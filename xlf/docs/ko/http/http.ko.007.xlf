<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="b9cbaf8eb79c9b8c4855be6b0eca34e758b86401" translate="yes" xml:space="preserve">
          <source>Specifies one or more protocol-level WebSocket extensions to ask the server to use. Using more than one &lt;code&gt;Sec-WebSocket-Extension&lt;/code&gt; header in a request is permitted; the result is the same as if you included all of the listed extensions in one such header.</source>
          <target state="translated">서버에서 사용하도록 요청하는 하나 이상의 프로토콜 레벨 WebSocket 확장을 지정합니다. 요청에 둘 이상의 &lt;code&gt;Sec-WebSocket-Extension&lt;/code&gt; 헤더를 사용하는 것이 허용됩니다. 결과는 나열된 헤더를 모두 하나의 헤더에 포함한 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e766075910421b2be9ca8f32bfa752ecb587b39f" translate="yes" xml:space="preserve">
          <source>Specifies origins that are allowed to see values of attributes retrieved via features of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;Resource Timing API&lt;/a&gt;, which would otherwise be reported as zero due to cross-origin restrictions.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;자원 타이밍 API의&lt;/a&gt; 기능을 통해 검색된 속성 값을 볼 수있는 출처를 지정합니다. 그렇지 않으면 교차 출처 제한으로 인해 0으로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="c2ecb07bbcb3e1be14696f3f86b19336ccf2cfdc" translate="yes" xml:space="preserve">
          <source>Specifies the URI to which the user agent should report Expect-CT failures.</source>
          <target state="translated">사용자 에이전트가 Expect-CT 실패를보고해야하는 URI를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="df8493e883fbdc515ef9ca1b5b0866d3e58f3660" translate="yes" xml:space="preserve">
          <source>Specifies the WebSocket protocol version the client wishes to use, so the server can confirm whether or not that version is supported on its end.</source>
          <target state="translated">클라이언트가 사용하려는 WebSocket 프로토콜 버전을 지정하여 서버가 해당 버전이 지원되는지 여부를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b4be09a1adcb38cab1a0e2686022154d066d8ba" translate="yes" xml:space="preserve">
          <source>Specifies the domain name of the server (for virtual hosting), and (optionally) the TCP port number on which the server is listening.</source>
          <target state="translated">서버의 도메인 이름 (가상 호스팅의 경우) 및 서버가 수신중인 TCP 포트 번호 (선택 사항)를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="efd15c591f12965b47534e1779aff0b7120829dc" translate="yes" xml:space="preserve">
          <source>Specifies the form of encoding used to safely transfer the entity to the user.</source>
          <target state="translated">엔터티를 사용자에게 안전하게 전송하는 데 사용되는 인코딩 형식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="413e001d0b162dbca41b0e7d35c867d5721df5a5" translate="yes" xml:space="preserve">
          <source>Specifies the lifetime of the policy, in seconds (in a similar way to e.g. HSTS policies are time-restricted). The referenced reporting group should have a lifetime at least as long as the NEL policy.</source>
          <target state="translated">정책의 수명을 초 단위로 지정합니다 (예 : HSTS 정책과 유사한 방식으로 시간 제한). 참조 된보고 그룹은 최소한 NEL 정책만큼 긴 수명을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="6d52f387eaf11730a59df918d4e3a112a2d99212" translate="yes" xml:space="preserve">
          <source>Specifies the maximum amount of time a resource will be considered fresh. Contrary to &lt;code&gt;Expires&lt;/code&gt;, this directive is relative to the time of the request.</source>
          <target state="translated">리소스가 최신 상태로 간주되는 최대 시간을 지정합니다. &lt;code&gt;Expires&lt;/code&gt; 와 달리이 지시문은 요청 시간과 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fef4478d76a150d6928212783b2ee9858bcd272" translate="yes" xml:space="preserve">
          <source>Specifies the method or methods allowed when accessing the resource in response to a preflight request.</source>
          <target state="translated">프리 플라이트 요청에 대한 응답으로 리소스에 액세스 할 때 허용되는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="495731834481a81b8123951704e2abcb07625db8" translate="yes" xml:space="preserve">
          <source>Specifies the methods allowed when accessing the resource in response to a preflight request.</source>
          <target state="translated">프리 플라이트 요청에 대한 응답으로 리소스에 액세스 할 때 허용되는 메서드를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="fa52c5dd51b37dc7727111c50a8217213608ca08" translate="yes" xml:space="preserve">
          <source>Specifies the number of seconds after reception of the &lt;code&gt;Expect-CT&lt;/code&gt; header field during which the user agent should regard the host from whom the message was received as a known Expect-CT host.</source>
          <target state="translated">사용자 에이전트가 메시지를 수신 한 호스트를 알려진 Expect-CT 호스트로 간주해야하는 &lt;code&gt;Expect-CT&lt;/code&gt; 헤더 필드를 수신 한 후의 시간 (초)을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="7f43b9fd51101abb87a0368fc81d197d96a63735" translate="yes" xml:space="preserve">
          <source>Specifies the origin &quot;null&quot;.</source>
          <target state="translated">원점 &quot;null&quot;을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="1ea81d80712300e661852f0c6af12a440f390050" translate="yes" xml:space="preserve">
          <source>Specifies the the form of encoding used to safely transfer the entity to the user.</source>
          <target state="translated">엔터티를 사용자에게 안전하게 전송하는 데 사용되는 인코딩 형식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="835c2397154f468b4c8ef93ba4c3e1aa7f2607eb" translate="yes" xml:space="preserve">
          <source>Specifies the transfer encodings the user agent is willing to accept.</source>
          <target state="translated">사용자 에이전트가 수락 할 전송 인코딩을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f30f059c03d4c3da1b77bd03fc6d7ad013fb12f4" translate="yes" xml:space="preserve">
          <source>Specifies those hosts to which the cookie will be sent. If not specified, defaults to the host portion of the current document location (but not including subdomains). Contrary to earlier specifications, leading dots in domain names are ignored. If a domain is specified, subdomains are always included.</source>
          <target state="translated">쿠키가 전송 될 호스트를 지정합니다. 지정하지 않으면 기본적으로 현재 문서 위치의 호스트 부분 (하위 도메인 제외)으로 설정됩니다. 이전 사양과 달리 도메인 이름의 선행 점은 무시됩니다. 도메인을 지정하면 하위 도메인이 항상 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="24167ab34816aa2157df161d6a2bd98aa1704455" translate="yes" xml:space="preserve">
          <source>Specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; 를&lt;/a&gt; 사용하여 페이지를 임베드 할 수있는 유효한 상위를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="3fa0df1c3795d4cdda9e9d0ae70ecf55400bafbc" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/WebRTC_API&quot;&gt;WebRTC&lt;/a&gt; connections.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/docs/Web/API/WebRTC_API&quot;&gt;WebRTC&lt;/a&gt; 연결에 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="2a90c719345e0d3bc78bace4ab1d3f64767f076c" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt; 스크립트에 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="d098bd02b96b2bdcbdaec1bb10a529856955c4ce" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소의 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="3b6311b937bff61b4874ab442d4d9dbb9f3cc22f" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for JavaScript inline event handlers.</source>
          <target state="translated">JavaScript 인라인 이벤트 핸들러의 유효한 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="cd49e94946949bc3d24a4291eb9f90caffd7e887" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for JavaScript.</source>
          <target state="translated">JavaScript의 유효한 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="282bf5eae963adccbd6d47d68520fe0a5c79b871" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt; 사용하여로드 된 글꼴의 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="db33d91daba98ebe85d45f79cd3a62539127fa18" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for inline styles applied to individual DOM elements.</source>
          <target state="translated">개별 DOM 요소에 적용된 인라인 스타일의 유효한 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="42f23c7f28c98c835d7c0a52c0e41c358dd15a49" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt;&lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track&quot;&gt; &lt;code&gt;&amp;lt;track&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 사용하여 미디어를로드하기위한 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="9dc2e0e19fce72e5227e4ed05399840422564be0" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 과 같은 요소를 사용하여 중첩 된 브라우징 컨텍스트로드에 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="ae55d19529942a4f7114ca5f6d12086fa3126f81" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for stylesheets &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; elements and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; elements with &lt;code&gt;rel=&quot;stylesheet&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rel=&quot;stylesheet&quot;&lt;/code&gt; 가있는&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; 시트 &amp;lt;style&amp;gt; 요소 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소의 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="a04b49e22cf0a5230eea588841a8a2b455c0bc3e" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for stylesheets.</source>
          <target state="translated">스타일 시트에 유효한 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c02deee0c3b25ce48a3b98b60fb3aad61652b709" translate="yes" xml:space="preserve">
          <source>Specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="fb673b2f31b191ea53966ff7ae48df6affc89e62" translate="yes" xml:space="preserve">
          <source>Specifies valid sources of application manifest files.</source>
          <target state="translated">유효한 응용 프로그램 매니페스트 파일 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2eb2af79b8a1a437680d977178946925ebbf2f7f" translate="yes" xml:space="preserve">
          <source>Specifies valid sources of images and favicons.</source>
          <target state="translated">유효한 이미지 및 파비콘 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="70ea0caeb914719c42a473dfe61a551bfbb951e5" translate="yes" xml:space="preserve">
          <source>Specifies valid sources to be prefetched or prerendered.</source>
          <target state="translated">프리 페치 또는 사전 렌더링 할 유효한 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="951baad47e3b7bd99fb8056c2485c87379c7b510" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;no-cache&lt;/code&gt; or &lt;code&gt;max-age=0&lt;/code&gt; indicates that clients can cache a resource and must revalidate each time before using it. This means HTTP request occurs each time, but it can skip downloading HTTP body if the content is valid.</source>
          <target state="translated">지정 &lt;code&gt;no-cache&lt;/code&gt; 또는 &lt;code&gt;max-age=0&lt;/code&gt; 클라이언트가 자원을 캐시 할 수 있습니다 그것을 사용하기 전에 때마다 재 검증해야 함을 나타냅니다. 즉, HTTP 요청이 매번 발생하지만 콘텐츠가 유효한 경우 HTTP 본문 다운로드를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e61777977f07fdafd61735735d76ae50997e152" translate="yes" xml:space="preserve">
          <source>Specifying a fallback policy</source>
          <target state="translated">대체 정책 지정</target>
        </trans-unit>
        <trans-unit id="3835c694b3a6ee97cfe71fb0cd1c9d794f4e48c3" translate="yes" xml:space="preserve">
          <source>Specifying legacy document modes*</source>
          <target state="translated">레거시 문서 모드 지정 *</target>
        </trans-unit>
        <trans-unit id="85f30ba6e5f19f51628bda67d9500dab94232f9a" translate="yes" xml:space="preserve">
          <source>Specifying multiple links</source>
          <target state="translated">여러 링크 지정</target>
        </trans-unit>
        <trans-unit id="f65d134dfe7e03e4b9a14898c4ef7cc4877bc321" translate="yes" xml:space="preserve">
          <source>Specifying multiple values is only supported in the &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP header, and not in the &lt;code&gt;referrerpolicy&lt;/code&gt; attribute.</source>
          <target state="translated">여러 값을 지정하는 것은 &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP 헤더 에서만 지원되며 &lt;code&gt;referrerpolicy&lt;/code&gt; 속성 에서는 지원 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b2bf4478d33594d8d9be5cf924dffa2d49ead910" translate="yes" xml:space="preserve">
          <source>Specifying your policy</source>
          <target state="translated">정책 지정</target>
        </trans-unit>
        <trans-unit id="f8a58e6474d46ef9548c5cf3e20d0bdc3d838946" translate="yes" xml:space="preserve">
          <source>Standard &lt;code&gt;Cache-Control&lt;/code&gt; directives that can be used by the client in an HTTP request.</source>
          <target state="translated">클라이언트가 HTTP 요청에서 사용할 수있는 표준 &lt;code&gt;Cache-Control&lt;/code&gt; 지시문.</target>
        </trans-unit>
        <trans-unit id="fc62e8bea8948c4f2c38c80d531e6ec6bc0f979f" translate="yes" xml:space="preserve">
          <source>Standard &lt;code&gt;Cache-Control&lt;/code&gt; directives that can be used by the server in an HTTP response.</source>
          <target state="translated">HTTP 응답에서 서버가 사용할 수있는 표준 &lt;code&gt;Cache-Control&lt;/code&gt; 지시문.</target>
        </trans-unit>
        <trans-unit id="7e4f48b87246ae2a22b36e2b02bbe847fa77f9da" translate="yes" xml:space="preserve">
          <source>Standardized methods are generic; that is, they are potentially
   applicable to any resource, not just one particular media type, kind
   of resource, or application.  As such, it is preferred that new
   methods be registered in a document that isn't specific to a single
   application or data format, since orthogonal technologies deserve
   orthogonal specification.

   Since message parsing (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7230]&lt;/a&gt;) needs to be
   independent of method semantics (aside from responses to HEAD),
   definitions of new methods cannot change the parsing algorithm or
   prohibit the presence of a message body on either the request or the
   response message.  Definitions of new methods can specify that only a
   zero-length message body is allowed by requiring a Content-Length
   header field with a value of &quot;0&quot;.

   A new method definition needs to indicate whether it is safe
   (&lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;), idempotent (&lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;), cacheable
   (&lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;), what semantics are to be associated with the payload
   body if any is present in the request and what refinements the method
   makes to header field or status code semantics.  If the new method is
   cacheable, its definition ought to describe how, and under what
   conditions, a cache can store a response and use it to satisfy a
   subsequent request.  The new method ought to describe whether it can
   be made conditional (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;) and, if so, how a server responds
   when the condition is false.  Likewise, if the new method might have
   some use for partial response semantics ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]), it ought to
   document this, too.

      Note: Avoid defining a method name that starts with &quot;M-&quot;, since
      that prefix might be misinterpreted as having the semantics
      assigned to it by [&lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC2774&lt;/a&gt;].</source>
          <target state="translated">표준화 된 방법은 일반적입니다. 즉, 하나의 특정 미디어 유형, 리소스 종류 또는 응용 프로그램뿐만 아니라 모든 리소스에 적용 할 수 있습니다. 이와 같이, 직교 기술은 직교 사양을 가질 가치가 있기 때문에 단일 방법 또는 데이터 형식에 국한되지 않은 문서에 새로운 방법을 등록하는 것이 바람직하다. 메시지 파싱 이후 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3&quot;&gt;[RFC7230]의 3.3 절&lt;/a&gt;)는 메소드 의미론 (HEAD에 대한 응답 제외)과 독립적이어야하며, 새로운 메소드의 정의는 구문 분석 알고리즘을 변경하거나 요청 또는 응답 메시지에서 메시지 본문의 존재를 금지 할 수 없습니다. 새 메소드의 정의는 값이 &quot;0&quot;인 Content-Length 헤더 필드를 요구하여 길이가 0 인 메시지 본문 만 허용되도록 지정할 수 있습니다. 새로운 분석법 정의는 안전한지 ( &lt;a href=&quot;#section-4.2.1&quot;&gt;섹션 4.2.1&lt;/a&gt; ), dem 등원 ( &lt;a href=&quot;#section-4.2.2&quot;&gt;섹션 4.2.2&lt;/a&gt; ), 캐시 가능 ( &lt;a href=&quot;#section-4.2.3&quot;&gt;섹션 4.2.3&lt;/a&gt; ) 여부를 표시해야합니다.), 요청에 존재하는 경우 페이로드 본문과 연관되는 의미 및 메소드가 헤더 필드 또는 상태 코드 의미를 개선하는 것. 새로운 방법이 캐시 가능한 경우, 그 정의는 캐시가 어떻게 그리고 어떤 조건 하에서 캐시가 응답을 저장하고 후속 요청을 만족시키는 데 사용할 수 있는지 설명해야합니다. 새로운 방법은 조건부로 작성 될 수 있는지 ( &lt;a href=&quot;#section-5.2&quot;&gt;섹션 5.2&lt;/a&gt; ), 그렇다면 조건이 거짓 일 때 서버가 어떻게 응답하는지 설명해야한다. 마찬가지로, 새로운 방법이 부분 응답 의미론을 사용할 수있는 경우 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]), 이것도 문서화해야합니다. 참고 : 접두어가 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC2774&lt;/a&gt; ]에 의해 지정된 의미가있는 것으로 잘못 해석 될 수 있으므로 &quot;M-&quot;으로 시작하는 메소드 이름을 정의하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="ec725f8ba620a293e9d02360be092dd295c3b54d" translate="yes" xml:space="preserve">
          <source>Start line</source>
          <target state="translated">출발 선</target>
        </trans-unit>
        <trans-unit id="e030402b999a37d4c6eb9f51e15b86c192ade5a6" translate="yes" xml:space="preserve">
          <source>Starting in Chrome 61, this applies to all of a frame's ancestors.</source>
          <target state="translated">Chrome 61부터는 프레임의 모든 조상에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="47374f68a6da45b7e6165e2b0f9740a82e30b4ff" translate="yes" xml:space="preserve">
          <source>Starting in Firefox 59, this applies to all of a frame's ancestors.</source>
          <target state="translated">Firefox 59부터는 프레임의 모든 조상에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6cbdee7a264558eb88d25ed8d267e476fca05cb7" translate="yes" xml:space="preserve">
          <source>Starting in Opera 48, this applies to all of a frame's ancestors.</source>
          <target state="translated">Opera 48부터는 프레임의 모든 조상에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b6deb6ef9aab80647d8c2b91f6b9f8ab6cffc3c1" translate="yes" xml:space="preserve">
          <source>Starting in Version 6, users can opt into using a GeckoView-based Focus for Android with a hidden preference: it uses a GeckoView UA string to advertise Gecko compatibility.</source>
          <target state="translated">버전 6부터 사용자는 숨겨진 환경 설정으로 GeckoView 기반 Android 용 Focus를 사용하도록 선택할 수 있습니다. GeckoView UA 문자열을 사용하여 Gecko 호환성을 알립니다.</target>
        </trans-unit>
        <trans-unit id="2767241100a2bb66d29b7ccd151257fc78abe38a" translate="yes" xml:space="preserve">
          <source>Starting with Chrome 52 and Firefox 52, insecure sites (&lt;code&gt;http:&lt;/code&gt;) can't set cookies with the &quot;secure&quot; directive anymore.</source>
          <target state="translated">Chrome 52 및 Firefox 52부터는 안전하지 않은 사이트 ( &lt;code&gt;http:&lt;/code&gt; :)가 더 이상 &quot;보안&quot;지시문으로 쿠키를 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2777fe7b39631e05febcca00592a28a86bb5182f" translate="yes" xml:space="preserve">
          <source>Starting with Chrome 52 and Firefox 52, insecure sites (&lt;code&gt;http:&lt;/code&gt;) can't set cookies with the &lt;code&gt;Secure&lt;/code&gt; attribute anymore.</source>
          <target state="translated">Chrome 52 및 Firefox 52부터 안전하지 않은 사이트 ( &lt;code&gt;http:&lt;/code&gt; :) 는 더 이상 &lt;code&gt;Secure&lt;/code&gt; 속성으로 쿠키를 설정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="bb7d21aec22143da2cc4da25c435e7bb29874f8d" translate="yes" xml:space="preserve">
          <source>Starting with Firefox 72, the opting out of MIME sniffing is also applied to top-level documents if a &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-type&lt;/code&gt;&lt;/a&gt; is provided. This can cause HTML web pages to be downloaded instead of being rendered when they are served with a MIME type other than &lt;code&gt;text/html&lt;/code&gt;. Make sure to set both headers correctly.</source>
          <target state="translated">Firefox 72부터는 &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-type&lt;/code&gt; &lt;/a&gt; 이 제공되는 경우 MIME 스니핑 옵트 아웃이 최상위 문서에도 적용 됩니다. 이로 인해 HTML 웹 페이지가 &lt;code&gt;text/html&lt;/code&gt; 이외의 MIME 유형으로 제공 될 때 렌더링되는 대신 다운로드 될 수 있습니다 . 두 헤더를 모두 올바르게 설정했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bae7d5be70820ed56467bd9a63744e23b47bd711" translate="yes" xml:space="preserve">
          <source>Status</source>
          <target state="translated">Status</target>
        </trans-unit>
        <trans-unit id="f7b7abf0e2e9d417ae8391f4a4fe7d726ce87d19" translate="yes" xml:space="preserve">
          <source>Status Code Definitions (RFC 2616)</source>
          <target state="translated">상태 코드 정의 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="79f8bb09cc70b71ab1e11fda8d1499287de0d9e4" translate="yes" xml:space="preserve">
          <source>Status line</source>
          <target state="translated">상태 표시 줄</target>
        </trans-unit>
        <trans-unit id="8f42525bc1bf257516b4843747d743c365504980" translate="yes" xml:space="preserve">
          <source>Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Abstract

   The Atom Publishing Protocol (AtomPub) is an application-level
   protocol for publishing and editing Web resources.  The protocol is
   based on HTTP transfer of Atom-formatted representations.  The Atom
   format is documented in the Atom Syndication Format. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Notational Conventions 
      &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;. XML-Related Conventions 
           &lt;a href=&quot;#section-2.1.1&quot;&gt;2.1.1&lt;/a&gt;. Referring to Information Items 
           &lt;a href=&quot;#section-2.1.2&quot;&gt;2.1.2&lt;/a&gt;. RELAX NG Schema 
           &lt;a href=&quot;#section-2.1.3&quot;&gt;2.1.3&lt;/a&gt;. Use of &quot;xml:base&quot; and &quot;xml:lang&quot; 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Terminology 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Protocol Model 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. Identity and Naming 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Documents and Resource Classification 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Control and Publishing 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. Client Implementation Considerations 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Protocol Operations 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. Retrieving a Service Document 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Listing Collection Members 
      &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;. Creating a Resource 
      &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;. Editing a Resource 
           &lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1&lt;/a&gt;. Retrieving a Resource 
           &lt;a href=&quot;#section-5.4.2&quot;&gt;5.4.2&lt;/a&gt;. Editing a Resource 
           &lt;a href=&quot;#section-5.4.3&quot;&gt;5.4.3&lt;/a&gt;. Deleting a Resource 
      &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt;. Use of HTTP Response Codes 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Protocol Documents 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Document Types 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. Document Extensibility 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Category Documents 
      &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;. Example 
      &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;. Element Definitions 
           &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt;. The &quot;app:categories&quot; Element 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. Service Documents 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Workspaces 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Example 
      &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;. Element Definitions 
           &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;. The &quot;app:service&quot; Element 
           &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt;. The &quot;app:workspace&quot; Element 
           &lt;a href=&quot;#section-8.3.3&quot;&gt;8.3.3&lt;/a&gt;. The &quot;app:collection&quot; Element 
           &lt;a href=&quot;#section-8.3.4&quot;&gt;8.3.4&lt;/a&gt;. The &quot;app:accept&quot; Element 
           &lt;a href=&quot;#section-8.3.5&quot;&gt;8.3.5&lt;/a&gt;. Usage in Atom Feed Documents 
           &lt;a href=&quot;#section-8.3.6&quot;&gt;8.3.6&lt;/a&gt;. The &quot;app:categories&quot; Element 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. Creating and Editing Resources 
      &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;. Member URIs 
      &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;. Creating Resources with POST 
           &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;. Example 
      &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;. Editing Resources with PUT 
      &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;. Deleting Resources with DELETE 
      &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;. Caching and Entity Tags 
           &lt;a href=&quot;#section-9.5.1&quot;&gt;9.5.1&lt;/a&gt;. Example ............................................ 

      &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;. Media Resources and Media Link Entries 
           &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;. Examples 
      &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;. The Slug Header 
           &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt;. Slug Header Syntax 
           &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt;. Example 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. Listing Collections 
      &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;. Collection Partial Lists 
      &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;. The &quot;app:edited&quot; Element 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;. Atom Format Link Relation Extensions 
      &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;. The &quot;edit&quot; Link Relation 
      &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;. The &quot;edit-media&quot; Link Relation 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;. The Atom Format Type Parameter 
      &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;. The &quot;type&quot; parameter 
           &lt;a href=&quot;#section-12.1.1&quot;&gt;12.1.1&lt;/a&gt;. Conformance 
   &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;. Atom Publishing Controls 
      &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt;. The &quot;app:control&quot; Element 
           &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt;. The &quot;app:draft&quot; Element 
   &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;. Securing the Atom Publishing Protocol 
   &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt;. Denial of Service 
      &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt;. Replay Attacks 
      &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt;. Spoofing Attacks 
      &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt;. Linked Resources 
      &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt;. Digital Signatures and Encryption 
      &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt;. URIs and IRIs 
      &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt;. Code Injection and Cross Site Scripting 
   &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-16.1&quot;&gt;16.1&lt;/a&gt;. Content-Type Registration for 'application/atomcat+xml' ..39
      &lt;a href=&quot;#section-16.2&quot;&gt;16.2&lt;/a&gt;. Content-Type Registration for 'application/atomsvc+xml' ..40
      &lt;a href=&quot;#section-16.3&quot;&gt;16.3&lt;/a&gt;. Header Field Registration for 'SLUG' 
      &lt;a href=&quot;#section-16.4&quot;&gt;16.4&lt;/a&gt;. The Link Relation Registration &quot;edit&quot; 
      &lt;a href=&quot;#section-16.5&quot;&gt;16.5&lt;/a&gt;. The Link Relation Registration &quot;edit-media&quot; 
      &lt;a href=&quot;#section-16.6&quot;&gt;16.6&lt;/a&gt;. The Atom Format Media Type Parameter 
   &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;. References 
      &lt;a href=&quot;#section-17.1&quot;&gt;17.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-17.2&quot;&gt;17.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. Contributors 
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. RELAX NG Compact Schema ...............................</source>
          <target state="translated">이 메모의 상태이 문서는 인터넷 커뮤니티를위한 인터넷 표준 추적 프로토콜을 지정하고 개선을위한 토론과 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태는 &quot;인터넷 공식 프로토콜 표준&quot;(STD 1)의 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다. Abstract AtomPub (Atom Publishing Protocol)는 웹 리소스를 게시하고 편집하기위한 응용 프로그램 수준 프로토콜입니다. 프로토콜은 Atom 형식 표현의 HTTP 전송을 기반으로합니다. Atom 형식은 Atom Syndication Format에 문서화되어 있습니다. 목차 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; . 소개 &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; . 표기법 &lt;a href=&quot;#section-2.1&quot;&gt;2.1 &lt;/a&gt; . XML 관련 규칙 &lt;a href=&quot;#section-2.1.1&quot;&gt;2.1.1&lt;/a&gt; . 정보 항목 참조 &lt;a href=&quot;#section-2.1.2&quot;&gt;2.1.2&lt;/a&gt; . RELAX NG 스키마 &lt;a href=&quot;#section-2.1.3&quot;&gt;2.1.3&lt;/a&gt; . &quot;xml : base&quot;및 &quot;xml : lang&quot;사용 &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; . 용어 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; . 프로토콜 모델 &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; . 아이디와 이름 지정 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . 문서 및 자원 분류 &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; . 컨트롤과 퍼블리싱 &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; . 클라이언트 구현 고려 사항 &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; . 프로토콜 운영 &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; . 서비스 문서 검색 &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; . 컬렉션 멤버 나열 &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; . 리소스 생성 &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt; . 자원 편집 &lt;a href=&quot;#section-5.4.1&quot;&gt; 5.4.1&lt;/a&gt; . 리소스 검색 &lt;a href=&quot;#section-5.4.2&quot;&gt;5.4.2&lt;/a&gt; . 자원 편집 &lt;a href=&quot;#section-5.4.3&quot;&gt;5.4.3&lt;/a&gt; . 자원 삭제 &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt; . HTTP 응답 코드 사용 &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; . 임상 시험 계획서 문서 &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt; . 문서 유형 &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; . 문서 확장 성 &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; . 카테고리 문서 &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; . 예 &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt; . 요소 정의 &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt; . &quot;app : categories&quot;요소 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; . 서비스 문서 &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; . 작업 공간 &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; . 예 &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt; . 요소 정의 &lt;a href=&quot;#section-8.3.1&quot;&gt; 8.3.1&lt;/a&gt; . &quot;app : service&quot;요소 &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt; . &quot;app : workspace&quot;요소 &lt;a href=&quot;#section-8.3.3&quot;&gt;8.3.3&lt;/a&gt; . &quot;app : collection&quot;요소 &lt;a href=&quot;#section-8.3.4&quot;&gt;8.3.4&lt;/a&gt; . &quot;app : accept&quot;요소 &lt;a href=&quot;#section-8.3.5&quot;&gt;8.3.5&lt;/a&gt; . Atom Feed Documents에서의 사용법 &lt;a href=&quot;#section-8.3.6&quot;&gt;8.3.6&lt;/a&gt; . &quot;app : categories&quot;요소 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt; . 자원 작성 및 편집 &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; . 멤버 URI &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt; . POST와 자원 작성 &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt; . 예 &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt; . PUT을 사용하여 리소스 편집 &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt; . DELETE를 사용하여 리소스 삭제&lt;a href=&quot;#section-9.5&quot;&gt; 9.5&lt;/a&gt; . 캐싱 및 엔터티 태그 &lt;a href=&quot;#section-9.5.1&quot;&gt;9.5.1&lt;/a&gt; . 예 ................................................................ &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt; . 미디어 리소스 및 미디어 링크 항목 &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt; . 실시 예 &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt; . 슬러그 헤더 &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt; . 슬러그 헤더 구문 &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt; . 실시 예 &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt; . 컬렉션 나열 &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; . 컬렉션 부분 목록 &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt; . &quot;app : edited&quot;요소 &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt; . 원자 형식 링크 관계 확장 &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt; . &quot;편집&quot;링크 관계 &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt; . &quot;편집 매체&quot;링크 관계 &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt; . 원자 형식 유형 매개 변수 &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt; . &quot;type&quot;매개 변수 &lt;a href=&quot;#section-12.1.1&quot;&gt;12.1.1&lt;/a&gt; . 적합성 &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt; . 아톰 퍼블리싱 컨트롤 &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt; . &quot;app : control&quot;요소 &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt; . &quot;app : draft&quot;요소 &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt; . Atom 게시 프로토콜 보안 &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt; . 보안 고려 사항 &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt; . 서비스 거부 &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt; . 리플레이 공격 &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt; . 스푸핑 공격 &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt; . 링크 된 리소스 &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt; . 디지털 서명 및 암호화 &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt; . URI 및 IRI &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt; . 코드 삽입 및 크로스 사이트 스크립팅 &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt; . IANA 고려 사항 &lt;a href=&quot;#section-16.1&quot;&gt;16.1&lt;/a&gt; . 'application / atomcat + xml'의 컨텐츠 유형 등록 ..39 &lt;a href=&quot;#section-16.2&quot;&gt;16.2&lt;/a&gt; . 'application / atomsvc ​​+ xml'의 컨텐츠 유형 등록 ..40 &lt;a href=&quot;#section-16.3&quot;&gt;16.3&lt;/a&gt; . 'SLUG'에 대한 헤더 필드 등록 &lt;a href=&quot;#section-16.4&quot;&gt;16.4&lt;/a&gt; . 링크 관계 등록 &quot;편집&quot; &lt;a href=&quot;#section-16.5&quot;&gt;16.5&lt;/a&gt; . 링크 관계 등록 &quot;edit-media&quot; &lt;a href=&quot;#section-16.6&quot;&gt;16.6&lt;/a&gt; . 원자 형식 매체 유형 매개 변수 &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt; . 참고 문헌 &lt;a href=&quot;#section-17.1&quot;&gt;17.1&lt;/a&gt; . 규범 참조 &lt;a href=&quot;#section-17.2&quot;&gt;17.2&lt;/a&gt; . 유익한 참고 자료 &lt;a href=&quot;#appendix-A&quot;&gt;부록 A&lt;/a&gt;. 참여자 &lt;a href=&quot;#appendix-B&quot;&gt;부록 B&lt;/a&gt; . RELAX NG 컴팩트 스키마 ...............................</target>
        </trans-unit>
        <trans-unit id="bba4ada33d7f6d8a86341c33e255f61ec01eb34d" translate="yes" xml:space="preserve">
          <source>Status of This Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The IETF Trust (2007).

Abstract

   Web Distributed Authoring and Versioning (WebDAV) consists of a set
   of methods, headers, and content-types ancillary to HTTP/1.1 for the
   management of resource properties, creation and management of
   resource collections, URL namespace manipulation, and resource
   locking (collision avoidance).

   &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; was published in February 1999, and this specification
   obsoletes &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; with minor revisions mostly due to
   interoperability experience. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Notational Conventions 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Terminology 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Data Model for Resource Properties 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. The Resource Property Model 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Properties and HTTP Headers 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Property Values 
           &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt;. Example - Property with Mixed Content 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. Property Names 
      &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt;. Source Resources and Output Resources 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Collections of Web Resources 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. HTTP URL Namespace Model 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Collection Resources 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Locking 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Lock Model 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. Exclusive vs. Shared Locks 
      &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;. Required Support 
      &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt;. Lock Creator and Privileges 
      &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt;. Lock Tokens 
      &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt;. Lock Timeout 
      &lt;a href=&quot;#section-6.7&quot;&gt;6.7&lt;/a&gt;. Lock Capability Discovery 
      &lt;a href=&quot;#section-6.8&quot;&gt;6.8&lt;/a&gt;. Active Lock Discovery 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Write Lock 
      &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;. Write Locks and Properties 
      &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;. Avoiding Lost Updates 
      &lt;a href=&quot;#section-7.3&quot;&gt;7.3&lt;/a&gt;. Write Locks and Unmapped URLs 
      &lt;a href=&quot;#section-7.4&quot;&gt;7.4&lt;/a&gt;. Write Locks and Collections 
      &lt;a href=&quot;#section-7.5&quot;&gt;7.5&lt;/a&gt;. Write Locks and the If Request Header 
           &lt;a href=&quot;#section-7.5.1&quot;&gt;7.5.1&lt;/a&gt;. Example - Write Lock and COPY 
           7.5.2. Example - Deleting a Member of a Locked
                  Collection 
      &lt;a href=&quot;#section-7.6&quot;&gt;7.6&lt;/a&gt;. Write Locks and COPY/MOVE 
      &lt;a href=&quot;#section-7.7&quot;&gt;7.7&lt;/a&gt;. Refreshing Write Locks 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. General Request and Response Handling 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Precedence in Error Handling 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Use of XML 
      &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;. URL Handling 
           &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;. Example - Correct URL Handling 
      &lt;a href=&quot;#section-8.4&quot;&gt;8.4&lt;/a&gt;. Required Bodies in Requests 
      &lt;a href=&quot;#section-8.5&quot;&gt;8.5&lt;/a&gt;. HTTP Headers for Use in WebDAV 
      &lt;a href=&quot;#section-8.6&quot;&gt;8.6&lt;/a&gt;. ETag 
      &lt;a href=&quot;#section-8.7&quot;&gt;8.7&lt;/a&gt;. Including Error Response Bodies 
      &lt;a href=&quot;#section-8.8&quot;&gt;8.8&lt;/a&gt;. Impact of Namespace Operations on Cache Validators 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. HTTP Methods for Distributed Authoring 
      &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;. PROPFIND Method 
           &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt;. PROPFIND Status Codes .............................. 

           &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;. Status Codes for Use in 'propstat' Element 
           &lt;a href=&quot;#section-9.1.3&quot;&gt;9.1.3&lt;/a&gt;. Example - Retrieving Named Properties 
           9.1.4. Example - Using 'propname' to Retrieve All
                  Property Names 
           &lt;a href=&quot;#section-9.1.5&quot;&gt;9.1.5&lt;/a&gt;. Example - Using So-called 'allprop' 
           &lt;a href=&quot;#section-9.1.6&quot;&gt;9.1.6&lt;/a&gt;. Example - Using 'allprop' with 'include' 
      &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;. PROPPATCH Method 
           &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;. Status Codes for Use in 'propstat' Element 
           &lt;a href=&quot;#section-9.2.2&quot;&gt;9.2.2&lt;/a&gt;. Example - PROPPATCH 
      &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;. MKCOL Method 
           &lt;a href=&quot;#section-9.3.1&quot;&gt;9.3.1&lt;/a&gt;. MKCOL Status Codes 
           &lt;a href=&quot;#section-9.3.2&quot;&gt;9.3.2&lt;/a&gt;. Example - MKCOL 
      &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;. GET, HEAD for Collections 
      &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;. POST for Collections 
      &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;. DELETE Requirements 
           &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;. DELETE for Collections 
           &lt;a href=&quot;#section-9.6.2&quot;&gt;9.6.2&lt;/a&gt;. Example - DELETE 
      &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;. PUT Requirements 
           &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt;. PUT for Non-Collection Resources 
           &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt;. PUT for Collections 
      &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt;. COPY Method 
           &lt;a href=&quot;#section-9.8.1&quot;&gt;9.8.1&lt;/a&gt;. COPY for Non-collection Resources 
           &lt;a href=&quot;#section-9.8.2&quot;&gt;9.8.2&lt;/a&gt;. COPY for Properties 
           &lt;a href=&quot;#section-9.8.3&quot;&gt;9.8.3&lt;/a&gt;. COPY for Collections 
           &lt;a href=&quot;#section-9.8.4&quot;&gt;9.8.4&lt;/a&gt;. COPY and Overwriting Destination Resources 
           &lt;a href=&quot;#section-9.8.5&quot;&gt;9.8.5&lt;/a&gt;. Status Codes 
           &lt;a href=&quot;#section-9.8.6&quot;&gt;9.8.6&lt;/a&gt;. Example - COPY with Overwrite 
           &lt;a href=&quot;#section-9.8.7&quot;&gt;9.8.7&lt;/a&gt;. Example - COPY with No Overwrite 
           &lt;a href=&quot;#section-9.8.8&quot;&gt;9.8.8&lt;/a&gt;. Example - COPY of a Collection 
      &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;. MOVE Method 
           &lt;a href=&quot;#section-9.9.1&quot;&gt;9.9.1&lt;/a&gt;. MOVE for Properties 
           &lt;a href=&quot;#section-9.9.2&quot;&gt;9.9.2&lt;/a&gt;. MOVE for Collections 
           &lt;a href=&quot;#section-9.9.3&quot;&gt;9.9.3&lt;/a&gt;. MOVE and the Overwrite Header 
           &lt;a href=&quot;#section-9.9.4&quot;&gt;9.9.4&lt;/a&gt;. Status Codes 
           &lt;a href=&quot;#section-9.9.5&quot;&gt;9.9.5&lt;/a&gt;. Example - MOVE of a Non-Collection 
           &lt;a href=&quot;#section-9.9.6&quot;&gt;9.9.6&lt;/a&gt;. Example - MOVE of a Collection 
      &lt;a href=&quot;#section-9.10&quot;&gt;9.10&lt;/a&gt;. LOCK Method 
           &lt;a href=&quot;#section-9.10.1&quot;&gt;9.10.1&lt;/a&gt;. Creating a Lock on an Existing Resource 
           &lt;a href=&quot;#section-9.10.2&quot;&gt;9.10.2&lt;/a&gt;. Refreshing Locks 
           &lt;a href=&quot;#section-9.10.3&quot;&gt;9.10.3&lt;/a&gt;. Depth and Locking 
           &lt;a href=&quot;#section-9.10.4&quot;&gt;9.10.4&lt;/a&gt;. Locking Unmapped URLs 
           &lt;a href=&quot;#section-9.10.5&quot;&gt;9.10.5&lt;/a&gt;. Lock Compatibility Table 
           &lt;a href=&quot;#section-9.10.6&quot;&gt;9.10.6&lt;/a&gt;. LOCK Responses 
           &lt;a href=&quot;#section-9.10.7&quot;&gt;9.10.7&lt;/a&gt;. Example - Simple Lock Request 
           &lt;a href=&quot;#section-9.10.8&quot;&gt;9.10.8&lt;/a&gt;. Example - Refreshing a Write Lock 
           &lt;a href=&quot;#section-9.10.9&quot;&gt;9.10.9&lt;/a&gt;. Example - Multi-Resource Lock Request 
      &lt;a href=&quot;#section-9.11&quot;&gt;9.11&lt;/a&gt;. UNLOCK Method 
           &lt;a href=&quot;#section-9.11.1&quot;&gt;9.11.1&lt;/a&gt;. Status Codes ...................................... 

           &lt;a href=&quot;#section-9.11.2&quot;&gt;9.11.2&lt;/a&gt;. Example - UNLOCK 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. HTTP Headers for Distributed Authoring 
      &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;. DAV Header 
      &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;. Depth Header 
      &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt;. Destination Header 
      &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt;. If Header 
           &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt;. Purpose 
           &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt;. Syntax 
           &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt;. List Evaluation 
           &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;. Matching State Tokens and ETags 
           &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt;. If Header and Non-DAV-Aware Proxies 
           &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt;. Example - No-tag Production 
           &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt;. Example - Using &quot;Not&quot; with No-tag Production 
           10.4.8. Example - Causing a Condition to Always
                   Evaluate to True 
           &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt;. Example - Tagged List If Header in COPY 
           10.4.10. Example - Matching Lock Tokens with
                    Collection Locks 
           &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt;. Example - Matching ETags on Unmapped URLs 
      &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt;. Lock-Token Header 
      &lt;a href=&quot;#section-10.6&quot;&gt;10.6&lt;/a&gt;. Overwrite Header 
      &lt;a href=&quot;#section-10.7&quot;&gt;10.7&lt;/a&gt;. Timeout Request Header 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;. Status Code Extensions to HTTP/1.1 
      &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;. 207 Multi-Status 
      &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;. 422 Unprocessable Entity 
      &lt;a href=&quot;#section-11.3&quot;&gt;11.3&lt;/a&gt;. 423 Locked 
      &lt;a href=&quot;#section-11.4&quot;&gt;11.4&lt;/a&gt;. 424 Failed Dependency 
      &lt;a href=&quot;#section-11.5&quot;&gt;11.5&lt;/a&gt;. 507 Insufficient Storage 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;. Use of HTTP Status Codes 
      &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;. 412 Precondition Failed 
      &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt;. 414 Request-URI Too Long 
   &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;. Multi-Status Response 
      &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt;. Response Headers 
      &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;. Handling Redirected Child Resources 
      &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt;. Internal Status Codes 
   &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;. XML Element Definitions 
      &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt;. activelock XML Element 
      &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt;. allprop XML Element 
      &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt;. collection XML Element 
      &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt;. depth XML Element 
      &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt;. error XML Element 
      &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt;. exclusive XML Element 
      &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt;. href XML Element 
      &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;. include XML Element 
      &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;. location XML Element 
      &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt;. lockentry XML Element 
      &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;. lockinfo XML Element 
      &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt;. lockroot XML Element .................................... 

      &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt;. lockscope XML Element 
      &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt;. locktoken XML Element 
      &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt;. locktype XML Element 
      &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;. multistatus XML Element 
      &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;. owner XML Element 
      &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt;. prop XML Element 
      &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;. propertyupdate XML Element 
      &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;. propfind XML Element 
      &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt;. propname XML Element 
      &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt;. propstat XML Element 
      &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt;. remove XML Element 
      &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;. response XML Element 
      &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt;. responsedescription XML Element 
      &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;. set XML Element 
      &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt;. shared XML Element 
      &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt;. status XML Element 
      &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt;. timeout XML Element 
      &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt;. write XML Element 
   &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt;. DAV Properties 
   &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;. Precondition/Postcondition XML Elements 
   &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;. XML Extensibility in DAV 
   &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt;. DAV Compliance Classes 
      &lt;a href=&quot;#section-18.1&quot;&gt;18.1&lt;/a&gt;. Class 1 
      &lt;a href=&quot;#section-18.2&quot;&gt;18.2&lt;/a&gt;. Class 2 
      &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt;. Class 3 
   &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt;. Internationalization Considerations 
   &lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-20.1&quot;&gt;20.1&lt;/a&gt;. Authentication of Clients 
      &lt;a href=&quot;#section-20.2&quot;&gt;20.2&lt;/a&gt;. Denial of Service 
      &lt;a href=&quot;#section-20.3&quot;&gt;20.3&lt;/a&gt;. Security through Obscurity 
      &lt;a href=&quot;#section-20.4&quot;&gt;20.4&lt;/a&gt;. Privacy Issues Connected to Locks 
      &lt;a href=&quot;#section-20.5&quot;&gt;20.5&lt;/a&gt;. Privacy Issues Connected to Properties 
      &lt;a href=&quot;#section-20.6&quot;&gt;20.6&lt;/a&gt;. Implications of XML Entities 
      &lt;a href=&quot;#section-20.7&quot;&gt;20.7&lt;/a&gt;. Risks Connected with Lock Tokens 
      &lt;a href=&quot;#section-20.8&quot;&gt;20.8&lt;/a&gt;. Hosting Malicious Content 
   &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-21.1&quot;&gt;21.1&lt;/a&gt;. New URI Schemes 
      &lt;a href=&quot;#section-21.2&quot;&gt;21.2&lt;/a&gt;. XML Namespaces 
      &lt;a href=&quot;#section-21.3&quot;&gt;21.3&lt;/a&gt;. Message Header Fields 
           &lt;a href=&quot;#section-21.3.1&quot;&gt;21.3.1&lt;/a&gt;. DAV 
           &lt;a href=&quot;#section-21.3.2&quot;&gt;21.3.2&lt;/a&gt;. Depth 
           &lt;a href=&quot;#section-21.3.3&quot;&gt;21.3.3&lt;/a&gt;. Destination 
           &lt;a href=&quot;#section-21.3.4&quot;&gt;21.3.4&lt;/a&gt;. If 
           &lt;a href=&quot;#section-21.3.5&quot;&gt;21.3.5&lt;/a&gt;. Lock-Token 
           &lt;a href=&quot;#section-21.3.6&quot;&gt;21.3.6&lt;/a&gt;. Overwrite 
           &lt;a href=&quot;#section-21.3.7&quot;&gt;21.3.7&lt;/a&gt;. Timeout 
      &lt;a href=&quot;#section-21.4&quot;&gt;21.4&lt;/a&gt;. HTTP Status Codes 
   &lt;a href=&quot;#section-22&quot;&gt;22&lt;/a&gt;. Acknowledgements ............................................. 

   &lt;a href=&quot;#section-23&quot;&gt;23&lt;/a&gt;. Contributors to This Specification 
   &lt;a href=&quot;#section-24&quot;&gt;24&lt;/a&gt;. Authors of &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;&lt;a href=&quot;#section-25&quot;&gt;25&lt;/a&gt;. References 
      &lt;a href=&quot;#section-25.1&quot;&gt;25.1&lt;/a&gt;. Normative References
      &lt;a href=&quot;#section-25.2&quot;&gt;25.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;.  Notes on Processing XML Elements 
      &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1&lt;/a&gt;. Notes on Empty XML Elements 
      &lt;a href=&quot;#appendix-A.2&quot;&gt;A.2&lt;/a&gt;. Notes on Illegal XML Processing 
      &lt;a href=&quot;#appendix-A.3&quot;&gt;A.3&lt;/a&gt;. Example - XML Syntax Error 
      &lt;a href=&quot;#appendix-A.4&quot;&gt;A.4&lt;/a&gt;. Example - Unexpected XML Element 
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. Notes on HTTP Client Compatibility 
   &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;. The 'opaquelocktoken' Scheme and URIs 
   &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt;. Lock-null Resources 
      &lt;a href=&quot;#appendix-D.1&quot;&gt;D.1&lt;/a&gt;. Guidance for Clients Using LOCK to Create Resources 
   &lt;a href=&quot;#appendix-E&quot;&gt;Appendix E&lt;/a&gt;. Guidance for Clients Desiring to Authenticate 
   &lt;a href=&quot;#appendix-F&quot;&gt;Appendix F&lt;/a&gt;. Summary of Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;&lt;a href=&quot;#appendix-F.1&quot;&gt;F.1&lt;/a&gt;. Changes for Both Client and Server Implementations 
      &lt;a href=&quot;#appendix-F.2&quot;&gt;F.2&lt;/a&gt;. Changes for Server Implementations 
      &lt;a href=&quot;#appendix-F.3&quot;&gt;F.3&lt;/a&gt;. Other Changes ............................................</source>
          <target state="translated">이 메모의 상태이 문서는 인터넷 커뮤니티를위한 인터넷 표준 추적 프로토콜을 지정하고 개선을위한 토론과 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태는 &quot;인터넷 공식 프로토콜 표준&quot;(STD 1)의 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다. 저작권 공지 저작권 (C) IETF 트러스트 (2007). WebDAV (Web Distributed Authoring and Versioning)는 자원 등록 정보 관리, 자원 콜렉션 작성 및 관리, URL 네임 스페이스 조작 및 자원 잠금 (충돌)을 위해 HTTP / 1.1에 부가되는 일련의 메소드, 헤더 및 컨텐츠 유형으로 구성됩니다. 기피). &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;이 사양 은 상호 운용성 경험으로 인해 약간 수정 된 &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; 을 더 이상 사용하지 않습니다 . 목차 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; . 소개 &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; . 표기법 &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; . 용어 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; . 자원 등록 정보의 데이터 모델 &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; . 자원 속성 모델 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . 등록 정보 및 HTTP 헤더 &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; . 속성 값 &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt; . 예-내용이 혼합 된 속성 &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; . 속성 이름 &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt; . 소스 리소스 및 출력 리소스 &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. 웹 자료 모음 &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; . HTTP URL 네임 스페이스 모델 &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; . 수집 자료 &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; . 잠금 &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt; . 모델 잠금 &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; . 배타적 잠금과 공유 잠금 &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; . 필요한 지원 &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt; . 잠금 생성기 및 권한 &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt; . 잠금 토큰 &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt; . 잠금 시간 종료 &lt;a href=&quot;#section-6.7&quot;&gt;6.7&lt;/a&gt; . 잠금 기능 발견 &lt;a href=&quot;#section-6.8&quot;&gt;6.8&lt;/a&gt; . 활성 잠금 발견 &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; . 쓰기 잠금 &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; . 쓰기 잠금 및 속성 &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt; . 손실 된 업데이트 방지 &lt;a href=&quot;#section-7.3&quot;&gt;7.3&lt;/a&gt;. 쓰기 잠금 및 매핑되지 않은 URL &lt;a href=&quot;#section-7.4&quot;&gt;7.4&lt;/a&gt; . 쓰기 잠금 및 모음 &lt;a href=&quot;#section-7.5&quot;&gt;7.5&lt;/a&gt; . 쓰기 잠금 및 If 요청 헤더 &lt;a href=&quot;#section-7.5.1&quot;&gt;7.5.1&lt;/a&gt; . 예-쓰기 잠금 및 복사 7.5.2. 예-잠긴 컬렉션의 멤버 삭제 &lt;a href=&quot;#section-7.6&quot;&gt;7.6&lt;/a&gt; . 쓰기 잠금 및 복사 / 이동 &lt;a href=&quot;#section-7.7&quot;&gt;7.7&lt;/a&gt; . 쓰기 잠금 새로 고침 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; . 일반적인 요청 및 응답 처리 &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; . 에러 처리의 우선 순위 &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; . XML 사용 &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt; . URL 처리 &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt; . 예-올바른 URL 처리 &lt;a href=&quot;#section-8.4&quot;&gt;8.4&lt;/a&gt;. 요청에 필요한 기관 &lt;a href=&quot;#section-8.5&quot;&gt;8.5&lt;/a&gt; . WebDAV &lt;a href=&quot;#section-8.6&quot;&gt;8.6&lt;/a&gt; 에서 사용하기위한 HTTP 헤더 . ETag &lt;a href=&quot;#section-8.7&quot;&gt;8.7&lt;/a&gt; . 에러 응답 바디 포함 &lt;a href=&quot;#section-8.8&quot;&gt;8.8&lt;/a&gt; . 캐시 유효성 검사기에 대한 네임 스페이스 작업의 영향 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt; . 분산 저작을위한 HTTP 메소드 &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; . PROPFIND 방법 &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt; . PROPFIND 상태 코드 .............................. &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt; . 'propstat'요소에 사용하기위한 상태 코드 &lt;a href=&quot;#section-9.1.3&quot;&gt;9.1.3&lt;/a&gt; . 예-명명 된 속성 검색 9.1.4. 예- 'propname'을 사용하여 모든 속성 이름 검색 &lt;a href=&quot;#section-9.1.5&quot;&gt;9.1.5&lt;/a&gt;. 예-소위 'allprop'사용 &lt;a href=&quot;#section-9.1.6&quot;&gt;9.1.6&lt;/a&gt; . 예- 'include'와 함께 'allprop'사용 &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt; . PROPPATCH 방법 &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt; . 'propstat'요소에 사용하기위한 상태 코드 &lt;a href=&quot;#section-9.2.2&quot;&gt;9.2.2&lt;/a&gt; . 예-PROPPATCH &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt; . MKCOL 방법 &lt;a href=&quot;#section-9.3.1&quot;&gt;9.3.1&lt;/a&gt; . MKCOL 상태 코드 &lt;a href=&quot;#section-9.3.2&quot;&gt;9.3.2&lt;/a&gt; . 예-MKCOL &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt; . 컬렉션 헤드 가져 오기 &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt; . 컬렉션을위한 POST &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt; . 삭제 요구 사항 &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt; . 컬렉션 삭제 &lt;a href=&quot;#section-9.6.2&quot;&gt;9.6.2&lt;/a&gt; . 예 - DELETE &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;. PUT 요구 사항 &lt;a href=&quot;#section-9.7.1&quot;&gt;9.7.1&lt;/a&gt; . 비 수집 자원에 대한 PUT &lt;a href=&quot;#section-9.7.2&quot;&gt;9.7.2&lt;/a&gt; . 컬렉션을위한 PUT &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt; . 복사 방법 &lt;a href=&quot;#section-9.8.1&quot;&gt;9.8.1&lt;/a&gt; . 비 수집 자료의 복사 &lt;a href=&quot;#section-9.8.2&quot;&gt;9.8.2&lt;/a&gt; . 재산을위한 사본 &lt;a href=&quot;#section-9.8.3&quot;&gt;9.8.3&lt;/a&gt; . 컬렉션 복사 &lt;a href=&quot;#section-9.8.4&quot;&gt;9.8.4&lt;/a&gt; . 복사 및 대상 리소스 덮어 쓰기 &lt;a href=&quot;#section-9.8.5&quot;&gt;9.8.5&lt;/a&gt; . 상태 코드 &lt;a href=&quot;#section-9.8.6&quot;&gt;9.8.6&lt;/a&gt; . 예-덮어 쓰기를 &lt;a href=&quot;#section-9.8.7&quot;&gt;사용한&lt;/a&gt; 복사 9.8.7 . 예-덮어 쓰기 &lt;a href=&quot;#section-9.8.8&quot;&gt;없는&lt;/a&gt; 복사 9.8.8 . 예-컬렉션 복사 &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;. 이동 방법 &lt;a href=&quot;#section-9.9.1&quot;&gt;9.9.1&lt;/a&gt; . 등록 정보 이동 &lt;a href=&quot;#section-9.9.2&quot;&gt;9.9.2&lt;/a&gt; . 컬렉션을위한 이동 &lt;a href=&quot;#section-9.9.3&quot;&gt;9.9.3&lt;/a&gt; . 이동 및 덮어 쓰기 헤더 &lt;a href=&quot;#section-9.9.4&quot;&gt;9.9.4&lt;/a&gt; . 상태 코드 &lt;a href=&quot;#section-9.9.5&quot;&gt;9.9.5&lt;/a&gt; . 예-비 컬렉션의 이동 &lt;a href=&quot;#section-9.9.6&quot;&gt;9.9.6&lt;/a&gt; . 예-컬렉션의 이동 &lt;a href=&quot;#section-9.10&quot;&gt;9.10&lt;/a&gt; . 잠금 방법 &lt;a href=&quot;#section-9.10.1&quot;&gt;9.10.1&lt;/a&gt; . 기존 자원에 대한 잠금 작성 &lt;a href=&quot;#section-9.10.2&quot;&gt;9.10.2&lt;/a&gt; . 상쾌한 잠금 &lt;a href=&quot;#section-9.10.3&quot;&gt;9.10.3&lt;/a&gt; . 깊이와 잠금 &lt;a href=&quot;#section-9.10.4&quot;&gt;9.10.4&lt;/a&gt; . 매핑되지 않은 URL 잠금 &lt;a href=&quot;#section-9.10.5&quot;&gt;9.10.5&lt;/a&gt;. 잠금 호환성 표 &lt;a href=&quot;#section-9.10.6&quot;&gt;9.10.6&lt;/a&gt; . 잠금 응답 &lt;a href=&quot;#section-9.10.7&quot;&gt;9.10.7&lt;/a&gt; . 예-단순 잠금 요청 &lt;a href=&quot;#section-9.10.8&quot;&gt;9.10.8&lt;/a&gt; . 예-쓰기 잠금 새로 고침 &lt;a href=&quot;#section-9.10.9&quot;&gt;9.10.9&lt;/a&gt; . 예-다중 리소스 잠금 요청 &lt;a href=&quot;#section-9.11&quot;&gt;9.11&lt;/a&gt; . 잠금 해제 방법 &lt;a href=&quot;#section-9.11.1&quot;&gt;9.11.1&lt;/a&gt; . 상태 코드 .............................................. &lt;a href=&quot;#section-9.11.2&quot;&gt;9.11.2&lt;/a&gt; . 예-잠금 해제 &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt; . 분산 작성을위한 HTTP 헤더 &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; . DAV 헤더 &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt; . 깊이 헤더 &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt; . 대상 헤더 &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt; . 헤더 인 경우 &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt; . 목적 &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt; . 구문 &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; . 목록 평가 &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt; . 일치하는 토큰 및 ETag &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt; . 헤더 및 비 DAV 인식 프록시의 경우 &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt; . 예-태그없는 생산 &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt; . 예-태그없는 생산에 &quot;Not&quot;사용 10.4.8. 예-조건을 항상 참으로 평가하기 &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt; . 예-COPY 10.4.10의 헤더 인 경우 태그가 지정된 목록 예-수집 잠금 장치와 잠금 토큰 일치 &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt; . 예-매핑되지 않은 URL에서 ETag 일치 &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt; . 잠금 토큰 헤더 &lt;a href=&quot;#section-10.6&quot;&gt;10.6&lt;/a&gt; . 헤더 덮어 쓰기 &lt;a href=&quot;#section-10.7&quot;&gt;10.7&lt;/a&gt; . 타임 아웃 요청 헤더 &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt; . HTTP / 1.1에 대한 상태 코드 확장 &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt; . 207 다중 상태 &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt; . 422 처리 할 수없는 엔티티 &lt;a href=&quot;#section-11.3&quot;&gt;11.3&lt;/a&gt; . 423 잠김 &lt;a href=&quot;#section-11.4&quot;&gt;11.4&lt;/a&gt; . 424 종속성 실패 &lt;a href=&quot;#section-11.5&quot;&gt;11.5&lt;/a&gt; . 507 저장 공간 부족 &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt; . HTTP 상태 코드 사용 &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt; . 412 사전 조건 실패 &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt; . 414 요청 URI가 너무 길다 &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt; . 다중 상태 응답 &lt;a href=&quot;#section-13.1&quot;&gt;13.1&lt;/a&gt; . 응답 헤더 &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;. 리디렉션 된 자식 리소스 처리 &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt; . 내부 상태 코드 &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt; . XML 요소 정의 &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt; . activelock XML 요소 &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt; . allprop XML 요소 &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt; . 컬렉션 XML 요소 &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt; . 깊이 XML 요소 &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt; . 오류 XML 요소 &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt; . 배타적 XML 요소 &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt; . href XML 요소 &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt; . XML 요소가 포함 &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt; . 위치 XML 요소 &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt; . lockentry XML 요소 &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt; . lockinfo XML 요소 &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt;. lockroot XML 요소 ............................................. &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt; . lockscope XML 요소 &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt; . 잠금 토큰 XML 요소 &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt; . 록 타입 XML 요소 &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt; . 다중 상태 XML 요소 &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt; . 소유자 XML 요소 &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt; . prop XML 요소 &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt; . propertyupdate XML 요소 &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt; . propfind XML 요소 &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt; . propname XML 요소 &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt; . propstat XML 요소 &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; . XML 요소 &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt; 제거 . 응답 XML 요소 &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt;. responsedescription XML 요소 &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; . XML 요소 설정 &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt; . 공유 XML 요소 &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt; . 상태 XML 요소 &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt; . 타임 아웃 XML 요소 &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt; . XML 요소 작성 &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt; . DAV 속성 &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt; . 전제 조건 / 사후 조건 XML 요소 &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt; . DAV의 XML 확장 성 &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt; . DAV 준수 클래스 &lt;a href=&quot;#section-18.1&quot;&gt;18.1&lt;/a&gt; . 클래스 1 &lt;a href=&quot;#section-18.2&quot;&gt;18.2&lt;/a&gt; . 클래스 2 &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt; . 종류 3 &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt; . 국제화 고려 사항 &lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt; . 보안 고려 사항 &lt;a href=&quot;#section-20.1&quot;&gt;20.1&lt;/a&gt; . 클라이언트 인증 &lt;a href=&quot;#section-20.2&quot;&gt;20.2&lt;/a&gt; . 서비스 거부 &lt;a href=&quot;#section-20.3&quot;&gt;20.3&lt;/a&gt; . 모호성을 통한 보안 &lt;a href=&quot;#section-20.4&quot;&gt;20.4&lt;/a&gt; . 잠금 장치에 연결된 개인 정보 문제 &lt;a href=&quot;#section-20.5&quot;&gt;20.5&lt;/a&gt; . 속성에 연결된 개인 정보 문제 &lt;a href=&quot;#section-20.6&quot;&gt;20.6&lt;/a&gt; . XML 엔티티의 의미 &lt;a href=&quot;#section-20.7&quot;&gt;20.7&lt;/a&gt; . 잠금 토큰과 관련된 위험 &lt;a href=&quot;#section-20.8&quot;&gt;20.8&lt;/a&gt; . 악성 콘텐츠 호스팅 &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt; . IANA 고려 사항 &lt;a href=&quot;#section-21.1&quot;&gt;21.1&lt;/a&gt; . 새로운 URI 스킴 &lt;a href=&quot;#section-21.2&quot;&gt;21.2&lt;/a&gt; . XML 네임 스페이스 &lt;a href=&quot;#section-21.3&quot;&gt;21.3&lt;/a&gt; . 메시지 헤더 필드 &lt;a href=&quot;#section-21.3.1&quot;&gt;21.3.1&lt;/a&gt; . DAV &lt;a href=&quot;#section-21.3.2&quot;&gt;21.3.2&lt;/a&gt;. 깊이 &lt;a href=&quot;#section-21.3.3&quot;&gt;21.3.3&lt;/a&gt; . 목적지 &lt;a href=&quot;#section-21.3.4&quot;&gt;21.3.4&lt;/a&gt; . 만약 &lt;a href=&quot;#section-21.3.5&quot;&gt;21.3.5&lt;/a&gt; . 잠금 토큰 &lt;a href=&quot;#section-21.3.6&quot;&gt;21.3.6을&lt;/a&gt; . 덮어 쓰기 &lt;a href=&quot;#section-21.3.7&quot;&gt;21.3.7&lt;/a&gt; . 타임 아웃 &lt;a href=&quot;#section-21.4&quot;&gt;21.4&lt;/a&gt; . HTTP 상태 코드 &lt;a href=&quot;#section-22&quot;&gt;22&lt;/a&gt; . 승인 ............................................. &lt;a href=&quot;#section-23&quot;&gt;23&lt;/a&gt; . 이 규격에 기여한 사람 &lt;a href=&quot;#section-24&quot;&gt;24&lt;/a&gt; . &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518의&lt;/a&gt; 저자 &lt;a href=&quot;#section-25&quot;&gt;25&lt;/a&gt; . 참고 자료 &lt;a href=&quot;#section-25.1&quot;&gt;25.1&lt;/a&gt; . 규범 참조 &lt;a href=&quot;#section-25.2&quot;&gt;25.2&lt;/a&gt; . 유익한 참고 문헌 &lt;a href=&quot;#appendix-A&quot;&gt;부록 A&lt;/a&gt; . XML 요소 처리에 대한 참고 사항 &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1&lt;/a&gt;. 빈 XML 요소에 대한 참고 사항 &lt;a href=&quot;#appendix-A.2&quot;&gt;A.2&lt;/a&gt; . 잘못된 XML 처리에 대한 참고 사항 &lt;a href=&quot;#appendix-A.3&quot;&gt;A.3&lt;/a&gt; . 예-XML 구문 오류 &lt;a href=&quot;#appendix-A.4&quot;&gt;A.4&lt;/a&gt; . 예 - 예기치 않은 XML 요소 &lt;a href=&quot;#appendix-B&quot;&gt;부록 B&lt;/a&gt; . HTTP 클라이언트 호환성에 대한 참고 사항 &lt;a href=&quot;#appendix-C&quot;&gt;부록 C&lt;/a&gt; . 'opaquelocktoken'제도와 URI를 &lt;a href=&quot;#appendix-D&quot;&gt;부록 D&lt;/a&gt; . 락 널 리소스 &lt;a href=&quot;#appendix-D.1&quot;&gt;D.1&lt;/a&gt; . 자원 만들기 LOCK을 사용하여 클라이언트에 대한 지침 &lt;a href=&quot;#appendix-E&quot;&gt;은 부록 E를&lt;/a&gt; . 인증하기를 희망 클라이언트에 대한 지침 &lt;a href=&quot;#appendix-F&quot;&gt;부록 F&lt;/a&gt; . &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518 &lt;/a&gt;&lt;a href=&quot;#appendix-F.1&quot;&gt;F.1&lt;/a&gt; 의 변경 사항 요약 . 클라이언트 및 서버 구현 모두에 대한 변경 사항 &lt;a href=&quot;#appendix-F.2&quot;&gt;F.2&lt;/a&gt;. 서버 구현에 대한 변경 사항 &lt;a href=&quot;#appendix-F.3&quot;&gt;F.3&lt;/a&gt; . 기타 변경 사항 ............................................</target>
        </trans-unit>
        <trans-unit id="5314ebdcf29205bc56fbbcaea0c60b012d05ccf0" translate="yes" xml:space="preserve">
          <source>Status of responses including a &lt;code&gt;Location&lt;/code&gt; header: &lt;a href=&quot;../status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/307&quot;&gt;&lt;code&gt;307&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/308&quot;&gt;&lt;code&gt;308&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">A 이하의 응답 상태 &lt;code&gt;Location&lt;/code&gt; 헤더 : &lt;a href=&quot;../status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/302&quot;&gt; &lt;code&gt;302&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/307&quot;&gt; &lt;code&gt;307&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/308&quot;&gt; &lt;code&gt;308&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d856fa610b4491baa384c8f7803b6e1e2fc35cdc" translate="yes" xml:space="preserve">
          <source>Status of this Memo

   This document specifies an Internet standards track protocol for the
   Internet community, and requests discussion and suggestions for
   improvements.  Please refer to the current edition of the &quot;Internet
   Official Protocol Standards&quot; (STD 1) for the standardization state
   and status of this protocol.  Distribution of this memo is unlimited.

Copyright Notice

   Copyright (C) The Internet Society (1999).  All Rights Reserved.

Abstract

   The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. It is a generic, stateless, protocol which can be used for
   many tasks beyond its use for hypertext, such as name servers and
   distributed object management systems, through extension of its
   request methods, error codes and headers [&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt;]. A feature of HTTP is
   the typing and negotiation of data representation, allowing systems
   to be built independently of the data being transferred.

   HTTP has been in use by the World-Wide Web global information
   initiative since 1990. This specification defines the protocol
   referred to as &quot;HTTP/1.1&quot;, and is an update to &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;]. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;   Introduction 
   &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt;    Purpose
   &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt;   Requirements 
   &lt;a href=&quot;#section-1.3&quot;&gt;1.3&lt;/a&gt;   Terminology 
   &lt;a href=&quot;#section-1.4&quot;&gt;1.4&lt;/a&gt;   Overall Operation 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;   Notational Conventions and Generic Grammar 
   &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;   Augmented BNF 
   &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt;   Basic Rules 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;   Protocol Parameters 
   &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;   HTTP Version 
   &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;   Uniform Resource Identifiers 
   &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;    General Syntax 
   &lt;a href=&quot;#section-3.2.2&quot;&gt;3.2.2&lt;/a&gt;    http URL 
   &lt;a href=&quot;#section-3.2.3&quot;&gt;3.2.3&lt;/a&gt;    URI Comparison 
   &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;   Date/Time Formats 
   &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt;    Full Date 
   &lt;a href=&quot;#section-3.3.2&quot;&gt;3.3.2&lt;/a&gt;    Delta Seconds 
   &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt;   Character Sets 
   &lt;a href=&quot;#section-3.4.1&quot;&gt;3.4.1&lt;/a&gt;    Missing Charset 
   &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt;   Content Codings 
   &lt;a href=&quot;#section-3.6&quot;&gt;3.6&lt;/a&gt;   Transfer Codings 
   &lt;a href=&quot;#section-3.6.1&quot;&gt;3.6.1&lt;/a&gt;    Chunked Transfer Coding 
   &lt;a href=&quot;#section-3.7&quot;&gt;3.7&lt;/a&gt;   Media Types 
   &lt;a href=&quot;#section-3.7.1&quot;&gt;3.7.1&lt;/a&gt;    Canonicalization and Text Defaults 
   &lt;a href=&quot;#section-3.7.2&quot;&gt;3.7.2&lt;/a&gt;    Multipart Types 
   &lt;a href=&quot;#section-3.8&quot;&gt;3.8&lt;/a&gt;   Product Tokens 
   &lt;a href=&quot;#section-3.9&quot;&gt;3.9&lt;/a&gt;   Quality Values 
   &lt;a href=&quot;#section-3.10&quot;&gt;3.10&lt;/a&gt;  Language Tags 
   &lt;a href=&quot;#section-3.11&quot;&gt;3.11&lt;/a&gt;  Entity Tags 
   &lt;a href=&quot;#section-3.12&quot;&gt;3.12&lt;/a&gt;  Range Units 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;   HTTP Message 
   &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;   Message Types 
   &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;   Message Headers 
   &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;   Message Body 
   &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;   Message Length 
   &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt;   General Header Fields 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;   Request 
   &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;   Request-Line 
   &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt;    Method 
   &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;    Request-URI 
   &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;   The Resource Identified by a Request 
   &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;   Request Header Fields 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;   Response 
   &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;   Status-Line 
   &lt;a href=&quot;#section-6.1.1&quot;&gt;6.1.1&lt;/a&gt;    Status Code and Reason Phrase 
   &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;   Response Header Fields ...................................... 

   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;   Entity 
   &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;   Entity Header Fields 
   &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;   Entity Body 
   &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt;    Type 
   &lt;a href=&quot;#section-7.2.2&quot;&gt;7.2.2&lt;/a&gt;    Entity Length 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;   Connections 
   &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;   Persistent Connections 
   &lt;a href=&quot;#section-8.1.1&quot;&gt;8.1.1&lt;/a&gt;    Purpose 
   &lt;a href=&quot;#section-8.1.2&quot;&gt;8.1.2&lt;/a&gt;    Overall Operation 
   &lt;a href=&quot;#section-8.1.3&quot;&gt;8.1.3&lt;/a&gt;    Proxy Servers 
   &lt;a href=&quot;#section-8.1.4&quot;&gt;8.1.4&lt;/a&gt;    Practical Considerations 
   &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;   Message Transmission Requirements 
   &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt;    Persistent Connections and Flow Control 
   &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt;    Monitoring Connections for Error Status Messages 
   &lt;a href=&quot;#section-8.2.3&quot;&gt;8.2.3&lt;/a&gt;    Use of the 100 (Continue) Status 
   &lt;a href=&quot;#section-8.2.4&quot;&gt;8.2.4&lt;/a&gt;    Client Behavior if Server Prematurely Closes Connection ..50
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;   Method Definitions 
   &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;   Safe and Idempotent Methods 
   &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt;    Safe Methods 
   &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;    Idempotent Methods 
   &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;   OPTIONS 
   &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;   GET 
   &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;   HEAD 
   &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;   POST 
   &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;   PUT 
   &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;   DELETE 
   &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt;   TRACE 
   &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;   CONNECT 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;   Status Code Definitions 
   &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;  Informational 1xx 
   &lt;a href=&quot;#section-10.1.1&quot;&gt;10.1.1&lt;/a&gt;   100 Continue 
   &lt;a href=&quot;#section-10.1.2&quot;&gt;10.1.2&lt;/a&gt;   101 Switching Protocols 
   &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;  Successful 2xx 
   &lt;a href=&quot;#section-10.2.1&quot;&gt;10.2.1&lt;/a&gt;   200 OK 
   &lt;a href=&quot;#section-10.2.2&quot;&gt;10.2.2&lt;/a&gt;   201 Created 
   &lt;a href=&quot;#section-10.2.3&quot;&gt;10.2.3&lt;/a&gt;   202 Accepted 
   &lt;a href=&quot;#section-10.2.4&quot;&gt;10.2.4&lt;/a&gt;   203 Non-Authoritative Information 
   &lt;a href=&quot;#section-10.2.5&quot;&gt;10.2.5&lt;/a&gt;   204 No Content 
   &lt;a href=&quot;#section-10.2.6&quot;&gt;10.2.6&lt;/a&gt;   205 Reset Content 
   &lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt;   206 Partial Content 
   &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt;  Redirection 3xx 
   &lt;a href=&quot;#section-10.3.1&quot;&gt;10.3.1&lt;/a&gt;   300 Multiple Choices 
   &lt;a href=&quot;#section-10.3.2&quot;&gt;10.3.2&lt;/a&gt;   301 Moved Permanently 
   &lt;a href=&quot;#section-10.3.3&quot;&gt;10.3.3&lt;/a&gt;   302 Found 
   &lt;a href=&quot;#section-10.3.4&quot;&gt;10.3.4&lt;/a&gt;   303 See Other 
   &lt;a href=&quot;#section-10.3.5&quot;&gt;10.3.5&lt;/a&gt;   304 Not Modified 
   &lt;a href=&quot;#section-10.3.6&quot;&gt;10.3.6&lt;/a&gt;   305 Use Proxy 
   &lt;a href=&quot;#section-10.3.7&quot;&gt;10.3.7&lt;/a&gt;   306 (Unused) ............................................. 

   &lt;a href=&quot;#section-10.3.8&quot;&gt;10.3.8&lt;/a&gt;   307 Temporary Redirect 
   &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt;  Client Error 4xx 
   &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt;    400 Bad Request 
   &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt;    401 Unauthorized 
   &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt;    402 Payment Required 
   &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;    403 Forbidden 
   &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt;    404 Not Found 
   &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt;    405 Method Not Allowed 
   &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt;    406 Not Acceptable 
   &lt;a href=&quot;#section-10.4.8&quot;&gt;10.4.8&lt;/a&gt;    407 Proxy Authentication Required 
   &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt;    408 Request Timeout 
   &lt;a href=&quot;#section-10.4.10&quot;&gt;10.4.10&lt;/a&gt;   409 Conflict 
   &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt;   410 Gone 
   &lt;a href=&quot;#section-10.4.12&quot;&gt;10.4.12&lt;/a&gt;   411 Length Required 
   &lt;a href=&quot;#section-10.4.13&quot;&gt;10.4.13&lt;/a&gt;   412 Precondition Failed 
   &lt;a href=&quot;#section-10.4.14&quot;&gt;10.4.14&lt;/a&gt;   413 Request Entity Too Large 
   &lt;a href=&quot;#section-10.4.15&quot;&gt;10.4.15&lt;/a&gt;   414 Request-URI Too Long 
   &lt;a href=&quot;#section-10.4.16&quot;&gt;10.4.16&lt;/a&gt;   415 Unsupported Media Type 
   &lt;a href=&quot;#section-10.4.17&quot;&gt;10.4.17&lt;/a&gt;   416 Requested Range Not Satisfiable 
   &lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt;   417 Expectation Failed 
   &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt;  Server Error 5xx 
   &lt;a href=&quot;#section-10.5.1&quot;&gt;10.5.1&lt;/a&gt;   500 Internal Server Error 
   &lt;a href=&quot;#section-10.5.2&quot;&gt;10.5.2&lt;/a&gt;   501 Not Implemented 
   &lt;a href=&quot;#section-10.5.3&quot;&gt;10.5.3&lt;/a&gt;   502 Bad Gateway 
   &lt;a href=&quot;#section-10.5.4&quot;&gt;10.5.4&lt;/a&gt;   503 Service Unavailable 
   &lt;a href=&quot;#section-10.5.5&quot;&gt;10.5.5&lt;/a&gt;   504 Gateway Timeout 
   &lt;a href=&quot;#section-10.5.6&quot;&gt;10.5.6&lt;/a&gt;   505 HTTP Version Not Supported 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;   Access Authentication 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;   Content Negotiation 
   &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;  Server-driven Negotiation 
   &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt;  Agent-driven Negotiation 
   &lt;a href=&quot;#section-12.3&quot;&gt;12.3&lt;/a&gt;  Transparent Negotiation 
   &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt;   Caching in HTTP 
   &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt;   Cache Correctness 
   &lt;a href=&quot;#section-13.1.2&quot;&gt;13.1.2&lt;/a&gt;   Warnings 
   &lt;a href=&quot;#section-13.1.3&quot;&gt;13.1.3&lt;/a&gt;   Cache-control Mechanisms 
   &lt;a href=&quot;#section-13.1.4&quot;&gt;13.1.4&lt;/a&gt;   Explicit User Agent Warnings 
   &lt;a href=&quot;#section-13.1.5&quot;&gt;13.1.5&lt;/a&gt;   Exceptions to the Rules and Warnings 
   &lt;a href=&quot;#section-13.1.6&quot;&gt;13.1.6&lt;/a&gt;   Client-controlled Behavior 
   &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt;  Expiration Model 
   &lt;a href=&quot;#section-13.2.1&quot;&gt;13.2.1&lt;/a&gt;   Server-Specified Expiration 
   &lt;a href=&quot;#section-13.2.2&quot;&gt;13.2.2&lt;/a&gt;   Heuristic Expiration 
   &lt;a href=&quot;#section-13.2.3&quot;&gt;13.2.3&lt;/a&gt;   Age Calculations 
   &lt;a href=&quot;#section-13.2.4&quot;&gt;13.2.4&lt;/a&gt;   Expiration Calculations 
   &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt;   Disambiguating Expiration Values 
   &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt;   Disambiguating Multiple Responses 
   &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt;  Validation Model 
   &lt;a href=&quot;#section-13.3.1&quot;&gt;13.3.1&lt;/a&gt;   Last-Modified Dates ...................................... 

   &lt;a href=&quot;#section-13.3.2&quot;&gt;13.3.2&lt;/a&gt;   Entity Tag Cache Validators 
   &lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt;   Weak and Strong Validators 
   13.3.4   Rules for When to Use Entity Tags and Last-Modified Dates.89
   &lt;a href=&quot;#section-13.3.5&quot;&gt;13.3.5&lt;/a&gt;   Non-validating Conditionals 
   &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt;  Response Cacheability 
   &lt;a href=&quot;#section-13.5&quot;&gt;13.5&lt;/a&gt;  Constructing Responses From Caches 
   &lt;a href=&quot;#section-13.5.1&quot;&gt;13.5.1&lt;/a&gt;   End-to-end and Hop-by-hop Headers 
   &lt;a href=&quot;#section-13.5.2&quot;&gt;13.5.2&lt;/a&gt;   Non-modifiable Headers 
   &lt;a href=&quot;#section-13.5.3&quot;&gt;13.5.3&lt;/a&gt;   Combining Headers 
   &lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt;   Combining Byte Ranges 
   &lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt;  Caching Negotiated Responses 
   &lt;a href=&quot;#section-13.7&quot;&gt;13.7&lt;/a&gt;  Shared and Non-Shared Caches 
   &lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt;  Errors or Incomplete Response Cache Behavior 
   &lt;a href=&quot;#section-13.9&quot;&gt;13.9&lt;/a&gt;  Side Effects of GET and HEAD 
   &lt;a href=&quot;#section-13.10&quot;&gt;13.10&lt;/a&gt;   Invalidation After Updates or Deletions 
   &lt;a href=&quot;#section-13.11&quot;&gt;13.11&lt;/a&gt;   Write-Through Mandatory 
   &lt;a href=&quot;#section-13.12&quot;&gt;13.12&lt;/a&gt;   Cache Replacement 
   &lt;a href=&quot;#section-13.13&quot;&gt;13.13&lt;/a&gt;   History Lists 
   &lt;a href=&quot;#section-14&quot;&gt;14&lt;/a&gt;   Header Field Definitions 
   &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt;  Accept 
   &lt;a href=&quot;#section-14.2&quot;&gt;14.2&lt;/a&gt;  Accept-Charset 
   &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt;  Accept-Encoding 
   &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt;  Accept-Language 
   &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt;  Accept-Ranges 
   &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt;  Age 
   &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt;  Allow 
   &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;  Authorization 
   &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;  Cache-Control 
   &lt;a href=&quot;#section-14.9.1&quot;&gt;14.9.1&lt;/a&gt;   What is Cacheable 
   &lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt;   What May be Stored by Caches 
   &lt;a href=&quot;#section-14.9.3&quot;&gt;14.9.3&lt;/a&gt;   Modifications of the Basic Expiration Mechanism 
   &lt;a href=&quot;#section-14.9.4&quot;&gt;14.9.4&lt;/a&gt;   Cache Revalidation and Reload Controls 
   &lt;a href=&quot;#section-14.9.5&quot;&gt;14.9.5&lt;/a&gt;   No-Transform Directive 
   &lt;a href=&quot;#section-14.9.6&quot;&gt;14.9.6&lt;/a&gt;   Cache Control Extensions 
   &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt;   Connection 
   &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;   Content-Encoding 
   &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt;   Content-Language 
   &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt;   Content-Length 
   &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt;   Content-Location 
   &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt;   Content-MD5 
   &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;   Content-Range 
   &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;   Content-Type 
   &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt;   Date 
   &lt;a href=&quot;#section-14.18.1&quot;&gt;14.18.1&lt;/a&gt;   Clockless Origin Server Operation 
   &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;   ETag 
   &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt;   Expect 
   &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt;   Expires 
   &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt;   From ..................................................... 

   &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt;   Host 
   &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;   If-Match 
   &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt;   If-Modified-Since 
   &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;   If-None-Match 
   &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt;   If-Range 
   &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt;   If-Unmodified-Since 
   &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt;   Last-Modified 
   &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt;   Location 
   &lt;a href=&quot;#section-14.31&quot;&gt;14.31&lt;/a&gt;   Max-Forwards 
   &lt;a href=&quot;#section-14.32&quot;&gt;14.32&lt;/a&gt;   Pragma 
   &lt;a href=&quot;#section-14.33&quot;&gt;14.33&lt;/a&gt;   Proxy-Authenticate 
   &lt;a href=&quot;#section-14.34&quot;&gt;14.34&lt;/a&gt;   Proxy-Authorization 
   &lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt;   Range 
   &lt;a href=&quot;#section-14.35.1&quot;&gt;14.35.1&lt;/a&gt;    Byte Ranges 
   &lt;a href=&quot;#section-14.35.2&quot;&gt;14.35.2&lt;/a&gt;    Range Retrieval Requests 
   &lt;a href=&quot;#section-14.36&quot;&gt;14.36&lt;/a&gt;   Referer 
   &lt;a href=&quot;#section-14.37&quot;&gt;14.37&lt;/a&gt;   Retry-After 
   &lt;a href=&quot;#section-14.38&quot;&gt;14.38&lt;/a&gt;   Server 
   &lt;a href=&quot;#section-14.39&quot;&gt;14.39&lt;/a&gt;   TE 
   &lt;a href=&quot;#section-14.40&quot;&gt;14.40&lt;/a&gt;   Trailer 
   &lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;  Transfer-Encoding
   &lt;a href=&quot;#section-14.42&quot;&gt;14.42&lt;/a&gt;   Upgrade 
   &lt;a href=&quot;#section-14.43&quot;&gt;14.43&lt;/a&gt;   User-Agent 
   &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;   Vary 
   &lt;a href=&quot;#section-14.45&quot;&gt;14.45&lt;/a&gt;   Via 
   &lt;a href=&quot;#section-14.46&quot;&gt;14.46&lt;/a&gt;   Warning 
   &lt;a href=&quot;#section-14.47&quot;&gt;14.47&lt;/a&gt;   WWW-Authenticate 
   &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt; Security Considerations 
   &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt;      Personal Information
   &lt;a href=&quot;#section-15.1.1&quot;&gt;15.1.1&lt;/a&gt;   Abuse of Server Log Information 
   &lt;a href=&quot;#section-15.1.2&quot;&gt;15.1.2&lt;/a&gt;   Transfer of Sensitive Information 
   &lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3&lt;/a&gt;   Encoding Sensitive Information in URI's 
   &lt;a href=&quot;#section-15.1.4&quot;&gt;15.1.4&lt;/a&gt;   Privacy Issues Connected to Accept Headers 
   &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt;  Attacks Based On File and Path Names 
   &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt;  DNS Spoofing 
   &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt;  Location Headers and Spoofing 
   &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt;  Content-Disposition Issues 
   &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt;  Authentication Credentials and Idle Clients 
   &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt;  Proxies and Caching 
   &lt;a href=&quot;#section-15.7.1&quot;&gt;15.7.1&lt;/a&gt;    Denial of Service Attacks on Proxies
   &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt;   Acknowledgments 
   &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt;   References 
   &lt;a href=&quot;#section-18&quot;&gt;18&lt;/a&gt;   Authors' Addresses 
   &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt;   Appendices 
   &lt;a href=&quot;#section-19.1&quot;&gt;19.1&lt;/a&gt;  Internet Media Type message/http and application/http 
   &lt;a href=&quot;#section-19.2&quot;&gt;19.2&lt;/a&gt;  Internet Media Type multipart/byteranges 
   &lt;a href=&quot;#section-19.3&quot;&gt;19.3&lt;/a&gt;  Tolerant Applications 
   &lt;a href=&quot;#section-19.4&quot;&gt;19.4&lt;/a&gt;  Differences Between HTTP Entities and &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; Entities .... 

   &lt;a href=&quot;#section-19.4.1&quot;&gt;19.4.1&lt;/a&gt;   MIME-Version 
   &lt;a href=&quot;#section-19.4.2&quot;&gt;19.4.2&lt;/a&gt;   Conversion to Canonical Form 
   &lt;a href=&quot;#section-19.4.3&quot;&gt;19.4.3&lt;/a&gt;   Conversion of Date Formats 
   &lt;a href=&quot;#section-19.4.4&quot;&gt;19.4.4&lt;/a&gt;   Introduction of Content-Encoding 
   &lt;a href=&quot;#section-19.4.5&quot;&gt;19.4.5&lt;/a&gt;   No Content-Transfer-Encoding 
   &lt;a href=&quot;#section-19.4.6&quot;&gt;19.4.6&lt;/a&gt;   Introduction of Transfer-Encoding 
   &lt;a href=&quot;#section-19.4.7&quot;&gt;19.4.7&lt;/a&gt;   MHTML and Line Length Limitations 
   &lt;a href=&quot;#section-19.5&quot;&gt;19.5&lt;/a&gt;  Additional Features 
   &lt;a href=&quot;#section-19.5.1&quot;&gt;19.5.1&lt;/a&gt;   Content-Disposition 
   &lt;a href=&quot;#section-19.6&quot;&gt;19.6&lt;/a&gt;  Compatibility with Previous Versions 
   &lt;a href=&quot;#section-19.6.1&quot;&gt;19.6.1&lt;/a&gt;   Changes from HTTP/1.0 
   &lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt;   Compatibility with HTTP/1.0 Persistent Connections 
   &lt;a href=&quot;#section-19.6.3&quot;&gt;19.6.3&lt;/a&gt;   Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;&lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt;   Index 
   &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt;   Full Copyright Statement</source>
          <target state="translated">이 메모의 상태이 문서는 인터넷 커뮤니티를위한 인터넷 표준 추적 프로토콜을 지정하고 개선을위한 토론과 제안을 요청합니다. 이 프로토콜의 표준화 상태 및 상태는 &quot;인터넷 공식 프로토콜 표준&quot;(STD 1)의 최신판을 참조하십시오. 이 메모의 배포는 무제한입니다. 저작권 공지 저작권 (C) The Internet Society (1999). 판권 소유. Abstract HTTP (Hypertext Transfer Protocol)는 분산 된 협업 하이퍼 미디어 정보 시스템을위한 응용 프로그램 수준 프로토콜입니다. 이는 요청 방식의 확장을 통해 네임 서버 및 분산 객체 관리 시스템과 같은 하이퍼 텍스트 사용 이외의 많은 작업에 사용할 수있는 일반적인 상태 비 저장 프로토콜입니다.오류 코드 및 헤더 [&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt; ]. HTTP의 특징은 데이터 표현의 타이핑 및 협상으로, 전송되는 데이터와 독립적으로 시스템을 구축 할 수 있습니다. HTTP는 1990 년 이래 World-Wide Web 글로벌 정보 이니셔티브에 의해 사용되었습니다.이 사양은 &quot;HTTP / 1.1&quot;이라는 프로토콜을 정의하며 &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068에&lt;/a&gt; 대한 업데이트입니다 [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]. 목차 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; 소개 &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt; 목적 &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt; 요구 사항 &lt;a href=&quot;#section-1.3&quot;&gt;1.3&lt;/a&gt; 용어 &lt;a href=&quot;#section-1.4&quot;&gt;1.4&lt;/a&gt; 전반적인 운영 &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; 표기법 및 일반 문법 &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; 증강 된 BNF &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt; 기본 규칙 &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; 프로토콜 매개 변수 &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt; HTTP 버전 &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; 통일 리소스 식별자 &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt; 일반 구문 &lt;a href=&quot;#section-3.2.2&quot;&gt;3.2.2&lt;/a&gt; http URL &lt;a href=&quot;#section-3.2.3&quot;&gt;3.2.3&lt;/a&gt; URI 비교 &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; 날짜 / 시간 형식 &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt; 전체 날짜 &lt;a href=&quot;#section-3.3.2&quot;&gt;3.3.2&lt;/a&gt; 델타 초 &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt; 문자 집합 &lt;a href=&quot;#section-3.4.1&quot;&gt;3.4.1&lt;/a&gt; 누락 된 문자 집합 &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt; 내용 코딩 &lt;a href=&quot;#section-3.6&quot;&gt;3.6&lt;/a&gt; 전송 코딩 &lt;a href=&quot;#section-3.6.1&quot;&gt;3.6.1&lt;/a&gt; 코딩 청크 분할 전송 &lt;a href=&quot;#section-3.7&quot;&gt;3.7&lt;/a&gt; 미디어 유형 &lt;a href=&quot;#section-3.7.1&quot;&gt;3.7.1&lt;/a&gt; 정규화 및 텍스트 기본값 &lt;a href=&quot;#section-3.7.2&quot;&gt;3.7.2 멀티&lt;/a&gt; 파트 유형 &lt;a href=&quot;#section-3.8&quot;&gt;3.8&lt;/a&gt; 제품 토큰 &lt;a href=&quot;#section-3.9&quot;&gt;3.9&lt;/a&gt; 품질 값 &lt;a href=&quot;#section-3.10&quot;&gt;3.10&lt;/a&gt; 언어 태그 &lt;a href=&quot;#section-3.11&quot;&gt;3.11&lt;/a&gt; 엔티티 태그 &lt;a href=&quot;#section-3.12&quot;&gt;3.12&lt;/a&gt; 범위 단위 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; HTTP 메시지 &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; 메시지 유형 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; 메시지 헤더 &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; 메시지 본문 &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; 메시지 길이 &lt;a href=&quot;#section-4.5&quot;&gt;4.5&lt;/a&gt; 일반 헤더 필드 &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; 요청 &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; 요청 라인 &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1 .1&lt;/a&gt; 방법 &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt; 요청 URI &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; 요청으로 식별 된 리소스 &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; 요청 헤더 필드 &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; 응답 &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt; 상태 행 &lt;a href=&quot;#section-6.1.1&quot;&gt;6.1.1&lt;/a&gt; 상태 코드 및 이유 문구 &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; 응답 헤더 필드 ............ ................. &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; 엔터티 &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; 엔터티 헤더 필드 &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt; 엔터티 본문 &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt; 유형 &lt;a href=&quot;#section-7.2.2&quot;&gt;7.2.2&lt;/a&gt; 엔터티 길이 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; 연결 &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; 영구 연결 &lt;a href=&quot;#section-8.1.1&quot;&gt;8.1.1&lt;/a&gt; 목적 &lt;a href=&quot;#section-8.1.2&quot;&gt;8.1.2&lt;/a&gt; 전체 작업 &lt;a href=&quot;#section-8.1.3&quot;&gt;8.1 .삼&lt;/a&gt; 프록시 서버 &lt;a href=&quot;#section-8.1.4&quot;&gt;8.1.4&lt;/a&gt; 실제 고려 사항 &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; 메시지 전송 요구 사항 &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt; 영구 연결 및 흐름 제어 &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt; 오류 상태 메시지에 대한 연결 모니터링 &lt;a href=&quot;#section-8.2.3&quot;&gt;8.2.3&lt;/a&gt; 100 (계속) 상태 사용 &lt;a href=&quot;#section-8.2.4&quot;&gt;8.2.4&lt;/a&gt; 서버가 연결을 조기에 종료하면 클라이언트 동작. .50 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt; 방법 정의 &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; 안전 및 등전위 방법 &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt; 안전한 방법 &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt; 등전위 방법 &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt; 옵션 &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt; GET &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt; HEAD &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt; POST &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt; PUT &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt; DELETE &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt; TRACE &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt; CONNECT &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt; 상태 코드 정의 &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; 정보 1xx &lt;a href=&quot;#section-10.1.1&quot;&gt;10.1.1&lt;/a&gt; 100 계속 &lt;a href=&quot;#section-10.1.2&quot;&gt;10.1.2&lt;/a&gt; 101 스위칭 프로토콜 &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt; 성공 2xx &lt;a href=&quot;#section-10.2.1&quot;&gt;10.2.1&lt;/a&gt; 200 OK &lt;a href=&quot;#section-10.2.2&quot;&gt;10.2.2&lt;/a&gt; 201 생성됨 &lt;a href=&quot;#section-10.2.3&quot;&gt;10.2.3&lt;/a&gt; 202 허용 &lt;a href=&quot;#section-10.2.4&quot;&gt;10.2.4&lt;/a&gt; 203 신뢰할 수없는 정보 &lt;a href=&quot;#section-10.2.5&quot;&gt;10.2.5&lt;/a&gt; 204 콘텐츠 없음 &lt;a href=&quot;#section-10.2.6&quot;&gt;10.2.6&lt;/a&gt; 205 콘텐츠 재설정 &lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt; 206 일부 내용 &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt; 리디렉션 3xx &lt;a href=&quot;#section-10.3.1&quot;&gt;10.3.1&lt;/a&gt; 300 객관식 선택 &lt;a href=&quot;#section-10.3.2&quot;&gt;10.3.2&lt;/a&gt; 301 영구적으로 이동 됨 &lt;a href=&quot;#section-10.3.3&quot;&gt;10.3.3&lt;/a&gt; 302 발견 &lt;a href=&quot;#section-10.3.4&quot;&gt;10.3.4&lt;/a&gt; 303 기타 &lt;a href=&quot;#section-10.3.5&quot;&gt;10.3.5&lt;/a&gt; 304 수정되지 않음 참조 &lt;a href=&quot;#section-10.3.6&quot;&gt;10.3.6&lt;/a&gt; 305 프록시 &lt;a href=&quot;#section-10.3.7&quot;&gt;10.3.7&lt;/a&gt; 306 사용 (사용되지 않음) .. ........................................... &lt;a href=&quot;#section-10.3.8&quot;&gt;10.3.8&lt;/a&gt; 307 임시 리디렉션 &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt; 클라이언트 오류 4xx &lt;a href=&quot;#section-10.4.1&quot;&gt;10.4.1&lt;/a&gt; 400 잘못된 요청 &lt;a href=&quot;#section-10.4.2&quot;&gt;10.4.2&lt;/a&gt; 401 무단 &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; 402 지불 필요 &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt; 403 금지됨 &lt;a href=&quot;#section-10.4.5&quot;&gt;10.4.5&lt;/a&gt; 404 찾을 수 없음 &lt;a href=&quot;#section-10.4.6&quot;&gt;10.4.6&lt;/a&gt; 405 허용되지 않는 방법 &lt;a href=&quot;#section-10.4.7&quot;&gt;10.4.7&lt;/a&gt; 406 허용 되지 않음 &lt;a href=&quot;#section-10.4.8&quot;&gt;10.4.8&lt;/a&gt; 407 프록시 인증 필요 &lt;a href=&quot;#section-10.4.9&quot;&gt;10.4.9&lt;/a&gt; 408 요청 시간 초과 &lt;a href=&quot;#section-10.4.10&quot;&gt;10.4.10&lt;/a&gt; 409 충돌 &lt;a href=&quot;#section-10.4.11&quot;&gt;10.4.11&lt;/a&gt; 410 사라짐 &lt;a href=&quot;#section-10.4.12&quot;&gt;10.4.12&lt;/a&gt; 411 길이 필요 &lt;a href=&quot;#section-10.4.13&quot;&gt;10.4.13&lt;/a&gt; 412 전제 조건 실패 &lt;a href=&quot;#section-10.4.14&quot;&gt;10.4.14&lt;/a&gt; 413 요청 엔티티가 너무 큼 &lt;a href=&quot;#section-10.4.15&quot;&gt;10.4.15&lt;/a&gt; 414 요청 URI가 너무 &lt;a href=&quot;#section-10.4.16&quot;&gt;깁니다 10.4.16&lt;/a&gt; 415 지원되지 않는 미디어 유형 &lt;a href=&quot;#section-10.4.17&quot;&gt;10.4.17&lt;/a&gt; 416 요청 된 범위를 충족 할 수 없음 &lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt; 417 예상 실패 &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt; 서버 오류 5xx &lt;a href=&quot;#section-10.5.1&quot;&gt;10.5.1&lt;/a&gt; 500 내부 서버 오류 &lt;a href=&quot;#section-10.5.2&quot;&gt;10.5.2&lt;/a&gt; 501 구현되지 않음 &lt;a href=&quot;#section-10.5.3&quot;&gt;10.5.3&lt;/a&gt; 502 불량 게이트웨이 &lt;a href=&quot;#section-10.5.4&quot;&gt;10.5.4&lt;/a&gt; 503 서비스를 사용할 수 없음 &lt;a href=&quot;#section-10.5.5&quot;&gt;10.5.5&lt;/a&gt; 504 게이트웨이 시간 초과 &lt;a href=&quot;#section-10.5.6&quot;&gt;10.5.6&lt;/a&gt; 505 HTTP 버전이 지원되지 않음 &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt; 액세스 인증 &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt; 내용 협상 &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt; 서버 중심 협상 &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt; 에이전트 중심 협상 &lt;a href=&quot;#section-12.3&quot;&gt;12.3&lt;/a&gt; 투명 협상 &lt;a href=&quot;#section-13&quot;&gt;13&lt;/a&gt; HTTP 캐싱 &lt;a href=&quot;#section-13.1.1&quot;&gt;13.1.1&lt;/a&gt; 캐시 정확성 &lt;a href=&quot;#section-13.1.2&quot;&gt;13.1.2&lt;/a&gt; 경고 &lt;a href=&quot;#section-13.1.3&quot;&gt;13.1.3&lt;/a&gt; 캐시 제어 메커니즘 &lt;a href=&quot;#section-13.1.4&quot;&gt;13.1.4&lt;/a&gt; 명시 적 사용자 에이전트 경고 &lt;a href=&quot;#section-13.1.5&quot;&gt;13.1.5&lt;/a&gt; 규칙 및 경고 예외 &lt;a href=&quot;#section-13.1.6&quot;&gt;13.1.6&lt;/a&gt; 클라이언트 제어 동작 &lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt; 만료 모델 &lt;a href=&quot;#section-13.2.1&quot;&gt;13.2.1&lt;/a&gt; 서버 지정 만료 &lt;a href=&quot;#section-13.2.2&quot;&gt;13.2.2&lt;/a&gt; 휴리스틱 만료 &lt;a href=&quot;#section-13.2.3&quot;&gt;13.2.3&lt;/a&gt; 연령 계산 &lt;a href=&quot;#section-13.2.4&quot;&gt;13.2.4&lt;/a&gt; 만료 계산 &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt; 명확성 만료 값 &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt; 여러 응답 명확화 &lt;a href=&quot;#section-13.3&quot;&gt;13.3&lt;/a&gt; 유효성 검사 모델 &lt;a href=&quot;#section-13.3.1&quot;&gt;13.3.1&lt;/a&gt; 최종 수정 날짜 ...................................... &lt;a href=&quot;#section-13.3.2&quot;&gt;13.3.2&lt;/a&gt; 엔터티 태그 캐시 검사기 &lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt; 약한 및 강한 검사기 13.3.4 규칙에 대한 때 사용 엔터티 태그와 마지막 수정 Dates.89에 &lt;a href=&quot;#section-13.3.5&quot;&gt;13.3.5&lt;/a&gt; 타당성을 검증하지 않는 조건문 &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt; 응답 캐시 가능한 &lt;a href=&quot;#section-13.5&quot;&gt;13.5&lt;/a&gt; 캐시에서 구축 응답 &lt;a href=&quot;#section-13.5.1&quot;&gt;13.5.1&lt;/a&gt; 최종 엔드 및 &lt;a href=&quot;#section-13.5.2&quot;&gt;홉별&lt;/a&gt; 헤더 13.5.2 수정할 수없는 헤더 &lt;a href=&quot;#section-13.5.3&quot;&gt;13.5.3&lt;/a&gt; 헤더 결합 &lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt; 바이트 범위 결합 &lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt; 협상 된 응답 캐싱 &lt;a href=&quot;#section-13.7&quot;&gt;13.7&lt;/a&gt; 공유 및 비 공유 캐시 &lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt; 에러 또는 불완전한 응답 캐시 동작 &lt;a href=&quot;#section-13.9&quot;&gt;13.9&lt;/a&gt; 부작용의 GET 및 HEAD &lt;a href=&quot;#section-13.10&quot;&gt;13.10&lt;/a&gt; 업데이트 또는 삭제 후 무효 &lt;a href=&quot;#section-13.11&quot;&gt;13.11&lt;/a&gt; 쓰기를 통해 필수 &lt;a href=&quot;#section-13.12&quot;&gt;13.12&lt;/a&gt; 캐시 교체 &lt;a href=&quot;#section-13.13&quot;&gt;13.13&lt;/a&gt; 히스토리 목록 &lt;a href=&quot;#section-14&quot;&gt;(14)&lt;/a&gt; 헤더 필드 정의가 &lt;a href=&quot;#section-14.1&quot;&gt;14.1&lt;/a&gt; 수락 &lt;a href=&quot;#section-14.2&quot;&gt;14.2을&lt;/a&gt; 수락-캐릭터 세트 &lt;a href=&quot;#section-14.3&quot;&gt;14.3&lt;/a&gt; 용납하는 인코딩 &lt;a href=&quot;#section-14.4&quot;&gt;14.4&lt;/a&gt; 수용 언어 &lt;a href=&quot;#section-14.5&quot;&gt;14.5&lt;/a&gt; 수용 범위 &lt;a href=&quot;#section-14.6&quot;&gt;14.6&lt;/a&gt; 연령 &lt;a href=&quot;#section-14.7&quot;&gt;14.7&lt;/a&gt; 허용 &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt; 권한 부여 &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt; 캐시 제어 &lt;a href=&quot;#section-14.9.1&quot;&gt;14.9.1은&lt;/a&gt; 캐시 할 무엇 &lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt; 캐시로 저장 될 수 무엇 &lt;a href=&quot;#section-14.9.3&quot;&gt;14.9.3&lt;/a&gt; 기본 만료 메커니즘의 수정 &lt;a href=&quot;#section-14.9.4&quot;&gt;14.9.4&lt;/a&gt; 캐시 재확인하고 다시로드 컨트롤 &lt;a href=&quot;#section-14.9.5&quot;&gt;14.9.5&lt;/a&gt; 무 변환 지침 &lt;a href=&quot;#section-14.9.6&quot;&gt;14.9.6&lt;/a&gt; 캐시 제어 확장 &lt;a href=&quot;#section-14.10&quot;&gt;14.10&lt;/a&gt; 연결 &lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt; 컨텐트 인코딩 &lt;a href=&quot;#section-14.12&quot;&gt;14.12&lt;/a&gt; 컨텐트 언어 &lt;a href=&quot;#section-14.13&quot;&gt;14.13&lt;/a&gt; 컨텐트 길이 &lt;a href=&quot;#section-14.14&quot;&gt;14.14&lt;/a&gt; 컨텐트 위치 &lt;a href=&quot;#section-14.15&quot;&gt;14.15&lt;/a&gt; 컨텐트 MD5 &lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt; Content-Range &lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt; Content-Type &lt;a href=&quot;#section-14.18&quot;&gt;14.18&lt;/a&gt; Date &lt;a href=&quot;#section-14.18.1&quot;&gt;14.18.1&lt;/a&gt; Clockless Origin Server 작동 &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt; ETag &lt;a href=&quot;#section-14.20&quot;&gt;14.20&lt;/a&gt; 예상 &lt;a href=&quot;#section-14.21&quot;&gt;14.21&lt;/a&gt; 만료 &lt;a href=&quot;#section-14.22&quot;&gt;14.22&lt;/a&gt; From .......................... ........................... &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; 호스트 &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt; If-Match &lt;a href=&quot;#section-14.25&quot;&gt;14.25&lt;/a&gt; If-Modified-Since &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; If-None-Match &lt;a href=&quot;#section-14.27&quot;&gt;14.27&lt;/a&gt; If-Range &lt;a href=&quot;#section-14.28&quot;&gt;14.28&lt;/a&gt; 수정되지 않은 경우 &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt; 마지막으로 수정 한 &lt;a href=&quot;#section-14.30&quot;&gt;14.30&lt;/a&gt; 위치 &lt;a href=&quot;#section-14.31&quot;&gt;14.31&lt;/a&gt; 맥스는 감 &lt;a href=&quot;#section-14.32&quot;&gt;14.32&lt;/a&gt; 에서 Pragma &lt;a href=&quot;#section-14.33&quot;&gt;14.33&lt;/a&gt; 프록시 인증합니다 &lt;a href=&quot;#section-14.34&quot;&gt;14.34&lt;/a&gt; 프록시 인증 &lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt; 범위 &lt;a href=&quot;#section-14.35.1&quot;&gt;14.35.1&lt;/a&gt; 바이트 범위 &lt;a href=&quot;#section-14.35.2&quot;&gt;14.35.2&lt;/a&gt; 범위 검색이 요청 &lt;a href=&quot;#section-14.36&quot;&gt;14.36&lt;/a&gt; 리퍼러 &lt;a href=&quot;#section-14.37&quot;&gt;14.37&lt;/a&gt; 재시도 - 후 &lt;a href=&quot;#section-14.38&quot;&gt;14.38&lt;/a&gt; 서버 &lt;a href=&quot;#section-14.39&quot;&gt;14.39&lt;/a&gt; TE &lt;a href=&quot;#section-14.40&quot;&gt;14.40&lt;/a&gt; 예고편 &lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt; 전송 인코딩 &lt;a href=&quot;#section-14.42&quot;&gt;14.42&lt;/a&gt; 업그레이드 &lt;a href=&quot;#section-14.43&quot;&gt;14.43&lt;/a&gt; 사용자 에이전트 &lt;a href=&quot;#section-14.44&quot;&gt;14.44가&lt;/a&gt; 다름 &lt;a href=&quot;#section-14.45&quot;&gt;14.45&lt;/a&gt; 통해 &lt;a href=&quot;#section-14.46&quot;&gt;14.46&lt;/a&gt; 경고 &lt;a href=&quot;#section-14.47&quot;&gt;14.47&lt;/a&gt; WWW 인증 &lt;a href=&quot;#section-15&quot;&gt;15&lt;/a&gt; 보안 고려 사항 &lt;a href=&quot;#section-15.1&quot;&gt;15.1&lt;/a&gt; 개인 정보 &lt;a href=&quot;#section-15.1.1&quot;&gt;15.1.1&lt;/a&gt; 서버 로그 정보의 남용 &lt;a href=&quot;#section-15.1.2&quot;&gt;15.1.2&lt;/a&gt; 중요한 정보의 전송 &lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3&lt;/a&gt; URI의 민감한 정보 인코딩 &lt;a href=&quot;#section-15.1.4&quot;&gt;15.1.4&lt;/a&gt; 헤더를 수락하기 위해 연결된 개인 정보 문제 &lt;a href=&quot;#section-15.2&quot;&gt;15.2&lt;/a&gt; 파일 및 경로 기반 공격 이름 &lt;a href=&quot;#section-15.3&quot;&gt;15.3&lt;/a&gt; DNS 스푸핑 &lt;a href=&quot;#section-15.4&quot;&gt;15.4&lt;/a&gt; 위치 헤더 및 스푸핑 &lt;a href=&quot;#section-15.5&quot;&gt;15.5&lt;/a&gt; 콘텐츠 처리 문제 &lt;a href=&quot;#section-15.6&quot;&gt;15.6&lt;/a&gt; 인증 자격 증명 및 유휴 클라이언트 &lt;a href=&quot;#section-15.7&quot;&gt;15.7&lt;/a&gt; 프록시 및 캐싱 &lt;a href=&quot;#section-15.7.1&quot;&gt;15.7.1&lt;/a&gt; 프록시에 대한 서비스 거부 공격 &lt;a href=&quot;#section-16&quot;&gt;16&lt;/a&gt; 승인 &lt;a href=&quot;#section-17&quot;&gt;17&lt;/a&gt; 참조 &lt;a href=&quot;#section-18&quot;&gt;17&lt;/a&gt; 작성자 주소 &lt;a href=&quot;#section-19&quot;&gt;19&lt;/a&gt; 부록 &lt;a href=&quot;#section-19.1&quot;&gt;19.1&lt;/a&gt; 인터넷 미디어 유형 메시지 / http 및 응용 프로그램 / http &lt;a href=&quot;#section-19.2&quot;&gt;19.2&lt;/a&gt; 인터넷 미디어 유형 멀티 파트 / 바이트 범위 &lt;a href=&quot;#section-19.3&quot;&gt;19.3&lt;/a&gt; 허용 응용 프로그램 &lt;a href=&quot;#section-19.4&quot;&gt;19.4&lt;/a&gt; HTTP 엔티티와 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC의&lt;/a&gt; 차이점 2045 엔터티 .... &lt;a href=&quot;#section-19.4.1&quot;&gt;19.4.1&lt;/a&gt; MIME 버전 &lt;a href=&quot;#section-19.4.2&quot;&gt;19.4.2&lt;/a&gt; 정식 형식으로 변환 &lt;a href=&quot;#section-19.4.3&quot;&gt;19.4.3&lt;/a&gt; 날짜 형식 변환 &lt;a href=&quot;#section-19.4.4&quot;&gt;19.4.4&lt;/a&gt; 콘텐츠 인코딩의 소개 &lt;a href=&quot;#section-19.4.5&quot;&gt;19.4.5&lt;/a&gt; 아니오 내용 전송 인코딩 &lt;a href=&quot;#section-19.4.6&quot;&gt;19.4.6&lt;/a&gt; 전송 인코딩 소개 &lt;a href=&quot;#section-19.4.7&quot;&gt;19.4.7&lt;/a&gt; MHTML 및 라인 길이 제한 &lt;a href=&quot;#section-19.5&quot;&gt;19.5&lt;/a&gt; 추가 기능 &lt;a href=&quot;#section-19.5.1&quot;&gt;19.5.1&lt;/a&gt; 내용 - 처리 &lt;a href=&quot;#section-19.6&quot;&gt;19.6&lt;/a&gt; 이전 버전과의 호환성 &lt;a href=&quot;#section-19.6.1&quot;&gt;19.6.1을&lt;/a&gt; HTTP / 1.0의 변경 사항 &lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt; HTTP / 1.0 영구 연결과의 호환성 &lt;a href=&quot;#section-19.6.3&quot;&gt;19.6.3 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068의&lt;/a&gt; 변경 사항 &lt;a href=&quot;#section-20&quot;&gt;20&lt;/a&gt; 색인 &lt;a href=&quot;#section-21&quot;&gt;21&lt;/a&gt; 전체 저작권 정보</target>
        </trans-unit>
        <trans-unit id="d08c83f00b0f35b12328f45a668424f28ef4c379" translate="yes" xml:space="preserve">
          <source>Storing Responses in Caches (RFC 7234)</source>
          <target state="translated">캐시에 응답 저장 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="7ff86787ade1bf61ad2e59270f3c9e57589ff5d5" translate="yes" xml:space="preserve">
          <source>Stream priorities are changed using the PRIORITY frame.  Setting a
   dependency causes a stream to become dependent on the identified
   parent stream.

   Dependent streams move with their parent stream if the parent is
   reprioritized.  Setting a dependency with the exclusive flag for a
   reprioritized stream causes all the dependencies of the new parent
   stream to become dependent on the reprioritized stream.

   If a stream is made dependent on one of its own dependencies, the
   formerly dependent stream is first moved to be dependent on the
   reprioritized stream's previous parent.  The moved dependency retains
   its weight.

   For example, consider an original dependency tree where B and C
   depend on A, D and E depend on C, and F depends on D.  If A is made
   dependent on D, then D takes the place of A.  All other dependency
   relationships stay the same, except for F, which becomes dependent on
   A if the reprioritization is exclusive. 

       x                x                x                 x
       |               / \               |                 |
       A              D   A              D                 D
      / \            /   / \            / \                |
     B   C     ==&amp;gt;  F   B   C   ==&amp;gt;    F   A       OR      A
        / \                 |             / \             /|\
       D   E                E            B   C           B C F
       |                                     |             |
       F                                     E             E
                  (intermediate)   (non-exclusive)    (exclusive)

                Figure 5: Example of Dependency Reordering</source>
          <target state="translated">스트림 우선 순위는 PRIORITY 프레임을 사용하여 변경됩니다. 종속성을 설정하면 스트림이 식별 된 상위 스트림에 종속됩니다. 종속 스트림은 상위 스트림의 우선 순위가 재 지정되면 상위 스트림과 함께 이동합니다. 우선 순위가 재 지정된 스트림에 대해 배타적 플래그를 사용하여 종속성을 설정하면 새 상위 스트림의 모든 종속성이 우선 순위가 재 지정된 스트림에 종속됩니다. 스트림이 자체 종속성 중 하나에 종속 된 경우 이전에 종속 된 스트림이 우선 순위가 재 지정된 스트림의 이전 상위에 종속되도록 먼저 이동됩니다. 이동 된 종속성은 가중치를 유지합니다. 예를 들어 B와 C가 A에 의존하고, D와 E가 C에 의존하고, F가 D에 의존하는 원래의 종속성 트리를 생각해보십시오. A가 D에 의존하게되면 D가 A를 대신합니다. 다른 모든 종속성 관계는 그대로 유지됩니다. F를 제외하고는 동일합니다.우선 순위 재 지정이 배타적이면 A에 종속됩니다. xxxx | / \ | | ADADD / \ / / \ / \ | BC ==&amp;gt; FBC ==&amp;gt; FA 또는 A / \ | / \ / | \ DEEBCBCF | | | FEE (중급) (비 독점) (독점) 그림 5 : 종속성 재정렬의 예</target>
        </trans-unit>
        <trans-unit id="bce8f34f0a23969364026999a31bec5f7b65b0ae" translate="yes" xml:space="preserve">
          <source>Streams are identified with an unsigned 31-bit integer.  Streams
   initiated by a client MUST use odd-numbered stream identifiers; those
   initiated by the server MUST use even-numbered stream identifiers.  A
   stream identifier of zero (0x0) is used for connection control
   messages; the stream identifier of zero cannot be used to establish a
   new stream.

   HTTP/1.1 requests that are upgraded to HTTP/2 (see &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;) are
   responded to with a stream identifier of one (0x1).  After the
   upgrade completes, stream 0x1 is &quot;half-closed (local)&quot; to the client.
   Therefore, stream 0x1 cannot be selected as a new stream identifier
   by a client that upgrades from HTTP/1.1.

   The identifier of a newly established stream MUST be numerically
   greater than all streams that the initiating endpoint has opened or
   reserved.  This governs streams that are opened using a HEADERS frame
   and streams that are reserved using PUSH_PROMISE.  An endpoint that
   receives an unexpected stream identifier MUST respond with a
   connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   The first use of a new stream identifier implicitly closes all
   streams in the &quot;idle&quot; state that might have been initiated by that
   peer with a lower-valued stream identifier.  For example, if a client
   sends a HEADERS frame on stream 7 without ever sending a frame on
   stream 5, then stream 5 transitions to the &quot;closed&quot; state when the
   first frame for stream 7 is sent or received.

   Stream identifiers cannot be reused.  Long-lived connections can
   result in an endpoint exhausting the available range of stream
   identifiers.  A client that is unable to establish a new stream
   identifier can establish a new connection for new streams.  A server
   that is unable to establish a new stream identifier can send a GOAWAY
   frame so that the client is forced to open a new connection for new
   streams.</source>
          <target state="translated">스트림은 부호없는 31 비트 정수로 식별됩니다. 클라이언트에 의해 시작된 스트림은 홀수 번호의 스트림 식별자를 사용해야합니다. 서버에 의해 시작된 것은 반드시 짝수 스트림 식별자를 사용해야합니다. 0x0의 스트림 식별자는 연결 제어 메시지에 사용됩니다. 0의 스트림 식별자는 새 스트림을 설정하는 데 사용할 수 없습니다. HTTP / 2로 업그레이드 된 HTTP / 1.1 요청 ( &lt;a href=&quot;#section-3.2&quot;&gt;섹션 3.2&lt;/a&gt; 참조))는 스트림 식별자 1 (0x1)로 응답합니다. 업그레이드가 완료된 후 스트림 0x1은 클라이언트에 대해 &quot;반 폐쇄 (로컬)&quot;상태가됩니다. 따라서 HTTP / 1.1에서 업그레이드하는 클라이언트는 스트림 0x1을 새 스트림 식별자로 선택할 수 없습니다. 새로 설정된 스트림의 식별자는 시작 엔드 포인트가 열거 나 예약 한 모든 스트림보다 숫자 적으로 커야합니다. 이는 HEADERS 프레임을 사용하여 열리는 스트림과 PUSH_PROMISE를 사용하여 예약 된 스트림을 제어합니다. 예기치 않은 스트림 식별자를 수신 한 엔드 포인트는 연결 오류로 응답해야합니다 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt;) PROTOCOL_ERROR 유형입니다. 새 스트림 식별자를 처음 사용하면 값이 낮은 스트림 식별자를 사용하여 해당 피어가 시작했을 수있는 &quot;유휴&quot;상태의 모든 스트림이 암시 적으로 닫힙니다. 예를 들어 클라이언트가 스트림 5에서 프레임을 전송하지 않고 스트림 7에서 HEADERS 프레임을 전송하면 스트림 7의 첫 번째 프레임이 전송되거나 수신 될 때 스트림 5가 &quot;닫힘&quot;상태로 전환됩니다. 스트림 식별자는 재사용 할 수 없습니다. 연결이 오래 지속되면 엔드 포인트가 사용 가능한 스트림 식별자 범위를 고갈시킬 수 있습니다. 새 스트림 식별자를 설정할 수없는 클라이언트는 새 스트림에 대한 새 연결을 설정할 수 있습니다. 새 스트림 식별자를 설정할 수없는 서버는 클라이언트가 새 스트림에 대한 새 연결을 열도록 강제로 GOAWAY 프레임을 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1c0b3831b3706354655bc626dc41410ec27c9ee" translate="yes" xml:space="preserve">
          <source>Strict Transport Security resolves this problem; as long as you've accessed your bank's web site once using HTTPS, and the bank's web site uses Strict Transport Security, your browser will know to automatically use only HTTPS, which prevents hackers from performing this sort of man-in-the-middle attack.</source>
          <target state="translated">엄격한 전송 보안은이 문제를 해결합니다. HTTPS를 사용하여 은행 웹 사이트에 한 번 액세스하고 은행 웹 사이트가 Strict Transport Security를 ​​사용하는 한, 브라우저는 HTTPS 만 자동으로 사용하므로 해커가 이러한 종류의 중간자 (man-in-the-middle)를 수행하지 못하게됩니다. 공격.</target>
        </trans-unit>
        <trans-unit id="fc587e4b5dd9c8f2dabaee348836f36fc9073981" translate="yes" xml:space="preserve">
          <source>Strict-Transport-Security</source>
          <target state="translated">Strict-Transport-Security</target>
        </trans-unit>
        <trans-unit id="b47d9bc682e1c7c17d99058428f34fc877b82f8a" translate="yes" xml:space="preserve">
          <source>Strong validation</source>
          <target state="translated">강력한 검증</target>
        </trans-unit>
        <trans-unit id="bce009dcd1fa74e08bb9b002217d1633ae7d181e" translate="yes" xml:space="preserve">
          <source>Strong validation consists of guaranteeing that the resource is, byte to byte, identical to the one it is compared too. This is mandatory for some conditional headers, and the default for the others. Strong validation is very strict and may be difficult to guarantee at the server level, but it does guarantee no data loss at any time, sometimes at the expense of performance.</source>
          <target state="translated">강력한 유효성 검사는 리소스가 비교되는 리소스와 동일하다는 것을 보장합니다. 일부 조건부 헤더의 경우 필수이고 다른 조건부 헤더의 경우 기본값입니다. 강력한 유효성 검사는 매우 엄격하며 서버 수준에서 보장하기 어려울 수 있지만 때로는 성능 저하로 인해 데이터 손실을 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="546f797f485e1c93debf33798738f22e2e2c71a9" translate="yes" xml:space="preserve">
          <source>Structure of a MIME type</source>
          <target state="translated">MIME 유형의 구조</target>
        </trans-unit>
        <trans-unit id="2a9b0645b4584767c896ce8933cbb6a249c16aa0" translate="yes" xml:space="preserve">
          <source>Structure of a server response</source>
          <target state="translated">서버 응답의 구조</target>
        </trans-unit>
        <trans-unit id="87e09f53c79b7b9952020efdce6fce234ef5dd58" translate="yes" xml:space="preserve">
          <source>Subnet based decisions</source>
          <target state="translated">서브넷 기반 결정</target>
        </trans-unit>
        <trans-unit id="d0b8ad91fc39a9beb48e35304c9f430f0a69862b" translate="yes" xml:space="preserve">
          <source>Subresource Integrity</source>
          <target state="translated">하위 자원 무결성</target>
        </trans-unit>
        <trans-unit id="983f9ac400958792e64abc2d44401492ed778563" translate="yes" xml:space="preserve">
          <source>Subresource Integrity&lt;br/&gt;&lt;small&gt;The definition of 'require-sri-for' in that specification.&lt;/small&gt;</source>
          <target state="translated">하위 자원 무결성 &lt;br/&gt;&lt;small&gt;해당 사양에서 '요구-스리-포'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="522495833932f57c0df7141327df306caf0e6ac3" translate="yes" xml:space="preserve">
          <source>Subsequent lines represent an HTTP header, giving the server information about what type of data is appropriate (e.g., what language, what MIME types), or other data altering its behavior (e.g., not sending an answer if it is already cached). These HTTP headers form a block which ends with an empty line.</source>
          <target state="translated">후속 행은 HTTP 헤더를 나타내며 서버에 적합한 데이터 유형 (예 : 언어, MIME 유형) 또는 동작을 변경하는 다른 데이터 (예 : 이미 캐시 된 경우 응답을 보내지 않음)에 대한 정보를 서버에 제공합니다. 이 HTTP 헤더는 빈 줄로 끝나는 블록을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="8d055925604926e85c70a546b297fe94724c7c5d" translate="yes" xml:space="preserve">
          <source>Subsequent lines represent specific HTTP headers, giving the client information about the data sent (e.g. type, data size, compression algorithm used, hints about caching). Similarly to the block of HTTP headers for a client request, these HTTP headers form a block ending with an empty line.</source>
          <target state="translated">후속 행은 특정 HTTP 헤더를 나타내며, 클라이언트에게 전송 된 데이터에 대한 정보 (예 : 유형, 데이터 크기, 사용 된 압축 알고리즘, 캐싱에 대한 힌트)를 제공합니다. 클라이언트 요청에 대한 HTTP 헤더 블록과 마찬가지로이 HTTP 헤더는 빈 줄로 끝나는 블록을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="56befc0f91be9db5dc24b49f4e5533e7ea0072f5" translate="yes" xml:space="preserve">
          <source>Subsequent sections discuss scenarios, as well as provide a breakdown of the HTTP headers used.</source>
          <target state="translated">다음 섹션에서는 시나리오에 대해 설명하고 사용 된 HTTP 헤더에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ff5c588e9523269ce3c84f63e9bd3897ebe63eec" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; of the distant resource is different to each listed in this header. By default, unless the etag is prefixed with &lt;code&gt;'W/'&lt;/code&gt;, it performs a strong validation.</source>
          <target state="translated">원격 자원 의 &lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 가이 헤더에 나열된 것과 다른 경우에 성공합니다 . 기본적으로 etag 앞에 &lt;code&gt;'W/'&lt;/code&gt; 가 붙지 않으면 강력한 유효성 검사가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="aeef7e868363979461d6ea2ad7bf8c6358e365a2" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; of the distant resource is equal to one listed in this header. By default, unless the etag is prefixed with &lt;code&gt;'W/'&lt;/code&gt;, it performs a strong validation.</source>
          <target state="translated">원격 자원 의 &lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 가이 헤더에 나열된 것과 동일 하면 성공합니다 . 기본적으로 etag 앞에 &lt;code&gt;'W/'&lt;/code&gt; 가 붙지 않으면 강력한 유효성 검사가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2c3bd70cb1b0ac4e3f147078e58e04d441ea7e0e" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; date of the distant resource is more recent than the one given in this header.</source>
          <target state="translated">원격 자원 의 &lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; 날짜가이 헤더에 제공된 것보다 최신 인 경우에 성공합니다 .</target>
        </trans-unit>
        <trans-unit id="54dce543ac7122114b0f1b25a6c18db4700a57c7" translate="yes" xml:space="preserve">
          <source>Succeeds if the &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; date of the distant resource is older or the same than the one given in this header.</source>
          <target state="translated">원격 자원 의 &lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; 날짜가이 헤더에 제공된 날짜보다 오래되었거나 같은 경우에 성공합니다 .</target>
        </trans-unit>
        <trans-unit id="1290a72cee06cf30f2b9582a53c05c695119f17b" translate="yes" xml:space="preserve">
          <source>Successful response has body</source>
          <target state="translated">성공적인 응답에는 신체가 있습니다</target>
        </trans-unit>
        <trans-unit id="d702cfd3f57a8cfe18b4f37a36bf15bc2c548094" translate="yes" xml:space="preserve">
          <source>Successful responses</source>
          <target state="translated">성공적인 응답</target>
        </trans-unit>
        <trans-unit id="47bd58ec264925cf6d2934f949144bd5b42d3e5b" translate="yes" xml:space="preserve">
          <source>Successful responses (&lt;code&gt;200&lt;/code&gt;&amp;ndash;&lt;code&gt;299&lt;/code&gt;)</source>
          <target state="translated">성공적인 응답 ( &lt;code&gt;200&lt;/code&gt; &amp;ndash; &lt;code&gt;299&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7e16e36ee4dff516de670a1cd0a9ef3f413ae5fb" translate="yes" xml:space="preserve">
          <source>Successful results of a retrieval request: a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (OK) response to a &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; request containing a resource like HTML documents, images or files.</source>
          <target state="translated">검색 요청의 성공적인 결과 : HTML 문서, 이미지 또는 파일과 같은 자원을 포함하는 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 요청에 대한 &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; (OK) 응답 .</target>
        </trans-unit>
        <trans-unit id="7cf7d910e383411b293ea5c44eeeb1c0a4a4a122" translate="yes" xml:space="preserve">
          <source>Successful web page response:</source>
          <target state="translated">성공적인 웹 페이지 응답 :</target>
        </trans-unit>
        <trans-unit id="201d1d5e3d5c9d5de591a119116dd6b9386319e3" translate="yes" xml:space="preserve">
          <source>Supplants the &lt;code&gt;Origin&lt;/code&gt; header as defined in RFC6454.</source>
          <target state="translated">RFC6454에 정의 된대로 &lt;code&gt;Origin&lt;/code&gt; 헤더를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="216a84fbd27cb3b4473b824b61cc5de56085403b" translate="yes" xml:space="preserve">
          <source>Support for the &lt;code&gt;Retry-After&lt;/code&gt; header on both clients and servers is still inconsistent. However, some crawlers and spiders, like the Googlebot, honor the &lt;code&gt;Retry-After&lt;/code&gt; header. It is useful to send it along with a &lt;a href=&quot;../status/503&quot;&gt;&lt;code&gt;503&lt;/code&gt;&lt;/a&gt; (Service Unavailable) response, so that search engines will keep indexing your site when the downtime is over.</source>
          <target state="translated">클라이언트와 서버 모두 에서 &lt;code&gt;Retry-After&lt;/code&gt; 헤더에 대한 지원 이 여전히 일치하지 않습니다. 그러나 Googlebot과 같은 일부 크롤러 및 스파이더는 &lt;code&gt;Retry-After&lt;/code&gt; 헤더를 존중합니다 . 다운 타임이 끝날 때 검색 엔진이 사이트 색인을 유지하도록 &lt;a href=&quot;../status/503&quot;&gt; &lt;code&gt;503&lt;/code&gt; &lt;/a&gt; (Service Unavailable) 응답 과 함께 전송하는 것이 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="4c6167e7995d17c7bc37724de85e632d49fe0fd7" translate="yes" xml:space="preserve">
          <source>Support of &lt;a href=&quot;../headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; allows the dissociation of the identification and the location of a given resource, allowing for a smarter &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CDN&quot;&gt;CDN&lt;/a&gt; caching mechanism.</source>
          <target state="translated">&lt;a href=&quot;../headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; 를&lt;/a&gt; 지원 하면 식별 및 지정된 자원의 위치를 ​​분리 할 수있어보다 스마트 한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CDN&quot;&gt;CDN&lt;/a&gt; 캐싱 메커니즘이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5557d57c74c062096ddfe6fcacebab65584a47fd" translate="yes" xml:space="preserve">
          <source>Supported digest algorithms are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3230&quot;&gt;RFC 3230&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc5843&quot;&gt;RFC 5843&lt;/a&gt;, and include &lt;code&gt;SHA-256&lt;/code&gt; and &lt;code&gt;SHA-512&lt;/code&gt;. Some of the supported algorithms, including &lt;code&gt;unixsum&lt;/code&gt; and &lt;code&gt;MD5&lt;/code&gt; are subject to collisions and are thus not suitable for applications in which collision-resistance is important.</source>
          <target state="translated">지원되는 다이제스트 알고리즘은 &lt;a href=&quot;https://tools.ietf.org/html/rfc3230&quot;&gt;RFC 3230&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc5843&quot;&gt;RFC 5843에&lt;/a&gt; 정의되어 있으며 &lt;code&gt;SHA-256&lt;/code&gt; 및 &lt;code&gt;SHA-512&lt;/code&gt; 를 포함 합니다. &lt;code&gt;unixsum&lt;/code&gt; 및 &lt;code&gt;MD5&lt;/code&gt; 를 포함하여 지원되는 알고리즘 중 일부는 충돌의 영향을 받기 때문에 충돌 저항이 중요한 애플리케이션에는 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9cf8d0d7c981d663797eeaca7523e977bed4ab51" translate="yes" xml:space="preserve">
          <source>Supporting OCSP stapling (that is, the &lt;code&gt;status_request&lt;/code&gt; TLS extension) and providing a &lt;code&gt;SignedCertificateTimestampList&lt;/code&gt;</source>
          <target state="translated">OCSP 스테이플 링 (즉, &lt;code&gt;status_request&lt;/code&gt; TLS 확장) 지원 및 &lt;code&gt;SignedCertificateTimestampList&lt;/code&gt; 제공</target>
        </trans-unit>
        <trans-unit id="d1d598d97e68fd3cf7ac8ec2441b332f10d641fc" translate="yes" xml:space="preserve">
          <source>Switch to a blacklist model for restricted Accept headers in simple CORS requests</source>
          <target state="translated">간단한 CORS 요청에서 제한된 Accept 헤더에 대한 블랙리스트 모델로 전환</target>
        </trans-unit>
        <trans-unit id="57ebc7fe25f3af6b8e76fe3b492c6dd20ec4df27" translate="yes" xml:space="preserve">
          <source>Switching protocols might be used with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API&quot;&gt;WebSockets&lt;/a&gt;.</source>
          <target state="translated">스위칭 프로토콜은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API&quot;&gt;WebSocket&lt;/a&gt; 과 함께 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00d7e2af1a23453b6e8dc5b63832fd4a645bc527" translate="yes" xml:space="preserve">
          <source>Synchronous XMLHTTPRequest</source>
          <target state="translated">동기 XMLHTTPRequest</target>
        </trans-unit>
        <trans-unit id="4103f0b31624fefeee3cf5f8642cc1c83ff9a978" translate="yes" xml:space="preserve">
          <source>Synchronous XMLHttpRequest</source>
          <target state="translated">동기 XMLHttpRequest</target>
        </trans-unit>
        <trans-unit id="be9208425b9c861fee1e1a67180b55dad01dafe7" translate="yes" xml:space="preserve">
          <source>Synchronous scripts</source>
          <target state="translated">동기식 스크립트</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="791a9bf2077653138c6b3912f9bf31ac1b906662" translate="yes" xml:space="preserve">
          <source>Syntax of Uniform Resource Identifiers (URIs)</source>
          <target state="translated">URI (Uniform Resource Identifier)의 구문</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="b10d92078103e058dd32c50f84517f2c9bcce935" translate="yes" xml:space="preserve">
          <source>TCP connection to the server timed out</source>
          <target state="translated">서버에 대한 TCP 연결 시간이 초과되었습니다.</target>
        </trans-unit>
        <trans-unit id="5a056389515bd999bc97e7793f7c147c0b47eac3" translate="yes" xml:space="preserve">
          <source>TCP port number on which the server is listening.</source>
          <target state="translated">서버가 청취중인 TCP 포트 번호</target>
        </trans-unit>
        <trans-unit id="49a198744d47717f2dedc61eda3abad936b310a2" translate="yes" xml:space="preserve">
          <source>TCP port number on which the server is listening. If no port is given, the default port for the service requested (e.g., &quot;80&quot; for an HTTP URL) is implied.</source>
          <target state="translated">서버가 청취중인 TCP 포트 번호 포트가 제공되지 않으면 요청 된 서비스의 기본 포트 (예 : HTTP URL의 경우 &quot;80&quot;)가 암시됩니다.</target>
        </trans-unit>
        <trans-unit id="1945ca5513cf77b8240e53495ba7a26e86acaca7" translate="yes" xml:space="preserve">
          <source>TE</source>
          <target state="translated">TE</target>
        </trans-unit>
        <trans-unit id="2dd200ebd9f2359780d12717e9c2166303c7a6d3" translate="yes" xml:space="preserve">
          <source>TE (RFC 2616)</source>
          <target state="translated">TE (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="a775b64f2cd6a88a198986d46d44e0a021785125" translate="yes" xml:space="preserve">
          <source>TIFF</source>
          <target state="translated">TIFF</target>
        </trans-unit>
        <trans-unit id="b698c11e84460ed5999bfeb5cbf25b865c238f3c" translate="yes" xml:space="preserve">
          <source>TODO</source>
          <target state="translated">TODO</target>
        </trans-unit>
        <trans-unit id="ddf8a55c683ee58c6268b4264acb1d703195d588" translate="yes" xml:space="preserve">
          <source>TRACE</source>
          <target state="translated">TRACE</target>
        </trans-unit>
        <trans-unit id="0d5266ebda7b5b7ca016e3ecbf8bfe060fe9dd53" translate="yes" xml:space="preserve">
          <source>TRACE (RFC 7231)</source>
          <target state="translated">TRACE (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="1223c0da5965757fa8d93336605832a0144596b6" translate="yes" xml:space="preserve">
          <source>TRACE: The message body contains the request message as received by the server</source>
          <target state="translated">TRACE : 메시지 본문에 서버가 수신 한 요청 메시지가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="56ab49a5c68f11cc45c651da6a3f339eff2853f8" translate="yes" xml:space="preserve">
          <source>TV</source>
          <target state="translated">TV</target>
        </trans-unit>
        <trans-unit id="fabcacd2a76a1a809975d60d7982c2a1035ab1c0" translate="yes" xml:space="preserve">
          <source>Tablet</source>
          <target state="translated">Tablet</target>
        </trans-unit>
        <trans-unit id="7193b142ed8cd6bae9bcd7f28df4d59bf30c7919" translate="yes" xml:space="preserve">
          <source>Tablet versions on WebView mirror mobile, but do not contain a &lt;code&gt;Mobile&lt;/code&gt; token.</source>
          <target state="translated">WebView의 태블릿 버전은 모바일을 미러링하지만 &lt;code&gt;Mobile&lt;/code&gt; 토큰 은 포함하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e63d48cf86b47f4a2e41a4c2480abd63617e07ff" translate="yes" xml:space="preserve">
          <source>Tagged Image File Format</source>
          <target state="translated">태그가 지정된 이미지 파일 형식</target>
        </trans-unit>
        <trans-unit id="6c352e4dbdd3d9d5e6127303b4e65a452119231a" translate="yes" xml:space="preserve">
          <source>Tagged Image File Format (TIFF)</source>
          <target state="translated">태그가 지정된 이미지 파일 형식 (TIFF)</target>
        </trans-unit>
        <trans-unit id="5c1a98fc42374c0534b21a7c408be88b0b460645" translate="yes" xml:space="preserve">
          <source>Tags and summary</source>
          <target state="translated">태그 및 요약</target>
        </trans-unit>
        <trans-unit id="03b91e28fed7956fe56ed8f65fc65fd882bbb491" translate="yes" xml:space="preserve">
          <source>Tags for the Identification of Language</source>
          <target state="translated">언어 식별 용 태그</target>
        </trans-unit>
        <trans-unit id="40a1df0d175828bc0ac87d97cb74122c8c8d4d00" translate="yes" xml:space="preserve">
          <source>Takes precedence over &lt;code&gt;max-age&lt;/code&gt; or the &lt;code&gt;Expires&lt;/code&gt; header, but it only applies to shared caches (e.g., proxies) and is ignored by a private cache.</source>
          <target state="translated">&lt;code&gt;max-age&lt;/code&gt; 또는 &lt;code&gt;Expires&lt;/code&gt; 헤더 보다 우선 하지만 공유 캐시 (예 : 프록시)에만 적용되며 개인 캐시에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c149ac475d4a9b7fd2b15c7870c52269b0872366" translate="yes" xml:space="preserve">
          <source>Tape Archive (TAR)</source>
          <target state="translated">테이프 아카이브 (TAR)</target>
        </trans-unit>
        <trans-unit id="a9bdde16c71950f9f0a80cbf4ce3915950ed2150" translate="yes" xml:space="preserve">
          <source>Targets of caching operations</source>
          <target state="translated">캐싱 작업의 대상</target>
        </trans-unit>
        <trans-unit id="d9c7795d9a943127c5b4d89543f3db9a1ffaae49" translate="yes" xml:space="preserve">
          <source>Technically a part of Device Memory API, this header represents an approximate amount of RAM client has.</source>
          <target state="translated">기술적으로 Device Memory API의 일부인이 헤더는 클라이언트가 보유한 RAM의 대략적인 양을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2313e8c800252c9ae07b4e97927a6d9cf9ac1b33" translate="yes" xml:space="preserve">
          <source>Techniques for canonical URLs</source>
          <target state="translated">표준 URL 기법</target>
        </trans-unit>
        <trans-unit id="04e57122701fa97f61a068ec7bd222827a269a62" translate="yes" xml:space="preserve">
          <source>Tells the browser that the page being loaded is going to want to perform a large allocation.</source>
          <target state="translated">로드중인 페이지가 큰 할당을 수행하려고 함을 브라우저에 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="c8c8d2a564da5b504842208aff51d3ccfc991895" translate="yes" xml:space="preserve">
          <source>Tells the client the server's prefered encoding scheme when submiting a username and password. The only allowed value is the case insensitive string &quot;UTF-8&quot;. This does not relate to the encoding of the realm string.</source>
          <target state="translated">사용자 이름과 비밀번호를 제출할 때 클라이언트에게 서버가 선호하는 인코딩 체계를 알려줍니다. 허용되는 유일한 값은 대소 문자를 구분하지 않는 문자열 &quot;UTF-8&quot;입니다. 이것은 영역 문자열의 인코딩과 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3e310a9a1efd6f1548ce06a7ac2dc4748669f825" translate="yes" xml:space="preserve">
          <source>Tells the client the server's prefered encoding scheme when submitting a username and password. The only allowed value is the case insensitive string &quot;UTF-8&quot;. This does not relate to the encoding of the realm string.</source>
          <target state="translated">사용자 이름과 암호를 제출할 때 서버가 선호하는 인코딩 체계를 클라이언트에 알립니다. 허용되는 유일한 값은 대소 문자를 구분하지 않는 문자열 &quot;UTF-8&quot;입니다. 이것은 영역 문자열의 인코딩과 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e58df9f49057b700376e3c8d719874a09fcdc736" translate="yes" xml:space="preserve">
          <source>Tells the user-agent to reset the document which sent this request.</source>
          <target state="translated">사용자 에이전트에게이 요청을 보낸 문서를 재설정하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="86f4edbe4b69402bc32c890fe46456f6b42c2ad1" translate="yes" xml:space="preserve">
          <source>Temporary redirections</source>
          <target state="translated">임시 리디렉션</target>
        </trans-unit>
        <trans-unit id="7aefd5b2f288adc48ce6a117e81f357d1eed0b40" translate="yes" xml:space="preserve">
          <source>Temporary redirects during site maintenance or downtime</source>
          <target state="translated">사이트 유지 관리 또는 다운 타임 동안 임시 리디렉션</target>
        </trans-unit>
        <trans-unit id="6b029c546a5b81b886574d6c63becc55db5c5c32" translate="yes" xml:space="preserve">
          <source>Temporary responses to long requests</source>
          <target state="translated">긴 요청에 대한 임시 응답</target>
        </trans-unit>
        <trans-unit id="44729f34632c3c8c496e4f38b8037aa7c3dfb175" translate="yes" xml:space="preserve">
          <source>Temporary responses to unsafe requests</source>
          <target state="translated">안전하지 않은 요청에 대한 임시 응답</target>
        </trans-unit>
        <trans-unit id="66ad9b49478e00d9521f776ed94bddcd7f501cea" translate="yes" xml:space="preserve">
          <source>Testing your policy</source>
          <target state="translated">정책 테스트</target>
        </trans-unit>
        <trans-unit id="c3328c39b0e29f78e9ff45db674248b1d245887d" translate="yes" xml:space="preserve">
          <source>Text</source>
          <target state="translated">Text</target>
        </trans-unit>
        <trans-unit id="9845ab8961b7e4a2e464fba53a5a9a896b568e17" translate="yes" xml:space="preserve">
          <source>Text, (generally ASCII or ISO 8859-&lt;em&gt;n&lt;/em&gt;)</source>
          <target state="translated">텍스트 (일반적으로 ASCII 또는 ISO 8859- &lt;em&gt;n&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="dd0fe1624d9684bcb52e0cccdb484d7e2001e225" translate="yes" xml:space="preserve">
          <source>Text-only data including any human-readable content, source code, or textual data such as comma-separated value (CSV) formatted data. Examples include &lt;code&gt;text/plain&lt;/code&gt;, &lt;code&gt;text/csv&lt;/code&gt;, and &lt;code&gt;text/html&lt;/code&gt;.</source>
          <target state="translated">사람이 읽을 수있는 콘텐츠, 소스 코드 또는 CSV (쉼표로 구분 된 값) 형식 데이터와 같은 텍스트 데이터를 포함하는 텍스트 전용 데이터입니다. 예를 들면 &lt;code&gt;text/plain&lt;/code&gt; , &lt;code&gt;text/csv&lt;/code&gt; 및 &lt;code&gt;text/html&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="41e7a7ed719d0daa7e0a2e3d48d3aa52fa318aae" translate="yes" xml:space="preserve">
          <source>Thanks to its extensibility &amp;ndash; creating new headers or methods is easy &amp;ndash; and even if the HTTP/1.1 protocol was refined over two revisions, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; published in June 1999 and the series of &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;-&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt; published in June 2014 in prevision of the release of HTTP/2, this protocol has been extremely stable over more than 15 years.</source>
          <target state="translated">확장 성 (새 헤더 또는 메소드 작성이 용이함)으로 인해 HTTP / 1.1 프로토콜이 두 가지 개정으로 수정 된 경우에도 1999 년 6 월에 발행 된 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; 및 2014 년 6 월에 발행 된 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt; - &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt; 시리즈 HTTP / 2 릴리스에서이 프로토콜은 15 년 이상 동안 매우 안정적입니다.</target>
        </trans-unit>
        <trans-unit id="cd15a270847553d0286663fce338c3186c3904d8" translate="yes" xml:space="preserve">
          <source>Thanks to the &lt;a href=&quot;../headers/host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; header, the ability to host different domains at the same IP address now allows server collocation.</source>
          <target state="translated">&lt;a href=&quot;../headers/host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; 헤더 덕분에 동일한 IP 주소에서 다른 도메인을 호스트 할 수있어 서버 배치가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="24cf3eddb29388191b3cd3ec808e71bc6c5fd48a" translate="yes" xml:space="preserve">
          <source>Thanks to the &lt;a href=&quot;../headers/host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; header, the ability to host different domains at the same IP address now allows server colocation.</source>
          <target state="translated">&lt;a href=&quot;../headers/host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; 헤더 덕분에 동일한 IP 주소에서 다른 도메인을 호스팅하는 기능을 통해 이제 서버 코 로케이션이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0c0b92cdd8e1ab117b52ae806f278493aef32784" translate="yes" xml:space="preserve">
          <source>That way, you still upgrade insecure requests on your secure site, but the only monitoring policy is violated and reports insecure resources to your endpoint.</source>
          <target state="translated">이렇게하면 보안 사이트에서 안전하지 않은 요청을 계속 업그레이드 할 수 있지만 유일한 모니터링 정책을 위반하고 안전하지 않은 리소스를 엔드 포인트에보고합니다.</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="30bedea71a5adc4d8f862982f2915b1068fb6576" translate="yes" xml:space="preserve">
          <source>The &quot;Accept&quot; header field can be used by user agents to specify
   response media types that are acceptable.  Accept header fields can
   be used to indicate that the request is specifically limited to a
   small set of desired types, as in the case of a request for an
   in-line image.

     Accept = #( media-range [ accept-params ] )

     media-range    = ( &quot;*/*&quot;
                      / ( type &quot;/&quot; &quot;*&quot; )
                      / ( type &quot;/&quot; subtype )
                      ) *( OWS &quot;;&quot; OWS parameter )
     accept-params  = weight *( accept-ext )
     accept-ext = OWS &quot;;&quot; OWS token [ &quot;=&quot; ( token / quoted-string ) ]

   The asterisk &quot;*&quot; character is used to group media types into ranges,
   with &quot;*/*&quot; indicating all media types and &quot;type/*&quot; indicating all
   subtypes of that type.  The media-range can include media type
   parameters that are applicable to that range.

   Each media-range might be followed by zero or more applicable media
   type parameters (e.g., charset), an optional &quot;q&quot; parameter for
   indicating a relative weight (&lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;), and then zero or more
   extension parameters.  The &quot;q&quot; parameter is necessary if any
   extensions (accept-ext) are present, since it acts as a separator
   between the two parameter sets.

      Note: Use of the &quot;q&quot; parameter name to separate media type
      parameters from Accept extension parameters is due to historical
      practice.  Although this prevents any media type parameter named
      &quot;q&quot; from being used with a media range, such an event is believed
      to be unlikely given the lack of any &quot;q&quot; parameters in the IANA 

      media type registry and the rare usage of any media type
      parameters in Accept.  Future media types are discouraged from
      registering any parameter named &quot;q&quot;.

   The example

     Accept: audio/*; q=0.2, audio/basic

   is interpreted as &quot;I prefer audio/basic, but send me any audio type
   if it is the best available after an 80% markdown in quality&quot;.

   A request without any Accept header field implies that the user agent
   will accept any media type in response.  If the header field is
   present in a request and none of the available representations for
   the response have a media type that is listed as acceptable, the
   origin server can either honor the header field by sending a 406 (Not
   Acceptable) response or disregard the header field by treating the
   response as if it is not subject to content negotiation.

   A more elaborate example is

     Accept: text/plain; q=0.5, text/html,
             text/x-dvi; q=0.8, text/x-c

   Verbally, this would be interpreted as &quot;text/html and text/x-c are
   the equally preferred media types, but if they do not exist, then
   send the text/x-dvi representation, and if that does not exist, send
   the text/plain representation&quot;.

   Media ranges can be overridden by more specific media ranges or
   specific media types.  If more than one media range applies to a
   given type, the most specific reference has precedence.  For example,

     Accept: text/*, text/plain, text/plain;format=flowed, */*

   have the following precedence:

   1.  text/plain;format=flowed

   2.  text/plain

   3.  text/*

   4.  */*

   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   that matches the type.  For example, 

     Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
             text/html;level=2;q=0.4, */*;q=0.5

   would cause the following values to be associated:

   +-------------------+---------------+
   | Media Type        | Quality Value |
   +-------------------+---------------+
   | text/html;level=1 | 1             |
   | text/html         | 0.7           |
   | text/plain        | 0.3           |
   | image/jpeg        | 0.5           |
   | text/html;level=2 | 0.4           |
   | text/html;level=3 | 0.7           |
   +-------------------+---------------+

   Note: A user agent might be provided with a default set of quality
   values for certain media ranges.  However, unless the user agent is a
   closed system that cannot interact with other rendering agents, this
   default set ought to be configurable by the user.</source>
          <target state="translated">&quot;Accept&quot;헤더 필드는 사용자 에이전트가 사용 가능한 응답 매체 유형을 지정하는 데 사용할 수 있습니다. 수락 헤더 필드는 인라인 이미지에 대한 요청과 같이 요청이 원하는 유형의 작은 세트로 특별히 제한됨을 나타내는 데 사용될 수 있습니다. 수락 = # (미디어 범위 [accept-params]) 미디어 범위 = ( &quot;* / *&quot;/ (유형 &quot;/&quot; &quot;*&quot;) / (유형 &quot;/&quot;하위 유형)) * (OWS &quot;;&quot;OWS 매개 변수 ) accept-params = weight * (accept-ext) accept-ext = OWS &quot;;&quot; OWS token [ &quot;=&quot;(token / quoted-string)] 별표 &quot;*&quot;문자는 미디어 유형을 범위로 그룹화하는 데 사용되며, &quot;* / *&quot;는 모든 미디어 유형을 나타내고 &quot;type / *&quot;해당 유형의 모든 하위 유형을 나타냅니다. 미디어 범위에는 해당 범위에 적용 가능한 미디어 유형 매개 변수가 포함될 수 있습니다. 각 용지 범위 뒤에는 0 또는 그 이상의 적용 가능한 용지 유형 매개 변수 (예 : 문자 세트)가있을 수 있습니다.&lt;a href=&quot;#section-5.3.1&quot;&gt;섹션 5.3.1&lt;/a&gt;)를 누른 다음 확장 매개 변수가 0 개 이상입니다. &quot;q&quot;매개 변수는 확장 (accept-ext)이있는 경우 필요합니다. 두 매개 변수 세트 사이의 분리기 역할을하기 때문입니다. 참고 : &quot;q&quot;매개 변수 이름을 사용하여 미디어 유형 매개 변수를 확장 확장 매개 변수 허용과 분리하는 것은 이전의 관행 때문입니다. 이렇게하면 &quot;q&quot;라는 매체 유형 매개 변수가 매체 범위와 함께 사용되지 않지만, 이러한 이벤트는 IANA 매체 유형 레지스트리에 &quot;q&quot;매개 변수가없고 매체 유형이 거의 사용되지 않는 것으로 간주됩니다. 수락의 매개 변수. 향후 미디어 유형은 &quot;q&quot;라는 매개 변수를 등록하지 않는 것이 좋습니다. 수락 예 : audio / *; q = 0.2, 오디오 / 기본은 &quot;오디오 / 기본을 선호하지만 80 % 품질 저하 후 최상의 오디오를 얻으려면 모든 오디오 유형을 보내십시오. &quot;헤더 헤더 필드가없는 요청은 사용자 에이전트가 미디어 유형을 응답으로 수락 함을 의미합니다. 필드가 요청에 있고 응답에 사용 가능한 표현 중 허용 가능한 것으로 표시된 미디어 유형이없는 경우, 원본 서버는 406 (Not Acceptable) 응답을 보내 헤더 필드를 처리하거나 처리하여 헤더 필드를 무시할 수 있습니다. 내용 협상에 영향을받지 않는 것처럼 응답 더 복잡한 예는 Accept : text / plain; q = 0.5, text / html, text / x-dvi; q = 0.8, text / xc 구두로 해석됩니다. &quot;text / html 및 text / xc도 마찬가지로 선호되는 미디어 유형이지만 존재하지 않는 경우그런 다음 text / x-dvi 표현을 보내십시오. 존재하지 않는 경우 text / plain 표현을 보내십시오. &quot;미디어 범위는보다 구체적인 미디어 범위 또는 특정 미디어 유형에 의해 재정의 될 수 있습니다. 예를 들어 수락 : text / *, text / plain, text / plain; format = flowed, * / *는 다음과 같은 우선 순위를 갖습니다. 1. text / plain; format = flowed 2. text / plain 3. text / * 4. * / * 주어진 유형과 관련된 매체 유형 품질 계수는 유형과 일치하는 우선 순위가 가장 높은 매체 범위를 찾아서 결정됩니다 (예 : Accept : text / *; q = 0.3). , text / html; q = 0.7, text / html; level = 1, text / html; level = 2; q = 0.4, * / *; q = 0.5로 인해 다음 값이 연결됩니다.+ ------------------- + --------------- + | 미디어 타입 | 품질 가치 | + ------------------- + --------------- + | text / html; level = 1 | 1 | | 텍스트 / html | 0.7 | | 텍스트 / 일반 | 0.3 | | 이미지 / jpeg | 0.5 | | text / html; level = 2 | 0.4 | | text / html; level = 3 | 0.7 | + ------------------- + --------------- + 참고 : 사용자 에이전트에는 기본 집합이 제공 될 수 있습니다. 특정 용지 범위의 품질 값. 그러나 사용자 에이전트가 다른 렌더링 에이전트와 상호 작용할 수없는 닫힌 시스템이 아닌 경우이 기본 세트는 사용자가 구성 할 수 있어야합니다.7 | | 텍스트 / 일반 | 0.3 | | 이미지 / jpeg | 0.5 | | text / html; level = 2 | 0.4 | | text / html; level = 3 | 0.7 | + ------------------- + --------------- + 참고 : 사용자 에이전트에는 기본 집합이 제공 될 수 있습니다. 특정 용지 범위의 품질 값. 그러나 사용자 에이전트가 다른 렌더링 에이전트와 상호 작용할 수없는 닫힌 시스템이 아닌 경우이 기본 세트는 사용자가 구성 할 수 있어야합니다.7 | | 텍스트 / 일반 | 0.3 | | 이미지 / jpeg | 0.5 | | text / html; level = 2 | 0.4 | | text / html; level = 3 | 0.7 | + ------------------- + --------------- + 참고 : 사용자 에이전트에는 기본 집합이 제공 될 수 있습니다. 특정 용지 범위의 품질 값. 그러나 사용자 에이전트가 다른 렌더링 에이전트와 상호 작용할 수없는 닫힌 시스템이 아닌 경우이 기본 세트는 사용자가 구성 할 수 있어야합니다.사용자 에이전트가 다른 렌더링 에이전트와 상호 작용할 수없는 닫힌 시스템이 아닌 경우이 기본 세트는 사용자가 구성 할 수 있어야합니다.사용자 에이전트가 다른 렌더링 에이전트와 상호 작용할 수없는 닫힌 시스템이 아닌 경우이 기본 세트는 사용자가 구성 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e190709d5dcd5319bdd81105d4e02470d1c77a57" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Charset&quot; header field can be sent by a user agent to
   indicate what charsets are acceptable in textual response content.
   This field allows user agents capable of understanding more
   comprehensive or special-purpose charsets to signal that capability
   to an origin server that is capable of representing information in
   those charsets.

     Accept-Charset = 1#( ( charset / &quot;*&quot; ) [ weight ] )

   Charset names are defined in &lt;a href=&quot;#section-3.1.1.2&quot;&gt;Section 3.1.1.2&lt;/a&gt;.  A user agent MAY
   associate a quality value with each charset to indicate the user's
   relative preference for that charset, as defined in &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;.
   An example is

     Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

   The special value &quot;*&quot;, if present in the Accept-Charset field,
   matches every charset that is not mentioned elsewhere in the
   Accept-Charset field.  If no &quot;*&quot; is present in an Accept-Charset
   field, then any charsets not explicitly mentioned in the field are
   considered &quot;not acceptable&quot; to the client.

   A request without any Accept-Charset header field implies that the
   user agent will accept any charset in response.  Most general-purpose
   user agents do not send Accept-Charset, unless specifically 

   configured to do so, because a detailed list of supported charsets
   makes it easier for a server to identify an individual by virtue of
   the user agent's request characteristics (&lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;).

   If an Accept-Charset header field is present in a request and none of
   the available representations for the response has a charset that is
   listed as acceptable, the origin server can either honor the header
   field, by sending a 406 (Not Acceptable) response, or disregard the
   header field by treating the resource as if it is not subject to
   content negotiation.</source>
          <target state="translated">&quot;Accept-Charset&quot;헤더 필드는 텍스트 응답 컨텐츠에서 허용되는 문자 세트를 표시하기 위해 사용자 에이전트에 의해 전송 될 수 있습니다. 이 필드를 사용하면보다 포괄적이거나 특수한 문자 집합을 이해할 수있는 사용자 에이전트가 해당 문자 집합의 정보를 나타낼 수있는 원본 서버에 해당 기능을 알릴 수 있습니다. Accept-Charset = 1 # ((charset / &quot;*&quot;) [weight]) 문자셋 이름은 &lt;a href=&quot;#section-3.1.1.2&quot;&gt;3.1.1.2 절에&lt;/a&gt; 정의되어 있습니다. 사용자 에이전트는 &lt;a href=&quot;#section-5.3.1&quot;&gt;5.3.1 절에&lt;/a&gt; 정의 된대로 품질 값을 각 문자 세트와 연관시켜 해당 문자 세트에 대한 사용자의 상대적 선호도를 표시 할 수 있습니다.. 예는 Accept-Charset입니다. iso-8859-5, unicode-1-1; q = 0.8 Accept-Charset 필드에있는 특수 값 &quot;*&quot;는 Accept-Charset의 다른 곳에 언급되지 않은 모든 문자 세트와 일치합니다. 문자셋 필드. Accept-Charset 필드에 &quot;*&quot;가 없으면 필드에 명시 적으로 언급되지 않은 모든 문자 집합은 클라이언트에 &quot;허용되지 않는&quot;것으로 간주됩니다. Accept-Charset 헤더 필드가없는 요청은 사용자 에이전트가 응답으로 모든 문자 세트를 승인 함을 의미합니다. 지원되는 문자 세트의 세부 목록이 사용자 에이전트의 요청 특성으로 인해 서버가 개인을 쉽게 식별 할 수 있기 때문에 특별히 구성된 경우가 아니면 대부분의 범용 사용자 에이전트는 Accept-Charset을 보내지 않습니다 ( &lt;a href=&quot;#section-9.7&quot;&gt;9.7 절).&lt;/a&gt;). Accept-Charset 헤더 필드가 요청에 있고 응답에 사용 가능한 표현 중 허용 가능한 것으로 표시된 문자 집합이없는 경우, 오리진 서버는 406 (Not Acceptable) 응답을 보내 헤더 필드를 존중할 수 있습니다. 또는 컨텐츠 협상이 적용되지 않는 것처럼 리소스를 처리하여 헤더 필드를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="94c1a4ee49201e6addf548dc16982d985feb45ac" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Encoding&quot; header field can be used by user agents to
   indicate what response content-codings (&lt;a href=&quot;#section-3.1.2.1&quot;&gt;Section 3.1.2.1&lt;/a&gt;) are
   acceptable in the response.  An &quot;identity&quot; token is used as a synonym
   for &quot;no encoding&quot; in order to communicate when no encoding is
   preferred.

     Accept-Encoding  = #( codings [ weight ] )
     codings          = content-coding / &quot;identity&quot; / &quot;*&quot;

   Each codings value MAY be given an associated quality value
   representing the preference for that encoding, as defined in
   &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;.  The asterisk &quot;*&quot; symbol in an Accept-Encoding field
   matches any available content-coding not explicitly listed in the
   header field.

   For example,

     Accept-Encoding: compress, gzip
     Accept-Encoding:
     Accept-Encoding: *
     Accept-Encoding: compress;q=0.5, gzip;q=1.0
     Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

   A request without an Accept-Encoding header field implies that the
   user agent has no preferences regarding content-codings.  Although
   this allows the server to use any content-coding in a response, it
   does not imply that the user agent will be able to correctly process
   all encodings.

   A server tests whether a content-coding for a given representation is
   acceptable using these rules:

   1.  If no Accept-Encoding field is in the request, any content-coding
       is considered acceptable by the user agent. 

   2.  If the representation has no content-coding, then it is
       acceptable by default unless specifically excluded by the
       Accept-Encoding field stating either &quot;identity;q=0&quot; or &quot;*;q=0&quot;
       without a more specific entry for &quot;identity&quot;.

   3.  If the representation's content-coding is one of the
       content-codings listed in the Accept-Encoding field, then it is
       acceptable unless it is accompanied by a qvalue of 0.  (As
       defined in &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;, a qvalue of 0 means &quot;not acceptable&quot;.)

   4.  If multiple content-codings are acceptable, then the acceptable
       content-coding with the highest non-zero qvalue is preferred.

   An Accept-Encoding header field with a combined field-value that is
   empty implies that the user agent does not want any content-coding in
   response.  If an Accept-Encoding header field is present in a request
   and none of the available representations for the response have a
   content-coding that is listed as acceptable, the origin server SHOULD
   send a response without any content-coding.

      Note: Most HTTP/1.0 applications do not recognize or obey qvalues
      associated with content-codings.  This means that qvalues might
      not work and are not permitted with x-gzip or x-compress.</source>
          <target state="translated">사용자 에이전트는 &quot;Accept-Encoding&quot;헤더 필드를 사용하여 응답 에 허용되는 응답 컨텐츠 코딩 ( &lt;a href=&quot;#section-3.1.2.1&quot;&gt;3.1.2.1&lt;/a&gt; ) 을 표시 할 수 있습니다 . &quot;식별&quot;토큰은 인코딩이 선호되지 않을 때 통신하기 위해 &quot;인코딩 없음&quot;의 동의어로 사용됩니다. Accept-Encoding = # (codings [weight]) codings = content-coding / &quot;identity&quot;/ &quot;*&quot; &lt;a href=&quot;#section-5.3.1&quot;&gt;5.3.1 절에&lt;/a&gt; 정의 된대로 각 코딩 값에는 해당 인코딩에 대한 선호도를 나타내는 관련 품질 값이 주어질 수있다. . Accept-Encoding 필드의 별표 &quot;*&quot;기호는 헤더 필드에 명시 적으로 나열되지 않은 사용 가능한 모든 컨텐츠 코딩과 일치합니다. 예를 들어, Accept-Encoding : compress, gzip Accept-Encoding : Accept-Encoding : * Accept-Encoding : compress; q = 0.5, gzip; q = 1.0 Accept-Encoding : gzip; q = 1.0, identity; q = 0.5, *; q = 0 Accept-Encoding 헤더 필드가없는 요청은 사용자 에이전트에 컨텐츠 코딩에 대한 기본 설정이 없음을 의미합니다. 이렇게하면 서버가 응답으로 컨텐츠 코딩을 사용할 수 있지만 사용자 에이전트가 모든 인코딩을 올바르게 처리 할 수 ​​있음을 의미하지는 않습니다. 서버는 다음 규칙을 사용하여 주어진 표현에 대한 컨텐츠 코딩이 허용되는지 여부를 테스트합니다. 1. 요청에 Accept-Encoding 필드가 없으면,모든 콘텐츠 코딩은 사용자 에이전트에 의해 허용되는 것으로 간주됩니다. 2. 표현에 컨텐츠 코딩이없는 경우, &quot;identity; q = 0&quot;또는 &quot;*; q = 0&quot;을 나타내는 Accept-Encoding 필드에 의해 특별히 제외되지 않은 경우 &quot; 정체&quot;. 3. 표현의 컨텐츠 코딩이 Accept-Encoding 필드에 나열된 컨텐츠 코딩 중 하나 인 경우 q 값이 0이 아닌 한 허용됩니다.&quot;신분&quot;에 대한 더 구체적인 항목이 없습니다. 3. 표현의 컨텐츠 코딩이 Accept-Encoding 필드에 나열된 컨텐츠 코딩 중 하나 인 경우 q 값이 0이 아닌 한 허용됩니다.&quot;신분&quot;에 대한 더 구체적인 항목이 없습니다. 3. 표현의 컨텐츠 코딩이 Accept-Encoding 필드에 나열된 컨텐츠 코딩 중 하나 인 경우 q 값이 0이 아닌 한 허용됩니다.&lt;a href=&quot;#section-5.3.1&quot;&gt;섹션 5.3.1&lt;/a&gt; 에서 qvalue 0은 &quot;허용되지 않음&quot;을 의미합니다. 4. 여러 개의 컨텐츠 코딩이 허용 가능한 경우, 0이 아닌 qvalue가 가장 높은 허용 가능한 컨텐츠 코딩이 선호됩니다. 필드 값이 결합 된 Accept-Encoding 헤더 필드는 사용자 에이전트가 콘텐츠 코딩을 원하지 않는 것을 의미합니다. Accept-Encoding 헤더 필드가 요청에 있고 응답에 사용 가능한 표현 중 수용 가능한 것으로 표시된 내용 코딩이없는 경우, 오리진 서버는 내용 코딩없이 응답을 보내야합니다. 참고 : 대부분의 HTTP / 1.0 응용 프로그램은 컨텐츠 코딩과 관련된 q 값을 인식하거나 따르지 않습니다. 이것은 qvalues가 작동하지 않을 수 있고 x-gzip 또는 x-compress에서 허용되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e583c40d3f3281ace1211bd3a8c4c5127953cb55" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Language&quot; header field can be used by user agents to
   indicate the set of natural languages that are preferred in the
   response.  Language tags are defined in &lt;a href=&quot;#section-3.1.3.1&quot;&gt;Section 3.1.3.1&lt;/a&gt;.

     Accept-Language = 1#( language-range [ weight ] )
     language-range  =
               &amp;lt;language-range, see &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.1&quot;&gt;[RFC4647], Section&amp;nbsp;2.1&lt;/a&gt;&amp;gt;

   Each language-range can be given an associated quality value
   representing an estimate of the user's preference for the languages
   specified by that range, as defined in &lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;.  For example,

     Accept-Language: da, en-gb;q=0.8, en;q=0.7

   would mean: &quot;I prefer Danish, but will accept British English and
   other types of English&quot;.

   A request without any Accept-Language header field implies that the
   user agent will accept any language in response.  If the header field
   is present in a request and none of the available representations for
   the response have a matching language tag, the origin server can
   either disregard the header field by treating the response as if it 

   is not subject to content negotiation or honor the header field by
   sending a 406 (Not Acceptable) response.  However, the latter is not
   encouraged, as doing so can prevent users from accessing content that
   they might be able to use (with translation software, for example).

   Note that some recipients treat the order in which language tags are
   listed as an indication of descending priority, particularly for tags
   that are assigned equal quality values (no value is the same as q=1).
   However, this behavior cannot be relied upon.  For consistency and to
   maximize interoperability, many user agents assign each language tag
   a unique quality value while also listing them in order of decreasing
   quality.  Additional discussion of language priority lists can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC4647]&lt;/a&gt;.

   For matching, &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC4647]&lt;/a&gt; defines several matching
   schemes.  Implementations can offer the most appropriate matching
   scheme for their requirements.  The &quot;Basic Filtering&quot; scheme
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3.3.1&quot;&gt;[RFC4647], Section&amp;nbsp;3.3.1&lt;/a&gt;) is identical to the matching scheme that
   was previously defined for HTTP in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.4&quot;&gt;Section&amp;nbsp;14.4 of [RFC2616]&lt;/a&gt;.

   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header field with the complete linguistic
   preferences of the user in every request (&lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;).

   Since intelligibility is highly dependent on the individual user,
   user agents need to allow user control over the linguistic preference
   (either through configuration of the user agent itself or by
   defaulting to a user controllable system setting).  A user agent that
   does not provide such control to the user MUST NOT send an
   Accept-Language header field.

      Note: User agents ought to provide guidance to users when setting
      a preference, since users are rarely familiar with the details of
      language matching as described above.  For example, users might
      assume that on selecting &quot;en-gb&quot;, they will be served any kind of
      English document if British English is not available.  A user
      agent might suggest, in such a case, to add &quot;en&quot; to the list for
      better matching behavior.</source>
          <target state="translated">&quot;Accept-Language&quot;헤더 필드는 사용자 에이전트가 응답에서 선호되는 자연어 세트를 표시하는 데 사용될 수 있습니다. 언어 태그는 &lt;a href=&quot;#section-3.1.3.1&quot;&gt;3.1.3.1 절&lt;/a&gt; 에서 정의됩니다 . Accept-Language = 1 # (language-range [weight]) language-range = &amp;lt;language-range, &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.1&quot;&gt;[RFC4647], 섹션 2.1 참조&lt;/a&gt; &amp;gt; 각 언어 범위에는 사용자 선호도 추정치를 나타내는 관련 품질 값이 주어질 수 있습니다. &lt;a href=&quot;#section-5.3.1&quot;&gt;5.3.1 절에&lt;/a&gt; 정의 된대로 해당 범위에 의해 지정된 언어. 예를 들어 Accept-Language : da, en-gb; q = 0.8, en; q = 0.7은 &quot;나는 덴마크어를 선호하지만 영국 영어와 다른 유형의 영어는 허용합니다&quot;를 의미합니다. Accept-Language 헤더 필드가없는 요청은 사용자 에이전트가 응답으로 모든 언어를 수락 함을 의미합니다. 요청에 헤더 필드가 있고 응답에 사용 가능한 표현에 일치하는 언어 태그가없는 경우 오리진 서버는 응답을 컨텐츠 협상 대상이 아닌 것처럼 처리하여 헤더 필드를 무시하거나 헤더를 존중할 수 있습니다 406 (Not Acceptable) 응답을 보내서 그러나 후자는 권장하지 않습니다. 이렇게하면 사용자가 사용할 수있는 컨텐츠 (예 : 번역 소프트웨어)에 액세스하지 못할 수 있습니다.일부 수신자는 특히 품질 값이 동일한 태그 (값이 q = 1과 같지 않음)에 대해 언어 태그가 나열되는 순서를 내림차순으로 표시합니다. 그러나이 동작은 신뢰할 수 없습니다. 일관성을 유지하고 상호 운용성을 최대화하기 위해 많은 사용자 에이전트가 각 언어 태그에 고유 한 품질 값을 할당하고 품질을 낮추는 순서대로 나열합니다. 언어 우선 순위 목록에 대한 추가 토론은많은 사용자 에이전트가 각 언어 태그에 고유 한 품질 값을 할당하고 품질을 낮추는 순서대로 나열합니다. 언어 우선 순위 목록에 대한 추가 토론은많은 사용자 에이전트가 각 언어 태그에 고유 한 품질 값을 할당하고 품질을 낮추는 순서대로 나열합니다. 언어 우선 순위 목록에 대한 추가 토론은&lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-2.3&quot;&gt;[RFC4647]의 2.3 절&lt;/a&gt; . 일치를 위해 &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3&quot;&gt;[RFC4647]의 3 절&lt;/a&gt; 은 몇 가지 일치 체계를 정의합니다. 구현은 요구 사항에 가장 적합한 일치 체계를 제공 할 수 있습니다. &quot;기본 필터링&quot;체계 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc4647#section-3.3.1&quot;&gt;[RFC4647], 3.3.1 절&lt;/a&gt; )는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.4&quot;&gt;[RFC2616]의 14.4 절&lt;/a&gt; 에서 HTTP에 대해 이전에 정의 된 일치 체계와 동일합니다 . 모든 요청에서 사용자의 완전한 언어 적 선호와 함께 Accept-Language 헤더 필드를 전송하는 것은 사용자의 개인 정보 보호 기대와 상충 될 수 있습니다 ( &lt;a href=&quot;#section-9.7&quot;&gt;섹션 9.7).&lt;/a&gt;). 명료도는 개별 사용자에 따라 크게 달라 지므로 사용자 에이전트는 사용자 에이전트 자체의 구성을 통해 또는 기본적으로 사용자 제어 가능한 시스템 설정으로 언어 선호도에 대한 사용자 제어를 허용해야합니다. 사용자에게 그러한 제어를 제공하지 않는 사용자 에이전트는 Accept-Language 헤더 필드를 보내서는 안됩니다. 참고 : 사용자 에이전트는 환경 설정시 사용자에게 지침을 제공해야합니다. 사용자는 위에서 설명한대로 언어 일치에 대한 세부 사항에 거의 익숙하지 않기 때문입니다. 예를 들어, 사용자는 &quot;en-gb&quot;를 선택할 때 영국 영어를 사용할 수없는 경우 모든 종류의 영어 문서가 제공된다고 가정 할 수 있습니다. 이 경우 사용자 에이전트는 더 나은 일치 동작을 위해 목록에 &quot;en&quot;을 추가 할 것을 제안 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="660e50878abbf252e2213e4a43a8c15147d72e0c" translate="yes" xml:space="preserve">
          <source>The &quot;Accept-Ranges&quot; header field allows a server to indicate that it
   supports range requests for the target resource.

     Accept-Ranges     = acceptable-ranges
     acceptable-ranges = 1#range-unit / &quot;none&quot;

   An origin server that supports byte-range requests for a given target
   resource MAY send

     Accept-Ranges: bytes

   to indicate what range units are supported.  A client MAY generate
   range requests without having received this header field for the
   resource involved.  Range units are defined in &lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;.

   A server that does not support any kind of range request for the
   target resource MAY send

     Accept-Ranges: none

   to advise the client not to attempt a range request.</source>
          <target state="translated">&quot;Accept-Ranges&quot;헤더 필드를 통해 서버는 대상 자원에 대한 범위 요청을 지원함을 표시 할 수 있습니다. 수락 범위 = 수용 가능 범위 수용 가능 범위 = 1 # range-unit / &quot;없음&quot;특정 대상 자원에 대한 바이트 범위 요청을 지원하는 오리진 서버는 지원되는 범위 단위를 나타내는 Accept-Ranges : 바이트를 보낼 수 있습니다. 클라이언트는 관련된 자원에 대한이 헤더 필드를받지 않고 범위 요청을 생성 할 수있다. 범위 단위는 &lt;a href=&quot;#section-2&quot;&gt;섹션 2에&lt;/a&gt; 정의되어 있습니다. 대상 리소스에 대해 어떤 종류의 범위 요청도 지원하지 않는 서버는 Accept-Ranges : none을 전송하여 클라이언트에게 범위 요청을 시도하지 않도록 조언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07e147c0306bf45017b2c661d092871c17cc475c" translate="yes" xml:space="preserve">
          <source>The &quot;Age&quot; header field conveys the sender's estimate of the amount of
   time since the response was generated or successfully validated at
   the origin server.  Age values are calculated as specified in
   &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;.

     Age = delta-seconds

   The Age field-value is a non-negative integer, representing time in
   seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;).

   The presence of an Age header field implies that the response was not
   generated or validated by the origin server for this request.
   However, lack of an Age header field does not imply the origin was
   contacted, since the response might have been received from an
   HTTP/1.0 cache that does not implement Age.</source>
          <target state="translated">&quot;나이&quot;헤더 필드는 발신자 서버에서 응답이 생성되거나 성공적으로 검증 된 이후 발신자의 예상 시간을 전달합니다. 연령 값은 &lt;a href=&quot;#section-4.2.3&quot;&gt;섹션 4.2.3에&lt;/a&gt; 지정된대로 계산됩니다 . Age = delta-seconds Age 필드 값은 시간을 초 단위로 나타내는 음이 아닌 정수입니다 ( &lt;a href=&quot;#section-1.2.1&quot;&gt;섹션 1.2.1&lt;/a&gt; 참조 ). Age 헤더 필드가 존재한다는 것은이 요청에 대한 오리진 서버가 응답을 생성 또는 검증하지 않았 음을 의미합니다. 그러나 Age 헤더 필드가 없다고해서 Age를 구현하지 않는 HTTP / 1.0 캐시에서 응답이 수신되었을 수 있기 때문에 오리진에 접속 한 것을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="1338498c252679bf6adfadb0f7074e7b148e3793" translate="yes" xml:space="preserve">
          <source>The &quot;Allow&quot; header field lists the set of methods advertised as
   supported by the target resource.  The purpose of this field is
   strictly to inform the recipient of valid request methods associated
   with the resource.

     Allow = #method

   Example of use:

     Allow: GET, HEAD, PUT

   The actual set of allowed methods is defined by the origin server at
   the time of each request.  An origin server MUST generate an Allow
   field in a 405 (Method Not Allowed) response and MAY do so in any
   other response.  An empty Allow field value indicates that the
   resource allows no methods, which might occur in a 405 response if
   the resource has been temporarily disabled by configuration.

   A proxy MUST NOT modify the Allow header field -- it does not need to
   understand all of the indicated methods in order to handle them
   according to the generic message handling rules.</source>
          <target state="translated">&quot;허용&quot;헤더 필드는 대상 자원이 지원하는 것으로 보급 된 메소드 세트를 나열합니다. 이 필드의 목적은 수신자에게 리소스와 관련된 유효한 요청 방법을 알려주는 것입니다. Allow = #method 사용 예 : Allow : GET, HEAD, PUT 실제 허용되는 메소드 세트는 각 요청시 오리진 서버에 의해 정의됩니다. 오리진 서버는 반드시 405 (Method Not Allowed) 응답에서 Allow 필드를 생성해야하며 다른 응답에서는 그렇게 할 수 있습니다. 비어있는 허용 필드 값은 리소스가 구성에 의해 일시적으로 비활성화 된 경우 405 응답에서 발생할 수있는 메서드를 허용하지 않음을 나타냅니다.프록시는 헤더 허용 필드를 수정해서는 안됩니다. 일반 메시지 처리 규칙에 따라 처리하기 위해 표시된 모든 방법을 이해할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="833bc28aae892154d2187dc74fadd75ecc7a7e54" translate="yes" xml:space="preserve">
          <source>The &quot;Authorization&quot; header field allows a user agent to authenticate
   itself with an origin server -- usually, but not necessarily, after
   receiving a 401 (Unauthorized) response.  Its value consists of
   credentials containing the authentication information of the user
   agent for the realm of the resource being requested.

     Authorization = credentials

   If a request is authenticated and a realm specified, the same
   credentials are presumed to be valid for all other requests within
   this realm (assuming that the authentication scheme itself does not
   require otherwise, such as credentials that vary according to a
   challenge value or using synchronized clocks).

   A proxy forwarding a request MUST NOT modify any Authorization fields
   in that request.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7234]&lt;/a&gt; for details of and
   requirements pertaining to handling of the Authorization field by
   HTTP caches.</source>
          <target state="translated">&quot;Authorization&quot;헤더 필드를 통해 사용자 에이전트는 일반적으로 401 (Unauthorized) 응답을받은 후 오리진 서버로 자체 인증 할 수 있습니다. 그 값은 요청되는 자원 영역에 대한 사용자 에이전트의 인증 정보를 포함하는 신임 정보로 구성됩니다. 권한 부여 = 신임 정보 요청이 인증되고 영역이 지정된 경우, 인증 영역 자체가 달리 요구하지 않는 경우 (예 : 챌린지 값에 따라 다른 신임 정보) 가정하면 동일한 영역의 자격 증명이이 영역 내의 다른 모든 요청에 ​​유효한 것으로 간주됩니다. 또는 동기화 된 시계 사용). 요청을 전달하는 프록시는 해당 요청의 인증 필드를 수정해서는 안됩니다 (MUST NOT). &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-3.2&quot;&gt;[RFC7234] 3.2 절&lt;/a&gt; 참조 HTTP 캐시에 의한 권한 부여 필드 처리와 관련된 세부 사항 및 요구 사항</target>
        </trans-unit>
        <trans-unit id="7168d04cbf63301e6705540ed2ab42ae32147600" translate="yes" xml:space="preserve">
          <source>The &quot;Basic&quot; HTTP authentication scheme is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7617&quot;&gt;RFC 7617&lt;/a&gt;, which transmits credentials as user ID/password pairs, encoded using base64.</source>
          <target state="translated">&quot;기본&quot;HTTP 인증 체계는 &lt;a href=&quot;https://tools.ietf.org/html/rfc7617&quot;&gt;RFC 7617에&lt;/a&gt; 정의되어 있으며 , 자격 증명을 base64를 사용하여 인코딩 된 사용자 ID / 암호 쌍으로 전송합니다.</target>
        </trans-unit>
        <trans-unit id="e6a4b6da05626e019facf6e5f03b1b90399b48bf" translate="yes" xml:space="preserve">
          <source>The &quot;Cache-Control&quot; header field is used to specify directives for
   caches along the request/response chain.  Such cache directives are
   unidirectional in that the presence of a directive in a request does
   not imply that the same directive is to be given in the response.

   A cache MUST obey the requirements of the Cache-Control directives
   defined in this section.  See &lt;a href=&quot;#section-5.2.3&quot;&gt;Section 5.2.3&lt;/a&gt; for information about how
   Cache-Control directives defined elsewhere are handled.

      Note: Some HTTP/1.0 caches might not implement Cache-Control.

   A proxy, whether or not it implements a cache, MUST pass cache
   directives through in forwarded messages, regardless of their
   significance to that application, since the directives might be
   applicable to all recipients along the request/response chain.  It is
   not possible to target a directive to a specific cache.

   Cache directives are identified by a token, to be compared
   case-insensitively, and have an optional argument, that can use both
   token and quoted-string syntax.  For the directives defined below
   that define arguments, recipients ought to accept both forms, even if
   one is documented to be preferred.  For any directive not defined by
   this specification, a recipient MUST accept both forms. 

     Cache-Control   = 1#cache-directive

     cache-directive = token [ &quot;=&quot; ( token / quoted-string ) ]

   For the cache directives defined below, no argument is defined (nor
   allowed) unless stated otherwise.</source>
          <target state="translated">&quot;Cache-Control&quot;헤더 필드는 요청 / 응답 체인을 따라 캐시에 대한 지시문을 지정하는 데 사용됩니다. 이러한 캐시 지시문은 요청에 지시문이 있다고해서 동일한 지시문이 응답에 제공되는 것을 의미하지 않는다는 점에서 단방향입니다. 캐시는이 섹션에 정의 된 Cache-Control 지시문의 요구 사항을 준수해야합니다. &lt;a href=&quot;#section-5.2.3&quot;&gt;섹션 5.2.3&lt;/a&gt; 참조 for information about how Cache-Control directives defined elsewhere are handled. Note: Some HTTP/1.0 caches might not implement Cache-Control. A proxy, whether or not it implements a cache, MUST pass cache directives through in forwarded messages, regardless of their significance to that application, since the directives might be applicable to all recipients along the request/response chain. It is not possible to target a directive to a specific cache. Cache directives are identified by a token, to be compared case-insensitively, and have an optional argument, that can use both token and quoted-string syntax. For the directives defined below that define arguments, recipients ought to accept both forms, even if one is documented to be preferred. For any directive not defined by this specification, a recipient MUST accept both forms. Cache-Control = 1#cache-directive cache-directive = token [ &quot;=&quot; ( token / quoted-string ) ] For the cache directives defined below, no argument is defined (nor allowed) unless stated otherwise.</target>
        </trans-unit>
        <trans-unit id="ead8e33ac22c36beaaccc520e5c8f0383500fa6b" translate="yes" xml:space="preserve">
          <source>The &quot;Connection&quot; header field allows the sender to indicate desired
   control options for the current connection.  In order to avoid
   confusing downstream recipients, a proxy or gateway MUST remove or
   replace any received connection options before forwarding the
   message.

   When a header field aside from Connection is used to supply control
   information for or about the current connection, the sender MUST list
   the corresponding field-name within the Connection header field.  A
   proxy or gateway MUST parse a received Connection header field before
   a message is forwarded and, for each connection-option in this field,
   remove any header field(s) from the message with the same name as the
   connection-option, and then remove the Connection header field itself
   (or replace it with the intermediary's own connection options for the
   forwarded message).

   Hence, the Connection header field provides a declarative way of
   distinguishing header fields that are only intended for the immediate
   recipient (&quot;hop-by-hop&quot;) from those fields that are intended for all
   recipients on the chain (&quot;end-to-end&quot;), enabling the message to be
   self-descriptive and allowing future connection-specific extensions
   to be deployed without fear that they will be blindly forwarded by
   older intermediaries.

   The Connection header field's value has the following grammar:

     Connection        = 1#connection-option
     connection-option = token

   Connection options are case-insensitive.

   A sender MUST NOT send a connection option corresponding to a header
   field that is intended for all recipients of the payload.  For
   example, Cache-Control is never appropriate as a connection option
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;). 

   The connection options do not always correspond to a header field
   present in the message, since a connection-specific header field
   might not be needed if there are no parameters associated with a
   connection option.  In contrast, a connection-specific header field
   that is received without a corresponding connection option usually
   indicates that the field has been improperly forwarded by an
   intermediary and ought to be ignored by the recipient.

   When defining new connection options, specification authors ought to
   survey existing header field names and ensure that the new connection
   option does not share the same name as an already deployed header
   field.  Defining a new connection option essentially reserves that
   potential field-name for carrying additional information related to
   the connection option, since it would be unwise for senders to use
   that field-name for anything else.

   The &quot;close&quot; connection option is defined for a sender to signal that
   this connection will be closed after completion of the response.  For
   example,

     Connection: close

   in either the request or the response header fields indicates that
   the sender is going to close the connection after the current
   request/response is complete (&lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt;).

   A client that does not support persistent connections MUST send the
   &quot;close&quot; connection option in every request message.

   A server that does not support persistent connections MUST send the
   &quot;close&quot; connection option in every response message that does not
   have a 1xx (Informational) status code.</source>
          <target state="translated">&quot;연결&quot;헤더 필드를 사용하면 발신자가 현재 연결에 원하는 제어 옵션을 표시 할 수 있습니다. 다운 스트림 수신자를 혼동하지 않으려면 프록시 또는 게이트웨이는 메시지를 전달하기 전에 수신 된 연결 옵션을 제거하거나 바꿔야합니다. Connection을 제외한 헤더 필드를 사용하여 현재 연결에 대한 제어 정보를 제공하는 경우 보낸 사람은 Connection 헤더 필드에 해당 필드 이름을 나열해야합니다. 프록시 또는 게이트웨이는 메시지가 전달되기 전에 수신 된 연결 헤더 필드를 구문 분석해야하며이 필드의 각 연결 옵션에 대해 연결 옵션과 동일한 이름을 가진 메시지에서 헤더 필드를 제거한 다음 제거하십시오. 연결 헤더 필드 자체 (또는 중개자로 대체)전달 된 메시지에 대한 자체 연결 옵션). 따라서 연결 헤더 필드는 체인의 모든 수신자를위한 필드 ( &quot;end-to-end&quot;)와 직접적인 수신자 ( &quot;hop-by-hop&quot;)만을 대상으로하는 헤더 필드를 구별하는 선언적인 방법을 제공합니다. &quot;)를 사용하여 메시지를 자기 설명 할 수있게하고 향후 연결 별 확장을 이전 중개자가 맹목적으로 전달할 것이라는 두려움없이 배포 할 수 있습니다. Connection 헤더 필드의 값은 다음과 같은 문법을 갖습니다. Connection = 1 # connection-option connection-option = token 연결 옵션은 대소 문자를 구분하지 않습니다. 발신자는 페이로드의 모든 수신자를 대상으로하는 헤더 필드에 해당하는 연결 옵션을 보내서는 안됩니다.예를 들어, Cache-Control은 연결 옵션 (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234] 섹션 5.2&lt;/a&gt;). 연결 옵션과 연관된 매개 변수가없는 경우 연결 별 헤더 필드가 필요하지 않을 수 있으므로 연결 옵션이 메시지에 존재하는 헤더 필드와 항상 일치하는 것은 아닙니다. 대조적으로, 해당 연결 옵션없이 수신 된 연결 특정 헤더 필드는 일반적으로 필드가 중개자에 의해 부적절하게 전달되었고 수신자에 의해 무시되어야 함을 나타냅니다. 새 연결 옵션을 정의 할 때 사양 작성자는 기존 헤더 필드 이름을 조사하고 새 연결 옵션이 이미 배포 된 헤더 필드와 동일한 이름을 공유하지 않아야합니다. 새 연결 옵션을 정의하면 기본적으로 연결 옵션과 관련된 추가 정보를 전달할 수있는 해당 필드 이름이 예약됩니다.발신자가 필드 이름을 다른 용도로 사용하는 것은 현명하지 않기 때문입니다. &quot;닫기&quot;연결 옵션은 발신자가 응답이 완료된 후이 연결이 닫히 겠다는 신호를 보내기 위해 정의됩니다. 예를 들어, 요청 또는 응답 헤더 필드에서 Connection : close는 현재 요청 / 응답이 완료된 후 발신자가 연결을 닫을 것임을 나타냅니다 (요청 또는 응답 헤더 필드에서 닫기는 현재 요청 / 응답이 완료된 후 발신자가 연결을 닫을 것임을 나타냅니다 (요청 또는 응답 헤더 필드에서 닫기는 현재 요청 / 응답이 완료된 후 발신자가 연결을 닫을 것임을 나타냅니다 (&lt;a href=&quot;#section-6.6&quot;&gt;섹션 6.6&lt;/a&gt; ). 영구 연결을 지원하지 않는 클라이언트는 모든 요청 메시지에 &quot;닫기&quot;연결 옵션을 보내야합니다. 영구 연결을 지원하지 않는 서버는 1xx (정보) 상태 코드가없는 모든 응답 메시지에 &quot;닫기&quot;연결 옵션을 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="f005d7daab665deae0b91cf8d9396978496c7fec" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Encoding&quot; header field indicates what content codings
   have been applied to the representation, beyond those inherent in the
   media type, and thus what decoding mechanisms have to be applied in
   order to obtain data in the media type referenced by the Content-Type
   header field.  Content-Encoding is primarily used to allow a
   representation's data to be compressed without losing the identity of
   its underlying media type.

     Content-Encoding = 1#content-coding

   An example of its use is

     Content-Encoding: gzip

   If one or more encodings have been applied to a representation, the
   sender that applied the encodings MUST generate a Content-Encoding
   header field that lists the content codings in the order in which
   they were applied.  Additional information about the encoding
   parameters can be provided by other header fields not defined by this
   specification.

   Unlike Transfer-Encoding (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.1&quot;&gt;Section&amp;nbsp;3.3.1 of [RFC7230]&lt;/a&gt;), the codings
   listed in Content-Encoding are a characteristic of the
   representation; the representation is defined in terms of the coded
   form, and all other metadata about the representation is about the
   coded form unless otherwise noted in the metadata definition.
   Typically, the representation is only decoded just prior to rendering
   or analogous usage.

   If the media type includes an inherent encoding, such as a data
   format that is always compressed, then that encoding would not be
   restated in Content-Encoding even if it happens to be the same
   algorithm as one of the content codings.  Such a content coding would
   only be listed if, for some bizarre reason, it is applied a second
   time to form the representation.  Likewise, an origin server might
   choose to publish the same data as multiple representations that
   differ only in whether the coding is defined as part of Content-Type 

   or Content-Encoding, since some user agents will behave differently
   in their handling of each response (e.g., open a &quot;Save as ...&quot; dialog
   instead of automatic decompression and rendering of content).

   An origin server MAY respond with a status code of 415 (Unsupported
   Media Type) if a representation in the request message has a content
   coding that is not acceptable.</source>
          <target state="translated">&quot;콘텐츠 인코딩&quot;헤더 필드는 미디어 유형 고유의 것 이외의 표현에 적용된 콘텐츠 코딩을 나타내며, 따라서 콘텐츠가 참조하는 미디어 유형의 데이터를 얻기 위해 어떤 디코딩 메커니즘을 적용해야하는지 나타냅니다. 헤더 필드를 입력하십시오. 컨텐츠 인코딩은 주로 기본 미디어 유형의 ID를 유지하면서 표현의 데이터를 압축 할 수 있도록하는 데 사용됩니다. Content-Encoding = 1 # content-coding 사용 예는 Content-Encoding입니다. gzip 하나 이상의 인코딩이 표현에 적용된 경우 인코딩을 적용한 발신인은 반드시 내용을 나열하는 Content-Encoding 헤더 필드를 생성해야합니다. 적용된 순서대로 코딩합니다.인코딩 매개 변수에 대한 추가 정보는이 사양에서 정의하지 않은 다른 헤더 필드에서 제공 할 수 있습니다. 전송 인코딩과 달리&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.1&quot;&gt;[RFC7230]의 섹션 3.3.1&lt;/a&gt;), Content-Encoding에 나열된 코딩은 표현의 특성이다. 표현은 코딩 된 형태로 정의되고, 표현에 관한 다른 모든 메타 데이터는 메타 데이터 정의에서 달리 언급되지 않는 한 코딩 된 형태에 관한 것이다. 일반적으로 표현은 렌더링 또는 유사한 사용 직전에 디코딩됩니다. 미디어 유형에 항상 압축되는 데이터 형식과 같은 고유 인코딩이 포함 된 경우 해당 인코딩은 콘텐츠 코딩 중 하나와 동일한 알고리즘이더라도 콘텐츠 인코딩에서 복원되지 않습니다. 이러한 콘텐츠 코딩은 기괴한 이유로 표현을 형성하기 위해 두 번째로 적용되는 경우에만 나열됩니다. 마찬가지로,오리진 서버는 코딩이 Content-Type 또는 Content-Encoding의 일부로 정의되는지 여부 만 다른 여러 표현과 동일한 데이터를 게시하도록 선택할 수 있습니다. 자동 압축 풀기 및 컨텐츠 렌더링 대신 &quot;다른 이름으로 저장 ...&quot;대화 상자). 요청 메시지의 표현에 허용되지 않는 컨텐츠 코딩이있는 경우, 오리진 서버는 상태 코드 415 (지원되지 않는 미디어 유형)로 응답 할 수 있습니다.요청 메시지의 표현에 허용되지 않는 컨텐츠 코딩이있는 경우, 오리진 서버는 상태 코드 415 (지원되지 않는 미디어 유형)로 응답 할 수 있습니다.요청 메시지의 표현에 허용되지 않는 컨텐츠 코딩이있는 경우, 오리진 서버는 상태 코드 415 (지원되지 않는 미디어 유형)로 응답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="164d16f9f8916d272734f22f4029358169a82681" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Language&quot; header field describes the natural language(s)
   of the intended audience for the representation.  Note that this
   might not be equivalent to all the languages used within the
   representation.

     Content-Language = 1#language-tag 

   Language tags are defined in &lt;a href=&quot;#section-3.1.3.1&quot;&gt;Section 3.1.3.1&lt;/a&gt;.  The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   representations according to the users' own preferred language.
   Thus, if the content is intended only for a Danish-literate audience,
   the appropriate field is

     Content-Language: da

   If no Content-Language is specified, the default is that the content
   is intended for all language audiences.  This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.

   Multiple languages MAY be listed for content that is intended for
   multiple audiences.  For example, a rendition of the &quot;Treaty of
   Waitangi&quot;, presented simultaneously in the original Maori and English
   versions, would call for

     Content-Language: mi, en

   However, just because multiple languages are present within a
   representation does not mean that it is intended for multiple
   linguistic audiences.  An example would be a beginner's language
   primer, such as &quot;A First Lesson in Latin&quot;, which is clearly intended
   to be used by an English-literate audience.  In this case, the
   Content-Language would properly only include &quot;en&quot;.

   Content-Language MAY be applied to any media type -- it is not
   limited to textual documents.</source>
          <target state="translated">&quot;Content-Language&quot;헤더 필드는 표현 대상 독자의 자연어를 설명합니다. 이는 표현에 사용 된 모든 언어와 같지 않을 수도 있습니다. Content-Language = 1 # language-tag 언어 태그는 &lt;a href=&quot;#section-3.1.3.1&quot;&gt;3.1.3.1 절에&lt;/a&gt; 정의되어 있습니다.. Content-Language의 기본 목적은 사용자가 선호하는 언어에 따라 표현을 식별하고 구별 할 수 있도록하는 것입니다. 따라서 컨텐츠가 덴마크어 언어 사용자 만 대상으로하는 경우 해당 필드는 컨텐츠 언어입니다. da 컨텐츠 언어가 지정되지 않은 경우 기본적으로 컨텐츠는 모든 언어 사용자를 대상으로합니다. 이는 발신자가 자연 언어에 고유 한 것으로 간주하지 않거나 발신자가 어떤 언어를 사용하는지 알지 못했음을 의미 할 수 있습니다. 여러 사용자를 대상으로하는 콘텐츠에 대해 여러 언어가 나열 될 수 있습니다. 예를 들어, 원래 마오리어와 영어 버전에서 동시에 제시된 &quot;와이 탕이의 보물&quot;을 번역하려면 Content-Language : mi,jw.org ko 그러나 표현 내에 여러 언어가 존재한다고해서 여러 언어 사용자를 대상으로한다는 의미는 아닙니다. 예를 들어 &quot;Latin의 첫 번째 수업&quot;과 같은 초보자의 언어 입문서가 영어를 사용하는 청중이 사용하도록 분명하게 고안되었습니다. 이 경우 Content-Language에는 &quot;en&quot;만 올바르게 포함됩니다. 콘텐츠 언어는 모든 미디어 유형에 적용될 수 있습니다 (텍스트 문서에만 국한되지 않음).이 경우 Content-Language에는 &quot;en&quot;만 올바르게 포함됩니다. 콘텐츠 언어는 모든 미디어 유형에 적용될 수 있습니다 (텍스트 문서에만 국한되지 않음).이 경우 Content-Language에는 &quot;en&quot;만 올바르게 포함됩니다. 콘텐츠 언어는 모든 미디어 유형에 적용될 수 있습니다 (텍스트 문서에만 국한되지 않음).</target>
        </trans-unit>
        <trans-unit id="befc0a5526257450f3dfb30b2d0dfe3ea24c1e2b" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Location&quot; header field references a URI that can be used
   as an identifier for a specific resource corresponding to the
   representation in this message's payload.  In other words, if one
   were to perform a GET request on this URI at the time of this
   message's generation, then a 200 (OK) response would contain the same
   representation that is enclosed as payload in this message.

     Content-Location = absolute-URI / partial-URI

   The Content-Location value is not a replacement for the effective
   Request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7230]&lt;/a&gt;).  It is representation
   metadata.  It has the same syntax and semantics as the header field
   of the same name defined for MIME body parts in &lt;a href=&quot;https://tools.ietf.org/html/rfc2557#section-4&quot;&gt;Section&amp;nbsp;4 of
   [RFC2557]&lt;/a&gt;.  However, its appearance in an HTTP message has some
   special implications for HTTP recipients. 

   If Content-Location is included in a 2xx (Successful) response
   message and its value refers (after conversion to absolute form) to a
   URI that is the same as the effective request URI, then the recipient
   MAY consider the payload to be a current representation of that
   resource at the time indicated by the message origination date.  For
   a GET (&lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt;) or HEAD (&lt;a href=&quot;#section-4.3.2&quot;&gt;Section 4.3.2&lt;/a&gt;) request, this is the
   same as the default semantics when no Content-Location is provided by
   the server.  For a state-changing request like PUT (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;) or
   POST (&lt;a href=&quot;#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt;), it implies that the server's response contains
   the new representation of that resource, thereby distinguishing it
   from representations that might only report about the action (e.g.,
   &quot;It worked!&quot;).  This allows authoring applications to update their
   local copies without the need for a subsequent GET request.

   If Content-Location is included in a 2xx (Successful) response
   message and its field-value refers to a URI that differs from the
   effective request URI, then the origin server claims that the URI is
   an identifier for a different resource corresponding to the enclosed
   representation.  Such a claim can only be trusted if both identifiers
   share the same resource owner, which cannot be programmatically
   determined via HTTP.

   o  For a response to a GET or HEAD request, this is an indication
      that the effective request URI refers to a resource that is
      subject to content negotiation and the Content-Location
      field-value is a more specific identifier for the selected
      representation.

   o  For a 201 (Created) response to a state-changing method, a
      Content-Location field-value that is identical to the Location
      field-value indicates that this payload is a current
      representation of the newly created resource.

   o  Otherwise, such a Content-Location indicates that this payload is
      a representation reporting on the requested action's status and
      that the same report is available (for future access with GET) at
      the given URI.  For example, a purchase transaction made via a
      POST request might include a receipt document as the payload of
      the 200 (OK) response; the Content-Location field-value provides
      an identifier for retrieving a copy of that same receipt in the
      future.

   A user agent that sends Content-Location in a request message is
   stating that its value refers to where the user agent originally
   obtained the content of the enclosed representation (prior to any
   modifications made by that user agent).  In other words, the user
   agent is providing a back link to the source of the original
   representation. 

   An origin server that receives a Content-Location field in a request
   message MUST treat the information as transitory request context
   rather than as metadata to be saved verbatim as part of the
   representation.  An origin server MAY use that context to guide in
   processing the request or to save it for other uses, such as within
   source links or versioning metadata.  However, an origin server MUST
   NOT use such context information to alter the request semantics.

   For example, if a client makes a PUT request on a negotiated resource
   and the origin server accepts that PUT (without redirection), then
   the new state of that resource is expected to be consistent with the
   one representation supplied in that PUT; the Content-Location cannot
   be used as a form of reverse content selection identifier to update
   only one of the negotiated representations.  If the user agent had
   wanted the latter semantics, it would have applied the PUT directly
   to the Content-Location URI.</source>
          <target state="translated">&quot;Content-Location&quot;헤더 필드는이 메시지의 페이로드의 표현에 해당하는 특정 자원의 식별자로 사용할 수있는 URI를 참조합니다. 즉,이 메시지 생성시이 URI에서 GET 요청을 수행하려는 경우 200 (OK) 응답에는이 메시지에서 페이로드로 묶인 동일한 표시가 포함됩니다. Content-Location = absolute-URI / partial-URI Content-Location 값은 유효 요청 URI를 대체하지 않습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]의 섹션 5.5&lt;/a&gt; ). 표현 메타 데이터입니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc2557#section-4&quot;&gt;[RFC2557] 섹션 4&lt;/a&gt; 에서 MIME 본문 부분에 대해 정의 된 동일한 이름의 헤더 필드와 동일한 구문 및 의미가 있습니다 .. 그러나 HTTP 메시지에 나타나는 것은 HTTP 수신자에게 특별한 영향을 미칩니다. Content-Location이 2xx (성공) 응답 메시지에 포함되어 있고 그 값이 (절대 형식으로 변환 한 후) 유효 요청 URI와 동일한 URI를 참조하는 경우 수신자는 페이로드를 현재 표현으로 간주 할 수 있습니다 (MAY) 메시지 시작 날짜로 표시된 시간에 해당 자원의 GET ( &lt;a href=&quot;#section-4.3.1&quot;&gt;섹션 4.3.1&lt;/a&gt; ) 또는 HEAD ( &lt;a href=&quot;#section-4.3.2&quot;&gt;섹션 4.3.2&lt;/a&gt; ) 요청의 경우 서버에서 Content-Location을 제공하지 않은 경우 기본 시맨틱과 동일합니다. PUT ( &lt;a href=&quot;#section-4.3.4&quot;&gt;섹션 4.3.4&lt;/a&gt; ) 또는 POST ( &lt;a href=&quot;#section-4.3.3&quot;&gt;섹션 4.3.3&lt;/a&gt; ) 와 같은 상태 변경 요청), 서버의 응답에 해당 리소스의 새로운 표현이 포함되어있어 해당 작업에 대해서만보고 할 수있는 표현 (예 : &quot;작동했습니다!&quot;)과 구분됩니다. 이를 통해 제작 응용 프로그램은 후속 GET 요청없이 로컬 복사본을 업데이트 할 수 있습니다. Content-Location이 2xx (성공) 응답 메시지에 포함되고 해당 필드 값이 유효 요청 URI와 다른 URI를 참조하는 경우, 오리진 서버는 URI가 동봉 된 해당 자원에 대한 다른 자원의 식별자라고 주장합니다. 대표. 이러한 주장은 두 식별자가 모두 동일한 리소스 소유자를 공유하는 경우에만 신뢰할 수 있으며, 이는 HTTP를 통해 프로그래밍 방식으로 결정할 수 없습니다. o GET 또는 HEAD 요청에 대한 응답이는 유효 요청 URI가 컨텐츠 협상의 대상이되는 자원을 나타내며 Content-Location 필드-값이 선택된 표현에 대한보다 구체적인 식별자임을 나타냅니다. o 상태 변경 방법에 대한 201 (작성) 응답의 경우 위치 필드 값과 동일한 컨텐츠 위치 필드 값은이 페이로드가 새로 작성된 자원의 현재 표시임을 나타냅니다. o 그렇지 않으면, 그러한 컨텐츠 위치는이 페이로드가 요청 된 조치의 상태를보고하는 표시이며 주어진 URI에서 동일한 보고서를 사용할 수 있음 (나중에 GET으로 액세스 할 수 있음)을 나타냅니다. 예를 들어POST 요청을 통해 이루어진 구매 거래는 200 (OK) 응답의 페이로드로 영수증 문서를 포함 할 수 있습니다. Content-Location 필드-값은 나중에 동일한 영수증의 사본을 검색하기위한 식별자를 제공합니다. 요청 메시지에서 Content-Location을 전송하는 사용자 에이전트는 해당 값이 사용자 에이전트가 원래 동봉 된 표현의 컨텐츠를 얻은 위치를 나타냅니다 (해당 사용자 에이전트가 수정하기 전에). 다시 말해, 사용자 에이전트는 원래 표현의 소스에 대한 백 링크를 제공하고 있습니다. 요청 메시지에서 Content-Location 필드를 수신하는 오리진 서버는 정보를 표현의 일부로 그대로 저장할 메타 데이터가 아닌 일시적인 요청 컨텍스트로 처리해야합니다.오리진 서버는 해당 컨텍스트를 사용하여 요청 처리를 안내하거나 소스 링크 또는 버전 관리 메타 데이터와 같은 다른 용도로 저장하도록 할 수 있습니다. 그러나 오리진 서버는 그러한 의미 정보를 사용하여 요청 의미를 변경해서는 안됩니다. 예를 들어, 클라이언트가 협상 된 자원에 대해 PUT 요청을하고 오리진 서버가 해당 PUT을 경로 재 지정없이 승인하면 해당 자원의 새 상태는 해당 PUT에 제공된 표현과 일치해야합니다. Content-Location은 협상 된 표현 중 하나만 업데이트하기 위해 리버스 컨텐츠 선택 식별자의 형태로 사용될 수 없습니다. 사용자 에이전트가 후자의 의미를 원한다면 PUT을 Content-Location URI에 직접 적용했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e94ff61628ee1556f9cb7b6e53cdb420e3640f8b" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Range&quot; header field is sent in a single part 206
   (Partial Content) response to indicate the partial range of the
   selected representation enclosed as the message payload, sent in each
   part of a multipart 206 response to indicate the range enclosed
   within each body part, and sent in 416 (Range Not Satisfiable)
   responses to provide information about the selected representation.

     Content-Range       = byte-content-range
                         / other-content-range

     byte-content-range  = bytes-unit SP
                           ( byte-range-resp / unsatisfied-range )

     byte-range-resp     = byte-range &quot;/&quot; ( complete-length / &quot;*&quot; )
     byte-range          = first-byte-pos &quot;-&quot; last-byte-pos
     unsatisfied-range   = &quot;*/&quot; complete-length

     complete-length     = 1*DIGIT

     other-content-range = other-range-unit SP other-range-resp
     other-range-resp    = *CHAR 

   If a 206 (Partial Content) response contains a Content-Range header
   field with a range unit (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;) that the recipient does not
   understand, the recipient MUST NOT attempt to recombine it with a
   stored representation.  A proxy that receives such a message SHOULD
   forward it downstream.

   For byte ranges, a sender SHOULD indicate the complete length of the
   representation from which the range has been extracted, unless the
   complete length is unknown or difficult to determine.  An asterisk
   character (&quot;*&quot;) in place of the complete-length indicates that the
   representation length was unknown when the header field was
   generated.

   The following example illustrates when the complete length of the
   selected representation is known by the sender to be 1234 bytes:

     Content-Range: bytes 42-1233/1234

   and this second example illustrates when the complete length is
   unknown:

     Content-Range: bytes 42-1233/*

   A Content-Range field value is invalid if it contains a
   byte-range-resp that has a last-byte-pos value less than its
   first-byte-pos value, or a complete-length value less than or equal
   to its last-byte-pos value.  The recipient of an invalid
   Content-Range MUST NOT attempt to recombine the received content with
   a stored representation.

   A server generating a 416 (Range Not Satisfiable) response to a
   byte-range request SHOULD send a Content-Range header field with an
   unsatisfied-range value, as in the following example:

     Content-Range: bytes */1234

   The complete-length in a 416 response indicates the current length of
   the selected representation.

   The Content-Range header field has no meaning for status codes that
   do not explicitly describe its semantic.  For this specification,
   only the 206 (Partial Content) and 416 (Range Not Satisfiable) status
   codes describe a meaning for Content-Range. 

   The following are examples of Content-Range values in which the
   selected representation contains a total of 1234 bytes:

   o  The first 500 bytes:

        Content-Range: bytes 0-499/1234

   o  The second 500 bytes:

        Content-Range: bytes 500-999/1234

   o  All except for the first 500 bytes:

        Content-Range: bytes 500-1233/1234

   o  The last 500 bytes:

        Content-Range: bytes 734-1233/1234</source>
          <target state="translated">&quot;컨텐트 범위&quot;헤더 필드는 메시지 페이로드로 묶인 선택된 표현의 부분 범위를 나타 내기 위해 단일 파트 206 (부분 컨텐츠) 응답으로 전송되며, 멀티 파트 206 응답의 각 파트에서 전송되어 범위를 표시합니다. 각 신체 부위를 선택하고 416 (Range Not Satisfiable) 응답으로 전송하여 선택한 표현에 대한 정보를 제공합니다. 내용 범위 = 바이트 내용 범위 / 기타 내용 범위 바이트 내용 범위 = 바이트 단위 SP (바이트 범위 해상도 / 불만족 범위) 바이트 범위 해상도 = 바이트 범위 &quot;/&quot;(완료 -length / &quot;*&quot;) 바이트 범위 = 첫 번째 바이트 위치 &quot;-&quot;마지막 바이트 위치 만족되지 않은 범위 = &quot;* /&quot;complete-length complete-length = 1 * DIGIT other-content-range = other-range-unit SP other-range-resp other-range-resp = * CHAR 206 (부분 컨텐츠) 응답에 Content-Range 헤더 필드가 포함 된 경우 범위 단위 (&lt;a href=&quot;#section-2&quot;&gt;섹션 2&lt;/a&gt;) 수령인이 이해하지 못하는 경우, 수령인은 저장된 표현과 함께 재결합을 시도해서는 안됩니다. 그러한 메시지를받는 프록시는 그것을 다운 스트림으로 전달해야한다. 바이트 범위의 경우, 발신인은 전체 길이를 알 수 없거나 결정하기 어려운 경우를 제외하고 범위가 추출 된 표현의 전체 길이를 표시해야한다. 전체 길이 대신 별표 문자 ( &quot;*&quot;)는 헤더 필드가 생성 될 때 표시 길이를 알 수 없음을 나타냅니다. 다음 예는 발신자가 선택한 표현의 전체 길이를 1234 바이트로 알고있는 경우를 보여줍니다. Content-Range : bytes 42-1233 / 1234 및이 두 번째 예는 전체 길이를 알 수없는 경우를 보여줍니다. Content-Range :bytes 42-1233 / * Content-Range 필드 값에 첫 번째 바이트 위치 값보다 작은 마지막 바이트 위치 값 또는 전체 길이 값보다 작은 바이트 범위 범위 값이 포함 된 경우 유효하지 않은 필드 범위 값 또는 마지막 바이트 위치 값과 같습니다. 유효하지 않은 Content-Range의 수신자는 수신 된 컨텐츠를 저장된 표현과 재결합하려고 시도해서는 안된다 (MUST NOT). 바이트 범위 요청에 대해 416 (Range Not Satisfiable) 응답을 생성하는 서버는 다음 예와 같이 만족하지 않은 범위 값으로 Content-Range 헤더 필드를 보내야합니다. Content-Range : bytes * / 1234 전체 길이 416 응답에서 선택한 표현의 현재 길이를 나타냅니다. Content-Range 헤더 필드는 의미를 명시 적으로 설명하지 않는 상태 코드에는 의미가 없습니다. 이 사양에서는206 (부분 내용) 및 416 (범위가 만족스럽지 않음) 상태 코드 만 내용 범위의 의미를 설명합니다. 다음은 선택한 표현에 총 1234 바이트가 포함 된 Content-Range 값의 예입니다. o 첫 500 바이트 : Content-Range : bytes 0-499 / 1234 o 두 번째 500 바이트 : Content-Range : bytes 500- 999/1234 o 처음 500 바이트를 제외한 모두 : 내용 범위 : 바이트 500-1233 / 1234 o 마지막 500 바이트 : 내용 범위 : 바이트 734-1233 / 1234바이트 0-499 / 1234 o 두 번째 500 바이트 : Content-Range : bytes 500-999 / 1234 o 처음 500 바이트를 제외한 모두 : Content-Range : bytes 500-1233 / 1234 o 마지막 500 바이트 : Content-Range : 바이트 734-1233 / 1234바이트 0-499 / 1234 o 두 번째 500 바이트 : Content-Range : bytes 500-999 / 1234 o 처음 500 바이트를 제외한 모두 : Content-Range : bytes 500-1233 / 1234 o 마지막 500 바이트 : Content-Range : 바이트 734-1233 / 1234</target>
        </trans-unit>
        <trans-unit id="3c402cbbcb9ecb9297de91cbbec783939a3ff8f6" translate="yes" xml:space="preserve">
          <source>The &quot;Content-Type&quot; header field indicates the media type of the
   associated representation: either the representation enclosed in the
   message payload or the selected representation, as determined by the
   message semantics.  The indicated media type defines both the data
   format and how that data is intended to be processed by a recipient,
   within the scope of the received message semantics, after any content
   codings indicated by Content-Encoding are decoded.

     Content-Type = media-type 

   Media types are defined in &lt;a href=&quot;#section-3.1.1.1&quot;&gt;Section 3.1.1.1&lt;/a&gt;.  An example of the field
   is

     Content-Type: text/html; charset=ISO-8859-4

   A sender that generates a message containing a payload body SHOULD
   generate a Content-Type header field in that message unless the
   intended media type of the enclosed representation is unknown to the
   sender.  If a Content-Type header field is not present, the recipient
   MAY either assume a media type of &quot;application/octet-stream&quot;
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-4.5.1&quot;&gt;[RFC2046], Section&amp;nbsp;4.5.1&lt;/a&gt;) or examine the data to determine its type.

   In practice, resource owners do not always properly configure their
   origin server to provide the correct Content-Type for a given
   representation, with the result that some clients will examine a
   payload's content and override the specified type.  Clients that do
   so risk drawing incorrect conclusions, which might expose additional
   security risks (e.g., &quot;privilege escalation&quot;).  Furthermore, it is
   impossible to determine the sender's intent by examining the data
   format: many data formats match multiple media types that differ only
   in processing semantics.  Implementers are encouraged to provide a
   means of disabling such &quot;content sniffing&quot; when it is used.</source>
          <target state="translated">&quot;컨텐츠 유형&quot;헤더 필드는 메시지 표현에 의해 결정된 메시지 페이로드에 포함 된 표현 또는 선택된 표현 중 하나와 관련된 표현의 미디어 유형을 나타낸다. 지시 된 미디어 타입은 데이터 인코딩에 의해 지시 된 임의의 콘텐츠 코딩이 디코딩 된 후, 데이터 포맷 및 수신 된 메시지 시맨틱의 범위 내에서 수신자에 의해 데이터가 처리되도록 의도 된 방법 모두를 정의한다. 콘텐츠 유형 = 미디어 유형 미디어 유형은&lt;a href=&quot;#section-3.1.1.1&quot;&gt; 3.1.1.1 절에&lt;/a&gt;. 이 필드의 예는 Content-Type입니다. text / html; charset = ISO-8859-4 페이로드 본문을 포함하는 메시지를 생성하는 발신자는 동봉 된 표현의 의도 된 미디어 유형이 발신자에게 알려지지 않은 경우 해당 메시지에 Content-Type 헤더 필드를 생성해야합니다 (SHOULD). Content-Type 헤더 필드가 존재하지 않는 경우, 수신자는 미디어 유형이 &quot;application / octet-stream&quot;( &lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-4.5.1&quot;&gt;[RFC2046], 섹션 4.5.1)을 가정 할 수있다.&lt;/a&gt;) 또는 데이터를 검사하여 유형을 확인하십시오. 실제로, 자원 소유자는 주어진 표현에 대해 올바른 컨텐츠 유형을 제공하도록 항상 오리진 서버를 올바르게 구성하지는 않으며, 그 결과 일부 클라이언트는 페이로드의 컨텐츠를 검사하고 지정된 유형을 대체합니다. 그렇게하는 클라이언트는 잘못된 결론을 도출하여 추가적인 보안 위험이 발생할 수 있습니다 (예 : &quot;권한 에스컬레이션&quot;). 또한 데이터 형식을 검사하여 보낸 사람의 의도를 확인할 수 없습니다. 많은 데이터 형식이 처리 의미 만 다른 여러 미디어 유형과 일치합니다. 구현자는 이러한 &quot;컨텐츠 스니핑&quot;을 사용할 때이를 비활성화하는 수단을 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c0724161072ae90382f70ffbb3410a3dba3f3bf1" translate="yes" xml:space="preserve">
          <source>The &quot;Date&quot; header field represents the date and time at which the
   message was originated, having the same semantics as the Origination
   Date Field (orig-date) defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.1&quot;&gt;Section&amp;nbsp;3.6.1 of [RFC5322]&lt;/a&gt;.  The
   field value is an HTTP-date, as defined in &lt;a href=&quot;#section-7.1.1.1&quot;&gt;Section 7.1.1.1&lt;/a&gt;.

     Date = HTTP-date

   An example is

     Date: Tue, 15 Nov 1994 08:12:31 GMT

   When a Date header field is generated, the sender SHOULD generate its
   field value as the best available approximation of the date and time
   of message generation.  In theory, the date ought to represent the
   moment just before the payload is generated.  In practice, the date
   can be generated at any time during message origination.

   An origin server MUST NOT send a Date header field if it does not
   have a clock capable of providing a reasonable approximation of the
   current instance in Coordinated Universal Time.  An origin server MAY
   send a Date header field if the response is in the 1xx
   (Informational) or 5xx (Server Error) class of status codes.  An
   origin server MUST send a Date header field in all other cases. 

   A recipient with a clock that receives a response message without a
   Date header field MUST record the time it was received and append a
   corresponding Date header field to the message's header section if it
   is cached or forwarded downstream.

   A user agent MAY send a Date header field in a request, though
   generally will not do so unless it is believed to convey useful
   information to the server.  For example, custom applications of HTTP
   might convey a Date if the server is expected to adjust its
   interpretation of the user's request based on differences between the
   user agent and server clocks.</source>
          <target state="translated">&quot;날짜&quot;헤더 필드는 메시지가 시작된 날짜와 시간을 나타내며 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.1&quot;&gt;[RFC5322]의 3.6.1 절에&lt;/a&gt; 정의 된 시작 날짜 필드 (원래 날짜)와 동일한 의미를 갖습니다. . 필드 값은 &lt;a href=&quot;#section-7.1.1.1&quot;&gt;섹션 7.1.1.1에&lt;/a&gt; 정의 된 HTTP 날짜입니다.. Date = HTTP-date 예는 Date : Tue, 1994 년 11 월 15 일 08:12:31 GMT입니다. Date 헤더 필드가 생성되면 발신인은 메시지 생성 날짜 및 시간의 근사값으로 필드 값을 생성해야합니다 (SHOULD). 이론적으로 날짜는 페이로드가 생성되기 직전의 순간을 나타내야합니다. 실제로 날짜는 메시지가 생성되는 동안 언제든지 생성 될 수 있습니다. 오리진 서버는 협정 세계시로 현재 인스턴스의 합리적인 근사치를 제공 할 수있는 시계가없는 경우 날짜 헤더 필드를 보내서는 안됩니다. 응답이 상태 코드의 1xx (정보) 또는 5xx (서버 오류) 클래스 인 경우 오리진 서버는 날짜 헤더 필드를 보낼 수 있습니다 (MAY). 오리진 서버는 다른 모든 경우에 날짜 헤더 필드를 보내야합니다.날짜 헤더 필드가없는 응답 메시지를 수신하는 시계를 가진 수신자는 수신 한 시간을 기록하고 메시지가 다운 스트림에 캐시되거나 전달 될 경우 해당 날짜 헤더 필드를 메시지의 헤더 섹션에 추가해야합니다. 사용자 에이전트는 요청에 날짜 헤더 필드를 보낼 수 있지만, 일반적으로 유용한 정보를 서버에 전달한다고 믿지 않는 한 그렇게하지는 않습니다. 예를 들어, HTTP의 사용자 정의 응용 프로그램은 서버가 사용자 에이전트와 서버 시계의 차이에 기초하여 사용자의 요청에 대한 해석을 조정해야하는 경우 날짜를 전달할 수 있습니다.다운 스트림에 캐시되거나 전달 된 경우 헤더 섹션. 사용자 에이전트는 요청에 날짜 헤더 필드를 보낼 수 있지만, 일반적으로 유용한 정보를 서버에 전달한다고 믿지 않는 한 그렇게하지는 않습니다. 예를 들어, HTTP의 사용자 정의 응용 프로그램은 서버가 사용자 에이전트와 서버 시계의 차이에 기초하여 사용자의 요청에 대한 해석을 조정해야하는 경우 날짜를 전달할 수 있습니다.다운 스트림에 캐시되거나 전달 된 경우 헤더 섹션. 사용자 에이전트는 요청에 날짜 헤더 필드를 보낼 수 있지만, 일반적으로 유용한 정보를 서버에 전달한다고 믿지 않는 한 그렇게하지는 않습니다. 예를 들어, HTTP의 사용자 정의 응용 프로그램은 서버가 사용자 에이전트와 서버 시계의 차이에 기초하여 사용자의 요청에 대한 해석을 조정해야하는 경우 날짜를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5a2d6bec4db1f50bd741730e8b916c0b881dd31" translate="yes" xml:space="preserve">
          <source>The &quot;ETag&quot; header field in a response provides the current entity-tag
   for the selected representation, as determined at the conclusion of
   handling the request.  An entity-tag is an opaque validator for
   differentiating between multiple representations of the same
   resource, regardless of whether those multiple representations are
   due to resource state changes over time, content negotiation
   resulting in multiple representations being valid at the same time,
   or both.  An entity-tag consists of an opaque quoted string, possibly
   prefixed by a weakness indicator.

     ETag       = entity-tag

     entity-tag = [ weak ] opaque-tag
     weak       = %x57.2F ; &quot;W/&quot;, case-sensitive
     opaque-tag = DQUOTE *etagc DQUOTE
     etagc      = %x21 / %x23-7E / obs-text
                ; VCHAR except double quotes, plus obs-text

      Note: Previously, opaque-tag was defined to be a quoted-string
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616], Section&amp;nbsp;3.11&lt;/a&gt;); thus, some recipients might perform
      backslash unescaping.  Servers therefore ought to avoid backslash
      characters in entity tags.

   An entity-tag can be more reliable for validation than a modification
   date in situations where it is inconvenient to store modification
   dates, where the one-second resolution of HTTP date values is not
   sufficient, or where modification dates are not consistently
   maintained.

   Examples:

     ETag: &quot;xyzzy&quot;
     ETag: W/&quot;xyzzy&quot;
     ETag: &quot;&quot; 

   An entity-tag can be either a weak or strong validator, with strong
   being the default.  If an origin server provides an entity-tag for a
   representation and the generation of that entity-tag does not satisfy
   all of the characteristics of a strong validator (&lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt;), then
   the origin server MUST mark the entity-tag as weak by prefixing its
   opaque value with &quot;W/&quot; (case-sensitive).</source>
          <target state="translated">응답의 &quot;ETag&quot;헤더 필드는 요청 처리의 결론에 따라 선택된 표현에 대한 현재 엔티티 태그를 제공합니다. 엔티티 태그는 시간이 지남에 따라 자원 상태가 변경되는지 여부, 컨텐츠 협상을 통해 여러 표현이 동시에 유효한지 또는 두 가지 모두에 관계없이 동일한 자원의 여러 표현을 구별하기위한 불투명 한 유효성 검사기입니다. 엔티티 태그는 불투명 인용 문자열로 구성되며 약점 표시기가 접두사로 표시 될 수 있습니다. ETag = 엔티티 태그 엔티티 태그 = [약한] 불투명 태그 약한 = % x57.2F; &quot;W /&quot;, 대소 문자 구분 불투명 태그 = DQUOTE * etagc DQUOTE etagc = % x21 / % x23-7E / obs-text; 큰 따옴표를 제외한 VCHAR,plus obs-text 참고 : 이전에는 불투명 태그가 인용 문자열 (&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616], 섹션 3.11&lt;/a&gt; ); 따라서 일부받는 사람은 백 슬래시 이스케이프 처리를 수행 할 수 있습니다. 따라서 서버는 엔티티 태그에서 백 슬래시 문자를 사용하지 않아야합니다. 엔터티 태그는 수정 날짜를 저장하는 것이 불편하거나 HTTP 날짜 값의 1 초 해상도가 충분하지 않거나 수정 날짜가 일관되게 유지되지 않는 경우 수정 날짜보다 유효성 검증에 더 신뢰할 수 있습니다. 예 : ETag : &quot;xyzzy&quot;ETag : W / &quot;xyzzy&quot;ETag : &quot;&quot;엔티티 태그는 약하거나 강력한 유효성 검사기 일 수 있으며 기본값은 strong입니다.오리진 서버가 표현을 위해 엔티티 태그를 제공하고 해당 엔티티 태그 생성이 강력한 유효성 검증기의 모든 특성을 충족시키지 못하는 경우 ( &lt;a href=&quot;#section-2.1&quot;&gt;섹션 2.1)&lt;/a&gt;), 원 서버는 불투명 한 값 앞에 &quot;W /&quot;(대소 문자 구분)를 붙여 엔티티 태그를 약한 것으로 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="6cbf7e19bfd8298755a091ae5f476f70610c660d" translate="yes" xml:space="preserve">
          <source>The &quot;Expect&quot; header field in a request indicates a certain set of
   behaviors (expectations) that need to be supported by the server in
   order to properly handle this request.  The only such expectation
   defined by this specification is 100-continue.

     Expect  = &quot;100-continue&quot;

   The Expect field-value is case-insensitive.

   A server that receives an Expect field-value other than 100-continue
   MAY respond with a 417 (Expectation Failed) status code to indicate
   that the unexpected expectation cannot be met.

   A 100-continue expectation informs recipients that the client is
   about to send a (presumably large) message body in this request and
   wishes to receive a 100 (Continue) interim response if the
   request-line and header fields are not sufficient to cause an
   immediate success, redirect, or error response.  This allows the
   client to wait for an indication that it is worthwhile to send the
   message body before actually doing so, which can improve efficiency
   when the message body is huge or when the client anticipates that an
   error is likely (e.g., when sending a state-changing method, for the
   first time, without previously verified authentication credentials).

   For example, a request that begins with

     PUT /somewhere/fun HTTP/1.1
     Host: origin.example.com
     Content-Type: video/h264
     Content-Length: 1234567890987
     Expect: 100-continue


   allows the origin server to immediately respond with an error
   message, such as 401 (Unauthorized) or 405 (Method Not Allowed),
   before the client starts filling the pipes with an unnecessary data
   transfer.

   Requirements for clients:

   o  A client MUST NOT generate a 100-continue expectation in a request
      that does not include a message body.

   o  A client that will wait for a 100 (Continue) response before
      sending the request message body MUST send an Expect header field
      containing a 100-continue expectation. 

   o  A client that sends a 100-continue expectation is not required to
      wait for any specific length of time; such a client MAY proceed to
      send the message body even if it has not yet received a response.
      Furthermore, since 100 (Continue) responses cannot be sent through
      an HTTP/1.0 intermediary, such a client SHOULD NOT wait for an
      indefinite period before sending the message body.

   o  A client that receives a 417 (Expectation Failed) status code in
      response to a request containing a 100-continue expectation SHOULD
      repeat that request without a 100-continue expectation, since the
      417 response merely indicates that the response chain does not
      support expectations (e.g., it passes through an HTTP/1.0 server).

   Requirements for servers:

   o  A server that receives a 100-continue expectation in an HTTP/1.0
      request MUST ignore that expectation.

   o  A server MAY omit sending a 100 (Continue) response if it has
      already received some or all of the message body for the
      corresponding request, or if the framing indicates that there is
      no message body.

   o  A server that sends a 100 (Continue) response MUST ultimately send
      a final status code, once the message body is received and
      processed, unless the connection is closed prematurely.

   o  A server that responds with a final status code before reading the
      entire message body SHOULD indicate in that response whether it
      intends to close the connection or continue reading and discarding
      the request message (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.6&quot;&gt;Section&amp;nbsp;6.6 of [RFC7230]&lt;/a&gt;).

   An origin server MUST, upon receiving an HTTP/1.1 (or later)
   request-line and a complete header section that contains a
   100-continue expectation and indicates a request message body will
   follow, either send an immediate response with a final status code,
   if that status can be determined by examining just the request-line
   and header fields, or send an immediate 100 (Continue) response to
   encourage the client to send the request's message body.  The origin
   server MUST NOT wait for the message body before sending the 100
   (Continue) response.

   A proxy MUST, upon receiving an HTTP/1.1 (or later) request-line and
   a complete header section that contains a 100-continue expectation
   and indicates a request message body will follow, either send an
   immediate response with a final status code, if that status can be
   determined by examining just the request-line and header fields, or
   begin forwarding the request toward the origin server by sending a 

   corresponding request-line and header section to the next inbound
   server.  If the proxy believes (from configuration or past
   interaction) that the next inbound server only supports HTTP/1.0, the
   proxy MAY generate an immediate 100 (Continue) response to encourage
   the client to begin sending the message body.

      Note: The Expect header field was added after the original
      publication of HTTP/1.1 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt;] as both the means to request an
      interim 100 (Continue) response and the general mechanism for
      indicating must-understand extensions.  However, the extension
      mechanism has not been used by clients and the must-understand
      requirements have not been implemented by many servers, rendering
      the extension mechanism useless.  This specification has removed
      the extension mechanism in order to simplify the definition and
      processing of 100-continue.</source>
          <target state="translated">요청의 &quot;예상&quot;헤더 필드는이 요청을 올바르게 처리하기 위해 서버에서 지원해야하는 특정 동작 (예상)을 나타냅니다. 본 명세서에 의해 정의 된 그러한 기대는 100- 연속이다. Expect = &quot;100-continue&quot;Expect 필드 값은 대소 문자를 구분하지 않습니다. 100-continue 이외의 Expect 필드 값을받는 서버는 417 (예상 실패) 상태 코드로 응답하여 예상치 못한 기대를 충족 할 수 없음을 나타낼 수 있습니다. 100- 연속 기대는 클라이언트에게이 요청에서 (아마도 큰) 메시지 본문을 보내려고하고 요청 라인 및 헤더 필드가 즉각적인 원인이 될 수없는 경우 100 (계속) 중간 응답을 수신하려고 함을 수신자에게 알립니다. 성공, 리디렉션,또는 오류 응답. 이를 통해 클라이언트는 실제로 전송하기 전에 메시지 본문을 전송하는 것이 가치가 있다는 표시를 기다릴 수 있으므로 메시지 본문이 크거나 클라이언트가 오류가 발생할 것으로 예상 될 때 (예 : 상태를 보낼 때) 효율성을 향상시킬 수 있습니다. -이전에 확인 된 인증 자격 증명없이 변경 방법). 예를 들어 PUT / somewhere / fun HTTP / 1.1 호스트로 시작하는 요청 : origin.example.com Content-Type : video / h264 Content-Length : 1234567890987 예상 : 100-continue를 사용하면 오리진 서버가 즉시 오류로 응답 할 수 있습니다. 클라이언트가 불필요한 데이터 전송으로 파이프를 채우기 시작하기 전에 401 (권한 없음) 또는 405 (방법이 허용되지 않음)와 같은 메시지가 표시됩니다. 고객을위한 요구 사항 :o 클라이언트는 메시지 본문을 포함하지 않는 요청에서 100- 연속 기대치를 생성해서는 안됩니다 (MUST NOT). o 요청 메시지 본문을 보내기 전에 100 (계속) 응답을 기다리는 클라이언트는 100- 연속 예상을 포함하는 Expect 헤더 필드를 보내야합니다. o 100- 연속 기대 값을 보내는 클라이언트는 특정 시간 동안 기다릴 필요가 없습니다. 이러한 클라이언트는 아직 응답을받지 않은 경우에도 메시지 본문을 계속 전송할 수 있습니다. 더욱이, 100 (Continue) 응답은 HTTP / 1.0 중개자를 통해 전송 될 수 없으므로 이러한 클라이언트는 메시지 본문을 보내기 전에 무기한 대기해야합니다.o 100- 연속 예상을 포함하는 요청에 대한 응답으로 417 (예상 실패) 상태 코드를 수신하는 클라이언트는 417 응답이 응답 체인이 기대를 지원하지 않음을 나타 내기 때문에 100- 연속 기대없이 요청을 반복해야합니다. 예를 들어, HTTP / 1.0 서버를 통과합니다). 서버 요구 사항 : o HTTP / 1.0 요청에서 100- 연속 예상을받는 서버는 해당 기대를 무시해야합니다. o 서버가 해당 요청에 대한 메시지 본문의 일부 또는 전부를 이미 수신했거나 프레임이 메시지 본문이 없음을 나타내는 경우 100 (계속) 응답 전송을 생략 할 수 있습니다. o 100 (계속) 응답을 보내는 서버는 궁극적으로 최종 상태 코드를 보내야합니다.연결이 너무 일찍 닫히지 않는 한, 메시지 본문이 수신되고 처리되면 o 전체 메시지 본문을 읽기 전에 최종 상태 코드로 응답하는 서버는 해당 연결에서 연결을 닫을 것인지 또는 계속해서 요청 메시지를 읽고 버릴 것인지를 표시해야합니다 (참조).&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.6&quot;&gt;[RFC7230]의 섹션 6.6&lt;/a&gt;). 오리진 서버는 반드시 HTTP / 1.1 (또는 그 이후) 요청 라인과 100- 연속 예상을 포함하고 요청 메시지 본문이 뒤 따르고 있음을 나타내는 완전한 헤더 섹션을 수신해야합니다. 요청 상태 및 헤더 필드 만 검사하여 해당 상태를 판별하거나 즉시 100 (계속) 응답을 보내 클라이언트가 요청의 메시지 본문을 보내도록 권장하십시오. 오리진 서버는 100 (Continue) 응답을 보내기 전에 메시지 본문을 기다리지 않아야합니다. 프록시는 반드시 HTTP / 1.1 (또는 그 이후) 요청 라인과 100- 연속 예상을 포함하고 요청 메시지 본문이 따르도록 지시하는 완전한 헤더 섹션을 수신해야합니다.요청 라인 및 헤더 필드 만 검사하여 해당 상태를 판별하거나 해당 요청 라인 및 헤더 섹션을 다음 인바운드 서버로 전송하여 요청을 오리진 서버로 전달하기 시작하십시오. 프록시가 (구성 또는 과거 상호 작용에서) 다음 인바운드 서버가 HTTP / 1.0 만 지원한다고 믿는 경우, 클라이언트가 메시지 본문을 보내기 시작하도록 격려하기 위해 프록시는 즉시 100 (계속) 응답을 생성 할 수 있습니다. 참고 : Expect 헤더 필드는 HTTP / 1.1의 최초 게시 이후에 추가되었습니다 [프록시가 (구성 또는 과거 상호 작용에서) 다음 인바운드 서버가 HTTP / 1.0 만 지원한다고 믿는 경우, 클라이언트가 메시지 본문을 보내기 시작하도록 격려하기 위해 프록시는 즉시 100 (계속) 응답을 생성 할 수 있습니다. 참고 : Expect 헤더 필드는 HTTP / 1.1의 최초 게시 이후에 추가되었습니다 [프록시가 (구성 또는 과거 상호 작용에서) 다음 인바운드 서버가 HTTP / 1.0 만 지원한다고 믿는 경우, 클라이언트가 메시지 본문을 보내기 시작하도록 격려하기 위해 프록시는 즉시 100 (계속) 응답을 생성 할 수 있습니다. 참고 : Expect 헤더 필드는 HTTP / 1.1의 최초 게시 이후에 추가되었습니다 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt; ]은 중간 100 (계속) 응답을 요청하는 수단과 반드시 ​​이해해야하는 확장을 나타내는 일반적인 메커니즘입니다. 그러나 클라이언트는 확장 메커니즘을 사용하지 않았으며 많은 서버에서 필수 이해 요구 사항을 구현하지 않아 확장 메커니즘을 사용할 수 없게되었습니다. 이 사양에서는 100- 연속의 정의 및 처리를 단순화하기 위해 확장 메커니즘을 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="73ec74b4c3de0b0e8320b9c1e9209dc1703d5df1" translate="yes" xml:space="preserve">
          <source>The &quot;Expires&quot; header field gives the date/time after which the
   response is considered stale.  See &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; for further discussion
   of the freshness model.

   The presence of an Expires field does not imply that the original
   resource will change or cease to exist at, before, or after that
   time.

   The Expires value is an HTTP-date timestamp, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;7.1.1.1 of [RFC7231]&lt;/a&gt;.

     Expires = HTTP-date

   For example

     Expires: Thu, 01 Dec 1994 16:00:00 GMT

   A cache recipient MUST interpret invalid date formats, especially the
   value &quot;0&quot;, as representing a time in the past (i.e., &quot;already
   expired&quot;).

   If a response includes a Cache-Control field with the max-age
   directive (&lt;a href=&quot;#section-5.2.2.8&quot;&gt;Section 5.2.2.8&lt;/a&gt;), a recipient MUST ignore the Expires
   field.  Likewise, if a response includes the s-maxage directive
   (&lt;a href=&quot;#section-5.2.2.9&quot;&gt;Section 5.2.2.9&lt;/a&gt;), a shared cache recipient MUST ignore the Expires
   field.  In both these cases, the value in Expires is only intended
   for recipients that have not yet implemented the Cache-Control field.

   An origin server without a clock MUST NOT generate an Expires field
   unless its value represents a fixed time in the past (always expired)
   or its value has been associated with the resource by a system or
   user with a reliable clock.

   Historically, HTTP required the Expires field-value to be no more
   than a year in the future.  While longer freshness lifetimes are no
   longer prohibited, extremely large values have been demonstrated to
   cause problems (e.g., clock overflows due to use of 32-bit integers
   for time values), and many caches will evict a response far sooner
   than that.</source>
          <target state="translated">&quot;만료&quot;헤더 필드는 응답이 오래되었다고 간주 된 날짜 / 시간을 제공합니다. 신선도 모델에 대한 자세한 내용 &lt;a href=&quot;#section-4.2&quot;&gt;은 4.2 절을&lt;/a&gt; 참조하십시오 . 만료 필드가 있다고해서 원래 리소스가 해당 시간 전, 후 또는 후에 존재하거나 변경되지 않는다는 것을 의미하지는 않습니다. Expires 값은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;[RFC7231]의 7.1.1.1 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.1&quot;&gt;섹션에&lt;/a&gt; 정의 된 HTTP- 날짜 타임 스탬프 입니다. Expires = HTTP-date 예 : Expires : Thu, 1994 년 12 월 01 일 16:00:00 GMT 캐시 수신자는 유효하지 않은 날짜 형식, 특히 &quot;0&quot;값을 과거의 시간을 나타내는 것으로 해석해야합니다 (예 : &quot;이미 만료 됨&quot; ). 응답에 max-age 지시문이있는 Cache-Control 필드가 포함 된 경우 ( &lt;a href=&quot;#section-5.2.2.8&quot;&gt;5.2.2.8 단원)&lt;/a&gt;) 수신자는 반드시 만료 필드를 무시해야합니다. 마찬가지로 응답에 s-maxage 지시문이 포함 된 경우 ( &lt;a href=&quot;#section-5.2.2.9&quot;&gt;섹션 5.2.2.9)&lt;/a&gt;) 공유 캐시 수신자는 반드시 만료 필드를 무시해야합니다. 이 두 경우 모두 Expires의 값은 아직 Cache-Control 필드를 구현하지 않은받는 사람을위한 것입니다. 시계가없는 오리진 서버는 값이 과거의 고정 시간을 나타내거나 (항상 만료 됨) 신뢰할 수있는 시계를 가진 시스템이나 사용자가 해당 값을 리소스와 연결하지 않은 경우 만료 필드를 생성해서는 안됩니다 (MUST NOT). 역사적으로 HTTP는 Expires 필드 값이 향후 1 년을 넘지 않아야했습니다. 더 긴 신선도 수명이 더 이상 금지되지 않지만, 매우 큰 값은 문제를 유발하는 것으로 입증되었습니다 (예 : 시간 값에 32 비트 정수를 사용하여 클록 오버플로). 많은 캐시가 그보다 훨씬 빠른 응답을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="435ee716a99e236d6e9d74d1e773dafee502988a" translate="yes" xml:space="preserve">
          <source>The &quot;From&quot; header field contains an Internet email address for a
   human user who controls the requesting user agent.  The address ought
   to be machine-usable, as defined by &quot;mailbox&quot; in &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;Section&amp;nbsp;3.4 of
   [RFC5322]&lt;/a&gt;:

     From    = mailbox

     mailbox = &amp;lt;mailbox, see &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322], Section&amp;nbsp;3.4&lt;/a&gt;&amp;gt;

   An example is:

     From: webmaster@example.org

   The From header field is rarely sent by non-robotic user agents.  A
   user agent SHOULD NOT send a From header field without explicit
   configuration by the user, since that might conflict with the user's
   privacy interests or their site's security policy. 

   A robotic user agent SHOULD send a valid From header field so that
   the person responsible for running the robot can be contacted if
   problems occur on servers, such as if the robot is sending excessive,
   unwanted, or invalid requests.

   A server SHOULD NOT use the From header field for access control or
   authentication, since most recipients will assume that the field
   value is public information.</source>
          <target state="translated">&quot;보낸 사람&quot;헤더 필드에는 요청하는 사용자 에이전트를 제어하는 ​​인간 사용자의 인터넷 이메일 주소가 포함됩니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;[RFC5322]의 섹션 3.4&lt;/a&gt; 에서 &quot;사서함&quot;으로 정의 된대로 주소는 기계로 사용 가능해야합니다 . From = mailbox mailbox = &amp;lt;mailbox &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.4&quot;&gt;, 섹션 3.4를&lt;/a&gt; 참조하십시오 .&amp;gt; 예 : From : webmaster@example.org From 헤더 필드는 거의 로봇이 아닌 사용자 에이전트에 의해 전송되지 않습니다. 사용자 에이전트는 사용자의 명시적인 구성 없이는 From 헤더 필드를 보내지 않아야합니다. 사용자 헤더는 사용자의 개인 정보 보호 또는 사이트의 보안 정책과 충돌 할 수 있기 때문입니다. 로봇 사용자 에이전트는 서버에서 문제가 발생하는 경우 (예 : 로봇이 과도하거나 원치 않거나 잘못된 요청을 보내는 경우) 로봇 실행 담당자에게 연락 할 수 있도록 유효한 From 헤더 필드를 보내야합니다 (SHOULD). 대부분의 수신자는 필드 값이 공개 정보라고 가정하기 때문에 서버는 액세스 제어 또는 인증에 From 헤더 필드를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="145f68a05a65e51d6c2dc78deb7c678abdc3112c" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Content Coding Registry&quot; defines the namespace for content
   coding names (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7230]&lt;/a&gt;).  The content coding registry
   is maintained at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&quot;HTTP 컨텐츠 코딩 레지스트리&quot;는 컨텐츠 코딩 이름의 네임 스페이스를 정의합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.2&quot;&gt;[RFC7230]의 4.2 절&lt;/a&gt; ). 콘텐츠 코딩 레지스트리는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;에 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="096c718821f30fce49e8b7b18bb3a8ea8e6712d1" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Content Coding Registry&quot; has been updated with the
   registrations below:

   +----------+----------------------------------------+---------------+
   | Name     | Description                            | Reference     |
   +----------+----------------------------------------+---------------+
   | identity | Reserved (synonym for &quot;no encoding&quot; in | &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt; |
   |          | Accept-Encoding)                       |               |
   +----------+----------------------------------------+---------------+</source>
          <target state="translated">&quot;HTTP 컨텐츠 코딩 레지스트리&quot;가 아래 등록으로 업데이트되었습니다 : + ---------- + ----------------------- ----------------- + --------------- + | 이름 | 설명 | 참조 | + ---------- + -------------------------------------- -+ --------------- + | 정체성 | 예약 ( &lt;a href=&quot;#section-5.3.4&quot;&gt;섹션 5.3.4&lt;/a&gt; | &quot; 허용 인코딩&quot;의 &quot;인코딩 없음&quot;의 동의어 ) | | + ---------- + -------------------------------------- -+ --------------- +</target>
        </trans-unit>
        <trans-unit id="a5c1ee951a5c8eed58e62c23efb0f5396f9627c4" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Range Unit Registry&quot; defines the namespace for the range
   unit names and refers to their corresponding specifications.  The
   registry has been created and is now maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&quot;HTTP 범위 단위 레지스트리&quot;는 범위 단위 이름의 네임 스페이스를 정의하고 해당 스펙을 나타냅니다. 레지스트리가 작성되었으며 이제 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt; 에서 유지 보수됩니다 .</target>
        </trans-unit>
        <trans-unit id="c05bfcc8f57df61bc6ed194b315d3b4b0050023f" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Transfer Coding Registry&quot; defines the namespace for
   transfer coding names.  It is maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&quot;HTTP 전송 코딩 레지스트리&quot;는 전송 코딩 이름의 네임 스페이스를 정의합니다. &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt;에 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="a0b8c24090cb7e4cccc52c9a6ee16a7c95a28e07" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP Transfer Coding Registry&quot; has been updated with the
   registrations below:

   +------------+--------------------------------------+---------------+
   | Name       | Description                          | Reference     |
   +------------+--------------------------------------+---------------+
   | chunked    | Transfer in a series of chunks       | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;   |
   | compress   | UNIX &quot;compress&quot; data format [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;]  | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | deflate    | &quot;deflate&quot; compressed data            | &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt; |
   |            | ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;]) inside the &quot;zlib&quot; data   |               |
   |            | format ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;])                   |               |
   | gzip       | GZIP file format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;]           | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   | x-compress | Deprecated (alias for compress)      | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | x-gzip     | Deprecated (alias for gzip)          | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   +------------+--------------------------------------+---------------+</source>
          <target state="translated">&quot;HTTP 전송 코딩 레지스트리&quot;가 아래 등록으로 업데이트되었습니다 : + ------------ + --------------------- ----------------- + --------------- + | 이름 | 설명 | 참조 | + ------------ + ------------------------------------ -+ --------------- + | 청크 | 일련의 덩어리로 전송 | &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt; | | 압축 | UNIX &quot;압축&quot;데이터 형식 [ &lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.1&quot;&gt;섹션 4.2.1&lt;/a&gt; | | 수축하다 | 압축 된 데이터 &quot;delate&quot;| &lt;a href=&quot;#section-4.2.2&quot;&gt;섹션 4.2.2&lt;/a&gt; | | | &quot;zlib&quot;데이터 내부의 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ]) | | | | 형식 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;]) | | | gzip | GZIP 파일 형식 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.3&quot;&gt;섹션 4.2.3&lt;/a&gt; | | x- 압축 | 더 이상 사용되지 않음 (압축 별명) | &lt;a href=&quot;#section-4.2.1&quot;&gt;섹션 4.2.1&lt;/a&gt; | | x-gzip | 더 이상 사용되지 않음 (gzip의 별명) | &lt;a href=&quot;#section-4.2.3&quot;&gt;섹션 4.2.3&lt;/a&gt; | + ------------ + ------------------------------------ -+ --------------- +</target>
        </trans-unit>
        <trans-unit id="49c73e0ff74e54cb4f5a88bc231df89416d0af4b" translate="yes" xml:space="preserve">
          <source>The &quot;HTTP&quot; entry in the upgrade token registry has been updated with
   the registration below:

   +-------+----------------------+----------------------+-------------+
   | Value | Description          | Expected Version     | Reference   |
   |       |                      | Tokens               |             |
   +-------+----------------------+----------------------+-------------+
   | HTTP  | Hypertext Transfer   | any DIGIT.DIGIT      | &lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt; |
   |       | Protocol             | (e.g, &quot;2.0&quot;)         |             |
   +-------+----------------------+----------------------+-------------+

   The responsible party is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">업그레이드 토큰 레지스트리의 &quot;HTTP&quot;항목이 아래 등록으로 업데이트되었습니다 : + ------- + ---------------------- + ---------------------- + ------------- + | 가치 | 설명 | 예상 버전 | 참조 | | | | 토큰 | | + ------- + ---------------------- + ------------------ ---- + ------------- + | HTTP | 하이퍼 텍스트 전송 | 모든 DIGIT.DIGIT | &lt;a href=&quot;#section-2.6&quot;&gt;섹션 2.6&lt;/a&gt; | | | 프로토콜 | (예 : &quot;2.0&quot;) | | + ------- + ---------------------- + ------------------ ---- + ------------- + 담당 당사자는 &quot;IETF (iesg@ietf.org)-인터넷 엔지니어링 태스크 포스&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="706b09d6ff20df56763add1c7636ec30c154eae9" translate="yes" xml:space="preserve">
          <source>The &quot;Host&quot; header field in a request provides the host and port
   information from the target URI, enabling the origin server to
   distinguish among resources while servicing requests for multiple
   host names on a single IP address.

     Host = uri-host [ &quot;:&quot; port ] ; &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;

   A client MUST send a Host header field in all HTTP/1.1 request
   messages.  If the target URI includes an authority component, then a
   client MUST send a field-value for Host that is identical to that
   authority component, excluding any userinfo subcomponent and its &quot;@&quot;
   delimiter (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;).  If the authority component is missing or
   undefined for the target URI, then a client MUST send a Host header
   field with an empty field-value.

   Since the Host field-value is critical information for handling a
   request, a user agent SHOULD generate Host as the first header field
   following the request-line.

   For example, a GET request to the origin server for
   &amp;lt;http://www.example.org/pub/WWW/&amp;gt; would begin with:

     GET /pub/WWW/ HTTP/1.1
     Host: www.example.org

   A client MUST send a Host header field in an HTTP/1.1 request even if
   the request-target is in the absolute-form, since this allows the
   Host information to be forwarded through ancient HTTP/1.0 proxies
   that might not have implemented Host.

   When a proxy receives a request with an absolute-form of
   request-target, the proxy MUST ignore the received Host header field
   (if any) and instead replace it with the host information of the
   request-target.  A proxy that forwards such a request MUST generate a
   new Host field-value based on the received request-target rather than
   forward the received Host field-value.

   Since the Host header field acts as an application-level routing
   mechanism, it is a frequent target for malware seeking to poison a
   shared cache or redirect a request to an unintended server.  An
   interception proxy is particularly vulnerable if it relies on the
   Host field-value for redirecting requests to internal servers, or for
   use as a cache key in a shared cache, without first verifying that
   the intercepted connection is targeting a valid IP address for that
   host. 

   A server MUST respond with a 400 (Bad Request) status code to any
   HTTP/1.1 request message that lacks a Host header field and to any
   request message that contains more than one Host header field or a
   Host header field with an invalid field-value.</source>
          <target state="translated">요청의 &quot;호스트&quot;헤더 필드는 대상 URI에서 호스트 및 포트 정보를 제공하여 단일 IP 주소에서 여러 호스트 이름에 대한 요청을 처리하는 동안 오리진 서버가 자원을 구별 할 수있게합니다. 호스트 = uri-host [ &quot;:&quot;port]; &lt;a href=&quot;#section-2.7.1&quot;&gt;섹션 2.7.1&lt;/a&gt; 클라이언트는 모든 HTTP / 1.1 요청 메시지에서 호스트 헤더 필드를 보내야한다. 대상 URI에 권한 구성 요소가 포함 된 경우, 클라이언트는 userinfo 하위 구성 요소 및 &quot;@&quot;분리 문자를 제외하고 해당 권한 구성 요소와 동일한 호스트에 대한 필드 값을 보내야합니다 ( &lt;a href=&quot;#section-2.7.1&quot;&gt;섹션 2.7.1).&lt;/a&gt;). 권한 URI 구성 요소가 대상 URI에 대해 누락되었거나 정의되지 않은 경우 클라이언트는 빈 필드 값으로 호스트 헤더 필드를 보내야합니다. 호스트 필드 값은 요청을 처리하기위한 중요한 정보이므로, 사용자 에이전트는 요청 라인 다음에 오는 첫 번째 헤더 필드로 호스트를 생성해야합니다 (SHOULD). 예를 들어, &amp;lt;http://www.example.org/pub/WWW/&amp;gt;에 대한 오리진 서버에 대한 GET 요청은 다음과 같이 시작합니다. GET / pub / WWW / HTTP / 1.1 호스트 : www.example.org 클라이언트는 반드시 있어야합니다. request-target이 절대 형식 인 경우에도 HTTP / 1.1 요청에서 Host header 필드를 보냅니다. 이렇게하면 Host를 구현하지 않았을 수있는 고대 HTTP / 1.0 프록시를 통해 Host 정보를 전달할 수 있습니다. 프록시가 절대 형식의 요청 대상으로 요청을 받으면,프록시는 수신 된 호스트 헤더 필드 (있는 경우)를 무시하고 대신 요청 대상의 호스트 정보로 대체해야합니다. 그러한 요청을 전달하는 프록시는 수신 된 호스트 필드 값을 전달하기보다는 수신 된 요청 대상을 기반으로 새로운 호스트 필드 값을 생성해야합니다. 호스트 헤더 필드는 응용 프로그램 수준 라우팅 메커니즘의 역할을하므로 공유 캐시를 감염 시키거나 의도하지 않은 서버로 요청을 리디렉션하려는 맬웨어의 대상이됩니다. 인터셉트 프록시는 인터셉트 된 연결이 해당 호스트의 유효한 IP 주소를 대상으로하는지 먼저 확인하지 않고 요청을 내부 서버로 리디렉션하거나 공유 캐시에서 캐시 키로 사용하기 위해 호스트 필드 값에 의존하는 경우 특히 취약합니다. .서버는 호스트 헤더 필드가없는 HTTP / 1.1 요청 메시지와 유효하지 않은 필드 값을 가진 호스트 헤더 필드 또는 둘 이상의 호스트 헤더 필드를 포함하는 모든 요청 메시지에 대해 400 (잘못된 요청) 상태 코드로 응답해야합니다. .</target>
        </trans-unit>
        <trans-unit id="bf76981296c1a614d1d61fab43ab95f1d60e0e35" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Authentication Scheme
   Registry&quot; defines the namespace for the authentication schemes in
   challenges and credentials.  It has been created and is now
   maintained at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-authschemes&quot;&gt;http://www.iana.org/assignments/http-authschemes&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&quot;HTTP (Hypertext Transfer Protocol) 인증 체계 레지스트리&quot;는 인증 체계의 네임 스페이스를 도전 과제 및 자격 증명으로 정의합니다. 작성되었으며 현재 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-authschemes&quot;&gt;http://www.iana.org/assignments/http-authschemes&lt;/a&gt; &amp;gt; 에서 유지 보수됩니다 .</target>
        </trans-unit>
        <trans-unit id="88cc8d3cf97af683587a5f4c1d90c4302b8b701f" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Cache Directive Registry&quot;
   defines the namespace for the cache directives.  It has been created
   and is now maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-cache-directives&quot;&gt;http://www.iana.org/assignments/http-cache-directives&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&quot;HTTP (Hypertext Transfer Protocol) 캐시 지시문 레지스트리&quot;는 캐시 지시문의 네임 스페이스를 정의합니다. 작성되었으며 현재 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-cache-directives&quot;&gt;http://www.iana.org/assignments/http-cache-directives&lt;/a&gt; &amp;gt; 에서 유지 보수됩니다 .</target>
        </trans-unit>
        <trans-unit id="b60962bbc448e0c8070e4bc5da2bd79c07e165d8" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Method Registry&quot; defines the
   namespace for the request method token (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;).  The method
   registry has been created and is now maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-methods&quot;&gt;http://www.iana.org/assignments/http-methods&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&quot;HTTP (Hypertext Transfer Protocol) Method Registry&quot;는 요청 메소드 토큰의 네임 스페이스를 정의합니다 ( &lt;a href=&quot;#section-4&quot;&gt;섹션 4&lt;/a&gt; ). 메소드 레지스트리가 작성되었으며 이제 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-methods&quot;&gt;http://www.iana.org/assignments/http-methods&lt;/a&gt; &amp;gt; 에서 유지 보수됩니다 .</target>
        </trans-unit>
        <trans-unit id="c7c8fd27b56ab4d4e5338d1c107879dea630f834" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Method Registry&quot; has been
   populated with the registrations below:

   +---------+------+------------+---------------+
   | Method  | Safe | Idempotent | Reference     |
   +---------+------+------------+---------------+
   | CONNECT | no   | no         | &lt;a href=&quot;#section-4.3.6&quot;&gt;Section 4.3.6&lt;/a&gt; |
   | DELETE  | no   | yes        | &lt;a href=&quot;#section-4.3.5&quot;&gt;Section 4.3.5&lt;/a&gt; |
   | GET     | yes  | yes        | &lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt; |
   | HEAD    | yes  | yes        | &lt;a href=&quot;#section-4.3.2&quot;&gt;Section 4.3.2&lt;/a&gt; |
   | OPTIONS | yes  | yes        | &lt;a href=&quot;#section-4.3.7&quot;&gt;Section 4.3.7&lt;/a&gt; |
   | POST    | no   | no         | &lt;a href=&quot;#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt; |
   | PUT     | no   | yes        | &lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt; |
   | TRACE   | yes  | yes        | &lt;a href=&quot;#section-4.3.8&quot;&gt;Section 4.3.8&lt;/a&gt; |
   +---------+------+------------+---------------+</source>
          <target state="translated">&quot;Hypertext Transfer Protocol (HTTP) Method Registry&quot;는 다음 등록으로 채워져 있습니다. + --------- + ------ + ------------ + --------------- + | 방법 | 안전 | dem 등원 | 참조 | + --------- + ------ + ------------ + --------------- + | 연결 | 아니요 | 아니요 | &lt;a href=&quot;#section-4.3.6&quot;&gt;섹션 4.3.6&lt;/a&gt; | | 삭제 | 아니요 | 예 | &lt;a href=&quot;#section-4.3.5&quot;&gt;섹션 4.3.5&lt;/a&gt; | | GET | 예 | 예 | &lt;a href=&quot;#section-4.3.1&quot;&gt;섹션 4.3.1&lt;/a&gt; | | 헤드 | 예 | 예 | &lt;a href=&quot;#section-4.3.2&quot;&gt;섹션 4.3.2&lt;/a&gt; | | 옵션 | 예 | 예 | &lt;a href=&quot;#section-4.3.7&quot;&gt;4.3.7 절&lt;/a&gt; | | POST | 아니요 | 아니요 | &lt;a href=&quot;#section-4.3.3&quot;&gt;섹션 4.3.3&lt;/a&gt; | | 퍼팅 | 아니요 | 예 | &lt;a href=&quot;#section-4.3.4&quot;&gt;섹션 4.3.4&lt;/a&gt; | | 트랙 | 예 | 예 |&lt;a href=&quot;#section-4.3.8&quot;&gt;섹션 4.3.8&lt;/a&gt; | + --------- + ------ + ------------ + --------------- +</target>
        </trans-unit>
        <trans-unit id="af47de3832189b79659dd3c031cb9fcb9be1aa14" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; defines
   the namespace for the response status-code token (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).  The
   status code registry is maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt;.

   This section replaces the registration procedure for HTTP Status
   Codes previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC2817]&lt;/a&gt;.</source>
          <target state="translated">&quot;HTTP (Hypertext Transfer Protocol) 상태 코드 레지스트리&quot;는 응답 상태 코드 토큰의 네임 스페이스를 정의합니다 ( &lt;a href=&quot;#section-6&quot;&gt;섹션 6&lt;/a&gt; ). 상태 코드 레지스트리는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;에 유지됩니다 . 이 섹션은 이전 &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.1&quot;&gt;에 [RFC2817] 섹션 7.1&lt;/a&gt; 에서 정의 된 HTTP 상태 코드의 등록 절차를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="a4249a89b69736470c36f6442d2bdc76c91dde18" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated to include the registrations below:

   +-------+-----------------------+-------------+
   | Value | Description           | Reference   |
   +-------+-----------------------+-------------+
   | 206   | Partial Content       | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   | 416   | Range Not Satisfiable | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; |
   +-------+-----------------------+-------------+</source>
          <target state="translated">&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;에 있는 &quot;Hypertext Transfer Protocol (HTTP) 상태 코드 레지스트리&quot; 가 아래 등록을 포함하도록 업데이트되었습니다. + ------- + ----------------------- + ------------- + | 가치 | 설명 | 참조 | + ------- + ----------------------- + ------------- + | 206 | 부분 내용 | &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt; | | 416 | 범위가 만족스럽지 않음 | &lt;a href=&quot;#section-4.4&quot;&gt;섹션 4.4&lt;/a&gt; | + ------- + ----------------------- + ------------- +</target>
        </trans-unit>
        <trans-unit id="42357d7df40e3a7ed38e6ec9bc128df372e92eb1" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated with the registrations below:

   +-------+---------------------+-------------+
   | Value | Description         | Reference   |
   +-------+---------------------+-------------+
   | 304   | Not Modified        | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   | 412   | Precondition Failed | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   +-------+---------------------+-------------+</source>
          <target state="translated">&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;에 있는 &quot;Hypertext Transfer Protocol (HTTP) 상태 코드 레지스트리&quot; 가 아래 등록으로 업데이트되었습니다. + ------- + --------------------- + ------------- + | 가치 | 설명 | 참조 | + ------- + --------------------- + ------------- + | 304 | 수정되지 않음 | &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt; | | 412 | 전제 조건 실패 | &lt;a href=&quot;#section-4.2&quot;&gt;4.2 절&lt;/a&gt; | + ------- + --------------------- + ------------- +</target>
        </trans-unit>
        <trans-unit id="6373f51fbfb2756123d6ebe8d028d312dde91148" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Status Code Registry&quot; located
   at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt; has been
   updated with the registrations below:

   +-------+-------------------------------+-------------+
   | Value | Description                   | Reference   |
   +-------+-------------------------------+-------------+
   | 401   | Unauthorized                  | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   | 407   | Proxy Authentication Required | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   +-------+-------------------------------+-------------+</source>
          <target state="translated">&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt;에 있는 &quot;Hypertext Transfer Protocol (HTTP) 상태 코드 레지스트리&quot; 가 아래 등록으로 업데이트되었습니다. + ------- + ------------------------------- + ------------- + | 가치 | 설명 | 참조 | + ------- + ------------------------------- + --------- ---- + | 401 | 무단 | &lt;a href=&quot;#section-3.1&quot;&gt;섹션 3.1&lt;/a&gt; | | 407 | 프록시 인증 필요 | &lt;a href=&quot;#section-3.2&quot;&gt;섹션 3.2&lt;/a&gt; | + ------- + ------------------------------- + --------- ---- +</target>
        </trans-unit>
        <trans-unit id="5cad05fd1eebfb52b696d9b41f75945bfa2216cd" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Upgrade Token Registry&quot;
   defines the namespace for protocol-name tokens used to identify
   protocols in the Upgrade header field.  The registry is maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-upgrade-tokens&quot;&gt;http://www.iana.org/assignments/http-upgrade-tokens&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&quot;HTTP (Hypertext Transfer Protocol) 업그레이드 토큰 레지스트리&quot;는 업그레이드 헤더 필드에서 프로토콜을 식별하는 데 사용되는 프로토콜 이름 토큰의 네임 스페이스를 정의합니다. 레지스트리는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-upgrade-tokens&quot;&gt;http://www.iana.org/assignments/http-upgrade-tokens&lt;/a&gt; &amp;gt;에 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="dff627671b970f06b09a819242fd5432d30d4c1d" translate="yes" xml:space="preserve">
          <source>The &quot;Hypertext Transfer Protocol (HTTP) Warn Codes&quot; registry defines
   the namespace for warn codes.  It has been created and is now
   maintained at &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes&quot;&gt;http://www.iana.org/assignments/http-warn-codes&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">&quot;HTTP (Hypertext Transfer Protocol) 경고 코드&quot;레지스트리는 경고 코드의 네임 스페이스를 정의합니다. 작성되었으며 현재 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes&quot;&gt;http://www.iana.org/assignments/http-warn-codes&lt;/a&gt; &amp;gt; 에서 유지 보수됩니다 .</target>
        </trans-unit>
        <trans-unit id="ce30eef6a7cd5d843d61361a8fb74fe7770cdcce" translate="yes" xml:space="preserve">
          <source>The &quot;If-Match&quot; header field makes the request method conditional on
   the recipient origin server either having at least one current
   representation of the target resource, when the field-value is &quot;*&quot;,
   or having a current representation of the target resource that has an
   entity-tag matching a member of the list of entity-tags provided in
   the field-value.

   An origin server MUST use the strong comparison function when
   comparing entity-tags for If-Match (&lt;a href=&quot;#section-2.3.2&quot;&gt;Section 2.3.2&lt;/a&gt;), since the client
   intends this precondition to prevent the method from being applied if
   there have been any changes to the representation data.

     If-Match = &quot;*&quot; / 1#entity-tag

   Examples:

     If-Match: &quot;xyzzy&quot;
     If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
     If-Match: *

   If-Match is most often used with state-changing methods (e.g., POST,
   PUT, DELETE) to prevent accidental overwrites when multiple user
   agents might be acting in parallel on the same resource (i.e., to 

   prevent the &quot;lost update&quot; problem).  It can also be used with safe
   methods to abort a request if the selected representation does not
   match one already stored (or partially stored) from a prior request.

   An origin server that receives an If-Match header field MUST evaluate
   the condition prior to performing the method (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  If the
   field-value is &quot;*&quot;, the condition is false if the origin server does
   not have a current representation for the target resource.  If the
   field-value is a list of entity-tags, the condition is false if none
   of the listed tags match the entity-tag of the selected
   representation.

   An origin server MUST NOT perform the requested method if a received
   If-Match condition evaluates to false; instead, the origin server
   MUST respond with either a) the 412 (Precondition Failed) status code
   or b) one of the 2xx (Successful) status codes if the origin server
   has verified that a state change is being requested and the final
   state is already reflected in the current state of the target
   resource (i.e., the change requested by the user agent has already
   succeeded, but the user agent might not be aware of it, perhaps
   because the prior response was lost or a compatible change was made
   by some other user agent).  In the latter case, the origin server
   MUST NOT send a validator header field in the response unless it can
   verify that the request is a duplicate of an immediately prior change
   made by the same user agent.

   The If-Match header field can be ignored by caches and intermediaries
   because it is not applicable to a stored response.</source>
          <target state="translated">&quot;If-Match&quot;헤더 필드는 필드 값이 &quot;*&quot;인 경우 대상 자원의 현재 표현이 하나 이상 있거나 대상 자원의 현재 표현이있는 수신자 원 서버에서 요청 메소드를 조건부로 만듭니다. 필드-값에 제공된 엔티티 태그 목록의 멤버와 일치하는 엔티티 태그가 있습니다. 오리진 서버는 If-Match에 대한 엔티티 태그를 비교할 때 강력한 비교 기능을 사용해야합니다 ( &lt;a href=&quot;#section-2.3.2&quot;&gt;섹션 2.3.2).&lt;/a&gt;), 클라이언트는 표현 데이터에 변경이있는 경우 메소드가 적용되지 않도록이 전제 조건을 의도합니다. If-Match = &quot;*&quot;/ 1 # entity-tag 예 : If-Match : &quot;xyzzy&quot;If-Match : &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;If-Match : * If-Match는 가장 자주 사용됩니다 상태 변경 방법 (예 : POST, PUT, DELETE)은 여러 사용자 에이전트가 동일한 자원에서 병렬로 작동 할 때 우발적 인 덮어 쓰기를 방지합니다 (예 : &quot;손실 된 업데이트&quot;문제 방지). 선택한 표현이 이전 요청에서 이미 저장된 (또는 부분적으로 저장된) 것과 일치하지 않는 경우 요청을 중단하기 위해 안전한 방법과 함께 사용할 수도 있습니다.If-Match 헤더 필드를받는 오리진 서버는 메소드를 수행하기 전에 조건을 평가해야합니다 (&lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt;). 필드 값이 &quot;*&quot;인 경우, 오리진 서버에 대상 자원에 대한 현재 표시가없는 경우 조건은 false입니다. 필드 값이 엔티티 태그 목록 인 경우 나열된 태그 중 선택된 표현의 엔티티 태그와 일치하는 태그가 없으면 조건이 false입니다. 수신 된 If-Match 조건이 false로 평가되면 오리진 서버는 요청 된 메소드를 수행해서는 안됩니다. 대신에, 오리진 서버는 a) 412 (전제 조건 실패) 상태 코드 또는 b) 오리진 서버가 상태 변경이 요청되고 최종 상태가 이미 있음을 확인한 경우 2xx (성공) 상태 코드 중 하나로 응답해야합니다. 대상 리소스의 현재 상태에 반영됩니다 (예 : 사용자 에이전트가 요청한 변경이 이미 성공했습니다.그러나 사전 응답이 유실되었거나 다른 사용자 에이전트가 호환 가능한 변경을 수행했기 때문에 사용자 에이전트가이를 인식하지 못할 수 있습니다. 후자의 경우, 오리진 서버는 요청이 동일한 사용자 에이전트가 수행 한 바로 이전 변경의 복제본임을 확인할 수 없다면 응답에 유효성 검사기 헤더 필드를 보내서는 안됩니다. If-Match 헤더 필드는 저장된 응답에 적용 할 수 없으므로 캐시 및 중개자에 의해 무시 될 수 있습니다.If-Match 헤더 필드는 저장된 응답에 적용 할 수 없으므로 캐시 및 중개자에 의해 무시 될 수 있습니다.If-Match 헤더 필드는 저장된 응답에 적용 할 수 없으므로 캐시 및 중개자에 의해 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a8bdb230b0368d774ef7c392fdbc661a6f47bdb" translate="yes" xml:space="preserve">
          <source>The &quot;If-Modified-Since&quot; header field makes a GET or HEAD request
   method conditional on the selected representation's modification date
   being more recent than the date provided in the field-value.
   Transfer of the selected representation's data is avoided if that
   data has not changed.

     If-Modified-Since = HTTP-date

   An example of the field is:

     If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A recipient MUST ignore If-Modified-Since if the request contains an
   If-None-Match header field; the condition in If-None-Match is
   considered to be a more accurate replacement for the condition in
   If-Modified-Since, and the two are only combined for the sake of
   interoperating with older intermediaries that might not implement
   If-None-Match.

   A recipient MUST ignore the If-Modified-Since header field if the
   received field-value is not a valid HTTP-date, or if the request
   method is neither GET nor HEAD.

   A recipient MUST interpret an If-Modified-Since field-value's
   timestamp in terms of the origin server's clock.

   If-Modified-Since is typically used for two distinct purposes: 1) to
   allow efficient updates of a cached representation that does not have
   an entity-tag and 2) to limit the scope of a web traversal to
   resources that have recently changed.

   When used for cache updates, a cache will typically use the value of
   the cached message's Last-Modified field to generate the field value
   of If-Modified-Since.  This behavior is most interoperable for cases
   where clocks are poorly synchronized or when the server has chosen to
   only honor exact timestamp matches (due to a problem with
   Last-Modified dates that appear to go &quot;back in time&quot; when the origin
   server's clock is corrected or a representation is restored from an
   archived backup).  However, caches occasionally generate the field
   value based on other data, such as the Date header field of the
   cached message or the local clock time that the message was received,
   particularly when the cached message does not contain a Last-Modified
   field. 

   When used for limiting the scope of retrieval to a recent time
   window, a user agent will generate an If-Modified-Since field value
   based on either its own local clock or a Date header field received
   from the server in a prior response.  Origin servers that choose an
   exact timestamp match based on the selected representation's
   Last-Modified field will not be able to help the user agent limit its
   data transfers to only those changed during the specified window.

   An origin server that receives an If-Modified-Since header field
   SHOULD evaluate the condition prior to performing the method
   (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  The origin server SHOULD NOT perform the requested
   method if the selected representation's last modification date is
   earlier than or equal to the date provided in the field-value;
   instead, the origin server SHOULD generate a 304 (Not Modified)
   response, including only those metadata that are useful for
   identifying or updating a previously cached response.

   Requirements on cache handling of a received If-Modified-Since header
   field are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">&quot;If-Modified-Since&quot;헤더 필드는 선택된 표현의 수정 날짜에 대한 GET 또는 HEAD 요청 방법을 필드 값에 제공된 날짜보다 최신 상태로 만듭니다. 데이터가 변경되지 않은 경우 선택한 표현의 데이터 전송을 피할 수 있습니다. If-Modified-Since = HTTP-date 필드의 예는 다음과 같습니다. If-Modified-Since : 토요일, 1994 년 10 월 29 일 19:43:31 GMT 수신자는 요청에 If-None이 포함 된 경우 If-Modified-Since를 무시해야합니다. 일치하는 헤더 필드; If-None-Match의 조건은 If-Modified-Since의 조건을 더 정확하게 대체하는 것으로 간주되며,이 둘은 If-None-Match를 구현하지 않을 수있는 구형 중개자와의 상호 운용을 위해 결합됩니다.수신 된 필드 값이 유효한 HTTP 날짜가 아니거나 요청 방법이 GET도 HEAD도 아닌 경우 수신자는 반드시 If-Modified-Since 헤더 필드를 무시해야합니다. 수신자는 If-Modified-Since 필드-값의 타임 스탬프를 오리진 서버의 시계로 해석해야합니다. If-Modified-Since는 일반적으로 다음 두 가지 목적으로 사용됩니다. 1) 엔티티 태그가없는 캐시 된 표현의 효율적인 업데이트 허용 및 2) 웹 탐색 범위를 최근에 변경된 자원으로 제한합니다. 캐시 업데이트에 사용될 때 캐시는 일반적으로 캐시 된 메시지의 Last-Modified 필드 값을 사용하여 If-Modified-Since의 필드 값을 생성합니다.이 동작은 시계가 제대로 동기화되지 않거나 서버가 정확한 타임 스탬프 일치 만 준수하도록 선택한 경우 (원래 서버의 시계가 수정 될 때 &quot;시간이 지남&quot;으로 보이는 마지막 수정 날짜의 문제로 인해) 가장 상호 운용성이 있습니다. 또는 아카이브 된 백업에서 표현이 복원됩니다). 그러나 캐시는 캐시 된 메시지의 날짜 헤더 필드 또는 메시지가 수신 된 로컬 클록 시간과 같은 다른 데이터, 특히 캐시 된 메시지에 Last-Modified 필드가없는 경우에 따라 필드 값을 생성하는 경우가 있습니다. 검색 범위를 최근 시간 창으로 제한하는 데 사용되는 경우,사용자 에이전트는 자신의 로컬 시계 또는 이전 응답으로 서버에서 수신 한 날짜 헤더 필드를 기반으로 If-Modified-Since 필드 값을 생성합니다. 선택한 표현의 Last-Modified 필드를 기반으로 정확한 타임 스탬프 일치를 선택하는 오리진 서버는 사용자 에이전트가 데이터 전송을 지정된 창에서 변경된 것만으로 제한 할 수 없습니다. If-Modified-Since 헤더 필드를 수신 한 오리진 서버는 방법을 수행하기 전에 조건을 평가해야한다 (SHOULD).If-Modified-Since 헤더 필드를 수신 한 오리진 서버는 방법을 수행하기 전에 조건을 평가해야한다 (SHOULD).If-Modified-Since 헤더 필드를 수신 한 오리진 서버는 방법을 수행하기 전에 조건을 평가해야한다 (SHOULD).&lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt; ). 선택된 표현의 최종 수정 날짜가 필드-값에 제공된 날짜보다 빠르거나 같으면, 원 서버는 요청 된 방법을 수행해서는 안된다; 대신에, 오리진 서버는 이전에 캐시 된 응답을 식별하거나 업데이트하는데 유용한 메타 데이터만을 포함하여 304 (수정되지 않음) 응답을 생성해야한다 (SHOULD). 수신 된 If-Modified-Since 헤더 필드의 캐시 처리에 대한 요구 사항 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;은 [RFC7234]의 섹션 4.3.2에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a0c758120c2ca9721b5496606fe6d4cf8c40d68" translate="yes" xml:space="preserve">
          <source>The &quot;If-None-Match&quot; header field makes the request method conditional
   on a recipient cache or origin server either not having any current
   representation of the target resource, when the field-value is &quot;*&quot;,
   or having a selected representation with an entity-tag that does not
   match any of those listed in the field-value.

   A recipient MUST use the weak comparison function when comparing
   entity-tags for If-None-Match (&lt;a href=&quot;#section-2.3.2&quot;&gt;Section 2.3.2&lt;/a&gt;), since weak entity-tags
   can be used for cache validation even if there have been changes to
   the representation data.

     If-None-Match = &quot;*&quot; / 1#entity-tag 

   Examples:

     If-None-Match: &quot;xyzzy&quot;
     If-None-Match: W/&quot;xyzzy&quot;
     If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
     If-None-Match: W/&quot;xyzzy&quot;, W/&quot;r2d2xxxx&quot;, W/&quot;c3piozzzz&quot;
     If-None-Match: *

   If-None-Match is primarily used in conditional GET requests to enable
   efficient updates of cached information with a minimum amount of
   transaction overhead.  When a client desires to update one or more
   stored responses that have entity-tags, the client SHOULD generate an
   If-None-Match header field containing a list of those entity-tags
   when making a GET request; this allows recipient servers to send a
   304 (Not Modified) response to indicate when one of those stored
   responses matches the selected representation.

   If-None-Match can also be used with a value of &quot;*&quot; to prevent an
   unsafe request method (e.g., PUT) from inadvertently modifying an
   existing representation of the target resource when the client
   believes that the resource does not have a current representation
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7231]&lt;/a&gt;).  This is a variation on the &quot;lost
   update&quot; problem that might arise if more than one client attempts to
   create an initial representation for the target resource.

   An origin server that receives an If-None-Match header field MUST
   evaluate the condition prior to performing the method (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).
   If the field-value is &quot;*&quot;, the condition is false if the origin
   server has a current representation for the target resource.  If the
   field-value is a list of entity-tags, the condition is false if one
   of the listed tags match the entity-tag of the selected
   representation.

   An origin server MUST NOT perform the requested method if the
   condition evaluates to false; instead, the origin server MUST respond
   with either a) the 304 (Not Modified) status code if the request
   method is GET or HEAD or b) the 412 (Precondition Failed) status code
   for all other request methods.

   Requirements on cache handling of a received If-None-Match header
   field are defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">&quot;If-None-Match&quot;헤더 필드는 필드 값이 &quot;*&quot;인 경우 대상 자원의 현재 표현이 없거나받는 사람 캐시 또는 오리진 서버에서 요청 메소드를 조건부로 만듭니다. 필드 값에 나열된 항목 태그와 일치하지 않는 항목 태그입니다. 수신자는 If-None-Match에 대한 엔티티 태그를 비교할 때 약한 비교 기능을 사용해야합니다 ( &lt;a href=&quot;#section-2.3.2&quot;&gt;섹션 2.3.2).&lt;/a&gt;), 표현 데이터가 변경된 경우에도 약한 엔티티 태그를 캐시 유효성 검증에 사용할 수 있습니다. If-None-Match = &quot;*&quot;/ 1 # entity-tag 예 : If-None-Match : &quot;xyzzy&quot;If-None-Match : W / &quot;xyzzy&quot;If-None-Match : &quot;xyzzy&quot;, &quot;r2d2xxxx&quot; , &quot;c3piozzzz&quot;If-None-Match : W / &quot;xyzzy&quot;, W / &quot;r2d2xxxx&quot;, W / &quot;c3piozzzz&quot;If-None-Match : * If-None-Match는 주로 효율적인 업데이트를 위해 조건부 GET 요청에 사용됩니다. 최소한의 트랜잭션 오버 헤드로 캐시 된 정보 클라이언트가 엔티티 태그가있는 하나 이상의 저장된 응답을 업데이트하고자 할 때, 클라이언트는 GET 요청을 할 때 해당 엔티티 태그 목록을 포함하는 If-None-Match 헤더 필드를 생성해야합니다.이를 통해 수신자 서버는 304 (수정되지 않음) 응답을 보내 저장된 응답 중 하나가 선택된 표현과 일치하는시기를 표시 할 수 있습니다. If-None-Match를 &quot;*&quot;값과 함께 사용하여 클라이언트가 리소스에 현재 표현이 없다고 판단 될 때 안전하지 않은 요청 방법 (예 : PUT)이 대상 리소스의 기존 표현을 실수로 수정하지 못하게 할 수 있습니다. (클라이언트가 자원에 현재 표현이 없다고 판단 될 때 대상 자원의 기존 표현을 실수로 수정하지 않음클라이언트가 자원에 현재 표현이 없다고 판단 될 때 대상 자원의 기존 표현을 실수로 수정하지 않음&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;[RFC7231]의 섹션 4.2.1&lt;/a&gt; ). 이는 둘 이상의 클라이언트가 대상 자원에 대한 초기 표현을 작성하려고 시도 할 때 발생할 수있는 &quot;업데이트 손실&quot;문제의 변형입니다. If-None-Match 헤더 필드를받는 오리진 서버는 메소드를 수행하기 전에 조건을 평가해야합니다 ( &lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt;). 필드 값이 &quot;*&quot;인 경우, 오리진 서버에 대상 자원에 대한 현재 표시가 있으면 조건이 false입니다. 필드-값이 엔티티 태그 목록 인 경우, 나열된 태그 중 하나가 선택한 표현의 엔티티 태그와 일치하면 조건이 false입니다. 조건이 거짓으로 평가되면, 원 서버는 요청 된 방법을 수행해서는 안된다; 대신에, 오리진 서버는 a) 요청 방법이 GET 또는 HEAD 인 경우 304 (수정되지 않음) 상태 코드 또는 b) 다른 모든 요청 방법에 대한 412 (전제 조건 실패) 상태 코드로 응답해야합니다. 수신 된 If-None-Match 헤더 필드의 캐시 처리에 대한 요구 사항 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.2&quot;&gt;은 [RFC7234] 4.3.2 절에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9010727bf44de6e918d999396395dcc003b1b98" translate="yes" xml:space="preserve">
          <source>The &quot;If-Range&quot; header field provides a special conditional request
   mechanism that is similar to the If-Match and If-Unmodified-Since
   header fields but that instructs the recipient to ignore the Range
   header field if the validator doesn't match, resulting in transfer of
   the new selected representation instead of a 412 (Precondition
   Failed) response.  If-Range is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7233]&lt;/a&gt;.</source>
          <target state="translated">&quot;If-Range&quot;헤더 필드는 If-Match 및 If-Unmodified-Since 헤더 필드와 유사한 특수 조건부 요청 메커니즘을 제공하지만 유효성 검사기가 일치하지 않으면 수신자가 Range 헤더 필드를 무시하도록 지시합니다. 412 (사전 조건 실패) 응답 대신 새로 선택한 표현을 전송합니다. If-Range는 &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;[RFC7233]의 섹션 3.2에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8425f95c9971ed97dd968bffd651d8482f2d923d" translate="yes" xml:space="preserve">
          <source>The &quot;If-Unmodified-Since&quot; header field makes the request method
   conditional on the selected representation's last modification date
   being earlier than or equal to the date provided in the field-value.
   This field accomplishes the same purpose as If-Match for cases where
   the user agent does not have an entity-tag for the representation.

     If-Unmodified-Since = HTTP-date

   An example of the field is:

     If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A recipient MUST ignore If-Unmodified-Since if the request contains
   an If-Match header field; the condition in If-Match is considered to
   be a more accurate replacement for the condition in
   If-Unmodified-Since, and the two are only combined for the sake of
   interoperating with older intermediaries that might not implement
   If-Match.

   A recipient MUST ignore the If-Unmodified-Since header field if the
   received field-value is not a valid HTTP-date.

   A recipient MUST interpret an If-Unmodified-Since field-value's
   timestamp in terms of the origin server's clock. 

   If-Unmodified-Since is most often used with state-changing methods
   (e.g., POST, PUT, DELETE) to prevent accidental overwrites when
   multiple user agents might be acting in parallel on a resource that
   does not supply entity-tags with its representations (i.e., to
   prevent the &quot;lost update&quot; problem).  It can also be used with safe
   methods to abort a request if the selected representation does not
   match one already stored (or partially stored) from a prior request.

   An origin server that receives an If-Unmodified-Since header field
   MUST evaluate the condition prior to performing the method
   (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;).  The origin server MUST NOT perform the requested method
   if the selected representation's last modification date is more
   recent than the date provided in the field-value; instead the origin
   server MUST respond with either a) the 412 (Precondition Failed)
   status code or b) one of the 2xx (Successful) status codes if the
   origin server has verified that a state change is being requested and
   the final state is already reflected in the current state of the
   target resource (i.e., the change requested by the user agent has
   already succeeded, but the user agent might not be aware of that
   because the prior response message was lost or a compatible change
   was made by some other user agent).  In the latter case, the origin
   server MUST NOT send a validator header field in the response unless
   it can verify that the request is a duplicate of an immediately prior
   change made by the same user agent.

   The If-Unmodified-Since header field can be ignored by caches and
   intermediaries because it is not applicable to a stored response.</source>
          <target state="translated">&quot;If-Unmodified-Since&quot;헤더 필드는 선택된 표현의 마지막 수정 날짜에 대한 요청 방법을 필드 값에 제공된 날짜보다 빠르거나 같게 만듭니다. 이 필드는 사용자 에이전트에 표시 할 엔티티 태그가없는 경우 If-Match와 동일한 목적을 달성합니다. If-Unmodified-Since = HTTP-date 필드의 예는 다음과 같습니다. If-Unmodified-Since : Sat, 1994 년 10 월 29 일 19:43:31 GMT 수신자는 요청에 If-Match가 포함 된 경우 If-Unmodified-Since를 무시해야합니다. 헤더 필드; If-Match의 조건은 If-Unmodified-Since의 조건을 더 정확하게 대체하는 것으로 간주되며,이 둘은 If-Match를 구현하지 않을 수있는 구 중개자와의 상호 운용을 위해서만 결합됩니다.수신 된 필드 값이 유효한 HTTP 날짜가 아닌 경우 수신자는 반드시 If-Unmodified-Since 헤더 필드를 무시해야합니다. 수신자는 반드시 If-Unmodified-Since 필드-값의 타임 스탬프를 오리진 서버의 시계로 해석해야합니다. If-Unmodified-Since는 상태 변경 방법 (예 : POST, PUT, DELETE)과 함께 여러 사용자 에이전트가 엔티티 태그에 해당 표현을 제공하지 않는 자원에 대해 병렬로 작동 할 때 우발적 인 덮어 쓰기를 방지하기 위해 가장 자주 사용됩니다 ( 즉, &quot;손실 된 업데이트&quot;문제를 방지하기 위해). 선택한 표현이 이전 요청에서 이미 저장된 (또는 부분적으로 저장된) 것과 일치하지 않는 경우 요청을 중단하기 위해 안전한 방법과 함께 사용할 수도 있습니다.If-Unmodified-Since 헤더 필드를받는 오리진 서버는 메소드를 수행하기 전에 조건을 평가해야합니다 (&lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt;). 선택된 표현의 마지막 수정 날짜가 필드-값에 제공된 날짜보다 최신 인 경우, 원 서버는 요청 된 방법을 수행해서는 안된다; 대신 오리진 서버는 a) 412 (사전 조건 실패) 상태 코드 또는 b) 오리진 서버가 상태 변경이 요청되고 최종 상태가 이미 반영되었음을 확인한 경우 2xx (성공) 상태 코드 중 하나로 응답해야합니다. 대상 자원의 현재 상태 (예 : 사용자 에이전트가 요청한 변경이 이미 성공했지만 사용자 에이전트는 이전 응답 메시지가 유실되었거나 일부 다른 사용자 에이전트가 호환 가능한 변경을했기 때문에이를 인식하지 못할 수 있음) ). 후자의 경우,오리진 서버는 요청이 동일한 사용자 에이전트가 변경 한 바로 이전의 복제본임을 확인할 수 없으면 응답에 유효성 검증기 헤더 필드를 보내서는 안됩니다. If-Unmodified-Since 헤더 필드는 저장된 응답에 적용 할 수 없으므로 캐시 및 중개자에 의해 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bcbe36b4b07ea53d8dfd522bedc5b18d8069ffd" translate="yes" xml:space="preserve">
          <source>The &quot;Last-Modified&quot; header field in a response provides a timestamp
   indicating the date and time at which the origin server believes the
   selected representation was last modified, as determined at the
   conclusion of handling the request.

     Last-Modified = HTTP-date

   An example of its use is

     Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT</source>
          <target state="translated">응답의 &quot;마지막 수정&quot;헤더 필드는 요청을 처리 한 결론에 따라 원본 서버가 선택된 표현이 마지막으로 수정되었다고 생각한 날짜 및 시간을 나타내는 타임 스탬프를 제공합니다. Last-Modified = HTTP-date 사용 예는 Last-Modified : Tue, 1994 년 11 월 15 일 12:45:26 GMT</target>
        </trans-unit>
        <trans-unit id="a6eb1d27a3336049ef780463edbd186c94593ceb" translate="yes" xml:space="preserve">
          <source>The &quot;Location&quot; header field is used in some responses to refer to a
   specific resource in relation to the response.  The type of
   relationship is defined by the combination of request method and
   status code semantics.

     Location = URI-reference

   The field value consists of a single URI-reference.  When it has the
   form of a relative reference (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986], Section&amp;nbsp;4.2&lt;/a&gt;), the final
   value is computed by resolving it against the effective request URI
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;[RFC3986], Section&amp;nbsp;5&lt;/a&gt;).

   For 201 (Created) responses, the Location value refers to the primary
   resource created by the request.  For 3xx (Redirection) responses,
   the Location value refers to the preferred target resource for
   automatically redirecting the request.

   If the Location value provided in a 3xx (Redirection) response does
   not have a fragment component, a user agent MUST process the
   redirection as if the value inherits the fragment component of the
   URI reference used to generate the request target (i.e., the
   redirection inherits the original reference's fragment, if any).

   For example, a GET request generated for the URI reference
   &quot;http://www.example.org/~tim&quot; might result in a 303 (See Other)
   response containing the header field:

     Location: /People.html#tim

   which suggests that the user agent redirect to
   &quot;http://www.example.org/People.html#tim&quot; 

   Likewise, a GET request generated for the URI reference
   &quot;http://www.example.org/index.html#larry&quot; might result in a 301
   (Moved Permanently) response containing the header field:

     Location: http://www.example.net/index.html

   which suggests that the user agent redirect to
   &quot;http://www.example.net/index.html#larry&quot;, preserving the original
   fragment identifier.

   There are circumstances in which a fragment identifier in a Location
   value would not be appropriate.  For example, the Location header
   field in a 201 (Created) response is supposed to provide a URI that
   is specific to the created resource.

      Note: Some recipients attempt to recover from Location fields that
      are not valid URI references.  This specification does not mandate
      or define such processing, but does allow it for the sake of
      robustness.

      Note: The Content-Location header field (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;) differs
      from Location in that the Content-Location refers to the most
      specific resource corresponding to the enclosed representation.
      It is therefore possible for a response to contain both the
      Location and Content-Location header fields.</source>
          <target state="translated">&quot;위치&quot;헤더 필드는 응답과 관련하여 특정 자원을 참조하기 위해 일부 응답에서 사용됩니다. 관계 유형은 요청 방법과 상태 코드 의미의 조합으로 정의됩니다. Location = URI-reference 필드 값은 단일 URI 참조로 구성됩니다. 상대 참조 형식 인 경우 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986], 섹션 4.2&lt;/a&gt; ), 최종 값은 유효 요청 URI ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;[RFC3986], 섹션 5)에&lt;/a&gt; 대해이를 해결하여 계산됩니다.). 201 (작성 됨) 응답의 경우 위치 값은 요청으로 작성된 1 차 자원을 나타냅니다. 3xx (리디렉션) 응답의 경우 Location 값은 요청을 자동으로 리디렉션하기위한 기본 대상 리소스를 나타냅니다. 3xx (리디렉션) 응답으로 제공된 Location 값에 프래그먼트 컴포넌트가없는 경우, 사용자 에이전트는 값이 요청 대상을 생성하는 데 사용 된 URI 참조의 프래그먼트 컴포넌트를 상속하는 것처럼 리디렉션을 처리해야합니다. 원래 참조의 조각 (있는 경우). 예를 들어, URI 참조 &quot;http://www.example.org/~tim&quot;에 대해 생성 된 GET 요청은 헤더 필드 Location : / People을 포함하는 303 (기타 참조) 응답을 초래할 수 있습니다.html # tim은 사용자 에이전트가 &quot;http://www.example.org/People.html#tim&quot;으로 리디렉션하도록 제안합니다. 마찬가지로 URI 참조 &quot;http://www.example.org/index에 대해 GET 요청이 생성됩니다. .html # larry &quot;는 헤더 필드 Location : http://www.example.net/index.html을 포함하는 301 (영구적으로 이동) 응답으로 사용자 에이전트가&quot;http : // www. example.net/index.html#larry &quot;(원래 조각 식별자 유지) Location 값의 조각 식별자가 적절하지 않은 상황이 있습니다. 예를 들어, 201 (작성 됨) 응답의 위치 헤더 필드는 작성된 자원에 고유 한 URI를 제공해야합니다. 노트 :일부 수신자는 유효한 URI 참조가 아닌 위치 필드에서 복구를 시도합니다. 이 사양은 그러한 처리를 요구하거나 정의하지는 않지만 견고성을 위해 허용합니다. 참고 : Content-Location 헤더 필드 (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;섹션 3.1.4.2&lt;/a&gt; )는 Content-Location이 동봉 된 표현에 해당하는 가장 구체적인 리소스를 참조한다는 점에서 Location과 다릅니다. 따라서 응답에 Location 및 Content-Location 헤더 필드가 모두 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74bdc0b34c81dec67352f90c99efe73d9563e534" translate="yes" xml:space="preserve">
          <source>The &quot;Max-Forwards&quot; header field provides a mechanism with the TRACE
   (&lt;a href=&quot;#section-4.3.8&quot;&gt;Section 4.3.8&lt;/a&gt;) and OPTIONS (&lt;a href=&quot;#section-4.3.7&quot;&gt;Section 4.3.7&lt;/a&gt;) request methods to limit
   the number of times that the request is forwarded by proxies.  This
   can be useful when the client is attempting to trace a request that
   appears to be failing or looping mid-chain.

     Max-Forwards = 1*DIGIT

   The Max-Forwards value is a decimal integer indicating the remaining
   number of times this request message can be forwarded.

   Each intermediary that receives a TRACE or OPTIONS request containing
   a Max-Forwards header field MUST check and update its value prior to
   forwarding the request.  If the received value is zero (0), the
   intermediary MUST NOT forward the request; instead, the intermediary
   MUST respond as the final recipient.  If the received Max-Forwards
   value is greater than zero, the intermediary MUST generate an updated
   Max-Forwards field in the forwarded message with a field-value that
   is the lesser of a) the received value decremented by one (1) or b)
   the recipient's maximum supported value for Max-Forwards.

   A recipient MAY ignore a Max-Forwards header field received with any
   other request methods.</source>
          <target state="translated">&quot;Max-Forwards&quot;헤더 필드는 TRACE ( &lt;a href=&quot;#section-4.3.8&quot;&gt;섹션 4.3.8&lt;/a&gt; ) 및 OPTIONS ( &lt;a href=&quot;#section-4.3.7&quot;&gt;섹션 4.3.7&lt;/a&gt; )와 함께 메커니즘을 제공합니다.) 요청 메소드가 프록시가 요청을 전달하는 횟수를 제한합니다. 클라이언트가 실패하거나 중간 체인을 루핑하는 것처럼 보이는 요청을 추적하려고 할 때 유용 할 수 있습니다. Max-Forwards = 1 * DIGIT Max-Forwards 값은이 요청 메시지를 전달할 수있는 남은 횟수를 나타내는 십진 정수입니다. Max-Forwards 헤더 필드를 포함하는 TRACE 또는 OPTIONS 요청을 수신하는 각 중개자는 요청을 전달하기 전에 해당 값을 확인하고 업데이트해야합니다. 수신 된 값이 영 (0)이면 중개자는 요청을 전달해서는 안됩니다. 대신 중개자는 반드시 최종 수령인으로 응답해야합니다. 수신 된 Max-Forwards 값이 0보다 큰 경우중개자는 전달 된 메시지에 업데이트 된 Max-Forwards 필드를 생성해야합니다. 수신자는 다른 요청 방법으로받은 Max-Forwards 헤더 필드를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62a3d127d32e2961eab7613512f025a99727d041" translate="yes" xml:space="preserve">
          <source>The &quot;Message Headers&quot; registry has been updated with the following
   permanent registrations:

   +-------------------+----------+----------+-----------------+
   | Header Field Name | Protocol | Status   | Reference       |
   +-------------------+----------+----------+-----------------+
   | Accept            | http     | standard | &lt;a href=&quot;#section-5.3.2&quot;&gt;Section 5.3.2&lt;/a&gt;   |
   | Accept-Charset    | http     | standard | &lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt;   |
   | Accept-Encoding   | http     | standard | &lt;a href=&quot;#section-5.3.4&quot;&gt;Section 5.3.4&lt;/a&gt;   |
   | Accept-Language   | http     | standard | &lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt;   |
   | Allow             | http     | standard | &lt;a href=&quot;#section-7.4.1&quot;&gt;Section 7.4.1&lt;/a&gt;   |
   | Content-Encoding  | http     | standard | &lt;a href=&quot;#section-3.1.2.2&quot;&gt;Section 3.1.2.2&lt;/a&gt; |
   | Content-Language  | http     | standard | &lt;a href=&quot;#section-3.1.3.2&quot;&gt;Section 3.1.3.2&lt;/a&gt; |
   | Content-Location  | http     | standard | &lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt; |
   | Content-Type      | http     | standard | &lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt; |
   | Date              | http     | standard | &lt;a href=&quot;#section-7.1.1.2&quot;&gt;Section 7.1.1.2&lt;/a&gt; |
   | Expect            | http     | standard | &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;   |
   | From              | http     | standard | &lt;a href=&quot;#section-5.5.1&quot;&gt;Section 5.5.1&lt;/a&gt;   |
   | Location          | http     | standard | &lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;   |
   | Max-Forwards      | http     | standard | &lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;   |
   | MIME-Version      | http     | standard | &lt;a href=&quot;#appendix-A.1&quot;&gt;Appendix A.1&lt;/a&gt;    |
   | Referer           | http     | standard | &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt;   |
   | Retry-After       | http     | standard | &lt;a href=&quot;#section-7.1.3&quot;&gt;Section 7.1.3&lt;/a&gt;   |
   | Server            | http     | standard | &lt;a href=&quot;#section-7.4.2&quot;&gt;Section 7.4.2&lt;/a&gt;   |
   | User-Agent        | http     | standard | &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt;   |
   | Vary              | http     | standard | &lt;a href=&quot;#section-7.1.4&quot;&gt;Section 7.1.4&lt;/a&gt;   |
   +-------------------+----------+----------+-----------------+

   The change controller for the above registrations is: &quot;IETF
   (iesg@ietf.org) - Internet Engineering Task Force&quot;.</source>
          <target state="translated">&quot;메시지 헤더&quot;레지스트리가 다음과 같은 영구 등록으로 업데이트되었습니다. + ------------------- + ---------- + --- ------- + ----------------- + | 헤더 필드 이름 | 프로토콜 | 상태 | 참조 | + ------------------- + ---------- + ---------- + ------- ---------- + | 수락 | http | 표준 | &lt;a href=&quot;#section-5.3.2&quot;&gt;섹션 5.3.2&lt;/a&gt; | | 수락 문자 | http | 표준 | &lt;a href=&quot;#section-5.3.3&quot;&gt;섹션 5.3.3&lt;/a&gt; | | 수락 인코딩 | http | 표준 | &lt;a href=&quot;#section-5.3.4&quot;&gt;섹션 5.3.4&lt;/a&gt; | | 수락 언어 | http | 표준 | &lt;a href=&quot;#section-5.3.5&quot;&gt;섹션 5.3.5&lt;/a&gt; | | 허용 | http | 표준 | &lt;a href=&quot;#section-7.4.1&quot;&gt;섹션 7.4.1&lt;/a&gt; | | 콘텐츠 인코딩 | http | 표준 | &lt;a href=&quot;#section-3.1.2.2&quot;&gt;3.1.2.2 항&lt;/a&gt;| | 콘텐츠 언어 | http | 표준 | &lt;a href=&quot;#section-3.1.3.2&quot;&gt;3.1.3.2 절&lt;/a&gt; | | 컨텐츠 위치 | http | 표준 | &lt;a href=&quot;#section-3.1.4.2&quot;&gt;섹션 3.1.4.2&lt;/a&gt; | | 컨텐츠 유형 | http | 표준 | &lt;a href=&quot;#section-3.1.1.5&quot;&gt;3.1.1.5 절&lt;/a&gt; | | 날짜 | http | 표준 | &lt;a href=&quot;#section-7.1.1.2&quot;&gt;7.1.1.2 절&lt;/a&gt; | | 기대 | http | 표준 | &lt;a href=&quot;#section-5.1.1&quot;&gt;섹션 5.1.1&lt;/a&gt; | | 보낸 사람 | http | 표준 | &lt;a href=&quot;#section-5.5.1&quot;&gt;섹션 5.5.1&lt;/a&gt; | | 위치 | http | 표준 | &lt;a href=&quot;#section-7.1.2&quot;&gt;섹션 7.1.2&lt;/a&gt; | | 맥스 포워드 | http | 표준 | &lt;a href=&quot;#section-5.1.2&quot;&gt;섹션 5.1.2&lt;/a&gt; | | MIME 버전 | http | 표준 | &lt;a href=&quot;#appendix-A.1&quot;&gt;부록 A.1&lt;/a&gt; | | 리퍼러 | http | 표준 | &lt;a href=&quot;#section-5.5.2&quot;&gt;섹션 5.5.2&lt;/a&gt; | | 재시도 후 | http | 표준 | &lt;a href=&quot;#section-7.1.3&quot;&gt;섹션 7.1.3&lt;/a&gt; | | 서버 | http | 표준 | &lt;a href=&quot;#section-7.4.2&quot;&gt;7.4.2 절&lt;/a&gt; | | 사용자 에이전트 | http | 표준 | &lt;a href=&quot;#section-5.5.3&quot;&gt;섹션 5.5.3&lt;/a&gt; | | 다름 | http | 표준 | &lt;a href=&quot;#section-7.1.4&quot;&gt;섹션 7.1.4&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ---------- + 위 등록에 대한 변경 컨트롤러는 &quot;IETF (iesg@ietf.org)-인터넷 엔지니어링 태스크 포스&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="17017ddede4b2983af658e0ef12536aeaa0acb5a" translate="yes" xml:space="preserve">
          <source>The &quot;Pragma&quot; header field allows backwards compatibility with
   HTTP/1.0 caches, so that clients can specify a &quot;no-cache&quot; request
   that they will understand (as Cache-Control was not defined until
   HTTP/1.1).  When the Cache-Control header field is also present and
   understood in a request, Pragma is ignored.

   In HTTP/1.0, Pragma was defined as an extensible field for
   implementation-specified directives for recipients.  This
   specification deprecates such extensions to improve interoperability.

     Pragma           = 1#pragma-directive
     pragma-directive = &quot;no-cache&quot; / extension-pragma
     extension-pragma = token [ &quot;=&quot; ( token / quoted-string ) ]

   When the Cache-Control header field is not present in a request,
   caches MUST consider the no-cache request pragma-directive as having
   the same effect as if &quot;Cache-Control: no-cache&quot; were present (see
   &lt;a href=&quot;#section-5.2.1&quot;&gt;Section 5.2.1&lt;/a&gt;).

   When sending a no-cache request, a client ought to include both the
   pragma and cache-control directives, unless Cache-Control: no-cache
   is purposefully omitted to target other Cache-Control response
   directives at HTTP/1.1 caches.  For example:

     GET / HTTP/1.1
     Host: www.example.com
     Cache-Control: max-age=30
     Pragma: no-cache

   will constrain HTTP/1.1 caches to serve a response no older than 30
   seconds, while precluding implementations that do not understand
   Cache-Control from serving a cached response.

      Note: Because the meaning of &quot;Pragma: no-cache&quot; in responses is
      not specified, it does not provide a reliable replacement for
      &quot;Cache-Control: no-cache&quot; in them.</source>
          <target state="translated">&quot;Pragma&quot;헤더 필드는 HTTP / 1.0 캐시와의 역 호환성을 허용하므로 클라이언트는 이해할 수있는 &quot;캐시 없음&quot;요청을 지정할 수 있습니다 (Cache-Control이 HTTP / 1.1까지 정의되지 않았기 때문에). Cache-Control 헤더 필드가 존재하고 요청에 이해되면 Pragma는 무시됩니다. HTTP / 1.0에서 Pragma는 수신자에 대한 구현 지정 지시문의 확장 가능한 필드로 정의되었습니다. 이 사양에서는 상호 운용성을 향상시키기 위해 이러한 확장을 사용하지 않습니다. Pragma = 1 # pragma-directive pragma-directive = &quot;no-cache&quot;/ extension-pragma extension-pragma = token [ &quot;=&quot;(token / quoted-string)] 요청에 Cache-Control 헤더 필드가없는 경우 ,캐시는 &quot;캐시 제어 : no-cache&quot;가 존재하는 것과 동일한 효과를 갖는 것으로 캐시없는 요청 pragma-directive를 고려해야합니다 (참조 &lt;a href=&quot;#section-5.2.1&quot;&gt;섹션 5.2.1&lt;/a&gt; ). 캐시없는 요청을 보낼 때, Cache-Control : no-cache가 HTTP / 1.1 캐시에서 다른 Cache-Control 응답 지시문을 대상으로하기 위해 의도적으로 생략되지 않는 한 클라이언트는 pragma 및 cache-control 지시문을 모두 포함해야합니다. 예 : GET / HTTP / 1.1 호스트 : www.example.com Cache-Control : max-age = 30 Pragma : no-cache는 HTTP / 1.1 캐시가 30 초 이하의 응답을 제공하도록 제한하고, 그렇지 않은 구현은 제외합니다. Cache-Control이 캐시 된 응답을 제공하는 것을 이해하지 못합니다. 참고 : 응답에서 &quot;Pragma : no-cache&quot;의 의미가 지정되어 있지 않기 때문에 &quot;Cache-Control : no-cache&quot;를 안정적으로 대체 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="056fcf2a31c44d11769adceb052cd538bdba3b52" translate="yes" xml:space="preserve">
          <source>The &quot;Proxy-Authenticate&quot; header field consists of at least one
   challenge that indicates the authentication scheme(s) and parameters
   applicable to the proxy for this effective request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5
   of [RFC7230]&lt;/a&gt;).  A proxy MUST send at least one Proxy-Authenticate
   header field in each 407 (Proxy Authentication Required) response
   that it generates.

     Proxy-Authenticate = 1#challenge

   Unlike WWW-Authenticate, the Proxy-Authenticate header field applies
   only to the next outbound client on the response chain.  This is
   because only the client that chose a given proxy is likely to have
   the credentials necessary for authentication.  However, when multiple
   proxies are used within the same administrative domain, such as
   office and regional caching proxies within a large corporate network,
   it is common for credentials to be generated by the user agent and
   passed through the hierarchy until consumed.  Hence, in such a
   configuration, it will appear as if Proxy-Authenticate is being
   forwarded because each proxy will send the same challenge set.

   Note that the parsing considerations for WWW-Authenticate apply to
   this header field as well; see &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; for details.</source>
          <target state="translated">&quot;프록시 인증&quot;헤더 필드는이 유효 요청 URI에 대한 프록시에 적용 할 수있는 인증 체계 및 매개 변수를 나타내는 하나 이상의 시도로 구성됩니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]의 섹션 5.5&lt;/a&gt;). 프록시는 생성하는 각 407 (프록시 인증 필요) 응답에서 하나 이상의 프록시 인증 헤더 필드를 보내야합니다. Proxy-Authenticate = 1 # challenge WWW-Authenticate와 달리 Proxy-Authenticate 헤더 필드는 응답 체인의 다음 아웃 바운드 클라이언트에만 적용됩니다. 지정된 프록시를 선택한 클라이언트 만 인증에 필요한 자격 증명을 가지고 있기 때문입니다. 그러나 대기업 네트워크 내의 사무실 및 지역 캐싱 프록시와 같은 동일한 관리 도메인 내에서 여러 프록시를 사용하는 경우 사용자 에이전트가 자격 증명을 생성하여 소비 될 때까지 계층 구조를 통과하는 것이 일반적입니다. 따라서 이러한 구성에서는각 프록시가 동일한 챌린지 세트를 보내므로 프록시 인증이 전달되는 것처럼 나타납니다. WWW-Authenticate에 대한 구문 분석 고려 사항은이 헤더 필드에도 적용됩니다. 보다&lt;a href=&quot;#section-4.1&quot;&gt;&lt;/a&gt;자세한 내용 은 4.1 절 .</target>
        </trans-unit>
        <trans-unit id="4e55a01408a5bfa971888b6023693ae2d37ad3ee" translate="yes" xml:space="preserve">
          <source>The &quot;Proxy-Authorization&quot; header field allows the client to identify
   itself (or its user) to a proxy that requires authentication.  Its
   value consists of credentials containing the authentication
   information of the client for the proxy and/or realm of the resource
   being requested.

     Proxy-Authorization = credentials

   Unlike Authorization, the Proxy-Authorization header field applies
   only to the next inbound proxy that demanded authentication using the
   Proxy-Authenticate field.  When multiple proxies are used in a chain,
   the Proxy-Authorization header field is consumed by the first inbound
   proxy that was expecting to receive credentials.  A proxy MAY relay
   the credentials from the client request to the next proxy if that is
   the mechanism by which the proxies cooperatively authenticate a given
   request.</source>
          <target state="translated">&quot;프록시 인증&quot;헤더 필드를 통해 클라이언트는 인증이 필요한 프록시로 자신 (또는 사용자)을 식별 할 수 있습니다. 이 값은 프록시 및 / 또는 요청되는 리소스 영역에 대한 클라이언트의 인증 정보를 포함하는 자격 증명으로 구성됩니다. Proxy-Authorization = 자격 증명 Authorization과 달리 Proxy-Authorization 헤더 필드는 Proxy-Authenticate 필드를 사용하여 인증을 요구 한 다음 인바운드 프록시에만 적용됩니다. 체인에서 여러 프록시를 사용하는 경우 프록시 인증 헤더 필드는 자격 증명을받을 것으로 예상되는 첫 번째 인바운드 프록시에서 사용됩니다.프록시가 프록시가 주어진 요청을 협력 적으로 인증하는 메커니즘 인 경우 프록시는 클라이언트 요청에서 다음 프록시로 자격 증명을 릴레이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b718f4bbb4edbfe4ac380e46d4526fcfa5c21c8b" translate="yes" xml:space="preserve">
          <source>The &quot;Range&quot; header field on a GET request modifies the method
   semantics to request transfer of only one or more subranges of the
   selected representation data, rather than the entire selected
   representation data.

     Range = byte-ranges-specifier / other-ranges-specifier
     other-ranges-specifier = other-range-unit &quot;=&quot; other-range-set
     other-range-set = 1*VCHAR

   A server MAY ignore the Range header field.  However, origin servers
   and intermediate caches ought to support byte ranges when possible,
   since Range supports efficient recovery from partially failed
   transfers and partial retrieval of large representations.  A server
   MUST ignore a Range header field received with a request method other
   than GET.

   An origin server MUST ignore a Range header field that contains a
   range unit it does not understand.  A proxy MAY discard a Range
   header field that contains a range unit it does not understand.

   A server that supports range requests MAY ignore or reject a Range
   header field that consists of more than two overlapping ranges, or a
   set of many small ranges that are not listed in ascending order,
   since both are indications of either a broken client or a deliberate
   denial-of-service attack (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).  A client SHOULD NOT request
   multiple ranges that are inherently less efficient to process and
   transfer than a single range that encompasses the same data.

   A client that is requesting multiple ranges SHOULD list those ranges
   in ascending order (the order in which they would typically be
   received in a complete representation) unless there is a specific
   need to request a later part earlier.  For example, a user agent
   processing a large representation with an internal catalog of parts
   might need to request later parts first, particularly if the
   representation consists of pages stored in reverse order and the user
   agent wishes to transfer one page at a time.

   The Range header field is evaluated after evaluating the precondition
   header fields defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;], and only if the result in absence
   of the Range header field would be a 200 (OK) response.  In other
   words, Range is ignored when a conditional GET would result in a 304
   (Not Modified) response. 

   The If-Range header field (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;) can be used as a precondition
   to applying the Range header field.

   If all of the preconditions are true, the server supports the Range
   header field for the target resource, and the specified range(s) are
   valid and satisfiable (as defined in &lt;a href=&quot;#section-2.1&quot;&gt;Section 2.1&lt;/a&gt;), the server SHOULD
   send a 206 (Partial Content) response with a payload containing one
   or more partial representations that correspond to the satisfiable
   ranges requested, as defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;.

   If all of the preconditions are true, the server supports the Range
   header field for the target resource, and the specified range(s) are
   invalid or unsatisfiable, the server SHOULD send a 416 (Range Not
   Satisfiable) response.</source>
          <target state="translated">GET 요청의 &quot;범위&quot;헤더 필드는 전체 선택된 표현 데이터가 아닌 선택된 표현 데이터의 하나 이상의 하위 범위의 전송을 요청하도록 메소드 시맨틱을 수정합니다. Range = byte-ranges-specifier / other-ranges-specifier other-ranges-specifier = other-range-unit &quot;=&quot;other-range-set other-range-set = 1 * VCHAR 서버는 Range 헤더 필드를 무시할 수 있습니다. 그러나 Range는 부분적으로 실패한 전송 및 큰 표현의 부분 검색에서 효율적인 복구를 지원하므로 원 서버와 중간 캐시는 가능한 경우 바이트 범위를 지원해야합니다. 서버는 GET 이외의 요청 방법으로 수신 된 Range 헤더 필드를 무시해야합니다.오리진 서버는 이해하지 못하는 범위 단위를 포함하는 범위 헤더 필드를 무시해야합니다. 프록시는 이해하지 못하는 범위 단위를 포함하는 범위 헤더 필드를 폐기 할 수 있습니다. 범위 요청을 지원하는 서버는 둘 이상의 겹치는 범위 또는 오름차순으로 나열되지 않은 많은 작은 범위 세트로 구성된 범위 헤더 필드를 무시하거나 거부 할 수 있습니다. 둘 다 깨진 클라이언트 또는 의도적 인 표시이므로 서비스 거부 공격 (둘 다 클라이언트가 고장 났거나 고의적 인 서비스 거부 공격 (둘 다 클라이언트가 고장 났거나 고의적 인 서비스 거부 공격 (&lt;a href=&quot;#section-6.1&quot;&gt;섹션 6.1&lt;/a&gt; ). 클라이언트는 동일한 데이터를 포함하는 단일 범위보다 본질적으로 처리 및 전송 효율성이 낮은 여러 범위를 요청해서는 안됩니다. 여러 범위를 요청하는 클라이언트는 이후 부분을 미리 요청해야하는 특별한 요구가없는 한 해당 범위를 오름차순으로 나열해야합니다 (일반적으로 전체 표현으로 표시되는 순서). 예를 들어, 내부 부품 카탈로그로 큰 표현을 처리하는 사용자 에이전트는 특히 표현이 역순으로 저장된 페이지로 구성되고 사용자 에이전트가 한 번에 한 페이지를 전송하려는 경우 나중에 부품을 요청해야 할 수 있습니다. 범위 헤더 필드는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232에&lt;/a&gt; 정의 된 전제 조건 헤더 필드를 평가 한 후 평가됩니다.]이며 범위 헤더 필드가없는 경우에만 200 (확인) 응답입니다. 즉, 조건부 GET으로 인해 304 (수정되지 않음) 응답이 발생하면 범위가 무시됩니다. If-Range 헤더 필드 ( &lt;a href=&quot;#section-3.2&quot;&gt;섹션 3.2&lt;/a&gt; )는 Range 헤더 필드를 적용하기위한 전제 조건으로 사용할 수 있습니다. 모든 전제 조건이 참이면, 서버는 대상 자원에 대한 범위 헤더 필드를 지원하고 지정된 범위가 유효하고 만족할 수 있고 ( &lt;a href=&quot;#section-2.1&quot;&gt;섹션 2.1에&lt;/a&gt; 정의 된대로 ), 서버는 206 (부분 컨텐츠) 응답을 보내야합니다 &lt;a href=&quot;#section-4&quot;&gt;섹션 4에&lt;/a&gt; 정의 된 바와 같이 요청 된 만족스러운 범위에 해당하는 하나 이상의 부분 표현을 포함하는 페이로드. 모든 전제 조건이 true이고 서버가 대상 자원에 대한 Range 헤더 필드를 지원하고 지정된 범위가 유효하지 않거나 만족할 수없는 경우 서버는 416 (Range Not Satisfiable) 응답을 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="1a6f10ce133a2f9215112587238b74cbf177295e" translate="yes" xml:space="preserve">
          <source>The &quot;Referer&quot; [sic] header field allows the user agent to specify a
   URI reference for the resource from which the target URI was obtained
   (i.e., the &quot;referrer&quot;, though the field name is misspelled).  A user
   agent MUST NOT include the fragment and userinfo components of the
   URI reference [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;], if any, when generating the Referer field
   value.

     Referer = absolute-URI / partial-URI

   The Referer header field allows servers to generate back-links to
   other resources for simple analytics, logging, optimized caching,
   etc.  It also allows obsolete or mistyped links to be found for
   maintenance.  Some servers use the Referer header field as a means of
   denying links from other sites (so-called &quot;deep linking&quot;) or
   restricting cross-site request forgery (CSRF), but not all requests
   contain it.

   Example:

     Referer: http://www.example.org/hypertext/Overview.html

   If the target URI was obtained from a source that does not have its
   own URI (e.g., input from the user keyboard, or an entry within the
   user's bookmarks/favorites), the user agent MUST either exclude the
   Referer field or send it with a value of &quot;about:blank&quot;.

   The Referer field has the potential to reveal information about the
   request context or browsing history of the user, which is a privacy
   concern if the referring resource's identifier reveals personal
   information (such as an account name) or a resource that is supposed
   to be confidential (such as behind a firewall or internal to a
   secured service).  Most general-purpose user agents do not send the
   Referer header field when the referring resource is a local &quot;file&quot; or
   &quot;data&quot; URI.  A user agent MUST NOT send a Referer header field in an
   unsecured HTTP request if the referring page was received with a
   secure protocol.  See &lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt; for additional security
   considerations. 

   Some intermediaries have been known to indiscriminately remove
   Referer header fields from outgoing requests.  This has the
   unfortunate side effect of interfering with protection against CSRF
   attacks, which can be far more harmful to their users.
   Intermediaries and user agent extensions that wish to limit
   information disclosure in Referer ought to restrict their changes to
   specific edits, such as replacing internal domain names with
   pseudonyms or truncating the query and/or path components.  An
   intermediary SHOULD NOT modify or delete the Referer header field
   when the field value shares the same scheme and host as the request
   target.</source>
          <target state="translated">&quot;참조 자&quot;[sic] 헤더 필드를 사용하면 사용자 에이전트가 대상 URI를 확보 한 자원에 대한 URI 참조를 지정할 수 있습니다 (예 : 필드 이름의 철자가 틀리더라도 &quot;참조 자&quot;). 사용자 에이전트는 URI 참조의 프래그먼트 및 userinfo 구성 요소를 포함해서는 안된다 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;] (있는 경우) 참조 필드 값을 생성 할 때. Referer = absolute-URI / partial-URI Referer 헤더 필드를 통해 서버는 간단한 분석, 로깅, 최적화 된 캐싱 등을 위해 다른 리소스에 대한 백 링크를 생성 할 수 있습니다. 또한 유지 관리를 위해 더 이상 사용되지 않거나 잘못 입력 된 링크를 찾을 수 있습니다. 일부 서버는 다른 사이트의 링크 ( &quot;딥 링크&quot;라고 함)를 거부하거나 CSRF (Cross-Site Request Forgery)를 제한하는 수단으로 Referer 헤더 필드를 사용하지만 모든 요청에 ​​포함하지는 않습니다. 예 : 참조 자 : http://www.example.org/hypertext/Overview.html 대상 URI가 고유 URI가없는 소스에서 얻은 경우 (예 : 사용자 키보드에서 입력 또는 사용자의 항목) 북마크 / 즐겨 찾기),사용자 에이전트는 Referer 필드를 제외하거나 &quot;about : blank&quot;값으로 보내야합니다. Referer 필드는 사용자의 요청 컨텍스트 또는 브라우징 히스토리에 대한 정보를 공개 할 가능성이 있습니다. 이는 참조 리소스의 식별자가 개인 정보 (예 : 계정 이름) 또는 기밀로 간주되는 리소스 ( 방화벽 뒤 또는 보안 서비스 내부 등). 대부분의 범용 사용자 에이전트는 참조 자원이 로컬 &quot;파일&quot;또는 &quot;데이터&quot;URI 인 경우 참조 헤더 필드를 보내지 않습니다. 참조 페이지가 보안 프로토콜로 수신 된 경우 사용자 에이전트는 보안되지 않은 HTTP 요청으로 Referer 헤더 필드를 보내서는 안됩니다 (MUST NOT). 보다Referer 필드는 사용자의 요청 컨텍스트 또는 브라우징 히스토리에 대한 정보를 공개 할 가능성이 있습니다. 이는 참조 자원의 식별자가 개인 정보 (예 : 계정 이름) 또는 기밀로 간주되는 자원 ( 방화벽 뒤 또는 보안 서비스 내부 등). 대부분의 범용 사용자 에이전트는 참조 자원이 로컬 &quot;파일&quot;또는 &quot;데이터&quot;URI 인 경우 참조 헤더 필드를 보내지 않습니다. 참조 페이지가 보안 프로토콜로 수신 된 경우, 사용자 에이전트는 보안되지 않은 HTTP 요청으로 Referer 헤더 필드를 보내서는 안됩니다 (MUST NOT). 보다Referer 필드는 사용자의 요청 컨텍스트 또는 브라우징 히스토리에 대한 정보를 공개 할 가능성이 있습니다. 이는 참조 리소스의 식별자가 개인 정보 (예 : 계정 이름) 또는 기밀로 간주되는 리소스 ( 방화벽 뒤 또는 보안 서비스 내부 등). 대부분의 범용 사용자 에이전트는 참조 자원이 로컬 &quot;파일&quot;또는 &quot;데이터&quot;URI 인 경우 참조 헤더 필드를 보내지 않습니다. 참조 페이지가 보안 프로토콜로 수신 된 경우, 사용자 에이전트는 보안되지 않은 HTTP 요청으로 Referer 헤더 필드를 보내서는 안됩니다 (MUST NOT). 보다식별자는 개인 정보 (예 : 계정 이름) 또는 기밀 정보 (예 : 방화벽 뒤 또는 보안 서비스 내부)를 나타냅니다. 대부분의 범용 사용자 에이전트는 참조 자원이 로컬 &quot;파일&quot;또는 &quot;데이터&quot;URI 인 경우 참조 헤더 필드를 보내지 않습니다. 참조 페이지가 보안 프로토콜로 수신 된 경우 사용자 에이전트는 보안되지 않은 HTTP 요청으로 Referer 헤더 필드를 보내서는 안됩니다 (MUST NOT). 보다식별자는 개인 정보 (예 : 계정 이름) 또는 기밀 정보 (예 : 방화벽 뒤 또는 보안 서비스 내부)를 나타냅니다. 대부분의 범용 사용자 에이전트는 참조 자원이 로컬 &quot;파일&quot;또는 &quot;데이터&quot;URI 인 경우 참조 헤더 필드를 보내지 않습니다. 참조 페이지가 보안 프로토콜로 수신 된 경우, 사용자 에이전트는 보안되지 않은 HTTP 요청으로 Referer 헤더 필드를 보내서는 안됩니다 (MUST NOT). 보다참조 페이지가 보안 프로토콜로 수신 된 경우 사용자 에이전트는 보안되지 않은 HTTP 요청으로 Referer 헤더 필드를 보내서는 안됩니다 (MUST NOT). 보다참조 페이지가 보안 프로토콜로 수신 된 경우, 사용자 에이전트는 보안되지 않은 HTTP 요청으로 Referer 헤더 필드를 보내서는 안됩니다 (MUST NOT). 보다&lt;a href=&quot;#section-9.4&quot;&gt;&lt;/a&gt;추가적인 보안 고려 사항 은 9.4 절 . 일부 중개자는 발신 요청에서 Referer 헤더 필드를 무차별 적으로 제거하는 것으로 알려져 있습니다. 이는 CSRF 공격에 대한 보호 기능을 방해하여 사용자에게 훨씬 더 해로울 수있는 불행한 부작용이 있습니다. Referer에서 정보 공개를 제한하려는 중개자 및 사용자 에이전트 확장은 내부 도메인 이름을 가명으로 바꾸거나 쿼리 및 / 또는 경로 구성 요소를 자르는 등 특정 편집으로 변경 사항을 제한해야합니다. 필드 값이 요청 대상과 동일한 체계 및 호스트를 공유하는 경우 중개자는 참조 헤더 필드를 수정하거나 삭제해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d19493afa0fd7d7d38b18500fe6b7e410894e8e6" translate="yes" xml:space="preserve">
          <source>The &quot;Server&quot; header field contains information about the software
   used by the origin server to handle the request, which is often used
   by clients to help identify the scope of reported interoperability
   problems, to work around or tailor requests to avoid particular
   server limitations, and for analytics regarding server or operating
   system use.  An origin server MAY generate a Server field in its
   responses.

     Server = product *( RWS ( product / comment ) )

   The Server field-value consists of one or more product identifiers,
   each followed by zero or more comments (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;),
   which together identify the origin server software and its
   significant subproducts.  By convention, the product identifiers are
   listed in decreasing order of their significance for identifying the
   origin server software.  Each product identifier consists of a name
   and optional version, as defined in &lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt;.

   Example:

     Server: CERN/3.0 libwww/2.17

   An origin server SHOULD NOT generate a Server field containing
   needlessly fine-grained detail and SHOULD limit the addition of
   subproducts by third parties.  Overly long and detailed Server field
   values increase response latency and potentially reveal internal
   implementation details that might make it (slightly) easier for
   attackers to find and exploit known security holes.</source>
          <target state="translated">&quot;서버&quot;헤더 필드에는 요청을 처리하기 위해 오리진 서버가 사용하는 소프트웨어에 대한 정보가 포함됩니다.이 정보는 클라이언트가보고 된 상호 운용성 문제의 범위를 식별하고 특정 서버 제한을 ​​피하기 위해 요청을 해결하거나 조정하기 위해 종종 사용합니다. 서버 또는 운영 체제 사용에 관한 분석 용. 오리진 서버는 응답에서 서버 필드를 생성 할 수 있습니다. 서버 = product * (RWS (product / comment)) 서버 필드 값은 하나 이상의 제품 식별자로 구성되며 각각 뒤에 0 개 이상의 주석이 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]의 3.2 절&lt;/a&gt;), 원본 서버 소프트웨어 및 중요한 하위 제품을 함께 식별합니다. 일반적으로 제품 식별자는 원본 서버 소프트웨어를 식별하는 데있어 중요도에 따라 내림차순으로 나열됩니다. 각 제품 식별자는 &lt;a href=&quot;#section-5.5.3&quot;&gt;5.5.3 절에&lt;/a&gt; 정의 된대로 이름과 선택적 버전으로 구성됩니다 . 예 : 서버 : CERN / 3.0 libwww / 2.17 오리진 서버는 불필요하게 세분화 된 세부 사항을 포함하는 서버 필드를 생성해서는 안되며, 타사의 하위 제품 추가를 제한해야합니다 (SHOULD). 지나치게 길고 상세한 서버 필드 값은 응답 대기 시간을 증가시키고 잠재적으로 공격자가 알려진 보안 허점을 쉽게 찾고 이용할 수 있도록하는 내부 구현 세부 정보를 공개합니다.</target>
        </trans-unit>
        <trans-unit id="bf7a34c8bf8ec710d19c3accad390aa1affece68" translate="yes" xml:space="preserve">
          <source>The &quot;TE&quot; header field in a request indicates what transfer codings,
   besides chunked, the client is willing to accept in response, and
   whether or not the client is willing to accept trailer fields in a
   chunked transfer coding.

   The TE field-value consists of a comma-separated list of transfer
   coding names, each allowing for optional parameters (as described in
   &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;), and/or the keyword &quot;trailers&quot;.  A client MUST NOT send
   the chunked transfer coding name in TE; chunked is always acceptable
   for HTTP/1.1 recipients.

     TE        = #t-codings
     t-codings = &quot;trailers&quot; / ( transfer-coding [ t-ranking ] )
     t-ranking = OWS &quot;;&quot; OWS &quot;q=&quot; rank
     rank      = ( &quot;0&quot; [ &quot;.&quot; 0*3DIGIT ] )
                / ( &quot;1&quot; [ &quot;.&quot; 0*3(&quot;0&quot;) ] )

   Three examples of TE use are below.

     TE: deflate
     TE:
     TE: trailers, deflate;q=0.5

   The presence of the keyword &quot;trailers&quot; indicates that the client is
   willing to accept trailer fields in a chunked transfer coding, as
   defined in &lt;a href=&quot;#section-4.1.2&quot;&gt;Section 4.1.2&lt;/a&gt;, on behalf of itself and any downstream
   clients.  For requests from an intermediary, this implies that
   either: (a) all downstream clients are willing to accept trailer
   fields in the forwarded response; or, (b) the intermediary will
   attempt to buffer the response on behalf of downstream recipients.
   Note that HTTP/1.1 does not define any means to limit the size of a
   chunked response such that an intermediary can be assured of
   buffering the entire response.

   When multiple transfer codings are acceptable, the client MAY rank
   the codings by preference using a case-insensitive &quot;q&quot; parameter
   (similar to the qvalues used in content negotiation fields, Section 

   5.3.1 of [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]).  The rank value is a real number in the range 0
   through 1, where 0.001 is the least preferred and 1 is the most
   preferred; a value of 0 means &quot;not acceptable&quot;.

   If the TE field-value is empty or if no TE field is present, the only
   acceptable transfer coding is chunked.  A message with no transfer
   coding is always acceptable.

   Since the TE header field only applies to the immediate connection, a
   sender of TE MUST also send a &quot;TE&quot; connection option within the
   Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) in order to prevent the TE
   field from being forwarded by intermediaries that do not support its
   semantics.</source>
          <target state="translated">요청의 &quot;TE&quot;헤더 필드는 청크 된 것 외에, 클라이언트가 응답으로 수락 할 의사가있는 것 및 클라이언트가 청크 된 전송 코딩에서 트레일러 필드를 허용 할 것인지의 여부를 나타낸다. TE 필드-값은 쉼표로 구분 된 전송 코딩 이름 목록으로 구성되며, 각각은 선택적 매개 변수를 허용합니다 ( &lt;a href=&quot;#section-4&quot;&gt;섹션 4에&lt;/a&gt; 설명 됨) ) 및 / 또는 키워드 &quot;예고편&quot; 클라이언트는 청크 된 전송 코딩 이름을 TE로 보내서는 안된다. 청크는 항상 HTTP / 1.1 수신자에게 허용됩니다. TE = # t- 코딩 t- 코딩 = &quot;트레일러&quot;/ (전송 코딩 [t- 순위]) t- 순위 = OWS &quot;;&quot; OWS &quot;q =&quot;rank rank = ( &quot;0&quot;[ &quot;.&quot;0 * 3DIGIT]) / ( &quot;1&quot;[ &quot;.&quot;0 * 3 ( &quot;0&quot;)]) TE 사용의 세 가지 예는 다음과 같습니다. TE : deflate TE : TE : 트레일러, deflate; q = 0.5 &quot;트레일러&quot;라는 키워드가 있으면 고객이 &lt;a href=&quot;#section-4.1.2&quot;&gt;섹션 4.1.2에&lt;/a&gt; 정의 된대로 청크 분할 전송 코딩에서 트레일러 필드를 허용 할 것임을 나타냅니다.자체 및 다운 스트림 클라이언트를 대신하여 중개자 요청의 경우 이는 다음 중 하나를 의미합니다. (a) 모든 다운 스트림 클라이언트가 전달 된 응답에서 트레일러 필드를 기꺼이 수락합니다. 또는 (b) 중개자는 다운 스트림 수신자를 대신하여 응답을 버퍼링하려고 시도 할 것이다. HTTP / 1.1은 중개자가 전체 응답을 버퍼링 할 수 있도록 청크 응답의 크기를 제한하는 수단을 정의하지 않습니다. 다중 전송 코딩이 수용 가능한 경우, 클라이언트는 대소 문자를 구분하지 않는 &quot;q&quot;매개 변수를 사용하여 선호도에 따라 코딩 순위를 매길 수 있습니다 (콘텐츠 협상 필드에 사용 된 qvalue와 유사, [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231의&lt;/a&gt; 섹션 5.3.1).]). 순위 값은 0에서 1 사이의 실수이며, 0.001이 가장 바람직하지 않고 1이 가장 선호됩니다. 값이 0이면 &quot;허용되지 않음&quot;을 의미합니다. TE 필드 값이 비어 있거나 TE 필드가없는 경우, 허용되는 전송 코드 만 청크됩니다. 전송 코딩이없는 메시지는 항상 허용됩니다. TE 헤더 필드는 즉각적인 연결에만 적용되기 때문에 TE를 보낸 사람은 TE 필드가 지원하지 않는 중개자에 의해 전달되지 않도록하기 위해 Connection 헤더 필드 ( &lt;a href=&quot;#section-6.1&quot;&gt;섹션 6.1&lt;/a&gt; ) 내에 &quot;TE&quot;연결 옵션을 보내야합니다. 그것의 의미론.</target>
        </trans-unit>
        <trans-unit id="642dca3b33f00cb08595b70f704b7b8a5ca96a77" translate="yes" xml:space="preserve">
          <source>The &quot;Upgrade&quot; header field is intended to provide a simple mechanism
   for transitioning from HTTP/1.1 to some other protocol on the same
   connection.  A client MAY send a list of protocols in the Upgrade
   header field of a request to invite the server to switch to one or
   more of those protocols, in order of descending preference, before
   sending the final response.  A server MAY ignore a received Upgrade
   header field if it wishes to continue using the current protocol on
   that connection.  Upgrade cannot be used to insist on a protocol
   change.

     Upgrade          = 1#protocol

     protocol         = protocol-name [&quot;/&quot; protocol-version]
     protocol-name    = token
     protocol-version = token

   A server that sends a 101 (Switching Protocols) response MUST send an
   Upgrade header field to indicate the new protocol(s) to which the
   connection is being switched; if multiple protocol layers are being
   switched, the sender MUST list the protocols in layer-ascending
   order.  A server MUST NOT switch to a protocol that was not indicated
   by the client in the corresponding request's Upgrade header field.  A 

   server MAY choose to ignore the order of preference indicated by the
   client and select the new protocol(s) based on other factors, such as
   the nature of the request or the current load on the server.

   A server that sends a 426 (Upgrade Required) response MUST send an
   Upgrade header field to indicate the acceptable protocols, in order
   of descending preference.

   A server MAY send an Upgrade header field in any other response to
   advertise that it implements support for upgrading to the listed
   protocols, in order of descending preference, when appropriate for a
   future request.

   The following is a hypothetical example sent by a client:

     GET /hello.txt HTTP/1.1
     Host: www.example.com
     Connection: upgrade
     Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11


   The capabilities and nature of the application-level communication
   after the protocol change is entirely dependent upon the new
   protocol(s) chosen.  However, immediately after sending the 101
   (Switching Protocols) response, the server is expected to continue
   responding to the original request as if it had received its
   equivalent within the new protocol (i.e., the server still has an
   outstanding request to satisfy after the protocol has been changed,
   and is expected to do so without requiring the request to be
   repeated).

   For example, if the Upgrade header field is received in a GET request
   and the server decides to switch protocols, it first responds with a
   101 (Switching Protocols) message in HTTP/1.1 and then immediately
   follows that with the new protocol's equivalent of a response to a
   GET on the target resource.  This allows a connection to be upgraded
   to protocols with the same semantics as HTTP without the latency cost
   of an additional round trip.  A server MUST NOT switch protocols
   unless the received message semantics can be honored by the new
   protocol; an OPTIONS request can be honored by any protocol. 

   The following is an example response to the above hypothetical
   request:

     HTTP/1.1 101 Switching Protocols
     Connection: upgrade
     Upgrade: HTTP/2.0

     [... data stream switches to HTTP/2.0 with an appropriate response
     (as defined by new protocol) to the &quot;GET /hello.txt&quot; request ...]

   When Upgrade is sent, the sender MUST also send a Connection header
   field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) that contains an &quot;upgrade&quot; connection option, in
   order to prevent Upgrade from being accidentally forwarded by
   intermediaries that might not implement the listed protocols.  A
   server MUST ignore an Upgrade header field that is received in an
   HTTP/1.0 request.

   A client cannot begin using an upgraded protocol on the connection
   until it has completely sent the request message (i.e., the client
   can't change the protocol it is sending in the middle of a message).
   If a server receives both an Upgrade and an Expect header field with
   the &quot;100-continue&quot; expectation (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.1.1&quot;&gt;Section&amp;nbsp;5.1.1 of [RFC7231]&lt;/a&gt;), the
   server MUST send a 100 (Continue) response before sending a 101
   (Switching Protocols) response.

   The Upgrade header field only applies to switching protocols on top
   of the existing connection; it cannot be used to switch the
   underlying connection (transport) protocol, nor to switch the
   existing communication to a different connection.  For those
   purposes, it is more appropriate to use a 3xx (Redirection) response
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.4&quot;&gt;Section&amp;nbsp;6.4 of [RFC7231]&lt;/a&gt;).

   This specification only defines the protocol name &quot;HTTP&quot; for use by
   the family of Hypertext Transfer Protocols, as defined by the HTTP
   version rules of &lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt; and future updates to this
   specification.  Additional tokens ought to be registered with IANA
   using the registration procedure defined in &lt;a href=&quot;#section-8.6&quot;&gt;Section 8.6&lt;/a&gt;.</source>
          <target state="translated">&quot;업그레이드&quot;헤더 필드는 동일한 연결에서 HTTP / 1.1에서 다른 프로토콜로 전환하기위한 간단한 메커니즘을 제공하기위한 것입니다. 클라이언트는 최종 응답을 보내기 전에 서버가 요청을 업그레이드 헤더 필드에 프로토콜 목록을 보내서 내림차순으로 하나 이상의 프로토콜로 전환하도록 서버를 초대 할 수 있습니다. 해당 연결에서 현재 프로토콜을 계속 사용하려는 경우 서버는 수신 한 업그레이드 헤더 필드를 무시할 수 있습니다. 프로토콜 변경을 주장하는 데 업그레이드를 사용할 수 없습니다. 업그레이드 = 1 # 프로토콜 프로토콜 = 프로토콜 이름 [ &quot;/&quot;protocol-version] protocol-name = token protocol-version = token 101 (스위칭 프로토콜) 응답을 보내는 서버는 반드시 업그레이드 헤더 필드를 보내서 연결이 전환되는 새로운 프로토콜을 나타냅니다. 여러 프로토콜 계층이 전환되는 경우 발신자는 반드시 프로토콜을 계층 오름차순으로 나열해야합니다. 서버는 해당 요청의 업그레이드 헤더 필드에 클라이언트가 표시하지 않은 프로토콜로 전환해서는 안됩니다 (MUST NOT). 서버는 클라이언트가 나타내는 우선 순위를 무시하고 요청의 성격 또는 서버의 현재 부하와 같은 다른 요인에 따라 새 프로토콜을 선택할 수 있습니다. 426 (업그레이드 필요) 응답을 보내는 서버는 반드시 허용 가능한 프로토콜을 나타 내기 위해 업그레이드 헤더 필드를 보내야합니다.내림차순으로. 서버는 다른 요청에 업그레이드 헤더 필드를 보내 향후 요청에 적합 할 경우 나열된 프로토콜로 업그레이드 지원을 내림차순으로 구현할 수 있음을 알릴 수 있습니다. 다음은 클라이언트가 보낸 가상의 예입니다. GET /hello.txt HTTP / 1.1 호스트 : www.example.com 연결 : 업그레이드 업그레이드 : HTTP / 2.0, SHTTP / 1.3, IRC / 6.9, RTA / x11 기능 및 특성 프로토콜 변경 후 애플리케이션 레벨 통신의 선택은 전적으로 선택된 새로운 프로토콜 (들)에 의존한다. 그러나 101 (Switching Protocols) 응답을 보낸 직후 서버는 마치 새 프로토콜 내에서 동등한 요청을받은 것처럼 원래 요청에 계속 응답해야합니다 (예 :프로토콜이 변경된 후에도 서버는 여전히 충족해야 할 미해결 요청을 가지고 있으며 요청을 반복하지 않고도 그렇게 할 것으로 예상됩니다). 예를 들어, 업그레이드 헤더 필드가 GET 요청에서 수신되고 서버가 프로토콜을 전환하기로 결정한 경우, 먼저 HTTP / 1.1에서 101 (스위칭 프로토콜) 메시지로 응답 한 다음 새 프로토콜의 응답에 해당하는 것을 즉시 따릅니다. 대상 자원의 GET에. 이를 통해 추가 왕복의 대기 시간 비용없이 HTTP와 동일한 의미를 가진 프로토콜로 연결을 업그레이드 할 수 있습니다. 수신 된 메시지 시맨틱이 새로운 프로토콜에 의해 존중 될 수 없다면 서버는 프로토콜을 전환해서는 안된다; 모든 프로토콜에서 OPTIONS 요청을 처리 할 수 ​​있습니다.다음은 위의 가상 요청에 대한 응답 예입니다. HTTP / 1.1 101 스위칭 프로토콜 연결 : 업그레이드 업그레이드 : HTTP / 2.0 [... 데이터 스트림은 적절한 프로토콜 (새 프로토콜에서 정의한대로)을 사용하여 HTTP / 2.0으로 전환합니다. &quot;GET /hello.txt&quot;request ...] 업그레이드가 전송되면 발신자는 반드시 연결 헤더 필드 (&lt;a href=&quot;#section-6.1&quot;&gt;&lt;/a&gt;나열된 프로토콜을 구현하지 않을 수있는 중개자가 업그레이드를 실수로 전달하지 못하도록하기 위해 &quot;업그레이드&quot;연결 옵션이 포함 된 섹션 6.1 ). 서버는 HTTP / 1.0 요청에서 수신 된 업그레이드 헤더 필드를 무시해야합니다. 클라이언트는 요청 메시지를 완전히 보낼 때까지 연결에서 업그레이드 된 프로토콜을 사용할 수 없습니다 (예 : 클라이언트는 메시지 중간에 보내는 프로토콜을 변경할 수 없음). 서버가 &quot;100-continue&quot;예상으로 업그레이드 및 Expect 헤더 필드를 모두받는 경우 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5.1.1&quot;&gt;[RFC7231]의 5.1.1 절&lt;/a&gt;) 서버는 반드시 101 (Switching Protocols) 응답을 보내기 전에 100 (Continue) 응답을 보내야합니다. 업그레이드 헤더 필드는 기존 연결 위에있는 프로토콜 전환에만 적용됩니다. 기본 연결 (전송) 프로토콜을 전환하거나 기존 통신을 다른 연결로 전환하는 데 사용할 수 없습니다. 이러한 목적으로 3xx (리디렉션) 응답을 사용하는 것이 더 적절합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.4&quot;&gt;[RFC7231]의 섹션 6.4&lt;/a&gt; ). 이 사양은 &lt;a href=&quot;#section-2.6&quot;&gt;섹션 2.6&lt;/a&gt; 의 HTTP 버전 규칙 과이 사양에 대한 향후 업데이트에 정의 된대로 하이퍼 텍스트 전송 프로토콜 제품군에서 사용할 프로토콜 이름 &quot;HTTP&quot;만 정의합니다 . 추가 토큰은에 정의 된 등록 절차를 사용하여 IANA에 등록해야합니다.&lt;a href=&quot;#section-8.6&quot;&gt;섹션 8.6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cca24e17d2817ed4fdcf6d3f466ac894c19b3c68" translate="yes" xml:space="preserve">
          <source>The &quot;User-Agent&quot; header field contains information about the user
   agent originating the request, which is often used by servers to help
   identify the scope of reported interoperability problems, to work
   around or tailor responses to avoid particular user agent
   limitations, and for analytics regarding browser or operating system
   use.  A user agent SHOULD send a User-Agent field in each request
   unless specifically configured not to do so.

     User-Agent = product *( RWS ( product / comment ) )

   The User-Agent field-value consists of one or more product
   identifiers, each followed by zero or more comments (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of
   [RFC7230]&lt;/a&gt;), which together identify the user agent software and its
   significant subproducts.  By convention, the product identifiers are
   listed in decreasing order of their significance for identifying the
   user agent software.  Each product identifier consists of a name and
   optional version.

     product         = token [&quot;/&quot; product-version]
     product-version = token

   A sender SHOULD limit generated product identifiers to what is
   necessary to identify the product; a sender MUST NOT generate
   advertising or other nonessential information within the product
   identifier.  A sender SHOULD NOT generate information in
   product-version that is not a version identifier (i.e., successive
   versions of the same product name ought to differ only in the
   product-version portion of the product identifier).

   Example:

     User-Agent: CERN-LineMode/2.15 libwww/2.17b3 

   A user agent SHOULD NOT generate a User-Agent field containing
   needlessly fine-grained detail and SHOULD limit the addition of
   subproducts by third parties.  Overly long and detailed User-Agent
   field values increase request latency and the risk of a user being
   identified against their wishes (&quot;fingerprinting&quot;).

   Likewise, implementations are encouraged not to use the product
   tokens of other implementations in order to declare compatibility
   with them, as this circumvents the purpose of the field.  If a user
   agent masquerades as a different user agent, recipients can assume
   that the user intentionally desires to see responses tailored for
   that identified user agent, even if they might not work as well for
   the actual user agent being used.</source>
          <target state="translated">&quot;사용자 에이전트&quot;헤더 필드에는 요청을 시작한 사용자 에이전트에 대한 정보가 포함됩니다.이 에이전트는 종종 서버에서보고 된 상호 운용성 문제의 범위를 식별하고 특정 사용자 에이전트 제한을 피하기 위해 응답을 조정하거나 조정하여 분석에 사용합니다. 브라우저 또는 운영 체제 사용과 관련하여. 사용자 에이전트는 특별히 요청하지 않는 한 각 요청마다 사용자 에이전트 필드를 보내야합니다. User-Agent = product * (RWS (product / comment)) User-Agent 필드 값은 하나 이상의 제품 식별자로 구성되며 각각 뒤에 0 개 이상의 주석이 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]의 3.2 절&lt;/a&gt;)는 사용자 에이전트 소프트웨어와 중요한 하위 제품을 함께 식별합니다. 일반적으로 제품 식별자는 사용자 에이전트 소프트웨어를 식별하는 데있어 중요도에 따라 내림차순으로 나열됩니다. 각 제품 식별자는 이름과 선택적 버전으로 구성됩니다. product = token [ &quot;/&quot;product-version] product-version = token 발신자는 생성 된 제품 식별자를 제품을 식별하는 데 필요한 것으로 제한해야합니다. 발신자는 제품 식별자 내에 광고 또는 기타 중요하지 않은 정보를 생성해서는 안됩니다. 발신자는 버전 식별자가 아닌 제품 버전의 정보를 생성하지 않아야합니다 (즉, 동일한 제품 이름의 연속 버전은 제품 식별자의 제품 버전 부분에서만 달라야 함). 예:사용자 에이전트 : CERN-LineMode / 2.15 libwww / 2.17b3 사용자 에이전트는 불필요하게 세분화 된 세부 사항을 포함하는 사용자 에이전트 필드를 생성해서는 안되며, 타사의 하위 제품 추가를 제한해야합니다. 너무 길고 상세한 User-Agent 필드 값은 요청 대기 시간을 늘리고 원하는대로 사용자를 식별 할 위험 ( &quot;지문&quot;)을 증가시킵니다. 마찬가지로, 구현은 다른 구현의 제품 토큰을 사용하여 호환성을 선언하기 위해 사용하지 않는 것이 좋습니다. 이는 필드의 목적을 우회하기 때문입니다. 사용자 에이전트가 다른 사용자 에이전트로 가장하는 경우 수신자는 사용중인 실제 사용자 에이전트에 대해 제대로 작동하지 않더라도 식별 된 사용자 에이전트에 맞게 조정 된 응답을 사용자가 의도적으로 원한다고 가정 할 수 있습니다.CERN-LineMode / 2.15 libwww / 2.17b3 사용자 에이전트는 불필요하게 세분화 된 세부 사항을 포함하는 사용자 에이전트 필드를 생성해서는 안되며, 타사의 하위 제품 추가를 제한해야합니다 (SHOULD). 너무 길고 자세한 User-Agent 필드 값은 요청 대기 시간을 늘리고 원하는대로 사용자를 식별 할 위험 ( &quot;지문&quot;)을 증가시킵니다. 마찬가지로, 구현은 다른 구현의 제품 토큰을 사용하여 호환성을 선언하기 위해 사용하지 않는 것이 좋습니다. 이는 필드의 목적을 우회하기 때문입니다. 사용자 에이전트가 다른 사용자 에이전트로 가장하는 경우 수신자는 사용중인 실제 사용자 에이전트에 대해 제대로 작동하지 않더라도 식별 된 사용자 에이전트에 맞게 조정 된 응답을 사용자가 의도적으로 원한다고 가정 할 수 있습니다.CERN-LineMode / 2.15 libwww / 2.17b3 사용자 에이전트는 불필요하게 세분화 된 세부 사항을 포함하는 사용자 에이전트 필드를 생성해서는 안되며, 타사의 하위 제품 추가를 제한해야합니다 (SHOULD). 너무 길고 자세한 User-Agent 필드 값은 요청 대기 시간을 늘리고 원하는대로 사용자를 식별 할 위험 ( &quot;지문&quot;)을 증가시킵니다. 마찬가지로, 구현은 다른 구현의 제품 토큰을 사용하여 호환성을 선언하기 위해 사용하지 않는 것이 좋습니다. 이는 필드의 목적을 우회하기 때문입니다. 사용자 에이전트가 다른 사용자 에이전트로 가장하는 경우 수신자는 사용중인 실제 사용자 에이전트에 대해 제대로 작동하지 않더라도 식별 된 사용자 에이전트에 맞게 조정 된 응답을 사용자가 의도적으로 원한다고 가정 할 수 있습니다.17b3 사용자 에이전트는 불필요하게 세분화 된 세부 사항을 포함하는 사용자 에이전트 필드를 생성해서는 안되며, 타사의 하위 제품 추가를 제한해야합니다. 너무 길고 자세한 User-Agent 필드 값은 요청 대기 시간을 늘리고 원하는대로 사용자를 식별 할 위험 ( &quot;지문&quot;)을 증가시킵니다. 마찬가지로, 구현은 다른 구현의 제품 토큰을 사용하여 호환성을 선언하기 위해 사용하지 않는 것이 좋습니다. 이는 필드의 목적을 우회하기 때문입니다. 사용자 에이전트가 다른 사용자 에이전트로 가장하는 경우 수신자는 사용중인 실제 사용자 에이전트에 대해 제대로 작동하지 않더라도 식별 된 사용자 에이전트에 맞게 조정 된 응답을 사용자가 의도적으로 원한다고 가정 할 수 있습니다.17b3 사용자 에이전트는 불필요하게 세분화 된 세부 사항을 포함하는 사용자 에이전트 필드를 생성해서는 안되며, 타사의 하위 제품 추가를 제한해야합니다. 너무 길고 자세한 User-Agent 필드 값은 요청 대기 시간을 늘리고 원하는대로 사용자를 식별 할 위험 ( &quot;지문&quot;)을 증가시킵니다. 마찬가지로, 구현은 다른 구현의 제품 토큰을 사용하여 호환성을 선언하기 위해 사용하지 않는 것이 좋습니다. 이는 필드의 목적을 우회하기 때문입니다. 사용자 에이전트가 다른 사용자 에이전트로 가장하는 경우 수신자는 사용중인 실제 사용자 에이전트에 대해 제대로 작동하지 않더라도 식별 된 사용자 에이전트에 맞게 조정 된 응답을 사용자가 의도적으로 원한다고 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bcae230b73127da4f18a6ca33ad2072b01f296a" translate="yes" xml:space="preserve">
          <source>The &quot;Vary&quot; header field in a response describes what parts of a
   request message, aside from the method, Host header field, and
   request target, might influence the origin server's process for
   selecting and representing this response.  The value consists of
   either a single asterisk (&quot;*&quot;) or a list of header field names
   (case-insensitive).

     Vary = &quot;*&quot; / 1#field-name

   A Vary field value of &quot;*&quot; signals that anything about the request
   might play a role in selecting the response representation, possibly
   including elements outside the message syntax (e.g., the client's
   network address).  A recipient will not be able to determine whether
   this response is appropriate for a later request without forwarding
   the request to the origin server.  A proxy MUST NOT generate a Vary
   field with a &quot;*&quot; value.

   A Vary field value consisting of a comma-separated list of names
   indicates that the named request header fields, known as the
   selecting header fields, might have a role in selecting the
   representation.  The potential selecting header fields are not
   limited to those defined by this specification.

   For example, a response that contains

     Vary: accept-encoding, accept-language

   indicates that the origin server might have used the request's
   Accept-Encoding and Accept-Language fields (or lack thereof) as
   determining factors while choosing the content for this response.

   An origin server might send Vary with a list of fields for two
   purposes:

   1.  To inform cache recipients that they MUST NOT use this response
       to satisfy a later request unless the later request has the same
       values for the listed fields as the original request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.1&quot;&gt;Section&amp;nbsp;4.1
       of [RFC7234]&lt;/a&gt;).  In other words, Vary expands the cache key
       required to match a new request to the stored cache entry. 

   2.  To inform user agent recipients that this response is subject to
       content negotiation (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;) and that a different
       representation might be sent in a subsequent request if
       additional parameters are provided in the listed header fields
       (proactive negotiation).

   An origin server SHOULD send a Vary header field when its algorithm
   for selecting a representation varies based on aspects of the request
   message other than the method and request target, unless the variance
   cannot be crossed or the origin server has been deliberately
   configured to prevent cache transparency.  For example, there is no
   need to send the Authorization field name in Vary because reuse
   across users is constrained by the field definition (&lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of
   [RFC7235]&lt;/a&gt;).  Likewise, an origin server might use Cache-Control
   directives (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;) to supplant Vary if it
   considers the variance less significant than the performance cost of
   Vary's impact on caching.</source>
          <target state="translated">응답의 &quot;Vary&quot;헤더 필드는 메소드, 호스트 헤더 필드 및 요청 대상 외에 요청 메시지의 어떤 부분이이 응답을 선택하고 나타내는 오리진 서버의 프로세스에 영향을 줄 수 있는지를 설명합니다. 값은 단일 별표 ( &quot;*&quot;) 또는 헤더 필드 이름 목록 (대소 문자 구분)으로 구성됩니다. Vary = &quot;*&quot;/ 1 # field-name &quot;*&quot;의 Vary 필드 값은 요청에 대한 모든 것이 메시지 표현 외부의 요소 (예 : 클라이언트의 네트워크 주소)를 포함하여 응답 표현을 선택하는 데 역할을 할 수 있음을 나타냅니다. . 수신자는 요청을 오리진 서버로 전달하지 않고이 응답이 이후 요청에 적합한 지 여부를 결정할 수 없습니다.프록시는 &quot;*&quot;값을 가진 Vary 필드를 생성해서는 안됩니다 (MUST NOT). 쉼표로 구분 된 이름 목록으로 구성된 Vary 필드 값은 선택 헤더 필드라고하는 명명 된 요청 헤더 필드가 표현을 선택하는 역할을 할 수 있음을 나타냅니다. 잠재적 인 선택 헤더 필드는 본 명세서에 의해 정의 된 것으로 제한되지 않는다. 예를 들어 Vary : accept-encoding, accept-language가 포함 된 응답은 오리진 서버가 요청의 Accept-Encoding 및 Accept-Language 필드 (또는 그 부족)를이 응답의 컨텐츠를 선택하는 동안 결정 요인으로 사용했음을 나타냅니다. 오리진 서버는 다음 두 가지 목적으로 Vary를 필드 목록과 함께 보낼 수 있습니다.이후 요청이 원래 요청과 나열된 필드에 대해 동일한 값을 가지지 않는 한 이후 요청을 만족시키기 위해이 응답을 사용해서는 안된다는 것을 캐시 수신자에게 알리기 위해 (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.1&quot;&gt;[RFC7234] 섹션 4.1&lt;/a&gt; ). 즉, Vary는 새 요청을 저장된 캐시 항목과 일치시키는 데 필요한 캐시 키를 확장합니다. 2.이 응답은 (내용 협상의 대상임을 사용자 에이전트받는 사람을 알리려면 &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;) 및 추가 헤더가 나열된 헤더 필드에 제공되는 경우 후속 요청에서 다른 표현이 전송 될 수 있습니다 (사전 협상). 분산을 넘길 수 없거나 캐시 투명성을 방지하기 위해 의도적으로 오리진 서버가 구성되지 않은 한, 표현을 선택하기위한 알고리즘이 방법 및 요청 대상 이외의 요청 메시지의 측면에 기초하여 변할 때 오리진 서버는 Vary 헤더 필드를 보내야한다 (SHOULD). . 예를 들어, 사용자 간 재사용이 필드 정의에 의해 제한되므로 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;[RFC7235]의 4.2 절)&lt;/a&gt; Vary에서 Authorization 필드 이름을 보낼 필요가 없습니다 . 마찬가지로 오리진 서버는 캐시 제어 지시문을 사용할 수 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]의 5.2 절&lt;/a&gt;Vary가 캐싱에 미치는 영향의 성능 비용보다 차이가 덜 중요하다고 판단되는 경우 Vary를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="316863bc1d70a96f56b104e2287a2491c7e69bb0" translate="yes" xml:space="preserve">
          <source>The &quot;Via&quot; header field indicates the presence of intermediate
   protocols and recipients between the user agent and the server (on
   requests) or between the origin server and the client (on responses),
   similar to the &quot;Received&quot; header field in email (&lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.7&quot;&gt;Section&amp;nbsp;3.6.7 of
   [RFC5322]&lt;/a&gt;).  Via can be used for tracking message forwards, avoiding
   request loops, and identifying the protocol capabilities of senders
   along the request/response chain.

     Via = 1#( received-protocol RWS received-by [ RWS comment ] )

     received-protocol = [ protocol-name &quot;/&quot; ] protocol-version
                         ; see &lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;
     received-by       = ( uri-host [ &quot;:&quot; port ] ) / pseudonym
     pseudonym         = token

   Multiple Via field values represent each proxy or gateway that has
   forwarded the message.  Each intermediary appends its own information
   about how the message was received, such that the end result is
   ordered according to the sequence of forwarding recipients. 

   A proxy MUST send an appropriate Via header field, as described
   below, in each message that it forwards.  An HTTP-to-HTTP gateway
   MUST send an appropriate Via header field in each inbound request
   message and MAY send a Via header field in forwarded response
   messages.

   For each intermediary, the received-protocol indicates the protocol
   and protocol version used by the upstream sender of the message.
   Hence, the Via field value records the advertised protocol
   capabilities of the request/response chain such that they remain
   visible to downstream recipients; this can be useful for determining
   what backwards-incompatible features might be safe to use in
   response, or within a later request, as described in &lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt;.
   For brevity, the protocol-name is omitted when the received protocol
   is HTTP.

   The received-by portion of the field value is normally the host and
   optional port number of a recipient server or client that
   subsequently forwarded the message.  However, if the real host is
   considered to be sensitive information, a sender MAY replace it with
   a pseudonym.  If a port is not provided, a recipient MAY interpret
   that as meaning it was received on the default TCP port, if any, for
   the received-protocol.

   A sender MAY generate comments in the Via header field to identify
   the software of each recipient, analogous to the User-Agent and
   Server header fields.  However, all comments in the Via field are
   optional, and a recipient MAY remove them prior to forwarding the
   message.

   For example, a request message could be sent from an HTTP/1.0 user
   agent to an internal proxy code-named &quot;fred&quot;, which uses HTTP/1.1 to
   forward the request to a public proxy at p.example.net, which
   completes the request by forwarding it to the origin server at
   www.example.com.  The request received by www.example.com would then
   have the following Via header field:

     Via: 1.0 fred, 1.1 p.example.net

   An intermediary used as a portal through a network firewall SHOULD
   NOT forward the names and ports of hosts within the firewall region
   unless it is explicitly enabled to do so.  If not enabled, such an
   intermediary SHOULD replace each received-by host of any host behind
   the firewall by an appropriate pseudonym for that host. 

   An intermediary MAY combine an ordered subsequence of Via header
   field entries into a single such entry if the entries have identical
   received-protocol values.  For example,

     Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy

   could be collapsed to

     Via: 1.0 ricky, 1.1 mertz, 1.0 lucy

   A sender SHOULD NOT combine multiple entries unless they are all
   under the same organizational control and the hosts have already been
   replaced by pseudonyms.  A sender MUST NOT combine entries that have
   different received-protocol values.</source>
          <target state="translated">&quot;Via&quot;헤더 필드는 이메일의 &quot;수신 된&quot;헤더 필드와 유사하게 사용자 에이전트와 서버 사이 (요청시) 또는 오리진 서버와 클라이언트 사이 (응답시)에 중간 프로토콜과 수신자가 있음을 나타냅니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.6.7&quot;&gt;섹션 [RFC5322]의 3.6.7&lt;/a&gt; ). Via는 메시지 전달을 추적하고 요청 루프를 피하며 요청 / 응답 체인을 따라 보낸 사람의 프로토콜 기능을 식별하는 데 사용할 수 있습니다. Via = 1 # (수신 된 프로토콜 RWS에 의해 수신 된 RWS) received-protocol = [프로토콜 이름 &quot;/&quot;] protocol-version; &lt;a href=&quot;#section-6.7&quot;&gt;섹션 6.7&lt;/a&gt; 참조 received-by = (uri-host [ &quot;:&quot;port]) / pseudonym pseudonym = token 다중 Via 필드 값은 메시지를 전달한 각 프록시 또는 게이트웨이를 나타냅니다. 각 중개자는 메시지 수신 방법에 대한 자체 정보를 추가하여 최종 결과가 전달 수신자 순서에 따라 정렬되도록합니다. 프록시는 아래에 설명 된대로 전달하는 각 메시지에 적절한 Via 헤더 필드를 보내야합니다. HTTP-to-HTTP 게이트웨이는 각 인바운드 요청 메시지에서 적절한 Via 헤더 필드를 보내야하고 전달 된 응답 메시지에서 Via 헤더 필드를 보낼 수 있습니다. 각 중개자에 대해 수신 된 프로토콜은 메시지의 업스트림 발신자가 사용하는 프로토콜 및 프로토콜 버전을 나타냅니다. 그 후,Via 필드 값은 요청 / 응답 체인의 알려진 프로토콜 기능을 다운 스트림 수신자가 볼 수 있도록 기록합니다. 이는 이전 버전과 호환되지 않는 기능이 응답 또는 나중에 요청에서 사용하기에 안전한지 확인하는 데 유용 할 수 있습니다.&lt;a href=&quot;#section-2.6&quot;&gt;섹션 2.6&lt;/a&gt;. 간결하게하기 위해 수신 된 프로토콜이 HTTP 인 경우 protocol-name이 생략됩니다. 필드 값의 수신 한 부분은 일반적으로 메시지를 전달한 수신자 서버 또는 클라이언트의 호스트 및 선택적 포트 번호입니다. 그러나 실제 호스트가 민감한 정보로 간주되는 경우 발신자는이 정보를 가명으로 대체 할 수 있습니다. 포트가 제공되지 않으면, 수신자는 수신 된 프로토콜에 대해 기본 TCP 포트 (있는 경우)에서 수신되었음을 의미하는 것으로 해석 할 수 있습니다. 발신자는 사용자 헤더 및 서버 헤더 필드와 유사하게 각 수신자의 소프트웨어를 식별하기 위해 Via 헤더 필드에 주석을 생성 할 수 있습니다. 그러나 Via 필드의 모든 주석은 선택 사항이며 수신자는 메시지를 전달하기 전에 주석을 제거 할 수 있습니다. 예를 들어요청 메시지는 HTTP / 1.0 사용자 에이전트에서 내부 프록시 코드 이름 &quot;fred&quot;로 전송 될 수 있습니다.이 프록시는 HTTP / 1.1을 사용하여 p.example.net의 공개 프록시로 요청을 전달합니다. www.example.com의 오리진 서버로 연결하십시오. www.example.com이 수신 한 요청에는 다음 Via 헤더 필드가 있습니다. Via : 1.0 fred, 1.1 p.example.net 네트워크 방화벽을 통해 포털로 사용되는 중개자는 호스트 이름과 포트를 전달해서는 안됩니다. 방화벽 영역이 명시 적으로 활성화되지 않은 경우 방화벽 영역 활성화되지 않은 경우, 그러한 중개자는 방화벽 뒤에있는 호스트의 각 수신 호스트를 해당 호스트에 대한 적절한 가명으로 교체해야합니다.항목이 동일한 수신 프로토콜 값을 갖는 경우 중개자는 Via 헤더 필드 항목의 순서가 지정된 서브 시퀀스를 단일 항목으로 결합 할 수있다. 예를 들어, Via : 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy는 Via : 1.0 ricky, 1.1 mertz, 1.0 lucy로 축소 될 수 있습니다. 발신자는 모두 같은 조직 제어하에 있지 않고 호스트가 이미 가명으로 대체되었습니다. 발신자는 다른 수신 프로토콜 값을 가진 항목을 결합해서는 안됩니다 (MUST NOT).lucy 발신자는 모두 같은 조직 통제하에 있고 호스트가 이미 가명으로 대체되지 않는 한 여러 항목을 결합해서는 안됩니다. 발신자는 다른 수신 프로토콜 값을 가진 항목을 결합해서는 안됩니다 (MUST NOT).0 lucy 발신자는 모두 같은 조직 통제하에 있고 호스트가 이미 가명으로 대체되지 않는 한 여러 항목을 결합해서는 안됩니다. 발신자는 다른 수신 프로토콜 값을 가진 항목을 결합해서는 안됩니다 (MUST NOT).</target>
        </trans-unit>
        <trans-unit id="9867a861577bfb6c81de727cf7f2304bd8cb13b4" translate="yes" xml:space="preserve">
          <source>The &quot;WWW-Authenticate&quot; header field indicates the authentication
   scheme(s) and parameters applicable to the target resource.

     WWW-Authenticate = 1#challenge

   A server generating a 401 (Unauthorized) response MUST send a
   WWW-Authenticate header field containing at least one challenge.  A
   server MAY generate a WWW-Authenticate header field in other response
   messages to indicate that supplying credentials (or different
   credentials) might affect the response.

   A proxy forwarding a response MUST NOT modify any WWW-Authenticate
   fields in that response.

   User agents are advised to take special care in parsing the field
   value, as it might contain more than one challenge, and each
   challenge can contain a comma-separated list of authentication
   parameters.  Furthermore, the header field itself can occur multiple
   times.

   For instance:

     WWW-Authenticate: Newauth realm=&quot;apps&quot;, type=1,
                       title=&quot;Login to \&quot;apps\&quot;&quot;, Basic realm=&quot;simple&quot;

   This header field contains two challenges; one for the &quot;Newauth&quot;
   scheme with a realm value of &quot;apps&quot;, and two additional parameters
   &quot;type&quot; and &quot;title&quot;, and another one for the &quot;Basic&quot; scheme with a
   realm value of &quot;simple&quot;.

      Note: The challenge grammar production uses the list syntax as
      well.  Therefore, a sequence of comma, whitespace, and comma can
      be considered either as applying to the preceding challenge, or to
      be an empty entry in the list of challenges.  In practice, this
      ambiguity does not affect the semantics of the header field value
      and thus is harmless.</source>
          <target state="translated">&quot;WWW-Authenticate&quot;헤더 필드는 대상 자원에 적용 가능한 인증 체계 및 매개 변수를 나타냅니다. WWW-Authenticate = 1 # challenge 401 (무단) 응답을 생성하는 서버는 적어도 하나의 챌린지를 포함하는 WWW-Authenticate 헤더 필드를 보내야합니다. 서버는 다른 응답 메시지에서 WWW-Authenticate 헤더 필드를 생성하여 자격 증명 (또는 다른 자격 증명)을 제공하면 응답에 영향을 줄 수 있음을 나타낼 수 있습니다. 응답을 전달하는 프록시는 해당 응답의 WWW 인증 필드를 수정해서는 안됩니다. 사용자 에이전트는 필드 값을 구문 분석 할 때 특히주의해야합니다. 필드 값은 둘 이상의 시도를 포함 할 수 있으며 각 시도는 쉼표로 구분 된 인증 매개 변수 목록을 포함 할 수 있습니다. 더욱이,헤더 필드 자체는 여러 번 발생할 수 있습니다. 예 : WWW-Authenticate : Newauth realm = &quot;apps&quot;, type = 1, title = &quot;\&quot;apps \ &quot;&quot;에 로그인, 기본 realm = &quot;simple&quot;이 헤더 필드에는 두 가지 과제가 있습니다. 하나는 영역 값이 &quot;apps&quot;인 &quot;Newauth&quot;체계를위한 것이고 두 개의 추가 매개 변수는 &quot;type&quot;과 &quot;title&quot;이고 다른 하나는 영역 값이 &quot;simple&quot;인 &quot;Basic&quot;체계를위한 것입니다. 참고 : 챌린지 문법 제작은 목록 구문도 사용합니다. 따라서 쉼표, 공백 및 쉼표 시퀀스는 이전 챌린지에 적용되거나 챌린지 목록의 빈 항목으로 간주 될 수 있습니다. 실제로,이 모호성은 헤더 필드 값의 의미론에 영향을 미치지 않으므로 무해합니다.</target>
        </trans-unit>
        <trans-unit id="010ba1a9ad73a34753b90adf3c72f63de66025ee" translate="yes" xml:space="preserve">
          <source>The &quot;Warning&quot; header field is used to carry additional information
   about the status or transformation of a message that might not be
   reflected in the status code.  This information is typically used to
   warn about possible incorrectness introduced by caching operations or
   transformations applied to the payload of the message. 

   Warnings can be used for other purposes, both cache-related and
   otherwise.  The use of a warning, rather than an error status code,
   distinguishes these responses from true failures.

   Warning header fields can in general be applied to any message,
   however some warn-codes are specific to caches and can only be
   applied to response messages.

     Warning       = 1#warning-value

     warning-value = warn-code SP warn-agent SP warn-text
                                           [ SP warn-date ]

     warn-code  = 3DIGIT
     warn-agent = ( uri-host [ &quot;:&quot; port ] ) / pseudonym
                     ; the name or pseudonym of the server adding
                     ; the Warning header field, for use in debugging
                     ; a single &quot;-&quot; is recommended when agent unknown
     warn-text  = quoted-string
     warn-date  = DQUOTE HTTP-date DQUOTE

   Multiple warnings can be generated in a response (either by the
   origin server or by a cache), including multiple warnings with the
   same warn-code number that only differ in warn-text.

   A user agent that receives one or more Warning header fields SHOULD
   inform the user of as many of them as possible, in the order that
   they appear in the response.  Senders that generate multiple Warning
   header fields are encouraged to order them with this user agent
   behavior in mind.  A sender that generates new Warning header fields
   MUST append them after any existing Warning header fields.

   Warnings are assigned three digit warn-codes.  The first digit
   indicates whether the Warning is required to be deleted from a stored
   response after validation:

   o  1xx warn-codes describe the freshness or validation status of the
      response, and so they MUST be deleted by a cache after validation.
      They can only be generated by a cache when validating a cached
      entry, and MUST NOT be generated in any other situation.

   o  2xx warn-codes describe some aspect of the representation that is
      not rectified by a validation (for example, a lossy compression of
      the representation) and they MUST NOT be deleted by a cache after
      validation, unless a full response is sent, in which case they
      MUST be. 

   If a sender generates one or more 1xx warn-codes in a message to be
   sent to a recipient known to implement only HTTP/1.0, the sender MUST
   include in each corresponding warning-value a warn-date that matches
   the Date header field in the message.  For example:

     HTTP/1.1 200 OK
     Date: Sat, 25 Aug 2012 23:34:45 GMT
     Warning: 112 - &quot;network down&quot; &quot;Sat, 25 Aug 2012 23:34:45 GMT&quot;


   Warnings have accompanying warn-text that describes the error, e.g.,
   for logging.  It is advisory only, and its content does not affect
   interpretation of the warn-code.

   If a recipient that uses, evaluates, or displays Warning header
   fields receives a warn-date that is different from the Date value in
   the same message, the recipient MUST exclude the warning-value
   containing that warn-date before storing, forwarding, or using the
   message.  This allows recipients to exclude warning-values that were
   improperly retained after a cache validation.  If all of the
   warning-values are excluded, the recipient MUST exclude the Warning
   header field as well.

   The following warn-codes are defined by this specification, each with
   a recommended warn-text in English, and a description of its meaning.
   The procedure for defining additional warn codes is described in
   &lt;a href=&quot;#section-7.2.1&quot;&gt;Section 7.2.1&lt;/a&gt;.</source>
          <target state="translated">&quot;경고&quot;헤더 필드는 상태 코드에 반영되지 않을 수있는 메시지의 상태 또는 변환에 대한 추가 정보를 전달하는 데 사용됩니다. 이 정보는 일반적으로 메시지의 페이로드에 적용된 캐싱 조작 또는 변환으로 인해 발생할 수있는 부정확성을 경고하는 데 사용됩니다. 캐시 관련 및 기타 다른 목적으로 경고를 사용할 수 있습니다. 오류 상태 코드 대신 경고를 사용하면 이러한 응답이 실제 실패와 구분됩니다. 경고 헤더 필드는 일반적으로 모든 메시지에 적용 할 수 있지만 일부 경고 코드는 캐시에만 적용되며 응답 메시지에만 적용 할 수 있습니다.경고 = 1 # 경고 값 경고 값 = 경고 코드 SP 경고 에이전트 SP 경고 텍스트 [SP 경고 날짜] 경고 코드 = 3DIGIT 경고 에이전트 = (uri-host [ &quot;:&quot;포트]) / 가명 ; 추가하는 서버의 이름 또는 가명; 디버깅에 사용되는 경고 헤더 필드; 에이전트가 알려지지 않은 경우 단일 &quot;-&quot;가 권장됩니다. warn-text = quoted-string warn-date = DQUOTE HTTP-date DQUOTE 여러 경고를 포함한 여러 경고를 포함하여 응답에서 (원본 서버 또는 캐시에 의해) 여러 경고를 생성 할 수 있습니다. 경고 텍스트 만 다른 동일한 경고 코드 번호 하나 이상의 경고 헤더 필드를받는 사용자 에이전트는 가능한 많은 필드를 사용자에게 알려야합니다.응답에 나타나는 순서대로. 여러 경고 헤더 필드를 생성하는 발신인은이 사용자 에이전트 동작을 염두에두고 주문하는 것이 좋습니다. 새로운 경고 헤더 필드를 생성하는 발신자는 기존 경고 헤더 필드 뒤에 추가해야합니다. 경고에는 세 자리 경고 코드가 할당됩니다. 첫 번째 숫자는 유효성 검증 후 저장된 응답에서 경고를 삭제해야하는지 여부를 나타냅니다. o 1xx 경고 코드는 응답의 최신 성 또는 유효성 검증 상태를 설명하므로 유효성 검증 후 캐시에 의해 삭제되어야합니다. 캐시 된 항목의 유효성을 검사 할 때 캐시에 의해서만 생성 될 수 있으며 다른 상황에서는 생성되지 않아야합니다.o 2xx 경고 코드는 유효성 검증에 의해 수정되지 않은 표현의 일부 측면을 설명하며 (예를 들어, 표현의 손실 압축) 전체 응답이 전송되지 않는 한 유효성 검증 후 캐시에 의해 삭제되지 않아야합니다. 경우에 따라야합니다. 발신자가 메시지에 하나 이상의 1xx 경고 코드를 생성하여 HTTP / 1.0 만 구현하는 것으로 알려진 수신자에게 보내려면 발신자는 각 해당 경고 값에 경고의 날짜 헤더 필드와 일치하는 경고 날짜를 포함해야합니다. 메시지. 예 : HTTP / 1.1 200 OK 날짜 : 2012 년 8 월 25 일 토요일 23:34:45 GMT 경고 : 112- &quot;네트워크 중단&quot; &quot;2012 년 8 월 25 일 토요일 23:34:45 GMT&quot;경고에는 경고 텍스트가 포함되어 있습니다. 예를 들어 로깅과 같은 오류. 자문 일뿐입니다그 내용은 경고 코드의 해석에 영향을 미치지 않습니다. 경고 헤더 필드를 사용, 평가 또는 표시하는 수신자가 동일한 메시지의 날짜 값과 다른 경고 날짜를 수신하는 경우, 수신자는 저장, 전달 또는 사용하기 전에 해당 경고 날짜를 포함하는 경고 값을 제외해야합니다. 메시지. 이를 통해 수신자는 캐시 유효성 검사 후에 잘못 유지 된 경고 값을 제외 할 수 있습니다. 모든 경고 값이 제외되면 수신자는 반드시 경고 헤더 필드도 제외해야합니다. 다음 경고 코드는이 사양에 의해 정의되며 각각 영어로 권장되는 경고 텍스트와 그 의미에 대한 설명이 있습니다. 추가 경고 코드를 정의하는 절차는경고 헤더 필드를 사용, 평가 또는 표시하는 수신자가 동일한 메시지의 날짜 값과 다른 경고 날짜를 수신하는 경우, 수신자는 저장, 전달 또는 사용하기 전에 해당 경고 날짜를 포함하는 경고 값을 제외해야합니다. 메시지. 이를 통해 수신자는 캐시 유효성 검사 후에 잘못 유지 된 경고 값을 제외 할 수 있습니다. 모든 경고 값이 제외되면 수신자는 반드시 경고 헤더 필드도 제외해야합니다. 다음 경고 코드는이 사양에서 정의되며 각각 영어로 권장되는 경고 텍스트와 그 의미에 대한 설명이 있습니다. 추가 경고 코드를 정의하는 절차는경고 헤더 필드를 사용, 평가 또는 표시하는 수신자가 동일한 메시지의 날짜 값과 다른 경고 날짜를 수신하는 경우, 수신자는 저장, 전달 또는 사용하기 전에 해당 경고 날짜를 포함하는 경고 값을 제외해야합니다. 메시지. 이를 통해 수신자는 캐시 유효성 검사 후에 잘못 유지 된 경고 값을 제외 할 수 있습니다. 모든 경고 값이 제외되면 수신자는 반드시 경고 헤더 필드도 제외해야합니다. 다음 경고 코드는이 사양에서 정의되며 각각 영어로 권장되는 경고 텍스트와 그 의미에 대한 설명이 있습니다. 추가 경고 코드를 정의하는 절차는또는 경고 헤더 필드에 동일한 메시지의 날짜 값과 다른 경고 날짜가 표시되면 수신자는 메시지를 저장, 전달 또는 사용하기 전에 경고 날짜가 포함 된 경고 값을 제외해야합니다. 이를 통해 수신자는 캐시 유효성 검사 후에 잘못 유지 된 경고 값을 제외 할 수 있습니다. 모든 경고 값이 제외되면 수신자는 반드시 경고 헤더 필드도 제외해야합니다. 다음 경고 코드는이 사양에서 정의되며 각각 영어로 권장되는 경고 텍스트와 그 의미에 대한 설명이 있습니다. 추가 경고 코드를 정의하는 절차는또는 경고 헤더 필드에 동일한 메시지의 날짜 값과 다른 경고 날짜가 표시되면 수신자는 메시지를 저장, 전달 또는 사용하기 전에 경고 날짜가 포함 된 경고 값을 제외해야합니다. 이를 통해 수신자는 캐시 유효성 검사 후에 잘못 유지 된 경고 값을 제외 할 수 있습니다. 모든 경고 값이 제외되면 수신자는 반드시 경고 헤더 필드도 제외해야합니다. 다음 경고 코드는이 사양에서 정의되며 각각 영어로 권장되는 경고 텍스트와 그 의미에 대한 설명이 있습니다. 추가 경고 코드를 정의하는 절차는이를 통해 수신자는 캐시 유효성 검사 후에 잘못 유지 된 경고 값을 제외 할 수 있습니다. 모든 경고 값이 제외되면 수신자는 반드시 경고 헤더 필드도 제외해야합니다. 다음 경고 코드는이 사양에 의해 정의되며 각각 영어로 권장되는 경고 텍스트와 그 의미에 대한 설명이 있습니다. 추가 경고 코드를 정의하는 절차는이를 통해 수신자는 캐시 유효성 검사 후에 잘못 유지 된 경고 값을 제외 할 수 있습니다. 모든 경고 값이 제외되면 수신자는 반드시 경고 헤더 필드도 제외해야합니다. 다음 경고 코드는이 사양에서 정의되며 각각 영어로 권장되는 경고 텍스트와 그 의미에 대한 설명이 있습니다. 추가 경고 코드를 정의하는 절차는 &lt;a href=&quot;#section-7.2.1&quot;&gt;섹션 7.2.1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="995d6efd3e0c66344c9a13f1a4baae749a8853bd" translate="yes" xml:space="preserve">
          <source>The &quot;app:categories&quot; element provides a list of the categories that
   can be applied to the members of a Collection.  See &lt;a href=&quot;#section-7.2.1&quot;&gt;Section 7.2.1&lt;/a&gt; for
   the detailed definition of app:categories.

   The server MAY reject attempts to create or store members whose
   categories are not present in its categories list.  A Collection that
   indicates the category set is open SHOULD NOT reject otherwise
   acceptable members whose categories are not in its categories list.
   The absence of an app:categories element means that the category
   handling of the Collection is unspecified.  A &quot;fixed&quot; category list
   that contains zero categories indicates the Collection does not
   accept category data.</source>
          <target state="translated">&quot;app : categories&quot;요소는 Collection의 멤버에 적용 할 수있는 카테고리 목록을 제공합니다. app : categories의 자세한 정의는 &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1 절을&lt;/a&gt; 참조하십시오 . 서버는 범주 목록에 범주가없는 구성원을 만들거나 저장하려는 시도를 거부 할 수 있습니다. 카테고리 세트가 열려 있음을 나타내는 컬렉션은 카테고리가 카테고리 목록에없는 다른 허용 가능한 멤버를 거부해서는 안됩니다 (SHOULD NOT). app : categories 요소가 없다는 것은 Collection의 카테고리 처리가 지정되지 않았 음을 의미합니다. 범주가 0 인 &quot;고정&quot;범주 목록은 컬렉션이 범주 데이터를 허용하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2862e4bbac71e75234686e57a0b3abd15c18ac9a" translate="yes" xml:space="preserve">
          <source>The &quot;app:collection&quot; element describes a Collection.  The app:
   collection element MUST contain one atom:title element.

   The app:collection element MAY contain any number of app:accept
   elements, indicating the types of representations accepted by the
   Collection.  The order of such elements is not significant.

   The app:collection element MAY contain any number of app:categories
   elements.

   appCollection =
      element app:collection {
         appCommonAttributes,
         attribute href { atomURI  },
         ( atomTitle
           &amp;amp; appAccept*
           &amp;amp; appCategories*
           &amp;amp; extensionSansTitleElement* )
      }</source>
          <target state="translated">&quot;app : collection&quot;요소는 Collection을 설명합니다. app : collection 요소는 atom : title 요소를 포함해야합니다. app : collection 요소는 Collection에서 허용되는 표현의 유형을 나타내는 app : accept 요소를 얼마든지 포함 할 수 있습니다. 이러한 요소의 순서는 중요하지 않습니다. app : collection 요소는 app : categories 요소를 포함 할 수 있습니다. appCollection = 요소 app : collection {appCommonAttributes, 속성 href {atomURI}, (atomTitle &amp;amp; appAccept * &amp;amp; appCategories * &amp;amp; extensionSansTitleElement *)}</target>
        </trans-unit>
        <trans-unit id="4f92b1bc26a73cb4af47cd72166377ea0b007dfa" translate="yes" xml:space="preserve">
          <source>The &quot;app:edited&quot; element is a Date construct (as defined by
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;]), whose content indicates the last time an Entry was
   edited.  If the entry has not been edited yet, the content indicates
   the time it was created.  Atom Entry elements in Collection Documents
   SHOULD contain one app:edited element, and MUST NOT contain more than
   one.

   appEdited = element app:edited ( atomDateConstruct )

   The server SHOULD change the value of this element every time an
   Entry Resource or an associated Media Resource has been edited.</source>
          <target state="translated">&quot;app : edited&quot;요소는 날짜 구성 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]에 의해 정의 됨 )이며, 해당 내용은 항목이 마지막으로 편집 된 시간을 나타냅니다. 항목이 아직 편집되지 않은 경우 내용은 생성 된 시간을 나타냅니다. 컬렉션 문서의 원자 엔트리 요소는 하나의 app : edited 요소를 포함해야하며, 둘 이상의 요소를 포함해서는 안됩니다. appEdited = element app : edited (atomDateConstruct) 서버는 Entry Resource 또는 관련 Media Resource가 편집 될 때마다이 요소의 값을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="68f4c11acf63f6cde7cb7434dea073f5a30ec84b" translate="yes" xml:space="preserve">
          <source>The &quot;atom:title&quot; element is defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] and gives a human-
   readable title for the Collection.</source>
          <target state="translated">&quot;atom : title&quot;요소는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]에 정의되어 있으며 사람이 읽을 수있는 컬렉션 제목을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="409b2e89b2d86b6bfc0d29cd3e58e574f2822ac5" translate="yes" xml:space="preserve">
          <source>The &quot;compress&quot; coding is an adaptive Lempel-Ziv-Welch (LZW) coding
   [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;] that is commonly produced by the UNIX file compression
   program &quot;compress&quot;.  A recipient SHOULD consider &quot;x-compress&quot; to be
   equivalent to &quot;compress&quot;.</source>
          <target state="translated">&quot;압축&quot;코딩은 UNIX 파일 압축 프로그램 &quot;압축&quot;에 의해 일반적으로 생성되는 LZW (Adaptive Lempel-Ziv-Welch) 코딩 [ &lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt; ]입니다. 수신자는 &quot;x-compress&quot;를 &quot;compress&quot;와 동등한 것으로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="5450639421b7ec9a5bfb9b3a5351d2c59960ee2f" translate="yes" xml:space="preserve">
          <source>The &quot;data&quot; URL scheme</source>
          <target state="translated">&quot;데이터&quot;URL 체계</target>
        </trans-unit>
        <trans-unit id="7fec5b6deed76c5c2f6df9fc9a93ea6b5f359e93" translate="yes" xml:space="preserve">
          <source>The &quot;deflate&quot; coding is a &quot;zlib&quot; data format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;] containing a
   &quot;deflate&quot; compressed data stream [&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;] that uses a combination of
   the Lempel-Ziv (LZ77) compression algorithm and Huffman coding.

      Note: Some non-conformant implementations send the &quot;deflate&quot;
      compressed data without the zlib wrapper.</source>
          <target state="translated">&quot;deflate&quot;코딩은 Lempel-Ziv (LZ77) 압축 알고리즘과 Huffman 코딩의 조합을 사용하는 &quot;deflate&quot;압축 데이터 스트림 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ]을 포함 하는 &quot;zlib&quot;데이터 형식 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt; ] 입니다. 참고 : 일부 부적합 구현에서는 zlib 래퍼없이 &quot;deflate&quot;압축 데이터를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="18f6fc86dc33b8be8746e1979432c3044e14ee93" translate="yes" xml:space="preserve">
          <source>The &quot;gzip&quot; coding is an LZ77 coding with a 32-bit Cyclic Redundancy
   Check (CRC) that is commonly produced by the gzip file compression
   program [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;].  A recipient SHOULD consider &quot;x-gzip&quot; to be
   equivalent to &quot;gzip&quot;.</source>
          <target state="translated">&quot;gzip&quot;코딩은 gzip 파일 압축 프로그램 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ] 에서 일반적으로 생성되는 32 비트 CRC (Cyclic Redundancy Check)를 사용하는 LZ77 코딩입니다 . 수신자는 &quot;x-gzip&quot;을 &quot;gzip&quot;과 동등한 것으로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="3da79a4d757a4b703e27456e900e76eca528f808" translate="yes" xml:space="preserve">
          <source>The &quot;http&quot; URI scheme is hereby defined for the purpose of minting
   identifiers according to their association with the hierarchical
   namespace governed by a potential HTTP origin server listening for
   TCP ([&lt;a href=&quot;https://tools.ietf.org/html/rfc0793&quot;&gt;RFC0793&lt;/a&gt;]) connections on a given port.

     http-URI = &quot;http:&quot; &quot;//&quot; authority path-abempty [ &quot;?&quot; query ]
                [ &quot;#&quot; fragment ]

   The origin server for an &quot;http&quot; URI is identified by the authority
   component, which includes a host identifier and optional TCP port
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.2&lt;/a&gt;).  The hierarchical path component and
   optional query component serve as an identifier for a potential
   target resource within that origin server's name space.  The optional
   fragment component allows for indirect identification of a secondary
   resource, independent of the URI scheme, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;Section&amp;nbsp;3.5 of
   [RFC3986]&lt;/a&gt;.

   A sender MUST NOT generate an &quot;http&quot; URI with an empty host
   identifier.  A recipient that processes such a URI reference MUST
   reject it as invalid.

   If the host identifier is provided as an IP address, the origin
   server is the listener (if any) on the indicated TCP port at that IP
   address.  If host is a registered name, the registered name is an
   indirect identifier for use with a name resolution service, such as
   DNS, to find an address for that origin server.  If the port
   subcomponent is empty or not given, TCP port 80 (the reserved port
   for WWW services) is the default.

   Note that the presence of a URI with a given authority component does
   not imply that there is always an HTTP server listening for
   connections on that host and port.  Anyone can mint a URI.  What the
   authority component determines is who has the right to respond
   authoritatively to requests that target the identified resource.  The
   delegated nature of registered names and IP addresses creates a
   federated namespace, based on control over the indicated host and
   port, whether or not an HTTP server is present.  See &lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt; for
   security considerations related to establishing authority.

   When an &quot;http&quot; URI is used within a context that calls for access to
   the indicated resource, a client MAY attempt access by resolving the
   host to an IP address, establishing a TCP connection to that address
   on the indicated port, and sending an HTTP request message
   (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) containing the URI's identifying data (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;) to the
   server.  If the server responds to that request with a non-interim 

   HTTP response message, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC7231]&lt;/a&gt;, then
   that response is considered an authoritative answer to the client's
   request.

   Although HTTP is independent of the transport protocol, the &quot;http&quot;
   scheme is specific to TCP-based services because the name delegation
   process depends on TCP for establishing authority.  An HTTP service
   based on some other underlying connection protocol would presumably
   be identified using a different URI scheme, just as the &quot;https&quot;
   scheme (below) is used for resources that require an end-to-end
   secured connection.  Other protocols might also be used to provide
   access to &quot;http&quot; identified resources -- it is only the authoritative
   interface that is specific to TCP.

   The URI generic syntax for authority also includes a deprecated
   userinfo subcomponent (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.1&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.1&lt;/a&gt;) for including user
   authentication information in the URI.  Some implementations make use
   of the userinfo component for internal configuration of
   authentication information, such as within command invocation
   options, configuration files, or bookmark lists, even though such
   usage might expose a user identifier or password.  A sender MUST NOT
   generate the userinfo subcomponent (and its &quot;@&quot; delimiter) when an
   &quot;http&quot; URI reference is generated within a message as a request
   target or header field value.  Before making use of an &quot;http&quot; URI
   reference received from an untrusted source, a recipient SHOULD parse
   for userinfo and treat its presence as an error; it is likely being
   used to obscure the authority for the sake of phishing attacks.</source>
          <target state="translated">&quot;http&quot;URI 스킴은 주어진 포트에서 TCP ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc0793&quot;&gt;RFC0793&lt;/a&gt; ]) 연결을 수신하는 잠재적 HTTP 오리진 서버에 의해 관리되는 계층 적 네임 스페이스와의 연관성에 따라 식별 식별자를 작성하기 위해 정의됩니다 . http-URI = &quot;http :&quot; &quot;//&quot;권한 경로 비우기 [ &quot;?&quot; query] [ &quot;#&quot;fragment] &quot;http&quot;URI의 오리진 서버는 권한 구성 요소로 식별되며 여기에는 호스트 ID 및 선택적 TCP 포트가 포함되어 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], 섹션 3.2.2&lt;/a&gt;). 계층 적 경로 구성 요소 및 선택적 쿼리 구성 요소는 해당 원본 서버의 네임 스페이스 내에서 잠재적 인 대상 리소스의 식별자로 사용됩니다. 선택적 프래그먼트 컴포넌트는 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986]의 3.5 절에&lt;/a&gt; 정의 된대로 URI 체계와 무관하게 보조 리소스를 간접적으로 식별 할 수 있습니다 .. 발신자는 빈 호스트 식별자로 &quot;http&quot;URI를 생성해서는 안됩니다 (MUST NOT). 이러한 URI 참조를 처리하는 수신자는이를 무효로 거부해야합니다. 호스트 ID가 IP 주소로 제공되는 경우, 오리진 서버는 해당 IP 주소에서 표시된 TCP 포트의 리스너 (있는 경우)입니다. 호스트가 등록 된 이름 인 경우 등록 된 이름은 DNS와 같은 이름 확인 서비스에서 해당 원본 서버의 주소를 찾기위한 간접 식별자입니다. 포트 하위 구성 요소가 비어 있거나 제공되지 않은 경우 TCP 포트 80 (WWW 서비스 용 예약 포트)이 기본값입니다. 지정된 권한 구성 요소가있는 URI가 있다고해서 해당 호스트 및 포트에서 연결을 청취하는 HTTP 서버가 항상 있음을 의미하지는 않습니다. 누구나 URI를 작성할 수 있습니다.권한 구성 요소가 판별하는 것은 식별 된 자원을 대상으로하는 요청에 정식으로 응답 할 권한이있는 사람입니다. 등록 된 이름 및 IP 주소의 위임 된 특성은 HTTP 서버의 존재 여부에 관계없이 표시된 호스트 및 포트에 대한 제어를 기반으로 연합 네임 스페이스를 만듭니다. 보다&lt;a href=&quot;#section-9.1&quot;&gt;&lt;/a&gt;권한 설정과 관련된 보안 고려 사항에 대한 섹션 9.1 . &quot;http&quot;URI가 표시된 리소스에 대한 액세스를 요청하는 컨텍스트 내에서 사용될 경우 클라이언트는 호스트를 IP 주소로 확인하고 표시된 포트에서 해당 주소에 대한 TCP 연결을 설정하고 HTTP를 전송하여 액세스를 시도 할 수 있습니다. 서버에 URI의 식별 데이터를 포함하는 요청 메시지 ( &lt;a href=&quot;#section-3&quot;&gt;섹션 3&lt;/a&gt; ) ( &lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt; ). &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6&quot;&gt;[RFC7231]의 6 절에&lt;/a&gt; 설명 된 것처럼 서버가 임시가 아닌 HTTP 응답 메시지로 해당 요청에 응답하는 경우이 응답은 고객의 요청에 대한 정식 답변으로 간주됩니다. HTTP는 전송 프로토콜과 독립적이지만 &quot;http&quot;체계는 이름 위임 프로세스가 권한을 설정하기 위해 TCP에 의존하기 때문에 TCP 기반 서비스에만 적용됩니다. &quot;https&quot;체계 (아래)가 종단 간 보안 연결이 필요한 자원에 사용되는 것처럼 다른 기본 연결 프로토콜을 기반으로하는 HTTP 서비스는 다른 URI 체계를 사용하여 식별 될 수 있습니다. &quot;http&quot;로 식별 된 리소스에 대한 액세스를 제공하기 위해 다른 프로토콜이 사용될 수도 있습니다. TCP와 관련된 권한있는 인터페이스 일뿐입니다. 권한에 대한 URI 일반 구문에는 더 이상 사용되지 않는 userinfo 하위 구성 요소 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.1&quot;&gt;[RFC3986], 섹션 3.2&lt;/a&gt; 도 포함됩니다 .1URI에 사용자 인증 정보를 포함합니다. 일부 구현에서는 명령 호출 옵션, 구성 파일 또는 책갈피 목록 내에서와 같이 인증 정보의 내부 구성에 userinfo 구성 요소를 사용하지만 이러한 사용법으로 인해 사용자 ID 또는 비밀번호가 노출 될 수 있습니다. 발신인은 &quot;http&quot;URI 참조가 요청 대상 또는 헤더 필드 값으로 메시지 내에 생성 될 때 userinfo 하위 구성 요소 (및 &quot;@&quot;분리 문자)를 생성해서는 안됩니다 (MUST NOT). 신뢰할 수없는 출처로부터받은 &quot;http&quot;URI 참조를 사용하기 전에 수신자는 userinfo를 구문 분석하고 그 존재를 오류로 처리해야합니다. 피싱 공격에 대한 권한을 가릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8a58311de89d4c408e7b65f13ca2deebb29dec3" translate="yes" xml:space="preserve">
          <source>The &quot;http&quot; scheme is used to locate network resources via the HTTP
   protocol. This section defines the scheme-specific syntax and
   semantics for http URLs.

   http_URL = &quot;http:&quot; &quot;//&quot; host [ &quot;:&quot; port ] [ abs_path [ &quot;?&quot; query ]]

   If the port is empty or not given, port 80 is assumed. The semantics
   are that the identified resource is located at the server listening
   for TCP connections on that port of that host, and the Request-URI
   for the resource is abs_path (&lt;a href=&quot;#section-5.1.2&quot;&gt;section 5.1.2&lt;/a&gt;). The use of IP addresses
   in URLs SHOULD be avoided whenever possible (see &lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;RFC 1900&lt;/a&gt; [&lt;a href=&quot;#ref-24&quot;&gt;24&lt;/a&gt;]). If
   the abs_path is not present in the URL, it MUST be given as &quot;/&quot; when
   used as a Request-URI for a resource (&lt;a href=&quot;#section-5.1.2&quot;&gt;section 5.1.2&lt;/a&gt;). If a proxy
   receives a host name which is not a fully qualified domain name, it
   MAY add its domain to the host name it received. If a proxy receives
   a fully qualified domain name, the proxy MUST NOT change the host
   name.</source>
          <target state="translated">&quot;http&quot;체계는 HTTP 프로토콜을 통해 네트워크 리소스를 찾는 데 사용됩니다. 이 섹션에서는 http URL에 대한 체계 별 구문과 의미를 정의합니다. http_URL = &quot;http :&quot; &quot;//&quot;호스트 [ &quot;:&quot;port] [abs_path [ &quot;?&quot; query]] 포트가 비어 있거나 제공되지 않은 경우 포트 80이 사용됩니다. 의미는 식별 된 자원이 해당 호스트의 해당 포트에서 TCP 연결을 청취하는 서버에 위치하고 자원의 Request-URI가 abs_path ( &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2 절&lt;/a&gt; )라는 것입니다. URL에서 IP 주소 사용은 가능하면 피해야합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;RFC 1900&lt;/a&gt; [ &lt;a href=&quot;#ref-24&quot;&gt;24&lt;/a&gt; ] 참조). 만약 abs_path가 URL에 존재하지 않는다면, 리소스에 대한 Request-URI로 사용될 때 반드시 &quot;/&quot;로 주어져야한다 &lt;a href=&quot;#section-5.1.2&quot;&gt;(5.1 절).2&lt;/a&gt;). 프록시가 정규화 된 도메인 이름이 아닌 호스트 이름을 수신하면 수신 한 호스트 이름에 도메인을 추가 할 수 있습니다. 프록시가 정규화 된 도메인 이름을 수신하면 프록시는 호스트 이름을 변경해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="73555a35c2933a1c75aa810e673714fa36744ea0" translate="yes" xml:space="preserve">
          <source>The &quot;https&quot; URI scheme is hereby defined for the purpose of minting
   identifiers according to their association with the hierarchical
   namespace governed by a potential HTTP origin server listening to a
   given TCP port for TLS-secured connections ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]).

   All of the requirements listed above for the &quot;http&quot; scheme are also
   requirements for the &quot;https&quot; scheme, except that TCP port 443 is the
   default if the port subcomponent is empty or not given, and the user
   agent MUST ensure that its connection to the origin server is secured
   through the use of strong encryption, end-to-end, prior to sending
   the first HTTP request.

     https-URI = &quot;https:&quot; &quot;//&quot; authority path-abempty [ &quot;?&quot; query ]
                 [ &quot;#&quot; fragment ]

   Note that the &quot;https&quot; URI scheme depends on both TLS and TCP for
   establishing authority.  Resources made available via the &quot;https&quot;
   scheme have no shared identity with the &quot;http&quot; scheme even if their 

   resource identifiers indicate the same authority (the same host
   listening to the same TCP port).  They are distinct namespaces and
   are considered to be distinct origin servers.  However, an extension
   to HTTP that is defined to apply to entire host domains, such as the
   Cookie protocol [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;], can allow information set by one service
   to impact communication with other services within a matching group
   of host domains.

   The process for authoritative access to an &quot;https&quot; identified
   resource is defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;].</source>
          <target state="translated">&quot;https&quot;URI 스킴은 TLS 보안 연결을 위해 주어진 TCP 포트를 수신하는 잠재적 HTTP 오리진 서버에 의해 관리되는 계층 적 네임 스페이스와의 연관성에 따라 식별 식별자를 작성하기 위해 정의됩니다 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246).&lt;/a&gt;]). 포트 하위 구성 요소가 비어 있거나 제공되지 않은 경우 TCP 포트 443이 기본값이고 사용자 에이전트가 반드시 연결을 확인해야한다는 점을 제외하고, &quot;http&quot;체계에 대해 위에 나열된 모든 요구 사항은 &quot;https&quot;체계에 대한 요구 사항이기도합니다. 오리진 서버는 첫 번째 HTTP 요청을 보내기 전에 엔드 투 엔드 (end-to-end) 강력한 암호화를 통해 보안됩니다. https-URI = &quot;https :&quot; &quot;//&quot;권한 경로 비우기 [ &quot;?&quot; query] [ &quot;# fragment fragment]&quot;https &quot;URI 스킴은 권한 설정을 위해 TLS와 TCP에 따라 다릅니다. &quot;https&quot;체계를 통해 사용 가능한 자원은 &quot;http&quot;와 공유 ID가 없습니다.자원 식별자가 동일한 권한 (같은 TCP 포트를 수신하는 동일한 호스트)을 나타내는 경우에도 그것들은 별개의 네임 스페이스이며 별개의 오리진 서버로 간주됩니다. 그러나 쿠키 프로토콜과 같은 전체 호스트 도메인에 적용되도록 정의 된 HTTP 확장&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; ]는 하나의 서비스에 의해 설정된 정보가 일치하는 호스트 도메인 그룹 내의 다른 서비스와의 통신에 영향을 줄 수있게한다. &quot;https&quot;로 식별 된 리소스에 대한 &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;정식&lt;/a&gt; 액세스 프로세스는 [ RFC2818 ]에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="381425c701e0e7786e14ce1ebe204baefd4cf1f3" translate="yes" xml:space="preserve">
          <source>The &quot;must-revalidate&quot; response directive indicates that once it has
   become stale, a cache MUST NOT use the response to satisfy subsequent
   requests without successful validation on the origin server.

   The must-revalidate directive is necessary to support reliable
   operation for certain protocol features.  In all circumstances a
   cache MUST obey the must-revalidate directive; in particular, if a
   cache cannot reach the origin server for any reason, it MUST generate
   a 504 (Gateway Timeout) response.

   The must-revalidate directive ought to be used by servers if and only
   if failure to validate a request on the representation could result
   in incorrect operation, such as a silently unexecuted financial
   transaction.</source>
          <target state="translated">&quot;must-revalidate&quot;응답 지시문은 일단 효력이 상실되면 캐시가 원본 서버에서 성공적인 유효성 검증없이 후속 요청을 만족시키기 위해 응답을 사용해서는 안됨을 나타냅니다. 특정 프로토콜 기능의 안정적인 작동을 지원하려면 must-revalidate 지시문이 필요합니다. 모든 상황에서 캐시는 must-revalidate 지시문을 따라야합니다. 특히 캐시가 어떤 이유로 든 오리진 서버에 도달 할 수없는 경우 반드시 504 (게이트웨이 타임 아웃) 응답을 생성해야합니다. must-revalidate 지시문은 표현에 대한 요청의 유효성을 검증하지 못하면 자동으로 실행되지 않는 금융 거래와 같은 잘못된 조작이 발생할 수있는 경우에만 서버에서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c4b6b9fcb971dd4f353272a2f91db7cf9a5b6db0" translate="yes" xml:space="preserve">
          <source>The &quot;no-cache&quot; request directive indicates that a cache MUST NOT use
   a stored response to satisfy the request without successful
   validation on the origin server.</source>
          <target state="translated">&quot;캐시 없음&quot;요청 지시문은 캐시가 원래 서버에 대한 유효성 검증없이 요청을 만족시키기 위해 저장된 응답을 사용해서는 안됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6e8f6289e5ab1b4d0a53bcb9e1b83dc08f1a97ef" translate="yes" xml:space="preserve">
          <source>The &quot;no-store&quot; request directive indicates that a cache MUST NOT
   store any part of either this request or any response to it.  This
   directive applies to both private and shared caches.  &quot;MUST NOT
   store&quot; in this context means that the cache MUST NOT intentionally
   store the information in non-volatile storage, and MUST make a
   best-effort attempt to remove the information from volatile storage
   as promptly as possible after forwarding it.

   This directive is NOT a reliable or sufficient mechanism for ensuring
   privacy.  In particular, malicious or compromised caches might not
   recognize or obey this directive, and communications networks might
   be vulnerable to eavesdropping.

   Note that if a request containing this directive is satisfied from a
   cache, the no-store request directive does not apply to the already
   stored response.</source>
          <target state="translated">&quot;no-store&quot;요청 지시문은 캐시가이 요청의 일부 나 응답을 저장해서는 안됨을 나타냅니다. 이 지정 문은 개인용 캐시와 공유 캐시 모두에 적용됩니다. 이러한 맥락에서 &quot;MUST NOT store&quot;는 캐시가 의도적으로 비 휘발성 저장소에 정보를 저장해서는 안되며, 정보를 전달한 후 가능한 한 빨리 휘발성 저장소에서 정보를 제거하기 위해 최선의 노력을 다해야 함을 의미합니다. 이 지침은 개인 정보 보호를위한 신뢰할 수 있거나 충분한 메커니즘이 아닙니다. 특히 악의적이거나 손상된 캐시는이 지시문을 인식하거나 따르지 않을 수 있으며 통신 네트워크는 도청에 취약 할 수 있습니다. 이 지시문을 포함하는 요청이 캐시에서 충족되면비 저장 요청 지시문은 이미 저장된 응답에 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94cb482b3050dacf986c6ae2b51caac0dbd9698e" translate="yes" xml:space="preserve">
          <source>The &quot;no-store&quot; response directive indicates that a cache MUST NOT
   store any part of either the immediate request or response.  This
   directive applies to both private and shared caches.  &quot;MUST NOT
   store&quot; in this context means that the cache MUST NOT intentionally
   store the information in non-volatile storage, and MUST make a
   best-effort attempt to remove the information from volatile storage
   as promptly as possible after forwarding it.

   This directive is NOT a reliable or sufficient mechanism for ensuring
   privacy.  In particular, malicious or compromised caches might not
   recognize or obey this directive, and communications networks might
   be vulnerable to eavesdropping.</source>
          <target state="translated">&quot;no-store&quot;응답 지시문은 캐시가 즉각적인 요청 또는 응답의 일부를 저장해서는 안됨을 나타냅니다. 이 지정 문은 개인용 캐시와 공유 캐시 모두에 적용됩니다. 이러한 맥락에서 &quot;MUST NOT store&quot;는 캐시가 의도적으로 비 휘발성 저장소에 정보를 저장해서는 안되며, 정보를 전달한 후 가능한 한 빨리 휘발성 저장소에서 정보를 제거하기 위해 최선의 노력을 다해야 함을 의미합니다. 이 지침은 개인 정보 보호를위한 신뢰할 수 있거나 충분한 메커니즘이 아닙니다. 특히 악의적이거나 손상된 캐시는이 지시문을 인식하거나 따르지 않을 수 있으며 통신 네트워크는 도청에 취약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="246740c14df98a9984cb7c90b794ca4cbab5f083" translate="yes" xml:space="preserve">
          <source>The &quot;no-transform&quot; request directive indicates that an intermediary
   (whether or not it implements a cache) MUST NOT transform the
   payload, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;Section&amp;nbsp;5.7.2 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">&quot;변환 없음&quot;요청 지시문 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;은 [RFC7230]의 5.7.2 절에&lt;/a&gt; 정의 된대로 중개자 (캐시 구현 여부에 관계없이)가 페이로드를 변환하지 않아야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="26ea1a7d280ad4fbc448761f675e1d88af0183a2" translate="yes" xml:space="preserve">
          <source>The &quot;no-transform&quot; response directive indicates that an intermediary
   (regardless of whether it implements a cache) MUST NOT transform the
   payload, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;Section&amp;nbsp;5.7.2 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">&quot;변환 없음&quot;응답 지시문 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;은 [RFC7230]의 5.7.2 섹션에&lt;/a&gt; 정의 된대로 (캐시 구현 여부와 상관없이) 중개자가 페이로드를 변환하지 않아야 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="32d0e455b09d675a4810b93c728652a215d3ce1a" translate="yes" xml:space="preserve">
          <source>The &quot;only-if-cached&quot; request directive indicates that the client only
   wishes to obtain a stored response.  If it receives this directive, a
   cache SHOULD either respond using a stored response that is
   consistent with the other constraints of the request, or respond with 

   a 504 (Gateway Timeout) status code.  If a group of caches is being
   operated as a unified system with good internal connectivity, a
   member cache MAY forward such a request within that group of caches.</source>
          <target state="translated">&quot;캐시 전용&quot;요청 지시문은 클라이언트가 저장된 응답 만 얻으려고 함을 나타냅니다. 이 지시문을 수신하면 캐시는 요청의 다른 제약 조건과 일치하는 저장된 응답을 사용하여 응답하거나 504 (게이트웨이 타임 아웃) 상태 코드로 응답해야합니다. 캐시 그룹이 내부 연결 상태가 좋은 통합 시스템으로 작동하는 경우 멤버 캐시는 해당 캐시 그룹 내에서 이러한 요청을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b71570fd0465b4f17b5b1cc37961cb5f46e70128" translate="yes" xml:space="preserve">
          <source>The &quot;proxy-revalidate&quot; response directive has the same meaning as the
   must-revalidate response directive, except that it does not apply to
   private caches.</source>
          <target state="translated">&quot;proxy-revalidate&quot;응답 지시문은 개인 캐시에 적용되지 않는다는 점을 제외하고 must-revalidate 응답 지시문과 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="f75c67cbc215fa2c33b29aa7195f38b3d21101a2" translate="yes" xml:space="preserve">
          <source>The &quot;public&quot; directive indicates that the response may be cached by any cache. This can be useful if pages with HTTP authentication, or response status codes that aren't normally cacheable, should now be cached.</source>
          <target state="translated">&quot;public&quot;지시문은 응답이 캐시에 의해 캐시 될 수 있음을 나타냅니다. 이는 HTTP 인증이있는 페이지 또는 일반적으로 캐시 할 수없는 응답 상태 코드를 이제 캐시해야하는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e6876985726810eb54534e7e11d768f44365be0" translate="yes" xml:space="preserve">
          <source>The &quot;public&quot; directive indicates that the response may be cached by any cache. This can be useful, if pages with HTTP authentication or response status codes that aren't normally cacheable, should now be cached.</source>
          <target state="translated">&quot;public&quot;지시문은 캐시가 응답을 캐시 할 수 있음을 나타냅니다. 일반적으로 캐시 할 수없는 HTTP 인증 또는 응답 상태 코드가있는 페이지를 캐시해야하는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4971052d2513145d16ddbb98b369e6dbbfe2ae90" translate="yes" xml:space="preserve">
          <source>The &quot;public&quot; response directive indicates that any cache MAY store
   the response, even if the response would normally be non-cacheable or
   cacheable only within a private cache.  (See &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; for
   additional details related to the use of public in response to a
   request containing Authorization, and &lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt; for details of how
   public affects responses that would normally not be stored, due to
   their status codes not being defined as cacheable by default; see
   &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;.)</source>
          <target state="translated">&quot;public&quot;응답 지시문은 응답이 일반적으로 개인 캐시 내에서만 캐시 할 수 없거나 캐시 가능하더라도 캐시가 응답을 저장할 수 있음을 나타냅니다. ( 권한을 포함하는 요청에 응답하여 공개 사용과 관련된 추가 세부 사항 &lt;a href=&quot;#section-3.2&quot;&gt;은 3.2 절을&lt;/a&gt; 참조 하고 , 기본적으로 상태 코드가 기본적으로 캐시 가능으로 정의되지 않은 상태로 인해 공개되지 않은 응답에 영향을 미치는 방식에 대한 세부 사항은 &lt;a href=&quot;#section-3&quot;&gt;3 절&lt;/a&gt; 을 참조하십시오. &lt;a href=&quot;#section-4.2.2&quot;&gt;섹션 4.2.2&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="3a53d63d810ef97bac3b0a2d1828ead948bae860" translate="yes" xml:space="preserve">
          <source>The &quot;realm&quot; authentication parameter is reserved for use by
   authentication schemes that wish to indicate a scope of protection.

   A protection space is defined by the canonical root URI (the scheme
   and authority components of the effective request URI; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;5.5 of [RFC7230]&lt;/a&gt;) of the server being accessed, in combination with
   the realm value if present.  These realms allow the protected
   resources on a server to be partitioned into a set of protection 

   spaces, each with its own authentication scheme and/or authorization
   database.  The realm value is a string, generally assigned by the
   origin server, that can have additional semantics specific to the
   authentication scheme.  Note that a response can have multiple
   challenges with the same auth-scheme but with different realms.

   The protection space determines the domain over which credentials can
   be automatically applied.  If a prior request has been authorized,
   the user agent MAY reuse the same credentials for all other requests
   within that protection space for a period of time determined by the
   authentication scheme, parameters, and/or user preferences (such as a
   configurable inactivity timeout).  Unless specifically allowed by the
   authentication scheme, a single protection space cannot extend
   outside the scope of its server.

   For historical reasons, a sender MUST only generate the quoted-string
   syntax.  Recipients might have to support both token and
   quoted-string syntax for maximum interoperability with existing
   clients that have been accepting both notations for a long time.</source>
          <target state="translated">&quot;영역&quot;인증 매개 변수는 보호 범위를 나타내려는 인증 체계에서 사용하도록 예약되어 있습니다. 보호 공간은 표준 루트 URI (실제 요청 URI의 체계 및 권한 구성 요소에 의해 정의됩니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]의 5.5 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;절&lt;/a&gt; 참조 ))이있는 경우 영역 값과 함께 액세스중인 서버의 이러한 영역을 사용하면 서버의 보호 된 자원을 각각 자체 인증 체계 및 / 또는 권한 부여 데이터베이스가있는 일련의 보호 공간으로 분할 할 수 있습니다. 영역 값은 일반적으로 오리진 서버에 의해 할당 된 문자열로, 인증 체계에 특정한 추가 의미를 가질 수 있습니다. 응답에는 인증 체계가 동일하지만 영역이 다른 여러 가지 문제가있을 수 있습니다. 보호 공간에 따라 자격 증명을 자동으로 적용 할 수있는 도메인이 결정됩니다. 이전 요청이 승인 된 경우, 사용자 에이전트는 인증 체계, 매개 변수,및 / 또는 사용자 기본 설정 (예 : 구성 가능한 비활성 시간 초과). 인증 체계에서 특별히 허용하지 않는 한 단일 보호 공간은 서버 범위 밖으로 확장 할 수 없습니다. 역사적 이유로, 발신자는 인용 문자열 구문 만 생성해야합니다. 받는 사람은 두 표기법을 오랫동안 받아온 기존 클라이언트와의 최대 상호 운용성을 위해 토큰 및 따옴표로 묶은 문자열 구문을 모두 지원해야 할 수 있습니다.받는 사람은 두 표기법을 오랫동안 받아온 기존 클라이언트와의 최대 상호 운용성을 위해 토큰 및 따옴표로 묶은 문자열 구문을 모두 지원해야 할 수 있습니다.받는 사람은 두 표기법을 오랫동안 받아온 기존 클라이언트와의 최대 상호 운용성을 위해 토큰 및 따옴표로 묶은 문자열 구문을 모두 지원해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="151e607c7a4575c8ca7477aa6824b0c9baed0674" translate="yes" xml:space="preserve">
          <source>The 'Basic' HTTP Authentication Scheme</source>
          <target state="translated">'기본'HTTP 인증 체계</target>
        </trans-unit>
        <trans-unit id="31b797417bbccba76fa104cff98e9ec776af2bfd" translate="yes" xml:space="preserve">
          <source>The 'opaquelocktoken' URI scheme was defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] (and
   registered by IANA) in order to create syntactically correct and
   easy-to-generate URIs out of UUIDs, intended to be used as lock
   tokens and to be unique across all resources for all time.

   An opaquelocktoken URI is constructed by concatenating the
   'opaquelocktoken' scheme with a UUID, along with an optional
   extension.  Servers can create new UUIDs for each new lock token.  If
   a server wishes to reuse UUIDs, the server MUST add an extension, and
   the algorithm generating the extension MUST guarantee that the same
   extension will never be used twice with the associated UUID.

     OpaqueLockToken-URI = &quot;opaquelocktoken:&quot; UUID [Extension]
       ; UUID is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC4122]&lt;/a&gt;.  Note that LWS
       ; is not allowed between elements of
       ; this production.

     Extension = path
       ; path is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC3986]&lt;/a&gt;</source>
          <target state="translated">잠금 토큰으로 사용되며 모든 리소스에서 고유하도록 UUID에서 구문 상 정확하고 생성하기 쉬운 URI를 생성하기 위해 'opaquelocktoken'URI 체계가 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; ] (및 IANA에 의해 등록됨)에 정의되었습니다. 항상. opaquelocktoken URI는 'opaquelocktoken'스킴을 UUID와 옵션 확장과 연결하여 구성됩니다. 서버는 각각의 새로운 잠금 토큰마다 새로운 UUID를 생성 할 수 있습니다. 서버가 UUID를 재사용하려면 확장을 추가해야하며 확장을 생성하는 알고리즘은 동일한 확장이 연결된 UUID와 함께 두 번 사용되지 않도록해야합니다. OpaqueLockToken-URI = &quot;opaquelocktoken :&quot;UUID [확장]; UUID는 &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-3&quot;&gt;[RFC4122]의 섹션 3에&lt;/a&gt; 정의되어 있습니다 .. LWS; 의 요소 사이에는 허용되지 않습니다. 이 생산. 확장 = 경로; 경로는 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986] 섹션 3.3에&lt;/a&gt; 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40135f19d49dbe171471ff8585f7f6ce0a630cbe" translate="yes" xml:space="preserve">
          <source>The 100 (Continue) status code indicates that the initial part of a
   request has been received and has not yet been rejected by the
   server.  The server intends to send a final response after the
   request has been fully received and acted upon.

   When the request contains an Expect header field that includes a
   100-continue expectation, the 100 response indicates that the server
   wishes to receive the request payload body, as described in
   &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;.  The client ought to continue sending the request and
   discard the 100 response.

   If the request did not contain an Expect header field containing the
   100-continue expectation, the client can simply discard this interim
   response.</source>
          <target state="translated">100 (계속) 상태 코드는 요청의 초기 부분이 수신되었고 아직 서버에 의해 거부되지 않았 음을 나타냅니다. 서버는 요청이 완전히 수신되고 실행 된 후 최종 응답을 보내려고합니다. 요청에 100- 연속 예상을 포함하는 Expect 헤더 필드가 포함 된 경우 100 응답은 &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1 절&lt;/a&gt; 에서 설명한대로 서버가 요청 페이로드 본문을 수신하려고 함을 나타냅니다 . 클라이언트는 요청을 계속 보내고 100 응답을 삭제해야합니다. 요청에 100- 연속 기대 값이 포함 된 Expect 헤더 필드가 포함되어 있지 않은 경우 클라이언트는이 임시 응답을 간단히 버릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d01ba31f4c44842de2b726b8f94536c5aca0981" translate="yes" xml:space="preserve">
          <source>The 101 (Switching Protocols) status code indicates that the server
   understands and is willing to comply with the client's request, via
   the Upgrade header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Section&amp;nbsp;6.7 of [RFC7230]&lt;/a&gt;), for a change in
   the application protocol being used on this connection.  The server 

   MUST generate an Upgrade header field in the response that indicates
   which protocol(s) will be switched to immediately after the empty
   line that terminates the 101 response.

   It is assumed that the server will only agree to switch protocols
   when it is advantageous to do so.  For example, switching to a newer
   version of HTTP might be advantageous over older versions, and
   switching to a real-time, synchronous protocol might be advantageous
   when delivering resources that use such features.</source>
          <target state="translated">101 (Switching Protocols) 상태 코드는 이 연결에서 사용되는 응용 프로그램 프로토콜의 변경에 대해 서버가 업그레이드 헤더 필드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;[RFC7230]의 6.7 절)&lt;/a&gt; 를 통해 서버가 클라이언트 요청을 이해하고 준수 할 의사가 있음을 나타냅니다 . 서버는 101 응답을 종료하는 빈 줄 바로 다음에 어떤 프로토콜이 전환 될 것인지를 나타내는 업그레이드 헤더 필드를 응답에 생성해야합니다. 서버는 프로토콜을 전환하는 것이 유리할 때만 프로토콜 전환에 동의한다고 가정합니다. 예를 들어, 최신 버전의 HTTP로 전환하면 이전 버전보다 유리할 수 있으며 실시간 동기 프로토콜로 전환하면 이러한 기능을 사용하는 리소스를 제공 할 때 유리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c844ae29efcb21429730db5f3e66a84ced4ddb52" translate="yes" xml:space="preserve">
          <source>The 101 status code</source>
          <target state="translated">101 상태 코드</target>
        </trans-unit>
        <trans-unit id="3ed3da1546f287aac58cc367f269cb9295233354" translate="yes" xml:space="preserve">
          <source>The 1xx (Informational) class of status code indicates an interim
   response for communicating connection status or request progress
   prior to completing the requested action and sending a final
   response. 1xx responses are terminated by the first empty line after
   the status-line (the empty line signaling the end of the header
   section).  Since HTTP/1.0 did not define any 1xx status codes, a
   server MUST NOT send a 1xx response to an HTTP/1.0 client.

   A client MUST be able to parse one or more 1xx responses received
   prior to a final response, even if the client does not expect one.  A
   user agent MAY ignore unexpected 1xx responses.

   A proxy MUST forward 1xx responses unless the proxy itself requested
   the generation of the 1xx response.  For example, if a proxy adds an
   &quot;Expect: 100-continue&quot; field when it forwards a request, then it need
   not forward the corresponding 100 (Continue) response(s).</source>
          <target state="translated">1xx (정보) 상태 코드 클래스는 요청 된 조치를 완료하고 최종 응답을 보내기 전에 연결 상태 또는 요청 진행 상황을 전달하기위한 임시 응답을 나타냅니다. 1xx 응답은 상태 행 뒤의 첫 번째 빈 줄 (헤더 섹션의 끝을 나타내는 빈 줄)로 종료됩니다. HTTP / 1.0은 1xx 상태 코드를 정의하지 않았으므로 서버는 1xx 응답을 HTTP / 1.0 클라이언트에 보내서는 안됩니다. 클라이언트는 하나의 응답을 기대하지 않더라도 최종 응답 전에받은 하나 이상의 1xx 응답을 구문 분석 할 수 있어야합니다. 사용자 에이전트는 예기치 않은 1xx 응답을 무시할 수 있습니다. 프록시 자체가 1xx 응답의 생성을 요청하지 않는 한 프록시는 반드시 1xx 응답을 전달해야합니다. 예를 들어, 프록시가 &quot;예상 : 100- 연속&quot;을 추가하는 경우필드가 요청을 전달할 때 해당 100 (계속) 응답을 전달할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="73c66d189cbfbc42b2d25d8e68502411eaf75067" translate="yes" xml:space="preserve">
          <source>The 200 (OK) status code indicates that the request has succeeded.
   The payload sent in a 200 response depends on the request method.
   For the methods defined by this specification, the intended meaning
   of the payload can be summarized as:

   GET  a representation of the target resource;

   HEAD  the same representation as GET, but without the representation
      data;

   POST  a representation of the status of, or results obtained from,
      the action;

   PUT, DELETE  a representation of the status of the action;

   OPTIONS  a representation of the communications options;

   TRACE  a representation of the request message as received by the end
      server.

   Aside from responses to CONNECT, a 200 response always has a payload,
   though an origin server MAY generate a payload body of zero length.
   If no payload is desired, an origin server ought to send 204 (No
   Content) instead.  For CONNECT, no payload is allowed because the
   successful result is a tunnel, which begins immediately after the 200
   response header section.

   A 200 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">200 (확인) 상태 코드는 요청이 성공했음을 나타냅니다. 200 응답으로 전송되는 페이로드는 요청 방법에 따라 다릅니다. 본 명세서에 의해 정의 된 방법들에 대해, 페이로드의 의도 된 의미는 다음과 같이 요약 될 수있다 : 목표 자원의 표현을 GET; GET과 동일하지만 표현 데이터가없는 표현; 조치의 상태 또는 조치 결과를 POST로 표시합니다. PUT, 작업 상태의 표현을 삭제합니다. 옵션은 통신 옵션을 나타냅니다. 최종 서버가 수신 한 요청 메시지 표시를 추적하십시오. CONNECT에 대한 응답 외에도 200 응답에는 항상 페이로드가 있지만 오리진 서버는 길이가 0 인 페이로드 본문을 생성 할 수 있습니다. 페이로드를 원하지 않으면오리진 서버는 대신 204 (No Content)를 보내야합니다. CONNECT의 경우 성공적인 결과는 터널이며 200 응답 헤더 섹션 바로 다음부터 시작되므로 페이로드가 허용되지 않습니다. 200 응답은 기본적으로 캐시 가능합니다. 즉, 방법 정의 나 명시 적 캐시 제어에 의해 달리 지시되지 않는 한 (참조 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234] 섹션 4.2.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fb652482ea97cc2ed5c9e3a8e7d46c55940f8e9f" translate="yes" xml:space="preserve">
          <source>The 201 (Created) status code indicates that the request has been
   fulfilled and has resulted in one or more new resources being
   created.  The primary resource created by the request is identified
   by either a Location header field in the response or, if no Location
   field is received, by the effective request URI.

   The 201 response payload typically describes and links to the
   resource(s) created.  See &lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt; for a discussion of the meaning
   and purpose of validator header fields, such as ETag and
   Last-Modified, in a 201 response.</source>
          <target state="translated">201 (작성 됨) 상태 코드는 요청이 이행되었으며 하나 이상의 새로운 자원이 작성되었음을 나타냅니다. 요청에 의해 작성된 기본 자원은 응답의 Location 헤더 필드 또는 Location 필드가 수신되지 않은 경우 유효 요청 URI에 의해 식별됩니다. 201 응답 페이로드는 일반적으로 생성 된 리소스를 설명하고 링크합니다. 201 응답에서 ETag 및 Last-Modified와 같은 유효성 검증기 헤더 필드의 의미와 목적에 대한 설명은 &lt;a href=&quot;#section-7.2&quot;&gt;7.2 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="abf13ad15a9e2fc228718670b40afce5ab72fe28" translate="yes" xml:space="preserve">
          <source>The 202 (Accepted) status code indicates that the request has been
   accepted for processing, but the processing has not been completed.
   The request might or might not eventually be acted upon, as it might
   be disallowed when processing actually takes place.  There is no
   facility in HTTP for re-sending a status code from an asynchronous
   operation.

   The 202 response is intentionally noncommittal.  Its purpose is to
   allow a server to accept a request for some other process (perhaps a
   batch-oriented process that is only run once per day) without
   requiring that the user agent's connection to the server persist
   until the process is completed.  The representation sent with this
   response ought to describe the request's current status and point to
   (or embed) a status monitor that can provide the user with an
   estimate of when the request will be fulfilled.</source>
          <target state="translated">202 (Accepted) 상태 코드는 요청이 처리를 위해 수락되었지만 처리가 완료되지 않았 음을 나타냅니다. 처리가 실제로 수행 될 때 허용되지 않을 수 있기 때문에 요청이 결국 수행 될 수도 있고 수행되지 않을 수도 있습니다. HTTP에는 비동기 작업에서 상태 코드를 다시 보내는 기능이 없습니다. 202 응답은 의도적으로 비 커밋입니다. 이 프로세스의 목적은 프로세스가 완료 될 때까지 서버에 대한 사용자 에이전트 연결이 유지되도록 요구하지 않고 서버가 다른 프로세스 (아마도 하루에 한 번만 실행되는 배치 지향 프로세스)에 대한 요청을 수락하도록하는 것입니다. 이 응답과 함께 전송 된 표현은 요청을 설명해야합니다.s 현재 상태 및 요청이 이행 될시기를 사용자에게 제공 할 수있는 상태 모니터를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="9a4650176c01777123e8dd8f9e1788cc242ba3f7" translate="yes" xml:space="preserve">
          <source>The 203 (Non-Authoritative Information) status code indicates that
   the request was successful but the enclosed payload has been modified
   from that of the origin server's 200 (OK) response by a transforming
   proxy (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;Section&amp;nbsp;5.7.2 of [RFC7230]&lt;/a&gt;).  This status code allows the
   proxy to notify recipients when a transformation has been applied,
   since that knowledge might impact later decisions regarding the
   content.  For example, future cache validation requests for the
   content might only be applicable along the same request path (through
   the same proxies).

   The 203 response is similar to the Warning code of 214 Transformation
   Applied (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7234]&lt;/a&gt;), which has the advantage of being
   applicable to responses with any status code. 

   A 203 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">203 (비 정식 정보) 상태 코드는 요청이 성공했지만 동봉 된 페이로드가 변환 프록시에 의해 오리진 서버의 200 (OK) 응답의 페이로드에서 수정되었음을 나타냅니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.2&quot;&gt;[RFC7230]의 5.7.2 섹션&lt;/a&gt; ). 이 상태 코드를 사용하면 변환이 적용될 때 프록시가 수신자에게이를 알릴 수 있습니다. 그 지식은 내용에 대한 이후의 결정에 영향을 줄 수 있기 때문입니다. 예를 들어, 콘텐츠에 대한 향후 캐시 유효성 검사 요청은 동일한 프록시를 통해 동일한 요청 경로를 통해서만 적용 할 수 있습니다. 203 응답은 214 변환 적용 경고 코드와 유사합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;[RFC7234] 섹션 5.5&lt;/a&gt;)는 상태 코드가있는 응답에 적용 할 수있는 장점이 있습니다. 203 응답은 기본적으로 캐시 가능합니다. 즉, 방법 정의 나 명시 적 캐시 제어에서 달리 명시하지 않는 한 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]의 4.2.2 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a03bafae0f2da4aa1963199aa2ef89f97a8ce60c" translate="yes" xml:space="preserve">
          <source>The 204 (No Content) status code indicates that the server has
   successfully fulfilled the request and that there is no additional
   content to send in the response payload body.  Metadata in the
   response header fields refer to the target resource and its selected
   representation after the requested action was applied.

   For example, if a 204 status code is received in response to a PUT
   request and the response contains an ETag header field, then the PUT
   was successful and the ETag field-value contains the entity-tag for
   the new representation of that target resource.

   The 204 response allows a server to indicate that the action has been
   successfully applied to the target resource, while implying that the
   user agent does not need to traverse away from its current &quot;document
   view&quot; (if any).  The server assumes that the user agent will provide
   some indication of the success to its user, in accord with its own
   interface, and apply any new or updated metadata in the response to
   its active representation.

   For example, a 204 status code is commonly used with document editing
   interfaces corresponding to a &quot;save&quot; action, such that the document
   being saved remains available to the user for editing.  It is also
   frequently used with interfaces that expect automated data transfers
   to be prevalent, such as within distributed version control systems.

   A 204 response is terminated by the first empty line after the header
   fields because it cannot contain a message body.

   A 204 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">204 (No Content) 상태 코드는 서버가 요청을 성공적으로 이행했으며 응답 페이로드 본문에 전송할 추가 컨텐츠가 없음을 나타냅니다. 응답 헤더 필드의 메타 데이터는 요청 된 조치가 적용된 후 대상 자원 및 선택된 표시를 나타냅니다. 예를 들어, PUT 요청에 대한 응답으로 204 상태 코드가 수신되고 응답에 ETag 헤더 필드가 포함 된 경우 PUT이 성공했으며 ETag 필드 값에 해당 대상 자원의 새 표현에 대한 엔티티 태그가 포함됩니다. 204 응답은 서버가 조치가 대상 자원에 성공적으로 적용되었음을 표시하면서 사용자 에이전트가 현재 &quot;문서보기&quot;(있는 경우)를 가로 질러 이동할 필요가 없음을 암시합니다.서버는 사용자 에이전트가 자체 인터페이스에 따라 사용자에게 성공 표시를 제공하고 활성 표현에 대한 응답으로 새로운 또는 업데이트 된 메타 데이터를 적용한다고 가정합니다. 예를 들어, 204 상태 코드는 &quot;저장&quot;액션에 대응하는 문서 편집 인터페이스와 함께 일반적으로 사용되므로, 저장되는 문서는 사용자가 편집 할 수 있도록 유지된다. 또한 분산 버전 제어 시스템과 같이 자동화 된 데이터 전송이 널리 보급 될 것으로 예상되는 인터페이스와 함께 자주 사용됩니다. 204 응답은 메시지 본문을 포함 할 수 없으므로 헤더 필드 다음의 첫 번째 빈 줄로 종료됩니다. 204 응답은 기본적으로 캐시 가능합니다. 즉,메소드 정의 또는 명시 적 캐시 제어에 의해 다르게 표시되지 않는 한 (참조 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234] 섹션 4.2.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="956b428452b332069240075e35ec925980806e62" translate="yes" xml:space="preserve">
          <source>The 205 (Reset Content) status code indicates that the server has
   fulfilled the request and desires that the user agent reset the
   &quot;document view&quot;, which caused the request to be sent, to its original
   state as received from the origin server.

   This response is intended to support a common data entry use case
   where the user receives content that supports data entry (a form,
   notepad, canvas, etc.), enters or manipulates data in that space, 

   causes the entered data to be submitted in a request, and then the
   data entry mechanism is reset for the next entry so that the user can
   easily initiate another input action.

   Since the 205 status code implies that no additional content will be
   provided, a server MUST NOT generate a payload in a 205 response.  In
   other words, a server MUST do one of the following for a 205
   response: a) indicate a zero-length body for the response by
   including a Content-Length header field with a value of 0; b)
   indicate a zero-length payload for the response by including a
   Transfer-Encoding header field with a value of chunked and a message
   body consisting of a single chunk of zero-length; or, c) close the
   connection immediately after sending the blank line terminating the
   header section.</source>
          <target state="translated">205 (콘텐츠 재설정) 상태 코드는 서버가 요청을 이행했음을 나타내며 사용자 에이전트가 요청을 전송 한 &quot;문서보기&quot;를 원래 서버로부터 수신 한 원래 상태로 재설정하기를 원합니다. 이 응답은 사용자가 데이터 입력을 지원하는 컨텐츠 (양식, 메모장, 캔버스 등)를 수신하고 해당 공간에서 데이터를 입력 또는 조작하여 입력 된 데이터를 제출하는 일반적인 데이터 입력 사용 사례를 지원하기위한 것입니다. 사용자가 다른 입력 동작을 쉽게 시작할 수 있도록 다음 항목에 대한 데이터 입력 메커니즘이 재설정됩니다. 205 상태 코드는 추가 컨텐츠가 제공되지 않음을 의미하므로 서버는 205 응답으로 페이로드를 생성해서는 안됩니다. 다시 말해,서버는 205 응답에 대해 다음 중 하나를 수행해야한다. a) 값이 0 인 Content-Length 헤더 필드를 포함하여 응답에 대한 길이가 0 인 본문을 표시한다. b) chunked 값을 갖는 Transfer-Encoding 헤더 필드와 길이가 0 인 단일 청크로 구성된 메시지 본문을 포함하여 응답에 대한 길이가 0 인 페이로드를 나타냅니다. 또는 c) 헤더 섹션을 종료하는 빈 줄을 보낸 후 즉시 연결을 닫습니다.c) 헤더 섹션을 종료하는 빈 줄을 보낸 후 즉시 연결을 닫습니다.c) 헤더 섹션을 종료하는 빈 줄을 보낸 후 즉시 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="07f77f37a20dc983a618d2c0027e2bd10388099a" translate="yes" xml:space="preserve">
          <source>The 206 (Partial Content) status code indicates that the server is
   successfully fulfilling a range request for the target resource by
   transferring one or more parts of the selected representation that
   correspond to the satisfiable ranges found in the request's Range
   header field (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;).

   If a single part is being transferred, the server generating the 206
   response MUST generate a Content-Range header field, describing what
   range of the selected representation is enclosed, and a payload
   consisting of the range.  For example:

     HTTP/1.1 206 Partial Content
     Date: Wed, 15 Nov 1995 06:25:24 GMT
     Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
     Content-Range: bytes 21010-47021/47022
     Content-Length: 26012
     Content-Type: image/gif

     ... 26012 bytes of partial image data 

   If multiple parts are being transferred, the server generating the
   206 response MUST generate a &quot;multipart/byteranges&quot; payload, as
   defined in &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;, and a Content-Type header field containing the
   multipart/byteranges media type and its required boundary parameter.
   To avoid confusion with single-part responses, a server MUST NOT
   generate a Content-Range header field in the HTTP header section of a
   multiple part response (this field will be sent in each part
   instead). 

   Within the header area of each body part in the multipart payload,
   the server MUST generate a Content-Range header field corresponding
   to the range being enclosed in that body part.  If the selected
   representation would have had a Content-Type header field in a 200
   (OK) response, the server SHOULD generate that same Content-Type
   field in the header area of each body part.  For example:

     HTTP/1.1 206 Partial Content
     Date: Wed, 15 Nov 1995 06:25:24 GMT
     Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
     Content-Length: 1741
     Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

     --THIS_STRING_SEPARATES
     Content-Type: application/pdf
     Content-Range: bytes 500-999/8000

     ...the first range
     --THIS_STRING_SEPARATES
     Content-Type: application/pdf
     Content-Range: bytes 7000-7999/8000

     ...the second range
     --THIS_STRING_SEPARATES--

   When multiple ranges are requested, a server MAY coalesce any of the
   ranges that overlap, or that are separated by a gap that is smaller
   than the overhead of sending multiple parts, regardless of the order
   in which the corresponding byte-range-spec appeared in the received
   Range header field.  Since the typical overhead between parts of a
   multipart/byteranges payload is around 80 bytes, depending on the
   selected representation's media type and the chosen boundary
   parameter length, it can be less efficient to transfer many small
   disjoint parts than it is to transfer the entire selected
   representation.

   A server MUST NOT generate a multipart response to a request for a
   single range, since a client that does not request multiple parts
   might not support multipart responses.  However, a server MAY
   generate a multipart/byteranges payload with only a single body part
   if multiple ranges were requested and only one range was found to be
   satisfiable or only one range remained after coalescing.  A client
   that cannot process a multipart/byteranges response MUST NOT generate
   a request that asks for multiple ranges.

   When a multipart response payload is generated, the server SHOULD
   send the parts in the same order that the corresponding
   byte-range-spec appeared in the received Range header field, 

   excluding those ranges that were deemed unsatisfiable or that were
   coalesced into other ranges.  A client that receives a multipart
   response MUST inspect the Content-Range header field present in each
   body part in order to determine which range is contained in that body
   part; a client cannot rely on receiving the same ranges that it
   requested, nor the same order that it requested.

   When a 206 response is generated, the server MUST generate the
   following header fields, in addition to those required above, if the
   field would have been sent in a 200 (OK) response to the same
   request: Date, Cache-Control, ETag, Expires, Content-Location, and
   Vary.

   If a 206 is generated in response to a request with an If-Range
   header field, the sender SHOULD NOT generate other representation
   header fields beyond those required above, because the client is
   understood to already have a prior response containing those header
   fields.  Otherwise, the sender MUST generate all of the
   representation header fields that would have been sent in a 200 (OK)
   response to the same request.

   A 206 response is cacheable by default; i.e., unless otherwise
   indicated by explicit cache controls (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of
   [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">206 (부분 컨텐츠) 상태 코드는 요청 범위 헤더 필드에있는 만족스러운 범위에 해당하는 선택된 표현의 하나 이상의 부분을 전송하여 서버가 대상 자원에 대한 범위 요청을 성공적으로 수행하고 있음을 나타냅니다 ( &lt;a href=&quot;#section-3.1&quot;&gt;섹션 3.1).&lt;/a&gt;). 단일 부품이 전송되는 경우, 206 응답을 생성하는 서버는 선택된 표현의 범위가 묶여있는 범위와 그 범위로 구성된 페이로드를 설명하는 Content-Range 헤더 필드를 생성해야합니다. 예 : HTTP / 1.1 206 부분 컨텐츠 날짜 : 1995 년 11 월 15 일 수요일 06:25:24 GMT 최종 수정 : 1995 년 11 월 15 일 수요일 04:58:08 GMT 컨텐츠 범위 : 바이트 21010-47021 / 47022 컨텐츠 길이 : 26012 Content-Type : image / gif ... 26012 바이트의 부분 이미지 데이터 여러 부분이 전송되는 경우 206 응답을 생성하는 서버는 &lt;a href=&quot;#appendix-A&quot;&gt;부록 A에&lt;/a&gt; 정의 된대로 &quot;다중 부분 / 바이트 범위&quot;페이로드를 생성해야합니다.및 multipart / byteranges 미디어 유형 및 필수 경계 매개 변수를 포함하는 Content-Type 헤더 필드입니다. 단일 파트 응답과 혼동을 피하기 위해 서버는 다중 파트 응답의 HTTP 헤더 섹션에 Content-Range 헤더 필드를 생성해서는 안됩니다 (이 필드는 각 파트로 대신 전송 됨). 멀티 파트 페이로드에서 각 본문 부분의 헤더 영역 내에서 서버는 해당 본문 부분으로 둘러싸인 범위에 해당하는 Content-Range 헤더 필드를 생성해야합니다. 선택된 표현이 200 (OK) 응답으로 Content-Type 헤더 필드를 가졌다면, 서버는 각 본문 부분의 헤더 영역에서 동일한 Content-Type 필드를 생성해야합니다. 예 : HTTP / 1.1 206 부분 콘텐츠 날짜 : 1995 년 11 월 15 일 수요일 06:25:24 GMT 최종 수정 : 수요일,1995 년 11 월 15 일 04:58:08 GMT 내용 길이 : 1741 내용 유형 : multipart / byteranges; boundary = THIS_STRING_SEPARATES --THIS_STRING_SEPARATES 컨텐츠 유형 : application / pdf 컨텐츠 범위 : bytes 500-999 / 8000 ... 첫 번째 범위 --THIS_STRING_SEPARATES 컨텐츠 유형 : application / pdf 컨텐츠 범위 : bytes 7000-7999 / 8000. .. 두 번째 범위 --THIS_STRING_SEPARATES-- 여러 범위가 요청되면 서버는 순서에 관계없이 겹치거나 여러 부품을 보내는 오버 헤드보다 작은 간격으로 분리 된 범위를 통합 할 수 있습니다. 해당 바이트 범위 스펙이 수신 된 Range 헤더 필드에 나타납니다. 멀티 파트 / 바이트 범위 페이로드의 부분 간의 일반적인 오버 헤드는 약 80 바이트이므로선택한 표현의 미디어 유형과 선택된 경계 매개 변수 길이에 따라 선택된 전체 표현을 전송하는 것보다 많은 작은 분리 된 부분을 전송하는 것이 덜 효율적일 수 있습니다. 다중 파트를 요청하지 않는 클라이언트가 다중 파트 응답을 지원하지 않을 수 있으므로 서버는 단일 범위 요청에 대한 다중 파트 응답을 생성해서는 안됩니다 (MUST NOT). 그러나 서버는 여러 범위가 요청되고 하나의 범위 만 만족할 수 있거나 통합 후 하나의 범위 만 남아 있으면 단일 본문 부분만으로 멀티 파트 / 바이트 범위 페이로드를 생성 할 수 있습니다 (MAY). 멀티 파트 / 바이트 범위 응답을 처리 할 수없는 클라이언트는 여러 범위를 요청하는 요청을 생성해서는 안됩니다 (MUST NOT). 멀티 파트 응답 페이로드가 생성되면서버는 만족할 수없는 것으로 간주되거나 다른 범위로 통합 된 범위를 제외하고 수신 된 범위 헤더 필드에 해당 바이트 범위 사양이 나타난 것과 동일한 순서로 부품을 전송해야합니다. 멀티 파트 응답을받는 클라이언트는 해당 본문 부분에 포함 된 범위를 결정하기 위해 각 본문 부분에있는 Content-Range 헤더 필드를 검사해야합니다. 클라이언트는 요청한 것과 동일한 범위 또는 요청한 것과 동일한 범위를받는 것에 의존 할 수 없습니다. 206 응답이 생성 될 때 필드가 동일한 요청에 대해 200 (OK) 응답으로 전송 된 경우 서버는 위에서 요구 한 것 외에 다음 헤더 필드를 생성해야합니다. Date, Cache-Control, ETag, 만료, 컨텐츠 위치 및 가변.If-Range 헤더 필드를 가진 요청에 대한 응답으로 206이 생성되면, 발신자는 위에서 요구 된 것 이외의 다른 표현 헤더 필드를 생성하지 않아야한다. 그렇지 않으면 발신자는 동일한 요청에 대해 200 (OK) 응답으로 전송 된 모든 표현 헤더 필드를 생성해야합니다. 206 응답은 기본적으로 캐시 가능합니다. 즉, 명시 적 캐시 제어에 의해 달리 지시되지 않는 한 (참조발신자는 동일한 요청에 대해 200 (OK) 응답으로 전송 된 모든 표현 헤더 필드를 생성해야합니다. 206 응답은 기본적으로 캐시 가능합니다. 즉, 명시 적 캐시 제어에 의해 달리 지시되지 않는 한 (참조발신자는 동일한 요청에 대해 200 (OK) 응답으로 전송 된 모든 표현 헤더 필드를 생성해야합니다. 206 응답은 기본적으로 캐시 가능합니다. 즉, 명시 적 캐시 제어에 의해 달리 지시되지 않는 한 (참조&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234] 섹션 4.2.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="a96c2c15082f71e24cf514861b9f6649cccdc6d7" translate="yes" xml:space="preserve">
          <source>The 207 (Multi-Status) status code provides status for multiple
   independent operations (see &lt;a href=&quot;#section-13&quot;&gt;Section 13&lt;/a&gt; for more information).</source>
          <target state="translated">207 (Multi-Status) 상태 코드는 여러 개의 독립적 인 작업에 대한 상태를 제공합니다 ( 자세한 내용 은 &lt;a href=&quot;#section-13&quot;&gt;섹션 13&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="21abf74518ada2943ea07b28d70fb2e06dfc8c14" translate="yes" xml:space="preserve">
          <source>The 2xx (Successful) class of status code indicates that the client's
   request was successfully received, understood, and accepted.</source>
          <target state="translated">2xx (성공) 상태 코드 클래스는 클라이언트 요청이 성공적으로 수신, 이해 및 수락되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8091edce5c825502d2461f4be1e98fbbf163fbf9" translate="yes" xml:space="preserve">
          <source>The 300 (Multiple Choices) status code indicates that the target
   resource has more than one representation, each with its own more
   specific identifier, and information about the alternatives is being
   provided so that the user (or user agent) can select a preferred
   representation by redirecting its request to one or more of those
   identifiers.  In other words, the server desires that the user agent
   engage in reactive negotiation to select the most appropriate
   representation(s) for its needs (&lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt;).

   If the server has a preferred choice, the server SHOULD generate a
   Location header field containing a preferred choice's URI reference.
   The user agent MAY use the Location field value for automatic
   redirection.

   For request methods other than HEAD, the server SHOULD generate a
   payload in the 300 response containing a list of representation
   metadata and URI reference(s) from which the user or user agent can
   choose the one most preferred.  The user agent MAY make a selection
   from that list automatically if it understands the provided media
   type.  A specific format for automatic selection is not defined by
   this specification because HTTP tries to remain orthogonal to the
   definition of its payloads.  In practice, the representation is
   provided in some easily parsed format believed to be acceptable to
   the user agent, as determined by shared design or content
   negotiation, or in some commonly accepted hypertext format. 

   A 300 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).

      Note: The original proposal for the 300 status code defined the
      URI header field as providing a list of alternative
      representations, such that it would be usable for 200, 300, and
      406 responses and be transferred in responses to the HEAD method.
      However, lack of deployment and disagreement over syntax led to
      both URI and Alternates (a subsequent proposal) being dropped from
      this specification.  It is possible to communicate the list using
      a set of Link header fields [&lt;a href=&quot;https://tools.ietf.org/html/rfc5988&quot;&gt;RFC5988&lt;/a&gt;], each with a relationship of
      &quot;alternate&quot;, though deployment is a chicken-and-egg problem.</source>
          <target state="translated">300 (Multiple Choices) 상태 코드는 대상 자원에 각각 고유의 고유 식별자가있는 둘 이상의 표시가 있으며 대체에 대한 정보가 제공되어 사용자 (또는 사용자 에이전트)가 다음과 같이 선호 표시를 선택할 수 있음을 나타냅니다. 요청을 하나 이상의 해당 식별자로 리디렉션합니다. 다시 말해, 서버는 사용자 에이전트가 요구에 가장 적합한 표현을 선택하기 위해 사후 협상에 참여하기를 원합니다 ( &lt;a href=&quot;#section-3.4&quot;&gt;3.4 절).&lt;/a&gt;). 서버가 선호하는 선택을하는 경우, 서버는 선호하는 선택의 URI 참조를 포함하는 Location 헤더 필드를 생성해야합니다. 사용자 에이전트는 자동 리디렉션을 위해 위치 필드 값을 사용할 수 있습니다. HEAD 이외의 요청 방법에 대해, 서버는 사용자 또는 사용자 에이전트가 가장 선호하는 것을 선택할 수있는 표현 메타 데이터 및 URI 참조의리스트를 포함하는 300 응답으로 페이로드를 생성해야한다 (SHOULD). 사용자 에이전트는 제공된 미디어 유형을 이해하면 해당 목록에서 자동으로 선택할 수 있습니다. HTTP는 페이로드 정의와 직교를 유지하기 때문에 자동 선택을위한 특정 형식은이 사양에서 정의되지 않습니다. 실제로,공유 설계 또는 컨텐츠 협상에 의해 결정되는 바와 같이, 사용자 에이전트가 수용 할 수있는 것으로 쉽게 해석 될 수있는 일부 형식으로, 또는 일반적으로 허용되는 하이퍼 텍스트 형식으로 표현이 제공된다. 기본적으로 300 응답은 캐시 가능합니다. 즉, 방법 정의 나 명시 적 캐시 제어에 의해 달리 지시되지 않는 한 (참조 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234] 섹션 4.2.2&lt;/a&gt; ). 참고 : 300 상태 코드에 대한 원래 제안은 대체 헤더의 목록을 제공하는 것으로 URI 헤더 필드를 정의하여 200, 300 및 406 응답에 사용 가능하고 HEAD 메소드에 대한 응답으로 전송됩니다. 그러나 구문에 대한 배포 및 의견 불일치로 인해 URI와 Alternates (이후 제안)가이 사양에서 삭제되었습니다. 배치는 닭과 계란 문제이지만 각각 &quot;대체&quot;관계를 갖는 링크 헤더 필드 세트 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc5988&quot;&gt;RFC5988)를&lt;/a&gt; 사용하여 목록을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e89e16d2ad3f5f0023fdef413da39c2201b7eab8" translate="yes" xml:space="preserve">
          <source>The 301 (Moved Permanently) status code indicates that the target
   resource has been assigned a new permanent URI and any future
   references to this resource ought to use one of the enclosed URIs.
   Clients with link-editing capabilities ought to automatically re-link
   references to the effective request URI to one or more of the new
   references sent by the server, where possible.

   The server SHOULD generate a Location header field in the response
   containing a preferred URI reference for the new permanent URI.  The
   user agent MAY use the Location field value for automatic
   redirection.  The server's response payload usually contains a short
   hypertext note with a hyperlink to the new URI(s).

      Note: For historical reasons, a user agent MAY change the request
      method from POST to GET for the subsequent request.  If this
      behavior is undesired, the 307 (Temporary Redirect) status code
      can be used instead.

   A 301 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">301 (영구적으로 이동 됨) 상태 코드는 대상 자원에 새로운 영구 URI가 지정되었으며이 자원에 대한 이후의 참조는 동봉 된 URI 중 하나를 사용해야 함을 나타냅니다. 링크 편집 기능이있는 클라이언트는 유효 요청 URI에 대한 참조를 가능한 경우 서버에서 전송 한 하나 이상의 새로운 참조에 자동으로 다시 연결해야합니다. 서버는 새로운 영구 URI에 대한 선호 URI 참조를 포함하는 응답에서 위치 헤더 필드를 생성해야한다 (SHOULD). 사용자 에이전트는 자동 리디렉션을 위해 위치 필드 값을 사용할 수 있습니다. 서버의 응답 페이로드에는 일반적으로 새 URI에 대한 하이퍼 링크와 함께 짧은 하이퍼 텍스트 노트가 포함됩니다. 참고 : 역사적 이유로 사용자 에이전트는 후속 요청에 대해 요청 방법을 POST에서 GET으로 변경할 수 있습니다.이 동작이 원치 않으면 307 (Temporary Redirect) 상태 코드를 대신 사용할 수 있습니다. 301 응답은 기본적으로 캐시 가능합니다. 즉, 방법 정의 나 명시 적 캐시 제어에 의해 달리 지시되지 않는 한 (참조 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234] 섹션 4.2.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9ef3872d9a97e7902a4418ab95fd36038bea8203" translate="yes" xml:space="preserve">
          <source>The 302 (Found) status code indicates that the target resource
   resides temporarily under a different URI.  Since the redirection
   might be altered on occasion, the client ought to continue to use the
   effective request URI for future requests. 

   The server SHOULD generate a Location header field in the response
   containing a URI reference for the different URI.  The user agent MAY
   use the Location field value for automatic redirection.  The server's
   response payload usually contains a short hypertext note with a
   hyperlink to the different URI(s).

      Note: For historical reasons, a user agent MAY change the request
      method from POST to GET for the subsequent request.  If this
      behavior is undesired, the 307 (Temporary Redirect) status code
      can be used instead.</source>
          <target state="translated">302 (발견 된) 상태 코드는 대상 자원이 일시적으로 다른 URI에 있음을 나타냅니다. 경우에 따라 리디렉션이 변경 될 수 있으므로 클라이언트는 향후 요청에 효과적인 요청 URI를 계속 사용해야합니다. 서버는 다른 URI에 대한 URI 참조를 포함하는 응답에서 Location 헤더 필드를 생성해야합니다 (SHOULD). 사용자 에이전트는 자동 리디렉션을 위해 위치 필드 값을 사용할 수 있습니다. 서버의 응답 페이로드에는 일반적으로 다른 URI에 대한 하이퍼 링크와 함께 짧은 하이퍼 텍스트 노트가 포함됩니다. 참고 : 역사적 이유로 사용자 에이전트는 후속 요청에 대해 요청 방법을 POST에서 GET으로 변경할 수 있습니다. 이 동작이 원치 않으면 307 (Temporary Redirect) 상태 코드를 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f98486b9c7317cc8a6b18febd1348ba3209011c0" translate="yes" xml:space="preserve">
          <source>The 303 (See Other) status code indicates that the server is
   redirecting the user agent to a different resource, as indicated by a
   URI in the Location header field, which is intended to provide an
   indirect response to the original request.  A user agent can perform
   a retrieval request targeting that URI (a GET or HEAD request if
   using HTTP), which might also be redirected, and present the eventual
   result as an answer to the original request.  Note that the new URI
   in the Location header field is not considered equivalent to the
   effective request URI.

   This status code is applicable to any HTTP method.  It is primarily
   used to allow the output of a POST action to redirect the user agent
   to a selected resource, since doing so provides the information
   corresponding to the POST response in a form that can be separately
   identified, bookmarked, and cached, independent of the original
   request.

   A 303 response to a GET request indicates that the origin server does
   not have a representation of the target resource that can be
   transferred by the server over HTTP.  However, the Location field
   value refers to a resource that is descriptive of the target
   resource, such that making a retrieval request on that other resource
   might result in a representation that is useful to recipients without
   implying that it represents the original target resource.  Note that
   answers to the questions of what can be represented, what
   representations are adequate, and what might be a useful description
   are outside the scope of HTTP.

   Except for responses to a HEAD request, the representation of a 303
   response ought to contain a short hypertext note with a hyperlink to
   the same URI reference provided in the Location header field.</source>
          <target state="translated">303 (기타 참조) 상태 코드는 위치 헤더 필드에 URI로 표시된대로 서버가 사용자 에이전트를 다른 자원으로 경로 재지 정하고 있음을 나타냅니다. 이는 원래 요청에 대한 간접 응답을 제공하기위한 것입니다. 사용자 에이전트는 해당 URI (HTTP를 사용하는 경우 GET 또는 HEAD 요청)를 대상으로하는 검색 요청을 수행 할 수 있으며, 이는 리디렉션 될 수도 있으며 최종 결과를 원래 요청에 대한 응답으로 표시합니다. 위치 헤더 필드의 새 URI는 유효 요청 URI와 동등한 것으로 간주되지 않습니다. 이 상태 코드는 모든 HTTP 메소드에 적용 가능합니다. 주로 POST 작업의 출력이 사용자 에이전트를 선택된 리소스로 리디렉션하도록 허용하는 데 사용됩니다.그렇게하면 원래 요청과 상관없이 POST 응답에 해당하는 정보가 별도로 식별, 책갈피 및 캐시 될 수있는 양식으로 제공됩니다. GET 요청에 대한 303 응답은 오리진 서버에 HTTP를 통해 서버가 전송할 수있는 대상 자원의 표현이 없음을 나타냅니다. 그러나 위치 필드 값은 대상 자원을 설명하는 자원을 나타내므로 해당 다른 자원에 대한 검색 요청을 수행하면 수신자가 원래 대상 자원을 나타내는 것을 암시하지 않고 수신자에게 유용한 표시가 될 수 있습니다. 표현할 수있는 내용, 적절한 표현 및 유용한 설명에 대한 질문에 대한 답변은 HTTP 범위를 벗어납니다.HEAD 요청에 대한 응답을 제외하고, 303 응답의 표현은 위치 헤더 필드에 제공된 동일한 URI 참조에 대한 하이퍼 링크와 함께 짧은 하이퍼 텍스트 노트를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="1310056b9a11237a35ab8cb0a6c54f0611f4bdbf" translate="yes" xml:space="preserve">
          <source>The 304 (Not Modified) status code indicates that a conditional GET
   or HEAD request has been received and would have resulted in a 200
   (OK) response if it were not for the fact that the condition
   evaluated to false.  In other words, there is no need for the server
   to transfer a representation of the target resource because the
   request indicates that the client, which made the request 

   conditional, already has a valid representation; the server is
   therefore redirecting the client to make use of that stored
   representation as if it were the payload of a 200 (OK) response.

   The server generating a 304 response MUST generate any of the
   following header fields that would have been sent in a 200 (OK)
   response to the same request: Cache-Control, Content-Location, Date,
   ETag, Expires, and Vary.

   Since the goal of a 304 response is to minimize information transfer
   when the recipient already has one or more cached representations, a
   sender SHOULD NOT generate representation metadata other than the
   above listed fields unless said metadata exists for the purpose of
   guiding cache updates (e.g., Last-Modified might be useful if the
   response does not have an ETag field).

   Requirements on a cache that receives a 304 response are defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.4&quot;&gt;Section&amp;nbsp;4.3.4 of [RFC7234]&lt;/a&gt;.  If the conditional request originated
   with an outbound client, such as a user agent with its own cache
   sending a conditional GET to a shared proxy, then the proxy SHOULD
   forward the 304 response to that client.

   A 304 response cannot contain a message-body; it is always terminated
   by the first empty line after the header fields.</source>
          <target state="translated">304 (수정되지 않음) 상태 코드는 조건부 GET 또는 HEAD 요청이 수신되었으며 조건이 false로 평가 된 사실이 아닌 경우 200 (OK) 응답을 초래했음을 나타냅니다. 즉, 요청을 조건부로 만든 클라이언트가 이미 유효한 표현을 가지고 있음을 나타 내기 때문에 서버가 대상 자원의 표현을 전송할 필요가 없습니다. 따라서 서버는 200 (OK) 응답의 페이로드 인 것처럼 저장된 표현을 사용하도록 클라이언트를 리디렉션합니다. 304 응답을 생성하는 서버는 동일한 요청에 대해 200 (OK) 응답으로 전송 된 Cache-Control, Content-Location, Date, ETag, Expires 및 Vary와 같은 헤더 필드를 생성해야합니다.304 응답의 목표는 수신자가 이미 하나 이상의 캐시 된 표현을 가질 때 정보 전송을 최소화하는 것이므로, 발신자는 캐시 업데이트를 안내하기 위해 상기 메타 데이터가 존재하지 않는 한 상기 열거 된 필드 이외의 표현 메타 데이터를 생성하지 않아야한다 (예를 들어, 응답에 ETag 필드가없는 경우 Last-Modified가 유용 할 수 있습니다. 304 응답을받는 캐시에 대한 요구 사항은304 응답을받는 캐시에 대한 요구 사항은304 응답을받는 캐시에 대한 요구 사항은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.4&quot;&gt;[RFC7234] 섹션 4.3.4&lt;/a&gt; . 조건부 요청이 자신의 캐시를 가진 사용자 에이전트와 같은 아웃 바운드 클라이언트에서 시작하여 조건부 GET을 공유 프록시에 보내는 경우 프록시는 해당 클라이언트에 304 응답을 전달해야합니다. 304 응답은 메시지 본문을 포함 할 수 없습니다. 헤더 필드 다음의 첫 번째 빈 줄로 항상 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="d962e03df1dabcc2ec176a4937563211d6cfd2cc" translate="yes" xml:space="preserve">
          <source>The 305 (Use Proxy) status code was defined in a previous version of
   this specification and is now deprecated (Appendix B).</source>
          <target state="translated">305 (프록시 사용) 상태 코드는이 사양의 이전 버전에서 정의되었으며 더 이상 사용되지 않습니다 (부록 B).</target>
        </trans-unit>
        <trans-unit id="bbf9b7a6555633242c214ea7db29148fae94dc7d" translate="yes" xml:space="preserve">
          <source>The 306 status code was defined in a previous version of this
   specification, is no longer used, and the code is reserved.</source>
          <target state="translated">306 상태 코드는이 사양의 이전 버전에서 정의되었으며 더 이상 사용되지 않으며 코드는 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4404c364ec3064905980ead43e5d3f9ef55ccb2e" translate="yes" xml:space="preserve">
          <source>The 306 status code was used in a previous version of the
   specification, is no longer used, and the code is reserved.</source>
          <target state="translated">306 상태 코드는 이전 버전의 사양에서 사용되었으며 더 이상 사용되지 않으며 코드는 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="efa8bf4f32294cae0ef47f6deb993b93eec7981d" translate="yes" xml:space="preserve">
          <source>The 307 (Temporary Redirect) status code indicates that the target
   resource resides temporarily under a different URI and the user agent
   MUST NOT change the request method if it performs an automatic
   redirection to that URI.  Since the redirection can change over time,
   the client ought to continue using the original effective request URI
   for future requests.

   The server SHOULD generate a Location header field in the response
   containing a URI reference for the different URI.  The user agent MAY
   use the Location field value for automatic redirection.  The server's
   response payload usually contains a short hypertext note with a
   hyperlink to the different URI(s).

      Note: This status code is similar to 302 (Found), except that it
      does not allow changing the request method from POST to GET.  This
      specification defines no equivalent counterpart for 301 (Moved
      Permanently) ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7238&quot;&gt;RFC7238&lt;/a&gt;], however, defines the status code 308
      (Permanent Redirect) for this purpose).</source>
          <target state="translated">307 (임시 리디렉션) 상태 코드는 대상 리소스가 다른 URI 아래에 일시적으로 상주하고 사용자 에이전트가 해당 URI로 자동 리디렉션을 수행하는 경우 요청 방법을 변경해서는 안된다는 것을 나타냅니다. 리디렉션은 시간이 지남에 따라 변경 될 수 있으므로 클라이언트는 향후 요청에 원래 유효 요청 URI를 계속 사용해야합니다. 서버는 다른 URI에 대한 URI 참조를 포함하는 응답에서 Location 헤더 필드를 생성해야합니다 (SHOULD). 사용자 에이전트는 자동 리디렉션을 위해 위치 필드 값을 사용할 수 있습니다. 서버의 응답 페이로드에는 일반적으로 다른 URI에 대한 하이퍼 링크와 함께 짧은 하이퍼 텍스트 노트가 포함됩니다. 참고 :이 상태 코드는 요청 방법을 POST에서 GET으로 변경할 수 없다는 점을 제외하고 302 (발견)와 유사합니다.이 사양은 301 (영구적으로 이동)에 해당하는 내용을 정의하지 않습니다 ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7238&quot;&gt;&lt;/a&gt;그러나 RFC7238 ]은 이러한 목적을위한 상태 코드 308 (영구적 리디렉션)을 정의한다.</target>
        </trans-unit>
        <trans-unit id="0b552dedeef68a9fc1c9bedf80fe2f970232311c" translate="yes" xml:space="preserve">
          <source>The 3xx (Redirection) class of status code indicates that further
   action needs to be taken by the user agent in order to fulfill the
   request.  If a Location header field (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;) is provided, the
   user agent MAY automatically redirect its request to the URI
   referenced by the Location field value, even if the specific status
   code is not understood.  Automatic redirection needs to done with
   care for methods not known to be safe, as defined in &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;,
   since the user might not wish to redirect an unsafe request.

   There are several types of redirects:

   1.  Redirects that indicate the resource might be available at a
       different URI, as provided by the Location field, as in the
       status codes 301 (Moved Permanently), 302 (Found), and 307
       (Temporary Redirect).

   2.  Redirection that offers a choice of matching resources, each
       capable of representing the original request target, as in the
       300 (Multiple Choices) status code.

   3.  Redirection to a different resource, identified by the Location
       field, that can represent an indirect response to the request, as
       in the 303 (See Other) status code.

   4.  Redirection to a previously cached result, as in the 304 (Not
       Modified) status code.

      Note: In HTTP/1.0, the status codes 301 (Moved Permanently) and
      302 (Found) were defined for the first type of redirect
      (&lt;a href=&quot;https://tools.ietf.org/html/rfc1945#section-9.3&quot;&gt;[RFC1945], Section&amp;nbsp;9.3&lt;/a&gt;).  Early user agents split on whether the
      method applied to the redirect target would be the same as the 

      original request or would be rewritten as GET.  Although HTTP
      originally defined the former semantics for 301 and 302 (to match
      its original implementation at CERN), and defined 303 (See Other)
      to match the latter semantics, prevailing practice gradually
      converged on the latter semantics for 301 and 302 as well.  The
      first revision of HTTP/1.1 added 307 (Temporary Redirect) to
      indicate the former semantics without being impacted by divergent
      practice.  Over 10 years later, most user agents still do method
      rewriting for 301 and 302; therefore, this specification makes
      that behavior conformant when the original request is POST.

   A client SHOULD detect and intervene in cyclical redirections (i.e.,
   &quot;infinite&quot; redirection loops).

      Note: An earlier version of this specification recommended a
      maximum of five redirections (&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-10.3&quot;&gt;[RFC2068], Section&amp;nbsp;10.3&lt;/a&gt;).  Content
      developers need to be aware that some clients might implement such
      a fixed limitation.</source>
          <target state="translated">상태 코드의 3xx (리디렉션) 클래스는 요청을 이행하기 위해 사용자 에이전트가 추가 조치를 취해야 함을 나타냅니다. Location 헤더 필드 ( &lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt; )가 제공되면, 사용자 에이전트는 특정 상태 코드가 이해되지 않더라도 요청을 Location 필드 값이 참조하는 URI로 자동 리디렉션 할 수 있습니다. &lt;a href=&quot;#section-4.2.1&quot;&gt;섹션 4.2.1에&lt;/a&gt; 정의 된대로 안전하지 않은 방법을주의해서 자동 리디렉션해야합니다.안전하지 않은 요청을 리디렉션하지 않기를 원할 수 있습니다. 리디렉션 유형에는 여러 가지가 있습니다. 1. 상태 코드 301 (영구적으로 이동), 302 (발견) 및 307 (임시 리디렉션)에서와 같이 위치 필드에서 제공 한 다른 URI에서 리소스를 사용할 수 있음을 나타내는 리디렉션 ). 2. 300 (Multiple Choices) 상태 코드에서와 같이 각각 원래 요청 대상을 나타낼 수있는 일치하는 리소스를 선택할 수있는 리디렉션. 3. 위치 필드로 식별되는 303 (기타 참조) 상태 코드와 같이 요청에 대한 간접 응답을 나타낼 수있는 다른 리소스로의 리디렉션. 4. 304 (수정되지 않음) 상태 코드에서와 같이 이전에 캐시 된 결과로 리디렉션. 참고 : HTTP / 1.0에서상태 코드 301 (영구적으로 이동) 및 302 (발견)는 첫 번째 유형의 리디렉션 (&lt;a href=&quot;https://tools.ietf.org/html/rfc1945#section-9.3&quot;&gt;[RFC1945], 섹션 9.3&lt;/a&gt;). 초기 사용자 에이전트는 경로 재 지정 대상에 적용된 메소드가 원래 요청과 동일한 지 GET으로 다시 작성되는지에 따라 분리됩니다. HTTP는 원래 301 및 302에 대한 이전 의미를 정의하고 (CERN에서의 원래 구현과 일치하도록) 303 (기타 참조)을 정의했지만, 후자의 의미와 일치하도록 일반적인 관행이 점차 301 및 302에 대한 후자의 의미에 수렴되었습니다. HTTP / 1.1의 첫 번째 개정판은 307 (Temporary Redirect)을 추가하여 분기 관행에 영향을받지 않고 이전 의미를 표시했습니다. 10 년이 지난 후에도 대부분의 사용자 에이전트는 여전히 301 및 302에 대해 메소드 재 작성을 수행합니다. 따라서이 사양은 원래 요청이 POST 일 때 해당 동작을 준수합니다.클라이언트는 주기적 리디렉션 (즉, &quot;무한&quot;리디렉션 루프)을 감지하고 개입해야합니다. 참고 :이 사양의 이전 버전에서는 최대 5 개의 리디렉션을 권장했습니다 (&lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-10.3&quot;&gt;[RFC2068], 섹션 10.3&lt;/a&gt; ). 컨텐츠 개발자는 일부 클라이언트가 이러한 고정 된 제한을 구현할 수 있음을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="334ca39a91da7c29dc27f4fe5d1fa671a87b47b0" translate="yes" xml:space="preserve">
          <source>The 400 (Bad Request) status code indicates that the server cannot or
   will not process the request due to something that is perceived to be
   a client error (e.g., malformed request syntax, invalid request
   message framing, or deceptive request routing).</source>
          <target state="translated">400 (잘못된 요청) 상태 코드는 클라이언트 오류 (예 : 잘못된 요청 구문, 잘못된 요청 메시지 프레이밍 또는 사기성 요청 라우팅)로 인식되는 것으로 인해 서버가 요청을 처리 할 수 ​​없거나 처리하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="29689450f4d2cb77a3efa906a5294a262a4c2452" translate="yes" xml:space="preserve">
          <source>The 401 (Unauthorized) status code indicates that the request has not
   been applied because it lacks valid authentication credentials for
   the target resource.  The server generating a 401 response MUST send
   a WWW-Authenticate header field (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) containing at least one
   challenge applicable to the target resource.

   If the request included authentication credentials, then the 401
   response indicates that authorization has been refused for those
   credentials.  The user agent MAY repeat the request with a new or
   replaced Authorization header field (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;).  If the 401
   response contains the same challenge as the prior response, and the
   user agent has already attempted authentication at least once, then
   the user agent SHOULD present the enclosed representation to the
   user, since it usually contains relevant diagnostic information.</source>
          <target state="translated">401 (인증되지 않음) 상태 코드는 요청이 대상 리소스에 대한 유효한 인증 자격 증명이 없기 때문에 적용되지 않았 음을 나타냅니다. 401 응답을 생성하는 서버 는 대상 자원에 적용 가능한 하나 이상의 챌린지를 포함 하는 WWW-Authenticate 헤더 필드 ( &lt;a href=&quot;#section-4.1&quot;&gt;4.1 절&lt;/a&gt; )를 보내야 합니다. 요청에 인증 자격 증명이 포함 된 경우 401 응답은 해당 자격 증명에 대한 권한 부여가 거부되었음을 나타냅니다. 사용자 에이전트는 새로운 또는 교체 된 Authorization 헤더 필드로 요청을 반복 할 수있다 ( &lt;a href=&quot;#section-4.2&quot;&gt;섹션 4.2)&lt;/a&gt;). 401 응답에 이전 응답과 동일한 시도가 포함되어 있고 사용자 에이전트가 이미 한 번 이상 인증을 시도한 경우 일반적으로 관련 진단 정보가 포함되어 있으므로 사용자 에이전트는 동봉 된 표현을 사용자에게 제시해야합니다.</target>
        </trans-unit>
        <trans-unit id="8a32cd96fa39bd8cea46e432f2bd383665a1ab08" translate="yes" xml:space="preserve">
          <source>The 402 (Payment Required) status code is reserved for future use.</source>
          <target state="translated">402 (결제 필요) 상태 코드는 나중에 사용하기 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="79339f2e8ca3d487560bd812a6eea754f58b8f81" translate="yes" xml:space="preserve">
          <source>The 403 (Forbidden) status code indicates that the server understood
   the request but refuses to authorize it.  A server that wishes to
   make public why the request has been forbidden can describe that
   reason in the response payload (if any).

   If authentication credentials were provided in the request, the
   server considers them insufficient to grant access.  The client
   SHOULD NOT automatically repeat the request with the same
   credentials.  The client MAY repeat the request with new or different
   credentials.  However, a request might be forbidden for reasons
   unrelated to the credentials.

   An origin server that wishes to &quot;hide&quot; the current existence of a
   forbidden target resource MAY instead respond with a status code of
   404 (Not Found).</source>
          <target state="translated">403 (금지됨) 상태 코드는 서버가 요청을 이해했지만 승인을 거부 함을 나타냅니다. 요청이 금지 된 이유를 공개하려는 서버는 응답 페이로드 (있는 경우)에서 해당 이유를 설명 할 수 있습니다. 요청에 인증 자격 증명이 제공된 경우 서버는 자격 증명이 액세스 권한을 부여하기에 충분하지 않은 것으로 간주합니다. 클라이언트는 동일한 자격 증명으로 요청을 자동으로 반복해서는 안됩니다. 클라이언트는 새로운 자격 증명이나 다른 자격 증명으로 요청을 반복 할 수 있습니다. 그러나 신임 정보와 관련이없는 이유로 요청이 금지 될 수 있습니다. 금지 된 대상 자원의 현재 존재를 &quot;숨기기&quot;하려는 원 서버는 대신 상태 코드 404 (찾을 수 없음)로 응답 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3def26038d6d95647ba8eb940680d2af264c867" translate="yes" xml:space="preserve">
          <source>The 404 (Not Found) status code indicates that the origin server did
   not find a current representation for the target resource or is not
   willing to disclose that one exists.  A 404 status code does not
   indicate whether this lack of representation is temporary or
   permanent; the 410 (Gone) status code is preferred over 404 if the
   origin server knows, presumably through some configurable means, that
   the condition is likely to be permanent.

   A 404 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">404 (찾을 수 없음) 상태 코드는 원본 서버가 대상 자원에 대한 현재 표현을 찾지 못했거나 존재한다는 것을 공개하지 않을 것임을 나타냅니다. 404 상태 코드는 이러한 표현 부족이 일시적인지 영구적인지를 나타내지 않습니다. 410 (Gone) 상태 코드는 원래 서버가 구성 가능한 일부 수단을 통해 조건이 영구적 일 가능성을 알고있는 경우 404보다 선호됩니다. 404 응답은 기본적으로 캐시 가능합니다. 즉, 방법 정의 나 명시 적 캐시 제어에서 달리 명시하지 않는 한 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]의 4.2.2 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="139fdce0aa53e1ec81629bd1c9fe084f1e273d10" translate="yes" xml:space="preserve">
          <source>The 405 (Method Not Allowed) status code indicates that the method
   received in the request-line is known by the origin server but not
   supported by the target resource.  The origin server MUST generate an
   Allow header field in a 405 response containing a list of the target
   resource's currently supported methods.

   A 405 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">405 (Method Not Allowed) 상태 코드는 요청 라인에서 수신 된 메소드가 원래 서버에 의해 알려져 있지만 대상 자원에 의해 지원되지 않음을 나타냅니다. 오리진 서버는 대상 리소스의 현재 지원되는 메소드 목록을 포함하는 405 응답에 Allow header 필드를 생성해야합니다. 405 응답은 기본적으로 캐시 가능합니다. 즉, 방법 정의 나 명시 적 캐시 제어에서 달리 명시하지 않는 한 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]의 4.2.2 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="ee79d34ebbf5f698fa72e9938ee69213ae4643fa" translate="yes" xml:space="preserve">
          <source>The 406 (Not Acceptable) status code indicates that the target
   resource does not have a current representation that would be
   acceptable to the user agent, according to the proactive negotiation
   header fields received in the request (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;), and the server
   is unwilling to supply a default representation.

   The server SHOULD generate a payload containing a list of available
   representation characteristics and corresponding resource identifiers
   from which the user or user agent can choose the one most
   appropriate.  A user agent MAY automatically select the most
   appropriate choice from that list.  However, this specification does
   not define any standard for such automatic selection, as described in
   &lt;a href=&quot;#section-6.4.1&quot;&gt;Section 6.4.1&lt;/a&gt;.</source>
          <target state="translated">406 (Not Acceptable) 상태 코드는 요청에서 수신 한 사전 협상 헤더 필드 ( &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; ) 에 따라 대상 자원에 사용자 에이전트가 수용 할 수있는 현재 표현이없고 서버가 기본 표현을 제공하십시오. 서버는 이용 가능한 표현 특성의 목록과 사용자 또는 사용자 에이전트가 가장 적합한 것을 선택할 수있는 해당 자원 식별자를 포함하는 페이로드를 생성해야한다 (SHOULD). 사용자 에이전트는 해당 목록에서 가장 적합한 선택을 자동으로 선택할 수 있습니다. 그러나이 사양은 &lt;a href=&quot;#section-6.4.1&quot;&gt;6.4.1 절에&lt;/a&gt; 설명 된대로 자동 선택에 대한 표준을 정의하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ec483ec7612cbc4a7219b208c6205da13b1a5be1" translate="yes" xml:space="preserve">
          <source>The 407 (Proxy Authentication Required) status code is similar to 401
   (Unauthorized), but it indicates that the client needs to
   authenticate itself in order to use a proxy.  The proxy MUST send a
   Proxy-Authenticate header field (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) containing a challenge
   applicable to that proxy for the target resource.  The client MAY
   repeat the request with a new or replaced Proxy-Authorization header
   field (&lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;).</source>
          <target state="translated">407 (프록시 인증 필요) 상태 코드는 401 (인증되지 않음)과 유사하지만 프록시를 사용하려면 클라이언트가 자신을 인증해야 함을 나타냅니다. 프록시는 반드시 대상 자원에 대해 해당 프록시에 적용 가능한 챌린지를 포함 하는 프록시 인증 헤더 필드 ( &lt;a href=&quot;#section-4.3&quot;&gt;4.3 절&lt;/a&gt; )를 보내야 합니다. 클라이언트는 새로운 프록시 대체 헤더 필드 ( &lt;a href=&quot;#section-4.4&quot;&gt;4.4 절&lt;/a&gt; ) 로 요청을 반복 할 수있다 .</target>
        </trans-unit>
        <trans-unit id="d63a1397f5112fdbc72a63c104b8b9b743795432" translate="yes" xml:space="preserve">
          <source>The 408 (Request Timeout) status code indicates that the server did
   not receive a complete request message within the time that it was
   prepared to wait.  A server SHOULD send the &quot;close&quot; connection option
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;Section&amp;nbsp;6.1 of [RFC7230]&lt;/a&gt;) in the response, since 408 implies that
   the server has decided to close the connection rather than continue
   waiting.  If the client has an outstanding request in transit, the
   client MAY repeat that request on a new connection.</source>
          <target state="translated">408 (요청 제한 시간) 상태 코드는 서버가 대기 준비 시간 내에 완전한 요청 메시지를 수신하지 않았 음을 나타냅니다. 408은 서버가 대기를 계속하기보다는 연결을 종료하기로 결정 했으므로 서버는 응답에 &quot;닫기&quot;연결 옵션 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;[RFC7230]의 6.1 절&lt;/a&gt; )을 보내야 한다. 클라이언트가 전송중인 미해결 요청을 가지고있는 경우 클라이언트는 새 연결에서 해당 요청을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="710b792af9157df3657d23cffcb2324a8f3a8d23" translate="yes" xml:space="preserve">
          <source>The 409 (Conflict) status code indicates that the request could not
   be completed due to a conflict with the current state of the target
   resource.  This code is used in situations where the user might be
   able to resolve the conflict and resubmit the request.  The server
   SHOULD generate a payload that includes enough information for a user
   to recognize the source of the conflict.

   Conflicts are most likely to occur in response to a PUT request.  For
   example, if versioning were being used and the representation being
   PUT included changes to a resource that conflict with those made by
   an earlier (third-party) request, the origin server might use a 409
   response to indicate that it can't complete the request.  In this
   case, the response representation would likely contain information
   useful for merging the differences based on the revision history.</source>
          <target state="translated">409 (충돌) 상태 코드는 대상 자원의 현재 상태와 충돌하여 요청을 완료 할 수 없음을 나타냅니다. 이 코드는 사용자가 충돌을 해결하고 요청을 다시 제출할 수있는 상황에서 사용됩니다. 서버는 사용자가 충돌의 원인을 인식하기에 충분한 정보를 포함하는 페이로드를 생성해야합니다. PUT 요청에 대한 응답으로 충돌이 발생할 가능성이 높습니다. 예를 들어, 버전 관리를 사용 중이고 PUT 표시에 이전 (타사) 요청에 의해 작성된 자원과 충돌하는 자원에 대한 변경 사항이 포함 된 경우, 오리진 서버는 409 응답을 사용하여 완료 할 수 없음을 표시 할 수 있습니다. 의뢰. 이 경우응답 표현에는 수정 내역에 따라 차이를 병합하는 데 유용한 정보가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed70c66832007f42d2ffeafd2453c5472e4f6db0" translate="yes" xml:space="preserve">
          <source>The 410 (Gone) status code indicates that access to the target
   resource is no longer available at the origin server and that this
   condition is likely to be permanent.  If the origin server does not 

   know, or has no facility to determine, whether or not the condition
   is permanent, the status code 404 (Not Found) ought to be used
   instead.

   The 410 response is primarily intended to assist the task of web
   maintenance by notifying the recipient that the resource is
   intentionally unavailable and that the server owners desire that
   remote links to that resource be removed.  Such an event is common
   for limited-time, promotional services and for resources belonging to
   individuals no longer associated with the origin server's site.  It
   is not necessary to mark all permanently unavailable resources as
   &quot;gone&quot; or to keep the mark for any length of time -- that is left to
   the discretion of the server owner.

   A 410 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">410 (Gone) 상태 코드는 대상 자원에 대한 액세스를 더 이상 원래 서버에서 사용할 수 없으며이 조건이 영구적 일 수 있음을 나타냅니다. 원래 서버가 조건이 영구적인지 여부를 알 수 없거나 결정할 기능이없는 경우 상태 코드 404 (찾을 수 없음)가 대신 사용되어야합니다. 410 응답은 기본적으로 수신자에게 자원을 의도적으로 사용할 수 없으며 서버 소유자가 해당 자원에 대한 원격 링크를 제거하기를 원한다는 것을 통지하여 웹 유지 보수 작업을 지원하기위한 것입니다. 이러한 이벤트는 제한된 기간의 판촉 서비스 및 더 이상 원본 서버 사이트와 관련이없는 개인 소유의 리소스에 일반적입니다. 영구적으로 사용할 수없는 모든 리소스를 &quot;&amp;rdquo;응답은 서버 소유자의 재량에 따라 남은 기간 동안 마크를 유지합니다. 410 응답은 기본적으로 캐시 가능합니다 (예 : 메소드 정의 또는 명시 적 캐시 제어에 의해 다르게 표시되지 않는 한). &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234] 섹션 4.2.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1d57fe4e2e7ca23134c38c0ed0018ac65cd3855c" translate="yes" xml:space="preserve">
          <source>The 411 (Length Required) status code indicates that the server
   refuses to accept the request without a defined Content-Length
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;Section&amp;nbsp;3.3.2 of [RFC7230]&lt;/a&gt;).  The client MAY repeat the request if
   it adds a valid Content-Length header field containing the length of
   the message body in the request message.</source>
          <target state="translated">411 (Length Required) 상태 코드는 서버가 정의 된 Content-Length ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;[RFC7230]의 섹션 3.3.2)&lt;/a&gt; 없이 요청을 수락하지 않음을 나타냅니다 . 클라이언트는 요청 메시지에 메시지 본문의 길이를 포함하는 유효한 Content-Length 헤더 필드를 추가하면 요청을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2b0a5d0ce695f774d281e52c15ee444fd3362b0" translate="yes" xml:space="preserve">
          <source>The 412 (Precondition Failed) status code indicates that one or more
   conditions given in the request header fields evaluated to false when
   tested on the server.  This response code allows the client to place
   preconditions on the current resource state (its current
   representations and metadata) and, thus, prevent the request method
   from being applied if the target resource is in an unexpected state.</source>
          <target state="translated">412 (전제 조건 실패) 상태 코드는 서버에서 테스트 할 때 요청 헤더 필드에 지정된 하나 이상의 조건이 false로 평가되었음을 나타냅니다. 이 응답 코드를 통해 클라이언트는 현재 자원 상태 (현재 표현 및 메타 데이터)에 사전 조건을 배치 할 수 있으므로 대상 자원이 예기치 않은 상태 인 경우 요청 메소드가 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d068c8261010d8ad8c83770690d1c48285eb7c3d" translate="yes" xml:space="preserve">
          <source>The 413 (Payload Too Large) status code indicates that the server is
   refusing to process a request because the request payload is larger
   than the server is willing or able to process.  The server MAY close
   the connection to prevent the client from continuing the request.

   If the condition is temporary, the server SHOULD generate a
   Retry-After header field to indicate that it is temporary and after
   what time the client MAY try again.</source>
          <target state="translated">413 (Payload Too Large) 상태 코드는 요청 페이로드가 서버가 처리 할 수 ​​있거나 처리 할 수있는 것보다 크기 때문에 서버가 요청 처리를 거부하고 있음을 나타냅니다. 서버는 클라이언트가 요청을 계속하지 못하도록 연결을 닫을 수 있습니다. 조건이 일시적인 경우 서버는 Retry-After 헤더 필드를 생성하여 일시적이고 클라이언트가 다시 시도 할 수있는 시간을 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="2eeffaec19aae81212514c4d922d7dc543cfcc59" translate="yes" xml:space="preserve">
          <source>The 414 (URI Too Long) status code indicates that the server is
   refusing to service the request because the request-target (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;5.3 of [RFC7230]&lt;/a&gt;) is longer than the server is willing to interpret.
   This rare condition is only likely to occur when a client has
   improperly converted a POST request to a GET request with long query
   information, when the client has descended into a &quot;black hole&quot; of
   redirection (e.g., a redirected URI prefix that points to a suffix of
   itself) or when the server is under attack by a client attempting to
   exploit potential security holes. 

   A 414 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">414 (URI Too Long) 상태 코드는 요청 대상 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230]의 5.3 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;절&lt;/a&gt; )이 서버가 해석하려는 것보다 길기 때문에 서버가 요청 서비스를 거부하고 있음을 나타냅니다 . 이 드문 조건은 클라이언트가 리디렉션의 &quot;블랙홀&quot;(예 : 접미사 자체) 또는 잠재적 보안 허점을 악용하려는 클라이언트가 서버를 공격하는 경우. 414 응답은 기본적으로 캐시 가능합니다. 즉, 방법 정의 나 명시 적 캐시 제어에서 달리 명시하지 않는 한 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]의 4.2.2 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="60bd497af3a67e2912392260b738e67280886922" translate="yes" xml:space="preserve">
          <source>The 415 (Unsupported Media Type) status code indicates that the
   origin server is refusing to service the request because the payload
   is in a format not supported by this method on the target resource.
   The format problem might be due to the request's indicated
   Content-Type or Content-Encoding, or as a result of inspecting the
   data directly.</source>
          <target state="translated">415 (지원되지 않는 매체 유형) 상태 코드는 페이로드가 대상 자원에서이 메소드가 지원하지 않는 형식이므로 오리진 서버가 요청 서비스를 거부하고 있음을 나타냅니다. 형식 문제는 요청에 표시된 Content-Type 또는 Content-Encoding 또는 데이터를 직접 검사 한 결과 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7168717c59ebb6678e8095c4f89436d6063047e" translate="yes" xml:space="preserve">
          <source>The 416 (Range Not Satisfiable) status code indicates that none of
   the ranges in the request's Range header field (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;) overlap
   the current extent of the selected resource or that the set of ranges
   requested has been rejected due to invalid ranges or an excessive
   request of small or overlapping ranges.

   For byte ranges, failing to overlap the current extent means that the
   first-byte-pos of all of the byte-range-spec values were greater than
   the current length of the selected representation.  When this status
   code is generated in response to a byte-range request, the sender
   SHOULD generate a Content-Range header field specifying the current
   length of the selected representation (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;).

   For example:

     HTTP/1.1 416 Range Not Satisfiable
     Date: Fri, 20 Jan 2012 15:41:54 GMT
     Content-Range: bytes */47022

      Note: Because servers are free to ignore Range, many
      implementations will simply respond with the entire selected
      representation in a 200 (OK) response.  That is partly because
      most clients are prepared to receive a 200 (OK) to complete the
      task (albeit less efficiently) and partly because clients might
      not stop making an invalid partial request until they have
      received a complete representation.  Thus, clients cannot depend
      on receiving a 416 (Range Not Satisfiable) response even when it
      is most appropriate.</source>
          <target state="translated">416 (Range Not Satisfiable) 상태 코드는 요청의 Range 헤더 필드 ( &lt;a href=&quot;#section-3.1&quot;&gt;섹션 3.1&lt;/a&gt; )의 범위가 선택한 자원의 현재 범위와 겹치지 않거나 유효하지 않은 범위 또는 과도한 범위로 인해 요청 된 범위 세트가 거부되었음을 나타냅니다. 작거나 겹치는 범위의 요청. 바이트 범위의 경우 현재 범위와 겹치지 않으면 모든 바이트 범위 스펙 값의 첫 번째 바이트 위치가 선택한 표현의 현재 길이보다 큼을 의미합니다. 바이트 상태 요청에 대한 응답으로이 상태 코드가 생성되면 발신자는 선택된 표현의 현재 길이를 지정하는 Content-Range 헤더 필드를 생성해야한다 ( &lt;a href=&quot;#section-4.2&quot;&gt;섹션 4.2).&lt;/a&gt;). 예 : HTTP / 1.1 416 범위를 만족할 수 없음 날짜 : 2012 년 1 월 20 일 금요일 15:41:54 GMT 콘텐츠 범위 : bytes * / 47022 참고 : 서버는 범위를 무시할 수 없으므로 많은 구현은 선택한 전체로 간단히 응답합니다. 200 (OK) 응답으로 표현. 그 이유는 대부분의 클라이언트가 작업을 완료하기 위해 200 (OK)을받을 준비가 되었기 때문에 (비효율적이지만) 클라이언트가 완전한 표현을받을 때까지 유효하지 않은 부분 요청을 중단하지 않을 수 있기 때문입니다. 따라서 클라이언트는 가장 적합한 경우에도 416 (Range Not Satisfiable) 응답 수신에 의존 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="74e2689c2b2651176712bcca9c3464c338299fa4" translate="yes" xml:space="preserve">
          <source>The 417 (Expectation Failed) status code indicates that the
   expectation given in the request's Expect header field
   (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;) could not be met by at least one of the inbound
   servers.</source>
          <target state="translated">417 (예상 실패) 상태 코드는 요청의 Expect 헤더 필드 ( &lt;a href=&quot;#section-5.1.1&quot;&gt;섹션 5.1.1&lt;/a&gt; )에 제공된 기대치를 하나 이상의 인바운드 서버에서 충족시킬 수 없음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="3e7e0d5b09bdf010782a5ab49b88e3ef27b80255" translate="yes" xml:space="preserve">
          <source>The 421 (Misdirected Request) status code indicates that the request
   was directed at a server that is not able to produce a response.
   This can be sent by a server that is not configured to produce
   responses for the combination of scheme and authority that are
   included in the request URI. 

   Clients receiving a 421 (Misdirected Request) response from a server
   MAY retry the request -- whether the request method is idempotent or
   not -- over a different connection.  This is possible if a connection
   is reused (&lt;a href=&quot;#section-9.1.1&quot;&gt;Section 9.1.1&lt;/a&gt;) or if an alternative service is selected
   [&lt;a href=&quot;#ref-ALT-SVC&quot;&gt;ALT-SVC&lt;/a&gt;].

   This status code MUST NOT be generated by proxies.

   A 421 response is cacheable by default, i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">421 (Misdirected Request) 상태 코드는 요청이 응답을 생성 할 수없는 서버로 보내 졌음을 나타냅니다. 요청 URI에 포함 된 체계와 권한의 조합에 대한 응답을 생성하도록 구성되지 않은 서버에서 보낼 수 있습니다. 서버로부터 421 (Misdirected Request) 응답을 수신하는 클라이언트는 요청 방법이 멱등 여부에 관계없이 다른 연결을 통해 요청을 재 시도 할 수 있습니다. 이는 연결이 재사용 되거나 ( &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1 절&lt;/a&gt; ) 대체 서비스가 선택되면 가능합니다 [ &lt;a href=&quot;#ref-ALT-SVC&quot;&gt;ALT-SVC&lt;/a&gt; ]. 이 상태 코드는 프록시에서 생성하면 안됩니다. 421 응답은 기본적으로 캐시 가능합니다. 즉, 메소드 정의 또는 명시 적 캐시 제어에 의해 달리 표시되지 않는 한 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]의 섹션 4.2.2&lt;/a&gt; 참조 )).</target>
        </trans-unit>
        <trans-unit id="240b1b41518b4e60c5fb369224ec2a4d545cd292" translate="yes" xml:space="preserve">
          <source>The 422 (Unprocessable Entity) status code means the server
   understands the content type of the request entity (hence a
   415(Unsupported Media Type) status code is inappropriate), and the
   syntax of the request entity is correct (thus a 400 (Bad Request)
   status code is inappropriate) but was unable to process the contained
   instructions.  For example, this error condition may occur if an XML
   request body contains well-formed (i.e., syntactically correct), but
   semantically erroneous, XML instructions.</source>
          <target state="translated">422 (처리 할 수없는 엔티티) 상태 코드는 서버가 요청 엔티티의 컨텐츠 유형을 이해하므로 (415 (지원되지 않는 매체 유형) 상태 코드가 부적절 함) 요청 엔티티의 구문이 정확함 (따라서 400 (잘못된 요청) ) 상태 코드는 부적절하지만 포함 된 지침을 처리 할 수 ​​없습니다. 예를 들어, XML 요청 본문에 올바른 형식 (구문 적으로 올바른)이지만 의미 상 잘못된 XML 명령어가 포함 된 경우이 오류 조건이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab7728b25333c3ed3e9c44c0ad08c1c5736966a3" translate="yes" xml:space="preserve">
          <source>The 423 (Locked) status code means the source or destination resource
   of a method is locked.  This response SHOULD contain an appropriate
   precondition or postcondition code, such as 'lock-token-submitted' or
   'no-conflicting-lock'.</source>
          <target state="translated">423 (Locked) 상태 코드는 메소드의 소스 또는 대상 자원이 잠겨 있음을 의미합니다. 이 응답에는 '잠금 토큰 제출'또는 '충돌 방지 잠금'과 같은 적절한 사전 조건 또는 사후 조건 코드가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7bea7308e120efd626a2dea25e346d82459c7846" translate="yes" xml:space="preserve">
          <source>The 424 (Failed Dependency) status code means that the method could
   not be performed on the resource because the requested action
   depended on another action and that action failed.  For example, if a
   command in a PROPPATCH method fails, then, at minimum, the rest of
   the commands will also fail with 424 (Failed Dependency).</source>
          <target state="translated">424 (실패 종속성) 상태 코드는 요청 된 조치가 다른 조치에 의존하고 해당 조치가 실패했기 때문에 자원에서 메소드를 수행 할 수 없음을 의미합니다. 예를 들어, PROPPATCH 메소드의 명령이 실패하면 최소한 나머지 명령도 424 (실패 종속성)로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="bbb046d45cb07e647735e9643ff8b2d8aa6d1cf5" translate="yes" xml:space="preserve">
          <source>The 426 (Upgrade Required) status code indicates that the server
   refuses to perform the request using the current protocol but might
   be willing to do so after the client upgrades to a different
   protocol.  The server MUST send an Upgrade header field in a 426
   response to indicate the required protocol(s) (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Section&amp;nbsp;6.7 of
   [RFC7230]&lt;/a&gt;).

   Example:

     HTTP/1.1 426 Upgrade Required
     Upgrade: HTTP/3.0
     Connection: Upgrade
     Content-Length: 53
     Content-Type: text/plain

     This service requires use of the HTTP/3.0 protocol.</source>
          <target state="translated">426 (업그레이드 필요) 상태 코드는 서버가 현재 프로토콜을 사용하여 요청 수행을 거부하지만 클라이언트가 다른 프로토콜로 업그레이드 한 후 기꺼이 할 수 있음을 나타냅니다. 서버는 필수 프로토콜을 표시하기 위해 반드시 426 응답으로 Upgrade 헤더 필드를 보내야합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;[RFC7230]의 6.7 절&lt;/a&gt; ). 예 : HTTP / 1.1 426 업그레이드 필요 업그레이드 : HTTP / 3.0 연결 : 업그레이드 Content-Length : 53 Content-Type : text / plain이 서비스는 HTTP / 3.0 프로토콜을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff18add20b8f554c457e49bc2e7ce8d714901464" translate="yes" xml:space="preserve">
          <source>The 4xx (Client Error) class of status code indicates that the client
   seems to have erred.  Except when responding to a HEAD request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition.  These status codes are applicable to any request method.
   User agents SHOULD display any included representation to the user.</source>
          <target state="translated">상태 코드의 4xx (클라이언트 오류) 클래스는 클라이언트가 오류가 발생한 것 같습니다. HEAD 요청에 응답 할 때를 제외하고, 서버는 오류 상황에 대한 설명과 일시적 또는 영구 조건인지 여부를 포함하는 표현을 보내야합니다. 이 상태 코드는 모든 요청 방법에 적용 할 수 있습니다. 사용자 에이전트는 사용자에게 포함 된 표현을 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c2a74d9f06b0a77075195702a5230a67673de95" translate="yes" xml:space="preserve">
          <source>The 4xx class of status code is intended for cases in which the
   client seems to have erred. Except when responding to a HEAD request,
   the server SHOULD include an entity containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition. These status codes are applicable to any request method.
   User agents SHOULD display any included entity to the user.

   If the client is sending data, a server implementation using TCP
   SHOULD be careful to ensure that the client acknowledges receipt of
   the packet(s) containing the response, before the server closes the
   input connection. If the client continues sending data to the server
   after the close, the server's TCP stack will send a reset packet to
   the client, which may erase the client's unacknowledged input buffers
   before they can be read and interpreted by the HTTP application.</source>
          <target state="translated">4xx 등급의 상태 코드는 클라이언트가 오류가 발생한 것처럼 보입니다. HEAD 요청에 응답 할 때를 제외하고, 서버는 오류 상황에 대한 설명과 일시적 또는 영구 조건인지를 포함하는 엔티티를 포함해야한다. 이 상태 코드는 모든 요청 방법에 적용 할 수 있습니다. 사용자 에이전트는 포함 된 엔티티를 사용자에게 표시해야합니다. 클라이언트가 데이터를 전송하는 경우 TCP를 사용하는 서버 구현은 서버가 입력 연결을 닫기 전에 클라이언트가 응답을 포함하는 패킷의 수신을 확인하도록주의해야합니다. 클라이언트가 닫은 후에도 계속 서버에 데이터를 보내면 서버의 TCP 스택이 클라이언트에 재설정 패킷을 보내 클라이언트를 지울 수 있습니다.승인되지 않은 입력 버퍼는 HTTP 응용 프로그램에서 읽고 해석하기 전에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e4172cee002fab51d59cbb6c27d459c5303764c9" translate="yes" xml:space="preserve">
          <source>The 500 (Internal Server Error) status code indicates that the server
   encountered an unexpected condition that prevented it from fulfilling
   the request.</source>
          <target state="translated">500 (내부 서버 오류) 상태 코드는 서버에서 요청을 수행하지 못하게하는 예기치 않은 조건이 발생했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5e788aee762bb64f07dea7e2e3b12cc4a6d5e7c2" translate="yes" xml:space="preserve">
          <source>The 501 (Not Implemented) status code indicates that the server does
   not support the functionality required to fulfill the request.  This
   is the appropriate response when the server does not recognize the
   request method and is not capable of supporting it for any resource.

   A 501 response is cacheable by default; i.e., unless otherwise
   indicated by the method definition or explicit cache controls (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">501 (구현되지 않음) 상태 코드는 서버가 요청을 수행하는 데 필요한 기능을 지원하지 않음을 나타냅니다. 서버가 요청 방법을 인식하지 못하고 자원을 지원할 수없는 경우 적절한 응답입니다. 501 응답은 기본적으로 캐시 가능합니다. 즉, 방법 정의 나 명시 적 캐시 제어에서 달리 명시하지 않는 한 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;[RFC7234]의 4.2.2 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="537a3dde972341b94cbb072093d8857e86b4614a" translate="yes" xml:space="preserve">
          <source>The 502 (Bad Gateway) status code indicates that the server, while
   acting as a gateway or proxy, received an invalid response from an
   inbound server it accessed while attempting to fulfill the request.</source>
          <target state="translated">502 (잘못된 게이트웨이) 상태 코드는 게이트웨이 또는 프록시 역할을하는 서버가 요청을 수행하는 동안 액세스 한 인바운드 서버로부터 유효하지 않은 응답을 수신했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6bbdd751ae4429ec4369780a1676c0e2b99f0f2f" translate="yes" xml:space="preserve">
          <source>The 503 (Service Unavailable) status code indicates that the server
   is currently unable to handle the request due to a temporary overload
   or scheduled maintenance, which will likely be alleviated after some
   delay.  The server MAY send a Retry-After header field
   (&lt;a href=&quot;#section-7.1.3&quot;&gt;Section 7.1.3&lt;/a&gt;) to suggest an appropriate amount of time for the
   client to wait before retrying the request.

      Note: The existence of the 503 status code does not imply that a
      server has to use it when becoming overloaded.  Some servers might
      simply refuse the connection.</source>
          <target state="translated">503 (Service Unavailable) 상태 코드는 서버가 일시적 과부하 또는 예정된 유지 보수로 인해 현재 요청을 처리 할 수 ​​없음을 나타냅니다. 이는 약간의 지연 후에 완화 될 수 있습니다. 서버 는 요청을 재 시도하기 전에 클라이언트가 대기 할 적절한 시간을 제안하기 위해 재시도 후 헤더 필드 ( &lt;a href=&quot;#section-7.1.3&quot;&gt;7.1.3 절&lt;/a&gt; )를 보낼 수 있습니다. 참고 : 503 상태 코드가 있다고해서 서버가 오버로드 될 때 서버가이를 사용해야한다는 의미는 아닙니다. 일부 서버는 단순히 연결을 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb5a6e6224a6befed044cf459ac3ad6b9a312b3f" translate="yes" xml:space="preserve">
          <source>The 504 (Gateway Timeout) status code indicates that the server,
   while acting as a gateway or proxy, did not receive a timely response
   from an upstream server it needed to access in order to complete the
   request.</source>
          <target state="translated">504 (Gateway Timeout) 상태 코드는 게이트웨이 또는 프록시 역할을하는 서버가 요청을 완료하기 위해 액세스해야하는 업스트림 서버로부터 적시에 응답을받지 못했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="73dde1c42105fdf2e1da6b5ec6f32547fa21c1f6" translate="yes" xml:space="preserve">
          <source>The 505 (HTTP Version Not Supported) status code indicates that the
   server does not support, or refuses to support, the major version of
   HTTP that was used in the request message.  The server is indicating
   that it is unable or unwilling to complete the request using the same
   major version as the client, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.6&quot;&gt;Section&amp;nbsp;2.6 of
   [RFC7230]&lt;/a&gt;, other than with this error message.  The server SHOULD
   generate a representation for the 505 response that describes why
   that version is not supported and what other protocols are supported
   by that server.</source>
          <target state="translated">505 (HTTP 버전 지원되지 않음) 상태 코드는 서버가 요청 메시지에 사용 된 HTTP의 주요 버전을 지원하지 않거나 지원을 거부 함을 나타냅니다. 서버는 이 오류 메시지 외에 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-2.6&quot;&gt;[RFC7230]의 2.6 절에&lt;/a&gt; 설명 된대로 클라이언트와 동일한 주 버전을 사용하여 요청을 완료 할 수 없거나 수행하지 않을 것임을 나타냅니다 . 서버는 해당 버전이 지원되지 않는 이유와 해당 서버에서 지원하는 다른 프로토콜을 설명하는 505 응답에 대한 표현을 생성해야합니다 (SHOULD).</target>
        </trans-unit>
        <trans-unit id="6cfe58d6c6aa1b9a0d0a3a747564d201b045f349" translate="yes" xml:space="preserve">
          <source>The 507 (Insufficient Storage) status code means the method could not
   be performed on the resource because the server is unable to store
   the representation needed to successfully complete the request.  This
   condition is considered to be temporary.  If the request that
   received this status code was the result of a user action, the
   request MUST NOT be repeated until it is requested by a separate user
   action.</source>
          <target state="translated">507 (부족한 저장소) 상태 코드는 서버가 요청을 성공적으로 완료하는 데 필요한 표현을 저장할 수 없기 때문에 자원에서 메소드를 수행 할 수 없음을 의미합니다. 이 상태는 일시적인 것으로 간주됩니다. 이 상태 코드를 수신 한 요청이 사용자 조치의 결과 인 경우 별도의 사용자 조치가 요청할 때까지 요청을 반복해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0e2021f09cffdfd7e8e3c2b6e4af6afc876e3ba4" translate="yes" xml:space="preserve">
          <source>The 511 status code indicates that the client needs to authenticate to gain network access.</source>
          <target state="translated">511 상태 코드는 클라이언트가 네트워크 액세스 권한을 얻기 위해 인증해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6f13f00eed6e2731f85266d4d2b5d1b194f1dc69" translate="yes" xml:space="preserve">
          <source>The 5xx (Server Error) class of status code indicates that the server
   is aware that it has erred or is incapable of performing the
   requested method.  Except when responding to a HEAD request, the
   server SHOULD send a representation containing an explanation of the
   error situation, and whether it is a temporary or permanent 

   condition.  A user agent SHOULD display any included representation
   to the user.  These response codes are applicable to any request
   method.</source>
          <target state="translated">5xx (서버 오류) 상태 코드 클래스는 서버가 서버가 요청 된 메소드를 잘못했거나 수행 할 수 없음을 인식하고 있음을 나타냅니다. HEAD 요청에 응답 할 때를 제외하고, 서버는 오류 상황에 대한 설명과 일시적 또는 영구 조건인지를 나타내는 표현을 보내야합니다. 사용자 에이전트는 사용자에게 포함 된 표현을 표시해야합니다. 이 응답 코드는 모든 요청 방법에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eff8921ecde9859824b0aa4a316363853f77725f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../index&quot;&gt;HTTP&lt;/a&gt;&lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">&lt;a href=&quot;../../index&quot;&gt;HTTP &lt;/a&gt;&lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; 지침 지시하는 클라이언트의 사용을 요구하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;하위 리소스 무결성&lt;/a&gt; 페이지에 스크립트 나 스타일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8981236cb35a3546e80d22d9775227a98e95ef1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME type&lt;/a&gt; of the resource or the data.</source>
          <target state="translated">자원 또는 데이터 의 &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME 유형&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="476cfd9f7f7d09d394f8e2d140063c4110e761fd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header tells the server that when the actual request is sent, it will have the &lt;code&gt;X-PINGOTHER&lt;/code&gt; and &lt;code&gt;Content-Type&lt;/code&gt; headers.</source>
          <target state="translated">&lt;a href=&quot;../headers/access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; 헤더는 실제 요청이 전송 될 때, 그것은있을 것이라는 점을 서버에 알려줍니다 &lt;code&gt;X-PINGOTHER&lt;/code&gt; 및 &lt;code&gt;Content-Type&lt;/code&gt; 헤더를.</target>
        </trans-unit>
        <trans-unit id="11aa0c02b1fe58d03a5cb415bbf783776721cd3e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; header sent in the preflight request tells the server that when the actual request is sent, it will have a &lt;a href=&quot;post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request method.</source>
          <target state="translated">&lt;a href=&quot;../headers/access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt; 프리 플라이트 요청에서 전송 헤더는 실제 요청이 전송 될 때, 그것은있을 것이라는 점을 서버에 알려줍니다 &lt;a href=&quot;post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; 의&lt;/a&gt; 요청 방법.</target>
        </trans-unit>
        <trans-unit id="bee0f2cff0fd1a73153d67243f177de87af10640" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; HTTP header.</source>
          <target state="translated">&lt;a href=&quot;../headers/feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; HTTP 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="1495070845bb0ae9175f95e2e4b9163ee31037e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../headers/referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; URL is too long</source>
          <target state="translated">&lt;a href=&quot;../headers/referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; URL이 너무 깁니다</target>
        </trans-unit>
        <trans-unit id="3221539e7878d032dbdd4035adad83f822b0aa1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header will be omitted entirely. No referrer information is sent along with requests.</source>
          <target state="translated">&lt;a href=&quot;../referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; 헤더는 전체적으로 생략된다. 요청과 함께 리퍼러 정보가 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e873c7c4f23e96331a7b10f6fab0e72d0c3815f6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header needs to be set to &quot;keep-alive&quot; for this header to have any meaning.</source>
          <target state="translated">이 헤더가 의미를 가지려면 &lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 헤더를 &quot;keep-alive&quot;로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="823cc49a67542bdec9a4ef4d6b1e415d7aeb3b04" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header needs to be set to &quot;keep-alive&quot; for this header to have any meaning. Also, &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt; are ignored in HTTP/2; connection management is handled by other mechanisms there.</source>
          <target state="translated">이 헤더가 의미를 가지려면 &lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 헤더를 &quot;keep-alive&quot;로 설정해야합니다. 또한 &lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 및 연결 &lt;a href=&quot;keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt; 는 HTTP / 2에서 무시됩니다. 연결 관리는 다른 메커니즘에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="28e20ae8f53246c900d9de361122fb549b4a54cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header with type &lt;code&gt;upgrade&lt;/code&gt; must &lt;em&gt;always&lt;/em&gt; be sent with the &lt;code&gt;Upgrade&lt;/code&gt; header (as shown above).</source>
          <target state="translated">&lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 타입과 헤더 &lt;code&gt;upgrade&lt;/code&gt; 해야한다 &lt;em&gt;항상&lt;/em&gt; 로 전송 &lt;code&gt;Upgrade&lt;/code&gt; 헤더 (로 위 그림 참조).</target>
        </trans-unit>
        <trans-unit id="3168c5253229cb7eddd39a17b55204a0719f1ccb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; defining the boundary of the multipart body.</source>
          <target state="translated">&lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 멀티 파트 몸의 경계를 정의.</target>
        </trans-unit>
        <trans-unit id="c285a5fb007b2a2d826d7bbfcdc526294f9f38d5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt; header is defined by the browser, or any other user-agent, and can vary according to the context, like fetching an HTML page or an image, a video, or a script: It is different when fetching a document entered in the address bar or an element linked via an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; element. Browsers are free to use the value of the header that they think is the most adequate; an exhaustive list of &lt;a href=&quot;content_negotiation/list_of_default_accept_values&quot;&gt;default values for common browsers&lt;/a&gt; is available.</source>
          <target state="translated">는 &lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt; 헤더가 브라우저 또는 다른 사용자 에이전트에 의해 정의되며, HTML 페이지 또는 이미지, 비디오, 또는 스크립트를 가져 오는 것처럼, 상황에 따라 달라질 수 있습니다 문서가 입력 가져올 때 그것은 다른 주소 표시 줄 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 를 통해 연결된 요소 브라우저는 가장 적절하다고 생각되는 헤더 값을 자유롭게 사용할 수 있습니다. &lt;a href=&quot;content_negotiation/list_of_default_accept_values&quot;&gt;공통 브라우저에 대한&lt;/a&gt; 전체 기본값 목록을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb614dd01dd7b5c3319f1fa867383facbd91a1a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt; header lists the MIME types of media resources that the agent is willing to process. It is comma-separated lists of MIME types, each combined with a quality factor, a parameter indicating the relative degree of preference between the different MIME types.</source>
          <target state="translated">는 &lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt; 에이전트가 프로세스 용의가 있음을 헤더 나열 미디어 자원의 MIME 유형을. 쉼표로 구분 된 MIME 유형 목록으로, 각 MIME 유형 사이의 상대적인 선호도를 나타내는 매개 변수 인 품질 요소와 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="47c1d1550663e7b9840b652f6ba1f6059d00bdc3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-ch-lifetime&quot;&gt;&lt;code&gt;Accept-CH-Lifetime&lt;/code&gt;&lt;/a&gt; header is used with the &lt;code&gt;Device-Memory&lt;/code&gt; value of the &lt;code&gt;Accept-CH&lt;/code&gt; header and indicates the amount of time the device should opt-in to sharing the amount of device memory with the server. The value is given in miliseconds and it's use is optional.</source>
          <target state="translated">&lt;a href=&quot;headers/accept-ch-lifetime&quot;&gt; &lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; &lt;/a&gt; 헤더는 함께 사용되는 &lt;code&gt;Device-Memory&lt;/code&gt; 의 값이 &lt;code&gt;Accept-CH&lt;/code&gt; 헤더 및 장치가 옵트해야하는 서버와 장치 메모리의 양을 공유하는 시간을 나타낸다. 값은 밀리 초 단위로 제공되며 사용은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="72ac9e88d286f1a089252d01c7518ad33d10efe4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt; header indicates to the server what kinds of character encodings are understood by the user-agent. Traditionally, it was set to a different value for each locale for the browser, like &lt;code&gt;ISO-8859-1,utf-8;q=0.7,*;q=0.7&lt;/code&gt; for a Western European locale.</source>
          <target state="translated">&lt;a href=&quot;headers/accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt; 헤더는 문자 인코딩의 종류는 사용자 에이전트에 의해 이해되는 것을 서버에 나타냅니다. 전통적으로 브라우저의 각 로케일에 대해 &lt;code&gt;ISO-8859-1,utf-8;q=0.7,*;q=0.7&lt;/code&gt; 과 같이 서유럽 로케일의 경우 다른 값으로 설정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="cac90f4ab93dcb579a645e89e4735bc55952622d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt; header defines the acceptable content-encoding (supported compressions). The value is a q-factor list (e.g.: &lt;code&gt;br, gzip;q=0.8&lt;/code&gt;) that indicates the priority of the encoding values. The default value &lt;code&gt;identity&lt;/code&gt; is at the lowest priority (unless otherwise declared).</source>
          <target state="translated">&lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt; 헤더는 허용되는 콘텐츠 부호화 (지원 압박)을 정의한다. 값은 인코딩 값의 우선 순위를 나타내는 &lt;code&gt;br, gzip;q=0.8&lt;/code&gt; 인자 목록 (예 : br, gzip; q = 0.8 )입니다. 기본적으로 &lt;code&gt;identity&lt;/code&gt; 되지 않은 경우를 제외하고 기본값 ID 가 가장 낮은 우선 순위입니다.</target>
        </trans-unit>
        <trans-unit id="1da487f47873fc85841849fa6ec975c0f7e1eb16" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt; header is used to indicate the language preference of the user. It is a list of values with quality factors (like: &lt;code&gt;&quot;de, en;q=0.7&lt;/code&gt;&quot;). A default value is often set according the language of the graphical interface of the user agent, but most browsers allow to set different language preferences.</source>
          <target state="translated">&lt;a href=&quot;headers/accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt; 헤더는 사용자의 언어 설정을 표시하는 데 사용됩니다. 품질 요소가있는 값의 목록입니다 (예 : &lt;code&gt;&quot;de, en;q=0.7&lt;/code&gt; &quot;). 기본값은 종종 사용자 에이전트의 그래픽 인터페이스 언어에 따라 설정되지만 대부분의 브라우저는 다른 언어 환경 설정을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="5e7674c7262d6464316098c5b65d3d21f6faacd3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt; header Indicates whether or not the response to the request can be exposed when the &lt;code&gt;credentials&lt;/code&gt; flag is true. When used as part of a response to a preflight request, this indicates whether or not the actual request can be made using credentials. Note that simple &lt;code&gt;GET&lt;/code&gt; requests are not preflighted, and so if a request is made for a resource with credentials, if this header is not returned with the resource, the response is ignored by the browser and not returned to web content.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; 헤더는 경우 요청에 대한 응답이 노출 될 수 있는지 여부를 나타냅니다 &lt;code&gt;credentials&lt;/code&gt; 플래그는 사실이다. 프리 플라이트 요청에 대한 응답의 일부로 사용되는 경우 실제 자격 증명을 사용하여 실제 요청을 수행 할 수 있는지 여부를 나타냅니다. 간단한 &lt;code&gt;GET&lt;/code&gt; 요청은 프리 플라이트되지 않으므로 자격 증명이있는 리소스를 요청하면이 헤더가 리소스와 함께 반환되지 않으면 브라우저에서 응답을 무시하고 웹 콘텐츠로 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb5022c494946ba6c712c71a1fbc929d4a279c00" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; header is used in response to a &lt;a href=&quot;#Preflighted_requests&quot;&gt;preflight request&lt;/a&gt; to indicate which HTTP headers can be used when making the actual request.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt; 헤더는 응답에 사용되는 &lt;a href=&quot;#Preflighted_requests&quot;&gt;프리 플라이트 요청&lt;/a&gt; 실제 요청을 할 때 사용할 수있는 HTTP 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="47e57affccad38127a20bce8c3436539e88c6c38" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header specifies the method or methods allowed when accessing the resource. This is used in response to a preflight request. The conditions under which a request is preflighted are discussed above.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; 헤더는 자원에 액세스 할 때 허용 된 방법 또는 방법을 지정한다. 프리 플라이트 요청에 대한 응답으로 사용됩니다. 요청이 프리 플라이트되는 조건은 위에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4527c593b9686c403ce7ee6942811c00a0260ae5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-expose-headers&quot;&gt;&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;&lt;/a&gt; header lets a server whitelist headers that Javascript (such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getResponseHeader&quot;&gt;&lt;code&gt;getResponseHeader()&lt;/code&gt;&lt;/a&gt;) in browsers are allowed to access.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-expose-headers&quot;&gt; &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; &lt;/a&gt; 헤더는 자바 스크립트 (예하는 서버 화이트리스트 헤더를 할 수 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getResponseHeader&quot;&gt; &lt;code&gt;getResponseHeader()&lt;/code&gt; &lt;/a&gt; ) 브라우저이 접근 가능한에서.</target>
        </trans-unit>
        <trans-unit id="1e7542b9c473bf75e6b574a96c6ca9ae6b946296" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-expose-headers&quot;&gt;&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;&lt;/a&gt; header lets a server whitelist headers that browsers are allowed to access. For example:</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-expose-headers&quot;&gt; &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; &lt;/a&gt; 헤더는 브라우저가 액세스 할 수 있는지 화이트리스트 헤더 서버를 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0c96e27b026e07ddc3f2931ff6f47daf2922b214" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-max-age&quot;&gt;&lt;code&gt;Access-Control-Max-Age&lt;/code&gt;&lt;/a&gt; header indicates how long the results of a preflight request can be cached. For an example of a preflight request, see the above examples.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-max-age&quot;&gt; &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; &lt;/a&gt; 헤더는 프리 플라이트 요청의 결과를 캐시 할 수있는 기간을 나타냅니다. 프리 플라이트 요청의 예는 위의 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b00b4f03e257f3dbfb1f8d0d5cf818265cd59e8a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header is used when issuing a preflight request to let the server know what HTTP headers will be used when the actual request is made.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; 실제 요청이있을 때 사용됩니다 어떤 HTTP 헤더 서버 노하우를 할 수있는 프리 플라이트 요청을 발행 할 때 헤더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="691c99e3378023d77080d83aad7e1e58d0aa3326" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; header notifies the server as part of a preflight request that when the actual request is sent, it will be sent with a &lt;code&gt;POST&lt;/code&gt; request method. The &lt;a href=&quot;headers/access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header notifies the server that when the actual request is sent, it will be sent with a &lt;code&gt;X-PINGOTHER&lt;/code&gt; and &lt;code&gt;Content-Type&lt;/code&gt; custom headers. The server now has an opportunity to determine whether it wishes to accept a request under these circumstances.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt; 헤더 통지 실제 요청이 전송 될 때,은에 전송 될 것이라는 플라이트 요청의 일부로서 서버 &lt;code&gt;POST&lt;/code&gt; 의 요청 방법. &lt;a href=&quot;headers/access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; 헤더 통지 실제 요청이 전송 될 때, 그것이로 전송됩니다 서버 &lt;code&gt;X-PINGOTHER&lt;/code&gt; 및 &lt;code&gt;Content-Type&lt;/code&gt; 사용자 정의 헤더. 이제 서버는 이러한 상황에서 요청을 수락할지 여부를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00e93481fc61267674621b1c977f194bc75b6c9a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt; is used when issuing a preflight request to let the server know what HTTP method will be used when the actual request is made.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt; 실제 요청이있을 때 사용됩니다 어떤 HTTP 방법 서버 노하우를 할 수있는 프리 플라이트 요청을 발행 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7fbe0c67984080abcf5fba23225ff8d88603f4f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request headers contain the credentials to authenticate a user agent with a (proxy) server. Here, the &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is needed again followed by the credentials, which can be encoded or encrypted depending on which authentication scheme is used.</source>
          <target state="translated">&lt;a href=&quot;headers/authorization&quot;&gt; &lt;code&gt;Authorization&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt; 요청 헤더는 (프록시) 서버와 사용자 에이전트를 인증하는 인증 정보를 포함한다. 여기서는 &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; 다음에 자격 증명이 다시 필요하며 사용되는 인증 체계에 따라 인코딩 또는 암호화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32735ad57de0b36b9cb875eb26ae77710d7487d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; request headers contain the credentials to authenticate a user agent with a (proxy) server. Here, the type is needed again followed by the credentials, which can be encoded or encrypted depending on which authentication scheme is used.</source>
          <target state="translated">&lt;a href=&quot;headers/authorization&quot;&gt; &lt;code&gt;Authorization&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt; 요청 헤더는 (프록시) 서버와 사용자 에이전트를 인증하는 인증 정보를 포함한다. 여기서는 인증 유형이 다시 필요하며,이 인증 유형은 사용되는 인증 체계에 따라 인코딩되거나 암호화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53e54b41889fb412304c339ba63b0b1d28f93d5d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; HTTP/1.1 general-header field is used to specify directives for caching mechanisms in both requests and responses. Use this header to define your caching policies with the variety of directives it provides.</source>
          <target state="translated">&lt;a href=&quot;headers/cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; HTTP / 1.1 일반 헤더 필드는 요청과 응답 모두 메커니즘을 캐싱에 대한 지시자를 표시하는 데 사용한다. 제공하는 다양한 지시문으로 캐싱 정책을 정의하려면이 헤더를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7095083b873f36d44191b5aa9a6bd5c7f44c8102" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header now indicates the size of the requested range (and not the full size of the image). The &lt;a href=&quot;headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; response header indicates where in the full resource this partial message belongs.</source>
          <target state="translated">&lt;a href=&quot;headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt; 헤더는 이제 요청 범위 (그리고 이미지의 전체 크기)의 크기를 나타냅니다. &lt;a href=&quot;headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; 전체 자원이 부분 메시지가 속한 곳 응답 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="373e10b1138008b081311180730e472ee8b5d4d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; response header fields allows web site administrators to control resources the user agent is allowed to load for a given page. With a few exceptions, policies mostly involve specifying server origins and script endpoints.</source>
          <target state="translated">&lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; 응답 헤더 필드는 사용자 에이전트가 해당 페이지에 대한 부하에 허용되는 제어 자원 웹 사이트 관리자를 할 수 있습니다. 몇 가지 예외를 제외하고 정책에는 주로 서버 원본 및 스크립트 끝점 지정이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b9fe6d801fee6375976ebc4e32f720967639b006" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; response header is an &lt;em&gt;opaque-to-the-useragent&lt;/em&gt; value that can be used as a strong validator. That means that a HTTP user-agent, such as the browser, does not know what this string represents and can't predict what its value would be. If the &lt;code&gt;ETag&lt;/code&gt; header was part of the response for a resource, the client can issue an &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; in the header of future requests &amp;ndash; in order to validate the cached resource.</source>
          <target state="translated">&lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 응답 헤더는 인 &lt;em&gt;불투명 - 투 - 사용자 에이전트&lt;/em&gt; 강한 검증로서 사용될 수있다 값. 즉, 브라우저와 같은 HTTP 사용자 에이전트는이 문자열이 무엇을 나타내는 지 알지 못하며 그 값이 무엇인지 예측할 수 없습니다. 는 IF &lt;code&gt;ETag&lt;/code&gt; 헤더가 리소스에 대한 응답의 일부, 클라이언트는 발행 할 &lt;a href=&quot;headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt; 캐시 된 자원을 검증하기 위해 - 미래의 요청의 헤더에.</target>
        </trans-unit>
        <trans-unit id="cc825b2410b4df4739e11c71f412ef7ef377ba8f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; HTTP header.</source>
          <target state="translated">&lt;a href=&quot;headers/feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; HTTP 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="02c9a22613e0a52af16dfd3143868970cb39f043" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/if-range&quot;&gt;&lt;code&gt;If-Range&lt;/code&gt;&lt;/a&gt; HTTP request header makes a range request conditional: if the condition is fulfilled, the range request will be issued and the server sends back a &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; answer with the appropriate body. If the condition is not fulfilled, the full resource is sent back, with a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status. This header can be used either with a &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; validator, or with an &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, but not with both.</source>
          <target state="translated">&lt;a href=&quot;headers/if-range&quot;&gt; &lt;code&gt;If-Range&lt;/code&gt; &lt;/a&gt; HTTP 요청 헤더는 다양한 요구 조건합니다 : 조건이 충족되는 경우, 범위 요청이 발행되고 서버가 다시 전송 &lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 해당하는 몸 대답을. 조건이 충족되지 않으면 전체 자원이 &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 상태 로 반송 됩니다. 이 헤더는 &lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; 유효성 검사기 또는 &lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 있지만 둘 다와 함께 사용할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="590a84433585d18f20730243da1b6a8953716c09" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; response header can be used as a weak validator. It is considered weak because it only has 1-second resolution. If the &lt;code&gt;Last-Modified&lt;/code&gt; header is present in a response, then the client can issue an &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; request header to validate the cached document.</source>
          <target state="translated">&lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; 응답 헤더는 약한 검증로서 사용될 수있다. 해상도는 1 초이므로 약한 것으로 간주됩니다. 는 IF &lt;code&gt;Last-Modified&lt;/code&gt; 헤더가 응답에 존재하고 클라이언트는이 발행 할 수 &lt;a href=&quot;headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt; 요청 헤더 캐시 된 문서의 유효성을 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a00311ebb7587989dbe59dcf3d642597bd57cd9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header indicates the origin of the cross-site access request or preflight request.</source>
          <target state="translated">&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 헤더는 크로스 사이트 접속 요청 또는 프리 플라이트 요청의 출처를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="00410abbfb65785de4501043b5495b885e06221c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header also allows you to get multiple ranges at once in a multipart document. The ranges are separated by a comma.</source>
          <target state="translated">&lt;a href=&quot;headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 헤더는 또한 당신이 다중 문서에서 한 번에 여러 범위를 얻을 수 있습니다. 범위는 쉼표로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="86f95f2219b451868ec50ea455d93d73adebbf1e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; HTTP response header sends cookies from the server to the user agent. A simple cookie is set like this:</source>
          <target state="translated">&lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; HTTP 응답 헤더는 사용자 에이전트 서버에서 쿠키를 보냅니다. 간단한 쿠키는 다음과 같이 설정됩니다 :</target>
        </trans-unit>
        <trans-unit id="af75cb2c0da0fe81a5535d484eb290c4bd4d639e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; header allows chunked encoding, which is useful when larger amounts of data are sent to the client and the total size of the response is not known until the request has been fully processed. The server sends data to the client straight away without buffering the response or determining the exact length, which leads to improved latency. Range requests and chunking are compatible and can be used with or without each other.</source>
          <target state="translated">&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; 헤더는 더 많은 양의 데이터가 클라이언트에 전송하고, 요청이 완전히 처리 될 때까지의 응답의 전체 크기를 알 수없는 경우 유용하다 청크 인코딩을 허용한다. 서버는 응답을 버퍼링하거나 정확한 길이를 결정하지 않고 즉시 클라이언트에 데이터를 전송하므로 지연 시간이 개선됩니다. 범위 요청 및 청킹은 호환 가능하며 서로 유무에 관계없이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7f353f47a7491fd7a18b5bc1a1b46d2745b86d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; header allows chunked encoding, which useful when larger amounts of data are sent to the client and the total size of the response is not known until the request has been fully processed. The server sends data to the client straight away without buffering the response or determining the exact length, which leads to improved latency. Range requests and chunking are compatible and can be used with or without each other.</source>
          <target state="translated">&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; 헤더는 더 많은 양의 데이터가 클라이언트에 상기 요구가 완전히 처리 될 때까지 알려지지 않은 응답의 전체 크기에 전송 유용한 청크 인코딩을 허용한다. 서버는 응답을 버퍼링하거나 정확한 길이를 결정하지 않고 바로 클라이언트에 데이터를 전송하므로 대기 시간이 향상됩니다. 범위 요청과 청킹은 호환되며 서로 사용하거나 사용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="427718e5d2f07133480270391026fe30a80122e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; header identifies the browser sending the request. This string may contain a space-separated list of &lt;em&gt;product tokens&lt;/em&gt; and &lt;em&gt;comments&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt; 헤더는 요청을 보내는 브라우저를 식별합니다. 이 문자열에는 공백으로 구분 된 &lt;em&gt;제품 토큰&lt;/em&gt; 및 &lt;em&gt;설명&lt;/em&gt; 목록이 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e0b7713d148829012c4c472ea954c0d5574cc79" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server.</source>
          <target state="translated">(가) &lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; HTTP를 응답 헤더는 캐시 된 응답이 원본 서버에서 새로운 하나를 요청하는 대신 사용할 수 있는지 여부를 결정하는 미래의 요청 헤더와 일치하는 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="b1d4a413436104711d19f9e2f2ce3b22dd6fa9fb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used, or if a fresh one must be requested from the origin server.</source>
          <target state="translated">(가) &lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; HTTP를 응답 헤더는 새로운 하나가 원본 서버에서 요청해야하는 경우 캐시 된 응답을 사용할 수 있는지 여부를 결정하는 미래의 요청 헤더와 일치하거나하는 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="8f8e8fc45b5f4468eb6609ffd5ad8cb0e64e2e51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response headers define the authentication method that should be used to gain access to a resource. They must specify which authentication scheme is used, so that the client that wishes to authorize knows how to provide the credentials.</source>
          <target state="translated">&lt;a href=&quot;headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt; 응답 헤더는 리소스에 액세스하기 위해 사용되어야하는 인증 방법을 정의한다. 권한을 부여하려는 클라이언트가 자격 증명을 제공하는 방법을 알 수 있도록 사용되는 인증 체계를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a9f41cb2e8943b80c1ccc9757d2185689ead0a50" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; response headers define the authentication method that should be used to gain access to a resource. They need to specify which authentication scheme is used, so that the client that wishes to authorize knows how to provide the credentials. The syntax for these headers is the following:</source>
          <target state="translated">&lt;a href=&quot;headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt; 응답 헤더는 리소스에 액세스하기 위해 사용되어야하는 인증 방법을 정의한다. 인증하려는 클라이언트가 자격 증명을 제공하는 방법을 알 수 있도록 사용되는 인증 체계를 지정해야합니다. 이 헤더의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="841a5f97046d98851a68c9d87ead02d585e0efda" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; request header field as received by the proxy.</source>
          <target state="translated">&lt;a href=&quot;host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; 요청 헤더 필드로 프록시에 의해 수신.</target>
        </trans-unit>
        <trans-unit id="90ae0d5ac939ab22b89ef22ef6cf0f70a90df9a8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite&lt;/a&gt; module can also be used to create redirects. It is more flexible, but a bit more complex to use.</source>
          <target state="translated">&lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;을 mod_rewrite&lt;/a&gt; 모듈은 리디렉션을 만드는 데 사용할 수 있습니다. 더 유연하지만 사용하기가 조금 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="575f2f642c54dbd7133186d28418d1c27eaa5d6f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes/http-warn-codes.xhtml&quot;&gt;HTTP Warn Codes registry at iana.org&lt;/a&gt; defines the namespace for warn codes.</source>
          <target state="translated">&lt;a href=&quot;http://www.iana.org/assignments/http-warn-codes/http-warn-codes.xhtml&quot;&gt;iana.org&lt;/a&gt; 의 HTTP 경고 코드 레지스트리는 경고 코드 의 네임 스페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="8df2d67e805aa2c79e4d6afb765f67e048353741" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://blogs.msdn.microsoft.com/ie/2008/09/02/ie8-security-part-vi-beta-2-update/&quot;&gt;original definition&lt;/a&gt; of X-Content-Type-Options by Microsoft.</source>
          <target state="translated">Microsoft의 X-Content-Type-Options에 대한 &lt;a href=&quot;https://blogs.msdn.microsoft.com/ie/2008/09/02/ie8-security-part-vi-beta-2-update/&quot;&gt;원래 정의&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6bb44a38f57a4a24a21a54355c1172f452d3808" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ALPN&quot;&gt;ALPN&lt;/a&gt; protocol identifier. Examples include h2 for HTTP/2 and h3-25 for draft 25 of the HTTP/3 protocol.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ALPN&quot;&gt;ALPN의&lt;/a&gt; 프로토콜 식별자. HTTP / 2의 경우 h2, HTTP / 3 프로토콜의 초안 25의 경우 h3-25를 예로들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="303a7ca8e087b00d9976db8accc4e29108a04169" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request requires preflight, preflighting could not be performed. There are a couple of reasons why preflighting might fail:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS의&lt;/a&gt; 요청을 수행 할 수 없습니다 프리 플라이트, 프리 플라이트가 필요합니다. 프리 플라이트가 실패 할 수있는 몇 가지 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ac1bdf745446afae63eab40c6dbfdebac045663" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request requires that the server permit the use of credentials, but the server's &lt;a href=&quot;../../headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt; header's value isn't set to &lt;code&gt;true&lt;/code&gt; to enable their use.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS의&lt;/a&gt; 요청은 서버 자격 증명의 사용을 허용해야하지만 서버의 &lt;a href=&quot;../../headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; 헤더의 값으로 설정되지 않은 &lt;code&gt;true&lt;/code&gt; 의 사용을 가능하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3fef220d846f02c9cfee24670814beeba7e7355" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request was attempted with the credentials flag set, but the server is configured using the wildcard (&lt;code&gt;&quot;*&quot;&lt;/code&gt;) as the value of &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;, which doesn't allow the use of credentials.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS의&lt;/a&gt; 요청이 자격 증명 플래그가 설정 시도했지만, 서버는 와일드 카드 (사용하여 구성됩니다 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 의 값으로) &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; 증명의 사용을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94840953c7f31c8c81ed2848ad9300fdfc9d44eb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request was responded to by the server with an HTTP redirect to a URL on a different origin than the original request, which is not permitted during CORS requests.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS의&lt;/a&gt; 요청은 CORS 요청시 허용되지 않는 원래의 요청이 아닌 다른 출처에서 URL에 HTTP 리디렉션으로 서버가 응답했다.</target>
        </trans-unit>
        <trans-unit id="46ef7b51d18c11a16b9ea7877d2ee5b389add21e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt; request which makes use of CORS failed because the HTTP connection failed at either the network or protocol level. The error is not directly related to CORS, but is a fundamental network error of some kind.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP의&lt;/a&gt; HTTP 연결은 네트워크 또는 프로토콜 수준에서 실패했기 때문에 CORS를 사용합니다 요청이 실패했습니다. 이 오류는 CORS와 직접 관련이 없지만 일종의 근본적인 네트워크 오류입니다.</target>
        </trans-unit>
        <trans-unit id="77ebeb340729beee4023ffdb21e08feae0d716a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality value&lt;/a&gt; to apply to that option.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;품질 값은&lt;/a&gt; 해당 옵션에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="8ca3dd995c40f4f12da6eea0a0fb62e8d5df0822" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/simple_header&quot;&gt;simple headers&lt;/a&gt;, &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; (but only with a MIME type of its parsed value (ignoring parameters) of either &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code&gt;multipart/form-data&lt;/code&gt;, or &lt;code&gt;text/plain&lt;/code&gt;), are always available and don't need to be listed by this header.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/simple_header&quot;&gt;간단한 헤더&lt;/a&gt; , &lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 중 하나의 (하지만 그 구문 분석 된 값의 MIME 타입 (무시 매개 변수) &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; , &lt;code&gt;multipart/form-data&lt;/code&gt; , 또는 &lt;code&gt;text/plain&lt;/code&gt; )을 항상 사용할 수 있으며이 헤더로 나열 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7c8c624b902acbdfb33352d81eeb9f16044ff38e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; was unable to add the required &lt;a href=&quot;../../headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP&lt;/a&gt; request. All CORS requests must have an &lt;code&gt;Origin&lt;/code&gt; header.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트는&lt;/a&gt; 요구되는 추가 할 수 없습니다 &lt;a href=&quot;../../headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 받는 헤더를 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP&quot;&gt;HTTP의&lt;/a&gt; 요청. 모든 CORS 요청에는 &lt;code&gt;Origin&lt;/code&gt; 헤더 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="541849bca8dfcb4810abe650d5548422c6848655" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FormData&quot;&gt;&lt;code&gt;FormData&lt;/code&gt;&lt;/a&gt; interface used to manipulate form data for use in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FormData&quot;&gt; &lt;code&gt;FormData&lt;/code&gt; 의&lt;/a&gt; 인터페이스에서 사용하기 위해 양식 데이터를 조작하는 데 사용 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; API.</target>
        </trans-unit>
        <trans-unit id="7537c29a754763b348491b7f0dbd96e605a4a484" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Reporting_API&quot;&gt;reporting API&lt;/a&gt; group to send network error reports to (see below).</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Reporting_API&quot;&gt;보고 API의&lt;/a&gt; (아래 참조)에 그룹은 네트워크 오류 보고서를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="315a779e6acad1d531dd53b54135b697e3e3e7ed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket&quot;&gt;&lt;code&gt;WebSocket()&lt;/code&gt;&lt;/a&gt; constructor does all the work of creating an initial HTTP/1.1 connection then handling the handshaking and upgrade process for you.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket&quot;&gt; &lt;code&gt;WebSocket()&lt;/code&gt; &lt;/a&gt; 생성자는 모든 후 초기 HTTP / 1.1 연결을 만드는 당신을 위해 핸드 쉐이크 및 업그레이드 프로세스를 처리하는 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d45717eba61ad3d5a426950cb644c8f2dd47e3a7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt; has been replced with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebXR_API&quot;&gt;WebXR Device API&lt;/a&gt; and is currently being removed from the web platform. Use the feature identifier &lt;a href=&quot;xr-spatial-tracking&quot;&gt;&lt;code&gt;xr-spatial-tracking&lt;/code&gt;&lt;/a&gt; for WebXR Device API instead.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API는&lt;/a&gt; 와 replced 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebXR_API&quot;&gt;WebXR 장치 API&lt;/a&gt; 및 현재 웹 플랫폼에서 제거되고있다. 대신 WebXR Device API에 대한 기능 식별자 &lt;a href=&quot;xr-spatial-tracking&quot;&gt; &lt;code&gt;xr-spatial-tracking&lt;/code&gt; &lt;/a&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b3d572fbbc7fb5223d172c4f660df4f67fd67a10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;&lt;code&gt;allow&lt;/code&gt;&lt;/a&gt; attribute on iframes.</source>
          <target state="translated">iframe 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt; &lt;code&gt;allow&lt;/code&gt; &lt;/a&gt; 속성</target>
        </trans-unit>
        <trans-unit id="41b2d8d87680fc3732f8e6149116b853f67342a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;allow&lt;/a&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#Attributes&quot;&gt;허용&lt;/a&gt; 에 대한 속성 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 해당&lt;/a&gt; 들.</target>
        </trans-unit>
        <trans-unit id="81c151e97bb2fc9016b004646d1163e360980269" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH-Lifetime&quot;&gt;&lt;code&gt;Accept-CH-Lifetime&lt;/code&gt;&lt;/a&gt; header is used with the &lt;code&gt;Device-Memory&lt;/code&gt; value of the &lt;code&gt;Accept-CH&lt;/code&gt; header and indicates the amount of time the device should opt-in to sharing the amount of device memory with the server. The value is given in miliseconds and it's use is optional.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH-Lifetime&quot;&gt; &lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; &lt;/a&gt; 헤더는 함께 사용되는 &lt;code&gt;Device-Memory&lt;/code&gt; 의 값이 &lt;code&gt;Accept-CH&lt;/code&gt; 헤더 및 장치가 옵트해야하는 서버와 장치 메모리의 양을 공유하는 시간을 나타낸다. 값은 밀리 초 단위로 제공되며 사용은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="feae0b21dc6047c955761cda1dd45a586e339677" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header field is used by clients to invite the server to switch to one of the listed protocols, in descending preference order.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; 헤더 필드는 우선 순위를 내림차순으로 나열된 프로토콜 중 하나로 전환하려면 서버를 초대하는 클라이언트에 의해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="102f0a3635d954f2ea429dc9612327a656cc4b1f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Audio_codecs&quot;&gt;audio codec&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Video_codecs&quot;&gt;video codec&lt;/a&gt; guides list the various codecs that web browsers often support, providing compatibility details along with technical information such as how many audio channels they support, what sort of compression is used, and what bit rates and so forth they're useful at. The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/WebRTC_codecs&quot;&gt;codecs used by WebRTC&lt;/a&gt; guide expands upon this by specifically covering the codecs supported by the major web browsers, so you can choose the codecs that best cover the range of browsers you wish to support.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Audio_codecs&quot;&gt;오디오 코덱&lt;/a&gt; 과 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Video_codecs&quot;&gt;코덱 비디오&lt;/a&gt; 가이드와 같은 종류의 압축을 사용하는 그들이 지원 얼마나 많은 오디오 채널로의 기술 정보와 함께 호환성 정보를 제공하는 웹 브라우저는 종종 지원하는 다양한 코덱을 나열 및 요금 비트 무엇인지 등 그들이있어 유용합니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/WebRTC_codecs&quot;&gt;한 WebRTC에 의해 사용되는 코덱&lt;/a&gt; 은 브라우저의 범위는 당신이 지원하고자 최선의 커버하는 코덱을 선택할 수 있도록, 특히 주요 웹 브라우저에서 지원하는 코덱을 포함하여시 가이드 확장합니다.</target>
        </trans-unit>
        <trans-unit id="bbd12c73f76eeadd9f5a8a7c267e1d8bb10451c5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://developer.mozilla.org/en/HTTP&quot;&gt;HTTP protocol&lt;/a&gt; provides a special mechanism allowing an already established connection to upgrade to a new, incompatible, protocol. This guide covers how this works and offers examples of scenarios in which it's used.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/HTTP&quot;&gt;HTTP 프로토콜은&lt;/a&gt; 이미 설정된 연결은 새로운 호환되지 않는 프로토콜로 업그레이드 할 수 있도록 특별한 메커니즘을 제공합니다. 이 안내서는 이것이 어떻게 작동하는지 다루고 사용 된 시나리오의 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="56487f351a83f4ece995635d28e031bb9e971d36" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://fetch.spec.whatwg.org/#cross-origin-resource-policy-header&quot;&gt;Cross-Origin-Resource-Policy&lt;/a&gt; header prevents other domains from loading the resources.</source>
          <target state="translated">&lt;a href=&quot;https://fetch.spec.whatwg.org/#cross-origin-resource-policy-header&quot;&gt;크로스 원점 자원 정책&lt;/a&gt; 헤더 방지 자원을로드에서 다른 도메인.</target>
        </trans-unit>
        <trans-unit id="30ff7cff75928c0f981ddbe781c5a37e5b8ec7ad" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias&lt;/a&gt; module has &lt;code&gt;Redirect&lt;/code&gt; and &lt;code&gt;RedirectMatch&lt;/code&gt; directives that set up a &lt;a href=&quot;status/302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt; response (by default):</source>
          <target state="translated">&lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias가의&lt;/a&gt; 모듈은이 &lt;code&gt;Redirect&lt;/code&gt; 및 &lt;code&gt;RedirectMatch&lt;/code&gt; 에 셋업 것을 지시 &lt;a href=&quot;status/302&quot;&gt; &lt;code&gt;302&lt;/code&gt; &lt;/a&gt; (기본적으로) 응답 :</target>
        </trans-unit>
        <trans-unit id="dfdf1721b0f5a67b62cb197634da7d5057e2041b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://observatory.mozilla.org/&quot;&gt;Mozilla Observatory&lt;/a&gt; tool testing the configuration (including this header) of Web sites for safety and security</source>
          <target state="translated">&lt;a href=&quot;https://observatory.mozilla.org/&quot;&gt;모질라 전망대&lt;/a&gt; 안전과 보안을위한 웹 사이트 (이 헤더 포함) 구성을 테스트 도구</target>
        </trans-unit>
        <trans-unit id="b0c2f791ad88a8a7e38ea528eb0f0ccd9df436bb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://tools.ietf.org/html/rfc4648#section-5&quot;&gt;base64url&lt;/a&gt; format is not the same as standard Base64 encoding. This is almost but not quite the same as standard Base64. The only difference: in order to ensure that the resulting string is safe for use in both URLs and filenames, the 62nd and 63rd characters in its alphabet are changed from &lt;code&gt;&quot;+&quot;&lt;/code&gt; and &lt;code&gt;&quot;/&quot;&lt;/code&gt; to &lt;code&gt;&quot;-&quot;&lt;/code&gt; (minus) and &lt;code&gt;&quot;_&quot;&lt;/code&gt; (underscore), respectively.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc4648#section-5&quot;&gt;base64url의&lt;/a&gt; 포맷은 표준 Base64 인코딩과 동일하지 않다. 이것은 표준 Base64와 거의 동일하지는 않습니다. 유일한 차이점 : 결과 문자열이 URL과 파일 이름 모두에서 안전하게 사용할 수 있도록 알파벳의 62 번째와 63 번째 문자가 &lt;code&gt;&quot;+&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 에서 &lt;code&gt;&quot;-&quot;&lt;/code&gt; (빼기) 및 &lt;code&gt;&quot;_&quot;&lt;/code&gt; (밑줄)입니다.</target>
        </trans-unit>
        <trans-unit id="e864176c816370410ca7b511fa51ea0441aec0c3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.iana.org/&quot;&gt;Internet Assigned Numbers Authority (IANA)&lt;/a&gt; is responsible for all official MIME types, and you can find the most up-to-date and complete list at their &lt;a href=&quot;https://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;Media Types&lt;/a&gt; page.</source>
          <target state="translated">&lt;a href=&quot;https://www.iana.org/&quot;&gt;인터넷 할당 번호 관리 기관 (IANA)는&lt;/a&gt; 모든 공식 MIME 유형에 대한 책임이있다, 당신은 자신의 가장 최신 목록을 찾을 수 있습니다 &lt;a href=&quot;https://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;미디어 유형의&lt;/a&gt; 페이지를.</target>
        </trans-unit>
        <trans-unit id="a0ea81494b8105f6717337ab7d95f01a45c084f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;index&quot;&gt;HTTP/1.1 protocol&lt;/a&gt; provides a special mechanism that can be used to upgrade an already established connection to a different protocol, using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header field.</source>
          <target state="translated">&lt;a href=&quot;index&quot;&gt;HTTP / 1.1 프로토콜&lt;/a&gt; 은 Using, 다른 프로토콜에 이미 설정된 연결을 업그레이드 할 수있는 특별한 메커니즘을 제공하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; 헤더 필드.</target>
        </trans-unit>
        <trans-unit id="8ab5fee31c8ccbebe1e49d2cda4be11eb9064dcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method requests a data representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">&lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; 의&lt;/a&gt; 방법은 지정된 자원의 데이터 표현을 요청합니다. &lt;code&gt;GET&lt;/code&gt; 을 사용한 요청 은 데이터 만 검색해야합니다.</target>
        </trans-unit>
        <trans-unit id="85676b7109bc7c3348572fe11d463aa4452c7f6e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; method sends data to a server so it may change its state. This is the method often used for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Forms&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; 의&lt;/a&gt; 그것의 상태를 변경할 수 있도록 방법은 서버로 데이터를 전송한다. 이것은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML 양식에&lt;/a&gt; 자주 사용되는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="759d2232e34b1fccdd6a4688d236906067716e48" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header will be omitted entirely. No referrer information is sent along with requests.</source>
          <target state="translated">&lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; 헤더는 전체적으로 생략된다. 요청과 함께 리퍼러 정보가 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb80c4be8693337fa70be2fe31fd2c4154708a28" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;status/101&quot;&gt;&lt;code&gt;101&lt;/code&gt;&lt;/a&gt; status code is sent as a response to a request including the &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; header to signal that the recipient of the request is willing to upgrade to one of the desired protocols. If the &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; status code is returned, the header must also include the &lt;code&gt;Connection&lt;/code&gt; and &lt;code&gt;Upgrade&lt;/code&gt; headers to describe the chosen protocol. See the examples in &lt;a href=&quot;#Common_uses_for_this_mechanism&quot;&gt;Common uses for this mechanism&lt;/a&gt; to learn more about how this works.</source>
          <target state="translated">&lt;a href=&quot;status/101&quot;&gt; &lt;code&gt;101&lt;/code&gt; &lt;/a&gt; 상태 코드가 포함하는 요청에 대한 응답으로서 송신된다 &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; 는 요청의 수신자가 원하는 프로토콜 중 하나를 업그레이드 할 의사가 있는지 신호 헤더. 는 IF &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; 상태 코드가 반환되고, 헤더도 포함해야 &lt;code&gt;Connection&lt;/code&gt; 및 &lt;code&gt;Upgrade&lt;/code&gt; 선택한 프로토콜을 설명하는 헤더를. 작동 방식에 대한 자세한 내용은 &lt;a href=&quot;#Common_uses_for_this_mechanism&quot;&gt;이 메커니즘의 일반적인 사용&lt;/a&gt; 예를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba7765f4a93430d93893449738d810f79adab493" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;status/300&quot;&gt;&lt;code&gt;300&lt;/code&gt;&lt;/a&gt; (Multiple Choices) or &lt;a href=&quot;status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) &lt;a href=&quot;status&quot;&gt;HTTP response codes&lt;/a&gt; by the server (&lt;em&gt;agent-driven negotiation&lt;/em&gt; or &lt;em&gt;reactive negotiation&lt;/em&gt;), that are used as fallback mechanisms.</source>
          <target state="translated">&lt;a href=&quot;status/300&quot;&gt; &lt;code&gt;300&lt;/code&gt; &lt;/a&gt; (복수 선택) 또는 &lt;a href=&quot;status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt; (불가) &lt;a href=&quot;status&quot;&gt;HTTP 응답 코드를&lt;/a&gt; 서버 (기준 &lt;em&gt;에이전트가 주도하는 협상&lt;/em&gt; 이나 &lt;em&gt;반응 협상&lt;/em&gt; 대체 메커니즘으로 사용된다).</target>
        </trans-unit>
        <trans-unit id="7a2ea4621d5db4a0643b172c60b9729d03740461" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;status/300&quot;&gt;&lt;code&gt;300&lt;/code&gt;&lt;/a&gt; (Multiple Choices) or &lt;a href=&quot;status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable), &lt;a href=&quot;status/415&quot;&gt;&lt;code&gt;415&lt;/code&gt;&lt;/a&gt; (Unsupported Media Type) &lt;a href=&quot;status&quot;&gt;HTTP response codes&lt;/a&gt; by the server (&lt;em&gt;agent-driven negotiation&lt;/em&gt; or &lt;em&gt;reactive negotiation&lt;/em&gt;), that are used as fallback mechanisms.</source>
          <target state="translated">&lt;a href=&quot;status/300&quot;&gt; &lt;code&gt;300&lt;/code&gt; &lt;/a&gt; (복수 선택) 또는 &lt;a href=&quot;status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt; (허용되지 않음), &lt;a href=&quot;status/415&quot;&gt; &lt;code&gt;415&lt;/code&gt; &lt;/a&gt; (지원되지 않는 미디어 유형) &lt;a href=&quot;status&quot;&gt;HTTP 응답 코드를&lt;/a&gt; 서버 (기준 &lt;em&gt;에이전트가 주도하는 협상&lt;/em&gt; 이나 &lt;em&gt;반응 협상&lt;/em&gt; 대체 메커니즘으로 사용된다).</target>
        </trans-unit>
        <trans-unit id="fdc1524f620c113ef489962d737efb33b27f2eac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; request header needs to be set to &quot;trailers&quot; to allow trailer fields.</source>
          <target state="translated">&lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; 의&lt;/a&gt; 요청 헤더 트레일러 필드를 허용하는 &quot;트레일러&quot;로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="106d3051b32652488ca1792a9b8e10220f0e7a85" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt; directive is evaluated before &lt;code&gt;block-all-mixed-content&lt;/code&gt; and If the former is set, the latter is effectively a no-op. It is recommended to set one directive or the other &amp;ndash; not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</source>
          <target state="translated">&lt;a href=&quot;upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt; 지시자는 이전에 평가 &lt;code&gt;block-all-mixed-content&lt;/code&gt; 과 전이 설정되어있는 경우, 후자는 효과적으로 조작은 행해지 지 않습니다. HTTP로 경로 재 지정한 후 강제하지 않는 이전 브라우저에서 HTTPS를 강제 실행하지 않는 한 하나의 지시어 또는 다른 지시어를 둘 다 설정하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5a51eef50de25b01cedd4928f3f99c9fae3d5200" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt; directive is evaluated before &lt;code&gt;block-all-mixed-content&lt;/code&gt;. If the former is set, the latter does nothing, so set one directive or the other &amp;ndash; not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</source>
          <target state="translated">&lt;a href=&quot;upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt; 지시자는 이전에 평가 &lt;code&gt;block-all-mixed-content&lt;/code&gt; . 전자가 설정되어 있으면 후자는 아무 작업도 수행하지 않으므로 HTTP로 리디렉션 한 후 강제로하지 않는 이전 브라우저에서 HTTPS를 강제로 적용하지 않으려면 둘 다가 아닌 하나의 지시문을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0f16849e96b723097d3105369f7d2ec73a2c9b25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header ensures that the content is cached properly (for instance ensuring that the user is not served a lower-quality image from the cache when &lt;code&gt;Save-Data&lt;/code&gt; header is no longer present [&lt;em&gt;e.g.&lt;/em&gt; after having switched from cellular to Wi-Fi]).</source>
          <target state="translated">은 &lt;a href=&quot;vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; (예 때 사용자가 캐시에서 낮은 품질의 이미지를 제공하지 않도록 보장 내용이 적절 캐시 해당 헤더 보장하지만을 &lt;code&gt;Save-Data&lt;/code&gt; 헤더는 더 이상 존재하는 [ &lt;em&gt;예를 들면&lt;/em&gt; 무선 인터넷을 셀룰러로 전환 후의]) .</target>
        </trans-unit>
        <trans-unit id="ce5a0a42af328d6549a6884a0d4203b5b8180652" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'src'&lt;/code&gt; origin is used in the iframe &lt;code&gt;allow&lt;/code&gt; attribute only, and is the &lt;em&gt;default&lt;/em&gt;&lt;code&gt;allowlist&lt;/code&gt; value.</source>
          <target state="translated">&lt;code&gt;'src'&lt;/code&gt; 기원은 iframe이 사용됩니다 &lt;code&gt;allow&lt;/code&gt; 전용 특성을하고있다 &lt;em&gt;기본 &lt;/em&gt; &lt;code&gt;allowlist&lt;/code&gt; 의 값입니다.</target>
        </trans-unit>
        <trans-unit id="a1e69a4edf06fe574fa80e88285f8fb7d88da970" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'strict-dynamic'&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. For example, a policy such as &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; would allow loading of a root script with &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; and propagate that trust to any script loaded by &lt;code&gt;loader.js&lt;/code&gt;, but disallow loading scripts from &lt;code&gt;https://whitelisted.com/&lt;/code&gt; unless accompanied by a nonce or loaded from a trusted script.</source>
          <target state="translated">&lt;code&gt;'strict-dynamic'&lt;/code&gt; 신뢰가 명시 적으로 넌스 또는 해시와 함께 제공함으로써, 마크 업에서 스크립트 현재까지 주어진 원본 식의 지정은, 그 루트 스크립트에 의해로드 된 모든 스크립트에 전달해야한다. 동시에 &lt;code&gt;'self'&lt;/code&gt; 또는 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 과 같은 화이트리스트 또는 소스 표현식 은 무시됩니다. 예를 들어 &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; 과 같은 정책 은 &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; 를 사용하여 루트 스크립트로드를 허용합니다 . example.com/loader.js &quot;&amp;gt; 및 &lt;code&gt;loader.js&lt;/code&gt; 에 의해로드 된 스크립트에 해당 신뢰를 전파 하지만 &lt;code&gt;https://whitelisted.com/&lt;/code&gt; 에서 스크립트로드는 허용하지 않습니다 .//whitelisted.com/ nonce가 동반되거나 신뢰할 수있는 스크립트에서로드되지 않는 한.</target>
        </trans-unit>
        <trans-unit id="b021b3c1d64f7dedfd2f1fd076264572ee155ed2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'strict-dynamic&lt;/code&gt;' source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. For example, a policy such as &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; would allow loading of a root script with &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; and propagate that trust to any script loaded by &lt;code&gt;loader.js&lt;/code&gt;, but disallow loading scripts from &lt;code&gt;https://whitelisted.com/&lt;/code&gt; unless accompanied by a nonce or loaded from a trusted script.</source>
          <target state="translated">&lt;code&gt;'strict-dynamic&lt;/code&gt; 신뢰가 명시 적으로 넌스 또는 해시와 함께 제공함으로써, 마크 업에서 스크립트 현재까지 주어진 것을'원본 식의 지정은, 그 루트 스크립트에 의해로드 된 모든 스크립트에 전달해야한다. 동시에 &lt;code&gt;'self'&lt;/code&gt; 또는 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 과 같은 화이트리스트 또는 소스 표현식 은 무시됩니다. 예를 들어 &lt;code&gt;script-src 'strict-dynamic' 'nonce-R4nd0m' https://whitelisted.com/&lt;/code&gt; 과 같은 정책 을 사용하면 &lt;code&gt;&amp;lt;script nonce=&quot;R4nd0m&quot; src=&quot;https://example.com/loader.js&quot;&amp;gt;&lt;/code&gt; 루트 스크립트를로드 할 수 있습니다. src = &quot;https : // example.com/loader.js &quot;&amp;gt; 및 &lt;code&gt;loader.js&lt;/code&gt; 에 의해로드 된 스크립트에 신뢰를 전파 하지만 &lt;code&gt;https://whitelisted.com/&lt;/code&gt; 에서 스크립트를로드 할 수는 없습니다 .//whitelisted.com/ nonce를 동반하거나 신뢰할 수있는 스크립트에서로드하지 않는 한</target>
        </trans-unit>
        <trans-unit id="6382e529a182503f39a7f7388e99ab1653c33241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'unsafe-eval'&lt;/code&gt; source expression controls several script execution methods that create code from strings. If &lt;code&gt;'unsafe-eval'&lt;/code&gt; isn't specified with the &lt;code&gt;script-src&lt;/code&gt; directive, the following methods are blocked and won't have any effect:</source>
          <target state="translated">&lt;code&gt;'unsafe-eval'&lt;/code&gt; 원본 식 제어 문자열에서 코드를 생성 할 몇 가지 스크립트 실행 방법. 경우 &lt;code&gt;'unsafe-eval'&lt;/code&gt; 로 지정되지 않은 &lt;code&gt;script-src&lt;/code&gt; 지시, 다음과 같은 방법이 차단되어 영향을주지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="7a974fff323538cd623f076264d18fe2300bde8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'unsafe-eval'&lt;/code&gt; source expression controls several style methods that create style declarations from strings. If &lt;code&gt;'unsafe-eval'&lt;/code&gt; isn't specified with the &lt;code&gt;style-src&lt;/code&gt; directive, the following methods are blocked and won't have any effect:</source>
          <target state="translated">&lt;code&gt;'unsafe-eval'&lt;/code&gt; 원본 식 제어 문자열에서 스타일 선언을 만들어 여러 스타일의 방법. 경우 &lt;code&gt;'unsafe-eval'&lt;/code&gt; 로 지정되지 않은 &lt;code&gt;style-src&lt;/code&gt; 지시, 다음과 같은 방법이 차단되어 영향을주지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="c3028d259a6399103c9ce4edc7dfac31909edc67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.htaccess&lt;/code&gt; file references a &lt;code&gt;.htpasswd&lt;/code&gt; file in which each line consists of a username and a password separated by a colon (&lt;code&gt;:&lt;/code&gt;). You cannot see the actual passwords as they are &lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;hashed&lt;/a&gt; (using MD5-based hashing, in this case). Note that you can name your &lt;code&gt;.htpasswd&lt;/code&gt; file differently if you like, but keep in mind this file shouldn't be accessible to anyone. (Apache is usually configured to prevent access to &lt;code&gt;.ht*&lt;/code&gt; files).</source>
          <target state="translated">&lt;code&gt;.htaccess&lt;/code&gt; 파일 참조합니다 &lt;code&gt;.htpasswd&lt;/code&gt; 각 행은 사용자 이름과 콜론으로 구분 암호로 구성되어있는 파일 ( &lt;code&gt;:&lt;/code&gt; ). &lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;해시 된&lt;/a&gt; 실제 암호는 볼 수 없습니다 (이 경우 MD5 기반 해싱 사용). 원하는 경우 &lt;code&gt;.htpasswd&lt;/code&gt; 파일의 이름을 다르게 지정할 수 있지만이 파일은 다른 사람이 액세스 할 수 없어야합니다. (Apache는 일반적으로 &lt;code&gt;.ht*&lt;/code&gt; 파일에 대한 액세스를 방지하도록 구성됩니다 ).</target>
        </trans-unit>
        <trans-unit id="f7d8d01c839e9d424312b47d646a614086c80cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.htaccess&lt;/code&gt; file references a &lt;code&gt;.htpasswd&lt;/code&gt; file in which each line contains of a username and a password separated by a colon (&quot;:&quot;). You can not see the actual passwords as they are &lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;encrypted&lt;/a&gt; (md5 in this case). Note that you can name your &lt;code&gt;.htpasswd&lt;/code&gt; file differently if you like, but keep in mind this file shouldn't be accessible to anyone. (Apache is usually configured to prevent access to &lt;code&gt;.ht*&lt;/code&gt; files).</source>
          <target state="translated">&lt;code&gt;.htaccess&lt;/code&gt; 파일 참조합니다 &lt;code&gt;.htpasswd&lt;/code&gt; 각 행은 사용자 이름이 들어있는 파일과 암호는 콜론으로 구분 ( &quot;&quot;). &lt;a href=&quot;https://httpd.apache.org/docs/2.4/misc/password_encryptions.html&quot;&gt;암호화 된&lt;/a&gt; 실제 비밀번호 (이 경우에는 md5)를 볼 수 없습니다 . 원하는 경우 &lt;code&gt;.htpasswd&lt;/code&gt; 파일의 이름을 다르게 지정할 수 있지만이 파일에 액세스 할 수 없다는 점에 유의하십시오. Apache는 일반적으로 &lt;code&gt;.ht*&lt;/code&gt; 파일에 액세스하지 못하도록 구성되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01ea6c155e3bff628716e111f394e3a0636ae28e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.htaccess&lt;/code&gt; file typically looks like this:</source>
          <target state="translated">&lt;code&gt;.htaccess&lt;/code&gt; 파일은 일반적으로 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="4140f45978733db50c0722e19703d0dd8732110c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;203&lt;/code&gt; response is similar to the value &lt;code&gt;&lt;a href=&quot;../headers/warning#Warning_codes&quot;&gt;214&lt;/a&gt;&lt;/code&gt;, meaning &lt;code&gt;Transformation Applied&lt;/code&gt;, of the &lt;a href=&quot;../headers/warning&quot;&gt;&lt;code&gt;Warning&lt;/code&gt;&lt;/a&gt; header code, which has the additional advantage of being applicable to responses with any status code.</source>
          <target state="translated">&lt;code&gt;203&lt;/code&gt; 응답 값과 유사하다 &lt;code&gt;&lt;a href=&quot;../headers/warning#Warning_codes&quot;&gt;214&lt;/a&gt;&lt;/code&gt; 즉, &lt;code&gt;Transformation Applied&lt;/code&gt; 의, &lt;a href=&quot;../headers/warning&quot;&gt; &lt;code&gt;Warning&lt;/code&gt; &lt;/a&gt; 모든 상태 코드 응답에 적용되는 추가적인 장점을 갖는다 헤더 코드.</target>
        </trans-unit>
        <trans-unit id="fd1e39721a458a8f43a8fa40e465369253ea6854" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;416&lt;/code&gt; response message contains a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; indicating an unsatisfied range (that is a &lt;code&gt;'*'&lt;/code&gt;) followed by a &lt;code&gt;'/'&lt;/code&gt; and the current length of the resource. E.g. &lt;code&gt;Content-Range: */12777&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;416&lt;/code&gt; 응답 메시지가 포함 된 &lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; (a 불만 인 범위를 나타내는 &lt;code&gt;'*'&lt;/code&gt; a로 하였다) &lt;code&gt;'/'&lt;/code&gt; 와 자원의 현재 길이. 예 : &lt;code&gt;Content-Range: */12777&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc6eca35190b0a85bc179efcd6440ff5e420f987" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;416&lt;/code&gt; response message contains a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; indicating an unsatisfied range (that is a &lt;code&gt;'*'&lt;/code&gt;) followed by a &lt;code&gt;'/'&lt;/code&gt; and the current length of the resource. E.g. &lt;code&gt;Content-Range: bytes */12777&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;416&lt;/code&gt; 응답 메시지가 포함 된 &lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; (a 불만 인 범위를 나타내는 &lt;code&gt;'*'&lt;/code&gt; a로 하였다) &lt;code&gt;'/'&lt;/code&gt; 와 자원의 현재 길이. 예 : &lt;code&gt;Content-Range: bytes */12777&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="000250a8c920d71a596d42e3ba222cb0c276eb98" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite&lt;/a&gt;&lt;/code&gt; module can also create redirects. It is more flexible, but a bit more complex.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_rewrite.html&quot;&gt;mod_rewrite&lt;/a&gt;&lt;/code&gt; 모듈은 리디렉션을 만들 수 있습니다. 더 유연하지만 조금 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="d74ebb54bf35188baf88fab6ddfb03450100af2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-allow&quot;&gt;allow&lt;/a&gt;&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">은 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-allow&quot;&gt;allow&lt;/a&gt;&lt;/code&gt; 에 대한 속성 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 해당&lt;/a&gt; 들.</target>
        </trans-unit>
        <trans-unit id="678867190bea86d25ddd4c42f7e5d5945a9962ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; attribute should start with a number indicating how many seconds the browser should wait before redirecting to the given URL. Always set it to &lt;code&gt;0&lt;/code&gt; for accessibility compliance.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; 속성은 브라우저가 지정된 URL로 리디렉션하기 전에 대기해야하는 시간 (초)을 나타내는 숫자로 시작해야합니다. 접근성 준수를 위해 항상 &lt;code&gt;0&lt;/code&gt; 으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e37ff63edc4a58e58577f391879495cdf22ee684" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; attribute starts with a number indicating how many seconds the browser should wait before redirecting to the given URL. Always set it to &lt;code&gt;0&lt;/code&gt;, for better accessibility.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-content&quot;&gt;content&lt;/a&gt;&lt;/code&gt; 몇 초에게 브라우저를 나타내는 숫자와 속성의 시작은 주어진 URL로 리디렉션하기 전에 기다려야합니다. 더 나은 접근성을 위해 항상 &lt;code&gt;0&lt;/code&gt; 으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="df94992d56f1ec3780068eef1f291a2bd6528445" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://developers.google.com/search/reference/robots_meta_tag#xrobotstag&quot;&gt;X-Robots-Tag&lt;/a&gt;&lt;/code&gt; HTTP header is used to indicate how a web page is to be indexed within public search engine results. The header is effectively equivalent to &lt;code&gt;&amp;lt;meta name=&quot;robots&quot; content=&quot;...&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://developers.google.com/search/reference/robots_meta_tag#xrobotstag&quot;&gt;X-Robots-Tag&lt;/a&gt;&lt;/code&gt; HTTP 헤더는 웹 페이지가 공개 검색 엔진 결과에서 색인하는 방법을 나타내는 데 사용됩니다. 헤더는 &lt;code&gt;&amp;lt;meta name=&quot;robots&quot; content=&quot;...&quot;&amp;gt;&lt;/code&gt; 와 실질적으로 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="7d9f882bdef0f2fbd9c820397fd3355193604e73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/compatibility/jj542450(v=vs.85)?#the-noopen-directive&quot;&gt;X-Download-Options&lt;/a&gt;&lt;/code&gt; HTTP header indicates that the browser (Internet Explorer) should not display the option to &quot;Open&quot; a file that has been downloaded from an application, to prevent phishing attacks as the file otherwise would gain access to execute in the context of the application. (Note: related &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/18488178/&quot;&gt;MS Edge bug&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/compatibility/jj542450(v=vs.85)?#the-noopen-directive&quot;&gt;X-Download-Options&lt;/a&gt;&lt;/code&gt; HTTP 헤더는 달리에서 실행에 액세스 할 브라우저 (인터넷 익스플로러) 파일과 피싱 공격을 방지하기 위해 &quot;열기&quot;응용 프로그램에서 다운로드 된 파일에 옵션을 표시 할 것을 나타냅니다 응용 프로그램의 컨텍스트. (참고 : 관련 &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/18488178/&quot;&gt;MS Edge 버그&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8570429a0850dacdf55e905b24382087aa950397" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias&lt;/a&gt;&lt;/code&gt; module has &lt;code&gt;Redirect&lt;/code&gt; and &lt;code&gt;RedirectMatch&lt;/code&gt; directives that set up &lt;a href=&quot;status/302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt; redirects by default:</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_alias.html&quot;&gt;mod_alias&lt;/a&gt;&lt;/code&gt; 가의 모듈은이 &lt;code&gt;Redirect&lt;/code&gt; 및 &lt;code&gt;RedirectMatch&lt;/code&gt; 에 지시를 그 설정 &lt;a href=&quot;status/302&quot;&gt; &lt;code&gt;302&lt;/code&gt; &lt;/a&gt; 기본적으로 리디렉션 :</target>
        </trans-unit>
        <trans-unit id="1a33077bdfc87f84fa941dba1652820231ca50a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; entity-header field provides a means for serialising one or more links in HTTP headers. It is semantically equivalent to the HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; 엔터티 헤더 필드는 HTTP 헤더에 하나 개 이상의 링크를 serialising하는 수단을 제공합니다. 의미 상 HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="0bf90377c54cfb58cf2ddd3a014cf93971e6153b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; entity-header field provides a means for serialising one or more links in HTTP headers. It is semantically equivalent to the HTML &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/link&quot;&gt;&amp;lt;link&amp;gt;&lt;/a&gt;&lt;/code&gt; element.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5988#section-5&quot;&gt;Link&lt;/a&gt;&lt;/code&gt; 엔터티 헤더 필드는 HTTP 헤더에 하나 개 이상의 링크를 serialising하는 수단을 제공합니다. 의미 적으로 HTML &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTML/Element/link&quot;&gt;&amp;lt;link&amp;gt;&lt;/a&gt;&lt;/code&gt; 요소 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a78799203cafc041527d32fff46051e530f3f10a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.1&quot;&gt;Signature&lt;/a&gt;&lt;/code&gt; header field conveys a list of signatures for an exchange, each one accompanied by information about how to determine the authority of and refresh that signature.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.1&quot;&gt;Signature&lt;/a&gt;&lt;/code&gt; 헤더 필드는 교환의 권한을 결정하고 그 서명을 갱신하는 방법에 대한 자세한 내용과 함께 각각에 대해 서명의 목록을 전달한다.</target>
        </trans-unit>
        <trans-unit id="ac287448eebb179af2b5fea39da63acb2f0e34a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.5.1.2&quot;&gt;Signed-Headers&lt;/a&gt;&lt;/code&gt; header field identifies an ordered list of response header fields to include in a signature.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.5.1.2&quot;&gt;Signed-Headers&lt;/a&gt;&lt;/code&gt; 헤더 필드는 서명에 포함 응답 헤더 필드의 정렬 된 목록을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="f3c5f0394e6c797409337c3ba59ac4660eea6b49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Accept-CH-Lifetime&lt;/strong&gt;&lt;/code&gt; header is set by the server to specify the persistence of &lt;a href=&quot;accept-ch&quot;&gt;&lt;code&gt;Accept-CH&lt;/code&gt;&lt;/a&gt; header value that specifies for which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client Hints&lt;/a&gt; headers client should include in subsequent requests.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Accept-CH-Lifetime&lt;/strong&gt;&lt;/code&gt; 헤더의 지속성 지정하기 위해 서버가 설정되어 &lt;a href=&quot;accept-ch&quot;&gt; &lt;code&gt;Accept-CH&lt;/code&gt; &lt;/a&gt; 지정이있는 것으로 헤더 값 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;클라이언트 힌트&lt;/a&gt; 헤더 클라이언트가 후속 요청에 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="1fc84160c5460da89ca680071c3cd21f91aa02e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Accept-CH&lt;/strong&gt;&lt;/code&gt; header is set by the server to specify which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client Hints&lt;/a&gt; headers a client should include in subsequent requests.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Accept-CH&lt;/strong&gt;&lt;/code&gt; 헤더를 지정하기 위해 서버가 설정되어 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;클라이언트 힌트&lt;/a&gt; 클라이언트가 후속 요청에 포함해야 헤더.</target>
        </trans-unit>
        <trans-unit id="d982342366479f245d9e1687b6642ae3d345e689" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Accept-Ranges&lt;/strong&gt;&lt;/code&gt; response HTTP header is a marker used by the server to advertise its support of partial requests. The value of this field indicates the unit that can be used to define a range.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Accept-Ranges&lt;/strong&gt;&lt;/code&gt; 응답 HTTP 헤더 부분 요청의 지원을 광고 서버에 의해 사용되는 마커입니다. 이 필드의 값은 범위를 정의하는 데 사용할 수있는 단위를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d3c88e931c279d244b193828eb2439579c4ee0ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Access-Control-Allow-Origin&lt;/strong&gt;&lt;/code&gt; response header indicates whether the response can be shared with requesting code from the given &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Access-Control-Allow-Origin&lt;/strong&gt;&lt;/code&gt; 응답 헤더는 응답이 주어진에서 코드를 요청과 공유 할 수 있는지 여부를 나타내는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;원&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7e76f11cda78abd0588ec375967af559825d413" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Age&lt;/strong&gt;&lt;/code&gt; header contains the time in seconds the object has been in a proxy cache.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Age&lt;/strong&gt;&lt;/code&gt; 헤더는 객체가 프록시 캐시되었습니다 시간 (초)이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9681dd052c79b13127ae3929a731da18e4b72d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; header lists the set of methods support by a resource.</source>
          <target state="translated">이 &lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; 자원에 의해 지원 헤더 나열 방법의 세트.</target>
        </trans-unit>
        <trans-unit id="c95653d764bb42232e9cbd3888e86cd3686754bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; header lists the set of methods supported by a resource.</source>
          <target state="translated">는 &lt;code&gt;&lt;strong&gt;Allow&lt;/strong&gt;&lt;/code&gt; 헤더 나열 자원에 의해 지원되는 방법의 세트.</target>
        </trans-unit>
        <trans-unit id="acc0cc776eb12ee2c880638b893d5b55050e39bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Digest&lt;/strong&gt;&lt;/code&gt; response HTTP header provides a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/digest&quot;&gt;digest&lt;/a&gt; of the requested resource.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Digest&lt;/strong&gt;&lt;/code&gt; 응답 HTTP 헤더는이 제공하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/digest&quot;&gt;소화&lt;/a&gt; 요청 된 리소스의.</target>
        </trans-unit>
        <trans-unit id="2e78b75471626ac2160cc198bfd26d8ad9f80eb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; header is set by an intermediary to indicate that the request has been conveyed in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS early data&lt;/a&gt;, and also indicates that the intermediary understands the &lt;a href=&quot;../status/425&quot;&gt;&lt;code&gt;425 (Too Early)&lt;/code&gt;&lt;/a&gt; status code.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; 헤더 요청에 반송되었음을 나타내는 중간으로 설정되어 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS 초기 데이터를&lt;/a&gt; , 또한 중간의 이해 것을 나타낸다 &lt;a href=&quot;../status/425&quot;&gt; &lt;code&gt;425 (Too Early)&lt;/code&gt; &lt;/a&gt; 상태 코드.</target>
        </trans-unit>
        <trans-unit id="d61bb0d627ec7b7f17d0bc47d697b57d00a1bc5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; header is set by an intermediate to indicates that the request has been conveyed in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS early data&lt;/a&gt;, and additionally indicates that an intermediary understands the &lt;a href=&quot;../status/425&quot;&gt;&lt;code&gt;425 (Too Early)&lt;/code&gt;&lt;/a&gt; status code. The &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; header is not set by the originator of the request (i.e., a browser).</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; 요청이 반송된다는 것을 의미 헤더 중간으로 설정되어 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Transport_Layer_Security#TLS_1.3&quot;&gt;TLS 이른 데이터&lt;/a&gt; 와 별도로 중개자가 이해하는 것을 나타낸다 &lt;a href=&quot;../status/425&quot;&gt; &lt;code&gt;425 (Too Early)&lt;/code&gt; &lt;/a&gt; 상태 코드. &lt;code&gt;&lt;strong&gt;Early-Data&lt;/strong&gt;&lt;/code&gt; 헤더 (즉, 브라우저) 요청의 송신자에 의해 설정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e737d89463e54c8720f8ad63e418a0bfb0f07f1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Expires&lt;/strong&gt;&lt;/code&gt; header contains the date/time after which the response is considered stale.</source>
          <target state="translated">이 &lt;code&gt;&lt;strong&gt;Expires&lt;/strong&gt;&lt;/code&gt; 헤더는 응답이 부실 간주되는 날짜 / 시간이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5be71a78718c793e01b9247dbf20bee8de751846" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;From&lt;/strong&gt;&lt;/code&gt; request header contains an Internet email address for a human user who controls the requesting user agent.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;From&lt;/strong&gt;&lt;/code&gt; 요청 헤더는 요청 사용자 에이전트를 통제하는 인간 사용자의 인터넷 전자 메일 주소가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="73a9129a968278840bcb3ecb81312e01ea1c7ad9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; request header specifies the domain name of the server (for virtual hosting), and (optionally) the TCP port number on which the server is listening.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; 요청 헤더 (가상 호스팅) 서버의 도메인 이름을 지정하고 (선택 사항) TCP 포트 번호가있는 서버가 듣고있다.</target>
        </trans-unit>
        <trans-unit id="1d90ed71aec05b79116744d2cf8473e3277dfbc7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; request header specifies the host and port number of the server to which the request is being sent.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Host&lt;/strong&gt;&lt;/code&gt; 요청 헤더는 요청이 전송되고되는 서버의 호스트 및 포트 번호를 지정한다.</target>
        </trans-unit>
        <trans-unit id="36122c8169aa84d5fb618cc5e704f67fadc13a5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; general header allows the sender to hint about how the connection and may be used to set a timeout and a maximum amount of requests.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; 일반 헤더는 제한 시간 및 요청의 최대 금액을 설정하는 데 사용할 수있는 방법 연결 및 대한 힌트를 보낸 사람을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0b74d9f17da8401496a5b8c7cf402bea1cb5769" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; general header allows the sender to hint about how the connection may be used to set a timeout and a maximum amount of requests.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Keep-Alive&lt;/strong&gt;&lt;/code&gt; 일반 헤더는 연결이 타임 아웃 요청의 최대 금액을 설정하는 데 사용할 수있는 방법에 대한 힌트를 보낸 사람을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fbf23d9b9327582f4f49a7ec76472bba6a6a4fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Pragma&lt;/strong&gt;&lt;/code&gt; HTTP/1.0 general header is an implementation-specific header that may have various effects along the request-response chain. It is used for backwards compatibility with HTTP/1.0 caches where the &lt;code&gt;Cache-Control&lt;/code&gt; HTTP/1.1 header is not yet present.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Pragma&lt;/strong&gt;&lt;/code&gt; HTTP는 / 1.0 일반 헤더 요청 - 응답 체인을 따라 다양한 효과를 가질 수있는 특정 구현 헤더이다. &lt;code&gt;Cache-Control&lt;/code&gt; HTTP / 1.1 헤더가 아직없는 HTTP / 1.0 캐시와의 하위 호환성을 위해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="df9c97c4ad9d61f0d260427224fcdc949c7f1596" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; request header contains the address of the page making the request. When following a link, this would be the url of the page containing the link. When making AJAX requests to another domain, this would be your page's url. The &lt;code&gt;Referer&lt;/code&gt; header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; 요청 헤더는 요청하는 페이지의 주소를 포함합니다. 링크를 따라갈 때 링크가 포함 된 페이지의 URL이됩니다. 다른 도메인에 AJAX 요청을 할 때 이것은 페이지의 URL이됩니다. &lt;code&gt;Referer&lt;/code&gt; 헤더는 서버가 사람들이 그들을 방문하는 곳 확인하고 예를 들어, 분석, 로깅 또는 최적화 된 캐싱 데이터를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab3c55e276ce88c71d0f16074fd5ecc0e9f413f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; request header contains the address of the previous web page from which a link to the currently requested page was followed. The &lt;code&gt;Referer&lt;/code&gt; header allows servers to identify where people are visiting them from and may use that data for analytics, logging, or optimized caching, for example.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Referer&lt;/strong&gt;&lt;/code&gt; 요청 헤더는 현재 요청 된 페이지에 대한 링크가 이어졌습니다있는 이전 웹 페이지의 주소를 포함합니다. &lt;code&gt;Referer&lt;/code&gt; 헤더는 서버가 사람들이 그들을 방문하는 곳 확인하고 예를 들어, 분석, 로깅 또는 최적화 된 캐싱 데이터를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f35781aa0d1de163111fee93c0d8d38911b682ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; header contains information about the software used by the origin server to handle the request.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; 헤더는 요청을 처리하는 원 서버가 사용하는 소프트웨어에 대한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1b3c683e4cd677dc3be26bd03213dd34909bab4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; header describes the software used by the origin server that handled the request &amp;mdash; that is, the server that generated the response.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Server&lt;/strong&gt;&lt;/code&gt; 응답을 생성하는 서버입니다 - 헤더는 요청을 처리하는 원 서버가 사용하는 소프트웨어에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f72ba03805654f750e5994c434c6ce48268c191f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;TE&lt;/strong&gt;&lt;/code&gt; request header specifies the transfer encodings the user agent is willing to accept. (you could informally call it &lt;em&gt;&lt;code&gt;Accept-Transfer-Encoding&lt;/code&gt;&lt;/em&gt;, which would be more intuitive).</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;TE&lt;/strong&gt;&lt;/code&gt; 의 요청 헤더는 사용자 에이전트가 받아 들일 용의가 전송 인코딩을 지정합니다. (비공식적으로 &lt;em&gt; &lt;code&gt;Accept-Transfer-Encoding&lt;/code&gt; &lt;/em&gt; 이라고 부를 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="5652b37e21feb912010feecdf8d75ae0995d40af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Timing-Allow-Origin&lt;/strong&gt;&lt;/code&gt; response header specifies origins that are allowed to see values of attributes retrieved via features of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;Resource Timing API&lt;/a&gt;, which would otherwise be reported as zero due to cross-origin restrictions.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Timing-Allow-Origin&lt;/strong&gt;&lt;/code&gt; 의 기능을 통해 검색 속성의 값을 볼 수 있습니다 응답 헤더를 지정 기원 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API&quot;&gt;자원 타이밍 API&lt;/a&gt; 그렇지 않으면 때문에 출처 간 제한 0으로보고 될 것이다.</target>
        </trans-unit>
        <trans-unit id="459b5cbc88f2c6244c84b2b7cf57687d4fed7e90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Variant Also Negotiates&lt;/strong&gt;&lt;/code&gt; status code indicates an internal server configuration error in which the chosen variant is itself configured to engage in content negotiation, so is not a proper negotiation endpoint.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Variant Also Negotiates&lt;/strong&gt;&lt;/code&gt; 상태 코드이므로, 선택된 변형 자체 내용 협상에 참여하도록 구성되어있는 내부 서버 구성 에러를 나타내는 적절한 협상 종점이 아니다.</target>
        </trans-unit>
        <trans-unit id="f06db3329ed9ad8dfc09e37ef09b6402d3732e8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Via&lt;/strong&gt;&lt;/code&gt; general header is added by proxies, both forward and reverse proxies, and can appear in the request headers and the response headers. It is used for tracking message forwards, avoiding request loops, and identifying the protocol capabilities of senders along the request/response chain.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Via&lt;/strong&gt;&lt;/code&gt; 일반 헤더는 순방향 및 역방향 프록시 프록시에 의해 첨가하고, 요청 헤더 및 응답 헤더에 표시 할 수있다. 메시지 전달을 추적하고 요청 루프를 피하며 요청 / 응답 체인을 따라 보낸 사람의 프로토콜 기능을 식별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="519d7e47665e940480525b25780c7db7b6681325" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;Want-Digest&lt;/strong&gt;&lt;/code&gt; HTTP header is primarily used in a HTTP request, to ask the responder to provide a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/digest&quot;&gt;digest&lt;/a&gt; of the requested resource using the &lt;code&gt;&lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt;&lt;/code&gt; response header.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;Want-Digest&lt;/strong&gt;&lt;/code&gt; HTTP 헤더는 주로 제공하기 위해 응답자에게 물어, HTTP 요청에서 사용되는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/digest&quot;&gt;소화&lt;/a&gt; 사용하여 요청 된 리소스의 &lt;code&gt;&lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt;&lt;/code&gt; 응답 헤더를.</target>
        </trans-unit>
        <trans-unit id="d2a25ab474d784c5f16b25d0aa6fcd7fc6ce7fc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; response HTTP header is a marker used by the server to indicate that the &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt; advertised in the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; headers should not be changed and be followed. This allows to opt-out of &lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;MIME type sniffing&lt;/a&gt;, or, in other words, it is a way to say that the webmasters knew what they were doing.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; HTTP 헤더는 것을 나타 내기 위해 서버에서 사용되는 마커은 응답 &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME 유형&lt;/a&gt; 에 광고 &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 변경되지 않아야하고 따라야 헤더. 이를 통해 &lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;MIME 유형 스니핑&lt;/a&gt; 을 거부 할 수 있습니다. 즉, 웹 마스터가 자신이하는 일을 알고 있다고 말하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="cd7aecd4c1fd5dec57a2c138b3e5a8c117d9036d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; response HTTP header is a marker used by the server to indicate that the &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt; advertised in the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; headers should not be changed and be followed. This is a way to opt out of &lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;MIME type sniffing&lt;/a&gt;, or, in other words, to say that the MIME types are deliberately configured.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;X-Content-Type-Options&lt;/strong&gt;&lt;/code&gt; HTTP 헤더는 것을 나타 내기 위해 서버에서 사용되는 마커은 응답 &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME 유형&lt;/a&gt; 에 광고 &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 변경되지 않아야하고 따라야 헤더. 이것은 &lt;a href=&quot;../basics_of_http/mime_types#MIME_sniffing&quot;&gt;MIME 유형 스니핑&lt;/a&gt; 을 옵트 아웃하는 방법입니다. 즉, MIME 유형이 의도적으로 구성되었다고 말하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bceacb1272f77c276df2ceb5f3eec10ddfee111d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; part of the UA string indicates if Firefox is running on a phone-sized or tablet device. When Firefox runs on a device that has the phone form factor, there is a &lt;code&gt;Mobile;&lt;/code&gt; token in the &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; part of the UA string. When Firefox runs on a tablet device, there is a &lt;code&gt;Tablet;&lt;/code&gt; token in the &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; part of the UA string instead. For example:</source>
          <target state="translated">UA 문자열 의 &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; 부분은 Firefox가 전화 크기 또는 태블릿 장치에서 실행 중인지 나타냅니다. 전화 폼 팩터가있는 장치에서 Firefox를 실행하면 &lt;code&gt;Mobile;&lt;/code&gt; UA 문자열 의 &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; 부분에있는 토큰 . Firefox가 태블릿 장치에서 실행될 때 &lt;code&gt;Tablet;&lt;/code&gt; 대신 UA 문자열 의 &lt;code&gt;&lt;var&gt;platform&lt;/var&gt;&lt;/code&gt; 부분에 토큰을 추가하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82e98053eac989383e680a4cf5cc9358923e6dcb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="6df4384dcc248042b53e1dc48377a116aa3f10ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-CH&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-CH&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="c43f0f2a86e0d2275393478d7fdb73db5ffbaada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Charset&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-Charset&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="2cb1ca877d3eb1b0f248f74c9ec40232997e5dc5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Charset&lt;/code&gt; request HTTP header advertises which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/character_encoding&quot;&gt;character encodings&lt;/a&gt; the client understands. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server selects one of the encodings, uses it, and informs the client of its choice within the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; response header, usually in a &lt;code&gt;charset=&lt;/code&gt; parameter. Browsers usually don't send this header, as the default value for each resource is usually correct and transmitting it would allow &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Privacy/Tracking_Protection&quot;&gt;fingerprinting&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Accept-Charset&lt;/code&gt; HTTP 헤더이 광고를하는 요청 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/character_encoding&quot;&gt;문자 인코딩&lt;/a&gt; 클라이언트가 이해를. &lt;a href=&quot;../content_negotiation&quot;&gt;콘텐츠 협상을&lt;/a&gt; 사용 하여 서버는 인코딩 중 하나를 선택하고 사용 하며 일반적으로 &lt;code&gt;charset=&lt;/code&gt; 매개 변수 의 &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 응답 헤더 내에서 선택 사항을 클라이언트에 알립니다 . 브라우저는 일반적으로이 헤더를 보내지 않습니다. 각 리소스의 기본값은 일반적으로 정확하고 전송하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Privacy/Tracking_Protection&quot;&gt;지문 인식&lt;/a&gt; 이 허용되기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="1e1a79dc44f6324b9656f0e9b91f70c6b6ee9b87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Charset&lt;/code&gt; request HTTP header advertises which character set the client is able to understand. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server then selects one of the proposals, uses it and informs the client of its choice within the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; response header. Browsers usually don't set this header as the default value for each content type is usually correct and transmitting it would allow easier fingerprinting.</source>
          <target state="translated">&lt;code&gt;Accept-Charset&lt;/code&gt; HTTP 헤더이 광고를 클라이언트가 이해할 수있는 문자 집합을 요청합니다. 그런 다음 &lt;a href=&quot;../content_negotiation&quot;&gt;컨텐츠 협상을&lt;/a&gt; 사용 하여 서버는 제안 중 하나를 선택하고이를 사용하여 클라이언트에게 &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 응답 헤더 내에서 선택한 것을 알립니다 . 브라우저는 일반적으로이 헤더를 각 컨텐츠 유형의 기본값이 올바른 것으로 설정하지 않으며이를 전송하면 더 쉬운 지문 인식이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="32e4c478c87a3a2796f89e9931f3a93966bdfdbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Encoding&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-Encoding&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="91185be688fa9da1a182310f6df358fd174c46f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Encoding&lt;/code&gt; request HTTP header advertises which content encoding, usually a compression algorithm, the client is able to understand. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server selects one of the proposals, uses it and informs the client of its choice with the &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt; response header.</source>
          <target state="translated">&lt;code&gt;Accept-Encoding&lt;/code&gt; 요청 HTTP 헤더이 광고를 콘텐츠 된 인코딩, 일반적으로 압축 알고리즘, 클라이언트가 이해 할 수 있습니다. 서버는 &lt;a href=&quot;../content_negotiation&quot;&gt;컨텐츠 협상을&lt;/a&gt; 사용 하여 제안서 중 하나를 선택하여 사용하고 클라이언트에게 &lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt; 응답 헤더를 사용하여 선택한 것을 알립니다 .</target>
        </trans-unit>
        <trans-unit id="3ae7d36d36006ff093b2a55d71bd74d51e77b3ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Language&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept-Language&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="c4a25b290f315f1cab7813fec6b003a441c0d600" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Language&lt;/code&gt; request HTTP header advertises which languages the client is able to understand, and which locale variant is preferred. (By languages, we mean natural languages, such as English, and not programming languages.) Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server then selects one of the proposals, uses it and informs the client of its choice with the &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt; response header. Browsers set adequate values for this header according to their user interface language and even if a user can change it, this happens rarely (and is frowned upon as it leads to fingerprinting).</source>
          <target state="translated">&lt;code&gt;Accept-Language&lt;/code&gt; HTTP 헤더이 광고를 클라이언트가 이해할 수있는 언어로, 어느 로케일 변형하는 것이 바람직하고 요청합니다. (언어로, 우리는 프로그래밍 언어가 아닌 영어와 같은 자연어를 의미합니다.) &lt;a href=&quot;../content_negotiation&quot;&gt;컨텐츠 협상을&lt;/a&gt; 사용 하여 서버는 제안 중 하나를 선택하여 사용하고 클라이언트에게 &lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt; 응답 헤더를 사용하여 선택한 것을 알립니다 . 브라우저는 사용자 인터페이스 언어에 따라이 헤더에 적절한 값을 설정하며, 사용자가 변경할 수있는 경우에도 거의 발생하지 않으며 지문으로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1d16f67263a6c86cf3fcdfef1e4b190e49a0296" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Patch&lt;/code&gt; response HTTP header advertises which media-type the server is able to understand in a PATCH request.</source>
          <target state="translated">&lt;code&gt;Accept-Patch&lt;/code&gt; 서버를 미디어 - 입력 응답 HTTP 헤더이 광고를 패치 요청에서 이해할 수있다.</target>
        </trans-unit>
        <trans-unit id="6003efca5251790ce42906144c5dccf2f87ad99b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept-Post&lt;/code&gt; response HTTP header advertises which &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;media types&lt;/a&gt; are accepted by the server for HTTP post requests.</source>
          <target state="translated">&lt;code&gt;Accept-Post&lt;/code&gt; 응답 HTTP 헤더이 광고를 &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;매체 유형은&lt;/a&gt; HTTP 포스트 요청을 서버에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1004b9f5d3731dda0f9cb684f40a19f9053e7da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Accept&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="826c8958d78002b0f5bee62cfd9d7b4401ff27e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Accept&lt;/code&gt; request HTTP header advertises which content types, expressed as &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;, the client is able to understand. Using &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;, the server then selects one of the proposals, uses it and informs the client of its choice with the &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; response header. Browsers set adequate values for this header depending on the context where the request is done: when fetching a CSS stylesheet a different value is set for the request than when fetching an image, video or a script.</source>
          <target state="translated">&lt;code&gt;Accept&lt;/code&gt; 로 표현 내용 유형, 요청 HTTP 헤더이 광고를 &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME 유형&lt;/a&gt; , 클라이언트가 이해 할 수 있습니다. &lt;a href=&quot;../content_negotiation&quot;&gt;컨텐츠 협상을&lt;/a&gt; 사용 하여 서버는 제안 중 하나를 선택하여 사용하고 클라이언트에게 &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 응답 헤더를 사용하여 선택한 것을 알립니다 . 브라우저는 요청이 수행되는 컨텍스트에 따라이 헤더에 적절한 값을 설정합니다. CSS 스타일 시트를 가져올 때 이미지, 비디오 또는 스크립트를 가져올 때와 다른 값이 요청에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="44e072ab59ddfb74fd5772684f9e86075ecb4b7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; header works in conjunction with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;&lt;code&gt;XMLHttpRequest.withCredentials&lt;/code&gt;&lt;/a&gt; property or with the &lt;code&gt;credentials&lt;/code&gt; option in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/Request&quot;&gt;&lt;code&gt;Request()&lt;/code&gt;&lt;/a&gt; constructor of the Fetch API. For a CORS request with credentials, in order for browsers to expose the response to frontend JavaScript code, both the server (using the &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; header) and the client (by setting the credentials mode for the XHR, Fetch, or Ajax request) must indicate that they&amp;rsquo;re opting in to including credentials.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 와 함께 작동 헤더 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt; &lt;code&gt;XMLHttpRequest.withCredentials&lt;/code&gt; 의&lt;/a&gt; 속성 또는으로 &lt;code&gt;credentials&lt;/code&gt; 에서 옵션을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/Request&quot;&gt; &lt;code&gt;Request()&lt;/code&gt; &lt;/a&gt; 페치 API의 생성자를. 자격 증명이있는 CORS 요청의 경우, 브라우저가 서버 ( &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 헤더를 사용하여 )와 클라이언트 (XHR, Fetch, 또는 Ajax 요청)은 자격 증명 포함을 선택하고 있음을 나타내야합니다.</target>
        </trans-unit>
        <trans-unit id="b7dcdecf1d26a57b7f2c288b092d6918cb0c9128" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; response header indicates whether or not the response to the request can be exposed to the page. It can be exposed when the &lt;code&gt;true&lt;/code&gt; value is returned.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 응답 헤더는 요청에 대한 응답이 페이지에 노출 될 수 있는지 여부를 나타냅니다. &lt;code&gt;true&lt;/code&gt; 값이 반환 될 때 노출 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c6671b887bc83cf312809fdd2c8e99c4197d40f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; response header tells browsers whether to expose the response to frontend JavaScript code when the request's credentials mode (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt;) is &quot;&lt;code&gt;include&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 응답 헤더는 요청의 인증 모드 (경우에 자바 스크립트 코드를 프론트 엔드에 대한 응답을 노출 여부를 브라우저에 알려줍니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; 가&lt;/a&gt; ) &quot;입니다 &lt;code&gt;include&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="f12c8be59963d49889bc73472fd35b514c851a07" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; response header tells browsers whether to expose the response to frontend JavaScript code when the request's credentials mode (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;include&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 응답 헤더는 요청의 인증 모드 (경우에 자바 스크립트 코드를 프론트 엔드에 대한 응답을 노출 여부를 브라우저에 알려줍니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; 은&lt;/a&gt; )는 &lt;code&gt;include&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72353e1b96e08b162b2efe8857a396c5cd57de4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header is sent by the server in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;; it lets the client know which &lt;a href=&quot;../../headers&quot;&gt;HTTP headers&lt;/a&gt; are permitted in CORS requests. If the client &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; finds among the comma-delineated values provided by the header any header name it does not recognize, this error occurs.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 헤더는에 응답하여 서버에서 전송되는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;프리 플라이트 요청&lt;/a&gt; ; CORS 요청에 어떤 &lt;a href=&quot;../../headers&quot;&gt;HTTP 헤더&lt;/a&gt; 가 허용 되는지 클라이언트에 알려 줍니다. 클라이언트 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트&lt;/a&gt; 가 헤더에서 제공하지 않는 쉼표로 구분 된 값 중에서 헤더 이름으로 인식되지 않는 헤더 이름을 찾으면이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0864906322164b5b88f217b19f6a18996814ca0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header is sent by the server to let the client know which headers it supports for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; requests. The value of &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; should be a comma-delineated list of header names, such as &quot;&lt;code&gt;X-Custom-Information&lt;/code&gt;&quot; or any of the standard but non-basic header names (which are always allowed).</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 헤더는이에 대해 지원하는 헤더 클라이언트 알리기 위해 서버에서 전송되는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS의&lt;/a&gt; 요청을. &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 의 값은 &quot; &lt;code&gt;X-Custom-Information&lt;/code&gt; &quot;또는 기본이 아닌 표준 헤더 이름 (항상 허용됨) 과 같이 쉼표로 구분 된 헤더 이름 목록이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="dd672b7157d867818df2e4b6551047d6d6feb57a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header is sent by the server to let the client know which headers it supports for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; requests. The value of &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; should be a comma-delineated list of header names, such as &lt;code&gt;&quot;X-Custom-Information&quot;&lt;/code&gt; or any of the standard but non-basic header names (which are always allowed).</source>
          <target state="translated">서버는 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 헤더를 보내 클라이언트가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; 요청을 지원하는 헤더를 알려줍니다 . &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 의 값은 &lt;code&gt;&quot;X-Custom-Information&quot;&lt;/code&gt; 과 같이 쉼표로 구분 된 헤더 이름 목록 이거나 표준이지만 기본이 아닌 헤더 이름 (항상 허용됨) 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7ff32aaa41aa73f3f46503d5b741dbb0efe92ed8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; response header is used in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; which includes the &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; to indicate which HTTP headers can be used during the actual request.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 응답 헤더는 응답에 사용되는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;프리 플라이트 요청&lt;/a&gt; 포함 &lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; 실제 요청시 사용할 수있는 HTTP 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e0316b88b462433d980db8987aaedc7affa9a74d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; header is sent by the server to let the client know what &lt;a href=&quot;../../methods&quot;&gt;HTTP request methods&lt;/a&gt; it supports for CORS requests. The header's value is a comma-delineated string of HTTP method names, such as &lt;a href=&quot;../../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;. If any of the specified values are not recognized by the client &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;, this error occurs.</source>
          <target state="translated">서버가 &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 헤더를 보내 클라이언트가 CORS 요청에 대해 지원 하는 &lt;a href=&quot;../../methods&quot;&gt;HTTP 요청 방법&lt;/a&gt; 을 알려줍니다 . 헤더의 값은 &lt;a href=&quot;../../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 와 같이 쉼표로 구분 된 HTTP 메소드 이름 문자열입니다 . 클라이언트 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트&lt;/a&gt; 가 지정된 값을 인식하지 못하면 이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="77116c8fb41e193fc817da845099a6fb246839d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; response header specifies the method or methods allowed when accessing the resource in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; (A)에 응답하여, 상기 자원에 액세스 할 때의 방법 또는 방법들은 허용 응답 헤더 지정 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;플라이트 요청&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="067f39d99ac015284dffa6b70703714ad54ce876" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; response header indicates which headers can be exposed as part of the response by listing their names.</source>
          <target state="translated">&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; 응답 헤더는 헤더 이름을 나열하여 응답의 한 부분으로 노출 될 수 있습니다 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0d0b9369d0f212ed412c895390853280713fe380" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; response header indicates how long the results of a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; (that is the information contained in the &lt;a href=&quot;access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; headers) can be cached.</source>
          <target state="translated">&lt;code&gt;Access-Control-Max-Age&lt;/code&gt; 응답 헤더는 얼마나 오래 결과를 나타냅니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;프리 플라이트 요청&lt;/a&gt; 합니다 (에 포함 된 정보입니다 &lt;a href=&quot;access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt; 캐시 할 수있는 헤더).</target>
        </trans-unit>
        <trans-unit id="d911724c3b9a4293a98fa691e196743b5241679f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; request header is used by browsers when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;, to let the server know which &lt;a href=&quot;../headers&quot;&gt;HTTP headers&lt;/a&gt; the client might send when the actual request is made.</source>
          <target state="translated">&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; 발행 할 때 요청 헤더는 브라우저에서 사용되는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;프리 플라이트 요청을&lt;/a&gt; 서버에 알려, &lt;a href=&quot;../headers&quot;&gt;HTTP 헤더&lt;/a&gt; 실제 요청이 때 클라이언트에서 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dafa896f612431fbab583cf168f3881c2f6b27aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; request header is used when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; to let the server know which &lt;a href=&quot;../headers&quot;&gt;HTTP headers&lt;/a&gt; will be used when the actual request is made.</source>
          <target state="translated">&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; 발행 할 때 요청 헤더가 사용됩니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;프리 플라이트 요청&lt;/a&gt; 서버 알려 &lt;a href=&quot;../headers&quot;&gt;HTTP 헤더&lt;/a&gt; 실제 요청이있을 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="da80f865ca3264cb02c6582db1c71f9050cac42c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; request header is used by browsers when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt;, to let the server know which &lt;a href=&quot;../methods&quot;&gt;HTTP method&lt;/a&gt; will be used when the actual request is made. This header is necessary as the preflight request is always an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; and doesn't use the same method as the actual request.</source>
          <target state="translated">&lt;code&gt;Access-Control-Request-Method&lt;/code&gt; 발행 할 때 요청 헤더는 브라우저에서 사용되는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;프리 플라이트 요청을&lt;/a&gt; 서버에 알려, &lt;a href=&quot;../methods&quot;&gt;HTTP 방법&lt;/a&gt; 실제 요청이있을 때 사용됩니다. 이 헤더는 실행 전 요청이 항상 &lt;a href=&quot;../methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; 이고 실제 요청과 동일한 방법을 사용하지 않기 때문에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9c04d281d947283fc5e13f4243911531dd1e81ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; request header is used when issuing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;preflight request&lt;/a&gt; to let the server know which &lt;a href=&quot;../methods&quot;&gt;HTTP method&lt;/a&gt; will be used when the actual request is made. This header is necessary as the preflight request is always an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; and doesn't use the same method as the actual request.</source>
          <target state="translated">&lt;code&gt;Access-Control-Request-Method&lt;/code&gt; 발행 할 때 요청 헤더가 사용됩니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/preflight_request&quot;&gt;프리 플라이트 요청&lt;/a&gt; 서버 알려 &lt;a href=&quot;../methods&quot;&gt;HTTP 방법&lt;/a&gt; 실제 요청이있을 때 사용됩니다. 프리 플라이트 요청은 항상 &lt;a href=&quot;../methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; 이며 실제 요청과 동일한 방법을 사용하지 않으므로이 헤더가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="c0cd5616b768c68f7ab87609f718d08faf8821ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Age&lt;/code&gt; header is usually close to zero. If it is &lt;code&gt;Age: 0&lt;/code&gt;, it was probably just fetched from the origin server; otherwise It is usually calculated as a difference between the proxy's current date and the &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; general header included in the HTTP response.</source>
          <target state="translated">&lt;code&gt;Age&lt;/code&gt; 헤더는 일반적으로 가까운 제로입니다. 이 경우 &lt;code&gt;Age: 0&lt;/code&gt; , 그것은 아마 원본 서버에서 가져되었다; 그렇지 않으면 일반적으로 프록시의 현재 날짜와 HTTP 응답에 포함 된 &lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 일반 헤더 의 차이로 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="86a92479e304493df13e1947522f656380ef064d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alt-Svc&lt;/code&gt; HTTP response header is used to advertise alternative services through which the same resource can be reached. An alternative service is defined by a protocol/host/port combination.</source>
          <target state="translated">&lt;code&gt;Alt-Svc&lt;/code&gt; HTTP 응답 헤더는 동일한 자원에 도달 할 수있는 다른 서비스를 광고하는 데 사용됩니다. 대체 서비스는 프로토콜 / 호스트 / 포트 조합으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="58db6b4226911c9c041223607c76d210c4b75632" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alt-Svc&lt;/code&gt; header is used to list alternate ways to reach this website.</source>
          <target state="translated">&lt;code&gt;Alt-Svc&lt;/code&gt; 헤더는이 웹 사이트에 도달하기 위해 목록 다른 방법으로 사용된다.</target>
        </trans-unit>
        <trans-unit id="f8bcd29c16619b65da2808b96987a30c145398a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECT&lt;/code&gt; method establishes a tunnel to the server identified by the target resource.</source>
          <target state="translated">&lt;code&gt;CONNECT&lt;/code&gt; 의 방법은 타겟 자원에 의해 식별되는 서버에 터널을 설정한다.</target>
        </trans-unit>
        <trans-unit id="d62340e78d8072dcadbb02101963582d73906639" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECT&lt;/code&gt; method starts two-way communications with the requested resource. It can be used to open a tunnel.</source>
          <target state="translated">&lt;code&gt;CONNECT&lt;/code&gt; 의 방법은 요청 된 리소스와 양방향 통신을 시작합니다. 터널을 여는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8e201387bc9b6658a40f0cd1fa9bd028389520f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CONNECT&lt;/code&gt; starts two-way communications with the requested resource. It can be used to open a tunnel.</source>
          <target state="translated">&lt;code&gt;CONNECT&lt;/code&gt; 는 요청 된 리소스와 양방향 통신을 시작합니다. 터널을 여는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6df08e573a851328603ffe071d7221d02feef0bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-Control&lt;/code&gt; HTTP header holds &lt;em&gt;directives&lt;/em&gt; (instructions) for &lt;a href=&quot;../caching&quot;&gt;caching&lt;/a&gt; in both requests and responses. A given directive in a request does not mean the same directive should be in the response.</source>
          <target state="translated">&lt;code&gt;Cache-Control&lt;/code&gt; HTTP 헤더는 보유 &lt;em&gt;지침&lt;/em&gt; 에 대한 (지침) &lt;a href=&quot;../caching&quot;&gt;캐싱&lt;/a&gt; 요청과 응답 모두를. 요청에 지정된 지시문이 응답에 동일한 지시문이 있어야 함을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="dcb3aeaa30daf04257b5de4b9c07c7b9084e9851" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-Control&lt;/code&gt; general-header field is used to specify directives for caching mechanisms in both requests and responses. Caching directives are unidirectional, meaning that a given directive in a request is not implying that the same directive is to be given in the response.</source>
          <target state="translated">&lt;code&gt;Cache-Control&lt;/code&gt; 일반 헤더 필드는 요청과 응답 모두 메커니즘을 캐싱에 대한 지시자를 표시하는 데 사용한다. 캐싱 지시문은 단방향이므로 요청의 지정된 지시문이 응답에 동일한 지시문이 제공되어야 함을 의미하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06a62b505dd9b8d1a88549c8be79a0204c13ff7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-Control&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Cache-Control&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="61c781f98a9ab9c12f19392e18737aa478f857a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cache-control&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Cache-control&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="c446d7df905a8656f6c8ae1eb3467db307c496ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clear-Site-Data&lt;/code&gt; header accepts one or more directives. If all types of data should be cleared, the wildcard directive (&lt;code&gt;&quot;*&quot;&lt;/code&gt;) can be used.</source>
          <target state="translated">&lt;code&gt;Clear-Site-Data&lt;/code&gt; 헤더는 하나 개 이상의 지시를 받아들입니다. 모든 유형의 데이터를 지우면 와일드 카드 지시문 ( &lt;code&gt;&quot;*&quot;&lt;/code&gt; )을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aaa643bf0a85cb5496af99271031c5e3d158467e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Clear-Site-Data&lt;/code&gt; header clears browsing data (cookies, storage, cache) associated with the requesting website. It allows web developers to have more control over the data stored locally by a browser for their origins.</source>
          <target state="translated">&lt;code&gt;Clear-Site-Data&lt;/code&gt; 헤더는 요청 웹 사이트와 관련된 데이터 (쿠키, 저장, 캐시)을 찾아 삭제합니다. 이를 통해 웹 개발자는 브라우저를 통해 로컬에 저장된 데이터를보다 효과적으로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f577eabd139f31271f00d10bbba8aad8ea919cc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Connection&lt;/code&gt; general header controls whether or not the network connection stays open after the current transaction finishes. If the value sent is &lt;code&gt;keep-alive&lt;/code&gt;, the connection is persistent and not closed, allowing for subsequent requests to the same server to be done.</source>
          <target state="translated">&lt;code&gt;Connection&lt;/code&gt; 일반 헤더 컨트롤이 있는지 여부를 네트워크 연결 숙박은 현재 트랜잭션이 완료된 후 엽니 다. 전송 된 값이 &lt;code&gt;keep-alive&lt;/code&gt; 인 경우 연결은 지속적이며 닫히지 않으므로 동일한 서버에 대한 후속 요청을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d537fcd6c95a2057cfd4527c292424b94b1ea111" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Connection&lt;/code&gt; header is set to &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; to indicate that an upgrade is requested.</source>
          <target state="translated">&lt;code&gt;Connection&lt;/code&gt; 헤더로 설정 &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; 업그레이드가 요구되는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2861dc12e30d4470a55eeb695e751b55e5e6a33a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Disposition&lt;/code&gt; header is defined in the larger context of MIME messages for e-mail, but only a subset of the possible parameters apply to HTTP forms and &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; requests. Only the value &lt;code&gt;form-data&lt;/code&gt;, as well as the optional directive &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;filename&lt;/code&gt;, can be used in the HTTP context.</source>
          <target state="translated">&lt;code&gt;Content-Disposition&lt;/code&gt; 헤더는 전자 메일 MIME 메시지의 큰 맥락에서 정의되지만 가능한 매개 변수의 서브 세트 만 HTTP 양식 및 적용 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; 의&lt;/a&gt; 요청. 선택적 지시문 &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;filename&lt;/code&gt; 뿐만 아니라 &lt;code&gt;form-data&lt;/code&gt; 값만 HTTP 컨텍스트에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="488c45ed82b63009ef20ba093e068984681301a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Encoding&lt;/code&gt; entity header is used to compress the media-type. When present, its value indicates which encodings were applied to the entity-body. It lets the client know how to decode in order to obtain the media-type referenced by the &lt;code&gt;Content-Type&lt;/code&gt; header.</source>
          <target state="translated">&lt;code&gt;Content-Encoding&lt;/code&gt; 엔티티 헤더는 미디어 유형을 압축하는 데 사용됩니다. 존재하는 경우 해당 값은 엔티티 본문에 적용된 인코딩을 나타냅니다. &lt;code&gt;Content-Type&lt;/code&gt; 헤더가 참조하는 미디어 유형을 얻기 위해 클라이언트에게 디코딩 방법을 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="43905a4350aba1098e2a710d64c8e9ee9088db8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt; header is used to specify the &lt;strong&gt; intended audience of the page&lt;/strong&gt;, and can indicate that this is more than one language.</source>
          <target state="translated">&lt;code&gt;Content-Language&lt;/code&gt; 헤더는 지정하는 데 사용되는 &lt;strong&gt;페이지의 대상 독자를&lt;/strong&gt; ,이 더 하나 개의 언어보다 것을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76fdb5d41ede9d4b6ff14e156b9fc840583f22aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;entity header&lt;/a&gt; is used to &lt;strong&gt;describe the language(s) intended for the audience&lt;/strong&gt;, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="translated">&lt;code&gt;Content-Language&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;엔티티 헤더는&lt;/a&gt; 데 사용되는 &lt;strong&gt;언어 (들)을 설명하는 사용자를 대상으로&lt;/strong&gt; 는 사용자가 사용자의 선호하는 언어에 따라 차별화 할 수 있습니다 그래서.</target>
        </trans-unit>
        <trans-unit id="a7cdf9f8259b0b027b83c7eabaf300c7bb40cfcd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Language&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;entity header&lt;/a&gt; is used to describe the language(s) intended for the audience, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="translated">&lt;code&gt;Content-Language&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/entity_header&quot;&gt;엔티티 헤더&lt;/a&gt; 는 사용자가 사용자의 선호하는 언어에 따라 차별화 할 수 있습니다 그래서, 언어 (들)을 설명하는 사용자를 대상으로하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ceb94b4b8102114799b44b32b66d5292b6f1285" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Length&lt;/code&gt; entity header indicates the size of the entity-body, in bytes, sent to the recipient.</source>
          <target state="translated">&lt;code&gt;Content-Length&lt;/code&gt; 엔터티 헤더는 기업-body의 크기를 바이트 단위로 수신자에게 전송.</target>
        </trans-unit>
        <trans-unit id="5d90bdb5582a8fea93b884b09c9eb8e68632eacc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Location&lt;/code&gt; header indicates an alternate location for the returned data. The principal use is to indicate the URL of a resource transmitted as the result of &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Content-Location&lt;/code&gt; 헤더는 반환 된 데이터의 대체 위치를 나타냅니다. 주된 용도는 &lt;a href=&quot;../content_negotiation&quot;&gt;컨텐츠 협상&lt;/a&gt; 의 결과로 전송 된 자원의 URL을 나타내는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="23071b7ae3831b0ab8df674533efac8686372e32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Range&lt;/code&gt; response HTTP header indicates where in a full body message a partial message belongs.</source>
          <target state="translated">&lt;code&gt;Content-Range&lt;/code&gt; 전체 본문 메시지에 일부 메시지가 속한 곳 응답 HTTP 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7a62e0c2806ef55661c99afdb86b1f8e171c816e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;strong&gt;&lt;dfn&gt;&lt;code&gt;Report-To&lt;/code&gt;&lt;/dfn&gt;&lt;/strong&gt; HTTP response header field instructs the user agent to store reporting endpoints for an origin.</source>
          <target state="translated">&lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;strong&gt;&lt;dfn&gt; &lt;code&gt;Report-To&lt;/code&gt; &lt;/dfn&gt;&lt;/strong&gt; 응답 헤더 필드 HTTP는 원점에 대한보고 엔드 포인트를 저장하는 사용자 에이전트에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="eda7fd480680111156c0cfd188e09b05c5966f8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Content-Type&lt;/code&gt; entity header is used to indicate the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MIME_type&quot;&gt;media type&lt;/a&gt; of the resource.</source>
          <target state="translated">&lt;code&gt;Content-Type&lt;/code&gt; 엔티티 헤더는 표시하는 데 사용되는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MIME_type&quot;&gt;미디어 유형&lt;/a&gt; 자원을.</target>
        </trans-unit>
        <trans-unit id="426d10d47e9cd0040a6dc32d3445f661ae1dd5ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cookie&lt;/code&gt; HTTP request header contains stored &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt; previously sent by the server with the &lt;a href=&quot;set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">&lt;code&gt;Cookie&lt;/code&gt; HTTP 요청 헤더가 저장 포함 &lt;a href=&quot;../cookies&quot;&gt;HTTP 쿠키&lt;/a&gt; 이전에 서버가 보낸 &lt;a href=&quot;set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; 헤더를.</target>
        </trans-unit>
        <trans-unit id="55cd10bb3eab56fcb3aaa9ed9e419b3b3cdd6947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Cookie&lt;/code&gt; header is optional and may be omitted if, for example, the browser's privacy settings block cookies.</source>
          <target state="translated">&lt;code&gt;Cookie&lt;/code&gt; 헤더는 선택 사항이며, 예를 들어, 브라우저의 개인 정보 설정이 쿠키를 차단, 경우 생략 할 수있다.</target>
        </trans-unit>
        <trans-unit id="906194f2cbb1fc47870cf91c47d3fd010f4ebd31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELETE&lt;/code&gt; deletes the specified resource.</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; 는 지정된 자원을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="82dc9f4d351ce501d0f5c9cfab64763375d85ec2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELETE&lt;/code&gt; method deletes the specified resource.</source>
          <target state="translated">&lt;code&gt;DELETE&lt;/code&gt; 방법은 지정된 자원을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="52d55ecc480b283f141b3b6f98cde8cb0145d572" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DNT&lt;/code&gt; (&lt;strong&gt;D&lt;/strong&gt;o &lt;strong&gt;N&lt;/strong&gt;ot &lt;strong&gt;T&lt;/strong&gt;rack) request header indicates the user's tracking preference. It lets users indicate whether they would prefer privacy rather than personalized content.</source>
          <target state="translated">&lt;code&gt;DNT&lt;/code&gt; ( &lt;strong&gt;D&lt;/strong&gt; O &lt;strong&gt;N&lt;/strong&gt; OT &lt;strong&gt;T&lt;/strong&gt; 요청 헤더 랙) 사용자의 트래킹 순위를 나타낸다. 이를 통해 사용자는 개인화 된 컨텐츠보다는 프라이버시를 선호하는지 여부를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cd717754d93b6be80da07e08c9fb1185b7e6942" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DPR&lt;/code&gt; header is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client Hints&lt;/a&gt; headers which represents the client device pixel ratio (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DPR&quot;&gt;DPR&lt;/a&gt;), which is the the number of physical device pixels corresponding to every CSS pixel.</source>
          <target state="translated">&lt;code&gt;DPR&lt;/code&gt; 의 헤더는 인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;클라이언트 힌트&lt;/a&gt; 클라이언트 장치 화소 비율 (나타내는 헤더 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DPR&quot;&gt;DPR&lt;/a&gt; 모든 CSS 화소에 대응하는 물리적 장치의 화소의 수이다).</target>
        </trans-unit>
        <trans-unit id="71ac6b7e2c0b37cbc89c1ece6a483f1521bccee2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Date&lt;/code&gt; general HTTP header contains the date and time at which the message was originated.</source>
          <target state="translated">&lt;code&gt;Date&lt;/code&gt; 일반 HTTP 헤더는 메시지가 유래 된 날짜와 시간이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eebea2d9e6a6d288555a242f73a9f9b00abe276" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Device-Memory&lt;/code&gt; header is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Device_Memory_API&quot;&gt;Device Memory API&lt;/a&gt; header that works like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client Hints&lt;/a&gt; header which represents the approximate amount of RAM client device has.</source>
          <target state="translated">&lt;code&gt;Device-Memory&lt;/code&gt; 헤더는이다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Device_Memory_API&quot;&gt;장치 메모리 API의&lt;/a&gt; 같은 작품 것을 헤더 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;클라이언트 힌트의&lt;/a&gt; RAM 클라이언트 장치의 대략적인 양을 나타내는 헤더가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fca5c6f26004ba8e513493500c35759b7d8670d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt; attributes define the &lt;em&gt;scope&lt;/em&gt; of the cookie: what URLs the cookies should be sent to.</source>
          <target state="translated">&lt;code&gt;Domain&lt;/code&gt; 및 &lt;code&gt;Path&lt;/code&gt; 속성은 정의 &lt;em&gt;범위&lt;/em&gt; 쿠키가로 전송해야하는지의 URL : 쿠키의를.</target>
        </trans-unit>
        <trans-unit id="a3b1269bf21dd422aa77c2c9c23ee0803a5f37a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; and &lt;code&gt;Path&lt;/code&gt; directives define the &lt;em&gt;scope&lt;/em&gt; of the cookie: what URLs the cookies should be sent to.</source>
          <target state="translated">&lt;code&gt;Domain&lt;/code&gt; 과 &lt;code&gt;Path&lt;/code&gt; 지침은 정의 &lt;em&gt;범위&lt;/em&gt; 쿠키가로 전송해야하는지의 URL : 쿠키의를.</target>
        </trans-unit>
        <trans-unit id="bae089f0efeafa75b1ab5dc8946d17d6e70ec21e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Domain&lt;/code&gt; attribute specifies which hosts are allowed to receive the cookie. If unspecified, it defaults to the same &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt; that set the cookie, &lt;em&gt;excluding subdomains&lt;/em&gt;. If &lt;code&gt;Domain&lt;/code&gt;&lt;em&gt;is&lt;/em&gt; specified, then subdomains are always included. Therefore, specifying &lt;code&gt;Domain&lt;/code&gt; is less restrictive than omitting it. However, it can be helpful when subdomains need to share information about a user.</source>
          <target state="translated">&lt;code&gt;Domain&lt;/code&gt; 호스트가 쿠키를받을 수 있습니다 속성 지정합니다. 지정하지 않으면 &lt;em&gt;하위 도메인을 제외&lt;/em&gt; 하고 쿠키를 설정 한 동일한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;출처로&lt;/a&gt; 기본 설정 됩니다. 경우 &lt;code&gt;Domain&lt;/code&gt; &lt;em&gt;되어&lt;/em&gt; 지정된 후, 하위 도메인은 항상 포함되어 있습니다. 따라서 &lt;code&gt;Domain&lt;/code&gt; 지정 은 생략하는 것보다 덜 제한적입니다. 그러나 하위 도메인이 사용자에 대한 정보를 공유해야하는 경우 유용 할 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c9c5ea9e0e528b35e54f97738194b2df17917c31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ETag&lt;/code&gt; HTTP response header is an identifier for a specific version of a resource. It allows caches to be more efficient, and saves bandwidth, as a web server does not need to send a full response if the content has not changed. On the other side, if the content has changed, etags are useful to help prevent simultaneous updates of a resource from overwriting each other (&quot;mid-air collisions&quot;).</source>
          <target state="translated">&lt;code&gt;ETag&lt;/code&gt; HTTP 응답의 헤더는 자원의 특정 버전에 대한 식별자이다. 컨텐츠가 변경되지 않은 경우 웹 서버가 전체 응답을 보낼 필요가 없으므로 캐시의 효율성이 향상되고 대역폭이 절약됩니다. 한편, 컨텐츠가 변경된 경우, etags는 자원의 동시 업데이트가 서로 겹쳐 쓰이지 않도록하는 데 유용합니다 ( &quot;공중 충돌&quot;).</target>
        </trans-unit>
        <trans-unit id="08646657870bfe9fc25378ffe7f57b55887a674a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ETag&lt;/code&gt; HTTP response header is an identifier for a specific version of a resource. It lets caches be more efficient and save bandwidth, as a web server does not need to resend a full response if the content has not changed. Additionally, etags help prevent simultaneous updates of a resource from overwriting each other (&lt;a href=&quot;#Caching_of_unchanged_resources&quot;&gt;&quot;mid-air collisions&quot;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;ETag&lt;/code&gt; HTTP 응답의 헤더는 자원의 특정 버전에 대한 식별자이다. 콘텐츠가 변경되지 않은 경우 웹 서버가 전체 응답을 다시 보낼 필요가 없기 때문에 캐시가 더 효율적이고 대역폭을 절약 할 수 있습니다. 또한 etag는 리소스의 동시 업데이트가 서로 덮어 쓰는 것을 방지하는 데 도움이됩니다 ( &lt;a href=&quot;#Caching_of_unchanged_resources&quot;&gt;&quot;공중 충돌&quot;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3b330412716d107192b6533fb30bf1581cd40ed2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Early-Data&lt;/code&gt; header is &lt;strong&gt;not&lt;/strong&gt; set by the originator of the request (i.e., a browser).</source>
          <target state="translated">&lt;code&gt;Early-Data&lt;/code&gt; 헤더입니다 &lt;strong&gt;하지&lt;/strong&gt; (즉, 브라우저) 요청의 송신자에 의해 설정합니다.</target>
        </trans-unit>
        <trans-unit id="26733480324535c0741d6a6528e1941641f5ce19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements, which prevents the use of misissued certificates for that site from going unnoticed.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; 헤더는 주목 갈에서 해당 사이트에 대한 misissued 인증서의 사용을 방지 인증서 투명성 요구 사항 및 / 또는 집행을보고하도록 선택에 사이트를 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d45aa61794fa19b9937294984a26564b7a2b70b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements, which prevents the use of misissued certificates for that site from going unnoticed. When a site enables the &lt;code&gt;Expect-CT&lt;/code&gt; header, they are requesting that the browser check that any certificate for that site appears in public CT logs.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; 헤더는 주목 갈에서 해당 사이트에 대한 misissued 인증서의 사용을 방지 인증서 투명성 요구 사항 및 / 또는 집행을보고하도록 선택에 사이트를 할 수 있습니다. 사이트에서 &lt;code&gt;Expect-CT&lt;/code&gt; 헤더를 사용하도록 설정하면 브라우저는 해당 사이트에 대한 인증서가 공용 CT 로그에 나타나는지 브라우저가 확인하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="5a38756d00a5a11b921674c4de083e3755d47807" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; header lets sites opt in to reporting and/or enforcement of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;Certificate Transparency&lt;/a&gt; requirements, to prevent the use of misissued certificates for that site from going unnoticed.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; 헤더는 사이트보고 및 / 또는 집행에 선택할 수 있습니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;인증서 투명&lt;/a&gt; 주목가는 해당 사이트에 대한 misissued 인증서의 사용을 방지하기 위해, 요구 사항.</target>
        </trans-unit>
        <trans-unit id="3c5d41eb6b835eb5ad3b6e94b607f55e721d9fdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect-CT&lt;/code&gt; will likely become obsolete in June 2021. Since May 2018 new certificates are expected to support SCTs by default. Certificates before March 2018 were allowed to have a lifetime of 39 months, those will all be expired in June 2021.</source>
          <target state="translated">&lt;code&gt;Expect-CT&lt;/code&gt; 가능성이 새 인증서는 기본적으로 SCTs을 지원할 것으로 예상된다 2018년 5월 가입일 June 2021에 무용지물이 될 것입니다. 2018 년 3 월 이전의 인증서는 39 개월의 수명이 허용되었으며 모두 2021 년 6 월에 만료됩니다.</target>
        </trans-unit>
        <trans-unit id="39f567c805d3b14ec3ccf5444b3918351ca629ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Expect&lt;/code&gt; HTTP request header indicates expectations that need to be fulfilled by the server in order to properly handle the request.</source>
          <target state="translated">&lt;code&gt;Expect&lt;/code&gt; HTTP 요청 헤더는 필요가 제대로 요청을 처리하기 위해 서버에 의해 성취 될 수 있다는 기대를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ea971246a330c3fd5b0ad3d128ebdbac36f3fb88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Feature-Policy&lt;/code&gt; header has now been renamed to &lt;code&gt;Permissions-Policy&lt;/code&gt; in the spec, and this article will eventually be updated to reflect that change.</source>
          <target state="translated">이제 사양에서 &lt;code&gt;Feature-Policy&lt;/code&gt; 헤더의 이름이 &lt;code&gt;Permissions-Policy&lt;/code&gt; 로 변경 되었으며이 문서는 결국 해당 변경 사항을 반영하도록 업데이트 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="9092e5df3d3c5b1e6e4085ebcd0973332a4819a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Forwarded&lt;/code&gt; header contains information from the &lt;a href=&quot;../proxy_servers_and_tunneling&quot;&gt;reverse proxy servers&lt;/a&gt; that is altered or lost when a proxy is involved in the path of the request.</source>
          <target state="translated">&lt;code&gt;Forwarded&lt;/code&gt; 헤더는 정보가 들어 &lt;a href=&quot;../proxy_servers_and_tunneling&quot;&gt;역방향 프록시 서버&lt;/a&gt; 프록시가 요청의 경로에 관여하는 경우 변경 또는 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="c43b4a38f617b0e601765fc7fa48f903467c8a77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Forwarded&lt;/code&gt; header contains information from the client-facing side of proxy servers that is altered or lost when a proxy is involved in the path of the request.</source>
          <target state="translated">&lt;code&gt;Forwarded&lt;/code&gt; 헤더는 프록시가 요청의 경로에 관여하는 경우 변경 또는 손실 프록시 서버의 클라이언트 측면에서 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7acf99131e3b502a504dfc606eb81c2fa8a3438" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; method requests a representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">&lt;code&gt;GET&lt;/code&gt; 의 방법은 지정된 리소스의 표현을 요구한다. &lt;code&gt;GET&lt;/code&gt; 을 사용한 요청 은 데이터 만 검색해야합니다.</target>
        </trans-unit>
        <trans-unit id="f4a622f1f455f51e4324f29b7983e11b4aa63399" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; requests a representation of the specified resource. Requests using &lt;code&gt;GET&lt;/code&gt; should only retrieve data.</source>
          <target state="translated">&lt;code&gt;GET&lt;/code&gt; 은 지정된 자원의 표현을 요구한다. &lt;code&gt;GET&lt;/code&gt; 을 사용한 요청 은 데이터 만 검색해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe2a61ce5f6f874b6cccf46f639263ba9a7751c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; method asks for a response identical to that of a &lt;code&gt;GET&lt;/code&gt; request, but without the response body.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 의 방법은 그와 동일한 응답을 요청 &lt;code&gt;GET&lt;/code&gt; 을 요청하지만, 응답 본체없이.</target>
        </trans-unit>
        <trans-unit id="8ab0b6ae10182c291f380700fbca30952dcca777" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; requests the &lt;a href=&quot;../headers&quot;&gt;headers&lt;/a&gt; that would be returned if the &lt;code&gt;HEAD&lt;/code&gt; request's URL was instead requested with the HTTP &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method. For example, if a URL might produce a large download, a &lt;code&gt;HEAD&lt;/code&gt; request could read its &lt;a href=&quot;../headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header to check the filesize without actually downloading the file.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 는 요청 &lt;a href=&quot;../headers&quot;&gt;헤더&lt;/a&gt; 경우 반환되는 &lt;code&gt;HEAD&lt;/code&gt; 의 요청의 URL 대신에 HTTP로 요청 된 &lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 방법을. 예를 들어 URL이 대용량 다운로드를 생성 할 수있는 경우 &lt;code&gt;HEAD&lt;/code&gt; 요청은 실제로 파일을 다운로드하지 않고 파일 크기를 확인하기 위해 &lt;a href=&quot;../headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt; 헤더를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcdb3000e143a76a0cbe83303746d3c1a0deba82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HEAD&lt;/code&gt; requests the headers that are returned if the specified resource would be requested with an HTTP &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method. Such a request can be done before deciding to download a large resource to save bandwidth, for example.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 는 지정된 리소스가 HTTP로 요청 될 경우 반환되는 헤더 요청 &lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 방법을. 예를 들어, 대역폭을 절약하기 위해 큰 리소스를 다운로드하기로 결정하기 전에 이러한 요청을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25050b6d25bf48e5e860b9e13a504c685ed5f20b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;HttpOnly&lt;/code&gt; cookie attribute can help to mitigate this attack by preventing access to cookie value through JavaScript.</source>
          <target state="translated">&lt;code&gt;HttpOnly&lt;/code&gt; 쿠키 속성은 자바 스크립트를 통해 쿠키 값에 대한 액세스를 방지하여 공격을 완화하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4db136fae95161e355b0319d6e24b7eb8dde4690" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Match&lt;/code&gt; HTTP request header makes the request conditional. For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, the server will send back the requested resource only if it matches one of the listed &lt;code&gt;ETags&lt;/code&gt;. For &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; and other non-safe methods, it will only upload the resource in this case.</source>
          <target state="translated">&lt;code&gt;If-Match&lt;/code&gt; HTTP 요청 헤더는 요청 조건을합니다. 들어 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 가 나열된 중 하나와 일치하는 경우에만 방법, 서버는 요청 된 리소스를 다시 보내드립니다 &lt;code&gt;ETags&lt;/code&gt; . 들어 &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 및 기타 비 안전 방법, 그것은 단지이 경우 리소스를 업로드합니다.</target>
        </trans-unit>
        <trans-unit id="89b34bc5ae9734af9081d0e5ea57512f4460ba59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Modified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status, only if it has been last modified after the given date. If the request has not been modified since, the response will be a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt; without any body; the &lt;a href=&quot;last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; response header of a previous request will contain the date of last modification. Unlike &lt;a href=&quot;if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-Modified-Since&lt;/code&gt; can only be used with a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;If-Modified-Since&lt;/code&gt; 요청 HTTP 헤더 요구 조건을 만드는 : 서버가 함께 요청 된 리소스를 다시 보내드립니다 &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; 가 마지막으로 주어진 날짜 이후 수정 된 경우에만 상태입니다. 이후 요청이 수정되지 않은 경우 응답은 본문이없는 &lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; 입니다&lt;/a&gt; . 이전 요청 의 &lt;a href=&quot;last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; 응답 헤더에는 마지막 수정 날짜가 포함됩니다. 달리 &lt;a href=&quot;if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;If-Modified-Since&lt;/code&gt; 만 사용할 수 있습니다 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5986b8f11ba0994d8a72e97fe21f90cc137ceae5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-None-Match&lt;/code&gt; HTTP request header makes the request conditional. For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, the server will send back the requested resource, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status, only if it doesn't have an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; matching the given ones. For other methods, the request will be processed only if the eventually existing resource's &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; doesn't match any of the values listed.</source>
          <target state="translated">&lt;code&gt;If-None-Match&lt;/code&gt; HTTP 요청 헤더는 요청 조건을합니다. 들어 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 방법, 서버는 함께 요청 된 리소스를 다시 보내드립니다 &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; 그것이이없는 경우에만 상태 &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 주어진 것과 일치합니다. 다른 방법의 경우 최종 기존 리소스의 &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 가 나열된 값과 일치하지 않는 경우에만 요청이 처리 됩니다.</target>
        </trans-unit>
        <trans-unit id="2724d0a408c5f3bcd5c0014c571f5f10868e51ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Range&lt;/code&gt; HTTP request header makes a range request conditional: if the condition is fulfilled, the range request will be issued and the server sends back a &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; answer with the appropriate body. If the condition is not fulfilled, the full resource is sent back, with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status.</source>
          <target state="translated">&lt;code&gt;If-Range&lt;/code&gt; HTTP 요청 헤더는 다양한 요구 조건합니다 : 조건이 충족되는 경우, 범위 요청이 발행되고 서버가 다시 전송 &lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 해당하는 몸 대답을. 조건이 충족되지 않으면 전체 자원이 &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 상태 로 반송 됩니다.</target>
        </trans-unit>
        <trans-unit id="22163b61a8a59a375d09bff2ee1f49eb81aa2552" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Unmodified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or another non-&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, only if it has not been last modified after the given date. If the request has been modified after the given date, the response will be a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) error.</source>
          <target state="translated">&lt;code&gt;If-Unmodified-Since&lt;/code&gt; 요청 HTTP 헤더 조건부 요청한다 : 서버가 요청 된 리소스를 다시 보내거나 경우에 그것을 받아 들일 것 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 또는 다른 비 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;안전&lt;/a&gt; 이 마지막으로 주어진 이후에 수정되지 않은 경우에만, 방법을 데이트. 지정된 날짜 이후에 요청이 수정 된 경우 응답은 &lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; (사전 조건 실패) 오류입니다.</target>
        </trans-unit>
        <trans-unit id="33d2652dcdd336882d1ff7dcd4aab424143119d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;If-Unmodified-Since&lt;/code&gt; request HTTP header makes the request conditional: the server will send back the requested resource, or accept it in the case of a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or another non-&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; method, only if it has not been last modified after the given date. If the resource has been modified after the given date, the response will be a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) error.</source>
          <target state="translated">&lt;code&gt;If-Unmodified-Since&lt;/code&gt; 요청 HTTP 헤더 조건부 요청한다 : 서버가 요청 된 리소스를 다시 보내거나 경우에 그것을 받아 들일 것 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 또는 다른 비 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;안전&lt;/a&gt; 이 마지막으로 주어진 이후에 수정되지 않은 경우에만, 방법을 데이트. 지정된 날짜 이후에 리소스가 수정 된 경우 응답은 &lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; (사전 조건 실패) 오류입니다.</target>
        </trans-unit>
        <trans-unit id="c6e9dbc2bd4ee3beeb7dae2fbab0d0ed4f0f0c7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Large-Allocation&lt;/code&gt; header throws warnings or error messages when used incorrectly. You'll encounter them in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;web console&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Large-Allocation&lt;/code&gt; 을 잘못 사용하는 경우 헤더는 경고 또는 오류 메시지가 발생합니다. 당신은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;웹 콘솔&lt;/a&gt; 에서 그것들을 보게 될 것입니다 .</target>
        </trans-unit>
        <trans-unit id="1f7bbba0c2fe1da5cfd40ee4dbb5a457286f63d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Last-Modified&lt;/code&gt; response HTTP header contains the date and time at which the origin server believes the resource was last modified. It is used as a validator to determine if a resource received or stored is the same. Less accurate than an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; header, it is a fallback mechanism. Conditional requests containing &lt;a href=&quot;if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; headers make use of this field.</source>
          <target state="translated">&lt;code&gt;Last-Modified&lt;/code&gt; 응답 HTTP 헤더가 원 서버가 자원이 마지막으로 변경되었다고 믿는 날짜와 시간이 포함되어 있습니다. 수신 또는 저장된 자원이 동일한 지 판별하기 위해 유효성 검증기로 사용됩니다. &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 헤더 보다 정확도가 떨어지면 대체 메커니즘입니다. &lt;a href=&quot;if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt; 헤더를 포함하는 조건부 요청 은이 필드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="408faa70ae199f0916e25f0545a45cf1159c3a15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Location&lt;/code&gt; response header indicates the URL to redirect a page to. It only provides a meaning when served with a &lt;code&gt;3xx&lt;/code&gt; (redirection) or &lt;code&gt;201&lt;/code&gt; (created) status response.</source>
          <target state="translated">&lt;code&gt;Location&lt;/code&gt; 응답 헤더에 페이지를 리디렉션 할 URL을 나타냅니다. &lt;code&gt;3xx&lt;/code&gt; (리디렉션) 또는 &lt;code&gt;201&lt;/code&gt; (만든) 상태 응답 과 함께 제공 될 때만 의미를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="7d4bbe1245321cac039158aa76ac84b747faeeee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; is used to describe the communication options for the target resource. The client can specify a URL for the OPTIONS method, or an asterisk (*) to refer to the entire server.</source>
          <target state="translated">&lt;code&gt;OPTIONS&lt;/code&gt; 는 대상 자원의 통신 옵션을 설명하는 데 사용된다. 클라이언트는 OPTIONS 메소드의 URL 또는 별표 (*)를 지정하여 전체 서버를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87018d773f4ad1701e531629a9f995260745c1b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; method is used to describe the communication options for the target resource.</source>
          <target state="translated">&lt;code&gt;OPTIONS&lt;/code&gt; 의 방법은 대상 리소스의 통신 옵션을 설명하는 데 사용된다.</target>
        </trans-unit>
        <trans-unit id="a6e38b6b645f385912507ae1ea58453222ae125b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OPTIONS&lt;/code&gt; requests permitted communication options for a given URL or server. A client can specify a URL with this method, or an asterisk (&lt;code&gt;*&lt;/code&gt;) to refer to the entire server.</source>
          <target state="translated">&lt;code&gt;OPTIONS&lt;/code&gt; 요청은 해당 URL 또는 서버에 대한 통신 옵션을 허용. 클라이언트는이 방법으로 URL을 지정하거나 전체 서버를 나타내는 별표 ( &lt;code&gt;*&lt;/code&gt; )를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a07a0f8f183e5dac76997068b2e3c2b7238732b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Origin&lt;/code&gt; request header indicates where a fetch originates from. It doesn't include any path information, but only the server name. It is sent with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; requests, as well as with &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; requests. It is similar to the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header, but, unlike this header, it doesn't disclose the whole path.</source>
          <target state="translated">&lt;code&gt;Origin&lt;/code&gt; A가에서 유래를 가져 오는 경우 요청 헤더를 나타냅니다. 경로 정보는 포함하지 않고 서버 이름 만 포함합니다. &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 요청 과 함께 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; 요청 과 함께 전송됩니다 . &lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; 헤더 와 비슷 하지만이 헤더와 달리 전체 경로를 공개하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="fbfda01971457a54151941075f2b100b82e48523" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PATCH&lt;/code&gt; applies partial modifications to a resource.</source>
          <target state="translated">&lt;code&gt;PATCH&lt;/code&gt; 리소스에 일부 변경을 적용한다.</target>
        </trans-unit>
        <trans-unit id="f9159e5596093f157b377894f822a924c1cb222b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PATCH&lt;/code&gt; method is used to apply partial modifications to a resource.</source>
          <target state="translated">&lt;code&gt;PATCH&lt;/code&gt; 방법은 리소스에 일부 변경을 적용하는데 사용된다.</target>
        </trans-unit>
        <trans-unit id="1f5331c568d957daee441f1fc46cb653dfa3c711" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POST&lt;/code&gt; method is used to submit an entity to the specified resource, often causing a change in state or side effects on the server.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; 의 방법들은 서버 상태 또는 부작용의 변화를 일으키는 상기 특정 자원 엔티티를 제출하는데 사용된다.</target>
        </trans-unit>
        <trans-unit id="3be3fad872235976dca00e40191bbd8a2412e11e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POST&lt;/code&gt; sends data to the server. The type of the body of the request is indicated by the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; 는 서버에 데이터를 전송합니다. 요청 본문의 &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 은 Content-Type 헤더로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa5fa4af532ebd69d21f151a379cfa743406c0e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUT&lt;/code&gt; creates a new resource or replaces a representation of the target resource with the request payload.</source>
          <target state="translated">&lt;code&gt;PUT&lt;/code&gt; 는 새로운 자원을 생성 또는 요청 페이로드 대상 자원의 표시를 대체한다.</target>
        </trans-unit>
        <trans-unit id="c05eb025eb7c8b4be7ac86b298f646c06fa3ba3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUT&lt;/code&gt; method replaces all current representations of the target resource with the request payload.</source>
          <target state="translated">&lt;code&gt;PUT&lt;/code&gt; 의 방법은 요청 페이로드 대상 자원의 현재 표현을 대체한다.</target>
        </trans-unit>
        <trans-unit id="6881c728a58c81e16c491c3900a0cb662b6f7797" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Path&lt;/code&gt; attribute indicates a URL path that must exist in the requested URL in order to send the &lt;code&gt;Cookie&lt;/code&gt; header. The &lt;code&gt;%x2F&lt;/code&gt; (&quot;/&quot;) character is considered a directory separator, and subdirectories match as well.</source>
          <target state="translated">&lt;code&gt;Path&lt;/code&gt; 속성은 보내기 위해 요청 된 URL에 존재해야 URL 경로를 나타내는 &lt;code&gt;Cookie&lt;/code&gt; 헤더를. &lt;code&gt;%x2F&lt;/code&gt; ( &quot;/&quot;) 문자는 디렉토리 분리 간주 하위 디렉토리도 일치한다.</target>
        </trans-unit>
        <trans-unit id="0c89f21cbe09b59b1b9abe85e9acdd8ee45935d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Pragma&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;Pragma&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="d99324cd748dcc4ddf7bf1ab613ab29af0de9abc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Proxy-Authenticate&lt;/code&gt; header is sent along with a &lt;a href=&quot;../status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Proxy-Authenticate&lt;/code&gt; 헤더가 함께 전송됩니다 &lt;a href=&quot;../status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38b88eeb5a1167fff3d87ac75a5f9789ffbc4ed1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt; HTTP request header indicates the part of a document that the server should return. Several parts can be requested with one &lt;code&gt;Range&lt;/code&gt; header at once, and the server may send back these ranges in a multipart document. If the server sends back ranges, it uses the &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Partial Content&lt;/code&gt; for the response. If the ranges are invalid, the server returns the &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Range Not Satisfiable&lt;/code&gt; error. The server can also ignore the &lt;code&gt;Range&lt;/code&gt; header and return the whole document with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status code.</source>
          <target state="translated">&lt;code&gt;Range&lt;/code&gt; HTTP 요청 헤더는 서버가 반환해야하는 문서의 일부를 나타냅니다. 한 번에 하나의 &lt;code&gt;Range&lt;/code&gt; 헤더로 여러 부분을 요청할 수 있으며 서버는 이러한 범위를 다중 부분 문서로 다시 보낼 수 있습니다. 서버가 범위를 되 돌리면 응답에 &lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Partial Content&lt;/code&gt; 를 사용합니다 . 범위가 유효하지 않으면 서버는 &lt;a href=&quot;../status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Range Not Satisfiable&lt;/code&gt; 오류를 반환합니다 . 서버는 &lt;code&gt;Range&lt;/code&gt; 헤더를 무시하고 &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; 상태 코드로 전체 문서를 반환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="31b15d048b735cd58d12cb36f1c04b433a92d0de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Range&lt;/code&gt; HTTP request header indicates the part of a document that the server should return. Several parts can be requested with one &lt;code&gt;Range&lt;/code&gt; header at once, and the server may send back these ranges in a multipart document. If the server sends back ranges, it uses the &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; for the response. If the ranges are invalid, the server returns the &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Range Not Satisfiable&lt;/code&gt; error. The server can also ignore the &lt;code&gt;Range&lt;/code&gt; header and return the whole document with a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; status code.</source>
          <target state="translated">&lt;code&gt;Range&lt;/code&gt; HTTP 요청 헤더는 서버가 반환해야하는 문서의 일부를 나타냅니다. 한 번에 하나의 &lt;code&gt;Range&lt;/code&gt; 헤더로 여러 부분을 요청할 수 있으며 서버는 이러한 범위를 여러 부분으로 된 문서로 다시 보낼 수 있습니다. 서버가 범위를 다시 보내면 &lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 를 사용하여 응답합니다. 범위가 유효하지 않으면 서버는 &lt;a href=&quot;../status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Range Not Satisfiable&lt;/code&gt; 오류를 리턴합니다 . 서버는 &lt;code&gt;Range&lt;/code&gt; 헤더를 무시하고 &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; 개의&lt;/a&gt; 상태 코드로 전체 문서를 반환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d730336d5f314e4ffb348e65cc342c819634ceb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP header governs which referrer information, sent in the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header, should be included with requests made.</source>
          <target state="translated">&lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP 헤더 다스리이되는 리퍼러에 전송되는 정보, &lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; 헤더 된 요청에 포함되어야한다.</target>
        </trans-unit>
        <trans-unit id="76239ca8ee1c72f207bd371031df7511a9737ea4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Referrer-Policy&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP_header&quot;&gt;HTTP header&lt;/a&gt; controls how much &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Referer_header:_privacy_and_security_concerns&quot;&gt;referrer information&lt;/a&gt; (sent via the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header) should be included with requests.</source>
          <target state="translated">&lt;code&gt;Referrer-Policy&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTP_header&quot;&gt;HTTP 헤더&lt;/a&gt; 컨트롤은 얼마나 많은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Referer_header:_privacy_and_security_concerns&quot;&gt;참조 자 정보를&lt;/a&gt; 합니다 (통해 전송 &lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; 헤더) 요청에 포함되어야한다.</target>
        </trans-unit>
        <trans-unit id="471a084b48fd4c8723f09a90baa8df53c1cd93e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Retry-After&lt;/code&gt; response HTTP header indicates how long the user agent should wait before making a follow-up request. There are three main cases this header is used:</source>
          <target state="translated">&lt;code&gt;Retry-After&lt;/code&gt; 응답 HTTP 헤더는 사용자 에이전트가 후속 요청을하기 전에 기다리는 시간을 나타냅니다. 이 헤더가 사용되는 세 가지 주요 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd701418d7c6bf62926c6ad09e3776653cf803d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SameSite&lt;/code&gt; attribute accepts three values:</source>
          <target state="translated">&lt;code&gt;SameSite&lt;/code&gt; 속성은 세 가지 값을 사용할 수</target>
        </trans-unit>
        <trans-unit id="12bf22b5dbc2a8c45c1d6d8c1615396a45809438" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SameSite&lt;/code&gt; attribute lets servers require that a cookie shouldn't be sent with cross-origin requests (where &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Site&quot;&gt;Site&lt;/a&gt; is defined by the registrable domain), which provides some protection against cross-site request forgery attacks (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSRF&quot;&gt;CSRF&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;SameSite&lt;/code&gt; 의 속성은 서버가 쿠키 (출처 간 요청과 함께 전송하지 말아야 할 것을 요구하고 있습니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Site&quot;&gt;사이트가&lt;/a&gt; 크로스 사이트 요청 위조 공격에 대한 몇 가지 보호 (제공 등록 가능한 도메인에 의해 정의된다), &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSRF&quot;&gt;CSRF를&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c183288b7bfb9b7d64e4bb9f606b605293a750ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SameSite&lt;/code&gt; attribute of the &lt;a href=&quot;../set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; HTTP response header allows you to declare if your cookie should be restricted to a first-party or same-site context.</source>
          <target state="translated">&lt;a href=&quot;../set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; HTTP 응답 헤더 의 &lt;code&gt;SameSite&lt;/code&gt; 속성을 사용하면 쿠키를 자사 또는 동일 사이트 컨텍스트로 제한해야하는지 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff9a7daddb986f8f3e9947219b02e125a02e07a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Save-Data&lt;/code&gt; header field is a boolean which, in requests, indicates the client's preference for reduced data usage. This could be for reasons such as high transfer costs, slow connection speeds, etc.</source>
          <target state="translated">&lt;code&gt;Save-Data&lt;/code&gt; 헤더 필드는 요청에, 감소 된 데이터 사용에 대한 고객의 선호도를 나타내는 부울입니다. 이는 높은 전송 비용, 느린 연결 속도 등과 같은 이유 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5c50e0dbd49e9be339d0014ff98de27f5af6b7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-Fetch-Dest&lt;/code&gt; fetch metadata header indicates the request's destination, that is how the fetched data will be used.</source>
          <target state="translated">&lt;code&gt;Sec-Fetch-Dest&lt;/code&gt; 메타 데이터 헤더는 데이터 페치 사용 방식이다 요청의 도착을 나타내는 페치.</target>
        </trans-unit>
        <trans-unit id="31f9900ebfdde4aa1830afd97db024c6b3f830be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-Fetch-Mode&lt;/code&gt; fetch metadata header indicates the request's mode.</source>
          <target state="translated">&lt;code&gt;Sec-Fetch-Mode&lt;/code&gt; 메타 데이터 헤더가 요청의 모드를 나타냅니다 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="25babdcd9266b9b2ebf26be60ebc0d7bfea878a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-Fetch-Site&lt;/code&gt; fetch metadata header indicates the relationship between a request initiator's origin and the origin of the resource.</source>
          <target state="translated">&lt;code&gt;Sec-Fetch-Site&lt;/code&gt; 메타 데이터 헤더 요청 개시제의 기원과 자원의 원점 사이의 관계를 나타내는 페치.</target>
        </trans-unit>
        <trans-unit id="ea3db281f732bb94a4a366b08b7f44ee831dbefd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-Fetch-User&lt;/code&gt; fetch metadata header indicates whether or not a navigation request was triggered by a user activation.</source>
          <target state="translated">&lt;code&gt;Sec-Fetch-User&lt;/code&gt; 메타 데이터 헤더 네비게이션 요청이 사용자의 활성화에 의해 트리거되었는지 여부를 나타냅니다 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6374aa4b75562bedbe4aa399825eadf45d2253c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; header specifies one or more WebSocket protocols that you wish to use, in order of preference. The first one that is supported by the server will be selected and returned by the server in a &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; header included in the response. You can use this more than once in the header, as well; the result is the same as if you used a comma-delineated list of subprotocol identifiers in a single header.</source>
          <target state="translated">&lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; 헤더 지정하는 하나 이상의 웹 소켓 프로토콜은 우선 순위에 따라, 사용하고자하는 것이다. 서버에서 지원하는 첫 번째 서버가 응답에 포함 된 &lt;code&gt;Sec-WebSocket-Protocol&lt;/code&gt; 헤더 에서 서버에 의해 선택되어 반환됩니다 . 헤더에서도 이것을 두 번 이상 사용할 수 있습니다. 결과는 단일 헤더에 쉼표로 구분 된 서브 프로토콜 식별자 목록을 사용한 것과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="bcaa9b003cfb51a580c36805f7e5708f883883c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Server-Timing&lt;/code&gt; header communicates one or more metrics and descriptions for a given request-response cycle. It is used to surface any backend server timing metrics (e.g. database read/write, CPU time, file system access, etc.) in the developer tools in the user's browser or in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt;&lt;code&gt;PerformanceServerTiming&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">&lt;code&gt;Server-Timing&lt;/code&gt; 헤더는 주어진 요청 - 응답주기에 대해 하나 개 이상의 메트릭과 설명을 전달합니다. 사용자 브라우저 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PerformanceServerTiming&quot;&gt; &lt;code&gt;PerformanceServerTiming&lt;/code&gt; &lt;/a&gt; 인터페이스 의 개발자 도구에 백엔드 서버 타이밍 메트릭 (예 : 데이터베이스 읽기 / 쓰기, CPU 시간, 파일 시스템 액세스 등)을 표시하는 데 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="58ba7a6637e80a2b7ed529a9998dc728401d3c92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Server-Timing&lt;/code&gt; header may expose potentially sensitive application and infrastructure information. Consider to control which metrics are returned when and to whom on the server side. For example, you could only show metrics to authenticated users and nothing to the public.</source>
          <target state="translated">&lt;code&gt;Server-Timing&lt;/code&gt; 헤더는 잠재적으로 민감한 애플리케이션 및 인프라 정보가 노출 될 수 있습니다. 서버 측에서 언제, 누구에게 어떤 메트릭이 리턴되는지 제어하십시오. 예를 들어 인증 된 사용자에게만 메트릭을 표시하고 일반 사용자에게는 아무 것도 표시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="55f111f3d740121c0376e9d447632d82acbbd389" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP response header is used to send a cookie from the server to the user agent, so the user agent can send it back to the server later. To send multiple cookies, multiple &lt;code&gt;Set-Cookie&lt;/code&gt; headers should be sent in the same response.</source>
          <target state="translated">&lt;code&gt;Set-Cookie&lt;/code&gt; HTTP 응답 헤더는 사용자 에이전트가 나중에 다시 서버로 보낼 수 있도록 사용자 에이전트 서버에서 쿠키를 전송하는 데 사용됩니다. 여러 쿠키를 보내려면 동일한 응답으로 여러 &lt;code&gt;Set-Cookie&lt;/code&gt; 헤더를 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="1e616d6c13d2c598274b6aa0d7cf7d1cc7921936" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP response header is used to send cookies from the server to the user agent.</source>
          <target state="translated">&lt;code&gt;Set-Cookie&lt;/code&gt; HTTP 응답 헤더는 사용자 에이전트 서버에서 쿠키를 전송하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d633495cdc7990d58394c50c8d640450b06b2d19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Set-Cookie&lt;/code&gt; and &lt;code&gt;Cookie&lt;/code&gt; headers</source>
          <target state="translated">&lt;code&gt;Set-Cookie&lt;/code&gt; 와 &lt;code&gt;Cookie&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="4ee3227d824b48a69ef6dfb672317e9a7fe813f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SourceMap&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header links generated code to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;source map&lt;/a&gt;, enabling the browser to reconstruct the original source and present the reconstructed original in the debugger.</source>
          <target state="translated">&lt;code&gt;SourceMap&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; A와 코드를 생성 응답 헤더 링크 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Debugger/How_to/Use_a_source_map&quot;&gt;소스 맵&lt;/a&gt; 브라우저를 가능하게는, 원래의 소스를 재구성하고 디버거에서 복원 된 원본을 제시한다.</target>
        </trans-unit>
        <trans-unit id="cc48476ae000e635700cbc6cc0b3e1b52a2ba404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Strict-Transport-Security&lt;/code&gt; response header (often abbreviated as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;) lets a web site tell browsers that it should only be accessed using HTTPS, instead of using HTTP.</source>
          <target state="translated">&lt;code&gt;Strict-Transport-Security&lt;/code&gt; (종종 축약 응답 헤더 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS는&lt;/a&gt; ) 웹 사이트가 HTTPS를 사용하여, 대신에 HTTP를 사용하여 만 접근해야한다고 브라우저를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a54300d397ddd96a89ed7e4299d868f45d6d3b45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRACE&lt;/code&gt; method performs a message loop-back test along the path to the target resource.</source>
          <target state="translated">&lt;code&gt;TRACE&lt;/code&gt; 의 방법은 대상 자원의 경로를 따라 메시지 루프 - 백 테스트를 수행한다.</target>
        </trans-unit>
        <trans-unit id="f4e482563cca8b6b536cb03f419ca214a60b04b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRACE&lt;/code&gt; performs a message loop-back test along the path to the target resource, providing a useful debugging mechanism.</source>
          <target state="translated">&lt;code&gt;TRACE&lt;/code&gt; 는 유용한 디버그 메커니즘을 제공 대상 자원의 경로를 따라 메시지 루프 - 백 테스트를 수행한다.</target>
        </trans-unit>
        <trans-unit id="24a6cebd134cf5267f57018cea1581d2a79160d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tk&lt;/code&gt; response header indicates the tracking status that applied to the corresponding request.</source>
          <target state="translated">&lt;code&gt;Tk&lt;/code&gt; 응답 헤더는 해당 요청에 적용되는 추적 상태를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="661d8abe462ff964e30520abb6a9490ee2f57e77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Transfer-Encoding&lt;/code&gt; header specifies the form of encoding used to safely transfer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;entity&lt;/a&gt; to the user.</source>
          <target state="translated">&lt;code&gt;Transfer-Encoding&lt;/code&gt; 헤더를 안전하게 전송하기 위해 사용되는 인코딩 형식 지정 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;엔티티를&lt;/a&gt; 사용자에게있다.</target>
        </trans-unit>
        <trans-unit id="e80b8cf0899b9de1fbc8c3b7fc1f7628157f4015" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Transfer-Encoding&lt;/code&gt; header specifies the form of encoding used to safely transfer the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Payload_body&quot;&gt;payload body&lt;/a&gt; to the user.</source>
          <target state="translated">&lt;code&gt;Transfer-Encoding&lt;/code&gt; 헤더를 안전하게 전송하기 위해 사용되는 인코딩 형식 지정 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Payload_body&quot;&gt;페이로드 몸체를&lt;/a&gt; 사용자에게있다.</target>
        </trans-unit>
        <trans-unit id="4e4d1816f1bb2e8b52d94106ccb83a944a14eca8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Upgrade&lt;/code&gt; header field may be used by clients to invite a server to switch to one (or more) of the listed protocols, in descending preference order.</source>
          <target state="translated">&lt;code&gt;Upgrade&lt;/code&gt; 헤더 필드는 우선 순위를 내림차순으로 나열된 프로토콜 중 하나 (또는 그 이상)로 전환하려면 서버를 초대하는 클라이언트가 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48fd812100e724a16068b0d9d88fea979cbef78f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Upgrade&lt;/code&gt; header specifies one or more comma-separated protocol names, in order of preference.</source>
          <target state="translated">&lt;code&gt;Upgrade&lt;/code&gt; 우선 순위에 따라 헤더를 지정하는 하나 이상의 쉼표로 구분 프로토콜 이름.</target>
        </trans-unit>
        <trans-unit id="ba632e686f1f5e8841818ed95374f3d49208c686" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;User-Agent&lt;/code&gt; header</source>
          <target state="translated">&lt;code&gt;User-Agent&lt;/code&gt; 헤더</target>
        </trans-unit>
        <trans-unit id="d7a5f551ef4f873a95fa7564b99b777f320ff383" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; HTTP response header determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server. It is used by the server to indicate which headers it used when selecting a representation of a resource in a &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; algorithm.</source>
          <target state="translated">(가) &lt;code&gt;Vary&lt;/code&gt; HTTP를 응답 헤더는 캐시 된 응답이 원본 서버에서 새로운 하나를 요청하는 대신 사용할 수 있는지 여부를 결정하는 미래의 요청 헤더와 일치하는 방법을 결정합니다. &lt;a href=&quot;../content_negotiation&quot;&gt;컨텐츠 협상&lt;/a&gt; 알고리즘 에서 자원의 표시를 선택할 때 사용한 헤더를 표시하기 위해 서버에서 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="b41f5b9f20c1124889bea2cf3b58e60fc1e6c962" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header can also be useful for serving different content to desktop and mobile users, or to allow search engines to discover the mobile version of a page (and perhaps also tell them that no &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;Cloaking&lt;/a&gt; is intended). This is usually achieved with the &lt;code&gt;Vary: User-Agent&lt;/code&gt; header, and works because the &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; header value is different for mobile and desktop clients.</source>
          <target state="translated">은 &lt;code&gt;Vary&lt;/code&gt; 헤더는 데스크탑 및 모바일 사용자에게 다른 콘텐츠를 제공하는 데 유용 할 수 있습니다, 또는 검색 엔진이 페이지의 모바일 버전을 발견 (그리고 아마도 또한 더 그들에게 할 수 있도록 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;은폐를&lt;/a&gt; 목적으로하지 않습니다). 이는 일반적으로 &lt;code&gt;Vary: User-Agent&lt;/code&gt; 헤더를 사용하여 이루어지며 &lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt; 헤더 값이 모바일 및 데스크톱 클라이언트에 따라 다르기 때문에 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="194b4e9dbe38f2da963d88dc0f228c708df4f3f9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header should be set on a &lt;a href=&quot;../status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; response exactly like it would have been set on an equivalent &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; response.</source>
          <target state="translated">은 &lt;code&gt;Vary&lt;/code&gt; 헤더가 설정되어야한다 &lt;a href=&quot;../status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; 는 동등한에 설정했을 똑같이 응답 &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 응답.</target>
        </trans-unit>
        <trans-unit id="320c93529dc0245d276d67069f44ba338d5af1d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header was added in the version 1.1 of HTTP and is necessary in order to allow caches to work appropriately. A cache, in order to work with server-driven content negotiation, needs to know which criteria was used by the server to select the transmitted content. That way, the cache can replay the algorithm and will be able to serve acceptable content directly, without more request to the server. Obviously, the wildcard '&lt;code&gt;*&lt;/code&gt;' prevents caching from occurring, as the cache cannot know what element is behind it.</source>
          <target state="translated">은 &lt;code&gt;Vary&lt;/code&gt; 헤더는 HTTP 버전 1.1에 추가 캐시가 적절하게 작동 할 수 있도록하기 위해 필요했다. 서버 구동 컨텐츠 협상을 수행하기 위해 캐시는 서버가 전송 된 컨텐츠를 선택하기 위해 사용한 기준을 알아야합니다. 이러한 방식으로 캐시는 알고리즘을 재생할 수 있으며 서버에 대한 추가 요청없이 수용 가능한 컨텐츠를 직접 제공 할 수 있습니다. 분명히, 와일드 카드 ' &lt;code&gt;*&lt;/code&gt; '는 캐시가 뒤에있는 요소를 알 수 없으므로 캐싱이 발생하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="76641ba7095f2c68f90780c9306f63f6bf04e9de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; header was added in the version 1.1 of HTTP and is necessary in order to allow caches to work appropriately. A cache, in order to work with server-driven content negotiation, needs to know which criteria was used by the server to select the transmitted content. That way, the cache can replay the algorithm and will be able to serve acceptable content directly, without more request to the server. Obviously, the wildcard '&lt;code&gt;*&lt;/code&gt;' prevents caching from occurring, as the cache cannot know what element is behind it. For more information &lt;a href=&quot;caching#Varying_responses&quot;&gt;HTTP caching &amp;gt; Varying responses&lt;/a&gt;.</source>
          <target state="translated">은 &lt;code&gt;Vary&lt;/code&gt; 헤더는 HTTP 버전 1.1에 추가 캐시가 적절하게 작동 할 수 있도록하기 위해 필요했다. 서버 기반 콘텐츠 협상을 사용하려면 캐시가 전송 된 콘텐츠를 선택하기 위해 서버에서 사용 된 기준을 알아야합니다. 이렇게하면 캐시가 알고리즘을 재생할 수 있으며 서버에 대한 추가 요청없이 허용 가능한 콘텐츠를 직접 제공 할 수 있습니다. 분명히 와일드 카드 ' &lt;code&gt;*&lt;/code&gt; '는 캐시가 그 뒤에있는 요소를 알 수 없기 때문에 캐싱 발생을 방지합니다. 자세한 내용은 &lt;a href=&quot;caching#Varying_responses&quot;&gt;HTTP 캐싱&amp;gt; 다양한 응답을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b4bde9aa68e310507cb43566d5d20223a7c4d89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vary&lt;/code&gt; response header</source>
          <target state="translated">은 &lt;code&gt;Vary&lt;/code&gt; 응답 헤더를</target>
        </trans-unit>
        <trans-unit id="405a63b6723f58e2ec7f579da6d22e1185e2ba24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;WWW-Authenticate&lt;/code&gt; header is sent along with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; response.</source>
          <target state="translated">&lt;code&gt;WWW-Authenticate&lt;/code&gt; 헤더가 함께 전송된다 &lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; 응답.</target>
        </trans-unit>
        <trans-unit id="4c2052dca6314ec4744d6670a2fcfde4364c3176" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Warning&lt;/code&gt; general HTTP header contains information about possible problems with the status of the message. More than one &lt;code&gt;Warning&lt;/code&gt; header may appear in a response.</source>
          <target state="translated">&lt;code&gt;Warning&lt;/code&gt; 일반적인 HTTP 헤더는 메시지의 상태에 발생할 수있는 문제에 대한 정보가 포함되어 있습니다. 응답에 둘 이상의 &lt;code&gt;Warning&lt;/code&gt; 헤더가 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efe0fdb5e1f6f144e9e814a9d19ed38077ab4d3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Width&lt;/code&gt; request header field is a number that indicates the desired resource width in physical pixels (i.e. intrinsic size of an image). The provided pixel value is a number rounded to the smallest following integer (i.e. ceiling value).</source>
          <target state="translated">&lt;code&gt;Width&lt;/code&gt; 요청 헤더 필드는 실제 화소에서 원하는 리소스의 폭 (즉, 화상의 극한 사이즈)를 나타내는 숫자이다. 제공된 픽셀 값은 가장 작은 다음 정수 (즉, 상한 값)로 반올림 된 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="e9e5b0e1f18626b41321a488aa80a25f985f1deb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; HTTP response header controls DNS prefetching, a feature by which browsers proactively perform domain name resolution on both links that the user may choose to follow as well as URLs for items referenced by the document, including images, CSS, JavaScript, and so forth.</source>
          <target state="translated">&lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; DNS는 프리 페치 HTTP 응답 헤더 컨트롤, 브라우저가 사전에 사용자가 따를뿐만 아니라 이미지, CSS를 포함하는 문서에 의해 참조 항목의 URL을 선택할 수 있다는 것을 모두 링크에 도메인 이름 확인을 수행하는 기능 , JavaScript 등.</target>
        </trans-unit>
        <trans-unit id="ff3dc3f28097222bbf317e1c8c99177c20310367" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-For&lt;/code&gt; (XFF) header is a de-facto standard header for identifying the originating IP address of a client connecting to a web server through an HTTP proxy or a load balancer. When traffic is intercepted between clients and servers, server access logs contain the IP address of the proxy or load balancer only. To see the original IP address of the client, the &lt;code&gt;X-Forwarded-For&lt;/code&gt; request header is used.</source>
          <target state="translated">&lt;code&gt;X-Forwarded-For&lt;/code&gt; (XFF) 헤더는 HTTP 프록시 또는 부하 분산을 통해 웹 서버에 접속하는 고객의 발신 IP 주소를 식별하기위한 사실상의 표준 헤더이다. 클라이언트와 서버간에 트래픽이 차단되면 서버 액세스 로그에는 프록시 또는로드 밸런서의 IP 주소 만 포함됩니다. 클라이언트의 원래 IP 주소를 보려면 &lt;code&gt;X-Forwarded-For&lt;/code&gt; 요청 헤더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="482fcec20c0b4ec16aa7ff0f4a40cd4a8e96efd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-Host&lt;/code&gt; (XFH) header is a de-facto standard header for identifying the original host requested by the client in the &lt;a href=&quot;host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; HTTP request header.</source>
          <target state="translated">&lt;code&gt;X-Forwarded-Host&lt;/code&gt; (XFH) 헤더는 클라이언트에 의해 요청 된 원래 호스트 식별하기위한 사실상의 표준 헤더 인 &lt;a href=&quot;host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; HTTP 요청 헤더.</target>
        </trans-unit>
        <trans-unit id="ac80a173a5330f7e0e915503af16d57814a7f24e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; (XFP) header is a de-facto standard header for identifying the protocol (HTTP or HTTPS) that a client used to connect to your proxy or load balancer. Your server access logs contain the protocol used between the server and the load balancer, but not the protocol used between the client and the load balancer. To determine the protocol used between the client and the load balancer, the &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; request header can be used.</source>
          <target state="translated">&lt;code&gt;X-Forwarded-Proto&lt;/code&gt; (XFP) 헤더는 클라이언트가 프록시 또는 부하 분산 장치에 연결하는 데 사용하는 프로토콜 (HTTP 또는 HTTPS) 식별하기위한 사실상의 표준 헤더입니다. 서버 액세스 로그에는 서버와로드 밸런서 사이에 사용 된 프로토콜이 포함되어 있지만 클라이언트와로드 밸런서 사이에 사용 된 프로토콜은 포함되어 있지 않습니다. 클라이언트와로드 밸런서간에 사용되는 프로토콜을 결정하기 위해 &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; 요청 헤더를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7641932b013d9ddf2ffa745ed9e59704ae3a5eaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt; . Sites can use this to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;clickjacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; 응답 헤더는 브라우저가있는 페이지를 렌더링하도록 허용해야하는지 여부를 표시하는 데 사용할 수있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 해당&lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; . 사이트는이를 사용 하여 콘텐츠가 다른 사이트에 포함되지 않도록하여 &lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;클릭 재킹&lt;/a&gt; 공격 을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8fc0e13a5bd95f55b983508d376db1ef57d9475" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt; . Sites can use this to avoid &lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;clickjacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; 응답 헤더는 브라우저가있는 페이지를 렌더링하도록 허용해야하는지 여부를 표시하는 데 사용할 수있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 해당&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; . 사이트는이를 사용 하여 콘텐츠가 다른 사이트에 포함되지 않도록함으로써 &lt;a href=&quot;https://en.wikipedia.org/wiki/clickjacking&quot;&gt;클릭 재킹&lt;/a&gt; 공격 을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c716845b63ad60de10c5d0721c333cc0a7789d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; response header can be used to indicate whether or not a browser should be allowed to render a page in a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;. Sites can use this to avoid &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Click-jacking&quot;&gt;click-jacking&lt;/a&gt; attacks, by ensuring that their content is not embedded into other sites.</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;a href=&quot;../index&quot;&gt;HTTP&lt;/a&gt; 응답 헤더는 브라우저가있는 페이지를 렌더링하도록 허용해야하는지 여부를 표시하는 데 사용할 수있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 해당&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; . 사이트는이를 사용 하여 콘텐츠가 다른 사이트에 포함되지 않도록함으로써 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Click-jacking&quot;&gt;클릭 재킹&lt;/a&gt; 공격 을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="691c4a3bae3f1a7c0be3c3aed1c8e618e4fcd9e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delta-seconds&lt;/code&gt; parameter indicates the number of seconds the results can be cached.</source>
          <target state="translated">&lt;code&gt;delta-seconds&lt;/code&gt; 매개 변수는 결과를 캐시 할 수있는 시간 (초)을 나타낸다.</target>
        </trans-unit>
        <trans-unit id="b2e68877049d392fb0d9efdba7e61a35e4736a2f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame-ancestors&lt;/code&gt; directive&amp;rsquo;s syntax is similar to a source list of other directives (e.g. &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt;), but doesn't allow &lt;code&gt;'unsafe-eval'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; for example. It will also not fall back to a &lt;code&gt;default-src&lt;/code&gt; setting. Only the sources listed below are allowed:</source>
          <target state="translated">&lt;code&gt;frame-ancestors&lt;/code&gt; 지시어의 구문은 다른 지시 (예를 들면의 소스 목록과 유사 &lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; )하지만, 허용하지 않는 &lt;code&gt;'unsafe-eval'&lt;/code&gt; 또는 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 예를. 또한 &lt;code&gt;default-src&lt;/code&gt; 설정 으로 돌아 가지 않습니다 . 아래에 나열된 소스 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="8325de55392dc75d103db2ad034803012b8edc93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame-ancestors&lt;/code&gt; directive&amp;rsquo;s syntax is similar to a source list of other directives (e.g. &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt;, but doesn't allow &lt;code&gt;'unsafe-eval'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; for example. It will also not fall back to a &lt;code&gt;default-src&lt;/code&gt; setting. Only the sources listed below are allowed:</source>
          <target state="translated">&lt;code&gt;frame-ancestors&lt;/code&gt; 지시어의 구문은 다른 지시자의 소스 목록 (예와 유사하다 &lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; 하지만, 허용하지 않는 &lt;code&gt;'unsafe-eval'&lt;/code&gt; 또는 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 예를. 그것은 또한 다시 떨어지지 않을 것이다 &lt;code&gt;default-src&lt;/code&gt; 설정 : 아래 나열된 소스 만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="e84f1d948281d5568220728b9d276abf0bdd4199" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;https://foo.example&lt;/code&gt; origin is permitted to request the &lt;code&gt;bar.example/resources/post-here/&lt;/code&gt; URL via the following:</source>
          <target state="translated">&lt;code&gt;https://foo.example&lt;/code&gt; 원산지는 요청하도록 허용 &lt;code&gt;bar.example/resources/post-here/&lt;/code&gt; 다음을 통해 URL :</target>
        </trans-unit>
        <trans-unit id="d731b7e80edba53bed02fe84939621f3420c12d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i&lt;/code&gt; makes it case-insensitive, and &lt;code&gt;mobi&lt;/code&gt; matches all mobile browsers.</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 그것을 대소 문자를 구별하게하고, &lt;code&gt;mobi&lt;/code&gt; 모든 모바일 브라우저와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6ff2a01caeced20b51683f18c74fcf809d0a629a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;infile&lt;/code&gt; parameter is the name of the file you wish to encode into base64 format, and &lt;code&gt;remotename&lt;/code&gt; is the remote name for the file, which isn't actually used in &lt;code&gt;data&lt;/code&gt; URLs.</source>
          <target state="translated">&lt;code&gt;infile&lt;/code&gt; 매개 변수는 base64로 형식으로 인코딩 될 파일의 이름이고, &lt;code&gt;remotename&lt;/code&gt; 실제로에 사용되지 않는 파일의 원격 이름입니다 &lt;code&gt;data&lt;/code&gt; 의 URL.</target>
        </trans-unit>
        <trans-unit id="604f09cfd89d091aa486d6636b750613f4f96b4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mediatype&lt;/code&gt; is a &lt;a href=&quot;mime_types&quot;&gt;MIME type&lt;/a&gt; string, such as &lt;code&gt;'image/jpeg'&lt;/code&gt; for a JPEG image file. If omitted, defaults to &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mediatype&lt;/code&gt; A는 &lt;a href=&quot;mime_types&quot;&gt;MIME 타입&lt;/a&gt; 과 같은 문자열, &lt;code&gt;'image/jpeg'&lt;/code&gt; JPEG 이미지 파일. 생략하면 기본값은 &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8e539bd2196b041a5032c2ef5a8994c7b7bde4dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mediatype&lt;/code&gt; is a MIME type string, such as &lt;code&gt;'image/jpeg'&lt;/code&gt; for a JPEG image file. If omitted, defaults to &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mediatype&lt;/code&gt; 같은 MIME 타입 캐릭터 인 &lt;code&gt;'image/jpeg'&lt;/code&gt; JPEG 이미지 파일. 생략하면 기본값은 &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="da52d7b321f788536d3829326d49c595d809fbf1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/byteranges&lt;/code&gt; MIME type is used to send partial responses to the browser.</source>
          <target state="translated">&lt;code&gt;multipart/byteranges&lt;/code&gt; MIME 유형이 브라우저에 부분적인 응답을 전송하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="13ff0ccca95ad2dd6f5550002a8ef74789370c1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/form-data&lt;/code&gt; type can be used when sending the values of a completed &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Form&lt;/a&gt; from browser to server.</source>
          <target state="translated">&lt;code&gt;multipart/form-data&lt;/code&gt; 완료된 값 전송시 타입이 사용될 수있다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML 폼&lt;/a&gt; 서버 브라우저.</target>
        </trans-unit>
        <trans-unit id="6d4a04b22f0b8d9d9056086ed2761a4ce7474e18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;multipart/form-data&lt;/code&gt;type can be used when sending the values of a completed &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Form&lt;/a&gt; from browser to server.</source>
          <target state="translated">&lt;code&gt;multipart/form-data&lt;/code&gt; 완료된 값 전송시 타입이 사용될 수있다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML 폼&lt;/a&gt; 서버 브라우저.</target>
        </trans-unit>
        <trans-unit id="5ed16b201bb930d269ec462a17331c9fe9b5c948" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no-store&lt;/code&gt; directive will prevent a new resource being cached, but it will not prevent the cache from responding with a non-stale resource that was cached as the result of an earlier request. Setting &lt;code&gt;max-age=0&lt;/code&gt; as well forces the cache to revalidate (clears the cache).</source>
          <target state="translated">&lt;code&gt;no-store&lt;/code&gt; 지시어는 새로운 자원이 캐시되는 방지 할 수 있지만, 이전 요청의 결과로 캐시 된 비 부실 리소스로 응답에서 캐시를 방지하지 않습니다. &lt;code&gt;max-age=0&lt;/code&gt; 을 설정 하면 캐시가 강제로 재 검증됩니다 (캐시가 지워짐).</target>
        </trans-unit>
        <trans-unit id="2d35dc77974d9a90114bab977a8eb5559894a4d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;payment&lt;/code&gt; feature's default allowlist value is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;payment&lt;/code&gt; 기능의 기본 allowlist 값은 &lt;code&gt;'self'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fa620fbdcb9cf9072c11203ebc2680fadd85c4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict-dynamic&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any allow-list or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; are ignored. See &lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt; for an example.</source>
          <target state="translated">&lt;code&gt;strict-dynamic&lt;/code&gt; 신뢰가 명시 적으로 넌스 또는 해시와 함께 제공함으로써, 마크 업에서 스크립트 현재까지 주어진 원본 식의 지정은, 그 루트 스크립트에 의해로드 된 모든 스크립트에 전달해야한다. 동시에 &lt;code&gt;'self'&lt;/code&gt; 또는 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 과 같은 허용 목록 또는 소스 표현식 은 무시됩니다. 예제는 &lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b82adb286ff040efc04b5588e84c42dc13b4b83e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict-dynamic&lt;/code&gt; source expression specifies that the trust explicitly given to a script present in the markup, by accompanying it with a nonce or a hash, shall be propagated to all the scripts loaded by that root script. At the same time, any whitelist or source expressions such as &lt;code&gt;'self'&lt;/code&gt; or &lt;code&gt;'unsafe-inline'&lt;/code&gt; will be ignored. See &lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt; for an example.</source>
          <target state="translated">&lt;code&gt;strict-dynamic&lt;/code&gt; 신뢰가 명시 적으로 넌스 또는 해시와 함께 제공함으로써, 마크 업에서 스크립트 현재까지 주어진 원본 식의 지정은, 그 루트 스크립트에 의해로드 된 모든 스크립트에 전달해야한다. 동시에 &lt;code&gt;'self'&lt;/code&gt; 또는 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 과 같은 화이트리스트 또는 소스 표현식 은 무시됩니다. 예제는 &lt;a href=&quot;script-src#strict-dynamic&quot;&gt;script-src&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3dc0a625918a10bc3cf47e685dbed66f751c4502" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; directive is evaluated before &lt;a href=&quot;block-all-mixed-content&quot;&gt;&lt;code&gt;block-all-mixed-content&lt;/code&gt;&lt;/a&gt; and if it is set, the latter is effectively a no-op. It is recommended to set either directive, but not both, unless you want to force HTTPS on older browsers that do not force it after a redirect to HTTP.</source>
          <target state="translated">&lt;code&gt;upgrade-insecure-requests&lt;/code&gt; 지시자는 이전에 평가 &lt;a href=&quot;block-all-mixed-content&quot;&gt; &lt;code&gt;block-all-mixed-content&lt;/code&gt; &lt;/a&gt; 과이 설정되어있는 경우, 후자는 효과적으로 조작은 행해지 지 않습니다. HTTP로 경로 재 지정한 후 강제하지 않는 이전 브라우저에서 HTTPS를 강제 실행하지 않는 한 두 지시문 중 하나를 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="67a6354b055d21e0ec5e6eda7647d60f1e916b1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; directive will not ensure that users visiting your site via links on third-party sites will be upgraded to HTTPS for the top-level navigation and thus does not replace the &lt;a href=&quot;../strict-transport-security&quot;&gt;&lt;code&gt;Strict-Transport-Security&lt;/code&gt;&lt;/a&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt;) header, which should still be set with an appropriate &lt;code&gt;max-age&lt;/code&gt; to ensure that users are not subject to SSL stripping attacks.</source>
          <target state="translated">&lt;code&gt;upgrade-insecure-requests&lt;/code&gt; 지시어는 대체하지 않습니다 따라서 타사 사이트의 링크를 통해 사이트를 방문하는 사용자가 최상위 탐색을 위해 HTTPS로 업그레이드됩니다 보장하지 않습니다 &lt;a href=&quot;../strict-transport-security&quot;&gt; &lt;code&gt;Strict-Transport-Security&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HSTS&quot;&gt;HSTS&lt;/a&gt; ) 헤더, 어떤 사용자가 SSL 제거 공격을받지 않도록 적절한 &lt;code&gt;max-age&lt;/code&gt; 으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6a8d44d29e56bc0c55ce499b78519e2f545a58b8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;HTTP version&lt;/em&gt;, which defines the structure of the remaining message, acting as an indicator of the expected version to use for the response.</source>
          <target state="translated">&lt;em&gt;HTTP 버전&lt;/em&gt; 응답에 사용할 예정의 버전 표시 자 역할 나머지 메시지의 구조를 정의한다.</target>
        </trans-unit>
        <trans-unit id="534c7de6c70ce30d5cc7ac84f7a1d413ddee5f41" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;asterisk form&lt;/em&gt;, a simple asterisk (&lt;code&gt;'*'&lt;/code&gt;) is used with &lt;code&gt;OPTIONS&lt;/code&gt;, representing the server as a whole.</source>
          <target state="translated">&lt;em&gt;별표 형태&lt;/em&gt; 간단한 별표 ( &lt;code&gt;'*'&lt;/code&gt; )와 함께 사용 &lt;code&gt;OPTIONS&lt;/code&gt; 서버 전체를 나타내는.</target>
        </trans-unit>
        <trans-unit id="e9fb04fb929e15b710da1fe284b86de9e6922e23" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;protocol version&lt;/em&gt;, usually &lt;code&gt;HTTP/1.1&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;프로토콜 버전&lt;/em&gt; , 일반적으로 &lt;code&gt;HTTP/1.1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57141383ea92e8d11fc4aae1bb6ea799c9f809f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;request target&lt;/em&gt;, usually a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;, or the absolute path of the protocol, port, and domain are usually characterized by the request context. The format of this request target varies between different HTTP methods. It can be</source>
          <target state="translated">&lt;em&gt;요청 대상&lt;/em&gt; , 통상 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt; 또는 프로토콜, 포트 및 도메인의 절대 경로는 일반적으로 요청 문맥 특징으로한다. 이 요청 대상의 형식은 HTTP 메소드마다 다릅니다. 그것은 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f9cc4edb4b5b40b8f3c061c79a6b4c632e4c730a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user-agent&lt;/em&gt; is any tool that acts on the behalf of the user. This role is primarily performed by the Web browser; a few exceptions being programs used by engineers, and Web developers to debug their applications.</source>
          <target state="translated">&lt;em&gt;사용자 에이전트는&lt;/em&gt; 사용자를 대신하여 역할을 어떤 도구입니다. 이 역할은 주로 웹 브라우저에서 수행됩니다. 엔지니어와 웹 개발자가 응용 프로그램을 디버깅하는 데 사용하는 프로그램은 예외입니다.</target>
        </trans-unit>
        <trans-unit id="094e3c74b2c1d28d2f1a69f2c5868e7adb3602cc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;user-agent&lt;/em&gt; is any tool that acts on the behalf of the user. This role is primarily performed by the Web browser; other possibilities are programs used by engineers and Web developers to debug their applications.</source>
          <target state="translated">&lt;em&gt;사용자 에이전트는&lt;/em&gt; 사용자를 대신하여 역할을 어떤 도구입니다. 이 역할은 주로 웹 브라우저에서 수행됩니다. 다른 가능성은 엔지니어와 웹 개발자가 응용 프로그램을 디버깅하는 데 사용하는 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="88ff728fce867d59850505a9f213412ce8cd201b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;&lt;var&gt;type&lt;/var&gt;&lt;/strong&gt; represents the general category into which the data type falls, such as &lt;code&gt;video&lt;/code&gt; or &lt;code&gt;text&lt;/code&gt;. The &lt;strong&gt;&lt;var&gt;subtype&lt;/var&gt;&lt;/strong&gt; identifies the exact kind of data of the specified type the MIME type represents. For example, for the MIME type &lt;code&gt;text&lt;/code&gt;, the subtype might be &lt;code&gt;plain&lt;/code&gt; (plain text), &lt;code&gt;html&lt;/code&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTML&quot;&gt;HTML&lt;/a&gt; source code), or &lt;code&gt;calendar&lt;/code&gt; (for iCalendar/&lt;code&gt;.ics&lt;/code&gt;) files.</source>
          <target state="translated">&lt;strong&gt; &lt;var&gt;type&lt;/var&gt; &lt;/strong&gt; 데이터 타입이 같은 속하는 일반 카테고리에 나타내는 &lt;code&gt;video&lt;/code&gt; 또는 &lt;code&gt;text&lt;/code&gt; . &lt;strong&gt; &lt;var&gt;subtype&lt;/var&gt; &lt;/strong&gt; 정확한 종류 MIME 유형이 나타내는 지정된 유형의 데이터를 식별합니다. 예를 들어, MIME 유형 &lt;code&gt;text&lt;/code&gt; 의 경우 하위 유형은 &lt;code&gt;plain&lt;/code&gt; (일반 텍스트), &lt;code&gt;html&lt;/code&gt; ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTML&quot;&gt;HTML&lt;/a&gt; 소스 코드) 또는 &lt;code&gt;calendar&lt;/code&gt; (iCalendar / &lt;code&gt;.ics&lt;/code&gt; 의 경우 ) 파일 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b83df44d3d37a4c410b129685134339244574f5" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Alt-Svc&lt;/strong&gt; header is used to list alternate ways to reach this website.</source>
          <target state="translated">&lt;strong&gt;Alt 키-SVC의&lt;/strong&gt; 헤더는이 웹 사이트에 도달하기 위해 목록 다른 방법으로 사용된다.</target>
        </trans-unit>
        <trans-unit id="8c3c79f7301c1c8d0fa9e587ad3fa734394dfbe4" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP DELETE request method&lt;/strong&gt; deletes the specified resource.</source>
          <target state="translated">&lt;strong&gt;HTTP DELETE 요청 방법은&lt;/strong&gt; 지정된 자원을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="8f98d07b9e286fdee4af0bfd151e3fef8b4e1fdf" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP PATCH request method&lt;/strong&gt; applies partial modifications to a resource.</source>
          <target state="translated">&lt;strong&gt;HTTP 패치 요청 방법은&lt;/strong&gt; 리소스에 일부 변경을 적용한다.</target>
        </trans-unit>
        <trans-unit id="2f72c255d4cd8cf0faaa3dfd5ef732d3c26ae02b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;HTTP PUT request method&lt;/strong&gt; creates a new resource or replaces a representation of the target resource with the request payload.</source>
          <target state="translated">&lt;strong&gt;HTTP PUT 요청의 방법은&lt;/strong&gt; 새로운 자원을 생성 또는 요청 페이로드 대상 자원의 표시를 대체한다.</target>
        </trans-unit>
        <trans-unit id="617a279a7f85aa11b7e9119c0549c65940ed8bdb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Sec-WebSocket-Accept&lt;/strong&gt; header is used in the websocket opening handshake. It would appear in the response headers. That is, this is header is sent from server to client to inform that server is willing to initiate a websocket connection.</source>
          <target state="translated">&lt;strong&gt;급 - 웹 소켓으로 수락&lt;/strong&gt; 헤더는 웹 소켓 개구 악수 사용된다. 응답 헤더에 나타납니다. 즉, 서버가 웹 소켓 연결을 시작하려고한다는 것을 알리기 위해 서버에서 클라이언트로 헤더가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="fec1b2ea30a4b23ec6ed613fb4a58917ff6f2e5d" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Trailer&lt;/strong&gt; response header allows the sender to include additional fields at the end of chunked messages in order to supply metadata that might be dynamically generated while the message body is sent, such as a message integrity check, digital signature, or post-processing status.</source>
          <target state="translated">&lt;strong&gt;트레일러&lt;/strong&gt; 응답 헤더는 송신자가 메시지 본문이 그러한 메시지 무결성 검사, 디지털 서명, 또는 후 처리 상태와 같은 전송 동안 동적으로 생성 될 수 공급 메타하기 위해 청크 메시지의 끝에 추가 필드를 포함 할 수있다.</target>
        </trans-unit>
        <trans-unit id="72b737b3f7ebb245858f1a5344bbb6bcfd1d296b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;User-Agent&lt;/strong&gt; request header contains a characteristic string that allows the network protocol peers to identify the application type, operating system, software vendor or software version of the requesting software user agent.</source>
          <target state="translated">&lt;strong&gt;사용자 에이전트&lt;/strong&gt; 요청 헤더는 네트워크 프로토콜 피어 응용 프로그램 유형, 운영 체제, 소프트웨어 공급 업체 또는 요청 소프트웨어 사용자 에이전트의 소프트웨어 버전을 식별 할 수있는 특성 문자열을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="2288013069b97e56ffbc4768d5888642c23e6913" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;User-Agent&lt;/strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/request_header&quot;&gt;request header&lt;/a&gt; is a characteristic string that lets servers and network peers identify the application, operating system, vendor, and/or version of the requesting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;사용자 에이전트 &lt;/strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/request_header&quot;&gt;요청 헤더는&lt;/a&gt; 서버와 네트워크 피어가 요청하는 응용 프로그램, 운영 체제, 공급 업체 및 / 또는 버전을 식별 할 수있는 특성 문자열 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="808b80dac820b6a1614956c81b08b2381235cc1b" translate="yes" xml:space="preserve">
          <source>The Accept header</source>
          <target state="translated">Accept 헤더</target>
        </trans-unit>
        <trans-unit id="ab7fb45a1dfda8bd680e10b36530ac6598af98b2" translate="yes" xml:space="preserve">
          <source>The Accept request-header field can be used to specify certain media
   types which are acceptable for the response. Accept headers can be
   used to indicate that the request is specifically limited to a small
   set of desired types, as in the case of a request for an in-line
   image.

       Accept         = &quot;Accept&quot; &quot;:&quot;
                        #( media-range [ accept-params ] )

       media-range    = ( &quot;*/*&quot;
                        | ( type &quot;/&quot; &quot;*&quot; )
                        | ( type &quot;/&quot; subtype )
                        ) *( &quot;;&quot; parameter )
       accept-params  = &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue *( accept-extension )
       accept-extension = &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]

   The asterisk &quot;*&quot; character is used to group media types into ranges,
   with &quot;*/*&quot; indicating all media types and &quot;type/*&quot; indicating all
   subtypes of that type. The media-range MAY include media type
   parameters that are applicable to that range.

   Each media-range MAY be followed by one or more accept-params,
   beginning with the &quot;q&quot; parameter for indicating a relative quality
   factor. The first &quot;q&quot; parameter (if any) separates the media-range
   parameter(s) from the accept-params. Quality factors allow the user
   or user agent to indicate the relative degree of preference for that
   media-range, using the qvalue scale from 0 to 1 (&lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;). The
   default value is q=1.

      Note: Use of the &quot;q&quot; parameter name to separate media type
      parameters from Accept extension parameters is due to historical
      practice. Although this prevents any media type parameter named
      &quot;q&quot; from being used with a media range, such an event is believed
      to be unlikely given the lack of any &quot;q&quot; parameters in the IANA
      media type registry and the rare usage of any media type
      parameters in Accept. Future media types are discouraged from
      registering any parameter named &quot;q&quot;. 

   The example

       Accept: audio/*; q=0.2, audio/basic

   SHOULD be interpreted as &quot;I prefer audio/basic, but send me any audio
   type if it is the best available after an 80% mark-down in quality.&quot;

   If no Accept header field is present, then it is assumed that the
   client accepts all media types. If an Accept header field is present,
   and if the server cannot send a response which is acceptable
   according to the combined Accept field value, then the server SHOULD
   send a 406 (not acceptable) response.

   A more elaborate example is

       Accept: text/plain; q=0.5, text/html,
               text/x-dvi; q=0.8, text/x-c

   Verbally, this would be interpreted as &quot;text/html and text/x-c are
   the preferred media types, but if they do not exist, then send the
   text/x-dvi entity, and if that does not exist, send the text/plain
   entity.&quot;

   Media ranges can be overridden by more specific media ranges or
   specific media types. If more than one media range applies to a given
   type, the most specific reference has precedence. For example,

       Accept: text/*, text/html, text/html;level=1, */*

   have the following precedence:

       1) text/html;level=1
       2) text/html
       3) text/*
       4) */*

   The media type quality factor associated with a given type is
   determined by finding the media range with the highest precedence
   which matches that type. For example,

       Accept: text/*;q=0.3, text/html;q=0.7, text/html;level=1,
               text/html;level=2;q=0.4, */*;q=0.5

   would cause the following values to be associated:

       text/html;level=1         = 1
       text/html                 = 0.7
       text/plain                = 0.3 

       image/jpeg                = 0.5
       text/html;level=2         = 0.4
       text/html;level=3         = 0.7

      Note: A user agent might be provided with a default set of quality
      values for certain media ranges. However, unless the user agent is
      a closed system which cannot interact with other rendering agents,
      this default set ought to be configurable by the user.</source>
          <target state="translated">요청 헤더 승인 필드를 사용하여 응답에 적합한 특정 매체 유형을 지정할 수 있습니다. 수락 헤더는 인라인 이미지에 대한 요청의 경우와 같이 요청이 원하는 유형의 작은 세트로 특별히 제한됨을 나타내는 데 사용될 수 있습니다. Accept = &quot;Accept&quot; &quot;:&quot;# (media-range [accept-params]) media-range = ( &quot;* / *&quot;| ( &quot;/&quot; &quot;*&quot;) | ( &quot;/&quot;하위 유형)) * ( &quot;;&quot;parameter) accept-params = &quot;;&quot; &quot;q&quot; &quot;=&quot;qvalue * (accept-extension) accept-extension = &quot;;&quot; token [ &quot;=&quot;(token | quoted-string)] 별표 &quot;*&quot;문자는 미디어 유형을 범위로 그룹화하는 데 사용되며 &quot;* / *&quot;는 모든 미디어 유형을 나타내고 &quot;type / *&quot;은 해당 유형의 모든 하위 유형을 나타냅니다. 미디어 범위는 해당 범위에 적용 할 수있는 미디어 유형 매개 변수를 포함 할 수 있습니다. 각 매체 범위 뒤에는 상대 품질 계수를 나타내는 &quot;q&quot;매개 변수로 시작하는 하나 이상의 accept-params가 올 수 있습니다. 첫 번째 &quot;q&quot;매개 변수 (있는 경우)는 미디어 범위 매개 변수를 accept-params에서 분리합니다. 품질 요소를 통해 사용자 또는 사용자 에이전트는 0에서 1까지의 qvalue 척도를 사용하여 해당 미디어 범위에 대한 상대적 선호도를 표시 할 수 있습니다 (미디어 범위는 해당 범위에 적용 가능한 미디어 유형 매개 변수를 포함 할 수 있습니다. 각 매체 범위 뒤에는 상대 품질 계수를 나타내는 &quot;q&quot;매개 변수로 시작하는 하나 이상의 accept-params가 올 수 있습니다. 첫 번째 &quot;q&quot;매개 변수 (있는 경우)는 미디어 범위 매개 변수를 accept-params에서 분리합니다. 품질 요소를 통해 사용자 또는 사용자 에이전트는 0에서 1까지의 qvalue 척도를 사용하여 해당 미디어 범위에 대한 상대적 선호도를 표시 할 수 있습니다 (미디어 범위는 해당 범위에 적용 할 수있는 미디어 유형 매개 변수를 포함 할 수 있습니다. 각 매체 범위 뒤에는 상대 품질 계수를 나타내는 &quot;q&quot;매개 변수로 시작하는 하나 이상의 accept-params가 올 수 있습니다. 첫 번째 &quot;q&quot;매개 변수 (있는 경우)는 미디어 범위 매개 변수를 accept-params에서 분리합니다. 품질 요소를 통해 사용자 또는 사용자 에이전트는 0에서 1까지의 qvalue 척도를 사용하여 해당 미디어 범위에 대한 상대적 선호도를 표시 할 수 있습니다 (품질 요소를 통해 사용자 또는 사용자 에이전트는 0에서 1까지의 qvalue 척도를 사용하여 해당 미디어 범위에 대한 상대적 선호도를 표시 할 수 있습니다 (품질 요소를 통해 사용자 또는 사용자 에이전트는 0에서 1까지의 qvalue 척도를 사용하여 해당 미디어 범위에 대한 상대적 선호도를 표시 할 수 있습니다 (&lt;a href=&quot;#section-3.9&quot;&gt;섹션 3.9&lt;/a&gt;). 기본값은 q = 1입니다. 참고 : &quot;q&quot;매개 변수 이름을 사용하여 미디어 유형 매개 변수를 확장 확장 매개 변수 허용과 분리하는 것은 이전의 관행 때문입니다. 이렇게하면 &quot;q&quot;라는 매체 유형 매개 변수가 매체 범위와 함께 사용되지 않지만, 이러한 이벤트는 IANA 매체 유형 레지스트리에 &quot;q&quot;매개 변수가없고 매체 유형이 거의 사용되지 않는 것으로 간주됩니다. 수락의 매개 변수. 향후 미디어 유형은 &quot;q&quot;라는 매개 변수를 등록하지 않는 것이 좋습니다. 수락 예 : audio / *; q = 0.2, 오디오 / 기본은 &quot;오디오 / 기본을 선호하지만 품질이 80 % 감소한 후에 가장 좋은 오디오 유형을 보내 주시기 바랍니다.&quot; 수락 헤더 필드가 없으면클라이언트는 모든 매체 유형을 승인한다고 가정합니다. 수락 헤더 필드가 있고 서버가 결합 된 수락 필드 값에 따라 허용되는 응답을 보낼 수없는 경우 서버는 406 (허용되지 않음) 응답을 보내야합니다. 보다 정교한 예는 Accept : text / plain; q = 0.5, 텍스트 / html, 텍스트 / x-dvi; q = 0.8, text / xc 구두로, 이것은 &quot;text / html 및 text / xc가 선호되는 미디어 유형으로 해석되지만 존재하지 않는 경우 text / x-dvi 엔티티를 보내십시오. 텍스트 / 일반 엔티티를 보냅니다. &quot; 보다 구체적인 용지 범위 또는 특정 용지 종류로 용지 범위를 재정의 할 수 있습니다. 특정 유형에 둘 이상의 매체 범위가 적용되는 경우 가장 구체적인 참조가 우선합니다. 예를 들어 수락 :text / *, text / html, text / html; level = 1, * / *의 우선 순위는 1) text / html; level = 1 2) text / html 3) text / * 4) * / * 미디어입니다. 주어진 유형과 관련된 유형 품질 계수는 해당 유형과 일치하는 우선 순위가 가장 높은 미디어 범위를 찾아서 결정됩니다. 예를 들어 수락 : text / *; q = 0.3, text / html; q = 0.7, text / html; level = 1, text / html; level = 2; q = 0.4, * / *; q = 0.5는 연관 될 다음 값 : text / html; level = 1 = 1 text / html = 0.7 text / plain = 0.3 image / jpeg = 0.5 text / html; level = 2 = 0.4 text / html; level = 3 = 0.7 참고 : 사용자 에이전트에 특정 미디어 범위에 대한 기본 품질 값 세트가 제공 될 수 있습니다.그러나 사용자 에이전트가 다른 렌더링 에이전트와 상호 작용할 수없는 닫힌 시스템이 아닌 경우이 기본 세트는 사용자가 구성 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e7b4f26fbb0e2bce3365129a80d0fb7728e75c9b" translate="yes" xml:space="preserve">
          <source>The Accept-CH header</source>
          <target state="translated">Accept-CH 헤더</target>
        </trans-unit>
        <trans-unit id="d63aae7229caefbd97fe24c548f9020512978ccc" translate="yes" xml:space="preserve">
          <source>The Accept-CH-Lifetime header</source>
          <target state="translated">Accept-CH-Lifetime 헤더</target>
        </trans-unit>
        <trans-unit id="4769fb0951abad4aa7016b3134653949993c77de" translate="yes" xml:space="preserve">
          <source>The Accept-Charset header</source>
          <target state="translated">Accept-Charset 헤더</target>
        </trans-unit>
        <trans-unit id="234dfa2f1729dd01886001e7daa88ee0bafe27f6" translate="yes" xml:space="preserve">
          <source>The Accept-Charset request-header field can be used to indicate what
   character sets are acceptable for the response. This field allows
   clients capable of understanding more comprehensive or special-
   purpose character sets to signal that capability to a server which is
   capable of representing documents in those character sets.

      Accept-Charset = &quot;Accept-Charset&quot; &quot;:&quot;
              1#( ( charset | &quot;*&quot; )[ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )


   Character set values are described in &lt;a href=&quot;#section-3.4&quot;&gt;section 3.4&lt;/a&gt;. Each charset MAY
   be given an associated quality value which represents the user's
   preference for that charset. The default value is q=1. An example is

      Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

   The special value &quot;*&quot;, if present in the Accept-Charset field,
   matches every character set (including ISO-8859-1) which is not
   mentioned elsewhere in the Accept-Charset field. If no &quot;*&quot; is present
   in an Accept-Charset field, then all character sets not explicitly
   mentioned get a quality value of 0, except for ISO-8859-1, which gets
   a quality value of 1 if not explicitly mentioned.

   If no Accept-Charset header is present, the default is that any
   character set is acceptable. If an Accept-Charset header is present,
   and if the server cannot send a response which is acceptable
   according to the Accept-Charset header, then the server SHOULD send
   an error response with the 406 (not acceptable) status code, though
   the sending of an unacceptable response is also allowed.</source>
          <target state="translated">Accept-Charset request-header 필드는 응답에 허용되는 문자 집합을 나타내는 데 사용할 수 있습니다. 이 필드를 사용하면보다 포괄적이거나 특수한 문자 세트를 이해할 수있는 클라이언트가 해당 문자 세트의 문서를 나타낼 수있는 서버에 해당 기능을 알릴 수 있습니다. Accept-Charset = &quot;Accept-Charset&quot; &quot;:&quot;1 # ((charset | &quot;*&quot;) [ &quot;;&quot; &quot;q&quot; &quot;=&quot;qvalue]) 문자 세트 값은&lt;a href=&quot;#section-3.4&quot;&gt; 3.4 절에 있습니다.&lt;/a&gt;. 각 문자 세트에는 해당 문자 세트에 대한 사용자의 선호도를 나타내는 관련 품질 값이 주어질 수 있습니다. 기본값은 q = 1입니다. 예는 Accept-Charset입니다. iso-8859-5, unicode-1-1; q = 0.8 Accept-Charset 필드에있는 특수 값 &quot;*&quot;는 모든 문자 세트 (ISO-8859-1 포함)와 일치합니다. Accept-Charset 필드의 다른 곳에서는 언급되지 않았습니다. Accept-Charset 필드에 &quot;*&quot;가 없으면 명시 적으로 언급되지 않은 경우 품질 값이 1 인 ISO-8859-1을 제외하고 명시 적으로 언급되지 않은 모든 문자 세트의 품질 값은 0입니다. Accept-Charset 헤더가 없으면 기본적으로 모든 문자 집합이 허용됩니다. Accept-Charset 헤더가 있으면서버가 Accept-Charset 헤더에 따라 허용되는 응답을 보낼 수없는 경우 서버는 허용 할 수없는 응답 전송도 허용되지만 406 (허용되지 않음) 상태 코드로 오류 응답을 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="4cd92c762aa78d137a23b8b73482ba75b9995048" translate="yes" xml:space="preserve">
          <source>The Accept-Encoding header</source>
          <target state="translated">Accept-Encoding 헤더</target>
        </trans-unit>
        <trans-unit id="2e57729d1ed38c6ddc068a85cca9d470a3c1d181" translate="yes" xml:space="preserve">
          <source>The Accept-Encoding request-header field is similar to Accept, but
   restricts the content-codings (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;) that are acceptable in
   the response.

       Accept-Encoding  = &quot;Accept-Encoding&quot; &quot;:&quot; 

                          1#( codings [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
       codings          = ( content-coding | &quot;*&quot; )

   Examples of its use are:

       Accept-Encoding: compress, gzip
       Accept-Encoding:
       Accept-Encoding: *
       Accept-Encoding: compress;q=0.5, gzip;q=1.0
       Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0

   A server tests whether a content-coding is acceptable, according to
   an Accept-Encoding field, using these rules:

      1. If the content-coding is one of the content-codings listed in
         the Accept-Encoding field, then it is acceptable, unless it is
         accompanied by a qvalue of 0. (As defined in &lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;, a
         qvalue of 0 means &quot;not acceptable.&quot;)

      2. The special &quot;*&quot; symbol in an Accept-Encoding field matches any
         available content-coding not explicitly listed in the header
         field.

      3. If multiple content-codings are acceptable, then the acceptable
         content-coding with the highest non-zero qvalue is preferred.

      4. The &quot;identity&quot; content-coding is always acceptable, unless
         specifically refused because the Accept-Encoding field includes
         &quot;identity;q=0&quot;, or because the field includes &quot;*;q=0&quot; and does
         not explicitly include the &quot;identity&quot; content-coding. If the
         Accept-Encoding field-value is empty, then only the &quot;identity&quot;
         encoding is acceptable.

   If an Accept-Encoding field is present in a request, and if the
   server cannot send a response which is acceptable according to the
   Accept-Encoding header, then the server SHOULD send an error response
   with the 406 (Not Acceptable) status code.

   If no Accept-Encoding field is present in a request, the server MAY
   assume that the client will accept any content coding. In this case,
   if &quot;identity&quot; is one of the available content-codings, then the
   server SHOULD use the &quot;identity&quot; content-coding, unless it has
   additional information that a different content-coding is meaningful
   to the client.

      Note: If the request does not include an Accept-Encoding field,
      and if the &quot;identity&quot; content-coding is unavailable, then
      content-codings commonly understood by HTTP/1.0 clients (i.e., 

      &quot;gzip&quot; and &quot;compress&quot;) are preferred; some older clients
      improperly display messages sent with other content-codings.  The
      server might also make this decision based on information about
      the particular user-agent or client.

      Note: Most HTTP/1.0 applications do not recognize or obey qvalues
      associated with content-codings. This means that qvalues will not
      work and are not permitted with x-gzip or x-compress.</source>
          <target state="translated">Accept-Encoding request-header 필드는 Accept와 유사하지만 컨텐츠 코딩을 제한합니다 (&lt;a href=&quot;#section-3.5&quot;&gt; (3.5 절&lt;/a&gt;)가 응답에 허용됩니다. Accept-Encoding = &quot;Accept-Encoding&quot; &quot;:&quot;1 # (codings [ &quot;;&quot; &quot;q&quot; &quot;=&quot;qvalue]) codings = (content-coding | &quot;*&quot;) 사용 예는 다음과 같습니다. Accept-Encoding : 압축, gzip Accept-Encoding : Accept-Encoding : * Accept-Encoding : compress; q = 0.5, gzip; q = 1.0 Accept-Encoding : gzip; q = 1.0, ID; q = 0.5, *; q = 0 서버는 다음 규칙을 사용하여 Accept-Encoding 필드에 따라 컨텐츠 코딩이 허용되는지 여부를 테스트합니다. 1. 컨텐츠 코딩이 Accept에 나열된 컨텐츠 코딩 중 하나 인 경우 -인코딩 필드, q 값이 0이 아닌 경우 허용됩니다.&lt;a href=&quot;#section-3.9&quot;&gt; 섹션 3.9에&lt;/a&gt;qvalue 0은 &quot;허용되지 않음&quot;을 의미합니다. 2. Accept-Encoding 필드의 특수 &quot;*&quot;기호는 헤더 필드에 명시 적으로 나열되지 않은 사용 가능한 모든 컨텐츠 코딩과 일치합니다. 3. 다수의 컨텐츠 코딩이 허용 가능한 경우, 0이 아닌 q 값을 갖는 허용 가능한 컨텐츠 코딩이 선호됩니다. 4. Accept-Encoding 필드에 &quot;identity; q = 0&quot;이 포함되거나 필드에 &quot;*; q = 0&quot;이 포함되고 &quot;*; q = 0&quot;이 포함되어 있고 &quot;&quot;; 신원 &quot;콘텐츠 코딩. Accept-Encoding 필드 값이 비어 있으면 &quot;identity&quot;인코딩 만 허용됩니다.Accept-Encoding 필드가 요청에 있고 서버가 Accept-Encoding 헤더에 따라 허용되는 응답을 보낼 수없는 경우 서버는 406 (Not Acceptable) 상태 코드와 함께 오류 응답을 보내야합니다. 요청에 Accept-Encoding 필드가 없으면 서버는 클라이언트가 모든 컨텐츠 코딩을 수락한다고 가정 할 수 있습니다. 이 경우, &quot;identity&quot;가 이용 가능한 컨텐츠 코딩 중 하나라면, 다른 컨텐츠 코딩이 클라이언트에게 의미가 있다는 추가 정보가없는 한, 서버는 &quot;identity&quot;컨텐츠 코딩을 사용해야한다. 참고 : 요청에 Accept-Encoding 필드가 포함되어 있지 않고 &quot;identity&quot;컨텐츠 코딩을 사용할 수없는 경우 HTTP / 1.0 클라이언트에서 일반적으로 이해하는 컨텐츠 코딩 (예 :&quot;gzip&quot;및 &quot;compress&quot;)가 선호됩니다. 일부 오래된 클라이언트는 다른 컨텐츠 코딩으로 전송 된 메시지를 부적절하게 표시합니다. 서버는 특정 사용자 에이전트 또는 클라이언트에 대한 정보를 기반으로이 결정을 내릴 수도 있습니다. 참고 : 대부분의 HTTP / 1.0 응용 프로그램은 컨텐츠 코딩과 관련된 q 값을 인식하거나 따르지 않습니다. 이것은 qvalues가 작동하지 않으며 x-gzip 또는 x-compress에서 허용되지 않음을 의미합니다.이것은 qvalues가 작동하지 않으며 x-gzip 또는 x-compress에서 허용되지 않음을 의미합니다.이것은 qvalues가 작동하지 않으며 x-gzip 또는 x-compress에서 허용되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="007df01155d25e755642903868beaa64cb7fcbdf" translate="yes" xml:space="preserve">
          <source>The Accept-Language header</source>
          <target state="translated">Accept-Language 헤더</target>
        </trans-unit>
        <trans-unit id="2ba115d77d254ca318ebb9337409d39d8d2c75fa" translate="yes" xml:space="preserve">
          <source>The Accept-Language request-header field is similar to Accept, but
   restricts the set of natural languages that are preferred as a
   response to the request. Language tags are defined in &lt;a href=&quot;#section-3.10&quot;&gt;section 3.10&lt;/a&gt;.

       Accept-Language = &quot;Accept-Language&quot; &quot;:&quot;
                         1#( language-range [ &quot;;&quot; &quot;q&quot; &quot;=&quot; qvalue ] )
       language-range  = ( ( 1*8ALPHA *( &quot;-&quot; 1*8ALPHA ) ) | &quot;*&quot; )

   Each language-range MAY be given an associated quality value which
   represents an estimate of the user's preference for the languages
   specified by that range. The quality value defaults to &quot;q=1&quot;. For
   example,

       Accept-Language: da, en-gb;q=0.8, en;q=0.7

   would mean: &quot;I prefer Danish, but will accept British English and
   other types of English.&quot; A language-range matches a language-tag if
   it exactly equals the tag, or if it exactly equals a prefix of the
   tag such that the first tag character following the prefix is &quot;-&quot;.
   The special range &quot;*&quot;, if present in the Accept-Language field,
   matches every tag not matched by any other range present in the
   Accept-Language field.

      Note: This use of a prefix matching rule does not imply that
      language tags are assigned to languages in such a way that it is
      always true that if a user understands a language with a certain
      tag, then this user will also understand all languages with tags
      for which this tag is a prefix. The prefix rule simply allows the
      use of prefix tags if this is the case.

   The language quality factor assigned to a language-tag by the
   Accept-Language field is the quality value of the longest language-
   range in the field that matches the language-tag. If no language-
   range in the field matches the tag, the language quality factor
   assigned is 0. If no Accept-Language header is present in the
   request, the server 

   SHOULD assume that all languages are equally acceptable. If an
   Accept-Language header is present, then all languages which are
   assigned a quality factor greater than 0 are acceptable.

   It might be contrary to the privacy expectations of the user to send
   an Accept-Language header with the complete linguistic preferences of
   the user in every request. For a discussion of this issue, see
   &lt;a href=&quot;#section-15.1.4&quot;&gt;section 15.1.4&lt;/a&gt;.

   As intelligibility is highly dependent on the individual user, it is
   recommended that client applications make the choice of linguistic
   preference available to the user. If the choice is not made
   available, then the Accept-Language header field MUST NOT be given in
   the request.

      Note: When making the choice of linguistic preference available to
      the user, we remind implementors of  the fact that users are not
      familiar with the details of language matching as described above,
      and should provide appropriate guidance. As an example, users
      might assume that on selecting &quot;en-gb&quot;, they will be served any
      kind of English document if British English is not available. A
      user agent might suggest in such a case to add &quot;en&quot; to get the
      best matching behavior.</source>
          <target state="translated">Accept-Language request-header 필드는 Accept와 비슷하지만 요청에 대한 응답으로 선호되는 자연어 세트를 제한합니다. 언어 태그는 &lt;a href=&quot;#section-3.10&quot;&gt;섹션 3.10에&lt;/a&gt; 정의되어 있습니다.. Accept-Language = &quot;Accept-Language&quot; &quot;:&quot;1 # (language-range [ &quot;;&quot; &quot;q&quot; &quot;=&quot;qvalue]) language-range = ((1 * 8ALPHA * ( &quot;-&quot;1 * 8ALPHA)) &quot;*&quot;) 각 언어 범위에는 해당 범위에 의해 지정된 언어에 대한 사용자의 선호도 추정치를 나타내는 관련 품질 값이 주어질 수 있습니다. 품질 값의 기본값은 &quot;q = 1&quot;입니다. 예를 들어 Accept-Language : da, en-gb; q = 0.8, en; q = 0.7은 &quot;나는 덴마크어를 선호하지만 영국 영어와 다른 유형의 영어는 허용합니다&quot;를 의미합니다. 언어 범위는 태그와 정확히 일치하거나 접두사 다음에 오는 첫 번째 태그 문자가 &quot;-&quot;가되도록 태그의 접두사와 정확히 일치하는 경우 언어 태그와 일치합니다.Accept-Language 필드에있는 경우 특수 범위 &quot;*&quot;는 Accept-Language 필드에있는 다른 범위와 일치하지 않는 모든 태그와 일치합니다. 참고 : 접두사 일치 규칙을 사용한다고해서 언어 태그가 언어에 할당되었다는 의미는 아닙니다. 사용자가 특정 태그가있는 언어를 이해하면이 사용자는 태그가있는 모든 언어도 이해할 수 있습니다 이 태그는 접두사입니다. 접두사 규칙을 사용하면 접두사 태그를 사용할 수 있습니다. Accept-Language 필드에 의해 언어 태그에 할당 된 언어 품질 요소는 언어 태그와 일치하는 필드에서 가장 긴 언어 범위의 품질 값입니다. 필드의 언어 범위가 태그와 일치하지 않으면 할당 된 언어 품질 계수는 0입니다.요청에 Accept-Language 헤더가 없으면 서버는 모든 언어가 똑같이 수용 가능한 것으로 가정해야합니다. Accept-Language 헤더가 있으면 0보다 큰 품질 계수가 지정된 모든 언어를 사용할 수 있습니다. 모든 요청에서 사용자의 완전한 언어 환경 설정으로 Accept-Language 헤더를 전송하는 것은 사용자의 개인 정보 보호 기대와 상반 될 수 있습니다. 이 문제에 대한 설명은모든 요청에서 사용자의 완전한 언어 환경 설정으로 Accept-Language 헤더를 전송하는 것은 사용자의 개인 정보 보호 기대와 상반 될 수 있습니다. 이 문제에 대한 설명은모든 요청에서 사용자의 완전한 언어 환경 설정으로 Accept-Language 헤더를 전송하는 것은 사용자의 개인 정보 보호 기대와 상반 될 수 있습니다. 이 문제에 대한 설명은 &lt;a href=&quot;#section-15.1.4&quot;&gt;섹션 15.1.4&lt;/a&gt;. 명료성은 개별 사용자에 따라 크게 달라 지므로 클라이언트 응용 프로그램에서 언어 선호도를 선택할 수 있도록하는 것이 좋습니다. 선택이 불가능한 경우 요청에 Accept-Language 헤더 필드를 지정해서는 안됩니다 (MUST NOT). 참고 : 언어 선호도 선택을 사용자에게 제공 할 때 사용자는 위에서 설명한대로 언어 일치에 대한 세부 사항에 익숙하지 않으며 적절한 지침을 제공해야한다는 사실을 구현 자에게 상기시킵니다. 예를 들어, 사용자는 &quot;en-gb&quot;를 선택할 때 영국 영어를 사용할 수없는 경우 모든 종류의 영어 문서가 제공된다고 가정 할 수 있습니다. 이 경우 사용자 에이전트는 &quot;en&quot;을 추가하여 가장 일치하는 동작을 얻을 것을 제안 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dceeccc14ca79697274f5080fd10fd4f709e2583" translate="yes" xml:space="preserve">
          <source>The Accept-Ranges response-header field allows the server to
      indicate its acceptance of range requests for a resource:

          Accept-Ranges     = &quot;Accept-Ranges&quot; &quot;:&quot; acceptable-ranges
          acceptable-ranges = 1#range-unit | &quot;none&quot;

      Origin servers that accept byte-range requests MAY send

          Accept-Ranges: bytes

      but are not required to do so. Clients MAY generate byte-range
      requests without having received this header for the resource
      involved. Range units are defined in &lt;a href=&quot;#section-3.12&quot;&gt;section 3.12&lt;/a&gt;.

      Servers that do not accept any kind of range request for a
      resource MAY send

          Accept-Ranges: none

      to advise the client not to attempt a range request.</source>
          <target state="translated">Accept-Ranges response-header 필드는 서버가 자원에 대한 범위 요청의 수락을 표시 할 수있게합니다. &quot;none&quot;바이트 범위 요청을 수락하는 오리진 서버는 Accept-Ranges : bytes를 보낼 수 있지만 반드시 그럴 필요는 없습니다. 클라이언트는 관련된 리소스에 대해이 헤더를받지 않고도 바이트 범위 요청을 생성 할 수 있습니다. 범위 단위는 &lt;a href=&quot;#section-3.12&quot;&gt;섹션 3.12에&lt;/a&gt; 정의되어 있습니다 . 자원에 대해 어떤 종류의 범위 요청도 허용하지 않는 서버는 수락 범위를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20fe0a78765b42653f8af73cd9564f1524ef0e69" translate="yes" xml:space="preserve">
          <source>The Age header field is used to convey an estimated age of the
   response message when obtained from a cache.  The Age field value is
   the cache's estimate of the number of seconds since the response was
   generated or validated by the origin server.  In essence, the Age 

   value is the sum of the time that the response has been resident in
   each of the caches along the path from the origin server, plus the
   amount of time it has been in transit along network paths.

   The following data is used for the age calculation:

   age_value

      The term &quot;age_value&quot; denotes the value of the Age header field
      (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;), in a form appropriate for arithmetic operation; or
      0, if not available.

   date_value

      The term &quot;date_value&quot; denotes the value of the Date header field,
      in a form appropriate for arithmetic operations.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;7.1.1.2 of [RFC7231]&lt;/a&gt; for the definition of the Date header field,
      and for requirements regarding responses without it.

   now

      The term &quot;now&quot; means &quot;the current value of the clock at the host
      performing the calculation&quot;.  A host ought to use NTP ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC5905&lt;/a&gt;])
      or some similar protocol to synchronize its clocks to Coordinated
      Universal Time.

   request_time

      The current value of the clock at the host at the time the request
      resulting in the stored response was made.

   response_time

      The current value of the clock at the host at the time the
      response was received.

   A response's age can be calculated in two entirely independent ways:

   1.  the &quot;apparent_age&quot;: response_time minus date_value, if the local
       clock is reasonably well synchronized to the origin server's
       clock.  If the result is negative, the result is replaced by
       zero.

   2.  the &quot;corrected_age_value&quot;, if all of the caches along the
       response path implement HTTP/1.1.  A cache MUST interpret this
       value relative to the time the request was initiated, not the
       time that the response was received. 

     apparent_age = max(0, response_time - date_value);

     response_delay = response_time - request_time;
     corrected_age_value = age_value + response_delay;

   These are combined as

     corrected_initial_age = max(apparent_age, corrected_age_value);

   unless the cache is confident in the value of the Age header field
   (e.g., because there are no HTTP/1.0 hops in the Via header field),
   in which case the corrected_age_value MAY be used as the
   corrected_initial_age.

   The current_age of a stored response can then be calculated by adding
   the amount of time (in seconds) since the stored response was last
   validated by the origin server to the corrected_initial_age.

     resident_time = now - response_time;
     current_age = corrected_initial_age + resident_time;</source>
          <target state="translated">Age 헤더 필드는 캐시에서 얻은 응답 메시지의 예상 수명을 전달하는 데 사용됩니다. Age 필드 값은 응답이 오리진 서버에 의해 생성되거나 유효성 검증 된 이후의 캐시 예상 시간 (초)입니다. 본질적으로 Age 값은 응답이 원래 서버의 경로를 따라 각 캐시에 상주 한 시간과 네트워크 경로를 따라 전송 된 시간의 합계입니다. 연령 계산에 다음 데이터가 사용됩니다. age_value &quot;age_value&quot;라는 용어는 연령 헤더 필드의 값을 나타냅니다 (&lt;a href=&quot;#section-5.1&quot;&gt; 섹션 5.1&lt;/a&gt;) 산술 연산에 적합한 형태 또는 사용할 수없는 경우 0입니다. date_value &quot;date_value&quot;라는 용어는 날짜 헤더 필드의 값을 산술 연산에 적합한 형식으로 나타냅니다. 날짜 헤더 필드의 정의 및 필드가없는 응답에 대한 요구 사항 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;은 [RFC7231]의 7.1.1.2 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;단원을&lt;/a&gt; 참조하십시오 . &quot;지금&quot;이라는 용어는 &quot;계산을 수행하는 호스트에서의 클럭의 현재 값&quot;을 의미합니다. 호스트는 NTP를 사용해야합니다 ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt; RFC5905&lt;/a&gt;]) 또는 유사한 프로토콜을 사용하여 시계를 협정 세계시로 동기화합니다. request_time 저장된 응답을 생성 한 요청이있을 때 호스트에서 클록의 현재 값. response_time 응답을 받았을 때 호스트에서 클럭의 현재 값. 응답 시간은 완전히 독립적 인 두 가지 방법으로 계산할 수 있습니다. 1. 로컬 시계가 원래 서버의 시계와 합리적으로 동기화 된 경우 &quot;apparent_age&quot;: response_time에서 date_value를 뺀 값입니다. 결과가 음수이면 결과는 0으로 대체됩니다. 2. 응답 경로를 따라 모든 캐시가 HTTP / 1.1을 구현하는 경우 &quot;corrected_age_value&quot;.캐시는 응답이 수신 된 시간이 아니라 요청이 시작된 시간을 기준으로이 값을 해석해야합니다. obvious_age = max (0, response_time-날짜 _ 값); response_delay = 응답 시간-요청 시간; corrected_age_value = 연령 _ 값 + 응답 _ 지연; 이들은 corrected_initial_age = max (apparent_age, corrected_age_value); 캐시가 Age 헤더 필드의 값을 확신하지 않는 한 (예를 들어, Via 헤더 필드에 HTTP / 1.0 홉이 없기 때문에),이 경우 corrected_age_value가 corrected_initial_age로 사용될 수 있습니다. 저장된 응답의 origin_age는 저장된 응답이 원래 서버에 의해 마지막으로 유효성 검증 된 이후의 시간을 초 단위로 추가하여 계산할 수 있습니다 (초 단위).resident_time = 현재-response_time; current_age = corrected_initial_age + 상주 _ 시간;</target>
        </trans-unit>
        <trans-unit id="fdef55523947f477881a984ce9c7d78915e916d7" translate="yes" xml:space="preserve">
          <source>The Age response-header field conveys the sender's estimate of the
      amount of time since the response (or its revalidation) was
      generated at the origin server. A cached response is &quot;fresh&quot; if
      its age does not exceed its freshness lifetime. Age values are
      calculated as specified in &lt;a href=&quot;#section-13.2.3&quot;&gt;section 13.2.3&lt;/a&gt;.

           Age = &quot;Age&quot; &quot;:&quot; age-value
           age-value = delta-seconds

      Age values are non-negative decimal integers, representing time in
      seconds.

      If a cache receives a value larger than the largest positive
      integer it can represent, or if any of its age calculations
      overflows, it MUST transmit an Age header with a value of
      2147483648 (2^31). An HTTP/1.1 server that includes a cache MUST
      include an Age header field in every response generated from its
      own cache. Caches SHOULD use an arithmetic type of at least 31
      bits of range.</source>
          <target state="translated">Age response-header (연령 응답 헤더) 필드는 발신자 서버에서 응답 (또는 재확인)이 생성 된 이후 발신자의 예상 시간을 전달합니다. 캐시 된 응답의 수명이 신선도 수명을 초과하지 않으면 &quot;신선한&quot;상태입니다. 연령 값은 &lt;a href=&quot;#section-13.2.3&quot;&gt;섹션 13.2.3에&lt;/a&gt; 지정된대로 계산됩니다.. Age = &quot;Age&quot; &quot;:&quot;age-value age-value = delta-seconds Age 값은 음수가 아닌 10 진수 정수로 시간을 초 단위로 나타냅니다. 캐시가 나타낼 수있는 최대 양의 정수보다 큰 값을 받거나 에이지 계산 중 오버플로가 발생하면 값이 2147483648 (2 ^ 31) 인 Age 헤더를 전송해야합니다. 캐시를 포함하는 HTTP / 1.1 서버는 자체 캐시에서 생성 된 모든 응답에 Age 헤더 필드를 포함해야합니다. 캐시는 적어도 31 비트 범위의 산술 형식을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d37b3ed1a7bd53de7b0c73a5ae6518e139d2ed9d" translate="yes" xml:space="preserve">
          <source>The Allow entity-header field lists the set of methods supported
      by the resource identified by the Request-URI. The purpose of this
      field is strictly to inform the recipient of valid methods
      associated with the resource. An Allow header field MUST be
      present in a 405 (Method Not Allowed) response.

          Allow   = &quot;Allow&quot; &quot;:&quot; #Method

      Example of use:

          Allow: GET, HEAD, PUT

      This field cannot prevent a client from trying other methods.
      However, the indications given by the Allow header field value
      SHOULD be followed. The actual set of allowed methods is defined
      by the origin server at the time of each request.

      The Allow header field MAY be provided with a PUT request to
      recommend the methods to be supported by the new or modified
      resource. The server is not required to support these methods and
      SHOULD include an Allow header in the response giving the actual
      supported methods. 

      A proxy MUST NOT modify the Allow header field even if it does not
      understand all the methods specified, since the user agent might
      have other means of communicating with the origin server.</source>
          <target state="translated">엔티티 헤더 허용 필드는 Request-URI에 의해 식별 된 자원에 의해 지원되는 메소드 세트를 나열합니다. 이 필드의 목적은 수신자에게 리소스와 관련된 유효한 방법을 알려주는 것입니다. 헤더 허용 필드는 반드시 405 (Method Not Allowed) 응답에 있어야합니다. Allow = &quot;Allow&quot; &quot;:&quot;#Method 사용 예 : Allow : GET, HEAD, PUT이 필드는 클라이언트가 다른 방법을 시도하지 못하게 할 수 없습니다. 그러나 Allow header (허용 헤더) 필드 값으로 표시되는 지시를 따라야합니다 (SHOULD). 허용되는 실제 메소드 세트는 각 요청시 오리진 서버에 의해 정의됩니다. 헤더 허용 필드에는 PUT 요청이 제공되어 새로운 또는 수정 된 자원이 지원할 방법을 권장 할 수 있습니다.서버는 이러한 방법을 지원할 필요가 없으며 실제 지원되는 방법을 제공하는 응답에 Allow 헤더를 포함해야합니다. 사용자 에이전트는 다른 방법으로 오리진 서버와 통신 할 수 있으므로 프록시는 지정된 모든 메소드를 이해하지 못하더라도 헤더 허용 필드를 수정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="13a4fef575d5af4e237a81912fe641b20dff803a" translate="yes" xml:space="preserve">
          <source>The Atom Protocol imposes few restrictions on the actions of servers.
   Unless a constraint is specified here, servers can be expected to
   vary in behavior, in particular around the manipulation of Atom
   Entries sent by clients.  For example, although this specification
   only defines the expected behavior of Collections with respect to GET
   and POST, this does not imply that PUT, DELETE, PROPPATCH, and others
   are forbidden on Collection Resources -- only that this specification
   does not define what the server's response would be to those methods.
   Similarly, while some HTTP status codes are mentioned explicitly,
   clients ought to be prepared to handle any status code from a server.
   Servers can choose to accept, reject, delay, moderate, censor,
   reformat, translate, relocate, or re-categorize the content submitted
   to them.  Only some of these choices are immediately relayed back to
   the client in responses to client requests; other choices may only
   become apparent later, in the feed or published entries.  The same
   series of requests to two different publishing sites can result in a
   different series of HTTP responses, different resulting feeds, or
   different entry contents.

   As a result, client software has to be written flexibly to accept
   what the server decides are the results of its submissions.  Any
   server response or server content modification not explicitly
   forbidden by this specification or HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] is therefore
   allowed.</source>
          <target state="translated">Atom 프로토콜은 서버 작업에 거의 제한이 없습니다. 여기에 제약 조건을 지정하지 않으면 서버는 특히 클라이언트가 보낸 Atom 항목 조작과 관련하여 동작이 달라질 수 있습니다. 예를 들어,이 스펙은 GET 및 POST와 관련하여 Collections의 예상되는 동작 만 정의하지만 PUT, DELETE, PROPPATCH 및 기타는 콜렉션 자원에서 금지됨을 의미하지는 않습니다.이 스펙은 서버의 내용을 정의하지 않습니다. 그 방법에 대한 답변이 될 것입니다. 마찬가지로 일부 HTTP 상태 코드가 명시 적으로 언급되어 있지만 클라이언트는 서버의 모든 상태 코드를 처리 할 수 ​​있도록 준비해야합니다. 서버는 수락, 거부, 지연, 보통, 검열, 재 포맷, 번역, 재배치,제출 된 컨텐츠를 다시 분류하십시오. 이러한 선택 중 일부만이 클라이언트 요청에 대한 응답으로 즉시 클라이언트에게 다시 중계됩니다. 다른 선택은 피드 또는 게시 된 항목에서 나중에 분명해질 수 있습니다. 두 개의 서로 다른 게시 사이트에 대한 동일한 일련의 요청으로 인해 서로 다른 일련의 HTTP 응답, 다른 결과 피드 또는 다른 항목 내용이 발생할 수 있습니다. 결과적으로 클라이언트 소프트웨어는 서버가 제출 한 결과를 결정하기 위해 유연하게 작성해야합니다. 이 사양 또는 HTTP에서 명시 적으로 금지하지 않은 모든 서버 응답 또는 서버 컨텐츠 수정 [피드 또는 게시 된 항목에서. 두 개의 서로 다른 게시 사이트에 대한 동일한 일련의 요청으로 인해 서로 다른 일련의 HTTP 응답, 다른 결과 피드 또는 다른 항목 내용이 발생할 수 있습니다. 결과적으로 클라이언트 소프트웨어는 서버가 제출 한 결과를 결정하기 위해 유연하게 작성해야합니다. 이 사양 또는 HTTP에서 명시 적으로 금지하지 않은 모든 서버 응답 또는 서버 컨텐츠 수정 [피드 또는 게시 된 항목에서. 두 개의 서로 다른 게시 사이트에 대한 동일한 일련의 요청으로 인해 서로 다른 일련의 HTTP 응답, 다른 결과 피드 또는 다른 항목 내용이 발생할 수 있습니다. 결과적으로 클라이언트 소프트웨어는 서버가 제출 한 결과를 결정하기 위해 유연하게 작성해야합니다. 이 사양 또는 HTTP에서 명시 적으로 금지하지 않은 모든 서버 응답 또는 서버 컨텐츠 수정 [이 사양 또는 HTTP에서 명시 적으로 금지하지 않은 모든 서버 응답 또는 서버 컨텐츠 수정 [이 사양 또는 HTTP에서 명시 적으로 금지하지 않은 모든 서버 응답 또는 서버 컨텐츠 수정 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;&lt;/a&gt;따라서 RFC2616 ]이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3007c47f9b138e0499c5f1a7d9a65013178447c8" translate="yes" xml:space="preserve">
          <source>The Atom Protocol specifies operations for publishing and editing
   Resources using HTTP.  It uses Atom-formatted representations to
   describe the state and metadata of those Resources.  It defines how
   Collections of Resources can be organized, and it specifies formats
   to support their discovery, grouping and categorization.</source>
          <target state="translated">Atom 프로토콜은 HTTP를 사용하여 자원을 공개하고 편집하기위한 조작을 지정합니다. Atom 형식의 표현을 사용하여 해당 자원의 상태 및 메타 데이터를 설명합니다. 리소스 모음을 구성하는 방법을 정의하고 검색, 그룹화 및 분류를 지원하는 형식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3a69850b360c5d4d12134d47ffb0f4087be9cb1a" translate="yes" xml:space="preserve">
          <source>The Atom Protocol uses the response status codes defined in HTTP to
   indicate the success or failure of an operation.  Consult the HTTP
   specification [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] for detailed definitions of each status code.

   Implementers are asked to note that according to the HTTP
   specification, HTTP 4xx and 5xx response entities SHOULD include a
   human-readable explanation of the error.</source>
          <target state="translated">Atom 프로토콜은 HTTP에 정의 된 응답 상태 코드를 사용하여 작업의 성공 또는 실패를 나타냅니다. 각 상태 코드에 대한 자세한 정의 는 HTTP 사양 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]을 참조하십시오 . 구현자는 HTTP 사양에 따라 HTTP 4xx 및 5xx 응답 엔터티에는 사람이 읽을 수있는 오류에 대한 설명이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="169d7cc9960872ff8dd439fd04a8242bd3b29ed5" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol</source>
          <target state="translated">원자 출판 프로토콜</target>
        </trans-unit>
        <trans-unit id="aa8edeb1773be5498439f67a0412dde5980a08ac" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is an application-level protocol for
   publishing and editing Web Resources using HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] and XML 1.0
   [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].  The protocol supports the creation of Web Resources and
   provides facilities for:

   o  Collections: Sets of Resources, which can be retrieved in whole or
      in part.

   o  Services: Discovery and description of Collections.

   o  Editing: Creating, editing, and deleting Resources.

   The Atom Publishing Protocol is different from many contemporary
   protocols in that the server is given wide latitude in processing
   requests from clients.  See &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; for more details.</source>
          <target state="translated">Atom Publishing Protocol은 HTTP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] 및 XML 1.0 [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ]을 사용하여 웹 자원을 공개하고 편집하기위한 애플리케이션 레벨 프로토콜입니다 . 이 프로토콜은 웹 리소스 생성을 지원하고 다음을위한 기능을 제공합니다. o 컬렉션 : 전체 또는 일부를 검색 할 수있는 리소스 집합. o 서비스 : 컬렉션 검색 및 설명. o 편집 : 리소스 생성, 편집 및 삭제. Atom Publishing Protocol은 서버가 클라이언트의 요청을 처리하는 데 광범위하게 제공된다는 점에서 많은 최신 프로토콜과 다릅니다. 자세한 내용 &lt;a href=&quot;#section-4.4&quot;&gt;은 4.4 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="091cad87f70ba141ab92f1e05e1c2c4c7b6a0753" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is based on HTTP and thus subject to the
   security considerations found in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-15&quot;&gt;Section&amp;nbsp;15 of [RFC2616]&lt;/a&gt;.

   The threats listed in this section apply to many protocols that run
   under HTTP.  The Atompub Working Group decided that the protection
   afforded by running authenticated HTTP under TLS (as described in
   &lt;a href=&quot;#section-14&quot;&gt;Section 14&lt;/a&gt;) was sufficient to mitigate many of the problems presented
   by the attacks listed in this section.</source>
          <target state="translated">Atom Publishing Protocol은 HTTP를 기반으로하므로 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-15&quot;&gt;[RFC2616]의 섹션 15에&lt;/a&gt; 있는 보안 고려 사항이 적용됩니다 . 이 섹션에 나열된 위협은 HTTP에서 실행되는 많은 프로토콜에 적용됩니다. Atompub 실무 그룹은 TLS에서 인증 된 HTTP를 실행함으로써 ( &lt;a href=&quot;#section-14&quot;&gt;14 장에&lt;/a&gt; 설명 된 ) 보호가이 섹션에 나열된 공격으로 인한 많은 문제를 완화하기에 충분하다고 결정했습니다.</target>
        </trans-unit>
        <trans-unit id="5d125ad81e218339dcf924271a55cccc89e9d5f5" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol is based on HTTP.  Authentication
   requirements for HTTP are covered in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-11&quot;&gt;Section&amp;nbsp;11 of [RFC2616]&lt;/a&gt;.

   The use of authentication mechanisms to prevent POSTing or editing by
   unknown or unauthorized clients is RECOMMENDED but not required.
   When authentication is not used, clients and servers are vulnerable
   to trivial spoofing, denial-of-service, and defacement attacks.
   However, in some contexts, this is an acceptable risk.

   The type of authentication deployed is a local decision made by the
   server operator.  Clients are likely to face authentication schemes
   that vary across server deployments.  At a minimum, client and server
   implementations MUST be capable of being configured to use HTTP Basic
   Authentication [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;] in conjunction with a connection made with
   TLS 1.0 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC2246&lt;/a&gt;] or a subsequent standards-track version of TLS
   (such as [&lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC4346&lt;/a&gt;]), supporting the conventions for using HTTP over
   TLS described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;]. 

   The choice of authentication mechanism will impact interoperability.
   The minimum level of security referenced above (Basic Authentication
   with TLS) is considered good practice for Internet applications at
   the time of publication of this specification and sufficient for
   establishing a baseline for interoperability.  Implementers are
   encouraged to investigate and use alternative mechanisms regarded as
   equivalently good or better at the time of deployment.  It is
   RECOMMENDED that clients be implemented in such a way that new
   authentication schemes can be deployed.

   Because this protocol uses HTTP response status codes as the primary
   means of reporting the result of a request, servers are advised to
   respond to unauthorized or unauthenticated requests using an
   appropriate 4xx HTTP response code (e.g., 401 &quot;Unauthorized&quot; or 403
   &quot;Forbidden&quot;) in accordance with [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;].</source>
          <target state="translated">Atom Publishing Protocol은 HTTP를 기반으로합니다. HTTP에 대한 인증 요구 사항 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-11&quot;&gt;은 [RFC2616]의 섹션 11&lt;/a&gt; 에서 다룹니다 . 알 수 없거나 권한이없는 클라이언트의 POST 또는 편집을 방지하기 위해 인증 메커니즘을 사용하는 것이 권장되지만 필수는 아닙니다. 인증을 사용하지 않으면 클라이언트와 서버는 사소한 스푸핑, 서비스 거부 및 손상 공격에 취약합니다. 그러나 일부 상황에서는 이것이 허용 가능한 위험입니다. 배포 된 인증 유형은 서버 운영자가 내린 로컬 결정입니다. 클라이언트는 서버 배포마다 다른 인증 체계에 직면 할 수 있습니다. 최소한 클라이언트 및 서버 구현은 HTTP 기본 인증을 사용하도록 구성 할 수 있어야합니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt; RFC2617&lt;/a&gt;]를 TLS 1.0 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC2246&lt;/a&gt; ] 또는 TLS 의 후속 표준 트랙 버전 (예 : [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC4346&lt;/a&gt; ])과 연결하여 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818에&lt;/a&gt; 설명 된 TLS를 통한 HTTP 사용 규칙을 지원함]. 인증 메커니즘을 선택하면 상호 운용성에 영향을줍니다. 위에서 언급 한 최소 보안 수준 (TLS를 사용한 기본 인증)은이 사양을 게시 할 때 인터넷 응용 프로그램에 대한 모범 사례로 간주되며 상호 운용성을위한 기준을 설정하기에 충분합니다. 구현 자들은 배치 시점에 동등하거나 양호하다고 간주되는 대체 메커니즘을 조사하고 사용하도록 권장됩니다. 새로운 인증 체계를 배포 할 수있는 방식으로 클라이언트를 구현하는 것이 좋습니다. 이 프로토콜은 요청 결과를보고하는 주요 수단으로 HTTP 응답 상태 코드를 사용하므로 서버는 적절한 4xx HTTP 응답 코드 (예 :401 &quot;무단&quot;또는 403 &quot;금지&quot;)에 따라 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="b27e5a48d6a66251fa9d4883723e1c6d86c30969" translate="yes" xml:space="preserve">
          <source>The Atom Publishing Protocol uses HTTP methods to author Member
   Resources as follows:

   o  GET is used to retrieve a representation of a known Resource.

   o  POST is used to create a new, dynamically named, Resource.  When
      the client submits non-Atom-Entry representations to a Collection
      for creation, two Resources are always created -- a Media Entry
      for the requested Resource, and a Media Link Entry for metadata
      about the Resource that will appear in the Collection.

   o  PUT is used to edit a known Resource.  It is not used for Resource
      creation.

   o  DELETE is used to remove a known Resource.

   The Atom Protocol only covers the creating, editing, and deleting of
   Entry and Media Resources.  Other Resources could be created, edited,
   and deleted as the result of manipulating a Collection, but the
   number of those Resources, their media types, and effects of Atom
   Protocol operations on them are outside the scope of this
   specification. 

   Since all aspects of client-server interaction are defined in terms
   of HTTP, [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] should be consulted for any areas not covered in
   this specification.</source>
          <target state="translated">Atom Publishing Protocol은 HTTP 메소드를 사용하여 다음과 같이 구성원 자원을 작성합니다. o GET은 알려진 자원의 표현을 검색하는 데 사용됩니다. o POST는 동적으로 명명 된 새로운 Resource를 작성하는 데 사용됩니다. 클라이언트가 작성을 위해 비 Atom-Entry 표현을 콜렉션에 제출하면 요청 된 자원에 대한 매체 항목과 콜렉션에 표시 될 자원에 대한 메타 데이터에 대한 매체 링크 항목이라는 두 가지 자원이 항상 작성됩니다. o PUT은 알려진 리소스를 편집하는 데 사용됩니다. 자원 작성에는 사용되지 않습니다. o DELETE는 알려진 자원을 제거하는 데 사용됩니다. Atom 프로토콜은 항목 및 미디어 리소스의 생성, 편집 및 삭제에만 적용됩니다. 컬렉션을 조작 한 결과 다른 리소스를 생성, 편집 및 삭제할 수 있습니다.그러나 이러한 리소스의 수, 미디어 유형 및 Atom 프로토콜 작업의 영향은이 사양의 범위를 벗어납니다. 클라이언트-서버 상호 작용의 모든 측면이 HTTP 측면에서 정의되므로 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;&lt;/a&gt;이 사양에서 다루지 않은 영역에 대해서는 RFC2616 ]을 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="42d277116045b96cf12bbfe45ba81c76ae3ef5f2" translate="yes" xml:space="preserve">
          <source>The Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] defines the &quot;application/
   atom+xml&quot; media type to identify both Atom Feed and Atom Entry
   Documents.  Implementation experience has demonstrated that Atom Feed
   and Entry Documents can have different processing models and that
   there are situations where they need to be differentiated.  This
   specification defines a &quot;type&quot; parameter used to differentiate the
   two types of Atom documents.</source>
          <target state="translated">Atom Syndication Format [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]은 Atom Feed 및 Atom Entry Documents를 모두 식별하기 위해 &quot;application / atom + xml&quot;매체 유형을 정의합니다. 구현 경험에 따르면 Atom Feed 및 Entry 문서는 다른 처리 모델을 가질 수 있으며 차별화해야 할 상황이 있음을 보여주었습니다. 이 사양은 두 가지 유형의 Atom 문서를 구별하는 데 사용되는 &quot;type&quot;매개 변수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d54dec6d4ad6caa6017041a8dbe37766ea30ecca" translate="yes" xml:space="preserve">
          <source>The CONNECT method can be used to create disproportionate load on an
   proxy, since stream creation is relatively inexpensive when compared
   to the creation and maintenance of a TCP connection.  A proxy might
   also maintain some resources for a TCP connection beyond the closing
   of the stream that carries the CONNECT request, since the outgoing
   TCP connection remains in the TIME_WAIT state.  Therefore, a proxy
   cannot rely on SETTINGS_MAX_CONCURRENT_STREAMS alone to limit the
   resources consumed by CONNECT requests.</source>
          <target state="translated">CONNECT 메서드는 TCP 연결의 생성 및 유지 관리에 비해 스트림 생성이 상대적으로 저렴하기 때문에 프록시에 불균형적인로드를 생성하는 데 사용할 수 있습니다. 프록시는 나가는 TCP 연결이 TIME_WAIT 상태로 유지되기 때문에 CONNECT 요청을 전달하는 스트림이 닫히는 것 이상으로 TCP 연결에 대한 일부 리소스를 유지할 수도 있습니다. 따라서 프록시는 SETTINGS_MAX_CONCURRENT_STREAMS에만 의존하여 CONNECT 요청에 사용되는 리소스를 제한 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6a14656993634aa0a74177de15aa55441d492abb" translate="yes" xml:space="preserve">
          <source>The CONNECT method requests that the recipient establish a tunnel to
   the destination origin server identified by the request-target and,
   if successful, thereafter restrict its behavior to blind forwarding
   of packets, in both directions, until the tunnel is closed.  Tunnels
   are commonly used to create an end-to-end virtual connection, through
   one or more proxies, which can then be secured using TLS (Transport
   Layer Security, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]).

   CONNECT is intended only for use in requests to a proxy.  An origin
   server that receives a CONNECT request for itself MAY respond with a
   2xx (Successful) status code to indicate that a connection is
   established.  However, most origin servers do not implement CONNECT.

   A client sending a CONNECT request MUST send the authority form of
   request-target (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of [RFC7230]&lt;/a&gt;); i.e., the request-target
   consists of only the host name and port number of the tunnel
   destination, separated by a colon.  For example,

     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80

   The recipient proxy can establish a tunnel either by directly
   connecting to the request-target or, if configured to use another
   proxy, by forwarding the CONNECT request to the next inbound proxy.
   Any 2xx (Successful) response indicates that the sender (and all 

   inbound proxies) will switch to tunnel mode immediately after the
   blank line that concludes the successful response's header section;
   data received after that blank line is from the server identified by
   the request-target.  Any response other than a successful response
   indicates that the tunnel has not yet been formed and that the
   connection remains governed by HTTP.

   A tunnel is closed when a tunnel intermediary detects that either
   side has closed its connection: the intermediary MUST attempt to send
   any outstanding data that came from the closed side to the other
   side, close both connections, and then discard any remaining data
   left undelivered.

   Proxy authentication might be used to establish the authority to
   create a tunnel.  For example,

     CONNECT server.example.com:80 HTTP/1.1
     Host: server.example.com:80
     Proxy-Authorization: basic aGVsbG86d29ybGQ=

   There are significant risks in establishing a tunnel to arbitrary
   servers, particularly when the destination is a well-known or
   reserved TCP port that is not intended for Web traffic.  For example,
   a CONNECT to a request-target of &quot;example.com:25&quot; would suggest that
   the proxy connect to the reserved port for SMTP traffic; if allowed,
   that could trick the proxy into relaying spam email.  Proxies that
   support CONNECT SHOULD restrict its use to a limited set of known
   ports or a configurable whitelist of safe request targets.

   A server MUST NOT send any Transfer-Encoding or Content-Length header
   fields in a 2xx (Successful) response to CONNECT.  A client MUST
   ignore any Content-Length or Transfer-Encoding header fields received
   in a successful response to CONNECT.

   A payload within a CONNECT request message has no defined semantics;
   sending a payload body on a CONNECT request might cause some existing
   implementations to reject the request.

   Responses to the CONNECT method are not cacheable.</source>
          <target state="translated">CONNECT 메소드는 수신자가 요청 대상에 의해 식별 된 목적지 오리진 서버에 터널을 설정하도록 요청한 후, 성공하면 터널이 닫힐 때까지 양방향으로 패킷의 블라인드 전달으로 동작을 제한합니다. 터널은 일반적으로 하나 이상의 프록시를 통해 종단 간 가상 연결을 만드는 데 사용되며 TLS (Transport Layer Security, [ 사용하여 보호 할 수 있습니다&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt; RFC5246)를&lt;/a&gt;]). CONNECT는 프록시 요청에만 사용됩니다. 자체 CONNECT 요청을 수신 한 오리진 서버는 2xx (성공) 상태 코드로 응답하여 연결이 설정되었음을 표시 할 수 있습니다. 그러나 대부분의 오리진 서버는 CONNECT를 구현하지 않습니다. CONNECT 요청을 보내는 클라이언트는 반드시 요청 대상의 권한 양식을 보내야합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230]의 섹션 5.3&lt;/a&gt;); 즉, 요청 대상은 터널 대상의 호스트 이름과 포트 번호로 구성되며 콜론으로 구분됩니다. 예 : CONNECT server.example.com:80 HTTP / 1.1 호스트 : server.example.com:80 수신자 프록시는 요청 대상에 직접 연결하거나 다른 프록시를 사용하도록 구성된 경우 전달을 통해 터널을 설정할 수 있습니다. 다음 인바운드 프록시에 대한 CONNECT 요청 2xx (성공) 응답은 발신자 (및 모든 인바운드 프록시)가 빈 응답 행 바로 다음에 성공적인 응답 헤더 섹션을 마치는 즉시 터널 모드로 전환됨을 나타냅니다. 해당 빈 줄 이후에 수신 된 데이터는 요청 대상으로 식별 된 서버에서 온 것입니다.성공적인 응답 이외의 응답은 터널이 아직 형성되지 않았으며 연결이 HTTP에 의해 관리됨을 나타냅니다. 터널 중개자가 어느 쪽의 연결이 끊 겼음을 감지하면 터널이 닫힙니다. 중개자는 반드시 닫힌 쪽에서 다른쪽으로 온 미해결 데이터를 전송하고 두 연결을 모두 닫은 다음 배달되지 않은 나머지 데이터는 모두 폐기해야합니다. 프록시 인증을 사용하여 터널을 만들 수있는 권한을 설정할 수 있습니다. 예를 들면 다음과 같습니다. CONNECT server.example.com:80 HTTP / 1.1 호스트 : server.example.com:80 프록시 인증 : basic aGVsbG86d29ybGQ = 임의의 서버로 터널을 설정하는 데 상당한 위험이 있습니다.특히 대상이 웹 트래픽 용이 아닌 잘 알려져 있거나 예약 된 TCP 포트 인 경우. 예를 들어 &quot;example.com:25&quot;의 요청 대상에 연결하려면 프록시가 SMTP 트래픽을 위해 예약 된 포트에 연결해야합니다. 허용되는 경우 프록시를 통해 스팸 전자 메일을 릴레이 할 수 있습니다. CONNECT를 지원하는 프록시는 제한된 알려진 포트 세트 또는 구성 가능한 안전 요청 대상 화이트리스트로 사용을 제한해야합니다. 서버는 2xx (성공) 응답으로 Transfer-Encoding 또는 Content-Length 헤더 필드를 CONNECT에 보내서는 안됩니다. 클라이언트는 CONNECT에 대한 성공적인 응답으로 수신 된 모든 Content-Length 또는 Transfer-Encoding 헤더 필드를 무시해야합니다. CONNECT 요청 메시지 내의 페이로드에는 정의 된 의미가 없습니다.CONNECT 요청에서 페이로드 본문을 전송하면 일부 기존 구현에서 요청을 거부 할 수 있습니다. CONNECT 메소드에 대한 응답은 캐시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="44e2ab9943f4c0dd2becd2a23e49a2cb8c91d927" translate="yes" xml:space="preserve">
          <source>The CONTINUATION frame (type=0x9) is used to continue a sequence of
   header block fragments (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).  Any number of CONTINUATION
   frames can be sent, as long as the preceding frame is on the same
   stream and is a HEADERS, PUSH_PROMISE, or CONTINUATION frame without
   the END_HEADERS flag set.

    +---------------------------------------------------------------+
    |                   Header Block Fragment (*)                 
    +---------------------------------------------------------------+

                   Figure 15: CONTINUATION Frame Payload

   The CONTINUATION frame payload contains a header block fragment
   (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;). 

   The CONTINUATION frame defines the following flag:

   END_HEADERS (0x4):  When set, bit 2 indicates that this frame ends a
      header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).

      If the END_HEADERS bit is not set, this frame MUST be followed by
      another CONTINUATION frame.  A receiver MUST treat the receipt of
      any other type of frame or a frame on a different stream as a
      connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   The CONTINUATION frame changes the connection state as defined in
   &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;.

   CONTINUATION frames MUST be associated with a stream.  If a
   CONTINUATION frame is received whose stream identifier field is 0x0,
   the recipient MUST respond with a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of
   type PROTOCOL_ERROR.

   A CONTINUATION frame MUST be preceded by a HEADERS, PUSH_PROMISE or
   CONTINUATION frame without the END_HEADERS flag set.  A recipient
   that observes violation of this rule MUST respond with a connection
   error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.</source>
          <target state="translated">CONTINUATION 프레임 (유형 = 0x9)은 헤더 블록 조각의 시퀀스를 계속하는 데 사용됩니다 ( &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt; ). 이전 프레임이 동일한 스트림에 있고 END_HEADERS 플래그가 설정되지 않은 HEADERS, PUSH_PROMISE 또는 CONTINUATION 프레임이면 원하는 수의 CONTINUATION 프레임을 전송할 수 있습니다. + ------------------------------------------------- -------------- + | 헤더 블록 조각 (*) + ------------------------------------------- -------------------- + 그림 15 : CONTINUATION 프레임 페이로드 CONTINUATION 프레임 페이로드는 헤더 블록 조각을 포함합니다 ( &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt; ). CONTINUATION 프레임은 다음 플래그를 정의합니다. END_HEADERS (0x4) : 설정되면 비트 2는이 프레임이 헤더 블록을 종료 함을 나타냅니다 ( &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt;). END_HEADERS 비트가 설정되지 않은 경우이 프레임 뒤에 다른 CONTINUATION 프레임이 와야합니다. 수신기는 다른 유형의 프레임 또는 다른 스트림의 프레임 수신을 PROTOCOL_ERROR 유형 의 연결 오류 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt; )로 취급해야합니다. CONTINUATION 프레임 &lt;a href=&quot;#section-4.3&quot;&gt;은 4.3 절에&lt;/a&gt; 정의 된대로 연결 상태를 변경합니다 . CONTINUATION 프레임은 스트림과 연결되어야합니다. 스트림 식별자 필드가 0x0 인 CONTINUATION 프레임이 수신되면 수신자 는 PROTOCOL_ERROR 유형 의 연결 오류 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt; )로 응답해야 합니다. CONTINUATION 프레임 앞에는 END_HEADERS 플래그가 설정되지 않은 HEADERS, PUSH_PROMISE 또는 CONTINUATION 프레임이 와야합니다. 이 규칙의 위반을 관찰 한 수신자는 연결 오류 (&lt;a href=&quot;#section-5.4.1&quot;&gt;&lt;/a&gt;PROTOCOL_ERROR 유형의 섹션 5.4.1 ).</target>
        </trans-unit>
        <trans-unit id="5cc173ef45538302331fa209f0189866cab3850f" translate="yes" xml:space="preserve">
          <source>The COPY method creates a duplicate of the source resource identified
   by the Request-URI, in the destination resource identified by the URI
   in the Destination header.  The Destination header MUST be present.
   The exact behavior of the COPY method depends on the type of the
   source resource.

   All WebDAV-compliant resources MUST support the COPY method.
   However, support for the COPY method does not guarantee the ability
   to copy a resource.  For example, separate programs may control
   resources on the same server.  As a result, it may not be possible to
   copy a resource to a location that appears to be on the same server.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">COPY 메소드는 Destination 헤더의 URI로 식별 된 대상 자원에서 Request-URI로 식별 된 소스 자원의 복제본을 작성합니다. 대상 헤더가 있어야합니다. COPY 메소드의 정확한 동작은 소스 자원의 유형에 따라 다릅니다. 모든 WebDAV 호환 리소스는 반드시 COPY 방법을 지원해야합니다. 그러나 COPY 메소드를 지원한다고해서 자원을 복사하는 기능이 보장되지는 않습니다. 예를 들어 별도의 프로그램이 같은 서버의 리소스를 제어 할 수 있습니다. 결과적으로 동일한 서버에있는 위치로 리소스를 복사하지 못할 수 있습니다. 이 방법은 dem 등이지만 안전하지는 않습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]의 9.1 절&lt;/a&gt; 참조 ). 이 방법에 대한 응답은 캐시해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="14111f3c8a7b4d6556d104b92402303159cbab91" translate="yes" xml:space="preserve">
          <source>The COPY method on a collection without a Depth header MUST act as if
   a Depth header with value &quot;infinity&quot; was included.  A client may
   submit a Depth header on a COPY on a collection with a value of &quot;0&quot;
   or &quot;infinity&quot;.  Servers MUST support the &quot;0&quot; and &quot;infinity&quot; Depth
   header behaviors on WebDAV-compliant resources.

   An infinite-depth COPY instructs that the collection resource
   identified by the Request-URI is to be copied to the location
   identified by the URI in the Destination header, and all its internal
   member resources are to be copied to a location relative to it,
   recursively through all levels of the collection hierarchy.  Note
   that an infinite-depth COPY of /A/ into /A/B/ could lead to infinite
   recursion if not handled correctly.

   A COPY of &quot;Depth: 0&quot; only instructs that the collection and its
   properties, but not resources identified by its internal member URLs,
   are to be copied.

   Any headers included with a COPY MUST be applied in processing every
   resource to be copied with the exception of the Destination header.

   The Destination header only specifies the destination URI for the
   Request-URI.  When applied to members of the collection identified by
   the Request-URI, the value of Destination is to be modified to
   reflect the current location in the hierarchy.  So, if the Request-
   URI is /a/ with Host header value http://example.com/ and the 

   Destination is http://example.com/b/, then when
   http://example.com/a/c/d is processed, it must use a Destination of
   http://example.com/b/c/d.

   When the COPY method has completed processing, it MUST have created a
   consistent URL namespace at the destination (see &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt; for the
   definition of namespace consistency).  However, if an error occurs
   while copying an internal collection, the server MUST NOT copy any
   resources identified by members of this collection (i.e., the server
   must skip this subtree), as this would create an inconsistent
   namespace.  After detecting an error, the COPY operation SHOULD try
   to finish as much of the original copy operation as possible (i.e.,
   the server should still attempt to copy other subtrees and their
   members that are not descendants of an error-causing collection).

   So, for example, if an infinite-depth copy operation is performed on
   collection /a/, which contains collections /a/b/ and /a/c/, and an
   error occurs copying /a/b/, an attempt should still be made to copy
   /a/c/.  Similarly, after encountering an error copying a non-
   collection resource as part of an infinite-depth copy, the server
   SHOULD try to finish as much of the original copy operation as
   possible.

   If an error in executing the COPY method occurs with a resource other
   than the resource identified in the Request-URI, then the response
   MUST be a 207 (Multi-Status), and the URL of the resource causing the
   failure MUST appear with the specific error.

   The 424 (Failed Dependency) status code SHOULD NOT be returned in the
   207 (Multi-Status) response from a COPY method.  These responses can
   be safely omitted because the client will know that the progeny of a
   resource could not be copied when the client receives an error for
   the parent.  Additionally, 201 (Created)/204 (No Content) status
   codes SHOULD NOT be returned as values in 207 (Multi-Status)
   responses from COPY methods.  They, too, can be safely omitted
   because they are the default success codes.</source>
          <target state="translated">Depth 헤더가없는 컬렉션의 COPY 메소드는 &quot;infinity&quot;값을 가진 Depth 헤더가 포함 된 것처럼 작동해야합니다. 클라이언트는 값이 &quot;0&quot;또는 &quot;infinity&quot;인 컬렉션의 COPY에 Depth 헤더를 제출할 수 있습니다. 서버는 WebDAV 호환 리소스에서 &quot;0&quot;및 &quot;무한대&quot;깊이 헤더 동작을 지원해야합니다. 무한 깊이 COPY는 Request-URI로 식별 된 콜렉션 자원이 Destination 헤더의 URI로 식별 된 위치로 복사되고 모든 내부 구성원 자원이 재귀 적으로 상대 위치로 복사되도록 지시합니다. 컬렉션 계층의 모든 수준을 통해. / A /의 / A / B / 로의 무한 깊이 복사는 올바르게 처리되지 않으면 무한 재귀로 이어질 수 있습니다. &quot;깊이의 사본 :0 &quot;은 내부 구성원 URL로 식별 된 자원이 아닌 콜렉션 및 해당 특성을 복사하도록 지시합니다. COPY에 포함 된 헤더는 대상 헤더를 제외하고 복사 할 모든 자원을 처리하는 데 적용되어야합니다. Destination 헤더는 Request-URI의 대상 URI 만 지정하며, Request-URI로 식별 된 콜렉션의 멤버에 적용되면 계층 구조의 현재 위치를 반영하도록 Destination 값이 수정됩니다. -URI는 호스트 헤더 값이 http://example.com/ 인 / a /이고 대상은 http://example.com/b/이며, http://example.com/a/c/d가 처리 될 때 COPY 메소드 처리가 완료되면 http://example.com/b/c/d의 대상을 사용해야합니다.대상에서 일관된 URL 네임 스페이스를 작성해야합니다 (참조&lt;a href=&quot;#section-5.1&quot;&gt;섹션 5.1&lt;/a&gt;네임 스페이스 일관성의 정의를 위해). 그러나 내부 컬렉션을 복사하는 동안 오류가 발생하면 서버는이 컬렉션의 구성원이 식별 한 모든 리소스를 복사해서는 안됩니다 (즉, 서버는이 하위 트리를 건너 뛰어야합니다). 오류를 감지 한 후 COPY 작업은 가능한 한 많은 원본 복사 작업을 완료해야합니다 (즉, 서버는 오류를 일으키는 컬렉션의 하위 항목이 아닌 다른 하위 트리 및 해당 구성원을 계속 복사해야 함). 예를 들어, / a / b / 및 / a / c / 콜렉션을 포함하는 / a / 콜렉션에서 무한 깊이 복사 조작이 수행되고 / a / b /를 복사하는 중에 오류가 발생하면 시도는 계속되어야합니다. / a / c /를 복사하도록 만드십시오. 비슷하게,무한 깊이 복사의 일부로 비 수집 자원을 복사하는 중 오류가 발생하면 서버는 가능한 한 많은 원본 복사 작업을 완료해야합니다. COPY 메소드 실행 오류가 Request-URI에서 식별 된 자원 이외의 자원에서 발생하는 경우 응답은 반드시 207 (Multi-Status)이어야하며, 실패를 야기한 자원의 URL은 반드시 오류. 424 (실패 종속성) 상태 코드는 COPY 메소드의 207 (다중 상태) 응답으로 리턴되지 않아야합니다. 클라이언트는 부모에 대한 오류를 수신 할 때 자원의 자손을 복사 할 수 없다는 것을 클라이언트가 알기 때문에 이러한 응답을 안전하게 생략 할 수 있습니다. 또한201 (작성 됨) / 204 (콘텐츠 없음) 상태 코드는 COPY 메소드의 207 (다중 상태) 응답에서 값으로 반환되지 않아야합니다. 또한 기본 성공 코드이므로 안전하게 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ccb4eecacf9e00ad51b2aefeb841f59a202bd7d" translate="yes" xml:space="preserve">
          <source>The CORS mechanism supports secure cross-origin requests and data transfers between browsers and servers. Modern browsers use CORS in APIs such as &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; to mitigate the risks of cross-origin HTTP requests.</source>
          <target state="translated">CORS 메커니즘은 브라우저와 서버 간의 안전한 교차 출처 요청 및 데이터 전송을 지원합니다. 최신 브라우저는 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; 와 같은 API에서 CORS를 사용 하여 교차 출처 HTTP 요청의 위험을 완화합니다.</target>
        </trans-unit>
        <trans-unit id="fbbf23077eb5623c9faba43d84ac7826f9fbf870" translate="yes" xml:space="preserve">
          <source>The CORS mechanism supports secure cross-origin requests and data transfers between browsers and web servers. Modern browsers use CORS in an API container such as &lt;code&gt;XMLHttpRequest&lt;/code&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; to help mitigate the risks of cross-origin HTTP requests.</source>
          <target state="translated">CORS 메커니즘은 브라우저와 웹 서버 간의 안전한 교차 출처 요청 및 데이터 전송을 지원합니다. 최신 브라우저는 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; 와 같은 API 컨테이너에서 CORS를 사용 하여 원본 간 HTTP 요청의 위험을 완화합니다.</target>
        </trans-unit>
        <trans-unit id="96ee35d668c5e43e29f1dd8cb8ffc05ffe8f756d" translate="yes" xml:space="preserve">
          <source>The CORS protocol originally required that behavior but &lt;a href=&quot;https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2&quot;&gt;was subsequently changed to no longer require it&lt;/a&gt;. However, not all browsers have implemented the change, and so still exhibit the behavior that was originally required.</source>
          <target state="translated">CORS 프로토콜은 원래 해당 동작이 필요했지만 &lt;a href=&quot;https://github.com/whatwg/fetch/commit/0d9a4db8bc02251cc9e391543bb3c1322fb882f2&quot;&gt;더 이상 필요하지 않도록 변경되었습니다&lt;/a&gt; . 그러나 모든 브라우저가 변경 사항을 구현하지는 않았으므로 원래 필요한 동작이 여전히 나타납니다.</target>
        </trans-unit>
        <trans-unit id="90251c7853324d5188765c4d4396bb48f7d83e13" translate="yes" xml:space="preserve">
          <source>The CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive should be used with this header, otherwise this header will be an expensive no-op machine.</source>
          <target state="translated">CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt; 지시문은이 헤더와 함께 사용해야합니다. 그렇지 않으면이 헤더는 값 비싼 운영 체제가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bb80a0a4cc2668fea5fc69f81138adf60314c6bd" translate="yes" xml:space="preserve">
          <source>The CSP mechanism allows multiple policies being specified for a resource, including via the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header, the &lt;a href=&quot;content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header and a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">CSP 메커니즘을 사용하면 &lt;code&gt;Content-Security-Policy&lt;/code&gt; 헤더, &lt;a href=&quot;content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt; 헤더 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 포함하여 리소스에 대해 여러 정책을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3a1440f01ca2c2191b9c319acb6ec56e362606ce" translate="yes" xml:space="preserve">
          <source>The Cache-Control general-header field is used to specify directives
   that MUST be obeyed by all caching mechanisms along the
   request/response chain. The directives specify behavior intended to
   prevent caches from adversely interfering with the request or
   response. These directives typically override the default caching
   algorithms. Cache directives are unidirectional in that the presence
   of a directive in a request does not imply that the same directive is
   to be given in the response.

      Note that HTTP/1.0 caches might not implement Cache-Control and
      might only implement Pragma: no-cache (see &lt;a href=&quot;#section-14.32&quot;&gt;section 14.32&lt;/a&gt;).

   Cache directives MUST be passed through by a proxy or gateway
   application, regardless of their significance to that application,
   since the directives might be applicable to all recipients along the
   request/response chain. It is not possible to specify a cache-
   directive for a specific cache.

    Cache-Control   = &quot;Cache-Control&quot; &quot;:&quot; 1#cache-directive

    cache-directive = cache-request-directive
         | cache-response-directive

    cache-request-directive =
           &quot;no-cache&quot;                          ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-store&quot;                          ; &lt;a href=&quot;#section-14.9.2&quot;&gt;Section 14.9.2&lt;/a&gt;
         | &quot;max-age&quot; &quot;=&quot; delta-seconds         ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;, 14.9.4
         | &quot;max-stale&quot; [ &quot;=&quot; delta-seconds ]   ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;min-fresh&quot; &quot;=&quot; delta-seconds       ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;no-transform&quot;                      ; &lt;a href=&quot;#section-14.9.5&quot;&gt;Section 14.9.5&lt;/a&gt;
         | &quot;only-if-cached&quot;                    ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | cache-extension                     ; &lt;a href=&quot;#section-14.9.6&quot;&gt;Section 14.9.6&lt;/a&gt;

     cache-response-directive =
           &quot;public&quot;                               ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;private&quot; [ &quot;=&quot; &amp;lt;&quot;&amp;gt; 1#field-name &amp;lt;&quot;&amp;gt; ] ; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-cache&quot; [ &quot;=&quot; &amp;lt;&quot;&amp;gt; 1#field-name &amp;lt;&quot;&amp;gt; ]; &lt;a href=&quot;#section-14.9.1&quot;&gt;Section 14.9.1&lt;/a&gt;
         | &quot;no-store&quot;                             ; &lt;a href=&quot;#section-14.9.2&quot;&gt;Section 14.9.2&lt;/a&gt;
         | &quot;no-transform&quot;                         ; &lt;a href=&quot;#section-14.9.5&quot;&gt;Section 14.9.5&lt;/a&gt;
         | &quot;must-revalidate&quot;                      ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | &quot;proxy-revalidate&quot;                     ; &lt;a href=&quot;#section-14.9.4&quot;&gt;Section 14.9.4&lt;/a&gt;
         | &quot;max-age&quot; &quot;=&quot; delta-seconds            ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | &quot;s-maxage&quot; &quot;=&quot; delta-seconds           ; &lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;
         | cache-extension                        ; &lt;a href=&quot;#section-14.9.6&quot;&gt;Section 14.9.6&lt;/a&gt;

    cache-extension = token [ &quot;=&quot; ( token | quoted-string ) ] 

   When a directive appears without any 1#field-name parameter, the
   directive applies to the entire request or response. When such a
   directive appears with a 1#field-name parameter, it applies only to
   the named field or fields, and not to the rest of the request or
   response. This mechanism supports extensibility; implementations of
   future versions of the HTTP protocol might apply these directives to
   header fields not defined in HTTP/1.1.

   The cache-control directives can be broken down into these general
   categories:

      - Restrictions on what are cacheable; these may only be imposed by
        the origin server.

      - Restrictions on what may be stored by a cache; these may be
        imposed by either the origin server or the user agent.

      - Modifications of the basic expiration mechanism; these may be
        imposed by either the origin server or the user agent.

      - Controls over cache revalidation and reload; these may only be
        imposed by a user agent.

      - Control over transformation of entities.

      - Extensions to the caching system.</source>
          <target state="translated">Cache-Control general-header 필드는 요청 / 응답 체인을 따라 모든 캐싱 메커니즘에 따라야하는 지시문을 지정하는 데 사용됩니다. 지시문은 캐시가 요청 또는 응답을 방해하지 않도록하는 동작을 지정합니다. 이러한 지시문은 일반적으로 기본 캐싱 알고리즘보다 우선합니다. 캐시 지시문은 요청에 지시문이 있다는 것이 응답에 동일한 지시문이 제공되는 것을 의미하지 않는다는 점에서 단방향입니다. HTTP / 1.0 캐시는 Cache-Control을 구현하지 않을 수 있으며 Pragma : no-cache 만 구현할 수 있습니다.&lt;a href=&quot;#section-14.32&quot;&gt; 섹션 14.32&lt;/a&gt;). 지시문은 요청 / 응답 체인을 따라 모든 수신자에게 적용될 수 있으므로 캐시 지시문은 해당 애플리케이션에 대한 중요성에 관계없이 프록시 또는 게이트웨이 애플리케이션에 의해 전달되어야합니다. 특정 캐시에 대해 캐시 지시문을 지정할 수 없습니다. Cache-Control = &quot;캐시-제어&quot; &quot;:&quot;1 # cache-directive 캐시-디렉티브 = 캐시-요청-디렉티브 | 캐시-응답-지시문 cache-request-directive = &quot;no-cache&quot;; &lt;a href=&quot;#section-14.9.1&quot;&gt;섹션 14.9.1&lt;/a&gt; | &quot;no-store&quot;; &lt;a href=&quot;#section-14.9.2&quot;&gt;섹션 14.9.2&lt;/a&gt; | &quot;max-age&quot; &quot;=&quot;델타-초; &lt;a href=&quot;#section-14.9.3&quot;&gt;섹션 14.9.3&lt;/a&gt; , 14.9.4 | &quot;최대 이야기&quot;[ &quot;=&quot;델타 초]; &lt;a href=&quot;#section-14.9.3&quot;&gt;섹션 14.9.3&lt;/a&gt; | &quot;min-fresh&quot; &quot;=&quot;델타 초; &lt;a href=&quot;#section-14.9.3&quot;&gt;섹션 14.9.3&lt;/a&gt; | &quot;변형 없음&quot;; &lt;a href=&quot;#section-14.9.5&quot;&gt;섹션 14.9.5&lt;/a&gt; | &quot;만 캐시 된 경우&quot;; &lt;a href=&quot;#section-14.9.4&quot;&gt;섹션 14.9.4&lt;/a&gt; | 캐시 확장; &lt;a href=&quot;#section-14.9.6&quot;&gt;섹션 14.9.6&lt;/a&gt; 캐시-응답 지시문 = &quot;public&quot;; &lt;a href=&quot;#section-14.9.1&quot;&gt;섹션 14.9.1&lt;/a&gt; | &quot;private&quot;[ &quot;=&quot;&amp;lt; &quot;&amp;gt; 1 # field-name &amp;lt;&quot;&amp;gt;]; &lt;a href=&quot;#section-14.9.1&quot;&gt;섹션 14.9.1&lt;/a&gt; | &quot;no-cache&quot;[ &quot;=&quot;&amp;lt; &quot;&amp;gt; 1 # field-name &amp;lt;&quot;&amp;gt;]; &lt;a href=&quot;#section-14.9.1&quot;&gt;섹션 14.9.1&lt;/a&gt; | &quot;no-store&quot;;&lt;a href=&quot;#section-14.9.2&quot;&gt;섹션 14.9.2&lt;/a&gt; | &quot;변형 없음&quot;; &lt;a href=&quot;#section-14.9.5&quot;&gt;섹션 14.9.5&lt;/a&gt; | &quot;반드시 재확인&quot;; &lt;a href=&quot;#section-14.9.4&quot;&gt;섹션 14.9.4&lt;/a&gt; | &quot;프록시 재확인&quot;; &lt;a href=&quot;#section-14.9.4&quot;&gt;섹션 14.9.4&lt;/a&gt; | &quot;max-age&quot; &quot;=&quot;델타-초; &lt;a href=&quot;#section-14.9.3&quot;&gt;섹션 14.9.3&lt;/a&gt; | &quot;s-maxage&quot; &quot;=&quot;델타 초; &lt;a href=&quot;#section-14.9.3&quot;&gt;섹션 14.9.3&lt;/a&gt; | 캐시 확장; &lt;a href=&quot;#section-14.9.6&quot;&gt;섹션 14.9.6&lt;/a&gt; cache-extension = token [ &quot;=&quot;(token | quoted-string)] 지시문이 1 # field-name 매개 변수없이 나타나면 지시문이 전체 요청 또는 응답에 적용됩니다. 이러한 지시문이 1 # field-name 매개 변수와 함께 나타나면 이름 지정된 필드에만 적용되고 나머지 요청이나 응답에는 적용되지 않습니다. 이 메커니즘은 확장 성을 지원합니다. 이후 버전의 HTTP 프로토콜 구현에서는 이러한 지시문을 HTTP / 1.1에 정의되지 않은 헤더 필드에 적용 할 수 있습니다. 캐시 제어 지시문은 다음과 같은 일반적인 범주로 나눌 수 있습니다.-캐시 가능한 대상에 대한 제한; 이것은 오리진 서버에 의해서만 부과 될 수 있습니다. -캐시에 의해 저장 될 수있는 것에 대한 제한; 이들은 오리진 서버 또는 사용자 에이전트에 의해 부과 될 수 있습니다.-기본 만기 메커니즘의 수정; 이들은 오리진 서버 또는 사용자 에이전트에 의해 부과 될 수 있습니다. -캐시 재확인 및 재로드를 제어합니다. 이들은 사용자 에이전트에 의해서만 부과 될 수 있습니다. -엔터티 변환 제어. -캐싱 시스템으로의 확장.</target>
        </trans-unit>
        <trans-unit id="9324bfa18c0087b8561a3281ae4b9944c65be9ca" translate="yes" xml:space="preserve">
          <source>The Cache-Control header field can be extended through the use of one
   or more cache-extension tokens, each with an optional assigned value.
   Informational extensions (those which do not require a change in
   cache behavior) MAY be added without changing the semantics of other
   directives. Behavioral extensions are designed to work by acting as
   modifiers to the existing base of cache directives. Both the new
   directive and the standard directive are supplied, such that
   applications which do not understand the new directive will default
   to the behavior specified by the standard directive, and those that
   understand the new directive will recognize it as modifying the
   requirements associated with the standard directive. In this way,
   extensions to the cache-control directives can be made without
   requiring changes to the base protocol.

   This extension mechanism depends on an HTTP cache obeying all of the
   cache-control directives defined for its native HTTP-version, obeying
   certain extensions, and ignoring all directives that it does not
   understand.

   For example, consider a hypothetical new response directive called
   community which acts as a modifier to the private directive. We
   define this new directive to mean that, in addition to any non-shared
   cache, any cache which is shared only by members of the community
   named within its value may cache the response. An origin server
   wishing to allow the UCI community to use an otherwise private
   response in their shared cache(s) could do so by including

       Cache-Control: private, community=&quot;UCI&quot;

   A cache seeing this header field will act correctly even if the cache
   does not understand the community cache-extension, since it will also
   see and understand the private directive and thus default to the safe
   behavior. 

   Unrecognized cache-directives MUST be ignored; it is assumed that any
   cache-directive likely to be unrecognized by an HTTP/1.1 cache will
   be combined with standard directives (or the response's default
   cacheability) such that the cache behavior will remain minimally
   correct even if the cache does not understand the extension(s).</source>
          <target state="translated">Cache-Control 헤더 필드는 각각 옵션으로 할당 된 값을 가진 하나 이상의 캐시 확장 토큰을 사용하여 확장 할 수 있습니다. 캐시 동작을 변경하지 않아도되는 정보 확장은 다른 지시문의 의미를 변경하지 않고 추가 될 수 있습니다. 동작 확장은 기존 캐시 지시문 기본에 대한 수정 자 역할을하여 작동하도록 설계되었습니다. 새 지시문과 표준 지시문이 모두 제공되므로 새 지시문을 이해하지 못하는 응용 프로그램은 기본 지시문에 지정된 동작으로 기본 설정되고 새 지시문을 이해하는 응용 프로그램은 표준과 관련된 요구 사항을 수정하는 것으로 인식합니다. 지령. 이런 식으로,캐시 제어 지시문의 확장은 기본 프로토콜을 변경하지 않고도 수행 할 수 있습니다. 이 확장 메커니즘은 기본 HTTP 버전에 대해 정의 된 모든 캐시 제어 지시문을 준수하고 특정 확장명을 준수하며 이해하지 못하는 모든 지시문을 무시하는 HTTP 캐시에 의존합니다. 예를 들어, private 지시문의 수정 자 역할을하는 커뮤니티라는 새로운 가상 지시문을 고려하십시오. 우리는이 새로운 지시문을 정의하여, 비공유 캐시 외에도 해당 값 내에 이름이 지정된 커뮤니티 구성원 만 공유하는 캐시가 응답을 캐시 할 수 있음을 의미합니다. UCI 커뮤니티가 공유 캐시에서 개인 응답을 사용하도록 허용하려는 원 서버는 Cache-Control : private,community = &quot;UCI&quot;이 헤더 필드를 보는 캐시는 캐시가 커뮤니티 캐시 확장을 이해하지 않더라도 개인 명령을보고 이해하므로 기본적으로 안전한 동작을 수행하기 때문에 올바르게 작동합니다. 인식 할 수없는 캐시 지시문은 무시해야합니다. HTTP / 1.1 캐시에 의해 인식되지 않을 가능성이있는 모든 캐시 지시문은 표준 지시문 (또는 응답의 기본 캐시 가능성)과 결합되어 캐시가 확장을 이해하지 않더라도 캐시 동작이 최소한으로 유지되도록 가정합니다 ( 에스).인식 할 수없는 캐시 지시문은 무시해야합니다. HTTP / 1.1 캐시에 의해 인식되지 않을 가능성이있는 모든 캐시 지시문은 표준 지시문 (또는 응답의 기본 캐시 가능성)과 결합되어 캐시가 확장을 이해하지 않더라도 캐시 동작이 최소한으로 유지되도록 가정합니다 ( 에스).인식 할 수없는 캐시 지시문은 무시해야합니다. HTTP / 1.1 캐시에 의해 인식되지 않을 가능성이있는 모든 캐시 지시문은 표준 지시문 (또는 응답의 기본 캐시 가능성)과 결합되어 캐시가 확장을 이해하지 않더라도 캐시 동작이 최소한으로 유지되도록 가정합니다 ( 에스).</target>
        </trans-unit>
        <trans-unit id="f33f8e03ed1edc160f54d39609d6b7e8bfc2a2f7" translate="yes" xml:space="preserve">
          <source>The Cache-Control header field can be extended through the use of one
   or more cache-extension tokens, each with an optional value.  A cache
   MUST ignore unrecognized cache directives.

   Informational extensions (those that do not require a change in cache
   behavior) can be added without changing the semantics of other
   directives.

   Behavioral extensions are designed to work by acting as modifiers to
   the existing base of cache directives.  Both the new directive and
   the old directive are supplied, such that applications that do not
   understand the new directive will default to the behavior specified
   by the old directive, and those that understand the new directive
   will recognize it as modifying the requirements associated with the
   old directive.  In this way, extensions to the existing cache-control
   directives can be made without breaking deployed caches.

   For example, consider a hypothetical new response directive called
   &quot;community&quot; that acts as a modifier to the private directive: in
   addition to private caches, any cache that is shared only by members
   of the named community is allowed to cache the response.  An origin
   server wishing to allow the UCI community to use an otherwise private
   response in their shared cache(s) could do so by including

     Cache-Control: private, community=&quot;UCI&quot;

   A cache that recognizes such a community cache-extension could
   broaden its behavior in accordance with that extension.  A cache that
   does not recognize the community cache-extension would ignore it and
   adhere to the private directive.</source>
          <target state="translated">Cache-Control 헤더 필드는 각각 선택적 값을 가진 하나 이상의 캐시 확장 토큰을 사용하여 확장 할 수 있습니다. 캐시는 인식 할 수없는 캐시 지시문을 무시해야합니다. 다른 지시문의 의미를 변경하지 않고 정보 확장 (캐시 동작을 변경하지 않아도되는 확장)을 추가 할 수 있습니다. 동작 확장은 기존 캐시 지시문 기본에 대한 수정 자 역할을하여 작동하도록 설계되었습니다. 새 지시문과 이전 지시문이 모두 제공되므로 새 지시문을 이해하지 못하는 응용 프로그램은 기본적으로 이전 지시문에 지정된 동작으로 기본 설정되며 새 지시문을 이해하는 응용 프로그램은 이전 지시문과 관련된 요구 사항을 수정하는 것으로 인식합니다. 지령. 이런 식으로,배포 된 캐시를 손상시키지 않고 기존 캐시 제어 지시문에 대한 확장을 만들 수 있습니다. 예를 들어 개인 지시문에 대한 수정 자 역할을하는 &quot;커뮤니티&quot;라는 가상의 새로운 응답 지시문을 고려하십시오. 개인 캐시 외에, 이름 지정된 커뮤니티의 구성원 만 공유하는 캐시는 응답을 캐시 할 수 있습니다. UCI 커뮤니티가 공유 캐시에서 다른 개인 응답을 사용하도록 허용하려는 원 서버는 Cache-Control을 포함하여이를 수행 할 수 있습니다. private, community = &quot;UCI&quot;이러한 커뮤니티 캐시 확장을 인식하는 캐시는 확장 될 수 있습니다. 해당 확장에 따른 동작. 커뮤니티 캐시 확장을 인식하지 못하는 캐시는이를 무시하고 개인 지시문을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="b85b1bbcc9141ccc627797dbf9d5406273b17461" translate="yes" xml:space="preserve">
          <source>The California Consumer Privacy Act</source>
          <target state="translated">캘리포니아 소비자 개인 정보 보호법</target>
        </trans-unit>
        <trans-unit id="c50007c31e7e40ed5eaa0ff3024c3f4a7f1a8be9" translate="yes" xml:space="preserve">
          <source>The Chrome (or Chromium/Blink-based engines) user agent string is similar to Firefox&amp;rsquo;s. For compatibility, it adds strings like &lt;code&gt;KHTML, like Gecko&lt;/code&gt; and &lt;code&gt;Safari&lt;/code&gt;.</source>
          <target state="translated">Chrome (또는 Chromium / Blink 기반 엔진) 사용자 에이전트 문자열은 Firefox와 유사합니다. 호환성을 위해 &lt;code&gt;KHTML, like Gecko&lt;/code&gt; 및 &lt;code&gt;Safari&lt;/code&gt; 와 같은 KHTML과 같은 문자열을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="e4526b0c406ce54b0f40282cbe0ea0db53127d37" translate="yes" xml:space="preserve">
          <source>The Chrome (or Chromium/blink-based engines) user agent string is similar to the Firefox format. For compatibility, it adds strings like &quot;KHTML, like Gecko&quot; and &quot;Safari&quot;.</source>
          <target state="translated">Chrome (또는 Chromium / 블링크 기반 엔진) 사용자 에이전트 문자열은 Firefox 형식과 유사합니다. 호환성을 위해 &quot;Kecko와 같은 KHTML&quot;및 &quot;Safari&quot;와 같은 문자열을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4e445db7bcb2d5d8898885e114adb8cb0619ec53" translate="yes" xml:space="preserve">
          <source>The Connection general-header field allows the sender to specify
   options that are desired for that particular connection and MUST NOT
   be communicated by proxies over further connections.

   The Connection header has the following grammar:

       Connection = &quot;Connection&quot; &quot;:&quot; 1#(connection-token)
       connection-token  = token

   HTTP/1.1 proxies MUST parse the Connection header field before a
   message is forwarded and, for each connection-token in this field,
   remove any header field(s) from the message with the same name as the
   connection-token. Connection options are signaled by the presence of
   a connection-token in the Connection header field, not by any
   corresponding additional header field(s), since the additional header
   field may not be sent if there are no parameters associated with that
   connection option.

   Message headers listed in the Connection header MUST NOT include
   end-to-end headers, such as Cache-Control.

   HTTP/1.1 defines the &quot;close&quot; connection option for the sender to
   signal that the connection will be closed after completion of the
   response. For example,

       Connection: close

   in either the request or the response header fields indicates that
   the connection SHOULD NOT be considered `persistent' (&lt;a href=&quot;#section-8.1&quot;&gt;section 8.1&lt;/a&gt;)
   after the current request/response is complete.

   HTTP/1.1 applications that do not support persistent connections MUST
   include the &quot;close&quot; connection option in every message.

   A system receiving an HTTP/1.0 (or lower-version) message that
   includes a Connection header MUST, for each connection-token in this
   field, remove and ignore any header field(s) from the message with
   the same name as the connection-token. This protects against mistaken
   forwarding of such header fields by pre-HTTP/1.1 proxies. See &lt;a href=&quot;#section-19.6.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt;.</source>
          <target state="translated">연결 일반 헤더 필드를 사용하면 발신자가 특정 연결에 필요한 옵션을 지정할 수 있으며 추가 연결을 통해 프록시와 통신해서는 안됩니다. 연결 헤더에는 다음과 같은 문법이 있습니다. 연결 = &quot;연결&quot; &quot;:&quot;1 # (연결 토큰) 연결 토큰 = 토큰 HTTP / 1.1 프록시는 메시지가 전달되고 각 연결 토큰에 대해 연결 헤더 필드를 구문 분석해야합니다. 이 필드에서 연결 토큰과 동일한 이름을 가진 메시지에서 헤더 필드를 제거하십시오. 연결 옵션은 해당 추가 헤더 필드가 아닌 연결 헤더 필드에 연결 토큰이 있음을 나타냅니다.해당 연결 옵션과 연관된 매개 변수가 없으면 추가 헤더 필드가 전송되지 않을 수 있습니다. 연결 헤더에 나열된 메시지 헤더에는 Cache-Control과 같은 엔드 투 엔드 헤더가 포함되어서는 안됩니다. HTTP / 1.1은 발신자가 응답이 완료된 후 연결이 종료 될 것임을 알리는 &quot;닫기&quot;연결 옵션을 정의합니다. 예를 들어, 요청 또는 응답 헤더 필드에서 Connection : close는 연결이 '영구적'으로 간주되어서는 안됨을 나타냅니다 (발신자가 응답 완료 후 연결이 끊 겼음을 알리는 연결 옵션. 예를 들어, 요청 또는 응답 헤더 필드에서 Connection : close는 연결이 '영구적'으로 간주되어서는 안됨을 나타냅니다 (발신자가 응답 완료 후 연결이 끊 겼음을 알리는 연결 옵션. 예를 들어, 요청 또는 응답 헤더 필드에서 Connection : close는 연결이 '영구적'으로 간주되어서는 안됨을 나타냅니다 (&lt;a href=&quot;#section-8.1&quot;&gt;섹션 8.1&lt;/a&gt; )은 현재 요청 / 응답이 완료된 후입니다. 지속적인 연결을 지원하지 않는 HTTP / 1.1 응용 프로그램은 모든 메시지에 &quot;close&quot;연결 옵션을 포함해야합니다. 이 필드의 각 연결 토큰에 대해 연결 헤더를 포함하는 HTTP / 1.0 (또는 하위 버전) 메시지를 수신하는 시스템은 연결과 동일한 이름을 가진 메시지에서 헤더 필드를 제거하고 무시합니다. 토큰. 이것은 HTTP / 1.1 이전 프록시에 의한 헤더 필드의 잘못된 전달을 방지합니다. &lt;a href=&quot;#section-19.6.2&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-19.6.2&quot;&gt;19.6.2&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="400f4aed66b4ae488aed6a9f1d0ba0a1d48e0bf5" translate="yes" xml:space="preserve">
          <source>The Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) provides a &quot;close&quot;
   connection option that a sender SHOULD send when it wishes to close
   the connection after the current request/response pair.

   A client that sends a &quot;close&quot; connection option MUST NOT send further
   requests on that connection (after the one containing &quot;close&quot;) and
   MUST close the connection after reading the final response message
   corresponding to this request.

   A server that receives a &quot;close&quot; connection option MUST initiate a
   close of the connection (see below) after it sends the final response
   to the request that contained &quot;close&quot;.  The server SHOULD send a
   &quot;close&quot; connection option in its final response on that connection.
   The server MUST NOT process any further requests received on that
   connection.

   A server that sends a &quot;close&quot; connection option MUST initiate a close
   of the connection (see below) after it sends the response containing
   &quot;close&quot;.  The server MUST NOT process any further requests received
   on that connection.

   A client that receives a &quot;close&quot; connection option MUST cease sending
   requests on that connection and close the connection after reading
   the response message containing the &quot;close&quot;; if additional pipelined
   requests had been sent on the connection, the client SHOULD NOT
   assume that they will be processed by the server. 

   If a server performs an immediate close of a TCP connection, there is
   a significant risk that the client will not be able to read the last
   HTTP response.  If the server receives additional data from the
   client on a fully closed connection, such as another request that was
   sent by the client before receiving the server's response, the
   server's TCP stack will send a reset packet to the client;
   unfortunately, the reset packet might erase the client's
   unacknowledged input buffers before they can be read and interpreted
   by the client's HTTP parser.

   To avoid the TCP reset problem, servers typically close a connection
   in stages.  First, the server performs a half-close by closing only
   the write side of the read/write connection.  The server then
   continues to read from the connection until it receives a
   corresponding close by the client, or until the server is reasonably
   certain that its own TCP stack has received the client's
   acknowledgement of the packet(s) containing the server's last
   response.  Finally, the server fully closes the connection.

   It is unknown whether the reset problem is exclusive to TCP or might
   also be found in other transport connection protocols.</source>
          <target state="translated">연결 헤더 필드 (&lt;a href=&quot;#section-6.1&quot;&gt; 6.1 절&lt;/a&gt;)는 발신자가 현재 요청 / 응답 쌍 후에 연결을 닫으려고 할 때 보내야하는 &quot;닫기&quot;연결 옵션을 제공합니다. &quot;닫기&quot;연결 옵션을 보내는 클라이언트는 해당 연결에 대한 추가 요청을 보내지 말아야하며 ( &quot;닫기&quot;가 포함 된 후)이 요청에 해당하는 최종 응답 메시지를 읽은 후 연결을 닫아야합니다. &quot;닫기&quot;연결 옵션을 수신 한 서버는 &quot;닫기&quot;가 포함 된 요청에 최종 응답을 보낸 후 연결을 닫아야합니다 (아래 참조). 서버는 해당 연결에 대한 최종 응답으로 &quot;닫기&quot;연결 옵션을 보내야합니다 (SHOULD). 서버는 해당 연결에서 수신 된 추가 요청을 처리해서는 안됩니다 (MUST NOT). &quot;를 보내는 서버&quot;닫기&quot;연결 옵션은 &quot;닫기&quot;를 포함하는 응답을 보낸 후 연결을 닫아야합니다 (아래 참조). 서버는 해당 연결에서 수신 된 추가 요청을 처리해서는 안됩니다. &quot;닫기&quot;가 포함 된 응답 메시지를 읽은 후 해당 연결에서 요청을 보내고 연결을 닫습니다. 연결에서 추가 파이프 라인 요청이 전송 된 경우 클라이언트는 서버에서 요청을 처리한다고 가정해서는 안됩니다. TCP 연결을 즉시 닫으면 클라이언트가 마지막 HTTP 응답을 읽을 수 없게 될 위험이 있습니다 서버가 완전히 닫힌 연결에서 클라이언트로부터 추가 데이터를받는 경우,서버의 응답을 받기 전에 클라이언트가 보낸 다른 요청과 같이 서버의 TCP 스택은 클라이언트에 재설정 패킷을 보냅니다. 불행히도, 재설정 패킷은 클라이언트의 HTTP 파서가 읽고 해석하기 전에 클라이언트의 승인되지 않은 입력 버퍼를 지울 수 있습니다. TCP 재설정 문제를 방지하기 위해 서버는 일반적으로 단계적으로 연결을 닫습니다. 먼저, 서버는 읽기 / 쓰기 연결의 쓰기 쪽만 닫아 반-폐쇄를 수행합니다. 그런 다음 서버는 클라이언트가 해당 닫기를 수신 할 때까지 또는 자체 TCP 스택이 서버의 마지막 응답을 포함하는 패킷에 대한 클라이언트의 승인을 받았음을 합리적으로 확신 할 때까지 연결에서 계속 읽습니다. 드디어,서버가 연결을 완전히 닫습니다. 재설정 문제가 TCP 전용인지 또는 다른 전송 연결 프로토콜에서도 발견 될 수 있는지 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e4269110c11e8492bcb4464320596b28df93a15f" translate="yes" xml:space="preserve">
          <source>The Content-Disposition response-header field has been proposed as a
   means for the origin server to suggest a default filename if the user
   requests that the content is saved to a file. This usage is derived
   from the definition of Content-Disposition in &lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt; [&lt;a href=&quot;#ref-35&quot;&gt;35&lt;/a&gt;].

        content-disposition = &quot;Content-Disposition&quot; &quot;:&quot;
                              disposition-type *( &quot;;&quot; disposition-parm )
        disposition-type = &quot;attachment&quot; | disp-extension-token
        disposition-parm = filename-parm | disp-extension-parm
        filename-parm = &quot;filename&quot; &quot;=&quot; quoted-string
        disp-extension-token = token
        disp-extension-parm = token &quot;=&quot; ( token | quoted-string )

   An example is

        Content-Disposition: attachment; filename=&quot;fname.ext&quot;

   The receiving user agent SHOULD NOT respect any directory path
   information present in the filename-parm parameter, which is the only
   parameter believed to apply to HTTP implementations at this time. The
   filename SHOULD be treated as a terminal component only.

   If this header is used in a response with the application/octet-
   stream content-type, the implied suggestion is that the user agent
   should not display the response, but directly enter a `save response
   as...' dialog.

   See &lt;a href=&quot;#section-15.5&quot;&gt;section 15.5&lt;/a&gt; for Content-Disposition security issues.</source>
          <target state="translated">사용자가 콘텐츠를 파일에 저장하도록 요청하는 경우 원본 서버가 기본 파일 이름을 제안하는 수단으로 콘텐츠 처리 응답 헤더 필드가 제안되었습니다. 이 사용법은 &lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt; [ Content-Disposition]의 정의에서 파생됩니다.&lt;a href=&quot;#ref-35&quot;&gt; 35&lt;/a&gt;]. content-disposition = &quot;Content-Disposition&quot; &quot;:&quot;처리 유형 * ( &quot;;&quot;disposition-parm) 처리 유형 = &quot;첨부 파일&quot;| disp- 확장 토큰 처리 -parm = filename-parm | disp-extension-parm filename-parm = &quot;filename&quot; &quot;=&quot;인용 문자열 disp-extension-token = 토큰 disp-extension-parm = token &quot;=&quot;(token | quoted-string) 예는 ​​Content-Disposition : attachment입니다. ; filename = &quot;fname.ext&quot;수신 사용자 에이전트는 filename-parm 매개 변수에 존재하는 디렉토리 경로 정보를 존중해서는 안됩니다. 이는 현재 HTTP 구현에 적용되는 것으로 생각되는 유일한 매개 변수입니다. 파일 이름은 터미널 구성 요소로만 취급해야합니다.이 헤더가 application / octet-stream content-type의 응답에 사용되는 경우 암시 된 제안은 사용자 에이전트가 응답을 표시하지 말고 '다른 이름으로 응답 저장 ...'대화 상자를 직접 입력해야한다는 것입니다. 보다&lt;a href=&quot;#section-15.5&quot;&gt;&lt;/a&gt;콘텐츠 처리 보안 문제에 대해서는 15.5 절을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="22177303e5c541de4c1a2fb13e69fc833be5a044" translate="yes" xml:space="preserve">
          <source>The Content-Encoding entity-header field is used as a modifier to the
   media-type. When present, its value indicates what additional content
   codings have been applied to the entity-body, and thus what decoding
   mechanisms must be applied in order to obtain the media-type
   referenced by the Content-Type header field. Content-Encoding is
   primarily used to allow a document to be compressed without losing
   the identity of its underlying media type.

       Content-Encoding  = &quot;Content-Encoding&quot; &quot;:&quot; 1#content-coding

   Content codings are defined in &lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;. An example of its use is

       Content-Encoding: gzip

   The content-coding is a characteristic of the entity identified by
   the Request-URI. Typically, the entity-body is stored with this
   encoding and is only decoded before rendering or analogous usage.
   However, a non-transparent proxy MAY modify the content-coding if the
   new coding is known to be acceptable to the recipient, unless the
   &quot;no-transform&quot; cache-control directive is present in the message.

   If the content-coding of an entity is not &quot;identity&quot;, then the
   response MUST include a Content-Encoding entity-header (&lt;a href=&quot;#section-14.11&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.11&quot;&gt;14.11&lt;/a&gt;) that lists the non-identity content-coding(s) used.

   If the content-coding of an entity in a request message is not
   acceptable to the origin server, the server SHOULD respond with a
   status code of 415 (Unsupported Media Type).

   If multiple encodings have been applied to an entity, the content
   codings MUST be listed in the order in which they were applied.
   Additional information about the encoding parameters MAY be provided
   by other entity-header fields not defined by this specification.</source>
          <target state="translated">콘텐츠 인코딩 엔터티 헤더 필드는 미디어 유형의 수정 자로 사용됩니다. 존재하는 경우, 그 값은 어떤 추가 컨텐츠 코딩이 엔티티 본문에 적용 되었는지를 나타내며, 따라서 Content-Type 헤더 필드에 의해 참조되는 미디어 유형을 얻기 위해 어떤 디코딩 메커니즘이 적용되어야 하는지를 나타낸다. 컨텐츠 인코딩은 주로 기본 미디어 유형의 ID를 잃지 않고 문서를 압축 할 수 있도록하는 데 사용됩니다. Content-Encoding = &quot;콘텐츠 인코딩&quot; &quot;:&quot;1 # content-coding 콘텐츠 코딩은 다음과 같이 정의됩니다.&lt;a href=&quot;#section-3.5&quot;&gt; 3.5 절&lt;/a&gt;. 사용 예는 Content-Encoding입니다. gzip content-coding은 Request-URI로 식별 된 엔티티의 특성입니다. 일반적으로 엔티티 본문은이 인코딩과 함께 저장되며 렌더링 또는 유사한 사용법 전에 만 디코딩됩니다. 그러나, &quot;비 변형&quot;캐시 제어 지시어가 메시지에 존재하지 않는 한, 비 투명 프록시는 새로운 코딩이 수신자에게 수용 가능한 것으로 알려진 경우 콘텐츠 코딩을 수정할 수있다 (MAY). 엔티티의 컨텐츠 코딩이 &quot;identity&quot;가 아닌 경우 응답에는 반드시 컨텐츠 인코딩 엔티티 헤더가 포함되어야합니다 ( &lt;a href=&quot;#section-14.11&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-14.11&quot;&gt;14.11).&lt;/a&gt;)는 사용 된 비 ID 콘텐츠 코딩을 나열합니다. 요청 메시지에있는 엔터티의 콘텐츠 코딩이 원본 서버에 적합하지 않은 경우 서버는 상태 코드 415 (지원되지 않는 미디어 유형)로 응답해야합니다. 엔터티에 여러 인코딩이 적용된 경우 콘텐츠 코딩은 적용된 순서대로 나열되어야합니다. 인코딩 매개 변수에 대한 추가 정보는이 사양에서 정의하지 않은 다른 엔터티 헤더 필드에서 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78e0f66604a34d6350aaee50ec1aed948b641dff" translate="yes" xml:space="preserve">
          <source>The Content-Language entity-header field describes the natural
   language(s) of the intended audience for the enclosed entity. Note
   that this might not be equivalent to all the languages used within
   the entity-body.

       Content-Language  = &quot;Content-Language&quot; &quot;:&quot; 1#language-tag 

   Language tags are defined in &lt;a href=&quot;#section-3.10&quot;&gt;section 3.10&lt;/a&gt;. The primary purpose of
   Content-Language is to allow a user to identify and differentiate
   entities according to the user's own preferred language. Thus, if the
   body content is intended only for a Danish-literate audience, the
   appropriate field is

       Content-Language: da

   If no Content-Language is specified, the default is that the content
   is intended for all language audiences. This might mean that the
   sender does not consider it to be specific to any natural language,
   or that the sender does not know for which language it is intended.

   Multiple languages MAY be listed for content that is intended for
   multiple audiences. For example, a rendition of the &quot;Treaty of
   Waitangi,&quot; presented simultaneously in the original Maori and English
   versions, would call for

       Content-Language: mi, en

   However, just because multiple languages are present within an entity
   does not mean that it is intended for multiple linguistic audiences.
   An example would be a beginner's language primer, such as &quot;A First
   Lesson in Latin,&quot; which is clearly intended to be used by an
   English-literate audience. In this case, the Content-Language would
   properly only include &quot;en&quot;.

   Content-Language MAY be applied to any media type -- it is not
   limited to textual documents.</source>
          <target state="translated">Content-Language entity-header 필드는 동봉 된 엔터티에 대한 대상 독자의 자연어를 설명합니다. 이것은 엔터티 본문 내에서 사용되는 모든 언어와 같지 않을 수도 있습니다. Content-Language = &quot;Content-Language&quot; &quot;:&quot;1 # language-tag 언어 태그는&lt;a href=&quot;#section-3.10&quot;&gt; 섹션 3.10에 있습니다.&lt;/a&gt;. Content-Language의 주요 목적은 사용자가 선호하는 언어에 따라 엔티티를 식별하고 구별 할 수 있도록하는 것입니다. 따라서 본문 내용이 덴마크어를 사용하는 청중만을 대상으로하는 경우 해당 필드는 내용 언어입니다. da 내용 언어가 지정되지 않은 경우 기본적으로 해당 내용은 모든 언어 청중을 대상으로합니다. 이는 발신자가 자연 언어에 고유 한 것으로 간주하지 않거나 발신자가 어떤 언어를 사용하는지 알지 못했음을 의미 할 수 있습니다. 여러 사용자를 대상으로하는 콘텐츠에 대해 여러 언어가 나열 될 수 있습니다. 예를 들어, 원래 마오리어와 영어 버전에서 동시에 제시된 &quot;와이 탕이의 보물&quot;을 번역하려면 Content-Language : mi,jw.org ko 그러나 여러 언어가 하나의 엔티티 내에 존재한다고해서 여러 언어 사용자를 대상으로한다는 의미는 아닙니다. 예를 들어 &quot;Latin의 첫 수업&quot;과 같은 초보자의 언어 입문서를들 수 있습니다.이 언어는 영어를 사용하는 청중이 사용하기위한 것입니다. 이 경우 Content-Language에는 &quot;en&quot;만 올바르게 포함됩니다. 내용 언어는 모든 매체 유형에 적용될 수 있습니다 (텍스트 문서에만 국한되지 않음).Content-Language에는 &quot;en&quot;만 올바르게 포함됩니다. 내용 언어는 모든 매체 유형에 적용될 수 있습니다 (텍스트 문서에만 국한되지 않음).Content-Language에는 &quot;en&quot;만 올바르게 포함됩니다. 내용 언어는 모든 매체 유형에 적용될 수 있습니다 (텍스트 문서에만 국한되지 않음).</target>
        </trans-unit>
        <trans-unit id="a1abd3b0ff945fb9c54be7f36c23b898d0262eca" translate="yes" xml:space="preserve">
          <source>The Content-Length entity-header field indicates the size of the
   entity-body, in decimal number of OCTETs, sent to the recipient or,
   in the case of the HEAD method, the size of the entity-body that
   would have been sent had the request been a GET.

       Content-Length    = &quot;Content-Length&quot; &quot;:&quot; 1*DIGIT

   An example is

       Content-Length: 3495

   Applications SHOULD use this field to indicate the transfer-length of
   the message-body, unless this is prohibited by the rules in &lt;a href=&quot;#section-4.4&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. 

   Any Content-Length greater than or equal to zero is a valid value.
   &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; describes how to determine the length of a message-body
   if a Content-Length is not given.

   Note that the meaning of this field is significantly different from
   the corresponding definition in MIME, where it is an optional field
   used within the &quot;message/external-body&quot; content-type. In HTTP, it
   SHOULD be sent whenever the message's length can be determined prior
   to being transferred, unless this is prohibited by the rules in
   &lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;.</source>
          <target state="translated">Content-Length entity-header (콘텐츠 길이 엔티티 헤더) 필드는 엔티티 본문의 크기를 10 진수 (OCTET 수)로 수신자에게 보내거나 HEAD 방법의 경우 전송 된 엔티티 본문의 크기를 나타냅니다. 요청은 GET이었습니다. Content-Length = &quot;Content-Length&quot; &quot;:&quot;1 * DIGIT 예는 Content-Length입니다. 3495 Applications &lt;a href=&quot;#section-4.4&quot;&gt;4.4 &lt;/a&gt;&lt;a href=&quot;#section-4.4&quot;&gt;절의&lt;/a&gt; 규칙에 의해 금지되지 않는 한이 필드를 사용하여 메시지 본문의 전송 길이를 표시해야합니다. . 0보다 크거나 같은 Content-Length는 유효한 값입니다. &lt;a href=&quot;#section-4.4&quot;&gt;섹션 4.4&lt;/a&gt;Content-Length가 제공되지 않은 경우 메시지 본문의 길이를 결정하는 방법을 설명합니다. 이 필드의 의미는 &quot;메시지 / 외부 본문&quot;컨텐츠 유형에서 사용되는 선택적 필드 인 MIME의 해당 정의와 크게 다릅니다. HTTP &lt;a href=&quot;#section-4.4&quot;&gt;에서는 4.4 절의&lt;/a&gt; 규칙에 의해 금지되지 않는 한 전송 전에 메시지 길이를 결정할 수있을 때마다 전송되어야한다 .</target>
        </trans-unit>
        <trans-unit id="f5000316ac8e17d070fa4e93bb14ed2071d4d60f" translate="yes" xml:space="preserve">
          <source>The Content-Location entity-header field MAY be used to supply the
   resource location for the entity enclosed in the message when that
   entity is accessible from a location separate from the requested
   resource's URI. A server SHOULD provide a Content-Location for the
   variant corresponding to the response entity; especially in the case
   where a resource has multiple entities associated with it, and those
   entities actually have separate locations by which they might be
   individually accessed, the server SHOULD provide a Content-Location
   for the particular variant which is returned.

       Content-Location = &quot;Content-Location&quot; &quot;:&quot;
                         ( absoluteURI | relativeURI )

   The value of Content-Location also defines the base URI for the
   entity.

   The Content-Location value is not a replacement for the original
   requested URI; it is only a statement of the location of the resource
   corresponding to this particular entity at the time of the request.
   Future requests MAY specify the Content-Location URI as the request-
   URI if the desire is to identify the source of that particular
   entity.

   A cache cannot assume that an entity with a Content-Location
   different from the URI used to retrieve it can be used to respond to
   later requests on that Content-Location URI. However, the Content-
   Location can be used to differentiate between multiple entities
   retrieved from a single requested resource, as described in &lt;a href=&quot;#section-13.6&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt;.

   If the Content-Location is a relative URI, the relative URI is
   interpreted relative to the Request-URI.

   The meaning of the Content-Location header in PUT or POST requests is
   undefined; servers are free to ignore it in those cases.</source>
          <target state="translated">Content-Location entity-header 필드는 요청 된 리소스의 URI와 다른 위치에서 해당 엔터티에 액세스 할 수있을 때 메시지에 포함 된 엔터티의 리소스 위치를 제공하는 데 사용될 수 있습니다. 서버는 응답 엔터티에 해당하는 변형에 대한 콘텐츠 위치를 제공해야한다. 특히 자원에 연관된 엔티티가 여러 개 있고 해당 엔티티가 실제로 개별적으로 액세스 할 수있는 별도의 위치를 ​​가지고있는 경우, 서버는 리턴되는 특정 변형에 대한 컨텐츠 위치를 제공해야합니다 (SHOULD). Content-Location = &quot;Content-Location&quot; &quot;:&quot;(absoluteURI | relativeURI) Content-Location의 값은 또한 엔티티의 기본 URI를 정의합니다.Content-Location 값은 원래 요청 된 URI를 대체하지 않습니다. 요청시이 특정 엔티티에 해당하는 자원의 위치에 대한 설명 일뿐입니다. 향후 요청은 원하는 특정 엔터티의 소스를 식별하려는 경우 Content-Location URI를 request-URI로 지정할 수 있습니다. 캐시는이를 검색하는 데 사용 된 URI와 다른 Content-Location을 가진 엔터티가 해당 Content-Location URI에 대한 이후 요청에 응답하는 데 사용될 수 있다고 가정 할 수 없습니다. 그러나 Content-Location은 단일 요청 자원에서 검색된 여러 엔티티를 구별하는 데 사용할 수 있습니다.요청시이 특정 엔티티에 해당하는 자원의 위치에 대한 설명 일뿐입니다. 향후 요청은 원하는 특정 엔터티의 소스를 식별하려는 경우 Content-Location URI를 request-URI로 지정할 수 있습니다. 캐시는이를 검색하는 데 사용 된 URI와 다른 Content-Location을 가진 엔터티가 해당 Content-Location URI에 대한 이후 요청에 응답하는 데 사용될 수 있다고 가정 할 수 없습니다. 그러나 Content-Location은 단일 요청 자원에서 검색된 여러 엔티티를 구별하는 데 사용할 수 있습니다.요청시이 특정 엔티티에 해당하는 자원의 위치에 대한 설명 일뿐입니다. 향후 요청은 원하는 특정 엔터티의 소스를 식별하려는 경우 Content-Location URI를 request-URI로 지정할 수 있습니다. 캐시는이를 검색하는 데 사용 된 URI와 다른 Content-Location을 가진 엔터티가 해당 Content-Location URI에 대한 이후 요청에 응답하는 데 사용될 수 있다고 가정 할 수 없습니다. 그러나 Content-Location은 단일 요청 자원에서 검색된 여러 엔티티를 구별하는 데 사용할 수 있습니다.캐시는이를 검색하는 데 사용 된 URI와 다른 Content-Location을 가진 엔터티가 해당 Content-Location URI에 대한 이후 요청에 응답하는 데 사용될 수 있다고 가정 할 수 없습니다. 그러나 Content-Location은 단일 요청 자원에서 검색된 여러 엔티티를 구별하는 데 사용할 수 있습니다.캐시는이를 검색하는 데 사용 된 URI와 다른 Content-Location을 가진 엔티티가 해당 Content-Location URI에 대한 이후 요청에 응답하는 데 사용될 수 있다고 가정 할 수 없습니다. 그러나 Content-Location은 단일 요청 자원에서 검색된 여러 엔티티를 구별하는 데 사용할 수 있습니다.&lt;a href=&quot;#section-13.6&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-13.6&quot;&gt;13.6&lt;/a&gt; . Content-Location이 상대 URI 인 경우 상대 URI는 Request-URI를 기준으로 해석됩니다. PUT 또는 POST 요청에서 Content-Location 헤더의 의미는 정의되어 있지 않습니다. 이 경우 서버는이를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6782e7664ef97f5aa5c3c489b023d738a78d068c" translate="yes" xml:space="preserve">
          <source>The Content-MD5 entity-header field, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; [&lt;a href=&quot;#ref-23&quot;&gt;23&lt;/a&gt;], is
   an MD5 digest of the entity-body for the purpose of providing an
   end-to-end message integrity check (MIC) of the entity-body. (Note: a
   MIC is good for detecting accidental modification of the entity-body
   in transit, but is not proof against malicious attacks.)

        Content-MD5   = &quot;Content-MD5&quot; &quot;:&quot; md5-digest
        md5-digest   = &amp;lt;base64 of 128 bit MD5 digest as per &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt;&amp;gt;

   The Content-MD5 header field MAY be generated by an origin server or
   client to function as an integrity check of the entity-body. Only
   origin servers or clients MAY generate the Content-MD5 header field;
   proxies and gateways MUST NOT generate it, as this would defeat its
   value as an end-to-end integrity check. Any recipient of the entity-
   body, including gateways and proxies, MAY check that the digest value
   in this header field matches that of the entity-body as received.

   The MD5 digest is computed based on the content of the entity-body,
   including any content-coding that has been applied, but not including
   any transfer-encoding applied to the message-body. If the message is
   received with a transfer-encoding, that encoding MUST be removed
   prior to checking the Content-MD5 value against the received entity.

   This has the result that the digest is computed on the octets of the
   entity-body exactly as, and in the order that, they would be sent if
   no transfer-encoding were being applied.

   HTTP extends &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; to permit the digest to be computed for MIME
   composite media-types (e.g., multipart/* and message/rfc822), but
   this does not change how the digest is computed as defined in the
   preceding paragraph.

   There are several consequences of this. The entity-body for composite
   types MAY contain many body-parts, each with its own MIME and HTTP
   headers (including Content-MD5, Content-Transfer-Encoding, and
   Content-Encoding headers). If a body-part has a Content-Transfer-
   Encoding or Content-Encoding header, it is assumed that the content
   of the body-part has had the encoding applied, and the body-part is
   included in the Content-MD5 digest as is -- i.e., after the
   application. The Transfer-Encoding header field is not allowed within
   body-parts.

   Conversion of all line breaks to CRLF MUST NOT be done before
   computing or checking the digest: the line break convention used in
   the text actually transmitted MUST be left unaltered when computing
   the digest. 

      Note: while the definition of Content-MD5 is exactly the same for
      HTTP as in &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; for MIME entity-bodies, there are several ways
      in which the application of Content-MD5 to HTTP entity-bodies
      differs from its application to MIME entity-bodies. One is that
      HTTP, unlike MIME, does not use Content-Transfer-Encoding, and
      does use Transfer-Encoding and Content-Encoding. Another is that
      HTTP more frequently uses binary content types than MIME, so it is
      worth noting that, in such cases, the byte order used to compute
      the digest is the transmission byte order defined for the type.
      Lastly, HTTP allows transmission of text types with any of several
      line break conventions and not just the canonical form using CRLF.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt; [ &lt;a href=&quot;#ref-23&quot;&gt;23&lt;/a&gt; ]에 정의 된 Content-MD5 entity-header 필드 는 엔티티 본문의 엔드 투 엔드 메시지 무결성 검사 (MIC)를 제공 할 목적으로 엔티티 본문의 MD5 다이제스트입니다. (참고 : MIC는 전송중인 엔티티 본문의 우발적 인 수정을 감지하는 데 유용하지만 악의적 인 공격에 대한 증거는 아닙니다.) Content-MD5 = &quot;Content-MD5&quot; &quot;:&quot;md5-digest md5-digest = &amp;lt;base64 of &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864에&lt;/a&gt; 따른 128 비트 MD5 다이제스트&amp;gt; 오리진 서버 또는 클라이언트가 Content-MD5 헤더 필드를 생성하여 엔터티 본문의 무결성 검사 기능을 수행 할 수 있습니다. 오리진 서버 또는 클라이언트 만이 Content-MD5 헤더 필드를 생성 할 수있다; 프록시와 게이트웨이는 엔드 투 엔드 무결성 검사로서의 가치를 상실 할 수 있으므로이를 생성해서는 안됩니다. 게이트웨이와 프록시를 포함한 엔티티 본문의 수신자는이 헤더 필드의 다이제스트 값이 수신 된 엔티티 본문의 다이제스트 값과 일치하는지 확인할 수 있습니다. MD5 다이제스트는 적용된 모든 본문 인코딩을 포함하지만 메시지 본문에 적용된 전송 인코딩은 포함하지 않은 엔티티 본문의 내용을 기반으로 계산됩니다. 메시지가 전송 인코딩으로 수신되면 수신 된 엔터티에 대해 Content-MD5 값을 확인하기 전에 해당 인코딩을 제거해야합니다.이것은 다이제스트가 엔티티-바디의 옥텟에 대해 정확하게 계산되고 전송 인코딩이 적용되지 않은 경우에 전송되는 순서를 갖습니다. HTTP 확장&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC 1864&lt;/a&gt;MIME 복합 미디어 유형 (예 : multipart / * 및 message / rfc822)에 대해 다이제스트를 계산할 수 있지만 이전 단락에 정의 된대로 다이제스트가 계산되는 방식은 변경되지 않습니다. 이것의 몇 가지 결과가 있습니다. 복합 유형의 엔티티 본문에는 각각 고유 한 MIME 및 HTTP 헤더 (Content-MD5, Content-Transfer-Encoding 및 Content-Encoding 헤더 포함)가있는 많은 본문 부분이 포함될 수 있습니다. 본문 부분에 Content-Transfer-Encoding 또는 Content-Encoding 헤더가있는 경우 본문 부분의 내용에 인코딩이 적용된 것으로 가정하고 본문 부분은 그대로 Content-MD5 다이제스트에 포함됩니다 -신청 후. 본문 부분에는 전송 인코딩 헤더 필드가 허용되지 않습니다.다이제스트를 계산하거나 확인하기 전에 모든 줄 바꿈을 CRLF로 변환해서는 안됩니다. 다이제스트를 계산할 때 실제로 전송되는 텍스트에 사용 된 줄 바꿈 규칙은 변경되지 않아야합니다. 참고 : Content-MD5의 정의는 HTTP의 경우와 동일하지만&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;&lt;/a&gt;MIME 엔터티 본문에 대한 RFC 1864 의 경우 Content-MD5에서 HTTP 엔터티 본문으로의 응용 프로그램이 해당 응용 프로그램에서 MIME 엔터티 본문으로 다른 방식에는 여러 가지가 있습니다. 하나는 HTTP가 MIME과 달리 Content-Transfer-Encoding을 사용하지 않고 Transfer-Encoding 및 Content-Encoding을 사용한다는 것입니다. 다른 하나는 HTTP가 MIME보다 이진 콘텐츠 형식을 더 자주 사용한다는 것이므로 이러한 경우 다이제스트를 계산하는 데 사용되는 바이트 순서는 형식에 대해 정의 된 전송 바이트 순서입니다. 마지막으로 HTTP는 CRLF를 사용하는 표준 형식뿐만 아니라 여러 줄 바꿈 규칙으로 텍스트 유형을 전송할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff07970e216340fa2fb8373a79c1c42c82bcf1ba" translate="yes" xml:space="preserve">
          <source>The Content-Range entity-header is sent with a partial entity-body to
   specify where in the full entity-body the partial body should be
   applied. Range units are defined in &lt;a href=&quot;#section-3.12&quot;&gt;section 3.12&lt;/a&gt;.

       Content-Range = &quot;Content-Range&quot; &quot;:&quot; content-range-spec

       content-range-spec      = byte-content-range-spec
       byte-content-range-spec = bytes-unit SP
                                 byte-range-resp-spec &quot;/&quot;
                                 ( instance-length | &quot;*&quot; )

       byte-range-resp-spec = (first-byte-pos &quot;-&quot; last-byte-pos)
                                      | &quot;*&quot;
       instance-length           = 1*DIGIT

   The header SHOULD indicate the total length of the full entity-body,
   unless this length is unknown or difficult to determine. The asterisk
   &quot;*&quot; character means that the instance-length is unknown at the time
   when the response was generated.

   Unlike byte-ranges-specifier values (see &lt;a href=&quot;#section-14.35.1&quot;&gt;section 14.35.1&lt;/a&gt;), a byte-
   range-resp-spec MUST only specify one range, and MUST contain
   absolute byte positions for both the first and last byte of the
   range.

   A byte-content-range-spec with a byte-range-resp-spec whose last-
   byte-pos value is less than its first-byte-pos value, or whose
   instance-length value is less than or equal to its last-byte-pos
   value, is invalid. The recipient of an invalid byte-content-range-
   spec MUST ignore it and any content transferred along with it.

   A server sending a response with status code 416 (Requested range not
   satisfiable) SHOULD include a Content-Range field with a byte-range-
   resp-spec of &quot;*&quot;. The instance-length specifies the current length of 

   the selected resource. A response with status code 206 (Partial
   Content) MUST NOT include a Content-Range field with a byte-range-
   resp-spec of &quot;*&quot;.

   Examples of byte-content-range-spec values, assuming that the entity
   contains a total of 1234 bytes:

      . The first 500 bytes:
       bytes 0-499/1234

      . The second 500 bytes:
       bytes 500-999/1234

      . All except for the first 500 bytes:
       bytes 500-1233/1234

      . The last 500 bytes:
       bytes 734-1233/1234

   When an HTTP message includes the content of a single range (for
   example, a response to a request for a single range, or to a request
   for a set of ranges that overlap without any holes), this content is
   transmitted with a Content-Range header, and a Content-Length header
   showing the number of bytes actually transferred. For example,

       HTTP/1.1 206 Partial content
       Date: Wed, 15 Nov 1995 06:25:24 GMT
       Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
       Content-Range: bytes 21010-47021/47022
       Content-Length: 26012
       Content-Type: image/gif

   When an HTTP message includes the content of multiple ranges (for
   example, a response to a request for multiple non-overlapping
   ranges), these are transmitted as a multipart message. The multipart
   media type used for this purpose is &quot;multipart/byteranges&quot; as defined
   in appendix 19.2. See appendix 19.6.3 for a compatibility issue.

   A response to a request for a single range MUST NOT be sent using the
   multipart/byteranges media type.  A response to a request for
   multiple ranges, whose result is a single range, MAY be sent as a
   multipart/byteranges media type with one part. A client that cannot
   decode a multipart/byteranges message MUST NOT ask for multiple
   byte-ranges in a single request.

   When a client requests multiple byte-ranges in one request, the
   server SHOULD return them in the order that they appeared in the
   request. 

   If the server ignores a byte-range-spec because it is syntactically
   invalid, the server SHOULD treat the request as if the invalid Range
   header field did not exist. (Normally, this means return a 200
   response containing the full entity).

   If the server receives a request (other than one including an If-
   Range request-header field) with an unsatisfiable Range request-
   header field (that is, all of whose byte-range-spec values have a
   first-byte-pos value greater than the current length of the selected
   resource), it SHOULD return a response code of 416 (Requested range
   not satisfiable) (&lt;a href=&quot;#section-10.4.17&quot;&gt;section 10.4.17&lt;/a&gt;).

      Note: clients cannot depend on servers to send a 416 (Requested
      range not satisfiable) response instead of a 200 (OK) response for
      an unsatisfiable Range request-header, since not all servers
      implement this request-header.</source>
          <target state="translated">Content-Range 엔티티 헤더는 전체 엔티티 본문에서 부분 본문을 적용 할 위치를 지정하기 위해 부분 엔티티 본문과 함께 전송됩니다. 범위 단위는 &lt;a href=&quot;#section-3.12&quot;&gt;섹션 3.12에&lt;/a&gt; 정의되어 있습니다.. Content-Range = &quot;Content-Range&quot; &quot;:&quot;content-range-spec 컨텐츠-범위 -spec = 바이트-내용-범위-사양 byte-content-range-spec = 바이트-단위 SP 바이트-범위 -resp-spec &quot; / &quot;(instance-length |&quot;* &quot;) byte-range-resp-spec = (first-byte-pos&quot;- &quot;last-byte-pos) | &quot;*&quot;instance-length = 1 * DIGIT이 길이를 알 수 없거나 결정하기 어려운 경우가 아니라면 헤더는 전체 엔터티 본문의 전체 길이를 나타내야한다. 별표 &quot;*&quot;문자는 응답이 생성 될 때 인스턴스 길이를 알 수 없음을 의미합니다. 바이트 범위 지정자와 달리 ( &lt;a href=&quot;#section-14.35.1&quot;&gt;섹션 14.35.1&lt;/a&gt; 참조)), byte-range-resp-spec은 하나의 범위 만 지정해야하며 범위의 첫 번째 바이트와 마지막 바이트 모두에 대한 절대 바이트 위치를 포함해야합니다. last-byte-pos 값이 첫 번째 byte-pos 값보다 작거나 인스턴스 길이 값이 last-보다 작거나 같은 byte-range-resp-spec을 갖는 byte-content-range-spec 바이트 위치 값이 유효하지 않습니다. 유효하지 않은 byte-content-range-spec을받는 사람은이를 무시하고 그와 함께 전송 된 모든 내용을 무시해야합니다. 상태 코드 416 (요청한 범위는 만족할 수 없음) 인 응답을 전송하는 서버는 바이트-범위 -resp-spec이 &quot;*&quot;인 Content-Range 필드를 포함해야합니다. instance-length는 선택된 자원의 현재 길이를 지정합니다.상태 코드 206 (부분 컨텐츠)의 응답은 바이트 범위 범위 스펙이 &quot;*&quot;인 컨텐츠 범위 필드를 포함해서는 안됩니다 (MUST NOT). 엔터티에 총 1234 바이트가 포함되어 있다고 가정 한 바이트-콘텐츠-범위-사양 값의 예 :. 처음 500 바이트 : bytes 0-499 / 1234 두 번째 500 바이트 : bytes 500-999 / 1234 처음 500 바이트를 제외한 모두 : 바이트 500-1233 / 1234 마지막 500 바이트 : bytes 734-1233 / 1234 HTTP 메시지에 단일 범위의 컨텐츠가 포함 된 경우 (예 : 단일 범위에 대한 요청에 대한 응답 또는 구멍없이 겹치는 범위의 세트에 대한 요청) )에서이 콘텐츠는 Content-Range 헤더와 실제로 전송 된 바이트 수를 나타내는 Content-Length 헤더와 함께 전송됩니다. 예를 들어, HTTP / 1입니다.1206 부분 내용 날짜 : 1995 년 11 월 15 일 수요일 06:25:24 GMT 최종 수정 : 1995 년 11 월 15 일 수요일 04:58:08 GMT 내용 범위 : 바이트 21010-47021 / 47022 내용 길이 : 26012 내용 유형 : image / gif HTTP 메시지에 여러 범위의 내용 (예 : 겹치지 않는 여러 범위에 대한 요청에 대한 응답)이 포함되어 있으면 여러 부분 메시지로 전송됩니다. 이 목적으로 사용되는 멀티 파트 미디어 유형은 부록 19.2에 정의 된 &quot;멀티 파트 / 바이트 범위&quot;입니다. 호환성 문제에 대해서는 부록 19.6.3을 참조하십시오. 단일 범위에 대한 요청에 대한 응답은 multipart / byteranges 미디어 유형을 사용하여 전송해서는 안됩니다 (MUST NOT). 결과가 단일 범위 인 여러 범위에 대한 요청에 대한 응답은 한 부분으로 여러 부분 / 바이트 범위의 미디어 유형으로 전송 될 수 있습니다.멀티 파트 / 바이트 범위 메시지를 디코딩 할 수없는 클라이언트는 단일 요청에서 여러 바이트 범위를 요구해서는 안됩니다 (MUST NOT). 클라이언트가 한 요청에서 여러 바이트 범위를 요청하면 서버는 요청에 나타난 순서대로 반환해야합니다. 서버가 구문 적으로 유효하지 않기 때문에 바이트 범위 사양을 무시하면 서버는 유효하지 않은 Range 헤더 필드가 존재하지 않는 것처럼 요청을 처리해야합니다 (SHOULD). 일반적으로 이는 전체 엔터티를 포함하는 200 응답을 반환합니다. 서버가 만족할 수없는 범위 요청 헤더 필드 (즉, 모든 바이트 범위 스펙 값의 첫 번째 바이트 위치 값이 큰)와 함께 요청 (If-Range 요청 헤더 필드를 포함하는 것 이외)을 수신하는 경우 선택한 리소스의 현재 길이보다)416의 응답 코드를 반환해야합니다 (요청 범위가 만족스럽지 않습니다) (&lt;a href=&quot;#section-10.4.17&quot;&gt;섹션 10.4.17&lt;/a&gt; ). 참고 : 모든 서버가이 요청 헤더를 구현하는 것은 아니기 때문에 클라이언트가 만족할 수없는 범위 요청 헤더에 대해 200 (OK) 응답 대신 416 (요청 범위가 만족스럽지 않음) 응답을 보내도록 서버에 의존 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="e283ef83ad0c98c2f0776bde603c318284d66f81" translate="yes" xml:space="preserve">
          <source>The Content-Type entity-header field indicates the media type of the
   entity-body sent to the recipient or, in the case of the HEAD method,
   the media type that would have been sent had the request been a GET.

       Content-Type   = &quot;Content-Type&quot; &quot;:&quot; media-type

   Media types are defined in &lt;a href=&quot;#section-3.7&quot;&gt;section 3.7&lt;/a&gt;. An example of the field is

       Content-Type: text/html; charset=ISO-8859-4

   Further discussion of methods for identifying the media type of an
   entity is provided in &lt;a href=&quot;#section-7.2.1&quot;&gt;section 7.2.1&lt;/a&gt;.</source>
          <target state="translated">Content-Type entity-header 필드는 수신자에게 전송 된 엔티티 본문의 미디어 유형을 표시하거나 HEAD 메소드의 경우 요청이 GET 인 경우 전송 된 미디어 유형을 표시합니다. Content-Type = &quot;Content-Type&quot; &quot;:&quot;미디어 유형 미디어 유형은 &lt;a href=&quot;#section-3.7&quot;&gt;3.7 절&lt;/a&gt; 에서 정의됩니다 . 이 필드의 예는 Content-Type : text / html; charset = ISO-8859-4 엔티티의 미디어 타입을 식별하는 방법에 대한 추가 논의는 &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1 장&lt;/a&gt; 에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="d09adc4e47017807bd60018491b4e8efd7bba713" translate="yes" xml:space="preserve">
          <source>The Cookie header field [&lt;a href=&quot;#ref-COOKIE&quot;&gt;COOKIE&lt;/a&gt;] uses a semi-colon (&quot;;&quot;) to delimit
   cookie-pairs (or &quot;crumbs&quot;).  This header field doesn't follow the
   list construction rules in HTTP (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2.2&lt;/a&gt;), which
   prevents cookie-pairs from being separated into different name-value
   pairs.  This can significantly reduce compression efficiency as
   individual cookie-pairs are updated.

   To allow for better compression efficiency, the Cookie header field
   MAY be split into separate header fields, each with one or more
   cookie-pairs.  If there are multiple Cookie header fields after
   decompression, these MUST be concatenated into a single octet string
   using the two-octet delimiter of 0x3B, 0x20 (the ASCII string &quot;; &quot;)
   before being passed into a non-HTTP/2 context, such as an HTTP/1.1
   connection, or a generic HTTP server application.

   Therefore, the following two lists of Cookie header fields are
   semantically equivalent.

     cookie: a=b; c=d; e=f

     cookie: a=b
     cookie: c=d
     cookie: e=f</source>
          <target state="translated">쿠키 헤더 필드 [ &lt;a href=&quot;#ref-COOKIE&quot;&gt;COOKIE&lt;/a&gt; ]는 세미콜론 ( &quot;;&quot;)을 사용하여 쿠키 쌍 (또는 &quot;경로&quot;)을 구분합니다. 이 헤더 필드는 HTTP의 목록 구성 규칙을 따르지 않습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.2&quot;&gt;[RFC7230], 섹션 3.2.2 참조).&lt;/a&gt;), 쿠키 쌍이 다른 이름-값 쌍으로 분리되는 것을 방지합니다. 이렇게하면 개별 쿠키 쌍이 업데이트 될 때 압축 효율성이 크게 감소 할 수 있습니다. 압축 효율성을 높이기 위해 쿠키 헤더 필드는 각각 하나 이상의 쿠키 쌍이있는 별도의 헤더 필드로 분할 될 수 있습니다. 압축 해제 후 쿠키 헤더 필드가 여러 개있는 경우 HTTP / 2가 아닌 컨텍스트로 전달되기 전에 0x3B, 0x20 (ASCII 문자열 &quot;;&quot;)의 2 옥텟 구분 기호를 사용하여 단일 옥텟 문자열로 연결되어야합니다. HTTP / 1.1 연결 또는 일반 HTTP 서버 애플리케이션으로. 따라서 다음 두 쿠키 헤더 필드 목록은 의미 상 동일합니다. 쿠키 : a = b; c = d; e = f 쿠키 : a = b 쿠키 : c = d 쿠키 : e = f</target>
        </trans-unit>
        <trans-unit id="037f56850e2d9507141cb0bfad334028f9b60f2f" translate="yes" xml:space="preserve">
          <source>The Cross-Origin Resource Sharing standard works by adding new &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; that allow servers to describe the set of origins that are permitted to read that information using a web browser. Additionally, for HTTP request methods that can cause side-effects on server's data (in particular, for HTTP methods other than &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, or for &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; usage with certain &lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;), the specification mandates that browsers &quot;preflight&quot; the request, soliciting supported methods from the server with an HTTP &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request method, and then, upon &quot;approval&quot; from the server, sending the actual request with the actual HTTP request method. Servers can also notify clients whether &quot;credentials&quot; (including &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and HTTP Authentication data) should be sent with requests.</source>
          <target state="translated">Cross-Origin Resource Sharing 표준은 서버가 웹 브라우저를 사용하여 해당 정보를 읽을 수있는 원본 세트를 설명 할 수있는 새로운 &lt;a href=&quot;headers&quot;&gt;HTTP 헤더&lt;/a&gt; 를 추가하여 작동 합니다. 또한 서버 데이터에 부작용을 일으킬 수있는 HTTP 요청 방법 (특히 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 이외의 HTTP 방법 또는 특정 &lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME 유형의 &lt;/a&gt;&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 사용 )의 경우, 사양에서는 브라우저가 요청을 &quot;프리 플라이트&quot;하여 지원되는 방법을 요구합니다. HTTP &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; 요청 메소드를 사용하여 서버에서, 서버에서 &quot;승인&quot;하면 실제 HTTP 요청 메소드로 실제 요청을 보냅니다. 서버는 또한 &quot;신임 정보&quot;여부를 클라이언트에게 알릴 수 있습니다.( &lt;a href=&quot;cookies&quot;&gt;쿠키 포함)&lt;/a&gt;HTTP 인증 데이터)를 요청과 함께 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="a3df3b7b4551cce965a08ca5b788db7477ac35eb" translate="yes" xml:space="preserve">
          <source>The Cross-Origin Resource Sharing standard works by adding new &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; that let servers describe which origins are permitted to read that information from a web browser. Additionally, for HTTP request methods that can cause side-effects on server data (in particular, HTTP methods other than &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; with certain &lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt;), the specification mandates that browsers &quot;preflight&quot; the request, soliciting supported methods from the server with the HTTP &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request method, and then, upon &quot;approval&quot; from the server, sending the actual request. Servers can also inform clients whether &quot;credentials&quot; (such as &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and &lt;a href=&quot;authentication&quot;&gt;HTTP Authentication&lt;/a&gt;) should be sent with requests.</source>
          <target state="translated">Cross-Origin Resource Sharing 표준은 서버가 웹 브라우저에서 해당 정보를 읽을 수있는 출처를 설명 할 수있는 새로운 &lt;a href=&quot;headers&quot;&gt;HTTP 헤더&lt;/a&gt; 를 추가하여 작동 합니다. 또한 서버 데이터에 부작용을 일으킬 수있는 HTTP 요청 메서드 (특히 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 이외의 HTTP 메서드 또는 특정 &lt;a href=&quot;basics_of_http/mime_types&quot;&gt;MIME 유형의 &lt;/a&gt;&lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; )의 경우 사양은 브라우저가 요청을 &quot;프리 플라이트&quot;하여 서버에서 지원되는 메서드를 요청하도록 요구합니다. HTTP &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; 요청 방법을 사용하여 서버에서 &quot;승인&quot;하면 실제 요청을 보냅니다. 서버는 또한 클라이언트에게 &quot;자격 증명&quot;(예 : &lt;a href=&quot;cookies&quot;&gt;쿠키&lt;/a&gt; 및 &lt;a href=&quot;authentication&quot;&gt;HTTP 인증)을&lt;/a&gt; 알릴 수 있습니다.)는 요청과 함께 전송되어야합니다.</target>
        </trans-unit>
        <trans-unit id="858dfd56015c8a42c014f2e88a9adef69bbf8f6d" translate="yes" xml:space="preserve">
          <source>The DELETE method on a collection MUST act as if a &quot;Depth: infinity&quot;
   header was used on it.  A client MUST NOT submit a Depth header with
   a DELETE on a collection with any value but infinity.

   DELETE instructs that the collection specified in the Request-URI and
   all resources identified by its internal member URLs are to be
   deleted.

   If any resource identified by a member URL cannot be deleted, then
   all of the member's ancestors MUST NOT be deleted, so as to maintain
   URL namespace consistency.

   Any headers included with DELETE MUST be applied in processing every
   resource to be deleted.

   When the DELETE method has completed processing, it MUST result in a
   consistent URL namespace.

   If an error occurs deleting a member resource (a resource other than
   the resource identified in the Request-URI), then the response can be
   a 207 (Multi-Status).  Multi-Status is used here to indicate which
   internal resources could NOT be deleted, including an error code,
   which should help the client understand which resources caused the
   failure.  For example, the Multi-Status body could include a response
   with status 423 (Locked) if an internal resource was locked.

   The server MAY return a 4xx status response, rather than a 207, if
   the request failed completely.

   424 (Failed Dependency) status codes SHOULD NOT be in the 207 (Multi-
   Status) response for DELETE.  They can be safely left out because the
   client will know that the ancestors of a resource could not be
   deleted when the client receives an error for the ancestor's progeny.
   Additionally, 204 (No Content) errors SHOULD NOT be returned in the
   207 (Multi-Status).  The reason for this prohibition is that 204 (No
   Content) is the default success code.</source>
          <target state="translated">컬렉션의 DELETE 메소드는 마치 &quot;Depth : infinity&quot;헤더가 사용 된 것처럼 작동해야합니다. 클라이언트는 무한대의 값을 가진 컬렉션에서 DELETE와 함께 깊이 헤더를 제출해서는 안됩니다. DELETE는 Request-URI에 지정된 콜렉션과 해당 내부 구성원 URL로 식별 된 모든 자원을 삭제하도록 지시합니다. 구성원 URL로 식별 된 자원을 삭제할 수없는 경우 URL 네임 스페이스 일관성을 유지하기 위해 모든 구성원의 조상을 삭제해서는 안됩니다. DELETE에 포함 된 모든 헤더는 삭제 될 모든 리소스를 처리하는 데 적용되어야합니다. DELETE 메소드가 처리를 완료하면 URL 네임 스페이스가 일관되어야합니다. 멤버 자원 (Request-URI에서 식별 된 자원 이외의 자원)을 삭제하는 중에 오류가 발생하면,응답은 207 (Multi-Status) 일 수 있습니다. 다중 상태는 여기에서 오류 코드를 포함하여 삭제할 수없는 내부 리소스를 나타 내기 위해 사용되며, 이로 인해 클라이언트가 어떤 리소스가 오류를 일으켰는지 이해할 수 있습니다. 예를 들어, 내부 자원이 잠겨 있으면 다중 상태 본문에 상태 423 (잠김)의 응답이 포함될 수 있습니다. 요청이 완전히 실패한 경우 서버는 207이 아닌 4xx 상태 응답을 반환 할 수 있습니다. 424 (실패 종속성) 상태 코드는 DELETE에 대한 207 (다중 상태) 응답에 있지 않아야합니다. 클라이언트가 조상의 자손에 대한 오류를 수신 할 때 리소스의 조상을 삭제할 수 없다는 것을 클라이언트가 알기 때문에 안전하게 제거 할 수 있습니다. 또한 207 (다중 상태)에서는 204 (콘텐츠 없음) 오류가 반환되지 않아야합니다.이 금지의 이유는 204 (No Content)가 기본 성공 코드이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e71c2610a983fa8562e2bcbd279e311806bf6084" translate="yes" xml:space="preserve">
          <source>The DELETE method requests that the origin server delete the resource
   identified by the Request-URI. This method MAY be overridden by human
   intervention (or other means) on the origin server. The client cannot
   be guaranteed that the operation has been carried out, even if the
   status code returned from the origin server indicates that the action
   has been completed successfully. However, the server SHOULD NOT
   indicate success unless, at the time the response is given, it
   intends to delete the resource or move it to an inaccessible
   location.

   A successful response SHOULD be 200 (OK) if the response includes an
   entity describing the status, 202 (Accepted) if the action has not
   yet been enacted, or 204 (No Content) if the action has been enacted
   but the response does not include an entity.

   If the request passes through a cache and the Request-URI identifies
   one or more currently cached entities, those entries SHOULD be
   treated as stale. Responses to this method are not cacheable.</source>
          <target state="translated">DELETE 메소드는 오리진 서버가 Request-URI로 식별 된 자원을 삭제하도록 요청합니다. 이 방법은 오리진 서버에서 사람의 개입 (또는 다른 수단)에 의해 무시 될 수 있습니다. 오리진 서버에서 리턴 된 상태 코드가 조치가 성공적으로 완료되었음을 표시하더라도 클라이언트는 조작이 수행되었음을 보증 할 수 없습니다. 그러나 서버는 응답이 제공 될 때 리소스를 삭제하거나 액세스 할 수없는 위치로 이동시키지 않는 한 성공을 나타내서는 안됩니다. 응답에 상태를 설명하는 엔터티가 포함 된 경우 성공적인 응답은 200 (OK)이고, 조치가 아직 시행되지 않은 경우 202 (Accepted), 조치가 시행되었지만 응답이 포함되지 않은 경우 204 (No Content) 여야합니다. 실체.요청이 캐시를 통과하고 Request-URI가 현재 캐시 된 하나 이상의 엔티티를 식별하는 경우 해당 항목은 오래된 것으로 취급해야합니다. 이 방법에 대한 응답은 캐시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c974be9fc532fcdd84db91fdeb0ba6b9b0cfa15b" translate="yes" xml:space="preserve">
          <source>The DELETE method requests that the origin server remove the
   association between the target resource and its current
   functionality.  In effect, this method is similar to the rm command
   in UNIX: it expresses a deletion operation on the URI mapping of the
   origin server rather than an expectation that the previously
   associated information be deleted.

   If the target resource has one or more current representations, they
   might or might not be destroyed by the origin server, and the
   associated storage might or might not be reclaimed, depending
   entirely on the nature of the resource and its implementation by the
   origin server (which are beyond the scope of this specification).
   Likewise, other implementation aspects of a resource might need to be
   deactivated or archived as a result of a DELETE, such as database or
   gateway connections.  In general, it is assumed that the origin
   server will only allow DELETE on resources for which it has a
   prescribed mechanism for accomplishing the deletion.

   Relatively few resources allow the DELETE method -- its primary use
   is for remote authoring environments, where the user has some
   direction regarding its effect.  For example, a resource that was
   previously created using a PUT request, or identified via the
   Location header field after a 201 (Created) response to a POST
   request, might allow a corresponding DELETE request to undo those
   actions.  Similarly, custom user agent implementations that implement 

   an authoring function, such as revision control clients using HTTP
   for remote operations, might use DELETE based on an assumption that
   the server's URI space has been crafted to correspond to a version
   repository.

   If a DELETE method is successfully applied, the origin server SHOULD
   send a 202 (Accepted) status code if the action will likely succeed
   but has not yet been enacted, a 204 (No Content) status code if the
   action has been enacted and no further information is to be supplied,
   or a 200 (OK) status code if the action has been enacted and the
   response message includes a representation describing the status.

   A payload within a DELETE request message has no defined semantics;
   sending a payload body on a DELETE request might cause some existing
   implementations to reject the request.

   Responses to the DELETE method are not cacheable.  If a DELETE
   request passes through a cache that has one or more stored responses
   for the effective request URI, those stored responses will be
   invalidated (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">DELETE 메소드는 오리진 서버가 대상 자원과 현재 기능 간의 연관을 제거하도록 요청합니다. 실제로이 방법은 UNIX의 rm 명령과 유사합니다. 이전에 연관된 정보가 삭제 될 것으로 예상하지 않고 원래 서버의 URI 맵핑에서 삭제 조작을 표시합니다. 대상 자원에 하나 이상의 현재 표시가있는 경우, 자원의 특성 및 원래 서버에 의한 구현에 따라 원래 서버에 의해 소멸되거나 소멸되지 않을 수 있으며 연관된 스토리지가 재생되거나 재생되지 않을 수 있습니다 ( 이 사양의 범위를 벗어납니다). 마찬가지로, DELETE의 결과로 리소스의 다른 구현 측면을 비활성화하거나 보관해야 할 수도 있습니다.데이터베이스 또는 게이트웨이 연결과 같은 일반적으로 오리진 서버는 삭제를 수행하기 위해 규정 된 메커니즘이있는 자원에 대해서만 DELETE를 허용한다고 가정합니다. DELETE 방법을 허용하는 리소스는 상대적으로 적습니다. 주된 용도는 원격 제작 환경에서 사용되며 사용자는 그 영향에 대한 방향이 있습니다. 예를 들어, PUT 요청을 사용하여 이전에 작성되었거나 POST 요청에 대한 201 (작성) 응답 후 위치 헤더 필드를 통해 식별 된 자원은 해당 DELETE 요청이 해당 조치를 실행 취소하도록 허용 할 수 있습니다. 마찬가지로, 원격 조작에 HTTP를 사용하는 개정 제어 클라이언트와 같은 작성 기능을 구현하는 사용자 정의 사용자 에이전트 구현에서는 서버의 가정에 따라 DELETE를 사용할 수 있습니다.URI 공간은 버전 저장소에 해당하도록 제작되었습니다. DELETE 방법이 성공적으로 적용되면, 원 서버는 조치가 성공할 수는 있지만 아직 제정되지 않은 경우 202 (수락 됨) 상태 코드를 전송하고, 조치가 제정되었고 더 이상 수행되지 않으면 204 (콘텐츠 없음) 상태 코드를 전송해야합니다. 정보가 제공되거나 조치가 제정되고 응답 메시지에 상태를 설명하는 표현이 포함 된 경우 200 (OK) 상태 코드가 제공됩니다. DELETE 요청 메시지 내의 페이로드에는 정의 된 의미가 없습니다. DELETE 요청에서 페이로드 본문을 전송하면 일부 기존 구현에서 요청을 거부 할 수 있습니다. DELETE 메소드에 대한 응답은 캐시 할 수 없습니다. DELETE 요청이 유효 요청 URI에 대해 하나 이상의 저장된 응답이있는 캐시를 통과하면,저장된 응답은 무효화됩니다 (참조&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;[RFC7234] 4.4 절&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="dd290a0d44bd1aedc43b87181e19c3e8fd871af9" translate="yes" xml:space="preserve">
          <source>The Date general-header field represents the date and time at which
   the message was originated, having the same semantics as orig-date in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;. The field value is an HTTP-date, as described in &lt;a href=&quot;#section-3.3.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt;; it MUST be sent in &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]-date format.

       Date  = &quot;Date&quot; &quot;:&quot; HTTP-date

   An example is

       Date: Tue, 15 Nov 1994 08:12:31 GMT

   Origin servers MUST include a Date header field in all responses,
   except in these cases: 

      1. If the response status code is 100 (Continue) or 101 (Switching
         Protocols), the response MAY include a Date header field, at
         the server's option.

      2. If the response status code conveys a server error, e.g. 500
         (Internal Server Error) or 503 (Service Unavailable), and it is
         inconvenient or impossible to generate a valid Date.

      3. If the server does not have a clock that can provide a
         reasonable approximation of the current time, its responses
         MUST NOT include a Date header field. In this case, the rules
         in &lt;a href=&quot;#section-14.18.1&quot;&gt;section 14.18.1&lt;/a&gt; MUST be followed.

   A received message that does not have a Date header field MUST be
   assigned one by the recipient if the message will be cached by that
   recipient or gatewayed via a protocol which requires a Date. An HTTP
   implementation without a clock MUST NOT cache responses without
   revalidating them on every use. An HTTP cache, especially a shared
   cache, SHOULD use a mechanism, such as NTP [&lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt;], to synchronize its
   clock with a reliable external standard.

   Clients SHOULD only send a Date header field in messages that include
   an entity-body, as in the case of the PUT and POST requests, and even
   then it is optional. A client without a clock MUST NOT send a Date
   header field in a request.

   The HTTP-date sent in a Date header SHOULD NOT represent a date and
   time subsequent to the generation of the message. It SHOULD represent
   the best available approximation of the date and time of message
   generation, unless the implementation has no means of generating a
   reasonably accurate date and time. In theory, the date ought to
   represent the moment just before the entity is generated. In
   practice, the date can be generated at any time during the message
   origination without affecting its semantic value.</source>
          <target state="translated">날짜 일반 헤더 필드는 메시지가 시작된 날짜와 시간을 나타내며 &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822의&lt;/a&gt; orig-date와 동일한 의미를 갖습니다 . 필드 값은 &lt;a href=&quot;#section-3.3.1&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt; 에서 설명한 HTTP 날짜입니다 . 반드시 &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; 으로 보내야합니다. [ &lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]-날짜 형식. Date = &quot;Date&quot; &quot;:&quot;HTTP-date 예는 다음과 같습니다. Date : Tue, 1994 년 11 월 15 일 08:12:31 GMT 오리진 서버는 다음 경우를 제외하고 모든 응답에 Date 헤더 필드를 포함해야합니다. 1. 응답 상태 코드가 100 (계속) 또는 101 (전환 프로토콜)이면 응답에 서버 옵션에 날짜 헤더 필드가 포함될 수 있습니다. 2. 응답 상태 코드가 서버 오류 (예 : 500 (내부 서버 오류) 또는 503 (서비스를 사용할 수 없음))를 전달하는 경우 유효한 날짜를 생성하는 것이 불편하거나 불가능합니다. 3. 서버에 현재 시간의 합리적인 근사치를 제공 할 수있는 시계가없는 경우 응답에 날짜 헤더 필드를 포함해서는 안됩니다. 이 경우&lt;a href=&quot;#section-14.18.1&quot;&gt;섹션 14.18.1 의 규칙&lt;/a&gt;반드시 따라야합니다. 날짜 헤더 필드가없는 수신 된 메시지는 메시지가 해당 수신자에 의해 캐시되거나 날짜가 필요한 프로토콜을 통해 게이트웨이 인 경우 수신자가 하나씩 할당해야합니다. 시계가없는 HTTP 구현은 매번 사용할 때마다 응답을 다시 확인하지 않고 응답을 캐시해서는 안됩니다 (MUST NOT). HTTP 캐시, 특히 공유 캐시는 NTP와 같은 메커니즘을 사용해야합니다 [ &lt;a href=&quot;#ref-28&quot;&gt;28&lt;/a&gt;], 시계를 안정적인 외부 표준과 동기화합니다. 클라이언트는 PUT 및 POST 요청의 경우와 같이 엔터티 본문을 포함하는 메시지로만 날짜 헤더 필드를 보내야하며, 선택 사항이기도합니다. 시계가없는 클라이언트는 요청에 날짜 헤더 필드를 보내서는 안됩니다 (MUST NOT). 날짜 헤더에 전송 된 HTTP 날짜는 메시지 생성 이후의 날짜와 시간을 나타내서는 안됩니다 (SHOULD NOT). 구현에 합리적으로 정확한 날짜와 시간을 생성 할 수단이없는 한, 메시지 생성 날짜와 시간의 가장 근접한 근사값을 나타내야한다. 이론적으로 날짜는 엔터티가 생성되기 직전의 순간을 나타냅니다. 실제로 날짜는 시맨틱 값에 영향을주지 않고 메시지를 생성하는 동안 언제든지 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6903ec22652fb8e7c29947078193d2ba673e0d45" translate="yes" xml:space="preserve">
          <source>The Depth header may be used with the LOCK method.  Values other than
   0 or infinity MUST NOT be used with the Depth header on a LOCK
   method.  All resources that support the LOCK method MUST support the
   Depth header.

   A Depth header of value 0 means to just lock the resource specified
   by the Request-URI.

   If the Depth header is set to infinity, then the resource specified
   in the Request-URI along with all its members, all the way down the
   hierarchy, are to be locked.  A successful result MUST return a
   single lock token.  Similarly, if an UNLOCK is successfully executed
   on this token, all associated resources are unlocked.  Hence, partial
   success is not an option for LOCK or UNLOCK.  Either the entire
   hierarchy is locked or no resources are locked.

   If the lock cannot be granted to all resources, the server MUST
   return a Multi-Status response with a 'response' element for at least
   one resource that prevented the lock from being granted, along with a
   suitable status code for that failure (e.g., 403 (Forbidden) or 423
   (Locked)).  Additionally, if the resource causing the failure was not
   the resource requested, then the server SHOULD include a 'response'
   element for the Request-URI as well, with a 'status' element
   containing 424 Failed Dependency.

   If no Depth header is submitted on a LOCK request, then the request
   MUST act as if a &quot;Depth:infinity&quot; had been submitted.</source>
          <target state="translated">깊이 헤더는 LOCK 메소드와 함께 사용될 수 있습니다. 0 또는 무한대 이외의 값은 LOCK 메소드의 깊이 헤더와 함께 사용해서는 안됩니다 (MUST NOT). LOCK 메소드를 지원하는 모든 자원은 Depth 헤더를 지원해야합니다. 값이 0 인 깊이 헤더는 Request-URI에 의해 지정된 리소스를 잠그는 것을 의미합니다. Depth 헤더가 무한대로 설정되면 Request-URI에 지정된 모든 멤버와 함께 계층 구조에서 내려진 모든 리소스가 잠 깁니다. 성공적인 결과는 반드시 단일 잠금 토큰을 반환해야합니다. 마찬가지로이 토큰에서 UNLOCK이 성공적으로 실행되면 모든 관련 리소스가 잠금 해제됩니다. 따라서 부분 성공은 LOCK 또는 UNLOCK에 대한 옵션이 아닙니다. 전체 계층이 잠겨 있거나 리소스가 잠겨 있지 않습니다. 모든 자원에 잠금을 부여 할 수없는 경우서버는 해당 장애에 대한 적절한 상태 코드 (예 : 403 (Forbidden) 또는 423 (Locked))와 함께 잠금이 부여되지 않은 하나 이상의 리소스에 대해 'response'요소와 함께 Multi-Status 응답을 반환해야합니다. . 또한 장애를 야기한 자원이 요청 된 자원이 아닌 경우, 서버는 Request-URI에 대한 'response'요소를 포함해야하며, 424 Failed Dependency를 포함하는 'status'요소를 포함해야한다. LOCK 요청에 Depth 헤더가 제출되지 않은 경우 요청은 &quot;Depth : infinity&quot;가 제출 된 것처럼 작동해야합니다.403 (금지) 또는 423 (잠금)). 또한 장애를 야기한 자원이 요청 된 자원이 아닌 경우, 서버는 Request-URI에 대한 'response'요소를 포함해야하며, 424 Failed Dependency를 포함하는 'status'요소를 포함해야한다. LOCK 요청에 Depth 헤더가 제출되지 않은 경우 요청은 &quot;Depth : infinity&quot;가 제출 된 것처럼 작동해야합니다.403 (금지) 또는 423 (잠금)). 또한 장애를 야기한 자원이 요청 된 자원이 아닌 경우, 서버는 Request-URI에 대한 'response'요소를 포함해야하며, 424 Failed Dependency를 포함하는 'status'요소를 포함해야한다. LOCK 요청에 Depth 헤더가 제출되지 않은 경우 요청은 &quot;Depth : infinity&quot;가 제출 된 것처럼 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="35342d84dcd43dba8096f5d5b39874e99cb4604b" translate="yes" xml:space="preserve">
          <source>The Destination request header specifies the URI that identifies a
   destination resource for methods such as COPY and MOVE, which take
   two URIs as parameters.

      Destination = &quot;Destination&quot; &quot;:&quot; Simple-ref


   If the Destination value is an absolute-URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;Section&amp;nbsp;4.3 of
   [RFC3986]&lt;/a&gt;), it may name a different server (or different port or
   scheme).  If the source server cannot attempt a copy to the remote
   server, it MUST fail the request.  Note that copying and moving
   resources to remote servers is not fully defined in this
   specification (e.g., specific error conditions). 

   If the Destination value is too long or otherwise unacceptable, the
   server SHOULD return 400 (Bad Request), ideally with helpful
   information in an error body.</source>
          <target state="translated">대상 요청 헤더는 두 개의 URI를 매개 변수로 사용하는 COPY 및 MOVE와 같은 메소드의 대상 자원을 식별하는 URI를 지정합니다. Destination = &quot;Destination&quot; &quot;:&quot;Simple-ref Destination 값이 절대 URI ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;[RFC3986]의 4.3 절&lt;/a&gt; ) 인 경우 다른 서버 (또는 다른 포트 또는 체계)의 이름을 지정할 수 있습니다. 소스 서버가 원격 서버로 복사를 시도 할 수 없으면 요청에 실패해야합니다. 자원을 원격 서버로 복사 및 이동하는 것은이 사양에서 완전히 정의되지 않았습니다 (예 : 특정 오류 조건). Destination 값이 너무 길거나 허용 할 수없는 경우 서버는 이상적으로 오류 본문에 유용한 정보와 함께 400 (잘못된 요청)을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ec562967c3ab4eb672c7b7fd0765b0c9a09d6b8" translate="yes" xml:space="preserve">
          <source>The ETag response-header field provides the current value of the
   entity tag for the requested variant. The headers used with entity
   tags are described in sections &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;, &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; and &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;. The entity tag
   MAY be used for comparison with other entities from the same resource
   (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;).

      ETag = &quot;ETag&quot; &quot;:&quot; entity-tag

   Examples:

      ETag: &quot;xyzzy&quot;
      ETag: W/&quot;xyzzy&quot;
      ETag: &quot;&quot;</source>
          <target state="translated">ETag 응답 헤더 필드는 요청 된 변형에 대한 엔티티 태그의 현재 값을 제공합니다. 엔티티 태그와 함께 사용되는 헤더는 &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt; , &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; 및 &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt; 섹션에 설명되어 있습니다 . 엔티티 태그는 동일한 리소스의 다른 엔티티와 비교하는 데 사용될 수 있습니다 &lt;a href=&quot;#section-13.3.3&quot;&gt;(13.3.3 절&lt;/a&gt; 참조 ). ETag = &quot;ETag&quot; &quot;:&quot;엔티티 태그 예 : ETag : &quot;xyzzy&quot;ETag : W / &quot;xyzzy&quot;ETag : &quot;&quot;</target>
        </trans-unit>
        <trans-unit id="4712a2d0dd6a27be4029656072d6f063c6808073" translate="yes" xml:space="preserve">
          <source>The ETag response-header field value, an entity tag, provides for an
   &quot;opaque&quot; cache validator. This might allow more reliable validation
   in situations where it is inconvenient to store modification dates,
   where the one-second resolution of HTTP date values is not
   sufficient, or where the origin server wishes to avoid certain
   paradoxes that might arise from the use of modification dates.

   Entity Tags are described in &lt;a href=&quot;#section-3.11&quot;&gt;section 3.11&lt;/a&gt;. The headers used with
   entity tags are described in sections &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;, &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt;, &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; and &lt;a href=&quot;#section-14.44&quot;&gt;14.44&lt;/a&gt;.</source>
          <target state="translated">엔티티 태그 인 ETag 응답 헤더 필드 값은 &quot;불투명 한&quot;캐시 유효성 검사기를 제공합니다. 이를 통해 수정 날짜를 저장하는 것이 불편한 상황, HTTP 날짜 값의 1 초 해상도가 충분하지 않은 경우 또는 오리진 서버가 수정 날짜 사용으로 인해 발생할 수있는 특정 역설을 피하려는 경우 더 안정적인 유효성 검증이 가능할 수 있습니다. . 엔터티 태그는 &lt;a href=&quot;#section-3.11&quot;&gt;섹션 3.11에&lt;/a&gt; 설명되어 있습니다 . 엔티티 태그와 함께 사용되는 헤더는 섹션 &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt; , &lt;a href=&quot;#section-14.24&quot;&gt;14.24&lt;/a&gt; , &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; 및 &lt;a href=&quot;#section-14.44&quot;&gt;14.44에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e574d1947b2d7656ccf38b993e2056ebdd1b0a0" translate="yes" xml:space="preserve">
          <source>The Expect request-header field is used to indicate that particular
   server behaviors are required by the client.

      Expect       =  &quot;Expect&quot; &quot;:&quot; 1#expectation

      expectation  =  &quot;100-continue&quot; | expectation-extension
      expectation-extension =  token [ &quot;=&quot; ( token | quoted-string )
                               *expect-params ]
      expect-params =  &quot;;&quot; token [ &quot;=&quot; ( token | quoted-string ) ]


   A server that does not understand or is unable to comply with any of
   the expectation values in the Expect field of a request MUST respond
   with appropriate error status. The server MUST respond with a 417
   (Expectation Failed) status if any of the expectations cannot be met
   or, if there are other problems with the request, some other 4xx
   status.

   This header field is defined with extensible syntax to allow for
   future extensions. If a server receives a request containing an
   Expect field that includes an expectation-extension that it does not
   support, it MUST respond with a 417 (Expectation Failed) status.

   Comparison of expectation values is case-insensitive for unquoted
   tokens (including the 100-continue token), and is case-sensitive for
   quoted-string expectation-extensions. 

   The Expect mechanism is hop-by-hop: that is, an HTTP/1.1 proxy MUST
   return a 417 (Expectation Failed) status if it receives a request
   with an expectation that it cannot meet. However, the Expect
   request-header itself is end-to-end; it MUST be forwarded if the
   request is forwarded.

   Many older HTTP/1.0 and HTTP/1.1 applications do not understand the
   Expect header.

   See &lt;a href=&quot;#section-8.2.3&quot;&gt;section 8.2.3&lt;/a&gt; for the use of the 100 (continue) status.</source>
          <target state="translated">Expect request-header 필드는 클라이언트에 특정 서버 비헤이비어가 필요함을 나타내는 데 사용됩니다. Expect = &quot;Expect&quot; &quot;:&quot;1 # expectation expectation = &quot;100-continue&quot;| expectation-extension expectation-extension = token [ &quot;=&quot;(token | quoted-string) * expect-params] expect-params = &quot;;&quot; token [ &quot;=&quot;(token | quoted-string)] 요청의 Expect 필드에있는 예상 값을 이해하지 못하거나 준수 할 수없는 서버는 적절한 오류 상태로 응답해야합니다. 서버는 기대치를 충족 할 수 없거나 요청에 다른 문제가있는 경우 다른 4xx 상태 인 경우 417 (예상 실패) 상태로 응답해야합니다.이 헤더 필드는 향후 확장을 위해 확장 가능한 구문으로 정의됩니다. 서버가 지원하지 않는 기대 확장이 포함 된 Expect 필드가 포함 된 요청을 수신하면 반드시 417 (예상 실패) 상태로 응답해야합니다. 기대 값 비교는 인용되지 않은 토큰 (100- 연속 토큰 포함)에 대해 대소 문자를 구분하지 않으며 따옴표로 묶인 문자열 기대-확장에 대해서는 대소 문자를 구분합니다. Expect 메커니즘은 홉별 (hop-by-hop)입니다. 즉, HTTP / 1.1 프록시는 충족 할 수 없을 것으로 예상되는 요청을 수신하면 417 (예상 실패) 상태를 리턴해야합니다. 그러나 Expect 요청 헤더 자체는 엔드 투 엔드입니다. 요청이 전달되면 전달되어야합니다. 많은 이전 HTTP / 1.0 및 HTTP / 1.1 애플리케이션은 Expect 헤더를 이해하지 못합니다. 보다보다보다보다보다보다보다서버가 지원하지 않는 기대 확장이 포함 된 Expect 필드가 포함 된 요청을 수신하면 반드시 417 (예상 실패) 상태로 응답해야합니다. 기대 값 비교는 인용되지 않은 토큰 (100- 연속 토큰 포함)에 대해 대소 문자를 구분하지 않으며 따옴표로 묶인 문자열 기대-확장에 대해서는 대소 문자를 구분합니다. Expect 메커니즘은 홉별 (hop-by-hop)입니다. 즉, HTTP / 1.1 프록시는 충족 할 수 없을 것으로 예상되는 요청을 수신하면 417 (예상 실패) 상태를 리턴해야합니다. 그러나 Expect 요청 헤더 자체는 엔드 투 엔드입니다. 요청이 전달되면 전달되어야합니다. 많은 이전 HTTP / 1.0 및 HTTP / 1.1 애플리케이션은 Expect 헤더를 이해하지 못합니다. 보다서버가 지원하지 않는 기대 확장이 포함 된 Expect 필드가 포함 된 요청을 수신하면 반드시 417 (예상 실패) 상태로 응답해야합니다. 기대 값 비교는 인용되지 않은 토큰 (100- 연속 토큰 포함)에 대해 대소 문자를 구분하지 않으며 따옴표로 묶인 문자열 기대-확장에 대해서는 대소 문자를 구분합니다. Expect 메커니즘은 홉별 (hop-by-hop)입니다. 즉, HTTP / 1.1 프록시는 충족 할 수 없을 것으로 예상되는 요청을 수신하면 417 (예상 실패) 상태를 리턴해야합니다. 그러나 Expect 요청 헤더 자체는 엔드 투 엔드입니다. 요청이 전달되면 전달되어야합니다. 많은 이전 HTTP / 1.0 및 HTTP / 1.1 애플리케이션은 Expect 헤더를 이해하지 못합니다. 보다보다보다기대 값 비교는 인용되지 않은 토큰 (100- 연속 토큰 포함)에 대해 대소 문자를 구분하지 않으며 따옴표로 묶인 문자열 기대-확장에 대해서는 대소 문자를 구분합니다. Expect 메커니즘은 홉별 (hop-by-hop)입니다. 즉, HTTP / 1.1 프록시는 충족 할 수 없을 것으로 예상되는 요청을 수신하면 417 (예상 실패) 상태를 리턴해야합니다. 그러나 Expect 요청 헤더 자체는 엔드 투 엔드입니다. 요청이 전달되면 전달되어야합니다. 많은 이전 HTTP / 1.0 및 HTTP / 1.1 애플리케이션은 Expect 헤더를 이해하지 못합니다. 보다기대 값 비교는 인용되지 않은 토큰 (100- 연속 토큰 포함)에 대해 대소 문자를 구분하지 않으며 따옴표로 묶인 문자열 기대-확장에 대해서는 대소 문자를 구분합니다. Expect 메커니즘은 홉별 (hop-by-hop)입니다. 즉, HTTP / 1.1 프록시는 충족 할 수 없을 것으로 예상되는 요청을 수신하면 417 (예상 실패) 상태를 리턴해야합니다. 그러나 Expect 요청 헤더 자체는 엔드 투 엔드입니다. 요청이 전달되면 전달되어야합니다. 많은 이전 HTTP / 1.0 및 HTTP / 1.1 애플리케이션은 Expect 헤더를 이해하지 못합니다. 보다1 프록시는 충족 할 수 없을 것으로 예상되는 요청을 받으면 417 (예상 실패) 상태를 반환해야합니다. 그러나 Expect 요청 헤더 자체는 엔드 투 엔드입니다. 요청이 전달되면 전달되어야합니다. 많은 이전 HTTP / 1.0 및 HTTP / 1.1 애플리케이션은 Expect 헤더를 이해하지 못합니다. 보다1 프록시는 충족 할 수 없을 것으로 예상되는 요청을 받으면 417 (예상 실패) 상태를 반환해야합니다. 그러나 Expect 요청 헤더 자체는 엔드 투 엔드입니다. 요청이 전달되면 전달되어야합니다. 많은 이전 HTTP / 1.0 및 HTTP / 1.1 애플리케이션은 Expect 헤더를 이해하지 못합니다. 보다&lt;a href=&quot;#section-8.2.3&quot;&gt;&lt;/a&gt;100 (계속) 상태 사용에 대한 섹션 8.2.3 .</target>
        </trans-unit>
        <trans-unit id="99ea10caeb88c8a848354c782365979235f3abbc" translate="yes" xml:space="preserve">
          <source>The Expires entity-header field gives the date/time after which the
   response is considered stale. A stale cache entry may not normally be
   returned by a cache (either a proxy cache or a user agent cache)
   unless it is first validated with the origin server (or with an
   intermediate cache that has a fresh copy of the entity). See &lt;a href=&quot;#section-13.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt; for further discussion of the expiration model.

   The presence of an Expires field does not imply that the original
   resource will change or cease to exist at, before, or after that
   time.

   The format is an absolute date and time as defined by HTTP-date in
   &lt;a href=&quot;#section-3.3.1&quot;&gt;section 3.3.1&lt;/a&gt;; it MUST be in &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; date format:

      Expires = &quot;Expires&quot; &quot;:&quot; HTTP-date

   An example of its use is

      Expires: Thu, 01 Dec 1994 16:00:00 GMT

      Note: if a response includes a Cache-Control field with the max-
      age directive (see &lt;a href=&quot;#section-14.9.3&quot;&gt;section 14.9.3&lt;/a&gt;), that directive overrides the
      Expires field.

   HTTP/1.1 clients and caches MUST treat other invalid date formats,
   especially including the value &quot;0&quot;, as in the past (i.e., &quot;already
   expired&quot;).

   To mark a response as &quot;already expired,&quot; an origin server sends an
   Expires date that is equal to the Date header value. (See the rules
   for expiration calculations in &lt;a href=&quot;#section-13.2.4&quot;&gt;section 13.2.4&lt;/a&gt;.) 

   To mark a response as &quot;never expires,&quot; an origin server sends an
   Expires date approximately one year from the time the response is
   sent. HTTP/1.1 servers SHOULD NOT send Expires dates more than one
   year in the future.

   The presence of an Expires header field with a date value of some
   time in the future on a response that otherwise would by default be
   non-cacheable indicates that the response is cacheable, unless
   indicated otherwise by a Cache-Control header field (&lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;).</source>
          <target state="translated">Expires entity-header 필드는 응답이 오래된 것으로 간주 된 날짜 / 시간을 제공합니다. 오래된 캐시 항목은 원래 서버 (또는 엔티티의 새로운 사본이있는 중간 캐시)로 먼저 유효성 검증되지 않는 한 캐시 (프록시 캐시 또는 사용자 에이전트 캐시)에 의해 정상적으로 리턴되지 않을 수 있습니다. 만료 모델에 대한 자세한 내용은 &lt;a href=&quot;#section-13.2&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-13.2&quot;&gt;13.2&lt;/a&gt; 를 참조하십시오 . 만료 필드가 있다고해서 원래 리소스가 해당 시간 전, 후 또는 후에 존재하거나 변경되지 않는다는 것을 의미하지는 않습니다. 형식은 &lt;a href=&quot;#section-3.3.1&quot;&gt;섹션 3.3.1&lt;/a&gt; 에서 HTTP-date로 정의 된 절대 날짜 및 시간입니다 . &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123에&lt;/a&gt; 있어야합니다.날짜 형식 : Expires = &quot;Expires&quot; &quot;:&quot;HTTP-date 사용 예는 Expires : Thu, 1994 년 12 월 01 일 16:00:00 GMT 참고 : 응답에 최대 지시문이있는 Cache-Control 필드가 포함 된 경우 ( &lt;a href=&quot;#section-14.9.3&quot;&gt;14.9.3&lt;/a&gt; 참조 ) 해당 지시문은 만료 필드를 재정의합니다. HTTP / 1.1 클라이언트 및 캐시는 과거와 같이 특히 &quot;0&quot;을 포함하여 다른 유효하지 않은 날짜 형식을 처리해야합니다 (예 : &quot;이미 만료 됨&quot;). 응답을 &quot;이미 만료 됨&quot;으로 표시하기 위해 오리진 서버는 만료 날짜를 Date 헤더 값과 동일하게 보냅니다. ( &lt;a href=&quot;#section-13.2.4&quot;&gt;섹션 13.2.4의&lt;/a&gt; 만료 계산 규칙을 ​​참조하십시오..) 응답이 &quot;만료되지 않음&quot;으로 표시하기 위해 오리진 서버는 응답이 전송 된 날로부터 약 1 년 후에 만료 날짜를 보냅니다. HTTP / 1.1 서버는 앞으로 1 년 이상 만료 날짜를 보내지 않아야합니다. 캐시 할 수없는 기본 응답에 대한 날짜 값이 미래의 시간 인 Expires 헤더 필드가 있으면 캐시 제어 헤더 필드 ( &lt;a href=&quot;#section-14.9&quot;&gt;14.9 절&lt;/a&gt; )에서 다르게 표시하지 않는 한 응답을 캐시 할 수 있음을 나타냅니다. .</target>
        </trans-unit>
        <trans-unit id="074a25a70f6f59d4456b693beabbab06efa52e09" translate="yes" xml:space="preserve">
          <source>The Feature Policy directive to apply the &lt;code&gt;allowlist&lt;/code&gt; to. See &lt;a href=&quot;#Directives&quot;&gt;Directives&lt;/a&gt; below for a list of the permitted directive names.</source>
          <target state="translated">기능 정책 지침은 적용 &lt;code&gt;allowlist&lt;/code&gt; 에 있습니다. 허용되는 지시문 이름 목록은 아래 &lt;a href=&quot;#Directives&quot;&gt;지시문을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="802828c9e44a9d19272a3ae660a11b2bb9d689e1" translate="yes" xml:space="preserve">
          <source>The Feature-Policy HTTP header</source>
          <target state="translated">기능 정책 HTTP 헤더</target>
        </trans-unit>
        <trans-unit id="8b610252bef915d12d88c567e1882bdb3b137742" translate="yes" xml:space="preserve">
          <source>The From request-header field, if given, SHOULD contain an Internet
   e-mail address for the human user who controls the requesting user
   agent. The address SHOULD be machine-usable, as defined by &quot;mailbox&quot;
   in &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] as updated by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;]:

       From   = &quot;From&quot; &quot;:&quot; mailbox

   An example is:

       From: webmaster@w3.org

   This header field MAY be used for logging purposes and as a means for
   identifying the source of invalid or unwanted requests. It SHOULD NOT
   be used as an insecure form of access protection. The interpretation
   of this field is that the request is being performed on behalf of the
   person given, who accepts responsibility for the method performed. In
   particular, robot agents SHOULD include this header so that the
   person responsible for running the robot can be contacted if problems
   occur on the receiving end.

   The Internet e-mail address in this field MAY be separate from the
   Internet host which issued the request. For example, when a request
   is passed through a proxy the original issuer's address SHOULD be
   used.

   The client SHOULD NOT send the From header field without the user's
   approval, as it might conflict with the user's privacy interests or
   their site's security policy. It is strongly recommended that the
   user be able to disable, enable, and modify the value of this field
   at any time prior to a request.</source>
          <target state="translated">From request-header (요청한 요청 헤더) 필드에는 요청하는 사용자 에이전트를 제어하는 ​​사용자의 인터넷 전자 메일 주소가 포함되어야합니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [ &lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt; ]에 의해 업데이트 된 &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]의 &quot;사서함&quot;에 정의 된대로 주소는 기계적으로 사용 가능해야합니다.] : From = &quot;보낸 사람&quot; &quot;:&quot;우편함 예 : From : webmaster@w3.org이 헤더 필드는 로깅 목적 및 유효하지 않거나 원치 않는 요청의 출처를 식별하는 수단으로 사용될 수 있습니다. 안전하지 않은 형태의 액세스 보호로 사용해서는 안됩니다. 이 필드의 해석은 요청 된 사람을 대신하여 요청이 수행되고 있으며, 수행 된 방법에 대한 책임을 수락하는 사람입니다. 특히 로봇 에이전트는이 헤더를 포함해야하므로 수신 측에서 문제가 발생할 경우 로봇 운영 담당자에게 연락 할 수 있습니다. 이 필드의 인터넷 이메일 주소는 요청을 발행 한 인터넷 호스트와 분리 될 수 있습니다. 예를 들어, 요청이 프록시를 통해 전달되면 원래 발급자의주소를 사용해야합니다. 클라이언트는 사용자의 개인 정보 보호 또는 사이트의 보안 정책과 충돌 할 수 있으므로 사용자의 승인없이 보낸 사람 헤더 필드를 보내지 않아야합니다. 사용자는 요청 전에 언제든지이 필드의 값을 비활성화, 활성화 및 수정할 수있는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8a3df35a0d664c78b3c3b6d7181ee8d7a2e5448f" translate="yes" xml:space="preserve">
          <source>The GET method means retrieve whatever information (in the form of an
   entity) is identified by the Request-URI. If the Request-URI refers
   to a data-producing process, it is the produced data which shall be
   returned as the entity in the response and not the source text of the
   process, unless that text happens to be the output of the process.

   The semantics of the GET method change to a &quot;conditional GET&quot; if the
   request message includes an If-Modified-Since, If-Unmodified-Since,
   If-Match, If-None-Match, or If-Range header field. A conditional GET
   method requests that the entity be transferred only under the
   circumstances described by the conditional header field(s). The
   conditional GET method is intended to reduce unnecessary network
   usage by allowing cached entities to be refreshed without requiring
   multiple requests or transferring data already held by the client.

   The semantics of the GET method change to a &quot;partial GET&quot; if the
   request message includes a Range header field. A partial GET requests
   that only part of the entity be transferred, as described in &lt;a href=&quot;#section-14.35&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt;. The partial GET method is intended to reduce unnecessary
   network usage by allowing partially-retrieved entities to be
   completed without transferring data already held by the client.

   The response to a GET request is cacheable if and only if it meets
   the requirements for HTTP caching described in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;.

   See &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations when used for forms.</source>
          <target state="translated">GET 메소드는 Request-URI에 의해 식별되는 모든 정보 (엔티티 형태)를 검색하는 것을 의미합니다. Request-URI가 데이터 생성 프로세스를 참조하는 경우, 해당 텍스트가 프로세스의 출력이 아닌 한, 프로세스의 소스 텍스트가 아닌 응답의 엔티티로 리턴되는 생성 된 데이터입니다. 요청 메시지에 If-Modified-Since, If-Unmodified-Since, If-Match, If-None-Match 또는 If-Range 헤더 필드가 포함 된 경우 GET 메소드의 의미는 &quot;조건부 GET&quot;으로 변경됩니다. 조건부 GET 메소드는 조건부 헤더 필드에 설명 된 상황에서만 엔티티를 전송하도록 요청합니다.조건부 GET 방법은 클라이언트가 이미 보유한 데이터를 여러 번 요청하거나 전송하지 않고도 캐시 된 엔터티를 새로 고치도록하여 불필요한 네트워크 사용을 줄 이도록 고안되었습니다. 요청 메시지에 Range 헤더 필드가 포함 된 경우 GET 메소드의 의미가 &quot;부분 GET&quot;으로 변경됩니다. 부분 GET은 다음에 설명 된대로 엔티티의 일부만 전송하도록 요청합니다.&lt;a href=&quot;#section-14.35&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-14.35&quot;&gt;14.35&lt;/a&gt; . 부분 GET 방법은 클라이언트가 이미 보유한 데이터를 전송하지 않고 부분 검색된 엔티티를 완료 할 수 있도록하여 불필요한 네트워크 사용을 줄 이도록 고안되었습니다. GET 요청에 대한 응답은 &lt;a href=&quot;#section-13&quot;&gt;13 섹션에&lt;/a&gt; 설명 된 HTTP 캐싱 요구 사항을 충족하는 경우에만 캐시 가능합니다 . 양식에 사용될 때 보안 고려 사항은 &lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7fe6f3c8c21eb606abd80993ecfb90185941dd2b" translate="yes" xml:space="preserve">
          <source>The GET method requests transfer of a current selected representation
   for the target resource.  GET is the primary mechanism of information
   retrieval and the focus of almost all performance optimizations.
   Hence, when people speak of retrieving some identifiable information
   via HTTP, they are generally referring to making a GET request.

   It is tempting to think of resource identifiers as remote file system
   pathnames and of representations as being a copy of the contents of
   such files.  In fact, that is how many resources are implemented (see
   &lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt; for related security considerations).  However, there are
   no such limitations in practice.  The HTTP interface for a resource
   is just as likely to be implemented as a tree of content objects, a
   programmatic view on various database records, or a gateway to other
   information systems.  Even when the URI mapping mechanism is tied to
   a file system, an origin server might be configured to execute the
   files with the request as input and send the output as the
   representation rather than transfer the files directly.  Regardless,
   only the origin server needs to know how each of its resource 

   identifiers corresponds to an implementation and how each
   implementation manages to select and send a current representation of
   the target resource in a response to GET.

   A client can alter the semantics of GET to be a &quot;range request&quot;,
   requesting transfer of only some part(s) of the selected
   representation, by sending a Range header field in the request
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]).

   A payload within a GET request message has no defined semantics;
   sending a payload body on a GET request might cause some existing
   implementations to reject the request.

   The response to a GET request is cacheable; a cache MAY use it to
   satisfy subsequent GET and HEAD requests unless otherwise indicated
   by the Cache-Control header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">GET 메소드는 대상 자원에 대해 현재 선택된 표현의 전송을 요청합니다. GET은 정보 검색의 주요 메커니즘이며 거의 모든 성능 최적화의 초점입니다. 따라서 사람들이 HTTP를 통해 식별 가능한 정보를 검색한다고 할 때 일반적으로 GET 요청을 말하는 것입니다. 리소스 식별자를 원격 파일 시스템 경로 이름으로, 표현을 그러한 파일의 내용의 복사본으로 생각하고 있습니다. 실제로, 그것은 구현 된 자원의 수입니다 ( &lt;a href=&quot;#section-9.1&quot;&gt;9.1 절&lt;/a&gt; 참조) 관련 보안 고려 사항). 그러나 실제로는 이러한 제한이 없습니다. 리소스에 대한 HTTP 인터페이스는 콘텐츠 개체 트리, 다양한 데이터베이스 레코드에 대한 프로그래밍 방식보기 또는 다른 정보 시스템으로의 게이트웨이로 구현 될 가능성이 높습니다. URI 맵핑 메커니즘이 파일 시스템에 연결되어 있더라도 오리진 서버는 요청을 입력으로 파일을 실행하고 파일을 직접 전송하지 않고 표현으로 출력을 보내도록 구성 될 수 있습니다. 어쨌든, 오리진 서버 만이 각 자원 식별자가 구현에 해당하는 방법과 각 구현이 GET에 대한 응답으로 대상 자원의 현재 표현을 선택하여 전송하는 방법을 알아야합니다. 클라이언트는 GET의 의미를 &quot;range request &quot;, 요청에 Range 헤더 필드를 전송하여 선택한 표현의 일부만 전송하도록 요청합니다 ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ]). GET 요청 메시지 내의 페이로드에는 정의 된 의미가 없습니다. GET 요청에서 페이로드 본문을 전송하면 일부 기존 구현에서 요청을 거부 할 수 있습니다. GET 요청에 대한 응답은 캐시 가능합니다. 캐시는 Cache-Control 헤더 필드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]의 5.2 절)에&lt;/a&gt; 의해 달리 지시되지 않는 한, 후속 GET 및 HEAD 요청을 만족시키기 위해이를 사용할 수있다 .</target>
        </trans-unit>
        <trans-unit id="7d2462324b684ba6bb0e708d0480d884f24bd586" translate="yes" xml:space="preserve">
          <source>The GOAWAY frame (type=0x7) is used to initiate shutdown of a
   connection or to signal serious error conditions.  GOAWAY allows an
   endpoint to gracefully stop accepting new streams while still
   finishing processing of previously established streams.  This enables
   administrative actions, like server maintenance.

   There is an inherent race condition between an endpoint starting new
   streams and the remote sending a GOAWAY frame.  To deal with this
   case, the GOAWAY contains the stream identifier of the last peer-
   initiated stream that was or might be processed on the sending
   endpoint in this connection.  For instance, if the server sends a
   GOAWAY frame, the identified stream is the highest-numbered stream
   initiated by the client.

   Once sent, the sender will ignore frames sent on streams initiated by
   the receiver if the stream has an identifier higher than the included
   last stream identifier.  Receivers of a GOAWAY frame MUST NOT open
   additional streams on the connection, although a new connection can
   be established for new streams.

   If the receiver of the GOAWAY has sent data on streams with a higher
   stream identifier than what is indicated in the GOAWAY frame, those
   streams are not or will not be processed.  The receiver of the GOAWAY
   frame can treat the streams as though they had never been created at
   all, thereby allowing those streams to be retried later on a new
   connection.

   Endpoints SHOULD always send a GOAWAY frame before closing a
   connection so that the remote peer can know whether a stream has been
   partially processed or not.  For example, if an HTTP client sends a
   POST at the same time that a server closes a connection, the client
   cannot know if the server started to process that POST request if the
   server does not send a GOAWAY frame to indicate what streams it might
   have acted on.

   An endpoint might choose to close a connection without sending a
   GOAWAY for misbehaving peers. 

   A GOAWAY frame might not immediately precede closing of the
   connection; a receiver of a GOAWAY that has no more use for the
   connection SHOULD still send a GOAWAY frame before terminating the
   connection.

    +-+-------------------------------------------------------------+
    |R|                  Last-Stream-ID (31)                        |
    +-+-------------------------------------------------------------+
    |                      Error Code (32)                          |
    +---------------------------------------------------------------+
    |                  Additional Debug Data (*)                    |
    +---------------------------------------------------------------+

                     Figure 13: GOAWAY Payload Format

   The GOAWAY frame does not define any flags.

   The GOAWAY frame applies to the connection, not a specific stream.
   An endpoint MUST treat a GOAWAY frame with a stream identifier other
   than 0x0 as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   The last stream identifier in the GOAWAY frame contains the highest-
   numbered stream identifier for which the sender of the GOAWAY frame
   might have taken some action on or might yet take action on.  All
   streams up to and including the identified stream might have been
   processed in some way.  The last stream identifier can be set to 0 if
   no streams were processed.

      Note: In this context, &quot;processed&quot; means that some data from the
      stream was passed to some higher layer of software that might have
      taken some action as a result.

   If a connection terminates without a GOAWAY frame, the last stream
   identifier is effectively the highest possible stream identifier.

   On streams with lower- or equal-numbered identifiers that were not
   closed completely prior to the connection being closed, reattempting
   requests, transactions, or any protocol activity is not possible,
   with the exception of idempotent actions like HTTP GET, PUT, or
   DELETE.  Any protocol activity that uses higher-numbered streams can
   be safely retried using a new connection.

   Activity on streams numbered lower or equal to the last stream
   identifier might still complete successfully.  The sender of a GOAWAY
   frame might gracefully shut down a connection by sending a GOAWAY
   frame, maintaining the connection in an &quot;open&quot; state until all in-
   progress streams complete. 

   An endpoint MAY send multiple GOAWAY frames if circumstances change.
   For instance, an endpoint that sends GOAWAY with NO_ERROR during
   graceful shutdown could subsequently encounter a condition that
   requires immediate termination of the connection.  The last stream
   identifier from the last GOAWAY frame received indicates which
   streams could have been acted upon.  Endpoints MUST NOT increase the
   value they send in the last stream identifier, since the peers might
   already have retried unprocessed requests on another connection.

   A client that is unable to retry requests loses all requests that are
   in flight when the server closes the connection.  This is especially
   true for intermediaries that might not be serving clients using
   HTTP/2.  A server that is attempting to gracefully shut down a
   connection SHOULD send an initial GOAWAY frame with the last stream
   identifier set to 2^31-1 and a NO_ERROR code.  This signals to the
   client that a shutdown is imminent and that initiating further
   requests is prohibited.  After allowing time for any in-flight stream
   creation (at least one round-trip time), the server can send another
   GOAWAY frame with an updated last stream identifier.  This ensures
   that a connection can be cleanly shut down without losing requests.

   After sending a GOAWAY frame, the sender can discard frames for
   streams initiated by the receiver with identifiers higher than the
   identified last stream.  However, any frames that alter connection
   state cannot be completely ignored.  For instance, HEADERS,
   PUSH_PROMISE, and CONTINUATION frames MUST be minimally processed to
   ensure the state maintained for header compression is consistent (see
   &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;); similarly, DATA frames MUST be counted toward the
   connection flow-control window.  Failure to process these frames can
   cause flow control or header compression state to become
   unsynchronized.

   The GOAWAY frame also contains a 32-bit error code (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) that
   contains the reason for closing the connection.

   Endpoints MAY append opaque data to the payload of any GOAWAY frame.
   Additional debug data is intended for diagnostic purposes only and
   carries no semantic value.  Debug information could contain security-
   or privacy-sensitive data.  Logged or otherwise persistently stored
   debug data MUST have adequate safeguards to prevent unauthorized
   access.</source>
          <target state="translated">GOAWAY 프레임 (유형 = 0x7)은 연결 종료를 시작하거나 심각한 오류 조건을 알리는 데 사용됩니다. GOAWAY를 사용하면 엔드 포인트가 이전에 설정된 스트림의 처리를 완료하는 동안 새 스트림 수락을 정상적으로 중지 할 수 있습니다. 이를 통해 서버 유지 관리와 같은 관리 작업을 수행 할 수 있습니다. 새로운 스트림을 시작하는 엔드 포인트와 GOAWAY 프레임을 보내는 원격지간에 고유 한 경쟁 조건이 있습니다. 이 경우를 처리하기 위해 GOAWAY에는이 연결의 송신 엔드 포인트에서 처리되었거나 처리되었을 수있는 마지막 피어 시작 스트림의 스트림 식별자가 포함됩니다. 예를 들어, 서버가 GOAWAY 프레임을 보내는 경우 식별 된 스트림은 클라이언트가 시작한 가장 높은 번호의 스트림입니다. 일단 전송되면송신자는 스트림에 포함 된 마지막 스트림 식별자보다 높은 식별자가있는 경우 수신자가 시작한 스트림에서 전송 된 프레임을 무시합니다. GOAWAY 프레임의 수신자는 새로운 스트림에 대해 새로운 연결을 설정할 수 있지만 연결에서 추가 스트림을 열지 않아야합니다. GOAWAY의 수신자가 GOAWAY 프레임에 표시된 것보다 높은 스트림 식별자를 가진 스트림에서 데이터를 보낸 경우 해당 스트림은 처리되지 않거나 처리되지 않습니다. GOAWAY 프레임의 수신자는 스트림을 전혀 생성되지 않은 것처럼 처리 할 수 ​​있으므로 나중에 새 연결에서 해당 스트림을 다시 시도 할 수 있습니다. 엔드 포인트는 연결을 닫기 전에 항상 GOAWAY 프레임을 보내야 원격 피어가 스트림이 부분적으로 처리되었는지 여부를 알 수 있습니다. 예를 들면HTTP 클라이언트가 서버가 연결을 닫는 동시에 POST를 보내는 경우, 서버가 작동했을 수있는 스트림을 나타 내기 위해 GOAWAY 프레임을 보내지 않으면 클라이언트는 서버가 POST 요청을 처리하기 시작했는지 알 수 없습니다. 엔드 포인트는 오작동하는 피어에 대해 GOAWAY를 보내지 않고 연결을 닫도록 선택할 수 있습니다. GOAWAY 프레임은 연결 닫기 직전에 있지 않을 수 있습니다. 연결에 더 이상 사용하지 않는 GOAWAY의 수신자는 연결을 종료하기 전에 GOAWAY 프레임을 전송해야합니다.+-+ ----------------------------------------------- -------------- + | R | 마지막 스트림 ID (31) | +-+ ----------------------------------------------- -------------- + | 오류 코드 (32) | + ------------------------------------------------- -------------- + | 추가 디버그 데이터 (*) | + ------------------------------------------------- -------------- + 그림 13 : GOAWAY 페이로드 형식 GOAWAY 프레임은 플래그를 정의하지 않습니다. GOAWAY 프레임은 특정 스트림이 아닌 연결에 적용됩니다. 엔드 포인트는 0x0 이외의 스트림 식별자가있는 GOAWAY 프레임을 연결 오류 (&lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1 절&lt;/a&gt;) PROTOCOL_ERROR 유형입니다. GOAWAY 프레임의 마지막 스트림 식별자에는 GOAWAY 프레임의 송신자가 어떤 조치를 취했거나 아직 조치를 취할 수있는 가장 높은 번호의 스트림 식별자가 포함됩니다. 식별 된 스트림까지 포함하여 모든 스트림이 어떤 방식 으로든 처리되었을 수 있습니다. 스트림이 처리되지 않은 경우 마지막 스트림 식별자를 0으로 설정할 수 있습니다. 참고 :이 컨텍스트에서 &quot;처리됨&quot;은 스트림의 일부 데이터가 결과적으로 일부 조치를 취했을 수있는 상위 소프트웨어 계층으로 전달되었음을 의미합니다. 연결이 GOAWAY 프레임없이 종료되면 마지막 스트림 식별자가 사실상 가능한 가장 높은 스트림 식별자입니다. 연결이 닫히기 전에 완전히 닫히지 않은 더 낮거나 같은 번호의 식별자가있는 스트림에서 요청, 트랜잭션,또는 HTTP GET, PUT 또는 DELETE와 같은 멱등 적 작업을 제외하고는 프로토콜 작업이 불가능합니다. 더 높은 번호의 스트림을 사용하는 모든 프로토콜 활동은 새 연결을 사용하여 안전하게 재 시도 할 수 있습니다. 마지막 스트림 식별자보다 낮거나 같은 번호가 지정된 스트림의 활동은 여전히 ​​성공적으로 완료 될 수 있습니다. GOAWAY 프레임을 보낸 사람은 진행중인 모든 스트림이 완료 될 때까지 연결을 &quot;열린&quot;상태로 유지하면서 GOAWAY 프레임을 전송하여 연결을 정상적으로 종료 할 수 있습니다. 상황이 변하면 엔드 포인트는 여러 GOAWAY 프레임을 보낼 수 있습니다. 예를 들어, 정상 종료 중에 NO_ERROR와 함께 GOAWAY를 보내는 엔드 포인트는 이후에 연결을 즉시 종료해야하는 조건이 발생할 수 있습니다.수신 된 마지막 GOAWAY 프레임의 마지막 스트림 식별자는 어떤 스트림에 대해 작동 할 수 있는지를 나타냅니다. 피어가 이미 다른 연결에서 처리되지 않은 요청을 재 시도했을 수 있으므로 엔드 포인트는 마지막 스트림 식별자에서 보내는 값을 늘리면 안됩니다. 요청을 재 시도 할 수없는 클라이언트는 서버가 연결을 닫을 때 진행중인 모든 요청을 잃게됩니다. 이는 특히 HTTP / 2를 사용하여 클라이언트에 서비스를 제공하지 않을 수있는 중개자에게 해당됩니다. 연결을 정상적으로 종료하려는 서버는 마지막 스트림 식별자가 2 ^ 31-1로 설정된 초기 GOAWAY 프레임과 NO_ERROR 코드를 전송해야합니다. 이는 종료가 임박하고 추가 요청을 시작할 수 없음을 클라이언트에 알립니다. 기내 스트림 생성을위한 시간 (최소 1 회 왕복 시간)을 허용 한 후서버는 업데이트 된 마지막 스트림 식별자와 함께 다른 GOAWAY 프레임을 보낼 수 있습니다. 이렇게하면 요청을 잃지 않고 연결을 완전히 종료 할 수 있습니다. GOAWAY 프레임을 보낸 후 발신자는 식별 된 마지막 스트림보다 높은 식별자를 사용하여 수신자가 시작한 스트림의 프레임을 버릴 수 있습니다. 그러나 연결 상태를 변경하는 프레임은 완전히 무시할 수 없습니다. 예를 들어 HEADERS, PUSH_PROMISE 및 CONTINUATION 프레임은 헤더 압축을 위해 유지되는 상태가 일관되게 유지되도록 최소한으로 처리되어야합니다 (참조송신자는 식별 된 마지막 스트림보다 높은 식별자를 사용하여 수신자가 시작한 스트림에 대한 프레임을 버릴 수 있습니다. 그러나 연결 상태를 변경하는 프레임은 완전히 무시할 수 없습니다. 예를 들어 HEADERS, PUSH_PROMISE 및 CONTINUATION 프레임은 헤더 압축을 위해 유지되는 상태가 일관되게 유지되도록 최소한으로 처리되어야합니다 (참조송신자는 식별 된 마지막 스트림보다 높은 식별자를 사용하여 수신자가 시작한 스트림에 대한 프레임을 버릴 수 있습니다. 그러나 연결 상태를 변경하는 프레임은 완전히 무시할 수 없습니다. 예를 들어 HEADERS, PUSH_PROMISE 및 CONTINUATION 프레임은 헤더 압축을 위해 유지되는 상태가 일관되게 유지되도록 최소한으로 처리되어야합니다 (참조&lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt; ); 마찬가지로, DATA 프레임은 연결 흐름 제어 창에 포함되어야합니다. 이러한 프레임을 처리하지 못하면 흐름 제어 또는 헤더 압축 상태가 동기화되지 않을 수 있습니다. GOAWAY 프레임에는 연결 종료 이유 가 포함 된 32 비트 오류 코드 ( &lt;a href=&quot;#section-7&quot;&gt;섹션 7&lt;/a&gt; )도 포함되어 있습니다. 엔드 포인트는 GOAWAY 프레임의 페이로드에 불투명 한 데이터를 추가 할 수 있습니다. 추가 디버그 데이터는 진단 목적으로 만 사용되며 의미 값을 전달하지 않습니다. 디버그 정보에는 보안 또는 개인 정보에 민감한 데이터가 포함될 수 있습니다. 기록되거나 영구적으로 저장된 디버그 데이터에는 무단 액세스를 방지하기위한 적절한 보호 장치가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5094fc44298eab7b1db803d184d5d22fe3243b4b" translate="yes" xml:space="preserve">
          <source>The General Data Privacy Regulation (GDPR) in the European Union</source>
          <target state="translated">유럽 ​​연합의 GDPR (General Data Privacy Regulation)</target>
        </trans-unit>
        <trans-unit id="7df79dab20c7e00cfdc0198d8b7108bafe0b904f" translate="yes" xml:space="preserve">
          <source>The HEAD method is identical to GET except that the server MUST NOT
   return a message-body in the response. The metainformation contained
   in the HTTP headers in response to a HEAD request SHOULD be identical
   to the information sent in response to a GET request. This method can
   be used for obtaining metainformation about the entity implied by the
   request without transferring the entity-body itself. This method is
   often used for testing hypertext links for validity, accessibility,
   and recent modification.

   The response to a HEAD request MAY be cacheable in the sense that the
   information contained in the response MAY be used to update a
   previously cached entity from that resource. If the new field values
   indicate that the cached entity differs from the current entity (as
   would be indicated by a change in Content-Length, Content-MD5, ETag
   or Last-Modified), then the cache MUST treat the cache entry as
   stale.</source>
          <target state="translated">HEAD 메소드는 서버가 응답으로 메시지 본문을 리턴해서는 안된다는 점을 제외하고는 GET과 동일합니다. HEAD 요청에 대한 응답으로 HTTP 헤더에 포함 된 메타 정보는 GET 요청에 대한 응답으로 전송 된 정보와 동일해야합니다. 이 방법은 엔티티 본문 자체를 전송하지 않고 요청에 의해 암시 된 엔티티에 대한 메타 정보를 얻는 데 사용할 수 있습니다. 이 방법은 유효성, 접근성 및 최근 수정 사항에 대해 하이퍼 텍스트 링크를 테스트하는 데 자주 사용됩니다. HEAD 요청에 대한 응답은 응답에 포함 된 정보가 해당 리소스에서 이전에 캐시 된 엔티티를 업데이트하는 데 사용될 수 있다는 의미에서 캐시 가능할 수 있습니다.새로운 필드 값이 캐시 된 엔티티가 현재 엔티티와 다르다는 것을 표시하는 경우 (Content-Length, Content-MD5, ETag 또는 Last-Modified의 변경으로 표시됨) 캐시는 캐시 항목을 오래된 것으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="af87f0a9948cd0c865e17fe40c999f5f6559a626" translate="yes" xml:space="preserve">
          <source>The HEAD method is identical to GET except that the server MUST NOT
   send a message body in the response (i.e., the response terminates at
   the end of the header section).  The server SHOULD send the same
   header fields in response to a HEAD request as it would have sent if
   the request had been a GET, except that the payload header fields
   (&lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;) MAY be omitted.  This method can be used for obtaining
   metadata about the selected representation without transferring the
   representation data and is often used for testing hypertext links for
   validity, accessibility, and recent modification.

   A payload within a HEAD request message has no defined semantics;
   sending a payload body on a HEAD request might cause some existing
   implementations to reject the request.

   The response to a HEAD request is cacheable; a cache MAY use it to
   satisfy subsequent HEAD requests unless otherwise indicated by the
   Cache-Control header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;).  A HEAD
   response might also have an effect on previously cached responses to
   GET; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.5&quot;&gt;Section&amp;nbsp;4.3.5 of [RFC7234]&lt;/a&gt;.</source>
          <target state="translated">HEAD 메소드는 서버가 응답으로 메시지 본문을 보내서는 안된다는 점을 제외하고 GET과 동일합니다 (즉, 헤더 섹션의 끝에서 응답이 종료 됨). 서버는 페이로드 헤더 필드를 제외하고 요청이 GET이었을 때 보낸 것과 동일한 헤더 필드를 HEAD 요청에 대한 응답으로 보내야한다 ( &lt;a href=&quot;#section-3.3&quot;&gt;섹션 3.3).&lt;/a&gt;) 생략 될 수 있습니다. 이 방법은 표현 데이터를 전송하지 않고 선택된 표현에 대한 메타 데이터를 얻는 데 사용될 수 있으며, 유효성, 접근성 및 최근 수정을 위해 하이퍼 텍스트 링크를 테스트하는 데 종종 사용됩니다. HEAD 요청 메시지 내의 페이로드에는 정의 된 의미가 없습니다. HEAD 요청에서 페이로드 본문을 전송하면 일부 기존 구현에서 요청을 거부 할 수 있습니다. HEAD 요청에 대한 응답은 캐시 가능합니다. 캐시는 Cache-Control 헤더 필드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234]의 5.2 절)에&lt;/a&gt; 의해 다르게 지시되지 않는 한 후속 HEAD 요청을 만족시키기 위해이를 사용할 수있다 . HEAD 응답은 GET에 대한 이전에 캐시 된 응답에도 영향을 줄 수 있습니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.3.5&quot;&gt;[RFC7234]의 4.3.5 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b66172e68b0534fed4eb909af19fada53af1789" translate="yes" xml:space="preserve">
          <source>The HEADERS frame (type=0x1) is used to open a stream (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;),
   and additionally carries a header block fragment.  HEADERS frames can
   be sent on a stream in the &quot;idle&quot;, &quot;reserved (local)&quot;, &quot;open&quot;, or
   &quot;half-closed (remote)&quot; state. 

    +---------------+
    |Pad Length? (8)|
    +-+-------------+-----------------------------------------------+
    |E|                 Stream Dependency? (31)                     |
    +-+-------------+-----------------------------------------------+
    |  Weight? (8)  |
    +-+-------------+-----------------------------------------------+
    |                   Header Block Fragment (*)                 
    +---------------------------------------------------------------+
    |                           Padding (*)                       
    +---------------------------------------------------------------+

                      Figure 7: HEADERS Frame Payload

   The HEADERS frame payload has the following fields:

   Pad Length:  An 8-bit field containing the length of the frame
      padding in units of octets.  This field is only present if the
      PADDED flag is set.

   E: A single-bit flag indicating that the stream dependency is
      exclusive (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  This field is only present if the
      PRIORITY flag is set.

   Stream Dependency:  A 31-bit stream identifier for the stream that
      this stream depends on (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  This field is only
      present if the PRIORITY flag is set.

   Weight:  An unsigned 8-bit integer representing a priority weight for
      the stream (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  Add one to the value to obtain a
      weight between 1 and 256.  This field is only present if the
      PRIORITY flag is set.

   Header Block Fragment:  A header block fragment (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).

   Padding:  Padding octets.

   The HEADERS frame defines the following flags:

   END_STREAM (0x1):  When set, bit 0 indicates that the header block
      (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) is the last that the endpoint will send for the
      identified stream.

      A HEADERS frame carries the END_STREAM flag that signals the end
      of a stream.  However, a HEADERS frame with the END_STREAM flag
      set can be followed by CONTINUATION frames on the same stream.
      Logically, the CONTINUATION frames are part of the HEADERS frame. 

   END_HEADERS (0x4):  When set, bit 2 indicates that this frame
      contains an entire header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) and is not followed
      by any CONTINUATION frames.

      A HEADERS frame without the END_HEADERS flag set MUST be followed
      by a CONTINUATION frame for the same stream.  A receiver MUST
      treat the receipt of any other type of frame or a frame on a
      different stream as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
      PROTOCOL_ERROR.

   PADDED (0x8):  When set, bit 3 indicates that the Pad Length field
      and any padding that it describes are present.

   PRIORITY (0x20):  When set, bit 5 indicates that the Exclusive Flag
      (E), Stream Dependency, and Weight fields are present; see
      &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;.

   The payload of a HEADERS frame contains a header block fragment
   (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).  A header block that does not fit within a HEADERS
   frame is continued in a CONTINUATION frame (&lt;a href=&quot;#section-6.10&quot;&gt;Section 6.10&lt;/a&gt;).

   HEADERS frames MUST be associated with a stream.  If a HEADERS frame
   is received whose stream identifier field is 0x0, the recipient MUST
   respond with a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   The HEADERS frame changes the connection state as described in
   &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;.

   The HEADERS frame can include padding.  Padding fields and flags are
   identical to those defined for DATA frames (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).  Padding
   that exceeds the size remaining for the header block fragment MUST be
   treated as a PROTOCOL_ERROR.

   Prioritization information in a HEADERS frame is logically equivalent
   to a separate PRIORITY frame, but inclusion in HEADERS avoids the
   potential for churn in stream prioritization when new streams are
   created.  Prioritization fields in HEADERS frames subsequent to the
   first on a stream reprioritize the stream (&lt;a href=&quot;#section-5.3.3&quot;&gt;Section 5.3.3&lt;/a&gt;).</source>
          <target state="translated">HEADERS 프레임 (유형 = 0x1)은 스트림을 여는 데 사용됩니다 ( &lt;a href=&quot;#section-5.1&quot;&gt;섹션 5.1&lt;/a&gt;), 추가로 헤더 블록 조각을 전달합니다. HEADERS 프레임은 &quot;유휴&quot;, &quot;예약 됨 (로컬)&quot;, &quot;열림&quot;또는 &quot;반 닫힘 (원격)&quot;상태의 스트림으로 전송 될 수 있습니다. + --------------- + | 패드 길이? (8) | +-+ ------------- + --------------------------------- -------------- + | E | 스트림 의존성? (31) | +-+ ------------- + --------------------------------- -------------- + | 무게? (8) | +-+ ------------- + --------------------------------- -------------- + | 헤더 블록 조각 (*) + ------------------------------------------- -------------------- + | 패딩 (*) + --------------------------------------------- ------------------ + 그림 7 : HEADERS 프레임 페이로드 HEADERS 프레임 페이로드에는 다음 필드가 있습니다. Pad Length : 프레임 패딩의 길이를 포함하는 8 비트 필드 옥텟 단위.이 필드는 PADDED 플래그가 설정된 경우에만 존재합니다. E : 스트림 종속성이 배타적임을 나타내는 단일 비트 플래그 (&lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt; ). 이 필드는 PRIORITY 플래그가 설정된 경우에만 존재합니다. 스트림 종속성 :이 스트림이 의존하는 스트림에 대한 31 비트 스트림 식별자 ( &lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt; 참조 ). 이 필드는 PRIORITY 플래그가 설정된 경우에만 존재합니다. 가중치 : 스트림의 우선 순위 가중치를 나타내는 부호없는 8 비트 정수입니다 ( &lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt; 참조 ). 값에 1을 추가하여 1과 256 사이의 가중치를 얻습니다.이 필드는 PRIORITY 플래그가 설정된 경우에만 존재합니다. 헤더 블록 조각 : 헤더 블록 조각 ( &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt; ). 패딩 : 패딩 옥텟. HEADERS 프레임은 다음 플래그를 정의합니다. END_STREAM (0x1) : 설정되면 비트 0은 헤더 블록을 나타냅니다 ( &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt;)는 엔드 포인트가 식별 된 스트림에 대해 보낼 마지막입니다. HEADERS 프레임은 스트림의 끝을 알리는 END_STREAM 플래그를 전달합니다. 그러나 END_STREAM 플래그가 설정된 HEADERS 프레임 뒤에는 동일한 스트림에서 CONTINUATION 프레임이 올 수 있습니다. 논리적으로 CONTINUATION 프레임은 HEADERS 프레임의 일부입니다. END_HEADERS (0x4) : 설정되면 비트 2는이 프레임이 전체 헤더 블록 ( &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt; )을 포함하고 CONTINUATION 프레임이 뒤 따르지 않음을 나타냅니다 . END_HEADERS 플래그가 설정되지 않은 HEADERS 프레임 뒤에는 동일한 스트림에 대한 CONTINUATION 프레임이 와야합니다. 수신자는 다른 유형의 프레임 또는 다른 스트림의 프레임 수신을 연결 오류로 취급해야합니다 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt;) PROTOCOL_ERROR 유형입니다. PADDED (0x8) : 설정된 경우 비트 3은 Pad Length 필드와 설명하는 모든 패딩이 있음을 나타냅니다. PRIORITY (0x20) : 설정되면 비트 5는 배타적 플래그 (E), 스트림 종속성 및 가중치 필드가 있음을 나타냅니다. &lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3을&lt;/a&gt; 참조하십시오 . HEADERS 프레임의 페이로드는 헤더 블록 조각을 포함합니다 ( &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt; ). HEADERS 프레임에 맞지 않는 헤더 블록은 CONTINUATION 프레임에서 계속됩니다 ( &lt;a href=&quot;#section-6.10&quot;&gt;섹션 6.10&lt;/a&gt; ). HEADERS 프레임은 스트림과 연결되어야합니다. 스트림 식별자 필드가 0x0 인 HEADERS 프레임이 수신되면 수신자 는 PROTOCOL_ERROR 유형 의 연결 오류 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt; )로 응답해야 합니다. HEADERS 프레임은 다음에 설명 된대로 연결 상태를 변경합니다.&lt;a href=&quot;#section-4.3&quot;&gt;4.3 항&lt;/a&gt; . HEADERS 프레임에는 패딩이 포함될 수 있습니다. 패딩 필드 및 플래그는 DATA 프레임에 대해 정의 된 것과 동일합니다 ( &lt;a href=&quot;#section-6.1&quot;&gt;섹션 6.1&lt;/a&gt; ). 헤더 블록 조각에 대해 남은 크기를 초과하는 패딩은 PROTOCOL_ERROR로 처리해야합니다. HEADERS 프레임의 우선 순위 정보는 논리적으로 별도의 PRIORITY 프레임과 동일하지만 HEADERS에 포함하면 새 스트림이 생성 될 때 스트림 우선 순위가 변동될 가능성이 없습니다. 스트림의 첫 번째 이후 HEADERS 프레임의 우선 순위 필드는 스트림의 우선 순위를 다시 지정합니다 ( &lt;a href=&quot;#section-5.3.3&quot;&gt;섹션 5.3.3&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5fa0cc40bb9e4667e351329947478703648e5a09" translate="yes" xml:space="preserve">
          <source>The HTML of &lt;code&gt;signup.html&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;signup.html&lt;/code&gt; 의 HTML은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7de3d21abd96bd4beb67ffb6ec818595df38d03d" translate="yes" xml:space="preserve">
          <source>The HTTP 1.1 (only) &lt;code&gt;Upgrade&lt;/code&gt; header can be used to upgrade an already established client/server connection to a different protocol (over the same transport protocol). For example, it can be used by a client to upgrade a connection from HTTP 1.1 to HTTP 2.0, or an HTTP or HTTPS connection into a WebSocket.</source>
          <target state="translated">HTTP 1.1 (전용) &lt;code&gt;Upgrade&lt;/code&gt; 헤더를 사용하여 이미 설정된 클라이언트 / 서버 연결을 다른 프로토콜 (동일한 전송 프로토콜을 통해 )로 업그레이드 할 수 있습니다. 예를 들어 클라이언트가 HTTP 1.1에서 HTTP 2.0으로 연결을 업그레이드하거나 HTTP 또는 HTTPS 연결을 WebSocket으로 업그레이드하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e4ed100d87a6355dfbd6e285bdb4feb98fdc0d9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets over HTTP when the page uses HTTPS.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; 지시문은 페이지가 HTTPS를 사용할 때 HTTP를 통해 자산을로드하지 못하도록합니다.</target>
        </trans-unit>
        <trans-unit id="f9ee255be05b605cffc50bf531b8bbc6cd52f1c8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets using HTTP when the page is loaded using HTTPS.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; 지시문은 페이지가 HTTPS를 사용하여로드 될 때 HTTP를 사용하여 자산을로드하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="9387c952373df9470c27016caf452ee055a0a173" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect-src&lt;/strong&gt;&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect-src&lt;/strong&gt;&lt;/code&gt; 지시문은 스크립트 인터페이스를 사용하여로드 할 수있는 URL을 제한합니다. 제한되는 API는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a4307301fcd6bb5ccdab9143ff3528885084251b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 스크립트 인터페이스를 사용하여로드 할 수있는 URL을 제한합니다. 제한되는 API는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="182931c21e0e507ac442ba7fad6c85f7022aa1b1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent will look for the &lt;code&gt;default-src&lt;/code&gt; directive and will use this value for it:</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 다른 CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;페치 지시문&lt;/a&gt; 의 폴백 역할을합니다 . 없는 다음 지시문 각각에 대해 사용자 에이전트는 &lt;code&gt;default-src&lt;/code&gt; 지시문을 찾아이 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="df6b0aa2488b0f60a06ea64f5f84252e16a5ba40" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt; 사용하여로드 된 글꼴의 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="b26fdbf4c8f95b8df3d8b6830742e1c693873add" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-action&lt;/code&gt; directive restricts the URLs which can be used as the target of a form submissions from a given context.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-action&lt;/code&gt; 지시문은 주어진 컨텍스트에서 양식 제출의 대상으로 사용할 수있는 URL을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="e3702b120d46e550d906d2d9a8d47f7b89a394a2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; directive specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; 를&lt;/a&gt; 사용하여 페이지를 임베드 할 수있는 유효한 상위를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="e7a99a281dc2a7e2980a9a7cde577543fea1d6f5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 과 같은 요소를 사용하여 중첩 된 브라우징 컨텍스트로드에 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="f35361ac952ed5107a00ab5b6446fbed51185da5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media-src&lt;/strong&gt;&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 사용하여 미디어를로드하기위한 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="39e405945a5f6f3e5caa215c10fb1ba16c926f41" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 사용하여 미디어를로드하기위한 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="a5cc0adb408b4a8f77493eae319c581cf4526353" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;navigate&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-to&lt;/code&gt; directive restricts the URLs to which a document can initiate navigations by any means including &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;&lt;/a&gt; (if &lt;a href=&quot;form-action&quot;&gt;&lt;code&gt;form-action&lt;/code&gt;&lt;/a&gt; is not specified), &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/location&quot;&gt;&lt;code&gt;window.location&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt;&lt;code&gt;window.open&lt;/code&gt;&lt;/a&gt;, etc. This is an enforcement on what navigations this document initiates &lt;strong&gt;not&lt;/strong&gt; on what this document is allowed to navigate to.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;navigate&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-to&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt; &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;form-action&quot;&gt; &lt;code&gt;form-action&lt;/code&gt; &lt;/a&gt; 이 지정되지 않은 경우), &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/location&quot;&gt; &lt;code&gt;window.location&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt; &lt;code&gt;window.open&lt;/code&gt; &lt;/a&gt; 를 포함하여 문서가 탐색을 시작할 수있는 URL을 제한합니다. .open 등이이 문서 동수 내비게이션 무엇에 집행입니다 &lt;strong&gt;하지&lt;/strong&gt; 이 문서를 탐색 할 수 있는지에.</target>
        </trans-unit>
        <trans-unit id="8d107e0a38faf65b9362f0868294c5f1f868d7aa" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; directive restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; 지시문은로드 할 수있는 자원 유형을 제한하여 문서에 포함 할 수있는 플러그인 세트를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="f6e050006d74c56b081d711041cc2a29932e1bfd" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;prefetch-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid resources that may be prefetched or prerendered.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;prefetch-src&lt;/strong&gt;&lt;/code&gt; 지시문은 미리 가져 오거나 미리 렌더링 할 수있는 유효한 리소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6ad6e328ff3b4fb09016b0d4cd3b23b2ef304500" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; directive used to specify information in the &lt;a href=&quot;../referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header (with a single &lt;code&gt;r&lt;/code&gt; as this was a typo in the original spec) for links away from a page. This API is deprecated and removed from browsers.</source>
          <target state="translated">페이지로부터의 링크 에 대한 &lt;a href=&quot;../referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; 헤더에 정보를 지정하는 데 사용되는 CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; 지시문 ( 원래 스펙의 오타 인 단일 &lt;code&gt;r&lt;/code&gt; 과 함께 ) 이 API는 더 이상 사용되지 않으며 브라우저에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="871ccac3ab2ff9b3690d358a4ea40b08884840e9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;require-trusted-types-for&lt;/strong&gt;&lt;/code&gt;  directive instructs user agents to control the data passed to DOM XSS sink functions, like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML&quot;&gt;Element.innerHTML&lt;/a&gt; setter.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;require-trusted-types-for&lt;/strong&gt;&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/innerHTML&quot;&gt;Element.innerHTML&lt;/a&gt; setter 와 같은 DOM XSS 싱크 함수에 전달되는 데이터를 제어하도록 사용자 에이전트에 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="8f8670f822879a6c1f70bb6696d4385c9e028089" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; directive enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute. It applies restrictions to a page's actions including preventing popups, preventing the execution of plugins and scripts, and enforcing a same-origin policy.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; 속성 과 유사한 요청 된 리소스에 대한 샌드 박스를 활성화 합니다. 팝업 방지, 플러그인 및 스크립트 실행 방지, 동일 출처 정책 시행 등 페이지 작업에 제한을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="a54e3f9dc9e10d181fcc5b9d14de91d2158ed49a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src-attr&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript inline event handlers. This includes only inline script event handlers like &lt;code&gt;onclick&lt;/code&gt;, but not URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src-attr&lt;/strong&gt;&lt;/code&gt; 지시문은 JavaScript 인라인 이벤트 핸들러의 유효한 소스를 지정합니다. 여기에는 &lt;code&gt;onclick&lt;/code&gt; 과 같은 인라인 스크립트 이벤트 핸들러 만 포함 되며 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 직접로드 된 URL 은 포함 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="63d32345b8cf84239a5bf4892731d98708512218" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript. This includes not only URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but also things like inline script event handlers (&lt;code&gt;onclick&lt;/code&gt;) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT stylesheets&lt;/a&gt; which can trigger script execution.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; 지시문은 JavaScript의 유효한 소스를 지정합니다. 여기에는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 직접로드 된 URL 뿐만 아니라 스크립트 실행을 트리거 할 수있는 인라인 스크립트 이벤트 핸들러 ( &lt;code&gt;onclick&lt;/code&gt; ) 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT 스타일 시트&lt;/a&gt; 와 같은 것도 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="ae949c0f5a7694445f0b27c386a8832b1c5e94b2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src-attr&lt;/code&gt; directive specifies valid sources for inline styles applied to individual DOM elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src-attr&lt;/code&gt; 지시문은 개별 DOM 요소에 적용된 인라인 스타일에 대한 유효한 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4e52836f01982774b986b243c0c4f29e000b612f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src-elem&lt;/code&gt; directive specifies valid sources for stylesheets &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; elements and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; elements with &lt;code&gt;rel=&quot;stylesheet&quot;&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src-elem&lt;/code&gt; 지시문 은 &lt;code&gt;rel=&quot;stylesheet&quot;&lt;/code&gt; 가있는&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; 시트 &amp;lt;style&amp;gt; 요소 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 대한 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="e2a780dcd99b14cfc49a43bc74102f1ed0b2e3e6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 스타일 시트에 유효한 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="7b3e13bcd5d8d9f7bcf64acc3459db7ca20c7578" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;trusted-types&lt;/strong&gt;&lt;/code&gt;  directive instructs user agents to restrict the creation of Trusted Types policies - functions that build non-spoofable, typed values intended to be passed to DOM XSS sinks in place of strings.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;trusted-types&lt;/strong&gt;&lt;/code&gt; 지시문은 사용자 에이전트가 신뢰할 수있는 유형 정책 (문자열 대신 DOM XSS 싱크로 전달되는 스푸핑 불가능한 유형 값을 빌드하는 함수)의 생성을 제한하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="591de896ab33256052ca0797fb955116eff15e90" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; directive instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS). This directive is intended for web sites with large numbers of insecure legacy URLs that need to be rewritten.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; 지시문은 사용자 에이전트가 모든 사이트의 안전하지 않은 URL (HTTP를 통해 제공되는 URL)을 보안 URL (HTTPS를 통해 제공되는 URL)로 교체 한 것처럼 처리하도록 지시합니다. 이 지시문은 다시 작성해야하는 안전하지 않은 기존 URL이 많은 웹 사이트를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="32ff6a8bc2363d0ff4f3086755b7248183c5b34b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt; 스크립트에 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="3acbb37620b5c60ffd911d6cef85fd1eada27d24" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;child-src&lt;/code&gt; directive defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;. For workers, non-compliant requests are treated as fatal network errors by the user agent.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;child-src&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 과 같은 요소를 사용하여로드 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;웹 작업자&lt;/a&gt; 및 중첩 된 브라우징 컨텍스트에 대한 유효한 소스를 정의합니다 . 작업자의 경우 비준수 요청은 사용자 에이전트에 의해 치명적인 네트워크 오류로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="7f5b4e1965627b7bb6308888f53e91d8ff996658" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;default-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent looks for the &lt;code&gt;default-src&lt;/code&gt; directive and uses this value for it:</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;default-src&lt;/code&gt; 지시문은 다른 CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch 지시문에&lt;/a&gt; 대한 대체 역할을합니다 . 없는 다음 지시문 각각에 대해 사용자 에이전트는 &lt;code&gt;default-src&lt;/code&gt; 지시문을 찾아이 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9204eef966021c11aedbb0e9fb96b1228c1de8f2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;script-src-elem&lt;/code&gt; directive specifies valid sources for JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but not inline script event handlers like &lt;code&gt;onclick&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;script-src-elem&lt;/code&gt; 지시문은 JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소의 유효한 소스를 지정 하지만 &lt;code&gt;onclick&lt;/code&gt; 과 같은 인라인 스크립트 이벤트 핸들러는 지정하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2aa9970523d0f2da18a413ddfa67a54c01337b6d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;style-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;style-src&lt;/code&gt; 지시문은 스타일 시트의 유효한 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="275423427a5662144b985c69ef01612f4d51c0a4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: &lt;strong&gt;manifest-src&lt;/strong&gt;&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: &lt;strong&gt;manifest-src&lt;/strong&gt;&lt;/code&gt; 지시문 은 리소스에 적용 할 수 있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;매니페스트를&lt;/a&gt; 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="5a8c324b7db31bcba8cef085e4b98f52d8cd17a3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;:&lt;/code&gt;&lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;:&lt;/code&gt; &lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문 은 리소스에 적용 할 수 있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;매니페스트를&lt;/a&gt; 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="8d10806c81e23539dc0cc263131762383ee75c31" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img-src&lt;/strong&gt;&lt;/code&gt; 지시문은 유효한 이미지 및 파비콘 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b239689551cd0c9430aba9321c015f59f5b7ee6a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 이미지 및 즐겨 찾기 아이콘의 유효한 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f43d22faa65da48c48f2987c23a1ac5f2d7480b1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object-src&lt;/strong&gt;&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 대한 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="4db12171daec1cecdac720828f51ca0a57d2ce24" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="a75713e06f850d30f3c1d3897dfbb65c817d0a9c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; 지시문은 클라이언트가 페이지의 스크립트 또는 스타일에 대해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;하위 자원 무결성&lt;/a&gt; 을 사용하도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="a32f782eaaf1368e46240e1ae4c440922d0f70d0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;base-uri&lt;/code&gt; directive restricts the URLs which can be used in a document's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element. If this value is absent, then any URI is allowed. If this directive is absent, the user agent will use the value in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">HTTP &lt;a href=&quot;../content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;base-uri&lt;/code&gt; 지시문은 문서의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에서 사용할 수있는 URL을 제한합니다 . 이 값이 없으면 모든 URI가 허용됩니다. 이 지시문이 없으면 사용자 에이전트는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 값을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="e0361bbd3e19dd4db920260e46f1803df2efaa1a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;accelerometer&lt;/code&gt; directive controls whether the current document is allowed to gather information about the acceleration of the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Accelerometer&quot;&gt;&lt;code&gt;Accelerometer&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;accelerometer&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Accelerometer&quot;&gt; &lt;code&gt;Accelerometer&lt;/code&gt; &lt;/a&gt; 인터페이스를 통해 장치의 가속에 대한 정보를 수집 할 수 있는지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="92c66228b38d0470e96db98a40225a18c2d3231a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;ambient-light-sensor&lt;/code&gt; directive controls whether the current document is allowed to gather information about the amount of light in the environment around the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AmbientLightSensor&quot;&gt;&lt;code&gt;AmbientLightSensor&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;ambient-light-sensor&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/AmbientLightSensor&quot;&gt; &lt;code&gt;AmbientLightSensor&lt;/code&gt; &lt;/a&gt; 인터페이스를 통해 기기 주변 환경의 빛의 양에 대한 정보를 수집 할 수 있는지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="358c131c1d5a8c89c254e16cfb1b9e90fee71186" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio#attr-autoplay&quot;&gt;autoplay&lt;/a&gt;&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;autoplay&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt; &lt;code&gt;HTMLMediaElement&lt;/code&gt; &lt;/a&gt; 인터페이스를 통해 요청 된 미디어를 자동 재생하도록 허용할지 여부를 제어합니다 . 이 정책이 사용 설정되고 사용자 동작이없는 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt; &lt;code&gt;HTMLMediaElement.play()&lt;/code&gt; &lt;/a&gt; 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 과 함께 거부됩니다 . &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio#attr-autoplay&quot;&gt;autoplay&lt;/a&gt;&lt;/code&gt; 속성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="01c9ca551ef322fcef92f79b3a236ae1ba63f558" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;. The &lt;code&gt;autoplay&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;autoplay&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt; &lt;code&gt;HTMLMediaElement&lt;/code&gt; &lt;/a&gt; 인터페이스를 통해 요청 된 미디어를 자동 재생하도록 허용되는지 여부를 제어합니다 . 이 정책이 활성화되어 있고 사용자 제스처가 없으면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt; &lt;code&gt;HTMLMediaElement.play()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;DOMException&lt;/code&gt; 으로 거부됩니다 . &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 &lt;code&gt;autoplay&lt;/code&gt; 속성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9bd2e515d62f7d6ede21b6f102d6e75bcfdc2806" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;battery&lt;/code&gt; directive controls whether the current document is allowed to gather information about the battery of the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/BatteryManager&quot;&gt;&lt;code&gt;BatteryManager&lt;/code&gt;&lt;/a&gt; interface obtained via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getBattery&quot;&gt;&lt;code&gt;Navigator.getBattery()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;battery&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getBattery&quot;&gt; &lt;code&gt;Navigator.getBattery()&lt;/code&gt; &lt;/a&gt; 를 통해 얻은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/BatteryManager&quot;&gt; &lt;code&gt;BatteryManager&lt;/code&gt; &lt;/a&gt; 인터페이스를 통해 현재 문서가 기기 배터리에 대한 정보를 수집 할 수 있는지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="7087babf47c5844e7ac3510edec835b831437673" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/NotAllowedError&quot;&gt;&lt;code&gt;NotAllowedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;camera&lt;/code&gt; 지시문은 현재 문서에서 비디오 입력 장치를 사용할 수 있는지 여부를 제어합니다. 이 정책을 사용하면, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 에 의해 반환 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt; 로모그래퍼 거부합니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/NotAllowedError&quot;&gt; &lt;code&gt;NotAllowedError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89ab43068a1ce03c2c700695396807b764653f4c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;camera&lt;/code&gt; 지시문은 현재 문서에서 비디오 입력 장치를 사용할 수 있는지 여부를 제어합니다. 이 정책을 사용하면, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 에 의해 반환 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt; 로모그래퍼 거부합니다 &lt;code&gt;NotAllowedError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a38d3aba5839b81049ae1c111db31f4dd2359f9e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;display-capture&lt;/code&gt; directive controls whether or not the document is permitted to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen_Capture_API&quot;&gt;Screen Capture API&lt;/a&gt;, i.e.,&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia&quot;&gt;&lt;code&gt;getDisplayMedia()&lt;/code&gt;&lt;/a&gt; to capture the screen's contents.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;display-capture&lt;/code&gt; 지시문은 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen_Capture_API&quot;&gt;Screen Capture API&lt;/a&gt; , 즉 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getDisplayMedia&quot;&gt; &lt;code&gt;getDisplayMedia()&lt;/code&gt; &lt;/a&gt; 를 사용하여 화면 내용을 캡처 하도록 허용할지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="0509b709eb9c12fa1d36b479d880843a32939bb2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;document-domain&lt;/code&gt; directive controls whether the current document is allowed to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, attempting to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt; will fail and cause a &lt;code&gt;SecurityError&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; to be be thrown.</source>
          <target state="translated">는 HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;document-domain&lt;/code&gt; 현재 문서가 세트로 허용되는지 여부를 지시 컨트롤 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; 을&lt;/a&gt; . 이 정책을 사용하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt; 설정 시도 가 실패하고 &lt;code&gt;SecurityError&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="db2a12cedfc96871f58d6b87b88cf7641d46244e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;encrypted-media&lt;/code&gt; 지시문은 현재 문서가 EME ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API) 를 사용할 수 있는지 여부를 제어합니다 . 이 정책을 사용하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt; &lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt; &lt;/a&gt; 반환 한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 과 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="c66dd6d4d4a75699b185decdfad8e45e19e0002d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;encrypted-media&lt;/code&gt; 지시문은 현재 문서가 EME ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API) 를 사용할 수 있는지 여부를 제어합니다 . 이 정책이 활성화되면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt; &lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;DOMException&lt;/code&gt; 과 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e8d5d79df5028bcf829983040e4f5d620f67f63" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;fullscreen&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt;&lt;code&gt;Element.requestFullScreen()&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, the returned &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; rejects with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;fullscreen&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt; &lt;code&gt;Element.requestFullScreen()&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있는지 여부를 제어합니다 . 이 정책을 사용하면 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 와 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="cb70b85868a9918e7c850de1c73663ec03ac5340" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;geolocation&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt;&lt;code&gt;Geolocation&lt;/code&gt;&lt;/a&gt; Interface. When this policy is enabled, calls to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt;&lt;code&gt;getCurrentPosition()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt;&lt;code&gt;watchPosition()&lt;/code&gt;&lt;/a&gt; will cause those functions' callbacks to be invoked with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt;&lt;code&gt;PositionError&lt;/code&gt;&lt;/a&gt; code of &lt;code&gt;PERMISSION_DENIED&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;geolocation&lt;/code&gt; 지정 문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt; &lt;code&gt;Geolocation&lt;/code&gt; &lt;/a&gt; 인터페이스 를 사용할 수 있는지 여부를 제어합니다 . 이 정책이 활성화되면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt; &lt;code&gt;getCurrentPosition()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt; &lt;code&gt;watchPosition()&lt;/code&gt; &lt;/a&gt; 을 호출하면 &lt;code&gt;PERMISSION_DENIED&lt;/code&gt; 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt; &lt;code&gt;PositionError&lt;/code&gt; &lt;/a&gt; 코드로 해당 함수의 콜백이 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1aa24dbbd3715af81f21828a56fabf5ec110953" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;gyroscope&lt;/code&gt; directive controls whether the current document is allowed to gather information about the orientation of the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Gyroscope&quot;&gt;&lt;code&gt;Gyroscope&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;gyroscope&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Gyroscope&quot;&gt; &lt;code&gt;Gyroscope&lt;/code&gt; &lt;/a&gt; 인터페이스를 통해 장치의 방향에 대한 정보를 수집 할 수 있는지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="85ff5966dce2b9c7b7600a4d4c06b6e4b170f277" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;layout-animations&lt;/code&gt; directive controls whether the current document is allowed to show layout animations.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;layout-animations&lt;/code&gt; 지시문은 현재 문서가 레이아웃 애니메이션을 표시 할 수 있는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="79581f7e39deb619df4e34954f818f674b43f16f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;legacy-image-formats&lt;/code&gt; directive controls whether the current document is allowed to display images in legacy formats.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;legacy-image-formats&lt;/code&gt; 지시문은 현재 문서가 기존 형식으로 이미지를 표시 할 수 있는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="dcb5ebff50a1c299f3cfff78c80e0f15d5569925" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;magnetometer&lt;/code&gt; directive controls whether the current document is allowed to gather information about the orientation of the device through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Magnetometer&quot;&gt;&lt;code&gt;Magnetometer&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 자 &lt;code&gt;magnetometer&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Magnetometer&quot;&gt; &lt;code&gt;Magnetometer&lt;/code&gt; &lt;/a&gt; 인터페이스를 통해 장치 방향에 대한 정보를 수집 할 수 있는지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="d88583ce1eab6212205a0ce4ec5269a6f045f6b3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;microphone&lt;/code&gt; directive controls whether the current document is allowed to use audio input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;microphone&lt;/code&gt; 지시문은 현재 문서에서 오디오 입력 장치를 사용할 수 있는지 여부를 제어합니다. 이 정책을 사용하면, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 에 의해 반환 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt; 로모그래퍼 거부합니다 &lt;code&gt;NotAllowedError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f61a9280d76cca41de0c10b1bb571562297d206c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;midi&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt;&lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;midi&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt; 를 사용할 수 있는지 여부를 제어합니다 . 이 정책이 활성화되면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt; &lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;DOMException&lt;/code&gt; 으로 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="7143f5b43341ab71af365409875146a8699bd3ea" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;oversized-images&lt;/code&gt; directive controls whether the current document is allowed to download and display large images.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;oversized-images&lt;/code&gt; 지시문은 현재 문서가 큰 이미지를 다운로드하고 표시 할 수 있는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="ad49b71ef86ec5410e8de76cba85903aa7fec02d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;code&gt;SecurityError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;payment&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;지불 요청 API&lt;/a&gt; 를 사용할 수 있는지 여부를 제어합니다 . 이 정책을 사용하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt; &lt;code&gt;PaymentRequest()&lt;/code&gt; &lt;/a&gt; 생성자가 &lt;code&gt;SecurityError&lt;/code&gt; 를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="1bf49ec28a205e1ed0b001dfbdb9aa642280ff0c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;picture-in-picture&lt;/code&gt; directive controls whether the current document is allowed to play a video in a Picture-in-Picture mode via the corresponding API.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;picture-in-picture&lt;/code&gt; 지시문은 현재 문서가 해당 API를 통해 Picture-in-Picture 모드에서 비디오를 재생할 수 있는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="2ebcad6e4fbff3f317a76c00d82e77cbe034d342" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;publickey-credentials-get&lt;/code&gt; directive controls whether the current document is allowed to access &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API&quot;&gt;Web Authentcation API&lt;/a&gt; to create new public-key credentials, i.e, via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get&quot;&gt;&lt;code&gt;navigator.credentials.get({publicKey: ..., ...})&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;publickey-credentials-get&lt;/code&gt; 현재 문서 액세스가 허용되는지 여부를 지시 컨트롤 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Authentication_API&quot;&gt;웹 Authentcation의 API&lt;/a&gt; 새로운 공개 키 인증서를 만들을 예를 통해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CredentialsContainer/get&quot;&gt; &lt;code&gt;navigator.credentials.get({publicKey: ..., ...})&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f5bf4e9f3fed1765343fd59a9718f4cd6d7d27d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;screen-wake-lock&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen_Wake_Lock_API&quot;&gt;Screen Wake Lock API&lt;/a&gt; to indicate that device should not dim or turn off the screen.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;screen-wake-lock&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Screen_Wake_Lock_API&quot;&gt;Screen Wake Lock API&lt;/a&gt; 를 사용하여 기기가 화면을 어둡게하거나 꺼서는 안됨을 표시 하도록 허용할지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="d480f24830d984d0930580ca8ddada9de45700d1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;sync-xhr&lt;/code&gt; directive controls whether the current document is allowed to make synchronous &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; requests.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;sync-xhr&lt;/code&gt; 지시문은 현재 문서가 동기 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 요청 을 만들 수 있는지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="2a58ad5a409b3b1c3a41e1e839795597dc6204dc" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;unoptimized-images&lt;/code&gt; directive controls whether the current document is allowed to download and display unoptimized images.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;unoptimized-images&lt;/code&gt; 지시문은 현재 문서가 최적화되지 않은 이미지를 다운로드하고 표시 할 수 있는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="d80682ef1147e80bdbff00f43c45c04f77992134" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;unsized-media&lt;/code&gt; directive controls whether the current document is allowed to change the size of media elements after the initial layout is complete.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;unsized-media&lt;/code&gt; 지시문은 초기 레이아웃이 완료된 후 현재 문서가 미디어 요소의 크기를 변경할 수 있는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="3ad639cf0153cfd80980b0affb3cc2e1e990de76" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vibrate&lt;/code&gt;  directive controls whether the current document is allowed to trigger device vibrations via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/vibrate&quot;&gt;&lt;code&gt;Navigator.vibrate()&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Vibration_API&quot;&gt;Vibration API&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;vibrate&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Vibration_API&quot;&gt;Vibration API&lt;/a&gt; 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/vibrate&quot;&gt; &lt;code&gt;Navigator.vibrate()&lt;/code&gt; &lt;/a&gt; 메서드를 통해 장치 진동을 트리거 할 수 있는지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="596ebd10a4b879fc3f494e6c070eefbc8b1b78da" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;vr&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt; 를 사용할 수 있는지 여부를 제어합니다 . 이 정책을 사용하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt; &lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt; &lt;/a&gt; 반환 한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 과 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="cf81d231c67dd1b00b85de64c8fcc4e2241cad31" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;vr&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt; 를 사용할 수 있는지 여부를 제어합니다 . 이 정책을 사용하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt; &lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;DOMException&lt;/code&gt; 과 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="15c0f9c5a8e9e08ad03923f24381554ed8b9ab1c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;wake-lock&lt;/code&gt; directive controls whether the current document is allowed to use Wake Lock API to indicate that device should not enter power-saving mode.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;wake-lock&lt;/code&gt; 지시문은 현재 문서가 Wake Lock API를 사용하여 장치가 절전 모드로 들어 가지 않도록 표시 할 수 있는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="269d13c10993281fbc573c770f836b44bc5f308a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;web-share&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share&quot;&gt;&lt;code&gt;Navigator.share()&lt;/code&gt;&lt;/a&gt; method of the Web Share API to share text, links, images, and other content to arbitrary destinations of the user's choice.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;web-share&lt;/code&gt; 지시문은 현재 문서가 Web Share API 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/share&quot;&gt; &lt;code&gt;Navigator.share()&lt;/code&gt; &lt;/a&gt; 메서드 를 사용하여 텍스트, 링크, 이미지 및 기타 콘텐츠를 사용자가 선택한 임의의 대상에 공유 할 수 있는지 여부를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="62dced3e4a986bc5373d1a7961ad28c776d2c977" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;xr-spatial-tracking&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API&quot;&gt;WebXR Device API&lt;/a&gt;. This policy controls whether &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XR/requestSession&quot;&gt;&lt;code&gt;navigator.xr.requestSession()&lt;/code&gt;&lt;/a&gt; can return &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XRSession&quot;&gt;&lt;code&gt;XRSession&lt;/code&gt;&lt;/a&gt; that requires spatial tracking and whether user agent can indicate support for sessions supporting spatial tracking via &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XR/isSessionSupported&quot;&gt;&lt;code&gt;navigator.xr.isSessionSupported()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/devicechange&quot;&gt;devicechange&lt;/a&gt;&lt;/code&gt; event on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/xr&quot;&gt;&lt;code&gt;navigator.xr&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;xr-spatial-tracking&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API&quot;&gt;WebXR Device API&lt;/a&gt; 를 사용할 수 있는지 여부를 제어합니다 . 이 정책은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XR/requestSession&quot;&gt; &lt;code&gt;navigator.xr.requestSession()&lt;/code&gt; &lt;/a&gt; 이 공간 추적이 필요한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XRSession&quot;&gt; &lt;code&gt;XRSession&lt;/code&gt; &lt;/a&gt; 을 반환 할 수 있는지 여부와 사용자 에이전트가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/xr&quot;&gt; &lt;code&gt;navigator.xr&lt;/code&gt; &lt;/a&gt; 객체의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XR/isSessionSupported&quot;&gt; &lt;code&gt;navigator.xr.isSessionSupported()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Events/devicechange&quot;&gt;devicechange&lt;/a&gt;&lt;/code&gt; 이벤트를 통해 공간 추적을 지원하는 세션에 대한 지원을 표시 할 수 있는지 여부를 제어 합니다.</target>
        </trans-unit>
        <trans-unit id="a4136ce714258747e9ae7bb826711d2f7370051e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header field's &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is disabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 필드의 &lt;code&gt;payment&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;지불 요청 API&lt;/a&gt; 를 사용할 수 있는지 여부를 제어합니다 . 이 정책이 사용 중지되면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt; &lt;code&gt;PaymentRequest()&lt;/code&gt; &lt;/a&gt; 생성자가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="085032760c08ad9b9fdf7e3304ad0c84d9aeabf7" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;../feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header usb directive controls whether the current document is allowed to use the WebUSB API.</source>
          <target state="translated">HTTP &lt;a href=&quot;../feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 usb 지시문은 현재 문서가 WebUSB API를 사용할 수 있는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="90bd59abf141ac2acd0d6eb93603dfbb20ca13bb" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; directive prevents loading any assets using HTTP when the page is loaded using HTTPS.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;block-all-mixed-content&lt;/strong&gt;&lt;/code&gt; 지시문은 페이지가 HTTPS를 사용하여로드 될 때 HTTP를 사용하여 자산을로드하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="2c130ba07e36557d606dab5e0daeea1174e0f829" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive restricts the URLs which can be loaded using script interfaces. The APIs that are restricted are:</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;connect&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 스크립트 인터페이스를 사용하여로드 할 수있는 URL을 제한합니다. 제한되는 API는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f9e44e9310d4af0da6d15e0f9e8b89d123612c88" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive serves as a fallback for the other CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;fetch directives&lt;/a&gt;. For each of the following directives that are absent, the user agent will look for the &lt;code&gt;default-src&lt;/code&gt; directive and will use this value for it:</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;default&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 다른 CSP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/fetch_directive&quot;&gt;페치 지시문&lt;/a&gt; 의 폴백 역할을합니다 . 없는 다음 지시문 각각에 대해 사용자 에이전트는 &lt;code&gt;default-src&lt;/code&gt; 지시문을 찾아이 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="872a0ce0f866c4f403e5c4fdabdba2ac75e64283" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for fonts loaded using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt;&lt;code&gt;@font-face&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;font&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face&quot;&gt; &lt;code&gt;@font-face&lt;/code&gt; &lt;/a&gt; 사용하여로드 된 글꼴의 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="89db1b08f92d8384d90536ecc2f476ece38912e3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-action&lt;/code&gt; directive restricts the URLs which can be used as the target of a form submissions from a given context.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;form&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-action&lt;/code&gt; 지시문은 지정된 컨텍스트에서 양식 제출 대상으로 사용할 수있는 URL을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="53e746d6be4fd9b5eb3832de56d4365f491df6d6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; directive specifies valid parents that may embed a page using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;frame-ancestors&lt;/strong&gt;&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; 를&lt;/a&gt; 사용하여 페이지를 임베드 할 수있는 유효한 상위를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="60434b7f567fe8e897910e8b6a67bd2318a07eda" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for nested browsing contexts loading using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;frame-src&lt;/strong&gt;&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 과 같은 요소를 사용하여 중첩 된 브라우징 컨텍스트로드에 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="af2c302ddc10d3d222e0a67e09b8d5d05e052366" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for loading media using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;media&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 사용하여 미디어를로드하기위한 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="3d40cffb60b43134b32f0810a5ed2a290fe665f6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; directive restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;plugin-types&lt;/strong&gt;&lt;/code&gt; 지시문은로드 할 수있는 자원 유형을 제한하여 문서에 포함 할 수있는 플러그인 세트를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="bdd0798eaf4df1ffabbf8a0c8d7aa4c0dbd9e69b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; directive used to specify information in the &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header (with a single &lt;code&gt;r&lt;/code&gt; as this was a typo in the original spec) for links away from a page. This API is deprecated and removed from browsers.</source>
          <target state="translated">페이지에서 떨어진 링크 에 대한 &lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; 헤더에 정보를 지정하는 데 사용되는 CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;referrer&lt;/strong&gt;&lt;/code&gt; 지시문 ( 원래 스펙의 오타 인 단일 &lt;code&gt;r&lt;/code&gt; 과 함께 ) 이 API는 더 이상 사용되지 않으며 브라우저에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="befd663ba9deb24fd4ec2918a5d6109d2636a2d4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; directive enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute. It applies restrictions to a page's actions including preventing popups, preventing the execution of plugins and scripts, and enforcing a same-origin policy.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;sandbox&lt;/strong&gt;&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; 속성 과 유사한 요청 된 리소스에 대한 샌드 박스를 활성화 합니다. 팝업 방지, 플러그인 및 스크립트 실행 방지, 동일 출처 정책 시행 등 페이지 작업에 제한을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="5b8d334a3bce170c8993d25e4d184932264ac72f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for JavaScript. This includes not only URLs loaded directly into &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, but also things like inline script event handlers (&lt;code&gt;onclick&lt;/code&gt;) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT stylesheets&lt;/a&gt; which can trigger script execution.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;script-src&lt;/strong&gt;&lt;/code&gt; 지시문은 JavaScript의 유효한 소스를 지정합니다. 여기에는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 직접로드 된 URL 뿐만 아니라 스크립트 실행을 트리거 할 수있는 인라인 스크립트 이벤트 핸들러 ( &lt;code&gt;onclick&lt;/code&gt; ) 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/XSLT&quot;&gt;XSLT 스타일 시트&lt;/a&gt; 와 같은 것들도 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="8cef37884cea47d641cdd47c4c37fa6b8ac6254c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for sources for stylesheets.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 스타일 시트 소스의 유효한 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="27cf15a50bbcd9352999ad2ec374352073190e0d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for stylesheets.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;style&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 스타일 시트의 유효한 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="8a7e1c437a2a4b57d25b681153a76fdfe0cd58a0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; directive instructs user agents to treat all of a site's insecure URLs (those served over HTTP) as though they have been replaced with secure URLs (those served over HTTPS). This directive is intended for web sites with large numbers of insecure legacy URLs that need to be rewritten.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;upgrade-insecure-requests&lt;/strong&gt;&lt;/code&gt; 지시문은 사용자 에이전트가 모든 사이트의 안전하지 않은 URL (HTTP를 통해 제공되는 URL)을 보안 URL (HTTPS를 통해 제공되는 URL)로 교체 한 것처럼 처리하도록 지시합니다. 이 지시문은 다시 작성해야하는 안전하지 않은 기존 URL이 많은 웹 사이트를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c6470e7d04b8abe1f65b75c4d51906723a206d5d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; (CSP) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; directive specifies valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt;&lt;code&gt;Worker&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt;&lt;code&gt;SharedWorker&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt;&lt;code&gt;ServiceWorker&lt;/code&gt;&lt;/a&gt; scripts.</source>
          <target state="translated">CSP ( HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; ) &lt;code&gt;&lt;strong&gt;worker-src&lt;/strong&gt;&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Worker&quot;&gt; &lt;code&gt;Worker&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker&quot;&gt; &lt;code&gt;SharedWorker&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker&quot;&gt; &lt;code&gt;ServiceWorker&lt;/code&gt; &lt;/a&gt; 스크립트에 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="65fa53659e196a5f364ee4db69fef14fde746c4b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;:&lt;/code&gt;&lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;manifest&lt;/a&gt; can be applied to the resource.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;:&lt;/code&gt; &lt;code&gt;&lt;strong&gt;manifest&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문 은 리소스에 적용 할 수 있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Manifest&quot;&gt;매니페스트를&lt;/a&gt; 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="e5534bb581250f2eb94ed31caf65205d9ee368e1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources of images and favicons.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;img&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 이미지 및 즐겨 찾기 아이콘의 유효한 소스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="dc76ac8291a24a25cb87200add3759c6483c6ea1" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt;&lt;code&gt;-src&lt;/code&gt; directive specifies valid sources for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;object&lt;/strong&gt;&lt;/code&gt; &lt;code&gt;-src&lt;/code&gt; 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 유효한 소스를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="1d78f21670ba26d46502f42156fd74dce6127ca2" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; directive instructs the client to require the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;Subresource Integrity&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;strong&gt;require-sri-for&lt;/strong&gt;&lt;/code&gt; 지시문은 클라이언트가 페이지의 스크립트 또는 스타일에 대해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity&quot;&gt;하위 자원 무결성&lt;/a&gt; 을 사용하도록 지시합니다 .</target>
        </trans-unit>
        <trans-unit id="c04dd8d66fd1dfd03e0cb89fd2b86f5466e7e9c8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt;&lt;code&gt;base-uri&lt;/code&gt; directive restricts the URLs which can be used in a document's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element. If this value is absent, then any URI is allowed. If this directive is absent, the user agent will use the value in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">HTTP &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; &lt;code&gt;base-uri&lt;/code&gt; 지시문은 문서의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에서 사용할 수있는 URL을 제한합니다 . 이 값이 없으면 모든 URI가 허용됩니다. 이 지시문이 없으면 사용자 에이전트는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 값을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="434bd95977151980be645e25d889ee96d08c9496" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;autoplay&lt;/code&gt; directive controls whether the current document is allowed to autoplay media requested through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt;&lt;code&gt;HTMLMediaElement&lt;/code&gt;&lt;/a&gt; interface. When this policy is enabled and there were no user gestures, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt;&lt;code&gt;HTMLMediaElement.play()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;. The &lt;code&gt;autoplay&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements will be ignored.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;autoplay&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement&quot;&gt; &lt;code&gt;HTMLMediaElement&lt;/code&gt; &lt;/a&gt; 인터페이스를 통해 요청 된 미디어를 자동 재생하도록 허용할지 여부를 제어합니다 . 이 정책이 사용 설정되고 사용자 동작이없는 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play&quot;&gt; &lt;code&gt;HTMLMediaElement.play()&lt;/code&gt; &lt;/a&gt; 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;DOMException&lt;/code&gt; 과 함께 거부됩니다 . &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 &lt;code&gt;autoplay&lt;/code&gt; 속성은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7f42da0f7bda5731910d6ec6cb2dc9b13ff87de9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;camera&lt;/code&gt; directive controls whether the current document is allowed to use video input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;camera&lt;/code&gt; 지시문은 현재 문서에서 비디오 입력 장치를 사용할 수 있는지 여부를 제어합니다. 이 정책을 사용하면, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 에 의해 반환 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt; 로모그래퍼 거부합니다 &lt;code&gt;NotAllowedError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b38e64dd4aafe5fbe1b9af5c13faa83b6a43ced" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;document-domain&lt;/code&gt; directive controls whether the current document is allowed to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, attempting to set &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt;&lt;code&gt;document.domain&lt;/code&gt;&lt;/a&gt; will fail and cause a &lt;code&gt;SecurityError&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; to be be thrown.</source>
          <target state="translated">는 HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;document-domain&lt;/code&gt; 현재 문서가 세트로 허용되는지 여부를 지시 컨트롤 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; 을&lt;/a&gt; . 이 정책을 사용하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/domain&quot;&gt; &lt;code&gt;document.domain&lt;/code&gt; &lt;/a&gt; 설정 시도 가 실패하고 &lt;code&gt;SecurityError&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="52529e863205e105281cb3b1e67c42491db93580" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;encrypted-media&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API (EME). When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt;&lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;encrypted-media&lt;/code&gt; 지시문은 현재 문서가 EME ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API&quot;&gt;Encrypted Media Extensions&lt;/a&gt; API) 를 사용할 수 있는지 여부를 제어합니다 . 이 정책을 사용하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess&quot;&gt; &lt;code&gt;Navigator.requestMediaKeySystemAccess()&lt;/code&gt; &lt;/a&gt; 반환 한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;DOMException&lt;/code&gt; 과 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c026bd77cc15606268a474526426c47ed406dd3" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;fullscreen&lt;/code&gt; directive controls whether the current document is allowed to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt;&lt;code&gt;Element.requestFullScreen()&lt;/code&gt;&lt;/a&gt;. When this policy is enabled, the returned &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; rejects with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;fullscreen&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Element/requestFullScreen&quot;&gt; &lt;code&gt;Element.requestFullScreen()&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있는지 여부를 제어합니다 . 이 정책을 사용하면 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 와 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="279945c05ed4e9f8612677a6cb5333c055c3347c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;geolocation&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt;&lt;code&gt;Geolocation&lt;/code&gt;&lt;/a&gt; Interface. When this policy is enabled, calls to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt;&lt;code&gt;getCurrentPosition()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt;&lt;code&gt;watchPosition()&lt;/code&gt;&lt;/a&gt; will cause those functions' callbacks to be invoked with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt;&lt;code&gt;PositionError&lt;/code&gt;&lt;/a&gt; code of &lt;code&gt;PERMISSION_DENIED&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;geolocation&lt;/code&gt; 지정 문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation&quot;&gt; &lt;code&gt;Geolocation&lt;/code&gt; &lt;/a&gt; 인터페이스 를 사용할 수 있는지 여부를 제어합니다 . 이 정책을 사용하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/getCurrentPosition&quot;&gt; &lt;code&gt;getCurrentPosition()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Geolocation/watchPosition&quot;&gt; &lt;code&gt;watchPosition()&lt;/code&gt; &lt;/a&gt; 을 호출하면 해당 함수의 콜백이 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PositionError&quot;&gt; &lt;code&gt;PositionError&lt;/code&gt; &lt;/a&gt; 코드 &lt;code&gt;PERMISSION_DENIED&lt;/code&gt; 와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="b86b8ff6f832650a49ab241aa391e1a80cf0e208" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;microphone&lt;/code&gt; directive controls whether the current document is allowed to use audio input devices. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt;&lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;NotAllowedError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;microphone&lt;/code&gt; 지시문은 현재 문서에서 오디오 입력 장치를 사용할 수 있는지 여부를 제어합니다. 이 정책을 사용하면, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 에 의해 반환 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia&quot;&gt; &lt;code&gt;MediaDevices.getUserMedia()&lt;/code&gt; &lt;/a&gt; 로모그래퍼 거부합니다 &lt;code&gt;NotAllowedError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ee0bf2b06d49cf8e3886496858e4c50b79dbf27" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;midi&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt;&lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;midi&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_MIDI_API&quot;&gt;Web MIDI API&lt;/a&gt; 를 사용할 수 있는지 여부를 제어합니다 . 이 정책이 활성화되면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMIDIAccess&quot;&gt; &lt;code&gt;Navigator.requestMIDIAccess()&lt;/code&gt; &lt;/a&gt; 반환 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;DOMException&lt;/code&gt; 과 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="92e1c9da52aa492cca410e5baad4c4d7dda1aa4f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;payment&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;Payment Request API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt;&lt;code&gt;PaymentRequest()&lt;/code&gt;&lt;/a&gt; constructor will throw a &lt;code&gt;SecurityError&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;payment&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Payment_Request_API&quot;&gt;지불 요청 API&lt;/a&gt; 를 사용할 수 있는지 여부를 제어합니다 . 이 정책이 활성화되면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/PaymentRequest&quot;&gt; &lt;code&gt;PaymentRequest()&lt;/code&gt; &lt;/a&gt; 생성자가 &lt;code&gt;SecurityError&lt;/code&gt; 를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="cc9aec9b3d7ed8d0d68045c2927ccdfecf55159b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;feature-policy&quot;&gt;&lt;code&gt;Feature-Policy&lt;/code&gt;&lt;/a&gt; header &lt;code&gt;vr&lt;/code&gt; directive controls whether the current document is allowed to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt;. When this policy is enabled, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;&lt;code&gt;Promise&lt;/code&gt;&lt;/a&gt; returned by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt;&lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt;&lt;/a&gt; will reject with a &lt;code&gt;DOMException&lt;/code&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;feature-policy&quot;&gt; &lt;code&gt;Feature-Policy&lt;/code&gt; &lt;/a&gt; 헤더 &lt;code&gt;vr&lt;/code&gt; 지시문은 현재 문서가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebVR_API&quot;&gt;WebVR API&lt;/a&gt; 를 사용할 수 있는지 여부를 제어합니다 . 이 정책을 사용하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/getVRDisplays&quot;&gt; &lt;code&gt;Navigator.getVRDisplays()&lt;/code&gt; &lt;/a&gt; 반환 한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt; &lt;code&gt;Promise&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;DOMException&lt;/code&gt; 과 함께 거부됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a01790dc40b1842141c794cdff77d6c8665d41c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;a href=&quot;put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method only allows complete replacement of a document. Unlike &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;PATCH&lt;/code&gt; is not idempotent, meaning successive identical patch requests &lt;em&gt;may &lt;/em&gt;have different effects. However, it is possible to issue &lt;code&gt;PATCH&lt;/code&gt; requests in such a way as to be idempotent.</source>
          <target state="translated">HTTP &lt;a href=&quot;put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 메소드는 문서의 완전한 교체 만 허용합니다. &lt;code&gt;PUT&lt;/code&gt; 과 달리 , &lt;code&gt;PATCH&lt;/code&gt; 는 dem 등성이 아니며, 동일한 패치 요청 &lt;em&gt;이&lt;/em&gt; 연속하여 다른 영향을 미칠 &lt;em&gt;수&lt;/em&gt; 있음을 의미 합니다. 그러나 dem 등원 (Idempotent) 방식으로 &lt;code&gt;PATCH&lt;/code&gt; 요청 을 발행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f334e7627368fd785cf9c286367893a77c43e45" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;100 Continue&lt;/code&gt; informational status response code indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.</source>
          <target state="translated">HTTP &lt;code&gt;100 Continue&lt;/code&gt; 정보 상태 응답 코드는 지금까지 모든 것이 정상이며 클라이언트가 요청을 계속하거나 이미 완료된 경우이를 무시해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7fbaadcda1376e28783b5f635687be50467a1933" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;103 Early Hints&lt;/code&gt; information response status code is primarily intended to be used with the &lt;a href=&quot;../headers/link&quot;&gt;&lt;code&gt;Link&lt;/code&gt;&lt;/a&gt; header to allow the user agent to start preloading resources while the server is still preparing a response.</source>
          <target state="translated">HTTP &lt;code&gt;103 Early Hints&lt;/code&gt; 정보 응답 상태 코드는 주로 &lt;a href=&quot;../headers/link&quot;&gt; &lt;code&gt;Link&lt;/code&gt; &lt;/a&gt; 헤더 와 함께 사용되어 서버가 응답을 준비하는 동안 사용자 에이전트가 리소스를 미리로드 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="278c46bdc85af7c390f125d693bcbfb316c79076" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;200 OK&lt;/code&gt; success status response code indicates that the request has succeeded. A 200 response is cacheable by default.</source>
          <target state="translated">HTTP &lt;code&gt;200 OK&lt;/code&gt; 성공 상태 응답 코드는 요청이 성공했음을 나타냅니다. 기본적으로 200 응답은 캐시 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c0eb27679053d5143a43ddd8d3a3431a539fa9ad" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;201 Created&lt;/code&gt; success status response code indicates that the request has succeeded and has led to the creation of a resource. The new resource is effectively created before this response is sent back and the new resource is returned in the body of the message, its location being either the URL of the request, or the content of the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;201 Created&lt;/code&gt; 성공 상태 응답 코드는 요청이 성공했으며 리소스가 생성되었음을 나타냅니다. 이 응답이 다시 전송되기 전에 새 자원이 효과적으로 작성되고 새 자원이 메시지 본문에 리턴되며, 해당 위치는 요청의 URL 또는 &lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; 헤더 의 컨텐츠입니다 .</target>
        </trans-unit>
        <trans-unit id="f20649a3f0fe7c56e61071fa1174a4b08047b9bd" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; response status indicates that the request was successful but the enclosed payload has been modified by a transforming &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxy&lt;/a&gt; from that of the origin server's &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) response .</source>
          <target state="translated">HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; 응답 상태는 요청이 성공했지만 포함 된 페이로드가 원본 서버의 &lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;OK&lt;/code&gt; ) 응답 에서 변환 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;프록시에&lt;/a&gt; 의해 수정되었음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="e4d3953aeb6b99914993168434167c7b602ed71d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; response status indicates that the request was successful but the enclosed payload has been modified from that of the origin server's &lt;a href=&quot;200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) response by a transforming &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxy&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;203 Non-Authoritative Information&lt;/code&gt; 응답 상태는 요청이 성공했지만 변환 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;프록시에&lt;/a&gt; 의해 동봉 된 페이로드가 원래 서버의 &lt;a href=&quot;200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;OK&lt;/code&gt; ) 응답 의 페이로드에서 수정되었음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="c8b0b238f5e41f13b1e7f817deb60c88d7d3bc20" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;204 No Content&lt;/code&gt; success status response code indicates that the request has succeeded, but that the client doesn't need to go away from its current page. A 204 response is cacheable by default. An &lt;a href=&quot;../headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; header is included in such a response.</source>
          <target state="translated">HTTP &lt;code&gt;204 No Content&lt;/code&gt; 성공 상태 응답 코드는 요청이 성공했지만 클라이언트가 현재 페이지에서 벗어날 필요가 없음을 나타냅니다. 204 응답은 기본적으로 캐시 가능합니다. 이러한 응답 에는 &lt;a href=&quot;../headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 헤더가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="80288ab170aee829f4cf209605eb49eadc086eef" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;205 Reset Content&lt;/code&gt; response status tells the client to reset the document view, so for example to clear the content of a form, reset a canvas state, or to refresh the UI.</source>
          <target state="translated">HTTP &lt;code&gt;205 Reset Content&lt;/code&gt; 응답 상태는 클라이언트에게 문서보기를 재설정하도록 지시합니다. 예를 들어 양식의 내용을 지우거나 캔버스 상태를 재설정하거나 UI를 새로 고칩니다.</target>
        </trans-unit>
        <trans-unit id="0c81546d9f0eee981bd016b4cb4e7eaa4833eb13" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;206 Partial Content&lt;/code&gt; success status response code indicates that the request has succeeded and has the body contains the requested ranges of data, as described in the &lt;a href=&quot;../headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header of the request.</source>
          <target state="translated">HTTP &lt;code&gt;206 Partial Content&lt;/code&gt; 성공 상태 응답 코드는 요청의 &lt;a href=&quot;../headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 헤더에 설명 된대로 요청이 성공했으며 본문에 요청 된 데이터 범위가 포함되어 있음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="3b3b5e099cd9381b1fd70b5113573795b1907f7d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; client error status response code indicates that the request has not been applied because it lacks valid authentication credentials for the target resource.</source>
          <target state="translated">HTTP &lt;code&gt;401 Unauthorized&lt;/code&gt; client 오류 상태 응답 코드는 요청이 대상 자원에 대한 유효한 인증 신임 정보가 없기 때문에 적용되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="29e296a48560f66dbcc3ec52c233f4fdb267b76e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;402 Payment Required&lt;/code&gt; is a nonstandard client error status response code that is reserved for future use.</source>
          <target state="translated">HTTP &lt;code&gt;402 Payment Required&lt;/code&gt; 는 향후 사용을 위해 예약 된 비표준 클라이언트 오류 상태 응답 코드입니다.</target>
        </trans-unit>
        <trans-unit id="979b22f333764accadf3c7a12f9ce50117ebb170" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; client error status response code indicates that the server understood the request but refuses to authorize it.</source>
          <target state="translated">HTTP &lt;code&gt;403 Forbidden&lt;/code&gt; client error 상태 응답 코드는 서버가 요청을 이해했지만 권한 부여를 거부 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="17d3fa05f1dcd2e00101e33637b74e845046dbb5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;407 Proxy Authentication Required &lt;/code&gt; client error status response code indicates that the request has not been applied because it lacks valid authentication credentials for a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;proxy server&lt;/a&gt; that is between the browser and the server that can access the requested resource.</source>
          <target state="translated">HTTP &lt;code&gt;407 Proxy Authentication Required &lt;/code&gt; 클라이언트 오류 상태 응답 코드는 요청 된 자원에 액세스 할 수있는 브라우저와 서버 사이 에있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;프록시 서버에&lt;/a&gt; 대한 유효한 인증 신임 정보가 없기 때문에 요청이 적용되지 않았 음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="bbb5886db0baaa39aa591bfbfac7d405f377c2ab" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;417 Expectation Failed&lt;/code&gt; client error response code indicates that the expectation given in the request's &lt;a href=&quot;../headers/expect&quot;&gt;&lt;code&gt;Expect&lt;/code&gt;&lt;/a&gt; header could not be met.</source>
          <target state="translated">HTTP &lt;code&gt;417 Expectation Failed&lt;/code&gt; 클라이언트 오류 응답 코드는 요청의 &lt;a href=&quot;../headers/expect&quot;&gt; &lt;code&gt;Expect&lt;/code&gt; &lt;/a&gt; 헤더에 제공된 기대치를 충족 할 수 없음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="0fd8eba95386e5a941324f20f703ccd45af95a3a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; client error response code indicates that the server refuses to brew coffee because it is a teapot. This error is a reference of Hyper Text Coffee Pot Control Protocol which was an April Fools' joke in 1998.</source>
          <target state="translated">&lt;code&gt;418 I'm a teapot&lt;/code&gt; 클라이언트 인 HTTP 418 오류 응답 코드는 서버가 주전자이므로 커피 추출을 거부 함을 나타냅니다. 이 오류는 1998 년 April Fools의 농담 인 Hyper Text Coffee Pot Control Protocol에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="654a84748c864e6e1a07b612586a854316f7aeb8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; client error response code indicates that the server refuses to brew coffee because it is, permanently, a teapot. A combined coffee/tea pot that is temporarily out of coffee should instead return 503. This error is a reference to Hyper Text Coffee Pot Control Protocol defined in April Fools' jokes in 1998 and 2014.</source>
          <target state="translated">HTTP &lt;code&gt;418 I'm a teapot&lt;/code&gt; client 오류 응답 코드는 커피가 영구적으로 주전자이기 때문에 서버가 커피 추출을 거부 함을 나타냅니다. 일시적으로 커피가 부족한 결합 된 커피 / 티 포트는 대신 503을 반환해야합니다.이 오류는 1998 년과 2014 년 만우절 농담에 정의 된 하이퍼 텍스트 커피 포트 제어 프로토콜에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="c11a396d84c2b4361354f28621db5450bb7872a5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; response code indicates the protocol the server is switching to as requested by a client which sent the message including the &lt;a href=&quot;../headers/upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; 응답 코드는 &lt;a href=&quot;../headers/upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; 요청 헤더 가 포함 된 메시지를 전송 한 클라이언트가 요청한대로 서버가 스위칭중인 프로토콜을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="b73eb36719efddb2bf307089114ca5c1ff83bc1f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; response code indicates the protocol the server is switching to as requested by a client which sent the message including the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;101 Switching Protocols&lt;/strong&gt;&lt;/code&gt; 응답 코드는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; 요청 헤더를 포함하여 메시지를 보낸 클라이언트가 요청한대로 서버가 전환하는 프로토콜을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="d7eb48272f72778b0b684676d2f608817e02eb9f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;300 Multiple Choices&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the request has more than one possible responses. The user-agent or the user should choose one of them. As there is no standardized way of choosing one of the responses, this response code is very rarely used.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;300 Multiple Choices&lt;/strong&gt;&lt;/code&gt; 리디렉션 상태 응답 코드는 요청에 둘 이상의 가능한 응답이 있음을 나타냅니다. 사용자 에이전트 또는 사용자는 그 중 하나를 선택해야합니다. 응답 중 하나를 선택하는 표준화 된 방법이 없으므로이 응답 코드는 거의 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de334adf5ffab7d89b3c6e50513373cd0cee8cfc" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt;&lt;/code&gt; client redirection response code indicates that there is no need to retransmit the requested resources. It is an implicit redirection to a cached resource. This happens when the request method is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt;, like a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request, or when the request is conditional and uses a &lt;a href=&quot;../headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;../headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;304 Not Modified&lt;/strong&gt;&lt;/code&gt; 클라이언트 리디렉션 응답 코드는 요청 된 리소스를 다시 전송할 필요가 없음을 나타냅니다. 캐시 된 리소스에 대한 암시 적 리디렉션입니다. 이는 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 요청 과 같은 요청 메소드가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;안전&lt;/a&gt; 하거나 요청이 조건부이고 &lt;a href=&quot;../headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt; 헤더를 사용하는 경우에 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="709d37d1b0cf9c49b3de2408fbf6ef4e0002c27a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server can't find the requested resource. Links that lead to a 404 page are often called broken or dead links and can be subject to &lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;link rot&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; 클라이언트 오류 응답 코드는 서버가 요청 된 리소스를 찾을 수 없음을 나타냅니다. 404 페이지로 연결되는 링크는 종종 끊어 지거나 죽은 링크라고하며 &lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;링크 부패의&lt;/a&gt; 대상이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="341bb159a2216d99ce107781a967531062a1c137" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server can't find the requested resource. Links which lead to a 404 page are often called broken or dead links, and can be subject to &lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;link rot&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;404 Not Found&lt;/strong&gt;&lt;/code&gt; 클라이언트 오류 응답 코드는 서버가 요청 된 자원을 찾을 수 없음을 나타냅니다. 404 페이지로 연결되는 링크는 종종 깨지거나 죽은 링크라고하며, 대상이 될 수 있습니다 &lt;a href=&quot;https://en.wikipedia.org/wiki/Link_rot&quot;&gt;죽은 링크&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="963eb81b613d14e6431a53b19e1087de4815c917" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; response status code indicates a request conflict with current state of the server.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 요청이 서버의 현재 상태와 충돌 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4a775e572f006026758ef524b8a9cc133b9ccc99" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; response status code indicates a request conflict with current state of the target resource.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;409 Conflict&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 요청이 대상 리소스의 현재 상태와 충돌 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1e620c227a6a0b266557df35d3c5635f4241af7c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;413 Payload Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request entity is larger than limits defined by server; the server might close the connection or return a &lt;a href=&quot;../headers/retry-after&quot;&gt;&lt;code&gt;Retry-After&lt;/code&gt;&lt;/a&gt; header field.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;413 Payload Too Large&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 요청 엔티티가 서버에서 정의한 한계보다 큼을 나타냅니다. 서버가 연결을 닫거나 &lt;a href=&quot;../headers/retry-after&quot;&gt; &lt;code&gt;Retry-After&lt;/code&gt; &lt;/a&gt; 헤더 필드를 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84e2079297e778196c8c9ae50616e31cf6eb1ce4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;414 URI Too Long&lt;/strong&gt;&lt;/code&gt; response status code indicates that the URI requested by the client is longer than the server is willing to interpret.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;414 URI Too Long&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 클라이언트가 요청한 URI가 서버가 해석하려는 것보다 길다는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fd260910ed4759c1378089671fbb6c0fbbb60660" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;415 Unsupported Media Type&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to accept the request because the payload format is in an unsupported format.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;415 Unsupported Media Type&lt;/strong&gt;&lt;/code&gt; 클라이언트 오류 응답 코드는 페이로드 형식이 지원되지 않는 형식이므로 서버가 요청 승인을 거부 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fa970ac1d28b371bc4205e842d1c6d26ad5a73c4" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;426 Upgrade Required&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to perform the request using the current protocol but might be willing to do so after the client upgrades to a different protocol.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;426 Upgrade Required&lt;/strong&gt;&lt;/code&gt; 클라이언트 오류 응답 코드는 서버가 현재 프로토콜을 사용하여 요청 수행을 거부하지만 클라이언트가 다른 프로토콜로 업그레이드 한 후 기꺼이 할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="75aa3c74acfab1e106209fd4dd08b06e3054f27c" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;428 Precondition Required&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server requires the request to be &lt;a href=&quot;../conditional_requests&quot;&gt;conditional&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;428 Precondition Required&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 서버가 요청을 &lt;a href=&quot;../conditional_requests&quot;&gt;조건부로&lt;/a&gt; 요구함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="caa3bb3b92f0cfe33012b47986779e7f954a74b6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;429 Too Many Requests&lt;/strong&gt;&lt;/code&gt; response status code indicates the user has sent too many requests in a given amount of time (&quot;rate limiting&quot;).</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;429 Too Many Requests&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 사용자가 지정된 시간 내에 요청을 너무 많이 보냈 음을 나타냅니다 ( &quot;속도 제한&quot;).</target>
        </trans-unit>
        <trans-unit id="04093cec2709dfaadbfa7527dc5c2ce1cd0b0646" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server is unwilling to process the request because its header fields are too large. The request may be resubmitted after reducing the size of the request header fields.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 헤더 필드가 너무 커서 서버가 요청을 처리하지 않을 것임을 나타냅니다. 요청 헤더 필드의 크기를 줄인 후 요청이 다시 제출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa944fee90f822e5d898a487cb81942f7a56be65" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server refuses to process the request because the request&amp;rsquo;s &lt;a href=&quot;../headers&quot;&gt;HTTP headers&lt;/a&gt; are too long. The request &lt;em&gt;may&lt;/em&gt; be resubmitted after reducing the size of the request headers.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;431 Request Header Fields Too Large&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 요청의 &lt;a href=&quot;../headers&quot;&gt;HTTP 헤더&lt;/a&gt; 가 너무 길기 때문에 서버가 요청 처리를 거부했음을 나타냅니다 . 요청 헤더의 크기를 줄인 후 요청을 다시 제출할 &lt;em&gt;수&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9ddb3645327183c13becf845f54f56cdc4fdb5b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;511 Network Authentication Required&lt;/strong&gt;&lt;/code&gt; response status code indicates that the client needs to authenticate to gain network access.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;511 Network Authentication Required&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 클라이언트가 네트워크 액세스 권한을 얻기 위해 인증해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="61ba4c1907f9a2e1f56de138ea9bcbb425c864e8" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; response header sends reports of pinning violation to the &lt;code&gt;report-uri&lt;/code&gt; specified in the header but, unlike &lt;a href=&quot;public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; still allows browsers to connect to the server if the pinning is violated.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; 응답 헤더는 피닝 위반 보고서를 헤더에 지정된 &lt;code&gt;report-uri&lt;/code&gt; 로 전송 하지만, &lt;a href=&quot;public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt; 과 달리 고정을 위반하면 브라우저가 서버에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d86ddf68a31dc8a760b8d60344a39004ec85b2f" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; response header was used to send reports of pinning violation to the &lt;code&gt;report-uri&lt;/code&gt; specified in the header but, unlike &lt;a href=&quot;public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; still allows browsers to connect to the server if the pinning is violated. The header is silently ignored in modern browsers as support for HPKP has been removed. Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;Certificate Transparency&lt;/a&gt; and the &lt;a href=&quot;expect-ct&quot;&gt;&lt;code&gt;Expect-CT&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins-Report-Only&lt;/strong&gt;&lt;/code&gt; 응답 헤더는 고정 위반 보고서를 헤더에 지정된 &lt;code&gt;report-uri&lt;/code&gt; 로 보내는 데 사용 되었지만, &lt;a href=&quot;public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt; 와는 달리 고정 상태 인 경우 브라우저가 서버에 연결할 수 있습니다. 위반. HPKP에 대한 지원이 제거되었으므로 최신 브라우저에서는 헤더가 자동으로 무시됩니다. 대신 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;인증서 투명성&lt;/a&gt; 과 &lt;a href=&quot;expect-ct&quot;&gt; &lt;code&gt;Expect-CT&lt;/code&gt; &lt;/a&gt; 헤더를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2f1aca0b8602a1b4269702669b5705705488252e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; response header associates a specific cryptographic public &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;key&lt;/a&gt; with a certain web server to decrease the risk of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; attacks with forged certificates. If one or several keys are pinned and none of them are used by the server, the browser will not accept the response as legitimate, and will not display it.</source>
          <target state="translated">HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; 응답 헤더는 특정 암호화 공개 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;키&lt;/a&gt; 를 특정 웹 서버 와 연결하여 위조 된 인증서 로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; 공격 의 위험을 줄 입니다. 하나 이상의 키가 고정되어 있고 서버에서 사용하지 않는 키가 있으면 브라우저는 응답을 정당한 것으로 받아들이지 않고 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5426b643c79f95f69aab37cfedbccbbaa4236ca6" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; response header used to associate a specific cryptographic public &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;key&lt;/a&gt; with a certain web server to decrease the risk of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; attacks with forged certificates, however, it has been removed from modern browsers and is no longer supported. Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;Certificate Transparency&lt;/a&gt; and &lt;a href=&quot;expect-ct&quot;&gt;&lt;code&gt;Expect-CT&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="translated">위조 된 인증서 로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; 공격 의 위험을 줄이기 위해 특정 암호화 공개 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/key&quot;&gt;키&lt;/a&gt; 를 특정 웹 서버와 연결하는 데 사용되는 HTTP &lt;code&gt;&lt;strong&gt;Public-Key-Pins&lt;/strong&gt;&lt;/code&gt; 응답 헤더 는 최신 브라우저에서 제거되었으며 더 이상 지원되지 않습니다. 대신 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency&quot;&gt;인증서 투명성&lt;/a&gt; 및 &lt;a href=&quot;expect-ct&quot;&gt; &lt;code&gt;Expect-CT&lt;/code&gt; &lt;/a&gt; 헤더를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cc17523ceced42a997fa4ec405b48542dc6da961" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent with a server, usually after the server has responded with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; status and the &lt;a href=&quot;www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;Authorization&lt;/code&gt; 요청 헤더에는 일반적으로 서버가 &lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; 상태 및 &lt;a href=&quot;www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt; 헤더로 응답 한 후 서버로 사용자 에이전트를 인증하기위한 신임 정보가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="91c7c3a40bace5e7298eaff1c25e12df9e924d3d" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent with a server, usually, but not necessarily, after the server has responded with a &lt;a href=&quot;../status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; status and the &lt;a href=&quot;www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;Authorization&lt;/code&gt; 요청 헤더에는 일반적으로 서버가 &lt;a href=&quot;../status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; 상태 및 &lt;a href=&quot;www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt; 헤더로 응답 한 후 서버에서 사용자 에이전트를 인증하기위한 자격 증명이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="eefae1a810c845c3fa68fd46660a1ab4ceaacda0" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; response header allows web developers to experiment with policies by monitoring (but not enforcing) their effects. These violation reports consist of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; documents sent via an HTTP &lt;code&gt;POST&lt;/code&gt; request to the specified URI.</source>
          <target state="translated">웹 개발자는 HTTP &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 응답 헤더를 사용하여 효과를 모니터링 (강제하지는 않음)하여 정책을 실험 할 수 있습니다. 이러한 위반 보고서 는 HTTP &lt;code&gt;POST&lt;/code&gt; 요청을 통해 지정된 URI로 전송 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; 문서로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="1cedc9503c55c7df39812e0c200c391cb9852c4a" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Content-Security-Policy&lt;/code&gt; response header allows web site administrators to control resources the user agent is allowed to load for a given page. With a few exceptions, policies mostly involve specifying server origins and script endpoints. This helps guard against cross-site scripting attacks (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;).</source>
          <target state="translated">웹 사이트 관리자는 HTTP &lt;code&gt;Content-Security-Policy&lt;/code&gt; 응답 헤더를 사용하여 사용자 에이전트가 특정 페이지에 대해로드 할 수있는 리소스를 제어 할 수 있습니다. 몇 가지 예외를 제외하고 정책에는 주로 서버 원본 및 스크립트 끝점 지정이 포함됩니다. 이를 통해 사이트 간 스크립팅 공격 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt; )을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9a358c2e37bd97387c345bc97d49f2b9964bebc" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Cross-Origin-Embedder-Policy&lt;/code&gt; (COEP) response header prevents a document from loading any cross-origin resources that don't explicitly grant the document permission (using &lt;a href=&quot;../cross-origin_resource_policy_(corp)&quot;&gt;CORP&lt;/a&gt; or &lt;a href=&quot;../cors&quot;&gt;CORS&lt;/a&gt;).</source>
          <target state="translated">HTTP COEP ( &lt;code&gt;Cross-Origin-Embedder-Policy&lt;/code&gt; Embedder -Policy ) 응답 헤더는 문서가 &lt;a href=&quot;../cross-origin_resource_policy_(corp)&quot;&gt;CORP&lt;/a&gt; 또는 &lt;a href=&quot;../cors&quot;&gt;CORS&lt;/a&gt; 사용하여 문서 권한을 명시 적으로 부여하지 않은 교차 ​​출처 리소스를로드하지 못하도록합니다 .</target>
        </trans-unit>
        <trans-unit id="bd12a715eb3e020beaec19eacef98180f3c03eb5" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Cross-Origin-Opener-Policy&lt;/code&gt; (COOP) response header allows you to ensure a top-level document does not share a browsing context group with cross-origin documents.</source>
          <target state="translated">HTTP COOP ( &lt;code&gt;Cross-Origin-Opener-Policy&lt;/code&gt; ) 응답 헤더를 사용하면 최상위 문서가 교차 출처 문서와 브라우징 컨텍스트 그룹을 공유하지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="532f81dfa15429527706f99b56516bbbb7103920" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Cross-Origin-Resource-Policy&lt;/code&gt; response header conveys a desire that the browser blocks no-cors cross-origin/cross-site requests to the given resource.</source>
          <target state="translated">HTTP &lt;code&gt;Cross-Origin-Resource-Policy&lt;/code&gt; 응답 헤더는 브라우저가 주어진 리소스에 대한 no-cors cross-origin / cross-site 요청을 차단하려는 요구를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="1606c56903114379a30109e67a8a9703c7538a88" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; header provides a mechanism to allow and deny the use of browser features in its own frame, and in content within any &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; elements in the document.</source>
          <target state="translated">HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; 헤더는 자체 프레임 및 문서의 모든 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 내의 콘텐츠에서 브라우저 기능의 사용을 허용 및 거부하는 메커니즘을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="1f93db0c2b1cae96ab8007915ebdc3aee6ae9b29" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; header provides a mechanism to allow and deny the use of browser features in its own frame, and in iframes that it embeds.</source>
          <target state="translated">HTTP &lt;code&gt;Feature-Policy&lt;/code&gt; 헤더는 자체 프레임과 iframe에 포함 된 브라우저 기능의 사용을 허용 및 거부하는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ffce3b68f1b8be8fa0ab126f01ab7dcd1167232b" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Link&lt;/code&gt; entity-header field provides a means for serialising one or more links in HTTP headers. It is semantically equivalent to the HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">HTTP &lt;code&gt;Link&lt;/code&gt; entity-header 필드는 HTTP 헤더에서 하나 이상의 링크를 직렬화하는 수단을 제공합니다. 의미 상 HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="15bba15c0e7df46ed2a8a40b2e760da5664fad96" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;NEL&lt;/code&gt; response header is used to configure network request logging.</source>
          <target state="translated">HTTP &lt;code&gt;NEL&lt;/code&gt; 응답 헤더는 네트워크 요청 로깅을 구성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1ee6fbdaf32a73c5d2da4ea87e0ad9941527d763" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Proxy-Authenticate&lt;/code&gt; response header defines the authentication method that should be used to gain access to a resource behind a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;proxy server&lt;/a&gt;. It authenticates the request to the proxy server, allowing it to transmit the request further.</source>
          <target state="translated">HTTP &lt;code&gt;Proxy-Authenticate&lt;/code&gt; 응답 헤더는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/proxy_server&quot;&gt;프록시 서버&lt;/a&gt; 뒤의 리소스에 액세스하는 데 사용해야하는 인증 방법을 정의 합니다 . 요청을 프록시 서버로 인증하여 요청을 더 전송할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d342efd1df2902182c9b47d04c0940ea25837a75" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Proxy-Authorization&lt;/code&gt; request header contains the credentials to authenticate a user agent to a proxy server, usually after the server has responded with a &lt;a href=&quot;../status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt; status and the &lt;a href=&quot;proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP &lt;code&gt;Proxy-Authorization&lt;/code&gt; 요청 헤더에는 일반적으로 서버가 &lt;a href=&quot;../status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; 상태 및 &lt;a href=&quot;proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt; 헤더로 응답 한 후 프록시 서버에 대한 사용자 에이전트를 인증하기위한 신임 정보가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="06706a733035595c3ca09ed579f53668680fa83e" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt; request header sends a signal to the server expressing the client&amp;rsquo;s preference for an encrypted and authenticated response, and that it can successfully handle the &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;CSP&lt;/a&gt; directive.</source>
          <target state="translated">HTTP &lt;code&gt;Upgrade-Insecure-Requests&lt;/code&gt; 요청 헤더는 암호화되고 인증 된 응답에 대한 클라이언트의 기본 설정을 나타내는 신호를 서버에 전송하며 &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt; CSP&lt;/a&gt; 지시문을 성공적으로 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f27fddd57d61b2e03f1c5514e09709028f9f0a9" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;WWW-Authenticate&lt;/code&gt; response header defines the authentication method that should be used to gain access to a resource.</source>
          <target state="translated">HTTP &lt;code&gt;WWW-Authenticate&lt;/code&gt; 응답 헤더는 리소스에 액세스하는 데 사용해야하는 인증 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="aeb81534f8cc6e53ddfa06e7cb5d6c8eaf9dba55" translate="yes" xml:space="preserve">
          <source>The HTTP &lt;code&gt;X-XSS-Protection&lt;/code&gt; response header is a feature of Internet Explorer, Chrome and Safari that stops pages from loading when they detect reflected cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;) attacks. Although these protections are largely unnecessary in modern browsers when sites implement a strong &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; that disables the use of inline JavaScript (&lt;code&gt;'unsafe-inline'&lt;/code&gt;), they can still provide protections for users of older web browsers that don't yet support &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;CSP&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;code&gt;X-XSS-Protection&lt;/code&gt; 응답 헤더는 Internet Explorer, Chrome 및 Safari의 기능으로, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt; (Cross-Site Scripting ) 공격이 감지 될 때 페이지로드를 중지합니다 . 사이트 가 인라인 JavaScript ( &lt;code&gt;'unsafe-inline'&lt;/code&gt; )를 사용하지 못하게 하는 강력한 &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; 을 구현할 때 최신 브라우저에서는 이러한 보호가 거의 필요 하지 않지만, 아직 그렇지 않은 이전 웹 브라우저의 사용자를 보호 할 수 있습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;CSP를&lt;/a&gt; 지원하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a09546225cff6400570e0443b16e0c6e86472fe" translate="yes" xml:space="preserve">
          <source>The HTTP Strict Transport Security header informs the browser that it should never load a site using HTTP and should automatically convert all attempts to access the site using HTTP to HTTPS requests instead.</source>
          <target state="translated">HTTP Strict Transport Security 헤더는 브라우저에 HTTP를 사용하여 사이트를로드해서는 안된다고 알려주고 대신 HTTP를 사용하여 사이트에 액세스하려는 모든 시도를 HTTPS 요청으로 자동 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="be8b00e9c8d5d272b2e1f90c102d59e067b32a0b" translate="yes" xml:space="preserve">
          <source>The HTTP URL namespace is a hierarchical namespace where the
   hierarchy is delimited with the &quot;/&quot; character.

   An HTTP URL namespace is said to be consistent if it meets the
   following conditions: for every URL in the HTTP hierarchy there
   exists a collection that contains that URL as an internal member URL.
   The root, or top-level collection of the namespace under
   consideration, is exempt from the previous rule.  The top-level
   collection of the namespace under consideration is not necessarily
   the collection identified by the absolute path '/' -- it may be
   identified by one or more path segments (e.g., /servlets/webdav/...)

   Neither HTTP/1.1 nor WebDAV requires that the entire HTTP URL
   namespace be consistent -- a WebDAV-compatible resource may not have
   a parent collection.  However, certain WebDAV methods are prohibited
   from producing results that cause namespace inconsistencies.

   As is implicit in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;], any resource, including
   collection resources, MAY be identified by more than one URI.  For
   example, a resource could be identified by multiple HTTP URLs.</source>
          <target state="translated">HTTP URL 네임 스페이스는 &quot;/&quot;문자로 계층이 구분되는 계층 적 네임 스페이스입니다. HTTP URL 네임 스페이스는 다음 조건을 충족하는 경우 일관된 것으로 간주됩니다. HTTP 계층의 모든 URL에 대해 해당 URL을 내부 구성원 URL로 포함하는 콜렉션이 있습니다. 고려중인 네임 스페이스의 루트 또는 최상위 수준 컬렉션은 이전 규칙에서 제외됩니다. 고려중인 네임 스페이스의 최상위 컬렉션은 반드시 절대 경로 '/'로 식별 된 컬렉션 일 필요는 없습니다. 하나 이상의 경로 세그먼트 (예 : / servlets / webdav / ...)로 식별 될 수 있습니다. HTTP / 1.1 또는 WebDAV에서는 전체 HTTP URL 네임 스페이스가 일관되어야합니다. WebDAV 호환 리소스에는 부모 컬렉션이 없을 수 있습니다. 하나,특정 WebDAV 메소드는 네임 스페이스 불일치를 유발하는 결과를 생성 할 수 없습니다. [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] 및 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ], 콜렉션 자원을 포함한 모든 자원은 둘 이상의 URI로 식별 될 수 있습니다 (MAY). 예를 들어, 리소스는 여러 HTTP URL로 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fce77c17c83cf3b9166ab68262d46c09171eb1b" translate="yes" xml:space="preserve">
          <source>The HTTP authentication framework does not define a single mechanism
   for maintaining the confidentiality of credentials; instead, each
   authentication scheme defines how the credentials are encoded prior
   to transmission.  While this provides flexibility for the development
   of future authentication schemes, it is inadequate for the protection
   of existing schemes that provide no confidentiality on their own, or
   that do not sufficiently protect against replay attacks.
   Furthermore, if the server expects credentials that are specific to
   each individual user, the exchange of those credentials will have the
   effect of identifying that user even if the content within
   credentials remains confidential.

   HTTP depends on the security properties of the underlying transport-
   or session-level connection to provide confidential transmission of
   header fields.  In other words, if a server limits access to
   authenticated users using this framework, the server needs to ensure
   that the connection is properly secured in accordance with the nature
   of the authentication scheme used.  For example, services that depend
   on individual user authentication often require a connection to be
   secured with TLS (&quot;Transport Layer Security&quot;, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]) prior to
   exchanging any credentials.</source>
          <target state="translated">HTTP 인증 프레임 워크는 자격 증명의 기밀성을 유지하기위한 단일 메커니즘을 정의하지 않습니다. 대신, 각 인증 체계는 전송 전에 자격 증명이 인코딩되는 방식을 정의합니다. 이는 향후 인증 체계의 개발에 유연성을 제공하지만 자체적으로 기밀성을 제공하지 않거나 재생 공격으로부터 충분히 보호하지 못하는 기존 체계를 보호하기에는 부적합합니다. 또한 서버가 각 개별 사용자에게 고유 한 자격 증명을 기대하면 자격 증명 내의 내용이 기밀로 유지되는 경우에도 해당 자격 증명을 교환하면 해당 사용자를 식별하는 효과가 있습니다.HTTP는 기본 전송 레벨 또는 세션 레벨 연결의 보안 특성에 따라 헤더 필드의 기밀 전송을 제공합니다. 즉, 서버가이 프레임 워크를 사용하여 인증 된 사용자에 대한 액세스를 제한하는 경우 서버는 사용 된 인증 체계의 특성에 따라 연결이 올바르게 보안되도록해야합니다. 예를 들어 개별 사용자 인증에 의존하는 서비스는 종종 TLS ( &quot;Transport Layer Security&quot;, [개별 사용자 인증에 의존하는 서비스는 종종 TLS ( &quot;Transport Layer Security&quot;, [개별 사용자 인증에 의존하는 서비스는 종종 TLS ( &quot;Transport Layer Security&quot;, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;&lt;/a&gt;자격 증명을 교환하기 전에 RFC5246 ]).</target>
        </trans-unit>
        <trans-unit id="d8d09b5015d287016b84da909b78b11d8d4463c3" translate="yes" xml:space="preserve">
          <source>The HTTP conditional request header fields [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;] allow a client
   to place a precondition on the state of the target resource, so that
   the action corresponding to the method semantics will not be applied
   if the precondition evaluates to false.  Each precondition defined by 

   this specification consists of a comparison between a set of
   validators obtained from prior representations of the target resource
   to the current state of validators for the selected representation
   (&lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;).  Hence, these preconditions evaluate whether the state
   of the target resource has changed since a given state known by the
   client.  The effect of such an evaluation depends on the method
   semantics and choice of conditional, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-5&quot;&gt;Section&amp;nbsp;5 of
   [RFC7232]&lt;/a&gt;.

   +---------------------+--------------------------+
   | Header Field Name   | Defined in...            |
   +---------------------+--------------------------+
   | If-Match            | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of [RFC7232]&lt;/a&gt; |
   | If-None-Match       | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7232]&lt;/a&gt; |
   | If-Modified-Since   | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7232]&lt;/a&gt; |
   | If-Unmodified-Since | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.4&quot;&gt;Section&amp;nbsp;3.4 of [RFC7232]&lt;/a&gt; |
   | If-Range            | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7233]&lt;/a&gt; |
   +---------------------+--------------------------+</source>
          <target state="translated">HTTP 조건부 요청 헤더 필드 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ]를 사용하면 클라이언트가 대상 자원의 상태에 사전 조건을 배치 할 수 있으므로 사전 조건이 false로 평가되는 경우 메소드 시맨틱에 해당하는 조치가 적용되지 않습니다. 이 규격에 의해 정의 된 각각의 전제 조건은 목표 자원의 사전 표현으로부터 획득 된 검증기 세트와 선택된 표현에 대한 검증기의 현재 상태 ( &lt;a href=&quot;#section-7.2&quot;&gt;섹션 7.2&lt;/a&gt; ) 사이의 비교로 구성된다 . 따라서 이러한 전제 조건은 클라이언트가 알려진 특정 상태 이후에 대상 자원의 상태가 변경되었는지 여부를 평가합니다. 이러한 평가의 효과는 방법론의 의미론과&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-5&quot;&gt;[RFC7232] 섹션 5&lt;/a&gt; . + --------------------- + -------------------------- + | 헤더 필드 이름 | 정의 ... | + --------------------- + -------------------------- + | 일치하는 경우 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.1&quot;&gt;[RFC7232] 섹션 3.1&lt;/a&gt; | | 일치하지 않는 경우 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;[RFC7232] 섹션 3.2&lt;/a&gt; | | 수정 된 이후 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;[RFC7232] 섹션 3.3&lt;/a&gt; | | 수정되지 않은 경우 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.4&quot;&gt;[RFC7232] 섹션 3.4&lt;/a&gt; | | 범위 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;[RFC7233] 섹션 3.2&lt;/a&gt; | + --------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="db5702e7098e5089b43ae75747b9b4a1f88a17e6" translate="yes" xml:space="preserve">
          <source>The HTTP method being used by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; request is not included in the list of methods specified by the response's &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; header. This header specifies a comma-delineated list of the HTTP methods which may be used when using CORS to access the URL specified in the request; if the request is using any other method, this error occurs.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; 요청 에 사용되는 HTTP 메소드 는 응답의 &lt;a href=&quot;../../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; 헤더에 지정된 메소드 목록에 포함되지 않습니다 . 이 헤더는 CORS를 사용하여 요청에 지정된 URL에 액세스 할 때 사용될 수있는 쉼표로 구분 된 HTTP 메소드 목록을 지정합니다. 요청이 다른 방법을 사용하는 경우이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9a5f8b591cdf4b19c28a4fbbf2ef71bf29cedf58" translate="yes" xml:space="preserve">
          <source>The HTTP protocol is a request/response protocol. A client sends a
   request to the server in the form of a request method, URI, and
   protocol version, followed by a MIME-like message containing request
   modifiers, client information, and possible body content over a
   connection with a server. The server responds with a status line,
   including the message's protocol version and a success or error code,
   followed by a MIME-like message containing server information, entity
   metainformation, and possible entity-body content. The relationship
   between HTTP and MIME is described in appendix 19.4.

   Most HTTP communication is initiated by a user agent and consists of
   a request to be applied to a resource on some origin server. In the
   simplest case, this may be accomplished via a single connection (v)
   between the user agent (UA) and the origin server (O).

          request chain ------------------------&amp;gt;
       UA -------------------v------------------- O
          &amp;lt;----------------------- response chain

   A more complicated situation occurs when one or more intermediaries
   are present in the request/response chain. There are three common
   forms of intermediary: proxy, gateway, and tunnel. A proxy is a
   forwarding agent, receiving requests for a URI in its absolute form,
   rewriting all or part of the message, and forwarding the reformatted
   request toward the server identified by the URI. A gateway is a
   receiving agent, acting as a layer above some other server(s) and, if
   necessary, translating the requests to the underlying server's
   protocol. A tunnel acts as a relay point between two connections
   without changing the messages; tunnels are used when the
   communication needs to pass through an intermediary (such as a
   firewall) even when the intermediary cannot understand the contents
   of the messages.

          request chain --------------------------------------&amp;gt;
       UA -----v----- A -----v----- B -----v----- C -----v----- O
          &amp;lt;------------------------------------- response chain

   The figure above shows three intermediaries (A, B, and C) between the
   user agent and origin server. A request or response message that
   travels the whole chain will pass through four separate connections.
   This distinction is important because some HTTP communication options 

   may apply only to the connection with the nearest, non-tunnel
   neighbor, only to the end-points of the chain, or to all connections
   along the chain. Although the diagram is linear, each participant may
   be engaged in multiple, simultaneous communications. For example, B
   may be receiving requests from many clients other than A, and/or
   forwarding requests to servers other than C, at the same time that it
   is handling A's request.

   Any party to the communication which is not acting as a tunnel may
   employ an internal cache for handling requests. The effect of a cache
   is that the request/response chain is shortened if one of the
   participants along the chain has a cached response applicable to that
   request. The following illustrates the resulting chain if B has a
   cached copy of an earlier response from O (via C) for a request which
   has not been cached by UA or A.

          request chain ----------&amp;gt;
       UA -----v----- A -----v----- B - - - - - - C - - - - - - O
          &amp;lt;--------- response chain

   Not all responses are usefully cacheable, and some requests may
   contain modifiers which place special requirements on cache behavior.
   HTTP requirements for cache behavior and cacheable responses are
   defined in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;.

   In fact, there are a wide variety of architectures and configurations
   of caches and proxies currently being experimented with or deployed
   across the World Wide Web. These systems include national hierarchies
   of proxy caches to save transoceanic bandwidth, systems that
   broadcast or multicast cache entries, organizations that distribute
   subsets of cached data via CD-ROM, and so on. HTTP systems are used
   in corporate intranets over high-bandwidth links, and for access via
   PDAs with low-power radio links and intermittent connectivity. The
   goal of HTTP/1.1 is to support the wide diversity of configurations
   already deployed while introducing protocol constructs that meet the
   needs of those who build web applications that require high
   reliability and, failing that, at least reliable indications of
   failure.

   HTTP communication usually takes place over TCP/IP connections. The
   default port is TCP 80 [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;], but other ports can be used. This does
   not preclude HTTP from being implemented on top of any other protocol
   on the Internet, or on other networks. HTTP only presumes a reliable
   transport; any protocol that provides such guarantees can be used;
   the mapping of the HTTP/1.1 request and response structures onto the
   transport data units of the protocol in question is outside the scope
   of this specification. 

   In HTTP/1.0, most implementations used a new connection for each
   request/response exchange. In HTTP/1.1, a connection may be used for
   one or more request/response exchanges, although connections may be
   closed for a variety of reasons (see &lt;a href=&quot;#section-8.1&quot;&gt;section 8.1&lt;/a&gt;).</source>
          <target state="translated">HTTP 프로토콜은 요청 / 응답 프로토콜입니다. 클라이언트는 요청 메소드, URI 및 프로토콜 버전의 형태로 서버에 요청을 보낸 다음 서버와의 연결을 통해 요청 수정 자, 클라이언트 정보 및 가능한 본문 내용을 포함하는 MIME와 유사한 메시지를 보냅니다. 서버는 메시지의 프로토콜 버전, 성공 또는 오류 코드를 포함한 상태 표시 줄과 서버 정보, 엔티티 메타 정보 및 가능한 엔티티 본문 컨텐츠를 포함하는 MIME와 유사한 메시지로 응답합니다. HTTP와 MIME의 관계는 부록 19.4에 설명되어 있습니다. 대부분의 HTTP 통신은 사용자 에이전트에 의해 시작되며 일부 오리진 서버의 자원에 적용되는 요청으로 구성됩니다. 가장 간단한 경우이것은 사용자 에이전트 (UA)와 오리진 서버 (O) 사이의 단일 연결 (v)을 통해 달성 될 수있다. 요청 체인 ------------------------&amp;gt; UA ------------------- v-- ----------------- O &amp;lt;----------------------- 응답 체인보다 복잡한 상황은 하나 이상의 중개자가 요청 / 응답 체인에 존재합니다. 프록시, 게이트웨이 및 터널의 세 가지 일반적인 형태가 있습니다. 프록시는 포워딩 에이전트로, 절대 형식으로 URI에 대한 요청을 수신하고, 메시지의 전부 또는 일부를 다시 쓰고, URI로 식별 된 서버로 재 포맷 된 요청을 전달합니다. 게이트웨이는 수신 에이전트로, 다른 서버보다 높은 계층으로 작동하며 필요한 경우 요청을 기본 서버의 프로토콜로 변환합니다.터널은 메시지를 변경하지 않고 두 연결 사이의 중계 점 역할을합니다. 중개자가 메시지의 내용을 이해할 수없는 경우에도 통신이 방화벽과 같은 중개자를 통과해야하는 경우 터널이 사용됩니다. 요청 체인 --------------------------------------&amp;gt; UA ----- v-- --- A ----- v ----- B ----- v ----- C ----- v ----- O &amp;lt;--------- ---------------------------- 응답 체인 위의 그림은 사용자 에이전트와 오리진 사이의 세 가지 중개자 (A, B 및 C)를 보여줍니다. 섬기는 사람. 전체 체인을 이동하는 요청 또는 응답 메시지는 4 개의 개별 연결을 통과합니다. 일부 HTTP 통신 옵션은 가장 가까운 비 터널 인접 장치와의 연결에만 적용 할 수 있기 때문에 이러한 구별이 중요합니다.체인의 끝점 또는 체인의 모든 연결부에만 연결하십시오. 다이어그램은 선형이지만 각 참가자는 여러 개의 동시 통신에 참여할 수 있습니다. 예를 들어, B는 A 이외의 많은 클라이언트로부터 요청을 수신하고 /하거나 A의 요청을 처리하는 동시에 C 이외의 서버로 요청을 전달할 수 있습니다. 터널로 작동하지 않는 통신 당사자는 요청을 처리하기 위해 내부 캐시를 사용할 수 있습니다. 캐시의 효과는 체인을 따라 참가자 중 하나가 해당 요청에 적용 가능한 캐시 된 응답을 갖는 경우 요청 / 응답 체인이 단축되는 것입니다. 다음은 B에 UA 또는 A에 의해 캐시되지 않은 요청에 대해 (C를 통해) O로부터의 초기 응답의 캐시 된 사본이있는 경우 결과 체인을 보여줍니다.요청 체인 ----------&amp;gt; UA ----- v ----- A ----- v ----- B------C----- -O &amp;lt;--------- 응답 체인 모든 응답을 캐시 할 수있는 것은 아니며 일부 요청에는 캐시 동작에 대한 특별한 요구 사항을 지정하는 수정자가 포함될 수 있습니다. 캐시 동작 및 캐시 가능한 응답에 대한 HTTP 요구 사항은&lt;a href=&quot;#section-13&quot;&gt;섹션 13&lt;/a&gt;. 실제로, 월드 와이드 웹 (World Wide Web)에서 현재 실험되거나 배포되고있는 캐시 및 프록시의 다양한 아키텍처와 구성이 있습니다. 이러한 시스템에는 대서양 대역폭을 절약하기위한 전국 프록시 캐시 계층, 캐시 항목을 브로드 캐스트 또는 멀티 캐스트하는 시스템, CD-ROM을 통해 캐시 된 데이터의 서브 세트를 분배하는 조직 등이 포함됩니다. HTTP 시스템은 고 대역폭 링크를 통해 회사 인트라넷에서 사용되며 저전력 무선 링크 및 간헐적 인 연결을 통해 PDA를 통한 액세스에 사용됩니다. HTTP / 1.1의 목표는 이미 구축 된 다양한 구성을 지원하는 동시에 높은 안정성을 요구하는 웹 응용 프로그램을 작성하는 사람들의 요구를 충족시키는 프로토콜 구성을 도입하는 것입니다.HTTP 통신은 일반적으로 TCP / IP 연결을 통해 이루어집니다. 기본 포트는 TCP 80 [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ]이지만 다른 포트를 사용할 수 있습니다. 인터넷이나 다른 네트워크의 다른 프로토콜 위에 HTTP가 구현되는 것을 막을 수는 없습니다. HTTP는 안정적인 전송만을 가정합니다. 그러한 보증을 제공하는 모든 프로토콜을 사용할 수 있습니다. HTTP / 1.1 요청 및 응답 구조를 해당 프로토콜의 전송 데이터 단위로 매핑하는 것은이 사양의 범위를 벗어납니다. HTTP / 1.0에서 대부분의 구현은 각 요청 / 응답 교환에 대해 새로운 연결을 사용했습니다. HTTP / 1.1에서는 연결이 여러 가지 이유로 닫힐 수 있지만 하나 이상의 요청 / 응답 교환에 연결이 사용될 수 있습니다 ( &lt;a href=&quot;#section-8.1&quot;&gt;섹션 8.1&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="711fba1dbcca7b38687dec5dcf6d2cbe1d22690a" translate="yes" xml:space="preserve">
          <source>The HTTP protocol specifies a request method called &lt;a href=&quot;methods/connect&quot;&gt;&lt;code&gt;CONNECT&lt;/code&gt;&lt;/a&gt;. It starts two-way communications with the requested resource and can be used to open a tunnel. This is how a client behind an HTTP proxy can access websites using SSL (i.e. HTTPS, port 443). Note, however, that not all proxy servers support the &lt;code&gt;CONNECT&lt;/code&gt; method or limit it to port 443 only.</source>
          <target state="translated">HTTP 프로토콜은 &lt;a href=&quot;methods/connect&quot;&gt; &lt;code&gt;CONNECT&lt;/code&gt; &lt;/a&gt; 라는 요청 메소드를 지정합니다 . 요청 된 리소스와 양방향 통신을 시작하고 터널을 여는 데 사용할 수 있습니다. HTTP 프록시 뒤의 클라이언트가 SSL (예 : HTTPS, 포트 443)을 사용하여 웹 사이트에 액세스 할 수있는 방법입니다. 그러나 모든 프록시 서버가 &lt;code&gt;CONNECT&lt;/code&gt; 메소드를 지원 하거나 포트 443으로 만 제한하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a45670933a882d376a78839281d063695249e118" translate="yes" xml:space="preserve">
          <source>The HTTP protocol used in those early phases was very simple, later dubbed HTTP/0.9, and sometimes as the one-line protocol.</source>
          <target state="translated">초기 단계에서 사용 된 HTTP 프로토콜은 매우 단순했고 나중에 HTTP / 0.9라고 불 렸으며 때로는 한 줄 프로토콜로도 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="8b8c615279d732a85c03cf31a496dadc0ee7a1e0" translate="yes" xml:space="preserve">
          <source>The HTTP request headers</source>
          <target state="translated">HTTP 요청 헤더</target>
        </trans-unit>
        <trans-unit id="dc91001bcd5977c42287ce1ec14f986765b8a528" translate="yes" xml:space="preserve">
          <source>The HTTP response headers</source>
          <target state="translated">HTTP 응답 헤더</target>
        </trans-unit>
        <trans-unit id="eb8587eac722cc07a0cd8556b058eb4e29c05d63" translate="yes" xml:space="preserve">
          <source>The HTTP status code of the resource on which the global object was instantiated.</source>
          <target state="translated">글로벌 오브젝트가 인스턴스화 된 자원의 HTTP 상태 코드입니다.</target>
        </trans-unit>
        <trans-unit id="7642977e6ce54243574090f3f5103dcd8214c71f" translate="yes" xml:space="preserve">
          <source>The HTTP version used in the request is not supported by the server.</source>
          <target state="translated">요청에 사용 된 HTTP 버전이 서버에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0cf1515c8e62f4e6628b5f0c81397855080991ba" translate="yes" xml:space="preserve">
          <source>The HTTP/1.1 standard defines list of the standard headers that start server-driven negotiation (&lt;a href=&quot;headers/accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;). Though strictly speaking &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; is not in this list, it is sometimes also used to send a specific representation of the requested resource, though this is not considered as a good practice. The server uses the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header to indicate which headers it actually used for content negotiation (or more precisely the associated response headers), so that &lt;a href=&quot;caching&quot;&gt;caches&lt;/a&gt; can work optimally.</source>
          <target state="translated">HTTP / 1.1 표준은 서버 중심 협상을 시작하는 표준 헤더 목록 ( &lt;a href=&quot;headers/accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt; )을 정의합니다. 엄밀히 말하면 &lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt; 는이 목록에 없지만 요청 된 리소스의 특정 표현을 보내는 데 사용되기도하지만 이는 좋은 방법으로 간주되지 않습니다. 서버는 &lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; 헤더를 사용하여 &lt;a href=&quot;caching&quot;&gt;캐시&lt;/a&gt; 가 최적으로 작동 할 수 있도록 실제로 컨텐츠 협상에 사용 된 헤더 (또는보다 정확하게 연관된 응답 헤더)를 표시 합니다 .</target>
        </trans-unit>
        <trans-unit id="ed9884f0209355d73677c39f7ea1c603c1d343ae" translate="yes" xml:space="preserve">
          <source>The HTTP/2 binary framing mechanism has been designed to not require any alteration of the APIs or config files applied: it is broadly transparent to the user.</source>
          <target state="translated">HTTP / 2 바이너리 프레이밍 메커니즘은 적용된 API 또는 구성 파일을 변경할 필요가 없도록 설계되었습니다. 사용자에게 광범위하게 투명합니다.</target>
        </trans-unit>
        <trans-unit id="eab0e3a9f6070e36846c5fd400fcb4bef4e35044" translate="yes" xml:space="preserve">
          <source>The HTTP/2 header field encoding allows the expression of names that
   are not valid field names in the Internet Message Syntax used by
   HTTP/1.1.  Requests or responses containing invalid header field
   names MUST be treated as malformed (&lt;a href=&quot;#section-8.1.2.6&quot;&gt;Section 8.1.2.6&lt;/a&gt;).  An
   intermediary therefore cannot translate an HTTP/2 request or response
   containing an invalid field name into an HTTP/1.1 message.

   Similarly, HTTP/2 allows header field values that are not valid.
   While most of the values that can be encoded will not alter header
   field parsing, carriage return (CR, ASCII 0xd), line feed (LF, ASCII
   0xa), and the zero character (NUL, ASCII 0x0) might be exploited by
   an attacker if they are translated verbatim.  Any request or response
   that contains a character not permitted in a header field value MUST
   be treated as malformed (&lt;a href=&quot;#section-8.1.2.6&quot;&gt;Section 8.1.2.6&lt;/a&gt;).  Valid characters are
   defined by the &quot;field-content&quot; ABNF rule in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">HTTP / 2 헤더 필드 인코딩은 HTTP / 1.1에서 사용하는 인터넷 메시지 구문에서 유효한 필드 이름이 아닌 이름의 표현을 허용합니다. 유효하지 않은 헤더 필드 이름을 포함하는 요청 또는 응답은 잘못된 형식으로 처리되어야합니다 ( &lt;a href=&quot;#section-8.1.2.6&quot;&gt;8.1.2.6 절&lt;/a&gt; ). 따라서 중개자는 잘못된 필드 이름이 포함 된 HTTP / 2 요청 또는 응답을 HTTP / 1.1 메시지로 변환 할 수 없습니다. 마찬가지로 HTTP / 2는 유효하지 않은 헤더 필드 값을 허용합니다. 인코딩 할 수있는 대부분의 값은 헤더 필드 구문 분석, 캐리지 리턴 (CR, ASCII 0xd), 줄 바꿈 (LF, ASCII 0xa) 및 0 문자 (NUL, ASCII 0x0)를 변경하지 않지만 공격자가 악용 할 수 있습니다. 그대로 번역 된 경우. 헤더 필드 값에 허용되지 않는 문자를 포함하는 모든 요청 또는 응답은 잘못된 형식 (&lt;a href=&quot;#section-8.1.2.6&quot;&gt;8.1.2.6 항&lt;/a&gt; ). 유효한 문자는 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]의 섹션 3.2&lt;/a&gt; 에있는 &quot;field-content&quot;ABNF 규칙에 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc2a35fa99cfd317dd5558de4b34fa07535768f1" translate="yes" xml:space="preserve">
          <source>The HTTP/2 protocol has several prime differences from the HTTP/1.1 version:</source>
          <target state="translated">HTTP / 2 프로토콜은 HTTP / 1.1 버전과 몇 가지 주요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ab1960130a01b920907a6e30a6c6e0c01c3afed" translate="yes" xml:space="preserve">
          <source>The HTTP/2 specification is split into four parts:

   o  Starting HTTP/2 (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) covers how an HTTP/2 connection is
      initiated.

   o  The frame (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;) and stream (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;) layers describe the
      way HTTP/2 frames are structured and formed into multiplexed
      streams.

   o  Frame (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;) and error (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) definitions include
      details of the frame and error types used in HTTP/2.

   o  HTTP mappings (&lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;) and additional requirements (&lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;)
      describe how HTTP semantics are expressed using frames and
      streams.

   While some of the frame and stream layer concepts are isolated from
   HTTP, this specification does not define a completely generic frame
   layer.  The frame and stream layers are tailored to the needs of the
   HTTP protocol and server push.</source>
          <target state="translated">HTTP / 2 사양은 네 부분으로 나뉩니다. o HTTP / 2 시작 ( &lt;a href=&quot;#section-3&quot;&gt;섹션 3&lt;/a&gt; )은 HTTP / 2 연결이 시작되는 방법을 다룹니다. o 프레임 ( &lt;a href=&quot;#section-4&quot;&gt;섹션 4&lt;/a&gt; ) 및 스트림 ( &lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt; ) 레이어는 HTTP / 2 프레임이 구조화되고 다중 스트림으로 형성되는 방식을 설명합니다. o 프레임 ( &lt;a href=&quot;#section-6&quot;&gt;섹션 6&lt;/a&gt; ) 및 오류 ( &lt;a href=&quot;#section-7&quot;&gt;섹션 7&lt;/a&gt; ) 정의에는 HTTP / 2에서 사용되는 프레임 및 오류 유형에 대한 세부 사항이 포함됩니다. o HTTP 매핑 ( &lt;a href=&quot;#section-8&quot;&gt;섹션 8&lt;/a&gt; ) 및 추가 요구 사항 ( &lt;a href=&quot;#section-9&quot;&gt;섹션 9&lt;/a&gt;) HTTP 의미 체계가 프레임과 스트림을 사용하여 표현되는 방법을 설명합니다. 일부 프레임 및 스트림 계층 개념은 HTTP와 분리되어 있지만이 사양은 완전히 일반적인 프레임 계층을 정의하지 않습니다. 프레임 및 스트림 계층은 HTTP 프로토콜 및 서버 푸시의 요구에 맞게 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="99fbf8dd0978f7db7e2a91bcbd770cc0ec6b4bcd" translate="yes" xml:space="preserve">
          <source>The Host request-header field specifies the Internet host and port
   number of the resource being requested, as obtained from the original
   URI given by the user or referring resource (generally an HTTP URL, 

   as described in &lt;a href=&quot;#section-3.2.2&quot;&gt;section 3.2.2&lt;/a&gt;). The Host field value MUST represent
   the naming authority of the origin server or gateway given by the
   original URL. This allows the origin server or gateway to
   differentiate between internally-ambiguous URLs, such as the root &quot;/&quot;
   URL of a server for multiple host names on a single IP address.

       Host = &quot;Host&quot; &quot;:&quot; host [ &quot;:&quot; port ] ; &lt;a href=&quot;#section-3.2.2&quot;&gt;Section 3.2.2&lt;/a&gt;

   A &quot;host&quot; without any trailing port information implies the default
   port for the service requested (e.g., &quot;80&quot; for an HTTP URL). For
   example, a request on the origin server for
   &amp;lt;&lt;a href=&quot;http://www.w3.org/pub/WWW/&quot;&gt;http://www.w3.org/pub/WWW/&lt;/a&gt;&amp;gt; would properly include:

       GET /pub/WWW/ HTTP/1.1
       Host: www.w3.org

   A client MUST include a Host header field in all HTTP/1.1 request
   messages . If the requested URI does not include an Internet host
   name for the service being requested, then the Host header field MUST
   be given with an empty value. An HTTP/1.1 proxy MUST ensure that any
   request message it forwards does contain an appropriate Host header
   field that identifies the service being requested by the proxy. All
   Internet-based HTTP/1.1 servers MUST respond with a 400 (Bad Request)
   status code to any HTTP/1.1 request message which lacks a Host header
   field.

   See sections &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; and &lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1&lt;/a&gt; for other requirements relating to
   Host.</source>
          <target state="translated">Host request-header (호스트 요청 헤더) 필드는 사용자 또는 참조 리소스가 제공 한 원래 URI (일반적으로 &lt;a href=&quot;#section-3.2.2&quot;&gt;3.2.2 절에&lt;/a&gt; 설명 된 HTTP URL)에서 얻은 요청중인 리소스의 인터넷 호스트 및 포트 번호를 지정합니다 . 호스트 필드 값은 원래 URL이 제공 한 오리진 서버 또는 게이트웨이의 이름 지정 권한을 나타내야합니다. 이를 통해 오리진 서버 또는 게이트웨이는 단일 IP 주소의 여러 호스트 이름에 대한 서버의 루트 &quot;/&quot;URL과 같이 내부적으로 모호한 URL을 구별 할 수 있습니다. Host = &quot;Host&quot; &quot;:&quot;host [ &quot;:&quot;port]; &lt;a href=&quot;#section-3.2.2&quot;&gt;섹션 3.2.2&lt;/a&gt; 후행 포트 정보가없는 &quot;호스트&quot;는 요청 된 서비스의 기본 포트를 의미합니다 (예 : HTTP URL의 경우 &quot;80&quot;). 예를 들어, 오리진 서버에서 &amp;lt; &lt;a href=&quot;http://www.w3.org/pub/WWW/&quot;&gt;http://www.w3.org/pub/WWW/에&lt;/a&gt; 대한 요청&amp;gt; GET / pub / WWW / HTTP / 1.1 호스트 : www.w3.org 클라이언트는 모든 HTTP / 1.1 요청 메시지에 호스트 헤더 필드를 포함해야합니다. 요청 된 URI에 요청중인 서비스의 인터넷 호스트 이름이 포함되어 있지 않으면 호스트 헤더 필드에 빈 값을 지정해야합니다. HTTP / 1.1 프록시는 전달하는 요청 메시지에 프록시가 요청하는 서비스를 식별하는 적절한 호스트 헤더 필드가 포함되어 있어야합니다. 모든 인터넷 기반 HTTP / 1.1 서버는 호스트 헤더 필드가없는 HTTP / 1.1 요청 메시지에 400 (잘못된 요청) 상태 코드로 응답해야합니다. 호스트와 관련된 다른 요구 사항은 &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; 및 &lt;a href=&quot;#section-19.6.1.1&quot;&gt;19.6.1.1&lt;/a&gt; 단원을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3b1aa4a92939a94846182a9752d0647f06200784" translate="yes" xml:space="preserve">
          <source>The Hyper Text Coffee Pot Control Protocol for Tea Efflux Appliances (HTCPCP-TEA)</source>
          <target state="translated">차 유출 장치 (HTCPCP-TEA)를위한 하이퍼 텍스트 커피 포트 제어 프로토콜</target>
        </trans-unit>
        <trans-unit id="2fbdae656d9bef10ff135384ea52e37645e6d50f" translate="yes" xml:space="preserve">
          <source>The Hyper Text Coffee Pot Control Protocol for Tea Efflux Appliances (HTCPCP-TEA): Response Codes</source>
          <target state="translated">차 유출 기기 (HTCPCP-TEA)를위한 하이퍼 텍스트 커피 포트 제어 프로토콜 : 응답 코드</target>
        </trans-unit>
        <trans-unit id="1867896c3b2397819388475788a0bf4abcbf5ed6" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request has been accepted for processing, but the processing has not been completed; in fact, processing may not have started yet. The request might or might not eventually be acted upon, as it might be disallowed when processing actually takes place.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 요청이 처리를 위해 수락되었지만 처리가 완료되지 않았 음을 나타냅니다. 실제로 처리가 아직 시작되지 않았을 수 있습니다. 요청은 처리가 실제로 수행 될 때 허용되지 않을 수 있으므로 결국 처리되거나 처리되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fa10aaa19ccd9183c515b022dab356e9181ff7f" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request has been received but not yet acted upon. It is non-committal, meaning that there is no way for the HTTP to later send an asynchronous response indicating the outcome of processing the request. It is intended for cases where another process or server handles the request, or for batch processing.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;202 Accepted&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 요청이 수신되었지만 아직 수행되지 않았 음을 나타냅니다. 커밋되지 않은 것은 HTTP가 나중에 요청 처리 결과를 나타내는 비동기 응답을 보낼 수있는 방법이 없음을 의미합니다. 다른 프로세스 나 서버가 요청을 처리하는 경우 또는 일괄 처리를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="8da2e56e0326733411c384ee9df3d066f1be28c3" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been definitively moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; headers. A browser redirects to this page and search engines update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is sent to the new URL).</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;301 Moved Permanently&lt;/strong&gt;&lt;/code&gt; 리디렉션 상태 응답 코드는 요청 된 리소스가 &lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; 헤더에서 제공 한 URL로 확실히 이동했음을 나타냅니다 . 브라우저가이 페이지로 리디렉션되고 검색 엔진이 리소스에 대한 링크를 업데이트합니다 ( 'SEO-speak'에서 'link-juice'가 새 URL로 전송 됨).</target>
        </trans-unit>
        <trans-unit id="bca235dd87a759f1a9dd3bfa9203b6546d063663" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;302 Found&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been temporarily moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header. A browser redirects to this page but search engines don't update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is not sent to the new URL).</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;302 Found&lt;/strong&gt;&lt;/code&gt; 리디렉션 상태 응답 코드는 요청 된 리소스가 &lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; 헤더에서 제공 한 URL로 일시적으로 이동했음을 나타냅니다 . 브라우저는이 페이지로 리디렉션되지만 검색 엔진은 리소스에 대한 링크를 업데이트하지 않습니다 ( 'SEO-speak'에서 'link-juice'는 새 URL로 전송되지 않는다고합니다).</target>
        </trans-unit>
        <trans-unit id="a0dc42b9614cba52b23ba38ea15b1e9d7488ecb2" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the redirects don't link to the newly uploaded resources but to another page, like a confirmation page or an upload progress page. This response code is usually sent back as a result of &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;. The method used to display this redirected page is always &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; 리디렉션 상태 응답 코드는 리디렉션이 새로 업로드 된 리소스가 아니라 확인 페이지 또는 업로드 진행률 페이지와 같은 다른 페이지에 연결됨을 나타냅니다. 이 응답 코드는 일반적으로 &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 의 결과로 다시 전송됩니다 . 이 리디렉션 된 페이지를 표시하는 데 사용되는 방법은 항상 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6d5990b78312268a2a1237e68fb338dd4e8d416f" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the redirects don't link to the newly uploaded resources, but to another page (such as a confirmation page or an upload progress page). This response code is usually sent back as a result of &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;. The method used to display this redirected page is always &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;303 See Other&lt;/strong&gt;&lt;/code&gt; 리디렉션 상태 응답 코드 &lt;strong&gt;참조&lt;/strong&gt; 는 리디렉션이 새로 업로드 된 리소스가 아니라 다른 페이지 (예 : 확인 페이지 또는 업로드 진행률 페이지)로 연결됨을 나타냅니다. 이 응답 코드는 일반적으로 &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 의 결과로 다시 전송됩니다 . 이 리디렉션 된 페이지를 표시하는 데 사용되는 방법은 항상 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3108347112af1e3d29e6704655c39459a5034ad0" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;308 Permanent Redirect&lt;/strong&gt;&lt;/code&gt; redirect status response code indicates that the resource requested has been definitively moved to the URL given by the &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; headers. A browser redirects to this page and search engines update their links to the resource (in 'SEO-speak', it is said that the 'link-juice' is sent to the new URL).</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;308 Permanent Redirect&lt;/strong&gt;&lt;/code&gt; 경로 재 지정 상태 응답 코드는 요청 된 자원이 &lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; 헤더에서 제공 한 URL로 확실히 이동되었음을 나타냅니다 . 브라우저가이 페이지로 리디렉션되고 검색 엔진이 리소스에 대한 링크를 업데이트합니다 ( 'SEO-speak'에서 'link-juice'가 새 URL로 전송 됨).</target>
        </trans-unit>
        <trans-unit id="cbd8493e7cce398f69ed55cb6bb5f24186092644" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server cannot or will not process the request due to something that is perceived to be a client error (e.g., malformed request syntax, invalid request message framing, or deceptive request routing).</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 클라이언트 오류 (예 : 잘못된 요청 구문, 잘못된 요청 메시지 프레이밍 또는 사기성 요청)로 인해 서버가 요청을 처리 할 수 ​​없거나 처리하지 않을 것임을 나타냅니다. 라우팅).</target>
        </trans-unit>
        <trans-unit id="2055230dbe836c1aaf7bd92cbe0fa85f1440c7fc" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server could not understand the request due to invalid syntax.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;400 Bad Request&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 유효하지 않은 구문으로 인해 서버가 요청을 이해할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="15ac14cd04fa900b118bba5f014d31ab3bbfe121" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;405 Method Not Allowed&lt;/strong&gt;&lt;/code&gt; response status code indicates that the request method is known by the server but is not supported by the target resource.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;405 Method Not Allowed&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 요청 방법이 서버에 알려져 있지만 대상 자원에 의해 지원 &lt;strong&gt;되지 않음을&lt;/strong&gt; 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="60871008192002b75675780fc635a2b570a2bf8c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;406 Not Acceptable&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server cannot produce a response matching the list of acceptable values defined in the request's proactive &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt; headers, and that the server is unwilling to supply a default representation.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;406 Not Acceptable&lt;/strong&gt;&lt;/code&gt; 클라이언트 오류 응답 코드는 서버가 요청의 사전 &lt;a href=&quot;../content_negotiation&quot;&gt;컨텐츠 협상&lt;/a&gt; 헤더에 정의 된 허용 가능한 값 목록과 일치하는 응답을 생성 할 수없고 서버가 기본 표현을 제공하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6d70feb7e34e129ebc5526b0c592e1fdbf1c816e" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;408 Request Timeout&lt;/strong&gt;&lt;/code&gt; response status code means that the server would like to shut down this unused connection. It is sent on an idle connection by some servers, &lt;em&gt;even without any previous request by the client&lt;/em&gt;.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;408 Request Timeout&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 서버가이 사용되지 않은 연결을 종료하려고 함을 의미합니다. &lt;em&gt;클라이언트의 이전 요청 없이도&lt;/em&gt; 일부 서버에서 유휴 연결로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="a66fb4f3fae8e6c063276dcb5237ee845eeca4ed" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;410 Gone&lt;/strong&gt;&lt;/code&gt; client error response code indicates that access to the target resource is no longer available at the origin server and that this condition is likely to be permanent.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;410 Gone&lt;/strong&gt;&lt;/code&gt; 클라이언트 오류 응답 코드는 대상 자원에 대한 액세스를 더 이상 원래 서버에서 사용할 수 없으며이 조건이 영구적 일 가능성이 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4b9a35e682079b0a683f989a76db71ce57aae81d" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;411 Length Required&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the server refuses to accept the request without a defined &lt;a href=&quot;../headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;411 Length Required&lt;/strong&gt;&lt;/code&gt; 클라이언트 오류 응답 코드는 서버가 정의 된 &lt;a href=&quot;../headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt; 헤더 없이 요청 수락을 거부 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="731510b854954129731e069eb6b3d2e9019b2fdc" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;412 Precondition Failed&lt;/strong&gt;&lt;/code&gt; client error response code indicates that access to the target resource has been denied. This happens with conditional requests on methods other than &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; when the condition defined by the &lt;a href=&quot;../headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; headers is not fulfilled. In that case, the request, usually an upload or a modification of a resource, cannot be made and this error response is sent back.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;412 Precondition Failed&lt;/strong&gt;&lt;/code&gt; 클라이언트 오류 응답 코드는 대상 자원에 대한 액세스가 거부되었음을 나타냅니다. 이는 &lt;a href=&quot;../headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt; 헤더에 의해 정의 된 조건이 충족 되지 않은 경우 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 이외의 메소드에 대한 조건부 요청에서 발생합니다 . 이 경우 일반적으로 자원 업로드 또는 수정 요청을 수행 할 수 없으며이 오류 응답이 다시 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="95dad23f3e8d87cfe4b0b1791422ccff7fdb0ec9" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;416 Range Not Satisfiable&lt;/strong&gt;&lt;/code&gt; error response code indicates that a server cannot serve the requested ranges. The most likely reason is that the document doesn't contain such ranges, or that the &lt;a href=&quot;../headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header value, though syntactically correct, doesn't make sense.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;416 Range Not Satisfiable&lt;/strong&gt;&lt;/code&gt; 오류 응답 코드는 서버가 요청 된 범위를 처리 할 수 ​​없음을 나타냅니다. 가장 가능성이 높은 이유는 문서에 이러한 범위가 포함되어 있지 않거나 구문으로 올바른 &lt;a href=&quot;../headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 헤더 값이 의미가 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="99f1059b5dc6332a65c7949a31d1b45cbce33ed7" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;422 Unprocessable Entity&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server understands the content type of the request entity, and the syntax of the request entity is correct, but it was unable to process the contained instructions.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;422 Unprocessable Entity&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 서버가 요청 엔티티의 컨텐츠 유형을 이해하고 요청 엔티티의 구문이 올바르지 만 포함 된 명령을 처리 할 수 ​​없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="630618c062b0adb0b4e53d21c6ec93a1ffc8709b" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;425 Too Early&lt;/strong&gt;&lt;/code&gt; response status code indicates that the server is unwilling to risk processing a request that might be replayed, which creates the potential for a replay attack.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;425 Too Early&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 서버가 재생할 수있는 요청을 처리 할 위험이 없음을 나타내므로 재생 공격의 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ba79c25bd016d25902460c531a9af1832ad5084" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;451 Unavailable For Legal Reasons&lt;/strong&gt;&lt;/code&gt; client error response code indicates that the user requested a resource that is not available due to legal reasons, such as a web page for which a legal action has been issued.</source>
          <target state="translated">&lt;code&gt;&lt;strong&gt;451 Unavailable For Legal Reasons&lt;/strong&gt;&lt;/code&gt; HTTP (HyperText Transfer Protocol) &lt;strong&gt;451을 사용할 수 없음&lt;/strong&gt; 클라이언트 오류 응답 코드는 사용자가 합법적 인 조치가 발행 된 웹 페이지와 같이 합법적 인 이유로 인해 사용할 수없는 자원을 요청했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b137e360e4b5274b152a6bc5424bdda215ece645" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server encountered an unexpected condition that prevented it from fulfilling the request.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;500 Internal Server Error&lt;/strong&gt;&lt;/code&gt; 서버 오류 응답 코드는 서버가 요청을 수행하지 못하게하는 예기치 않은 조건이 발생했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9c744578cdc0d9bb57ba2e4e4ab0fa07c99379e2" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the request method is not supported by the server and cannot be handled. The only methods that servers are required to support (and therefore that must not return this code) are &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; 서버 오류 응답 코드는 요청 방법이 서버에서 지원되지 않아 처리 할 수 ​​없음을 나타냅니다. 서버가 지원해야하는 유일한 메소드 (따라서이 코드를 리턴하지 않아야 함)는 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1db14053efdc5b849d20c165c505ccbdce0af60c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; server error response code means that &lt;strong&gt;the server does not support the functionality required to fulfill the request&lt;/strong&gt;.</source>
          <target state="translated">The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;501 Not Implemented&lt;/strong&gt;&lt;/code&gt; server error response code means that &lt;strong&gt;the server does not support the functionality required to fulfill the request&lt;/strong&gt;.</target>
        </trans-unit>
        <trans-unit id="c56e521d7943d1bf8ac9d8be1e1d2c5a9c11ad29" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;502 Bad Gateway&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, received an invalid response from the upstream server.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;502 Bad Gateway&lt;/strong&gt;&lt;/code&gt; 서버 오류 응답 코드는 서버가 게이트웨이 또는 프록시 역할을하는 동안 업스트림 서버로부터 유효하지 않은 응답을 수신했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d97095b9bce2f7dabb2319cf5e31ce5cd055c7fe" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server is not ready to handle the request.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;503 Service Unavailable&lt;/strong&gt;&lt;/code&gt; 서버 오류 응답 코드는 서버가 요청을 처리 할 준비가되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ed70120131ebb0a274691c4d30386f6dc8fc669c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, cannot get a response in time.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; 서버 오류 응답 코드는 서버가 게이트웨이 또는 프록시로 작동하는 동안 시간 내에 응답을 얻을 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a75a514de375190ba5cb2f8574ec6665fc8a648c" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; server error response code indicates that the server, while acting as a gateway or proxy, did not get a response in time from the upstream server that it needed in order to complete the request.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;504 Gateway Timeout&lt;/strong&gt;&lt;/code&gt; 서버 오류 응답 코드는 서버가 게이트웨이 또는 프록시로 작동하는 동안 요청을 완료하는 데 필요한 업스트림 서버로부터 제때 응답을받지 못했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5206e7fbe439a4fe0558730cbd561b9d56ad71ad" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;505 HTTP Version Not Supported&lt;/strong&gt;&lt;/code&gt; response status code indicates that the HTTP version used in the request is not supported by the server.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;505 HTTP Version Not Supported&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 요청에 사용 된 HTTP 버전이 서버에서 &lt;strong&gt;지원되지 않음을&lt;/strong&gt; 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="49ce1d6f6a8be4676edf766aee4540297f25f76a" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;506 Variant Also Negotiates&lt;/strong&gt;&lt;/code&gt; response status code may be given in the context of Transparent Content Negotiation (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;RFC 2295&lt;/a&gt;). This protocol enables a client to retrieve the best variant of a given resource, where the server supports multiple variants.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;506 Variant Also Negotiates&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 Transparent Content Negotiation의 컨텍스트에서 제공 될 수 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;RFC 2295&lt;/a&gt; 참조 ). 이 프로토콜을 사용하면 클라이언트는 서버가 여러 변형을 지원하는 주어진 리소스의 최상의 변형을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="820e5cef7a998998b0849eeb24e0fff1b6649bae" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;507 Insufficient Storage&lt;/strong&gt;&lt;/code&gt; response status code may be given in the context of the Web Distributed Authoring and Versioning (WebDAV) protocol (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC 4918&lt;/a&gt;).</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;507 Insufficient Storage&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 WebDAV (Web Distributed Authoring and Versioning) 프로토콜의 컨텍스트에서 제공 될 수 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC 4918&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="76d88c87ab8a315a60aa9543690290ffbfbdb653" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;508 Loop Detected&lt;/strong&gt;&lt;/code&gt; response status code may be given in the context of the Web Distributed Authoring and Versioning (WebDAV) protocol.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;508 Loop Detected&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 WebDAV (Web Distributed Authoring and Versioning) 프로토콜의 컨텍스트에서 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81aa286d5750f499d27f8f17321bc45f7f2ca1f1" translate="yes" xml:space="preserve">
          <source>The HyperText Transfer Protocol (HTTP) &lt;code&gt;&lt;strong&gt;510 Not Extended&lt;/strong&gt;&lt;/code&gt; response status code is sent in the context of the HTTP Extension Framework, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC 2774&lt;/a&gt;.</source>
          <target state="translated">HTTP (HyperText Transfer Protocol) &lt;code&gt;&lt;strong&gt;510 Not Extended&lt;/strong&gt;&lt;/code&gt; 응답 상태 코드는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC 2774에&lt;/a&gt; 정의 된 HTTP 확장 프레임 워크의 컨텍스트에서 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="2e3eb482b38eeaa5e40d4ddbab8b13b92a13f7fd" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level request/response protocol that uses extensible semantics and
   self-descriptive message payloads for flexible interaction with
   network-based hypertext information systems.  This document is the
   first in a series of documents that collectively form the HTTP/1.1
   specification:

   1.  &quot;Message Syntax and Routing&quot; (this document)

   2.  &quot;Semantics and Content&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]

   3.  &quot;Conditional Requests&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]

   4.  &quot;Range Requests&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]

   5.  &quot;Caching&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]

   6.  &quot;Authentication&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;]

   This HTTP/1.1 specification obsoletes &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; (on HTTP
   versioning).  This specification also updates the use of CONNECT to
   establish a tunnel, previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt;, and defines the
   &quot;https&quot; URI scheme that was described informally in &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt;.

   HTTP is a generic interface protocol for information systems.  It is
   designed to hide the details of how a service is implemented by
   presenting a uniform interface to clients that is independent of the
   types of resources provided.  Likewise, servers do not need to be
   aware of each client's purpose: an HTTP request can be considered in
   isolation rather than being associated with a specific type of client
   or a predetermined sequence of application steps.  The result is a
   protocol that can be used effectively in many different contexts and
   for which implementations can evolve independently over time.

   HTTP is also designed for use as an intermediation protocol for
   translating communication to and from non-HTTP information systems.
   HTTP proxies and gateways can provide access to alternative
   information services by translating their diverse protocols into a
   hypertext format that can be viewed and manipulated by clients in the
   same way as HTTP services.

   One consequence of this flexibility is that the protocol cannot be
   defined in terms of what occurs behind the interface.  Instead, we
   are limited to defining the syntax of communication, the intent of
   received communication, and the expected behavior of recipients.  If
   the communication is considered in isolation, then successful actions 

   ought to be reflected in corresponding changes to the observable
   interface provided by servers.  However, since multiple clients might
   act in parallel and perhaps at cross-purposes, we cannot require that
   such changes be observable beyond the scope of a single response.

   This document describes the architectural elements that are used or
   referred to in HTTP, defines the &quot;http&quot; and &quot;https&quot; URI schemes,
   describes overall network operation and connection management, and
   defines HTTP message framing and forwarding requirements.  Our goal
   is to define all of the mechanisms necessary for HTTP message
   handling that are independent of message semantics, thereby defining
   the complete set of requirements for message parsers and message-
   forwarding intermediaries.</source>
          <target state="translated">HTTP (Hypertext Transfer Protocol)는 네트워크 기반 하이퍼 텍스트 정보 시스템과의 유연한 상호 작용을 위해 확장 가능한 의미 체계 및 자체 설명 메시지 페이로드를 사용하는 상태 비 저장 응용 프로그램 수준 요청 / 응답 프로토콜입니다. 이 문서는 HTTP / 1.1 사양을 종합적으로 구성하는 일련의 문서 중 첫 번째입니다. 1. &quot;메시지 구문 및 라우팅&quot;(이 문서) 2. &quot;시맨틱 및 컨텐츠&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ] 3. &quot;조건부 요청&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ] 4. &quot;범위 요청&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ] 5. &quot;캐싱&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt; ] 6. &quot;인증&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ]이 HTTP / 1.1 사양은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145를 폐기합니다&lt;/a&gt;(HTTP 버전 관리). 이 사양은 또한 이전에 &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt; 에 정의 된 터널을 설정하기 위해 CONNECT 사용을 업데이트하고 &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818에&lt;/a&gt; 비공식적으로 설명 된 &quot;https&quot;URI 체계를 정의합니다.. HTTP는 정보 시스템을위한 일반적인 인터페이스 프로토콜입니다. 제공되는 리소스 유형에 관계없이 클라이언트에 균일 한 인터페이스를 제공하여 서비스 구현 방법에 대한 세부 정보를 숨기도록 설계되었습니다. 마찬가지로 서버는 각 클라이언트의 목적을 인식 할 필요가 없습니다. HTTP 요청은 특정 유형의 클라이언트 또는 미리 결정된 일련의 응용 프로그램 단계와 관련되는 것이 아니라 격리 된 것으로 간주 될 수 있습니다. 그 결과 많은 다른 상황에서 효과적으로 사용될 수 있고 구현이 시간이 지남에 따라 독립적으로 발전 할 수있는 프로토콜이 만들어집니다. HTTP는 또한 비 HTTP 정보 시스템과의 통신을 변환하기위한 중개 프로토콜로 사용하도록 설계되었습니다.HTTP 프록시 및 게이트웨이는 다양한 프로토콜을 HTTP 서비스와 동일한 방식으로 클라이언트가보고 조작 할 수있는 하이퍼 텍스트 형식으로 변환하여 대체 정보 서비스에 대한 액세스를 제공 할 수 있습니다. 이 유연성의 한 가지 결과는 프로토콜이 인터페이스 뒤에서 발생하는 측면에서 정의 될 수 없다는 것입니다. 대신, 우리는 의사 소통의 구문, 수신 된 의사의 의사의 의도, 수신자의 예상되는 행동을 정의하는 데 제한을받습니다. 통신이 격리 된 것으로 간주되면 서버에서 제공하는 관찰 가능한 인터페이스에 대한 해당 변경 사항에 성공적인 작업이 반영되어야합니다. 그러나 여러 클라이언트가 병렬로 작동하고 교차 목적으로 작동 할 수 있으므로단일 응답 범위를 넘어서 그러한 변경 사항을 관찰 할 것을 요구할 수는 없습니다. 이 문서는 HTTP에서 사용되거나 참조되는 아키텍처 요소를 설명하고 &quot;http&quot;및 &quot;https&quot;URI 체계를 정의하고 전반적인 네트워크 운영 및 연결 관리를 설명하며 HTTP 메시지 프레임 및 전달 요구 사항을 정의합니다. 우리의 목표는 메시지 의미와 무관 한 HTTP 메시지 처리에 필요한 모든 메커니즘을 정의하여 메시지 파서 및 메시지 전달 중개자에 대한 완전한 요구 사항을 정의하는 것입니다.전체 네트워크 운영 및 연결 관리에 대해 설명하고 HTTP 메시지 프레임 및 전달 요구 사항을 정의합니다. 우리의 목표는 메시지 의미와 무관 한 HTTP 메시지 처리에 필요한 모든 메커니즘을 정의하여 메시지 파서 및 메시지 전달 중개자에 대한 완전한 요구 사항을 정의하는 것입니다.전체 네트워크 운영 및 연결 관리에 대해 설명하고 HTTP 메시지 프레임 및 전달 요구 사항을 정의합니다. 우리의 목표는 메시지 의미와 무관 한 HTTP 메시지 처리에 필요한 모든 메커니즘을 정의하여 메시지 파서 및 메시지 전달 중개자에 대한 완전한 요구 사항을 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="265e7d56ba5f2b7320f23766ef7d78d6049d252e" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is a wildly successful
   protocol.  However, the way HTTP/1.1 uses the underlying transport
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6&quot;&gt;[RFC7230], Section&amp;nbsp;6&lt;/a&gt;) has several characteristics that have a
   negative overall effect on application performance today.

   In particular, HTTP/1.0 allowed only one request to be outstanding at
   a time on a given TCP connection.  HTTP/1.1 added request pipelining,
   but this only partially addressed request concurrency and still
   suffers from head-of-line blocking.  Therefore, HTTP/1.0 and HTTP/1.1
   clients that need to make many requests use multiple connections to a
   server in order to achieve concurrency and thereby reduce latency.

   Furthermore, HTTP header fields are often repetitive and verbose,
   causing unnecessary network traffic as well as causing the initial
   TCP [&lt;a href=&quot;#ref-TCP&quot;&gt;TCP&lt;/a&gt;] congestion window to quickly fill.  This can result in
   excessive latency when multiple requests are made on a new TCP
   connection.

   HTTP/2 addresses these issues by defining an optimized mapping of
   HTTP's semantics to an underlying connection.  Specifically, it
   allows interleaving of request and response messages on the same
   connection and uses an efficient coding for HTTP header fields.  It
   also allows prioritization of requests, letting more important
   requests complete more quickly, further improving performance. 

   The resulting protocol is more friendly to the network because fewer
   TCP connections can be used in comparison to HTTP/1.x.  This means
   less competition with other flows and longer-lived connections, which
   in turn lead to better utilization of available network capacity.

   Finally, HTTP/2 also enables more efficient processing of messages
   through use of binary message framing.</source>
          <target state="translated">HTTP (Hypertext Transfer Protocol)는 매우 성공적인 프로토콜입니다. 그러나 HTTP / 1.1이 기본 전송 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6&quot;&gt;[RFC7230], 섹션 6&lt;/a&gt; )을 사용하는 방식에는 오늘날 애플리케이션 성능에 부정적인 영향을 미치는 몇 가지 특성이 있습니다. 특히 HTTP / 1.0은 주어진 TCP 연결에서 한 번에 하나의 요청 만 처리 할 수 ​​있도록 허용했습니다. HTTP / 1.1은 요청 파이프 라이닝을 추가했지만 이것은 부분적으로 요청 동시성을 해결했으며 여전히 헤드 오브 라인 차단 문제를 겪고 있습니다. 따라서 많은 요청을해야하는 HTTP / 1.0 및 HTTP / 1.1 클라이언트는 동시성을 달성하여 대기 시간을 줄이기 위해 서버에 대한 다중 연결을 사용합니다. 또한 HTTP 헤더 필드는 종종 반복적이고 장황하여 불필요한 네트워크 트래픽을 유발할뿐만 아니라 초기 TCP [ &lt;a href=&quot;#ref-TCP&quot;&gt;TCP&lt;/a&gt;] 혼잡 창을 빠르게 채울 수 있습니다. 이로 인해 새 TCP 연결에 여러 요청이있을 때 과도한 지연이 발생할 수 있습니다. HTTP / 2는 기본 연결에 대한 HTTP 의미 체계의 최적화 된 매핑을 정의하여 이러한 문제를 해결합니다. 특히 동일한 연결에서 요청 및 응답 메시지의 인터리빙을 허용하고 HTTP 헤더 필드에 효율적인 코딩을 사용합니다. 또한 요청의 우선 순위를 지정하여 더 중요한 요청을 더 빨리 완료하고 성능을 더욱 향상시킬 수 있습니다. HTTP / 1.x와 비교하여 더 적은 수의 TCP 연결을 사용할 수 있으므로 결과 프로토콜은 네트워크에 더 친숙합니다. 즉, 다른 흐름과 수명이 긴 연결과의 경쟁이 줄어들어 사용 가능한 네트워크 용량을 더 잘 활용할 수 있습니다. 드디어,HTTP / 2는 또한 바이너리 메시지 프레이밍을 사용하여보다 효율적인 메시지 처리를 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="bfba6f949d10bf9871b3c465a4b0c721c894d894" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol (HTTP) is an application-level
   protocol for distributed, collaborative, hypermedia information
   systems. HTTP has been in use by the World-Wide Web global
   information initiative since 1990. The first version of HTTP,
   referred to as HTTP/0.9, was a simple protocol for raw data transfer
   across the Internet. HTTP/1.0, as defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; [&lt;a href=&quot;#ref-6&quot;&gt;6&lt;/a&gt;], improved
   the protocol by allowing messages to be in the format of MIME-like
   messages, containing metainformation about the data transferred and
   modifiers on the request/response semantics. However, HTTP/1.0 does
   not sufficiently take into consideration the effects of hierarchical
   proxies, caching, the need for persistent connections, or virtual
   hosts. In addition, the proliferation of incompletely-implemented
   applications calling themselves &quot;HTTP/1.0&quot; has necessitated a
   protocol version change in order for two communicating applications
   to determine each other's true capabilities.

   This specification defines the protocol referred to as &quot;HTTP/1.1&quot;.
   This protocol includes more stringent requirements than HTTP/1.0 in
   order to ensure reliable implementation of its features.

   Practical information systems require more functionality than simple
   retrieval, including search, front-end update, and annotation. HTTP
   allows an open-ended set of methods and headers that indicate the
   purpose of a request [&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt;]. It builds on the discipline of reference
   provided by the Uniform Resource Identifier (URI) [&lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt;], as a location
   (URL) [&lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt;] or name (URN) [&lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt;], for indicating the resource to which a 

   method is to be applied. Messages are passed in a format similar to
   that used by Internet mail [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] as defined by the Multipurpose
   Internet Mail Extensions (MIME) [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;].

   HTTP is also used as a generic protocol for communication between
   user agents and proxies/gateways to other Internet systems, including
   those supported by the SMTP [&lt;a href=&quot;#ref-16&quot;&gt;16&lt;/a&gt;], NNTP [&lt;a href=&quot;#ref-13&quot;&gt;13&lt;/a&gt;], FTP [&lt;a href=&quot;#ref-18&quot;&gt;18&lt;/a&gt;], Gopher [&lt;a href=&quot;#ref-2&quot;&gt;2&lt;/a&gt;],
   and WAIS [&lt;a href=&quot;#ref-10&quot;&gt;10&lt;/a&gt;] protocols. In this way, HTTP allows basic hypermedia
   access to resources available from diverse applications.</source>
          <target state="translated">HTTP (Hypertext Transfer Protocol)는 분산 된 협업 하이퍼 미디어 정보 시스템을위한 응용 프로그램 수준 프로토콜입니다. HTTP는 1990 년 이래 World-Wide Web 글로벌 정보 이니셔티브에서 사용되고 있습니다. HTTP / 0.9라고하는 HTTP의 첫 번째 버전은 인터넷을 통한 원시 데이터 전송을위한 간단한 프로토콜이었습니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945에&lt;/a&gt; 의해 정의 된 HTTP / 1.0 [ &lt;a href=&quot;#ref-6&quot;&gt;6&lt;/a&gt;], 전송 된 데이터 및 요청 / 응답 시맨틱에 대한 수정 자에 대한 메타 정보를 포함하는 메시지가 MIME 유사 메시지 형식이되도록하여 프로토콜을 개선했습니다. 그러나 HTTP / 1.0은 계층 프록시, 캐싱, 영구 연결 필요성 또는 가상 호스트의 영향을 충분히 고려하지 않습니다. 또한 자체적으로 &quot;HTTP / 1.0&quot;이라고하는 불완전하게 구현 된 응용 프로그램의 확산으로 인해 두 개의 통신 응용 프로그램이 서로의 실제 기능을 판단 할 수 있도록 프로토콜 버전이 변경되었습니다. 이 사양에서는 &quot;HTTP / 1.1&quot;이라는 프로토콜을 정의합니다. 이 프로토콜에는 기능을 안정적으로 구현하기 위해 HTTP / 1.0보다 엄격한 요구 사항이 포함되어 있습니다.실용적인 정보 시스템은 검색, 프런트 엔드 업데이트 및 주석을 포함하여 간단한 검색보다 더 많은 기능이 필요합니다. HTTP는 요청의 목적을 나타내는 개방형 메소드 및 헤더 세트를 허용합니다.&lt;a href=&quot;#ref-47&quot;&gt;47&lt;/a&gt; ]. 메소드가 적용될 자원을 표시하기 위해 URI (Uniform Resource Identifier) ​​[ &lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt; ]가 제공하는 참조 규율 ( 위치) (URL) [ &lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt; ] 또는 이름 (URN) [ &lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt; ]으로 작성됩니다. . 메시지는 MIME (Multipurpose Internet Mail Extensions) [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ]에 정의 된대로 인터넷 메일 [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]에서 사용하는 것과 유사한 형식으로 전달됩니다 . HTTP는 또한 SMTP [ &lt;a href=&quot;#ref-16&quot;&gt;16&lt;/a&gt; ], NNTP [ &lt;a href=&quot;#ref-13&quot;&gt;13&lt;/a&gt; ], FTP [ &lt;a href=&quot;#ref-18&quot;&gt;18&lt;/a&gt; ], Gopher [ &lt;a href=&quot;#ref-2&quot;&gt;2&lt;/a&gt; ] 및 WAIS [ 지원 ]를 포함하여 다른 인터넷 시스템에 대한 사용자 에이전트와 프록시 / 게이트웨이 간의 통신을위한 일반 프로토콜로도 사용됩니다.&lt;a href=&quot;#ref-10&quot;&gt;10&lt;/a&gt; ] 프로토콜. 이러한 방식으로 HTTP를 통해 다양한 응용 프로그램에서 사용 가능한 리소스에 대한 기본 하이퍼 미디어 액세스가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="1a129c42494254f3f39028a252991104523d52ce" translate="yes" xml:space="preserve">
          <source>The Hypertext Transfer Protocol Status Code 308 (Permanent Redirect)</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 상태 코드 308 (영구적 리디렉션)</target>
        </trans-unit>
        <trans-unit id="7c3eef52124b6a04770da43e5780935c839f5a5d" translate="yes" xml:space="preserve">
          <source>The IP address is invalid</source>
          <target state="translated">IP 주소가 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="6eeb9098fe0eb68f08e0d43612ff763509c93784" translate="yes" xml:space="preserve">
          <source>The IP address is unreachable</source>
          <target state="translated">IP 주소에 연결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2f67a1bb61a74c01a68383ec9ae389f39adb9d3d" translate="yes" xml:space="preserve">
          <source>The If header has two distinct purposes:

   o  The first purpose is to make a request conditional by supplying a
      series of state lists with conditions that match tokens and ETags
      to a specific resource.  If this header is evaluated and all state
      lists fail, then the request MUST fail with a 412 (Precondition
      Failed) status.  On the other hand, the request can succeed only
      if one of the described state lists succeeds.  The success
      criteria for state lists and matching functions are defined in
      Sections &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; and &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt;.

   o  Additionally, the mere fact that a state token appears in an If
      header means that it has been &quot;submitted&quot; with the request.  In
      general, this is used to indicate that the client has knowledge of
      that state token.  The semantics for submitting a state token
      depend on its type (for lock tokens, please refer to &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).

   Note that these two purposes need to be treated distinctly: a state
   token counts as being submitted independently of whether the server
   actually has evaluated the state list it appears in, and also
   independently of whether or not the condition it expressed was found
   to be true.</source>
          <target state="translated">If 헤더에는 다음과 같은 두 가지 목적이 있습니다. o 첫 번째 목적은 특정 자원에 토큰 및 ETag와 일치하는 조건이있는 일련의 상태 목록을 제공하여 요청을 조건부로 만드는 것입니다. 이 헤더가 평가되고 모든 상태 목록이 실패하면 요청은 412 (전제 조건 실패) 상태로 실패해야합니다. 반면에, 설명 된 상태 목록 중 하나가 성공한 경우에만 요청이 성공할 수 있습니다. 상태 목록 및 일치 기능의 성공 기준은 &lt;a href=&quot;#section-10.4.3&quot;&gt;10.4.3&lt;/a&gt; 및 &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt; 섹션에 정의되어 있습니다.. 또한 상태 토큰이 If 헤더에 표시된다는 사실은 요청과 함께 &quot;제출&quot;되었음을 의미합니다. 일반적으로 클라이언트가 해당 상태 토큰을 알고 있음을 나타내는 데 사용됩니다. 상태 토큰을 제출하기위한 시맨틱은 유형에 따라 다릅니다 (잠금 토큰의 경우 &lt;a href=&quot;#section-6&quot;&gt;섹션 6&lt;/a&gt; 참조 ). 이 두 가지 목적은 별개로 처리해야합니다. 상태 토큰은 서버가 실제로 표시되는 상태 목록을 평가했는지 여부와 표현 된 조건이 참인지 여부에 관계없이 제출 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ef772a237bb19f58e37ac6262a206108449c06a7" translate="yes" xml:space="preserve">
          <source>The If request header is intended to have similar functionality to
   the If-Match header defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.24&quot;&gt;Section&amp;nbsp;14.24 of [RFC2616]&lt;/a&gt;.  However,
   the If header handles any state token as well as ETags.  A typical
   example of a state token is a lock token, and lock tokens are the
   only state tokens defined in this specification.</source>
          <target state="translated">If 요청 헤더는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.24&quot;&gt;[RFC2616] 14.24 절에&lt;/a&gt; 정의 된 If-Match 헤더와 유사한 기능을 갖도록 고안되었습니다 . 그러나 If 헤더는 ETag뿐만 아니라 모든 상태 토큰을 처리합니다. 상태 토큰의 일반적인 예는 잠금 토큰이며 잠금 토큰은이 사양에 정의 된 유일한 상태 토큰입니다.</target>
        </trans-unit>
        <trans-unit id="f13702c8c2a26258beb9827d9b24d567b0373ca0" translate="yes" xml:space="preserve">
          <source>The If-Match request-header field is used with a method to make it
   conditional. A client that has one or more entities previously
   obtained from the resource can verify that one of those entities is
   current by including a list of their associated entity tags in the
   If-Match header field. Entity tags are defined in &lt;a href=&quot;#section-3.11&quot;&gt;section 3.11&lt;/a&gt;. The
   purpose of this feature is to allow efficient updates of cached
   information with a minimum amount of transaction overhead. It is also
   used, on updating requests, to prevent inadvertent modification of
   the wrong version of a resource. As a special case, the value &quot;*&quot;
   matches any current entity of the resource.

       If-Match = &quot;If-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )

   If any of the entity tags match the entity tag of the entity that
   would have been returned in the response to a similar GET request
   (without the If-Match header) on that resource, or if &quot;*&quot; is given 

   and any current entity exists for that resource, then the server MAY
   perform the requested method as if the If-Match header field did not
   exist.

   A server MUST use the strong comparison function (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;)
   to compare the entity tags in If-Match.

   If none of the entity tags match, or if &quot;*&quot; is given and no current
   entity exists, the server MUST NOT perform the requested method, and
   MUST return a 412 (Precondition Failed) response. This behavior is
   most useful when the client wants to prevent an updating method, such
   as PUT, from modifying a resource that has changed since the client
   last retrieved it.

   If the request would, without the If-Match header field, result in
   anything other than a 2xx or 412 status, then the If-Match header
   MUST be ignored.

   The meaning of &quot;If-Match: *&quot; is that the method SHOULD be performed
   if the representation selected by the origin server (or by a cache,
   possibly using the Vary mechanism, see &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt;) exists, and
   MUST NOT be performed if the representation does not exist.

   A request intended to update a resource (e.g., a PUT) MAY include an
   If-Match header field to signal that the request method MUST NOT be
   applied if the entity corresponding to the If-Match value (a single
   entity tag) is no longer a representation of that resource. This
   allows the user to indicate that they do not wish the request to be
   successful if the resource has been changed without their knowledge.
   Examples:

       If-Match: &quot;xyzzy&quot;
       If-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
       If-Match: *

   The result of a request having both an If-Match header field and
   either an If-None-Match or an If-Modified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">If-Match request-header 필드는 조건부로 만드는 방법과 함께 사용됩니다. 자원에서 이전에 얻은 하나 이상의 엔티티가있는 클라이언트는 If-Match 헤더 필드에 연관된 엔티티 태그 목록을 포함시켜 해당 엔티티 중 하나가 현재 상태인지 확인할 수 있습니다. 엔터티 태그는 &lt;a href=&quot;#section-3.11&quot;&gt;섹션 3.11에&lt;/a&gt; 정의되어 있습니다.. 이 기능의 목적은 최소한의 트랜잭션 오버 헤드로 캐시 된 정보를 효율적으로 업데이트 할 수 있도록하는 것입니다. 또한 요청을 업데이트 할 때 잘못된 버전의 리소스가 실수로 수정되는 것을 방지하기 위해 사용됩니다. 특별한 경우, &quot;*&quot;값은 현재 자원의 모든 엔티티와 일치합니다. If-Match = &quot;If-Match&quot; &quot;:&quot;( &quot;*&quot;| 1 # entity-tag) 엔티티 태그 중 하나가 유사한 GET 요청에 대한 응답으로 리턴 된 엔티티의 엔티티 태그와 일치하는 경우 ( 해당 자원에 If-Match 헤더가없는 경우) 또는 &quot;*&quot;가 제공되고 해당 자원에 대한 현재 엔티티가 존재하는 경우, 서버는 If-Match 헤더 필드가 존재하지 않는 것처럼 요청 된 메소드를 수행 할 수 있습니다.서버는 강력한 비교 기능을 사용해야합니다 ( &lt;a href=&quot;#section-13.3.3&quot;&gt;섹션 13.3.3 참조)&lt;/a&gt;)를 사용하여 If-Match에서 엔티티 태그를 비교하십시오. 일치하는 엔티티 태그가 없거나 &quot;*&quot;가 제공되고 현재 엔티티가 존재하지 않으면 서버는 요청 된 메소드를 수행하지 않아야하며 412 (사전 조건 실패) 응답을 리턴해야합니다. 이 동작은 클라이언트가 PUT과 같은 업데이트 방법이 클라이언트가 마지막으로 검색 한 이후 변경된 리소스를 수정하지 못하게하려는 경우에 가장 유용합니다. 요청이 If-Match 헤더 필드없이 2xx 또는 412 이외의 상태가된다면 If-Match 헤더는 무시되어야합니다. &quot;If-Match : *&quot;의 의미는 오리진 서버 (또는 캐시, 아마도 Vary 메커니즘을 사용하여 캐시에 의해 선택된 표현은 &lt;a href=&quot;#section-14.44&quot;&gt;14.44 절&lt;/a&gt; 참조)가 수행되는 경우이 방법을 수행해야한다는 것입니다.)가 존재하며 표현이 존재하지 않으면 수행해서는 안됩니다. 자원 (예를 들어, PUT)을 업데이트하기위한 요청은 If-Match 값에 대응하는 엔티티 (단일 엔티티 태그)가 더 이상 존재하지 않는 경우 요청 방법이 적용되어서는 안된다는 신호를 보내기 위해 If-Match 헤더 필드를 포함 할 수있다. 그 자원의 표현 이를 통해 사용자는 자신의 지식없이 자원이 변경된 경우 요청이 성공하기를 원하지 않음을 표시 할 수 있습니다. 예 : If-Match : &quot;xyzzy&quot;If-Match : &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;If-Match : * If-Match 헤더 필드와 If-None-Match가 모두있는 요청의 결과 또는 If-Modified-Since 헤더 필드는이 사양에 의해 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9436a493b897cd39a84206566701a405b2d51016" translate="yes" xml:space="preserve">
          <source>The If-Modified-Since request-header field is used with a method to
   make it conditional: if the requested variant has not been modified
   since the time specified in this field, an entity will not be
   returned from the server; instead, a 304 (not modified) response will
   be returned without any message-body.

       If-Modified-Since = &quot;If-Modified-Since&quot; &quot;:&quot; HTTP-date 

   An example of the field is:

       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   A GET method with an If-Modified-Since header and no Range header
   requests that the identified entity be transferred only if it has
   been modified since the date given by the If-Modified-Since header.
   The algorithm for determining this includes the following cases:

      a) If the request would normally result in anything other than a
         200 (OK) status, or if the passed If-Modified-Since date is
         invalid, the response is exactly the same as for a normal GET.
         A date which is later than the server's current time is
         invalid.

      b) If the variant has been modified since the If-Modified-Since
         date, the response is exactly the same as for a normal GET.

      c) If the variant has not been modified since a valid If-
         Modified-Since date, the server SHOULD return a 304 (Not
         Modified) response.

   The purpose of this feature is to allow efficient updates of cached
   information with a minimum amount of transaction overhead.

      Note: The Range request-header field modifies the meaning of If-
      Modified-Since; see &lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt; for full details.

      Note: If-Modified-Since times are interpreted by the server, whose
      clock might not be synchronized with the client.

      Note: When handling an If-Modified-Since header field, some
      servers will use an exact date comparison function, rather than a
      less-than function, for deciding whether to send a 304 (Not
      Modified) response. To get best results when sending an If-
      Modified-Since header field for cache validation, clients are
      advised to use the exact date string received in a previous Last-
      Modified header field whenever possible.

      Note: If a client uses an arbitrary date in the If-Modified-Since
      header instead of a date taken from the Last-Modified header for
      the same request, the client should be aware of the fact that this
      date is interpreted in the server's understanding of time. The
      client should consider unsynchronized clocks and rounding problems
      due to the different encodings of time between the client and
      server. This includes the possibility of race conditions if the
      document has changed between the time it was first requested and
      the If-Modified-Since date of a subsequent request, and the 

      possibility of clock-skew-related problems if the If-Modified-
      Since date is derived from the client's clock without correction
      to the server's clock. Corrections for different time bases
      between client and server are at best approximate due to network
      latency.

   The result of a request having both an If-Modified-Since header field
   and either an If-Match or an If-Unmodified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">If-Modified-Since 요청 헤더 필드는 조건부로 만드는 방법과 함께 사용됩니다. 요청 된 변형이이 필드에 지정된 시간 이후 수정되지 않은 경우 서버에서 엔티티가 리턴되지 않습니다. 대신 메시지 본문없이 304 (수정되지 않음) 응답이 반환됩니다. If-Modified-Since = &quot;If-Modified-Since&quot; &quot;:&quot;HTTP-date 필드의 예는 다음과 같습니다. If-Modified-Since : Sat, 1994 년 10 월 29 일 19:43:31 GMT If- Modified-Since 헤더 및 Range 헤더 없음은 식별 된 엔티티가 If-Modified-Since 헤더에 의해 제공된 날짜 이후에 수정 된 경우에만 전송되도록 요청합니다. 이를 결정하는 알고리즘에는 다음과 같은 경우가 포함됩니다.a) 요청이 정상적으로 200 (OK) 이외의 상태가되거나 전달 된 If-Modified-Since 날짜가 유효하지 않은 경우 응답은 일반 GET과 정확히 동일합니다. 서버의 현재 시간보다 늦은 날짜가 유효하지 않습니다. b) If-Modified-Since 날짜 이후에 변형이 수정 된 경우 응답은 일반 GET과 동일합니다. c) 유효한 수정 이후 날짜 이후에 변형이 수정되지 않은 경우 서버는 304 (수정되지 않음) 응답을 반환해야합니다. 이 기능의 목적은 최소한의 트랜잭션 오버 헤드로 캐시 된 정보를 효율적으로 업데이트 할 수 있도록하는 것입니다. 참고 : Range request-header 필드는 If- Modified-Since의 의미를 수정합니다. 보다또는 전달 된 If-Modified-Since 날짜가 유효하지 않은 경우 응답은 일반 GET과 동일합니다. 서버의 현재 시간보다 늦은 날짜가 유효하지 않습니다. b) If-Modified-Since 날짜 이후에 변형이 수정 된 경우 응답은 일반 GET과 동일합니다. c) 유효한 수정 이후 날짜 이후에 변형이 수정되지 않은 경우 서버는 304 (수정되지 않음) 응답을 반환해야합니다. 이 기능의 목적은 최소한의 트랜잭션 오버 헤드로 캐시 된 정보를 효율적으로 업데이트 할 수 있도록하는 것입니다. 참고 : Range request-header 필드는 If- Modified-Since의 의미를 수정합니다. 보다또는 전달 된 If-Modified-Since 날짜가 유효하지 않은 경우 응답은 일반 GET과 동일합니다. 서버의 현재 시간보다 늦은 날짜가 유효하지 않습니다. b) If-Modified-Since 날짜 이후에 변형이 수정 된 경우 응답은 일반 GET과 동일합니다. c) 유효한 수정 이후 날짜 이후에 변형이 수정되지 않은 경우 서버는 304 (수정되지 않음) 응답을 반환해야합니다. 이 기능의 목적은 최소한의 트랜잭션 오버 헤드로 캐시 된 정보를 효율적으로 업데이트 할 수 있도록하는 것입니다. 참고 : Range request-header 필드는 If- Modified-Since의 의미를 수정합니다. 보다서버의 현재 시간보다 늦은 날짜가 유효하지 않습니다. b) If-Modified-Since 날짜 이후에 변형이 수정 된 경우 응답은 일반 GET과 동일합니다. c) 유효한 수정 이후 날짜 이후에 변형이 수정되지 않은 경우 서버는 304 (수정되지 않음) 응답을 반환해야합니다. 이 기능의 목적은 최소한의 트랜잭션 오버 헤드로 캐시 된 정보를 효율적으로 업데이트 할 수 있도록하는 것입니다. 참고 : Range request-header 필드는 If- Modified-Since의 의미를 수정합니다. 보다서버의 현재 시간보다 늦은 날짜가 유효하지 않습니다. b) If-Modified-Since 날짜 이후에 변형이 수정 된 경우 응답은 일반 GET과 동일합니다. c) 유효한 수정 이후 날짜 이후에 변형이 수정되지 않은 경우 서버는 304 (수정되지 않음) 응답을 반환해야합니다. 이 기능의 목적은 최소한의 트랜잭션 오버 헤드로 캐시 된 정보를 효율적으로 업데이트 할 수 있도록하는 것입니다. 참고 : Range request-header 필드는 If- Modified-Since의 의미를 수정합니다. 보다c) 유효한 수정 이후 날짜 이후에 변형이 수정되지 않은 경우 서버는 304 (수정되지 않음) 응답을 반환해야합니다. 이 기능의 목적은 최소한의 트랜잭션 오버 헤드로 캐시 된 정보를 효율적으로 업데이트 할 수 있도록하는 것입니다. 참고 : Range request-header 필드는 If- Modified-Since의 의미를 수정합니다. 보다c) 유효한 수정 이후 날짜 이후에 변형이 수정되지 않은 경우 서버는 304 (수정되지 않음) 응답을 반환해야합니다. 이 기능의 목적은 최소한의 트랜잭션 오버 헤드로 캐시 된 정보를 효율적으로 업데이트 할 수 있도록하는 것입니다. 참고 : Range request-header 필드는 If- Modified-Since의 의미를 수정합니다. 보다&lt;a href=&quot;#section-14.35&quot;&gt;섹션 14.35&lt;/a&gt;자세한 내용은. 참고 : If-Modified-Since 시간은 서버에서 해석되며 시계는 클라이언트와 동기화되지 않을 수 있습니다. 참고 : If-Modified-Since 헤더 필드를 처리 할 때 일부 서버는 304 (수정되지 않음) 응답을 보낼지 여부를 결정하기 위해 기능보다 작지 않은 정확한 날짜 비교 기능을 사용합니다. 캐시 유효성 검사를 위해 If-Modified-Since 헤더 필드를 보낼 때 최상의 결과를 얻으려면 클라이언트는 가능할 때마다 이전 Last-modified 헤더 필드에서받은 정확한 날짜 문자열을 사용하는 것이 좋습니다. 참고 : 클라이언트가 동일한 요청에 대해 Last-Modified 헤더에서 가져온 날짜 대신 If-Modified-Since 헤더에서 임의의 날짜를 사용하는 경우,클라이언트는이 날짜가 서버의 시간 이해에서 해석된다는 사실을 알고 있어야합니다. 클라이언트는 클라이언트와 서버 간의 시간 인코딩이 다르기 때문에 동기화되지 않은 클럭과 반올림 문제를 고려해야합니다. 여기에는 문서가 처음 요청 된 시간과 후속 요청의 수정 후 날짜 사이에 변경된 경우 경쟁 조건의 가능성과 수정 후 날짜의 경우 시계 왜곡 관련 문제가 발생할 수 있습니다. 서버의 시계를 수정하지 않고 클라이언트의 시계에서 파생됩니다. 클라이언트와 서버 간의 다른 시간 기준에 대한 수정은 네트워크 대기 시간으로 인해 대략적으로 이루어집니다.If-Modified-Since 헤더 필드와 If-Match 또는 If-Unmodified-Since 헤더 필드가 모두있는 요청의 결과는이 사양에서 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39e92741a96fab5452a65a932345457528d34e55" translate="yes" xml:space="preserve">
          <source>The If-None-Match request-header field is used with a method to make
   it conditional. A client that has one or more entities previously
   obtained from the resource can verify that none of those entities is
   current by including a list of their associated entity tags in the
   If-None-Match header field. The purpose of this feature is to allow
   efficient updates of cached information with a minimum amount of
   transaction overhead. It is also used to prevent a method (e.g. PUT)
   from inadvertently modifying an existing resource when the client
   believes that the resource does not exist.

   As a special case, the value &quot;*&quot; matches any current entity of the
   resource.

       If-None-Match = &quot;If-None-Match&quot; &quot;:&quot; ( &quot;*&quot; | 1#entity-tag )

   If any of the entity tags match the entity tag of the entity that
   would have been returned in the response to a similar GET request
   (without the If-None-Match header) on that resource, or if &quot;*&quot; is
   given and any current entity exists for that resource, then the
   server MUST NOT perform the requested method, unless required to do
   so because the resource's modification date fails to match that
   supplied in an If-Modified-Since header field in the request.
   Instead, if the request method was GET or HEAD, the server SHOULD
   respond with a 304 (Not Modified) response, including the cache-
   related header fields (particularly ETag) of one of the entities that
   matched. For all other request methods, the server MUST respond with
   a status of 412 (Precondition Failed).

   See &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt; for rules on how to determine if two entities tags
   match. The weak comparison function can only be used with GET or HEAD
   requests. 

   If none of the entity tags match, then the server MAY perform the
   requested method as if the If-None-Match header field did not exist,
   but MUST also ignore any If-Modified-Since header field(s) in the
   request. That is, if no entity tags match, then the server MUST NOT
   return a 304 (Not Modified) response.

   If the request would, without the If-None-Match header field, result
   in anything other than a 2xx or 304 status, then the If-None-Match
   header MUST be ignored. (See &lt;a href=&quot;#section-13.3.4&quot;&gt;section 13.3.4&lt;/a&gt; for a discussion of
   server behavior when both If-Modified-Since and If-None-Match appear
   in the same request.)

   The meaning of &quot;If-None-Match: *&quot; is that the method MUST NOT be
   performed if the representation selected by the origin server (or by
   a cache, possibly using the Vary mechanism, see &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt;)
   exists, and SHOULD be performed if the representation does not exist.
   This feature is intended to be useful in preventing races between PUT
   operations.

   Examples:

       If-None-Match: &quot;xyzzy&quot;
       If-None-Match: W/&quot;xyzzy&quot;
       If-None-Match: &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;
       If-None-Match: W/&quot;xyzzy&quot;, W/&quot;r2d2xxxx&quot;, W/&quot;c3piozzzz&quot;
       If-None-Match: *

   The result of a request having both an If-None-Match header field and
   either an If-Match or an If-Unmodified-Since header fields is
   undefined by this specification.</source>
          <target state="translated">If-None-Match 요청 헤더 필드는 조건부로 만드는 방법과 함께 사용됩니다. 자원에서 이전에 얻은 하나 이상의 엔티티가있는 클라이언트는 If-None-Match 헤더 필드에 연관된 엔티티 태그 목록을 포함하여 해당 엔티티가 현재 없음을 확인할 수 있습니다. 이 기능의 목적은 최소한의 트랜잭션 오버 헤드로 캐시 된 정보를 효율적으로 업데이트 할 수 있도록하는 것입니다. 또한 클라이언트가 리소스가 존재하지 않는다고 판단 할 때 메소드 (예 : PUT)가 기존 리소스를 실수로 수정하지 못하도록 방지하는 데 사용됩니다. 특별한 경우, &quot;*&quot;값은 현재 자원의 모든 엔티티와 일치합니다. If-None-Match = &quot;If-None-Match&quot; &quot;:&quot;( &quot;*&quot;| 1 # entity-tag) 엔티티 태그 중 하나가 해당 자원의 유사한 GET 요청 (If-None-Match 헤더없이)에 대한 응답으로 리턴 된 엔티티의 엔티티 태그와 일치하거나 &quot;* &quot;가 주어지고 해당 자원에 대한 현재 엔티티가 존재하는 경우, 자원의 수정 날짜가 요청의 If-Modified-Since 헤더 필드에 제공된 것과 일치하지 않으므로 서버는 요청 된 메소드를 수행하지 않아야합니다. 대신 요청 방법이 GET 또는 HEAD 인 경우 서버는 일치하는 엔티티 중 하나의 캐시 관련 헤더 필드 (특히 ETag)를 포함하여 304 (수정되지 않음) 응답으로 응답해야합니다. 다른 모든 요청 방법의 경우 서버는 상태 412 (전제 조건 실패)로 응답해야합니다. 보다보다보다보다보다자원의 수정 날짜가 요청의 If-Modified-Since 헤더 필드에 제공된 것과 일치하지 않기 때문에 서버는 요청 된 메소드를 수행하지 않아야합니다. 대신 요청 방법이 GET 또는 HEAD 인 경우 서버는 일치하는 엔티티 중 하나의 캐시 관련 헤더 필드 (특히 ETag)를 포함하여 304 (수정되지 않음) 응답으로 응답해야합니다. 다른 모든 요청 방법의 경우 서버는 상태 412 (전제 조건 실패)로 응답해야합니다. 보다리소스의 수정 날짜가 요청의 If-Modified-Since 헤더 필드에 제공된 날짜와 일치하지 않기 때문에 서버는 요청 된 메소드를 수행하지 않아야합니다. 대신 요청 방법이 GET 또는 HEAD 인 경우 서버는 일치하는 엔티티 중 하나의 캐시 관련 헤더 필드 (특히 ETag)를 포함하여 304 (수정되지 않음) 응답으로 응답해야합니다. 다른 모든 요청 방법의 경우 서버는 상태 412 (전제 조건 실패)로 응답해야합니다. 보다서버는 일치하는 엔티티 중 하나의 캐시 관련 헤더 필드 (특히 ETag)를 포함하여 304 (수정되지 않음) 응답으로 응답해야합니다 (SHOULD). 다른 모든 요청 방법의 경우 서버는 상태 412 (전제 조건 실패)로 응답해야합니다. 보다서버는 일치하는 엔티티 중 하나의 캐시 관련 헤더 필드 (특히 ETag)를 포함하여 304 (수정되지 않음) 응답으로 응답해야합니다 (SHOULD). 다른 모든 요청 방법의 경우 서버는 상태 412 (전제 조건 실패)로 응답해야합니다. 보다&lt;a href=&quot;#section-13.3.3&quot;&gt;&lt;/a&gt;두 항목 태그가 일치하는지 확인하는 방법에 대한 규칙은 13.3.3 단원을 참조하십시오 . 약한 비교 기능은 GET 또는 HEAD 요청에만 사용할 수 있습니다. 일치하는 엔티티 태그가 없으면, 서버는 요청 된 메소드를 If-None-Match 헤더 필드가 존재하지 않는 것처럼 수행 할 수 있지만 요청의 If-Modified-Since 헤더 필드도 무시해야합니다. 즉, 엔티티 태그가 일치하지 않으면 서버는 304 (수정되지 않음) 응답을 반환해서는 안됩니다 (MUST NOT). 요청이 If-None-Match 헤더 필드없이 2xx 또는 304 이외의 상태가된다면 If-None-Match 헤더는 무시되어야합니다. ( &lt;a href=&quot;#section-13.3.4&quot;&gt;섹션 13.3.4&lt;/a&gt; 참조If-Modified-Since와 If-None-Match가 동일한 요청에 나타날 때 서버 비헤이비어에 대해 설명합니다.) &quot;If-None-Match : *&quot;의 의미는 표현이 선택된 경우이 방법을 수행하지 않아야한다는 것입니다. 오리진 서버 또는 캐시 (Vary 메커니즘을 사용하는 경우) &lt;a href=&quot;#section-14.44&quot;&gt;섹션 14.44&lt;/a&gt; 참조)가 존재하고 표현이 존재하지 않으면 수행되어야한다. 이 기능은 PUT 작업 간의 경쟁을 방지하는 데 유용합니다. 예 : If-None-Match : &quot;xyzzy&quot;If-None-Match : W / &quot;xyzzy&quot;If-None-Match : &quot;xyzzy&quot;, &quot;r2d2xxxx&quot;, &quot;c3piozzzz&quot;If-None-Match : W / &quot;xyzzy&quot; , W / &quot;r2d2xxxx&quot;, W / &quot;c3piozzzz&quot;If-None-Match : * If-None-Match 헤더 필드와 If-Match 또는 If-Unmodified-Since 헤더 필드가 모두있는 요청의 결과는 다음과 같습니다. 이 사양에서는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a77607d9e035711baba5b97bc67fee22711422dd" translate="yes" xml:space="preserve">
          <source>The If-Unmodified-Since request-header field is used with a method to
   make it conditional. If the requested resource has not been modified
   since the time specified in this field, the server SHOULD perform the
   requested operation as if the If-Unmodified-Since header were not
   present.

   If the requested variant has been modified since the specified time,
   the server MUST NOT perform the requested operation, and MUST return
   a 412 (Precondition Failed).

      If-Unmodified-Since = &quot;If-Unmodified-Since&quot; &quot;:&quot; HTTP-date

   An example of the field is:

       If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT

   If the request normally (i.e., without the If-Unmodified-Since
   header) would result in anything other than a 2xx or 412 status, the
   If-Unmodified-Since header SHOULD be ignored.

   If the specified date is invalid, the header is ignored.

   The result of a request having both an If-Unmodified-Since header
   field and either an If-None-Match or an If-Modified-Since header
   fields is undefined by this specification.</source>
          <target state="translated">If-Unmodified-Since 요청 헤더 필드는 조건부로 만드는 방법과 함께 사용됩니다. 이 필드에 지정된 시간 이후 요청 된 리소스가 수정되지 않은 경우 서버는 If-Unmodified-Since 헤더가없는 것처럼 요청 된 작업을 수행해야합니다. 지정된 시간 이후에 요청 된 변형이 수정 된 경우 서버는 요청 된 작업을 수행해서는 안되며 412 (사전 조건 실패)를 반환해야합니다. If-Unmodified-Since = &quot;If-Unmodified-Since&quot; &quot;:&quot;HTTP-date 필드의 예는 다음과 같습니다. If-Unmodified-Since : Sat, 1994 년 10 월 29 일 19:43:31 GMT 요청이 정상적으로 수행되는 경우 (예 : If-Unmodified-Since 헤더가 없으면 2xx 또는 412 이외의 상태가되므로 If-Unmodified-Since 헤더는 무시해야합니다.지정된 날짜가 유효하지 않으면 헤더가 무시됩니다. If-Unmodified-Since 헤더 필드와 If-None-Match 또는 If-Modified-Since 헤더 필드가 모두있는 요청의 결과는이 스펙에서 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fdfb0dc451f3880ef0d4f67dac2ee95582caadcf" translate="yes" xml:space="preserve">
          <source>The JavaScript function returns a single string</source>
          <target state="translated">JavaScript 함수는 단일 문자열을 반환합니다</target>
        </trans-unit>
        <trans-unit id="703e778a54d67833e0037322f76c267a64284bbc" translate="yes" xml:space="preserve">
          <source>The JavaScript function should always be saved to a file by itself and not be embedded in HTML.</source>
          <target state="translated">JavaScript 함수는 항상 파일 자체에 저장해야하며 HTML에 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="b34c71697b1823e77b9a782ccdbeeb5fdf757c55" translate="yes" xml:space="preserve">
          <source>The JavaScript function should always be saved to a file by itself but not be embedded in a HTML file or any other file.</source>
          <target state="translated">JavaScript 함수는 항상 자체적으로 파일에 저장되어야하지만 HTML 파일이나 다른 파일에 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="ae3233de7c368a8e5f19a8ef2604664291230823" translate="yes" xml:space="preserve">
          <source>The JavaScript snippets included in these sections (and running instances of the server-code that correctly handles these cross-site requests) can be found &quot;in action&quot; at &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;http://arunranga.com/examples/access-control/&lt;/a&gt;, and will work in browsers that support cross-site &lt;code&gt;XMLHttpRequest&lt;/code&gt;.</source>
          <target state="translated">이 섹션에 포함 된 JavaScript 스 니펫 (및 이러한 교차 사이트 요청을 올바르게 처리하는 서버 코드 인스턴스 실행)은 &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;http://arunranga.com/examples/access-control/&lt;/a&gt; 에서 &quot;실제로&quot;찾을 수 있습니다. 크로스 사이트 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 를 지원하는 브라우저에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="925661df194abc683169e90bef883c4c078be359" translate="yes" xml:space="preserve">
          <source>The Keep-Alive Header (Experimental specification)</source>
          <target state="translated">Keep-Alive 헤더 (실험 사양)</target>
        </trans-unit>
        <trans-unit id="db2749cedc967fd4ef7ed7614b130c614deab08c" translate="yes" xml:space="preserve">
          <source>The Last-Modified entity-header field indicates the date and time at
   which the origin server believes the variant was last modified.

       Last-Modified  = &quot;Last-Modified&quot; &quot;:&quot; HTTP-date 

   An example of its use is

       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT

   The exact meaning of this header field depends on the implementation
   of the origin server and the nature of the original resource. For
   files, it may be just the file system last-modified time. For
   entities with dynamically included parts, it may be the most recent
   of the set of last-modify times for its component parts. For database
   gateways, it may be the last-update time stamp of the record. For
   virtual objects, it may be the last time the internal state changed.

   An origin server MUST NOT send a Last-Modified date which is later
   than the server's time of message origination. In such cases, where
   the resource's last modification would indicate some time in the
   future, the server MUST replace that date with the message
   origination date.

   An origin server SHOULD obtain the Last-Modified value of the entity
   as close as possible to the time that it generates the Date value of
   its response. This allows a recipient to make an accurate assessment
   of the entity's modification time, especially if the entity changes
   near the time that the response is generated.

   HTTP/1.1 servers SHOULD send Last-Modified whenever feasible.</source>
          <target state="translated">Last-Modified entity-header (최종 수정 된 엔터티 헤더) 필드는 원본 서버에서 변형이 마지막으로 수정 된 날짜와 시간을 나타냅니다. Last-Modified = &quot;Last-Modified&quot; &quot;:&quot;HTTP-date 사용 예는 Last-Modified : Tue, 1994 년 11 월 15 일 12:45:26 GMT이 헤더 필드의 정확한 의미는 원본 구현에 따라 다릅니다. 서버 및 원래 자원의 특성. 파일의 경우 파일 시스템이 마지막으로 수정 된 시간 일 수 있습니다. 동적으로 포함 된 부품이있는 엔티티의 경우 구성 요소 부품에 대한 최신 수정 시간 집합 일 수 있습니다. 데이터베이스 게이트웨이의 경우 레코드의 마지막 업데이트 타임 스탬프 일 수 있습니다. 가상 객체의 경우 내부 상태가 마지막으로 변경된 시간 일 수 있습니다.오리진 서버는 서버가 메시지를 보낸 시간보다 늦은 Last-Modified 날짜를 보내서는 안됩니다. 그러한 경우, 자원의 마지막 수정이 미래의 시간을 나타내는 경우, 서버는 해당 날짜를 메시지 시작 날짜로 바꿔야합니다. 오리진 서버는 응답의 Date 값을 생성하는 시간에 최대한 가깝게 엔티티의 Last-Modified 값을 가져와야합니다. 이를 통해 특히 응답이 생성되는 시간에 개체가 변경되는 경우 수신자는 개체의 수정 시간을 정확하게 평가할 수 있습니다. HTTP / 1.1 서버는 가능할 때마다 Last-Modified를 보내야한다.마지막 수정은 미래의 시간을 나타내며 서버는 해당 날짜를 메시지 시작 날짜로 바꿔야합니다. 오리진 서버는 응답의 날짜 값을 생성하는 시간에 최대한 가깝게 엔터티의 마지막 수정 값을 가져와야합니다. 이를 통해 특히 응답이 생성되는 시간에 개체가 변경되는 경우 수신자는 개체의 수정 시간을 정확하게 평가할 수 있습니다. HTTP / 1.1 서버는 가능할 때마다 Last-Modified를 보내야한다.마지막 수정은 미래의 시간을 나타내며 서버는 해당 날짜를 메시지 시작 날짜로 바꿔야합니다. 오리진 서버는 응답의 Date 값을 생성하는 시간에 최대한 가깝게 엔티티의 Last-Modified 값을 가져와야합니다. 이를 통해 특히 응답이 생성되는 시간에 개체가 변경되는 경우 수신자는 개체의 수정 시간을 정확하게 평가할 수 있습니다. HTTP / 1.1 서버는 가능할 때마다 Last-Modified를 보내야한다.s 수정 시간, 특히 응답이 생성되는 시간에 개체가 변경되는 경우. HTTP / 1.1 서버는 가능할 때마다 Last-Modified를 보내야한다.s 수정 시간, 특히 응답이 생성되는 시간에 개체가 변경되는 경우. HTTP / 1.1 서버는 가능할 때마다 Last-Modified를 보내야한다.</target>
        </trans-unit>
        <trans-unit id="528a83f631c94edde30298fe82ad4b470dc52fd6" translate="yes" xml:space="preserve">
          <source>The Last-Modified entity-header field value is often used as a cache
   validator. In simple terms, a cache entry is considered to be valid
   if the entity has not been modified since the Last-Modified value.</source>
          <target state="translated">Last-Modified entity-header 필드 값은 종종 캐시 유효성 검사기로 사용됩니다. 간단히 말해서, Last-Modified 값 이후 엔터티가 수정되지 않은 경우 캐시 항목이 유효한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="017625ae11b1cf3babbe1d1e9f72538a1d0bcdba" translate="yes" xml:space="preserve">
          <source>The Location response-header field is used to redirect the recipient
   to a location other than the Request-URI for completion of the
   request or identification of a new resource. For 201 (Created)
   responses, the Location is that of the new resource which was created
   by the request. For 3xx responses, the location SHOULD indicate the
   server's preferred URI for automatic redirection to the resource. The
   field value consists of a single absolute URI.

       Location       = &quot;Location&quot; &quot;:&quot; absoluteURI

   An example is:

       Location: &lt;a href=&quot;http://www.w3.org/pub/WWW/People.html&quot;&gt;http://www.w3.org/pub/WWW/People.html&lt;/a&gt;

      Note: The Content-Location header field (&lt;a href=&quot;#section-14.14&quot;&gt;section 14.14&lt;/a&gt;) differs
      from Location in that the Content-Location identifies the original
      location of the entity enclosed in the request. It is therefore
      possible for a response to contain header fields for both Location
      and Content-Location. Also see &lt;a href=&quot;#section-13.10&quot;&gt;section 13.10&lt;/a&gt; for cache
      requirements of some methods.</source>
          <target state="translated">Location response-header (위치 응답 헤더) 필드는 요청 완료 또는 새 리소스 식별을 위해 수신자를 Request-URI 이외의 위치로 리디렉션하는 데 사용됩니다. 201 (작성 됨) 응답의 경우 위치는 요청에 의해 작성된 새 자원의 위치입니다. 3xx 응답의 경우, 위치는 자원으로의 자동 재 지정을 위해 서버가 선호하는 URI를 표시해야한다. 필드 값은 단일 절대 URI로 구성됩니다. Location = &quot;Location&quot; &quot;:&quot;absoluteURI 예는 다음과 같습니다. Location : &lt;a href=&quot;http://www.w3.org/pub/WWW/People.html&quot;&gt;http://www.w3.org/pub/WWW/People.html&lt;/a&gt; 참고 : Content-Location 헤더 필드 ( &lt;a href=&quot;#section-14.14&quot;&gt;섹션 14.14&lt;/a&gt;)는 Content-Location이 요청에 포함 된 엔티티의 원래 위치를 식별한다는 점에서 Location과 다릅니다. 따라서 응답에 Location 및 Content-Location 모두에 대한 헤더 필드가 포함될 수 있습니다. 또한 일부 메소드의 캐시 요구 사항에 대해서는 &lt;a href=&quot;#section-13.10&quot;&gt;13.10 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5bc7ceee0f881c0002d5d80140938c1e7f80c8e7" translate="yes" xml:space="preserve">
          <source>The MIME type of audiovisual files mostly indicate the container formats. The most common ones on the Web are:</source>
          <target state="translated">시청각 파일의 MIME 유형은 대부분 컨테이너 형식을 나타냅니다. 웹에서 가장 일반적인 것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e997fc9b96d9d0ec4b11746c0834f2c40378a91" translate="yes" xml:space="preserve">
          <source>The MOVE operation on a non-collection resource is the logical
   equivalent of a copy (COPY), followed by consistency maintenance
   processing, followed by a delete of the source, where all three
   actions are performed in a single operation.  The consistency
   maintenance step allows the server to perform updates caused by the
   move, such as updating all URLs, other than the Request-URI that
   identifies the source resource, to point to the new destination
   resource. 

   The Destination header MUST be present on all MOVE methods and MUST
   follow all COPY requirements for the COPY part of the MOVE method.
   All WebDAV-compliant resources MUST support the MOVE method.

   Support for the MOVE method does not guarantee the ability to move a
   resource to a particular destination.  For example, separate programs
   may actually control different sets of resources on the same server.
   Therefore, it may not be possible to move a resource within a
   namespace that appears to belong to the same server.

   If a resource exists at the destination, the destination resource
   will be deleted as a side-effect of the MOVE operation, subject to
   the restrictions of the Overwrite header.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">The MOVE operation on a non-collection resource is the logical equivalent of a copy (COPY), followed by consistency maintenance processing, followed by a delete of the source, where all three actions are performed in a single operation. The consistency maintenance step allows the server to perform updates caused by the move, such as updating all URLs, other than the Request-URI that identifies the source resource, to point to the new destination resource. The Destination header MUST be present on all MOVE methods and MUST follow all COPY requirements for the COPY part of the MOVE method. All WebDAV-compliant resources MUST support the MOVE method. Support for the MOVE method does not guarantee the ability to move a resource to a particular destination. For example, separate programs may actually control different sets of resources on the same server. Therefore, it may not be possible to move a resource within a namespace that appears to belong to the same server. If a resource exists at the destination, the destination resource will be deleted as a side-effect of the MOVE operation, subject to the restrictions of the Overwrite header. This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616] 섹션 9.1&lt;/a&gt; ). 이 방법에 대한 응답은 캐시해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="cb1023831cad3159839df21a4251dd372a13a0bc" translate="yes" xml:space="preserve">
          <source>The Max-Forwards request-header field provides a mechanism with the
   TRACE (&lt;a href=&quot;#section-9.8&quot;&gt;section 9.8&lt;/a&gt;) and OPTIONS (&lt;a href=&quot;#section-9.2&quot;&gt;section 9.2&lt;/a&gt;) methods to limit the
   number of proxies or gateways that can forward the request to the
   next inbound server. This can be useful when the client is attempting
   to trace a request chain which appears to be failing or looping in
   mid-chain.

       Max-Forwards   = &quot;Max-Forwards&quot; &quot;:&quot; 1*DIGIT

   The Max-Forwards value is a decimal integer indicating the remaining
   number of times this request message may be forwarded.

   Each proxy or gateway recipient of a TRACE or OPTIONS request
   containing a Max-Forwards header field MUST check and update its
   value prior to forwarding the request. If the received value is zero
   (0), the recipient MUST NOT forward the request; instead, it MUST
   respond as the final recipient. If the received Max-Forwards value is
   greater than zero, then the forwarded message MUST contain an updated
   Max-Forwards field with a value decremented by one (1).

   The Max-Forwards header field MAY be ignored for all other methods
   defined by this specification and for any extension methods for which
   it is not explicitly referred to as part of that method definition.</source>
          <target state="translated">Max-Forwards 요청 헤더 필드는 TRACE ( &lt;a href=&quot;#section-9.8&quot;&gt;섹션 9.8&lt;/a&gt; ) 및 OPTIONS ( &lt;a href=&quot;#section-9.2&quot;&gt;섹션 9.2&lt;/a&gt; )와 함께 메커니즘을 제공합니다.) 요청을 다음 인바운드 서버로 전달할 수있는 프록시 또는 게이트웨이 수를 제한하는 방법. 이는 클라이언트가 미드 체인에서 실패하거나 루핑 된 것으로 보이는 요청 체인을 추적하려고 할 때 유용 할 수 있습니다. Max-Forwards = &quot;Max-Forwards&quot; &quot;:&quot;1 * DIGIT Max-Forwards 값은이 요청 메시지가 전달 될 수있는 남은 횟수를 나타내는 십진 정수입니다. Max-Forwards 헤더 필드를 포함하는 TRACE 또는 OPTIONS 요청의 각 프록시 또는 게이트웨이 수신자는 요청을 전달하기 전에 해당 값을 확인하고 업데이트해야합니다. 수신 된 값이 0이면, 수신자는 요청을 전달해서는 안된다. 대신 최종 수신자로 응답해야합니다. 수신 된 Max-Forwards 값이 0보다 큰 경우전달 된 메시지는 업데이트 된 Max-Forwards 필드를 1만큼 감소한 값으로 포함해야합니다. Max-Forwards 헤더 필드는이 표준에 의해 정의 된 다른 모든 메소드와 해당 메소드 정의의 일부로 명시 적으로 언급되지 않은 확장 메소드에 대해서는 무시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9679bb7ec73b85f439581526aa5e2f804e20f5f" translate="yes" xml:space="preserve">
          <source>The Member URI allows clients to retrieve, edit, and delete a Member
   Resource using HTTP's GET, PUT, and DELETE methods.  Entry Resources
   are represented as Atom Entry documents.

   Member URIs appear in two places.  They are returned in a Location
   header after successful Resource creation using POST, as described in
   &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt; below.  They can also appear in a Collection Feed's
   Entries, as atom:link elements with a link relation of &quot;edit&quot;.

   A Member Entry SHOULD contain such an atom:link element with a link
   relation of &quot;edit&quot;, which indicates the Member URI.</source>
          <target state="translated">멤버 URI를 통해 클라이언트는 HTTP의 GET, PUT 및 DELETE 메소드를 사용하여 멤버 자원을 검색, 편집 및 삭제할 수 있습니다. 응모 자료는 Atom Entry 문서로 표시됩니다. 멤버 URI는 두 곳에 나타납니다. 아래 &lt;a href=&quot;#section-9.2&quot;&gt;섹션 9.2에&lt;/a&gt; 설명 된대로 POST를 사용하여 리소스를 성공적으로 생성 한 후 Location 헤더에 반환 됩니다. 또한 &quot;feed&quot;링크 관계를 가진 atom : link 요소로 Collection Feed의 항목에 나타날 수 있습니다. 멤버 엔트리는 멤버 관계를 나타내는 &quot;edit&quot;의 링크 관계를 갖는 그러한 atom : link 요소를 포함해야한다 (SHOULD).</target>
        </trans-unit>
        <trans-unit id="8bc27eaceea013a32bec84be620f4a677881aac7" translate="yes" xml:space="preserve">
          <source>The Method  token indicates the method to be performed on the
   resource identified by the Request-URI. The method is case-sensitive.

       Method         = &quot;OPTIONS&quot;                ; &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;
                      | &quot;GET&quot;                    ; &lt;a href=&quot;#section-9.3&quot;&gt;Section 9.3&lt;/a&gt;
                      | &quot;HEAD&quot;                   ; &lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt;
                      | &quot;POST&quot;                   ; &lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;
                      | &quot;PUT&quot;                    ; &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;
                      | &quot;DELETE&quot;                 ; &lt;a href=&quot;#section-9.7&quot;&gt;Section 9.7&lt;/a&gt;
                      | &quot;TRACE&quot;                  ; &lt;a href=&quot;#section-9.8&quot;&gt;Section 9.8&lt;/a&gt;
                      | &quot;CONNECT&quot;                ; &lt;a href=&quot;#section-9.9&quot;&gt;Section 9.9&lt;/a&gt;
                      | extension-method
       extension-method = token

   The list of methods allowed by a resource can be specified in an
   Allow header field (&lt;a href=&quot;#section-14.7&quot;&gt;section 14.7&lt;/a&gt;). The return code of the response
   always notifies the client whether a method is currently allowed on a
   resource, since the set of allowed methods can change dynamically. An
   origin server SHOULD return the status code 405 (Method Not Allowed)
   if the method is known by the origin server but not allowed for the
   requested resource, and 501 (Not Implemented) if the method is
   unrecognized or not implemented by the origin server. The methods GET
   and HEAD MUST be supported by all general-purpose servers. All other
   methods are OPTIONAL; however, if the above methods are implemented,
   they MUST be implemented with the same semantics as those specified
   in &lt;a href=&quot;#section-9&quot;&gt;section 9&lt;/a&gt;.</source>
          <target state="translated">메소드 토큰은 Request-URI로 식별 된 자원에서 수행 할 메소드를 나타냅니다. 이 방법은 대소 문자를 구분합니다. 방법 = &quot;옵션&quot;; &lt;a href=&quot;#section-9.2&quot;&gt;섹션 9.2&lt;/a&gt; | &quot;가져 오기&quot; ; &lt;a href=&quot;#section-9.3&quot;&gt;섹션 9.3&lt;/a&gt; | &quot;헤드&quot;; &lt;a href=&quot;#section-9.4&quot;&gt;섹션 9.4&lt;/a&gt; | &quot;게시하다&quot; ; &lt;a href=&quot;#section-9.5&quot;&gt;섹션 9.5&lt;/a&gt; | &quot;PUT&quot;; &lt;a href=&quot;#section-9.6&quot;&gt;섹션 9.6&lt;/a&gt; | &quot;삭제&quot;; &lt;a href=&quot;#section-9.7&quot;&gt;섹션 9.7&lt;/a&gt; | &quot;TRACE&quot;; &lt;a href=&quot;#section-9.8&quot;&gt;섹션 9.8&lt;/a&gt; | &quot;잇다&quot;; &lt;a href=&quot;#section-9.9&quot;&gt;섹션 9.9&lt;/a&gt; | extension-method extension-method = token 리소스가 허용하는 메소드 목록은 헤더 허용 필드 ( &lt;a href=&quot;#section-14.7&quot;&gt;섹션 14.7)&lt;/a&gt; 에서 지정할 수 있습니다.). 허용 된 메소드 세트가 동적으로 변경 될 수 있으므로 응답의 리턴 코드는 항상 메소드가 현재 자원에서 허용되는지 여부를 클라이언트에 알립니다. 오리진 서버는 메소드가 오리진 서버에 의해 알려져 있지만 요청 된 자원에 대해 허용되지 않은 경우 상태 코드 405 (Method Not Allowed)를 리턴해야하며, 메소드가 인식되지 않거나 오리진 서버에 의해 구현되지 않은 경우 501 (Not Implemented)을 리턴해야합니다. GET 및 HEAD 방법은 모든 범용 서버에서 지원해야합니다. 다른 모든 방법은 선택 사항입니다. 그러나 위의 방법을 구현하는 경우 반드시 &lt;a href=&quot;#section-9&quot;&gt;섹션 9에&lt;/a&gt; 지정된 것과 동일한 의미로 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b472ea77a890edf2b85c6971105718fc4fd6fc42" translate="yes" xml:space="preserve">
          <source>The OPTIONS method represents a request for information about the
   communication options available on the request/response chain
   identified by the Request-URI. This method allows the client to
   determine the options and/or requirements associated with a resource,
   or the capabilities of a server, without implying a resource action
   or initiating a resource retrieval.

   Responses to this method are not cacheable.

   If the OPTIONS request includes an entity-body (as indicated by the
   presence of Content-Length or Transfer-Encoding), then the media type
   MUST be indicated by a Content-Type field. Although this
   specification does not define any use for such a body, future
   extensions to HTTP might use the OPTIONS body to make more detailed
   queries on the server. A server that does not support such an
   extension MAY discard the request body.

   If the Request-URI is an asterisk (&quot;*&quot;), the OPTIONS request is
   intended to apply to the server in general rather than to a specific
   resource. Since a server's communication options typically depend on
   the resource, the &quot;*&quot; request is only useful as a &quot;ping&quot; or &quot;no-op&quot;
   type of method; it does nothing beyond allowing the client to test
   the capabilities of the server. For example, this can be used to test
   a proxy for HTTP/1.1 compliance (or lack thereof).

   If the Request-URI is not an asterisk, the OPTIONS request applies
   only to the options that are available when communicating with that
   resource.

   A 200 response SHOULD include any header fields that indicate
   optional features implemented by the server and applicable to that
   resource (e.g., Allow), possibly including extensions not defined by
   this specification. The response body, if any, SHOULD also include
   information about the communication options. The format for such a 

   body is not defined by this specification, but might be defined by
   future extensions to HTTP. Content negotiation MAY be used to select
   the appropriate response format. If no response body is included, the
   response MUST include a Content-Length field with a field-value of
   &quot;0&quot;.

   The Max-Forwards request-header field MAY be used to target a
   specific proxy in the request chain. When a proxy receives an OPTIONS
   request on an absoluteURI for which request forwarding is permitted,
   the proxy MUST check for a Max-Forwards field. If the Max-Forwards
   field-value is zero (&quot;0&quot;), the proxy MUST NOT forward the message;
   instead, the proxy SHOULD respond with its own communication options.
   If the Max-Forwards field-value is an integer greater than zero, the
   proxy MUST decrement the field-value when it forwards the request. If
   no Max-Forwards field is present in the request, then the forwarded
   request MUST NOT include a Max-Forwards field.</source>
          <target state="translated">OPTIONS 메소드는 Request-URI로 식별 된 요청 / 응답 체인에서 사용 가능한 통신 옵션에 대한 정보 요청을 나타냅니다. 이 방법을 사용하면 클라이언트는 리소스 작업을 암시하거나 리소스 검색을 시작하지 않고도 리소스 또는 서버의 기능과 관련된 옵션 및 / 또는 요구 사항을 결정할 수 있습니다. 이 방법에 대한 응답은 캐시 할 수 없습니다. OPTIONS 요청에 엔티티 본문 (Content-Length 또는 Transfer-Encoding이 있음으로 표시됨)이 포함 된 경우 미디어 유형은 반드시 Content-Type 필드로 표시해야합니다. 이 스펙이 그러한 본문에 대한 사용을 정의하지는 않지만 향후 HTTP 확장은 OPTIONS 본문을 사용하여 서버에서 더 자세한 조회를 할 수 있습니다.이러한 확장을 지원하지 않는 서버는 요청 본문을 버릴 수 있습니다. Request-URI가 별표 ( &quot;*&quot;) 인 경우 OPTIONS 요청은 특정 자원이 아닌 서버에 일반적으로 적용됩니다. 서버의 통신 옵션은 일반적으로 리소스에 따라 다르므로 &quot;*&quot;요청은 &quot;ping&quot;또는 &quot;no-op&quot;유형의 방법으로 만 유용합니다. 클라이언트가 서버의 기능을 테스트 할 수 있도록하는 것 이상은 없습니다. 예를 들어, 이는 HTTP / 1.1 준수 (또는 부족)에 대한 프록시를 테스트하는 데 사용될 수 있습니다. Request-URI가 별표가 아닌 경우 OPTIONS 요청은 해당 자원과 통신 할 때 사용 가능한 옵션에만 적용됩니다.200 응답은 서버에 의해 구현되고 해당 규격에 정의되지 않은 확장을 포함하여 해당 자원에 적용 할 수있는 선택적 기능을 나타내는 헤더 필드를 포함해야한다 (SHOULD). 응답 본문에는 통신 옵션에 대한 정보도 포함되어야한다 (SHOULD). 이러한 본문의 형식은이 사양에 의해 정의되지 않지만 향후 HTTP 확장으로 정의 될 수 있습니다. 콘텐츠 협상을 사용하여 적절한 응답 형식을 선택할 수 있습니다. 응답 본문이 포함되어 있지 않으면 응답에 필드 값이 &quot;0&quot;인 Content-Length 필드가 포함되어야합니다. Max-Forwards 요청 헤더 필드는 요청 체인의 특정 프록시를 대상으로하는 데 사용될 수 있습니다.프록시가 요청 전달이 허용 된 absoluteURI에서 OPTIONS 요청을 수신하면 프록시는 Max-Forwards 필드를 확인해야합니다. Max-Forwards 필드 값이 0 ( &quot;0&quot;)이면 프록시는 메시지를 전달해서는 안됩니다. 대신 프록시는 자체 통신 옵션으로 응답해야합니다. Max-Forwards 필드 값이 0보다 큰 정수인 경우 프록시는 요청을 전달할 때 필드 값을 줄여야합니다. 요청에 Max-Forwards 필드가 없으면 전달 된 요청에 Max-Forwards 필드가 포함되어서는 안됩니다 (MUST NOT).Max-Forwards 필드 값이 0보다 큰 정수인 경우 프록시는 요청을 전달할 때 필드 값을 줄여야합니다. 요청에 Max-Forwards 필드가 없으면 전달 된 요청에는 Max-Forwards 필드가 포함되어서는 안됩니다 (MUST NOT).Max-Forwards 필드 값이 0보다 큰 정수인 경우 프록시는 요청을 전달할 때 필드 값을 줄여야합니다. 요청에 Max-Forwards 필드가 없으면 전달 된 요청에는 Max-Forwards 필드가 포함되어서는 안됩니다 (MUST NOT).</target>
        </trans-unit>
        <trans-unit id="49820b72a266a24d241c6570cc10be88c4ce50ca" translate="yes" xml:space="preserve">
          <source>The OPTIONS method requests information about the communication
   options available for the target resource, at either the origin
   server or an intervening intermediary.  This method allows a client
   to determine the options and/or requirements associated with a
   resource, or the capabilities of a server, without implying a
   resource action. 

   An OPTIONS request with an asterisk (&quot;*&quot;) as the request-target
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of [RFC7230]&lt;/a&gt;) applies to the server in general rather
   than to a specific resource.  Since a server's communication options
   typically depend on the resource, the &quot;*&quot; request is only useful as a
   &quot;ping&quot; or &quot;no-op&quot; type of method; it does nothing beyond allowing the
   client to test the capabilities of the server.  For example, this can
   be used to test a proxy for HTTP/1.1 conformance (or lack thereof).

   If the request-target is not an asterisk, the OPTIONS request applies
   to the options that are available when communicating with the target
   resource.

   A server generating a successful response to OPTIONS SHOULD send any
   header fields that might indicate optional features implemented by
   the server and applicable to the target resource (e.g., Allow),
   including potential extensions not defined by this specification.
   The response payload, if any, might also describe the communication
   options in a machine or human-readable representation.  A standard
   format for such a representation is not defined by this
   specification, but might be defined by future extensions to HTTP.  A
   server MUST generate a Content-Length field with a value of &quot;0&quot; if no
   payload body is to be sent in the response.

   A client MAY send a Max-Forwards header field in an OPTIONS request
   to target a specific recipient in the request chain (see
   &lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;).  A proxy MUST NOT generate a Max-Forwards header
   field while forwarding a request unless that request was received
   with a Max-Forwards field.

   A client that generates an OPTIONS request containing a payload body
   MUST send a valid Content-Type header field describing the
   representation media type.  Although this specification does not
   define any use for such a payload, future extensions to HTTP might
   use the OPTIONS body to make more detailed queries about the target
   resource.

   Responses to the OPTIONS method are not cacheable.</source>
          <target state="translated">OPTIONS 메소드는 원래 서버 또는 중간 매개체에서 대상 자원에 사용 가능한 통신 옵션에 대한 정보를 요청합니다. 이 방법을 사용하면 클라이언트는 리소스 작업을 암시하지 않고 리소스 또는 서버의 기능과 관련된 옵션 및 / 또는 요구 사항을 결정할 수 있습니다. 별표 ( &quot;*&quot;)를 요청 대상으로 사용하는 OPTIONS 요청 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.3&quot;&gt;[RFC7230]의 섹션 5.3&lt;/a&gt;)는 특정 리소스가 아닌 일반적으로 서버에 적용됩니다. 서버의 통신 옵션은 일반적으로 리소스에 따라 다르므로 &quot;*&quot;요청은 &quot;ping&quot;또는 &quot;no-op&quot;유형의 방법으로 만 유용합니다. 클라이언트가 서버의 기능을 테스트 할 수 있도록하는 것 이상은 없습니다. 예를 들어, 이것은 HTTP / 1.1 적합성 (또는 그 부족)에 대한 프록시를 테스트하는 데 사용될 수 있습니다. 요청 대상이 별표가 아닌 경우 OPTIONS 요청은 대상 자원과 통신 할 때 사용 가능한 옵션에 적용됩니다. OPTIONS에 대한 성공적인 응답을 생성하는 서버는 서버가 구현하고 대상 자원에 적용 가능한 선택적 기능 (예 : 허용)을 나타내는 헤더 필드를 보내야합니다.이 사양에서 정의하지 않은 잠재적 인 확장을 포함합니다. 응답 페이로드 (있는 경우)는 기계 또는 사람이 읽을 수있는 표현의 통신 옵션을 설명 할 수도 있습니다. 이러한 표현에 대한 표준 형식은이 사양에 의해 정의되지 않지만 향후 HTTP 확장으로 정의 될 수 있습니다. 페이로드 본문을 응답으로 보내지 않으면 서버는 값이 &quot;0&quot;인 Content-Length 필드를 생성해야합니다. 클라이언트는 요청 체인의 특정 수신자를 대상으로 OPTIONS 요청에 Max-Forwards 헤더 필드를 보낼 수 있습니다 (참조).그러나 향후 HTTP 확장으로 정의 될 수 있습니다. 페이로드 본문을 응답으로 보내지 않으면 서버는 값이 &quot;0&quot;인 Content-Length 필드를 생성해야합니다. 클라이언트는 요청 체인의 특정 수신자를 대상으로 OPTIONS 요청에 Max-Forwards 헤더 필드를 보낼 수 있습니다 (참조).그러나 향후 HTTP 확장으로 정의 될 수 있습니다. 페이로드 본문을 응답으로 보내지 않으면 서버는 값이 &quot;0&quot;인 Content-Length 필드를 생성해야합니다. 클라이언트는 요청 체인의 특정 수신자를 대상으로 OPTIONS 요청에 Max-Forwards 헤더 필드를 보낼 수 있습니다 (참조). &lt;a href=&quot;#section-5.1.2&quot;&gt;섹션 5.1.2&lt;/a&gt; ). 요청을 Max-Forwards 필드와 함께 수신하지 않는 한 프록시는 요청을 전달하는 동안 Max-Forwards 헤더 필드를 생성해서는 안됩니다 (MUST NOT). 페이로드 본문을 포함하는 OPTIONS 요청을 생성하는 클라이언트는 표현 미디어 유형을 설명하는 유효한 Content-Type 헤더 필드를 보내야합니다. 이 스펙은 그러한 페이로드에 대한 사용을 정의하지 않지만, 향후 HTTP 확장은 OPTIONS 본문을 사용하여 대상 자원에 대한 자세한 조회를 작성할 수 있습니다. OPTIONS 메소드에 대한 응답은 캐시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="335a905cdd5cc098f1e6a149fd20a764baed11c1" translate="yes" xml:space="preserve">
          <source>The Opera browser is also based on the Blink engine, which is why it almost looks the same, but adds &lt;code&gt;&quot;OPR/&amp;lt;version&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">Opera 브라우저도 Blink 엔진을 기반으로하므로 거의 동일하게 보이지만 &lt;code&gt;&quot;OPR/&amp;lt;version&amp;gt;&quot;&lt;/code&gt; 을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="1d0b5a78c1f599442b880ea6a8403854d20e3ef6" translate="yes" xml:space="preserve">
          <source>The Opera browser is also based on the blink engine, which is why it almost looks the same, but adds &quot;OPR/&amp;lt;version&amp;gt;&quot;.</source>
          <target state="translated">Opera 브라우저는 또한 깜박임 엔진을 기반으로하므로 거의 동일하게 보이지만 &quot;OPR / &amp;lt;version&amp;gt;&quot;을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1a9fb731478c28f4fa3740727c3862c0e8280261" translate="yes" xml:space="preserve">
          <source>The Operating System is given in most User Agent strings (although not web-focused platforms like Firefox OS), but the format varies a lot. It is a fixed string between two semi-colons, in the comment part of the User Agent. These strings are specific for each browser. They indicate the OS, but also often its version and information on the relying hardware (32 or 64 bits, or Intel/PPC for Mac).</source>
          <target state="translated">운영 체제는 대부분의 User Agent 문자열로 제공되지만 (Firefox OS와 같은 웹 중심 플랫폼은 아니지만) 형식은 많이 다릅니다. 사용자 에이전트의 주석 부분에서 두 개의 세미콜론 사이에 고정 문자열입니다. 이 문자열은 각 브라우저마다 다릅니다. OS뿐만 아니라 의존 하드웨어 (32 또는 64 비트 또는 Mac 용 Intel / PPC)에 대한 버전 및 정보도 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b865b396cc503b061720f4db16c1a8fdc2531248" translate="yes" xml:space="preserve">
          <source>The PAC file is named &lt;code&gt;proxy.pac&lt;/code&gt;</source>
          <target state="translated">PAC 파일의 이름은 &lt;code&gt;proxy.pac&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1f9837bd9139ad48f4cd2dd0906bd1f2401fbe7f" translate="yes" xml:space="preserve">
          <source>The PAC file is named proxy.pac</source>
          <target state="translated">PAC 파일 이름은 proxy.pac입니다.</target>
        </trans-unit>
        <trans-unit id="ad2834ac0702672d145d7ca3894c53d5a21fd051" translate="yes" xml:space="preserve">
          <source>The PHP snippets (and the JavaScript invocations to the server) in subsequent sections are taken from &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;the working code samples posted here.&lt;/a&gt; These will work in browsers that implement cross-site &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음 섹션의 PHP 스 니펫 (및 서버에 대한 JavaScript 호출) &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;은 여기에 게시 된 작업 코드 샘플&lt;/a&gt; 에서 가져옵니다 . 이들은 크로스 사이트 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 를 구현하는 브라우저에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="68bd99f90bb560cf24ee3bfb0650ff1043f9b961" translate="yes" xml:space="preserve">
          <source>The PING frame (type=0x6) is a mechanism for measuring a minimal
   round-trip time from the sender, as well as determining whether an
   idle connection is still functional.  PING frames can be sent from
   any endpoint.

    +---------------------------------------------------------------+
    |                                                               |
    |                      Opaque Data (64)                         |
    |                                                               |
    +---------------------------------------------------------------+

                      Figure 12: PING Payload Format

   In addition to the frame header, PING frames MUST contain 8 octets of
   opaque data in the payload.  A sender can include any value it
   chooses and use those octets in any fashion.

   Receivers of a PING frame that does not include an ACK flag MUST send
   a PING frame with the ACK flag set in response, with an identical
   payload.  PING responses SHOULD be given higher priority than any
   other frame.

   The PING frame defines the following flags:

   ACK (0x1):  When set, bit 0 indicates that this PING frame is a PING
      response.  An endpoint MUST set this flag in PING responses.  An
      endpoint MUST NOT respond to PING frames containing this flag. 

   PING frames are not associated with any individual stream.  If a PING
   frame is received with a stream identifier field value other than
   0x0, the recipient MUST respond with a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   Receipt of a PING frame with a length field value other than 8 MUST
   be treated as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   FRAME_SIZE_ERROR.</source>
          <target state="translated">PING 프레임 (유형 = 0x6)은 발신자의 최소 왕복 시간을 측정하고 유휴 연결이 여전히 작동하는지 여부를 결정하는 메커니즘입니다. PING 프레임은 모든 엔드 포인트에서 전송할 수 있습니다. + ------------------------------------------------- -------------- + | | | 불투명 데이터 (64) | | | + ------------------------------------------------- -------------- + 그림 12 : PING 페이로드 형식 프레임 헤더 외에도 PING 프레임은 페이로드에 8 옥텟의 불투명 데이터를 포함해야합니다. 보낸 사람은 선택한 모든 값을 포함 할 수 있으며 어떤 방식 으로든 해당 옥텟을 사용할 수 있습니다. ACK 플래그를 포함하지 않는 PING 프레임의 수신자는 동일한 페이로드로 응답으로 설정된 ACK 플래그와 함께 PING 프레임을 전송해야합니다. PING 응답은 다른 프레임보다 더 높은 우선 순위를 부여해야합니다. PING 프레임은 다음 플래그를 정의합니다. ACK (0x1) : 설정시,비트 0은이 PING 프레임이 PING 응답임을 나타냅니다. 엔드 포인트는 PING 응답에서이 플래그를 설정해야합니다. 엔드 포인트는이 플래그를 포함하는 PING 프레임에 응답하지 않아야합니다. PING 프레임은 개별 스트림과 연결되지 않습니다. 0x0 이외의 스트림 식별자 필드 값으로 PING 프레임이 수신되면 수신자는 연결 오류 (&lt;a href=&quot;#section-5.4.1&quot;&gt;&lt;/a&gt;PROTOCOL_ERROR 유형의 섹션 5.4.1 ). 길이 필드 값이 8이 아닌 PING 프레임 수신은 FRAME_SIZE_ERROR 유형 의 연결 오류 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt; ) 로 처리 되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d84539c58092eb061728beac8d3510599c78d9e2" translate="yes" xml:space="preserve">
          <source>The POST method is used to request that the origin server accept the
   entity enclosed in the request as a new subordinate of the resource
   identified by the Request-URI in the Request-Line. POST is designed
   to allow a uniform method to cover the following functions:

      - Annotation of existing resources;

      - Posting a message to a bulletin board, newsgroup, mailing list,
        or similar group of articles;

      - Providing a block of data, such as the result of submitting a
        form, to a data-handling process;

      - Extending a database through an append operation.

   The actual function performed by the POST method is determined by the
   server and is usually dependent on the Request-URI. The posted entity
   is subordinate to that URI in the same way that a file is subordinate
   to a directory containing it, a news article is subordinate to a
   newsgroup to which it is posted, or a record is subordinate to a
   database.

   The action performed by the POST method might not result in a
   resource that can be identified by a URI. In this case, either 200
   (OK) or 204 (No Content) is the appropriate response status,
   depending on whether or not the response includes an entity that
   describes the result. 

   If a resource has been created on the origin server, the response
   SHOULD be 201 (Created) and contain an entity which describes the
   status of the request and refers to the new resource, and a Location
   header (see &lt;a href=&quot;#section-14.30&quot;&gt;section 14.30&lt;/a&gt;).

   Responses to this method are not cacheable, unless the response
   includes appropriate Cache-Control or Expires header fields. However,
   the 303 (See Other) response can be used to direct the user agent to
   retrieve a cacheable resource.

   POST requests MUST obey the message transmission requirements set out
   in &lt;a href=&quot;#section-8.2&quot;&gt;section 8.2&lt;/a&gt;.

   See &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations.</source>
          <target state="translated">POST 메소드는 오리진 서버가 요청에 포함 된 엔티티를 요청 라인의 Request-URI에 의해 식별 된 자원의 새로운 하위 항목으로 승인하도록 요청하는 데 사용됩니다. POST는 균일 한 방법으로 다음 기능을 처리 할 수 ​​있도록 설계되었습니다.-기존 자원의 주석; -게시판, 뉴스 그룹, 메일 링리스트 또는 유사한 기사 그룹에 메시지 게시; -양식 제출 결과와 같은 데이터 블록을 데이터 처리 프로세스에 제공 -추가 작업을 통해 데이터베이스를 확장합니다. POST 방법으로 수행되는 실제 기능은 서버에 의해 결정되며 일반적으로 Request-URI에 따라 다릅니다. 게시 된 엔티티는 파일이 포함 된 디렉토리에 종속 된 것과 동일한 방식으로 해당 URI에 종속됩니다.뉴스 기사는 게시 된 뉴스 그룹에 종속되거나 레코드는 데이터베이스에 종속됩니다. POST 메소드에 의해 수행 된 조치로 인해 URI로 식별 할 수있는 자원이 생성되지 않을 수 있습니다. 이 경우 응답에 결과를 설명하는 엔터티가 포함되어 있는지 여부에 따라 200 (OK) 또는 204 (No Content)가 적절한 응답 상태입니다. 원 서버에서 자원이 생성 된 경우 응답은 201 (생성)이어야하고 요청 상태를 설명하고 새 자원과 위치 헤더를 참조하는 엔티티를 포함해야합니다 (참조).이 경우 응답에 결과를 설명하는 엔터티가 포함되어 있는지 여부에 따라 200 (OK) 또는 204 (No Content)가 적절한 응답 상태입니다. 오리진 서버에서 리소스가 생성 된 경우 응답은 201 (생성)이어야하고 요청 상태를 설명하고 새 리소스 및 위치 헤더를 나타내는 엔터티를 포함해야합니다 (참조).이 경우 응답에 결과를 설명하는 엔터티가 포함되어 있는지 여부에 따라 200 (OK) 또는 204 (No Content)가 적절한 응답 상태입니다. 오리진 서버에서 리소스가 생성 된 경우 응답은 201 (생성)이어야하고 요청 상태를 설명하고 새 리소스 및 위치 헤더를 나타내는 엔터티를 포함해야합니다 (참조).&lt;a href=&quot;#section-14.30&quot;&gt;섹션 14.30&lt;/a&gt; ). 응답에 적절한 Cache-Control 또는 Expires 헤더 필드가 포함되어 있지 않으면이 방법에 대한 응답을 캐시 할 수 없습니다. 그러나 303 (기타 참조) 응답을 사용하여 사용자 에이전트가 캐시 가능한 자원을 검색하도록 지시 할 수 있습니다. POST 요청은 &lt;a href=&quot;#section-8.2&quot;&gt;섹션 8.2에&lt;/a&gt; 설정된 메시지 전송 요구 사항을 준수해야합니다 . 보안 고려 사항에 대해서는 &lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7c4a0540415d773e2957d84d1e4f16f405d585a" translate="yes" xml:space="preserve">
          <source>The POST method requests that the target resource process the
   representation enclosed in the request according to the resource's
   own specific semantics.  For example, POST is used for the following
   functions (among others):

   o  Providing a block of data, such as the fields entered into an HTML
      form, to a data-handling process; 

   o  Posting a message to a bulletin board, newsgroup, mailing list,
      blog, or similar group of articles;

   o  Creating a new resource that has yet to be identified by the
      origin server; and

   o  Appending data to a resource's existing representation(s).

   An origin server indicates response semantics by choosing an
   appropriate status code depending on the result of processing the
   POST request; almost all of the status codes defined by this
   specification might be received in a response to POST (the exceptions
   being 206 (Partial Content), 304 (Not Modified), and 416 (Range Not
   Satisfiable)).

   If one or more resources has been created on the origin server as a
   result of successfully processing a POST request, the origin server
   SHOULD send a 201 (Created) response containing a Location header
   field that provides an identifier for the primary resource created
   (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;) and a representation that describes the status of the
   request while referring to the new resource(s).

   Responses to POST requests are only cacheable when they include
   explicit freshness information (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7234]&lt;/a&gt;).
   However, POST caching is not widely implemented.  For cases where an
   origin server wishes the client to be able to cache the result of a
   POST in a way that can be reused by a later GET, the origin server
   MAY send a 200 (OK) response containing the result and a
   Content-Location header field that has the same value as the POST's
   effective request URI (&lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt;).

   If the result of processing a POST would be equivalent to a
   representation of an existing resource, an origin server MAY redirect
   the user agent to that resource by sending a 303 (See Other) response
   with the existing resource's identifier in the Location field.  This
   has the benefits of providing the user agent a resource identifier
   and transferring the representation via a method more amenable to
   shared caching, though at the cost of an extra request if the user
   agent does not already have the representation cached.</source>
          <target state="translated">POST 메소드는 대상 자원이 자원 고유의 의미에 따라 요청에 포함 된 표현을 처리하도록 요청합니다. 예를 들어 POST는 다음과 같은 기능에 사용됩니다. o HTML 양식에 입력 된 필드와 같은 데이터 블록을 데이터 처리 프로세스에 제공합니다. o 게시판, 뉴스 그룹, 메일 목록, 블로그 또는 유사한 기사 그룹에 메시지 게시; o 오리진 서버에 의해 아직 식별되지 않은 새로운 자원 작성; o 자원의 기존 표현에 데이터 추가. 오리진 서버는 POST 요청 처리 결과에 따라 적절한 상태 코드를 선택하여 응답 의미론을 표시합니다.이 사양에서 정의한 거의 모든 상태 코드는 POST에 대한 응답으로 수신 될 수 있습니다 (예외는 206 (부분 내용), 304 (수정되지 않음) 및 416 (범위가 만족스럽지 않음)). POST 요청을 성공적으로 처리 한 결과로 오리진 서버에서 하나 이상의 리소스가 생성 된 경우 오리진 서버는 생성 된 기본 리소스에 대한 식별자를 제공하는 Location 헤더 필드를 포함하는 201 (Created) 응답을 보내야합니다.오리진 서버는 생성 된 1 차 자원에 대한 식별자를 제공하는 Location 헤더 필드를 포함하는 201 (Created) 응답을 보내야한다.오리진 서버는 생성 된 1 차 자원에 대한 식별자를 제공하는 Location 헤더 필드를 포함하는 201 (Created) 응답을 보내야한다.&lt;a href=&quot;#section-7.1.2&quot;&gt;섹션 7.1.2&lt;/a&gt; ) 및 새로운 자원을 참조하면서 요청의 상태를 설명하는 표현. POST 요청에 대한 응답은 명시 적 최신 정보가 포함 된 경우에만 캐시 할 수 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.1&quot;&gt;[RFC7234]의 섹션 4.2.1&lt;/a&gt; 참조 ). 그러나 POST 캐싱은 널리 구현되지 않았습니다. 오리진 서버가 클라이언트가 나중에 GET에 의해 재사용 될 수있는 방식으로 POST 결과를 캐시 할 수 있기를 원하는 경우, 오리진 서버는 결과와 Content-Location을 포함하는 200 (OK) 응답을 보낼 수 있습니다. POST의 유효 요청 URI와 동일한 값을 가진 헤더 필드 ( &lt;a href=&quot;#section-3.1.4.2&quot;&gt;3.1.4.2 절)&lt;/a&gt;). POST 처리 결과가 기존 자원의 표현과 동일한 경우, 원 서버는 Location 필드에 기존 자원의 식별자와 함께 303 (기타 참조) 응답을 전송하여 사용자 에이전트를 해당 자원으로 리디렉션 할 수 있습니다. 이는 사용자 에이전트가 이미 캐시 된 표현을 가지고 있지 않은 경우 추가 요청 비용으로 사용자 에이전트에 자원 식별자를 제공하고 공유 캐싱에 더 적합한 방법을 통해 표시를 전송하는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="009ae6509d491675faf3db2c6925c60d8bb4838c" translate="yes" xml:space="preserve">
          <source>The PRIORITY frame (type=0x2) specifies the sender-advised priority
   of a stream (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  It can be sent in any stream state,
   including idle or closed streams. 

    +-+-------------------------------------------------------------+
    |E|                  Stream Dependency (31)                     |
    +-+-------------+-----------------------------------------------+
    |   Weight (8)  |
    +-+-------------+

                     Figure 8: PRIORITY Frame Payload

   The payload of a PRIORITY frame contains the following fields:

   E: A single-bit flag indicating that the stream dependency is
      exclusive (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).

   Stream Dependency:  A 31-bit stream identifier for the stream that
      this stream depends on (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).

   Weight:  An unsigned 8-bit integer representing a priority weight for
      the stream (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;).  Add one to the value to obtain a
      weight between 1 and 256.

   The PRIORITY frame does not define any flags.

   The PRIORITY frame always identifies a stream.  If a PRIORITY frame
   is received with a stream identifier of 0x0, the recipient MUST
   respond with a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   The PRIORITY frame can be sent on a stream in any state, though it
   cannot be sent between consecutive frames that comprise a single
   header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).  Note that this frame could arrive after
   processing or frame sending has completed, which would cause it to
   have no effect on the identified stream.  For a stream that is in the
   &quot;half-closed (remote)&quot; or &quot;closed&quot; state, this frame can only affect
   processing of the identified stream and its dependent streams; it
   does not affect frame transmission on that stream.

   The PRIORITY frame can be sent for a stream in the &quot;idle&quot; or &quot;closed&quot;
   state.  This allows for the reprioritization of a group of dependent
   streams by altering the priority of an unused or closed parent
   stream.

   A PRIORITY frame with a length other than 5 octets MUST be treated as
   a stream error (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) of type FRAME_SIZE_ERROR.</source>
          <target state="translated">PRIORITY 프레임 (유형 = 0x2)은 스트림의 송신자 권고 우선 순위를 지정합니다 ( &lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt; ). 유휴 또는 닫힌 스트림을 포함하여 모든 스트림 상태로 전송할 수 있습니다. +-+ ----------------------------------------------- -------------- + | E | 스트림 종속성 (31) | +-+ ------------- + --------------------------------- -------------- + | 무게 (8) | +-+ ------------- + 그림 8 : PRIORITY 프레임 페이로드 PRIORITY 프레임의 페이로드에는 다음 필드가 포함됩니다. E : 스트림 종속성이 배타적임을 나타내는 단일 비트 플래그 (참조 : &lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt; ). 스트림 종속성 :이 스트림이 의존하는 스트림에 대한 31 비트 스트림 식별자 ( &lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt; 참조 ). 가중치 : 스트림의 우선 순위 가중치를 나타내는 부호없는 8 비트 정수 ( &lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt; 참조)). 값에 1을 더하여 1과 256 사이의 가중치를 얻습니다. PRIORITY 프레임은 플래그를 정의하지 않습니다. PRIORITY 프레임은 항상 스트림을 식별합니다. 0x0의 스트림 식별자로 PRIORITY 프레임이 수신되면 수신자 는 PROTOCOL_ERROR 유형 의 연결 오류 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt; )로 응답해야 합니다. PRIORITY 프레임은 단일 헤더 블록을 구성하는 연속 프레임간에 전송할 수 없지만 모든 상태의 스트림에서 전송할 수 있습니다 ( &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt;). 이 프레임은 처리 또는 프레임 전송이 완료된 후에 도착할 수 있으므로 식별 된 스트림에 영향을 미치지 않습니다. &quot;반 닫힘 (원격)&quot;또는 &quot;닫힘&quot;상태에있는 스트림의 경우이 프레임은 식별 된 스트림과 해당 종속 스트림의 처리에만 영향을 줄 수 있습니다. 해당 스트림의 프레임 전송에는 영향을주지 않습니다. PRIORITY 프레임은 &quot;유휴&quot;또는 &quot;닫힘&quot;상태의 스트림에 대해 전송 될 수 있습니다. 이를 통해 사용되지 않거나 닫힌 상위 스트림의 우선 순위를 변경하여 종속 스트림 그룹의 우선 순위를 다시 지정할 수 있습니다. 길이가 5 옥텟이 아닌 PRIORITY 프레임은 FRAME_SIZE_ERROR 유형 의 스트림 오류 ( &lt;a href=&quot;#section-5.4.2&quot;&gt;섹션 5.4.2&lt;/a&gt; ) 로 처리 되어야합니다.</target>
        </trans-unit>
        <trans-unit id="babc13478772ae526be737f6ddcf858ed85d894b" translate="yes" xml:space="preserve">
          <source>The PROPFIND method retrieves properties defined on the resource
   identified by the Request-URI, if the resource does not have any
   internal members, or on the resource identified by the Request-URI
   and potentially its member resources, if the resource is a collection
   that has internal member URLs.  All DAV-compliant resources MUST
   support the PROPFIND method and the propfind XML element
   (&lt;a href=&quot;#section-14.20&quot;&gt;Section 14.20&lt;/a&gt;) along with all XML elements defined for use with that
   element.

   A client MUST submit a Depth header with a value of &quot;0&quot;, &quot;1&quot;, or
   &quot;infinity&quot; with a PROPFIND request.  Servers MUST support &quot;0&quot; and &quot;1&quot;
   depth requests on WebDAV-compliant resources and SHOULD support
   &quot;infinity&quot; requests.  In practice, support for infinite-depth
   requests MAY be disabled, due to the performance and security
   concerns associated with this behavior.  Servers SHOULD treat a
   request without a Depth header as if a &quot;Depth: infinity&quot; header was
   included. 

   A client may submit a 'propfind' XML element in the body of the
   request method describing what information is being requested.  It is
   possible to:

   o  Request particular property values, by naming the properties
      desired within the 'prop' element (the ordering of properties in
      here MAY be ignored by the server),

   o  Request property values for those properties defined in this
      specification (at a minimum) plus dead properties, by using the
      'allprop' element (the 'include' element can be used with
      'allprop' to instruct the server to also include additional live
      properties that may not have been returned otherwise),

   o  Request a list of names of all the properties defined on the
      resource, by using the 'propname' element.

   A client may choose not to submit a request body.  An empty PROPFIND
   request body MUST be treated as if it were an 'allprop' request.

   Note that 'allprop' does not return values for all live properties.
   WebDAV servers increasingly have expensively-calculated or lengthy
   properties (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;]) and do not return all
   properties already.  Instead, WebDAV clients can use propname
   requests to discover what live properties exist, and request named
   properties when retrieving values.  For a live property defined
   elsewhere, that definition can specify whether or not that live
   property would be returned in 'allprop' requests.

   All servers MUST support returning a response of content type text/
   xml or application/xml that contains a multistatus XML element that
   describes the results of the attempts to retrieve the various
   properties.

   If there is an error retrieving a property, then a proper error
   result MUST be included in the response.  A request to retrieve the
   value of a property that does not exist is an error and MUST be noted
   with a 'response' XML element that contains a 404 (Not Found) status
   value.

   Consequently, the 'multistatus' XML element for a collection resource
   MUST include a 'response' XML element for each member URL of the
   collection, to whatever depth was requested.  It SHOULD NOT include
   any 'response' elements for resources that are not WebDAV-compliant.
   Each 'response' element MUST contain an 'href' element that contains
   the URL of the resource on which the properties in the prop XML
   element are defined.  Results for a PROPFIND on a collection resource
   are returned as a flat list whose order of entries is not 

   significant.  Note that a resource may have only one value for a
   property of a given name, so the property may only show up once in
   PROPFIND responses.

   Properties may be subject to access control.  In the case of
   'allprop' and 'propname' requests, if a principal does not have the
   right to know whether a particular property exists, then the property
   MAY be silently excluded from the response.

   Some PROPFIND results MAY be cached, with care, as there is no cache
   validation mechanism for most properties.  This method is both safe
   and idempotent (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of [RFC2616]&lt;/a&gt;).</source>
          <target state="translated">PROPFIND 메소드는 자원에 내부 구성원이없는 경우 Request-URI로 식별 된 자원 또는 자원이있는 콜렉션 인 경우 Request-URI 및 잠재적으로 해당 구성원 자원으로 식별 된 자원에 정의 된 특성을 검색합니다. 내부 회원 URL. 모든 DAV 호환 리소스는 반드시 PROPFIND 메소드와 propfind XML 요소를 지원해야합니다 ( &lt;a href=&quot;#section-14.20&quot;&gt;14.20 절).&lt;/a&gt;) 및 해당 요소와 함께 사용하도록 정의 된 모든 XML 요소와 함께. 클라이언트는 PROPFIND 요청과 함께 &quot;0&quot;, &quot;1&quot;또는 &quot;infinity&quot;값을 가진 깊이 헤더를 제출해야합니다. 서버는 WebDAV 호환 리소스에서 &quot;0&quot;및 &quot;1&quot;깊이 요청을 지원해야하며 &quot;무한대&quot;요청을 지원해야합니다. 실제로이 동작과 관련된 성능 및 보안 문제로 인해 무한 깊이 요청에 대한 지원이 비활성화 될 수 있습니다. 서버는 &quot;Depth : infinity&quot;헤더가 포함 된 것처럼 Depth 헤더가없는 요청을 처리해야합니다. 클라이언트는 어떤 정보가 요청되고 있는지를 설명하는 요청 메소드 본문에 'propfind'XML 요소를 제출할 수 있습니다. o 특정 속성 값 요청,'prop'요소 내에서 원하는 속성의 이름을 지정함으로써 (여기에서 속성 순서는 서버에서 무시 될 수 있음) o '이 사양에 정의 된 속성에 대한 속성 값 (최소한)과' allprop '요소 ('include '요소는'allprop '와 함께 사용하여 서버에 달리 리턴되지 않은 추가 라이브 특성도 포함하도록 지시 할 수 있음) o 자원에 정의 된 모든 특성의 이름 목록을 요청합니다. 'propname'요소를 사용하여 고객은 요청 본문을 제출하지 않도록 선택할 수 있습니다. 빈 PROPFIND 요청 본문은 마치 'allprop'요청 인 것처럼 처리해야합니다. 'allprop'는 모든 라이브 속성에 대한 값을 반환하지는 않습니다.WebDAV 서버는 점점 비싸거나 계산되는 속성이 점점 증가합니다 ([&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ] 및 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;]) 이미 모든 속성을 반환하지는 않습니다. 대신 WebDAV 클라이언트는 propname 요청을 사용하여 어떤 라이브 특성이 있는지 발견하고 값을 검색 할 때 이름 지정된 특성을 요청할 수 있습니다. 다른 곳에 정의 된 라이브 속성의 경우 해당 정의는 해당 라이브 속성이 'allprop'요청으로 반환되는지 여부를 지정할 수 있습니다. 모든 서버는 다양한 속성을 검색하려는 시도의 결과를 설명하는 다중 상태 XML 요소가 포함 된 콘텐츠 유형 text / xml 또는 application / xml의 응답 반환을 지원해야합니다. 특성을 검색하는 중에 오류가 발생하면 응답에 올바른 오류 결과가 포함되어야합니다. 존재하지 않는 속성 값을 검색하라는 요청은 오류이며 '응답'과 함께 표시되어야합니다.404 (찾을 수 없음) 상태 값이 포함 된 XML 요소 결과적으로 컬렉션 리소스에 대한 'multistatus'XML 요소는 요청 된 깊이에 따라 컬렉션의 각 멤버 URL에 대한 'response'XML 요소를 포함해야합니다. WebDAV를 준수하지 않는 리소스에 대한 '응답'요소를 포함하지 않아야합니다. 각 'response'요소는 prop XML 요소의 특성이 정의 된 자원의 URL을 포함하는 'href'요소를 포함해야합니다. 콜렉션 자원의 PROPFIND에 대한 결과는 항목 순서가 중요하지 않은 단순 목록으로 리턴됩니다. 리소스는 주어진 이름의 속성에 대해 하나의 값만 가질 수 있으므로 속성은 PROPFIND 응답에 한 번만 표시 될 수 있습니다.속성에 따라 액세스 제어가 적용될 수 있습니다. 'allprop'및 'propname'요청의 경우, 주체가 특정 속성이 존재하는지 알 수있는 권한이 없으면 속성이 응답에서 자동으로 제외 될 수 있습니다. 대부분의 속성에 대해 캐시 유효성 검사 메커니즘이 없으므로 일부 PROPFIND 결과는주의해서 캐시 될 수 있습니다. 이 방법은 안전하고 dem 등입니다 (참조&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616] 섹션 9.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="63b7604adf362cf9b58baac42bf0c778df2e71b7" translate="yes" xml:space="preserve">
          <source>The PROPPATCH method processes instructions specified in the request
   body to set and/or remove properties defined on the resource
   identified by the Request-URI.

   All DAV-compliant resources MUST support the PROPPATCH method and
   MUST process instructions that are specified using the
   propertyupdate, set, and remove XML elements.  Execution of the
   directives in this method is, of course, subject to access control
   constraints.  DAV-compliant resources SHOULD support the setting of
   arbitrary dead properties.

   The request message body of a PROPPATCH method MUST contain the
   propertyupdate XML element.

   Servers MUST process PROPPATCH instructions in document order (an
   exception to the normal rule that ordering is irrelevant).
   Instructions MUST either all be executed or none executed.  Thus, if
   any error occurs during processing, all executed instructions MUST be
   undone and a proper error result returned.  Instruction processing
   details can be found in the definition of the set and remove
   instructions in Sections &lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; and &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt;.

   If a server attempts to make any of the property changes in a
   PROPPATCH request (i.e., the request is not rejected for high-level
   errors before processing the body), the response MUST be a Multi-
   Status response as described in &lt;a href=&quot;#section-9.2.1&quot;&gt;Section 9.2.1&lt;/a&gt;.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">PROPPATCH 메소드는 Request-URI로 식별 된 자원에 정의 된 특성을 설정 및 / 또는 제거하기 위해 요청 본문에 지정된 명령을 처리합니다. 모든 DAV 호환 리소스는 반드시 PROPPATCH 메서드를 지원해야하며 propertyupdate, set 및 remove XML 요소를 사용하여 지정된 명령어를 처리해야합니다. 물론이 방법에서 지시문의 실행은 액세스 제어 제약 조건의 적용을받습니다. DAV 호환 리소스는 임의의 데드 속성 설정을 지원해야합니다 (SHOULD). PROPPATCH 메소드의 요청 메시지 본문에는 propertyupdate XML 요소가 포함되어야합니다. 서버는 문서 순서대로 PROPPATCH 명령어를 처리해야합니다 (주문과 관련이없는 일반적인 규칙은 예외). 명령어는 모두 실행되거나 실행되지 않아야합니다. 그러므로,처리 중에 오류가 발생하면 실행 된 모든 명령을 실행 취소하고 적절한 오류 결과를 반환해야합니다. 명령어 처리 세부 사항은 섹션의 정의 및 제거 명령어 정의에서 찾을 수 있습니다.&lt;a href=&quot;#section-14.23&quot;&gt;14.23&lt;/a&gt; 및 &lt;a href=&quot;#section-14.26&quot;&gt;14.26&lt;/a&gt; . 서버가 PROPPATCH 요청에서 속성을 변경하려고 시도하는 경우 (즉, 본문을 처리하기 전에 높은 수준의 오류에 대한 요청이 거부되지 않음) 응답은 &lt;a href=&quot;#section-9.2.1&quot;&gt;섹션 9.2.1에&lt;/a&gt; 설명 된 다중 상태 응답이어야합니다. . 이 방법은 dem 등이지만 안전하지는 않습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616]의 9.1 절&lt;/a&gt; 참조 ). 이 방법에 대한 응답은 캐시해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="601421813323ca4f0788af9d830329726cc8945b" translate="yes" xml:space="preserve">
          <source>The PUSH_PROMISE frame (type=0x5) is used to notify the peer endpoint
   in advance of streams the sender intends to initiate.  The
   PUSH_PROMISE frame includes the unsigned 31-bit identifier of the
   stream the endpoint plans to create along with a set of headers that
   provide additional context for the stream.  &lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt; contains a
   thorough description of the use of PUSH_PROMISE frames.

    +---------------+
    |Pad Length? (8)|
    +-+-------------+-----------------------------------------------+
    |R|                  Promised Stream ID (31)                    |
    +-+-----------------------------+-------------------------------+
    |                   Header Block Fragment (*)                 
    +---------------------------------------------------------------+
    |                           Padding (*)                       
    +---------------------------------------------------------------+

                  Figure 11: PUSH_PROMISE Payload Format

   The PUSH_PROMISE frame payload has the following fields:

   Pad Length:  An 8-bit field containing the length of the frame
      padding in units of octets.  This field is only present if the
      PADDED flag is set.

   R: A single reserved bit.

   Promised Stream ID:  An unsigned 31-bit integer that identifies the
      stream that is reserved by the PUSH_PROMISE.  The promised stream
      identifier MUST be a valid choice for the next stream sent by the
      sender (see &quot;new stream identifier&quot; in &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;).

   Header Block Fragment:  A header block fragment (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;)
      containing request header fields.

   Padding:  Padding octets. 

   The PUSH_PROMISE frame defines the following flags:

   END_HEADERS (0x4):  When set, bit 2 indicates that this frame
      contains an entire header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) and is not followed
      by any CONTINUATION frames.

      A PUSH_PROMISE frame without the END_HEADERS flag set MUST be
      followed by a CONTINUATION frame for the same stream.  A receiver
      MUST treat the receipt of any other type of frame or a frame on a
      different stream as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
      PROTOCOL_ERROR.

   PADDED (0x8):  When set, bit 3 indicates that the Pad Length field
      and any padding that it describes are present.

   PUSH_PROMISE frames MUST only be sent on a peer-initiated stream that
   is in either the &quot;open&quot; or &quot;half-closed (remote)&quot; state.  The stream
   identifier of a PUSH_PROMISE frame indicates the stream it is
   associated with.  If the stream identifier field specifies the value
   0x0, a recipient MUST respond with a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;)
   of type PROTOCOL_ERROR.

   Promised streams are not required to be used in the order they are
   promised.  The PUSH_PROMISE only reserves stream identifiers for
   later use.

   PUSH_PROMISE MUST NOT be sent if the SETTINGS_ENABLE_PUSH setting of
   the peer endpoint is set to 0.  An endpoint that has set this setting
   and has received acknowledgement MUST treat the receipt of a
   PUSH_PROMISE frame as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   Recipients of PUSH_PROMISE frames can choose to reject promised
   streams by returning a RST_STREAM referencing the promised stream
   identifier back to the sender of the PUSH_PROMISE.

   A PUSH_PROMISE frame modifies the connection state in two ways.
   First, the inclusion of a header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) potentially
   modifies the state maintained for header compression.  Second,
   PUSH_PROMISE also reserves a stream for later use, causing the
   promised stream to enter the &quot;reserved&quot; state.  A sender MUST NOT
   send a PUSH_PROMISE on a stream unless that stream is either &quot;open&quot;
   or &quot;half-closed (remote)&quot;; the sender MUST ensure that the promised
   stream is a valid choice for a new stream identifier (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;)
   (that is, the promised stream MUST be in the &quot;idle&quot; state). 

   Since PUSH_PROMISE reserves a stream, ignoring a PUSH_PROMISE frame
   causes the stream state to become indeterminate.  A receiver MUST
   treat the receipt of a PUSH_PROMISE on a stream that is neither
   &quot;open&quot; nor &quot;half-closed (local)&quot; as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.  However, an endpoint that
   has sent RST_STREAM on the associated stream MUST handle PUSH_PROMISE
   frames that might have been created before the RST_STREAM frame is
   received and processed.

   A receiver MUST treat the receipt of a PUSH_PROMISE that promises an
   illegal stream identifier (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;) as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.  Note that an illegal stream
   identifier is an identifier for a stream that is not currently in the
   &quot;idle&quot; state.

   The PUSH_PROMISE frame can include padding.  Padding fields and flags
   are identical to those defined for DATA frames (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).</source>
          <target state="translated">PUSH_PROMISE 프레임 (유형 = 0x5)은 발신자가 시작하려는 스트림에 앞서 피어 엔드 포인트에 알리는 데 사용됩니다. PUSH_PROMISE 프레임에는 스트림에 대한 추가 컨텍스트를 제공하는 헤더 세트와 함께 엔드 포인트가 생성 할 계획 인 스트림의 서명되지 않은 31 비트 식별자가 포함됩니다. &lt;a href=&quot;#section-8.2&quot;&gt;8.2 절&lt;/a&gt;PUSH_PROMISE 프레임 사용에 대한 자세한 설명이 포함되어 있습니다. + --------------- + | 패드 길이? (8) | +-+ ------------- + --------------------------------- -------------- + | R | 약속 된 스트림 ID (31) | +-+ ----------------------------- + ----------------- -------------- + | 헤더 블록 조각 (*) + ------------------------------------------- -------------------- + | 패딩 (*) + --------------------------------------------- ------------------ + 그림 11 : PUSH_PROMISE 페이로드 형식 PUSH_PROMISE 프레임 페이로드에는 다음 필드가 있습니다. Pad Length : 프레임 패딩 길이를 포함하는 8 비트 필드 옥텟 단위. 이 필드는 PADDED 플래그가 설정된 경우에만 존재합니다. R : 예약 된 단일 비트. 약속 된 스트림 ID : PUSH_PROMISE에서 예약 한 스트림을 식별하는 부호없는 31 비트 정수입니다.약속 된 스트림 식별자는 발신자가 보낸 다음 스트림에 대해 유효한 선택이어야합니다 ( &quot;새 스트림 식별자&quot;참조).&lt;a href=&quot;#section-5.1.1&quot;&gt;섹션 5.1.1&lt;/a&gt; ). 헤더 블록 조각 : 요청 헤더 필드를 포함 하는 헤더 블록 조각 ( &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt; ). 패딩 : 패딩 옥텟. PUSH_PROMISE 프레임은 다음 플래그를 정의합니다. END_HEADERS (0x4) : 설정되면 비트 2는이 프레임이 전체 헤더 블록 ( &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt; )을 포함하고 CONTINUATION 프레임이 뒤 따르지 않음을 나타냅니다 . END_HEADERS 플래그가 설정되지 않은 PUSH_PROMISE 프레임 뒤에는 동일한 스트림에 대한 CONTINUATION 프레임이 와야합니다. 수신자는 다른 유형의 프레임 또는 다른 스트림의 프레임 수신을 연결 오류로 취급해야합니다 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt;) PROTOCOL_ERROR 유형입니다. PADDED (0x8) : 설정된 경우 비트 3은 Pad Length 필드와 설명하는 모든 패딩이 있음을 나타냅니다. PUSH_PROMISE 프레임은 &quot;open&quot;또는 &quot;half-closed (remote)&quot;상태에있는 피어 시작 스트림에서만 전송되어야합니다. PUSH_PROMISE 프레임의 스트림 식별자는 연결된 스트림을 나타냅니다. 스트림 식별자 필드가 0x0 값을 지정하면 수신자는 연결 오류로 응답해야합니다 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt;) PROTOCOL_ERROR 유형입니다. 약속 된 스트림은 약속 된 순서대로 사용할 필요가 없습니다. PUSH_PROMISE는 나중에 사용하기 위해 스트림 식별자 만 예약합니다. PUSH_PROMISE는 피어 엔드 포인트의 SETTINGS_ENABLE_PUSH 설정이 0으로 설정된 경우 전송되지 않아야합니다.이 설정을 설정하고 승인을받은 엔드 포인트는 PUSH_PROMISE 프레임 수신을 PROTOCOL_ERROR 유형 의 연결 오류 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt; )로 처리해야합니다. . PUSH_PROMISE 프레임의 수신자는 약속 된 스트림 식별자를 참조하는 RST_STREAM을 PUSH_PROMISE의 발신자에게 다시 반환하여 약속 된 스트림을 거부하도록 선택할 수 있습니다. PUSH_PROMISE 프레임은 두 가지 방법으로 연결 상태를 수정합니다. 첫째, 헤더 블록의 포함 ( &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt;) 잠재적으로 헤더 압축을 위해 유지되는 상태를 수정합니다. 둘째, PUSH_PROMISE는 나중에 사용하기 위해 스트림을 예약하여 약속 된 스트림이 &quot;reserved&quot;상태가되도록합니다. 송신자는 스트림이 &quot;개방&quot;또는 &quot;반 폐쇄 (원격)&quot;가 아닌 한 스트림에서 PUSH_PROMISE를 보내지 않아야합니다. 발신자는 약속 된 스트림이 새로운 스트림 식별자 ( &lt;a href=&quot;#section-5.1.1&quot;&gt;섹션 5.1.1&lt;/a&gt; )에 대해 유효한 선택인지 확인해야합니다 (즉, 약속 된 스트림은 &quot;유휴&quot;상태에 있어야 함). PUSH_PROMISE는 스트림을 예약하므로 PUSH_PROMISE 프레임을 무시하면 스트림 상태가 불확실 해집니다. 수신자는 &quot;개방&quot;도 아니고 &quot;반 폐쇄 (로컬)&quot;도 아닌 스트림에서 PUSH_PROMISE 수신을 연결 오류로 취급해야합니다 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt;) PROTOCOL_ERROR 유형입니다. 그러나 관련 스트림에서 RST_STREAM을 전송 한 엔드 포인트는 RST_STREAM 프레임이 수신 및 처리되기 전에 생성되었을 수있는 PUSH_PROMISE 프레임을 처리해야합니다. 수신기는 잘못된 스트림 식별자 ( &lt;a href=&quot;#section-5.1.1&quot;&gt;섹션 5.1.1&lt;/a&gt; ) 를 약속하는 PUSH_PROMISE의 수신을 PROTOCOL_ERROR 유형 의 연결 오류 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt; )로 취급해야합니다. 잘못된 스트림 식별자는 현재 &quot;유휴&quot;상태가 아닌 스트림에 대한 식별자입니다. PUSH_PROMISE 프레임은 패딩을 포함 할 수 있습니다. 패딩 필드 및 플래그는 DATA 프레임에 대해 정의 된 것과 동일합니다 ( &lt;a href=&quot;#section-6.1&quot;&gt;섹션 6.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1975f22fa255d880d63431b9c6a1e839eaebbdbb" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the enclosed entity be stored under the
   supplied Request-URI. If the Request-URI refers to an already
   existing resource, the enclosed entity SHOULD be considered as a
   modified version of the one residing on the origin server. If the
   Request-URI does not point to an existing resource, and that URI is
   capable of being defined as a new resource by the requesting user
   agent, the origin server can create the resource with that URI. If a
   new resource is created, the origin server MUST inform the user agent
   via the 201 (Created) response. If an existing resource is modified,
   either the 200 (OK) or 204 (No Content) response codes SHOULD be sent
   to indicate successful completion of the request. If the resource
   could not be created or modified with the Request-URI, an appropriate
   error response SHOULD be given that reflects the nature of the
   problem. The recipient of the entity MUST NOT ignore any Content-*
   (e.g. Content-Range) headers that it does not understand or implement
   and MUST return a 501 (Not Implemented) response in such cases.

   If the request passes through a cache and the Request-URI identifies
   one or more currently cached entities, those entries SHOULD be
   treated as stale. Responses to this method are not cacheable.

   The fundamental difference between the POST and PUT requests is
   reflected in the different meaning of the Request-URI. The URI in a
   POST request identifies the resource that will handle the enclosed
   entity. That resource might be a data-accepting process, a gateway to
   some other protocol, or a separate entity that accepts annotations.
   In contrast, the URI in a PUT request identifies the entity enclosed
   with the request -- the user agent knows what URI is intended and the
   server MUST NOT attempt to apply the request to some other resource.
   If the server desires that the request be applied to a different URI, 

   it MUST send a 301 (Moved Permanently) response; the user agent MAY
   then make its own decision regarding whether or not to redirect the
   request.

   A single resource MAY be identified by many different URIs. For
   example, an article might have a URI for identifying &quot;the current
   version&quot; which is separate from the URI identifying each particular
   version. In this case, a PUT request on a general URI might result in
   several other URIs being defined by the origin server.

   HTTP/1.1 does not define how a PUT method affects the state of an
   origin server.

   PUT requests MUST obey the message transmission requirements set out
   in &lt;a href=&quot;#section-8.2&quot;&gt;section 8.2&lt;/a&gt;.

   Unless otherwise specified for a particular entity-header, the
   entity-headers in the PUT request SHOULD be applied to the resource
   created or modified by the PUT.</source>
          <target state="translated">PUT 메소드는 동봉 된 엔티티가 제공된 Request-URI 아래에 저장되도록 요청합니다. Request-URI가 이미 존재하는 자원을 참조하는 경우 동봉 된 엔티티는 원본 서버에있는 수정 된 버전으로 간주해야합니다. Request-URI가 기존 자원을 가리 키지 않고 요청 사용자 에이전트가 해당 URI를 새 자원으로 정의 할 수있는 경우, 오리진 서버는 해당 URI로 자원을 작성할 수 있습니다. 새로운 리소스가 생성되면 오리진 서버는 반드시 201 (Created) 응답을 통해 사용자 에이전트에게 알려야합니다. 기존 자원이 수정되면 요청 완료를 표시하기 위해 200 (OK) 또는 204 (No Content) 응답 코드를 보내야합니다. Request-URI로 자원을 작성하거나 수정할 수없는 경우,문제의 본질을 반영하는 적절한 오류 응답이 제공되어야한다. 엔터티의 수신자는 이해하지 않거나 구현하지 않은 Content-* (예 : Content-Range) 헤더를 무시해서는 안되며 그러한 경우 501 (구현되지 않음) 응답을 반환해야합니다. 요청이 캐시를 통과하고 Request-URI가 현재 캐시 된 하나 이상의 엔티티를 식별하는 경우 해당 항목은 오래된 것으로 취급해야합니다. 이 방법에 대한 응답은 캐시 할 수 없습니다. POST와 PUT 요청의 근본적인 차이점은 Request-URI의 다른 의미에 반영됩니다. POST 요청의 URI는 동봉 된 엔터티를 처리 할 리소스를 식별합니다. 이 리소스는 데이터 수락 프로세스, 다른 프로토콜의 게이트웨이 또는 주석을 허용하는 별도의 엔티티 일 수 있습니다.반대로 PUT 요청의 URI는 요청으로 둘러싸인 엔티티를 식별합니다. 사용자 에이전트는 의도 된 URI를 알고 있으며 서버는 요청을 다른 자원에 적용해서는 안됩니다. 서버가 요청이 다른 URI에 적용되기를 원하면 301 (영구적으로 이동) 응답을 보내야합니다. 그런 다음 사용자 에이전트는 요청을 리디렉션할지 여부에 대한 자체 결정을 내릴 수 있습니다. 단일 리소스는 여러 가지 URI로 식별 될 수 있습니다. 예를 들어, 기사에는 &quot;현재 버전&quot;을 식별하기위한 URI가있을 수 있으며, 이는 각 특정 버전을 식별하는 URI와 별개입니다. 이 경우 일반 URI에 대한 PUT 요청으로 인해 여러 다른 URI가 오리진 서버에 의해 정의 될 수 있습니다. HTTP / 1.1은 PUT 방법이 원본 서버의 상태에 미치는 영향을 정의하지 않습니다. PUT 요청은 메시지 전송 요구 사항을 준수해야합니다.&lt;a href=&quot;#section-8.2&quot;&gt;섹션 8.2&lt;/a&gt; . 특정 엔터티 헤더에 다르게 지정되지 않는 한 PUT 요청의 엔터티 헤더는 PUT에 의해 생성되거나 수정 된 리소스에 적용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7beb3539a595c62f6de09ee642f7b3a560d38b59" translate="yes" xml:space="preserve">
          <source>The PUT method requests that the state of the target resource be
   created or replaced with the state defined by the representation
   enclosed in the request message payload.  A successful PUT of a given
   representation would suggest that a subsequent GET on that same
   target resource will result in an equivalent representation being
   sent in a 200 (OK) response.  However, there is no guarantee that 

   such a state change will be observable, since the target resource
   might be acted upon by other user agents in parallel, or might be
   subject to dynamic processing by the origin server, before any
   subsequent GET is received.  A successful response only implies that
   the user agent's intent was achieved at the time of its processing by
   the origin server.

   If the target resource does not have a current representation and the
   PUT successfully creates one, then the origin server MUST inform the
   user agent by sending a 201 (Created) response.  If the target
   resource does have a current representation and that representation
   is successfully modified in accordance with the state of the enclosed
   representation, then the origin server MUST send either a 200 (OK) or
   a 204 (No Content) response to indicate successful completion of the
   request.

   An origin server SHOULD ignore unrecognized header fields received in
   a PUT request (i.e., do not save them as part of the resource state).

   An origin server SHOULD verify that the PUT representation is
   consistent with any constraints the server has for the target
   resource that cannot or will not be changed by the PUT.  This is
   particularly important when the origin server uses internal
   configuration information related to the URI in order to set the
   values for representation metadata on GET responses.  When a PUT
   representation is inconsistent with the target resource, the origin
   server SHOULD either make them consistent, by transforming the
   representation or changing the resource configuration, or respond
   with an appropriate error message containing sufficient information
   to explain why the representation is unsuitable.  The 409 (Conflict)
   or 415 (Unsupported Media Type) status codes are suggested, with the
   latter being specific to constraints on Content-Type values.

   For example, if the target resource is configured to always have a
   Content-Type of &quot;text/html&quot; and the representation being PUT has a
   Content-Type of &quot;image/jpeg&quot;, the origin server ought to do one of:

   a.  reconfigure the target resource to reflect the new media type;

   b.  transform the PUT representation to a format consistent with that
       of the resource before saving it as the new resource state; or,

   c.  reject the request with a 415 (Unsupported Media Type) response
       indicating that the target resource is limited to &quot;text/html&quot;,
       perhaps including a link to a different resource that would be a
       suitable target for the new representation. 

   HTTP does not define exactly how a PUT method affects the state of an
   origin server beyond what can be expressed by the intent of the user
   agent request and the semantics of the origin server response.  It
   does not define what a resource might be, in any sense of that word,
   beyond the interface provided via HTTP.  It does not define how
   resource state is &quot;stored&quot;, nor how such storage might change as a
   result of a change in resource state, nor how the origin server
   translates resource state into representations.  Generally speaking,
   all implementation details behind the resource interface are
   intentionally hidden by the server.

   An origin server MUST NOT send a validator header field
   (&lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;), such as an ETag or Last-Modified field, in a
   successful response to PUT unless the request's representation data
   was saved without any transformation applied to the body (i.e., the
   resource's new representation data is identical to the representation
   data received in the PUT request) and the validator field value
   reflects the new representation.  This requirement allows a user
   agent to know when the representation body it has in memory remains
   current as a result of the PUT, thus not in need of being retrieved
   again from the origin server, and that the new validator(s) received
   in the response can be used for future conditional requests in order
   to prevent accidental overwrites (&lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;).

   The fundamental difference between the POST and PUT methods is
   highlighted by the different intent for the enclosed representation.
   The target resource in a POST request is intended to handle the
   enclosed representation according to the resource's own semantics,
   whereas the enclosed representation in a PUT request is defined as
   replacing the state of the target resource.  Hence, the intent of PUT
   is idempotent and visible to intermediaries, even though the exact
   effect is only known by the origin server.

   Proper interpretation of a PUT request presumes that the user agent
   knows which target resource is desired.  A service that selects a
   proper URI on behalf of the client, after receiving a state-changing
   request, SHOULD be implemented using the POST method rather than PUT.
   If the origin server will not make the requested PUT state change to
   the target resource and instead wishes to have it applied to a
   different resource, such as when the resource has been moved to a
   different URI, then the origin server MUST send an appropriate 3xx
   (Redirection) response; the user agent MAY then make its own decision
   regarding whether or not to redirect the request.

   A PUT request applied to the target resource can have side effects on
   other resources.  For example, an article might have a URI for
   identifying &quot;the current version&quot; (a resource) that is separate from
   the URIs identifying each particular version (different resources 

   that at one point shared the same state as the current version
   resource).  A successful PUT request on &quot;the current version&quot; URI
   might therefore create a new version resource in addition to changing
   the state of the target resource, and might also cause links to be
   added between the related resources.

   An origin server that allows PUT on a given target resource MUST send
   a 400 (Bad Request) response to a PUT request that contains a
   Content-Range header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7233]&lt;/a&gt;), since the
   payload is likely to be partial content that has been mistakenly PUT
   as a full representation.  Partial content updates are possible by
   targeting a separately identified resource with state that overlaps a
   portion of the larger resource, or by using a different method that
   has been specifically defined for partial updates (for example, the
   PATCH method defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC5789&lt;/a&gt;]).

   Responses to the PUT method are not cacheable.  If a successful PUT
   request passes through a cache that has one or more stored responses
   for the effective request URI, those stored responses will be
   invalidated (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7234]&lt;/a&gt;).</source>
          <target state="translated">PUT 메소드는 대상 자원의 상태를 작성하거나 요청 메시지 페이로드에 포함 된 표현으로 정의 된 상태로 바꾸도록 요청합니다. 주어진 표현의 성공적인 PUT은 동일한 목표 자원에 대한 후속 GET이 200 (OK) 응답으로 동등한 표현이 전송됨을 시사합니다. 그러나 후속 GET을 수신하기 전에 대상 자원이 다른 사용자 에이전트에 의해 병렬로 처리되거나 오리진 서버에 의해 동적 처리 될 수 있기 때문에 이러한 상태 변경을 관찰 할 수 있다는 보장은 없습니다. 성공적인 응답은 사용자 에이전트의 의도가 원래 서버에 의해 처리 될 때 달성되었음을 나타냅니다.대상 자원에 현재 표현이없고 PUT이 성공적으로 작성하면, 원 서버는 반드시 201 (작성) 응답을 보내 사용자 에이전트에게 알려야합니다. 대상 자원에 현재 표현이 있고 해당 표현이 동봉 된 표현의 상태에 따라 성공적으로 수정 된 경우, 오리진 서버는 성공적인 완료를 표시하기 위해 200 (OK) 또는 204 (No Content) 응답을 보내야합니다. 요청. 오리진 서버는 PUT 요청에서 수신 된 인식 할 수없는 헤더 필드를 무시해야합니다 (즉, 자원 상태의 일부로 저장하지 마십시오). 오리진 서버는 PUT 표현이 PUT에 의해 변경 될 수 있거나 변경되지 않을 대상 자원에 대한 서버의 제한 조건과 일치하는지 확인해야합니다.이는 오리진 서버가 GET 응답에서 표시 메타 데이터의 값을 설정하기 위해 URI와 관련된 내부 구성 정보를 사용할 때 특히 중요합니다. PUT 표현이 목표 자원과 일치하지 않는 경우, 원 서버는 표현을 변환하거나 자원 구성을 변경하여 일관성을 유지하거나 표현이 적합하지 않은 이유를 설명하기에 충분한 정보를 포함하는 적절한 오류 메시지로 응답해야한다. 409 (충돌) 또는 415 (지원되지 않는 매체 유형) 상태 코드가 제안되며 후자는 컨텐츠 유형 값의 제한 사항에 따라 다릅니다. 예를 들어 대상 자원이 항상 &quot;text / html&quot;의 Content-Type을 갖도록 구성된 경우PUT 인 표현은 &quot;image / jpeg&quot;의 Content-Type을 가지며, 오리진 서버는 다음 중 하나를 수행해야합니다. 새 매체 유형을 반영하도록 대상 자원을 재구성하십시오. 비. PUT 표현을 새로운 자원 상태로 저장하기 전에 자원의 형식과 일치하는 형식으로 변환합니다. 또는 c. 대상 리소스가 &quot;text / html&quot;로 제한됨을 나타내는 415 (지원되지 않는 미디어 유형) 응답으로 요청을 거부합니다. 새 표현에 적합한 다른 리소스에 대한 링크를 포함 할 수도 있습니다. HTTP는 PUT 메소드가 사용자 에이전트 요청의 의도와 오리진 서버 응답의 의미로 표현할 수있는 것 이상으로 오리진 서버의 상태에 미치는 영향을 정확하게 정의하지 않습니다.HTTP를 통해 제공되는 인터페이스를 넘어 어떤 의미에서든 리소스가 무엇인지 정의하지 않습니다. 자원 상태가 &quot;저장된&quot;방법이나 자원 상태 변경의 결과로 이러한 스토리지가 어떻게 변경 될 수 있는지 또는 원본 서버가 자원 상태를 표현으로 변환하는 방법을 정의하지 않습니다. 일반적으로, 자원 인터페이스 뒤에있는 모든 구현 세부 사항은 서버에 의해 의도적으로 숨겨져 있습니다. 오리진 서버는 유효성 검사기 헤더 필드를 보내서는 안됩니다 (자원 인터페이스 뒤에있는 모든 구현 세부 사항은 서버에 의해 의도적으로 숨겨져 있습니다. 오리진 서버는 유효성 검사기 헤더 필드를 보내서는 안됩니다 (자원 인터페이스 뒤에있는 모든 구현 세부 사항은 서버에 의해 의도적으로 숨겨져 있습니다. 오리진 서버는 유효성 검사기 헤더 필드를 보내서는 안됩니다 (&lt;a href=&quot;#section-7.2&quot;&gt;&lt;/a&gt;ETag 또는 Last-Modified 필드와 같은 섹션 7.2 )는 요청의 표현 데이터가 본문에 적용되는 변환없이 저장되지 않은 경우 (즉, 자원의 새로운 표현 데이터가 수신 된 표현 데이터와 동일하지 않은 경우) PUT에 대한 성공적인 응답 PUT 요청) 및 유효성 검사기 필드 값은 새로운 표현을 반영합니다. 이 요구 사항을 통해 사용자 에이전트는 메모리에있는 표시 본문이 PUT의 결과로 최신 상태를 유지하는 시점을 알 수 있으므로 원본 서버에서 다시 검색 할 필요가없고 응답에서 새 유효성 검증기 (들)를 수신해야합니다. 우발적 인 덮어 쓰기를 방지하기 위해 향후 조건부 요청에 사용할 수 있습니다 ( &lt;a href=&quot;#section-5.2&quot;&gt;섹션 5.2&lt;/a&gt;). POST와 PUT 방법의 근본적인 차이점은 동봉 된 표현에 대한 다른 의도로 강조됩니다. POST 요청의 대상 자원은 자원 자체의 의미에 따라 동봉 된 표현을 처리하기위한 반면 PUT 요청의 동봉 된 표현은 대상 자원의 상태를 대체하는 것으로 정의됩니다. 따라서 PUT의 의도는 server 등원이며 중개자에게만 표시됩니다. 비록 정확한 효과는 원래 서버에서만 알 수 있습니다. PUT 요청의 올바른 해석은 사용자 에이전트가 원하는 대상 자원을 알고 있다고 가정합니다. 상태 변경 요청을 수신 한 후 클라이언트 대신 적절한 URI를 선택하는 서비스는 PUT이 아닌 POST 메소드를 사용하여 구현해야합니다.원 서버가 요청 된 PUT 상태를 대상 자원으로 변경하지 않고 자원이 다른 URI로 이동 된 경우와 같이 다른 자원에 적용하려면 원 서버는 적절한 3xx를 보내야합니다. (리다이렉션) 응답; 그런 다음 사용자 에이전트는 요청을 리디렉션할지 여부에 대한 자체 결정을 내릴 수 있습니다. 대상 자원에 적용된 PUT 요청은 다른 자원에 부작용이있을 수 있습니다. 예를 들어, 기사에는 각 특정 버전을 식별하는 URI (한 시점에서 현재 버전 리소스와 동일한 상태를 공유하는 다른 리소스)와는 다른 &quot;현재 버전&quot;(리소스)을 식별하기위한 URI가있을 수 있습니다. &quot;현재 버전&quot;에 대한 성공적인 PUT 요청따라서 URI는 대상 자원의 상태를 변경하는 것 외에도 새 버전 자원을 작성하고 관련 자원 사이에 링크를 추가 할 수도 있습니다. 주어진 대상 리소스에서 PUT을 허용하는 오리진 서버는 반드시 Content-Range 헤더 필드를 포함하는 PUT 요청에 400 (잘못된 요청) 응답을 보내야합니다 (&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;&lt;/a&gt;페이로드는 전체 표현으로 실수로 PUT 된 부분 내용 일 가능성이 있기 때문에 [RFC7233] 섹션 4.2 . 부분 콘텐츠 업데이트는 더 큰 리소스의 일부와 겹치는 상태로 개별적으로 식별 된 리소스를 대상으로하거나 부분 업데이트에 대해 특별히 정의 된 다른 방법 (예 : [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC5789&lt;/a&gt; ]에 정의 된 PATCH 방법 )을 사용하여 가능합니다. PUT 메소드에 대한 응답은 캐시 할 수 없습니다. 성공적인 PUT 요청이 유효 요청 URI에 대해 하나 이상의 저장된 응답이있는 캐시를 통과하면 저장된 응답이 무효화됩니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.4&quot;&gt;[RFC7234] 4.4 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="6e42dfbab6315a9d1786cb94b26bfc16b764a831" translate="yes" xml:space="preserve">
          <source>The Pragma general-header field is used to include implementation-
   specific directives that might apply to any recipient along the
   request/response chain. All pragma directives specify optional
   behavior from the viewpoint of the protocol; however, some systems
   MAY require that behavior be consistent with the directives.

       Pragma            = &quot;Pragma&quot; &quot;:&quot; 1#pragma-directive
       pragma-directive  = &quot;no-cache&quot; | extension-pragma
       extension-pragma  = token [ &quot;=&quot; ( token | quoted-string ) ]

   When the no-cache directive is present in a request message, an
   application SHOULD forward the request toward the origin server even
   if it has a cached copy of what is being requested. This pragma
   directive has the same semantics as the no-cache cache-directive (see
   &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;) and is defined here for backward compatibility with
   HTTP/1.0. Clients SHOULD include both header fields when a no-cache
   request is sent to a server not known to be HTTP/1.1 compliant. 

   Pragma directives MUST be passed through by a proxy or gateway
   application, regardless of their significance to that application,
   since the directives might be applicable to all recipients along the
   request/response chain. It is not possible to specify a pragma for a
   specific recipient; however, any pragma directive not relevant to a
   recipient SHOULD be ignored by that recipient.

   HTTP/1.1 caches SHOULD treat &quot;Pragma: no-cache&quot; as if the client had
   sent &quot;Cache-Control: no-cache&quot;. No new Pragma directives will be
   defined in HTTP.

      Note: because the meaning of &quot;Pragma: no-cache as a response
      header field is not actually specified, it does not provide a
      reliable replacement for &quot;Cache-Control: no-cache&quot; in a response</source>
          <target state="translated">Pragma 일반 헤더 필드는 요청 / 응답 체인을 따라 모든 수신자에게 적용될 수있는 구현 별 지시문을 포함하는 데 사용됩니다. 모든 pragma 지시문은 프로토콜 관점에서 선택적 동작을 지정합니다. 그러나 일부 시스템에서는 동작이 지시문과 일치해야 할 수도 있습니다. Pragma = &quot;Pragma&quot; &quot;:&quot;1 # pragma-directive pragma-directive = &quot;no-cache&quot;| extension-pragma extension-pragma = token [ &quot;=&quot;(token | quoted-string)] 요청 메시지에 no-cache 지시문이 있으면 응용 프로그램은 캐시 된 사본이 있어도 요청을 원본 서버로 전달해야합니다 요청되는 내용 이 pragma 지시문은 no-cache 캐시 지시문과 동일한 의미를 갖습니다 ( &lt;a href=&quot;#section-14.9&quot;&gt;섹션 14.9 참조).&lt;/a&gt;) 및 HTTP / 1.0과의 호환성을 위해 여기에 정의되어 있습니다. 캐시없는 요청이 HTTP / 1.1 호환이 아닌 서버로 전송 될 때 클라이언트는 두 헤더 필드를 모두 포함해야합니다 (SHOULD). 지시문은 요청 / 응답 체인을 따라 모든 수신자에게 적용될 수 있으므로 Pragma 지시문은 해당 응용 프로그램에 대한 중요성에 관계없이 프록시 또는 게이트웨이 응용 프로그램을 통해 전달되어야합니다. 특정 수신자에 대한 pragma를 지정할 수 없습니다. 그러나 수신자와 관련이없는 pragma 지시문은 해당 수신자가 무시해야합니다. HTTP / 1.1 캐시는 클라이언트가 &quot;Cache-Control : no-cache&quot;를 보낸 것처럼 &quot;Pragma : no-cache&quot;를 처리해야합니다. 새로운 Pragma 지시문은 HTTP에 정의되지 않습니다. 참고 : &quot;Pragma :응답 헤더 필드 인 no-cache는 실제로 지정되지 않으며 응답에서 &quot;Cache-Control : no-cache&quot;를 안정적으로 대체하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="871bcdf53c1b79539586617d7fc176e073aa2706" translate="yes" xml:space="preserve">
          <source>The Proxy-Authenticate response-header field MUST be included as part
   of a 407 (Proxy Authentication Required) response. The field value
   consists of a challenge that indicates the authentication scheme and
   parameters applicable to the proxy for this Request-URI.

       Proxy-Authenticate  = &quot;Proxy-Authenticate&quot; &quot;:&quot; 1#challenge

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. Unlike
   WWW-Authenticate, the Proxy-Authenticate header field applies only to
   the current connection and SHOULD NOT be passed on to downstream
   clients. However, an intermediate proxy might need to obtain its own
   credentials by requesting them from the downstream client, which in
   some circumstances will appear as if the proxy is forwarding the
   Proxy-Authenticate header field.</source>
          <target state="translated">프록시 인증 응답 헤더 필드는 반드시 407 (프록시 인증 필요) 응답의 일부로 포함되어야합니다. 필드 값은이 Request-URI의 프록시에 적용 할 수있는 인증 체계 및 매개 변수를 나타내는 인증 확인으로 구성됩니다. Proxy-Authenticate = &quot;프록시 인증&quot; &quot;:&quot;1 # challenge HTTP 액세스 인증 프로세스는 &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증&quot;[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. WWW-Authenticate와 달리 Proxy-Authenticate 헤더 필드는 현재 연결에만 적용되며 다운 스트림 클라이언트에 전달해서는 안됩니다. 그러나 중간 프록시는 다운 스트림 클라이언트에서 요청하여 자체 신임 정보를 가져와야 할 수도 있습니다. 이는 일부 상황에서 프록시가 프록시 인증 헤더 필드를 전달하는 것처럼 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ad6052a85e2e7f8497d8ed5920ca77e487770b52" translate="yes" xml:space="preserve">
          <source>The Proxy-Authorization request-header field allows the client to
   identify itself (or its user) to a proxy which requires
   authentication. The Proxy-Authorization field value consists of
   credentials containing the authentication information of the user
   agent for the proxy and/or realm of the resource being requested.

       Proxy-Authorization     = &quot;Proxy-Authorization&quot; &quot;:&quot; credentials

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;] . Unlike
   Authorization, the Proxy-Authorization header field applies only to
   the next outbound proxy that demanded authentication using the Proxy-
   Authenticate field. When multiple proxies are used in a chain, the 

   Proxy-Authorization header field is consumed by the first outbound
   proxy that was expecting to receive credentials. A proxy MAY relay
   the credentials from the client request to the next proxy if that is
   the mechanism by which the proxies cooperatively authenticate a given
   request.</source>
          <target state="translated">Proxy-Authorization request-header 필드는 클라이언트가 인증이 필요한 프록시에 자신 (또는 사용자)을 식별 할 수 있도록합니다. 프록시 인증 필드 값은 프록시에 대한 사용자 에이전트의 인증 정보 및 / 또는 요청되는 리소스 영역을 포함하는 자격 증명으로 구성됩니다. Proxy-Authorization = &quot;Proxy-Authorization&quot; &quot;:&quot;자격 증명 HTTP 액세스 인증 프로세스는 &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증&quot;[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. 권한 부여와 달리 프록시 인증 헤더 필드는 프록시 인증 필드를 사용하여 인증이 필요한 다음 아웃 바운드 프록시에만 적용됩니다. 체인에서 여러 프록시를 사용하는 경우 프록시 인증 헤더 필드는 자격 증명을받을 것으로 예상되는 첫 번째 아웃 바운드 프록시에서 사용됩니다. 프록시가 프록시가 주어진 요청을 협력 적으로 인증하는 메커니즘 인 경우 프록시는 클라이언트 요청에서 다음 프록시로 자격 증명을 릴레이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fb25443f99d4a6f4c3661e5265360468e08d470" translate="yes" xml:space="preserve">
          <source>The RST_STREAM frame (type=0x3) allows for immediate termination of a
   stream.  RST_STREAM is sent to request cancellation of a stream or to
   indicate that an error condition has occurred.

    +---------------------------------------------------------------+
    |                        Error Code (32)                        |
    +---------------------------------------------------------------+

                    Figure 9: RST_STREAM Frame Payload

   The RST_STREAM frame contains a single unsigned, 32-bit integer
   identifying the error code (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;).  The error code indicates why
   the stream is being terminated.

   The RST_STREAM frame does not define any flags.

   The RST_STREAM frame fully terminates the referenced stream and
   causes it to enter the &quot;closed&quot; state.  After receiving a RST_STREAM
   on a stream, the receiver MUST NOT send additional frames for that
   stream, with the exception of PRIORITY.  However, after sending the
   RST_STREAM, the sending endpoint MUST be prepared to receive and
   process additional frames sent on the stream that might have been
   sent by the peer prior to the arrival of the RST_STREAM.

   RST_STREAM frames MUST be associated with a stream.  If a RST_STREAM
   frame is received with a stream identifier of 0x0, the recipient MUST
   treat this as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   RST_STREAM frames MUST NOT be sent for a stream in the &quot;idle&quot; state.
   If a RST_STREAM frame identifying an idle stream is received, the
   recipient MUST treat this as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of
   type PROTOCOL_ERROR.

   A RST_STREAM frame with a length other than 4 octets MUST be treated
   as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type FRAME_SIZE_ERROR.</source>
          <target state="translated">RST_STREAM 프레임 (유형 = 0x3)은 스트림의 즉각적인 종료를 허용합니다. RST_STREAM은 스트림 취소를 요청하거나 오류 조건이 발생했음을 나타 내기 위해 전송됩니다. + ------------------------------------------------- -------------- + | 오류 코드 (32) | + ------------------------------------------------- -------------- + 그림 9 : RST_STREAM 프레임 페이로드 RST_STREAM 프레임은 오류 코드를 식별하는 단일 부호없는 32 비트 정수를 포함합니다 ( &lt;a href=&quot;#section-7&quot;&gt;섹션 7&lt;/a&gt;). 오류 코드는 스트림이 종료되는 이유를 나타냅니다. RST_STREAM 프레임은 플래그를 정의하지 않습니다. RST_STREAM 프레임은 참조 된 스트림을 완전히 종료하고 &quot;닫힌&quot;상태가되도록합니다. 스트림에서 RST_STREAM을 수신 한 후 수신자는 PRIORITY를 제외하고 해당 스트림에 대한 추가 프레임을 보내면 안됩니다. 그러나 RST_STREAM을 전송 한 후 전송 엔드 포인트는 RST_STREAM이 도착하기 전에 피어에 의해 전송되었을 수있는 스트림에서 전송 된 추가 프레임을 수신하고 처리 할 준비가되어 있어야합니다. RST_STREAM 프레임은 스트림과 연결되어야합니다. RST_STREAM 프레임이 0x0의 스트림 식별자로 수신되면 수신자는이를 연결 오류로 취급해야합니다 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt;) PROTOCOL_ERROR 유형입니다. RST_STREAM 프레임은 &quot;유휴&quot;상태의 스트림에 대해 전송되지 않아야합니다. 유휴 스트림을 식별하는 RST_STREAM 프레임이 수신되면 수신자는이를 PROTOCOL_ERROR 유형 의 연결 오류 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt; ) 로 취급해야 합니다. 길이가 4 옥텟이 아닌 RST_STREAM 프레임은 FRAME_SIZE_ERROR 유형 의 연결 오류 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt; ) 로 처리 되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a2e20c61425846c0564c678e617e3a0e40ac8e14" translate="yes" xml:space="preserve">
          <source>The Referer[sic] request-header field allows the client to specify,
   for the server's benefit, the address (URI) of the resource from
   which the Request-URI was obtained (the &quot;referrer&quot;, although the
   header field is misspelled.) The Referer request-header allows a
   server to generate lists of back-links to resources for interest,
   logging, optimized caching, etc. It also allows obsolete or mistyped
   links to be traced for maintenance. The Referer field MUST NOT be
   sent if the Request-URI was obtained from a source that does not have
   its own URI, such as input from the user keyboard.

       Referer        = &quot;Referer&quot; &quot;:&quot; ( absoluteURI | relativeURI )

   Example:

       Referer: &lt;a href=&quot;http://www.w3.org/hypertext/DataSources/Overview.html&quot;&gt;http://www.w3.org/hypertext/DataSources/Overview.html&lt;/a&gt; 

   If the field value is a relative URI, it SHOULD be interpreted
   relative to the Request-URI. The URI MUST NOT include a fragment. See
   &lt;a href=&quot;#section-15.1.3&quot;&gt;section 15.1.3&lt;/a&gt; for security considerations.</source>
          <target state="translated">Referer [sic] request-header 필드는 클라이언트가 서버의 이익을 위해 Request-URI를 얻은 자원의 주소 (URI)를 지정하도록합니다 (헤더 필드의 철자가 틀리더라도 &quot;참조 자&quot;). Referer request-header는 서버가 관심, 로깅, 최적화 된 캐싱 등을 위해 자원에 대한 백 링크 목록을 생성 할 수있게합니다. 또한 유지 보수를 위해 사용되지 않거나 잘못 입력 된 링크를 추적 할 수 있습니다. 사용자 키보드의 입력과 같이 고유 URI가없는 소스에서 Request-URI를 얻은 경우 Referer 필드를 보내서는 안됩니다 (MUST NOT). Referer = &quot;Referer&quot; &quot;:&quot;(absoluteURI | relativeURI) 예 : &lt;a href=&quot;http://www.w3.org/hypertext/DataSources/Overview.html&quot;&gt;참조 자&lt;/a&gt; : http://www.w3.org/hypertext/DataSources/Overview.html 필드 값이 상대 URI 인 경우 Request-URI를 기준으로 해석해야합니다. URI는 프래그먼트를 포함해서는 안됩니다. 보안 고려 사항에 대해서는 &lt;a href=&quot;#section-15.1.3&quot;&gt;15.1.3 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ada285615064adfa5d8e8460b22e8d2e1a9f7a60" translate="yes" xml:space="preserve">
          <source>The Request-Line begins with a method token, followed by the
   Request-URI and the protocol version, and ending with CRLF. The
   elements are separated by SP characters. No CR or LF is allowed
   except in the final CRLF sequence.

        Request-Line   = Method SP Request-URI SP HTTP-Version CRLF</source>
          <target state="translated">Request-Line은 메소드 토큰으로 시작하고 Request-URI 및 프로토콜 버전이 뒤 따르며 CRLF로 끝납니다. 요소는 SP 문자로 구분됩니다. 최종 CRLF 시퀀스를 제외하고 CR 또는 LF는 허용되지 않습니다. 요청 라인 = 메소드 SP 요청 URI SP HTTP 버전 CRLF</target>
        </trans-unit>
        <trans-unit id="8314c65661bfa76aafcdfccc2a0cabd4c8b07f40" translate="yes" xml:space="preserve">
          <source>The Request-URI is a Uniform Resource Identifier (&lt;a href=&quot;#section-3.2&quot;&gt;section 3.2&lt;/a&gt;) and
   identifies the resource upon which to apply the request.

       Request-URI    = &quot;*&quot; | absoluteURI | abs_path | authority

   The four options for Request-URI are dependent on the nature of the
   request. The asterisk &quot;*&quot; means that the request does not apply to a
   particular resource, but to the server itself, and is only allowed
   when the method used does not necessarily apply to a resource. One
   example would be

       OPTIONS * HTTP/1.1

   The absoluteURI form is REQUIRED when the request is being made to a
   proxy. The proxy is requested to forward the request or service it
   from a valid cache, and return the response. Note that the proxy MAY
   forward the request on to another proxy or directly to the server 

   specified by the absoluteURI. In order to avoid request loops, a
   proxy MUST be able to recognize all of its server names, including
   any aliases, local variations, and the numeric IP address. An example
   Request-Line would be:

       GET &lt;a href=&quot;http://www.w3.org/pub/WWW/TheProject.html&quot;&gt;http://www.w3.org/pub/WWW/TheProject.html&lt;/a&gt; HTTP/1.1

   To allow for transition to absoluteURIs in all requests in future
   versions of HTTP, all HTTP/1.1 servers MUST accept the absoluteURI
   form in requests, even though HTTP/1.1 clients will only generate
   them in requests to proxies.

   The authority form is only used by the CONNECT method (&lt;a href=&quot;#section-9.9&quot;&gt;section 9.9&lt;/a&gt;).

   The most common form of Request-URI is that used to identify a
   resource on an origin server or gateway. In this case the absolute
   path of the URI MUST be transmitted (see &lt;a href=&quot;#section-3.2.1&quot;&gt;section 3.2.1&lt;/a&gt;, abs_path) as
   the Request-URI, and the network location of the URI (authority) MUST
   be transmitted in a Host header field. For example, a client wishing
   to retrieve the resource above directly from the origin server would
   create a TCP connection to port 80 of the host &quot;www.w3.org&quot; and send
   the lines:

       GET /pub/WWW/TheProject.html HTTP/1.1
       Host: www.w3.org

   followed by the remainder of the Request. Note that the absolute path
   cannot be empty; if none is present in the original URI, it MUST be
   given as &quot;/&quot; (the server root).

   The Request-URI is transmitted in the format specified in &lt;a href=&quot;#section-3.2.1&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;. If the Request-URI is encoded using the &quot;% HEX HEX&quot; encoding
   [&lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;], the origin server MUST decode the Request-URI in order to
   properly interpret the request. Servers SHOULD respond to invalid
   Request-URIs with an appropriate status code.

   A transparent proxy MUST NOT rewrite the &quot;abs_path&quot; part of the
   received Request-URI when forwarding it to the next inbound server,
   except as noted above to replace a null abs_path with &quot;/&quot;.

      Note: The &quot;no rewrite&quot; rule prevents the proxy from changing the
      meaning of the request when the origin server is improperly using
      a non-reserved URI character for a reserved purpose.  Implementors
      should be aware that some pre-HTTP/1.1 proxies have been known to
      rewrite the Request-URI.</source>
          <target state="translated">Request-URI는 Uniform Resource Identifier입니다 ( &lt;a href=&quot;#section-3.2&quot;&gt;섹션 3.2)&lt;/a&gt;) 및 요청을 적용 할 리소스를 식별합니다. Request-URI = &quot;*&quot;| absoluteURI | abs_path | 권한 Request-URI의 네 가지 옵션은 요청의 특성에 따라 다릅니다. 별표 &quot;*&quot;는 요청이 특정 자원이 아니라 서버 자체에 적용되고 사용 된 방법이 자원에 반드시 적용되지 않는 경우에만 허용됨을 의미합니다. 한 가지 예는 OPTIONS * HTTP / 1.1입니다. 요청이 프록시에 작성 될 때 absoluteURI 양식이 필요합니다. 프록시는 유효한 캐시에서 요청 또는 서비스를 전달하고 응답을 반환하도록 요청됩니다. 프록시는 요청을 다른 프록시 또는 absoluteURI에 의해 지정된 서버로 직접 전달할 수 있습니다. 요청 루프를 피하기 위해프록시는 별칭, 로컬 변형 및 숫자 IP 주소를 포함한 모든 서버 이름을 인식 할 수 있어야합니다. 요청 라인의 예는 다음과 같습니다. GET&lt;a href=&quot;http://www.w3.org/pub/WWW/TheProject.html&quot;&gt;http://www.w3.org/pub/WWW/TheProject.html&lt;/a&gt; HTTP / 1.1 향후 HTTP 버전의 모든 요청에서 absoluteURI로 전환 할 수 있도록하려면 모든 HTTP / 1.1 서버는 요청에서 절대 URI 양식을 수락해야합니다. HTTP / 1.1 클라이언트는 프록시 요청에서만 클라이언트를 생성합니다. 권한 형식은 CONNECT 메소드에서만 사용됩니다 ( &lt;a href=&quot;#section-9.9&quot;&gt;9.9 절&lt;/a&gt; ). Request-URI의 가장 일반적인 형태는 오리진 서버 또는 게이트웨이에서 자원을 식별하는 데 사용됩니다. 이 경우 URI의 절대 경로를 전송해야합니다 ( &lt;a href=&quot;#section-3.2.1&quot;&gt;섹션 3.2.1&lt;/a&gt; 참조)., abs_path)를 Request-URI로, URI (권한)의 네트워크 위치는 호스트 헤더 필드로 전송해야합니다. 예를 들어, 오리진 서버에서 직접 위의 자원을 검색하려는 클라이언트는 &quot;www.w3.org&quot;호스트의 포트 80에 대한 TCP 연결을 작성하고 다음 행을 보냅니다. GET /pub/WWW/TheProject.html HTTP / 1.1 호스트 : www.w3.org 다음에 나머지 요청. 절대 경로는 비워 둘 수 없습니다. 원래 URI에 존재하지 않는 경우 반드시 &quot;/&quot;(서버 루트)로 지정해야합니다. Request-URI는 &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1 &lt;/a&gt;&lt;a href=&quot;#section-3.2.1&quot;&gt;절에&lt;/a&gt; 명시된 형식으로 전송된다 . Request-URI가 &quot;% HEX HEX&quot;인코딩을 사용하여 인코딩 된 경우 [ &lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;], 오리진 서버는 요청을 올바르게 해석하기 위해 Request-URI를 디코딩해야합니다. 서버는 적절한 상태 코드로 유효하지 않은 Request-URI에 응답해야합니다. 투명 프록시는 수신 된 Request-URI를 다음 인바운드 서버로 전달할 때 널 abs_path를 &quot;/&quot;로 바꾸는 것을 제외하고는 수신 된 Request-URI의 &quot;abs_path&quot;부분을 다시 쓰지 않아야합니다. 참고 : &quot;다시 쓰기 금지&quot;규칙은 오리진 서버가 예약되지 않은 URI 문자를 예약 된 목적으로 잘못 사용하는 경우 프록시가 요청의 의미를 변경하지 못하게합니다. 구현자는 일부 HTTP / 1.1 이전 프록시가 Request-URI를 다시 쓰는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="27df10f6e52fad72f86af47082d4aed616c53e54" translate="yes" xml:space="preserve">
          <source>The Retry-After response-header field can be used with a 503 (Service
   Unavailable) response to indicate how long the service is expected to
   be unavailable to the requesting client. This field MAY also be used
   with any 3xx (Redirection) response to indicate the minimum time the
   user-agent is asked wait before issuing the redirected request. The
   value of this field can be either an HTTP-date or an integer number
   of seconds (in decimal) after the time of the response.

       Retry-After  = &quot;Retry-After&quot; &quot;:&quot; ( HTTP-date | delta-seconds )

   Two examples of its use are

       Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
       Retry-After: 120

   In the latter example, the delay is 2 minutes.</source>
          <target state="translated">Retry-After response-header 필드는 503 (Service Unavailable) 응답과 함께 사용하여 요청 클라이언트가 서비스를 사용할 수없는 시간을 나타냅니다. 이 필드는 3xx (리디렉션) 응답과 함께 사용되어 리디렉트 된 요청을 발행하기 전에 사용자 에이전트에게 대기 시간을 요청하는 최소 시간을 나타냅니다. 이 필드의 값은 응답 시간 후 HTTP 날짜 또는 정수 초 (10 진수) 일 수 있습니다. Retry-After = &quot;Retry-After&quot; &quot;:&quot;(HTTP-date | delta-seconds) 사용의 두 가지 예는 Retry-After입니다. Fri, 31 Dec 1999 23:59:59 GMT Retry-After : 120 후자 예를 들어, 지연 시간은 2 분입니다.</target>
        </trans-unit>
        <trans-unit id="818c17cd76fd87b90da17d6a18fd82be94517b9c" translate="yes" xml:space="preserve">
          <source>The SETTINGS frame (type=0x4) conveys configuration parameters that
   affect how endpoints communicate, such as preferences and constraints
   on peer behavior.  The SETTINGS frame is also used to acknowledge the
   receipt of those parameters.  Individually, a SETTINGS parameter can
   also be referred to as a &quot;setting&quot;. 

   SETTINGS parameters are not negotiated; they describe characteristics
   of the sending peer, which are used by the receiving peer.  Different
   values for the same parameter can be advertised by each peer.  For
   example, a client might set a high initial flow-control window,
   whereas a server might set a lower value to conserve resources.

   A SETTINGS frame MUST be sent by both endpoints at the start of a
   connection and MAY be sent at any other time by either endpoint over
   the lifetime of the connection.  Implementations MUST support all of
   the parameters defined by this specification.

   Each parameter in a SETTINGS frame replaces any existing value for
   that parameter.  Parameters are processed in the order in which they
   appear, and a receiver of a SETTINGS frame does not need to maintain
   any state other than the current value of its parameters.  Therefore,
   the value of a SETTINGS parameter is the last value that is seen by a
   receiver.

   SETTINGS parameters are acknowledged by the receiving peer.  To
   enable this, the SETTINGS frame defines the following flag:

   ACK (0x1):  When set, bit 0 indicates that this frame acknowledges
      receipt and application of the peer's SETTINGS frame.  When this
      bit is set, the payload of the SETTINGS frame MUST be empty.
      Receipt of a SETTINGS frame with the ACK flag set and a length
      field value other than 0 MUST be treated as a connection error
      (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type FRAME_SIZE_ERROR.  For more information,
      see &lt;a href=&quot;#section-6.5.3&quot;&gt;Section 6.5.3&lt;/a&gt; (&quot;Settings Synchronization&quot;).

   SETTINGS frames always apply to a connection, never a single stream.
   The stream identifier for a SETTINGS frame MUST be zero (0x0).  If an
   endpoint receives a SETTINGS frame whose stream identifier field is
   anything other than 0x0, the endpoint MUST respond with a connection
   error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   The SETTINGS frame affects connection state.  A badly formed or
   incomplete SETTINGS frame MUST be treated as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type PROTOCOL_ERROR.

   A SETTINGS frame with a length other than a multiple of 6 octets MUST
   be treated as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   FRAME_SIZE_ERROR.</source>
          <target state="translated">SETTINGS 프레임 (유형 = 0x4)은 엔드 포인트가 통신하는 방식에 영향을주는 구성 매개 변수 (예 : 피어 동작에 대한 기본 설정 및 제약)를 전달합니다. SETTINGS 프레임은 해당 매개 변수의 수신을 확인하는데도 사용됩니다. 개별적으로 SETTINGS 매개 변수는 &quot;설정&quot;이라고도합니다. SETTINGS 매개 변수는 협상되지 않습니다. 수신 피어가 사용하는 송신 피어의 특성을 설명합니다. 동일한 매개 변수에 대해 서로 다른 값을 각 피어가 알릴 수 있습니다. 예를 들어 클라이언트는 초기 흐름 제어 창을 높게 설정하고 서버는 리소스를 절약하기 위해 더 낮은 값을 설정할 수 있습니다. SETTINGS 프레임은 연결 시작시 두 엔드 포인트 모두에 의해 전송되어야하며 연결 ​​수명 동안 어느 한 엔드 포인트에 의해 다른 시간에 전송 될 수 있습니다.구현은이 사양에 정의 된 모든 매개 변수를 지원해야합니다. SETTINGS 프레임의 각 매개 변수는 해당 매개 변수의 기존 값을 대체합니다. 매개 변수는 나타나는 순서대로 처리되며 SETTINGS 프레임의 수신자는 매개 변수의 현재 값 이외의 상태를 유지할 필요가 없습니다. 따라서 SETTINGS 매개 변수의 값은 수신자가 보는 마지막 값입니다. SETTINGS 매개 변수는 수신 피어가 승인합니다. 이를 활성화하기 위해 SETTINGS 프레임은 다음 플래그를 정의합니다. ACK (0x1) : 설정되면 비트 0은이 프레임이 피어의 SETTINGS 프레임의 수신 및 적용을 승인 함을 나타냅니다. 이 비트가 설정되면 SETTINGS 프레임의 페이로드가 비어 있어야합니다.ACK 플래그가 설정된 SETTINGS 프레임과 0이 아닌 길이 필드 값을 수신하면 연결 오류 (&lt;a href=&quot;#section-5.4.1&quot;&gt;&lt;/a&gt;FRAME_SIZE_ERROR 유형의 섹션 5.4.1 ). 자세한 내용은 &lt;a href=&quot;#section-6.5.3&quot;&gt;섹션 6.5.3&lt;/a&gt; ( &quot;설정 동기화&quot;)을 참조하십시오 . SETTINGS 프레임은 항상 단일 스트림이 아닌 연결에 적용됩니다. SETTINGS 프레임의 스트림 식별자는 0 (0x0)이어야합니다. 엔드 포인트가 스트림 식별자 필드가 0x0이 아닌 SETTINGS 프레임을 수신하면, 엔드 포인트는 PROTOCOL_ERROR 유형 의 연결 오류 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt; )로 응답해야 합니다. 설정 프레임은 연결 상태에 영향을줍니다. 잘못 구성되거나 불완전한 SETTINGS 프레임은 PROTOCOL_ERROR 유형 의 연결 오류 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt; ) 로 처리되어야 합니다. 길이가 6 옥텟의 배수가 아닌 SETTINGS 프레임은 연결 오류로 처리되어야합니다 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt;) FRAME_SIZE_ERROR 유형.</target>
        </trans-unit>
        <trans-unit id="9f8174334dfb42409bd14d344357a61e0522761d" translate="yes" xml:space="preserve">
          <source>The Sec-Fetch-Dest HTTP Request Header</source>
          <target state="translated">Sec-Fetch-Dest HTTP 요청 헤더</target>
        </trans-unit>
        <trans-unit id="089fba56f3ba935817b0ee0ba0d50c6c7250a452" translate="yes" xml:space="preserve">
          <source>The Sec-Fetch-Mode HTTP Request Header</source>
          <target state="translated">Sec-Fetch-Mode HTTP 요청 헤더</target>
        </trans-unit>
        <trans-unit id="0922dedc70e7039f73de5afb1791c6af1cadc728" translate="yes" xml:space="preserve">
          <source>The Sec-Fetch-Site HTTP Request Header</source>
          <target state="translated">Sec-Fetch-Site HTTP 요청 헤더</target>
        </trans-unit>
        <trans-unit id="8e9ebb888b481c6982054f06f45605ddc268b5db" translate="yes" xml:space="preserve">
          <source>The Sec-Fetch-User HTTP Request Header</source>
          <target state="translated">Sec-Fetch-User HTTP 요청 헤더</target>
        </trans-unit>
        <trans-unit id="f351e70802256078de6c82adb6c9f8135e4ad1a4" translate="yes" xml:space="preserve">
          <source>The Server response-header field contains information about the
   software used by the origin server to handle the request. The field
   can contain multiple product tokens (&lt;a href=&quot;#section-3.8&quot;&gt;section 3.8&lt;/a&gt;) and comments
   identifying the server and any significant subproducts. The product
   tokens are listed in order of their significance for identifying the
   application.

       Server         = &quot;Server&quot; &quot;:&quot; 1*( product | comment )

   Example:

       Server: CERN/3.0 libwww/2.17

   If the response is being forwarded through a proxy, the proxy
   application MUST NOT modify the Server response-header. Instead, it
   SHOULD include a Via field (as described in &lt;a href=&quot;#section-14.45&quot;&gt;section 14.45&lt;/a&gt;).

      Note: Revealing the specific software version of the server might
      allow the server machine to become more vulnerable to attacks
      against software that is known to contain security holes. Server
      implementors are encouraged to make this field a configurable
      option.</source>
          <target state="translated">서버 응답 헤더 필드에는 요청을 처리하기 위해 오리진 서버가 사용하는 소프트웨어에 대한 정보가 있습니다. 이 필드에는 여러 제품 토큰 ( &lt;a href=&quot;#section-3.8&quot;&gt;섹션 3.8&lt;/a&gt; )과 서버 및 중요한 하위 제품을 식별하는 주석 이 포함될 수 있습니다 . 제품 토큰은 응용 프로그램을 식별하는 데 중요한 순서대로 나열됩니다. 서버 = &quot;서버&quot; &quot;:&quot;1 * (product | comment) 예 : 서버 : CERN / 3.0 libwww / 2.17 프록시를 통해 응답이 전달되는 경우 프록시 응용 프로그램은 서버 응답 헤더를 수정해서는 안됩니다. 대신, Via 필드를 포함해야합니다 ( &lt;a href=&quot;#section-14.45&quot;&gt;섹션 14.45에&lt;/a&gt; 설명되어 있음)). 참고 : 서버의 특정 소프트웨어 버전을 공개하면 서버 시스템이 보안 허점이있는 것으로 알려진 소프트웨어에 대한 공격에 더 취약해질 수 있습니다. 서버 구현자는이 필드를 구성 가능한 옵션으로 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="87ed514ae2ccfa3b72514fa6a84c466f301be7c1" translate="yes" xml:space="preserve">
          <source>The Status-Code element is a 3-digit integer result code of the
   attempt to understand and satisfy the request. These codes are fully
   defined in &lt;a href=&quot;#section-10&quot;&gt;section 10&lt;/a&gt;. The Reason-Phrase is intended to give a short
   textual description of the Status-Code. The Status-Code is intended
   for use by automata and the Reason-Phrase is intended for the human
   user. The client is not required to examine or display the Reason-
   Phrase. 

   The first digit of the Status-Code defines the class of response. The
   last two digits do not have any categorization role. There are 5
   values for the first digit:

      - 1xx: Informational - Request received, continuing process

      - 2xx: Success - The action was successfully received,
        understood, and accepted

      - 3xx: Redirection - Further action must be taken in order to
        complete the request

      - 4xx: Client Error - The request contains bad syntax or cannot
        be fulfilled

      - 5xx: Server Error - The server failed to fulfill an apparently
        valid request

   The individual values of the numeric status codes defined for
   HTTP/1.1, and an example set of corresponding Reason-Phrase's, are
   presented below. The reason phrases listed here are only
   recommendations -- they MAY be replaced by local equivalents without
   affecting the protocol.

      Status-Code    =
            &quot;100&quot;  ; &lt;a href=&quot;#section-10.1.1&quot;&gt;Section 10.1.1&lt;/a&gt;: Continue
          | &quot;101&quot;  ; &lt;a href=&quot;#section-10.1.2&quot;&gt;Section 10.1.2&lt;/a&gt;: Switching Protocols
          | &quot;200&quot;  ; &lt;a href=&quot;#section-10.2.1&quot;&gt;Section 10.2.1&lt;/a&gt;: OK
          | &quot;201&quot;  ; &lt;a href=&quot;#section-10.2.2&quot;&gt;Section 10.2.2&lt;/a&gt;: Created
          | &quot;202&quot;  ; &lt;a href=&quot;#section-10.2.3&quot;&gt;Section 10.2.3&lt;/a&gt;: Accepted
          | &quot;203&quot;  ; &lt;a href=&quot;#section-10.2.4&quot;&gt;Section 10.2.4&lt;/a&gt;: Non-Authoritative Information
          | &quot;204&quot;  ; &lt;a href=&quot;#section-10.2.5&quot;&gt;Section 10.2.5&lt;/a&gt;: No Content
          | &quot;205&quot;  ; &lt;a href=&quot;#section-10.2.6&quot;&gt;Section 10.2.6&lt;/a&gt;: Reset Content
          | &quot;206&quot;  ; &lt;a href=&quot;#section-10.2.7&quot;&gt;Section 10.2.7&lt;/a&gt;: Partial Content
          | &quot;300&quot;  ; &lt;a href=&quot;#section-10.3.1&quot;&gt;Section 10.3.1&lt;/a&gt;: Multiple Choices
          | &quot;301&quot;  ; &lt;a href=&quot;#section-10.3.2&quot;&gt;Section 10.3.2&lt;/a&gt;: Moved Permanently
          | &quot;302&quot;  ; &lt;a href=&quot;#section-10.3.3&quot;&gt;Section 10.3.3&lt;/a&gt;: Found
          | &quot;303&quot;  ; &lt;a href=&quot;#section-10.3.4&quot;&gt;Section 10.3.4&lt;/a&gt;: See Other
          | &quot;304&quot;  ; &lt;a href=&quot;#section-10.3.5&quot;&gt;Section 10.3.5&lt;/a&gt;: Not Modified
          | &quot;305&quot;  ; &lt;a href=&quot;#section-10.3.6&quot;&gt;Section 10.3.6&lt;/a&gt;: Use Proxy
          | &quot;307&quot;  ; &lt;a href=&quot;#section-10.3.8&quot;&gt;Section 10.3.8&lt;/a&gt;: Temporary Redirect
          | &quot;400&quot;  ; &lt;a href=&quot;#section-10.4.1&quot;&gt;Section 10.4.1&lt;/a&gt;: Bad Request
          | &quot;401&quot;  ; &lt;a href=&quot;#section-10.4.2&quot;&gt;Section 10.4.2&lt;/a&gt;: Unauthorized
          | &quot;402&quot;  ; &lt;a href=&quot;#section-10.4.3&quot;&gt;Section 10.4.3&lt;/a&gt;: Payment Required
          | &quot;403&quot;  ; &lt;a href=&quot;#section-10.4.4&quot;&gt;Section 10.4.4&lt;/a&gt;: Forbidden
          | &quot;404&quot;  ; &lt;a href=&quot;#section-10.4.5&quot;&gt;Section 10.4.5&lt;/a&gt;: Not Found
          | &quot;405&quot;  ; &lt;a href=&quot;#section-10.4.6&quot;&gt;Section 10.4.6&lt;/a&gt;: Method Not Allowed
          | &quot;406&quot;  ; &lt;a href=&quot;#section-10.4.7&quot;&gt;Section 10.4.7&lt;/a&gt;: Not Acceptable 

          | &quot;407&quot;  ; &lt;a href=&quot;#section-10.4.8&quot;&gt;Section 10.4.8&lt;/a&gt;: Proxy Authentication Required
          | &quot;408&quot;  ; &lt;a href=&quot;#section-10.4.9&quot;&gt;Section 10.4.9&lt;/a&gt;: Request Time-out
          | &quot;409&quot;  ; &lt;a href=&quot;#section-10.4.10&quot;&gt;Section 10.4.10&lt;/a&gt;: Conflict
          | &quot;410&quot;  ; &lt;a href=&quot;#section-10.4.11&quot;&gt;Section 10.4.11&lt;/a&gt;: Gone
          | &quot;411&quot;  ; &lt;a href=&quot;#section-10.4.12&quot;&gt;Section 10.4.12&lt;/a&gt;: Length Required
          | &quot;412&quot;  ; &lt;a href=&quot;#section-10.4.13&quot;&gt;Section 10.4.13&lt;/a&gt;: Precondition Failed
          | &quot;413&quot;  ; &lt;a href=&quot;#section-10.4.14&quot;&gt;Section 10.4.14&lt;/a&gt;: Request Entity Too Large
          | &quot;414&quot;  ; &lt;a href=&quot;#section-10.4.15&quot;&gt;Section 10.4.15&lt;/a&gt;: Request-URI Too Large
          | &quot;415&quot;  ; &lt;a href=&quot;#section-10.4.16&quot;&gt;Section 10.4.16&lt;/a&gt;: Unsupported Media Type
          | &quot;416&quot;  ; &lt;a href=&quot;#section-10.4.17&quot;&gt;Section 10.4.17&lt;/a&gt;: Requested range not satisfiable
          | &quot;417&quot;  ; &lt;a href=&quot;#section-10.4.18&quot;&gt;Section 10.4.18&lt;/a&gt;: Expectation Failed
          | &quot;500&quot;  ; &lt;a href=&quot;#section-10.5.1&quot;&gt;Section 10.5.1&lt;/a&gt;: Internal Server Error
          | &quot;501&quot;  ; &lt;a href=&quot;#section-10.5.2&quot;&gt;Section 10.5.2&lt;/a&gt;: Not Implemented
          | &quot;502&quot;  ; &lt;a href=&quot;#section-10.5.3&quot;&gt;Section 10.5.3&lt;/a&gt;: Bad Gateway
          | &quot;503&quot;  ; &lt;a href=&quot;#section-10.5.4&quot;&gt;Section 10.5.4&lt;/a&gt;: Service Unavailable
          | &quot;504&quot;  ; &lt;a href=&quot;#section-10.5.5&quot;&gt;Section 10.5.5&lt;/a&gt;: Gateway Time-out
          | &quot;505&quot;  ; &lt;a href=&quot;#section-10.5.6&quot;&gt;Section 10.5.6&lt;/a&gt;: HTTP Version not supported
          | extension-code

      extension-code = 3DIGIT
      Reason-Phrase  = *&amp;lt;TEXT, excluding CR, LF&amp;gt;

   HTTP status codes are extensible. HTTP applications are not required
   to understand the meaning of all registered status codes, though such
   understanding is obviously desirable. However, applications MUST
   understand the class of any status code, as indicated by the first
   digit, and treat any unrecognized response as being equivalent to the
   x00 status code of that class, with the exception that an
   unrecognized response MUST NOT be cached. For example, if an
   unrecognized status code of 431 is received by the client, it can
   safely assume that there was something wrong with its request and
   treat the response as if it had received a 400 status code. In such
   cases, user agents SHOULD present to the user the entity returned
   with the response, since that entity is likely to include human-
   readable information which will explain the unusual status.</source>
          <target state="translated">Status-Code 요소는 요청을 이해하고 만족시키기위한 3 자리 정수 결과 코드입니다. 이 코드는 &lt;a href=&quot;#section-10&quot;&gt;섹션 10에&lt;/a&gt; 완전히 정의되어 있습니다.. 이유 문구는 상태 코드에 대한 간단한 텍스트 설명을 제공하기위한 것입니다. Status-Code는 오토마타에서 사용하기위한 것이며 Reason-Phrase는 사용자를위한 것입니다. 클라이언트는 이유 문구를 조사하거나 표시 할 필요가 없습니다. Status-Code의 첫 번째 숫자는 응답 클래스를 정의합니다. 마지막 두 자리에는 분류 역할이 없습니다. 첫 번째 숫자에는 5 개의 값이 있습니다.-1xx : 정보-요청 수신, 프로세스 계속-2xx : 성공-조치가 성공적으로 수신, 이해 및 승인되었습니다.-3xx : 경로 재 지정-요청을 완료하려면 추가 조치를 수행해야합니다. -4xx : 클라이언트 오류-요청에 잘못된 구문이 포함되어 있거나 이행 할 수 없습니다-5xx :서버 오류-서버가 명백히 유효한 요청을 이행하지 못했습니다. HTTP / 1.1에 대해 정의 된 숫자 상태 코드의 개별 값 및 해당하는 이유 문구의 예가 아래에 나와 있습니다. 여기에 나열된 이유 문구는 권장 사항 일뿐입니다. 프로토콜에 영향을주지 않으면 서 해당하는 문구로 대체 할 수 있습니다. 상태 코드 = &quot;100&quot;;&lt;a href=&quot;#section-10.1.1&quot;&gt;섹션 10.1.1&lt;/a&gt; : 계속 | &quot;101&quot;; &lt;a href=&quot;#section-10.1.2&quot;&gt;섹션 10.1.2&lt;/a&gt; : 스위칭 프로토콜 | &quot;200&quot;; &lt;a href=&quot;#section-10.2.1&quot;&gt;섹션 10.2.1&lt;/a&gt; : 확인 | &quot;201&quot;; &lt;a href=&quot;#section-10.2.2&quot;&gt;섹션 10.2.2&lt;/a&gt; : 작성 | &quot;202&quot;; &lt;a href=&quot;#section-10.2.3&quot;&gt;섹션 10.2.3&lt;/a&gt; : 허용 | &quot;203&quot;; &lt;a href=&quot;#section-10.2.4&quot;&gt;섹션 10.2.4&lt;/a&gt; : 신뢰할 수없는 정보 | &quot;204&quot;; &lt;a href=&quot;#section-10.2.5&quot;&gt;섹션 10.2.5&lt;/a&gt; : 내용 없음 | &quot;205&quot;; &lt;a href=&quot;#section-10.2.6&quot;&gt;섹션 10.2.6&lt;/a&gt; : 내용 재설정 | &quot;206&quot;; &lt;a href=&quot;#section-10.2.7&quot;&gt;섹션 10.2.7&lt;/a&gt; : 부분 내용 | &quot;300&quot;; &lt;a href=&quot;#section-10.3.1&quot;&gt;섹션 10.3.1&lt;/a&gt; : 다중 선택 | &quot;301&quot;; &lt;a href=&quot;#section-10.3.2&quot;&gt;섹션 10.3.&lt;/a&gt;2 : 영구적으로 움직였다 | &quot;302&quot;;&lt;a href=&quot;#section-10.3.3&quot;&gt;섹션 10.3.3&lt;/a&gt; : 발견 | &quot;303&quot;; &lt;a href=&quot;#section-10.3.4&quot;&gt;섹션 10.3.4&lt;/a&gt; : 기타 | &quot;304&quot;; &lt;a href=&quot;#section-10.3.5&quot;&gt;섹션 10.3.5&lt;/a&gt; : 수정되지 않음 | &quot;305&quot;; &lt;a href=&quot;#section-10.3.6&quot;&gt;섹션 10.3.6&lt;/a&gt; : 프록시 사용 | &quot;307&quot;; &lt;a href=&quot;#section-10.3.8&quot;&gt;섹션 10.3.8&lt;/a&gt; : 임시 리디렉션 | &quot;400&quot;; &lt;a href=&quot;#section-10.4.1&quot;&gt;섹션 10.4.1&lt;/a&gt; : 잘못된 요청 | &quot;401&quot;; &lt;a href=&quot;#section-10.4.2&quot;&gt;섹션 10.4.2&lt;/a&gt; : 무단 | &quot;402&quot;; &lt;a href=&quot;#section-10.4.3&quot;&gt;섹션 10.4.3&lt;/a&gt; : 지불 필요 | &quot;403&quot;; &lt;a href=&quot;#section-10.4.4&quot;&gt;섹션 10.4.4&lt;/a&gt; : 금지 | &quot;404&quot;; &lt;a href=&quot;#section-10.4.5&quot;&gt;섹션 10.4.5&lt;/a&gt; : 찾을 수 없음 | &quot;405&quot;; &lt;a href=&quot;#section-10.4.6&quot;&gt;섹션 10.4.6&lt;/a&gt; :허용되지 않는 방법 | &quot;406&quot;; &lt;a href=&quot;#section-10.4.7&quot;&gt;섹션 10.4.7&lt;/a&gt;: 허용되지 않음 | &quot;407&quot;; &lt;a href=&quot;#section-10.4.8&quot;&gt;섹션 10.4.8&lt;/a&gt; : 프록시 인증 필요 | &quot;408&quot;; &lt;a href=&quot;#section-10.4.9&quot;&gt;섹션 10.4.9&lt;/a&gt; : 요청 시간 초과 | &quot;409&quot;; &lt;a href=&quot;#section-10.4.10&quot;&gt;섹션 10.4.10&lt;/a&gt; : 충돌 | &quot;410&quot;; &lt;a href=&quot;#section-10.4.11&quot;&gt;섹션 10.4.11&lt;/a&gt; : 사라짐 | &quot;411&quot;; &lt;a href=&quot;#section-10.4.12&quot;&gt;섹션 10.4.12&lt;/a&gt; : 필요한 길이 | &quot;412&quot;; &lt;a href=&quot;#section-10.4.13&quot;&gt;섹션 10.4.13&lt;/a&gt; : 전제 조건 실패 | &quot;413&quot;; &lt;a href=&quot;#section-10.4.14&quot;&gt;섹션 10.4.14&lt;/a&gt; : 요청 엔티티가 너무 큼 | &quot;414&quot;; &lt;a href=&quot;#section-10.4.15&quot;&gt;섹션 10.4.15&lt;/a&gt; : 요청 URI가 너무 큼 | &quot;415&quot;; &lt;a href=&quot;#section-10.4.16&quot;&gt;섹션 10.4.16&lt;/a&gt; : 지원되지 않는 미디어 유형 | &quot;416&quot;;&lt;a href=&quot;#section-10.4.17&quot;&gt;섹션 10.4.17&lt;/a&gt;: 요청 된 범위를 충족시킬 수 없음 | &quot;417&quot;; &lt;a href=&quot;#section-10.4.18&quot;&gt;섹션 10.4.18&lt;/a&gt; : 예상 실패 | &quot;500&quot;; &lt;a href=&quot;#section-10.5.1&quot;&gt;섹션 10.5.1&lt;/a&gt; : 내부 서버 오류 | &quot;501&quot;; &lt;a href=&quot;#section-10.5.2&quot;&gt;섹션 10.5.2&lt;/a&gt; : 구현되지 않음 | &quot;502&quot;; &lt;a href=&quot;#section-10.5.3&quot;&gt;섹션 10.5.3&lt;/a&gt; : 잘못된 게이트웨이 | &quot;503&quot;; &lt;a href=&quot;#section-10.5.4&quot;&gt;섹션 10.5.4&lt;/a&gt; : 사용할 수없는 서비스 | &quot;504&quot;; &lt;a href=&quot;#section-10.5.5&quot;&gt;섹션 10.5.5&lt;/a&gt; : 게이트웨이 시간 초과 | &quot;505&quot;; &lt;a href=&quot;#section-10.5.6&quot;&gt;섹션 10.5.6&lt;/a&gt;: HTTP 버전이 지원되지 않습니다 | extension-code extension-code = 3DIGIT 이유-구문 = * &amp;lt;TEXT, CR, LF 제외&amp;gt; HTTP 상태 코드는 확장 가능합니다. HTTP 애플리케이션은 등록 된 모든 상태 코드의 의미를 이해할 필요는 없지만, 그러한 이해는 분명히 바람직합니다. 그러나 응용 프로그램은 첫 번째 숫자로 표시된 상태 코드의 클래스를 이해해야하며 인식 할 수없는 응답을 캐시해서는 안된다는 점을 제외하고 인식 할 수없는 응답을 해당 클래스의 x00 상태 코드와 동등한 것으로 처리해야합니다. 예를 들어, 클라이언트가 인식 할 수없는 상태 코드 431을 수신하면 요청에 문제가 있다고 가정하고 응답을 400 상태 코드를 수신 한 것처럼 처리 할 수 ​​있습니다. 그런 경우는,사용자 에이전트는 사용자에게 응답과 함께 반환 된 개체를 사용자에게 제공해야합니다. 그 개체는 사람이 읽을 수있는 정보를 포함하여 비정상 상태를 설명 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b8418e17a41aec97d3c590fcc65fedf33be9a1c2" translate="yes" xml:space="preserve">
          <source>The TCP connection failed due to reasons not covered by previous errors</source>
          <target state="translated">이전 오류에 포함되지 않은 이유로 인해 TCP 연결이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="a63d3da83f08f3589783fd322c14eb384668776f" translate="yes" xml:space="preserve">
          <source>The TCP connection was aborted</source>
          <target state="translated">TCP 연결이 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="ece1a07cee60e2c0d379acd1235868c7480c2fcb" translate="yes" xml:space="preserve">
          <source>The TCP connection was closed by the server</source>
          <target state="translated">TCP 연결이 서버에 의해 닫혔습니다.</target>
        </trans-unit>
        <trans-unit id="796733a0ab45ac90906d6f198849475b13814e44" translate="yes" xml:space="preserve">
          <source>The TCP connection was refused by the server</source>
          <target state="translated">TCP 연결이 서버에서 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="44cef75a8f9ea523ffedd880063709751f6702f3" translate="yes" xml:space="preserve">
          <source>The TCP connection was reset</source>
          <target state="translated">TCP 연결이 재설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="a033c5a9ee721261b9ef910b0f68478ac7363993" translate="yes" xml:space="preserve">
          <source>The TCP handshake itself is time-consuming, but a TCP connection adapts to its load, becoming more efficient with more sustained (or warm) connections. Short-lived connections do not make use of this efficiency feature of TCP, and performance degrades from optimum by persisting to transmit over a new, cold connection.</source>
          <target state="translated">TCP 핸드 셰이크 자체는 시간이 많이 걸리지 만 TCP 연결은로드에 적응하여보다 지속적이거나 따뜻한 연결로보다 효율적입니다. 수명이 짧은 연결은 TCP의 이러한 효율성 기능을 사용하지 않으며 새로운 콜드 연결을 통해 전송을 지속함으로써 성능이 최적에서 저하됩니다.</target>
        </trans-unit>
        <trans-unit id="a9a108e88ad08677b3a7b101ee6720f85b6d8f49" translate="yes" xml:space="preserve">
          <source>The TE request-header field indicates what extension transfer-codings
   it is willing to accept in the response and whether or not it is
   willing to accept trailer fields in a chunked transfer-coding. Its
   value may consist of the keyword &quot;trailers&quot; and/or a comma-separated
   list of extension transfer-coding names with optional accept
   parameters (as described in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;).

       TE        = &quot;TE&quot; &quot;:&quot; #( t-codings )
       t-codings = &quot;trailers&quot; | ( transfer-extension [ accept-params ] )

   The presence of the keyword &quot;trailers&quot; indicates that the client is
   willing to accept trailer fields in a chunked transfer-coding, as
   defined in &lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt;. This keyword is reserved for use with
   transfer-coding values even though it does not itself represent a
   transfer-coding.

   Examples of its use are:

       TE: deflate
       TE:
       TE: trailers, deflate;q=0.5

   The TE header field only applies to the immediate connection.
   Therefore, the keyword MUST be supplied within a Connection header
   field (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;) whenever TE is present in an HTTP/1.1 message.

   A server tests whether a transfer-coding is acceptable, according to
   a TE field, using these rules:

      1. The &quot;chunked&quot; transfer-coding is always acceptable. If the
         keyword &quot;trailers&quot; is listed, the client indicates that it is
         willing to accept trailer fields in the chunked response on
         behalf of itself and any downstream clients. The implication is
         that, if given, the client is stating that either all
         downstream clients are willing to accept trailer fields in the
         forwarded response, or that it will attempt to buffer the
         response on behalf of downstream recipients.

         Note: HTTP/1.1 does not define any means to limit the size of a
         chunked response such that a client can be assured of buffering
         the entire response.

      2. If the transfer-coding being tested is one of the transfer-
         codings listed in the TE field, then it is acceptable unless it
         is accompanied by a qvalue of 0. (As defined in &lt;a href=&quot;#section-3.9&quot;&gt;section 3.9&lt;/a&gt;, a
         qvalue of 0 means &quot;not acceptable.&quot;) 

      3. If multiple transfer-codings are acceptable, then the
         acceptable transfer-coding with the highest non-zero qvalue is
         preferred.  The &quot;chunked&quot; transfer-coding always has a qvalue
         of 1.

   If the TE field-value is empty or if no TE field is present, the only
   transfer-coding  is &quot;chunked&quot;. A message with no transfer-coding is
   always acceptable.</source>
          <target state="translated">TE 요청 헤더 필드는 응답에서 수락 할 확장 전송 코딩 및 청크 전송 코딩에서 트레일러 필드를 허용 할 것인지 여부를 나타냅니다. 값은 &quot;트레일러&quot;키워드 및 / 또는 선택적 수락 매개 변수가있는 쉼표로 구분 된 확장 전송 코드화 이름 목록 &lt;a href=&quot;#section-3.6&quot;&gt;(3.6 절 참조&lt;/a&gt; )으로 구성 될 수 있습니다. TE = &quot;TE&quot; &quot;:&quot;# (t-codings) t-codings = &quot;트레일러&quot;| (transfer-extension [accept-params]) 키워드 &quot;트레일러&quot;가 있으면 &lt;a href=&quot;#section-3.6.1&quot;&gt;섹션 3.6.1에&lt;/a&gt; 정의 된대로 클라이언트가 청크 분할 전송 코딩에서 트레일러 필드를 허용 할 것임을 나타냅니다.. 이 키워드는 자체적으로 전송 코딩을 나타내지 않더라도 전송 코딩 값과 함께 사용하도록 예약되어 있습니다. TE : deflate TE : TE : 트레일러, deflate; q = 0.5 TE 헤더 필드는 즉시 연결에만 적용됩니다. 따라서 키워드는 반드시 연결 헤더 필드 내에 제공해야합니다 ( &lt;a href=&quot;#section-14.10&quot;&gt;섹션 14.10).&lt;/a&gt;TE가 HTTP / 1.1 메시지에 존재할 때마다). 서버는 TE 필드에 따라 다음 규칙을 사용하여 전송 코딩이 허용되는지 테스트합니다. 1. &quot;청크 된&quot;전송 코딩이 항상 허용됩니다. &quot;트레일러&quot;라는 키워드가 나열되면 클라이언트는 자신과 다운 스트림 클라이언트를 대신하여 청크 응답에서 트레일러 필드를 수락 할 의사가 있음을 나타냅니다. 의미가 주어진 경우, 클라이언트는 모든 다운 스트림 클라이언트가 전달 된 응답에서 트레일러 필드를 기꺼이 수락하거나 다운 스트림 수신자를 대신하여 응답을 버퍼링하려고 시도한다는 의미입니다. 참고 : HTTP / 1.도 1은 클라이언트가 전체 응답을 버퍼링 할 수 있도록 청크 응답의 크기를 제한하는 수단을 정의하지 않는다. 2. 테스트중인 전송 코딩이 TE 필드에 나열된 전송 코딩 중 하나 인 경우 q 값이 0이 아닌 한 허용됩니다.&lt;a href=&quot;#section-3.9&quot;&gt;섹션 3.9&lt;/a&gt; 에서 q 값이 0이면 &quot;허용되지 않습니다&quot;를 의미합니다. 3. 다중 전송 코딩이 허용되는 경우 0이 아닌 q 값이 가장 높은 허용 전송 코딩이 선호됩니다. &quot;청크 된&quot;전송 코딩의 q 값은 항상 1입니다. TE 필드 값이 비어 있거나 TE 필드가없는 경우 유일한 전송 코딩은 &quot;청크&quot;됩니다. 전송 코딩이없는 메시지는 항상 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="028b36d5d9b3506526bee546184ec9c68b1e3650" translate="yes" xml:space="preserve">
          <source>The TRACE method is used to invoke a remote, application-layer loop-
   back of the request message. The final recipient of the request
   SHOULD reflect the message received back to the client as the
   entity-body of a 200 (OK) response. The final recipient is either the 

   origin server or the first proxy or gateway to receive a Max-Forwards
   value of zero (0) in the request (see &lt;a href=&quot;#section-14.31&quot;&gt;section 14.31&lt;/a&gt;). A TRACE request
   MUST NOT include an entity.

   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information. The value of the Via header field (&lt;a href=&quot;#section-14.45&quot;&gt;section 14.45&lt;/a&gt;) is of
   particular interest, since it acts as a trace of the request chain.
   Use of the Max-Forwards header field allows the client to limit the
   length of the request chain, which is useful for testing a chain of
   proxies forwarding messages in an infinite loop.

   If the request is valid, the response SHOULD contain the entire
   request message in the entity-body, with a Content-Type of
   &quot;message/http&quot;. Responses to this method MUST NOT be cached.</source>
          <target state="translated">TRACE 메소드는 요청 메시지의 원격 애플리케이션 계층 루프백을 호출하는 데 사용됩니다. 요청의 최종 수신자는 200 (OK) 응답의 엔티티 본문으로 클라이언트에 수신 된 메시지를 반영해야한다. 최종 수신자는 원래 서버이거나 요청에서 Max-Forwards 값을 0으로받는 첫 번째 프록시 또는 게이트웨이입니다 &lt;a href=&quot;#section-14.31&quot;&gt;(14.31 절&lt;/a&gt; 참조 ). TRACE 요청은 엔티티를 포함해서는 안됩니다. TRACE를 사용하면 클라이언트는 요청 체인의 다른 쪽 끝에서 수신되는 내용을보고 해당 데이터를 테스트 또는 진단 정보로 사용할 수 있습니다. Via 헤더 필드의 값 ( &lt;a href=&quot;#section-14.45&quot;&gt;섹션 14.45&lt;/a&gt;)는 요청 체인의 추적 역할을하기 때문에 특히 중요합니다. Max-Forwards 헤더 필드를 사용하면 클라이언트가 요청 체인의 길이를 제한 할 수 있습니다. 이는 무한 루프에서 메시지를 전달하는 프록시 체인을 테스트하는 데 유용합니다. 요청이 유효하다면, 응답은 &quot;message / http&quot;의 Content-Type과 함께 엔티티 본문에 전체 요청 메시지를 포함해야한다. 이 방법에 대한 응답은 캐시해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6e96e28d353c4ec4abe9e9bc4e5f7f7754ad5448" translate="yes" xml:space="preserve">
          <source>The TRACE method requests a remote, application-level loop-back of
   the request message.  The final recipient of the request SHOULD
   reflect the message received, excluding some fields described below,
   back to the client as the message body of a 200 (OK) response with a
   Content-Type of &quot;message/http&quot; (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-8.3.1&quot;&gt;Section&amp;nbsp;8.3.1 of [RFC7230]&lt;/a&gt;).  The
   final recipient is either the origin server or the first server to
   receive a Max-Forwards value of zero (0) in the request
   (&lt;a href=&quot;#section-5.1.2&quot;&gt;Section 5.1.2&lt;/a&gt;). 

   A client MUST NOT generate header fields in a TRACE request
   containing sensitive data that might be disclosed by the response.
   For example, it would be foolish for a user agent to send stored user
   credentials [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;] or cookies [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;] in a TRACE request.  The
   final recipient of the request SHOULD exclude any request header
   fields that are likely to contain sensitive data when that recipient
   generates the response body.

   TRACE allows the client to see what is being received at the other
   end of the request chain and use that data for testing or diagnostic
   information.  The value of the Via header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;Section&amp;nbsp;5.7.1 of
   [RFC7230]&lt;/a&gt;) is of particular interest, since it acts as a trace of the
   request chain.  Use of the Max-Forwards header field allows the
   client to limit the length of the request chain, which is useful for
   testing a chain of proxies forwarding messages in an infinite loop.

   A client MUST NOT send a message body in a TRACE request.

   Responses to the TRACE method are not cacheable.</source>
          <target state="translated">TRACE 메소드는 요청 메시지의 원격 애플리케이션 레벨 루프백을 요청합니다. 메시지를 반영해야한다 요청의 최종 수신자는 일부 필드는 다시 &quot;메시지 / http&quot;의 Content-Type (와 응답 200 (OK)의 메시지 본문으로 클라이언트에, 아래에 설명 제외한받은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-8.3.1&quot;&gt;제 8.3.1 [RFC7230]&lt;/a&gt; ). 최종 수신자는 원래 서버이거나 요청에서 Max-Forwards 값을 영 (0)으로받는 첫 번째 서버입니다 ( &lt;a href=&quot;#section-5.1.2&quot;&gt;섹션 5.1.2&lt;/a&gt; ). 클라이언트는 응답에 의해 공개 될 수있는 민감한 데이터를 포함하는 TRACE 요청에서 헤더 필드를 생성해서는 안됩니다 (MUST NOT). 예를 들어, 사용자 에이전트가 저장된 사용자 자격 증명 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ] 또는 쿠키 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; 를 보내는 것은 어리석은 일입니다.]를 TRACE 요청에서 요청의 최종 수신자는 수신자가 응답 본문을 생성 할 때 민감한 데이터를 포함 할 가능성이있는 요청 헤더 필드를 제외해야합니다. TRACE를 사용하면 클라이언트는 요청 체인의 다른 쪽 끝에서 수신되는 내용을보고 해당 데이터를 테스트 또는 진단 정보로 사용할 수 있습니다. Via 헤더 필드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230]의 섹션 5.7.1)의&lt;/a&gt; 값은 요청 체인의 추적으로 작동하므로 특히 중요합니다. Max-Forwards 헤더 필드를 사용하면 클라이언트가 요청 체인의 길이를 제한 할 수 있습니다. 이는 무한 루프에서 메시지를 전달하는 프록시 체인을 테스트하는 데 유용합니다. 클라이언트는 TRACE 요청으로 메시지 본문을 보내서는 안됩니다. TRACE 메소드에 대한 응답은 캐시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="03897f64a14a74fe7d2358b82a3a5d08dc5e4c2f" translate="yes" xml:space="preserve">
          <source>The Trailer general field value indicates that the given set of
   header fields is present in the trailer of a message encoded with
   chunked transfer-coding.

       Trailer  = &quot;Trailer&quot; &quot;:&quot; 1#field-name

   An HTTP/1.1 message SHOULD include a Trailer header field in a
   message using chunked transfer-coding with a non-empty trailer. Doing
   so allows the recipient to know which header fields to expect in the
   trailer.

   If no Trailer header field is present, the trailer SHOULD NOT include
   any header fields. See &lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt; for restrictions on the use of
   trailer fields in a &quot;chunked&quot; transfer-coding.

   Message header fields listed in the Trailer header field MUST NOT
   include the following header fields:

      . Transfer-Encoding

      . Content-Length

      . Trailer</source>
          <target state="translated">예고편 일반 필드 값은 주어진 헤더 필드 세트가 청크 전송 코드로 인코딩 된 메시지 예고편에 있음을 나타냅니다. Trailer = &quot;Trailer&quot; &quot;:&quot;1 # field-name HTTP / 1.1 메시지는 비어 있지 않은 트레일러와 함께 청크 분할 전송 코딩을 사용하는 메시지에 트레일러 헤더 필드를 포함해야합니다. 그렇게하면 수신자는 예고편에서 어떤 헤더 필드를 기대할 수 있는지 알 수 있습니다. 트레일러 헤더 필드가 없으면 트레일러는 헤더 필드를 포함하지 않아야합니다. &quot;청크 (chunked)&quot;전송 코딩에서 트레일러 필드 사용에 대한 제한 사항은 &lt;a href=&quot;#section-3.6.1&quot;&gt;3.6.1 섹션을&lt;/a&gt; 참조하십시오 . 트레일러 헤더 필드에 나열된 메시지 헤더 필드에는 다음 헤더 필드가 포함되어서는 안됩니다. 전송 인코딩. 콘텐츠 길이.트레일러</target>
        </trans-unit>
        <trans-unit id="5a0c272967d0d482ca0381c6f18703875d017457" translate="yes" xml:space="preserve">
          <source>The Transfer-Encoding general-header field indicates what (if any)
   type of transformation has been applied to the message body in order
   to safely transfer it between the sender and the recipient. This
   differs from the content-coding in that the transfer-coding is a
   property of the message, not of the entity.

     Transfer-Encoding       = &quot;Transfer-Encoding&quot; &quot;:&quot; 1#transfer-coding

   Transfer-codings are defined in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;. An example is:

     Transfer-Encoding: chunked 

   If multiple encodings have been applied to an entity, the transfer-
   codings MUST be listed in the order in which they were applied.
   Additional information about the encoding parameters MAY be provided
   by other entity-header fields not defined by this specification.

   Many older HTTP/1.0 applications do not understand the Transfer-
   Encoding header.</source>
          <target state="translated">전송 인코딩 일반 헤더 필드는 발신자와 수신자간에 안전하게 전송하기 위해 메시지 본문에 적용된 변환 유형 (있는 경우)을 나타냅니다. 이는 전송 코딩이 엔티티가 아닌 메시지의 속성이라는 점에서 컨텐츠 코딩과 다릅니다. 전송 인코딩 = &quot;전송 인코딩&quot; &quot;:&quot;1 # 전송 인코딩 전송 코딩은 &lt;a href=&quot;#section-3.6&quot;&gt;3.6 절&lt;/a&gt; 에서 정의됩니다.. 예를 들면 다음과 같습니다. Transfer-Encoding : chunked 엔터티에 여러 인코딩이 적용된 경우 전송 코딩은 적용된 순서대로 나열되어야합니다. 인코딩 매개 변수에 대한 추가 정보는이 사양에서 정의하지 않은 다른 엔터티 헤더 필드에서 제공 될 수 있습니다. 많은 이전 HTTP / 1.0 응용 프로그램은 Transfer-Encoding 헤더를 이해하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="2b9c17fcff0e77e15eb4e1a1d785371389cb348c" translate="yes" xml:space="preserve">
          <source>The Transfer-Encoding header field lists the transfer coding names
   corresponding to the sequence of transfer codings that have been (or
   will be) applied to the payload body in order to form the message
   body.  Transfer codings are defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;.

     Transfer-Encoding = 1#transfer-coding

   Transfer-Encoding is analogous to the Content-Transfer-Encoding field
   of MIME, which was designed to enable safe transport of binary data
   over a 7-bit transport service (&lt;a href=&quot;https://tools.ietf.org/html/rfc2045#section-6&quot;&gt;[RFC2045], Section&amp;nbsp;6&lt;/a&gt;).  However, safe
   transport has a different focus for an 8bit-clean transfer protocol.
   In HTTP's case, Transfer-Encoding is primarily intended to accurately
   delimit a dynamically generated payload and to distinguish payload
   encodings that are only applied for transport efficiency or security
   from those that are characteristics of the selected resource. 

   A recipient MUST be able to parse the chunked transfer coding
   (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;) because it plays a crucial role in framing messages
   when the payload body size is not known in advance.  A sender MUST
   NOT apply chunked more than once to a message body (i.e., chunking an
   already chunked message is not allowed).  If any transfer coding
   other than chunked is applied to a request payload body, the sender
   MUST apply chunked as the final transfer coding to ensure that the
   message is properly framed.  If any transfer coding other than
   chunked is applied to a response payload body, the sender MUST either
   apply chunked as the final transfer coding or terminate the message
   by closing the connection.

   For example,

     Transfer-Encoding: gzip, chunked

   indicates that the payload body has been compressed using the gzip
   coding and then chunked using the chunked coding while forming the
   message body.

   Unlike Content-Encoding (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;Section&amp;nbsp;3.1.2.1 of [RFC7231]&lt;/a&gt;),
   Transfer-Encoding is a property of the message, not of the
   representation, and any recipient along the request/response chain
   MAY decode the received transfer coding(s) or apply additional
   transfer coding(s) to the message body, assuming that corresponding
   changes are made to the Transfer-Encoding field-value.  Additional
   information about the encoding parameters can be provided by other
   header fields not defined by this specification.

   Transfer-Encoding MAY be sent in a response to a HEAD request or in a
   304 (Not Modified) response (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7232]&lt;/a&gt;) to a GET
   request, neither of which includes a message body, to indicate that
   the origin server would have applied a transfer coding to the message
   body if the request had been an unconditional GET.  This indication
   is not required, however, because any recipient on the response chain
   (including the origin server) can remove transfer codings when they
   are not needed.

   A server MUST NOT send a Transfer-Encoding header field in any
   response with a status code of 1xx (Informational) or 204 (No
   Content).  A server MUST NOT send a Transfer-Encoding header field in
   any 2xx (Successful) response to a CONNECT request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of
   [RFC7231]&lt;/a&gt;).

   Transfer-Encoding was added in HTTP/1.1.  It is generally assumed
   that implementations advertising only HTTP/1.0 support will not
   understand how to process a transfer-encoded payload.  A client MUST
   NOT send a request containing Transfer-Encoding unless it knows the 

   server will handle HTTP/1.1 (or later) requests; such knowledge might
   be in the form of specific user configuration or by remembering the
   version of a prior received response.  A server MUST NOT send a
   response containing Transfer-Encoding unless the corresponding
   request indicates HTTP/1.1 (or later).

   A server that receives a request message with a transfer coding it
   does not understand SHOULD respond with 501 (Not Implemented).</source>
          <target state="translated">Transfer-Encoding 헤더 필드는 메시지 본문을 형성하기 위해 페이로드 본문에 적용되었거나 적용되는 전송 코딩 시퀀스에 해당하는 전송 코딩 이름을 나열합니다. 전송 코딩은 &lt;a href=&quot;#section-4&quot;&gt;섹션 4에&lt;/a&gt; 정의되어 있습니다. Transfer-Encoding = 1 # transfer-coding Transfer-Encoding은 7 비트 전송 서비스를 통해 이진 데이터를 안전하게 전송하도록 설계된 MIME의 Content-Transfer-Encoding 필드와 유사합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2045#section-6&quot;&gt;[RFC2045], 섹션 6&lt;/a&gt;). 그러나 안전한 전송에는 8 비트 클린 전송 프로토콜에 대한 초점이 다릅니다. HTTP의 경우, Transfer-Encoding은 기본적으로 동적으로 생성 된 페이로드를 정확하게 구분하고 전송 효율성 또는 보안에만 적용되는 페이로드 인코딩을 선택된 리소스의 특성과 구별하기위한 것입니다. 수신자는 청크 전송 코드를 구문 분석 할 수 있어야합니다 ( &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt;)는 페이로드 본문 크기를 미리 알 수 없을 때 메시지 프레이밍에 결정적인 역할을하기 때문입니다. 발신자는 메시지 본문에 두 번 이상 청크를 적용해서는 안됩니다 (즉, 이미 청크 된 메시지 청크는 허용되지 않음). 청크 이외의 전송 코딩이 요청 페이로드 본문에 적용되는 경우, 송신자는 메시지가 올바르게 프레임되도록하기 위해 최종 전송 코딩으로 청크를 적용해야합니다. 청크 이외의 전송 코딩이 응답 페이로드 본문에 적용되는 경우, 송신자는 최종 전송 코딩으로 청크를 적용하거나 연결을 닫아 메시지를 종료해야합니다. 예를 들어, Transfer-Encoding : gzip, chunked는 페이로드 본문이 gzip 코딩을 사용하여 압축 된 다음 메시지 본문을 형성하는 동안 청크 된 코딩을 사용하여 청크되었음을 나타냅니다.콘텐츠 인코딩과 달리&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;[RFC7231]의 3.1.2.1 항에서&lt;/a&gt; , Transfer-Encoding은 표현이 아닌 메시지의 속성이며, 요청 / 응답 체인을 따르는 수신자는 수신 된 전송 코딩을 디코딩하거나 추가 전송 코딩을 적용 할 수 있습니다. )는 전송 인코딩 필드 값에 해당 변경이 있다고 가정하고 메시지 본문에 적용됩니다. 인코딩 매개 변수에 대한 추가 정보는이 사양에서 정의하지 않은 다른 헤더 필드에서 제공 할 수 있습니다. 전송 인코딩은 HEAD 요청에 대한 응답 또는 304 (수정되지 않음) 응답으로 전송 될 수 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;[RFC7232]의 4.1 항&lt;/a&gt; ))는 요청이 무조건적인 GET 인 경우, 오리진 서버가 메시지 본문에 전송 코딩을 적용했음을 표시하기 위해 메시지 본문을 포함하지 않는 GET 요청에 대해. 그러나 응답 체인 (원본 서버 포함)의 모든 수신자가 필요하지 않은 전송 코딩을 제거 할 수 있으므로이 표시는 필요하지 않습니다. 서버는 상태 코드가 1xx (정보) 또는 204 (콘텐츠 없음) 인 응답으로 Transfer-Encoding 헤더 필드를 보내서는 안됩니다. 서버는 2xx (성공) 응답의 Transfer-Encoding 헤더 필드를 CONNECT 요청에 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;보내서는 안됩니다 ([RFC7231]의 4.3.6 절).&lt;/a&gt;). 전송 인코딩이 HTTP / 1.1에 추가되었습니다. 일반적으로 HTTP / 1.0 지원 만 광고하는 구현은 전송 인코딩 된 페이로드를 처리하는 방법을 이해하지 못한다고 가정합니다. 클라이언트가 서버가 HTTP / 1.1 (이상) 요청을 처리 할 것이라는 것을 알지 않는 한, 클라이언트는 Transfer-Encoding을 포함하는 요청을 보내서는 안됩니다. 이러한 지식은 특정 사용자 구성의 형태이거나 이전에 수신 된 응답의 버전을 기억함으로써 이루어질 수 있습니다. 해당 요청이 HTTP / 1.1 이상을 나타내지 않는 한 서버는 Transfer-Encoding을 포함하는 응답을 보내서는 안됩니다. 전송 코딩으로 요청 메시지를 수신하는 서버는 501 (구현되지 않음)로 응답해야한다는 것을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="1c8b20b0d07b7680a3c0f95ac8ec3b25b3de332b" translate="yes" xml:space="preserve">
          <source>The Transport Layer Security (TLS) Protocol Version 1.2</source>
          <target state="translated">TLS (Transport Layer Security) 프로토콜 버전 1.2</target>
        </trans-unit>
        <trans-unit id="12fd383ebe402c54f473646772c58d3e6163c837" translate="yes" xml:space="preserve">
          <source>The Transport Layer Security (TLS) Protocol Version 1.3</source>
          <target state="translated">TLS (Transport Layer Security) 프로토콜 버전 1.3</target>
        </trans-unit>
        <trans-unit id="8a56da9b77b531c4fafce5d057fc066caa86cf4f" translate="yes" xml:space="preserve">
          <source>The UA string of Firefox itself is broken down into four components:</source>
          <target state="translated">Firefox 자체의 UA 문자열은 다음과 같은 네 가지 구성 요소로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="f72374d140af175240e14a12a7f961729a13b2d2" translate="yes" xml:space="preserve">
          <source>The UNLOCK method removes the lock identified by the lock token in
   the Lock-Token request header.  The Request-URI MUST identify a
   resource within the scope of the lock.

   Note that use of the Lock-Token header to provide the lock token is
   not consistent with other state-changing methods, which all require
   an If header with the lock token.  Thus, the If header is not needed
   to provide the lock token.  Naturally, when the If header is present,
   it has its normal meaning as a conditional header.

   For a successful response to this method, the server MUST delete the
   lock entirely.

   If all resources that have been locked under the submitted lock token
   cannot be unlocked, then the UNLOCK request MUST fail.

   A successful response to an UNLOCK method does not mean that the
   resource is necessarily unlocked.  It means that the specific lock
   corresponding to the specified token no longer exists.

   Any DAV-compliant resource that supports the LOCK method MUST support
   the UNLOCK method.

   This method is idempotent, but not safe (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;Section&amp;nbsp;9.1 of
   [RFC2616]&lt;/a&gt;).  Responses to this method MUST NOT be cached.</source>
          <target state="translated">UNLOCK 메소드는 잠금 토큰 요청 헤더에서 잠금 토큰으로 식별 된 잠금을 제거합니다. Request-URI는 잠금 범위 내에서 리소스를 식별해야합니다. 잠금 토큰을 제공하기 위해 잠금 토큰 헤더를 사용하는 것은 잠금 상태가있는 If 헤더가 필요한 다른 상태 변경 방법과 일치하지 않습니다. 따라서 If 헤더는 잠금 토큰을 제공하는 데 필요하지 않습니다. 당연히 If 헤더가 있으면 조건부 헤더로서 정상적인 의미를 갖습니다. 이 방법에 성공적으로 응답하려면 서버는 반드시 잠금을 완전히 삭제해야합니다. 제출 된 잠금 토큰으로 잠긴 모든 자원을 잠금 해제 할 수 없으면 UNLOCK 요청이 실패해야합니다. UNLOCK 방법에 대한 응답이 리소스가 반드시 잠금 해제되어 있다는 것을 의미하지는 않습니다.지정된 토큰에 해당하는 특정 잠금이 더 이상 존재하지 않음을 의미합니다. LOCK 방법을 지원하는 DAV 호환 리소스는 반드시 UNLOCK 방법을 지원해야합니다. 이 방법은 dem 등이지만 안전하지는 않습니다 (참조&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-9.1&quot;&gt;[RFC2616] 섹션 9.1&lt;/a&gt; ). 이 방법에 대한 응답은 캐시해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b0025b4b69a4ce00bf003d08c44025493d147db8" translate="yes" xml:space="preserve">
          <source>The URI (absolute or relative) must be enclosed between &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">URI (절대 또는 상대)는 &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; 사이에 포함되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7dc195e95f3f78e1ec1e89ef97a6a85b571c15d4" translate="yes" xml:space="preserve">
          <source>The URI of the document in which the violation occurred.</source>
          <target state="translated">위반이 발생한 문서의 URI입니다.</target>
        </trans-unit>
        <trans-unit id="a00094afe4ee340f38859ca45715a9f8d4fda91e" translate="yes" xml:space="preserve">
          <source>The URI of the resource that was blocked from loading by the Content Security Policy. If the blocked URI is from a different origin than the &lt;code&gt;document-uri&lt;/code&gt;, then the blocked URI is truncated to contain just the scheme, host, and port.</source>
          <target state="translated">콘텐츠 보안 정책에 의해로드가 차단 된 리소스의 URI입니다. 차단 된 URI가 &lt;code&gt;document-uri&lt;/code&gt; 와 다른 출처에서 온 경우 차단 된 URI는 체계, 호스트 및 포트만 포함하도록 잘립니다.</target>
        </trans-unit>
        <trans-unit id="ceb66755626c081ee38ccbccf8e082e6464687a3" translate="yes" xml:space="preserve">
          <source>The URI of the resource that was blocked from loading by the Content Security Policy. If the blocked URI is from a different origin than the document-uri, then the blocked URI is truncated to contain just the scheme, host, and port.</source>
          <target state="translated">콘텐츠 보안 정책에 의해로드가 차단 된 리소스의 URI입니다. 차단 된 URI가 document-uri와 다른 출처에서 온 경우 차단 된 URI는 체계, 호스트 및 포트만 포함하도록 잘립니다.</target>
        </trans-unit>
        <trans-unit id="20d9b67c973fb9378d4e9a9893dce633fc72be6a" translate="yes" xml:space="preserve">
          <source>The URI reference, must be enclosed between &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">URI 참조는 &lt;code&gt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&lt;/code&gt; 로 묶어야합니다 .</target>
        </trans-unit>
        <trans-unit id="ab6860a88c4f5fa569a9d2df89c6b4183b5b6406" translate="yes" xml:space="preserve">
          <source>The URI requested by the client is longer than the server is willing to interpret.</source>
          <target state="translated">클라이언트가 요청한 URI가 서버가 해석하려는 것보다 깁니다.</target>
        </trans-unit>
        <trans-unit id="3c5fb5f7c661d221d889ac05db6f82fe9c0205e8" translate="yes" xml:space="preserve">
          <source>The URI where the user agent should report &lt;code&gt;Expect-CT&lt;/code&gt; failures.</source>
          <target state="translated">사용자 에이전트가 &lt;code&gt;Expect-CT&lt;/code&gt; 실패를 보고해야하는 URI 입니다.</target>
        </trans-unit>
        <trans-unit id="2631108f4b94ab9a2cb00980acaf8c1f780ff904" translate="yes" xml:space="preserve">
          <source>The URL &lt;code&gt;http://example.com/&lt;/code&gt; will be redirected to &lt;code&gt;http://www.example.com/&lt;/code&gt;, as will any files or directories under it (&lt;code&gt;http://example.com/index.html&lt;/code&gt; will be redirected to &lt;code&gt;http://www.example.com/index.html&lt;/code&gt;)</source>
          <target state="translated">URL &lt;code&gt;http://example.com/&lt;/code&gt; 은 &lt;code&gt;http://www.example.com/&lt;/code&gt; 으로 리디렉션 되며 그 아래 파일이나 디렉토리 ( &lt;code&gt;http://example.com/index.html&lt;/code&gt; ) 는 &lt;code&gt;http://www.example.com/index.html&lt;/code&gt; 로 리디렉션됩니다 : //www.example.com/index.html )</target>
        </trans-unit>
        <trans-unit id="5efef24fc6384dd41fb192a1bf80a33651bde15a" translate="yes" xml:space="preserve">
          <source>The URL &lt;code&gt;https://example.com/&lt;/code&gt; will be redirected to &lt;code&gt;https://www.example.com/&lt;/code&gt;, as will any files or directories under it (&lt;code&gt;https://example.com/some-page&lt;/code&gt; will be redirected to &lt;code&gt;https://www.example.com/some-page&lt;/code&gt;)</source>
          <target state="translated">의 URL &lt;code&gt;https://example.com/&lt;/code&gt; 는 로 리디렉션됩니다 &lt;code&gt;https://www.example.com/&lt;/code&gt; 그 아래에있는 모든 파일이나 디렉토리 (되므로, &lt;code&gt;https://example.com/some-page&lt;/code&gt; 가 로 리디렉션됩니다 &lt;code&gt;https://www.example.com/some-page&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ab68e1cdf6b3b2fc5d165ae5d131fcb809d37323" translate="yes" xml:space="preserve">
          <source>The URL being accessed. The path and query components of &lt;code&gt;https://&lt;/code&gt; URLs are stripped. In Chrome (versions 52 to 73), you can disable this by setting &lt;code&gt;PacHttpsUrlStrippingEnabled&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; in policy or by launching with the &lt;code&gt;--unsafe-pac-url&lt;/code&gt; command-line flag (in Chrome 74, only the flag works, and from 75 onward, there is no way to disable path-stripping; as of Chrome 81, path-stripping does not apply to HTTP URLs, but there is interest in changing this behavior to match HTTPS); in Firefox, the preference is &lt;code&gt;network.proxy.autoconfig_url.include_path&lt;/code&gt;.</source>
          <target state="translated">액세스중인 URL입니다. &lt;code&gt;https://&lt;/code&gt; URL 의 경로 및 쿼리 구성 요소 가 제거됩니다. Chrome (버전 52 ~ 73)에서는 정책에서 &lt;code&gt;PacHttpsUrlStrippingEnabled&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정 하거나 &lt;code&gt;--unsafe-pac-url&lt;/code&gt; 명령 줄 플래그를 사용하여 실행 하여이 기능 을 비활성화 할 수 있습니다 (Chrome 74에서는 플래그 만 작동하고 75부터는 , 경로 분리를 비활성화 할 수있는 방법이 없습니다. Chrome 81부터 경로 분리는 HTTP URL에 적용되지 않지만 HTTPS와 일치하도록이 동작을 변경하는 데 관심이 있습니다. Firefox에서 기본 설정은 &lt;code&gt;network.proxy.autoconfig_url.include_path&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="328f9c5a6f56c9b38378bbbf4afce0ee4c1c87e1" translate="yes" xml:space="preserve">
          <source>The URL being accessed. The path and query components of &lt;code&gt;https://&lt;/code&gt; URLs are stripped. In Chrome, you can disable this by setting &lt;code&gt;PacHttpsUrlStrippingEnabled&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;, in Firefox the preference is &lt;code&gt;network.proxy.autoconfig_url.include_path&lt;/code&gt;.</source>
          <target state="translated">액세스중인 URL입니다. &lt;code&gt;https://&lt;/code&gt; URL 의 경로 및 쿼리 구성 요소 가 제거되었습니다. Chrome에서는 &lt;code&gt;PacHttpsUrlStrippingEnabled&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정 하여 이를 비활성화 할 수 있습니다 . Firefox에서는 환경 설정이 &lt;code&gt;network.proxy.autoconfig_url.include_path&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1aac5516d3c0193c8b37aa0f0d853eb420d0c8fa" translate="yes" xml:space="preserve">
          <source>The URL of the requested resource has been changed permanently. The new URL is given in the response.</source>
          <target state="translated">요청 된 리소스의 URL이 영구적으로 변경되었습니다. 새 URL이 응답에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="0186dd865b14f3a2fc2d2ec7512e14fe948697fc" translate="yes" xml:space="preserve">
          <source>The Upgrade general-header allows the client to specify what
   additional communication protocols it supports and would like to use
   if the server finds it appropriate to switch protocols. The server
   MUST use the Upgrade header field within a 101 (Switching Protocols)
   response to indicate which protocol(s) are being switched.

       Upgrade        = &quot;Upgrade&quot; &quot;:&quot; 1#product

   For example,

       Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11

   The Upgrade header field is intended to provide a simple mechanism
   for transition from HTTP/1.1 to some other, incompatible protocol. It
   does so by allowing the client to advertise its desire to use another
   protocol, such as a later version of HTTP with a higher major version
   number, even though the current request has been made using HTTP/1.1.
   This eases the difficult transition between incompatible protocols by
   allowing the client to initiate a request in the more commonly
   supported protocol while indicating to the server that it would like
   to use a &quot;better&quot; protocol if available (where &quot;better&quot; is determined
   by the server, possibly according to the nature of the method and/or
   resource being requested).

   The Upgrade header field only applies to switching application-layer
   protocols upon the existing transport-layer connection. Upgrade
   cannot be used to insist on a protocol change; its acceptance and use
   by the server is optional. The capabilities and nature of the
   application-layer communication after the protocol change is entirely
   dependent upon the new protocol chosen, although the first action
   after changing the protocol MUST be a response to the initial HTTP
   request containing the Upgrade header field.

   The Upgrade header field only applies to the immediate connection.
   Therefore, the upgrade keyword MUST be supplied within a Connection
   header field (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;) whenever Upgrade is present in an
   HTTP/1.1 message. 

   The Upgrade header field cannot be used to indicate a switch to a
   protocol on a different connection. For that purpose, it is more
   appropriate to use a 301, 302, 303, or 305 redirection response.

   This specification only defines the protocol name &quot;HTTP&quot; for use by
   the family of Hypertext Transfer Protocols, as defined by the HTTP
   version rules of &lt;a href=&quot;#section-3.1&quot;&gt;section 3.1&lt;/a&gt; and future updates to this
   specification. Any token can be used as a protocol name; however, it
   will only be useful if both the client and server associate the name
   with the same protocol.</source>
          <target state="translated">업그레이드 일반 헤더를 사용하면 클라이언트가 지원하는 추가 통신 프로토콜을 지정하고 서버가 프로토콜 전환에 적합한 것으로 판단 할 경우 사용할 프로토콜을 지정할 수 있습니다. 서버는 101 (Switching Protocols) 응답 내에서 Upgrade header 필드를 사용하여 전환중인 프로토콜을 표시해야합니다. Upgrade = &quot;Upgrade&quot; &quot;:&quot;1 # product 예 : Upgrade : HTTP / 2.0, SHTTP / 1.3, IRC / 6.9, RTA / x11 Upgrade 헤더 필드는 HTTP / 1.1에서 일부로의 전환을위한 간단한 메커니즘을 제공하기위한 것입니다. 다른 호환되지 않는 프로토콜. 현재 요청이 HTTP / 1.1을 사용하여 이루어 졌더라도 클라이언트가 주 버전 번호가 더 높은 이후 버전의 HTTP와 같은 다른 프로토콜을 사용하려는 의사를 알릴 수 있습니다.이렇게하면 클라이언트가 더 일반적으로 지원되는 프로토콜로 요청을 시작하는 동시에 서버에 &quot;더 나은&quot;프로토콜을 사용하고 싶다는 표시를함으로써 (예 : &quot;더 나은&quot;서버에 의해 결정됨) 호환되지 않는 프로토콜 간 어려운 전환이 쉬워집니다. 요청 된 방법 및 / 또는 자원의 특성에 따라). 업그레이드 헤더 필드는 기존 전송 계층 연결시 응용 프로그램 계층 프로토콜 전환에만 적용됩니다. 프로토콜 변경을 주장하는 데 업그레이드를 사용할 수 없습니다. 서버에 의한 승인 및 사용은 선택 사항입니다. 프로토콜 변경 후 애플리케이션 계층 통신의 기능과 특성은 전적으로 선택한 새로운 프로토콜에 따라 달라집니다.프로토콜을 변경 한 후 첫 번째 조치는 반드시 업그레이드 헤더 필드를 포함하는 초기 HTTP 요청에 대한 응답이어야합니다. 업그레이드 헤더 필드는 즉시 연결에만 적용됩니다. 따라서 업그레이드 키워드는 반드시 연결 헤더 필드 (&lt;a href=&quot;#section-14.10&quot;&gt;&lt;/a&gt;HTTP / 1.1 메시지에 업그레이드가있을 때마다 14.10 절 . 업그레이드 헤더 필드는 다른 연결에서 프로토콜로의 전환을 나타내는 데 사용할 수 없습니다. 이를 위해서는 301, 302, 303 또는 305 리디렉션 응답을 사용하는 것이 더 적합합니다. 이 사양은 &lt;a href=&quot;#section-3.1&quot;&gt;섹션 3.1&lt;/a&gt; 의 HTTP 버전 규칙 과이 사양에 대한 향후 업데이트에 정의 된 하이퍼 텍스트 전송 프로토콜 제품군에서 사용할 프로토콜 이름 &quot;HTTP&quot;만 정의합니다 . 프로토콜 이름으로 모든 토큰을 사용할 수 있습니다. 그러나 클라이언트와 서버가 이름을 동일한 프로토콜과 연관시키는 경우에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="956c514c873571fd13c43a02eba30c85c739c04b" translate="yes" xml:space="preserve">
          <source>The User-Agent (&lt;a href=&quot;#section-5.5.3&quot;&gt;Section 5.5.3&lt;/a&gt;), Via (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;Section&amp;nbsp;5.7.1 of [RFC7230]&lt;/a&gt;), and
   Server (&lt;a href=&quot;#section-7.4.2&quot;&gt;Section 7.4.2&lt;/a&gt;) header fields often reveal information about
   the respective sender's software systems.  In theory, this can make
   it easier for an attacker to exploit known security holes; in
   practice, attackers tend to try all potential holes regardless of the
   apparent software versions being used.

   Proxies that serve as a portal through a network firewall ought to
   take special precautions regarding the transfer of header information
   that might identify hosts behind the firewall.  The Via header field
   allows intermediaries to replace sensitive machine names with
   pseudonyms.</source>
          <target state="translated">User-Agent ( &lt;a href=&quot;#section-5.5.3&quot;&gt;섹션 5.5.3&lt;/a&gt; ), Via ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.7.1&quot;&gt;[RFC7230]의 섹션 5.7.1&lt;/a&gt; ) 및 Server ( &lt;a href=&quot;#section-7.4.2&quot;&gt;섹션 7.4.2&lt;/a&gt; ) 헤더 필드는 종종 각 발신자의 소프트웨어 시스템에 대한 정보를 표시합니다. 이론적으로 이것은 공격자가 알려진 보안 취약점을 쉽게 악용 할 수 있도록합니다. 실제로 공격자는 사용중인 명백한 소프트웨어 버전에 관계없이 모든 잠재적 인 허점을 시도하는 경향이 있습니다. 네트워크 방화벽을 통해 포털 역할을하는 프록시는 방화벽 뒤의 호스트를 식별 할 수있는 헤더 정보 전송과 관련하여 특별한 예방 조치를 취해야합니다. Via 헤더 필드를 통해 중개자는 민감한 기계 이름을 가명으로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9bc48b6946945b170102521a95dcc585d202997" translate="yes" xml:space="preserve">
          <source>The User-Agent header</source>
          <target state="translated">User-Agent 헤더</target>
        </trans-unit>
        <trans-unit id="37ab671dc85571491b078190122b8c7014630aae" translate="yes" xml:space="preserve">
          <source>The User-Agent request-header field contains information about the
   user agent originating the request. This is for statistical purposes,
   the tracing of protocol violations, and automated recognition of user
   agents for the sake of tailoring responses to avoid particular user
   agent limitations. User agents SHOULD include this field with
   requests. The field can contain multiple product tokens (&lt;a href=&quot;#section-3.8&quot;&gt;section 3.8&lt;/a&gt;)
   and comments identifying the agent and any subproducts which form a
   significant part of the user agent. By convention, the product tokens
   are listed in order of their significance for identifying the
   application.

       User-Agent     = &quot;User-Agent&quot; &quot;:&quot; 1*( product | comment )

   Example:

       User-Agent: CERN-LineMode/2.15 libwww/2.17b3</source>
          <target state="translated">User-Agent request-header 필드는 요청을 시작한 사용자 에이전트에 대한 정보를 포함합니다. 이는 특정 사용자 에이전트 제한을 피하기 위해 응답을 조정하기 위해 통계 목적, 프로토콜 위반 추적 및 사용자 에이전트 자동 인식입니다. 사용자 에이전트는이 필드를 요청과 함께 포함해야합니다. 이 필드에는 여러 제품 토큰 ( &lt;a href=&quot;#section-3.8&quot;&gt;섹션 3.8&lt;/a&gt; )과 에이전트 및 사용자 에이전트의 중요한 부분을 구성하는 하위 제품을 식별하는 주석 이 포함될 수 있습니다 . 일반적으로 제품 토큰은 응용 프로그램을 식별하는 데 중요한 순서대로 나열됩니다. User-Agent = &quot;User-Agent&quot; &quot;:&quot;1 * (product | comment) 예 : User-Agent : CERN-LineMode / 2.15 libwww / 2.17b3</target>
        </trans-unit>
        <trans-unit id="0145d328878d74d7d6f76ae8e632bd27f666b2da" translate="yes" xml:space="preserve">
          <source>The Vary field value indicates the set of request-header fields that
   fully determines, while the response is fresh, whether a cache is
   permitted to use the response to reply to a subsequent request
   without revalidation. For uncacheable or stale responses, the Vary
   field value advises the user agent about the criteria that were used
   to select the representation. A Vary field value of &quot;*&quot; implies that
   a cache cannot determine from the request headers of a subsequent
   request whether this response is the appropriate representation. See
   &lt;a href=&quot;#section-13.6&quot;&gt;section 13.6&lt;/a&gt; for use of the Vary header field by caches.

       Vary  = &quot;Vary&quot; &quot;:&quot; ( &quot;*&quot; | 1#field-name )

   An HTTP/1.1 server SHOULD include a Vary header field with any
   cacheable response that is subject to server-driven negotiation.
   Doing so allows a cache to properly interpret future requests on that
   resource and informs the user agent about the presence of negotiation 

   on that resource. A server MAY include a Vary header field with a
   non-cacheable response that is subject to server-driven negotiation,
   since this might provide the user agent with useful information about
   the dimensions over which the response varies at the time of the
   response.

   A Vary field value consisting of a list of field-names signals that
   the representation selected for the response is based on a selection
   algorithm which considers ONLY the listed request-header field values
   in selecting the most appropriate representation. A cache MAY assume
   that the same selection will be made for future requests with the
   same values for the listed field names, for the duration of time for
   which the response is fresh.

   The field-names given are not limited to the set of standard
   request-header fields defined by this specification. Field names are
   case-insensitive.

   A Vary field value of &quot;*&quot; signals that unspecified parameters not
   limited to the request-headers (e.g., the network address of the
   client), play a role in the selection of the response representation.
   The &quot;*&quot; value MUST NOT be generated by a proxy server; it may only be
   generated by an origin server.</source>
          <target state="translated">Vary 필드 값은 응답이 최신 인 동안 캐시가 응답을 사용하여 재확인없이 후속 요청에 응답 할 수 있는지 여부를 완전히 결정하는 요청 헤더 필드 세트를 나타냅니다. 캐시 할 수 없거나 부실한 응답의 경우 Vary 필드 값은 사용자 에이전트에게 표시를 선택하는 데 사용 된 기준을 알려줍니다. Vary 필드 값 &quot;*&quot;는 캐시가 후속 요청의 요청 헤더에서이 응답이 적절한 표현인지 확인할 수 없음을 의미합니다. &lt;a href=&quot;#section-13.6&quot;&gt;섹션 13.6&lt;/a&gt; 참조 Vary 헤더 필드를 캐시에 사용합니다. Vary = &quot;Vary&quot; &quot;:&quot;( &quot;*&quot;| 1 # field-name) HTTP / 1.1 서버는 서버 주도 협상의 대상이되는 캐시 가능한 응답을 갖는 Vary 헤더 필드를 포함해야합니다. 이렇게하면 캐시가 해당 리소스에 대한 향후 요청을 올바르게 해석하고 해당 리소스에 대한 협상이 있는지 사용자 에이전트에 알립니다. 서버는 서버 중심 협상의 대상이되는 캐시 불가능한 응답을 가진 Vary 헤더 필드를 포함 할 수 있습니다. 이는 응답시 응답이 변하는 차원에 대한 유용한 정보를 사용자 에이전트에 제공 할 수 있기 때문입니다.필드 이름 목록으로 구성된 Vary 필드 값은 응답에 대해 선택된 표현이 가장 적합한 표현을 선택할 때 나열된 요청 헤더 필드 값만 고려하는 선택 알고리즘을 기반으로한다는 신호를 보냅니다. 캐시는 응답이 새로운 시간 동안, 나열된 필드 이름에 대해 동일한 값을 갖는 미래 요청에 대해 동일한 선택이 이루어질 것이라고 가정 할 수있다. 제공된 필드 이름은이 사양에서 정의한 표준 요청 헤더 필드 집합으로 제한되지 않습니다. 필드 이름은 대소 문자를 구분하지 않습니다. &quot;-&quot;신호의 가변 필드 값은 요청 헤더 (예를 들어, 클라이언트의 네트워크 주소)로 제한되지 않은 지정되지 않은 파라미터가 응답 표현의 선택에 역할을한다는 것을 나타낸다. &quot;* &quot;값은 프록시 서버에 의해 생성되어서는 안되며 오리진 서버에 의해서만 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4eba333151816238416f3ddeba94021b6342f57" translate="yes" xml:space="preserve">
          <source>The Vary response header</source>
          <target state="translated">Vary 응답 헤더</target>
        </trans-unit>
        <trans-unit id="46218eb322ca25f8d1c7432adb208448ace419bd" translate="yes" xml:space="preserve">
          <source>The Via general-header field MUST be used by gateways and proxies to
   indicate the intermediate protocols and recipients between the user
   agent and the server on requests, and between the origin server and
   the client on responses. It is analogous to the &quot;Received&quot; field of
   &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] and is intended to be used for tracking message forwards,
   avoiding request loops, and identifying the protocol capabilities of
   all senders along the request/response chain.

      Via =  &quot;Via&quot; &quot;:&quot; 1#( received-protocol received-by [ comment ] )
      received-protocol = [ protocol-name &quot;/&quot; ] protocol-version
      protocol-name     = token
      protocol-version  = token
      received-by       = ( host [ &quot;:&quot; port ] ) | pseudonym
      pseudonym         = token

   The received-protocol indicates the protocol version of the message
   received by the server or client along each segment of the
   request/response chain. The received-protocol version is appended to
   the Via field value when the message is forwarded so that information
   about the protocol capabilities of upstream applications remains
   visible to all recipients. 

   The protocol-name is optional if and only if it would be &quot;HTTP&quot;. The
   received-by field is normally the host and optional port number of a
   recipient server or client that subsequently forwarded the message.
   However, if the real host is considered to be sensitive information,
   it MAY be replaced by a pseudonym. If the port is not given, it MAY
   be assumed to be the default port of the received-protocol.

   Multiple Via field values represents each proxy or gateway that has
   forwarded the message. Each recipient MUST append its information
   such that the end result is ordered according to the sequence of
   forwarding applications.

   Comments MAY be used in the Via header field to identify the software
   of the recipient proxy or gateway, analogous to the User-Agent and
   Server header fields. However, all comments in the Via field are
   optional and MAY be removed by any recipient prior to forwarding the
   message.

   For example, a request message could be sent from an HTTP/1.0 user
   agent to an internal proxy code-named &quot;fred&quot;, which uses HTTP/1.1 to
   forward the request to a public proxy at nowhere.com, which completes
   the request by forwarding it to the origin server at www.ics.uci.edu.
   The request received by www.ics.uci.edu would then have the following
   Via header field:

       Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)

   Proxies and gateways used as a portal through a network firewall
   SHOULD NOT, by default, forward the names and ports of hosts within
   the firewall region. This information SHOULD only be propagated if
   explicitly enabled. If not enabled, the received-by host of any host
   behind the firewall SHOULD be replaced by an appropriate pseudonym
   for that host.

   For organizations that have strong privacy requirements for hiding
   internal structures, a proxy MAY combine an ordered subsequence of
   Via header field entries with identical received-protocol values into
   a single such entry. For example,

       Via: 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy

        could be collapsed to

       Via: 1.0 ricky, 1.1 mertz, 1.0 lucy 

   Applications SHOULD NOT combine multiple entries unless they are all
   under the same organizational control and the hosts have already been
   replaced by pseudonyms. Applications MUST NOT combine entries which
   have different received-protocol values.</source>
          <target state="translated">Via General-header 필드는 게이트웨이와 프록시가 요청에 따라 사용자 에이전트와 서버 사이, 그리고 응답시 오리진 서버와 클라이언트 사이에 중간 프로토콜과 수신자를 나타내야합니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; 의 &quot;Received&quot;필드와 유사합니다. [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] 메시지 전달을 추적하고 요청 루프를 피하며 요청 / 응답 체인을 따라 모든 발신자의 프로토콜 기능을 식별하는 데 사용됩니다. Via = &quot;Via&quot; &quot;:&quot;1 # (수신 프로토콜 [[]]에 의해 수신 됨] 수신 프로토콜 = [프로토콜 이름 &quot;/&quot;] 프로토콜 버전 protocol-name = 토큰 프로토콜 버전 = 토큰 수령자 = (호스트 [ &quot;:&quot;포트]) | pseudonym pseudonym = token 수신 프로토콜은 요청 / 응답 체인의 각 세그먼트를 따라 서버 또는 클라이언트가 수신 한 메시지의 프로토콜 버전을 나타냅니다.수신 된 프로토콜 버전은 메시지가 전달 될 때 Via 필드 값에 추가되어 업스트림 응용 프로그램의 프로토콜 기능에 대한 정보가 모든 수신자에게 계속 표시됩니다. protocol-name은 &quot;HTTP&quot;인 경우에만 선택적입니다. 수신인 필드는 일반적으로 메시지를 전달한 수신자 서버 또는 클라이언트의 호스트 및 선택적 포트 번호입니다. 그러나 실제 호스트가 민감한 정보로 간주되면 가명으로 대체 될 수 있습니다. 포트가 제공되지 않으면, 수신 된 프로토콜의 기본 포트로 간주 될 수 있습니다. 다중 Via 필드 값은 메시지를 전달한 각 프록시 또는 게이트웨이를 나타냅니다.각 수령인은 전달 결과의 순서에 따라 최종 결과가 정렬되도록 정보를 추가해야합니다. Via 헤더 필드에서 주석을 사용하여 User-Agent 및 Server 헤더 필드와 유사한 수신자 프록시 또는 게이트웨이의 소프트웨어를 식별 할 수 있습니다. 그러나 Via 필드의 모든 주석은 선택 사항이며 메시지를 전달하기 전에 수신자가 제거 할 수 있습니다. 예를 들어, 요청 메시지는 HTTP / 1.0 사용자 에이전트에서 코드 이름이 &quot;fred&quot;인 내부 프록시로 전송 될 수 있습니다.이 프록시는 HTTP / 1.1을 사용하여 요청을 nowhere.com의 공용 프록시로 전달합니다. www.ics.uci.edu의 오리진 서버로 전달합니다. www.ics.uci.edu가 수신 한 요청은 다음 Via 헤더 필드를 갖게됩니다. Via : 1.0 fred, 1.1 nowhere.com (Apache / 1.1) 네트워크 방화벽을 통해 포털로 사용되는 프록시 및 게이트웨이는 기본적으로 방화벽 영역 내의 호스트 이름과 포트를 전달해서는 안됩니다. 이 정보는 명시 적으로 활성화 된 경우에만 전파해야합니다. 활성화되지 않은 경우 방화벽 뒤에있는 호스트의 수신 호스트는 해당 호스트에 대한 적절한 가명으로 교체해야합니다. 내부 구조를 숨기기 위해 강력한 개인 정보 보호 요구 사항이있는 조직의 경우 프록시는 Via 헤더 필드 항목의 순서가 지정된 하위 시퀀스를 동일한 수신 프로토콜 값과 단일 항목으로 결합 할 수 있습니다. 예를 들어, Via : 1.0 ricky, 1.1 ethel, 1.1 fred, 1.0 lucy는 Via : 1.0 ricky, 1.1 mertz, 1로 축소 될 수 있습니다.0 lucy 응용 프로그램 여러 조직의 항목이 모두 동일한 조직 제어하에 있고 호스트가 이미 가명으로 바뀌지 않는 한 여러 항목을 결합해서는 안됩니다. 응용 프로그램은 다른 수신 프로토콜 값을 가진 항목을 결합해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="324e73fe5f7adaaf8050e5c44d8fcd8a74dfca98" translate="yes" xml:space="preserve">
          <source>The WINDOW_UPDATE frame (type=0x8) is used to implement flow control;
   see &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt; for an overview.

   Flow control operates at two levels: on each individual stream and on
   the entire connection.

   Both types of flow control are hop by hop, that is, only between the
   two endpoints.  Intermediaries do not forward WINDOW_UPDATE frames
   between dependent connections.  However, throttling of data transfer
   by any receiver can indirectly cause the propagation of flow-control
   information toward the original sender.

   Flow control only applies to frames that are identified as being
   subject to flow control.  Of the frame types defined in this
   document, this includes only DATA frames.  Frames that are exempt
   from flow control MUST be accepted and processed, unless the receiver
   is unable to assign resources to handling the frame.  A receiver MAY
   respond with a stream error (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) or connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type FLOW_CONTROL_ERROR if it is unable to accept
   a frame.

    +-+-------------------------------------------------------------+
    |R|              Window Size Increment (31)                     |
    +-+-------------------------------------------------------------+

                  Figure 14: WINDOW_UPDATE Payload Format

   The payload of a WINDOW_UPDATE frame is one reserved bit plus an
   unsigned 31-bit integer indicating the number of octets that the
   sender can transmit in addition to the existing flow-control window.
   The legal range for the increment to the flow-control window is 1 to
   2^31-1 (2,147,483,647) octets.

   The WINDOW_UPDATE frame does not define any flags.

   The WINDOW_UPDATE frame can be specific to a stream or to the entire
   connection.  In the former case, the frame's stream identifier
   indicates the affected stream; in the latter, the value &quot;0&quot; indicates
   that the entire connection is the subject of the frame.

   A receiver MUST treat the receipt of a WINDOW_UPDATE frame with an
   flow-control window increment of 0 as a stream error (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;)
   of type PROTOCOL_ERROR; errors on the connection flow-control window
   MUST be treated as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;). 

   WINDOW_UPDATE can be sent by a peer that has sent a frame bearing the
   END_STREAM flag.  This means that a receiver could receive a
   WINDOW_UPDATE frame on a &quot;half-closed (remote)&quot; or &quot;closed&quot; stream.
   A receiver MUST NOT treat this as an error (see &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;).

   A receiver that receives a flow-controlled frame MUST always account
   for its contribution against the connection flow-control window,
   unless the receiver treats this as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;).  This is necessary even if the frame is in error.
   The sender counts the frame toward the flow-control window, but if
   the receiver does not, the flow-control window at the sender and
   receiver can become different.

   A WINDOW_UPDATE frame with a length other than 4 octets MUST be
   treated as a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type
   FRAME_SIZE_ERROR.</source>
          <target state="translated">WINDOW_UPDATE 프레임 (유형 = 0x8)은 흐름 제어를 구현하는 데 사용됩니다. &lt;a href=&quot;#section-5.2&quot;&gt;5.2 절&lt;/a&gt; 참조개요. 흐름 제어는 각 개별 스트림과 전체 연결의 두 가지 수준에서 작동합니다. 두 가지 유형의 흐름 제어는 홉 단위, 즉 두 끝점 사이에서만 가능합니다. 중개자는 종속 연결간에 WINDOW_UPDATE 프레임을 전달하지 않습니다. 그러나 수신자의 데이터 전송 제한은 간접적으로 원래 발신자에게 흐름 제어 정보의 전파를 유발할 수 있습니다. 흐름 제어는 흐름 제어 대상으로 식별 된 프레임에만 적용됩니다. 이 문서에 정의 된 프레임 유형 중 DATA 프레임 만 포함됩니다. 흐름 제어에서 제외 된 프레임은 수신자가 프레임 처리에 리소스를 할당 할 수없는 경우를 제외하고 반드시 수락 및 처리되어야합니다. 수신기는 스트림 오류 ( &lt;a href=&quot;#section-5.4.2&quot;&gt;섹션 5.4.2&lt;/a&gt; ) 또는 연결 오류 (&lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1 절&lt;/a&gt;) 프레임을 수락 할 수없는 경우 FLOW_CONTROL_ERROR 유형입니다. +-+ ----------------------------------------------- -------------- + | R | 창 크기 증가 (31) | +-+ ----------------------------------------------- -------------- + 그림 14 : WINDOW_UPDATE 페이로드 형식 WINDOW_UPDATE 프레임의 페이로드는 하나의 예약 된 비트와 보낸 사람이 추가로 전송할 수있는 옥텟 수를 나타내는 부호없는 31 비트 정수입니다. 기존 흐름 제어 창에 추가합니다. 흐름 제어 창 증분에 대한 법적 범위는 1에서 2 ^ 31-1 (2,147,483,647) 옥텟입니다. WINDOW_UPDATE 프레임은 플래그를 정의하지 않습니다. WINDOW_UPDATE 프레임은 스트림 또는 전체 연결에 특정 할 수 있습니다. 전자의 경우 프레임의 스트림 식별자는 영향을받는 스트림을 나타냅니다. 후자의 경우 값 &quot;0&quot;전체 연결이 프레임의 주제임을 나타냅니다. 수신자는 흐름 제어 창 증분이 0 인 WINDOW_UPDATE 프레임의 수신을 스트림 오류 (&lt;a href=&quot;#section-5.4.2&quot;&gt;섹션 5.4.2&lt;/a&gt; ) PROTOCOL_ERROR 유형; 연결 흐름 제어 창의 오류는 연결 오류로 처리되어야합니다 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt; ). WINDOW_UPDATE는 END_STREAM 플래그가있는 프레임을 보낸 피어가 보낼 수 있습니다. 이것은 수신자가 &quot;반 폐쇄 (원격)&quot;또는 &quot;폐쇄&quot;스트림에서 WINDOW_UPDATE 프레임을 수신 할 수 있음을 의미합니다. 수신자는 이것을 오류로 취급해서는 안됩니다 ( &lt;a href=&quot;#section-5.1&quot;&gt;섹션 5.1&lt;/a&gt; 참조 ). 흐름 제어 프레임을 수신하는 수신기는 수신기가이를 연결 오류로 취급하지 않는 한 연결 흐름 제어 창에 대한 기여를 항상 고려해야합니다 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt;). 프레임에 오류가있는 경우에도 필요합니다. 송신자는 흐름 제어 창을 향해 프레임을 계산하지만 수신자가 그렇지 않은 경우 송신자와 수신자의 흐름 제어 창이 다를 수 있습니다. 길이가 4 옥텟이 아닌 WINDOW_UPDATE 프레임은 FRAME_SIZE_ERROR 유형 의 연결 오류 ( &lt;a href=&quot;#section-5.4.1&quot;&gt;섹션 5.4.1&lt;/a&gt; ) 로 처리 되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0176fdb6175026d4c263772f8859cf082f15cf8e" translate="yes" xml:space="preserve">
          <source>The WWW-Authenticate response-header field MUST be included in 401
   (Unauthorized) response messages. The field value consists of at
   least one challenge that indicates the authentication scheme(s) and
   parameters applicable to the Request-URI.

       WWW-Authenticate  = &quot;WWW-Authenticate&quot; &quot;:&quot; 1#challenge

   The HTTP access authentication process is described in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. User
   agents are advised to take special care in parsing the WWW-
   Authenticate field value as it might contain more than one challenge,
   or if more than one WWW-Authenticate header field is provided, the
   contents of a challenge itself can contain a comma-separated list of
   authentication parameters.</source>
          <target state="translated">WWW-Authenticate response-header 필드는 반드시 401 (Unauthorized) 응답 메시지에 포함되어야합니다. 필드 값은 Request-URI에 적용 할 수있는 인증 체계 및 매개 변수를 나타내는 하나 이상의 시도로 구성됩니다. WWW-Authenticate = &quot;WWW-Authenticate&quot; &quot;:&quot;1 # challenge HTTP 액세스 인증 프로세스는 &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증&quot;[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]에 설명되어 있습니다. 사용자 에이전트는 WWW-Authenticate 필드 값을 두 개 이상의 챌린지가 포함되어있을 수 있으므로 구문 분석 할 때 특히주의해야합니다. 또는 둘 이상의 WWW-Authenticate 헤더 필드가 제공된 경우 챌린지 자체의 내용은 쉼표로 구분 될 수 있습니다 인증 매개 변수 목록</target>
        </trans-unit>
        <trans-unit id="7a35f374a20f06c6368a7744257833df18d21fb6" translate="yes" xml:space="preserve">
          <source>The Warning general-header field is used to carry additional
   information about the status or transformation of a message which
   might not be reflected in the message. This information is typically
   used to warn about a possible lack of semantic transparency from
   caching operations or transformations applied to the entity body of
   the message.

   Warning headers are sent with responses using:

       Warning    = &quot;Warning&quot; &quot;:&quot; 1#warning-value

       warning-value = warn-code SP warn-agent SP warn-text
                                             [SP warn-date]

       warn-code  = 3DIGIT
       warn-agent = ( host [ &quot;:&quot; port ] ) | pseudonym
                       ; the name or pseudonym of the server adding
                       ; the Warning header, for use in debugging
       warn-text  = quoted-string
       warn-date  = &amp;lt;&quot;&amp;gt; HTTP-date &amp;lt;&quot;&amp;gt;

   A response MAY carry more than one Warning header.

   The warn-text SHOULD be in a natural language and character set that
   is most likely to be intelligible to the human user receiving the
   response. This decision MAY be based on any available knowledge, such
   as the location of the cache or user, the Accept-Language field in a
   request, the Content-Language field in a response, etc. The default
   language is English and the default character set is ISO-8859-1.

   If a character set other than ISO-8859-1 is used, it MUST be encoded
   in the warn-text using the method described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; [&lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;].

   Warning headers can in general be applied to any message, however
   some specific warn-codes are specific to caches and can only be
   applied to response messages. New Warning headers SHOULD be added
   after any existing Warning headers. A cache MUST NOT delete any
   Warning header that it received with a message. However, if a cache
   successfully validates a cache entry, it SHOULD remove any Warning
   headers previously attached to that entry except as specified for 

   specific Warning codes. It MUST then add any Warning headers received
   in the validating response. In other words, Warning headers are those
   that would be attached to the most recent relevant response.

   When multiple Warning headers are attached to a response, the user
   agent ought to inform the user of as many of them as possible, in the
   order that they appear in the response. If it is not possible to
   inform the user of all of the warnings, the user agent SHOULD follow
   these heuristics:

      - Warnings that appear early in the response take priority over
        those appearing later in the response.

      - Warnings in the user's preferred character set take priority
        over warnings in other character sets but with identical warn-
        codes and warn-agents.

   Systems that generate multiple Warning headers SHOULD order them with
   this user agent behavior in mind.

   Requirements for the behavior of caches with respect to Warnings are
   stated in &lt;a href=&quot;#section-13.1.2&quot;&gt;section 13.1.2&lt;/a&gt;.

   This is a list of the currently-defined warn-codes, each with a
   recommended warn-text in English, and a description of its meaning.

   110 Response is stale
     MUST be included whenever the returned response is stale.

   111 Revalidation failed
     MUST be included if a cache returns a stale response because an
     attempt to revalidate the response failed, due to an inability to
     reach the server.

   112 Disconnected operation
     SHOULD be included if the cache is intentionally disconnected from
     the rest of the network for a period of time.

   113 Heuristic expiration
     MUST be included if the cache heuristically chose a freshness
     lifetime greater than 24 hours and the response's age is greater
     than 24 hours.

   199 Miscellaneous warning
     The warning text MAY include arbitrary information to be presented
     to a human user, or logged. A system receiving this warning MUST
     NOT take any automated action, besides presenting the warning to
     the user. 

   214 Transformation applied
     MUST be added by an intermediate cache or proxy if it applies any
     transformation changing the content-coding (as specified in the
     Content-Encoding header) or media-type (as specified in the
     Content-Type header) of the response, or the entity-body of the
     response, unless this Warning code already appears in the response.

   299 Miscellaneous persistent warning
     The warning text MAY include arbitrary information to be presented
     to a human user, or logged. A system receiving this warning MUST
     NOT take any automated action.

   If an implementation sends a message with one or more Warning headers
   whose version is HTTP/1.0 or lower, then the sender MUST include in
   each warning-value a warn-date that matches the date in the response.

   If an implementation receives a message with a warning-value that
   includes a warn-date, and that warn-date is different from the Date
   value in the response, then that warning-value MUST be deleted from
   the message before storing, forwarding, or using it. (This prevents
   bad consequences of naive caching of Warning header fields.) If all
   of the warning-values are deleted for this reason, the Warning header
   MUST be deleted as well.</source>
          <target state="translated">경고 일반 헤더 필드는 메시지에 반영되지 않을 수있는 메시지의 상태 또는 변환에 대한 추가 정보를 전달하는 데 사용됩니다. 이 정보는 일반적으로 메시지의 엔터티 본문에 적용된 캐싱 작업 또는 변환으로 인한 의미 투명성 부족에 대해 경고하는 데 사용됩니다. 경고 헤더는 다음을 사용하여 응답과 함께 전송됩니다. 경고 = &quot;경고&quot; &quot;:&quot;1 # 경고 값 경고 값 = 경고 코드 SP 경고 에이전트 SP 경고 텍스트 [SP 경고 날짜] 경고 코드 = 3DIGIT 경고 에이전트 = (호스트 [ &quot;:&quot;포트]) | 가명; 추가하는 서버의 이름 또는 가명; 경고 헤더디버깅에 사용 warn-text = quoted-string warn-date = &amp;lt; &quot;&amp;gt; HTTP-date &amp;lt;&quot;&amp;gt; 응답에 둘 이상의 경고 헤더가있을 수 있습니다. 경고문은 응답을받는 사람이 이해하기 쉬운 자연 언어와 문자 집합이어야합니다. 이 결정은 캐시 또는 사용자의 위치, 요청의 Accept-Language 필드, 응답의 Content-Language 필드 등과 같은 사용 가능한 지식을 기반으로 할 수 있습니다. 기본 언어는 영어이며 기본 문자 세트입니다. ISO-8859-1입니다. ISO-8859-1 이외의 문자 집합을 사용하는 경우 반드시 경고 텍스트에 설명 된 방법을 사용하여 인코딩해야합니다.경고문은 응답을받는 사람이 이해하기 쉬운 자연 언어와 문자 집합이어야합니다. 이 결정은 캐시 또는 사용자의 위치, 요청의 Accept-Language 필드, 응답의 Content-Language 필드 등과 같은 사용 가능한 지식을 기반으로 할 수 있습니다. 기본 언어는 영어이며 기본 문자 세트입니다. ISO-8859-1입니다. ISO-8859-1 이외의 문자 집합을 사용하는 경우 반드시 경고 텍스트에 설명 된 방법을 사용하여 인코딩해야합니다.경고문은 응답을받는 사람이 이해하기 쉬운 자연 언어와 문자 집합이어야합니다. 이 결정은 캐시 또는 사용자의 위치, 요청의 Accept-Language 필드, 응답의 Content-Language 필드 등과 같은 사용 가능한 지식을 기반으로 할 수 있습니다. 기본 언어는 영어이며 기본 문자 세트입니다. ISO-8859-1입니다. ISO-8859-1 이외의 문자 집합을 사용하는 경우 반드시 경고 텍스트에 설명 된 방법을 사용하여 인코딩해야합니다.기본 언어는 영어이고 기본 문자 집합은 ISO-8859-1입니다. ISO-8859-1 이외의 문자 집합을 사용하는 경우 반드시 경고 텍스트에 설명 된 방법을 사용하여 인코딩해야합니다.기본 언어는 영어이고 기본 문자 집합은 ISO-8859-1입니다. ISO-8859-1 이외의 문자 집합을 사용하는 경우 반드시 경고 텍스트에 설명 된 방법을 사용하여 인코딩해야합니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; [ &lt;a href=&quot;#ref-14&quot;&gt;14&lt;/a&gt;]. 경고 헤더는 일반적으로 모든 메시지에 적용 할 수 있지만 일부 특정 경고 코드는 캐시에만 적용되며 응답 메시지에만 적용 할 수 있습니다. 기존 경고 헤더 뒤에 새 경고 헤더를 추가해야합니다. 캐시는 메시지와 함께받은 경고 헤더를 삭제해서는 안됩니다 (MUST NOT). 그러나 캐시가 캐시 항목의 유효성을 성공적으로 확인하면 특정 경고 코드에 지정된 경우를 제외하고 해당 항목에 이전에 연결된 모든 경고 헤더를 제거해야합니다. 그런 다음 유효성 검사 응답에서 수신 된 모든 경고 헤더를 추가해야합니다. 다시 말해, 경고 헤더는 가장 최근의 관련 응답에 첨부되는 헤더입니다. 응답에 여러 개의 경고 헤더가 첨부되면 사용자 에이전트는 가능한 많은 헤더를 사용자에게 알려야합니다.응답에 나타나는 순서대로. 사용자에게 모든 경고를 알 수없는 경우, 사용자 에이전트는 다음 휴리스틱을 따라야합니다.-응답 초기에 나타나는 경고가 응답 후반에 나타나는 경고보다 우선합니다. -사용자가 선호하는 문자 세트의 경고가 다른 문자 세트의 경고보다 우선하지만 경고 및 경고 에이전트는 동일합니다. 여러 경고 헤더를 생성하는 시스템은이 사용자 에이전트 동작을 염두에두고 정렬해야합니다. 경고와 관련된 캐시 동작 요구 사항은-응답 초기에 나타나는 경고가 응답 후반에 나타나는 경고보다 우선합니다. -사용자가 선호하는 문자 세트의 경고가 다른 문자 세트의 경고보다 우선하지만 경고 및 경고 에이전트는 동일합니다. 여러 경고 헤더를 생성하는 시스템은이 사용자 에이전트 동작을 염두에두고 정렬해야합니다. 경고와 관련된 캐시 동작 요구 사항은-응답 초기에 나타나는 경고가 응답 후반에 나타나는 경고보다 우선합니다. -사용자가 선호하는 문자 세트의 경고가 다른 문자 세트의 경고보다 우선하지만 경고 및 경고 에이전트는 동일합니다. 여러 경고 헤더를 생성하는 시스템은이 사용자 에이전트 동작을 염두에두고 정렬해야합니다. 경고와 관련된 캐시 동작 요구 사항은경고와 관련된 캐시 동작 요구 사항은경고와 관련된 캐시 동작 요구 사항은&lt;a href=&quot;#section-13.1.2&quot;&gt;섹션 13.1.2&lt;/a&gt;. 다음은 현재 정의 된 경고 코드 목록이며, 각각 영어로 권장되는 경고 텍스트와 그 의미에 대한 설명이 있습니다. 110 응답이 부실함 반환 된 응답이 부실 할 때마다 응답을 포함해야합니다. 111 서버에 도달 할 수 없기 때문에 응답 재확인 시도가 실패하여 캐시가 오래된 응답을 반환하는 경우 유효성 재확인에 실패해야합니다. 연결이 끊긴 작업 캐시가 일정 기간 동안 네트워크의 나머지 부분에서 의도적으로 연결이 끊어진 경우 포함해야합니다. 캐시가 24 시간보다 긴 신선도 수명을 발견 적으로 선택하고 응답 시간이 24 시간보다 큰 경우 휴리스틱 만료를 포함해야합니다.199 기타 경고 경고 텍스트는 사람에게 제시되거나 기록 될 임의의 정보를 포함 할 수 있습니다. 이 경고를받는 시스템은 사용자에게 경고를 표시하는 것 외에 자동 조치를 취해서는 안됩니다. 214 적용되는 변환은 응답의 내용 코딩 (Content-Encoding 헤더에 지정된대로) 또는 미디어 유형 (Content-Type 헤더에 지정된대로)을 변경하는 변환을 적용 할 경우 반드시 중간 캐시 또는 프록시에 의해 추가되어야한다. 이 경고 코드가 이미 응답에 나타나지 않는 한 응답의 엔터티 본문입니다. 299 기타 지속적 경고 경고 텍스트는 사람에게 제시되거나 기록 될 임의의 정보를 포함 할 수 있습니다. 이 경고를받는 시스템은 자동 조치를 취해서는 안됩니다.구현시 버전이 HTTP / 1.0 이하인 하나 이상의 경고 헤더가있는 메시지를 보내는 경우 발신인은 응답의 날짜와 일치하는 경고 날짜를 각 경고 값에 포함해야합니다. 구현이 경고 날짜를 포함하는 경고 값을 가진 메시지를 수신하고 해당 경고 날짜가 응답의 날짜 값과 다른 경우 저장, 전달 또는 전달하기 전에 해당 경고 값을 메시지에서 삭제해야합니다. 그것을 사용합니다. (이로 인해 경고 헤더 필드의 순진 캐싱으로 인한 나쁜 결과를 방지 할 수 있습니다.) 이러한 이유로 모든 경고 값이 삭제되면 경고 헤더도 삭제해야합니다.보낸 사람은 각 경고 값에 응답 날짜와 일치하는 경고 날짜를 포함해야합니다. 구현이 경고 날짜를 포함하는 경고 값을 가진 메시지를 수신하고 해당 경고 날짜가 응답의 날짜 값과 다른 경우 저장, 전달 또는 전달하기 전에 해당 경고 값을 메시지에서 삭제해야합니다. 그것을 사용합니다. (이로 인해 경고 헤더 필드의 순진 캐싱으로 인한 나쁜 결과를 방지 할 수 있습니다.) 이러한 이유로 모든 경고 값이 삭제되면 경고 헤더도 삭제해야합니다.보낸 사람은 각 경고 값에 응답 날짜와 일치하는 경고 날짜를 포함해야합니다. 구현이 경고 날짜를 포함하는 경고 값을 가진 메시지를 수신하고 해당 경고 날짜가 응답의 날짜 값과 다른 경우 저장, 전달 또는 전달하기 전에 해당 경고 값을 메시지에서 삭제해야합니다. 그것을 사용합니다. (이로 인해 경고 헤더 필드의 순진 캐싱으로 인한 나쁜 결과를 방지 할 수 있습니다.) 이러한 이유로 모든 경고 값이 삭제되면 경고 헤더도 삭제해야합니다.(이로 인해 경고 헤더 필드의 순진 캐싱으로 인한 나쁜 결과를 방지 할 수 있습니다.) 이러한 이유로 모든 경고 값이 삭제되면 경고 헤더도 삭제해야합니다.(이로 인해 경고 헤더 필드의 순진 캐싱으로 인한 나쁜 결과를 방지 할 수 있습니다.) 이러한 이유로 모든 경고 값이 삭제되면 경고 헤더도 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="650ee0647a2c1fdd4db296e88e9d7457a6d4e9da" translate="yes" xml:space="preserve">
          <source>The Web APIs have native methods to encode or decode to base64: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;Base64 encoding and decoding&lt;/a&gt;.</source>
          <target state="translated">웹 API에는 base64로 인코딩 또는 디코딩하는 기본 메소드 인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;Base64 인코딩 및 디코딩이&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="56faf444060ee49993107fee26b7ba0d66f5e281" translate="yes" xml:space="preserve">
          <source>The Web Origin Concept</source>
          <target state="translated">웹 오리진 개념</target>
        </trans-unit>
        <trans-unit id="215d6bd38f0870c1defdd62eb60f6f1375d1790f" translate="yes" xml:space="preserve">
          <source>The Web Runtime uses the same user agent string as desktop Firefox.</source>
          <target state="translated">Web Runtime은 데스크탑 Firefox와 동일한 사용자 에이전트 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="941232b2ff4433cb0bd6270438632894b53fb59c" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily not available for reasons that have not been unforeseen. That way, search engines don't update their links.</source>
          <target state="translated">예상치 못한 이유로 웹 페이지를 일시적으로 사용할 수 없습니다. 이렇게하면 검색 엔진이 링크를 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55fa8ca3dd54f0ec3aab1401af4719063aeb4a24" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily not available for reasons that have not been unforeseen. That way, search engines don't update their links. Better than &lt;code&gt;302&lt;/code&gt; when non-GET links/operations are available on the site.</source>
          <target state="translated">예상치 못한 이유로 웹 페이지를 일시적으로 사용할 수 없습니다. 이렇게하면 검색 엔진이 링크를 업데이트하지 않습니다. 사이트에서 비 GET 링크 / 작업을 사용할 수있는 경우 &lt;code&gt;302&lt;/code&gt; 보다 낫습니다 .</target>
        </trans-unit>
        <trans-unit id="d6e1f00a886091957899f1d426a1a907509a4636" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily unavailable for unforeseen reasons.</source>
          <target state="translated">웹 페이지는 예기치 않은 이유로 일시적으로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d83272b4a920a61a8fef1340e4de8c385bd7ee81" translate="yes" xml:space="preserve">
          <source>The Web page is temporarily unavailable for unforeseen reasons. Better than &lt;code&gt;302&lt;/code&gt; when non-&lt;code&gt;GET&lt;/code&gt; operations are available on the site.</source>
          <target state="translated">웹 페이지는 예기치 않은 이유로 일시적으로 사용할 수 없습니다. 사이트에서 &lt;code&gt;GET&lt;/code&gt; 이 아닌 작업을 사용할 수있는 경우 &lt;code&gt;302&lt;/code&gt; 보다 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ad5e46a03efafad9853b734ee0d593694b072117" translate="yes" xml:space="preserve">
          <source>The Web server</source>
          <target state="translated">웹 서버</target>
        </trans-unit>
        <trans-unit id="95924074d7e37faf6b144a7b43119f38c76fd2f0" translate="yes" xml:space="preserve">
          <source>The WebSocket Protocol</source>
          <target state="translated">WebSocket 프로토콜</target>
        </trans-unit>
        <trans-unit id="09ee06d1ee05107c094545645447a824d3d94f1b" translate="yes" xml:space="preserve">
          <source>The WebSocket protocol version the client wishes to use when communicating with the server. This number should be the most recent version possible listed in the &lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#version-number&quot;&gt;IANA WebSocket Version Number Registry&lt;/a&gt;. The most recent final version of the WebSocket protocol is version 13.</source>
          <target state="translated">클라이언트가 서버와 통신 할 때 사용하려는 WebSocket 프로토콜 버전. 이 번호는 &lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#version-number&quot;&gt;IANA WebSocket 버전 번호 레지스트리에&lt;/a&gt; 나열된 최신 버전이어야합니다 . WebSocket 프로토콜의 최신 버전은 버전 13입니다.</target>
        </trans-unit>
        <trans-unit id="e242f211ed018b0f56d726778881102bd4b4068c" translate="yes" xml:space="preserve">
          <source>The XML namespace extension ([&lt;a href=&quot;#ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;]) is used in this
   specification in order to allow for new XML elements to be added
   without fear of colliding with other element names.  Although WebDAV
   request and response bodies can be extended by arbitrary XML
   elements, which can be ignored by the message recipient, an XML
   element in the &quot;DAV:&quot; namespace SHOULD NOT be used in the request or
   response body unless that XML element is explicitly defined in an
   IETF RFC reviewed by a WebDAV working group.

   For WebDAV to be both extensible and backwards-compatible, both
   clients and servers need to know how to behave when unexpected or
   unrecognized command extensions are received.  For XML processing,
   this means that clients and servers MUST process received XML
   documents as if unexpected elements and attributes (and all children
   of unrecognized elements) were not there.  An unexpected element or
   attribute includes one that may be used in another context but is not
   expected here.  Ignoring such items for purposes of processing can of
   course be consistent with logging all information or presenting for
   debugging.

   This restriction also applies to the processing, by clients, of DAV
   property values where unexpected XML elements SHOULD be ignored
   unless the property's schema declares otherwise.

   This restriction does not apply to setting dead DAV properties on the
   server where the server MUST record all XML elements. 

   Additionally, this restriction does not apply to the use of XML where
   XML happens to be the content type of the entity body, for example,
   when used as the body of a PUT.

   Processing instructions in XML SHOULD be ignored by recipients.
   Thus, specifications extending WebDAV SHOULD NOT use processing
   instructions to define normative behavior.

   XML DTD fragments are included for all the XML elements defined in
   this specification.  However, correct XML will not be valid according
   to any DTD due to namespace usage and extension rules.  In
   particular:

   o  Elements (from this specification) are in the &quot;DAV:&quot; namespace,

   o  Element ordering is irrelevant unless otherwise stated,

   o  Extension attributes MAY be added,

   o  For element type definitions of &quot;ANY&quot;, the normative text
      definition for that element defines what can be in it and what
      that means.

   o  For element type definitions of &quot;#PCDATA&quot;, extension elements MUST
      NOT be added.

   o  For other element type definitions, including &quot;EMPTY&quot;, extension
      elements MAY be added.

   Note that this means that elements containing elements cannot be
   extended to contain text, and vice versa.

   With DTD validation relaxed by the rules above, the constraints
   described by the DTD fragments are normative (see for example
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;).  A recipient of a WebDAV message with an XML body MUST
   NOT validate the XML document according to any hard-coded or
   dynamically-declared DTD.

   Note that this section describes backwards-compatible extensibility
   rules.  There might also be times when an extension is designed not
   to be backwards-compatible, for example, defining an extension that
   reuses an XML element defined in this document but omitting one of
   the child elements required by the DTDs in this specification.</source>
          <target state="translated">XML 네임 스페이스 확장 ([ &lt;a href=&quot;#ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;])는 다른 XML 요소 이름과 충돌 할 염려없이 새로운 XML 요소를 추가 할 수 있도록이 사양에서 사용됩니다. WebDAV 요청 및 응답 본문은 메시지 수신자가 무시할 수있는 임의의 XML 요소로 확장 될 수 있지만 &quot;DAV :&quot;네임 스페이스의 XML 요소는 해당 XML 요소가 명시 적으로 정의되어 있지 않으면 요청 또는 응답 본문에서 사용해서는 안됩니다 (SHOULD). WebDAV 실무 그룹에 의해 검토 된 IETF RFC에서. WebDAV가 확장 가능하고 이전 버전과 호환 가능하도록하려면 클라이언트와 서버 모두 예기치 않은 또는 인식 할 수없는 명령 확장이 수신 될 때 동작하는 방법을 알아야합니다. XML 처리의 경우즉, 클라이언트와 서버는 예기치 않은 요소와 속성 (및 인식 할 수없는 요소의 모든 자식)이없는 것처럼 수신 된 XML 문서를 처리해야합니다. 예기치 않은 요소 또는 속성에는 다른 컨텍스트에서 사용될 수 있지만 여기에서는 예상되지 않는 요소 또는 속성이 포함됩니다. 처리 목적으로 이러한 항목을 무시하는 것은 물론 모든 정보를 기록하거나 디버깅을 위해 제시하는 것과 일치 할 수 있습니다. 이 제한은 속성 스키마가 달리 선언하지 않는 한 예기치 않은 XML 요소를 무시해야하는 클라이언트의 DAV 속성 값 처리에도 적용됩니다. 서버가 모든 XML 요소를 기록해야하는 서버에서 죽은 DAV 속성을 설정하는 경우에는이 제한이 적용되지 않습니다. 또한이 제한은 XML이 엔티티 본문의 컨텐츠 유형이되는 XML (예 : PUT의 본문으로 사용되는 경우)에는 적용되지 않습니다. 수신자는 XML로 처리 지침을 무시해야한다. 따라서 WebDAV를 확장하는 사양은 표준 동작을 정의하기 위해 처리 명령을 사용해서는 안됩니다. XML DTD 조각은이 사양에 정의 된 모든 XML 요소에 포함됩니다. 그러나 네임 스페이스 사용 및 확장 규칙으로 인해 DTD에 따라 올바른 XML이 유효하지 않습니다. o 요소 (이 사양의)는 &quot;DAV :&quot;네임 스페이스에 있습니다. o 달리 명시되지 않는 한 요소 순서는 관련이 없습니다. o 확장 속성이 추가 될 수 있습니다. o &quot;ANY&quot;의 요소 유형 정의의 경우,그 요소에 대한 규범 적 텍스트 정의는 그 안에있을 수있는 것과 그 의미를 정의합니다. o &quot;#PCDATA&quot;의 요소 유형 정의에는 확장 요소를 추가해서는 안됩니다. o &quot;EMPTY&quot;를 포함한 다른 요소 유형 정의의 경우 확장 요소가 추가 될 수 있습니다. 즉, 요소를 포함하는 요소는 텍스트를 포함하도록 확장 할 수 없으며 그 반대도 마찬가지입니다. 위의 규칙으로 DTD 유효성 검사를 완화하면 DTD 조각으로 설명 된 제약 조건이 규범 적입니다 (예 : 참조).즉, 요소를 포함하는 요소는 텍스트를 포함하도록 확장 할 수 없으며 그 반대도 마찬가지입니다. 위의 규칙으로 DTD 유효성 검사를 완화하면 DTD 조각으로 설명 된 제약 조건이 규범 적입니다 (예 : 참조).즉, 요소를 포함하는 요소는 텍스트를 포함하도록 확장 할 수 없으며 그 반대도 마찬가지입니다. 위의 규칙으로 DTD 유효성 검사를 완화하면 DTD 조각으로 설명 된 제약 조건이 규범 적입니다 (예 : 참조). &lt;a href=&quot;#appendix-A&quot;&gt;부록 A&lt;/a&gt; ). XML 본문이있는 WebDAV 메시지를받는 사람은 하드 코딩되거나 동적으로 선언 된 DTD에 따라 XML 문서의 유효성을 검사해서는 안됩니다. 이 섹션에서는 이전 버전과 호환되는 확장 성 규칙에 대해 설명합니다. 예를 들어,이 문서에 정의 된 XML 요소를 재사용하는 확장을 정의하지만이 사양에서 DTD에 필요한 하위 요소 중 하나를 생략하는 등 확장이 하위 호환성을 갖도록 설계된 경우도있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5abb61434aba6cac3c3255f0777b6e4ab04de6f1" translate="yes" xml:space="preserve">
          <source>The abbreviation for each format links to a longer description of the format, its capabilities, and detailed browser compatibility information; including which versions introduced support and specific special features that may have been introduced later.</source>
          <target state="translated">각 형식의 약어는 형식에 대한 자세한 설명, 기능 및 자세한 브라우저 호환성 정보로 연결됩니다. 지원을 도입 한 버전 및 나중에 도입 될 수있는 특정 특수 기능을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="b298dd5e10b677f7b1f3b1962b7f374d92022229" translate="yes" xml:space="preserve">
          <source>The ability to lock a resource provides a mechanism for serializing
   access to that resource.  Using a lock, an authoring client can
   provide a reasonable guarantee that another principal will not modify
   a resource while it is being edited.  In this way, a client can
   prevent the &quot;lost update&quot; problem.

   This specification allows locks to vary over two client-specified
   parameters, the number of principals involved (exclusive vs. shared)
   and the type of access to be granted.  This document defines locking
   for only one access type, write.  However, the syntax is extensible,
   and permits the eventual specification of locking for other access
   types.</source>
          <target state="translated">리소스를 잠그는 기능은 해당 리소스에 대한 액세스를 직렬화하는 메커니즘을 제공합니다. 잠금을 사용하여 작성 클라이언트는 다른 프린시 펄이 편집중인 자원을 수정하지 않을 것이라는 합리적인 보증을 제공 할 수 있습니다. 이러한 방식으로 클라이언트는 &quot;손실 된 업데이트&quot;문제를 방지 할 수 있습니다. 이 사양을 사용하면 잠금이 클라이언트가 지정한 두 가지 매개 변수, 포함 된 주체 수 (제외 대 공유) 및 부여 할 액세스 유형에 따라 달라질 수 있습니다. 이 문서는 하나의 액세스 유형에 대해서만 잠금을 정의합니다. 그러나 구문은 확장 가능하며 최종적으로 다른 액세스 유형에 대한 잠금 스펙을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="3b06c2527b7380abe2e2e286d29197b000c1f987" translate="yes" xml:space="preserve">
          <source>The above Content Security Policy will allow inline &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements</source>
          <target state="translated">위의 콘텐츠 보안 정책은 인라인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 허용 합니다</target>
        </trans-unit>
        <trans-unit id="38b5b1c5b09838d3f34e6ad848719f979f8adbe4" translate="yes" xml:space="preserve">
          <source>The above Content Security Policy will allow inline styles like the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; element, and the &lt;code&gt;style&lt;/code&gt; attribute on any element:</source>
          <target state="translated">위의 콘텐츠 보안 정책은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 와 같은 인라인 스타일 및 모든 요소 의 &lt;code&gt;style&lt;/code&gt; 속성을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="fccee75b555f59c4fe0c1b6040c213d2c31d26f2" translate="yes" xml:space="preserve">
          <source>The above checks to see if the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header sent by the browser (obtained through $_SERVER['HTTP_ORIGIN']) matches '&lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;'. If yes, it returns &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt;. This example can be &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;seen running here&lt;/a&gt;.</source>
          <target state="translated">위의 내용 은 브라우저가 보낸 ($ _SERVER [ 'HTTP_ORIGIN']을 통해 얻은) &lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 헤더가 ' &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt; ' 과 일치하는지 확인 합니다. 그렇다면 &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt; 반환합니다 . 이 예제는 &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;여기서 실행되는&lt;/a&gt; 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ded9ed730bf997dd582fce073e6812fd63d3ebf3" translate="yes" xml:space="preserve">
          <source>The above code would have made several incorrect assumptions:</source>
          <target state="translated">위의 코드는 몇 가지 잘못된 가정을 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="ced1ab96d2e07e89bba3cc71ef4220a4d87bd67e" translate="yes" xml:space="preserve">
          <source>The above example will use the proxy for everything except local hosts in the mozilla.org domain, with the further exception that hosts &lt;code&gt;www.mozilla.org&lt;/code&gt; and &lt;code&gt;merchant.mozilla.org&lt;/code&gt; will go through the proxy.</source>
          <target state="translated">위의 예는 &lt;code&gt;www.mozilla.org&lt;/code&gt; 및 &lt;code&gt;merchant.mozilla.org&lt;/code&gt; 를 호스트하는 추가 예외를 제외하고 mozilla.org 도메인의 로컬 호스트를 제외한 모든 항목에 프록시를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="bde7701a5c7f870f1548d1541023a9c35cec39e4" translate="yes" xml:space="preserve">
          <source>The above example will use the proxy for everything except local hosts in the mozilla.org domain, with the further exception that hosts www.mozilla.org and merchant.mozilla.org will go through the proxy.</source>
          <target state="translated">위의 예는 mozilla.org 도메인의 로컬 호스트를 제외한 모든 호스트에 프록시를 사용하지만, www.mozilla.org 및 merchant.mozilla.org 호스트는 프록시를 거치게됩니다.</target>
        </trans-unit>
        <trans-unit id="7aeeb6c5396c82b22fb67dae5cbdfb5d930395d8" translate="yes" xml:space="preserve">
          <source>The above permissions may be cached for 86,400 seconds (1 day).</source>
          <target state="translated">위의 권한은 86,400 초 (1 일) 동안 캐시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="517f24a05885574e21ddf60556499b7755bb7037" translate="yes" xml:space="preserve">
          <source>The above requires consulting the DNS every time; it can be grouped intelligently with other rules so that DNS is consulted only if other rules do not yield a result:</source>
          <target state="translated">위의 내용은 매번 DNS를 참조해야합니다. 다른 규칙으로 결과를 얻지 못하는 경우에만 DNS를 참조하도록 다른 규칙과 지능적으로 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a1d7213c66cb3708576c9dee4e5fbc7b85eeee8" translate="yes" xml:space="preserve">
          <source>The added security is only provided if the user accessing the document is using a browser supporting &lt;code&gt;X-Frame-Options&lt;/code&gt;.</source>
          <target state="translated">추가 된 보안은 문서에 액세스하는 사용자가 &lt;code&gt;X-Frame-Options&lt;/code&gt; 를 지원하는 브라우저를 사용하는 경우에만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="442c6996e10d8c8b2aa1a7ff243ac87908709eb2" translate="yes" xml:space="preserve">
          <source>The added security is provided only if the user accessing the document is using a browser that supports &lt;code&gt;X-Frame-Options&lt;/code&gt;.</source>
          <target state="translated">추가 보안은 문서에 액세스하는 사용자가 &lt;code&gt;X-Frame-Options&lt;/code&gt; 를 지원하는 브라우저를 사용하는 경우에만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc4cf5be0bdff2d41464e3aec79f3206f5e9a290" translate="yes" xml:space="preserve">
          <source>The address of the previous web page from which a link to the currently requested page was followed.</source>
          <target state="translated">현재 요청 된 페이지로 연결되는 이전 웹 페이지의 주소입니다.</target>
        </trans-unit>
        <trans-unit id="b7f363462ba0e835d6efe5f6a4a754557a175395" translate="yes" xml:space="preserve">
          <source>The allow list is &lt;code&gt;'self'&lt;/code&gt;.</source>
          <target state="translated">허용 목록은 &lt;code&gt;'self'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3a13999e890799ba528c66f4b10225cdce017aa2" translate="yes" xml:space="preserve">
          <source>The allowlist is a list of origins that takes one of the following values:</source>
          <target state="translated">허용 목록은 다음 값 중 하나를 취하는 원점 목록입니다.</target>
        </trans-unit>
        <trans-unit id="393e3579b1c31fc17a2e5e0bd2a662711c3a5e42" translate="yes" xml:space="preserve">
          <source>The alternative and de-facto standard versions of this header are the &lt;a href=&quot;x-forwarded-for&quot;&gt;&lt;code&gt;X-Forwarded-For&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;x-forwarded-host&quot;&gt;&lt;code&gt;X-Forwarded-Host&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;x-forwarded-proto&quot;&gt;&lt;code&gt;X-Forwarded-Proto&lt;/code&gt;&lt;/a&gt; headers.</source>
          <target state="translated">이 헤더의 대체 표준 표준 버전은 &lt;a href=&quot;x-forwarded-for&quot;&gt; &lt;code&gt;X-Forwarded-For&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;x-forwarded-host&quot;&gt; &lt;code&gt;X-Forwarded-Host&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;x-forwarded-proto&quot;&gt; &lt;code&gt;X-Forwarded-Proto&lt;/code&gt; &lt;/a&gt; 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="87766695ac6340c40537ef09e93a85866ad2734b" translate="yes" xml:space="preserve">
          <source>The amount of device RAM can be used as a fingerprinting variable, so values for the header are intentionally coarse to reduce the potential for its misuse. The header takes on the following values: &lt;code&gt;0.25&lt;/code&gt;, &lt;code&gt;0.5&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;8&lt;/code&gt;.</source>
          <target state="translated">장치 RAM의 양은 핑거 프린팅 변수로 사용될 수 있으므로 헤더의 값은 오용 가능성을 줄이기 위해 의도적으로 대략적으로 지정됩니다. 헤더는 &lt;code&gt;0.25&lt;/code&gt; , &lt;code&gt;0.5&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;4&lt;/code&gt; , &lt;code&gt;8&lt;/code&gt; 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="55a9a290f76d786d7b3d83d441f76e13bf0f3dcc" translate="yes" xml:space="preserve">
          <source>The app:categories element can contain a &quot;fixed&quot; attribute, with a
   value of either &quot;yes&quot; or &quot;no&quot;, indicating whether the list of
   categories is a fixed or an open set.  The absence of the &quot;fixed&quot;
   attribute is equivalent to the presence of a &quot;fixed&quot; attribute with a
   value of &quot;no&quot;.

   Alternatively, the app:categories element MAY contain an &quot;href&quot;
   attribute, whose value MUST be an IRI reference identifying a
   Category Document.  If the &quot;href&quot; attribute is provided, the app:
   categories element MUST be empty and MUST NOT have the &quot;fixed&quot; or
   &quot;scheme&quot; attributes.</source>
          <target state="translated">app : categories 요소는 범주 목록이 고정 세트인지 또는 열린 세트인지를 나타내는 &quot;yes&quot;또는 &quot;no&quot;값을 갖는 &quot;fixed&quot;속성을 포함 할 수 있습니다. &quot;fixed&quot;속성이 없으면 &quot;no&quot;값을 가진 &quot;fixed&quot;속성이있는 것과 같습니다. 또는 app : categories 요소는 &quot;href&quot;속성을 포함 할 수 있으며, 그 값은 카테고리 문서를 식별하는 IRI 참조 여야합니다. &quot;href&quot;속성이 제공되는 경우 app : categories 요소는 비어 있어야하며 &quot;fixed&quot;또는 &quot;scheme&quot;속성이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="41b7617765ea8bb8c7b2ba0dc382b82fa950ce4a" translate="yes" xml:space="preserve">
          <source>The app:collection element MAY appear as a child of an atom:feed or
   atom:source element in an Atom Feed Document.  Its content identifies
   a Collection by which new Entries can be added to appear in the feed.
   When it appears in an atom:feed or atom:source element, the app:
   collection element is considered foreign markup as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;6 of [RFC4287]&lt;/a&gt;.</source>
          <target state="translated">app : collection 요소는 Atom Feed Document에서 atom : feed 또는 atom : source 요소의 자식으로 나타날 수 있습니다. 컨텐츠는 새 항목을 추가하여 피드에 표시 할 수있는 콜렉션을 식별합니다. atom : feed 또는 atom : source 요소에 나타나는 경우 app : collection 요소는 &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;[RFC4287]의 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;섹션 &lt;/a&gt;6에 정의 된대로 외부 마크 업으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="784a9192f7175993193ec2889d2de31d1902f984" translate="yes" xml:space="preserve">
          <source>The app:collection element MUST contain an &quot;href&quot; attribute, whose
   value gives the IRI of the Collection.</source>
          <target state="translated">app : collection 요소는 반드시 &quot;href&quot;속성을 포함해야하며, 그 값은 Collection의 IRI를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7a08eb3336f8f673ed58387417f07a2fa35ffa86" translate="yes" xml:space="preserve">
          <source>The app:workspace element MUST contain one &quot;atom:title&quot; element (as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;]), giving a human-readable title for the
   Workspace.</source>
          <target state="translated">app : workspace 요소는 하나의 &quot;atom : title&quot;요소 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]에 정의 된대로)를 포함해야 하며, 작업 영역에 대한 사람이 읽을 수있는 제목을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="31dd4c2d31d8ecfa729e47a41ac595124e30799a" translate="yes" xml:space="preserve">
          <source>The application/http type can be used to enclose a pipeline of one or
   more HTTP request or response messages (not intermixed).

   Type name:  application

   Subtype name:  http

   Required parameters:  N/A

   Optional parameters:  version, msgtype

      version:  The HTTP-version number of the enclosed messages (e.g.,
         &quot;1.1&quot;).  If not present, the version can be determined from the
         first line of the body. 

      msgtype:  The message type -- &quot;request&quot; or &quot;response&quot;.  If not
         present, the type can be determined from the first line of the
         body.

   Encoding considerations:  HTTP messages enclosed by this type are in
      &quot;binary&quot; format; use of an appropriate Content-Transfer-Encoding
      is required when transmitted via email.

   Security considerations:  see &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;

   Interoperability considerations:  N/A

   Published specification:  This specification (see &lt;a href=&quot;#section-8.3.2&quot;&gt;Section 8.3.2&lt;/a&gt;).

   Applications that use this media type:  N/A

   Fragment identifier considerations:  N/A

   Additional information:

      Deprecated alias names for this type:  N/A

      Magic number(s):  N/A

      File extension(s):  N/A

      Macintosh file type code(s):  N/A

   Person and email address to contact for further information:
      See Authors' Addresses section.

   Intended usage:  COMMON

   Restrictions on usage:  N/A

   Author:  See Authors' Addresses section.

   Change controller:  IESG</source>
          <target state="translated">application / http 유형을 사용하여 하나 이상의 HTTP 요청 또는 응답 메시지 (혼합되지 않음)의 파이프 라인을 묶을 수 있습니다. 유형 이름 : application 하위 유형 이름 : http 필수 매개 변수 : 해당 사항 없음 선택적 매개 변수 : version, msgtype version : 동봉 된 메시지의 HTTP 버전 번호 (예 : &quot;1.1&quot;). 없으면 버전은 본문의 첫 번째 줄에서 확인할 수 있습니다. msgtype : 메시지 유형- &quot;요청&quot;또는 &quot;응답&quot;. 존재하지 않는 경우, 신체의 첫 번째 라인에서 유형을 결정할 수 있습니다. 인코딩 고려 사항 :이 유형으로 묶인 HTTP 메시지는 &quot;이진&quot;형식입니다. 이메일을 통해 전송할 때는 적절한 콘텐츠 전송 인코딩을 사용해야합니다. 보안 고려 사항 :&lt;a href=&quot;#section-9&quot;&gt;섹션 9 참조&lt;/a&gt; 상호 운용성 고려 사항 : 해당 사항 없음 게시 된 사양 :이 사양 ( &lt;a href=&quot;#section-8.3.2&quot;&gt;섹션 8.3.2&lt;/a&gt; 참조 ). 이 미디어 유형을 사용하는 응용 프로그램 : 해당 사항 없음 조각 식별자 고려 사항 : 해당 사항 없음 추가 정보 :이 유형에 대해 더 이상 사용되지 않는 별칭 이름 : 해당 사항 없음 매직 번호 : 해당 사항 없음 파일 확장자 : 해당 없음 Macintosh 파일 유형 코드 : 해당 사항 없음 자세한 내용은 연락 할 사람과 이메일 주소 : 작성자 주소 섹션을 참조하십시오. 용도 : COMMON 사용 제한 : 해당 사항 없음 저자 : 저자 주소 섹션을 참조하십시오. 컨트롤러 변경 : IESG</target>
        </trans-unit>
        <trans-unit id="79aee5e9b1bd229aa07d406e676deb28b27cc227" translate="yes" xml:space="preserve">
          <source>The article &lt;a href=&quot;cors&quot;&gt;covering the HTTP headers used by both clients and servers is here&lt;/a&gt;, and should be considered prerequisite reading.</source>
          <target state="translated">&lt;a href=&quot;cors&quot;&gt;클라이언트와 서버 모두에서 사용하는 HTTP 헤더를 다루는&lt;/a&gt; 기사 가 여기 있으며 전제 조건으로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="06b805071003db0b0483630bf1631444f9c65f63" translate="yes" xml:space="preserve">
          <source>The asterisk is a special value representing any resource.</source>
          <target state="translated">별표는 모든 리소스를 나타내는 특수한 값입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
