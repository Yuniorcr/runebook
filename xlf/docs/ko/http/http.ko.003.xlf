<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="a7213ccaea2b1f5a17c04d5d00a491991e7405ff" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;lt;cookie-name&amp;gt;&lt;/code&gt; can be any US-ASCII characters, except control characters, spaces, or tabs. It also must not contain a separator character like the following: &lt;code&gt;( ) &amp;lt; &amp;gt; @ , ; : \ &quot; / [ ] ? = { }&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;cookie-name&amp;gt;&lt;/code&gt; 제어 문자, 공백 또는 탭을 제외하고는 US-ASCII 문자가 될 수 있습니다. 또한 다음과 같은 구분 문자를 포함해서는 안됩니다. &lt;code&gt;( ) &amp;lt; &amp;gt; @ , ; : \ &quot; / [ ] ? = { }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16b2a81bf240653adf4ae5646645097e3700e614" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;lt;cookie-value&amp;gt;&lt;/code&gt; can optionally be set in double quotes and any US-ASCII characters excluding CTLs, whitespace, double quotes, comma, semicolon, and backslash are allowed. &lt;strong&gt;Encoding&lt;/strong&gt;: Many implementations perform URL encoding on cookie values, however it is not required per the RFC specification. It does help satisfying the requirements about which characters are allowed for &amp;lt;cookie-value&amp;gt; though.</source>
          <target state="translated">&lt;code&gt;&amp;lt;cookie-value&amp;gt;&lt;/code&gt; 선택적 따옴표와의 CTL, 공백, 큰 따옴표, 쉼표, 세미콜론을 제외한 모든 US-ASCII 문자로 설정할 수 있으며, 백 슬래시는 사용할 수 있습니다. &lt;strong&gt;인코딩&lt;/strong&gt; : 많은 구현에서 쿠키 값에 대한 URL 인코딩을 수행하지만 RFC 사양에 따라 필요하지는 않습니다. &amp;lt;cookie-value&amp;gt;에 허용되는 문자에 대한 요구 사항을 충족시키는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="e3f20af8a4d172bba05887f769d27d85c6a8c07e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&amp;lt;cookie-value&amp;gt;&lt;/code&gt; can optionally be wrapped in double quotes and include any US-ASCII characters excluding control characters, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Whitespace&quot;&gt;Whitespace&lt;/a&gt;, double quotes, comma, semicolon, and backslash. &lt;strong&gt;Encoding&lt;/strong&gt;: Many implementations perform URL encoding on cookie values, however it is not required per the RFC specification. It does help satisfying the requirements about which characters are allowed for &amp;lt;cookie-value&amp;gt; though.</source>
          <target state="translated">&lt;code&gt;&amp;lt;cookie-value&amp;gt;&lt;/code&gt; 옵션으로 큰 따옴표로 감싸이고, 제어 문자를 제외한 모든 US-ASCII 문자를 포함 할 수있다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Whitespace&quot;&gt;공백&lt;/a&gt; , 큰 따옴표, 쉼표, 세미콜론, 그리고 백 슬래시. &lt;strong&gt;인코딩&lt;/strong&gt; : 많은 구현에서 쿠키 값에 대해 URL 인코딩을 수행하지만 RFC 사양에 따라 필요하지 않습니다. 하지만 &amp;lt;cookie-value&amp;gt;에 허용되는 문자에 대한 요구 사항을 충족하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="5f819db31cf5179b914aa0bbc4b051d20a15499c" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ruellan-http-accept-push-policy-00#section-3.2&quot;&gt;Push-Policy&lt;/a&gt;&lt;/code&gt; defines the server behaviour regarding push when processing a request.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ruellan-http-accept-push-policy-00#section-3.2&quot;&gt;Push-Policy&lt;/a&gt;&lt;/code&gt; 요청을 처리 할 때 푸시에 대한 서버 동작을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="907291403f83bafff1a5018284ddb5cda5ef87c1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Host&lt;/code&gt; header field must be sent in all HTTP/1.1 request messages. A &lt;a href=&quot;../status/400&quot;&gt;&lt;code&gt;400&lt;/code&gt;&lt;/a&gt; (Bad Request) status code may be sent to any HTTP/1.1 request message that lacks a &lt;code&gt;Host&lt;/code&gt; header field or that contains more than one.</source>
          <target state="translated">&lt;code&gt;Host&lt;/code&gt; 헤더 필드는 모든 HTTP / 1.1 요청 메시지로 전송해야합니다. &lt;a href=&quot;../status/400&quot;&gt; &lt;code&gt;400&lt;/code&gt; &lt;/a&gt; (잘못된 요청) 상태 코드가없는 모든 HTTP / 1.1 요구 메시지로 전송 될 수 있습니다 &lt;code&gt;Host&lt;/code&gt; 헤더 필드를 또는 하나 이상의 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd38adbfb297f98e4845f58ef168d327990960e8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Host&lt;/code&gt; header field must be sent in all HTTP/1.1 request messages. A &lt;a href=&quot;../status/400&quot;&gt;&lt;code&gt;400&lt;/code&gt;&lt;/a&gt; (Bad Request) status code will be sent to any HTTP/1.1 request message that lacks a &lt;code&gt;Host&lt;/code&gt; header field or contains more than one.</source>
          <target state="translated">&lt;code&gt;Host&lt;/code&gt; 헤더 필드는 모든 HTTP / 1.1 요청 메시지로 전송해야합니다. &lt;a href=&quot;../status/400&quot;&gt; &lt;code&gt;400&lt;/code&gt; &lt;/a&gt; (잘못된 요청) 상태 코드가없는 모든 HTTP / 1.1 요구 메시지로 전송됩니다 &lt;code&gt;Host&lt;/code&gt; 헤더 필드를 또는 하나 이상 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d493f4b34b837ecbf516ab3be315bb7e5800bd7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Large-Allocation&lt;/code&gt; header was ignored due to the document not being loaded out of process.</source>
          <target state="translated">&lt;code&gt;Large-Allocation&lt;/code&gt; 헤더는 프로세스로로드되지 않는 문서에 의한 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="b52f033ccd0a61255fd618ddae3d133b3a87b36a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Large-Allocation&lt;/code&gt; header was ignored due to the load being triggered by a non-GET request.</source>
          <target state="translated">&lt;code&gt;Large-Allocation&lt;/code&gt; 부하에 비 GET 요청에 의해 트리거되는 때문에 헤더는 무시되었습니다.</target>
        </trans-unit>
        <trans-unit id="8b66ecc22d4701e215c7c43a0496c165504db343" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Large-Allocation&lt;/code&gt; header was ignored due to the presence of windows which have a reference to this browsing context through the frame hierarchy or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/opener&quot;&gt;&lt;code&gt;window.opener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Large-Allocation&lt;/code&gt; 헤더는 프레임 계층 구조 또는 통해이 검색 컨텍스트에 대한 참조가 윈도우의 존재로 인해 무시 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/opener&quot;&gt; &lt;code&gt;window.opener&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73a9512193aaddbed5822d47b67cd6e8914618f0" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;PATCH&lt;/code&gt; is not necessarily idempotent, although it can be. Contrast this with &lt;a href=&quot;put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;; which is always idempotent. The word &quot;idempotent&quot; means that any number of repeated, identical requests will leave the resource in the same state. For example if an auto-incrementing counter field is an integral part of the resource, then a &lt;a href=&quot;put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; will naturally overwrite it (since it overwrites everything), but not necessarily so for &lt;code&gt;PATCH&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;PATCH&lt;/code&gt; 가 될 수 있지만 반드시 멱등되지 않습니다. 이것을 &lt;a href=&quot;put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 와 대조하십시오 . 항상 멱 등성입니다. &quot;멱 등성&quot;이라는 단어는 반복되는 동일한 요청이 자원을 동일한 상태로 남겨 두는 것을 의미합니다. 예를 들어 자동 증가 카운터 필드가 리소스의 필수 부분 인 경우 &lt;a href=&quot;put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 는 자연스럽게이를 덮어 쓰지만 (모든 것을 덮어 쓰기 때문에) &lt;code&gt;PATCH&lt;/code&gt; 의 경우 반드시 그런 것은 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="c8022f4e83935a93ef3b8b1c2d930ed06dced354" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;PATCH&lt;/code&gt; request is considered a set of instructions on how to modify a resource. Contrast this with &lt;a href=&quot;put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;; which is a complete representation of a resource.</source>
          <target state="translated">&lt;code&gt;PATCH&lt;/code&gt; 요청은 리소스를 수정하는 방법에 대한 지침의 집합으로 간주됩니다. 이것을 &lt;a href=&quot;put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 와 대조하십시오 . 자원의 완전한 표현입니다.</target>
        </trans-unit>
        <trans-unit id="148adc34b3c03dd4552c4ce02841588fbe7d2b17" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;POST&lt;/code&gt; request is typically sent via an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML form&lt;/a&gt; and results in a change on the server. In this case, the content type is selected by putting the adequate string in the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#attr-enctype&quot;&gt;enctype&lt;/a&gt;&lt;/code&gt; attribute of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;&lt;/a&gt; element or the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-formenctype&quot;&gt;formenctype&lt;/a&gt;&lt;/code&gt; attribute of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt;&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button&quot;&gt;&lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt;&lt;/a&gt; elements:</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; 의 요청은 일반적 통해 전송되는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML 양식&lt;/a&gt; 서버의 변화 및 결과. 이 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt; &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form#attr-enctype&quot;&gt;enctype&lt;/a&gt;&lt;/code&gt; 속성 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input&quot;&gt; &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button&quot;&gt; &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#attr-formenctype&quot;&gt;formenctype&lt;/a&gt;&lt;/code&gt; 속성에 적절한 문자열을 입력하여 컨텐츠 유형을 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9a09061e55ef0722388221ef70fbf98831901fc" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Referer&lt;/code&gt; header is not sent by browsers if:</source>
          <target state="translated">다음과 같은 경우 브라우저가 &lt;code&gt;Referer&lt;/code&gt; 헤더를 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b7de4dc33844cb3c83cd7c6ece8fd1f67d772660" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Tk&lt;/code&gt; header for a resource that claims not to be tracking would look like:</source>
          <target state="translated">추적하지 않는다고 주장하는 리소스 의 &lt;code&gt;Tk&lt;/code&gt; 헤더는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3a39de192b8c94e0bdb22f2bcb149d7e553934cb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;data&lt;/code&gt; URL provides a file within a file, which can potentially be very wide relative to the width of the enclosing document. As a URL, the &lt;code&gt;data&lt;/code&gt; should be formatable with whitespace (linefeed, tab, or spaces), but there are practical issues that arise &lt;a href=&quot;http://bugzilla.mozilla.org/show_bug.cgi?id=73026#c12&quot;&gt;when using base64 encoding&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; URL은 잠재적 둘러싸 문서의 너비에 비해 매우 넓은 수있는 파일 내의 파일을 제공한다. URL 은 공백 (줄 바꿈, 탭 또는 공백)을 사용 하여 &lt;code&gt;data&lt;/code&gt; 를 형식화 할 수 있어야하지만 &lt;a href=&quot;http://bugzilla.mozilla.org/show_bug.cgi?id=73026#c12&quot;&gt;base64 인코딩을 사용할 때&lt;/a&gt; 발생하는 실제 문제가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f62e0b29365c072d5d290c0cb67e2e50ff07068" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;multipart/form-data&lt;/code&gt; body requires a &lt;code&gt;Content-Disposition&lt;/code&gt; header to provide information for each subpart of the form (e.g. for every form field and any files that are part of field data). The first directive is always &lt;code&gt;form-data&lt;/code&gt;, and the header &lt;em&gt;must&lt;/em&gt; also include a &lt;code&gt;name&lt;/code&gt; parameter to identify the relevant field. Additional directives are case-insensitive and have arguments that use quoted-string syntax after the &lt;code&gt;'='&lt;/code&gt; sign. Multiple parameters are separated by a semi-colon (&lt;code&gt;';'&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;multipart/form-data&lt;/code&gt; 본문이 요구 &lt;code&gt;Content-Disposition&lt;/code&gt; (모든 형태의 필드에 대한 예 및 필드 데이터의 일부인 파일) 형태로 각각의 서브 파트의 정보를 제공하는 헤더. 첫 번째 지시문은 항상 &lt;code&gt;form-data&lt;/code&gt; 이며 헤더 에는 관련 필드를 식별 하는 &lt;code&gt;name&lt;/code&gt; 매개 변수 도 포함 &lt;em&gt;되어야&lt;/em&gt; 합니다. 추가 지시문은 대소 문자를 구분하지 않으며 &lt;code&gt;'='&lt;/code&gt; 기호 뒤에 인용 문자열 구문을 사용하는 인수가 있습니다 . 여러 매개 변수는 세미콜론 ( &lt;code&gt;';'&lt;/code&gt; )으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="67ef0cbe7ad55aa4468b6292a11f980a072c57e1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;name&lt;/code&gt; with a value of &lt;code&gt;'_charset_'&lt;/code&gt; indicates that the part is not an HTML field, but the default charset to use for parts without explicit charset information.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 의 값을 &lt;code&gt;'_charset_'&lt;/code&gt; 부분은 HTML 필드 없음을 나타냅니다하지만, 디폴트의 캐릭터 세트는 명시 적 캐릭터 정보가없는 부품에 사용.</target>
        </trans-unit>
        <trans-unit id="77ca7e4cfdb62ea74f42d6c168a3d1427f68fc26" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;product token&lt;/em&gt; is a name followed by a '&lt;code&gt;/&lt;/code&gt;' and a version number, like &lt;code&gt;Firefox/4.0.1&lt;/code&gt;. There may be as many of them as the user-agent wants. A &lt;em&gt;comment&lt;/em&gt; is a free string delimited by parentheses. Obviously parentheses cannot be used in that string. The inner format of a comment is not defined by the standard, though several browser put several tokens in it, separated by '&lt;code&gt;;&lt;/code&gt;'.</source>
          <target state="translated">&lt;em&gt;제품 토큰&lt;/em&gt; 은 '다음에 이름 &lt;code&gt;/&lt;/code&gt; 같은'및 버전 번호, &lt;code&gt;Firefox/4.0.1&lt;/code&gt; . 사용자 에이전트가 원하는 수만큼이있을 수 있습니다. &lt;em&gt;코멘트는&lt;/em&gt; 괄호로 구분없는 문자열입니다. 해당 문자열에는 괄호를 사용할 수 없습니다. 주석의 내부 형식은 표준에 의해 정의되지 않지만, 일부 브라우저는 여러 개의 토큰을 넣습니다 &lt;code&gt;;&lt;/code&gt; '.</target>
        </trans-unit>
        <trans-unit id="7807903fa1b0b7939213e9e4f5b3217c04d49395" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;start-line&lt;/em&gt; describing the requests to be implemented, or its status of whether successful or a failure. This start-line is always a single line.</source>
          <target state="translated">구현 요청 또는 성공 여부에 대한 &lt;em&gt;시작 라인&lt;/em&gt; . 이 시작 줄은 항상 한 줄입니다.</target>
        </trans-unit>
        <trans-unit id="93859c81ff65c5134b0dd141e4cbca2ab3420924" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;status code&lt;/em&gt;, indicating success or failure of the request. Common status codes are &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;status/404&quot;&gt;&lt;code&gt;404&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;status/302&quot;&gt;&lt;code&gt;302&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;상태 코드&lt;/em&gt; 요청의 성공 또는 실패를 나타냅니다. 일반적인 상태 코드는 &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;status/404&quot;&gt; &lt;code&gt;404&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;status/302&quot;&gt; &lt;code&gt;302&lt;/code&gt; 입니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="76c2a47356f2a849271ea7cc25822c2941eeef27" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;status text&lt;/em&gt;. A brief, purely informational, textual description of the status code to help a human understand the HTTP message.</source>
          <target state="translated">&lt;em&gt;상태 텍스트&lt;/em&gt; . 사람이 HTTP 메시지를 이해하는 데 도움이되는 상태 코드에 대한 간략하고 순수한 정보 텍스트 설명.</target>
        </trans-unit>
        <trans-unit id="0559ada531b9179dd1b1f6a65154a22a437ad6c4" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;Multipurpose Internet Mail Extensions (MIME) type&lt;/strong&gt; is a standard that indicates the nature and format of a document, file, or assortment of bytes. It is defined and standardized in &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;IETF RFC 6838&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;MIME (Multipurpose Internet Mail Extensions) 형식은&lt;/strong&gt; 바이트의 문서, 파일 또는 구색의 성격과 형식을 나타내는 표준입니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;IETF RFC 6838&lt;/a&gt; 에서 정의되고 표준화되었습니다 .</target>
        </trans-unit>
        <trans-unit id="06fe2028c6d41d5f963c85bb23a2f9582052e0be" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;Proxy Auto-Configuration (PAC)&lt;/strong&gt; file is a JavaScript function that determines whether web browser requests (HTTP, HTTPS, and FTP) go directly to the destination or are forwarded to a web proxy server. The JavaScript function contained in the PAC file defines the function:</source>
          <target state="translated">&lt;strong&gt;프록시 자동 구성 (PAC)&lt;/strong&gt; 파일은 웹 브라우저 요청 (HTTP, HTTPS 및 FTP)을 대상으로 직접 이동 또는 웹 프록시 서버로 전달할지 여부를 결정하는 자바 스크립트 함수이다. PAC 파일에 포함 된 JavaScript 함수는 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="921d1ae1d227879cc9b76f47ae6c47c89749c0e7" translate="yes" xml:space="preserve">
          <source>A &lt;strong&gt;media type&lt;/strong&gt; (also known as a &lt;strong&gt;Multipurpose Internet Mail Extensions or MIME type&lt;/strong&gt;) is a standard that indicates the nature and format of a document, file, or assortment of bytes. It is defined and standardized in IETF's &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;미디어 타입&lt;/strong&gt; (이라고도 &lt;strong&gt;다목적 인터넷 메일 확장 또는 MIME 타입&lt;/strong&gt; ) 바이트의 문서, 파일 또는 구색의 성격과 형식을 나타내는 표준입니다. IETF의 &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt; 에서 정의되고 표준화되었습니다 .</target>
        </trans-unit>
        <trans-unit id="32908568fcbbdd8ea0e3d262e49fd8c59b6cf1c5" translate="yes" xml:space="preserve">
          <source>A COPY method invocation MUST NOT duplicate any write locks active on
   the source.  However, as previously noted, if the COPY copies the
   resource into a collection that is locked with a depth-infinity lock,
   then the resource will be added to the lock.

   A successful MOVE request on a write locked resource MUST NOT move
   the write lock with the resource.  However, if there is an existing
   lock at the destination, the server MUST add the moved resource to
   the destination lock scope.  For example, if the MOVE makes the
   resource a child of a collection that has a depth-infinity lock, then
   the resource will be added to that collection's lock.  Additionally,
   if a resource with a depth-infinity lock is moved to a destination
   that is within the scope of the same lock (e.g., within the URL
   namespace tree covered by the lock), the moved resource will again be
   added to the lock.  In both these examples, as specified in
   &lt;a href=&quot;#section-7.5&quot;&gt;Section 7.5&lt;/a&gt;, an If header must be submitted containing a lock token
   for both the source and destination.</source>
          <target state="translated">COPY 메소드 호출은 소스에서 활성화 된 쓰기 잠금을 복제해서는 안됩니다 (MUST NOT). 그러나 앞에서 언급했듯이 COPY가 자원을 깊이 무한대 잠금으로 잠긴 콜렉션에 복사하면 자원이 잠금에 추가됩니다. 쓰기 잠금 리소스에 대한 성공적인 MOVE 요청은 리소스와 함께 쓰기 잠금을 이동해서는 안됩니다 (MUST NOT). 그러나 대상에 기존 잠금이있는 경우 서버는 이동 된 리소스를 대상 잠금 범위에 추가해야합니다. 예를 들어, MOVE가 자원을 깊이 무한대 잠금이있는 콜렉션의 하위로 만들면 해당 자원이 해당 콜렉션의 잠금에 추가됩니다. 또한 깊이 무한대 잠금이있는 리소스가 동일한 잠금 범위 내에있는 대상으로 이동 한 경우 (예 :잠금이 적용되는 URL 네임 스페이스 트리 내에서 이동 된 리소스가 다시 잠금에 추가됩니다. 이 두 가지 예에서 &lt;a href=&quot;#section-7.5&quot;&gt;7.5 절&lt;/a&gt; , 소스와 대상 모두에 대한 잠금 토큰을 포함하는 If 헤더를 제출해야합니다.</target>
        </trans-unit>
        <trans-unit id="54ccf84b84ef6409cbbed9c34674f05d1e7198a6" translate="yes" xml:space="preserve">
          <source>A Condition that consists of a single entity-tag or state-token
   evaluates to true if the resource matches the described state (where
   the individual matching functions are defined below in
   &lt;a href=&quot;#section-10.4.4&quot;&gt;Section 10.4.4&lt;/a&gt;).  Prefixing it with &quot;Not&quot; reverses the result of the
   evaluation (thus, the &quot;Not&quot; applies only to the subsequent entity-tag
   or state-token).

   Each List production describes a series of conditions.  The whole
   list evaluates to true if and only if each condition evaluates to
   true (that is, the list represents a logical conjunction of
   Conditions).

   Each No-tag-list and Tagged-list production may contain one or more
   Lists.  They evaluate to true if and only if any of the contained
   lists evaluates to true (that is, if there's more than one List, that
   List sequence represents a logical disjunction of the Lists). 

   Finally, the whole If header evaluates to true if and only if at
   least one of the No-tag-list or Tagged-list productions evaluates to
   true.  If the header evaluates to false, the server MUST reject the
   request with a 412 (Precondition Failed) status.  Otherwise,
   execution of the request can proceed as if the header wasn't present.</source>
          <target state="translated">단일 엔티티 태그 또는 상태 토큰으로 구성된 조건은 리소스가 설명 된 상태와 일치하면 true로 평가됩니다 (여기서 일치하는 함수는 아래 &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt; 에서 정의 됨). ). 접두사에 &quot;Not&quot;을 붙이면 평가 결과가 반대로됩니다 (따라서 &quot;Not&quot;은 후속 엔티티 태그 또는 상태 토큰에만 적용됩니다). 각 List 프로덕션은 일련의 조건을 설명합니다. 각 조건이 true로 평가되는 경우에만 (즉, 목록이 조건의 논리적 연결을 나타내는 경우) 전체 목록이 true로 평가됩니다. 각 태그 없음 목록 및 태그 목록 생성에는 하나 이상의 목록이 포함될 수 있습니다. 포함 된 목록 중 하나라도 true로 평가되는 경우에만 (즉, 둘 이상의 목록이있는 경우 해당 목록 순서는 목록의 논리적 분리를 나타냄) 참으로 평가됩니다. 마지막으로 No-tag-list 또는 Tagged-list 프로덕션 중 하나 이상이 true로 평가되는 경우에만 전체 If 헤더가 true로 평가됩니다. 헤더가 false로 평가되면서버는 412 (사전 조건 실패) 상태의 요청을 거부해야합니다. 그렇지 않으면 요청이 헤더가없는 것처럼 진행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ca49fbd841006f7b8c4f68cfeb745b6f799b83d" translate="yes" xml:space="preserve">
          <source>A DAV-compliant resource can advertise several classes of compliance.
   A client can discover the compliance classes of a resource by
   executing OPTIONS on the resource and examining the &quot;DAV&quot; header
   which is returned.  Note particularly that resources, rather than
   servers, are spoken of as being compliant.  That is because
   theoretically some resources on a server could support different
   feature sets.  For example, a server could have a sub-repository
   where an advanced feature like versioning was supported, even if that
   feature was not supported on all sub-repositories.

   Since this document describes extensions to the HTTP/1.1 protocol,
   minimally all DAV-compliant resources, clients, and proxies MUST be
   compliant with [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].

   A resource that is class 2 or class 3 compliant must also be class 1
   compliant.</source>
          <target state="translated">DAV 호환 리소스는 여러 클래스의 준수를 알릴 수 있습니다. 클라이언트는 자원에서 OPTIONS를 실행하고 리턴되는 &quot;DAV&quot;헤더를 검사하여 자원의 준수 클래스를 발견 할 수 있습니다. 특히 서버가 아닌 리소스는 호환되는 것으로 언급됩니다. 이론적으로 서버의 일부 리소스는 다른 기능 세트를 지원할 수 있기 때문입니다. 예를 들어, 서버는 해당 기능이 모든 하위 저장소에서 지원되지 않더라도 버전 관리와 같은 고급 기능이 지원되는 하위 저장소를 가질 수 있습니다. 이 문서는 HTTP / 1.1 프로토콜에 대한 확장을 설명하므로 최소한 모든 DAV 호환 리소스, 클라이언트 및 프록시는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]. 클래스 2 또는 클래스 3을 준수하는 리소스도 클래스 1을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="f86021a073cb3d0361968791f30494aec6a11bf5" translate="yes" xml:space="preserve">
          <source>A LOCK request to an existing resource will create a lock on the
   resource identified by the Request-URI, provided the resource is not
   already locked with a conflicting lock.  The resource identified in
   the Request-URI becomes the root of the lock.  LOCK method requests
   to create a new lock MUST have an XML request body.  The server MUST
   preserve the information provided by the client in the 'owner'
   element in the LOCK request.  The LOCK request MAY have a Timeout
   header.

   When a new lock is created, the LOCK response:

   o  MUST contain a body with the value of the DAV:lockdiscovery
      property in a prop XML element.  This MUST contain the full
      information about the lock just granted, while information about
      other (shared) locks is OPTIONAL.

   o  MUST include the Lock-Token response header with the token
      associated with the new lock.</source>
          <target state="translated">기존 리소스에 대한 잠금 요청은 리소스가 충돌하는 잠금으로 아직 잠겨 있지 않은 경우 Request-URI로 식별 된 리소스에 대한 잠금을 만듭니다. Request-URI에서 식별 된 자원은 잠금의 루트가됩니다. 새 잠금을 작성하기위한 LOCK 메소드 요청에는 XML 요청 본문이 있어야합니다. 서버는 반드시 클라이언트가 제공 한 정보를 LOCK 요청의 'owner'요소에 보존해야합니다. 잠금 요청은 타임 아웃 헤더를 가질 수있다. 새 잠금이 작성되면 LOCK 응답은 다음과 같습니다. o prop XML 요소에 DAV : lockdiscovery 특성 값을 가진 본문이 있어야합니다. 여기에는 방금 부여 된 잠금에 대한 전체 정보가 포함되어야하며 다른 (공유) 잠금에 대한 정보는 선택 사항입니다.o 반드시 새로운 잠금과 관련된 토큰과 함께 잠금 토큰 응답 헤더를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="b5ec04e796ad556a9a01172c14afcf29870510e8" translate="yes" xml:space="preserve">
          <source>A Last-Modified time, when used as a validator in a request, is
   implicitly weak unless it is possible to deduce that it is strong,
   using the following rules:

   o  The validator is being compared by an origin server to the actual
      current validator for the representation and,

   o  That origin server reliably knows that the associated
      representation did not change twice during the second covered by
      the presented validator.

   or

   o  The validator is about to be used by a client in an
      If-Modified-Since, If-Unmodified-Since, or If-Range header field,
      because the client has a cache entry for the associated
      representation, and

   o  That cache entry includes a Date value, which gives the time when
      the origin server sent the original response, and

   o  The presented Last-Modified time is at least 60 seconds before the
      Date value.

   or

   o  The validator is being compared by an intermediate cache to the
      validator stored in its cache entry for the representation, and

   o  That cache entry includes a Date value, which gives the time when
      the origin server sent the original response, and

   o  The presented Last-Modified time is at least 60 seconds before the
      Date value. 

   This method relies on the fact that if two different responses were
   sent by the origin server during the same second, but both had the
   same Last-Modified time, then at least one of those responses would
   have a Date value equal to its Last-Modified time.  The arbitrary
   60-second limit guards against the possibility that the Date and
   Last-Modified values are generated from different clocks or at
   somewhat different times during the preparation of the response.  An
   implementation MAY use a value larger than 60 seconds, if it is
   believed that 60 seconds is too short.</source>
          <target state="translated">요청에서 유효성 검사기로 사용되는 Last-Modified 시간은 다음 규칙을 사용하여 강력하다고 추론 할 수 없으면 암시 적으로 약합니다. o 유효성 검사기는 원본 서버에서 실제 유효성 검사기와 비교됩니다. o 원 서버는 제시된 검증 인이 다루는 두 번째 동안 관련된 표현이 두 번 변하지 않았다는 것을 확실하게 알고있다. 또는 o 클라이언트가 관련 표현에 대한 캐시 항목을 가지고 있기 때문에 유효성 검사기가 If-Modified-Since, If-Unmodified-Since 또는 If-Range 헤더 필드에서 클라이언트가 사용하려고합니다. o 해당 캐시 항목 원본 서버가 원래 응답을 보낸 시간을 제공하는 Date 값을 포함합니다.o 제시된 Last-Modified 시간은 Date 값보다 적어도 60 초 전입니다. 또는 o 유효성 검사기가 표시를 위해 캐시 항목에 저장된 유효성 검사기와 중간 캐시를 비교하고 있습니다. o 해당 캐시 항목에는 원본 서버가 원래 응답을 보낸 시간을 제공하는 날짜 값이 포함되어 있습니다. 마지막으로 수정 한 시간은 날짜 값보다 적어도 60 초 전입니다. 이 방법은 동일한 초 동안 두 개의 서로 다른 응답이 오리진 서버에 의해 전송되었지만 둘 다 동일한 Last-Modified 시간을 가졌다면 해당 응답 중 하나 이상이 Last-Modified와 동일한 Date 값을 가질 것이라는 사실에 의존합니다. 시각.임의의 60 초 제한은 응답 준비 중에 날짜 및 마지막 수정 값이 다른 시계에서 또는 다소 다른 시간에 생성 될 가능성을 방지합니다. 구현에 60 초가 너무 짧은 경우 60 초보다 큰 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b3ff774d817ff6a5f8200f28c0299ad729f7f1f" translate="yes" xml:space="preserve">
          <source>A MIME type consists of a &lt;strong&gt;type&lt;/strong&gt; and a &lt;strong&gt;subtype&lt;/strong&gt; &amp;mdash; two strings separated by &lt;code&gt;/&lt;/code&gt;. No whitespace is allowed. The &lt;em&gt;type&lt;/em&gt; represents the category and can be a &lt;em&gt;discrete&lt;/em&gt; or a &lt;em&gt;multipart&lt;/em&gt; type. The &lt;em&gt;subtype&lt;/em&gt; is specific to each type.</source>
          <target state="translated">MIME 유형은 &lt;strong&gt;유형&lt;/strong&gt; 과 &lt;strong&gt;하위 유형 ( &lt;/strong&gt; &lt;code&gt;/&lt;/code&gt; 으로 구분 된 두 개의 문자열)으로 구성됩니다 . 공백은 허용되지 않습니다. &lt;em&gt;유형&lt;/em&gt; 카테고리를 나타내며 될 수 &lt;em&gt;이산&lt;/em&gt; 또는 &lt;em&gt;다중&lt;/em&gt; 타입. &lt;em&gt;하위 유형은&lt;/em&gt; 각 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="df3b4fd9f2c9a070d38b528649b2abf469edffda" translate="yes" xml:space="preserve">
          <source>A MIME type, but without any subtype. &lt;code&gt;image/*&lt;/code&gt; will match &lt;code&gt;image/png&lt;/code&gt;, &lt;code&gt;image/svg&lt;/code&gt;, &lt;code&gt;image/gif&lt;/code&gt; and any other image types.</source>
          <target state="translated">MIME 유형이지만 하위 유형이 없습니다. &lt;code&gt;image/*&lt;/code&gt; 는 &lt;code&gt;image/png&lt;/code&gt; , &lt;code&gt;image/svg&lt;/code&gt; , &lt;code&gt;image/gif&lt;/code&gt; 및 기타 이미지 유형과 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="5ad212a1da928bdf764389014591f982a86a3c0f" translate="yes" xml:space="preserve">
          <source>A MOVE with &quot;Depth: infinity&quot; instructs that the collection
   identified by the Request-URI be moved to the address specified in
   the Destination header, and all resources identified by its internal
   member URLs are to be moved to locations relative to it, recursively
   through all levels of the collection hierarchy.

   The MOVE method on a collection MUST act as if a &quot;Depth: infinity&quot;
   header was used on it.  A client MUST NOT submit a Depth header on a
   MOVE on a collection with any value but &quot;infinity&quot;. 

   Any headers included with MOVE MUST be applied in processing every
   resource to be moved with the exception of the Destination header.
   The behavior of the Destination header is the same as given for COPY
   on collections.

   When the MOVE method has completed processing, it MUST have created a
   consistent URL namespace at both the source and destination (see
   &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt; for the definition of namespace consistency).  However,
   if an error occurs while moving an internal collection, the server
   MUST NOT move any resources identified by members of the failed
   collection (i.e., the server must skip the error-causing subtree), as
   this would create an inconsistent namespace.  In this case, after
   detecting the error, the move operation SHOULD try to finish as much
   of the original move as possible (i.e., the server should still
   attempt to move other subtrees and the resources identified by their
   members that are not descendants of an error-causing collection).
   So, for example, if an infinite-depth move is performed on collection
   /a/, which contains collections /a/b/ and /a/c/, and an error occurs
   moving /a/b/, an attempt should still be made to try moving /a/c/.
   Similarly, after encountering an error moving a non-collection
   resource as part of an infinite-depth move, the server SHOULD try to
   finish as much of the original move operation as possible.

   If an error occurs with a resource other than the resource identified
   in the Request-URI, then the response MUST be a 207 (Multi-Status),
   and the errored resource's URL MUST appear with the specific error.

   The 424 (Failed Dependency) status code SHOULD NOT be returned in the
   207 (Multi-Status) response from a MOVE method.  These errors can be
   safely omitted because the client will know that the progeny of a
   resource could not be moved when the client receives an error for the
   parent.  Additionally, 201 (Created)/204 (No Content) responses
   SHOULD NOT be returned as values in 207 (Multi-Status) responses from
   a MOVE.  These responses can be safely omitted because they are the
   default success codes.</source>
          <target state="translated">&quot;Depth : infinity&quot;가있는 MOVE는 Request-URI로 식별 된 콜렉션이 Destination 헤더에 지정된 주소로 이동하고 내부 구성원 URL로 식별 된 모든 자원이이를 통해 해당 위치로 재귀 적으로 이동하도록 지시합니다. 컬렉션 계층의 모든 수준 컬렉션의 MOVE 메소드는 마치 &quot;Depth : infinity&quot;헤더가 사용 된 것처럼 작동해야합니다. 클라이언트는 &quot;무한대&quot;이외의 값을 가진 컬렉션의 MOVE에 깊이 헤더를 제출해서는 안됩니다. MOVE에 포함 된 헤더는 Destination 헤더를 제외하고 이동 될 모든 리소스를 처리하는 데 적용되어야합니다. Destination 헤더의 동작은 컬렉션에서 COPY에 대해 주어진 것과 동일합니다. MOVE 메소드가 처리를 완료하면소스와 대상 모두에서 일관된 URL 네임 스페이스를 작성해야합니다 (참조 &lt;a href=&quot;#section-5.1&quot;&gt;섹션 5.1&lt;/a&gt;네임 스페이스 일관성의 정의를 위해). 그러나 내부 컬렉션을 이동하는 동안 오류가 발생하면 서버는 실패한 컬렉션의 구성원이 식별 한 리소스를 이동해서는 안됩니다 (즉, 서버는 오류를 일으키는 하위 트리를 건너 뛰어야합니다). 이 경우, 오류를 감지 한 후 이동 조작은 가능한 한 많은 원래 이동을 완료해야합니다 (즉, 서버는 여전히 오류의 후손이 아닌 구성원이 식별 한 다른 서브 트리 및 자원을 이동하려고 시도해야합니다) -발생 원인). 예를 들어, / a / b / 및 / a / c / 콜렉션을 포함하는 / a / 콜렉션에서 무한 깊이 이동이 수행되고 / a / b /를 이동하는 중에 오류가 발생하면 시도는 여전히 수행되어야합니다. / a / c /를 움직여 보았습니다. 비슷하게,무한 깊이 이동의 일부로 수집되지 않은 리소스를 이동하는 동안 오류가 발생하면 서버는 가능한 한 많은 원래 이동 작업을 완료해야합니다. Request-URI에서 식별 된 자원 이외의 자원에서 오류가 발생하면 응답은 반드시 207 (다중 상태)이어야하며, 오류가 발생한 자원의 URL은 특정 오류와 함께 나타나야합니다. MOVE 메소드의 207 (Multi-Status) 응답으로 424 (Failed Dependency) 상태 코드를 반환해서는 안됩니다 (SHOULD NOT). 이 오류는 클라이언트가 상위에 대한 오류를 수신 할 때 자원의 자손을 이동할 수 없다는 것을 클라이언트가 알기 때문에 안전하게 생략 할 수 있습니다. 또한 201 (작성 됨) / 204 (콘텐츠 없음) 응답은 MOVE에서 207 (다중 상태) 응답의 값으로 반환되지 않아야합니다.이러한 응답은 기본 성공 코드이므로 안전하게 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e669f83c371fcfc2d6309646e47cad96a8d6939b" translate="yes" xml:space="preserve">
          <source>A Multi-Status response conveys information about multiple resources
   in situations where multiple status codes might be appropriate.  The
   default Multi-Status response body is a text/xml or application/xml
   HTTP entity with a 'multistatus' root element.  Further elements
   contain 200, 300, 400, and 500 series status codes generated during
   the method invocation. 100 series status codes SHOULD NOT be recorded
   in a 'response' XML element.

   Although '207' is used as the overall response status code, the
   recipient needs to consult the contents of the multistatus response
   body for further information about the success or failure of the
   method execution.  The response MAY be used in success, partial
   success and also in failure situations.

   The 'multistatus' root element holds zero or more 'response' elements
   in any order, each with information about an individual resource.
   Each 'response' element MUST have an 'href' element to identify the
   resource.

   A Multi-Status response uses one out of two distinct formats for
   representing the status:

   1.  A 'status' element as child of the 'response' element indicates
       the status of the message execution for the identified resource
       as a whole (for instance, see &lt;a href=&quot;#section-9.6.2&quot;&gt;Section 9.6.2&lt;/a&gt;).  Some method
       definitions provide information about specific status codes
       clients should be prepared to see in a response.  However,
       clients MUST be able to handle other status codes, using the
       generic rules defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;Section&amp;nbsp;10 of [RFC2616]&lt;/a&gt;.

   2.  For PROPFIND and PROPPATCH, the format has been extended using
       the 'propstat' element instead of 'status', providing information
       about individual properties of a resource.  This format is
       specific to PROPFIND and PROPPATCH, and is described in detail in
       Sections &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; and &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;.</source>
          <target state="translated">다중 상태 응답은 다중 상태 코드가 적절한 상황에서 다중 자원에 대한 정보를 전달합니다. 기본 다중 상태 응답 본문은 'multistatus'루트 요소가있는 text / xml 또는 application / xml HTTP 엔티티입니다. 추가 요소에는 메소드 호출 중에 생성 된 200, 300, 400 및 500 시리즈 상태 코드가 포함됩니다. 100 시리즈 상태 코드는 '응답'XML 요소에 기록해서는 안된다. '207'이 전체 응답 상태 코드로 사용되지만 수신자는 메소드 실행의 성공 또는 실패에 대한 추가 정보를 얻기 위해 다중 상태 응답 본문의 내용을 참조해야합니다. 응답은 성공, 부분적 성공 및 실패 상황에서도 사용될 수 있습니다. '멀티 스테이터스'루트 요소에는 개별 자원에 대한 정보가있는 순서대로 0 개 이상의 '응답'요소가 있습니다. 각 'response'요소에는 자원을 식별하기위한 'href'요소가 있어야합니다. 다중 상태 응답은 상태를 표시하기 위해 두 가지 고유 형식 중 하나를 사용합니다. 1. 'response'요소의 하위 요소 인 'status'요소는 식별 된 자원에 대한 메시지 실행 상태를 전체적으로 나타냅니다 (예 : 보다'response'의 하위 요소 인 element는 식별 된 자원에 대한 메시지 실행 상태를 전체적으로 나타냅니다 (예 :'response'의 하위 요소 인 element는 식별 된 자원에 대한 메시지 실행 상태를 전체적으로 나타냅니다 (예 :&lt;a href=&quot;#section-9.6.2&quot;&gt;섹션 9.6.2&lt;/a&gt; ). 일부 메소드 정의는 클라이언트가 응답에서 볼 수 있도록 준비해야하는 특정 상태 코드에 대한 정보를 제공합니다. 그러나 클라이언트 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;는 [RFC2616] 섹션 10에&lt;/a&gt; 정의 된 일반 규칙을 사용하여 다른 상태 코드를 처리 할 수 ​​있어야합니다 . 2. PROPFIND 및 PROPPATCH의 경우, 'status'대신 'propstat'요소를 사용하여 형식이 확장되어 자원의 개별 특성에 대한 정보를 제공합니다. 이 형식은 PROPFIND 및 PROPPATCH에만 적용되며 섹션 &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; 및 &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt; 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="da18d217768d6c1e8762bf2a3c6c1f21f00b13c4" translate="yes" xml:space="preserve">
          <source>A Multi-Status response conveys information about multiple resources in situations where multiple status codes might be appropriate.</source>
          <target state="translated">다중 상태 응답은 다중 상태 코드가 적절한 상황에서 다중 자원에 대한 정보를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="47c63e0905725bb2dacb2b7404ab31605abb7f60" translate="yes" xml:space="preserve">
          <source>A PUT performed on an existing resource replaces the GET response
   entity of the resource.  Properties defined on the resource may be
   recomputed during PUT processing but are not otherwise affected.  For
   example, if a server recognizes the content type of the request body,
   it may be able to automatically extract information that could be
   profitably exposed as properties.

   A PUT that would result in the creation of a resource without an
   appropriately scoped parent collection MUST fail with a 409
   (Conflict).

   A PUT request allows a client to indicate what media type an entity
   body has, and whether it should change if overwritten.  Thus, a
   client SHOULD provide a Content-Type for a new resource if any is
   known.  If the client does not provide a Content-Type for a new
   resource, the server MAY create a resource with no Content-Type
   assigned, or it MAY attempt to assign a Content-Type. 

   Note that although a recipient ought generally to treat metadata
   supplied with an HTTP request as authoritative, in practice there's
   no guarantee that a server will accept client-supplied metadata
   (e.g., any request header beginning with &quot;Content-&quot;).  Many servers
   do not allow configuring the Content-Type on a per-resource basis in
   the first place.  Thus, clients can't always rely on the ability to
   directly influence the content type by including a Content-Type
   request header.</source>
          <target state="translated">기존 자원에서 수행 된 PUT은 자원의 GET 응답 엔티티를 대체합니다. 자원에 정의 된 특성은 PUT 처리 중에 재 계산 될 수 있지만 그렇지 않은 경우에는 영향을받지 않습니다. 예를 들어, 서버가 요청 본문의 콘텐츠 유형을 인식하면, 속성으로 수익성있게 노출 될 수있는 정보를 자동으로 추출 할 수 있습니다. 적절한 범위의 상위 컬렉션없이 리소스를 생성하는 PUT은 반드시 409 (충돌)로 실패해야합니다. PUT 요청을 통해 클라이언트는 엔터티 본문에 어떤 미디어 유형이 있고 덮어 쓸 경우 변경해야하는지 여부를 나타낼 수 있습니다. 따라서, 클라이언트는 알려진 경우 새로운 자원에 대한 컨텐트 유형을 제공해야한다. 클라이언트가 새 리소스에 콘텐츠 유형을 제공하지 않으면서버는 Content-Type이 할당되지 않은 리소스를 만들거나 Content-Type을 할당하려고 시도 할 수 있습니다. 수신자는 일반적으로 HTTP 요청과 함께 제공되는 메타 데이터를 신뢰할 수있는 것으로 취급해야하지만 실제로 서버가 클라이언트 제공 메타 데이터 (예 : &quot;Content-&quot;로 시작하는 요청 헤더)를 수락한다는 보장은 없습니다. 많은 서버는 먼저 리소스별로 Content-Type을 구성 할 수 없습니다. 따라서 클라이언트가 항상 콘텐츠 유형 요청 헤더를 포함하여 콘텐츠 유형에 직접 영향을 미치는 기능에 의존 할 수는 없습니다.s 서버가 클라이언트 제공 메타 데이터 (예 : &quot;Content-&quot;로 시작하는 모든 요청 헤더)를 허용한다는 보장은 없습니다. 많은 서버는 먼저 리소스별로 Content-Type을 구성 할 수 없습니다. 따라서 클라이언트가 항상 콘텐츠 유형 요청 헤더를 포함하여 콘텐츠 유형에 직접 영향을 미치는 기능에 의존 할 수는 없습니다.s 서버가 클라이언트 제공 메타 데이터 (예 : &quot;Content-&quot;로 시작하는 모든 요청 헤더)를 허용한다는 보장은 없습니다. 많은 서버는 먼저 리소스별로 Content-Type을 구성 할 수 없습니다. 따라서 클라이언트가 항상 콘텐츠 유형 요청 헤더를 포함하여 콘텐츠 유형에 직접 영향을 미치는 기능에 의존 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3416af5b6f6d84eb8e002dbdbec4d7e1feccd161" translate="yes" xml:space="preserve">
          <source>A Resource whose IRI is listed in a Collection is called a Member
   Resource.  The protocol defines two kinds of Member Resources --
   Entry Resources and Media Resources.  Entry Resources are represented
   as Atom Entry Documents [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].  Media Resources can have
   representations in any media type.  A Media Resource is described
   within a Collection using an Entry called a Media Link Entry.  This
   diagram shows the classification of Resources within the Atom
   Protocol:

                Member Resources
                       |
                -----------------
               |                 |
         Entry Resources     Media Resources
               |
         Media Link Entry

   The Atom Protocol defines Collection Resources for managing and
   organizing both kinds of Member Resource.  A Collection is
   represented by an Atom Feed Document.  A Collection Feed's Entries
   contain the IRIs of, and metadata about, the Collection's Member
   Resources.  A Collection Feed can contain any number of Entries,
   which might represent all the Members of the Collection, or an
   ordered subset of them (see &lt;a href=&quot;#section-10.1&quot;&gt;Section 10.1&lt;/a&gt;).  In the diagram of a
   Collection below, there are two Entries.  The first contains the IRI
   of an Entry Resource.  The second contains the IRIs of both a Media
   Resource and a Media Link Entry, which contains the metadata for that
   Media Resource:

     Collection
        |
        o- Entry
        |    |
        |    o- Member Entry IRI (Entry Resource)
        |
        o- Entry
             |
             o- Member Entry IRI (Media Link Entry)
             |
             o- Media IRI        (Media Resource)

   The Atom Protocol does not make a distinction between Feeds used for
   Collections and other Atom Feeds.  The only mechanism that this
   specification supplies for indicating that a Feed is a Collection
   Feed is the presence of the Feed's IRI in a Service Document. 

   Service Documents represent server-defined groups of Collections, and
   are used to initialize the process of creating and editing Resources.
   These groups of Collections are called Workspaces.  Workspaces have
   names, but no IRIs, and no specified processing model.  The Service
   Document can indicate which media types, and which categories, a
   Collection will accept.  In the diagram below, there are two
   Workspaces each describing the IRIs, acceptable media types, and
   categories for a Collection:

     Service
        o- Workspace
        |    |
        |    o- Collection
        |         |
        |         o- IRI, categories, media types
        |
        o- Workspace
             |
             o- Collection
                  |
                  o- IRI, categories, media types</source>
          <target state="translated">IRI가 컬렉션에 나열된 리소스를 멤버 리소스라고합니다. 이 프로토콜은 두 가지 종류의 멤버 리소스 (엔트리 리소스 및 미디어 리소스)를 정의합니다. 응모 자료는 원자 응모 서류로 표시됩니다 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;]. 미디어 리소스는 모든 미디어 유형으로 표현할 수 있습니다. 미디어 리소스는 미디어 링크 항목이라는 항목을 사용하여 컬렉션 내에 설명됩니다. 이 다이어그램은 Atom 프로토콜 내의 자원 분류를 보여줍니다. ----------------- | | 참가 리소스 미디어 리소스 | 미디어 링크 항목 Atom 프로토콜은 두 가지 종류의 회원 리소스를 관리하고 구성하기위한 수집 리소스를 정의합니다. 컬렉션은 Atom Feed Document로 표시됩니다. 컬렉션 피드의 항목에는 컬렉션의 회원 리소스에 대한 IRI 및 메타 데이터가 포함됩니다. 수집 피드는 여러 항목을 포함 할 수 있습니다.컬렉션의 모든 멤버 또는 순서가 지정된 서브 세트를 나타낼 수 있습니다 (참조&lt;a href=&quot;#section-10.1&quot;&gt;10.1 절&lt;/a&gt;). 아래 컬렉션의 다이어그램에는 두 개의 항목이 있습니다. 첫 번째는 엔트리 리소스의 IRI를 포함합니다. 두 번째는 미디어 리소스와 미디어 링크 항목의 IRI를 포함하며 여기에는 해당 미디어 리소스에 대한 메타 데이터가 포함됩니다. Collection | o- 입국 | | | o- 회원 등록 IRI (참가 자원) | o- 입국 | o- 회원 가입 IRI (미디어 링크 참가) | o- 미디어 IRI (미디어 리소스) Atom 프로토콜은 수집에 사용되는 피드와 다른 Atom 피드를 구분하지 않습니다. 피드가 수집 피드임을 나타 내기 위해이 사양이 제공하는 유일한 메커니즘은 서비스 문서에 피드의 IRI가 있다는 것입니다.서비스 문서는 서버 정의 컬렉션 모음을 나타내며 리소스를 만들고 편집하는 프로세스를 초기화하는 데 사용됩니다. 이러한 컬렉션 그룹을 작업 공간이라고합니다. 작업 공간에는 이름이 있지만 IRI가없고 지정된 처리 모델이 없습니다. 서비스 문서는 어떤 미디어 유형 및 어떤 카테고리가 컬렉션에 허용되는지 표시 할 수 있습니다. 아래 다이어그램에는 IRI, 수용 가능한 미디어 유형 및 컬렉션 범주를 각각 설명하는 두 개의 작업 영역이 있습니다. 서비스 o 작업 영역 | | | o- 컬렉션 | | | o- IRI, 카테고리, 미디어 유형 | o- 작업 공간 | o- 컬렉션 | o- IRI, 카테고리, 미디어 유형자원 작성 및 편집 프로세스를 초기화하는 데 사용됩니다. 이러한 컬렉션 그룹을 작업 공간이라고합니다. 작업 공간에는 이름이 있지만 IRI가없고 지정된 처리 모델이 없습니다. 서비스 문서는 어떤 미디어 유형 및 어떤 카테고리가 컬렉션에 허용되는지 표시 할 수 있습니다. 아래 다이어그램에는 IRI, 수용 가능한 미디어 유형 및 컬렉션 범주를 각각 설명하는 두 개의 작업 영역이 있습니다. 서비스 o 작업 영역 | | | o- 컬렉션 | | | o- IRI, 카테고리, 미디어 유형 | o- 작업 공간 | o- 컬렉션 | o- IRI, 카테고리, 미디어 유형자원 작성 및 편집 프로세스를 초기화하는 데 사용됩니다. 이러한 컬렉션 그룹을 작업 공간이라고합니다. 작업 공간에는 이름이 있지만 IRI가없고 지정된 처리 모델이 없습니다. 서비스 문서는 어떤 미디어 유형 및 어떤 카테고리가 컬렉션에 허용되는지 표시 할 수 있습니다. 아래 다이어그램에는 IRI, 수용 가능한 미디어 유형 및 컬렉션 범주를 각각 설명하는 두 개의 작업 영역이 있습니다. 서비스 o 작업 영역 | | | o- 컬렉션 | | | o- IRI, 카테고리, 미디어 유형 | o- 작업 공간 | o- 컬렉션 | o- IRI, 카테고리, 미디어 유형작업 공간에는 이름이 있지만 IRI가없고 지정된 처리 모델이 없습니다. 서비스 문서는 어떤 미디어 유형 및 어떤 카테고리가 컬렉션에 허용되는지 표시 할 수 있습니다. 아래 다이어그램에는 IRI, 수용 가능한 미디어 유형 및 컬렉션 범주를 각각 설명하는 두 개의 작업 영역이 있습니다. 서비스 o 작업 영역 | | | o- 컬렉션 | | | o- IRI, 카테고리, 미디어 유형 | o- 작업 공간 | o- 컬렉션 | o- IRI, 카테고리, 미디어 유형작업 공간에는 이름이 있지만 IRI가없고 지정된 처리 모델이 없습니다. 서비스 문서는 어떤 미디어 유형 및 어떤 카테고리가 컬렉션에 적용되는지 표시 할 수 있습니다. 아래 다이어그램에는 IRI, 수용 가능한 미디어 유형 및 컬렉션 범주를 각각 설명하는 두 개의 작업 영역이 있습니다. 서비스 o 작업 영역 | | | o- 컬렉션 | | | o- IRI, 카테고리, 미디어 유형 | o- 작업 공간 | o- 컬렉션 | o- IRI, 카테고리, 미디어 유형컬렉션에 허용되는 미디어 유형 및 범주 : 서비스 o 작업 영역 | | | o- 컬렉션 | | | o- IRI, 카테고리, 미디어 유형 | o- 작업 공간 | o- 컬렉션 | o- IRI, 카테고리, 미디어 유형컬렉션에 허용되는 미디어 유형 및 범주 : 서비스 o 작업 영역 | | | o- 컬렉션 | | | o- IRI, 카테고리, 미디어 유형 | o- 작업 공간 | o- 컬렉션 | o- IRI, 카테고리, 미디어 유형</target>
        </trans-unit>
        <trans-unit id="35b9ab54a0a93ba0ced7c4af3c76df8322f7ce52" translate="yes" xml:space="preserve">
          <source>A Service Document groups Collections into Workspaces.  Operations on
   Workspaces, such as creation or deletion, are not defined by this
   specification.  This specification assigns no meaning to Workspaces;
   that is, a Workspace does not imply any specific processing
   assumptions.

   There is no requirement that a server support multiple Workspaces.
   In addition, a Collection MAY appear in more than one Workspace.</source>
          <target state="translated">서비스 문서는 콜렉션을 작업 공간으로 그룹화합니다. 작성 또는 삭제와 같은 작업 공간에서의 조작은이 스펙에 의해 정의되지 않습니다. 이 사양은 작업 공간에 의미를 부여하지 않습니다. 즉, 작업 공간은 특정 처리 가정을 의미하지 않습니다. 서버가 여러 작업 공간을 지원할 필요는 없습니다. 또한 컬렉션은 둘 이상의 작업 공간에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab9f1fd23a2ea88a066574ed1c1549d86b5413c4" translate="yes" xml:space="preserve">
          <source>A TLS extension of type &lt;code&gt;signed_certificate_timestamp&lt;/code&gt; sent during the handshake</source>
          <target state="translated">핸드 셰이크 중에 전송 된 &lt;code&gt;signed_certificate_timestamp&lt;/code&gt; 유형의 TLS 확장</target>
        </trans-unit>
        <trans-unit id="d2c9ff77a6964659200d811cbcc28e7831aa3441" translate="yes" xml:space="preserve">
          <source>A URI where to POST the report to.</source>
          <target state="translated">보고서를 게시 할 URI입니다.</target>
        </trans-unit>
        <trans-unit id="7d9a4a4099f798612139543cae66aebb996fc259" translate="yes" xml:space="preserve">
          <source>A URL is composed of different parts, some mandatory and others are optional. A more complex example might look like this:</source>
          <target state="translated">URL은 여러 부분으로 구성되어 있으며 일부는 필수이며 다른 것은 선택 사항입니다. 보다 복잡한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="17235672157ab3c954238f5bafa108a22cb04819" translate="yes" xml:space="preserve">
          <source>A Uniform Resource Name (URN) is a URI that identifies a resource by name in a particular namespace.</source>
          <target state="translated">URI (Uniform Resource Name)는 특정 네임 스페이스에서 이름으로 리소스를 식별하는 URI입니다.</target>
        </trans-unit>
        <trans-unit id="f48650afe5c259c1528667a4e36bcfbef464815b" translate="yes" xml:space="preserve">
          <source>A Web page is a hypertext document. This means some parts of displayed text are links which can be activated (usually by a click of the mouse) to fetch a new Web page, allowing the user to direct their user-agent and navigate through the Web. The browser translates these directions in HTTP requests, and further interprets the HTTP responses to present the user with a clear response.</source>
          <target state="translated">웹 페이지는 하이퍼 텍스트 문서입니다. 이는 표시되는 텍스트의 일부가 링크 (일반적으로 마우스 클릭으로 활성화)되어 새 웹 페이지를 가져 와서 사용자 에이전트를 지시하고 웹을 탐색 할 수있는 링크임을 의미합니다. 브라우저는 HTTP 요청에서 이러한 지시 사항을 번역하고 HTTP 응답을 추가로 해석하여 사용자에게 명확한 응답을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4801f2494f1bfe7a2312cfcf44cb6aeb3133107d" translate="yes" xml:space="preserve">
          <source>A WebDAV client implemented to this specification might find servers
   that create lock-null resources (implemented before this
   specification using [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;]) as well as servers that create locked
   empty resources.  The response to the LOCK request will not indicate
   what kind of resource was created.  There are a few techniques that
   help the client deal with either type.

      If the client wishes to avoid accidentally creating either lock-
      null or empty locked resources, an &quot;If-Match: *&quot; header can be
      included with LOCK requests to prevent the server from creating a
      new resource.

      If a LOCK request creates a resource and the client subsequently
      wants to overwrite that resource using a COPY or MOVE request, the
      client should include an &quot;Overwrite: T&quot; header.

      If a LOCK request creates a resource and the client then decides
      to get rid of that resource, a DELETE request is supposed to fail
      on a lock-null resource and UNLOCK should be used instead.  But
      with a locked empty resource, UNLOCK doesn't make the resource
      disappear.  Therefore, the client might have to try both requests
      and ignore an error in one of the two requests.</source>
          <target state="translated">이 스펙에 구현 된 WebDAV 클라이언트는 잠금 널 자원을 작성하는 서버를 찾을 수 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518을&lt;/a&gt; 사용하여이 스펙 전에 구현 됨).]) 및 잠긴 빈 자원을 작성하는 서버. LOCK 요청에 대한 응답은 생성 된 리소스 종류를 나타내지 않습니다. 클라이언트가 두 가지 유형을 모두 다루는 데 도움이되는 몇 가지 기술이 있습니다. 클라이언트가 실수로 잠금 또는 비어있는 잠긴 자원을 작성하지 않으려면 서버가 새 자원을 작성하지 못하도록 &quot;If-Match : *&quot;헤더를 LOCK 요청에 포함시킬 수 있습니다. LOCK 요청이 자원을 작성하고 클라이언트가 COPY 또는 MOVE 요청을 사용하여 해당 자원을 겹쳐 쓰려면 클라이언트에 &quot;Overwrite : T&quot;헤더가 포함되어야합니다. LOCK 요청이 리소스를 생성하고 클라이언트가 해당 리소스를 제거하기로 결정한 경우,DELETE 요청은 잠금 널 자원에서 실패해야하며 대신 UNLOCK을 사용해야합니다. 그러나 빈 리소스가 잠겨 있으면 UNLOCK은 리소스를 사라지게하지 않습니다. 따라서 클라이언트는 두 요청을 모두 시도하고 두 요청 중 하나의 오류를 무시해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9c050a4669d26963f30fbcabf737a5a269d8088" translate="yes" xml:space="preserve">
          <source>A WebDAV-compliant resource is not required to support locking in any
   form.  If the resource does support locking, it may choose to support
   any combination of exclusive and shared locks for any access types.

   The reason for this flexibility is that locking policy strikes to the
   very heart of the resource management and versioning systems employed
   by various storage repositories.  These repositories require control
   over what sort of locking will be made available.  For example, some
   repositories only support shared write locks, while others only
   provide support for exclusive write locks, while yet others use no
   locking at all.  As each system is sufficiently different to merit
   exclusion of certain locking features, this specification leaves
   locking as the sole axis of negotiation within WebDAV.</source>
          <target state="translated">WebDAV 호환 리소스는 어떤 형태의 잠금도 지원하지 않아도됩니다. 자원이 잠금을 지원하는 경우 모든 액세스 유형에 대해 독점 잠금 및 공유 잠금 조합을 지원하도록 선택할 수 있습니다. 이러한 유연성의 이유는 다양한 정책 저장소에서 사용하는 리소스 관리 및 버전 관리 시스템의 핵심에 잠금 정책이 적용되기 때문입니다. 이러한 리포지토리에는 사용할 수있는 잠금 유형을 제어해야합니다. 예를 들어 일부 리포지토리는 공유 쓰기 잠금 만 지원하는 반면 다른 리포지토리는 단독 쓰기 잠금 만 지원하는 반면 다른 리포지토리는 전혀 잠금을 사용하지 않습니다. 각 시스템은 특정 잠금 기능을 배제하기에 충분히 다르기 때문에이 사양은 잠금을 WebDAV 내에서 유일한 협상 축으로 남겨 둡니다.</target>
        </trans-unit>
        <trans-unit id="38254fe710f16f85c9fd4ff8f8d9fcf247affba8" translate="yes" xml:space="preserve">
          <source>A blank line indicating all meta-information for the request has been sent.</source>
          <target state="translated">요청에 대한 모든 메타 정보를 나타내는 빈 줄이 전송되었습니다.</target>
        </trans-unit>
        <trans-unit id="dffa4d2573a0c29a3cf6a916b1ae983e76a72cd2" translate="yes" xml:space="preserve">
          <source>A blank line indicating all meta-information for the request have been sent.</source>
          <target state="translated">요청에 대한 모든 메타 정보를 나타내는 빈 줄이 전송되었습니다.</target>
        </trans-unit>
        <trans-unit id="98ed6d976f0709e14a223063750e838af2371092" translate="yes" xml:space="preserve">
          <source>A boolean that indicates the user agent's preference for reduced data usage.</source>
          <target state="translated">감소 된 데이터 사용량에 대한 사용자 에이전트의 기본 설정을 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="d6f5fbf27da59695f3ff9b3365893efeb5c2ea49" translate="yes" xml:space="preserve">
          <source>A brief description of the changes between the early versions of HTTP, to the modern HTTP/2 and beyond.</source>
          <target state="translated">초기 HTTP 버전과 최신 HTTP / 2 이상의 변경 사항에 대한 간단한 설명.</target>
        </trans-unit>
        <trans-unit id="39fb3ea12550138a780b56267e0eeca6a0faf155" translate="yes" xml:space="preserve">
          <source>A brief description of the changes between the early versions of HTTP, to the modern HTTP/2, the emergent HTTP/3 and beyond.</source>
          <target state="translated">초기 버전의 HTTP, 최신 HTTP / 2, 새로운 HTTP / 3 이상으로의 변경 사항에 대한 간략한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="cd6e33516e3b56de33ea030077bb00ea0ddc4642" translate="yes" xml:space="preserve">
          <source>A brief introduction of the notion of resources, identifiers, and locations on the Web.</source>
          <target state="translated">웹에서 자원, 식별자 및 위치에 대한 개념을 간략하게 소개합니다.</target>
        </trans-unit>
        <trans-unit id="2eb51aaae5e24e4201d71c51102766328e241d9e" translate="yes" xml:space="preserve">
          <source>A brief introduction to the concept of resources, identifiers, and locations on the web.</source>
          <target state="translated">웹상의 리소스, 식별자 및 위치 개념에 대한 간략한 소개입니다.</target>
        </trans-unit>
        <trans-unit id="70b11a72f1dd5ff054b32769e00fdf5e574c1d4a" translate="yes" xml:space="preserve">
          <source>A cache MUST NOT store a response to any request, unless:

   o  The request method is understood by the cache and defined as being
      cacheable, and

   o  the response status code is understood by the cache, and

   o  the &quot;no-store&quot; cache directive (see &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;) does not appear
      in request or response header fields, and

   o  the &quot;private&quot; response directive (see &lt;a href=&quot;#section-5.2.2.6&quot;&gt;Section 5.2.2.6&lt;/a&gt;) does not
      appear in the response, if the cache is shared, and

   o  the Authorization header field (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7235]&lt;/a&gt;) does
      not appear in the request, if the cache is shared, unless the
      response explicitly allows it (see &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;), and

   o  the response either:

      *  contains an Expires header field (see &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;), or

      *  contains a max-age response directive (see &lt;a href=&quot;#section-5.2.2.8&quot;&gt;Section 5.2.2.8&lt;/a&gt;), or

      *  contains a s-maxage response directive (see &lt;a href=&quot;#section-5.2.2.9&quot;&gt;Section 5.2.2.9&lt;/a&gt;)
         and the cache is shared, or

      *  contains a Cache Control Extension (see &lt;a href=&quot;#section-5.2.3&quot;&gt;Section 5.2.3&lt;/a&gt;) that
         allows it to be cached, or

      *  has a status code that is defined as cacheable by default (see
         &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;), or 

      *  contains a public response directive (see &lt;a href=&quot;#section-5.2.2.5&quot;&gt;Section 5.2.2.5&lt;/a&gt;).

   Note that any of the requirements listed above can be overridden by a
   cache-control extension; see &lt;a href=&quot;#section-5.2.3&quot;&gt;Section 5.2.3&lt;/a&gt;.

   In this context, a cache has &quot;understood&quot; a request method or a
   response status code if it recognizes it and implements all specified
   caching-related behavior.

   Note that, in normal operation, some caches will not store a response
   that has neither a cache validator nor an explicit expiration time,
   as such responses are not usually useful to store.  However, caches
   are not prohibited from storing such responses.</source>
          <target state="translated">캐시는 다음과 같은 경우를 제외하고는 요청에 대한 응답을 저장해서는 안된다. o 요청 방법이 캐시에 의해 이해되고 캐시 가능한 것으로 정의되고 o 응답 상태 코드가 캐시에 의해 이해되고 o &quot;비 저장&quot;캐시 지시 ( &lt;a href=&quot;#section-5.2&quot;&gt;5.2 절&lt;/a&gt; 참조 ) 요청 또는 응답 헤더 필드에 나타나지 않으며, 캐시가 공유 된 경우 &quot;개인&quot;응답 지시문 ( &lt;a href=&quot;#section-5.2.2.6&quot;&gt;5.2.2.6 절&lt;/a&gt; 참조 )이 응답에 나타나지 않으며 o 권한 부여 헤더 필드 ( 응답이 명시 적으로 허용하지 않는 한 ( &lt;a href=&quot;#section-3.2&quot;&gt;3.2 절&lt;/a&gt; 참조 ) 캐시가 공유 된 경우 요청 &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;에 [RFC7235] 4.2 절&lt;/a&gt; 참조 ) 표시되지 않으며 응답은 다음 중 하나입니다.* Expires 헤더 필드를 포함합니다 (참조&lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt; ) 또는 *는 최대 연령 응답 지시문 ( &lt;a href=&quot;#section-5.2.2.8&quot;&gt;5.2.2.8&lt;/a&gt; 참조 )을 포함하거나 * s-maxage 응답 지시문 ( &lt;a href=&quot;#section-5.2.2.9&quot;&gt;5.2.2.9&lt;/a&gt; 참조 )을 포함하며 캐시가 공유되거나 캐시 제어 확장을 포함합니다 ( &lt;a href=&quot;#section-5.2.3&quot;&gt;5.2.3&lt;/a&gt; 참조 ) 캐시 될 수 있거나 * 기본적으로 캐시 가능한 것으로 정의 된 상태 코드 ( &lt;a href=&quot;#section-4.2.2&quot;&gt;4.2.2&lt;/a&gt; 참조 )를 가지고 있거나 * 공개 응답 지시어를 포함합니다 ( &lt;a href=&quot;#section-5.2.2.5&quot;&gt;5.2.2.5&lt;/a&gt; 참조 ). 위에 나열된 요구 사항은 캐시 제어 확장으로 재정의 될 수 있습니다. &lt;a href=&quot;#section-5.2.3&quot;&gt;섹션 5.2.3&lt;/a&gt; 참조. 이와 관련하여 캐시는 요청 방법 또는 응답 상태 코드를 인식하고 지정된 캐싱 관련 동작을 모두 구현하는 경우 요청 방법 또는 응답 상태 코드를 &quot;인식&quot;합니다. 정상 작업에서 일부 캐시는 캐시 유효성 검사기 나 명시적인 만료 시간이없는 응답을 저장하지 않습니다. 이러한 응답은 일반적으로 저장하는 데 유용하지 않습니다. 그러나 캐시가 이러한 응답을 저장하는 것은 금지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="afcd457e5449ea96b9730d7945fa792f97c22645" translate="yes" xml:space="preserve">
          <source>A cache SHOULD generate this if it heuristically chose a freshness
   lifetime greater than 24 hours and the response's age is greater than
   24 hours.</source>
          <target state="translated">캐시는 24 시간을 초과하는 신선도 수명을 경험적으로 선택하고 응답 시간이 24 시간을 초과하는 경우이를 생성해야합니다 (SHOULD).</target>
        </trans-unit>
        <trans-unit id="f6168c09c8c7fd95195aaf7adbff37d6acd9b77a" translate="yes" xml:space="preserve">
          <source>A cache SHOULD generate this if it is intentionally disconnected from
   the rest of the network for a period of time.</source>
          <target state="translated">캐시는 일정 기간 동안 네트워크의 나머지 부분에서 의도적으로 연결이 끊어진 경우이를 생성해야합니다 (SHOULD).</target>
        </trans-unit>
        <trans-unit id="5d58c7fee0ffec3747d196ae22d87f92a88b3159" translate="yes" xml:space="preserve">
          <source>A cache SHOULD generate this when sending a stale response because an
   attempt to validate the response failed, due to an inability to reach
   the server.</source>
          <target state="translated">캐시는 서버에 도달 할 수 없기 때문에 응답 유효성 검사 시도가 실패했기 때문에 오래된 응답을 보낼 때이를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="9dedbe9ca421577a1ae13ea9af987a4dc03874f1" translate="yes" xml:space="preserve">
          <source>A cache SHOULD generate this whenever the sent response is stale.</source>
          <target state="translated">캐시 된 응답이 오래 될 때마다 캐시가이를 생성해야한다.</target>
        </trans-unit>
        <trans-unit id="3d66f1b37c3af5067fb436a94514119f41081f5c" translate="yes" xml:space="preserve">
          <source>A cache can calculate the freshness lifetime (denoted as
   freshness_lifetime) of a response by using the first match of the
   following:

   o  If the cache is shared and the s-maxage response directive
      (&lt;a href=&quot;#section-5.2.2.9&quot;&gt;Section 5.2.2.9&lt;/a&gt;) is present, use its value, or

   o  If the max-age response directive (&lt;a href=&quot;#section-5.2.2.8&quot;&gt;Section 5.2.2.8&lt;/a&gt;) is present,
      use its value, or

   o  If the Expires response header field (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;) is present, use
      its value minus the value of the Date response header field, or

   o  Otherwise, no explicit expiration time is present in the response.
      A heuristic freshness lifetime might be applicable; see
      &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;.

   Note that this calculation is not vulnerable to clock skew, since all
   of the information comes from the origin server. 

   When there is more than one value present for a given directive
   (e.g., two Expires header fields, multiple Cache-Control: max-age
   directives), the directive's value is considered invalid.  Caches are
   encouraged to consider responses that have invalid freshness
   information to be stale.</source>
          <target state="translated">캐시는 다음 중 첫 번째 일치 항목을 사용하여 응답의 신선도 수명 (freshness_lifetime으로 표시)을 계산할 수 있습니다. o 캐시가 공유되고 s-maxage 응답 지시문 ( &lt;a href=&quot;#section-5.2.2.9&quot;&gt;5.2.2.9 절&lt;/a&gt; )이 있으면 해당 값을 사용하십시오. 또는 o 최대 연령 응답 지시문 ( &lt;a href=&quot;#section-5.2.2.8&quot;&gt;섹션 5.2.2.8&lt;/a&gt; )이 존재하면 해당 값을 사용하거나 o 응답 응답 헤더 필드 ( &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; )가 있으면 해당 값에서 날짜 응답 헤더 필드 값을 뺀 값을 사용하십시오. 또는 o 그렇지 않으면 응답에 명시적인 만료 시간이 없습니다. 휴리스틱 신선도 수명이 적용될 수 있습니다. &lt;a href=&quot;#section-4.2.2&quot;&gt;섹션 4.2.2&lt;/a&gt; 참조 . 이 정보는 모든 정보가 원본 서버에서 제공되므로 클럭 스큐에 취약하지 않습니다. 지정된 지시문에 대해 둘 이상의 값이 존재하는 경우 (예 : 두 개의 Expires 헤더 필드, 여러 Cache-Control : max-age 지시문) 지시문의 값은 유효하지 않은 것으로 간주됩니다. 캐시는 유효하지 않은 최신 정보가있는 응답을 부실하게 고려하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ffb1f6da1ee8afd1a7b46e415ab53e9563e80045" translate="yes" xml:space="preserve">
          <source>A cache entry might also consist of multiple stored responses differentiated by a secondary key, if the request is target of content negotiation. For more details see the information about the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header &lt;a href=&quot;#Varying_responses&quot;&gt;below&lt;/a&gt;.</source>
          <target state="translated">요청이 콘텐츠 협상의 대상인 경우 캐시 항목은 보조 키로 구분 된 여러 저장된 응답으로 구성 될 수도 있습니다. 자세한 내용은 &lt;a href=&quot;#Varying_responses&quot;&gt;아래 &lt;/a&gt;&lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; 헤더 에 대한 정보를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5972d7cea05a00533e908dec31b26470e29e3357" translate="yes" xml:space="preserve">
          <source>A cache that receives an incomplete response (for example, with fewer
   bytes of data than specified in a Content-Length header) MAY store
   the response. However, the cache MUST treat this as a partial
   response. Partial responses MAY be combined as described in &lt;a href=&quot;#section-13.5.4&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4&lt;/a&gt;; the result might be a full response or might still be
   partial. A cache MUST NOT return a partial response to a client
   without explicitly marking it as such, using the 206 (Partial
   Content) status code. A cache MUST NOT return a partial response
   using a status code of 200 (OK).

   If a cache receives a 5xx response while attempting to revalidate an
   entry, it MAY either forward this response to the requesting client,
   or act as if the server failed to respond. In the latter case, it MAY
   return a previously received response unless the cached entry
   includes the &quot;must-revalidate&quot; cache-control directive (see &lt;a href=&quot;#section-14.9&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;).</source>
          <target state="translated">불완전한 응답을받는 캐시 (예 : Content-Length 헤더에 지정된 것보다 적은 바이트의 데이터)는 응답을 저장할 수 있습니다. 그러나 캐시는이를 부분 응답으로 처리해야합니다. &lt;a href=&quot;#section-13.5.4&quot;&gt;13.5.4 &lt;/a&gt;&lt;a href=&quot;#section-13.5.4&quot;&gt;절&lt;/a&gt; 에서 설명한대로 부분 응답을 결합 할 수있다.; 결과는 전체 응답이거나 여전히 부분적 일 수 있습니다. 캐시는 206 (부분 컨텐츠) 상태 코드를 사용하여 명시 적으로 표시하지 않고 클라이언트에 부분 응답을 반환해서는 안됩니다 (MUST NOT). 캐시는 상태 코드 200 (OK)을 사용하여 부분 응답을 반환해서는 안됩니다 (MUST NOT). 캐시가 항목을 재확인하려고 시도하는 동안 5xx 응답을 수신하면 요청 응답 클라이언트에게이 응답을 전달하거나 서버가 응답하지 않은 것처럼 행동 할 수 있습니다. 후자의 경우 캐시 된 항목에 &quot;must-revalidate&quot;캐시 제어 지시문이 포함되어 있지 않으면 이전에 수신 한 응답을 반환 할 수도 있습니다 &lt;a href=&quot;#section-14.9&quot;&gt;( &lt;/a&gt;&lt;a href=&quot;#section-14.9&quot;&gt;14.9 &lt;/a&gt;절 참조 ).</target>
        </trans-unit>
        <trans-unit id="a72a187927140b084c50b2a86bb3cae9c1129d9d" translate="yes" xml:space="preserve">
          <source>A cache will send the request to the origin server for validation before releasing a cached copy.</source>
          <target state="translated">캐시는 캐시 된 사본을 릴리스하기 전에 유효성 검증을 위해 요청을 오리진 서버로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="92c597b13172b0ae1b9fec4cca7c94c8d5002a48" translate="yes" xml:space="preserve">
          <source>A character encoding name, like &lt;code&gt;utf-8&lt;/code&gt; or &lt;code&gt;iso-8859-15.&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;utf-8&lt;/code&gt; 또는 &lt;code&gt;iso-8859-15.&lt;/code&gt; 와 같은 문자 인코딩 이름 입니다.</target>
        </trans-unit>
        <trans-unit id="ef7762a0337a8349674180425bb13270b132201a" translate="yes" xml:space="preserve">
          <source>A character set like &lt;code&gt;utf-8&lt;/code&gt; or &lt;code&gt;iso-8859-15.&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;utf-8&lt;/code&gt; 또는 &lt;code&gt;iso-8859-15.&lt;/code&gt; 와 같은 문자 집합</target>
        </trans-unit>
        <trans-unit id="a46fba5aafbe140d23668fd13707246dc167e60e" translate="yes" xml:space="preserve">
          <source>A class 1 compliant resource MUST meet all &quot;MUST&quot; requirements in all
   sections of this document.

   Class 1 compliant resources MUST return, at minimum, the value &quot;1&quot; in
   the DAV header on all responses to the OPTIONS method.</source>
          <target state="translated">클래스 1 호환 리소스는이 문서의 모든 섹션에서 모든 &quot;MUST&quot;요구 사항을 충족해야합니다. 클래스 1 호환 리소스는 OPTIONS 메서드에 대한 모든 응답에서 최소한 DAV 헤더의 값 &quot;1&quot;을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="f09ae974e30d6d65603cbcb265f3f767e63d4b38" translate="yes" xml:space="preserve">
          <source>A class 2 compliant resource MUST meet all class 1 requirements and
   support the LOCK method, the DAV:supportedlock property, the DAV:
   lockdiscovery property, the Time-Out response header and the Lock-
   Token request header.  A class 2 compliant resource SHOULD also
   support the Timeout request header and the 'owner' XML element.

   Class 2 compliant resources MUST return, at minimum, the values &quot;1&quot;
   and &quot;2&quot; in the DAV header on all responses to the OPTIONS method.</source>
          <target state="translated">클래스 2 호환 리소스는 모든 클래스 1 요구 사항을 충족하고 LOCK 메서드, DAV : supportedlock 속성, DAV : lockdiscovery 속성, Time-Out 응답 헤더 및 Lock-Token 요청 헤더를 지원해야합니다. 클래스 2 호환 리소스는 또한 타임 아웃 요청 헤더와 '소유자'XML 요소를 지원해야한다 (SHOULD). 클래스 2 호환 리소스는 OPTIONS 메서드에 대한 모든 응답에서 최소한 DAV 헤더의 값 &quot;1&quot;및 &quot;2&quot;를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="c8a24609de1da03e233355a5b214ad825afc020e" translate="yes" xml:space="preserve">
          <source>A client MUST NOT submit the same write lock request twice.  Note
   that a client is always aware it is resubmitting the same lock
   request because it must include the lock token in the If header in
   order to make the request for a resource that is already locked.

   However, a client may submit a LOCK request with an If header but
   without a body.  A server receiving a LOCK request with no body MUST
   NOT create a new lock -- this form of the LOCK request is only to be
   used to &quot;refresh&quot; an existing lock (meaning, at minimum, that any
   timers associated with the lock MUST be reset).

   Clients may submit Timeout headers of arbitrary value with their lock
   refresh requests.  Servers, as always, may ignore Timeout headers
   submitted by the client, and a server MAY refresh a lock with a
   timeout period that is different than the previous timeout period
   used for the lock, provided it advertises the new value in the LOCK
   refresh response.

   If an error is received in response to a refresh LOCK request, the
   client MUST NOT assume that the lock was refreshed.</source>
          <target state="translated">클라이언트는 동일한 쓰기 잠금 요청을 두 번 제출해서는 안됩니다 (MUST NOT). 클라이언트는 이미 잠겨있는 자원을 요청하려면 If 헤더에 잠금 토큰을 포함해야하기 때문에 항상 동일한 잠금 요청을 다시 제출하고 있음을 알고 있습니다. 그러나 클라이언트는 본문이없는 If 헤더로 LOCK 요청을 제출할 수 있습니다. 본문이없는 LOCK 요청을 수신하는 서버는 새로운 잠금을 생성해서는 안됩니다 (이 형식의 LOCK 요청은 기존 잠금을 ​​&quot;새로 고침&quot;하는 데에만 사용되어야합니다 (잠금과 관련된 모든 타이머는 반드시 잠금을 해제해야 함). 초기화). 클라이언트는 잠금 새로 고침 요청과 함께 임의 값의 제한 시간 헤더를 제출할 수 있습니다. 서버는 항상 그렇듯이 클라이언트가 제출 한 타임 아웃 헤더를 무시할 수 있습니다.그리고 서버는 LOCK 리프레시 응답에서 새로운 값을 광고한다면 잠금에 사용 된 이전 타임 아웃 기간과 다른 타임 아웃 기간으로 잠금을 리프레쉬 할 수있다. 새로 고침 LOCK 요청에 대한 응답으로 오류가 수신되면 클라이언트는 잠금이 새로 고쳐 졌다고 가정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7d982f3df26faad33edb44e7ec5819638eb4f0b9" translate="yes" xml:space="preserve">
          <source>A client can POST Media Resources as well as Entry Resources to a
   Collection.  If a server accepts such a request, then it MUST create
   two new Resources -- one that corresponds to the entity sent in the
   request, called the Media Resource, and an associated Member Entry,
   called the Media Link Entry.  Media Link Entries are represented as
   Atom Entries, and appear in the Collection.

   The Media Link Entry contains the metadata and IRI of the (perhaps
   non-textual) Media Resource.  The Media Link Entry thus makes the
   metadata about the Media Resource separately available for retrieval
   and alteration.

   The server can signal the media types it will accept using the app:
   accept element in the Service Document, as specified in &lt;a href=&quot;#section-8.3.4&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-8.3.4&quot;&gt;8.3.4&lt;/a&gt;.

   Successful responses to creation requests MUST include the URI of the
   Media Link Entry in the Location header.  The Media Link Entry SHOULD
   contain an atom:link element with a link relation of &quot;edit-media&quot;
   that contains the Media Resource IRI.  The Media Link Entry MUST have
   an atom:content element with a &quot;src&quot; attribute.  The value of the
   &quot;src&quot; attribute is an IRI for the newly created Media Resource.  It
   is OPTIONAL that the IRI of the &quot;src&quot; attribute on the atom:content
   element be the same as the Media Resource IRI.  For example, the
   &quot;src&quot; attribute value might instead be a link into a static cache or
   content distribution network and not the Media Resource IRI.

   Implementers are asked to note that [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;] specifies that Atom
   Entries MUST contain an atom:summary element.  Thus, upon successful
   creation of a Media Link Entry, a server MAY choose to populate the
   atom:summary element (as well as any other mandatory elements such as
   atom:id, atom:author, and atom:title) with content derived from the
   POSTed entity or from any other source.  A server might not allow a
   client to modify the server-selected values for these elements.

   For Resource creation, this specification only defines cases where
   the POST body has an Atom Entry entity declared as an Atom media type
   (&quot;application/atom+xml&quot;), or a non-Atom entity declared as a non-Atom
   media type.  When a client is POSTing an Atom Entry to a Collection,
   it may use a media type of either &quot;application/atom+xml&quot; or
   &quot;application/atom +xml;type=entry&quot;.  This specification does not
   specify any request semantics or server behavior in the case where
   the POSTed media type is &quot;application/atom+xml&quot; but the body is
   something other than an Atom Entry.  In particular, what happens on
   POSTing an Atom Feed Document to a Collection using the &quot;application/
   atom+xml&quot; media type is undefined. 

   The Atom Protocol does not specify a means to create multiple
   representations of the same Resource (for example, a PNG and a JPG of
   the same image) either on creation or editing.</source>
          <target state="translated">클라이언트는 미디어 리소스 및 컬렉션에 항목 리소스를 게시 할 수 있습니다. 서버가 그러한 요청을 수락하면 반드시 두 개의 새로운 리소스를 생성해야합니다. 하나는 요청에 전송 된 엔티티 (미디어 리소스라고 함)와 관련 멤버 항목 (미디어 링크 항목)에 해당합니다. 미디어 링크 항목은 원자 항목으로 표시되며 모음에 나타납니다. 미디어 링크 항목에는 텍스트가 아닌 미디어 리소스의 메타 데이터와 IRI가 포함됩니다. 따라서 미디어 링크 항목은 미디어 리소스에 대한 메타 데이터를 검색 및 변경에 별도로 사용할 수있게합니다. 서버는 &lt;a href=&quot;#section-8.3.4&quot;&gt;섹션에&lt;/a&gt; 지정된 서비스 문서의 app : accept 요소를 사용하여 허용 할 미디어 유형을 알릴 수 있습니다.&lt;a href=&quot;#section-8.3.4&quot;&gt; 8.3.4에 알릴 수 있습니다.&lt;/a&gt;. 작성 요청에 대한 성공적인 응답은 Location 헤더에 미디어 링크 항목의 URI를 포함해야합니다. 미디어 링크 엔트리는 미디어 리소스 IRI를 포함하는 &quot;edit-media&quot;의 링크 관계를 갖는 atom : link 요소를 포함해야한다. 미디어 링크 엔트리는 반드시 &quot;src&quot;속성을 가진 atom : content 요소를 가져야합니다. &quot;src&quot;속성의 값은 새로 작성된 매체 자원에 대한 IRI입니다. atom : content 요소에서 &quot;src&quot;속성의 IRI는 매체 자원 IRI와 동일해야합니다. 예를 들어 &quot;src&quot;속성 값은 미디어 리소스 IRI가 아닌 정적 캐시 또는 콘텐츠 배포 네트워크에 대한 링크 일 수 있습니다. 구현자는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;]는 Atom 항목이 atom : summary 요소를 포함해야 함을 지정합니다. 따라서, 미디어 링크 엔트리가 성공적으로 생성되면, 서버는 atom : summary 요소 (attom : id, atom : author 및 atom : title과 같은 다른 필수 요소)를 게시 된 엔티티 또는 다른 소스에서. 서버는 클라이언트가 이러한 요소에 대해 서버가 선택한 값을 수정하도록 허용하지 않을 수 있습니다. 자원 작성의 경우이 스펙은 POST 본문에 Atom 매체 유형 ( &quot;application / atom + xml&quot;)으로 선언 된 Atom Entry 엔티티 또는 Atom이 아닌 매체 유형으로 선언 된 Atom이 아닌 엔티티를 갖는 경우 만 정의합니다. 클라이언트가 콜렉션에 Atom 항목을 게시하는 경우 &quot;application / atom + xml&quot;또는 &quot;application / atom + xml의 미디어 유형을 사용할 수 있습니다.type = entry &quot;.이 스펙은 POST 된 매체 유형이&quot;application / atom + xml &quot;이지만 본문이 Atom 항목이 아닌 경우 요청 시맨틱 또는 서버 작동을 지정하지 않습니다. 특히 POSTing에서 발생하는 사항 &quot;application / atom + xml&quot;매체 유형을 사용하여 콜렉션에 Atom 피드 문서가 정의되지 않은 경우 Atom 프로토콜은 동일한 자원 (예 : 동일한 이미지의 PNG 및 JPG)의 다중 표현을 작성하는 수단을 지정하지 않습니다. )를 만들거나 편집 할 때&quot;application / atom + xml&quot;매체 유형을 사용하여 Atom Feed 문서를 콜렉션에 POST 할 때 발생하는 상황은 정의되어 있지 않습니다. Atom 프로토콜은 작성 또는 편집시 동일한 자원 (예 : 동일한 이미지의 PNG 및 JPG)의 다중 표현을 작성하는 수단을 지정하지 않습니다.&quot;application / atom + xml&quot;매체 유형을 사용하여 Atom Feed 문서를 콜렉션에 POST 할 때 발생하는 상황은 정의되어 있지 않습니다. Atom 프로토콜은 작성 또는 편집시 동일한 자원 (예 : 동일한 이미지의 PNG 및 JPG)의 다중 표현을 작성하는 수단을 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e5c63dbdb2f7786ab98990dffa15132b1ea80a1" translate="yes" xml:space="preserve">
          <source>A client can assign a priority for a new stream by including
   prioritization information in the HEADERS frame (&lt;a href=&quot;#section-6.2&quot;&gt;Section 6.2&lt;/a&gt;) that
   opens the stream.  At any other time, the PRIORITY frame
   (&lt;a href=&quot;#section-6.3&quot;&gt;Section 6.3&lt;/a&gt;) can be used to change the priority of a stream.

   The purpose of prioritization is to allow an endpoint to express how
   it would prefer its peer to allocate resources when managing
   concurrent streams.  Most importantly, priority can be used to select
   streams for transmitting frames when there is limited capacity for
   sending.

   Streams can be prioritized by marking them as dependent on the
   completion of other streams (&lt;a href=&quot;#section-5.3.1&quot;&gt;Section 5.3.1&lt;/a&gt;).  Each dependency is
   assigned a relative weight, a number that is used to determine the
   relative proportion of available resources that are assigned to
   streams dependent on the same stream. 

   Explicitly setting the priority for a stream is input to a
   prioritization process.  It does not guarantee any particular
   processing or transmission order for the stream relative to any other
   stream.  An endpoint cannot force a peer to process concurrent
   streams in a particular order using priority.  Expressing priority is
   therefore only a suggestion.

   Prioritization information can be omitted from messages.  Defaults
   are used prior to any explicit values being provided (&lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83b701e8884cdcbec201923a5462b4446bf15619" translate="yes" xml:space="preserve">
          <source>A client can express the desired push policy for a request by sending an &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ruellan-http-accept-push-policy-00#section-3.1&quot;&gt;Accept-Push-Policy&lt;/a&gt;&lt;/code&gt; header field in the request.</source>
          <target state="translated">클라이언트는 &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ruellan-http-accept-push-policy-00#section-3.1&quot;&gt;Accept-Push-Policy&lt;/a&gt;&lt;/code&gt; 를 전송하여 요청에 대한 원하는 푸시 정책을 표현할 수 있습니다 헤더 필드를 .</target>
        </trans-unit>
        <trans-unit id="158968deede144dac0a0fb8c225610ac022fddfc" translate="yes" xml:space="preserve">
          <source>A client can learn that a particular server supports HTTP/2 by other
   means.  For example, [&lt;a href=&quot;#ref-ALT-SVC&quot;&gt;ALT-SVC&lt;/a&gt;] describes a mechanism for advertising
   this capability.

   A client MUST send the connection preface (&lt;a href=&quot;#section-3.5&quot;&gt;Section 3.5&lt;/a&gt;) and then MAY
   immediately send HTTP/2 frames to such a server; servers can identify
   these connections by the presence of the connection preface.  This 

   only affects the establishment of HTTP/2 connections over cleartext
   TCP; implementations that support HTTP/2 over TLS MUST use protocol
   negotiation in TLS [&lt;a href=&quot;#ref-TLS-ALPN&quot;&gt;TLS-ALPN&lt;/a&gt;].

   Likewise, the server MUST send a connection preface (&lt;a href=&quot;#section-3.5&quot;&gt;Section 3.5&lt;/a&gt;).

   Without additional information, prior support for HTTP/2 is not a
   strong signal that a given server will support HTTP/2 for future
   connections.  For example, it is possible for server configurations
   to change, for configurations to differ between instances in
   clustered servers, or for network conditions to change.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf460d7009baa0cf38dad3c06caeb746522b55c" translate="yes" xml:space="preserve">
          <source>A client can send the &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.7&quot;&gt;Accept-Signature&lt;/a&gt;&lt;/code&gt; header field to indicate intention to take advantage of any available signatures and to indicate what kinds of signatures it supports.</source>
          <target state="translated">클라이언트는 &lt;code&gt;&lt;a href=&quot;https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.7&quot;&gt;Accept-Signature&lt;/a&gt;&lt;/code&gt; 를 보낼 수 있습니다 헤더 필드를 사용 가능한 서명을 활용하려는 의도와 지원하는 서명 종류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="80a4adc81ca6f443765ed44b189dadef0d1bac96" translate="yes" xml:space="preserve">
          <source>A client ought to limit the number of simultaneous open connections
   that it maintains to a given server.

   Previous revisions of HTTP gave a specific number of connections as a
   ceiling, but this was found to be impractical for many applications.
   As a result, this specification does not mandate a particular maximum
   number of connections but, instead, encourages clients to be
   conservative when opening multiple connections.

   Multiple connections are typically used to avoid the &quot;head-of-line
   blocking&quot; problem, wherein a request that takes significant
   server-side processing and/or has a large payload blocks subsequent
   requests on the same connection.  However, each connection consumes
   server resources.  Furthermore, using multiple connections can cause
   undesirable side effects in congested networks.

   Note that a server might reject traffic that it deems abusive or
   characteristic of a denial-of-service attack, such as an excessive
   number of open connections from a single client.</source>
          <target state="translated">클라이언트는 주어진 서버에 대해 유지되는 동시 개방 연결 수를 제한해야합니다. HTTP의 이전 개정은 특정 수의 연결을 상한값으로 제공했지만 많은 응용 프로그램에 비실용적 인 것으로 밝혀졌습니다. 결과적으로이 사양은 특정 최대 연결 수를 요구하지 않으며 대신 여러 연결을 열 때 클라이언트가 보수적이어야합니다. 다수의 연결은 일반적으로 &quot;헤드 라인 차단&quot;문제를 피하기 위해 사용되는데, 여기서 중요한 서버 측 처리를 필요로하는 요청 및 / 또는 큰 페이로드는 동일한 연결에서 후속 요청을 차단합니다. 그러나 각 연결은 서버 리소스를 소비합니다. 또한 여러 연결을 사용하면 혼잡 한 네트워크에서 바람직하지 않은 부작용이 발생할 수 있습니다.서버는 단일 클라이언트의 과도한 수의 열린 연결과 같이 서비스 거부 공격의 악용 또는 특성으로 간주되는 트래픽을 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c4361d2d7548ea6bc70d98eca9d420ed02557e9" translate="yes" xml:space="preserve">
          <source>A client requests signals to the server that it supports the upgrade mechanisms of &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">클라이언트는 &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt; 의 업그레이드 메커니즘을 지원한다는 신호를 서버 에 요청합니다 .</target>
        </trans-unit>
        <trans-unit id="d5dc81872963bb2874b6966923a2cab55617f3ce" translate="yes" xml:space="preserve">
          <source>A client sends a request with a Expect header and waits for the server to respond before sending the message body.</source>
          <target state="translated">클라이언트는 Expect 헤더와 함께 요청을 보내고 메시지 본문을 보내기 전에 서버가 응답하기를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="3c772b2037eba42a257f31dd19bdf0b51277103f" translate="yes" xml:space="preserve">
          <source>A client sends an HTTP request on a new stream, using a previously
   unused stream identifier (&lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;).  A server sends an HTTP
   response on the same stream as the request.

   An HTTP message (request or response) consists of:

   1.  for a response only, zero or more HEADERS frames (each followed
       by zero or more CONTINUATION frames) containing the message
       headers of informational (1xx) HTTP responses (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230],
       Section&amp;nbsp;3.2&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.2&quot;&gt;[RFC7231], Section&amp;nbsp;6.2&lt;/a&gt;),

   2.  one HEADERS frame (followed by zero or more CONTINUATION frames)
       containing the message headers (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230], Section&amp;nbsp;3.2&lt;/a&gt;),

   3.  zero or more DATA frames containing the payload body (see
       &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3&quot;&gt;[RFC7230], Section&amp;nbsp;3.3&lt;/a&gt;), and

   4.  optionally, one HEADERS frame, followed by zero or more
       CONTINUATION frames containing the trailer-part, if present (see
       &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.1.2&quot;&gt;[RFC7230], Section&amp;nbsp;4.1.2&lt;/a&gt;).

   The last frame in the sequence bears an END_STREAM flag, noting that
   a HEADERS frame bearing the END_STREAM flag can be followed by
   CONTINUATION frames that carry any remaining portions of the header
   block.

   Other frames (from any stream) MUST NOT occur between the HEADERS
   frame and any CONTINUATION frames that might follow.

   HTTP/2 uses DATA frames to carry message payloads.  The &quot;chunked&quot;
   transfer encoding defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7230]&lt;/a&gt; MUST NOT be
   used in HTTP/2.

   Trailing header fields are carried in a header block that also
   terminates the stream.  Such a header block is a sequence starting
   with a HEADERS frame, followed by zero or more CONTINUATION frames,
   where the HEADERS frame bears an END_STREAM flag.  Header blocks
   after the first that do not terminate the stream are not part of an
   HTTP request or response. 

   A HEADERS frame (and associated CONTINUATION frames) can only appear
   at the start or end of a stream.  An endpoint that receives a HEADERS
   frame without the END_STREAM flag set after receiving a final (non-
   informational) status code MUST treat the corresponding request or
   response as malformed (&lt;a href=&quot;#section-8.1.2.6&quot;&gt;Section 8.1.2.6&lt;/a&gt;).

   An HTTP request/response exchange fully consumes a single stream.  A
   request starts with the HEADERS frame that puts the stream into an
   &quot;open&quot; state.  The request ends with a frame bearing END_STREAM,
   which causes the stream to become &quot;half-closed (local)&quot; for the
   client and &quot;half-closed (remote)&quot; for the server.  A response starts
   with a HEADERS frame and ends with a frame bearing END_STREAM, which
   places the stream in the &quot;closed&quot; state.

   An HTTP response is complete after the server sends -- or the client
   receives -- a frame with the END_STREAM flag set (including any
   CONTINUATION frames needed to complete a header block).  A server can
   send a complete response prior to the client sending an entire
   request if the response does not depend on any portion of the request
   that has not been sent and received.  When this is true, a server MAY
   request that the client abort transmission of a request without error
   by sending a RST_STREAM with an error code of NO_ERROR after sending
   a complete response (i.e., a frame with the END_STREAM flag).
   Clients MUST NOT discard responses as a result of receiving such a
   RST_STREAM, though clients can always discard responses at their
   discretion for other reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637640a6ac566c746cfe3512f687ebb242d9b708" translate="yes" xml:space="preserve">
          <source>A client sends request header fields to provide more information
   about the request context, make the request conditional based on the
   target resource state, suggest preferred formats for the response,
   supply authentication credentials, or modify the expected request
   processing.  These fields act as request modifiers, similar to the
   parameters on a programming language method invocation.</source>
          <target state="translated">클라이언트는 요청 헤더 필드를 전송하여 요청 컨텍스트에 대한 추가 정보를 제공하고, 대상 자원 상태를 기반으로 요청을 조건부로 설정하고, 응답에 대한 선호 형식을 제안하고, 인증 신임 정보를 제공하거나, 예상 요청 처리를 수정합니다. 이 필드는 프로그래밍 언어 메소드 호출의 매개 변수와 유사한 요청 수정 자 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="e0dfb61cf763ec1db31697625b14173ab1816338" translate="yes" xml:space="preserve">
          <source>A client that makes a request for an &quot;http&quot; URI without prior
   knowledge about support for HTTP/2 on the next hop uses the HTTP
   Upgrade mechanism (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.7&quot;&gt;Section&amp;nbsp;6.7 of [RFC7230]&lt;/a&gt;).  The client does so by
   making an HTTP/1.1 request that includes an Upgrade header field with
   the &quot;h2c&quot; token.  Such an HTTP/1.1 request MUST include exactly one
   HTTP2-Settings (&lt;a href=&quot;#section-3.2.1&quot;&gt;Section 3.2.1&lt;/a&gt;) header field.

   For example:

     GET / HTTP/1.1
     Host: server.example.com
     Connection: Upgrade, HTTP2-Settings
     Upgrade: h2c
     HTTP2-Settings: &amp;lt;base64url encoding of HTTP/2 SETTINGS payload&amp;gt;

   Requests that contain a payload body MUST be sent in their entirety
   before the client can send HTTP/2 frames.  This means that a large
   request can block the use of the connection until it is completely
   sent.

   If concurrency of an initial request with subsequent requests is
   important, an OPTIONS request can be used to perform the upgrade to
   HTTP/2, at the cost of an additional round trip. 

   A server that does not support HTTP/2 can respond to the request as
   though the Upgrade header field were absent:

     HTTP/1.1 200 OK
     Content-Length: 243
     Content-Type: text/html

     

   A server MUST ignore an &quot;h2&quot; token in an Upgrade header field.
   Presence of a token with &quot;h2&quot; implies HTTP/2 over TLS, which is
   instead negotiated as described in &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;.

   A server that supports HTTP/2 accepts the upgrade with a 101
   (Switching Protocols) response.  After the empty line that terminates
   the 101 response, the server can begin sending HTTP/2 frames.  These
   frames MUST include a response to the request that initiated the
   upgrade.

   For example:

     HTTP/1.1 101 Switching Protocols
     Connection: Upgrade
     Upgrade: h2c

     [ HTTP/2 connection 

   The first HTTP/2 frame sent by the server MUST be a server connection
   preface (&lt;a href=&quot;#section-3.5&quot;&gt;Section 3.5&lt;/a&gt;) consisting of a SETTINGS frame (&lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;).
   Upon receiving the 101 response, the client MUST send a connection
   preface (&lt;a href=&quot;#section-3.5&quot;&gt;Section 3.5&lt;/a&gt;), which includes a SETTINGS frame.

   The HTTP/1.1 request that is sent prior to upgrade is assigned a
   stream identifier of 1 (see &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;) with default priority
   values (&lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt;).  Stream 1 is implicitly &quot;half-closed&quot; from
   the client toward the server (see &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;), since the request is
   completed as an HTTP/1.1 request.  After commencing the HTTP/2
   connection, stream 1 is used for the response.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e7d76a2766c403c7c4fb05311e3908c0f23363" translate="yes" xml:space="preserve">
          <source>A client that makes a request to an &quot;https&quot; URI uses TLS [&lt;a href=&quot;#ref-TLS12&quot;&gt;TLS12&lt;/a&gt;] with
   the application-layer protocol negotiation (ALPN) extension
   [&lt;a href=&quot;#ref-TLS-ALPN&quot;&gt;TLS-ALPN&lt;/a&gt;].

   HTTP/2 over TLS uses the &quot;h2&quot; protocol identifier.  The &quot;h2c&quot;
   protocol identifier MUST NOT be sent by a client or selected by a
   server; the &quot;h2c&quot; protocol identifier describes a protocol that does
   not use TLS.

   Once TLS negotiation is complete, both the client and the server MUST
   send a connection preface (&lt;a href=&quot;#section-3.5&quot;&gt;Section 3.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed66d390cb72517711831274a3a7d112673c59ff" translate="yes" xml:space="preserve">
          <source>A client that supports persistent connections MAY &quot;pipeline&quot; its
   requests (i.e., send multiple requests without waiting for each
   response).  A server MAY process a sequence of pipelined requests in
   parallel if they all have safe methods (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7231]&lt;/a&gt;),
   but it MUST send the corresponding responses in the same order that
   the requests were received.

   A client that pipelines requests SHOULD retry unanswered requests if
   the connection closes before it receives all of the corresponding
   responses.  When retrying pipelined requests after a failed
   connection (a connection not explicitly closed by the server in its
   last complete response), a client MUST NOT pipeline immediately after
   connection establishment, since the first remaining request in the
   prior pipeline might have caused an error response that can be lost
   again if multiple requests are sent on a prematurely closed
   connection (see the TCP reset problem described in &lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt;).

   Idempotent methods (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC7231]&lt;/a&gt;) are significant to
   pipelining because they can be automatically retried after a
   connection failure.  A user agent SHOULD NOT pipeline requests after
   a non-idempotent method, until the final response status code for
   that method has been received, unless the user agent has a means to
   detect and recover from partial failure conditions involving the
   pipelined sequence. 

   An intermediary that receives pipelined requests MAY pipeline those
   requests when forwarding them inbound, since it can rely on the
   outbound user agent(s) to determine what requests can be safely
   pipelined.  If the inbound connection fails before receiving a
   response, the pipelining intermediary MAY attempt to retry a sequence
   of requests that have yet to receive a response if the requests all
   have idempotent methods; otherwise, the pipelining intermediary
   SHOULD forward any received responses and then close the
   corresponding outbound connection(s) so that the outbound user
   agent(s) can recover accordingly.</source>
          <target state="translated">지속적인 연결을 지원하는 클라이언트는 요청을 &quot;파이프 라인&quot;할 수 있습니다 (즉, 각 응답을 기다리지 않고 여러 요청을 보낼 수 있음). 서버에 파이프 라인 요청 시퀀스가 ​​모두 안전한 방법을 가지고 있다면 병렬로 처리 할 수도 있습니다 (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt; [RFC7231]의 섹션 4.2.1).&lt;/a&gt;)이지만 요청이 수신 된 순서와 동일한 순서로 해당 응답을 보내야합니다. 파이프 라인 요청을하는 클라이언트는 모든 해당 응답을 받기 전에 연결이 닫히면 응답하지 않은 요청을 다시 시도해야합니다. 연결이 실패한 후 파이프 라인 요청을 다시 시도 할 때 (마지막 완료 응답에서 서버에 의해 명시 적으로 닫히지 않은 연결) 클라이언트는 연결 설정 직후에 파이프 라인해서는 안됩니다. 조기에 닫힌 연결에서 여러 요청이 전송되면 다시 손실 될 수 있습니다 ( &lt;a href=&quot;#section-6.6&quot;&gt;6.6 절에&lt;/a&gt; 설명 된 TCP 재설정 문제 참조) ). &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.2&quot;&gt;dem 등원&lt;/a&gt; 방법 ( [RFC7231]의 섹션 4.2.2))는 연결 실패 후 자동으로 재 시도 할 수 있으므로 파이프 라이닝에 중요합니다. 사용자 에이전트가 파이프 라인 된 시퀀스와 관련된 부분 실패 조건을 감지하고 복구 할 수있는 수단이없는 한, 사용자 에이전트는 해당 메소드에 대한 최종 응답 상태 코드가 수신 될 때까지 비등 전성 메소드 후에 파이프 라인 요청을하지 않아야합니다. 파이프 라인 요청을받는 중개자는 요청을 안전하게 전달할 수있는 아웃 바운드 사용자 에이전트에 의존 할 수 있기 때문에 요청을 인바운드 전달할 때 파이프 라인 할 수 있습니다. 응답을 받기 전에 인바운드 연결이 실패하면 파이프 라인 중개자는 요청에 모두 dem 등원 한 방법이있는 경우 아직 응답을받지 않은 일련의 요청을 재 시도 할 수 있습니다. 그렇지 않으면,파이프 라인 중개자는 수신 된 응답을 전달한 다음 해당 아웃 바운드 연결을 닫아야 아웃 바운드 사용자 에이전트가 그에 따라 복구 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="09e95576fba358e044ab16ce38c0a6a7604b1900" translate="yes" xml:space="preserve">
          <source>A client that supports persistent connections MAY &quot;pipeline&quot; its
   requests (i.e., send multiple requests without waiting for each
   response). A server MUST send its responses to those requests in the
   same order that the requests were received.

   Clients which assume persistent connections and pipeline immediately
   after connection establishment SHOULD be prepared to retry their
   connection if the first pipelined attempt fails. If a client does
   such a retry, it MUST NOT pipeline before it knows the connection is
   persistent. Clients MUST also be prepared to resend their requests if
   the server closes the connection before sending all of the
   corresponding responses.

   Clients SHOULD NOT pipeline requests using non-idempotent methods or
   non-idempotent sequences of methods (see &lt;a href=&quot;#section-9.1.2&quot;&gt;section 9.1.2&lt;/a&gt;). Otherwise, a
   premature termination of the transport connection could lead to
   indeterminate results. A client wishing to send a non-idempotent
   request SHOULD wait to send that request until it has received the
   response status for the previous request.</source>
          <target state="translated">지속적인 연결을 지원하는 클라이언트는 요청을 &quot;파이프 라인&quot;할 수 있습니다 (즉, 각 응답을 기다리지 않고 여러 요청을 보낼 수 있음). 서버는 요청을받은 순서대로 응답을 해당 요청에 보내야합니다. 연결 설정 직후 영구 연결 및 파이프 라인을 가정하는 클라이언트는 첫 번째 파이프 라인 시도가 실패하면 연결을 다시 시도해야합니다. 클라이언트가 이러한 재 시도를 수행하는 경우 연결이 지속됨을 알기 전에 파이프 라인해서는 안됩니다. 클라이언트는 또한 해당하는 모든 응답을 보내기 전에 서버가 연결을 닫으면 요청을 다시 보낼 수 있어야합니다. 클라이언트는 비등 전성 방법이나 비등 전성 방법 시퀀스를 사용하여 요청을 파이프 라인해서는 &lt;a href=&quot;#section-9.1.2&quot;&gt;안됩니다&lt;/a&gt; ( 섹션 9.1.2 참조).). 그렇지 않으면 전송 연결이 조기에 종료되면 결과가 불확실해질 수 있습니다. 비등 전성 요청을 보내려는 클라이언트는 이전 요청에 대한 응답 상태를 수신 할 때까지 해당 요청을 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="63e7a43a912d31f1510e39f67b9021a4a00a0103" translate="yes" xml:space="preserve">
          <source>A client that wants to authenticate itself with the server can then do so by including an &lt;a href=&quot;headers/authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; request header with the credentials.</source>
          <target state="translated">서버에서 자신을 인증하려는 클라이언트 는 자격 증명과 함께 &lt;a href=&quot;headers/authorization&quot;&gt; &lt;code&gt;Authorization&lt;/code&gt; &lt;/a&gt; 요청 헤더를 포함하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a4673d2cf5f078d0e80766af3fc18ef334aaf9ad" translate="yes" xml:space="preserve">
          <source>A client to display (and accidentally edit) these documents, the first Web browser called &lt;em&gt;WorldWideWeb&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;WorldWideWeb&lt;/em&gt; 이라는 첫 번째 웹 브라우저 인 이러한 문서를 표시하고 실수로 편집하는 클라이언트 .</target>
        </trans-unit>
        <trans-unit id="bc8b63d811e299dc8d332f7a04036fbab8d18d90" translate="yes" xml:space="preserve">
          <source>A client's request signals to the server that it supports the upgrade mechanisms of &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">클라이언트의 요청은 &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt; 의 업그레이드 메커니즘을 지원한다는 신호를 서버에 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="6cf22c128590a11ccd015eab613d6d6178d3986e" translate="yes" xml:space="preserve">
          <source>A collection of tips to help operational teams with creating secure web applications.</source>
          <target state="translated">운영 팀이 안전한 웹 응용 프로그램을 만드는 데 도움이되는 팁 모음입니다.</target>
        </trans-unit>
        <trans-unit id="545d7ecd63391cf84687a091c329dea2e48ff465" translate="yes" xml:space="preserve">
          <source>A comma-delimited list of &lt;a href=&quot;../headers&quot;&gt;HTTP headers&lt;/a&gt; that are included in the request.</source>
          <target state="translated">요청에 포함 된 쉼표로 구분 된 &lt;a href=&quot;../headers&quot;&gt;HTTP 헤더&lt;/a&gt; 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="4a7070eb1fb6568ed5750e765e691507dcbb9e26" translate="yes" xml:space="preserve">
          <source>A comma-delineated list of the WebSocket protocol versions supported by the server.</source>
          <target state="translated">서버에서 지원하는 쉼표로 구분 된 WebSocket 프로토콜 버전 목록입니다.</target>
        </trans-unit>
        <trans-unit id="dd0dcb0efcb7d9566b65a09f6272f43ad4054b47" translate="yes" xml:space="preserve">
          <source>A comma-separated list of extensions to request (or agree to support). These should be selected from the &lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#extension-name&quot;&gt;IANA WebSocket Extension Name Registry&lt;/a&gt;. Extensions which take parameters do so by using semicolon delineation.</source>
          <target state="translated">쉼표로 구분 된 확장 프로그램 목록으로 요청하거나 지원에 동의합니다. &lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#extension-name&quot;&gt;IANA WebSocket 확장명 레지스트리&lt;/a&gt; 에서 선택해야합니다. . 매개 변수를 사용하는 확장은 세미콜론 설명을 사용하여 수행합니다.</target>
        </trans-unit>
        <trans-unit id="6d9b0d38fc7576edfbc87bdb5049a93e906cc613" translate="yes" xml:space="preserve">
          <source>A comma-separated list of header names to take into account when deciding whether or not a cached response can be used.</source>
          <target state="translated">캐시 된 응답을 사용할 수 있는지 여부를 결정할 때 고려해야 할 쉼표로 구분 된 헤더 이름 목록입니다.</target>
        </trans-unit>
        <trans-unit id="3351f8daef225cdddd1d659a4e4c2bff164ed208" translate="yes" xml:space="preserve">
          <source>A comma-separated list of parameters, each consisting of an identifier and a value separated by the equal sign (&lt;code&gt;'='&lt;/code&gt;). The following identifiers are possible:</source>
          <target state="translated">쉼표로 구분 된 매개 변수 목록으로, 각각 식별자와 등호 ( &lt;code&gt;'='&lt;/code&gt; )로 구분 된 값으로 구성됩니다 . 다음과 같은 식별자가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="e64dd752a990983ce318fbd34f3017c824c11259" translate="yes" xml:space="preserve">
          <source>A comma-separated list of subprotocol names, in the order of preference. The subprotocols may be selected from the &lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#subprotocol-name&quot;&gt;IANA WebSocket Subprotocol Name Registry&lt;/a&gt; or may be a custom name jointly understood by the client and the server.</source>
          <target state="translated">기본 설정 순서대로 쉼표로 구분 된 하위 프로토콜 이름 목록입니다. 서브 프로토콜은 &lt;a href=&quot;https://www.iana.org/assignments/websocket/websocket.xml#subprotocol-name&quot;&gt;IANA WebSocket&lt;/a&gt; 서브 프로토콜 이름 레지스트리에서 선택 하거나 클라이언트와 서버가 공동으로 이해하는 사용자 정의 이름 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="954560756b7f774ff0dbcf3f403c65bfec685270" translate="yes" xml:space="preserve">
          <source>A common case is when a site resides at &lt;code&gt;www.example.com&lt;/code&gt;, but accessing it from &lt;code&gt;example.com&lt;/code&gt; should also work. Redirections for &lt;code&gt;example.com&lt;/code&gt; to &lt;code&gt;www.example.com&lt;/code&gt; are thus set up. You might also redirect from common synonyms or frequent typos of your domains.</source>
          <target state="translated">일반적인 경우는 사이트가 &lt;code&gt;www.example.com&lt;/code&gt; 에 있지만 &lt;code&gt;example.com&lt;/code&gt; 에서 액세스하는 경우에도 작동합니다. 따라서 &lt;code&gt;example.com&lt;/code&gt; 에서 &lt;code&gt;www.example.com&lt;/code&gt; 으로의 리디렉션 이 설정됩니다. 도메인의 일반적인 동의어 또는 빈번한 오타에서 리디렉션 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="765a1ca65f0ae709d5083d956638fa8d4f371723" translate="yes" xml:space="preserve">
          <source>A common operation in Web applications is to &lt;em&gt;update&lt;/em&gt; a remote document. This is very common in any file system or source control applications, but any application that allows to store remote resources needs such a mechanism. Common Web sites, like wikis and other CMS, have such a need.</source>
          <target state="translated">웹 응용 프로그램에서 일반적인 작업은 &lt;em&gt;업데이트하는 것입니다&lt;/em&gt; 원격 문서 하는 것입니다. 이것은 모든 파일 시스템 또는 소스 제어 응용 프로그램에서 매우 일반적이지만 원격 리소스를 저장할 수있는 응용 프로그램에는 이러한 메커니즘이 필요합니다. 위키 및 기타 CMS와 같은 일반적인 웹 사이트에는 이러한 요구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="56fb8e2fb85d7e564f3d29ea311fff6ca481b845" translate="yes" xml:space="preserve">
          <source>A complete URL, known as the &lt;em&gt;absolute form&lt;/em&gt;, is mostly used with &lt;code&gt;GET&lt;/code&gt; when connected to a proxy.</source>
          <target state="translated">&lt;em&gt;절대 형식으로&lt;/em&gt; 알려진 완전한 URL 은 대부분 &lt;code&gt;GET&lt;/code&gt; 과 함께 사용됩니다. 은 프록시에 연결될 때 .</target>
        </trans-unit>
        <trans-unit id="fe1809df44023e8e001ce74fe56c8e7ccf0d8591" translate="yes" xml:space="preserve">
          <source>A compression format using the &lt;a href=&quot;http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;Lempel-Ziv coding&lt;/a&gt; (LZ77), with a 32-bit CRC.</source>
          <target state="translated">32 비트 CRC와 함께 &lt;a href=&quot;http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;Lempel-Ziv 코딩&lt;/a&gt; (LZ77)을 사용하는 압축 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="f3c6e3712615587b61d1ea467fde1e10f59e37c9" translate="yes" xml:space="preserve">
          <source>A compression format using the &lt;a href=&quot;http://en.wikipedia.org/wiki/LZW&quot;&gt;Lempel-Ziv-Welch&lt;/a&gt; (LZW) algorithm.</source>
          <target state="translated">LZW ( &lt;a href=&quot;http://en.wikipedia.org/wiki/LZW&quot;&gt;Lempel-Ziv-Welch&lt;/a&gt; ) 알고리즘을 사용하는 압축 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="fc4d9ed7204457ec6cc9721d89f040474b7a652b" translate="yes" xml:space="preserve">
          <source>A compression format using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; structure, with the &lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;deflate&lt;/em&gt;&lt;/a&gt; compression algorithm.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;수축&lt;/em&gt;&lt;/a&gt; 압축 알고리즘 과 함께 &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; 구조를 사용하는 압축 형식 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="05595aa3b6a0abccc227abaf6c71dbce8636585f" translate="yes" xml:space="preserve">
          <source>A compression format using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Brotli&quot;&gt;Brotli&lt;/a&gt; algorithm.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Brotli&quot;&gt;Brotli&lt;/a&gt; 알고리즘을 사용한 압축 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="d5f5c5610894d726a658909063c81dee8cf8da26" translate="yes" xml:space="preserve">
          <source>A compression format using the &lt;a href=&quot;https://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;Lempel-Ziv coding&lt;/a&gt; (LZ77), with a 32-bit CRC.</source>
          <target state="translated">다음을 사용하는 압축 형식 &lt;a href=&quot;https://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;&lt;/a&gt;32 비트 CRC와 함께 Lempel-Ziv 코딩 (LZ77)을 입니다.</target>
        </trans-unit>
        <trans-unit id="13ee4dcdbc16553632cbd81d6f559303fab97423" translate="yes" xml:space="preserve">
          <source>A compression format using the &lt;a href=&quot;https://en.wikipedia.org/wiki/LZW&quot;&gt;Lempel-Ziv-Welch&lt;/a&gt; (LZW) algorithm.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/LZW&quot;&gt;Lempel-Ziv-Welch&lt;/a&gt; (LZW) 알고리즘을 사용하는 압축 형식 .</target>
        </trans-unit>
        <trans-unit id="0df54e7cc1e88fc5811ec6386faef052c65d5bf5" translate="yes" xml:space="preserve">
          <source>A compression format using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; structure, with the &lt;a href=&quot;https://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;deflate&lt;/em&gt;&lt;/a&gt; compression algorithm.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;deflate&lt;/em&gt;&lt;/a&gt; 압축 알고리즘 과 함께 &lt;a href=&quot;https://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; 구조를 사용하는 압축 형식 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d7bb2d2d512282eb3e9b2963af2987738e151227" translate="yes" xml:space="preserve">
          <source>A connection can be reused, saving the time to reopen it numerous times to display the resources embedded into the single original document retrieved.</source>
          <target state="translated">연결을 재사용하여 여러 번 다시 열어서 검색 한 단일 원본 문서에 포함 된 리소스를 표시하는 시간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="509931ff360314f1dcb21ee1409195696c609d6d" translate="yes" xml:space="preserve">
          <source>A connection error is any error that prevents further processing of
   the frame layer or corrupts any connection state.

   An endpoint that encounters a connection error SHOULD first send a
   GOAWAY frame (&lt;a href=&quot;#section-6.8&quot;&gt;Section 6.8&lt;/a&gt;) with the stream identifier of the last
   stream that it successfully received from its peer.  The GOAWAY frame
   includes an error code that indicates why the connection is
   terminating.  After sending the GOAWAY frame for an error condition,
   the endpoint MUST close the TCP connection.

   It is possible that the GOAWAY will not be reliably received by the
   receiving endpoint (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.6&quot;&gt;[RFC7230], Section&amp;nbsp;6.6&lt;/a&gt; describes how an immediate
   connection close can result in data loss).  In the event of a
   connection error, GOAWAY only provides a best-effort attempt to
   communicate with the peer about why the connection is being
   terminated.

   An endpoint can end a connection at any time.  In particular, an
   endpoint MAY choose to treat a stream error as a connection error.
   Endpoints SHOULD send a GOAWAY frame when ending a connection,
   providing that circumstances permit it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50a3a1fcd6e5f64af49a78c0978fa2905e70fbdc" translate="yes" xml:space="preserve">
          <source>A connection is controlled at the transport layer, and therefore fundamentally out of scope for HTTP. Though HTTP doesn't require the underlying transport protocol to be connection-based; only requiring it to be &lt;em&gt;reliable&lt;/em&gt;, or not lose messages (so at minimum presenting an error). Among the two most common transport protocols on the Internet, TCP is reliable and UDP isn't. HTTP subsequently relies on the TCP standard, which is connection-based, even though a connection is not always required.</source>
          <target state="translated">연결은 전송 계층에서 제어되므로 기본적으로 HTTP 범위를 벗어납니다. HTTP는 기본 전송 프로토콜이 연결 기반 일 필요는 없지만; 단지 그것을 필요로하는 것은 할 수 &lt;em&gt;신뢰할 수있는&lt;/em&gt; , 또는 (그래서 최소한 오류를 제시) 메시지가 손실되지. 인터넷에서 가장 일반적인 두 가지 전송 프로토콜 중 TCP는 안정적이며 UDP는 신뢰할 수 없습니다. HTTP는 연결이 항상 필요한 것은 아니지만 연결 기반 인 TCP 표준에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="449f1efb42383b982f63e22f55d172b3f3d362a4" translate="yes" xml:space="preserve">
          <source>A connection is controlled at the transport layer, and therefore fundamentally out of scope for HTTP. Though HTTP doesn't require the underlying transport protocol to be connection-based; only requiring it to be &lt;em&gt;reliable&lt;/em&gt;, or not lose messages (so at minimum presenting an error). Among the two most common transport protocols on the Internet, TCP is reliable and UDP isn't. HTTP therefore relies on the TCP standard, which is connection-based.</source>
          <target state="translated">연결은 전송 계층에서 제어되므로 기본적으로 HTTP의 범위를 벗어납니다. HTTP는 기본 전송 프로토콜이 연결 기반이어야하는 것은 아닙니다. &lt;em&gt;신뢰할 수&lt;/em&gt; 있어야 하거나 메시지가 손실되지 않아야합니다 (최소한 오류 표시). 인터넷에서 가장 일반적인 두 가지 전송 프로토콜 중 TCP는 신뢰할 수 있고 UDP는 그렇지 않습니다. 따라서 HTTP는 연결 기반 인 TCP 표준에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="da45e542a4ecf477e31105fbfb530cf280b696ac" translate="yes" xml:space="preserve">
          <source>A cookie begins with a name-value pair:</source>
          <target state="translated">쿠키는 이름-값 쌍으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="c987d7297ad42a4f63e657b6a26ef82f6c58c39b" translate="yes" xml:space="preserve">
          <source>A cookie belonging to a domain that does not include the origin server &lt;a href=&quot;https://tools.ietf.org/html/rfc6265#section-4.1.2.3&quot;&gt;should be rejected by the user agent&lt;/a&gt;. The following cookie will be rejected if it was set by a server hosted on originalcompany.com.</source>
          <target state="translated">오리진 서버를 포함하지 않는 도메인에 속하는 쿠키 &lt;a href=&quot;https://tools.ietf.org/html/rfc6265#section-4.1.2.3&quot;&gt;는 사용자 에이전트에 의해 거부되어야합니다&lt;/a&gt; . originalcompany.com에서 호스팅되는 서버에서 설정 한 쿠키는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="0f35e435392b2381557a355cb4470d731e02478a" translate="yes" xml:space="preserve">
          <source>A cookie for a domain that does not include the server that set it &lt;a href=&quot;https://tools.ietf.org/html/rfc6265#section-4.1.2.3&quot;&gt;should be rejected by the user agent&lt;/a&gt;.</source>
          <target state="translated">설정 한 서버를 포함하지 않는 도메인에 대한 쿠키 &lt;a href=&quot;https://tools.ietf.org/html/rfc6265#section-4.1.2.3&quot;&gt;는 사용자 에이전트에 의해 거부되어야합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d37ce32a93b2cb9f5253c4016337dd3a5af1c3e5" translate="yes" xml:space="preserve">
          <source>A cookie for a sub domain of the serving domain will be rejected.</source>
          <target state="translated">서비스 도메인의 하위 도메인에 대한 쿠키가 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="cf8f0198fd6d1e23aedf60fb515a3869ace7ce34" translate="yes" xml:space="preserve">
          <source>A cookie is associated with a domain. If this domain is the same as the domain of the page you are on, the cookie is called a &lt;em&gt;first-party cookie&lt;/em&gt;. If the domain is different, it is a &lt;em&gt;third-party cookie&lt;/em&gt;. While the server hosting a web page sets first-party cookies, the page may contain images or other components stored on servers in other domains (for example, ad banners), which may set third-party cookies. These are mainly used for advertising and tracking across the web. See for example the &lt;a href=&quot;https://policies.google.com/technologies/types&quot;&gt;types of cookies used by Google&lt;/a&gt;. A third party server can build up a profile of a user's browsing history and habits based on cookies sent to it by the same browser when accessing multiple sites. Firefox, by default, blocks third-party cookies that are known to contain trackers. Third-party cookies (or just tracking cookies) may also be blocked by other browser settings or extensions. Cookie blocking can cause some third-party components (such as social media widgets) to not function as intended.</source>
          <target state="translated">쿠키는 도메인과 연결됩니다. 이 도메인이 현재 페이지의 도메인과 동일한 경우 쿠키를 &lt;em&gt;자사 쿠키&lt;/em&gt; 라고합니다 . 도메인이 다른 경우 &lt;em&gt;타사 쿠키&lt;/em&gt; 입니다. 웹 페이지를 호스팅하는 서버가 자사 쿠키를 설정하는 동안 페이지에는 타사 쿠키를 설정할 수있는 다른 도메인 (예 : 광고 배너)의 서버에 저장된 이미지 또는 기타 구성 요소가 포함될 수 있습니다. 주로 웹에서 광고 및 추적에 사용됩니다. 예를 들어&lt;a href=&quot;https://policies.google.com/technologies/types&quot;&gt; Google에서 사용하는 쿠키 유형을&lt;/a&gt;. 타사 서버는 여러 사이트에 액세스 할 때 동일한 브라우저에서 보낸 쿠키를 기반으로 사용자의 검색 기록 및 습관에 대한 프로필을 만들 수 있습니다. Firefox는 기본적으로 추적기를 포함하는 것으로 알려진 타사 쿠키를 차단합니다. 타사 쿠키 (또는 추적 쿠키)는 다른 브라우저 설정이나 확장 프로그램에 의해 차단 될 수도 있습니다. 쿠키 차단으로 인해 일부 타사 구성 요소 (예 : 소셜 미디어 위젯)가 의도 한대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3d37c8e928ad783b182cebcac2bda3dbbdb9937" translate="yes" xml:space="preserve">
          <source>A cookie with the &lt;code&gt;HttpOnly&lt;/code&gt; attribute is inaccessible to the JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt;&lt;code&gt;Document.cookie&lt;/code&gt;&lt;/a&gt; API; it is sent only to the server. For example, cookies that persist server-side sessions don't need to be available to JavaScript, and should have the &lt;code&gt;HttpOnly&lt;/code&gt; attribute. This precaution helps mitigate cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Cross-site_scripting_(XSS)&quot;&gt;XSS&lt;/a&gt;) attacks.</source>
          <target state="translated">&lt;code&gt;HttpOnly&lt;/code&gt; 속성이 있는 쿠키 는 JavaScript &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt; &lt;code&gt;Document.cookie&lt;/code&gt; &lt;/a&gt; API에 액세스 할 수 없습니다 . 서버로만 전송됩니다. 예를 들어 서버 측 세션을 유지하는 쿠키는 JavaScript에서 사용할 수있을 필요가 없으며 &lt;code&gt;HttpOnly&lt;/code&gt; 속성을 가져야 합니다. 이 예방 조치는 교차 사이트 스크립팅 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Cross-site_scripting_(XSS)&quot;&gt;XSS&lt;/a&gt; ) 공격 을 완화하는 데 도움이됩니다 .</target>
        </trans-unit>
        <trans-unit id="28a5315337fe2caafeb7456394c12b7df8509b49" translate="yes" xml:space="preserve">
          <source>A cookie with the &lt;code&gt;Secure&lt;/code&gt; attribute is sent to the server only with an encrypted request over the HTTPS protocol, never with unsecured HTTP (except on localhost), and therefore can't easily be accessed by a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MitM&quot;&gt;man-in-the-middle&lt;/a&gt; attacker. Insecure sites (with &lt;code&gt;http:&lt;/code&gt; in the URL) can't set cookies with the &lt;code&gt;Secure&lt;/code&gt; attribute. However, do not assume that &lt;code&gt;Secure&lt;/code&gt; prevents all access to sensitive information in cookies; for example, it can be read and modified by someone with access to the client's hard disk (or JavaScript if the &lt;code&gt;HttpOnly&lt;/code&gt; attribute is not set).</source>
          <target state="translated">&lt;code&gt;Secure&lt;/code&gt; 속성이 있는 쿠키 는 HTTPS 프로토콜을 통한 암호화 된 요청을 통해서만 서버로 전송되며 보안되지 않은 HTTP (localhost 제외)는 사용되지 않으므로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MitM&quot;&gt;중간자&lt;/a&gt; 공격자가 쉽게 액세스 할 수 없습니다 . 안전하지 않은 사이트 ( URL에 &lt;code&gt;http:&lt;/code&gt; 포함 )는 &lt;code&gt;Secure&lt;/code&gt; 속성으로 쿠키를 설정할 수 없습니다 . 그러나 &lt;code&gt;Secure&lt;/code&gt; 가 쿠키의 민감한 정보에 대한 모든 액세스를 차단 한다고 가정하지 마십시오 . 예를 들어 클라이언트의 하드 디스크 (또는 &lt;code&gt;HttpOnly&lt;/code&gt; 속성이 설정되지 않은 경우 JavaScript)에 대한 액세스 권한이있는 사람이 읽고 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2001d70e25e20b433ea2e7fdbd02e6058831b1c9" translate="yes" xml:space="preserve">
          <source>A correct cache MUST respond to a request with the most up-to-date
   response held by the cache that is appropriate to the request (see
   sections &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt;, &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt;, and &lt;a href=&quot;#section-13.12&quot;&gt;13.12&lt;/a&gt;) which meets one of the following
   conditions:

      1. It has been checked for equivalence with what the origin server
         would have returned by revalidating the response with the
         origin server (&lt;a href=&quot;#section-13.3&quot;&gt;section 13.3&lt;/a&gt;); 

      2. It is &quot;fresh enough&quot; (see &lt;a href=&quot;#section-13.2&quot;&gt;section 13.2&lt;/a&gt;). In the default case,
         this means it meets the least restrictive freshness requirement
         of the client, origin server, and cache (see &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;); if
         the origin server so specifies, it is the freshness requirement
         of the origin server alone.

         If a stored response is not &quot;fresh enough&quot; by the most
         restrictive freshness requirement of both the client and the
         origin server, in carefully considered circumstances the cache
         MAY still return the response with the appropriate Warning
         header (see &lt;a href=&quot;#section-13.1.5&quot;&gt;section 13.1.5&lt;/a&gt; and 14.46), unless such a response
         is prohibited (e.g., by a &quot;no-store&quot; cache-directive, or by a
         &quot;no-cache&quot; cache-request-directive; see &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;).

      3. It is an appropriate 304 (Not Modified), 305 (Proxy Redirect),
         or error (4xx or 5xx) response message.

   If the cache can not communicate with the origin server, then a
   correct cache SHOULD respond as above if the response can be
   correctly served from the cache; if not it MUST return an error or
   warning indicating that there was a communication failure.

   If a cache receives a response (either an entire response, or a 304
   (Not Modified) response) that it would normally forward to the
   requesting client, and the received response is no longer fresh, the
   cache SHOULD forward it to the requesting client without adding a new
   Warning (but without removing any existing Warning headers). A cache
   SHOULD NOT attempt to revalidate a response simply because that
   response became stale in transit; this might lead to an infinite
   loop. A user agent that receives a stale response without a Warning
   MAY display a warning indication to the user.</source>
          <target state="translated">올바른 캐시 는 다음 조건 중 하나를 충족 하는 요청에 적합한 캐시가 보유한 최신 응답 ( &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt; , &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt; 및 &lt;a href=&quot;#section-13.12&quot;&gt;13.12&lt;/a&gt; 참조)으로 요청에 응답 해야 합니다. 1 오리진 서버와의 응답을 재확인하여 오리진 서버가 리턴 한 것과 동일한 지 검사했다 &lt;a href=&quot;#section-13.3&quot;&gt;(13.3 절&lt;/a&gt; ). 2. &quot;충분히 신선합니다&quot;( &lt;a href=&quot;#section-13.2&quot;&gt;13.2 절&lt;/a&gt; 참조 ). 기본적으로 이는 클라이언트, 오리진 서버 및 캐시의 최소 제한 신선도 요구 사항을 충족 함을 의미합니다 ( &lt;a href=&quot;#section-14.9&quot;&gt;섹션 14.9&lt;/a&gt; 참조).); 오리진 서버가 이와 같이 지정하면 오리진 서버의 최신 요구 사항입니다. 저장된 응답이 클라이언트와 오리진 서버 모두의 가장 제한적인 신선도 요구 사항으로 인해 &quot;충분히 새로 고침&quot;되지 않은 경우 신중하게 고려 된 상황에서 캐시는 여전히 적절한 경고 헤더와 함께 응답을 반환 할 수 있습니다 &lt;a href=&quot;#section-13.1.5&quot;&gt;(13.1.5&lt;/a&gt; 및 14.46 섹션 참조 ) 그러한 응답이 금지되지 않는 한 (예를 들어, &quot;비 저장&quot;캐시 지시 또는 &quot;비 캐시&quot;캐시 요청 지시에 의해;&lt;a href=&quot;#section-14.9&quot;&gt; 14.9 절&lt;/a&gt;). 3. 적절한 304 (수정되지 않음), 305 (프록시 리디렉션) 또는 오류 (4xx 또는 5xx) 응답 메시지입니다. 캐시가 오리진 서버와 통신 할 수없는 경우, 캐시에서 응답을 올바르게 제공 할 수 있으면 올바른 캐시가 위와 같이 응답해야합니다. 그렇지 않으면 통신 실패가 발생했음을 나타내는 오류 또는 경고를 반환해야합니다. 캐시가 일반적으로 요청하는 클라이언트에게 전달할 응답 (전체 응답 또는 304 (수정되지 않음) 응답)을 수신하고 수신 된 응답이 더 이상 최신 상태가 아닌 경우 캐시는 요청하지 않고 요청 클라이언트에게 전달해야합니다. 새로운 경고 추가 (기존 경고 헤더를 제거하지 않음). 캐시는 단순히 응답이 오래되었다는 이유로 응답을 다시 시도해서는 안된다.이로 인해 무한 루프가 발생할 수 있습니다. 경고없이 오래된 응답을 수신 한 사용자 에이전트는 사용자에게 경고 표시를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89577e07030bd40f6712d10194b453cf2d440e98" translate="yes" xml:space="preserve">
          <source>A cross-site request has previously been performed that already did a preflight, and doing the preflight again is not permitted. Make sure your code only preflights once per connection.</source>
          <target state="translated">사전 비행을 이미 수행 한 교차 사이트 요청이 수행되었으며 사전 비행을 다시 수행 할 수 없습니다. 코드는 연결 당 한 번만 프리 플라이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="a811a3a9985b454708fdc8eb33814dd46cc41295" translate="yes" xml:space="preserve">
          <source>A custom header</source>
          <target state="translated">맞춤 헤더</target>
        </trans-unit>
        <trans-unit id="5a2fa58bd2284006bceccd7cb755ebd723f2c6f7" translate="yes" xml:space="preserve">
          <source>A custom header (such as &lt;code&gt;X-PINGARUNER&lt;/code&gt;) is sent with the request.</source>
          <target state="translated">요청과 함께 사용자 정의 헤더 (예 : &lt;code&gt;X-PINGARUNER&lt;/code&gt; )가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="503ad6dab740192f7df55700acaa852749538c30" translate="yes" xml:space="preserve">
          <source>A date after which to retry. See the &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; header for more details on the HTTP date format.</source>
          <target state="translated">재 시도한 날짜입니다. HTTP 날짜 형식에 대한 자세한 내용 은 &lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 헤더를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b40039ddee641d60641b6ebc43748e9635b227eb" translate="yes" xml:space="preserve">
          <source>A deployment of HTTP/2 over TLS 1.2 SHOULD NOT use any of the cipher
   suites that are listed in the cipher suite black list (Appendix A).

   Endpoints MAY choose to generate a connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;)
   of type INADEQUATE_SECURITY if one of the cipher suites from the
   black list is negotiated.  A deployment that chooses to use a black-
   listed cipher suite risks triggering a connection error unless the
   set of potential peers is known to accept that cipher suite.

   Implementations MUST NOT generate this error in reaction to the
   negotiation of a cipher suite that is not on the black list.
   Consequently, when clients offer a cipher suite that is not on the
   black list, they have to be prepared to use that cipher suite with
   HTTP/2.

   The black list includes the cipher suite that TLS 1.2 makes
   mandatory, which means that TLS 1.2 deployments could have non-
   intersecting sets of permitted cipher suites.  To avoid this problem
   causing TLS handshake failures, deployments of HTTP/2 that use TLS
   1.2 MUST support TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 [&lt;a href=&quot;#ref-TLS-ECDHE&quot;&gt;TLS-ECDHE&lt;/a&gt;]
   with the P-256 elliptic curve [&lt;a href=&quot;#ref-FIPS186&quot;&gt;FIPS186&lt;/a&gt;]. 

   Note that clients might advertise support of cipher suites that are
   on the black list in order to allow for connection to servers that do
   not support HTTP/2.  This allows servers to select HTTP/1.1 with a
   cipher suite that is on the HTTP/2 black list.  However, this can
   result in HTTP/2 being negotiated with a black-listed cipher suite if
   the application protocol and cipher suite are independently selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2cf3c99c4d72849ee4efd8ac6882b05e9d3a1a1" translate="yes" xml:space="preserve">
          <source>A description of the protected area, the realm. If no realm is specified, clients often display a formatted host name instead.</source>
          <target state="translated">보호 된 영역, 영역에 대한 설명 영역을 지정하지 않으면 클라이언트는 종종 형식화 된 호스트 이름을 대신 표시합니다.</target>
        </trans-unit>
        <trans-unit id="5e9d729c23cc7169e172ea196579970b84e7e284" translate="yes" xml:space="preserve">
          <source>A description of the protected area. If no realm is specified, clients often display a formatted hostname instead.</source>
          <target state="translated">보호 영역에 대한 설명 영역을 지정하지 않으면 클라이언트는 종종 형식화 된 호스트 이름을 대신 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b5a8720daf81911489f27aaafe4bd0ccd798eb06" translate="yes" xml:space="preserve">
          <source>A discussion of Cross-Origin Resource Sharing from a server perspective (including PHP code snippets) can be found in the &lt;a href=&quot;server-side_access_control&quot;&gt;Server-Side Access Control (CORS)&lt;/a&gt; article.</source>
          <target state="translated">서버 관점 (PHP 코드 스 니펫 포함)에서의 Cross-Origin Resource Sharing에 대한 설명은 서버 &lt;a href=&quot;server-side_access_control&quot;&gt;측 액세스 제어 (CORS)&lt;/a&gt; 기사 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4908a8b2c4833ed56d01c1531e18571e4bbedba2" translate="yes" xml:space="preserve">
          <source>A document can only load resources from the same origin, or resources explicitly marked as loadable from another origin.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3fc6fb939e0085074cefc8e6d65d3381d91750" translate="yes" xml:space="preserve">
          <source>A few examples:</source>
          <target state="translated">몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="b27d2c2e1b4290f0ba6c37cc3712ff739648e303" translate="yes" xml:space="preserve">
          <source>A form using the &lt;code&gt;multipart/form-data&lt;/code&gt; content type:</source>
          <target state="translated">&lt;code&gt;multipart/form-data&lt;/code&gt; 컨텐츠 유형을 사용하는 양식 :</target>
        </trans-unit>
        <trans-unit id="614f75732c39c44f099d446998fd31224f828fd2" translate="yes" xml:space="preserve">
          <source>A format using the &lt;a href=&quot;http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;Lempel-Ziv coding&lt;/a&gt; (LZ77), with a 32-bit CRC is accepted as a transfer coding name.</source>
          <target state="translated">32 비트 CRC와 함께 &lt;a href=&quot;http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;Lempel-Ziv 코딩&lt;/a&gt; (LZ77)을 사용하는 형식 이 전송 코딩 이름으로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="22748d9ab36c5f67b399f36a38ad2543edae63ac" translate="yes" xml:space="preserve">
          <source>A format using the &lt;a href=&quot;http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;Lempel-Ziv coding&lt;/a&gt; (LZ77), with a 32-bit CRC. This is originally the format of the UNIX &lt;em&gt;gzip&lt;/em&gt; program. The HTTP/1.1 standard also recommends that the servers supporting this content-encoding should recognize &lt;code&gt;x-gzip&lt;/code&gt; as an alias, for compatibility purposes.</source>
          <target state="translated">32 비트 CRC와 함께 &lt;a href=&quot;http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;Lempel-Ziv 코딩&lt;/a&gt; (LZ77)을 사용하는 형식 입니다. 이것은 원래 UNIX &lt;em&gt;gzip&lt;/em&gt; 프로그램 의 형식입니다 . HTTP / 1.1 표준은 또한이 컨텐츠 인코딩을 지원하는 서버 가 호환성을 위해 &lt;code&gt;x-gzip&lt;/code&gt; 을 별명으로 인식하도록 권장 합니다.</target>
        </trans-unit>
        <trans-unit id="ef17edcb9fdca11383c92d9963d7bf24f22d1a7d" translate="yes" xml:space="preserve">
          <source>A format using the &lt;a href=&quot;http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;Lempel-Ziv coding&lt;/a&gt; (LZ77), with a 32-bit CRC. This is the original format of the UNIX &lt;em&gt;gzip&lt;/em&gt; program. The HTTP/1.1 standard also recommends that the servers supporting this content-encoding should recognize &lt;code&gt;x-gzip&lt;/code&gt; as an alias, for compatibility purposes.</source>
          <target state="translated">32 비트 CRC와 함께 &lt;a href=&quot;http://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77&quot;&gt;Lempel-Ziv 코딩&lt;/a&gt; (LZ77)을 사용하는 형식 입니다. 이것은 UNIX &lt;em&gt;gzip&lt;/em&gt; 프로그램 의 원래 형식입니다 . HTTP / 1.1 표준은 또한이 컨텐츠 인코딩을 지원하는 서버 가 호환성을 위해 &lt;code&gt;x-gzip&lt;/code&gt; 을 별명으로 인식하도록 권장 합니다.</target>
        </trans-unit>
        <trans-unit id="44f47b4033a24779dd1d3b91694a7e0c751de3c5" translate="yes" xml:space="preserve">
          <source>A format using the &lt;a href=&quot;http://en.wikipedia.org/wiki/LZW&quot;&gt;Lempel-Ziv-Welch&lt;/a&gt; (LZW) algorithm is accepted as a transfer coding name.</source>
          <target state="translated">LZW ( &lt;a href=&quot;http://en.wikipedia.org/wiki/LZW&quot;&gt;Lempel-Ziv-Welch&lt;/a&gt; ) 알고리즘을 사용하는 형식 이 전송 코딩 이름으로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="ff6501d8ed3cac8df2af44cead1b7ab4b7e10774" translate="yes" xml:space="preserve">
          <source>A format using the &lt;a href=&quot;http://en.wikipedia.org/wiki/LZW&quot;&gt;Lempel-Ziv-Welch&lt;/a&gt; (LZW) algorithm. The value name was taken from the UNIX &lt;em&gt;compress&lt;/em&gt; program, which implemented this algorithm.</source>
          <target state="translated">LZW ( &lt;a href=&quot;http://en.wikipedia.org/wiki/LZW&quot;&gt;Lempel-Ziv-Welch&lt;/a&gt; ) 알고리즘을 사용하는 형식 입니다. 값 이름은 이 알고리즘을 구현 한 UNIX &lt;em&gt;압축&lt;/em&gt; 프로그램 에서 가져 왔습니다 .</target>
        </trans-unit>
        <trans-unit id="474b27ae1efc1cf4c0259d41c022937667b49d1f" translate="yes" xml:space="preserve">
          <source>A format using the &lt;a href=&quot;http://en.wikipedia.org/wiki/LZW&quot;&gt;Lempel-Ziv-Welch&lt;/a&gt; (LZW) algorithm. The value name was taken from the UNIX &lt;em&gt;compress&lt;/em&gt; program, which implemented this algorithm. Like the compress program, which has disappeared from most UNIX distributions, this content-encoding is not used by many browsers today, partly because of a patent issue (it expired in 2003).</source>
          <target state="translated">LZW ( &lt;a href=&quot;http://en.wikipedia.org/wiki/LZW&quot;&gt;Lempel-Ziv-Welch&lt;/a&gt; ) 알고리즘을 사용하는 형식 입니다. 값 이름은 이 알고리즘을 구현 한 UNIX &lt;em&gt;압축&lt;/em&gt; 프로그램 에서 가져 왔습니다 . 대부분의 UNIX 배포판에서 사라진 압축 프로그램과 마찬가지로이 콘텐츠 인코딩은 현재 일부 브라우저에서 사용되지 않으며 부분적으로 특허 문제 (2003 년에 만료 됨)로 인해 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61675e08319d9261f19703357a0adf44d98c5d90" translate="yes" xml:space="preserve">
          <source>A format using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Brotli&quot;&gt;Brotli&lt;/a&gt; algorithm.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Brotli&quot;&gt;Brotli&lt;/a&gt; 알고리즘을 사용하는 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="d3ddbd90fc923592bb2b8a99325a9ed24ae5ba5a" translate="yes" xml:space="preserve">
          <source>A forward proxy, or gateway, or just &quot;proxy&quot; provides proxy services to a client or a group of clients. There are likely hundreds of thousands of open forward proxies on the Internet. They store and forward Internet services (like the DNS, or web pages) to reduce and control the bandwidth used by the group.</source>
          <target state="translated">정방향 프록시 또는 게이트웨이 또는 &quot;프록시&quot;는 클라이언트 또는 클라이언트 그룹에 프록시 서비스를 제공합니다. 인터넷에는 수십만 개의 오픈 포워드 프록시가있을 수 있습니다. 인터넷 서비스 (DNS 또는 웹 페이지 등)를 저장 및 전달하여 그룹에서 사용하는 대역폭을 줄이고 제어합니다.</target>
        </trans-unit>
        <trans-unit id="910536150ef5b9e104120b70b03cb221a8cac548" translate="yes" xml:space="preserve">
          <source>A fresh response is one whose age has not yet exceeded its freshness
   lifetime.  Conversely, a stale response is one where it has.

   A response's freshness lifetime is the length of time between its
   generation by the origin server and its expiration time.  An explicit
   expiration time is the time at which the origin server intends that a
   stored response can no longer be used by a cache without further
   validation, whereas a heuristic expiration time is assigned by a
   cache when no explicit expiration time is available.

   A response's age is the time that has passed since it was generated
   by, or successfully validated with, the origin server.

   When a response is &quot;fresh&quot; in the cache, it can be used to satisfy
   subsequent requests without contacting the origin server, thereby
   improving efficiency.

   The primary mechanism for determining freshness is for an origin
   server to provide an explicit expiration time in the future, using
   either the Expires header field (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;) or the max-age response
   directive (&lt;a href=&quot;#section-5.2.2.8&quot;&gt;Section 5.2.2.8&lt;/a&gt;).  Generally, origin servers will assign
   future explicit expiration times to responses in the belief that the
   representation is not likely to change in a semantically significant
   way before the expiration time is reached.

   If an origin server wishes to force a cache to validate every
   request, it can assign an explicit expiration time in the past to
   indicate that the response is already stale.  Compliant caches will
   normally validate a stale cached response before reusing it for
   subsequent requests (see &lt;a href=&quot;#section-4.2.4&quot;&gt;Section 4.2.4&lt;/a&gt;).

   Since origin servers do not always provide explicit expiration times,
   caches are also allowed to use a heuristic to determine an expiration
   time under certain circumstances (see &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;).

   The calculation to determine if a response is fresh is:

      response_is_fresh = (freshness_lifetime &amp;gt; current_age)

   freshness_lifetime is defined in &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;; current_age is
   defined in &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;.

   Clients can send the max-age or min-fresh cache directives in a
   request to constrain or relax freshness calculations for the
   corresponding response (&lt;a href=&quot;#section-5.2.1&quot;&gt;Section 5.2.1&lt;/a&gt;). 

   When calculating freshness, to avoid common problems in date parsing:

   o  Although all date formats are specified to be case-sensitive, a
      cache recipient SHOULD match day, week, and time-zone names
      case-insensitively.

   o  If a cache recipient's internal implementation of time has less
      resolution than the value of an HTTP-date, the recipient MUST
      internally represent a parsed Expires date as the nearest time
      equal to or earlier than the received value.

   o  A cache recipient MUST NOT allow local time zones to influence the
      calculation or comparison of an age or expiration time.

   o  A cache recipient SHOULD consider a date with a zone abbreviation
      other than GMT or UTC to be invalid for calculating expiration.

   Note that freshness applies only to cache operation; it cannot be
   used to force a user agent to refresh its display or reload a
   resource.  See &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt; for an explanation of the difference between
   caches and history mechanisms.</source>
          <target state="translated">신선한 반응은 나이가 아직 신선도 수명을 초과하지 않은 반응입니다. 반대로 부실한 반응은 그것이있는 것입니다. 응답의 신선도 수명은 오리진 서버에 의한 생성 시간과 만료 시간 사이의 시간입니다. 명시 적 만기 시간은 오리진 서버가 저장된 응답을 더 이상 유효성 검증없이 캐시에서 더 이상 사용할 수 없도록하는 시간이며, 휴리스틱 만기 시간은 명시 적 만기 시간이 없을 때 캐시에 의해 지정됩니다. 응답 기간은 오리진 서버에서 생성했거나 검증 한 이후 경과 한 시간입니다. 캐시에서 응답이 &quot;신선한&quot;경우 원본 서버에 접속하지 않고 후속 요청을 충족시키는 데 사용될 수 있으므로 효율성이 향상됩니다.신선도를 결정하는 기본 메커니즘은 원본 서버가 Expires 헤더 필드 (&lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt; ) 또는 최대 연령 응답 지시문 ( &lt;a href=&quot;#section-5.2.2.8&quot;&gt;섹션 5.2.2.8&lt;/a&gt; ). 일반적으로, 원 서버는 표현이 만료 시간에 도달하기 전에 의미 적으로 중요한 방식으로 변경되지 않을 것이라는 믿음으로 미래의 명시적인 만료 시간을 응답에 할당합니다. 오리진 서버가 캐시가 모든 요청의 유효성을 검증하도록하려면 과거에 명시 적으로 만료 시간을 지정하여 응답이 이미 오래되었음을 표시 할 수 있습니다. 호환 캐시는 일반적으로 후속 요청에 재사용하기 전에 오래된 캐시 응답의 유효성을 검사합니다 ( &lt;a href=&quot;#section-4.2.4&quot;&gt;4.2.4 절&lt;/a&gt; 참조)). 오리진 서버가 항상 명시적인 만료 시간을 제공하지는 않기 때문에 캐시는 휴리스틱을 사용하여 특정 상황에서 만료 시간을 결정할 수도 있습니다 ( 참조&lt;a href=&quot;#section-5.2.1&quot;&gt; 5.2.1 절).&lt;/a&gt;&lt;a href=&quot;#section-4.2.2&quot;&gt;섹션 4.2.2&lt;/a&gt; ). 응답이 최신인지 확인하는 계산은 다음과 같습니다. response_is_fresh = (freshness_lifetime&amp;gt; current_age) freshness_lifetime은 &lt;a href=&quot;#section-4.2.1&quot;&gt;섹션 4.2.1에&lt;/a&gt; 정의되어 있습니다 . current_age는 &lt;a href=&quot;#section-4.2.3&quot;&gt;4.2.3 절에&lt;/a&gt; 정의되어 있습니다. 고객은 요청에 따라 max-age 또는 min-fresh 캐시 지시문을 보내 해당 응답에 대한 최신 성 계산을 제한하거나 완화 할 수 있습니다 (). 신선도를 계산할 때 날짜 구문 분석의 일반적인 문제를 피하려면 : o 모든 날짜 형식이 대소 문자를 구분하도록 지정되었지만 캐시 수신자는 날짜, 주 및 시간대 이름을 대소 문자를 구분하지 않아야합니다. o 캐시 수신자의 내부 시간 구현이 HTTP- 날짜 값보다 해상도가 낮은 경우, 수신자는 구문 분석 된 만기 날짜를 수신 된 값과 가장 근접한 시간으로 내부적으로 나타내야합니다. o 캐시 수신자는 현지 시간대가 사용 기간 또는 만료 시간의 계산 또는 비교에 영향을 미치지 않아야합니다. o 캐시 수신자는 GMT 또는 UTC 이외의 영역 약어가있는 날짜가 만료 계산에 유효하지 않은 것으로 간주해야합니다. 신선도는 캐시 작업에만 적용됩니다.사용자 에이전트가 표시를 새로 고치거나 자원을 다시로드하도록하는 데 사용할 수 없습니다. 보다&lt;a href=&quot;#section-6&quot;&gt;&lt;/a&gt;캐시와 히스토리 메커니즘의 차이점에 대한 설명은 6 절 .</target>
        </trans-unit>
        <trans-unit id="ec3a4e1f8c0ddeb70da974b4f25090860679d57c" translate="yes" xml:space="preserve">
          <source>A full language tag. In addition to the language itself, it may contain additional information after a &lt;code&gt;'-'&lt;/code&gt;. The most common extra information is the country variant (like &lt;code&gt;'en-US'&lt;/code&gt;) or the type of alphabet to use (like &lt;code&gt;'sr-Lat'&lt;/code&gt;). Other variants like the type of orthography (&lt;code&gt;'de-DE-1996'&lt;/code&gt;) are usually not used in the context of this header.</source>
          <target state="translated">완전한 언어 태그. 언어 자체 외에도 &lt;code&gt;'-'&lt;/code&gt; 뒤에 추가 정보가 포함될 수 있습니다 . 가장 일반적인 추가 정보는 국가 변형 (예 : &lt;code&gt;'en-US'&lt;/code&gt; ) 또는 사용할 알파벳 유형 (예 : &lt;code&gt;'sr-Lat'&lt;/code&gt; )입니다. 직교 법 유형 ( &lt;code&gt;'de-DE-1996'&lt;/code&gt; ) 과 같은 다른 변형 은 일반적으로이 헤더와 관련하여 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f898e90d14bf75f1a87a64bdb376f6dbabf567d" translate="yes" xml:space="preserve">
          <source>A general warning field containing information about possible problems.</source>
          <target state="translated">가능한 문제에 대한 정보가 포함 된 일반 경고 필드입니다.</target>
        </trans-unit>
        <trans-unit id="0a3e8915e8c75e5f7d73ca07d7035d1049a05c98" translate="yes" xml:space="preserve">
          <source>A language expressed as a 2 or 3-character string.</source>
          <target state="translated">2 자 또는 3 자 문자열로 표현 된 언어입니다.</target>
        </trans-unit>
        <trans-unit id="746b4aed00138f5979b1e170746db262eb836c96" translate="yes" xml:space="preserve">
          <source>A language tag (which is sometimes referred to as a &quot;locale identifier&quot;). This consists of a 2-3 letter base language tag representing the language, optionally followed by additional subtags separated by &lt;code&gt;'-'&lt;/code&gt;. The most common extra information is the country or region variant (like &lt;code&gt;'en-US'&lt;/code&gt; or &lt;code&gt;'fr-CA'&lt;/code&gt;) or the type of alphabet to use (like &lt;code&gt;'sr-Latn'&lt;/code&gt;). Other variants like the type of orthography (&lt;code&gt;'de-DE-1996'&lt;/code&gt;) are usually not used in the context of this header.</source>
          <target state="translated">언어 태그 ( &quot;로케일 식별자&quot;라고도 함). 이는 언어를 나타내는 2-3 자의 기본 언어 태그로 구성되며 선택적으로 &lt;code&gt;'-'&lt;/code&gt; 로 구분 된 추가 하위 태그가 뒤 따릅니다 . 가장 일반적인 추가 정보는 국가 또는 지역 변형 (예 : &lt;code&gt;'en-US'&lt;/code&gt; 또는 &lt;code&gt;'fr-CA'&lt;/code&gt; ) 또는 사용할 알파벳 유형 (예 : &lt;code&gt;'sr-Latn'&lt;/code&gt; )입니다. orthography 유형 ( &lt;code&gt;'de-DE-1996'&lt;/code&gt; ) 과 같은 다른 변형 은 일반적으로이 헤더의 컨텍스트에서 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="492fb7060c509851f8ee1f0684fc115667c9e3f7" translate="yes" xml:space="preserve">
          <source>A language tag identifies a natural language spoken, written, or
   otherwise conveyed by human beings for communication of information
   to other human beings. Computer languages are explicitly excluded.
   HTTP uses language tags within the Accept-Language and Content-
   Language fields.

   The syntax and registry of HTTP language tags is the same as that
   defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1766&quot;&gt;RFC 1766&lt;/a&gt; [&lt;a href=&quot;#ref-1&quot;&gt;1&lt;/a&gt;]. In summary, a language tag is composed of 1
   or more parts: A primary language tag and a possibly empty series of
   subtags:

        language-tag  = primary-tag *( &quot;-&quot; subtag )
        primary-tag   = 1*8ALPHA
        subtag        = 1*8ALPHA

   White space is not allowed within the tag and all tags are case-
   insensitive. The name space of language tags is administered by the
   IANA. Example tags include:

       en, en-US, en-cockney, i-cherokee, x-pig-latin 

   where any two-letter primary-tag is an ISO-639 language abbreviation
   and any two-letter initial subtag is an ISO-3166 country code. (The
   last three tags above are not registered tags; all but the last are
   examples of tags which could be registered in future.)</source>
          <target state="translated">언어 태그는 다른 사람에게 정보를 전달하기 위해 사람이 말하거나 쓰거나 다른 방식으로 전달하는 자연어를 식별합니다. 컴퓨터 언어는 명시 적으로 제외됩니다. HTTP는 Accept-Language 및 Content- Language 필드에서 언어 태그를 사용합니다. HTTP 언어 태그의 구문과 레지스트리는 &lt;a href=&quot;https://tools.ietf.org/html/rfc1766&quot;&gt;RFC 1766&lt;/a&gt; [ &lt;a href=&quot;#ref-1&quot;&gt;1&lt;/a&gt;]. 요약하면 언어 태그는 1 개 이상의 부분으로 구성됩니다. 기본 언어 태그 및 빈 일련의 하위 태그 : language-tag = primary-tag * ( &quot;-&quot;subtag) primary-tag = 1 * 8ALPHA subtag = 1 * 8ALPHA 태그 내에 공백이 허용되지 않으며 모든 태그는 대소 문자를 구분하지 않습니다. 언어 태그의 네임 스페이스는 IANA에서 관리합니다. 태그 예는 다음과 같습니다. en, en-US, en-cockney, i-cherokee, x-pig-latin 여기서 두 글자 기본 태그는 ISO-639 언어 약어이고 모든 두 글자 초기 하위 태그는 ISO-3166입니다. 국가 코드. (위의 마지막 3 개 태그는 등록 된 태그가 아니며 마지막 태그는 모두 나중에 등록 할 수있는 태그의 예입니다.)</target>
        </trans-unit>
        <trans-unit id="94092a3bb36b69c98b3f284dcd812139e3cd4535" translate="yes" xml:space="preserve">
          <source>A language tag, as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5646&quot;&gt;RFC5646&lt;/a&gt;], identifies a natural
   language spoken, written, or otherwise conveyed by human beings for
   communication of information to other human beings.  Computer
   languages are explicitly excluded.

   HTTP uses language tags within the Accept-Language and
   Content-Language header fields.  Accept-Language uses the broader
   language-range production defined in &lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt;, whereas
   Content-Language uses the language-tag production defined below.

     language-tag = &amp;lt;Language-Tag, see &lt;a href=&quot;https://tools.ietf.org/html/rfc5646#section-2.1&quot;&gt;[RFC5646], Section&amp;nbsp;2.1&lt;/a&gt;&amp;gt;

   A language tag is a sequence of one or more case-insensitive subtags,
   each separated by a hyphen character (&quot;-&quot;, %x2D).  In most cases, a
   language tag consists of a primary language subtag that identifies a
   broad family of related languages (e.g., &quot;en&quot; = English), which is
   optionally followed by a series of subtags that refine or narrow that
   language's range (e.g., &quot;en-CA&quot; = the variety of English as
   communicated in Canada).  Whitespace is not allowed within a language
   tag.  Example tags include:

     fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN

   See [&lt;a href=&quot;https://tools.ietf.org/html/rfc5646&quot;&gt;RFC5646&lt;/a&gt;] for further information.</source>
          <target state="translated">[ &lt;a href=&quot;https://tools.ietf.org/html/rfc5646&quot;&gt;RFC5646&lt;/a&gt; ]에 정의 된 언어 태그 는 다른 사람에게 정보를 전달하기 위해 사람이 말하거나 쓰거나 다른 방식으로 전달하는 자연어를 식별합니다. 컴퓨터 언어는 명시 적으로 제외됩니다. HTTP는 Accept-Language 및 Content-Language 헤더 필드에서 언어 태그를 사용합니다. Accept-Language는 &lt;a href=&quot;#section-5.3.5&quot;&gt;5.3.5 절&lt;/a&gt; 에서 정의 된 더 넓은 언어 범위 제작을 사용하는 반면 Content-Language는 아래 정의 된 언어 태그 제작을 사용합니다. language-tag = &amp;lt;언어-태그 &lt;a href=&quot;https://tools.ietf.org/html/rfc5646#section-2.1&quot;&gt;, 섹션 2.1 [RFC5646]&lt;/a&gt; 참조&amp;gt; 언어 태그는 대소 문자를 구분하지 않는 하나 이상의 하위 태그 시퀀스로, 하이픈 문자 ( &quot;-&quot;, % x2D)로 구분됩니다. 대부분의 경우 언어 태그는 광범위한 관련 언어 제품군 (예 : &quot;en&quot;= 영어)을 식별하는 기본 언어 하위 태그로 구성되며, 선택적으로 해당 언어의 범위를 세분화하거나 좁히는 일련의 하위 태그 (예 : &quot;en-CA&quot;= 캐나다에서 의사 소통되는 다양한 영어). 언어 태그에는 공백이 허용되지 않습니다. 태그 예는 다음과 같습니다. fr, en-US, es-419, az-Arab, x-pig-latin, man-Nkoo-GN 자세한 내용은 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5646&quot;&gt;RFC5646&lt;/a&gt; ]을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e661c244f36d3503b3fccce131704ef80b3983c9" translate="yes" xml:space="preserve">
          <source>A large header block (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) can cause an implementation to
   commit a large amount of state.  Header fields that are critical for
   routing can appear toward the end of a header block, which prevents
   streaming of header fields to their ultimate destination.  This
   ordering and other reasons, such as ensuring cache correctness, mean 

   that an endpoint might need to buffer the entire header block.  Since
   there is no hard limit to the size of a header block, some endpoints
   could be forced to commit a large amount of available memory for
   header fields.

   An endpoint can use the SETTINGS_MAX_HEADER_LIST_SIZE to advise peers
   of limits that might apply on the size of header blocks.  This
   setting is only advisory, so endpoints MAY choose to send header
   blocks that exceed this limit and risk having the request or response
   being treated as malformed.  This setting is specific to a
   connection, so any request or response could encounter a hop with a
   lower, unknown limit.  An intermediary can attempt to avoid this
   problem by passing on values presented by different peers, but they
   are not obligated to do so.

   A server that receives a larger header block than it is willing to
   handle can send an HTTP 431 (Request Header Fields Too Large) status
   code [&lt;a href=&quot;https://tools.ietf.org/html/rfc6585&quot;&gt;RFC6585&lt;/a&gt;].  A client can discard responses that it cannot
   process.  The header block MUST be processed to ensure a consistent
   connection state, unless the connection is closed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f7a702b8c7697ca25eba936c967f0eb503afb30" translate="yes" xml:space="preserve">
          <source>A list of exposed headers consisting of zero or more &lt;a href=&quot;../headers&quot;&gt;header names&lt;/a&gt; other than the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_request_header&quot;&gt;CORS-safelisted request headers&lt;/a&gt; that the resource might use and can be exposed.</source>
          <target state="translated">리소스가 사용할 수 있고 노출 될 수있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_request_header&quot;&gt;CORS 허용 목록 요청 헤더&lt;/a&gt; 를 제외하고 0 개 이상의 &lt;a href=&quot;../headers&quot;&gt;헤더 이름&lt;/a&gt; 으로 구성된 노출 된 헤더 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="401eed78acd05f98cd45899dd71bdbf7ded19951" translate="yes" xml:space="preserve">
          <source>A list of exposed headers consisting of zero or more &lt;a href=&quot;../headers&quot;&gt;header names&lt;/a&gt; other than the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Simple_response_header&quot;&gt;simple response headers&lt;/a&gt; that the resource might use and can be exposed.</source>
          <target state="translated">자원이 사용할 수 있고 노출 될 수있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Simple_response_header&quot;&gt;단순 응답 헤더&lt;/a&gt; 이외 의 0 개 이상의 &lt;a href=&quot;../headers&quot;&gt;헤더 이름&lt;/a&gt; 으로 구성된 노출 된 헤더 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="a086a61548ed72dd4794fb8ac5f997765cb5cd7d" translate="yes" xml:space="preserve">
          <source>A list of name-value pairs in the form of &lt;code&gt;&amp;lt;cookie-name&amp;gt;=&amp;lt;cookie-value&amp;gt;&lt;/code&gt;. Pairs in the list are separated by a semicolon and a space (&lt;code&gt;'; '&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&amp;lt;cookie-name&amp;gt;=&amp;lt;cookie-value&amp;gt;&lt;/code&gt; 형식의 이름-값 쌍 목록입니다 . 목록의 쌍은 세미콜론과 공백 ( &lt;code&gt;'; '&lt;/code&gt; )으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="201228fcd5cdd61ee1713b535c51e93b617c9561" translate="yes" xml:space="preserve">
          <source>A lock MAY have a limited lifetime.  The lifetime is suggested by the
   client when creating or refreshing the lock, but the server
   ultimately chooses the timeout value.  Timeout is measured in seconds
   remaining until lock expiration.

   The timeout counter MUST be restarted if a refresh lock request is
   successful (see &lt;a href=&quot;#section-9.10.2&quot;&gt;Section 9.10.2&lt;/a&gt;).  The timeout counter SHOULD NOT be
   restarted at any other time.

   If the timeout expires, then the lock SHOULD be removed.  In this
   case the server SHOULD act as if an UNLOCK method was executed by the 

   server on the resource using the lock token of the timed-out lock,
   performed with its override authority.

   Servers are advised to pay close attention to the values submitted by
   clients, as they will be indicative of the type of activity the
   client intends to perform.  For example, an applet running in a
   browser may need to lock a resource, but because of the instability
   of the environment within which the applet is running, the applet may
   be turned off without warning.  As a result, the applet is likely to
   ask for a relatively small timeout value so that if the applet dies,
   the lock can be quickly harvested.  However, a document management
   system is likely to ask for an extremely long timeout because its
   user may be planning on going offline.

   A client MUST NOT assume that just because the timeout has expired,
   the lock has immediately been removed.

   Likewise, a client MUST NOT assume that just because the timeout has
   not expired, the lock still exists.  Clients MUST assume that locks
   can arbitrarily disappear at any time, regardless of the value given
   in the Timeout header.  The Timeout header only indicates the
   behavior of the server if extraordinary circumstances do not occur.
   For example, a sufficiently privileged user may remove a lock at any
   time, or the system may crash in such a way that it loses the record
   of the lock's existence.</source>
          <target state="translated">자물쇠는 수명이 제한 될 수 있습니다. 잠금을 작성하거나 새로 고칠 때 클라이언트가 수명을 제안하지만 궁극적으로 서버는 시간 종료 값을 선택합니다. 제한 시간은 잠금 만료까지 남은 시간 (초)으로 측정됩니다. 새로 고침 잠금 요청이 성공하면 타임 아웃 카운터를 반드시 다시 시작해야합니다 ( &lt;a href=&quot;#section-9.10.2&quot;&gt;9.10.2 절&lt;/a&gt; 참조)). The timeout counter SHOULD NOT be restarted at any other time. If the timeout expires, then the lock SHOULD be removed. In this case the server SHOULD act as if an UNLOCK method was executed by the server on the resource using the lock token of the timed-out lock, performed with its override authority. Servers are advised to pay close attention to the values submitted by clients, as they will be indicative of the type of activity the client intends to perform. For example, an applet running in a browser may need to lock a resource, but because of the instability of the environment within which the applet is running, the applet may be turned off without warning. As a result, the applet is likely to ask for a relatively small timeout value so that if the applet dies, the lock can be quickly harvested. However, a document management system is likely to ask for an extremely long timeout because its user may be planning on going offline. A client MUST NOT assume that just because the timeout has expired, the lock has immediately been removed. Likewise, a client MUST NOT assume that just because the timeout has not expired, the lock still exists. Clients MUST assume that locks can arbitrarily disappear at any time, regardless of the value given in the Timeout header. The Timeout header only indicates the behavior of the server if extraordinary circumstances do not occur. For example, a sufficiently privileged user may remove a lock at any time, or the system may crash in such a way that it loses the record of the lock's existence.</target>
        </trans-unit>
        <trans-unit id="a65767371978fb7907be1bc9f3cea569719dbaa4" translate="yes" xml:space="preserve">
          <source>A lock is refreshed by sending a LOCK request to the URL of a
   resource within the scope of the lock.  This request MUST NOT have a
   body and it MUST specify which lock to refresh by using the 'If'
   header with a single lock token (only one lock may be refreshed at a
   time).  The request MAY contain a Timeout header, which a server MAY
   accept to change the duration remaining on the lock to the new value.
   A server MUST ignore the Depth header on a LOCK refresh.

   If the resource has other (shared) locks, those locks are unaffected
   by a lock refresh.  Additionally, those locks do not prevent the
   named lock from being refreshed.

   The Lock-Token header is not returned in the response for a
   successful refresh LOCK request, but the LOCK response body MUST
   contain the new value for the DAV:lockdiscovery property.</source>
          <target state="translated">잠금 범위 내의 자원 URL에 LOCK 요청을 보내 잠금을 새로 고칩니다. 이 요청에는 본문이 없어야하며 단일 잠금 토큰과 함께 'If'헤더를 사용하여 새로 고칠 잠금을 지정해야합니다 (한 번에 하나의 잠금 만 새로 고칠 수 있음). 요청은 타임 아웃 헤더를 포함 할 수 있으며, 서버는 잠금에 남아있는 지속 시간을 새로운 값으로 변경하기 위해 수용 할 수있다. 서버는 반드시 잠금 새로 고침시 깊이 헤더를 무시해야합니다. 리소스에 다른 (공유) 잠금이있는 경우 해당 잠금은 잠금 새로 고침의 영향을받지 않습니다. 또한 이러한 잠금으로 인해 명명 된 잠금이 새로 고쳐지지 않습니다. Lock-Token 헤더는 성공적인 새로 고침 LOCK 요청에 대한 응답으로 반환되지 않지만 LOCK 응답 본문에는 DAV : lockdiscovery 속성에 대한 새 값이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2d1c6621f1a90b5ee7c672cc60c74be33fafb4aa" translate="yes" xml:space="preserve">
          <source>A lock token is a type of state token that identifies a particular
   lock.  Each lock has exactly one unique lock token generated by the
   server.  Clients MUST NOT attempt to interpret lock tokens in any
   way.

   Lock token URIs MUST be unique across all resources for all time.
   This uniqueness constraint allows lock tokens to be submitted across
   resources and servers without fear of confusion.  Since lock tokens
   are unique, a client MAY submit a lock token in an If header on a
   resource other than the one that returned it.

   When a LOCK operation creates a new lock, the new lock token is
   returned in the Lock-Token response header defined in &lt;a href=&quot;#section-10.5&quot;&gt;Section 10.5&lt;/a&gt;,
   and also in the body of the response.

   Servers MAY make lock tokens publicly readable (e.g., in the DAV:
   lockdiscovery property).  One use case for making lock tokens
   readable is so that a long-lived lock can be removed by the resource
   owner (the client that obtained the lock might have crashed or
   disconnected before cleaning up the lock).  Except for the case of
   using UNLOCK under user guidance, a client SHOULD NOT use a lock
   token created by another client instance.

   This specification encourages servers to create Universally Unique
   Identifiers (UUIDs) for lock tokens, and to use the URI form defined
   by &quot;A Universally Unique Identifier (UUID) URN Namespace&quot;
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC4122&lt;/a&gt;]).  However, servers are free to use any URI (e.g., from
   another scheme) so long as it meets the uniqueness requirements.  For
   example, a valid lock token might be constructed using the
   &quot;opaquelocktoken&quot; scheme defined in &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;.

   Example: &quot;urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6&quot;</source>
          <target state="translated">잠금 토큰은 특정 잠금을 식별하는 상태 토큰 유형입니다. 각 잠금에는 서버에서 생성 한 고유 한 잠금 토큰이 정확히 하나 있습니다. 클라이언트는 어떤 식 으로든 잠금 토큰을 해석하려고 시도해서는 안됩니다. 잠금 토큰 URI는 모든 자원에서 항상 고유해야합니다. 이 고유 제한 조건을 통해 혼동의 염려없이 자원 및 서버에 잠금 토큰을 제출할 수 있습니다. 잠금 토큰은 고유하기 때문에 클라이언트는 잠금 토큰을 반환 한 리소스가 아닌 다른 리소스의 If 헤더에 잠금 토큰을 제출할 수 있습니다. LOCK 조작이 새 잠금을 작성하면 &lt;a href=&quot;#section-10.5&quot;&gt;10.5 절에&lt;/a&gt; 정의 된 잠금 토큰 응답 헤더에 새 잠금 토큰이 리턴됩니다.그리고 응답의 본문에도 있습니다. 서버는 잠금 토큰을 공개적으로 읽을 수있게 만들 수 있습니다 (예 : DAV : lockdiscovery 속성). 잠금 토큰을 읽을 수있게 만드는 한 가지 사용 사례는 리소스 소유자가 오래 지속 된 잠금을 제거 할 수 있도록하는 것입니다 (잠금을 확보 한 클라이언트가 잠금을 정리하기 전에 충돌하거나 연결이 끊어졌을 수 있음). 사용자 지침에 따라 UNLOCK을 사용하는 경우를 제외하고 클라이언트는 다른 클라이언트 인스턴스에서 생성 한 잠금 토큰을 사용해서는 안됩니다. 이 스펙은 서버가 잠금 토큰에 대한 UUID (Universally Unique Identifier)를 작성하고 &quot;UUID (Universally Unique Identifier) ​​URN 네임 스페이스&quot;([ &lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC4122&lt;/a&gt; )에 정의 된 URI 양식을 사용하도록 권장합니다.]). 그러나 서버는 고유성 요구 사항을 충족하는 한 (예 : 다른 체계의) 모든 URI를 자유롭게 사용할 수 있습니다. 예를 들어, 유효한 잠금 토큰은 &lt;a href=&quot;#appendix-C&quot;&gt;부록 C에&lt;/a&gt; 정의 된 &quot;opaquelocktoken&quot;체계를 사용하여 구성 될 수 있습니다 . 예 : &quot;urn : uuid : f81d4fae-7dec-11d0-a765-00a0c91e6bf6&quot;</target>
        </trans-unit>
        <trans-unit id="38e28447330e8077fc8cab54715d0f561c86ebbf" translate="yes" xml:space="preserve">
          <source>A machine-usable email address.</source>
          <target state="translated">컴퓨터에서 사용할 수있는 이메일 주소입니다.</target>
        </trans-unit>
        <trans-unit id="638122c7d8d04d744e55be1901fffac264110971" translate="yes" xml:space="preserve">
          <source>A malformed request or response is one that is an otherwise valid
   sequence of HTTP/2 frames but is invalid due to the presence of
   extraneous frames, prohibited header fields, the absence of mandatory
   header fields, or the inclusion of uppercase header field names.

   A request or response that includes a payload body can include a
   content-length header field.  A request or response is also malformed
   if the value of a content-length header field does not equal the sum
   of the DATA frame payload lengths that form the body.  A response
   that is defined to have no payload, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;[RFC7230],
   Section&amp;nbsp;3.3.2&lt;/a&gt;, can have a non-zero content-length header field, even
   though no content is included in DATA frames.

   Intermediaries that process HTTP requests or responses (i.e., any
   intermediary not acting as a tunnel) MUST NOT forward a malformed
   request or response.  Malformed requests or responses that are
   detected MUST be treated as a stream error (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) of type
   PROTOCOL_ERROR.

   For malformed requests, a server MAY send an HTTP response prior to
   closing or resetting the stream.  Clients MUST NOT accept a malformed
   response.  Note that these requirements are intended to protect
   against several types of common attacks against HTTP; they are
   deliberately strict because being permissive can expose
   implementations to these vulnerabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe425fac28cb48d5475051bae0bfe4902aafb25c" translate="yes" xml:space="preserve">
          <source>A message that encapsulates other messages. This can be used, for instance, to represent an email that includes a forwarded message as part of its data, or to allow sending very large messages in chunks as if it were multiple messages. Examples include &lt;code&gt;message/rfc822&lt;/code&gt; (for forwarded or replied-to message quoting) and &lt;code&gt;message/partial&lt;/code&gt; to allow breaking a large message into smaller ones automatically to be reassembled by the recipient.</source>
          <target state="translated">다른 메시지를 캡슐화하는 메시지입니다. 예를 들어 전달 된 메시지를 데이터의 일부로 포함하는 이메일을 나타내거나 매우 큰 메시지를 여러 메시지 인 것처럼 청크로 보낼 수 있습니다. 예를 들어 &lt;code&gt;message/rfc822&lt;/code&gt; (전달되거나 회신 된 메시지 인용 용) 및 &lt;code&gt;message/partial&lt;/code&gt; 을 포함하여 큰 메시지를 작은 메시지로 자동 분할하여 수신자가 재 조립합니다.</target>
        </trans-unit>
        <trans-unit id="e534d830d6d1a4baaca41c124f70dc5dd2676c60" translate="yes" xml:space="preserve">
          <source>A method other than &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; is used, or if &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; is used with a &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;&lt;strong&gt;other than&lt;/strong&gt; one of &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code&gt;multipart/form-data&lt;/code&gt;, or &lt;code&gt;text/plain&lt;/code&gt;. For instance, if the &lt;code&gt;Content-Type&lt;/code&gt; of the &lt;code&gt;POST&lt;/code&gt; body is &lt;code&gt;application/xml&lt;/code&gt;, a request is preflighted.</source>
          <target state="translated">이외의 방법 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; 를&lt;/a&gt; 사용하는 경우, 또는되고 &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; 가&lt;/a&gt; 함께 사용되는 &lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;&lt;strong&gt; 이외&lt;/strong&gt; 의 일 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; , &lt;code&gt;multipart/form-data&lt;/code&gt; , 또는 &lt;code&gt;text/plain&lt;/code&gt; . 경우 예를 들어, &lt;code&gt;Content-Type&lt;/code&gt; 의 &lt;code&gt;POST&lt;/code&gt; 의 몸은 &lt;code&gt;application/xml&lt;/code&gt; , 요청이 preflighted된다.</target>
        </trans-unit>
        <trans-unit id="aed855bd7233b72a834c1273c05aff7651b0d47d" translate="yes" xml:space="preserve">
          <source>A more radical approach to cookies are zombie cookies or &quot;Evercookies&quot; which are recreated after their deletion and are intentionally hard to delete forever. They are using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API&quot;&gt;Web storage API&lt;/a&gt;, Flash Local Shared Objects and other techniques to recreate themselves whenever the cookie's absence is detected.</source>
          <target state="translated">쿠키에 대한보다 급진적 인 접근 방식은 좀비 쿠키 또는 &quot;Evercookies&quot;로, 삭제 후 다시 생성되며 의도적으로 영구적으로 삭제하기가 어렵습니다. 그들은 사용하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API&quot;&gt;웹 스토리지 API를&lt;/a&gt; , 플래시 로컬 공유는 개체와 쿠키의 부재가 탐지 될 때마다 다른 기술 자체를 다시.</target>
        </trans-unit>
        <trans-unit id="b6cbf91c7a233e2d92640564b32c98fc24c39369" translate="yes" xml:space="preserve">
          <source>A non-negative decimal integer indicating the seconds to delay after the response is received.</source>
          <target state="translated">응답이 수신 된 후 지연되는 초를 나타내는 음이 아닌 10 진수입니다.</target>
        </trans-unit>
        <trans-unit id="6619a7d6c651e30a9c93d75a3aae971cdd6730a9" translate="yes" xml:space="preserve">
          <source>A non-negative integer, representing time in seconds the object has been in a proxy cache.</source>
          <target state="translated">객체가 프록시 캐시에 있었던 시간을 초 단위로 나타내는 음이 아닌 정수입니다.</target>
        </trans-unit>
        <trans-unit id="de5cdae960d879dbf9f2c82fb00f32d958dffa0f" translate="yes" xml:space="preserve">
          <source>A number of security issues (e.g. phishing) have been associated with data URLs, and navigating to them in the browser's top level. To mitigate such issues, top-level navigation to &lt;code&gt;data://&lt;/code&gt; URIs has been blocked in Firefox 59+ (release version, Nightly/Beta from 58), and we hope to see other browsers follow suit soon. &lt;a href=&quot;https://blog.mozilla.org/security/2017/11/27/blocking-top-level-navigations-data-urls-firefox-58/&quot;&gt;See Blocking Top-Level Navigations to data URLs for Firefox 58&lt;/a&gt; for more details.</source>
          <target state="translated">여러 가지 보안 문제 (예 : 피싱)가 데이터 URL과 관련되어 브라우저의 최상위 수준으로 이동합니다. 이러한 문제를 완화하기 위해 Firefox 59 이상 (릴리스 버전, Nightly / Beta 58)에서 &lt;code&gt;data://&lt;/code&gt; URI에 대한 최상위 수준 탐색 이 차단되었으며 다른 브라우저도 곧 사용할 수 있기를 바랍니다. &lt;a href=&quot;https://blog.mozilla.org/security/2017/11/27/blocking-top-level-navigations-data-urls-firefox-58/&quot;&gt;자세한 내용은 Firefox 58의 데이터 URL에 대한 최상위 탐색 차단&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="141411a44840cd22ecb3eb10490b2fda0a7babf0" translate="yes" xml:space="preserve">
          <source>A number of security issues (e.g. phishing) have been associated with data URLs, and navigating to them in the browser's top level. To mitigate such issues, top-level navigation to &lt;code&gt;data://&lt;/code&gt; URLs has been blocked in Firefox 59+ (release version, Nightly/Beta from 58), and we hope to see other browsers follow suit soon. &lt;a href=&quot;https://blog.mozilla.org/security/2017/11/27/blocking-top-level-navigations-data-urls-firefox-58/&quot;&gt;See Blocking Top-Level Navigations to data URLs for Firefox 58&lt;/a&gt; for more details.</source>
          <target state="translated">여러 보안 문제 (예 : 피싱)가 데이터 URL과 관련되어 있으며 브라우저의 최상위 수준에서 탐색합니다. 이러한 문제를 완화하기 위해 Firefox 59+ (릴리스 버전, 58의 Nightly / Beta)에서 &lt;code&gt;data://&lt;/code&gt; URL에 대한 최상위 탐색 이 차단되었으며, 곧 다른 브라우저에서도이를 따르기를 바랍니다. &lt;a href=&quot;https://blog.mozilla.org/security/2017/11/27/blocking-top-level-navigations-data-urls-firefox-58/&quot;&gt;자세한 내용은 Firefox 58&lt;/a&gt; 용 데이터 URL에 대한 최상위 탐색 차단 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="11607966c4ade482e455f279b7d34f6602b327af" translate="yes" xml:space="preserve">
          <source>A number that indicates the client&amp;rsquo;s current Device Pixel Ratio (DPR), which is the ratio of physical pixels over CSS pixels (Section 5.2 of &lt;a href=&quot;https://httpwg.org/http-extensions/client-hints.html#CSSVAL&quot;&gt;&lt;cite&gt;[CSSVAL]&lt;/cite&gt;&lt;/a&gt;) of the layout viewport (Section 9.1.1 of &lt;a href=&quot;https://httpwg.org/http-extensions/client-hints.html#CSS2&quot;&gt;&lt;cite&gt;[CSS2]&lt;/cite&gt;&lt;/a&gt;) on the device.</source>
          <target state="translated">클라이언트의 현재 장치 픽셀 비율 (DPR)을 나타내는 숫자로, 이는 장치 에서 레이아웃 뷰포트 ( &lt;a href=&quot;https://httpwg.org/http-extensions/client-hints.html#CSS2&quot;&gt;&lt;cite&gt;[CSS2]&lt;/cite&gt;&lt;/a&gt; 의 섹션 9.1.1)의 CSS 픽셀 ( &lt;a href=&quot;https://httpwg.org/http-extensions/client-hints.html#CSSVAL&quot;&gt;&lt;cite&gt;[CSSVAL]&lt;/cite&gt;&lt;/a&gt; 의 섹션 5.2 )에 대한 물리적 픽셀의 비율입니다 .&lt;cite&gt;&lt;/cite&gt;</target>
        </trans-unit>
        <trans-unit id="c02c1193cef8895bfcfd76fab36022e947d7a1b5" translate="yes" xml:space="preserve">
          <source>A number that indicates the layout viewport width in CSS pixels. The provided pixel value is a number rounded to the smallest following integer (i.e. ceiling value).</source>
          <target state="translated">레이아웃 뷰포트 너비를 CSS 픽셀로 나타내는 숫자입니다. 제공된 픽셀 값은 가장 작은 다음 정수 (즉, 상한 값)로 반올림 된 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="2b684cac1ea80ff01d85f8cdf2dbba122eead923" translate="yes" xml:space="preserve">
          <source>A number that indicates the ratio between physical pixels over CSS pixels of the selected image response.</source>
          <target state="translated">선택한 이미지 응답의 CSS 픽셀에 대한 물리적 픽셀 간의 비율을 나타내는 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="d140d340f4e2b728e728d3e54954e96ec6667988" translate="yes" xml:space="preserve">
          <source>A numerical value indicating whether the client wants to opt in to reduced data usage mode. &lt;code&gt;on&lt;/code&gt; indicates yes, while &lt;code&gt;off&lt;/code&gt; (the default) indicates no.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f80a5754b00a7b58692d532b283436fe5b8ce5" translate="yes" xml:space="preserve">
          <source>A path that must exist in the requested URL, or the browser won't send the &lt;code&gt;Cookie&lt;/code&gt; header.</source>
          <target state="translated">요청 된 URL에 있어야하는 경로입니다. 그렇지 않으면 브라우저가 &lt;code&gt;Cookie&lt;/code&gt; 헤더를 보내지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="650f390919a1e248d300f040459a60f3f5810f31" translate="yes" xml:space="preserve">
          <source>A peer can limit the number of concurrently active streams using the
   SETTINGS_MAX_CONCURRENT_STREAMS parameter (see &lt;a href=&quot;#section-6.5.2&quot;&gt;Section 6.5.2&lt;/a&gt;) within
   a SETTINGS frame.  The maximum concurrent streams setting is specific
   to each endpoint and applies only to the peer that receives the
   setting.  That is, clients specify the maximum number of concurrent
   streams the server can initiate, and servers specify the maximum
   number of concurrent streams the client can initiate.

   Streams that are in the &quot;open&quot; state or in either of the &quot;half-
   closed&quot; states count toward the maximum number of streams that an
   endpoint is permitted to open.  Streams in any of these three states
   count toward the limit advertised in the
   SETTINGS_MAX_CONCURRENT_STREAMS setting.  Streams in either of the
   &quot;reserved&quot; states do not count toward the stream limit.

   Endpoints MUST NOT exceed the limit set by their peer.  An endpoint
   that receives a HEADERS frame that causes its advertised concurrent
   stream limit to be exceeded MUST treat this as a stream error
   (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) of type PROTOCOL_ERROR or REFUSED_STREAM.  The choice
   of error code determines whether the endpoint wishes to enable
   automatic retry (see &lt;a href=&quot;#section-8.1.4&quot;&gt;Section 8.1.4&lt;/a&gt;) for details).

   An endpoint that wishes to reduce the value of
   SETTINGS_MAX_CONCURRENT_STREAMS to a value that is below the current
   number of open streams can either close streams that exceed the new
   value or allow streams to complete.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be4c8ac9e916c2f51a9f789cc3213dedde33771f" translate="yes" xml:space="preserve">
          <source>A persistent connection is one which remains open for a period of time, and can be reused for several requests, saving the need for a new TCP handshake, and utilizing TCP's performance enhancing capabilities. This connection will not stay open forever: idle connections are closed after some time (a server may use the &lt;a href=&quot;headers/keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt; header to specify a minimum time the connection should be kept open).</source>
          <target state="translated">지속적인 연결은 일정 기간 동안 열려 있고 여러 요청에 재사용 할 수있어 새로운 TCP 핸드 셰이크의 필요성을 줄이고 TCP의 성능 향상 기능을 활용합니다. 이 연결은 영구적으로 열려 있지 않습니다. 일정 시간이 지나면 유휴 연결이 닫힙니다 (서버는 연결 유지를위한 최소 시간을 지정 하기 위해 &lt;a href=&quot;headers/keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt; 헤더를 사용할 수 있습니다 ).</target>
        </trans-unit>
        <trans-unit id="7f5964b3fdbddffba630fc173f336fc4d53d9c2d" translate="yes" xml:space="preserve">
          <source>A policy is described using a series of policy directives, each of which describes the policy for a certain resource type or policy area. Your policy should include a &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; policy directive, which is a fallback for other resource types when they don't have policies of their own (for a complete list, see the description of the &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive). A policy needs to include a &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/content-security-policy/script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; directive to prevent inline scripts from running, as well as blocking the use of &lt;code&gt;eval()&lt;/code&gt;. A policy needs to include a &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/content-security-policy/style-src&quot;&gt;&lt;code&gt;style-src&lt;/code&gt;&lt;/a&gt; directive to restrict inline styles from being applied from a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; element or a &lt;code&gt;style&lt;/code&gt; attribute.</source>
          <target state="translated">정책은 일련의 정책 지시문을 사용하여 설명되며 각각은 특정 자원 유형 또는 정책 영역에 대한 정책을 설명합니다. 정책에는 &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; 정책 지시문 이 포함되어야합니다.이 정책 지시문은 다른 자원 유형에 고유 한 정책이없는 경우 다른 자원 유형에 대한 폴백입니다 (전체 목록은 &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; 지시문 설명 참조 ). &lt;code&gt;eval()&lt;/code&gt; 사용을 차단할뿐만 아니라 인라인 스크립트가 실행되지 않도록 정책에 &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;headers/content-security-policy/script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt; 지시문 을 포함해야합니다 . 인라인 스타일이 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에서 적용되지 않도록 제한 하려면 정책에 &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;headers/content-security-policy/style-src&quot;&gt; &lt;code&gt;style-src&lt;/code&gt; &lt;/a&gt; 지시문이 포함되어야 합니다. &lt;code&gt;style&lt;/code&gt; 속성.</target>
        </trans-unit>
        <trans-unit id="49ce15f1c7d8b0b9060e29949f31f97e8c869e2f" translate="yes" xml:space="preserve">
          <source>A policy is described using a series of policy directives, each of which describes the policy for a certain resource type or policy area. Your policy should include a &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; policy directive, which is a fallback for other resource types when they don't have policies of their own (for a complete list, see the description of the &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive). A policy needs to include a &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/content-security-policy/script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; directive to prevent inline scripts from running, as well as blocking the use of &lt;code&gt;eval()&lt;/code&gt;. A policy needs to include a &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/content-security-policy/style-src&quot;&gt;&lt;code&gt;style-src&lt;/code&gt;&lt;/a&gt; directive to restrict inline styles from being applied from a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; element or a &lt;code&gt;style&lt;/code&gt; attribute. There are specific directives for a wide variety of types of items, so that each type can have its own policy, including fonts, frames, images, audio and video media, scripts, and workers.</source>
          <target state="translated">정책은 일련의 정책 지시문을 사용하여 설명되며, 각 지시문은 특정 리소스 유형 또는 정책 영역에 대한 정책을 설명합니다. 정책에는 &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; 정책 지시문 이 포함되어야 합니다. 이는 자체 정책이없는 경우 다른 리소스 유형에 대한 대체입니다 (전체 목록은 &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; 지시문에 대한 설명 참조 ). 정책은 인라인 스크립트가 실행되는 것을 방지하고 &lt;code&gt;eval()&lt;/code&gt; 사용을 차단하기 위해 &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;headers/content-security-policy/script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt; 지시문 을 포함해야합니다 . 정책은 인라인 스타일이 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에서 적용되는 것을 제한하기 위해 &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;headers/content-security-policy/style-src&quot;&gt; &lt;code&gt;style-src&lt;/code&gt; &lt;/a&gt; 지시문 을 포함해야합니다 . &lt;code&gt;style&lt;/code&gt; 속성. 다양한 유형의 항목에 대한 특정 지시문이 있으므로 각 유형은 글꼴, 프레임, 이미지, 오디오 및 비디오 미디어, 스크립트 및 작업자를 포함한 자체 정책을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf3f38c5e6f98017e27ccd823e11fb4f53638759" translate="yes" xml:space="preserve">
          <source>A policy is described using a set of individual policy directives. A policy directive is a combination of a defined feature name, and an allowlist of origins that can use the feature.</source>
          <target state="translated">정책은 일련의 개별 정책 지시문을 사용하여 설명됩니다. 정책 지시문은 정의 된 기능 이름과이 기능을 사용할 수있는 원본의 허용 목록을 조합 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="96c2d8ce988407a2f35daa2b84e52da67848d1ab" translate="yes" xml:space="preserve">
          <source>A policy is described using a set of individual policy directives. A policy directive is a combination of a defined feature name, and an allowlist of origins that can use the feature. Features within a policy are separated by semicolons.</source>
          <target state="translated">정책은 개별 정책 지시문 세트를 사용하여 설명됩니다. 정책 지시문은 정의 된 기능 이름과 기능을 사용할 수있는 원본 허용 목록의 조합입니다. 정책 내의 기능은 세미콜론으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="d9f98b79f6a6f4ba906bbb9100d3b420de5ceeef" translate="yes" xml:space="preserve">
          <source>A potential security hole recently been fixed by browsers is authentication of cross-site images. From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/59&quot;&gt;Firefox 59&lt;/a&gt; onwards, image resources loaded from different origins to the current document are no longer able to trigger HTTP authentication dialogs (&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1423146&quot;&gt;bug 1423146&lt;/a&gt;), preventing user credentials being stolen if attackers were able to embed an arbitrary image into a third-party page.</source>
          <target state="translated">최근 브라우저에 의해 수정 된 잠재적 보안 허점은 교차 사이트 이미지의 인증입니다. 에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/59&quot;&gt;파이어 폭스 59&lt;/a&gt; 년 이후, 현재 문서에 서로 다른 기원에서로드 이미지 리소스는 더 이상 (HTTP 인증 대화 상자를 트리거 할 수없는 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1423146&quot;&gt;버그 1423146&lt;/a&gt; 공격자가 타사 페이지에 삽입 임의의 이미지 수 있다면 사용자 자격 증명 도난 방지)를.</target>
        </trans-unit>
        <trans-unit id="dc1e2a64ac8cc70397584ab85d7a956880edca58" translate="yes" xml:space="preserve">
          <source>A potential security hole that has recently been fixed by browsers is authentication of cross-site images. From &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/59&quot;&gt;Firefox 59&lt;/a&gt; onwards, image resources loaded from different origins to the current document are no longer able to trigger HTTP authentication dialogs (&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1423146&quot;&gt;bug 1423146&lt;/a&gt;), preventing user credentials being stolen if attackers were able to embed an arbitrary image into a third-party page.</source>
          <target state="translated">브라우저가 최근에 수정 한 잠재적 인 보안 허점은 사이트 간 이미지 인증입니다. 에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Releases/59&quot;&gt;파이어 폭스 59&lt;/a&gt; 년 이후, 현재 문서에 서로 다른 기원에서로드 이미지 리소스는 더 이상 (HTTP 인증 대화 상자를 트리거 할 수없는 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1423146&quot;&gt;버그 1423146&lt;/a&gt; 공격자가 타사 페이지에 삽입 임의의 이미지 수 있다면 사용자 자격 증명 도난 방지)를.</target>
        </trans-unit>
        <trans-unit id="6365c5dff77a5f8170fa70a3b4adb72b11fd2b61" translate="yes" xml:space="preserve">
          <source>A primary goal of CSP is to mitigate and report XSS attacks. XSS attacks exploit the browser's trust of the content received from the server. Malicious scripts are executed by the victim's browser because the browser trusts the source of the content, even when it's not coming from where it seems to be coming from.</source>
          <target state="translated">CSP의 주요 목표는 XSS 공격을 완화하고보고하는 것입니다. XSS 공격은 서버에서받은 컨텐트에 대한 브라우저의 신뢰를 악용합니다. 브라우저가 콘텐츠의 출처를 신뢰하지 않기 때문에 피해자의 브라우저가 악성 스크립트를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="439d68646c04f15f6a1847145b2f1608413870b0" translate="yes" xml:space="preserve">
          <source>A private cache is dedicated to a single user. You might have seen &quot;caching&quot; in your browser's settings already. A browser cache holds all documents downloaded via &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; by the user. This cache is used to make visited documents available for back/forward navigation, saving, viewing-as-source, etc. without requiring an additional trip to the server. It likewise improves offline browsing of cached content.</source>
          <target state="translated">개인 캐시는 단일 사용자 전용입니다. 브라우저 설정에서 &quot;캐싱&quot;을 보셨을 것입니다. 브라우저 캐시는 사용자가 &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; 를 통해 다운로드 한 모든 문서를 보유합니다 . 이 캐시는 서버를 추가로 방문하지 않고도 방문한 문서를 뒤로 / 앞으로 탐색, 저장, 소스로보기 등에 사용할 수 있도록하는 데 사용됩니다. 마찬가지로 캐시 된 컨텐츠의 오프라인 브라우징이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="f82d2b7fb1e238df861eebe638d87bc4cf317285" translate="yes" xml:space="preserve">
          <source>A process for decoding the chunked transfer coding can be represented
   in pseudo-code as:

     length := 0
     read chunk-size, chunk-ext (if any), and CRLF
     while (chunk-size &amp;gt; 0) {
        read chunk-data and CRLF
        append chunk-data to decoded-body
        length := length + chunk-size
        read chunk-size, chunk-ext (if any), and CRLF
     }
     read trailer field
     while (trailer field is not empty) {
        if (trailer field is allowed to be sent in a trailer) {
            append trailer field to existing header fields
        }
        read trailer-field
     }
     Content-Length := length
     Remove &quot;chunked&quot; from Transfer-Encoding
     Remove Trailer from existing header fields</source>
          <target state="translated">청크 된 전송 코딩을 디코딩하는 프로세스는 다음과 같이 의사 코드로 표현 될 수있다 : length : = 0 청크 크기 판독, 청크 확장 (있는 경우), 및 CRLF 동안 (청크 크기&amp;gt; 0) {청크 데이터 판독 및 CRLF 청크 데이터를 디코딩 된 본문 길이에 추가 : = 길이 + 청크 크기 읽기 청크 크기, 청크 확장 (있는 경우) 및 CRLF} 트레일러 필드 읽기 (트레일러 필드가 비어 있지 않음) {if (trailer field is 예고편으로 전송 가능) {기존 헤더 필드에 예고편 필드 추가} 예고편 필드 읽기} Content-Length : = length 전송 인코딩에서 &quot;청크&quot;제거 기존 헤더 필드에서 예고편 제거</target>
        </trans-unit>
        <trans-unit id="3433ae2d101b2c7bcd4c2dc4e1a13455c8f60c5d" translate="yes" xml:space="preserve">
          <source>A product identifier</source>
          <target state="translated">제품 식별자</target>
        </trans-unit>
        <trans-unit id="9958c4830d3fc544adf2dd5f899a801d1f14198e" translate="yes" xml:space="preserve">
          <source>A product identifier &amp;mdash; its name or development codename.</source>
          <target state="translated">제품 식별자-이름 또는 개발 코드 명.</target>
        </trans-unit>
        <trans-unit id="0885b17418737dcc207d3d7f9c2773976ecc3fe7" translate="yes" xml:space="preserve">
          <source>A project designed to help developers, system administrators, and security professionals configure their sites safely and securely.</source>
          <target state="translated">개발자, 시스템 관리자 및 보안 전문가가 사이트를 안전하고 안전하게 구성 할 수 있도록 설계된 프로젝트입니다.</target>
        </trans-unit>
        <trans-unit id="812c8d56ede89e043cd0d76837494a71cd36e6fd" translate="yes" xml:space="preserve">
          <source>A property name is a universally unique identifier that is associated
   with a schema that provides information about the syntax and
   semantics of the property.

   Because a property's name is universally unique, clients can depend
   upon consistent behavior for a particular property across multiple
   resources, on the same and across different servers, so long as that
   property is &quot;live&quot; on the resources in question, and the
   implementation of the live property is faithful to its definition.

   The XML namespace mechanism, which is based on URIs ([&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;]), is
   used to name properties because it prevents namespace collisions and
   provides for varying degrees of administrative control.

   The property namespace is flat; that is, no hierarchy of properties
   is explicitly recognized.  Thus, if a property A and a property A/B
   exist on a resource, there is no recognition of any relationship
   between the two properties.  It is expected that a separate
   specification will eventually be produced that will address issues
   relating to hierarchical properties.

   Finally, it is not possible to define the same property twice on a
   single resource, as this would cause a collision in the resource's
   property namespace.</source>
          <target state="translated">특성 이름은 특성의 구문 및 의미에 대한 정보를 제공하는 스키마와 연관된 범용 고유 식별자입니다. 속성 이름은 보편적으로 고유하기 때문에 클라이언트는 해당 속성이 문제의 리소스에 &quot;실제&quot;인 한 여러 리소스, 동일한 서버 및 다른 서버에서 특정 속성에 대한 일관된 동작에 의존 할 수 있습니다. 살아있는 재산은 그 정의에 충실합니다. URI를 기반으로하는 XML 네임 스페이스 메커니즘 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;])는 네임 스페이스 충돌을 방지하고 다양한 수준의 관리 제어를 제공하므로 속성 이름을 지정하는 데 사용됩니다. 속성 네임 스페이스는 평평합니다. 즉, 속성 계층이 명시 적으로 인식되지 않습니다. 따라서, 특성 A와 특성 A / B가 자원에 존재하는 경우, 두 특성 사이의 관계는 인식되지 않습니다. 계층 적 속성과 관련된 문제를 해결하는 별도의 사양이 결국 생성 될 것으로 예상됩니다. 마지막으로, 단일 자원에서 동일한 특성을 두 번 정의 할 수 없습니다. 자원의 특성 네임 스페이스에서 충돌이 발생하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6673520452754c10b992e04503b918fc10714c5c" translate="yes" xml:space="preserve">
          <source>A receiver that wishes to use a smaller flow-control window than the
   current size can send a new SETTINGS frame.  However, the receiver
   MUST be prepared to receive data that exceeds this window size, since
   the sender might send data that exceeds the lower limit prior to
   processing the SETTINGS frame.

   After sending a SETTINGS frame that reduces the initial flow-control
   window size, a receiver MAY continue to process streams that exceed
   flow-control limits.  Allowing streams to continue does not allow the
   receiver to immediately reduce the space it reserves for flow-control
   windows.  Progress on these streams can also stall, since
   WINDOW_UPDATE frames are needed to allow the sender to resume
   sending.  The receiver MAY instead send a RST_STREAM with an error
   code of FLOW_CONTROL_ERROR for the affected streams.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cacdba23a65a183495b790ee68fdf2145281249c" translate="yes" xml:space="preserve">
          <source>A recurring question among website owners is whether to choose non-www or www URLs. This page provides some advice on what's best.</source>
          <target state="translated">웹 사이트 소유자에게 반복되는 질문은 www가 아닌 ​​URL을 선택할지 아니면 www URL을 선택할지입니다. 이 페이지는 가장 좋은 것에 대한 조언을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7dfa1a7fc8e90c654961e3cd92ce898d60b0c079" translate="yes" xml:space="preserve">
          <source>A referrer will be sent for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-site origins&lt;/a&gt;, but cross-origin requests will contain no referrer information.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;동일 사이트 출처에&lt;/a&gt; 대해서는 리퍼러가 전송 되지만 출처 간 요청에는 리퍼러 정보가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b6c9e53e2af534c3dcf745698dae9e91a4a2d0a" translate="yes" xml:space="preserve">
          <source>A referrer will be sent for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-site origins&lt;/a&gt;, but cross-origin requests will send no referrer information.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;동일한 사이트 출처에&lt;/a&gt; 대한 리퍼러가 전송 되지만 출처 간 요청은 리퍼러 정보를 전송하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cae243fc787eed5f661f7ca1eba239db78ab53cd" translate="yes" xml:space="preserve">
          <source>A registration MUST include the following fields:

   o  Cache Directive Name 

   o  Pointer to specification text

   Values to be added to this namespace require IETF Review (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], Section&amp;nbsp;4.1&lt;/a&gt;).</source>
          <target state="translated">등록에는 다음 필드가 포함되어야합니다. o 캐시 지시문 이름 o 스펙 텍스트에 대한 &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;포인터이&lt;/a&gt; 네임 스페이스에 추가되는 값에는 IETF 검토가 필요합니다 ( [RFC5226], 섹션 4.1 참조 ).</target>
        </trans-unit>
        <trans-unit id="d53f7f5a3cccd3a8eb1b60f9e389fc08f9663236" translate="yes" xml:space="preserve">
          <source>A registration MUST include the following fields:

   o  Status Code (3 digits)

   o  Short Description

   o  Pointer to specification text

   Values to be added to the HTTP status code namespace require IETF
   Review (see &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], Section&amp;nbsp;4.1&lt;/a&gt;).</source>
          <target state="translated">등록에는 다음 필드가 포함되어야합니다. o 상태 코드 (3 자리) o 간단한 설명 o 사양 텍스트에 대한 포인터 HTTP 상태 코드 네임 스페이스에 추가되는 값에는 IETF 검토가 필요합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[4.1 절 RFC5226]&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="30a86ff2e17ce76a1f3b579485c7312a875e5283" translate="yes" xml:space="preserve">
          <source>A registration MUST include the following fields:

   o  Warn Code (3 digits)

   o  Short Description

   o  Pointer to specification text

   Values to be added to this namespace require IETF Review (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], Section&amp;nbsp;4.1&lt;/a&gt;).</source>
          <target state="translated">등록에는 다음 필드가 포함되어야합니다. o 경고 코드 (3 자리) o 간단한 설명 o 사양 텍스트에 대한 &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;포인터이&lt;/a&gt; 네임 스페이스에 추가되는 값에는 IETF 검토가 필요합니다 ( 4.1 절 [RFC5226] 참조 ).</target>
        </trans-unit>
        <trans-unit id="49d235161b5c7adbe95acaa5e39a723e244ff106" translate="yes" xml:space="preserve">
          <source>A related topic is the concept of HTTP connection upgrades, wherein an HTTP/1.1 connection is upgraded to a different protocol, such as TLS/1.0, WebSocket, or even HTTP/2 in cleartext. This &lt;a href=&quot;protocol_upgrade_mechanism&quot;&gt;protocol upgrade mechanism&lt;/a&gt; is documented in more detail elsewhere.</source>
          <target state="translated">관련 주제는 HTTP 연결 업그레이드의 개념으로, HTTP / 1.1 연결은 TLS / 1.0, WebSocket 또는 일반 텍스트의 HTTP / 2와 같은 다른 프로토콜로 업그레이드됩니다. 이 &lt;a href=&quot;protocol_upgrade_mechanism&quot;&gt;프로토콜 업그레이드 메커니즘&lt;/a&gt; 은 다른 곳에 더 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="07d792622b2930c487cb661d9dfa70764d9bdce6" translate="yes" xml:space="preserve">
          <source>A relative (to the request URL) or absolute URL pointing to a source map file.</source>
          <target state="translated">소스 맵 파일을 가리키는 상대 (요청 URL) 또는 절대 URL.</target>
        </trans-unit>
        <trans-unit id="04b17c6c33bdd43b6f562d0d41e6eb0e2aa2ab77" translate="yes" xml:space="preserve">
          <source>A relative (to the request URL) or absolute URL.</source>
          <target state="translated">상대 (요청 URL) 또는 절대 URL</target>
        </trans-unit>
        <trans-unit id="b2268a2e42421e9d441dc85b7260cf9456fb7200" translate="yes" xml:space="preserve">
          <source>A representation can be partitioned into subranges according to
   various structural units, depending on the structure inherent in the
   representation's media type.  This &quot;range unit&quot; is used in the
   Accept-Ranges (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;) response header field to advertise
   support for range requests, the Range (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;) request header
   field to delineate the parts of a representation that are requested,
   and the Content-Range (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;) payload header field to describe
   which part of a representation is being transferred.

     range-unit       = bytes-unit / other-range-unit</source>
          <target state="translated">표현은 미디어 유형에 내재 된 구조에 따라 다양한 구조 단위에 따라 하위 범위로 분할 될 수 있습니다. 이 &quot;범위 단위&quot;는 범위 요청에 대한 지원을 알리기 위해 수락 범위 ( &lt;a href=&quot;#section-2.3&quot;&gt;섹션 2.3&lt;/a&gt; ) 응답 헤더 필드, 요청 된 표현의 일부를 설명하는 범위 ( &lt;a href=&quot;#section-3.1&quot;&gt;섹션 3.1&lt;/a&gt; ) 요청 헤더 필드 및 Content- 전송중인 표현의 부분을 설명하는 범위 ( &lt;a href=&quot;#section-4.2&quot;&gt;섹션 4.2&lt;/a&gt; ) 페이로드 헤더 필드입니다. 범위 단위 = 바이트 단위 / 기타 범위 단위</target>
        </trans-unit>
        <trans-unit id="d71b4bd9a10e17cd95bbfd491a4aa1f6dbc4d2f2" translate="yes" xml:space="preserve">
          <source>A request message from a client to a server includes, within the
   first line of that message, the method to be applied to the resource,
   the identifier of the resource, and the protocol version in use.

        Request       = Request-Line              ; &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;
                        *(( general-header        ; &lt;a href=&quot;#section-4.5&quot;&gt;Section 4.5&lt;/a&gt;
                         | request-header         ; &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;
                         | entity-header ) CRLF)  ; &lt;a href=&quot;#section-7.1&quot;&gt;Section 7.1&lt;/a&gt;
                        CRLF
                        [ message-body ]          ; &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;</source>
          <target state="translated">클라이언트에서 서버로의 요청 메시지는 해당 메시지의 첫 번째 라인 내에 자원에 적용되는 방법, 자원의 식별자 및 사용중인 프로토콜 버전을 포함합니다. 요청 = 요청 라인; &lt;a href=&quot;#section-5.1&quot;&gt;섹션 5.1&lt;/a&gt; * ((일반 헤더; &lt;a href=&quot;#section-4.5&quot;&gt;섹션 4.5&lt;/a&gt; | 요청 헤더; &lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt; | 엔티티 헤더) CRLF); &lt;a href=&quot;#section-7.1&quot;&gt;7.1 절&lt;/a&gt; CRLF [message-body]; &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d9fa92bb2a5449449d61328cb82bf9e89b926d4" translate="yes" xml:space="preserve">
          <source>A request method is considered &quot;idempotent&quot; if the intended effect on
   the server of multiple identical requests with that method is the
   same as the effect for a single such request.  Of the request methods
   defined by this specification, PUT, DELETE, and safe request methods
   are idempotent. 

   Like the definition of safe, the idempotent property only applies to
   what has been requested by the user; a server is free to log each
   request separately, retain a revision control history, or implement
   other non-idempotent side effects for each idempotent request.

   Idempotent methods are distinguished because the request can be
   repeated automatically if a communication failure occurs before the
   client is able to read the server's response.  For example, if a
   client sends a PUT request and the underlying connection is closed
   before any response is received, then the client can establish a new
   connection and retry the idempotent request.  It knows that repeating
   the request will have the same intended effect, even if the original
   request succeeded, though the response might differ.</source>
          <target state="translated">요청 방법은 해당 방법으로 여러 동일한 요청이있는 서버에서 의도 한 효과가 단일 요청에 대한 효과와 동일하면 &quot;등전위&quot;로 간주됩니다. 이 사양에서 정의한 요청 방법 중에서 PUT, DELETE 및 안전한 요청 방법이 dem 등원입니다. 안전 정의와 마찬가지로 dem 등원 속성은 사용자가 요청한 내용에만 적용됩니다. 서버는 각 요청을 개별적으로 기록하거나, 개정 제어 히스토리를 유지하거나, 각 request 등원 요청에 대해 다른 비등 전성 부작용을 구현할 수 있습니다. 클라이언트가 서버의 응답을 읽기 전에 통신 실패가 발생하면 요청이 자동으로 반복 될 수 있으므로 dem 등원 한 방법이 구별됩니다. 예를 들어클라이언트가 PUT 요청을 보내고 응답이 수신되기 전에 기본 연결이 닫히면 클라이언트는 새 연결을 설정하고 dem 등원 요청을 다시 시도 할 수 있습니다. 응답이 다를 수 있지만 원래 요청이 성공하더라도 요청을 반복하면 의도 한 효과가 동일하다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="546384726031738c999ae47dc3029524e1da7c86" translate="yes" xml:space="preserve">
          <source>A request that needs to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; was attempted, but CORS is disabled in the user's browser. When this happens, the user needs to turn CORS back on in their browser.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt; 를 사용해야하는 요청 이 시도되었지만 사용자 브라우저에서 CORS가 사용되지 않습니다. 이 경우 사용자는 브라우저에서 CORS를 다시 켜야합니다.</target>
        </trans-unit>
        <trans-unit id="58731bd968021ea09d9af4e515aa9201da338c9d" translate="yes" xml:space="preserve">
          <source>A request that upgrades from HTTP/1.1 to HTTP/2 MUST include exactly
   one &quot;HTTP2-Settings&quot; header field.  The HTTP2-Settings header field
   is a connection-specific header field that includes parameters that
   govern the HTTP/2 connection, provided in anticipation of the server
   accepting the request to upgrade.

     HTTP2-Settings    = token68 

   A server MUST NOT upgrade the connection to HTTP/2 if this header
   field is not present or if more than one is present.  A server MUST
   NOT send this header field.

   The content of the HTTP2-Settings header field is the payload of a
   SETTINGS frame (&lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;), encoded as a base64url string (that is,
   the URL- and filename-safe Base64 encoding described in &lt;a href=&quot;https://tools.ietf.org/html/rfc4648#section-5&quot;&gt;Section&amp;nbsp;5 of
   [RFC4648]&lt;/a&gt;, with any trailing '=' characters omitted).  The ABNF
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] production for &quot;token68&quot; is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of
   [RFC7235]&lt;/a&gt;.

   Since the upgrade is only intended to apply to the immediate
   connection, a client sending the HTTP2-Settings header field MUST
   also send &quot;HTTP2-Settings&quot; as a connection option in the Connection
   header field to prevent it from being forwarded (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;Section&amp;nbsp;6.1 of
   [RFC7230]&lt;/a&gt;).

   A server decodes and interprets these values as it would any other
   SETTINGS frame.  Explicit acknowledgement of these settings
   (&lt;a href=&quot;#section-6.5.3&quot;&gt;Section 6.5.3&lt;/a&gt;) is not necessary, since a 101 response serves as
   implicit acknowledgement.  Providing these values in the upgrade
   request gives a client an opportunity to provide parameters prior to
   receiving any frames from the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c4fecdc1b419060578658673f7841f56391ef3c" translate="yes" xml:space="preserve">
          <source>A request-line begins with a method token, followed by a single space
   (SP), the request-target, another single space (SP), the protocol
   version, and ends with CRLF.

     request-line   = method SP request-target SP HTTP-version CRLF

   The method token indicates the request method to be performed on the
   target resource.  The request method is case-sensitive.

     method         = token

   The request methods defined by this specification can be found in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4&quot;&gt;Section&amp;nbsp;4 of [RFC7231]&lt;/a&gt;, along with information regarding the HTTP
   method registry and considerations for defining new methods.

   The request-target identifies the target resource upon which to apply
   the request, as defined in &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;.

   Recipients typically parse the request-line into its component parts
   by splitting on whitespace (see &lt;a href=&quot;#section-3.5&quot;&gt;Section 3.5&lt;/a&gt;), since no whitespace is
   allowed in the three components.  Unfortunately, some user agents
   fail to properly encode or exclude whitespace found in hypertext
   references, resulting in those disallowed characters being sent in a
   request-target.

   Recipients of an invalid request-line SHOULD respond with either a
   400 (Bad Request) error or a 301 (Moved Permanently) redirect with
   the request-target properly encoded.  A recipient SHOULD NOT attempt
   to autocorrect and then process the request without a redirect, since
   the invalid request-line might be deliberately crafted to bypass
   security filters along the request chain.

   HTTP does not place a predefined limit on the length of a
   request-line, as described in &lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;.  A server that receives a
   method longer than any that it implements SHOULD respond with a 501
   (Not Implemented) status code.  A server that receives a 

   request-target longer than any URI it wishes to parse MUST respond
   with a 414 (URI Too Long) status code (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.12&quot;&gt;Section&amp;nbsp;6.5.12 of
   [RFC7231]&lt;/a&gt;).

   Various ad hoc limitations on request-line length are found in
   practice.  It is RECOMMENDED that all HTTP senders and recipients
   support, at a minimum, request-line lengths of 8000 octets.</source>
          <target state="translated">요청 라인은 메소드 토큰으로 시작하고 단일 공간 (SP), 요청 대상, 다른 단일 공간 (SP), 프로토콜 버전이 뒤 따르며 CRLF로 끝납니다. request-line = 메소드 SP request-target SP HTTP 버전 CRLF 메소드 토큰은 대상 자원에서 수행 될 요청 메소드를 나타냅니다. 요청 방법은 대소 문자를 구분합니다. method = token이 스펙에 의해 정의 된 요청 메소드 는 HTTP 메소드 레지스트리에 관한 정보와 새로운 메소드를 정의하기위한 고려 사항과 함께 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4&quot;&gt;[RFC7231]의 섹션 4&lt;/a&gt; 에서 찾을 수 있습니다 . 요청 대상은 요청에 적용 할 대상 자원을 식별합니다 (&lt;a href=&quot;#section-5.3&quot;&gt; 섹션 5.3에&lt;/a&gt;. 수신자는 일반적으로 공백으로 분할하여 요청 라인을 구성 요소 부분으로 구문 분석합니다 ( &lt;a href=&quot;#section-3.5&quot;&gt;3.5 절&lt;/a&gt; 참조)), 세 구성 요소에는 공백이 허용되지 않기 때문입니다. 불행하게도 일부 사용자 에이전트는 하이퍼 텍스트 참조에서 찾은 공백을 올바르게 인코딩하거나 제외하지 못하므로 허용되지 않는 문자가 요청 대상으로 전송됩니다. 유효하지 않은 요청 라인의 수신자는 400 (잘못된 요청) 오류 또는 301 (영구적으로 이동) 리디렉션으로 요청 대상을 올바르게 인코딩해야합니다 (SHOULD). 잘못된 요청 라인은 요청 체인을 따라 보안 필터를 우회하도록 의도적으로 만들어 질 수 있으므로 수신자는 리디렉션없이 요청을 자동 수정 한 다음 처리하지 않아야합니다. &lt;a href=&quot;#section-2.5&quot;&gt;섹션 2.5에&lt;/a&gt; 설명 된 것처럼 HTTP는 요청 라인 길이에 미리 정의 된 제한을 두지 않습니다.. 구현 한 것보다 긴 메소드를 수신하는 서버는 501 (구현되지 않음) 상태 코드로 응답해야합니다. 구문 분석하려는 URI보다 긴 요청 대상을 수신하는 서버는 반드시 414 (URI Too Long) 상태 코드로 응답해야합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.12&quot;&gt;[RFC7231]의 6.5.12 절&lt;/a&gt; 참조 ). 요청 라인 길이에 대한 다양한 임시 제한 사항이 실제로 발견되었습니다. 모든 HTTP 발신자와 수신자는 최소 8000 옥텟의 요청 라인 길이를 지원하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7980e0e9f0bf2020cb5e958089632996a1336213" translate="yes" xml:space="preserve">
          <source>A resource can explicitly advertise its support for the revisions to
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] made in this document.  Class 1 MUST be supported as well.
   Class 2 MAY be supported.  Advertising class 3 support in addition to
   class 1 and 2 means that the server supports all the requirements in
   this specification.  Advertising class 3 and class 1 support, but not
   class 2, means that the server supports all the requirements in this
   specification except possibly those that involve locking support. 

   Example:

            DAV: 1, 3</source>
          <target state="translated">자원은 이 문서에서 작성된 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; ] 개정에 대한 지원을 명시 적으로 알릴 수 있습니다. 클래스 1도 반드시 지원되어야합니다. 클래스 2가 지원 될 수 있습니다. 클래스 1 및 2 외에 광고 클래스 3 지원은 서버가이 사양의 모든 요구 사항을 지원함을 의미합니다. 클래스 2가 아닌 클래스 3 및 클래스 1 지원을 광고한다는 것은 서버가 잠금 지원이 필요한 경우를 제외하고이 사양의 모든 요구 사항을 지원한다는 것을 의미합니다. 예 : DAV : 1, 3</target>
        </trans-unit>
        <trans-unit id="8f0b02bd6becb7e138339ca8cbce88e5c8dc9860" translate="yes" xml:space="preserve">
          <source>A response containing a &lt;code&gt;Keep-Alive&lt;/code&gt; header:</source>
          <target state="translated">&lt;code&gt;Keep-Alive&lt;/code&gt; 헤더를 포함하는 응답 :</target>
        </trans-unit>
        <trans-unit id="e3589c5d5733be22e8a4c793501192c7aeaaf910" translate="yes" xml:space="preserve">
          <source>A response containing one single range:</source>
          <target state="translated">하나의 단일 범위를 포함하는 응답 :</target>
        </trans-unit>
        <trans-unit id="d288a5da8b4ec025b38438ed09fb0060c6a676e8" translate="yes" xml:space="preserve">
          <source>A response containing several ranges:</source>
          <target state="translated">여러 범위를 포함하는 응답 :</target>
        </trans-unit>
        <trans-unit id="a0ee67e224ae11e90845c87f77f2fe7ec059fb94" translate="yes" xml:space="preserve">
          <source>A response message is considered complete when all of the octets
   indicated by the message framing ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;]) are received prior to
   the connection being closed.  If the request method is GET, the
   response status code is 200 (OK), and the entire response header
   section has been received, a cache MAY store an incomplete response
   message body if the cache entry is recorded as incomplete.  Likewise,
   a 206 (Partial Content) response MAY be stored as if it were an
   incomplete 200 (OK) cache entry.  However, a cache MUST NOT store
   incomplete or partial-content responses if it does not support the
   Range and Content-Range header fields or if it does not understand
   the range units used in those fields.

   A cache MAY complete a stored incomplete response by making a
   subsequent range request ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]) and combining the successful
   response with the stored entry, as defined in &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;.  A cache
   MUST NOT use an incomplete response to answer requests unless the
   response has been made complete or the request is partial and
   specifies a range that is wholly within the incomplete response.  A
   cache MUST NOT send a partial response to a client without explicitly
   marking it as such using the 206 (Partial Content) status code.</source>
          <target state="translated">메시지 프레임에 의해 표시된 모든 옥텟이 표시되면 응답 메시지가 완료된 것으로 간주됩니다 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;])는 연결이 종료되기 전에 수신됩니다. 요청 방법이 GET이고, 응답 상태 코드는 200 (OK)이고, 전체 응답 헤더 섹션이 수신 된 경우, 캐시 엔트리가 불완전한 것으로 기록되면 캐시는 불완전한 응답 메시지 본문을 저장할 수있다 (MAY). 마찬가지로, 206 (Partial Content) 응답은 불완전한 200 (OK) 캐시 항목 인 것처럼 저장 될 수 있습니다. 그러나 캐시가 범위 및 컨텐츠 범위 헤더 필드를 지원하지 않거나 해당 필드에 사용 된 범위 단위를 이해하지 못하는 경우 캐시는 불완전하거나 부분 컨텐츠 응답을 저장해서는 안됩니다. 캐시는 다음에 정의 된대로 후속 범위 요청 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ])을 만들고 성공적인 응답을 저장된 항목과 결합하여 저장된 불완전한 응답을 완료 할 수 있습니다 .&lt;a href=&quot;#section-3.3&quot;&gt;섹션 3.3&lt;/a&gt; . 응답이 완료되거나 요청이 부분적으로 이루어지지 않고 캐시가 불완전한 응답 내에있는 범위를 지정하지 않는 한 캐시는 불완전한 응답을 사용하여 요청에 응답해서는 안됩니다. 캐시는 206 (부분 컨텐츠) 상태 코드를 사용하여 명시 적으로 표시하지 않고 클라이언트에 부분 응답을 보내서는 안됩니다 (MUST NOT).</target>
        </trans-unit>
        <trans-unit id="999a0c8fd82d7b5d2242dddbeb3edd70fcd18975" translate="yes" xml:space="preserve">
          <source>A response might transfer only a partial representation if the
   connection closed prematurely or if the request used one or more
   Range specifiers ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]).  After several such transfers, a cache
   might have received several ranges of the same representation.  A
   cache MAY combine these ranges into a single stored response, and
   reuse that response to satisfy later requests, if they all share the
   same strong validator and the cache complies with the client
   requirements in &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.3&quot;&gt;Section&amp;nbsp;4.3 of [RFC7233]&lt;/a&gt;.

   When combining the new response with one or more stored responses, a
   cache MUST:

   o  delete any Warning header fields in the stored response with
      warn-code 1xx (see &lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;);

   o  retain any Warning header fields in the stored response with
      warn-code 2xx; and,

   o  use other header fields provided in the new response, aside from
      Content-Range, to replace all instances of the corresponding
      header fields in the stored response.</source>
          <target state="translated">연결이 조기에 종료되었거나 요청에 하나 이상의 범위 지정자 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ])가 사용 된 경우 응답은 부분 표현 만 전송할 수 있습니다 . 이러한 전송이 여러 번 수행 된 후 캐시는 동일한 범위의 여러 범위를 수신했을 수 있습니다. 캐시는 이러한 범위를 단일 저장된 응답으로 결합하고, 동일한 강력한 유효성 검증기를 공유하고 캐시 &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.3&quot;&gt;가 [RFC7233] 4.3 절의&lt;/a&gt; 클라이언트 요구 사항을 준수하는 경우 이후 요청을 만족시키기 위해 해당 응답을 재사용 할 수 있습니다. 하나 이상의 저장 응답, 캐시 MUST와 새로운 응답을 조합 할 때 : O는 경고 코드 1XX에 저장된 응답의 모든 경고 헤더 필드를 삭제합니다 ( &lt;a href=&quot;#section-5.5&quot;&gt;5.5 절&lt;/a&gt;); o warn-code 2xx를 사용하여 저장된 응답의 모든 경고 헤더 필드를 유지합니다. o 저장된 응답에서 해당 헤더 필드의 모든 인스턴스를 대체하기 위해 Content-Range를 제외하고 새 응답에 제공된 다른 헤더 필드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c70c6ad8d852190de6c159770119532624c086ed" translate="yes" xml:space="preserve">
          <source>A response might transfer only a subrange of a representation if the
   connection closed prematurely or if the request used one or more
   Range specifications.  After several such transfers, a client might
   have received several ranges of the same representation.  These
   ranges can only be safely combined if they all have in common the
   same strong validator (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of [RFC7232]&lt;/a&gt;).

   A client that has received multiple partial responses to GET requests
   on a target resource MAY combine those responses into a larger
   continuous range if they share the same strong validator.

   If the most recent response is an incomplete 200 (OK) response, then
   the header fields of that response are used for any combined response
   and replace those of the matching stored responses.

   If the most recent response is a 206 (Partial Content) response and
   at least one of the matching stored responses is a 200 (OK), then the
   combined response header fields consist of the most recent 200
   response's header fields.  If all of the matching stored responses
   are 206 responses, then the stored response with the most recent
   header fields is used as the source of header fields for the combined
   response, except that the client MUST use other header fields
   provided in the new response, aside from Content-Range, to replace
   all instances of the corresponding header fields in the stored
   response. 

   The combined response message body consists of the union of partial
   content ranges in the new response and each of the selected
   responses.  If the union consists of the entire range of the
   representation, then the client MUST process the combined response as
   if it were a complete 200 (OK) response, including a Content-Length
   header field that reflects the complete length.  Otherwise, the
   client MUST process the set of continuous ranges as one of the
   following: an incomplete 200 (OK) response if the combined response
   is a prefix of the representation, a single 206 (Partial Content)
   response containing a multipart/byteranges body, or multiple 206
   (Partial Content) responses, each with one continuous range that is
   indicated by a Content-Range header field.</source>
          <target state="translated">연결이 너무 일찍 닫히거나 요청이 하나 이상의 범위 사양을 사용한 경우 응답은 표현의 하위 범위 만 전송할 수 있습니다. 이러한 전송이 여러 번 수행 된 후 클라이언트는 동일한 범위의 여러 범위를 수신했을 수 있습니다. 이 범위는 모두 동일한 강력한 유효성 검사기를 가지고있는 경우에만 안전하게 결합 할 수 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.1&quot;&gt;[RFC7232]의 섹션 2.1&lt;/a&gt;). 대상 리소스에서 GET 요청에 대해 여러 부분 응답을받은 클라이언트는 동일한 강력한 유효성 검사기를 공유하는 경우 이러한 응답을 더 큰 연속 범위로 결합 할 수 있습니다. 가장 최근의 응답이 불완전한 200 (OK) 응답 인 경우 해당 응답의 헤더 필드는 결합 된 응답에 사용되며 일치하는 저장된 응답의 헤더 필드를 대체합니다. 가장 최근의 응답이 206 (부분 컨텐츠) 응답이고 일치하는 저장된 응답 중 하나 이상이 200 (확인) 인 경우 결합 된 응답 헤더 필드는 가장 최근의 200 응답 헤더 필드로 구성됩니다. 일치하는 저장된 응답이 모두 206 개의 응답 인 경우 가장 최근의 헤더 필드가있는 저장된 응답이 결합 된 응답의 헤더 필드 소스로 사용됩니다.단, 클라이언트는 Content-Range를 제외하고는 새로운 응답에 제공된 다른 헤더 필드를 사용하여 저장된 응답에서 해당 헤더 필드의 모든 인스턴스를 대체해야합니다. 결합 된 응답 메시지 본문은 새로운 응답 및 선택된 각각의 응답에서 부분 컨텐츠 범위의 합집합으로 구성됩니다. 공용체가 표현의 전체 범위로 구성된 경우, 클라이언트는 전체 길이를 반영하는 Content-Length 헤더 필드를 포함하여 완전한 200 (OK) 응답 인 것처럼 결합 된 응답을 처리해야합니다. 그렇지 않으면, 클라이언트는 연속 범위의 집합을 다음 중 하나로 처리해야한다 : 결합 된 응답이 표현의 접두사 인 경우 불완전한 200 (OK) 응답,멀티 파트 / 바이트 범위 본문을 포함하는 단일 206 (부분 컨텐츠) 응답 또는 각각 하나의 연속 범위가 있으며 컨텐츠 범위 헤더 필드로 표시되는 다중 206 (부분 컨텐츠) 응답.</target>
        </trans-unit>
        <trans-unit id="13df76672f8936d6bfa4c75fdd9352b5d89d02a9" translate="yes" xml:space="preserve">
          <source>A response might transfer only a subrange of the bytes of an entity-
   body, either because the request included one or more Range
   specifications, or because a connection was broken prematurely. After
   several such transfers, a cache might have received several ranges of
   the same entity-body.

   If a cache has a stored non-empty set of subranges for an entity, and
   an incoming response transfers another subrange, the cache MAY
   combine the new subrange with the existing set if both the following
   conditions are met:

      - Both the incoming response and the cache entry have a cache
        validator.

      - The two cache validators match using the strong comparison
        function (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;).

   If either requirement is not met, the cache MUST use only the most
   recent partial response (based on the Date values transmitted with
   every response, and using the incoming response if these values are
   equal or missing), and MUST discard the other partial information.</source>
          <target state="translated">요청에 하나 이상의 Range 사양이 포함되었거나 연결이 너무 일찍 끊어져서 응답이 엔터티 본문 바이트의 하위 범위 만 전송할 수 있습니다. 이러한 전송이 여러 번 수행되면 캐시에 동일한 범위의 동일한 엔터티 본문 범위가 수신되었을 수 있습니다. 캐시에 엔티티에 대해 비어 있지 않은 하위 범위 세트가 저장되어 있고 수신 응답이 다른 하위 범위를 전송하는 경우 다음 조건이 모두 충족되는 경우 캐시는 새 하위 범위를 기존 세트와 결합 할 수 있습니다. 캐시 항목에는 캐시 검사기가 있습니다. -두 개의 캐시 유효성 검사기는 강력한 비교 기능을 사용하여 일치합니다 ( &lt;a href=&quot;#section-13.3.3&quot;&gt;섹션 13.3.3&lt;/a&gt; 참조).). 요구 사항이 충족되지 않으면 캐시는 가장 최근의 부분 응답 만 사용해야하며 (모든 응답과 함께 전송 된 날짜 값을 기준으로하며 이러한 값이 같거나없는 경우 들어오는 응답을 사용해야 함) 다른 부분 정보를 폐기해야합니다.</target>
        </trans-unit>
        <trans-unit id="fd3c0d3780d4efb8123ce73b8830668addce6c7f" translate="yes" xml:space="preserve">
          <source>A response provided by a cache is stale (the expiration time set for it has passed).</source>
          <target state="translated">캐시가 제공 한 응답이 오래되었습니다 (설정된 만료 시간이 지났습니다).</target>
        </trans-unit>
        <trans-unit id="ce0f87926e811ddf23f0d196ca75fb63d5c3ead6" translate="yes" xml:space="preserve">
          <source>A response that tells the browser to allow code from any origin to access a resource will include the following:</source>
          <target state="translated">브라우저에서 모든 출처의 코드가 리소스에 액세스하도록 허용하는 응답에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="16c3c1296edc54a60a8b59b30b92efe26a36cd5c" translate="yes" xml:space="preserve">
          <source>A response that tells the browser to allow requesting code from the origin &lt;code&gt;https://developer.mozilla.org&lt;/code&gt; to access a resource will include the following:</source>
          <target state="translated">&lt;code&gt;https://developer.mozilla.org&lt;/code&gt; 에서 코드를 요청 하여 리소스에 액세스 하도록 브라우저에 지시하는 응답 에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a2251e4ef7d0bf0a06db2d6ac25abf911ead38c0" translate="yes" xml:space="preserve">
          <source>A response to a &lt;code&gt;HEAD&lt;/code&gt; method &lt;em&gt;should not&lt;/em&gt; have a body. If it has one anyway, that body &lt;strong&gt;must be&lt;/strong&gt; ignored: any &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;entity headers&lt;/a&gt; that might describe the erroneous body are instead assumed to describe the response which a similar &lt;code&gt;GET&lt;/code&gt; request would have received.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 메서드에 대한 응답 에는 본문이 &lt;em&gt;없어야합니다&lt;/em&gt; . 어쨌든 하나가있는 경우 해당 본문 &lt;strong&gt;은&lt;/strong&gt; 무시 &lt;strong&gt;해야합니다&lt;/strong&gt; . 잘못된 본문을 설명 할 수 있는 모든 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;엔티티 헤더&lt;/a&gt; 는 대신 유사한 &lt;code&gt;GET&lt;/code&gt; 요청이 수신했을 응답을 설명하는 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="99a9acb9401a41dff46ebd4d7c24d2a3d9111ef3" translate="yes" xml:space="preserve">
          <source>A response to a &lt;code&gt;HEAD&lt;/code&gt; method should not have a body. If so, it must be ignored. Even so, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;entity headers&lt;/a&gt; describing the content of the body, like &lt;a href=&quot;../headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; may be included in the response. They don't relate to the body of the &lt;code&gt;HEAD&lt;/code&gt; response, which should be empty, but to the body of similar request using the &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method would have returned as a response.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 메소드에 대한 응답 에는 본문이 없어야합니다. 그렇다면 무시해야합니다. 그럼에도 불구하고 &lt;a href=&quot;../headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt; 와 같이 본문의 내용을 설명하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Entity_header&quot;&gt;엔터티 헤더&lt;/a&gt; 가 응답에 포함될 수 있습니다. &lt;code&gt;HEAD&lt;/code&gt; 응답 의 본문과 관련 이 없으며 비어 있어야합니다. 그러나 &lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 메소드를 사용하는 유사한 요청의 본문은 응답으로 반환되었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e2a4eab8fbc63e64d63cfaa4c539160dcfdafd03" translate="yes" xml:space="preserve">
          <source>A response to the HEAD method is identical to what an equivalent
   request made with a GET would have been, except it lacks a body.
   This property of HEAD responses can be used to invalidate or update a
   cached GET response if the more efficient conditional GET request
   mechanism is not available (due to no validators being present in the
   stored response) or if transmission of the representation body is not
   desired even if it has changed.

   When a cache makes an inbound HEAD request for a given request target
   and receives a 200 (OK) response, the cache SHOULD update or
   invalidate each of its stored GET responses that could have been
   selected for that request (see &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;).

   For each of the stored responses that could have been selected, if
   the stored response and HEAD response have matching values for any
   received validator fields (ETag and Last-Modified) and, if the HEAD
   response has a Content-Length header field, the value of
   Content-Length matches that of the stored response, the cache SHOULD
   update the stored response as described below; otherwise, the cache
   SHOULD consider the stored response to be stale. 

   If a cache updates a stored response with the metadata provided in a
   HEAD response, the cache MUST:

   o  delete any Warning header fields in the stored response with
      warn-code 1xx (see &lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;);

   o  retain any Warning header fields in the stored response with
      warn-code 2xx; and,

   o  use other header fields provided in the HEAD response to replace
      all instances of the corresponding header fields in the stored
      response and append new header fields to the stored response's
      header section unless otherwise restricted by the Cache-Control
      header field.</source>
          <target state="translated">HEAD 메소드에 대한 응답은 본문이 없다는 점을 제외하고 GET으로 작성된 동등한 요청과 동일합니다. 보다 효율적인 조건부 GET 요청 메커니즘을 사용할 수 없거나 (저장된 응답에 유효성 검사기가 존재하지 않기 때문에) 표현 본문의 전송이 바람직하지 않은 경우 HEAD 응답의이 속성을 사용하여 캐시 된 GET 응답을 무효화하거나 업데이트 할 수 있습니다. 변경된 경우. 캐시가 주어진 요청 대상에 대해 인바운드 HEAD 요청을하고 200 (OK) 응답을 수신하면 캐시는 해당 요청에 대해 선택 될 수있는 저장된 각 GET 응답을 업데이트하거나 무효화해야합니다 ( &lt;a href=&quot;#section-4.1&quot;&gt;4.1 절&lt;/a&gt; 참조)). 저장된 응답 및 HEAD 응답에 수신 된 유효성 검증기 필드 (ETag 및 Last-Modified)에 대해 일치하는 값이 있고 HEAD 응답에 Content-Length 헤더 필드가있는 경우 선택할 수있는 각 저장된 응답에 대해 값 Content-Length는 저장된 응답의 것과 일치하며, 캐시는 아래에 설명 된 바와 같이 저장된 응답을 업데이트해야한다. 그렇지 않으면 캐시는 저장된 응답을 무효로 간주해야합니다. 캐시가 HEAD 응답에 제공된 메타 데이터로 저장된 응답을 업데이트하는 경우 캐시는 반드시 다음을 수행해야합니다. o warn-code 1xx를 사용하여 저장된 응답에서 경고 헤더 필드를 삭제하십시오 ( &lt;a href=&quot;#section-5.5&quot;&gt;5.5 절&lt;/a&gt; 참조).); o warn-code 2xx를 사용하여 저장된 응답의 모든 경고 헤더 필드를 유지합니다. o Cache-Control 헤더 필드에 의해 달리 제한되지 않는 한 HEAD 응답에 제공된 다른 헤더 필드를 사용하여 저장된 응답에서 해당 헤더 필드의 모든 인스턴스를 대체하고 저장된 헤더 헤더 섹션에 새 헤더 필드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="669f6d87675fe454e2d369ba30faa8e2cfffabb9" translate="yes" xml:space="preserve">
          <source>A response triggering the &quot;Save As&quot; dialog:</source>
          <target state="translated">&quot;다른 이름으로 저장&quot;대화 상자를 트리거하는 응답 :</target>
        </trans-unit>
        <trans-unit id="b9e19c47b651e8243cff78fe0138bde2241237d7" translate="yes" xml:space="preserve">
          <source>A returned resource may have one &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; header, with the following syntax:</source>
          <target state="translated">리턴 된 자원 에는 다음 구문과 함께 하나의 &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; 헤더 가있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95815d7a3c95d6951515bf50a9472dbd82e8e267" translate="yes" xml:space="preserve">
          <source>A schema such as 'http:' or 'https:'. &lt;strong&gt;The colon is required, single quotes shouldn't be used&lt;/strong&gt;. You can also specify data schemas (not recommended).</source>
          <target state="translated">'http :'또는 'https :'와 같은 스키마 &lt;strong&gt;콜론이 필요하며 작은 따옴표는 사용하지 않아야합니다&lt;/strong&gt; . 데이터 스키마를 지정할 수도 있습니다 (권장하지 않음).</target>
        </trans-unit>
        <trans-unit id="cbe7c636e6af2d87ce371a4de3a942151e1fda04" translate="yes" xml:space="preserve">
          <source>A schema such as 'http:' or 'https:'. The colon is required. You can also specify data schemas (not recommended).</source>
          <target state="translated">'http :'또는 'https :'와 같은 스키마 콜론이 필요합니다. 데이터 스키마를 지정할 수도 있습니다 (권장하지 않음).</target>
        </trans-unit>
        <trans-unit id="d95228bc872e424d1fe8017595ec38304956be44" translate="yes" xml:space="preserve">
          <source>A scheme such as &lt;code&gt;http:&lt;/code&gt; or &lt;code&gt;https:&lt;/code&gt;. The colon is required and scheme should not be quoted. You can also specify data schemes (not recommended).</source>
          <target state="translated">&lt;code&gt;http:&lt;/code&gt; 또는 &lt;code&gt;https:&lt;/code&gt; 와 같은 스키마 . 콜론은 필수이며 구성표는 인용 할 수 없습니다. 데이터 구성표를 지정할 수도 있습니다 (권장되지 않음).</target>
        </trans-unit>
        <trans-unit id="b3df65d87ed800b56d06e1302b4935c2d9d8a276" translate="yes" xml:space="preserve">
          <source>A scheme such as &lt;code&gt;http:&lt;/code&gt; or &lt;code&gt;https:&lt;/code&gt;. The colon is required. Unlike other values below, single quotes shouldn't be used. You can also specify data schemes (not recommended).</source>
          <target state="translated">&lt;code&gt;http:&lt;/code&gt; 또는 &lt;code&gt;https:&lt;/code&gt; 와 같은 스키마 . 콜론이 필요합니다. 아래의 다른 값과 달리 작은 따옴표를 사용하면 안됩니다. 데이터 구성표를 지정할 수도 있습니다 (권장되지 않음).</target>
        </trans-unit>
        <trans-unit id="40cd5842c9a4632e241e41e95dbacd3ae50ac805" translate="yes" xml:space="preserve">
          <source>A secure cookie is only sent to the server with an encrypted request over the HTTPS protocol. Even with &lt;code&gt;Secure&lt;/code&gt;, sensitive information should &lt;em&gt;never&lt;/em&gt; be stored in cookies, as they are inherently insecure and this flag can't offer real protection. Starting with Chrome 52 and Firefox 52, insecure sites (&lt;code&gt;http:&lt;/code&gt;) can't set cookies with the &lt;code&gt;Secure&lt;/code&gt; directive.</source>
          <target state="translated">보안 쿠키는 HTTPS 프로토콜을 통해 암호화 된 요청으로 서버로만 전송됩니다. &lt;code&gt;Secure&lt;/code&gt; 를 사용 하더라도 민감한 정보 는 본질적으로 안전하지 않으므로이 플래그는 실제 보호 기능을 제공 할 수 없으므로 쿠키에 저장 해서는 &lt;em&gt;안됩니다&lt;/em&gt; . Chrome 52 및 Firefox 52부터는 안전하지 않은 사이트 ( &lt;code&gt;http:&lt;/code&gt; :) 가 &lt;code&gt;Secure&lt;/code&gt; 지정 문으로 쿠키를 설정할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7af3cd8d402a8e9beb152653018d719dd4ad9d78" translate="yes" xml:space="preserve">
          <source>A secure cookie will only be sent to the server when a request is made using SSL and the HTTPS protocol. However, confidential or sensitive information should never be stored or transmitted in HTTP Cookies as the entire mechanism is inherently insecure and this doesn't mean that any information is encrypted, for example.</source>
          <target state="translated">SSL 및 HTTPS 프로토콜을 사용하여 요청한 경우에만 보안 쿠키가 서버로 전송됩니다. 그러나 전체 메커니즘이 본질적으로 안전하지 않기 때문에 기밀 정보 나 민감한 정보는 HTTP 쿠키에 저장하거나 전송해서는 안됩니다. 예를 들어 정보가 암호화 된 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1953290f4d197b8408a6748e64b125663c28443d" translate="yes" xml:space="preserve">
          <source>A server SHOULD return a response with this status code if a request
   included a Range request-header field (&lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt;), and none of
   the range-specifier values in this field overlap the current extent
   of the selected resource, and the request did not include an If-Range
   request-header field. (For byte-ranges, this means that the first-
   byte-pos of all of the byte-range-spec values were greater than the
   current length of the selected resource.)

   When this status code is returned for a byte-range request, the
   response SHOULD include a Content-Range entity-header field
   specifying the current length of the selected resource (see &lt;a href=&quot;#section-14.16&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt;). This response MUST NOT use the multipart/byteranges content-
   type.</source>
          <target state="translated">요청에 Range request-header 필드 ( &lt;a href=&quot;#section-14.35&quot;&gt;14.35 절&lt;/a&gt; )가 포함되어 있고이 필드 의 범위 지정자 값이 선택한 리소스의 현재 범위와 겹치지 않는 경우 서버는이 상태 코드로 응답을 반환해야합니다. If-Range 요청 헤더 필드를 포함하십시오. 바이트 범위의 경우 이는 모든 바이트 범위 스펙 값의 첫 번째 바이트 위치가 선택된 자원의 현재 길이보다 큼을 의미합니다.이 상태 코드가 바이트 범위 요청에 대해 리턴되면, 응답은 선택된 자원의 현재 길이를 지정하는 Content-Range entity-header 필드를 포함해야한다 ( &lt;a href=&quot;#section-14.16&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-14.16&quot;&gt;14.16&lt;/a&gt; 참조 ). 이 응답은 multipart / byteranges content-type을 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="e0f49674d51f115dc57ea58b6c6057d6e1f1f18a" translate="yes" xml:space="preserve">
          <source>A server is in the position to save personal data about a user's
   requests over time, which might identify their reading patterns or
   subjects of interest.  In particular, log information gathered at an
   intermediary often contains a history of user agent interaction,
   across a multitude of sites, that can be traced to individual users.

   HTTP log information is confidential in nature; its handling is often
   constrained by laws and regulations.  Log information needs to be
   securely stored and appropriate guidelines followed for its analysis.
   Anonymization of personal information within individual entries
   helps, but it is generally not sufficient to prevent real log traces
   from being re-identified based on correlation with other access
   characteristics.  As such, access traces that are keyed to a specific
   client are unsafe to publish even if the key is pseudonymous. 

   To minimize the risk of theft or accidental publication, log
   information ought to be purged of personally identifiable
   information, including user identifiers, IP addresses, and
   user-provided query parameters, as soon as that information is no
   longer necessary to support operational needs for security, auditing,
   or fraud control.</source>
          <target state="translated">서버는 시간이 지남에 따라 사용자의 요청에 대한 개인 데이터를 저장할 수있는 위치에 있으며, 이는 읽기 패턴 또는 관심있는 주제를 식별 할 수 있습니다. 특히, 중개자에서 수집 된 로그 정보에는 종종 여러 사이트에서 개별 사용자에게 추적 할 수있는 사용자 에이전트 상호 작용 기록이 포함됩니다. HTTP 로그 정보는 본질적으로 기밀입니다. 취급은 종종 법과 규정에 의해 제약을받습니다. 로그 정보를 안전하게 저장하고 분석을위한 적절한 지침을 따라야합니다. 개별 항목 내에서 개인 정보의 익명화는 도움이되지만 일반적으로 다른 액세스 특성과의 상관 관계에 따라 실제 로그 추적이 재 식별되는 것을 방지하기에는 충분하지 않습니다. 따라서특정 클라이언트에 키가 지정된 액세스 추적은 키가 유사하더라도 게시하기에 안전하지 않습니다. 도난 또는 우발적 인 게시 위험을 최소화하기 위해 보안에 대한 운영 요구를 지원하기 위해 정보가 더 이상 필요하지 않은 경우 사용자 식별 정보, IP 주소 및 사용자 제공 쿼리 매개 변수를 포함하여 개인 식별 정보로 로그 정보를 제거해야합니다. , 감사 또는 사기 통제.또는 사기 통제.또는 사기 통제.</target>
        </trans-unit>
        <trans-unit id="09bccdb2c6a511f29817abf1fc56652b7723e836" translate="yes" xml:space="preserve">
          <source>A server is in the position to save personal data about a user's
   requests which might identify their reading patterns or subjects of
   interest. This information is clearly confidential in nature and its
   handling can be constrained by law in certain countries. People using
   the HTTP protocol to provide data are responsible for ensuring that
   such material is not distributed without the permission of any
   individuals that are identifiable by the published results.</source>
          <target state="translated">서버는 사용자의 요청에 대한 개인 데이터를 저장하여 읽기 패턴 또는 관심있는 주제를 식별 할 수 있습니다. 이 정보는 본질적으로 기밀로 유지되며 특정 국가의 법률에 따라 취급이 제한 될 수 있습니다. 데이터를 제공하기 위해 HTTP 프로토콜을 사용하는 사람들은 공개 된 결과로 식별 할 수있는 개인의 허가없이 그러한 자료가 배포되지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec687f3c8448a18d04b2f853d94efde481053651" translate="yes" xml:space="preserve">
          <source>A server is not necessarily a single machine, but several server software instances can be hosted on the same machine. With HTTP/1.1 and the &lt;a href=&quot;headers/host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; header, they may even share the same IP address.</source>
          <target state="translated">서버가 반드시 단일 시스템 일 필요는 없지만 동일한 시스템에서 여러 서버 소프트웨어 인스턴스를 호스팅 할 수 있습니다. HTTP / 1.1 및 &lt;a href=&quot;headers/host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; 헤더를 사용하면 동일한 IP 주소를 공유 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d019112f6091b0eed2debdbb713a8f052cf5222e" translate="yes" xml:space="preserve">
          <source>A server is not necessarily a single machine, but several servers can be hosted on the same machine. With HTTP/1.1 and the &lt;a href=&quot;headers/host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt; header, they may even share the same IP address.</source>
          <target state="translated">서버는 반드시 단일 시스템 일 필요는 없지만 동일한 서버에서 여러 서버를 호스팅 할 수 있습니다. HTTP / 1.1 및 &lt;a href=&quot;headers/host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; 헤더를 사용하면 동일한 IP 주소를 공유 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b79873bcb71a9cedddcc30f39182301545811028" translate="yes" xml:space="preserve">
          <source>A server isn't necessarily a physical machine: several servers can reside on the same physical machine. Or, one server can be handled by several machines, cooperating to produce the answer or balancing the load of the requests between them. The key point is that semantically &lt;em&gt;one domain name represents one single server&lt;/em&gt;.</source>
          <target state="translated">서버는 반드시 물리적 시스템 일 필요는 없습니다. 여러 서버가 동일한 물리적 시스템에 상주 할 수 있습니다. 또는 한 대의 서버가 여러 대의 컴퓨터에서 처리하여 응답을 생성하도록 협력하거나 서버간에 요청의 부하를 분산시킬 수 있습니다. 요점은 의미 적으로 &lt;em&gt;하나의 도메인 이름이 하나의 단일 서버를 나타냅니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f0b526e8ef3de96dc3fb291521c6f4a105213fa5" translate="yes" xml:space="preserve">
          <source>A server may also send the header as part of a &lt;a href=&quot;../status/426&quot;&gt;&lt;code&gt;426&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Upgrade Required&lt;/code&gt; response, to indicate that the server won't perform the request using the current protocol, but might do so if the protocol is changed. The client can then request a protocol change using the process above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfac30184b9556e9ef555e2af061b31b9e243352" translate="yes" xml:space="preserve">
          <source>A server receives a request for &lt;code&gt;http://www.example.org/whaddup&lt;/code&gt; (when the canonical domain is example.org)</source>
          <target state="translated">서버는 &lt;code&gt;http://www.example.org/whaddup&lt;/code&gt; 에 대한 요청을받습니다 (표준 도메인이 example.org 인 경우)</target>
        </trans-unit>
        <trans-unit id="6385a8f83518f5bb31e0c309e5837964daeac0d1" translate="yes" xml:space="preserve">
          <source>A server receiving a PATCH request with an unsupported media type could reply with &lt;a href=&quot;../status/415&quot;&gt;&lt;code&gt;415&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unsupported Media Type&lt;/code&gt; and an Accept-Patch header referencing one or more supported media types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ffc5be989c3040f832f85d28f183c24d1ebfbb" translate="yes" xml:space="preserve">
          <source>A server should send the &quot;close&quot; &lt;a href=&quot;../headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header field in the response, since &lt;code&gt;408&lt;/code&gt; implies that the server has decided to close the connection rather than continue waiting.</source>
          <target state="translated">&lt;code&gt;408&lt;/code&gt; 은 서버가 계속 대기하지 않고 연결을 종료하기로 결정 했으므로 응답에 &quot;close&quot; &lt;a href=&quot;../headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 헤더 필드를 보내야합니다 .</target>
        </trans-unit>
        <trans-unit id="23fcc0e82756bfddc3111906b38afc8f67f763c0" translate="yes" xml:space="preserve">
          <source>A server supporting partial downloads broadcasts this by sending the &lt;a href=&quot;headers/accept-ranges&quot;&gt;&lt;code&gt;Accept-Ranges&lt;/code&gt;&lt;/a&gt; header. Once this happens, the client can resume a download by sending a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Ranges&quot;&gt;&lt;code&gt;Ranges&lt;/code&gt;&lt;/a&gt; header with the missing ranges:</source>
          <target state="translated">부분 다운로드를 지원하는 서버는 &lt;a href=&quot;headers/accept-ranges&quot;&gt; &lt;code&gt;Accept-Ranges&lt;/code&gt; &lt;/a&gt; 헤더를 전송하여이를 브로드 캐스트합니다 . 이러한 상황이 발생하면, 클라이언트는 전송하여 다운로드를 재개 할 수있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Ranges&quot;&gt; &lt;code&gt;Ranges&lt;/code&gt; &lt;/a&gt; 누락 된 범위와 헤더를 :</target>
        </trans-unit>
        <trans-unit id="6f9b03e6063cc4b5ce8870c57b5b3f1fefcf329b" translate="yes" xml:space="preserve">
          <source>A server that receives an incomplete request message, usually due to
   a canceled request or a triggered timeout exception, MAY send an
   error response prior to closing the connection.

   A client that receives an incomplete response message, which can
   occur when a connection is closed prematurely or when decoding a
   supposedly chunked transfer coding fails, MUST record the message as
   incomplete.  Cache requirements for incomplete responses are defined
   in &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC7234]&lt;/a&gt;.

   If a response terminates in the middle of the header section (before
   the empty line is received) and the status code might rely on header
   fields to convey the full meaning of the response, then the client
   cannot assume that meaning has been conveyed; the client might need
   to repeat the request in order to determine what action to take next.

   A message body that uses the chunked transfer coding is incomplete if
   the zero-sized chunk that terminates the encoding has not been
   received.  A message that uses a valid Content-Length is incomplete
   if the size of the message body received (in octets) is less than the
   value given by Content-Length.  A response that has neither chunked
   transfer coding nor Content-Length is terminated by closure of the
   connection and, thus, is considered complete regardless of the number
   of message body octets received, provided that the header section was
   received intact.</source>
          <target state="translated">불완전한 요청 메시지를 수신하는 서버는 대개 취소 된 요청 또는 트리거 된 시간 초과 예외로 인해 연결을 닫기 전에 오류 응답을 보낼 수 있습니다. 연결이 조기에 닫히거나 추정 된 청크 전송 코딩 디코딩이 실패 할 때 발생할 수있는 불완전한 응답 메시지를 수신하는 클라이언트는 반드시 메시지를 불완전한 것으로 기록해야합니다. 불완전한 응답에 대한 캐시 요구 사항 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-3&quot;&gt;은 [RFC7234]의 섹션 3에&lt;/a&gt; 정의되어 있습니다 .. 헤더 행 중간에서 응답이 종료되고 (빈 행이 수신되기 전에) 상태 코드가 헤더 필드를 사용하여 응답의 전체 의미를 전달할 수 있으면 클라이언트는 의미가 전달되었다고 가정 할 수 없습니다. 클라이언트는 다음에 수행 할 조치를 결정하기 위해 요청을 반복해야 할 수도 있습니다. 인코딩을 종료하는 크기가 0 인 청크가 수신되지 않으면 청크 된 전송 코딩을 사용하는 메시지 본문이 불완전합니다. 수신 된 메시지 본문의 크기 (옥텟)가 Content-Length가 제공 한 값보다 작 으면 유효한 Content-Length를 사용하는 메시지가 불완전합니다. 청크 된 전송 코딩이나 Content-Length가없는 응답은 연결을 닫으면 종료되므로헤더 섹션이 그대로 수신 된 경우 수신 된 메시지 본문 옥텟 수에 관계없이 완전한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a058fcef10ecb10e40930fc393c822b8da706b5f" translate="yes" xml:space="preserve">
          <source>A server to give access to the document, an early version of &lt;em&gt;httpd&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;httpd&lt;/em&gt; 의 초기 버전 인 문서에 액세스 할 수있는 &lt;em&gt;서버&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5428d9f2d224f7b0136e57c085942bc52a277388" translate="yes" xml:space="preserve">
          <source>A sha256, sha384 or sha512 hash of scripts or styles. The use of this source consists of two portions separated by a dash: the encryption algorithm used to create the hash and the base64-encoded hash of the script or style. When generating the hash, don't include the &amp;lt;script&amp;gt; or &amp;lt;style&amp;gt; tags and note that capitalization and whitespace matter, including leading or trailing whitespace. See &lt;a href=&quot;script-src#Unsafe_inline_script&quot;&gt;unsafe inline script&lt;/a&gt; for an example. In CSP 2.0 this applied only to inline scripts. CSP 3.0 allows it in the case of &lt;code&gt;script-src&lt;/code&gt; for external scripts.</source>
          <target state="translated">스크립트 또는 스타일의 sha256, sha384 또는 sha512 해시 이 소스는 대시로 구분 된 두 부분으로 구성됩니다. 해시를 만드는 데 사용되는 암호화 알고리즘과 스크립트 또는 스타일의 base64 인코딩 해시입니다. 해시를 생성 할 때 &amp;lt;script&amp;gt; 또는 &amp;lt;style&amp;gt; 태그를 포함하지 말고 선행 또는 후행 공백을 포함하여 대문자 및 공백 문제를 참고하십시오. 예제는 &lt;a href=&quot;script-src#Unsafe_inline_script&quot;&gt;안전하지 않은 인라인 스크립트&lt;/a&gt; 를 참조하십시오 . CSP 2.0에서는 인라인 스크립트에만 적용되었습니다. CSP 3.0에서는 &lt;code&gt;script-src&lt;/code&gt; 의 경우 외부 스크립트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0be84bce742baeb2d49ccf396ba5e30b04dc8c9" translate="yes" xml:space="preserve">
          <source>A sha256, sha384 or sha512 hash of scripts or styles. The use of this source consists of two portions separated by a dash: the encryption algorithm used to create the hash and the base64-encoded hash of the script or style. When generating the hash, don't include the &amp;lt;script&amp;gt; or &amp;lt;style&amp;gt; tags and note that capitalization and whitespace matter, including leading or trailing whitespace. See &lt;a href=&quot;script-src#Unsafe_inline_script&quot;&gt;unsafe inline script&lt;/a&gt; for an example. In CSP 2.0, this applied only to inline scripts. CSP 3.0 allows it in the case of &lt;code&gt;script-src&lt;/code&gt; for external scripts.</source>
          <target state="translated">스크립트 또는 스타일의 sha256, sha384 또는 sha512 해시. 이 소스의 사용은 대시로 구분 된 두 부분으로 구성됩니다. 즉, 해시를 만드는 데 사용되는 암호화 알고리즘과 스크립트 또는 스타일의 base64로 인코딩 된 해시입니다. 해시를 생성 할 때 &amp;lt;script&amp;gt; 또는 &amp;lt;style&amp;gt; 태그를 포함하지 말고 선행 또는 후행 공백을 포함하여 대문자와 공백이 중요합니다. 예를 들어 &lt;a href=&quot;script-src#Unsafe_inline_script&quot;&gt;안전하지 않은 인라인 스크립트&lt;/a&gt; 를 참조하십시오 . CSP 2.0에서는 인라인 스크립트에만 적용되었습니다. CSP 3.0은 외부 스크립트에 대한 &lt;code&gt;script-src&lt;/code&gt; 의 경우이를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="effe3f436253f2fb4b93f88cfbc11ed917fb2ccb" translate="yes" xml:space="preserve">
          <source>A shared cache MUST NOT use a cached response to a request with an
   Authorization header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7235]&lt;/a&gt;) to satisfy any
   subsequent request unless a cache directive that allows such
   responses to be stored is present in the response.

   In this specification, the following Cache-Control response
   directives (&lt;a href=&quot;#section-5.2.2&quot;&gt;Section 5.2.2&lt;/a&gt;) have such an effect: must-revalidate,
   public, and s-maxage. 

   Note that cached responses that contain the &quot;must-revalidate&quot; and/or
   &quot;s-maxage&quot; response directives are not allowed to be served stale
   (&lt;a href=&quot;#section-4.2.4&quot;&gt;Section 4.2.4&lt;/a&gt;) by shared caches.  In particular, a response with
   either &quot;max-age=0, must-revalidate&quot; or &quot;s-maxage=0&quot; cannot be used to
   satisfy a subsequent request without revalidating it on the origin
   server.</source>
          <target state="translated">공유 캐시는 승인 헤더 필드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;[RFC7235]의 섹션 4.2)&lt;/a&gt; 가있는 요청에 대해 캐시 된 응답을 사용하여 응답에 이러한 응답을 저장할 수있는 캐시 지시문이없는 경우 후속 요청을 충족해서는 안됩니다. 이 사양에서 다음과 같은 캐시 제어 응답 지시문 ( &lt;a href=&quot;#section-5.2.2&quot;&gt;섹션 5.2.2&lt;/a&gt; )은 반드시 유효성을 다시 확인해야합니다. 공개 및 s-maxage. &quot;must-revalidate&quot;및 / 또는 &quot;s-maxage&quot;응답 지시문이 포함 된 캐시 된 응답은 부실하게 제공 될 수 없습니다 ( &lt;a href=&quot;#section-4.2.4&quot;&gt;섹션 4.2.4).&lt;/a&gt;)을 공유 캐시로 특히, &quot;max-age = 0, must-revalidate&quot;또는 &quot;s-maxage = 0&quot;의 응답을 사용하여 후속 요청을 오리진 서버에서 다시 확인하지 않고 후속 요청을 충족시킬 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6723cf8edd03849b4cdc5d908be434852f344b77" translate="yes" xml:space="preserve">
          <source>A shared cache is a cache that stores responses to be reused by more than one user. For example, an ISP or your company might have set up a web proxy as part of its local network infrastructure to serve many users so that popular resources are reused a number of times, reducing network traffic and latency.</source>
          <target state="translated">공유 캐시는 둘 이상의 사용자가 재사용 할 응답을 저장하는 캐시입니다. 예를 들어, ISP 또는 회사는 로컬 네트워크 인프라의 일부로 웹 프록시를 설정하여 많은 사용자에게 서비스를 제공하여 인기있는 리소스를 여러 번 재사용함으로써 네트워크 트래픽 및 대기 시간을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="c2b2979df34c75249acdcbaead32af4206e98c1f" translate="yes" xml:space="preserve">
          <source>A significant difference between HTTP/1.1 and earlier versions of
   HTTP is that persistent connections are the default behavior of any
   HTTP connection. That is, unless otherwise indicated, the client
   SHOULD assume that the server will maintain a persistent connection,
   even after error responses from the server.

   Persistent connections provide a mechanism by which a client and a
   server can signal the close of a TCP connection. This signaling takes
   place using the Connection header field (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;). Once a close
   has been signaled, the client MUST NOT send any more requests on that
   connection.</source>
          <target state="translated">HTTP / 1.1과 이전 버전의 HTTP의 중요한 차이점은 영구 연결이 모든 HTTP 연결의 기본 동작이라는 점입니다. 즉, 달리 명시되지 않는 한 클라이언트는 서버의 오류 응답 후에도 서버가 지속적인 연결을 유지한다고 가정해야합니다. 지속적인 연결은 클라이언트와 서버가 TCP 연결 종료를 알리는 메커니즘을 제공합니다. 이 시그널링은 연결 헤더 필드를 사용하여 수행됩니다 ( &lt;a href=&quot;#section-14.10&quot;&gt;섹션 14.10&lt;/a&gt; ). 종료 신호가 발생하면 클라이언트는 해당 연결에 대해 더 이상 요청을 보내지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="fc833fea6c576628123c7be8083a40beb8ce29b5" translate="yes" xml:space="preserve">
          <source>A simple form using the default &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; content type:</source>
          <target state="translated">기본 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 컨텐츠 유형을 사용하는 간단한 양식 :</target>
        </trans-unit>
        <trans-unit id="c7b39b34d060373154765396af385c3d062ca369" translate="yes" xml:space="preserve">
          <source>A simple protocol to exchange these documents, the &lt;em&gt;HypertText Transfer Protocol &lt;/em&gt;(HTTP).</source>
          <target state="translated">이러한 문서를 교환하는 간단한 프로토콜 인 &lt;em&gt;HypertText Transfer Protocol&lt;/em&gt; (HTTP)입니다.</target>
        </trans-unit>
        <trans-unit id="fe6b8df10d2d0221c0d8b10a29444ba2522da8aa" translate="yes" xml:space="preserve">
          <source>A single, precise &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME type&lt;/a&gt;, like &lt;code&gt;text/html&lt;/code&gt;.</source>
          <target state="translated">하나, 정확한 &lt;a href=&quot;../basics_of_http/mime_types&quot;&gt;MIME 타입&lt;/a&gt; 과 같은, &lt;code&gt;text/html&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4deb257d47824330583bad2d749145dc206117e9" translate="yes" xml:space="preserve">
          <source>A specific document is called a &lt;em&gt;resource&lt;/em&gt;. When a client wants to obtain a resource, the client requests it using its URL. The server uses this URL to choose one of the variants it provides &amp;ndash; each variant being called a &lt;em&gt;representation&lt;/em&gt; &amp;ndash; and returns a specific representation to the client. The overall resource, as well as each of the representations, have a specific URL. How a specific representation is chosen when the resource is called is determined by &lt;em&gt;content negotiation&lt;/em&gt; and there are several ways of negotiating between the client and the server.</source>
          <target state="translated">특정 문서를 &lt;em&gt;리소스&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; . 클라이언트가 리소스를 얻으려고 할 때 클라이언트는 URL을 사용하여 리소스를 요청합니다. 서버는이 URL을 사용하여 제공하는 변형 중 하나 ( &lt;em&gt;표현&lt;/em&gt; 이라고하는 각 변형) 를 선택하고 클라이언트에 특정 표현을 반환합니다. 전체 리소스와 각 표현에는 특정 URL이 있습니다. 리소스가 호출 될 때 특정 표현이 선택되는 방법은 &lt;em&gt;콘텐츠 협상에&lt;/em&gt; 의해 결정되며 클라이언트와 서버간에 협상하는 여러 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b779f5a10d17e9e595f84888aae03e305b6d164d" translate="yes" xml:space="preserve">
          <source>A specific document is called a &lt;em&gt;resource&lt;/em&gt;. When a client wants to obtain it, it requests it using its URL. The server uses this URL to choose one of the variants it provides &amp;ndash; each variant being called a &lt;em&gt;representation&lt;/em&gt; &amp;ndash; and returns this specific representation to the client. The overall resource, as well as each of the representations, have a specific URL. How a specific representation is chosen when the resource is called is determined by &lt;em&gt;content negotiation&lt;/em&gt; and there are several ways of negotiating between the client and the server.</source>
          <target state="translated">특정 문서를 &lt;em&gt;자원&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . 클라이언트가이를 얻으려면 URL을 사용하여 요청합니다. 서버는이 URL을 사용하여 제공하는 변형 중 하나 (각 변형을 &lt;em&gt;표현&lt;/em&gt; 이라고 함)를 선택 하고이 특정 표현을 클라이언트에 반환합니다. 각 표현뿐만 아니라 전체 자원에는 특정 URL이 있습니다. 자원이 호출 될 때 특정 표현이 선택되는 방법은 &lt;em&gt;컨텐츠 협상에&lt;/em&gt; 의해 결정되며 클라이언트와 서버간에 협상하는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ceace1a8903945561dd351633e2b54bd5662380b" translate="yes" xml:space="preserve">
          <source>A specific incompatibility exists in some versions of the Safari web browser, whereby if a Content Security Policy header is set, but not a Same Origin header, the browser will block self-hosted content and off-site content, and incorrectly report that this is due to a the Content Security Policy not allowing the content.</source>
          <target state="translated">일부 버전의 Safari 웹 브라우저에는 특정 비 호환성이 존재합니다. 따라서 콘텐츠 보안 정책 헤더가 설정되어 있지만 동일한 오리진 헤더가 아닌 경우 브라우저는 자체 호스팅 컨텐츠 및 오프 사이트 컨텐츠를 차단하고 이것이 잘못되었다고 잘못보고합니다. 콘텐츠 보안 정책으로 인해 콘텐츠를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9d5d6a9b1ff08cc641c31611f35b864c75165ef" translate="yes" xml:space="preserve">
          <source>A specific kind of URI that directly embeds the resource it represents. Data URIs are very convenient, but have some caveats.</source>
          <target state="translated">나타내는 리소스를 직접 포함하는 특정 종류의 URI입니다. 데이터 URI는 매우 편리하지만 몇 가지주의 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="80a8fdf6c2788b6b9978669c875fa2c7ee77f30d" translate="yes" xml:space="preserve">
          <source>A specific kind of URIs that directly embeds the resource it represents. Data URIs are very convenient, but have some caveats.</source>
          <target state="translated">그것이 나타내는 자원을 직접 포함하는 특정 종류의 URI. 데이터 URI는 매우 편리하지만 몇 가지주의 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6717e7d4b911da2b4b4a18d74011b1145e1b78df" translate="yes" xml:space="preserve">
          <source>A specific kind of URIs, data URIs, embed the resource itself inside the identifier.</source>
          <target state="translated">특정 종류의 URI 인 데이터 URI는 리소스 자체를 식별자 안에 포함시킵니다.</target>
        </trans-unit>
        <trans-unit id="fa9c947ce55668387be7bc6267a41295eae128cc" translate="yes" xml:space="preserve">
          <source>A specification such as this thrives on piercing critical review and
   withers from apathetic neglect.  The authors gratefully acknowledge
   the contributions of the following people, whose insights were so
   valuable at every stage of our work.

   Contributors to &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;

   Terry Allen, Harald Alvestrand, Jim Amsden, Becky Anderson, Alan
   Babich, Sanford Barr, Dylan Barrell, Bernard Chester, Tim Berners-
   Lee, Dan Connolly, Jim Cunningham, Ron Daniel, Jr., Jim Davis, Keith
   Dawson, Mark Day, Brian Deen, Martin Duerst, David Durand, Lee
   Farrell, Chuck Fay, Wesley Felter, Roy Fielding, Mark Fisher, Alan
   Freier, George Florentine, Jim Gettys, Phill Hallam-Baker, Dennis
   Hamilton, Steve Henning, Mead Himelstein, Alex Hopmann, Andre van der
   Hoek, Ben Laurie, Paul Leach, Ora Lassila, Karen MacArthur, Steven
   Martin, Larry Masinter, Michael Mealling, Keith Moore, Thomas Narten,
   Henrik Nielsen, Kenji Ota, Bob Parker, Glenn Peterson, Jon Radoff,
   Saveen Reddy, Henry Sanders, Christopher Seiwald, Judith Slein, Mike
   Spreitzer, Einar Stefferud, Greg Stein, Ralph Swick, Kenji Takahashi,
   Richard N. Taylor, Robert Thau, John Turner, Sankar Virdhagriswaran,
   Fabio Vitali, Gregory Woodhouse, and Lauren Wood.

   Two from this list deserve special mention.  The contributions by
   Larry Masinter have been invaluable; he both helped the formation of
   the working group and patiently coached the authors along the way.
   In so many ways he has set high standards that we have toiled to
   meet.  The contributions of Judith Slein were also invaluable; by
   clarifying the requirements and in patiently reviewing version after
   version, she both improved this specification and expanded our minds
   on document management.

   We would also like to thank John Turner for developing the XML DTD.

   The authors of &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; were Yaron Goland, Jim Whitehead, A. Faizi,
   Steve Carter, and D. Jensen.  Although their names had to be removed
   due to IETF author count restrictions, they can take credit for the
   majority of the design of WebDAV.

   Additional Acknowledgements for This Specification

   Significant contributors of text for this specification are listed as
   contributors in the section below.  We must also gratefully
   acknowledge Geoff Clemm, Joel Soderberg, and Dan Brotsky for hashing
   out specific text on the list or in meetings.  Joe Hildebrand and
   Cullen Jennings helped close many issues.  Barry Lind described an
   additional security consideration and Cullen Jennings provided text 

   for that consideration.  Jason Crawford tracked issue status for this
   document for a period of years, followed by Elias Sinderson.</source>
          <target state="translated">이와 같은 사양은 비판적 검토를 찌르고 냉담한 방치에서 벗어나는 데 성공합니다. 저자는 다음과 같은 사람들의 공헌에 감사를 표하며 우리의 작업의 모든 단계에서 통찰력이 매우 중요했습니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518에&lt;/a&gt; 기고자 Terry Allen, Harald Alvestrand, Jim Amsden, Becky Anderson, Alan Babich, Sanford Barr, Dylan Barrell, Bernard Chester, Tim Berners- Lee, Dan Connolly, Jim Cunningham, Ron Daniel, Jr., Jim Davis, Keith Dawson, Mark Day, Brian Deen, Martin Duerst, David Durand, Lee Farrell, Chuck Fay, Wesley Felter, Roy Fielding, Mark Fisher, Alan Freier, George Florentine, Jim Gettys, Phill Hallam-Baker, Dennis Hamilton, Steve Henning, Mead Himelstein, Alex Hopmann, 안드레 반 데어 호크, 벤 로리, 폴 리치, 오라 라 실라, 카렌 맥아더, 스티븐 마틴, 래리 마스터, 마이클 멀링, 키스 무어, 토마스 나텐, 헨릭 닐슨, 켄지 오타, 밥 파커, 글렌 피터슨, 존 래도 프, 세이브 레디, Henry Sanders, Christopher Seiwald, Judith Slein, Mike Spreitzer, Einar Stefferud, Greg Stein, Ralph Swick, Kenji Takahashi,Richard N. Taylor, Robert Thau, John Turner, Sankar Virdhagriswaran, Fabio Vitali, Gregory Woodhouse 및 Lauren Wood. 이 목록에서 두 가지는 특별한 언급이 필요합니다. Larry Masinter의 기여는 매우 귀중했습니다. 그는 실무 그룹의 형성을 도왔고 작가들을 진지하게지도했다. 그는 여러 가지면에서 우리가 고수하기 위해 고수 한 표준을 세웠습니다. Judith Slein의 기여도 매우 귀중했습니다. 요구 사항을 명확히하고 버전 별 버전을 참을성있게 검토함으로써이 사양을 개선하고 문서 관리에 대한 우리의 생각을 넓혔습니다. XML DTD를 개발 한 John Turner에게도 감사의 말씀을 전합니다. 저자이 목록에서 두 가지는 특별한 언급이 필요합니다. Larry Masinter의 기여는 매우 귀중했습니다. 그는 실무 그룹의 형성을 도왔고 작가들을 진지하게지도했다. 그는 여러 가지면에서 우리가 고수하기 위해 고수 한 표준을 세웠습니다. Judith Slein의 기여도 매우 귀중했습니다. 요구 사항을 명확히하고 버전 별 버전을 참을성있게 검토함으로써이 사양을 개선하고 문서 관리에 대한 우리의 생각을 넓혔습니다. XML DTD를 개발 한 John Turner에게도 감사의 말씀을 전합니다. 저자이 목록에서 두 가지는 특별한 언급이 필요합니다. Larry Masinter의 기여는 매우 귀중했습니다. 그는 실무 그룹의 형성을 도왔고 작가들을 진지하게지도했다. 그는 여러 가지면에서 우리가 고수하기 위해 고수 한 표준을 세웠습니다. Judith Slein의 기여도 매우 귀중했습니다. 요구 사항을 명확히하고 버전 별 버전을 참을성있게 검토함으로써이 사양을 개선하고 문서 관리에 대한 우리의 생각을 넓혔습니다. XML DTD를 개발 한 John Turner에게도 감사의 말씀을 전합니다. 저자그는 여러 가지면에서 우리가 고수하기 위해 고수 한 표준을 세웠습니다. Judith Slein의 기여도 매우 귀중했습니다. 요구 사항을 명확히하고 버전 별 버전을 참을성있게 검토함으로써이 사양을 개선하고 문서 관리에 대한 우리의 생각을 넓혔습니다. XML DTD를 개발 한 John Turner에게도 감사의 말씀을 전합니다. 저자그는 여러 가지면에서 우리가 고수하기 위해 고수 한 표준을 세웠습니다. Judith Slein의 기여도 매우 귀중했습니다. 요구 사항을 명확히하고 버전 별 버전을 참을성있게 검토함으로써이 사양을 개선하고 문서 관리에 대한 우리의 생각을 넓혔습니다. XML DTD를 개발 한 John Turner에게도 감사의 말씀을 전합니다. 저자&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;Yaron Goland, Jim Whitehead, A. Faizi, Steve Carter, D. Jensen 등이 있습니다. IETF 작성자 수 제한으로 인해 이름을 제거해야했지만 WebDAV 디자인의 대부분을 인정할 수 있습니다. 이 사양에 대한 추가 승인이 사양의 주요 텍스트 제공자는 아래 섹션에 제공자로 표시됩니다. 또한 목록이나 회의에서 특정 텍스트를 해시 한 Geoff Clemm, Joel Soderberg 및 Dan Brotsky에게도 감사의 말을 전합니다. Joe Hildebrand와 Cullen Jennings가 많은 문제를 해결하는 데 도움을주었습니다. Barry Lind는 추가 보안 고려 사항을 설명했으며 Cullen Jennings는 해당 고려 사항에 대한 텍스트를 제공했습니다. Jason Crawford는 몇 년 동안이 문서의 문제 상태를 추적 한 후 Elias Sinderson이 그 뒤를이었습니다.</target>
        </trans-unit>
        <trans-unit id="243ac7b5d0c4b7135957ced81f079042072b4147" translate="yes" xml:space="preserve">
          <source>A standardized version of this header is the HTTP &lt;a href=&quot;forwarded&quot;&gt;&lt;code&gt;Forwarded&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">이 헤더의 표준화 된 버전은 HTTP &lt;a href=&quot;forwarded&quot;&gt; &lt;code&gt;Forwarded&lt;/code&gt; &lt;/a&gt; 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="d5732080026806544aacb362bb381344fc069b68" translate="yes" xml:space="preserve">
          <source>A status code line is also sent at the beginning of the response, allowing the browser itself to understand the success or failure of the request and to adapt its behavior in consequence (like in updating or using its local cache in a specific way)</source>
          <target state="translated">응답 시작시 상태 코드 행이 전송되어 브라우저 자체가 요청의 성공 또는 실패를 이해하고 결과적으로 동작을 조정할 수 있습니다 (예 : 특정 방식으로 로컬 캐시를 업데이트하거나 사용하는 경우).</target>
        </trans-unit>
        <trans-unit id="c8e08ba45f9595801714cdefafd3faea76d549c5" translate="yes" xml:space="preserve">
          <source>A status message, a non-authoritative short description of the status code.</source>
          <target state="translated">상태 메시지, 상태 코드에 대한 권한이없는 간단한 설명.</target>
        </trans-unit>
        <trans-unit id="8af24e7123d43765daa487b6cb3e5b3c4417b1a2" translate="yes" xml:space="preserve">
          <source>A stream error is an error related to a specific stream that does not
   affect processing of other streams.

   An endpoint that detects a stream error sends a RST_STREAM frame
   (&lt;a href=&quot;#section-6.4&quot;&gt;Section 6.4&lt;/a&gt;) that contains the stream identifier of the stream where
   the error occurred.  The RST_STREAM frame includes an error code that
   indicates the type of error.

   A RST_STREAM is the last frame that an endpoint can send on a stream.
   The peer that sends the RST_STREAM frame MUST be prepared to receive
   any frames that were sent or enqueued for sending by the remote peer.
   These frames can be ignored, except where they modify connection
   state (such as the state maintained for header compression
   (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) or flow control).

   Normally, an endpoint SHOULD NOT send more than one RST_STREAM frame
   for any stream.  However, an endpoint MAY send additional RST_STREAM
   frames if it receives frames on a closed stream after more than a
   round-trip time.  This behavior is permitted to deal with misbehaving
   implementations. 

   To avoid looping, an endpoint MUST NOT send a RST_STREAM in response
   to a RST_STREAM frame.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e013235aa2f4b291e00e311c2ac1352025ad323f" translate="yes" xml:space="preserve">
          <source>A string for identifying HTTP/2 is entered into the &quot;Application-
   Layer Protocol Negotiation (ALPN) Protocol IDs&quot; registry established
   in [&lt;a href=&quot;#ref-TLS-ALPN&quot;&gt;TLS-ALPN&lt;/a&gt;].

   This document establishes a registry for frame types, settings, and
   error codes.  These new registries appear in the new &quot;Hypertext
   Transfer Protocol version 2 (HTTP/2) Parameters&quot; section.

   This document registers the HTTP2-Settings header field for use in
   HTTP; it also registers the 421 (Misdirected Request) status code.

   This document registers the &quot;PRI&quot; method for use in HTTP to avoid
   collisions with the connection preface (&lt;a href=&quot;#section-3.5&quot;&gt;Section 3.5&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a08604bc21c1691f9b1f625192cc47697f42035b" translate="yes" xml:space="preserve">
          <source>A successful LOCK method MUST result in the creation of an empty
   resource that is locked (and that is not a collection) when a
   resource did not previously exist at that URL.  Later on, the lock
   may go away but the empty resource remains.  Empty resources MUST
   then appear in PROPFIND responses including that URL in the response
   scope.  A server MUST respond successfully to a GET request to an
   empty resource, either by using a 204 No Content response, or by
   using 200 OK with a Content-Length header indicating zero length</source>
          <target state="translated">성공적인 LOCK 메소드는 리소스가 해당 URL에 존재하지 않았을 때 잠겨 있고 컬렉션이 아닌 빈 리소스를 생성해야합니다. 나중에 잠금이 사라지지만 빈 리소스는 남아 있습니다. 빈 자원은 응답 범위에서 해당 URL을 포함한 PROPFIND 응답에 나타나야합니다. 서버는 204 No Content 응답을 사용하거나 길이가 0 인 Content-Length 헤더로 200 OK를 사용하여 빈 자원에 대한 GET 요청에 성공적으로 응답해야합니다.</target>
        </trans-unit>
        <trans-unit id="761ebc49a4e6c7f0646a5103ac3b55e7ffb14172" translate="yes" xml:space="preserve">
          <source>A successful response is indicated by any &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.3&quot;&gt;2xx&lt;/a&gt; status code.</source>
          <target state="translated">성공적인 응답은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.3&quot;&gt;2xx&lt;/a&gt; 상태 코드로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="34367556fdd895f927c5302a93e55ce713fb9f94" translate="yes" xml:space="preserve">
          <source>A successful response is indicated with a &lt;a href=&quot;../status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt; response code, because the response in the example does not carry a message body. (which a response with the 200 code would have). Note that other success codes could be used as well.</source>
          <target state="translated">예제의 응답이 메시지 본문을 전달하지 않기 때문에 성공적인 응답은 &lt;a href=&quot;../status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt; 응답 코드로 표시됩니다. (200 코드의 응답이있을 것입니다). 다른 성공 코드도 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e103fc95ad4823358a2845eae9f826cfeffda4c5" translate="yes" xml:space="preserve">
          <source>A textual format to represent hypertext documents, the &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;HyperText Markup Language&lt;/a&gt;&lt;/em&gt; (HTML).</source>
          <target state="translated">하이퍼 텍스트 문서를 나타내는 텍스트 형식 인 하이퍼 &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML&quot;&gt;텍스트 마크 업 언어&lt;/a&gt;&lt;/em&gt; (HTML)입니다.</target>
        </trans-unit>
        <trans-unit id="4ce1aa0486be881fd62b04d40f7f043b63b1c037" translate="yes" xml:space="preserve">
          <source>A three-digit warning number. The first digit indicates whether the &lt;code&gt;Warning&lt;/code&gt; is required to be deleted from a stored response after validation.</source>
          <target state="translated">3 자리 경고 번호. 첫 번째 숫자는 유효성 검사 후 저장된 응답에서 &lt;code&gt;Warning&lt;/code&gt; 를 삭제 해야하는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="7b7d752bda74832f7282cbd7c03d86206cc0cd43" translate="yes" xml:space="preserve">
          <source>A trailer allows the sender to include additional fields at the end
   of a chunked message in order to supply metadata that might be
   dynamically generated while the message body is sent, such as a
   message integrity check, digital signature, or post-processing
   status.  The trailer fields are identical to header fields, except
   they are sent in a chunked trailer instead of the message's header
   section.

     trailer-part   = *( header-field CRLF )

   A sender MUST NOT generate a trailer that contains a field necessary
   for message framing (e.g., Transfer-Encoding and Content-Length),
   routing (e.g., Host), request modifiers (e.g., controls and
   conditionals in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5&quot;&gt;Section&amp;nbsp;5 of [RFC7231]&lt;/a&gt;), authentication (e.g., see
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;]), response control data (e.g., see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1&quot;&gt;7.1 of [RFC7231]&lt;/a&gt;), or determining how to process the payload (e.g.,
   Content-Encoding, Content-Type, Content-Range, and Trailer).

   When a chunked message containing a non-empty trailer is received,
   the recipient MAY process the fields (aside from those forbidden
   above) as if they were appended to the message's header section.  A
   recipient MUST ignore (or consider as an error) any fields that are
   forbidden to be sent in a trailer, since processing them as if they
   were present in the header section might bypass external security
   filters.

   Unless the request includes a TE header field indicating &quot;trailers&quot;
   is acceptable, as described in &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;, a server SHOULD NOT
   generate trailer fields that it believes are necessary for the user
   agent to receive.  Without a TE containing &quot;trailers&quot;, the server
   ought to assume that the trailer fields might be silently discarded
   along the path to the user agent.  This requirement allows
   intermediaries to forward a de-chunked message to an HTTP/1.0
   recipient without buffering the entire response.</source>
          <target state="translated">트레일러는 메시지 무결성 검사, 디지털 서명 또는 사후 처리 상태와 같이 메시지 본문이 전송되는 동안 동적으로 생성 될 수있는 메타 데이터를 제공하기 위해 청크자가 청크 된 메시지의 끝에 추가 필드를 포함 할 수 있도록합니다. 예고편 필드는 헤더 필드와 동일하지만 메시지의 헤더 섹션 대신 청크 예고편으로 전송됩니다. trailer-part = * (header-field CRLF) 발신자는 메시지 프레이밍 (예 : Transfer-Encoding 및 Content-Length), 라우팅 (예 : 호스트), 요청 수정 자 (예 : &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-5&quot;&gt;[RFC7231] 섹션 5의&lt;/a&gt; 제어 및 조건 , 인증 (예 : [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ] 및 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265 참조)&lt;/a&gt;]), 응답 제어 데이터 (예 : &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1&quot;&gt;[RFC7231] &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1&quot;&gt;섹션 &lt;/a&gt;7.1 참조 ) 또는 페이로드 처리 방법 결정 (예 : Content-Encoding, Content-Type, Content-Range 및 Trailer). 비어 있지 않은 예고편이 포함 된 청크 메시지가 수신되면 수신자는 메시지의 헤더 섹션에 추가 된 것처럼 필드 (위에서 금지 된 필드 제외)를 처리 할 수 ​​있습니다. 수신자는 예고편에 전송이 금지 된 필드를 헤더 섹션에있는 것처럼 처리하면 외부 보안 필터를 무시할 수 있으므로 무시해야합니다 (또는 오류로 간주). 요청에 &quot;트레일러&quot;가 허용됨을 나타내는 TE 헤더 필드가 포함되어 있지 않으면&lt;a href=&quot;#section-4.3&quot;&gt; 섹션 4.3에&lt;/a&gt;서버는 사용자 에이전트에 필요한 트레일러 필드를 생성해서는 안됩니다. &quot;트레일러&quot;를 포함하는 TE가 없으면 서버는 트레일러 필드가 사용자 에이전트의 경로를 따라 자동으로 버려 질 수 있다고 가정해야합니다. 이 요구 사항을 통해 중개자는 청크 해제 된 메시지를 전체 응답을 버퍼링하지 않고 HTTP / 1.0 수신자에게 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b66dee6b11e93736d953af429c12c61621b0b237" translate="yes" xml:space="preserve">
          <source>A typical HTTP session</source>
          <target state="translated">일반적인 HTTP 세션</target>
        </trans-unit>
        <trans-unit id="96ee2f8f3bbbe21e292a7b8dac9501fca154c6f0" translate="yes" xml:space="preserve">
          <source>A typical flow of requests, all through one single connection is now looking like this:</source>
          <target state="translated">하나의 단일 연결을 통한 일반적인 요청 흐름은 이제 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4ccbdc0f9453daa1ff4757f0c1283a456c445232" translate="yes" xml:space="preserve">
          <source>A typical status line looks like: &lt;code&gt;HTTP/1.1 404 Not Found.&lt;/code&gt;</source>
          <target state="translated">일반적인 상태 표시 줄은 &lt;code&gt;HTTP/1.1 404 Not Found.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5301a544830b2f5e4f1a802c0392489c4929900" translate="yes" xml:space="preserve">
          <source>A typical status line looks like: &lt;code&gt;HTTP/1.1 404 Not Found&lt;/code&gt;.</source>
          <target state="translated">일반적인 상태 줄은 다음과 같습니다. &lt;code&gt;HTTP/1.1 404 Not Found&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7772ff9ebd19b33547ec2a86b5652c058907a9ee" translate="yes" xml:space="preserve">
          <source>A unique string identifying the version of the resource. Conditional requests using &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; use this value to change the behavior of the request.</source>
          <target state="translated">리소스의 버전을 식별하는 고유 한 문자열입니다. &lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; 를&lt;/a&gt; 사용하는 조건부 요청 은이 값을 사용하여 요청의 동작을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="ae78cbf97ee4cff3a5f3f02f099427e133082c03" translate="yes" xml:space="preserve">
          <source>A user agent has to demonstrate knowledge of a lock when requesting
   an operation on a locked resource.  Otherwise, the following scenario
   might occur.  In the scenario, program A, run by User A, takes out a
   write lock on a resource.  Program B, also run by User A, has no
   knowledge of the lock taken out by program A, yet performs a PUT to
   the locked resource.  In this scenario, the PUT succeeds because
   locks are associated with a principal, not a program, and thus
   program B, because it is acting with principal A's credential, is
   allowed to perform the PUT.  However, had program B known about the
   lock, it would not have overwritten the resource, preferring instead
   to present a dialog box describing the conflict to the user.  Due to
   this scenario, a mechanism is needed to prevent different programs
   from accidentally ignoring locks taken out by other programs with the
   same authorization.

   In order to prevent these collisions, a lock token MUST be submitted
   by an authorized principal for all locked resources that a method may
   change or the method MUST fail.  A lock token is submitted when it
   appears in an If header.  For example, if a resource is to be moved
   and both the source and destination are locked, then two lock tokens
   must be submitted in the If header, one for the source and the other
   for the destination.</source>
          <target state="translated">사용자 에이전트는 잠긴 자원에 대한 작업을 요청할 때 잠금에 대한 지식을 보여 주어야합니다. 그렇지 않으면 다음 시나리오가 발생할 수 있습니다. 이 시나리오에서 사용자 A가 실행하는 프로그램 A는 자원에 대한 쓰기 잠금을 수행합니다. 사용자 A도 실행하는 프로그램 B는 프로그램 A가 수행 한 잠금에 대해 알지 못하지만 잠긴 자원에 대한 PUT을 수행합니다. 이 시나리오에서는 잠금이 프로그램이 아닌 보안 주체와 연결되어 있으므로 PUT이 성공하므로 프로그램 B는 보안 주체 A의 자격 증명으로 작동하므로 PUT을 수행 할 수 있습니다. 그러나 프로그램 B가 잠금에 대해 알고 있었으므로 리소스를 덮어 쓰지 않았고 대신 사용자에게 충돌을 설명하는 대화 상자를 표시하는 것을 선호했습니다. 이 시나리오로 인해다른 프로그램이 동일한 권한을 가진 다른 프로그램에서 가져온 잠금을 실수로 무시하지 않도록하는 메커니즘이 필요합니다. 이러한 충돌을 방지하기 위해, 권한이 부여 된 보안 주체는 잠금 토큰을 변경하여 메소드가 변경 될 수 있거나 메소드가 실패해야합니다. 잠금 헤더는 If 헤더에 나타날 때 제출됩니다. 예를 들어, 자원을 이동하고 소스와 대상을 모두 잠그면 If 헤더에 두 개의 잠금 토큰을 제출해야합니다. 하나는 소스 용이고 다른 하나는 대상 용입니다.메소드가 변경되거나 메소드가 실패해야하는 모든 잠긴 자원에 대해 권한있는 보안 주체가 잠금 토큰을 제출해야합니다. 잠금 헤더는 If 헤더에 나타날 때 제출됩니다. 예를 들어, 자원을 이동하고 소스와 대상을 모두 잠그면 If 헤더에 두 개의 잠금 토큰을 제출해야합니다. 하나는 소스 용이고 다른 하나는 대상 용입니다.메소드가 변경되거나 메소드가 실패해야하는 모든 잠긴 자원에 대해 권한있는 보안 주체가 잠금 토큰을 제출해야합니다. 잠금 헤더는 If 헤더에 나타날 때 제출됩니다. 예를 들어, 자원을 이동하고 소스와 대상을 모두 잠그면 If 헤더에 두 개의 잠금 토큰을 제출해야합니다. 하나는 소스 용이고 다른 하나는 대상 용입니다.</target>
        </trans-unit>
        <trans-unit id="1665264fcfc3dbf5c0a1ff63ea9c76cb5daa217f" translate="yes" xml:space="preserve">
          <source>A user agent that wishes to authenticate itself with a server--
      usually, but not necessarily, after receiving a 401 response--does
      so by including an Authorization request-header field with the
      request.  The Authorization field value consists of credentials
      containing the authentication information of the user agent for
      the realm of the resource being requested.

          Authorization  = &quot;Authorization&quot; &quot;:&quot; credentials

      HTTP access authentication is described in &quot;HTTP Authentication:
      Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. If a request is
      authenticated and a realm specified, the same credentials SHOULD
      be valid for all other requests within this realm (assuming that
      the authentication scheme itself does not require otherwise, such
      as credentials that vary according to a challenge value or using
      synchronized clocks).

      When a shared cache (see &lt;a href=&quot;#section-13.7&quot;&gt;section 13.7&lt;/a&gt;) receives a request
      containing an Authorization field, it MUST NOT return the
      corresponding response as a reply to any other request, unless one
      of the following specific exceptions holds:

      1. If the response includes the &quot;s-maxage&quot; cache-control
         directive, the cache MAY use that response in replying to a
         subsequent request. But (if the specified maximum age has
         passed) a proxy cache MUST first revalidate it with the origin
         server, using the request-headers from the new request to allow
         the origin server to authenticate the new request. (This is the
         defined behavior for s-maxage.) If the response includes &quot;s-
         maxage=0&quot;, the proxy MUST always revalidate it before re-using
         it.

      2. If the response includes the &quot;must-revalidate&quot; cache-control
         directive, the cache MAY use that response in replying to a
         subsequent request. But if the response is stale, all caches
         MUST first revalidate it with the origin server, using the
         request-headers from the new request to allow the origin server
         to authenticate the new request.

      3. If the response includes the &quot;public&quot; cache-control directive,
         it MAY be returned in reply to any subsequent request.</source>
          <target state="translated">일반적으로 401 응답을받은 후 반드시 서버에 인증하려는 사용자 에이전트는 요청에 Authorization request-header 필드를 포함 시켜서 인증합니다. 권한 부여 필드 값은 요청되는 자원 영역에 대한 사용자 에이전트의 인증 정보를 포함하는 신임 정보로 구성됩니다. Authorization = &quot;Authorization&quot; &quot;:&quot;자격 증명 HTTP 액세스 인증은 &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증&quot;[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. 요청이 인증되고 영역이 지정된 경우이 영역 내의 다른 모든 요청에 ​​대해 동일한 자격 증명이 유효해야합니다 (챌린지 값에 따라 다른 자격 증명이나 동기화 된 시계를 사용하는 자격 증명과 같이 인증 체계 자체가 달리 요구하지 않는 경우) . 공유 캐시 ( &lt;a href=&quot;#section-13.7&quot;&gt;섹션 13.7&lt;/a&gt; 참조))는 승인 필드를 포함하는 요청을 수신하며, 다음 특정 예외 중 하나가 유지되지 않는 한 다른 요청에 대한 응답으로 해당 응답을 반환해서는 안됩니다. 1. 응답에 &quot;s-maxage&quot;캐시 제어 지시문이 포함 된 경우, 캐시는 후속 요청에 대한 응답으로 해당 응답을 사용할 수 있습니다. 그러나 (지정된 최대 유효 기간이 지난 경우) 프록시 캐시는 먼저 새 요청의 요청 헤더를 사용하여 원본 서버가 새 요청을 인증 할 수 있도록 원본 서버로 프록시 캐시를 다시 확인해야합니다. (s-maxage에 대해 정의 된 동작입니다.) 응답에 &quot;s-maxage = 0&quot;이 포함 된 경우 프록시를 다시 사용하기 전에 항상 프록시를 다시 확인해야합니다. 2. 응답에 &quot;must-revalidate &quot;cache-control 지시문, 캐시는 후속 요청에 응답 할 때 해당 응답을 사용할 수 있습니다. 그러나 응답이 오래되면 모든 캐시는 먼저 새 요청의 요청 헤더를 사용하여 원래 서버로이를 다시 확인해야합니다. 원 서버가 새로운 요청을 인증 할 수 있도록 허용 3. 응답에 &quot;공개&quot;캐시 제어 지시문이 포함 된 경우 후속 요청에 대한 응답으로 응답이 반환 될 수 있습니다.응답에 &quot;공개&quot;캐시 제어 지시문이 포함 된 경우 후속 요청에 대한 응답으로 리턴 될 수 있습니다.응답에 &quot;공개&quot;캐시 제어 지시문이 포함 된 경우 후속 요청에 대한 응답으로 리턴 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3eb38217a0a68009475024a823a8a9c28117955a" translate="yes" xml:space="preserve">
          <source>A valid &lt;a href=&quot;../../basics_of_http/mime_types/complete_list_of_mime_types&quot;&gt;MIME type&lt;/a&gt;.</source>
          <target state="translated">유효한 &lt;a href=&quot;../../basics_of_http/mime_types/complete_list_of_mime_types&quot;&gt;MIME 유형&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8fbdf43407e27f9040d31e47e9ef380e7e61d10a" translate="yes" xml:space="preserve">
          <source>A valid policy name consists only of alphanumeric characters, or one of &quot;&lt;code&gt;-#=_/@.%&lt;/code&gt;&quot;. A star (&lt;code&gt;*&lt;/code&gt;) as a policy name instructs the user agent to allow any unique policy name ('&lt;code&gt;allow-duplicates&lt;/code&gt;' may relax that further).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d38f471ad34bbb66b972153ec1a0f3abc561da01" translate="yes" xml:space="preserve">
          <source>A value of &lt;code&gt;On&lt;/code&gt; indicates explicit user opt-in into a reduced data usage mode on the client, and when communicated to origins allows them to deliver alternative content to reduce the data downloaded such as smaller image and video resources, different markup and styling, disabled polling and automatic updates, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e6db7c902ddf3358740b6f48b9c66a1329f13a" translate="yes" xml:space="preserve">
          <source>A value of &lt;strong&gt;-1&lt;/strong&gt; will disable caching, requiring a preflight OPTIONS check for all calls.</source>
          <target state="translated">값이 &lt;strong&gt;-1이면&lt;/strong&gt; 캐싱이 비활성화되어 모든 통화에 대한 사전 비행 옵션 검사가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5889b8a74eb0576ba107584be5617ae14bc061f0" translate="yes" xml:space="preserve">
          <source>A version number of the product.</source>
          <target state="translated">제품의 버전 번호입니다.</target>
        </trans-unit>
        <trans-unit id="e076002695264f7b92b71f90d2a5b52b89009a69" translate="yes" xml:space="preserve">
          <source>A very comprehensive article on browser internals and request flow through HTTP protocol. A MUST-READ for any web developer.</source>
          <target state="translated">HTTP 프로토콜을 통한 브라우저 내부 및 요청 흐름에 대한 매우 포괄적 인 기사. 모든 웹 개발자에게 반드시 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="1fa040618dd780f3a0aef82d86f3446592dbd355" translate="yes" xml:space="preserve">
          <source>A video file, possibly with audio, in the OGG container format. Theora is the usual video codec used within it; Vorbis is the usual audio codec.</source>
          <target state="translated">OGG 컨테이너 형식의 오디오가 포함 된 비디오 파일입니다. Theora는 그 안에 사용되는 일반적인 비디오 코덱입니다. Vorbis는 일반적인 오디오 코덱입니다.</target>
        </trans-unit>
        <trans-unit id="4c86cb2facddc78dcf860daaf77f4a3854799edb" translate="yes" xml:space="preserve">
          <source>A video file, possibly with audio, in the Ogg container format. Theora is the usual video codec used within it; Vorbis is the usual audio codec, although Opus is becoming more common.</source>
          <target state="translated">Ogg 컨테이너 형식의 비디오 파일 (오디오 포함 가능). Theora는 그 안에서 사용되는 일반적인 비디오 코덱입니다. Vorbis는 일반적인 오디오 코덱이지만 Opus가 점점 보편화되고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fa979d0019d43f2c9b25ac426f79d9a5706a185" translate="yes" xml:space="preserve">
          <source>A video file, possibly with audio, in the WebM container format. VP8 and VP9 are the most common video codecs; Vorbis and Opus the most common audio codecs.</source>
          <target state="translated">WebM 컨테이너 형식의 오디오가있는 비디오 파일입니다. VP8과 VP9는 가장 일반적인 비디오 코덱입니다. Vorbis와 Opus가 가장 일반적인 오디오 코덱입니다.</target>
        </trans-unit>
        <trans-unit id="19beb4d587d6a250a74c565550aaab0fc61d9928" translate="yes" xml:space="preserve">
          <source>A vulnerable application on a sub-domain can set a cookie with the &lt;code&gt;Domain&lt;/code&gt; attribute, which gives access to that cookie on all other subdomains. This mechanism can be abused in a &lt;em&gt;session fixation&lt;/em&gt; attack. See &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Session_fixation&quot;&gt;session fixation&lt;/a&gt; for primary mitigation methods.</source>
          <target state="translated">하위 도메인의 취약한 애플리케이션은 다른 모든 하위 도메인의 해당 쿠키에 대한 액세스를 제공 하는 &lt;code&gt;Domain&lt;/code&gt; 속성을 사용하여 쿠키를 설정할 수 있습니다 . 이 메커니즘은 &lt;em&gt;세션 고정&lt;/em&gt; 공격 에서 악용 될 수 있습니다 . 기본 완화 방법 은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Session_fixation&quot;&gt;세션 고정&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a189a3656c45672cb9f6d2aac0bf5a253e8d427" translate="yes" xml:space="preserve">
          <source>A web site administrator for an online banking site wants to ensure that all its content is loaded using SSL, in order to prevent attackers from eavesdropping on requests.</source>
          <target state="translated">온라인 뱅킹 사이트의 웹 사이트 관리자는 공격자가 요청을 도청하지 못하도록 모든 콘텐츠가 SSL을 사용하여로드되도록하려고합니다.</target>
        </trans-unit>
        <trans-unit id="b4a4bd38a2a84044ff7aca2e9392bd40ae65380b" translate="yes" xml:space="preserve">
          <source>A web site administrator for an online banking site wants to ensure that all its content is loaded using TLS, in order to prevent attackers from eavesdropping on requests.</source>
          <target state="translated">온라인 뱅킹 사이트의 웹 사이트 관리자는 공격자가 요청을 도청하는 것을 방지하기 위해 모든 콘텐츠가 TLS를 사용하여로드되는지 확인하려고합니다.</target>
        </trans-unit>
        <trans-unit id="78a6cf5a14fccb26323ff827be190ed35fcc6e26" translate="yes" xml:space="preserve">
          <source>A web site administrator of a web mail site wants to allow HTML in email, as well as images loaded from anywhere, but not JavaScript or other potentially dangerous content.</source>
          <target state="translated">웹 메일 사이트의 웹 사이트 관리자는 전자 메일의 HTML뿐만 아니라 JavaScript 또는 기타 잠재적으로 위험한 콘텐츠가 아닌 모든 위치에서로드 된 이미지를 허용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="7426821d25f9d1be7cdc0dee42a0c8e03a96be3c" translate="yes" xml:space="preserve">
          <source>A web site administrator wants all content to come from the site's own origin (this excludes subdomains.)</source>
          <target state="translated">웹 사이트 관리자는 모든 콘텐츠를 사이트 자체에서 가져 오기를 원합니다 (하위 도메인 제외).</target>
        </trans-unit>
        <trans-unit id="094a073a77d4ea29e21e0f0aa48a85ef6fc064f6" translate="yes" xml:space="preserve">
          <source>A web site administrator wants to allow content from a trusted domain and all its subdomains (it doesn't have to be the same domain that the CSP is set on.)</source>
          <target state="translated">웹 사이트 관리자가 신뢰할 수있는 도메인 및 모든 하위 도메인의 콘텐츠를 허용하려고합니다 (CSP가 설정 한 도메인과 같을 필요는 없음).</target>
        </trans-unit>
        <trans-unit id="c81c7277d68cf8c04b37b98fb5f5a7cea290054e" translate="yes" xml:space="preserve">
          <source>A web site administrator wants to allow users of a web application to include images from any origin in their own content, but to restrict audio or video media to trusted providers, and all scripts only to a specific server that hosts trusted code.</source>
          <target state="translated">웹 사이트 관리자는 웹 응용 프로그램 사용자가 자신의 콘텐츠에 원본 이미지를 포함 할 수 있지만 오디오 또는 비디오 미디어는 신뢰할 수있는 공급자로 제한하고 모든 스크립트는 신뢰할 수있는 코드를 호스팅하는 특정 서버로만 제한하려고합니다.</target>
        </trans-unit>
        <trans-unit id="9498f184ab4111b05c76c6fbfcfb1b645e8241e1" translate="yes" xml:space="preserve">
          <source>A whitelist for specific inline scripts using a cryptographic nonce (number used once). The server must generate a unique nonce value each time it transmits a policy. It is critical to provide an unguessable nonce, as bypassing a resource&amp;rsquo;s policy is otherwise trivial. See &lt;a href=&quot;script-src#Unsafe_inline_script&quot;&gt;unsafe inline script&lt;/a&gt; for an example. Specifying nonce makes a modern browser ignore &lt;code&gt;'unsafe-inline'&lt;/code&gt; which could still be set for older browsers without nonce support.</source>
          <target state="translated">암호화 nonce (번호는 한 번 사용됨)를 사용하는 특정 인라인 스크립트에 대한 화이트리스트입니다. 서버는 정책을 전송할 때마다 고유 한 nonce 값을 생성해야합니다. 자원 정책을 우회하는 것은 사소한 일이므로 의심 할 수없는 논스를 제공하는 것이 중요합니다. 예제는 &lt;a href=&quot;script-src#Unsafe_inline_script&quot;&gt;안전하지 않은 인라인 스크립트&lt;/a&gt; 를 참조하십시오 . nonce를 지정하면 최신 브라우저는 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 을 무시하므로 nonce를 지원하지 않는 구형 브라우저에는 여전히 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="607dbcd9743fda8a80dc6941bb1406560915ac51" translate="yes" xml:space="preserve">
          <source>A.1.  Changes from HTTP/1.0</source>
          <target state="translated">A.1. HTTP / 1.0에서 변경된 사항</target>
        </trans-unit>
        <trans-unit id="71e7c2181bcefe9076dade6180831af529a35160" translate="yes" xml:space="preserve">
          <source>A.1.  MIME-Version</source>
          <target state="translated">A.1. MIME 버전</target>
        </trans-unit>
        <trans-unit id="934d78a07914cb136497f33678b675d378c9c1c3" translate="yes" xml:space="preserve">
          <source>A.1.  Notes on Empty XML Elements</source>
          <target state="translated">A.1. 빈 XML 요소에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="0a1cd245606e42807b94c9f374a34eccc7961ec0" translate="yes" xml:space="preserve">
          <source>A.1.1.  Multihomed Web Servers</source>
          <target state="translated">A.1.1. 멀티 홈 웹 서버</target>
        </trans-unit>
        <trans-unit id="31ff08eb30576725916a16c707537cd82a7aa072" translate="yes" xml:space="preserve">
          <source>A.1.2.  Keep-Alive Connections</source>
          <target state="translated">A.1.2. 연결 유지</target>
        </trans-unit>
        <trans-unit id="4be274cc414e041aa285536fd1d9abea04688061" translate="yes" xml:space="preserve">
          <source>A.1.3.  Introduction of Transfer-Encoding</source>
          <target state="translated">A.1.3. 전송 인코딩 소개</target>
        </trans-unit>
        <trans-unit id="b625deb328c263df8d663f465330058cd2f6a3db" translate="yes" xml:space="preserve">
          <source>A.2.  Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;</source>
          <target state="translated">A.2. &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616의&lt;/a&gt; 변경 사항</target>
        </trans-unit>
        <trans-unit id="6c37ee894c4d97db6e012967c60c8ae1646c47d2" translate="yes" xml:space="preserve">
          <source>A.2.  Conversion to Canonical Form</source>
          <target state="translated">A.2. 정식 형식으로 변환</target>
        </trans-unit>
        <trans-unit id="13a5586a515762626176f0ba79e73a11ee5d37bc" translate="yes" xml:space="preserve">
          <source>A.2.  Notes on Illegal XML Processing</source>
          <target state="translated">A.2. 잘못된 XML 처리에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="5c000b068248fb6a64403618c2b71c2ec3faa5ef" translate="yes" xml:space="preserve">
          <source>A.3.  Conversion of Date Formats</source>
          <target state="translated">A.3. 날짜 형식의 변환</target>
        </trans-unit>
        <trans-unit id="ddb60af0705f2ed7e764e5c836e357c9a4588554" translate="yes" xml:space="preserve">
          <source>A.3.  Example - XML Syntax Error</source>
          <target state="translated">A.3. 예-XML 구문 오류</target>
        </trans-unit>
        <trans-unit id="c26036cb9e7529396282952036d022db566e885e" translate="yes" xml:space="preserve">
          <source>A.4.  Conversion of Content-Encoding</source>
          <target state="translated">A.4. 컨텐츠 인코딩의 변환</target>
        </trans-unit>
        <trans-unit id="6ea2c416d6e0ef6e9a66400fec7ff2af31243cc5" translate="yes" xml:space="preserve">
          <source>A.4.  Example - Unexpected XML Element</source>
          <target state="translated">A.4. 예-예기치 않은 XML 요소</target>
        </trans-unit>
        <trans-unit id="a266ccc4168540071853c8f0598387442256e895" translate="yes" xml:space="preserve">
          <source>A.5.  Conversion of Content-Transfer-Encoding</source>
          <target state="translated">A.5. 콘텐츠 전송 인코딩의 변환</target>
        </trans-unit>
        <trans-unit id="206ee8943d80ea391322bf6e9311cef2b5532423" translate="yes" xml:space="preserve">
          <source>A.6.  MHTML and Line Length Limitations</source>
          <target state="translated">A.6. MHTML 및 줄 길이 제한</target>
        </trans-unit>
        <trans-unit id="b463080c85b05823aaddc6fc68a219f5680ee32b" translate="yes" xml:space="preserve">
          <source>AAC audio</source>
          <target state="translated">AAC 오디오</target>
        </trans-unit>
        <trans-unit id="3ed3e9ef5eed89882da580130970d5049696337c" translate="yes" xml:space="preserve">
          <source>ABNF List Extension: #rule (RFC 7230)</source>
          <target state="translated">ABNF 목록 확장 : #rule (RFC 7230)</target>
        </trans-unit>
        <trans-unit id="ebcd0787537de59613870f2b356e9e9a51dc2254" translate="yes" xml:space="preserve">
          <source>ACCEPT POST</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1588a2512f762c137bb4684cdcc818aa63d0393" translate="yes" xml:space="preserve">
          <source>ALLOW-FROM</source>
          <target state="translated">ALLOW-FROM</target>
        </trans-unit>
        <trans-unit id="5766cf5be7954090e3b573bc2ac357eb125cb979" translate="yes" xml:space="preserve">
          <source>APIs based on HTTP</source>
          <target state="translated">HTTP 기반 API</target>
        </trans-unit>
        <trans-unit id="8ccf350ab0d3a2a51ea1d5c6a29807a0e4f960cf" translate="yes" xml:space="preserve">
          <source>APNG</source>
          <target state="translated">APNG</target>
        </trans-unit>
        <trans-unit id="491f27fea75b26dbfefa2ee1bed63b09db887b09" translate="yes" xml:space="preserve">
          <source>AVI: Audio Video Interleave</source>
          <target state="translated">AVI : 오디오 비디오 인터리브</target>
        </trans-unit>
        <trans-unit id="cd437865cbac7655f8b86519aea764f378093804" translate="yes" xml:space="preserve">
          <source>Abbreviation</source>
          <target state="translated">Abbreviation</target>
        </trans-unit>
        <trans-unit id="24750e2e16dfc2b89dc7f623971f1a084bde0d9a" translate="yes" xml:space="preserve">
          <source>Abstract

   The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level protocol for distributed, collaborative, hypermedia information
   systems.  This document defines the HTTP Authentication framework.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in &lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;Section&amp;nbsp;2 of RFC 5741&lt;/a&gt;.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7235&quot;&gt;http://www.rfc-editor.org/info/rfc7235&lt;/a&gt;.

Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (&lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this 

   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
      &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt;. Conformance and Error Handling 
      &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt;. Syntax Notation 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Access Authentication Framework 
      &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;. Challenge and Response 
      &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt;. Protection Space (Realm) 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Status Code Definitions 
      &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;. 401 Unauthorized 
      &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;. 407 Proxy Authentication Required 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Header Field Definitions 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. WWW-Authenticate 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Authorization 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Proxy-Authenticate 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. Proxy-Authorization 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. Authentication Scheme Registry 
           &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt;. Procedure 
           &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;. Considerations for New Authentication Schemes 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Status Code Registration 
      &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;. Header Field Registration 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Confidentiality of Credentials 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. Authentication Credentials and Idle Clients 
      &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;. Protection Spaces 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Acknowledgments 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. References 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. Changes from RFCs 2616 and 2617 
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. Imported ABNF 
   &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;. Collected ABNF 
   Index .............................................................</source>
          <target state="translated">Abstract HTTP (Hypertext Transfer Protocol)는 분산 된 협업 하이퍼 미디어 정보 시스템을위한 상태 비 저장 응용 프로그램 수준 프로토콜입니다. 이 문서는 HTTP 인증 프레임 워크를 정의합니다. 이 메모의 상태 인터넷 표준 트랙 문서입니다. 이 문서는 IETF (Internet Engineering Task Force)의 제품입니다. IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG (Internet Engineering Steering Group)의 승인을 받았습니다. 인터넷 표준에 대한 추가 정보 &lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;는 RFC 5741의 섹션 2&lt;/a&gt; 에서 제공됩니다 . 이 문서의 현재 상태, 정오표 및 이에 대한 피드백을 제공하는 방법에 대한 정보는 &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7235&quot;&gt; http://www.rfc-editor.org/info/rfc7235 .&lt;/a&gt;. 저작권 공지 Copyright (c) 2014 IETF Trust 및 문서 작성자로 식별 된 사람. 판권 소유. 이 문서는 &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; 및 IETF 문서와 관련된 IETF 트러스트의 법적 조항을 따릅니다 (&lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt; http://trustee.ietf.org/license-info&lt;/a&gt;)는이 문서가 출판 된 날짜에 유효합니다. 이 문서와 관련한 귀하의 권리 및 제한 사항을 설명하는이 문서를주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions 섹션 4.e에 설명 된대로 간체 BSD 라이센스 텍스트를 포함해야하며 간체 BSD 라이센스에 기술 된대로 보증없이 제공됩니다. 이 문서에는 2008 년 11 월 10 일 이전에 출판 또는 공개 된 IETF 문서 또는 IETF 기고서의 자료가 포함될 수 있습니다.이 자료의 일부에 대한 저작권을 관리하는 사람은 해당 자료를 수정할 수있는 권한을 IETF 신뢰에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부.해당 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 취득하지 않으면이 문서는 IETF 표준 프로세스 외부에서 수정 될 수 없으며,이 문서의 형식을 제외하고는 파생 문서를 IETF 표준 프로세스 외부에서 작성할 수 없습니다. RFC로 출판하거나 영어 이외의 언어로 번역 할 수 있습니다. 목차 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; . 소개 &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt; . 적합성 및 오류 처리 &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt; . 구문 표기법 &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; . 액세스 인증 프레임 워크 &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; . 도전과 응답 &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt; . 보호 공간 (Realm) &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; . 상태 코드 정의 &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt; . 401 무단 &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; . 407 프록시 인증 필요 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; . 헤더 필드 정의 &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; . WWW 인증 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . 권한 부여 &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; . 프록시 인증 &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; . 프록시 인증 &lt;a href=&quot;#section-5&quot;&gt; 5&lt;/a&gt;. IANA 고려 사항 &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; . 인증 체계 레지스트리 &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt; . 절차 &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt; . 새로운 인증 체계에 대한 고려 사항 &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; . 상태 코드 등록 &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; . 헤더 필드 등록 &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; . 보안 고려 사항 &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt; . 자격 증명의 기밀성 &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; . 인증 자격 증명 및 유휴 클라이언트 &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; . 보호 공간 &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; . 감사의 글 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; . 참고 자료 &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; . 규범 참조 &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; . 유익한 참고 문헌 &lt;a href=&quot;#appendix-A&quot;&gt;부록 A&lt;/a&gt; . RFC는 2616과 2617에서 변경 &lt;a href=&quot;#appendix-B&quot;&gt;부록 B&lt;/a&gt; . 수입 ABNF &lt;a href=&quot;#appendix-C&quot;&gt;부록 C&lt;/a&gt; . 수집 된 ABNF 지수 ............................................... ..............</target>
        </trans-unit>
        <trans-unit id="b5cf0df594932a60c94f36c291eebcfe03889d61" translate="yes" xml:space="preserve">
          <source>Abstract

   The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level protocol for distributed, collaborative, hypertext information
   systems.  This document defines HTTP caches and the associated header
   fields that control cache behavior or indicate cacheable response
   messages.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in &lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;Section&amp;nbsp;2 of RFC 5741&lt;/a&gt;.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7234&quot;&gt;http://www.rfc-editor.org/info/rfc7234&lt;/a&gt;. 

Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (&lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
      &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt;. Conformance and Error Handling 
      &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt;. Syntax Notation 
           &lt;a href=&quot;#section-1.2.1&quot;&gt;1.2.1&lt;/a&gt;. Delta Seconds 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Overview of Cache Operation 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Storing Responses in Caches 
      &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;. Storing Incomplete Responses 
      &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;. Storing Responses to Authenticated Requests 
      &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;. Combining Partial Content 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Constructing Responses from Caches 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. Calculating Secondary Keys with Vary 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Freshness 
           &lt;a href=&quot;#section-4.2.1&quot;&gt;4.2.1&lt;/a&gt;. Calculating Freshness Lifetime 
           &lt;a href=&quot;#section-4.2.2&quot;&gt;4.2.2&lt;/a&gt;. Calculating Heuristic Freshness 
           &lt;a href=&quot;#section-4.2.3&quot;&gt;4.2.3&lt;/a&gt;. Calculating Age 
           &lt;a href=&quot;#section-4.2.4&quot;&gt;4.2.4&lt;/a&gt;. Serving Stale Responses 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Validation 
           &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt;. Sending a Validation Request 
           &lt;a href=&quot;#section-4.3.2&quot;&gt;4.3.2&lt;/a&gt;. Handling a Received Validation Request ............. 

           &lt;a href=&quot;#section-4.3.3&quot;&gt;4.3.3&lt;/a&gt;. Handling a Validation Response 
           &lt;a href=&quot;#section-4.3.4&quot;&gt;4.3.4&lt;/a&gt;. Freshening Stored Responses upon Validation 
           &lt;a href=&quot;#section-4.3.5&quot;&gt;4.3.5&lt;/a&gt;. Freshening Responses via HEAD 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. Invalidation 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Header Field Definitions 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. Age 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Cache-Control 
           &lt;a href=&quot;#section-5.2.1&quot;&gt;5.2.1&lt;/a&gt;. Request Cache-Control Directives 
           &lt;a href=&quot;#section-5.2.2&quot;&gt;5.2.2&lt;/a&gt;. Response Cache-Control Directives 
           &lt;a href=&quot;#section-5.2.3&quot;&gt;5.2.3&lt;/a&gt;. Cache Control Extensions 
      &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;. Expires 
      &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;. Pragma 
      &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt;. Warning 
           &lt;a href=&quot;#section-5.5.1&quot;&gt;5.5.1&lt;/a&gt;. Warning: 110 - &quot;Response is Stale&quot; 
           &lt;a href=&quot;#section-5.5.2&quot;&gt;5.5.2&lt;/a&gt;. Warning: 111 - &quot;Revalidation Failed&quot; 
           &lt;a href=&quot;#section-5.5.3&quot;&gt;5.5.3&lt;/a&gt;. Warning: 112 - &quot;Disconnected Operation&quot; 
           &lt;a href=&quot;#section-5.5.4&quot;&gt;5.5.4&lt;/a&gt;. Warning: 113 - &quot;Heuristic Expiration&quot; 
           &lt;a href=&quot;#section-5.5.5&quot;&gt;5.5.5&lt;/a&gt;. Warning: 199 - &quot;Miscellaneous Warning&quot; 
           &lt;a href=&quot;#section-5.5.6&quot;&gt;5.5.6&lt;/a&gt;. Warning: 214 - &quot;Transformation Applied&quot; 
           &lt;a href=&quot;#section-5.5.7&quot;&gt;5.5.7&lt;/a&gt;. Warning: 299 - &quot;Miscellaneous Persistent Warning&quot; ..32
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. History Lists 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;. Cache Directive Registry 
           &lt;a href=&quot;#section-7.1.1&quot;&gt;7.1.1&lt;/a&gt;. Procedure 
           &lt;a href=&quot;#section-7.1.2&quot;&gt;7.1.2&lt;/a&gt;. Considerations for New Cache Control Directives 
           &lt;a href=&quot;#section-7.1.3&quot;&gt;7.1.3&lt;/a&gt;. Registrations 
      &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;. Warn Code Registry 
           &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt;. Procedure 
           &lt;a href=&quot;#section-7.2.2&quot;&gt;7.2.2&lt;/a&gt;. Registrations 
      &lt;a href=&quot;#section-7.3&quot;&gt;7.3&lt;/a&gt;. Header Field Registration 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. Security Considerations 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. Acknowledgments 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. References 
      &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;&lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. Imported ABNF 
   &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;. Collected ABNF 
   Index .............................................................</source>
          <target state="translated">Abstract HTTP (Hypertext Transfer Protocol)는 분산 된 협업 하이퍼 텍스트 정보 시스템을위한 상태 비 저장 응용 프로그램 수준 프로토콜입니다. 이 문서는 HTTP 캐시 및 캐시 동작을 제어하거나 캐시 가능한 응답 메시지를 나타내는 관련 헤더 필드를 정의합니다. 이 메모의 상태 인터넷 표준 트랙 문서입니다. 이 문서는 IETF (Internet Engineering Task Force)의 제품입니다. IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG (Internet Engineering Steering Group)의 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용 &lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;은 RFC 5741의 섹션 2&lt;/a&gt; 에서 확인할 수 있습니다.. 이 문서의 현재 상태, 정오표 및 이에 대한 피드백 제공 방법에 대한 정보는 &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7234&quot;&gt;http://www.rfc-editor.org/info/rfc7234&lt;/a&gt; 에서 얻을 수 있습니다 . 저작권 공지 Copyright (c) 2014 IETF Trust 및 문서 작성자로 식별 된 사람. 판권 소유. 이 문서는 &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; 및 IETF 문서와 관련된 IETF 트러스트의 법적 조항 ( &lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt; )의 적용을받습니다.)는이 문서가 출판 된 날짜에 유효합니다. 이 문서와 관련한 귀하의 권리 및 제한 사항을 설명하는이 문서를주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions 섹션 4.e에 설명 된대로 간체 BSD 라이센스 텍스트를 포함해야하며 간체 BSD 라이센스에 기술 된대로 보증없이 제공됩니다. 이 문서에는 2008 년 11 월 10 일 이전에 출판 또는 공개 된 IETF 문서 또는 IETF 기고서의 자료가 포함될 수 있습니다.이 자료의 일부에 대한 저작권을 관리하는 사람은 해당 자료를 수정할 수있는 권한을 IETF 신뢰에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부.해당 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 취득하지 않으면이 문서는 IETF 표준 프로세스 외부에서 수정 될 수 없으며,이 문서의 형식을 제외하고는 파생 문서를 IETF 표준 프로세스 외부에서 작성할 수 없습니다. RFC로 출판하거나 영어 이외의 언어로 번역 할 수 있습니다. 목차 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; . 소개 &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt; . 적합성 및 오류 처리 &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt; . 구문 표기법 &lt;a href=&quot;#section-1.2.1&quot;&gt;1.2.1&lt;/a&gt; . 델타 초 &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; . 캐시 작업 개요 &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; . 캐시에 응답 저장 &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt; . 불완전한 응답 저장 &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; . 인증 된 요청에 응답 저장 &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; . 부분 컨텐츠 결합 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; . 캐시에서 응답 구성 &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; . Vary를 사용하여 2 차 키 계산 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . 신선도 &lt;a href=&quot;#section-4.2.1&quot;&gt;4.2.1&lt;/a&gt; . 신선도 수명 계산 &lt;a href=&quot;#section-4.2.2&quot;&gt; 4.2.2&lt;/a&gt;. 휴리스틱 신선도 계산 &lt;a href=&quot;#section-4.2.3&quot;&gt;4.2.3&lt;/a&gt; . 나이 계산 &lt;a href=&quot;#section-4.2.4&quot;&gt;4.2.4&lt;/a&gt; . 부실 응답 제공 &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; . 검증 &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt; . 유효성 검사 요청 보내기 &lt;a href=&quot;#section-4.3.2&quot;&gt;4.3.2&lt;/a&gt; . 수신 된 확인 요청 처리 ............. &lt;a href=&quot;#section-4.3.3&quot;&gt;4.3.3&lt;/a&gt; . 유효성 검사 응답 처리 &lt;a href=&quot;#section-4.3.4&quot;&gt;4.3.4&lt;/a&gt; . 유효성 검사시 저장된 응답 새로 고침 &lt;a href=&quot;#section-4.3.5&quot;&gt;4.3.5&lt;/a&gt; . HEAD를 통한 청량 응답 &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; . 무효화 &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; . 헤더 필드 정의 &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; . 나이 &lt;a href=&quot;#section-5.2&quot;&gt;5.2 &lt;/a&gt; . 캐시 제어 &lt;a href=&quot;#section-5.2.1&quot;&gt;5.2.1&lt;/a&gt;. 요청 캐시 제어 지시문 &lt;a href=&quot;#section-5.2.2&quot;&gt;5.2.2&lt;/a&gt; . 응답 캐시 제어 지시어 &lt;a href=&quot;#section-5.2.3&quot;&gt;5.2.3&lt;/a&gt; . 캐시 제어 확장 &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; . 만료 &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt; . 프라 그마 &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt; . 경고 &lt;a href=&quot;#section-5.5.1&quot;&gt;5.5.1&lt;/a&gt;&lt;a href=&quot;#section-5.5.3&quot;&gt; 5.5.3&lt;/a&gt; . 경고 : 112- &quot;연결 끊김 작업&quot; &lt;a href=&quot;#section-5.5.4&quot;&gt;5.5.4&lt;/a&gt; . 경고 : &lt;a href=&quot;#section-5.5.5&quot;&gt;113-&lt;/a&gt; &quot;Heuristic Expiration&quot; 5.5.5 . 경고 : 199- &quot;기타 경고&quot; . 경고 : 214- &quot;변환 적용됨&quot; &lt;a href=&quot;#section-5.5.7&quot;&gt;5.5.7&lt;/a&gt;. 경고 : 110- &quot;응답이 오래되었습니다&quot; &lt;a href=&quot;#section-5.5.2&quot;&gt;5.5.2&lt;/a&gt; . 경고 : 111 - &quot;재확인 실패&quot; . 경고 : 299- &quot;기타 지속 경고&quot;..32 &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; . 히스토리 목록 &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; . IANA 고려 사항 &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; . 캐시 지시 레지스트리 &lt;a href=&quot;#section-7.1.1&quot;&gt;7.1.1&lt;/a&gt; . 절차 &lt;a href=&quot;#section-7.1.2&quot;&gt;7.1.2&lt;/a&gt; . 새로운 캐시 제어 지시문에 대한 고려 사항 &lt;a href=&quot;#section-7.1.3&quot;&gt;7.1.3&lt;/a&gt; . 등록 &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt; . 경고 코드 레지스트리 &lt;a href=&quot;#section-7.2.1&quot;&gt;7.2.1&lt;/a&gt; . 절차 &lt;a href=&quot;#section-7.2.2&quot;&gt;7.2.2&lt;/a&gt; . 등록 &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt; . 참조 &lt;a href=&quot;#section-10.1&quot;&gt;10.1 &lt;/a&gt;&lt;a href=&quot;#appendix-A&quot;&gt;부록 A&lt;/a&gt;&lt;a href=&quot;#section-5.5.6&quot;&gt; 5.5.6&lt;/a&gt;&lt;a href=&quot;#section-7.3&quot;&gt; 7.3&lt;/a&gt; . 헤더 필드 등록 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; . 보안 고려 사항 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. 감사의 글 . 규범 참조 &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt; . 유익한 참고 문헌 &lt;a href=&quot;#appendix-B&quot;&gt; 부록 B&lt;/a&gt; . 수입 ABNF &lt;a href=&quot;#appendix-C&quot;&gt;부록 C&lt;/a&gt; . 수집 된 ABNF 지수 ............................................... ............... &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616의&lt;/a&gt; 변경 사항</target>
        </trans-unit>
        <trans-unit id="ccfa8b0f43222ebcd97d708793fc8cc336ca94f7" translate="yes" xml:space="preserve">
          <source>Abstract

   The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level protocol for distributed, collaborative, hypertext information
   systems.  This document defines HTTP/1.1 conditional requests,
   including metadata header fields for indicating state changes,
   request header fields for making preconditions on such state, and
   rules for constructing the responses to a conditional request when
   one or more preconditions evaluate to false.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in &lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;Section&amp;nbsp;2 of RFC 5741&lt;/a&gt;.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7232&quot;&gt;http://www.rfc-editor.org/info/rfc7232&lt;/a&gt;. 

Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (&lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
      &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt;. Conformance and Error Handling 
      &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt;. Syntax Notation 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Validators 
      &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;. Weak versus Strong 
      &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt;. Last-Modified 
           &lt;a href=&quot;#section-2.2.1&quot;&gt;2.2.1&lt;/a&gt;. Generation 
           &lt;a href=&quot;#section-2.2.2&quot;&gt;2.2.2&lt;/a&gt;. Comparison 
      &lt;a href=&quot;#section-2.3&quot;&gt;2.3&lt;/a&gt;. ETag 
           &lt;a href=&quot;#section-2.3.1&quot;&gt;2.3.1&lt;/a&gt;. Generation 
           &lt;a href=&quot;#section-2.3.2&quot;&gt;2.3.2&lt;/a&gt;. Comparison 
           2.3.3. Example: Entity-Tags Varying on
                  Content-Negotiated Resources 
      &lt;a href=&quot;#section-2.4&quot;&gt;2.4&lt;/a&gt;. When to Use Entity-Tags and Last-Modified Dates 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Precondition Header Fields 
      &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;. If-Match 
      &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;. If-None-Match 
      &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;. If-Modified-Since 
      &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt;. If-Unmodified-Since 
      &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt;. If-Range 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Status Code Definitions 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. 304 Not Modified 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. 412 Precondition Failed 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Evaluation 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Precedence 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;. Status Code Registration 
      &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;. Header Field Registration 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. Security Considerations 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. Acknowledgments 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. References 
      &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;&lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. Imported ABNF 
   &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;. Collected ABNF 
   Index .............................................................</source>
          <target state="translated">Abstract HTTP (Hypertext Transfer Protocol)는 분산 된 공동 작업 하이퍼 텍스트 정보 시스템을위한 상태 비 저장 응용 프로그램 수준 프로토콜입니다. 이 문서는 상태 변경을 나타내는 메타 데이터 헤더 필드, 해당 상태에 대한 사전 조건을 만들기위한 요청 헤더 필드 및 하나 이상의 사전 조건이 false로 평가 될 때 조건부 요청에 대한 응답을 구성하는 규칙을 포함하여 HTTP / 1.1 조건부 요청을 정의합니다. 이 메모의 상태 인터넷 표준 트랙 문서입니다. 이 문서는 IETF (Internet Engineering Task Force)의 제품입니다. IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG (Internet Engineering Steering Group)의 승인을 받았습니다.인터넷 표준에 대한 자세한 내용은&lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;RFC 5741의 섹션 2&lt;/a&gt; . 이 문서의 현재 상태, 정오표 및 이에 대한 피드백 제공 방법에 대한 정보는 &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7232&quot;&gt;http://www.rfc-editor.org/info/rfc7232&lt;/a&gt; 에서 얻을 수 있습니다 . 저작권 공지 Copyright (c) 2014 IETF Trust 및 문서 작성자로 식별 된 사람. 판권 소유. 이 문서는 &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78 &lt;/a&gt; 및 IETF 문서와 관련된 IETF 트러스트의 법적 조항을 (&lt;a href=&quot;#section-1&quot;&gt;1의&lt;/a&gt; 적용을받습니다 . 소개 &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt; . 적합성 및 오류 처리 &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt; . 구문 표기법 &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; . 검사기 &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; . 약한 대 강한 &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt; . 최종 수정 &lt;a href=&quot;#section-2.2.1&quot;&gt;2.2.1&lt;/a&gt; . &lt;a href=&quot;#section-2.2.2&quot;&gt;2.2.2&lt;/a&gt; 세대 &lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt; http://trustee.ietf.org/license-info&lt;/a&gt;)는이 문서가 출판 된 날짜에 유효합니다. 이 문서와 관련한 귀하의 권리 및 제한 사항을 설명하는이 문서를주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions 섹션 4.e에 설명 된대로 간체 BSD 라이센스 텍스트를 포함해야하며 간체 BSD 라이센스에 기술 된대로 보증없이 제공됩니다. 이 문서에는 2008 년 11 월 10 일 이전에 출판 또는 공개 된 IETF 문서 또는 IETF 기고서의 자료가 포함될 수 있습니다.이 자료의 일부에 대한 저작권을 관리하는 사람은 해당 자료를 수정할 수있는 권한을 IETF 신뢰에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부.해당 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 취득하지 않으면이 문서는 IETF 표준 프로세스 외부에서 수정 될 수 없으며,이 문서의 형식을 제외하고는 파생 문서를 IETF 표준 프로세스 외부에서 작성할 수 없습니다. RFC로 출판하거나 영어 이외의 언어로 번역 할 수 있습니다. 목차 . 비교 &lt;a href=&quot;#section-2.3&quot;&gt;2.3&lt;/a&gt; . ETag &lt;a href=&quot;#section-2.3.1&quot;&gt;2.3.1&lt;/a&gt; . 세대 &lt;a href=&quot;#section-2.3.2&quot;&gt;2.3.2&lt;/a&gt; . 비교 2.3.3. 예 : 컨텐츠 협상 된 자원에 따라 다른 엔티티 태그 &lt;a href=&quot;#section-2.4&quot;&gt;2.4&lt;/a&gt; . 엔터티 태그 및 최종 수정 날짜를 사용하는시기 &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; . 전제 조건 헤더 필드 &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt; . If-Match &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; . 일치하지 않는 경우 &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; . If-Modified-Since &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt; . 수정되지 않은 경우 &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt; . 경우 범위 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; . 상태 코드 정의 &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; . 304 수정되지 않음 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. 412 사전 조건 실패 &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; . 평가 &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; . 우선 순위 &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; . IANA 고려 사항 &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; . 상태 코드 등록 &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt; . 헤더 필드 등록 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; . 보안 고려 사항 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt; . 감사의 글 &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt; . 참고 자료 &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; . 규범 참조 &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt; . 유익한 참고 문헌 &lt;a href=&quot;#appendix-A&quot;&gt;부록 A&lt;/a&gt; . 에서 변경 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616 &lt;/a&gt;&lt;a href=&quot;#appendix-B&quot;&gt;부록 B&lt;/a&gt; . 수입 ABNF &lt;a href=&quot;#appendix-C&quot;&gt;부록 C&lt;/a&gt; . 수집 된 ABNF 지수 ............................................... ..............</target>
        </trans-unit>
        <trans-unit id="4ab940ed5bb0ef7e467d0859d7a9acd1d3a04f4b" translate="yes" xml:space="preserve">
          <source>Abstract

   The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level protocol for distributed, collaborative, hypertext information
   systems.  This document defines range requests and the rules for
   constructing and combining responses to those requests.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in &lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;Section&amp;nbsp;2 of RFC 5741&lt;/a&gt;.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7233&quot;&gt;http://www.rfc-editor.org/info/rfc7233&lt;/a&gt;. 

Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (&lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
      &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt;. Conformance and Error Handling 
      &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt;. Syntax Notation 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Range Units 
      &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;. Byte Ranges 
      &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt;. Other Range Units 
      &lt;a href=&quot;#section-2.3&quot;&gt;2.3&lt;/a&gt;. Accept-Ranges 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Range Requests 
      &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;. Range 
      &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;. If-Range 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Responses to a Range Request 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. 206 Partial Content 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Content-Range 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Combining Ranges 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. 416 Range Not Satisfiable 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. Range Unit Registry 
           &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt;. Procedure 
           &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;. Registrations 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Status Code Registration 
      &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;. Header Field Registration 
      &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;. Internet Media Type Registration 
           &lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1&lt;/a&gt;. Internet Media Type multipart/byteranges 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Denial-of-Service Attacks Using Range 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Acknowledgments 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. References 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. Internet Media Type multipart/byteranges 
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;&lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;. Imported ABNF 
   &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt;. Collected ABNF 
   Index .............................................................</source>
          <target state="translated">Abstract HTTP (Hypertext Transfer Protocol)는 분산 된 공동 작업 하이퍼 텍스트 정보 시스템을위한 상태 비 저장 응용 프로그램 수준 프로토콜입니다. 이 문서는 범위 요청과 해당 요청에 대한 응답을 구성 및 결합하기위한 규칙을 정의합니다. 이 메모의 상태 인터넷 표준 트랙 문서입니다. 이 문서는 IETF (Internet Engineering Task Force)의 제품입니다. IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG (Internet Engineering Steering Group)의 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은 &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7233&quot;&gt;http://www.rfc-editor.org/info/rfc7233을 참조하십시오.&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt; 은 RFC 5741의 섹션 2&lt;/a&gt; . 이 문서의 현재 상태, 정오표 및 이에 대한 피드백을 제공하는 방법에 대한 정보는 . 저작권 공지 Copyright (c) 2014 IETF Trust 및 문서 작성자로 식별 된 사람. 판권 소유. 이 문서는 &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; 및 IETF 문서와 관련된 IETF 트러스트의 법적 조항을 따릅니다 (&lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt; http://trustee.ietf.org/license-info&lt;/a&gt;)는이 문서가 출판 된 날짜에 유효합니다. 이 문서와 관련한 귀하의 권리 및 제한 사항을 설명하는이 문서를주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions 섹션 4.e에 설명 된대로 간체 BSD 라이센스 텍스트를 포함해야하며 간체 BSD 라이센스에 기술 된대로 보증없이 제공됩니다. 이 문서에는 2008 년 11 월 10 일 이전에 출판 또는 공개 된 IETF 문서 또는 IETF 기고서의 자료가 포함될 수 있습니다.이 자료의 일부에 대한 저작권을 관리하는 사람은 해당 자료를 수정할 수있는 권한을 IETF 신뢰에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부.해당 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 취득하지 않으면이 문서는 IETF 표준 프로세스 외부에서 수정 될 수 없으며,이 문서의 형식을 제외하고는 파생 문서를 IETF 표준 프로세스 외부에서 작성할 수 없습니다. RFC로 출판하거나 영어 이외의 언어로 번역 할 수 있습니다. 목차 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; . 소개 &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt; . 적합성 및 오류 처리 &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt; . 구문 표기법 &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; . 범위 단위 &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; . 바이트 범위 &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt; . 다른 범위 단위 &lt;a href=&quot;#section-2.3&quot;&gt;2.3&lt;/a&gt; . 수락 범위 &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; . 범위 요청 &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt; . 범위 &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; . 경우 범위 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; . 범위 요청에 대한 응답 &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; . 206 일부 내용 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . 내용 범위 &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; . 범위 결합 &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; . 416 범위가 만족스럽지 않음 &lt;a href=&quot;#section-5&quot;&gt;5 &lt;/a&gt; . IANA 고려 사항 &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. 범위 단위 레지스트리 &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt; . 절차 &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt; . 등록 &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; . 상태 코드 등록 &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; . 헤더 필드 등록 &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt; . 인터넷 매체 유형 등록 &lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1&lt;/a&gt; . 인터넷 미디어 유형 멀티 파트 / 바이트 범위 &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; . 보안 고려 사항 &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt; . 범위를 사용한 서비스 거부 공격 &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; . 감사의 글 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; . 참고 자료 &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; . 규범 참조 &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; . 유익한 참고 자료 &lt;a href=&quot;#appendix-A&quot;&gt; 부록 A&lt;/a&gt;. 인터넷 미디어 유형 멀티 파트 / 바이트 범위 &lt;a href=&quot;#appendix-B&quot;&gt;부록 B&lt;/a&gt; . 에서 변경 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616 &lt;/a&gt;&lt;a href=&quot;#appendix-C&quot;&gt;부록 C&lt;/a&gt; . 수입 ABNF &lt;a href=&quot;#appendix-D&quot;&gt;부록 D&lt;/a&gt; . 수집 된 ABNF 지수 ............................................... ..............</target>
        </trans-unit>
        <trans-unit id="175c5b30db7132745dd409dfe5b4fe160db2ec2b" translate="yes" xml:space="preserve">
          <source>Abstract

   The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level protocol for distributed, collaborative, hypertext information
   systems.  This document defines the semantics of HTTP/1.1 messages,
   as expressed by request methods, request header fields, response
   status codes, and response header fields, along with the payload of
   messages (metadata and body content) and mechanisms for content
   negotiation.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in &lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;Section&amp;nbsp;2 of RFC 5741&lt;/a&gt;.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7231&quot;&gt;http://www.rfc-editor.org/info/rfc7231&lt;/a&gt;. 

Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (&lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English. 

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
      &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt;. Conformance and Error Handling 
      &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt;. Syntax Notation 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Resources 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Representations 
      &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;. Representation Metadata 
           &lt;a href=&quot;#section-3.1.1&quot;&gt;3.1.1&lt;/a&gt;. Processing Representation Data 
           &lt;a href=&quot;#section-3.1.2&quot;&gt;3.1.2&lt;/a&gt;. Encoding for Compression or Integrity 
           &lt;a href=&quot;#section-3.1.3&quot;&gt;3.1.3&lt;/a&gt;. Audience Language 
           &lt;a href=&quot;#section-3.1.4&quot;&gt;3.1.4&lt;/a&gt;. Identification 
      &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;. Representation Data 
      &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;. Payload Semantics 
      &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt;. Content Negotiation 
           &lt;a href=&quot;#section-3.4.1&quot;&gt;3.4.1&lt;/a&gt;. Proactive Negotiation 
           &lt;a href=&quot;#section-3.4.2&quot;&gt;3.4.2&lt;/a&gt;. Reactive Negotiation 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Request Methods 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. Overview 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Common Method Properties 
           &lt;a href=&quot;#section-4.2.1&quot;&gt;4.2.1&lt;/a&gt;. Safe Methods 
           &lt;a href=&quot;#section-4.2.2&quot;&gt;4.2.2&lt;/a&gt;. Idempotent Methods 
           &lt;a href=&quot;#section-4.2.3&quot;&gt;4.2.3&lt;/a&gt;. Cacheable Methods 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Method Definitions 
           &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt;. GET 
           &lt;a href=&quot;#section-4.3.2&quot;&gt;4.3.2&lt;/a&gt;. HEAD 
           &lt;a href=&quot;#section-4.3.3&quot;&gt;4.3.3&lt;/a&gt;. POST 
           &lt;a href=&quot;#section-4.3.4&quot;&gt;4.3.4&lt;/a&gt;. PUT 
           &lt;a href=&quot;#section-4.3.5&quot;&gt;4.3.5&lt;/a&gt;. DELETE 
           &lt;a href=&quot;#section-4.3.6&quot;&gt;4.3.6&lt;/a&gt;. CONNECT 
           &lt;a href=&quot;#section-4.3.7&quot;&gt;4.3.7&lt;/a&gt;. OPTIONS 
           &lt;a href=&quot;#section-4.3.8&quot;&gt;4.3.8&lt;/a&gt;. TRACE 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Request Header Fields 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. Controls 
           &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt;. Expect 
           &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;. Max-Forwards 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Conditionals 
      &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;. Content Negotiation 
           &lt;a href=&quot;#section-5.3.1&quot;&gt;5.3.1&lt;/a&gt;. Quality Values 
           &lt;a href=&quot;#section-5.3.2&quot;&gt;5.3.2&lt;/a&gt;. Accept 
           &lt;a href=&quot;#section-5.3.3&quot;&gt;5.3.3&lt;/a&gt;. Accept-Charset 
           &lt;a href=&quot;#section-5.3.4&quot;&gt;5.3.4&lt;/a&gt;. Accept-Encoding 
           &lt;a href=&quot;#section-5.3.5&quot;&gt;5.3.5&lt;/a&gt;. Accept-Language 
      &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;. Authentication Credentials 
      &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt;. Request Context 
           &lt;a href=&quot;#section-5.5.1&quot;&gt;5.5.1&lt;/a&gt;. From 
           &lt;a href=&quot;#section-5.5.2&quot;&gt;5.5.2&lt;/a&gt;. Referer 
           &lt;a href=&quot;#section-5.5.3&quot;&gt;5.5.3&lt;/a&gt;. User-Agent ......................................... 

   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Response Status Codes 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Overview of Status Codes 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. Informational 1xx 
           &lt;a href=&quot;#section-6.2.1&quot;&gt;6.2.1&lt;/a&gt;. 100 Continue 
           &lt;a href=&quot;#section-6.2.2&quot;&gt;6.2.2&lt;/a&gt;. 101 Switching Protocols 
      &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;. Successful 2xx 
           &lt;a href=&quot;#section-6.3.1&quot;&gt;6.3.1&lt;/a&gt;. 200 OK 
           &lt;a href=&quot;#section-6.3.2&quot;&gt;6.3.2&lt;/a&gt;. 201 Created 
           &lt;a href=&quot;#section-6.3.3&quot;&gt;6.3.3&lt;/a&gt;. 202 Accepted 
           &lt;a href=&quot;#section-6.3.4&quot;&gt;6.3.4&lt;/a&gt;. 203 Non-Authoritative Information 
           &lt;a href=&quot;#section-6.3.5&quot;&gt;6.3.5&lt;/a&gt;. 204 No Content 
           &lt;a href=&quot;#section-6.3.6&quot;&gt;6.3.6&lt;/a&gt;. 205 Reset Content 
      &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt;. Redirection 3xx 
           &lt;a href=&quot;#section-6.4.1&quot;&gt;6.4.1&lt;/a&gt;. 300 Multiple Choices 
           &lt;a href=&quot;#section-6.4.2&quot;&gt;6.4.2&lt;/a&gt;. 301 Moved Permanently 
           &lt;a href=&quot;#section-6.4.3&quot;&gt;6.4.3&lt;/a&gt;. 302 Found 
           &lt;a href=&quot;#section-6.4.4&quot;&gt;6.4.4&lt;/a&gt;. 303 See Other 
           &lt;a href=&quot;#section-6.4.5&quot;&gt;6.4.5&lt;/a&gt;. 305 Use Proxy 
           &lt;a href=&quot;#section-6.4.6&quot;&gt;6.4.6&lt;/a&gt;. 306 (Unused) 
           &lt;a href=&quot;#section-6.4.7&quot;&gt;6.4.7&lt;/a&gt;. 307 Temporary Redirect 
      &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt;. Client Error 4xx 
           &lt;a href=&quot;#section-6.5.1&quot;&gt;6.5.1&lt;/a&gt;. 400 Bad Request 
           &lt;a href=&quot;#section-6.5.2&quot;&gt;6.5.2&lt;/a&gt;. 402 Payment Required 
           &lt;a href=&quot;#section-6.5.3&quot;&gt;6.5.3&lt;/a&gt;. 403 Forbidden 
           &lt;a href=&quot;#section-6.5.4&quot;&gt;6.5.4&lt;/a&gt;. 404 Not Found 
           &lt;a href=&quot;#section-6.5.5&quot;&gt;6.5.5&lt;/a&gt;. 405 Method Not Allowed 
           &lt;a href=&quot;#section-6.5.6&quot;&gt;6.5.6&lt;/a&gt;. 406 Not Acceptable 
           &lt;a href=&quot;#section-6.5.7&quot;&gt;6.5.7&lt;/a&gt;. 408 Request Timeout 
           &lt;a href=&quot;#section-6.5.8&quot;&gt;6.5.8&lt;/a&gt;. 409 Conflict 
           &lt;a href=&quot;#section-6.5.9&quot;&gt;6.5.9&lt;/a&gt;. 410 Gone 
           &lt;a href=&quot;#section-6.5.10&quot;&gt;6.5.10&lt;/a&gt;. 411 Length Required 
           &lt;a href=&quot;#section-6.5.11&quot;&gt;6.5.11&lt;/a&gt;. 413 Payload Too Large 
           &lt;a href=&quot;#section-6.5.12&quot;&gt;6.5.12&lt;/a&gt;. 414 URI Too Long 
           &lt;a href=&quot;#section-6.5.13&quot;&gt;6.5.13&lt;/a&gt;. 415 Unsupported Media Type 
           &lt;a href=&quot;#section-6.5.14&quot;&gt;6.5.14&lt;/a&gt;. 417 Expectation Failed 
           &lt;a href=&quot;#section-6.5.15&quot;&gt;6.5.15&lt;/a&gt;. 426 Upgrade Required 
      &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt;. Server Error 5xx 
           &lt;a href=&quot;#section-6.6.1&quot;&gt;6.6.1&lt;/a&gt;. 500 Internal Server Error 
           &lt;a href=&quot;#section-6.6.2&quot;&gt;6.6.2&lt;/a&gt;. 501 Not Implemented 
           &lt;a href=&quot;#section-6.6.3&quot;&gt;6.6.3&lt;/a&gt;. 502 Bad Gateway 
           &lt;a href=&quot;#section-6.6.4&quot;&gt;6.6.4&lt;/a&gt;. 503 Service Unavailable 
           &lt;a href=&quot;#section-6.6.5&quot;&gt;6.6.5&lt;/a&gt;. 504 Gateway Timeout 
           &lt;a href=&quot;#section-6.6.6&quot;&gt;6.6.6&lt;/a&gt;. 505 HTTP Version Not Supported 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Response Header Fields 
      &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt;. Control Data 
ed            7.1.1. Origination Date 
           &lt;a href=&quot;#section-7.1.2&quot;&gt;7.1.2&lt;/a&gt;. Location 
           &lt;a href=&quot;#section-7.1.3&quot;&gt;7.1.3&lt;/a&gt;. Retry-After ........................................ 

           &lt;a href=&quot;#section-7.1.4&quot;&gt;7.1.4&lt;/a&gt;. Vary 
      &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt;. Validator Header Fields 
      &lt;a href=&quot;#section-7.3&quot;&gt;7.3&lt;/a&gt;. Authentication Challenges 
      &lt;a href=&quot;#section-7.4&quot;&gt;7.4&lt;/a&gt;. Response Context 
           &lt;a href=&quot;#section-7.4.1&quot;&gt;7.4.1&lt;/a&gt;. Allow 
           &lt;a href=&quot;#section-7.4.2&quot;&gt;7.4.2&lt;/a&gt;. Server 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Method Registry 
           &lt;a href=&quot;#section-8.1.1&quot;&gt;8.1.1&lt;/a&gt;. Procedure 
           &lt;a href=&quot;#section-8.1.2&quot;&gt;8.1.2&lt;/a&gt;. Considerations for New Methods 
           &lt;a href=&quot;#section-8.1.3&quot;&gt;8.1.3&lt;/a&gt;. Registrations 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Status Code Registry 
           &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt;. Procedure 
           &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt;. Considerations for New Status Codes 
           &lt;a href=&quot;#section-8.2.3&quot;&gt;8.2.3&lt;/a&gt;. Registrations 
      &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;. Header Field Registry 
           &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;. Considerations for New Header Fields 
           &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt;. Registrations 
      &lt;a href=&quot;#section-8.4&quot;&gt;8.4&lt;/a&gt;. Content Coding Registry 
           &lt;a href=&quot;#section-8.4.1&quot;&gt;8.4.1&lt;/a&gt;. Procedure 
           &lt;a href=&quot;#section-8.4.2&quot;&gt;8.4.2&lt;/a&gt;. Registrations 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;. Attacks Based on File and Path Names 
      &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;. Attacks Based on Command, Code, or Query Injection 
      &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;. Disclosure of Personal Information 
      &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;. Disclosure of Sensitive Information in URIs 
      &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;. Disclosure of Fragment after Redirects 
      &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;. Disclosure of Product Information 
      &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;. Browser Fingerprinting 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. Acknowledgments 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;. References 
      &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. Differences between HTTP and MIME 
      &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1&lt;/a&gt;. MIME-Version 
      &lt;a href=&quot;#appendix-A.2&quot;&gt;A.2&lt;/a&gt;. Conversion to Canonical Form 
      &lt;a href=&quot;#appendix-A.3&quot;&gt;A.3&lt;/a&gt;. Conversion of Date Formats 
      &lt;a href=&quot;#appendix-A.4&quot;&gt;A.4&lt;/a&gt;. Conversion of Content-Encoding 
      &lt;a href=&quot;#appendix-A.5&quot;&gt;A.5&lt;/a&gt;. Conversion of Content-Transfer-Encoding 
      &lt;a href=&quot;#appendix-A.6&quot;&gt;A.6&lt;/a&gt;. MHTML and Line Length Limitations 
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;&lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;. Imported ABNF 
   &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt;. Collected ABNF 
   Index .............................................................</source>
          <target state="translated">Abstract HTTP (Hypertext Transfer Protocol)는 분산 된 공동 작업 하이퍼 텍스트 정보 시스템을위한 상태 비 저장 응용 프로그램 수준 프로토콜입니다. 이 문서는 요청 페이로드 (메타 데이터 및 본문 내용) 및 내용 협상 메커니즘과 함께 요청 방법, 요청 헤더 필드, 응답 상태 코드 및 응답 헤더 필드로 표현 된 HTTP / 1.1 메시지의 의미를 정의합니다. 이 메모의 상태 인터넷 표준 트랙 문서입니다. 이 문서는 IETF (Internet Engineering Task Force)의 제품입니다. IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG (Internet Engineering Steering Group)의 승인을 받았습니다. 인터넷 표준에 대한 자세한 내용은&lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;RFC 5741의 섹션 2&lt;/a&gt; . 이 문서의 현재 상태, 정오표 및 이에 대한 피드백 제공 방법에 대한 정보는 &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7231&quot;&gt;http://www.rfc-editor.org/info/rfc7231&lt;/a&gt; 에서 얻을 수 있습니다 . 저작권 공지 Copyright (c) 2014 IETF Trust 및 문서 작성자로 식별 된 사람. 판권 소유. 이 문서는 &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; 및 IETF 문서와 관련된 IETF 트러스트의 법적 조항을 따릅니다 (&lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt; http://trustee.ietf.org/license-info&lt;/a&gt;)는이 문서가 출판 된 날짜에 유효합니다. 이 문서와 관련한 귀하의 권리 및 제한 사항을 설명하는이 문서를주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions 섹션 4.e에 설명 된대로 간체 BSD 라이센스 텍스트를 포함해야하며 간체 BSD 라이센스에 기술 된대로 보증없이 제공됩니다. 이 문서에는 2008 년 11 월 10 일 이전에 출판 또는 공개 된 IETF 문서 또는 IETF 기고서의 자료가 포함될 수 있습니다.이 자료의 일부에 대한 저작권을 관리하는 사람은 해당 자료를 수정할 수있는 권한을 IETF 신뢰에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부.해당 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 취득하지 않으면이 문서는 IETF 표준 프로세스 외부에서 수정 될 수 없으며,이 문서의 형식을 제외하고는 파생 문서를 IETF 표준 프로세스 외부에서 작성할 수 없습니다. RFC로 출판하거나 영어 이외의 언어로 번역 할 수 있습니다. 목차 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; . 소개 &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt; . 적합성 및 오류 처리 &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt; . 구문 표기법 &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; . 자원 &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; . 표현 &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt; . 표현 메타 데이터 &lt;a href=&quot;#section-3.1.1&quot;&gt;3.1.1&lt;/a&gt; . 표현 데이터 처리 &lt;a href=&quot;#section-3.1.2&quot;&gt;3.1.2&lt;/a&gt; . 압축 또는 무결성을위한 인코딩 &lt;a href=&quot;#section-3.1.3&quot;&gt;3.1.3&lt;/a&gt; . 관객 언어 &lt;a href=&quot;#section-3.1.4&quot;&gt;3.1.4&lt;/a&gt; . 식별 &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; . 대표 데이터 &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; . 페이로드 의미론 &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt; . 내용 협상 &lt;a href=&quot;#section-3.4.1&quot;&gt;3.4.1 &lt;/a&gt; . 사전 협상 &lt;a href=&quot;#section-3.4.2&quot;&gt;3.4.2&lt;/a&gt;. 반응성 협상 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; . 요청 방법 &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; . 개요 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . 일반적인 분석법 속성 &lt;a href=&quot;#section-4.2.1&quot;&gt;4.2.1&lt;/a&gt; . 안전한 방법 &lt;a href=&quot;#section-4.2.2&quot;&gt;4.2.2&lt;/a&gt; . dem 등식 방법 &lt;a href=&quot;#section-4.2.3&quot;&gt;4.2.3&lt;/a&gt; . 캐시 가능한 방법 &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; . 방법 정의 &lt;a href=&quot;#section-4.3.1&quot;&gt;4.3.1&lt;/a&gt; . GET &lt;a href=&quot;#section-4.3.2&quot;&gt;4.3.2&lt;/a&gt; . 헤드 &lt;a href=&quot;#section-4.3.3&quot;&gt;4.3.3&lt;/a&gt; . POST &lt;a href=&quot;#section-4.3.4&quot;&gt;4.3.4&lt;/a&gt; . PUT &lt;a href=&quot;#section-4.3.5&quot;&gt;4.3.5&lt;/a&gt; . 삭제 &lt;a href=&quot;#section-4.3.6&quot;&gt;4.3.6&lt;/a&gt; . 연결 &lt;a href=&quot;#section-4.3.7&quot;&gt;4.3.7&lt;/a&gt; . 옵션 &lt;a href=&quot;#section-4.3.8&quot;&gt; 4.3.8&lt;/a&gt;. 트랙 &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. 요청 헤더 필드 &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt; . 컨트롤 &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt; . 기대 &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt; . 최대 포워드 &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; . 조건부 &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; . 내용 협상 &lt;a href=&quot;#section-5.3.1&quot;&gt;5.3.1&lt;/a&gt; . 질 가치 &lt;a href=&quot;#section-5.3.2&quot;&gt;5.3.2&lt;/a&gt; . 동의 &lt;a href=&quot;#section-5.3.3&quot;&gt;5.3.3&lt;/a&gt; . 수락-문자셋 &lt;a href=&quot;#section-5.3.4&quot;&gt;5.3.4&lt;/a&gt; . 수락 인코딩 &lt;a href=&quot;#section-5.3.5&quot;&gt;5.3.5&lt;/a&gt; . 수락 언어 &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt; . 인증 자격 증명 &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt; . 요청 문맥 &lt;a href=&quot;#section-5.5.1&quot;&gt;5.5.1&lt;/a&gt; . 에서 &lt;a href=&quot;#section-5.5.2&quot;&gt; 5.5.2&lt;/a&gt;. 레퍼러 &lt;a href=&quot;#section-5.5.3&quot;&gt;5.5.3&lt;/a&gt;. User-Agent ...................................................... &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; . 응답 상태 코드 &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt; . 상태 코드 개요 &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; . 정보 용 1xx &lt;a href=&quot;#section-6.2.1&quot;&gt;6.2.1&lt;/a&gt; . 100 계속 &lt;a href=&quot;#section-6.2.2&quot;&gt;6.2.2&lt;/a&gt; . 101 스위칭 프로토콜 &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; . 성공적인 2xx &lt;a href=&quot;#section-6.3.1&quot;&gt;6.3.1&lt;/a&gt; . 200 OK &lt;a href=&quot;#section-6.3.2&quot;&gt;6.3.2&lt;/a&gt; . 201 생성됨 &lt;a href=&quot;#section-6.3.3&quot;&gt;6.3.3&lt;/a&gt; . 202 허용 &lt;a href=&quot;#section-6.3.4&quot;&gt;6.3.4&lt;/a&gt; . 203 비 권한 정보 &lt;a href=&quot;#section-6.3.5&quot;&gt;6.3.5&lt;/a&gt; . 204 내용 없음 &lt;a href=&quot;#section-6.3.6&quot;&gt;6.3.6&lt;/a&gt; . 205 콘텐츠 재설정 &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt; . 리디렉션 3xx &lt;a href=&quot;#section-6.4.1&quot;&gt;6.4.1&lt;/a&gt; . 300 객관식 선택 &lt;a href=&quot;#section-6.4.2&quot;&gt;6.4.2&lt;/a&gt; . 301 영구 이동 &lt;a href=&quot;#section-6.4.3&quot;&gt;6.4.3&lt;/a&gt; . 302 발견 &lt;a href=&quot;#section-6.4.4&quot;&gt;6.4.4&lt;/a&gt; . 303 기타 &lt;a href=&quot;#section-6.4.5&quot;&gt;6.4.5&lt;/a&gt; 참조 . 305 프록시 사용 &lt;a href=&quot;#section-6.4.6&quot;&gt;6.4.6&lt;/a&gt; . 306 (사용하지 않음) &lt;a href=&quot;#section-6.4.7&quot;&gt;6.4.7&lt;/a&gt; . 307 임시 리디렉션 &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt; . 클라이언트 오류 4xx &lt;a href=&quot;#section-6.5.1&quot;&gt;6.5.1&lt;/a&gt; . 400 잘못된 요청 &lt;a href=&quot;#section-6.5.2&quot;&gt;6.5.2&lt;/a&gt; . 402 지불 필요 &lt;a href=&quot;#section-6.5.3&quot;&gt;6.5.3&lt;/a&gt; . 403 금지됨 &lt;a href=&quot;#section-6.5.4&quot;&gt;6.5.4&lt;/a&gt; . 404 찾을 수 없음 &lt;a href=&quot;#section-6.5.5&quot;&gt;6.5.5&lt;/a&gt; . 405 메소드가 허용되지 않습니다 &lt;a href=&quot;#section-6.5.6&quot;&gt;6.5.6&lt;/a&gt; . 406 허용되지 않음 &lt;a href=&quot;#section-6.5.7&quot;&gt;6.5.7&lt;/a&gt;&lt;a href=&quot;#section-6.6.3&quot;&gt; 6.6.3&lt;/a&gt;. 408 요청 시간 초과 &lt;a href=&quot;#section-6.5.8&quot;&gt;6.5.8&lt;/a&gt; . 409 충돌 &lt;a href=&quot;#section-6.5.9&quot;&gt;6.5.9&lt;/a&gt; . 410 사라짐 &lt;a href=&quot;#section-6.5.10&quot;&gt;6.5.10&lt;/a&gt; . 411 필요한 길이 &lt;a href=&quot;#section-6.5.11&quot;&gt;6.5.11&lt;/a&gt; . 413 페이로드가 너무 큼 &lt;a href=&quot;#section-6.5.12&quot;&gt;6.5.12&lt;/a&gt; . 414 URI가 너무 길다 &lt;a href=&quot;#section-6.5.13&quot;&gt;6.5.13&lt;/a&gt; . 415 지원되지 않는 미디어 유형 &lt;a href=&quot;#section-6.5.14&quot;&gt;6.5.14&lt;/a&gt; . 417 예상 실패 &lt;a href=&quot;#section-6.5.15&quot;&gt;6.5.15&lt;/a&gt; . 426 업그레이드 필요 &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt; . 서버 오류 5xx &lt;a href=&quot;#section-6.6.1&quot;&gt;6.6.1&lt;/a&gt; . 500 내부 서버 오류 &lt;a href=&quot;#section-6.6.2&quot;&gt;6.6.2&lt;/a&gt; . 501 구현되지 않음 . 502 나쁜 게이트웨이 &lt;a href=&quot;#section-6.6.4&quot;&gt;6.6.4&lt;/a&gt;. 503 서비스를 이용할 수 없음 &lt;a href=&quot;#section-6.6.5&quot;&gt;6.6.5&lt;/a&gt; . 504 게이트웨이 시간 초과 &lt;a href=&quot;#section-6.6.6&quot;&gt;6.6.6&lt;/a&gt; . 505 HTTP 버전이 지원되지 않음 &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; . 응답 헤더 필드 &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; . 제어 데이터 ed 7.1.1. 시작 날짜 &lt;a href=&quot;#section-7.1.2&quot;&gt;7.1.2&lt;/a&gt; . 위치 &lt;a href=&quot;#section-7.1.3&quot;&gt;7.1.3&lt;/a&gt; . 재시도 후 ........................................ &lt;a href=&quot;#section-7.1.4&quot;&gt;7.1.4&lt;/a&gt; . 다름 &lt;a href=&quot;#section-7.2&quot;&gt;7.2&lt;/a&gt; . 검증기 헤더 필드 &lt;a href=&quot;#section-7.3&quot;&gt;7.3&lt;/a&gt; . 인증 문제 &lt;a href=&quot;#section-7.4&quot;&gt;7.4&lt;/a&gt; . 응답 문맥 &lt;a href=&quot;#section-7.4.1&quot;&gt;7.4.1&lt;/a&gt; . 허용 &lt;a href=&quot;#section-7.4.2&quot;&gt; 7.4.2&lt;/a&gt;. 서버 &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; . IANA 고려 사항 &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; . 메소드 레지스트리 &lt;a href=&quot;#section-8.1.1&quot;&gt;8.1.1&lt;/a&gt; . 절차 &lt;a href=&quot;#section-8.1.2&quot;&gt;8.1.2&lt;/a&gt; . 새로운 방법에 대한 고려 사항 &lt;a href=&quot;#section-8.1.3&quot;&gt;8.1.3&lt;/a&gt; . 등록 &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; . 상태 코드 레지스트리 &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt; . 절차 &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt; . 새로운 상태 코드에 대한 고려 사항 &lt;a href=&quot;#section-8.2.3&quot;&gt;8.2.3&lt;/a&gt; . 등록 &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt; . 헤더 필드 레지스트리 &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt; . 새 헤더 필드에 대한 고려 사항 &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt; . 등록 &lt;a href=&quot;#section-8.4&quot;&gt;8.4 &lt;/a&gt; . 콘텐츠 코딩 레지스트리 &lt;a href=&quot;#section-8.4.1&quot;&gt;8.4.1&lt;/a&gt; . 절차 &lt;a href=&quot;#section-8.4.2&quot;&gt;8.4.2&lt;/a&gt; . 등록 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. 보안 고려 사항 &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; . 파일 및 경로 이름에 따른 공격 &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt; . 명령, 코드 또는 쿼리 삽입 기반 공격 &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt; . 개인 정보 공개 &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt; . URI에 민감한 정보 공개 &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt; . 리디렉션 후의 조각 공개 &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt; . 제품 정보 공개 &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt; . 브라우저 핑거 프린팅 &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt; . 감사의 말 &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt; . 참조 &lt;a href=&quot;#section-11.1&quot;&gt;11.1 &lt;/a&gt; . 규범 참조 &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt; . 유익한 참고 문헌 &lt;a href=&quot;#appendix-A&quot;&gt;부록 A&lt;/a&gt; . HTTP와 MIME &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1의&lt;/a&gt; 차이점 . MIME 버전 &lt;a href=&quot;#appendix-A.2&quot;&gt;A.2&lt;/a&gt; . 정식 형태로의 변환 &lt;a href=&quot;#appendix-A.3&quot;&gt;A.3&lt;/a&gt; . 날짜 형식 변환 &lt;a href=&quot;#appendix-A.4&quot;&gt;A.4&lt;/a&gt; . 콘텐츠 인코딩 변환 &lt;a href=&quot;#appendix-A.5&quot;&gt;A.5&lt;/a&gt; . 콘텐츠 전송 인코딩의 변환 &lt;a href=&quot;#appendix-A.6&quot;&gt;A.6&lt;/a&gt; . MHTML 및 라인 길이 제한 &lt;a href=&quot;#appendix-B&quot;&gt;부록 B&lt;/a&gt; . 에서 변경 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616 &lt;/a&gt;&lt;a href=&quot;#appendix-C&quot;&gt;부록 C&lt;/a&gt; . 수입 ABNF &lt;a href=&quot;#appendix-D&quot;&gt;부록 D&lt;/a&gt; . 수집 된 ABNF 지수 ............................................... ..............</target>
        </trans-unit>
        <trans-unit id="40af3a9e68d967dfc1ebb5c1482c0bb1ee2a2de4" translate="yes" xml:space="preserve">
          <source>Abstract

   The Hypertext Transfer Protocol (HTTP) is a stateless application-
   level protocol for distributed, collaborative, hypertext information
   systems.  This document provides an overview of HTTP architecture and
   its associated terminology, defines the &quot;http&quot; and &quot;https&quot; Uniform
   Resource Identifier (URI) schemes, defines the HTTP/1.1 message
   syntax and parsing requirements, and describes related security
   concerns for implementations.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in &lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;Section&amp;nbsp;2 of RFC 5741&lt;/a&gt;.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7230&quot;&gt;http://www.rfc-editor.org/info/rfc7230&lt;/a&gt;. 

Copyright Notice

   Copyright (c) 2014 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (&lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

   This document may contain material from IETF Documents or IETF
   Contributions published or made publicly available before November
   10, 2008.  The person(s) controlling the copyright in some of this
   material may not have granted the IETF Trust the right to allow
   modifications of such material outside the IETF Standards Process.
   Without obtaining an adequate license from the person(s) controlling
   the copyright in such materials, this document may not be modified
   outside the IETF Standards Process, and derivative works of it may
   not be created outside the IETF Standards Process, except to format
   it for publication as an RFC or to translate it into languages other
   than English.

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
      &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt;. Requirements Notation 
      &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt;. Syntax Notation 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. Architecture 
      &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;. Client/Server Messaging 
      &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt;. Implementation Diversity 
      &lt;a href=&quot;#section-2.3&quot;&gt;2.3&lt;/a&gt;. Intermediaries 
      &lt;a href=&quot;#section-2.4&quot;&gt;2.4&lt;/a&gt;. Caches 
      &lt;a href=&quot;#section-2.5&quot;&gt;2.5&lt;/a&gt;. Conformance and Error Handling 
      &lt;a href=&quot;#section-2.6&quot;&gt;2.6&lt;/a&gt;. Protocol Versioning 
      &lt;a href=&quot;#section-2.7&quot;&gt;2.7&lt;/a&gt;. Uniform Resource Identifiers 
           &lt;a href=&quot;#section-2.7.1&quot;&gt;2.7.1&lt;/a&gt;. http URI Scheme 
           &lt;a href=&quot;#section-2.7.2&quot;&gt;2.7.2&lt;/a&gt;. https URI Scheme 
           &lt;a href=&quot;#section-2.7.3&quot;&gt;2.7.3&lt;/a&gt;. http and https URI Normalization and Comparison 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Message Format 
      &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;. Start Line 
           &lt;a href=&quot;#section-3.1.1&quot;&gt;3.1.1&lt;/a&gt;. Request Line 
           &lt;a href=&quot;#section-3.1.2&quot;&gt;3.1.2&lt;/a&gt;. Status Line 
      &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;. Header Fields ............................................. 

           &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;. Field Extensibility 
           &lt;a href=&quot;#section-3.2.2&quot;&gt;3.2.2&lt;/a&gt;. Field Order 
           &lt;a href=&quot;#section-3.2.3&quot;&gt;3.2.3&lt;/a&gt;. Whitespace 
           &lt;a href=&quot;#section-3.2.4&quot;&gt;3.2.4&lt;/a&gt;. Field Parsing 
           &lt;a href=&quot;#section-3.2.5&quot;&gt;3.2.5&lt;/a&gt;. Field Limits 
           &lt;a href=&quot;#section-3.2.6&quot;&gt;3.2.6&lt;/a&gt;. Field Value Components 
      &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;. Message Body 
           &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt;. Transfer-Encoding 
           &lt;a href=&quot;#section-3.3.2&quot;&gt;3.3.2&lt;/a&gt;. Content-Length 
           &lt;a href=&quot;#section-3.3.3&quot;&gt;3.3.3&lt;/a&gt;. Message Body Length 
      &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt;. Handling Incomplete Messages 
      &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt;. Message Parsing Robustness 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. Transfer Codings 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. Chunked Transfer Coding 
           &lt;a href=&quot;#section-4.1.1&quot;&gt;4.1.1&lt;/a&gt;. Chunk Extensions 
           &lt;a href=&quot;#section-4.1.2&quot;&gt;4.1.2&lt;/a&gt;. Chunked Trailer Part 
           &lt;a href=&quot;#section-4.1.3&quot;&gt;4.1.3&lt;/a&gt;. Decoding Chunked 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Compression Codings 
           &lt;a href=&quot;#section-4.2.1&quot;&gt;4.2.1&lt;/a&gt;. Compress Coding 
           &lt;a href=&quot;#section-4.2.2&quot;&gt;4.2.2&lt;/a&gt;. Deflate Coding 
           &lt;a href=&quot;#section-4.2.3&quot;&gt;4.2.3&lt;/a&gt;. Gzip Coding 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. TE 
      &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt;. Trailer 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Message Routing 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. Identifying a Target Resource 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Connecting Inbound 
      &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;. Request Target 
           &lt;a href=&quot;#section-5.3.1&quot;&gt;5.3.1&lt;/a&gt;. origin-form 
           &lt;a href=&quot;#section-5.3.2&quot;&gt;5.3.2&lt;/a&gt;. absolute-form 
           &lt;a href=&quot;#section-5.3.3&quot;&gt;5.3.3&lt;/a&gt;. authority-form 
           &lt;a href=&quot;#section-5.3.4&quot;&gt;5.3.4&lt;/a&gt;. asterisk-form 
      &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;. Host 
      &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt;. Effective Request URI 
      &lt;a href=&quot;#section-5.6&quot;&gt;5.6&lt;/a&gt;. Associating a Response to a Request 
      &lt;a href=&quot;#section-5.7&quot;&gt;5.7&lt;/a&gt;. Message Forwarding 
           &lt;a href=&quot;#section-5.7.1&quot;&gt;5.7.1&lt;/a&gt;. Via 
           &lt;a href=&quot;#section-5.7.2&quot;&gt;5.7.2&lt;/a&gt;. Transformations 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Connection Management 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. Connection 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. Establishment 
      &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;. Persistence 
           &lt;a href=&quot;#section-6.3.1&quot;&gt;6.3.1&lt;/a&gt;. Retrying Requests 
           &lt;a href=&quot;#section-6.3.2&quot;&gt;6.3.2&lt;/a&gt;. Pipelining 
      &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt;. Concurrency 
      &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt;. Failures and Timeouts 
      &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt;. Tear-down 
      &lt;a href=&quot;#section-6.7&quot;&gt;6.7&lt;/a&gt;. Upgrade 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. ABNF List Extension: #rule ..................................... 

   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. Header Field Registration 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. URI Scheme Registration 
      &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;. Internet Media Type Registration 
           &lt;a href=&quot;#section-8.3.1&quot;&gt;8.3.1&lt;/a&gt;. Internet Media Type message/http 
           &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt;. Internet Media Type application/http 
      &lt;a href=&quot;#section-8.4&quot;&gt;8.4&lt;/a&gt;. Transfer Coding Registry 
           &lt;a href=&quot;#section-8.4.1&quot;&gt;8.4.1&lt;/a&gt;. Procedure 
           &lt;a href=&quot;#section-8.4.2&quot;&gt;8.4.2&lt;/a&gt;. Registration 
      &lt;a href=&quot;#section-8.5&quot;&gt;8.5&lt;/a&gt;. Content Coding Registration 
      &lt;a href=&quot;#section-8.6&quot;&gt;8.6&lt;/a&gt;. Upgrade Token Registry 
           &lt;a href=&quot;#section-8.6.1&quot;&gt;8.6.1&lt;/a&gt;. Procedure 
           &lt;a href=&quot;#section-8.6.2&quot;&gt;8.6.2&lt;/a&gt;. Upgrade Token Registration 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;. Establishing Authority 
      &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;. Risks of Intermediaries 
      &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt;. Attacks via Protocol Element Length 
      &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt;. Response Splitting 
      &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt;. Request Smuggling 
      &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt;. Message Integrity 
      &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt;. Message Confidentiality 
      &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt;. Privacy of Server Log Information 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. Acknowledgments 
   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;. References 
      &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. HTTP Version History 
      &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1&lt;/a&gt;. Changes from HTTP/1.0  
           &lt;a href=&quot;#appendix-A.1.1&quot;&gt;A.1.1&lt;/a&gt;.  Multihomed Web Servers 
           &lt;a href=&quot;#appendix-A.1.2&quot;&gt;A.1.2&lt;/a&gt;.  Keep-Alive Connections 
           &lt;a href=&quot;#appendix-A.1.3&quot;&gt;A.1.3&lt;/a&gt;.  Introduction of Transfer-Encoding 
      &lt;a href=&quot;#appendix-A.2&quot;&gt;A.2&lt;/a&gt;.  Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;&lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;. Collected ABNF 
   Index .............................................................</source>
          <target state="translated">Abstract HTTP (Hypertext Transfer Protocol)는 분산 된 공동 작업 하이퍼 텍스트 정보 시스템을위한 상태 비 저장 응용 프로그램 수준 프로토콜입니다. 이 문서는 HTTP 아키텍처 및 관련 용어에 대한 개요를 제공하고, &quot;http&quot;및 &quot;https&quot;URI (Uniform Resource Identifier) ​​체계를 정의하고 HTTP / 1.1 메시지 구문 및 구문 분석 요구 사항을 정의하며 구현에 대한 관련 보안 문제를 설명합니다. 이 메모의 상태 인터넷 표준 트랙 문서입니다. 이 문서는 IETF (Internet Engineering Task Force)의 제품입니다. IETF 커뮤니티의 합의를 나타냅니다. 공개 검토를 받았으며 IESG (Internet Engineering Steering Group)의 승인을 받았습니다.인터넷 표준에 대한 자세한 내용은&lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;RFC 5741의 섹션 2&lt;/a&gt; . 이 문서의 현재 상태, 정오표 및 이에 대한 피드백 제공 방법에 대한 정보는 &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7230&quot;&gt;http://www.rfc-editor.org/info/rfc7230&lt;/a&gt; 에서 얻을 수 있습니다 . 저작권 공지 Copyright (c) 2014 IETF Trust 및 문서 작성자로 식별 된 사람. 판권 소유. 이 문서는 &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; 및 IETF 문서와 관련된 IETF 트러스트의 법적 조항을 따릅니다 (&lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt; http://trustee.ietf.org/license-info&lt;/a&gt;)는이 문서가 출판 된 날짜에 유효합니다. 이 문서와 관련한 귀하의 권리 및 제한 사항을 설명하는이 문서를주의 깊게 검토하십시오. 이 문서에서 추출한 코드 구성 요소는 Trust Legal Provisions 섹션 4.e에 설명 된대로 간체 BSD 라이센스 텍스트를 포함해야하며 간체 BSD 라이센스에 기술 된대로 보증없이 제공됩니다. 이 문서에는 2008 년 11 월 10 일 이전에 출판 또는 공개 된 IETF 문서 또는 IETF 기고서의 자료가 포함될 수 있습니다.이 자료의 일부에 대한 저작권을 관리하는 사람은 해당 자료를 수정할 수있는 권한을 IETF 신뢰에 부여하지 않았을 수 있습니다. IETF 표준 프로세스 외부.해당 자료의 저작권을 관리하는 사람으로부터 적절한 라이센스를 취득하지 않으면이 문서는 IETF 표준 프로세스 외부에서 수정 될 수 없으며,이 문서의 형식을 제외하고는 파생 문서를 IETF 표준 프로세스 외부에서 작성할 수 없습니다. RFC로 출판하거나 영어 이외의 언어로 번역 할 수 있습니다. 목차 &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt; . 소개 &lt;a href=&quot;#section-1.1&quot;&gt;1.1&lt;/a&gt; . 요구 사항 표기법 &lt;a href=&quot;#section-1.2&quot;&gt;1.2&lt;/a&gt; . 구문 표기법 &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt; . 아키텍처 &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; . 클라이언트 / 서버 메시징 &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt; . 구현 다양성 &lt;a href=&quot;#section-2.3&quot;&gt;2.3&lt;/a&gt; . 중개자 &lt;a href=&quot;#section-2.4&quot;&gt;2.4&lt;/a&gt; . 캐시 &lt;a href=&quot;#section-2.5&quot;&gt;2.5&lt;/a&gt; . 적합성 및 오류 처리 &lt;a href=&quot;#section-2.6&quot;&gt;2.6&lt;/a&gt; . 프로토콜 버전 관리 &lt;a href=&quot;#section-2.7&quot;&gt;2.7&lt;/a&gt; . 균일 한 자원 식별자 &lt;a href=&quot;#section-2.7.1&quot;&gt;2.7.1&lt;/a&gt; . http URI 스킴 &lt;a href=&quot;#section-2.7.2&quot;&gt;2.7.2&lt;/a&gt; . https URI 스킴 &lt;a href=&quot;#section-2.7.3&quot;&gt;2.7.3&lt;/a&gt; . http 및 https URI 정규화 및 비교 &lt;a href=&quot;#section-3&quot;&gt; 3&lt;/a&gt;. 메시지 형식 &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt; . &lt;a href=&quot;#section-3.1.1&quot;&gt;3.1.1&lt;/a&gt; 행을 시작하십시오 . 요청 라인 &lt;a href=&quot;#section-3.1.2&quot;&gt;3.1.2&lt;/a&gt; . 상태 표시 줄 &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt; . 헤더 필드 ............................................. &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt; . 분야 확장 성 &lt;a href=&quot;#section-3.2.2&quot;&gt;3.2.2&lt;/a&gt; . 현장 주문 &lt;a href=&quot;#section-3.2.3&quot;&gt;3.2.3&lt;/a&gt; . 공백 &lt;a href=&quot;#section-3.2.4&quot;&gt;3.2.4&lt;/a&gt; . 필드 파싱 &lt;a href=&quot;#section-3.2.5&quot;&gt;3.2.5&lt;/a&gt; . 필드 한계 &lt;a href=&quot;#section-3.2.6&quot;&gt;3.2.6&lt;/a&gt; . 필드 값 구성 요소 &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; . 메시지 본문 &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1&lt;/a&gt; . 전송 인코딩 &lt;a href=&quot;#section-3.3.2&quot;&gt;3.3.2&lt;/a&gt; . 콘텐츠 길이 &lt;a href=&quot;#section-3.3.3&quot;&gt; 3.3.3&lt;/a&gt;. 메시지 본문 길이 &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt; . 불완전한 메시지 처리 &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt; . 메시지 파싱 견고성 &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt; . 전송 코딩 &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt; . 청크 전송 코드 &lt;a href=&quot;#section-4.1.1&quot;&gt;4.1.1&lt;/a&gt; . 청크 확장 &lt;a href=&quot;#section-4.1.2&quot;&gt;4.1.2&lt;/a&gt; . 청크 트레일러 파트 &lt;a href=&quot;#section-4.1.3&quot;&gt;4.1.3&lt;/a&gt; . 청크 디코딩 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . 압축 코딩 &lt;a href=&quot;#section-4.2.1&quot;&gt;4.2.1&lt;/a&gt; . 압축 코딩 &lt;a href=&quot;#section-4.2.2&quot;&gt;4.2.2&lt;/a&gt; . 코딩 수축 &lt;a href=&quot;#section-4.2.3&quot;&gt;4.2.3&lt;/a&gt; . Gzip 코딩 &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; . TE &lt;a href=&quot;#section-4.4&quot;&gt;4.4&lt;/a&gt; . 트레일러 &lt;a href=&quot;#section-5&quot;&gt;5 &lt;/a&gt; . 메시지 라우팅 &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. 대상 자원 식별 &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt; . 인바운드 연결 &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt; . 요청 목표 &lt;a href=&quot;#section-5.3.1&quot;&gt;5.3.1&lt;/a&gt; . 원산지 양식 &lt;a href=&quot;#section-5.3.2&quot;&gt;5.3.2&lt;/a&gt; . 절대 형식 &lt;a href=&quot;#section-5.3.3&quot;&gt;5.3.3&lt;/a&gt; . 권한 양식 &lt;a href=&quot;#section-5.3.4&quot;&gt;5.3.4&lt;/a&gt; . 별표 형태 &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt; . 호스트 &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt; . 효과적인 요청 URI &lt;a href=&quot;#section-5.6&quot;&gt;5.6&lt;/a&gt; . 응답을 요청에 연결 &lt;a href=&quot;#section-5.7&quot;&gt;5.7&lt;/a&gt; . 메시지 전달 &lt;a href=&quot;#section-5.7.1&quot;&gt;5.7.1&lt;/a&gt; . &lt;a href=&quot;#section-5.7.2&quot;&gt;5.7.2를&lt;/a&gt; 통해 . 변환 &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt; . 연결 관리 &lt;a href=&quot;#section-6.1&quot;&gt; 6.1&lt;/a&gt;. 연결 &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. 설립 &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; . 지속성 &lt;a href=&quot;#section-6.3.1&quot;&gt;6.3.1&lt;/a&gt; . 요청 재시도 &lt;a href=&quot;#section-6.3.2&quot;&gt;6.3.2&lt;/a&gt; . 파이프 라이닝 &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt; . 동시성 &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt; . 실패와 타임 아웃 &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt; . 인열 &lt;a href=&quot;#section-6.7&quot;&gt;6.7&lt;/a&gt; . 업그레이드 &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt; . ABNF 목록 확장자 : #rule ..................................... &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt; . IANA 고려 사항 &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt; . 헤더 필드 등록 &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; . URI 스킴 등록 &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt; . 인터넷 미디어 유형 등록 &lt;a href=&quot;#section-8.3.1&quot;&gt; 8.3.1&lt;/a&gt;. 인터넷 미디어 유형 메시지 / http &lt;a href=&quot;#section-8.3.2&quot;&gt;8.3.2&lt;/a&gt; . 인터넷 미디어 유형 응용 프로그램 / http &lt;a href=&quot;#section-8.4&quot;&gt;8.4&lt;/a&gt; . 전송 코딩 레지스트리 &lt;a href=&quot;#section-8.4.1&quot;&gt;8.4.1&lt;/a&gt; . 절차 &lt;a href=&quot;#section-8.4.2&quot;&gt;8.4.2&lt;/a&gt; . 등록 &lt;a href=&quot;#section-8.5&quot;&gt;8.5&lt;/a&gt; . 콘텐츠 코딩 등록 &lt;a href=&quot;#section-8.6&quot;&gt;8.6&lt;/a&gt; . 업그레이드 토큰 레지스트리 &lt;a href=&quot;#section-8.6.1&quot;&gt;8.6.1&lt;/a&gt; . 절차 &lt;a href=&quot;#section-8.6.2&quot;&gt;8.6.2&lt;/a&gt; . 업그레이드 토큰 등록 &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt; . 보안 고려 사항 &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt; . 권한 설정 &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt; . 중개인의 위험 &lt;a href=&quot;#section-9.3&quot;&gt;9.3&lt;/a&gt; . 프로토콜 요소 길이 &lt;a href=&quot;#section-9.4&quot;&gt;9.4&lt;/a&gt; 를 통한 공격 . 응답 분할 &lt;a href=&quot;#section-9.5&quot;&gt;9.5&lt;/a&gt; . 밀수 요청 &lt;a href=&quot;#section-9.6&quot;&gt;9.6&lt;/a&gt; . 메시지 무결성 &lt;a href=&quot;#section-9.7&quot;&gt;9.7&lt;/a&gt; . 메시지 기밀성 &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt; . 서버 로그 정보의 프라이버시 &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt; . 감사의 말 &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt; . 참고 자료 &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt; . 규범 참조 &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt; . 유익한 참고 문헌 &lt;a href=&quot;#appendix-A&quot;&gt;부록 A&lt;/a&gt; . HTTP 버전 기록 &lt;a href=&quot;#appendix-A.1&quot;&gt;A.1&lt;/a&gt; . HTTP / 1.0에서 변경 &lt;a href=&quot;#appendix-A.1.1&quot;&gt;A.1.1&lt;/a&gt; . 멀티 홈 웹 서버 &lt;a href=&quot;#appendix-A.1.2&quot;&gt;A.1.2&lt;/a&gt; . 연결 유지 &lt;a href=&quot;#appendix-A.1.3&quot;&gt;A.1.3&lt;/a&gt; . 전송 인코딩 소개 &lt;a href=&quot;#appendix-A.2&quot;&gt; A.2&lt;/a&gt; . &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616 &lt;/a&gt;&lt;a href=&quot;#appendix-B&quot;&gt;부록 B의&lt;/a&gt; 변경 사항. 수집 된 ABNF 지수 ............................................... ..............</target>
        </trans-unit>
        <trans-unit id="169ce4ffcc45df2dca538209a9b8308901d5a3b7" translate="yes" xml:space="preserve">
          <source>Abstract

   This specification describes an optimized expression of the semantics
   of the Hypertext Transfer Protocol (HTTP), referred to as HTTP
   version 2 (HTTP/2).  HTTP/2 enables a more efficient use of network
   resources and a reduced perception of latency by introducing header
   field compression and allowing multiple concurrent exchanges on the
   same connection.  It also introduces unsolicited push of
   representations from servers to clients.

   This specification is an alternative to, but does not obsolete, the
   HTTP/1.1 message syntax.  HTTP's existing semantics remain unchanged.

Status of This Memo

   This is an Internet Standards Track document.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Further information on
   Internet Standards is available in &lt;a href=&quot;https://tools.ietf.org/html/rfc5741#section-2&quot;&gt;Section&amp;nbsp;2 of RFC 5741&lt;/a&gt;.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   &lt;a href=&quot;http://www.rfc-editor.org/info/rfc7540&quot;&gt;http://www.rfc-editor.org/info/rfc7540&lt;/a&gt;. 

Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (&lt;a href=&quot;http://trustee.ietf.org/license-info&quot;&gt;http://trustee.ietf.org/license-info&lt;/a&gt;) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   &lt;a href=&quot;#section-1&quot;&gt;1&lt;/a&gt;. Introduction 
   &lt;a href=&quot;#section-2&quot;&gt;2&lt;/a&gt;. HTTP/2 Protocol Overview 
      &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt;. Document Organization 
      &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt;. Conventions and Terminology 
   &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt;. Starting HTTP/2 
      &lt;a href=&quot;#section-3.1&quot;&gt;3.1&lt;/a&gt;. HTTP/2 Version Identification 
      &lt;a href=&quot;#section-3.2&quot;&gt;3.2&lt;/a&gt;. Starting HTTP/2 for &quot;http&quot; URIs 
           &lt;a href=&quot;#section-3.2.1&quot;&gt;3.2.1&lt;/a&gt;. HTTP2-Settings Header Field 
      &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;. Starting HTTP/2 for &quot;https&quot; URIs 
      &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt;. Starting HTTP/2 with Prior Knowledge 
      &lt;a href=&quot;#section-3.5&quot;&gt;3.5&lt;/a&gt;. HTTP/2 Connection Preface 
   &lt;a href=&quot;#section-4&quot;&gt;4&lt;/a&gt;. HTTP Frames 
      &lt;a href=&quot;#section-4.1&quot;&gt;4.1&lt;/a&gt;. Frame Format 
      &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;. Frame Size 
      &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;. Header Compression and Decompression 
   &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt;. Streams and Multiplexing 
      &lt;a href=&quot;#section-5.1&quot;&gt;5.1&lt;/a&gt;. Stream States 
           &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1&lt;/a&gt;. Stream Identifiers 
           &lt;a href=&quot;#section-5.1.2&quot;&gt;5.1.2&lt;/a&gt;. Stream Concurrency 
      &lt;a href=&quot;#section-5.2&quot;&gt;5.2&lt;/a&gt;. Flow Control 
           &lt;a href=&quot;#section-5.2.1&quot;&gt;5.2.1&lt;/a&gt;. Flow-Control Principles 
           &lt;a href=&quot;#section-5.2.2&quot;&gt;5.2.2&lt;/a&gt;. Appropriate Use of Flow Control 
      &lt;a href=&quot;#section-5.3&quot;&gt;5.3&lt;/a&gt;. Stream Priority 
           &lt;a href=&quot;#section-5.3.1&quot;&gt;5.3.1&lt;/a&gt;. Stream Dependencies 
           &lt;a href=&quot;#section-5.3.2&quot;&gt;5.3.2&lt;/a&gt;. Dependency Weighting 
           &lt;a href=&quot;#section-5.3.3&quot;&gt;5.3.3&lt;/a&gt;. Reprioritization 
           &lt;a href=&quot;#section-5.3.4&quot;&gt;5.3.4&lt;/a&gt;. Prioritization State Management 
           &lt;a href=&quot;#section-5.3.5&quot;&gt;5.3.5&lt;/a&gt;. Default Priorities 
      &lt;a href=&quot;#section-5.4&quot;&gt;5.4&lt;/a&gt;. Error Handling 
           &lt;a href=&quot;#section-5.4.1&quot;&gt;5.4.1&lt;/a&gt;. Connection Error Handling 
           &lt;a href=&quot;#section-5.4.2&quot;&gt;5.4.2&lt;/a&gt;. Stream Error Handling .............................. 

           &lt;a href=&quot;#section-5.4.3&quot;&gt;5.4.3&lt;/a&gt;. Connection Termination 
      &lt;a href=&quot;#section-5.5&quot;&gt;5.5&lt;/a&gt;. Extending HTTP/2 
   &lt;a href=&quot;#section-6&quot;&gt;6&lt;/a&gt;. Frame Definitions 
      &lt;a href=&quot;#section-6.1&quot;&gt;6.1&lt;/a&gt;. DATA 
      &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt;. HEADERS 
      &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt;. PRIORITY 
      &lt;a href=&quot;#section-6.4&quot;&gt;6.4&lt;/a&gt;. RST_STREAM 
      &lt;a href=&quot;#section-6.5&quot;&gt;6.5&lt;/a&gt;. SETTINGS 
           &lt;a href=&quot;#section-6.5.1&quot;&gt;6.5.1&lt;/a&gt;. SETTINGS Format 
           &lt;a href=&quot;#section-6.5.2&quot;&gt;6.5.2&lt;/a&gt;. Defined SETTINGS Parameters 
           &lt;a href=&quot;#section-6.5.3&quot;&gt;6.5.3&lt;/a&gt;. Settings Synchronization 
      &lt;a href=&quot;#section-6.6&quot;&gt;6.6&lt;/a&gt;. PUSH_PROMISE 
      &lt;a href=&quot;#section-6.7&quot;&gt;6.7&lt;/a&gt;. PING 
      &lt;a href=&quot;#section-6.8&quot;&gt;6.8&lt;/a&gt;. GOAWAY 
      &lt;a href=&quot;#section-6.9&quot;&gt;6.9&lt;/a&gt;. WINDOW_UPDATE 
           &lt;a href=&quot;#section-6.9.1&quot;&gt;6.9.1&lt;/a&gt;. The Flow-Control Window 
           &lt;a href=&quot;#section-6.9.2&quot;&gt;6.9.2&lt;/a&gt;. Initial Flow-Control Window Size 
           &lt;a href=&quot;#section-6.9.3&quot;&gt;6.9.3&lt;/a&gt;. Reducing the Stream Window Size 
      &lt;a href=&quot;#section-6.10&quot;&gt;6.10&lt;/a&gt;. CONTINUATION 
   &lt;a href=&quot;#section-7&quot;&gt;7&lt;/a&gt;. Error Codes 
   &lt;a href=&quot;#section-8&quot;&gt;8&lt;/a&gt;. HTTP Message Exchanges 
      &lt;a href=&quot;#section-8.1&quot;&gt;8.1&lt;/a&gt;. HTTP Request/Response Exchange 
           &lt;a href=&quot;#section-8.1.1&quot;&gt;8.1.1&lt;/a&gt;. Upgrading from HTTP/2 
           &lt;a href=&quot;#section-8.1.2&quot;&gt;8.1.2&lt;/a&gt;. HTTP Header Fields 
           &lt;a href=&quot;#section-8.1.3&quot;&gt;8.1.3&lt;/a&gt;. Examples 
           &lt;a href=&quot;#section-8.1.4&quot;&gt;8.1.4&lt;/a&gt;. Request Reliability Mechanisms in HTTP/2 
      &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;. Server Push 
           &lt;a href=&quot;#section-8.2.1&quot;&gt;8.2.1&lt;/a&gt;. Push Requests 
           &lt;a href=&quot;#section-8.2.2&quot;&gt;8.2.2&lt;/a&gt;. Push Responses 
      &lt;a href=&quot;#section-8.3&quot;&gt;8.3&lt;/a&gt;. The CONNECT Method 
   &lt;a href=&quot;#section-9&quot;&gt;9&lt;/a&gt;. Additional HTTP Requirements/Considerations 
      &lt;a href=&quot;#section-9.1&quot;&gt;9.1&lt;/a&gt;. Connection Management 
           &lt;a href=&quot;#section-9.1.1&quot;&gt;9.1.1&lt;/a&gt;. Connection Reuse 
           &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;. The 421 (Misdirected Request) Status Code 
      &lt;a href=&quot;#section-9.2&quot;&gt;9.2&lt;/a&gt;. Use of TLS Features 
           &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;. TLS 1.2 Features 
           &lt;a href=&quot;#section-9.2.2&quot;&gt;9.2.2&lt;/a&gt;. TLS 1.2 Cipher Suites 
   &lt;a href=&quot;#section-10&quot;&gt;10&lt;/a&gt;. Security Considerations 
      &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt;. Server Authority 
      &lt;a href=&quot;#section-10.2&quot;&gt;10.2&lt;/a&gt;. Cross-Protocol Attacks 
      &lt;a href=&quot;#section-10.3&quot;&gt;10.3&lt;/a&gt;. Intermediary Encapsulation Attacks 
      &lt;a href=&quot;#section-10.4&quot;&gt;10.4&lt;/a&gt;. Cacheability of Pushed Responses 
      &lt;a href=&quot;#section-10.5&quot;&gt;10.5&lt;/a&gt;. Denial-of-Service Considerations 
           &lt;a href=&quot;#section-10.5.1&quot;&gt;10.5.1&lt;/a&gt;. Limits on Header Block Size 
           &lt;a href=&quot;#section-10.5.2&quot;&gt;10.5.2&lt;/a&gt;. CONNECT Issues 
      &lt;a href=&quot;#section-10.6&quot;&gt;10.6&lt;/a&gt;. Use of Compression 
      &lt;a href=&quot;#section-10.7&quot;&gt;10.7&lt;/a&gt;. Use of Padding 
      &lt;a href=&quot;#section-10.8&quot;&gt;10.8&lt;/a&gt;. Privacy Considerations ................................... 

   &lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt;. IANA Considerations 
      &lt;a href=&quot;#section-11.1&quot;&gt;11.1&lt;/a&gt;. Registration of HTTP/2 Identification Strings 
      &lt;a href=&quot;#section-11.2&quot;&gt;11.2&lt;/a&gt;. Frame Type Registry 
      &lt;a href=&quot;#section-11.3&quot;&gt;11.3&lt;/a&gt;. Settings Registry 
      &lt;a href=&quot;#section-11.4&quot;&gt;11.4&lt;/a&gt;. Error Code Registry 
      &lt;a href=&quot;#section-11.5&quot;&gt;11.5&lt;/a&gt;. HTTP2-Settings Header Field Registration 
      &lt;a href=&quot;#section-11.6&quot;&gt;11.6&lt;/a&gt;. PRI Method Registration 
      &lt;a href=&quot;#section-11.7&quot;&gt;11.7&lt;/a&gt;. The 421 (Misdirected Request) HTTP Status Code 
      &lt;a href=&quot;#section-11.8&quot;&gt;11.8&lt;/a&gt;. The h2c Upgrade Token 
   &lt;a href=&quot;#section-12&quot;&gt;12&lt;/a&gt;. References 
      &lt;a href=&quot;#section-12.1&quot;&gt;12.1&lt;/a&gt;. Normative References 
      &lt;a href=&quot;#section-12.2&quot;&gt;12.2&lt;/a&gt;. Informative References 
   &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;. TLS 1.2 Cipher Suite Black List 
   Acknowledgements 
   Authors' Addresses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="088fbdf0be09f2b57f797db06f694f1729caf35d" translate="yes" xml:space="preserve">
          <source>Accelerometer</source>
          <target state="translated">Accelerometer</target>
        </trans-unit>
        <trans-unit id="4a6020ab1c5517bd5d30e781beba5515f12cafd7" translate="yes" xml:space="preserve">
          <source>Accelerometer&lt;br/&gt;&lt;small&gt;The definition of 'Accelerometer' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb54db510a92908a5a4df79fc1ad1eae8df50ec3" translate="yes" xml:space="preserve">
          <source>Accept</source>
          <target state="translated">Accept</target>
        </trans-unit>
        <trans-unit id="87fbce3fda446208ef2acea7678d689afb9f87e9" translate="yes" xml:space="preserve">
          <source>Accept (RFC 2616)</source>
          <target state="translated">수락 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="0dcc20ef513587031d3a72165f89c3586e57c7de" translate="yes" xml:space="preserve">
          <source>Accept (RFC 7231)</source>
          <target state="translated">수락 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="4e7eb8a9e22a94e3c88a689612ab6a2a6f4c8e4f" translate="yes" xml:space="preserve">
          <source>Accept request-headers can reveal information about the user to all
   servers which are accessed. The Accept-Language header in particular
   can reveal information the user would consider to be of a private
   nature, because the understanding of particular languages is often 

   strongly correlated to the membership of a particular ethnic group.
   User agents which offer the option to configure the contents of an
   Accept-Language header to be sent in every request are strongly
   encouraged to let the configuration process include a message which
   makes the user aware of the loss of privacy involved.

   An approach that limits the loss of privacy would be for a user agent
   to omit the sending of Accept-Language headers by default, and to ask
   the user whether or not to start sending Accept-Language headers to a
   server if it detects, by looking for any Vary response-header fields
   generated by the server, that such sending could improve the quality
   of service.

   Elaborate user-customized accept header fields sent in every request,
   in particular if these include quality values, can be used by servers
   as relatively reliable and long-lived user identifiers. Such user
   identifiers would allow content providers to do click-trail tracking,
   and would allow collaborating content providers to match cross-server
   click-trails or form submissions of individual users. Note that for
   many users not behind a proxy, the network address of the host
   running the user agent will also serve as a long-lived user
   identifier. In environments where proxies are used to enhance
   privacy, user agents ought to be conservative in offering accept
   header configuration options to end users. As an extreme privacy
   measure, proxies could filter the accept headers in relayed requests.
   General purpose user agents which provide a high degree of header
   configurability SHOULD warn users about the loss of privacy which can
   be involved.</source>
          <target state="translated">수락 요청 헤더는 사용자에 대한 정보를 액세스하는 모든 서버에 공개 할 수 있습니다. 특히 Accept-Language 헤더는 특정 언어에 대한 이해가 종종 특정 민족 그룹의 멤버십과 밀접한 관련이 있기 때문에 사용자가 사적인 성격으로 생각하는 정보를 공개 할 수 있습니다. 모든 요청에서 전송되도록 Accept-Language 헤더의 내용을 구성하는 옵션을 제공하는 사용자 에이전트는 구성 프로세스에 관련 개인 정보의 손실을 사용자에게 알리는 메시지가 포함되도록하는 것이 좋습니다. 프라이버시 손실을 제한하는 접근 방식은 사용자 에이전트가 기본적으로 Accept-Language 헤더 전송을 생략하는 것입니다.서버에 의해 생성 된 Vary 응답 헤더 필드를 찾아서 그러한 전송이 서비스 품질을 향상시킬 수 있음을 탐지하면 Accept-Language 헤더를 서버에 보내기 시작하는지 여부를 사용자에게 묻습니다. 모든 요청에서 전송되는 정교한 사용자 정의 수락 헤더 필드, 특히 품질 값이 포함 된 경우 서버는 비교적 신뢰할 수 있고 수명이 긴 사용자 식별자로 서버에서 사용할 수 있습니다. 이러한 사용자 식별자는 컨텐츠 제공자가 클릭 트레일 추적을 수행 할 수있게하며 협업 컨텐츠 제공자가 서버 간 클릭 트레일을 일치 시키거나 개별 사용자의 제출을 ​​형성 할 수 있도록합니다. 프록시 뒤에 있지 않은 많은 사용자의 경우, 사용자 에이전트를 실행하는 호스트의 네트워크 주소도 오래 지속되는 사용자 식별자로 사용됩니다.프라이버시를 향상시키기 위해 프록시가 사용되는 환경에서, 사용자 에이전트는 최종 사용자에게 헤더 구성 옵션을 제공하는 데 보수적이어야합니다. 극단적 인 개인 정보 보호 조치로서 프록시는 릴레이 된 요청에서 수락 헤더를 필터링 할 수 있습니다. 높은 수준의 헤더 구성 기능을 제공하는 범용 사용자 에이전트는 관련 될 수있는 개인 정보의 손실에 대해 사용자에게 경고해야합니다.</target>
        </trans-unit>
        <trans-unit id="cbf7652dda9b574ee3d8fa9ba1a981f6e580b50c" translate="yes" xml:space="preserve">
          <source>Accept-CH</source>
          <target state="translated">Accept-CH</target>
        </trans-unit>
        <trans-unit id="36d96a263709e34be5a5041f8061f37f18742f90" translate="yes" xml:space="preserve">
          <source>Accept-CH-Lifetime</source>
          <target state="translated">Accept-CH-Lifetime</target>
        </trans-unit>
        <trans-unit id="aaf67685a1d81108695f45293bf84f12a0c9cb46" translate="yes" xml:space="preserve">
          <source>Accept-Charset</source>
          <target state="translated">Accept-Charset</target>
        </trans-unit>
        <trans-unit id="1eb70f6fb0b92415ec54f2514f66fef0477c9d03" translate="yes" xml:space="preserve">
          <source>Accept-Charset (RFC 2616)</source>
          <target state="translated">수락 문자 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="d46e62b664d44c5c0ad50b6fbfcf9b7ffd34c78f" translate="yes" xml:space="preserve">
          <source>Accept-Charset (RFC 7231)</source>
          <target state="translated">수락 문자 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="05a25bf4449549e9b5ee96afc9f36857b37fc6e8" translate="yes" xml:space="preserve">
          <source>Accept-Charset is no more</source>
          <target state="translated">Accept-Charset은 더 이상 없습니다</target>
        </trans-unit>
        <trans-unit id="177429157553dbb71c8bab30aac57a62d268cc1c" translate="yes" xml:space="preserve">
          <source>Accept-Encoding</source>
          <target state="translated">Accept-Encoding</target>
        </trans-unit>
        <trans-unit id="a80413a74e8c6a5ee7628707c28264f5fc57f11c" translate="yes" xml:space="preserve">
          <source>Accept-Encoding (RFC 2616)</source>
          <target state="translated">수락 인코딩 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="d76f042c2a36b8346c52df9cd05152e174c68474" translate="yes" xml:space="preserve">
          <source>Accept-Encoding (RFC 7231)</source>
          <target state="translated">수락 인코딩 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="58385b3fba0471cb7c233041f9d15c4b6ccf18fe" translate="yes" xml:space="preserve">
          <source>Accept-Language</source>
          <target state="translated">Accept-Language</target>
        </trans-unit>
        <trans-unit id="8a194a37a0fab016d1dac628a2d4a8bdc2847fc0" translate="yes" xml:space="preserve">
          <source>Accept-Language (RFC 2616)</source>
          <target state="translated">수락 언어 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="6a5d4a129ec209d245a79d6c3f2edfdd87668589" translate="yes" xml:space="preserve">
          <source>Accept-Language (RFC 7231)</source>
          <target state="translated">수락 언어 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="ea739811444a8e5f6504b6782269b732b928cc75" translate="yes" xml:space="preserve">
          <source>Accept-Patch</source>
          <target state="translated">Accept-Patch</target>
        </trans-unit>
        <trans-unit id="e22e9df1bfaf7e154b76461094ccdcabf7952070" translate="yes" xml:space="preserve">
          <source>Accept-Post</source>
          <target state="translated">Accept-Post</target>
        </trans-unit>
        <trans-unit id="02910fe72aef1e79d1ce552b0125fe9d6e734463" translate="yes" xml:space="preserve">
          <source>Accept-Ranges</source>
          <target state="translated">Accept-Ranges</target>
        </trans-unit>
        <trans-unit id="0e716e0e0b978d47436d93b491a16aeaac22f9e5" translate="yes" xml:space="preserve">
          <source>Accept-Ranges (RFC 2616)</source>
          <target state="translated">수락 범위 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="764a440a698a17aa1dc774708163b405c87ff4bd" translate="yes" xml:space="preserve">
          <source>Accept-Ranges (RFC 7233)</source>
          <target state="translated">수락 범위 (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="bc19e40eb87eca9ddb4a92e3a97c67ee6143d7d5" translate="yes" xml:space="preserve">
          <source>Access Authentication (RFC 2616)</source>
          <target state="translated">액세스 인증 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="6a77d7667269bf6db4712e4162088af68dbec9fc" translate="yes" xml:space="preserve">
          <source>Access Authentication Framework (RFC 7235)</source>
          <target state="translated">액세스 인증 프레임 워크 (RFC 7235)</target>
        </trans-unit>
        <trans-unit id="c22573ef8df23292ff057255b9a28b1bea0f5bec" translate="yes" xml:space="preserve">
          <source>Access control is a security technique that can be used to regulate who or what can view or use resources in a computing environment.</source>
          <target state="translated">액세스 제어는 컴퓨팅 환경에서 리소스를 보거나 사용할 수있는 사람 또는 대상을 규제하는 데 사용할 수있는 보안 기술입니다.</target>
        </trans-unit>
        <trans-unit id="f81413e1c5136d3c3d54929c9e2b0c8e7144bc04" translate="yes" xml:space="preserve">
          <source>Access control systems perform &lt;a href=&quot;http://searchsoftwarequality.techtarget.com/definition/authorization&quot;&gt;authorization&lt;/a&gt; identification, &lt;a href=&quot;http://searchsecurity.techtarget.com/definition/authentication&quot;&gt;authentication&lt;/a&gt;, access approval, and accountability of entities through login credentials including &lt;a href=&quot;http://searchsecurity.techtarget.com/definition/password&quot;&gt;passwords&lt;/a&gt;, personal identification numbers (PINs), &lt;a href=&quot;http://searchsecurity.techtarget.com/definition/biometrics&quot;&gt;biometric&lt;/a&gt; scans, and physical or electronic keys.</source>
          <target state="translated">액세스 제어 시스템 은 &lt;a href=&quot;http://searchsecurity.techtarget.com/definition/password&quot;&gt;비밀번호&lt;/a&gt; , PIN (개인 식별 번호), &lt;a href=&quot;http://searchsecurity.techtarget.com/definition/biometrics&quot;&gt;생체&lt;/a&gt; 검색 및 물리적 또는 전자 키를 포함한 로그인 자격 증명을 통해 &lt;a href=&quot;http://searchsoftwarequality.techtarget.com/definition/authorization&quot;&gt;권한 부여&lt;/a&gt; 식별, &lt;a href=&quot;http://searchsecurity.techtarget.com/definition/authentication&quot;&gt;인증&lt;/a&gt; , 액세스 승인 및 엔티티의 책임을 수행 합니다.</target>
        </trans-unit>
        <trans-unit id="d810350110ab0e795aa4da0b30363f0a9f966603" translate="yes" xml:space="preserve">
          <source>Access forbidden</source>
          <target state="translated">액세스 금지</target>
        </trans-unit>
        <trans-unit id="80c707124192246c159bfaa608d8114812340fa4" translate="yes" xml:space="preserve">
          <source>Access using credentials in the URL</source>
          <target state="translated">URL에서 자격 증명을 사용하여 액세스</target>
        </trans-unit>
        <trans-unit id="09fbec75ee860af401feca052767eb8d2119fc55" translate="yes" xml:space="preserve">
          <source>Access-Control-Allow-Credentials</source>
          <target state="translated">Access-Control-Allow-Credentials</target>
        </trans-unit>
        <trans-unit id="2d66b46792a018ad2020282cc416e9ee8f06f861" translate="yes" xml:space="preserve">
          <source>Access-Control-Allow-Headers</source>
          <target state="translated">Access-Control-Allow-Headers</target>
        </trans-unit>
        <trans-unit id="2a2a0c7e0ef78c7c6bd13f7ae4ec973cd75d4f40" translate="yes" xml:space="preserve">
          <source>Access-Control-Allow-Methods</source>
          <target state="translated">Access-Control-Allow-Methods</target>
        </trans-unit>
        <trans-unit id="c4f2dafa374f61f543d5c6c14d4bdbb5b6456db0" translate="yes" xml:space="preserve">
          <source>Access-Control-Allow-Origin</source>
          <target state="translated">Access-Control-Allow-Origin</target>
        </trans-unit>
        <trans-unit id="313ef5554833c1d023f8841fd3ca07c129f4dabb" translate="yes" xml:space="preserve">
          <source>Access-Control-Expose-Headers</source>
          <target state="translated">Access-Control-Expose-Headers</target>
        </trans-unit>
        <trans-unit id="4196525184a54a54617a46e60664f7d0e4576b20" translate="yes" xml:space="preserve">
          <source>Access-Control-Max-Age</source>
          <target state="translated">Access-Control-Max-Age</target>
        </trans-unit>
        <trans-unit id="19e900248599e307979b6e63f1848ccf43a39cde" translate="yes" xml:space="preserve">
          <source>Access-Control-Request-Headers</source>
          <target state="translated">Access-Control-Request-Headers</target>
        </trans-unit>
        <trans-unit id="95705e26c9fe99470c7ef1269a9e4c14d288b849" translate="yes" xml:space="preserve">
          <source>Access-Control-Request-Method</source>
          <target state="translated">Access-Control-Request-Method</target>
        </trans-unit>
        <trans-unit id="07e4b36adfd07ceb756a5d56381f00df21670fde" translate="yes" xml:space="preserve">
          <source>Add Android version to Fennec UA String (bug 1169772)</source>
          <target state="translated">Fennec UA String에 안드로이드 버전 추가 (버그 1169772)</target>
        </trans-unit>
        <trans-unit id="3858ee0b1cf51a7d707eae259a28585eabdbec88" translate="yes" xml:space="preserve">
          <source>Add the following line to the Web.config file to send the &lt;code&gt;Public-Key-Pins&lt;/code&gt; header:</source>
          <target state="translated">Web.config 파일에 다음 줄을 추가하여 &lt;code&gt;Public-Key-Pins&lt;/code&gt; 헤더 를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="87343a4ec44d6166bd6139504ce40cd88c57d49d" translate="yes" xml:space="preserve">
          <source>Added &lt;code&gt;frame-src&lt;/code&gt;, &lt;code&gt;manifest-src&lt;/code&gt; and &lt;code&gt;worker-src&lt;/code&gt; as defaults.</source>
          <target state="translated">추가 &lt;code&gt;frame-src&lt;/code&gt; , &lt;code&gt;manifest-src&lt;/code&gt; 와 &lt;code&gt;worker-src&lt;/code&gt; 기본값으로.</target>
        </trans-unit>
        <trans-unit id="760223db38df00fd781c0887ee7e1f480b28b1c4" translate="yes" xml:space="preserve">
          <source>Added by a proxy if it applies any transformation to the representation, such as changing the content-coding, media-type or the like.</source>
          <target state="translated">컨텐츠 코딩, 미디어 유형 등을 변경하는 등 표현에 변환을 적용하는 경우 프록시에 의해 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1f6aba7e1c260b1e97306b61055dc5586e639243" translate="yes" xml:space="preserve">
          <source>Added by proxies, both forward and reverse proxies, and can appear in the request headers and the response headers.</source>
          <target state="translated">정방향 및 역방향 프록시 모두 프록시에 의해 추가되며 요청 헤더 및 응답 헤더에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6b68b9b3bb4cdd89081228b70979f9dc4741b29" translate="yes" xml:space="preserve">
          <source>Adding a line similar to the following to your webserver's config will enable HPKP on your Apache. This requires &lt;code&gt;mod_headers&lt;/code&gt; enabled.</source>
          <target state="translated">웹 서버의 구성에 다음과 유사한 행을 추가하면 Apache에서 HPKP가 활성화됩니다. 이를 위해서는 &lt;code&gt;mod_headers&lt;/code&gt; 를 활성화 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7dd6d658aa94b5d065ce37a8745178e4946d3138" translate="yes" xml:space="preserve">
          <source>Adding a new user through a signup modal;</source>
          <target state="translated">가입 모달을 통해 새로운 사용자 추가;</target>
        </trans-unit>
        <trans-unit id="0b33cfd7eec93815656866755a3c74843234ba55" translate="yes" xml:space="preserve">
          <source>Adding the following line and inserting the appropriate &lt;code&gt;pin-sha256=&quot;...&quot;&lt;/code&gt; values will enable HPKP on your nginx. This requires the &lt;code&gt;ngx_http_headers_module.&lt;/code&gt;</source>
          <target state="translated">다음 줄을 추가하고 적절한 &lt;code&gt;pin-sha256=&quot;...&quot;&lt;/code&gt; 값을 삽입하면 nginx에서 HPKP가 활성화됩니다. &lt;code&gt;ngx_http_headers_module.&lt;/code&gt; 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="0e4beeace5c1da3ea1621f1d80ef923b85ae8c3d" translate="yes" xml:space="preserve">
          <source>Additional HTTP Status Codes</source>
          <target state="translated">추가 HTTP 상태 코드</target>
        </trans-unit>
        <trans-unit id="1967bb490854e6f28ca3226c89aac1f8fefbf865" translate="yes" xml:space="preserve">
          <source>Additional cache control mechanisms have been introduced.</source>
          <target state="translated">추가 캐시 제어 메커니즘이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="4ca7b9663ad28e00bad95a214ec91b0b6850abe7" translate="yes" xml:space="preserve">
          <source>Addresses</source>
          <target state="translated">Addresses</target>
        </trans-unit>
        <trans-unit id="995ce128c900d1dd4799f4d03800bc30f8a436b1" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;base-uri&lt;/code&gt;, &lt;code&gt;child-src&lt;/code&gt;, &lt;code&gt;form-action&lt;/code&gt;, &lt;code&gt;frame-ancestors&lt;/code&gt;, &lt;code&gt;plugin-types&lt;/code&gt;, &lt;code&gt;referrer&lt;/code&gt;, and &lt;code&gt;report-uri&lt;/code&gt;. Deprecates &lt;code&gt;frame-src&lt;/code&gt;.</source>
          <target state="translated">를 추가의 &lt;code&gt;base-uri&lt;/code&gt; , &lt;code&gt;child-src&lt;/code&gt; , &lt;code&gt;form-action&lt;/code&gt; , &lt;code&gt;frame-ancestors&lt;/code&gt; , &lt;code&gt;plugin-types&lt;/code&gt; , &lt;code&gt;referrer&lt;/code&gt; 및 &lt;code&gt;report-uri&lt;/code&gt; . &lt;code&gt;frame-src&lt;/code&gt; 를 추천하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4fdd0faf0766b83c157ed1bedec26ec4f6e1bf8e" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;block-all-mixed-content&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;block-all-mixed-content&lt;/code&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="698c1f11ceb6668338bb9d2d17bb8f430c4a92aa" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;disown-opener&lt;/code&gt;, &lt;code&gt;manifest-src&lt;/code&gt;, &lt;code&gt;navigate-to&lt;/code&gt;, &lt;code&gt;report-to&lt;/code&gt;, &lt;code&gt;strict-dynamic&lt;/code&gt;, &lt;code&gt;worker-src&lt;/code&gt;. Undeprecates &lt;code&gt;frame-src&lt;/code&gt;. Deprecates &lt;code&gt;report-uri&lt;/code&gt; in favor if &lt;code&gt;report-to&lt;/code&gt;.</source>
          <target state="translated">를 추가의 &lt;code&gt;disown-opener&lt;/code&gt; , &lt;code&gt;manifest-src&lt;/code&gt; , &lt;code&gt;navigate-to&lt;/code&gt; , &lt;code&gt;report-to&lt;/code&gt; , &lt;code&gt;strict-dynamic&lt;/code&gt; , &lt;code&gt;worker-src&lt;/code&gt; . &lt;code&gt;frame-src&lt;/code&gt; 를 폐기합니다 . Deprecates는 &lt;code&gt;report-uri&lt;/code&gt; 의 경우 찬성 &lt;code&gt;report-to&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9d53db6af9b950aa6111bf9a5dda8ffb5ba7a6b" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;manifest-src&lt;/code&gt;, &lt;code&gt;navigate-to&lt;/code&gt;, &lt;code&gt;report-to&lt;/code&gt;, &lt;code&gt;strict-dynamic&lt;/code&gt;, &lt;code&gt;worker-src&lt;/code&gt;. Undeprecates &lt;code&gt;frame-src&lt;/code&gt;. Deprecates &lt;code&gt;report-uri&lt;/code&gt; in favor if &lt;code&gt;report-to&lt;/code&gt;.</source>
          <target state="translated">추가 &lt;code&gt;manifest-src&lt;/code&gt; , &lt;code&gt;navigate-to&lt;/code&gt; , &lt;code&gt;report-to&lt;/code&gt; , &lt;code&gt;strict-dynamic&lt;/code&gt; , &lt;code&gt;worker-src&lt;/code&gt; . Undeprecates의 &lt;code&gt;frame-src&lt;/code&gt; . &lt;code&gt;report-to&lt;/code&gt; 인 경우 선호되는 &lt;code&gt;report-uri&lt;/code&gt; 를 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1f3f4d3e4268a9bb85346c045c680766b2c7af4b" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;require-sri-for&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;require-sri-for&lt;/code&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="cc23a4d8adf978e596103328ec8522255dce7f76" translate="yes" xml:space="preserve">
          <source>Adds &lt;code&gt;upgrade-insecure-requests&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;upgrade-insecure-requests&lt;/code&gt; 추가 합니다 .</target>
        </trans-unit>
        <trans-unit id="455a3de4efcb11c6f35e14a41277f553dccf6ef8" translate="yes" xml:space="preserve">
          <source>Adobe &lt;a href=&quot;https://acrobat.adobe.com/us/en/why-adobe/about-adobe-pdf.html&quot;&gt;Portable Document Format&lt;/a&gt; (PDF)</source>
          <target state="translated">Adobe &lt;a href=&quot;https://acrobat.adobe.com/us/en/why-adobe/about-adobe-pdf.html&quot;&gt;휴대용 문서 형식&lt;/a&gt; (PDF)</target>
        </trans-unit>
        <trans-unit id="c6442c85da3c85db38a1dc41c371e4303bfaa1ab" translate="yes" xml:space="preserve">
          <source>Adopting a strict policy</source>
          <target state="translated">엄격한 정책 채택</target>
        </trans-unit>
        <trans-unit id="705cc20005888890de14a5894736ddb464edf2fe" translate="yes" xml:space="preserve">
          <source>Advice on using a www-prefixed domain or not, this article explains the consequences of the choice as well as how to make it.</source>
          <target state="translated">www-prefixed 도메인 사용에 대한 조언으로,이 기사는 선택의 결과와 그 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="733cfd6083d3dd3e2cb74c180509e4b0f99a5baa" translate="yes" xml:space="preserve">
          <source>Advisory text describing the error.</source>
          <target state="translated">오류를 설명하는 권고 텍스트.</target>
        </trans-unit>
        <trans-unit id="70bf82aa792195fb9abd5a33a491d7ed6007e8d4" translate="yes" xml:space="preserve">
          <source>After a successful COPY invocation, all dead properties on the source
   resource SHOULD be duplicated on the destination resource.  Live
   properties described in this document SHOULD be duplicated as
   identically behaving live properties at the destination resource, but
   not necessarily with the same values.  Servers SHOULD NOT convert
   live properties into dead properties on the destination resource,
   because clients may then draw incorrect conclusions about the state
   or functionality of a resource.  Note that some live properties are
   defined such that the absence of the property has a specific meaning
   (e.g., a flag with one meaning if present, and the opposite if
   absent), and in these cases, a successful COPY might result in the
   property being reported as &quot;Not Found&quot; in subsequent requests.

   When the destination is an unmapped URL, a COPY operation creates a
   new resource much like a PUT operation does.  Live properties that
   are related to resource creation (such as DAV:creationdate) should
   have their values set accordingly.</source>
          <target state="translated">COPY 호출이 성공하면 소스 리소스의 모든 죽은 속성이 대상 리소스에서 복제되어야합니다. 이 문서에서 설명하는 라이브 속성은 대상 리소스에서 동일하게 동작하는 라이브 속성으로 복제되어야하지만 반드시 같은 값을 갖는 것은 아닙니다. 클라이언트는 자원의 상태 나 기능에 대한 잘못된 결론을 내릴 수 있으므로 서버는 실제 자원을 대상 자원의 죽은 특성으로 변환하지 않아야합니다. 일부 라이브 속성은 속성의 부재가 특정 의미를 갖도록 정의됩니다 (예 : 존재하는 경우 하나의 의미를 가진 플래그,없는 경우 반대). 이러한 경우 COPY가 성공하면 속성이 발생할 수 있습니다. 후속 요청에서 &quot;찾을 수 없음&quot;으로보고되었습니다.대상이 매핑되지 않은 URL 인 경우 COPY 작업은 PUT 작업과 매우 유사한 새 리소스를 만듭니다. 리소스 생성과 관련된 라이브 속성 (예 : DAV : creationdate)은 그에 따라 값을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e07104f09b3d658fa8a7e37d72c9f233c219006d" translate="yes" xml:space="preserve">
          <source>After receiving an HTTP request, a server can send one or more &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; headers with the response. The cookie is usually stored by the browser, and then the cookie is sent with requests made to the same server inside a &lt;a href=&quot;headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; HTTP header. An expiration date or duration can be specified, after which the cookie is no longer sent. Additional restrictions to a specific domain and path can be set, limiting where the cookie is sent. For details about the header attributes mentioned below, refer to the &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; reference article.</source>
          <target state="translated">HTTP 요청을받은 후 서버는 응답과 함께 하나 이상의 &lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; 헤더를 보낼 수 있습니다 . 쿠키는 일반적으로 브라우저에 의해 저장되고 쿠키는 &lt;a href=&quot;headers/cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt; HTTP 헤더 내의 동일한 서버에 대한 요청과 함께 전송됩니다 . 만료 날짜 또는 기간을 지정할 수 있으며 그 이후에는 쿠키가 더 이상 전송되지 않습니다. 특정 도메인 및 경로에 대한 추가 제한을 설정하여 쿠키가 전송되는 위치를 제한 할 수 있습니다. 아래에 언급 된 헤더 속성에 대한 자세한 내용은 &lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; 참조 문서를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="a14481714e36484442aceaedae4c2cd14105aca4" translate="yes" xml:space="preserve">
          <source>After receiving and interpreting a request message, a server responds
   with an HTTP response message.

       Response      = Status-Line               ; &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;
                       *(( general-header        ; &lt;a href=&quot;#section-4.5&quot;&gt;Section 4.5&lt;/a&gt;
                        | response-header        ; &lt;a href=&quot;#section-6.2&quot;&gt;Section 6.2&lt;/a&gt;
                        | entity-header ) CRLF)  ; &lt;a href=&quot;#section-7.1&quot;&gt;Section 7.1&lt;/a&gt;
                       CRLF
                       [ message-body ]          ; &lt;a href=&quot;#section-7.2&quot;&gt;Section 7.2&lt;/a&gt;</source>
          <target state="translated">요청 메시지를 수신하고 해석 한 후 서버는 HTTP 응답 메시지로 응답합니다. 응답 = 상태 라인; &lt;a href=&quot;#section-6.1&quot;&gt;섹션 6.1&lt;/a&gt; * ((일반 헤더; &lt;a href=&quot;#section-4.5&quot;&gt;섹션 4.5&lt;/a&gt; | 응답 헤더; &lt;a href=&quot;#section-6.2&quot;&gt;섹션 6.2&lt;/a&gt; | 엔티티 헤더) CRLF); &lt;a href=&quot;#section-7.1&quot;&gt;7.1 절&lt;/a&gt; CRLF [message-body]; &lt;a href=&quot;#section-7.2&quot;&gt;섹션 7.2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dd41b49b28657546d8abb377c969ab355261d840" translate="yes" xml:space="preserve">
          <source>After reviewing all of the above better alternatives to user agent sniffing, there are still some potential cases where user agent sniffing is appropriate and justified.</source>
          <target state="translated">사용자 에이전트 스니핑에 대한 위의 더 나은 대안을 모두 검토 한 후에도 사용자 에이전트 스니핑이 적절하고 정당한 몇 가지 잠재적 인 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="da1797b05d9266d8b1fa009268c07e98d87828a9" translate="yes" xml:space="preserve">
          <source>After sending the PUSH_PROMISE frame, the server can begin delivering
   the pushed response as a response (&lt;a href=&quot;#section-8.1.2.4&quot;&gt;Section 8.1.2.4&lt;/a&gt;) on a server-
   initiated stream that uses the promised stream identifier.  The
   server uses this stream to transmit an HTTP response, using the same
   sequence of frames as defined in &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;.  This stream becomes
   &quot;half-closed&quot; to the client (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;) after the initial HEADERS
   frame is sent.

   Once a client receives a PUSH_PROMISE frame and chooses to accept the
   pushed response, the client SHOULD NOT issue any requests for the
   promised response until after the promised stream has closed.

   If the client determines, for any reason, that it does not wish to
   receive the pushed response from the server or if the server takes
   too long to begin sending the promised response, the client can send
   a RST_STREAM frame, using either the CANCEL or REFUSED_STREAM code
   and referencing the pushed stream's identifier.

   A client can use the SETTINGS_MAX_CONCURRENT_STREAMS setting to limit
   the number of responses that can be concurrently pushed by a server.
   Advertising a SETTINGS_MAX_CONCURRENT_STREAMS value of zero disables
   server push by preventing the server from creating the necessary
   streams.  This does not prohibit a server from sending PUSH_PROMISE
   frames; clients need to reset any promised streams that are not
   wanted.

   Clients receiving a pushed response MUST validate that either the
   server is authoritative (see &lt;a href=&quot;#section-10.1&quot;&gt;Section 10.1&lt;/a&gt;) or the proxy that provided
   the pushed response is configured for the corresponding request.  For
   example, a server that offers a certificate for only the
   &quot;example.com&quot; DNS-ID or Common Name is not permitted to push a
   response for &quot;https://www.example.org/doc&quot;.

   The response for a PUSH_PROMISE stream begins with a HEADERS frame,
   which immediately puts the stream into the &quot;half-closed (remote)&quot;
   state for the server and &quot;half-closed (local)&quot; state for the client,
   and ends with a frame bearing END_STREAM, which places the stream in
   the &quot;closed&quot; state.

      Note: The client never sends a frame with the END_STREAM flag for
      a server push.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef923924b84276758cd6220f7c2e0df0c688265" translate="yes" xml:space="preserve">
          <source>After the HTTP/1.1 header and the blank line that indicates the end of the header, the server will immediately include the server connection preface, starting with a &lt;code&gt;SETTINGS&lt;/code&gt; frame.</source>
          <target state="translated">HTTP / 1.1 헤더와 헤더의 끝을 나타내는 빈 줄 다음에 서버는 &lt;code&gt;SETTINGS&lt;/code&gt; 프레임으로 시작하여 서버 연결 서문을 즉시 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="8d6a047137bbfac123a894e86187dc3649969994" translate="yes" xml:space="preserve">
          <source>After the connected agent has sent its request, the web server processes it, and ultimately returns a response. Similar to a client request, a server response is formed of text directives, separated by CRLF, though divided into three blocks:</source>
          <target state="translated">연결된 에이전트가 요청을 보낸 후 웹 서버는 요청을 처리하고 궁극적으로 응답을 반환합니다. 클라이언트 요청과 마찬가지로 서버 응답은 CRLF로 구분 된 텍스트 지시문으로 구성되지만 세 개의 블록으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="26b7ae2775e7780938b8a0d7dbb2cdbf0eb3bc68" translate="yes" xml:space="preserve">
          <source>Again, use of the DNS server in the above can be minimized by adding redundant rules in the beginning:</source>
          <target state="translated">또한 처음에 중복 규칙을 추가하여 위의 DNS 서버 사용을 최소화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff9f1ff32120d8b893c1ded522d49590353b29a6" translate="yes" xml:space="preserve">
          <source>Age</source>
          <target state="translated">Age</target>
        </trans-unit>
        <trans-unit id="55c793215f8562190a36c5bf36bf9466ad683e17" translate="yes" xml:space="preserve">
          <source>Age (RFC 2616)</source>
          <target state="translated">나이 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="e4b4c54419afac8726deafd7435dab4615c9a68e" translate="yes" xml:space="preserve">
          <source>Age (RFC 7234)</source>
          <target state="translated">나이 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="52f86c4884cf6979487407f1bfb260fe6dc008d2" translate="yes" xml:space="preserve">
          <source>Agent-driven negotiation</source>
          <target state="translated">에이전트 중심 협상</target>
        </trans-unit>
        <trans-unit id="82e63706ff054e31f88909b903c540eb9fab7bf0" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content&quot;&gt;mixed content&lt;/a&gt; resource requests are blocked, including both active and passive mixed content. This also applies to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; documents, ensuring the entire page is mixed content free.</source>
          <target state="translated">활성 및 수동 혼합 컨텐츠를 포함하여 모든 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content&quot;&gt;혼합 컨텐츠&lt;/a&gt; 자원 요청이 차단됩니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 문서 에도 적용 되므로 전체 페이지에 혼합 컨텐츠가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="3f8728ba6de2afc5f460293bf5467790c482e2a7" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content&quot;&gt;mixed content&lt;/a&gt; resource requests are blocked, including both active and passive mixed content. This also applies to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; documents, ensuring the entire page is mixed content-free.</source>
          <target state="translated">액티브 및 패시브 혼합 콘텐츠를 포함하여 모든 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content&quot;&gt;혼합 콘텐츠&lt;/a&gt; 리소스 요청이 차단됩니다. 이는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 문서 에도 적용되어 전체 페이지에 내용이 혼합되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="a9a928697259543059b585ea4af2c89236a67a72" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;text&lt;/code&gt; JavaScript types have been deprecated by &lt;a href=&quot;https://tools.ietf.org/html/rfc4329&quot;&gt;RFC 4329&lt;/a&gt;.</source>
          <target state="translated">모든 &lt;code&gt;text&lt;/code&gt; JavaScript 유형은 &lt;a href=&quot;https://tools.ietf.org/html/rfc4329&quot;&gt;RFC 4329&lt;/a&gt; 에서 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="44f2895fb52823cefc3e500436bf5266b5f12474" translate="yes" xml:space="preserve">
          <source>All DAV headers follow the same basic formatting rules as HTTP
   headers.  This includes rules like line continuation and how to
   combine (or separate) multiple instances of the same header using
   commas.

   WebDAV adds two new conditional headers to the set defined in HTTP:
   the If and Overwrite headers.</source>
          <target state="translated">모든 DAV 헤더는 HTTP 헤더와 동일한 기본 형식 규칙을 따릅니다. 여기에는 줄 연속과 같은 규칙과 쉼표를 사용하여 동일한 헤더의 여러 인스턴스를 결합 (또는 분리)하는 방법이 포함됩니다. WebDAV는 HTTP에 정의 된 세트에 If 및 Overwrite 헤더라는 두 가지 새로운 조건부 헤더를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7bb7c13dc794c86beb6b5eb454b43a1af1effca0" translate="yes" xml:space="preserve">
          <source>All HTML content should be served with this type. Alternative MIME types for XHTML (like &lt;code&gt;application/xhtml+xml&lt;/code&gt;) are mostly useless nowadays.</source>
          <target state="translated">모든 HTML 컨텐츠는이 유형으로 제공되어야합니다. XHTML의 대체 MIME 유형 (예 : &lt;code&gt;application/xhtml+xml&lt;/code&gt; )은 오늘날 거의 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c02d32fb5d5640d2efd7ae1d94e1efc7987916ea" translate="yes" xml:space="preserve">
          <source>All HTTP/1.1 messages consist of a start-line followed by a sequence
   of octets in a format similar to the Internet Message Format
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;]: zero or more header fields (collectively referred to as
   the &quot;headers&quot; or the &quot;header section&quot;), an empty line indicating the
   end of the header section, and an optional message body.

     HTTP-message   = start-line
                      *( header-field CRLF )
                      CRLF
                      [ message-body ] 

   The normal procedure for parsing an HTTP message is to read the
   start-line into a structure, read each header field into a hash table
   by field name until the empty line, and then use the parsed data to
   determine if a message body is expected.  If a message body has been
   indicated, then it is read as a stream until an amount of octets
   equal to the message body length is read or the connection is closed.

   A recipient MUST parse an HTTP message as a sequence of octets in an
   encoding that is a superset of US-ASCII [&lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt;].  Parsing an HTTP
   message as a stream of Unicode characters, without regard for the
   specific encoding, creates security vulnerabilities due to the
   varying ways that string processing libraries handle invalid
   multibyte character sequences that contain the octet LF (%x0A).
   String-based parsers can only be safely used within protocol elements
   after the element has been extracted from the message, such as within
   a header field-value after message parsing has delineated the
   individual fields.

   An HTTP message can be parsed as a stream for incremental processing
   or forwarding downstream.  However, recipients cannot rely on
   incremental delivery of partial messages, since some implementations
   will buffer or delay message forwarding for the sake of network
   efficiency, security checks, or payload transformations.

   A sender MUST NOT send whitespace between the start-line and the
   first header field.  A recipient that receives whitespace between the
   start-line and the first header field MUST either reject the message
   as invalid or consume each whitespace-preceded line without further
   processing of it (i.e., ignore the entire line, along with any
   subsequent lines preceded by whitespace, until a properly formed
   header field is received or the header section is terminated).

   The presence of such whitespace in a request might be an attempt to
   trick a server into ignoring that field or processing the line after
   it as a new request, either of which might result in a security
   vulnerability if other implementations within the request chain
   interpret the same message differently.  Likewise, the presence of
   such whitespace in a response might be ignored by some clients or
   cause others to cease parsing.</source>
          <target state="translated">모든 HTTP / 1.1 메시지는 인터넷 메시지 형식 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322]&lt;/a&gt; 과 유사한 형식으로 시작 행과 일련의 8 진수로 구성됩니다.] : 0 개 이상의 헤더 필드 (통칭하여 &quot;헤더&quot;또는 &quot;헤더 섹션&quot;이라고 함), 헤더 섹션의 끝을 나타내는 빈 줄 및 선택적 메시지 본문. HTTP-message = start-line * (헤더 필드 CRLF) CRLF [message-body] HTTP 메시지를 구문 분석하는 일반적인 절차는 시작 라인을 구조로 읽고 각 헤더 필드를 필드 이름별로 해시 테이블로 읽는 것입니다. 빈 줄까지 기다린 다음 구문 분석 된 데이터를 사용하여 메시지 본문이 예상되는지 확인합니다. 메시지 본문이 표시된 경우, 메시지 본문 길이와 동일한 옥텟의 양을 읽거나 연결이 닫힐 때까지 스트림으로 읽습니다.수신자는 반드시 US-ASCII의 상위 집합 인 인코딩에서 HTTP 메시지를 일련의 8 진수로 파싱해야한다.&lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt;]. 특정 인코딩에 관계없이 HTTP 메시지를 유니 코드 문자 스트림으로 구문 분석하면 문자열 처리 라이브러리가 옥텟 LF (% x0A)를 포함하는 유효하지 않은 멀티 바이트 문자 시퀀스를 처리하는 다양한 방식으로 인해 보안 취약점이 발생합니다. 문자열 기반 파서는 메시지 구문 분석이 개별 필드를 묘사 한 후 헤더 필드 값과 같이 메시지에서 요소가 추출 된 후 프로토콜 요소 내에서만 안전하게 사용할 수 있습니다. HTTP 메시지는 증분 처리 또는 다운 스트림 전달을위한 스트림으로 구문 분석 될 수 있습니다. 그러나 일부 구현에서는 네트워크 효율성, 보안 검사 또는 페이로드 변환을 위해 메시지 전달을 버퍼링하거나 지연시키기 때문에 수신자는 부분 메시지의 증분 전달에 의존 할 수 없습니다.발신자는 시작 줄과 첫 번째 헤더 필드 사이에 공백을 보내서는 안됩니다. 시작 행과 첫 번째 헤더 필드 사이에 공백을받는 수신자는 메시지를 유효하지 않은 것으로 거부하거나 추가 처리없이 공백 앞에 오는 각 행을 사용해야합니다 (즉, 공백 앞에 오는 모든 행과 함께 전체 행을 무시합니다). , 올바르게 구성된 헤더 필드가 수신되거나 헤더 섹션이 종료 될 때까지). 요청에 이러한 공백이 존재하면 서버가 해당 필드를 무시하거나 새로운 요청으로 라인을 처리하도록 속일 수 있습니다. 요청 체인 내의 다른 구현이 동일하게 해석하면 보안 취약점이 발생할 수 있습니다. 다르게 메시지. 마찬가지로,응답에서 이러한 공백의 존재는 일부 클라이언트에서 무시되거나 다른 사용자가 구문 분석을 중단시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc6d70014fb3882dcf60f571eb265b4ead440816" translate="yes" xml:space="preserve">
          <source>All conditional headers try to check if the resource stored on the server matches a specific version. To achieve this, the conditional requests need to indicate the version of the resource. As comparing the whole resource byte to byte is impracticable, and not always what is wanted, the request transmits a value describing the version. Such values are called &lt;em&gt;validators&lt;/em&gt;, and are of two kinds:</source>
          <target state="translated">모든 조건부 헤더는 서버에 저장된 리소스가 특정 버전과 일치하는지 확인합니다. 이를 위해서는 조건부 요청에 리소스 버전을 표시해야합니다. 전체 리소스 바이트를 바이트와 비교하는 것은 불가능하며 항상 원하는 것은 아니기 때문에 요청은 버전을 설명하는 값을 전송합니다. 이러한 값을 &lt;em&gt;유효성 검증기&lt;/em&gt; 라고 하며 두 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="296ff2d47f9455e021f2222fa33a39e88b9c1dd8" translate="yes" xml:space="preserve">
          <source>All dependent streams are allocated an integer weight between 1 and
   256 (inclusive).

   Streams with the same parent SHOULD be allocated resources
   proportionally based on their weight.  Thus, if stream B depends on
   stream A with weight 4, stream C depends on stream A with weight 12,
   and no progress can be made on stream A, stream B ideally receives
   one-third of the resources allocated to stream C.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea1578a24664dc2977454167c38e76bf6096f7f" translate="yes" xml:space="preserve">
          <source>All directives must comply with the &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;quoted-string grammar&lt;/a&gt;. A directive that does not include the double quotes is invalid.</source>
          <target state="translated">모든 지시문은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;인용 문자열 문법을&lt;/a&gt; 준수해야합니다 . 큰 따옴표를 포함하지 않는 지시문은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee4674f00380d123974f659bcae306656f636284" translate="yes" xml:space="preserve">
          <source>All documents in the &lt;code&gt;images/&lt;/code&gt; directory will redirect to a different domain.</source>
          <target state="translated">&lt;code&gt;images/&lt;/code&gt; 디렉토리 의 모든 문서 는 다른 도메인으로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="86032829f23613e0e2c883c0ed233cfc98f34429" translate="yes" xml:space="preserve">
          <source>All documents in the &lt;code&gt;images/&lt;/code&gt; folder will be redirected to a different domain.</source>
          <target state="translated">&lt;code&gt;images/&lt;/code&gt; 폴더 의 모든 문서 는 다른 도메인으로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="151f06c99b273134876a0a499da72571a2000294" translate="yes" xml:space="preserve">
          <source>All frames begin with a fixed 9-octet header followed by a variable-
   length payload.

    +-----------------------------------------------+
    |                 Length (24)                   |
    +---------------+---------------+---------------+
    |   Type (8)    |   Flags (8)   |
    +-+-------------+---------------+-------------------------------+
    |R|                 Stream Identifier (31)                      |
    +=+=============================================================+
    |                   Frame Payload (0...)                      
    +---------------------------------------------------------------+

                          Figure 1: Frame Layout

   The fields of the frame header are defined as:

   Length:  The length of the frame payload expressed as an unsigned
      24-bit integer.  Values greater than 2^14 (16,384) MUST NOT be
      sent unless the receiver has set a larger value for
      SETTINGS_MAX_FRAME_SIZE.

      The 9 octets of the frame header are not included in this value. 

   Type:  The 8-bit type of the frame.  The frame type determines the
      format and semantics of the frame.  Implementations MUST ignore
      and discard any frame that has a type that is unknown.

   Flags:  An 8-bit field reserved for boolean flags specific to the
      frame type.

      Flags are assigned semantics specific to the indicated frame type.
      Flags that have no defined semantics for a particular frame type
      MUST be ignored and MUST be left unset (0x0) when sending.

   R: A reserved 1-bit field.  The semantics of this bit are undefined,
      and the bit MUST remain unset (0x0) when sending and MUST be
      ignored when receiving.

   Stream Identifier:  A stream identifier (see &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;) expressed
      as an unsigned 31-bit integer.  The value 0x0 is reserved for
      frames that are associated with the connection as a whole as
      opposed to an individual stream.

   The structure and content of the frame payload is dependent entirely
   on the frame type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c6c99a024c7f251148642ab153c93b1834f5d1" translate="yes" xml:space="preserve">
          <source>All hosts which aren't fully qualified, or the ones that are in local domain, will be connected to directly. Everything else will go through &lt;code&gt;w3proxy.mozilla.org:8080&lt;/code&gt;. If the proxy goes down, connections become direct automatically:</source>
          <target state="translated">정규화되지 않은 모든 호스트 또는 로컬 도메인에있는 호스트는 직접 연결됩니다. 다른 모든 것은 &lt;code&gt;w3proxy.mozilla.org:8080&lt;/code&gt; 을 통과 합니다. 프록시가 다운되면 자동으로 직접 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="2556a3f65b2016a6f4465c2cba6687d885b96f50" translate="yes" xml:space="preserve">
          <source>All hosts which aren't fully qualified, or the ones that are in local domain, will be connected to directly. Everything else will go through w3proxy:8080. If the proxy goes down, connections become direct automatically:</source>
          <target state="translated">정규화되지 않은 모든 호스트 또는 로컬 도메인에있는 호스트는 직접 연결됩니다. 다른 모든 것들은 w3proxy : 8080을 거치게됩니다. 프록시가 다운되면 연결이 자동으로 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="9e7d8118d9f750540c3d405da3bd825af374930a" translate="yes" xml:space="preserve">
          <source>All iframes inherit the policy of their parent page. If the iframe has an &lt;code&gt;allow&lt;/code&gt; attribute, the policies of the parent page and the &lt;code&gt;allow&lt;/code&gt; attribute are combined, using the most restrictive subset. For an iframe to have a feature enabled, the origin must be in the allowlist for both the parent page and the allow attribute.</source>
          <target state="translated">모든 iframe은 상위 페이지의 정책을 상속합니다. iframe에 &lt;code&gt;allow&lt;/code&gt; 속성 이 있으면 가장 제한적인 하위 집합을 사용하여 상위 페이지의 정책과 &lt;code&gt;allow&lt;/code&gt; 속성이 결합됩니다. iframe에서 기능을 사용하려면 원점이 상위 페이지 및 허용 속성 모두에 대한 허용 목록에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="14f1bc03c603d449cb2f82a18478f537735beda9" translate="yes" xml:space="preserve">
          <source>All local accesses are desired to be direct. All proxy servers run on the port 8080 (they don't need to). Note how strings can be concatenated with the &lt;strong&gt;+&lt;/strong&gt; operator in JavaScript.</source>
          <target state="translated">모든 로컬 액세스는 직접적이어야합니다. 모든 프록시 서버는 포트 8080에서 실행됩니다 (필요하지는 않음). JavaScript에서 문자열을 &lt;strong&gt;+&lt;/strong&gt; 연산자 로 연결하는 방법에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="871fee64cdc73fa544bed4b409dd8bfda18bd570" translate="yes" xml:space="preserve">
          <source>All local accesses are desired to be direct. All proxy servers run on the port 8080 (they don't need to, you can just change your port but remember to modify your configuations on both side). Note how strings can be concatenated with the &lt;code&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;/code&gt; operator in JavaScript.</source>
          <target state="translated">모든 로컬 액세스는 직접적이어야합니다. 모든 프록시 서버는 포트 8080에서 실행됩니다 (그럴 필요는 없습니다. 포트만 변경할 수 있지만 양쪽에서 구성을 수정하는 것을 잊지 마십시오). JavaScript에서 문자열을 &lt;code&gt;&lt;strong&gt;+&lt;/strong&gt;&lt;/code&gt; 연산자 로 연결하는 방법에 유의하십시오 .</target>
        </trans-unit>
        <trans-unit id="47f43d7619bd14afa48b80f4f69322e3d75a1bed" translate="yes" xml:space="preserve">
          <source>All methods that might be expected to cause modifications to the
   origin server's resources MUST be written through to the origin
   server. This currently includes all methods except for GET and HEAD.
   A cache MUST NOT reply to such a request from a client before having
   transmitted the request to the inbound server, and having received a
   corresponding response from the inbound server. This does not prevent
   a proxy cache from sending a 100 (Continue) response before the
   inbound server has sent its final reply.

   The alternative (known as &quot;write-back&quot; or &quot;copy-back&quot; caching) is not
   allowed in HTTP/1.1, due to the difficulty of providing consistent
   updates and the problems arising from server, cache, or network
   failure prior to write-back.</source>
          <target state="translated">오리진 서버의 자원을 수정하게 될 것으로 예상되는 모든 방법은 반드시 오리진 서버에 작성해야합니다. 여기에는 현재 GET 및 HEAD를 제외한 모든 방법이 포함됩니다. 캐시는 요청을 인바운드 서버로 전송하고 인바운드 서버로부터 해당 응답을 수신하기 전에 클라이언트의 요청에 응답해서는 안됩니다. 인바운드 서버가 최종 응답을 보내기 전에 프록시 캐시가 100 (계속) 응답을 보내는 것을 막지 않습니다. 일관된 업데이트를 제공하기가 어렵고 쓰기 전 서버, 캐시 또는 네트워크 오류로 인해 발생하는 문제로 인해 HTTP / 1.1에서는 대안 ( &quot;write-back&quot;또는 &quot;copy-back&quot;캐싱)이 허용되지 않습니다. 뒤.</target>
        </trans-unit>
        <trans-unit id="d6a76bce8ed4b24dc82bafad92dd9740f7195e9c" translate="yes" xml:space="preserve">
          <source>All modern browsers and servers do support it and the only thing to negotiate is the compression algorithm to use. These algorithm are optimized for text. In the 1990s, compression technology was advancing at a rapid pace and numerous successive algorithms have been added to the set of possible choices. Nowadays, only two are relevant: &lt;code&gt;gzip&lt;/code&gt;, the most common one, and &lt;code&gt;br&lt;/code&gt; the new challenger.</source>
          <target state="translated">모든 최신 브라우저와 서버는이를 지원하며 협상 할 유일한 것은 사용할 압축 알고리즘입니다. 이 알고리즘은 텍스트에 최적화되어 있습니다. 1990 년대에 압축 기술은 빠른 속도로 발전하고 있으며 수많은 일련의 알고리즘이 가능한 선택 세트에 추가되었습니다. : 현재, 두는 관련이 &lt;code&gt;gzip&lt;/code&gt; , 가장 일반적인 하나, 그리고 &lt;code&gt;br&lt;/code&gt; 새로운 도전자.</target>
        </trans-unit>
        <trans-unit id="7efabba7ae41c2653d1f20ea222b6e6ae7445249" translate="yes" xml:space="preserve">
          <source>All of the mechanisms specified in this document are described in
   both prose and an augmented Backus-Naur Form (BNF) similar to that
   used by &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]. Implementors will need to be familiar with the
   notation in order to understand this specification. The augmented BNF
   includes the following constructs:

   name = definition
      The name of a rule is simply the name itself (without any
      enclosing &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot;) and is separated from its definition by the
      equal &quot;=&quot; character. White space is only significant in that
      indentation of continuation lines is used to indicate a rule
      definition that spans more than one line. Certain basic rules are
      in uppercase, such as SP, LWS, HT, CRLF, DIGIT, ALPHA, etc. Angle
      brackets are used within definitions whenever their presence will
      facilitate discerning the use of rule names.

   &quot;literal&quot;
      Quotation marks surround literal text. Unless stated otherwise,
      the text is case-insensitive.

   rule1 | rule2
      Elements separated by a bar (&quot;|&quot;) are alternatives, e.g., &quot;yes |
      no&quot; will accept yes or no.

   (rule1 rule2)
      Elements enclosed in parentheses are treated as a single element.
      Thus, &quot;(elem (foo | bar) elem)&quot; allows the token sequences &quot;elem
      foo elem&quot; and &quot;elem bar elem&quot;.

   *rule
      The character &quot;*&quot; preceding an element indicates repetition. The
      full form is &quot;&amp;lt;n&amp;gt;*&amp;lt;m&amp;gt;element&quot; indicating at least &amp;lt;n&amp;gt; and at most
      &amp;lt;m&amp;gt; occurrences of element. Default values are 0 and infinity so
      that &quot;*(element)&quot; allows any number, including zero; &quot;1*element&quot;
      requires at least one; and &quot;1*2element&quot; allows one or two.

   [&lt;a id=&quot;ref-rule&quot; name=&quot;ref-rule&quot;&gt;rule&lt;/a&gt;]
      Square brackets enclose optional elements; &quot;[foo bar]&quot; is
      equivalent to &quot;*1(foo bar)&quot;. 

   N rule
      Specific repetition: &quot;&amp;lt;n&amp;gt;(element)&quot; is equivalent to
      &quot;&amp;lt;n&amp;gt;*&amp;lt;n&amp;gt;(element)&quot;; that is, exactly &amp;lt;n&amp;gt; occurrences of (element).
      Thus 2DIGIT is a 2-digit number, and 3ALPHA is a string of three
      alphabetic characters.

   #rule
      A construct &quot;#&quot; is defined, similar to &quot;*&quot;, for defining lists of
      elements. The full form is &quot;&amp;lt;n&amp;gt;#&amp;lt;m&amp;gt;element&quot; indicating at least
      &amp;lt;n&amp;gt; and at most &amp;lt;m&amp;gt; elements, each separated by one or more commas
      (&quot;,&quot;) and OPTIONAL linear white space (LWS). This makes the usual
      form of lists very easy; a rule such as
         ( *LWS element *( *LWS &quot;,&quot; *LWS element ))
      can be shown as
         1#element
      Wherever this construct is used, null elements are allowed, but do
      not contribute to the count of elements present. That is,
      &quot;(element), , (element) &quot; is permitted, but counts as only two
      elements. Therefore, where at least one element is required, at
      least one non-null element MUST be present. Default values are 0
      and infinity so that &quot;#element&quot; allows any number, including zero;
      &quot;1#element&quot; requires at least one; and &quot;1#2element&quot; allows one or
      two.

   ; comment
      A semi-colon, set off some distance to the right of rule text,
      starts a comment that continues to the end of line. This is a
      simple way of including useful notes in parallel with the
      specifications.

   implied *LWS
      The grammar described by this specification is word-based. Except
      where noted otherwise, linear white space (LWS) can be included
      between any two adjacent words (token or quoted-string), and
      between adjacent words and separators, without changing the
      interpretation of a field. At least one delimiter (LWS and/or

      separators) MUST exist between any two tokens (for the definition
      of &quot;token&quot; below), since they would otherwise be interpreted as a
      single token.</source>
          <target state="translated">이 문서에 명시된 모든 메커니즘은 &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822에&lt;/a&gt; 의해 사용 된 것과 유사한 산문 및 확장 된 백 투스-나 우어 양식 (BNF)으로 설명되어 있습니다. [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]. 구현자는이 사양을 이해하기 위해 표기법에 익숙해야합니다. 확장 된 BNF에는 다음과 같은 구성이 포함됩니다. name = definition 규칙의 이름은 단순히 이름 자체 ( &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;없이)이며 &quot;=&quot;문자로 정의와 구분됩니다. 공백은 연속 줄 들여 쓰기가 둘 이상의 줄에 걸친 규칙 정의를 나타내는 데 사용된다는 점에서만 중요합니다. SP, LWS, HT, CRLF, DIGIT, ALPHA 등과 같은 특정 기본 규칙은 대문자로되어 있습니다. 꺾쇠 괄호는 규칙 이름의 사용을 식별하는 데 도움이 될 때마다 정의 내에서 사용됩니다. &quot;리터럴&quot;따옴표는 리터럴 텍스트를 둘러 쌉니다. 달리 언급하지 않는 한텍스트는 대소 문자를 구분하지 않습니다. rule1 | rule2 막대 ( &quot;|&quot;)로 구분 된 요소는 대안입니다. 예를 들어 &quot;yes | no&quot;는 yes 또는 no를 허용합니다. (rule1 rule2) 괄호로 묶인 요소는 단일 요소로 취급됩니다. 따라서 &quot;(elem (foo | bar) elem)&quot;은 토큰 시퀀스 &quot;elem foo elem&quot;및 &quot;elem bar elem&quot;을 허용합니다. * rule 요소 앞의 문자 &quot;*&quot;는 반복을 나타냅니다. 전체 형태는 &quot;&amp;lt;n&amp;gt; * &amp;lt;m&amp;gt; element&quot;이며 요소의 &amp;lt;n&amp;gt; 이상 &amp;lt;m&amp;gt;을 나타냅니다. 기본값은 0과 무한대이므로 &quot;* (element)&quot;는 0을 포함한 모든 숫자를 허용합니다. &quot;1 * 요소&quot;는 하나 이상이 필요합니다. &quot;1 * 2element&quot;는 하나 나 둘을 허용합니다. [[[rule1 | rule2 막대 ( &quot;|&quot;)로 구분 된 요소는 대안입니다. 예를 들어 &quot;yes | no&quot;는 yes 또는 no를 허용합니다. (rule1 rule2) 괄호로 묶인 요소는 단일 요소로 취급됩니다. 따라서 &quot;(elem (foo | bar) elem)&quot;은 토큰 시퀀스 &quot;elem foo elem&quot;및 &quot;elem bar elem&quot;을 허용합니다. * rule 요소 앞의 문자 &quot;*&quot;는 반복을 나타냅니다. 전체 형태는 &quot;&amp;lt;n&amp;gt; * &amp;lt;m&amp;gt; element&quot;이며 요소의 &amp;lt;n&amp;gt; 이상 &amp;lt;m&amp;gt;을 나타냅니다. 기본값은 0과 무한대이므로 &quot;* (element)&quot;는 0을 포함한 모든 숫자를 허용합니다. &quot;1 * 요소&quot;는 하나 이상이 필요합니다. &quot;1 * 2element&quot;는 하나 나 둘을 허용합니다. [rule1 | rule2 막대 ( &quot;|&quot;)로 구분 된 요소는 대안입니다. 예를 들어 &quot;yes | no&quot;는 yes 또는 no를 허용합니다. (rule1 rule2) 괄호로 묶인 요소는 단일 요소로 취급됩니다. 따라서 &quot;(elem (foo | bar) elem)&quot;은 토큰 시퀀스 &quot;elem foo elem&quot;및 &quot;elem bar elem&quot;을 허용합니다. * rule 요소 앞의 문자 &quot;*&quot;는 반복을 나타냅니다. 전체 형태는 &quot;&amp;lt;n&amp;gt; * &amp;lt;m&amp;gt; element&quot;이며 요소의 &amp;lt;n&amp;gt; 이상 &amp;lt;m&amp;gt;을 나타냅니다. 기본값은 0과 무한대이므로 &quot;* (element)&quot;는 0을 포함한 모든 숫자를 허용합니다. &quot;1 * 요소&quot;는 하나 이상이 필요합니다. &quot;1 * 2element&quot;는 하나 나 둘을 허용합니다. [[[예 | no &quot;는 yes 또는 no를 허용합니다. (rule1 rule2) 괄호로 묶인 요소는 단일 요소로 취급되므로&quot;(elem (foo | bar) elem) &quot;은 토큰 시퀀스&quot;elem foo elem &quot;및&quot;elem bar elem을 허용합니다. &quot;. * rule 요소 앞의 문자&quot;* &quot;는 반복을 나타냅니다. 전체 형태는&quot;&amp;lt;n&amp;gt; * &amp;lt;m&amp;gt; element &quot;이상이며 &amp;lt;n&amp;gt; 및 최대 &amp;lt;m&amp;gt; 개의 요소 발생을 나타냅니다. 기본값은 0이고 &quot;* (element)&quot;는 0을 포함하여 임의의 숫자를 허용하고 &quot;1 * element&quot;는 하나 이상을 필요로하며 &quot;1 * 2element&quot;는 하나 또는 둘을 허용합니다.예 | no &quot;는 yes 또는 no를 허용합니다. (rule1 rule2) 괄호로 묶인 요소는 단일 요소로 취급되므로&quot;(elem (foo | bar) elem) &quot;은 토큰 시퀀스&quot;elem foo elem &quot;및&quot;elem bar elem을 허용합니다. &quot;. * rule 요소 앞의 문자&quot;* &quot;는 반복을 나타냅니다. 전체 형태는&quot;&amp;lt;n&amp;gt; * &amp;lt;m&amp;gt; element &quot;이상이며 &amp;lt;n&amp;gt; 및 최대 &amp;lt;m&amp;gt; 개의 요소 발생을 나타냅니다. 기본값은 0이고 &quot;* (element)&quot;는 0을 포함하여 임의의 숫자를 허용하고 &quot;1 * element&quot;는 하나 이상을 필요로하며 &quot;1 * 2element&quot;는 하나 또는 둘을 허용합니다.(elem (foo | bar) elem) &quot;은 토큰 시퀀스&quot;elem foo elem &quot;및&quot;elem bar elem &quot;을 허용합니다. * rule 요소 앞의 문자&quot;* &quot;는 반복을 나타냅니다. 전체 형식은&quot;&amp;lt;n&amp;gt; * &amp;lt;m &amp;gt; element &quot;는 &amp;lt;n&amp;gt; 개와 &amp;lt;m&amp;gt; 개 이상의 요소를 나타냅니다. 기본값은 0과 무한대이므로&quot;* (element) &quot;는 0을 포함한 모든 숫자를 허용합니다.&quot;1 * element &quot;는 하나 이상이 필요합니다. &quot;1 * 2 요소&quot;는 하나 나 둘을 허용합니다.(elem (foo | bar) elem) &quot;은 토큰 시퀀스&quot;elem foo elem &quot;및&quot;elem bar elem &quot;을 허용합니다. * rule 요소 앞의 문자&quot;* &quot;는 반복을 나타냅니다. 전체 형식은&quot;&amp;lt;n&amp;gt; * &amp;lt;m &amp;gt; element &quot;는 &amp;lt;n&amp;gt; 개와 &amp;lt;m&amp;gt; 개 이상의 요소를 나타냅니다. 기본값은 0과 무한대이므로&quot;* (element) &quot;는 0을 포함한 모든 숫자를 허용합니다.&quot;1 * element &quot;는 하나 이상이 필요합니다. &quot;1 * 2 요소&quot;는 하나 나 둘을 허용합니다.최대 &amp;lt;m&amp;gt; 개의 요소 발생. 기본값은 0과 무한대이므로 &quot;* (element)&quot;는 0을 포함한 모든 숫자를 허용합니다. &quot;1 * 요소&quot;는 하나 이상이 필요합니다. &quot;1 * 2element&quot;는 하나 나 둘을 허용합니다. [최대 &amp;lt;m&amp;gt; 개의 요소 발생. 기본값은 0과 무한대이므로 &quot;* (element)&quot;는 0을 포함한 모든 숫자를 허용합니다. &quot;1 * 요소&quot;는 하나 이상이 필요합니다. &quot;1 * 2element&quot;는 하나 나 둘을 허용합니다. [&lt;a id=&quot;ref-rule&quot; name=&quot;ref-rule&quot;&gt;규칙&lt;/a&gt;] 대괄호는 선택적 요소를 포함합니다. &quot;[foo bar]&quot;는 &quot;* 1 (foo bar)&quot;와 같습니다. N 규칙 특정 반복 : &quot;&amp;lt;n&amp;gt; (요소)&quot;는 &quot;&amp;lt;n&amp;gt; * &amp;lt;n&amp;gt; (요소)&quot;와 같습니다. 즉, 정확히 &amp;lt;n&amp;gt; 개의 (요소)가 나타납니다. 따라서 2DIGIT는 2 자리 숫자이고 3ALPHA는 3 자의 영 문자열입니다. #rule 요소 목록을 정의하기 위해 &quot;*&quot;와 유사한 구문 &quot;#&quot;이 정의됩니다. 전체 형식은 &quot;&amp;lt;n&amp;gt; # &amp;lt;m&amp;gt; element&quot;이며 적어도 &amp;lt;n&amp;gt; 개 이하의 &amp;lt;m&amp;gt; 요소를 나타내며 각 요소는 하나 이상의 쉼표 ( &quot;,&quot;)와 OPTIONAL linear white space (LWS)로 구분됩니다. 이것은 일반적인 형태의 목록을 매우 쉽게 만듭니다. (* LWS 요소 * (* LWS &quot;와 같은 규칙,&quot;* LWS element))는 1 # element로 표시 될 수 있습니다.이 구문이 사용될 때마다 널 요소는 허용되지만 존재하는 요소 수에는 영향을주지 않습니다. 즉,&quot;(element),, (element) &quot;는 허용됩니다 최소 하나의 요소가 필요한 경우 하나 이상의 null이 아닌 요소가 있어야합니다. 기본값은 0과 무한대이므로 &quot;#element&quot;는 0을 포함한 모든 숫자를 허용합니다. &quot;1 #element &quot;는 최소한 하나를 필요로하고&quot;1 # 2element &quot;는 하나 또는 두개를 허용합니다.; 주석 규칙 텍스트의 오른쪽으로 약간 떨어진 거리에있는 세미콜론은 줄 끝까지 계속되는 주석을 시작합니다. 사양과 함께 유용한 메모를 포함하는 간단한 방법.암시 적 * LWS이 사양에서 설명하는 문법은 단어 기반입니다. 달리 언급 된 경우를 제외하고, 선형 공백 (LWS)은 필드의 해석을 변경하지 않고 인접한 두 단어 (토큰 또는 따옴표로 묶인 문자열) 사이와 인접한 단어와 구분 기호 사이에 포함될 수 있습니다. 두 토큰 사이에 최소 하나의 구분 기호 (LWS 및 / 또는 구분 기호)가 있어야합니다 (아래 &quot;토큰&quot;의 정의를 위해). 그렇지 않으면 단일 토큰으로 해석되기 때문입니다.두 토큰 사이에 최소 하나의 구분 기호 (LWS 및 / 또는 구분 기호)가 있어야합니다 (아래 &quot;토큰&quot;의 정의를 위해). 그렇지 않으면 단일 토큰으로 해석되기 때문입니다.두 토큰 사이에 최소 하나의 구분 기호 (LWS 및 / 또는 구분 기호)가 있어야합니다 (아래 &quot;토큰&quot;의 정의를 위해). 그렇지 않으면 단일 토큰으로 해석되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d9826d3b0aadb4c0d991f77ab80bce5d93271a5e" translate="yes" xml:space="preserve">
          <source>All present and future subdomains will be HTTPS for a max-age of 1 year. This blocks access to pages or sub domains that can only be served over HTTP.</source>
          <target state="translated">현재 및 미래의 모든 하위 도메인은 최대 1 년 동안 HTTPS가됩니다. 이는 HTTP를 통해서만 제공 될 수있는 페이지 또는 하위 도메인에 대한 액세스를 차단합니다.</target>
        </trans-unit>
        <trans-unit id="efb3018ed7ba81bc986a32dff4c272b1fc5af94f" translate="yes" xml:space="preserve">
          <source>All responses with one of these status codes send a &lt;code&gt;Location&lt;/code&gt; header.</source>
          <target state="translated">이러한 상태 코드 중 하나를 가진 모든 응답은 &lt;code&gt;Location&lt;/code&gt; 헤더를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="f69c00231b6bb7e2418bf271e61ffc7333b84fb8" translate="yes" xml:space="preserve">
          <source>All streams are initially assigned a non-exclusive dependency on
   stream 0x0.  Pushed streams (&lt;a href=&quot;#section-8.2&quot;&gt;Section 8.2&lt;/a&gt;) initially depend on their
   associated stream.  In both cases, streams are assigned a default
   weight of 16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31998230cdc3b967cea6c7d6edfed8e8ab8ab57f" translate="yes" xml:space="preserve">
          <source>All you need to do is combine multiple &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; headers into a single one, with commas separating the origins gathered from each copy of the header.</source>
          <target state="translated">여러 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더를 하나의 헤더로 결합하기 만하면 헤더의 각 사본에서 수집 된 원점을 쉼표로 구분할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ad0e3698278f45b2af94445396e9865f213f617" translate="yes" xml:space="preserve">
          <source>Allow</source>
          <target state="translated">Allow</target>
        </trans-unit>
        <trans-unit id="fd3431f3358696a8f688eedd078d377a2bef938b" translate="yes" xml:space="preserve">
          <source>Allow (RFC 2616)</source>
          <target state="translated">허용 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="2a254a8dafebfc7a8b81cab0f55d1468af9cf5e7" translate="yes" xml:space="preserve">
          <source>Allow (RFC 7231)</source>
          <target state="translated">허용 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="78637188ae6e129684b8ed4d25b294e489fcaddf" translate="yes" xml:space="preserve">
          <source>Allow commas in Accept, Accept-Language, and Content-Language request headers for simple CORS</source>
          <target state="translated">간단한 CORS에 대한 Accept, Accept-Language 및 Content-Language 요청 헤더에 쉼표를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b7700064d34b89eae4fcb61ae4f9c3f1965adc23" translate="yes" xml:space="preserve">
          <source>Allow credentials:</source>
          <target state="translated">자격 증명 허용 :</target>
        </trans-unit>
        <trans-unit id="85317a1ad2b956cae1168d9078911413cee98254" translate="yes" xml:space="preserve">
          <source>Allow iframes to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API&quot;&gt;fullscreen API&lt;/a&gt;.</source>
          <target state="translated">iframe이 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API&quot;&gt;전체 화면 API&lt;/a&gt; 를 사용하도록 허용 합니다 .</target>
        </trans-unit>
        <trans-unit id="464b3413d2c92ce5d1cdddc36fca2e60307a278a" translate="yes" xml:space="preserve">
          <source>Allow iframes to use the fullscreen API.</source>
          <target state="translated">iframe이 전체 화면 API를 사용하도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="de76bcbe1f2fb18c478a0f6fa30885454a59cea6" translate="yes" xml:space="preserve">
          <source>Allowed in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML forms&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML 양식으로&lt;/a&gt; 허용</target>
        </trans-unit>
        <trans-unit id="0fda3a8172ffd809fcbe4f6321f7fa38cb061525" translate="yes" xml:space="preserve">
          <source>Allowed in HTML forms</source>
          <target state="translated">HTML 양식으로 허용</target>
        </trans-unit>
        <trans-unit id="81c74e599caf074409d91e89aa90f8b48ef77e84" translate="yes" xml:space="preserve">
          <source>Allowing Flash content</source>
          <target state="translated">플래시 컨텐츠 허용</target>
        </trans-unit>
        <trans-unit id="e8cb5b34df4d8b6d0f67236dd55dc2d559fc1e85" translate="yes" xml:space="preserve">
          <source>Allowing Java applets</source>
          <target state="translated">Java 애플릿 허용</target>
        </trans-unit>
        <trans-unit id="38a5368250d0af35f902c906a91e772c1f7312b2" translate="yes" xml:space="preserve">
          <source>Allowing users to opt out of receiving some or all cookies.</source>
          <target state="translated">사용자가 일부 또는 전체 쿠키 수신을 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5611e2c410b0178775a61e246c3d79485afc2e9" translate="yes" xml:space="preserve">
          <source>Allowing users to use the bulk of your service without receiving cookies.</source>
          <target state="translated">사용자가 쿠키를받지 않고 귀하의 서비스를 대량으로 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="7c6534d14b65c6f01882f09b9bc7625ec45018e6" translate="yes" xml:space="preserve">
          <source>Allows a sandboxed document to open new windows without forcing the sandboxing flags upon them. This will allow, for example, a third-party advertisement to be safely sandboxed without forcing the same restrictions upon a landing page.</source>
          <target state="translated">샌드 박스 문서가 샌드 박스 플래그를 강제하지 않고 새 창을 열 수 있도록합니다. 예를 들어, 랜딩 페이지에 동일한 제한을 적용하지 않고 타사 광고를 안전하게 샌드 박스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd9d1abd82bff4013e4d8b034e274de5b3c1cd64" translate="yes" xml:space="preserve">
          <source>Allows a server to declare an embedder policy for a given document.</source>
          <target state="translated">서버가 주어진 문서에 대한 임 베더 정책을 선언하도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="5c9b4234b2a3be8eb41cdf957e42821c7296b4df" translate="yes" xml:space="preserve">
          <source>Allows embedders to have control over whether an iframe can start a presentation session.</source>
          <target state="translated">임 베더가 iframe이 프리젠 테이션 세션을 시작할 수 있는지 여부를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc5d5f3bfec8b9763df60e08f7fe09fc818a1534" translate="yes" xml:space="preserve">
          <source>Allows enabling specific inline &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Event_handlers&quot;&gt;event handlers&lt;/a&gt;. If you only need to allow inline event handlers and not inline &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements or &lt;code&gt;javascript:&lt;/code&gt; URLs, this is a safer method than using the &lt;code&gt;unsafe-inline&lt;/code&gt; expression.</source>
          <target state="translated">특정 인라인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Event_handlers&quot;&gt;이벤트 핸들러를&lt;/a&gt; 활성화 할 수 있습니다. 인라인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 또는 &lt;code&gt;javascript:&lt;/code&gt; URL이 아닌 인라인 이벤트 핸들러 만 허용해야하는 경우 &lt;code&gt;unsafe-inline&lt;/code&gt; 표현식을 사용하는 것보다 더 안전한 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="c2dccfc3d16fbd6966ea66bf8065e453d70002c8" translate="yes" xml:space="preserve">
          <source>Allows for creating policies with a name that was already used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a6156330c202b6a59a4dd9cbf9d1fc74688899" translate="yes" xml:space="preserve">
          <source>Allows for downloads to occur without a gesture from the user.</source>
          <target state="translated">사용자의 제스처없이 다운로드를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23a9b362468a49f0fc591066164c814185eb3f1f" translate="yes" xml:space="preserve">
          <source>Allows popups (like from &lt;code&gt;window.open&lt;/code&gt;, &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt;, &lt;code&gt;showModalDialog&lt;/code&gt;). If this keyword is not used, that functionality will silently fail.</source>
          <target state="translated">팝업을 허용합니다 (예 : &lt;code&gt;window.open&lt;/code&gt; , &lt;code&gt;target=&quot;_blank&quot;&lt;/code&gt; , &lt;code&gt;showModalDialog&lt;/code&gt; ). 이 키워드를 사용하지 않으면 해당 기능이 자동으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="772ca43b3ac605b73ba1b10b87801c9eb255da4d" translate="yes" xml:space="preserve">
          <source>Allows servers to assert that a cookie ought not to be sent along with cross-site requests, which provides some protection against cross-site request forgery attacks (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSRF&quot;&gt;CSRF&lt;/a&gt;).</source>
          <target state="translated">서버가 사이트 간 요청과 함께 쿠키를 보내지 않아야한다고 주장 할 수 있으며, 이는 사이트 간 요청 위조 공격 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSRF&quot;&gt;CSRF&lt;/a&gt; ) 에 대한 보호 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="8884a66b5c1071e7a925fac5c26c615146d4a1b8" translate="yes" xml:space="preserve">
          <source>Allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements, which prevents the use of misissued certificates for that site from going unnoticed. When a site enables the Expect-CT header, they are requesting that Chrome check that any certificate for that site appears in public CT logs.</source>
          <target state="translated">사이트에서 인증서 투명성 요구 사항보고 및 / 또는 시행을 허용하여 해당 사이트에 대해 잘못 발급 된 인증서를 사용하지 못하도록합니다. 사이트에서 Expect-CT 헤더를 사용하도록 설정하면 Chrome에서 해당 사이트의 인증서가 공개 CT 로그에 표시되는지 확인하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="0410e69274a5c7230756b0a2cd3597d21bf3033b" translate="yes" xml:space="preserve">
          <source>Allows sites to opt in to reporting and/or enforcement of Certificate Transparency requirements.</source>
          <target state="translated">사이트에서 인증서 투명성 요구 사항보고 및 / 또는 시행을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d5d66c72c2c3237333bd488a07baf5da98b6794" translate="yes" xml:space="preserve">
          <source>Allows the content to be treated as being from its normal origin. If this keyword is not used, the embedded content is treated as being from a unique origin.</source>
          <target state="translated">콘텐츠가 원래 출처에서 온 것으로 취급되도록합니다. 이 키워드를 사용하지 않으면 포함 된 컨텐츠는 고유 한 출처에서 온 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="741605ef4e45ee0618904121cc3fd5f417c8880d" translate="yes" xml:space="preserve">
          <source>Allows the embedded browsing context to disable the ability to lock the screen orientation.</source>
          <target state="translated">내장 된 브라우징 컨텍스트가 화면 방향을 잠그는 기능을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a01ecc6028bdc4a32cc774eaf65dc48562b4acc1" translate="yes" xml:space="preserve">
          <source>Allows the embedded browsing context to navigate (load) content to the top-level browsing context. If this keyword is not used, this operation is not allowed.</source>
          <target state="translated">포함 된 탐색 컨텍스트가 최상위 탐색 컨텍스트로 컨텐츠를 탐색 (로드) 할 수 있도록합니다. 이 키워드를 사용하지 않으면이 작업이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf9916914f8c66adba9d7f2f9c9a589c27a1dda4" translate="yes" xml:space="preserve">
          <source>Allows the embedded browsing context to open modal windows.</source>
          <target state="translated">임베디드 브라우징 컨텍스트가 모달 창을 열 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="d0f95216587dc88511ecf6c58e7bdf8112265979" translate="yes" xml:space="preserve">
          <source>Allows the embedded browsing context to run scripts (but not create pop-up windows). If this keyword is not used, this operation is not allowed.</source>
          <target state="translated">임베드 된 찾아보기 컨텍스트가 스크립트를 실행할 수 있도록 허용하지만 팝업 창은 작성하지 않습니다. 이 키워드를 사용하지 않으면이 작업이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0419c62683b1201e44580c6c185018bb2fc4aa4a" translate="yes" xml:space="preserve">
          <source>Allows the embedded browsing context to submit forms. If this keyword is not used, this operation is not allowed.</source>
          <target state="translated">임베드 된 찾아보기 컨텍스트가 양식을 제출할 수 있도록합니다. 이 키워드를 사용하지 않으면이 작업이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f2c89b61af6c6f17a8c09714a97165e2cf23d19e" translate="yes" xml:space="preserve">
          <source>Allows the embedded browsing context to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/WebAPI/Pointer_Lock&quot;&gt;Pointer Lock API&lt;/a&gt;.</source>
          <target state="translated">임베디드 브라우징 컨텍스트가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/WebAPI/Pointer_Lock&quot;&gt;Pointer Lock API&lt;/a&gt; 를 사용할 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="d47be6416ef63d9adb3f32563ed73e211a7ca688" translate="yes" xml:space="preserve">
          <source>Allows the page to disable the ability to lock the screen orientation.</source>
          <target state="translated">페이지가 화면 방향을 잠그는 기능을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33838b0859b41b03a423bfc2b34752d52297549b" translate="yes" xml:space="preserve">
          <source>Allows the page to navigate (load) content to the top-level browsing context. If this keyword is not used, this operation is not allowed.</source>
          <target state="translated">페이지가 콘텐츠를 최상위 브라우징 컨텍스트로 탐색 (로드) 할 수 있도록합니다. 이 키워드를 사용하지 않으면이 작업이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="efefb75a2a3ce03432240765afc717dab3a1111d" translate="yes" xml:space="preserve">
          <source>Allows the page to open modal windows.</source>
          <target state="translated">페이지에서 모달 창을 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33d2730a7964a8927d460300290addb305c20e3b" translate="yes" xml:space="preserve">
          <source>Allows the page to run scripts (but not create pop-up windows). If this keyword is not used, this operation is not allowed.</source>
          <target state="translated">페이지에서 스크립트를 실행하도록 허용합니다 (팝업 창을 만들지는 않음). 이 키워드를 사용하지 않으면이 작업이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2a9a180c669b480f86657cd6f967b3c5b030d21" translate="yes" xml:space="preserve">
          <source>Allows the page to submit forms. If this keyword is not used, this operation is not allowed.</source>
          <target state="translated">페이지에서 양식을 제출할 수 있습니다. 이 키워드를 사용하지 않으면이 작업이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2f5ac4d66b40e0417e5931f2cd52e670042101b" translate="yes" xml:space="preserve">
          <source>Allows the page to use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/WebAPI/Pointer_Lock&quot;&gt;Pointer Lock API&lt;/a&gt;.</source>
          <target state="translated">페이지가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/WebAPI/Pointer_Lock&quot;&gt;포인터 잠금 API&lt;/a&gt; 를 사용하도록 허용합니다. .</target>
        </trans-unit>
        <trans-unit id="fa9af97868bcd3e0e5abf7dded6f81f5e4562003" translate="yes" xml:space="preserve">
          <source>Allows the sender to include additional fields at the end of chunked message.</source>
          <target state="translated">보낸 사람이 청크 된 메시지 끝에 추가 필드를 포함 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="08a8ebd4fc62c0a4cb8521f9866243f0e1c6ea8b" translate="yes" xml:space="preserve">
          <source>Allows the use of &lt;code&gt;eval()&lt;/code&gt; and similar methods for creating code from strings. You must include the single quotes.</source>
          <target state="translated">사용 허용 &lt;code&gt;eval()&lt;/code&gt; 및 문자열의 코드를 생성하기위한 유사한 방법. 작은 따옴표를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="01d7fdad360cfdc2e901b1df4a68463e1a02b8e8" translate="yes" xml:space="preserve">
          <source>Allows the use of inline resources, such as inline &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, &lt;code&gt;javascript:&lt;/code&gt; URLs, inline event handlers, and inline &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; elements. The single quotes are required.</source>
          <target state="translated">인라인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소, &lt;code&gt;javascript:&lt;/code&gt; URL, 인라인 이벤트 핸들러 및 인라인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 와 같은 인라인 리소스를 사용할 수 있습니다 . 작은 따옴표가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2cd1bd87864a04cf3add283dce271e5f814f1e28" translate="yes" xml:space="preserve">
          <source>Allows the use of inline resources, such as inline &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, &lt;code&gt;javascript:&lt;/code&gt; URLs, inline event handlers, and inline &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; elements. You must include the single quotes.</source>
          <target state="translated">인라인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소, &lt;code&gt;javascript:&lt;/code&gt; URL, 인라인 이벤트 핸들러 및 인라인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 와 같은 인라인 자원을 사용할 수 있습니다 . 작은 따옴표를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="51e3ac5152db55dda9ebbbe8483aa28291ace912" translate="yes" xml:space="preserve">
          <source>Allows web developers to experiment with policies by monitoring (but not enforcing) their effects. These violation reports consist of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; documents sent via an HTTP &lt;code&gt;POST&lt;/code&gt; request to the specified URI.</source>
          <target state="translated">웹 개발자는 효과를 모니터링 (강제하지는 않음)하여 정책을 실험 할 수 있습니다. 이러한 위반 보고서 는 HTTP &lt;code&gt;POST&lt;/code&gt; 요청을 통해 지정된 URI로 전송 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; 문서로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="84ad2a25c230050cfbdb31526527d5fcf1288905" translate="yes" xml:space="preserve">
          <source>Allows web developers to experiment with policies by monitoring, but not enforcing, their effects. These violation reports consist of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; documents sent via an HTTP &lt;code&gt;POST&lt;/code&gt; request to the specified URI.</source>
          <target state="translated">웹 개발자가 정책의 효과를 모니터링하되 시행하지는 않음으로써 정책을 실험 할 수 있습니다. 이러한 위반 보고서 는 HTTP &lt;code&gt;POST&lt;/code&gt; 요청을 통해 지정된 URI로 전송 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/JSON&quot;&gt;JSON&lt;/a&gt; 문서로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c57719b8c00db1084bb9759e63a3f932a7629f6" translate="yes" xml:space="preserve">
          <source>Also try to move less relevant/important information down to the bottom and group the page's content together meaningfully. Although it is off-topic, perhaps the following detailed example might give you insights and ideas that persuade you to forgo user agent sniffing. Let us imagine a page composed of boxes of information; each box is about a different feline breed or canine breed. Each box has an image, an overview, and a historical funfact. The pictures are kept to a maximum reasonable size even on large screens. For the purposes of grouping the content meaningfully, all the cat boxes are separated from all the dog boxes such that the cat and dog boxes are not intermixed together. On a large screen, it saves space to have multiple columns to reduce the space wasted to the left and to the right of the pictures. The boxes can be separated into multiple columns via two equally fair method. From this point on, we shall assume that all the dog boxes are at the top of the source code, that all the cat boxes are at the bottom of the source code, and that all these boxes have the same parent element. There a single instance of a dog box immediately above a cat box, of course. The first method uses horizontal &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox&quot;&gt;Flexboxes&lt;/a&gt; to group the content such that when the page is displayed to the end user, all the dogs boxes are at the top of the page and all the cat boxes are lower on the page. The second method uses a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Layout_cookbook/Column_layouts&quot;&gt;Column&lt;/a&gt; layout and resents all the dogs to the left and all the cats to the right. Only in this particular scenario, it is appropriate to provide no fallback for the flexboxes/multicolumns, resulting in a single column of very wide boxes on old browsers. Also consider the following. If more people visit the webpage to see the cats, then it might be a good idea to put all the cats higher in the source code than the dogs so that more people can find what they are looking for faster on smaller screens where the content collapses down to one column.</source>
          <target state="translated">또한 관련성이 낮거나 중요하지 않은 정보를 맨 아래로 이동하고 페이지의 콘텐츠를 의미있게 그룹화하십시오. 주제에서 벗어난 내용이지만 다음의 자세한 예제는 사용자 에이전트 스니핑을 포기하도록 설득하는 통찰력과 아이디어를 제공 할 수 있습니다. 정보 상자로 구성된 페이지를 상상해 봅시다. 각 상자는 다른 고양이 품종 또는 개 품종에 관한 것입니다. 각 상자에는 이미지, 개요 및 역사적 사실이 있습니다. 사진은 큰 화면에서도 합리적인 최대 크기로 유지됩니다. 콘텐츠를 의미있게 그룹화하기 위해 모든 고양이 상자를 모든 개 상자와 분리하여 고양이 상자와 개 상자가 서로 섞이지 않도록합니다. 큰 화면에서는 사진의 왼쪽과 오른쪽에 낭비되는 공간을 줄이기 위해 여러 개의 열이있는 공간을 절약합니다.두 개의 동일하게 공정한 방법을 통해 상자를 여러 열로 분리 할 수 ​​있습니다. 이 시점부터 우리는 모든 개 상자가 소스 코드의 맨 위에 있고, 모든 고양이 상자가 소스 코드의 맨 아래에 있으며,이 모든 상자가 동일한 부모 요소를 가지고 있다고 가정합니다. 물론 고양이 상자 바로 위에 개 상자가 하나 있습니다. 첫 번째 방법은 수평&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox&quot;&gt;&lt;/a&gt;페이지가 최종 사용자에게 표시 될 때 모든 개 상자가 페이지 상단에 있고 모든 고양이 상자가 페이지 하단에 있도록 콘텐츠를 그룹화하는 Flexbox 입니다. 두 번째 방법은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/Layout_cookbook/Column_layouts&quot;&gt;열&lt;/a&gt; 레이아웃을 사용하고 모든 개를 왼쪽으로, 모든 고양이를 오른쪽으로 다시 보냅니다. 이 특정 시나리오에서만 플렉스 박스 / 다중 열에 대한 폴백을 제공하지 않는 것이 적절합니다. 따라서 이전 브라우저에서는 매우 넓은 상자의 단일 열이 생성됩니다. 다음 사항도 고려하십시오. 더 많은 사람들이 고양이를보기 위해 웹 페이지를 방문한다면, 더 많은 사람들이 콘텐츠가 축소되는 작은 화면에서 원하는 것을 더 빨리 찾을 수 있도록 모든 고양이를 개보다 소스 코드에서 더 높게 배치하는 것이 좋습니다. 한 열로 내려갑니다.</target>
        </trans-unit>
        <trans-unit id="197ef715f3c646e6b397719edb24cab181a5e5e8" translate="yes" xml:space="preserve">
          <source>Also, by default, prefetching of embedded link hostnames is not performed on documents loaded over &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt;. On Firefox, this can be changed by setting the &lt;code&gt;network.dns.disablePrefetchFromHTTPS&lt;/code&gt; preference to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">또한 기본적으로 내장 링크 호스트 이름의 프리 페치는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS를&lt;/a&gt; 통해로드 된 문서에서 수행되지 않습니다 . Firefox에서는 &lt;code&gt;network.dns.disablePrefetchFromHTTPS&lt;/code&gt; 환경 설정을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2786b01f7fddba1a4761b75f4be96f18c612dfea" translate="yes" xml:space="preserve">
          <source>Also, pay attention not to use a simple regular expression on the BrowserName, user agents also contain strings outside the Keyword/Value syntax. Safari &amp;amp; Chrome contain the string 'like Gecko', for instance.</source>
          <target state="translated">또한 BrowserName에서 간단한 정규식을 사용하지 않도록주의하십시오. 사용자 에이전트에는 키워드 / 값 구문 외부의 문자열도 포함되어 있습니다. 예를 들어 Safari &amp;amp; Chrome에는 'like Gecko'와 같은 문자열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a39f383ce421cfb82712ee700637b63b224f71b2" translate="yes" xml:space="preserve">
          <source>Alt-Svc</source>
          <target state="translated">Alt-Svc</target>
        </trans-unit>
        <trans-unit id="969f9938b9e9ad46cc407e83f40599f28ad451b1" translate="yes" xml:space="preserve">
          <source>Alternative way of specifying redirections</source>
          <target state="translated">리디렉션을 지정하는 다른 방법</target>
        </trans-unit>
        <trans-unit id="aafaa60231bd948348513cfbf048fba3ee9420b0" translate="yes" xml:space="preserve">
          <source>Alternatively, a &lt;code&gt;noreferrer&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types&quot;&gt;link relation&lt;/a&gt; on an &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;area&lt;/code&gt;, or &lt;code&gt;link&lt;/code&gt; element can be set:</source>
          <target state="translated">또는 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;area&lt;/code&gt; 또는 &lt;code&gt;link&lt;/code&gt; 요소 에 대한 &lt;code&gt;noreferrer&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types&quot;&gt;링크 관계&lt;/a&gt; 를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28d99eac48e2150a7854ebf5ed41a547fcb7ff26" translate="yes" xml:space="preserve">
          <source>Alternatively, a &lt;code&gt;noreferrer&lt;/code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types&quot;&gt;link relation&lt;/a&gt; on an a, area, or link element can be set:</source>
          <target state="translated">또는 a, area 또는 link 요소 의 &lt;code&gt;noreferrer&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types&quot;&gt;링크 관계&lt;/a&gt; 를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a8e3d200820a58b6e0b8358c248b25476e1c5f5" translate="yes" xml:space="preserve">
          <source>Alternatively, in newer versions:</source>
          <target state="translated">또는 최신 버전에서 :</target>
        </trans-unit>
        <trans-unit id="a9bb9cbc60c02f0889f6ac3194244c3ea1b935e7" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element can be used to configure a policy, for example: &lt;code&gt;&amp;lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src 'self'; img-src https://*; child-src 'none';&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 사용하여 정책을 구성 할 수 있습니다 (예 : &lt;code&gt;&amp;lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src 'self'; img-src https://*; child-src 'none';&quot;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb21b29ffd21c7c82658bce444d0d375ea5eb7ac" translate="yes" xml:space="preserve">
          <source>Alternatively, you can create hashes from your inline scripts. CSP supports sha256, sha384 and sha512.</source>
          <target state="translated">또는 인라인 스크립트에서 해시를 만들 수 있습니다. CSP는 sha256, sha384 및 sha512를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c96489cbf1e84a29d50323c0d62b764cf352a52a" translate="yes" xml:space="preserve">
          <source>Alternatively, you can create hashes from your inline styles. CSP supports sha256, sha384 and sha512.</source>
          <target state="translated">또는 인라인 스타일에서 해시를 만들 수 있습니다. CSP는 sha256, sha384 및 sha512를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="52a25e02a82ef60d93cd242f5fb2c709e891fe3d" translate="yes" xml:space="preserve">
          <source>Alternatively, you can create hashes from your inline styles. CSP supports sha256, sha384 and sha512. The &lt;strong&gt;binary&lt;/strong&gt; form of the hash has to be encoded with base64. You can obtain the hash of a string on the command line via the &lt;code&gt;openssl&lt;/code&gt; program:</source>
          <target state="translated">또는 인라인 스타일에서 해시를 만들 수 있습니다. CSP는 sha256, sha384 및 sha512를 지원합니다. 해시 의 &lt;strong&gt;이진&lt;/strong&gt; 형식은 base64로 인코딩해야합니다. &lt;code&gt;openssl&lt;/code&gt; 프로그램을 통해 명령 줄에서 문자열의 해시를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c45516a24ea8f0e4a83ad34f9d135e93d5d83f7b" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use frameguard directly:</source>
          <target state="translated">또는 프레임 가드를 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7028d055906f785a2824cddbc861da7d354ff8c" translate="yes" xml:space="preserve">
          <source>Although &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_request_header&quot;&gt;CORS-safelisted request headers&lt;/a&gt; are always allowed and don't usually need to be listed in &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;, listing them anyway will circumvent the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_request_header#Additional_restrictions&quot;&gt;additional restrictions&lt;/a&gt; that apply.</source>
          <target state="translated">하지만 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_request_header&quot;&gt;CORS - safelisted 요청 헤더는&lt;/a&gt; 항상 사용할 수 있으며 일반적으로 나열 할 필요가 없습니다 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 우회 것이다 어쨌든 목록, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_request_header#Additional_restrictions&quot;&gt;추가 제한&lt;/a&gt; 이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c1557091a03ff09f7dee02267939f1e7e6affdd2" translate="yes" xml:space="preserve">
          <source>Although Firefox supports &lt;code&gt;data&lt;/code&gt; URLs of essentially unlimited length, browsers are not required to support any particular maximum length of data. For example, the Opera 11 browser limited URLs to 65535 characters long which limits &lt;code&gt;data&lt;/code&gt; URLs to 65529 characters (65529 characters being the length of the encoded data, not the source, if you use the plain &lt;code&gt;data:&lt;/code&gt;, without specifying a MIME type).</source>
          <target state="translated">Firefox는 기본적으로 무제한 길이의 &lt;code&gt;data&lt;/code&gt; URL을 지원하지만 브라우저는 특정 최대 길이의 데이터를 지원하지 않아도됩니다. 예를 들어, Opera 11 브라우저는 URL을 65535 자로 제한하여 &lt;code&gt;data&lt;/code&gt; URL을 65529 자로 제한 합니다 (65529 자는 MIME 유형을 지정하지 않고 일반 &lt;code&gt;data:&lt;/code&gt; 를 사용하는 경우 소스가 아닌 인코딩 된 데이터의 길이입니다 ).</target>
        </trans-unit>
        <trans-unit id="95896d4301d000a02f900c6b86de14488ddbcde0" translate="yes" xml:space="preserve">
          <source>Although fragment identifiers used within URI references are not sent
   in requests, implementers ought to be aware that they will be visible
   to the user agent and any extensions or scripts running as a result
   of the response.  In particular, when a redirect occurs and the
   original request's fragment identifier is inherited by the new
   reference in Location (&lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;), this might have the effect of
   disclosing one site's fragment to another site.  If the first site
   uses personal information in fragments, it ought to ensure that
   redirects to other sites include a (possibly empty) fragment
   component in order to block that inheritance.</source>
          <target state="translated">URI 참조 내에서 사용되는 프래그먼트 식별자는 요청으로 전송되지 않지만 구현자는 사용자 에이전트와 응답의 결과로 실행되는 확장 또는 스크립트에 표시 될 것임을 알고 있어야합니다. 특히 리디렉션이 발생하고 원래 요청의 조각 식별자가 Location ( &lt;a href=&quot;#section-7.1.2&quot;&gt;7.1.2 절&lt;/a&gt; ) 의 새로운 참조에 의해 상속 될 경우, 한 사이트의 조각을 다른 사이트에 공개하는 효과가있을 수 있습니다. 첫 번째 사이트가 조각에 개인 정보를 사용하는 경우 해당 상속을 차단하기 위해 다른 사이트로의 리디렉션에 비어있는 조각 구성 요소가 포함되어 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="31287a55ab92ee46df59edd609b16221b3daba2a" translate="yes" xml:space="preserve">
          <source>Although it is &lt;strong&gt;strongly discouraged&lt;/strong&gt; by Mozilla, some handset manufacturers unfortunately include a token in their device's UA string that represents their device id. If this is the case, the Firefox OS UA string will look like the device-specific string in the table above, where &lt;em&gt;&lt;strong&gt;nnnn;&lt;/strong&gt;&lt;/em&gt; is the manufacturer's code for the device (see &lt;a href=&quot;https://wiki.mozilla.org/B2G/User_Agent/Device_Model_Inclusion_Requirements&quot;&gt;Guidelines&lt;/a&gt;). Some of them we have noticed are of the form &quot;&lt;strong&gt;NexusOne;&lt;/strong&gt;&quot;, &quot;&lt;strong&gt;ZTEOpen;&lt;/strong&gt;&quot;, or &quot;&lt;strong&gt;Open C;&lt;/strong&gt;&quot; (note that putting space is also discouraged). We provide this information to assist with your UA detection logic, but Mozilla discourages the detection of a device id in UA strings.</source>
          <target state="translated">모질라 가 &lt;strong&gt;권장&lt;/strong&gt; 하지는 않지만 , 일부 핸드셋 제조업체는 장치 ID를 나타내는 토큰을 장치의 UA 문자열에 포함시킵니다. 이 경우 Firefox OS UA 문자열은 위 표의 장치 별 문자열과 같습니다 (여기서 &lt;em&gt;&lt;strong&gt;nnnn;&lt;/strong&gt;&lt;/em&gt; 장치 제조업체의 코드입니다 ( &lt;a href=&quot;https://wiki.mozilla.org/B2G/User_Agent/Device_Model_Inclusion_Requirements&quot;&gt;지침&lt;/a&gt; 참조 ). 우리가 알아 &lt;strong&gt;낸&lt;/strong&gt; 것 중 일부는 &quot; &lt;strong&gt;NexusOne;&lt;/strong&gt; &quot;, &quot; &lt;strong&gt;ZTEOpen;&lt;/strong&gt; &quot;또는 &quot; &lt;strong&gt;Open C;&lt;/strong&gt; &quot;형식입니다 (공백 &lt;strong&gt;배치도&lt;/strong&gt; 권장하지 않음). UA 감지 논리를 지원하기 위해이 정보를 제공하지만 Mozilla는 UA 문자열에서 장치 ID 감지를 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d3b41d03b9a3434a867d7f122dd20caa1d4ef01" translate="yes" xml:space="preserve">
          <source>Although line 10 contains the Cookie destined for the content on &lt;code&gt;http://bar.other&lt;/code&gt;, if bar.other did not respond with an &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: true&lt;/code&gt; (line 17) the response would be ignored and not made available to web content.</source>
          <target state="translated">10 행에 &lt;code&gt;http://bar.other&lt;/code&gt; 의 콘텐츠로 향하는 쿠키가 포함되어 있지만 bar.other가 &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: true&lt;/code&gt; (17 행)로 응답하지 않으면 응답이 무시되고 사용할 수 없게됩니다. 웹 콘텐츠에.</target>
        </trans-unit>
        <trans-unit id="3e784d0202a94833f035a84e2685a288c242330e" translate="yes" xml:space="preserve">
          <source>Although line 11 contains the Cookie destined for the content on &lt;code&gt;http://bar.other&lt;/code&gt;, if bar.other did not respond with an &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: true&lt;/code&gt; (line 19) the response would be ignored and not made available to web content.</source>
          <target state="translated">11 행에는 &lt;code&gt;http://bar.other&lt;/code&gt; 의 컨텐츠로 향하는 쿠키가 포함되어 있지만 bar.other가 &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: true&lt;/code&gt; (19 행)로 응답하지 않으면 응답이 무시되고 사용할 수 없게됩니다. 웹 콘텐츠에.</target>
        </trans-unit>
        <trans-unit id="46a72e7d1df557890c548f429dfcfe446b549d89" translate="yes" xml:space="preserve">
          <source>Although the HTTP standard specifies &quot;unauthorized&quot;, semantically this response means &quot;unauthenticated&quot;. That is, the client must authenticate itself to get the requested response.</source>
          <target state="translated">HTTP 표준은 &quot;권한 없음&quot;을 지정하지만 의미 상이 응답은 &quot;인증되지 않음&quot;을 의미합니다. 즉, 요청 된 응답을 얻으려면 클라이언트가 자신을 인증해야합니다.</target>
        </trans-unit>
        <trans-unit id="772d6209abf255884251d1e63fc5494b4017ee80" translate="yes" xml:space="preserve">
          <source>Although the write locks provide some help in preventing lost
   updates, they cannot guarantee that updates will never be lost.
   Consider the following scenario:

   Two clients A and B are interested in editing the resource
   'index.html'.  Client A is an HTTP client rather than a WebDAV
   client, and so does not know how to perform locking.

   Client A doesn't lock the document, but does a GET, and begins
   editing.

   Client B does LOCK, performs a GET and begins editing.

   Client B finishes editing, performs a PUT, then an UNLOCK.

   Client A performs a PUT, overwriting and losing all of B's changes.

   There are several reasons why the WebDAV protocol itself cannot
   prevent this situation.  First, it cannot force all clients to use
   locking because it must be compatible with HTTP clients that do not
   comprehend locking.  Second, it cannot require servers to support
   locking because of the variety of repository implementations, some of
   which rely on reservations and merging rather than on locking.
   Finally, being stateless, it cannot enforce a sequence of operations
   like LOCK / GET / PUT / UNLOCK.

   WebDAV servers that support locking can reduce the likelihood that
   clients will accidentally overwrite each other's changes by requiring
   clients to lock resources before modifying them.  Such servers would
   effectively prevent HTTP 1.0 and HTTP 1.1 clients from modifying
   resources.

   WebDAV clients can be good citizens by using a lock / retrieve /
   write /unlock sequence of operations (at least by default) whenever
   they interact with a WebDAV server that supports locking. 

   HTTP 1.1 clients can be good citizens, avoiding overwriting other
   clients' changes, by using entity tags in If-Match headers with any
   requests that would modify resources.

   Information managers may attempt to prevent overwrites by
   implementing client-side procedures requiring locking before
   modifying WebDAV resources.</source>
          <target state="translated">쓰기 잠금은 업데이트 손실을 방지하는 데 도움이되지만 업데이트가 손실되지 않을 것이라고 보장 할 수는 없습니다. 다음 시나리오를 고려하십시오. 두 클라이언트 A와 B는 'index.html'자원 편집에 관심이 있습니다. 클라이언트 A는 WebDAV 클라이언트가 아닌 HTTP 클라이언트이므로 잠금을 수행하는 방법을 모릅니다. 클라이언트 A는 문서를 잠그지 않지만 GET을 수행하고 편집을 시작합니다. 클라이언트 B는 잠금을 수행하고 GET을 수행하며 편집을 시작합니다. 클라이언트 B는 편집을 마치고 PUT을 수행 한 다음 UNLOCK을 수행합니다. 클라이언트 A는 PUT을 수행하여 B의 모든 변경 사항을 덮어 쓰고 잃습니다. WebDAV 프로토콜 자체가이 상황을 막을 수없는 데에는 몇 가지 이유가 있습니다. 먼저,잠금을 이해하지 못하는 HTTP 클라이언트와 호환되어야하기 때문에 모든 클라이언트가 잠금을 사용하도록 강제 할 수는 없습니다. 둘째, 다양한 저장소 구현으로 인해 서버가 잠금을 지원하도록 요구할 수 없으며, 일부는 잠금이 아닌 예약 및 병합에 의존합니다. 마지막으로 상태 비 저장이므로 LOCK / GET / PUT / UNLOCK과 같은 일련의 작업을 시행 할 수 없습니다. 잠금을 지원하는 WebDAV 서버는 클라이언트가 리소스를 수정하기 전에 리소스를 잠그도록 요구함으로써 서로의 변경 사항을 실수로 덮어 쓸 가능성을 줄일 수 있습니다. 이러한 서버는 HTTP 1.0 및 HTTP 1.1 클라이언트가 자원을 수정하지 못하게 효과적으로 방지합니다.WebDAV 클라이언트는 잠금을 지원하는 WebDAV 서버와 상호 작용할 때마다 잠금 / 검색 / 쓰기 / 잠금 해제 작업 순서를 사용하여 (최소한 기본적으로) 시민이 될 수 있습니다. HTTP 1.1 클라이언트는 자원을 수정하는 요청과 함께 If-Match 헤더의 엔티티 태그를 사용하여 다른 클라이언트의 변경 사항을 겹쳐 쓰지 않고 좋은 시민이 될 수 있습니다. 정보 관리자는 WebDAV 자원을 수정하기 전에 잠금이 필요한 클라이언트 측 프로 시저를 구현하여 겹쳐 쓰기를 방지하려고 시도 할 수 있습니다.정보 관리자는 WebDAV 자원을 수정하기 전에 잠금이 필요한 클라이언트 측 프로 시저를 구현하여 겹쳐 쓰기를 방지하려고 시도 할 수 있습니다.정보 관리자는 WebDAV 자원을 수정하기 전에 잠금이 필요한 클라이언트 측 프로 시저를 구현하여 겹쳐 쓰기를 방지하려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae6fcea0d3527546dbc2efecb9c0488c56577892" translate="yes" xml:space="preserve">
          <source>Although this document specifies the requirements for the generation
   of HTTP/1.1 messages, not all applications will be correct in their
   implementation. We therefore recommend that operational applications
   be tolerant of deviations whenever those deviations can be
   interpreted unambiguously.

   Clients SHOULD be tolerant in parsing the Status-Line and servers
   tolerant when parsing the Request-Line. In particular, they SHOULD
   accept any amount of SP or HT characters between fields, even though
   only a single SP is required.

   The line terminator for message-header fields is the sequence CRLF.
   However, we recommend that applications, when parsing such headers,
   recognize a single LF as a line terminator and ignore the leading CR.

   The character set of an entity-body SHOULD be labeled as the lowest
   common denominator of the character codes used within that body, with
   the exception that not labeling the entity is preferred over labeling
   the entity with the labels US-ASCII or ISO-8859-1. See &lt;a href=&quot;#section-3.7.1&quot;&gt;section 3.7.1&lt;/a&gt;
   and 3.4.1.

   Additional rules for requirements on parsing and encoding of dates
   and other potential problems with date encodings include:

      - HTTP/1.1 clients and caches SHOULD assume that an &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC-850&lt;/a&gt; date
        which appears to be more than 50 years in the future is in fact
        in the past (this helps solve the &quot;year 2000&quot; problem).

      - An HTTP/1.1 implementation MAY internally represent a parsed
        Expires date as earlier than the proper value, but MUST NOT
        internally represent a parsed Expires date as later than the
        proper value.

      - All expiration-related calculations MUST be done in GMT. The
        local time zone MUST NOT influence the calculation or comparison
        of an age or expiration time. 

      - If an HTTP header incorrectly carries a date value with a time
        zone other than GMT, it MUST be converted into GMT using the
        most conservative possible conversion.</source>
          <target state="translated">이 문서는 HTTP / 1.1 메시지 생성에 대한 요구 사항을 명시하지만 모든 응용 프로그램이 구현에 올바른 것은 아닙니다. 따라서 운영 애플리케이션은 이러한 편차를 명확하게 해석 할 수있을 때마다 편차를 견딜 것을 권장합니다. 클라이언트는 요청 라인을 구문 분석 할 때 Status-Line을 구문 분석 할 때 허용되며 서버는 허용해야합니다. 특히 단일 SP 만 필요한 경우에도 필드간에 SP 또는 HT 문자를 허용해야합니다. 메시지 헤더 필드의 줄 종결자는 시퀀스 CRLF입니다. 그러나 이러한 헤더를 구문 분석 할 때 응용 프로그램은 단일 LF를 줄 종결 자로 인식하고 선행 CR을 무시하는 것이 좋습니다.엔터티 본문의 문자 집합은 해당 본문에 사용 된 문자 코드의 가장 작은 공통 분모로 레이블이 지정되어야합니다. 단, 레이블을 지정하지 않는 것이 US-ASCII 또는 ISO-8859- 1. 보다&lt;a href=&quot;#section-3.7.1&quot;&gt;섹션 3.7.1&lt;/a&gt; 및 3.4.1. 날짜 구문 분석 및 인코딩 요구 사항 및 날짜 인코딩의 기타 잠재적 문제점에 대한 추가 규칙은 다음과 같습니다.-HTTP / 1.1 클라이언트 및 캐시 &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC-850&lt;/a&gt;미래에 50 년 이상인 것으로 보이는 날짜는 실제로 과거입니다 ( &quot;2000 년 문제&quot;해결에 도움이 됨). -HTTP / 1.1 구현은 내부적으로 구문 분석 된 만료 날짜를 적절한 값보다 빠른 것으로 나타낼 수 있지만, 내부적으로 구문 분석 된 만료 날짜를 적절한 값보다 늦은 것으로 나타내서는 안됩니다. -모든 만료 관련 계산은 반드시 GMT에서 수행해야합니다. 현지 시간대는 연령 또는 만료 시간의 계산 또는 비교에 영향을 주어서는 안됩니다 (MUST NOT). -HTTP 헤더가 GMT 이외의 시간대로 날짜 값을 잘못 전달하는 경우 가장 보수적 인 변환을 사용하여 GMT로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="d7059fa05c2bada2fecf12f49096ca50d8fbd471" translate="yes" xml:space="preserve">
          <source>Although this status code is intended to describe a response with no body, servers may erroneously include data following the headers. The protocol allows user agents to vary in how they process such responses (&lt;a href=&quot;https://github.com/httpwg/http11bis/issues/26&quot;&gt;discussion regarding this specification text can be found here&lt;/a&gt;). This is observable in persistent connections, where the invalid body may include a distinct response to a subsequent request.</source>
          <target state="translated">이 상태 코드는 본문이없는 응답을 설명하기위한 것이지만 서버는 헤더 다음에 데이터를 잘못 포함 할 수 있습니다. 이 프로토콜을 통해 사용자 에이전트는 이러한 응답을 처리하는 방법이 다양합니다 ( &lt;a href=&quot;https://github.com/httpwg/http11bis/issues/26&quot;&gt;이 사양 텍스트에 대한 설명은 여기 참조&lt;/a&gt; ). 이는 유효하지 않은 본문이 후속 요청에 대한 고유 한 응답을 포함 할 수있는 영구 연결에서 관찰 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdf07a548d7dfec43b202a1786fb9188645f2387" translate="yes" xml:space="preserve">
          <source>Amazon Kindle eBook format</source>
          <target state="translated">아마존 킨들 전자 책 형식</target>
        </trans-unit>
        <trans-unit id="af7c29965f74dbcaf148b9acaea604efc27c6cbf" translate="yes" xml:space="preserve">
          <source>Ambient light sensor</source>
          <target state="translated">주변 광 센서</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="615b8c7998d5277881578a2abc74d98135448bfa" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;allowlist&lt;/code&gt; is a list of origins that takes one or more of the following values, separated by spaces:</source>
          <target state="translated">&lt;code&gt;allowlist&lt;/code&gt; 는 공간에 의해 분리 된 다음 값 중 하나 이상을 취 기원의 목록이다 :</target>
        </trans-unit>
        <trans-unit id="6b4e8bf14b8c6f1d264a99cfc4165e21e00334c4" translate="yes" xml:space="preserve">
          <source>An &lt;em&gt;&lt;a href=&quot;methods&quot;&gt;HTTP method&lt;/a&gt;&lt;/em&gt;, a verb (like &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;) or a noun (like &lt;a href=&quot;methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt;), that describes the action to be performed. For example, &lt;code&gt;GET&lt;/code&gt; indicates that a resource should be fetched or &lt;code&gt;POST&lt;/code&gt; means that data is pushed to the server (creating or modifying a resource, or generating a temporary document to send back).</source>
          <target state="translated">수행 할 조치를 설명 하는 &lt;em&gt;&lt;a href=&quot;methods&quot;&gt;HTTP 메소드&lt;/a&gt;&lt;/em&gt; , 동사 (예 : &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; ) 또는 명사 ( &lt;a href=&quot;methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; ). 예를 들어, &lt;code&gt;GET&lt;/code&gt; 은 자원을 페치해야 함을 나타내거나 &lt;code&gt;POST&lt;/code&gt; 는 데이터를 서버로 푸시 함 (자원을 작성 또는 수정하거나 임시 문서를 생성하여 다시 보내기)을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="86440ab578a3769337d5800e98b7fd98176177d7" translate="yes" xml:space="preserve">
          <source>An Atom Publishing Protocol Category Document, when serialized as XML
   1.0, can be identified with the following media type:

   MIME media type name:  application

   MIME subtype name:  atomcat+xml

   Required parameters:  None.

   Optional parameters:

      &quot;charset&quot;:  This parameter has identical semantics to the charset
         parameter of the &quot;application/xml&quot; media type as specified in
         [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;].

   Encoding considerations:  Identical to those of &quot;application/xml&quot; as
      described in &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-3.2&quot;&gt;[RFC3023], Section&amp;nbsp;3.2&lt;/a&gt;. 

   Security considerations:  As defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt;.

      In addition, as this media type uses the &quot;+xml&quot; convention, it
      shares the same security considerations as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-10&quot;&gt;[RFC3023],
      Section&amp;nbsp;10&lt;/a&gt;.

   Interoperability considerations:  There are no known interoperability
      issues.

   Published specification:  &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt;.

   Applications that use this media type:  No known applications
      currently use this media type.

   Additional information:

   Magic number(s):  As specified for &quot;application/xml&quot; in &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-3.2&quot;&gt;[RFC3023],
      Section&amp;nbsp;3.2&lt;/a&gt;.

   File extension:  .atomcat

   Fragment identifiers:  As specified for &quot;application/xml&quot; in
      &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-5&quot;&gt;[RFC3023], Section&amp;nbsp;5&lt;/a&gt;.

   Base URI:  As specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-6&quot;&gt;[RFC3023], Section&amp;nbsp;6&lt;/a&gt;.

   Macintosh file type code:  TEXT

   Person &amp;amp; email address to contact for further information:
      Joe Gregorio &amp;lt;joe@bitworking.org&amp;gt;

   Intended usage:  COMMON

   Author/Change controller:  IETF (iesg@ietf.org) Internet Engineering
      Task Force</source>
          <target state="translated">XML 1.0으로 직렬화 될 때 Atom Publishing Protocol 범주 문서는 다음 매체 유형으로 식별 할 수 있습니다. MIME 매체 유형 이름 : 애플리케이션 MIME 하위 유형 이름 : atomcat + xml 필수 매개 변수 : 없음. 선택적 매개 변수 : &quot;charset&quot;:이 매개 변수는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt; ]에 지정된 &quot;application / xml&quot;매체 유형의 charset 매개 변수와 동일한 의미를 갖습니다 . 인코딩 고려 사항 : &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-3.2&quot;&gt;[RFC3023], 섹션 3.2에&lt;/a&gt; 설명 된 &quot;application / xml&quot;과 동일합니다 . 보안 고려 사항 : &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023에&lt;/a&gt; 정의 된 대로 . 또한이 미디어 유형은 &quot;+ xml&quot;규칙을 사용하므로 &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-10&quot;&gt;[RFC3023]에&lt;/a&gt; 설명 된 것과 동일한 보안 고려 사항을 공유합니다 .섹션 10. 상호 운용성 고려 사항 : 알려진 상호 운용성 문제가 없습니다. 게시 된 사양 : &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt; . 이 매체 유형을 사용하는 응용 프로그램 : 현재이 매체 유형을 사용하는 알려진 응용 프로그램이 없습니다. 추가 정보 : 매직 번호 : &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-3.2&quot;&gt;[RFC3023], 섹션 3.2의&lt;/a&gt; &quot;application / xml&quot;에 지정된대로 . 파일 확장자 : .atomcat 조각 식별자 : &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-5&quot;&gt;[RFC3023], 섹션 5의&lt;/a&gt; &quot;application / xml&quot;에 지정된대로 . 기본 URI : &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-6&quot;&gt;[RFC3023], 섹션 6에&lt;/a&gt; 지정된대로. Macintosh 파일 유형 코드 : TEXT 추가 정보를 위해 연락 할 사람 및 이메일 주소 : Joe Gregorio &amp;lt;joe@bitworking.org&amp;gt; 용도 : COMMON 저자 / 제어기 : IETF (iesg@ietf.org) 인터넷 엔지니어링 태스크 포스</target>
        </trans-unit>
        <trans-unit id="cf6c4aedb53226da5214a23ca75c1a0eb3cafdc2" translate="yes" xml:space="preserve">
          <source>An Atom Publishing Protocol Service Document, when serialized as XML
   1.0, can be identified with the following media type:

   MIME media type name:  application

   MIME subtype name:  atomsvc+xml

   Required parameters:  None. 

   Optional parameters:

      &quot;charset&quot;:  This parameter has identical semantics to the charset
         parameter of the &quot;application/xml&quot; media type as specified in
         [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;].

   Encoding considerations:  Identical to those of &quot;application/xml&quot; as
      described in &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-3.2&quot;&gt;[RFC3023], Section&amp;nbsp;3.2&lt;/a&gt;.

   Security considerations:  As defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt;.

      In addition, as this media type uses the &quot;+xml&quot; convention, it
      shares the same security considerations as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-10&quot;&gt;[RFC3023],
      Section&amp;nbsp;10&lt;/a&gt;.

   Interoperability considerations:  There are no known interoperability
      issues.

   Published specification:  &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt;.

   Applications that use this media type:  No known applications
      currently use this media type.

   Additional information:

   Magic number(s):  As specified for &quot;application/xml&quot; in &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-3.2&quot;&gt;[RFC3023],
      Section&amp;nbsp;3.2&lt;/a&gt;.

   File extension:  .atomsvc

   Fragment identifiers:  As specified for &quot;application/xml&quot; in
      &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-5&quot;&gt;[RFC3023], Section&amp;nbsp;5&lt;/a&gt;.

   Base URI:  As specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-6&quot;&gt;[RFC3023], Section&amp;nbsp;6&lt;/a&gt;.

   Macintosh file type code:  TEXT

   Person and email address to contact for further information:  Joe
      Gregorio &amp;lt;joe@bitworking.org&amp;gt;

   Intended usage:  COMMON

   Author/Change controller:  IETF (iesg@ietf.org) Internet Engineering
      Task Force</source>
          <target state="translated">XML 1.0으로 직렬화 될 때 Atom Publishing Protocol Service Document는 다음 매체 유형으로 식별 할 수 있습니다. MIME 매체 유형 이름 : application MIME 하위 유형 이름 : atomsvc ​​+ xml 필수 매개 변수 : 없음. 선택적 매개 변수 : &quot;charset&quot;:이 매개 변수는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt; ]에 지정된 &quot;application / xml&quot;매체 유형의 charset 매개 변수와 동일한 의미를 갖습니다 . 인코딩 고려 사항 : &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-3.2&quot;&gt;[RFC3023], 섹션 3.2에&lt;/a&gt; 설명 된 &quot;application / xml&quot;과 동일합니다 . 보안 고려 사항 : &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023에&lt;/a&gt; 정의 된 대로 . 또한이 미디어 유형은 &quot;+ xml&quot;규칙을 사용하므로 &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-10&quot;&gt;[RFC3023]에&lt;/a&gt; 설명 된 것과 동일한 보안 고려 사항을 공유합니다 .섹션 10. 상호 운용성 고려 사항 : 알려진 상호 운용성 문제가 없습니다. 게시 된 사양 : &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt; . 이 매체 유형을 사용하는 응용 프로그램 : 현재이 매체 유형을 사용하는 알려진 응용 프로그램이 없습니다. 추가 정보 : 매직 번호 : &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-3.2&quot;&gt;[RFC3023], 섹션 3.2의&lt;/a&gt; &quot;application / xml&quot;에 지정된대로 . 파일 확장자 : .atomsvc ​​조각 식별자 : &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-5&quot;&gt;[RFC3023], 섹션 5의&lt;/a&gt; &quot;application / xml&quot;에 지정된대로 . 기본 URI : &lt;a href=&quot;https://tools.ietf.org/html/rfc3023#section-6&quot;&gt;[RFC3023], 섹션 6에&lt;/a&gt; 지정된대로. Macintosh 파일 유형 코드 : TEXT 추가 정보를 위해 연락 할 사람과 이메일 주소 : Joe Gregorio &amp;lt;joe@bitworking.org&amp;gt; 용도 : COMMON 저자 / 제어기 : IETF (iesg@ietf.org) 인터넷 엔지니어링 태스크 포스</target>
        </trans-unit>
        <trans-unit id="7254bd871c63a8e62a9d5239377ac0b3fc259331" translate="yes" xml:space="preserve">
          <source>An HTML document that executes a JavaScript alert. Note that the closing script tag is required.</source>
          <target state="translated">JavaScript 경고를 실행하는 HTML 문서입니다. 닫기 스크립트 태그가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="303f58f13dce71a0e7fad3c11eac5eff7ef589df" translate="yes" xml:space="preserve">
          <source>An HTML document with &lt;code&gt;&amp;lt;h1&amp;gt;Hello, World!&amp;lt;/h1&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;lt;h1&amp;gt;Hello, World!&amp;lt;/h1&amp;gt;&lt;/code&gt; 된 HTML 문서</target>
        </trans-unit>
        <trans-unit id="f190ae58e3762585b81fc8fc127a43daf1651695" translate="yes" xml:space="preserve">
          <source>An HTTP &lt;a href=&quot;methods&quot;&gt;method&lt;/a&gt;, usually a verb like &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or a noun like &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; that defines the operation the client wants to perform. Typically, a client wants to fetch a resource (using &lt;code&gt;GET&lt;/code&gt;) or post the value of an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML form&lt;/a&gt; (using &lt;code&gt;POST&lt;/code&gt;), though more operations may be needed in other cases.</source>
          <target state="translated">HTTP &lt;a href=&quot;methods&quot;&gt;메소드&lt;/a&gt; , 일반적으로 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 와 같은 동사 또는 &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 와 같은 명사 에서 클라이언트가 수행하려는 조작을 정의합니다. 일반적으로 클라이언트는 리소스를 가져 오거나 ( &lt;code&gt;GET&lt;/code&gt; 사용 ) &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML 형식&lt;/a&gt; 의 값을 게시 ( &lt;code&gt;POST&lt;/code&gt; 사용 )를 원하지만 다른 경우에는 더 많은 작업이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e084db9952eabe09407577846f46c517a44d7f7d" translate="yes" xml:space="preserve">
          <source>An HTTP Extension Framework</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224b4c4e69b1e3dc55d55f1ba353682c6c99e28c" translate="yes" xml:space="preserve">
          <source>An HTTP Status Code to Report Legal Obstacles</source>
          <target state="translated">법적 장애를보고하기위한 HTTP 상태 코드</target>
        </trans-unit>
        <trans-unit id="606a7f78aa2b9bb237bbb97da4be73cfcfdc8923" translate="yes" xml:space="preserve">
          <source>An HTTP message can be either a request from client to server or a
   response from server to client.  Syntactically, the two types of
   message differ only in the start-line, which is either a request-line
   (for requests) or a status-line (for responses), and in the algorithm
   for determining the length of the message body (&lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;). 

   In theory, a client could receive requests and a server could receive
   responses, distinguishing them by their different start-line formats,
   but, in practice, servers are implemented to only expect a request (a
   response is interpreted as an unknown or invalid request method) and
   clients are implemented to only expect a response.

     start-line     = request-line / status-line</source>
          <target state="translated">HTTP 메시지는 클라이언트에서 서버로의 요청이거나 서버에서 클라이언트로의 응답 일 수 있습니다. 문법적으로 두 가지 유형의 메시지는 요청 라인 (요청의 경우) 또는 상태 라인 (응답의 경우)과 메시지 본문의 길이를 결정하는 알고리즘 ( &lt;a href=&quot;#section-3.3&quot;&gt;섹션&lt;/a&gt; )에서만 다릅니다. 3.3 ). 이론적으로 클라이언트는 요청을 수신하고 서버는 다른 시작 라인 형식으로 구별하여 응답을 수신 할 수 있지만 실제로 서버는 요청 만 예상하도록 구현됩니다 (응답은 알 수 없거나 유효하지 않은 요청 방법으로 해석 됨) ) 및 고객은 응답 만 기대하도록 구현되었습니다. 시작 라인 = 요청 라인 / 상태 라인</target>
        </trans-unit>
        <trans-unit id="daaec2180aef0e0c15dca19ff80c20ef6a2edd19" translate="yes" xml:space="preserve">
          <source>An HTTP-date timestamp.</source>
          <target state="translated">HTTP 날짜 타임 스탬프</target>
        </trans-unit>
        <trans-unit id="bda182a3078d6fee0f6ff4a7deb6d570e58ba8a3" translate="yes" xml:space="preserve">
          <source>An HTTP/1.1 (or later) client sending a message-body SHOULD monitor
   the network connection for an error status while it is transmitting
   the request. If the client sees an error status, it SHOULD
   immediately cease transmitting the body. If the body is being sent
   using a &quot;chunked&quot; encoding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;), a zero length chunk and
   empty trailer MAY be used to prematurely mark the end of the message.
   If the body was preceded by a Content-Length header, the client MUST
   close the connection.</source>
          <target state="translated">메시지 본문을 전송하는 HTTP / 1.1 (또는 이후) 클라이언트는 네트워크 연결이 요청을 전송하는 동안 오류 상태를 모니터링해야합니다. 클라이언트가 오류 상태를 발견하면 즉시 본문 전송을 중단해야합니다. 본문이 &quot;청크&quot;인코딩을 사용하여 전송되는 경우 ( &lt;a href=&quot;#section-3.6&quot;&gt;섹션 3.6&lt;/a&gt; ) 길이가 0 인 청크와 빈 트레일러를 사용하여 메시지의 끝을 조기에 표시 할 수 있습니다. 본문 앞에 Content-Length 헤더가 있으면 클라이언트는 연결을 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="287c4eeafec6189b6edc5e8b172c0314056ae7c7" translate="yes" xml:space="preserve">
          <source>An HTTP/1.1 &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; is used as request method. In the case of a POST, the &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; of the request body is one of &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code&gt;multipart/form-data&lt;/code&gt;, or &lt;code&gt;text/plain.&lt;/code&gt;</source>
          <target state="translated">HTTP / 1.1 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 가 요청 방법으로 사용됩니다. POST의 경우 요청 본문 의 &lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; , &lt;code&gt;multipart/form-data&lt;/code&gt; 또는 &lt;code&gt;text/plain.&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="43150375aa6dfc8cbdc9d2576d9ab158a71ecc43" translate="yes" xml:space="preserve">
          <source>An HTTP/1.1 server MAY assume that a HTTP/1.1 client intends to
   maintain a persistent connection unless a Connection header including
   the connection-token &quot;close&quot; was sent in the request. If the server
   chooses to close the connection immediately after sending the
   response, it SHOULD send a Connection header including the
   connection-token close.

   An HTTP/1.1 client MAY expect a connection to remain open, but would
   decide to keep it open based on whether the response from a server
   contains a Connection header with the connection-token close. In case
   the client does not want to maintain a connection for more than that
   request, it SHOULD send a Connection header including the
   connection-token close.

   If either the client or the server sends the close token in the
   Connection header, that request becomes the last one for the
   connection.

   Clients and servers SHOULD NOT assume that a persistent connection is
   maintained for HTTP versions less than 1.1 unless it is explicitly
   signaled. See &lt;a href=&quot;#section-19.6.2&quot;&gt;section 19.6.2&lt;/a&gt; for more information on backward
   compatibility with HTTP/1.0 clients.

   In order to remain persistent, all messages on the connection MUST
   have a self-defined message length (i.e., one not defined by closure
   of the connection), as described in &lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;.</source>
          <target state="translated">HTTP / 1.1 서버는 연결 토큰 &quot;close&quot;를 포함하는 Connection 헤더가 요청에 전송되지 않는 한 HTTP / 1.1 클라이언트가 지속적인 연결을 유지하려고한다고 가정 할 수있다. 서버가 응답을 보낸 후 즉시 연결을 닫으려면 연결 토큰 닫기를 포함하여 연결 헤더를 보내야합니다. HTTP / 1.1 클라이언트는 연결이 열린 채로있을 것으로 예상 할 수 있지만 서버의 응답에 연결 토큰이 닫힌 연결 헤더가 포함되어 있는지 여부에 따라 열린 상태로 유지하기로 결정합니다. 클라이언트가 해당 요청보다 더 많은 연결을 유지하지 않으려면 연결 토큰 닫기를 포함하여 연결 헤더를 보내야합니다. 클라이언트 또는 서버가 연결 헤더에서 닫기 토큰을 보내는 경우,해당 요청이 연결의 마지막 요청이됩니다. 클라이언트와 서버는 명시 적으로 신호를 보내지 않는 한 1.1 미만의 HTTP 버전에 대해 지속적인 연결을 유지한다고 가정해서는 안됩니다. 보다&lt;a href=&quot;#section-19.6.2&quot;&gt;&lt;/a&gt;HTTP / 1.0 클라이언트와의 역 호환성에 대한 자세한 정보는 19.6.2 절 을 참조하십시오. 지속성을 유지하려면 &lt;a href=&quot;#section-4.4&quot;&gt;4.4 절&lt;/a&gt; 에서 설명한대로 연결의 모든 메시지에 자체 정의 된 메시지 길이 (즉, 연결을 닫을 때 정의되지 않은 메시지 길이)가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="26a5246f423e33fffe2547c2c151d27d85e6b13f" translate="yes" xml:space="preserve">
          <source>An HTTP/2 connection can demand a greater commitment of resources to
   operate than an HTTP/1.1 connection.  The use of header compression
   and flow control depend on a commitment of resources for storing a
   greater amount of state.  Settings for these features ensure that
   memory commitments for these features are strictly bounded. 

   The number of PUSH_PROMISE frames is not constrained in the same
   fashion.  A client that accepts server push SHOULD limit the number
   of streams it allows to be in the &quot;reserved (remote)&quot; state.  An
   excessive number of server push streams can be treated as a stream
   error (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) of type ENHANCE_YOUR_CALM.

   Processing capacity cannot be guarded as effectively as state
   capacity.

   The SETTINGS frame can be abused to cause a peer to expend additional
   processing time.  This might be done by pointlessly changing SETTINGS
   parameters, setting multiple undefined parameters, or changing the
   same setting multiple times in the same frame.  WINDOW_UPDATE or
   PRIORITY frames can be abused to cause an unnecessary waste of
   resources.

   Large numbers of small or empty frames can be abused to cause a peer
   to expend time processing frame headers.  Note, however, that some
   uses are entirely legitimate, such as the sending of an empty DATA or
   CONTINUATION frame at the end of a stream.

   Header compression also offers some opportunities to waste processing
   resources; see Section 7 of [&lt;a href=&quot;#ref-COMPRESSION&quot;&gt;COMPRESSION&lt;/a&gt;] for more details on
   potential abuses.

   Limits in SETTINGS parameters cannot be reduced instantaneously,
   which leaves an endpoint exposed to behavior from a peer that could
   exceed the new limits.  In particular, immediately after establishing
   a connection, limits set by a server are not known to clients and
   could be exceeded without being an obvious protocol violation.

   All these features -- i.e., SETTINGS changes, small frames, header
   compression -- have legitimate uses.  These features become a burden
   only when they are used unnecessarily or to excess.

   An endpoint that doesn't monitor this behavior exposes itself to a
   risk of denial-of-service attack.  Implementations SHOULD track the
   use of these features and set limits on their use.  An endpoint MAY
   treat activity that is suspicious as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type ENHANCE_YOUR_CALM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ee0ef68ac24c01079c045790e35074016c60661" translate="yes" xml:space="preserve">
          <source>An HTTP/2 connection is an application-layer protocol running on top
   of a TCP connection ([&lt;a href=&quot;#ref-TCP&quot;&gt;TCP&lt;/a&gt;]).  The client is the TCP connection
   initiator.

   HTTP/2 uses the same &quot;http&quot; and &quot;https&quot; URI schemes used by HTTP/1.1.
   HTTP/2 shares the same default port numbers: 80 for &quot;http&quot; URIs and
   443 for &quot;https&quot; URIs.  As a result, implementations processing
   requests for target resource URIs like &quot;http://example.org/foo&quot; or
   &quot;https://example.com/bar&quot; are required to first discover whether the
   upstream server (the immediate peer to which the client wishes to
   establish a connection) supports HTTP/2.

   The means by which support for HTTP/2 is determined is different for
   &quot;http&quot; and &quot;https&quot; URIs.  Discovery for &quot;http&quot; URIs is described in
   &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;.  Discovery for &quot;https&quot; URIs is described in &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6701a3501f8b2c3f6e37a5b1513ec20fdcb01fb9" translate="yes" xml:space="preserve">
          <source>An HTTP/2 implementation MAY treat the negotiation of any of the
   following cipher suites with TLS 1.2 as a connection error
   (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type INADEQUATE_SECURITY:

   o  TLS_NULL_WITH_NULL_NULL

   o  TLS_RSA_WITH_NULL_MD5

   o  TLS_RSA_WITH_NULL_SHA

   o  TLS_RSA_EXPORT_WITH_RC4_40_MD5

   o  TLS_RSA_WITH_RC4_128_MD5

   o  TLS_RSA_WITH_RC4_128_SHA

   o  TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5

   o  TLS_RSA_WITH_IDEA_CBC_SHA

   o  TLS_RSA_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_RSA_WITH_DES_CBC_SHA

   o  TLS_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_DH_DSS_WITH_DES_CBC_SHA

   o  TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA

   o  TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_DH_RSA_WITH_DES_CBC_SHA

   o  TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_DHE_DSS_WITH_DES_CBC_SHA

   o  TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA

   o  TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA 

   o  TLS_DHE_RSA_WITH_DES_CBC_SHA

   o  TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_DH_anon_EXPORT_WITH_RC4_40_MD5

   o  TLS_DH_anon_WITH_RC4_128_MD5

   o  TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA

   o  TLS_DH_anon_WITH_DES_CBC_SHA

   o  TLS_DH_anon_WITH_3DES_EDE_CBC_SHA

   o  TLS_KRB5_WITH_DES_CBC_SHA

   o  TLS_KRB5_WITH_3DES_EDE_CBC_SHA

   o  TLS_KRB5_WITH_RC4_128_SHA

   o  TLS_KRB5_WITH_IDEA_CBC_SHA

   o  TLS_KRB5_WITH_DES_CBC_MD5

   o  TLS_KRB5_WITH_3DES_EDE_CBC_MD5

   o  TLS_KRB5_WITH_RC4_128_MD5

   o  TLS_KRB5_WITH_IDEA_CBC_MD5

   o  TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA

   o  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA

   o  TLS_KRB5_EXPORT_WITH_RC4_40_SHA

   o  TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5

   o  TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5

   o  TLS_KRB5_EXPORT_WITH_RC4_40_MD5

   o  TLS_PSK_WITH_NULL_SHA

   o  TLS_DHE_PSK_WITH_NULL_SHA

   o  TLS_RSA_PSK_WITH_NULL_SHA 

   o  TLS_RSA_WITH_AES_128_CBC_SHA

   o  TLS_DH_DSS_WITH_AES_128_CBC_SHA

   o  TLS_DH_RSA_WITH_AES_128_CBC_SHA

   o  TLS_DHE_DSS_WITH_AES_128_CBC_SHA

   o  TLS_DHE_RSA_WITH_AES_128_CBC_SHA

   o  TLS_DH_anon_WITH_AES_128_CBC_SHA

   o  TLS_RSA_WITH_AES_256_CBC_SHA

   o  TLS_DH_DSS_WITH_AES_256_CBC_SHA

   o  TLS_DH_RSA_WITH_AES_256_CBC_SHA

   o  TLS_DHE_DSS_WITH_AES_256_CBC_SHA

   o  TLS_DHE_RSA_WITH_AES_256_CBC_SHA

   o  TLS_DH_anon_WITH_AES_256_CBC_SHA

   o  TLS_RSA_WITH_NULL_SHA256

   o  TLS_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_RSA_WITH_AES_256_CBC_SHA256

   o  TLS_DH_DSS_WITH_AES_128_CBC_SHA256

   o  TLS_DH_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_DHE_DSS_WITH_AES_128_CBC_SHA256

   o  TLS_RSA_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA

   o  TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA 

   o  TLS_DHE_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_DH_DSS_WITH_AES_256_CBC_SHA256

   o  TLS_DH_RSA_WITH_AES_256_CBC_SHA256

   o  TLS_DHE_DSS_WITH_AES_256_CBC_SHA256

   o  TLS_DHE_RSA_WITH_AES_256_CBC_SHA256

   o  TLS_DH_anon_WITH_AES_128_CBC_SHA256

   o  TLS_DH_anon_WITH_AES_256_CBC_SHA256

   o  TLS_RSA_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA

   o  TLS_PSK_WITH_RC4_128_SHA

   o  TLS_PSK_WITH_3DES_EDE_CBC_SHA

   o  TLS_PSK_WITH_AES_128_CBC_SHA

   o  TLS_PSK_WITH_AES_256_CBC_SHA

   o  TLS_DHE_PSK_WITH_RC4_128_SHA

   o  TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA

   o  TLS_DHE_PSK_WITH_AES_128_CBC_SHA

   o  TLS_DHE_PSK_WITH_AES_256_CBC_SHA

   o  TLS_RSA_PSK_WITH_RC4_128_SHA

   o  TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA

   o  TLS_RSA_PSK_WITH_AES_128_CBC_SHA 

   o  TLS_RSA_PSK_WITH_AES_256_CBC_SHA

   o  TLS_RSA_WITH_SEED_CBC_SHA

   o  TLS_DH_DSS_WITH_SEED_CBC_SHA

   o  TLS_DH_RSA_WITH_SEED_CBC_SHA

   o  TLS_DHE_DSS_WITH_SEED_CBC_SHA

   o  TLS_DHE_RSA_WITH_SEED_CBC_SHA

   o  TLS_DH_anon_WITH_SEED_CBC_SHA

   o  TLS_RSA_WITH_AES_128_GCM_SHA256

   o  TLS_RSA_WITH_AES_256_GCM_SHA384

   o  TLS_DH_RSA_WITH_AES_128_GCM_SHA256

   o  TLS_DH_RSA_WITH_AES_256_GCM_SHA384

   o  TLS_DH_DSS_WITH_AES_128_GCM_SHA256

   o  TLS_DH_DSS_WITH_AES_256_GCM_SHA384

   o  TLS_DH_anon_WITH_AES_128_GCM_SHA256

   o  TLS_DH_anon_WITH_AES_256_GCM_SHA384

   o  TLS_PSK_WITH_AES_128_GCM_SHA256

   o  TLS_PSK_WITH_AES_256_GCM_SHA384

   o  TLS_RSA_PSK_WITH_AES_128_GCM_SHA256

   o  TLS_RSA_PSK_WITH_AES_256_GCM_SHA384

   o  TLS_PSK_WITH_AES_128_CBC_SHA256

   o  TLS_PSK_WITH_AES_256_CBC_SHA384

   o  TLS_PSK_WITH_NULL_SHA256

   o  TLS_PSK_WITH_NULL_SHA384

   o  TLS_DHE_PSK_WITH_AES_128_CBC_SHA256 

   o  TLS_DHE_PSK_WITH_AES_256_CBC_SHA384

   o  TLS_DHE_PSK_WITH_NULL_SHA256

   o  TLS_DHE_PSK_WITH_NULL_SHA384

   o  TLS_RSA_PSK_WITH_AES_128_CBC_SHA256

   o  TLS_RSA_PSK_WITH_AES_256_CBC_SHA384

   o  TLS_RSA_PSK_WITH_NULL_SHA256

   o  TLS_RSA_PSK_WITH_NULL_SHA384

   o  TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256

   o  TLS_EMPTY_RENEGOTIATION_INFO_SCSV

   o  TLS_ECDH_ECDSA_WITH_NULL_SHA

   o  TLS_ECDH_ECDSA_WITH_RC4_128_SHA

   o  TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA 

   o  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA

   o  TLS_ECDHE_ECDSA_WITH_NULL_SHA

   o  TLS_ECDHE_ECDSA_WITH_RC4_128_SHA

   o  TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA

   o  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA

   o  TLS_ECDH_RSA_WITH_NULL_SHA

   o  TLS_ECDH_RSA_WITH_RC4_128_SHA

   o  TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA

   o  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA

   o  TLS_ECDHE_RSA_WITH_NULL_SHA

   o  TLS_ECDHE_RSA_WITH_RC4_128_SHA

   o  TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA

   o  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA

   o  TLS_ECDH_anon_WITH_NULL_SHA

   o  TLS_ECDH_anon_WITH_RC4_128_SHA

   o  TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDH_anon_WITH_AES_128_CBC_SHA

   o  TLS_ECDH_anon_WITH_AES_256_CBC_SHA

   o  TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA

   o  TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA

   o  TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA 

   o  TLS_SRP_SHA_WITH_AES_128_CBC_SHA

   o  TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA

   o  TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA

   o  TLS_SRP_SHA_WITH_AES_256_CBC_SHA

   o  TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA

   o  TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA

   o  TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256

   o  TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384

   o  TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256

   o  TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384

   o  TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384

   o  TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256

   o  TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384

   o  TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256

   o  TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384

   o  TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256

   o  TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384

   o  TLS_ECDHE_PSK_WITH_RC4_128_SHA

   o  TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA

   o  TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA

   o  TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA

   o  TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256

   o  TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384 

   o  TLS_ECDHE_PSK_WITH_NULL_SHA

   o  TLS_ECDHE_PSK_WITH_NULL_SHA256

   o  TLS_ECDHE_PSK_WITH_NULL_SHA384

   o  TLS_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256

   o  TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384

   o  TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256

   o  TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384

   o  TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_DH_anon_WITH_ARIA_128_CBC_SHA256

   o  TLS_DH_anon_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384

   o  TLS_RSA_WITH_ARIA_128_GCM_SHA256 

   o  TLS_RSA_WITH_ARIA_256_GCM_SHA384

   o  TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256

   o  TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384

   o  TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256

   o  TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384

   o  TLS_DH_anon_WITH_ARIA_128_GCM_SHA256

   o  TLS_DH_anon_WITH_ARIA_256_GCM_SHA384

   o  TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256

   o  TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384

   o  TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256

   o  TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384

   o  TLS_PSK_WITH_ARIA_128_CBC_SHA256

   o  TLS_PSK_WITH_ARIA_256_CBC_SHA384

   o  TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256

   o  TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384

   o  TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256

   o  TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384

   o  TLS_PSK_WITH_ARIA_128_GCM_SHA256

   o  TLS_PSK_WITH_ARIA_256_GCM_SHA384

   o  TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256

   o  TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384

   o  TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256

   o  TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384

   o  TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256 

   o  TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256

   o  TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384

   o  TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256 

   o  TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256

   o  TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384

   o  TLS_RSA_WITH_AES_128_CCM

   o  TLS_RSA_WITH_AES_256_CCM

   o  TLS_RSA_WITH_AES_128_CCM_8

   o  TLS_RSA_WITH_AES_256_CCM_8

   o  TLS_PSK_WITH_AES_128_CCM

   o  TLS_PSK_WITH_AES_256_CCM

   o  TLS_PSK_WITH_AES_128_CCM_8

   o  TLS_PSK_WITH_AES_256_CCM_8

      Note: This list was assembled from the set of registered TLS
      cipher suites at the time of writing.  This list includes those
      cipher suites that do not offer an ephemeral key exchange and
      those that are based on the TLS null, stream, or block cipher type
      (as defined in Section 6.2.3 of [&lt;a href=&quot;#ref-TLS12&quot;&gt;TLS12&lt;/a&gt;]).  Additional cipher
      suites with these properties could be defined; these would not be
      explicitly prohibited. 

Acknowledgements

   This document includes substantial input from the following
   individuals:

   o  Adam Langley, Wan-Teh Chang, Jim Morrison, Mark Nottingham, Alyssa
      Wilk, Costin Manolache, William Chan, Vitaliy Lvin, Joe Chan, Adam
      Barth, Ryan Hamilton, Gavin Peters, Kent Alstad, Kevin Lindsay,
      Paul Amer, Fan Yang, and Jonathan Leighton (SPDY contributors).

   o  Gabriel Montenegro and Willy Tarreau (Upgrade mechanism).

   o  William Chan, Salvatore Loreto, Osama Mazahir, Gabriel Montenegro,
      Jitu Padhye, Roberto Peon, and Rob Trace (Flow control).

   o  Mike Bishop (Extensibility).

   o  Mark Nottingham, Julian Reschke, James Snell, Jeff Pinner, Mike
      Bishop, and Herve Ruellan (Substantial editorial contributions).

   o  Kari Hurtta, Tatsuhiro Tsujikawa, Greg Wilkins, Poul-Henning Kamp,
      and Jonathan Thackray.

   o  Alexey Melnikov, who was an editor of this document in 2013.

   A substantial proportion of Martin's contribution was supported by
   Microsoft during his employment there.

   The Japanese HTTP/2 community provided invaluable contributions,
   including a number of implementations as well as numerous technical
   and editorial contributions. 

Authors' Addresses

   Mike Belshe
   BitGo

   EMail: mike@belshe.com


   Roberto Peon
   Google, Inc

   EMail: fenix@google.com


   Martin Thomson (editor)
   Mozilla
   331 E Evelyn Street
   Mountain View, CA  94041
   United States

   EMail: martin.thomson@gmail.com


Belshe, et al.               Standards Track                   [Page 96]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e198b1f69badcd0d294bae2afb6df6ba9df42c" translate="yes" xml:space="preserve">
          <source>An IANA registry maintains &lt;a href=&quot;http://www.iana.org/assignments/http-parameters/http-parameters.xml#http-parameters-1&quot;&gt;a complete list of official content encodings&lt;/a&gt;.</source>
          <target state="translated">IANA 레지스트리 &lt;a href=&quot;http://www.iana.org/assignments/http-parameters/http-parameters.xml#http-parameters-1&quot;&gt;는 공식 컨텐츠 인코딩의 전체 목록을&lt;/a&gt; 유지 합니다 .</target>
        </trans-unit>
        <trans-unit id="1f6bd1f61bcbf82ca97f280b68dcf8ec1c7ecb18" translate="yes" xml:space="preserve">
          <source>An IANA registry maintains &lt;a href=&quot;https://www.iana.org/assignments/http-parameters/http-parameters.xml#http-parameters-1&quot;&gt;a complete list of official content encodings&lt;/a&gt;.</source>
          <target state="translated">IANA 레지스트리 &lt;a href=&quot;https://www.iana.org/assignments/http-parameters/http-parameters.xml#http-parameters-1&quot;&gt;는 공식 콘텐츠 인코딩의 전체 목록을&lt;/a&gt; 유지 합니다 .</target>
        </trans-unit>
        <trans-unit id="fc3cd64d927c27e2c875db1e4f0241b2d475f24e" translate="yes" xml:space="preserve">
          <source>An absolute or partial address of the previous web page from which a link to the currently requested page was followed. URL fragments (i.e. &quot;#section&quot;) and userinfo (i.e. &quot;username:password&quot; in &quot;https://username:password@example.com/foo/bar/&quot;) are not included.</source>
          <target state="translated">현재 요청 된 페이지로 연결되는 이전 웹 페이지의 절대 또는 부분 주소입니다. URL 조각 (예 : &quot;#section&quot;) 및 userinfo (예 : &quot;https : // username : password@example.com/foo/bar/&quot;의 &quot;username : password&quot;)는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="88d7d1ee9799639ae7a725a7df1453133be8aff7" translate="yes" xml:space="preserve">
          <source>An absolute path, ultimately followed by a &lt;code&gt;'?'&lt;/code&gt; and query string. This is the most common form, known as the &lt;em&gt;origin form&lt;/em&gt;, and is used with &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;HEAD&lt;/code&gt;, and &lt;code&gt;OPTIONS&lt;/code&gt; methods.</source>
          <target state="translated">절대 경로, 궁극적으로 &lt;code&gt;'?'&lt;/code&gt; 쿼리 문자열. 이것은 가장 일반적인 형식으로 &lt;em&gt;origin form&lt;/em&gt; 이며 &lt;code&gt;GET&lt;/code&gt; , &lt;code&gt;POST&lt;/code&gt; , &lt;code&gt;HEAD&lt;/code&gt; 및 &lt;code&gt;OPTIONS&lt;/code&gt; 메서드 와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a5094c29882d093c531b3991dab04140b27dc3c2" translate="yes" xml:space="preserve">
          <source>An allow-list for specific inline scripts using a cryptographic nonce (number used once). The server must generate a unique nonce value each time it transmits a policy. It is critical to provide an unguessable nonce, as bypassing a resource&amp;rsquo;s policy is otherwise trivial. See &lt;a href=&quot;script-src#Unsafe_inline_script&quot;&gt;unsafe inline script&lt;/a&gt; for an example. Specifying nonce makes a modern browser ignore &lt;code&gt;'unsafe-inline'&lt;/code&gt; which could still be set for older browsers without nonce support.</source>
          <target state="translated">암호화 임시 값 (한 번 사용 된 번호)을 사용하는 특정 인라인 스크립트에 대한 허용 목록입니다. 서버는 정책을 전송할 때마다 고유 한 임시 값을 생성해야합니다. 리소스의 정책을 우회하는 것은 사소한 일이므로 추측 할 수없는 임시 값을 제공하는 것이 중요합니다. 참조 &lt;a href=&quot;script-src#Unsafe_inline_script&quot;&gt;안전하지 않은 인라인 스크립트를&lt;/a&gt;예를 들어 를 . nonce를 지정하면 최신 브라우저가 nonce 지원없이 이전 브라우저에 대해 설정할 수있는 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 을 무시 합니다.</target>
        </trans-unit>
        <trans-unit id="2f7612f8d608c3f6e8f180ad8653c5d57a276d94" translate="yes" xml:space="preserve">
          <source>An allowlist is a list of origins that takes one or more of the following values:</source>
          <target state="translated">허용 목록은 다음 값 중 하나 이상을 취하는 원점 목록입니다.</target>
        </trans-unit>
        <trans-unit id="4bb11d5976a64d2ae62179eb46982158c56bbed3" translate="yes" xml:space="preserve">
          <source>An attempt to validate the response failed, due to an inability to reach the server.</source>
          <target state="translated">서버에 연결할 수 없어서 응답 유효성 검증 시도에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="5712cd588fbe7cbcb4437f68372abb9b405a060c" translate="yes" xml:space="preserve">
          <source>An audio file in the OGG container format. Vorbis is the most common audio codec used in such a container.</source>
          <target state="translated">OGG 컨테이너 형식의 오디오 파일입니다. Vorbis는 이러한 컨테이너에 사용되는 가장 일반적인 오디오 코덱입니다.</target>
        </trans-unit>
        <trans-unit id="81b348b0f03b452c6893ff611a8d9c735c690bbe" translate="yes" xml:space="preserve">
          <source>An audio file in the Ogg container format. Vorbis is the most common audio codec used in such a container; however, Opus is now supported by Ogg as well.</source>
          <target state="translated">Ogg 컨테이너 형식의 오디오 파일입니다. Vorbis는 이러한 컨테이너에 사용되는 가장 일반적인 오디오 코덱입니다. 그러나 Opus는 이제 Ogg에서도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="275274da827a5e3fea5040e1aba9e600308dbbfb" translate="yes" xml:space="preserve">
          <source>An audio file in the WAVE container format. The PCM audio codec (WAVE codec &quot;1&quot;) is often supported, but other codecs have limited support (if any).</source>
          <target state="translated">WAVE 컨테이너 형식의 오디오 파일. PCM 오디오 코덱 (WAVE 코덱 &quot;1&quot;)이 종종 지원되지만 다른 코덱은 지원이 제한적입니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="0a0a6088f473bc9a3adf41b833d943e48b7fa5e7" translate="yes" xml:space="preserve">
          <source>An audio file in the WebM container format. Vorbis and Opus are the codecs officially supported by the WebM specification.</source>
          <target state="translated">WebM 컨테이너 형식의 오디오 파일입니다. Vorbis 및 Opus는 WebM 사양에서 공식적으로 지원하는 코덱입니다.</target>
        </trans-unit>
        <trans-unit id="04f3d314e777f96d5cb8022250e30f26ec18d095" translate="yes" xml:space="preserve">
          <source>An audio file in the WebM container format. Vorbis and Opus are the most common audio codecs.</source>
          <target state="translated">WebM 컨테이너 형식의 오디오 파일. Vorbis와 Opus는 가장 일반적인 오디오 코덱입니다.</target>
        </trans-unit>
        <trans-unit id="6d9bc7bf062074940f71cffe41ac4324eaa5605c" translate="yes" xml:space="preserve">
          <source>An audio or video file using the OGG container format. Theora is the usual video codec used within it; Vorbis is the usual audio codec.</source>
          <target state="translated">OGG 컨테이너 형식을 사용하는 오디오 또는 비디오 파일. Theora는 그 안에 사용되는 일반적인 비디오 코덱입니다. Vorbis는 일반적인 오디오 코덱입니다.</target>
        </trans-unit>
        <trans-unit id="28a4ce6138e5a1b915452926382ff3f84bda1947" translate="yes" xml:space="preserve">
          <source>An audio or video file using the Ogg container format. Theora is the usual video codec used within it; Vorbis is the usual audio codec.</source>
          <target state="translated">Ogg 컨테이너 형식을 사용하는 오디오 또는 비디오 파일. Theora는 그 안에서 사용되는 일반적인 비디오 코덱입니다. Vorbis는 일반적인 오디오 코덱입니다.</target>
        </trans-unit>
        <trans-unit id="4bab7fe5b73a7d6c377d59fdf9559bcf2ea5f6e5" translate="yes" xml:space="preserve">
          <source>An entity tag uniquely representing the requested resource. It is a string of ASCII characters placed between double quotes (Like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;) and may be prefixed by &lt;code&gt;W/&lt;/code&gt; to indicate that the weak comparison algorithm should be used.</source>
          <target state="translated">요청 된 자원을 고유하게 나타내는 엔티티 태그입니다. 큰 따옴표 ( &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; 와 같이) 사이에있는 ASCII 문자 문자열이며 약한 비교 알고리즘을 사용해야 함을 나타 내기 위해 &lt;code&gt;W/&lt;/code&gt; 접두사가 붙을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8351e98570f813491d441d5ddd55a80b35cfdc7d" translate="yes" xml:space="preserve">
          <source>An example HTTP request:</source>
          <target state="translated">HTTP 요청 예 :</target>
        </trans-unit>
        <trans-unit id="937401682bbf56d33e1065700936f4be12544c64" translate="yes" xml:space="preserve">
          <source>An example of a &lt;a href=&quot;#Preflighted_requests&quot;&gt;preflight request is given above&lt;/a&gt;, including an example which sends this header to the browser.</source>
          <target state="translated">이 헤더를 브라우저로 보내는 예제를 포함하여 &lt;a href=&quot;#Preflighted_requests&quot;&gt;프리 플라이트 요청&lt;/a&gt; 의 예가 위에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="18c03540d76fb7a3ce87da945d5bbdc9444de704" translate="yes" xml:space="preserve">
          <source>An example of a cross-origin request: The frontend JavaScript code for a web application served from &lt;code&gt;http://domain-a.com&lt;/code&gt; uses &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; to make a request for &lt;code&gt;http://api.domain-b.com/data.json&lt;/code&gt;.</source>
          <target state="translated">교차 출처 요청의 예 : &lt;code&gt;http://domain-a.com&lt;/code&gt; 에서 제공되는 웹 응용 프로그램의 프론트 엔드 JavaScript 코드 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;http://api.domain-b.com/data.json&lt;/code&gt; 에 대한 요청을합니다. .</target>
        </trans-unit>
        <trans-unit id="3394f284d7025377699f6e1e4fd6fb1b485373b4" translate="yes" xml:space="preserve">
          <source>An example of a cross-origin request: the front-end JavaScript code served from &lt;code&gt;https://domain-a.com&lt;/code&gt; uses &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; to make a request for &lt;code&gt;https://domain-b.com/data.json&lt;/code&gt;.</source>
          <target state="translated">교차 출처 요청의 예 : &lt;code&gt;https://domain-a.com&lt;/code&gt; 에서 제공되는 프런트 엔드 JavaScript 코드 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;https://domain-b.com/data.json&lt;/code&gt; 을 요청합니다 .</target>
        </trans-unit>
        <trans-unit id="6fa1717cd1d978e6cae9d3ef7affa2c14bef3a08" translate="yes" xml:space="preserve">
          <source>An example of an HTML form posted using the &lt;code&gt;multipart/form-data&lt;/code&gt; format that makes use of the &lt;code&gt;Content-Disposition&lt;/code&gt; header:</source>
          <target state="translated">&lt;code&gt;Content-Disposition&lt;/code&gt; 헤더를 사용하는 &lt;code&gt;multipart/form-data&lt;/code&gt; 형식을 사용하여 게시 된 HTML 양식의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0eb7d8b63d836dc8b48fea64e497eee88c8fc37a" translate="yes" xml:space="preserve">
          <source>An example response:</source>
          <target state="translated">응답 예 :</target>
        </trans-unit>
        <trans-unit id="d06bdca7c09b88f2f4a910e920b7d53770584980" translate="yes" xml:space="preserve">
          <source>An example scenario</source>
          <target state="translated">예제 시나리오</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="524d76d400d5cb73fc54737fb4d856fc9ec10a9a" translate="yes" xml:space="preserve">
          <source>An identifier disclosing the information that is altered or lost when using a proxy. This can be either:</source>
          <target state="translated">프록시를 사용할 때 변경되거나 손실 된 정보를 공개하는 식별자입니다. 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae6172d2a45cf37f2f2799154f23922f58940acb" translate="yes" xml:space="preserve">
          <source>An integer in the given unit indicating the beginning of the request range.</source>
          <target state="translated">요청 범위의 시작을 나타내는 지정된 단위의 정수</target>
        </trans-unit>
        <trans-unit id="5f15168b132abe2a60f0170a67ead71d262beaa6" translate="yes" xml:space="preserve">
          <source>An integer in the given unit indicating the end of the requested range.</source>
          <target state="translated">요청 된 범위의 끝을 나타내는 지정된 단위의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="fb3aa033dddb2a858401595eeaf3ab8db26849c4" translate="yes" xml:space="preserve">
          <source>An integer in the given unit indicating the end of the requested range. This value is optional and, if omitted, the end of the document is taken as the end of the range.</source>
          <target state="translated">요청 된 범위의 끝을 나타내는 지정된 단위의 정수입니다. 이 값은 선택 사항이며 생략하면 문서의 끝이 범위의 끝으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a73313ed84e91191f3d2b2b90684cde52ec8f101" translate="yes" xml:space="preserve">
          <source>An integer in the given unit indicating the number of units at the end of the file to return.</source>
          <target state="translated">반환 할 파일 끝의 단위 수를 나타내는 지정된 단위의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="bc0e19474dd59d2467fd56601368eedbd6a3f2cd" translate="yes" xml:space="preserve">
          <source>An intermediate cache or proxy cannot edit the response body, &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;. It therefore forbids a proxy or browser feature, such as &lt;a href=&quot;https://support.google.com/webmasters/answer/6211428&quot;&gt;Google&amp;rsquo;s Web Light&lt;/a&gt;, from converting images to minimize data for a cache store or slow connection.</source>
          <target state="translated">중간 캐시 또는 프록시는 응답 본문, &lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; 을&lt;/a&gt; 편집 할 수 없습니다 . 따라서 &lt;a href=&quot;https://support.google.com/webmasters/answer/6211428&quot;&gt;Google의 Web Light&lt;/a&gt; 와 같은 프록시 또는 브라우저 기능이 이미지를 변환하여 캐시 저장소 또는 느린 연결에 대한 데이터를 최소화 하는 것을 금지 합니다.</target>
        </trans-unit>
        <trans-unit id="978df3d581d5f2123e6d6e2fbfff4d060ccce54e" translate="yes" xml:space="preserve">
          <source>An optional &lt;em&gt;body&lt;/em&gt; containing data associated with the request (like content of an HTML form), or the document associated with a response. The presence of the body and its size is specified by the start-line and HTTP headers.</source>
          <target state="translated">요청과 관련된 데이터 (예 : HTML 양식의 내용) 또는 응답과 관련된 문서가 포함 된 선택적 &lt;em&gt;본문&lt;/em&gt; 입니다. 본문의 존재와 크기는 시작 줄과 HTTP 헤더에 의해 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="08d7e405f02128c6b7b24a0361c7298994da77d1" translate="yes" xml:space="preserve">
          <source>An optional &lt;strong&gt;parameter&lt;/strong&gt; can be added to provide additional details:</source>
          <target state="translated">선택적 &lt;strong&gt;매개 변수&lt;/strong&gt;추가 세부 사항을 제공하기 위해 를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="258eb51f5d78b7afb24633c632b091d4e2519fd6" translate="yes" xml:space="preserve">
          <source>An optional set of &lt;em&gt;HTTP headers&lt;/em&gt; specifying the request, or describing the body included in the message.</source>
          <target state="translated">요청을 지정하거나 메시지에 포함 된 본문을 설명 하는 선택적 &lt;em&gt;HTTP 헤더&lt;/em&gt; 세트입니다 .</target>
        </trans-unit>
        <trans-unit id="599d0e853eca77f2daf81b1d2e0984db369b73c0" translate="yes" xml:space="preserve">
          <source>An origin considered secure by the browser is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb6a0c0ce21b968ca2bae147ce0e590ec11226ee" translate="yes" xml:space="preserve">
          <source>An origin server SHOULD send Last-Modified for any selected
   representation for which a last modification date can be reasonably
   and consistently determined, since its use in conditional requests
   and evaluating cache freshness ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]) results in a substantial
   reduction of HTTP traffic on the Internet and can be a significant
   factor in improving service scalability and reliability.

   A representation is typically the sum of many parts behind the
   resource interface.  The last-modified time would usually be the most
   recent time that any of those parts were changed.  How that value is
   determined for any given resource is an implementation detail beyond
   the scope of this specification.  What matters to HTTP is how
   recipients of the Last-Modified header field can use its value to
   make conditional requests and test the validity of locally cached
   responses.

   An origin server SHOULD obtain the Last-Modified value of the
   representation as close as possible to the time that it generates the
   Date field value for its response.  This allows a recipient to make
   an accurate assessment of the representation's modification time,
   especially if the representation changes near the time that the
   response is generated.

   An origin server with a clock MUST NOT send a Last-Modified date that
   is later than the server's time of message origination (Date).  If
   the last modification time is derived from implementation-specific 

   metadata that evaluates to some time in the future, according to the
   origin server's clock, then the origin server MUST replace that value
   with the message origination date.  This prevents a future
   modification date from having an adverse impact on cache validation.

   An origin server without a clock MUST NOT assign Last-Modified values
   to a response unless these values were associated with the resource
   by some other system or user with a reliable clock.</source>
          <target state="translated">오리진 서버는 조건부 요청에 사용하고 캐시 신선도를 평가하기 때문에 마지막 수정 날짜를 합리적이고 일관되게 결정할 수있는 선택된 표현에 대해 Last-Modified를 전송해야합니다 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234).&lt;/a&gt;]) 인터넷에서 HTTP 트래픽이 크게 감소하고 서비스 확장 성과 안정성을 향상시키는 데 중요한 요소가 될 수 있습니다. 표현은 일반적으로 자원 인터페이스 뒤의 많은 부분의 합계입니다. 마지막으로 수정 한 시간은 일반적으로 해당 부분이 변경된 가장 최근 시간입니다. 주어진 자원에 대해 해당 값을 결정하는 방법은이 사양의 범위를 벗어난 구현 세부 사항입니다. HTTP에서 중요한 것은 Last-Modified 헤더 필드의 수신자가 해당 값을 사용하여 조건부 요청을 작성하고 로컬로 캐시 된 응답의 유효성을 테스트하는 방법입니다. 오리진 서버는 응답의 날짜 필드 값을 생성하는 시간에 최대한 가깝게 표현의 최종 수정 된 값을 얻어야합니다.이를 통해 수신자는 특히 응답이 생성 된 시간에 따라 표현이 변경되는 경우 표현의 수정 시간을 정확하게 평가할 수 있습니다. 시계가있는 오리진 서버는 서버의 메시지 발신 시간 (날짜)보다 늦은 Last-Modified 날짜를 보내서는 안됩니다 (MUST). 마지막 수정 시간이 오리진 서버의 시계에 따라 미래의 시간으로 평가되는 구현 별 메타 데이터에서 파생 된 경우, 오리진 서버는 해당 값을 메시지 시작 날짜로 바꿔야합니다. 이렇게하면 향후 수정 날짜가 캐시 유효성 검사에 부정적인 영향을 미치지 않습니다.클럭이없는 오리진 서버는이 값이 신뢰할 수있는 클럭을 가진 다른 시스템이나 사용자에 의해 리소스와 연결되어 있지 않는 한 Last-Modified 값을 응답에 할당해서는 안됩니다 (MUST NOT).</target>
        </trans-unit>
        <trans-unit id="d0c39f83da17a248ad712c0819b8703fb2f5ef34" translate="yes" xml:space="preserve">
          <source>An unsecured HTTP request is used and the referring page was received with a secure protocol (HTTPS).</source>
          <target state="translated">보안되지 않은 HTTP 요청이 사용되고 참조 페이지가 보안 프로토콜 (HTTPS)로 수신되었습니다.</target>
        </trans-unit>
        <trans-unit id="2b6110e3591ac90aa132e8d09ccc7a10f3c9f89c" translate="yes" xml:space="preserve">
          <source>And the MIME type set to:</source>
          <target state="translated">그리고 MIME 유형은 다음과 같이 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="6e13d60348da6215250058b98e62629552950b15" translate="yes" xml:space="preserve">
          <source>And the MIME type should be set to:</source>
          <target state="translated">MIME 유형은 다음과 같이 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="51d93a0e0e6b94c85ab246f096bdfe11ac7c7be5" translate="yes" xml:space="preserve">
          <source>Android (version 40 and below)</source>
          <target state="translated">Android (버전 40 이하)</target>
        </trans-unit>
        <trans-unit id="9d181bb566f9337c1f23f7fa7129fbabf5cee58d" translate="yes" xml:space="preserve">
          <source>Android (version 41 and above)</source>
          <target state="translated">Android (버전 41 이상)</target>
        </trans-unit>
        <trans-unit id="a5b93109d2910f83b46a8f8b84565a2b90f04e8f" translate="yes" xml:space="preserve">
          <source>Android webview</source>
          <target state="translated">안드로이드 웹뷰</target>
        </trans-unit>
        <trans-unit id="8a128a9589c315d21634acc57ea259fa0a700af6" translate="yes" xml:space="preserve">
          <source>Animated Portable Network Graphics</source>
          <target state="translated">애니메이션 휴대용 네트워크 그래픽</target>
        </trans-unit>
        <trans-unit id="d2272152aaed514a90142950fb3ee1816c7074cb" translate="yes" xml:space="preserve">
          <source>Annotation of existing resources</source>
          <target state="translated">기존 자원의 주석</target>
        </trans-unit>
        <trans-unit id="8642c3a715dbd6efdfc0bb89f8eb0afbc3cede8d" translate="yes" xml:space="preserve">
          <source>Another (implicit) indication that &lt;code&gt;PATCH&lt;/code&gt; is allowed, is the presence of the &lt;a href=&quot;../headers/accept-patch&quot;&gt;&lt;code&gt;Accept-Patch&lt;/code&gt;&lt;/a&gt; header, which specifies the patch document formats accepted by the server.</source>
          <target state="translated">&lt;code&gt;PATCH&lt;/code&gt; 가 허용 된다는 또 다른 (암시 적) 표시 는 서버에서 승인 한 패치 문서 형식을 지정하는 &lt;a href=&quot;../headers/accept-patch&quot;&gt; &lt;code&gt;Accept-Patch&lt;/code&gt; &lt;/a&gt; 헤더 의 존재입니다 .</target>
        </trans-unit>
        <trans-unit id="30a34db762af17ee412c2a1fc9d092bc9dce7999" translate="yes" xml:space="preserve">
          <source>Another (implicit) indication that PATCH is allowed, is the presence of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Patch&quot;&gt;&lt;code&gt;Accept-Patch&lt;/code&gt;&lt;/a&gt; header, which specifies the patch document formats accepted by the server.</source>
          <target state="translated">PATCH가 허용된다는 또 다른 (암시 적) 표시는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Patch&quot;&gt; &lt;code&gt;Accept-Patch&lt;/code&gt; &lt;/a&gt; 헤더 가 존재한다는 것입니다.이 헤더는 서버가 승인 한 패치 문서 형식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2ea2ea80d736402d761cc48753f37ae87a7086f1" translate="yes" xml:space="preserve">
          <source>Another API, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;server-sent events&lt;/a&gt;, is a one-way service that allows a server to send events to the client, using HTTP as a transport mechanism. Using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource&quot;&gt;&lt;code&gt;EventSource&lt;/code&gt;&lt;/a&gt; interface, the client opens a connection and establishes event handlers. The client browser automatically converts the messages that arrive on the HTTP stream into appropriate &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event&quot;&gt;&lt;code&gt;Event&lt;/code&gt;&lt;/a&gt; objects, delivering them to the event handlers that have been registered for the events' &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event/type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; if known, or to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/onmessage&quot;&gt;&lt;code&gt;onmessage&lt;/code&gt;&lt;/a&gt; event handler if no type-specific event handler was established.</source>
          <target state="translated">또 다른 API 인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;server-sent events&lt;/a&gt; 는 전송 메커니즘으로 HTTP를 사용하여 서버가 클라이언트에 이벤트를 보낼 수있는 단방향 서비스입니다. 클라이언트 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource&quot;&gt; &lt;code&gt;EventSource&lt;/code&gt; &lt;/a&gt; 인터페이스를 사용하여 연결을 열고 이벤트 핸들러를 설정합니다. 클라이언트 브라우저는 HTTP 스트림에 도착한 메시지를 적절한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event&quot;&gt; &lt;code&gt;Event&lt;/code&gt; &lt;/a&gt; 객체 로 자동 변환하여 알려진 경우 이벤트 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Event/type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; 에 등록 된 이벤트 핸들러 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/onmessage&quot;&gt; &lt;code&gt;onmessage&lt;/code&gt; 에 전달합니다.&lt;/a&gt; 유형별 이벤트 핸들러가없는 경우 이벤트 핸들러로 전달합니다. 설립.</target>
        </trans-unit>
        <trans-unit id="9db32006413a6e691ae3fb773aa031a903fdfbff" translate="yes" xml:space="preserve">
          <source>Another approach to storing data in the browser is the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API&quot;&gt;Web Storage API&lt;/a&gt;. The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage&quot;&gt;window.sessionStorage&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt;window.localStorage&lt;/a&gt; properties correspond to session and permanent cookies in duration, but have larger storage limits than cookies, and are never sent to a server. More structured and larger amounts of data can be stored using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API&quot;&gt;IndexedDB API&lt;/a&gt;, or a library built on it.</source>
          <target state="translated">브라우저에 데이터를 저장하는 또 다른 접근 방식은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API&quot;&gt;Web Storage API&lt;/a&gt; 입니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage&quot;&gt;window.sessionStorage&lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage&quot;&gt;window.localStorage&lt;/a&gt; 속성은 시간에 세션 및 영구 쿠키에 해당하지만, 쿠키보다 큰 저장 용량 제한이 있고, 서버에 전송되지 않습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API&quot;&gt;IndexedDB API&lt;/a&gt; 또는 그 위에 빌드 된 라이브러리를 사용하여 더 구조화되고 더 많은 양의 데이터를 저장할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="522f7fe585152d75fdebc26d8febeb7c023ce78b" translate="yes" xml:space="preserve">
          <source>Another such case is for fixing bugs in browsers that do not automatically update. Internet Explorer (on Windows) and Webkit (on iOS) are two perfect examples. Prior to version 9, Internet Explorer had unbelievable issues with rendering bugs, CSS bugs, API bugs, and so forth. However, Internet Explorer was such a special little &lt;s&gt;wasp&lt;/s&gt; exception prior to version 9 that it was very easy to detect the browser based upon the browser-specific features available. Webkit is a bit worse because Apple forces all of the browsers on IOS to use Webkit internally, thus the user has no way to get a better more updated browser on older devices. Most bugs can be detected, but some bugs take more effort to detect than others. In such cases, it might be beneficial to use user agent sniffing to save on performance. For example, Webkit 6 has a bug whereby when the device orientation changes, the browser might not fire &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList&quot;&gt;MediaQueryList&lt;/a&gt; listeners when it should. To overcome this bug, observe the code below.</source>
          <target state="translated">또 다른 경우는 자동으로 업데이트되지 않는 브라우저의 버그를 수정하는 것입니다. Internet Explorer (Windows)와 Webkit (iOS)이 완벽한 예입니다. 버전 9 이전에는 Internet Explorer에 렌더링 버그, CSS 버그, API 버그 등의 문제가있었습니다. 하지만 인터넷 익스플로러는 아주 특별한 &lt;s&gt;말벌&lt;/s&gt; 이었습니다.&lt;s&gt;&lt;/s&gt;버전 9 이전의 예외는 사용 가능한 브라우저 별 기능을 기반으로 브라우저를 매우 쉽게 감지 할 수 있다는 점입니다. Webkit은 Apple이 IOS의 모든 브라우저가 내부적으로 Webkit을 사용하도록 강제하기 때문에 약간 더 나쁩니다. 따라서 사용자는 이전 장치에서 더 나은 업데이트 된 브라우저를 얻을 방법이 없습니다. 대부분의 버그는 감지 할 수 있지만 일부 버그는 다른 버그보다 감지하는 데 더 많은 노력이 필요합니다. 이러한 경우 성능을 절약하기 위해 사용자 에이전트 스니핑을 사용하는 것이 유용 할 수 있습니다. 예를 들어, Webkit 6에는 장치 방향이 변경 될 때 브라우저가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList&quot;&gt;MediaQueryList&lt;/a&gt; 리스너를 실행 하지 않을 수있는 버그 가 있습니다. 이 버그를 극복하려면 아래 코드를 관찰하십시오.</target>
        </trans-unit>
        <trans-unit id="82dda038aa2cce2ed80f2fe178807efbf3638a7c" translate="yes" xml:space="preserve">
          <source>Another typical use case of the &lt;code&gt;ETag&lt;/code&gt; header is to cache resources that are unchanged. If a user visits a given URL again (that has an &lt;code&gt;ETag&lt;/code&gt; set), and it is &lt;em&gt;stale&lt;/em&gt;, that is too old to be considered usable, the client will send the value of its &lt;code&gt;ETag&lt;/code&gt; along in an &lt;a href=&quot;if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; header field:</source>
          <target state="translated">&lt;code&gt;ETag&lt;/code&gt; 헤더 의 또 다른 일반적인 사용 사례 는 변경되지 않은 리소스를 캐시하는 것입니다. 사용자가 지정된 URL ( &lt;code&gt;ETag&lt;/code&gt; 세트가 있음)을 다시 방문하고 유효 &lt;em&gt;하지 않은 오래된&lt;/em&gt; URL 인 경우 클라이언트는 &lt;code&gt;ETag&lt;/code&gt; 값을 &lt;a href=&quot;if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt; 헤더 필드 와 함께 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="013822625b21f9cdd212bedabde063e3b082d165" translate="yes" xml:space="preserve">
          <source>Another typical use of the &lt;code&gt;ETag&lt;/code&gt; header is to cache resources that are unchanged. If a user visits a given URL again (that has an &lt;code&gt;ETag&lt;/code&gt; set), and it is &lt;em&gt;stale&lt;/em&gt; (too old to be considered usable), the client will send the value of its &lt;code&gt;ETag&lt;/code&gt; along in an &lt;a href=&quot;if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; header field:</source>
          <target state="translated">&lt;code&gt;ETag&lt;/code&gt; 헤더 의 또 다른 일반적인 용도 는 변경되지 않은 리소스를 캐시하는 것입니다. 사용자가 주어진 URL ( &lt;code&gt;ETag&lt;/code&gt; 가 설정되어 있음)을 다시 방문하고 &lt;em&gt;부실한 경우&lt;/em&gt; (사용할 수 없다고 간주하기에는 너무 오래되면) 클라이언트는 &lt;a href=&quot;if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt; 와 함께 &lt;code&gt;ETag&lt;/code&gt; 값을 보냅니다. 헤더 필드에 .</target>
        </trans-unit>
        <trans-unit id="5e02264f317d706ccbea92e11ccd2f204223b4b4" translate="yes" xml:space="preserve">
          <source>Any MIME type</source>
          <target state="translated">모든 MIME 유형</target>
        </trans-unit>
        <trans-unit id="664cc5e88f68df83f7fdaca487b2f0a350552a8c" translate="yes" xml:space="preserve">
          <source>Any attempt to identify the entity ultimately responsible for the resource being unavailable belongs in the response body, not in the &lt;code&gt;rel=&quot;blocked-by&quot;&lt;/code&gt; link. This includes the name of the person or organization that made a legal demand resulting in the content's removal.</source>
          <target state="translated">리소스를 사용할 수없는 궁극적 인 책임이있는 엔티티를 식별하려는 모든 시도는 &lt;code&gt;rel=&quot;blocked-by&quot;&lt;/code&gt; 가 아닌 응답 본문에 속합니다. 링크가 . 여기에는 콘텐츠 삭제를 초래하는 법적 요청을 한 사람 또는 조직의 이름이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d073236284623914133cba02aa3f08d7e4a1a8da" translate="yes" xml:space="preserve">
          <source>Any attempt to identify the entity ultimately responsible for the resource being unavailable, such as the name of the person or organization that made a legal demand resulting in the content's removal belongs in the response body, not in the &lt;code&gt;rel=&quot;blocked-by&quot;&lt;/code&gt; link.</source>
          <target state="translated">콘텐츠를 삭제하도록 법적 요구를 한 개인 또는 조직의 이름과 같이 리소스를 사용할 수없는 궁극적 인 책임이있는 엔티티를 식별하려는 시도는 &lt;code&gt;rel=&quot;blocked-by&quot;&lt;/code&gt; 링크가 아닌 응답 본문에 속합니다. .</target>
        </trans-unit>
        <trans-unit id="2f93939c7c6cb77a4b58edcc0e622cd4847d28e7" translate="yes" xml:space="preserve">
          <source>Any charset not mentioned elsewhere in the header; &lt;code&gt;'*'&lt;/code&gt; being used as a wildcard.</source>
          <target state="translated">헤더의 다른 곳에서 언급되지 않은 모든 문자 집합; &lt;code&gt;'*'&lt;/code&gt; 는 와일드 카드로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1fc5d287b6ce02126912e6b9a448430e3c10e833" translate="yes" xml:space="preserve">
          <source>Any charset not mentioned elsewhere in the header; &lt;code&gt;*&lt;/code&gt; is used as a wildcard.</source>
          <target state="translated">헤더의 다른 곳에서 언급되지 않은 모든 문자 세트; &lt;code&gt;*&lt;/code&gt; 는 와일드 카드로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cffac48fe322697cea7b86272c21674cea37081d" translate="yes" xml:space="preserve">
          <source>Any document that contains text and is theoretically human readable</source>
          <target state="translated">텍스트를 포함하고 이론적으로 사람이 읽을 수있는 모든 문서</target>
        </trans-unit>
        <trans-unit id="2222f9e23d53ca401d68b85209e6a60c148699f8" translate="yes" xml:space="preserve">
          <source>Any dotted address such as an IP address or mask.</source>
          <target state="translated">IP 주소 또는 마스크와 같은 점으로 구분 된 주소</target>
        </trans-unit>
        <trans-unit id="6dd2b19bd700bc5770d5e2ddd162cb6829cc8561" translate="yes" xml:space="preserve">
          <source>Any encoding is placed in an order of preference, expressed using a relative &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/quality_values&quot;&gt;quality value&lt;/a&gt; called the &lt;em&gt;weight&lt;/em&gt;.</source>
          <target state="translated">모든 인코딩은 선호하는 순서대로 배치되며 &lt;em&gt;가중치&lt;/em&gt; 라는 상대 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/quality_values&quot;&gt;품질 값을&lt;/a&gt; 사용하여 표현됩니다.&lt;em&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="019e0e72fd8d034b92757591b2abd6fca20d6e93" translate="yes" xml:space="preserve">
          <source>Any kind of audio file</source>
          <target state="translated">모든 종류의 오디오 파일</target>
        </trans-unit>
        <trans-unit id="dd4445bb33a492123fee27932f107bd3fb3d96ab" translate="yes" xml:space="preserve">
          <source>Any kind of binary data</source>
          <target state="translated">모든 종류의 이진 데이터</target>
        </trans-unit>
        <trans-unit id="3c78c30698ff4d77228e78708753b01ba8b332fc" translate="yes" xml:space="preserve">
          <source>Any kind of binary data that doesn't fall explicitly into one of the other types; either data that will be executed or interpreted in some way or binary data that requires a specific application or category of application to use. Generic binary data (or binary data whose true type is unknown) is &lt;code&gt;application/octet-stream&lt;/code&gt;. Other common examples include &lt;code&gt;application/pdf&lt;/code&gt;, &lt;code&gt;application/pkcs8&lt;/code&gt;, and &lt;code&gt;application/zip&lt;/code&gt;.</source>
          <target state="translated">다른 유형 중 하나에 명시 적으로 속하지 않는 모든 종류의 이진 데이터; 어떤 방식 으로든 실행되거나 해석 될 데이터 또는 사용할 특정 응용 프로그램 또는 응용 프로그램 범주가 필요한 이진 데이터. 일반 이진 데이터 (또는 실제 유형을 알 수없는 이진 데이터)는 &lt;code&gt;application/octet-stream&lt;/code&gt; 입니다. 다른 일반적인 예로는 &lt;code&gt;application/pdf&lt;/code&gt; , &lt;code&gt;application/pkcs8&lt;/code&gt; 및 &lt;code&gt;application/zip&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6114a2f683fe140d2073d3c42d6efbc65bb0052" translate="yes" xml:space="preserve">
          <source>Any kind of binary data, especially data that will be executed or interpreted somehow.</source>
          <target state="translated">모든 종류의 이진 데이터, 특히 어떻게 든 실행되거나 해석 될 데이터.</target>
        </trans-unit>
        <trans-unit id="1efabcb6609afdf043de0f7cdb84bbe7f95e6d79" translate="yes" xml:space="preserve">
          <source>Any kind of image. Videos are not included, though animated images (like animated GIF) are described with an image type.</source>
          <target state="translated">모든 종류의 이미지. 애니메이션 GIF와 같은 애니메이션 이미지는 이미지 유형으로 설명되지만 비디오는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01b107a882caf2ec54e57571bc8a5b70f3cfd436" translate="yes" xml:space="preserve">
          <source>Any kind of video file</source>
          <target state="translated">모든 종류의 비디오 파일</target>
        </trans-unit>
        <trans-unit id="1bebfb3250f36aea1f47b92ea11652dd128e36ff" translate="yes" xml:space="preserve">
          <source>Any language; &lt;code&gt;'*'&lt;/code&gt; is used as a wildcard.</source>
          <target state="translated">모든 언어; &lt;code&gt;'*'&lt;/code&gt; 는 와일드 카드로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa2b54a4202ec978d3ce61340b71c764fd12c522" translate="yes" xml:space="preserve">
          <source>Any of those URLs can be typed into your browser's address bar to tell it to load the associated page (resource).</source>
          <target state="translated">해당 URL을 브라우저의 주소 표시 줄에 입력하여 관련 페이지 (자원)를로드하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a55969e44ed3bb85f72438df20e0888b1d448e7d" translate="yes" xml:space="preserve">
          <source>Any request can contain a conditional header defined in HTTP (If-
   Match, If-Modified-Since, etc.) or the &quot;If&quot; or &quot;Overwrite&quot;
   conditional headers defined in this specification.  If the server
   evaluates a conditional header, and if that condition fails to hold,
   then this error code MUST be returned.  On the other hand, if the
   client did not include a conditional header in the request, then the
   server MUST NOT use this status code.</source>
          <target state="translated">모든 요청에는 HTTP에 정의 된 조건부 헤더 (If- Match, If-Modified-Since 등) 또는이 사양에 정의 된 &quot;If&quot;또는 &quot;Overwrite&quot;조건부 헤더가 포함될 수 있습니다. 서버가 조건부 헤더를 평가하고 해당 조건이 유지되지 않으면이 오류 코드가 리턴되어야합니다. 반면에 클라이언트가 요청에 조건부 헤더를 포함하지 않은 경우 서버는이 상태 코드를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7cdc0894205bef818ccb78426bec4fd87c774e5d" translate="yes" xml:space="preserve">
          <source>Any script inspecting the response is permitted to read the values of the &lt;code&gt;X-PINGOTHER&lt;/code&gt; and &lt;code&gt;Content-Type&lt;/code&gt; headers.</source>
          <target state="translated">응답을 검사하는 모든 스크립트는 &lt;code&gt;X-PINGOTHER&lt;/code&gt; 및 &lt;code&gt;Content-Type&lt;/code&gt; 의 값을 읽을 수 있습니다. 헤더 있습니다.</target>
        </trans-unit>
        <trans-unit id="8478316470e4f240737c39611f11363ddfca7c9b" translate="yes" xml:space="preserve">
          <source>Any value is placed in an order of preference expressed using a relative &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality value&lt;/a&gt; called &lt;em&gt;weight&lt;/em&gt;.</source>
          <target state="translated">모든 값은 &lt;em&gt;weight&lt;/em&gt; 라는 상대적 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;품질 값을&lt;/a&gt; 사용하여 표현 된 우선 순위대로 배치됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0362e9377af962c1e1e3c9526a03e0bd8afd66f5" translate="yes" xml:space="preserve">
          <source>Any value is placed in an order of preference expressed using a relative &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality value&lt;/a&gt; called the &lt;em&gt;weight&lt;/em&gt;.</source>
          <target state="translated">모든 값은 &lt;em&gt;weight&lt;/em&gt; 라는 상대적 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;품질 값을&lt;/a&gt; 사용하여 표현 된 우선 순위대로 배치됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2511c542d2415f42594a069865e3cebb0df0bdbf" translate="yes" xml:space="preserve">
          <source>Any value placed in an order of preference expressed using a relative &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality value&lt;/a&gt; called &lt;em&gt;weight&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;weight&lt;/em&gt; 라는 상대적인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;품질 값을&lt;/a&gt; 사용하여 선호하는 순서대로 배치 된 값 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="028f46051e76ed93ba7b2778ec6eb36735319f74" translate="yes" xml:space="preserve">
          <source>Any value used is placed in an order of preference expressed using relative &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality value&lt;/a&gt; called the &lt;em&gt;weight&lt;/em&gt;.</source>
          <target state="translated">사용 된 모든 값 은 &lt;em&gt;weight&lt;/em&gt; 라고하는 상대적인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;품질 값을&lt;/a&gt; 사용하여 표현 된 우선 순위대로 배치됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0b5958b0f53cb499388dd9ee04a106a30b02c5d1" translate="yes" xml:space="preserve">
          <source>Apache</source>
          <target state="translated">Apache</target>
        </trans-unit>
        <trans-unit id="8999d296169b8dd735b6c2a66a1890fdaeaf65ac" translate="yes" xml:space="preserve">
          <source>Apache (.htaccess)</source>
          <target state="translated">아파치 (.htaccess)</target>
        </trans-unit>
        <trans-unit id="7723239d4f8c294f39821b7409607014e4779e8f" translate="yes" xml:space="preserve">
          <source>Apache configuration</source>
          <target state="translated">아파치 설정</target>
        </trans-unit>
        <trans-unit id="aa0a9cd5c584e9e02295690438c89eb9804a2974" translate="yes" xml:space="preserve">
          <source>Apache examples</source>
          <target state="translated">아파치 예제</target>
        </trans-unit>
        <trans-unit id="c418bff5ffb1981f5504dddf5424420a352c8db4" translate="yes" xml:space="preserve">
          <source>Apache supports compression and uses &lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_deflate.html&quot;&gt;mod_deflate&lt;/a&gt;; for nginx there is &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_gzip_module.html&quot;&gt;ngx_http_gzip_module&lt;/a&gt;; for IIS, the &lt;code&gt;&lt;a href=&quot;https://www.iis.net/configreference/system.webserver/httpcompression&quot;&gt;&amp;lt;httpCompression&amp;gt;&lt;/a&gt;&lt;/code&gt; element.</source>
          <target state="translated">Apache는 압축을 지원하고 &lt;a href=&quot;http://httpd.apache.org/docs/current/mod/mod_deflate.html&quot;&gt;mod_deflate를 사용합니다&lt;/a&gt; . nginx의 경우 &lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_gzip_module.html&quot;&gt;ngx_http_gzip_module이 있습니다&lt;/a&gt; . IIS의 경우 &lt;code&gt;&lt;a href=&quot;https://www.iis.net/configreference/system.webserver/httpcompression&quot;&gt;&amp;lt;httpCompression&amp;gt;&lt;/a&gt;&lt;/code&gt; 요소</target>
        </trans-unit>
        <trans-unit id="fb97b025af5b9508c5b771e7550a47edd3292e52" translate="yes" xml:space="preserve">
          <source>Apache supports compression and uses &lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_deflate.html&quot;&gt;mod_deflate&lt;/a&gt;; for nginx there is &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_gzip_module.html&quot;&gt;ngx_http_gzip_module&lt;/a&gt;; for IIS, the &lt;code&gt;&lt;a href=&quot;https://www.iis.net/configreference/system.webserver/httpcompression&quot;&gt;&amp;lt;httpCompression&amp;gt;&lt;/a&gt;&lt;/code&gt; element.</source>
          <target state="translated">Apache는 압축을 지원하고 &lt;a href=&quot;https://httpd.apache.org/docs/current/mod/mod_deflate.html&quot;&gt;mod_deflate를 사용합니다&lt;/a&gt; . nginx의 경우 &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_gzip_module.html&quot;&gt;ngx_http_gzip_module이 있습니다&lt;/a&gt; . IIS의 경우 &lt;code&gt;&lt;a href=&quot;https://www.iis.net/configreference/system.webserver/httpcompression&quot;&gt;&amp;lt;httpCompression&amp;gt;&lt;/a&gt;&lt;/code&gt; 요소입니다.</target>
        </trans-unit>
        <trans-unit id="faca6e6d39fcc2dddfd17aac8a4b697f78f0b4a5" translate="yes" xml:space="preserve">
          <source>Apart from the headers automatically set by the user agent (for example, &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://fetch.spec.whatwg.org/#forbidden-header-name&quot;&gt;the other headers defined in the Fetch spec as a &amp;ldquo;forbidden header name&amp;rdquo;&lt;/a&gt;), the only headers which are allowed to be manually set are &lt;a href=&quot;https://fetch.spec.whatwg.org/#cors-safelisted-request-header&quot;&gt;those which the Fetch spec defines as a &amp;ldquo;CORS-safelisted request-header&amp;rdquo;&lt;/a&gt;, which are:</source>
          <target state="translated">그렇다 (예,에 자동으로 사용자 에이전트가 설정 한 헤더에서 &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;https://fetch.spec.whatwg.org/#forbidden-header-name&quot;&gt;는 &quot;금지 헤더 이름&quot;로 가져 오기 스펙에 정의 된 다른 헤더&lt;/a&gt; ), 수동으로 설정할 수 있도록 허용 된 머리글 만있는 &lt;a href=&quot;https://fetch.spec.whatwg.org/#cors-safelisted-request-header&quot;&gt;사람들은 Fetch 사양은 &quot;CORS 허용 목록에있는 요청 헤더&quot;로 정의하며 다음&lt;/a&gt; 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="970faa6cb472b485c0f707488c5cdc08b7986c8b" translate="yes" xml:space="preserve">
          <source>Apart from the headers set automatically by the user agent (for example, &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://fetch.spec.whatwg.org/#forbidden-header-name&quot;&gt;any of the other headers with names defined in the Fetch spec as a &amp;ldquo;forbidden header name&amp;rdquo;&lt;/a&gt;), the only headers which are allowed to be manually set are &lt;a href=&quot;https://fetch.spec.whatwg.org/#cors-safelisted-request-header&quot;&gt;those which the Fetch spec defines as being a &amp;ldquo;CORS-safelisted request-header&amp;rdquo;&lt;/a&gt;, which are:</source>
          <target state="translated">사용자 에이전트가 자동으로 설정 한 헤더 (예 : &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://fetch.spec.whatwg.org/#forbidden-header-name&quot;&gt;Fetch 사양에서 &quot;금지 된 헤더 이름&quot;으로 정의 된 이름을 가진 다른 헤더)&lt;/a&gt; 외에는 허용되는 유일한 헤더 수동 설정은 &lt;a href=&quot;https://fetch.spec.whatwg.org/#cors-safelisted-request-header&quot;&gt;Fetch 스펙이 &quot;CORS-safelisted request-header&quot;로 정의한 것입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1aa865a302682de3015e0ace4594cebfe9d891b1" translate="yes" xml:space="preserve">
          <source>AppCache,</source>
          <target state="translated">AppCache,</target>
        </trans-unit>
        <trans-unit id="f4f943fdac0850a40c1e416faae62566138da37d" translate="yes" xml:space="preserve">
          <source>Appendix A.  Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;</source>
          <target state="translated">부록 A. &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616의&lt;/a&gt; 변경 사항</target>
        </trans-unit>
        <trans-unit id="918d2c04181755c7d2a2da27da64eb8b93bdb750" translate="yes" xml:space="preserve">
          <source>Appendix A.  Changes from RFCs 2616 and 2617</source>
          <target state="translated">부록 A. RFC 2616 및 2617의 변경 사항</target>
        </trans-unit>
        <trans-unit id="b43034e2e81ab244701cc36ac5fa225c7d47a6b7" translate="yes" xml:space="preserve">
          <source>Appendix A.  Contributors</source>
          <target state="translated">부록 A. 기고자</target>
        </trans-unit>
        <trans-unit id="81248f72eaaeaa9ce24d21fe4f273f8ddcbc8c1d" translate="yes" xml:space="preserve">
          <source>Appendix A.  Differences between HTTP and MIME</source>
          <target state="translated">부록 A. HTTP와 MIME의 차이점</target>
        </trans-unit>
        <trans-unit id="7952612f081e615aa7bd03aa23dc4c518656090e" translate="yes" xml:space="preserve">
          <source>Appendix A.  HTTP Version History</source>
          <target state="translated">부록 A. HTTP 버전 히스토리</target>
        </trans-unit>
        <trans-unit id="6a6a944bd171bde6db3410fdca99b9555cb916eb" translate="yes" xml:space="preserve">
          <source>Appendix A.  Internet Media Type multipart/byteranges</source>
          <target state="translated">부록 A. 인터넷 매체 유형 멀티 파트 / 바이트 범위</target>
        </trans-unit>
        <trans-unit id="5a342778d6d38dec85304f64cb11f4d4619e78db" translate="yes" xml:space="preserve">
          <source>Appendix A.  Notes on Processing XML Elements</source>
          <target state="translated">부록 A. XML 요소 처리에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="a31c03a24bf30a70f8618d83f8525ac0d5fb0b3b" translate="yes" xml:space="preserve">
          <source>Appendix A.  TLS 1.2 Cipher Suite Black List</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee9c6db5c064e35f5da900ad01918c6a6eb39c9" translate="yes" xml:space="preserve">
          <source>Appendix B.  Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;</source>
          <target state="translated">부록 B. &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616의&lt;/a&gt; 변경 사항</target>
        </trans-unit>
        <trans-unit id="66e5d9de6262db2adaa063f2f1cfab6dede8a9d3" translate="yes" xml:space="preserve">
          <source>Appendix B.  Collected ABNF</source>
          <target state="translated">부록 B. 수집 된 ABNF</target>
        </trans-unit>
        <trans-unit id="4047ada28894f318e92d4c1e37bfb1baca1a4956" translate="yes" xml:space="preserve">
          <source>Appendix B.  Imported ABNF</source>
          <target state="translated">부록 B. 수입 된 ABNF</target>
        </trans-unit>
        <trans-unit id="e8da15ad98d1a9ffbcd6d66ba2fd87d4baebf827" translate="yes" xml:space="preserve">
          <source>Appendix B.  Notes on HTTP Client Compatibility</source>
          <target state="translated">부록 B. HTTP 클라이언트 호환성에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="4bc7060239451790c0c340964acba077f07d510e" translate="yes" xml:space="preserve">
          <source>Appendix B.  RELAX NG Compact Schema</source>
          <target state="translated">부록 B. RELAX NG 컴팩트 스키마</target>
        </trans-unit>
        <trans-unit id="058387e6d5459c618bca63d6f49f8d5971089303" translate="yes" xml:space="preserve">
          <source>Appendix C.  Collected ABNF</source>
          <target state="translated">부록 C. ABNF 수집</target>
        </trans-unit>
        <trans-unit id="977523ad17c09cc35f1c89152295090a33b58a76" translate="yes" xml:space="preserve">
          <source>Appendix C.  Imported ABNF</source>
          <target state="translated">부록 C. 수입 된 ABNF</target>
        </trans-unit>
        <trans-unit id="de902e4f9b3096f5f049db4d8e97c98cde2df389" translate="yes" xml:space="preserve">
          <source>Appendix C.  The 'opaquelocktoken' Scheme and URIs</source>
          <target state="translated">부록 C. 'opaquelocktoken'체계 및 URI</target>
        </trans-unit>
        <trans-unit id="ce8263e94ec9fefd83f8c080b1172f0fb08a91c8" translate="yes" xml:space="preserve">
          <source>Appendix D.  Collected ABNF</source>
          <target state="translated">부록 D. 수집 된 ABNF</target>
        </trans-unit>
        <trans-unit id="0d9be62baed7f2691c136ca29f5d801725b346de" translate="yes" xml:space="preserve">
          <source>Appendix D.  Lock-null Resources</source>
          <target state="translated">부록 D. 잠금 널 자원</target>
        </trans-unit>
        <trans-unit id="b843d7a45c5fbfe004e6dab880398f2c109d318b" translate="yes" xml:space="preserve">
          <source>Appendix E.  Guidance for Clients Desiring to Authenticate</source>
          <target state="translated">부록 E. 인증을 원하는 고객을위한 지침</target>
        </trans-unit>
        <trans-unit id="1e32692b4682e33761a3d401d643e95f4fc629c6" translate="yes" xml:space="preserve">
          <source>Appendix F.  Summary of Changes from &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;</source>
          <target state="translated">부록 F. &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; 의 변경 사항 요약</target>
        </trans-unit>
        <trans-unit id="a6b70da19fe698facbbf74a7c6848c10082c6db6" translate="yes" xml:space="preserve">
          <source>Apple Installer Package</source>
          <target state="translated">애플 인스톨러 패키지</target>
        </trans-unit>
        <trans-unit id="594c277ced56ff92f49f5549dcb6e9bb01873e08" translate="yes" xml:space="preserve">
          <source>Apple Safari rejects any such data. Google Chrome and Microsoft Edge discard up to four invalid bytes preceding a valid response. Firefox tolerates in excess of a kilobyte of invalid data preceding a valid response.</source>
          <target state="translated">Apple Safari는 그러한 데이터를 거부합니다. Chrome 및 Microsoft Edge는 유효한 응답을하기 전에 최대 4 개의 유효하지 않은 바이트를 버립니다. Firefox는 유효한 응답에 앞서 킬로바이트를 초과하는 유효하지 않은 데이터를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a7e444ff8fa9777e03d5103a61265a5f5c06bddc" translate="yes" xml:space="preserve">
          <source>AppleWebKit/xyz</source>
          <target state="translated">AppleWebKit/xyz</target>
        </trans-unit>
        <trans-unit id="978492a43f30387de57a216152fb92287c408810" translate="yes" xml:space="preserve">
          <source>April 1st joke spec</source>
          <target state="translated">4 월 1 일 농담 사양</target>
        </trans-unit>
        <trans-unit id="c3cfa2d1b2b69734300d2888ba207ad587d929b9" translate="yes" xml:space="preserve">
          <source>Arbitrary, non-specific warning</source>
          <target state="translated">임의의 비 특정 경고</target>
        </trans-unit>
        <trans-unit id="ef596164d3adddb52527e23859760cbb72f418cb" translate="yes" xml:space="preserve">
          <source>Architecture (RFC 7230)</source>
          <target state="translated">아키텍처 (RFC 7230)</target>
        </trans-unit>
        <trans-unit id="2cd9571b02d0b5f97d07115fe12dfba195dd6de2" translate="yes" xml:space="preserve">
          <source>Archive document (multiple files embedded)</source>
          <target state="translated">보관 문서 (여러 파일 포함)</target>
        </trans-unit>
        <trans-unit id="96df099182a80fa56639e210174f84a1514aeddb" translate="yes" xml:space="preserve">
          <source>Are you trying to check for the existence of a specific feature?</source>
          <target state="translated">특정 기능이 있는지 확인하려고합니까?</target>
        </trans-unit>
        <trans-unit id="22374513ed4cb776e85f41fade4e611b7089d973" translate="yes" xml:space="preserve">
          <source>Are you trying to work around a specific bug in some version of a browser?</source>
          <target state="translated">일부 버전의 브라우저에서 특정 버그를 해결하려고합니까?</target>
        </trans-unit>
        <trans-unit id="8c498b25da0ee315015a3c8c5220c1550df792eb" translate="yes" xml:space="preserve">
          <source>Arguably the most common use and misuse of user agent sniffing is to detect if the device is a mobile device. However, people too often overlook what they are really after. People use user agent sniffing to detect if the users' device is touch-friendly and has a small screen so they can optimize their website accordingly. While user agent sniffing can sometimes detect these, not all devices are the same: some mobile devices have big screen sizes, some desktops have a small touchscreen, some people use smart TV's which are an entirely different ballgame altogether, and some people can dynamically change the width and height of their screen by flipping their tablet on its side! So, user agent sniffing is definitely not the way to go. Thankfully, there are much better alternatives. Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/maxTouchPoints&quot;&gt;Navigator.maxTouchPoints&lt;/a&gt; to detect if the user's device has a touchscreen. Then, default back to checking the user agent screen only &lt;em&gt;if (!(&quot;maxTouchPoints&quot; in navigator)) { /*Code here*/}&lt;/em&gt;. Using this information of whether the device has a touchscreen, do not change the entire layout of the website just for touch devices: you will only create more work and maintenance for yourself. Rather, add in touch conveniences such as bigger, more easily clickable buttons (you can do this using CSS by simply increasing the font size). Here is an example of code that increases the padding of #exampleButton to 1em on mobile devices.</source>
          <target state="translated">사용자 에이전트 스니핑의 가장 일반적인 사용 및 오용은 장치가 모바일 장치인지 감지하는 것입니다. 그러나 사람들은 너무 자주 자신이 추구하는 것을 간과합니다. 사람들은 사용자 에이전트 스니핑을 사용하여 사용자의 기기가 터치 친화적이고 화면이 작아 그에 따라 웹 사이트를 최적화 할 수 있는지 감지합니다. 사용자 에이전트 스니핑은 때때로이를 감지 할 수 있지만 모든 장치가 동일한 것은 아닙니다. 일부 모바일 장치에는 큰 화면 크기가 있고, 일부 데스크톱에는 작은 터치 스크린이 있으며, 어떤 사람들은 완전히 다른 볼 게임 인 스마트 TV를 사용하고, 어떤 사람들은 동적으로 변경할 수 있습니다. 태블릿을 옆으로 뒤집어 화면의 너비와 높이를 조정하세요! 따라서 사용자 에이전트 스니핑은 확실히 갈 길이 아닙니다. 고맙게도 훨씬 더 나은 대안이 있습니다. 사용하다&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Navigator/maxTouchPoints&quot;&gt; Navigator.maxTouchPoints&lt;/a&gt;사용자의 기기에 터치 스크린이 있는지 감지합니다. 그런 다음 &lt;em&gt;(! ( &quot;maxTouchPoints&quot;in navigator)) {/ * Code here * /} 인 경우&lt;/em&gt; 에만 사용자 에이전트 화면을 다시 확인하도록 기본 설정 합니다. 장치에 터치 스크린이 있는지 여부에 대한이 정보를 사용하여 터치 장치만을위한 웹 사이트의 전체 레이아웃을 변경하지 마십시오. 더 많은 작업과 유지 관리를 직접 만들 수 있습니다. 오히려 더 크고 쉽게 클릭 할 수있는 버튼과 같은 터치 편의를 추가하십시오 (단순히 글꼴 크기를 늘리면 CSS를 사용하여 수행 할 수 있습니다). 다음은 휴대 기기에서 #exampleButton의 패딩을 1em으로 늘리는 코드의 예입니다.</target>
        </trans-unit>
        <trans-unit id="8cab0add88f8e2a278cfb8a5e8b164090488d38a" translate="yes" xml:space="preserve">
          <source>Arguably the most common use and misuse of user agent sniffing is to detect if the device is a mobile device. However, what is failed to be accountable is what they're really after. People use user agent sniffing to detect if the users' device is touch-friendly and has a small screen so they can optimize their website accordingly. While user agent sniffing can sometimes detect these, not all devices are the same. Some mobile devices have big screen sizes, some desktops have a small touchscreen, some people use smart TV's which are an entirely different ballgame altogether, some people can dynamically change the width and height of their screen by flipping their tablet on its side! So, user agent sniffing is definitely not the way to go. But, there are much better alternatives. Use &lt;em&gt;Navigator.maxTouchPoints&lt;/em&gt; to detect if the user's device has a touchscreen. Then, default back to checking the user agent screen only &lt;em&gt;if (!(&quot;maxTouchPoints&quot; in Navigator)) { /*Code here*/}&lt;/em&gt;. Using this information of whether the device has a touchscreen, do not change the entire layout of the website just for touch devices: you will only create more work and maintenance for yourself. Rather, add in touch conveniences such as bigger, more easily clickable buttons (you can do this using CSS by simply increasing the font size). As for the screen size, simply use &lt;em&gt;window.innerWidth&lt;/em&gt; and &lt;em&gt;window.addEventListener(&quot;resize&quot;, function(){ /*refresh screen size dependent things*/ })&lt;/em&gt;. What you want to do for screen size is not slash off information on smaller screens. That will only annoy people because it will force them to use the desktop version. Rather, try to have fewer columns of information in a longer page on smaller screens while having more columns with a shorter page on larger screen sizes. This effect can be easily achieved using CSS flexboxes. Next, always make your code dynamic. The user can flip their mobile device on its side, changing the width and height of the page. Never be satisfied with your webpage until you can open up the dev tools side panel and resize the screen while the webpage looks smooth, fluid, and dynamically resized.</source>
          <target state="translated">사용자 에이전트 스니핑의 가장 일반적인 사용 및 오용은 장치가 모바일 장치인지 여부를 감지하는 것입니다. 그러나 책임을지지 않는 것은 그들이 실제로 추구하는 것입니다. 사람들은 사용자 에이전트 스니핑을 사용하여 사용자의 기기가 터치 친화적이고 작은 화면을 가지고 있는지 여부를 감지하여 그에 따라 웹 사이트를 최적화 할 수 있습니다. 사용자 에이전트 스니핑이 때때로이를 감지 할 수 있지만 모든 장치가 동일한 것은 아닙니다. 일부 휴대 기기에는 화면 크기가 크고 일부 데스크톱에는 터치 스크린이 작고 일부 사람들은 완전히 다른 볼 게임 인 스마트 TV를 사용하며 일부 사람들은 태블릿을 옆으로 뒤집어 화면의 너비와 높이를 동적으로 변경할 수 있습니다! 따라서 사용자 에이전트 스니핑은 확실히 진행되지 않습니다. 그러나 훨씬 더 나은 대안이 있습니다. &lt;em&gt;Navigator.maxTouchPoints&lt;/em&gt; 사용&lt;em&gt;&lt;/em&gt;사용자의 기기에 터치 스크린이 있는지 감지합니다. 그런 다음 기본적으로 사용자 에이전트 화면 확인으로 돌아갑니다 &lt;em&gt;((((Navigator의 &quot;maxTouchPoints&quot;)) {/ * Code here * /})&lt;/em&gt; . 장치에 터치 스크린이 있는지 여부에 대한이 정보를 사용하여 터치 장치에 대해서만 웹 사이트의 전체 레이아웃을 변경하지 마십시오. 사용자를 위해 더 많은 작업과 유지 보수 만 만들 수 있습니다. 오히려 더 크고 더 쉽게 클릭 할 수있는 버튼과 같은 편리한 터치 기능을 추가하십시오 (글꼴 크기를 늘리면 CSS를 사용하여이를 수행 할 수 있음). 화면 크기는 &lt;em&gt;window.innerWidth&lt;/em&gt; 및 &lt;em&gt;window.addEventListener ( &quot;resize&quot;, function () {/ * 화면 크기에 따라 새로 고침 된 항목 * /})를 사용하십시오.&lt;/em&gt;. 화면 크기에 대해 수행하려는 작업은 더 작은 화면의 정보를 제거하지 않습니다. 데스크톱 버전을 사용하도록 강요하기 때문에 사람들을 귀찮게 할 것입니다. 오히려 작은 화면에서는 긴 페이지에 정보 열이 적고 큰 화면에서는 짧은 페이지의 열이 더 많습니다. 이 효과는 CSS flexbox를 사용하여 쉽게 달성 할 수 있습니다. 다음으로 항상 코드를 동적으로 만드십시오. 사용자는 모바일 장치를 옆으로 뒤집어 페이지 너비와 높이를 변경할 수 있습니다. 웹 페이지가 매끄럽고 유동적이며 동적으로 크기가 조정되는 동안 개발 도구 측면 패널을 열고 화면 크기를 조정할 수있을 때까지 웹 페이지에 만족하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="aec8c8505f13b416d6485fc08c67f5112086e6ad" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      #field-name

   The &quot;no-cache&quot; response directive indicates that the response MUST
   NOT be used to satisfy a subsequent request without successful
   validation on the origin server.  This allows an origin server to
   prevent a cache from using it to satisfy a request without contacting
   it, even by caches that have been configured to send stale responses.

   If the no-cache response directive specifies one or more field-names,
   then a cache MAY use the response to satisfy a subsequent request,
   subject to any other restrictions on caching.  However, any header
   fields in the response that have the field-name(s) listed MUST NOT be
   sent in the response to a subsequent request without successful
   revalidation with the origin server.  This allows an origin server to
   prevent the re-use of certain header fields in a response, while
   still allowing caching of the rest of the response.

   The field-names given are not limited to the set of header fields
   defined by this specification.  Field names are case-insensitive. 

   This directive uses the quoted-string form of the argument syntax.  A
   sender SHOULD NOT generate the token form (even if quoting appears
   not to be needed for single-entry lists).

   Note: Although it has been back-ported to many implementations, some
   HTTP/1.0 caches will not recognize or obey this directive.  Also,
   no-cache response directives with field-names are often handled by
   caches as if an unqualified no-cache directive was received; i.e.,
   the special handling for the qualified form is not widely
   implemented.</source>
          <target state="translated">인수 구문 : # field-name &quot;no-cache&quot;응답 지시문은 오리진 서버에서 성공적으로 검증하지 않고 후속 요청을 만족시키기 위해 응답을 사용해서는 안됨을 나타냅니다. 따라서 원본 서버는 오래된 응답을 보내도록 구성된 캐시에 의해서도 캐시가 캐시를 사용하여 요청을 충족시키지 못하도록 캐시를 사용하지 못하게 할 수 있습니다. 캐시 없음 응답 지시문이 하나 이상의 필드 이름을 지정하면 캐시는 캐싱에 대한 다른 제한 사항에 따라 응답을 사용하여 후속 요청을 충족시킬 수 있습니다. 그러나 필드 이름이 나열된 응답의 헤더 필드는 원본 서버와의 유효성을 다시 확인하지 않고 후속 요청에 대한 응답으로 전송해서는 안됩니다 (MUST NOT).이를 통해 오리진 서버는 응답에서 특정 헤더 필드의 재사용을 방지하면서도 나머지 응답을 캐싱 할 수 있습니다. 제공된 필드 이름은이 사양에서 정의한 헤더 필드 집합으로 제한되지 않습니다. 필드 이름은 대소 문자를 구분하지 않습니다. 이 지시문은 따옴표로 묶은 문자열 형식의 인수 구문을 사용합니다. 발신자는 토큰 양식을 생성하지 않아야합니다 (단일 입력 목록에 인용이 필요하지 않은 경우에도). 참고 : 많은 구현으로 백 포트되었지만 일부 HTTP / 1.0 캐시는이 지시문을 인식하거나 따르지 않습니다. 또한 필드 이름이있는 캐시없는 응답 지시문은 종종 정규화되지 않은 no-cache 지시문이 수신 된 것처럼 캐시에 의해 처리됩니다. 즉, 적격 양식에 대한 특수 처리는 널리 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1831ae5ad42c135eef58117ca5beea27918ee39" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      #field-name 

   The &quot;private&quot; response directive indicates that the response message
   is intended for a single user and MUST NOT be stored by a shared
   cache.  A private cache MAY store the response and reuse it for later
   requests, even if the response would normally be non-cacheable.

   If the private response directive specifies one or more field-names,
   this requirement is limited to the field-values associated with the
   listed response header fields.  That is, a shared cache MUST NOT
   store the specified field-names(s), whereas it MAY store the
   remainder of the response message.

   The field-names given are not limited to the set of header fields
   defined by this specification.  Field names are case-insensitive.

   This directive uses the quoted-string form of the argument syntax.  A
   sender SHOULD NOT generate the token form (even if quoting appears
   not to be needed for single-entry lists).

   Note: This usage of the word &quot;private&quot; only controls where the
   response can be stored; it cannot ensure the privacy of the message
   content.  Also, private response directives with field-names are
   often handled by caches as if an unqualified private directive was
   received; i.e., the special handling for the qualified form is not
   widely implemented.</source>
          <target state="translated">인수 구문 : # field-name &quot;private&quot;응답 지시문은 응답 메시지가 단일 사용자를위한 것이며 공유 캐시에 저장되어서는 안됨을 나타냅니다. 개인 캐시는 응답을 캐시 할 수없는 경우에도 응답을 저장하고 나중에 요청에 재사용 할 수 있습니다. 개인 응답 지시문이 하나 이상의 필드 이름을 지정하는 경우이 요구 사항은 나열된 응답 헤더 필드와 연관된 필드 값으로 제한됩니다. 즉, 공유 캐시는 지정된 필드 이름을 저장해서는 안되며 나머지 응답 메시지는 저장할 수 있습니다. 제공된 필드 이름은이 사양에서 정의한 헤더 필드 집합으로 제한되지 않습니다. 필드 이름은 대소 문자를 구분하지 않습니다. 이 지시문은 따옴표로 묶은 문자열 형식의 인수 구문을 사용합니다.발신자는 토큰 양식을 생성하지 않아야합니다 (단일 입력 목록에 인용이 필요하지 않은 경우에도). 참고 : &quot;private&quot;이라는 단어의 사용법은 응답을 저장할 수있는 위치 만 제어합니다. 메시지 내용의 프라이버시를 보장 할 수 없습니다. 또한 필드 이름이있는 개인 응답 지시문은 종종 규정되지 않은 개인 지시문이 수신 된 것처럼 캐시에 의해 처리됩니다. 즉, 적격 양식에 대한 특수 처리는 널리 구현되지 않습니다.필드 이름이있는 개인 응답 지시문은 종종 규정되지 않은 개인 지시문이 수신 된 것처럼 캐시에 의해 처리됩니다. 즉, 적격 양식에 대한 특수 처리는 널리 구현되지 않습니다.필드 이름이있는 개인 응답 지시문은 종종 규정되지 않은 개인 지시문이 수신 된 것처럼 캐시에 의해 처리됩니다. 즉, 적격 양식에 대한 특수 처리는 널리 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4aefbf84315b53b56a158fafd1e4047cf84680b4" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      delta-seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;)

   The &quot;max-age&quot; request directive indicates that the client is
   unwilling to accept a response whose age is greater than the
   specified number of seconds.  Unless the max-stale request directive
   is also present, the client is not willing to accept a stale
   response.

   This directive uses the token form of the argument syntax: e.g.,
   'max-age=5' not 'max-age=&quot;5&quot;'.  A sender SHOULD NOT generate the
   quoted-string form.</source>
          <target state="translated">인수 구문 : delta-seconds ( &lt;a href=&quot;#section-1.2.1&quot;&gt;1.2.1 절&lt;/a&gt; 참조 ) &quot;max-age&quot;요청 지시문은 클라이언트가 연령이 지정된 시간 (초)보다 큰 응답을 수락하지 않음을 나타냅니다. max-stale 요청 지시문도 없으면 클라이언트는 오래된 응답을 기꺼이 수락하지 않습니다. 이 지시문은 인수 구문의 토큰 형식을 사용합니다 (예 : 'max-age = &quot;5&quot;'가 아닌 'max-age = 5' '). 발신자는 따옴표로 묶인 문자열 형식을 생성하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="13b97b4c1790a5d1690e4603b26402d86eb7b629" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      delta-seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;)

   The &quot;max-age&quot; response directive indicates that the response is to be
   considered stale after its age is greater than the specified number
   of seconds.

   This directive uses the token form of the argument syntax: e.g.,
   'max-age=5' not 'max-age=&quot;5&quot;'.  A sender SHOULD NOT generate the
   quoted-string form.</source>
          <target state="translated">인수 구문 : delta-seconds ( &lt;a href=&quot;#section-1.2.1&quot;&gt;1.2.1 절&lt;/a&gt; 참조 ) &quot;max-age&quot;응답 지시문은 응답 시간이 지정된 시간 (초)보다 큰 후에 응답이 무효로 간주됨을 나타냅니다. 이 지시문은 인수 구문의 토큰 형식을 사용합니다 (예 : 'max-age = &quot;5&quot;'가 아닌 'max-age = 5' '). 발신자는 따옴표로 묶인 문자열 형식을 생성하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="06cca4dcd60697e3d0f6bcb9d03459f0446ded37" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      delta-seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;)

   The &quot;max-stale&quot; request directive indicates that the client is
   willing to accept a response that has exceeded its freshness
   lifetime.  If max-stale is assigned a value, then the client is
   willing to accept a response that has exceeded its freshness lifetime
   by no more than the specified number of seconds.  If no value is
   assigned to max-stale, then the client is willing to accept a stale
   response of any age.

   This directive uses the token form of the argument syntax: e.g.,
   'max-stale=10' not 'max-stale=&quot;10&quot;'.  A sender SHOULD NOT generate
   the quoted-string form.</source>
          <target state="translated">인수 구문 : delta-seconds ( &lt;a href=&quot;#section-1.2.1&quot;&gt;1.2.1 절&lt;/a&gt; 참조 ) &quot;max-stale&quot;요청 지시문은 클라이언트가 신선도 수명을 초과 한 응답을 기꺼이 수락 함을 나타냅니다. max-stale에 값이 할당되면 클라이언트는 지정된 시간 (초)만큼 신선도 수명을 초과 한 응답을 기꺼이 수락합니다. max-stale에 값이 지정되지 않으면 클라이언트는 모든 연령의 오래된 응답을 기꺼이 수락합니다. 이 지시문은 인수 구문의 토큰 형식을 사용합니다 (예 : 'max-stale = 10'not 'max-stale = &quot;10&quot;'). 발신자는 따옴표로 묶인 문자열 형식을 생성하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a825cbd8ee60bf462c6dee710ec7c6f4b00811e3" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      delta-seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;)

   The &quot;s-maxage&quot; response directive indicates that, in shared caches,
   the maximum age specified by this directive overrides the maximum age
   specified by either the max-age directive or the Expires header
   field.  The s-maxage directive also implies the semantics of the
   proxy-revalidate response directive.

   This directive uses the token form of the argument syntax: e.g.,
   's-maxage=10' not 's-maxage=&quot;10&quot;'.  A sender SHOULD NOT generate the
   quoted-string form.</source>
          <target state="translated">인수 구문 : 델타-초 ( &lt;a href=&quot;#section-1.2.1&quot;&gt;섹션 1.2.1&lt;/a&gt; 참조 ) &quot;s-maxage&quot;응답 지시문은 공유 캐시에서이 지시문에 의해 지정된 최대 보존 기간이 max-age 지시어 또는 만료에 의해 지정된 최대 보존 기간보다 우선 함을 나타냅니다. 헤더 필드. s-maxage 지시문은 또한 proxy-revalidate 응답 지시문의 의미를 의미합니다. 이 지시문은 인수 구문의 토큰 형식을 사용합니다 (예 : 's-maxage = 10'not 's-maxage = &quot;10&quot;'). 발신자는 따옴표로 묶인 문자열 형식을 생성하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="ecc2f52fea65ff20c3fe05e836282a0ecfcb5341" translate="yes" xml:space="preserve">
          <source>Argument syntax:

      delta-seconds (see &lt;a href=&quot;#section-1.2.1&quot;&gt;Section 1.2.1&lt;/a&gt;) 

   The &quot;min-fresh&quot; request directive indicates that the client is
   willing to accept a response whose freshness lifetime is no less than
   its current age plus the specified time in seconds.  That is, the
   client wants a response that will still be fresh for at least the
   specified number of seconds.

   This directive uses the token form of the argument syntax: e.g.,
   'min-fresh=20' not 'min-fresh=&quot;20&quot;'.  A sender SHOULD NOT generate
   the quoted-string form.</source>
          <target state="translated">인수 구문 : 델타-초 ( &lt;a href=&quot;#section-1.2.1&quot;&gt;섹션 1.2.1&lt;/a&gt; 참조 ) &quot;min-fresh&quot;요청 지시문은 클라이언트가 최신 수명과 현재 시간에 지정된 시간 (초)을 더한 응답을 기꺼이 수락 함을 나타냅니다. 즉, 클라이언트는 최소한 지정된 시간 (초) 동안 새로운 응답을 원합니다. 이 지시문은 인수 구문의 토큰 형식을 사용합니다 (예 : 'min-fresh = 20'not 'min-fresh = &quot;20&quot;'). 발신자는 인용 문자열 형식을 생성해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7c422841b7e3951946583038790545c4ed38481b" translate="yes" xml:space="preserve">
          <source>Articles</source>
          <target state="translated">Articles</target>
        </trans-unit>
        <trans-unit id="6927f0a6d5b5b7a8990677811eb75f75899710be" translate="yes" xml:space="preserve">
          <source>As a &lt;a href=&quot;https://en.wikipedia.org/wiki/Defense_in_depth_(computing)&quot;&gt;defence-in-depth measure&lt;/a&gt;, however, it is possible to use &lt;em&gt;cookie prefixes&lt;/em&gt; to assert specific facts about the cookie. Two prefixes are available:</source>
          <target state="translated">A와 &lt;a href=&quot;https://en.wikipedia.org/wiki/Defense_in_depth_(computing)&quot;&gt;심층 방어 조치&lt;/a&gt; , 그러나, 사용할 수 있습니다 &lt;em&gt;쿠키 접두사를&lt;/em&gt; 쿠키에 대한 어설 션 특정 사실에. 두 가지 접두사를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbe5fd2ae86fbae88e539aaddac116ef8cfd88d6" translate="yes" xml:space="preserve">
          <source>As a header for a multipart body</source>
          <target state="translated">멀티 파트 바디의 헤더로</target>
        </trans-unit>
        <trans-unit id="4db566644cc9fbe6a83b2c42804119cde6babd72" translate="yes" xml:space="preserve">
          <source>As a multipart document format, it consists of different parts, delimited by a boundary (a string starting with a double dash &lt;code&gt;'--'&lt;/code&gt;). Each part is its own entity with its own HTTP headers, &lt;a href=&quot;../headers/content-disposition&quot;&gt;&lt;code&gt;Content-Disposition&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; for file uploading fields.</source>
          <target state="translated">여러 부분으로 구성된 문서 형식은 경계 (두 개의 대시 &lt;code&gt;'--'&lt;/code&gt; 시작하는 문자열)로 구분 된 다른 부분으로 구성됩니다 . 각 부분은 파일 업로드 필드를위한 고유 한 HTTP 헤더, &lt;a href=&quot;../headers/content-disposition&quot;&gt; &lt;code&gt;Content-Disposition&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 이있는 자체 엔티티입니다 .</target>
        </trans-unit>
        <trans-unit id="178623dce37dff8814bd5d7a8ed3496b3a38d15c" translate="yes" xml:space="preserve">
          <source>As a multipart document format, it consists of different parts, delimited by a boundary (a string starting with a double dash &lt;code&gt;--&lt;/code&gt;). Each part is its own entity with its own HTTP headers, &lt;a href=&quot;../headers/content-disposition&quot;&gt;&lt;code&gt;Content-Disposition&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; for file uploading fields.</source>
          <target state="translated">여러 부분으로 된 문서 형식이므로 경계로 구분 된 여러 부분으로 구성됩니다 (이중 대시 &lt;code&gt;--&lt;/code&gt; 시작하는 문자열 ). 각 부분은 자체 HTTP 헤더, &lt;a href=&quot;../headers/content-disposition&quot;&gt; &lt;code&gt;Content-Disposition&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 이있는 자체 엔티티입니다. 파일 업로드 필드를위한 .</target>
        </trans-unit>
        <trans-unit id="f8c3d44cd58fb8f4d3b3944cc4bb1a87c5213f6f" translate="yes" xml:space="preserve">
          <source>As a response header for the main body</source>
          <target state="translated">본체에 대한 응답 헤더로</target>
        </trans-unit>
        <trans-unit id="fe358a19fe3a891412dc63b31012cfff7e86b53a" translate="yes" xml:space="preserve">
          <source>As above, but use proxy for local servers which are outside the firewall</source>
          <target state="translated">위와 같지만 방화벽 외부에있는 로컬 서버에는 프록시를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="21bb09d2ae7faa16332b73a9ff9b212546d3db2e" translate="yes" xml:space="preserve">
          <source>As an HTTP/1.x connection is serializing requests, even without any ordering, it can't be optimal without large enough available bandwidth. As a solution, browsers open several connections to each domain, sending parallel requests. Default was once 2 to 3 connections, but this has now increased to a more common use of 6 parallel connections. There is a risk of triggering &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DOS_attack&quot;&gt;DoS&lt;/a&gt; protection on the server side if attempting more than this number.</source>
          <target state="translated">HTTP / 1.x 연결은 순서를 지정하지 않아도 요청을 직렬화하므로 사용 가능한 충분한 대역폭이 없으면 최적이 될 수 없습니다. 솔루션으로 브라우저는 각 도메인에 여러 연결을 열어 병렬 요청을 보냅니다. 기본값은 한 번 2 ~ 3 개의 연결 이었지만 이제는 6 개의 병렬 연결이 더 많이 사용됩니다. 이 번호 이상을 시도하면 서버 측에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DOS_attack&quot;&gt;DoS&lt;/a&gt; 보호 가 트리거 될 위험 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac2caa651e1c42338fb211a69aa78825a0cefdcd" translate="yes" xml:space="preserve">
          <source>As an ultimate form of protection, sites that want to never allow scripts to be executed can opt to globally disallow script execution.</source>
          <target state="translated">궁극적 인 보호 방법으로 스크립트 실행을 절대 원하지 않는 사이트는 전체적으로 스크립트 실행을 허용하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c5fdf8f8fd2b7a8d4e1fc4e882626af24bfa4c2" translate="yes" xml:space="preserve">
          <source>As compression brings significant performance improvements, it is recommended to activate it for all files, but already compressed ones like images, audio files and videos.</source>
          <target state="translated">압축시 성능이 크게 향상되므로 모든 파일에 대해 압축을 활성화하는 것이 좋지만 이미 이미지, 오디오 파일 및 비디오와 같은 압축 파일을 활성화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="07e3361838eead49089d2124cc5527647d9a433d" translate="yes" xml:space="preserve">
          <source>As compression works better on a specific kind of files, it usually provides nothing to compress them a second time. In fact, this is often counter productive as the cost of the overhead (algorithms usually need a dictionary that add to the initial size) can be higher than the extra gain in compression resulting in a larger file. Do not use the two following techniques for files in a compressed format.</source>
          <target state="translated">압축은 특정 종류의 파일에서 더 잘 작동하므로 일반적으로 두 번째로 압축 할 수 없습니다. 실제로 오버 헤드 비용 (알고리즘에는 일반적으로 초기 크기에 추가되는 사전이 필요함)이 압축시 추가 이득보다 높아 파일 크기가 커질 수 있기 때문에 이는 종종 생산성에 반합니다. 압축 형식의 파일에는 다음 두 가지 기술을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="81962caea1092807ea8b2efefdcc4ff1e7fe59fa" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;, intermediaries can serve a variety of
   roles in the processing of HTTP requests and responses.  Some
   intermediaries are used to improve performance or availability.
   Others are used for access control or to filter content.  Since an
   HTTP stream has characteristics similar to a pipe-and-filter
   architecture, there are no inherent limits to the extent an
   intermediary can enhance (or interfere) with either direction of the
   stream.

   An intermediary not acting as a tunnel MUST implement the Connection
   header field, as specified in &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;, and exclude fields from
   being forwarded that are only intended for the incoming connection.

   An intermediary MUST NOT forward a message to itself unless it is
   protected from an infinite request loop.  In general, an intermediary
   ought to recognize its own server names, including any aliases, local
   variations, or literal IP addresses, and respond to such requests
   directly.</source>
          <target state="translated">&lt;a href=&quot;#section-2.3&quot;&gt;2.3 장에&lt;/a&gt; 설명 된 것처럼 중개자는 HTTP 요청 및 응답 처리에서 다양한 역할을 수행 할 수 있습니다. 일부 중개자는 성능 또는 가용성을 향상시키기 위해 사용됩니다. 다른 것은 액세스 제어 또는 컨텐츠 필터링에 사용됩니다. HTTP 스트림은 파이프 앤 필터 아키텍처와 유사한 특성을 갖기 때문에 중개자가 스트림의 어느 방향 으로든 향상 (또는 간섭) 할 수있는 범위에는 고유 한 제한이 없습니다. 터널로 작동하지 않는 중개자는 &lt;a href=&quot;#section-6.1&quot;&gt;섹션 6.1&lt;/a&gt; 에 명시된 대로 연결 헤더 필드를 구현해야합니다.수신 연결 전용 필드가 전달되지 않도록 제외합니다. 중개자는 무한 요청 루프로부터 보호되지 않는 한 메시지를 자신에게 전달해서는 안된다 (MUST NOT). 일반적으로 중개자는 별칭, 로컬 변형 또는 리터럴 IP 주소를 포함하여 자체 서버 이름을 인식하고 이러한 요청에 직접 응답해야합니다.</target>
        </trans-unit>
        <trans-unit id="f43788db4540801d9e9c8e83df8533bea5ea3e5a" translate="yes" xml:space="preserve">
          <source>As discussed above, caching servers will by default match future requests &lt;em&gt;only&lt;/em&gt; to requests with &lt;em&gt;exactly&lt;/em&gt; the same headers and header values. That means a request will be made to the origin and a new cache will be created for every slight variant that might be specified by different user-agents.</source>
          <target state="translated">위에서 설명한 것처럼 캐싱 서버는 기본적으로 향후 요청을 &lt;em&gt;정확히&lt;/em&gt; 동일한 헤더 및 헤더 값을 가진 요청 &lt;em&gt;에만 &lt;/em&gt;&lt;em&gt;일치&lt;/em&gt; 시킵니다. 즉, 오리진에 요청이 작성되고 다른 사용자 에이전트가 지정할 수있는 모든 약간의 변형에 대해 새 캐시가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2d3139df0524707e53ec9e8cd4a5811fa59a90a9" translate="yes" xml:space="preserve">
          <source>As for MIME types of audio or video files, they typically specify the container format (file type). The optional &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter&quot;&gt;codecs parameter&lt;/a&gt; can be added to the MIME type to further specify which codecs to use and what options were used to encode the media, such as codec profile, level, or other such information.</source>
          <target state="translated">오디오 또는 비디오 파일의 MIME 유형은 일반적으로 컨테이너 형식 (파일 유형)을 지정합니다. 선택적 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter&quot;&gt;코덱 매개 변수&lt;/a&gt; 를 MIME 유형에 추가하여 사용할 코덱과 코덱 프로필, 레벨 또는 기타 이러한 정보와 같은 미디어 인코딩에 사용 된 옵션을 추가로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdc03353444641fab750adbd74e2bf1df56aa6e5" translate="yes" xml:space="preserve">
          <source>As for the screen size, simply use &lt;em&gt;window.innerWidth&lt;/em&gt; and window.addEventListener(&quot;resize&quot;, function(){ /*refresh screen size dependent things*/ }). What you want to do for screen size is not slash off information on smaller screens. That will only annoy people because it will force them to use the desktop version. Rather, try to have fewer columns of information in a longer page on smaller screens while having more columns with a shorter page on larger screen sizes. This effect can be easily achieved using CSS &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox&quot;&gt;flexboxes&lt;/a&gt;, sometimes with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Floats&quot;&gt;floats&lt;/a&gt; as a partial fallback.</source>
          <target state="translated">화면 크기는 &lt;em&gt;window.innerWidth&lt;/em&gt; 와 window.addEventListener ( &quot;resize&quot;, function () {/ * 화면 크기에 따라 새로 고침 * /})을 사용하면됩니다. 화면 크기에 대해 원하는 것은 작은 화면에서 정보를 없애는 것이 아닙니다. 그것은 사람들이 데스크톱 버전을 사용하도록 강요하기 때문에 사람들을 괴롭힐 것입니다. 오히려 작은 화면에서는 더 긴 페이지에 정보 열을 더 적게 사용하고 더 큰 화면 크기에서는 더 짧은 페이지에 더 많은 열을 사용하십시오. 이 효과는 CSS &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Flexbox&quot;&gt;flexboxes를&lt;/a&gt; 사용하여 쉽게 얻을 수 있으며 때로는 부분적인 폴백 으로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Floats&quot;&gt;float&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0808a49d5ce5e6736477468b862009c7c3fdd1ef" translate="yes" xml:space="preserve">
          <source>As introduced in &lt;a href=&quot;#section-8.7&quot;&gt;Section 8.7&lt;/a&gt;, extra information on error conditions
   can be included in the body of many status responses.  This section
   makes requirements on the use of the error body mechanism and
   introduces a number of precondition and postcondition codes.

   A &quot;precondition&quot; of a method describes the state of the server that
   must be true for that method to be performed.  A &quot;postcondition&quot; of a
   method describes the state of the server that must be true after that
   method has been completed.

   Each precondition and postcondition has a unique XML element
   associated with it.  In a 207 Multi-Status response, the XML element
   MUST appear inside an 'error' element in the appropriate 'propstat or
   'response' element depending on whether the condition applies to one
   or more properties or to the resource as a whole.  In all other error
   responses where this specification's 'error' body is used, the
   precondition/postcondition XML element MUST be returned as the child
   of a top-level 'error' element in the response body, unless otherwise
   negotiated by the request, along with an appropriate response status.
   The most common response status codes are 403 (Forbidden) if the
   request should not be repeated because it will always fail, and 409
   (Conflict) if it is expected that the user might be able to resolve
   the conflict and resubmit the request.  The 'error' element MAY
   contain child elements with specific error information and MAY be
   extended with any custom child elements.

   This mechanism does not take the place of using a correct numeric
   status code as defined here or in HTTP, because the client must
   always be able to take a reasonable course of action based only on
   the numeric code.  However, it does remove the need to define new
   numeric codes.  The new machine-readable codes used for this purpose
   are XML elements classified as preconditions and postconditions, so
   naturally, any group defining a new condition code can use their own
   namespace.  As always, the &quot;DAV:&quot; namespace is reserved for use by
   IETF-chartered WebDAV working groups. 

   A server supporting this specification SHOULD use the XML error
   whenever a precondition or postcondition defined in this document is
   violated.  For error conditions not specified in this document, the
   server MAY simply choose an appropriate numeric status and leave the
   response body blank.  However, a server MAY instead use a custom
   condition code and other supporting text, because even when clients
   do not automatically recognize condition codes, they can be quite
   useful in interoperability testing and debugging.

   Example - Response with precondition code

   &amp;gt;&amp;gt;Response

      HTTP/1.1 423 Locked
      Content-Type: application/xml; charset=&quot;utf-8&quot;
      Content-Length: xxxx

      &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
      &amp;lt;D:error xmlns:D=&quot;DAV:&quot;&amp;gt;
        &amp;lt;D:lock-token-submitted&amp;gt;
          &amp;lt;D:href&amp;gt;/workspace/webdav/&amp;lt;/D:href&amp;gt;
        &amp;lt;/D:lock-token-submitted&amp;gt;
      &amp;lt;/D:error&amp;gt;

   In this example, a client unaware of a depth-infinity lock on the
   parent collection &quot;/workspace/webdav/&quot; attempted to modify the
   collection member &quot;/workspace/webdav/proposal.doc&quot;.

   Some other useful preconditions and postconditions have been defined
   in other specifications extending WebDAV, such as [&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt;] (see
   particularly &lt;a href=&quot;#section-7.1.1&quot;&gt;Section 7.1.1&lt;/a&gt;), [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;], and [&lt;a href=&quot;https://tools.ietf.org/html/rfc3648&quot;&gt;RFC3648&lt;/a&gt;].

   All these elements are in the &quot;DAV:&quot; namespace.  If not specified
   otherwise, the content for each condition's XML element is defined to
   be empty.


   Name:  lock-token-matches-request-uri

   Use with:  409 Conflict

   Purpose:  (precondition) -- A request may include a Lock-Token header
      to identify a lock for the UNLOCK method.  However, if the
      Request-URI does not fall within the scope of the lock identified
      by the token, the server SHOULD use this error.  The lock may have
      a scope that does not include the Request-URI, or the lock could
      have disappeared, or the token may be invalid. 

   Name:  lock-token-submitted (precondition)

   Use with:  423 Locked

   Purpose:  The request could not succeed because a lock token should
      have been submitted.  This element, if present, MUST contain at
      least one URL of a locked resource that prevented the request.  In
      cases of MOVE, COPY, and DELETE where collection locks are
      involved, it can be difficult for the client to find out which
      locked resource made the request fail -- but the server is only
      responsible for returning one such locked resource.  The server
      MAY return every locked resource that prevented the request from
      succeeding if it knows them all.

   &amp;lt;!ELEMENT lock-token-submitted (href+) &amp;gt;


   Name:  no-conflicting-lock (precondition)

   Use with:  Typically 423 Locked

   Purpose:  A LOCK request failed due the presence of an already
      existing conflicting lock.  Note that a lock can be in conflict
      although the resource to which the request was directed is only
      indirectly locked.  In this case, the precondition code can be
      used to inform the client about the resource that is the root of
      the conflicting lock, avoiding a separate lookup of the
      &quot;lockdiscovery&quot; property.

   &amp;lt;!ELEMENT no-conflicting-lock (href)* &amp;gt;


   Name:  no-external-entities

   Use with:  403 Forbidden

   Purpose:  (precondition) -- If the server rejects a client request
      because the request body contains an external entity, the server
      SHOULD use this error.


   Name:  preserved-live-properties

   Use with:  409 Conflict

   Purpose:  (postcondition) -- The server received an otherwise-valid
      MOVE or COPY request, but cannot maintain the live properties with
      the same behavior at the destination.  It may be that the server 

      only supports some live properties in some parts of the
      repository, or simply has an internal error.


   Name:  propfind-finite-depth

   Use with:  403 Forbidden

   Purpose:  (precondition) -- This server does not allow infinite-depth
      PROPFIND requests on collections.


   Name:  cannot-modify-protected-property

   Use with:  403 Forbidden

   Purpose:  (precondition) -- The client attempted to set a protected
      property in a PROPPATCH (such as DAV:getetag).  See also
      &lt;a href=&quot;https://tools.ietf.org/html/rfc3253#section-3.12&quot;&gt;[RFC3253], Section&amp;nbsp;3.12&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#section-8.7&quot;&gt;섹션 8.7&lt;/a&gt; 에서 소개 된 바와 같이오류 상태에 대한 추가 정보는 여러 상태 응답 본문에 포함될 수 있습니다. 이 섹션에서는 오류 본문 메커니즘 사용에 대한 요구 사항을 만들고 여러 전제 조건 및 사후 조건 코드를 소개합니다. 메소드의 &quot;전제 조건&quot;은 해당 메소드가 수행 되려면 서버의 상태를 설명합니다. 메소드의 &quot;사후 조건&quot;은 해당 메소드가 완료된 후 참이어야하는 서버의 상태를 설명합니다. 각 사전 조건과 사후 조건에는 고유 한 XML 요소가 있습니다. 207 다중 상태 응답에서 XML 요소는 적절한 'propstat 또는'response '의'error '요소 안에 있어야합니다.조건이 하나 이상의 속성에 적용되는지 또는 리소스 전체에 적용되는지에 따라 요소. 이 명세의 '오류'본문이 사용되는 다른 모든 오류 응답에서 사전 조건 / 사후 조건 XML 요소는 요청에 의해 달리 협상되지 않는 한 응답 본문에서 최상위 '오류'요소의 자식으로 반환되어야합니다. 적절한 응답 상태. 요청이 항상 실패하여 반복되지 않아야하는 경우 가장 일반적인 응답 상태 코드는 403 (금지됨)이고, 사용자가 충돌을 해결하고 요청을 다시 제출할 수있을 것으로 예상되는 경우 409 (충돌)입니다. 'error'요소는 특정 오류 정보가있는 자식 요소를 포함 할 수 있으며 모든 사용자 정의 자식 요소로 확장 될 수 있습니다.클라이언트는 항상 숫자 코드만을 기반으로 합리적인 조치를 취할 수 있어야하기 때문에이 메커니즘은 여기 또는 HTTP에 정의 된 올바른 숫자 상태 코드를 사용하지 않습니다. 그러나 새 숫자 코드를 정의 할 필요가 없습니다. 이 목적으로 사용되는 새로운 기계 판독 가능 코드는 전제 조건과 사후 조건으로 분류 된 XML 요소이므로 당연히 새 조건 코드를 정의하는 모든 그룹은 자체 네임 스페이스를 사용할 수 있습니다. 항상 그렇듯이 &quot;DAV :&quot;네임 스페이스는 IETF 공인 WebDAV 작업 그룹에서 사용하도록 예약되어 있습니다. 이 사양을 지원하는 서버는이 문서에 정의 된 전제 조건 또는 사후 조건을 위반할 때마다 XML 오류를 사용해야합니다. 이 문서에 명시되지 않은 오류 조건의 경우서버는 단순히 적절한 숫자 상태를 선택하고 응답 본문을 비워 둘 수 있습니다. 그러나 클라이언트가 조건 코드를 자동으로 인식하지 않더라도 상호 운용성 테스트 및 디버깅에 매우 유용 할 수 있기 때문에 서버는 대신 사용자 정의 조건 코드 및 기타 지원 텍스트를 사용할 수 있습니다. 예-전제 조건 코드 &amp;gt;&amp;gt; 응답 HTTP / 1.1의 응답 423 잠긴 컨텐츠 유형 : application / xml; charset = &quot;utf-8&quot;Content-Length : xxxx &amp;lt;? xml version = &quot;1.0&quot;encoding = &quot;utf-8&quot;?&amp;gt; &amp;lt;D : error xmlns : D = &quot;DAV :&quot;&amp;gt; &amp;lt;D : lock-token-submitted &amp;gt; &amp;lt;D : href&amp;gt; / workspace / webdav / &amp;lt;/ D : href&amp;gt; &amp;lt;/ D : lock-token-submitted&amp;gt; &amp;lt;/ D : error&amp;gt;이 예에서상위 콜렉션 &quot;/ workspace / webdav /&quot;에서 깊이 무한대 잠금을 인식하지 못하는 클라이언트가 콜렉션 구성원 &quot;/workspace/webdav/proposal.doc&quot;을 수정하려고했습니다. WebDAV를 확장하는 다른 사양에는 다음과 같은 다른 유용한 전제 조건과 사후 조건이 정의되어 있습니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC3744&lt;/a&gt; ] (특히 &lt;a href=&quot;#section-7.1.1&quot;&gt;섹션 7.1.1&lt;/a&gt; 참조 ), [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ] 및 [&lt;a href=&quot;https://tools.ietf.org/html/rfc3648&quot;&gt; RFC3648&lt;/a&gt;]. 이러한 모든 요소는 &quot;DAV :&quot;네임 스페이스에 있습니다. 달리 지정하지 않으면 각 조건의 XML 요소에 대한 내용이 비어있는 것으로 정의됩니다. 이름 : lock-token-matches-request-uri 다음과 함께 사용 : 409 충돌 목적 : (전제 조건)-요청에 UNLOCK 메서드의 잠금을 식별하기위한 Lock-Token 헤더가 포함될 수 있습니다. 그러나 Request-URI가 토큰으로 식별 된 잠금 범위에 속하지 않으면 서버는이 오류를 사용해야합니다. 잠금에 Request-URI가 포함되지 않은 범위가 있거나 잠금이 사라 졌거나 토큰이 유효하지 않을 수 있습니다. 이름 : 잠금 토큰 제출 (전제 조건) 다음과 함께 사용 : 423 잠금 목적 : 잠금 토큰이 제출되어 요청이 실패했습니다. 이 요소가 있다면요청을 방해하는 잠겨진 리소스의 URL을 하나 이상 포함해야합니다. 콜렉션 잠금이 관련된 MOVE, COPY 및 DELETE의 경우, 클라이언트가 어떤 잠금 자원이 요청을 실패하게했는지 알아내는 것이 어려울 수 있지만 서버는 이러한 잠금 자원 중 하나만 리턴해야합니다. 서버는 요청을 모두 알고 있으면 요청이 성공하지 못하도록 잠긴 모든 자원을 반환 할 수 있습니다. &amp;lt;! ELEMENT 잠금 토큰 제출 (href +)&amp;gt; 이름 : 충돌 방지 잠금 (전제 조건) 함께 사용 : 일반적으로 423 잠금 목적 : 기존 충돌 잠금이 이미 존재하므로 잠금 요청에 실패했습니다. 요청이 전달 된 리소스가 간접적으로 만 잠겨 있어도 잠금이 충돌 할 수 있습니다. 이 경우전제 조건 코드는 &quot;lockdiscovery&quot;특성의 개별적인 조회를 피하면서 충돌 잠금의 루트 인 자원에 대해 클라이언트에 알리는 데 사용될 수 있습니다. &amp;lt;! ELEMENT no-conflicting-lock (href) *&amp;gt; 이름 : no-external-entities 다음과 함께 사용 : 403 금지 목적 : (전제 조건)-요청 본문에 외부 엔터티가 포함되어있어 서버가 클라이언트 요청을 거부하는 경우 서버 이 오류를 사용해야합니다. 이름 : preserved-live-properties 다음과 함께 사용 : 409 충돌 목적 : (사후 조건)-서버가 다른 MOVE 또는 COPY 요청을 받았지만 대상에서 동일한 동작으로 라이브 속성을 유지할 수 없습니다. 서버가 저장소 일부의 일부 라이브 특성 만 지원할 수 있습니다.또는 단순히 내부 오류가 있습니다. 이름 : propfind-finite-depth 다음과 함께 사용 : 403 금지 용도 : (전제 조건)-이 서버는 컬렉션에서 무한 깊이 PROPFIND 요청을 허용하지 않습니다. 이름 : 수정할 수 없음-속성 속성 사용 : 403 금지 목적 : (전제 조건)-클라이언트가 PROPPATCH에서 보호 속성 (예 : DAV : getetag)을 설정하려고했습니다. 또한보십시오 &lt;a href=&quot;https://tools.ietf.org/html/rfc3253#section-3.12&quot;&gt;[RFC3253], 섹션 3.12&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e578d6e0863762b2b392e523d033651de5872ee8" translate="yes" xml:space="preserve">
          <source>As is the case for images, HTML doesn't mandate that web browsers support any specific file and codec types for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, so it's important to consider your target audience and the range of browsers (and versions of those browsers) they may be using when choosing the file type and codecs to use for media.</source>
          <target state="translated">이미지의 경우와 마찬가지로 HTML은 웹 브라우저가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 대해 특정 파일 및 코덱 유형을 지원하도록 요구하지 않으므로 대상 청중과 브라우저 범위 (및 버전)를 고려하는 것이 중요합니다. 해당 브라우저) 미디어에 사용할 파일 유형 및 코덱을 선택할 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fe77ba78e510c9166dbea1c2b28c359c08ac3d8" translate="yes" xml:space="preserve">
          <source>As long as the &lt;code&gt;identity&lt;/code&gt; value, meaning no encoding, is not explicitly forbidden, by an &lt;code&gt;identity;q=0&lt;/code&gt; or a &lt;code&gt;*;q=0&lt;/code&gt; without another explicitly set value for identity, the server must never send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Acceptable&lt;/code&gt; error.</source>
          <target state="translated">긴만큼 &lt;code&gt;identity&lt;/code&gt; 더 인코딩을 의미가없는 값, 명시 적으로 금지되지 않는 &lt;code&gt;identity;q=0&lt;/code&gt; 또는 &lt;code&gt;*;q=0&lt;/code&gt; 정체성에 대한 또 다른 명시 적으로 설정 값없이 서버가 다시 보낼 안 &lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Acceptable&lt;/code&gt; 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="74200951f8f3fa2318cb0493483bd1ef3add00e6" translate="yes" xml:space="preserve">
          <source>As long as the cache is not stale, no requests are issued at all. But once it has become stale, this is mostly controlled by the &lt;a href=&quot;headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; header, the client doesn't use the cached value directly but issues a &lt;em&gt;conditional request&lt;/em&gt;. The value of the validator is used as a parameter of the &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; headers.</source>
          <target state="translated">캐시가 오래되지 않으면 요청이 전혀 발행되지 않습니다. 그러나 그것이 오래되면, 이것은 대부분 &lt;a href=&quot;headers/cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; 헤더에 의해 제어되며 , 클라이언트는 캐시 된 값을 직접 사용하지 않고 &lt;em&gt;조건부 요청을&lt;/em&gt; 발행합니다 . 유효성 검증기의 값은 &lt;a href=&quot;headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; 헤더 의 매개 변수로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="85a5d6853183730de2675bcbb36ff69a7b45767b" translate="yes" xml:space="preserve">
          <source>As of Firefox 68, &lt;code&gt;https&lt;/code&gt; pages are not permitted to access &lt;code&gt;http://localhost&lt;/code&gt;, although this may be changed by &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1488740&quot;&gt;Bug 1488740&lt;/a&gt;.</source>
          <target state="translated">Firefox 68에서 &lt;code&gt;https&lt;/code&gt; 페이지는 &lt;code&gt;http://localhost&lt;/code&gt; 에 액세스 할 수 없지만 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1488740&quot;&gt;Bug 1488740에&lt;/a&gt; 의해 변경 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="39de7dbf0fcbd56548611790fd4f9d1859fcff38" translate="yes" xml:space="preserve">
          <source>As of HTTP/1.1, the connection is no longer closed after completing the third phase, and the client is now granted a further request: this means the second and third phases can now be performed any number of times.</source>
          <target state="translated">HTTP / 1.1 기준으로, 3 단계를 완료 한 후 연결이 더 이상 닫히지 않으며 이제 클라이언트에게 추가 요청이 부여됩니다. 이는 이제 2 단계 및 3 단계를 여러 번 수행 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3267856a66c8d58fa6c67469981a2b6478095c6a" translate="yes" xml:space="preserve">
          <source>As of June 2019, the &lt;a href=&quot;https://wicg.github.io/picture-in-picture/#feature-policy&quot;&gt;spec draft&lt;/a&gt; and &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=806249#c17&quot;&gt;Google Chrome&lt;/a&gt; set default allow list to &lt;code&gt;*&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06cf4063f7dac467fae6879bda8095e3ff5808d1" translate="yes" xml:space="preserve">
          <source>As seen above, the &lt;code&gt;noreferrer&lt;/code&gt; link relation is written without a dash &amp;mdash; &lt;code&gt;noreferrer&lt;/code&gt;. When the referrer policy is specified for the entire document with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element, it's written &lt;em&gt;with&lt;/em&gt; a dash: &lt;code&gt;&amp;lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">위에서 볼 수 있듯이 &lt;code&gt;noreferrer&lt;/code&gt; 링크 관계는 대시 ( &lt;code&gt;noreferrer&lt;/code&gt; ) 없이 작성됩니다 . 리퍼러 정책이와 전체 문서를 지정하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소, 그것은 쓰여 &lt;em&gt;과&lt;/em&gt; : 대시 &lt;code&gt;&amp;lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10737eb038a18f448d914366beb682e160b36994" translate="yes" xml:space="preserve">
          <source>As seen earlier, in most cases, looking for the rendering engine is a better way to go. This will help to not exclude lesser known browsers. Browsers sharing a common rendering engine will display a page in the same way: it is often a fair assumption that what will work in one will work in the other.</source>
          <target state="translated">앞에서 본 것처럼 대부분의 경우 렌더링 엔진을 찾는 것이 더 좋은 방법입니다. 이렇게하면 덜 알려진 브라우저를 제외하지 않을 수 있습니다. 공통 렌더링 엔진을 공유하는 브라우저는 같은 방식으로 페이지를 표시합니다. 한 페이지에서 작동하는 것이 다른 사이트에서도 작동 할 것이라고 가정하는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="78c188cf3444dcabae8c9d4a1f5961a9553d9194" translate="yes" xml:space="preserve">
          <source>As several representations of a given resource are sent, shared caches are less efficient and server implementations are more complex.</source>
          <target state="translated">주어진 자원의 여러 표현이 전송 될 때 공유 캐시의 효율성이 떨어지고 서버 구현이 더 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="7377d313a5ee9a8718b11c2ecd95fc7f352f8569" translate="yes" xml:space="preserve">
          <source>As the above code demonstrates, there is &lt;strong&gt;always &lt;/strong&gt;a way to test browser support on anything, no exceptions. There &lt;strong&gt;never &lt;/strong&gt;any reason to check the user string for this.</source>
          <target state="translated">위의 코드에서 알 수 있듯이 예외없이 브라우저 지원을 테스트 할 수있는 방법 이 &lt;strong&gt;항상&lt;/strong&gt; 있습니다. 이를 위해 사용자 문자열을 확인할 이유 가 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bd630c3d2c38cd17c79f057386bd9dee90389bcb" translate="yes" xml:space="preserve">
          <source>As the above code demonstrates, there is &lt;strong&gt;always&lt;/strong&gt; a way to test browser support without user agent sniffing. There is &lt;strong&gt;never&lt;/strong&gt; any reason to check the user agent string for this.</source>
          <target state="translated">위의 코드에서 알 수 있듯이 &lt;strong&gt;항상&lt;/strong&gt; 사용자 에이전트 스니핑없이 브라우저 지원을 테스트 할 수있는 방법이 있습니다. 이를 위해 사용자 에이전트 문자열을 확인할 이유 가 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3b1896c32232ae10635b0e9d7b6084cf07068dbb" translate="yes" xml:space="preserve">
          <source>As the name implies, a reverse proxy does the opposite of what a forward proxy does: A forward proxy acts in behalf of clients (or requesting hosts), a reverse proxy acts in behalf of servers. Forward proxies can hide the identities of clients whereas reverse proxies can hide the identities of servers. Reverse proxies have several use cases, a few are:</source>
          <target state="translated">이름에서 알 수 있듯이 역방향 프록시는 정방향 프록시의 기능과 반대입니다. 정방향 프록시는 클라이언트 대신 (또는 호스트 요청), 역방향 프록시는 서버를 대신하여 작동합니다. 정방향 프록시는 클라이언트의 ID를 숨길 수 있지만 역방향 프록시는 서버의 ID를 숨길 수 있습니다. 리버스 프록시에는 몇 가지 사용 사례가 있으며 그 중 몇 가지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40dbdc58bd286d3f6c3860a41b01365fe8a90574" translate="yes" xml:space="preserve">
          <source>As the name implies, a reverse proxy does the opposite of what a forward proxy does: A forward proxy acts on behalf of clients (or requesting hosts). Forward proxies can hide the identities of clients whereas reverse proxies can hide the identities of servers. Reverse proxies have several use cases, a few are:</source>
          <target state="translated">이름에서 알 수 있듯이 역방향 프록시는 정방향 프록시의 역할과 반대입니다. 정방향 프록시는 클라이언트 (또는 요청 호스트)를 대신하여 작동합니다. 정방향 프록시는 클라이언트의 ID를 숨길 수있는 반면 역방향 프록시는 서버의 ID를 숨길 수 있습니다. 역방향 프록시에는 몇 가지 사용 사례가 있으며 그 중 몇 가지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4fdf182c8fbdda48a83dae747cba9e04f53c39b9" translate="yes" xml:space="preserve">
          <source>As the user ID and password are passed over the network as clear text (it is base64 encoded, but base64 is a reversible encoding), the basic authentication scheme &lt;strong&gt;is not secure&lt;/strong&gt;. HTTPS/TLS should be used with basic authentication. Without these additional security enhancements, basic authentication should not be used to protect sensitive or valuable information.</source>
          <target state="translated">사용자 ID와 암호가 일반 텍스트로 네트워크를 통해 전달되므로 (base64로 인코딩되지만 base64는 가역적 인코딩) 기본 인증 체계 &lt;strong&gt;는 안전하지 않습니다&lt;/strong&gt; . HTTPS / TLS는 기본 인증과 함께 사용해야합니다. 이러한 추가 보안 강화 기능이 없으면 기본 인증을 사용하여 중요하거나 중요한 정보를 보호해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="444c366dc18e9c8a26e52d6d891adf57495dae72" translate="yes" xml:space="preserve">
          <source>As the user ID and password are passed over the network as clear text (it is base64 encoded, but base64 is a reversible encoding), the basic authentication scheme is not secure. HTTPS / TLS should be used in conjunction with basic authentication. Without these additional security enhancements, basic authentication should not be used to protect sensitive or valuable information.</source>
          <target state="translated">사용자 ID와 비밀번호가 일반 텍스트 (base64로 인코딩되었지만 base64는 가역 인코딩)로 네트워크를 통해 전달되므로 기본 인증 체계는 안전하지 않습니다. 기본 인증과 함께 HTTPS / TLS를 사용해야합니다. 이러한 추가 보안 향상 기능이 없으면 중요하거나 중요한 정보를 보호하기 위해 기본 인증을 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="a6c3ae8778eda348525a5dd269ea2b796710e51f" translate="yes" xml:space="preserve">
          <source>As there is no uniformity of the different part of the user agent string, this is the tricky part.</source>
          <target state="translated">사용자 에이전트 문자열의 다른 부분에는 균일 성이 없으므로 까다로운 부분입니다.</target>
        </trans-unit>
        <trans-unit id="bc6ee085f0ae97c37cea4781b55609b159806f1f" translate="yes" xml:space="preserve">
          <source>As this policy is expressed via a &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Response_header&quot;&gt;response header&lt;/a&gt;&lt;/em&gt;, the actual request is not prevented&amp;mdash;rather, the browser prevents the &lt;em&gt;result&lt;/em&gt; from being leaked by stripping the response body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ddb1d34141f0f1a53b5fad16b4bdbb2de512647" translate="yes" xml:space="preserve">
          <source>As well as styles that are applied in JavaScript by setting the &lt;code&gt;style&lt;/code&gt; attribute directly, or by setting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/cssText&quot;&gt;&lt;code&gt;cssText&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">As well as styles that are applied in JavaScript by setting the &lt;code&gt;style&lt;/code&gt; attribute directly, or by setting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/cssText&quot;&gt; &lt;code&gt;cssText&lt;/code&gt; &lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="17fdcd20e92320a37954cc0aaa2c4492b1c32a15" translate="yes" xml:space="preserve">
          <source>As well as styles that are applied in Javascript by setting the &lt;code&gt;style&lt;/code&gt; attribute directly, or by setting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/cssText&quot;&gt;&lt;code&gt;cssText&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">뿐만 아니라 설정하여 자바 스크립트에 적용되는 스타일 &lt;code&gt;style&lt;/code&gt; , 또는 설정하여 직접 속성을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/CSSStyleDeclaration/cssText&quot;&gt; &lt;code&gt;cssText&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="d02d7f17a2dcce723df40692e0f522ac350d18cf" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;, input filtering is important.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt; 와 마찬가지로 입력 필터링이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="2ea5b0bb9c6a34b711f367b6b2d6d55f8f5e966a" translate="yes" xml:space="preserve">
          <source>As you can see, the report includes the full path to the violating resource in &lt;code&gt;blocked-uri&lt;/code&gt;. This is not always the case. For example, if the &lt;code&gt;signup.html&lt;/code&gt; attempted to load CSS from &lt;code&gt;http://anothercdn.example.com/stylesheet.css&lt;/code&gt;, the browser would &lt;em&gt;not&lt;/em&gt; include the full path, but only the origin (&lt;code&gt;http://anothercdn.example.com&lt;/code&gt;). The CSP specification &lt;a href=&quot;http://www.w3.org/TR/CSP/#security-violation-reports&quot;&gt;gives an explanation&lt;/a&gt; of this odd behaviour. In summary, this is done to prevent leaking sensitive information about cross-origin resources.</source>
          <target state="translated">As you can see, the report includes the full path to the violating resource in &lt;code&gt;blocked-uri&lt;/code&gt; . This is not always the case. For example, if the &lt;code&gt;signup.html&lt;/code&gt; attempted to load CSS from &lt;code&gt;http://anothercdn.example.com/stylesheet.css&lt;/code&gt; , the browser would &lt;em&gt;not&lt;/em&gt; include the full path, but only the origin ( &lt;code&gt;http://anothercdn.example.com&lt;/code&gt; ). The CSP specification &lt;a href=&quot;http://www.w3.org/TR/CSP/#security-violation-reports&quot;&gt;gives an explanation&lt;/a&gt; of this odd behaviour. In summary, this is done to prevent leaking sensitive information about cross-origin resources.</target>
        </trans-unit>
        <trans-unit id="090adf7d66d69b3cc82ada8155a31b95b1d5cc05" translate="yes" xml:space="preserve">
          <source>As you can see, the report includes the full path to the violating resource in &lt;code&gt;blocked-uri&lt;/code&gt;. This is not always the case. For example, when the &lt;code&gt;signup.html&lt;/code&gt; would attempt to load CSS from &lt;a href=&quot;http://anothercdn.example.com/stylesheet.css&quot;&gt;&lt;code&gt;http://anothercdn.example.com/stylesheet.css&lt;/code&gt;&lt;/a&gt;, the browser would &lt;em&gt;not&lt;/em&gt; include the full path but only the origin (&lt;code&gt;http://anothercdn.example.com&lt;/code&gt;). The CSP specification &lt;a href=&quot;http://www.w3.org/TR/CSP/#security-violation-reports&quot;&gt;gives an explanation&lt;/a&gt; of this odd behaviour. In summary, this is done to prevent leaking sensitive information about cross-origin resources.</source>
          <target state="translated">보다시피, 보고서에는 &lt;code&gt;blocked-uri&lt;/code&gt; 의 위반 리소스에 대한 전체 경로가 포함됩니다 . 항상 그런 것은 아닙니다. 예를 들어 &lt;code&gt;signup.html&lt;/code&gt; 이 &lt;a href=&quot;http://anothercdn.example.com/stylesheet.css&quot;&gt; &lt;code&gt;http://anothercdn.example.com/stylesheet.css&lt;/code&gt; &lt;/a&gt; 에서 CSS를로드하려고 하면 브라우저 에 전체 경로는 포함 &lt;em&gt;되지 않고&lt;/em&gt; 원본 ( &lt;code&gt;http://anothercdn.example.com&lt;/code&gt; ) 만 포함됩니다 ). CSP 사양 &lt;a href=&quot;http://www.w3.org/TR/CSP/#security-violation-reports&quot;&gt;은&lt;/a&gt; 이 이상한 행동에 대한 설명 을 제공합니다 . 요약하면, 이는 출처 간 자원에 대한 민감한 정보가 유출되는 것을 방지하기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ec92124be22f59c3429bab49ee1de958a60686bc" translate="yes" xml:space="preserve">
          <source>As you can see, the report includes the full path to the violating resource in &lt;code&gt;blocked-uri&lt;/code&gt;. This is not always the case. For example, when the &lt;code&gt;signup.html&lt;/code&gt; would attempt to load CSS from &lt;code&gt;http://anothercdn.example.com/stylesheet.css&lt;/code&gt;, the browser would &lt;em&gt;not&lt;/em&gt; include the full path but only the origin (&lt;code&gt;http://anothercdn.example.com&lt;/code&gt;). This is done to prevent leaking sensitive information about cross-origin resources.</source>
          <target state="translated">보다시피, 보고서에는 &lt;code&gt;blocked-uri&lt;/code&gt; 의 위반 리소스에 대한 전체 경로가 포함됩니다 . 항상 그런 것은 아닙니다. 예를 들어 &lt;code&gt;signup.html&lt;/code&gt; 이 &lt;code&gt;http://anothercdn.example.com/stylesheet.css&lt;/code&gt; 에서 CSS를로드하려고 하면 브라우저 에 전체 경로는 포함 &lt;em&gt;되지 않고&lt;/em&gt; 원본 ( &lt;code&gt;http://anothercdn.example.com&lt;/code&gt; ) 만 포함됩니다 ). 이는 출처 간 자원에 대한 민감한 정보가 유출되는 것을 방지하기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="5181c200a5bc4c79427bf4adcaa2c1205fdeba26" translate="yes" xml:space="preserve">
          <source>Asserts that a cookie must not be sent with cross-origin requests, providing some protection against cross-site request forgery attacks (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSRF&quot;&gt;CSRF&lt;/a&gt;).</source>
          <target state="translated">Asserts that a cookie must not be sent with cross-origin requests, providing some protection against cross-site request forgery attacks (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSRF&quot;&gt;CSRF&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="8d2597783f8778af171536ba979953d5e5baf049" translate="yes" xml:space="preserve">
          <source>Associates a specific cryptographic public key with a certain web server to decrease the risk of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; attacks with forged certificates.</source>
          <target state="translated">특정 암호화 공개 키를 특정 웹 서버 와 연결하여 위조 된 인증서 로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/MITM&quot;&gt;MITM&lt;/a&gt; 공격 의 위험을 줄 입니다.</target>
        </trans-unit>
        <trans-unit id="4423c564a6dd958705092c9f3f6196baaeb909f9" translate="yes" xml:space="preserve">
          <source>At this point, a typical request and response looked like this:</source>
          <target state="translated">이 시점에서 일반적인 요청 및 응답은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="640a65ab124efd895e7362db6ab879724f9f4606" translate="yes" xml:space="preserve">
          <source>Atom Entry and Feed Documents can contain XML Digital Signatures
   [&lt;a href=&quot;#ref-REC-xmldsig-core&quot;&gt;REC-xmldsig-core&lt;/a&gt;] and can be encrypted using XML Encryption
   [&lt;a href=&quot;#ref-REC-xmlenc-core&quot;&gt;REC-xmlenc-core&lt;/a&gt;] as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-5&quot;&gt;Section&amp;nbsp;5 of [RFC4287]&lt;/a&gt;.  Handling
   of signatures and encrypted elements in Atom documents is discussed
   in Sections &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; and &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; of [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].

   Neither servers nor clients are under any obligation to support
   encryption and digital signature of Entries or Feeds, although it is
   certainly possible that in some installations, clients or servers
   might require signing or encrypting of the documents exchanged in the
   Atom Protocol.

   Because servers are allowed (and in some cases, expected) to modify
   the contents of an Entry Document before publishing it, signatures
   within an entry are only likely to be useful to the server to which
   the entry is being sent.  Clients cannot assume that the signature
   will be valid when viewed by a third party, or even that the server
   will publish the client's signature.

   A server is allowed to strip client-applied signatures, to strip
   client-applied signatures and then re-sign with its own public key,
   and to oversign an entry with its own public key.  The meaning to a
   third party of a signature applied by a server is the same as a
   signature from anyone, as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].  It is RECOMMENDED
   that a server that is aware that it has changed any part of an Entry
   Document that was signed by the client should strip that signature
   before publishing the entry in order to prevent third parties from
   trying to interpret a signature that cannot be validated.</source>
          <target state="translated">원자 입력 및 피드 문서는 XML 디지털 서명 [ &lt;a href=&quot;#ref-REC-xmldsig-core&quot;&gt;REC-xmldsig-core&lt;/a&gt; ]을 포함 할 수 있으며 &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-5&quot;&gt;[RFC4287]의 5 절에&lt;/a&gt; 지정된 XML 암호화 [ &lt;a href=&quot;#ref-REC-xmlenc-core&quot;&gt;REC-xmlenc-core&lt;/a&gt; ]를 사용하여 암호화 할 수 있습니다 . Atom 문서의 서명 및 암호화 된 요소 처리는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; 의 섹션 &lt;a href=&quot;#section-5&quot;&gt;5&lt;/a&gt; 및 &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; 에서 설명합니다.]. 서버 나 클라이언트는 항목 또는 피드의 암호화 및 디지털 서명을 지원할 의무가 없지만, 일부 설치에서는 클라이언트 또는 서버가 Atom 프로토콜에서 교환 된 문서의 서명 또는 암호화를 요구할 수 있습니다. 항목 문서를 게시하기 전에 서버가 항목 문서의 내용을 수정할 수 있고 (경우에 따라 예상되는) 항목 항목의 서명은 항목을 보내는 서버에만 유용 할 수 있습니다. 클라이언트는 제 3자가 볼 때 서명이 유효하거나 서버가 클라이언트의 서명을 게시한다고 가정 할 수 없습니다. 서버는 클라이언트에 적용된 서명을 제거하고 클라이언트에 적용된 서명을 제거한 다음 자체 공개 키로 다시 서명 할 수 있습니다.자신의 공개 키로 항목을 서명합니다. 서버에서 적용한 서명의 타사에 대한 의미는 [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]. 클라이언트가 서명 한 항목 문서의 일부를 변경했음을 알고있는 서버는 항목을 공개하기 전에 해당 서명을 제거하여 검증 할 수없는 서명을 해석하지 못하도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c5aa3a3e4c19a0f5bd9d139cb1cf724de62f5c3f" translate="yes" xml:space="preserve">
          <source>Atom Feed and Entry Documents can contain XML External Entities as
   defined in Section 4.2.2 of [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].  Atom implementations are not
   required to load external entities.  External entities are subject to
   the same security concerns as any network operation and can alter the
   semantics of an Atom document.  The same issues exist for Resources
   linked to by Atom elements such as atom:link and atom:content.</source>
          <target state="translated">Atom Feed 및 Entry 문서에는 [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ]의 4.2.2 섹션에 정의 된 XML 외부 엔티티가 포함될 수 있습니다 . 외부 엔티티를로드하기 위해 Atom 구현이 필요하지 않습니다. 외부 엔터티는 모든 네트워크 작업과 동일한 보안 문제가 적용되며 Atom 문서의 의미를 변경할 수 있습니다. atom : link 및 atom : content와 같은 Atom 요소로 링크 된 자원에 대해서도 동일한 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb39269091e71d2cf80365bde28208d78373e852" translate="yes" xml:space="preserve">
          <source>Atom Feed and Entry Documents can contain a broad range of content
   types including code that might be executable in some contexts.
   Malicious clients could attempt to attack servers or other clients by
   injecting code into a Collection Document's Entry or Media Resources.

   Server implementations are strongly encouraged to verify that client-
   supplied content is safe prior to accepting, processing, or
   publishing it.  In the case of HTML, experience indicates that
   verification based on a white list of acceptable content is more
   effective than a black list of forbidden content.

   Additional information about XHTML and HTML content safety can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-8.1&quot;&gt;Section&amp;nbsp;8.1 of [RFC4287]&lt;/a&gt;.</source>
          <target state="translated">Atom Feed and Entry Documents는 일부 컨텍스트에서 실행 가능한 코드를 포함하여 광범위한 컨텐츠 유형을 포함 할 수 있습니다. 악의적 인 클라이언트는 수집 문서의 항목 또는 미디어 리소스에 코드를 삽입하여 서버 또는 다른 클라이언트를 공격 할 수 있습니다. 서버에서 구현하면 클라이언트가 제공 한 콘텐츠가 수락, 처리 또는 게시되기 전에 안전한지 확인하는 것이 좋습니다. HTML의 경우 경험에 따르면 허용되는 콘텐츠의 허용 목록을 기반으로하는 확인은 금지 된 콘텐츠의 차단 목록보다 효과적입니다. XHTML 및 HTML 컨텐츠 안전에 대한 추가 정보 &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-8.1&quot;&gt;는 [RFC4287] 섹션 8.1&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f30f294721759bc8f3b4c8af76920be111f1ebd" translate="yes" xml:space="preserve">
          <source>Atom Protocol Document formats are specified in terms of the XML
   Information Set [&lt;a href=&quot;#ref-REC-xml-infoset&quot;&gt;REC-xml-infoset&lt;/a&gt;], serialized as XML 1.0 [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].

   The Infoset terms &quot;Element Information Item&quot; and &quot;Attribute
   Information Item&quot; are shortened to &quot;element&quot; and &quot;attribute&quot;
   respectively.  Therefore, when this specification uses the term
   &quot;element&quot;, it is referring to an Element Information Item, and when
   it uses the term &quot;attribute&quot;, it is referring to an Attribute
   Information Item.</source>
          <target state="translated">Atom 프로토콜 문서 형식은 XML 정보 세트 [ &lt;a href=&quot;#ref-REC-xml-infoset&quot;&gt;REC-xml-infoset&lt;/a&gt; ]로 지정되며 XML 1.0 [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ]으로 직렬화됩니다 . 정보 요소 용어 &quot;요소 정보 항목&quot;및 &quot;속성 정보 항목&quot;은 각각 &quot;요소&quot;및 &quot;속성&quot;으로 단축됩니다. 따라서, 본 명세서에서 &quot;요소&quot;라는 용어를 사용하는 경우에는 요소 정보 항목을 의미하고, &quot;속성&quot;이라는 용어를 사용하는 경우 속성 정보 항목을 의미한다.</target>
        </trans-unit>
        <trans-unit id="2e1b50db6b134e88169d0061fffd21c5907dcc49" translate="yes" xml:space="preserve">
          <source>Atom Protocol documents allow the use of IRIs [&lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt;] as well as
   URIs [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;] to identify Resources.  Before an IRI in a document is
   used by HTTP, the IRI is first converted to a URI according to the
   procedure defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3987#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of [RFC3987]&lt;/a&gt;.  In accordance with
   that specification, the conversion SHOULD be applied as late as
   possible.  Conversion does not imply Resource creation -- the IRI and
   the URI into which it is converted identify the same Resource.

   While the Atom Protocol specifies the formats of the representations
   that are exchanged and the actions that can be performed on the IRIs
   embedded in those representations, it does not constrain the form of
   the URIs that are used.  HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;] specifies that the URI space
   of each server is controlled by that server, and this protocol
   imposes no further constraints on that control.</source>
          <target state="translated">Atom 프로토콜 문서를 사용하면 IRI [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt; ]와 URI [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]를 사용하여 자원을 식별 할 수 있습니다. HTTP에서 문서의 IRI를 사용하기 전에 먼저 &lt;a href=&quot;https://tools.ietf.org/html/rfc3987#section-3.1&quot;&gt;IRF가 [RFC3987] 3.1 절에&lt;/a&gt; 정의 된 절차에 따라 URI로 변환됩니다 . 그 사양에 따라, 변환은 가능한 한 늦게 적용되어야한다. 변환은 자원 작성을 의미하지 않습니다. IRI와 변환 된 URI는 동일한 자원을 식별합니다. Atom 프로토콜은 교환되는 표시 형식과 해당 표시에 임베드 된 IRI에서 수행 할 수있는 조치를 지정하지만 사용되는 URI의 형식을 제한하지는 않습니다. HTTP [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]는 각 서버의 URI 공간이 해당 서버에 의해 제어되도록 지정하며이 프로토콜은 해당 제어에 대한 추가 제한 조건을 부과하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="736c134a608fda6f7298f3bba3cfd72a9fdecd9a" translate="yes" xml:space="preserve">
          <source>Atom Publishing Protocol implementations are susceptible to a variety
   of spoofing attacks.  Malicious clients might send Atom Entries
   containing inaccurate information anywhere in the document.</source>
          <target state="translated">Atom Publishing Protocol 구현은 다양한 스푸핑 공격에 취약합니다. 악의적 인 클라이언트는 문서의 어느 곳에서나 부정확 한 정보가 포함 된 Atom 항목을 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcde284149405876b277c263099cd3f0fe408f3d" translate="yes" xml:space="preserve">
          <source>Atom Publishing Protocol implementations handle URIs and IRIs.  See
   &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-7&quot;&gt;Section&amp;nbsp;7 of [RFC3986]&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc3987#section-8&quot;&gt;Section&amp;nbsp;8 of [RFC3987]&lt;/a&gt; for security
   considerations related to their handling and use. 

   The Atom Publishing Protocol leaves the server in control of minting
   URIs.  The use of any client-supplied data for creating new URIs is
   subject to the same concerns as described in the next section.</source>
          <target state="translated">Atom Publishing Protocol 구현은 URI 및 IRI를 처리합니다. 취급 및 사용과 관련된 보안 고려 사항에 대해서는 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-7&quot;&gt;[RFC3986]의 섹션 7&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc3987#section-8&quot;&gt;[RFC3987]의 섹션 8을&lt;/a&gt; 참조하십시오 . Atom Publishing Protocol은 서버를 Minting URI를 제어하도록합니다. 새 URI를 작성하기 위해 클라이언트가 제공 한 데이터를 사용하는 경우 다음 섹션에서 설명한 것과 동일한 우려가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="43c64fa2cad1ec9b5d7097b9637cf7e73d027deb" translate="yes" xml:space="preserve">
          <source>Atom Publishing Protocol server implementations are susceptible to
   replay attacks.  Specifically, this specification does not define a
   means of detecting duplicate requests.  Accidentally sent duplicate
   requests are indistinguishable from intentional and malicious replay
   attacks.</source>
          <target state="translated">Atom Publishing Protocol 서버 구현은 공격을 재생하기 쉽습니다. 특히이 사양에서는 중복 요청을 감지하는 방법을 정의하지 않습니다. 실수로 전송 된 중복 요청은 의도적 인 악의적 재생 공격과 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2972250359d4c37b4863cb1f87236835622705f3" translate="yes" xml:space="preserve">
          <source>Atom Publishing Protocol server implementations need to take adequate
   precautions to ensure malicious clients cannot consume excessive
   server resources (CPU, memory, disk, etc.).</source>
          <target state="translated">Atom Publishing Protocol 서버 구현은 악의적 인 클라이언트가 과도한 서버 리소스 (CPU, 메모리, 디스크 등)를 소비 할 수 없도록 적절한 예방 조치를 취해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c002bc6355801197a02bfae106d0ff5c2ac8619" translate="yes" xml:space="preserve">
          <source>Attribute Value:  edit

   Description:  An IRI of an editable Member Entry.  When appearing
      within an atom:entry, the href IRI can be used to retrieve,
      update, and delete the Resource represented by that Entry.

   Expected display characteristics:  Undefined; this relation can be
      used for background processing or to provide extended
      functionality without displaying its value.

   Security considerations:  Automated agents should take care when this
      relation crosses administrative domains (e.g., the URI has a
      different authority than the current document).</source>
          <target state="translated">속성 값 : 편집 설명 : 편집 가능한 멤버 항목의 IRI atom : entry 내에 나타날 때 href IRI를 사용하여 해당 항목이 나타내는 자원을 검색, 업데이트 및 삭제할 수 있습니다. 예상 디스플레이 특성 : 정의되지 않음; 이 관계는 백그라운드 처리 또는 값을 표시하지 않고 확장 된 기능을 제공하는 데 사용할 수 있습니다. 보안 고려 사항 : 자동화 에이전트는이 관계가 관리 도메인을 교차 할 때주의해야합니다 (예 : URI가 현재 문서와 다른 권한을 가짐).</target>
        </trans-unit>
        <trans-unit id="37137689e8aac586d2a2206e3451c0c78ed0404b" translate="yes" xml:space="preserve">
          <source>Attribute Value:  edit-media

   Description:  An IRI of an editable Media Resource.  When appearing
      within an atom:entry, the href IRI can be used to retrieve,
      update, and delete the Media Resource associated with that Entry.

   Expected display characteristics:  Undefined; this relation can be
      used for background processing or to provide extended
      functionality without displaying its value.

   Security considerations:  Automated agents should take care when this
      relation crosses administrative domains (e.g., the URI has a
      different authority than the current document).</source>
          <target state="translated">속성 값 : edit-media 설명 : 편집 가능한 미디어 리소스의 IRI. atom : entry 내에 나타날 때 href IRI를 사용하여 해당 항목과 연관된 매체 자원을 검색, 업데이트 및 삭제할 수 있습니다. 예상 디스플레이 특성 : 정의되지 않음; 이 관계는 백그라운드 처리 또는 값을 표시하지 않고 확장 된 기능을 제공하는 데 사용할 수 있습니다. 보안 고려 사항 : 자동화 에이전트는이 관계가 관리 도메인을 교차 할 때주의해야합니다 (예 : URI가 현재 문서와 다른 권한을 가짐).</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="f249c1f3c78b5d8dfebf667cc36b2ac178b2dfce" translate="yes" xml:space="preserve">
          <source>Audio and video types</source>
          <target state="translated">오디오 및 비디오 유형</target>
        </trans-unit>
        <trans-unit id="e6d4341caf182975ff694c881dad755bd726c7a8" translate="yes" xml:space="preserve">
          <source>Audio and video. Only resources with the correct MIME Type will be played in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; elements. Be sure to &lt;a href=&quot;https://developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements&quot;&gt;use the correct type for audio and video&lt;/a&gt;.</source>
          <target state="translated">오디오 및 비디오. 올바른 MIME 유형을 가진 리소스 만 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에서 재생됩니다 . &lt;a href=&quot;https://developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements&quot;&gt;오디오 및 비디오에 올바른 유형&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7e617aec809a52d5e6a3a74811a5f9fd204a3f1" translate="yes" xml:space="preserve">
          <source>Audio and video. Only resources with the correct MIME Type will be played in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; elements. Be sure to specify the correct &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats&quot;&gt;media type for audio and video&lt;/a&gt;.</source>
          <target state="translated">Audio and video. Only resources with the correct MIME Type will be played in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; elements. Be sure to specify the correct &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats&quot;&gt;media type for audio and video&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="76247395f996d3bf715facd1a789b21b73e56939" translate="yes" xml:space="preserve">
          <source>Audio or music data. Examples include &lt;code&gt;audio/mpeg&lt;/code&gt;, &lt;code&gt;audio/vorbis&lt;/code&gt;.</source>
          <target state="translated">Audio or music data. Examples include &lt;code&gt;audio/mpeg&lt;/code&gt; , &lt;code&gt;audio/vorbis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="147b0d392949573e61339af923f0d61f3d4158e3" translate="yes" xml:space="preserve">
          <source>Audio or video type</source>
          <target state="translated">오디오 또는 비디오 유형</target>
        </trans-unit>
        <trans-unit id="ee1acfa55eb1476c86c5c4a68f256a67b25289ab" translate="yes" xml:space="preserve">
          <source>Authentication</source>
          <target state="translated">Authentication</target>
        </trans-unit>
        <trans-unit id="fc6c8170f13d7b26f5b4b7880a4d642545c57a00" translate="yes" xml:space="preserve">
          <source>Authentication challenges indicate what mechanisms are available for
   the client to provide authentication credentials in future requests.

   +--------------------+--------------------------+
   | Header Field Name  | Defined in...            |
   +--------------------+--------------------------+
   | WWW-Authenticate   | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7235]&lt;/a&gt; |
   | Proxy-Authenticate | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.3&quot;&gt;Section&amp;nbsp;4.3 of [RFC7235]&lt;/a&gt; |
   +--------------------+--------------------------+</source>
          <target state="translated">인증 문제는 클라이언트가 향후 요청에서 인증 자격 증명을 제공 할 수있는 메커니즘을 나타냅니다. + -------------------- + -------------------------- + | 헤더 필드 이름 | 정의 ... | + -------------------- + -------------------------- + | WWW 인증 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.1&quot;&gt;[RFC7235] 섹션 4.1&lt;/a&gt; | | 프록시 인증 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.3&quot;&gt;[RFC7235] 섹션 4.3&lt;/a&gt; | + -------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="153bcddcdfb94a1c4fcc1b07386bec94f199b549" translate="yes" xml:space="preserve">
          <source>Authentication of cross-origin images</source>
          <target state="translated">교차 출처 이미지 인증</target>
        </trans-unit>
        <trans-unit id="76f2d621f56ba98464057328fa277805b179a4c3" translate="yes" xml:space="preserve">
          <source>Authentication schemes</source>
          <target state="translated">인증 체계</target>
        </trans-unit>
        <trans-unit id="82c6eeec306dfcdeb221624f2ddf32ce5652cd2a" translate="yes" xml:space="preserve">
          <source>Authentication schemes that solely rely on the &quot;realm&quot; mechanism for
   establishing a protection space will expose credentials to all
   resources on an origin server.  Clients that have successfully made
   authenticated requests with a resource can use the same
   authentication credentials for other resources on the same origin
   server.  This makes it possible for a different resource to harvest
   authentication credentials for other resources.

   This is of particular concern when an origin server hosts resources
   for multiple parties under the same canonical root URI (&lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt;).
   Possible mitigation strategies include restricting direct access to
   authentication credentials (i.e., not making the content of the
   Authorization request header field available), and separating
   protection spaces by using a different host name (or port number) for
   each party.</source>
          <target state="translated">보호 공간을 설정하기 위해 &quot;영역&quot;메커니즘에만 의존하는 인증 체계는 원본 서버의 모든 리소스에 자격 증명을 노출합니다. 리소스로 인증 된 요청을 한 클라이언트는 동일한 원본 서버의 다른 리소스에 대해 동일한 인증 자격 증명을 사용할 수 있습니다. 이를 통해 다른 리소스가 다른 리소스에 대한 인증 자격 증명을 수집 할 수 있습니다. 이는 오리진 서버가 동일한 표준 루트 URI ( &lt;a href=&quot;#section-2.2&quot;&gt;2.2 절)&lt;/a&gt; 에서 여러 당사자에 대한 자원을 호스팅 할 때 특히 중요합니다.). 가능한 완화 전략에는 인증 자격 증명에 대한 직접 액세스 제한 (즉, 인증 요청 헤더 필드의 내용을 사용할 수 없음) 및 각 당사자에 대해 다른 호스트 이름 (또는 포트 번호)을 사용하여 보호 공간 분리가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7e8fe0af4751860c096cd4a38e3b9eeae02683be" translate="yes" xml:space="preserve">
          <source>Authentification for AWS servers (&lt;code&gt;AWS4-HMAC-SHA256&lt;/code&gt;)</source>
          <target state="translated">AWS 서버 인증 ( &lt;code&gt;AWS4-HMAC-SHA256&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="97a9869cf89f831749f9533eebd33a7ff2d561cb" translate="yes" xml:space="preserve">
          <source>Authority</source>
          <target state="translated">Authority</target>
        </trans-unit>
        <trans-unit id="5e25ce007aa95ea2ea8b158aee9c630a32ea5616" translate="yes" xml:space="preserve">
          <source>Authorization</source>
          <target state="translated">Authorization</target>
        </trans-unit>
        <trans-unit id="3224c382af3d5fca4ce96ea1f1e751cb8cb2158f" translate="yes" xml:space="preserve">
          <source>Authorization (RFC 2616)</source>
          <target state="translated">승인 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="bae9490e931f2a313f9d9d7c5b0605ca243c7183" translate="yes" xml:space="preserve">
          <source>Authorization (RFC 7235)</source>
          <target state="translated">승인 (RFC 7235)</target>
        </trans-unit>
        <trans-unit id="d4fee4c08f75764f9229f565110251d77f383d11" translate="yes" xml:space="preserve">
          <source>Authorization and Proxy-Authorization headers</source>
          <target state="translated">Authorization and Proxy-Authorization headers</target>
        </trans-unit>
        <trans-unit id="95619b532fe893a1b62f3f25950021c4a689dd4d" translate="yes" xml:space="preserve">
          <source>Autoplay</source>
          <target state="translated">Autoplay</target>
        </trans-unit>
        <trans-unit id="68600483f20f1dc6f59f6bc5af1b4286e5f91bc8" translate="yes" xml:space="preserve">
          <source>Avoid overly-detailed &lt;code&gt;Server&lt;/code&gt; values, as they can reveal information that might make it (slightly) easier for attackers to exploit known security holes.</source>
          <target state="translated">Avoid overly-detailed &lt;code&gt;Server&lt;/code&gt; values, as they can reveal information that might make it (slightly) easier for attackers to exploit known security holes.</target>
        </trans-unit>
        <trans-unit id="7cdb07e7f031ea64baa50d4fba0ccadf646f5986" translate="yes" xml:space="preserve">
          <source>Avoiding COEP blockage with CORS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2caaa3b5ae832f6f7280b3a4c0e89023587c880" translate="yes" xml:space="preserve">
          <source>Avoiding mid-air collisions</source>
          <target state="translated">공중 충돌 방지</target>
        </trans-unit>
        <trans-unit id="cff193e7487bbc8578fa13e29841eaf30a9bedc1" translate="yes" xml:space="preserve">
          <source>Avoiding the lost update problem with optimistic locking</source>
          <target state="translated">낙관적 잠금으로 손실 된 업데이트 문제 방지</target>
        </trans-unit>
        <trans-unit id="8d576102d4917836a687b68a54b6ec02b0270e5d" translate="yes" xml:space="preserve">
          <source>Avoiding user agent detection</source>
          <target state="translated">사용자 에이전트 감지 방지</target>
        </trans-unit>
        <trans-unit id="76b2165174f526621c2ceebcd2a4d6f508b46aba" translate="yes" xml:space="preserve">
          <source>BCP 47</source>
          <target state="translated">BCP 47</target>
        </trans-unit>
        <trans-unit id="8306a543f91f1fd548cb382031a57ef6cd3bdffb" translate="yes" xml:space="preserve">
          <source>BMP</source>
          <target state="translated">BMP</target>
        </trans-unit>
        <trans-unit id="ecd4ecba402cd2d1689af61cc723efcbd052a8bf" translate="yes" xml:space="preserve">
          <source>BWS = OWS

   Connection = *( &quot;,&quot; OWS ) connection-option *( OWS &quot;,&quot; [ OWS
    connection-option ] )

   Content-Length = 1*DIGIT

   HTTP-message = start-line *( header-field CRLF ) CRLF [ message-body
    ]
   HTTP-name = %x48.54.54.50 ; HTTP
   HTTP-version = HTTP-name &quot;/&quot; DIGIT &quot;.&quot; DIGIT
   Host = uri-host [ &quot;:&quot; port ]

   OWS = *( SP / HTAB )

   RWS = 1*( SP / HTAB )

   TE = [ ( &quot;,&quot; / t-codings ) *( OWS &quot;,&quot; [ OWS t-codings ] ) ]
   Trailer = *( &quot;,&quot; OWS ) field-name *( OWS &quot;,&quot; [ OWS field-name ] )
   Transfer-Encoding = *( &quot;,&quot; OWS ) transfer-coding *( OWS &quot;,&quot; [ OWS
    transfer-coding ] )

   URI-reference = &amp;lt;URI-reference, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.1&quot;&gt;[RFC3986], Section&amp;nbsp;4.1&lt;/a&gt;&amp;gt;
   Upgrade = *( &quot;,&quot; OWS ) protocol *( OWS &quot;,&quot; [ OWS protocol ] )

   Via = *( &quot;,&quot; OWS ) ( received-protocol RWS received-by [ RWS comment
    ] ) *( OWS &quot;,&quot; [ OWS ( received-protocol RWS received-by [ RWS
    comment ] ) ] )

   absolute-URI = &amp;lt;absolute-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;[RFC3986], Section&amp;nbsp;4.3&lt;/a&gt;&amp;gt;
   absolute-form = absolute-URI
   absolute-path = 1*( &quot;/&quot; segment )
   asterisk-form = &quot;*&quot;
   authority = &amp;lt;authority, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;
   authority-form = authority 

   chunk = chunk-size [ chunk-ext ] CRLF chunk-data CRLF
   chunk-data = 1*OCTET
   chunk-ext = *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )
   chunk-ext-name = token
   chunk-ext-val = token / quoted-string
   chunk-size = 1*HEXDIG
   chunked-body = *chunk last-chunk trailer-part CRLF
   comment = &quot;(&quot; *( ctext / quoted-pair / comment ) &quot;)&quot;
   connection-option = token
   ctext = HTAB / SP / %x21-27 ; '!'-'''
    / %x2A-5B ; '*'-'['
    / %x5D-7E ; ']'-'~'
    / obs-text

   field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
   field-name = token
   field-value = *( field-content / obs-fold )
   field-vchar = VCHAR / obs-text
   fragment = &amp;lt;fragment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], Section&amp;nbsp;3.5&lt;/a&gt;&amp;gt;

   header-field = field-name &quot;:&quot; OWS field-value OWS
   http-URI = &quot;http://&quot; authority path-abempty [ &quot;?&quot; query ] [ &quot;#&quot;
    fragment ]
   https-URI = &quot;https://&quot; authority path-abempty [ &quot;?&quot; query ] [ &quot;#&quot;
    fragment ]

   last-chunk = 1*&quot;0&quot; [ chunk-ext ] CRLF

   message-body = *OCTET
   method = token

   obs-fold = CRLF 1*( SP / HTAB )
   obs-text = %x80-FF
   origin-form = absolute-path [ &quot;?&quot; query ]

   partial-URI = relative-part [ &quot;?&quot; query ]
   path-abempty = &amp;lt;path-abempty, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.3&lt;/a&gt;&amp;gt;
   port = &amp;lt;port, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
   protocol = protocol-name [ &quot;/&quot; protocol-version ]
   protocol-name = token
   protocol-version = token
   pseudonym = token

   qdtext = HTAB / SP / &quot;!&quot; / %x23-5B ; '#'-'['
    / %x5D-7E ; ']'-'~'
    / obs-text
   query = &amp;lt;query, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.4&quot;&gt;[RFC3986], Section&amp;nbsp;3.4&lt;/a&gt;&amp;gt;
   quoted-pair = &quot;\&quot; ( HTAB / SP / VCHAR / obs-text ) 

   quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE

   rank = ( &quot;0&quot; [ &quot;.&quot; *3DIGIT ] ) / ( &quot;1&quot; [ &quot;.&quot; *3&quot;0&quot; ] )
   reason-phrase = *( HTAB / SP / VCHAR / obs-text )
   received-by = ( uri-host [ &quot;:&quot; port ] ) / pseudonym
   received-protocol = [ protocol-name &quot;/&quot; ] protocol-version
   relative-part = &amp;lt;relative-part, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986], Section&amp;nbsp;4.2&lt;/a&gt;&amp;gt;
   request-line = method SP request-target SP HTTP-version CRLF
   request-target = origin-form / absolute-form / authority-form /
    asterisk-form

   scheme = &amp;lt;scheme, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.1&quot;&gt;[RFC3986], Section&amp;nbsp;3.1&lt;/a&gt;&amp;gt;
   segment = &amp;lt;segment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.3&lt;/a&gt;&amp;gt;
   start-line = request-line / status-line
   status-code = 3DIGIT
   status-line = HTTP-version SP status-code SP reason-phrase CRLF

   t-codings = &quot;trailers&quot; / ( transfer-coding [ t-ranking ] )
   t-ranking = OWS &quot;;&quot; OWS &quot;q=&quot; rank
   tchar = &quot;!&quot; / &quot;#&quot; / &quot;$&quot; / &quot;%&quot; / &quot;&amp;amp;&quot; / &quot;'&quot; / &quot;*&quot; / &quot;+&quot; / &quot;-&quot; / &quot;.&quot; /
    &quot;^&quot; / &quot;_&quot; / &quot;`&quot; / &quot;|&quot; / &quot;~&quot; / DIGIT / ALPHA
   token = 1*tchar
   trailer-part = *( header-field CRLF )
   transfer-coding = &quot;chunked&quot; / &quot;compress&quot; / &quot;deflate&quot; / &quot;gzip&quot; /
    transfer-extension
   transfer-extension = token *( OWS &quot;;&quot; OWS transfer-parameter )
   transfer-parameter = token BWS &quot;=&quot; BWS ( token / quoted-string )

   uri-host = &amp;lt;host, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.2&lt;/a&gt;&amp;gt; 

Index

   A
      absolute-form (of request-target)  42
      accelerator  10
      application/http Media Type  63
      asterisk-form (of request-target)  43
      authoritative response  67
      authority-form (of request-target)  42-43

   B
      browser  7

   C
      cache  11
      cacheable  12
      captive portal  11
      chunked (Coding Format)  28, 32, 36
      client  7
      close  51, 56
      compress (Coding Format)  38
      connection  7
      Connection header field  51, 56
      Content-Length header field  30

   D
      deflate (Coding Format)  38
      Delimiters  27
      downstream  10

   E
      effective request URI  45

   G
      gateway  10
      Grammar
         absolute-form  42
         absolute-path  16
         absolute-URI  16
         ALPHA  6
         asterisk-form  41, 43
         authority  16
         authority-form  42-43
         BWS  25
         chunk  36
         chunk-data  36
         chunk-ext  36
         chunk-ext-name  36 

         chunk-ext-val  36
         chunk-size  36
         chunked-body  36
         comment  27
         Connection  51
         connection-option  51
         Content-Length  30
         CR  6
         CRLF  6
         ctext  27
         CTL  6
         DIGIT  6
         DQUOTE  6
         field-content  23
         field-name  23, 40
         field-value  23
         field-vchar  23
         fragment  16
         header-field  23, 37
         HEXDIG  6
         Host  44
         HTAB  6
         HTTP-message  19
         HTTP-name  14
         http-URI  17
         HTTP-version  14
         https-URI  18
         last-chunk  36
         LF  6
         message-body  28
         method  21
         obs-fold  23
         obs-text  27
         OCTET  6
         origin-form  42
         OWS  25
         partial-URI  16
         port  16
         protocol-name  47
         protocol-version  47
         pseudonym  47
         qdtext  27
         query  16
         quoted-pair  27
         quoted-string  27
         rank  39
         reason-phrase  22
         received-by  47 

         received-protocol  47
         request-line  21
         request-target  41
         RWS  25
         scheme  16
         segment  16
         SP  6
         start-line  21
         status-code  22
         status-line  22
         t-codings  39
         t-ranking  39
         tchar  27
         TE  39
         token  27
         Trailer  40
         trailer-part  37
         transfer-coding  35
         Transfer-Encoding  28
         transfer-extension  35
         transfer-parameter  35
         Upgrade  57
         uri-host  16
         URI-reference  16
         VCHAR  6
         Via  47
      gzip (Coding Format)  39

   H
      header field  19
      header section  19
      headers  19
      Host header field  44
      http URI scheme  17
      https URI scheme  17
   I
      inbound  9
      interception proxy  11
      intermediary  9

   M
      Media Type
         application/http  63
         message/http  62
      message  7
      message/http Media Type  62
      method  21 

   N
      non-transforming proxy  49

   O
      origin server  7
      origin-form (of request-target)  42
      outbound  10

   P
      phishing  67
      proxy  10

   R
      recipient  7
      request  7
      request-target  21
      resource  16
      response  7
      reverse proxy  10

   S
      sender  7
      server  7
      spider  7

   T
      target resource  40
      target URI  40
      TE header field  39
      Trailer header field  40
      Transfer-Encoding header field  28
      transforming proxy  49
      transparent proxy  11
      tunnel  10

   U
      Upgrade header field  57
      upstream  9
      URI scheme
         http  17
         https  17
      user agent  7

   V
      Via header field  47 

Authors' Addresses

   Roy T. Fielding (editor)
   Adobe Systems Incorporated
   345 Park Ave
   San Jose, CA  95110
   USA

   EMail: fielding@gbiv.com
   URI:   &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt;


   Julian F. Reschke (editor)
   greenbytes GmbH
   Hafenweg 16
   Muenster, NW  48155
   Germany

   EMail: julian.reschke@greenbytes.de
   URI:   &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt;


Fielding &amp;amp; Reschke           Standards Track                   [Page 89]</source>
          <target state="translated">BWS = OWS 연결 = * ( &quot;,&quot;OWS) 연결 옵션 * (OWS &quot;,&quot;[OWS 연결 옵션]) 컨텐츠 길이 = 1 * DIGIT HTTP 메시지 = 시작 줄 * (헤더 필드 CRLF) CRLF [메시지 본문] HTTP- 이름 = % x48.54.54.50; HTTP HTTP-version = HTTP- 이름 &quot;/&quot;DIGIT &quot;.&quot; DIGIT 호스트 = uri-host [ &quot;:&quot;포트] OWS = * (SP / HTAB) RWS = 1 * (SP / HTAB) TE = [( &quot;,&quot;/ t-codings) * (OWS &quot;,&quot;[OWS t -codings])] Trailer = * ( &quot;,&quot;OWS) field-name * (OWS &quot;,&quot;[OWS field-name]) Transfer-Encoding = * ( &quot;,&quot;OWS) 전송 코딩 * (OWS &quot;,&quot; [OWS 전송 코딩]) URI-reference = &amp;lt;URI-reference, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.1&quot;&gt;[RFC3986], 섹션 4.1 참조&lt;/a&gt;&amp;gt; 업그레이드 = * ( &quot;,&quot;OWS) 프로토콜 * (OWS &quot;,&quot;[OWS 프로토콜]) Via = * ( &quot;,&quot;OWS) ([RWS 의견]에 의해 수신 된 프로토콜 RWS 수신 * * OWS &quot;,&quot; [OWS ([RWS 설명]에 의해 수신 된 수신 프로토콜 RWS]]]) absolute-URI = &amp;lt;absolute-URI &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;, 섹션 4.3&lt;/a&gt; 참조 [RFC3986], 섹션 4.3 &amp;gt; absolute-form = absolute-URI absolute-path = 1 * ( &quot;/ &quot;segment) 별표 형식 =&quot;* &quot;권한 = &amp;lt;기관, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2&quot;&gt;[RFC3986], 섹션 3.2 참조&lt;/a&gt;&amp;gt; authority-form = authority chunk = 청크 크기 [chunk-ext] CRLF chunk-data CRLF chunk-data = 1 * OCTET chunk-ext = * ( &quot;;&quot;chunk-ext-name [ &quot;=&quot;chunk-ext- val]) chunk-ext-name = token chunk-ext-val = token / quoted-string chunk-size = 1 * HEXDIG chunked-body = * chunk last-chunk trailer-part CRLF comment = &quot;(&quot;* (ctext / 인용 쌍 / 주석) &quot;)&quot;연결 옵션 = 토큰 ctext = HTAB / SP / % x21-27; '!'- '' '/ % x2A-5B; '*'- '['/ % x5D-7E; ']'- '~'/ obs-text field-content = field-vchar [1 * (SP / HTAB) field-vchar] field-name = 토큰 field-value = * (field-content / obs-fold) 필드 -vchar = VCHAR / obs-text fragment = &amp;lt;fragment, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], 섹션 3.5 참조&lt;/a&gt;&amp;gt; header-field = field-name &quot;:&quot;OWS 필드 값 OWS http-URI = &quot;http : //&quot;권한 경로 비우기 [ &quot;?&quot; 쿼리] [ &quot;#&quot;조각] https-URI = &quot;https : //&quot;권한 경로 비우기 [ &quot;?&quot; query] [ &quot;#&quot;fragment] last-chunk = 1 * &quot;0&quot;[chunk-ext] CRLF 메시지 본문 = * OCTET 메소드 = 토큰 obs-fold = CRLF 1 * (SP / HTAB) obs-text = % x80 -FF origin-form = 절대 경로 [ &quot;?&quot; query] partial-URI = 상대 부분 [ &quot;?&quot; 쿼리] path-abempty = &amp;lt;path-abempty &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;, 섹션 [RFC3986], 섹션 3.3&lt;/a&gt; &amp;gt; port = &amp;lt;port &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.3&quot;&gt;, 섹션 3.2.3 [RFC3986]&lt;/a&gt; 참조&amp;gt; 프로토콜 = 프로토콜 이름 [ &quot;/&quot;프로토콜 버전] 프로토콜 이름 = 토큰 프로토콜 버전 = 토큰 가명 = 토큰 qdtext = HTAB / SP / &quot;!&quot; / % x23-5B; '#'- '['/ % x5D-7E; ']'- '~'/ obs-text query = &amp;lt;query, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.4&quot;&gt;[RFC3986], 3.4 절&lt;/a&gt; 참조 &amp;gt; quoted-pair = &quot;\&quot;(HTAB / SP / VCHAR / obs-text) quoted-string = DQUOTE * (qdtext / quoted-pair) DQUOTE 순위 = ( &quot;0&quot;[ &quot;.&quot;* 3DIGIT]) / ( &quot;1&quot;[ &quot;.&quot;* 3 &quot;0&quot;]) 이유 문구 = * (HTAB / SP / VCHAR / obs- text) received-by = (uri-host [ &quot;:&quot;port]) / pseudonym received-protocol = [protocol-name &quot;/&quot;] protocol-version relative-part = &amp;lt;상대 부분 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;, 섹션 4.2 [RFC3986]&lt;/a&gt; 참조&amp;gt; request-line = 메소드 SP request-target SP HTTP 버전 CRLF request-target = origin-form / absolute-form / authority-form / asterisk-form scheme = &amp;lt;체계, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.1&quot;&gt;[RFC3986], 섹션 3.1&lt;/a&gt; &amp;gt; segment = &amp;lt; 세그먼트, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986], 섹션 3.3 참조&lt;/a&gt;&amp;gt; 시작 라인 = 요청 라인 / 상태 라인 상태 코드 = 3DIGIT 상태 라인 = HTTP 버전 SP 상태 코드 SP 이유 문구 CRLF t-codings = &quot;트레일러&quot;/ (전송 코딩 [t- 순위] ) t- 순위 = OWS &quot;;&quot; OWS &quot;q =&quot;랭크 tchar = &quot;!&quot; / &quot;#&quot;/ &quot;$&quot;/ &quot;%&quot;/ &quot;&amp;amp;&quot;/ &quot; '&quot;/ &quot;*&quot;/ &quot;+&quot;/ &quot;-&quot;/ &quot;.&quot; / &quot;^&quot;/ &quot;_&quot;/ &quot;`&quot;/ &quot;|&quot; / &quot;~&quot;/ DIGIT / ALPHA 토큰 = 1 * tchar 트레일러 부분 = * (헤더 필드 CRLF) 전송 코딩 = &quot;청크&quot;/ &quot;압축&quot;/ &quot;수축&quot;/ &quot;gzip&quot;/ 전송 확장 전송 확장 = 토큰 * (OWS &quot;;&quot;OWS 전송 매개 변수) 전송 매개 변수 = 토큰 BWS &quot;= &quot;BWS (token / quoted-string) uri-host = &amp;lt;host, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], 섹션 3.2.2 참조&lt;/a&gt;&amp;gt; 색인 A 절대 형식 (요청 대상) 42 가속기 10 응용 프로그램 / http 미디어 유형 63 별표 형식 (요청 대상) 43 권위있는 응답 67 권한 형식 (요청 대상) 42-43 B 브라우저 7 C 캐시 11 캐시 가능 12 캡 티브 포털 11 청크 (코딩 형식) 28, 32, 36 클라이언트 7 닫기 51, 56 압축 (코딩 형식) 38 연결 7 연결 헤더 필드 51, 56 콘텐츠 길이 헤더 필드 30 D 수축 (코딩 형식) 38 구분 기호 27 다운 스트림 10 E 유효 요청 URI 45 G 게이트웨이 10 문법 절대 형식 42 절대 경로 16 절대 URI 16 ALPHA 6 별표 형식 41,43 권한 16 권한 양식 42-43 BWS 25 청크 36 청크 데이터 36 청크 확장명 36 청크 확장명 36 청크 확장명 36 청크 크기 36 청크 본문 36 코멘트 27 연결 51 연결 옵션 51 내용 길이 30 CR 6 CRLF 6 ctext 27 CTL 6 DIGIT 6 DQUOTE 6 필드 내용 23 필드 이름 23, 40 필드 값 23 field-vchar 23 조각 16 헤더 필드 23,37 HEXDIG 6 호스트 44 HTAB 6 HTTP 메시지 19 HTTP 이름 14 http-URI 17 HTTP 버전 14 https-URI 18 마지막 청크 36 LF 6 메시지 본문 28 방법 21 obs-fold 23 obs-text 27 OCTET 6 origin 양식 42 OWS 25 부분 URI 16 포트 16 프로토콜 이름 47 프로토콜 버전 47 가명 47 qdtext 27 쿼리 16 인용 쌍 27 인용 문자열 27 순위 39 이유 문구 22 수신 한 47 수신 프로토콜 47 요청 라인 21 요청 대상 41 RWS 25 구성표 16 세그먼트 16 SP 6 시작 라인 21 상태 코드22 상태 표시 줄 22 t- 코딩 39 t- 순위 39 tchar 27 TE 39 토큰 27 트레일러 40 트레일러 부품 37 전송 코드 35 전송 인코딩 28 전송 확장 35 전송 매개 변수 35 업그레이드 57 URI 호스트 16 URI 참조 16 VCHAR 6 Via 47 gzip (코딩 형식) 39 H 헤더 필드 19 헤더 섹션 19 헤더 19 호스트 헤더 필드 44 http URI 스킴 17 https URI 스킴 17 I 인바운드 9 차단 프록시 11 중개자 9 M 미디어 유형 애플리케이션 / http 63 메시지 / http 62 메시지 7 메시지 / http 미디어 유형 62 방법 21 N 비 변환 프록시 49 O오리진 서버 7 오리진 양식 (요청 대상) 42 아웃 바운드 10 P 피싱 67 프록시 10 R 수신자 7 요청 7 요청 대상 21 리소스 16 응답 7 리버스 프록시 10 S 발신자 7 서버 7 스파이더 7 T 대상 리소스 40 대상 URI 40 TE 헤더 필드 39 트레일러 헤더 필드 40 전송 인코딩 헤더 필드 28 변환 프록시 49 투명 프록시 11 터널 10 U 업그레이드 헤더 필드 57 업스트림 9 URI 체계 http 17 https 17 사용자 에이전트 7 V 헤더 필드 47 작성자 주소 Roy T. Fielding (편집자) Adobe Systems Incorporated 345 Park Ave San Jose, CA 95110 USA 이메일 : fielding@gbiv.com URI : &lt;a href=&quot;http://roy.gbiv.com/&quot;&gt;http://roy.gbiv.com/&lt;/a&gt; Julian F. Reschke (편집자) greenbytes GmbH Hafenweg 16 Muenster, NW 48155 독일 이메일 : julian.reschke@greenbytes.de URI : &lt;a href=&quot;http://greenbytes.de/tech/webdav/&quot;&gt;http://greenbytes.de/tech/webdav/&lt;/a&gt; 필딩 &amp;amp; Reschke 표준 트랙 [페이지 89]</target>
        </trans-unit>
        <trans-unit id="5f38d91a98f445cfaf31a1b87315c344133fcf77" translate="yes" xml:space="preserve">
          <source>BZip archive</source>
          <target state="translated">BZip 아카이브</target>
        </trans-unit>
        <trans-unit id="9268ec259738e5664244ab3e240148d4cb02f539" translate="yes" xml:space="preserve">
          <source>BZip2 archive</source>
          <target state="translated">BZip2 아카이브</target>
        </trans-unit>
        <trans-unit id="b1ff57d696aa3ec09bd76c88944e1a7097ee37a3" translate="yes" xml:space="preserve">
          <source>Bad:</source>
          <target state="translated">Bad:</target>
        </trans-unit>
        <trans-unit id="6b6c8e8e9e899e58c8a82dcfe5a52c51d8589bc9" translate="yes" xml:space="preserve">
          <source>Base64 encoding and decoding</source>
          <target state="translated">Base64 인코딩 및 디코딩</target>
        </trans-unit>
        <trans-unit id="dd485ec404c88c9bc1169c18d4946d7741390c2a" translate="yes" xml:space="preserve">
          <source>Base64 encoding of a file or string on Linux and Mac OS X systems can be achieved using the command-line &lt;code&gt;base64&lt;/code&gt; (or, as an alternative, the &lt;code&gt;uuencode&lt;/code&gt; utility with &lt;code&gt;-m&lt;/code&gt; argument).</source>
          <target state="translated">Base64 encoding of a file or string on Linux and Mac OS X systems can be achieved using the command-line &lt;code&gt;base64&lt;/code&gt; (or, as an alternative, the &lt;code&gt;uuencode&lt;/code&gt; utility with &lt;code&gt;-m&lt;/code&gt; argument).</target>
        </trans-unit>
        <trans-unit id="c8a6c4738838e4b0a166434348297e34cf13d0aa" translate="yes" xml:space="preserve">
          <source>Base64 is a group of binary-to-text encoding schemes that represent binary data in an ASCII string format by translating it into a radix-64 representation. By consisting only in ASCII characters, base64 strings are generally url-safe, and that's why they can be used to encode data in Data URLs.</source>
          <target state="translated">Base64 is a group of binary-to-text encoding schemes that represent binary data in an ASCII string format by translating it into a radix-64 representation. By consisting only in ASCII characters, base64 strings are generally url-safe, and that's why they can be used to encode data in Data URLs.</target>
        </trans-unit>
        <trans-unit id="5f89697a7bc4483ffe13d2dcbf8d58f7b7c1be20" translate="yes" xml:space="preserve">
          <source>Basic aspects of HTTP</source>
          <target state="translated">HTTP의 기본 측면</target>
        </trans-unit>
        <trans-unit id="f1141fef0f5d80de5637d17a79c2912b21db48fe" translate="yes" xml:space="preserve">
          <source>Basic authentication scheme</source>
          <target state="translated">기본 인증 체계</target>
        </trans-unit>
        <trans-unit id="8a8d7195474f74b23cfe43ea9439aa2d6b6b0acb" translate="yes" xml:space="preserve">
          <source>Basic operation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e2b3aff207a2929af920ad2047a4854ec8d687" translate="yes" xml:space="preserve">
          <source>Basic support</source>
          <target state="translated">기본 지원</target>
        </trans-unit>
        <trans-unit id="81efe3a6d9678e29a4c810740a95dcc9bb4f25f2" translate="yes" xml:space="preserve">
          <source>Basics of HTTP</source>
          <target state="translated">HTTP의 기초</target>
        </trans-unit>
        <trans-unit id="e0cd046975ac459ab156bc7edc2ad7f0be4cd40d" translate="yes" xml:space="preserve">
          <source>Battery Status API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a186f451d47a315ace213770793074f6621919f" translate="yes" xml:space="preserve">
          <source>Battery Status API&lt;br/&gt;&lt;small&gt;The definition of 'Feature Policy integration' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="029209c4aa3fd234305ceec4958ac95bfc012cd5" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;Upgrade&lt;/code&gt; is a hop-by-hop header, it also needs to be listed in the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header field. This means that a typical request that includes Upgrade would look something like:</source>
          <target state="translated">Because &lt;code&gt;Upgrade&lt;/code&gt; is a hop-by-hop header, it also needs to be listed in the &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; header field. This means that a typical request that includes Upgrade would look something like:</target>
        </trans-unit>
        <trans-unit id="2390d6f45ac482880e651868f977b3b748a0f6b2" translate="yes" xml:space="preserve">
          <source>Because HTTP uses mostly textual, character-delimited fields, parsers
   are often vulnerable to attacks based on sending very long (or very
   slow) streams of data, particularly where an implementation is
   expecting a protocol element with no predefined length.

   To promote interoperability, specific recommendations are made for
   minimum size limits on request-line (&lt;a href=&quot;#section-3.1.1&quot;&gt;Section 3.1.1&lt;/a&gt;) and header fields
   (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;).  These are minimum recommendations, chosen to be
   supportable even by implementations with limited resources; it is
   expected that most implementations will choose substantially higher
   limits.

   A server can reject a message that has a request-target that is too
   long (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.12&quot;&gt;Section&amp;nbsp;6.5.12 of [RFC7231]&lt;/a&gt;) or a request payload that is too
   large (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.11&quot;&gt;Section&amp;nbsp;6.5.11 of [RFC7231]&lt;/a&gt;).  Additional status codes related
   to capacity limits have been defined by extensions to HTTP [&lt;a href=&quot;https://tools.ietf.org/html/rfc6585&quot;&gt;RFC6585&lt;/a&gt;].

   Recipients ought to carefully limit the extent to which they process
   other protocol elements, including (but not limited to) request
   methods, response status phrases, header field-names, numeric values,
   and body chunks.  Failure to limit such processing can result in
   buffer overflows, arithmetic overflows, or increased vulnerability to
   denial-of-service attacks.</source>
          <target state="translated">HTTP는 대부분 문자로 구분 된 텍스트로 구분 된 필드를 사용하기 때문에 파서는 종종 매우 긴 (또는 매우 느린) 데이터 스트림 전송을 기반으로하는 공격에 취약합니다. 특히 구현시 미리 정의 된 길이가없는 프로토콜 요소가 필요한 경우. 상호 운용성을 촉진하기 위해 요청 라인 ( &lt;a href=&quot;#section-3.1.1&quot;&gt;섹션 3.1.1&lt;/a&gt; ) 및 헤더 필드 ( &lt;a href=&quot;#section-3.2&quot;&gt;섹션 3.2&lt;/a&gt; ) 에서 최소 크기 제한에 대한 특정 권장 사항이 작성됩니다 . 이것들은 제한된 자원을 가진 구현에서도 지원할 수 있도록 선택된 최소 권장 사항입니다. 대부분의 구현은 실질적으로 더 높은 한계를 선택할 것으로 예상됩니다. 서버가 요청 대상이 너무 긴 메시지를 거부 할 수 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.12&quot;&gt;[RFC7231]의 6.5.12 절)&lt;/a&gt;) 또는 요청 페이로드가 너무 큽니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.11&quot;&gt;[RFC7231]의 섹션 6.5.11&lt;/a&gt; ). 용량 제한과 관련된 추가 상태 코드는 HTTP 확장으로 정의되었습니다 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6585&quot;&gt;RFC6585&lt;/a&gt; ]. 받는 사람은 요청 방법, 응답 상태 문구, 헤더 필드 이름, 숫자 값 및 본문 청크를 포함하여 다른 프로토콜 요소를 처리하는 범위를 신중하게 제한해야합니다. 이러한 처리를 제한하지 않으면 버퍼 오버플로, 산술 오버플로 또는 서비스 거부 공격에 대한 취약성이 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e347f7f4e0eb64be97283fb708464f948f15cd41" translate="yes" xml:space="preserve">
          <source>Because a client might be receiving responses via multiple paths, so
   that some responses flow through one set of caches and other
   responses flow through a different set of caches, a client might
   receive responses in an order different from that in which the origin
   server sent them. We would like the client to use the most recently
   generated response, even if older responses are still apparently
   fresh.

   Neither the entity tag nor the expiration value can impose an
   ordering on responses, since it is possible that a later response
   intentionally carries an earlier expiration time. The Date values are
   ordered to a granularity of one second.

   When a client tries to revalidate a cache entry, and the response it
   receives contains a Date header that appears to be older than the one
   for the existing entry, then the client SHOULD repeat the request
   unconditionally, and include

       Cache-Control: max-age=0

   to force any intermediate caches to validate their copies directly
   with the origin server, or

       Cache-Control: no-cache

   to force any intermediate caches to obtain a new copy from the origin
   server. 

   If the Date values are equal, then the client MAY use either response
   (or MAY, if it is being extremely prudent, request a new response).
   Servers MUST NOT depend on clients being able to choose
   deterministically between responses generated during the same second,
   if their expiration times overlap.</source>
          <target state="translated">클라이언트가 여러 경로를 통해 응답을 수신 할 수 있으므로 일부 응답은 한 세트의 캐시를 통과하고 다른 응답은 다른 캐시 세트를 통과하므로 클라이언트는 원래 서버가 보낸 순서와 다른 순서로 응답을 수신 할 수 있습니다. . 오래된 응답이 여전히 최신 인 경우에도 클라이언트는 가장 최근에 생성 된 응답을 사용하기를 원합니다. 나중에 응답이 의도적으로 더 빠른 만료 시간을 가질 수 있기 때문에 엔티티 태그 나 만료 값 모두 응답에 순서를 지정할 수 없습니다. 날짜 값은 1 초 단위로 정렬됩니다. 클라이언트가 캐시 항목의 유효성을 다시 검사하려고 시도하고 수신 한 응답에 기존 항목의 항목보다 오래된 것으로 보이는 날짜 헤더가 포함 된 경우,그런 다음 클라이언트는 요청을 무조건 반복해야하며 Cache-Control : max-age = 0을 포함하여 중간 캐시가 원본 서버와 직접 복사본의 유효성을 검사하도록하거나 Cache-Control : no-cache를 사용하여 중간 캐시를 강제로 가져와야합니다. 오리진 서버에서 새로운 사본. Date 값이 같으면 클라이언트는 두 가지 응답 중 하나를 사용할 수 있습니다 (또는 매우 신중한 경우 새 응답을 요청할 수 있음). 서버가 만료 시간이 겹치는 경우 동일한 초 동안 생성 된 응답 중에서 클라이언트가 결정적으로 선택할 수있는 것에 의존해서는 안됩니다.no-cache는 중간 캐시가 원본 서버에서 새 사본을 얻도록 강제합니다. Date 값이 같으면 클라이언트는 두 가지 응답 중 하나를 사용할 수 있습니다 (또는 매우 신중한 경우 새 응답을 요청할 수 있음). 서버는 만료 시간이 겹치는 경우 동일한 초 동안 생성 된 응답 중에서 클라이언트가 결정적으로 선택할 수 있어야해서는 안됩니다.no-cache는 중간 캐시가 오리진 서버로부터 새로운 사본을 얻도록 강제합니다. Date 값이 같으면 클라이언트는 두 가지 응답 중 하나를 사용할 수 있습니다 (또는 매우 신중한 경우 새 응답을 요청할 수 있음). 서버는 만료 시간이 겹치는 경우 동일한 초 동안 생성 된 응답 중에서 클라이언트가 결정적으로 선택할 수 있어야해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="86455b35c9696e2ada5790776540ffdd90e87107" translate="yes" xml:space="preserve">
          <source>Because expiration values are assigned optimistically, it is possible
   for two caches to contain fresh values for the same resource that are
   different.

   If a client performing a retrieval receives a non-first-hand response
   for a request that was already fresh in its own cache, and the Date
   header in its existing cache entry is newer than the Date on the new
   response, then the client MAY ignore the response. If so, it MAY
   retry the request with a &quot;Cache-Control: max-age=0&quot; directive (see
   &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;), to force a check with the origin server.

   If a cache has two fresh responses for the same representation with
   different validators, it MUST use the one with the more recent Date
   header. This situation might arise because the cache is pooling
   responses from other caches, or because a client has asked for a
   reload or a revalidation of an apparently fresh cache entry.</source>
          <target state="translated">만료 값이 낙관적으로 할당되므로 두 캐시에 동일한 동일한 리소스에 대한 새로운 값이 포함될 수 있습니다. 검색을 수행하는 클라이언트가 자체 캐시에서 이미 새로운 요청에 대해 직접 응답이 아닌 응답을 수신하고 기존 캐시 항목의 날짜 헤더가 새 응답의 날짜보다 최신 인 경우 클라이언트는 무시할 수 있습니다 (MAY) 응답. 그렇다면 &quot;Cache-Control : max-age = 0&quot;지시문으로 요청을 다시 시도 할 수 있습니다 ( &lt;a href=&quot;#section-14.9&quot;&gt;섹션 14.9&lt;/a&gt; 참조). ), 원본 서버를 강제로 확인합니다. 캐시에 다른 유효성 검사기를 가진 동일한 표현에 대해 두 개의 새로운 응답이 있으면 최신 Date 헤더가있는 응답을 사용해야합니다. 캐시가 다른 캐시의 응답을 풀링 중이거나 클라이언트가 명백히 새로운 캐시 항목의 재로드 또는 재확인을 요청했기 때문에 이러한 상황이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8925ede0629c5d28bf60e237373ba50709672d6" translate="yes" xml:space="preserve">
          <source>Because some of the information shared by &lt;code&gt;resource:&lt;/code&gt; URLs is available to websites, a web page could run internal scripts and inspect internal resources of Firefox, including the default preferences, which could be a serious security and privacy issue.</source>
          <target state="translated">&lt;code&gt;resource:&lt;/code&gt; 공유하는 일부 정보 : 웹 사이트에서 URL을 사용할 수 있으므로 웹 페이지는 내부 스크립트를 실행하고 기본 환경 설정을 포함하여 Firefox의 내부 리소스를 검사 할 수 있으며 이는 심각한 보안 및 개인 정보 보호 문제 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="546f4d232503e1d341d388da112b0bb01eea4130" translate="yes" xml:space="preserve">
          <source>Because the &lt;a href=&quot;headers/user-agent&quot;&gt;&lt;code&gt;User-Agent&lt;/code&gt;&lt;/a&gt; header value is different (&quot;varies&quot;) for mobile and desktop clients, caches will not be used to serve mobile content mistakenly to desktop users or vice versa.</source>
          <target state="translated">모바일 및 데스크톱 클라이언트 의 &lt;a href=&quot;headers/user-agent&quot;&gt; &lt;code&gt;User-Agent&lt;/code&gt; &lt;/a&gt; 헤더 값이 다르기 때문에 ( &quot;다양성&quot;), 캐시는 모바일 콘텐츠를 데스크톱 사용자에게 실수로 제공하거나 그 반대로 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b675dee5907b6c94664883b5699f8243f8d18b2d" translate="yes" xml:space="preserve">
          <source>Because the request headers in the above example include a &lt;code&gt;Cookie&lt;/code&gt; header, the request would fail if the value of the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header was &quot;*&quot;. But it does not fail: Because the value of the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header is &quot;&lt;code&gt;http://foo.example&lt;/code&gt;&quot; (an actual origin) rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard, the credential-cognizant content is returned to the invoking web content.</source>
          <target state="translated">Because the request headers in the above example include a &lt;code&gt;Cookie&lt;/code&gt; header, the request would fail if the value of the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header was &quot;*&quot;. But it does not fail: Because the value of the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header is &quot; &lt;code&gt;http://foo.example&lt;/code&gt; &quot; (an actual origin) rather than the &quot; &lt;code&gt;*&lt;/code&gt; &quot; wildcard, the credential-cognizant content is returned to the invoking web content.</target>
        </trans-unit>
        <trans-unit id="f8cadc83ac6b7350fa14508ccacb5caa822a4e4b" translate="yes" xml:space="preserve">
          <source>Because the request headers in the above example include a &lt;code&gt;Cookie&lt;/code&gt; header, the request would fail if the value of the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header were &quot;*&quot;. But it does not fail: Because the value of the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header is &quot;&lt;code&gt;http://foo.example&lt;/code&gt;&quot; (an actual origin) rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard, the credential-cognizant content is returned to the invoking web content.</source>
          <target state="translated">위 예의 요청 헤더에 &lt;code&gt;Cookie&lt;/code&gt; 헤더가 포함되어 있으므로 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더의 값이 &quot;*&quot;인 경우 요청이 실패합니다 . 그러나 실패하지는 않습니다. &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더의 값이 &quot; &lt;code&gt;*&lt;/code&gt; &quot;와일드 카드가 아닌 &quot; &lt;code&gt;http://foo.example&lt;/code&gt; &quot;(실제 원점) 이므로 자격 증명 인식 내용이 호출 웹 컨텐츠.</target>
        </trans-unit>
        <trans-unit id="9f1e2820de19096a78681bfbbd2529f24bd989c8" translate="yes" xml:space="preserve">
          <source>Because the source of a link might be private information or might
   reveal an otherwise private information source, it is strongly
   recommended that the user be able to select whether or not the
   Referer field is sent. For example, a browser client could have a
   toggle switch for browsing openly/anonymously, which would
   respectively enable/disable the sending of Referer and From
   information.

   Clients SHOULD NOT include a Referer header field in a (non-secure)
   HTTP request if the referring page was transferred with a secure
   protocol.

   Authors of services which use the HTTP protocol SHOULD NOT use GET
   based forms for the submission of sensitive data, because this will
   cause this data to be encoded in the Request-URI. Many existing
   servers, proxies, and user agents will log the request URI in some
   place where it might be visible to third parties. Servers can use
   POST-based form submission instead</source>
          <target state="translated">링크의 소스는 개인 정보이거나 다른 개인 정보 소스를 표시 할 수 있으므로 사용자는 Referer 필드의 전송 여부를 선택할 수있는 것이 좋습니다. 예를 들어, 브라우저 클라이언트에는 공개 / 익명으로 브라우징하기위한 토글 스위치가있어 Referer 및 From 정보의 전송을 각각 활성화 / 비활성화 할 수 있습니다. 참조 페이지가 보안 프로토콜로 전송 된 경우 클라이언트는 (비보안) HTTP 요청에 Referer 헤더 필드를 포함하지 않아야합니다. HTTP 프로토콜을 사용하는 서비스 작성자는 민감한 데이터를 제출하기 위해 GET 기반 양식을 사용해서는 안됩니다.이 데이터는 Request-URI로 인코딩되기 때문입니다. 많은 기존 서버, 프록시,사용자 에이전트는 요청 URI를 제 3자가 볼 수있는 위치에 기록합니다. 서버는 대신 POST 기반 양식 제출을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89777ff4d87ff412faf166b9388ba8bd9eb18838" translate="yes" xml:space="preserve">
          <source>Because unsafe request methods (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7231]&lt;/a&gt;) such as
   PUT, POST or DELETE have the potential for changing state on the
   origin server, intervening caches can use them to keep their contents
   up to date.

   A cache MUST invalidate the effective Request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of
   [RFC7230]&lt;/a&gt;) as well as the URI(s) in the Location and Content-Location
   response header fields (if present) when a non-error status code is
   received in response to an unsafe request method.

   However, a cache MUST NOT invalidate a URI from a Location or
   Content-Location response header field if the host part of that URI
   differs from the host part in the effective request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5
   of [RFC7230]&lt;/a&gt;).  This helps prevent denial-of-service attacks.

   A cache MUST invalidate the effective request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of
   [RFC7230]&lt;/a&gt;) when it receives a non-error response to a request with a
   method whose safety is unknown.

   Here, a &quot;non-error response&quot; is one with a 2xx (Successful) or 3xx
   (Redirection) status code.  &quot;Invalidate&quot; means that the cache will
   either remove all stored responses related to the effective request
   URI or will mark these as &quot;invalid&quot; and in need of a mandatory
   validation before they can be sent in response to a subsequent
   request.

   Note that this does not guarantee that all appropriate responses are
   invalidated.  For example, a state-changing request might invalidate
   responses in the caches it travels through, but relevant responses
   still might be stored in other caches that it has not.</source>
          <target state="translated">PUT, POST 또는 DELETE와 같은 안전하지 않은 요청 방법 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;[RFC7231]의 섹션 4.2.1&lt;/a&gt; )은 오리진 서버에서 상태를 변경할 가능성이 있기 때문에 중간 캐시는이 방법을 사용하여 해당 내용을 최신 상태로 유지할 수 있습니다. 캐시 는 오류가 아닌 상태 코드가 다음에 대한 응답으로 수신 될 때 유효 요청 URI ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]의 섹션 5.5&lt;/a&gt; )와 위치 및 컨텐츠 위치 응답 헤더 필드 (있는 경우)의 URI를 무효화해야 합니다. 안전하지 않은 요청 방법 그러나 캐시는 해당 URI의 호스트 부분이 유효 요청 URI의 호스트 부분과 다를 경우 Location 또는 Content-Location 응답 헤더 필드에서 URI를 무효화해서는 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;안됩니다 ([RFC7230]의 5.5 절&lt;/a&gt;). 이를 통해 서비스 거부 공격을 방지 할 수 있습니다. 캐시는 유효 요청 URI를 무효화해야한다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]의 5.5 절&lt;/a&gt;) 안전성이 알려지지 않은 방법으로 요청에 대한 오류가 아닌 응답을 수신 한 경우 여기서 &quot;비 오류 응답&quot;은 2xx (성공) 또는 3xx (리디렉션) 상태 코드가있는 것입니다. &quot;유효하지 않음&quot;은 캐시가 유효 요청 URI와 관련된 모든 저장된 응답을 제거하거나 이러한 요청을 &quot;유효하지 않은&quot;것으로 표시하고 후속 요청에 대한 응답으로 전송되기 전에 필수 유효성 검증이 필요함을 의미합니다. 이로 인해 모든 적절한 응답이 무효화되는 것은 아닙니다. 예를 들어, 상태 변경 요청은 이동하는 캐시에서 응답을 무효화 할 수 있지만 관련 응답은 여전히 ​​그렇지 않은 다른 캐시에 저장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7164b8ce21f524d63c0906c78c5305985077fd8f" translate="yes" xml:space="preserve">
          <source>Before Firefox 58, &lt;code&gt;frame-ancestors&lt;/code&gt; is ignored in &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;.</source>
          <target state="translated">Firefox 58 이전 에는 &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 에서 &lt;code&gt;frame-ancestors&lt;/code&gt; 이 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="ee3fc8de372dabedbc1b9fd227e55db192bded9b" translate="yes" xml:space="preserve">
          <source>Before Firefox 80, applying &lt;code&gt;fullscreen&lt;/code&gt; to an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; (i.e. via the &lt;code&gt;allow&lt;/code&gt; attribute) does not work unless the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute is also present.</source>
          <target state="translated">Before Firefox 80, applying &lt;code&gt;fullscreen&lt;/code&gt; to an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; (i.e. via the &lt;code&gt;allow&lt;/code&gt; attribute) does not work unless the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute is also present.</target>
        </trans-unit>
        <trans-unit id="e1aa5f2715f87eb515763d2edd53baeae3f8d201" translate="yes" xml:space="preserve">
          <source>Before Firefox for Android 58, &lt;code&gt;frame-ancestors&lt;/code&gt; is ignored in &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;.</source>
          <target state="translated">Android 58 용 Firefox 이전 에는 &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 에서 &lt;code&gt;frame-ancestors&lt;/code&gt; 이 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="9418490a330c1f1a821e30ad652b77665cb8b536" translate="yes" xml:space="preserve">
          <source>Before a client and server can exchange an HTTP request/response pair, they must establish a TCP connection, a process which requires several round-trips. The default behavior of HTTP/1.0 is to open a separate TCP connection for each HTTP request/response pair. This is less efficient than sharing a single TCP connection when multiple requests are sent in close succession.</source>
          <target state="translated">Before a client and server can exchange an HTTP request/response pair, they must establish a TCP connection, a process which requires several round-trips. The default behavior of HTTP/1.0 is to open a separate TCP connection for each HTTP request/response pair. This is less efficient than sharing a single TCP connection when multiple requests are sent in close succession.</target>
        </trans-unit>
        <trans-unit id="98afb5d15000b90ef6856f9873a69ca2c0709aba" translate="yes" xml:space="preserve">
          <source>Before later builds of Chrome 64, invalid Expect-CT reports would be sent. Newer versions do not send reports after 10 weeks from the build date. See &lt;a href=&quot;https://crbug.com/786563&quot;&gt;bug 786563&lt;/a&gt;.</source>
          <target state="translated">Before later builds of Chrome 64, invalid Expect-CT reports would be sent. Newer versions do not send reports after 10 weeks from the build date. See &lt;a href=&quot;https://crbug.com/786563&quot;&gt;bug 786563&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="62fc5c2bc1f37893a14f09a3227f0a7bbc9e9b1c" translate="yes" xml:space="preserve">
          <source>Beginning in version 41, Firefox for Android will contain the Android version as part of the &lt;var&gt;platform&lt;/var&gt; token. For increased interoperability, if the browser is running on a version below 4 it will report 4.4. Android versions 4 and above will report the version accurately. Note that the same Gecko&amp;mdash;with the same capabilities&amp;mdash;is shipped to all versions of Android.</source>
          <target state="translated">버전 41부터 Android 용 Firefox는 &lt;var&gt;platform&lt;/var&gt; 토큰의 일부로 Android 버전을 포함합니다 . 상호 운용성을 높이기 위해 브라우저가 4 이하 버전에서 실행되는 경우 4.4를보고합니다. Android 버전 4 이상은 버전을 정확하게보고합니다. 동일한 기능을 가진 동일한 Gecko는 모든 버전의 Android에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3dac22f5a23b1f3829fde1d94704586ae962f362" translate="yes" xml:space="preserve">
          <source>Below, the client creates a Member Entry using POST:

       POST /myblog/entries HTTP/1.1
       Host: example.org
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Type: application/atom+xml;type=entry
       Content-Length: nnn
       Slug: First Post

       &amp;lt;?xml version=&quot;1.0&quot; ?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;Atom-Powered Robots Run Amok&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2007-02-123T17:09:02Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Captain Lansing&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content&amp;gt;It's something moving... solid metal&amp;lt;/content&amp;gt;
       &amp;lt;/entry&amp;gt;

   The server signals a successful creation with a status code of 201,
   and returns an ETag header in the response.  Because, in this case,
   the server returned a Content-Location header and Location header
   with the same value, the returned Entry representation can be
   understood to be a complete representation of the newly created Entry
   (see &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;).

       HTTP/1.1 201 Created
       Date: Fri, 23 Feb 2007 21:17:11 GMT
       Content-Length: nnn
       Content-Type: application/atom+xml;type=entry
       Location: http://example.org/edit/first-post.atom
       Content-Location: http://example.org/edit/first-post.atom
       ETag: &quot;e180ee84f0671b1&quot;

       &amp;lt;?xml version=&quot;1.0&quot; ?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;Atom-Powered Robots Run Amok&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2007-02-123T17:09:02Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Captain Lansing&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content&amp;gt;It's something moving... solid metal&amp;lt;/content&amp;gt;
       &amp;lt;/entry&amp;gt;

   The client can, if it wishes, use the returned ETag value to later
   construct a &quot;Conditional GET&quot; as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  In this case,
   prior to editing, the client sends the ETag value for the Member
   using the If-None-Match header. 

       GET /edit/first-post.atom HTTP/1.1
       Host: example.org
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       If-None-Match: &quot;e180ee84f0671b1&quot;

   If the Entry has not been modified, the response will be a status
   code of 304 (&quot;Not Modified&quot;).  This allows the client to determine
   whether it still has the most recent representation of the Entry at
   the time of editing.

       HTTP/1.1 304 Not Modified
       Date: Sat, 24 Feb 2007 13:17:11 GMT

   After editing, the client can PUT the Entry and send the ETag entity
   value in an If-Match header, informing the server to accept the entry
   on the condition that the entity value sent still matches the
   server's.

       PUT /edit/first-post.atom HTTP/1.1
       Host: example.org
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Type: application/atom+xml;type=entry
       Content-Length: nnn
       If-Match: &quot;e180ee84f0671b1&quot;

       &amp;lt;?xml version=&quot;1.0&quot; ?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;Atom-Powered Robots Run Amok&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2007-02-24T16:34:06Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Captain Lansing&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content&amp;gt;Update: it's a hoax!&amp;lt;/content&amp;gt;
       &amp;lt;/entry&amp;gt;

   The server however has since received a more recent copy than the
   client's, and it responds with a status code of 412 (&quot;Precondition
   Failed&quot;).

       HTTP/1.1 412 Precondition Failed
       Date: Sat, 24 Feb 2007 16:34:11 GMT

   This informs the client that the server has a more recent version of
   the Entry and will not allow the sent entity to be stored.</source>
          <target state="translated">아래에서 클라이언트는 POST를 사용하여 멤버 항목을 작성합니다. POST : POST / myblog / entries HTTP / 1.1 호스트 : example.org 인증 : 기본 ZGFmZnk6c2VjZXJldA == 컨텐츠 유형 : application / atom + xml; type = entry 컨텐츠 길이 : nnn Slug : 첫 번째 게시물 &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; 원격 로봇이 Amok를 실행 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695-cfb8-4ebb-aaaa-80da344efa6a &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2007-02-123T17 : 09 : 02Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; 캡틴 랜싱 &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;content&amp;gt; 움직이는 것입니다 ... solid metal &amp;lt;/ content&amp;gt; &amp;lt;/ entry&amp;gt; 서버는 상태 코드가 201 인 성공적인 생성을 알립니다.응답에 ETag 헤더를 반환합니다. 이 경우, 서버는 동일한 값을 가진 Content-Location 헤더와 Location 헤더를 반환했기 때문에 반환 된 Entry 표현은 새로 작성된 Entry의 완전한 표현으로 이해 될 수 있습니다 (참조&lt;a href=&quot;#section-9.2&quot;&gt;섹션 9.2&lt;/a&gt; ). HTTP / 1.1 201 작성 날짜 : 2007 년 2 월 23 일 금요일 21:17:11 GMT 콘텐츠 길이 : nnn 콘텐츠 유형 : application / atom + xml; type = entry 위치 : http://example.org/edit/first- post.atom 컨텐츠 위치 : http://example.org/edit/first-post.atom ETag : &quot;e180ee84f0671b1&quot;&amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http : //www.w3. org / 2005 / Atom &quot;&amp;gt; &amp;lt;title&amp;gt; 원자력 로봇이 Amok를 실행합니다 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695-cfb8-4ebb-aaaa-80da344efa6a &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2007-02-123T17 : 09 : 02Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; 캡틴 랜싱 &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;content&amp;gt; 움직이는 무언가 ... 단단한 금속 &amp;lt;/ content&amp;gt; &amp;lt;/ entry&amp;gt;원하는 경우 클라이언트는 반환 된 ETag 값을 사용하여 나중에 [조건부 GET &quot;을 정의 할 수 있습니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]. 이 경우 클라이언트는 편집하기 전에 If-None-Match 헤더를 사용하여 멤버에 대한 ETag 값을 보냅니다. GET /edit/first-post.atom HTTP / 1.1 호스트 : example.org 권한 부여 : 기본 ZGFmZnk6c2VjZXJldA == 일치하지 않는 항목 : &quot;e180ee84f0671b1&quot;항목이 수정되지 않은 경우 응답은 상태 코드 304 ( &quot;수정되지 않음&quot;). 이를 통해 클라이언트는 편집 할 때 여전히 최신 항목을 가지고 있는지 확인할 수 있습니다. HTTP / 1.1 304 수정되지 않은 날짜 : 토요일, 2007 년 2 월 24 일 13:17:11 GMT 편집 후 클라이언트는 항목을 PUT하고 If-Match 헤더에 ETag 엔티티 값을 보내 서버가 서버의 항목을 수락하도록 지시합니다. 전송 된 엔티티 값이 여전히 서버의 값과 일치한다는 조건.PUT /edit/first-post.atom HTTP / 1.1 호스트 : example.org 인증 : 기본 ZGFmZnk6c2VjZXJldA == 콘텐츠 유형 : application / atom + xml; type = entry 콘텐츠 길이 : nnn If-Match : &quot;e180ee84f0671b1&quot;&amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; 원격 로봇이 Amok를 실행합니다 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695- cfb8-4ebb-aaaa-80da344efa6a &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2007-02-24T16 : 34 : 06Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; 캡틴 랜싱 &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;content&amp;gt; 업데이트 : hoax! &amp;lt;/ content&amp;gt; &amp;lt;/ entry&amp;gt; 그러나 서버는 이후 클라이언트보다 최신 사본을 받았습니다.상태 코드 412 ( &quot;전제 조건 실패&quot;)로 응답합니다. HTTP / 1.1 412 전제 조건 실패 날짜 : 2007 년 2 월 24 일 (토) 16:34:11 GMT 클라이언트에게 서버에 최신 버전의 항목이 있음을 알리고 보낸 엔터티를 저장할 수 없게합니다.</target>
        </trans-unit>
        <trans-unit id="c0330bfb1138bf9fb6ae44f78a5af3bf13c6fff6" translate="yes" xml:space="preserve">
          <source>Below, the client sends a POST request containing a PNG image to the
   URI of a Collection that accepts PNG images:

       POST /edit/ HTTP/1.1
       Host: media.example.org
       Content-Type: image/png
       Slug: The Beach
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Length: nnn

       ...binary data

   The server signals a successful creation with a status code of 201.
   The response includes a Location header indicating the Member URI of
   the Media Link Entry and a representation of that entry in the body
   of the response.  The Media Link Entry includes a content element
   with a &quot;src&quot; attribute.  It also contains a link with a link relation
   of &quot;edit-media&quot;, specifying the IRI to be used for modifying the
   Media Resource.

       HTTP/1.1 201 Created
       Date: Fri, 7 Oct 2005 17:17:11 GMT
       Content-Length: nnn
       Content-Type: application/atom+xml;type=entry;charset=&quot;utf-8&quot;
       Location: http://example.org/media/edit/the_beach.atom

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;The Beach&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2005-10-07T17:17:08Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;summary type=&quot;text&quot; /&amp;gt;
         &amp;lt;content type=&quot;image/png&quot;
            src=&quot;http://media.example.org/the_beach.png&quot;/&amp;gt;
         &amp;lt;link rel=&quot;edit-media&quot;
            href=&quot;http://media.example.org/edit/the_beach.png&quot; /&amp;gt;
         &amp;lt;link rel=&quot;edit&quot;
            href=&quot;http://example.org/media/edit/the_beach.atom&quot; /&amp;gt;
       &amp;lt;/entry&amp;gt; 

   Later, the client sends a PUT request containing the new PNG using
   the URI indicated in the Media Link Entry's &quot;edit-media&quot; link:

       PUT /edit/the_beach.png HTTP/1.1
       Host: media.example.org
       Content-Type: image/png
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Length: nnn

       ...binary data

   The server signals a successful edit with a status code of 200.

       HTTP/1.1 200 Ok
       Date: Fri, 8 Oct 2006 17:17:11 GMT

   The client can edit the metadata for the picture.  First GET the
   Media Link Entry:

       GET /media/edit/the_beach.atom HTTP/1.1
       Host: example.org
       Authorization: Basic ZGFmZnk6c2VjZXJldA==

   The Media Link Entry is returned.

       HTTP/1.1 200 Ok
       Date: Fri, 7 Oct 2005 17:18:11 GMT
       Content-Length: nnn
       Content-Type: application/atom+xml;type=entry;charset=&quot;utf-8&quot;
       ETag: &quot;c181bb840673b5&quot;

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;The Beach&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2005-10-07T17:17:08Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;summary type=&quot;text&quot; /&amp;gt;
         &amp;lt;content type=&quot;image/png&quot;
            src=&quot;http://media.example.org/the_beach.png&quot;/&amp;gt;
         &amp;lt;link rel=&quot;edit-media&quot;
            href=&quot;http://media.example.org/edit/the_beach.png&quot; /&amp;gt;
         &amp;lt;link rel=&quot;edit&quot;
            href=&quot;http://example.org/media/edit/the_beach.atom&quot; /&amp;gt;
       &amp;lt;/entry&amp;gt;

   The metadata can be updated, in this case to add a summary, and then
   PUT back to the server. 

       PUT /media/edit/the_beach.atom HTTP/1.1
       Host: example.org
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Type: application/atom+xml;type=entry
       Content-Length: nnn
       If-Match: &quot;c181bb840673b5&quot;

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;The Beach&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2005-10-07T17:17:08Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;summary type=&quot;text&quot;&amp;gt;
             A nice sunset picture over the water.
         &amp;lt;/summary&amp;gt;
         &amp;lt;content type=&quot;image/png&quot;
            src=&quot;http://media.example.org/the_beach.png&quot;/&amp;gt;
         &amp;lt;link rel=&quot;edit-media&quot;
            href=&quot;http://media.example.org/edit/the_beach.png&quot; /&amp;gt;
         &amp;lt;link rel=&quot;edit&quot;
            href=&quot;http://example.org/media/edit/the_beach.atom&quot; /&amp;gt;
       &amp;lt;/entry&amp;gt;

   The update was successful.

       HTTP/1.1 200 Ok
       Date: Fri, 7 Oct 2005 17:19:11 GMT
       Content-Length: 0

   Multiple Media Resources can be added to the Collection.

       POST /edit/ HTTP/1.1
       Host: media.example.org
       Content-Type: image/png
       Slug: The Pier
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Length: nnn

       ...binary data

   The Resource is created successfully.

       HTTP/1.1 201 Created
       Date: Fri, 7 Oct 2005 17:17:11 GMT
       Content-Length: nnn
       Content-Type: application/atom+xml;type=entry;charset=&quot;utf-8&quot;
       Location: http://example.org/media/edit/the_pier.atom 

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;The Pier&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efe6b&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2005-10-07T17:26:43Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;summary type=&quot;text&quot; /&amp;gt;
         &amp;lt;content type=&quot;image/png&quot;
            src=&quot;http://media.example.org/the_pier.png&quot;/&amp;gt;
         &amp;lt;link rel=&quot;edit-media&quot;
            href=&quot;http://media.example.org/edit/the_pier.png&quot; /&amp;gt;
         &amp;lt;link rel=&quot;edit&quot;
            href=&quot;http://example.org/media/edit/the_pier.atom&quot; /&amp;gt;
       &amp;lt;/entry&amp;gt;

   The client can now create a new Atom Entry in the blog Entry
   Collection that references the two newly created Media Resources.

       POST /blog/ HTTP/1.1
       Host: example.org
       Content-Type: application/atom+xml;type=entry
       Slug: A day at the beach
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Length: nnn

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;A fun day at the beach&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6b&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2005-10-07T17:40:02Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content type=&quot;xhtml&quot;&amp;gt;
             &amp;lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;
                 &amp;lt;xhtml:p&amp;gt;We had a good day at the beach.
                     &amp;lt;xhtml:img alt=&quot;the beach&quot;
                         src=&quot;http://media.example.org/the_beach.png&quot;/&amp;gt;
                 &amp;lt;/xhtml:p&amp;gt;
                 &amp;lt;xhtml:p&amp;gt;Later we walked down to the pier.
                     &amp;lt;xhtml:img  alt=&quot;the pier&quot;
                         src=&quot;http://media.example.org/the_pier.png&quot;/&amp;gt;
                 &amp;lt;/xhtml:p&amp;gt;
             &amp;lt;/xhtml:div&amp;gt;
         &amp;lt;/content&amp;gt;
       &amp;lt;/entry&amp;gt;

   The Resource is created successfully. 

       HTTP/1.1 200 Ok
       Date: Fri, 7 Oct 2005 17:20:11 GMT
       Content-Length: nnn
       Content-Type: application/atom+xml;type=entry;charset=&quot;utf-8&quot;
       Location: http://example.org/blog/atom/a-day-at-the-beach.atom

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;A fun day at the beach&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;http://example.org/blog/a-day-at-the-beach.xhtml&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2005-10-07T17:43:07Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;Daffy&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content type=&quot;xhtml&quot;&amp;gt;
             &amp;lt;xhtml:div xmlns:xhtml=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;
                 &amp;lt;xhtml:p&amp;gt;We had a good day at the beach.
                     &amp;lt;xhtml:img alt=&quot;the beach&quot;
                        src=&quot;http://media.example.org/the_beach.png&quot;/&amp;gt;
                 &amp;lt;/xhtml:p&amp;gt;
                 &amp;lt;xhtml:p&amp;gt;Later we walked down to the pier.
                     &amp;lt;xhtml:img alt=&quot;the pier&quot;
                        src=&quot;http://media.example.org/the_pier.png&quot;/&amp;gt;
                 &amp;lt;/xhtml:p&amp;gt;
             &amp;lt;/xhtml:div&amp;gt;
         &amp;lt;/content&amp;gt;
         &amp;lt;link rel=&quot;edit&quot;
           href=&quot;http://example.org/blog/edit/a-day-at-the-beach.atom&quot;/&amp;gt;
         &amp;lt;link rel=&quot;alternate&quot; type=&quot;text/html&quot;
           href=&quot;http://example.org/blog/a-day-at-the-beach.html&quot;/&amp;gt;
       &amp;lt;/entry&amp;gt;

   Note that the returned Entry contains a link with a relation of
   &quot;alternate&quot; that points to the associated HTML page that was created
   -- this is not required by this specification, but is included to
   show the kinds of changes a server can make to an Entry.</source>
          <target state="translated">아래에서 클라이언트는 PNG 이미지를 포함하는 POST 요청을 PNG 이미지를 허용하는 컬렉션의 URI로 보냅니다. POST / edit / HTTP / 1.1 호스트 : media.example.org 콘텐츠 유형 : image / png 슬러그 : 해변 인증 : 기본 ZGFmZnk6c2VjZXJldA == Content-Length : nnn ... binary data 서버는 상태 코드가 201 인 성공적인 작성을 신호합니다. 응답에는 Media Link Entry의 멤버 URI를 나타내는 Location 헤더와 해당 항목의 해당 항목의 표현이 포함됩니다. 응답의 본문. 미디어 링크 항목에는 &quot;src&quot;속성이있는 컨텐츠 요소가 포함됩니다. 또한 미디어 리소스를 수정하는 데 사용할 IRI를 지정하는 &quot;edit-media&quot;링크 관계가있는 링크가 포함되어 있습니다. HTTP / 1.1 201 작성 날짜 : 2005 년 10 월 7 일 금요일 17:17 :11 GMT Content-Length : nnn Content-Type : application / atom + xml; type = entry; charset = &quot;utf-8&quot;위치 : http://example.org/media/edit/the_beach.atom &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; 해변 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695-cfb8-4ebb-aaaa-80da344efa6a &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2005-10-07T17 : 17 : 08Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; Daffy &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;summary type = &quot;text&quot;/&amp;gt; &amp;lt;content type = &quot;image / png &quot;src =&quot;http://media.example.org/the_beach.png &quot;/&amp;gt; &amp;lt;link rel =&quot;edit-media &quot;href =&quot;http://media.example.org/edit/the_beach.png &quot; /&amp;gt; &amp;lt;link rel = &quot;edit&quot;href = &quot;http://example.org/media/edit/the_beach.atom&quot;/&amp;gt; &amp;lt;/ entry&amp;gt; 나중에 클라이언트는 미디어에 표시된 URI를 사용하여 새 PNG가 포함 된 PUT 요청을 보냅니다. 링크 엔트리의 &quot;미디어 편집&quot;링크 : PUT /edit/the_beach.png HTTP / 1.1 호스트 : media.example.org 콘텐츠 유형 : image / png 인증 : 기본 ZGFmZnk6c2VjZXJldA == 콘텐츠 길이 : nnn ... 바이너리 데이터 서버는 상태 코드 200으로 편집 성공을 알립니다. HTTP / 1.1 200 Ok 날짜 : 금, 2006 년 10 월 8 일 17:17:11 GMT 클라이언트는 그림의 메타 데이터를 편집 할 수 있습니다. 먼저 미디어 링크 항목을 가져옵니다. GET /media/edit/the_beach.atom HTTP / 1.1 호스트 : example.org 인증 :기본 ZGFmZnk6c2VjZXJldA == 미디어 링크 항목이 반환됩니다. HTTP / 1.1 200 Ok 날짜 : 2005 년 10 월 7 일 금요일 17:18:11 GMT 콘텐츠 길이 : nnn 콘텐츠 유형 : application / atom + xml; type = entry; charset = &quot;utf-8&quot;ETag : &quot;c181bb840673b5&quot;&amp;lt; ? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; 해변 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695-cfb8-4ebb -aaaa-80da344efa6a &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2005-10-07T17 : 17 : 08Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; Daffy &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;summary type = &quot;text&quot;/&amp;gt; &amp;lt;content type = &quot;image / png&quot;src = &quot;http://media.example.org/the_beach.png&quot;/&amp;gt; &amp;lt;link rel = &quot;edit-media&quot;href = &quot;http://media.example.org/edit/the_beach.png&quot;/&amp;gt; &amp;lt;link rel = &quot;edit&quot;href = &quot;http://example.org/media/edit/the_beach.atom&quot;/&amp;gt; &amp;lt; / entry&amp;gt; 메타 데이터를 업데이트하여이 경우 요약을 추가 한 다음 서버에 다시 PUT 할 수 있습니다. PUT /media/edit/the_beach.atom HTTP / 1.1 호스트 : example.org 인증 : 기본 ZGFmZnk6c2VjZXJldA == 컨텐츠 유형 : application / atom + xml; type = entry 컨텐츠 길이 : nnn If-Match : &quot;c181bb840673b5&quot;&amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; 해변 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695-cfb8-4ebb- aaaa-80da344efa6a &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2005-10-07T17 : 17 : 08Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; Daffy &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;summary type = &quot;text&quot;&amp;gt; 물 위의 멋진 일몰 사진. &amp;lt;/ summary&amp;gt; &amp;lt;content type = &quot;image / png&quot;src = &quot;http://media.example.org/the_beach.png&quot;/&amp;gt; &amp;lt;link rel = &quot;edit-media&quot;href = &quot;http : // media. example.org/edit/the_beach.png &quot;/&amp;gt; &amp;lt;link rel =&quot;edit &quot;href =&quot;http://example.org/media/edit/the_beach.atom &quot;/&amp;gt; &amp;lt;/ entry&amp;gt; 업데이트에 성공했습니다. HTTP / 1.1 200 Ok 날짜 : 2005 년 10 월 7 일 금요일 17:19:11 GMT 콘텐츠 길이 : 0 여러 미디어 리소스를 컬렉션에 추가 할 수 있습니다. POST / edit / HTTP / 1.1 호스트 : media.example.org 콘텐츠 유형 :슬러그 : 피어 인증 : 기본 ZGFmZnk6c2VjZXJldA == 콘텐츠 길이 : nnn ... 이진 데이터 리소스가 성공적으로 생성되었습니다. HTTP / 1.1 201 작성 날짜 : 2005 년 10 월 7 일 금요일 17:17:11 GMT 콘텐츠 길이 : nnn 콘텐츠 유형 : application / atom + xml; type = entry; charset = &quot;utf-8&quot;위치 : http : // example.org/media/edit/the_pier.atom &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; 부두 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695-cfb8-4ebb-aaaa-80da344efe6b &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2005-10-07T17 : 26 : 43Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; Daffy &amp;lt;/ name&amp;gt; &amp;lt;/ 저자 &amp;gt; &amp;lt;summary type = &quot;text&quot;/&amp;gt; &amp;lt;content type = &quot;image / png &quot;src =&quot;http://media.example.org/the_pier.png &quot;/&amp;gt; &amp;lt;link rel =&quot;edit-media &quot;href =&quot;http://media.example.org/edit/the_pier.png &quot;/&amp;gt; &amp;lt;link rel =&quot;edit &quot;href =&quot;http://example.org/media/edit/the_pier.atom &quot;/&amp;gt; &amp;lt;/ entry&amp;gt; 이제 클라이언트는 블로그 항목 콜렉션에서 새 Atom 항목을 작성할 수 있습니다. POST / blog / HTTP / 1.1 호스트 : example.org 콘텐츠 유형 : application / atom + xml; type = entry 슬러그 : 해변에서의 하루 승인 : 기본 ZGFmZnk6c2VjZXJldA == 콘텐츠 길이 : nnn &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; 해변에서의 즐거운 하루 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695-cfb8-4ebb-aaaa-80da344efa6b &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2005-10-07T17 : 40 : 02Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; Daffy &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;content type = &quot;xhtml&quot;&amp;gt; &amp;lt;xhtml : div xmlns : xhtml = &quot;http://www.w3.org/1999/xhtml&quot;&amp;gt; &amp;lt;xhtml : p&amp;gt; 해변에서 즐거운 하루를 보냈습니다. &amp;lt;xhtml : img alt = &quot;해변&quot;src = &quot;http://media.example.org/the_beach.png&quot;/&amp;gt; &amp;lt;/ xhtml : p&amp;gt; &amp;lt;xhtml : p&amp;gt; 나중에 부두까지 걸어갔습니다. &amp;lt;xhtml : img alt = &quot;부두&quot;src = &quot;http://media.example.org/the_pier.png&quot;/&amp;gt; &amp;lt;/ xhtml : p&amp;gt; &amp;lt;/ xhtml : div&amp;gt; &amp;lt;/ content&amp;gt; &amp;lt;/ entry&amp;gt; 리소스가 성공적으로 생성되었습니다. HTTP / 1.1 200 Ok 날짜 : 2005 년 10 월 7 일 금요일 17:20:11 GMT 콘텐츠 길이 : nnn 콘텐츠 유형 : application / atom + xml; type = entry; charset = &quot;utf-8&quot;위치 : http : // example.org/blog/atom/a-day-at-the-beach.atom &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt; title&amp;gt; 해변에서의 즐거운 하루 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; http://example.org/blog/a-day-at-the-beach.xhtml &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2005-10-07T17 : 43 : 07Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt;name&amp;gt; Daffy &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;content type = &quot;xhtml&quot;&amp;gt; &amp;lt;xhtml : div xmlns : xhtml = &quot;http://www.w3.org/1999/ xhtml &quot;&amp;gt;&amp;lt;xhtml : p&amp;gt; 해변에서 즐거운 하루를 보냈습니다. &amp;lt;xhtml : img alt = &quot;해변&quot;src = &quot;http://media.example.org/the_beach.png&quot;/&amp;gt; &amp;lt;/ xhtml : p&amp;gt; &amp;lt;xhtml : p&amp;gt; 나중에 부두까지 걸어갔습니다. &amp;lt;xhtml : img alt = &quot;부두&quot;src = &quot;http://media.example.org/the_pier.png&quot;/&amp;gt; &amp;lt;/ xhtml : p&amp;gt; &amp;lt;/ xhtml : div&amp;gt; &amp;lt;/ content&amp;gt; &amp;lt;link rel = &quot; edit &quot;href =&quot;http://example.org/blog/edit/a-day-at-the-beach.atom &quot;/&amp;gt; &amp;lt;link rel =&quot;alternate &quot;type =&quot;text / html &quot;href =&quot;http : //example.org/blog/a-day-at-the-beach.html &quot;/&amp;gt; &amp;lt;/ entry&amp;gt;반환 된 Entry에는 생성 된 관련 HTML 페이지를 가리키는 &quot;alternate&quot;관계가 포함 된 링크가 포함되어 있습니다.이 사양에서는 필요하지 않지만 서버가 수행 할 수있는 변경 종류를 보여주기 위해 포함됩니다. 기입.</target>
        </trans-unit>
        <trans-unit id="be9cb09a54952403acfaab07ff33017f6f0fca24" translate="yes" xml:space="preserve">
          <source>Below, the client sends a POST request containing an Atom Entry
   representation using the URI of the Collection:

       POST /edit/ HTTP/1.1
       Host: example.org
       User-Agent: Thingio/1.0
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Type: application/atom+xml;type=entry
       Content-Length: nnn
       Slug: First Post

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;Atom-Powered Robots Run Amok&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2003-12-13T18:30:02Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;John Doe&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content&amp;gt;Some text.&amp;lt;/content&amp;gt;
       &amp;lt;/entry&amp;gt;

   The server signals a successful creation with a status code of 201.
   The response includes a Location header indicating the Member Entry
   URI of the Atom Entry, and a representation of that Entry in the body
   of the response.

       HTTP/1.1 201 Created
       Date: Fri, 7 Oct 2005 17:17:11 GMT
       Content-Length: nnn
       Content-Type: application/atom+xml;type=entry;charset=&quot;utf-8&quot;
       Location: http://example.org/edit/first-post.atom
       ETag: &quot;c180de84f991g8&quot; 

       &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
       &amp;lt;entry xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
         &amp;lt;title&amp;gt;Atom-Powered Robots Run Amok&amp;lt;/title&amp;gt;
         &amp;lt;id&amp;gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&amp;lt;/id&amp;gt;
         &amp;lt;updated&amp;gt;2003-12-13T18:30:02Z&amp;lt;/updated&amp;gt;
         &amp;lt;author&amp;gt;&amp;lt;name&amp;gt;John Doe&amp;lt;/name&amp;gt;&amp;lt;/author&amp;gt;
         &amp;lt;content&amp;gt;Some text.&amp;lt;/content&amp;gt;
         &amp;lt;link rel=&quot;edit&quot;
             href=&quot;http://example.org/edit/first-post.atom&quot;/&amp;gt;
       &amp;lt;/entry&amp;gt;

   The Entry created and returned by the Collection might not match the
   Entry POSTed by the client.  A server MAY change the values of
   various elements in the Entry, such as the atom:id, atom:updated, and
   atom:author values, and MAY choose to remove or add other elements
   and attributes, or change element content and attribute values.</source>
          <target state="translated">아래에서 클라이언트는 콜렉션의 URI를 사용하여 Atom Entry 표현을 포함하는 POST 요청을 보냅니다. POST / edit / HTTP / 1.1 Host : example.org User-Agent : Thingio / 1.0 Authorization : Basic ZGFmZnk6c2VjZXJldA == Content-Type : application / atom + xml; type = entry 콘텐츠 길이 : nnn 슬러그 : 첫 번째 게시물 &amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; 원자력 로봇이 Amok를 실행 함 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695-cfb8-4ebb-aaaa-80da344efa6a &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2003-12-13T18 : 30 : 02Z &amp;lt;/ updated&amp;gt; &amp;lt;author&amp;gt; &amp;lt; name&amp;gt; John Doe &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;content&amp;gt; 일부 텍스트 &amp;lt;/ content&amp;gt; &amp;lt;/ entry&amp;gt;서버는 상태 코드 201로 성공적인 작성을 알립니다. 응답에는 Atom 항목의 구성원 항목 URI를 나타내는 Location 헤더와 응답 본문에 해당 항목의 표현이 포함됩니다. HTTP / 1.1 201 작성 날짜 : 2005 년 10 월 7 일 금요일 17:17:11 GMT 콘텐츠 길이 : nnn 콘텐츠 유형 : application / atom + xml; type = entry; charset = &quot;utf-8&quot;위치 : http : // example.org/edit/first-post.atom ETag : &quot;c180de84f991g8&quot;&amp;lt;? xml version = &quot;1.0&quot;?&amp;gt; &amp;lt;entry xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;title&amp;gt; Atom -Powered Robots Amok 실행 &amp;lt;/ title&amp;gt; &amp;lt;id&amp;gt; urn : uuid : 1225c695-cfb8-4ebb-aaaa-80da344efa6a &amp;lt;/ id&amp;gt; &amp;lt;updated&amp;gt; 2003-12-13T18 : 30 : 02Z &amp;lt;/ updated&amp;gt; &amp;lt;저자&amp;gt; &amp;lt;name&amp;gt; John Doe &amp;lt;/ name&amp;gt; &amp;lt;/ author&amp;gt; &amp;lt;content&amp;gt; 일부 텍스트 &amp;lt;/ content&amp;gt; &amp;lt;link rel = &quot;edit&quot;href = &quot;http://example.org/edit/first-post.atom&quot;/&amp;gt; &amp;lt;/ entry&amp;gt; 컬렉션에서 생성하고 반환 한 항목이 클라이언트가 게시 한 항목과 일치하지 않을 수 있습니다. 서버는 atom : id, atom : updated 및 atom : author 값과 같이 Entry의 다양한 요소 값을 변경하고 다른 요소 및 속성을 제거 또는 추가하거나 요소 내용 및 속성 값을 변경하도록 선택할 수 있습니다.콜렉션에서 작성하여 리턴 한 항목이 클라이언트가 POST 한 항목과 일치하지 않을 수 있습니다. 서버는 atom : id, atom : updated 및 atom : author 값과 같이 Entry의 다양한 요소 값을 변경하고 다른 요소 및 속성을 제거 또는 추가하거나 요소 내용 및 속성 값을 변경하도록 선택할 수 있습니다.콜렉션에서 작성하여 리턴 한 항목이 클라이언트가 POST 한 항목과 일치하지 않을 수 있습니다. 서버는 atom : id, atom : updated 및 atom : author 값과 같이 Entry의 다양한 요소 값을 변경하고 다른 요소 및 속성을 제거 또는 추가하거나 요소 내용 및 속성 값을 변경하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="552d2669fbc3963dfa12ac837a60570b8d21b825" translate="yes" xml:space="preserve">
          <source>Besides the setting of the validators on the server side, this mechanism is transparent: all browsers manage a cache and send such conditional requests without any special work to be done by Web developers.</source>
          <target state="translated">서버 측에서 유효성 검사기를 설정하는 것 외에도이 메커니즘은 투명합니다. 모든 브라우저는 캐시를 관리하고 웹 개발자가 수행 할 특별한 작업없이 이러한 조건부 요청을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="95a31c7b8d5f0b04cb1a96329834684da05258b3" translate="yes" xml:space="preserve">
          <source>Best Practices for Using the Vary Header &amp;ndash; fastly.com</source>
          <target state="translated">가변 헤더 사용에 대한 모범 사례 &amp;ndash; fastly.com</target>
        </trans-unit>
        <trans-unit id="3696a45b0fbbf421a242df5da5ec4b688f7df3d0" translate="yes" xml:space="preserve">
          <source>Best practices for good user experiences</source>
          <target state="translated">좋은 사용자 경험을위한 모범 사례</target>
        </trans-unit>
        <trans-unit id="e8192d28d193fb637729d7681a715b53c8d8e6fa" translate="yes" xml:space="preserve">
          <source>Between the Web browser and the server, numerous computers and machines relay the HTTP messages. Due to the layered structure of the Web stack, most of these operate at either the transport, network or physical levels, becoming transparent at the HTTP layer and potentially making a significant impact on performance. Those operating at the application layers are generally called &lt;strong&gt;proxies&lt;/strong&gt;. These can be transparent, or not (changing requests going through them), and may perform numerous functions:</source>
          <target state="translated">웹 브라우저와 서버 사이에서 수많은 컴퓨터와 시스템이 HTTP 메시지를 릴레이합니다. 웹 스택의 계층 구조로 인해 대부분은 전송, 네트워크 또는 물리적 수준에서 작동하여 HTTP 계층에서 투명 해지고 성능에 상당한 영향을 미칩니다. 응용 계층에서 작동하는 것을 일반적으로 &lt;strong&gt;프록시&lt;/strong&gt; 라고 합니다. 이들은 투명하거나 투명하지 않을 수 있으며 (요청을 변경하는 요청) 많은 기능을 수행 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0a8c80fd5bfdf982f1a24e39074b4f6a15dfc943" translate="yes" xml:space="preserve">
          <source>Between the Web browser and the server, numerous computers and machines relay the HTTP messages. Due to the layered structure of the Web stack, most of these operate at the transport, network or physical levels, becoming transparent at the HTTP layer and potentially making a significant impact on performance. Those operating at the application layers are generally called &lt;strong&gt;proxies&lt;/strong&gt;. These can be transparent, forwarding on the requests they receive without altering them in any way, or non-transparent, in which case they will change the request in some way before passing it along to the server. Proxies may perform numerous functions:</source>
          <target state="translated">Between the Web browser and the server, numerous computers and machines relay the HTTP messages. Due to the layered structure of the Web stack, most of these operate at the transport, network or physical levels, becoming transparent at the HTTP layer and potentially making a significant impact on performance. Those operating at the application layers are generally called &lt;strong&gt;proxies&lt;/strong&gt;. These can be transparent, forwarding on the requests they receive without altering them in any way, or non-transparent, in which case they will change the request in some way before passing it along to the server. Proxies may perform numerous functions:</target>
        </trans-unit>
        <trans-unit id="d43d1533f1d10a317b9afc62ab5e7c5e6d08f4b9" translate="yes" xml:space="preserve">
          <source>Bitmap file</source>
          <target state="translated">비트 맵 파일</target>
        </trans-unit>
        <trans-unit id="2e7b5639c2d5c6aefb6a4756b1924c7615e2b7af" translate="yes" xml:space="preserve">
          <source>Blink</source>
          <target state="translated">Blink</target>
        </trans-unit>
        <trans-unit id="d47c2c9d44766d5026529dab6ab5f38489055deb" translate="yes" xml:space="preserve">
          <source>Blink-based (Chromium, Google Chrome, Opera 15+)</source>
          <target state="translated">깜박임 기반 (Chromium, Google Chrome, Opera 15+)</target>
        </trans-unit>
        <trans-unit id="46790d0844afe283d3a8ad292d2479e6b7f8de27" translate="yes" xml:space="preserve">
          <source>Blink-based (Chromium, Google Chrome, Opera 15+, Edge on Android)</source>
          <target state="translated">Blink-based (Chromium, Google Chrome, Opera 15+, Edge on Android)</target>
        </trans-unit>
        <trans-unit id="12dcd04f8772116c748e7a1686d74433478cbbb7" translate="yes" xml:space="preserve">
          <source>Block pages from loading when they detect reflected XSS attacks:</source>
          <target state="translated">반영된 XSS 공격을 탐지 할 때 페이지가로드되지 않도록 차단 :</target>
        </trans-unit>
        <trans-unit id="72005736b3d633e161ec04f9f5626d8efc05d101" translate="yes" xml:space="preserve">
          <source>Block the use of outdated APIs like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest&quot;&gt;synchronous XHR&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/write&quot;&gt;&lt;code&gt;document.write()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest&quot;&gt;동기 XHR&lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/write&quot;&gt; &lt;code&gt;document.write()&lt;/code&gt; &lt;/a&gt; 와 같은 오래된 API의 사용을 차단하십시오 .</target>
        </trans-unit>
        <trans-unit id="1284de1552841a2d74b9dd9edf7b2b69b49a7a36" translate="yes" xml:space="preserve">
          <source>Blocks a request if the request destination is of type:</source>
          <target state="translated">Blocks a request if the request destination is of type:</target>
        </trans-unit>
        <trans-unit id="3ae08957fc64f7c37c7fd78d3088b53f4a0ac969" translate="yes" xml:space="preserve">
          <source>Blocks a request if the requested type is</source>
          <target state="translated">요청 된 유형이 다음과 같은 경우 요청을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="46c32d078786c9c754da18021b9cdd7c2ac0a06f" translate="yes" xml:space="preserve">
          <source>Blog post: &lt;a href=&quot;http://blog.sidstamm.com/2010/08/http-strict-transport-security-has.html&quot;&gt;HTTP Strict Transport Security has landed!&lt;/a&gt;</source>
          <target state="translated">블로그 게시물 : &lt;a href=&quot;http://blog.sidstamm.com/2010/08/http-strict-transport-security-has.html&quot;&gt;HTTP Strict Transport Security가 출시되었습니다!&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f7b0d6ecddd36325803a206713ad475fcf71d8b" translate="yes" xml:space="preserve">
          <source>Blog post: &lt;a href=&quot;http://hacks.mozilla.org/2010/08/firefox-4-http-strict-transport-security-force-https/&quot;&gt;HTTP Strict Transport Security (force HTTPS)&lt;/a&gt;</source>
          <target state="translated">블로그 게시물 : &lt;a href=&quot;http://hacks.mozilla.org/2010/08/firefox-4-http-strict-transport-security-force-https/&quot;&gt;HTTP Strict Transport Security (HTTPS 강제 적용)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b8bbcb0cbe3103f54b01e581bd5b4dcf154fe100" translate="yes" xml:space="preserve">
          <source>Blog post: &lt;a href=&quot;https://blog.sidstamm.com/2010/08/http-strict-transport-security-has.html&quot;&gt;HTTP Strict Transport Security has landed!&lt;/a&gt;</source>
          <target state="translated">Blog post: &lt;a href=&quot;https://blog.sidstamm.com/2010/08/http-strict-transport-security-has.html&quot;&gt;HTTP Strict Transport Security has landed!&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="37f2aceceb8d0bab8adfd81677e137c925113f15" translate="yes" xml:space="preserve">
          <source>Blog post: &lt;a href=&quot;https://hacks.mozilla.org/2010/08/firefox-4-http-strict-transport-security-force-https/&quot;&gt;HTTP Strict Transport Security (force HTTPS)&lt;/a&gt;</source>
          <target state="translated">Blog post: &lt;a href=&quot;https://hacks.mozilla.org/2010/08/firefox-4-http-strict-transport-security-force-https/&quot;&gt;HTTP Strict Transport Security (force HTTPS)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8874edbfb3bde7b175aaba19f751935d9beacccf" translate="yes" xml:space="preserve">
          <source>Bodies can be broadly divided into three categories:</source>
          <target state="translated">시체는 크게 세 가지 범주로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2274273379451e1b300d8da8d1d55a10464ef909" translate="yes" xml:space="preserve">
          <source>Bodies can be broadly divided into two categories:</source>
          <target state="translated">시체는 크게 두 가지 범주로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="718a7e8a582e982e452dd5700addba4ffc1cf40d" translate="yes" xml:space="preserve">
          <source>Body</source>
          <target state="translated">Body</target>
        </trans-unit>
        <trans-unit id="c11c5c92eb4bb23f4e3a2e484b5d01a2f02ca7c0" translate="yes" xml:space="preserve">
          <source>Bourne shell script</source>
          <target state="translated">Bourne 쉘 스크립트</target>
        </trans-unit>
        <trans-unit id="35387df992c10423a1e97a8fdd9850a0e2b7c2bb" translate="yes" xml:space="preserve">
          <source>Brotli Compressed Data Format</source>
          <target state="translated">Brotli 압축 데이터 형식</target>
        </trans-unit>
        <trans-unit id="ebd022bdbe14f7ec31423f0eeb91b8cd71a827f2" translate="yes" xml:space="preserve">
          <source>Browse through detailed HTTP reference documentation.</source>
          <target state="translated">자세한 HTTP 참조 문서를 찾아보십시오.</target>
        </trans-unit>
        <trans-unit id="54a2cf5e634dbba0be2bf8a55f79252f5c790bdb" translate="yes" xml:space="preserve">
          <source>Browser</source>
          <target state="translated">Browser</target>
        </trans-unit>
        <trans-unit id="aac7378f1efd1829430797b0495fda2b1605e7e6" translate="yes" xml:space="preserve">
          <source>Browser Compatibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63fac1fb83ccf0b03f982fe1fa1a1b2cd86ed72c" translate="yes" xml:space="preserve">
          <source>Browser Name</source>
          <target state="translated">브라우저 이름</target>
        </trans-unit>
        <trans-unit id="d18eb74e69d3d38bec47169d773de18efefdfab3" translate="yes" xml:space="preserve">
          <source>Browser behavior differs if this response erroneously includes a body on persistent connections See &lt;a href=&quot;204&quot;&gt;204 No Content&lt;/a&gt; for more detail.</source>
          <target state="translated">이 응답에 영구 연결의 본문이 잘못 포함되어 있으면 브라우저 동작이 다릅니다 . 자세한 &lt;a href=&quot;204&quot;&gt;내용&lt;/a&gt; 은 204 내용 없음을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b99b91e559917941bb0e259fb1c7151b747a651d" translate="yes" xml:space="preserve">
          <source>Browser compatibility</source>
          <target state="translated">브라우저 호환성</target>
        </trans-unit>
        <trans-unit id="b36b7a67afaec4b763f7afbae4c6ac08d5194f85" translate="yes" xml:space="preserve">
          <source>Browser compatibility is not relevant for this header (header is sent by server, and the specification does not define client behaviour).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9596fac5cc2ce26e02f68794e8302c229989e32" translate="yes" xml:space="preserve">
          <source>Browser compatibility&lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;Update compatibility data on GitHub&lt;/a&gt;</source>
          <target state="translated">브라우저 호환성 &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;GitHub의 호환성 데이터 업데이트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7fa3ab903e2b10d31d9550e3d19e0235e67965c5" translate="yes" xml:space="preserve">
          <source>Browser detection using the user agent</source>
          <target state="translated">사용자 에이전트를 사용한 브라우저 감지</target>
        </trans-unit>
        <trans-unit id="b250936e425b70355734e2e64ef7dec7333eb610" translate="yes" xml:space="preserve">
          <source>Browser fingerprinting is a set of techniques for identifying a
   specific user agent over time through its unique set of
   characteristics.  These characteristics might include information
   related to its TCP behavior, feature capabilities, and scripting
   environment, though of particular interest here is the set of unique
   characteristics that might be communicated via HTTP.  Fingerprinting
   is considered a privacy concern because it enables tracking of a user
   agent's behavior over time without the corresponding controls that
   the user might have over other forms of data collection (e.g.,
   cookies).  Many general-purpose user agents (i.e., Web browsers) have
   taken steps to reduce their fingerprints.

   There are a number of request header fields that might reveal
   information to servers that is sufficiently unique to enable
   fingerprinting.  The From header field is the most obvious, though it
   is expected that From will only be sent when self-identification is
   desired by the user.  Likewise, Cookie header fields are deliberately 

   designed to enable re-identification, so fingerprinting concerns only
   apply to situations where cookies are disabled or restricted by the
   user agent's configuration.

   The User-Agent header field might contain enough information to
   uniquely identify a specific device, usually when combined with other
   characteristics, particularly if the user agent sends excessive
   details about the user's system or extensions.  However, the source
   of unique information that is least expected by users is proactive
   negotiation (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;), including the Accept, Accept-Charset,
   Accept-Encoding, and Accept-Language header fields.

   In addition to the fingerprinting concern, detailed use of the
   Accept-Language header field can reveal information the user might
   consider to be of a private nature.  For example, understanding a
   given language set might be strongly correlated to membership in a
   particular ethnic group.  An approach that limits such loss of
   privacy would be for a user agent to omit the sending of
   Accept-Language except for sites that have been whitelisted, perhaps
   via interaction after detecting a Vary header field that indicates
   language negotiation might be useful.

   In environments where proxies are used to enhance privacy, user
   agents ought to be conservative in sending proactive negotiation
   header fields.  General-purpose user agents that provide a high
   degree of header field configurability ought to inform users about
   the loss of privacy that might result if too much detail is provided.
   As an extreme privacy measure, proxies could filter the proactive
   negotiation header fields in relayed requests.</source>
          <target state="translated">브라우저 핑거 프린팅은 고유 한 특성 세트를 통해 시간이 지남에 따라 특정 사용자 에이전트를 식별하기위한 기술 세트입니다. 이러한 특성에는 TCP 동작, 기능 기능 및 스크립팅 환경과 관련된 정보가 포함될 수 있지만 여기에는 특히 HTTP를 통해 통신 할 수있는 고유 한 특성이 있습니다. 지문은 사용자가 다른 형태의 데이터 수집 (예 : 쿠키)에 대해 가질 수있는 해당 제어없이 시간이 지남에 따라 사용자 에이전트의 동작을 추적 할 수있게하므로 프라이버시 문제로 간주됩니다. 많은 범용 사용자 에이전트 (예 : 웹 브라우저)는 지문을 줄이기위한 조치를 취했습니다.핑거 프린팅을 가능하게하는 고유 한 서버에 정보를 표시 할 수있는 많은 요청 헤더 필드가 있습니다. From 헤더 필드가 가장 분명하지만 From은 사용자가 자체 식별을 원하는 경우에만 전송 될 것으로 예상됩니다. 마찬가지로 쿠키 헤더 필드는 의도적으로 재 식별을 가능하게하도록 설계되었으므로 지문 처리 문제는 사용자 에이전트의 구성에 의해 쿠키가 비활성화되거나 제한되는 상황에만 적용됩니다. User-Agent 헤더 필드에는 특정 장치를 고유하게 식별하기에 충분한 정보가 포함되어있을 수 있습니다. 일반적으로 다른 특성과 결합 할 때, 특히 사용자 에이전트가 사용자의 시스템 또는 확장에 대한 과도한 세부 정보를 보내는 경우입니다. 하나,사용자가 가장 적게 기대하는 고유 한 정보의 출처는 사전 협상 (&lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt;) (Accept, Accept-Charset, Accept-Encoding 및 Accept-Language 헤더 필드 포함) 지문 관련 문제 외에도 Accept-Language 헤더 필드를 자세하게 사용하면 사용자가 사적인 것으로 간주 할 수있는 정보를 알 수 있습니다. 예를 들어, 주어진 언어 세트를 이해하는 것은 특정 민족 그룹의 멤버십과 밀접한 관련이있을 수 있습니다. 이러한 개인 정보 손실을 제한하는 접근 방식은 사용자 에이전트가 허용 된 언어를 보내는 것을 생략하는 것입니다. 허용 된 언어는 언어 협상을 나타내는 Vary 헤더 필드를 감지 한 후 상호 작용을 통해 허용됩니다. 프라이버시를 향상시키기 위해 프록시가 사용되는 환경에서 사용자 에이전트는 사전 협상 헤더 필드를 전송하는 데 보수적이어야합니다.높은 수준의 헤더 필드 구성 기능을 제공하는 범용 사용자 에이전트는 사용자에게 세부 정보가 너무 많이 제공 될 경우 발생할 수있는 개인 정보 손실에 대해 알려야합니다. 극단적 인 개인 정보 보호 조치로서 프록시는 릴레이 된 요청에서 사전 협상 헤더 필드를 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ed002e27e188e607dd038f852e9932680fbaaf2" translate="yes" xml:space="preserve">
          <source>Browser implementation is being discussed in &lt;a href=&quot;https://github.com/w3c/web-share/issues/169&quot;&gt;https://github.com/w3c/web-share/issues/169&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70dd2cd112b43ff0945574d1dda0f74996baa01" translate="yes" xml:space="preserve">
          <source>Browser specific notes</source>
          <target state="translated">Browser specific notes</target>
        </trans-unit>
        <trans-unit id="4fc469bc098ba2e7153a183b517baa5e07dc2864" translate="yes" xml:space="preserve">
          <source>Browser test site: &lt;a href=&quot;https://projects.dm.id.lv/Public-Key-Pins_test&quot;&gt;HSTS and HPKP test&lt;/a&gt;</source>
          <target state="translated">브라우저 테스트 사이트 : &lt;a href=&quot;https://projects.dm.id.lv/Public-Key-Pins_test&quot;&gt;HSTS 및 HPKP 테스트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1d7e0a33cf80fe452070f36fa8edcaff2499ee3" translate="yes" xml:space="preserve">
          <source>Browser version</source>
          <target state="translated">브라우저 버전</target>
        </trans-unit>
        <trans-unit id="d09fda30e9d38d9aabf757744c9bcebdabaa3f5c" translate="yes" xml:space="preserve">
          <source>Browsers &lt;strong&gt;ignore&lt;/strong&gt; the &lt;code&gt;Expect-CT&lt;/code&gt; header over HTTP; the header only has effect on HTTPS connections.</source>
          <target state="translated">Browsers &lt;strong&gt;ignore&lt;/strong&gt; the &lt;code&gt;Expect-CT&lt;/code&gt; header over HTTP; the header only has effect on HTTPS connections.</target>
        </trans-unit>
        <trans-unit id="c2c3bd867e8f023b1e9b10989759e0116b284ac8" translate="yes" xml:space="preserve">
          <source>Browsers are migrating to have &lt;a href=&quot;https://www.chromestatus.com/feature/5088147346030592&quot;&gt;cookies default to &lt;code&gt;SameSite=Lax&lt;/code&gt;&lt;/a&gt;. If a cookie is needed to be sent cross-origin, opt out of the &lt;code&gt;SameSite&lt;/code&gt; restriction using the &lt;code&gt;None&lt;/code&gt; value. The &lt;code&gt;None&lt;/code&gt; value requires the &lt;a href=&quot;#Secure&quot;&gt;&lt;code&gt;Secure&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">Browsers are migrating to have &lt;a href=&quot;https://www.chromestatus.com/feature/5088147346030592&quot;&gt;cookies default to &lt;code&gt;SameSite=Lax&lt;/code&gt; &lt;/a&gt;. If a cookie is needed to be sent cross-origin, opt out of the &lt;code&gt;SameSite&lt;/code&gt; restriction using the &lt;code&gt;None&lt;/code&gt; value. The &lt;code&gt;None&lt;/code&gt; value requires the &lt;a href=&quot;#Secure&quot;&gt; &lt;code&gt;Secure&lt;/code&gt; &lt;/a&gt; attribute.</target>
        </trans-unit>
        <trans-unit id="08f273cb65b42c95174f6e5a89129c85c242b47c" translate="yes" xml:space="preserve">
          <source>Browsers are migrating to have &lt;a href=&quot;https://www.chromestatus.com/feature/5088147346030592&quot;&gt;cookies default to &lt;code&gt;SameSite=Lax&lt;/code&gt;&lt;/a&gt;. If a cookie is needed to be sent cross-origin, opt out of the SameSite restriction by using the &lt;code&gt;None&lt;/code&gt; directive. The &lt;code&gt;None&lt;/code&gt; directive requires that the &lt;a href=&quot;#Secure_and_HttpOnly_cookies&quot;&gt;&lt;code&gt;Secure&lt;/code&gt;&lt;/a&gt; attribute also be used.</source>
          <target state="translated">Browsers are migrating to have &lt;a href=&quot;https://www.chromestatus.com/feature/5088147346030592&quot;&gt;cookies default to &lt;code&gt;SameSite=Lax&lt;/code&gt; &lt;/a&gt;. If a cookie is needed to be sent cross-origin, opt out of the SameSite restriction by using the &lt;code&gt;None&lt;/code&gt; directive. The &lt;code&gt;None&lt;/code&gt; directive requires that the &lt;a href=&quot;#Secure_and_HttpOnly_cookies&quot;&gt; &lt;code&gt;Secure&lt;/code&gt; &lt;/a&gt; attribute also be used.</target>
        </trans-unit>
        <trans-unit id="040b9395d8c1be97fa38d9005cfb38d82433885b" translate="yes" xml:space="preserve">
          <source>Browsers block frontend JavaScript code from accessing the &lt;code&gt;Set Cookie&lt;/code&gt; header, as required by the Fetch spec, which defines &lt;code&gt;Set-Cookie&lt;/code&gt; as a &lt;a href=&quot;https://fetch.spec.whatwg.org/#forbidden-response-header-name&quot;&gt;forbidden response-header name&lt;/a&gt; that &lt;a href=&quot;https://fetch.spec.whatwg.org/#ref-for-forbidden-response-header-name%E2%91%A0&quot;&gt;must be filtered out&lt;/a&gt; from any response exposed to frontend code.</source>
          <target state="translated">Browsers block frontend JavaScript code from accessing the &lt;code&gt;Set Cookie&lt;/code&gt; header, as required by the Fetch spec, which defines &lt;code&gt;Set-Cookie&lt;/code&gt; as a &lt;a href=&quot;https://fetch.spec.whatwg.org/#forbidden-response-header-name&quot;&gt;forbidden response-header name&lt;/a&gt; that &lt;a href=&quot;https://fetch.spec.whatwg.org/#ref-for-forbidden-response-header-name%E2%91%A0&quot;&gt;must be filtered out&lt;/a&gt; from any response exposed to frontend code.</target>
        </trans-unit>
        <trans-unit id="a862ea052d45f44e70d62ee3df599d55e7a99307" translate="yes" xml:space="preserve">
          <source>Browsers send specific &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; for cross-site requests initiated from within &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt;. It also expects to see specific HTTP headers sent back with cross-site responses. An overview of these headers, including sample JavaScript code that initiates requests and processes responses from the server, as well as a discussion of each header, &lt;a href=&quot;cors&quot;&gt;can be found in the HTTP Access Control (CORS) article&lt;/a&gt; and should be read as a companion article to this one. This article covers processing &lt;strong&gt;Access Control Requests&lt;/strong&gt; and formulating &lt;strong&gt;Access Control Responses&lt;/strong&gt; in PHP. The target audience for this article are server programmers or administrators. Although the code samples shown here are in PHP, similar concepts apply for ASP.net, Perl, Python, Java, etc.; in general, these concepts can be applied to any server-side programming environment that processes HTTP requests and dynamically formulates HTTP responses.</source>
          <target state="translated">브라우저는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt; 내에서 시작된 사이트 간 요청에 대한 특정 &lt;a href=&quot;headers&quot;&gt;HTTP 헤더&lt;/a&gt; 를 보냅니다 . 또한 교차 사이트 응답과 함께 특정 HTTP 헤더가 다시 전송 될 것으로 예상합니다. 요청을 시작하고 서버의 응답을 처리하는 샘플 JavaScript 코드 및 각 헤더에 대한 설명을 포함하여 이러한 헤더에 대한 개요는 &lt;a href=&quot;cors&quot;&gt;HTTP 액세스 제어 (CORS) 기사에서 찾을 수 있으며 이에 대한 기사&lt;/a&gt; 로 읽어야합니다. 이 하나. 이 문서에서는 &lt;strong&gt;액세스 제어 요청&lt;/strong&gt; 처리 및 &lt;strong&gt;액세스 제어 응답&lt;/strong&gt; 공식화에 대해 설명합니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;PHP에서. 이 기사의 대상은 서버 프로그래머 또는 관리자입니다. 여기에 표시된 코드 샘플은 PHP로되어 있지만 ASP.net, Perl, Python, Java 등에 유사한 개념이 적용됩니다. 일반적으로 이러한 개념은 HTTP 요청을 처리하고 HTTP 응답을 동적으로 공식화하는 모든 서버 측 프로그래밍 환경에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f862e5c244452929ab40c4ceda509655ef249fcb" translate="yes" xml:space="preserve">
          <source>Browsers use &lt;code&gt;utf-8&lt;/code&gt; encoding for usernames and passwords.</source>
          <target state="translated">Browsers use &lt;code&gt;utf-8&lt;/code&gt; encoding for usernames and passwords.</target>
        </trans-unit>
        <trans-unit id="a4d0e2f5033f06ac6f49cc655a388250e954dd48" translate="yes" xml:space="preserve">
          <source>Browsers use &lt;code&gt;utf-8&lt;/code&gt; encoding for usernames and passwords. Firefox used to use &lt;code&gt;ISO-8859-1&lt;/code&gt;, but changed over to &lt;code&gt;utf-8&lt;/code&gt; for parity with other browsers, and to avoid potential problems as described in &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1419658&quot;&gt;bug 1419658&lt;/a&gt;.</source>
          <target state="translated">브라우저 는 사용자 이름 및 비밀번호에 &lt;code&gt;utf-8&lt;/code&gt; 인코딩을 사용 합니다. Firefox는 &lt;code&gt;ISO-8859-1&lt;/code&gt; 을 사용 했지만 다른 브라우저와의 패리티를 위해 &lt;code&gt;utf-8&lt;/code&gt; 로 변경 되었으며 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1419658&quot;&gt;버그 1419658에&lt;/a&gt; 설명 된대로 잠재적 인 문제를 피 했습니다 .</target>
        </trans-unit>
        <trans-unit id="a63957685418f827a422303f2aa0c711fe3143d4" translate="yes" xml:space="preserve">
          <source>Browsers use the MIME type, &lt;strong&gt;not the file extension&lt;/strong&gt;, to determine how to process a URL &amp;mdash; it is important that servers send the correct MIME type in the response's &lt;a href=&quot;../headers/content-type&quot;&gt;Content-Type header&lt;/a&gt;.</source>
          <target state="translated">브라우저 &lt;strong&gt;는 파일 확장자가 아닌&lt;/strong&gt; MIME 유형을 사용하여 URL을 처리하는 방법을 결정합니다. 서버는 응답의 &lt;a href=&quot;../headers/content-type&quot;&gt;Content-Type 헤더&lt;/a&gt; 에 올바른 MIME 유형을 보내는 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="2e9afcf709277aae6a6520057ea60bf3be39c90b" translate="yes" xml:space="preserve">
          <source>Browsers will not remember an &lt;code&gt;Expect-CT&lt;/code&gt; policy, unless the site has 'proven' it can serve a certificate satisfying the certificate transparency requirements. Browsers implement their own trust model regarding which CT logs are considered trusted for the certificate to have been logged to.</source>
          <target state="translated">Browsers will not remember an &lt;code&gt;Expect-CT&lt;/code&gt; policy, unless the site has 'proven' it can serve a certificate satisfying the certificate transparency requirements. Browsers implement their own trust model regarding which CT logs are considered trusted for the certificate to have been logged to.</target>
        </trans-unit>
        <trans-unit id="5bc12d6c5418def433565d97fa4386bb760ddfa9" translate="yes" xml:space="preserve">
          <source>Buggy &lt;a href=&quot;https://en.wikipedia.org/wiki/Proxy_server&quot;&gt;proxies&lt;/a&gt; are still common and these lead to strange and erratic behaviors that Web developers cannot foresee and diagnose easily.</source>
          <target state="translated">버기 &lt;a href=&quot;https://en.wikipedia.org/wiki/Proxy_server&quot;&gt;프록시&lt;/a&gt; 는 여전히 일반적이며 웹 개발자가 쉽게 예측하고 진단 할 수없는 이상하고 불규칙한 동작으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="a08f5341fe1477c327aaa2ec714bb0a54bdba4f3" translate="yes" xml:space="preserve">
          <source>Bugzilla bug 1459573</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82fd0d6dc5b3bab8b83886f108ed9c6addec57a9" translate="yes" xml:space="preserve">
          <source>Builds of Chrome are designed to stop enforcing the &lt;code&gt;Expect-CT&lt;/code&gt; policy 10 weeks after the installation's build date.</source>
          <target state="translated">Builds of Chrome are designed to stop enforcing the &lt;code&gt;Expect-CT&lt;/code&gt; policy 10 weeks after the installation's build date.</target>
        </trans-unit>
        <trans-unit id="3838036b670cc0248afd246abbe594ee328cf4de" translate="yes" xml:space="preserve">
          <source>But browsers and standards are not perfect, and there are still some edge cases where detecting the browser is needed. Using the user agent to detect the browser looks simple, but doing it well is, in fact, a very hard problem. This document will guide you in doing this as correctly as possible.</source>
          <target state="translated">그러나 브라우저와 표준은 완벽하지 않으며 브라우저 감지가 필요한 경우가 여전히 있습니다. 사용자 에이전트를 사용하여 브라우저를 감지하는 것은 간단 해 보이지만 실제로는 매우 어려운 문제입니다. 이 문서는 가능한 한 정확하게이 작업을 수행하도록 안내합니다.</target>
        </trans-unit>
        <trans-unit id="7c8e3ceffa66e087ea7c8b96aa7587bcaf4d90e8" translate="yes" xml:space="preserve">
          <source>But if it&amp;rsquo;s not possible to make those changes, then another way that may be possible is to this:</source>
          <target state="translated">그러나 이러한 변경을 수행 할 수없는 경우 가능한 다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d7241a2b594de7bc64154d28757129ce26170606" translate="yes" xml:space="preserve">
          <source>By default the policy is set to &lt;code&gt;*&lt;/code&gt;, which means synchronous requests are allowed in all frames.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95da926485cbe7c1b54926edc5fadc82e556e609" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;https://developer.mozilla.org/en/HTTP&quot;&gt;HTTP&lt;/a&gt; requests are issued sequentially. The next request is only issued once the response to the current request has been received. As they are affected by network latencies and bandwidth limitations, this can result in significant delay before the next request is &lt;em&gt;seen&lt;/em&gt; by the server.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;https://developer.mozilla.org/en/HTTP&quot;&gt;HTTP&lt;/a&gt; 요청은 순차적으로 발행됩니다. 다음 요청은 현재 요청에 대한 응답이 수신 된 후에 만 ​​발행됩니다. 네트워크 대기 시간 및 대역폭 제한의 영향을 받으 므로 서버 에서 다음 요청이 &lt;em&gt;표시&lt;/em&gt; 되기 전에 상당한 지연이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6abb5b1e0911f25ada48f489e06f7debe4790d8f" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; requests are issued sequentially. The next request is only issued once the response to the current request has been received. As they are affected by network latencies and bandwidth limitations, this can result in significant delay before the next request is &lt;em&gt;seen&lt;/em&gt; by the server.</source>
          <target state="translated">By default, &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; requests are issued sequentially. The next request is only issued once the response to the current request has been received. As they are affected by network latencies and bandwidth limitations, this can result in significant delay before the next request is &lt;em&gt;seen&lt;/em&gt; by the server.</target>
        </trans-unit>
        <trans-unit id="dbfb748d8e0737c34e1264e5236d921dd7f9917f" translate="yes" xml:space="preserve">
          <source>By default, a response is cacheable if the requirements of the
   request method, request header fields, and the response status
   indicate that it is cacheable. &lt;a href=&quot;#section-13.4&quot;&gt;Section 13.4&lt;/a&gt; summarizes these defaults
   for cacheability. The following Cache-Control response directives
   allow an origin server to override the default cacheability of a
   response:

   public
      Indicates that the response MAY be cached by any cache, even if it
      would normally be non-cacheable or cacheable only within a non-
      shared cache. (See also Authorization, &lt;a href=&quot;#section-14.8&quot;&gt;section 14.8&lt;/a&gt;, for
      additional details.)

   private
      Indicates that all or part of the response message is intended for
      a single user and MUST NOT be cached by a shared cache. This
      allows an origin server to state that the specified parts of the 

      response are intended for only one user and are not a valid
      response for requests by other users. A private (non-shared) cache
      MAY cache the response.

       Note: This usage of the word private only controls where the
       response may be cached, and cannot ensure the privacy of the
       message content.

   no-cache
       If the no-cache directive does not specify a field-name, then a
      cache MUST NOT use the response to satisfy a subsequent request
      without successful revalidation with the origin server. This
      allows an origin server to prevent caching even by caches that
      have been configured to return stale responses to client requests.

      If the no-cache directive does specify one or more field-names,
      then a cache MAY use the response to satisfy a subsequent request,
      subject to any other restrictions on caching. However, the
      specified field-name(s) MUST NOT be sent in the response to a
      subsequent request without successful revalidation with the origin
      server. This allows an origin server to prevent the re-use of
      certain header fields in a response, while still allowing caching
      of the rest of the response.

       Note: Most HTTP/1.0 caches will not recognize or obey this
       directive.</source>
          <target state="translated">요청 메소드, 요청 헤더 필드 및 응답 상태의 요구 사항이 캐시 가능함을 표시하는 경우 기본적으로 응답은 캐시 가능합니다. &lt;a href=&quot;#section-13.4&quot;&gt;섹션 13.4&lt;/a&gt; 에는 캐시 가능성에 대한 이러한 기본값이 요약되어 있습니다. 다음과 같은 캐시 제어 응답 지시문을 사용하면 오리진 서버가 응답의 기본 캐시 가능성을 대체 할 수 있습니다. public 응답이 일반적으로 캐시 할 수 없거나 공유되지 않은 캐시 내에서만 캐시 가능하더라도 캐시에 의해 캐시 될 수 있음을 나타냅니다 . (권한, &lt;a href=&quot;#section-14.8&quot;&gt;섹션 14.8 참조&lt;/a&gt;비공개 응답 메시지의 일부 또는 전부가 단일 사용자를위한 것이며 공유 캐시에 의해 캐시되지 않아야 함을 나타냅니다. 이를 통해 오리진 서버는 응답의 지정된 부분이 한 명의 사용자만을위한 것이며 다른 사용자의 요청에 대한 올바른 응답이 아니라고 진술 할 수 있습니다. 비공개 (비공유) 캐시는 응답을 캐시 할 수 있습니다. 참고 :이 private이라는 단어 사용은 응답을 캐시 할 수있는 위치 만 제어하며 메시지 내용의 프라이버시를 보장 할 수 없습니다. no-cache no-cache 지시문이 field-name을 지정하지 않으면, 캐시는 오리진 서버와의 재확인없이 후속 요청을 만족시키기 위해 응답을 사용해서는 안됩니다.이를 통해 오리진 서버는 클라이언트 요청에 부실 응답을 리턴하도록 구성된 캐시로도 캐싱을 방지 할 수 있습니다. no-cache 지시문이 하나 이상의 필드 이름을 지정하면 캐시는 캐싱에 대한 다른 제한에 따라 응답을 사용하여 후속 요청을 충족시킬 수 있습니다. 그러나 지정된 field-name (s)은 원본 서버와의 재확인없이 후속 요청에 대한 응답으로 전송되어서는 안됩니다 (MUST NOT). 이를 통해 오리진 서버는 응답에서 특정 헤더 필드의 재사용을 방지하면서도 나머지 응답을 캐싱 할 수 있습니다. 참고 : 대부분의 HTTP / 1.0 캐시는이 지시문을 인식하거나 따르지 않습니다.no-cache 지시문이 하나 이상의 필드 이름을 지정하면 캐시는 캐싱에 대한 다른 제한 사항에 따라 응답을 사용하여 후속 요청을 충족시킬 수 있습니다. 그러나 지정된 field-name (s)은 원본 서버와의 재확인없이 후속 요청에 대한 응답으로 전송되어서는 안됩니다 (MUST NOT). 이를 통해 오리진 서버는 응답에서 특정 헤더 필드의 재사용을 방지하면서도 나머지 응답을 캐싱 할 수 있습니다. 참고 : 대부분의 HTTP / 1.0 캐시는이 지시문을 인식하거나 따르지 않습니다.no-cache 지시문이 하나 이상의 필드 이름을 지정하면 캐시는 캐싱에 대한 다른 제한 사항에 따라 응답을 사용하여 후속 요청을 충족시킬 수 있습니다. 그러나 지정된 field-name (s)은 원본 서버와의 재확인없이 후속 요청에 대한 응답으로 전송되어서는 안됩니다 (MUST NOT). 이를 통해 오리진 서버는 응답에서 특정 헤더 필드의 재사용을 방지하면서도 나머지 응답을 캐싱 할 수 있습니다. 참고 : 대부분의 HTTP / 1.0 캐시는이 지시문을 인식하거나 따르지 않습니다.지정된 field-name (s)은 원본 서버와의 재확인없이 후속 요청에 대한 응답으로 전송되어서는 안됩니다 (MUST NOT). 이를 통해 오리진 서버는 응답에서 특정 헤더 필드의 재사용을 방지하면서도 나머지 응답을 캐싱 할 수 있습니다. 참고 : 대부분의 HTTP / 1.0 캐시는이 지시문을 인식하거나 따르지 않습니다.지정된 field-name (s)은 오리진 서버와의 재확인없이 후속 요청에 대한 응답으로 전송되어서는 안됩니다 (MUST NOT). 이를 통해 오리진 서버는 응답에서 특정 헤더 필드의 재사용을 방지하면서도 나머지 응답을 캐싱 할 수 있습니다. 참고 : 대부분의 HTTP / 1.0 캐시는이 지시문을 인식하거나 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11cebe099b732834a230be98a924681140743e7e" translate="yes" xml:space="preserve">
          <source>By default, only the 6 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Simple_response_header&quot;&gt;simple response headers&lt;/a&gt; are exposed:</source>
          <target state="translated">기본적으로 6 개의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Simple_response_header&quot;&gt;간단한 응답 헤더&lt;/a&gt; 만 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa262e31090b07e93005688b0506414a054e9ae2" translate="yes" xml:space="preserve">
          <source>By default, only the 7 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_response_header&quot;&gt;CORS-safelisted response headers&lt;/a&gt; are exposed:</source>
          <target state="translated">By default, only the 7 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_response_header&quot;&gt;CORS-safelisted response headers&lt;/a&gt; are exposed:</target>
        </trans-unit>
        <trans-unit id="2f534edc05bd142ea112ee3efccba58b43dd4c66" translate="yes" xml:space="preserve">
          <source>By default, the Geolocation API can be used within top-level documents and their same-origin child frames. This directive allows or prevents cross-origin frames from accessing geolocation. This includes same-origin frames.</source>
          <target state="translated">기본적으로 Geolocation API는 최상위 문서 및 동일한 원본 자식 프레임 내에서 사용할 수 있습니다. 이 지시문은 출처 간 프레임이 지리적 위치에 액세스하는 것을 허용하거나 방지합니다. 여기에는 동일한 출처 프레임이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e044c03f1a747bedf5cf5499ef70c090ed113f76" translate="yes" xml:space="preserve">
          <source>By default, top-level documents and their same-origin child frames can request and enter fullscreen mode. This directive allows or prevents cross-origin frames from using fullscreen mode. This includes same-origin frames.</source>
          <target state="translated">기본적으로 최상위 문서 및 동일한 원본 자식 프레임은 전체 화면 모드를 요청하고 입력 할 수 있습니다. 이 지시문은 출처 간 프레임이 전체 화면 모드를 사용하도록 허용하거나 방지합니다. 여기에는 동일한 출처 프레임이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d23c07d6cec707b5f2b899cf897854aba60b3de4" translate="yes" xml:space="preserve">
          <source>By default, violation reports aren't sent. To enable violation reporting, you need to specify the &lt;a href=&quot;headers/content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; policy directive, providing at least one URI to which to deliver the reports:</source>
          <target state="translated">기본적으로 위반 보고서는 전송되지 않습니다. 위반보고를 사용하려면 &lt;a href=&quot;headers/content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt; 를 전달할 URI를 하나 이상 제공 하여 report-uri 정책 지시문 을 지정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="8029f70a8cb4b060850538e53207e165c56eb9a2" translate="yes" xml:space="preserve">
          <source>By far, the most common use case for upgrading an HTTP connection is to use WebSockets, which are always implemented by upgrading an HTTP or HTTPS connection. Keep in mind that if you're opening a new connection using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket&quot;&gt;WebSocket API&lt;/a&gt;, or any library that does WebSockets, most or all of this is done for you. For example, opening a WebSocket connection is as simple as:</source>
          <target state="translated">지금까지 HTTP 연결을 업그레이드하는 가장 일반적인 사용 사례는 항상 HTTP 또는 HTTPS 연결을 업그레이드하여 구현되는 WebSocket을 사용하는 것입니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket&quot;&gt;WebSocket API&lt;/a&gt; 또는 WebSocket을 수행하는 라이브러리를 사용하여 새 연결을 여는 경우이 중 대부분 또는 전부가 자동으로 수행됩니다. 예를 들어, WebSocket 연결을 여는 것은 다음과 같이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="8e0591ef828136aecdfc13e9fe74e5b53dd0d8e6" translate="yes" xml:space="preserve">
          <source>By specifying the &lt;code&gt;'none'&lt;/code&gt; keyword for the origin list, the specified features will be disabled for all browsing contexts (this includes all iframes), regardless of their origin.</source>
          <target state="translated">By specifying the &lt;code&gt;'none'&lt;/code&gt; keyword for the origin list, the specified features will be disabled for all browsing contexts (this includes all iframes), regardless of their origin.</target>
        </trans-unit>
        <trans-unit id="8358024c4d3220c8cee184585d77cac9c14c31ac" translate="yes" xml:space="preserve">
          <source>By specifying the &lt;code&gt;'none'&lt;/code&gt; keyword for the origin list, the specified features will be disabled for all browsing contexts, regardless of their origin.</source>
          <target state="translated">지정하여 &lt;code&gt;'none'&lt;/code&gt; 원점 목록 키워드를, 지정된 기능을 기점과 상관없이, 모든 검색 컨텍스트에 사용할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="424fa2e5f873eae608f951882e066b4cbc6e7248" translate="yes" xml:space="preserve">
          <source>By their very nature, HTTP intermediaries are men-in-the-middle and,
   thus, represent an opportunity for man-in-the-middle attacks.
   Compromise of the systems on which the intermediaries run can result
   in serious security and privacy problems.  Intermediaries might have
   access to security-related information, personal information about
   individual users and organizations, and proprietary information
   belonging to users and content providers.  A compromised
   intermediary, or an intermediary implemented or configured without
   regard to security and privacy considerations, might be used in the
   commission of a wide range of potential attacks.

   Intermediaries that contain a shared cache are especially vulnerable
   to cache poisoning attacks, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-8&quot;&gt;Section&amp;nbsp;8 of [RFC7234]&lt;/a&gt;. 

   Implementers need to consider the privacy and security implications
   of their design and coding decisions, and of the configuration
   options they provide to operators (especially the default
   configuration).

   Users need to be aware that intermediaries are no more trustworthy
   than the people who run them; HTTP itself cannot solve this problem.</source>
          <target state="translated">본질적으로 HTTP 중개자는 중간자 (man-in-the-middle)이므로 중간자 (man-in-the-middle) 공격의 기회를 나타냅니다. 중개자가 실행되는 시스템이 손상되면 심각한 보안 및 개인 정보 보호 문제가 발생할 수 있습니다. 중개자는 보안 관련 정보, 개별 사용자 및 조직에 대한 개인 정보 및 사용자 및 컨텐츠 제공자에 속하는 독점 정보에 액세스 할 수 있습니다. 보안 및 개인 정보 보호 고려 사항과 무관하게 훼손된 중개자 또는 구현되거나 구성된 중개자가 광범위한 잠재적 공격을 수행하는 데 사용될 수 있습니다. 공유 캐시를 포함하는 중개자 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-8&quot;&gt;는 [RFC7234]의 섹션 8에&lt;/a&gt; 설명 된 것처럼 캐시 중독 공격에 특히 취약합니다 .. 구현자는 설계 및 코딩 결정, 그리고 운영자에게 제공하는 구성 옵션 (특히 기본 구성)에 대한 개인 정보 보호 및 보안 관련 사항을 고려해야합니다. 사용자는 중개자가 자신을 운영하는 사람들보다 더 신뢰할 수 없다는 것을 알고 있어야합니다. HTTP 자체는이 문제를 해결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="068b79ba257daf146b30abe76ed868aecb1b606b" translate="yes" xml:space="preserve">
          <source>By their very nature, HTTP proxies are men-in-the-middle, and
   represent an opportunity for man-in-the-middle attacks. Compromise of
   the systems on which the proxies run can result in serious security
   and privacy problems. Proxies have access to security-related
   information, personal information about individual users and
   organizations, and proprietary information belonging to users and
   content providers. A compromised proxy, or a proxy implemented or
   configured without regard to security and privacy considerations,
   might be used in the commission of a wide range of potential attacks.

   Proxy operators should protect the systems on which proxies run as
   they would protect any system that contains or transports sensitive
   information. In particular, log information gathered at proxies often
   contains highly sensitive personal information, and/or information
   about organizations. Log information should be carefully guarded, and
   appropriate guidelines for use developed and followed. (&lt;a href=&quot;#section-15.1.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-15.1.1&quot;&gt;15.1.1&lt;/a&gt;). 

   Caching proxies provide additional potential vulnerabilities, since
   the contents of the cache represent an attractive target for
   malicious exploitation. Because cache contents persist after an HTTP
   request is complete, an attack on the cache can reveal information
   long after a user believes that the information has been removed from
   the network. Therefore, cache contents should be protected as
   sensitive information.

   Proxy implementors should consider the privacy and security
   implications of their design and coding decisions, and of the
   configuration options they provide to proxy operators (especially the
   default configuration).

   Users of a proxy need to be aware that they are no trustworthier than
   the people who run the proxy; HTTP itself cannot solve this problem.

   The judicious use of cryptography, when appropriate, may suffice to
   protect against a broad range of security and privacy attacks. Such
   cryptography is beyond the scope of the HTTP/1.1 specification.</source>
          <target state="translated">본질적으로 HTTP 프록시는 중간자 (man-in-the-middle)이며 중간자 (man-in-the-middle) 공격의 기회를 나타냅니다. 프록시가 실행되는 시스템이 손상되면 심각한 보안 및 개인 정보 보호 문제가 발생할 수 있습니다. 프록시는 보안 관련 정보, 개별 사용자 및 조직에 대한 개인 정보 및 사용자 및 콘텐츠 공급자의 소유 정보에 액세스 할 수 있습니다. 보안 및 개인 정보 보호 고려 사항에 관계없이 구현 된 프록시 또는 손상된 프록시가 광범위한 잠재적 공격에 사용될 수 있습니다. 프록시 운영자는 중요한 정보를 포함하거나 전송하는 시스템을 보호 할 때 프록시가 실행되는 시스템을 보호해야합니다. 특히,프록시에서 수집 된 로그 정보에는 종종 민감한 개인 정보 및 / 또는 조직에 대한 정보가 포함됩니다. 로그 정보는주의해서 보호해야하며 사용에 대한 적절한 지침을 개발하고 준수해야합니다. (&lt;a href=&quot;#section-15.1.1&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-15.1.1&quot;&gt;15.1.1&lt;/a&gt;). 캐시의 내용은 악의적 인 악용의 매력적인 대상이되기 때문에 캐싱 프록시는 추가적인 잠재적 취약점을 제공합니다. HTTP 요청이 완료된 후에도 캐시 내용이 유지되므로 사용자가 네트워크에서 정보가 제거되었다고 생각한 후에 캐시를 공격하면 정보가 노출 될 수 있습니다. 따라서 캐시 내용은 중요한 정보로 보호되어야합니다. 프록시 구현자는 디자인 및 코딩 결정, 프록시 운영자에게 제공하는 구성 옵션 (특히 기본 구성)에 대한 개인 정보 보호 및 보안 영향을 고려해야합니다. 대리 사용자는 대리를 운영하는 사람들보다 신뢰가 없다는 것을 알고 있어야합니다. HTTP 자체는이 문제를 해결할 수 없습니다. 암호화의 신중한 사용적절한 경우 광범위한 보안 및 개인 정보 공격으로부터 보호하기에 충분할 수 있습니다. 이러한 암호화는 HTTP / 1.1 사양의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="0385baee4e5a7514e39184b6448baf26de0bf842" translate="yes" xml:space="preserve">
          <source>Bypassing additional restrictions</source>
          <target state="translated">Bypassing additional restrictions</target>
        </trans-unit>
        <trans-unit id="3dfb40a9e84e63716a4b33d9963c4cfd678075a5" translate="yes" xml:space="preserve">
          <source>Byte Ranges (RFC 7233)</source>
          <target state="translated">바이트 범위 (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="b18368c56eb40788963923a6e1129947a0d58087" translate="yes" xml:space="preserve">
          <source>C-Shell script</source>
          <target state="translated">C 쉘 스크립트</target>
        </trans-unit>
        <trans-unit id="6e288959d3443bcec62386f7d9014542f6872829" translate="yes" xml:space="preserve">
          <source>CONNECT</source>
          <target state="translated">CONNECT</target>
        </trans-unit>
        <trans-unit id="2600bf1e8e192e1bd65ac3bc3a4d82977f60d6da" translate="yes" xml:space="preserve">
          <source>CONNECT (RFC 7231)</source>
          <target state="translated">연결 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="3f06f1ede16af06a408e9c55accedff143ec05ac" translate="yes" xml:space="preserve">
          <source>COOP will process-isolate your document and potential attackers can't access to your global object if they were opening it in a popup, preventing a set of cross-origin attacks dubbed &lt;a href=&quot;https://github.com/xsleaks/xsleaks&quot;&gt;XS-Leaks&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58b0c89f90f23a658ff74ef5bd072768c76288f7" translate="yes" xml:space="preserve">
          <source>CORP is an additional layer of protection beyond the default &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;. Cross-Origin Resource Policy complements &lt;a href=&quot;https://fetch.spec.whatwg.org/#corb&quot;&gt;Cross-Origin Read Blocking&lt;/a&gt; (CORB), which is a mechanism to prevent some cross-origin reads by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2139aadec237bbecb581e62932f94bc3bce7a704" translate="yes" xml:space="preserve">
          <source>CORS</source>
          <target state="translated">CORS</target>
        </trans-unit>
        <trans-unit id="6296a1fd2a34552fbb648aabe29411711a0e4595" translate="yes" xml:space="preserve">
          <source>CORS and caching</source>
          <target state="translated">CORS 및 캐싱</target>
        </trans-unit>
        <trans-unit id="3c63268612970c5bd579c70dbeed257045fe1f70" translate="yes" xml:space="preserve">
          <source>CORS enabled image</source>
          <target state="translated">CORS 가능 이미지</target>
        </trans-unit>
        <trans-unit id="e825c1a70b304027f50005fcb1118744bfcdf168" translate="yes" xml:space="preserve">
          <source>CORS error messages</source>
          <target state="translated">CORS 오류 메시지</target>
        </trans-unit>
        <trans-unit id="184d3111cdadf6b3fad8c042206c94ffd04e65c3" translate="yes" xml:space="preserve">
          <source>CORS errors</source>
          <target state="translated">CORS 오류</target>
        </trans-unit>
        <trans-unit id="d1cb428716c692d19e9dc06754cff0043e662a41" translate="yes" xml:space="preserve">
          <source>CORS failures result in errors, but for security reasons, specifics about the error &lt;em&gt;are not available to JavaScript&lt;/em&gt;. All the code knows is that an error occurred. The only way to determine what specifically went wrong is to look at the browser's console for details.</source>
          <target state="translated">CORS failures result in errors, but for security reasons, specifics about the error &lt;em&gt;are not available to JavaScript&lt;/em&gt;. All the code knows is that an error occurred. The only way to determine what specifically went wrong is to look at the browser's console for details.</target>
        </trans-unit>
        <trans-unit id="e389a185748256670e3bef3e9d485d4db6698009" translate="yes" xml:space="preserve">
          <source>CORS failures result in errors, but for security reasons, specifics about what went wrong &lt;em&gt;are not available to JavaScript code&lt;/em&gt;. All the code knows is that an error occurred. The only way to determine what specifically went wrong is to look at the browser's console for details.</source>
          <target state="translated">CORS 실패로 인해 오류가 발생하지만 보안상의 이유로 잘못된 사항에 대한 세부 사항 &lt;em&gt;을 JavaScript 코드에서 사용할 수 없습니다&lt;/em&gt; . 모든 코드는 오류가 발생했다는 것을 알고 있습니다. 구체적으로 무엇이 잘못되었는지 확인하는 유일한 방법은 브라우저 콘솔에서 자세한 내용을 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="de24c9d37107bb00fdf3a04f2c2a9d24eabcbabc" translate="yes" xml:space="preserve">
          <source>CORS introduction</source>
          <target state="translated">CORS 소개</target>
        </trans-unit>
        <trans-unit id="ee0eba3ae2bb3a8277a088b3fe2cba0700041b16" translate="yes" xml:space="preserve">
          <source>CORS settings attributes</source>
          <target state="translated">CORS 설정 속성</target>
        </trans-unit>
        <trans-unit id="089d646aeb28f1767e0d39506004c44f044e2a50" translate="yes" xml:space="preserve">
          <source>CORS-safelisted request header</source>
          <target state="translated">CORS-safelisted request header</target>
        </trans-unit>
        <trans-unit id="c658a0ab02da27fa9bc91475d5f929983201d0e9" translate="yes" xml:space="preserve">
          <source>CORS-safelisted request-header</source>
          <target state="translated">CORS 안전 요청 헤더</target>
        </trans-unit>
        <trans-unit id="303b72d3bf7642992ec9938ae19c4e19cbd5022d" translate="yes" xml:space="preserve">
          <source>CORS-safelisted response header</source>
          <target state="translated">CORS-safelisted response header</target>
        </trans-unit>
        <trans-unit id="4822cee4b44a5acfdf824aef5c202c725aa2e1ef" translate="yes" xml:space="preserve">
          <source>CORS-safelisted response-header</source>
          <target state="translated">CORS 허용 응답 헤더</target>
        </trans-unit>
        <trans-unit id="3115498a58c30161e8334af0606a41f44c318e04" translate="yes" xml:space="preserve">
          <source>CSP</source>
          <target state="translated">CSP</target>
        </trans-unit>
        <trans-unit id="70771af22a8b356fbf094cdf8ec696e798056732" translate="yes" xml:space="preserve">
          <source>CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive</source>
          <target state="translated">CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt; 지시어</target>
        </trans-unit>
        <trans-unit id="44f87a469d5fa9f5e3c9a3ab2c29c19df8341c51" translate="yes" xml:space="preserve">
          <source>CSP &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt; directive</source>
          <target state="translated">CSP &lt;a href=&quot;content-security-policy/upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt; 지시문</target>
        </trans-unit>
        <trans-unit id="2e0d3366da966d21d7a419c2ed0bbe7fe3d112f6" translate="yes" xml:space="preserve">
          <source>CSP Level 2 frame-ancestors directive</source>
          <target state="translated">CSP 레벨 2 프레임 조상 지시문</target>
        </trans-unit>
        <trans-unit id="d9132b00c8144355d2ffb30916581bd6454aef63" translate="yes" xml:space="preserve">
          <source>CSP allows multiple policies being specified for a resource, including via the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header, the &lt;a href=&quot;content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header and a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">CSP를 통해 &lt;code&gt;Content-Security-Policy&lt;/code&gt; 헤더, &lt;a href=&quot;content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt; 헤더 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 포함하여 리소스에 대해 여러 정책을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84514b55cad8a4471776e8261e9056e00bb80eff" translate="yes" xml:space="preserve">
          <source>CSP directives</source>
          <target state="translated">CSP 지시어</target>
        </trans-unit>
        <trans-unit id="6edf30c08fbe221348e45d46487682ad464890a5" translate="yes" xml:space="preserve">
          <source>CSP directives (&lt;a href=&quot;https://www.w3.org/TR/CSP/#csp-directives&quot;&gt;https://www.w3.org/TR/CSP/#csp-directives&lt;/a&gt;):</source>
          <target state="translated">CSP directives (&lt;a href=&quot;https://www.w3.org/TR/CSP/#csp-directives&quot;&gt;https://www.w3.org/TR/CSP/#csp-directives&lt;/a&gt;):</target>
        </trans-unit>
        <trans-unit id="da26228b4f698331031c5864aacaf5b9f95766d7" translate="yes" xml:space="preserve">
          <source>CSP for Web Workers</source>
          <target state="translated">CSP for Web Workers</target>
        </trans-unit>
        <trans-unit id="612d537b7ed50a4dda4dafd9890db5ab966fe8e6" translate="yes" xml:space="preserve">
          <source>CSP in Web Workers</source>
          <target state="translated">CSP in Web Workers</target>
        </trans-unit>
        <trans-unit id="ac7e232a207938fbc334d7ae81fd9271bdea2b5f" translate="yes" xml:space="preserve">
          <source>CSP in workers</source>
          <target state="translated">근로자의 CSP</target>
        </trans-unit>
        <trans-unit id="62becf9c2b19df7737b78178e6297a23a4286119" translate="yes" xml:space="preserve">
          <source>CSP is designed to be fully backward compatible (except CSP version 2 where there are some explicitly-mentioned inconsistencies in backward compatibility; more details &lt;a href=&quot;https://www.w3.org/TR/CSP2&quot;&gt;here&lt;/a&gt; section 1.1). Browsers that don't support it still work with servers that implement it, and vice-versa: browsers that don't support CSP simply ignore it, functioning as usual, defaulting to the standard same-origin policy for web content. If the site doesn't offer the CSP header, browsers likewise use the standard &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;.</source>
          <target state="translated">CSP는 완벽하게 역 호환이 가능하도록 설계되어있다 (이전 버전과의 호환성에 일부 명시 적으로 언급 한 불일치가 CSP 버전 2를 제외하고, 자세한 내용은 &lt;a href=&quot;https://www.w3.org/TR/CSP2&quot;&gt;여기&lt;/a&gt; 1.1 절). 이를 지원하지 않는 브라우저는 여전히이를 구현하는 서버에서 작동하며 그 반대도 마찬가지입니다. CSP를 지원하지 않는 브라우저는이를 무시하고 평소와 같이 작동하며 기본적으로 웹 컨텐츠에 대한 표준 동일 출처 정책으로 기본 설정됩니다. 사이트에서 CSP 헤더를 제공하지 않으면 브라우저도 마찬가지로 표준 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;동일 출처 정책을 사용&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9c066fd6908e5e3d0bb62d17e654cbfe8a428f91" translate="yes" xml:space="preserve">
          <source>CSP makes it possible for server administrators to reduce or eliminate the vectors by which XSS can occur by specifying the domains that the browser should consider to be valid sources of executable scripts. A CSP compatible browser will then only execute scripts loaded in source files received from those allowlisted domains, ignoring all other script (including inline scripts and event-handling HTML attributes).</source>
          <target state="translated">CSP makes it possible for server administrators to reduce or eliminate the vectors by which XSS can occur by specifying the domains that the browser should consider to be valid sources of executable scripts. A CSP compatible browser will then only execute scripts loaded in source files received from those allowlisted domains, ignoring all other script (including inline scripts and event-handling HTML attributes).</target>
        </trans-unit>
        <trans-unit id="cc54f753bc7cbbc002ef53de42786ebf31429cfa" translate="yes" xml:space="preserve">
          <source>CSP makes it possible for server administrators to reduce or eliminate the vectors by which XSS can occur by specifying the domains that the browser should consider to be valid sources of executable scripts. A CSP compatible browser will then only execute scripts loaded in source files received from those whitelisted domains, ignoring all other script (including inline scripts and event-handling HTML attributes).</source>
          <target state="translated">CSP를 통해 서버 관리자는 브라우저가 실행 가능한 스크립트의 유효한 소스로 간주해야하는 도메인을 지정하여 XSS가 발생할 수있는 벡터를 줄이거 나 없앨 수 있습니다. 그러면 CSP 호환 브라우저는 허용 된 도메인에서받은 소스 파일에로드 된 스크립트 만 실행하며 다른 모든 스크립트 (인라인 스크립트 및 이벤트 처리 HTML 속성 포함)는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="7031a0ce63915761c940ed51b1837a242dbd3b4b" translate="yes" xml:space="preserve">
          <source>CSP version</source>
          <target state="translated">CSP 버전</target>
        </trans-unit>
        <trans-unit id="a3d4a5f94061540e9f0aa3594fa2f993bb976f3b" translate="yes" xml:space="preserve">
          <source>CSP: base-uri</source>
          <target state="translated">CSP : 기본 URI</target>
        </trans-unit>
        <trans-unit id="e1f387bd5a0bc1c97fc48409c2910b8698c8640e" translate="yes" xml:space="preserve">
          <source>CSP: block-all-mixed-content</source>
          <target state="translated">CSP : 모든 콘텐츠 혼합</target>
        </trans-unit>
        <trans-unit id="b25eb56df44cb67b582b21cd3edbd78acfb7b3e7" translate="yes" xml:space="preserve">
          <source>CSP: child-src</source>
          <target state="translated">CSP : child-src</target>
        </trans-unit>
        <trans-unit id="d8d4703b593508b27eaeff8d0aebcd15f991e8e2" translate="yes" xml:space="preserve">
          <source>CSP: connect-src</source>
          <target state="translated">CSP : connect-src</target>
        </trans-unit>
        <trans-unit id="68907bfebcb9f7aaac284a06b0682cb8062e8905" translate="yes" xml:space="preserve">
          <source>CSP: default-src</source>
          <target state="translated">CSP : default-src</target>
        </trans-unit>
        <trans-unit id="33201263305688f8d0319035bf86905e02a74b2e" translate="yes" xml:space="preserve">
          <source>CSP: font-src</source>
          <target state="translated">CSP : font-src</target>
        </trans-unit>
        <trans-unit id="288f4f31fbc4626f98b2f869fd485b9fad754b76" translate="yes" xml:space="preserve">
          <source>CSP: form-action</source>
          <target state="translated">CSP : 양식 동작</target>
        </trans-unit>
        <trans-unit id="1110c66ccba3f4594386963f17efd01ebfc1cd32" translate="yes" xml:space="preserve">
          <source>CSP: frame-ancestors</source>
          <target state="translated">CSP : 프레임 조상</target>
        </trans-unit>
        <trans-unit id="a9d7881b7f2e872886dea3318b9ec4ad54690900" translate="yes" xml:space="preserve">
          <source>CSP: frame-src</source>
          <target state="translated">CSP : 프레임 -SRC</target>
        </trans-unit>
        <trans-unit id="21056b59bbdeaabbcbf48e5b78e6825df16fd152" translate="yes" xml:space="preserve">
          <source>CSP: img-src</source>
          <target state="translated">CSP : img-src</target>
        </trans-unit>
        <trans-unit id="5b7bbbea8fbb911ad61a95926c52038e17270734" translate="yes" xml:space="preserve">
          <source>CSP: manifest-src</source>
          <target state="translated">CSP : manifest-src</target>
        </trans-unit>
        <trans-unit id="216739951c2911845bfa3c58a3e1759ef762351f" translate="yes" xml:space="preserve">
          <source>CSP: media-src</source>
          <target state="translated">CSP : 미디어 SRC</target>
        </trans-unit>
        <trans-unit id="d27ff0f1654b7502333c88f9af77e32304f80495" translate="yes" xml:space="preserve">
          <source>CSP: navigate-to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b0f2d6ea1745b227865a7908c705926a5818865" translate="yes" xml:space="preserve">
          <source>CSP: object-src</source>
          <target state="translated">CSP : object-src</target>
        </trans-unit>
        <trans-unit id="9310170277ea799be8285b0064422067334219b7" translate="yes" xml:space="preserve">
          <source>CSP: plugin-types</source>
          <target state="translated">CSP : 플러그인 유형</target>
        </trans-unit>
        <trans-unit id="caf04f49fb12869875e5809bb62ca18f1dc04233" translate="yes" xml:space="preserve">
          <source>CSP: prefetch-src</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f55d98b5a3ac85d047f911ee4a486f34144e3d" translate="yes" xml:space="preserve">
          <source>CSP: referrer</source>
          <target state="translated">CSP : 리퍼러</target>
        </trans-unit>
        <trans-unit id="a53be58aafa7031586553deadc48190f849f218d" translate="yes" xml:space="preserve">
          <source>CSP: report-to</source>
          <target state="translated">CSP :보고</target>
        </trans-unit>
        <trans-unit id="865f9627c1b6ca237d57e68fc76c695bc3af6d64" translate="yes" xml:space="preserve">
          <source>CSP: report-uri</source>
          <target state="translated">CSP : 보고서 URI</target>
        </trans-unit>
        <trans-unit id="360c612795c5fa6ec239445c2a3549cdd177ae8f" translate="yes" xml:space="preserve">
          <source>CSP: require-sri-for</source>
          <target state="translated">CSP : 요구 사항</target>
        </trans-unit>
        <trans-unit id="5b9a9a7b030ff638c13fe5252ac9605de9bd9a33" translate="yes" xml:space="preserve">
          <source>CSP: require-trusted-types-for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95233e49e595781c9ba6c45123a969ceace0209c" translate="yes" xml:space="preserve">
          <source>CSP: sandbox</source>
          <target state="translated">CSP : 샌드 박스</target>
        </trans-unit>
        <trans-unit id="746f3a678a7fdd2c8e56ab69cf9f85ffa266928d" translate="yes" xml:space="preserve">
          <source>CSP: script-src</source>
          <target state="translated">CSP : 스크립트 -SRC</target>
        </trans-unit>
        <trans-unit id="74e0def20d9663d6b9402691f4938dcedcc472f5" translate="yes" xml:space="preserve">
          <source>CSP: script-src-attr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11c49dd9c01c9002a8c1ca0b0e20c73e1ea7e83d" translate="yes" xml:space="preserve">
          <source>CSP: script-src-elem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="073f20d15a570fd6d41695506e3f4b44db4ec9c8" translate="yes" xml:space="preserve">
          <source>CSP: style-src</source>
          <target state="translated">CSP : 스타일 -SRC</target>
        </trans-unit>
        <trans-unit id="976a77859491cd1ef47e641e7311bb890156672f" translate="yes" xml:space="preserve">
          <source>CSP: style-src-attr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f967c2c8d4a89149755f714e13243120974c7c" translate="yes" xml:space="preserve">
          <source>CSP: style-src-elem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef6a35189958c52fc4d11428c18472eb8ebbc1b7" translate="yes" xml:space="preserve">
          <source>CSP: trusted-types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdec421ab6d7add012ba02e55c66584a25b4ae24" translate="yes" xml:space="preserve">
          <source>CSP: upgrade-insecure-requests</source>
          <target state="translated">CSP : 업그레이드 비보안 요청</target>
        </trans-unit>
        <trans-unit id="fb8f32fe79e286807b14bcfd102e8d5b1bd01893" translate="yes" xml:space="preserve">
          <source>CSP: worker-src</source>
          <target state="translated">CSP : 작업자 -SRC</target>
        </trans-unit>
        <trans-unit id="63b89c4cbe4e07b5d318b0db30585680356a57b5" translate="yes" xml:space="preserve">
          <source>CSS &lt;code&gt;url()&lt;/code&gt;</source>
          <target state="translated">CSS &lt;code&gt;url()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7be6c2d6b0a547250410b1a2318dda4537f080e3" translate="yes" xml:space="preserve">
          <source>CSS @media feature &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-reduced-data&quot;&gt;prefers-reduced-data&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b735f2f9a96efb6f279ab57aab6386d338a0c8dc" translate="yes" xml:space="preserve">
          <source>CSS Shapes from images.</source>
          <target state="translated">CSS Shapes from images.</target>
        </trans-unit>
        <trans-unit id="cc5b4a629abbfbd5eccc6eedfa9f028a8215b669" translate="yes" xml:space="preserve">
          <source>CSS can fetch resources referenced from stylesheets. These resources are following a referrer policy as well.</source>
          <target state="translated">CSS는 스타일 시트에서 참조 된 리소스를 가져올 수 있습니다. 이러한 리소스는 리퍼러 정책도 준수합니다.</target>
        </trans-unit>
        <trans-unit id="428ac0eae6ca052836b3b2ffa97a6afe49df6977" translate="yes" xml:space="preserve">
          <source>CSS can fetch resources referenced from stylesheets. These resources follow a referrer policy as well:</source>
          <target state="translated">CSS can fetch resources referenced from stylesheets. These resources follow a referrer policy as well:</target>
        </trans-unit>
        <trans-unit id="f7417538e496bd203aa442ce377a765b360b5ad7" translate="yes" xml:space="preserve">
          <source>CSS files</source>
          <target state="translated">CSS 파일</target>
        </trans-unit>
        <trans-unit id="b7a02370a133e45105b3a6f51aad72447007c06f" translate="yes" xml:space="preserve">
          <source>CSS files used to style a Web page &lt;strong&gt;must&lt;/strong&gt; be sent with &lt;code&gt;text/css&lt;/code&gt;. If a server doesn't recognize the &lt;code&gt;.css&lt;/code&gt; suffix for CSS files, it may send them with &lt;code&gt;text/plain&lt;/code&gt; or &lt;code&gt;application/octet-stream&lt;/code&gt; MIME types. If so, they won't be recognized as CSS by most browsers and will be ignored.</source>
          <target state="translated">CSS files used to style a Web page &lt;strong&gt;must&lt;/strong&gt; be sent with &lt;code&gt;text/css&lt;/code&gt; . If a server doesn't recognize the &lt;code&gt;.css&lt;/code&gt; suffix for CSS files, it may send them with &lt;code&gt;text/plain&lt;/code&gt; or &lt;code&gt;application/octet-stream&lt;/code&gt; MIME types. If so, they won't be recognized as CSS by most browsers and will be ignored.</target>
        </trans-unit>
        <trans-unit id="c7a58e854c19a4742126d3d6571cf7bf2c94f204" translate="yes" xml:space="preserve">
          <source>CSS files used to style a Web page&lt;strong&gt; must&lt;/strong&gt; be sent with &lt;code&gt;text/css&lt;/code&gt;. If a server doesn't recognize the &lt;code&gt;.css&lt;/code&gt; suffix for CSS files, it may send them with &lt;code&gt;text/plain&lt;/code&gt; or &lt;code&gt;application/octet-stream&lt;/code&gt; MIME types. If so, they won't be recognized as CSS by most browsers and will be ignored.</source>
          <target state="translated">웹 페이지의 스타일을 지정하는 데 사용되는 CSS 파일 은 &lt;code&gt;text/css&lt;/code&gt; 와 함께 전송 &lt;strong&gt;되어야합니다&lt;/strong&gt; . 서버가 CSS 파일 의 &lt;code&gt;.css&lt;/code&gt; 접미사를 인식하지 못하면 &lt;code&gt;text/plain&lt;/code&gt; 또는 &lt;code&gt;application/octet-stream&lt;/code&gt; MIME 유형으로 보낼 수 있습니다. 그렇다면 대부분의 브라우저에서 CSS로 인식되지 않으므로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1964934d77bf5d32bc29b25c72e40d0a04b94a48" translate="yes" xml:space="preserve">
          <source>CT requirements can be satisfied via any one of the following mechanisms:</source>
          <target state="translated">CT requirements can be satisfied via any one of the following mechanisms:</target>
        </trans-unit>
        <trans-unit id="b97a250a6d2c0f59f2f4c22e8e9f5dd5b39d8624" translate="yes" xml:space="preserve">
          <source>Cache but revalidate</source>
          <target state="translated">Cache but revalidate</target>
        </trans-unit>
        <trans-unit id="c9387eaae83736c3d69453fd21bd568dec8f4524" translate="yes" xml:space="preserve">
          <source>Cache handling of a response to a conditional request is dependent
   upon its status code:

   o  A 304 (Not Modified) response status code indicates that the
      stored response can be updated and reused; see &lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;.

   o  A full response (i.e., one with a payload body) indicates that
      none of the stored responses nominated in the conditional request
      is suitable.  Instead, the cache MUST use the full response to
      satisfy the request and MAY replace the stored response(s).

   o  However, if a cache receives a 5xx (Server Error) response while
      attempting to validate a response, it can either forward this
      response to the requesting client, or act as if the server failed
      to respond.  In the latter case, the cache MAY send a previously
      stored response (see &lt;a href=&quot;#section-4.2.4&quot;&gt;Section 4.2.4&lt;/a&gt;).</source>
          <target state="translated">조건부 요청에 대한 응답의 캐시 처리는 상태 코드에 따라 다릅니다. o 304 (수정되지 않음) 응답 상태 코드는 저장된 응답을 업데이트하고 재사용 할 수 있음을 나타냅니다. &lt;a href=&quot;#section-4.3.4&quot;&gt;섹션 4.3.4&lt;/a&gt; 참조 . o 전체 응답 (즉, 페이로드 본문이있는 응답)은 조건부 요청에 지정된 저장된 응답이 적합하지 않음을 나타냅니다. 대신, 캐시는 요청을 충족시키기 위해 전체 응답을 사용해야하며 저장된 응답을 대체 할 수 있습니다. o 그러나 응답의 유효성을 검증하는 중에 캐시가 5xx (서버 오류) 응답을 수신하면 요청 응답 클라이언트에게이 응답을 전달하거나 서버가 응답하지 않은 것처럼 작동 할 수 있습니다. 후자의 경우, 캐시는 이전에 저장된 응답을 보낼 수 있습니다&lt;a href=&quot;#section-4.2.4&quot;&gt;섹션 4.2.4&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9eca146b7d059bac1fffb373a3b4ac5a46895065" translate="yes" xml:space="preserve">
          <source>Cache refresh: this indicates that the cache value is still fresh and can be used.</source>
          <target state="translated">캐시 새로 고침 : 캐시 값이 여전히 최신 상태이며 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="797e92b9fd4173be50b6906927ba56a7e66b9d27" translate="yes" xml:space="preserve">
          <source>Cache request directives</source>
          <target state="translated">캐시 요청 지시문</target>
        </trans-unit>
        <trans-unit id="0b943ff4cafdda6a82e806c4186ad1f27a30b226" translate="yes" xml:space="preserve">
          <source>Cache response directives</source>
          <target state="translated">캐시 응답 지시문</target>
        </trans-unit>
        <trans-unit id="363657bc3c95ae010a3ed0bae48a02dfa27c59c4" translate="yes" xml:space="preserve">
          <source>Cache results of a preflight request for 10 minutes:</source>
          <target state="translated">프리 플라이트 요청 결과를 10 분 동안 캐시합니다.</target>
        </trans-unit>
        <trans-unit id="0426eb019de93cd2ae1c3a3a04b09dc6cfd746ab" translate="yes" xml:space="preserve">
          <source>Cache static content: offload the web servers by caching static content like pictures,</source>
          <target state="translated">정적 컨텐츠 캐시 : 그림과 같은 정적 컨텐츠를 캐싱하여 웹 서버를 오프로드하십시오.</target>
        </trans-unit>
        <trans-unit id="8cc8d7aabbcac8d512fa7176f44889e337cb29b2" translate="yes" xml:space="preserve">
          <source>Cache update</source>
          <target state="translated">캐시 업데이트</target>
        </trans-unit>
        <trans-unit id="f39c0f09e8619679ee8854f8b7b8e45d8271d16d" translate="yes" xml:space="preserve">
          <source>Cache validation</source>
          <target state="translated">캐시 유효성 검사</target>
        </trans-unit>
        <trans-unit id="9b09c51972b24aaf8bff4e23301b40da54c025b6" translate="yes" xml:space="preserve">
          <source>Cache-Control</source>
          <target state="translated">Cache-Control</target>
        </trans-unit>
        <trans-unit id="96c175aa287942740a4c9dc0851f228f568c2dd0" translate="yes" xml:space="preserve">
          <source>Cache-Control (RFC 2616)</source>
          <target state="translated">캐시 제어 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="db46bd114028441fc2cb90df358efa899df9e03d" translate="yes" xml:space="preserve">
          <source>Cache-Control (RFC 7234)</source>
          <target state="translated">캐시 제어 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="f831d9e40838da8be7663f96e7bf5e81e81f1527" translate="yes" xml:space="preserve">
          <source>Cacheability</source>
          <target state="translated">Cacheability</target>
        </trans-unit>
        <trans-unit id="ab9c8d4b22f42d6e20f2de04cee4a87194c9b2ff" translate="yes" xml:space="preserve">
          <source>Cacheable</source>
          <target state="translated">Cacheable</target>
        </trans-unit>
        <trans-unit id="367eb2cade8f9a82f981b9ecbd24bcbcccc4234d" translate="yes" xml:space="preserve">
          <source>Cacheable Methods (RFC 7231)</source>
          <target state="translated">캐시 가능한 방법 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="60790f7c84170a8b87051d7e857118ffeb0465ee" translate="yes" xml:space="preserve">
          <source>Caching</source>
          <target state="translated">Caching</target>
        </trans-unit>
        <trans-unit id="6d4faa9c38ae0bea36b2a77a74f1c5565404a706" translate="yes" xml:space="preserve">
          <source>Caching FAQ</source>
          <target state="translated">캐싱 FAQ</target>
        </trans-unit>
        <trans-unit id="c30dddf76b8532fde16158f240307de27191ec53" translate="yes" xml:space="preserve">
          <source>Caching Tutorial &amp;ndash; Mark Nottingham</source>
          <target state="translated">캐싱 튜토리얼 &amp;ndash; Mark Nottingham</target>
        </trans-unit>
        <trans-unit id="e7969efad7a9997c2c32dfba8ba0fa3f7863eaa5" translate="yes" xml:space="preserve">
          <source>Caching Tutorial for Web Authors and Webmasters</source>
          <target state="translated">Caching Tutorial for Web Authors and Webmasters</target>
        </trans-unit>
        <trans-unit id="0b4f6bae82cc7d9cc7d1831819fc166adba3c40b" translate="yes" xml:space="preserve">
          <source>Caching directives have the following rules to be valid:</source>
          <target state="translated">Caching directives have the following rules to be valid:</target>
        </trans-unit>
        <trans-unit id="0587c95421ffd96422e6ce52f99b0eeb12897612" translate="yes" xml:space="preserve">
          <source>Caching in HTTP (RFC 2616)</source>
          <target state="translated">HTTP 캐싱 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="12274da356087ef702ccbb200cdfa705f2a6cb21" translate="yes" xml:space="preserve">
          <source>Caching is a technique that stores a copy of a given resource and serves it back when requested. When a web cache has a requested resource in its store, it intercepts the request and returns its copy instead of re-downloading from the originating server. This achieves several goals: it eases the load of the server that doesn&amp;rsquo;t need to serve all clients itself, and it improves performance by being closer to the client, i.e., it takes less time to transmit the resource back. For a web site, it is a major component in achieving high performance. On the other side, it has to be configured properly as not all resources stay identical forever: it is important to cache a resource only until it changes, not longer.</source>
          <target state="translated">캐싱은 주어진 리소스의 복사본을 저장하고 요청시 다시 서비스하는 기술입니다. 웹 캐시에 해당 저장소에 요청 된 리소스가 있으면 요청을 차단하고 원래 서버에서 다시 다운로드하는 대신 복사본을 반환합니다. 이를 통해 여러 가지 목표를 달성 할 수 있습니다. 즉, 모든 클라이언트 자체에 서비스를 제공 할 필요가없는 서버의로드를 줄이고, 클라이언트와 더 가까워 지므로 성능을 향상시킵니다. 즉, 리소스를 다시 전송하는 데 걸리는 시간이 줄어 듭니다. 웹 사이트의 경우 고성능을 달성하는 데있어 주요 구성 요소입니다. 반면에 모든 리소스가 영원히 동일하게 유지되는 것은 아니므로 올바르게 구성해야합니다. 더 이상 변경되지 않을 때까지만 리소스를 캐시하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="d5bd9f8c4cb307c4c859ece3e85c3287fab9c02d" translate="yes" xml:space="preserve">
          <source>Caching is very important for fast Web sites. This article describes different methods of caching and how to use HTTP Headers to control them.</source>
          <target state="translated">캐싱은 빠른 웹 사이트에 매우 중요합니다. 이 문서에서는 다양한 캐싱 방법과 HTTP 헤더를 사용하여이를 캐싱하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="948ba29270deb9f483242162487c780bcfdc8dba" translate="yes" xml:space="preserve">
          <source>Caching of unchanged resources</source>
          <target state="translated">변경되지 않은 리소스 캐싱</target>
        </trans-unit>
        <trans-unit id="23206d16033b30654e4d04b8e38733f9a9b711e1" translate="yes" xml:space="preserve">
          <source>Caching static assets</source>
          <target state="translated">정적 자산 캐싱</target>
        </trans-unit>
        <trans-unit id="224012a44d1a3dcbedc904993d8d0726b013bed5" translate="yes" xml:space="preserve">
          <source>Caching-related headers that are sent along with this response should be taken care of, as a 503 status is often a temporary condition and responses shouldn't usually be cached.</source>
          <target state="translated">이 응답과 함께 전송되는 캐싱 관련 헤더는 503 상태가 일시적인 조건이므로 응답을 캐시하지 않기 때문에주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="72bc7dfdbfb35fbe7d280800db5164dcd1988d57" translate="yes" xml:space="preserve">
          <source>Calculating Secondary Keys with Vary (RFC 7234)</source>
          <target state="translated">가변으로 2 차 키 계산 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="4da9c9af9631e294961d5a16fdc681ca3d84f508" translate="yes" xml:space="preserve">
          <source>Camera</source>
          <target state="translated">Camera</target>
        </trans-unit>
        <trans-unit id="1c8974e3fdbd4a7f871b765b73b10e7d5c3e086c" translate="yes" xml:space="preserve">
          <source>Camino on Mac</source>
          <target state="translated">Mac의 카미노</target>
        </trans-unit>
        <trans-unit id="34df0028992d6ae22f580333583afab1e0e37c34" translate="yes" xml:space="preserve">
          <source>Can you spot the mistake? Stylesheets are allowed to be loaded only from &lt;code&gt;cdn.example.com&lt;/code&gt;, yet the website tries to load one from its own origin (&lt;code&gt;http://example.com&lt;/code&gt;). A browser capable of enforcing CSP would send the following violation report as a POST request to &lt;code&gt;http://example.com/_/csp-reports&lt;/code&gt;, when the document is visited:</source>
          <target state="translated">Can you spot the mistake? Stylesheets are allowed to be loaded only from &lt;code&gt;cdn.example.com&lt;/code&gt; , yet the website tries to load one from its own origin ( &lt;code&gt;http://example.com&lt;/code&gt; ). A browser capable of enforcing CSP would send the following violation report as a POST request to &lt;code&gt;http://example.com/_/csp-reports&lt;/code&gt; , when the document is visited:</target>
        </trans-unit>
        <trans-unit id="2f86269acd3e77cefb32ddc78f8c4c6c9bd506e6" translate="yes" xml:space="preserve">
          <source>Can you spot the mistake? Stylesheets are only allowed to be loaded from &lt;code&gt;cdn.example.com&lt;/code&gt;, yet the website tries to load one from its own origin (&lt;code&gt;http://example.com&lt;/code&gt;). A browser capable of enforcing CSP will send the following violation report as a POST request to &lt;code&gt;&lt;a href=&quot;http://example.com/_/csp-reports&quot;&gt;http://example.com/_/csp-reports&lt;/a&gt;&lt;/code&gt;, when the document is visited:</source>
          <target state="translated">실수를 알아낼 수 있습니까? 스타일 시트는 &lt;code&gt;cdn.example.com&lt;/code&gt; 에서만로드 할 수 있지만 웹 사이트는 고유 한 원점 ( &lt;code&gt;http://example.com&lt;/code&gt; ) 에서로드하려고합니다 . CSP를 적용 할 수있는 브라우저 는 문서를 방문 할 때 다음 위반 보고서를 POST 요청으로 &lt;code&gt;&lt;a href=&quot;http://example.com/_/csp-reports&quot;&gt;http://example.com/_/csp-reports&lt;/a&gt;&lt;/code&gt; 에 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="8b35fa85102875260c5079cd9bdec0d2fdc2ee7d" translate="yes" xml:space="preserve">
          <source>Can you spot the violation? Stylesheets are only allowed to be loaded from &lt;code&gt;cdn.example.com&lt;/code&gt;, yet the website tries to load one from its own origin (&lt;code&gt;http://example.com&lt;/code&gt;). A browser capable of enforcing CSP will send the following violation report as a POST request to &lt;code&gt;http://example.com/_/csp-reports&lt;/code&gt;, when the document is visited:</source>
          <target state="translated">위반 사항을 발견 할 수 있습니까? 스타일 시트는 &lt;code&gt;cdn.example.com&lt;/code&gt; 에서만로드 할 수 있지만 웹 사이트는 고유 한 원점 ( &lt;code&gt;http://example.com&lt;/code&gt; ) 에서로드하려고합니다 . CSP를 적용 할 수있는 브라우저 는 문서를 방문 할 때 다음 위반 보고서를 POST 요청으로 &lt;code&gt;http://example.com/_/csp-reports&lt;/code&gt; 에 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="c19fa848f8d18f6a6f2a50f399649151c43d2ccf" translate="yes" xml:space="preserve">
          <source>Candidate Recommendation</source>
          <target state="translated">후보 추천</target>
        </trans-unit>
        <trans-unit id="23538d20ac9108dc1735c5b220e319e9fe9ebfa3" translate="yes" xml:space="preserve">
          <source>Cascading Style Sheets (CSS)</source>
          <target state="translated">캐스 케이 딩 스타일 시트 (CSS)</target>
        </trans-unit>
        <trans-unit id="0b6458ff064d78bd1b35deea2f51916b09b5473f" translate="yes" xml:space="preserve">
          <source>Case-insensitive, but lowercase is recommended.</source>
          <target state="translated">Case-insensitive, but lowercase is recommended.</target>
        </trans-unit>
        <trans-unit id="aa1717d0e9589578b46ef62dc5cfe9cd1de83ba5" translate="yes" xml:space="preserve">
          <source>Category Documents contain lists of categories described using the
   &quot;atom:category&quot; element from the Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].
   Categories can also appear in Service Documents, where they indicate
   the categories allowed in a Collection (see &lt;a href=&quot;#section-8.3.6&quot;&gt;Section 8.3.6&lt;/a&gt;).

   Category Documents are identified with the &quot;application/atomcat+xml&quot;
   media type (see &lt;a href=&quot;#section-16.1&quot;&gt;Section 16.1&lt;/a&gt;).</source>
          <target state="translated">카테고리 문서에는 Atom Syndication Format [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ] 의 &quot;atom : category&quot;요소를 사용하여 설명 된 카테고리 목록이 포함되어 있습니다 . 카테고리는 또한 서비스 문서에 나타날 수 있으며, 여기서 컬렉션에서 허용되는 카테고리를 나타냅니다 ( &lt;a href=&quot;#section-8.3.6&quot;&gt;8.3.6 절&lt;/a&gt; 참조 ). 카테고리 문서는 &quot;application / atomcat + xml&quot;매체 유형으로 식별됩니다 ( &lt;a href=&quot;#section-16.1&quot;&gt;16.1 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4953a4d35c24e7592363ade77ff9bd38b491415d" translate="yes" xml:space="preserve">
          <source>Certain features depend on cross-origin isolation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3adf629209f8f370767ac9b58ec590a278a3655" translate="yes" xml:space="preserve">
          <source>Certain features like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer&quot;&gt;&lt;code&gt;SharedArrayBuffer&lt;/code&gt;&lt;/a&gt; objects or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Performance/now&quot;&gt;&lt;code&gt;Performance.now()&lt;/code&gt;&lt;/a&gt; with unthrottled timers are only available if your document has a COOP header with the value &lt;code&gt;same-origin&lt;/code&gt; value set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98cfdc8dc518c66839eb93c58f7c6441910d5d79" translate="yes" xml:space="preserve">
          <source>Change the default behavior of autoplay on mobile and third party videos.</source>
          <target state="translated">모바일 및 타사 비디오에서 자동 재생의 기본 동작을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="e97cb80f95cbab0c6a227b198b72f39726ca3006" translate="yes" xml:space="preserve">
          <source>Change the default values or options that control the feature behavior.</source>
          <target state="translated">기능 동작을 제어하는 ​​기본값 또는 옵션을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="98070d26bda6abfdd501e4b5389ac0c61c5c1549" translate="yes" xml:space="preserve">
          <source>Change the request such that it is a &lt;a href=&quot;#Simple_requests&quot;&gt;simple request&lt;/a&gt; that doesn&amp;rsquo;t cause a preflight</source>
          <target state="translated">Change the request such that it is a &lt;a href=&quot;#Simple_requests&quot;&gt;simple request&lt;/a&gt; that doesn&amp;rsquo;t cause a preflight</target>
        </trans-unit>
        <trans-unit id="8080157d68fc1aa058042192fc9b1007517bb764" translate="yes" xml:space="preserve">
          <source>Change the server-side behavior to avoid the preflight and/or to avoid the redirect</source>
          <target state="translated">Change the server-side behavior to avoid the preflight and/or to avoid the redirect</target>
        </trans-unit>
        <trans-unit id="811bf2bd6edd23474dfa0570cd89845010ee8135" translate="yes" xml:space="preserve">
          <source>Character encoding of HTTP authentication</source>
          <target state="translated">HTTP 인증의 문자 인코딩</target>
        </trans-unit>
        <trans-unit id="245374780def29c61ce1165c1fdbe13bc3583f38" translate="yes" xml:space="preserve">
          <source>Check the &lt;a href=&quot;#Browser_compatibility&quot;&gt;Browser compatibility table&lt;/a&gt; carefully before using this in production.</source>
          <target state="translated">프로덕션 환경에서 사용하기 전에 &lt;a href=&quot;#Browser_compatibility&quot;&gt;브라우저 호환성 표를&lt;/a&gt; 주의 해서 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="de85527d64c40bc55991f2429578ed63d3ac01ed" translate="yes" xml:space="preserve">
          <source>Checking if a server supports partial requests</source>
          <target state="translated">서버가 부분 요청을 지원하는지 확인</target>
        </trans-unit>
        <trans-unit id="ffef88d017227b1ea1b9169e0335da32c5b6a9dd" translate="yes" xml:space="preserve">
          <source>Choosing between www and non-www URLs</source>
          <target state="translated">www와 www가 아닌 ​​URL 중에서 선택</target>
        </trans-unit>
        <trans-unit id="218e75c7a912404b048fff0747e40108873b6334" translate="yes" xml:space="preserve">
          <source>Chrome</source>
          <target state="translated">Chrome</target>
        </trans-unit>
        <trans-unit id="04c901a0daf91c2a0f3e8fdc0701d52f69dd276c" translate="yes" xml:space="preserve">
          <source>Chrome 59 and higher skips the &lt;a href=&quot;child-src&quot;&gt;&lt;code&gt;child-src&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">Chrome 59 이상은 &lt;a href=&quot;child-src&quot;&gt; &lt;code&gt;child-src&lt;/code&gt; &lt;/a&gt; 지시문을 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="4f8f8ffcc2cbf126c04a5b0120a393e971c34f1c" translate="yes" xml:space="preserve">
          <source>Chrome 59 and higher skips the deprecated &lt;code&gt;child-src&lt;/code&gt; directive.</source>
          <target state="translated">Chrome 59 이상은 더 이상 사용되지 않는 &lt;code&gt;child-src&lt;/code&gt; 지시문을 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="936b3a2c1e8b0dd5e471f5ddaa07ff52d2e26abf" translate="yes" xml:space="preserve">
          <source>Chrome UA string</source>
          <target state="translated">크롬 UA 문자열</target>
        </trans-unit>
        <trans-unit id="d099f88b010d4398cebebe8e633ffe4874c4aa01" translate="yes" xml:space="preserve">
          <source>Chrome for Android</source>
          <target state="translated">Android 용 Chrome</target>
        </trans-unit>
        <trans-unit id="63fa9dfaafef106782cff2f23fd6100812a2c815" translate="yes" xml:space="preserve">
          <source>Chrome has &lt;a href=&quot;https://www.chromestatus.com/feature/5021976655560704&quot;&gt;removed their XSS Auditor&lt;/a&gt;</source>
          <target state="translated">Chrome has &lt;a href=&quot;https://www.chromestatus.com/feature/5021976655560704&quot;&gt;removed their XSS Auditor&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06b23f33df74ac419800e0f9c00c1fee716262fb" translate="yes" xml:space="preserve">
          <source>Chrome, Edge, Firefox, Internet Explorer, Opera, Safari</source>
          <target state="translated">Chrome, Edge, Firefox, Internet Explorer, Opera, Safari</target>
        </trans-unit>
        <trans-unit id="0c61202a79a1fff40efdcb9dc2c09bb3207be4de" translate="yes" xml:space="preserve">
          <source>Chrome, Edge, Firefox, Opera</source>
          <target state="translated">Chrome, Edge, Firefox, Opera</target>
        </trans-unit>
        <trans-unit id="865e5314adc4c753b1de74b6801e82c3bba584f4" translate="yes" xml:space="preserve">
          <source>Chrome, Edge, Firefox, Opera, Safari</source>
          <target state="translated">Chrome, Edge, Firefox, Opera, Safari</target>
        </trans-unit>
        <trans-unit id="019a920351ae1cc253d801e3029fcb49f0363eb6" translate="yes" xml:space="preserve">
          <source>Chrome/xyz</source>
          <target state="translated">Chrome/xyz</target>
        </trans-unit>
        <trans-unit id="530e72f2ef34a9545e0a5330771934b72c420c79" translate="yes" xml:space="preserve">
          <source>Chrome/xyz or Chromium/xyz</source>
          <target state="translated">Chrome / xyz 또는 Chromium / xyz</target>
        </trans-unit>
        <trans-unit id="32166e83eed3818d45d2cbecbe2e6cf85528e265" translate="yes" xml:space="preserve">
          <source>Chromium</source>
          <target state="translated">Chromium</target>
        </trans-unit>
        <trans-unit id="be78db4800418a74118cb63d7fc3c7b519d7c030" translate="yes" xml:space="preserve">
          <source>Chromium (prior to v76) &lt;a href=&quot;https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=36&amp;amp;rcl=52002151773d8cd9ffc5f557cd7cc880fddcae3e&quot;&gt;caps at 10 minutes&lt;/a&gt; (600 seconds).</source>
          <target state="translated">Chromium (prior to v76) &lt;a href=&quot;https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=36&amp;amp;rcl=52002151773d8cd9ffc5f557cd7cc880fddcae3e&quot;&gt;caps at 10 minutes&lt;/a&gt; (600 seconds).</target>
        </trans-unit>
        <trans-unit id="20b80ad1d26c2f3aaa13597f08219cb16ea10fef" translate="yes" xml:space="preserve">
          <source>Chromium (starting in v76) &lt;a href=&quot;https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=31&amp;amp;rcl=49e7c0b4886cac1f3d09dc046bd528c9c811a0fa&quot;&gt;caps at 2 hours&lt;/a&gt; (7200 seconds).</source>
          <target state="translated">Chromium (starting in v76) &lt;a href=&quot;https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=31&amp;amp;rcl=49e7c0b4886cac1f3d09dc046bd528c9c811a0fa&quot;&gt;caps at 2 hours&lt;/a&gt; (7200 seconds).</target>
        </trans-unit>
        <trans-unit id="7817e5d6f503912e54b0784dc45d20aa97799b67" translate="yes" xml:space="preserve">
          <source>Chromium also specifies a default value of 5 seconds.</source>
          <target state="translated">Chromium also specifies a default value of 5 seconds.</target>
        </trans-unit>
        <trans-unit id="a00534e71fb83f1f72f13c598065c49858fefc4a" translate="yes" xml:space="preserve">
          <source>Chromium/xyz</source>
          <target state="translated">Chromium/xyz</target>
        </trans-unit>
        <trans-unit id="f2e3d3255876440830fb74bf171c1d2ece3388ed" translate="yes" xml:space="preserve">
          <source>Chromium: &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=615313&quot;&gt;Issue 615313&lt;/a&gt;</source>
          <target state="translated">크롬 : &lt;a href=&quot;https://bugs.chromium.org/p/chromium/issues/detail?id=615313&quot;&gt;문제 615313&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="02dae4314d1b02d0bfeeff3a285006bc4766d38a" translate="yes" xml:space="preserve">
          <source>Chunked encoding</source>
          <target state="translated">청크 인코딩</target>
        </trans-unit>
        <trans-unit id="0e13d13f96bc6fbff5ad281601f23302761c061e" translate="yes" xml:space="preserve">
          <source>Chunked encoding is useful when larger amounts of data are sent to the client and the total size of the response may not be known until the request has been fully processed. For example, when generating a large HTML table resulting from a database query or when transmitting large images. A chunked response looks like this:</source>
          <target state="translated">청크 인코딩은 더 많은 양의 데이터가 클라이언트로 전송 될 때 유용하며 요청이 완전히 처리 될 때까지 응답의 전체 크기를 알 수 없습니다. 예를 들어, 데이터베이스 쿼리로 인해 큰 HTML 테이블을 생성하거나 큰 이미지를 전송할 때. 청크 응답은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8220572e0102502603e5875887b5183212dd190a" translate="yes" xml:space="preserve">
          <source>Chunked responses are now also supported.</source>
          <target state="translated">청크 응답도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="db3313f2827a057e3a64943f9f95e2ab49a79565" translate="yes" xml:space="preserve">
          <source>Chunked transfer encoding</source>
          <target state="translated">청크 전송 인코딩</target>
        </trans-unit>
        <trans-unit id="02f5fbe3823ae3ee8836aabcd6aedc25a237e372" translate="yes" xml:space="preserve">
          <source>Chunked transfer encoding using a trailing header</source>
          <target state="translated">후행 헤더를 사용하는 청크 전송 인코딩</target>
        </trans-unit>
        <trans-unit id="5b18750fa39107d207083b7b1ced1d41dba0f08b" translate="yes" xml:space="preserve">
          <source>Clear Site Data</source>
          <target state="translated">명확한 사이트 데이터</target>
        </trans-unit>
        <trans-unit id="563a0adf9cc2a772ffc80a2f072b2791b10b2699" translate="yes" xml:space="preserve">
          <source>Clear-Site-Data</source>
          <target state="translated">Clear-Site-Data</target>
        </trans-unit>
        <trans-unit id="47c3b55337992becca7776593cb6ed91ea600664" translate="yes" xml:space="preserve">
          <source>Clearing cookies</source>
          <target state="translated">쿠키 삭제</target>
        </trans-unit>
        <trans-unit id="cc7132c182abf9d906ed90a092216ab6aefbc162" translate="yes" xml:space="preserve">
          <source>Clears browsing data (e.g. cookies, storage, cache) associated with the requesting website.</source>
          <target state="translated">요청하는 웹 사이트와 관련된 탐색 데이터 (예 : 쿠키, 저장소, 캐시)를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="7ca8349d76abe296a6950f45aded7fe82937ec47" translate="yes" xml:space="preserve">
          <source>ClickJacking Defenses - IEBlog</source>
          <target state="translated">ClickJacking Defense-IEBlog</target>
        </trans-unit>
        <trans-unit id="04d39ef8ff1810b107a1befbb4f275d469a941cd" translate="yes" xml:space="preserve">
          <source>Client                                     Server
     |                                           |
     |  1.) DELETE to Member URI                 |
     |------------------------------------------&amp;gt;|
     |                                           |
     |  2.) 200 OK                               |
     |&amp;lt;------------------------------------------|
     |                                           |

   1.  The client sends a DELETE request to the URI of a Member
       Resource.

   2.  If the deletion is successful, the server responds with a status
       code of 200.

   A different approach is taken for deleting Media Resources; see
   &lt;a href=&quot;#section-9.4&quot;&gt;Section 9.4&lt;/a&gt; for details.</source>
          <target state="translated">클라이언트 서버 | | | 1.) 멤버 URI로 삭제 | | ------------------------------------------&amp;gt; | | | | 2.) 200 OK | | &amp;lt;------------------------------------------ | | | 1. 클라이언트는 DELETE 요청을 멤버 리소스의 URI로 보냅니다. 2. 삭제에 성공하면 서버는 상태 코드 200으로 응답합니다. 미디어 리소스를 삭제하는 다른 방법이 사용됩니다. 자세한 내용 &lt;a href=&quot;#section-9.4&quot;&gt;은 9.4 절&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="06414e618e271894c3e9df0da8e1288e8b9d978d" translate="yes" xml:space="preserve">
          <source>Client                                     Server
     |                                           |
     |  1.) GET to Member URI                    |
     |------------------------------------------&amp;gt;|
     |                                           |
     |  2.) 200 Ok                               |
     |      Member Representation                |
     |&amp;lt;------------------------------------------|
     |                                           |

   1.  The client sends a GET request to the URI of a Member Resource to
       retrieve its representation.

   2.  The server responds with the representation of the Member
       Resource.</source>
          <target state="translated">클라이언트 서버 | | | 1.) 회원 URI에 GET | | ------------------------------------------&amp;gt; | | | | 2.) 200 Ok | | 회원 대표 | | &amp;lt;------------------------------------------ | | | 1. 클라이언트는 GET 요청을 구성원 자원의 URI로 보내 해당 표현을 검색합니다. 2. 서버는 구성원 자원의 표시로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="76876be155df9d3b1979f0004de22edc27efe8b1" translate="yes" xml:space="preserve">
          <source>Client                                     Server
     |                                           |
     |  1.) GET to Service Document URI          |
     |------------------------------------------&amp;gt;|
     |                                           |
     |  2.) 200 Ok                               |
     |      Service Document                     |
     |&amp;lt;------------------------------------------|
     |                                           |

   1.  The client sends a GET request to the URI of the Service
       Document.

   2.  The server responds with a Service Document enumerating the IRIs
       of a group of Collections and the capabilities of those
       Collections supported by the server.  The content of this
       document can vary based on aspects of the client request,
       including, but not limited to, authentication credentials.</source>
          <target state="translated">클라이언트 서버 | | | 1.) 서비스 문서 URI로 GET | | ------------------------------------------&amp;gt; | | | | 2.) 200 Ok | | 서비스 문서 | | &amp;lt;------------------------------------------ | | | 1. 클라이언트는 서비스 문서의 URI에 GET 요청을 보냅니다. 2. 서버는 컬렉션 그룹의 IRI 및 서버가 지원하는 컬렉션의 기능을 열거하는 서비스 문서로 응답합니다. 이 문서의 내용은 클라이언트 요청의 측면에 따라 다를 수 있습니다.인증 자격 증명.</target>
        </trans-unit>
        <trans-unit id="1d5b247b01ee86613d994ca606b20cb6279035ed" translate="yes" xml:space="preserve">
          <source>Client                                     Server
     |                                           |
     |  1.) POST to Collection URI               |
     |      Member Representation                |
     |------------------------------------------&amp;gt;|
     |                                           |
     |  2.) 201 Created                          |
     |      Location: Member Entry URI           |
     |&amp;lt;------------------------------------------|
     |                                           |

   1.  The client POSTs a representation of the Member to the URI of the
       Collection.

   2.  If the Member Resource was created successfully, the server
       responds with a status code of 201 and a Location header that
       contains the IRI of the newly created Entry Resource.  Media
       Resources could have also been created and their IRIs can be
       found through the Entry Resource.  See &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt; for more
       details.</source>
          <target state="translated">클라이언트 서버 | | | 1.) POST to Collection URI | | 회원 대표 | | ------------------------------------------&amp;gt; | | | | 2) 201 Created | | 위치 : 회원 항목 URI | | &amp;lt;------------------------------------------ | | | 1. 클라이언트는 Member의 표현을 Collection의 URI에 POST합니다. 2. 구성원 자원이 성공적으로 작성된 경우, 서버는 상태 코드 201과 새로 작성된 항목 자원의 IRI를 포함하는 Location 헤더로 응답합니다.미디어 리소스도 만들 수 있었으며 IRI는 엔트리 리소스를 통해 찾을 수 있습니다. 보다&lt;a href=&quot;#section-9.6&quot;&gt;&lt;/a&gt;자세한 내용은 섹션 9.6 .</target>
        </trans-unit>
        <trans-unit id="cd91d64f5ba1c2b561dc68aad78122e44b4031ba" translate="yes" xml:space="preserve">
          <source>Client                                     Server
     |                                           |
     |  1.) PUT to Member URI                    |
     |      Member Representation                |
     |------------------------------------------&amp;gt;|
     |                                           |
     |  2.) 200 OK                               |
     |&amp;lt;------------------------------------------|

   1.  The client sends a PUT request to store a representation of a
       Member Resource.

   2.  If the request is successful, the server responds with a status
       code of 200.</source>
          <target state="translated">클라이언트 서버 | | | 1.) 회원 URI에 PUT | | 회원 대표 | | ------------------------------------------&amp;gt; | | | | 2.) 200 OK | | &amp;lt;------------------------------------------ | 1. 클라이언트는 PUT 요청을 보내 회원 리소스의 표현을 저장합니다. 2. 요청이 성공하면 서버는 상태 코드 200으로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="2ab41737272cae6324e9b264638622ce30e7016c" translate="yes" xml:space="preserve">
          <source>Client error responses</source>
          <target state="translated">클라이언트 오류 응답</target>
        </trans-unit>
        <trans-unit id="c82a3ee2730bab92b98bc213a8fb73492e3fdebd" translate="yes" xml:space="preserve">
          <source>Client errors (&lt;code&gt;400&lt;/code&gt;&amp;ndash;&lt;code&gt;499&lt;/code&gt;)</source>
          <target state="translated">Client errors ( &lt;code&gt;400&lt;/code&gt; &amp;ndash; &lt;code&gt;499&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="dd407b441928f45e73a186d44c8d9b1022e9b952" translate="yes" xml:space="preserve">
          <source>Client hints</source>
          <target state="translated">클라이언트 힌트</target>
        </trans-unit>
        <trans-unit id="d5d9a54cc11d8f25e2a07fd30bc5b8caf775ec8d" translate="yes" xml:space="preserve">
          <source>Client request</source>
          <target state="translated">고객 요청</target>
        </trans-unit>
        <trans-unit id="c5b2b8d440453db220355b3130f1ed0c4ab07917" translate="yes" xml:space="preserve">
          <source>Client-Side &amp;amp; Server-Side (Java) sample for Cross-Origin Resource Sharing (CORS)</source>
          <target state="translated">CORS (Cross-Origin Resource Sharing)를위한 클라이언트 측 및 서버 측 (Java) 샘플</target>
        </trans-unit>
        <trans-unit id="6f5874c4570fe3f1c919c21b9967af34bee3005c" translate="yes" xml:space="preserve">
          <source>Client-initiated upgrade to HTTP over TLS</source>
          <target state="translated">TLS를 통한 HTTP로 클라이언트 시작 업그레이드</target>
        </trans-unit>
        <trans-unit id="922d22a1c7654940e60c03245c40184c1e28e1bb" translate="yes" xml:space="preserve">
          <source>Client: the user-agent</source>
          <target state="translated">클라이언트 : 사용자 에이전트</target>
        </trans-unit>
        <trans-unit id="28beb9075baceef63887e188043a5dc8f9f8abcf" translate="yes" xml:space="preserve">
          <source>Clients and servers communicate by exchanging individual messages (as opposed to a stream of data). The messages sent by the client, usually a Web browser, are called &lt;em&gt;requests&lt;/em&gt; and the messages sent by the server as an answer are called &lt;em&gt;responses&lt;/em&gt;.</source>
          <target state="translated">클라이언트와 서버는 개별 메시지를 교환하여 통신합니다 (데이터 스트림이 아닌). 클라이언트 (보통 웹 브라우저)가 보낸 메시지를 &lt;em&gt;요청&lt;/em&gt; 이라고 하고 서버가 응답으로 보낸 메시지를 &lt;em&gt;response&lt;/em&gt; 라고 합니다.</target>
        </trans-unit>
        <trans-unit id="f0a6c74917d2b5e80cb29e5ed1cc31e500515eb2" translate="yes" xml:space="preserve">
          <source>Clients are often privy to large amounts of personal information,
   including both information provided by the user to interact with
   resources (e.g., the user's name, location, mail address, passwords,
   encryption keys, etc.) and information about the user's browsing
   activity over time (e.g., history, bookmarks, etc.).  Implementations
   need to prevent unintentional disclosure of personal information.</source>
          <target state="translated">클라이언트는 종종 사용자가 리소스와 상호 작용하기 위해 제공 한 정보 (예 : 사용자 이름, 위치, 메일 주소, 비밀번호, 암호화 키 등) 및 사용자의 브라우징 활동에 대한 정보를 포함하여 많은 양의 개인 정보를 소유합니다. 시간 (예 : 기록, 북마크 등). 구현시 의도하지 않은 개인 정보 공개가 방지되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c8385dd1dcb9fe615c68497e7d83ea0f53328707" translate="yes" xml:space="preserve">
          <source>Clients using HTTP rely heavily on the Domain Name Service, and are
   thus generally prone to security attacks based on the deliberate
   mis-association of IP addresses and DNS names. Clients need to be
   cautious in assuming the continuing validity of an IP number/DNS name
   association.

   In particular, HTTP clients SHOULD rely on their name resolver for
   confirmation of an IP number/DNS name association, rather than
   caching the result of previous host name lookups. Many platforms
   already can cache host name lookups locally when appropriate, and
   they SHOULD be configured to do so. It is proper for these lookups to
   be cached, however, only when the TTL (Time To Live) information
   reported by the name server makes it likely that the cached
   information will remain useful.

   If HTTP clients cache the results of host name lookups in order to
   achieve a performance improvement, they MUST observe the TTL
   information reported by DNS.

   If HTTP clients do not observe this rule, they could be spoofed when
   a previously-accessed server's IP address changes. As network
   renumbering is expected to become increasingly common [&lt;a href=&quot;#ref-24&quot;&gt;24&lt;/a&gt;], the
   possibility of this form of attack will grow. Observing this
   requirement thus reduces this potential security vulnerability.

   This requirement also improves the load-balancing behavior of clients
   for replicated servers using the same DNS name and reduces the
   likelihood of a user's experiencing failure in accessing sites which
   use that strategy.</source>
          <target state="translated">HTTP를 사용하는 클라이언트는 도메인 이름 서비스에 크게 의존하므로 일반적으로 IP 주소와 DNS 이름의 잘못된 연결에 기반한 보안 공격을 받기 쉽습니다. IP 번호 / DNS 이름 연결의 지속적인 유효성을 가정 할 때 클라이언트는주의해야합니다. 특히, HTTP 클라이언트는 이전 호스트 이름 조회 결과를 캐싱하기보다는 IP 번호 / DNS 이름 연결을 확인하기 위해 이름 확인자에 의존해야합니다 (SHOULD). 많은 플랫폼이 이미 적절한 경우 호스트 이름 조회를 로컬로 캐시 할 수 있으므로 그렇게 구성해야합니다. 이름 서버에서보고 한 TTL (Time To Live) 정보로 인해 캐시 된 정보가 유용 할 가능성이있는 경우에만 이러한 조회를 캐시하는 것이 좋습니다.HTTP 클라이언트가 성능 향상을 위해 호스트 이름 조회 결과를 캐시하는 경우 DNS에서보고 한 TTL 정보를 준수해야합니다. HTTP 클라이언트가이 규칙을 준수하지 않으면 이전에 액세스 한 서버의 IP 주소가 변경 될 때 스푸핑 될 수 있습니다. 네트워크 번호 변경이 점점 일반화 될 것으로 예상됨에 따라 [&lt;a href=&quot;#ref-24&quot;&gt;24&lt;/a&gt; ], 이러한 형태의 공격 가능성이 커질 것이다. 따라서이 요구 사항을 준수하면 잠재적 인 보안 취약점이 줄어 듭니다. 또한이 요구 사항은 동일한 DNS 이름을 사용하여 복제 된 서버에 대한 클라이언트의로드 균형 조정 동작을 개선하고 해당 전략을 사용하는 사이트에 액세스하는 데 사용자가 실패 할 가능성을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="939f605954e45144b33768a5bb94ffea000db6cc" translate="yes" xml:space="preserve">
          <source>Close or reuse the connection for further requests.</source>
          <target state="translated">추가 요청을 위해 연결을 닫거나 재사용하십시오.</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="2a1800f5cb859b9d67e384c7da846507f055a233" translate="yes" xml:space="preserve">
          <source>Code Samples Showing &lt;code&gt;XMLHttpRequest&lt;/code&gt; and Cross-Origin Resource Sharing</source>
          <target state="translated">&lt;code&gt;XMLHttpRequest&lt;/code&gt; 및 Cross-Origin 리소스 공유를 보여주는 코드 샘플</target>
        </trans-unit>
        <trans-unit id="d674b2dea57bb6fd7e6a35edd6eb081470fbfe96" translate="yes" xml:space="preserve">
          <source>Collection Resources MUST provide representations in the form of Atom
   Feed Documents whose Entries contain the IRIs of the Members in the
   Collection.  No distinction is made between Collection Feeds and
   other kinds of Feeds -- a Feed might act both as a 'public' feed for
   subscription purposes and as a Collection Feed.

   Each Entry in the Feed Document SHOULD have an atom:link element with
   a relation of &quot;edit&quot; (see &lt;a href=&quot;#section-11.1&quot;&gt;Section 11.1&lt;/a&gt;).

   The Entries in the returned Atom Feed SHOULD be ordered by their
   &quot;app:edited&quot; property, with the most recently edited Entries coming
   first in the document order.  The app:edited value is not equivalent
   to the HTTP Last-Modified header and cannot be used to determine the
   freshness of cached responses.

   Clients MUST NOT assume that an Atom Entry returned in the Feed is a
   full representation of an Entry Resource and SHOULD perform a GET on
   the URI of the Member Entry before editing it.  See &lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt; for a
   discussion on the implications of cache control directives when
   obtaining entries.</source>
          <target state="translated">수금 자료는 Atom Feed Documents 형식으로 표현해야하며, 해당 항목에 수금 한 회원의 IRI가 포함되어 있어야합니다. 수집 피드와 다른 종류의 피드는 구별되지 않습니다. 피드는 구독 목적의 '공개'피드와 수집 피드의 역할을합니다. 피드 문서의 각 엔트리는 &quot;edit&quot;관계의 atom : link 요소를 가져야합니다 ( &lt;a href=&quot;#section-11.1&quot;&gt;11.1 장&lt;/a&gt; 참조)). 반환 된 Atom 피드의 항목은 &quot;app : edited&quot;속성으로 주문해야하며 가장 최근에 편집 한 항목이 문서 순서에서 먼저 나타납니다. app : edited 값은 HTTP Last-Modified 헤더와 같지 않으며 캐시 된 응답의 최신 성을 결정하는 데 사용할 수 없습니다. 고객은 피드에 반환 된 Atom Entry가 Entry Resource의 전체 표현이라고 가정해서는 안되며, 편집하기 전에 Member Entry의 URI에서 GET을 수행해야합니다. 항목을 얻을 때 캐시 제어 지시문의 의미에 대한 설명 은 &lt;a href=&quot;#section-9.5&quot;&gt;섹션 9.5&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b11e6ff9806f23d877b8f28e66ba1d2666df0aba" translate="yes" xml:space="preserve">
          <source>Collection resources differ from other resources in that they also
   act as containers.  Some HTTP methods apply only to a collection, but
   some apply to some or all of the resources inside the container
   defined by the collection.  When the scope of a method is not clear,
   the client can specify what depth to apply.  Depth can be either zero
   levels (only the collection), one level (the collection and directly
   contained resources), or infinite levels (the collection and all
   contained resources recursively).

   A collection's state consists of at least a set of mappings between
   path segments and resources, and a set of properties on the
   collection itself.  In this document, a resource B will be said to be
   contained in the collection resource A if there is a path segment
   mapping that maps to B and that is contained in A.  A collection MUST
   contain at most one mapping for a given path segment, i.e., it is
   illegal to have the same path segment mapped to more than one
   resource. 

   Properties defined on collections behave exactly as do properties on
   non-collection resources.  A collection MAY have additional state
   such as entity bodies returned by GET.

   For all WebDAV-compliant resources A and B, identified by URLs &quot;U&quot;
   and &quot;V&quot;, respectively, such that &quot;V&quot; is equal to &quot;U/SEGMENT&quot;, A MUST
   be a collection that contains a mapping from &quot;SEGMENT&quot; to B.  So, if
   resource B with URL &quot;http://example.com/bar/blah&quot; is WebDAV compliant
   and if resource A with URL &quot;http://example.com/bar/&quot; is WebDAV
   compliant, then resource A must be a collection and must contain
   exactly one mapping from &quot;blah&quot; to B.

   Although commonly a mapping consists of a single segment and a
   resource, in general, a mapping consists of a set of segments and a
   resource.  This allows a server to treat a set of segments as
   equivalent (i.e., either all of the segments are mapped to the same
   resource, or none of the segments are mapped to a resource).  For
   example, a server that performs case-folding on segments will treat
   the segments &quot;ab&quot;, &quot;Ab&quot;, &quot;aB&quot;, and &quot;AB&quot; as equivalent.  A client can
   then use any of these segments to identify the resource.  Note that a
   PROPFIND result will select one of these equivalent segments to
   identify the mapping, so there will be one PROPFIND response element
   per mapping, not one per segment in the mapping.

   Collection resources MAY have mappings to non-WebDAV-compliant
   resources in the HTTP URL namespace hierarchy but are not required to
   do so.  For example, if resource X with URL
   &quot;http://example.com/bar/blah&quot; is not WebDAV compliant and resource A
   with &quot;URL http://example.com/bar/&quot; identifies a WebDAV collection,
   then A may or may not have a mapping from &quot;blah&quot; to X.

   If a WebDAV-compliant resource has no WebDAV-compliant internal
   members in the HTTP URL namespace hierarchy, then the WebDAV-
   compliant resource is not required to be a collection.

   There is a standing convention that when a collection is referred to
   by its name without a trailing slash, the server MAY handle the
   request as if the trailing slash were present.  In this case, it
   SHOULD return a Content-Location header in the response, pointing to
   the URL ending with the &quot;/&quot;.  For example, if a client invokes a
   method on http://example.com/blah (no trailing slash), the server may
   respond as if the operation were invoked on http://example.com/blah/
   (trailing slash), and should return a Content-Location header with
   the value http://example.com/blah/.  Wherever a server produces a URL
   referring to a collection, the server SHOULD include the trailing
   slash.  In general, clients SHOULD use the trailing slash form of
   collection names.  If clients do not use the trailing slash form the
   client needs to be prepared to see a redirect response.  Clients will 

   find the DAV:resourcetype property more reliable than the URL to find
   out if a resource is a collection.

   Clients MUST be able to support the case where WebDAV resources are
   contained inside non-WebDAV resources.  For example, if an OPTIONS
   response from &quot;http://example.com/servlet/dav/collection&quot; indicates
   WebDAV support, the client cannot assume that
   &quot;http://example.com/servlet/dav/&quot; or its parent necessarily are
   WebDAV collections.

   A typical scenario in which mapped URLs do not appear as members of
   their parent collection is the case where a server allows links or
   redirects to non-WebDAV resources.  For instance, &quot;/col/link&quot; might
   not appear as a member of &quot;/col/&quot;, although the server would respond
   with a 302 status to a GET request to &quot;/col/link&quot;; thus, the URL
   &quot;/col/link&quot; would indeed be mapped.  Similarly, a dynamically-
   generated page might have a URL mapping from &quot;/col/index.html&quot;, thus
   this resource might respond with a 200 OK to a GET request yet not
   appear as a member of &quot;/col/&quot;.

   Some mappings to even WebDAV-compliant resources might not appear in
   the parent collection.  An example for this case are servers that
   support multiple alias URLs for each WebDAV-compliant resource.  A
   server may implement case-insensitive URLs, thus &quot;/col/a&quot; and
   &quot;/col/A&quot; identify the same resource, yet only either &quot;a&quot; or &quot;A&quot; is
   reported upon listing the members of &quot;/col&quot;.  In cases where a server
   treats a set of segments as equivalent, the server MUST expose only
   one preferred segment per mapping, consistently chosen, in PROPFIND
   responses.</source>
          <target state="translated">수집 자원은 컨테이너 역할도한다는 점에서 다른 자원과 다릅니다. 일부 HTTP 메소드는 콜렉션에만 적용되지만 일부는 콜렉션에 의해 정의 된 컨테이너 내부의 일부 또는 모든 자원에 적용됩니다. 메소드의 범위가 명확하지 않은 경우 클라이언트는 적용 할 깊이를 지정할 수 있습니다. 깊이는 0 레벨 (컬렉션 만), 1 레벨 (컬렉션 및 직접 포함 된 자원) 또는 무한 레벨 (컬렉션 및 모든 포함 된 자원을 재귀 적으로)입니다. 컬렉션의 상태는 최소한 경로 세그먼트와 리소스 간의 매핑 집합과 컬렉션 자체의 속성 집합으로 구성됩니다. 이 문서에서B에 매핑되고 A에 포함 된 경로 세그먼트 매핑이있는 경우 리소스 B는 컬렉션 리소스 A에 포함되어 있다고합니다. 컬렉션은 주어진 경로 세그먼트에 대해 최대 하나의 매핑을 포함해야합니다. 동일한 경로 세그먼트를 둘 이상의 리소스에 매핑하는 것은 불법입니다. 컬렉션에 정의 된 속성은 컬렉션이 아닌 리소스의 속성과 똑같이 동작합니다. 컬렉션은 GET에 의해 반환 된 엔티티 본문과 같은 추가 상태를 가질 수 있습니다. &quot;V&quot;가 &quot;U / SEGMENT&quot;와 같은 URL &quot;U&quot;및 &quot;V&quot;로 식별되는 모든 WebDAV 호환 자원 A 및 B에 대해 A는 &quot;SEGMENT&quot;의 맵핑을 포함하는 콜렉션이어야합니다. URL이 &quot;http://example.com/bar/blah&quot;인 리소스 B가URL이 &quot;http://example.com/bar/&quot;인 자원 A가 WebDAV를 준수하는 경우 자원 A는 콜렉션이어야하며 &quot;blah&quot;에서 B로 정확히 하나의 맵핑을 포함해야합니다. 단일 세그먼트 및 자원의 일반적으로, 맵핑은 일련의 세그먼트 및 자원으로 구성된다. 이를 통해 서버는 세그먼트 세트를 동등한 것으로 처리 할 수 ​​있습니다 (즉, 모든 세그먼트가 동일한 자원에 맵핑되거나 세그먼트에 자원이 맵핑되지 않음). 예를 들어, 세그먼트에서 케이스 접기를 수행하는 서버는 세그먼트 &quot;ab&quot;, &quot;Ab&quot;, &quot;aB&quot;및 &quot;AB&quot;를 동등한 것으로 취급합니다. 클라이언트는 이러한 세그먼트 중 하나를 사용하여 리소스를 식별 할 수 있습니다.PROPFIND 결과는 맵핑을 식별하기 위해 이러한 동등한 세그먼트 중 하나를 선택하므로 맵핑에서 세그먼트 당 하나가 아니라 맵핑 당 하나의 PROPFIND 응답 요소가 있습니다. 콜렉션 자원은 HTTP URL 네임 스페이스 계층 구조에서 WebDAV를 준수하지 않는 자원에 맵핑 될 수 있지만 그렇게 할 필요는 없습니다. 예를 들어 URL이 &quot;http://example.com/bar/blah&quot;인 자원 X가 WebDAV를 준수하지 않고 &quot;URL http://example.com/bar/&quot;를 가진 자원 A가 WebDAV 콜렉션을 식별하면 A가 WebDAV 호환 리소스에 HTTP URL 네임 스페이스 계층 구조에 WebDAV 호환 내부 멤버가없는 경우 WebDAV 호환 리소스가 컬렉션 일 필요는 없습니다.컬렉션이 후행 슬래시없이 이름으로 참조 될 경우 서버는 후행 슬래시가있는 것처럼 요청을 처리 할 수 ​​있습니다. 이 경우 &quot;/&quot;로 끝나는 URL을 가리키는 응답에 Content-Location 헤더를 반환해야합니다. 예를 들어, 클라이언트가 http://example.com/blah (후행 슬래시 없음)에서 메소드를 호출하면 서버는 http://example.com/blah/ (트레일 슬래시)에서 작업이 호출 된 것처럼 응답 할 수 있습니다. 이며 값이 http://example.com/blah/ 인 Content-Location 헤더를 반환해야합니다. 서버가 컬렉션을 참조하는 URL을 생성 할 때마다 서버 뒤에 슬래시를 포함해야합니다. 일반적으로 클라이언트는 슬래시 형식의 컬렉션 이름을 사용해야합니다.클라이언트가 후행 슬래시 양식을 사용하지 않으면 클라이언트가 경로 재 지정 응답을 볼 수 있도록 준비해야합니다. 클라이언트는 DAV : resourcetype 속성이 URL보다 더 안정적이라는 것을 알게되어 리소스가 컬렉션인지 확인합니다. 클라이언트는 WebDAV 자원이 WebDAV가 아닌 자원에 포함 된 경우를 지원할 수 있어야합니다. 예를 들어 &quot;http://example.com/servlet/dav/collection&quot;의 OPTIONS 응답이 WebDAV 지원을 나타내는 경우 클라이언트는 &quot;http://example.com/servlet/dav/&quot;또는 해당 상위가 WebDAV 모음입니다. 맵핑 된 URL이 상위 콜렉션의 구성원으로 나타나지 않는 일반적인 시나리오는 서버가 WebDAV 이외의 자원으로의 링크 또는 경로 재 지정을 허용하는 경우입니다. 예를 들어 &quot;/ col / link&quot;서버가 &quot;/ col / link&quot;에 대한 GET 요청에 대해 302 상태로 응답하지만 &quot;/ col /&quot;의 구성원으로 나타나지 않을 수 있습니다. 따라서 URL &quot;/ col / link&quot;는 실제로 매핑됩니다. 마찬가지로 동적으로 생성 된 페이지에는 &quot;/col/index.html&quot;의 URL 매핑이있을 수 있으므로이 리소스는 GET 요청에 200 OK로 응답하지만 &quot;/ col /&quot;의 멤버로 표시되지 않을 수 있습니다. WebDAV 호환 리소스에 대한 일부 매핑은 상위 컬렉션에 나타나지 않을 수 있습니다. 이 경우의 예는 각 WebDAV 호환 자원에 대해 다중 별명 URL을 지원하는 서버입니다. 서버는 대소 문자를 구분하지 않는 URL을 구현할 수 있으므로 &quot;/ col / a&quot;및 &quot;/ col / A&quot;는 동일한 리소스를 식별하지만 &quot;a&quot;또는 &quot;A&quot;만 식별합니다&quot;/ col&quot;의 회원을 등록하면보고됩니다. 서버가 세그먼트 세트를 동등한 것으로 취급하는 경우, 서버는 PROPFIND 응답에서 일관되게 선택된 맵핑 당 하나의 선호 세그먼트 만 노출해야합니다.</target>
        </trans-unit>
        <trans-unit id="92c14ed70a70a4eecdf0beb11029acb63043ecd0" translate="yes" xml:space="preserve">
          <source>Collections and Namespace Operations

   o  Due to interoperability problems, allowable formats for contents
      of 'href' elements in multistatus responses have been limited (see
      &lt;a href=&quot;#section-8.3&quot;&gt;Section 8.3&lt;/a&gt;).

   o  Due to lack of implementation, support for the 'propertybehavior'
      request body for COPY and MOVE has been removed.  Instead,
      requirements for property preservation have been clarified (see
      Sections &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt; and &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt;).

   Properties

   o  Strengthened server requirements for storage of property values,
      in particular persistence of language information (xml:lang),
      whitespace, and XML namespace information (see &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).

   o  Clarified requirements on which properties should be writable by
      the client; in particular, setting &quot;DAV:displayname&quot; should be
      supported by servers (see &lt;a href=&quot;#section-15&quot;&gt;Section 15&lt;/a&gt;).

   o  Only '&lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt;-date' productions are legal as values for DAV:
      getlastmodified (see &lt;a href=&quot;#section-15.7&quot;&gt;Section 15.7&lt;/a&gt;).

   Headers and Marshalling

   o  Servers are now required to do authorization checks before
      processing conditional headers (see &lt;a href=&quot;#section-8.5&quot;&gt;Section 8.5&lt;/a&gt;).

   Locking

   o  Strengthened requirement to check identity of lock creator when
      accessing locked resources (see &lt;a href=&quot;#section-6.4&quot;&gt;Section 6.4&lt;/a&gt;).  Clients should be
      aware that lock tokens returned to other principals can only be
      used to break a lock, if at all. 

   o  &lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-8.10.4&quot;&gt;Section&amp;nbsp;8.10.4 of [RFC2518]&lt;/a&gt; incorrectly required servers to return
      a 409 status where a 207 status was really appropriate.  This has
      been corrected (&lt;a href=&quot;#section-9.10&quot;&gt;Section 9.10&lt;/a&gt;).</source>
          <target state="translated">컬렉션 및 네임 스페이스 작업 o 상호 운용성 문제로 인해 다중 상태 응답에서 'href'요소의 내용에 허용되는 형식이 제한되었습니다 ( &lt;a href=&quot;#section-8.3&quot;&gt;섹션 8.3&lt;/a&gt; 참조 ). o 구현 부족으로 인해 COPY 및 MOVE에 대한 'propertybehavior'요청 본문에 대한 지원이 제거되었습니다. 대신, 재산 보존에 대한 요구 사항이 명확 해졌습니다 (섹션 &lt;a href=&quot;#section-9.8&quot;&gt;9.8&lt;/a&gt; 및 &lt;a href=&quot;#section-9.9&quot;&gt;9.9&lt;/a&gt; 참조 ). 속성 o 속성 값 저장, 특히 언어 정보의 지속성 (xml : lang), 공백 및 XML 네임 스페이스 정보에 대한 서버 요구 사항 강화 ( &lt;a href=&quot;#section-4.3&quot;&gt;4.3 절&lt;/a&gt; 참조)). o 고객이 속성을 쓸 수있는 명확한 요구 사항 특히, &quot;DAV : displayname&quot;설정은 서버에서 지원해야합니다 ( &lt;a href=&quot;#section-15&quot;&gt;섹션 15&lt;/a&gt; 참조 ). o ' &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt; -date'프로덕션 만 DAV의 값으로 유효합니다 : getlastmodified ( &lt;a href=&quot;#section-15.7&quot;&gt;15.7 절&lt;/a&gt; 참조 ). 헤더 및 마샬링 o 이제 조건부 헤더를 처리하기 전에 서버가 권한 검사를 수행해야합니다 ( &lt;a href=&quot;#section-8.5&quot;&gt;8.5 절&lt;/a&gt; 참조 ). 잠금 o 잠금 리소스에 액세스 할 때 잠금 생성기의 신원을 확인하기위한 강화 된 요구 사항 ( &lt;a href=&quot;#section-6.4&quot;&gt;섹션 6.4&lt;/a&gt; 참조)). 클라이언트는 다른 프린시 펄로 리턴 된 잠금 토큰을 사용하여 잠금을 해제 할 수 있다는 사실을 알고 있어야합니다. o &lt;a href=&quot;https://tools.ietf.org/html/rfc2518#section-8.10.4&quot;&gt;[RFC2518] 섹션 8.10.4는&lt;/a&gt; 서버가 207 상태가 실제로 적절한 409 상태를 반환하도록 잘못 요구했습니다. 이것은 수정되었습니다 ( &lt;a href=&quot;#section-9.10&quot;&gt;Section 9.10&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cfd2e08606ba977053d3bef5451af9337fdfae03" translate="yes" xml:space="preserve">
          <source>Collections and Namespace Operations

   o  The semantics of PROPFIND 'allprop' (&lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt;) have been
      relaxed so that servers return results including, at a minimum,
      the live properties defined in this specification, but not
      necessarily return other live properties.  The 'allprop' directive
      therefore means something more like &quot;return all properties that
      are supposed to be returned when 'allprop' is requested&quot; -- a set
      of properties that may include custom properties and properties
      defined in other specifications if those other specifications so
      require.  Related to this, 'allprop' requests can now be extended
      with the 'include' syntax to include specific named properties, 

      thereby avoiding additional requests due to changed 'allprop'
      semantics.

   o  Servers are now allowed to reject PROPFIND requests with Depth:
      Infinity.  Clients that used this will need to be able to do a
      series of Depth:1 requests instead.

   o  Multi-Status response bodies now can transport the value of HTTP's
      Location response header in the new 'location' element.  Clients
      may use this to avoid additional roundtrips to the server when
      there is a 'response' element with a 3xx status (see
      &lt;a href=&quot;#section-14.24&quot;&gt;Section 14.24&lt;/a&gt;).

   o  The definition of COPY has been relaxed so that it doesn't require
      servers to first delete the target resources anymore (this was a
      known incompatibility with [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;]).  See &lt;a href=&quot;#section-9.8&quot;&gt;Section 9.8&lt;/a&gt;.

   Headers and Marshalling

   o  The Destination and If request headers now allow absolute paths in
      addition to full URIs (see &lt;a href=&quot;#section-8.3&quot;&gt;Section 8.3&lt;/a&gt;).  This may be useful for
      clients operating through a reverse proxy that does rewrite the
      Host request header, but not WebDAV-specific headers.

   o  This specification adopts the error marshalling extensions and the
      &quot;precondition/postcondition&quot; terminology defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;] (see
      &lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;).  Related to that, it adds the &quot;error&quot; XML element
      inside multistatus response bodies (see &lt;a href=&quot;#section-14.5&quot;&gt;Section 14.5&lt;/a&gt;, however note
      that it uses a format different from the one recommended in &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;3253&lt;/a&gt;).

   o  Senders and recipients are now required to support the UTF-16
      character encoding in XML message bodies (see &lt;a href=&quot;#section-19&quot;&gt;Section 19&lt;/a&gt;).

   o  Clients are now required to send the Depth header on PROPFIND
      requests, although servers are still encouraged to support clients
      that don't.

   Locking

   o  &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;'s concept of &quot;lock-null resources&quot; (LNRs) has been
      replaced by a simplified approach, the &quot;locked empty resources&quot;
      (see &lt;a href=&quot;#section-7.3&quot;&gt;Section 7.3&lt;/a&gt;).  There are some aspects of lock-null resources
      clients cannot rely on anymore, namely, the ability to use them to
      create a locked collection or the fact that they disappear upon
      UNLOCK when no PUT or MKCOL request was issued.  Note that servers
      are still allowed to implement LNRs as per &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;. 

   o  There is no implicit refresh of locks anymore.  Locks are only
      refreshed upon explicit request (see &lt;a href=&quot;#section-9.10.2&quot;&gt;Section 9.10.2&lt;/a&gt;).

   o  Clarified that the DAV:owner value supplied in the LOCK request
      must be preserved by the server just like a dead property
      (&lt;a href=&quot;#section-14.17&quot;&gt;Section 14.17&lt;/a&gt;).  Also added the DAV:lockroot element
      (&lt;a href=&quot;#section-14.12&quot;&gt;Section 14.12&lt;/a&gt;), which allows clients to discover the root of
      lock.</source>
          <target state="translated">컬렉션과 네임 스페이스 연산 o PROPFIND 'allprop'의 의미론 ( &lt;a href=&quot;#section-9.1&quot;&gt;9.1 절&lt;/a&gt;)는 서버가이 사양에 정의 된 라이브 속성을 포함하여 결과를 반환하지만 반드시 다른 라이브 속성을 반환하는 것은 아닙니다. 따라서 'allprop'지시문은 &quot; 'allprop'가 요청 될 때 리턴되어야하는 모든 특성 리턴&quot;과 같은 것을 의미합니다. 이러한 특성은 다른 스펙에 필요한 경우 다른 스펙에 정의 된 사용자 정의 특성 및 특성을 포함 할 수 있습니다. . 이와 관련하여 'allprop'요청을 'include'구문으로 확장하여 특정 명명 된 속성을 포함함으로써 변경된 'allprop'시맨틱으로 인한 추가 요청을 피할 수 있습니다. o 이제 서버는 깊이가있는 PROPFIND 요청을 거부 할 수 있습니다.무한대. 이를 사용하는 클라이언트는 대신 일련의 Depth : 1 요청을 수행 할 수 있어야합니다. o 다중 상태 응답 본문은 이제 새로운 'location'요소에서 HTTP의 Location 응답 헤더 값을 전송할 수 있습니다. 클라이언트는 이것을 사용하여 상태가 3xx 인 '응답'요소가있을 때 서버에 대한 추가 왕복을 피할 수 있습니다 (참조 &lt;a href=&quot;#section-14.24&quot;&gt;섹션 14.24&lt;/a&gt; ). o COPY의 정의가 완화되어 서버에서 더 이상 대상 자원을 더 이상 삭제하지 않아도됩니다 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ] 과의 알려진 비 호환성 임 ). &lt;a href=&quot;#section-9.8&quot;&gt;섹션 9.8&lt;/a&gt; 참조 . 헤더 및 마샬링 o 대상 및 If 요청 헤더는 이제 전체 URI 외에 절대 경로를 허용합니다 ( &lt;a href=&quot;#section-8.3&quot;&gt;섹션 8.3&lt;/a&gt; 참조 ). 이는 WebDAV 특정 헤더가 아닌 호스트 요청 헤더를 다시 쓰는 리버스 프록시를 통해 작동하는 클라이언트에 유용 할 수 있습니다. o이 사양은 오류 마샬링 확장과 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ]에 정의 된 &quot;전제 조건 / 후 조건&quot;용어를 채택합니다 ( &lt;a href=&quot;#section-16&quot;&gt;섹션 16&lt;/a&gt; 참조) ). 이와 관련하여 다중 상태 응답 본문 내에 &quot;오류&quot;XML 요소를 추가합니다 ( &lt;a href=&quot;#section-14.5&quot;&gt;14.5 절&lt;/a&gt; 참조 ). &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;3253&lt;/a&gt; 에서 권장되는 형식과 다른 형식을 사용합니다 . o 이제 발신자와 수신자는 XML 메시지 본문에서 UTF-16 문자 인코딩을 지원해야합니다 ( &lt;a href=&quot;#section-19&quot;&gt;섹션 19&lt;/a&gt; 참조 ). o 서버는 여전히 지원하지 않는 클라이언트를 지원하도록 권장되지만, 이제 클라이언트는 PROPFIND 요청에 대해 Depth 헤더를 보내야합니다. 잠금 o &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; 의 &quot;LNR (lock-null resources)&quot;개념은 &quot;빈 자원 잠금&quot;이라는 간단한 접근 방식으로 대체되었습니다 ( &lt;a href=&quot;#section-7.3&quot;&gt;섹션 7.3&lt;/a&gt; 참조).). 클라이언트가 더 이상 사용할 수없는 잠금 널 자원의 일부 측면, 즉 잠금 콜렉션을 작성하는 기능 또는 PUT 또는 MKCOL 요청이 발행되지 않은 경우 UNLOCK시 사라진다는 사실이 있습니다. 서버는 여전히 &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518에&lt;/a&gt; 따라 LNR을 구현할 수 있습니다. o 더 이상 암시적인 잠금 새로 고침이 없습니다. 잠금은 명시 적 요청시에만 새로 고쳐집니다 ( &lt;a href=&quot;#section-9.10.2&quot;&gt;9.10.2 절&lt;/a&gt; 참조 ). o LOCK 요청에 제공된 DAV : owner 값은 죽은 속성과 마찬가지로 서버에 의해 보존되어야 함을 &lt;a href=&quot;#section-14.17&quot;&gt;명시&lt;/a&gt; 했습니다 ( 14.17 절 ). 또한 클라이언트가 잠금 루트를 발견 할 수 있도록 DAV : lockroot 요소 ( &lt;a href=&quot;#section-14.12&quot;&gt;14.12 절&lt;/a&gt; )를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="ea7b149981164a5bdbbf89dc8821115528f3f53c" translate="yes" xml:space="preserve">
          <source>Collections can contain large numbers of Resources.  A client such as
   a web spider or web browser might be overwhelmed if the response to a
   GET contained every Entry in a Collection -- in turn the server might
   also waste bandwidth and processing time on generating a response
   that cannot be handled.  For this reason, servers MAY respond to
   Collection GET requests with a Feed Document containing a partial
   list of the Collection's members, and a link to the next partial list
   feed, if it exists.  The first such partial list returned MUST
   contain the most recently edited member Resources and MUST have an
   atom:link with a &quot;next&quot; relation whose &quot;href&quot; value is the URI of the
   next partial list of the Collection.  This next partial list will
   contain the next most recently edited set of Member Resources (and an
   atom:link to the following partial list if it exists).

   In addition to the &quot;next&quot; relation, partial list feeds MAY contain
   link elements with &quot;rel&quot; attribute values of &quot;previous&quot;, &quot;first&quot;, and
   &quot;last&quot;, that can be used to navigate through the complete set of
   entries in the Collection.

   For instance, suppose a client is supplied the URI
   &quot;http://example.org/entries/go&quot; of a Collection of Member Entries,
   where the server as a matter of policy avoids generating Feed
   Documents containing more than 10 Entries.  The Atom Feed Document 

   for the Collection will then represent the first partial list of a
   set of 10 linked Feed Documents.  The &quot;first&quot; relation references the
   initial Feed Document in the set and the &quot;last&quot; relation references
   the final Feed Document in the set.  Within each document, the
   &quot;previous&quot; and &quot;next&quot; link relations reference the preceding and
   subsequent documents.

     &amp;lt;feed xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
       &amp;lt;link rel=&quot;first&quot;
             href=&quot;http://example.org/entries/go&quot; /&amp;gt;
       &amp;lt;link rel=&quot;next&quot;
             href=&quot;http://example.org/entries/2&quot; /&amp;gt;
       &amp;lt;link rel=&quot;last&quot;
             href=&quot;http://example.org/entries/10&quot; /&amp;gt;
       
     &amp;lt;/feed&amp;gt;

   The &quot;previous&quot; and &quot;next&quot; link elements for the partial list feed
   located at &quot;http://example.org/entries/2&quot; would look like this:

     &amp;lt;feed xmlns=&quot;http://www.w3.org/2005/Atom&quot;&amp;gt;
       &amp;lt;link rel=&quot;first&quot;
             href=&quot;http://example.org/entries/go&quot; /&amp;gt;
       &amp;lt;link rel=&quot;previous&quot;
             href=&quot;http://example.org/entries/go&quot; /&amp;gt;
       &amp;lt;link rel=&quot;next&quot;
             href=&quot;http://example.org/entries/3&quot; /&amp;gt;
       &amp;lt;link rel=&quot;last&quot;
             href=&quot;http://example.org/entries/10&quot; /&amp;gt;
       
     &amp;lt;/feed&amp;gt;</source>
          <target state="translated">컬렉션에는 많은 리소스가 포함될 수 있습니다. GET에 대한 응답이 콜렉션의 모든 항목을 포함하는 경우 웹 스파이더 또는 웹 브라우저와 같은 클라이언트가 압도 될 수 있습니다. 따라서 서버는 처리 할 수없는 응답을 생성하는 데 대역폭 및 처리 시간이 낭비 될 수 있습니다. 이러한 이유로 서버는 컬렉션 구성원의 일부 목록이 포함 된 피드 문서와 다음 부분 목록 피드 (있는 경우)에 대한 링크를 사용하여 컬렉션 GET 요청에 응답 할 수 있습니다. 리턴 된 첫 번째 부분 목록은 가장 최근에 편집 된 구성원 자원을 포함해야하며 &quot;href&quot;값이 콜렉션의 다음 부분 목록의 URI 인 &quot;다음&quot;관계가있는 atom : link를 가져야합니다.이 다음 부분 목록에는 가장 최근에 편집 된 다음 구성원 자원 세트 (및 다음 부분 목록에 대한 atom : link)가 포함됩니다. &quot;다음&quot;관계에 추가하여 부분 목록 피드에는 &quot;rel&quot;속성 값이 &quot;previous&quot;, &quot;first&quot;및 &quot;last&quot;인 링크 요소가 포함될 수 있습니다. 수집. 예를 들어, 클라이언트에 구성원 항목 콜렉션의 URI &quot;http://example.org/entries/go&quot;가 클라이언트에 제공되고 정책의 문제로 서버가 10 개 이상의 항목을 포함하는 피드 문서를 생성하지 못하게한다고 가정하십시오. 컬렉션에 대한 Atom 피드 문서는 10 개의 연결된 피드 문서 세트의 첫 번째 부분 목록을 나타냅니다. 첫번째&quot;관계는 세트의 초기 피드 문서를 참조하고 &quot;마지막&quot;관계는 세트의 최종 피드 문서를 참조합니다. 각 문서 내에서 &quot;이전&quot;및 &quot;다음&quot;링크 관계는 선행 및 후속 문서를 참조합니다. &amp;lt;feed xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;link rel = &quot;first&quot;href = &quot;http://example.org/entries/go&quot;/&amp;gt; &amp;lt;link rel = &quot;next &quot;href =&quot;http://example.org/entries/2 &quot;/&amp;gt; &amp;lt;link rel =&quot;last &quot;href =&quot;http://example.org/entries/10 &quot;/&amp;gt; &amp;lt;/ feed&amp;gt;&quot;이전 &quot; &quot;http://example.org/entries/2&quot;에있는 부분 목록 피드의 &quot;다음&quot;링크 요소는 다음과 같습니다.&amp;lt;feed xmlns = &quot;http://www.w3.org/2005/Atom&quot;&amp;gt; &amp;lt;link rel = &quot;first&quot;href = &quot;http://example.org/entries/go&quot;/&amp;gt; &amp;lt;link rel = &quot;이전 &quot;href =&quot;http://example.org/entries/go &quot;/&amp;gt; &amp;lt;link rel =&quot;next &quot;href =&quot;http://example.org/entries/3 &quot;/&amp;gt; &amp;lt;link rel =&quot;last &quot;href = &quot;http://example.org/entries/10&quot;/&amp;gt; &amp;lt;/ feed&amp;gt;org / entries / 3 &quot;/&amp;gt; &amp;lt;link rel =&quot;last &quot;href =&quot;http://example.org/entries/10 &quot;/&amp;gt; &amp;lt;/ feed&amp;gt;org / entries / 3 &quot;/&amp;gt; &amp;lt;link rel =&quot;last &quot;href =&quot;http://example.org/entries/10 &quot;/&amp;gt; &amp;lt;/ feed&amp;gt;</target>
        </trans-unit>
        <trans-unit id="19b77d56fd18f49783fa29dab7e6057a1e912b7b" translate="yes" xml:space="preserve">
          <source>Combating ClickJacking with X-Frame-Options - IEInternals</source>
          <target state="translated">ClickJacking과 X-Frame-Options의 결합-IEInternals</target>
        </trans-unit>
        <trans-unit id="4b4da2aaa941fd10619ebba8b1a33ab3b456b5cf" translate="yes" xml:space="preserve">
          <source>Combining Ranges (RFC 7233)</source>
          <target state="translated">결합 범위 (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="d9439543fdbba1e16aeffe917fc7d29f50cbcc79" translate="yes" xml:space="preserve">
          <source>Comma-delimited list of the allowed &lt;a href=&quot;../methods&quot;&gt;HTTP request methods&lt;/a&gt;.</source>
          <target state="translated">허용 된 &lt;a href=&quot;../methods&quot;&gt;HTTP 요청 메소드&lt;/a&gt; 의 쉼표로 구분 된 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="5bb95ba15fb836d98586a3edad9ec1fd27077fa7" translate="yes" xml:space="preserve">
          <source>Comma-separated values (CSV)</source>
          <target state="translated">쉼표로 구분 된 값 (CSV)</target>
        </trans-unit>
        <trans-unit id="68546dfaabacefbed271a8286b33a08186cc138e" translate="yes" xml:space="preserve">
          <source>Command line: &lt;code&gt;pactester -p ~/pacparser-master/tests/proxy.pac -u http://www.mozilla.org&lt;/code&gt;</source>
          <target state="translated">명령 행 : &lt;code&gt;pactester -p ~/pacparser-master/tests/proxy.pac -u http://www.mozilla.org&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="62674fb494832a5696aeff81df38c79717f4136f" translate="yes" xml:space="preserve">
          <source>Command line: &lt;code&gt;pactester -p ~/pacparser-master/tests/proxy.pac -u http://www.mozilla.org&lt;/code&gt; (passes the &lt;code&gt;host&lt;/code&gt; parameter &lt;code&gt;www.mozilla.org&lt;/code&gt; and the &lt;code&gt;url&lt;/code&gt; parameter &lt;code&gt;http://www.mozilla.org&lt;/code&gt;)</source>
          <target state="translated">Command line: &lt;code&gt;pactester -p ~/pacparser-master/tests/proxy.pac -u http://www.mozilla.org&lt;/code&gt; (passes the &lt;code&gt;host&lt;/code&gt; parameter &lt;code&gt;www.mozilla.org&lt;/code&gt; and the &lt;code&gt;url&lt;/code&gt; parameter &lt;code&gt;http://www.mozilla.org&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="153d7a58b3a3e898fcbdd04c462af308414bd09d" translate="yes" xml:space="preserve">
          <source>Comment</source>
          <target state="translated">Comment</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="4861e90f90a057c5903a2cf3d60626141d9b6010" translate="yes" xml:space="preserve">
          <source>Comments to &lt;a href=&quot;news://news.mozilla.org/netscape.public.mozilla.netlib&quot;&gt;mozilla.dev.platform&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;news://news.mozilla.org/netscape.public.mozilla.netlib&quot;&gt;mozilla.dev.platform에 대한&lt;/a&gt; 의견</target>
        </trans-unit>
        <trans-unit id="355f9fe714bdefce689d0719b3940842115ebbd1" translate="yes" xml:space="preserve">
          <source>Common browsers User Agent strings</source>
          <target state="translated">일반적인 브라우저 사용자 에이전트 문자열</target>
        </trans-unit>
        <trans-unit id="93c3c55fe8f9dff2940ed7383aee89cb47a05822" translate="yes" xml:space="preserve">
          <source>Common causes are a server that is down for maintenance or that is overloaded. This response should be used for temporary conditions and the &lt;a href=&quot;../headers/retry-after&quot;&gt;&lt;code&gt;Retry-After&lt;/code&gt;&lt;/a&gt; HTTP header should, if possible, contain the estimated time for the recovery of the service.</source>
          <target state="translated">일반적인 원인은 유지 관리를 위해 다운되었거나 과부하 된 서버입니다. 이 응답은 임시 조건에 사용해야하며 가능하면 &lt;a href=&quot;../headers/retry-after&quot;&gt; &lt;code&gt;Retry-After&lt;/code&gt; &lt;/a&gt; HTTP 헤더에는 가능한 경우 서비스 복구 예상 시간이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f52fe2765fb6c8791ca39fc493cf9ca94ef54e30" translate="yes" xml:space="preserve">
          <source>Common format for web browsers:</source>
          <target state="translated">Common format for web browsers:</target>
        </trans-unit>
        <trans-unit id="376d942f8b1dc70a62764c08e0779e6fd0d34dc3" translate="yes" xml:space="preserve">
          <source>Common forms of caching entries are:</source>
          <target state="translated">Common forms of caching entries are:</target>
        </trans-unit>
        <trans-unit id="38d604abe4effd051b577737efcac0be5dd312de" translate="yes" xml:space="preserve">
          <source>Common problems</source>
          <target state="translated">일반적인 문제</target>
        </trans-unit>
        <trans-unit id="e69ef1fa14a563c69b2071931128d46e80d8fcab" translate="yes" xml:space="preserve">
          <source>Common uses for this mechanism</source>
          <target state="translated">이 메커니즘의 일반적인 용도</target>
        </trans-unit>
        <trans-unit id="a3e3c123b281c1fc386d6962bf0c8c55f62330c3" translate="yes" xml:space="preserve">
          <source>Communicates one or more metrics and descriptions for the given request-response cycle.</source>
          <target state="translated">주어진 요청-응답주기에 대한 하나 이상의 메트릭 및 설명을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="36eba05ecfef326403242e9b2557dc4cf61823c3" translate="yes" xml:space="preserve">
          <source>Communicating Presentation Information in Internet Messages: The Content-Disposition Header Field</source>
          <target state="translated">인터넷 메시지의 프리젠 테이션 정보 통신 : 컨텐츠 처리 헤더 필드</target>
        </trans-unit>
        <trans-unit id="bb4f07ea51666d42daa68586d151fd1eee7f250c" translate="yes" xml:space="preserve">
          <source>Comparing versions of the same resource is a bit tricky: depending on the context, there are two kinds of &lt;em&gt;equality checks&lt;/em&gt;:</source>
          <target state="translated">동일한 리소스의 버전을 비교하는 것은 약간 까다 롭습니다. 컨텍스트에 따라 두 가지 종류의 &lt;em&gt;동등성 검사가 있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="187c3be8f0ded5cfb27cd980759930707dd51a48" translate="yes" xml:space="preserve">
          <source>Comparison to chunked &lt;code&gt;Transfer-Encoding&lt;/code&gt;</source>
          <target state="translated">청크 &lt;code&gt;Transfer-Encoding&lt;/code&gt; 비교</target>
        </trans-unit>
        <trans-unit id="2cb53559d09ec4706b50627aafe05c3f74ccaf5c" translate="yes" xml:space="preserve">
          <source>Compatibility Notes</source>
          <target state="translated">호환성 노트</target>
        </trans-unit>
        <trans-unit id="7d648a6dff363974f754bb78876c2b10dadd8183" translate="yes" xml:space="preserve">
          <source>Compatibility notes</source>
          <target state="translated">호환성 노트</target>
        </trans-unit>
        <trans-unit id="079f93e4945f9092390a018ed062372bdcfd86bd" translate="yes" xml:space="preserve">
          <source>Complete list of MIME types</source>
          <target state="translated">MIME 유형의 전체 목록</target>
        </trans-unit>
        <trans-unit id="8a9facd0c43149e93efff61f4e5ddc45591658e4" translate="yes" xml:space="preserve">
          <source>Components of HTTP-based systems</source>
          <target state="translated">HTTP 기반 시스템의 구성 요소</target>
        </trans-unit>
        <trans-unit id="c3c91e1eed116d8885305f2a420a8509e0cc75cc" translate="yes" xml:space="preserve">
          <source>Comprehensive list of MIME types useful for Web developers.</source>
          <target state="translated">웹 개발자에게 유용한 종합적인 MIME 유형 목록.</target>
        </trans-unit>
        <trans-unit id="e99b96873911e57f5de9103e887195406f68cd32" translate="yes" xml:space="preserve">
          <source>Compressing HTTP messages is one of the most important ways to improve the performance of a Web site, it shrinks the size of the data transmitted and makes better use of the available bandwidth; browsers always send this header and the server should be configured to abide to it and to use compression.</source>
          <target state="translated">HTTP 메시지를 압축하는 것은 웹 사이트의 성능을 향상시키는 가장 중요한 방법 중 하나이며, 전송되는 데이터의 크기를 줄이고 사용 가능한 대역폭을 더 잘 활용합니다. 브라우저는 항상이 헤더를 보내고 서버는이를 준수하고 압축을 사용하도록 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="b19ee5750a4f428fdbb3471286458f10f3749ac9" translate="yes" xml:space="preserve">
          <source>Compressing with gzip</source>
          <target state="translated">gzip으로 압축</target>
        </trans-unit>
        <trans-unit id="46ead4045fbadbc2f0b37b6046e5803972459710" translate="yes" xml:space="preserve">
          <source>Compression</source>
          <target state="translated">Compression</target>
        </trans-unit>
        <trans-unit id="5b5a0baa20c54e0050cb20d7eb082ba182a1b5ec" translate="yes" xml:space="preserve">
          <source>Compression can allow an attacker to recover secret data when it is
   compressed in the same context as data under attacker control.
   HTTP/2 enables compression of header fields (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;); the
   following concerns also apply to the use of HTTP compressed content-
   codings (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;[RFC7231], Section&amp;nbsp;3.1.2.1&lt;/a&gt;).

   There are demonstrable attacks on compression that exploit the
   characteristics of the web (e.g., [&lt;a href=&quot;#ref-BREACH&quot;&gt;BREACH&lt;/a&gt;]).  The attacker induces
   multiple requests containing varying plaintext, observing the length
   of the resulting ciphertext in each, which reveals a shorter length
   when a guess about the secret is correct. 

   Implementations communicating on a secure channel MUST NOT compress
   content that includes both confidential and attacker-controlled data
   unless separate compression dictionaries are used for each source of
   data.  Compression MUST NOT be used if the source of data cannot be
   reliably determined.  Generic stream compression, such as that
   provided by TLS, MUST NOT be used with HTTP/2 (see &lt;a href=&quot;#section-9.2&quot;&gt;Section 9.2&lt;/a&gt;).

   Further considerations regarding the compression of header fields are
   described in [&lt;a href=&quot;#ref-COMPRESSION&quot;&gt;COMPRESSION&lt;/a&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b0ce5a72c7b5ba41f70c30e64c6c6b62713bf9" translate="yes" xml:space="preserve">
          <source>Compression: compress and optimize content to speed up load time.</source>
          <target state="translated">압축 : 컨텐츠를 압축 및 최적화하여로드 시간을 단축합니다.</target>
        </trans-unit>
        <trans-unit id="afa306b4fc5fbd90b0a114f6bd08ca2cc8754f57" translate="yes" xml:space="preserve">
          <source>Concatenates the four dot-separated bytes into one 4-byte word and converts it to decimal.</source>
          <target state="translated">4 개의 도트로 구분 된 바이트를 하나의 4 바이트 워드로 연결하고 10 진수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b5c1cd3785db2824d1ab278c24866501932dedaf" translate="yes" xml:space="preserve">
          <source>Concepts and usage</source>
          <target state="translated">개념과 사용법</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="9a261b82a98b8bdc6d75dae90ec8ee01b54eeff4" translate="yes" xml:space="preserve">
          <source>Conditional headers</source>
          <target state="translated">조건부 헤더</target>
        </trans-unit>
        <trans-unit id="8bcd73be2170abf93875e1fa36640534488be6c5" translate="yes" xml:space="preserve">
          <source>Conditional range requests</source>
          <target state="translated">조건부 범위 요청</target>
        </trans-unit>
        <trans-unit id="32f3486df02697cc767cdf9f317b7c01b4f54138" translate="yes" xml:space="preserve">
          <source>Conditional requests</source>
          <target state="translated">조건부 요청</target>
        </trans-unit>
        <trans-unit id="b96d7430d9350e321fe2f05974da38d1376f5101" translate="yes" xml:space="preserve">
          <source>Conditional requests allow implementing the &lt;em&gt;optimistic locking algorithm&lt;/em&gt; (used by most wikis or source control systems). The concept is to allow all clients to get copies of the resource, then let them modify it locally, controlling concurrency by successfully allowing the first client submitting an update. All subsequent updates, based on the now obsolete version of the resource, are rejected:</source>
          <target state="translated">조건부 요청을 통해 &lt;em&gt;낙관적 잠금 알고리즘&lt;/em&gt; (대부분의 Wiki 또는 소스 제어 시스템에서 사용)을 구현할 수 있습니다. 개념은 모든 클라이언트가 자원의 사본을 확보 한 다음 로컬로 수정하여 첫 번째 클라이언트가 업데이트를 제출하도록 허용함으로써 동시성을 제어하도록하는 것입니다. 더 이상 사용되지 않는 리소스 버전을 기반으로하는 모든 후속 업데이트는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="bb657402b08e081af170034d16476c261b3e0bd6" translate="yes" xml:space="preserve">
          <source>Conditional requests are HTTP requests [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;] that include one or
   more header fields indicating a precondition to be tested before
   applying the method semantics to the target resource.  This document
   defines the HTTP/1.1 conditional request mechanisms in terms of the
   architecture, syntax notation, and conformance criteria defined in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;].

   Conditional GET requests are the most efficient mechanism for HTTP
   cache updates [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;].  Conditionals can also be applied to
   state-changing methods, such as PUT and DELETE, to prevent the &quot;lost
   update&quot; problem: one client accidentally overwriting the work of
   another client that has been acting in parallel.

   Conditional request preconditions are based on the state of the
   target resource as a whole (its current value set) or the state as
   observed in a previously obtained representation (one value in that
   set).  A resource might have multiple current representations, each
   with its own observable state.  The conditional request mechanisms
   assume that the mapping of requests to a &quot;selected representation&quot;
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC7231]&lt;/a&gt;) will be consistent over time if the server
   intends to take advantage of conditionals.  Regardless, if the
   mapping is inconsistent and the server is unable to select the
   appropriate representation, then no harm will result when the
   precondition evaluates to false.

   The conditional request preconditions defined by this specification
   (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) are evaluated when applicable to the recipient
   (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;) according to their order of precedence (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).</source>
          <target state="translated">조건부 요청은 메소드 시맨틱을 대상 자원에 적용하기 전에 테스트 할 전제 조건을 나타내는 하나 이상의 헤더 필드를 포함하는 HTTP 요청 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ]입니다. 이 문서는 HTTP / 1.1 조건부 요청 메커니즘을 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]에 정의 된 아키텍처, 구문 표기법 및 적합성 기준과 관련하여 정의 합니다. 조건부 GET 요청은 HTTP 캐시 업데이트를위한 가장 효율적인 메커니즘입니다. [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;]. &quot;손실 된 업데이트&quot;문제를 방지하기 위해 PUT 및 DELETE와 같은 상태 변경 방법에도 조건을 적용 할 수 있습니다. 한 클라이언트가 실수로 병렬로 작업 한 다른 클라이언트의 작업을 덮어 씁니다. 조건부 요청 전제 조건은 대상 자원의 전체 상태 (현재 값 세트) 또는 이전에 얻은 표현에서 관찰 된 상태 (해당 세트의 하나의 값)를 기반으로합니다. 자원에는 각각 자체 관찰 가능한 상태를 가진 여러 개의 현재 표현이있을 수 있습니다. 조건부 요청 메커니즘은 요청을 &quot;선택된 표현&quot;에 매핑한다고 가정합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3&quot;&gt;[RFC7231]의 섹션 3&lt;/a&gt;)는 서버가 조건을 활용하려는 경우 시간이 지남에 따라 일관됩니다. 그럼에도 불구하고 매핑이 일치하지 않고 서버가 적절한 표현을 선택할 수없는 경우 전제 조건이 거짓으로 평가 될 때 해가 발생하지 않습니다. 본 명세서 ( &lt;a href=&quot;#section-3&quot;&gt;섹션 3&lt;/a&gt; )에 의해 정의 된 조건부 요청 전제 조건 은 우선 순위 ( &lt;a href=&quot;#section-6&quot;&gt;섹션 6&lt;/a&gt; ) 에 따라 수신자 ( &lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt; )에 적용 가능한 경우 평가된다 .</target>
        </trans-unit>
        <trans-unit id="f8c4083d3ac1096a523190657f90870d3b790d6a" translate="yes" xml:space="preserve">
          <source>Conditional requests are a key feature of HTTP, and allow the building of efficient and complex applications. For caching or resuming downloads, the only work required for webmasters is to configure the server correctly; setting correct etags in some environments can be tricky. Once achieved, the browser will serve the expected conditional requests.</source>
          <target state="translated">조건부 요청은 HTTP의 주요 기능이며 효율적이고 복잡한 애플리케이션을 빌드 할 수 있습니다. 다운로드 캐싱 또는 다시 시작의 경우 웹 마스터에게 필요한 유일한 작업은 서버를 올바르게 구성하는 것입니다. 일부 환경에서 올바른 etag를 설정하는 것은 까다로울 수 있습니다. 일단 달성되면 브라우저는 예상되는 조건부 요청을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="d6a56385d0729f6ff4bf27671cc845cb6f2cfde5" translate="yes" xml:space="preserve">
          <source>Conditionals</source>
          <target state="translated">Conditionals</target>
        </trans-unit>
        <trans-unit id="168256d8522ab8aa1e488cbca9a371a273b318a6" translate="yes" xml:space="preserve">
          <source>Confidential or sensitive information should never be stored or transmitted in HTTP Cookies, as the entire mechanism is inherently insecure.</source>
          <target state="translated">전체 메커니즘이 본질적으로 안전하지 않기 때문에 기밀 또는 민감한 정보는 HTTP 쿠키에 저장하거나 전송해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b6f09b9822b4fcc7ee7448f402f4626bb6d634c3" translate="yes" xml:space="preserve">
          <source>Configuring Apache</source>
          <target state="translated">아파치 설정</target>
        </trans-unit>
        <trans-unit id="5aa009cf30d646a189a2b32b2e2f211086ce4d68" translate="yes" xml:space="preserve">
          <source>Configuring Content Security Policy involves adding the &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header to a web page and giving it values to control resources the user agent is allowed to load for that page. For example, a page that uploads and displays images could allow images from anywhere, but restrict a form action to a specific endpoint. A properly designed Content Security Policy helps protect a page against a cross site scripting attack. This article explains how to construct such headers properly, and provides examples.</source>
          <target state="translated">콘텐츠 보안 정책을 구성 하려면 웹 페이지에 &lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; HTTP 헤더를 추가하고 해당 페이지에 대해 사용자 에이전트가로드 할 수있는 리소스를 제어하는 ​​값을 제공해야합니다. 예를 들어, 이미지를 업로드하고 표시하는 페이지는 어디에서나 이미지를 허용하지만 양식 작업을 특정 엔드 포인트로 제한 할 수 있습니다. 올바르게 설계된 콘텐츠 보안 정책은 사이트 간 스크립팅 공격으로부터 페이지를 보호합니다. 이 기사에서는 이러한 헤더를 올바르게 구성하는 방법을 설명하고 예제를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="10fe25707b2c8df561d63aa0f93126ee95f3147f" translate="yes" xml:space="preserve">
          <source>Configuring Content Security Policy involves adding the &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header to a web page and giving it values to control what resources the user agent is allowed to load for that page. For example, a page that uploads and displays images could allow images from anywhere, but restrict a form action to a specific endpoint. A properly designed Content Security Policy helps protect a page against a cross site scripting attack. This article explains how to construct such headers properly, and provides examples.</source>
          <target state="translated">Configuring Content Security Policy involves adding the &lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; HTTP header to a web page and giving it values to control what resources the user agent is allowed to load for that page. For example, a page that uploads and displays images could allow images from anywhere, but restrict a form action to a specific endpoint. A properly designed Content Security Policy helps protect a page against a cross site scripting attack. This article explains how to construct such headers properly, and provides examples.</target>
        </trans-unit>
        <trans-unit id="7daf13b1f60fb4af3d6921cd3bc4aced67ab5a7a" translate="yes" xml:space="preserve">
          <source>Configuring Express</source>
          <target state="translated">Express 구성</target>
        </trans-unit>
        <trans-unit id="6f39d4583059888ab118eae8d20c986e51f1274e" translate="yes" xml:space="preserve">
          <source>Configuring HAProxy</source>
          <target state="translated">HAProxy 구성</target>
        </trans-unit>
        <trans-unit id="d70d5fc578cb203b115c05b384a205e2f62a043b" translate="yes" xml:space="preserve">
          <source>Configuring IIS</source>
          <target state="translated">IIS 구성</target>
        </trans-unit>
        <trans-unit id="2031ab4ee84e7e349fa32c5b2095aa6cafb6bd65" translate="yes" xml:space="preserve">
          <source>Configuring nginx</source>
          <target state="translated">nginx 구성</target>
        </trans-unit>
        <trans-unit id="532521e6c325d8d9c38dfb2c90ab768c58d19d39" translate="yes" xml:space="preserve">
          <source>Configuring prefetching in the browser</source>
          <target state="translated">브라우저에서 프리 페치 구성</target>
        </trans-unit>
        <trans-unit id="cfe2338ad9f0d231c9e7e937eb36ba083fe3da49" translate="yes" xml:space="preserve">
          <source>Configuring redirects in common servers</source>
          <target state="translated">공통 서버에서 리디렉션 구성</target>
        </trans-unit>
        <trans-unit id="82949d3ffebaebf9aadf54999c74e7c2fdc71165" translate="yes" xml:space="preserve">
          <source>Conflicts are most likely to occur in response to a &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; request. For example, you may get a 409 response when uploading a file which is older than the one already on the server resulting in a version control conflict.</source>
          <target state="translated">&lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 요청 에 대한 응답으로 충돌이 발생할 가능성이 높습니다 . 예를 들어 서버에 이미있는 파일보다 오래된 파일을 업로드하면 버전 제어 충돌이 발생하여 409 응답이 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6512ee1541e9a6c52d5bf7cf465332e8df25ea3c" translate="yes" xml:space="preserve">
          <source>Connection</source>
          <target state="translated">Connection</target>
        </trans-unit>
        <trans-unit id="32e5f579d6704066fd06ba7fbc38b931e1dbb869" translate="yes" xml:space="preserve">
          <source>Connection (RFC 2616)</source>
          <target state="translated">연결 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="1f3fc181701dc7eaafa3f89e076f2b6541c863f2" translate="yes" xml:space="preserve">
          <source>Connection Management (RFC 7230)</source>
          <target state="translated">연결 관리 (RFC 7230)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
