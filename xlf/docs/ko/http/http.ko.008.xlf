<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="973c4945198f89ca852f9330ea8ecbaa87253ef7" translate="yes" xml:space="preserve">
          <source>There is effort from browsers in moving to a stricter default value, namely &lt;code&gt;strict-origin-when-cross-origin&lt;/code&gt; (see &lt;a href=&quot;https://github.com/whatwg/fetch/pull/952&quot;&gt;https://github.com/whatwg/fetch/pull/952&lt;/a&gt;), consider using this value (or a stricter one), if possible, when changing the Referrer-Policy.</source>
          <target state="translated">There is effort from browsers in moving to a stricter default value, namely &lt;code&gt;strict-origin-when-cross-origin&lt;/code&gt; (see &lt;a href=&quot;https://github.com/whatwg/fetch/pull/952&quot;&gt;https://github.com/whatwg/fetch/pull/952&lt;/a&gt;), consider using this value (or a stricter one), if possible, when changing the Referrer-Policy.</target>
        </trans-unit>
        <trans-unit id="357745e961c49e7808944a7f96ad3fca2b616dd4" translate="yes" xml:space="preserve">
          <source>There is no content to send for this request, but the headers may be useful. The user-agent may update its cached headers for this resource with the new ones.</source>
          <target state="translated">이 요청에 보낼 내용이 없지만 헤더가 유용 할 수 있습니다. 사용자 에이전트는이 자원에 대한 캐시 된 헤더를 새로운 것으로 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f5a6e5a3d7f30adf4bc4c7e14047c3ad52fec62" translate="yes" xml:space="preserve">
          <source>There is no way to deal with this problem without annoying one of the two clients. However, lost updates and race conditions are to be avoided. We want predictable results, and expect that the clients are notified when their changes are rejected.</source>
          <target state="translated">두 클라이언트 중 하나를 성가 시게하지 않고이 문제를 처리 할 방법이 없습니다. 그러나 손실 된 업데이트 및 경쟁 조건은 피해야합니다. 우리는 예측 가능한 결과를 원하며, 변경 사항이 거부되면 고객에게 알림을받을 것으로 기대합니다.</target>
        </trans-unit>
        <trans-unit id="5746b1d21828f38918b30138869ef276f2228158" translate="yes" xml:space="preserve">
          <source>There is one associative array already defined (because a JavaScript currently cannot define them on its own):</source>
          <target state="translated">JavaScript가 현재 자체적으로 정의 할 수 없기 때문에 이미 정의 된 연관 배열이 하나 있습니다.</target>
        </trans-unit>
        <trans-unit id="d277b5fa967b80dbc6939e7b654fcee1641c47de" translate="yes" xml:space="preserve">
          <source>There may be cases where a client wishes to submit state tokens, but
   doesn't want the request to fail just because the state token isn't
   current anymore.  One simple way to do this is to include a Condition
   that is known to always evaluate to true, such as in:

     If: (&amp;lt;urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt;)
       (Not &amp;lt;DAV:no-lock&amp;gt;)

   &quot;DAV:no-lock&quot; is known to never represent a current lock token.  Lock
   tokens are assigned by the server, following the uniqueness
   requirements described in &lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;, therefore cannot use the
   &quot;DAV:&quot; scheme.  Thus, by applying &quot;Not&quot; to a state token that is 

   known not to be current, the Condition always evaluates to true.
   Consequently, the whole If header will always evaluate to true, and
   the lock token urn:uuid:181d4fae-7d8c-11d0-a765-00a0c91e6bf2 will be
   submitted in any case.</source>
          <target state="translated">클라이언트가 상태 토큰을 제출하려고하지만 상태 토큰이 더 이상 최신 상태가 아니기 때문에 요청이 실패하는 것을 원하지 않는 경우가 있습니다. 이를 수행하는 한 가지 간단한 방법은 다음과 같이 항상 true로 평가되는 것으로 알려진 조건을 포함하는 것입니다. If : (&amp;lt;urn : uuid : 181d4fae-7d8c-11d0-a765-00a0c91e6bf2&amp;gt;) lock&amp;gt;) &quot;DAV : no-lock&quot;은 현재 잠금 토큰을 나타내지 않는 것으로 알려져 있습니다. &lt;a href=&quot;#section-6.5&quot;&gt;6.5에&lt;/a&gt; 설명 된 고유성 요구 사항에 따라 서버에서 잠금 토큰을 할당합니다.따라서 &quot;DAV :&quot;체계를 사용할 수 없습니다. 따라서 현재 상태가 아닌 것으로 알려진 상태 토큰에 &quot;Not&quot;을 적용하면 Condition이 항상 true로 평가됩니다. 따라서 전체 If 헤더는 항상 true로 평가되며 잠금 토큰 urn : uuid : 181d4fae-7d8c-11d0-a765-00a0c91e6bf2는 어떤 경우에도 제출됩니다.</target>
        </trans-unit>
        <trans-unit id="ea32afad30d9372a076356ddcbf2224780548842" translate="yes" xml:space="preserve">
          <source>There may be other regulations governing the use of cookies in your locality. The burden is on you to know and comply with these regulations. There are companies that offer &quot;cookie banner&quot; code that helps you comply with these regulations.</source>
          <target state="translated">There may be other regulations governing the use of cookies in your locality. The burden is on you to know and comply with these regulations. There are companies that offer &quot;cookie banner&quot; code that helps you comply with these regulations.</target>
        </trans-unit>
        <trans-unit id="2490d9396fd52fc708c5e36b206a6d2e488dee63" translate="yes" xml:space="preserve">
          <source>There should always be a confirmation required for any sensitive action.</source>
          <target state="translated">민감한 조치에는 항상 확인이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="291573b8b0016bfdbfee8add5e78d0c5e2c87fdd" translate="yes" xml:space="preserve">
          <source>There was one associative array (object) already defined, because at the time JavaScript code was unable to define it by itself:</source>
          <target state="translated">There was one associative array (object) already defined, because at the time JavaScript code was unable to define it by itself:</target>
        </trans-unit>
        <trans-unit id="9a8936e6969eea24b3ea42fd8769c85fdddd316b" translate="yes" xml:space="preserve">
          <source>These HTTP codes are not redefined, but their use is somewhat
   extended by WebDAV methods and requirements.  In general, many HTTP
   status codes can be used in response to any request, not just in
   cases described in this document.  Note also that WebDAV servers are
   known to use 300-level redirect responses (and early interoperability
   tests found clients unprepared to see those responses).  A 300-level
   response MUST NOT be used when the server has created a new resource
   in response to the request.</source>
          <target state="translated">이러한 HTTP 코드는 재정의되지 않지만 WebDAV 메소드 및 요구 사항에 의해 사용이 다소 확장됩니다. 일반적으로이 문서에 설명 된 경우뿐만 아니라 모든 HTTP 상태 코드를 모든 요청에 ​​응답하여 사용할 수 있습니다. 또한 WebDAV 서버는 300 수준의 리디렉션 응답을 사용하는 것으로 알려져 있으며 초기 상호 운용성 테스트에서 클라이언트가 해당 응답을 볼 수없는 것으로 나타났습니다. 서버가 요청에 대한 응답으로 새 리소스를 생성 한 경우 300 수준 응답을 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d2011ed2f18ef5bdd96144452aa6435ca84d3624" translate="yes" xml:space="preserve">
          <source>These URLs are examples &amp;mdash; the site could serve the different filetypes with any URL patterns it wishes, such as a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search&quot;&gt;query string parameter&lt;/a&gt;: &lt;code&gt;/documents/foo?format=json&lt;/code&gt;, &lt;code&gt;/documents/foo?format=xml&lt;/code&gt;, and so on.</source>
          <target state="translated">이러한 URL은 예입니다 - 사이트가 같은 같은이 원하는 모든 URL 패턴과 다른 파일 형식 봉사 할 수 있었다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search&quot;&gt;쿼리 문자열 매개 변수를&lt;/a&gt; : &lt;code&gt;/documents/foo?format=json&lt;/code&gt; , &lt;code&gt;/documents/foo?format=xml&lt;/code&gt; , 등등.</target>
        </trans-unit>
        <trans-unit id="19ac2e7adff1466c1a8f79fcbd5235600c8aac56" translate="yes" xml:space="preserve">
          <source>These URLs will be rewritten before the request is made, meaning that no insecure requests will hit the network. Note that, if the requested resource is not actually available via HTTPS, the request will fail without any fallback to HTTP.</source>
          <target state="translated">이러한 URL은 요청이 이루어지기 전에 다시 작성되므로 안전하지 않은 요청이 네트워크에 도달하지 않습니다. 요청 된 리소스를 실제로 HTTPS를 통해 사용할 수없는 경우 HTTP로 폴백하지 않고 요청이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="14aea1eca27b905f4bb97521d425369003cb4f07" translate="yes" xml:space="preserve">
          <source>These are some sample UA strings from other Gecko-based browsers on various platforms. Note that many of these have not yet been released on Gecko 2.0!</source>
          <target state="translated">다음은 다양한 플랫폼에서 다른 Gecko 기반 브라우저의 샘플 UA 문자열입니다. 이 중 다수는 아직 Gecko 2.0에서 출시되지 않았습니다!</target>
        </trans-unit>
        <trans-unit id="f6caceedce573b19f722b4be7d0ac77739c262ca" translate="yes" xml:space="preserve">
          <source>These are the values sent when the context doesn't give better information. Note that all browsers add the &lt;code&gt;*/*&lt;/code&gt; MIME Type to cover all cases. This is typically used for requests initiated via the address bar of a browser, or via an HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">컨텍스트가 더 나은 정보를 제공하지 않을 때 전송되는 값입니다. 모든 브라우저는 모든 경우를 다루기 위해 &lt;code&gt;*/*&lt;/code&gt; MIME 유형을 추가합니다 . 이는 일반적으로 브라우저의 주소 표시 줄 또는 HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 를 통해 시작된 요청에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="63ded4498d8ac164d315a41831a90dda911d2194" translate="yes" xml:space="preserve">
          <source>These four building blocks were completed by the end of 1990, and the first servers were already running outside of CERN by early 1991. On August 6&lt;sup&gt;th&lt;/sup&gt; 1991, Tim Berners-Lee's &lt;a href=&quot;https://groups.google.com/forum/#!msg/alt.hypertext/eCTkkOoWTAY/urNMgHnS2gYJ&quot;&gt;post&lt;/a&gt; on the public &lt;em&gt;alt.hypertext&lt;/em&gt; newsgroup is now considered as the official start of the World Wide Web as a public project.</source>
          <target state="translated">이 네 개의 빌딩 블록은 1990 년 말까지 완료하고, 첫 번째 서버는 이미 8 월 6 일 이른 1991 년으로 CERN의 외부에서 실행 된 &lt;sup&gt;일&lt;/sup&gt; , 팀 버너스 - 리 1991 년 &lt;a href=&quot;https://groups.google.com/forum/#!msg/alt.hypertext/eCTkkOoWTAY/urNMgHnS2gYJ&quot;&gt;이후&lt;/a&gt; 대중에 &lt;em&gt;alt.hypertext의&lt;/em&gt; 뉴스 그룹은 이제 공식으로 간주됩니다 공개 프로젝트로 월드 와이드 웹의 시작.</target>
        </trans-unit>
        <trans-unit id="0baa00267d012f566fcf313a5a48be2638b11dd3" translate="yes" xml:space="preserve">
          <source>These four building blocks were completed by the end of 1990, and the first servers were already running outside of CERN by early 1991. On August 6&lt;sup&gt;th&lt;/sup&gt; 1991, Tim Berners-Lee's &lt;a href=&quot;https://www.w3.org/People/Berners-Lee/1991/08/art-6484.txt&quot;&gt;post&lt;/a&gt; on the public &lt;em&gt;alt.hypertext&lt;/em&gt; newsgroup is now considered as the official start of the World Wide Web as a public project.</source>
          <target state="translated">These four building blocks were completed by the end of 1990, and the first servers were already running outside of CERN by early 1991. On August 6&lt;sup&gt;th&lt;/sup&gt; 1991, Tim Berners-Lee's &lt;a href=&quot;https://www.w3.org/People/Berners-Lee/1991/08/art-6484.txt&quot;&gt;post&lt;/a&gt; on the public &lt;em&gt;alt.hypertext&lt;/em&gt; newsgroup is now considered as the official start of the World Wide Web as a public project.</target>
        </trans-unit>
        <trans-unit id="fe283302753b3d4f0050a7e568fff6e5641e1e65" translate="yes" xml:space="preserve">
          <source>These functions can be used in building the PAC file:</source>
          <target state="translated">이 기능들은 PAC 파일을 만드는 데 사용될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1a84013246b548f38ea0c6cbcd4306fd09b1fd50" translate="yes" xml:space="preserve">
          <source>These headers &lt;em&gt;must&lt;/em&gt; be transmitted to the final recipient of the message: the server for a request, or the client for a response. Intermediate proxies must retransmit these headers unmodified and caches must store them.</source>
          <target state="translated">These headers &lt;em&gt;must&lt;/em&gt; be transmitted to the final recipient of the message: the server for a request, or the client for a response. Intermediate proxies must retransmit these headers unmodified and caches must store them.</target>
        </trans-unit>
        <trans-unit id="adec7a72aca0f353da15e6ce23d6fb621cfcba41" translate="yes" xml:space="preserve">
          <source>These headers are meaningful only for a single transport-level connection and must not be retransmitted by proxies or cached. Such headers are: &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/trailer&quot;&gt;&lt;code&gt;Trailer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt;. Note that only hop-by-hop headers may be set using the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; general header.</source>
          <target state="translated">이 헤더는 단일 전송 레벨 연결에만 의미가 있으며 프록시에 의해 재전송되거나 캐시되지 않아야합니다. 이러한 헤더는 &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/trailer&quot;&gt; &lt;code&gt;Trailer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 일반 헤더를 사용하여 홉별 헤더 만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6d30d003653ac1d60828803e6858dd6022c5e88" translate="yes" xml:space="preserve">
          <source>These headers are meaningful only for a single transport-level connection, and &lt;em&gt;must not&lt;/em&gt; be retransmitted by proxies or cached. Note that only hop-by-hop headers may be set using the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; general header.</source>
          <target state="translated">These headers are meaningful only for a single transport-level connection, and &lt;em&gt;must not&lt;/em&gt; be retransmitted by proxies or cached. Note that only hop-by-hop headers may be set using the &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; general header.</target>
        </trans-unit>
        <trans-unit id="ed24fa2e76be943bae964dfeca098c8b6b9d0285" translate="yes" xml:space="preserve">
          <source>These headers must be transmitted to the final recipient of the message; that is, the server for a request or the client for a response. Intermediate proxies must retransmit end-to-end headers unmodified and caches must store them.</source>
          <target state="translated">이 헤더는 메시지의 최종 수신자에게 전송되어야합니다. 즉, 요청을위한 서버 또는 응답을위한 클라이언트입니다. 중간 프록시는 수정되지 않은 엔드 투 엔드 헤더를 재전송해야하며 캐시는이를 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="49c4698bda080192aa7cae79c66f0082e395ce72" translate="yes" xml:space="preserve">
          <source>These novelties have not been introduced as concerted effort, but as a try-and-see approach over the 1991-1995 period: a server and a browser added one feature and it saw if it get traction. A lot of interoperability problems were common. In November 1996, in order to solve these annoyances, an informational document describing the common practices has been published, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;. This is the definition of HTTP/1.0 and it is notable that, in the narrow sense of the term, it isn't an official standard.</source>
          <target state="translated">이러한 참신함은 공동 노력으로 소개 된 것이 아니라 1991-1995 년에 걸친 시도와 접근 방식으로 소개되었습니다 : 서버와 브라우저는 하나의 기능을 추가하여 견인력을 얻었는지 확인했습니다. 많은 상호 운용성 문제가 일반적이었습니다. 1996 년 11 월, 이러한 성가심을 해결하기 위해 일반적인 관행을 설명하는 정보 문서 인 &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; 가 발표되었습니다 . 이것은 HTTP / 1.0의 정의이며, 좁은 의미에서 공식 표준이 아니라는 점이 주목할 만하다.</target>
        </trans-unit>
        <trans-unit id="970955263d6d4ddd63f73c663170a288a2997da3" translate="yes" xml:space="preserve">
          <source>These novelties have not been introduced as concerted effort, but as a try-and-see approach over the 1991-1995 period: a server and a browser added one feature and it saw if it got traction. A lot of interoperability problems were common. In November 1996, in order to solve these annoyances, an informational document describing the common practices has been published, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;. This is the definition of HTTP/1.0 and it is notable that, in the narrow sense of the term, it isn't an official standard.</source>
          <target state="translated">These novelties have not been introduced as concerted effort, but as a try-and-see approach over the 1991-1995 period: a server and a browser added one feature and it saw if it got traction. A lot of interoperability problems were common. In November 1996, in order to solve these annoyances, an informational document describing the common practices has been published, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;. This is the definition of HTTP/1.0 and it is notable that, in the narrow sense of the term, it isn't an official standard.</target>
        </trans-unit>
        <trans-unit id="0c3e47aa5ab3cee6753961966b6b7cea5b1c2b29" translate="yes" xml:space="preserve">
          <source>These redirections are meant to last forever. They imply that the original URL should no longer be used, and replaced with the new one.Search engine robots, RSS readers, and other crawlers will update the original URL for the resource.</source>
          <target state="translated">These redirections are meant to last forever. They imply that the original URL should no longer be used, and replaced with the new one.Search engine robots, RSS readers, and other crawlers will update the original URL for the resource.</target>
        </trans-unit>
        <trans-unit id="c006f1681899103b8b2e153338a77be2fac29883" translate="yes" xml:space="preserve">
          <source>These redirections are meant to last forever. They imply that the original URL should not be used anymore and that the new one is preferred. Search engine robots trigger an update of the associated URL for the resource in their indexes.</source>
          <target state="translated">이러한 방향 전환은 영원히 지속됩니다. 그들은 원래 URL을 더 이상 사용해서는 안되며 새로운 URL을 선호한다는 것을 의미합니다. 검색 엔진 로봇은 색인에서 리소스에 대한 관련 URL 업데이트를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="a400740c640b1a2456fc464d677ae89fe9a9ea33" translate="yes" xml:space="preserve">
          <source>These regulations have global reach, because they apply to any site on the &lt;em&gt;World Wide&lt;/em&gt; Web that is accessed by users from these jurisdictions (the EU and California, with the caveat that California's law applies only to entities with gross revenue over 25 million USD, among other things.)</source>
          <target state="translated">These regulations have global reach, because they apply to any site on the &lt;em&gt;World Wide&lt;/em&gt; Web that is accessed by users from these jurisdictions (the EU and California, with the caveat that California's law applies only to entities with gross revenue over 25 million USD, among other things.)</target>
        </trans-unit>
        <trans-unit id="d896ad159048e4b552eaa0836d02af56e04f2aad" translate="yes" xml:space="preserve">
          <source>These regulations include requirements such as:</source>
          <target state="translated">These regulations include requirements such as:</target>
        </trans-unit>
        <trans-unit id="a3faadcdd29a9a6bfd08a2c7df57422c7e3b140f" translate="yes" xml:space="preserve">
          <source>These types of manipulations can be prevented by disallowing Javascript via the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; CSP directive.</source>
          <target state="translated">&lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt; CSP 지시문을 통해 Javascript를 허용하지 않으면 이러한 유형의 조작을 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b94cf424727db244876c5a0b8a36ae1be82af513" translate="yes" xml:space="preserve">
          <source>They exist. They are hard to defend against. Research continues.
   Beware.</source>
          <target state="translated">존재합니다. 그들은 방어하기 어렵다. 연구는 계속됩니다. 조심하십시오.</target>
        </trans-unit>
        <trans-unit id="2b2bbfc5127ae16613bef18603ec77b3984aa83a" translate="yes" xml:space="preserve">
          <source>They should always provide a way to overcome the server-chosen language, e.g., by providing a language menu on the site. Most user-agents provide a default value for the &lt;code&gt;Accept-Language&lt;/code&gt; header, adapted to the user interface language and end users often do not modify it, either by not knowing how, or by not being able to do it, as in an Internet caf&amp;eacute; for instance.</source>
          <target state="translated">예를 들어 사이트에서 언어 메뉴를 제공하여 서버가 선택한 언어를 극복 할 수있는 방법을 항상 제공해야합니다. 대부분의 사용자 에이전트는 &lt;code&gt;Accept-Language&lt;/code&gt; 헤더에 기본값을 제공하며 사용자 인터페이스 언어에 적합하며 최종 사용자는 인터넷 카페에서와 같이 방법을 모르거나 수행 할 수 없어서 수정하지 않는 경우가 많습니다. 예를 들어.</target>
        </trans-unit>
        <trans-unit id="d3bab67bcd21378560c58ae4bc5a035031a2e0e6" translate="yes" xml:space="preserve">
          <source>Third-party cookies</source>
          <target state="translated">타사 쿠키</target>
        </trans-unit>
        <trans-unit id="78174180aec78d0cf1800defae73ef9440efe127" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt; and worker are blocked and won't load:</source>
          <target state="translated">이 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 작업자는 차단되어로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f02d516991c23089fc7ef470b5b1f7122a1b1ddc" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://fetch.spec.whatwg.org/#http-cors-protocol&quot;&gt;cross-origin sharing standard&lt;/a&gt; can enable cross-site HTTP requests for:</source>
          <target state="translated">This &lt;a href=&quot;https://fetch.spec.whatwg.org/#http-cors-protocol&quot;&gt;cross-origin sharing standard&lt;/a&gt; can enable cross-site HTTP requests for:</target>
        </trans-unit>
        <trans-unit id="dd32e06ea9f72392b7e2d0f29fca1199727c26bb" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;https://fetch.spec.whatwg.org/#http-cors-protocol&quot;&gt;cross-origin sharing standard&lt;/a&gt; is used to enable cross-site HTTP requests for:</source>
          <target state="translated">이 &lt;a href=&quot;https://fetch.spec.whatwg.org/#http-cors-protocol&quot;&gt;교차 출처 공유 표준&lt;/a&gt; 은 다음에 대한 사이트 간 HTTP 요청을 활성화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="451546fb091c1c1b7ec24fc3cf824086880d3078" translate="yes" xml:space="preserve">
          <source>This Warning code MUST be added by a proxy if it applies any
   transformation to the representation, such as changing the
   content-coding, media-type, or modifying the representation data,
   unless this Warning code already appears in the response.</source>
          <target state="translated">이 경고 코드가 응답에이 경고 코드가 이미 표시되어 있지 않은 경우 내용 코딩, 미디어 유형 변경 또는 표현 데이터 수정과 같은 표현에 변환을 적용하는 경우 반드시이 경고 코드를 프록시에 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c5ceee1b632af499883fff54e65911348e83c82" translate="yes" xml:space="preserve">
          <source>This Webpage has a redirect loop</source>
          <target state="translated">This Webpage has a redirect loop</target>
        </trans-unit>
        <trans-unit id="18ecbc255cf2ecd1c85dbf2f6ac85289ceb68820" translate="yes" xml:space="preserve">
          <source>This allows the &lt;code&gt;X-My-Custom-Header&lt;/code&gt; and &lt;code&gt;X-Another-Custom-Header&lt;/code&gt; headers to be exposed to the browser.</source>
          <target state="translated">이를 통해 &lt;code&gt;X-My-Custom-Header&lt;/code&gt; 및 &lt;code&gt;X-Another-Custom-Header&lt;/code&gt; 헤더가 브라우저에 노출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d793e4bdbd751c7b733ab0e15d263a1a9069b84e" translate="yes" xml:space="preserve">
          <source>This appendix is informative.

   The Relax NG schema explicitly excludes elements in the Atom Protocol
   namespace that are not defined in this revision of the specification.
   Requirements for Atom Protocol processors encountering such markup
   are given in Sections &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; and &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; of [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].

   The Schema for Service Documents:

   # -*- rnc -*- # RELAX NG Compact Syntax Grammar for the Atom Protocol

   namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;
   namespace atom = &quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;
   namespace xsd = &quot;&lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt;&quot;
   namespace xhtml = &quot;&lt;a href=&quot;http://www.w3.org/1999/xhtml&quot;&gt;http://www.w3.org/1999/xhtml&lt;/a&gt;&quot;
   namespace local = &quot;&quot;

   start = appService

   # common:attrs

   atomURI = text

   appCommonAttributes =
      attribute xml:base { atomURI }?,
      attribute xml:lang { atomLanguageTag  }?,
      attribute xml:space {&quot;default&quot;|&quot;preserved&quot;}?,
      undefinedAttribute*

   atomCommonAttributes = appCommonAttributes

   undefinedAttribute = attribute * - (xml:base | xml:space  | xml:lang
     | local:*) { text }

   atomLanguageTag = xsd:string {
      pattern = &quot;([A-Za-z]{1,8}(-[A-Za-z0-9]{1,8})*)?&quot;
   } 

   atomDateConstruct =
       appCommonAttributes,
       xsd:dateTime

   # app:service
   appService =
      element app:service {
         appCommonAttributes,
         ( appWorkspace+
           &amp;amp; extensionElement* )
      }

   # app:workspace

   appWorkspace =
      element app:workspace {
         appCommonAttributes,
         ( atomTitle
           &amp;amp; appCollection*
           &amp;amp; extensionSansTitleElement* )
      }

   atomTitle = element atom:title { atomTextConstruct }

   # app:collection

   appCollection =
      element app:collection {
         appCommonAttributes,
         attribute href { atomURI  },
         ( atomTitle
           &amp;amp; appAccept*
           &amp;amp; appCategories*
           &amp;amp; extensionSansTitleElement* )
      }

   # app:categories

   atomCategory =
       element atom:category {
          atomCommonAttributes,
          attribute term { text },
          attribute scheme { atomURI }?,
          attribute label { text }?,
          undefinedContent
       } 

   appInlineCategories =
       element app:categories {
           attribute fixed { &quot;yes&quot; | &quot;no&quot; }?,
           attribute scheme { atomURI }?,
           (atomCategory*,
           undefinedContent)
       }

   appOutOfLineCategories =
       element app:categories {
           attribute href { atomURI },
           undefinedContent
       }

   appCategories = appInlineCategories | appOutOfLineCategories

   # app:accept

   appAccept =
      element app:accept {
            appCommonAttributes,
            ( text? )
      }

   # Simple Extension

   simpleSansTitleExtensionElement =
      element * - (app:*|atom:title) {
         text
      }

   simpleExtensionElement =
      element * - (app:*) {
         text
      }

   # Structured Extension

   structuredSansTitleExtensionElement =
      element * - (app:*|atom:title) {
         (attribute * { text }+,
            (text|anyElement)*)
       | (attribute * { text }*,
          (text?, anyElement+, (text|anyElement)*))
      } 

   structuredExtensionElement =
      element * - (app:*) {
         (attribute * { text }+,
            (text|anyElement)*)
       | (attribute * { text }*,
          (text?, anyElement+, (text|anyElement)*))
      }

   # Other Extensibility

   extensionSansTitleElement =
    simpleSansTitleExtensionElement|structuredSansTitleExtensionElement

   extensionElement = simpleExtensionElement |
      structuredExtensionElement

   undefinedContent = (text|anyForeignElement)*

   # Extensions

   anyElement =
      element * {
         (attribute * { text }
          | text
          | anyElement)*
      }

   anyForeignElement =
       element * - app:* {
          (attribute * { text }
           | text
           | anyElement)*
       }

   atomPlainTextConstruct =
       atomCommonAttributes,
       attribute type { &quot;text&quot; | &quot;html&quot; }?,
       text

   atomXHTMLTextConstruct =
       atomCommonAttributes,
       attribute type { &quot;xhtml&quot; },
       xhtmlDiv

   atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct 

   anyXHTML = element xhtml:* {
       (attribute * { text }
        | text
        | anyXHTML)*
   }

   xhtmlDiv = element xhtml:div {
     (attribute * { text }
      | text
      | anyXHTML)*
   }

   # EOF

   The Schema for Category Documents:

   # -*- rnc -*- # RELAX NG Compact Syntax Grammar for the Atom Protocol

   namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;
   namespace atom = &quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;
   namespace xsd = &quot;&lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt;&quot;
   namespace local = &quot;&quot;

   start = appCategories

   atomCommonAttributes =
      attribute xml:base { atomURI }?,
      attribute xml:lang { atomLanguageTag }?,
      undefinedAttribute*

   undefinedAttribute = attribute * - (xml:base | xml:lang | local:*) {
     text }

   atomURI = text

   atomLanguageTag = xsd:string {
      pattern = &quot;([A-Za-z]{1,8}(-[A-Za-z0-9]{1,8})*)?&quot;
   }

   atomCategory =
       element atom:category {
          atomCommonAttributes,
          attribute term { text },
          attribute scheme { atomURI }?,
          attribute label { text }?,
          undefinedContent
       } 

   appInlineCategories =
       element app:categories {
           attribute fixed { &quot;yes&quot; | &quot;no&quot; }?,
           attribute scheme { atomURI }?,
           (atomCategory*,
           undefinedContent)
       }

   appOutOfLineCategories =
       element app:categories {
           attribute href { atomURI },
           (empty)
       }

   appCategories = appInlineCategories | appOutOfLineCategories

   # Extensibility

   undefinedContent = (text|anyForeignElement)*

   anyElement =
      element * {
         (attribute * { text }
          | text
          | anyElement)*
      }

   anyForeignElement =
       element * - atom:* {
          (attribute * { text }
           | text
           | anyElement)*
       }

   # EOF 

Authors' Addresses

   Joe Gregorio (editor)
   Google

   EMail: joe@bitworking.org
   URI:   &lt;a href=&quot;http://bitworking.org/&quot;&gt;http://bitworking.org/&lt;/a&gt;


   Bill de hOra (editor)
   NewBay Software

   EMail: bill@dehora.net
   URI:   &lt;a href=&quot;http://dehora.net/&quot;&gt;http://dehora.net/&lt;/a&gt; 

Full Copyright Statement

   Copyright (C) The IETF Trust (2007).

   This document is subject to the rights, licenses and restrictions
   contained in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt;, and except as set forth therein, the authors
   retain all their rights.

   This document and the information contained herein are provided on an
   &quot;AS IS&quot; basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS
   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND
   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS
   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF
   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED
   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.

Intellectual Property

   The IETF takes no position regarding the validity or scope of any
   Intellectual Property Rights or other rights that might be claimed to
   pertain to the implementation or use of the technology described in
   this document or the extent to which any license under such rights
   might or might not be available; nor does it represent that it has
   made any independent effort to identify any such rights.  Information
   on the procedures with respect to rights in RFC documents can be
   found in &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt;.

   Copies of IPR disclosures made to the IETF Secretariat and any
   assurances of licenses to be made available, or the result of an
   attempt made to obtain a general license or permission for the use of
   such proprietary rights by implementers or users of this
   specification can be obtained from the IETF on-line IPR repository at
   &lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt;.

   The IETF invites any interested party to bring to its attention any
   copyrights, patents or patent applications, or other proprietary
   rights that may cover technology that may be required to implement
   this standard.  Please address the information to the IETF at
   ietf-ipr@ietf.org.


Gregorio &amp;amp; de hOra          Standards Track                    [Page 53]</source>
          <target state="translated">이 부록은 유익한 정보입니다. Relax NG 스키마는이 사양 개정에 정의되지 않은 Atom 프로토콜 네임 스페이스의 요소를 명시 적으로 제외합니다. 이러한 마크 업이 발생하는 Atom 프로토콜 프로세서에 대한 요구 사항 은 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ] 의 섹션 &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; 및 &lt;a href=&quot;#section-6.3&quot;&gt;6.3&lt;/a&gt; 에 나와 있습니다. 서비스 문서의 스키마 : #-*-rnc-*-# Atom 프로토콜 네임 스페이스 앱의 RELAX NG 압축 구문 문법 = &quot; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &quot;네임 스페이스 atom = &quot; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http : // www.w3.org/2005/Atom&lt;/a&gt; &quot;네임 스페이스 xsd =&quot; &lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt; &quot;네임 스페이스 xhtml =&quot; &lt;a href=&quot;http://www.w3.org/1999/xhtml&quot;&gt;http://www.w3.org/1999/xhtml&lt;/a&gt;&quot;namespace local =&quot; &quot;start = appService # common : attrs atomURI = text appCommonAttributes = attribute xml : base {atomURI} ?, attribute xml : lang {atomLanguageTag} ?, attribute xml : space {&quot;default &quot;|&quot;preserved &quot;}? , undefinedAttribute * atomCommonAttributes = appCommonAttributes undefinedAttribute = attribute *-(xml : base | xml : space | xml : lang | local : *) {text} atomLanguageTag = xsd : string {패턴 = &quot;([A-Za-z] {1 , 8} (-[A-Za-z0-9] {1,8}) *)? &quot;} atomDateConstruct = appCommonAttributes, xsd : dateTime # app : service appService = element app : service {appCommonAttributes, (appWorkspace + &amp;amp; extensionElement * )} # app : workspace appWorkspace = 요소 앱 :작업 공간 {appCommonAttributes, (atomTitle &amp;amp; appCollection * &amp;amp; extensionSansTitleElement *)} atomTitle = 요소 atom : title {atomTextConstruct} # app : collection appCollection = 요소 app : collection {appCommonAttributes, 특성 href {atomURI}, (atomTitle &amp;amp; appAccept * &amp;amp; app 카테고리 * &amp;amp; extensionSansTitleElement *)} # app : 카테고리 atomCategory = 요소 atom : category {atomCommonAttributes, 속성 용어 {text}, 속성 체계 {atomURI} ?, 속성 레이블 {text} ?, undefinedContent} appInlineCategories = 요소 app : categories {속성 고정 { &quot;예&quot;| &quot;아니&quot; }?,속성 체계 {atomURI} ?, (atomCategory *, undefinedContent)} appOutOfLineCategories = element app : categories {속성 href {atomURI}, undefinedContent} appCategories = appInline 카테고리 | appOutOfLine 카테고리 # app : accept appAccept = element app : accept {appCommonAttributes, (text?)} # Simple Extension simpleSansTitleExtensionElement = element *-(app : * | atom : title) {text} simpleExtensionElement = 요소 *-(app : *) { text} # 구조적 확장 structuredSansTitleExtensionElement = element *-(app : * | atom : title) {(속성 * {text} +, (text | anyElement) *) | (속성 * {text} *, (text ?,anyElement +, (text | anyElement) *))} structuredExtensionElement = 요소 *-(app : *) {(속성 * {text} +, (text | anyElement) *) | (속성 * {text} *, (text ?, anyElement +, (text | anyElement) *))} # 기타 확장 성 extensionSansTitleElement = simpleSansTitleExtensionElement | structuredSansTitleExtensionElement extensionElement = simpleExtensionElement | structuredExtensionElement undefinedContent = (text | anyForeignElement) * # 확장명 anyElement = element * {(속성 * {text} | text | anyElement) *} anyForeignElement = 요소 *-app : * {(속성 * {text} | text | anyElement) * } atomPlainTextConstruct = atomCommonAttributes,속성 유형 { &quot;text&quot;| &quot;html&quot;} ?, 텍스트 atomXHTMLTextConstruct = atomCommonAttributes, 속성 유형 { &quot;xhtml&quot;}, xhtmlDiv atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct anyXHTML = 요소 xhtml : * {(속성 * {text} | text | anyXHTML) *} xhtmlDiv = element xhtml : div {(속성 * {text} | text | anyXHTML) *} # EOF 범주 문서의 스키마 : # -*-rnc-*-# ALA 프로토콜 네임 스페이스 앱의 RELAX NG 컴팩트 구문 문법 = &quot;xhtmlDiv atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct anyXHTML = 요소 xhtml : * {(속성 * {text} | text | anyXHTML) *} xhtmlDiv = element xhtml : div {(속성 * {text} | text | anyXHTML) *} # EOF 범주 문서의 스키마 : # -*-rnc-*-# ALA 프로토콜 네임 스페이스 앱의 RELAX NG 컴팩트 구문 문법 = &quot;xhtmlDiv atomTextConstruct = atomPlainTextConstruct | atomXHTMLTextConstruct anyXHTML = 요소 xhtml : * {(속성 * {text} | text | anyXHTML) *} xhtmlDiv = element xhtml : div {(속성 * {text} | text | anyXHTML) *} # EOF 범주 문서의 스키마 : # -*-rnc-*-# ALA 프로토콜 네임 스페이스 앱의 RELAX NG 컴팩트 구문 문법 = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &quot;네임 스페이스 atom =&quot; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; &quot;네임 스페이스 xsd =&quot; &lt;a href=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;http://www.w3.org/2001/XMLSchema&lt;/a&gt;&quot;namespace local =&quot; &quot;start = app 카테고리 atomCommonAttributes = 속성 xml : base {atomURI} ?, 속성 xml : lang {atomLanguageTag} ?, undefinedAttribute * undefinedAttribute = 속성 *-(xml : base | xml : lang | local : *) { text} atomURI = 텍스트 atomLanguageTag = xsd : string {pattern = &quot;([A-Za-z] {1,8} (-[A-Za-z0-9] {1,8}) *)?&quot;} atomCategory = 요소 atom : category {atomCommonAttributes, 속성 용어 {text}, 속성 체계 {atomURI} ?, 속성 레이블 {text} ?, undefinedContent} appInlineCategories = element app : categories {속성 고정 { &quot;yes&quot;| &quot;no&quot;} ?, 속성 체계 {atomURI} ?, (atomCategory *,undefinedContent)} appOutOfLineCategories = 요소 app : categories {attribute href {atomURI}, (비어 있음)} appCategories = appInline 카테고리 | appOutOfLine 카테고리 # 확장 성 undefinedContent = (text | anyForeignElement) * anyElement = element * {(속성 * {text} | text | anyElement) *} anyForeignElement = 요소 *-atom : * {(속성 * {text} | text | anyElement) * } # EOF 저자 주소 Joe Gregorio (편집자) Google 이메일 : joe@bitworking.org URI :(비어 있음)} app 카테고리 = appInline 카테고리 | appOutOfLine 카테고리 # 확장 성 undefinedContent = (text | anyForeignElement) * anyElement = element * {(속성 * {text} | text | anyElement) *} anyForeignElement = 요소 *-atom : * {(속성 * {text} | text | anyElement) * } # EOF 저자 주소 Joe Gregorio (편집자) Google 이메일 : joe@bitworking.org URI :(비어 있음)} app 카테고리 = appInline 카테고리 | appOutOfLine 카테고리 # 확장 성 undefinedContent = (text | anyForeignElement) * anyElement = element * {(속성 * {text} | text | anyElement) *} anyForeignElement = 요소 *-atom : * {(속성 * {text} | text | anyElement) * } # EOF 저자 주소 Joe Gregorio (편집자) Google 이메일 : joe@bitworking.org URI :* {(속성 * {text} | text | anyElement) *} # EOF 저자 주소 Joe Gregorio (편집자) Google 이메일 : joe@bitworking.org URI :* {(속성 * {text} | text | anyElement) *} # EOF 저자 주소 Joe Gregorio (편집자) Google 이메일 : joe@bitworking.org URI : &lt;a href=&quot;http://bitworking.org/&quot;&gt;http://bitworking.org/&lt;/a&gt; Bill de hOra (편집자) NewBay Software 이메일 : bill@dehora.net URI : &lt;a href=&quot;http://dehora.net/&quot;&gt;http://dehora.net/&lt;/a&gt; 전체 저작권 정보 Copyright (C) IETF Trust (2007). 이 문서는 &lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78에&lt;/a&gt; 포함 된 권리, 라이센스 및 제한 사항의 적용을받습니다저자는 여기에 명시된 경우를 제외하고 모든 권리를 보유합니다. 이 문서와 여기에 포함 된 정보는 &quot;있는 그대로&quot;제공되며, 기부자, 그 / 그녀가 대표하거나 후원하는 단체, 인터넷 사회, IETF 신뢰 및 인터넷 엔지니어링 책임은 모두 부인됩니다. 여기에 포함 된 정보의 사용이 특정 목적에 대한 상품성 또는 적합성에 대한 어떠한 권리 나 묵시적 보증도 침해하지 않는다는 어떠한 보증도 포함하여 명시 적 또는 묵시적 보증.지적 재산권 IETF는이 문서에 기술 된 기술의 구현 또는 사용과 관련하여 주장 할 수있는 지적 재산권 또는 기타 권리의 유효성 또는 범위 또는 그러한 권리에 따른 라이센스가 사용하지 못할 수 있습니다. 또한 그러한 권리를 식별하기 위해 독립적 인 노력을 기울인 것도 아닙니다. RFC 문서의 권리와 관련된 절차에 대한 정보는&lt;a href=&quot;https://tools.ietf.org/html/bcp78&quot;&gt;BCP 78&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/bcp79&quot;&gt;BCP 79&lt;/a&gt; . IETF 사무국에 대한 IPR 공개 사본 및 사용 가능한 라이센스에 대한 보증, 또는이 사양의 구현 자 또는 사용자가 해당 소유권을 사용하기위한 일반 라이센스 또는 허가를 획득하려는 시도의 결과를 얻을 수 있습니다. 에서 IETF 온라인 IPR 저장소에서 &lt;a href=&quot;http://www.ietf.org/ipr&quot;&gt;http://www.ietf.org/ipr&lt;/a&gt; . IETF는 모든 이해 당사자가이 표준을 구현하는 데 필요할 수있는 기술을 포괄 할 수있는 모든 저작권, 특허 또는 특허 응용 프로그램 또는 기타 소유권을 관심을 갖도록 초대합니다. 정보는 IETF (ietf-ipr@ietf.org)로 문의하십시오. Gregorio &amp;amp; de hOra 표준 트랙 [페이지 53]</target>
        </trans-unit>
        <trans-unit id="2da261bce7b3f1d3df96b4c74a292834af8e4041" translate="yes" xml:space="preserve">
          <source>This article documents the default values for the HTTP &lt;code&gt;&lt;a href=&quot;../headers/accept&quot;&gt;Accept&lt;/a&gt;&lt;/code&gt; header for specific inputs and browser versions.</source>
          <target state="translated">이 기사에서는 특정 입력 및 브라우저 버전에 대한 HTTP &lt;code&gt;&lt;a href=&quot;../headers/accept&quot;&gt;Accept&lt;/a&gt;&lt;/code&gt; 헤더 의 기본값을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="76ccc899841c5ef0fd03f785dbd8994ed74b0227" translate="yes" xml:space="preserve">
          <source>This article is a general discussion of Cross-Origin Resource Sharing and includes a discussion of the necessary HTTP headers.</source>
          <target state="translated">이 기사는 Cross-Origin Resource Sharing에 대한 일반적인 토론이며 필요한 HTTP 헤더에 대한 토론을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="f43366408332e68939fb55f17a9ba0a7c3e2020f" translate="yes" xml:space="preserve">
          <source>This article provides guidance on how to choose whether to use a www-prefixed domain or not, along with the consequences of that choice.</source>
          <target state="translated">This article provides guidance on how to choose whether to use a www-prefixed domain or not, along with the consequences of that choice.</target>
        </trans-unit>
        <trans-unit id="41ec7728272d28393919275489b46845b2a0bf81" translate="yes" xml:space="preserve">
          <source>This can be done easily using the command-line &lt;code&gt;uuencode&lt;/code&gt; utility on Linux and Mac OS X systems:</source>
          <target state="translated">이것은 Linux 및 Mac OS X 시스템 에서 명령 행 &lt;code&gt;uuencode&lt;/code&gt; 유틸리티를 사용하여 쉽게 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11f06821ff38b68a8a006d81f07fe9d41afdd57e" translate="yes" xml:space="preserve">
          <source>This can be useful for serving content dynamically, for example. When using the &lt;code&gt;Vary: User-Agent&lt;/code&gt; header, caching servers should consider the user agent when deciding whether to serve the page from cache. If you are serving different content to mobile users, it can help you to avoid that a cache may mistakenly serve a desktop version of your site to your mobile users. In addition, it can help Google and other search engines to discover the mobile version of a page, and might also tell them that no &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;Cloaking&lt;/a&gt; is intended.</source>
          <target state="translated">예를 들어 콘텐츠를 동적으로 제공하는 데 유용 할 수 있습니다. 사용하는 경우는 &lt;code&gt;Vary: User-Agent&lt;/code&gt; 캐시에서 페이지를 제공할지 여부를 결정할 때 헤더, 캐싱 서버가 사용자 에이전트를 고려해야합니다. 모바일 사용자에게 다른 컨텐츠를 제공하는 경우 캐시가 실수로 데스크탑 버전의 사이트를 모바일 사용자에게 제공하는 것을 피할 수 있습니다. 또한 Google 및 기타 검색 엔진이 모바일 버전의 페이지를 발견하는 데 도움을 줄 수 있으며 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;클로킹&lt;/a&gt; 이 의도 되지 않았다고 말할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18b253862e749024a5a8be5438a282e1f0a396b5" translate="yes" xml:space="preserve">
          <source>This can happen if the JavaScript code is running with enhanced privileges allowing it access to multiple domains' content, for example.</source>
          <target state="translated">예를 들어, JavaScript 코드가 여러 도메인의 콘텐츠에 액세스 할 수있는 향상된 권한으로 실행되는 경우 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d58af569eba5200f4747d5689b8ff7e7d1d52941" translate="yes" xml:space="preserve">
          <source>This class of status code indicates a provisional response,
   consisting only of the Status-Line and optional headers, and is
   terminated by an empty line. There are no required headers for this
   class of status code. Since HTTP/1.0 did not define any 1xx status
   codes, servers MUST NOT send a 1xx response to an HTTP/1.0 client
   except under experimental conditions.

   A client MUST be prepared to accept one or more 1xx status responses
   prior to a regular response, even if the client does not expect a 100
   (Continue) status message. Unexpected 1xx status responses MAY be
   ignored by a user agent.

   Proxies MUST forward 1xx responses, unless the connection between the
   proxy and its client has been closed, or unless the proxy itself
   requested the generation of the 1xx response. (For example, if a 

   proxy adds a &quot;Expect: 100-continue&quot; field when it forwards a request,
   then it need not forward the corresponding 100 (Continue)
   response(s).)</source>
          <target state="translated">이 상태 코드 클래스는 상태 라인 및 선택적 헤더로만 구성된 임시 응답을 나타내며 빈 라인으로 종료됩니다. 이 클래스의 상태 코드에 필요한 헤더가 없습니다. HTTP / 1.0은 1xx 상태 코드를 정의하지 않았기 때문에 서버는 실험 조건을 제외하고 1xx 응답을 HTTP / 1.0 클라이언트에 보내서는 안됩니다. 클라이언트가 100 (계속) 상태 메시지를 기대하지 않더라도 클라이언트는 정기 응답 전에 하나 이상의 1xx 상태 응답을 승인 할 수 있어야합니다. 예상치 못한 1xx 상태 응답은 사용자 에이전트에 의해 무시 될 수 있습니다. 프록시와 클라이언트 간의 연결이 닫히지 않았거나 프록시 자체가 1xx 응답의 생성을 요청하지 않는 한 프록시는 반드시 1xx 응답을 전달해야합니다. (예 : 프록시가 '예상 : 100-continue &quot;필드는 요청을 전달할 때 해당 100 (계속) 응답을 전달할 필요가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="6b9a408e9c3b7b54fbf759cb196264221abed170" translate="yes" xml:space="preserve">
          <source>This class of status code indicates that further action needs to be
   taken by the user agent in order to fulfill the request.  The action
   required MAY be carried out by the user agent without interaction
   with the user if and only if the method used in the second request is
   GET or HEAD. A client SHOULD detect infinite redirection loops, since
   such loops generate network traffic for each redirection.

      Note: previous versions of this specification recommended a
      maximum of five redirections. Content developers should be aware
      that there might be clients that implement such a fixed
      limitation.</source>
          <target state="translated">이 상태 코드 클래스는 요청을 이행하기 위해 사용자 에이전트가 추가 조치를 취해야 함을 나타냅니다. 필요한 조치는 두 번째 요청에 사용 된 방법이 GET 또는 HEAD 인 경우에만 사용자와의 상호 작용없이 사용자 에이전트에 의해 수행 될 수 있습니다. 클라이언트는 무한 리디렉션 루프를 감지해야합니다. 이러한 루프는 각 리디렉션에 대해 네트워크 트래픽을 생성하기 때문입니다. 참고 :이 사양의 이전 버전에서는 최대 5 개의 리디렉션이 권장되었습니다. 컨텐츠 개발자는 이러한 고정 된 제한을 구현하는 클라이언트가있을 수 있음을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="dbcc4967400bddc90f0377f2e1ba98fce661236c" translate="yes" xml:space="preserve">
          <source>This class of status code indicates that the client's request was
   successfully received, understood, and accepted.</source>
          <target state="translated">이 상태 코드 클래스는 클라이언트 요청이 성공적으로 수신, 이해 및 수락되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aa0eac6f65fb6440a25f249695197fc412fc43a4" translate="yes" xml:space="preserve">
          <source>This code indicates that the server has received and is processing the request, but no response is available yet.</source>
          <target state="translated">이 코드는 서버가 요청을 수신하여 처리 중이지만 아직 응답을 사용할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3a6a8f72886b84a7449d24f613f3e53c70e794a8" translate="yes" xml:space="preserve">
          <source>This code is reserved for future use.</source>
          <target state="translated">이 코드는 나중에 사용하기 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffadfb15e2eb2fc2bbccd496410791acc5ffa9e9" translate="yes" xml:space="preserve">
          <source>This code is sent in response to an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header by the client, and indicates the protocol the server is switching to.</source>
          <target state="translated">이 코드는 클라이언트 가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; 요청 헤더 에 응답하여 전송 하며 서버가 전환하는 프로토콜을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aa1e5327237aabe301b48a95db0d8c6c85cc5f0b" translate="yes" xml:space="preserve">
          <source>This code is sent in response to an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; request header from the client, and indicates the protocol the server is switching to.</source>
          <target state="translated">This code is sent in response to an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; request header from the client, and indicates the protocol the server is switching to.</target>
        </trans-unit>
        <trans-unit id="b0827e7feb1318caf938fa97aff681eecc88f25e" translate="yes" xml:space="preserve">
          <source>This code is similar to 401 (Unauthorized), but indicates that the
   client must first authenticate itself with the proxy. The proxy MUST
   return a Proxy-Authenticate header field (&lt;a href=&quot;#section-14.33&quot;&gt;section 14.33&lt;/a&gt;) containing a
   challenge applicable to the proxy for the requested resource. The
   client MAY repeat the request with a suitable Proxy-Authorization
   header field (&lt;a href=&quot;#section-14.34&quot;&gt;section 14.34&lt;/a&gt;). HTTP access authentication is explained
   in &quot;HTTP Authentication: Basic and Digest Access Authentication&quot;
   [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;].</source>
          <target state="translated">이 코드는 401 (권한 없음)과 유사하지만 클라이언트가 먼저 프록시를 사용하여 인증해야 함을 나타냅니다. 프록시 는 요청 된 자원에 대한 프록시에 적용 가능한 챌린지를 포함 하는 프록시 인증 헤더 필드 ( &lt;a href=&quot;#section-14.33&quot;&gt;섹션 14.33&lt;/a&gt; )를 반환해야 합니다. 클라이언트는 적절한 Proxy-Authorization 헤더 필드 ( &lt;a href=&quot;#section-14.34&quot;&gt;14.34 절&lt;/a&gt; )로 요청을 반복 할 수있다 . HTTP 액세스 인증은 &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증&quot;[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a79aa67f6b67e62ec228c4830d6fa231aff1cf84" translate="yes" xml:space="preserve">
          <source>This design technique involves developing your Web site in 'layers', using a bottom-up approach, starting with a simpler layer and improving the capabilities of the site in successive layers, each using more features.</source>
          <target state="translated">이 디자인 기법에는 상향식 접근 방식을 사용하여 웹 사이트를 '계층'으로 개발하고 간단한 계층부터 시작하여 연속 된 계층에서 사이트 기능을 향상시키는 기능이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="c4f2bfc459cbc9d47da09ed899ca07996d8c748f" translate="yes" xml:space="preserve">
          <source>This directive is meaningless for the Public-Key-Pins-Report-Only header, it will be ignored by user agents and the header will not be cached.</source>
          <target state="translated">이 지시문은 Public-Key-Pins-Report-Only 헤더에는 의미가 없으며, 사용자 에이전트에 의해 무시되며 헤더는 캐시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f32511f74b3172e453c0eb1a2d75c8552c9a2edb" translate="yes" xml:space="preserve">
          <source>This directive is not supported in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element or by the &lt;a href=&quot;../content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-policy-Report-Only&lt;/code&gt;&lt;/a&gt; header field.</source>
          <target state="translated">이 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 또는 &lt;a href=&quot;../content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-policy-Report-Only&lt;/code&gt; &lt;/a&gt; 헤더 필드 에서 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9d0590723290af17baff140ec8796150f9341847" translate="yes" xml:space="preserve">
          <source>This directive is not supported in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">이 지시문은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에서 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9b819d9b6f80f6df35168312b4868b28bd76e9d1" translate="yes" xml:space="preserve">
          <source>This document describes an extension to the HTTP/1.1 protocol that
   allows clients to perform remote Web content authoring operations.
   This extension provides a coherent set of methods, headers, request
   entity body formats, and response entity body formats that provide
   operations for:

   Properties: The ability to create, remove, and query information
   about Web pages, such as their authors, creation dates, etc.

   Collections: The ability to create sets of documents and to retrieve
   a hierarchical membership listing (like a directory listing in a file
   system).

   Locking: The ability to keep more than one person from working on a
   document at the same time.  This prevents the &quot;lost update problem&quot;,
   in which modifications are lost as first one author, then another,
   writes changes without merging the other author's changes.

   Namespace Operations: The ability to instruct the server to copy and
   move Web resources, operations that change the mapping from URLs to
   resources.

   Requirements and rationale for these operations are described in a
   companion document, &quot;Requirements for a Distributed Authoring and
   Versioning Protocol for the World Wide Web&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt;].

   This document does not specify the versioning operations suggested by
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt;].  That work was done in a separate document, &quot;Versioning
   Extensions to WebDAV&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;].

   The sections below provide a detailed introduction to various WebDAV
   abstractions: resource properties (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;), collections of
   resources (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;), locks (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;) in general, and write locks
   (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) specifically.

   These abstractions are manipulated by the WebDAV-specific HTTP
   methods (&lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;) and the extra HTTP headers (&lt;a href=&quot;#section-10&quot;&gt;Section 10&lt;/a&gt;) used with
   WebDAV methods.  General considerations for handling HTTP requests
   and responses in WebDAV are found in &lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;.

   While the status codes provided by HTTP/1.1 are sufficient to
   describe most error conditions encountered by WebDAV methods, there
   are some errors that do not fall neatly into the existing categories.
   This specification defines extra status codes developed for WebDAV
   methods (&lt;a href=&quot;#section-11&quot;&gt;Section 11&lt;/a&gt;) and describes existing HTTP status codes
   (&lt;a href=&quot;#section-12&quot;&gt;Section 12&lt;/a&gt;) as used in WebDAV.  Since some WebDAV methods may 

   operate over many resources, the Multi-Status response (&lt;a href=&quot;#section-13&quot;&gt;Section 13&lt;/a&gt;)
   has been introduced to return status information for multiple
   resources.  Finally, this version of WebDAV introduces precondition
   and postcondition (&lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;) XML elements in error response bodies.

   WebDAV uses XML ([&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;]) for property names and some values, and
   also uses XML to marshal complicated requests and responses.  This
   specification contains DTD and text definitions of all properties
   (&lt;a href=&quot;#section-15&quot;&gt;Section 15&lt;/a&gt;) and all other XML elements (&lt;a href=&quot;#section-14&quot;&gt;Section 14&lt;/a&gt;) used in
   marshalling.  WebDAV includes a few special rules on extending WebDAV
   XML marshalling in backwards-compatible ways (&lt;a href=&quot;#section-17&quot;&gt;Section 17&lt;/a&gt;).

   Finishing off the specification are sections on what it means for a
   resource to be compliant with this specification (&lt;a href=&quot;#section-18&quot;&gt;Section 18&lt;/a&gt;), on
   internationalization support (&lt;a href=&quot;#section-19&quot;&gt;Section 19&lt;/a&gt;), and on security
   (&lt;a href=&quot;#section-20&quot;&gt;Section 20&lt;/a&gt;).</source>
          <target state="translated">이 문서는 클라이언트가 원격 웹 컨텐츠 저작 작업을 수행 할 수 있도록하는 HTTP / 1.1 프로토콜의 확장에 대해 설명합니다. 이 확장은 다음과 같은 작업을 제공하는 일관된 메소드, 헤더, 요청 엔터티 본문 형식 및 응답 엔터티 본문 형식을 제공합니다. 속성 : 웹 페이지에 대한 정보 (예 : 작성자, 작성 날짜, 콜렉션 : 문서 세트를 작성하고 계층 적 멤버쉽 리스팅 (파일 시스템의 디렉토리 리스팅과 같은)을 검색하는 기능. 잠금 : 여러 사람이 동시에 한 문서에서 작업하지 못하게하는 기능. 이렇게하면 &quot;잃어버린 업데이트 문제&quot;를 방지 할 수 있습니다.이 업데이트에서 수정자는 먼저 한 사람 씩, 다른 사람은다른 작성자의 변경 사항을 병합하지 않고 변경 사항을 작성합니다. 네임 스페이스 작업 : URL에서 리소스로 매핑을 변경하는 작업 인 서버에 웹 리소스를 복사하고 이동하도록 지시하는 기능. 이러한 작업에 대한 요구 사항 및 이론적 근거는 &quot;WWW (World Wide Web)에 대한 분산 작성 및 버전 관리 프로토콜에 대한 요구 사항&quot;문서에 설명되어 있습니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt; ]. 이 문서는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC2291&lt;/a&gt; ]에서 제안한 버전 관리 작업을 지정하지 않습니다 . 이 작업은 별도의 문서 &quot;WebDAV에 대한 버전 확장&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; ]에서 수행되었습니다. 아래 섹션에서는 다양한 WebDAV 추상화에 대한 자세한 소개를 제공합니다. 리소스 속성 ( &lt;a href=&quot;#section-4&quot;&gt;섹션 4&lt;/a&gt; ), 리소스 모음 ( &lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt; ), 잠금 ( &lt;a href=&quot;#section-6&quot;&gt;섹션 6&lt;/a&gt; ) 및 쓰기 잠금 ( &lt;a href=&quot;#section-7&quot;&gt;섹션 7&lt;/a&gt; ). 이러한 추상화는 WebDAV 고유의 HTTP 메소드 ( &lt;a href=&quot;#section-9&quot;&gt;섹션 9&lt;/a&gt; ) 및 추가 HTTP 헤더 ( &lt;a href=&quot;#section-10&quot;&gt;섹션 10)로 조작됩니다.&lt;/a&gt;)는 WebDAV 메소드와 함께 사용됩니다. WebDAV에서 HTTP 요청 및 응답을 처리하기위한 일반적인 고려 사항은 &lt;a href=&quot;#section-8&quot;&gt;섹션 8에&lt;/a&gt; 있습니다. HTTP / 1.1에서 제공하는 상태 코드는 WebDAV 메소드에서 발생하는 대부분의 오류 조건을 설명하기에 충분하지만 기존 범주에 속하지 않는 일부 오류가 있습니다. 이 사양은 WebDAV 메소드 용으로 개발 된 추가 상태 코드 ( &lt;a href=&quot;#section-11&quot;&gt;11 &lt;/a&gt;&lt;a href=&quot;#section-12&quot;&gt;장&lt;/a&gt; )를 정의하고 WebDAV에서 사용되는 기존 HTTP 상태 코드 ( 12 장 )를 설명 합니다. 일부 WebDAV 방법은 많은 리소스를 통해 작동 할 수 있으므로 다중 상태 응답 ( &lt;a href=&quot;#section-13&quot;&gt;섹션 13&lt;/a&gt;)가 여러 리소스에 대한 상태 정보를 반환하기 위해 도입되었습니다. 마지막으로,이 버전의 WebDAV 는 오류 응답 본문에 사전 조건 및 사후 조건 ( &lt;a href=&quot;#section-16&quot;&gt;섹션 16&lt;/a&gt; ) XML 요소를 도입 합니다. WebDAV는 속성 이름 및 일부 값에 XML ([ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt; ])을 사용하고 복잡한 요청 및 응답을 마샬링하기 위해 XML을 사용합니다. 이 사양에는 마샬링에 사용되는 모든 속성 ( &lt;a href=&quot;#section-15&quot;&gt;섹션 15&lt;/a&gt; ) 및 기타 모든 XML 요소 ( &lt;a href=&quot;#section-14&quot;&gt;섹션 14&lt;/a&gt; )의 DTD 및 텍스트 정의가 포함 됩니다. WebDAV에는 이전 버전과 호환되는 방식으로 WebDAV XML 마샬링을 확장하는 몇 가지 특수 규칙이 포함되어 있습니다 ( &lt;a href=&quot;#section-17&quot;&gt;섹션 17).&lt;/a&gt;). 사양의 마무리는 자원이이 사양을 준수한다는 의미 ( &lt;a href=&quot;#section-18&quot;&gt;섹션 18&lt;/a&gt; ), 국제화 지원 ( &lt;a href=&quot;#section-19&quot;&gt;섹션 19&lt;/a&gt; ) 및 보안 ( &lt;a href=&quot;#section-20&quot;&gt;섹션 20&lt;/a&gt; ) 에 대한 섹션 입니다.</target>
        </trans-unit>
        <trans-unit id="d12cc0f3aacd5b3de7f5ba6d1f64c9e830a68a99" translate="yes" xml:space="preserve">
          <source>This document describes the user agent string used in Firefox 4 and later and applications based on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0 and later. For a breakdown of changes to the string in Gecko 2.0, see &lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Final User Agent string for Firefox 4&lt;/a&gt; (blog post). See also this document on &lt;a href=&quot;../../browser_detection_using_the_user_agent&quot;&gt;user agent sniffing&lt;/a&gt; and this &lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks blog post&lt;/a&gt;.</source>
          <target state="translated">이 문서는 Firefox 4 이상에서 사용되는 사용자 에이전트 문자열과 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0 이상 기반 응용 프로그램에 대해 설명합니다 . Gecko 2.0의 문자열 변경 내용 &lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;은 Firefox 4 용 최종 사용자 에이전트 문자열&lt;/a&gt; (블로그 게시물)을 참조하십시오. &lt;a href=&quot;../../browser_detection_using_the_user_agent&quot;&gt;사용자 에이전트 스니핑&lt;/a&gt; 에 대한이 문서 와이 &lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks 블로그 게시물을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="77d126757eafa5a2c1ec7b146581b7a094dfa302" translate="yes" xml:space="preserve">
          <source>This document describes the user agent string used in Firefox 4 and later and applications based on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0 and later. For a breakdown of changes to the string in Gecko 2.0, see &lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;Final User Agent string for Firefox 4&lt;/a&gt; (blog post). See also this document on &lt;a href=&quot;../browser_detection_using_the_user_agent&quot;&gt;user agent sniffing&lt;/a&gt; and this &lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks blog post&lt;/a&gt;.</source>
          <target state="translated">이 문서는 Firefox 4 이상에서 사용되는 사용자 에이전트 문자열과 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Gecko&quot;&gt;Gecko&lt;/a&gt; 2.0 이상 기반 응용 프로그램에 대해 설명합니다 . Gecko 2.0의 문자열 변경 내용 &lt;a href=&quot;https://hacks.mozilla.org/2010/09/final-user-agent-string-for-firefox-4/&quot;&gt;은 Firefox 4 용 최종 사용자 에이전트 문자열&lt;/a&gt; (블로그 게시물)을 참조하십시오. &lt;a href=&quot;../browser_detection_using_the_user_agent&quot;&gt;사용자 에이전트 스니핑&lt;/a&gt; 에 대한이 문서 와이 &lt;a href=&quot;https://hacks.mozilla.org/2013/09/user-agent-detection-history-and-checklist/&quot;&gt;Hacks 블로그 게시물을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e83d25b1239accfb20c5eb5ac032a6055e8ac00e" translate="yes" xml:space="preserve">
          <source>This edition of HTTP/1.1 builds on the many contributions that went
   into &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;, and &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, including
   substantial contributions made by the previous authors, editors, and
   Working Group Chairs: Tim Berners-Lee, Ari Luotonen, Roy T. Fielding,
   Henrik Frystyk Nielsen, Jim Gettys, Jeffrey C. Mogul, Larry Masinter,
   and Paul J. Leach.  Mark Nottingham oversaw this effort as Working
   Group Chair.

   Since 1999, the following contributors have helped improve the HTTP
   specification by reporting bugs, asking smart questions, drafting or
   reviewing text, and evaluating open issues:

   Adam Barth, Adam Roach, Addison Phillips, Adrian Chadd, Adrian Cole,
   Adrien W. de Croy, Alan Ford, Alan Ruttenberg, Albert Lunde, Alek
   Storm, Alex Rousskov, Alexandre Morgaut, Alexey Melnikov, Alisha
   Smith, Amichai Rothman, Amit Klein, Amos Jeffries, Andreas Maier,
   Andreas Petersson, Andrei Popov, Anil Sharma, Anne van Kesteren,
   Anthony Bryan, Asbjorn Ulsberg, Ashok Kumar, Balachander
   Krishnamurthy, Barry Leiba, Ben Laurie, Benjamin Carlyle, Benjamin
   Niven-Jenkins, Benoit Claise, Bil Corry, Bill Burke, Bjoern
   Hoehrmann, Bob Scheifler, Boris Zbarsky, Brett Slatkin, Brian Kell,
   Brian McBarron, Brian Pane, Brian Raymor, Brian Smith, Bruce Perens,
   Bryce Nesbitt, Cameron Heavon-Jones, Carl Kugler, Carsten Bormann,
   Charles Fry, Chris Burdess, Chris Newman, Christian Huitema, Cyrus
   Daboo, Dale Robert Anderson, Dan Wing, Dan Winship, Daniel Stenberg,
   Darrel Miller, Dave Cridland, Dave Crocker, Dave Kristol, Dave
   Thaler, David Booth, David Singer, David W. Morris, Diwakar Shetty,
   Dmitry Kurochkin, Drummond Reed, Duane Wessels, Edward Lee, Eitan
   Adler, Eliot Lear, Emile Stephan, Eran Hammer-Lahav, Eric D.
   Williams, Eric J. Bowman, Eric Lawrence, Eric Rescorla, Erik
   Aronesty, EungJun Yi, Evan Prodromou, Felix Geisendoerfer, Florian
   Weimer, Frank Ellermann, Fred Akalin, Fred Bohle, Frederic Kayser,
   Gabor Molnar, Gabriel Montenegro, Geoffrey Sneddon, Gervase Markham,
   Gili Tzabari, Grahame Grieve, Greg Slepak, Greg Wilkins, Grzegorz
   Calkowski, Harald Tveit Alvestrand, Harry Halpin, Helge Hess, Henrik
   Nordstrom, Henry S. Thompson, Henry Story, Herbert van de Sompel,
   Herve Ruellan, Howard Melman, Hugo Haas, Ian Fette, Ian Hickson, Ido
   Safruti, Ilari Liusvaara, Ilya Grigorik, Ingo Struck, J. Ross Nicoll,
   James Cloos, James H. Manger, James Lacey, James M. Snell, Jamie 

   Lokier, Jan Algermissen, Jari Arkko, Jeff Hodges (who came up with
   the term 'effective Request-URI'), Jeff Pinner, Jeff Walden, Jim
   Luther, Jitu Padhye, Joe D. Williams, Joe Gregorio, Joe Orton, Joel
   Jaeggli, John C. Klensin, John C. Mallery, John Cowan, John Kemp,
   John Panzer, John Schneider, John Stracke, John Sullivan, Jonas
   Sicking, Jonathan A. Rees, Jonathan Billington, Jonathan Moore,
   Jonathan Silvera, Jordi Ros, Joris Dobbelsteen, Josh Cohen, Julien
   Pierre, Jungshik Shin, Justin Chapweske, Justin Erenkrantz, Justin
   James, Kalvinder Singh, Karl Dubost, Kathleen Moriarty, Keith
   Hoffman, Keith Moore, Ken Murchison, Koen Holtman, Konstantin
   Voronkov, Kris Zyp, Leif Hedstrom, Lionel Morand, Lisa Dusseault,
   Maciej Stachowiak, Manu Sporny, Marc Schneider, Marc Slemko, Mark
   Baker, Mark Pauley, Mark Watson, Markus Isomaki, Markus Lanthaler,
   Martin J. Duerst, Martin Musatov, Martin Nilsson, Martin Thomson,
   Matt Lynch, Matthew Cox, Matthew Kerwin, Max Clark, Menachem Dodge,
   Meral Shirazipour, Michael Burrows, Michael Hausenblas, Michael
   Scharf, Michael Sweet, Michael Tuexen, Michael Welzl, Mike Amundsen,
   Mike Belshe, Mike Bishop, Mike Kelly, Mike Schinkel, Miles Sabin,
   Murray S. Kucherawy, Mykyta Yevstifeyev, Nathan Rixham, Nicholas
   Shanks, Nico Williams, Nicolas Alvarez, Nicolas Mailhot, Noah Slater,
   Osama Mazahir, Pablo Castro, Pat Hayes, Patrick R. McManus, Paul E.
   Jones, Paul Hoffman, Paul Marquess, Pete Resnick, Peter Lepeska,
   Peter Occil, Peter Saint-Andre, Peter Watkins, Phil Archer, Phil
   Hunt, Philippe Mougin, Phillip Hallam-Baker, Piotr Dobrogost, Poul-
   Henning Kamp, Preethi Natarajan, Rajeev Bector, Ray Polk, Reto
   Bachmann-Gmuer, Richard Barnes, Richard Cyganiak, Rob Trace, Robby
   Simpson, Robert Brewer, Robert Collins, Robert Mattson, Robert
   O'Callahan, Robert Olofsson, Robert Sayre, Robert Siemer, Robert de
   Wilde, Roberto Javier Godoy, Roberto Peon, Roland Zink, Ronny
   Widjaja, Ryan Hamilton, S. Mike Dierken, Salvatore Loreto, Sam
   Johnston, Sam Pullara, Sam Ruby, Saurabh Kulkarni, Scott Lawrence
   (who maintained the original issues list), Sean B. Palmer, Sean
   Turner, Sebastien Barnoud, Shane McCarron, Shigeki Ohtsu, Simon
   Yarde, Stefan Eissing, Stefan Tilkov, Stefanos Harhalakis, Stephane
   Bortzmeyer, Stephen Farrell, Stephen Kent, Stephen Ludin, Stuart
   Williams, Subbu Allamaraju, Subramanian Moonesamy, Susan Hares,
   Sylvain Hellegouarch, Tapan Divekar, Tatsuhiro Tsujikawa, Tatsuya
   Hayashi, Ted Hardie, Ted Lemon, Thomas Broyer, Thomas Fossati, Thomas
   Maslen, Thomas Nadeau, Thomas Nordin, Thomas Roessler, Tim Bray, Tim
   Morgan, Tim Olsen, Tom Zhou, Travis Snoozy, Tyler Close, Vincent
   Murphy, Wenbo Zhu, Werner Baumann, Wilbur Streett, Wilfredo Sanchez
   Vega, William A. Rowe Jr., William Chan, Willy Tarreau, Xiaoshu Wang,
   Yaron Goland, Yngve Nysaeter Pettersen, Yoav Nir, Yogesh Bang,
   Yuchung Cheng, Yutaka Oiwa, Yves Lafon (long-time member of the
   editor team), Zed A. Shaw, and Zhong Yu.

   See &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-16&quot;&gt;Section&amp;nbsp;16 of [RFC2616]&lt;/a&gt; for additional acknowledgements from
   prior revisions.</source>
          <target state="translated">이 HTTP / 1.1 버전은 &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616에&lt;/a&gt; 많은 기여를했습니다.팀 버너스-리, 아리 루 오토 넨, 로이 T. 필딩, 헨리크 프라이스 티크 닐슨, 짐 게티, 제프리시 모굴, 래리 마스터, 폴 제이 리치 . Mark Nottingham은 이러한 노력을 실무 그룹 의장으로 감독했습니다. 1999 년부터 다음 기고자들은 버그를보고하고, 현명한 질문을하고, 텍스트를 작성하거나 검토하고, 공개 된 문제를 평가하여 HTTP 사양을 개선하는 데 도움을주었습니다. Adam Barth, Adam Roach, Addison Phillips, Adrian Chadd, Adrian Cole, Adrien W. de Croy , Alan Ford, Alan Ruttenberg, Albert Lunde, Alek Storm, Alex Rousskov, Alexandre Morgaut, Alexey Melnikov, Alisha Smith, Amichai Rothman, Amit Klein, Amos Jeffries, Andreas Maier, Andreas Petersson, Andrei Popov, Anil Sharma, Anne van Kesteren,Anthony Bryan, Asbjorn Ulsberg, Ashok Kumar, Balachander Krishnamurthy, Barry Leiba, Ben Laurie, Benjamin Carlyle, Benjamin Niven-Jenkins, Benoit Claise, Bil Corry, Bill Burke, Bjoern Hoehrmann, Bob Scheifler, Boris Zbarsky, Brett Slatkin, 브라이언 켈, Brian McBarron, Brian Pane, Brian Raymor, Brian Smith, Bruce Perens, Bryce Nesbitt, Cameron Heavon-Jones, Carl Kugler, Carsten Bormann, Charles Fry, Chris Burdess, Chris Newman, Christian Huitema, Cyrus Daboo, Dale Robert Anderson, Dan Wing , Dan Winship, Daniel Stenberg, Darrel Miller, Dave Cridland, Dave Crocker, Dave Kristol, Dave Thaler, David Booth, David Singer, David W. Morris, Diwakar Shetty, Dmitry Kurochkin, Drummond Reed, Duane Wessels, Edward Lee, Eitan Adler Eliot Lear, Emile Stephan, Eran Hammer-Lahav, Eric D. Williams, Eric J. Bowman,Eric Lawrence, Eric Rescorla, Erik Aronesty, EungJun Yi, Evan Prodromou, Felix Geisendoerfer, Florian Weimer, Frank Ellermann, Fred Akalin, Fred Bohle, Frederic Kayser, Gabor Molnar, Gabriel Montenegro, Geoffrey Sneddon, Gervase Markham, Gili Tzabari, 그레이엄 그리브 , Greg Slepak, Greg Wilkins, Grzegorz Calkowski, Harald Tveit Alvestrand, Harry Halpin, Helge Hess, Henrik Nordstrom, Henry S. Thompson, Henry Story, Herbert van de Sompel, Herve Ruellan, Howard Melman, Hugo Haas, Ian Fette, Ian Hickson , Ido Safruti, Ilari Liusvaara, Ilya Grigorik, Ingo Struck, J. Ross Nicoll, James Cloos, James H. Manger, James Lacey, James M. Snell, Jamie Lokier, Jan Algermissen, Jari Arkko, Jeff Hodges '유효한 요청 URI'라는 용어), Jeff Pinner, Jeff Walden, Jim Luther, Jitu Padhye, Joe D. Williams,Joe Gregorio, Joe Orton, Joel Jaeggli, John C. Klensin, John C. Mallery, John Cowan, John Kemp, John Panzer, John Schneider, John Stracke, John Sullivan, Jonas Sicking, Jonathan A. Rees, Jonathan Billington, Jonathan Moore , Jonathan Silvera, Jordi Ros, Joris Dobbelsteen, Josh Cohen, Julien Pierre, Jungshik Shin, Justin Chapweske, Justin Erenkrantz, Justin James, Kalvinder Singh, Karl Dubost, Kathleen Moriarty, Keith Hoffman, Keith Moore, Ken Murchison, Koen Holtman, Konstantin Voronkov, Kris Zyp, Leif Hedstrom, Lionel Morand, Lisa Dusseault, Maciej Stachowiak, Manu Sporny, Marc Schneider, Marc Slemko, Mark Baker, Mark Pauley, Mark Watson, Markus Isomaki, Markus Lanthaler, Martin J. Duerst, Martin Musatov, Martin 닐슨, 마틴 톰슨, 맷 린치, 매튜 콕스, 매튜 커윈, 맥스 클락, 메나 켐 닷지,Meral Shirazipour, Michael Burrows, Michael Hausenblas, Michael Scharf, Michael Sweet, Michael Tuexen, Michael Welzl, Mike Amundsen, Mike Belshe, Mike Bishop, Mike Kelly, Mike Schinkel, Miles Sabin, Murray S. Kucherawy, Mykyta Yevstifeyev, Nathan Rixham, 니콜라스 샹크스, 니코 윌리엄스, 니콜라스 알바레즈, 니콜라스 Mailhot, 노아 슬레이터, 오사마 마 자히르, 파블로 카스트로, 팻 헤이스, 패트릭 R. 맥 마누스, 폴 E. 존스, 폴 호프만, 폴 마르케스, 피트 레닉, 피터 레 페스 카, 피터 오실, 피터 세인트 안드레, 피터 왓킨스, 필 궁수, 필 헌트, 필립 무 gin, 필립 할람 베이커, 피오트르 도브로 고스트, 폴 헤닝 캄프, 프레 티 나타 라얀, 라 예프 벡터, 레이 포크, 레토 바흐 만-구 에르, 리차드 반스, 리차드 시가 닉 트레이스, 로비 심슨, Robert Brewer, Robert Collins, Robert Mattson, Robert O'Callahan,Robert Olofsson, Robert Sayre, Robert Siemer, Robert de Wilde, Roberto Javier Godoy, Roberto Peon, Roland Zink, Ronny Widjaja, Ryan Hamilton, S. Mike Dierken, Salvatore Loreto, Sam Johnston, Sam Pullara, Sam Ruby, Saurabh Kulkarni, Scott Lawrence (원본 문제 목록을 유지 한 사람), Sean B. Palmer, Sean Turner, Sebastien Barnoud, Shane McCarron, Shigeki Ohtsu, Simon Yarde, Stefan Eissing, Stefan Tilkov, Stefanos Harhalakis, Stephane Bortzmeyer, Stephen Farrell, Stephen Kent, Stephen Ludin 스튜어트 윌리엄스, Subbu Allamaraju, Subramanian Moonesamy, Susan Hares, Sylvain Hellegouarch, Tapan Divekar, Tatsuhiro Tsujikawa, Tatsuya Hayashi, Ted Hardie, Ted Lemon, Thomas Broyer, Thomas Fossati, Thomas Maslen, Thomas Nadeau, Thomas Nordin, Thomas Roessler, Tim 브레이, 팀 모건, 팀 올슨, 톰 주, 트래비스 스 누지,Tyler Close, Vincent Murphy, Wenbo Zhu, Werner Baumann, Wilbur Streett, Wilfredo Sanchez Vega, William A. Rowe Jr., William Chan, Willy Tarreau, Xiaoshu Wang, Yaron Goland, Yngve Nysaeter Pettersen, Yoav Nir, Yogesh Bang, Yuchung Cheng , Yutaka Oiwa, Yves Lafon (오래 편집자 멤버), Zed A. Shaw 및 Zhong Yu. 보다&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-16&quot;&gt;&lt;/a&gt;이전 개정의 추가 승인에 대해서는 [RFC2616]의 16 항 .</target>
        </trans-unit>
        <trans-unit id="ee24423cc6a36dea3e2a80b1cc45bcc1e29b0c7b" translate="yes" xml:space="preserve">
          <source>This error can also occur if the response includes more than one &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header.</source>
          <target state="translated">응답에 둘 이상의 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더가 포함 된 경우에도이 오류가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e1d7d044ce568115a051e7914a52c456d823802" translate="yes" xml:space="preserve">
          <source>This error means that the document was not loaded at the top level of an user-opened or noopener-opened tab or window. It can occur in these situations:</source>
          <target state="translated">이 오류는 문서가 사용자가 열거 나 열지 않은 탭 또는 창의 최상위 레벨에로드되지 않았 음을 의미합니다. 다음과 같은 상황에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="852ff1bb35f3874b9a14a70ab4ee1ec671ff8707" translate="yes" xml:space="preserve">
          <source>This error occurs when attempting to preflight a header that is not expressly allowed (that is, it's not included in the list specified by the &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header sent by the server). To fix this, the server needs to be updated so that it allows the indicated header, or you need to avoid using that header.</source>
          <target state="translated">This error occurs when attempting to preflight a header that is not expressly allowed (that is, it's not included in the list specified by the &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header sent by the server). To fix this, the server needs to be updated so that it allows the indicated header, or you need to avoid using that header.</target>
        </trans-unit>
        <trans-unit id="1884120a66eaf56447e8f0aecbc8de6969d27e9d" translate="yes" xml:space="preserve">
          <source>This error response is a generic &quot;catch-all&quot; response. Sometimes, server administrators log error responses like the 500 status code with more details about the request to prevent the error from happening again in the future.</source>
          <target state="translated">이 오류 응답은 일반적인 &quot;catch-all&quot;응답입니다. 때때로 서버 관리자는 나중에 오류가 다시 발생하지 않도록 요청에 대한 자세한 정보와 함께 500 상태 코드와 같은 오류 응답을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="bf47d90cae9806b4c78cd4a0f7b36fa115bda893" translate="yes" xml:space="preserve">
          <source>This error response is a generic &quot;catch-all&quot; response. Usually, this indicates the server cannot find a better 5xx error code to response. Sometimes, server administrators log error responses like the 500 status code with more details about the request to prevent the error from happening again in the future.</source>
          <target state="translated">This error response is a generic &quot;catch-all&quot; response. Usually, this indicates the server cannot find a better 5xx error code to response. Sometimes, server administrators log error responses like the 500 status code with more details about the request to prevent the error from happening again in the future.</target>
        </trans-unit>
        <trans-unit id="9439e46ba591022a7d8217b7752ce9ccbf400eb2" translate="yes" xml:space="preserve">
          <source>This error response is given when the server is acting as a gateway and cannot get a response in time.</source>
          <target state="translated">이 오류 응답은 서버가 게이트웨이로 작동하고 시간 내에 응답을 얻을 수 없을 때 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="eab61895b7f6d33786618e886763053a4551a6b6" translate="yes" xml:space="preserve">
          <source>This error response means that the server, while working as a gateway to get a response needed to handle the request, got an invalid response.</source>
          <target state="translated">이 오류 응답은 서버가 요청을 처리하는 데 필요한 응답을 얻기 위해 게이트웨이로 작업하는 동안 유효하지 않은 응답을 받았음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f68650d4dca44929b9f30e96e89144cfc0f2f700" translate="yes" xml:space="preserve">
          <source>This error shouldn't happen on well-tested production systems, but can be found more often while testing a new system.</source>
          <target state="translated">이 오류는 테스트를 거친 프로덕션 시스템에서는 발생하지 않지만 새 시스템을 테스트하는 동안 더 자주 발견 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="483909e9171e2699ed78d6021cf1843f1935c891" translate="yes" xml:space="preserve">
          <source>This evolution of HTTP proves its extensibility and simplicity, liberating creation of many applications and compelling the adoption of the protocol. The environment in which HTTP is used today is quite different from that seen in the early 1990s. HTTP's original design proved to be a masterpiece, allowing the Web to evolve over a quarter of a century, without the need of a mutiny. By healing flaws, yet retaining the flexibility and extensibility which made HTTP such a success, the adoption of HTTP/2 hints at a bright future for the protocol.</source>
          <target state="translated">이러한 HTTP의 진화는 확장 성과 단순성을 입증하여 많은 응용 프로그램을 생성하고 프로토콜 채택을 강요합니다. 오늘날 HTTP가 사용되는 환경은 1990 년대 초와는 상당히 다릅니다. HTTP의 독창적 인 디자인은 걸작 인 것으로 판명되었으므로 웹은 반란없이 4 세기 동안 진화 할 수있었습니다. 결함을 치유하면서도 HTTP를 성공으로 이끈 유연성과 확장 성을 유지함으로써 프로토콜의 미래에 HTTP / 2 힌트를 채택 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="781912733ac5a2c031d25e3e8b5988cba0dcdce0" translate="yes" xml:space="preserve">
          <source>This example allows &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; content on a particular origin to access the user's location:</source>
          <target state="translated">이 예에서는 특정 출발지의 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 콘텐츠가 사용자의 위치에 액세스 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="ca8e2b99c120ccf6c9a6bffe95a381cde5380542" translate="yes" xml:space="preserve">
          <source>This example creates a collection called /webdisc/xfiles/ on the
   server www.example.com. 

   &amp;gt;&amp;gt;Request

     MKCOL /webdisc/xfiles/ HTTP/1.1
     Host: www.example.com


   &amp;gt;&amp;gt;Response

     HTTP/1.1 201 Created</source>
          <target state="translated">이 예제는 www.example.com 서버에서 / webdisc / xfiles /라는 컬렉션을 만듭니다. &amp;gt;&amp;gt; MKCOL 요청 / webdisc / xfiles / HTTP / 1.1 호스트 : www.example.com &amp;gt;&amp;gt; 응답 HTTP / 1.1 201 생성</target>
        </trans-unit>
        <trans-unit id="a0811554d7dd6c0c801a3a83158f7a56615c10fc" translate="yes" xml:space="preserve">
          <source>This example is more sophisticated. There are four (4) proxy servers; one of them is a hot stand-by for all of the other ones, so if any of the remaining three goes down the fourth one will take over. Furthermore, the three remaining proxy servers share the load based on URL patterns, which makes their caching more effective (there is only one copy of any document on the three servers - as opposed to one copy on each of them). The load is distributed like this:</source>
          <target state="translated">This example is more sophisticated. There are four (4) proxy servers; one of them is a hot stand-by for all of the other ones, so if any of the remaining three goes down the fourth one will take over. Furthermore, the three remaining proxy servers share the load based on URL patterns, which makes their caching more effective (there is only one copy of any document on the three servers - as opposed to one copy on each of them). The load is distributed like this:</target>
        </trans-unit>
        <trans-unit id="6c2ce892d1c3a6298b72aa271eaca87af850694a" translate="yes" xml:space="preserve">
          <source>This example is more sophisticated. There are four (4) proxy servers; one of them is a hot stand-by for all of the other ones, so if any of the remaining three goes down the fourth one will take over. Furthermore, the three remaining proxy servers share the load based on URL patterns, which makes their caching more effective (there is only one copy of any document on the three servers -- as opposed to one copy on each of them). The load is distributed like this:</source>
          <target state="translated">이 예는 더 정교합니다. 4 개의 프록시 서버가 있습니다. 그들 중 하나는 다른 모든 것의 핫 스탠바이이므로 나머지 세 개 중 하나라도 쓰러지면 네 번째 것이 인계됩니다. 또한 나머지 3 개의 프록시 서버는 URL 패턴을 기반으로로드를 공유하므로보다 효과적으로 캐싱 할 수 있습니다 (3 개의 서버에는 하나의 사본이 아니라 각 서버에 하나의 문서 사본 만 있음). 하중은 다음과 같이 분배됩니다.</target>
        </trans-unit>
        <trans-unit id="f8d7c446d07bc06ec9ae31c4aecccef522ea44ec" translate="yes" xml:space="preserve">
          <source>This example response is taken from the IETF RFC (see below) and contains a reference to &lt;a href=&quot;https://en.wikipedia.org/wiki/Monty_Python's_Life_of_Brian&quot;&gt;Monty Python's Life of Brian&lt;/a&gt;.</source>
          <target state="translated">이 예제 응답은 IETF RFC (아래 참조)에서 가져 왔으며 &lt;a href=&quot;https://en.wikipedia.org/wiki/Monty_Python's_Life_of_Brian&quot;&gt;Monty Python의 Life of Brian에&lt;/a&gt; 대한 참조를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="999b4d428320409a219f5dc5012ceca8d2b38d22" translate="yes" xml:space="preserve">
          <source>This example shows &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; when it specifies support for multiple headers.</source>
          <target state="translated">이 예는 여러 헤더에 대한 지원을 지정할 때 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="0b1f58893a7cb8a1c12815693f3befaeab5b7414" translate="yes" xml:space="preserve">
          <source>This example shows resource
   http://www.example.com/~fielding/index.html being copied to the
   location http://www.example.com/users/f/fielding/index.html.  The 204
   (No Content) status code indicates that the existing resource at the
   destination was overwritten.

   &amp;gt;&amp;gt;Request

     COPY /~fielding/index.html HTTP/1.1
     Host: www.example.com
     Destination: http://www.example.com/users/f/fielding/index.html

   &amp;gt;&amp;gt;Response

     HTTP/1.1 204 No Content</source>
          <target state="translated">이 예는 http://www.example.com/~fielding/index.html 리소스가 http://www.example.com/users/f/fielding/index.html 위치로 복사되는 것을 보여줍니다. 204 (No Content) 상태 코드는 대상의 기존 리소스를 덮어 쓴 것을 나타냅니다. &amp;gt;&amp;gt; 요청 복사 /~fielding/index.html HTTP / 1.1 호스트 : www.example.com 대상 : http://www.example.com/users/f/fielding/index.html &amp;gt;&amp;gt; 응답 HTTP / 1.1 204 아니요 함유량</target>
        </trans-unit>
        <trans-unit id="fa023a88dd9876a6752395fc5752087af07a81f6" translate="yes" xml:space="preserve">
          <source>This example shows resource
   http://www.example.com/~fielding/index.html being moved to the
   location http://www.example.com/users/f/fielding/index.html.  The
   contents of the destination resource would have been overwritten if
   the destination URL was already mapped to a resource.  In this case,
   since there was nothing at the destination resource, the response
   code is 201 (Created).

   &amp;gt;&amp;gt;Request

     MOVE /~fielding/index.html HTTP/1.1
     Host: www.example.com
     Destination: http://www.example/users/f/fielding/index.html

   &amp;gt;&amp;gt;Response

     HTTP/1.1 201 Created
     Location: http://www.example.com/users/f/fielding/index.html</source>
          <target state="translated">이 예는 http://www.example.com/~fielding/index.html 자원이 http://www.example.com/users/f/fielding/index.html 위치로 이동되는 것을 보여줍니다. 대상 URL이 이미 리소스에 매핑 된 경우 대상 리소스의 내용을 덮어 씁니다. 이 경우 대상 자원에 아무것도 없으므로 응답 코드는 201 (작성 됨)입니다. &amp;gt;&amp;gt; 요청 MOVE /~fielding/index.html HTTP / 1.1 호스트 : www.example.com 대상 : http : //www.example/users/f/fielding/index.html &amp;gt;&amp;gt; 응답 HTTP / 1.1 201 생성 된 위치 : http://www.example.com/users/f/fielding/index.html</target>
        </trans-unit>
        <trans-unit id="e00417a4554c87f42e03a721ef55ecfe0950a2cf" translate="yes" xml:space="preserve">
          <source>This example will work in an environment where the internal DNS server is set up so that it can only resolve internal host names, and the goal is to use a proxy only for hosts that aren't resolvable:</source>
          <target state="translated">이 예제는 내부 DNS 서버가 설정되어 내부 호스트 이름 만 확인할 수있는 환경에서 작동하며 목표는 분석 할 수없는 호스트에 대해서만 프록시를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a76e357a372c477fb919b2dd879c8bc24b00a2e5" translate="yes" xml:space="preserve">
          <source>This extensible nature of HTTP has, over time, allowed for more control and functionality of the Web. Cache or authentication methods were functions handled early in HTTP history. The ability to relax the &lt;em&gt;origin constraint&lt;/em&gt;, by contrast, has only been added in the 2010s.</source>
          <target state="translated">이러한 확장 가능한 HTTP 특성으로 인해 시간이 지남에 따라 웹의 제어 및 기능이 향상되었습니다. 캐시 또는 인증 방법은 HTTP 기록 초기에 처리 된 기능이었습니다. 반대로, &lt;em&gt;원점 제약&lt;/em&gt; 을 완화하는 기능 은 2010 년대에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="60964c2acb63a5e80056aab53d36efc81e0dae97" translate="yes" xml:space="preserve">
          <source>This feature has been removed from the Web standards. Though some browsers may still support it, it is in the process of being dropped. Avoid using it and update existing code if possible; see the &lt;a href=&quot;#Browser_compatibility&quot;&gt;compatibility table&lt;/a&gt; at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.</source>
          <target state="translated">이 기능은 웹 표준에서 제거되었습니다. 일부 브라우저는 여전히이를 지원할 수 있지만 삭제되는 중입니다. 사용하지 말고 가능한 경우 기존 코드를 업데이트하십시오. 결정을 안내하려면이 페이지 하단의 &lt;a href=&quot;#Browser_compatibility&quot;&gt;호환성 표&lt;/a&gt; 를 참조하십시오 . 이 기능은 언제든지 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f97d5c5e8a61c76b7ca883b249f65188e1add95" translate="yes" xml:space="preserve">
          <source>This feature is commonly used to allow a resource to be cached in uncompressed and (various) compressed forms, and served appropriately to user agents based on the encodings that they support. For example, a server can set &lt;code&gt;Vary: Accept-Encoding&lt;/code&gt; to ensure that a separate version of a resource is cached for all requests that specify support for a particular set of encodings, e.g. &lt;code&gt;Accept-Encoding: gzip,deflate,sdch&lt;/code&gt;.</source>
          <target state="translated">This feature is commonly used to allow a resource to be cached in uncompressed and (various) compressed forms, and served appropriately to user agents based on the encodings that they support. For example, a server can set &lt;code&gt;Vary: Accept-Encoding&lt;/code&gt; to ensure that a separate version of a resource is cached for all requests that specify support for a particular set of encodings, e.g. &lt;code&gt;Accept-Encoding: gzip,deflate,sdch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17fdac85d6009334c365dfdd6eb6bef5e4374b26" translate="yes" xml:space="preserve">
          <source>This feature is no longer recommended. Though some browsers might still support it, it may have already been removed from the relevant web standards, may be in the process of being dropped, or may only be kept for compatibility purposes. Avoid using it, and update existing code if possible; see the &lt;a href=&quot;#Browser_compatibility&quot;&gt;compatibility table&lt;/a&gt; at the bottom of this page to guide your decision. Be aware that this feature may cease to work at any time.</source>
          <target state="translated">이 기능은 더 이상 권장되지 않습니다. 일부 브라우저는 여전히이 브라우저를 지원할 수 있지만 관련 웹 표준에서 이미 제거되었거나 삭제 중이거나 호환성을 위해서만 유지 될 수 있습니다. 사용하지 말고 가능한 경우 기존 코드를 업데이트하십시오. 결정을 안내하려면이 페이지 하단의 &lt;a href=&quot;#Browser_compatibility&quot;&gt;호환성 표&lt;/a&gt; 를 참조하십시오 . 이 기능은 언제든지 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad63cac1625affd2a84d66756a720def351fb2b3" translate="yes" xml:space="preserve">
          <source>This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future.</source>
          <target state="translated">이 기능은 비표준이며 표준 트랙이 아닙니다. 웹이있는 프로덕션 사이트에서는 사용하지 마십시오. 모든 사용자에게 적용되는 것은 아닙니다. 구현 간에는 큰 비 호환성이있을 수 있으며 향후 동작이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59314e7aec66910164f6914bdc2ab1c6bad7e1f6" translate="yes" xml:space="preserve">
          <source>This feature is obsolete. Although it may still work in some browsers, its use is discouraged since it could be removed at any time. Try to avoid using it.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 일부 브라우저에서는 여전히 작동하지만 언제든지 제거 할 수 있으므로 사용하지 않는 것이 좋습니다. 사용을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="44d6d26ec2012e7ff67a4bdfd287c446e6ad0a4f" translate="yes" xml:space="preserve">
          <source>This fundamental article describes a typical HTTP session: What happens under the hood when you click on a link in your browser.</source>
          <target state="translated">This fundamental article describes a typical HTTP session: What happens under the hood when you click on a link in your browser.</target>
        </trans-unit>
        <trans-unit id="bc17d0049c62a76188340a479b6da749df640b09" translate="yes" xml:space="preserve">
          <source>This fundamental article describes a typical HTTP session: what happens under the hood when you click on a link in your browser&amp;hellip;</source>
          <target state="translated">이 기본 기사에서는 일반적인 HTTP 세션에 대해 설명합니다. 브라우저에서 링크를 클릭 할 때 발생하는 상황&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="9f93380bea42618419d88a1e2ec92eb06b4070a2" translate="yes" xml:space="preserve">
          <source>This header can be used either with a &lt;a href=&quot;last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; validator, or with an &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;, but not with both.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; 유효성 검사기 또는 &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 있지만 둘 다와 함께 사용할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="e2108a313bc4bb54663d17af6f772b5774776cf7" translate="yes" xml:space="preserve">
          <source>This header from the server tells the client to store a cookie.</source>
          <target state="translated">서버의이 헤더는 클라이언트에게 쿠키를 저장하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="9f3041471fef5fbbbbc5c294aaefd72cf8e4b8e6" translate="yes" xml:space="preserve">
          <source>This header is a hint to be used when the server has no way of determining the language via another way, like a specific URL, that is controlled by an explicit user decision. It is recommended that the server never overrides an explicit decision. The content of the &lt;code&gt;Accept-Language&lt;/code&gt; is often out of the control of the user (like when traveling and using an Internet Cafe in a different country); the user may also want to visit a page in another language than the locale of their user interface.</source>
          <target state="translated">이 헤더는 서버가 명시적인 사용자 결정에 의해 제어되는 특정 URL과 같은 다른 방법을 통해 언어를 결정할 방법이 없을 때 사용되는 힌트입니다. 서버가 명시 적 결정을 무시하지 않는 것이 좋습니다. &lt;code&gt;Accept-Language&lt;/code&gt; 의 내용은 사용자가 통제 할 수없는 경우가 많습니다 (예 : 다른 국가의 인터넷 카페를 여행하거나 이용할 때). 사용자는 자신의 사용자 인터페이스 로캘이 아닌 다른 언어로 페이지를 방문 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e9bd72b00debb383ca11d6751998799ac99152f" translate="yes" xml:space="preserve">
          <source>This header is automatically added by clients that choose to use it; it cannot be added using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader&quot;&gt;&lt;code&gt;XMLHttpRequest.setRequestHeader()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 헤더는 사용하기로 선택한 클라이언트에 의해 자동으로 추가됩니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/setRequestHeader&quot;&gt; &lt;code&gt;XMLHttpRequest.setRequestHeader()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 추가 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4737f0640e2626ce2c86bf3453432d3e8fdff2b5" translate="yes" xml:space="preserve">
          <source>This header is not supported inside a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">이 헤더는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 내에서 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4ac57abc80887b57bdf2fcf4f45fa8fc42191101" translate="yes" xml:space="preserve">
          <source>This header is required if the request has an &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">요청에 &lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; 헤더 가있는 경우이 헤더가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="737f8eaab76cbd788575174bfce1b83385303b75" translate="yes" xml:space="preserve">
          <source>This header is still in an experimental state, and is subject to change at any time. Be wary of this when implementing it on your website. The header has now been renamed to &lt;code&gt;Permissions-Policy&lt;/code&gt; in the spec, and this article will eventually be updated to reflect that change.</source>
          <target state="translated">This header is still in an experimental state, and is subject to change at any time. Be wary of this when implementing it on your website. The header has now been renamed to &lt;code&gt;Permissions-Policy&lt;/code&gt; in the spec, and this article will eventually be updated to reflect that change.</target>
        </trans-unit>
        <trans-unit id="dae9e9e16dbee7cb2e940a19073f03abae67dabc" translate="yes" xml:space="preserve">
          <source>This header is used for debugging, statistics, and generating location-dependent content and by design it exposes privacy sensitive information, such as the IP address of the client. Therefore the user's privacy must be kept in mind when deploying this header.</source>
          <target state="translated">이 헤더는 디버깅, 통계 및 위치 종속 컨텐츠 생성에 사용되며 설계 상 클라이언트의 IP 주소와 같은 개인 정보에 민감한 정보를 노출합니다. 따라서이 헤더를 배포 할 때 사용자의 개인 정보를 염두에 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="e339b1a060076bad3fa562c3df51670b4975b5b9" translate="yes" xml:space="preserve">
          <source>This header must be sent if the server responds with a &lt;a href=&quot;../status/405&quot;&gt;&lt;code&gt;405&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Method Not Allowed&lt;/code&gt; status code to indicate which request methods can be used. An empty &lt;code&gt;Allow&lt;/code&gt; header indicates that the resource allows no request methods, which might occur temporarily for a given resource, for example.</source>
          <target state="translated">서버가 &lt;a href=&quot;../status/405&quot;&gt; &lt;code&gt;405&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Method Not Allowed&lt;/code&gt; 상태 코드로 응답하여 사용할 수있는 요청 방법을 나타내는 경우이 헤더를 보내야합니다 . 빈 &lt;code&gt;Allow&lt;/code&gt; 헤더는 리소스가 요청 리소스를 허용하지 않음을 나타냅니다. 예를 들어 지정된 리소스에 대해 일시적으로 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d038bd6662fb532b2ff18177eb47f5f8cd56f9cb" translate="yes" xml:space="preserve">
          <source>This header reports violations that would have occurred. You can use this to iteratively work on your content security policy. You observe how your site behaves, watching for violation reports, or &lt;a href=&quot;https://secure.wphackedhelp.com/blog/wordpress-malware-redirect-hack-cleanup/&quot;&gt;malware redirects&lt;/a&gt;, then choose the desired policy enforced by the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">This header reports violations that would have occurred. You can use this to iteratively work on your content security policy. You observe how your site behaves, watching for violation reports, or &lt;a href=&quot;https://secure.wphackedhelp.com/blog/wordpress-malware-redirect-hack-cleanup/&quot;&gt;malware redirects&lt;/a&gt;, then choose the desired policy enforced by the &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; header.</target>
        </trans-unit>
        <trans-unit id="65cd8f4bdbc85c57584352cda936cbf16cec5740" translate="yes" xml:space="preserve">
          <source>This header reports violations that would have occurred. You can use this to iteratively work on your content security policy. You observe how your site behaves, watching for violation reports, then choose the desired policy enforced by the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">이 헤더는 발생한 위반을보고합니다. 이를 사용하여 컨텐츠 보안 정책을 반복적으로 작업 할 수 있습니다. 사이트의 작동 방식을 관찰하고 위반 보고서를 관찰 한 후 &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; 헤더로 시행 할 원하는 정책을 선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="6406ecfb1884f34413b4947c4224d8b102734485" translate="yes" xml:space="preserve">
          <source>This header was introduced by Microsoft in IE 8 as a way for webmasters to block content sniffing that was happening and could transform non-executable MIME types into executable MIME types. Since then, other browsers have introduced it, even if their MIME sniffing algorithms were less aggressive.</source>
          <target state="translated">이 헤더는 웹 마스터가 발생하는 콘텐츠 스니핑을 차단하고 실행 불가능한 MIME 유형을 실행 가능한 MIME 유형으로 변환 할 수있는 방법으로 IE 8에서 Microsoft에 의해 도입되었습니다. 그 이후로 MIME 스니핑 알고리즘이 덜 공격적인 경우에도 다른 브라우저에서이를 도입했습니다.</target>
        </trans-unit>
        <trans-unit id="7910eee90b814ebcea921d5e05f3e798655b01a9" translate="yes" xml:space="preserve">
          <source>This interim response indicates that everything so far is OK and that the client should continue the request, or ignore the response if the request is already finished.</source>
          <target state="translated">This interim response indicates that everything so far is OK and that the client should continue the request, or ignore the response if the request is already finished.</target>
        </trans-unit>
        <trans-unit id="c77a8aadedd58ca97eb678dcd40675e7891feafc" translate="yes" xml:space="preserve">
          <source>This interim response indicates that everything so far is OK and that the client should continue with the request or ignore it if it is already finished.</source>
          <target state="translated">이 임시 응답은 지금까지 모든 것이 정상이며 클라이언트가 요청을 계속하거나 요청이 이미 완료된 경우이를 무시해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="97f1b290f6e916924cd7cb715ba859fdd697edc8" translate="yes" xml:space="preserve">
          <source>This is a problem that most likely can only be fixed on the server side, by modifying the server's configuration to no longer send the invalid or unknown header name with the &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header. It may also be worth checking to ensure that the user agent or HTTP library you're using on the client is up-to-date.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 헤더 와 함께 유효하지 않거나 알 수없는 헤더 이름을 더 이상 보내지 않도록 서버 구성을 수정하면 서버 측에서만 해결할 수있는 문제입니다 . 클라이언트에서 사용중인 사용자 에이전트 또는 HTTP 라이브러리가 최신인지 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5ca266f84de58335a9fa22c96177ea4b42712957" translate="yes" xml:space="preserve">
          <source>This is a problem that most likely can only be fixed on the server side, by modifying the server's configuration to no longer send the invalid or unknown method name with the &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; header. It may also be worth checking to ensure that the user agent or HTTP library you're using on the client is up-to-date.</source>
          <target state="translated">&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; 헤더 로 더 이상 유효하지 않거나 알려지지 않은 메소드 이름을 보내지 않도록 서버의 구성을 수정하여 서버 측에서만 해결할 수있는 문제점입니다 . 클라이언트에서 사용중인 사용자 에이전트 또는 HTTP 라이브러리가 최신인지 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="68654c9820232d31d9835d660a42416043e4d6e6" translate="yes" xml:space="preserve">
          <source>This is a top-down approach in which you build the best possible site using all the features you want, then tweak it to make it work on older browsers. This can be harder to do, and less effective, than progressive enhancement, but may be useful in some cases.</source>
          <target state="translated">이것은 원하는 모든 기능을 사용하여 최상의 사이트를 구축 한 다음 이전 브라우저에서 작동하도록 조정합니다. 점진적 향상보다 수행하기가 어렵고 효과가 떨어질 수 있지만 경우에 따라 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddb9ae3d96d8b78e1be6c37fe9e53f2fec150502" translate="yes" xml:space="preserve">
          <source>This is a very subjective topic it could be considered a &lt;a href=&quot;http://bikeshed.com/&quot;&gt;bikeshedding&lt;/a&gt; issue. If you wish to read deeper, please see some of the &lt;a href=&quot;http://www.themezilla.com/should-you-use-www-in-your-url-or-not/&quot;&gt;many&lt;/a&gt;&lt;a href=&quot;https://www.wpbeginner.com/beginners-guide/www-vs-non-www-which-is-better-for-wordpress-seo/&quot;&gt;articles&lt;/a&gt; on the subject.</source>
          <target state="translated">이것은 &lt;a href=&quot;http://bikeshed.com/&quot;&gt;자전거 흘림&lt;/a&gt; 문제 로 간주 될 수있는 매우 주관적인 주제 입니다. 더 자세히 읽으 려면 주제에 대한 &lt;a href=&quot;http://www.themezilla.com/should-you-use-www-in-your-url-or-not/&quot;&gt;많은 &lt;/a&gt;&lt;a href=&quot;https://www.wpbeginner.com/beginners-guide/www-vs-non-www-which-is-better-for-wordpress-seo/&quot;&gt;기사&lt;/a&gt; 중 일부를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="641095a78e4ebe2abe2b4166aac4c4584c32cfcf" translate="yes" xml:space="preserve">
          <source>This is a very subjective topic it could be considered a &lt;a href=&quot;http://bikeshed.com/&quot;&gt;bikeshedding&lt;/a&gt; issue. If you wish to read deeper, please see some of the &lt;a href=&quot;https://www.netlify.com/blog/2017/02/28/to-www-or-not-www/&quot;&gt;many&lt;/a&gt;&lt;a href=&quot;https://www.wpbeginner.com/beginners-guide/www-vs-non-www-which-is-better-for-wordpress-seo/&quot;&gt;articles&lt;/a&gt; on the subject.</source>
          <target state="translated">This is a very subjective topic it could be considered a &lt;a href=&quot;http://bikeshed.com/&quot;&gt;bikeshedding&lt;/a&gt; issue. If you wish to read deeper, please see some of the &lt;a href=&quot;https://www.netlify.com/blog/2017/02/28/to-www-or-not-www/&quot;&gt;many&lt;/a&gt;&lt;a href=&quot;https://www.wpbeginner.com/beginners-guide/www-vs-non-www-which-is-better-for-wordpress-seo/&quot;&gt;articles&lt;/a&gt; on the subject.</target>
        </trans-unit>
        <trans-unit id="80608a6f9119cc7c4582aee9309cf18792c53923" translate="yes" xml:space="preserve">
          <source>This is an improvement over earlier &lt;code&gt;Accept&lt;/code&gt; headers as it no longer ranks &lt;code&gt;image/png&lt;/code&gt; above &lt;code&gt;text/html&lt;/code&gt;</source>
          <target state="translated">더 이상 &lt;code&gt;text/html&lt;/code&gt; 보다 &lt;code&gt;image/png&lt;/code&gt; 순위를 가지지 않기 때문에 이전 &lt;code&gt;Accept&lt;/code&gt; 헤더 보다 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="b2128edd161faa94a80e6eb961a49e5e2001c4b7" translate="yes" xml:space="preserve">
          <source>This is an obsolete directive that no longer works in modern browsers. Don't use it. In supporting legacy browsers, a page can be displayed in a frame only on the specified origin &lt;em&gt;uri&lt;/em&gt;. Note that in the legacy Firefox implementation this still suffered from the same problem as &lt;code&gt;SAMEORIGIN&lt;/code&gt; did &amp;mdash; it doesn't check the frame ancestors to see if they are in the same origin. The &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header has a &lt;a href=&quot;content-security-policy/frame-ancestors&quot;&gt;&lt;code&gt;frame-ancestors&lt;/code&gt;&lt;/a&gt; directive which you can use instead.</source>
          <target state="translated">This is an obsolete directive that no longer works in modern browsers. Don't use it. In supporting legacy browsers, a page can be displayed in a frame only on the specified origin &lt;em&gt;uri&lt;/em&gt;. Note that in the legacy Firefox implementation this still suffered from the same problem as &lt;code&gt;SAMEORIGIN&lt;/code&gt; did &amp;mdash; it doesn't check the frame ancestors to see if they are in the same origin. The &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; HTTP header has a &lt;a href=&quot;content-security-policy/frame-ancestors&quot;&gt; &lt;code&gt;frame-ancestors&lt;/code&gt; &lt;/a&gt; directive which you can use instead.</target>
        </trans-unit>
        <trans-unit id="0c4a19f41f357e975c7ecf272280bda06a0a7837" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f3c017ea67402b333e111c91d0d8c835c18ed46a" translate="yes" xml:space="preserve">
          <source>This is implemented using the &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; headers. If the etag doesn't match the original file, or if the file has been modified since it has been obtained, the change is simply rejected with a &lt;a href=&quot;status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Precondition Failed&lt;/code&gt; error. It is then up to the client to deal with the error: either by notifying the user to start again (this time on the newest version), or by showing the user a &lt;em&gt;diff &lt;/em&gt;of both versions, helping them decide which changes they wish to keep.</source>
          <target state="translated">이것은 &lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt; 헤더를 사용하여 구현됩니다 . etag가 원본 파일과 일치하지 않거나 파일을 얻은 후 수정 된 경우에는 &lt;a href=&quot;status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Precondition Failed&lt;/code&gt; 오류 와 함께 변경이 거부됩니다 . 오류를 처리하는 것은 클라이언트에게 달려 있습니다. 사용자에게 다시 시작하도록 알리거나 (이번에는 최신 버전에서) 사용자에게 두 버전 의 &lt;em&gt;차이점&lt;/em&gt; 을 보여 주어 유지하려는 변경 사항을 결정할 수 있도록합니다. .</target>
        </trans-unit>
        <trans-unit id="124f23444ec9f501d1f80c6afe1cad1494209a7a" translate="yes" xml:space="preserve">
          <source>This is part of an &lt;strong&gt;experimental&lt;/strong&gt; technology called &lt;em&gt;Client Hints &lt;/em&gt; and is only available in Chrome 61 or later.</source>
          <target state="translated">이는 &lt;em&gt;클라이언트 힌트&lt;/em&gt; 라는 &lt;strong&gt;실험&lt;/strong&gt; 기술의 일부이며 Chrome 61 이상에서만 사용할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8cd6fbb7a4f7885010a0bffbaf4241fed054fc3" translate="yes" xml:space="preserve">
          <source>This is part of an &lt;strong&gt;experimental&lt;/strong&gt; technology called &lt;em&gt;Client Hints&lt;/em&gt; and is only available in Chrome 61 or later.</source>
          <target state="translated">This is part of an &lt;strong&gt;experimental&lt;/strong&gt; technology called &lt;em&gt;Client Hints&lt;/em&gt; and is only available in Chrome 61 or later.</target>
        </trans-unit>
        <trans-unit id="d2cd90cf410e959cd661c8e83d47ed919723c7b5" translate="yes" xml:space="preserve">
          <source>This is part of an &lt;strong&gt;experimental&lt;/strong&gt; technology called &lt;em&gt;Client Hints&lt;/em&gt;. Initial support is in Chrome 46 or later. The Device-Memory value is in Chrome 61 or later.</source>
          <target state="translated">이것은 &lt;em&gt;클라이언트 힌트&lt;/em&gt; 라는 &lt;strong&gt;실험&lt;/strong&gt; 기술의 일부입니다 . 초기 지원은 Chrome 46 이상입니다. 기기 메모리 값은 Chrome 61 이상입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c9b9f265a030439ad0eded89740990c1cd0e705" translate="yes" xml:space="preserve">
          <source>This is similar to 401 but authentication is needed to be done by a proxy.</source>
          <target state="translated">이것은 401과 비슷하지만 프록시로 인증을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="eeed176b4c6d9e486d6e3b46cc4c1482f2ae547b" translate="yes" xml:space="preserve">
          <source>This is the default behavior if no policy is specified, or if the provided value is invalid. The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/path&quot;&gt;path&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/querystring&quot;&gt;querystring&lt;/a&gt; of the URL are sent as a referrer when the protocol security level stays the same (HTTP&amp;rarr;HTTP, HTTPS&amp;rarr;HTTPS) or improves (HTTP&amp;rarr;HTTPS), but isn't sent to less secure destinations (HTTPS&amp;rarr;HTTP).</source>
          <target state="translated">This is the default behavior if no policy is specified, or if the provided value is invalid. The &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/path&quot;&gt;path&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/querystring&quot;&gt;querystring&lt;/a&gt; of the URL are sent as a referrer when the protocol security level stays the same (HTTP&amp;rarr;HTTP, HTTPS&amp;rarr;HTTPS) or improves (HTTP&amp;rarr;HTTPS), but isn't sent to less secure destinations (HTTPS&amp;rarr;HTTP).</target>
        </trans-unit>
        <trans-unit id="8f1bfe2beacf7098474167acd9a0dc8c20186348" translate="yes" xml:space="preserve">
          <source>This is the default for binary files. As it means &lt;em&gt;unknown binary &lt;/em&gt; file, browsers usually don't execute it, or even ask if it should be executed. They treat it as if the &lt;a href=&quot;../headers/content-disposition&quot;&gt;&lt;code&gt;Content-Disposition&lt;/code&gt;&lt;/a&gt; header was set to &lt;code&gt;attachment&lt;/code&gt;, and propose a &quot;Save As&quot; dialog.</source>
          <target state="translated">이진 파일의 기본값입니다. &lt;em&gt;알 수없는 이진&lt;/em&gt; 파일을 의미하므로 브라우저는 일반적으로 파일을 실행하지 않거나 실행해야하는지 묻습니다. 그들은 &lt;a href=&quot;../headers/content-disposition&quot;&gt; &lt;code&gt;Content-Disposition&lt;/code&gt; &lt;/a&gt; 헤더가 &lt;code&gt;attachment&lt;/code&gt; 로 설정된 것처럼 취급 하고 &quot;다른 이름으로 저장&quot;대화 상자를 제안합니다.</target>
        </trans-unit>
        <trans-unit id="763b865e8143c4b06adf307c51b45264f147e5ff" translate="yes" xml:space="preserve">
          <source>This is the default for binary files. As it means &lt;em&gt;unknown binary&lt;/em&gt; file, browsers usually don't execute it, or even ask if it should be executed. They treat it as if the &lt;a href=&quot;../headers/content-disposition&quot;&gt;&lt;code&gt;Content-Disposition&lt;/code&gt;&lt;/a&gt; header was set to &lt;code&gt;attachment&lt;/code&gt;, and propose a &quot;Save As&quot; dialog.</source>
          <target state="translated">This is the default for binary files. As it means &lt;em&gt;unknown binary&lt;/em&gt; file, browsers usually don't execute it, or even ask if it should be executed. They treat it as if the &lt;a href=&quot;../headers/content-disposition&quot;&gt; &lt;code&gt;Content-Disposition&lt;/code&gt; &lt;/a&gt; header was set to &lt;code&gt;attachment&lt;/code&gt; , and propose a &quot;Save As&quot; dialog.</target>
        </trans-unit>
        <trans-unit id="5a1fbd395e24ae5276bcd50aae6f6286330fa789" translate="yes" xml:space="preserve">
          <source>This is the default for textual files. Even if it really means &quot;unknown textual file,&quot; browsers assume they can display it.</source>
          <target state="translated">This is the default for textual files. Even if it really means &quot;unknown textual file,&quot; browsers assume they can display it.</target>
        </trans-unit>
        <trans-unit id="9273da9e8fd5fcf9c3bde1b24ef99c570ddd6fd7" translate="yes" xml:space="preserve">
          <source>This is the default for textual files. Even if it really means &lt;em&gt;unknown textual&lt;/em&gt; file, browsers assume they can display it.</source>
          <target state="translated">텍스트 파일의 기본값입니다. &lt;em&gt;알 수없는 텍스트&lt;/em&gt; 파일을 의미하더라도 브라우저는 파일을 표시 할 수 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e89b69639ed3c3449649e0ef238ba09b307791ec" translate="yes" xml:space="preserve">
          <source>This is the user agent's default behavior if no policy is specified. The URL is sent as a referrer when the protocol security level stays the same (HTTP&amp;rarr;HTTP, HTTPS&amp;rarr;HTTPS), but isn't sent to a less secure destination (HTTPS&amp;rarr;HTTP).</source>
          <target state="translated">정책이 지정되지 않은 경우 이는 사용자 에이전트의 기본 동작입니다. 프로토콜 보안 수준이 동일하게 유지 될 때 (HTTP &amp;rarr; HTTP, HTTPS &amp;rarr; HTTPS) URL은 참조 자로 전송되지만 보안 수준이 낮은 대상 (HTTPS &amp;rarr; HTTP)으로 전송되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="aec6ea7897565c6f7f8de375d3405f1846b40c5a" translate="yes" xml:space="preserve">
          <source>This is the user agent's default behavior if no policy is specified. The origin is sent as referrer to a-priori as-much-secure destination (HTTPS-&amp;gt;HTTPS), but isn't sent to a less secure destination (HTTPS-&amp;gt;HTTP).</source>
          <target state="translated">정책이 지정되지 않은 경우 이는 사용자 에이전트의 기본 동작입니다. 오리진은 보안 상 가장 안전한 대상 (HTTPS-&amp;gt; HTTPS)에 대한 참조 자로 전송되지만 덜 안전한 대상 (HTTPS-&amp;gt; HTTP)으로 전송되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="176fe26e859db9d8a79b1329a0c4c540c8bdb602" translate="yes" xml:space="preserve">
          <source>This is used for caching purposes. It tells the client that the response has not been modified, so the client can continue to use the same cached version of the response.</source>
          <target state="translated">캐싱 목적으로 사용됩니다. 클라이언트에게 응답이 수정되지 않았 음을 알리므로 클라이언트는 동일한 캐시 버전의 응답을 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db5ca9d8b582bb760db634b162cc4217b98dc46c" translate="yes" xml:space="preserve">
          <source>This is usually a bad practice, but there are some cases in which this is necessary. In these cases, you should first analyze your situation to be sure it's really necessary. Can you prevent it by adding some non-semantic &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt;&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;&lt;/a&gt; elements? The difficulty of successfully using user agent detection is worth a few disruptions to the purity of your HTML. Also, rethink your design: can you use progressive enhancement or fluid layouts to help remove the need to do this?</source>
          <target state="translated">이것은 일반적으로 나쁜 습관이지만 이것이 필요한 경우가 있습니다. 이러한 경우에는 상황을 먼저 분석하여 실제로 필요한지 확인해야합니다. 의미없는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div&quot;&gt; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/span&quot;&gt; &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 를 추가하여이를 방지 할 수 있습니까 ? 사용자 에이전트 감지를 성공적으로 사용하는 데 어려움이 있다면 HTML 순도를 약간 떨어 뜨릴 가치가 있습니다. 또한 디자인을 다시 생각하십시오. 점진적 향상 또는 유동적 인 레이아웃을 사용하여이를 수행 할 필요가 없습니까?</target>
        </trans-unit>
        <trans-unit id="0d42afd2b8cd7621e5970bc258f4d2e2f724c681" translate="yes" xml:space="preserve">
          <source>This means that if you do not need to support legacy browsers, it is recommended that you use &lt;code&gt;&lt;a href=&quot;content-security-policy&quot;&gt;Content-Security-Policy&lt;/a&gt;&lt;/code&gt; without allowing &lt;code&gt;unsafe-inline&lt;/code&gt; scripts instead.</source>
          <target state="translated">This means that if you do not need to support legacy browsers, it is recommended that you use &lt;code&gt;&lt;a href=&quot;content-security-policy&quot;&gt;Content-Security-Policy&lt;/a&gt;&lt;/code&gt; without allowing &lt;code&gt;unsafe-inline&lt;/code&gt; scripts instead.</target>
        </trans-unit>
        <trans-unit id="17702de3201465eb14c00b1b36262a93968df79b" translate="yes" xml:space="preserve">
          <source>This means that the resource is now permanently located at another URI, specified by the &lt;code&gt;Location:&lt;/code&gt; HTTP Response header. This has the same semantics as the &lt;code&gt;301 Moved Permanently&lt;/code&gt; HTTP response code, with the exception that the user agent &lt;em&gt;must not&lt;/em&gt; change the HTTP method used: If a &lt;code&gt;POST&lt;/code&gt; was used in the first request, a &lt;code&gt;POST&lt;/code&gt; must be used in the second request.</source>
          <target state="translated">이는 이제 자원이 &lt;code&gt;Location:&lt;/code&gt; HTTP Response 헤더에 의해 지정된 다른 URI에 영구적으로 위치 함을 의미합니다 . 것과 동일한 의미를 갖는다 &lt;code&gt;301 Moved Permanently&lt;/code&gt; 사용자 에이전트는 것을 제외하고는, HTTP 응답 코드 &lt;em&gt;안&lt;/em&gt; 경우 사용되는 HTTP 방법을 변경 &lt;code&gt;POST&lt;/code&gt; 가 첫 번째 요청에 사용 하였다하는 &lt;code&gt;POST&lt;/code&gt; 는 두 번째 요청에 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="37f8e68ab017e83ab3d110757c8a5ccd4bf55d28" translate="yes" xml:space="preserve">
          <source>This mechanism is always client initiated (with one exception: it's possible for the server to &lt;a href=&quot;#Server-initiated_upgrade_to_TLS&quot;&gt;require an upgrade to TLS&lt;/a&gt;), and the server may accept or refuse the switch to the new protocol. This makes it possible to start a connection using a commonly-used protocol, such as HTTP/1.1, then request that the connection switch to HTTP/2 or even to WebSockets.</source>
          <target state="translated">이 메커니즘은 항상 클라이언트에서 시작되며 (단 한 가지 예외 : 서버 &lt;a href=&quot;#Server-initiated_upgrade_to_TLS&quot;&gt;에서 TLS로 업그레이드해야&lt;/a&gt; 할 수 있음) 서버는 새 프로토콜로의 전환을 수락하거나 거부 할 수 있습니다. 이를 통해 HTTP / 1.1과 같이 일반적으로 사용되는 프로토콜을 사용하여 연결을 시작한 다음 연결이 HTTP / 2 또는 WebSocket으로 전환되도록 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fd8e35050a88061004785e66da5be5ef6c4558f" translate="yes" xml:space="preserve">
          <source>This mechanism is optional; it cannot be used to insist on a protocol change. Implementations can choose not to take advantage of an upgrade even if they support the new protocol, and in practice, this mechanism is used mostly to bootstrap a WebSockets connection.</source>
          <target state="translated">This mechanism is optional; it cannot be used to insist on a protocol change. Implementations can choose not to take advantage of an upgrade even if they support the new protocol, and in practice, this mechanism is used mostly to bootstrap a WebSockets connection.</target>
        </trans-unit>
        <trans-unit id="930c017a0341cb94a246a09014c32e54c099c6b0" translate="yes" xml:space="preserve">
          <source>This message means that the browser saw the &lt;code&gt;Large-Allocation&lt;/code&gt; header, and was able to reload the page into a new process which should have more available contiguous memory.</source>
          <target state="translated">이 메시지는 브라우저가 &lt;code&gt;Large-Allocation&lt;/code&gt; 헤더를 보고 더 많은 사용 가능한 연속 메모리를 가져야하는 새 프로세스로 페이지를 다시로드 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7884c1f5aebded20cacbf12f85bb3629712f95c4" translate="yes" xml:space="preserve">
          <source>This model is the default model used in HTTP/1.0 (if there is no &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header, or if its value is set to &lt;code&gt;close&lt;/code&gt;). In HTTP/1.1, this model is only used when the &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; header is sent with a value of &lt;code&gt;close&lt;/code&gt;.</source>
          <target state="translated">이 모델은 HTTP / 1.0에서 사용되는 기본 모델입니다 ( &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 헤더가 없거나 값이 &lt;code&gt;close&lt;/code&gt; 로 설정된 경우 ). HTTP / 1.1에서이 모델은 &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 헤더가 &lt;code&gt;close&lt;/code&gt; 값으로 전송 될 때만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f8dd381093e02d3c56d8bf2d6a1a2b6d6c9bc23" translate="yes" xml:space="preserve">
          <source>This page is not complete.</source>
          <target state="translated">이 페이지는 완성되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2700ae9496ac92696a2d7d32affc7822518ebd17" translate="yes" xml:space="preserve">
          <source>This page was loaded in a new process due to a &lt;code&gt;Large-Allocation&lt;/code&gt; header.</source>
          <target state="translated">이 페이지는 &lt;code&gt;Large-Allocation&lt;/code&gt; 헤더 로 인해 새 프로세스에로드되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0cac347b43837064b316648d4989da0372112872" translate="yes" xml:space="preserve">
          <source>This page would be loaded in a new process due to a &lt;code&gt;Large-Allocation&lt;/code&gt; header, however &lt;code&gt;Large-Allocation&lt;/code&gt; process creation is disabled on non-Win32 platforms.</source>
          <target state="translated">이 페이지는 &lt;code&gt;Large-Allocation&lt;/code&gt; 헤더 로 인해 새 프로세스에로드 되지만 Win32 이외의 플랫폼 에서는 &lt;code&gt;Large-Allocation&lt;/code&gt; 프로세스 생성이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="24edd3164f6204b4aeaaef84edccb45a164270bb" translate="yes" xml:space="preserve">
          <source>This pattern of the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; headers is the simplest use of the access control protocol. If the resource owners at &lt;code&gt;https://bar.other&lt;/code&gt; wished to restrict access to the resource to requests &lt;em&gt;only&lt;/em&gt; from &lt;code&gt;https://foo.example&lt;/code&gt;, (i.e no domain other than &lt;code&gt;https://foo.example&lt;/code&gt; can access the resource in a cross-site manner) they would send:</source>
          <target state="translated">This pattern of the &lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; headers is the simplest use of the access control protocol. If the resource owners at &lt;code&gt;https://bar.other&lt;/code&gt; wished to restrict access to the resource to requests &lt;em&gt;only&lt;/em&gt; from &lt;code&gt;https://foo.example&lt;/code&gt; , (i.e no domain other than &lt;code&gt;https://foo.example&lt;/code&gt; can access the resource in a cross-site manner) they would send:</target>
        </trans-unit>
        <trans-unit id="07bca8347d8092d11755f1e4e5691c56881328bb" translate="yes" xml:space="preserve">
          <source>This performs a simple exchange between the client and the server, using CORS headers to handle the privileges:</source>
          <target state="translated">This performs a simple exchange between the client and the server, using CORS headers to handle the privileges:</target>
        </trans-unit>
        <trans-unit id="012dc0221186c93aa5f93e94a45c4ed8bd7f1e8a" translate="yes" xml:space="preserve">
          <source>This policy will leak origins and paths from TLS-protected resources to insecure origins. Carefully consider the impact of this setting.</source>
          <target state="translated">이 정책은 TLS로 보호되는 리소스에서 안전하지 않은 오리진으로 오리진 및 경로를 유출합니다. 이 설정의 영향을 신중하게 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e32c67984e9c6672ef8d338fdf20280130724f78" translate="yes" xml:space="preserve">
          <source>This policy will leak potentially-private information from HTTPS resource URLs to insecure origins. Carefully consider the impact of this setting.</source>
          <target state="translated">This policy will leak potentially-private information from HTTPS resource URLs to insecure origins. Carefully consider the impact of this setting.</target>
        </trans-unit>
        <trans-unit id="777df6e36502c801cccff6604d845d23f1626c6e" translate="yes" xml:space="preserve">
          <source>This prefetching is performed in the background, so that the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DNS&quot;&gt;DNS&lt;/a&gt; is likely to have been resolved by the time the referenced items are needed. This reduces latency when the user clicks a link.</source>
          <target state="translated">이 프리 페치는 백그라운드에서 수행되므로 참조 항목이 필요할 때 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DNS&quot;&gt;DNS&lt;/a&gt; 가 해결되었을 가능성이 있습니다. 사용자가 링크를 클릭 할 때 대기 시간이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="322ff44ffffc8c1929757a32b5dd54ce49618142" translate="yes" xml:space="preserve">
          <source>This rapid adoption rate was likely as HTTP/2 does not require adaptation of Web sites and applications: using HTTP/1.1 or HTTP/2 is transparent for them. Having an up-to-date server communicating with a recent browser is enough to enable its use: only a limited set of groups were needed to trigger adoption, and as legacy browser and server versions are renewed, usage has naturally increased, without further Web developer efforts.</source>
          <target state="translated">HTTP / 2는 웹 사이트 및 응용 프로그램을 조정할 필요가 없기 때문에 빠른 채택률이 높았습니다. HTTP / 1.1 또는 HTTP / 2를 사용하는 것은 투명합니다. 최신 서버와 최신 서버와 통신하는 것만으로도 충분히 사용할 수 있습니다. 제한된 그룹 집합 만 채택하면 트리거가 가능하고 레거시 브라우저 및 서버 버전이 갱신됨에 따라 웹을 추가하지 않고도 사용량이 자연스럽게 증가했습니다. 개발자 노력.</target>
        </trans-unit>
        <trans-unit id="9bd4e192aba5cf8728bcb7d85247e143a7a701f5" translate="yes" xml:space="preserve">
          <source>This represents an HTML resource whose contents are:</source>
          <target state="translated">내용이 다음과 같은 HTML 리소스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9e1a08d4ddad6242047c3f07fe630aad370f9ebd" translate="yes" xml:space="preserve">
          <source>This response code is no longer used, it is just reserved currently. It was used in a previous version of the HTTP 1.1 specification.</source>
          <target state="translated">이 응답 코드는 더 이상 사용되지 않으며 현재 예약되어 있습니다. HTTP 1.1 스펙의 이전 버전에서 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="8d9b5cfc9ffb70c58676155836edb7100932e47c" translate="yes" xml:space="preserve">
          <source>This response code is no longer used; it is just reserved. It was used in a previous version of the HTTP/1.1 specification.</source>
          <target state="translated">This response code is no longer used; it is just reserved. It was used in a previous version of the HTTP/1.1 specification.</target>
        </trans-unit>
        <trans-unit id="196c5e3984dee3a01e3d4870bc32fe1976f373ee" translate="yes" xml:space="preserve">
          <source>This response code is reserved for future use. Initial aim for creating this code was using it for digital payment systems however this is not used currently.</source>
          <target state="translated">이 응답 코드는 나중에 사용하기 위해 예약되어 있습니다. 이 코드를 작성하기위한 초기 목표는 디지털 지불 시스템에 사용되었지만 현재는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2dd19a171f836779710936f505245545bdd2344b" translate="yes" xml:space="preserve">
          <source>This response code is reserved for future use. The initial aim for creating this code was using it for digital payment systems, however this status code is used very rarely and no standard convention exists.</source>
          <target state="translated">This response code is reserved for future use. The initial aim for creating this code was using it for digital payment systems, however this status code is used very rarely and no standard convention exists.</target>
        </trans-unit>
        <trans-unit id="17caf511cbbea70b5e359bd60edd742730612bb2" translate="yes" xml:space="preserve">
          <source>This response code is sent after accomplishing request to tell user agent reset document view which sent this request.</source>
          <target state="translated">이 응답 코드는 요청을 완료 한 후 전송되어 사용자 에이전트에게이 요청을 보낸 문서보기를 재설정하도록합니다.</target>
        </trans-unit>
        <trans-unit id="a6e3073e4af982c8216898b651b8900b118d9707" translate="yes" xml:space="preserve">
          <source>This response code is used because of range header sent by the client to separate download into multiple streams.</source>
          <target state="translated">이 응답 코드는 다운로드를 여러 스트림으로 분리하기 위해 클라이언트가 전송 한 범위 헤더 때문에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b0b3091267e6eb1f6619e52e3332c6b0eef55bd5" translate="yes" xml:space="preserve">
          <source>This response code is used when the &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header is sent from the client to request only part of a resource.</source>
          <target state="translated">This response code is used when the &lt;a href=&quot;headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; header is sent from the client to request only part of a resource.</target>
        </trans-unit>
        <trans-unit id="54001a8a74f4230a78d081c9dd427598feb0b64e" translate="yes" xml:space="preserve">
          <source>This response code means returned meta-information set is not exact set as available from the origin server, but collected from a local or a third party copy. Except this condition, 200 OK response should be preferred instead of this response.</source>
          <target state="translated">이 응답 코드는 리턴 된 메타 정보 세트가 원래 서버에서 사용 가능한 정확한 세트가 아니라 로컬 또는 써드 파티 사본에서 수집됨을 의미합니다. 이 조건을 제외하고이 응답 대신 200 OK 응답이 선호되어야합니다.</target>
        </trans-unit>
        <trans-unit id="adaff7b5972a65eef381227188ec9967318ffddd" translate="yes" xml:space="preserve">
          <source>This response code means that the URI of requested resource has been changed &lt;em&gt;temporarily&lt;/em&gt;. Further changes in the URI might be made in the future. Therefore, this same URI should be used by the client in future requests.</source>
          <target state="translated">This response code means that the URI of requested resource has been changed &lt;em&gt;temporarily&lt;/em&gt;. Further changes in the URI might be made in the future. Therefore, this same URI should be used by the client in future requests.</target>
        </trans-unit>
        <trans-unit id="a48afdbe246b4285c52a497fa58e9555d4417761" translate="yes" xml:space="preserve">
          <source>This response code means that the URI of requested resource has been changed &lt;em&gt;temporarily&lt;/em&gt;. New changes in the URI might be made in the future. Therefore, this same URI should be used by the client in future requests.</source>
          <target state="translated">이 응답 코드는 요청 된 자원의 URI가 &lt;em&gt;일시적&lt;/em&gt; 으로 변경되었음을 의미합니다 . 향후 URI에서 새로운 변경이 이루어질 수 있습니다. 따라서 향후 요청에서 클라이언트가 동일한 URI를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="796776b8f699ee7445564de16ff0f1e7a6734445" translate="yes" xml:space="preserve">
          <source>This response code means that the URI of the requested resource has been changed. Probably, the new URI would be given in the response.</source>
          <target state="translated">이 응답 코드는 요청 된 자원의 URI가 변경되었음을 의미합니다. 아마도 새로운 URI가 응답에 주어질 것입니다.</target>
        </trans-unit>
        <trans-unit id="d31becaff4260704a27003cc76245a28d6fbfe6e" translate="yes" xml:space="preserve">
          <source>This response code means the expectation indicated by the &lt;code&gt;Expect&lt;/code&gt; request header field can't be met by the server.</source>
          <target state="translated">이 응답 코드 는 서버 가 &lt;code&gt;Expect&lt;/code&gt; 요청 헤더 필드로 표시된 예상을 충족 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f85333520aaa3b92348b920c927ea684bb37f464" translate="yes" xml:space="preserve">
          <source>This response code means the returned meta-information is not exactly the same as is available from the origin server, but is collected from a local or a third-party copy. This is mostly used for mirrors or backups of another resource. Except for that specific case, the &quot;200 OK&quot; response is preferred to this status.</source>
          <target state="translated">This response code means the returned meta-information is not exactly the same as is available from the origin server, but is collected from a local or a third-party copy. This is mostly used for mirrors or backups of another resource. Except for that specific case, the &quot;200 OK&quot; response is preferred to this status.</target>
        </trans-unit>
        <trans-unit id="276e87f04788008ea8cf8cd65690a3af4d8541d7" translate="yes" xml:space="preserve">
          <source>This response is sent on an idle connection by some servers, even without any previous request by the client. It means that the server would like to shut down this unused connection. This response is used much more since some browsers, like Chrome, Firefox 27+, or IE9, use HTTP pre-connection mechanisms to speed up surfing. Also note that some servers merely shut down the connection without sending this message.</source>
          <target state="translated">이 응답은 클라이언트의 이전 요청 없이도 일부 서버에서 유휴 연결로 전송됩니다. 서버가이 사용되지 않는 연결을 종료하려고 함을 의미합니다. 이 응답은 Chrome, Firefox 27 이상 또는 IE9와 같은 일부 브라우저가 HTTP 사전 연결 메커니즘을 사용하여 서핑 속도를 높이기 때문에 훨씬 더 많이 사용됩니다. 또한 일부 서버는이 메시지를 보내지 않고 연결을 종료하기 만합니다.</target>
        </trans-unit>
        <trans-unit id="2c19fa8f26e55768b081e1362d43a2a5e678955c" translate="yes" xml:space="preserve">
          <source>This response is sent when a request conflicts with the current state of the server.</source>
          <target state="translated">요청이 서버의 현재 상태와 충돌 할 때이 응답이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="e9b8041c4bfcb3ea983601ee1d46fb89425a8ff6" translate="yes" xml:space="preserve">
          <source>This response is sent when the requested content has been permanently deleted from server, with no forwarding address. Clients are expected to remove their caches and links to the resource. The HTTP specification intends this status code to be used for &quot;limited-time, promotional services&quot;. APIs should not feel compelled to indicate resources that have been deleted with this status code.</source>
          <target state="translated">This response is sent when the requested content has been permanently deleted from server, with no forwarding address. Clients are expected to remove their caches and links to the resource. The HTTP specification intends this status code to be used for &quot;limited-time, promotional services&quot;. APIs should not feel compelled to indicate resources that have been deleted with this status code.</target>
        </trans-unit>
        <trans-unit id="6c23f72de698fc46f7f3192934a03283e62349b8" translate="yes" xml:space="preserve">
          <source>This response is sent when the web server, after performing &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Content_negotiation#Server-driven_negotiation&quot;&gt;server-driven content negotiation&lt;/a&gt;, doesn't find any content following the criteria given by the user agent.</source>
          <target state="translated">이 응답은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Content_negotiation#Server-driven_negotiation&quot;&gt;서버 구동 컨텐츠 협상&lt;/a&gt; 을 수행 한 후 웹 서버 가 사용자 에이전트가 제공 한 기준을 따르는 컨텐츠를 찾지 못할 때 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="f98b7a29dead3c53a44ae4ec7ab268f3fe1c0fc6" translate="yes" xml:space="preserve">
          <source>This response is sent when the web server, after performing &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Content_negotiation#Server-driven_negotiation&quot;&gt;server-driven content negotiation&lt;/a&gt;, doesn't find any content that conforms to the criteria given by the user agent.</source>
          <target state="translated">This response is sent when the web server, after performing &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/HTTP/Content_negotiation#Server-driven_negotiation&quot;&gt;server-driven content negotiation&lt;/a&gt;, doesn't find any content that conforms to the criteria given by the user agent.</target>
        </trans-unit>
        <trans-unit id="20edf11481196ba8cc7fb946fd061c712997616b" translate="yes" xml:space="preserve">
          <source>This response is used much more since some browsers, like Chrome, Firefox 27+, and IE9, use HTTP pre-connection mechanisms to speed up surfing.</source>
          <target state="translated">이 응답은 Chrome, Firefox 27 이상 및 IE9와 같은 일부 브라우저가 HTTP 사전 연결 메커니즘을 사용하여 서핑 속도를 높이기 때문에 훨씬 더 많이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="efe292862f7c79acb9c2cf06d20c3228017f8092" translate="yes" xml:space="preserve">
          <source>This response means that server could not understand the request due to invalid syntax.</source>
          <target state="translated">이 응답은 유효하지 않은 구문으로 인해 서버가 요청을 이해할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b752e6a7b8c6d84ac6a300b6dfb2535f1b47b8ae" translate="yes" xml:space="preserve">
          <source>This response would be sent when the requested content has been permanently deleted from server, with no forwarding address. Clients are expected to remove their caches and links to the resource. The HTTP specification intends this status code to be used for &quot;limited-time, promotional services&quot;. APIs should not feel compelled to indicate resources that have been deleted with this status code.</source>
          <target state="translated">요청 된 콘텐츠가 전달 주소없이 서버에서 영구적으로 삭제되면이 응답이 전송됩니다. 클라이언트는 캐시와 자원에 대한 링크를 제거해야합니다. HTTP 사양에서는이 상태 코드를 &quot;제한된 프로모션 서비스&quot;에 사용하려고합니다. API는이 상태 코드로 삭제 된 리소스를 나타내도록 강요해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="eb0cde7eef9a19e7d58639cfa5c60f6f2574ad52" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of HTTP/1.1 header
   fields for applying preconditions on requests.  &lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt; defines
   when the preconditions are applied.  &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt; defines the order of
   evaluation when more than one precondition is present.</source>
          <target state="translated">이 섹션은 요청에 전제 조건을 적용하기위한 HTTP / 1.1 헤더 필드의 구문과 의미를 정의합니다. &lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt; 는 전제 조건이 적용되는시기를 정의합니다. &lt;a href=&quot;#section-6&quot;&gt;섹션 6&lt;/a&gt; 은 둘 이상의 전제 조건이 존재할 때 평가 순서를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="84857579e8f4c4b00cf5ec7e227da62c2cbe3299" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of HTTP/1.1 header
   fields related to caching.</source>
          <target state="translated">이 섹션은 캐싱과 관련된 HTTP / 1.1 헤더 필드의 구문과 의미를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0e8dc398bfb18bf438574e9ca86e1a588f2447e3" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of all standard
   HTTP/1.1 header fields. For entity-header fields, both sender and
   recipient refer to either the client or the server, depending on who
   sends and who receives the entity.</source>
          <target state="translated">이 섹션은 모든 표준 HTTP / 1.1 헤더 필드의 구문과 의미를 정의합니다. 엔터티 헤더 필드의 경우 보낸 사람과받는 사람 모두 엔터티를 보내고받는 사람에 따라 클라이언트 또는 서버를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="96ccae596f81c60b228fa76095eeb49aec1c38ba" translate="yes" xml:space="preserve">
          <source>This section defines the syntax and semantics of header fields
   related to the HTTP authentication framework.</source>
          <target state="translated">이 섹션은 HTTP 인증 프레임 워크와 관련된 헤더 필드의 구문과 의미를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="b059e4393c3ed5f02e30040602db1e13b843ebfb" translate="yes" xml:space="preserve">
          <source>This section describes problems that commonly occur when creating and using &lt;code&gt;data&lt;/code&gt; URLs.</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;data&lt;/code&gt; URL을 만들고 사용할 때 일반적으로 발생하는 문제에 대해 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="509645587a49cf601fb027d0d0b3f365b9c1a570" translate="yes" xml:space="preserve">
          <source>This section describes the semantics specific to the write lock type.
   The write lock is a specific instance of a lock type, and is the only
   lock type described in this specification.

   An exclusive write lock protects a resource: it prevents changes by
   any principal other than the lock creator and in any case where the
   lock token is not submitted (e.g., by a client process other than the
   one holding the lock).

   Clients MUST submit a lock-token they are authorized to use in any
   request that modifies a write-locked resource.  The list of
   modifications covered by a write-lock include:

   1.  A change to any of the following aspects of any write-locked
       resource:

       *  any variant,

       *  any dead property,

       *  any live property that is lockable (a live property is
          lockable unless otherwise defined.)

   2.  For collections, any modification of an internal member URI.  An
       internal member URI of a collection is considered to be modified
       if it is added, removed, or identifies a different resource.
       More discussion on write locks and collections is found in
       &lt;a href=&quot;#section-7.4&quot;&gt;Section 7.4&lt;/a&gt;.

   3.  A modification of the mapping of the root of the write lock,
       either to another resource or to no resource (e.g., DELETE).

   Of the methods defined in HTTP and WebDAV, PUT, POST, PROPPATCH,
   LOCK, UNLOCK, MOVE, COPY (for the destination resource), DELETE, and
   MKCOL are affected by write locks.  All other HTTP/WebDAV methods
   defined so far -- GET in particular -- function independently of a
   write lock.

   The next few sections describe in more specific terms how write locks
   interact with various operations.</source>
          <target state="translated">이 섹션에서는 쓰기 잠금 유형과 관련된 의미를 설명합니다. 쓰기 잠금은 잠금 유형의 특정 인스턴스이며이 사양에 설명 된 유일한 잠금 유형입니다. 단독 쓰기 잠금은 리소스를 보호합니다. 잠금 생성자 이외의 다른 주체와 잠금 토큰이 제출되지 않은 경우 (예 : 잠금을 보유한 클라이언트 프로세스 이외의 클라이언트 프로세스)에 의한 변경을 방지합니다. 클라이언트는 쓰기 잠금 리소스를 수정하는 모든 요청에 ​​사용할 권한이있는 잠금 토큰을 제출해야합니다. 쓰기 잠금이 적용되는 수정 목록에는 다음이 포함됩니다. 1. 쓰기 잠금 리소스의 다음 측면에 대한 변경 사항 : * 변형, * 사용 불능 속성,* 잠글 수있는 라이브 속성 (달리 정의되지 않는 한 라이브 속성은 잠글 수 있음) 2. 컬렉션의 경우 내부 멤버 URI의 수정. 컬렉션의 내부 멤버 URI는 다른 리소스를 추가, 제거 또는 식별하는 경우 수정 된 것으로 간주됩니다. 쓰기 잠금 및 컬렉션에 대한 자세한 내용은 &lt;a href=&quot;#section-7.4&quot;&gt;섹션 7.4&lt;/a&gt; . 3. 쓰기 잠금의 루트를 다른 리소스로 또는 리소스가없는 것으로 (예 : DELETE) 매핑 수정. HTTP 및 WebDAV에 정의 된 메소드 중에서 PUT, POST, PROPPATCH, LOCK, UNLOCK, MOVE, COPY (대상 자원의 경우), DELETE 및 MKCOL은 쓰기 잠금의 영향을받습니다. 지금까지 정의 된 다른 모든 HTTP / WebDAV 메소드 (특히 GET)는 쓰기 잠금과 독립적으로 작동합니다. 다음 몇 섹션에서는 쓰기 잠금이 다양한 작업과 상호 작용하는 방식을보다 구체적인 용어로 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1b8caae975a03a8390b52fa0ed5d2957f9b87b19" translate="yes" xml:space="preserve">
          <source>This section is meant to inform application developers, information
   providers, and users of the security limitations in HTTP/1.1 as
   described by this document. The discussion does not include
   definitive solutions to the problems revealed, though it does make
   some suggestions for reducing security risks.</source>
          <target state="translated">This section is meant to inform application developers, information providers, and users of the security limitations in HTTP/1.1 as described by this document. The discussion does not include definitive solutions to the problems revealed, though it does make some suggestions for reducing security risks.</target>
        </trans-unit>
        <trans-unit id="e14dd174357a0e5e555989561acf1df199436583" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns relevant to HTTP semantics and
   its use for transferring information over the Internet.
   Considerations related to message syntax, parsing, and routing are
   discussed in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-9&quot;&gt;Section&amp;nbsp;9 of [RFC7230]&lt;/a&gt;.

   The list of considerations below is not exhaustive.  Most security
   concerns related to HTTP semantics are about securing server-side
   applications (code behind the HTTP interface), securing user agent 

   processing of payloads received via HTTP, or secure use of the
   Internet in general, rather than security of the protocol.  Various
   organizations maintain topical information and links to current
   research on Web application security (e.g., [&lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt;]).</source>
          <target state="translated">이 섹션은 개발자, 정보 제공 업체 및 사용자에게 HTTP 의미와 관련된 알려진 보안 문제 및 인터넷을 통한 정보 전송에 대한 사용에 대해 설명합니다. 메시지 구문, 구문 분석 및 라우팅과 관련된 고려 사항 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-9&quot;&gt;은 [RFC7230]의 섹션 9&lt;/a&gt; 에서 설명 합니다. 아래 고려 사항 목록은 완전한 것이 아닙니다. HTTP 시맨틱과 관련된 대부분의 보안 문제는 서버 측 애플리케이션 (HTTP 인터페이스 뒤의 코드) 보안, HTTP를 통해 수신 된 페이로드의 사용자 에이전트 처리 보안 또는 일반적으로 프로토콜의 보안보다는 인터넷의 안전한 사용에 관한 것입니다. 다양한 조직이 주제 정보를 유지하고 웹 응용 프로그램 보안에 대한 최신 연구 링크 (예 : [ &lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt; ])를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="cc5ec5ca15ce6b7e4d99013caa23973be65f1836" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to HTTP authentication.
   More general security considerations are addressed in HTTP messaging
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and semantics [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].

   Everything about the topic of HTTP authentication is a security
   consideration, so the list of considerations below is not exhaustive.
   Furthermore, it is limited to security considerations regarding the
   authentication framework, in general, rather than discussing all of
   the potential considerations for specific authentication schemes
   (which ought to be documented in the specifications that define those
   schemes).  Various organizations maintain topical information and
   links to current research on Web application security (e.g.,
   [&lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt;]), including common pitfalls for implementing and using the
   authentication schemes found in practice.</source>
          <target state="translated">이 섹션은 개발자, 정보 제공 업체 및 사용자에게 HTTP 인증과 관련된 알려진 보안 문제를 알리기위한 것입니다. 보다 일반적인 보안 고려 사항은 HTTP 메시징 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] 및 시맨틱 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231에서 해결됩니다.&lt;/a&gt;]. HTTP 인증 주제에 대한 모든 것은 보안 고려 사항이므로 아래 고려 사항 목록이 완전한 것은 아닙니다. 또한 특정 인증 체계 (해당 체계를 정의하는 사양에 문서화되어야 함)에 대한 모든 잠재적 고려 사항을 논의하기보다는 일반적으로 인증 프레임 워크와 관련된 보안 고려 사항으로 제한됩니다. 다양한 조직 에서 실제로 발견 된 인증 체계를 구현하고 사용하기위한 일반적인 함정을 포함하여 웹 응용 프로그램 보안 (예 : [ &lt;a href=&quot;#ref-OWASP&quot;&gt;OWASP&lt;/a&gt; ]) 에 대한 최신 연구에 대한 주제 정보와 링크를 유지 관리 합니다.</target>
        </trans-unit>
        <trans-unit id="d7b61cbd1c222657e3948d017b4f1b45bdc23901" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to HTTP caching.  More
   general security considerations are addressed in HTTP messaging
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and semantics [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].

   Caches expose additional potential vulnerabilities, since the
   contents of the cache represent an attractive target for malicious
   exploitation.  Because cache contents persist after an HTTP request
   is complete, an attack on the cache can reveal information long after
   a user believes that the information has been removed from the
   network.  Therefore, cache contents need to be protected as sensitive
   information.

   In particular, various attacks might be amplified by being stored in
   a shared cache; such &quot;cache poisoning&quot; attacks use the cache to
   distribute a malicious payload to many clients, and are especially
   effective when an attacker can use implementation flaws, elevated
   privileges, or other techniques to insert such a response into a
   cache.  One common attack vector for cache poisoning is to exploit
   differences in message parsing on proxies and in user agents; see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.3&quot;&gt;Section&amp;nbsp;3.3.3 of [RFC7230]&lt;/a&gt; for the relevant requirements.

   Likewise, implementation flaws (as well as misunderstanding of cache
   operation) might lead to caching of sensitive information (e.g.,
   authentication credentials) that is thought to be private, exposing
   it to unauthorized parties. 

   Furthermore, the very use of a cache can bring about privacy
   concerns.  For example, if two users share a cache, and the first one
   browses to a site, the second may be able to detect that the other
   has been to that site, because the resources from it load more
   quickly, thanks to the cache.

   Note that the Set-Cookie response header field [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;] does not
   inhibit caching; a cacheable response with a Set-Cookie header field
   can be (and often is) used to satisfy subsequent requests to caches.
   Servers who wish to control caching of these responses are encouraged
   to emit appropriate Cache-Control response header fields.</source>
          <target state="translated">이 섹션은 개발자, 정보 제공 업체 및 사용자에게 HTTP 캐싱과 관련된 알려진 보안 문제를 알리기위한 것입니다. 보다 일반적인 보안 고려 사항은 HTTP 메시징 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] 및 시맨틱 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231에서 해결됩니다.&lt;/a&gt;]. 캐시의 내용은 악의적 인 악용의 대상이되기 때문에 캐시는 잠재적 인 취약점을 추가로 노출시킵니다. HTTP 요청이 완료된 후에도 캐시 내용이 유지되므로 사용자가 네트워크에서 정보가 제거되었다고 생각한 후에 캐시를 공격하면 정보가 노출 될 수 있습니다. 따라서 캐시 내용을 중요한 정보로 보호해야합니다. 특히, 공유 캐시에 저장함으로써 다양한 공격이 증폭 될 수 있습니다. 이러한 &quot;캐시 포이즌&quot;공격은 캐시를 사용하여 악의적 인 페이로드를 많은 클라이언트에 배포하며, 특히 공격자가 구현 결함, 높은 권한 또는 기타 기술을 사용하여 이러한 응답을 캐시에 삽입 할 수있을 때 효과적입니다.캐시 포이즈 닝에 대한 하나의 일반적인 공격 벡터는 프록시와 사용자 에이전트의 메시지 구문 분석의 차이점을 이용하는 것입니다. 보다 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.3&quot;&gt;&lt;/a&gt;관련 요구 사항에 대해서는 [RFC7230]의 3.3.3 절 . 마찬가지로, 구현 결함 (캐시 조작에 대한 오해)은 개인 정보로 간주되는 민감한 정보 (예 : 인증 신임 정보)를 캐싱하여 권한없는 당사자에게 노출시킬 수 있습니다. 또한 캐시를 많이 사용하면 개인 정보 보호 문제가 발생할 수 있습니다. 예를 들어 두 명의 사용자가 캐시를 공유하고 첫 번째 사용자가 사이트를 탐색하는 경우 두 번째 사용자는 캐시 덕분에 다른 사용자가 해당 사이트를 방문했음을 감지 할 수 있습니다. Set-Cookie 응답 헤더 필드 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;]는 캐싱을 금지하지 않습니다. Set-Cookie 헤더 필드를 가진 캐시 가능한 응답은 캐시에 대한 후속 요청을 충족시키는 데 사용될 수 있습니다. 이러한 응답의 캐싱을 제어하려는 서버는 적절한 캐시 제어 응답 헤더 필드를 생성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0e335c0656016c7e9ffd0c440c556a3faf33fe1d" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to the HTTP conditional
   request mechanisms.  More general security considerations are
   addressed in HTTP &quot;Message Syntax and Routing&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and
   &quot;Semantics and Content&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]. 

   The validators defined by this specification are not intended to
   ensure the validity of a representation, guard against malicious
   changes, or detect man-in-the-middle attacks.  At best, they enable
   more efficient cache updates and optimistic concurrent writes when
   all participants are behaving nicely.  At worst, the conditions will
   fail and the client will receive a response that is no more harmful
   than an HTTP exchange without conditional requests.

   An entity-tag can be abused in ways that create privacy risks.  For
   example, a site might deliberately construct a semantically invalid
   entity-tag that is unique to the user or user agent, send it in a
   cacheable response with a long freshness time, and then read that
   entity-tag in later conditional requests as a means of re-identifying
   that user or user agent.  Such an identifying tag would become a
   persistent identifier for as long as the user agent retained the
   original cache entry.  User agents that cache representations ought
   to ensure that the cache is cleared or replaced whenever the user
   performs privacy-maintaining actions, such as clearing stored cookies
   or changing to a private browsing mode.</source>
          <target state="translated">이 섹션은 개발자, 정보 제공 업체 및 사용자에게 HTTP 조건부 요청 메커니즘과 관련된 알려진 보안 문제를 알리기위한 것입니다. 보다 일반적인 보안 고려 사항은 HTTP &quot;Message Syntax and Routing&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] 및 &quot;Semantics and Content&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231에서 다룹니다.&lt;/a&gt;]. 이 사양으로 정의 된 유효성 검사기는 표현의 유효성을 보장하거나 악의적 인 변경을 방지하거나 중간자 공격을 탐지하기위한 것이 아닙니다. 기껏해야 모든 참가자가 잘 동작 할 때보다 효율적인 캐시 업데이트와 낙관적 인 동시 쓰기가 가능합니다. 최악의 경우 조건이 실패하고 클라이언트는 조건부 요청없이 HTTP 교환보다 더 해로운 응답을받습니다. 개인 정보 위험을 유발하는 방식으로 엔티티 태그를 남용 할 수 있습니다. 예를 들어, 사이트는 사용자 또는 사용자 에이전트에 고유 한 의미 적으로 유효하지 않은 엔티티 태그를 의도적으로 구성하고, 신선도 시간이 긴 캐시 가능한 응답으로 전송합니다.그런 다음 해당 사용자 또는 사용자 에이전트를 다시 식별하는 수단으로 나중에 조건부 요청에서 해당 엔티티 태그를 읽습니다. 이러한 식별 태그는 사용자 에이전트가 원래 캐시 항목을 유지하는 한 지속적 식별자가됩니다. 표현을 캐시하는 사용자 에이전트는 사용자가 저장된 쿠키를 지우거나 개인 브라우징 모드로 변경하는 등 개인 정보 유지 관리 작업을 수행 할 때마다 캐시를 ​​지우거나 교체해야합니다.</target>
        </trans-unit>
        <trans-unit id="a8b6ada4af46edbc538acb5ee5cd9d1e819c9d08" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security concerns specific to the HTTP range
   request mechanisms.  More general security considerations are
   addressed in HTTP messaging [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;] and semantics [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].</source>
          <target state="translated">이 섹션은 개발자, 정보 제공 업체 및 사용자에게 HTTP 범위 요청 메커니즘과 관련된 알려진 보안 문제를 알리기위한 것입니다. 보다 일반적인 보안 고려 사항은 HTTP 메시징 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ] 및 의미론 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ]에서 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="20f34b6144b38a6c6e8c314d3b99c718e19c16cf" translate="yes" xml:space="preserve">
          <source>This section is meant to inform developers, information providers,
   and users of known security considerations relevant to HTTP message
   syntax, parsing, and routing.  Security considerations about HTTP
   semantics and payloads are addressed in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;].</source>
          <target state="translated">이 섹션은 개발자, 정보 제공 업체 및 사용자에게 HTTP 메시지 구문, 구문 분석 및 라우팅과 관련된 알려진 보안 고려 사항을 알려줍니다. HTTP 시맨틱 및 페이로드에 대한 보안 고려 사항은 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ]에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6807589d15db566935fa0b36f3c986f0dcb8f1e1" translate="yes" xml:space="preserve">
          <source>This section is provided to detail issues concerning security
   implications of which WebDAV applications need to be aware.

   All of the security considerations of HTTP/1.1 (discussed in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]) and XML (discussed in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;]) also apply to WebDAV.  In
   addition, the security risks inherent in remote authoring require
   stronger authentication technology, introduce several new privacy
   concerns, and may increase the hazards from poor server design.
   These issues are detailed below.</source>
          <target state="translated">이 섹션은 WebDAV 응용 프로그램이 인식해야하는 보안 관련 문제에 대해 자세히 설명합니다. HTTP / 1.1 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]에 설명) 및 XML ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt; ]에 설명)의 모든 보안 고려 사항 도 WebDAV에 적용됩니다. 또한 원격 작성에 내재 된 보안 위험에는보다 강력한 인증 기술이 필요하며 몇 가지 새로운 개인 정보 보호 문제가 발생하며 서버 디자인이 좋지 않아 위험이 증가 할 수 있습니다. 이러한 문제는 아래에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6f1686ad83954bc21d87d0b2feab0950aa7dc14" translate="yes" xml:space="preserve">
          <source>This section lists headers that clients may use when issuing HTTP requests in order to make use of the cross-origin sharing feature. Note that these headers are set for you when making invocations to servers. Developers using cross-site &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; capability do not have to set any cross-origin sharing request headers programmatically.</source>
          <target state="translated">이 섹션에는 클라이언트 간 공유 기능을 사용하기 위해 클라이언트가 HTTP 요청을 발행 할 때 사용할 수있는 헤더가 나열되어 있습니다. 이 헤더는 서버를 호출 할 때 설정됩니다. 교차 사이트 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 기능을 사용하는 개발자 는 프로그래밍 방식으로 교차 출처 공유 요청 헤더를 설정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2596221fd857bbcaea04d0cd1a4ea6fd1d357430" translate="yes" xml:space="preserve">
          <source>This section lists major changes between this document and &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;,
   starting with those that are likely to result in implementation
   changes.  Servers will advertise support for all changes in this
   specification by returning the compliance class &quot;3&quot; in the DAV
   response header (see Sections &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; and &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt;).</source>
          <target state="translated">이 섹션에는 구현 변경을 초래할 수있는 변경 사항부터 시작 하여이 문서와 &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; 간의 주요 변경 사항이 나와 있습니다. 서버는 DAV 응답 헤더에 준수 클래스 &quot;3&quot;을 반환하여이 사양의 모든 변경 사항에 대한 지원을 알립니다 (섹션 &lt;a href=&quot;#section-10.1&quot;&gt;10.1&lt;/a&gt; 및 &lt;a href=&quot;#section-18.3&quot;&gt;18.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="fd619925c99ba3f120ebdc079103c35edf44f771" translate="yes" xml:space="preserve">
          <source>This section lists the HTTP response headers that servers send back for access control requests as defined by the Cross-Origin Resource Sharing specification. The previous section gives an overview of these in action.</source>
          <target state="translated">이 섹션에는 서버 간 자원 공유 사양에 정의 된대로 서버가 액세스 제어 요청을 위해 보내는 HTTP 응답 헤더가 나열되어 있습니다. 이전 섹션에서는 이러한 기능에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="256b3572a114f6830fdfb27c4527ad2a42aa41b3" translate="yes" xml:space="preserve">
          <source>This section provides a concise model for how locking behaves.  Later
   sections will provide more detail on some of the concepts and refer
   back to these model statements.  Normative statements related to LOCK
   and UNLOCK method handling can be found in the sections on those
   methods, whereas normative statements that cover any method are
   gathered here.

   1.  A lock either directly or indirectly locks a resource.

   2.  A resource becomes directly locked when a LOCK request to a URL
       of that resource creates a new lock.  The &quot;lock-root&quot; of the new
       lock is that URL.  If at the time of the request, the URL is not
       mapped to a resource, a new empty resource is created and
       directly locked.

   3.  An exclusive lock (&lt;a href=&quot;#section-6.2&quot;&gt;Section 6.2&lt;/a&gt;) conflicts with any other kind of
       lock on the same resource, whether either lock is direct or
       indirect.  A server MUST NOT create conflicting locks on a
       resource.

   4.  For a collection that is locked with a depth-infinity lock L, all
       member resources are indirectly locked.  Changes in membership of
       such a collection affect the set of indirectly locked resources:

       *  If a member resource is added to the collection, the new
          member resource MUST NOT already have a conflicting lock,
          because the new resource MUST become indirectly locked by L.

       *  If a member resource stops being a member of the collection,
          then the resource MUST no longer be indirectly locked by L.

   5.  Each lock is identified by a single globally unique lock token
       (&lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;).

   6.  An UNLOCK request deletes the lock with the specified lock token.
       After a lock is deleted, no resource is locked by that lock.

   7.  A lock token is &quot;submitted&quot; in a request when it appears in an
       &quot;If&quot; header (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;, &quot;Write Lock&quot;, discusses when token
       submission is required for write locks).

   8.  If a request causes the lock-root of any lock to become an
       unmapped URL, then the lock MUST also be deleted by that request.</source>
          <target state="translated">이 섹션에서는 잠금 작동 방식에 대한 간결한 모델을 제공합니다. 이후 섹션에서는 일부 개념에 대해 자세히 설명하고 이러한 모델 설명을 다시 참조합니다. LOCK 및 UNLOCK 메소드 처리와 관련된 규범 문은 해당 메소드의 섹션에서 찾을 수 있지만 모든 메소드를 다루는 규범 문은 여기에 수집됩니다. 1. 잠금은 리소스를 직접 또는 간접적으로 잠급니다. 2. 해당 리소스의 URL에 대한 잠금 요청이 새 잠금을 만들면 리소스가 직접 잠 깁니다. 새 잠금의 &quot;루트 루트&quot;는 해당 URL입니다. 요청시 URL이 자원에 맵핑되지 않으면 비어있는 새 자원이 작성되고 직접 잠 깁니다. 3. 독점 잠금 장치 ( &lt;a href=&quot;#section-6.2&quot;&gt;섹션 6.2&lt;/a&gt;) 잠금이 직접적이든 간접적이든 동일한 리소스에 대한 다른 종류의 잠금과 충돌합니다. 서버는 리소스에 대해 충돌하는 잠금을 생성해서는 안됩니다 (MUST NOT). 4. 깊이 무한대 잠금 L로 잠긴 컬렉션의 경우 모든 멤버 리소스가 간접적으로 잠 깁니다. 이러한 콜렉션의 멤버쉽 변경은 간접적으로 잠긴 자원 세트에 영향을줍니다. * 멤버 자원이 콜렉션에 추가되는 경우 새 자원이 L에 의해 간접적으로 잠금 상태가되어야하므로 새 멤버 자원은 충돌하는 잠금이 없어야합니다. * 멤버 자원이 콜렉션의 멤버 인 것을 중지하면 L로 자원을 더 이상 간접적으로 잠그지 않아야합니다. 5. 각 잠금은 단일 한 글로벌 고유 잠금 토큰 (&lt;a href=&quot;#section-6.5&quot;&gt;섹션 6.5&lt;/a&gt; ). 6. UNLOCK 요청은 지정된 잠금 토큰을 가진 잠금을 삭제합니다. 잠금이 삭제 된 후에는 해당 잠금에 의해 리소스가 잠기지 않습니다. 7. &quot;If&quot;헤더에 나타날 때 요청에 잠금 토큰이 &quot;제출&quot;됩니다 ( &lt;a href=&quot;#section-7&quot;&gt;섹션 7&lt;/a&gt; , &quot;쓰기 잠금&quot;, 쓰기 잠금에 토큰 제출이 필요한시기에 대해 설명). 8. 요청으로 인해 잠금의 잠금 루트가 매핑되지 않은 URL이되면 해당 요청에 의해 잠금도 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4b255e71c5acf2b758f6ac1313183b4a6e6c569" translate="yes" xml:space="preserve">
          <source>This section provides a description of a type of Web resource, the
   collection, and discusses its interactions with the HTTP URL
   namespace and with HTTP methods.  The purpose of a collection
   resource is to model collection-like objects (e.g., file system
   directories) within a server's namespace. 

   All DAV-compliant resources MUST support the HTTP URL namespace model
   specified herein.</source>
          <target state="translated">이 섹션에서는 웹 리소스 유형, 컬렉션에 대한 설명과 HTTP URL 네임 스페이스 및 HTTP 메서드와의 상호 작용에 대해 설명합니다. 콜렉션 자원의 목적은 서버의 네임 스페이스 내에서 콜렉션과 유사한 오브젝트 (예 : 파일 시스템 디렉토리)를 모델링하는 것입니다. 모든 DAV 호환 리소스는 여기에 지정된 HTTP URL 네임 스페이스 모델을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="41f24be581ad6f64eda1b3a4bd3c9c3eed891392" translate="yes" xml:space="preserve">
          <source>This section provides examples of some common security policy scenarios.</source>
          <target state="translated">이 섹션에서는 몇 가지 일반적인 보안 정책 시나리오의 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ffdc290f371b09817d92044b4802c7dcaa78a48b" translate="yes" xml:space="preserve">
          <source>This section summarizes major differences between versions HTTP/1.0
   and HTTP/1.1.</source>
          <target state="translated">이 섹션에서는 버전 HTTP / 1.0과 HTTP / 1.1의 주요 차이점을 요약합니다.</target>
        </trans-unit>
        <trans-unit id="ff966b2d60be3de0767cef83a4ad73d50f777ddf" translate="yes" xml:space="preserve">
          <source>This section, as with similar sections for other methods, provides
   some guidance on error codes and preconditions or postconditions
   (defined in &lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;) that might be particularly useful with
   PROPFIND.

   403 Forbidden - A server MAY reject PROPFIND requests on collections
   with depth header of &quot;Infinity&quot;, in which case it SHOULD use this
   error with the precondition code 'propfind-finite-depth' inside the
   error body.</source>
          <target state="translated">이 섹션은 다른 방법에 대한 유사한 섹션과 마찬가지로 PROPFIND에 특히 유용 할 수있는 오류 코드 및 사전 조건 또는 사후 조건 ( &lt;a href=&quot;#section-16&quot;&gt;섹션 16에&lt;/a&gt; 정의 됨)에 대한 지침을 제공 합니다. 403 금지-서버는 깊이 헤더가 &quot;Infinity&quot;인 컬렉션에 대한 PROPFIND 요청을 거부 할 수 있습니다.이 경우 오류 본문 내에서 사전 조건 코드 'propfind-finite-depth'와 함께이 오류를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee00e4e33c5031393996d9cbbb32237668a87ffc" translate="yes" xml:space="preserve">
          <source>This shows the server sending headers to tell the client to store a pair of cookies:</source>
          <target state="translated">This shows the server sending headers to tell the client to store a pair of cookies:</target>
        </trans-unit>
        <trans-unit id="639667e8ad5d2c48599430916aed509755cbbadd" translate="yes" xml:space="preserve">
          <source>This simple HTML file will be saved as a regular download rather than displayed in the browser. Most browsers will propose to save it under the &lt;code&gt;cool.html&lt;/code&gt; filename (by default).</source>
          <target state="translated">이 간단한 HTML 파일은 브라우저에 표시되지 않고 일반 다운로드로 저장됩니다. 대부분의 브라우저는 기본적으로 &lt;code&gt;cool.html&lt;/code&gt; 파일 이름으로 파일 을 저장하도록 제안합니다 .</target>
        </trans-unit>
        <trans-unit id="1c7309d7bb5ffc950761c7540724deee943ec907" translate="yes" xml:space="preserve">
          <source>This simple model held an innate limitation on performance: opening each TCP connection is a resource-consuming operation. Several messages must be exchanged between the client and the server. Network latency and bandwidth affect performance when a request needs sending. Modern Web pages require many requests (a dozen or more) to serve the amount of information needed, proving this earlier model inefficient.</source>
          <target state="translated">이 간단한 모델은 성능면에서 본질적인 한계를 가지고있었습니다. 각 TCP 연결을 여는 것은 리소스를 소비하는 작업입니다. 클라이언트와 서버간에 여러 메시지를 교환해야합니다. 네트워크 대기 시간 및 대역폭은 요청을 보내야 할 때 성능에 영향을줍니다. 최신 웹 페이지에는 필요한 양의 정보를 제공하기 위해 많은 요청 (12 개 이상)이 필요하므로이 초기 모델은 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="484f69d86199a4745f12e506b1b55024069115fc" translate="yes" xml:space="preserve">
          <source>This solution is more efficient, but slightly less flexible, as only one etag can be used in the condition. Rarely is such additional flexibility needed.</source>
          <target state="translated">이 솔루션은 하나의 etag 만 조건에서 사용될 수 있으므로보다 효율적이지만 약간 덜 유연합니다. 그러한 추가적인 유연성이 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01774d0c8108df34d3eb470ca203ddd51442235b" translate="yes" xml:space="preserve">
          <source>This specification adds the value &quot;edit&quot; to the Atom Registry of Link
   Relations (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC4287]&lt;/a&gt;).  The value of &quot;edit&quot;
   specifies that the value of the href attribute is the IRI of an
   editable Member Entry.  When appearing within an atom:entry, the href
   IRI can be used to retrieve, update, and delete the Resource
   represented by that Entry.  An atom:entry MUST NOT contain more than
   one &quot;edit&quot; link relation.</source>
          <target state="translated">이 사양은 &quot;edit&quot;값을 링크 관계의 Atom 레지스트리에 추가합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;[RFC4287]의 7.1 절&lt;/a&gt; 참조 ). &quot;edit&quot;값은 href 속성 값이 편집 가능한 멤버 항목의 IRI임을 지정합니다. atom : entry 내에 나타날 때 href IRI를 사용하여 해당 항목이 나타내는 자원을 검색, 업데이트 및 삭제할 수 있습니다. atom : entry는 하나 이상의 &quot;편집&quot;링크 관계를 포함해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="87fe0975464508a17f30a33c7f745b43a75fae60" translate="yes" xml:space="preserve">
          <source>This specification adds the value &quot;edit-media&quot; to the Atom Registry
   of Link Relations (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;Section&amp;nbsp;7.1 of [RFC4287]&lt;/a&gt;).  When appearing
   within an atom:entry, the value of the href attribute is an IRI that
   can be used to modify a Media Resource associated with that Entry.

   An atom:entry element MAY contain zero or more &quot;edit-media&quot; link
   relations.  An atom:entry MUST NOT contain more than one atom:link
   element with a &quot;rel&quot; attribute value of &quot;edit-media&quot; that has the
   same &quot;type&quot; and &quot;hreflang&quot; attribute values.  All &quot;edit-media&quot; link
   relations in the same Entry reference the same Resource.  If a client
   encounters multiple &quot;edit-media&quot; link relations in an Entry then it
   SHOULD choose a link based on the client preferences for &quot;type&quot; and
   &quot;hreflang&quot;.  If a client encounters multiple &quot;edit-media&quot; link
   relations in an Entry and has no preference based on the &quot;type&quot; and
   &quot;hreflang&quot; attributes then the client SHOULD pick the first &quot;edit-
   media&quot; link relation in document order.</source>
          <target state="translated">이 사양은 &quot;edit-media&quot;값을 링크 관계의 Atom 레지스트리에 추가합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-7.1&quot;&gt;[RFC4287] 섹션 7.1&lt;/a&gt; 참조 )). atom : entry 내에 나타날 때 href 속성의 값은 해당 항목과 연관된 매체 자원을 수정하는 데 사용할 수있는 IRI입니다. atom : entry 요소는 0 개 이상의 &quot;미디어 편집&quot;링크 관계를 포함 할 수 있습니다. atom : entry는 &quot;rel&quot;속성 값이 &quot;edit-media&quot;인 &quot;type&quot;및 &quot;hreflang&quot;속성 값이 같은 atom : link 요소를 두 개 이상 포함해서는 안됩니다. 동일한 항목의 모든 &quot;편집 매체&quot;링크 관계는 동일한 자원을 참조합니다. 클라이언트가 엔트리에서 여러 개의 &quot;미디어 편집&quot;링크 관계를 발견하면 &quot;type&quot;및 &quot;hreflang&quot;에 대한 클라이언트 기본 설정을 기반으로 링크를 선택해야합니다. 클라이언트가 여러 &quot;편집 미디어&quot;를 발견 한 경우항목의 링크 관계와 &quot;type&quot;및 &quot;hreflang&quot;속성을 기반으로하는 기본 설정이없는 경우 클라이언트는 문서 순서에서 첫 번째 &quot;미디어 편집&quot;링크 관계를 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2a53f987b042cdfef40437d4b21f1000736b54d" translate="yes" xml:space="preserve">
          <source>This specification defines a new &quot;type&quot; parameter for use with the
   &quot;application/atom+xml&quot; media type.  The &quot;type&quot; parameter has a value
   of &quot;entry&quot; or &quot;feed&quot;.

   Neither the parameter name nor its value are case sensitive. 

   The value &quot;entry&quot; indicates that the media type identifies an Atom
   Entry Document.  The root element of the document MUST be atom:entry.

   The value &quot;feed&quot; indicates that the media type identifies an Atom
   Feed Document.  The root element of the document MUST be atom:feed.

   If not specified, the type is assumed to be unspecified, requiring
   Atom processors to examine the root element to determine the type of
   Atom document.</source>
          <target state="translated">이 사양은 &quot;application / atom + xml&quot;미디어 유형과 함께 사용할 새로운 &quot;type&quot;매개 변수를 정의합니다. &quot;type&quot;매개 변수의 값은 &quot;entry&quot;또는 &quot;feed&quot;입니다. 매개 변수 이름과 값은 대소 문자를 구분하지 않습니다. &quot;entry&quot;값은 매체 유형이 원자 항목 문서를 식별 함을 나타냅니다. 문서의 루트 요소는 atom : entry 여야합니다. &quot;feed&quot;값은 미디어 유형이 Atom Feed Document를 식별 함을 나타냅니다. 문서의 루트 요소는 atom : feed 여야합니다. 지정되지 않은 경우 유형이 지정되지 않은 것으로 간주되므로 Atom 프로세서는 Atom 문서의 유형을 판별하기 위해 루트 요소를 검사해야합니다.</target>
        </trans-unit>
        <trans-unit id="978449461dd375d2f22dc902ad77e42eee391e36" translate="yes" xml:space="preserve">
          <source>This specification defines an Atom Format Structured Extension, as
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC4287]&lt;/a&gt;, for publishing control within the
   &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot; namespace.</source>
          <target state="translated">이 사양은 &quot; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; &quot;네임 스페이스 내에서 제어를 공개하기 위해 &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;[RFC4287]의 섹션 6에&lt;/a&gt; 정의 된 Atom 형식 구조 확장을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="91a1e7bdc7ea038fc4979f4ad8ada34b2e46af01" translate="yes" xml:space="preserve">
          <source>This specification defines the HTTP status codes

   o  207 Multi-Status (&lt;a href=&quot;#section-11.1&quot;&gt;Section 11.1&lt;/a&gt;)

   o  422 Unprocessable Entity (&lt;a href=&quot;#section-11.2&quot;&gt;Section 11.2&lt;/a&gt;),

   o  423 Locked (&lt;a href=&quot;#section-11.3&quot;&gt;Section 11.3&lt;/a&gt;),

   o  424 Failed Dependency (&lt;a href=&quot;#section-11.4&quot;&gt;Section 11.4&lt;/a&gt;) and

   o  507 Insufficient Storage (&lt;a href=&quot;#section-11.5&quot;&gt;Section 11.5&lt;/a&gt;),

   to be updated in the registry at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt;&amp;gt;.

   Note: the HTTP status code 102 (Processing) has been removed in this
   specification; its IANA registration should continue to reference &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;2518&lt;/a&gt;.</source>
          <target state="translated">이 사양은 HTTP 상태 코드를 정의합니다 .o 207 다중 상태 ( &lt;a href=&quot;#section-11.1&quot;&gt;섹션 11.1&lt;/a&gt; ) o 422 처리 할 수없는 엔티티 ( &lt;a href=&quot;#section-11.2&quot;&gt;섹션 11.2&lt;/a&gt; ), o 423 잠금 ( &lt;a href=&quot;#section-11.3&quot;&gt;섹션 11.3&lt;/a&gt; ), o 424 실패 종속성 ( &lt;a href=&quot;#section-11.4&quot;&gt;섹션 11.4&lt;/a&gt; ) 및 o 507 스토리지 부족 ( &lt;a href=&quot;#section-11.5&quot;&gt;섹션 11.5&lt;/a&gt; ) &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-status-codes&quot;&gt;http://www.iana.org/assignments/http-status-codes&lt;/a&gt; &amp;gt; 의 레지스트리에서 업데이트됩니다 . 참고 :이 사양에서는 HTTP 상태 코드 102 (처리 중)가 제거되었습니다. IANA 등록은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;2518을&lt;/a&gt; 계속 참조해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7e1fe7c5f8c6eb66628d934996aa12f9c804ee43" translate="yes" xml:space="preserve">
          <source>This specification defines two URI schemes:

   1.  the &quot;opaquelocktoken&quot; scheme defined in &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt;, and

   2.  the &quot;DAV&quot; URI scheme, which historically was used in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] to
       disambiguate WebDAV property and XML element names and which
       continues to be used for that purpose in this specification and
       others extending WebDAV.  Creation of identifiers in the &quot;DAV:&quot;
       namespace is controlled by the IETF.

   Note that defining new URI schemes for XML namespaces is now
   discouraged.  &quot;DAV:&quot; was defined before standard best practices
   emerged.</source>
          <target state="translated">이 규격은 두 가지 URI 체계를 정의한다 : 1. &lt;a href=&quot;#appendix-C&quot;&gt;부록 C에&lt;/a&gt; 정의 된 &quot;opaquelocktoken&quot;체계 , 2. 역사적으로 WebDAV 속성과 XML 요소 이름을 명확하게하기 위해 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; ] 에서 사용 된 &quot;DAV&quot;URI 체계 이 사양 및 WebDAV를 확장하는 기타 목적에서 사용됩니다. &quot;DAV :&quot;네임 스페이스에서 식별자 생성은 IETF에 의해 제어됩니다. XML 네임 스페이스에 대한 새 URI 체계를 정의하는 것은 권장되지 않습니다. &quot;DAV :&quot;는 표준 모범 사례가 나타나기 전에 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="21623dc11b6c2f043255281513da10df5c7cbec3" translate="yes" xml:space="preserve">
          <source>This specification defines two forms of metadata that are commonly
   used to observe resource state and test for preconditions:
   modification dates (&lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt;) and opaque entity tags
   (&lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt;).  Additional metadata that reflects resource state has
   been defined by various extensions of HTTP, such as Web Distributed
   Authoring and Versioning (WebDAV, [&lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC4918&lt;/a&gt;]), that are beyond the
   scope of this specification.  A resource metadata value is referred
   to as a &quot;validator&quot; when it is used within a precondition.</source>
          <target state="translated">이 사양은 자원 상태를 관찰하고 전제 조건을 테스트하는 데 일반적으로 사용되는 두 가지 형식의 메타 데이터 인 수정 날짜 ( &lt;a href=&quot;#section-2.2&quot;&gt;섹션 2.2&lt;/a&gt; )와 불투명 엔티티 태그 ( &lt;a href=&quot;#section-2.3&quot;&gt;섹션 2.3&lt;/a&gt; )를 정의합니다. 리소스 상태를 반영하는 추가 메타 데이터 는이 사양의 범위를 벗어난 WebDAV, [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC4918&lt;/a&gt; ] 와 같은 HTTP의 다양한 확장에 의해 정의되었습니다 . 리소스 메타 데이터 값은 사전 조건 내에서 사용될 때 &quot;유효성 검사기&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="187fe63d0c83c4fa38b37175ce98332747f01af0" translate="yes" xml:space="preserve">
          <source>This specification defines two kinds of documents -- Category
   Documents and Service Documents.

   A Category Document (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;) contains lists of categories
   specified using the &quot;atom:category&quot; element from the Atom Syndication
   Format (see &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-4.2.2&quot;&gt;Section&amp;nbsp;4.2.2 of [RFC4287]&lt;/a&gt;).

   A Service Document (&lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;) groups available Collections into
   Workspaces.

   The namespace name [&lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml-names&lt;/a&gt;] for either kind of document is:

       &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;

   Atom Publishing Protocol XML Documents MUST be &quot;namespace-well-
   formed&quot; as specified in Section 7 of [&lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml-names&lt;/a&gt;].

   This specification uses the prefix &quot;app:&quot; for the namespace name.
   The prefix &quot;atom:&quot; is used for &quot;&lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt;&quot;, the
   namespace name of the Atom Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].  These
   namespace prefixes are not semantically significant.

   This specification does not define any DTDs for Atom Protocol
   formats, and hence does not require them to be &quot;valid&quot; in the sense
   used by [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].</source>
          <target state="translated">이 사양은 범주 문서와 서비스 문서의 두 종류의 문서를 정의합니다. 카테고리 문서 ( &lt;a href=&quot;#section-7&quot;&gt;섹션 7&lt;/a&gt; )에는 Atom Syndication Format의 &quot;atom : category&quot;요소를 사용하여 지정된 카테고리 목록이 포함되어 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-4.2.2&quot;&gt;[RFC4287]의 섹션 4.2.2&lt;/a&gt; 참조 ). 서비스 문서 ( &lt;a href=&quot;#section-8&quot;&gt;섹션 8&lt;/a&gt; )는 사용 가능한 콜렉션을 작업 공간으로 그룹화합니다. 네임 스페이스의 이름은 [ &lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-XML-이름은&lt;/a&gt; 문서의 두 종류이기] : &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt; 아톰 출판 프로토콜 XML 문서가 있어야한다 &quot;네임 스페이스-잘 형성&quot;의 7 절에 규정 된 [ &lt;a href=&quot;#ref-REC-xml-names&quot;&gt;REC-xml- 이름&lt;/a&gt;]. 이 사양에서는 네임 스페이스 이름으로 접두사 &quot;app :&quot;를 사용합니다. 접두사 &quot;atom :&quot;은 &quot; &lt;a href=&quot;http://www.w3.org/2005/Atom&quot;&gt;http://www.w3.org/2005/Atom&lt;/a&gt; &quot;에 사용 되며 Atom 신디케이션 형식 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ] 의 네임 스페이스 이름입니다 . 이러한 네임 스페이스 접두사는 의미 상 중요하지 않습니다. 이 사양에서는 Atom 프로토콜 형식에 대한 DTD를 정의하지 않으므로 [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ]에서 사용하는 의미에서 &quot;유효한&quot;형식 일 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="6f49469a7f998d6aa7fb1c171080afd01320be81" translate="yes" xml:space="preserve">
          <source>This specification does not define the behavior of the PUT method for
   existing collections.  A PUT request to an existing collection MAY be
   treated as an error (405 Method Not Allowed).

   The MKCOL method is defined to create collections.</source>
          <target state="translated">이 사양에서는 기존 컬렉션에 대한 PUT 메서드의 동작을 정의하지 않습니다. 기존 컬렉션에 대한 PUT 요청은 오류로 처리 될 수 있습니다 (405 Method Not Allowed). MKCOL 메소드는 콜렉션을 작성하도록 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d7d3f4f1fc7a5db64d2f982f26f4448b11b753a7" translate="yes" xml:space="preserve">
          <source>This specification encourages the use of &quot;A Universally Unique
   Identifier (UUID) URN Namespace&quot; ([&lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC4122&lt;/a&gt;]) for lock tokens
   (&lt;a href=&quot;#section-6.5&quot;&gt;Section 6.5&lt;/a&gt;), in order to guarantee their uniqueness across space
   and time.  Version 1 UUIDs (defined in &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;) MAY contain a
   &quot;node&quot; field that &quot;consists of an IEEE 802 MAC address, usually the
   host address.  For systems with multiple IEEE addresses, any
   available one can be used&quot;.  Since a WebDAV server will issue many
   locks over its lifetime, the implication is that it may also be
   publicly exposing its IEEE 802 address.

   There are several risks associated with exposure of IEEE 802
   addresses.  Using the IEEE 802 address:

   o  It is possible to track the movement of hardware from subnet to
      subnet.

   o  It may be possible to identify the manufacturer of the hardware
      running a WebDAV server.

   o  It may be possible to determine the number of each type of
      computer running WebDAV.

   This risk only applies to host-address-based UUID versions.  &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;4 of [RFC4122]&lt;/a&gt; describes several other mechanisms for generating
   UUIDs that do not involve the host address and therefore do not
   suffer from this risk.</source>
          <target state="translated">이 사양에서는 공간과 시간에 걸쳐 고유성을 보장하기 위해 잠금 토큰 ( &lt;a href=&quot;#section-6.5&quot;&gt;6.5 절&lt;/a&gt; )에 &quot;UUID (Universally Unique Identifier) ​​URN 네임 스페이스&quot;([ &lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC4122&lt;/a&gt; ])를 사용하도록 권장합니다 . 버전 1 UUID ( &lt;a href=&quot;#section-4&quot;&gt;섹션 4에&lt;/a&gt; 정의 됨)) &quot;노드&quot;필드를 포함 할 수 있습니다. &quot;일반적으로 호스트 주소 인 IEEE 802 MAC 주소로 구성됩니다. IEEE 주소가 여러 개인 시스템의 경우 사용 가능한 주소를 사용할 수 있습니다&quot;. WebDAV 서버는 수명 기간 동안 많은 잠금을 발행하므로 IEEE 802 주소를 공개적으로 노출 할 수도 있습니다. IEEE 802 주소 노출과 관련된 몇 가지 위험이 있습니다. IEEE 802 주소 사용 : o 서브넷에서 서브넷으로의 하드웨어 이동을 추적 할 수 있습니다. o WebDAV 서버를 실행하는 하드웨어 제조업체를 식별 할 수 있습니다. o WebDAV를 실행하는 각 컴퓨터 유형의 수를 결정할 수 있습니다. 이 위험은 호스트 주소 기반 UUID 버전에만 적용됩니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;[RFC4122]의 &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4122#section-4&quot;&gt;섹션 &lt;/a&gt;4호스트 주소를 포함하지 않으므로 UUID를 생성하기위한 몇 가지 다른 메커니즘을 설명하므로 이러한 위험이 없습니다.</target>
        </trans-unit>
        <trans-unit id="37eee64d4bf2bb8f0591eb5fc58512e72f0c0858" translate="yes" xml:space="preserve">
          <source>This specification has been carefully audited to correct and
   disambiguate key word usage; &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; had many problems in respect to
   the conventions laid out in &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [&lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt;].

   Clarified which error code should be used for inbound server failures
   (e.g. DNS failures). (&lt;a href=&quot;#section-10.5.5&quot;&gt;Section 10.5.5&lt;/a&gt;). 

   CREATE had a race that required an Etag be sent when a resource is
   first created. (&lt;a href=&quot;#section-10.2.2&quot;&gt;Section 10.2.2&lt;/a&gt;).

   Content-Base was deleted from the specification: it was not
   implemented widely, and there is no simple, safe way to introduce it
   without a robust extension mechanism. In addition, it is used in a
   similar, but not identical fashion in MHTML [&lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt;].

   Transfer-coding and message lengths all interact in ways that
   required fixing exactly when chunked encoding is used (to allow for
   transfer encoding that may not be self delimiting); it was important
   to straighten out exactly how message lengths are computed. (Sections
   3.6, 4.4, 7.2.2, 13.5.2, 14.13, 14.16)

   A content-coding of &quot;identity&quot; was introduced, to solve problems
   discovered in caching. (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;)

   Quality Values of zero should indicate that &quot;I don't want something&quot;
   to allow clients to refuse a representation. (&lt;a href=&quot;#section-3.9&quot;&gt;Section 3.9&lt;/a&gt;)

   The use and interpretation of HTTP version numbers has been clarified
   by &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;. Require proxies to upgrade requests to highest protocol
   version they support to deal with problems discovered in HTTP/1.0
   implementations (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;)

   Charset wildcarding is introduced to avoid explosion of character set
   names in accept headers. (&lt;a href=&quot;#section-14.2&quot;&gt;Section 14.2&lt;/a&gt;)

   A case was missed in the Cache-Control model of HTTP/1.1; s-maxage
   was introduced to add this missing case. (Sections &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt;, &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt;, &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt;,
   14.9.3)

   The Cache-Control: max-age directive was not properly defined for
   responses. (&lt;a href=&quot;#section-14.9.3&quot;&gt;Section 14.9.3&lt;/a&gt;)

   There are situations where a server (especially a proxy) does not
   know the full length of a response but is capable of serving a
   byterange request. We therefore need a mechanism to allow byteranges
   with a content-range not indicating the full length of the message.
   (&lt;a href=&quot;#section-14.16&quot;&gt;Section 14.16&lt;/a&gt;)

   Range request responses would become very verbose if all meta-data
   were always returned; by allowing the server to only send needed
   headers in a 206 response, this problem can be avoided. (&lt;a href=&quot;#section-10.2.7&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt;, 13.5.3, and 14.27) 

   Fix problem with unsatisfiable range requests; there are two cases:
   syntactic problems, and range doesn't exist in the document. The 416
   status code was needed to resolve this ambiguity needed to indicate
   an error for a byte range request that falls outside of the actual
   contents of a document. (&lt;a href=&quot;#section-10.4.17&quot;&gt;Section 10.4.17&lt;/a&gt;, 14.16)

   Rewrite of message transmission requirements to make it much harder
   for implementors to get it wrong, as the consequences of errors here
   can have significant impact on the Internet, and to deal with the
   following problems:

      1. Changing &quot;HTTP/1.1 or later&quot; to &quot;HTTP/1.1&quot;, in contexts where
         this was incorrectly placing a requirement on the behavior of
         an implementation of a future version of HTTP/1.x

      2. Made it clear that user-agents should retry requests, not
         &quot;clients&quot; in general.

      3. Converted requirements for clients to ignore unexpected 100
         (Continue) responses, and for proxies to forward 100 responses,
         into a general requirement for 1xx responses.

      4. Modified some TCP-specific language, to make it clearer that
         non-TCP transports are possible for HTTP.

      5. Require that the origin server MUST NOT wait for the request
         body before it sends a required 100 (Continue) response.

      6. Allow, rather than require, a server to omit 100 (Continue) if
         it has already seen some of the request body.

      7. Allow servers to defend against denial-of-service attacks and
         broken clients.

   This change adds the Expect header and 417 status code. The message
   transmission requirements fixes are in sections &lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt;, &lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt;,
   8.1.2.2, 13.11, and 14.20.

   Proxies should be able to add Content-Length when appropriate.
   (&lt;a href=&quot;#section-13.5.2&quot;&gt;Section 13.5.2&lt;/a&gt;)

   Clean up confusion between 403 and 404 responses. (&lt;a href=&quot;#section-10.4.4&quot;&gt;Section 10.4.4&lt;/a&gt;,
   10.4.5, and 10.4.11)

   Warnings could be cached incorrectly, or not updated appropriately.
   (&lt;a href=&quot;#section-13.1.2&quot;&gt;Section 13.1.2&lt;/a&gt;, 13.2.4, 13.5.2, 13.5.3, 14.9.3, and 14.46) Warning
   also needed to be a general header, as PUT or other methods may have
   need for it in requests. 

   Transfer-coding had significant problems, particularly with
   interactions with chunked encoding. The solution is that transfer-
   codings become as full fledged as content-codings. This involves
   adding an IANA registry for transfer-codings (separate from content
   codings), a new header field (TE) and enabling trailer headers in the
   future. Transfer encoding is a major performance benefit, so it was
   worth fixing [&lt;a href=&quot;#ref-39&quot;&gt;39&lt;/a&gt;]. TE also solves another, obscure, downward
   interoperability problem that could have occurred due to interactions
   between authentication trailers, chunked encoding and HTTP/1.0
   clients.(&lt;a href=&quot;#section-3.6&quot;&gt;Section 3.6&lt;/a&gt;, 3.6.1, and 14.39)

   The PATCH, LINK, UNLINK methods were defined but not commonly
   implemented in previous versions of this specification. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;
   [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;].

   The Alternates, Content-Version, Derived-From, Link, URI, Public and
   Content-Base header fields were defined in previous versions of this
   specification, but not commonly implemented. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;].</source>
          <target state="translated">이 사양은 키워드 사용을 수정하고 명확하게하기 위해 신중하게 감사되었습니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; 은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; [ &lt;a href=&quot;#ref-34&quot;&gt;34&lt;/a&gt; ] 에 제시된 규칙과 관련하여 많은 문제가있었습니다 . 인바운드 서버 오류 (예 : DNS 오류)에 사용해야하는 오류 코드가 명확 해졌습니다. ( &lt;a href=&quot;#section-10.5.5&quot;&gt;10.5.5 항&lt;/a&gt; ). CREATE에는 리소스를 처음 만들 때 Etag를 보내야하는 경쟁이있었습니다. ( &lt;a href=&quot;#section-10.2.2&quot;&gt;10.2.2 항&lt;/a&gt; ). Content-Base가 사양에서 삭제되었습니다. 광범위하게 구현되지 않았으며 강력한 확장 메커니즘없이 간단하고 안전하게 도입 할 수있는 방법이 없습니다. 또한 MHTML에서 유사하지만 동일하지 않은 방식으로 사용됩니다. [ &lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt;]. 전송 코딩 및 메시지 길이는 모두 청크 분할 인코딩을 사용할 때 (자체 구분이 아닌 전송 인코딩을 허용하기 위해) 정확하게 수정해야하는 방식으로 상호 작용합니다. 메시지 길이 계산 방법을 정확하게 정리하는 것이 중요했습니다. (섹션 3.6, 4.4, 7.2.2, 13.5.2, 14.13, 14.16) 캐싱에서 발견 된 문제를 해결하기 위해 &quot;identity&quot;의 컨텐츠 코딩이 도입되었습니다. ( &lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt; ) 품질 값이 0 인 경우 고객이 표현을 거부 할 수 있도록 &quot;나는 원하지 않습니다&quot;가 표시되어야합니다. ( &lt;a href=&quot;#section-3.9&quot;&gt;3.9 절&lt;/a&gt; ) &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145에&lt;/a&gt; 의해 HTTP 버전 번호의 사용 및 해석이 명확 해졌습니다.. 프록시가 HTTP / 1.0 구현에서 발견 된 문제점을 처리하기 위해 지원하는 최고 프로토콜 버전으로 요청을 업그레이드해야합니다 ( &lt;a href=&quot;#section-3.1&quot;&gt;3.1 절&lt;/a&gt; ). ( &lt;a href=&quot;#section-14.2&quot;&gt;14.2 절&lt;/a&gt; ) HTTP / 1.1의 캐시 제어 모델에서 사례가 누락되었습니다. 이 누락 사례를 추가하기 위해 s-maxage가 도입되었습니다. (섹션 &lt;a href=&quot;#section-13.4&quot;&gt;13.4&lt;/a&gt; , &lt;a href=&quot;#section-14.8&quot;&gt;14.8&lt;/a&gt; , &lt;a href=&quot;#section-14.9&quot;&gt;14.9&lt;/a&gt; , 14.9.3) Cache-Control : max-age 지시문이 응답에 대해 올바르게 정의되지 않았습니다. ( &lt;a href=&quot;#section-14.9.3&quot;&gt;14.9.3 항&lt;/a&gt;) 서버 (특히 프록시)가 응답의 전체 길이를 모르지만 바이트 범위 요청을 처리 할 수있는 상황이 있습니다. 따라서 메시지의 전체 길이를 나타내지 않는 내용 범위의 바이트 범위를 허용하는 메커니즘이 필요합니다. ( &lt;a href=&quot;#section-14.16&quot;&gt;14.14 절&lt;/a&gt; ) 모든 메타 데이터가 항상 반환되면 범위 요청 응답은 매우 장황해진다. 서버가 206 응답으로 필요한 헤더 만 보내도록 허용함으로써이 문제를 피할 수 있습니다. ( &lt;a href=&quot;#section-10.2.7&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-10.2.7&quot;&gt;10.2.7&lt;/a&gt;, 13.5.3 및 14.27) 만족할 수없는 범위 요청 문제를 해결합니다. 구문상의 문제와 문서에 범위가 존재하지 않는 두 가지 경우가 있습니다. 416 상태 코드는 문서의 실제 내용을 벗어나는 바이트 범위 요청에 대한 오류를 나타내는 데 필요한이 모호성을 해결하는 데 필요했습니다. ( &lt;a href=&quot;#section-10.4.17&quot;&gt;섹션 10.4.17&lt;/a&gt;, 14.16) 오류로 인한 결과가 인터넷에 중대한 영향을 미치고 다음과 같은 문제를 처리 할 수 ​​있기 때문에 구현자가 실수를 저지르기가 더 어려워 지도록 메시지 전송 요구 사항을 다시 작성하십시오. 1. &quot;HTTP / 1.1 또는 나중에 HTTP / 1.x 2의 구현 동작에 대한 요구 사항을 잘못 요구하는 상황에서 나중에 &quot;HTTP / 1.1&quot;으로 변경하십시오. 사용자 에이전트가 &quot;클라이언트가 아닌 요청을 다시 시도해야 함을 분명히했습니다.&quot; &quot;일반적으로 3. 클라이언트가 예기치 않은 100 (계속) 응답을 무시하고 프록시가 100 응답을 전달하도록 요구 사항을 1xx 응답의 일반 요구 사항으로 변환했습니다. 4. 일부 TCP 관련 언어를 수정했습니다.비 TCP 전송이 HTTP에 가능하다는 것을보다 명확하게하기 위해. 5. 오리진 서버가 요구 된 100 (계속) 응답을 보내기 전에 요청 본문을 기다리지 않아야합니다. 6. 서버가 요청 본문 중 일부를 이미 본 경우 서버가 필요하지 않고 100 (계속)을 생략하도록 허용하십시오. 7. 서버가 서비스 거부 공격 및 손상된 클라이언트에 대해 방어 할 수 있도록합니다. 이 변경으로 Expect 헤더와 417 상태 코드가 추가됩니다. 메시지 전송 요구 사항 수정 사항은 섹션에 있습니다.요청 본문 중 일부를 이미 본 경우 100 (계속)을 생략하는 서버 7. 서버가 서비스 거부 공격 및 손상된 클라이언트에 대해 방어 할 수 있도록합니다. 이 변경으로 Expect 헤더와 417 상태 코드가 추가됩니다. 메시지 전송 요구 사항 수정 사항은 섹션에 있습니다.요청 본문 중 일부를 이미 본 경우 100 (계속)을 생략하는 서버 7. 서버가 서비스 거부 공격 및 손상된 클라이언트에 대해 방어 할 수 있도록합니다. 이 변경으로 Expect 헤더와 417 상태 코드가 추가됩니다. 메시지 전송 요구 사항 수정 사항은 섹션에 있습니다.&lt;a href=&quot;#section-8.2&quot;&gt;8.2&lt;/a&gt; , &lt;a href=&quot;#section-10.4.18&quot;&gt;10.4.18&lt;/a&gt; , 8.1.2.2, 13.11 및 14.20. 프록시는 적절한 경우 Content-Length를 추가 할 수 있어야합니다. ( &lt;a href=&quot;#section-13.5.2&quot;&gt;13.5.2 절&lt;/a&gt; ) 403과 404 응답 사이의 혼란을 정리하십시오. ( &lt;a href=&quot;#section-10.4.4&quot;&gt;10.4.4&lt;/a&gt; , 10.4.5 및 10.4.11 섹션 ) 경고가 잘못 캐시되거나 적절하게 업데이트되지 않을 수 있습니다. ( &lt;a href=&quot;#section-13.1.2&quot;&gt;13.1.2 항&lt;/a&gt;, 13.2.4, 13.5.2, 13.5.3, 14.9.3 및 14.46) 경고는 PUT 또는 기타 방법이 요청에 필요할 수 있으므로 일반 헤더 여야합니다. 전송 코딩은 특히 청크 인코딩과의 상호 작용에 중대한 문제가있었습니다. 해결책은 전송 코딩이 콘텐츠 코딩만큼 본격화되는 것입니다. 전송 코딩 (컨텐츠 코딩과는 별도)을위한 IANA 레지스트리 추가, 새로운 헤더 필드 (TE) 및 향후 트레일러 헤더 활성화가 포함됩니다. 전송 인코딩은 성능상의 주요 이점이므로 수정할 가치가 있습니다 [ &lt;a href=&quot;#ref-39&quot;&gt;39&lt;/a&gt; ]. TE는 또한 인증 트레일러, 청크 인코딩 및 HTTP / 1.0 클라이언트 간의 상호 작용으로 인해 발생할 수있는 모호하지 않은 하향 상호 운용성 문제를 해결합니다 ( &lt;a href=&quot;#section-3.6&quot;&gt;3.6 절)&lt;/a&gt; ., 3.6.1 및 14.39) PATCH, LINK, UNLINK 방법이 정의되었지만이 사양의 이전 버전에서는 일반적으로 구현되지 않았습니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]를 참조하십시오 . Alternates, Content-Version, Derived-From, Link, URI, Public 및 Content-Base 헤더 필드는이 사양의 이전 버전에서 정의되었지만 일반적으로 구현되지 않았습니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c3aed10c6ed1ff4c98e713111fede52cc2146bd" translate="yes" xml:space="preserve">
          <source>This specification makes heavy use of the augmented BNF and generic
   constructs defined by David H. Crocker for &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]. Similarly, it
   reuses many of the definitions provided by Nathaniel Borenstein and
   Ned Freed for MIME [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]. We hope that their inclusion in this
   specification will help reduce past confusion over the relationship
   between HTTP and Internet mail message formats.

   The HTTP protocol has evolved considerably over the years. It has
   benefited from a large and active developer community--the many
   people who have participated on the www-talk mailing list--and it is
   that community which has been most responsible for the success of
   HTTP and of the World-Wide Web in general. Marc Andreessen, Robert
   Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois
   Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob
   McCool, Lou Montulli, Dave Raggett, Tony Sanders, and Marc
   VanHeyningen deserve special recognition for their efforts in
   defining early aspects of the protocol.

   This document has benefited greatly from the comments of all those
   participating in the HTTP-WG. In addition to those already mentioned,
   the following individuals have contributed to this specification: 

       Gary Adams                  Ross Patterson
       Harald Tveit Alvestrand     Albert Lunde
       Keith Ball                  John C. Mallery
       Brian Behlendorf            Jean-Philippe Martin-Flatin
       Paul Burchard               Mitra
       Maurizio Codogno            David Morris
       Mike Cowlishaw              Gavin Nicol
       Roman Czyborra              Bill Perry
       Michael A. Dolan            Jeffrey Perry
       David J. Fiander            Scott Powers
       Alan Freier                 Owen Rees
       Marc Hedlund                Luigi Rizzo
       Greg Herlihy                David Robinson
       Koen Holtman                Marc Salomon
       Alex Hopmann                Rich Salz
       Bob Jernigan                Allan M. Schiffman
       Shel Kaphan                 Jim Seidman
       Rohit Khare                 Chuck Shotton
       John Klensin                Eric W. Sink
       Martijn Koster              Simon E. Spero
       Alexei Kosut                Richard N. Taylor
       David M. Kristol            Robert S. Thau
       Daniel LaLiberte            Bill (BearHeart) Weinman
       Ben Laurie                  Francois Yergeau
       Paul J. Leach               Mary Ellen Zurko
       Daniel DuBois               Josh Cohen


   Much of the content and presentation of the caching design is due to
   suggestions and comments from individuals including: Shel Kaphan,
   Paul Leach, Koen Holtman, David Morris, and Larry Masinter.

   Most of the specification of ranges is based on work originally done
   by Ari Luotonen and John Franks, with additional input from Steve
   Zilles.

   Thanks to the &quot;cave men&quot; of Palo Alto. You know who you are.

   Jim Gettys (the current editor of this document) wishes particularly
   to thank Roy Fielding, the previous editor of this document, along
   with John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen
   Holtman, John Franks, Josh Cohen, Alex Hopmann, Scott Lawrence, and
   Larry Masinter for their help. And thanks go particularly to Jeff
   Mogul and Scott Lawrence for performing the &quot;MUST/MAY/SHOULD&quot; audit. 

   The Apache Group, Anselm Baird-Smith, author of Jigsaw, and Henrik
   Frystyk implemented &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; early, and we wish to thank them for the
   discovery of many of the problems that this document attempts to
   rectify.</source>
          <target state="translated">이 사양은 &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ] 에 David H. Crocker에 의해 정의 된 증강 BNF 및 일반 구성을 많이 사용합니다 . 마찬가지로, Nathaniel Borenstein과 Ned Freed가 제공 한 많은 정의를 MIME에 재사용합니다. [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]. 이 사양에 포함 시키면 HTTP와 인터넷 메일 메시지 형식 간의 관계에 대한 과거의 혼란을 줄일 수 있기를 바랍니다. HTTP 프로토콜은 수년에 걸쳐 상당히 발전했습니다. 이 사이트는 www-talk 메일 링리스트에 참여한 많은 사람들이 참여하는 대규모의 활발한 개발자 커뮤니티의 혜택을 받았으며 HTTP 및 World-Wide Web의 성공에 가장 큰 책임을지는 커뮤니티입니다. 일반. Marc Andreessen, Robert Cailliau, Daniel W. Connolly, Bob Denny, John Franks, Jean-Francois Groff, Phillip M. Hallam-Baker, Hakon W. Lie, Ari Luotonen, Rob McCool, Lou Montulli, Dave Raggett, Tony Sanders 및 Marc VanHeyningen은 프로토콜의 초기 측면을 정의하려는 노력에 대해 특별한 인정을받을 자격이 있습니다.이 문서는 HTTP-WG에 참여하는 모든 사람들의 의견에서 큰 도움이되었습니다. 이미 언급 한 것 외에도 다음과 같은 개인이이 사양에 기여했습니다. Gary Adams Ross Patterson Harald Tveit Alvestrand Albert Lunde Keith Ball John C. Mallery Brian Behlendorf Jean-Plipin Martin-Flatin Paul Burchard Mitra Maurizio Codogno David Morris Mike Cowlishaw Gavin Nicol Roman Czyborra 빌 페리 Michael A. Dolan Jeffrey Perry David J.Fiander Scott Powers Alan Freier Owen Rees Marc Hedlund Luigi Rizzo Greg Herlihy David Robinson Koen Holtman Marc Salomon Alex Hopmann Rich Salz Bob Jernigan Allan M. Schiffman Shel Kaphan Jim Seidman Rohit Khare Chuck Shotton John Klensin Eric W. Sink Martijn Koster Simon E. Spero Alexei Kosut Richard N. Taylor David M. Kristol Robert S. Thau Daniel LaLiberte Bill (베어 하트) Weinman Ben Laurie Francois Yergeau Paul J.Leach Mary Ellen Zurko Daniel DuBois Josh Cohen 캐싱 디자인의 내용과 프레젠테이션은 Shel Kaphan, Paul Leach, Koen Holtman, David Morris 및 Larry Masinter를 포함한 개인의 제안과 의견에 의한 것입니다. 범위 사양의 대부분은 Ari Luotonen과 John Franks가 원래 수행 한 작업을 기반으로하며 Steve Zilles의 추가 정보를 제공합니다. 팔로 알토의 &quot;동굴 남자&quot;에게 감사합니다. 넌 네가 누구인지 안다. Jim Gettys (현재이 문서의 편집자)는 John Klensin, Jeff Mogul, Paul Leach, Dave Kristol, Koen Holtman, John Franks, Josh Cohen, Alex Hopmann,이 문서의 이전 편집자 인 Roy Fielding에게 감사의 말씀을 전합니다. Scott Lawrence와 Larry Masinter의 도움을 받았습니다.&quot;MUST / MAY / SHOULD&quot;감사를 수행해 주신 Jeff Mogul과 Scott Lawrence에게 감사드립니다. Apache Group, Anselm Baird-Smith, Jigsaw의 저자 및 Henrik Frystyk가 구현했습니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; 초기에이 문서에서 해결하려는 많은 문제를 발견해 주셔서 감사합니다.</target>
        </trans-unit>
        <trans-unit id="3fad4602c9c700895f3ed6117008bdc18c9fc181" translate="yes" xml:space="preserve">
          <source>This specification reserves the method name CONNECT for use with a
   proxy that can dynamically switch to being a tunnel (e.g. SSL
   tunneling [&lt;a href=&quot;#ref-44&quot;&gt;44&lt;/a&gt;]).</source>
          <target state="translated">이 스펙은 터널로 동적 전환 할 수있는 프록시와 함께 사용하기 위해 메소드 이름 CONNECT를 예약합니다 (예 : SSL 터널링 [ &lt;a href=&quot;#ref-44&quot;&gt;44&lt;/a&gt; ]).</target>
        </trans-unit>
        <trans-unit id="672729314726c61a4c205fd539620a1ce076c9fe" translate="yes" xml:space="preserve">
          <source>This specification takes over the definition of the HTTP
   Authentication Framework, previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;.  We thank
   John Franks, Phillip M. Hallam-Baker, Jeffery L. Hostetler, Scott D.
   Lawrence, Paul J. Leach, Ari Luotonen, and Lawrence C. Stewart for
   their work on that specification.  See &lt;a href=&quot;https://tools.ietf.org/html/rfc2617#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC2617]&lt;/a&gt; for
   further acknowledgements.

   See &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-10&quot;&gt;Section&amp;nbsp;10 of [RFC7230]&lt;/a&gt; for the Acknowledgments related to this
   document revision.</source>
          <target state="translated">이 사양은 이전에 &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt; 에 정의 된 HTTP 인증 프레임 워크의 정의를 대체 합니다. John Franks, Phillip M. Hallam-Baker, Jeffery L. Hostetler, Scott D. Lawrence, Paul J. Leach, Ari Luotonen 및 Lawrence C. Stewart가이 사양에 대한 작업을 해주셔서 감사합니다. 추가 승인에 대해서는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2617#section-6&quot;&gt;[RFC2617]의 섹션 6을&lt;/a&gt; 참조하십시오 . 이 문서 개정과 관련된 승인에 대해서는 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-10&quot;&gt;[RFC7230]의 섹션 10을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="199a33e3a0bbdd6ce39373b856043ea2c7f5f848" translate="yes" xml:space="preserve">
          <source>This specification targets conformance criteria according to the role
   of a participant in HTTP communication.  Hence, HTTP requirements are
   placed on senders, recipients, clients, servers, user agents,
   intermediaries, origin servers, proxies, gateways, or caches,
   depending on what behavior is being constrained by the requirement.
   Additional (social) requirements are placed on implementations,
   resource owners, and protocol element registrations when they apply
   beyond the scope of a single communication.

   The verb &quot;generate&quot; is used instead of &quot;send&quot; where a requirement
   differentiates between creating a protocol element and merely
   forwarding a received element downstream.

   An implementation is considered conformant if it complies with all of
   the requirements associated with the roles it partakes in HTTP.

   Conformance includes both the syntax and semantics of protocol
   elements.  A sender MUST NOT generate protocol elements that convey a
   meaning that is known by that sender to be false.  A sender MUST NOT
   generate protocol elements that do not match the grammar defined by
   the corresponding ABNF rules.  Within a given message, a sender MUST
   NOT generate protocol elements or syntax alternatives that are only
   allowed to be generated by participants in other roles (i.e., a role
   that the sender does not have for that message).

   When a received protocol element is parsed, the recipient MUST be
   able to parse any value of reasonable length that is applicable to
   the recipient's role and that matches the grammar defined by the
   corresponding ABNF rules.  Note, however, that some received protocol
   elements might not be parsed.  For example, an intermediary 

   forwarding a message might parse a header-field into generic
   field-name and field-value components, but then forward the header
   field without further parsing inside the field-value.

   HTTP does not have specific length limitations for many of its
   protocol elements because the lengths that might be appropriate will
   vary widely, depending on the deployment context and purpose of the
   implementation.  Hence, interoperability between senders and
   recipients depends on shared expectations regarding what is a
   reasonable length for each protocol element.  Furthermore, what is
   commonly understood to be a reasonable length for some protocol
   elements has changed over the course of the past two decades of HTTP
   use and is expected to continue changing in the future.

   At a minimum, a recipient MUST be able to parse and process protocol
   element lengths that are at least as long as the values that it
   generates for those same protocol elements in other messages.  For
   example, an origin server that publishes very long URI references to
   its own resources needs to be able to parse and process those same
   references when received as a request target.

   A recipient MUST interpret a received protocol element according to
   the semantics defined for it by this specification, including
   extensions to this specification, unless the recipient has determined
   (through experience or configuration) that the sender incorrectly
   implements what is implied by those semantics.  For example, an
   origin server might disregard the contents of a received
   Accept-Encoding header field if inspection of the User-Agent header
   field indicates a specific implementation version that is known to
   fail on receipt of certain content codings.

   Unless noted otherwise, a recipient MAY attempt to recover a usable
   protocol element from an invalid construct.  HTTP does not define
   specific error handling mechanisms except when they have a direct
   impact on security, since different applications of the protocol
   require different error handling strategies.  For example, a Web
   browser might wish to transparently recover from a response where the
   Location header field doesn't parse according to the ABNF, whereas a
   systems control client might consider any form of error recovery to
   be dangerous.</source>
          <target state="translated">이 사양은 HTTP 통신에서 참가자의 역할에 따른 적합성 기준을 대상으로합니다. 따라서 HTTP 요구 사항은 요구 사항에 의해 제한되는 동작에 따라 발신자, 수신자, 클라이언트, 서버, 사용자 에이전트, 중개자, 오리진 서버, 프록시, 게이트웨이 또는 캐시에 적용됩니다. 구현, 리소스 소유자 및 프로토콜 요소 등록이 단일 통신 범위를 넘어 적용되는 경우 추가 (사회적) 요구 사항이 적용됩니다. 요구 사항이 프로토콜 요소를 작성하는 것과 수신 된 요소를 다운 스트림으로 전달하는 것만 구별하는 &quot;보내기&quot;대신 &quot;생성&quot;동사가 사용됩니다.구현이 HTTP에서 수행하는 역할과 관련된 모든 요구 사항을 준수하는 경우 적합한 것으로 간주됩니다. 적합성에는 프로토콜 요소의 구문과 의미가 모두 포함됩니다. 발신자는 발신자가 알고있는 의미를 거짓으로 나타내는 프로토콜 요소를 생성해서는 안됩니다. 발신자는 해당 ABNF 규칙에 의해 정의 된 문법과 일치하지 않는 프로토콜 요소를 생성해서는 안된다 (MUST NOT). 주어진 메시지 내에서, 발신자는 다른 역할 (즉, 발신자가 그 메시지에 대해 가지고 있지 않은 역할)의 참가자 만이 생성 할 수있는 프로토콜 요소 나 구문 대안을 생성해서는 안된다 (MUST NOT). 수신 된 프로토콜 요소가 구문 분석 될 때 수신자는 수신자에게 적용 가능한 합리적인 길이의 값을 구문 분석 할 수 있어야합니다.역할과 해당 ABNF 규칙에 의해 정의 된 문법과 일치합니다. 그러나 일부 수신 된 프로토콜 요소는 구문 분석되지 않을 수 있습니다. 예를 들어, 메시지를 전달하는 중개자는 헤더 필드를 일반 필드 이름 및 필드 값 컴포넌트로 구문 분석 할 수 있지만 필드 값 내부에서 추가 구문 분석을하지 않고 헤더 필드를 전달할 수 있습니다. HTTP는 많은 프로토콜 요소에 대한 특정 길이 제한이 없습니다. 배포 길이와 구현 목적에 따라 적절한 길이가 크게 달라질 수 있기 때문입니다. 따라서, 발신자와 수신자 간의 상호 운용성은 각 프로토콜 요소의 합리적인 길이에 대한 공유 된 기대에 달려 있습니다. 더욱이,일부 프로토콜 요소에 대해 합리적인 길이로 일반적으로 이해되는 것은 지난 20 년간의 HTTP 사용 과정에서 변경되었으며 앞으로도 계속 변경 될 것으로 예상됩니다. 최소한 수신자는 다른 메시지에서 동일한 프로토콜 요소에 대해 생성 한 값만큼 최소한 프로토콜 요소 길이를 구문 분석하고 처리 할 수 ​​있어야합니다. 예를 들어, 매우 긴 URI 참조를 자체 자원에 공개하는 오리진 서버는 요청 대상으로 수신 될 때 동일한 참조를 구문 분석하고 처리 할 수 ​​있어야합니다. 수신자는 반드시이 규격에 대한 확장을 포함하여 본 규격에 의해 정의 된 의미론에 따라 수신 된 프로토콜 요소를 해석해야한다.수신자가 (경험이나 구성을 통해) 발신자가 해당 의미에 의해 암시 된 것을 잘못 구현 한 것으로 판단하지 않는 한. 예를 들어, User-Agent 헤더 필드의 검사가 특정 컨텐츠 코딩의 수신에 실패한 것으로 알려진 특정 구현 버전을 나타내는 경우, 오리진 서버는 수신 된 Accept-Encoding 헤더 필드의 컨텐츠를 무시할 수 있습니다. 달리 언급되지 않는 한, 수신자는 유효하지 않은 구조에서 사용 가능한 프로토콜 요소를 복구하려고 시도 할 수있다. 프로토콜의 응용 프로그램마다 다른 오류 처리 전략이 필요하기 때문에 HTTP는 보안에 직접적인 영향을 미치는 경우를 제외하고 특정 오류 처리 메커니즘을 정의하지 않습니다. 예를 들어웹 브라우저는 ABNF에 따라 Location 헤더 필드가 구문 분석되지 않는 응답에서 투명하게 복구하기를 원하지만 시스템 제어 클라이언트는 모든 형태의 오류 복구를 위험한 것으로 간주 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="facba0308af11f7848962366e11eb270544c791e" translate="yes" xml:space="preserve">
          <source>This specification uses a number of terms to refer to the roles
   played by participants in, and objects of, the HTTP communication.

   connection
      A transport layer virtual circuit established between two programs
      for the purpose of communication.

   message
      The basic unit of HTTP communication, consisting of a structured
      sequence of octets matching the syntax defined in &lt;a href=&quot;#section-4&quot;&gt;section 4&lt;/a&gt; and
      transmitted via the connection.

   request
      An HTTP request message, as defined in &lt;a href=&quot;#section-5&quot;&gt;section 5&lt;/a&gt;.

   response
      An HTTP response message, as defined in &lt;a href=&quot;#section-6&quot;&gt;section 6&lt;/a&gt;. 

   resource
      A network data object or service that can be identified by a URI,
      as defined in &lt;a href=&quot;#section-3.2&quot;&gt;section 3.2&lt;/a&gt;. Resources may be available in multiple
      representations (e.g. multiple languages, data formats, size, and
      resolutions) or vary in other ways.

   entity
      The information transferred as the payload of a request or
      response. An entity consists of metainformation in the form of
      entity-header fields and content in the form of an entity-body, as
      described in &lt;a href=&quot;#section-7&quot;&gt;section 7&lt;/a&gt;.

   representation
      An entity included with a response that is subject to content
      negotiation, as described in &lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;. There may exist multiple
      representations associated with a particular response status.

   content negotiation
      The mechanism for selecting the appropriate representation when
      servicing a request, as described in &lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;. The
      representation of entities in any response can be negotiated
      (including error responses).

   variant
      A resource may have one, or more than one, representation(s)
      associated with it at any given instant. Each of these
      representations is termed a `varriant'.  Use of the term `variant'
      does not necessarily imply that the resource is subject to content
      negotiation.

   client
      A program that establishes connections for the purpose of sending
      requests.

   user agent
      The client which initiates a request. These are often browsers,
      editors, spiders (web-traversing robots), or other end user tools.

   server
      An application program that accepts connections in order to
      service requests by sending back responses. Any given program may
      be capable of being both a client and a server; our use of these
      terms refers only to the role being performed by the program for a
      particular connection, rather than to the program's capabilities
      in general. Likewise, any server may act as an origin server,
      proxy, gateway, or tunnel, switching behavior based on the nature
      of each request. 

   origin server
      The server on which a given resource resides or is to be created.

   proxy
      An intermediary program which acts as both a server and a client
      for the purpose of making requests on behalf of other clients.
      Requests are serviced internally or by passing them on, with
      possible translation, to other servers. A proxy MUST implement
      both the client and server requirements of this specification. A
      &quot;transparent proxy&quot; is a proxy that does not modify the request or
      response beyond what is required for proxy authentication and
      identification. A &quot;non-transparent proxy&quot; is a proxy that modifies
      the request or response in order to provide some added service to
      the user agent, such as group annotation services, media type
      transformation, protocol reduction, or anonymity filtering. Except
      where either transparent or non-transparent behavior is explicitly
      stated, the HTTP proxy requirements apply to both types of
      proxies.

   gateway
      A server which acts as an intermediary for some other server.
      Unlike a proxy, a gateway receives requests as if it were the
      origin server for the requested resource; the requesting client
      may not be aware that it is communicating with a gateway.

   tunnel
      An intermediary program which is acting as a blind relay between
      two connections. Once active, a tunnel is not considered a party
      to the HTTP communication, though the tunnel may have been
      initiated by an HTTP request. The tunnel ceases to exist when both
      ends of the relayed connections are closed.

   cache
      A program's local store of response messages and the subsystem
      that controls its message storage, retrieval, and deletion. A
      cache stores cacheable responses in order to reduce the response
      time and network bandwidth consumption on future, equivalent
      requests. Any client or server may include a cache, though a cache
      cannot be used by a server that is acting as a tunnel.

   cacheable
      A response is cacheable if a cache is allowed to store a copy of
      the response message for use in answering subsequent requests. The
      rules for determining the cacheability of HTTP responses are
      defined in &lt;a href=&quot;#section-13&quot;&gt;section 13&lt;/a&gt;. Even if a resource is cacheable, there may
      be additional constraints on whether a cache can use the cached
      copy for a particular request. 

   first-hand
      A response is first-hand if it comes directly and without
      unnecessary delay from the origin server, perhaps via one or more
      proxies. A response is also first-hand if its validity has just
      been checked directly with the origin server.

   explicit expiration time
      The time at which the origin server intends that an entity should
      no longer be returned by a cache without further validation.

   heuristic expiration time
      An expiration time assigned by a cache when no explicit expiration
      time is available.

   age
      The age of a response is the time since it was sent by, or
      successfully validated with, the origin server.

   freshness lifetime
      The length of time between the generation of a response and its
      expiration time.

   fresh
      A response is fresh if its age has not yet exceeded its freshness
      lifetime.

   stale
      A response is stale if its age has passed its freshness lifetime.

   semantically transparent
      A cache behaves in a &quot;semantically transparent&quot; manner, with
      respect to a particular response, when its use affects neither the
      requesting client nor the origin server, except to improve
      performance. When a cache is semantically transparent, the client
      receives exactly the same response (except for hop-by-hop headers)
      that it would have received had its request been handled directly
      by the origin server.

   validator
      A protocol element (e.g., an entity tag or a Last-Modified time)
      that is used to find out whether a cache entry is an equivalent
      copy of an entity.

   upstream/downstream
      Upstream and downstream describe the flow of a message: all
      messages flow from upstream to downstream. 

   inbound/outbound
      Inbound and outbound refer to the request and response paths for
      messages: &quot;inbound&quot; means &quot;traveling toward the origin server&quot;,
      and &quot;outbound&quot; means &quot;traveling toward the user agent&quot;</source>
          <target state="translated">이 표준은 여러 용어를 사용하여 HTTP 통신의 참여자 및 대상이 수행하는 역할을 나타냅니다. 연결 통신 목적으로 두 프로그램간에 설정된 전송 계층 가상 회로. 메시지 HTTP 통신의 기본 단위로, &lt;a href=&quot;#section-4&quot;&gt;섹션 4에&lt;/a&gt; 정의되어 있고 연결을 통해 전송 된 구문과 일치하는 구조화 된 옥텟 시퀀스로 구성됩니다 . request &lt;a href=&quot;#section-5&quot;&gt;섹션 5에&lt;/a&gt; 정의 된 HTTP 요청 메시지 . response &lt;a href=&quot;#section-6&quot;&gt;6 절에&lt;/a&gt; 정의 된 HTTP 응답 메시지 . resource &lt;a href=&quot;#section-3.2&quot;&gt;3.2 절에&lt;/a&gt; 정의 된 URI로 식별 할 수있는 네트워크 데이터 객체 또는 서비스. 리소스는 여러 가지 표현 (예 : 여러 언어, 데이터 형식, 크기 및 해상도)으로 제공되거나 다른 방식으로 달라질 수 있습니다. 엔티티 요청 또는 응답의 페이로드로 전송 된 정보입니다. 엔터티는 &lt;a href=&quot;#section-7&quot;&gt;섹션 7&lt;/a&gt; 에서 설명한 것처럼 엔터티 헤더 필드 형식의 메타 정보와 엔터티 본문 형식의 콘텐츠로 구성됩니다 . 표현 &lt;a href=&quot;#section-12&quot;&gt;12 절에&lt;/a&gt; 기술 된 바와 같이, 내용 협상을받는 응답에 포함 된 실체 . 특정 응답 상태와 관련된 여러 표현이있을 수 있습니다. 내용 협상 &lt;a href=&quot;#section-12&quot;&gt;섹션 12에&lt;/a&gt; 설명 된대로 요청을 처리 할 때 적절한 표현을 선택하는 메커니즘. 응답에서 엔터티 표현을 협상 할 수 있습니다 (오류 응답 포함). 변형 자원은 임의의 주어진 순간에 그와 관련된 하나 이상의 표현 (들)을 가질 수있다. 이 표현들은 각각 '변종'이라고합니다. '변형 (variant)'이라는 용어를 사용한다고해서 반드시 자원이 내용 협상을 받아야한다는 것을 의미하지는 않습니다. 클라이언트 요청을 보내기 위해 연결을 설정하는 프로그램입니다. 사용자 에이전트 요청을 시작하는 클라이언트입니다. 이들은 종종 브라우저, 편집자, 스파이더 (웹 탐색 로봇) 또는 기타 최종 사용자 도구입니다. 서버 응답을 다시 보내 요청을 처리하기 위해 연결을 수락하는 응용 프로그램.임의의 주어진 프로그램은 클라이언트 및 서버 둘 다일 수있다; 이러한 용어의 사용은 일반적으로 프로그램의 기능이 아니라 특정 연결에 대해 프로그램이 수행하는 역할만을 나타냅니다. 마찬가지로 모든 서버는 원본 서버, 프록시, 게이트웨이 또는 터널로 작동하여 각 요청의 특성에 따라 동작을 전환 할 수 있습니다. 오리진 서버 지정된 자원이 상주하거나 작성 될 서버. 프록시 다른 클라이언트를 대신하여 요청을하기 위해 서버와 클라이언트의 역할을하는 중개 프로그램입니다. 요청은 내부적으로 또는 가능한 번역을 통해 다른 서버로 전달하여 서비스됩니다. 프록시는 반드시이 사양의 클라이언트 및 서버 요구 사항을 모두 구현해야합니다.&quot;투명 프록시&quot;는 프록시 인증 및 식별에 필요한 것 이상으로 요청 또는 응답을 수정하지 않는 프록시입니다. &quot;투명한 프록시&quot;는 그룹 주석 서비스, 미디어 유형 변환, 프로토콜 축소 또는 익명 필터링과 같은 추가 에이전트 서비스를 사용자 에이전트에 제공하기 위해 요청 또는 응답을 수정하는 프록시입니다. 투명하거나 투명하지 않은 동작이 명시 적으로 언급 된 경우를 제외하고 HTTP 프록시 요구 사항은 두 가지 유형의 프록시 모두에 적용됩니다. 게이트웨이 다른 서버의 중개자 역할을하는 서버. 프록시와 달리 게이트웨이는 요청 된 자원의 원래 서버 인 것처럼 요청을 수신합니다.요청 클라이언트는 게이트웨이와 통신하고 있음을 인식하지 못할 수 있습니다. 터널 두 연결 사이의 블라인드 릴레이 역할을하는 중개 프로그램. 터널이 HTTP 요청에 의해 시작되었을 수 있지만 터널이 활성화되면 HTTP 통신의 당사자로 간주되지 않습니다. 중계 된 연결의 양쪽 끝이 닫히면 터널이 존재하지 않습니다. 캐시 응답 메시지의 프로그램 로컬 저장소 및 해당 메시지 저장소, 검색 및 삭제를 제어하는 ​​하위 시스템. 캐시는 캐시 가능한 응답을 저장하여 향후 동등한 요청에 대한 응답 시간과 네트워크 대역폭 소비를 줄입니다. 클라이언트 나 서버에는 캐시가 포함될 수 있지만 터널로 작동하는 서버는 캐시를 사용할 수 없습니다.캐시 가능 캐시가 후속 요청에 응답하기 위해 응답 메시지의 사본을 캐시에 저장하도록 허용 된 경우 응답을 캐시 할 수 있습니다. HTTP 응답의 캐시 가능성을 결정하기위한 규칙은&lt;a href=&quot;#section-13&quot;&gt;섹션 13&lt;/a&gt;. 리소스가 캐시 가능한 경우에도 캐시가 특정 요청에 대해 캐시 된 복사본을 사용할 수 있는지 여부에 대한 추가 제약이있을 수 있습니다. 직접 응답 하나 이상의 프록시를 통해 오리진 서버에서 불필요한 지연없이 직접 발생하는 경우 직접 응답합니다. 응답이 원래 서버에서 직접 확인 된 경우에도 직접 응답합니다. 명시 적 만기 시간 원래 서버가 더 이상 유효성 검증없이 캐시가 엔티티를 더 이상 리턴하지 않도록 의도 한 시간입니다. 휴리스틱 만료 시간 명시적인 만료 시간이 없을 때 캐시에 의해 할당 된 만료 시간입니다. age 응답의 나이는 오리진 서버에 의해 전송되거나 검증 된 이후의 시간입니다.신선도 수명 응답 생성과 만료 시간 사이의 시간입니다. 신선도 나이가 신선도 수명을 아직 초과하지 않은 경우 반응이 신선합니다. 부실 나이가 신선도 수명을 지났 으면 응답이 부실합니다. 의미 적으로 투명성 캐시는 성능 향상을 제외하고는 사용이 요청 클라이언트 나 오리진 서버에 영향을 미치지 않을 때 특정 응답과 관련하여 &quot;의도적으로 투명하게&quot;동작합니다. 캐시가 의미 적으로 투명한 경우 클라이언트는 요청이 오리진 서버에 의해 직접 처리 된 경우 수신 한 것과 동일한 응답 (홉별 헤더 제외)을 수신합니다. 유효성 검사기 프로토콜 요소 (예 :캐시 항목이 엔티티의 동등한 사본인지 여부를 확인하는 데 사용되는 엔티티 태그 또는 Last-Modified 시간). 업스트림 / 다운 스트림 업스트림 및 다운 스트림은 메시지 흐름을 설명합니다. 모든 메시지는 업스트림에서 다운 스트림으로 흐릅니다. 인바운드 / 아웃 바운드 인바운드 및 아웃 바운드는 메시지의 요청 및 응답 경로를 나타냅니다. &quot;인바운드&quot;는 &quot;원본 서버로의 이동&quot;을 의미하고 &quot;아웃 바운드&quot;는 &quot;사용자 에이전트로의 이동&quot;을 의미합니다.인바운드 / 아웃 바운드 인바운드 및 아웃 바운드는 메시지의 요청 및 응답 경로를 나타냅니다. &quot;인바운드&quot;는 &quot;원본 서버로의 이동&quot;을 의미하고 &quot;아웃 바운드&quot;는 &quot;사용자 에이전트로의 이동&quot;을 의미합니다.인바운드 / 아웃 바운드 인바운드 및 아웃 바운드는 메시지의 요청 및 응답 경로를 나타냅니다. &quot;인바운드&quot;는 &quot;원본 서버로의 이동&quot;을 의미하고 &quot;아웃 바운드&quot;는 &quot;사용자 에이전트로의 이동&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5366fbe830e07db7f7079781b54e53bea8e2feb6" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;,
   that allows for compact definition of comma-separated lists using a
   '#' operator (similar to how the '*' operator indicates repetition).
   &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt; shows the collected grammar with all list operators
   expanded to standard ABNF notation.

   The following core rules are included by reference, as defined in
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;[RFC5234], Appendix&amp;nbsp;B.1&lt;/a&gt;: ALPHA (letters), CR (carriage return), CRLF
   (CR LF), CTL (controls), DIGIT (decimal 0-9), DQUOTE (double quote),
   HEXDIG (hexadecimal 0-9/A-F/a-f), HTAB (horizontal tab), LF (line
   feed), OCTET (any 8-bit sequence of data), SP (space), and VCHAR (any
   visible [&lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt;] character).

   As a convention, ABNF rule names prefixed with &quot;obs-&quot; denote
   &quot;obsolete&quot; grammar rules that appear for historical reasons.</source>
          <target state="translated">이 사양은 &lt;a href=&quot;#section-7&quot;&gt;섹션 7에&lt;/a&gt; 정의 된 목록 확장과 함께 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] 의 ABNF (Augmented Backus-Naur Form) 표기법을 사용하며 '#'연산자를 사용하여 쉼표로 구분 된 목록을 간단하게 정의 할 수 있습니다 ( '*' '연산자는 반복을 나타냅니다). &lt;a href=&quot;#appendix-B&quot;&gt;부록 B&lt;/a&gt; 는 모든 목록 연산자가 표준 ABNF 표기법으로 확장 된 수집 된 문법을 보여줍니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc5234#appendix-B.1&quot;&gt;부록 B.1 [RFC5234]에&lt;/a&gt; 정의 된대로 다음 핵심 규칙이 참조로 포함됩니다. : ALPHA (문자), CR (캐리지 리턴), CRLF (CR LF), CTL (컨트롤), DIGIT (10 진수 0-9), DQUOTE (큰 따옴표), HEXDIG (16 진수 0-9 / AF / af), HTAB (수평 탭), LF (줄 바꿈), OCTET (8 비트 데이터 시퀀스), SP (공백) 및 VCHAR (모든 가시 [ &lt;a href=&quot;#ref-USASCII&quot;&gt;USASCII&lt;/a&gt; ] 문자). 관례 적으로, &quot;obs-&quot;접두사가 붙은 ABNF 규칙 이름은 역사적 이유로 나타나는 &quot;사용되지 않는&quot;문법 규칙을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3f746953f3428a5eccba921f06abcdb82aa34c60" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt;, that allows for compact definition of comma-separated
   lists using a '#' operator (similar to how the '*' operator indicates
   repetition).  &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt; describes rules imported from other
   documents.  &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt; shows the collected grammar with all list
   operators expanded to standard ABNF notation.</source>
          <target state="translated">이 사양은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;[RFC7230]의 섹션 7에&lt;/a&gt; 정의 된 목록 확장과 함께 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] 의 ABNF (Augmented Backus-Naur Form) 표기법을 사용하며 '#'연산자를 사용하여 쉼표로 구분 된 목록을 간단하게 정의 할 수 있습니다 ( '*'연산자가 반복을 나타내는 방법). &lt;a href=&quot;#appendix-B&quot;&gt;부록 B&lt;/a&gt; 에서는 다른 문서에서 가져온 규칙에 대해 설명합니다. &lt;a href=&quot;#appendix-C&quot;&gt;부록 C&lt;/a&gt; 는 모든 목록 연산자가 표준 ABNF 표기법으로 확장 된 수집 된 문법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="faf3c32d78c2b6483745156433268b97ba91a18a" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt;, that allows for compact definition of comma-separated
   lists using a '#' operator (similar to how the '*' operator indicates
   repetition).  &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt; describes rules imported from other
   documents.  &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt; shows the collected grammar with all list
   operators expanded to standard ABNF notation.</source>
          <target state="translated">이 사양은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;[RFC7230]의 섹션 7에&lt;/a&gt; 정의 된 목록 확장과 함께 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] 의 ABNF (Augmented Backus-Naur Form) 표기법을 사용하며 '#'연산자를 사용하여 쉼표로 구분 된 목록을 간단하게 정의 할 수 있습니다 ( '*'연산자가 반복을 나타내는 방법). &lt;a href=&quot;#appendix-C&quot;&gt;부록 C&lt;/a&gt; 는 다른 문서에서 가져온 규칙을 설명합니다. &lt;a href=&quot;#appendix-D&quot;&gt;부록 D&lt;/a&gt; 는 모든 목록 연산자가 표준 ABNF 표기법으로 확장 된 수집 된 문법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ee23ef0e85f4f9cd9d0acebbd9b86ac08e046506" translate="yes" xml:space="preserve">
          <source>This specification uses the Augmented Backus-Naur Form (ABNF)
   notation of [&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;] with a list extension, defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt;, that allows for compact definition of comma-separated
   lists using a '#' operator (similar to how the '*' operator indicates
   repetition).  &lt;a href=&quot;#appendix-C&quot;&gt;Appendix C&lt;/a&gt; describes rules imported from other
   documents.  &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt; shows the collected grammar with all list
   operators expanded to standard ABNF notation. 

   This specification uses the terms &quot;character&quot;, &quot;character encoding
   scheme&quot;, &quot;charset&quot;, and &quot;protocol element&quot; as they are defined in
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt;].</source>
          <target state="translated">이 사양은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;[RFC7230]의 섹션 7에&lt;/a&gt; 정의 된 목록 확장과 함께 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ] 의 ABNF (Augmented Backus-Naur Form) 표기법을 사용하며 '#'연산자를 사용하여 쉼표로 구분 된 목록을 간단하게 정의 할 수 있습니다 ( '*'연산자가 반복을 나타내는 방법). &lt;a href=&quot;#appendix-C&quot;&gt;부록 C&lt;/a&gt; 는 다른 문서에서 가져온 규칙을 설명합니다. &lt;a href=&quot;#appendix-D&quot;&gt;부록 D&lt;/a&gt; 는 모든 목록 연산자가 표준 ABNF 표기법으로 확장 된 수집 된 문법을 보여줍니다. 본 명세서는 용어 &quot;문자&quot;, &quot;문자 인코딩 체계&quot;, &quot;문자 세트&quot;및 &quot;프로토콜 요소&quot;를 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt; ]에 정의 된 바와 같이 사용 한다.</target>
        </trans-unit>
        <trans-unit id="98343664a6355afcb4ca38df251b44b6714d8a1e" translate="yes" xml:space="preserve">
          <source>This specification uses three rules to denote the use of linear
   whitespace: OWS (optional whitespace), RWS (required whitespace), and
   BWS (&quot;bad&quot; whitespace).

   The OWS rule is used where zero or more linear whitespace octets
   might appear.  For protocol elements where optional whitespace is
   preferred to improve readability, a sender SHOULD generate the
   optional whitespace as a single SP; otherwise, a sender SHOULD NOT
   generate optional whitespace except as needed to white out invalid or
   unwanted protocol elements during in-place message filtering.

   The RWS rule is used when at least one linear whitespace octet is
   required to separate field tokens.  A sender SHOULD generate RWS as a
   single SP.

   The BWS rule is used where the grammar allows optional whitespace
   only for historical reasons.  A sender MUST NOT generate BWS in
   messages.  A recipient MUST parse for such bad whitespace and remove
   it before interpreting the protocol element. 

     OWS            = *( SP / HTAB )
                    ; optional whitespace
     RWS            = 1*( SP / HTAB )
                    ; required whitespace
     BWS            = OWS
                    ; &quot;bad&quot; whitespace</source>
          <target state="translated">이 사양에서는 선형 공백 사용을 나타내는 세 가지 규칙 인 OWS (선택적 공백), RWS (필수 공백) 및 BWS ( &quot;나쁜&quot;공백)를 사용합니다. OWS 규칙은 0 개 이상의 선형 공백 옥텟이 나타날 수있는 곳에 사용됩니다. 가독성을 개선하기 위해 선택적 공백이 선호되는 프로토콜 요소의 경우, 발신자는 선택적 SP를 단일 SP로 생성해야합니다. 그렇지 않으면 발신자는 전체 메시지 필터링 중에 유효하지 않거나 원치 않는 프로토콜 요소를 제거하는 데 필요한 경우를 제외하고 선택적 공백을 생성하지 않아야합니다. RWS 규칙은 필드 토큰을 분리하기 위해 하나 이상의 선형 공백 옥텟이 필요한 경우에 사용됩니다. 발신자는 RWS를 단일 SP로 생성해야합니다. BWS 규칙은 문법이 역사적 이유로 만 선택적 공백을 허용하는 경우에 사용됩니다.발신자는 메시지에서 BWS를 생성해서는 안됩니다. 수신자는 이러한 잘못된 공백을 구문 분석하고 프로토콜 요소를 해석하기 전에 제거해야합니다. OWS = * (SP / HTAB); 선택적 공백 RWS = 1 * (SP / HTAB); 필요한 공백 BWS = OWS; &quot;나쁜&quot;공백</target>
        </trans-unit>
        <trans-unit id="aff04232d95d6c1171cd6ab1415e3e08026d9557" translate="yes" xml:space="preserve">
          <source>This specification uses two new media types that conform to the
   registry mechanism described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4288&quot;&gt;RFC4288&lt;/a&gt;], a new message header that
   conforms to the registry mechanism described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt;], and two
   new link relations that conform to the registry mechanism described
   in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].</source>
          <target state="translated">이 명세서 [에서 설명한 등록 메커니즘에 부합 개의 새로운 미디어 타입 사용 &lt;a href=&quot;https://tools.ietf.org/html/rfc4288&quot;&gt;RFC4288&lt;/a&gt; ] 레지스트리 메커니즘에 부합는 [에서 설명한 새로운 메시지 헤더 &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC3864&lt;/a&gt; [에서 설명한 등록 메커니즘에 부합], 2 개 개의 새로운 링크 관계 &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287을&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="230704ae6595086f8b4b75eab8034387112b13dd" translate="yes" xml:space="preserve">
          <source>This status can also send a &lt;a href=&quot;../headers/retry-after&quot;&gt;&lt;code&gt;Retry-After&lt;/code&gt;&lt;/a&gt; header, telling the requester when to check back to see if the functionality is supported by then.</source>
          <target state="translated">This status can also send a &lt;a href=&quot;../headers/retry-after&quot;&gt; &lt;code&gt;Retry-After&lt;/code&gt; &lt;/a&gt; header, telling the requester when to check back to see if the functionality is supported by then.</target>
        </trans-unit>
        <trans-unit id="755885b5d7d7ceb53dac1ececfff6ea91ddc944f" translate="yes" xml:space="preserve">
          <source>This status code is primarily intended to be used with the &lt;a href=&quot;headers/link&quot;&gt;&lt;code&gt;Link&lt;/code&gt;&lt;/a&gt; header, letting the user agent start &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content&quot;&gt;preloading&lt;/a&gt; resources while the server prepares a response.</source>
          <target state="translated">This status code is primarily intended to be used with the &lt;a href=&quot;headers/link&quot;&gt; &lt;code&gt;Link&lt;/code&gt; &lt;/a&gt; header, letting the user agent start &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content&quot;&gt;preloading&lt;/a&gt; resources while the server prepares a response.</target>
        </trans-unit>
        <trans-unit id="168a50454b53ca416e50a221ecab212a73004d2b" translate="yes" xml:space="preserve">
          <source>This status code is used in HTTP 1.1 only for Request-URIs, not URIs
   in other locations.</source>
          <target state="translated">이 상태 코드는 HTTP 1.1에서 다른 위치의 URI가 아닌 Request-URI에 대해서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e6542819db91e2214f7b4c25edf572e8a36dacaa" translate="yes" xml:space="preserve">
          <source>This status is not generated by origin servers, but by intercepting proxies that control access to the network.</source>
          <target state="translated">이 상태는 오리진 서버가 아니라 네트워크 액세스를 제어하는 ​​프록시를 가로 채서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="372dd7c8c17bd1505f433437b7bcad8e716c04b8" translate="yes" xml:space="preserve">
          <source>This status is sent with a &lt;a href=&quot;../headers/proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt; header that contains information on how to authorize correctly.</source>
          <target state="translated">이 상태는 올바르게 인증하는 방법에 대한 정보가 포함 된 &lt;a href=&quot;../headers/proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt; 헤더 와 함께 전송 됩니다.</target>
        </trans-unit>
        <trans-unit id="a3cd34d9e9d7109fa13e3c0395c58eb46cc7b8a7" translate="yes" xml:space="preserve">
          <source>This status is sent with a &lt;a href=&quot;../headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; header that contains information on how to authorize correctly.</source>
          <target state="translated">이 상태는 올바르게 권한 부여하는 방법에 대한 정보가 포함 된 &lt;a href=&quot;../headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt; 헤더 와 함께 전송 됩니다.</target>
        </trans-unit>
        <trans-unit id="8a9d71b9023a06f11edab66435c308dc6a0ee383" translate="yes" xml:space="preserve">
          <source>This status is similar to &lt;a href=&quot;401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;, but in this case, re-authenticating will make no difference. The access is permanently forbidden and tied to the application logic, such as insufficient rights to a resource.</source>
          <target state="translated">이 상태는 &lt;a href=&quot;401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만이 경우 다시 인증해도 아무런 차이가 없습니다. 액세스 권한이 영구적으로 금지되며 리소스에 대한 권한이 충분하지 않은 등의 응용 프로그램 논리에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="a37c225e3a7cdee05e8c812d332fa6e17571a6c3" translate="yes" xml:space="preserve">
          <source>This status is similar to &lt;a href=&quot;403&quot;&gt;&lt;code&gt;403&lt;/code&gt;&lt;/a&gt;, but in this case, authentication is possible.</source>
          <target state="translated">이 상태는 &lt;a href=&quot;403&quot;&gt; &lt;code&gt;403&lt;/code&gt; &lt;/a&gt; 과 유사 하지만이 경우 인증이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d740e14cfb624c7102c236e54e55ea5db95b95e3" translate="yes" xml:space="preserve">
          <source>This technique does work for internal links, but try to avoid having internal redirects. A redirect has a significant performance cost (as an extra HTTP request occurs). If you can avoid it by correcting internal links, you should fix those links instead.</source>
          <target state="translated">This technique does work for internal links, but try to avoid having internal redirects. A redirect has a significant performance cost (as an extra HTTP request occurs). If you can avoid it by correcting internal links, you should fix those links instead.</target>
        </trans-unit>
        <trans-unit id="be28e288a13627a68b1784eb600b0e65cfd5a0de" translate="yes" xml:space="preserve">
          <source>This technique has an additional benefit: updating two cached resources at the same time will not lead to the situation where the out-dated version of one resource is used in combination with the new version of the other one. This is very important when web sites have CSS stylesheets or JS scripts that have mutual dependencies, i.e., they depend on each other because they refer to the same HTML elements.</source>
          <target state="translated">이 기술에는 추가 이점이 있습니다. 두 개의 캐시 된 리소스를 동시에 업데이트해도 한 리소스의 오래된 버전이 다른 리소스의 새 버전과 함께 사용되는 상황이 발생하지 않습니다. 이는 웹 사이트에 상호 의존성을 갖는 CSS 스타일 시트 또는 JS 스크립트가있는 경우 매우 중요합니다. 즉, 동일한 HTML 요소를 참조하기 때문에 서로 의존합니다.</target>
        </trans-unit>
        <trans-unit id="3aeab72cfc99a5f7f9ea4900285e4bd674414a02" translate="yes" xml:space="preserve">
          <source>This value can be modified using the &lt;a href=&quot;http://kb.mozillazine.org/Network.http.accept.default&quot;&gt;&lt;code&gt;network.http.accept.default&lt;/code&gt;&lt;/a&gt; parameter. &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l1750&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">이 값은 &lt;a href=&quot;http://kb.mozillazine.org/Network.http.accept.default&quot;&gt; &lt;code&gt;network.http.accept.default&lt;/code&gt; &lt;/a&gt; 매개 변수를 사용하여 수정할 수 있습니다 . &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l1750&quot;&gt;출처&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a0945e40dcef867b66faa0e27a1bd4227d6481c" translate="yes" xml:space="preserve">
          <source>This value can be modified using the &lt;code&gt;image.http.accept&lt;/code&gt; parameter. &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l3779&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">This value can be modified using the &lt;code&gt;image.http.accept&lt;/code&gt; parameter. &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l3779&quot;&gt;source&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee7de26255283cc9167d1e4ab5cca6cdf380b11c" translate="yes" xml:space="preserve">
          <source>This value can be modified using the &lt;code&gt;image.http.accept&lt;/code&gt; parameter. &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l4735&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">이 값은 &lt;code&gt;image.http.accept&lt;/code&gt; 매개 변수를 사용하여 수정할 수 있습니다 . &lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/modules/libpref/init/all.js#l4735&quot;&gt;출처&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b50b2cc5848103a486b6389534eb105140db6ea" translate="yes" xml:space="preserve">
          <source>This will lead to a simple exchange between the client and the server, using CORS headers to handle the privileges:</source>
          <target state="translated">이는 CORS 헤더를 사용하여 권한을 처리하여 클라이언트와 서버 사이를 간단하게 교환합니다.</target>
        </trans-unit>
        <trans-unit id="81a97739f75df445cadaa8f98d4fa5c5bdf3f859" translate="yes" xml:space="preserve">
          <source>This works roughly the same way as a client-initiated upgrade; an optional upgrade is requested by adding the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header to any message. A mandatory upgrade, though, works slightly differently, in that it requests the upgrade by replying to a message it receives with the &lt;a href=&quot;status/426&quot;&gt;&lt;code&gt;426&lt;/code&gt;&lt;/a&gt; status code, like this:</source>
          <target state="translated">이것은 클라이언트가 시작한 업그레이드와 거의 같은 방식으로 작동합니다. 메시지에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; 헤더를 추가하여 선택적 업그레이드를 요청 합니다. 그러나 필수 업그레이드는 다음과 같이 &lt;a href=&quot;status/426&quot;&gt; &lt;code&gt;426&lt;/code&gt; &lt;/a&gt; 상태 코드로 수신되는 메시지에 응답하여 업그레이드를 요청한다는 점에서 약간 다르게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="fa3701a77f1cf83ff8e3fe524326c23f848bc1ab" translate="yes" xml:space="preserve">
          <source>This would allow CORS requests from Mozilla, Google, Microsoft, and Apple's domains.</source>
          <target state="translated">이를 통해 Mozilla, Google, Microsoft 및 Apple 도메인의 CORS 요청이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a59129b8ca208dcde27e54fb7891ca5c8b965bb9" translate="yes" xml:space="preserve">
          <source>Though Feature Policy provides control of multiple features using a consistent syntax, the behavior of policy controlled features varies and depends on several factors.</source>
          <target state="translated">기능 정책은 일관된 구문을 사용하여 여러 기능을 제어 할 수 있지만 정책 제어 기능의 동작은 다양하며 여러 요인에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="35b0c32c11633fd5293f1721594a37c0441531d3" translate="yes" xml:space="preserve">
          <source>Though HTTP/2 adds some complexity, by embedding HTTP messages in frames to improve performance, the basic structure of messages has stayed the same since HTTP/1.0. Session flow remains simple, allowing it to be investigated, and debugged with a simple &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor&quot;&gt;HTTP message monitor&lt;/a&gt;.</source>
          <target state="translated">HTTP / 2는 성능을 향상시키기 위해 프레임에 HTTP 메시지를 임베드하여 약간의 복잡성을 추가하지만 메시지의 기본 구조는 HTTP / 1.0 이후로 동일하게 유지되었습니다. 세션 흐름은 단순하게 유지되므로 간단한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor&quot;&gt;HTTP 메시지 모니터&lt;/a&gt; 로이를 조사하고 디버깅 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a15157e510ae4fb6f9c552a8502c5d3c090f5d9" translate="yes" xml:space="preserve">
          <source>Though fixed in Firefox 69, previous 32-bit versions of Firefox running on 64-bit processors would report that the system is using a 32-bit CPU.</source>
          <target state="translated">Though fixed in Firefox 69, previous 32-bit versions of Firefox running on 64-bit processors would report that the system is using a 32-bit CPU.</target>
        </trans-unit>
        <trans-unit id="c1440c92eaa6c1b3552c42a43600691971d67871" translate="yes" xml:space="preserve">
          <source>Though the &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; directive is intended to replace the deprecated &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive, &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; is not supported in most browsers yet. So for compatibility with current browsers while also adding forward compatibility when browsers get &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; support, you can specify both &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; and &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Though the &lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; directive is intended to replace the deprecated &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive, &lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; is not supported in most browsers yet. So for compatibility with current browsers while also adding forward compatibility when browsers get &lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; support, you can specify both &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; and &lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="3b6645a896cbe79649d39568f2032a9ab20c38bc" translate="yes" xml:space="preserve">
          <source>Though the &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; directive is intended to replace the deprecated &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive, &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; isn&amp;rsquo;t supported in most browsers yet. So for compatibility with current browsers while also adding forward compatibility when browsers get &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; support, you can specify both &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; and &lt;a href=&quot;content-security-policy/report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">하지만 &lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; 지침이되지 않는 대체하기위한 것입니다 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 지침을 &lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; 아직 대부분의 브라우저에서 지원되지 않습니다. 따라서 브라우저가 &lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; 지원할 때 호환성을 추가하면서 현재 브라우저와의 호환성 을 위해 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 와 &lt;a href=&quot;content-security-policy/report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; 를&lt;/a&gt; 모두 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d2996b4c0f8fba5d4ab332690b5f78e0e30f92d" translate="yes" xml:space="preserve">
          <source>Though the &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; directive is intended to replace the deprecated &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; directive, &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; isn&amp;rsquo;t supported in most browsers yet. So for compatibility with current browsers while also adding forward compatibility when browsers get &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt; support, you can specify both &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; and &lt;a href=&quot;report-to&quot;&gt;&lt;code&gt;report-to&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">하지만 &lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; 지침이되지 않는 대체하기위한 것입니다 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 지침을 &lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; 아직 대부분의 브라우저에서 지원되지 않습니다. 따라서 브라우저가 &lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; &lt;/a&gt; 지원할 때 호환성을 추가하면서 현재 브라우저와의 호환성 을 위해 &lt;code&gt;&lt;strong&gt;report-uri&lt;/strong&gt;&lt;/code&gt; 와 &lt;a href=&quot;report-to&quot;&gt; &lt;code&gt;report-to&lt;/code&gt; 를&lt;/a&gt; 모두 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c3769f4cf6b7264f228cc766b7de9065e61137e" translate="yes" xml:space="preserve">
          <source>Though there are legitimate uses of this header for selecting content, &lt;a href=&quot;browser_detection_using_the_user_agent&quot;&gt;it is considered bad practice&lt;/a&gt; to rely on it to define what features are supported by the user agent.</source>
          <target state="translated">컨텐츠를 선택하기 위해이 헤더를 합법적으로 사용하지만 사용자 에이전트가 지원하는 기능을 정의하기 위해이 헤더에 의존하는 것은 &lt;a href=&quot;browser_detection_using_the_user_agent&quot;&gt;나쁜 습관&lt;/a&gt; 으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="b228606ae426f931604823fecbe96f6aa2850ab0" translate="yes" xml:space="preserve">
          <source>Threats</source>
          <target state="translated">Threats</target>
        </trans-unit>
        <trans-unit id="02283ca03b246291fac06381aab094d267592b90" translate="yes" xml:space="preserve">
          <source>Tighter Control Over Your Referrers &amp;ndash; Mozilla Security Blog</source>
          <target state="translated">리퍼러에 대한 엄격한 제어 &amp;ndash; Mozilla 보안 블로그</target>
        </trans-unit>
        <trans-unit id="7197d879754a435ef6abdac823a28530b7748197" translate="yes" xml:space="preserve">
          <source>Time based conditions</source>
          <target state="translated">시간 기반 조건</target>
        </trans-unit>
        <trans-unit id="d21434199b502487596cffe0f83fce73f8fae46d" translate="yes" xml:space="preserve">
          <source>TimeOut = &quot;Timeout&quot; &quot;:&quot; 1#TimeType
      TimeType = (&quot;Second-&quot; DAVTimeOutVal | &quot;Infinite&quot;)
                 ; No LWS allowed within TimeType
      DAVTimeOutVal = 1*DIGIT

   Clients MAY include Timeout request headers in their LOCK requests.
   However, the server is not required to honor or even consider these
   requests.  Clients MUST NOT submit a Timeout request header with any
   method other than a LOCK method.

   The &quot;Second&quot; TimeType specifies the number of seconds that will
   elapse between granting of the lock at the server, and the automatic
   removal of the lock.  The timeout value for TimeType &quot;Second&quot; MUST
   NOT be greater than 2^32-1.

   See &lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt; for a description of lock timeout behavior.</source>
          <target state="translated">TimeOut = &quot;Timeout&quot; &quot;:&quot;1 # TimeType TimeType = ( &quot;Second-&quot;DAVTimeOutVal | &quot;무한&quot;); TimeType 내에 허용 된 LWS가 없습니다. DAVTimeOutVal = 1 * DIGIT 클라이언트는 LOCK 요청에 타임 아웃 요청 헤더를 포함 할 수 있습니다. 그러나 서버는 이러한 요청을 존중하거나 고려할 필요가 없습니다. 클라이언트는 LOCK 메서드 이외의 다른 방법으로 타임 아웃 요청 헤더를 제출해서는 안됩니다. &quot;두 번째&quot;TimeType은 서버에서 잠금 부여와 잠금 자동 제거 사이의 경과 시간 (초)을 지정합니다. TimeType &quot;Second&quot;의 시간 초과 값은 2 ^ 32-1보다 크지 않아야합니다. 잠금 시간 종료 동작에 대한 설명은 &lt;a href=&quot;#section-6.6&quot;&gt;6.6 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7bbd92323b129c3217bf6942ecefc96c45003532" translate="yes" xml:space="preserve">
          <source>Timing-Allow-Origin</source>
          <target state="translated">Timing-Allow-Origin</target>
        </trans-unit>
        <trans-unit id="768e0c1c69573fb588f61f1308a015c11468e05f" translate="yes" xml:space="preserve">
          <source>Title</source>
          <target state="translated">Title</target>
        </trans-unit>
        <trans-unit id="eb5cc0f84fc345c602dd1accf23180e03ce108cd" translate="yes" xml:space="preserve">
          <source>Tk</source>
          <target state="translated">Tk</target>
        </trans-unit>
        <trans-unit id="6916244a87f04cf740dd467f9478fda4624dfa30" translate="yes" xml:space="preserve">
          <source>To add members to a Collection, clients send POST requests to the URI
   of the Collection.

   Successful member creation is indicated with a 201 (&quot;Created&quot;)
   response code.  When the Collection responds with a status code of
   201, it SHOULD also return a response body, which MUST be an Atom
   Entry Document representing the newly created Resource.  Since the
   server is free to alter the POSTed Entry, for example, by changing
   the content of the atom:id element, returning the Entry can be useful
   to the client, enabling it to correlate the client and server views
   of the new Entry.

   When a Member Resource is created, its Member Entry URI MUST be
   returned in a Location header in the Collection's response. 

   If the creation request contained an Atom Entry Document, and the
   subsequent response from the server contains a Content-Location
   header that matches the Location header character-for-character, then
   the client is authorized to interpret the response entity as being a
   complete representation of the newly created Entry.  Without a
   matching Content-Location header, the client MUST NOT assume the
   returned entity is a complete representation of the created Resource.

   The request body sent with the POST need not be an Atom Entry.  For
   example, it might be a picture or a movie.  Collections MAY return a
   response with a status code of 415 (&quot;Unsupported Media Type&quot;) to
   indicate that the media type of the POSTed entity is not allowed or
   supported by the Collection.  For a discussion of the issues in
   creating such content, see &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;.</source>
          <target state="translated">컬렉션에 멤버를 추가하기 위해 클라이언트는 POST 요청을 컬렉션의 URI로 보냅니다. 성공적인 멤버 작성은 201 ( &quot;Created&quot;) 응답 코드로 표시됩니다. 컬렉션이 상태 코드 201로 응답하면 응답 본문을 반환해야합니다. 응답 본문은 반드시 새로 생성 된 리소스를 나타내는 Atom 항목 문서 여야합니다. 서버는 예를 들어 atom : id 요소의 내용을 변경하여 POST 된 항목을 자유롭게 변경할 수 있으므로 항목을 반환하면 클라이언트에 유용 할 수 있으므로 새 항목의 클라이언트와 서버보기를 상관시킬 수 있습니다. 멤버 리소스가 생성되면 멤버 엔트리 URI는 컬렉션 응답의 Location 헤더에 반환되어야합니다. 작성 요청에 Atom Entry Document가 포함 된 경우서버로부터의 후속 응답은 문자마다 문자의 위치 헤더와 일치하는 Content-Location 헤더를 포함하고, 클라이언트는 응답 엔티티를 새로 생성 된 엔트리의 완전한 표현으로 해석 할 수있다. 일치하는 Content-Location 헤더가 없으면 클라이언트는 반환 된 엔터티가 생성 된 리소스의 완전한 표현이라고 가정해서는 안됩니다 (MUST NOT). POST와 함께 전송 된 요청 본문은 Atom 항목 일 필요는 없습니다. 예를 들어 사진이나 영화 일 수 있습니다. 컬렉션은 상태 코드가 415 ( &quot;지원되지 않는 미디어 유형&quot;) 인 응답을 반환하여 POST 된 엔터티의 미디어 유형이 컬렉션에서 허용 또는 지원되지 않음을 나타냅니다. 이러한 컨텐츠 작성시 발생하는 문제에 대한 설명은보다보다그러면 클라이언트는 응답 엔터티를 새로 생성 된 항목의 완전한 표현으로 해석 할 수 있습니다. 일치하는 Content-Location 헤더가 없으면 클라이언트는 반환 된 엔터티가 생성 된 리소스의 완전한 표현이라고 가정해서는 안됩니다 (MUST NOT). POST와 함께 전송 된 요청 본문은 Atom 항목 일 필요는 없습니다. 예를 들어 사진이나 영화 일 수 있습니다. 컬렉션은 상태 코드가 415 ( &quot;지원되지 않는 미디어 유형&quot;) 인 응답을 반환하여 POST 된 엔터티의 미디어 유형이 컬렉션에서 허용 또는 지원되지 않음을 나타냅니다. 이러한 컨텐츠 작성시 발생하는 문제에 대한 설명은 다음을 참조하십시오.그러면 클라이언트는 응답 엔터티를 새로 생성 된 항목의 완전한 표현으로 해석 할 수 있습니다. 일치하는 Content-Location 헤더가 없으면 클라이언트는 반환 된 엔터티가 생성 된 리소스의 완전한 표현이라고 가정해서는 안됩니다 (MUST NOT). POST와 함께 전송 된 요청 본문은 Atom 항목 일 필요는 없습니다. 예를 들어 사진이나 영화 일 수 있습니다. 컬렉션은 상태 코드가 415 ( &quot;지원되지 않는 미디어 유형&quot;) 인 응답을 반환하여 POST 된 엔터티의 미디어 유형이 컬렉션에서 허용 또는 지원되지 않음을 나타냅니다. 이러한 컨텐츠 작성시 발생하는 문제에 대한 설명은 다음을 참조하십시오.클라이언트는 리턴 된 엔티티가 작성된 자원의 완전한 표현이라고 가정해서는 안됩니다 (MUST NOT). POST와 함께 전송 된 요청 본문은 Atom 항목 일 필요는 없습니다. 예를 들어 사진이나 영화 일 수 있습니다. 컬렉션은 상태 코드가 415 ( &quot;지원되지 않는 미디어 유형&quot;) 인 응답을 반환하여 POST 된 엔터티의 미디어 유형이 컬렉션에서 허용 또는 지원되지 않음을 나타냅니다. 이러한 컨텐츠 작성시 발생하는 문제에 대한 설명은 다음을 참조하십시오.클라이언트는 리턴 된 엔티티가 작성된 자원의 완전한 표현이라고 가정해서는 안됩니다 (MUST NOT). POST와 함께 전송 된 요청 본문은 Atom 항목 일 필요는 없습니다. 예를 들어 사진이나 영화 일 수 있습니다. 컬렉션은 상태 코드가 415 ( &quot;지원되지 않는 미디어 유형&quot;) 인 응답을 반환하여 POST 된 엔터티의 미디어 유형이 컬렉션에서 허용 또는 지원되지 않음을 나타냅니다. 이러한 컨텐츠 작성시 발생하는 문제에 대한 설명은)은 POSTed 엔티티의 미디어 유형이 콜렉션에서 허용되거나 지원되지 않음을 나타냅니다. 이러한 컨텐츠 작성시 발생하는 문제에 대한 설명은)은 POSTed 엔티티의 미디어 유형이 콜렉션에서 허용되거나 지원되지 않음을 나타냅니다. 이러한 컨텐츠 작성시 발생하는 문제에 대한 설명은&lt;a href=&quot;#section-9.6&quot;&gt;섹션 9.6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="386b4890041dd717ecf8b7b91609bc0b0530ef7e" translate="yes" xml:space="preserve">
          <source>To additionally expose a custom header, like &lt;code&gt;X-Kuma-Revision&lt;/code&gt;, you can specify multiple headers separated by a comma:</source>
          <target state="translated">&lt;code&gt;X-Kuma-Revision&lt;/code&gt; 과 같은 사용자 정의 헤더를 추가로 노출하려면 쉼표로 구분하여 여러 헤더를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a180bdbe7008f814531ba52754a31bdde24cb15f" translate="yes" xml:space="preserve">
          <source>To allow &lt;code&gt;https://developer.mozilla.org&lt;/code&gt; to see timing resources, you can specify:</source>
          <target state="translated">&lt;code&gt;https://developer.mozilla.org&lt;/code&gt; 에서 타이밍 리소스를 볼 수 있도록 다음을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac82a05a9215546227ac811284787b043b688757" translate="yes" xml:space="preserve">
          <source>To allow any resource to see timing resources:</source>
          <target state="translated">리소스가 타이밍 리소스를 볼 수있게하려면 :</target>
        </trans-unit>
        <trans-unit id="de9aa903d9e34061f0b89ba2ccd4efede6a71126" translate="yes" xml:space="preserve">
          <source>To allow any site to make CORS requests &lt;em&gt;without&lt;/em&gt; using the &lt;code&gt;*&lt;/code&gt; wildcard (for example, to enable credentials), your server must read the value of the request's &lt;code&gt;Origin&lt;/code&gt; header and use that value to set &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;, and must also set a &lt;code&gt;Vary: Origin&lt;/code&gt; header to indicate that some headers are being set dynamically depending on the origin.</source>
          <target state="translated">To allow any site to make CORS requests &lt;em&gt;without&lt;/em&gt; using the &lt;code&gt;*&lt;/code&gt; wildcard (for example, to enable credentials), your server must read the value of the request's &lt;code&gt;Origin&lt;/code&gt; header and use that value to set &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; , and must also set a &lt;code&gt;Vary: Origin&lt;/code&gt; header to indicate that some headers are being set dynamically depending on the origin.</target>
        </trans-unit>
        <trans-unit id="ed12e1286c2fe40563eb11b075acdb101da5456e" translate="yes" xml:space="preserve">
          <source>To allow inline scripts and inline event handlers, &lt;code&gt;'unsafe-inline'&lt;/code&gt;, a nonce-source or a hash-source that matches the inline block can be specified.</source>
          <target state="translated">인라인 스크립트 및 인라인 이벤트 핸들러를 허용하기 위해 &lt;code&gt;'unsafe-inline'&lt;/code&gt; , nonce-source 또는 인라인 블록과 일치하는 해시 소스를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0269ea1c1b256b968def48a5f2f52309ec5262a" translate="yes" xml:space="preserve">
          <source>To allow inline styles, &lt;code&gt;'unsafe-inline'&lt;/code&gt;, a nonce-source or a hash-source that matches the inline block can be specified.</source>
          <target state="translated">인라인 스타일을 허용하기 위해 &lt;code&gt;'unsafe-inline'&lt;/code&gt; , 인라인 블록과 일치하는 nonce-source 또는 hash-source를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13976356a231a259baf5887e2defcf39ece5cf88" translate="yes" xml:space="preserve">
          <source>To apply a redirect to a directory or only certain pages, use the &lt;code&gt;rewrite&lt;/code&gt; directive:</source>
          <target state="translated">To apply a redirect to a directory or only certain pages, use the &lt;code&gt;rewrite&lt;/code&gt; directive:</target>
        </trans-unit>
        <trans-unit id="baf2613fc6493f70145cca53cbfd72435e9e8e80" translate="yes" xml:space="preserve">
          <source>To apply a redirect to a folder or a subset of the pages only, use the &lt;code&gt;rewrite&lt;/code&gt; directive:</source>
          <target state="translated">폴더 또는 페이지의 하위 집합에만 리디렉션을 적용하려면 &lt;code&gt;rewrite&lt;/code&gt; 지시문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb7179c9bb0b7e4c55288f5bc188620cf66f5d11" translate="yes" xml:space="preserve">
          <source>To avoid breaking existing web content, the default for such policy-controlled features is to allow the functionality to be used by all origins. That is, the default allowlist is &lt;code&gt;'*'&lt;/code&gt; for each feature. Preventing the use of the sub-optimal functionality requires explicitly specifying a policy that disables the features.</source>
          <target state="translated">기존 웹 컨텐츠가 손상되는 것을 방지하기 위해 이러한 정책 제어 기능의 기본값은 모든 출처에서 기능을 사용할 수 있도록하는 것입니다. 즉, 기본 허용 목록은 각 기능에 대해 &lt;code&gt;'*'&lt;/code&gt; 입니다. 차선의 기능 사용을 방지하려면 기능을 사용하지 않도록 설정하는 정책을 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4241af7f93eeeca05ab65287e814f22f52b1e121" translate="yes" xml:space="preserve">
          <source>To avoid unnecessary requests and duplicated cache entries, caching servers should use &lt;strong&gt;normalization &lt;/strong&gt;to pre-process the request and cache only files that are needed. For example, in the case of &lt;code&gt;Accept-Encoding&lt;/code&gt; you could check for &lt;code&gt;gzip&lt;/code&gt; and other compression types in the header before doing further processing, and otherwise unset the header. In &quot;pseudo code&quot; this might look like:</source>
          <target state="translated">To avoid unnecessary requests and duplicated cache entries, caching servers should use &lt;strong&gt;normalization &lt;/strong&gt;to pre-process the request and cache only files that are needed. For example, in the case of &lt;code&gt;Accept-Encoding&lt;/code&gt; you could check for &lt;code&gt;gzip&lt;/code&gt; and other compression types in the header before doing further processing, and otherwise unset the header. In &quot;pseudo code&quot; this might look like:</target>
        </trans-unit>
        <trans-unit id="9aa4823e36d63b17b94087b674887608e0551a24" translate="yes" xml:space="preserve">
          <source>To configure Apache to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header for all pages, add this to your site's configuration:</source>
          <target state="translated">모든 페이지에 대해 &lt;code&gt;X-Frame-Options&lt;/code&gt; 헤더 를 보내도록 Apache를 구성하려면 다음을 사이트 구성에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ed88de8ec706b4b0a28b855a26786e3ee2a0c543" translate="yes" xml:space="preserve">
          <source>To configure Apache to set the &lt;code&gt;X-Frame-Options&lt;/code&gt; DENY, add this to your site's configuration:</source>
          <target state="translated">To configure Apache to set the &lt;code&gt;X-Frame-Options&lt;/code&gt; DENY, add this to your site's configuration:</target>
        </trans-unit>
        <trans-unit id="e80d381b0c7feec0a158d29c3338a640577b5bd0" translate="yes" xml:space="preserve">
          <source>To configure Apache to set the &lt;code&gt;X-Frame-Options&lt;/code&gt; deny , add this to your site's configuration:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; deny 를 설정하도록 Apache를 구성하려면 이를 사이트 구성에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b534ad3f3a442c64de937628acf24797af926fef" translate="yes" xml:space="preserve">
          <source>To configure Apache to set the &lt;code&gt;X-Frame-Options&lt;/code&gt; to &lt;code&gt;allow-from&lt;/code&gt; a specific Host , add this to your site's configuration:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; 를 특정 호스트 &lt;code&gt;allow-from&lt;/code&gt; 하도록 Apache를 구성하려면 이를 사이트 구성에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="c6efccd4af9ebeaf527c38eab55daa0481a50728" translate="yes" xml:space="preserve">
          <source>To configure Express to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, you can use &lt;a href=&quot;https://helmetjs.github.io/&quot;&gt;helmet&lt;/a&gt; which uses &lt;a href=&quot;https://helmetjs.github.io/docs/frameguard/&quot;&gt;frameguard&lt;/a&gt; to set the header. Add this to your server configuration:</source>
          <target state="translated">To configure Express to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, you can use &lt;a href=&quot;https://helmetjs.github.io/&quot;&gt;helmet&lt;/a&gt; which uses &lt;a href=&quot;https://helmetjs.github.io/docs/frameguard/&quot;&gt;frameguard&lt;/a&gt; to set the header. Add this to your server configuration:</target>
        </trans-unit>
        <trans-unit id="845c7d45d2e5670380ce094b42f8d93ca377f4d0" translate="yes" xml:space="preserve">
          <source>To configure HAProxy to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, add this to your front-end, listen, or backend configuration:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; 헤더 를 보내도록 HAProxy를 구성하려면 이를 프론트 엔드, 청취 또는 백엔드 구성에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d8ead758c64a8732b962f9c079ccbcb8977cec05" translate="yes" xml:space="preserve">
          <source>To configure IIS to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, add this to your site's &lt;code&gt;Web.config&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;X-Frame-Options&lt;/code&gt; 헤더 를 보내도록 IIS를 구성하려면 이를 사이트의 &lt;code&gt;Web.config&lt;/code&gt; 파일에 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="40d91183fa2ac507cab6f74e7d193a9cc7597506" translate="yes" xml:space="preserve">
          <source>To configure nginx to send the &lt;code&gt;X-Frame-Options&lt;/code&gt; header, add this either to your http, server or location configuration:</source>
          <target state="translated">Xgin &lt;code&gt;X-Frame-Options&lt;/code&gt; 헤더 를 보내도록 nginx를 구성하려면 http, 서버 또는 위치 구성에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f87ea35dcc44f41e60725e0641384c547d99d798" translate="yes" xml:space="preserve">
          <source>To correct this problem on the client side, simply ensure that the credentials flag's value is &lt;code&gt;false&lt;/code&gt; when issuing your CORS request.</source>
          <target state="translated">클라이언트 측에서이 문제점을 정정하려면 CORS 요청을 발행 할 때 신임 정보 플래그의 값이 &lt;code&gt;false&lt;/code&gt; 인지 확인 하십시오.</target>
        </trans-unit>
        <trans-unit id="d348d55722c44b500e4b7059e9ff9d2fa1dddb00" translate="yes" xml:space="preserve">
          <source>To delete a Member Resource, a client sends a DELETE request to its
   Member URI, as specified in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  The deletion of a Media Link
   Entry SHOULD result in the deletion of the corresponding Media
   Resource.</source>
          <target state="translated">구성원 자원을 삭제하기 위해 클라이언트는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]에 지정된대로 구성원 URI에 DELETE 요청을 보냅니다 . 미디어 링크 항목을 삭제하면 해당 미디어 리소스가 삭제되어야합니다 (SHOULD).</target>
        </trans-unit>
        <trans-unit id="72f4f993e89f8fbf65e0d29a84346e687a67b7ba" translate="yes" xml:space="preserve">
          <source>To disable caching of a resource, you can send the following response header:</source>
          <target state="translated">To disable caching of a resource, you can send the following response header:</target>
        </trans-unit>
        <trans-unit id="04d139058a76ad3d2cff70e2b313580511ed4b4b" translate="yes" xml:space="preserve">
          <source>To disallow all plugins, the &lt;a href=&quot;object-src&quot;&gt;&lt;code&gt;object-src&lt;/code&gt;&lt;/a&gt; directive should be set to &lt;code&gt;'none'&lt;/code&gt; which will disallow plugins. The &lt;code&gt;plugin-types&lt;/code&gt; directive is only used if you are allowing plugins with &lt;code&gt;object-src&lt;/code&gt; at all.</source>
          <target state="translated">모든 플러그인을 허용하지 않으려면 &lt;a href=&quot;object-src&quot;&gt; &lt;code&gt;object-src&lt;/code&gt; &lt;/a&gt; 지시문을 &lt;code&gt;'none'&lt;/code&gt; 으로 설정해야 플러그인을 허용하지 않습니다. &lt;code&gt;plugin-types&lt;/code&gt; 당신이 플러그인을 허용하는 경우 지시어에만 사용됩니다 &lt;code&gt;object-src&lt;/code&gt; 전혀합니다.</target>
        </trans-unit>
        <trans-unit id="92b682f994622384b1029f2cc2b8c3099145173c" translate="yes" xml:space="preserve">
          <source>To disallow http assets on a more granular level, you can also set individual directives to &quot;https:&quot;. For example, to disallow insecure http images:</source>
          <target state="translated">보다 세분화 된 수준에서 http 자산을 허용하지 않으려면 개별 지시문을 &quot;https :&quot;로 설정할 수도 있습니다. 예를 들어 안전하지 않은 http 이미지를 허용하지 않으려면 :</target>
        </trans-unit>
        <trans-unit id="a213397329a4dbbb753416e90e80c6286443a758" translate="yes" xml:space="preserve">
          <source>To disallow http assets on a more granular level, you can also set individual directives to &lt;code&gt;https:&lt;/code&gt;. For example, to disallow nonsecure HTTP images:</source>
          <target state="translated">To disallow http assets on a more granular level, you can also set individual directives to &lt;code&gt;https:&lt;/code&gt; . For example, to disallow nonsecure HTTP images:</target>
        </trans-unit>
        <trans-unit id="76414f91106f2a76e27289d53511ec4aff7ac9a8" translate="yes" xml:space="preserve">
          <source>To do this, HTTP uses a mechanism similar to the content negotiation for end-to-end compression: the node transmitting the request advertizes its will using the &lt;a href=&quot;headers/te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; header and the other node chooses the adequate method, applies it, and indicates its choice with the &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">이를 위해 HTTP는 엔드-투-엔드 압축을위한 컨텐츠 협상과 유사한 메커니즘을 사용합니다. 요청을 전송하는 노드는 &lt;a href=&quot;headers/te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; 헤더 를 사용하여 자신의 의지를 알리고 다른 노드는 적절한 방법을 선택하고 적용하며 &lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="2695ec4a2bbfc44084d656ae8935110af8816675" translate="yes" xml:space="preserve">
          <source>To ease deployment, CSP can be deployed in report-only mode. The policy is not enforced, but any violations are reported to a provided URI. Additionally, a report-only header can be used to test a future revision to a policy without actually deploying it.</source>
          <target state="translated">배포를 쉽게하기 위해 CSP를 보고서 전용 모드로 배포 할 수 있습니다. 정책은 시행되지 않지만 위반 사항은 제공된 URI에보고됩니다. 또한 보고서 전용 헤더를 사용하여 실제로 배포하지 않고 향후 정책 개정을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75b596875abd418e26e2741605ac5a556d421f5c" translate="yes" xml:space="preserve">
          <source>To edit a Member Resource, a client sends a PUT request to its Member
   URI, as specified in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].

   To avoid unintentional loss of data when editing Member Entries or
   Media Link Entries, an Atom Protocol client SHOULD preserve all
   metadata that has not been intentionally modified, including unknown
   foreign markup as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC4287]&lt;/a&gt;.</source>
          <target state="translated">멤버 자원을 편집하기 위해 클라이언트는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]에 지정된대로 PUT 요청을 멤버 URI에 보냅니다 . 멤버 항목 또는 미디어 링크 항목을 편집 할 때 의도하지 않은 데이터 손실을 방지하기 위해 Atom 프로토콜 클라이언트는 &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;[RFC4287]의 섹션 6에&lt;/a&gt; 정의 된 알 수없는 외부 마크 업을 포함하여 의도적으로 수정되지 않은 모든 메타 데이터를 보존해야합니다 .</target>
        </trans-unit>
        <trans-unit id="65a702b04aa6a54fd3c8430997ab1bc38d37ad8c" translate="yes" xml:space="preserve">
          <source>To eliminate this error by changing the server's configuration, adjust the server's configuration to set the &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; header's value to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">서버 구성을 변경하여이 오류를 제거하려면 서버 구성을 조정하여 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 헤더 값을 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfa8844d0259c7d70df5b60e696f31e2bbcd03c1" translate="yes" xml:space="preserve">
          <source>To enable CSP, you need to configure your web server to return the &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header (sometimes you will see mentions of the &lt;code&gt;X-Content-Security-Policy&lt;/code&gt; header, but that's an older version and you don't need to specify it anymore).</source>
          <target state="translated">CSP를 사용하려면 &lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; HTTP 헤더 를 반환하도록 웹 서버를 구성해야합니다 (때로는 &lt;code&gt;X-Content-Security-Policy&lt;/code&gt; 헤더에 대한 언급이 있지만 이전 버전 일 필요는 없음). 더 이상 지정하십시오).</target>
        </trans-unit>
        <trans-unit id="19b1b9201d67c0e13d81834b3ed7b51ae71bba12" translate="yes" xml:space="preserve">
          <source>To enable CSP, you need to configure your web server to return the &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header. (Sometimes you may see mentions of the &lt;code&gt;X-Content-Security-Policy&lt;/code&gt; header, but that's an older version and you don't need to specify it anymore.)</source>
          <target state="translated">To enable CSP, you need to configure your web server to return the &lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; HTTP header. (Sometimes you may see mentions of the &lt;code&gt;X-Content-Security-Policy&lt;/code&gt; header, but that's an older version and you don't need to specify it anymore.)</target>
        </trans-unit>
        <trans-unit id="e9df87dcc5fcb972c46f913809c87fec6f3d341b" translate="yes" xml:space="preserve">
          <source>To enable this feature for your site, you need to return the &lt;a href=&quot;headers/public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; HTTP header when your site is accessed over HTTPS:</source>
          <target state="translated">사이트에서이 기능을 사용하려면 HTTPS를 통해 사이트에 액세스 할 때 &lt;a href=&quot;headers/public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt; HTTP 헤더 를 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d7620e1e33a6d347685e1ebb3aa8b33714970a09" translate="yes" xml:space="preserve">
          <source>To ensure the authenticity of a server's public key used in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt; sessions, this public key is wrapped into a X.509 certificate which is usually signed by a certificate authority (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CA&quot;&gt;CA&lt;/a&gt;). Web clients such as browsers trust a lot of these CAs, which can all create certificates for arbitrary domain names. If an attacker is able to compromise a single CA, they can perform MITM attacks on various TLS connections. HPKP can circumvent this threat for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt; protocol by telling the client which public key belongs to a certain web server.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt; 세션 에서 사용되는 서버의 공개 키의 신뢰성을 보장하기 위해이 공개 키는 일반적으로 인증 기관 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CA&quot;&gt;CA&lt;/a&gt; )에 의해 서명 된 X.509 인증서로 래핑됩니다 . 브라우저와 같은 웹 클라이언트는 이러한 많은 CA를 신뢰하므로 임의의 도메인 이름에 대한 인증서를 만들 수 있습니다. 공격자가 단일 CA를 손상시킬 수 있으면 다양한 TLS 연결에서 MITM 공격을 수행 할 수 있습니다. HPKP는 클라이언트에게 특정 웹 서버에 속하는 공개 키를 알려줌으로써 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt; 프로토콜에 대한 이러한 위협을 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb1ec08765a8cde8081dbd27d2c650bba3f705fa" translate="yes" xml:space="preserve">
          <source>To expose a non-CORS-safelisted request header, you can specify:</source>
          <target state="translated">To expose a non-CORS-safelisted request header, you can specify:</target>
        </trans-unit>
        <trans-unit id="ee9c68887239fed95f26110a7e627ff78bd12cc1" translate="yes" xml:space="preserve">
          <source>To expose a non-simple response header, you can specify:</source>
          <target state="translated">단순하지 않은 응답 헤더를 표시하려면 다음을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c49b225b0a37fb347c33ef070bf2b8ce3177f370" translate="yes" xml:space="preserve">
          <source>To find out whether a server supports &lt;code&gt;PATCH&lt;/code&gt;, a server can advertise its support by adding it to the list in the &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; (for &lt;a href=&quot;../cors&quot;&gt;CORS&lt;/a&gt;) response headers.</source>
          <target state="translated">To find out whether a server supports &lt;code&gt;PATCH&lt;/code&gt; , a server can advertise its support by adding it to the list in the &lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; (for &lt;a href=&quot;../cors&quot;&gt;CORS&lt;/a&gt;) response headers.</target>
        </trans-unit>
        <trans-unit id="0114a346ce11f11d1f933758ffbbdf2f5442cd43" translate="yes" xml:space="preserve">
          <source>To find out whether a server supports &lt;code&gt;PATCH&lt;/code&gt;, a server can advertise its support by adding it to the list in the &lt;a href=&quot;../headers/allow&quot;&gt;&lt;code&gt;Allow&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; (for CORS) response headers.</source>
          <target state="translated">서버가 &lt;code&gt;PATCH&lt;/code&gt; 를 지원하는지 여부를 확인하기 위해 서버는 서버를 &lt;a href=&quot;../headers/allow&quot;&gt; &lt;code&gt;Allow&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; (CORS) 응답 헤더 의 목록에 추가하여 지원 을 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3e43c65e3e2914cd34ba18edec78bc17058b478" translate="yes" xml:space="preserve">
          <source>To find out which request methods a server supports, one can use curl and issue an OPTIONS request:</source>
          <target state="translated">서버가 지원하는 요청 방법을 찾으려면 curl을 사용하여 OPTIONS 요청을 발행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94a06678a04eb20207fc7bb6378a7dadaf3ba84d" translate="yes" xml:space="preserve">
          <source>To find out which request methods a server supports, one can use the &lt;code&gt;curl&lt;/code&gt; command-line program to issue an &lt;code&gt;OPTIONS&lt;/code&gt; request:</source>
          <target state="translated">To find out which request methods a server supports, one can use the &lt;code&gt;curl&lt;/code&gt; command-line program to issue an &lt;code&gt;OPTIONS&lt;/code&gt; request:</target>
        </trans-unit>
        <trans-unit id="0e18f6487121f857662c6a85c3a47051c59f1876" translate="yes" xml:space="preserve">
          <source>To fix the problem, update your code to use the new URL as reported by the redirect, thereby avoiding the redirect.</source>
          <target state="translated">문제를 해결하려면 리디렉션에서보고 한대로 새 URL을 사용하도록 코드를 업데이트하여 리디렉션을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="32dbd3b679bd14efe132327b76684a2c87a18ba4" translate="yes" xml:space="preserve">
          <source>To fix this problem on the client side, revise the code to not request the use of credentials.</source>
          <target state="translated">클라이언트 쪽에서이 문제를 해결하려면 자격 증명 사용을 요청하지 않도록 코드를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="35039835a23cd330912a1e328fb92250be4508c7" translate="yes" xml:space="preserve">
          <source>To fix this problem, simply make sure you use HTTPS URLs when issuing requests involving CORS, such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; APIs, Web Fonts (&lt;code&gt;@font-face&lt;/code&gt;), and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL&quot;&gt;WebGL textures&lt;/a&gt;, and XSL stylesheets.</source>
          <target state="translated">To fix this problem, simply make sure you use HTTPS URLs when issuing requests involving CORS, such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; APIs, Web Fonts ( &lt;code&gt;@font-face&lt;/code&gt; ), and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL&quot;&gt;WebGL textures&lt;/a&gt;, and XSL stylesheets.</target>
        </trans-unit>
        <trans-unit id="2617321bfe1280098dd397ad19ede4778814a0fc" translate="yes" xml:space="preserve">
          <source>To fix this problem, simply make sure you use HTTPS URLs when issuing requests involving CORS.</source>
          <target state="translated">이 문제점을 해결하려면 CORS와 관련된 요청을 발행 할 때 HTTPS URL을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="15680ede5ec99b5956f1bf553d855c87853f86ba" translate="yes" xml:space="preserve">
          <source>To have a server check the request's headers, a client must send &lt;a href=&quot;../headers/expect&quot;&gt;&lt;code&gt;Expect&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: 100-continue&lt;/code&gt; as a header in its initial request and receive a &lt;code&gt;100 Continue&lt;/code&gt; status code in response before sending the body.</source>
          <target state="translated">서버가 요청의 헤더를 확인하게하려면 클라이언트는 초기 요청에서 헤더로 &lt;a href=&quot;../headers/expect&quot;&gt; &lt;code&gt;Expect&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: 100-continue&lt;/code&gt; 를 보내고 본문을 보내기 전에 응답 으로 &lt;code&gt;100 Continue&lt;/code&gt; 상태 코드를 받아야합니다 .</target>
        </trans-unit>
        <trans-unit id="a8e97e24a55d2464483db3779fca7d3ac69353bb" translate="yes" xml:space="preserve">
          <source>To list the Members of a Collection, the client sends a GET request
   to the URI of a Collection.  An Atom Feed Document is returned whose
   Entries contain the IRIs of Member Resources.  The returned Feed may
   describe all, or only a partial list, of the Members in a Collection
   (see &lt;a href=&quot;#section-10&quot;&gt;Section 10&lt;/a&gt;).

   Client                          Server
     |                                |
     |  1.) GET to Collection URI     |
     |-------------------------------&amp;gt;|
     |                                |
     |  2.) 200 Ok                    |
     |      Atom Feed Document        |
     |&amp;lt;-------------------------------|
     |                                |

   1.  The client sends a GET request to the URI of the Collection.

   2.  The server responds with an Atom Feed Document containing the
       IRIs of the Collection Members.</source>
          <target state="translated">컬렉션의 멤버를 나열하기 위해 클라이언트는 GET 요청을 컬렉션의 URI로 보냅니다. 항목이 회원 자원의 IRI를 포함하는 Atom 피드 문서가 리턴됩니다. 반환 된 피드는 컬렉션의 멤버 전체 또는 일부만 설명 할 수 있습니다 ( &lt;a href=&quot;#section-10&quot;&gt;섹션 10&lt;/a&gt; 참조)). 클라이언트 서버 | | | 1.) 컬렉션 URI로 가져 오기 | | -------------------------------&amp;gt; | | | | 2.) 200 Ok | | 원자 공급 문서 | | &amp;lt;------------------------------- | | | 1. 클라이언트는 GET 요청을 Collection의 URI로 보냅니다. 2. 서버는 수집 멤버의 IRI를 포함하는 Atom Feed Document로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="40d4be7657f2f51d2de5be0cbaac7191b3c8a653" translate="yes" xml:space="preserve">
          <source>To load an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; you must specify &lt;code&gt;application/x-java-applet&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; 을로드하려면 &lt;code&gt;application/x-java-applet&lt;/code&gt; 을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8d201d9342cffef73d7a41bc9cba81a23914667e" translate="yes" xml:space="preserve">
          <source>To password-protect a directory on an Apache server, you will need a &lt;code&gt;.htaccess&lt;/code&gt; and a &lt;code&gt;.htpasswd&lt;/code&gt; file.</source>
          <target state="translated">Apache 서버에서 디렉토리를 비밀번호로 보호하려면 &lt;code&gt;.htaccess&lt;/code&gt; 및 &lt;code&gt;.htpasswd&lt;/code&gt; 파일 이 필요 합니다.</target>
        </trans-unit>
        <trans-unit id="2b1b9e12e5ed28875fdd87d9931a916a268928e4" translate="yes" xml:space="preserve">
          <source>To present a Web page, the browser sends an original request to fetch the HTML document from the page. It then parses this file, fetching additional requests corresponding to execution scripts, layout information (CSS) to display, and sub-resources contained within the page (usually images and videos). The Web browser then mixes these resources to present to the user a complete document, the Web page. Scripts executed by the browser can fetch more resources in later phases and the browser updates the Web page accordingly.</source>
          <target state="translated">웹 페이지를 표시하기 위해 브라우저는 원래 요청을 보내 페이지에서 HTML 문서를 가져옵니다. 그런 다음이 파일을 구문 분석하여 실행 스크립트, 표시 할 레이아웃 정보 (CSS) 및 페이지에 포함 된 하위 리소스 (일반적으로 이미지 및 비디오)에 해당하는 추가 요청을 가져옵니다. 그런 다음 웹 브라우저는 이러한 리소스를 혼합하여 사용자에게 완전한 문서 인 웹 페이지를 제공합니다. 브라우저가 실행 한 스크립트는 이후 단계에서 더 많은 리소스를 가져올 수 있으며 브라우저는 그에 따라 웹 페이지를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="9e60dfe4ac6141599165a832cd24e1d13bc8342c" translate="yes" xml:space="preserve">
          <source>To present a Web page, the browser sends an original request to fetch the HTML document that represents the page. It then parses this file, making additional requests corresponding to execution scripts, layout information (CSS) to display, and sub-resources contained within the page (usually images and videos). The Web browser then mixes these resources to present to the user a complete document, the Web page. Scripts executed by the browser can fetch more resources in later phases and the browser updates the Web page accordingly.</source>
          <target state="translated">To present a Web page, the browser sends an original request to fetch the HTML document that represents the page. It then parses this file, making additional requests corresponding to execution scripts, layout information (CSS) to display, and sub-resources contained within the page (usually images and videos). The Web browser then mixes these resources to present to the user a complete document, the Web page. Scripts executed by the browser can fetch more resources in later phases and the browser updates the Web page accordingly.</target>
        </trans-unit>
        <trans-unit id="bbc3791377cf289d3e10d82216c0c34f70d22305" translate="yes" xml:space="preserve">
          <source>To prevent cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;) attacks, &lt;code&gt;HttpOnly&lt;/code&gt; cookies are inaccessible to JavaScript's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt;&lt;code&gt;Document.cookie&lt;/code&gt;&lt;/a&gt; API; they are only sent to the server. For example, cookies that persist server-side sessions don't need to be available to JavaScript, and the &lt;code&gt;HttpOnly&lt;/code&gt; flag should be set.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt; (Cross-Site Scripting ) 공격 을 방지하기 위해 &lt;code&gt;HttpOnly&lt;/code&gt; 쿠키는 JavaScript의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt; &lt;code&gt;Document.cookie&lt;/code&gt; &lt;/a&gt; API에 액세스 할 수 없습니다 . 서버로만 전송됩니다. 예를 들어, 서버 측 세션을 유지하는 쿠키는 JavaScript에 사용할 필요가 없으며 &lt;code&gt;HttpOnly&lt;/code&gt; 플래그를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="72ede2114830d9b5c365d2af6457cc4237ba98cd" translate="yes" xml:space="preserve">
          <source>To prevent snooping and other privacy invasions, Web browsers enforce strict separation between Web sites. Only pages from the &lt;strong&gt;same origin&lt;/strong&gt; can access all the information of a Web page. Though such constraint is a burden to the server, HTTP headers can relax this strict separation on the server side, allowing a document to become a patchwork of information sourced from different domains; there could even be security-related reasons to do so.</source>
          <target state="translated">To prevent snooping and other privacy invasions, Web browsers enforce strict separation between Web sites. Only pages from the &lt;strong&gt;same origin&lt;/strong&gt; can access all the information of a Web page. Though such constraint is a burden to the server, HTTP headers can relax this strict separation on the server side, allowing a document to become a patchwork of information sourced from different domains; there could even be security-related reasons to do so.</target>
        </trans-unit>
        <trans-unit id="da58d84bcbf609daa347015eaf4c1596d9aec024" translate="yes" xml:space="preserve">
          <source>To prevent snooping and other privacy invasions, Web browsers enforce strict separation between Web sites. Only pages from the &lt;strong&gt;same origin&lt;/strong&gt; can access all the information of a Web page. Though such constraint is a burden to the server, HTTP headers can relax this strict separation server-side, allowing a document to become a patchwork of information sourced from different domains (there could even be security-related reasons to do so).</source>
          <target state="translated">스누핑 및 기타 개인 정보 침해를 방지하기 위해 웹 브라우저는 웹 사이트를 엄격하게 분리합니다. &lt;strong&gt;동일한 출처의&lt;/strong&gt; 페이지 만 웹 페이지의 모든 정보에 액세스 할 수 있습니다. 이러한 제한은 서버에 부담이되지만 HTTP 헤더는이 엄격한 분리 서버 측을 완화하여 문서가 다른 도메인에서 가져온 정보의 패치 워크가 될 수 있습니다 (보안 관련 이유도있을 수 있음).</target>
        </trans-unit>
        <trans-unit id="6fdb9fa15e3fd167189ceff75fae693acf53ca4b" translate="yes" xml:space="preserve">
          <source>To prevent this, conditional requests are used. For ranges, there are two ways of doing this. The more flexible one makes use of &lt;a href=&quot;headers/if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; and the server returns an error if the precondition fails; the client then restarts the download from the beginning:</source>
          <target state="translated">이를 방지하기 위해 조건부 요청이 사용됩니다. 범위의 경우 두 가지 방법이 있습니다. 보다 유연한 것은 &lt;a href=&quot;headers/if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; 를 사용&lt;/a&gt; 하며 전제 조건이 실패하면 서버가 오류를 리턴합니다. 그런 다음 클라이언트는 처음부터 다운로드를 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="51d6446ef1d59700324bbaf38bfb84d4a066a702" translate="yes" xml:space="preserve">
          <source>To prevent this, conditional requests are used. For ranges, there are two ways of doing this. The more flexible one makes use of &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; and the server returns an error if the precondition fails; the client then restarts the download from the beginning:</source>
          <target state="translated">To prevent this, conditional requests are used. For ranges, there are two ways of doing this. The more flexible one makes use of &lt;a href=&quot;headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; and the server returns an error if the precondition fails; the client then restarts the download from the beginning:</target>
        </trans-unit>
        <trans-unit id="8ae0931ca2f4a9bdada593d70fdcc9e0e5795272" translate="yes" xml:space="preserve">
          <source>To provide information about the proxy itself (not about the client connecting to it), the &lt;code&gt;Via&lt;/code&gt; header can be used.</source>
          <target state="translated">연결하는 클라이언트가 아닌 프록시 자체에 대한 정보를 제공하기 위해 &lt;code&gt;Via&lt;/code&gt; 헤더를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39f35e596ed723bf2514b5c1b49a714286137491" translate="yes" xml:space="preserve">
          <source>To request a mandatory upgrade to TLS&amp;mdash;that is, to upgrade and fail the connection if the upgrade is not successful&amp;mdash;your first request must be an &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request, like this:</source>
          <target state="translated">TLS 로의 필수 업그레이드를 요청하려면, 즉 업그레이드에 실패한 경우 연결을 업그레이드하고 실패하려면 첫 번째 요청은 다음 과 같은 &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; 요청 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="0ac4a6a255bea42439869af2e4020d47f12f5638" translate="yes" xml:space="preserve">
          <source>To see stored cookies (and other storage that a web page can use), you can enable the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector&quot;&gt;Storage Inspector&lt;/a&gt; in Developer Tools and select Cookies from the storage tree.</source>
          <target state="translated">저장된 쿠키 (및 웹 페이지에서 사용할 수있는 다른 스토리지)를 보려면 개발자 도구에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Storage_Inspector&quot;&gt;스토리지 검사기&lt;/a&gt; 를 활성화 하고 스토리지 트리에서 쿠키를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc330ab165d9d2700ffdde233d29f19baad1a79d" translate="yes" xml:space="preserve">
          <source>To select the algorithm to use, browsers and servers use &lt;a href=&quot;content_negotiation&quot;&gt;proactive content negotiation&lt;/a&gt;. The browser sends an &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt; header with the algorithm it supports and its order of precedence, the server picks one, uses it to compress the body of the response and uses the &lt;a href=&quot;headers/content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt; header to tell the browser the algorithm it has chosen. As content negotiation has been used to choose a representation based on its encoding, the server must send a &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; header containing at least &lt;a href=&quot;headers/accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt; alongside this header in the response; that way, caches will be able to cache the different representations of the resource.</source>
          <target state="translated">사용할 알고리즘을 선택하기 위해 브라우저 및 서버는 &lt;a href=&quot;content_negotiation&quot;&gt;사전 컨텐츠 협상을 사용&lt;/a&gt; 합니다. 브라우저는 지원하는 알고리즘과 우선 순위 순서로 서버 가 &lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt; 헤더를 전송합니다 . 서버는이를 선택하고 응답 본문을 압축하는 데이를 사용하고 &lt;a href=&quot;headers/content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt; 헤더를 사용하여 브라우저에 선택한 알고리즘을 알려줍니다. 컨텐츠 협상이 인코딩을 기반으로 표현을 선택하는 데 사용되었으므로 서버는 응답에서이 헤더와 함께 &lt;a href=&quot;headers/accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; 을&lt;/a&gt; 포함 하는 &lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; 헤더를 보내야합니다 . 이런 식으로 캐시는 리소스의 다른 표현을 캐시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="634a9fb6a29c3c70ac67df06d1d205bf0ae96039" translate="yes" xml:space="preserve">
          <source>To set allowed types for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt;&lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt;&lt;/a&gt; elements, use the &lt;a href=&quot;plugin-types&quot;&gt;&lt;code&gt;plugin-types&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object&quot;&gt; &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed&quot;&gt; &lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet&quot;&gt; &lt;code&gt;&amp;lt;applet&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소에 허용되는 유형을 설정하려면 &lt;a href=&quot;plugin-types&quot;&gt; &lt;code&gt;plugin-types&lt;/code&gt; &lt;/a&gt; 지시문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1df8505922402bf519c64877c4fe5b468a0d15a0" translate="yes" xml:space="preserve">
          <source>To turn off caching, you can send the following response header. In addition, see also the &lt;code&gt;Expires&lt;/code&gt; and &lt;code&gt;Pragma&lt;/code&gt; headers.</source>
          <target state="translated">캐싱을 끄려면 다음 응답 헤더를 보낼 수 있습니다. 또한 &lt;code&gt;Expires&lt;/code&gt; 및 &lt;code&gt;Pragma&lt;/code&gt; 헤더 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd73224596457324eeb7f6a3787968a990efcb06" translate="yes" xml:space="preserve">
          <source>To turn on the enforcement of all the best practices, specify the policy as below.</source>
          <target state="translated">모든 모범 사례를 시행하려면 다음과 같이 정책을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="e986abf32e5ea3dcadc05857dd5f7dc3d3e31912" translate="yes" xml:space="preserve">
          <source>To understand the underlying issue with the CORS configuration, you need to find out which request is at fault and why. These steps may help you do so:</source>
          <target state="translated">CORS 구성의 기본 문제를 이해하려면 결함이있는 요청과 이유를 찾아야합니다. 다음 단계는 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5de27ea55a3c3a2648dd523ae819b4dad29f351" translate="yes" xml:space="preserve">
          <source>To upgrade to TLS optionally (that is, allowing the connection to continue in cleartext if the upgrade to TLS fails), you simply use the &lt;code&gt;Upgrade&lt;/code&gt; and &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; headers as expected. For example, given the original request:</source>
          <target state="translated">선택적으로 TLS로 업그레이드하려면 (즉, TLS 로의 업그레이드가 실패 할 경우 연결을 일반 텍스트로 계속 허용) &lt;code&gt;Upgrade&lt;/code&gt; 및 &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 헤더를 예상대로 사용하면 됩니다. 예를 들어, 원래 요청이 제공된 경우 :</target>
        </trans-unit>
        <trans-unit id="044deb9959ba1185df13d8adce29060324260efa" translate="yes" xml:space="preserve">
          <source>Today, every HTTP/1.1-compliant proxy and server should support pipelining, though many have limitations in practice: a significant reason no modern browser activates this feature by default.</source>
          <target state="translated">오늘날 모든 HTTP / 1.1 호환 프록시 및 서버는 파이프 라이닝을 지원해야하지만 실제로는 많은 제한이 있습니다. 최신 브라우저가 기본적으로이 기능을 활성화하지 않는 중요한 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="33aad73dfe686c313271fd5a3616235aaa85ae94" translate="yes" xml:space="preserve">
          <source>Together with the resource, the validators are sent in the headers. In this example, both &lt;a href=&quot;headers/last-modified&quot;&gt;&lt;code&gt;Last-Modified&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt; are sent, but it could equally have been only one of them. These validators are cached with the resource (like all headers) and will be used to craft conditional requests, once the cache becomes stale.</source>
          <target state="translated">리소스와 함께 유효성 검사기는 헤더로 전송됩니다. 이 예에서는 &lt;a href=&quot;headers/last-modified&quot;&gt; &lt;code&gt;Last-Modified&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;headers/etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; 가 모두 전송되지만 둘 중 하나 일뿐입니다. 이 유효성 검사기는 모든 헤더와 같이 리소스와 함께 캐시되며 캐시가 오래되면 조건부 요청을 작성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0525ab49d332c5db40375b0a9f6ea89615d60e2c" translate="yes" xml:space="preserve">
          <source>Tools &amp;amp; resources</source>
          <target state="translated">도구 및 리소스</target>
        </trans-unit>
        <trans-unit id="b9ddad26522153eb9872297e87c93c799247f043" translate="yes" xml:space="preserve">
          <source>Tools to check your cache-related headers</source>
          <target state="translated">캐시 관련 헤더를 확인하는 도구</target>
        </trans-unit>
        <trans-unit id="7b5272923a452bc32a23884c3fe28dc343ef4efe" translate="yes" xml:space="preserve">
          <source>Top-level navigation blocked to data:// URIs</source>
          <target state="translated">data : // URI로 차단 된 최상위 탐색</target>
        </trans-unit>
        <trans-unit id="e81a151bd05091f9935dc3aba219eed346e7bb4f" translate="yes" xml:space="preserve">
          <source>Tracking</source>
          <target state="translated">Tracking</target>
        </trans-unit>
        <trans-unit id="5dcb619778c5a48fbe9ce0ea8e4e07da0e9aea7d" translate="yes" xml:space="preserve">
          <source>Tracking Preference Expression</source>
          <target state="translated">선호 사항 추적</target>
        </trans-unit>
        <trans-unit id="2af5d6ecb9eb76a6bccbc8c68b541e6b6b396809" translate="yes" xml:space="preserve">
          <source>Tracking Preference Expression (DNT)&lt;br/&gt;&lt;small&gt;The definition of 'DNT Header Field for HTTP Requests' in that specification.&lt;/small&gt;</source>
          <target state="translated">DNT (Tracking Preference Expression) &lt;br/&gt;&lt;small&gt;해당 사양에서 'HTTP 요청에 대한 DNT 헤더 필드'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="84aa830d1d5897f6ae5f7fca1156da8d8706f8cb" translate="yes" xml:space="preserve">
          <source>Tracking Preference Expression (DNT)&lt;br/&gt;&lt;small&gt;The definition of 'Tk header field' in that specification.&lt;/small&gt;</source>
          <target state="translated">추적 기본 설정 표현식 (DNT) &lt;br/&gt;&lt;small&gt;해당 사양에서 'Tk 헤더 필드'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="d37a3197e485b933cb995fe9c9d3f25f9de908c0" translate="yes" xml:space="preserve">
          <source>Tracking and privacy</source>
          <target state="translated">추적 및 개인 정보</target>
        </trans-unit>
        <trans-unit id="8e5bd5bfa384bf004de3147d61aadd3993d2c684" translate="yes" xml:space="preserve">
          <source>Tracking with consent. The origin server believes it has received prior consent for tracking this user, user agent, or device.</source>
          <target state="translated">동의 추적 오리진 서버는이 사용자, 사용자 에이전트 또는 장치 추적에 대한 사전 동의를 받았다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="a58efd8405db46a290d75d073d8104640ac8bf79" translate="yes" xml:space="preserve">
          <source>Tracking.</source>
          <target state="translated">Tracking.</target>
        </trans-unit>
        <trans-unit id="26013bccba39d56f3505ecd08b5aabdc74ef7701" translate="yes" xml:space="preserve">
          <source>Trailer</source>
          <target state="translated">Trailer</target>
        </trans-unit>
        <trans-unit id="2f8c965a489badb0e16d07f424592d1f9df923ab" translate="yes" xml:space="preserve">
          <source>Trailer (RFC 2616)</source>
          <target state="translated">트레일러 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="77a56b4b0d25c8ae802cf40ac536850a7797b43e" translate="yes" xml:space="preserve">
          <source>Transfer Codings (RFC 7230)</source>
          <target state="translated">전송 코딩 (RFC 7230)</target>
        </trans-unit>
        <trans-unit id="70841a225420fbcb24be7613367795a906d292c9" translate="yes" xml:space="preserve">
          <source>Transfer coding</source>
          <target state="translated">전송 코딩</target>
        </trans-unit>
        <trans-unit id="7ebdaa3f3a4520281b97e02b5d2f54005ba580f8" translate="yes" xml:space="preserve">
          <source>Transfer coding names are used to indicate an encoding transformation
   that has been, can be, or might need to be applied to a payload body
   in order to ensure &quot;safe transport&quot; through the network.  This
   differs from a content coding in that the transfer coding is a
   property of the message rather than a property of the representation
   that is being transferred.

     transfer-coding    = &quot;chunked&quot; ; &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;
                        / &quot;compress&quot; ; &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;
                        / &quot;deflate&quot; ; &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;
                        / &quot;gzip&quot; ; &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;
                        / transfer-extension
     transfer-extension = token *( OWS &quot;;&quot; OWS transfer-parameter )

   Parameters are in the form of a name or name=value pair.

     transfer-parameter = token BWS &quot;=&quot; BWS ( token / quoted-string )

   All transfer-coding names are case-insensitive and ought to be
   registered within the HTTP Transfer Coding registry, as defined in
   &lt;a href=&quot;#section-8.4&quot;&gt;Section 8.4&lt;/a&gt;.  They are used in the TE (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) and
   Transfer-Encoding (&lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt;) header fields.</source>
          <target state="translated">전송 코딩 이름은 네트워크를 통한 &quot;안전한 전송&quot;을 보장하기 위해 페이로드 바디에 적용되었거나 페이로드 바디에 적용될 수있는 인코딩 변환을 나타내는 데 사용됩니다. 이는 전송 코딩이 전송되는 표현의 속성이 아니라 메시지의 속성이라는 점에서 콘텐츠 코딩과 다르다. 전송 코딩 = &quot;청크&quot;; &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt; / &quot;압축&quot;; &lt;a href=&quot;#section-4.2.1&quot;&gt;섹션 4.2.1&lt;/a&gt; / &quot;delate&quot;; &lt;a href=&quot;#section-4.2.2&quot;&gt;섹션 4.2.2&lt;/a&gt; / &quot;gzip&quot;; &lt;a href=&quot;#section-4.2.3&quot;&gt;섹션 4.2.3&lt;/a&gt; / transfer-extension transfer-extension = token * (OWS &quot;;&quot;OWS transfer-parameter) 매개 변수는 이름 또는 이름 = 값 쌍의 형식입니다. transfer-parameter = token BWS &quot;=&quot;BWS (token / quoted-string) 모든 전송 코딩 이름은 대소 문자를 구분하지 않으며 &lt;a href=&quot;#section-8.4&quot;&gt;8.4 절에&lt;/a&gt; 정의 된 HTTP 전송 코딩 레지스트리에 등록해야합니다 . TE ( &lt;a href=&quot;#section-4.3&quot;&gt;4.3 절&lt;/a&gt; ) 및 전송 인코딩 ( &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1 절&lt;/a&gt; ) 헤더 필드에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4d8b97a685db2fa279df1bb0d54e0fdc0c9f8bb5" translate="yes" xml:space="preserve">
          <source>Transfer-Encoding</source>
          <target state="translated">Transfer-Encoding</target>
        </trans-unit>
        <trans-unit id="4626d4537fdc031b31ab03445f507eb645f0b745" translate="yes" xml:space="preserve">
          <source>Transfer-Encoding (RFC 2616)</source>
          <target state="translated">전송 인코딩 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="af30d73f2f27d92a78211f034fdce80b11f12b01" translate="yes" xml:space="preserve">
          <source>Transfer-coding values are used to indicate an encoding
   transformation that has been, can be, or may need to be applied to an
   entity-body in order to ensure &quot;safe transport&quot; through the network.
   This differs from a content coding in that the transfer-coding is a
   property of the message, not of the original entity.

       transfer-coding         = &quot;chunked&quot; | transfer-extension
       transfer-extension      = token *( &quot;;&quot; parameter )

   Parameters are in  the form of attribute/value pairs.

       parameter               = attribute &quot;=&quot; value
       attribute               = token
       value                   = token | quoted-string

   All transfer-coding values are case-insensitive. HTTP/1.1 uses
   transfer-coding values in the TE header field (&lt;a href=&quot;#section-14.39&quot;&gt;section 14.39&lt;/a&gt;) and in
   the Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section 14.41&lt;/a&gt;).

   Whenever a transfer-coding is applied to a message-body, the set of
   transfer-codings MUST include &quot;chunked&quot;, unless the message is
   terminated by closing the connection. When the &quot;chunked&quot; transfer-
   coding is used, it MUST be the last transfer-coding applied to the
   message-body. The &quot;chunked&quot; transfer-coding MUST NOT be applied more
   than once to a message-body. These rules allow the recipient to
   determine the transfer-length of the message (&lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;).

   Transfer-codings are analogous to the Content-Transfer-Encoding
   values of MIME [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;], which were designed to enable safe transport of
   binary data over a 7-bit transport service. However, safe transport
   has a different focus for an 8bit-clean transfer protocol. In HTTP,
   the only unsafe characteristic of message-bodies is the difficulty in
   determining the exact body length (&lt;a href=&quot;#section-7.2.2&quot;&gt;section 7.2.2&lt;/a&gt;), or the desire to
   encrypt data over a shared transport. 

   The Internet Assigned Numbers Authority (IANA) acts as a registry for
   transfer-coding value tokens. Initially, the registry contains the
   following tokens: &quot;chunked&quot; (&lt;a href=&quot;#section-3.6.1&quot;&gt;section 3.6.1&lt;/a&gt;), &quot;identity&quot; (&lt;a href=&quot;#section-3.6.2&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-3.6.2&quot;&gt;3.6.2&lt;/a&gt;), &quot;gzip&quot; (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;), &quot;compress&quot; (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;), and &quot;deflate&quot;
   (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;).

   New transfer-coding value tokens SHOULD be registered in the same way
   as new content-coding value tokens (&lt;a href=&quot;#section-3.5&quot;&gt;section 3.5&lt;/a&gt;).

   A server which receives an entity-body with a transfer-coding it does
   not understand SHOULD return 501 (Unimplemented), and close the
   connection. A server MUST NOT send transfer-codings to an HTTP/1.0
   client.</source>
          <target state="translated">전송 코딩 값은 네트워크를 통한 &quot;안전한 전송&quot;을 보장하기 위해 엔터티 본문에 적용되었거나 적용될 수있는 인코딩 변환을 나타내는 데 사용됩니다. 이는 전송 코딩이 원래 엔티티가 아니라 메시지의 속성이라는 점에서 콘텐츠 코딩과 다릅니다. 전송 코딩 = &quot;청크&quot;| transfer-extension transfer-extension = token * ( &quot;;&quot;parameter) 매개 변수는 속성 / 값 쌍의 형식입니다. 매개 변수 = 속성 &quot;=&quot;값 속성 = 토큰 값 = 토큰 | 인용 문자열 모든 전송 코딩 값은 대소 문자를 구분합니다. HTTP / 1.1은 TE 헤더 필드에서 전송 코딩 값을 사용합니다 ( &lt;a href=&quot;#section-14.39&quot;&gt;섹션 14.39).&lt;/a&gt;) 및 Transfer-Encoding 헤더 필드 ( &lt;a href=&quot;#section-14.41&quot;&gt;섹션 14.41&lt;/a&gt; )에 있습니다. 전송 코드가 메시지 본문에 적용될 때마다 연결을 닫아서 메시지가 종료되지 않는 한 전송 코드 세트에는 반드시 &quot;청크&quot;가 포함되어야합니다. &quot;청크 된&quot;전송 코딩이 사용될 때, 이것은 메시지 본문에 적용된 마지막 전송 코딩이어야한다. &quot;청크 된&quot;전송 코딩은 메시지 본문에 두 번 이상 적용되어서는 안됩니다 (MUST NOT). 이 규칙을 통해 수신자는 메시지의 전송 길이를 결정할 수 있습니다 ( &lt;a href=&quot;#section-4.4&quot;&gt;섹션 4.4&lt;/a&gt; ). 전송 코딩은 MIME의 콘텐츠 전송 인코딩 값과 유사하다 [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;], 7 비트 전송 서비스를 통해 이진 데이터를 안전하게 전송하도록 설계되었습니다. 그러나 안전한 전송에는 8 비트 클린 전송 프로토콜에 대한 초점이 다릅니다. HTTP에서 메시지 본문의 안전하지 않은 특징은 정확한 본문 길이 ( &lt;a href=&quot;#section-7.2.2&quot;&gt;7.2.2 절&lt;/a&gt; ) 를 결정하기가 어렵 거나 공유 전송을 통해 데이터를 암호화하려는 욕구입니다. IANA (Internet Assigned Numbers Authority)는 전송 코딩 가치 토큰의 레지스트리 역할을합니다. 처음에는 레지스트리에 &quot;chunked&quot;( &lt;a href=&quot;#section-3.6.1&quot;&gt;섹션 3.6.1&lt;/a&gt; ), &quot;identity&quot;( &lt;a href=&quot;#section-3.6.2&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-3.6.2&quot;&gt;3.6.2&lt;/a&gt; ), &quot;gzip&quot;( &lt;a href=&quot;#section-3.5&quot;&gt;섹션 3.5&lt;/a&gt; ), &quot;compress&quot;( &lt;a href=&quot;#section-3.5&quot;&gt;섹션 3.5&lt;/a&gt; ) 및 &quot;deflate&quot; 토큰이 포함됩니다.( &lt;a href=&quot;#section-3.5&quot;&gt;섹션 3.5&lt;/a&gt;). 새로운 전송 코딩 가치 토큰은 새로운 콘텐츠 코딩 가치 토큰과 같은 방식으로 등록되어야한다 ( &lt;a href=&quot;#section-3.5&quot;&gt;섹션 3.5&lt;/a&gt; ). 전송 코딩이있는 엔터티 본문을받는 서버는 501 반환 (구현되지 않음)을 이해하지 못하고 연결을 닫습니다. 서버는 전송 코딩을 HTTP / 1.0 클라이언트에 보내서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="8f06d2432c28b1a1b63093c7243e8fc4296b2052" translate="yes" xml:space="preserve">
          <source>Transformation Applied</source>
          <target state="translated">적용되는 변환</target>
        </trans-unit>
        <trans-unit id="0333efced7aed7a62393f804f6f0a1fac69384cf" translate="yes" xml:space="preserve">
          <source>Transitioning from &lt;code&gt;X-Forwarded-For&lt;/code&gt; to &lt;code&gt;Forwarded&lt;/code&gt;</source>
          <target state="translated">에서 전환 &lt;code&gt;X-Forwarded-For&lt;/code&gt; 에 &lt;code&gt;Forwarded&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01d5987738fe39dbda22e95b91e209136e267709" translate="yes" xml:space="preserve">
          <source>Transparent negotiation is a combination of both server-driven and
   agent-driven negotiation. When a cache is supplied with a form of the
   list of available representations of the response (as in agent-driven
   negotiation) and the dimensions of variance are completely understood
   by the cache, then the cache becomes capable of performing server-
   driven negotiation on behalf of the origin server for subsequent
   requests on that resource.

   Transparent negotiation has the advantage of distributing the
   negotiation work that would otherwise be required of the origin
   server and also removing the second request delay of agent-driven
   negotiation when the cache is able to correctly guess the right
   response.

   This specification does not define any mechanism for transparent
   negotiation, though it also does not prevent any such mechanism from
   being developed as an extension that could be used within HTTP/1.1.</source>
          <target state="translated">투명한 협상은 서버 중심 및 에이전트 중심 협상의 조합입니다. 캐시에 사용 가능한 응답 표현 목록 형식 (에이전트 중심 협상에서와 같이)이 제공되고 분산 차원이 캐시에 의해 완전히 이해되면 캐시가 대신 서버 구동 협상을 수행 할 수있게됩니다. 해당 자원에 대한 후속 요청에 대한 오리진 서버 투명한 협상은 원래 서버에 필요한 협상 작업을 분배하고 캐시가 올바른 응답을 올바르게 추측 할 수있을 때 에이전트 중심 협상의 두 번째 요청 지연을 제거 할 수 있다는 이점이 있습니다. 이 사양은 투명한 협상을위한 메커니즘을 정의하지 않습니다.HTTP / 1.1에서 사용할 수있는 확장으로 이러한 메커니즘이 개발되는 것을 막지는 못합니다.</target>
        </trans-unit>
        <trans-unit id="78b9ce3dc78962972447ca0b6f58074fd970dfbb" translate="yes" xml:space="preserve">
          <source>Transport Layer Security (TLS) Application-Layer Protocol Negotiation Extension</source>
          <target state="translated">TLS (Transport Layer Security) 응용 프로그램 계층 프로토콜 협상 확장</target>
        </trans-unit>
        <trans-unit id="dfd6efe315d54c8cdd2adc5afbb8872f6a336102" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;SameSite=None&lt;/code&gt; and invalid values as &lt;code&gt;Strict&lt;/code&gt; in iOS before 13. See &lt;a href=&quot;https://webkit.org/b/198181&quot;&gt;bug 198181&lt;/a&gt;.</source>
          <target state="translated">Treats &lt;code&gt;SameSite=None&lt;/code&gt; and invalid values as &lt;code&gt;Strict&lt;/code&gt; in iOS before 13. See &lt;a href=&quot;https://webkit.org/b/198181&quot;&gt;bug 198181&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7b08ea38352dc45d4d989417f6fef8d6f90e693b" translate="yes" xml:space="preserve">
          <source>Treats &lt;code&gt;SameSite=None&lt;/code&gt; and invalid values as &lt;code&gt;Strict&lt;/code&gt; in macOS before 10.15 Catalina. See &lt;a href=&quot;https://webkit.org/b/198181&quot;&gt;bug 198181&lt;/a&gt;.</source>
          <target state="translated">Treats &lt;code&gt;SameSite=None&lt;/code&gt; and invalid values as &lt;code&gt;Strict&lt;/code&gt; in macOS before 10.15 Catalina. See &lt;a href=&quot;https://webkit.org/b/198181&quot;&gt;bug 198181&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="323f99b9a56b4b45411c566426be7157525a2168" translate="yes" xml:space="preserve">
          <source>Trident</source>
          <target state="translated">Trident</target>
        </trans-unit>
        <trans-unit id="ca3606ead865c2815a13e76d1b25c992f4f3c6f9" translate="yes" xml:space="preserve">
          <source>Trident/7.0; .*rv:xyz &lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target state="translated">Trident/7.0; .*rv:xyz &lt;sup&gt;[2]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="c266c97b59663994c186c4ed953693b711755a83" translate="yes" xml:space="preserve">
          <source>Trident/xyz</source>
          <target state="translated">Trident/xyz</target>
        </trans-unit>
        <trans-unit id="ea2c9903532f8ca9b9bfd8b8e86bf77e287eda98" translate="yes" xml:space="preserve">
          <source>Tries to resolve the hostname. Returns true if succeeds.</source>
          <target state="translated">호스트 이름을 확인하려고합니다. 성공하면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0ad2653fb337835a830a479f5211338052b81788" translate="yes" xml:space="preserve">
          <source>Troubleshooting HTTP 405</source>
          <target state="translated">Troubleshooting HTTP 405</target>
        </trans-unit>
        <trans-unit id="9b5aeb48bb5b3f47bc91e7f66bbbde649d99b8a5" translate="yes" xml:space="preserve">
          <source>Troubleshooting errors</source>
          <target state="translated">오류 해결</target>
        </trans-unit>
        <trans-unit id="6e7d676a3f4acf661dbd32eb846f4d30d45c42b9" translate="yes" xml:space="preserve">
          <source>True if and only if the IP address of the host matches the specified IP address pattern.</source>
          <target state="translated">호스트의 IP 주소가 지정된 IP 주소 패턴과 일치하는 경우에만 true입니다.</target>
        </trans-unit>
        <trans-unit id="853354f33edc8bdc875b21e01f674d1cc985ac56" translate="yes" xml:space="preserve">
          <source>True if and only if there is no domain name in the hostname (no dots).</source>
          <target state="translated">호스트 이름에 도메인 이름이없는 경우에만 적용됩니다 (점 없음).</target>
        </trans-unit>
        <trans-unit id="40b3edf718ee234d3ed60de8590b0eab146b9f6b" translate="yes" xml:space="preserve">
          <source>TrueType Font</source>
          <target state="translated">트루 타입 글꼴</target>
        </trans-unit>
        <trans-unit id="deed064463d5fe6a9b6de90de79e1d7bc5664ed3" translate="yes" xml:space="preserve">
          <source>Trying to access an &lt;code&gt;http&lt;/code&gt; resource from a page with an &lt;code&gt;https&lt;/code&gt; origin will also cause this error.</source>
          <target state="translated">Trying to access an &lt;code&gt;http&lt;/code&gt; resource from a page with an &lt;code&gt;https&lt;/code&gt; origin will also cause this error.</target>
        </trans-unit>
        <trans-unit id="1ecb3021f84a92249f81d93e6449bc294633f5a4" translate="yes" xml:space="preserve">
          <source>Trying to access an &lt;code&gt;https&lt;/code&gt; resource that has an invalid certificate will cause this error.</source>
          <target state="translated">Trying to access an &lt;code&gt;https&lt;/code&gt; resource that has an invalid certificate will cause this error.</target>
        </trans-unit>
        <trans-unit id="cb7dd9fead5f39240201ca09db25e60a206fb473" translate="yes" xml:space="preserve">
          <source>Trying to use a &lt;a href=&quot;../../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; request will fail with this error.</source>
          <target state="translated">&lt;a href=&quot;../../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 요청 을 사용하려고하면 이 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="91efe823a9a6e3fb633db6d257efcabfa7cfb34a" translate="yes" xml:space="preserve">
          <source>Tunneling transmits private network data and protocol information through public network by encapsulating the data. HTTP tunneling is using a protocol of higher level (HTTP) to transport a lower level protocol (TCP).</source>
          <target state="translated">터널링은 데이터를 캡슐화하여 공용 네트워크를 통해 개인 네트워크 데이터 및 프로토콜 정보를 전송합니다. HTTP 터널링은 상위 레벨 (HTTP) 프로토콜을 사용하여 하위 레벨 프로토콜 (TCP)을 전송합니다.</target>
        </trans-unit>
        <trans-unit id="e28a72d2f72f9e470a9c017ef73151d89a57b9b9" translate="yes" xml:space="preserve">
          <source>Turning on and off prefetching</source>
          <target state="translated">프리 페치 켜기 및 끄기</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="2b805468035d4d32817647d90742c71d232cc025" translate="yes" xml:space="preserve">
          <source>Two header fields are used for carrying authentication credentials,
   as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt;].  Note that various custom mechanisms for
   user authentication use the Cookie header field for this purpose, as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt;].

   +---------------------+--------------------------+
   | Header Field Name   | Defined in...            |
   +---------------------+--------------------------+
   | Authorization       | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7235]&lt;/a&gt; |
   | Proxy-Authorization | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7235]&lt;/a&gt; |
   +---------------------+--------------------------+</source>
          <target state="translated">[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC7235&lt;/a&gt; ]에 정의 된 인증 자격 증명을 전달하는 데 두 개의 헤더 필드가 사용됩니다 . 사용자 인증을위한 다양한 사용자 지정 메커니즘은 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC6265&lt;/a&gt; ]에 정의 된대로 쿠키 헤더 필드를이 목적으로 사용합니다 . + --------------------- + -------------------------- + | 헤더 필드 이름 | 정의 ... | + --------------------- + -------------------------- + | 인증 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.2&quot;&gt;[RFC7235] 4.2 절&lt;/a&gt; | | 프록시 인증 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7235#section-4.4&quot;&gt;[RFC7235] 4.4 절&lt;/a&gt; | + --------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="ce0195a6ae48268edebd5bad672073160522c130" translate="yes" xml:space="preserve">
          <source>Two newer models were created in HTTP/1.1. The persistent-connection model keeps connections opened between successive requests, reducing the time needed to open new connections. The HTTP pipelining model goes one step further, by sending several successive requests without even waiting for an answer, reducing much of the latency in the network.</source>
          <target state="translated">HTTP / 1.1에서 두 가지 새로운 모델이 생성되었습니다. 지속적 연결 모델은 연속적인 요청간에 연결을 열어 놓아 새 연결을 여는 데 필요한 시간을 줄입니다. HTTP 파이프 라이닝 모델은 응답을 기다리지 않고도 여러 개의 연속 요청을 보내 네트워크의 대기 시간을 크게 줄임으로써 한 단계 더 발전했습니다.</target>
        </trans-unit>
        <trans-unit id="a6b6a2cb2500b00f4598bac08b45cc08135ddf62" translate="yes" xml:space="preserve">
          <source>Two others content encoding, &lt;code&gt;bzip&lt;/code&gt; and &lt;code&gt;bzip2&lt;/code&gt;, are sometimes used, though not standard. They implement the algorithm used by these two UNIX programs. Note that the first one was discontinued due to patent licensing problems.</source>
          <target state="translated">다른 두 가지 컨텐츠 인코딩 ( &lt;code&gt;bzip&lt;/code&gt; 및 &lt;code&gt;bzip2&lt;/code&gt; )이 표준은 아니지만 때때로 사용됩니다. 이 두 UNIX 프로그램에서 사용하는 알고리즘을 구현합니다. 특허 라이센스 문제로 인해 첫 번째 라이센스가 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="be051f060f0e48af75e9fbc48e21748ef6b4cb67" translate="yes" xml:space="preserve">
          <source>Two primary MIME types are important for the role of default types:</source>
          <target state="translated">기본 유형의 역할에는 두 가지 기본 MIME 유형이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="f3b42007b5826f0bf510edecae6f14cfe0fe14b4" translate="yes" xml:space="preserve">
          <source>Type name:  multipart

   Subtype name:  byteranges

   Required parameters:  boundary

   Optional parameters:  N/A

   Encoding considerations:  only &quot;7bit&quot;, &quot;8bit&quot;, or &quot;binary&quot; are
      permitted

   Security considerations:  see &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;

   Interoperability considerations:  N/A

   Published specification:  This specification (see &lt;a href=&quot;#appendix-A&quot;&gt;Appendix A&lt;/a&gt;).

   Applications that use this media type:  HTTP components supporting
      multiple ranges in a single request.

   Fragment identifier considerations:  N/A

   Additional information:

      Deprecated alias names for this type:  N/A

      Magic number(s):  N/A

      File extension(s):  N/A

      Macintosh file type code(s):  N/A

   Person and email address to contact for further information:  See
      Authors' Addresses section.

   Intended usage:  COMMON

   Restrictions on usage:  N/A

   Author:  See Authors' Addresses section.

   Change controller:  IESG</source>
          <target state="translated">유형 이름 : multipart 하위 유형 이름 : 바이트 범위 필수 매개 변수 : 경계 선택적 매개 변수 : 해당 사항 없음 인코딩 고려 사항 : &quot;7bit&quot;, &quot;8bit&quot;또는 &quot;binary&quot;만 허용됩니다. 보안 고려 사항 : &lt;a href=&quot;#section-6&quot;&gt;섹션 6&lt;/a&gt; 상호 운용성 고려 사항 : 해당 사항 없음 게시 된 사양 :이 사양 ( &lt;a href=&quot;#appendix-A&quot;&gt;부록 A&lt;/a&gt; 참조). 이 미디어 유형을 사용하는 응용 프로그램 : 단일 요청에서 여러 범위를 지원하는 HTTP 구성 요소 단편 식별자 고려 사항 : 해당 사항 없음 추가 정보 :이 유형의 더 이상 사용되지 않는 별명 : 해당 사항 없음 매직 번호 : 해당 사항 없음 파일 확장자 : 해당 사항 없음 Macintosh 파일 유형 코드 : 해당 사항 없음 개인 자세한 내용은 연락 할 이메일 주소 : 작성자 주소 섹션을 참조하십시오. 용도 : COMMON 사용 제한 : 해당 사항 없음 저자 : 저자 주소 섹션을 참조하십시오. 컨트롤러 변경 : IESG</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="1cdbcf1104e531ebfadc11eeae080e4dae018fc1" translate="yes" xml:space="preserve">
          <source>Types of policy-controlled features</source>
          <target state="translated">정책 제어 기능의 유형</target>
        </trans-unit>
        <trans-unit id="7e09f83609dd0c3d502c7f963c9a6cb433242aef" translate="yes" xml:space="preserve">
          <source>Typescript file</source>
          <target state="translated">타이프 스크립트 파일</target>
        </trans-unit>
        <trans-unit id="bcdcdf22eca538d6ec2cf257367ae227cf6af679" translate="yes" xml:space="preserve">
          <source>Typical use case</source>
          <target state="translated">일반적인 사용 사례</target>
        </trans-unit>
        <trans-unit id="9d181320d36d0df488b3ffb530573b04214390c3" translate="yes" xml:space="preserve">
          <source>Typically, a server response contains a &lt;code&gt;WWW-Authenticate&lt;/code&gt; header that looks like these:</source>
          <target state="translated">일반적으로 서버 응답에는 다음과 같은 &lt;code&gt;WWW-Authenticate&lt;/code&gt; 헤더가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="5c770b12d663e3645cbb00a17170089090ea1bce" translate="yes" xml:space="preserve">
          <source>Typically, a server response contains a &lt;code&gt;WWW-Authenticate&lt;/code&gt; header that looks like this:</source>
          <target state="translated">Typically, a server response contains a &lt;code&gt;WWW-Authenticate&lt;/code&gt; header that looks like this:</target>
        </trans-unit>
        <trans-unit id="b7575b8da7bfc80688b2b000e08fcdc14b5cd506" translate="yes" xml:space="preserve">
          <source>Typically, this means that a required precondition header, such as &lt;a href=&quot;../headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt;, &lt;strong&gt;is missing&lt;/strong&gt;.</source>
          <target state="translated">일반적으로이 방법은 다음과 같은 필요한 전제 조건 헤더 것을 &lt;a href=&quot;../headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; , &lt;strong&gt;행방 불명입니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="037314288a9afb85b05677ae9ceceff454cbc8e0" translate="yes" xml:space="preserve">
          <source>Typically, you don't want your users to resend &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; requests. If you serve the response as the result of this request, a simple press of the reload button will resend the request (possibly after a confirmation message).</source>
          <target state="translated">Typically, you don't want your users to resend &lt;a href=&quot;methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt; requests. If you serve the response as the result of this request, a simple press of the reload button will resend the request (possibly after a confirmation message).</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="cb371c93c5aa0e62198efd303ae2c17474416d1a" translate="yes" xml:space="preserve">
          <source>URI</source>
          <target state="translated">URI</target>
        </trans-unit>
        <trans-unit id="f70305059f0d6ca694366421ab9addbc18e37b87" translate="yes" xml:space="preserve">
          <source>URI/URL - A Uniform Resource Identifier and Uniform Resource Locator,
   respectively.  These terms (and the distinction between them) are
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;].

   URI/URL Mapping - A relation between an absolute URI and a resource.
   Since a resource can represent items that are not network
   retrievable, as well as those that are, it is possible for a resource
   to have zero, one, or many URI mappings.  Mapping a resource to an
   &quot;http&quot; scheme URI makes it possible to submit HTTP protocol requests
   to the resource using the URI. 

   Path Segment - Informally, the characters found between slashes (&quot;/&quot;)
   in a URI.  Formally, as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC3986]&lt;/a&gt;.

   Collection - Informally, a resource that also acts as a container of
   references to child resources.  Formally, a resource that contains a
   set of mappings between path segments and resources and meets the
   requirements defined in &lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;.

   Internal Member (of a Collection) - Informally, a child resource of a
   collection.  Formally, a resource referenced by a path segment
   mapping contained in the collection.

   Internal Member URL (of a Collection) - A URL of an internal member,
   consisting of the URL of the collection (including trailing slash)
   plus the path segment identifying the internal member.

   Member (of a Collection) - Informally, a &quot;descendant&quot; of a
   collection.  Formally, an internal member of the collection, or,
   recursively, a member of an internal member.

   Member URL (of a Collection) - A URL that is either an internal
   member URL of the collection itself, or is an internal member URL of
   a member of that collection.

   Property - A name/value pair that contains descriptive information
   about a resource.

   Live Property - A property whose semantics and syntax are enforced by
   the server.  For example, the live property DAV:getcontentlength has
   its value, the length of the entity returned by a GET request,
   automatically calculated by the server.

   Dead Property - A property whose semantics and syntax are not
   enforced by the server.  The server only records the value of a dead
   property; the client is responsible for maintaining the consistency
   of the syntax and semantics of a dead property.

   Principal - A distinct human or computational actor that initiates
   access to network resources.

   State Token - A URI that represents a state of a resource.  Lock
   tokens are the only state tokens defined in this specification.</source>
          <target state="translated">URI / URL-균일 자원 식별자 및 균일 자원 로케이터. 이러한 용어 (및 이들의 구별)는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]에 정의되어 있습니다. URI / URL 매핑-절대 URI와 리소스 간의 관계 자원은 검색 할 수없는 항목뿐만 아니라 네트워크 검색 할 수없는 항목을 나타낼 수 있으므로 자원에 0, 1 또는 많은 URI 맵핑이있을 수 있습니다. 자원을 &quot;http&quot;스킴 URI에 매핑하면 URI를 사용하여 HTTP 프로토콜 요청을 자원에 제출할 수 있습니다. 경로 세그먼트-비공식적으로 URI에서 슬래시 ( &quot;/&quot;) 사이에있는 문자입니다. 공식적으로 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986] 섹션 3.3에&lt;/a&gt; 정의 된대로. 수집-비공식적으로, 하위 자원에 대한 참조 컨테이너 역할을하는 자원. 공식적으로, 경로 세그먼트와 자원 사이의 맵핑 세트를 포함하고 &lt;a href=&quot;#section-5&quot;&gt;5 절에&lt;/a&gt; 정의 된 요구 사항을 충족시키는 자원. 내부 구성원 (컬렉션)-비공식적으로 컬렉션의 하위 리소스입니다. 공식적으로는 컬렉션에 포함 된 경로 세그먼트 매핑으로 참조되는 리소스입니다. 내부 구성원 URL (컬렉션)-컬렉션의 URL (후행 슬래시 포함)과 내부 구성원을 식별하는 경로 세그먼트로 구성되는 내부 구성원의 URL입니다. 컬렉션의 멤버-비공식적으로 컬렉션의 &quot;후손&quot;입니다. 공식적으로, 컬렉션의 내부 멤버 또는 재귀 적으로 내부 멤버의 멤버입니다. 컬렉션의 구성원 URL-컬렉션 자체의 내부 구성원 URL이거나 해당 컬렉션 구성원의 내부 구성원 URL 인 URL입니다. 속성-리소스에 대한 설명 정보가 포함 된 이름 / 값 쌍입니다.라이브 속성-의미와 구문이 서버에 의해 적용되는 속성입니다. 예를 들어 라이브 속성 DAV : getcontentlength는 GET 요청에 의해 반환 된 엔터티 길이 인 값을 가지며 서버에서 자동으로 계산합니다. Dead Property-서버가 의미와 구문을 시행하지 않는 속성입니다. 서버는 죽은 속성 값만 기록합니다. 클라이언트는 죽은 속성의 구문과 의미의 일관성을 유지해야합니다. Principal-네트워크 리소스에 대한 액세스를 시작하는 고유 한 사람 또는 계산 행위자입니다. State Token-상태를 나타내는 URI입니다. 잠금 토큰은이 사양에 정의 된 유일한 상태 토큰입니다.getcontentlength는 GET 요청에 의해 리턴 된 엔티티의 길이 값을 가지며 서버가 자동으로 계산합니다. Dead Property-서버에서 의미와 구문을 적용하지 않는 속성입니다. 서버는 죽은 속성 값만 기록합니다. 클라이언트는 죽은 속성의 구문과 의미의 일관성을 유지해야합니다. Principal-네트워크 리소스에 대한 액세스를 시작하는 고유 한 사람 또는 계산 행위자입니다. State Token-상태를 나타내는 URI입니다. 잠금 토큰은이 사양에 정의 된 유일한 상태 토큰입니다.getcontentlength는 GET 요청에 의해 리턴 된 엔티티의 길이 값을 가지며 서버가 자동으로 계산합니다. Dead Property-서버가 의미와 구문을 시행하지 않는 속성입니다. 서버는 죽은 속성 값만 기록합니다. 클라이언트는 죽은 속성의 구문과 의미의 일관성을 유지해야합니다. Principal-네트워크 리소스에 대한 액세스를 시작하는 고유 한 사람 또는 계산 행위자입니다. State Token-상태를 나타내는 URI입니다. 잠금 토큰은이 사양에 정의 된 유일한 상태 토큰입니다.서버는 죽은 속성 값만 기록합니다. 클라이언트는 죽은 속성의 구문과 의미의 일관성을 유지해야합니다. Principal-네트워크 리소스에 대한 액세스를 시작하는 고유 한 사람 또는 계산 행위자입니다. State Token-상태를 나타내는 URI입니다. 잠금 토큰은이 사양에 정의 된 유일한 상태 토큰입니다.서버는 죽은 속성 값만 기록합니다. 클라이언트는 죽은 속성의 구문과 의미의 일관성을 유지해야합니다. Principal-네트워크 리소스에 대한 액세스를 시작하는 고유 한 사람 또는 계산 행위자입니다. State Token-상태를 나타내는 URI입니다. 잠금 토큰은이 사양에 정의 된 유일한 상태 토큰입니다.</target>
        </trans-unit>
        <trans-unit id="1b1db348af514b6bea21a18f53ca916d54264149" translate="yes" xml:space="preserve">
          <source>URIs and how to access resources on the Web.</source>
          <target state="translated">URI 및 웹의 리소스에 액세스하는 방법</target>
        </trans-unit>
        <trans-unit id="6d39406666e0fced7b5feeca9564a556a649dc18" translate="yes" xml:space="preserve">
          <source>URIs are intended to be shared, not secured, even when they identify
   secure resources.  URIs are often shown on displays, added to
   templates when a page is printed, and stored in a variety of
   unprotected bookmark lists.  It is therefore unwise to include
   information within a URI that is sensitive, personally identifiable,
   or a risk to disclose.

   Authors of services ought to avoid GET-based forms for the submission
   of sensitive data because that data will be placed in the
   request-target.  Many existing servers, proxies, and user agents log
   or display the request-target in places where it might be visible to
   third parties.  Such services ought to use POST-based form submission
   instead.

   Since the Referer header field tells a target site about the context
   that resulted in a request, it has the potential to reveal
   information about the user's immediate browsing history and any
   personal information that might be found in the referring resource's
   URI.  Limitations on the Referer header field are described in
   &lt;a href=&quot;#section-5.5.2&quot;&gt;Section 5.5.2&lt;/a&gt; to address some of its security considerations.</source>
          <target state="translated">URI는 보안 리소스를 식별하더라도 보안되지 않고 공유되도록 고안되었습니다. URI는 종종 디스플레이에 표시되고 페이지가 인쇄 될 때 템플릿에 추가되며 다양한 보호되지 않은 책갈피 목록에 저장됩니다. 따라서 민감하거나 개인적으로 식별 할 수 있거나 공개 할 위험이있는 URI에 정보를 포함시키는 것은 현명하지 않습니다. 서비스 작성자는 민감한 데이터를 제출할 때 GET 기반 양식을 사용하지 않아야합니다. 그 데이터는 요청 대상에 배치되기 때문입니다. 기존의 많은 서버, 프록시 및 사용자 에이전트는 요청 대상을 제 3자가 볼 수있는 위치에 기록하거나 표시합니다. 이러한 서비스는 대신 POST 기반 양식 제출을 사용해야합니다. Referer 헤더 필드는 대상 사이트에 요청한 컨텍스트에 대해 알려주므로,사용자의 즉각적인 인터넷 사용 기록 및 참조 리소스의 URI에있는 개인 정보에 대한 정보를 공개 할 수 있습니다. Referer 헤더 필드의 제한 사항은 &lt;a href=&quot;#section-5.5.2&quot;&gt;&lt;/a&gt;보안 고려 사항 중 일부를 다루는 5.5.2 절 .</target>
        </trans-unit>
        <trans-unit id="3cce85850c1e42a1666b59eb99149f8792f48d3c" translate="yes" xml:space="preserve">
          <source>URIs have been known by many names: WWW addresses, Universal Document
   Identifiers, Universal Resource Identifiers [&lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt;], and finally the
   combination of Uniform Resource Locators (URL) [&lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt;] and Names (URN)
   [&lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt;]. As far as HTTP is concerned, Uniform Resource Identifiers are
   simply formatted strings which identify--via name, location, or any
   other characteristic--a resource.</source>
          <target state="translated">URI는 WWW 주소, Universal Document Identifiers, Universal Resource Identifiers [ &lt;a href=&quot;#ref-3&quot;&gt;3&lt;/a&gt; ], 그리고 URL (Uniform Resource Locator) [ &lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt; ] 및 Names (URN) [ &lt;a href=&quot;#ref-20&quot;&gt;20&lt;/a&gt; ] 등 여러 이름으로 알려져 있습니다. HTTP와 관련하여 Uniform Resource Identifier는 이름, 위치 또는 기타 특성을 통해 리소스를 식별하는 형식이 지정된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="498e7643a14364976970437ebe13915fd4a1000a" translate="yes" xml:space="preserve">
          <source>URIs in HTTP can be represented in absolute form or relative to some
   known base URI [&lt;a href=&quot;#ref-11&quot;&gt;11&lt;/a&gt;], depending upon the context of their use. The two
   forms are differentiated by the fact that absolute URIs always begin
   with a scheme name followed by a colon. For definitive information on
   URL syntax and semantics, see &quot;Uniform Resource Identifiers (URI):
   Generic Syntax and Semantics,&quot; &lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt; [&lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;] (which replaces RFCs
   1738 [&lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt;] and &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt; [&lt;a href=&quot;#ref-11&quot;&gt;11&lt;/a&gt;]). This specification adopts the
   definitions of &quot;URI-reference&quot;, &quot;absoluteURI&quot;, &quot;relativeURI&quot;, &quot;port&quot;,
   &quot;host&quot;,&quot;abs_path&quot;, &quot;rel_path&quot;, and &quot;authority&quot; from that
   specification.

   The HTTP protocol does not place any a priori limit on the length of
   a URI. Servers MUST be able to handle the URI of any resource they
   serve, and SHOULD be able to handle URIs of unbounded length if they
   provide GET-based forms that could generate such URIs. A server
   SHOULD return 414 (Request-URI Too Long) status if a URI is longer
   than the server can handle (see &lt;a href=&quot;#section-10.4.15&quot;&gt;section 10.4.15&lt;/a&gt;).

      Note: Servers ought to be cautious about depending on URI lengths
      above 255 bytes, because some older client or proxy
      implementations might not properly support these lengths.</source>
          <target state="translated">HTTP의 URI는 사용 컨텍스트에 따라 절대 형식 또는 알려진 일부 기본 URI [ &lt;a href=&quot;#ref-11&quot;&gt;11&lt;/a&gt; ]를 기준으로 표시 될 수 있습니다 . 두 형식은 절대 URI가 항상 체계 이름 뒤에 콜론으로 시작한다는 사실로 구별됩니다. URL 구문 및 의미에 대한 결정적인 정보는 &quot;Uniform Resource Identifiers (URI) : 일반 구문 및 의미&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt; [ &lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt; ] (RFC 1738 [ &lt;a href=&quot;#ref-4&quot;&gt;4&lt;/a&gt; ] 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt; [ &lt;a href=&quot;#ref-11&quot;&gt;11&lt;/a&gt; 대체)를 참조하십시오.]). 이 사양은 해당 사양에서 &quot;URI-reference&quot;, &quot;absoluteURI&quot;, &quot;relativeURI&quot;, &quot;port&quot;, &quot;host&quot;, &quot;abs_path&quot;, &quot;rel_path&quot;및 &quot;authority&quot;의 정의를 채택합니다. HTTP 프로토콜은 URI 길이에 대한 사전 제한을 두지 않습니다. 서버는 서비스를 제공하는 모든 리소스의 URI를 처리 할 수 ​​있어야하며 이러한 URI를 생성 할 수있는 GET 기반 양식을 제공하는 경우 길이가 제한되지 않은 URI를 처리 할 수 ​​있어야합니다. 서버가 처리 할 수있는 것보다 URI가 긴 경우 서버는 414 (Request-URI Too Long) 상태를 반환해야합니다 &lt;a href=&quot;#section-10.4.15&quot;&gt;(10.4.15 절&lt;/a&gt; 참조 ). 참고 : 서버는 255 바이트를 초과하는 URI 길이에 따라 신중해야합니다.일부 오래된 클라이언트 또는 프록시 구현은 이러한 길이를 제대로 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfef62af9614810559e1e5b81b8c27fecbab7b5c" translate="yes" xml:space="preserve">
          <source>URL redirection, also known as URL forwarding, is a technique to give a page, a form or a whole Web application, more than one URL address. HTTP provides a special kind of responses, &lt;em&gt;&lt;strong&gt;HTTP redirects&lt;/strong&gt;&lt;/em&gt;, to perform this operation used for numerous goals: temporary redirection while site maintenance is ongoing, permanent redirection to keep external links working after a change of the site's architecture, progress pages when uploading a file, and so on.</source>
          <target state="translated">URL 전달이라고도하는 URL 리디렉션은 하나 이상의 URL 주소로 페이지, 양식 또는 전체 웹 응용 프로그램을 제공하는 기술입니다. HTTP는 여러 가지 목표에 사용되는이 작업을 수행하기 위한 특별한 종류의 응답 인 &lt;em&gt;&lt;strong&gt;HTTP redirects를&lt;/strong&gt;&lt;/em&gt; 제공합니다. 사이트 유지 관리가 진행되는 동안 임시 리디렉션, 사이트 아키텍처가 변경된 후 외부 링크가 작동하도록하는 영구 리디렉션, 파일 업로드시 진행률 페이지, 등등.</target>
        </trans-unit>
        <trans-unit id="11053b0e7813cb1ccd4cf628421c47a3253d39a1" translate="yes" xml:space="preserve">
          <source>URL-embedded JavaScript code</source>
          <target state="translated">URL-embedded JavaScript code</target>
        </trans-unit>
        <trans-unit id="621894213e70d0f25d538e3e503f261cb1c92c16" translate="yes" xml:space="preserve">
          <source>URL/hostname based conditions</source>
          <target state="translated">URL / 호스트 이름 기반 조건</target>
        </trans-unit>
        <trans-unit id="01f03837323aab32409bb99c50d6c475179c49df" translate="yes" xml:space="preserve">
          <source>URLs</source>
          <target state="translated">URLs</target>
        </trans-unit>
        <trans-unit id="b9011f5a3d0a8fd5aa8be41c9a2ba56d323a6e48" translate="yes" xml:space="preserve">
          <source>URLs and URNs</source>
          <target state="translated">URL 및 URN</target>
        </trans-unit>
        <trans-unit id="0d68396d9a72290240763f5089d4a58c9fd02660" translate="yes" xml:space="preserve">
          <source>URLs appear in many places in requests and responses.
   Interoperability experience with [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] showed that many clients
   parsing Multi-Status responses did not fully implement the full
   Reference Resolution defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;Section&amp;nbsp;5 of [RFC3986]&lt;/a&gt;.  Thus,
   servers in particular need to be careful in handling URLs in
   responses, to ensure that clients have enough context to be able to
   interpret all the URLs.  The rules in this section apply not only to
   resource URLs in the 'href' element in Multi-Status responses, but
   also to the Destination and If header resource URLs.

   The sender has a choice between two approaches: using a relative
   reference, which is resolved against the Request-URI, or a full URI.
   A server MUST ensure that every 'href' value within a Multi-Status
   response uses the same format.

   WebDAV only uses one form of relative reference in its extensions,
   the absolute path.

      Simple-ref = absolute-URI | ( path-absolute [ &quot;?&quot; query ] )

   The absolute-URI, path-absolute and query productions are defined in
   Sections &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt;, &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;, and &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt; of [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;].

   Within Simple-ref productions, senders MUST NOT:

   o  use dot-segments (&quot;.&quot; or &quot;..&quot;), or

   o  have prefixes that do not match the Request-URI (using the
      comparison rules defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.2.3&quot;&gt;Section&amp;nbsp;3.2.3 of [RFC2616]&lt;/a&gt;).

   Identifiers for collections SHOULD end in a '/' character.</source>
          <target state="translated">URL은 요청 및 응답의 여러 위치에 나타납니다. [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; ] 과의 상호 운용성 경험에 따르면 다중 상태 응답을 구문 분석하는 많은 클라이언트 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-5&quot;&gt;가 [RFC3986] 섹션 5에&lt;/a&gt; 정의 된 전체 참조 해상도를 완전히 구현하지 못함. 따라서 서버는 클라이언트가 모든 URL을 해석 할 수있는 충분한 컨텍스트를 갖도록 응답에서 URL을 처리 할 때주의해야합니다. 이 섹션의 규칙은 다중 상태 응답의 'href'요소에있는 리소스 URL뿐만 아니라 대상 및 If 헤더 리소스 URL에도 적용됩니다. 발신자는 요청 URI에 대해 해결되는 상대 참조 또는 전체 URI를 사용하여 두 가지 접근 방식 중에서 선택할 수 있습니다. 서버는 다중 상태 응답 내의 모든 'href'값이 동일한 형식을 사용해야합니다. WebDAV는 확장에서 절대 경로 인 상대 참조의 한 가지 형식 만 사용합니다. 단순 심판 = 절대 URI | 절대 경로, 절대 경로 및 쿼리 생성은 섹션에 정의되어 있습니다 (경로 절대 [ &quot;?&quot;쿼리]).&lt;a href=&quot;#section-4.3&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; 의 4.3 , &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; 및 &lt;a href=&quot;#section-3.4&quot;&gt;3.4&lt;/a&gt; . 단순 참조 제작에서 발송인은 다음을 수행해서는 안됩니다. o 도트 세그먼트 ( &quot;.&quot;또는 &quot;..&quot;)를 사용하거나 o 요청 -URI와 일치하지 않는 접두사를 갖습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.2.3&quot;&gt;3.2.3 절에&lt;/a&gt; 정의 된 비교 규칙 사용). [RFC2616] ). 컬렉션의 식별자는 '/'문자로 끝나야합니다 (SHOULD).</target>
        </trans-unit>
        <trans-unit id="2c75d09b30def3f5acce02670c0f8d304787deb1" translate="yes" xml:space="preserve">
          <source>URNs</source>
          <target state="translated">URNs</target>
        </trans-unit>
        <trans-unit id="09716c44992b8bceefcd6d77921ff9ec06e2764d" translate="yes" xml:space="preserve">
          <source>USB</source>
          <target state="translated">USB</target>
        </trans-unit>
        <trans-unit id="463d4baccb11d04bd39b50170d5669b1473a3d3e" translate="yes" xml:space="preserve">
          <source>UTF-8 is now well-supported and the overwhelmingly preferred character encoding. To &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;guarantee better privacy through less configuration-based entropy&lt;/a&gt;, all browsers omit the &lt;code&gt;Accept-Charset&lt;/code&gt; header: Internet Explorer 8+, Safari 5+, Opera 11+, Firefox 10+ and Chrome 27+ no longer send it.</source>
          <target state="translated">UTF-8 is now well-supported and the overwhelmingly preferred character encoding. To &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;guarantee better privacy through less configuration-based entropy&lt;/a&gt;, all browsers omit the &lt;code&gt;Accept-Charset&lt;/code&gt; header: Internet Explorer 8+, Safari 5+, Opera 11+, Firefox 10+ and Chrome 27+ no longer send it.</target>
        </trans-unit>
        <trans-unit id="3395f08e982fbccb7c267f1152a8f77ff4f3d2ba" translate="yes" xml:space="preserve">
          <source>Unconstrained multiple range requests are susceptible to denial-of-
   service attacks because the effort required to request many
   overlapping ranges of the same data is tiny compared to the time,
   memory, and bandwidth consumed by attempting to serve the requested
   data in many parts.  Servers ought to ignore, coalesce, or reject
   egregious range requests, such as requests for more than two
   overlapping ranges or for many small ranges in a single set,
   particularly when the ranges are requested out of order for no
   apparent reason.  Multipart range requests are not designed to
   support random access.</source>
          <target state="translated">제한되지 않은 다중 범위 요청은 동일한 데이터의 여러 중첩 범위를 요청하는 데 필요한 노력이 요청 된 데이터를 여러 부분으로 제공하려고 시도하는 데 소요되는 시간, 메모리 및 대역폭에 비해 작기 때문에 서비스 거부 공격에 취약합니다. 서버는 특히 범위가 명백한 이유없이 순서없이 요청 될 때 단일 범위 내에서 두 개 이상의 겹치는 범위 또는 많은 작은 범위에 대한 요청과 같은 심각한 범위 요청을 무시, 통합 또는 거부해야합니다. 멀티 파트 범위 요청은 임의 액세스를 지원하도록 설계되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="87b5a91171602746648bcc818bbb122d7646769d" translate="yes" xml:space="preserve">
          <source>Undeprecates &lt;code&gt;frame-src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;frame-src&lt;/code&gt; 를 폐기합니다 .</target>
        </trans-unit>
        <trans-unit id="7f3058bceb865d591bd6a47330d0826684d098a7" translate="yes" xml:space="preserve">
          <source>Under construction. The origin server is currently testing its communication of tracking status.</source>
          <target state="translated">공사중. 오리진 서버는 현재 추적 상태 통신을 테스트하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="93bb4b1c6ee8c5d136c3ae4245fe9019094c3bdf" translate="yes" xml:space="preserve">
          <source>Understanding The Vary Header - Smashing Magazine</source>
          <target state="translated">Understanding The Vary Header - Smashing Magazine</target>
        </trans-unit>
        <trans-unit id="4821ae5432f25746ffce2357d74178373c8cf2dd" translate="yes" xml:space="preserve">
          <source>Understanding XSS Auditor &amp;ndash; Virtue Security</source>
          <target state="translated">XSS 감사 자 이해 &amp;ndash; 미덕 보안</target>
        </trans-unit>
        <trans-unit id="b2f6280ce256054e508e4d6c0d2aed7f16b9ceb5" translate="yes" xml:space="preserve">
          <source>Unfortunately, the HTTP standard does not specify the format of the page allowing to choose between the available resource, which prevents to easily automatize the process. Besides falling back to the &lt;em&gt;server-driven negotiation&lt;/em&gt;, this method is almost always used in conjunction with scripting, especially with JavaScript redirection: after having checked for the negotiation criteria, the script performs the redirection. A second problem is that one more request is needed in order to fetch the real resource, slowing the availability of the resource to the user.</source>
          <target state="translated">불행히도 HTTP 표준은 사용 가능한 리소스 중에서 선택할 수있는 페이지 형식을 지정하지 않으므로 프로세스를 쉽게 자동화 할 수 없습니다. &lt;em&gt;서버 중심 협상으로&lt;/em&gt; 돌아가는 것 외에도이 방법은 거의 항상 스크립팅, 특히 JavaScript 리디렉션과 함께 사용됩니다. 협상 기준을 확인한 후 스크립트는 리디렉션을 수행합니다. 두 번째 문제는 실제 리소스를 가져 오기 위해 하나 이상의 요청이 필요하다는 것입니다. 사용자에게 리소스의 가용성이 느려집니다.</target>
        </trans-unit>
        <trans-unit id="590261af46ebe2219ba617fed793de6d03379f66" translate="yes" xml:space="preserve">
          <source>Unfortunately, the HTTP standard does not specify the format of the page for choosing between the available resource, which prevents the process being automated. Besides falling back to the &lt;em&gt;server-driven negotiation&lt;/em&gt;, this method is almost always used in conjunction with scripting, especially with JavaScript redirection: after having checked for the negotiation criteria, the script performs the redirection. A second problem is that one more request is needed in order to fetch the real resource, slowing the availability of the resource to the user.</source>
          <target state="translated">Unfortunately, the HTTP standard does not specify the format of the page for choosing between the available resource, which prevents the process being automated. Besides falling back to the &lt;em&gt;server-driven negotiation&lt;/em&gt;, this method is almost always used in conjunction with scripting, especially with JavaScript redirection: after having checked for the negotiation criteria, the script performs the redirection. A second problem is that one more request is needed in order to fetch the real resource, slowing the availability of the resource to the user.</target>
        </trans-unit>
        <trans-unit id="eba4dbb75ad90a20a4a3d20676386c7ac0143689" translate="yes" xml:space="preserve">
          <source>Unfortunately, things get a little inaccurate as soon as we take into account concurrency. While a client is locally modifying its new copy of the resource, a second client can fetch the same resource and do the same on its copy. What happens next is very unfortunate: when they commit back to the server, the modifications from the first client are discarded by the next client push, as this second client is unaware of the first client's changes to the resource. The decision on who wins, is not communicated to the other party. Which client's changes are to be kept, will vary with the speed they commit; this depends on the performance of the clients, of the server, and even of the human editing the document at the client. The winner will change from one time to the next. This is a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/race_condition&quot;&gt;race condition&lt;/a&gt; and leads to problematic behaviors, which are difficult to detect and to debug:</source>
          <target state="translated">불행히도 동시성을 고려하자마자 상황이 약간 부정확 해집니다. 클라이언트가 새 리소스 사본을 로컬로 수정하는 동안 두 번째 클라이언트는 동일한 리소스를 가져 와서 해당 복사본에서 동일한 작업을 수행 할 수 있습니다. 다음에 발생하는 일은 매우 불행한 일입니다. 서버에 다시 커밋 할 때 첫 번째 클라이언트의 수정 내용은 다음 클라이언트 푸시에 의해 삭제됩니다. 두 번째 클라이언트는 첫 번째 클라이언트의 리소스 변경 사항을 인식하지 못하기 때문입니다. 누가 이길 지에 대한 결정은 상대방에게 전달되지 않습니다. 어떤 클라이언트의 변경 사항을 유지해야하는지는 커밋 속도에 따라 다릅니다. 이것은 클라이언트, 서버의 성능 및 심지어 클라이언트에서 문서를 편집하는 사람의 성능에 달려 있습니다. 승자는 한 번에서 다음 번으로 변경됩니다. 이것은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/race_condition&quot;&gt;경쟁 조건입니다&lt;/a&gt; 감지하고 디버깅하기 어려운 문제가있는 동작으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="9d6157fa48e6c6221f34d6df81ed35de4c9f2058" translate="yes" xml:space="preserve">
          <source>Uniform Resource Identifier (URI): Generic Syntax</source>
          <target state="translated">URI (Uniform Resource Identifier) ​​: 일반 구문</target>
        </trans-unit>
        <trans-unit id="5331c3d8fb4de87de8b7a5cbf7bd8ea20f192adf" translate="yes" xml:space="preserve">
          <source>Uniform Resource Identifiers (URIs) [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;] are used throughout
   HTTP as the means for identifying resources (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-2&quot;&gt;Section&amp;nbsp;2 of [RFC7231]&lt;/a&gt;).
   URI references are used to target requests, indicate redirects, and
   define relationships.

   The definitions of &quot;URI-reference&quot;, &quot;absolute-URI&quot;, &quot;relative-part&quot;,
   &quot;scheme&quot;, &quot;authority&quot;, &quot;port&quot;, &quot;host&quot;, &quot;path-abempty&quot;, &quot;segment&quot;,
   &quot;query&quot;, and &quot;fragment&quot; are adopted from the URI generic syntax.  An
   &quot;absolute-path&quot; rule is defined for protocol elements that can
   contain a non-empty path component.  (This rule differs slightly from
   the path-abempty rule of &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;, which allows for an empty path to
   be used in references, and path-absolute rule, which does not allow
   paths that begin with &quot;//&quot;.)  A &quot;partial-URI&quot; rule is defined for
   protocol elements that can contain a relative URI but not a fragment
   component.

     URI-reference = &amp;lt;URI-reference, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.1&quot;&gt;[RFC3986], Section&amp;nbsp;4.1&lt;/a&gt;&amp;gt;
     absolute-URI  = &amp;lt;absolute-URI, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;[RFC3986], Section&amp;nbsp;4.3&lt;/a&gt;&amp;gt;
     relative-part = &amp;lt;relative-part, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986], Section&amp;nbsp;4.2&lt;/a&gt;&amp;gt;
     scheme        = &amp;lt;scheme, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.1&quot;&gt;[RFC3986], Section&amp;nbsp;3.1&lt;/a&gt;&amp;gt;
     authority     = &amp;lt;authority, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2&lt;/a&gt;&amp;gt;
     uri-host      = &amp;lt;host, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.2&lt;/a&gt;&amp;gt;
     port          = &amp;lt;port, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.2.3&lt;/a&gt;&amp;gt;
     path-abempty  = &amp;lt;path-abempty, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.3&lt;/a&gt;&amp;gt;
     segment       = &amp;lt;segment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986], Section&amp;nbsp;3.3&lt;/a&gt;&amp;gt;
     query         = &amp;lt;query, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.4&quot;&gt;[RFC3986], Section&amp;nbsp;3.4&lt;/a&gt;&amp;gt;
     fragment      = &amp;lt;fragment, see &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], Section&amp;nbsp;3.5&lt;/a&gt;&amp;gt;

     absolute-path = 1*( &quot;/&quot; segment )
     partial-URI   = relative-part [ &quot;?&quot; query ]

   Each protocol element in HTTP that allows a URI reference will
   indicate in its ABNF production whether the element allows any form
   of reference (URI-reference), only a URI in absolute form
   (absolute-URI), only the path and optional query components, or some
   combination of the above.  Unless otherwise indicated, URI references
   are parsed relative to the effective request URI (&lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;).</source>
          <target state="translated">URI (Uniform Resource Identifier) ​​[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]는 HTTP를 통해 자원을 식별하는 수단으로 사용됩니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-2&quot;&gt;[RFC7231]의 섹션 2&lt;/a&gt; ). URI 참조는 요청을 대상으로하고 리디렉션을 표시하며 관계를 정의하는 데 사용됩니다. &quot;URI-reference&quot;, &quot;absolute-URI&quot;, &quot;relative-part&quot;, &quot;scheme&quot;, &quot;authority&quot;, &quot;port&quot;, &quot;host&quot;, &quot;path-abempty&quot;, &quot;segment&quot;, &quot;query&quot;의 정의 및 &quot;fragment&quot;는 URI 일반 구문에서 채택됩니다. &quot;절대 경로&quot;규칙은 비어 있지 않은 경로 구성 요소를 포함 할 수있는 프로토콜 요소에 대해 정의됩니다. (이 규칙은 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; 의 경로 비우기 규칙과 약간 다릅니다., 참조에 빈 경로를 사용할 수 있고 &quot;//&quot;로 시작하는 경로를 허용하지 않는 경로 절대 규칙) &quot;partial-URI&quot;규칙은 상대 경로를 포함 할 수있는 프로토콜 요소에 대해 정의됩니다. URI이지만 조각 구성 요소는 아닙니다. URI-reference = &amp;lt;URI- 참조, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.1&quot;&gt;[RFC3986], 섹션 4.1 참조&lt;/a&gt; &amp;gt; absolute-URI = &amp;lt;절대 -URI, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.3&quot;&gt;[RFC3986], 섹션 4.3 참조&lt;/a&gt; &amp;gt; relative-part = &amp;lt;상대-부분, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-4.2&quot;&gt;[RFC3986], 섹션 4.2 참조&lt;/a&gt; &amp;gt; scheme = &amp;lt;scheme, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.1&quot;&gt;[RFC3986], 섹션 3.1 참조&lt;/a&gt; &amp;gt; authority = &amp;lt;authority, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2&quot;&gt;[RFC3986], 섹션 3.2 참조&lt;/a&gt; &amp;gt; uri-host = &amp;lt;host, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.2&quot;&gt;[RFC3986], 섹션 3.2.2 참조&lt;/a&gt; &amp;gt; port = &amp;lt;포트, 참조&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.2.3&quot;&gt;[RFC3986], 섹션 3.2.3&lt;/a&gt; &amp;gt; 경로 비우기 = &amp;lt;경로 비우기, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986]&lt;/a&gt; 참조 , 섹션 3.3 &amp;gt; 세그먼트 = &amp;lt;세그먼트, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.3&quot;&gt;[RFC3986]&lt;/a&gt; 참조 , 섹션 3.3 &amp;gt; query = &amp;lt;query, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.4&quot;&gt;[RFC3986]&lt;/a&gt; 참조 , 섹션 3.4 &amp;gt; fragment = &amp;lt;fragment, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], 섹션 3.5 참조&lt;/a&gt;&amp;gt; 절대 경로 = 1 * ( &quot;/&quot;segment) partial-URI = relative-part [ &quot;?&quot; query] URI 참조를 허용하는 HTTP의 각 프로토콜 요소는 ABNF 프로덕션에서 요소가 모든 형식의 참조 (URI-reference), 절대 형식의 URI 만 (absolute-URI), 경로 및 선택적 쿼리 만 허용하는지 여부를 ABNF 프로덕션에 표시합니다. 구성 요소 또는 위의 일부 조합. 달리 명시되지 않는 한, URI 참조는 유효 요청 URI에 대해 구문 분석됩니다 ( &lt;a href=&quot;#section-5.5&quot;&gt;섹션 5.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="326e61a6296432fcad1af300f3c896bd0e9d0435" translate="yes" xml:space="preserve">
          <source>Uniform Resource Names</source>
          <target state="translated">균일 한 리소스 이름</target>
        </trans-unit>
        <trans-unit id="0f25e6e17d90b442b15b6c3491b583d0eb8a4b09" translate="yes" xml:space="preserve">
          <source>Unless dealing with a very old system, which doesn't support a persistent connection, there is no compelling reason to use this model.</source>
          <target state="translated">지속적인 연결을 지원하지 않는 아주 오래된 시스템을 다루지 않는 한이 모델을 사용해야 할 이유는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7df067eefe56c18b36ec5afe619983a9a5702d6c" translate="yes" xml:space="preserve">
          <source>Unless specifically constrained by a cache-control (&lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;)
   directive, a caching system MAY always store a successful response
   (see &lt;a href=&quot;#section-13.8&quot;&gt;section 13.8&lt;/a&gt;) as a cache entry, MAY return it without validation
   if it is fresh, and MAY return it after successful validation. If
   there is neither a cache validator nor an explicit expiration time
   associated with a response, we do not expect it to be cached, but
   certain caches MAY violate this expectation (for example, when little
   or no network connectivity is available). A client can usually detect
   that such a response was taken from a cache by comparing the Date
   header to the current time.

      Note: some HTTP/1.0 caches are known to violate this expectation
      without providing any Warning.

   However, in some cases it might be inappropriate for a cache to
   retain an entity, or to return it in response to a subsequent
   request. This might be because absolute semantic transparency is
   deemed necessary by the service author, or because of security or
   privacy considerations. Certain cache-control directives are
   therefore provided so that the server can indicate that certain
   resource entities, or portions thereof, are not to be cached
   regardless of other considerations.

   Note that &lt;a href=&quot;#section-14.8&quot;&gt;section 14.8&lt;/a&gt; normally prevents a shared cache from saving
   and returning a response to a previous request if that request
   included an Authorization header.

   A response received with a status code of 200, 203, 206, 300, 301 or
   410 MAY be stored by a cache and used in reply to a subsequent
   request, subject to the expiration mechanism, unless a cache-control
   directive prohibits caching. However, a cache that does not support
   the Range and Content-Range headers MUST NOT cache 206 (Partial
   Content) responses.

   A response received with any other status code (e.g. status codes 302
   and 307) MUST NOT be returned in a reply to a subsequent request
   unless there are cache-control directives or another header(s) that
   explicitly allow it. For example, these include the following: an
   Expires header (&lt;a href=&quot;#section-14.21&quot;&gt;section 14.21&lt;/a&gt;); a &quot;max-age&quot;, &quot;s-maxage&quot;,  &quot;must-
   revalidate&quot;, &quot;proxy-revalidate&quot;, &quot;public&quot; or &quot;private&quot; cache-control
   directive (&lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;).</source>
          <target state="translated">Unless specifically constrained by a cache-control (&lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;) directive, a caching system MAY always store a successful response (see &lt;a href=&quot;#section-13.8&quot;&gt;section 13.8&lt;/a&gt;) as a cache entry, MAY return it without validation if it is fresh, and MAY return it after successful validation. If there is neither a cache validator nor an explicit expiration time associated with a response, we do not expect it to be cached, but certain caches MAY violate this expectation (for example, when little or no network connectivity is available). A client can usually detect that such a response was taken from a cache by comparing the Date header to the current time. Note: some HTTP/1.0 caches are known to violate this expectation without providing any Warning. However, in some cases it might be inappropriate for a cache to retain an entity, or to return it in response to a subsequent request. This might be because absolute semantic transparency is deemed necessary by the service author, or because of security or privacy considerations. Certain cache-control directives are therefore provided so that the server can indicate that certain resource entities, or portions thereof, are not to be cached regardless of other considerations. Note that &lt;a href=&quot;#section-14.8&quot;&gt;섹션 14.8은&lt;/a&gt; 일반적으로 요청에 Authorization 헤더가 포함 된 경우 공유 캐시가 이전 요청에 대한 응답을 저장하고 응답을 반환하지 못하게합니다. 캐시 제어 지시가 캐싱을 금지하지 않는 한, 상태 코드 200, 203, 206, 300, 301 또는 410으로 수신 된 응답은 캐시에 의해 저장되고 만료 메커니즘에 따라 후속 요청에 응답하여 사용될 수있다. 그러나 범위 및 컨텐츠 범위 헤더를 지원하지 않는 캐시는 206 (부분 컨텐츠) 응답을 캐시하지 않아야합니다. 다른 상태 코드 (예 : 상태 코드 302 및 307)로 수신 된 응답은 캐시 제어 지시문이나 명시 적으로 허용하는 다른 헤더가없는 한 후속 요청에 대한 응답으로 반환되어서는 안됩니다. 예를 들어 다음과 같습니다. Expires 헤더 (&lt;a href=&quot;#section-14.21&quot;&gt;섹션 14.21&lt;/a&gt; ); &quot;max-age&quot;, &quot;s-maxage&quot;, &quot;must-revalidate&quot;, &quot;proxy-revalidate&quot;, &quot;public&quot;또는 &quot;private&quot;캐시 제어 지시문 ( &lt;a href=&quot;#section-14.9&quot;&gt;14.9 절&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6575621a518b7b48c43d42321f561d5d0b99d27e" translate="yes" xml:space="preserve">
          <source>Unless the origin server explicitly prohibits the caching of their
   responses, the application of GET and HEAD methods to any resources
   SHOULD NOT have side effects that would lead to erroneous behavior if
   these responses are taken from a cache. They MAY still have side
   effects, but a cache is not required to consider such side effects in
   its caching decisions. Caches are always expected to observe an
   origin server's explicit restrictions on caching.

   We note one exception to this rule: since some applications have
   traditionally used GETs and HEADs with query URLs (those containing a
   &quot;?&quot; in the rel_path part) to perform operations with significant side
   effects, caches MUST NOT treat responses to such URIs as fresh unless
   the server provides an explicit expiration time. This specifically
   means that responses from HTTP/1.0 servers for such URIs SHOULD NOT
   be taken from a cache. See &lt;a href=&quot;#section-9.1.1&quot;&gt;section 9.1.1&lt;/a&gt; for related information.</source>
          <target state="translated">오리진 서버가 응답 캐싱을 명시 적으로 금지하지 않는 한, GET 및 HEAD 메소드를 모든 자원에 적용하면 이러한 응답을 캐시에서 가져 오는 경우 잘못된 동작을 유발하는 부작용이 없어야합니다. 여전히 부작용이있을 수 있지만 캐싱 결정시 이러한 부작용을 고려하기 위해 캐시가 필요하지 않습니다. 캐시는 항상 원본 서버의 캐싱에 대한 명시 적 제한 사항을 준수해야합니다. 이 규칙에 대한 한 가지 예외가 있습니다. 일부 응용 프로그램은 전통적으로 쿼리 URL (rel_path 부분에 &quot;?&quot;가 포함 된 쿼리 URL)이있는 GET 및 HEAD를 사용하여 심각한 부작용이있는 작업을 수행 했으므로 캐시는 이러한 URI에 대한 응답을 새로운 URI로 처리해서는 안됩니다 서버가 명시적인 만료 시간을 제공하지 않는 한.이것은 특히 이러한 URI에 대한 HTTP / 1.0 서버의 응답을 캐시에서 가져 오지 않아야 함을 의미합니다. 보다&lt;a href=&quot;#section-9.1.1&quot;&gt;&lt;/a&gt;관련 정보는 섹션 9.1.1 .</target>
        </trans-unit>
        <trans-unit id="a882eb5ce8619bac0f4ca38a47d118a374f590ac" translate="yes" xml:space="preserve">
          <source>Unless you have a very specific immediate need, don't use this deprecated technique; switch to HTTP/2 instead. In HTTP/2, domain sharding is no longer useful: the HTTP/2 connection is able to handle parallel unprioritized requests very well. Domain sharding is even detrimental to performance. Most HTTP/2 implementations use a technique called &lt;a href=&quot;https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/&quot;&gt;connection coalescing&lt;/a&gt; to revert eventual domain sharding.</source>
          <target state="translated">매우 구체적인 즉각적인 요구가없는 한이 폐기 된 기술을 사용하지 마십시오. 대신 HTTP / 2로 전환하십시오. HTTP / 2에서는 도메인 샤딩이 더 이상 유용하지 않습니다. HTTP / 2 연결은 우선 순위가없는 병렬 요청을 매우 잘 처리 할 수 ​​있습니다. 도메인 샤딩은 성능에 해 롭습니다. 대부분의 HTTP / 2 구현은 &lt;a href=&quot;https://daniel.haxx.se/blog/2016/08/18/http2-connection-coalescing/&quot;&gt;연결 통합&lt;/a&gt; 이라는 기술을 사용하여 최종 도메인 샤딩을 되돌 립니다 .</target>
        </trans-unit>
        <trans-unit id="955f79db78c5cf8385c47043fef1a0ffa744352f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#Simple_requests&quot;&gt;&amp;ldquo;simple requests&amp;rdquo; (discussed above)&lt;/a&gt;, &quot;preflighted&quot; requests first send an HTTP request by the &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; method to the resource on the other domain, in order to determine whether the actual request is safe to send. Cross-site requests are preflighted like this since they may have implications to user data.</source>
          <target state="translated">&lt;a href=&quot;#Simple_requests&quot;&gt;&quot;단순 요청&quot;(위에서 논의 됨)&lt;/a&gt; 과 달리 , &quot;미리 비행 된&quot;요청 은 실제 요청이 전송하기에 안전한지 판단하기 위해 먼저 &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; 메소드에 의해 HTTP 요청을 다른 도메인의 자원으로 보냅니다. 사이트 간 요청은 사용자 데이터에 영향을 줄 수 있으므로 이와 같이 프리 플라이트됩니다.</target>
        </trans-unit>
        <trans-unit id="d273c3c1c262b7b14dbca55da7ae721b5a1b7cec" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;#Simple_requests&quot;&gt;&amp;ldquo;simple requests&amp;rdquo; (discussed above)&lt;/a&gt;, for &quot;preflighted&quot; requests the browser first sends an HTTP request using the &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; method to the resource on the other origin, in order to determine if the actual request is safe to send. Cross-site requests are preflighted like this since they may have implications to user data.</source>
          <target state="translated">Unlike &lt;a href=&quot;#Simple_requests&quot;&gt;&amp;ldquo;simple requests&amp;rdquo; (discussed above)&lt;/a&gt;, for &quot;preflighted&quot; requests the browser first sends an HTTP request using the &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; method to the resource on the other origin, in order to determine if the actual request is safe to send. Cross-site requests are preflighted like this since they may have implications to user data.</target>
        </trans-unit>
        <trans-unit id="b6e7352000385c24773b5c3b97548547d27dfcec" translate="yes" xml:space="preserve">
          <source>Unlike subsequent evolutions, there were no HTTP headers, meaning that only HTML files could be transmitted, but no other type of documents. There were no status or error codes: in case of a problem, a specific HTML file was send back with the description of the problem contained in it, for human consumption.</source>
          <target state="translated">이후의 진화와 달리 HTTP 헤더는 없었습니다. 즉, HTML 파일 만 전송할 수 있지만 다른 유형의 문서는 없습니다. 상태 또는 오류 코드는 없었습니다. 문제가 발생하면 특정 HTML 파일이 사람이 소비 할 수 있도록 문제에 대한 설명과 함께 다시 전송되었습니다.</target>
        </trans-unit>
        <trans-unit id="dcc5e76d5034fe1dc84b95117a89364e895b52d1" translate="yes" xml:space="preserve">
          <source>Unlike the previous case, browser history will consider non-www and www URLs as independent entries.</source>
          <target state="translated">이전의 경우와 달리 브라우저 기록은 www가 아닌 ​​www와 www가 아닌 ​​URL을 독립된 항목으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="7607e9b76ed3569248e88c3e032d8ff230e82e7b" translate="yes" xml:space="preserve">
          <source>Unoptimized (poorly compressed) images</source>
          <target state="translated">최적화되지 않은 (잘 압축되지 않은) 이미지</target>
        </trans-unit>
        <trans-unit id="b89f58bc5f8bec30721ee6218fbce69f661ae508" translate="yes" xml:space="preserve">
          <source>Unoptimized images</source>
          <target state="translated">최적화되지 않은 이미지</target>
        </trans-unit>
        <trans-unit id="245e0bd02f62833b644643c9a2e8742e64c2dd7a" translate="yes" xml:space="preserve">
          <source>Unrecognized markup in an Atom Publishing Protocol document is
   considered &quot;foreign markup&quot; as defined in &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt; of the Atom
   Syndication Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].  Foreign markup can be used anywhere
   within a Category or Service Document unless it is explicitly
   forbidden.  Processors that encounter foreign markup MUST NOT stop
   processing and MUST NOT signal an error.  Clients SHOULD preserve
   foreign markup when transmitting such documents.

   The namespace name &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot; is reserved for
   forward-compatible revisions of the Category and Service Document
   types.  This does not exclude the addition of elements and attributes
   that might not be recognized by processors conformant to this
   specification.  Such unrecognized markup from the
   &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot; namespace MUST be treated as foreign
   markup.</source>
          <target state="translated">Atom Publishing Protocol 문서에서 인식 할 수없는 마크 업은 Atom 신디케이션 형식 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ] 의 &lt;a href=&quot;#section-6&quot;&gt;섹션 6&lt;/a&gt; 에 정의 된 &quot;외국 마크 업&quot;으로 간주됩니다 . 외부 마크 업은 명시 적으로 금지되지 않는 한 카테고리 또는 서비스 문서 내 어디에서나 사용할 수 있습니다. 외부 마크 업이 발생한 프로세서는 처리를 중단해서는 안되며 오류를 알리지 않아야합니다. 고객은 그러한 문서를 전송할 때 외국 마크 업을 유지해야합니다. 네임 스페이스 이름 &quot; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;는 범주 및 서비스 문서 유형의 호환 버전을 위해 예약되어 있습니다.이 사양을 준수하는 프로세서가 인식 할 수없는 요소 및 속성 추가는 제외되지 않습니다.&quot; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http : // www. w3.org/2007/app&lt;/a&gt; &quot;네임 스페이스는 반드시 외부 마크 업으로 취급되어야합니다.</target>
        </trans-unit>
        <trans-unit id="de81198fe40f54ca54fd480498f47c5bd2c4979b" translate="yes" xml:space="preserve">
          <source>Unsafe eval expressions</source>
          <target state="translated">안전하지 않은 평가 식</target>
        </trans-unit>
        <trans-unit id="83339b270595929064cc25f1d47c8f0230812a35" translate="yes" xml:space="preserve">
          <source>Unsafe inline script</source>
          <target state="translated">안전하지 않은 인라인 스크립트</target>
        </trans-unit>
        <trans-unit id="a3661e5b83227307acd4850c07a9aaa4a3205ae7" translate="yes" xml:space="preserve">
          <source>Unsafe inline styles</source>
          <target state="translated">안전하지 않은 인라인 스타일</target>
        </trans-unit>
        <trans-unit id="b9c54338e2e3842fa7755217571c1728460781da" translate="yes" xml:space="preserve">
          <source>Unsafe style expressions</source>
          <target state="translated">안전하지 않은 스타일 표현</target>
        </trans-unit>
        <trans-unit id="51e569288fd4c9764275c80909467d65bb077394" translate="yes" xml:space="preserve">
          <source>Unsized media</source>
          <target state="translated">크기가 조정되지 않은 미디어</target>
        </trans-unit>
        <trans-unit id="03d0f6e963af156d3bbc20c425d63949186d2932" translate="yes" xml:space="preserve">
          <source>Until browsers catch up with the spec, you may be able to work around this limitation by doing one or both of the following:</source>
          <target state="translated">Until browsers catch up with the spec, you may be able to work around this limitation by doing one or both of the following:</target>
        </trans-unit>
        <trans-unit id="56a7c8e0f8f826b048cc60b6edd36eb21796fb60" translate="yes" xml:space="preserve">
          <source>Updated. The request resulted in a potential change to the tracking status applicable to this user, user agent, or device.</source>
          <target state="translated">업데이트되었습니다. 요청으로 인해이 사용자, 사용자 에이전트 또는 장치에 적용 가능한 추적 상태가 잠재적으로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="ac2a73c827836daeaf2402394c054c2277994448" translate="yes" xml:space="preserve">
          <source>Upgrade (RFC 2616)</source>
          <target state="translated">업그레이드 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="541adf48138ad8391190feed85e1730b3e897f18" translate="yes" xml:space="preserve">
          <source>Upgrade Insecure Requests</source>
          <target state="translated">안전하지 않은 요청 업그레이드</target>
        </trans-unit>
        <trans-unit id="03453046fa615930ff26806bfd5e6e667dba241d" translate="yes" xml:space="preserve">
          <source>Upgrade Insecure Requests&lt;br/&gt;&lt;small&gt;The definition of 'upgrade-insecure-requests' in that specification.&lt;/small&gt;</source>
          <target state="translated">안전하지 &lt;small&gt;않은 요청 업그레이드 해당 사양에서 '&lt;/small&gt; 업그레이드 비보안 요청 &lt;br/&gt;&lt;small&gt;'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="61c6967492e019e22cb265be59268846e0812c5e" translate="yes" xml:space="preserve">
          <source>Upgrade-Insecure-Requests</source>
          <target state="translated">Upgrade-Insecure-Requests</target>
        </trans-unit>
        <trans-unit id="3b1e9dd129f9691779584493ef0cbd2760709427" translate="yes" xml:space="preserve">
          <source>Upgrading HTTP/1.1 Connections</source>
          <target state="translated">Upgrading HTTP/1.1 Connections</target>
        </trans-unit>
        <trans-unit id="373052ca50b595448fddb3ae3555f3abe2335a7b" translate="yes" xml:space="preserve">
          <source>Upgrading an HTTP connection to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt; uses the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header with the token &lt;code&gt;&quot;TLS/1.0&quot;&lt;/code&gt;. If the switch is made successfully, the original request (which included &lt;code&gt;Upgrade&lt;/code&gt;) is completed as normal, but on the TLS connection.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt; 를 사용하도록 HTTP 연결을 업그레이드하면 &lt;code&gt;&quot;TLS/1.0&quot;&lt;/code&gt; 토큰과 함께 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; 헤더가 사용 됩니다. 전환이 완료되면 원래 요청 ( &lt;code&gt;Upgrade&lt;/code&gt; 포함 )이 정상적으로 완료되지만 TLS 연결에서 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="ab6bbb4d08469c650377ccf5de1a9d9d4253b906" translate="yes" xml:space="preserve">
          <source>Upgrading to TLS Within HTTP/1.1</source>
          <target state="translated">HTTP / 1.1 내에서 TLS로 업그레이드</target>
        </trans-unit>
        <trans-unit id="4a01efdfa6f7b943dbd14d96f1bbda14ed6ca745" translate="yes" xml:space="preserve">
          <source>Upgrading to a WebSocket connection</source>
          <target state="translated">WebSocket 연결로 업그레이드</target>
        </trans-unit>
        <trans-unit id="0df7fec503cc297ba369a863eb42d823f8a3ecf0" translate="yes" xml:space="preserve">
          <source>Upgrading to an HTTP/2 connection</source>
          <target state="translated">HTTP / 2 연결로 업그레이드</target>
        </trans-unit>
        <trans-unit id="92d99b032888bf69448943e3813f272f0f43c556" translate="yes" xml:space="preserve">
          <source>Usage notes</source>
          <target state="translated">사용법 메모</target>
        </trans-unit>
        <trans-unit id="206d556a43a2ee8de81319e120005dc792bee741" translate="yes" xml:space="preserve">
          <source>Usage of &lt;code&gt;isInNet()&lt;/code&gt;, &lt;code&gt;isResolvable()&lt;/code&gt; and &lt;code&gt;dnsResolve()&lt;/code&gt; functions should be carefully considered, as they require the DNS server to be consulted. All the other autoconfig-related functions are mere string-matching functions that don't require the use of a DNS server. If a proxy is used, the proxy will perform its DNS lookup which would double the impact on the DNS server. Most of the time these functions are not necessary to achieve the desired result.</source>
          <target state="translated">Usage of &lt;code&gt;isInNet()&lt;/code&gt; , &lt;code&gt;isResolvable()&lt;/code&gt; and &lt;code&gt;dnsResolve()&lt;/code&gt; functions should be carefully considered, as they require the DNS server to be consulted. All the other autoconfig-related functions are mere string-matching functions that don't require the use of a DNS server. If a proxy is used, the proxy will perform its DNS lookup which would double the impact on the DNS server. Most of the time these functions are not necessary to achieve the desired result.</target>
        </trans-unit>
        <trans-unit id="609254f79607923f3629c1a1e3f48cf232c1eba4" translate="yes" xml:space="preserve">
          <source>Use SOCKS if the primary proxy goes down.</source>
          <target state="translated">기본 프록시가 다운 된 경우 SOCKS를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8b4ff35cb43293441d2110cc488f4176d62f368d" translate="yes" xml:space="preserve">
          <source>Use and Interpretation of HTTP Version Numbers</source>
          <target state="translated">HTTP 버전 번호 사용 및 해석</target>
        </trans-unit>
        <trans-unit id="14a29ba383c84d15925a42f871530f52904ae908" translate="yes" xml:space="preserve">
          <source>Use cases</source>
          <target state="translated">사용 사례</target>
        </trans-unit>
        <trans-unit id="f86adfd6db8707c78a8855719e5ab5617c841214" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;isInNet()&lt;/code&gt;, &lt;code&gt;isResolvable()&lt;/code&gt; and &lt;code&gt;dnsResolve()&lt;/code&gt; functions should be carefully considered, as they require the DNS server to be consulted. All the other autoconfig-related functions are mere string-matching functions that don't require the use of a DNS server. If a proxy is used, the proxy will perform its DNS lookup which would double the impact on the DNS server. Most of the time these functions are not necessary to achieve the desired result.</source>
          <target state="translated">의 사용 &lt;code&gt;isInNet()&lt;/code&gt; , &lt;code&gt;isResolvable()&lt;/code&gt; 및 &lt;code&gt;dnsResolve()&lt;/code&gt; 가 DNS 서버가 협의해야로서 기능을 신중하게 고려되어야한다. 다른 모든 자동 구성 관련 기능은 DNS 서버를 사용할 필요가없는 단순한 문자열 일치 기능입니다. 프록시가 사용되면 프록시는 DNS 조회를 수행하여 DNS 서버에 미치는 영향을 두 배로 증가시킵니다. 대부분의 경우 이러한 기능은 원하는 결과를 얻는 데 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="541cad19bcced32598517d8ec84381ca4110eb7d" translate="yes" xml:space="preserve">
          <source>Use of server-driven content negotiation (&lt;a href=&quot;#section-12.1&quot;&gt;section 12.1&lt;/a&gt;), as indicated
   by the presence of a Vary header field in a response, alters the
   conditions and procedure by which a cache can use the response for
   subsequent requests. See &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt; for use of the Vary header
   field by servers.

   A server SHOULD use the Vary header field to inform a cache of what
   request-header fields were used to select among multiple
   representations of a cacheable response subject to server-driven
   negotiation. The set of header fields named by the Vary field value
   is known as the &quot;selecting&quot; request-headers.

   When the cache receives a subsequent request whose Request-URI
   specifies one or more cache entries including a Vary header field,
   the cache MUST NOT use such a cache entry to construct a response to
   the new request unless all of the selecting request-headers present
   in the new request match the corresponding stored request-headers in
   the original request.

   The selecting request-headers from two requests are defined to match
   if and only if the selecting request-headers in the first request can
   be transformed to the selecting request-headers in the second request 

   by adding or removing linear white space (LWS) at places where this
   is allowed by the corresponding BNF, and/or combining multiple
   message-header fields with the same field name following the rules
   about message headers in &lt;a href=&quot;#section-4.2&quot;&gt;section 4.2&lt;/a&gt;.

   A Vary header field-value of &quot;*&quot; always fails to match and subsequent
   requests on that resource can only be properly interpreted by the
   origin server.

   If the selecting request header fields for the cached entry do not
   match the selecting request header fields of the new request, then
   the cache MUST NOT use a cached entry to satisfy the request unless
   it first relays the new request to the origin server in a conditional
   request and the server responds with 304 (Not Modified), including an
   entity tag or Content-Location that indicates the entity to be used.

   If an entity tag was assigned to a cached representation, the
   forwarded request SHOULD be conditional and include the entity tags
   in an If-None-Match header field from all its cache entries for the
   resource. This conveys to the server the set of entities currently
   held by the cache, so that if any one of these entities matches the
   requested entity, the server can use the ETag header field in its 304
   (Not Modified) response to tell the cache which entry is appropriate.
   If the entity-tag of the new response matches that of an existing
   entry, the new response SHOULD be used to update the header fields of
   the existing entry, and the result MUST be returned to the client.

   If any of the existing cache entries contains only partial content
   for the associated entity, its entity-tag SHOULD NOT be included in
   the If-None-Match header field unless the request is for a range that
   would be fully satisfied by that entry.

   If a cache receives a successful response whose Content-Location
   field matches that of an existing cache entry for the same Request-
   ]URI, whose entity-tag differs from that of the existing entry, and
   whose Date is more recent than that of the existing entry, the
   existing entry SHOULD NOT be returned in response to future requests
   and SHOULD be deleted from the cache.</source>
          <target state="translated">응답에 Vary 헤더 필드가 있음으로 표시되는 서버 기반 컨텐츠 협상 ( &lt;a href=&quot;#section-12.1&quot;&gt;섹션 12.1&lt;/a&gt; )을 사용하면 캐시가 후속 요청에 응답을 사용할 수있는 조건 및 절차가 변경됩니다. 보다&lt;a href=&quot;#section-14.44&quot;&gt; 섹션 14.44&lt;/a&gt;서버에서 Vary 헤더 필드를 사용합니다. 서버는 Vary 헤더 필드를 사용하여 서버 구동 협상에 따라 캐시 가능한 응답의 다중 표현 중에서 선택하는 데 사용 된 요청 헤더 필드를 캐시에 알려야합니다. Vary 필드 값으로 명명 된 헤더 필드 세트를 &quot;선택&quot;요청 헤더라고합니다. 캐시가 Request-URI가 Vary 헤더 필드를 포함하여 하나 이상의 캐시 항목을 지정하는 후속 요청을 수신 할 때, 캐시는 선택 요청 헤더가 모두 존재하지 않는 한 이러한 캐시 항목을 사용하여 새로운 요청에 대한 응답을 구성해서는 안됩니다. 새 요청은 원래 요청의 해당 저장된 요청 헤더와 일치합니다.두 요청에서 선택 요청 헤더는 위치에서 선형 공백 (LWS)을 추가하거나 제거하여 첫 번째 요청에서 선택 요청 헤더를 두 번째 요청에서 선택 요청 헤더로 변환 할 수있는 경우에만 일치하도록 정의됩니다. 여기서 해당 BNF가 허용하거나 메시지 헤더에 대한 규칙에 따라 동일한 필드 이름으로 여러 메시지 헤더 필드를 결합&lt;a href=&quot;#section-4.2&quot;&gt;섹션 4.2&lt;/a&gt;. &quot;*&quot;의 Vary 헤더 필드 값이 항상 일치하지 않으며 해당 자원의 후속 요청은 원래 서버에서만 올바르게 해석 할 수 있습니다. 캐시 된 항목에 대한 선택 요청 헤더 필드가 새 요청의 선택 요청 헤더 필드와 일치하지 않으면 캐시는 캐시 된 항목을 사용하여 요청을 먼저 충족시키지 않는 한 요청을 만족시키기 위해 캐시 된 항목을 사용해서는 안됩니다 (MUST). 요청하고 서버는 사용할 엔티티를 나타내는 엔티티 태그 또는 Content-Location을 포함하여 304 (수정되지 않음)로 응답합니다. 엔티티 태그가 캐시 된 표현에 할당 되었다면, 전달 된 요청은 조건부이어야하고 자원에 대한 모든 캐시 엔트리로부터 If-None-Match 헤더 필드에 엔티티 태그를 포함시켜야한다.이것은 캐시에 현재 보유 된 엔티티 세트를 서버에 전달하므로, 이들 엔티티 중 하나가 요청 된 엔티티와 일치하는 경우 서버는 304 (수정되지 않음) 응답에서 ETag 헤더 필드를 사용하여 캐시에 어떤 항목을 알려줄 수 있습니다 적절하다. 새로운 응답의 엔티티 태그가 기존 엔트리의 엔티티 태그와 일치하면, 새로운 응답을 사용하여 기존 엔트리의 헤더 필드를 업데이트해야하며 결과는 반드시 클라이언트에게 반환되어야합니다. 기존 캐시 항목 중 하나에 관련 엔터티에 대한 부분 내용 만 포함 된 경우 요청이 해당 항목에 의해 완전히 만족되는 범위가 아닌 경우 엔터티 태그는 If-None-Match 헤더 필드에 포함되지 않아야합니다.캐시가 Content-Location 필드가 동일한 Request-] URI에 대한 기존 캐시 항목의 응답과 일치하고 엔티티 태그가 기존 항목의 것과 다르고 날짜가 기존의 항목보다 최신 인 응답을 수신하는 경우 기존 요청은 향후 요청에 대한 응답으로 반환되어서는 안되며 캐시에서 삭제해야합니다 (SHOULD).</target>
        </trans-unit>
        <trans-unit id="e77c9c913df2233d025f025eb22c3c9e62e56fdc" translate="yes" xml:space="preserve">
          <source>Use of the Content-Disposition Header Field in the Hypertext Transfer Protocol (HTTP)</source>
          <target state="translated">HTTP (Hypertext Transfer Protocol)에서 콘텐츠 처리 헤더 필드 사용</target>
        </trans-unit>
        <trans-unit id="eb01880ea7e6c648b8ded6a971ea49e97cecb27b" translate="yes" xml:space="preserve">
          <source>Use proxy for everything except local hosts</source>
          <target state="translated">로컬 호스트를 제외한 모든 것에 프록시 사용</target>
        </trans-unit>
        <trans-unit id="0107748696d0540526cac08ee4cbc145c8a991e8" translate="yes" xml:space="preserve">
          <source>Use proxy only if cannot resolve host</source>
          <target state="translated">호스트를 확인할 수없는 경우에만 프록시 사용</target>
        </trans-unit>
        <trans-unit id="c7ed5020d95df63e9bfb909b2b5b6c058bbb92a7" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;../referrer-policy&quot;&gt;&lt;code&gt;Referrer-Policy&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="translated">사용 &lt;a href=&quot;../referrer-policy&quot;&gt; &lt;code&gt;Referrer-Policy&lt;/code&gt; &lt;/a&gt; 대신 헤더를.</target>
        </trans-unit>
        <trans-unit id="374f23714fac239889ce0a35686349d0fd2fc8cd" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;HttpOnly&lt;/code&gt; attribute to prevent access to cookie values via JavaScript.</source>
          <target state="translated">Use the &lt;code&gt;HttpOnly&lt;/code&gt; attribute to prevent access to cookie values via JavaScript.</target>
        </trans-unit>
        <trans-unit id="a6ac4246f627ce26f7ce64dc4d28d75832652c40" translate="yes" xml:space="preserve">
          <source>Used by Internet Explorer to signal which document mode to use.</source>
          <target state="translated">사용할 문서 모드를 알리기 위해 Internet Explorer에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3e069a42a09f6b8db75113499e4519c2f9266038" translate="yes" xml:space="preserve">
          <source>Used for expressing the user's tracking preference.</source>
          <target state="translated">사용자의 추적 기본 설정을 표현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="83b3f402f1178112d86419eb8f13870a53b15a0a" translate="yes" xml:space="preserve">
          <source>Used in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request&quot;&gt;preflight request&lt;/a&gt; to indicate which HTTP headers can be used when making the actual request.</source>
          <target state="translated">Used in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request&quot;&gt;preflight request&lt;/a&gt; to indicate which HTTP headers can be used when making the actual request.</target>
        </trans-unit>
        <trans-unit id="254d1c745ac787d4b79a0930aea72d4ebc02b51f" translate="yes" xml:space="preserve">
          <source>Used in response to a preflight request to indicate which HTTP headers can be used when making the actual request.</source>
          <target state="translated">프리 플라이트 요청에 대한 응답으로 실제 요청시 사용할 수있는 HTTP 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dd444ebe633050849c3b22b62bbb0225010af96b" translate="yes" xml:space="preserve">
          <source>Used inside a &lt;code&gt;&amp;lt;dav:propstat&amp;gt;&lt;/code&gt; response element to avoid repeatedly enumerating the internal members of multiple bindings to the same collection.</source>
          <target state="translated">Used inside a &lt;code&gt;&amp;lt;dav:propstat&amp;gt;&lt;/code&gt; response element to avoid repeatedly enumerating the internal members of multiple bindings to the same collection.</target>
        </trans-unit>
        <trans-unit id="3851eaed9a9d01e9b233c8f2d77fe0a55f087096" translate="yes" xml:space="preserve">
          <source>Used inside a DAV: propstat response element to avoid enumerating the internal members of multiple bindings to the same collection repeatedly.</source>
          <target state="translated">DAV : propstat 응답 요소 내부에서 사용되어 여러 바인딩의 내부 멤버를 동일한 컬렉션에 반복적으로 열거하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="44451c54c4073c5b244dfc14ec1273b05fc53e0e" translate="yes" xml:space="preserve">
          <source>Used to contain an HTTP cookie, previously sent by the server with the &lt;a href=&quot;headers/set-cookie2&quot;&gt;&lt;code&gt;Set-Cookie2&lt;/code&gt;&lt;/a&gt; header, but has been obsoleted by the specification. Use &lt;a href=&quot;headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">서버에서 이전에 &lt;a href=&quot;headers/set-cookie2&quot;&gt; &lt;code&gt;Set-Cookie2&lt;/code&gt; &lt;/a&gt; 헤더로 전송 한 HTTP 쿠키를 포함하는 데 사용 되었지만 사양에서 사용되지 않습니다. 대신 &lt;a href=&quot;headers/cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b20d6e9692539ff76f2c433622b085813c4ed010" translate="yes" xml:space="preserve">
          <source>Used to indicate how a web page is to be indexed within public search engine results. The header is effectively equivalent to &lt;code&gt;&amp;lt;meta name=&quot;robots&quot; content=&quot;...&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">공개 검색 엔진 결과 내에서 웹 페이지를 색인화하는 방법을 나타내는 데 사용됩니다. 헤더는 효과적으로 &lt;code&gt;&amp;lt;meta name=&quot;robots&quot; content=&quot;...&quot;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9405a74f4eda686904f91b373876d189023d5ec" translate="yes" xml:space="preserve">
          <source>Used to list alternate ways to reach this service.</source>
          <target state="translated">이 서비스에 도달하는 다른 방법을 나열하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="903aa38e08f404e0fe6134066bb4603722c02c8d" translate="yes" xml:space="preserve">
          <source>Used to redirect after a &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; to prevent a refresh of the page that would re-trigger the operation.</source>
          <target state="translated">작업을 다시 트리거하는 페이지를 새로 고치지 않도록 &lt;a href=&quot;methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 후에 리디렉션하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="02f36883721bfa91f003c55fe923c34d8b1123a0" translate="yes" xml:space="preserve">
          <source>Used to redirect after a &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, so that refreshing the result page doesn't re-trigger the operation.</source>
          <target state="translated">결과 페이지를 새로 고쳐도 작업이 다시 트리거되지 않도록 &lt;a href=&quot;methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 후에 리디렉션하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f1d08aee2da19cf95ec2fb45d662ac243b00d47d" translate="yes" xml:space="preserve">
          <source>Used to remove the &lt;a href=&quot;https://w3c.github.io/ServiceWorker/#path-restriction&quot;&gt;path restriction&lt;/a&gt; by including this header &lt;a href=&quot;https://w3c.github.io/ServiceWorker/#service-worker-script-response&quot;&gt;in the response of the Service Worker script&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://w3c.github.io/ServiceWorker/#service-worker-script-response&quot;&gt;Service Worker 스크립트의 응답&lt;/a&gt; 에이 헤더 를 포함 하여 &lt;a href=&quot;https://w3c.github.io/ServiceWorker/#path-restriction&quot;&gt;경로 제한&lt;/a&gt; 을 제거하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8fdc6d67d4d52e242748c4720010a7d9fc0ab0ad" translate="yes" xml:space="preserve">
          <source>Used to send cookies from the server to the user agent, but has been obsoleted by the specification. Use &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">서버에서 사용자 에이전트로 쿠키를 보내는 데 사용되지만 사양에서 더 이상 사용되지 않습니다. 대신 &lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b62be9bca2e56c611a10053517163712a9e03fe9" translate="yes" xml:space="preserve">
          <source>Used to specify a server endpoint for the browser to send warning and error reports to.</source>
          <target state="translated">브라우저가 경고 및 오류 보고서를 보낼 서버 엔드 포인트를 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a0095a76b4707f02952bc67d941d3c22eb71071f" translate="yes" xml:space="preserve">
          <source>Used to specify an allow-list of &lt;a href=&quot;https://w3c.github.io/webappsec-trusted-types/dist/spec/&quot;&gt;Trusted Types&lt;/a&gt; policies. Trusted Types allows applications to lock down DOM XSS injection sinks to only accept non-spoofable, typed values in place of strings.</source>
          <target state="translated">&lt;a href=&quot;https://w3c.github.io/webappsec-trusted-types/dist/spec/&quot;&gt;신뢰할 수있는 유형&lt;/a&gt; 정책 의 허용 목록을 지정하는 데 사용됩니다 . 신뢰할 수있는 유형을 사용하면 애플리케이션이 DOM XSS 삽입 싱크를 잠 가서 문자열 대신 스푸핑이 불가능하고 유형이 지정된 값만 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fac194550e6aaaaf4fc9e84fd643b08330514f82" translate="yes" xml:space="preserve">
          <source>Used to specify information in the &lt;a href=&quot;referer&quot;&gt;Referer&lt;/a&gt; (sic) header for links away from a page. Use the &lt;a href=&quot;referrer-policy&quot;&gt;&lt;code&gt;Referrer-Policy&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="translated">페이지 외부 링크 에 대한 &lt;a href=&quot;referer&quot;&gt;Referer&lt;/a&gt; (sic) 헤더 의 정보를 지정하는 데 사용됩니다 . 사용 &lt;a href=&quot;referrer-policy&quot;&gt; &lt;code&gt;Referrer-Policy&lt;/code&gt; &lt;/a&gt; 대신 헤더를.</target>
        </trans-unit>
        <trans-unit id="7f557f31b265b32e0da41b9f05f518d64277e5f0" translate="yes" xml:space="preserve">
          <source>Used to specify information in the referer (sic) header for links away from a page. Use the &lt;a href=&quot;referrer-policy&quot;&gt;&lt;code&gt;Referrer-Policy&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="translated">페이지에서 떨어진 링크에 대한 참조 자 (sic) 헤더에 정보를 지정하는 데 사용됩니다. 사용 &lt;a href=&quot;referrer-policy&quot;&gt; &lt;code&gt;Referrer-Policy&lt;/code&gt; &lt;/a&gt; 대신 헤더를.</target>
        </trans-unit>
        <trans-unit id="f531ff014faf3edcc5032454c287c495bd6b92dc" translate="yes" xml:space="preserve">
          <source>Used to specify the compression algorithm.</source>
          <target state="translated">압축 알고리즘을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="13fba396aeb16216bd521f7aa66eb44c4da1577d" translate="yes" xml:space="preserve">
          <source>Used when issuing a preflight request to let the server know which &lt;a href=&quot;methods&quot;&gt;HTTP method&lt;/a&gt; will be used when the actual request is made.</source>
          <target state="translated">프리 플라이트 요청을 발행 할 때 실제 요청이 이루어질 때 어떤 &lt;a href=&quot;methods&quot;&gt;HTTP 메소드&lt;/a&gt; 가 사용 될지 서버에 알리기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2bd516d36772bd5ea2d67bbc4165b0dbce033d9a" translate="yes" xml:space="preserve">
          <source>Used when issuing a preflight request to let the server know which HTTP headers will be used when the actual request is made.</source>
          <target state="translated">프리 플라이트 요청을 발행 할 때 실제 요청이 이루어질 때 어떤 HTTP 헤더가 사용 될지 서버에 알리기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8f9f2317df27b96fec34402a882717f5741a2312" translate="yes" xml:space="preserve">
          <source>User Agent</source>
          <target state="translated">사용자 에이전트</target>
        </trans-unit>
        <trans-unit id="96196c87ac2ee878b4abd2f4685a989aa9780951" translate="yes" xml:space="preserve">
          <source>User Agent string</source>
          <target state="translated">사용자 에이전트 문자열</target>
        </trans-unit>
        <trans-unit id="f1851715072ef49470d2dfd3811ec1d1bac97021" translate="yes" xml:space="preserve">
          <source>User agents often have history mechanisms, such as &quot;Back&quot; buttons and
   history lists, that can be used to redisplay a representation
   retrieved earlier in a session.

   The freshness model (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;) does not necessarily apply to
   history mechanisms.  That is, a history mechanism can display a
   previous representation even if it has expired.

   This does not prohibit the history mechanism from telling the user
   that a view might be stale or from honoring cache directives (e.g.,
   Cache-Control: no-store).</source>
          <target state="translated">사용자 에이전트에는 종종 &quot;뒤로&quot;버튼 및 기록 목록과 같은 기록 메커니즘이있어 세션에서 이전에 검색된 표현을 다시 표시하는 데 사용할 수 있습니다. 신선도 모델 ( &lt;a href=&quot;#section-4.2&quot;&gt;섹션 4.2&lt;/a&gt; )이 히스토리 메커니즘에 반드시 적용되는 것은 아닙니다. 즉, 히스토리 메커니즘은 만료 된 경우에도 이전 표시를 표시 할 수 있습니다. 이것은 히스토리 메커니즘이 사용자에게 뷰가 오래되었거나 캐시 지시문 (예 : Cache-Control : no-store)을 준수 할 수 있음을 알리는 것을 금지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4415ef6828595c5d51a025c59cf8000e72dad23" translate="yes" xml:space="preserve">
          <source>User agents often have history mechanisms, such as &quot;Back&quot; buttons and
   history lists, which can be used to redisplay an entity retrieved
   earlier in a session.

   History mechanisms and caches are different. In particular history
   mechanisms SHOULD NOT try to show a semantically transparent view of
   the current state of a resource. Rather, a history mechanism is meant
   to show exactly what the user saw at the time when the resource was
   retrieved.

   By default, an expiration time does not apply to history mechanisms.
   If the entity is still in storage, a history mechanism SHOULD display
   it even if the entity has expired, unless the user has specifically
   configured the agent to refresh expired history documents.

   This is not to be construed to prohibit the history mechanism from
   telling the user that a view might be stale.

      Note: if history list mechanisms unnecessarily prevent users from
      viewing stale resources, this will tend to force service authors
      to avoid using HTTP expiration controls and cache controls when
      they would otherwise like to. Service authors may consider it
      important that users not be presented with error messages or
      warning messages when they use navigation controls (such as BACK)
      to view previously fetched resources. Even though sometimes such
      resources ought not to cached, or ought to expire quickly, user
      interface considerations may force service authors to resort to
      other means of preventing caching (e.g. &quot;once-only&quot; URLs) in order
      not to suffer the effects of improperly functioning history
      mechanisms.</source>
          <target state="translated">사용자 에이전트는 종종 &quot;뒤로&quot;버튼 및 기록 목록과 같은 기록 메커니즘을 가지고 있는데, 이는 세션에서 이전에 검색된 엔티티를 다시 표시하는 데 사용할 수 있습니다. 히스토리 메커니즘과 캐시는 다릅니다. 특히 히스토리 메커니즘은 리소스의 현재 상태를 의미 적으로 투명하게 보여서는 안됩니다. 오히려 히스토리 메커니즘은 자원을 검색 할 때 사용자가 본 것을 정확하게 표시하기위한 것입니다. 기본적으로 만료 시간은 기록 메커니즘에 적용되지 않습니다. 엔티티가 여전히 스토리지에있는 경우, 사용자가 만료 된 히스토리 문서를 새로 고치도록 에이전트를 구체적으로 구성하지 않은 경우, 엔티티가 만료 된 경우에도 히스토리 메커니즘이이를 표시해야합니다 (SHOULD).이것은 히스토리 메커니즘이 사용자에게 뷰가 오래되었다는 것을 알려주지 않도록 해석되어서는 안됩니다. 참고 : 히스토리 목록 메커니즘으로 인해 사용자가 부실 자원을 볼 수없는 경우 서비스 작성자가 HTTP 만기 제어 및 캐시 제어를 사용하지 않을 수 있습니다. 서비스 작성자는 탐색 컨트롤 (예 : BACK)을 사용하여 이전에 가져온 리소스를 볼 때 오류 메시지 나 경고 메시지가 표시되지 않는 것이 중요하다고 생각할 수 있습니다. 때때로 이러한 리소스는 캐시되지 않거나 빨리 만료되어야하지만 사용자 인터페이스 고려 사항으로 인해 서비스 작성자는 캐싱을 방지하는 다른 수단 (예 : &quot;한 번만&quot;)에 의지 할 수 있습니다.히스토리 메커니즘이 제대로 작동하지 않아서 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef8a5045e61510a061d2ed7f1794e270afbdc266" translate="yes" xml:space="preserve">
          <source>User preferences, themes, and other settings</source>
          <target state="translated">사용자 기본 설정, 테마 및 기타 설정</target>
        </trans-unit>
        <trans-unit id="170c6d2e56e8b4e9ec094b58afe212ec6e8296a6" translate="yes" xml:space="preserve">
          <source>User-Agent</source>
          <target state="translated">User-Agent</target>
        </trans-unit>
        <trans-unit id="1af81e21640faada944a6a51c7427107b23862dd" translate="yes" xml:space="preserve">
          <source>User-Agent (RFC 2616)</source>
          <target state="translated">사용자 에이전트 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="9e418a2de2016f5489f400bdd59f7d98983152ae" translate="yes" xml:space="preserve">
          <source>User-Agent (RFC 7231)</source>
          <target state="translated">사용자 에이전트 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="e9f2acd9319796127c26633394cadcb61c4e6cb6" translate="yes" xml:space="preserve">
          <source>User-Agent detection, history and checklist</source>
          <target state="translated">사용자 에이전트 감지, 히스토리 및 점검 목록</target>
        </trans-unit>
        <trans-unit id="25fb3b0fb82d92b257f4abf9c12069ad6ce3a8ba" translate="yes" xml:space="preserve">
          <source>User-Agent: Firefox</source>
          <target state="translated">사용자 에이전트 : Firefox</target>
        </trans-unit>
        <trans-unit id="461246704acac5c978b021dbe1bb6946d4fb06af" translate="yes" xml:space="preserve">
          <source>Uses the non-standard name: &lt;code&gt;X-Content-Security-Policy&lt;/code&gt;</source>
          <target state="translated">비표준 이름 사용 : &lt;code&gt;X-Content-Security-Policy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b767622d82ebb5ed86e7d98876ac2c600c5e6b41" translate="yes" xml:space="preserve">
          <source>Uses the non-standard name: &lt;code&gt;X-Webkit-CSP&lt;/code&gt;</source>
          <target state="translated">비표준 이름 사용 : &lt;code&gt;X-Webkit-CSP&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc53525239d5487c05ac1087f6ca7d5f2f779901" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; with credentials:</source>
          <target state="translated">신임 정보와 함께 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="775b0a348ff6d7feb24560ac7ae004af821cabfb" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;XHR&lt;/a&gt; with credentials:</source>
          <target state="translated">신임 정보와 함께 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;XHR&lt;/a&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="50b3d158a5243f6906bff7679a67e75c48e89bc6" translate="yes" xml:space="preserve">
          <source>Using &lt;em&gt;&lt;code&gt;&amp;lt;link rel=&quot;canonical&quot;&amp;gt;&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">사용 &lt;em&gt; &lt;code&gt;&amp;lt;link rel=&quot;canonical&quot;&amp;gt;&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d058ec1d546ffd4724c08314ef307b7b9d7d0cf8" translate="yes" xml:space="preserve">
          <source>Using CORS - HTML5 Rocks</source>
          <target state="translated">CORS 사용-HTML5 락</target>
        </trans-unit>
        <trans-unit id="d5b6aeeea8a183eae1980c322cfe2088cc4d812f" translate="yes" xml:space="preserve">
          <source>Using CORS with All (Modern) Browsers</source>
          <target state="translated">모든 (현대) 브라우저에서 CORS 사용</target>
        </trans-unit>
        <trans-unit id="2b0657cfc18741e8d87d0fb3eecf2f7e48f046bf" translate="yes" xml:space="preserve">
          <source>Using CSP</source>
          <target state="translated">CSP 사용</target>
        </trans-unit>
        <trans-unit id="2a075c7f234b30ed09767571bf0ceed43702253f" translate="yes" xml:space="preserve">
          <source>Using Early Data in HTTP</source>
          <target state="translated">HTTP에서 초기 데이터 사용</target>
        </trans-unit>
        <trans-unit id="95cb8ad5ba97958bfc77f7e47510a519e5b56075" translate="yes" xml:space="preserve">
          <source>Using Feature Policy</source>
          <target state="translated">기능 정책 사용</target>
        </trans-unit>
        <trans-unit id="faf834f6793fc3f5f4b06268382d98fe70168835" translate="yes" xml:space="preserve">
          <source>Using HTTP 301 redirects</source>
          <target state="translated">HTTP 301 리디렉션 사용</target>
        </trans-unit>
        <trans-unit id="d727a2f1b0f1ead6a5afe7b4b3b79b5d88a9496a" translate="yes" xml:space="preserve">
          <source>Using HTTP cookies allows you to link requests with the state of the server. This creates sessions, despite basic HTTP being a state-less protocol. This is useful not only for e-commerce shopping baskets, but also for any site allowing user configuration of the output.</source>
          <target state="translated">HTTP 쿠키를 사용하면 요청을 서버 상태와 연결할 수 있습니다. 기본 HTTP가 상태 비 저장 프로토콜 인 경우에도 세션이 생성됩니다. 이는 전자 상거래 쇼핑 바구니뿐만 아니라 사용자가 출력을 구성 할 수있는 모든 사이트에도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="65356d107d722c421bdf9afae2752bb3644268e5" translate="yes" xml:space="preserve">
          <source>Using HTTP for complex applications</source>
          <target state="translated">복잡한 애플리케이션에 HTTP 사용</target>
        </trans-unit>
        <trans-unit id="bdebe583c1966f4eb802f9db212ff788822f1b79" translate="yes" xml:space="preserve">
          <source>Using HTTP for secure transmissions</source>
          <target state="translated">안전한 전송을 위해 HTTP 사용</target>
        </trans-unit>
        <trans-unit id="d91da6c75dbce03772ce3e47bbb5354fb14b4b03" translate="yes" xml:space="preserve">
          <source>Using a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;&lt;/a&gt; element with an action set to inline JavaScript will result in a CSP violation.</source>
          <target state="translated">사용하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt; &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; &lt;/a&gt; 액션 세트 요소 것은 자바 스크립트가 CSP 위반이 발생합니다 인라인합니다.</target>
        </trans-unit>
        <trans-unit id="4922a67e365ea567205aca17260f78c85648a98b" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; structure (defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt;) with the &lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;deflate&lt;/em&gt;&lt;/a&gt; compression algorithm (defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc1951&quot;&gt;RFC 1951&lt;/a&gt;).</source>
          <target state="translated">은 Using &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;ZLIB의&lt;/a&gt; (정의 구조 &lt;a href=&quot;http://tools.ietf.org/html/rfc1950&quot;&gt;1,950 RFC&lt;/a&gt; )와 &lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;DEFLATE&lt;/em&gt;&lt;/a&gt; 압축 알고리즘 (정의 &lt;a href=&quot;http://tools.ietf.org/html/rfc1951&quot;&gt;RFC 1951&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5f135cd288cff1c792d31f6c40167df8a81653f9" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; structure (defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt;) with the &lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;deflate&lt;/em&gt;&lt;/a&gt; compression algorithm (defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1951&lt;/a&gt;).</source>
          <target state="translated">은 Using &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;ZLIB의&lt;/a&gt; (정의 구조 &lt;a href=&quot;http://tools.ietf.org/html/rfc1950&quot;&gt;1,950 RFC&lt;/a&gt; )와 &lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;DEFLATE&lt;/em&gt;&lt;/a&gt; 압축 알고리즘 (정의 &lt;a href=&quot;http://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1951&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f6d2f72f11bac70f52a4d8c1aa837dc886d98d35" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; structure (defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt;), with the &lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;deflate&lt;/em&gt;&lt;/a&gt; compression algorithm (defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1951&lt;/a&gt;).</source>
          <target state="translated">은 Using &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;ZLIB의&lt;/a&gt; (정의 구조 &lt;a href=&quot;http://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt; )와, &lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;DEFLATE&lt;/em&gt;&lt;/a&gt; 압축 알고리즘 (정의 &lt;a href=&quot;http://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1951&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="381f4958cb832cb4d7530e7e9118ab47b34808f2" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; structure is accepted as a transfer coding name.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; 구조 사용은 전송 코딩 이름으로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c06631425c8e2a5c38beb712ece2894d30377b7f" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;code&gt;allow&lt;/code&gt; attribute:</source>
          <target state="translated">은 Using &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;code&gt;allow&lt;/code&gt; 속성 :</target>
        </trans-unit>
        <trans-unit id="331593d404c541921d5682ea4724593568cd2784" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;Forwarded&lt;/code&gt; header</source>
          <target state="translated">은 Using &lt;code&gt;Forwarded&lt;/code&gt; 헤더를</target>
        </trans-unit>
        <trans-unit id="9c88668cce11f173b8e79266db94e16cf90dd514" translate="yes" xml:space="preserve">
          <source>Using the Resource Timing API</source>
          <target state="translated">자원 타이밍 API 사용</target>
        </trans-unit>
        <trans-unit id="fe1f968e579f2259eb8e8e4a023219aab908c00a" translate="yes" xml:space="preserve">
          <source>Usually a client will present a password prompt to the user and will then issue the request including the correct &lt;code&gt;Authorization&lt;/code&gt; header.</source>
          <target state="translated">일반적으로 클라이언트는 사용자에게 암호 프롬프트를 표시 한 다음 올바른 &lt;code&gt;Authorization&lt;/code&gt; 헤더를 포함하는 요청을 발행합니다 .</target>
        </trans-unit>
        <trans-unit id="f1d9d10dc421dffc12418b1ffd0ee9ed4d6c1255" translate="yes" xml:space="preserve">
          <source>Usually cached alternative service entries are cleared on network configuration changes. Use of the persist=1 parameter ensures that the entry is not deleted through such changes.</source>
          <target state="translated">일반적으로 캐시 된 대체 서비스 항목은 네트워크 구성 변경시 지워집니다. persist = 1 매개 변수를 사용하면 이러한 변경으로 인해 항목이 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5d9a9c22782754834063c5c87e532b570115167" translate="yes" xml:space="preserve">
          <source>VR / XR</source>
          <target state="translated">VR / XR</target>
        </trans-unit>
        <trans-unit id="dd74d182c641e4c78502d863b44d0aeff1575e54" translate="yes" xml:space="preserve">
          <source>Validation</source>
          <target state="translated">Validation</target>
        </trans-unit>
        <trans-unit id="6ed0f1de5e048f3ac28333d0cfff3151dbc16735" translate="yes" xml:space="preserve">
          <source>Validation (RFC 7234)</source>
          <target state="translated">검증 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="712c6ea96c055017cf46eeff45a8bf53cd962f56" translate="yes" xml:space="preserve">
          <source>Validator header fields convey metadata about the selected
   representation (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;).  In responses to safe requests, validator
   fields describe the selected representation chosen by the origin
   server while handling the response.  Note that, depending on the
   status code semantics, the selected representation for a given
   response is not necessarily the same as the representation enclosed
   as response payload.

   In a successful response to a state-changing request, validator
   fields describe the new representation that has replaced the prior
   selected representation as a result of processing the request.

   For example, an ETag header field in a 201 (Created) response
   communicates the entity-tag of the newly created resource's
   representation, so that it can be used in later conditional requests
   to prevent the &quot;lost update&quot; problem [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;].

   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | ETag              | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7232]&lt;/a&gt; |
   | Last-Modified     | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2&quot;&gt;Section&amp;nbsp;2.2 of [RFC7232]&lt;/a&gt; |
   +-------------------+--------------------------+</source>
          <target state="translated">유효성 검사기 헤더 필드는 선택한 표현에 대한 메타 데이터를 전달합니다 ( &lt;a href=&quot;#section-3&quot;&gt;섹션 3&lt;/a&gt;). 안전한 요청에 대한 응답에서 유효성 검사기 필드는 응답을 처리하는 동안 원본 서버에서 선택한 선택된 표현을 설명합니다. 상태 코드 의미에 따라 주어진 응답에 대해 선택된 표현이 응답 페이로드로 묶인 표현과 반드시 ​​동일하지는 않습니다. 상태 변경 요청에 대한 성공적인 응답에서 유효성 검사기 필드는 요청 처리 결과 이전에 선택한 표현을 대체 한 새로운 표현을 설명합니다. 예를 들어, 201 (작성 됨) 응답의 ETag 헤더 필드는 새로 작성된 자원 표시의 엔티티 태그를 통신하므로 나중에 갱신되지 않는 문제점을 방지하기 위해 조건부 요청에서 사용할 수 있습니다. [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]. + ------------------- + -------------------------- + | 헤더 필드 이름 | 정의 ... | + ------------------- + -------------------------- + | ETag | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232] 섹션 2.3&lt;/a&gt; | | 마지막 수정 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2&quot;&gt;[RFC7232] 섹션 2.2&lt;/a&gt; | + ------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="762f13c2259b5fbab6d8f1bdbab081fc48bc558f" translate="yes" xml:space="preserve">
          <source>Validators</source>
          <target state="translated">Validators</target>
        </trans-unit>
        <trans-unit id="dccad7c8797a5d7efc3bc914b1c32ba185470954" translate="yes" xml:space="preserve">
          <source>Validators come in two flavors: strong or weak.  Weak validators are
   easy to generate but are far less useful for comparisons.  Strong
   validators are ideal for comparisons but can be very difficult (and
   occasionally impossible) to generate efficiently.  Rather than impose
   that all forms of resource adhere to the same strength of validator,
   HTTP exposes the type of validator in use and imposes restrictions on
   when weak validators can be used as preconditions.

   A &quot;strong validator&quot; is representation metadata that changes value
   whenever a change occurs to the representation data that would be
   observable in the payload body of a 200 (OK) response to GET.

   A strong validator might change for reasons other than a change to
   the representation data, such as when a semantically significant part
   of the representation metadata is changed (e.g., Content-Type), but
   it is in the best interests of the origin server to only change the
   value when it is necessary to invalidate the stored responses held by
   remote caches and authoring tools.

   Cache entries might persist for arbitrarily long periods, regardless
   of expiration times.  Thus, a cache might attempt to validate an
   entry using a validator that it obtained in the distant past.  A
   strong validator is unique across all versions of all representations
   associated with a particular resource over time.  However, there is
   no implication of uniqueness across representations of different
   resources (i.e., the same strong validator might be in use for
   representations of multiple resources at the same time and does not
   imply that those representations are equivalent). 

   There are a variety of strong validators used in practice.  The best
   are based on strict revision control, wherein each change to a
   representation always results in a unique node name and revision
   identifier being assigned before the representation is made
   accessible to GET.  A collision-resistant hash function applied to
   the representation data is also sufficient if the data is available
   prior to the response header fields being sent and the digest does
   not need to be recalculated every time a validation request is
   received.  However, if a resource has distinct representations that
   differ only in their metadata, such as might occur with content
   negotiation over media types that happen to share the same data
   format, then the origin server needs to incorporate additional
   information in the validator to distinguish those representations.

   In contrast, a &quot;weak validator&quot; is representation metadata that might
   not change for every change to the representation data.  This
   weakness might be due to limitations in how the value is calculated,
   such as clock resolution, an inability to ensure uniqueness for all
   possible representations of the resource, or a desire of the resource
   owner to group representations by some self-determined set of
   equivalency rather than unique sequences of data.  An origin server
   SHOULD change a weak entity-tag whenever it considers prior
   representations to be unacceptable as a substitute for the current
   representation.  In other words, a weak entity-tag ought to change
   whenever the origin server wants caches to invalidate old responses.

   For example, the representation of a weather report that changes in
   content every second, based on dynamic measurements, might be grouped
   into sets of equivalent representations (from the origin server's
   perspective) with the same weak validator in order to allow cached
   representations to be valid for a reasonable period of time (perhaps
   adjusted dynamically based on server load or weather quality).
   Likewise, a representation's modification time, if defined with only
   one-second resolution, might be a weak validator if it is possible
   for the representation to be modified twice during a single second
   and retrieved between those modifications.

   Likewise, a validator is weak if it is shared by two or more
   representations of a given resource at the same time, unless those
   representations have identical representation data.  For example, if
   the origin server sends the same validator for a representation with
   a gzip content coding applied as it does for a representation with no
   content coding, then that validator is weak.  However, two
   simultaneous representations might share the same strong validator if
   they differ only in the representation metadata, such as when two
   different media types are available for the same representation data. 

   Strong validators are usable for all conditional requests, including
   cache validation, partial content ranges, and &quot;lost update&quot;
   avoidance.  Weak validators are only usable when the client does not
   require exact equality with previously obtained representation data,
   such as when validating a cache entry or limiting a web traversal to
   recent changes.</source>
          <target state="translated">유효성 검사기는 강하거나 약한 두 가지 맛이 있습니다. 약한 유효성 검사기는 생성하기 쉽지만 비교에는 훨씬 유용하지 않습니다. 강력한 유효성 검사기는 비교에 이상적이지만 효율적으로 생성하기가 매우 어려울 수 있으며 때로는 불가능할 수도 있습니다. 모든 유형의 자원이 동일한 강도의 유효성 검증기를 준수하도록 강요하는 대신 HTTP는 사용중인 유효성 검증기 유형을 노출하고 취약한 유효성 검증 기가 전제 조건으로 사용될 수있는 경우에 대한 제한을 부과합니다. &quot;강한 유효성 검사기&quot;는 GET에 대한 200 (OK) 응답의 페이로드 본문에서 관찰 할 수있는 표현 데이터가 변경 될 때마다 값을 변경하는 표현 메타 데이터입니다. 강력한 유효성 검사기는 표현 데이터 변경 이외의 이유로 변경 될 수 있습니다.예를 들어 표현 메타 데이터의 의미 상 중요한 부분이 변경되는 경우 (예 : Content-Type) 원격 캐시에 의해 저장된 저장된 응답을 무효화해야 할 때만 값을 변경하는 것이 원 서버의 최선의 이익입니다. 저작 도구. 캐시 항목은 만료 시간에 관계없이 임의로 장기간 지속될 수 있습니다. 따라서 캐시는 먼 과거에 얻은 유효성 검사기를 사용하여 항목의 유효성을 검사하려고 시도 할 수 있습니다. 강력한 유효성 검사기는 시간이 지남에 따라 특정 리소스와 관련된 모든 표현의 모든 버전에서 고유합니다. 그러나 서로 다른 자원의 표현에서 고유성이 함축되지는 않습니다 (예 :동일한 강력한 유효성 검증 기가 동시에 여러 자원을 표시하는 데 사용 중일 수 있으며 해당 표시가 동등한 것을 의미하지는 않습니다. 실제로 사용되는 다양한 강력한 유효성 검사기가 있습니다. 최선의 방법은 엄격한 개정 관리를 기반으로하며, 표현을 변경할 때마다 항상 고유 한 노드 이름과 개정 식별자가 지정되어 GET에 표시 할 수 있습니다. 응답 헤더 필드를 보내기 전에 데이터를 사용할 수 있고 유효성 검사 요청을받을 때마다 다이제스트를 다시 계산할 필요가없는 경우 표현 데이터에 적용된 충돌 방지 해시 함수도 충분합니다. 그러나 리소스에 메타 데이터 만 다른 고유 한 표현이있는 경우,동일한 데이터 형식을 공유하는 매체 유형에 대한 컨텐츠 협상에서 발생할 수있는 것과 같이 오리진 서버는 해당 표시를 구별하기 위해 유효성 검증기에 추가 정보를 통합해야합니다. 반대로 &quot;약한 유효성 검사기&quot;는 표현 데이터를 변경할 때마다 변경되지 않는 표현 메타 데이터입니다. 이 약점은 클럭 해상도, 가능한 모든 자원 표현에 고유성을 보장 할 수 없거나 자원 소유자가 자체 결정된 동등성 세트로 표현을 그룹화하려는 욕구와 같은 값 계산 방법의 한계로 인한 것일 수 있습니다. 고유 한 데이터 시퀀스가 ​​아니라오리진 서버는 이전 표현이 현재 표현을 대신 할 수없는 것으로 간주 될 때마다 약한 엔티티 태그를 변경해야합니다. 즉, 약한 엔티티 태그는 원래 서버가 캐시가 이전 응답을 무효화하기를 원할 때마다 변경되어야합니다. 예를 들어, 동적 측정을 기반으로 1 초마다 컨텐츠가 변경되는 날씨 보고서의 표현은 캐시 된 표현이 유효하도록 동일한 약한 유효성 검증기를 사용하여 (원본 서버의 관점에서) 동등한 표현 세트로 그룹화 될 수 있습니다. 적절한 시간 동안 (아마 서버로드 또는 날씨 품질에 따라 동적으로 조정될 수 있음) 마찬가지로 표현의 수정 시간 (1 초 해상도로만 정의 된 경우)표현이 1 초 동안 두 번 수정되고 해당 수정 사이에서 검색 될 수있는 경우 약한 유효성 검사기 일 수 있습니다. 마찬가지로, 해당 표현이 동일한 표현 데이터를 가지지 않는 한 주어진 자원의 둘 이상의 표현이 동시에 공유되면 유효성 검사기는 약합니다. 예를 들어, 오리진 서버가 컨텐츠 코딩이없는 표현에 대해 적용되는 gzip 컨텐츠 코딩이있는 표현에 대해 동일한 유효성 검증기를 보내면 해당 유효성 검증 기가 약합니다. 그러나 두 개의 동시 표현은 동일한 표현 데이터에 대해 두 개의 다른 매체 유형을 사용할 수있는 경우와 같이 표현 메타 데이터에서만 다른 경우 동일한 강력한 유효성 검증기를 공유 할 수 있습니다. 모든 조건부 요청에 강력한 유효성 검사기를 사용할 수 있습니다.캐시 유효성 검사, 부분 컨텐츠 범위 및 &quot;손실 된 업데이트&quot;방지를 포함합니다. 약한 유효성 검사기는 클라이언트가 캐시 항목의 유효성을 검사하거나 웹 탐색을 최근 변경 사항으로 제한하는 경우와 같이 이전에 얻은 표현 데이터와 정확히 동일한 것이 필요하지 않은 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="95995420eab6703ad8a4f2ba7da6319b9b43e40d" translate="yes" xml:space="preserve">
          <source>Values for a CSS stylesheet</source>
          <target state="translated">CSS 스타일 시트의 값</target>
        </trans-unit>
        <trans-unit id="a5ef8687b052a94f11db08f4f679818138d67288" translate="yes" xml:space="preserve">
          <source>Values for a video</source>
          <target state="translated">비디오의 가치</target>
        </trans-unit>
        <trans-unit id="4d9dcfc6daf7e146bae84e76afccb728e632f028" translate="yes" xml:space="preserve">
          <source>Values for an image</source>
          <target state="translated">이미지 값</target>
        </trans-unit>
        <trans-unit id="0022bf43f5fac9f98b34676d218d78927c174e9e" translate="yes" xml:space="preserve">
          <source>Values for audio resources</source>
          <target state="translated">오디오 리소스의 가치</target>
        </trans-unit>
        <trans-unit id="d5707d69daa9b8c62fb80486ceff04ff21fd84f0" translate="yes" xml:space="preserve">
          <source>Values for scripts</source>
          <target state="translated">스크립트 값</target>
        </trans-unit>
        <trans-unit id="2b24d45fc35a156981b37ec34e29d99633f90ceb" translate="yes" xml:space="preserve">
          <source>Vary</source>
          <target state="translated">Vary</target>
        </trans-unit>
        <trans-unit id="9b2e108b3f882316723628f809864b1feb7974b4" translate="yes" xml:space="preserve">
          <source>Vary (RFC 2616)</source>
          <target state="translated">다양 함 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="e40dcd8515c2cf843fee10b24ff8980777ae7ffa" translate="yes" xml:space="preserve">
          <source>Vary (RFC 7231)</source>
          <target state="translated">다양 함 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="7b2b0d3e57119ab5faa1b67d5efd6c7de0e7f709" translate="yes" xml:space="preserve">
          <source>Vary with care &amp;ndash; Vary header problems in IE6-9</source>
          <target state="translated">주의 사항에 따라 다름 &amp;ndash; IE6-9의 다양한 문제</target>
        </trans-unit>
        <trans-unit id="19eb9e0947788d5d1d26e214c7f03629eeb827cb" translate="yes" xml:space="preserve">
          <source>Varying responses</source>
          <target state="translated">다양한 응답</target>
        </trans-unit>
        <trans-unit id="cd93e3881536fce26e72a7e663780b36bdbdb4a8" translate="yes" xml:space="preserve">
          <source>Version 3 (and probably earlier) of Firefox for Fire TV use a user agent string with the following format:</source>
          <target state="translated">Fire TV 용 Firefox 3 버전 (및 이전 버전)은 다음 형식의 사용자 에이전트 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a69e9865ae8f4c198fd5ee0e05c338894a1f0bbb" translate="yes" xml:space="preserve">
          <source>Version 7 of Focus for iOS uses a user agent string with the following format:</source>
          <target state="translated">Focus for iOS 버전 7은 다음 형식의 사용자 에이전트 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="38993cc538cc5926945d26ae695bf9289c5f5b16" translate="yes" xml:space="preserve">
          <source>Version number of the product.</source>
          <target state="translated">제품의 버전 번호입니다.</target>
        </trans-unit>
        <trans-unit id="297d1a34c5a91c3face08ee659f305e1a1a91054" translate="yes" xml:space="preserve">
          <source>Versioning information is now sent within each request (&lt;code&gt;HTTP/1.0&lt;/code&gt; is appended to the &lt;code&gt;GET&lt;/code&gt; line)</source>
          <target state="translated">버전 정보가 각 요청 내에서 전송됩니다 ( &lt;code&gt;HTTP/1.0&lt;/code&gt; 이 &lt;code&gt;GET&lt;/code&gt; 행 에 추가됨 )</target>
        </trans-unit>
        <trans-unit id="69a7be7d74e8b54ef69683eb73c3addbe24661a5" translate="yes" xml:space="preserve">
          <source>Via</source>
          <target state="translated">Via</target>
        </trans-unit>
        <trans-unit id="5efffb1f13385b4c17fcaf2a54ce6c61c3ffee1f" translate="yes" xml:space="preserve">
          <source>Via (RFC 2616)</source>
          <target state="translated">경유 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="600beac1ac4f104310961c0df27d3fda7e13e76a" translate="yes" xml:space="preserve">
          <source>Video data or files, such as MP4 movies (&lt;code&gt;video/mp4&lt;/code&gt;).</source>
          <target state="translated">MP4 영화 ( &lt;code&gt;video/mp4&lt;/code&gt; ) 와 같은 비디오 데이터 또는 파일 .</target>
        </trans-unit>
        <trans-unit id="876d409a2453771f3498295f0ec1ad8b311c1abe" translate="yes" xml:space="preserve">
          <source>Video formats on the Web are lossy and for images, &lt;code&gt;jpeg&lt;/code&gt; is.</source>
          <target state="translated">웹의 비디오 형식은 손실이 있으며 이미지의 경우 &lt;code&gt;jpeg&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b8e388ceed1411c403014aaf99cf7852f8214b26" translate="yes" xml:space="preserve">
          <source>Video formats on the Web are lossy; the &lt;code&gt;jpeg&lt;/code&gt; image format is also lossy.</source>
          <target state="translated">웹상의 비디오 형식은 손실이 있습니다. &lt;code&gt;jpeg&lt;/code&gt; 이미지 포맷은 손실된다.</target>
        </trans-unit>
        <trans-unit id="4aa07f2310615edb1b8aea001b9424df7324bc70" translate="yes" xml:space="preserve">
          <source>Violation case</source>
          <target state="translated">위반 사례</target>
        </trans-unit>
        <trans-unit id="e27cced9fe19bc714fee1a81671a7f569628e245" translate="yes" xml:space="preserve">
          <source>Violation cases</source>
          <target state="translated">위반 사례</target>
        </trans-unit>
        <trans-unit id="c496e3c34f0eba7e144fe804c7ad8671f57cafe2" translate="yes" xml:space="preserve">
          <source>Violation report syntax</source>
          <target state="translated">위반 보고서 구문</target>
        </trans-unit>
        <trans-unit id="d5008ff9b05d4e106caa52d46336fe823818f4b8" translate="yes" xml:space="preserve">
          <source>W3C Note: Editing the Web &amp;ndash; Detecting the Lost Update Problem Using Unreserved Checkout</source>
          <target state="translated">W3C 참고 : 웹 편집 &amp;ndash; 예약되지 않은 체크 아웃을 사용하여 손실 된 업데이트 문제 감지</target>
        </trans-unit>
        <trans-unit id="884f3317cb1124a8431120b58009200dca7a4d67" translate="yes" xml:space="preserve">
          <source>WEBM audio</source>
          <target state="translated">WEBM 오디오</target>
        </trans-unit>
        <trans-unit id="a9048e6f38bd6def914e8bc02c0c815e74aa6b31" translate="yes" xml:space="preserve">
          <source>WEBM video</source>
          <target state="translated">WEBM 비디오</target>
        </trans-unit>
        <trans-unit id="10d4da79ed320e304a4183b2724689aacff736ee" translate="yes" xml:space="preserve">
          <source>WEBP image</source>
          <target state="translated">WEBP 이미지</target>
        </trans-unit>
        <trans-unit id="91e15dfd33a8977326ec3048fffcf2851f9ab5d0" translate="yes" xml:space="preserve">
          <source>WWW-Authenticate</source>
          <target state="translated">WWW-Authenticate</target>
        </trans-unit>
        <trans-unit id="66096447ca6339831faa35cab2472b54e0d02b68" translate="yes" xml:space="preserve">
          <source>WWW-Authenticate (RFC 2616)</source>
          <target state="translated">WWW 인증 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="10ca8f25b6696fb63530265acb249b906a791bb0" translate="yes" xml:space="preserve">
          <source>WWW-Authenticate (RFC 7235)</source>
          <target state="translated">WWW 인증 (RFC 7235)</target>
        </trans-unit>
        <trans-unit id="f6d051699bd0f43788b5be58a23eb21f84335023" translate="yes" xml:space="preserve">
          <source>WWW-Authenticate and Proxy-Authenticate headers</source>
          <target state="translated">WWW-Authenticate 및 Proxy-Authenticate 헤더</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="be4d2f140ad1f885bd4fd65204345d7cda73e466" translate="yes" xml:space="preserve">
          <source>Warning (RFC 2616)</source>
          <target state="translated">경고 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="84bedb41c866653578afdf5c8ba922625099fff2" translate="yes" xml:space="preserve">
          <source>Warning (RFC 7234)</source>
          <target state="translated">경고 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="a947928bc7f59190ce4b3eb8f6b60da4b597dfb2" translate="yes" xml:space="preserve">
          <source>Warning codes</source>
          <target state="translated">경고 코드</target>
        </trans-unit>
        <trans-unit id="98d22e2da9720c80cb3f1a3c48430a5ba47ef6df" translate="yes" xml:space="preserve">
          <source>Was defined in a previous version of the HTTP specification to indicate that a requested response must be accessed by a proxy. It has been deprecated due to security concerns regarding in-band configuration of a proxy.</source>
          <target state="translated">프록시가 요청 된 응답에 액세스해야 함을 나타 내기 위해 이전 버전의 HTTP 사양에서 정의되었습니다. 프록시의 대역 내 구성과 관련된 보안 문제로 인해 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b65b1ec95e015e3a3a9a72a92184b75a39063c7e" translate="yes" xml:space="preserve">
          <source>Waveform Audio Format</source>
          <target state="translated">파형 오디오 형식</target>
        </trans-unit>
        <trans-unit id="3614aa76f325a8581f86ebecc652236220abab3a" translate="yes" xml:space="preserve">
          <source>Ways to mitigate attacks involving cookies:</source>
          <target state="translated">쿠키와 관련된 공격을 완화하는 방법 :</target>
        </trans-unit>
        <trans-unit id="c1ed8d07477aa173249b6733f07e79520338b110" translate="yes" xml:space="preserve">
          <source>We adopt a set of rules and recommendations for origin servers,
   clients, and caches regarding when various validator types ought to
   be used, and for what purposes.

   HTTP/1.1 origin servers:

      - SHOULD send an entity tag validator unless it is not feasible to
        generate one.

      - MAY send a weak entity tag instead of a strong entity tag, if
        performance considerations support the use of weak entity tags,
        or if it is unfeasible to send a strong entity tag.

      - SHOULD send a Last-Modified value if it is feasible to send one,
        unless the risk of a breakdown in semantic transparency that
        could result from using this date in an If-Modified-Since header
        would lead to serious problems.

   In other words, the preferred behavior for an HTTP/1.1 origin server
   is to send both a strong entity tag and a Last-Modified value.

   In order to be legal, a strong entity tag MUST change whenever the
   associated entity value changes in any way. A weak entity tag SHOULD
   change whenever the associated entity changes in a semantically
   significant way.

      Note: in order to provide semantically transparent caching, an
      origin server must avoid reusing a specific strong entity tag
      value for two different entities, or reusing a specific weak
      entity tag value for two semantically different entities. Cache
      entries might persist for arbitrarily long periods, regardless of
      expiration times, so it might be inappropriate to expect that a
      cache will never again attempt to validate an entry using a
      validator that it obtained at some point in the past.

   HTTP/1.1 clients:

      - If an entity tag has been provided by the origin server, MUST
        use that entity tag in any cache-conditional request (using If-
        Match or If-None-Match).

      - If only a Last-Modified value has been provided by the origin
        server, SHOULD use that value in non-subrange cache-conditional
        requests (using If-Modified-Since). 

      - If only a Last-Modified value has been provided by an HTTP/1.0
        origin server, MAY use that value in subrange cache-conditional
        requests (using If-Unmodified-Since:). The user agent SHOULD
        provide a way to disable this, in case of difficulty.

      - If both an entity tag and a Last-Modified value have been
        provided by the origin server, SHOULD use both validators in
        cache-conditional requests. This allows both HTTP/1.0 and
        HTTP/1.1 caches to respond appropriately.

   An HTTP/1.1 origin server, upon receiving a conditional request that
   includes both a Last-Modified date (e.g., in an If-Modified-Since or
   If-Unmodified-Since header field) and one or more entity tags (e.g.,
   in an If-Match, If-None-Match, or If-Range header field) as cache
   validators, MUST NOT return a response status of 304 (Not Modified)
   unless doing so is consistent with all of the conditional header
   fields in the request.

   An HTTP/1.1 caching proxy, upon receiving a conditional request that
   includes both a Last-Modified date and one or more entity tags as
   cache validators, MUST NOT return a locally cached response to the
   client unless that cached response is consistent with all of the
   conditional header fields in the request.

      Note: The general principle behind these rules is that HTTP/1.1
      servers and clients should transmit as much non-redundant
      information as is available in their responses and requests.
      HTTP/1.1 systems receiving this information will make the most
      conservative assumptions about the validators they receive.

      HTTP/1.0 clients and caches will ignore entity tags. Generally,
      last-modified values received or used by these systems will
      support transparent and efficient caching, and so HTTP/1.1 origin
      servers should provide Last-Modified values. In those rare cases
      where the use of a Last-Modified value as a validator by an
      HTTP/1.0 system could result in a serious problem, then HTTP/1.1
      origin servers should not provide one.</source>
          <target state="translated">다양한 유효성 검사기 유형을 사용해야 할시기와 목적에 대해 오리진 서버, 클라이언트 및 캐시에 대한 일련의 규칙과 권장 사항을 채택합니다. HTTP / 1.1 오리진 서버 :-엔티티 태그 검사기를 생성 할 수 없다면 엔티티 태그 검사기를 보내야한다. -성능 고려 사항이 취약한 엔티티 태그 사용을 지원하거나 강력한 엔티티 태그를 전송할 수없는 경우 강력한 엔티티 태그 대신 취약한 엔티티 태그를 전송할 수 있습니다. -If-Modified-Since 헤더에서이 날짜를 사용하여 발생할 수있는 의미 투명성의 고장 위험이 심각한 문제를 야기하지 않는 한, 전송 가능한 경우 Last-Modified 값을 보내야합니다. 다시 말해, HTTP / 1에 대해 선호되는 동작입니다.1 원 서버는 강력한 엔터티 태그와 Last-Modified 값을 모두 전송합니다. 합법적으로되기 위해서는 강력한 엔터티 태그가 관련 엔터티 값이 어떤 식 으로든 변경 될 때마다 변경되어야합니다. 약한 엔터티 태그는 관련 엔터티가 의미 적으로 중요한 방식으로 변경 될 때마다 변경되어야합니다. 참고 : 의미 적으로 투명한 캐싱을 제공하기 위해 오리진 서버는 서로 다른 두 엔티티에 대해 특정 강력한 엔티티 태그 값을 재사용하거나 의미 적으로 다른 두 엔티티에 대해 특정 취약한 엔티티 태그 값을 재사용하지 않아야합니다. 캐시 항목은 만료 시간에 관계없이 임의로 장기간 지속될 수 있으므로 캐시가 과거 어느 시점에서 얻은 유효성 검사기를 사용하여 항목의 유효성을 다시 검사하지 않을 것으로 예상 할 수 없습니다.HTTP / 1.1 클라이언트 :-오리진 서버가 엔티티 태그를 제공 한 경우 캐시 조건부 요청 (If- Match 또는 If-None-Match 사용)에서 해당 엔티티 태그를 사용해야합니다. -오리진 서버가 Last-Modified 값만 제공 한 경우, 하위 값이 아닌 캐시 조건부 요청에서 If-Modified-Since를 사용하여 해당 값을 사용해야합니다. -HTTP / 1.0 오리진 서버에서 Last-Modified 값만 제공 한 경우 하위 범위 캐시 조건부 요청에서 해당 값을 사용할 수 있습니다 (If-Unmodified-Since : 사용). 사용자 에이전트는 어려움이있을 경우이를 비활성화하는 방법을 제공해야합니다 (SHOULD). -오리진 서버가 엔티티 태그와 Last-Modified 값을 모두 제공 한 경우 캐시 조건부 요청에서 두 검증기를 모두 사용해야합니다. 이것은 HTTP / 1을 모두 허용합니다.적절하게 응답하기위한 0 및 HTTP / 1.1 캐시. 최종 수정 날짜 (예 : If-Modified-Since 또는 If-Unmodified-Since 헤더 필드)와 하나 이상의 엔티티 태그 (예 : 캐시 유효성 검사기 인 If-Match, If-None-Match 또는 If-Range 헤더 필드)는 요청의 모든 조건부 헤더 필드와 일치하지 않는 한 응답 상태 304 (수정되지 않음)를 반환해서는 안됩니다. 캐시 수정 자로 Last-Modified 날짜와 하나 이상의 엔티티 태그를 모두 포함하는 조건부 요청을 수신 한 HTTP / 1.1 캐싱 프록시는 캐시 된 응답이 모든 캐시와 일치하지 않는 한 클라이언트에 로컬로 캐시 된 응답을 반환해서는 안됩니다 (MUST NOT). 요청의 조건부 헤더 필드 노트 :이러한 규칙의 기본 원리는 HTTP / 1.1 서버 및 클라이언트가 응답 및 요청에서 사용 가능한 한 많은 비 중복 정보를 전송해야한다는 것입니다. 이 정보를받는 HTTP / 1.1 시스템은 그들이받는 검증 자에 대해 가장 보수적 인 가정을 할 것입니다. HTTP / 1.0 클라이언트 및 캐시는 엔티티 태그를 무시합니다. 일반적으로 이러한 시스템에서 수신하거나 사용하는 마지막 수정 된 값은 투명하고 효율적인 캐싱을 지원하므로 HTTP / 1.1 오리진 서버는 Last-Modified 값을 제공해야합니다. HTTP / 1.0 시스템에서 Last-Modified 값을 유효성 검증기로 사용하면 심각한 문제점이 발생할 수있는 드문 경우에는 HTTP / 1.1 오리진 서버가이를 제공하지 않아야합니다.1 서버와 클라이언트는 응답 및 요청에서 사용할 수있는만큼 비 중복 정보를 전송해야합니다. 이 정보를받는 HTTP / 1.1 시스템은 그들이받는 검증 자에 대해 가장 보수적 인 가정을 할 것입니다. HTTP / 1.0 클라이언트 및 캐시는 엔티티 태그를 무시합니다. 일반적으로 이러한 시스템에서 수신하거나 사용하는 마지막 수정 된 값은 투명하고 효율적인 캐싱을 지원하므로 HTTP / 1.1 오리진 서버는 Last-Modified 값을 제공해야합니다. HTTP / 1.0 시스템에서 Last-Modified 값을 유효성 검증기로 사용하면 심각한 문제점이 발생할 수있는 드문 경우에는 HTTP / 1.1 오리진 서버가이를 제공하지 않아야합니다.1 서버와 클라이언트는 응답 및 요청에서 사용할 수있는만큼 비 중복 정보를 전송해야합니다. 이 정보를받는 HTTP / 1.1 시스템은 그들이받는 검증 자에 대해 가장 보수적 인 가정을 할 것입니다. HTTP / 1.0 클라이언트 및 캐시는 엔티티 태그를 무시합니다. 일반적으로 이러한 시스템에서 수신하거나 사용하는 마지막 수정 된 값은 투명하고 효율적인 캐싱을 지원하므로 HTTP / 1.1 오리진 서버는 Last-Modified 값을 제공해야합니다. HTTP / 1.0 시스템에서 Last-Modified 값을 유효성 검증기로 사용하면 심각한 문제점이 발생할 수있는 드문 경우에는 HTTP / 1.1 오리진 서버가이를 제공하지 않아야합니다.이 정보를받는 1 개의 시스템은 그들이받는 검증 자에 대해 가장 보수적 인 가정을 할 것입니다. HTTP / 1.0 클라이언트 및 캐시는 엔티티 태그를 무시합니다. 일반적으로 이러한 시스템에서 수신하거나 사용하는 마지막 수정 값은 투명하고 효율적인 캐싱을 지원하므로 HTTP / 1.1 오리진 서버는 Last-Modified 값을 제공해야합니다. HTTP / 1.0 시스템에서 Last-Modified 값을 유효성 검증기로 사용하면 심각한 문제점이 발생할 수있는 드문 경우에는 HTTP / 1.1 오리진 서버가이를 제공하지 않아야합니다.이 정보를받는 1 개의 시스템은 그들이받는 검증 자에 대해 가장 보수적 인 가정을 할 것입니다. HTTP / 1.0 클라이언트 및 캐시는 엔티티 태그를 무시합니다. 일반적으로 이러한 시스템에서 수신하거나 사용하는 마지막 수정 값은 투명하고 효율적인 캐싱을 지원하므로 HTTP / 1.1 오리진 서버는 Last-Modified 값을 제공해야합니다. HTTP / 1.0 시스템에서 Last-Modified 값을 유효성 검증기로 사용하면 심각한 문제점이 발생할 수있는 드문 경우에는 HTTP / 1.1 오리진 서버가이를 제공하지 않아야합니다.이러한 시스템에서 수신하거나 사용하는 마지막 수정 된 값은 투명하고 효율적인 캐싱을 지원하므로 HTTP / 1.1 오리진 서버는 Last-Modified 값을 제공해야합니다. HTTP / 1.0 시스템에서 Last-Modified 값을 유효성 검증기로 사용하면 심각한 문제점이 발생할 수있는 드문 경우에는 HTTP / 1.1 오리진 서버가이를 제공하지 않아야합니다.이러한 시스템에서 수신하거나 사용하는 마지막 수정 된 값은 투명하고 효율적인 캐싱을 지원하므로 HTTP / 1.1 오리진 서버는 Last-Modified 값을 제공해야합니다. HTTP / 1.0 시스템에서 Last-Modified 값을 유효성 검증기로 사용하면 심각한 문제점이 발생할 수있는 드문 경우에는 HTTP / 1.1 오리진 서버가이를 제공하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="cbefa43c4244c9659990b7c712219c66a3ed30c8" translate="yes" xml:space="preserve">
          <source>We can request a single range from a resource. Again, we can test a request by using cURL. The &quot;&lt;code&gt;-H&lt;/code&gt;&quot; option will append a header line to the request, which in this case is the &lt;code&gt;Range&lt;/code&gt; header requesting the first 1024 bytes.</source>
          <target state="translated">리소스에서 단일 범위를 요청할 수 있습니다. 다시 cURL을 사용하여 요청을 테스트 할 수 있습니다. &quot; &lt;code&gt;-H&lt;/code&gt; &quot;옵션은 요청에 헤더 행을 추가하며,이 경우 첫 번째 1024 바이트를 요청하는 &lt;code&gt;Range&lt;/code&gt; 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="b6a9bbf12e8ee0277600f2ecdeea60a7f6ed55e7" translate="yes" xml:space="preserve">
          <source>We present three scenarios that demonstrate how Cross-Origin Resource Sharing works. All these examples use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;, which can make cross-site requests in any supporting browser.</source>
          <target state="translated">교차 출처 리소스 공유가 작동하는 방식을 보여주는 세 가지 시나리오를 제시합니다. 이 모든 예제는 지원되는 모든 브라우저에서 교차 사이트 요청을 할 수있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; 를&lt;/a&gt; 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="c36fd34ea11996b6fcd900ac461a83c9aca72d5f" translate="yes" xml:space="preserve">
          <source>Weak validation</source>
          <target state="translated">약한 검증</target>
        </trans-unit>
        <trans-unit id="1bbd54b41e2dcd60140061474c56461a3b1017b8" translate="yes" xml:space="preserve">
          <source>Weak validation differs from strong validation, as it considers two versions of the document as identical if the content is equivalent. For example, a page that would differ from another only by a different date in its footer, or different advertising, would be considered &lt;em&gt;identical&lt;/em&gt; to the other with weak validation. These same two versions are considered &lt;em&gt;different&lt;/em&gt; when using strong validation. Building a system of etags that creates weak validation may be complex, as it involves knowing the importance of the different elements of a page, but is very useful towards optimizing cache performance.</source>
          <target state="translated">약한 유효성 검사는 내용이 동일한 경우 두 버전의 문서가 동일하다고 간주되므로 강력한 유효성 검사와 다릅니다. 예를 들어 바닥 글에서 다른 날짜 또는 다른 광고로만 다른 페이지와 다른 페이지는 유효성이 약한 페이지와 &lt;em&gt;동일한&lt;/em&gt; 것으로 간주됩니다 . 이 두 버전은 &lt;em&gt;다른&lt;/em&gt; 것으로 간주됩니다&lt;em&gt;&lt;/em&gt;강력한 유효성 검사를 사용할 때 됩니다. 약한 유효성 검사를 생성하는 etag 시스템을 구축하는 것은 페이지의 여러 요소의 중요성을 알아야하기 때문에 복잡 할 수 있지만 캐시 성능을 최적화하는 데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="81b0091d349f7e8dabfa6f00aa81829d266ffe7f" translate="yes" xml:space="preserve">
          <source>Weak versus Strong (RFC 7232)</source>
          <target state="translated">약한 대 강한 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="846bec671d05b4a9c57d268a32b9ca23d81cc1ef" translate="yes" xml:space="preserve">
          <source>Web Fonts (for cross-domain font usage in &lt;code&gt;@font-face&lt;/code&gt; within CSS), &lt;a href=&quot;https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements&quot;&gt;so that servers can deploy TrueType fonts that can only be cross-site loaded and used by web sites that are permitted to do so.&lt;/a&gt;</source>
          <target state="translated">웹 글꼴 ( CSS 내의 &lt;code&gt;@font-face&lt;/code&gt; 에서 도메인 간 글꼴 사용 ) &lt;a href=&quot;https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements&quot;&gt;을 통해 서버는 사이트 간로드 만 허용되고 웹 사이트에서 허용되는 트루 타입 글꼴을 배포 할 수 있습니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="176255fee5b73645d93cc65c9bf7cc53c9096411" translate="yes" xml:space="preserve">
          <source>Web Linking</source>
          <target state="translated">웹 링크</target>
        </trans-unit>
        <trans-unit id="7fde211ec2ffa63e011d15d658c6456ee3361232" translate="yes" xml:space="preserve">
          <source>Web Open Font Format (WOFF)</source>
          <target state="translated">웹 열기 글꼴 형식 (WOFF)</target>
        </trans-unit>
        <trans-unit id="5f3f450e346fdae22197c1f6b75eaf5e058000c1" translate="yes" xml:space="preserve">
          <source>Web Picture format</source>
          <target state="translated">웹 사진 형식</target>
        </trans-unit>
        <trans-unit id="91d14f7b44c057d129ff61e05ff9ce4d6f2fc29a" translate="yes" xml:space="preserve">
          <source>Web Share API</source>
          <target state="translated">웹 공유 API</target>
        </trans-unit>
        <trans-unit id="bd59440b016b6287e24e59a96a86e62ba9ba00ba" translate="yes" xml:space="preserve">
          <source>Web app manifest</source>
          <target state="translated">웹앱 매니페스트</target>
        </trans-unit>
        <trans-unit id="bda95fb3fa91f3d265697fb24bb06ea2572d20c9" translate="yes" xml:space="preserve">
          <source>Web developers invented a technique that Steve Souders called &lt;em&gt;revving&lt;/em&gt;&lt;sup&gt;&lt;a href=&quot;https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Infrequently updated files are named in a specific way: in their URL, usually in the filename, a revision (or version) number is added. That way each new revision of this resource is considered as a resource on its own that &lt;em&gt;never&lt;/em&gt; changes and that can have an expiration time very far in the future, usually one year or even more. In order to have the new versions, all the links to them must be changed, that is the drawback of this method: additional complexity that is usually taken care of by the tool chain used by Web developers. When the infrequently variable resources change they induce an additional change to often variable resources. When these are read, the new versions of the others are also read.</source>
          <target state="translated">웹 개발자는 Steve Souders가 &lt;em&gt;revving &lt;/em&gt;&lt;sup&gt;&lt;a href=&quot;https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; 이라고 부르는 기술을 발명했습니다 . 자주 업데이트되지 않는 파일은 특정 방식으로 이름이 지정됩니다. URL, 일반적으로 파일 이름에 개정 (또는 버전) 번호가 추가됩니다. 이렇게하면이 리소스의 각각의 새로운 개정은 &lt;em&gt;결코&lt;/em&gt; 변경 매우 먼 미래, 일반적으로 1 년 이상이 될 수 있습니다. 새 버전을 가지려면 모든 링크를 변경해야합니다. 이것이이 방법의 단점입니다. 일반적으로 웹 개발자가 사용하는 도구 체인에서 처리하는 추가 복잡성입니다. 드물게 가변적 인 자원이 변경되면 종종 가변 자원에 대한 추가 변경을 유도합니다. 이들을 읽을 때 다른 버전의 새 버전도 읽습니다.</target>
        </trans-unit>
        <trans-unit id="4aae5e4ef23e3484617aad036f6f0942d85a4a3d" translate="yes" xml:space="preserve">
          <source>Web developers invented a technique that Steve Souders called &lt;em&gt;revving&lt;/em&gt;&lt;sup&gt;&lt;a href=&quot;https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Infrequently updated files are named in specific way: in their URL, usually in the filename, a revision (or version) number is added. That way each new revision of this resource is considered as a resource on its own that &lt;em&gt;never&lt;/em&gt; changes and that can have an expiration time very far in the future, usually one year or even more. In order to have the new versions, all the links to them must be changed, that is the drawback of this method: additional complexity that is usually taken care of by the tool chain used by Web developers. When the infrequently variable resources change they induce an additional change to often variable resources. When these are read, the new versions of the others are also read.</source>
          <target state="translated">웹 개발자는 Steve Souders가 &lt;em&gt;revving&lt;/em&gt; 이라고 부르는 기술을 개발했습니다 &lt;sup&gt;&lt;a href=&quot;https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; . 자주 업데이트되지 않는 파일은 특정 방식으로 이름이 지정됩니다. URL, 일반적으로 파일 이름에 개정 (또는 버전) 번호가 추가됩니다. 그렇게하면이 자원의 각 새로운 개정판은 그 자체로는 &lt;em&gt;결코&lt;/em&gt; 자원이 아닌 자원으로 간주됩니다&lt;em&gt;&lt;/em&gt;변경 사항은 향후 1 년 또는 그 이상까지 만료 시간이 매우 길어질 수 있습니다. 새 버전을 사용하려면 웹 개발자가 사용하는 툴 체인에 의해 처리되는 추가 복잡성 인이 방법의 단점 인 새 버전에 대한 모든 링크를 변경해야합니다. 드물게 가변 자원이 변경 될 때 종종 가변 자원에 대한 추가 변경을 유도합니다. 이것들을 읽을 때, 다른 것의 새로운 버전도 읽습니다.</target>
        </trans-unit>
        <trans-unit id="c70b0ff6920fb5d4f64386ac826550f70e1ff8e1" translate="yes" xml:space="preserve">
          <source>Web developers, or webmasters, rarely craft these textual HTTP messages themselves: software, a Web browser, proxy, or Web server, perform this action. They provide HTTP messages through config files (for proxies or servers), APIs (for browsers), or other interfaces.</source>
          <target state="translated">웹 개발자 나 웹 마스터는 이러한 텍스트 HTTP 메시지 자체를 거의 만들지 않습니다. 소프트웨어, 웹 브라우저, 프록시 또는 웹 서버는이 작업을 수행합니다. 구성 파일 (프록시 또는 서버용), API (브라우저 용) 또는 기타 인터페이스를 통해 HTTP 메시지를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8d4119ff2982c9f860674f920c336448cc016413" translate="yes" xml:space="preserve">
          <source>Web media technologies</source>
          <target state="translated">웹 미디어 기술</target>
        </trans-unit>
        <trans-unit id="83eb70bb9b9c1cc810a2c336b4e785e9b89447dd" translate="yes" xml:space="preserve">
          <source>Web sites can easily collect Firefox default preferences by overriding this &lt;code&gt;pref()&lt;/code&gt; function and using the script &lt;code&gt;resource:///defaults/preferences/firefox.js&lt;/code&gt;.</source>
          <target state="translated">웹 사이트는이 &lt;code&gt;pref()&lt;/code&gt; 함수 를 재정의 하고 &lt;code&gt;resource:///defaults/preferences/firefox.js&lt;/code&gt; 스크립트를 사용하여 Firefox 기본 환경 설정을 쉽게 수집 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="051061c35dede06e751f127657cfd8dabc9b47ce" translate="yes" xml:space="preserve">
          <source>WebAssembly</source>
          <target state="translated">WebAssembly</target>
        </trans-unit>
        <trans-unit id="e993b7a84cae2379869728d12f4d33cde0391ee7" translate="yes" xml:space="preserve">
          <source>WebDAV provides the ability to send a LOCK request to an unmapped URL
   in order to reserve the name for use.  This is a simple way to avoid
   the lost-update problem on the creation of a new resource (another
   way is to use If-None-Match header specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.26&quot;&gt;Section&amp;nbsp;14.26 of
   [RFC2616]&lt;/a&gt;).  It has the side benefit of locking the new resource
   immediately for use of the creator.

   Note that the lost-update problem is not an issue for collections
   because MKCOL can only be used to create a collection, not to
   overwrite an existing collection.  When trying to lock a collection
   upon creation, clients can attempt to increase the likelihood of
   getting the lock by pipelining the MKCOL and LOCK requests together
   (but because this doesn't convert two separate operations into one
   atomic operation, there's no guarantee this will work).

   A successful lock request to an unmapped URL MUST result in the
   creation of a locked (non-collection) resource with empty content.
   Subsequently, a successful PUT request (with the correct lock token)
   provides the content for the resource.  Note that the LOCK request
   has no mechanism for the client to provide Content-Type or Content-
   Language, thus the server will use defaults or empty values and rely
   on the subsequent PUT request for correct values.

   A resource created with a LOCK is empty but otherwise behaves in
   every way as a normal resource.  It behaves the same way as a
   resource created by a PUT request with an empty body (and where a
   Content-Type and Content-Language was not specified), followed by a
   LOCK request to the same resource.  Following from this model, a
   locked empty resource:

   o  Can be read, deleted, moved, and copied, and in all ways behaves
      as a regular non-collection resource.

   o  Appears as a member of its parent collection.

   o  SHOULD NOT disappear when its lock goes away (clients must
      therefore be responsible for cleaning up their own mess, as with
      any other operation or any non-empty resource). 

   o  MAY NOT have values for properties like DAV:getcontentlanguage
      that haven't been specified yet by the client.

   o  Can be updated (have content added) with a PUT request.

   o  MUST NOT be converted into a collection.  The server MUST fail a
      MKCOL request (as it would with a MKCOL request to any existing
      non-collection resource).

   o  MUST have defined values for DAV:lockdiscovery and DAV:
      supportedlock properties.

   o  The response MUST indicate that a resource was created, by use of
      the &quot;201 Created&quot; response code (a LOCK request to an existing
      resource instead will result in 200 OK).  The body must still
      include the DAV:lockdiscovery property, as with a LOCK request to
      an existing resource.

   The client is expected to update the locked empty resource shortly
   after locking it, using PUT and possibly PROPPATCH.

   Alternatively and for backwards compatibility to [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;], servers
   MAY implement Lock-Null Resources (LNRs) instead (see definition in
   &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt;).  Clients can easily interoperate both with servers that
   support the old model LNRs and the recommended model of &quot;locked empty
   resources&quot; by only attempting PUT after a LOCK to an unmapped URL,
   not MKCOL or GET, and by not relying on specific properties of LNRs.</source>
          <target state="translated">WebDAV는 사용할 이름을 예약하기 위해 매핑되지 않은 URL에 LOCK 요청을 보내는 기능을 제공합니다. 이것은 새로운 리소스를 만들 때 업데이트 손실 문제를 피하는 간단한 방법입니다 (또 다른 방법은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.26&quot;&gt;[RFC2616] 14.26 절에&lt;/a&gt; 지정된 If-None-Match 헤더를 사용하는 것입니다 )). 작성자를 사용하기 위해 새 자원을 즉시 잠그는 이점이 있습니다. MKCOL은 기존 컬렉션을 덮어 쓰지 않고 컬렉션을 만드는 데만 사용할 수 있기 때문에 업데이트 손실 문제는 컬렉션에 문제가되지 않습니다. 생성시 컬렉션을 잠그려고 할 때 클라이언트는 MKCOL과 LOCK 요청을 함께 파이프 라인하여 잠금을 획득 할 가능성을 높일 수 있습니다 (그러나 이것은 두 개의 개별 연산을 하나의 원자 연산으로 변환하지 않기 때문에 이것이 작동한다는 보장은 없습니다 ). 매핑되지 않은 URL에 대한 잠금 요청이 성공하면 빈 내용으로 잠긴 (수집되지 않은) 리소스가 생성되어야합니다. 후속 적으로, 올바른 잠금 토큰을 가진 성공적인 PUT 요청은 자원의 컨텐츠를 제공합니다.LOCK 요청에는 클라이언트가 Content-Type 또는 Content-Language를 제공 ​​할 수있는 메커니즘이 없으므로 서버는 기본값 또는 빈 값을 사용하고 올바른 값을 위해 후속 PUT 요청에 의존합니다. LOCK으로 작성된 자원은 비어 있지만 모든 방식으로 일반 자원으로 작동합니다. 빈 본문 (및 Content-Type 및 Content-Language가 지정되지 않은)이있는 PUT 요청에 의해 생성 된 리소스와 동일한 방식으로 작동 한 다음 동일한 리소스에 대한 LOCK 요청이 수행됩니다. 이 모델에서 비어있는 빈 리소스는 다음과 같습니다. o 읽기, 삭제, 이동 및 복사가 가능하며 모든 방법으로 일반 비 수집 리소스로 작동합니다. o 부모 컬렉션의 구성원으로 나타납니다.o 잠금이 해제 될 때 사라지지 않아야합니다 (따라서 클라이언트는 다른 작업이나 비어 있지 않은 리소스와 마찬가지로 자신의 혼란을 정리해야합니다). o 클라이언트가 아직 지정하지 않은 DAV : getcontentlanguage와 같은 속성 값을 가질 수 없습니다. PUT 요청으로 업데이트 (컨텐츠 추가) 할 수 있습니다. o 컬렉션으로 변환해서는 안됩니다. 서버는 (기존의 비 수집 자원에 대한 MKCOL 요청과 마찬가지로) MKCOL 요청에 실패해야합니다. o DAV : lockdiscovery 및 DAV : supportedlock 속성에 대한 값을 정의해야합니다. o 응답은 &quot;201 Created&quot;응답 코드를 사용하여 리소스가 생성되었음을 나타내야합니다 (기존 리소스에 대한 LOCK 요청은 200이됩니다).기존 자원에 대한 잠금 요청과 같이 본문에는 여전히 DAV : lockdiscovery 특성이 포함되어 있어야합니다. 클라이언트는 PUT 및 가능하면 PROPPATCH를 사용하여 잠긴 빈 자원을 잠근 직후 업데이트해야합니다. 또는 이전 버전과의 호환성을 위해 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; ], 서버는 대신 LNR (Lock-Null Resources)을 구현할 수 있습니다 ( &lt;a href=&quot;#appendix-D&quot;&gt;부록 D의&lt;/a&gt; 정의 참조 ). 클라이언트는 MKCOL 또는 GET이 아닌 매핑되지 않은 URL에 대한 잠금 후 PUT을 시도하고 LNR의 특정 속성에 의존하지 않음으로써 이전 모델 LNR을 지원하는 서버와 권장되는 &quot;잠긴 빈 리소스&quot;모델과 쉽게 상호 운용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a23e5cc615236bc8c759c172e1a9673963c88638" translate="yes" xml:space="preserve">
          <source>WebDAV provides, through the PROPFIND method, a mechanism for listing
   the member resources of a collection.  This greatly diminishes the
   effectiveness of security or privacy techniques that rely only on the
   difficulty of discovering the names of network resources.  Users of
   WebDAV servers are encouraged to use access control techniques to
   prevent unwanted access to resources, rather than depending on the
   relative obscurity of their resource names.</source>
          <target state="translated">WebDAV는 PROPFIND 메소드를 통해 콜렉션의 멤버 자원을 나열하는 메커니즘을 제공합니다. 이는 네트워크 리소스의 이름을 찾기가 어려운 보안 또는 개인 정보 보호 기술의 효율성을 크게 떨어 뜨립니다. WebDAV 서버 사용자는 리소스 이름의 상대적인 모호성에 의존하기보다는 액세스 제어 기술을 사용하여 리소스에 대한 원치 않는 액세스를 방지하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f85551b99b1731274ca28a740445b7fb39846ad8" translate="yes" xml:space="preserve">
          <source>WebDAV was designed to be, and has been found to be, backward-
   compatible with HTTP 1.1.  The PUT and DELETE methods are defined in
   HTTP and thus may be used by HTTP clients as well as WebDAV-aware
   clients, but the responses to PUT and DELETE have been extended in
   this specification in ways that only a WebDAV client would be
   entirely prepared for.  Some theoretical concerns were raised about
   whether those responses would cause interoperability problems with
   HTTP-only clients, and this section addresses those concerns.

   Since any HTTP client ought to handle unrecognized 400-level and 500-
   level status codes as errors, the following new status codes should
   not present any issues: 422, 423, and 507 (424 is also a new status
   code but it appears only in the body of a Multistatus response.)  So,
   for example, if an HTTP client attempted to PUT or DELETE a locked
   resource, the 423 Locked response ought to result in a generic error
   presented to the user.

   The 207 Multistatus response is interesting because an HTTP client
   issuing a DELETE request to a collection might interpret a 207
   response as a success, even though it does not realize the resource
   is a collection and cannot understand that the DELETE operation might
   have been a complete or partial failure.  That interpretation isn't
   entirely justified, because a 200-level response indicates that the
   server &quot;received, understood, and accepted&quot; the request, not that the
   request resulted in complete success.

   One option is that a server could treat a DELETE of a collection as
   an atomic operation, and use either 204 No Content in case of
   success, or some appropriate error response (400 or 500 level) for an
   error.  This approach would indeed maximize backward compatibility.
   However, since interoperability tests and working group discussions
   have not turned up any instances of HTTP clients issuing a DELETE
   request against a WebDAV collection, this concern is more theoretical
   than practical.  Thus, servers are likely to be completely successful
   at interoperating with HTTP clients even if they treat any collection
   DELETE request as a WebDAV request and send a 207 Multi-Status
   response.

   In general, server implementations are encouraged to use the detailed
   responses and other mechanisms defined in this document rather than
   make changes for theoretical interoperability concerns.</source>
          <target state="translated">WebDAV는 HTTP 1.1과 역 호환되도록 설계되었습니다. PUT 및 DELETE 메소드는 HTTP로 정의되므로 WebDAV 인식 클라이언트뿐만 아니라 HTTP 클라이언트에서도 사용할 수 있지만 PUT 및 DELETE에 대한 응답은 WebDAV 클라이언트 만 완전히 준비 할 수 있도록이 스펙에서 확장되었습니다. . 이러한 응답이 HTTP 전용 클라이언트와의 상호 운용성 문제를 유발하는지 여부에 대한 일부 이론적 우려가 제기되었으며이 섹션에서는 이러한 문제를 해결합니다. HTTP 클라이언트는 인식 할 수없는 400 수준 및 500 수준 상태 코드를 오류로 처리해야하므로 다음과 같은 새로운 상태 코드는 문제를 나타내지 않아야합니다. 422, 423 및 507 (424는 새로운 상태 코드이지만 예를 들어 Multistatus 응답의 본문입니다.HTTP 클라이언트가 잠긴 자원을 PUT하거나 삭제하려고 시도한 경우, 423 잠금 응답은 일반 오류를 사용자에게 표시해야합니다. 207 Multistatus 응답은 컬렉션에 DELETE 요청을 발행하는 HTTP 클라이언트가 207 응답을 성공으로 해석 할 수 있지만 자원이 콜렉션임을 인식하지 못하고 DELETE 조작이 완료되었거나 부분 고장. 200 수준의 응답이 서버가 요청을 &quot;수신, 이해 및 수락&quot;했음을 나타 내기 때문에 그 해석이 전적으로 정당화되지는 않습니다. 한 가지 옵션은 서버가 컬렉션의 DELETE를 원 자성 작업으로 취급하고 성공시 204 No Content를 사용할 수 있다는 것입니다.또는 오류에 대한 적절한 오류 응답 (400 또는 500 레벨). 이 접근법은 실제로 이전 버전과의 호환성을 최대화합니다. 그러나 상호 운용성 테스트 및 작업 그룹 토론에서 WebDAV 콜렉션에 대해 DELETE 요청을 발행하는 HTTP 클라이언트 인스턴스가 나타나지 않았으므로이 문제는 실제적인 것보다 더 이론적입니다. 따라서 서버는 컬렉션 삭제 요청을 WebDAV 요청으로 취급하고 207 다중 상태 응답을 보내더라도 HTTP 클라이언트와의 상호 운용에 완전히 성공할 것입니다. 일반적으로 서버 구현에서는 이론적 상호 운용성 문제를 변경하기보다는이 문서에 정의 된 세부 응답 및 기타 메커니즘을 사용하는 것이 좋습니다.이 접근법은 실제로 이전 버전과의 호환성을 최대화합니다. 그러나 상호 운용성 테스트 및 작업 그룹 토론에서 WebDAV 콜렉션에 대해 DELETE 요청을 발행하는 HTTP 클라이언트 인스턴스가 나타나지 않았으므로이 문제는 실제적인 것보다 더 이론적입니다. 따라서 서버는 컬렉션 삭제 요청을 WebDAV 요청으로 취급하고 207 다중 상태 응답을 보내더라도 HTTP 클라이언트와의 상호 운용에 완전히 성공할 수 있습니다. 일반적으로 서버 구현에서는 이론적 상호 운용성 문제를 변경하기보다는이 문서에 정의 된 세부 응답 및 기타 메커니즘을 사용하는 것이 좋습니다.이 접근법은 실제로 이전 버전과의 호환성을 최대화합니다. 그러나 상호 운용성 테스트 및 작업 그룹 토론에서 WebDAV 콜렉션에 대해 DELETE 요청을 발행하는 HTTP 클라이언트 인스턴스가 나타나지 않았으므로이 문제는 실제적인 것보다 더 이론적입니다. 따라서 서버는 컬렉션 삭제 요청을 WebDAV 요청으로 취급하고 207 다중 상태 응답을 보내더라도 HTTP 클라이언트와의 상호 운용에 완전히 성공할 수 있습니다. 일반적으로 서버 구현에서는 이론적 상호 운용성 문제를 변경하기보다는이 문서에 정의 된 세부 응답 및 기타 메커니즘을 사용하는 것이 좋습니다.상호 운용성 테스트 및 작업 그룹 토론에서 WebDAV 콜렉션에 대해 DELETE 요청을 발행하는 HTTP 클라이언트 인스턴스가 나타나지 않았으므로이 문제는 실제적인 것보다 이론적 인 것입니다. 따라서 서버는 컬렉션 삭제 요청을 WebDAV 요청으로 취급하고 207 다중 상태 응답을 보내더라도 HTTP 클라이언트와의 상호 운용에 완전히 성공할 것입니다. 일반적으로 서버 구현에서는 이론적 상호 운용성 문제를 변경하기보다는이 문서에 정의 된 세부 응답 및 기타 메커니즘을 사용하는 것이 좋습니다.상호 운용성 테스트 및 작업 그룹 토론에서 WebDAV 콜렉션에 대해 DELETE 요청을 발행하는 HTTP 클라이언트 인스턴스가 나타나지 않았으므로이 문제는 실제적인 것보다 이론적 인 것입니다. 따라서 서버는 컬렉션 삭제 요청을 WebDAV 요청으로 취급하고 207 다중 상태 응답을 보내더라도 HTTP 클라이언트와의 상호 운용에 완전히 성공할 것입니다. 일반적으로 서버 구현에서는 이론적 상호 운용성 문제를 변경하기보다는이 문서에 정의 된 세부 응답 및 기타 메커니즘을 사용하는 것이 좋습니다.서버는 콜렉션 DELETE 요청을 WebDAV 요청으로 취급하고 207 다중 상태 응답을 보내더라도 HTTP 클라이언트와의 상호 운용에 완전히 성공할 수 있습니다. 일반적으로 서버 구현에서는 이론적 상호 운용성 문제를 변경하기보다는이 문서에 정의 된 세부 응답 및 기타 메커니즘을 사용하는 것이 좋습니다.서버는 콜렉션 DELETE 요청을 WebDAV 요청으로 취급하고 207 다중 상태 응답을 보내더라도 HTTP 클라이언트와의 상호 운용에 완전히 성공할 수 있습니다. 일반적으로 서버 구현에서는 이론적 상호 운용성 문제를 변경하기보다는이 문서에 정의 된 세부 응답 및 기타 메커니즘을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3eebce6ea96f9e6c03e9252a4f8ef2ea9fe141c2" translate="yes" xml:space="preserve">
          <source>WebKit</source>
          <target state="translated">WebKit</target>
        </trans-unit>
        <trans-unit id="3cc12f1bec20e52cab0b97341d3c02b8d6b5a8e7" translate="yes" xml:space="preserve">
          <source>WebKit-based (Android, Safari)</source>
          <target state="translated">WebKit 기반 (Android, Safari)</target>
        </trans-unit>
        <trans-unit id="6cd48f2561ad5a0df1f54b2512998a473f410b84" translate="yes" xml:space="preserve">
          <source>WebKit: &lt;a href=&quot;https://bugs.webkit.org/show_bug.cgi?id=165508&quot;&gt;Issue 165508&lt;/a&gt;</source>
          <target state="translated">WebKit : &lt;a href=&quot;https://bugs.webkit.org/show_bug.cgi?id=165508&quot;&gt;문제 165508&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6fa39ac0c7eff59abc27629413eef3a672293245" translate="yes" xml:space="preserve">
          <source>WebP</source>
          <target state="translated">WebP</target>
        </trans-unit>
        <trans-unit id="e5b42921cd81579fb4373d4c9301a0b48c00c221" translate="yes" xml:space="preserve">
          <source>WebSQL databases,</source>
          <target state="translated">WebSQL 데이터베이스</target>
        </trans-unit>
        <trans-unit id="02a11319d4ec575e7c0cfcc8b345785648d8021d" translate="yes" xml:space="preserve">
          <source>WebSocket API</source>
          <target state="translated">WebSocket API</target>
        </trans-unit>
        <trans-unit id="135a771b27602deda1493cda4d44fa69a76c0314" translate="yes" xml:space="preserve">
          <source>WebSocket connections (Secure)</source>
          <target state="translated">WebSocket 연결 (보안)</target>
        </trans-unit>
        <trans-unit id="e4ca95fd7fee5486bad6b0d54e93172855ee31dd" translate="yes" xml:space="preserve">
          <source>WebSocket-specific headers</source>
          <target state="translated">WebSocket 관련 헤더</target>
        </trans-unit>
        <trans-unit id="56d0e53e6a7114caaeb10b3ceba94b42ba2520e2" translate="yes" xml:space="preserve">
          <source>WebSockets</source>
          <target state="translated">WebSockets</target>
        </trans-unit>
        <trans-unit id="d5b3205d2f50f8459df98f434927a9961edb8576" translate="yes" xml:space="preserve">
          <source>WebVR 1.1</source>
          <target state="translated">WebVR 1.1</target>
        </trans-unit>
        <trans-unit id="494fbe1ebcf39962e071a464fdd0df350d08593e" translate="yes" xml:space="preserve">
          <source>WebVR API was never enabled by default in any production builds and was replaced by WebXR Device API.</source>
          <target state="translated">WebVR API는 프로덕션 빌드에서 기본적으로 활성화되지 않았으며 WebXR 장치 API로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="a1e76aac4eddc8812e45c58b46f8b12f9b9860da" translate="yes" xml:space="preserve">
          <source>What Does the &quot;Track&quot; in &quot;Do Not Track&quot; Mean? &amp;ndash; EFF</source>
          <target state="translated">&quot;추적하지 않음&quot;의 &quot;추적&quot;이란 무엇입니까? &amp;ndash; EFF</target>
        </trans-unit>
        <trans-unit id="6a8f52f9ef8f506e4398a41c7de6a771321653bb" translate="yes" xml:space="preserve">
          <source>What are domain names?</source>
          <target state="translated">도메인 이름은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="268a9a597e83ba75272d9a4ac9bca257bf6b5aed" translate="yes" xml:space="preserve">
          <source>What can be controlled by HTTP</source>
          <target state="translated">HTTP로 제어 할 수있는 것</target>
        </trans-unit>
        <trans-unit id="713c03e5f5976173474700739054677d438ef529" translate="yes" xml:space="preserve">
          <source>What is a URL?</source>
          <target state="translated">URL이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="cb40fda7700c4353a89ae159720212fe772dbbc9" translate="yes" xml:space="preserve">
          <source>What requests use CORS?</source>
          <target state="translated">CORS를 사용하는 요청은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="71c8a4a23b0dea390d9c49b1b0992f6d919a9595" translate="yes" xml:space="preserve">
          <source>What went wrong?</source>
          <target state="translated">무엇이 잘못 되었나요?</target>
        </trans-unit>
        <trans-unit id="cf7174ba77cb305a51d991cf76d59eab20483bc3" translate="yes" xml:space="preserve">
          <source>When a 206 (Partial Content) response message includes the content of
   multiple ranges, they are transmitted as body parts in a multipart
   message body (&lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-5.1&quot;&gt;[RFC2046], Section&amp;nbsp;5.1&lt;/a&gt;) with the media type of
   &quot;multipart/byteranges&quot;.

   The multipart/byteranges media type includes one or more body parts,
   each with its own Content-Type and Content-Range fields.  The
   required boundary parameter specifies the boundary string used to
   separate each body part.

   Implementation Notes:

   1.  Additional CRLFs might precede the first boundary string in the
       body.

   2.  Although [&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt;] permits the boundary string to be quoted, some
       existing implementations handle a quoted boundary string
       incorrectly.

   3.  A number of clients and servers were coded to an early draft of
       the byteranges specification that used a media type of multipart/
       x-byteranges, which is almost (but not quite) compatible with
       this type.

   Despite the name, the &quot;multipart/byteranges&quot; media type is not
   limited to byte ranges.  The following example uses an &quot;exampleunit&quot;
   range unit:

     HTTP/1.1 206 Partial Content
     Date: Tue, 14 Nov 1995 06:25:24 GMT
     Last-Modified: Tue, 14 July 04:58:08 GMT
     Content-Length: 2331785
     Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

     --THIS_STRING_SEPARATES
     Content-Type: video/example
     Content-Range: exampleunit 1.2-4.3/25

     ...the first range
     --THIS_STRING_SEPARATES
     Content-Type: video/example
     Content-Range: exampleunit 11.2-14.3/25

     ...the second range
     --THIS_STRING_SEPARATES--</source>
          <target state="translated">206 (부분 컨텐츠) 응답 메시지에 여러 범위의 컨텐츠가 포함 된 경우 , 매체 유형이 &quot;멀티 파트 / 바이트 범위&quot;인 멀티 파트 메시지 본문 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-5.1&quot;&gt;[RFC2046], 섹션 5.1&lt;/a&gt; )에 본문으로 전송됩니다 . multipart / byteranges 미디어 유형에는 각각 고유 한 Content-Type 및 Content-Range 필드가있는 하나 이상의 본문 부분이 포함됩니다. 필수 경계 매개 변수는 각 본문 부분을 분리하는 데 사용되는 경계 문자열을 지정합니다. 구현 노트 : 1. 추가 CRLF가 본문의 첫 번째 경계 문자열보다 앞에 올 수 있습니다. 2. 비록 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt;]는 경계 문자열을 인용 할 수있게하며 일부 기존 구현에서는 인용 된 경계 문자열을 잘못 처리합니다. 3. 여러 종류의 클라이언트와 서버가 미디어 유형의 multipart / x-byterange를 사용하는 바이트 범위 사양의 초기 초안으로 코딩되었으며,이 유형과 거의 호환되지만 그다지 호환되지는 않습니다. 이름에도 불구하고 &quot;multipart / byteranges&quot;미디어 유형은 바이트 범위로 제한되지 않습니다. 다음 예제는 &quot;exampleunit&quot;범위 단위를 사용합니다. HTTP / 1.1 206 부분 컨텐츠 날짜 : 1995 년 11 월 14 일 화요일 06:25:24 GMT 최종 수정 : 7 월 14 일 04:58:08 GMT 컨텐츠 길이 : 2331785 컨텐츠 유형 : multipart / byteranges; boundary = THIS_STRING_SEPARATES --THIS_STRING_SEPARATES 콘텐츠 유형 : 비디오 / 예제 콘텐츠 범위 : exampleunit 12-4.3 / 25 ... 첫 번째 범위 --THIS_STRING_SEPARATES 콘텐츠 유형 : 비디오 / 예제 콘텐츠 범위 : exampleunit 11.2-14.3 / 25 ... 두 번째 범위 --THIS_STRING_SEPARATES--</target>
        </trans-unit>
        <trans-unit id="6c808413e1f3c35593db90aed6fc9dab2aba5b1a" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request is used to load a document, that load cannot currently be redirected into a new process. This error is displayed when loading a document with a &lt;code&gt;Large-Allocation&lt;/code&gt; header with a non-GET HTTP method. This could be caused due to the document being loaded by a form submission, for example.</source>
          <target state="translated">때 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; 의&lt;/a&gt; 요청이 문서를로드하는 데 사용됩니다, 그 부하는 현재 새로운 프로세스로 리디렉션 할 수 없습니다. 비 GET HTTP 메소드를 사용하여 &lt;code&gt;Large-Allocation&lt;/code&gt; 헤더가있는 문서를로드 할 때이 오류가 표시됩니다 . 예를 들어, 양식 제출에 의해 문서가로드되어 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56b0204156f1f5be7ef0d0a67cbf3c8e482f8b85" translate="yes" xml:space="preserve">
          <source>When a CSS stylesheet is requested, via the &lt;code&gt;&amp;lt;link rel=&quot;stylesheet&quot;&amp;gt;&lt;/code&gt; HTML element, most browsers use specific values.</source>
          <target state="translated">CSS 스타일 시트가 요청되면 &lt;code&gt;&amp;lt;link rel=&quot;stylesheet&quot;&amp;gt;&lt;/code&gt; HTML 요소를 통해 대부분의 브라우저는 특정 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6496002e1314faa2d54160cca1e538793173aa5c" translate="yes" xml:space="preserve">
          <source>When a cache has a stale entry that it would like to use as a
   response to a client's request, it first has to check with the origin
   server (or possibly an intermediate cache with a fresh response) to
   see if its cached entry is still usable. We call this &quot;validating&quot;
   the cache entry. Since we do not want to have to pay the overhead of
   retransmitting the full response if the cached entry is good, and we
   do not want to pay the overhead of an extra round trip if the cached
   entry is invalid, the HTTP/1.1 protocol supports the use of
   conditional methods.

   The key protocol features for supporting conditional methods are
   those concerned with &quot;cache validators.&quot; When an origin server
   generates a full response, it attaches some sort of validator to it,
   which is kept with the cache entry. When a client (user agent or
   proxy cache) makes a conditional request for a resource for which it
   has a cache entry, it includes the associated validator in the
   request.

   The server then checks that validator against the current validator
   for the entity, and, if they match (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;), it responds
   with a special status code (usually, 304 (Not Modified)) and no
   entity-body. Otherwise, it returns a full response (including
   entity-body). Thus, we avoid transmitting the full response if the
   validator matches, and we avoid an extra round trip if it does not
   match.

   In HTTP/1.1, a conditional request looks exactly the same as a normal
   request for the same resource, except that it carries a special
   header (which includes the validator) that implicitly turns the
   method (usually, GET) into a conditional.

   The protocol includes both positive and negative senses of cache-
   validating conditions. That is, it is possible to request either that
   a method be performed if and only if a validator matches or if and
   only if no validators match. 

      Note: a response that lacks a validator may still be cached, and
      served from cache until it expires, unless this is explicitly
      prohibited by a cache-control directive. However, a cache cannot
      do a conditional retrieval if it does not have a validator for the
      entity, which means it will not be refreshable after it expires.</source>
          <target state="translated">캐시에 클라이언트 요청에 대한 응답으로 사용하려는 오래된 항목이있는 경우 먼저 캐시 된 항목이 여전히 사용 가능한지 확인하기 위해 원래 서버 (또는 새로운 응답이있는 중간 캐시)를 확인해야합니다. . 이것을 캐시 항목을 &quot;유효성 검사&quot;라고합니다. 캐시 된 항목이 양호하면 전체 응답을 다시 전송하는 오버 헤드를 지불하지 않아도되고 캐시 된 항목이 유효하지 않은 경우 추가 왕복의 오버 헤드를 지불하지 않기 위해 HTTP / 1.1 프로토콜이 지원합니다. 조건부 방법의 사용. 조건부 방법을 지원하기위한 주요 프로토콜 기능은 &quot;캐시 유효성 검사기&quot;와 관련된 기능입니다. 오리진 서버는 전체 응답을 생성 할 때 캐시 항목과 함께 유지되는 일종의 유효성 검증기를 첨부합니다.클라이언트 (사용자 에이전트 또는 프록시 캐시)가 캐시 항목이있는 자원에 대해 조건부 요청을하면 요청에 연관된 유효성 검증 기가 포함됩니다. 그런 다음 서버는 해당 유효성 검사기를 엔터티의 현재 유효성 검사기와 비교하여 확인하고 일치하는지 확인합니다 (참조&lt;a href=&quot;#section-13.3.3&quot;&gt;섹션 13.3.3&lt;/a&gt;), 특수 상태 코드 (일반적으로 304 (수정되지 않음))로 응답하고 엔터티 본문이 없습니다. 그렇지 않으면 전체 응답 (Entity-body 포함)을 반환합니다. 따라서 유효성 검사기가 일치하면 전체 응답을 전송하지 않으며 일치하지 않으면 추가 왕복을 피합니다. HTTP / 1.1에서 조건부 요청은 메소드 (일반적으로 GET)를 내재적으로 조건부로 바꾸는 특수 헤더 (유효 기 포함)를 포함한다는 점을 제외하고는 동일한 자원에 대한 일반 요청과 정확히 동일합니다. 이 프로토콜에는 긍정적이고 부정적인 캐시 유효성 검사 조건이 모두 포함됩니다. 즉, 검증자가 일치하는 경우에만 또는 검증자가 일치하지 않는 경우에만 메소드를 수행하도록 요청할 수 있습니다. 노트 :유효성 검사기가없는 응답은 캐시 제어 지시문에서 명시 적으로 금지하지 않는 한 계속 캐시되어 캐시가 만료 될 때까지 캐시에서 제공 될 수 있습니다. 그러나 엔터티에 대한 유효성 검사기가없는 캐시는 조건부 검색을 수행 할 수 없습니다. 즉, 캐시가 만료 된 후에는 새로 고칠 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2a313afb539045fee37b52ddc2442118f434a073" translate="yes" xml:space="preserve">
          <source>When a cache has one or more stored responses for a requested URI,
   but cannot serve any of them (e.g., because they are not fresh, or
   one cannot be selected; see &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;), it can use the conditional
   request mechanism [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;] in the forwarded request to give the next
   inbound server an opportunity to select a valid stored response to
   use, updating the stored metadata in the process, or to replace the
   stored response(s) with a new response.  This process is known as
   &quot;validating&quot; or &quot;revalidating&quot; the stored response.</source>
          <target state="translated">캐시에 요청 된 URI에 대해 하나 이상의 저장된 응답이 있지만 그 중 하나를 제공 할 수없는 경우 (예 : 새로 작성되지 않았거나 선택할 수 없기 때문에 &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt; 참조 ) 조건부 요청 메커니즘 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ]을 사용할 수 있습니다 . 전달 된 요청에서, 다음 인바운드 서버가 사용할 유효한 저장된 응답을 선택하여 프로세스에서 저장된 메타 데이터를 업데이트하거나 저장된 응답을 새로운 응답으로 대체 할 기회를 제공합니다. 이 프로세스를 저장된 응답을 &quot;확인&quot;또는 &quot;재확인&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="e7c36b18a75fcc748e38b4b4ab8d6dd1ec4fac99" translate="yes" xml:space="preserve">
          <source>When a cache makes a validating request to a server, and the server
   provides a 304 (Not Modified) response or a 206 (Partial Content)
   response, the cache then constructs a response to send to the
   requesting client.

   If the status code is 304 (Not Modified), the cache uses the entity-
   body stored in the cache entry as the entity-body of this outgoing
   response. If the status code is 206 (Partial Content) and the ETag or
   Last-Modified headers match exactly, the cache MAY combine the
   contents stored in the cache entry with the new contents received in
   the response and use the result as the entity-body of this outgoing
   response, (see 13.5.4).

   The end-to-end headers stored in the cache entry are used for the
   constructed response, except that

      - any stored Warning headers with warn-code 1xx (see &lt;a href=&quot;#section-14.46&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.46&quot;&gt;14.46&lt;/a&gt;) MUST be deleted from the cache entry and the forwarded
        response.

      - any stored Warning headers with warn-code 2xx MUST be retained
        in the cache entry and the forwarded response.

      - any end-to-end headers provided in the 304 or 206 response MUST
        replace the corresponding headers from the cache entry.

   Unless the cache decides to remove the cache entry, it MUST also
   replace the end-to-end headers stored with the cache entry with
   corresponding headers received in the incoming response, except for
   Warning headers as described immediately above. If a header field-
   name in the incoming response matches more than one header in the
   cache entry, all such old headers MUST be replaced.

   In other words, the set of end-to-end headers received in the
   incoming response overrides all corresponding end-to-end headers
   stored with the cache entry (except for stored Warning headers with
   warn-code 1xx, which are deleted even if not overridden).

      Note: this rule allows an origin server to use a 304 (Not
      Modified) or a 206 (Partial Content) response to update any header
      associated with a previous response for the same entity or sub-
      ranges thereof, although it might not always be meaningful or
      correct to do so. This rule does not allow an origin server to use
      a 304 (Not Modified) or a 206 (Partial Content) response to
      entirely delete a header that it had provided with a previous
      response.</source>
          <target state="translated">캐시가 서버에 유효성 검증 요청을하고 서버가 304 (수정되지 않음) 응답 또는 206 (부분 컨텐츠) 응답을 제공하는 경우, 캐시는 요청 클라이언트로 전송하기위한 응답을 구성합니다. 상태 코드가 304 (수정되지 않음) 인 경우 캐시는 캐시 항목에 저장된 엔티티 본문을이 발신 응답의 엔티티 본문으로 사용합니다. 상태 코드가 206 (부분 컨텐츠)이고 ETag 또는 Last-Modified 헤더가 정확히 일치하는 경우, 캐시는 캐시 항목에 저장된 컨텐츠를 응답에서 수신 한 새 컨텐츠와 결합하고 그 결과를 엔티티 본문으로 사용할 수 있습니다 (MAY). 이 발신 응답 (13.5.4 참조). 캐시 항목에 저장된 엔드-투-엔드 헤더는 다음을 제외하고 구성된 응답에 사용됩니다. 경고 코드가 1xx 인 저장된 경고 헤더&lt;a href=&quot;#section-14.46&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-14.46&quot;&gt;14.46&lt;/a&gt;)는 캐시 항목과 전달 된 응답에서 삭제해야합니다. -경고 코드가 2xx 인 저장된 경고 헤더는 캐시 항목과 전달 된 응답에 보관해야합니다. -304 또는 206 응답으로 제공된 모든 종단 간 헤더는 캐시 항목의 해당 헤더를 대체해야합니다. 캐시가 캐시 엔트리를 제거하기로 결정하지 않는 한, 캐시 엔트리와 함께 저장된 엔드-투-엔드 헤더를 바로 위에서 설명한 경고 헤더를 제외하고 수신 응답에서 수신 된 해당 헤더로 교체해야합니다. 수신 응답의 헤더 필드 이름이 캐시 항목의 둘 이상의 헤더와 일치하면 이러한 모든 이전 헤더를 교체해야합니다. 다시 말해,수신 응답에서 수신 된 엔드-투-엔드 헤더 세트는 캐시 항목과 함께 저장된 모든 해당 엔드-투-엔드 헤더를 대체합니다 (경고 코드가 1xx 인 저장된 경고 헤더는 제외됨). 참고 :이 규칙을 통해 오리진 서버는 304 (수정되지 않음) 또는 206 (부분 컨텐츠) 응답을 사용하여 동일한 엔티티 또는 하위 범위에 대한 이전 응답과 연관된 헤더를 업데이트 할 수 있지만 항상 의미가있는 것은 아닙니다. 또는 수정하십시오. 이 규칙은 오리진 서버가 304 (수정되지 않음) 또는 206 (부분 컨텐츠) 응답을 사용하여 이전 응답과 함께 제공된 헤더를 완전히 삭제하도록 허용하지 않습니다.재정의되지 않더라도 삭제됩니다). 참고 :이 규칙을 통해 오리진 서버는 304 (수정되지 않음) 또는 206 (부분 컨텐츠) 응답을 사용하여 동일한 엔티티 또는 하위 범위에 대한 이전 응답과 연관된 헤더를 업데이트 할 수 있지만 항상 의미가있는 것은 아닙니다. 또는 수정하십시오. 이 규칙은 오리진 서버가 304 (수정되지 않음) 또는 206 (부분 컨텐츠) 응답을 사용하여 이전 응답과 함께 제공된 헤더를 완전히 삭제하도록 허용하지 않습니다.재정의되지 않더라도 삭제됩니다). 참고 :이 규칙을 통해 오리진 서버는 304 (수정되지 않음) 또는 206 (부분 컨텐츠) 응답을 사용하여 동일한 엔티티 또는 하위 범위에 대한 이전 응답과 연관된 헤더를 업데이트 할 수 있지만 항상 의미가있는 것은 아닙니다. 또는 수정하십시오. 이 규칙은 오리진 서버가 304 (수정되지 않음) 또는 206 (부분 컨텐츠) 응답을 사용하여 이전 응답과 함께 제공된 헤더를 완전히 삭제하도록 허용하지 않습니다.그렇게하는 것이 항상 의미가 있거나 올바른 것은 아닙니다. 이 규칙은 오리진 서버가 304 (수정되지 않음) 또는 206 (부분 컨텐츠) 응답을 사용하여 이전 응답과 함께 제공된 헤더를 완전히 삭제하도록 허용하지 않습니다.그렇게하는 것이 항상 의미가 있거나 올바른 것은 아닙니다. 이 규칙은 오리진 서버가 304 (수정되지 않음) 또는 206 (부분 컨텐츠) 응답을 사용하여 이전 응답과 함께 제공된 헤더를 완전히 삭제하도록 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d406717c4c6e5b1008e22170bfa6487a4fa871a" translate="yes" xml:space="preserve">
          <source>When a cache receives a 304 (Not Modified) response and already has
   one or more stored 200 (OK) responses for the same cache key, the
   cache needs to identify which of the stored responses are updated by
   this new response and then update the stored response(s) with the new
   information provided in the 304 response.

   The stored response to update is identified by using the first match
   (if any) of the following:

   o  If the new response contains a strong validator (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.1&quot;&gt;Section&amp;nbsp;2.1
      of [RFC7232]&lt;/a&gt;), then that strong validator identifies the selected
      representation for update.  All of the stored responses with the
      same strong validator are selected.  If none of the stored
      responses contain the same strong validator, then the cache MUST
      NOT use the new response to update any stored responses. 

   o  If the new response contains a weak validator and that validator
      corresponds to one of the cache's stored responses, then the most
      recent of those matching stored responses is selected for update.

   o  If the new response does not include any form of validator (such
      as in the case where a client generates an If-Modified-Since
      request from a source other than the Last-Modified response header
      field), and there is only one stored response, and that stored
      response also lacks a validator, then that stored response is
      selected for update.

   If a stored response is selected for update, the cache MUST:

   o  delete any Warning header fields in the stored response with
      warn-code 1xx (see &lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;);

   o  retain any Warning header fields in the stored response with
      warn-code 2xx; and,

   o  use other header fields provided in the 304 (Not Modified)
      response to replace all instances of the corresponding header
      fields in the stored response.</source>
          <target state="translated">캐시가 304 (수정되지 않음) 응답을 수신하고 동일한 캐시 키에 대해 하나 이상의 저장된 200 (OK) 응답을 이미 가지고있는 경우, 캐시는이 새로운 응답에 의해 업데이트 된 저장된 응답을 식별 한 다음 저장된 것을 업데이트해야합니다. 304 응답에 제공된 새로운 정보로 응답합니다. 업데이트 된 저장된 응답은 다음 중 첫 번째 일치 (있는 경우)를 사용하여 식별됩니다. o 새 응답에 강력한 유효성 검사기가 포함 된 경우 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.1&quot;&gt;[RFC7232]의 2.1 단원&lt;/a&gt; 참조 )), 강력한 유효성 검사기는 업데이트를 위해 선택된 표현을 식별합니다. 동일한 강력한 유효성 검사기를 가진 저장된 응답이 모두 선택됩니다. 저장된 응답에 동일한 강력한 유효성 검사기가 포함되어 있지 않으면 캐시는 저장된 응답을 업데이트하기 위해 새 응답을 사용해서는 안됩니다. o 새 응답에 약한 유효성 검사기가 포함되어 있고 해당 유효성 검사기가 캐시의 저장된 응답 중 하나에 해당하는 경우 저장된 저장된 응답 중 가장 일치하는 항목이 업데이트를 위해 선택됩니다. o 클라이언트가 Last-Modified 응답 헤더 필드 이외의 소스에서 If-Modified-Since 요청을 생성하는 경우와 같이 새 응답에 유효성 검사기 형식이 포함되지 않은 경우 저장된 응답이 하나만있는 경우 ,저장된 응답에도 유효성 검사기가 부족하며 저장된 응답은 업데이트를 위해 선택됩니다. 저장된 응답을 업데이트하도록 선택한 경우 캐시는 반드시 다음을 수행해야합니다. o warn-code 1xx를 사용하여 저장된 응답의 모든 경고 헤더 필드를 삭제하십시오 (참조).&lt;a href=&quot;#section-5.5&quot;&gt;섹션 5.5&lt;/a&gt; ); o warn-code 2xx를 사용하여 저장된 응답의 모든 경고 헤더 필드를 유지합니다. o 304 (수정되지 않음) 응답에 제공된 다른 헤더 필드를 사용하여 저장된 응답에서 해당 헤더 필드의 모든 인스턴스를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="e27f8aec5a4d9dfc930b9dd75d95d7e0c67f7b5f" translate="yes" xml:space="preserve">
          <source>When a cache receives a request that can be satisfied by a cached response that has a &lt;code&gt;Vary&lt;/code&gt; header field, it must not use that cached response unless all header fields as nominated by the &lt;code&gt;Vary&lt;/code&gt; header match in both the original (cached) request and the new request.</source>
          <target state="translated">캐시는이 가지고있는 캐시 된 응답에 의해 만족 될 수있는 요청 받으면 &lt;code&gt;Vary&lt;/code&gt; 헤더 필드를, 그것은이 지명 한 모든 헤더 필드하지 않는 한 캐시 된 응답을 사용해서는 안 &lt;code&gt;Vary&lt;/code&gt; 원 (캐시) 요청과 새로운 모두 헤더 일치 의뢰.</target>
        </trans-unit>
        <trans-unit id="259d9c0cc1a97e83d0591dcfa329388834b800bc" translate="yes" xml:space="preserve">
          <source>When a cache receives a request that can be satisfied by a stored
   response that has a Vary header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.4&quot;&gt;Section&amp;nbsp;7.1.4 of [RFC7231]&lt;/a&gt;),
   it MUST NOT use that response unless all of the selecting header 

   fields nominated by the Vary header field match in both the original
   request (i.e., that associated with the stored response), and the
   presented request.

   The selecting header fields from two requests are defined to match if
   and only if those in the first request can be transformed to those in
   the second request by applying any of the following:

   o  adding or removing whitespace, where allowed in the header field's
      syntax

   o  combining multiple header fields with the same field name (see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;)

   o  normalizing both header field values in a way that is known to
      have identical semantics, according to the header field's
      specification (e.g., reordering field values when order is not
      significant; case-normalization, where values are defined to be
      case-insensitive)

   If (after any normalization that might take place) a header field is
   absent from a request, it can only match another request if it is
   also absent there.

   A Vary header field-value of &quot;*&quot; always fails to match.

   The stored response with matching selecting header fields is known as
   the selected response.

   If multiple selected responses are available (potentially including
   responses without a Vary header field), the cache will need to choose
   one to use.  When a selecting header field has a known mechanism for
   doing so (e.g., qvalues on Accept and similar request header fields),
   that mechanism MAY be used to select preferred responses; of the
   remainder, the most recent response (as determined by the Date header
   field) is used, as per &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;.

   If no selected response is available, the cache cannot satisfy the
   presented request.  Typically, it is forwarded to the origin server
   in a (possibly conditional; see &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) request.</source>
          <target state="translated">캐시가 Vary 헤더 필드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.4&quot;&gt;[RFC7231]의 섹션 7.1.4)를&lt;/a&gt; 가진 저장된 응답으로 충족 될 수있는 요청을 수신 할 때 Vary 헤더 필드로 지정된 모든 선택 헤더 필드가 아닌 한 해당 응답을 사용해서는 안됩니다. 원래 요청 (즉, 저장된 응답과 관련된 요청)과 제시된 요청 모두에서 일치합니다. 두 요청에서 선택 헤더 필드는 다음 중 하나를 적용하여 첫 번째 요청의 헤더 필드를 두 번째 요청의 헤더 필드로 변환 할 수있는 경우에만 일치하도록 정의됩니다. o 공백 추가 또는 제거, 헤더 필드의 구문에서 허용되는 경우 o 여러 헤더 필드를 동일한 필드 이름으로 결합 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]의 3.2 절&lt;/a&gt; 참조 )o 헤더 필드의 사양에 따라 동일한 의미론을 갖는 것으로 알려진 두 헤더 필드 값을 정규화 (예 : 순서가 중요하지 않은 경우 필드 값 재정렬, 값이 대소 문자를 구분하지 않는 경우 정규화) 헤더 필드가 요청에없는 경우 (정규화 후에) 요청이없는 경우 다른 요청과 만 일치 할 수 있습니다. &quot;*&quot;의 Vary 헤더 필드 값이 항상 일치하지 않습니다. 선택 헤더 필드와 일치하는 저장된 응답을 선택된 응답이라고합니다. 선택한 여러 응답을 사용할 수있는 경우 (Vary 헤더 필드가없는 응답 포함) 캐시는 사용할 응답을 선택해야합니다.선택 헤더 필드에 알려진 메커니즘 (예 : 수락 및 유사한 요청 헤더 필드의 qvalue)이있는 경우 해당 메커니즘을 사용하여 선호 응답을 선택할 수 있습니다. 나머지 중 가장 최근 응답 (날짜 헤더 필드에 의해 결정됨)이&lt;a href=&quot;#section-4&quot;&gt;섹션 4&lt;/a&gt; . 선택된 응답이 없으면 캐시가 제시된 요청을 충족시킬 수 없습니다. 일반적으로 요청 은 (조건부; &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt; 참조 ) 요청으로 오리진 서버로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="2efb3fde6a483d198481c23c5cdc77de55b29f46" translate="yes" xml:space="preserve">
          <source>When a cache receives a request that has a &lt;code&gt;Vary&lt;/code&gt; header field, it must not use a cached response by default unless all header fields specified in the &lt;code&gt;Vary&lt;/code&gt; header match in both the original (cached) request and the new request.</source>
          <target state="translated">캐시는이이 요청을 수신 할 때 &lt;code&gt;Vary&lt;/code&gt; 헤더 필드에 지정된 모든 헤더 필드가없는 한, 그것은 기본적으로 캐시 된 응답을 사용해서는 안 &lt;code&gt;Vary&lt;/code&gt; 원 (캐시) 요청과 새로운 요청 모두 헤더 일치.</target>
        </trans-unit>
        <trans-unit id="287b2fc4e92e6cc3cafe98a92f86bd5cdf146df5" translate="yes" xml:space="preserve">
          <source>When a cached document's expiration time has been reached, it is either validated or fetched again. Validation can only occur if the server provided either a &lt;em&gt;strong validator&lt;/em&gt; or a &lt;em&gt;weak validator&lt;/em&gt;.</source>
          <target state="translated">캐시 된 문서의 만료 시간에 도달하면 유효성 검사 또는 다시 가져옵니다. 서버가 &lt;em&gt;강력한 유효성 검사기&lt;/em&gt; 또는 &lt;em&gt;약한 유효성 &lt;/em&gt;&lt;em&gt;검사기를&lt;/em&gt; 제공 한 경우에만 유효성 검사가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="975b61b5ac16b78cc262727df4d4fcf1f3fc063c" translate="yes" xml:space="preserve">
          <source>When a client wants to communicate with a server, either the final server or an intermediate proxy, it performs the following steps:</source>
          <target state="translated">클라이언트가 최종 서버 또는 중간 프록시 서버와 통신하려는 경우 다음 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b5e879fd0d6d83356c23a21725294c0955f7c7cc" translate="yes" xml:space="preserve">
          <source>When a complete or partial representation is transferred in a message
   payload, it is often desirable for the sender to supply, or the
   recipient to determine, an identifier for a resource corresponding to
   that representation.

   For a request message:

   o  If the request has a Content-Location header field, then the
      sender asserts that the payload is a representation of the
      resource identified by the Content-Location field-value.  However,
      such an assertion cannot be trusted unless it can be verified by
      other means (not defined by this specification).  The information
      might still be useful for revision history links. 

   o  Otherwise, the payload is unidentified.

   For a response message, the following rules are applied in order
   until a match is found:

   1.  If the request method is GET or HEAD and the response status code
       is 200 (OK), 204 (No Content), 206 (Partial Content), or 304 (Not
       Modified), the payload is a representation of the resource
       identified by the effective request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of
       [RFC7230]&lt;/a&gt;).

   2.  If the request method is GET or HEAD and the response status code
       is 203 (Non-Authoritative Information), the payload is a
       potentially modified or enhanced representation of the target
       resource as provided by an intermediary.

   3.  If the response has a Content-Location header field and its
       field-value is a reference to the same URI as the effective
       request URI, the payload is a representation of the resource
       identified by the effective request URI.

   4.  If the response has a Content-Location header field and its
       field-value is a reference to a URI different from the effective
       request URI, then the sender asserts that the payload is a
       representation of the resource identified by the Content-Location
       field-value.  However, such an assertion cannot be trusted unless
       it can be verified by other means (not defined by this
       specification).

   5.  Otherwise, the payload is unidentified.</source>
          <target state="translated">전체 또는 부분 표현이 메시지 페이로드로 전송 될 때, 발신자가 그 표현에 대응하는 자원의 식별자를 제공하거나 수신자가 결정하는 것이 종종 바람직하다. 요청 메시지의 경우 : o 요청에 Content-Location 헤더 필드가있는 경우 발신자는 페이로드가 Content-Location 필드 값으로 식별 된 리소스의 표현이라고 주장합니다. 그러나 이러한 주장은 다른 방법으로 검증 할 수 없다면 (이 규격에 의해 정의되지 않은) 신뢰할 수 없다. 이 정보는 여전히 개정 내역 링크에 유용 할 수 있습니다. o 그렇지 않으면 페이로드가 식별되지 않습니다. 응답 메시지의 경우 일치하는 항목을 찾을 때까지 다음 규칙이 순서대로 적용됩니다.요청 방법이 GET 또는 HEAD이고 응답 상태 코드가 200 (OK), 204 (No Content), 206 (Partial Content) 또는 304 (Not Modified) 인 경우 페이로드는 유효에 의해 식별 된 리소스를 나타냅니다. 요청 URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]의 섹션 5.5&lt;/a&gt;). 2. 요청 방법이 GET 또는 HEAD이고 응답 상태 코드가 203 (비 정식 정보) 인 경우, 페이로드는 중개자가 제공 한 대상 자원의 잠재적으로 수정 또는 강화 된 표현입니다. 3. 응답에 Content-Location 헤더 필드가 있고 해당 필드 값이 유효 요청 URI와 동일한 URI에 대한 참조 인 경우 페이로드는 유효 요청 URI로 식별 된 리소스를 나타냅니다. 4. 응답에 Content-Location 헤더 필드가 있고 해당 필드 값이 유효 요청 URI와 다른 URI에 대한 참조 인 경우 송신자는 페이로드가 Content-Location 필드로 식별 된 자원의 표현이라고 주장합니다. -값. 하나,그러한 주장은 다른 방법으로 검증 될 수 없다면 (이 규격에 의해 정의되지 않은) 신뢰할 수 없다. 5. 그렇지 않으면 페이로드가 식별되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e81a1900fdbf11113476103eae02d72c7f77097d" translate="yes" xml:space="preserve">
          <source>When a message does not have a Transfer-Encoding header field, a
   Content-Length header field can provide the anticipated size, as a
   decimal number of octets, for a potential payload body.  For messages
   that do include a payload body, the Content-Length field-value
   provides the framing information necessary for determining where the
   body (and message) ends.  For messages that do not include a payload
   body, the Content-Length indicates the size of the selected
   representation (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC7231]&lt;/a&gt;).

     Content-Length = 1*DIGIT

   An example is

     Content-Length: 3495

   A sender MUST NOT send a Content-Length header field in any message
   that contains a Transfer-Encoding header field.

   A user agent SHOULD send a Content-Length in a request message when
   no Transfer-Encoding is sent and the request method defines a meaning
   for an enclosed payload body.  For example, a Content-Length header
   field is normally sent in a POST request even when the value is 0
   (indicating an empty payload body).  A user agent SHOULD NOT send a
   Content-Length header field when the request message does not contain
   a payload body and the method semantics do not anticipate such a
   body.

   A server MAY send a Content-Length header field in a response to a
   HEAD request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2 of [RFC7231]&lt;/a&gt;); a server MUST NOT send
   Content-Length in such a response unless its field-value equals the
   decimal number of octets that would have been sent in the payload
   body of a response if the same request had used the GET method.

   A server MAY send a Content-Length header field in a 304 (Not
   Modified) response to a conditional GET request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of
   [RFC7232]&lt;/a&gt;); a server MUST NOT send Content-Length in such a response 

   unless its field-value equals the decimal number of octets that would
   have been sent in the payload body of a 200 (OK) response to the same
   request.

   A server MUST NOT send a Content-Length header field in any response
   with a status code of 1xx (Informational) or 204 (No Content).  A
   server MUST NOT send a Content-Length header field in any 2xx
   (Successful) response to a CONNECT request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of
   [RFC7231]&lt;/a&gt;).

   Aside from the cases defined above, in the absence of
   Transfer-Encoding, an origin server SHOULD send a Content-Length
   header field when the payload body size is known prior to sending the
   complete header section.  This will allow downstream recipients to
   measure transfer progress, know when a received message is complete,
   and potentially reuse the connection for additional requests.

   Any Content-Length field value greater than or equal to zero is
   valid.  Since there is no predefined limit to the length of a
   payload, a recipient MUST anticipate potentially large decimal
   numerals and prevent parsing errors due to integer conversion
   overflows (&lt;a href=&quot;#section-9.3&quot;&gt;Section 9.3&lt;/a&gt;).

   If a message is received that has multiple Content-Length header
   fields with field-values consisting of the same decimal value, or a
   single Content-Length header field with a field value containing a
   list of identical decimal values (e.g., &quot;Content-Length: 42, 42&quot;),
   indicating that duplicate Content-Length header fields have been
   generated or combined by an upstream message processor, then the
   recipient MUST either reject the message as invalid or replace the
   duplicated field-values with a single valid Content-Length field
   containing that decimal value prior to determining the message body
   length or forwarding the message.

      Note: HTTP's use of Content-Length for message framing differs
      significantly from the same field's use in MIME, where it is an
      optional field used only within the &quot;message/external-body&quot;
      media-type.</source>
          <target state="translated">메시지에 Transfer-Encoding 헤더 필드가없는 경우 Content-Length 헤더 필드는 잠재적 페이로드 본문에 예상 크기를 10 진수 10 진수로 제공 할 수 있습니다. 페이로드 본문을 포함하는 메시지의 경우 Content-Length 필드 값은 본문 (및 메시지)이 끝나는 위치를 결정하는 데 필요한 프레임 정보를 제공합니다. 페이로드 본문이 포함되지 않은 메시지의 경우 Content-Length는 선택한 표현의 크기를 나타냅니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3&quot;&gt;[RFC7231]의 3 절).&lt;/a&gt;). Content-Length = 1 * DIGIT 예는 Content-Length입니다. 3495 발신자는 Transfer-Encoding 헤더 필드가 포함 된 메시지에서 Content-Length 헤더 필드를 보내면 안됩니다. 사용자 에이전트는 전송 인코딩이 전송되지 않고 요청 방법이 동봉 된 페이로드 본문에 대한 의미를 정의 할 때 요청 메시지에 Content-Length를 전송해야합니다. 예를 들어, Content-Length 헤더 필드는 값이 0 (빈 페이로드 본문을 나타냄) 인 경우에도 일반적으로 POST 요청에서 전송됩니다. 요청 메시지에 페이로드 본문이없고 메소드 시맨틱이 그러한 본문을 예상하지 않는 경우 사용자 에이전트는 Content-Length 헤더 필드를 보내지 않아야합니다. 서버는 HEAD 요청에 대한 응답으로 Content-Length 헤더 필드를 보낼 수있다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.2&quot;&gt;[RFC7231]의 4.3.2 절)&lt;/a&gt;); 동일한 요청이 GET 메소드를 사용한 경우 필드 값이 응답의 페이로드 본문에서 전송 된 10 진수의 10 진수와 같지 않은 한 서버는 이러한 응답으로 Content-Length를 보내서는 안됩니다. 서버는 조건부 GET 요청에 304 (Not Modified) 응답으로 Content-Length 헤더 필드를 전송할 수있다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;[RFC7232]의 4.1 절)&lt;/a&gt;); 필드 값이 동일한 요청에 대한 200 (OK) 응답의 페이로드 본문에서 전송 된 10 진수의 10 진수와 같은 경우가 아니면 서버는 이러한 응답으로 Content-Length를 보내서는 안됩니다. 서버는 상태 코드가 1xx (Informational) 또는 204 (No Content) 인 응답으로 Content-Length 헤더 필드를 보내서는 안됩니다. 서버는 CONNECT 요청에 대해 2xx (성공) 응답의 Content-Length 헤더 필드를 보내서는 안됩니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231]의 4.3.6 절).&lt;/a&gt;). 위에서 정의한 경우를 제외하고, Transfer-Encoding이 없으면 오리진 서버는 전체 헤더 섹션을 보내기 전에 페이로드 본문 크기를 알 때 Content-Length 헤더 필드를 보내야합니다 (SHOULD). 이를 통해 다운 스트림 수신자는 전송 진행률을 측정하고 수신 된 메시지가 완료된시기를 알고 추가 요청에 연결을 재사용 할 수 있습니다. 0보다 크거나 같은 모든 Content-Length 필드 값이 유효합니다. 페이로드의 길이에 대한 사전 정의 된 제한이 없으므로 수신자는 잠재적으로 큰 십진수를 예상하고 정수 변환 오버플로로 인한 구문 분석 오류를 방지해야합니다 ( &lt;a href=&quot;#section-9.3&quot;&gt;섹션 9.3).&lt;/a&gt;). 동일한 10 진수 값으로 구성된 필드 값이있는 여러 Content-Length 헤더 필드가있는 메시지가 수신되거나 동일한 10 진수 값 목록이 포함 된 필드 값이있는 단일 Content-Length 헤더 필드 (예 : &quot;Content-Length : 42, 42 &quot;), 중복 된 Content-Length 헤더 필드가 업스트림 메시지 프로세서에 의해 생성 또는 결합되었음을 나타내면 수신자는 메시지를 유효하지 않은 것으로 거부하거나 복제 된 필드 값을 유효한 단일 Content-Length로 대체해야합니다. 메시지 본문 길이를 결정하거나 메시지를 전달하기 전에 해당 10 진수 값을 포함하는 필드. 참고 : 메시지 프레이밍에 HTTP의 Content-Length 사용은 MIME에서의 동일한 필드 사용과 크게 다릅니다.여기서 &quot;message / external-body&quot;미디어 유형 내에서만 사용되는 선택적 필드입니다.</target>
        </trans-unit>
        <trans-unit id="8a3283af6dcc2661109dbb11d4827ac5e1d71582" translate="yes" xml:space="preserve">
          <source>When a message includes a message body encoded with the chunked
   transfer coding and the sender desires to send metadata in the form
   of trailer fields at the end of the message, the sender SHOULD
   generate a Trailer header field before the message body to indicate
   which fields will be present in the trailers.  This allows the
   recipient to prepare for receipt of that metadata before it starts
   processing the body, which is useful if the message is being streamed
   and the recipient wishes to confirm an integrity check on the fly.

     Trailer = 1#field-name</source>
          <target state="translated">메시지가 청크 된 전송 코딩으로 인코딩 된 메시지 본문을 포함하고 발신자가 메시지의 끝에서 트레일러 필드 형태로 메타 데이터를 전송하고자하는 경우, 발신자는 메시지 본문 전에 트레일러 헤더 필드를 생성하여 어떤 필드가 트레일러에 있어야합니다. 이를 통해 수신자는 본문 처리를 시작하기 전에 해당 메타 데이터의 수신을 준비 할 수 있습니다. 이는 메시지가 스트리밍되고 수신자가 무결성 검사를 즉시 확인하려는 경우에 유용합니다. 트레일러 = 1 # 필드 이름</target>
        </trans-unit>
        <trans-unit id="b235fc2e260e87a056455dbda3fa587e723e993d" translate="yes" xml:space="preserve">
          <source>When a precondition header is &lt;strong&gt;not matching&lt;/strong&gt; the server side state, the response should be &lt;a href=&quot;412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Precondition Failed&lt;/code&gt;.</source>
          <target state="translated">전제 조건 헤더가 서버 측 상태와 &lt;strong&gt;일치하지 않으면&lt;/strong&gt; 응답은 &lt;a href=&quot;412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Precondition Failed&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="186bf5363add379b2ba012f5766a038907e51aa8" translate="yes" xml:space="preserve">
          <source>When a request's credentials mode (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt;) is &quot;&lt;code&gt;include&lt;/code&gt;&quot;, browsers will only expose the response to frontend JavaScript code if the &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">요청의 자격 증명 모드 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; &lt;/a&gt; )가 &quot; &lt;code&gt;include&lt;/code&gt; &quot;인 경우 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 브라우저는 프론트 엔드 JavaScript 코드에만 응답을 노출 합니다 .</target>
        </trans-unit>
        <trans-unit id="7333e1d0d6993ac9df1cdfe6fae92b4f7648978f" translate="yes" xml:space="preserve">
          <source>When a request's credentials mode (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;include&lt;/code&gt;, browsers will only expose the response to frontend JavaScript code if the &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">요청의 자격 증명 모드 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; &lt;/a&gt; )가 &lt;code&gt;include&lt;/code&gt; 인 경우 브라우저는 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 값이 &lt;code&gt;true&lt;/code&gt; 인 경우에만 프런트 엔드 JavaScript 코드에 대한 응답을 노출 합니다 .</target>
        </trans-unit>
        <trans-unit id="6dac549244c018dee53a4d208ca6b3e0f5dca724" translate="yes" xml:space="preserve">
          <source>When a script is requested, like via the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; HTML element, some browsers use specific values.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; HTML 요소 를 통해와 같이 스크립트가 요청 되면 일부 브라우저는 특정 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f12d11c8f8587f228e72fd8c89532b1324f82f4a" translate="yes" xml:space="preserve">
          <source>When a site enables the &lt;code&gt;Expect-CT&lt;/code&gt; header, they are requesting that the browser check that any certificate for that site appears in &lt;strong&gt;&lt;a href=&quot;https://www.certificate-transparency.org/known-logs&quot;&gt;public CT logs&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">사이트에서 &lt;code&gt;Expect-CT&lt;/code&gt; 헤더를 활성화하면 브라우저는 해당 사이트에 대한 인증서가 &lt;strong&gt;&lt;a href=&quot;https://www.certificate-transparency.org/known-logs&quot;&gt;공개 CT 로그에&lt;/a&gt;&lt;/strong&gt; 나타나는지 브라우저에 확인하도록 요청합니다 .</target>
        </trans-unit>
        <trans-unit id="fa74c170f2d19667b559eacecf88a8660b338292" translate="yes" xml:space="preserve">
          <source>When a user opened a page using a &lt;code&gt;file:///&lt;/code&gt; URI in Firefox 67 and earlier, the origin of the page was defined as the directory from which the page was opened. Resources in the same directory and its subdirectories were treated as having the same origin for purposes of the CORS same-origin rule.</source>
          <target state="translated">사용자 가 Firefox 67 및 이전 버전에서 &lt;code&gt;file:///&lt;/code&gt; URI를 사용하여 페이지를 열었을 때 페이지 의 출처는 페이지가 열린 디렉토리로 정의되었습니다. CORS 동일 출처 규칙에 따라 동일한 디렉토리 및 하위 디렉토리에있는 리소스는 동일한 출처를 갖는 것으로 취급되었습니다.</target>
        </trans-unit>
        <trans-unit id="d36ab7ed245bcd63c35d075bb14e0ef75e55e069" translate="yes" xml:space="preserve">
          <source>When a validation request is made, the server can either ignore the validation request and response with a normal &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt;, or it can return &lt;a href=&quot;status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; (with an empty body) to instruct the browser to use its cached copy. The latter response can also include headers that update the expiration time of the cached document.</source>
          <target state="translated">유효성 검사 요청이 이루어지면 서버는 유효성 검사 요청 및 정상적인 &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 응답을 무시 하거나 &lt;a href=&quot;status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; (빈 본문 포함)를 반환 하여 브라우저에 캐시 된 복사본을 사용하도록 지시 할 수 있습니다. 후자의 응답은 캐시 된 문서의 만료 시간을 업데이트하는 헤더를 포함 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="47e19190be60527564cf5d0364edee22a0103f29" translate="yes" xml:space="preserve">
          <source>When a video is requested, via the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; HTML element, most browsers use specific values.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; HTML 요소 를 통해 비디오가 요청 되면 대부분의 브라우저는 특정 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="63eed939b8f0aa6e66825ee3882a3480a6666111" translate="yes" xml:space="preserve">
          <source>When adding such a tag, you serve the same content for both domains, telling search engines which URL is canonical. In the previous example, &lt;code&gt;http://www.example.org/whaddup&lt;/code&gt; would serve the same content as &lt;code&gt;http://example.org/whaddup&lt;/code&gt;, but with an additional &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element in the head:</source>
          <target state="translated">이러한 태그를 추가하면 두 도메인 모두에 동일한 콘텐츠를 제공하여 어떤 URL이 표준 URL인지 검색 엔진에 알려줍니다. 이전 예에서 &lt;code&gt;http://www.example.org/whaddup&lt;/code&gt; 은 &lt;code&gt;http://example.org/whaddup&lt;/code&gt; 과 동일한 컨텐츠를 제공 하지만 헤드에 추가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="59d5afaa19c72d09eeef4b2419754f02979a4b23" translate="yes" xml:space="preserve">
          <source>When an Expires date is set, the deadline is relative to the &lt;em&gt;client&lt;/em&gt; the cookie is being set on, not the server.</source>
          <target state="translated">만료 날짜가 설정된 경우 기한은 서버가 아니라 쿠키가 설정된 &lt;em&gt;클라이언트에&lt;/em&gt; 상대적 입니다.</target>
        </trans-unit>
        <trans-unit id="4c4bb5659f583a468f69b6efcf9b5dc0370b8db9" translate="yes" xml:space="preserve">
          <source>When an HTTP 206 (Partial Content) response message includes the
   content of multiple ranges (a response to a request for multiple
   non-overlapping ranges), these are transmitted as a multipart
   message-body. The media type for this purpose is called
   &quot;multipart/byteranges&quot;.

   The multipart/byteranges media type includes two or more parts, each
   with its own Content-Type and Content-Range fields. The required
   boundary parameter specifies the boundary string used to separate
   each body-part.

       Media Type name:         multipart
       Media subtype name:      byteranges
       Required parameters:     boundary
       Optional parameters:     none
       Encoding considerations: only &quot;7bit&quot;, &quot;8bit&quot;, or &quot;binary&quot; are
                                permitted
       Security considerations: none


   For example:

   HTTP/1.1 206 Partial Content
   Date: Wed, 15 Nov 1995 06:25:24 GMT
   Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
   Content-type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

   --THIS_STRING_SEPARATES
   Content-type: application/pdf
   Content-range: bytes 500-999/8000

   ...the first range
   --THIS_STRING_SEPARATES
   Content-type: application/pdf
   Content-range: bytes 7000-7999/8000

   ...the second range
   --THIS_STRING_SEPARATES--

      Notes:

      1) Additional CRLFs may precede the first boundary string in the
         entity. 

      2) Although &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt; [&lt;a href=&quot;#ref-40&quot;&gt;40&lt;/a&gt;] permits the boundary string to be
         quoted, some existing implementations handle a quoted boundary
         string incorrectly.

      3) A number of browsers and servers were coded to an early draft
         of the byteranges specification to use a media type of
         multipart/x-byteranges, which is almost, but not quite
         compatible with the version documented in HTTP/1.1.</source>
          <target state="translated">HTTP (206) (부분 컨텐츠) 응답 메시지가 다중 범위의 컨텐츠 (중복되지 않은 다중 범위에 대한 요청에 대한 응답)를 포함하는 경우, 이들은 다중 파트 메시지 본문으로 전송된다. 이 목적을위한 매체 유형을 &quot;멀티 파트 / 바이트 범위&quot;라고합니다. multipart / byteranges 미디어 유형에는 각각 고유 한 Content-Type 및 Content-Range 필드가있는 둘 이상의 부분이 포함됩니다. 필수 경계 매개 변수는 각 본문 부분을 분리하는 데 사용되는 경계 문자열을 지정합니다. 미디어 유형 이름 : multipart 미디어 하위 유형 이름 : 바이트 범위 필수 매개 변수 : 경계 선택적 매개 변수 : 없음 인코딩 고려 사항 : &quot;7bit&quot;, &quot;8bit&quot;또는 &quot;binary&quot;만 허용됩니다. 보안 고려 사항 :none 예 : HTTP / 1.1 206 부분 컨텐츠 날짜 : 1995 년 11 월 15 일 수요일 06:25:24 GMT 최종 수정 : 1995 년 11 월 15 일 수요일 04:58:08 GMT 컨텐츠 유형 : multipart / byteranges; boundary = THIS_STRING_SEPARATES --THIS_STRING_SEPARATES 컨텐츠 유형 : application / pdf 컨텐츠 범위 : bytes 500-999 / 8000 ... 첫 번째 범위 --THIS_STRING_SEPARATES 컨텐츠 유형 : application / pdf 컨텐츠 범위 : bytes 7000-7999 / 8000. .. 두 번째 범위 --THIS_STRING_SEPARATES-- 참고 : 1) 추가 CRLF가 엔티티의 첫 번째 경계 문자열 앞에 올 수 있습니다. 2) 그래도boundary = THIS_STRING_SEPARATES --THIS_STRING_SEPARATES 컨텐츠 유형 : application / pdf 컨텐츠 범위 : bytes 500-999 / 8000 ... 첫 번째 범위 --THIS_STRING_SEPARATES 컨텐츠 유형 : application / pdf 컨텐츠 범위 : bytes 7000-7999 / 8000. .. 두 번째 범위 --THIS_STRING_SEPARATES-- 참고 : 1) 추가 CRLF가 엔티티의 첫 번째 경계 문자열 앞에 올 수 있습니다. 2) 그래도boundary = THIS_STRING_SEPARATES --THIS_STRING_SEPARATES 컨텐츠 유형 : application / pdf 컨텐츠 범위 : bytes 500-999 / 8000 ... 첫 번째 범위 --THIS_STRING_SEPARATES 컨텐츠 유형 : application / pdf 컨텐츠 범위 : bytes 7000-7999 / 8000. .. 두 번째 범위 --THIS_STRING_SEPARATES-- 참고 : 1) 추가 CRLF가 엔티티의 첫 번째 경계 문자열 앞에 올 수 있습니다. 2) 그래도&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt; [ &lt;a href=&quot;#ref-40&quot;&gt;40&lt;/a&gt; ]은 경계 문자열을 인용 할 수있게하며, 일부 기존 구현에서는 인용 된 경계 문자열을 잘못 처리합니다. 3) 여러 종류의 브라우저와 서버가 multipart / x-byteranges의 미디어 유형을 사용하기 위해 바이트 범위 사양의 초기 초안으로 코딩되었으며, HTTP / 1.1에 문서화 된 버전과 거의 호환되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed84582108607d5a8e0796d0b676929516566c33" translate="yes" xml:space="preserve">
          <source>When an audio file is requested, like via the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; HTML element, most browsers use specific values.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; HTML 요소 를 통해와 같이 오디오 파일이 요청 되면 대부분의 브라우저는 특정 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9efbf183df3ebd070a5d9eb93570e9456b19792e" translate="yes" xml:space="preserve">
          <source>When an entity-body is included with a message, the data type of that
   body is determined via the header fields Content-Type and Content-
   Encoding. These define a two-layer, ordered encoding model:

       entity-body := Content-Encoding( Content-Type( data ) )

   Content-Type specifies the media type of the underlying data.
   Content-Encoding may be used to indicate any additional content
   codings applied to the data, usually for the purpose of data
   compression, that are a property of the requested resource. There is
   no default encoding.

   Any HTTP/1.1 message containing an entity-body SHOULD include a
   Content-Type header field defining the media type of that body. If
   and only if the media type is not given by a Content-Type field, the
   recipient MAY attempt to guess the media type via inspection of its
   content and/or the name extension(s) of the URI used to identify the
   resource. If the media type remains unknown, the recipient SHOULD
   treat it as type &quot;application/octet-stream&quot;.</source>
          <target state="translated">엔티티 본문이 메시지에 포함 된 경우 해당 본문의 데이터 유형은 헤더 필드 Content-Type 및 Content-Encoding을 통해 결정됩니다. 이들은 2 계층 순서의 인코딩 모델을 정의합니다. entity-body : = Content-Encoding (Content-Type (data)) Content-Type은 기본 데이터의 미디어 유형을 지정합니다. 콘텐츠 인코딩은 일반적으로 데이터 압축을 위해 요청 된 자원의 속성 인 데이터에 적용된 임의의 추가 콘텐츠 코딩을 나타내는 데 사용될 수있다. 기본 인코딩이 없습니다. 엔티티 본문을 포함하는 모든 HTTP / 1.1 메시지는 해당 본문의 미디어 유형을 정의하는 Content-Type 헤더 필드를 포함해야합니다 (SHOULD). 미디어 유형이 컨텐츠 유형 필드에 의해 제공되지 않은 경우에만,수신자는 그 내용 및 / 또는 자원을 식별하는데 사용 된 URI의 이름 확장자를 검사하여 매체 유형을 추측하려고 시도 할 수있다. 미디어 유형을 알 수없는 경우 수신자는이를 &quot;application / octet-stream&quot;유형으로 취급해야합니다.</target>
        </trans-unit>
        <trans-unit id="514b34eaec23c4a82ae216c4952b1601e369040b" translate="yes" xml:space="preserve">
          <source>When an expiry date is set, the time and date set is relative to the client the cookie is being set on, not the server.</source>
          <target state="translated">만료 날짜가 설정되면 시간과 날짜 설정은 서버가 아닌 쿠키가 설정된 클라이언트와 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="689ec0aa3c371c99a1bb0c520e872fada7093b46" translate="yes" xml:space="preserve">
          <source>When arrows are found in the resource URL's ('-&amp;gt;'), it means that the first file loaded the next one:</source>
          <target state="translated">리소스 URL ( '-&amp;gt;')에 화살표가 있으면 첫 번째 파일이 다음 파일을로드했음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="537cfbce765877e75dc4ddb75367470d9c1d0f61" translate="yes" xml:space="preserve">
          <source>When both the &lt;code&gt;enforce&lt;/code&gt; directive and the &lt;code&gt;report-uri&lt;/code&gt; directive are present, the configuration is referred to as an &quot;enforce-and-report&quot; configuration, signalling to the user agent both that compliance to the Certificate Transparency policy should be enforced and that violations should be reported.</source>
          <target state="translated">모두가 때 &lt;code&gt;enforce&lt;/code&gt; 지침과 &lt;code&gt;report-uri&lt;/code&gt; 지침이 존재하는 구성은 인증서 투명성 정책이 준수가 모두 적용되어야하는 사용자 에이전트에 신호,에 &quot;시행 앤 보고서&quot;를 구성이라 그 위반해야한다 보고됩니다.</target>
        </trans-unit>
        <trans-unit id="c72d9da42d5a452306e589dd697e9bc2459db237" translate="yes" xml:space="preserve">
          <source>When browsers receive a redirect, they immediately load the new URL provided in the &lt;code&gt;Location&lt;/code&gt; header. Besides the small performance hit of an additional round-trip, users rarely notice the redirection.</source>
          <target state="translated">브라우저가 리디렉션을 수신하면 즉시 &lt;code&gt;Location&lt;/code&gt; 헤더에 제공된 새 URL을로드합니다 . 추가 왕복의 작은 성능 저하 외에도 사용자는 리디렉션을 거의 알아 차리지 못합니다.</target>
        </trans-unit>
        <trans-unit id="405dbcb99df2fc12205b914cd73322e548995294" translate="yes" xml:space="preserve">
          <source>When comparing two URIs to decide if they match or not, a client
   SHOULD use a case-sensitive octet-by-octet comparison of the entire
   URIs, with these exceptions:

      - A port that is empty or not given is equivalent to the default
        port for that URI-reference;

        - Comparisons of host names MUST be case-insensitive;

        - Comparisons of scheme names MUST be case-insensitive;

        - An empty abs_path is equivalent to an abs_path of &quot;/&quot;.

   Characters other than those in the &quot;reserved&quot; and &quot;unsafe&quot; sets (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt; [&lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;]) are equivalent to their &quot;&quot;%&quot; HEX HEX&quot; encoding.

   For example, the following three URIs are equivalent:

      &lt;a href=&quot;http://abc.com:80/~smith/home.html&quot;&gt;http://abc.com:80/~smith/home.html&lt;/a&gt;&lt;a href=&quot;http://ABC.com/%7Esmith/home.html&quot;&gt;http://ABC.com/%7Esmith/home.html&lt;/a&gt;&lt;a href=&quot;http://ABC.com/%7esmith/home.html&quot;&gt;http://ABC.com:/%7esmith/home.html&lt;/a&gt;</source>
          <target state="translated">두 URI를 비교하여 일치하는지 여부를 결정하는 경우 클라이언트는 다음을 제외하고 전체 URI의 대소 문자 구분 8 진수 비교를 사용해야합니다.-비어 있거나 제공되지 않은 포트는 기본 포트와 같습니다. 그 URI 참조를 위해; -호스트 이름 비교는 대소 문자를 구분하지 않아야합니다. -체계 명 비교는 대소 문자를 구분하지 않아야한다. -빈 abs_path는 &quot;/&quot;의 abs_path와 같습니다. &quot;예약 된&quot;및 &quot;안전하지 않은&quot;세트 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt; [ &lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt; ] 참조) 이외의 문자 는 &quot;&quot;% &quot;HEX HEX&quot;인코딩과 같습니다. 예를 들어 &lt;a href=&quot;http://abc.com:80/~smith/home.html&quot;&gt;http://abc.com:80/~smith/home.html &lt;/a&gt;&lt;a href=&quot;http://ABC.com/%7Esmith/home.html&quot;&gt;http : // ABC의&lt;/a&gt; 세 가지 URI가 동일 합니다.com / % 7Esmith / home.html&lt;a href=&quot;http://ABC.com/%7esmith/home.html&quot;&gt;http://ABC.com:/%7esmith/home.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17c62a909cae76968be588e261c2cc6fcbe524c4" translate="yes" xml:space="preserve">
          <source>When considering the design of HTTP, it is easy to fall into a trap
   of thinking that all user agents are general-purpose browsers and all
   origin servers are large public websites.  That is not the case in
   practice.  Common HTTP user agents include household appliances,
   stereos, scales, firmware update scripts, command-line programs,
   mobile apps, and communication devices in a multitude of shapes and
   sizes.  Likewise, common HTTP origin servers include home automation 

   units, configurable networking components, office machines,
   autonomous robots, news feeds, traffic cameras, ad selectors, and
   video-delivery platforms.

   The term &quot;user agent&quot; does not imply that there is a human user
   directly interacting with the software agent at the time of a
   request.  In many cases, a user agent is installed or configured to
   run in the background and save its results for later inspection (or
   save only a subset of those results that might be interesting or
   erroneous).  Spiders, for example, are typically given a start URI
   and configured to follow certain behavior while crawling the Web as a
   hypertext graph.

   The implementation diversity of HTTP means that not all user agents
   can make interactive suggestions to their user or provide adequate
   warning for security or privacy concerns.  In the few cases where
   this specification requires reporting of errors to the user, it is
   acceptable for such reporting to only be observable in an error
   console or log file.  Likewise, requirements that an automated action
   be confirmed by the user before proceeding might be met via advance
   configuration choices, run-time options, or simple avoidance of the
   unsafe action; confirmation does not imply any specific user
   interface or interruption of normal processing if the user has
   already made that choice.</source>
          <target state="translated">HTTP 디자인을 고려할 때 모든 사용자 에이전트가 범용 브라우저이고 모든 오리진 서버가 대규모 공용 웹 사이트라는 생각에 쉽게 빠질 수 있습니다. 실제로는 그렇지 않습니다. 일반적인 HTTP 사용자 에이전트에는 다양한 모양과 크기의 가전 제품, 스테레오, 스케일, 펌웨어 업데이트 스크립트, 명령 줄 프로그램, 모바일 앱 및 통신 장치가 포함됩니다. 마찬가지로 일반적인 HTTP 오리진 서버에는 홈 자동화 장치, 구성 가능한 네트워킹 구성 요소, 사무 기기, 자율 로봇, 뉴스 피드, 교통 카메라, 광고 선택기 및 비디오 배달 플랫폼이 포함됩니다. &quot;사용자 에이전트&quot;라는 용어는 요청시 소프트웨어 사용자와 직접 상호 작용하는 휴먼 사용자가 있음을 의미하지 않습니다. 많은 경우에,사용자 에이전트는 백그라운드에서 실행되고 나중에 검사하기 위해 결과를 저장하거나 흥미 롭거나 잘못된 결과의 하위 집합 만 저장하도록 설치 또는 구성됩니다. 예를 들어 스파이더에는 일반적으로 시작 URI가 제공되며 웹을 하이퍼 텍스트 그래프로 크롤링하는 동안 특정 동작을 따르도록 구성됩니다. HTTP의 구현 다양성은 모든 사용자 에이전트가 사용자에게 대화식 제안을하거나 보안 또는 개인 정보 보호 문제에 대해 적절한 경고를 제공 할 수있는 것은 아닙니다. 이 사양에서 사용자에게 오류를보고해야하는 경우가 거의 없지만 이러한보고는 오류 콘솔 또는 로그 파일에서만 관찰 할 수 있습니다. 마찬가지로,진행하기 전에 사용자가 자동 ​​조치를 확인해야하는 요구 사항은 사전 구성 선택, 런타임 옵션 또는 안전하지 않은 조치의 간단한 회피를 통해 충족 될 수 있습니다. 사용자가 이미 선택한 경우 확인은 특정 사용자 인터페이스 또는 정상적인 처리 중단을 의미하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a827c5b68b1342f6b9dfe8a6f1bbe7a2e6832493" translate="yes" xml:space="preserve">
          <source>When considering using the user agent string to detect which browser is being used, your first step is to try to avoid it if possible. Start by trying to identify &lt;strong&gt;why&lt;/strong&gt; you want to do it.</source>
          <target state="translated">사용중인 브라우저를 감지하기 위해 사용자 에이전트 문자열 사용을 고려할 때 첫 번째 단계는 가능한 경우이를 피하는 것입니다. &lt;strong&gt;왜&lt;/strong&gt; 당신이 그것을 원하는지 &lt;strong&gt;알아&lt;/strong&gt; 내려고 노력 하십시오.</target>
        </trans-unit>
        <trans-unit id="363ec37ef9e1fc22a7e69c6d6b95891d8282b35a" translate="yes" xml:space="preserve">
          <source>When content negotiation preferences are sent by the user agent in a
   request to encourage an algorithm located at the server to select the
   preferred representation, it is called proactive negotiation (a.k.a.,
   server-driven negotiation).  Selection is based on the available
   representations for a response (the dimensions over which it might
   vary, such as language, content-coding, etc.) compared to various
   information supplied in the request, including both the explicit
   negotiation fields of &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt; and implicit characteristics, such
   as the client's network address or parts of the User-Agent field.

   Proactive negotiation is advantageous when the algorithm for
   selecting from among the available representations is difficult to
   describe to a user agent, or when the server desires to send its
   &quot;best guess&quot; to the user agent along with the first response (hoping
   to avoid the round trip delay of a subsequent request if the &quot;best
   guess&quot; is good enough for the user).  In order to improve the
   server's guess, a user agent MAY send request header fields that
   describe its preferences.

   Proactive negotiation has serious disadvantages:

   o  It is impossible for the server to accurately determine what might
      be &quot;best&quot; for any given user, since that would require complete
      knowledge of both the capabilities of the user agent and the
      intended use for the response (e.g., does the user want to view it
      on screen or print it on paper?);

   o  Having the user agent describe its capabilities in every request
      can be both very inefficient (given that only a small percentage
      of responses have multiple representations) and a potential risk
      to the user's privacy;

   o  It complicates the implementation of an origin server and the
      algorithms for generating responses to a request; and, 

   o  It limits the reusability of responses for shared caching.

   A user agent cannot rely on proactive negotiation preferences being
   consistently honored, since the origin server might not implement
   proactive negotiation for the requested resource or might decide that
   sending a response that doesn't conform to the user agent's
   preferences is better than sending a 406 (Not Acceptable) response.

   A Vary header field (&lt;a href=&quot;#section-7.1.4&quot;&gt;Section 7.1.4&lt;/a&gt;) is often sent in a response
   subject to proactive negotiation to indicate what parts of the
   request information were used in the selection algorithm.</source>
          <target state="translated">서버에 위치한 알고리즘이 선호 표현을 선택하도록 요청하기 위해 사용자 에이전트가 컨텐츠 협상 환경 설정을 전송하는 경우이를 사전 협상 (일명 서버 중심 협상)이라고합니다. 선택은 &lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt; 의 명시 적 협상 필드를 포함하여 요청에 제공된 다양한 정보와 비교하여 응답에 사용 가능한 표현 (언어, 컨텐츠 코딩 등의 다양한 차원)을 기반으로합니다.및 클라이언트의 네트워크 주소 또는 User-Agent 필드의 일부와 같은 암시 적 특성. 사용 가능한 표현 중에서 선택하는 알고리즘이 사용자 에이전트에 설명하기 어렵거나 서버가 첫 번째 응답과 함께 &quot;최상의 추측&quot;을 사용자 에이전트에 보내려고 할 때 사전 협상이 유리합니다 (라운드를 피하기 위해 호핑). &quot;최상의 추측&quot;이 사용자에게 충분한 경우 후속 요청의 트립 지연). 서버의 추측을 향상시키기 위해 사용자 에이전트는 환경 설정을 설명하는 요청 헤더 필드를 보낼 수 있습니다. 사전 협상에는 다음과 같은 심각한 단점이 있습니다. o 서버가 특정 사용자에게 &quot;최상의&quot;항목을 정확하게 결정하는 것은 불가능합니다.왜냐하면 사용자 에이전트의 기능과 응답에 의도 된 용도에 대한 완전한 지식이 필요하기 때문입니다 (예 : 사용자가 화면에서 보거나 종이에 인쇄하겠습니까?). o 모든 요청에서 사용자 에이전트가 자신의 기능을 설명하도록하는 것은 매우 비효율적 일 수 있습니다 (작은 비율의 응답 만 여러 가지 표현으로 표시됨) 및 사용자 개인 정보에 대한 잠재적 위험. o 오리진 서버의 구현과 요청에 대한 응답을 생성하는 알고리즘을 복잡하게합니다. 그리고 o 공유 캐싱에 대한 응답의 재사용 성을 제한합니다. 사용자 에이전트는 사전 협상 기본 설정이 지속적으로 존중되는 것에 의존 할 수 없습니다.오리진 서버가 요청 된 자원에 대한 사전 협상을 구현하지 않거나 사용자 에이전트의 환경 설정에 맞지 않는 응답을 보내는 것이 406 (Not Acceptable) 응답을 보내는 것보다 낫다고 결정할 수 있기 때문입니다. Vary 헤더 필드 (&lt;a href=&quot;#section-7.1.4&quot;&gt;섹션 7.1.4&lt;/a&gt; )는 종종 요청 알고리즘의 어느 부분이 선택 알고리즘에 사용되었는지를 나타 내기 위해 사전 협상을 거쳐 응답으로 전송된다.</target>
        </trans-unit>
        <trans-unit id="6e8b863a8325429fa580715d5e011bccf6680ef8" translate="yes" xml:space="preserve">
          <source>When generating the hash, don't include the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; tags and note that capitalization and whitespace matter, including leading or trailing whitespace.</source>
          <target state="translated">해시를 생성 할 때 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; 태그를 포함하지 말고 선행 또는 후행 공백을 포함하여 대문자 및 공백 문제를 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="3f48bce4871048870c1db54917c2fa532f74b23b" translate="yes" xml:space="preserve">
          <source>When generating the hash, don't include the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; tags and note that capitalization and whitespace matter, including leading or trailing whitespace.</source>
          <target state="translated">해시를 생성 할 때 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; 태그를 포함하지 말고 선행 또는 후행 공백을 포함하여 대문자 및 공백 문제를 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="9503f3849e836b443578c208529989db300450fe" translate="yes" xml:space="preserve">
          <source>When it is necessary to express semantics for a response that are not
   defined by current status codes, a new status code can be registered.
   Status codes are generic; they are potentially applicable to any
   resource, not just one particular media type, kind of resource, or
   application of HTTP.  As such, it is preferred that new status codes
   be registered in a document that isn't specific to a single
   application.

   New status codes are required to fall under one of the categories
   defined in &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;.  To allow existing parsers to process the
   response message, new status codes cannot disallow a payload,
   although they can mandate a zero-length payload body.

   Proposals for new status codes that are not yet widely deployed ought
   to avoid allocating a specific number for the code until there is
   clear consensus that it will be registered; instead, early drafts can
   use a notation such as &quot;4NN&quot;, or &quot;3N0&quot; .. &quot;3N9&quot;, to indicate the
   class of the proposed status code(s) without consuming a number
   prematurely.

   The definition of a new status code ought to explain the request
   conditions that would cause a response containing that status code
   (e.g., combinations of request header fields and/or method(s)) along
   with any dependencies on response header fields (e.g., what fields
   are required, what fields can modify the semantics, and what header
   field semantics are further refined when used with the new status
   code).

   The definition of a new status code ought to specify whether or not
   it is cacheable.  Note that all status codes can be cached if the
   response they occur in has explicit freshness information; however,
   status codes that are defined as being cacheable are allowed to be
   cached without explicit freshness information.  Likewise, the
   definition of a status code can place constraints upon cache
   behavior.  See [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;] for more information.

   Finally, the definition of a new status code ought to indicate
   whether the payload has any implied association with an identified
   resource (&lt;a href=&quot;#section-3.1.4.1&quot;&gt;Section 3.1.4.1&lt;/a&gt;).</source>
          <target state="translated">현재 상태 코드에 의해 정의되지 않은 응답에 대한 의미를 표현할 필요가있는 경우 새로운 상태 코드를 등록 할 수 있습니다. 상태 코드는 일반적입니다. 이들은 하나의 특정 미디어 유형, 종류의 리소스 또는 HTTP 응용 프로그램뿐만 아니라 모든 리소스에 적용 할 수 있습니다. 따라서 단일 응용 프로그램과 관련이없는 문서에 새 상태 코드를 등록하는 것이 좋습니다. 새로운 상태 코드는 &lt;a href=&quot;#section-6&quot;&gt;6 장에&lt;/a&gt; 정의 된 범주 중 하나에 속해야합니다.. 기존 파서가 응답 메시지를 처리 ​​할 수 ​​있도록 새 상태 코드는 길이가 0 인 페이로드 본문을 위임 할 수 있지만 페이로드를 허용하지 않습니다. 아직 널리 배포되지 않은 새로운 상태 코드에 대한 제안은 코드가 등록 될 것이라는 명확한 합의가있을 때까지 코드에 특정 번호를 할당하지 않아야합니다. 대신 초안은 &quot;4NN&quot;또는 &quot;3N0&quot;.. &quot;3N9&quot;와 같은 표기법을 사용하여 번호를 조기에 소비하지 않고 제안 된 상태 코드의 클래스를 표시 할 수 있습니다. 새로운 상태 코드의 정의는 해당 상태 코드를 포함하는 응답 (예 : 요청 헤더 필드 및 / 또는 방법의 조합)과 응답 헤더 필드에 대한 종속성 (예 : 필드는 필수입니다시맨틱을 수정할 수있는 필드 및 새 상태 코드와 함께 사용될 때 어떤 헤더 필드 시맨틱이 더 세분화되는지) 새로운 상태 코드의 정의는 캐시 가능 여부를 지정해야합니다. 응답에 명시 적 최신 정보가있는 경우 모든 상태 코드를 캐시 할 수 있습니다. 그러나 캐시 가능으로 정의 된 상태 코드는 명시 적 최신 정보없이 캐시 될 수 있습니다. 마찬가지로, 상태 코드의 정의는 캐시 동작에 제약을 둘 수 있습니다. 보다 [응답에 명시 적 최신 정보가있는 경우 모든 상태 코드를 캐시 할 수 있습니다. 그러나 캐시 가능으로 정의 된 상태 코드는 명시 적 최신 정보없이 캐시 될 수 있습니다. 마찬가지로, 상태 코드의 정의는 캐시 동작에 제약을 둘 수 있습니다. 보다 [응답에 명시 적 최신 정보가있는 경우 모든 상태 코드를 캐시 할 수 있습니다. 그러나 캐시 가능으로 정의 된 상태 코드는 명시 적 최신 정보없이 캐시 될 수 있습니다. 마찬가지로, 상태 코드의 정의는 캐시 동작에 제약을 둘 수 있습니다. 보다 [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;&lt;/a&gt;자세한 정보는 RFC7234 ]를 참조하십시오. 마지막으로, 새로운 상태 코드의 정의는 페이로드에 식별 된 자원과의 암시 적 연관이 있는지 여부를 표시해야합니다 ( &lt;a href=&quot;#section-3.1.4.1&quot;&gt;섹션 3.1.4.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="992ffeef665788e48dbe3069859c70bc8ca73c53" translate="yes" xml:space="preserve">
          <source>When making a request to a proxy, other than a CONNECT or server-wide
   OPTIONS request (as detailed below), a client MUST send the target
   URI in absolute-form as the request-target.

     absolute-form  = absolute-URI

   The proxy is requested to either service that request from a valid
   cache, if possible, or make the same request on the client's behalf
   to either the next inbound proxy server or directly to the origin
   server indicated by the request-target.  Requirements on such
   &quot;forwarding&quot; of messages are defined in &lt;a href=&quot;#section-5.7&quot;&gt;Section 5.7&lt;/a&gt;.

   An example absolute-form of request-line would be:

     GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1 

   To allow for transition to the absolute-form for all requests in some
   future version of HTTP, a server MUST accept the absolute-form in
   requests, even though HTTP/1.1 clients will only send them in
   requests to proxies.</source>
          <target state="translated">CONNECT 또는 서버 차원의 OPTIONS 요청 이외의 프록시에 요청을 할 때 (아래에 설명 된 바와 같이), 클라이언트는 절대로 URI를 요청 대상으로 보내야합니다. absolute-form = absolute-URI 프록시는 가능한 경우 유효한 캐시에서 요청한 서비스를 제공하거나 클라이언트를 대신하여 다음 인바운드 프록시 서버 또는 요청에 의해 표시된 원래 서버에 동일한 요청을하도록 요청됩니다. -표적. 이러한 메시지 전달에 대한 요구 사항 &lt;a href=&quot;#section-5.7&quot;&gt;은 5.7 절에&lt;/a&gt; 정의되어있다.. 요청 라인의 절대 형식의 예는 다음과 같습니다. GET http://www.example.org/pub/WWW/TheProject.html HTTP / 1.1 향후 버전의 모든 요청에 ​​대한 절대 형식으로의 전환을 허용하려면 HTTP, 1.1 클라이언트는 요청으로 프록시를 보내더라도 서버는 절대 형식의 요청을 수락해야합니다.</target>
        </trans-unit>
        <trans-unit id="5964da98a7563489c792bd7738fa111b60299bfb" translate="yes" xml:space="preserve">
          <source>When more than one conditional request header field is present in a
   request, the order in which the fields are evaluated becomes
   important.  In practice, the fields defined in this document are
   consistently implemented in a single, logical order, since &quot;lost
   update&quot; preconditions have more strict requirements than cache
   validation, a validated cache is more efficient than a partial
   response, and entity tags are presumed to be more accurate than date
   validators.

   A recipient cache or origin server MUST evaluate the request
   preconditions defined by this specification in the following order:

   1.  When recipient is the origin server and If-Match is present,
       evaluate the If-Match precondition:

       *  if true, continue to step 3

       *  if false, respond 412 (Precondition Failed) unless it can be
          determined that the state-changing request has already
          succeeded (see &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;) 

   2.  When recipient is the origin server, If-Match is not present, and
       If-Unmodified-Since is present, evaluate the If-Unmodified-Since
       precondition:

       *  if true, continue to step 3

       *  if false, respond 412 (Precondition Failed) unless it can be
          determined that the state-changing request has already
          succeeded (see &lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt;)

   3.  When If-None-Match is present, evaluate the If-None-Match
       precondition:

       *  if true, continue to step 5

       *  if false for GET/HEAD, respond 304 (Not Modified)

       *  if false for other methods, respond 412 (Precondition Failed)

   4.  When the method is GET or HEAD, If-None-Match is not present, and
       If-Modified-Since is present, evaluate the If-Modified-Since
       precondition:

       *  if true, continue to step 5

       *  if false, respond 304 (Not Modified)

   5.  When the method is GET and both Range and If-Range are present,
       evaluate the If-Range precondition:

       *  if the validator matches and the Range specification is
          applicable to the selected representation, respond 206
          (Partial Content) [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]

   6.  Otherwise,

       *  all conditions are met, so perform the requested action and
          respond according to its success or failure.

   Any extension to HTTP/1.1 that defines additional conditional request
   header fields ought to define its own expectations regarding the
   order for evaluating such fields in relation to those defined in this
   document and other conditionals that might be found in practice.</source>
          <target state="translated">요청에 둘 이상의 조건부 요청 헤더 필드가있는 경우 필드 평가 순서가 중요해집니다. 실제로, &quot;손실 된 업데이트&quot;전제 조건은 캐시 유효성 검증보다 엄격한 요구 사항이 있고 유효성 검증 된 캐시는 부분 응답보다 효율적이며 엔티티 태그는 다음과 같이 가정되므로이 문서에 정의 된 필드는 단일 논리 순서로 일관되게 구현됩니다. 날짜 유효성 검사기보다 정확합니다. 수신자 캐시 또는 오리진 서버는이 스펙에 의해 정의 된 요청 전제 조건을 다음 순서로 평가해야합니다. 1. 수신자가 오리진 서버이고 If-Match가있는 경우 If-Match 전제 조건을 평가하십시오. * true이면 3 단계를 계속하십시오. * 거짓 인 경우상태 변경 요청이 이미 완료되었다고 판단 할 수없는 경우 412 (사전 조건 실패)로 응답하십시오 (참조).&lt;a href=&quot;#section-3.1&quot;&gt;섹션 3.1&lt;/a&gt; ) 2. 수신자가 오리진 서버 인 경우 If-Match가없고 If-Unmodified-Since가있는 경우 If-Unmodified-Since 전제 조건을 평가하십시오. * true 인 경우 3 단계를 계속하십시오. * false 인 경우 응답하십시오. 상태 변경 요청이 이미 성공했다고 판정되지 않는 한 (412) (전제 실패) (참조 : &lt;a href=&quot;#section-3.4&quot;&gt;3.4 절&lt;/a&gt;) 3. If-None-Match가있는 경우 If-None-Match 전제 조건을 평가하십시오. * true 인 경우 5 단계를 계속하십시오. * GET / HEAD에 대해 false 인 경우 304 (수정되지 않음) * 다른 방법에 대해 false 인 경우, 응답 412 (전제 조건 실패) 4. 분석법이 GET 또는 HEAD 인 경우 If-None-Match가없고 If-Modified-Since가있는 경우 If-Modified-Since 전제 조건을 평가하십시오. * true이면 단계를 계속하십시오. 5 * false 인 경우 304 (수정되지 않음)로 응답합니다. 5. 분석법이 GET이고 범위 및 범위 범위가 모두 존재하는 경우 If-Range 전제 조건을 평가하십시오. * 유효성 검증 기가 일치하고 범위 스펙이 선택된 표시에 적용 가능한 경우 응답 206 (부분 컨텐츠) [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;] 6. 그렇지 않으면 * 모든 조건이 충족되므로 요청 된 조치를 수행하고 성공 또는 실패에 따라 응답하십시오. 추가 조건부 요청 헤더 필드를 정의하는 HTTP / 1.1의 확장은이 문서에 정의 된 것과 관련하여 해당 필드를 평가하는 순서 및 실제로 발견 될 수있는 다른 조건에 대한 자체 기대치를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="012095a2ecfbd653fa333e34acf5cb049a30844a" translate="yes" xml:space="preserve">
          <source>When multiple transfer codings are acceptable, the &lt;code&gt;q&lt;/code&gt; parameter of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality value&lt;/a&gt; syntax can rank codings by preference.</source>
          <target state="translated">다중 전송 코딩이 허용 될 때 , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;품질 값&lt;/a&gt; 신택스 의 &lt;code&gt;q&lt;/code&gt; 파라미터는 선호도에 따라 코딩 순위를 매길 수있다.</target>
        </trans-unit>
        <trans-unit id="f6fe88ae046c3e416533e0417c1df22db8f56bfa" translate="yes" xml:space="preserve">
          <source>When navigating through different networks of the Internet, proxy servers and HTTP tunnels are facilitating access to content on the World Wide Web. A proxy can be on the user's local computer, or anywhere between the user's computer and a destination server on the Internet. This page outlines some basics about proxies and introduces a few configuration options.</source>
          <target state="translated">인터넷의 다른 네트워크를 탐색 할 때 프록시 서버와 HTTP 터널은 World Wide Web의 콘텐츠에 대한 액세스를 용이하게합니다. 프록시는 사용자의 로컬 컴퓨터 또는 사용자의 컴퓨터와 인터넷의 대상 서버 사이에있을 수 있습니다. 이 페이지에서는 프록시에 대한 몇 가지 기본 사항을 설명하고 몇 가지 구성 옵션을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="f45873daa29905f82c21b98d3ce8067de352cd0b" translate="yes" xml:space="preserve">
          <source>When navigating through different networks of the Internet, proxy servers and HTTP tunnels are facilitating access to content on the World Wide Web. A proxy can be on the user's local computer, or anywhere between the user's computer and an destination server on the Internet. This page outlines some basics about proxies and introduces a few configuration options.</source>
          <target state="translated">인터넷의 다른 네트워크를 탐색 할 때 프록시 서버와 HTTP 터널은 월드 와이드 웹의 컨텐츠에 대한 액세스를 용이하게합니다. 프록시는 사용자의 로컬 컴퓨터에 있거나 사용자 컴퓨터와 인터넷의 대상 서버 사이에있을 수 있습니다. 이 페이지는 프록시에 대한 몇 가지 기본 사항을 설명하고 몇 가지 구성 옵션을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="2cf69f0b62bc3201eb1d5247cb7d21efe9fcd7bc" translate="yes" xml:space="preserve">
          <source>When passing a string literal like to methods like: &lt;code&gt;window.setTimeout(&quot;alert(\&quot;Hello World!\&quot;);&quot;, 500);&lt;/code&gt;</source>
          <target state="translated">다음과 같은 메소드와 같은 문자열 리터럴을 전달할 때 : &lt;code&gt;window.setTimeout(&quot;alert(\&quot;Hello World!\&quot;);&quot;, 500);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d3e1568b9d8f26b7cf9b41cc05173988e6bafcb" translate="yes" xml:space="preserve">
          <source>When people say they want &quot;browser detection&quot;, often they actually want &quot;rendering engine detection&quot;. Do you actually want to detect Firefox, as opposed to SeaMonkey, or Chrome as opposed to Chromium? Or do you actually simply want to see if the browser is using the Gecko or the WebKit rendering engine? If this is what you need, see further down the page.</source>
          <target state="translated">사람들이 &quot;브라우저 감지&quot;를 원할 때 종종 &quot;렌더링 엔진 감지&quot;를 원합니다. 실제로 SeaMonkey가 아닌 Firefox 또는 Chromium이 아닌 Chrome을 감지 하시겠습니까? 아니면 브라우저가 Gecko 또는 WebKit 렌더링 엔진을 사용하고 있는지 실제로보고 싶습니까? 이것이 필요한 것이라면, 페이지 아래쪽을 더보십시오.</target>
        </trans-unit>
        <trans-unit id="641c314e0a3e7172c6dc4519de6003467c4aa390" translate="yes" xml:space="preserve">
          <source>When performing If header processing, the definition of a matching
   state token or entity tag is as follows:

   Identifying a resource: The resource is identified by the URI along
   with the token, in tagged list production, or by the Request-URI in
   untagged list production.

   Matching entity tag: Where the entity tag matches an entity tag
   associated with the identified resource.  Servers MUST use either the
   weak or the strong comparison function defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.3.3&quot;&gt;Section&amp;nbsp;13.3.3 of
   [RFC2616]&lt;/a&gt;.

   Matching state token: Where there is an exact match between the state
   token in the If header and any state token on the identified
   resource.  A lock state token is considered to match if the resource
   is anywhere in the scope of the lock.

   Handling unmapped URLs: For both ETags and state tokens, treat as if
   the URL identified a resource that exists but does not have the
   specified state.</source>
          <target state="translated">If 헤더 처리를 수행 할 때 일치하는 상태 토큰 또는 엔티티 태그의 정의는 다음과 같습니다. 자원 식별 : 자원은 토큰과 함께 URI, 태그가 지정된 목록 생성 또는 태그가없는 목록의 Request-URI로 식별됩니다. 생산. 일치하는 엔티티 태그 : 엔티티 태그는 식별 된 자원과 연관된 엔티티 태그와 일치합니다. 서버 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.3.3&quot;&gt;는 [RFC2616]의 13.3.3 절에&lt;/a&gt; 정의 된 약한 또는 강한 비교 기능을 사용해야합니다 .. 일치하는 상태 토큰 : If 헤더의 상태 토큰과 식별 된 자원의 모든 상태 토큰이 정확히 일치하는 경우. 리소스가 잠금 범위 내에있는 경우 잠금 상태 토큰이 일치하는 것으로 간주됩니다. 매핑되지 않은 URL 처리 : ETag 및 상태 토큰 모두 URL이 존재하지만 지정된 상태가 아닌 리소스를 식별 한 것처럼 처리합니다.</target>
        </trans-unit>
        <trans-unit id="2e596c5772c2e6ae2a45b036f02565ea11dd1152" translate="yes" xml:space="preserve">
          <source>When possible, use HTTP redirects and don't add &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element redirects. If someone changes the HTTP redirects but forgets to change the HTML redirects, the redirects will no longer be identical, which could cause an infinite loop or other nightmares.</source>
          <target state="translated">가능하면 HTTP 리디렉션을 사용하고 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 리디렉션을 추가하지 마십시오 . 누군가 HTTP 리디렉션을 변경했지만 HTML 리디렉션을 변경하는 것을 잊은 경우 리디렉션이 더 이상 동일하지 않아 무한 루프 또는 기타 악몽이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="431409982a981ed89ff2dc5506166f45957e0a11" translate="yes" xml:space="preserve">
          <source>When possible, use HTTP redirects, and don't add &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element redirects. If someone changes the HTTP redirects and forgets to change the HTML redirects the redirects will no longer be identical, which could cause an infinite loop or other nightmares.</source>
          <target state="translated">가능하면 HTTP 리디렉션을 사용하고 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 리디렉션을 추가하지 마십시오 . 누군가 HTTP 리디렉션을 변경하고 HTML 리디렉션 변경을 잊어 버린 경우 리디렉션이 더 이상 동일하지 않아 무한 루프 또는 기타 악몽이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c6db50a4bbf09d3b72d3f46fb9f7f812630cfd6" translate="yes" xml:space="preserve">
          <source>When present on a response to a &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request that has no body, it indicates the value that would have applied to the corresponding &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; message.</source>
          <target state="translated">본문이없는 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 요청 에 대한 응답 이 있으면 해당 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 메시지에 적용되는 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="8d602fc4361edf535f13cf0e83c68250a27555fa" translate="yes" xml:space="preserve">
          <source>When present with the &lt;code&gt;enforce&lt;/code&gt; directive, the configuration is referred to as an &quot;enforce-and-report&quot; configuration, signalling to the user agent both that compliance to the Certificate Transparency policy should be enforced &lt;em&gt;and&lt;/em&gt; that violations should be reported.</source>
          <target state="translated">에 존재하는 경우 &lt;code&gt;enforce&lt;/code&gt; 지침이 구성이 인증서 투명성 정책이 준수가 모두 적용되어야하는 사용자 에이전트에 신호,에 &quot;시행 앤 보고서&quot;를 구성이라 &lt;em&gt;하고&lt;/em&gt; 위반에보고해야한다.</target>
        </trans-unit>
        <trans-unit id="2677bfe338fef1db9d7d5bb4695ba60efdfb09e0" translate="yes" xml:space="preserve">
          <source>When presented with a request, a cache MUST NOT reuse a stored
   response, unless:

   o  The presented effective request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7230]&lt;/a&gt;) and
      that of the stored response match, and

   o  the request method associated with the stored response allows it
      to be used for the presented request, and

   o  selecting header fields nominated by the stored response (if any)
      match those presented (see &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;), and 

   o  the presented request does not contain the no-cache pragma
      (&lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;), nor the no-cache cache directive (&lt;a href=&quot;#section-5.2.1&quot;&gt;Section 5.2.1&lt;/a&gt;),
      unless the stored response is successfully validated
      (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;), and

   o  the stored response does not contain the no-cache cache directive
      (&lt;a href=&quot;#section-5.2.2.2&quot;&gt;Section 5.2.2.2&lt;/a&gt;), unless it is successfully validated
      (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;), and

   o  the stored response is either:

      *  fresh (see &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;), or

      *  allowed to be served stale (see &lt;a href=&quot;#section-4.2.4&quot;&gt;Section 4.2.4&lt;/a&gt;), or

      *  successfully validated (see &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).

   Note that any of the requirements listed above can be overridden by a
   cache-control extension; see &lt;a href=&quot;#section-5.2.3&quot;&gt;Section 5.2.3&lt;/a&gt;.

   When a stored response is used to satisfy a request without
   validation, a cache MUST generate an Age header field (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;),
   replacing any present in the response with a value equal to the
   stored response's current_age; see &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;.

   A cache MUST write through requests with methods that are unsafe
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7231]&lt;/a&gt;) to the origin server; i.e., a cache is
   not allowed to generate a reply to such a request before having
   forwarded the request and having received a corresponding response.

   Also, note that unsafe requests might invalidate already-stored
   responses; see &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;.

   When more than one suitable response is stored, a cache MUST use the
   most recent response (as determined by the Date header field).  It
   can also forward the request with &quot;Cache-Control: max-age=0&quot; or
   &quot;Cache-Control: no-cache&quot; to disambiguate which response to use.

   A cache that does not have a clock available MUST NOT use stored
   responses without revalidating them upon every use.</source>
          <target state="translated">요청과 함께 제시된 캐시는 다음과 같은 경우를 제외하고는 저장된 응답을 재사용해서는 안된다. o 제시된 유효 요청 URI ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]의 섹션 5.5&lt;/a&gt; )와 저장된 응답이 일치하는 것 및 o 저장된 응답과 관련된 요청 방법은 제시된 요청에 사용될 것이며, o 저장된 응답에 의해 지명 된 헤더 필드 (있는 경우)를 선택하는 것은 제시된 것과 일치하며 ( &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt; 참조 ) 제시된 요청은 캐시없는 프라그 마를 포함하지 않는다 ( &lt;a href=&quot;#section-5.4&quot;&gt;섹션 5.4&lt;/a&gt; ) 저장된 응답의 유효성이 성공적으로 검사되지 않는 한 캐시없는 캐시 지정 문 ( &lt;a href=&quot;#section-5.2.1&quot;&gt;섹션 5.2.1&lt;/a&gt; ) 또는 &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt;), o 저장된 응답 이 성공적으로 검증되지 않은 경우 ( &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt; ) 캐시없는 캐시 지시문 ( &lt;a href=&quot;#section-5.2.2.2&quot;&gt;5.2.2.2&lt;/a&gt; )을 포함하지 않으며 o 저장된 응답이 다음과 같은 경우 : * 새로 고침 ( &lt;a href=&quot;#section-4.2&quot;&gt;섹션 4.2&lt;/a&gt; 참조 ) 또는 * 부실하게 제공 되거나 ( &lt;a href=&quot;#section-4.2.4&quot;&gt;섹션 4.2.4&lt;/a&gt; 참조 ) * 성공적으로 검증되었습니다 ( &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt; 참조 ). 위에 나열된 요구 사항은 캐시 제어 확장으로 재정의 될 수 있습니다. &lt;a href=&quot;#section-5.2.3&quot;&gt;섹션 5.2.3&lt;/a&gt; 참조 . 저장된 응답이 유효성 검증없이 요청을 만족시키기 위해 사용될 때, 캐시는 반드시 Age 헤더 필드를 생성해야합니다 ( &lt;a href=&quot;#section-5.1&quot;&gt;섹션 5.1)&lt;/a&gt;), 응답에 존재하는 임의의 것을 저장된 응답의 current_age와 동일한 값으로 대체; &lt;a href=&quot;#section-4.2.3&quot;&gt;섹션 4.2.3&lt;/a&gt; 참조 . 캐시는 안전하지 않은 메소드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;[RFC7231]의 섹션 4.2.1&lt;/a&gt; )로 요청을 통해 오리진 서버에 기록해야합니다. 즉, 캐시는 요청을 전달하고 대응하는 응답을 수신하기 전에 이러한 요청에 대한 응답을 생성 할 수 없다. 또한 안전하지 않은 요청은 이미 저장된 응답을 무효화 할 수 있습니다. &lt;a href=&quot;#section-4.4&quot;&gt;4.4 절&lt;/a&gt; 참조. 하나 이상의 적절한 응답이 저장되면 캐시는 가장 최근의 응답을 사용해야합니다 (날짜 헤더 필드에 의해 결정됨). 또한 &quot;Cache-Control : max-age = 0&quot;또는 &quot;Cache-Control : no-cache&quot;로 요청을 전달하여 사용할 응답을 명확하게 할 수 있습니다. 사용 가능한 클럭이없는 캐시는 매번 사용할 때마다 유효성을 검사하지 않고 저장된 응답을 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="118ca9fdf6295ed6b61ba0d26cdb23fa50df2281" translate="yes" xml:space="preserve">
          <source>When receiving an HTTP request, a server can send a &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header with the response. The cookie is usually stored by the browser, and then the cookie is sent with requests made to the same server inside a &lt;a href=&quot;headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; HTTP header. An expiration date or duration can be specified, after which the cookie is no longer sent. Additionally, restrictions to a specific domain and path can be set, limiting where the cookie is sent.</source>
          <target state="translated">HTTP 요청을 수신하면 서버는 응답과 함께 &lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; 헤더를 보낼 수 있습니다 . 쿠키는 일반적으로 브라우저에 의해 저장되고 &lt;a href=&quot;headers/cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt; HTTP 헤더 내의 동일한 서버에 대한 요청과 함께 쿠키가 전송됩니다 . 쿠키가 더 이상 전송되지 않는 만료 날짜 또는 기간을 지정할 수 있습니다. 또한 쿠키가 전송되는 위치를 제한하여 특정 도메인 및 경로에 대한 제한을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e9b93794ed31355629f157a820821c9c468143b" translate="yes" xml:space="preserve">
          <source>When requesting an image, like through an HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt; element, user-agent often sets a specific list of media types to be welcomed.</source>
          <target state="translated">HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 통해 이미지를 요청할 때 user-agent는 종종 특정 미디어 유형 목록을 환영하도록 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8497a7a0712bffc13bbeb91db7dcfe0053667c2b" translate="yes" xml:space="preserve">
          <source>When responding to a credentialed request, the server &lt;strong&gt;must&lt;/strong&gt; specify an origin in the value of the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header, instead of specifying the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard.</source>
          <target state="translated">자격 증명 요청에 응답 할 때 서버 &lt;strong&gt;는&lt;/strong&gt; &quot; &lt;code&gt;*&lt;/code&gt; &quot;와일드 카드 를 지정하는 대신 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더 값에 오리진을 지정 &lt;strong&gt;해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d1d5e8076fc20454045b01525a599db69f9d0096" translate="yes" xml:space="preserve">
          <source>When responses convey payload information, whether indicating a
   success or an error, the origin server often has different ways of
   representing that information; for example, in different formats,
   languages, or encodings.  Likewise, different users or user agents
   might have differing capabilities, characteristics, or preferences
   that could influence which representation, among those available,
   would be best to deliver.  For this reason, HTTP provides mechanisms
   for content negotiation.

   This specification defines two patterns of content negotiation that
   can be made visible within the protocol: &quot;proactive&quot;, where the
   server selects the representation based upon the user agent's stated
   preferences, and &quot;reactive&quot; negotiation, where the server provides a
   list of representations for the user agent to choose from.  Other
   patterns of content negotiation include &quot;conditional content&quot;, where
   the representation consists of multiple parts that are selectively
   rendered based on user agent parameters, &quot;active content&quot;, where the
   representation contains a script that makes additional (more
   specific) requests based on the user agent characteristics, and
   &quot;Transparent Content Negotiation&quot; ([&lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;RFC2295&lt;/a&gt;]), where content 

   selection is performed by an intermediary.  These patterns are not
   mutually exclusive, and each has trade-offs in applicability and
   practicality.

   Note that, in all cases, HTTP is not aware of the resource semantics.
   The consistency with which an origin server responds to requests,
   over time and over the varying dimensions of content negotiation, and
   thus the &quot;sameness&quot; of a resource's observed representations over
   time, is determined entirely by whatever entity or algorithm selects
   or generates those responses.  HTTP pays no attention to the man
   behind the curtain.</source>
          <target state="translated">응답이 성공 또는 오류를 나타내는 지 여부에 관계없이 페이로드 정보를 전달할 때 원래 서버는 종종 해당 정보를 나타내는 다른 방법을 갖습니다. 예를 들어, 다른 형식, 언어 또는 인코딩으로. 마찬가지로, 다른 사용자 또는 사용자 에이전트는 다른 표현, 사용 가능한 것 중에서 가장 표현하기에 영향을 줄 수있는 다른 기능, 특성 또는 선호도를 가질 수 있습니다. 이러한 이유로 HTTP는 컨텐츠 협상을위한 메커니즘을 제공합니다. 이 사양은 프로토콜 내에서 볼 수있는 두 가지 패턴의 콘텐츠 협상을 정의합니다. &quot;프로 액티브&quot;-서버가 사용자 에이전트의 지정된 기본 설정에 따라 표현을 선택합니다.여기서 서버는 사용자 에이전트가 선택할 수있는 표현 목록을 제공합니다. 컨텐츠 협상의 다른 패턴에는 &quot;조건부 컨텐츠&quot;가 있으며, 여기서 표현은 사용자 에이전트 매개 변수를 기반으로 선택적으로 렌더링되는 여러 부분으로 구성됩니다. &quot;활성 컨텐츠&quot;. 여기에는 표시에 따라 추가 (보다 구체적인) 요청을 작성하는 스크립트가 포함됩니다. 사용자 에이전트 특성 및 &quot;투명한 콘텐츠 협상&quot;([여기서 표현에는 사용자 에이전트 특성 및 &quot;투명한 내용 협상&quot;([Transparent Content Negotiation)에 따라 추가 (보다 구체적인) 요청을하는 스크립트가 포함됩니다.여기서 표현에는 사용자 에이전트 특성 및 &quot;투명한 내용 협상&quot;([Transparent Content Negotiation)에 따라 추가 (보다 구체적인) 요청을하는 스크립트가 포함됩니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;&lt;/a&gt;콘텐츠 선택은 중개자에 의해 수행되는 RFC2295 ]). 이러한 패턴은 상호 배타적이지 않으며 각각 적용 및 실용성에있어 절충점이 있습니다. 모든 경우에 HTTP는 자원 시맨틱을 인식하지 못합니다. 시간이 지남에 따라 그리고 컨텐츠 협상의 다양한 차원에 걸쳐 원 서버가 요청에 응답하는 일관성과 시간에 따른 자원의 관찰 된 표현의 &quot;동일성&quot;은 엔티티 또는 알고리즘이 해당 응답을 선택하거나 생성하는 모든 것에 의해 전적으로 결정됩니다. HTTP는 커튼 뒤의 사람에게주의를 기울이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb60f936f846aaffe2cddcca884c71458177df7b" translate="yes" xml:space="preserve">
          <source>When resuming to request more parts of a resource, you need to guarantee that the stored resource has not been modified since the last fragment has been received.</source>
          <target state="translated">자원의 더 많은 부분을 요청하기 위해 재개 할 때 마지막 조각이 수신 된 이후에 저장된 자원이 수정되지 않았 음을 보증해야합니다.</target>
        </trans-unit>
        <trans-unit id="112139cb42754557c5251097c3d9d57a0f0f1846" translate="yes" xml:space="preserve">
          <source>When saving changes to a wiki page (posting data), the &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request will contain the &lt;a href=&quot;../headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; header containing the &lt;code&gt;ETag&lt;/code&gt; values to check freshness against.</source>
          <target state="translated">Wiki 페이지 (게시 데이터)에 변경 사항을 저장할 때 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 요청에는 최신 성을 확인할 &lt;code&gt;ETag&lt;/code&gt; 값 이 포함 된 &lt;a href=&quot;../headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; 헤더가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="eb9c62d45614a9fc9c768607aa8dd717eb012aae" translate="yes" xml:space="preserve">
          <source>When saving changes to a wiki page (posting data), the &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request will contain the &lt;a href=&quot;if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; header containing the &lt;code&gt;ETag&lt;/code&gt; values to check freshness against.</source>
          <target state="translated">위키 페이지 (게시 데이터)에 변경 사항을 저장할 때 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 요청에는 최신 정보를 확인하기 위해 &lt;code&gt;ETag&lt;/code&gt; 값 이 포함 된 &lt;a href=&quot;if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; 헤더가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="3ecf0a10a5d9c4c3b83b0e8a52e69826167aa3c7" translate="yes" xml:space="preserve">
          <source>When sending a conditional request for cache validation, a cache
   sends one or more precondition header fields containing validator
   metadata from its stored response(s), which is then compared by
   recipients to determine whether a stored response is equivalent to a
   current representation of the resource.

   One such validator is the timestamp given in a Last-Modified header
   field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2&quot;&gt;Section&amp;nbsp;2.2 of [RFC7232]&lt;/a&gt;), which can be used in an
   If-Modified-Since header field for response validation, or in an
   If-Unmodified-Since or If-Range header field for representation
   selection (i.e., the client is referring specifically to a previously
   obtained representation with that timestamp).

   Another validator is the entity-tag given in an ETag header field
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7232]&lt;/a&gt;).  One or more entity-tags, indicating one
   or more stored responses, can be used in an If-None-Match header
   field for response validation, or in an If-Match or If-Range header
   field for representation selection (i.e., the client is referring
   specifically to one or more previously obtained representations with
   the listed entity-tags).</source>
          <target state="translated">캐시 유효성 검사를위한 조건부 요청을 보낼 때 캐시는 저장된 응답에서 유효성 검사기 메타 데이터를 포함하는 하나 이상의 전제 조건 헤더 필드를 보낸 다음받는 사람과 비교하여 저장된 응답이 리소스의 현재 표현과 같은지 여부를 확인합니다. . 이러한 유효성 검사기 중 하나는 Last-Modified 헤더 필드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2&quot;&gt;[RFC7232]의 섹션 2.2)에&lt;/a&gt; 제공된 타임 스탬프이며, 응답 유효성 검사를 위해 If-Modified-Since 헤더 필드 또는 If-Unmodified-Since 또는 If에 사용될 수 있습니다. 표현 선택을위한 범위 헤더 필드 (즉, 클라이언트는 구체적으로 그 타임 스탬프로 이전에 획득 된 표현을 참조하고 있음). 다른 유효성 검사기는 ETag 헤더 필드에 제공된 엔티티 태그 &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;입니다 ([RFC7232]의 2.3 절&lt;/a&gt;). 하나 이상의 저장된 응답을 나타내는 하나 이상의 엔티티 태그는 응답 유효성 검증을 위해 If-None-Match 헤더 필드 또는 표현 선택 (즉, 클라이언트)을위한 If-Match 또는 If-Range 헤더 필드에서 사용될 수 있습니다. (목록에 표시된 엔티티 태그를 사용하여 이전에 얻은 하나 이상의 표현을 구체적으로 언급하고 있음).</target>
        </trans-unit>
        <trans-unit id="fce832cc958ff4ef014da90639644dd9e45d6938" translate="yes" xml:space="preserve">
          <source>When sent with a &lt;a href=&quot;../status/429&quot;&gt;&lt;code&gt;429&lt;/code&gt;&lt;/a&gt; (Too Many Requests) response, this indicates how long to wait before making a new request.</source>
          <target state="translated">&lt;a href=&quot;../status/429&quot;&gt; &lt;code&gt;429&lt;/code&gt; &lt;/a&gt; (너무 많은 요청) 응답 과 함께 전송되면 새 요청을하기 전에 대기하는 시간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="79ae6cec0f4f3064c8648fb0e2f622088ea4675c" translate="yes" xml:space="preserve">
          <source>When sent with a &lt;a href=&quot;../status/503&quot;&gt;&lt;code&gt;503&lt;/code&gt;&lt;/a&gt; (Service Unavailable) response, this indicates how long the service is expected to be unavailable.</source>
          <target state="translated">&lt;a href=&quot;../status/503&quot;&gt; &lt;code&gt;503&lt;/code&gt; &lt;/a&gt; (Service Unavailable) 응답 과 함께 전송되면 서비스를 사용할 수 없을 것으로 예상되는 시간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e83d0887ca1d1fc9960fe8e57672e00926af79bd" translate="yes" xml:space="preserve">
          <source>When sent with a redirect response, such as &lt;a href=&quot;../status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; (Moved Permanently), this indicates the minimum time that the user agent is asked to wait before issuing the redirected request.</source>
          <target state="translated">&lt;a href=&quot;../status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt; (영구적으로 이동 됨) 과 같은 리디렉션 응답으로 전송되면 리디렉션 된 요청을 발행하기 전에 사용자 에이전트가 대기하도록 요청되는 최소 시간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c92c83a3263a103661248f1683416444f3d70f52" translate="yes" xml:space="preserve">
          <source>When submitting a lock request, a user agent may also submit an
   'owner' XML field giving contact information for the person taking
   out the lock (for those cases where a person, rather than a robot, is
   taking out the lock).  This contact information is stored in a DAV:
   lockdiscovery property on the resource, and can be used by other 

   collaborators to begin negotiation over access to the resource.
   However, in many cases, this contact information can be very private,
   and should not be widely disseminated.  Servers SHOULD limit read
   access to the DAV:lockdiscovery property as appropriate.
   Furthermore, user agents SHOULD provide control over whether contact
   information is sent at all, and if contact information is sent,
   control over exactly what information is sent.</source>
          <target state="translated">잠금 요청을 제출할 때 사용자 에이전트는 잠금을 수행하는 사람 (로봇이 아닌 사람이 잠금을 수행하는 경우)에 대한 연락처 정보를 제공하는 '소유자'XML 필드를 제출할 수도 있습니다. 이 연락처 정보는 리소스의 DAV : lockdiscovery 속성에 저장되며 다른 공동 작업자가 리소스 액세스에 대한 협상을 시작하는 데 사용할 수 있습니다. 그러나 대부분의 경우이 연락처 정보는 매우 개인 정보 일 수 있으므로 널리 보급되어서는 안됩니다. 서버는 DAV : lockdiscovery 속성에 대한 읽기 액세스를 적절하게 제한해야합니다. 또한 사용자 에이전트는 연락처 정보의 전송 여부에 대한 제어를 제공해야하며 연락처 정보가 전송되는 경우 정확히 어떤 정보가 전송되는지 제어해야합니다.</target>
        </trans-unit>
        <trans-unit id="48e2270a1e81d7fd634978728cb4b921d727d1ad" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Partial Content&lt;/code&gt; status code is sent, this MIME type indicates that the document is composed of several parts, one for each of the requested ranges. Like other multipart types, the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; uses a &lt;code&gt;boundary&lt;/code&gt; to separate the pieces. Each piece has a &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header with its actual type and a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; of the range it represents.</source>
          <target state="translated">때 &lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Partial Content&lt;/code&gt; 상태 코드가 전송되고,이 MIME 타입의 문서는 여러 부분, 요청 된 범위의 각각에 대한 하나의 구성을 나타냅니다. 다른 멀티 파트 유형과 마찬가지로 &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;boundary&lt;/code&gt; 를 사용 하여 조각을 분리합니다. 각 조각에는 실제 유형 의 &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 헤더와 그것이 나타내는 &lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; 의 Content-Range 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ba16d0b2909ed8c865e2f861632fd65055bfc45" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;POST&lt;/code&gt; request is sent via a method other than an HTML form &amp;mdash; like via an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; &amp;mdash; the body can take any type. As described in the HTTP 1.1 specification, &lt;code&gt;POST&lt;/code&gt; is designed to allow a uniform method to cover the following functions:</source>
          <target state="translated">때 &lt;code&gt;POST&lt;/code&gt; 의 요청이 HTML 양식 이외의 방법을 통해 전송됩니다 - 같은 통해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; 의&lt;/a&gt; - 몸은 모든 종류의 수 있습니다. HTTP 1.1 사양에 설명 된대로 &lt;code&gt;POST&lt;/code&gt; 는 균일 한 방법으로 다음 기능을 처리 할 수 ​​있도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="ee1ae4b4d29880b199bbb96de77973c9bb419343" translate="yes" xml:space="preserve">
          <source>When the client wants to communicate with a server, either being the final server or an intermediate proxy, it performs the following steps:</source>
          <target state="translated">클라이언트가 최종 서버 또는 중간 프록시 인 서버와 통신하려는 경우 다음 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b883869a25a4436318f14eff46717c107adc1c67" translate="yes" xml:space="preserve">
          <source>When the condition fails for &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, then the server must return HTTP status code 304 (Not Modified). For methods that apply server-side changes, the status code 412 (Precondition Failed) is used. Note that the server generating a 304 response MUST generate any of the following header fields that would have been sent in a 200 (OK) response to the same request: Cache-Control, Content-Location, Date, ETag, Expires, and Vary.</source>
          <target state="translated">&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 메소드에 대한 조건이 실패하면 서버는 HTTP 상태 코드 304 (수정되지 않음)를 리턴해야합니다. 서버 측 변경 사항을 적용하는 방법에는 상태 코드 412 (전제 조건 실패)가 사용됩니다. 304 응답을 생성하는 서버는 동일한 요청에 대해 200 (OK) 응답으로 전송 된 Cache-Control, Content-Location, Date, ETag, Expires 및 Vary와 같은 헤더 필드를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb9a689d273317ba5ef7624a99ac855ef096064b" translate="yes" xml:space="preserve">
          <source>When the expiration time specified by the Strict-Transport-Security header elapses, the next attempt to load the site via HTTP will proceed as normal instead of automatically using HTTPS.</source>
          <target state="translated">Strict-Transport-Security 헤더에 지정된 만료 시간이 경과하면 HTTP를 통해 사이트를로드하려는 다음 시도는 자동으로 HTTPS를 사용하는 대신 정상적으로 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="4d04c0cd831cfd20faa7e1fe732a4e0914639cf8" translate="yes" xml:space="preserve">
          <source>When the form is submitted, the site generates a receipt for the transaction. The server could use &lt;code&gt;Content-Location&lt;/code&gt; to indicate that receipt's URL for future access.</source>
          <target state="translated">양식이 제출되면 사이트는 거래에 대한 영수증을 생성합니다. 서버는 &lt;code&gt;Content-Location&lt;/code&gt; 을 사용 하여 나중에 액세스 할 수 있도록 영수증의 URL을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54bc09488c526dacffc841e2906f0ddbba4554d0" translate="yes" xml:space="preserve">
          <source>When the source resource is not a collection, the result of the COPY
   method is the creation of a new resource at the destination whose
   state and behavior match that of the source resource as closely as
   possible.  Since the environment at the destination may be different
   than at the source due to factors outside the scope of control of the
   server, such as the absence of resources required for correct
   operation, it may not be possible to completely duplicate the
   behavior of the resource at the destination.  Subsequent alterations
   to the destination resource will not modify the source resource.
   Subsequent alterations to the source resource will not modify the
   destination resource.</source>
          <target state="translated">소스 자원이 콜렉션이 아닌 경우 COPY 메소드의 결과는 대상에서 상태 및 동작이 소스 자원의 상태 및 동작과 최대한 일치하는 새 자원을 작성하는 것입니다. 서버의 제어 범위를 벗어난 요인 (예 : 올바른 작동에 필요한 자원이없는 등)으로 인해 대상의 환경이 소스의 환경과 다를 수 있으므로, 자원의 동작을 완전히 복제하지 못할 수 있습니다. 목적지. 이후에 대상 리소스를 변경해도 소스 리소스는 수정되지 않습니다. 이후에 소스 리소스를 변경해도 대상 리소스는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5486bfa60602bb895214d015f37fd5698ae7c49a" translate="yes" xml:space="preserve">
          <source>When to Use Entity-Tags and Last-Modified Dates (RFC 7232)</source>
          <target state="translated">엔터티 태그 및 최종 수정 날짜를 사용하는 경우 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="b34a4c2a8d2bd2be505eebfefc7f3521b9c0bbcf" translate="yes" xml:space="preserve">
          <source>When used as part of a response to a preflight request, this indicates whether or not the actual request can be made using credentials. Note that simple &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; requests are not preflighted, and so if a request is made for a resource with credentials, if this header is not returned with the resource, the response is ignored by the browser and not returned to web content.</source>
          <target state="translated">프리 플라이트 요청에 대한 응답의 일부로 사용되는 경우 실제 자격 증명을 사용하여 실제 요청을 수행 할 수 있는지 여부를 나타냅니다. 간단한 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 요청은 프리 플라이트되지 않으므로 자격 증명이있는 리소스를 요청하면이 헤더가 리소스와 함께 반환되지 않으면 브라우저에서 응답을 무시하고 웹 콘텐츠로 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6658a6f8ffe56893681a8ca01fe29c5f148086e" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-None-Match&lt;/code&gt; has precedence (if the server supports it).</source>
          <target state="translated">함께 사용되는 경우에 &lt;a href=&quot;if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;If-None-Match&lt;/code&gt; 우선 순위를 가지고 (서버가 지원하는 경우).</target>
        </trans-unit>
        <trans-unit id="a59bbd7394bbd946e2f8e6daaaadb0ebcf7845d8" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt;, it is ignored, unless the server doesn't support &lt;code&gt;If-None-Match&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt; 와 함께 사용 하면 서버가 &lt;code&gt;If-None-Match&lt;/code&gt; 를 지원하지 않는 한 무시 됩니다.</target>
        </trans-unit>
        <trans-unit id="940d765e5e6f04c24517cbcdc47ec43569264193" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt;: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/referrerPolicy&quot;&gt;&lt;code&gt;Request.referrerPolicy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;가져 오기&lt;/a&gt; 사용시 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/referrerPolicy&quot;&gt; &lt;code&gt;Request.referrerPolicy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95651ca261ced0fa7d7a802f20f0fac00474ad6e" translate="yes" xml:space="preserve">
          <source>When using URLs in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTML&quot;&gt;HTML&lt;/a&gt; content, you should generally only use a few of these URL schemes. When referring to subresources &amp;mdash; that is, files that are being loaded as part of a larger document &amp;mdash; you should only use the HTTP and HTTPS schemes. Increasingly, browsers are removing support for using FTP to load subresources, for security reasons.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTML&quot;&gt;HTML&lt;/a&gt; 내용 에서 URL을 사용할 때는 일반적으로 이러한 URL 체계 중 몇 가지만 사용해야합니다. 하위 문서 (더 큰 문서의 일부로로드되는 파일)를 참조 할 때는 HTTP 및 HTTPS 체계 만 사용해야합니다. 보안상의 이유로 브라우저는 FTP를 사용하여 하위 자원을로드하는 것에 대한 지원을 제거하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9eea4faa25e4e579cef40974188a8f16f3f6d744" translate="yes" xml:space="preserve">
          <source>When using the &quot;&lt;code&gt;must-revalidate&lt;/code&gt;&quot; directive, the cache must verify the status of the stale resources before using it and expired ones should not be used. For more details, see the &lt;a href=&quot;#Cache_validation&quot;&gt;Validation&lt;/a&gt; section below.</source>
          <target state="translated">&quot; &lt;code&gt;must-revalidate&lt;/code&gt; &quot;지시문을 사용하는 경우 캐시는 사용하기 전에 오래된 자원의 상태를 확인해야하며 만료 된 자원은 사용해서는 안됩니다. 자세한 내용은 아래 의 &lt;a href=&quot;#Cache_validation&quot;&gt;유효성 검사&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ecdb14111320a66294518a2069105521deccaff6" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;Vary: User-Agent&lt;/code&gt; header, caching servers should consider the user agent when deciding whether to serve the page from cache. For example, if you are serving different content to mobile users, it can help you to avoid that a cache may mistakenly serve a desktop version of your site to your mobile users. It can help Google and other search engines to discover the mobile version of a page, and might also tell them that no &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;Cloaking&lt;/a&gt; is intended.</source>
          <target state="translated">사용하는 경우는 &lt;code&gt;Vary: User-Agent&lt;/code&gt; 캐시에서 페이지를 제공할지 여부를 결정할 때 헤더, 캐싱 서버가 사용자 에이전트를 고려해야합니다. 예를 들어 모바일 사용자에게 다른 콘텐츠를 제공하는 경우 캐시가 실수로 사이트의 데스크톱 버전을 모바일 사용자에게 제공하지 않도록 할 수 있습니다. Google 및 기타 검색 엔진이 모바일 버전의 페이지를 발견하는 데 도움을 줄 수 있으며 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;클로킹&lt;/a&gt; 이 의도 되지 않았다고 말할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3026e4bf68b068a4b6ce5495c541e344d3b11c9" translate="yes" xml:space="preserve">
          <source>When you restructure Web sites, URLs change. Even if you update your site's links to match the new URLs, you have no control over the URLs used by external resources.</source>
          <target state="translated">웹 사이트를 재구성하면 URL이 변경됩니다. 새 URL과 일치하도록 사이트의 링크를 업데이트하더라도 외부 리소스에서 사용하는 URL을 제어 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f075b4f1650209d71c1757142531e91ebe323426" translate="yes" xml:space="preserve">
          <source>When you restructure Web sites, URLs of resources change. Even if you can update the internal links of your Web site to match the new naming scheme, you have no control over the URLs used by external resources. You don't want to break these links, as they bring you valuable users (and help your SEO), so you set up redirects from the old URLs to the new ones.</source>
          <target state="translated">웹 사이트를 재구성하면 리소스 URL이 변경됩니다. 새 이름 지정 체계와 일치하도록 웹 사이트의 내부 링크를 업데이트 할 수 있더라도 외부 자원이 사용하는 URL을 제어 할 수 없습니다. 귀중한 사용자를 유도하고 SEO를 돕기 때문에 이러한 링크를 끊지 않으려면 이전 URL에서 새 URL로 리디렉션을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="6070588ec0c2a8c5e6cfc541a62c166faa651c18" translate="yes" xml:space="preserve">
          <source>Whenever a cache returns a response that is neither first-hand nor
   &quot;fresh enough&quot; (in the sense of condition 2 in &lt;a href=&quot;#section-13.1.1&quot;&gt;section 13.1.1&lt;/a&gt;), it
   MUST attach a warning to that effect, using a Warning general-header.
   The Warning header and the currently defined warnings are described
   in &lt;a href=&quot;#section-14.46&quot;&gt;section 14.46&lt;/a&gt;. The warning allows clients to take appropriate
   action.

   Warnings MAY be used for other purposes, both cache-related and
   otherwise. The use of a warning, rather than an error status code,
   distinguish these responses from true failures.

   Warnings are assigned three digit warn-codes. The first digit
   indicates whether the Warning MUST or MUST NOT be deleted from a
   stored cache entry after a successful revalidation: 

   1xx  Warnings that describe the freshness or revalidation status of
     the response, and so MUST be deleted after a successful
     revalidation. 1XX warn-codes MAY be generated by a cache only when
     validating a cached entry. It MUST NOT be generated by clients.

   2xx  Warnings that describe some aspect of the entity body or entity
     headers that is not rectified by a revalidation (for example, a
     lossy compression of the entity bodies) and which MUST NOT be
     deleted after a successful revalidation.

   See &lt;a href=&quot;#section-14.46&quot;&gt;section 14.46&lt;/a&gt; for the definitions of the codes themselves.

   HTTP/1.0 caches will cache all Warnings in responses, without
   deleting the ones in the first category. Warnings in responses that
   are passed to HTTP/1.0 caches carry an extra warning-date field,
   which prevents a future HTTP/1.1 recipient from believing an
   erroneously cached Warning.

   Warnings also carry a warning text. The text MAY be in any
   appropriate natural language (perhaps based on the client's Accept
   headers), and include an OPTIONAL indication of what character set is
   used.

   Multiple warnings MAY be attached to a response (either by the origin
   server or by a cache), including multiple warnings with the same code
   number. For example, a server might provide the same warning with
   texts in both English and Basque.

   When multiple warnings are attached to a response, it might not be
   practical or reasonable to display all of them to the user. This
   version of HTTP does not specify strict priority rules for deciding
   which warnings to display and in what order, but does suggest some
   heuristics.</source>
          <target state="translated">캐시가 직접적이거나 &quot;충분히 신선한&quot;( &lt;a href=&quot;#section-13.1.1&quot;&gt;섹션 13.1.1&lt;/a&gt; 의 조건 2의 의미가 아닌) 응답을 리턴 할 때마다 경고 일반 헤더를 사용하여 해당 효과에 경고를 첨부해야합니다. 경고 헤더와 현재 정의 된 경고는 &lt;a href=&quot;#section-14.46&quot;&gt;14.46 절에&lt;/a&gt; 설명되어 있습니다.. 경고는 클라이언트가 적절한 조치를 취할 수 있도록합니다. 경고는 캐시 관련 및 기타 다른 용도로 사용될 수 있습니다. 오류 상태 코드 대신 경고를 사용하면 이러한 응답을 실제 실패와 구별 할 수 있습니다. 경고에는 세 자리 경고 코드가 할당됩니다. 첫 번째 숫자는 재확인이 성공한 후 저장된 캐시 항목에서 경고를 삭제해야하는지 또는 절대로 삭제하지 않아야하는지 나타냅니다. 1xx 응답의 최신 상태 또는 재확인 상태를 설명하는 경고이므로 재확인이 완료된 후에 삭제해야합니다. 1XX 경고 코드는 캐시 된 항목을 확인할 때만 캐시에 의해 생성 될 수 있습니다. 클라이언트가 생성해서는 안됩니다. 2xx 재확인으로 수정되지 않은 엔터티 본문 또는 엔터티 헤더의 일부 측면을 설명하는 경고 (예 :엔터티 본문의 손실 압축)을 성공적으로 확인한 후에는 삭제해서는 안됩니다. 보다&lt;a href=&quot;#section-14.46&quot;&gt;섹션 14.46&lt;/a&gt;코드 자체의 정의. HTTP / 1.0 캐시는 첫 번째 카테고리의 경고를 삭제하지 않고 모든 경고를 응답으로 캐시합니다. HTTP / 1.0 캐시로 전달되는 응답의 경고에는 추가 경고 날짜 필드가 있으므로 향후 HTTP / 1.1 수신자가 잘못 캐시 된 경고를 믿지 못하게됩니다. 경고에는 경고 텍스트도 있습니다. 텍스트는 적절한 자연 언어 (아마도 클라이언트의 Accept 헤더를 기반으로 함) 일 수 있으며 사용되는 문자 집합에 대한 선택 표시를 포함 할 수 있습니다. 동일한 코드 번호의 여러 경고를 포함하여 여러 경고를 원본 서버 나 캐시에 의해 응답에 첨부 할 수 있습니다. 예를 들어, 서버는 영어와 바스크어로 된 텍스트와 동일한 경고를 제공 할 수 있습니다.여러 경고가 응답에 첨부되면 모든 경고를 사용자에게 표시하는 것이 실용적이지 않거나 합리적이지 않을 수 있습니다. 이 HTTP 버전은 표시 할 경고와 순서를 결정하기위한 엄격한 우선 순위 규칙을 지정하지 않지만 일부 휴리스틱을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="b6e3f26fff7f269af5ed05c0a30457f5f9d7d7e2" translate="yes" xml:space="preserve">
          <source>Whenever the Strict-Transport-Security header is delivered to the browser, it will update the expiration time for that site, so sites can refresh this information and prevent the timeout from expiring. Should it be necessary to disable Strict Transport Security, setting the max-age to 0 (over a https connection) will immediately expire the &lt;code&gt;Strict-Transport-Security&lt;/code&gt; header, allowing access via http.</source>
          <target state="translated">Strict-Transport-Security 헤더가 브라우저에 전달 될 때마다 해당 사이트의 만료 시간이 업데이트되므로 사이트에서이 정보를 새로 고치고 시간 초과가 만료되지 않도록 할 수 있습니다. Strict Transport Security를 ​​비활성화해야하는 경우 https 연결을 통해 max-age를 0으로 설정하면 &lt;code&gt;Strict-Transport-Security&lt;/code&gt; 헤더 가 즉시 만료되어 http를 통한 액세스가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="7f2824d529ed4da83ab98e7c885ddfa6c409076e" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;form-action&lt;/code&gt; should block redirects after a form submission is &lt;a href=&quot;https://github.com/w3c/webappsec-csp/issues/8&quot;&gt;debated&lt;/a&gt; and browser implementations of this aspect are inconsistent (e.g. Firefox 57 doesn't block the redirects whereas Chrome 63 does).</source>
          <target state="translated">양식 제출이 &lt;a href=&quot;https://github.com/w3c/webappsec-csp/issues/8&quot;&gt;토론 된&lt;/a&gt; 후 &lt;code&gt;form-action&lt;/code&gt; 이 리디렉션을 차단해야하는지 여부 와이 측면의 브라우저 구현이 일치하지 않는지 여부 (예 : Firefox 57은 리디렉션을 차단하지 않지만 Chrome 63은 그렇지 않습니다).</target>
        </trans-unit>
        <trans-unit id="fb6399f7fa65b3b2878d7126ab85f658d02766e0" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/character_encodings&quot;&gt;character encodings&lt;/a&gt; the client understands.</source>
          <target state="translated">어떤 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/character_encodings&quot;&gt;문자 인코딩&lt;/a&gt; 클라이언트가 이해를.</target>
        </trans-unit>
        <trans-unit id="2e149cf9cb25225d5524e2c0b27df15969b2bc6b" translate="yes" xml:space="preserve">
          <source>Which part of the user agent contains the information you are looking for</source>
          <target state="translated">찾고자하는 정보를 포함하는 사용자 에이전트의 어느 부분</target>
        </trans-unit>
        <trans-unit id="99fc0a09b56367aa86fac890ff8bff6f93f0262e" translate="yes" xml:space="preserve">
          <source>Which part of the user agent contains the information you are looking for?</source>
          <target state="translated">사용자 에이전트의 어느 부분에 찾고있는 정보가 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="e993bfc672f17c43ec7068a082e6c9f72e4fd853" translate="yes" xml:space="preserve">
          <source>While Firefox 3.5 introduced support for cross-site &lt;code&gt;XMLHttpRequests&lt;/code&gt; and Web Fonts, certain requests were limited until later versions. Specifically, Firefox 7 introduced the ability for cross-site HTTP requests for WebGL Textures, and Firefox 9 added support for Images drawn on a canvas using &lt;code&gt;drawImage()&lt;/code&gt;.</source>
          <target state="translated">Firefox 3.5는 교차 사이트 &lt;code&gt;XMLHttpRequests&lt;/code&gt; 및 웹 글꼴에 대한 지원을 도입했지만 특정 요청은 이후 버전까지 제한되었습니다. 특히 Firefox 7은 WebGL Textures에 대한 사이트 간 HTTP 요청 기능을 도입했으며 Firefox 9는 &lt;code&gt;drawImage()&lt;/code&gt; 사용하여 캔버스에 그려진 이미지 지원을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="20d023c8effc05b035da8186b6438727d9b10e7e" translate="yes" xml:space="preserve">
          <source>While specific HTTP status codes are shown in the interaction
   diagrams below, an AtomPub client should be prepared to handle any
   status code.  For example, a PUT to a Member URI could result in the
   return of a &quot;204 No Content&quot; status code, which still indicates
   success.</source>
          <target state="translated">아래의 상호 작용 다이어그램에 특정 HTTP 상태 코드가 표시되어 있지만 AtomPub 클라이언트는 모든 상태 코드를 처리 할 수 ​​있도록 준비해야합니다. 예를 들어, 멤버 URI에 대한 PUT은 여전히 ​​성공을 나타내는 &quot;204 컨텐츠 없음&quot;상태 코드를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="338f925525fc3393283ece9c49173250a55b4c67" translate="yes" xml:space="preserve">
          <source>While the origin server (and to a lesser extent, intermediate caches,
   by their contribution to the age of a response) are the primary
   source of expiration information, in some cases the client might need
   to control a cache's decision about whether to return a cached
   response without validating it. Clients do this using several
   directives of the Cache-Control header.

   A client's request MAY specify the maximum age it is willing to
   accept of an unvalidated response; specifying a value of zero forces
   the cache(s) to revalidate all responses. A client MAY also specify
   the minimum time remaining before a response expires. Both of these
   options increase constraints on the behavior of caches, and so cannot
   further relax the cache's approximation of semantic transparency.

   A client MAY also specify that it will accept stale responses, up to
   some maximum amount of staleness. This loosens the constraints on the
   caches, and so might violate the origin server's specified
   constraints on semantic transparency, but might be necessary to
   support disconnected operation, or high availability in the face of
   poor connectivity.</source>
          <target state="translated">오리진 서버 (및 응답 기간에 기여한 중간 캐시)가 만기 정보의 주요 소스 인 반면 클라이언트는 캐시 된 리턴 여부에 대한 캐시 결정을 제어해야 할 수도 있습니다. 확인하지 않고 응답하십시오. 클라이언트는 Cache-Control 헤더의 여러 지시문을 사용하여이 작업을 수행합니다. 고객의 요청은 확인되지 않은 응답을 수락 할 최대 연령을 지정할 수 있습니다. 값을 0으로 지정하면 캐시가 모든 응답을 다시 강제합니다. 클라이언트는 응답이 만료되기 전에 남은 최소 시간을 지정할 수도 있습니다. 이 두 옵션 모두 캐시 동작에 대한 제약을 증가 시키므로 캐시의 의미 투명성 근사치를 더 이상 완화 할 수 없습니다.클라이언트는 또한 최대 무효 량까지 오래된 응답을 수락하도록 지정할 수 있습니다. 캐시에 대한 제약이 완화되어 의미 투명성에 대한 원본 서버의 지정된 제약 조건을 위반할 수 있지만 연결이 끊긴 상황에서 연결이 끊긴 작업이나 고 가용성을 지원하는 데 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f8ec3f1f56c6bc412a296279f741f72feec98d6" translate="yes" xml:space="preserve">
          <source>While the version number for Firefox OS is not included in the UA string, it is possible to infer version information from the Gecko version number present in the UA string.</source>
          <target state="translated">Firefox OS의 버전 번호는 UA 문자열에 포함되어 있지 않지만 UA 문자열에있는 Gecko 버전 번호에서 버전 정보를 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97f6d88cfb1e84306b1da3a5b584e510b6a952d4" translate="yes" xml:space="preserve">
          <source>While this directive uses the same arguments as other CSP directives, some of them don&amp;rsquo;t make sense for `&amp;lt;base&amp;gt;`, such as the keywords &lt;code&gt;'unsafe-inline'&lt;/code&gt; and &lt;code&gt;'strict-dynamic'&lt;/code&gt;</source>
          <target state="translated">이 지시어는 다른 CSP 지시어와 같은 인수를 사용하지만 키워드 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 및 &lt;code&gt;'strict-dynamic'&lt;/code&gt; 과 같은`&amp;lt;base&amp;gt;`에는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f537be83534f2bb055e551bb0d596ae0047d77e6" translate="yes" xml:space="preserve">
          <source>While those without a write lock may not alter a property on a
   resource it is still possible for the values of live properties to
   change, even while locked, due to the requirements of their schemas.
   Only dead properties and live properties defined as lockable are
   guaranteed not to change while write locked.</source>
          <target state="translated">쓰기 잠금이없는 리소스는 리소스의 속성을 변경할 수 없지만 스키마 요구 사항으로 인해 잠겨있는 동안에도 라이브 속성의 값이 변경 될 수 있습니다. 잠금 가능으로 정의 된 죽은 속성과 라이브 속성 만 쓰기 잠금 상태에서 변경되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb0451d5b11619c1207cdf6653be0f2c1c7804fc" translate="yes" xml:space="preserve">
          <source>While you can use the protocol upgrade mechanism to upgrade an HTTP/1.1 connection to HTTP/2, you can't go the other way. In fact, the 101 status code is no longer supported at all in HTTP/2, since HTTP/2 doesn't have an upgrade mechanism.</source>
          <target state="translated">프로토콜 업그레이드 메커니즘을 사용하여 HTTP / 1.1 연결을 HTTP / 2로 업그레이드 할 수는 있지만 다른 방법으로는 갈 수 없습니다. 실제로 HTTP / 2에는 업그레이드 메커니즘이 없으므로 101/2 상태 코드는 더 이상 HTTP / 2에서 전혀 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="261605cea16791a4ddb43f7b2749c4b19783648d" translate="yes" xml:space="preserve">
          <source>Who should read this article?</source>
          <target state="translated">이 기사를 누가 읽어야합니까?</target>
        </trans-unit>
        <trans-unit id="665c65a0f74535d4656efd18a227f19541666d9b" translate="yes" xml:space="preserve">
          <source>Wikipedia page on List of HTTP headers</source>
          <target state="translated">HTTP 헤더 목록의 Wikipedia 페이지</target>
        </trans-unit>
        <trans-unit id="cc6b4a8fc4aeba016589b1291deb108288b680c4" translate="yes" xml:space="preserve">
          <source>Wikipedia: &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP%20Strict%20Transport%20Security&quot;&gt;HTTP Strict Transport Security&lt;/a&gt;</source>
          <target state="translated">위키 백과 : &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP%20Strict%20Transport%20Security&quot;&gt;HTTP Strict Transport Security&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed7d5745fff339844aa920c78c4b743eeaaaa20b" translate="yes" xml:space="preserve">
          <source>Wikipedia: HTTP 404</source>
          <target state="translated">위키 백과 : HTTP 404</target>
        </trans-unit>
        <trans-unit id="c3fb892e6bb839e40a5aa40ad6213e107182238b" translate="yes" xml:space="preserve">
          <source>Wikipedia: HTTP 451</source>
          <target state="translated">위키 백과 : HTTP 451</target>
        </trans-unit>
        <trans-unit id="6fd57bc7d46dd1d7c88fd1f38c6b88d2f037bcae" translate="yes" xml:space="preserve">
          <source>Wikipedia: Hyper Text Coffee Pot Control Protocol</source>
          <target state="translated">위키 백과 : 하이퍼 텍스트 커피 포트 제어 프로토콜</target>
        </trans-unit>
        <trans-unit id="d2a3cafe6626783cff3b940b111bae036a628cbe" translate="yes" xml:space="preserve">
          <source>Wildcard (&lt;code&gt;*&lt;/code&gt;)</source>
          <target state="translated">와일드 카드 ( &lt;code&gt;*&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b8899fd2529c1a2011b26126cae3a5c0a4b0a831" translate="yes" xml:space="preserve">
          <source>Will be implemented, see &lt;a href=&quot;https://crbug.com/1007264&quot;&gt;bug 1007264&lt;/a&gt;.</source>
          <target state="translated">구현 될 &lt;a href=&quot;https://crbug.com/1007264&quot;&gt;예정&lt;/a&gt; 입니다. 버그 1007264를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="31c9a3739d5b563171fe69071b7457ba22d94b63" translate="yes" xml:space="preserve">
          <source>Windows NT on x64 CPU</source>
          <target state="translated">x64 CPU의 Windows NT</target>
        </trans-unit>
        <trans-unit id="f5e663f8a9a4dc9bf996e681010668eeffc4658c" translate="yes" xml:space="preserve">
          <source>Windows NT on x86</source>
          <target state="translated">x86의 Windows NT</target>
        </trans-unit>
        <trans-unit id="9d75778731ec194b7c3ce2f2a665761a11719f44" translate="yes" xml:space="preserve">
          <source>Windows NT on x86 CPU</source>
          <target state="translated">x86 CPU의 Windows NT</target>
        </trans-unit>
        <trans-unit id="a91a0206361cb5cdd5d3a572c04ff168eb925f08" translate="yes" xml:space="preserve">
          <source>Windows NT, WOW64</source>
          <target state="translated">윈도우 NT, WOW64</target>
        </trans-unit>
        <trans-unit id="e8e293f9ba55bd519e617bb25740cd26b038610b" translate="yes" xml:space="preserve">
          <source>Windows NT, Win64 on x64</source>
          <target state="translated">Windows NT, x64의 Win64</target>
        </trans-unit>
        <trans-unit id="1f7d7a7d59bb7043e9140971ef9251fab7982c2e" translate="yes" xml:space="preserve">
          <source>Windows OS/2 Bitmap Graphics</source>
          <target state="translated">Windows OS / 2 비트 맵 그래픽</target>
        </trans-unit>
        <trans-unit id="300a9414a515ce56cc07b2655723c865442c3bba" translate="yes" xml:space="preserve">
          <source>Windows icons</source>
          <target state="translated">Windows 아이콘</target>
        </trans-unit>
        <trans-unit id="d49fd423350dcd691fcb99fbae2181da74ce3859" translate="yes" xml:space="preserve">
          <source>Windows user agents have the following variations, where &lt;em&gt;x.y&lt;/em&gt; is the Windows NT version (for instance, Windows NT 6.1).</source>
          <target state="translated">Windows 사용자 에이전트에는 다음과 같은 변형이 있습니다. 여기서 &lt;em&gt;xy&lt;/em&gt; 는 Windows NT 버전입니다 (예 : Windows NT 6.1).</target>
        </trans-unit>
        <trans-unit id="8bd46cc0624bcd0f4f4799ef906d98088943324f" translate="yes" xml:space="preserve">
          <source>Windows version</source>
          <target state="translated">Windows 버전</target>
        </trans-unit>
        <trans-unit id="989504c4d96b544c144c0d90f1bbe95390e8d564" translate="yes" xml:space="preserve">
          <source>With Feature Policy, you opt-in to a set of &quot;policies&quot; for the browser to enforce on specific features used throughout a website. These policies restrict what APIs the site can access or modify the browser's default behavior for certain features.</source>
          <target state="translated">기능 정책을 사용하면 브라우저가 웹 사이트 전체에서 사용되는 특정 기능을 시행하도록 일련의 &quot;정책&quot;을 선택합니다. 이러한 정책은 사이트에서 특정 기능에 대한 브라우저의 기본 동작에 액세스하거나 수정할 수있는 API를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="063d698928c501813d56323f470e5ed6d3986fb1" translate="yes" xml:space="preserve">
          <source>With TCP the default port, for an HTTP server on a computer, is port 80. Other ports can also be used, like 8000 or 8080. The URL of a page to fetch contains both the domain name, and the port number, though the latter can be omitted if it is 80. See &lt;a href=&quot;basics_of_http/identifying_resources_on_the_web&quot;&gt;Identifying resources on the Web&lt;/a&gt; for more details.</source>
          <target state="translated">TCP를 사용하면 컴퓨터의 HTTP 서버에 대한 기본 포트는 포트 80입니다. 8000 또는 8080과 같은 다른 포트도 사용할 수 있습니다. 가져올 페이지의 URL에는 도메인 이름과 포트 번호가 모두 포함됩니다. 80 인 경우 후자를 생략 할 수 있습니다. 자세한 내용 &lt;a href=&quot;basics_of_http/identifying_resources_on_the_web&quot;&gt;은 웹&lt;/a&gt; 에서 자원 식별 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="287bd90b43fa4667e9fa5d74268b62d6241e8c36" translate="yes" xml:space="preserve">
          <source>With UTF-8 now being well-supported, being the preferred way of encoding characters, &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;and to guarantee better privacy through less configuration-based entropy&lt;/a&gt;, browsers omit the &lt;code&gt;Accept-Charset&lt;/code&gt; header: Internet Explorer 8, Safari 5, Opera 11, Firefox 10 and Chrome 27 have abandoned this header.</source>
          <target state="translated">이제 UTF-8이 잘 지원되고, 선호되는 문자 인코딩 방법이며, &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;구성 기반 엔트로피를 줄여 더 나은 개인 정보를 보장하기 위해&lt;/a&gt; 브라우저는 &lt;code&gt;Accept-Charset&lt;/code&gt; 헤더 (Internet Explorer 8, Safari 5, Opera 11, Firefox 10)를 생략합니다 . Chrome 27은이 헤더를 포기했습니다.</target>
        </trans-unit>
        <trans-unit id="a257ad9324f117394e2b9a6293c343f5ba6993ef" translate="yes" xml:space="preserve">
          <source>With UTF-8 now being well-supported, being the preferred way of encoding characters, &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;and to guarantee better privacy through less configuration-based entropy&lt;/a&gt;, most browsers omit the &lt;code&gt;Accept-Charset&lt;/code&gt; header: Internet Explorer 8, Safari 5, Opera 11 and Firefox 10 have abandoned this header.</source>
          <target state="translated">UTF-8은 이제 문자 인코딩 방식이 선호되고 &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;구성 기반 엔트로피를 줄여 더 나은 개인 정보를 보장하기 위해&lt;/a&gt; 대부분의 브라우저에서 &lt;code&gt;Accept-Charset&lt;/code&gt; 헤더 (Internet Explorer 8, Safari 5, Opera 11 및 Firefox)를 생략합니다 . 10이 헤더를 버렸습니다.</target>
        </trans-unit>
        <trans-unit id="c4aa194cdaea498795c2710e4b593bbb786c966e" translate="yes" xml:space="preserve">
          <source>With agent-driven negotiation, selection of the best representation
   for a response is performed by the user agent after receiving an
   initial response from the origin server. Selection is based on a list
   of the available representations of the response included within the
   header fields or entity-body of the initial response, with each
   representation identified by its own URI. Selection from among the
   representations may be performed automatically (if the user agent is
   capable of doing so) or manually by the user selecting from a
   generated (possibly hypertext) menu.

   Agent-driven negotiation is advantageous when the response would vary
   over commonly-used dimensions (such as type, language, or encoding),
   when the origin server is unable to determine a user agent's
   capabilities from examining the request, and generally when public
   caches are used to distribute server load and reduce network usage.

   Agent-driven negotiation suffers from the disadvantage of needing a
   second request to obtain the best alternate representation. This
   second request is only efficient when caching is used. In addition,
   this specification does not define any mechanism for supporting
   automatic selection, though it also does not prevent any such
   mechanism from being developed as an extension and used within
   HTTP/1.1. 

   HTTP/1.1 defines the 300 (Multiple Choices) and 406 (Not Acceptable)
   status codes for enabling agent-driven negotiation when the server is
   unwilling or unable to provide a varying response using server-driven
   negotiation.</source>
          <target state="translated">에이전트 중심 협상에서는 응답에 대한 최상의 표현 선택이 원래 서버로부터 초기 응답을받은 후 사용자 에이전트가 수행합니다. 선택은 헤더 필드 또는 초기 응답의 엔티티 본문에 포함 된 응답의 사용 가능한 표시 목록을 기반으로하며 각 표시는 고유 한 URI로 식별됩니다. 표현들 중에서 선택은 자동으로 (사용자 에이전트가 그렇게 할 수있는 경우), 또는 사용자가 생성 된 (아마 하이퍼 텍스트) 메뉴로부터 선택함으로써 수동으로 수행 될 수있다. 에이전트 중심 협상은 원래 서버가 요청을 검사하여 사용자 에이전트의 기능을 확인할 수없는 경우 일반적으로 사용되는 차원 (예 : 유형, 언어 또는 인코딩)에 따라 응답이 달라질 때 유리합니다.일반적으로 퍼블릭 캐시를 사용하여 서버로드를 분산시키고 네트워크 사용량을 줄일 때. 에이전트 중심 협상은 최상의 대체 표현을 얻기 위해 두 번째 요청이 필요하다는 단점이 있습니다. 이 두 번째 요청은 캐싱이 사용될 때만 효율적입니다. 또한이 사양에서는 자동 선택을 지원하는 메커니즘을 정의하지 않지만 이러한 메커니즘이 확장으로 개발되어 HTTP / 1.1 내에서 사용되는 것을 막지는 않습니다. HTTP / 1.1은 서버가 서버 중심 협상을 사용하여 다양한 응답을 제공 할 수 없거나 서버가 협상 할 수없는 경우 에이전트 중심 협상을 가능하게하는 300 (여러 선택) 및 406 (허용되지 않음) 상태 코드를 정의합니다.에이전트 중심 협상은 최상의 대체 표현을 얻기 위해 두 번째 요청이 필요하다는 단점이 있습니다. 이 두 번째 요청은 캐싱이 사용될 때만 효율적입니다. 또한이 사양에서는 자동 선택을 지원하는 메커니즘을 정의하지 않지만 이러한 메커니즘이 확장으로 개발되어 HTTP / 1.1 내에서 사용되는 것을 막지는 않습니다. HTTP / 1.1은 서버가 서버 중심 협상을 사용하여 다양한 응답을 제공 할 수 없거나 서버가 협상 할 수없는 경우 에이전트 중심 협상을 가능하게하는 300 (여러 선택) 및 406 (허용되지 않음) 상태 코드를 정의합니다.에이전트 중심 협상은 최상의 대체 표현을 얻기 위해 두 번째 요청이 필요하다는 단점이 있습니다. 이 두 번째 요청은 캐싱이 사용될 때만 효율적입니다. 또한이 사양에서는 자동 선택을 지원하는 메커니즘을 정의하지 않지만 이러한 메커니즘이 확장으로 개발되어 HTTP / 1.1 내에서 사용되는 것을 막지는 않습니다. HTTP / 1.1은 서버가 서버 중심 협상을 사용하여 다양한 응답을 제공 할 수 없거나 서버가 협상 할 수없는 경우 에이전트 중심 협상을 가능하게하는 300 (여러 선택) 및 406 (허용되지 않음) 상태 코드를 정의합니다.이 명세는 자동 선택을 지원하는 메커니즘을 정의하지는 않지만 그러한 메커니즘이 확장으로 개발되어 HTTP / 1.1 내에서 사용되는 것을 막지는 않습니다. HTTP / 1.1은 서버가 서버 중심 협상을 사용하여 다양한 응답을 제공 할 수 없거나 서버가 협상 할 수없는 경우 에이전트 중심 협상을 가능하게하는 300 (여러 선택) 및 406 (허용되지 않음) 상태 코드를 정의합니다.이 명세는 자동 선택을 지원하는 메커니즘을 정의하지는 않지만 그러한 메커니즘이 확장으로 개발되어 HTTP / 1.1 내에서 사용되는 것을 막지는 않습니다. HTTP / 1.1은 서버가 서버 중심 협상을 사용하여 다양한 응답을 제공 할 의사가 없거나 불가능한 경우 에이전트 중심 협상을 가능하게하는 300 (여러 선택) 및 406 (허용되지 않음) 상태 코드를 정의합니다.1은 서버가 서버 중심 협상을 사용하여 다양한 응답을 제공 할 의사가없는 경우 에이전트 중심 협상을 가능하게하는 300 (여러 선택) 및 406 (허용 불가) 상태 코드를 정의합니다.1은 서버가 서버 중심 협상을 사용하여 다양한 응답을 제공 할 의사가없는 경우 에이전트 중심 협상을 가능하게하는 300 (여러 선택) 및 406 (허용 안 됨) 상태 코드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7770029630372b0eac11793689759fe0480d9ff8" translate="yes" xml:space="preserve">
          <source>With an &amp;lt;iframe&amp;gt; element</source>
          <target state="translated">&amp;lt;iframe&amp;gt; 요소</target>
        </trans-unit>
        <trans-unit id="73763e7948769a9fcb45adc2ce4867d6d88c43a7" translate="yes" xml:space="preserve">
          <source>With external scripts</source>
          <target state="translated">외부 스크립트</target>
        </trans-unit>
        <trans-unit id="f470ad653a278fddde764ace4f49c6c4d0467b38" translate="yes" xml:space="preserve">
          <source>With reactive negotiation (a.k.a., agent-driven negotiation),
   selection of the best response representation (regardless of the
   status code) is performed by the user agent after receiving an
   initial response from the origin server that contains a list of
   resources for alternative representations.  If the user agent is not
   satisfied by the initial response representation, it can perform a
   GET request on one or more of the alternative resources, selected
   based on metadata included in the list, to obtain a different form of
   representation for that response.  Selection of alternatives might be
   performed automatically by the user agent or manually by the user
   selecting from a generated (possibly hypertext) menu.

   Note that the above refers to representations of the response, in
   general, not representations of the resource.  The alternative
   representations are only considered representations of the target
   resource if the response in which those alternatives are provided has
   the semantics of being a representation of the target resource (e.g.,
   a 200 (OK) response to a GET request) or has the semantics of
   providing links to alternative representations for the target
   resource (e.g., a 300 (Multiple Choices) response to a GET request).

   A server might choose not to send an initial representation, other
   than the list of alternatives, and thereby indicate that reactive
   negotiation by the user agent is preferred.  For example, the
   alternatives listed in responses with the 300 (Multiple Choices) and
   406 (Not Acceptable) status codes include information about the
   available representations so that the user or user agent can react by
   making a selection.

   Reactive negotiation is advantageous when the response would vary
   over commonly used dimensions (such as type, language, or encoding),
   when the origin server is unable to determine a user agent's
   capabilities from examining the request, and generally when public
   caches are used to distribute server load and reduce network usage. 

   Reactive negotiation suffers from the disadvantages of transmitting a
   list of alternatives to the user agent, which degrades user-perceived
   latency if transmitted in the header section, and needing a second
   request to obtain an alternate representation.  Furthermore, this
   specification does not define a mechanism for supporting automatic
   selection, though it does not prevent such a mechanism from being
   developed as an extension.</source>
          <target state="translated">사후 협상 (일명 에이전트 중심 협상)을 사용하면 상태 코드에 관계없이 최상의 응답 표현을 선택하여 대체 표현을위한 리소스 목록이 포함 된 원본 서버로부터 초기 응답을받은 후 사용자 에이전트가 수행합니다. 사용자 에이전트가 초기 응답 표현에 만족하지 않으면, 목록에 포함 된 메타 데이터에 기초하여 선택된 하나 이상의 대체 자원에 대해 GET 요청을 수행하여 해당 응답에 대한 다른 표현 형식을 얻을 수 있습니다. 대안의 선택은 사용자 에이전트에 의해 자동으로 수행되거나 사용자가 생성 된 (아마 하이퍼 텍스트) 메뉴에서 선택하여 수동으로 수행 될 수 있습니다. 위의 답변은 일반적으로 답변의 표현을 나타냅니다.자원의 표현이 아닙니다. 대안의 표현은 대안이 제공되는 응답이 목표 자원의 표현이라는 의미를 가지거나 (예를 들어, GET 요청에 대한 200 (OK) 응답) 의미를 갖는 경우에만 목표 자원의 표현으로 간주된다. 타겟 리소스에 대한 대안적인 표현들에 대한 링크를 제공하는 것 (예를 들어, GET 요청에 대한 300 (Multiple Choices) 응답). 서버는 대안 목록 이외의 초기 표현을 보내지 않기로 선택할 수 있으므로 사용자 에이전트의 반응 협상이 선호됨을 나타냅니다. 예를 들어300 (Multiple Choices) 및 406 (Not Acceptable) 상태 코드에 대한 응답으로 나열된 대안에는 사용 가능한 표현에 대한 정보가 포함되므로 사용자 또는 사용자 에이전트가 선택하여 반응 할 수 있습니다. 응답이 일반적으로 사용되는 차원 (예 : 유형, 언어 또는 인코딩)에 따라 다를 경우, 오리진 서버가 요청을 검사하여 사용자 에이전트의 기능을 판별 할 수없는 경우 및 일반적으로 공개 캐시를 사용하여 분배하는 경우 반응성 협상이 유리합니다. 서버로드 및 네트워크 사용량 감소 반응성 협상은 대안의 목록을 사용자 에이전트에 전송하는 단점이 있으며, 이는 헤더 섹션에서 전송되는 경우 사용자-지각 대기 시간을 저하 시키며, 다른 표현을 얻기 위해 제 2 요청을 필요로한다.또한, 본 명세서는 자동 선택을 지원하기위한 메커니즘을 정의하지 않지만, 그러한 메커니즘이 확장으로서 개발되는 것을 막지는 않는다.</target>
        </trans-unit>
        <trans-unit id="f8cb0ac82812058c0694f7c5a07bb9f285a50bcb" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method you are able to implement this. The client first reads the original files, modifies them, and finally pushes them to the server:</source>
          <target state="translated">으로 &lt;a href=&quot;methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; 의&lt;/a&gt; 방법이 구현 할 수 있습니다. 클라이언트는 먼저 원본 파일을 읽고 수정 한 다음 서버로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="5a4f6110e1e61b04fbe62fb541b4c16a90b6d7dd" translate="yes" xml:space="preserve">
          <source>With the above header set on a domain example.com that wants to migrate from HTTP to HTTPS, non-navigational insecure resource requests are automatically upgraded (first-party as well as third-party requests).</source>
          <target state="translated">HTTP에서 HTTPS로 마이그레이션하려는 도메인 example.com에 위의 헤더가 설정되어 있으면 비 탐색적인 안전하지 않은 리소스 요청이 자동으로 업그레이드됩니다 (타사 및 타사 요청).</target>
        </trans-unit>
        <trans-unit id="538d5b744abf2a80cab094727a14a51501db7d8c" translate="yes" xml:space="preserve">
          <source>With the exception of &lt;code&gt;multipart/form-data&lt;/code&gt;, used in the &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Forms&lt;/a&gt;, and &lt;code&gt;multipart/byteranges&lt;/code&gt;, used with &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; to send part of a document, HTTP doesn't handle multipart documents in a special way: the message is transmitted to the browser (which will likely show a &quot;Save As&quot; window if it doesn't know how to display the document).</source>
          <target state="translated">를 제외하고 &lt;code&gt;multipart/form-data&lt;/code&gt; 에 사용, &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; 의&lt;/a&gt; 방법 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML 양식&lt;/a&gt; 및 &lt;code&gt;multipart/byteranges&lt;/code&gt; 사용, &lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 문서의 일부를 보내, HTTP는 특별한 방법으로 다중 문서를 처리하지 않습니다 : 메시지를 브라우저로 전송됩니다 (문서를 표시하는 방법을 모르는 경우 &quot;다른 이름으로 저장&quot;창이 표시 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="708d2e1600bcd9604e2edeccc4c3fd62c52a3c1a" translate="yes" xml:space="preserve">
          <source>With the help of the &lt;a href=&quot;../content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header and the &lt;a href=&quot;report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive, you can set-up an enforced policy and a reported policy like this:</source>
          <target state="translated">의 도움으로 &lt;a href=&quot;../content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt; 헤더와 &lt;a href=&quot;report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt; 지시, 당신은 설정 할 수있는 강화 정책이 같은보고 정책을 :</target>
        </trans-unit>
        <trans-unit id="044b9dbdfbd69bd21aa2b1d882b33557eda54a7b" translate="yes" xml:space="preserve">
          <source>With the help of the &lt;code&gt;ETag&lt;/code&gt; and the &lt;a href=&quot;../headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; headers, you can detect mid-air edit collisions.</source>
          <target state="translated">&lt;code&gt;ETag&lt;/code&gt; 및 &lt;a href=&quot;../headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; 헤더 의 도움으로 공중 편집 충돌을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="105d80b763f419ce22176e98ecfdc97c5f8387a4" translate="yes" xml:space="preserve">
          <source>With the help of the &lt;code&gt;ETag&lt;/code&gt; and the &lt;a href=&quot;if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; headers, you are able to detect mid-air edit collisions.</source>
          <target state="translated">의 도움으로 &lt;code&gt;ETag&lt;/code&gt; 및 &lt;a href=&quot;if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; 헤더, 당신은 공중 편집 충돌을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ddd17a77e3eb820e93844f51c9bd5df55066992" translate="yes" xml:space="preserve">
          <source>With the help of the &lt;code&gt;ETag&lt;/code&gt; and the &lt;a href=&quot;if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; headers, you can detect mid-air edit collisions.</source>
          <target state="translated">&lt;code&gt;ETag&lt;/code&gt; 및 &lt;a href=&quot;if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; 헤더 의 도움으로 공중 편집 충돌을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="512239b40fd41d01554678757db96317e6284079" translate="yes" xml:space="preserve">
          <source>With the help of the new HTTP headers, the ability to transmit other documents than plain HTML files has been added (thanks to the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header).</source>
          <target state="translated">새로운 HTTP 헤더 덕분에 일반 HTML 파일 이외의 다른 문서를 전송하는 기능이 추가되었습니다 ( &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 헤더 덕분에 ).</target>
        </trans-unit>
        <trans-unit id="1a7203df4fb0cc96a3946c892f2dac6dbefbb1dc" translate="yes" xml:space="preserve">
          <source>With these techniques, you can configure your server to respond correctly for both, the www-prefixed and the non-www-prefixed domains. It is good advice to do this since you can't predict which URL users will type in their browser's URL bar. It is a matter of choosing which type you want to use as your canonical location, then redirecting the other type to it.</source>
          <target state="translated">이러한 기술을 사용하면 www-prefixed 도메인과 www-prefixed 도메인이 아닌 도메인 모두에 대해 올바르게 응답하도록 서버를 구성 할 수 있습니다. 브라우저의 URL 표시 줄에 입력 할 URL 사용자를 예측할 수 없으므로이 작업을 수행하는 것이 좋습니다. 정식 위치로 사용할 유형을 선택한 다음 다른 유형을 해당 유형으로 리디렉션해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d1c75c7baf134aba78012137949996ebe9070b0" translate="yes" xml:space="preserve">
          <source>With three possibilities for URL redirections, several methods can be specified at the same time, but which one is applied first? The order of precedence is the following:</source>
          <target state="translated">URL 리디렉션에 대한 세 가지 가능성을 통해 여러 방법을 동시에 지정할 수 있지만 어떤 방법이 먼저 적용됩니까? 우선 순위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a418f3a1c01fcbf5c90b703d052201992e5fb874" translate="yes" xml:space="preserve">
          <source>With three ways to trigger redirections, several ways can be used at the same time. But which is applied first?</source>
          <target state="translated">리디렉션을 트리거하는 세 가지 방법을 통해 여러 가지 방법을 동시에 사용할 수 있습니다. 그러나 어느 것이 먼저 적용됩니까?</target>
        </trans-unit>
        <trans-unit id="a8be0bede91ceb6ad718250a6be05f374208c9a0" translate="yes" xml:space="preserve">
          <source>Worker support</source>
          <target state="translated">근로자 지원</target>
        </trans-unit>
        <trans-unit id="dd81953275e4c603fc6e296163f16395c6ee5da7" translate="yes" xml:space="preserve">
          <source>Working Draft</source>
          <target state="translated">작업 초안</target>
        </trans-unit>
        <trans-unit id="37c6e1e814485ae2acb0d7377a8e62b4414e27eb" translate="yes" xml:space="preserve">
          <source>Working code samples</source>
          <target state="translated">작업 코드 샘플</target>
        </trans-unit>
        <trans-unit id="eacebc1ffedb674ae5bd64f058688530e875da85" translate="yes" xml:space="preserve">
          <source>Workspaces are server-defined groups of Collections.  The &quot;app:
   workspace&quot; element contains zero or more app:collection elements
   describing the Collections of Resources available for editing.

   appWorkspace =
      element app:workspace {
         appCommonAttributes,
         ( atomTitle
           &amp;amp; appCollection*
           &amp;amp; extensionSansTitleElement* )
      }

   atomTitle = element atom:title { atomTextConstruct }</source>
          <target state="translated">작업 공간은 서버 정의 모음 모음입니다. &quot;app : workspace&quot;요소에는 편집 가능한 자원 콜렉션을 설명하는 app : collection 요소가 0 개 이상 있습니다. appWorkspace = 요소 app : workspace {appCommonAttributes, (atomTitle &amp;amp; appCollection * &amp;amp; extensionSansTitleElement *)} atomTitle = 요소 atom : title {atomTextConstruct}</target>
        </trans-unit>
        <trans-unit id="79a153310ffa336984498274d184537ce99e3457" translate="yes" xml:space="preserve">
          <source>Writing a policy</source>
          <target state="translated">정책 작성</target>
        </trans-unit>
        <trans-unit id="b1d3f473c48021046e7ba3468f5cf21e1b0e7ddd" translate="yes" xml:space="preserve">
          <source>X-Content-Type-Options</source>
          <target state="translated">X-Content-Type-Options</target>
        </trans-unit>
        <trans-unit id="25731e7aec64e37cf5913bb14adeca448b936ee9" translate="yes" xml:space="preserve">
          <source>X-DNS-Prefetch-Control</source>
          <target state="translated">X-DNS-Prefetch-Control</target>
        </trans-unit>
        <trans-unit id="08a62266c2fee44d28f2a09bdc63f0cb3203d151" translate="yes" xml:space="preserve">
          <source>X-Forwarded-For</source>
          <target state="translated">X-Forwarded-For</target>
        </trans-unit>
        <trans-unit id="3dfd27b5c348953dd22222a659a5031713ce4ff1" translate="yes" xml:space="preserve">
          <source>X-Forwarded-Host</source>
          <target state="translated">X-Forwarded-Host</target>
        </trans-unit>
        <trans-unit id="5f77b69d4a9a12e6be323362589ebb4520c18095" translate="yes" xml:space="preserve">
          <source>X-Forwarded-Proto</source>
          <target state="translated">X-Forwarded-Proto</target>
        </trans-unit>
        <trans-unit id="06d18ff7a6daa0422e0cad3f72e863617cee9d06" translate="yes" xml:space="preserve">
          <source>X-Frame-Options</source>
          <target state="translated">X-Frame-Options</target>
        </trans-unit>
        <trans-unit id="8c52affc192efbc43d6163a7df7a9d01beb38c0f" translate="yes" xml:space="preserve">
          <source>X-Webkit-CSP</source>
          <target state="translated">X-Webkit-CSP</target>
        </trans-unit>
        <trans-unit id="c7215a317b6dd9b4629392c1b06074727d0d0713" translate="yes" xml:space="preserve">
          <source>X-XSS-Protection</source>
          <target state="translated">X-XSS-Protection</target>
        </trans-unit>
        <trans-unit id="4e111db7771a9e3cb485a634fdca19d4a087bf84" translate="yes" xml:space="preserve">
          <source>X.509v3 certificate extension to allow embedding of signed certificate timestamps issued by individual logs</source>
          <target state="translated">개별 로그에서 발행 한 서명 된 인증서 타임 스탬프를 포함 할 수있는 X.509v3 인증서 확장</target>
        </trans-unit>
        <trans-unit id="fcf9ac265948c22972f4a00525a49dcdca8ded84" translate="yes" xml:space="preserve">
          <source>X.X.X.Y</source>
          <target state="translated">X.X.X.Y</target>
        </trans-unit>
        <trans-unit id="ffa12f27ac48a1ab5dd93d501704d6f43ec578fa" translate="yes" xml:space="preserve">
          <source>XHTML</source>
          <target state="translated">XHTML</target>
        </trans-unit>
        <trans-unit id="02faa7587ad581423c40a3b14ac82860aadd96d3" translate="yes" xml:space="preserve">
          <source>XML elements defined by this specification MAY have an &quot;xml:base&quot;
   attribute [&lt;a href=&quot;#ref-REC-xmlbase&quot;&gt;REC-xmlbase&lt;/a&gt;].  When xml:base is used, it serves the
   function described in &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt; of URI Generic Syntax [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;],
   by establishing the base URI (or IRI, Internationalized Resource
   Identifier [&lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt;]) for resolving relative references found within
   the scope of the &quot;xml:base&quot; attribute.

   Any element defined by this specification MAY have an &quot;xml:lang&quot;
   attribute, whose content indicates the natural language for the
   element and its descendants.  Requirements regarding the content and
   interpretation of &quot;xml:lang&quot; are specified in &lt;a href=&quot;#section-2.12&quot;&gt;Section 2.12&lt;/a&gt; of XML 1.0
   [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].</source>
          <target state="translated">이 규격에 의해 정의 된 XML 요소는 &quot;xml : base&quot;속성 [ &lt;a href=&quot;#ref-REC-xmlbase&quot;&gt;REC-xmlbase&lt;/a&gt; ]을 가질 수 있다. xml : base를 사용하는 경우 xml : base는 범위 내에서 발견 된 상대 참조를 해결하기위한 기본 URI (또는 IRI, 국제화 된 자원 식별자 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt; ])를 설정하여 URI 일반 구문 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]의 &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1 절에&lt;/a&gt; 설명 된 기능을 수행합니다. &quot;xml : base&quot;속성 이 규격에 의해 정의 된 모든 요소는 &quot;xml : lang&quot;속성을 가질 수 있으며, 그 내용은 그 요소와 그 자손의 자연어를 나타낸다. &quot;xml : lang&quot;의 내용과 해석에 관한 요구 사항 은 XML 1의 &lt;a href=&quot;#section-2.12&quot;&gt;2.12 절에&lt;/a&gt; 명시되어있다 .0 [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="118d184a6966521bcc7ff20a77721ff4e779ff1c" translate="yes" xml:space="preserve">
          <source>XML is a flexible data format that makes it easy to submit data that
   appears legal but in fact is not.  The philosophy of &quot;Be flexible in
   what you accept and strict in what you send&quot; still applies, but it
   must not be applied inappropriately.  XML is extremely flexible in
   dealing with issues of whitespace, element ordering, inserting new
   elements, etc.  This flexibility does not require extension,
   especially not in the area of the meaning of elements.

   There is no kindness in accepting illegal combinations of XML
   elements.  At best, it will cause an unwanted result and at worst it
   can cause real damage.</source>
          <target state="translated">XML은 유연한 것처럼 보이지만 실제로는 적합하지 않은 데이터를 쉽게 제출할 수있는 유연한 데이터 형식입니다. &quot;수락하는 것에 융통성 있고 발송하는 것에 엄격하게&quot;라는 철학이 여전히 적용되지만, 부적절하게 적용되어서는 안됩니다. XML은 공백, 요소 순서, 새로운 요소 삽입 등의 문제를 처리 할 때 매우 유연합니다. 이러한 유연성은 특히 요소의 의미 영역이 아닌 확장을 필요로하지 않습니다. XML 요소의 잘못된 조합을 받아들이는 것은 친절하지 않습니다. 기껏해야 원치 않는 결과를 초래하고 최악의 경우 실제 피해를 입을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ac1e607d8b04259c13b0dc929c5a55b74dd33cb" translate="yes" xml:space="preserve">
          <source>XML namespaces disambiguate WebDAV property names and XML elements.
   Any WebDAV user or application can define a new namespace in order to
   create custom properties or extend WebDAV XML syntax.  IANA does not
   need to manage such namespaces, property names, or element names.</source>
          <target state="translated">XML 네임 스페이스는 WebDAV 속성 이름과 XML 요소를 명확하게합니다. 모든 WebDAV 사용자 또는 애플리케이션은 사용자 정의 특성을 작성하거나 WebDAV XML 구문을 확장하기 위해 새 네임 스페이스를 정의 할 수 있습니다. IANA는 이러한 네임 스페이스, 속성 이름 또는 요소 이름을 관리 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec22a72705e20935a57158e733e78bdae4f2f2cd" translate="yes" xml:space="preserve">
          <source>XML supports a facility known as &quot;external entities&quot;, defined in
   Section 4.2.2 of [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;], which instructs an XML processor to
   retrieve and include additional XML.  An external XML entity can be
   used to append or modify the document type declaration (DTD)
   associated with an XML document.  An external XML entity can also be
   used to include XML within the content of an XML document.  For non-
   validating XML, such as the XML used in this specification, including
   an external XML entity is not required by XML.  However, XML does
   state that an XML processor may, at its discretion, include the
   external XML entity.

   External XML entities have no inherent trustworthiness and are
   subject to all the attacks that are endemic to any HTTP GET request.
   Furthermore, it is possible for an external XML entity to modify the
   DTD, and hence affect the final form of an XML document, in the worst
   case, significantly modifying its semantics or exposing the XML
   processor to the security risks discussed in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;].  Therefore,
   implementers must be aware that external XML entities should be
   treated as untrustworthy.  If a server chooses not to handle external
   XML entities, it SHOULD respond to requests containing external
   entities with the 'no-external-entities' condition code.

   There is also the scalability risk that would accompany a widely
   deployed application that made use of external XML entities.  In this
   situation, it is possible that there would be significant numbers of
   requests for one external XML entity, potentially overloading any 

   server that fields requests for the resource containing the external
   XML entity.

   Furthermore, there's also a risk based on the evaluation of &quot;internal
   entities&quot; as defined in Section 4.2.2 of [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;].  A small,
   carefully crafted request using nested internal entities may require
   enormous amounts of memory and/or processing time to process.  Server
   implementers should be aware of this risk and configure their XML
   parsers so that requests like these can be detected and rejected as
   early as possible.</source>
          <target state="translated">XML은 [ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML의&lt;/a&gt; 4.2.2 절에 정의 된 &quot;외부 엔티티&quot;라는 기능을 지원합니다.]는 XML 프로세서가 추가 XML을 검색하고 포함하도록 지시합니다. 외부 XML 엔터티를 사용하여 XML 문서와 관련된 DTD (Document Type Declaration)를 추가하거나 수정할 수 있습니다. 외부 XML 엔터티를 사용하여 XML 문서의 내용에 XML을 포함시킬 수도 있습니다. 외부 XML 엔터티를 포함하여이 사양에 사용 된 XML과 같은 비 유효 XML의 경우 XML에 필요하지 않습니다. 그러나 XML은 XML 프로세서가 재량에 따라 외부 XML 엔터티를 포함 할 수 있다고 명시합니다. 외부 XML 엔터티에는 고유 한 신뢰성이 없으며 모든 HTTP GET 요청에 고유 한 모든 공격이 적용됩니다. 또한 외부 XML 엔터티가 DTD를 수정할 수 있으므로 최악의 경우 XML 문서의 최종 양식에 영향을 미칩니다.시맨틱 스를 대폭 수정하거나 XML 프로세서를 [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt; ]. 따라서 구현자는 외부 XML 엔터티를 신뢰할 수없는 것으로 취급해야한다는 것을 알고 있어야합니다. 서버가 외부 XML 엔터티를 처리하지 않기로 선택한 경우 '외부 엔터티 없음'조건 코드로 외부 엔터티를 포함하는 요청에 응답해야합니다. 외부 XML 엔터티를 사용하는 광범위하게 배포 된 응용 프로그램과 함께 발생할 수있는 확장 성 위험도 있습니다. 이 상황에서 하나의 외부 XML 엔티티에 대한 요청이 상당히 많아 외부 XML 엔티티를 포함하는 자원에 대한 요청을 처리하는 서버를 오버로드 할 수 있습니다. 또한 [ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML의&lt;/a&gt; 4.2.2 절에 정의 된 &quot;내부 엔티티&quot;의 평가에 따른 위험도 있습니다]. 중첩 된 내부 엔터티를 사용하여 작고 정교하게 제작 된 요청에는 처리하는 데 엄청난 양의 메모리 및 / 또는 처리 시간이 필요할 수 있습니다. 서버 구현자는 이러한 위험을 알고 XML 구문 분석기를 구성하여 이와 같은 요청을 가능한 빨리 발견하고 거부 할 수 있도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="b52535bbad4c67580746ea1c2e2d0547fde6a67a" translate="yes" xml:space="preserve">
          <source>XML supports two mechanisms for indicating that an XML element does
   not have any content.  The first is to declare an XML element of the
   form &amp;lt;A&amp;gt;&amp;lt;/A&amp;gt;.  The second is to declare an XML element of the form
   &amp;lt;A/&amp;gt;.  The two XML elements are semantically identical.</source>
          <target state="translated">XML은 XML 요소에 내용이 없음을 나타내는 두 가지 메커니즘을 지원합니다. 첫 번째는 &amp;lt;A&amp;gt; &amp;lt;/A&amp;gt; 형식의 XML 요소를 선언하는 것입니다. 두 번째는 &amp;lt;A/&amp;gt; 형식의 XML 요소를 선언하는 것입니다. 두 XML 요소는 의미 상 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b1a146ce24fcf201b49e752836700a2313cfce76" translate="yes" xml:space="preserve">
          <source>XUL</source>
          <target state="translated">XUL</target>
        </trans-unit>
        <trans-unit id="db9a9676b638863e69493a0d059f3d23b2a78eff" translate="yes" xml:space="preserve">
          <source>Y. Y. Goland
   Microsoft Corporation
   One Microsoft Way
   Redmond, WA 98052-6399
   EMail: yarong@microsoft.com


   E. J. Whitehead, Jr.
   Dept. Of Information and Computer Science
   University of California, Irvine
   Irvine, CA 92697-3425
   EMail: ejw@ics.uci.edu


   A. Faizi
   Netscape
   685 East Middlefield Road
   Mountain View, CA 94043
   EMail: asad@netscape.com 

   S. R. Carter
   Novell
   1555 N. Technology Way
   M/S ORM F111
   Orem, UT 84097-2399
   EMail: srcarter@novell.com


   D. Jensen
   Novell
   1555 N. Technology Way
   M/S ORM F111
   Orem, UT 84097-2399
   EMail: dcjensen@novell.com</source>
          <target state="translated">YY Goland Microsoft Corporation One Microsoft Way Redmond, WA 98052-6399 전자 메일 : yarong@microsoft.com EJ Whitehead, Jr. 캘리포니아 얼바인 어바인 정보 및 컴퓨터 과학 대학교 캘리포니아 92697-3425 전자 메일 : ejw@ics.uci .edu A. Faizi Netscape 685 East Middlefield Road Mountain View, CA 94043 이메일 : asad@netscape.com SR Carter Novell 1555 N. 기술 방식 M / S ORM F111 Orem, UT 84097-2399 이메일 : srcarter@novell.com D. Jensen Novell 1555 N. Technology Way M / S ORM F111 Orem, UT 84097-2399 이메일 : dcjensen@novell.com</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="1a82ce976af425a56eaeeaa127b4f030cbb2bf55" translate="yes" xml:space="preserve">
          <source>Yes. If this directive is absent, the user agent will look for the &lt;code&gt;default-src&lt;/code&gt; directive.</source>
          <target state="translated">예. 이 지시문이 없으면 사용자 에이전트는 &lt;code&gt;default-src&lt;/code&gt; 지시문을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="a03d0938eab0d6ee22b27cb1b4a301b73e8ef58d" translate="yes" xml:space="preserve">
          <source>You can also configure a site to allow any site to access it by using the &lt;code&gt;&quot;*&quot;&lt;/code&gt; wildcard. You should only use this for public APIs. Private APIs should never use &lt;code&gt;&quot;*&quot;&lt;/code&gt;, and should instead have a specific domain or domains set. In addition, the wildcard only works for requests made with the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-crossorigin&quot;&gt;crossorigin&lt;/a&gt;&lt;/code&gt; attribute set to &lt;code&gt;&quot;anonymous&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;*&quot;&lt;/code&gt; 와일드 카드를 사용하여 사이트에서 액세스 할 수 있도록 사이트를 구성 할 수도 있습니다 . 공개 API에만 사용해야합니다. 개인 API는 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 를 사용 해서는 안되며 대신 특정 도메인을 설정해야합니다. 또한 와일드 카드는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-crossorigin&quot;&gt;crossorigin&lt;/a&gt;&lt;/code&gt; 속성이 &lt;code&gt;&quot;anonymous&quot;&lt;/code&gt; 로 설정된 요청에 대해서만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="75af7d57fd721f02bd6ba3587fe6812772fb7fcf" translate="yes" xml:space="preserve">
          <source>You can also configure a site to allow any site to access it by using the &lt;code&gt;*&lt;/code&gt; wildcard. You should only use this for public APIs. Private APIs should never use &lt;code&gt;*&lt;/code&gt;, and should instead have a specific domain or domains set. In addition, the wildcard only works for requests made with the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-crossorigin&quot;&gt;crossorigin&lt;/a&gt;&lt;/code&gt; attribute set to &lt;code&gt;anonymous&lt;/code&gt;, and it prevents sending credentials like cookies in requests.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 와일드 카드 를 사용하여 모든 사이트가 액세스 할 수 있도록 사이트를 구성 할 수도 있습니다 . 공용 API에만 사용해야합니다. 비공개 API는 &lt;code&gt;*&lt;/code&gt; 를 사용해서는 안되며 , 대신 특정 도메인을 설정해야합니다. 또한 와일드 카드는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-crossorigin&quot;&gt;crossorigin&lt;/a&gt;&lt;/code&gt; 속성이 &lt;code&gt;anonymous&lt;/code&gt; 로 설정된 요청에 대해서만 작동하며 요청 에서 쿠키와 같은 자격 증명을 보내는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="e8c5b12eb050dfd4399098b193f351f4fbac43c5" translate="yes" xml:space="preserve">
          <source>You can also set referrer policies in HTML documents. For example, by using a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-name&quot;&gt;name of &lt;code&gt;referrer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">HTML 문서에서 리퍼러 정책을 설정할 수도 있습니다. 예를 들어, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-name&quot;&gt;이름이 &lt;/a&gt; &lt;code&gt;referrer&lt;/code&gt; 인&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 사용하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="195c470c8c8c727452226fead2121e4e2e15995a" translate="yes" xml:space="preserve">
          <source>You can also set referrer policies inside HTML. For example, you can set the referrer policy for the entire document with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-name&quot;&gt;name&lt;/a&gt; of &lt;code&gt;referrer&lt;/code&gt;:</source>
          <target state="translated">HTML 내에서 리퍼러 정책을 설정할 수도 있습니다. 예를 들어,와 전체 문서의 참조 자 정책을 설정할 수 있습니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; A의 요소 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-name&quot;&gt;이름&lt;/a&gt; 의 &lt;code&gt;referrer&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="306b4bc212db26d3f47d487dfdbe512922fd95bc" translate="yes" xml:space="preserve">
          <source>You can also upgrade an HTTP/1.1 connection to TLS/1.0. The main advantages to this are that you can avoid using URL redirection from &quot;http://&quot; to &quot;https://&quot; on the server and you can easily use TLS on virtual hosts. This may, however, introduce problems with proxy servers.</source>
          <target state="translated">HTTP / 1.1 연결을 TLS / 1.0으로 업그레이드 할 수도 있습니다. 이것의 주요 장점은 서버에서 &quot;http : //&quot;에서 &quot;https : //&quot;로 URL 리디렉션을 사용하지 않고 가상 호스트에서 TLS를 쉽게 사용할 수 있다는 것입니다. 그러나 프록시 서버에 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8f33154995cf629f0c4dcbdc756b5ef348aae13" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;&quot;wss://&quot;&lt;/code&gt; URL scheme to open a secure WebSocket connection.</source>
          <target state="translated">당신은 또한 사용할 수있는 &lt;code&gt;&quot;wss://&quot;&lt;/code&gt; URL 방식을 안전한 웹 소켓 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="bb8c719f47766046067ab4ba3d9d63932f7735fd" translate="yes" xml:space="preserve">
          <source>You can either send the &lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; header server-side, or from individual documents, using the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; attribute on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element, like this:</source>
          <target state="translated">&lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; 과 같이 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; 속성을 사용하여 X-DNS-Prefetch-Control 헤더를 서버 측으로 보내 거나 개별 문서에서 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9b490f6db58176d0a61ab78a69dbead300c1e16" translate="yes" xml:space="preserve">
          <source>You can force the lookup of specific hostnames without providing specific anchors using that hostname by using the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#attr-rel&quot;&gt;rel&lt;/a&gt;&lt;/code&gt; attribute on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types&quot;&gt;link type&lt;/a&gt; of &lt;code&gt;dns-prefetch&lt;/code&gt;:</source>
          <target state="translated">사용자는 사용하는 특정 호스트를 사용하여 앵커를 설치하지 않고, 특정의 호스트 이름 조회를 강제 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#attr-rel&quot;&gt;rel&lt;/a&gt;&lt;/code&gt; 온 특성 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; A의 요소 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types&quot;&gt;링크 타입&lt;/a&gt; 의 &lt;code&gt;dns-prefetch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="890b436866aa7fec0eb591186b42b85551101fe8" translate="yes" xml:space="preserve">
          <source>You can help by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/MDN/Contribute/Howto/Document_an_HTTP_header&quot;&gt;writing new entries&lt;/a&gt; or improving the existing ones.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/MDN/Contribute/Howto/Document_an_HTTP_header&quot;&gt;새 항목&lt;/a&gt; 을 쓰거나 기존 항목을 개선하여 도움을 줄 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b351d15f45462c98aeea68c3d35a05714734814" translate="yes" xml:space="preserve">
          <source>You can reverse this setting by setting &lt;code&gt;content&lt;/code&gt; to &quot;&lt;code&gt;on&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;content&lt;/code&gt; 를 &quot; &lt;code&gt;on&lt;/code&gt; &quot; 으로 설정하여이 설정을 되돌릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48019a7a0d5588a4850584f68a3a5d5553f14588" translate="yes" xml:space="preserve">
          <source>You can send the &lt;code&gt;Feature-Policy&lt;/code&gt; HTTP header with the response of a page. The value of this header is a policy to be enforced by the browser for the given page. It has the following structure.</source>
          <target state="translated">페이지의 응답으로 &lt;code&gt;Feature-Policy&lt;/code&gt; HTTP 헤더를 보낼 수 있습니다 . 이 헤더의 값은 주어진 페이지에 대해 브라우저에 의해 시행되는 정책입니다. 다음과 같은 구조로되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bfa7d772cf31ca26fbcc1e9d0f1daf1147032db" translate="yes" xml:space="preserve">
          <source>You can use a hash-source to only allow specific inline style blocks:</source>
          <target state="translated">해시 소스를 사용하여 특정 인라인 스타일 블록 만 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="544765b693d9f6cf73fb8f6dc3d703f7a471c0a9" translate="yes" xml:space="preserve">
          <source>You can use a nonce-source to only allow specific inline script blocks:</source>
          <target state="translated">nonce-source를 사용하여 특정 인라인 스크립트 블록 만 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e8d2670c21852aa6796fac3bb46c156114c42df" translate="yes" xml:space="preserve">
          <source>You can use a nonce-source to only allow specific inline style blocks:</source>
          <target state="translated">nonce-source를 사용하여 특정 인라인 스타일 블록 만 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a65bfc91cd3f3591eaf8300d226b1df9b91b92b3" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header to specify your policy, like this:</source>
          <target state="translated">당신이 사용할 수있는 &lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; 과 같이 정책을 지정 HTTP 헤더를 :</target>
        </trans-unit>
        <trans-unit id="d6b308802143863f61fdfd923956be0f5c92e18a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; HTTP header to specify your policy, like this:</source>
          <target state="translated">당신이 사용할 수있는 &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt; HTTP 헤더이 같은 정책을 지정하려면 :</target>
        </trans-unit>
        <trans-unit id="eb5f5c27a50e86c2cf442e41b9e616e143082854" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header more than once like in the example below. Pay special attention to the &lt;a href=&quot;content-security-policy/connect-src&quot;&gt;&lt;code&gt;connect-src&lt;/code&gt;&lt;/a&gt; directive here. Even though the second policy would allow the connection, the first policy contains &lt;code&gt;connect-src 'none'&lt;/code&gt;. Adding additional policies &lt;em&gt;can only further restrict&lt;/em&gt; the capabilities of the protected resource, which means that there will be no connection allowed and, as the strictest policy, &lt;code&gt;connect-src 'none'&lt;/code&gt; is enforced.</source>
          <target state="translated">아래 예와 같이 &lt;code&gt;Content-Security-Policy&lt;/code&gt; 헤더를 두 번 이상 사용할 수 있습니다 . 여기서 &lt;a href=&quot;content-security-policy/connect-src&quot;&gt; &lt;code&gt;connect-src&lt;/code&gt; &lt;/a&gt; 지시문에 특히주의 하십시오. 두 번째 정책에서 연결을 허용하더라도 첫 번째 정책에는 &lt;code&gt;connect-src 'none'&lt;/code&gt; 이 포함 됩니다. 추가 정책을 추가 하면 보호 된 자원의 기능 &lt;em&gt;만 추가로 제한 할 수 있습니다.&lt;/em&gt; 즉, 연결이 허용되지 않으며 가장 엄격한 정책으로 &lt;code&gt;connect-src 'none'&lt;/code&gt; 이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="137bbd4986d24df8c6873572858b3eacd9e0ddc8" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header more than once, as in the example below. Pay special attention to the &lt;a href=&quot;content-security-policy/connect-src&quot;&gt;&lt;code&gt;connect-src&lt;/code&gt;&lt;/a&gt; directive here. Even though the second policy would allow the connection, the first policy contains &lt;code&gt;connect-src 'none'&lt;/code&gt;. Adding additional policies &lt;em&gt;can only further restrict&lt;/em&gt; the capabilities of the protected resource, which means that there will be no connection allowed and, as the strictest policy, &lt;code&gt;connect-src 'none'&lt;/code&gt; is enforced.</source>
          <target state="translated">아래 예제와 같이 &lt;code&gt;Content-Security-Policy&lt;/code&gt; 헤더를 두 번 이상 사용할 수 있습니다 . 여기서 &lt;a href=&quot;content-security-policy/connect-src&quot;&gt; &lt;code&gt;connect-src&lt;/code&gt; &lt;/a&gt; 지시문에 특히주의 하십시오. 두 번째 정책이 연결을 허용하더라도 첫 번째 정책에는 &lt;code&gt;connect-src 'none'&lt;/code&gt; 이 포함 됩니다. 추가 정책을 추가 하면 보호 된 리소스의 기능 &lt;em&gt;만 더 제한&lt;/em&gt; 될 수 있습니다. 즉, 연결이 허용되지 않고 가장 엄격한 정책으로 &lt;code&gt;connect-src 'none'&lt;/code&gt; 이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="15fc382b165c36d3e771f09364d3fcb2bc6049c2" translate="yes" xml:space="preserve">
          <source>You don't want to break these links, as they bring valuable users and help your SEO, so you set up redirects from the old URLs to the new ones.</source>
          <target state="translated">귀중한 사용자를 불러오고 SEO를 지원하므로 이러한 링크를 끊고 싶지 않으므로 이전 URL에서 새 URL로 리디렉션을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="34dc813df24a4439aacb95679eee73b4dc499bdd" translate="yes" xml:space="preserve">
          <source>You log into a free WiFi access point at an airport and start surfing the web, visiting your online banking service to check your balance and pay a couple of bills. Unfortunately, the access point you're using is actually a hacker's laptop, and they're intercepting your original HTTP request and redirecting you to a clone of your bank's site instead of the real thing. Now your private data is exposed to the hacker.</source>
          <target state="translated">공항에서 무료 Wi-Fi 액세스 포인트에 로그인하고 웹 서핑을 시작하고 온라인 뱅킹 서비스를 방문하여 잔액을 확인하고 청구서를 지불하십시오. 불행히도, 사용중인 액세스 포인트는 실제로 해커의 랩톱이며 원래 HTTP 요청을 가로 채고 실제 사이트 대신 은행 사이트의 복제본으로 리디렉션합니다. 이제 개인 데이터가 해커에 노출되었습니다.</target>
        </trans-unit>
        <trans-unit id="7a5b96310bd1cc34f2c4474ad2f7105660a63d2d" translate="yes" xml:space="preserve">
          <source>You should replace them with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener&quot;&gt;&lt;code&gt;addEventListener&lt;/code&gt;&lt;/a&gt; calls:</source>
          <target state="translated">이를 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener&quot;&gt; &lt;code&gt;addEventListener&lt;/code&gt; &lt;/a&gt; 호출로 바꿔야합니다 .</target>
        </trans-unit>
        <trans-unit id="6edcf297ed74116e062437136c2a1939f6a974cf" translate="yes" xml:space="preserve">
          <source>You should replaced them with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener&quot;&gt;&lt;code&gt;addEventListener&lt;/code&gt;&lt;/a&gt; calls:</source>
          <target state="translated">이를 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener&quot;&gt; &lt;code&gt;addEventListener&lt;/code&gt; &lt;/a&gt; 호출 로 바꿔야합니다 .</target>
        </trans-unit>
        <trans-unit id="2dc398a2b8603e27409f8150e3f33028d9184301" translate="yes" xml:space="preserve">
          <source>You shouldn't use the &lt;code&gt;From&lt;/code&gt; header for access control or authentication.</source>
          <target state="translated">액세스 제어 또는 인증에 &lt;code&gt;From&lt;/code&gt; 헤더를 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="aeb501a73f497244a1ca4c81bc0f2b75e165449c" translate="yes" xml:space="preserve">
          <source>You will have to set the same nonce on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; element:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에 동일한 nonce를 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="497810d0e0f1d8b5f343ce88e064b208a24ef471" translate="yes" xml:space="preserve">
          <source>You will have to set the same nonce on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; element:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에 동일한 nonce를 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8639bd898d6134e22819658d6593031b9a6e1f29" translate="yes" xml:space="preserve">
          <source>Your site needs to use a specific Web feature that some browsers don't yet support, and you want to send those users to an older Web site with fewer features but that you know will work. This is the worst reason to use user agent detection because odds are eventually all the other browsers will catch up. In addition, it is not practical to test every one of the less popular browsers and test for them. You should &lt;strong&gt;never &lt;/strong&gt;do user agent sniffing. There is &lt;strong&gt;always &lt;/strong&gt;the alternative of doing feature detection instead.</source>
          <target state="translated">귀하의 사이트는 일부 브라우저에서 아직 지원하지 않는 특정 웹 기능을 사용해야하며, 기능이 적지 만 작동 할 것으로 알고있는 이전 웹 사이트로 해당 사용자를 보내려고합니다. 이로 인해 사용자 에이전트 감지를 사용해야하는 최악의 이유는 다른 모든 브라우저에서 발생할 가능성이 높기 때문입니다. 또한 덜 인기있는 브라우저를 모두 테스트하고 테스트하는 것은 실용적이지 않습니다. 사용자 에이전트 스니핑을 수행 해서는 &lt;strong&gt;안됩니다&lt;/strong&gt; . 대신 기능 감지를 수행하는 대안 이 &lt;strong&gt;항상&lt;/strong&gt; 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3951b830d04bd983e497b92f61aa57c49fe1e1c8" translate="yes" xml:space="preserve">
          <source>Your site needs to use a specific Web feature that some browsers don't yet support, and you want to send those users to an older Web site with fewer features but that you know will work. This is the worst reason to use user agent detection because odds are eventually all the other browsers will catch up. In addition, it is not practical to test every one of the less popular browsers and test for them. You should &lt;strong&gt;never&lt;/strong&gt; do user agent sniffing. There is &lt;strong&gt;always&lt;/strong&gt; the alternative of doing feature detection instead.</source>
          <target state="translated">귀하의 사이트는 일부 브라우저에서 아직 지원하지 않는 특정 웹 기능을 사용해야하며 이러한 사용자를 더 적은 기능이 있지만 작동 할 것으로 알고있는 이전 웹 사이트로 보내려고합니다. 이것은 결국 다른 모든 브라우저가 따라 잡을 가능성이 있기 때문에 사용자 에이전트 감지를 사용하는 최악의 이유입니다. 또한 덜 인기있는 브라우저를 모두 테스트하고 테스트하는 것은 실용적이지 않습니다. 사용자 에이전트 스니핑 은 &lt;strong&gt;절대&lt;/strong&gt; 하지 말아야합니다 . 대신 기능 감지를 수행하는 대안 이 &lt;strong&gt;항상&lt;/strong&gt; 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a2430dd6f1577013044f8423647dd090b767a57" translate="yes" xml:space="preserve">
          <source>ZIP archive</source>
          <target state="translated">ZIP 보관</target>
        </trans-unit>
        <trans-unit id="7410a2c5889ae46b6ebf4b5278be959009c7bf12" translate="yes" xml:space="preserve">
          <source>Zero or more comments containing more details; sub-product information, for example.</source>
          <target state="translated">자세한 내용이 포함 된 0 개 이상의 주석 예를 들어, 하위 제품 정보.</target>
        </trans-unit>
        <trans-unit id="7d194154860ee775d5ccbab4aa4357621f57dae0" translate="yes" xml:space="preserve">
          <source>Zero or more comments containing sub product information, for example.</source>
          <target state="translated">예를 들어 하위 제품 정보를 포함하는 0 개 이상의 주석</target>
        </trans-unit>
        <trans-unit id="2284673182cdd127888b6dd7e7eec11544c2f01a" translate="yes" xml:space="preserve">
          <source>Zombie cookies and Evercookies</source>
          <target state="translated">좀비 쿠키와 에버 쿠키</target>
        </trans-unit>
        <trans-unit id="1858daecfe7cd2d5ad3fcabc22474135629b2038" translate="yes" xml:space="preserve">
          <source>Zombie cookies on Wikipedia</source>
          <target state="translated">Wikipedia의 좀비 쿠키</target>
        </trans-unit>
        <trans-unit id="faa3018647580610f8ce8b73789a682575c40c26" translate="yes" xml:space="preserve">
          <source>[1] The specification did not intend to allow method changes, but there are existing user agents that do change their method. &lt;a href=&quot;status/308&quot;&gt;&lt;code&gt;308&lt;/code&gt;&lt;/a&gt; was created to remove the ambiguity of the behavior when using non-&lt;code&gt;GET&lt;/code&gt; methods.</source>
          <target state="translated">[1] 사양은 방법 변경을 허용하지 않았지만 방법을 변경하는 기존 사용자 에이전트가 있습니다. 비 &lt;code&gt;GET&lt;/code&gt; 메서드를 사용할 때 동작의 모호성을 제거하기 위해 &lt;a href=&quot;status/308&quot;&gt; &lt;code&gt;308&lt;/code&gt; &lt;/a&gt; 이 만들어졌습니다 .</target>
        </trans-unit>
        <trans-unit id="6b0af4c0811a538531e2dcf92a4868eda57b0def" translate="yes" xml:space="preserve">
          <source>[1] The specification had no intent to allow method changes, but practically there are user agents out there doing this. &lt;code&gt;308&lt;/code&gt; has been created to remove the ambiguity of the behavior when using non-&lt;code&gt;GET&lt;/code&gt; methods.</source>
          <target state="translated">사양은 방법 변경을 허용하려는 의도가 없었지만 실제로는이를 수행하는 사용자 에이전트가 있습니다. 비 &lt;code&gt;GET&lt;/code&gt; 메소드를 사용할 때 동작의 모호성을 제거하기 위해 &lt;code&gt;308&lt;/code&gt; 이 작성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f59b1ae9fa755e33069cec38aff63589aeb6fd23" translate="yes" xml:space="preserve">
          <source>[2] The specification did not intend to allow method changes, but there are existing user agents that do change their method. &lt;a href=&quot;status/307&quot;&gt;&lt;code&gt;307&lt;/code&gt;&lt;/a&gt; was created to remove the ambiguity of the behavior when using non-&lt;code&gt;GET&lt;/code&gt; methods.</source>
          <target state="translated">[2] 사양은 방법 변경을 허용하지 않았지만 방법을 변경하는 기존 사용자 에이전트가 있습니다. 비 &lt;code&gt;GET&lt;/code&gt; 메서드를 사용할 때 동작의 모호성을 제거하기 위해 &lt;a href=&quot;status/307&quot;&gt; &lt;code&gt;307&lt;/code&gt; &lt;/a&gt; 이 만들어졌습니다 .</target>
        </trans-unit>
        <trans-unit id="bc921dbce86b3452ecb504ace2a6ebd3695e66a1" translate="yes" xml:space="preserve">
          <source>[2] The specification had no intent to allow method changes, but practically there are user agents out there doing this. &lt;code&gt;307&lt;/code&gt; has been created to remove the ambiguity of the behavior when using non-&lt;code&gt;GET&lt;/code&gt; methods.</source>
          <target state="translated">사양은 방법 변경을 허용하려는 의도가 없었지만 실제로는이를 수행하는 사용자 에이전트가 있습니다. 비 &lt;code&gt;GET&lt;/code&gt; 메소드를 사용할 때 동작의 모호성을 제거하기 위해 &lt;code&gt;307&lt;/code&gt; 이 작성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6e0756612a3806a698305eb0752124038b7a1541" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-1&quot; name=&quot;ref-1&quot;&gt;1&lt;/a&gt;] Alvestrand, H., &quot;Tags for the Identification of Languages&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1766&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1766&quot;&gt;1766&lt;/a&gt;, March 1995.

   [&lt;a id=&quot;ref-2&quot; name=&quot;ref-2&quot;&gt;2&lt;/a&gt;] Anklesaria, F., McCahill, M., Lindner, P., Johnson, D., Torrey,
       D. and B. Alberti, &quot;The Internet Gopher Protocol (a distributed
       document search and retrieval protocol)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1436&quot;&gt;RFC 1436&lt;/a&gt;, March 1993.

   [&lt;a id=&quot;ref-3&quot; name=&quot;ref-3&quot;&gt;3&lt;/a&gt;] Berners-Lee, T., &quot;Universal Resource Identifiers in WWW&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1630&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1630&quot;&gt;1630&lt;/a&gt;, June 1994.

   [&lt;a id=&quot;ref-4&quot; name=&quot;ref-4&quot;&gt;4&lt;/a&gt;] Berners-Lee, T., Masinter, L. and M. McCahill, &quot;Uniform Resource
       Locators (URL)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1738&quot;&gt;RFC 1738&lt;/a&gt;, December 1994.

   [&lt;a id=&quot;ref-5&quot; name=&quot;ref-5&quot;&gt;5&lt;/a&gt;] Berners-Lee, T. and D. Connolly, &quot;Hypertext Markup Language -
       2.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1866&quot;&gt;RFC 1866&lt;/a&gt;, November 1995.

   [&lt;a id=&quot;ref-6&quot; name=&quot;ref-6&quot;&gt;6&lt;/a&gt;] Berners-Lee, T., Fielding, R. and H. Frystyk, &quot;Hypertext Transfer
       Protocol -- HTTP/1.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-7&quot; name=&quot;ref-7&quot;&gt;7&lt;/a&gt;] Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
       Extensions (MIME) Part One: Format of Internet Message Bodies&quot;,
       &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;, November 1996.

   [&lt;a id=&quot;ref-8&quot; name=&quot;ref-8&quot;&gt;8&lt;/a&gt;] Braden, R., &quot;Requirements for Internet Hosts -- Communication
       Layers&quot;, STD 3, &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt;, October 1989.

   [&lt;a id=&quot;ref-9&quot; name=&quot;ref-9&quot;&gt;9&lt;/a&gt;] Crocker, D., &quot;Standard for The Format of ARPA Internet Text
       Messages&quot;, STD 11, &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;, August 1982.

   [&lt;a id=&quot;ref-10&quot; name=&quot;ref-10&quot;&gt;10&lt;/a&gt;] Davis, F., Kahle, B., Morris, H., Salem, J., Shen, T., Wang, R.,
        Sui, J., and M. Grinbaum, &quot;WAIS Interface Protocol Prototype
        Functional Specification,&quot; (v1.5), Thinking Machines
        Corporation, April 1990.

   [&lt;a id=&quot;ref-11&quot; name=&quot;ref-11&quot;&gt;11&lt;/a&gt;] Fielding, R., &quot;Relative Uniform Resource Locators&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt;,
        June 1995.

   [&lt;a id=&quot;ref-12&quot; name=&quot;ref-12&quot;&gt;12&lt;/a&gt;] Horton, M. and R. Adams, &quot;Standard for Interchange of USENET
        Messages&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1036&quot;&gt;RFC 1036&lt;/a&gt;, December 1987. 

   [&lt;a id=&quot;ref-13&quot; name=&quot;ref-13&quot;&gt;13&lt;/a&gt;] Kantor, B. and P. Lapsley, &quot;Network News Transfer Protocol&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc977&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc977&quot;&gt;977&lt;/a&gt;, February 1986.

   [&lt;a id=&quot;ref-14&quot; name=&quot;ref-14&quot;&gt;14&lt;/a&gt;] Moore, K., &quot;MIME (Multipurpose Internet Mail Extensions) Part
        Three: Message Header Extensions for Non-ASCII Text&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;,
        November 1996.

   [&lt;a id=&quot;ref-15&quot; name=&quot;ref-15&quot;&gt;15&lt;/a&gt;] Nebel, E. and L. Masinter, &quot;Form-based File Upload in HTML&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1867&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1867&quot;&gt;1867&lt;/a&gt;, November 1995.

   [&lt;a id=&quot;ref-16&quot; name=&quot;ref-16&quot;&gt;16&lt;/a&gt;] Postel, J., &quot;Simple Mail Transfer Protocol&quot;, STD 10, &lt;a href=&quot;https://tools.ietf.org/html/rfc821&quot;&gt;RFC 821&lt;/a&gt;,
        August 1982.

   [&lt;a id=&quot;ref-17&quot; name=&quot;ref-17&quot;&gt;17&lt;/a&gt;] Postel, J., &quot;Media Type Registration Procedure&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt;,
        November 1996.

   [&lt;a id=&quot;ref-18&quot; name=&quot;ref-18&quot;&gt;18&lt;/a&gt;] Postel, J. and J. Reynolds, &quot;File Transfer Protocol&quot;, STD 9, &lt;a href=&quot;https://tools.ietf.org/html/rfc959&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc959&quot;&gt;959&lt;/a&gt;, October 1985.

   [&lt;a id=&quot;ref-19&quot; name=&quot;ref-19&quot;&gt;19&lt;/a&gt;] Reynolds, J. and J. Postel, &quot;Assigned Numbers&quot;, STD 2, &lt;a href=&quot;https://tools.ietf.org/html/rfc1700&quot;&gt;RFC 1700&lt;/a&gt;,
        October 1994.

   [&lt;a id=&quot;ref-20&quot; name=&quot;ref-20&quot;&gt;20&lt;/a&gt;] Sollins, K. and L. Masinter, &quot;Functional Requirements for
        Uniform Resource Names&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1737&quot;&gt;RFC 1737&lt;/a&gt;, December 1994.

   [&lt;a id=&quot;ref-21&quot; name=&quot;ref-21&quot;&gt;21&lt;/a&gt;] US-ASCII. Coded Character Set - 7-Bit American Standard Code for
        Information Interchange. Standard ANSI X3.4-1986, ANSI, 1986.

   [&lt;a id=&quot;ref-22&quot; name=&quot;ref-22&quot;&gt;22&lt;/a&gt;] ISO-8859. International Standard -- Information Processing --
        8-bit Single-Byte Coded Graphic Character Sets --
        Part 1: Latin alphabet No. 1, ISO-8859-1:1987.
        Part 2: Latin alphabet No. 2, ISO-8859-2, 1987.
        Part 3: Latin alphabet No. 3, ISO-8859-3, 1988.
        Part 4: Latin alphabet No. 4, ISO-8859-4, 1988.
        Part 5: Latin/Cyrillic alphabet, ISO-8859-5, 1988.
        Part 6: Latin/Arabic alphabet, ISO-8859-6, 1987.
        Part 7: Latin/Greek alphabet, ISO-8859-7, 1987.
        Part 8: Latin/Hebrew alphabet, ISO-8859-8, 1988.
        Part 9: Latin alphabet No. 5, ISO-8859-9, 1990.

   [&lt;a id=&quot;ref-23&quot; name=&quot;ref-23&quot;&gt;23&lt;/a&gt;] Meyers, J. and M. Rose, &quot;The Content-MD5 Header Field&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;1864&lt;/a&gt;, October 1995.

   [&lt;a id=&quot;ref-24&quot; name=&quot;ref-24&quot;&gt;24&lt;/a&gt;] Carpenter, B. and Y. Rekhter, &quot;Renumbering Needs Work&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;1900&lt;/a&gt;, February 1996.

   [&lt;a id=&quot;ref-25&quot; name=&quot;ref-25&quot;&gt;25&lt;/a&gt;] Deutsch, P., &quot;GZIP file format specification version 4.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;1952&lt;/a&gt;, May 1996. 

   [&lt;a id=&quot;ref-26&quot; name=&quot;ref-26&quot;&gt;26&lt;/a&gt;] Venkata N. Padmanabhan, and Jeffrey C. Mogul. &quot;Improving HTTP
        Latency&quot;, Computer Networks and ISDN Systems, v. 28, pp. 25-35,
        Dec. 1995. Slightly revised version of paper in Proc. 2nd
        International WWW Conference '94: Mosaic and the Web, Oct. 1994,
        which is available at
        &lt;a href=&quot;http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLatency.html&quot;&gt;http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLat&lt;/a&gt;&lt;a href=&quot;http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLatency.html&quot;&gt;ency.html&lt;/a&gt;.

   [&lt;a id=&quot;ref-27&quot; name=&quot;ref-27&quot;&gt;27&lt;/a&gt;] Joe Touch, John Heidemann, and Katia Obraczka. &quot;Analysis of HTTP
        Performance&quot;, &amp;lt;URL: &lt;a href=&quot;http://www.isi.edu/touch/pubs/http-perf96/&quot;&gt;http://www.isi.edu/touch/pubs/http-perf96/&lt;/a&gt;&amp;gt;,
        ISI Research Report ISI/RR-98-463, (original report dated Aug.
        1996), USC/Information Sciences Institute, August 1998.

   [&lt;a id=&quot;ref-28&quot; name=&quot;ref-28&quot;&gt;28&lt;/a&gt;] Mills, D., &quot;Network Time Protocol (Version 3) Specification,
        Implementation and Analysis&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1305&quot;&gt;RFC 1305&lt;/a&gt;, March 1992.

   [&lt;a id=&quot;ref-29&quot; name=&quot;ref-29&quot;&gt;29&lt;/a&gt;] Deutsch, P., &quot;DEFLATE Compressed Data Format Specification
        version 1.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC 1951&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-30&quot; name=&quot;ref-30&quot;&gt;30&lt;/a&gt;] S. Spero, &quot;Analysis of HTTP Performance Problems,&quot;
        &lt;a href=&quot;http://sunsite.unc.edu/mdma-release/http-prob.html&quot;&gt;http://sunsite.unc.edu/mdma-release/http-prob.html&lt;/a&gt;.

   [&lt;a id=&quot;ref-31&quot; name=&quot;ref-31&quot;&gt;31&lt;/a&gt;] Deutsch, P. and J. Gailly, &quot;ZLIB Compressed Data Format
        Specification version 3.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-32&quot; name=&quot;ref-32&quot;&gt;32&lt;/a&gt;] Franks, J., Hallam-Baker, P., Hostetler, J., Leach, P.,
        Luotonen, A., Sink, E. and L. Stewart, &quot;An Extension to HTTP:
        Digest Access Authentication&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2069&quot;&gt;RFC 2069&lt;/a&gt;, January 1997.

   [&lt;a id=&quot;ref-33&quot; name=&quot;ref-33&quot;&gt;33&lt;/a&gt;] Fielding, R., Gettys, J., Mogul, J., Frystyk, H. and T.
        Berners-Lee, &quot;Hypertext Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;2068&lt;/a&gt;, January 1997.

   [&lt;a id=&quot;ref-34&quot; name=&quot;ref-34&quot;&gt;34&lt;/a&gt;] Bradner, S., &quot;Key words for use in RFCs to Indicate Requirement
        Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997.

   [&lt;a id=&quot;ref-35&quot; name=&quot;ref-35&quot;&gt;35&lt;/a&gt;] Troost, R. and Dorner, S., &quot;Communicating Presentation
        Information in Internet Messages: The Content-Disposition
        Header&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt;, June 1995.

   [&lt;a id=&quot;ref-36&quot; name=&quot;ref-36&quot;&gt;36&lt;/a&gt;] Mogul, J., Fielding, R., Gettys, J. and H. Frystyk, &quot;Use and
        Interpretation of HTTP Version Numbers&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;, May 1997.
        [jg639]

   [&lt;a id=&quot;ref-37&quot; name=&quot;ref-37&quot;&gt;37&lt;/a&gt;] Palme, J., &quot;Common Internet Message Headers&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2076&quot;&gt;RFC 2076&lt;/a&gt;, February
        1997. [jg640] 

   [&lt;a id=&quot;ref-38&quot; name=&quot;ref-38&quot;&gt;38&lt;/a&gt;] Yergeau, F., &quot;UTF-8, a transformation format of Unicode and
        ISO-10646&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2279&quot;&gt;RFC 2279&lt;/a&gt;, January 1998. [jg641]

   [&lt;a id=&quot;ref-39&quot; name=&quot;ref-39&quot;&gt;39&lt;/a&gt;] Nielsen, H.F., Gettys, J., Baird-Smith, A., Prud'hommeaux, E.,
        Lie, H., and C. Lilley. &quot;Network Performance Effects of
        HTTP/1.1, CSS1, and PNG,&quot; Proceedings of ACM SIGCOMM '97, Cannes
        France, September 1997.[jg642]

   [&lt;a id=&quot;ref-40&quot; name=&quot;ref-40&quot;&gt;40&lt;/a&gt;] Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
        Extensions (MIME) Part Two: Media Types&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt;, November
        1996. [jg643]

   [&lt;a id=&quot;ref-41&quot; name=&quot;ref-41&quot;&gt;41&lt;/a&gt;] Alvestrand, H., &quot;IETF Policy on Character Sets and Languages&quot;,
        &lt;a href=&quot;https://tools.ietf.org/html/bcp18&quot;&gt;BCP 18&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2277&quot;&gt;RFC 2277&lt;/a&gt;, January 1998. [jg644]

   [&lt;a id=&quot;ref-42&quot; name=&quot;ref-42&quot;&gt;42&lt;/a&gt;] Berners-Lee, T., Fielding, R. and L. Masinter, &quot;Uniform Resource
        Identifiers (URI): Generic Syntax and Semantics&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt;,
        August 1998. [jg645]

   [&lt;a id=&quot;ref-43&quot; name=&quot;ref-43&quot;&gt;43&lt;/a&gt;] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
        Leach, P., Luotonen, A., Sink, E. and L. Stewart, &quot;HTTP
        Authentication: Basic and Digest Access Authentication&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;2617&lt;/a&gt;, June 1999. [jg646]

   [&lt;a id=&quot;ref-44&quot; name=&quot;ref-44&quot;&gt;44&lt;/a&gt;] Luotonen, A., &quot;Tunneling TCP based protocols through Web proxy
        servers,&quot; Work in Progress. [jg647]

   [&lt;a id=&quot;ref-45&quot; name=&quot;ref-45&quot;&gt;45&lt;/a&gt;] Palme, J. and A. Hopmann, &quot;MIME E-mail Encapsulation of
        Aggregate Documents, such as HTML (MHTML)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2110&quot;&gt;RFC 2110&lt;/a&gt;, March
        1997.

   [&lt;a id=&quot;ref-46&quot; name=&quot;ref-46&quot;&gt;46&lt;/a&gt;] Bradner, S., &quot;The Internet Standards Process -- Revision 3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp9&quot;&gt;BCP&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/bcp9&quot;&gt;9&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2026&quot;&gt;RFC 2026&lt;/a&gt;, October 1996.

   [&lt;a id=&quot;ref-47&quot; name=&quot;ref-47&quot;&gt;47&lt;/a&gt;] Masinter, L., &quot;Hyper Text Coffee Pot Control Protocol
        (HTCPCP/1.0)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2324&quot;&gt;RFC 2324&lt;/a&gt;, 1 April 1998.

   [&lt;a id=&quot;ref-48&quot; name=&quot;ref-48&quot;&gt;48&lt;/a&gt;] Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
        Extensions (MIME) Part Five: Conformance Criteria and Examples&quot;,
        &lt;a href=&quot;https://tools.ietf.org/html/rfc2049&quot;&gt;RFC 2049&lt;/a&gt;, November 1996.

   [&lt;a id=&quot;ref-49&quot; name=&quot;ref-49&quot;&gt;49&lt;/a&gt;] Troost, R., Dorner, S. and K. Moore, &quot;Communicating Presentation
        Information in Internet Messages: The Content-Disposition Header
        Field&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2183&quot;&gt;RFC 2183&lt;/a&gt;, August 1997.</source>
          <target state="translated">[ &lt;a id=&quot;ref-1&quot; name=&quot;ref-1&quot;&gt;1&lt;/a&gt; ] Alvestrand, H., &quot;언어의 식별에 대한 태그&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1766&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1766&quot;&gt;1766&lt;/a&gt; , 1995 년 3 월 [ &lt;a id=&quot;ref-2&quot; name=&quot;ref-2&quot;&gt;2&lt;/a&gt; ] Anklesaria, F., McCahill, M., 린드너, P., 존슨, D., 토리, D. B. Alberti, &quot;인터넷 고퍼 프로토콜 (분산 문서 검색 및 검색 프로토콜)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1436&quot;&gt;RFC 1436&lt;/a&gt; , 1993 년 &lt;a id=&quot;ref-3&quot; name=&quot;ref-3&quot;&gt;3&lt;/a&gt; 월. [ 3 ] Berners-Lee, T., &quot;WW의 범용 자원 식별자&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1630&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1630&quot;&gt;1630&lt;/a&gt; , 1994 년 6 월 [ &lt;a id=&quot;ref-4&quot; name=&quot;ref-4&quot;&gt;4&lt;/a&gt; ] Berners-Lee, T., Masinter, L. 및 M. McCahill, &quot;Uniform Resource Locators (URL)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1738&quot;&gt;RFC 1738&lt;/a&gt; , 1994 년 12 월. [ &lt;a id=&quot;ref-5&quot; name=&quot;ref-5&quot;&gt;5&lt;/a&gt;] Berners-Lee, T. 및 D. Connolly, &quot;하이퍼 텍스트 마크 업 언어-2.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1866&quot;&gt;RFC 1866&lt;/a&gt; , 1995 년 11 월. [ &lt;a id=&quot;ref-6&quot; name=&quot;ref-6&quot;&gt;6&lt;/a&gt; ] Berners-Lee, T., Fielding, R. 및 H. Frystyk, &quot;하이퍼 텍스트 전송 프로토콜- -HTTP / 1.0 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; , 1996 년 5 월. [ &lt;a id=&quot;ref-7&quot; name=&quot;ref-7&quot;&gt;7&lt;/a&gt; ] Freed, N. 및 N. Borenstein,&quot;MIME (Multipurpose Internet Mail Extensions) 1 부 : 인터넷 메시지 본문 형식 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; , 1996 년 11 월. [ &lt;a id=&quot;ref-8&quot; name=&quot;ref-8&quot;&gt;8&lt;/a&gt; ] Braden, R., &quot;인터넷 호스트 요구 사항-통신 계층&quot;, STD 3, &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; , 1989 년 10 월. [ &lt;a id=&quot;ref-9&quot; name=&quot;ref-9&quot;&gt;9&lt;/a&gt; ] Crocker, D., &quot;ARPA 인터넷 문자 메시지 형식 표준&quot;, STD 11,&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;1982 년 8 월. [ &lt;a id=&quot;ref-10&quot; name=&quot;ref-10&quot;&gt;10&lt;/a&gt; ] Davis, F., Kahle, B., Morris, H., Salem, J., Shen, T., Wang, R., Sui, J. 및 M. Grinbaum, &quot;WAIS 인터페이스 프로토콜 프로토 타입 기능 사양, &quot;(v1.5), Thinking Machines Corporation, 1990 년 4 월. [ &lt;a id=&quot;ref-11&quot; name=&quot;ref-11&quot;&gt;11&lt;/a&gt; ] Fielding, R.,&quot;Relative Uniform Resource Locators &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt; , 1995 년 6 월. [ &lt;a id=&quot;ref-12&quot; name=&quot;ref-12&quot;&gt;12&lt;/a&gt; ] Horton, M. and R. Adams, &quot;USENET 메시지 교환 표준&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1036&quot;&gt;RFC 1036&lt;/a&gt; , 1987 년 12 월. [ &lt;a id=&quot;ref-13&quot; name=&quot;ref-13&quot;&gt;13&lt;/a&gt; ] Kantor, B. 및 P. Lapsley, &quot;Network News Transfer Protocol&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc977&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc977&quot;&gt;977&lt;/a&gt; , 1986 년 2 월. [ &lt;a id=&quot;ref-14&quot; name=&quot;ref-14&quot;&gt;14&lt;/a&gt;] Moore, K., &quot;MIME (Multipurpose Internet Mail Extensions) 3 부 : 비 ASCII 텍스트에 대한 메시지 헤더 확장&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; , 1996 년 11 월. [ &lt;a id=&quot;ref-15&quot; name=&quot;ref-15&quot;&gt;15&lt;/a&gt; ] Nebel, E. 및 L. Masinter, &quot;양식 파일 HTML로 업로드 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1867&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1867&quot;&gt;1867&lt;/a&gt; , 1995 년 11 월. [ &lt;a id=&quot;ref-16&quot; name=&quot;ref-16&quot;&gt;16&lt;/a&gt; ] Postel, J.,&quot;단순 메일 전송 프로토콜 &quot;, STD 10, &lt;a href=&quot;https://tools.ietf.org/html/rfc821&quot;&gt;RFC 821&lt;/a&gt; , 1982 년 8 월. [ &lt;a id=&quot;ref-17&quot; name=&quot;ref-17&quot;&gt;17&lt;/a&gt; ] Postel, J.,&quot;미디어 유형 등록 절차 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt; , 1996 년 11 월. [ &lt;a id=&quot;ref-18&quot; name=&quot;ref-18&quot;&gt;18&lt;/a&gt; ] Postel, J. 및 J. Reynolds, &quot;파일 전송 프로토콜&quot;, STD 9, &lt;a href=&quot;https://tools.ietf.org/html/rfc959&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc959&quot;&gt;959&lt;/a&gt; , 1985 년 10 월. [ &lt;a id=&quot;ref-19&quot; name=&quot;ref-19&quot;&gt;19&lt;/a&gt;] Reynolds, J. 및 J. Postel, &quot;지정 번호&quot;, STD 2, &lt;a href=&quot;https://tools.ietf.org/html/rfc1700&quot;&gt;RFC 1700&lt;/a&gt; , 1994 년 10 월. [ &lt;a id=&quot;ref-20&quot; name=&quot;ref-20&quot;&gt;20&lt;/a&gt; ] Sollins, K. 및 L. Masinter, &quot;일관된 자원 명에 대한 기능 요구 사항&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1737&quot;&gt;RFC 1737&lt;/a&gt; , 1994 년 12 월 [ &lt;a id=&quot;ref-21&quot; name=&quot;ref-21&quot;&gt;21&lt;/a&gt; ] US-ASCII. 코드화 된 문자 세트-정보 교환을위한 7 비트 미국 표준 코드. 표준 ANSI X3.4-1986, ANSI, 1986. [ &lt;a id=&quot;ref-22&quot; name=&quot;ref-22&quot;&gt;22&lt;/a&gt;] ISO-8859. 국제 표준-정보 처리-8 비트 단일 바이트 코드 그래픽 문자 세트-1 부 : 라틴 알파벳 1, ISO-8859-1 : 1987. 2 부 : 라틴 알파벳 2, ISO-8859-2, 1987. 3 부 : 라틴 알파벳 3, ISO-8859-3, 1988. 4 부 : 라틴 알파벳 4, ISO-8859-4, 1988 5 부 : 라틴어 / 키릴 자모 알파벳, ISO-8859-5, 1988. 6 부 : 라틴어 / 아랍어 알파벳, ISO-8859-6, 1987. 7 부 : 라틴어 / 그리스어 알파벳, ISO-8859-7, 1987. 8 : 라틴 / 히브리어 알파벳, ISO-8859-8, 1988. Part 9 : 라틴 알파벳 No. 5, ISO-8859-9, 1990. [ &lt;a id=&quot;ref-23&quot; name=&quot;ref-23&quot;&gt;23&lt;/a&gt; ] Meyers, J. and M. Rose, &quot;Content-MD5 헤더 Field &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;1864&lt;/a&gt; , 1995 년 10 월. [ &lt;a id=&quot;ref-24&quot; name=&quot;ref-24&quot;&gt;24&lt;/a&gt;] 목수, B. 및 Y. Rekhter, &quot;재 번호 매기기 작업 필요&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;1900&lt;/a&gt; , 1996 년 2 월. [ &lt;a id=&quot;ref-25&quot; name=&quot;ref-25&quot;&gt;25&lt;/a&gt; ] Deutsch, P., &quot;GZIP 파일 형식 사양 버전 4.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;1952&lt;/a&gt; , 1996 년 5 월. [ &lt;a id=&quot;ref-26&quot; name=&quot;ref-26&quot;&gt;26&lt;/a&gt; ] Venkata N Padmanabhan 및 Jeffrey C. Mogul. &quot;HTTP 지연 시간 개선&quot;, 컴퓨터 네트워크 및 ISDN 시스템, v. 28, pp. 25-35, 1995 년 12 월. Proc. 제 2 차 국제 WWW 컨퍼런스 '94 : Mosaic and the Web, 1994 년 10 월, &lt;a href=&quot;http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLatency.html&quot;&gt;http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLat &lt;/a&gt;&lt;a href=&quot;http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLatency.html&quot;&gt;ency.html&lt;/a&gt; 에서 볼 수 있습니다 . [ &lt;a id=&quot;ref-27&quot; name=&quot;ref-27&quot;&gt;27&lt;/a&gt;] Joe Touch, John Heidemann 및 Katia Obraczka. &quot;HTTP 성능 분석&quot;, &amp;lt;URL : &lt;a href=&quot;http://www.isi.edu/touch/pubs/http-perf96/&quot;&gt;http://www.isi.edu/touch/pubs/http-perf96/&lt;/a&gt; &amp;gt;, ISI Research Report ISI / RR-98-463, (1996 년 8 월 원본 보고서), USC / Information Sciences Institute, 1998 년 8 월. [ &lt;a id=&quot;ref-28&quot; name=&quot;ref-28&quot;&gt;28&lt;/a&gt; ] Mills, D., &quot;네트워크 시간 프로토콜 (버전 3) 사양, 구현 및 분석&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1305&quot;&gt;RFC 1305&lt;/a&gt; , 1992 년 3 월. [ &lt;a id=&quot;ref-29&quot; name=&quot;ref-29&quot;&gt;29&lt;/a&gt; ] Deutsch, P., &quot;DEFLATE 압축 데이터 형식 사양 버전 1.3 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC 1951&lt;/a&gt; , 1996 년 5 월 [ &lt;a id=&quot;ref-30&quot; name=&quot;ref-30&quot;&gt;30&lt;/a&gt; ] S. Spero,&quot;분석 HTTP의 성능 문제, &quot; &lt;a href=&quot;http://sunsite.unc.edu/mdma-release/http-prob.html&quot;&gt;http://sunsite.unc.edu/mdma-release/http-prob.html&lt;/a&gt; .[ &lt;a id=&quot;ref-31&quot; name=&quot;ref-31&quot;&gt;31&lt;/a&gt;] Deutsch, P. 및 J. Gailly, &quot;ZLIB 압축 데이터 형식 사양 버전 3.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt; , 1996 년 5 월. [ &lt;a id=&quot;ref-32&quot; name=&quot;ref-32&quot;&gt;32&lt;/a&gt; ] Franks, J., Hallam-Baker, P., Hostetler, J., Leach, P. , Luotonen, A., Sink, E. 및 L. Stewart, &quot;HTTP의 확장 : 다이제스트 액세스 인증&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2069&quot;&gt;RFC 2069&lt;/a&gt; , 1997 년 1 월. [ &lt;a id=&quot;ref-33&quot; name=&quot;ref-33&quot;&gt;33&lt;/a&gt; ] Fielding, R., Gettys, J., Mogul, J., Frystyk, H. 및 T. Berners-Lee, &quot;Hypertext Transfer Protocol-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;2068&lt;/a&gt; , 1997 년 1 월. [ &lt;a id=&quot;ref-34&quot; name=&quot;ref-34&quot;&gt;34&lt;/a&gt; ] Bradner, S., &quot;요구 사항 수준을 나타내는 RFC에서 사용되는 핵심어&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; , 1997 년 3 월. [ &lt;a id=&quot;ref-35&quot; name=&quot;ref-35&quot;&gt;35&lt;/a&gt;] Troost, R. 및 Dorner, S., &quot;인터넷 메시지의 프리젠 테이션 정보 통신 : 컨텐츠 처리 헤더&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt; , 1995 년 6 월. [ &lt;a id=&quot;ref-36&quot; name=&quot;ref-36&quot;&gt;36&lt;/a&gt; ] Mogul, J., Fielding, R., Gettys, J. and H. Frystyk, &quot;HTTP 버전 번호 사용 및 해석&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; , 1997 년 5 월. [jg639] [ &lt;a id=&quot;ref-37&quot; name=&quot;ref-37&quot;&gt;37&lt;/a&gt; ] Palme, J., &quot;공통 인터넷 메시지 헤더&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2076&quot;&gt;RFC 2076&lt;/a&gt; , 1997 년 2 월. [jg640] [ &lt;a id=&quot;ref-38&quot; name=&quot;ref-38&quot;&gt;38&lt;/a&gt; ] Yergeau, F., &quot;UTF-8, 유니 코드 및 ISO-10646의 변환 형식&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2279&quot;&gt;RFC 2279&lt;/a&gt; , 1998 년 1 월. [jg641] [ &lt;a id=&quot;ref-39&quot; name=&quot;ref-39&quot;&gt;39&lt;/a&gt;] Nielsen, HF, Gettys, J., Baird-Smith, A., Prud'hommeaux, E., Lie, H. 및 C. Lilley. &quot;HTTP / 1.1, CSS1 및 PNG의 네트워크 성능 효과,&quot;1997 년 9 월, 칸느 프랑스 ACM SIGCOMM '97의 절차. [jg642] [ &lt;a id=&quot;ref-40&quot; name=&quot;ref-40&quot;&gt;40&lt;/a&gt; ] Free , N. 및 N. Borenstein, &quot;MIME (Multipurpose Internet Mail Extensions)&quot; ) 2 부 : 미디어 유형 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt; , 1996 년 11 월. [jg643] [ &lt;a id=&quot;ref-41&quot; name=&quot;ref-41&quot;&gt;41&lt;/a&gt; ] Alvestrand, H.,&quot;문자 세트 및 언어에 대한 IETF 정책 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp18&quot;&gt;BCP 18&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2277&quot;&gt;RFC 2277&lt;/a&gt; , 1998 년 1 월. [jg644] [ &lt;a id=&quot;ref-42&quot; name=&quot;ref-42&quot;&gt;42&lt;/a&gt; ] Berners-Lee, T., Fielding, R. 및 L. Masinter, &quot;Uniform Resource Identifiers (URI) : 일반 구문 및 의미론&quot;,&lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt;[jg645] [ &lt;a id=&quot;ref-43&quot; name=&quot;ref-43&quot;&gt;43&lt;/a&gt; ] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., Sink, E. and L. Stewart , &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;2617&lt;/a&gt; , 1999 년 6 월. [jg646] [ &lt;a id=&quot;ref-44&quot; name=&quot;ref-44&quot;&gt;44&lt;/a&gt; ] Luotonen, A., &quot;웹 프록시 서버를 통한 TCP 기반 프로토콜 튠링 &quot;작업 진행 중. [jg647] [ &lt;a id=&quot;ref-45&quot; name=&quot;ref-45&quot;&gt;45&lt;/a&gt; ] Palme, J. 및 A. Hopmann, &quot;HTML (MHTML)과 같은 집계 문서의 MIME 전자 메일 캡슐화&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2110&quot;&gt;RFC 2110&lt;/a&gt; , 1997 년 3 월. [ &lt;a id=&quot;ref-46&quot; name=&quot;ref-46&quot;&gt;46&lt;/a&gt; ] Bradner, S., &quot;인터넷 표준 프로세스-개정 3 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp9&quot;&gt;BCP &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/bcp9&quot;&gt;9&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2026&quot;&gt;RFC 2026&lt;/a&gt;10 월 1996 [ &lt;a id=&quot;ref-47&quot; name=&quot;ref-47&quot;&gt;47&lt;/a&gt; ] Masinter, L., &quot;하이퍼 텍스트 커피 주전자 제어 프로토콜 (HTCPCP이 / 1.0)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2324&quot;&gt;RFC 2324&lt;/a&gt; 년 4 월 1 일 1998 [ &lt;a id=&quot;ref-48&quot; name=&quot;ref-48&quot;&gt;48&lt;/a&gt; ] 해방, N. 및 N. Borenstein, &quot;다목적 인터넷 메일 확장 (MIME) 5 부 : 적합성 기준 및 예 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2049&quot;&gt;RFC 2049&lt;/a&gt; , 1996 년 11 월. [ &lt;a id=&quot;ref-49&quot; name=&quot;ref-49&quot;&gt;49&lt;/a&gt; ] Troost, R., Dorner, S. 및 K. Moore,&quot;인터넷 메시지의 프리젠 테이션 정보 통신 : 컨텐츠 처리 헤더 필드 &quot; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2183&quot;&gt;RFC 2183&lt;/a&gt; , 1997 년 8 월.</target>
        </trans-unit>
        <trans-unit id="dc821d5e8b6f5141610286985b0b686179701b49" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-BCP115&quot; name=&quot;ref-BCP115&quot;&gt;BCP115&lt;/a&gt;]      Hansen, T., Hardie, T., and L. Masinter, &quot;Guidelines
                 and Registration Procedures for New URI Schemes&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/bcp115&quot;&gt;BCP 115&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4395&quot;&gt;RFC 4395&lt;/a&gt;, February 2006.

   [&lt;a id=&quot;ref-BCP13&quot; name=&quot;ref-BCP13&quot;&gt;BCP13&lt;/a&gt;]       Freed, N., Klensin, J., and T. Hansen, &quot;Media Type
                 Specifications and Registration Procedures&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt;, January 2013.

   [&lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]       Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
                 Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;, September 2004.

   [&lt;a id=&quot;ref-Georgiev&quot; name=&quot;ref-Georgiev&quot;&gt;Georgiev&lt;/a&gt;]    Georgiev, M., Iyengar, S., Jana, S., Anubhai, R.,
                 Boneh, D., and V. Shmatikov, &quot;The Most Dangerous Code
                 in the World: Validating SSL Certificates in Non-
                 browser Software&quot;, In Proceedings of the 2012 ACM
                 Conference on Computer and Communications Security (CCS
                 '12), pp. 38-49, October 2012,
                 &amp;lt;&lt;a href=&quot;http://doi.acm.org/10.1145/2382196.2382204&quot;&gt;http://doi.acm.org/10.1145/2382196.2382204&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-ISO-8859-1&quot; name=&quot;ref-ISO-8859-1&quot;&gt;ISO-8859-1&lt;/a&gt;]  International Organization for Standardization,
                 &quot;Information technology -- 8-bit single-byte coded
                 graphic character sets -- Part 1: Latin alphabet No.
                 1&quot;, ISO/IEC 8859-1:1998, 1998.

   [&lt;a id=&quot;ref-Klein&quot; name=&quot;ref-Klein&quot;&gt;Klein&lt;/a&gt;]       Klein, A., &quot;Divide and Conquer - HTTP Response
                 Splitting, Web Cache Poisoning Attacks, and Related
                 Topics&quot;, March 2004, &amp;lt;&lt;a href=&quot;http://packetstormsecurity.com/papers/general/whitepaper_httpresponse.pdf&quot;&gt;http://packetstormsecurity.com/&lt;/a&gt;&lt;a href=&quot;http://packetstormsecurity.com/papers/general/whitepaper_httpresponse.pdf&quot;&gt;papers/general/whitepaper_httpresponse.pdf&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-Kri2001&quot; name=&quot;ref-Kri2001&quot;&gt;Kri2001&lt;/a&gt;]     Kristol, D., &quot;HTTP Cookies: Standards, Privacy, and
                 Politics&quot;, ACM Transactions on Internet
                 Technology 1(2), November 2001,
                 &amp;lt;&lt;a href=&quot;http://arxiv.org/abs/cs.SE/0105018&quot;&gt;http://arxiv.org/abs/cs.SE/0105018&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-Linhart&quot; name=&quot;ref-Linhart&quot;&gt;Linhart&lt;/a&gt;]     Linhart, C., Klein, A., Heled, R., and S. Orrin, &quot;HTTP
                 Request Smuggling&quot;, June 2005,
                 &amp;lt;&lt;a href=&quot;http://www.watchfire.com/news/whitepapers.aspx&quot;&gt;http://www.watchfire.com/news/whitepapers.aspx&lt;/a&gt;&amp;gt;. 

   [&lt;a id=&quot;ref-RFC1919&quot; name=&quot;ref-RFC1919&quot;&gt;RFC1919&lt;/a&gt;]     Chatel, M., &quot;Classical versus Transparent IP Proxies&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc1919&quot;&gt;RFC 1919&lt;/a&gt;, March 1996.

   [&lt;a id=&quot;ref-RFC1945&quot; name=&quot;ref-RFC1945&quot;&gt;RFC1945&lt;/a&gt;]     Berners-Lee, T., Fielding, R., and H. Nielsen,
                 &quot;Hypertext Transfer Protocol -- HTTP/1.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;,
                 May 1996.

   [&lt;a id=&quot;ref-RFC2045&quot; name=&quot;ref-RFC2045&quot;&gt;RFC2045&lt;/a&gt;]     Freed, N. and N. Borenstein, &quot;Multipurpose Internet
                 Mail Extensions (MIME) Part One: Format of Internet
                 Message Bodies&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;, November 1996.

   [&lt;a id=&quot;ref-RFC2047&quot; name=&quot;ref-RFC2047&quot;&gt;RFC2047&lt;/a&gt;]     Moore, K., &quot;MIME (Multipurpose Internet Mail
                 Extensions) Part Three: Message Header Extensions for
                 Non-ASCII Text&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;, November 1996.

   [&lt;a id=&quot;ref-RFC2068&quot; name=&quot;ref-RFC2068&quot;&gt;RFC2068&lt;/a&gt;]     Fielding, R., Gettys, J., Mogul, J., Nielsen, H., and
                 T. Berners-Lee, &quot;Hypertext Transfer Protocol --
                 HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;, January 1997.

   [&lt;a id=&quot;ref-RFC2145&quot; name=&quot;ref-RFC2145&quot;&gt;RFC2145&lt;/a&gt;]     Mogul, J., Fielding, R., Gettys, J., and H. Nielsen,
                 &quot;Use and Interpretation of HTTP Version Numbers&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;, May 1997.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]     Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
                 Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
                 Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC2817&quot; name=&quot;ref-RFC2817&quot;&gt;RFC2817&lt;/a&gt;]     Khare, R. and S. Lawrence, &quot;Upgrading to TLS Within
                 HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt;, May 2000.

   [&lt;a id=&quot;ref-RFC2818&quot; name=&quot;ref-RFC2818&quot;&gt;RFC2818&lt;/a&gt;]     Rescorla, E., &quot;HTTP Over TLS&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt;, May 2000.

   [&lt;a id=&quot;ref-RFC3040&quot; name=&quot;ref-RFC3040&quot;&gt;RFC3040&lt;/a&gt;]     Cooper, I., Melve, I., and G. Tomlinson, &quot;Internet Web
                 Replication and Caching Taxonomy&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3040&quot;&gt;RFC 3040&lt;/a&gt;,
                 January 2001.

   [&lt;a id=&quot;ref-RFC4033&quot; name=&quot;ref-RFC4033&quot;&gt;RFC4033&lt;/a&gt;]     Arends, R., Austein, R., Larson, M., Massey, D., and S.
                 Rose, &quot;DNS Security Introduction and Requirements&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc4033&quot;&gt;RFC 4033&lt;/a&gt;, March 2005.

   [&lt;a id=&quot;ref-RFC4559&quot; name=&quot;ref-RFC4559&quot;&gt;RFC4559&lt;/a&gt;]     Jaganathan, K., Zhu, L., and J. Brezak, &quot;SPNEGO-based
                 Kerberos and NTLM HTTP Authentication in Microsoft
                 Windows&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4559&quot;&gt;RFC 4559&lt;/a&gt;, June 2006.

   [&lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt;]     Narten, T. and H. Alvestrand, &quot;Guidelines for Writing
                 an IANA Considerations Section in RFCs&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;, May 2008. 

   [&lt;a id=&quot;ref-RFC5246&quot; name=&quot;ref-RFC5246&quot;&gt;RFC5246&lt;/a&gt;]     Dierks, T. and E. Rescorla, &quot;The Transport Layer
                 Security (TLS) Protocol Version 1.2&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt;,
                 August 2008.

   [&lt;a id=&quot;ref-RFC5322&quot; name=&quot;ref-RFC5322&quot;&gt;RFC5322&lt;/a&gt;]     Resnick, P., &quot;Internet Message Format&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;,
                 October 2008.

   [&lt;a id=&quot;ref-RFC6265&quot; name=&quot;ref-RFC6265&quot;&gt;RFC6265&lt;/a&gt;]     Barth, A., &quot;HTTP State Management Mechanism&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;,
                 April 2011.

   [&lt;a id=&quot;ref-RFC6585&quot; name=&quot;ref-RFC6585&quot;&gt;RFC6585&lt;/a&gt;]     Nottingham, M. and R. Fielding, &quot;Additional HTTP Status
                 Codes&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6585&quot;&gt;RFC 6585&lt;/a&gt;, April 2012.</source>
          <target state="translated">[ &lt;a id=&quot;ref-BCP115&quot; name=&quot;ref-BCP115&quot;&gt;BCP115&lt;/a&gt; ] Hansen, T., Hardie, T. 및 L. Masinter, &quot;새로운 URI 체계에 대한 지침 및 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp115&quot;&gt;BCP 115&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc4395&quot;&gt;RFC 4395&lt;/a&gt; , 2006 년 2 월. [ &lt;a id=&quot;ref-BCP13&quot; name=&quot;ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] Freed, N., Klensin, J. 및 T. Hansen, &quot;미디어 유형 사양 및 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt; , 2013 년 1 월. [ &lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] Klyne, G., Nottingham, M. 및 J. Mogul, &quot;메시지 헤더 필드의 등록 절차&quot; , &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt; , 2004 년 9 월. [ &lt;a id=&quot;ref-Georgiev&quot; name=&quot;ref-Georgiev&quot;&gt;Georgiev&lt;/a&gt;] Georgiev, M., Iyengar, S., Jana, S., Anubhai, R., Boneh, D. 및 V. Shmatikov, &quot;세계에서 가장 위험한 코드 : 비 브라우저 소프트웨어에서 SSL 인증서 확인&quot;, 2012 년 컴퓨터 및 통신 보안에 관한 ACM 컨퍼런스 (CCS '12), pp. 38-49, 2012 년 10 월 38, &amp;lt; &lt;a href=&quot;http://doi.acm.org/10.1145/2382196.2382204&quot;&gt;http://doi.acm.org/10.1145/2382196.2382204&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-ISO-8859-1&quot; name=&quot;ref-ISO-8859-1&quot;&gt;ISO-8859-1&lt;/a&gt; ] 국제 표준화기구, &quot;정보 기술-8 비트 1 바이트 코드 그래픽 문자 세트-1 부 : 라틴 알파벳 1 호&quot;, ISO / IEC 8859-1 : 1998, 1998. [ &lt;a id=&quot;ref-Klein&quot; name=&quot;ref-Klein&quot;&gt;클라인&lt;/a&gt;] 클라인, A., &quot;분할 및 정복 - HTTP 응답 분할, 웹 캐시 중독 공격 및 관련 항목&quot;2004 년 3 월, &amp;lt; &lt;a href=&quot;http://packetstormsecurity.com/papers/general/whitepaper_httpresponse.pdf&quot;&gt;http://packetstormsecurity.com/ &lt;/a&gt;&lt;a href=&quot;http://packetstormsecurity.com/papers/general/whitepaper_httpresponse.pdf&quot;&gt;논문 / / whitepaper_httpresponse.pdf 일반&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-Kri2001&quot; name=&quot;ref-Kri2001&quot;&gt;Kri2001&lt;/a&gt; ] Kristol, D., &quot;HTTP 쿠키 : 표준, 개인 정보 및 정치&quot;, 인터넷 기술 1 (2), 2001 년 11 월의 ACM 거래, &amp;lt; &lt;a href=&quot;http://arxiv.org/abs/cs.SE/0105018&quot;&gt;http://arxiv.org/abs/cs.SE/0105018&lt;/a&gt; &amp;gt; . [ &lt;a id=&quot;ref-Linhart&quot; name=&quot;ref-Linhart&quot;&gt;Linhart&lt;/a&gt; ] Linhart, C., Klein, A., Heled, R. 및 S. Orrin, &quot;HTTP 요청 밀수&quot;, 2005 년 6 월, &amp;lt; &lt;a href=&quot;http://www.watchfire.com/news/whitepapers.aspx&quot;&gt;http://www.watchfire.com/news/whitepapers.aspx&lt;/a&gt; &amp;gt;.[ &lt;a id=&quot;ref-RFC1919&quot; name=&quot;ref-RFC1919&quot;&gt;RFC1919&lt;/a&gt;] Chatel, M., &quot;클래식 및 투명 IP 프록시&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1919&quot;&gt;RFC 1919&lt;/a&gt; , 1996 년 3 월. [ &lt;a id=&quot;ref-RFC1945&quot; name=&quot;ref-RFC1945&quot;&gt;RFC1945&lt;/a&gt; ] Berners-Lee, T., Fielding, R. 및 H. Nielsen, &quot;하이퍼 텍스트 전송 프로토콜-HTTP / 1.0&quot; , &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; , 1996 년 5 월. [ &lt;a id=&quot;ref-RFC2045&quot; name=&quot;ref-RFC2045&quot;&gt;RFC2045&lt;/a&gt; ] Free, N. 및 N. Borenstein, &quot;MIME (Multipurpose Internet Mail Extensions) 1 부 : 인터넷 메시지 본문 형식&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; , 1996 년 11 월. [ &lt;a id=&quot;ref-RFC2047&quot; name=&quot;ref-RFC2047&quot;&gt;RFC2047&lt;/a&gt; ] Moore, K. , &quot;MIME (Multipurpose Internet Mail Extensions) 3 부 : 비 ASCII 텍스트에 대한 메시지 헤더 확장&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; , 1996 년 11 월.[&lt;a id=&quot;ref-RFC2068&quot; name=&quot;ref-RFC2068&quot;&gt;RFC2068&lt;/a&gt; ] Fielding, R., Gettys, J., Mogul, J., Nielsen, H. 및 T. Berners-Lee, &quot;Hypertext Transfer Protocol-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; , 1997 년 1 월. [ &lt;a id=&quot;ref-RFC2145&quot; name=&quot;ref-RFC2145&quot;&gt;RFC2145&lt;/a&gt; ] Mogul , J., Fielding, R., Gettys, J. 및 H. Nielsen, &quot;HTTP 버전 번호 사용 및 해석&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; , 1997 년 5 월. [ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt; ] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. 및 T. Berners-Lee, &quot;하이퍼 텍스트 전송 프로토콜-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC2817&quot; name=&quot;ref-RFC2817&quot;&gt;RFC2817&lt;/a&gt; ] Khare, R. and 로렌스, &quot;HTTP / 1.1 내에서 TLS로 업그레이드&quot;,&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt; , 2000 년 5 월. [ &lt;a id=&quot;ref-RFC2818&quot; name=&quot;ref-RFC2818&quot;&gt;RFC2818&lt;/a&gt; ] Rescorla , E., &quot;HTTP Over TLS&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt; , 2000 년 5 월. [ &lt;a id=&quot;ref-RFC3040&quot; name=&quot;ref-RFC3040&quot;&gt;RFC3040&lt;/a&gt; ] Cooper, I., Melve, I. 및 G. Tomlinson, &quot;인터넷 웹 복제 및 캐싱 분류 &lt;a id=&quot;ref-RFC4033&quot; name=&quot;ref-RFC4033&quot;&gt;체계&lt;/a&gt; &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3040&quot;&gt;RFC 3040&lt;/a&gt; , 2001 년 1 월. [ RFC4033 ] Arends, R., Austein, R., Larson, M., Massey, D. 및 S. Rose,&quot;DNS 보안 소개 및 요구 사항 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4033&quot;&gt;RFC 4033&lt;/a&gt; , 2005 년 3 월 [ &lt;a id=&quot;ref-RFC4559&quot; name=&quot;ref-RFC4559&quot;&gt;RFC4559&lt;/a&gt; ] Jaganathan, K., Zhu, L. 및 J. Brezak, &quot;Microsoft Windows의 SPNEGO 기반 Kerberos 및 NTLM HTTP 인증&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4559&quot;&gt;RFC 4559&lt;/a&gt;[ &lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt; ] Narten, T. 및 H. Alvestrand, &quot;RFC에 IANA 고려 사항 섹션 작성 지침&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt; , 2008 년 5 월. [ &lt;a id=&quot;ref-RFC5246&quot; name=&quot;ref-RFC5246&quot;&gt;RFC5246&lt;/a&gt; ] Dierks, T. 및 E. Rescorla , &quot; TLS (Transport Layer Security) 프로토콜 버전 1.2 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt; , 2008 년 8 월. [ &lt;a id=&quot;ref-RFC5322&quot; name=&quot;ref-RFC5322&quot;&gt;RFC5322&lt;/a&gt; ] Resnick, P.,&quot;인터넷 메시지 형식 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; , 2008 년 10 월. [ &lt;a id=&quot;ref-RFC6265&quot; name=&quot;ref-RFC6265&quot;&gt;RFC6265&lt;/a&gt; ] Barth, A.,&quot;HTTP 상태 관리 메커니즘 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt; , 2011 년 4 월. [ &lt;a id=&quot;ref-RFC6585&quot; name=&quot;ref-RFC6585&quot;&gt;RFC6585&lt;/a&gt;] Nottingham, M. 및 R. Fielding, &quot;추가 HTTP 상태 코드&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6585&quot;&gt;RFC 6585&lt;/a&gt; , 2012 년 4 월.</target>
        </trans-unit>
        <trans-unit id="709bdcb38d1223b2efcf9537053ac448ee82c675" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-BCP13&quot; name=&quot;ref-BCP13&quot;&gt;BCP13&lt;/a&gt;]    Freed, N., Klensin, J., and T. Hansen, &quot;Media Type
              Specifications and Registration Procedures&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt;, January 2013.

   [&lt;a id=&quot;ref-BCP178&quot; name=&quot;ref-BCP178&quot;&gt;BCP178&lt;/a&gt;]   Saint-Andre, P., Crocker, D., and M. Nottingham,
              &quot;Deprecating the &quot;X-&quot; Prefix and Similar Constructs in
              Application Protocols&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp178&quot;&gt;BCP 178&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6648&quot;&gt;RFC 6648&lt;/a&gt;, June 2012. 

   [&lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]    Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
              Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;,
              September 2004.

   [&lt;a id=&quot;ref-OWASP&quot; name=&quot;ref-OWASP&quot;&gt;OWASP&lt;/a&gt;]    van der Stock, A., Ed., &quot;A Guide to Building Secure Web
              Applications and Web Services&quot;, The Open Web Application
              Security Project (OWASP) 2.0.1, July 2005,
              &amp;lt;&lt;a href=&quot;https://www.owasp.org/&quot;&gt;https://www.owasp.org/&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REST&quot; name=&quot;ref-REST&quot;&gt;REST&lt;/a&gt;]     Fielding, R., &quot;Architectural Styles and the Design of
              Network-based Software Architectures&quot;,
              Doctoral Dissertation, University of California, Irvine,
              September 2000,
              &amp;lt;&lt;a href=&quot;http://roy.gbiv.com/pubs/dissertation/top.htm&quot;&gt;http://roy.gbiv.com/pubs/dissertation/top.htm&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC1945&quot; name=&quot;ref-RFC1945&quot;&gt;RFC1945&lt;/a&gt;]  Berners-Lee, T., Fielding, R., and H. Nielsen, &quot;Hypertext
              Transfer Protocol -- HTTP/1.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-RFC2049&quot; name=&quot;ref-RFC2049&quot;&gt;RFC2049&lt;/a&gt;]  Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
              Extensions (MIME) Part Five: Conformance Criteria and
              Examples&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2049&quot;&gt;RFC 2049&lt;/a&gt;, November 1996.

   [&lt;a id=&quot;ref-RFC2068&quot; name=&quot;ref-RFC2068&quot;&gt;RFC2068&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Nielsen, H., and T.
              Berners-Lee, &quot;Hypertext Transfer Protocol -- HTTP/1.1&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;, January 1997.

   [&lt;a id=&quot;ref-RFC2295&quot; name=&quot;ref-RFC2295&quot;&gt;RFC2295&lt;/a&gt;]  Holtman, K. and A. Mutz, &quot;Transparent Content Negotiation
              in HTTP&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;RFC 2295&lt;/a&gt;, March 1998.

   [&lt;a id=&quot;ref-RFC2388&quot; name=&quot;ref-RFC2388&quot;&gt;RFC2388&lt;/a&gt;]  Masinter, L., &quot;Returning Values from Forms:  multipart/
              form-data&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2388&quot;&gt;RFC 2388&lt;/a&gt;, August 1998.

   [&lt;a id=&quot;ref-RFC2557&quot; name=&quot;ref-RFC2557&quot;&gt;RFC2557&lt;/a&gt;]  Palme, F., Hopmann, A., Shelness, N., and E. Stefferud,
              &quot;MIME Encapsulation of Aggregate Documents, such as HTML
              (MHTML)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2557&quot;&gt;RFC 2557&lt;/a&gt;, March 1999.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC2774&quot; name=&quot;ref-RFC2774&quot;&gt;RFC2774&lt;/a&gt;]  Frystyk, H., Leach, P., and S. Lawrence, &quot;An HTTP
              Extension Framework&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC 2774&lt;/a&gt;, February 2000.

   [&lt;a id=&quot;ref-RFC2817&quot; name=&quot;ref-RFC2817&quot;&gt;RFC2817&lt;/a&gt;]  Khare, R. and S. Lawrence, &quot;Upgrading to TLS Within
              HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt;, May 2000.

   [&lt;a id=&quot;ref-RFC2978&quot; name=&quot;ref-RFC2978&quot;&gt;RFC2978&lt;/a&gt;]  Freed, N. and J. Postel, &quot;IANA Charset Registration
              Procedures&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp19&quot;&gt;BCP 19&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC 2978&lt;/a&gt;, October 2000. 

   [&lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt;]  Narten, T. and H. Alvestrand, &quot;Guidelines for Writing an
              IANA Considerations Section in RFCs&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;,
              May 2008.

   [&lt;a id=&quot;ref-RFC5246&quot; name=&quot;ref-RFC5246&quot;&gt;RFC5246&lt;/a&gt;]  Dierks, T. and E. Rescorla, &quot;The Transport Layer Security
              (TLS) Protocol Version 1.2&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt;, August 2008.

   [&lt;a id=&quot;ref-RFC5322&quot; name=&quot;ref-RFC5322&quot;&gt;RFC5322&lt;/a&gt;]  Resnick, P., &quot;Internet Message Format&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;,
              October 2008.

   [&lt;a id=&quot;ref-RFC5789&quot; name=&quot;ref-RFC5789&quot;&gt;RFC5789&lt;/a&gt;]  Dusseault, L. and J. Snell, &quot;PATCH Method for HTTP&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC 5789&lt;/a&gt;, March 2010.

   [&lt;a id=&quot;ref-RFC5905&quot; name=&quot;ref-RFC5905&quot;&gt;RFC5905&lt;/a&gt;]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,
              &quot;Network Time Protocol Version 4: Protocol and Algorithms
              Specification&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC 5905&lt;/a&gt;, June 2010.

   [&lt;a id=&quot;ref-RFC5987&quot; name=&quot;ref-RFC5987&quot;&gt;RFC5987&lt;/a&gt;]  Reschke, J., &quot;Character Set and Language Encoding for
              Hypertext Transfer Protocol (HTTP) Header Field
              Parameters&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987&lt;/a&gt;, August 2010.

   [&lt;a id=&quot;ref-RFC5988&quot; name=&quot;ref-RFC5988&quot;&gt;RFC5988&lt;/a&gt;]  Nottingham, M., &quot;Web Linking&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5988&quot;&gt;RFC 5988&lt;/a&gt;, October 2010.

   [&lt;a id=&quot;ref-RFC6265&quot; name=&quot;ref-RFC6265&quot;&gt;RFC6265&lt;/a&gt;]  Barth, A., &quot;HTTP State Management Mechanism&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;,
              April 2011.

   [&lt;a id=&quot;ref-RFC6266&quot; name=&quot;ref-RFC6266&quot;&gt;RFC6266&lt;/a&gt;]  Reschke, J., &quot;Use of the Content-Disposition Header Field
              in the Hypertext Transfer Protocol (HTTP)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6266&quot;&gt;RFC 6266&lt;/a&gt;,
              June 2011.

   [&lt;a id=&quot;ref-RFC7238&quot; name=&quot;ref-RFC7238&quot;&gt;RFC7238&lt;/a&gt;]  Reschke, J., &quot;The Hypertext Transfer Protocol (HTTP)
              Status Code 308 (Permanent Redirect)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7238&quot;&gt;RFC 7238&lt;/a&gt;,
              June 2014.</source>
          <target state="translated">[ &lt;a id=&quot;ref-BCP13&quot; name=&quot;ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] Free , N., Klensin, J. 및 T. Hansen, &quot;미디어 유형 사양 및 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt; , 2013 년 1 월. [ &lt;a id=&quot;ref-BCP178&quot; name=&quot;ref-BCP178&quot;&gt;BCP178&lt;/a&gt; ] Saint-Andre, P., Crocker, D. 및 M. Nottingham, &quot;응용 프로그램 프로토콜에서&quot;X- &quot;접두사 및 유사한 &lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;구문 사용 중단&lt;/a&gt; &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp178&quot;&gt;BCP 178&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc6648&quot;&gt;RFC 6648&lt;/a&gt; , 2012 년 6 월. [ BCP90 ] Klyne, G., Nottingham, M. 및 J. Mogul, &quot; 메시지 헤더 필드의 등록 절차 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt; , 2004 년 9 월. [ &lt;a id=&quot;ref-OWASP&quot; name=&quot;ref-OWASP&quot;&gt;OWASP&lt;/a&gt;] van der Stock, A., Ed., &quot;보안 웹 응용 프로그램 및 웹 서비스 구축 안내서&quot;, OWASP (Open Web Application Security Project) 2.0.1, 2005 년 7 월, &amp;lt; &lt;a href=&quot;https://www.owasp.org/&quot;&gt;https://www.owasp.org /&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-REST&quot; name=&quot;ref-REST&quot;&gt;REST&lt;/a&gt; ] Fielding, R., &quot;건축 스타일 및 네트워크 기반 소프트웨어 아키텍처의 설계&quot;, 캘리포니아 대학교, 박사 학위 논문, Irvine, 2000 년 9 월, &amp;lt; &lt;a href=&quot;http://roy.gbiv.com/pubs/dissertation/top.htm&quot;&gt;http://roy.gbiv.com/pubs/dissertation/top .htm&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-RFC1945&quot; name=&quot;ref-RFC1945&quot;&gt;RFC1945&lt;/a&gt; ] Berners-Lee, T., Fielding, R. 및 H. Nielsen, &quot;하이퍼 텍스트 전송 프로토콜-HTTP / 1.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; , 1996 년 5 월. [ &lt;a id=&quot;ref-RFC2049&quot; name=&quot;ref-RFC2049&quot;&gt;RFC2049&lt;/a&gt;] Freed, N. 및 N. Borenstein, &quot;MIME (Multipurpose Internet Mail Extensions) 5 부 : 적합성 기준 및 예&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2049&quot;&gt;RFC 2049&lt;/a&gt; , 1996 년 11 월. [ &lt;a id=&quot;ref-RFC2068&quot; name=&quot;ref-RFC2068&quot;&gt;RFC2068&lt;/a&gt; ] Fielding, R., Gettys, J., Mogul, J. , Nielsen, H. 및 T. Berners-Lee, &quot;Hypertext Transfer Protocol-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; , 1997 년 1 월. [ &lt;a id=&quot;ref-RFC2295&quot; name=&quot;ref-RFC2295&quot;&gt;RFC2295&lt;/a&gt; ] Holtman, K. 및 A. Mutz, &quot;HTTP의 투명 콘텐츠 협상&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;RFC 2295&lt;/a&gt; , 1998 년 3 월. [ &lt;a id=&quot;ref-RFC2388&quot; name=&quot;ref-RFC2388&quot;&gt;RFC2388&lt;/a&gt; ] Masinter, L., &quot;양식에서 값 반환 : 다중 부품 / 양식 데이터&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2388&quot;&gt;RFC 2388&lt;/a&gt; , 1998 년 8 월. [ &lt;a id=&quot;ref-RFC2557&quot; name=&quot;ref-RFC2557&quot;&gt;RFC2557&lt;/a&gt;] Palme, F., Hopmann, A., Shelness, N. 및 E. Stefferud, &quot;HTML (MHTML)과 같은 집계 문서의 MIME 캡슐화&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2557&quot;&gt;RFC 2557&lt;/a&gt; , 1999 년 3 월. [ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt; ] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. 및 T. Berners-Lee, &quot;Hypertext Transfer Protocol-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC2774&quot; name=&quot;ref-RFC2774&quot;&gt;RFC2774&lt;/a&gt; ] Frystyk, H., Leach, P. 및 S. Lawrence, &quot;HTTP 확장 프레임 워크&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC 2774&lt;/a&gt; , 2000 년 2 월. [ &lt;a id=&quot;ref-RFC2817&quot; name=&quot;ref-RFC2817&quot;&gt;RFC2817&lt;/a&gt; ] Khare, R. 및 S. Lawrence, &quot;HTTP / 1.1 내에서 TLS로 업그레이드 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt; , 2000 년 5 월. [ &lt;a id=&quot;ref-RFC2978&quot; name=&quot;ref-RFC2978&quot;&gt;RFC2978&lt;/a&gt;] Freed, N. 및 J. Postel, &quot;IANA &lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;문자 세트&lt;/a&gt; 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp19&quot;&gt;BCP 19&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC 2978&lt;/a&gt; , 2000 년 10 월. [ RFC5226 ] Narten, T. 및 H. Alvestrand, &quot;RFC에서 IANA 고려 사항 섹션 작성 지침&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt; , 2008 년 5 월. [ &lt;a id=&quot;ref-RFC5246&quot; name=&quot;ref-RFC5246&quot;&gt;RFC5246&lt;/a&gt; ] Dierks, T. 및 E. Rescorla , &quot;TLS (Transport Layer Security) 프로토콜 버전 1.2&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt; , 2008 년 8 월. [ &lt;a id=&quot;ref-RFC5322&quot; name=&quot;ref-RFC5322&quot;&gt;RFC5322&lt;/a&gt; ] Resnick, P., &quot;Internet 메시지 형식 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; , 2008 년 10 월. [ &lt;a id=&quot;ref-RFC5789&quot; name=&quot;ref-RFC5789&quot;&gt;RFC5789&lt;/a&gt;] Dusseault, L. 및 J. Snell, &quot;HTTP 용 패치 방법&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC 5789&lt;/a&gt; , 2010 년 3 월. [ &lt;a id=&quot;ref-RFC5905&quot; name=&quot;ref-RFC5905&quot;&gt;RFC5905&lt;/a&gt; ] Mills, D., Martin, J., Ed., Burbank, J. 및 W. Kasch, &quot; 네트워크 시간 프로토콜 버전 4 : 프로토콜 및 알고리즘 사양 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC 5905&lt;/a&gt; , 2010 년 6 월. [ &lt;a id=&quot;ref-RFC5987&quot; name=&quot;ref-RFC5987&quot;&gt;RFC5987&lt;/a&gt; ] Reschke, J.,&quot;HTTP (Hypertext Transfer Protocol) 헤더 필드 매개 변수의 문자 세트 및 언어 인코딩 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987&lt;/a&gt; , 2010 년 8 월. [ &lt;a id=&quot;ref-RFC5988&quot; name=&quot;ref-RFC5988&quot;&gt;RFC5988&lt;/a&gt; ] Nottingham, M., &quot;웹 링크&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5988&quot;&gt;RFC 5988&lt;/a&gt; , 2010 년 10 월. [ &lt;a id=&quot;ref-RFC6265&quot; name=&quot;ref-RFC6265&quot;&gt;RFC6265&lt;/a&gt; ] Barth, A., &quot;HTTP 상태 관리 메커니즘&quot;,&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;[ &lt;a id=&quot;ref-RFC6266&quot; name=&quot;ref-RFC6266&quot;&gt;RFC6266&lt;/a&gt; ] Reschke, J., &quot;HTTP (Hypertext Transfer Protocol)에서 콘텐츠 처리 헤더 필드 사용&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6266&quot;&gt;RFC 6266&lt;/a&gt; , 2011 년 6 월. [ &lt;a id=&quot;ref-RFC7238&quot; name=&quot;ref-RFC7238&quot;&gt;RFC7238&lt;/a&gt; ] Reschke, J., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP) 상태 코드 308 (영구적 리디렉션) &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7238&quot;&gt;RFC 7238&lt;/a&gt; , 2014 년 6 월.</target>
        </trans-unit>
        <trans-unit id="188dbbf80aeecdc21816591c6751af6f215cfa89" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-BCP13&quot; name=&quot;ref-BCP13&quot;&gt;BCP13&lt;/a&gt;]    Freed, N., Klensin, J., and T. Hansen, &quot;Media Type
              Specifications and Registration Procedures&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt;, January 2013.

   [&lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]    Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
              Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;,
              September 2004.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt;]  Narten, T. and H. Alvestrand, &quot;Guidelines for Writing an
              IANA Considerations Section in RFCs&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;,
              May 2008.</source>
          <target state="translated">[ &lt;a id=&quot;ref-BCP13&quot; name=&quot;ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] Free , N., Klensin, J. 및 T. Hansen, &quot;미디어 유형 사양 및 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt; , 2013 년 1 월. [ &lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] Klyne, G., Nottingham, M. 및 J. Mogul, &quot;메시지 헤더 필드의 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt; , 2004 년 9 월. [ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt; ] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. 및 T. Berners-Lee, &quot;하이퍼 텍스트 전송 프로토콜-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt;] Narten, T. 및 H. Alvestrand, &quot;RFC에 IANA 고려 사항 섹션 작성 지침&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt; , 2008 년 5 월.</target>
        </trans-unit>
        <trans-unit id="73a151d5cd044c04e47c30098a4884b545c7d743" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]    Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
              Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;,
              September 2004.

   [&lt;a id=&quot;ref-OWASP&quot; name=&quot;ref-OWASP&quot;&gt;OWASP&lt;/a&gt;]    van der Stock, A., Ed., &quot;A Guide to Building Secure Web
              Applications and Web Services&quot;, The Open Web Application
              Security Project (OWASP) 2.0.1, July 2005,
              &amp;lt;&lt;a href=&quot;https://www.owasp.org/&quot;&gt;https://www.owasp.org/&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999. 

   [&lt;a id=&quot;ref-RFC2617&quot; name=&quot;ref-RFC2617&quot;&gt;RFC2617&lt;/a&gt;]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
              Leach, P., Luotonen, A., and L. Stewart, &quot;HTTP
              Authentication: Basic and Digest Access Authentication&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt;]  Berners-Lee, T., Fielding, R., and L. Masinter, &quot;Uniform
              Resource Identifier (URI): Generic Syntax&quot;, STD 66,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;, January 2005.

   [&lt;a id=&quot;ref-RFC4648&quot; name=&quot;ref-RFC4648&quot;&gt;RFC4648&lt;/a&gt;]  Josefsson, S., &quot;The Base16, Base32, and Base64 Data
              Encodings&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC 4648&lt;/a&gt;, October 2006.

   [&lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt;]  Narten, T. and H. Alvestrand, &quot;Guidelines for Writing an
              IANA Considerations Section in RFCs&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;,
              May 2008.

   [&lt;a id=&quot;ref-RFC5246&quot; name=&quot;ref-RFC5246&quot;&gt;RFC5246&lt;/a&gt;]  Dierks, T. and E. Rescorla, &quot;The Transport Layer Security
              (TLS) Protocol Version 1.2&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt;, August 2008.</source>
          <target state="translated">[ &lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] Klyne, G., Nottingham, M. 및 J. Mogul, &quot;메시지 헤더 필드의 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt; , 2004 년 9 월. [ &lt;a id=&quot;ref-OWASP&quot; name=&quot;ref-OWASP&quot;&gt;OWASP&lt;/a&gt; ] van der Stock, A., Ed., &quot; 안전한 웹 응용 프로그램 및 웹 서비스 구축 안내서 &quot;, 2005 년 7 월 OWASP (Open Web Application Security Project) 2.0.1, &amp;lt; &lt;a href=&quot;https://www.owasp.org/&quot;&gt;https://www.owasp.org/&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt; ] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. 및 T. Berners-Lee, &quot;하이퍼 텍스트 전송 프로토콜-HTTP / 1.1&quot; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC2617&quot; name=&quot;ref-RFC2617&quot;&gt;RFC2617&lt;/a&gt;] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A. 및 L. Stewart, &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt; ] Berners-Lee, T., Fielding, R. 및 L. Masinter, &quot;Uniform Resource Identifier (URI) : Generic Syntax&quot;, STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; , 2005 년 1 월. [ &lt;a id=&quot;ref-RFC4648&quot; name=&quot;ref-RFC4648&quot;&gt;RFC4648&lt;/a&gt; ] Josefsson , S., &quot;Base16, Base32 및 Base64 데이터 인코딩&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC 4648&lt;/a&gt; , 2006 년 10 월. [ &lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt; ] Narten, T. 및 H. Alvestrand, &quot;RFC의 IANA 고려 사항 섹션 작성 지침&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt; ,&lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt; , 2008 년 5 월. [ &lt;a id=&quot;ref-RFC5246&quot; name=&quot;ref-RFC5246&quot;&gt;RFC5246&lt;/a&gt; ] Dierks, T. 및 E. Rescorla , &quot;TLS (Transport Layer Security) 프로토콜 버전 1.2&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt; , 2008 년 8 월.</target>
        </trans-unit>
        <trans-unit id="68349d0417ea59a9fce1a54293548f5d71f13c68" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]    Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
              Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;,
              September 2004.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC4918&quot; name=&quot;ref-RFC4918&quot;&gt;RFC4918&lt;/a&gt;]  Dusseault, L., Ed., &quot;HTTP Extensions for Web Distributed
              Authoring and Versioning (WebDAV)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC 4918&lt;/a&gt;, June 2007.</source>
          <target state="translated">[ &lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] Klyne, G., Nottingham, M. 및 J. Mogul, &quot;메시지 헤더 필드의 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt; , 2004 년 9 월. [ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt; ] Fielding, R., Gettys, J., Mogul , J., Frystyk, H., Masinter, L., Leach, P. 및 T. Berners-Lee, &quot;Hypertext Transfer Protocol-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC4918&quot; name=&quot;ref-RFC4918&quot;&gt;RFC4918&lt;/a&gt; ] Dusseault, L. , Ed., &quot;WebDAV (Web Distributed Authoring and Versioning)를위한 HTTP 확장&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC 4918&lt;/a&gt; , 2007 년 6 월.</target>
        </trans-unit>
        <trans-unit id="de3ead8edc0a72f563112dfbf128ce107b02bbff" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]    Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
              Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;,
              September 2004.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt;]  Narten, T. and H. Alvestrand, &quot;Guidelines for Writing an
              IANA Considerations Section in RFCs&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;,
              May 2008.

   [&lt;a id=&quot;ref-RFC5861&quot; name=&quot;ref-RFC5861&quot;&gt;RFC5861&lt;/a&gt;]  Nottingham, M., &quot;HTTP Cache-Control Extensions for Stale
              Content&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5861&quot;&gt;RFC 5861&lt;/a&gt;, April 2010.

   [&lt;a id=&quot;ref-RFC5905&quot; name=&quot;ref-RFC5905&quot;&gt;RFC5905&lt;/a&gt;]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,
              &quot;Network Time Protocol Version 4: Protocol and Algorithms
              Specification&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC 5905&lt;/a&gt;, June 2010.

   [&lt;a id=&quot;ref-RFC6265&quot; name=&quot;ref-RFC6265&quot;&gt;RFC6265&lt;/a&gt;]  Barth, A., &quot;HTTP State Management Mechanism&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;,
              April 2011.</source>
          <target state="translated">[ &lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] Klyne, G., Nottingham, M. 및 J. Mogul, &quot;메시지 헤더 필드의 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt; , 2004 년 9 월. [ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt; ] Fielding, R., Gettys, J., Mogul , J., Frystyk, H., Masinter, L., Leach, P. 및 T. Berners-Lee, &quot;Hypertext Transfer Protocol-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt; ] Narten, T. 및 H. Alvestrand, &quot;RFC에 IANA 고려 사항 섹션 작성 지침&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt; , 2008 년 5 월. [ &lt;a id=&quot;ref-RFC5861&quot; name=&quot;ref-RFC5861&quot;&gt;RFC5861&lt;/a&gt;] Nottingham, M., &quot;부실 콘텐츠에 대한 HTTP 캐시 제어 확장&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5861&quot;&gt;RFC 5861&lt;/a&gt; , 2010 년 4 월. [ &lt;a id=&quot;ref-RFC5905&quot; name=&quot;ref-RFC5905&quot;&gt;RFC5905&lt;/a&gt; ] Mills, D., Martin, J., Ed., Burbank, J. 및 W. Kasch, &quot; 네트워크 시간 프로토콜 버전 4 : 프로토콜 및 알고리즘 사양 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC 5905&lt;/a&gt; , 2010 년 6 월. [ &lt;a id=&quot;ref-RFC6265&quot; name=&quot;ref-RFC6265&quot;&gt;RFC6265&lt;/a&gt; ] Barth, A.,&quot;HTTP 상태 관리 메커니즘 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt; , 2011 년 4 월.</target>
        </trans-unit>
        <trans-unit id="be465035882a640817e7c019d9758fba1f0298fa" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-NOTE-detect-lost-update&quot; name=&quot;ref-NOTE-detect-lost-update&quot;&gt;NOTE-detect-lost-update&lt;/a&gt;]
              Nielsen, H. and D. LaLiberte, &quot;Editing the Web: Detecting
              the Lost Update Problem Using Unreserved Checkout&quot;, World
              Wide Web Consortium NOTE NOTE-detect-lost-update, May
              1999, &amp;lt;&lt;a href=&quot;http://www.w3.org/1999/04/Editing/&quot;&gt;http://www.w3.org/1999/04/Editing/&lt;/a&gt;&amp;gt;. 

   [&lt;a id=&quot;ref-REC-webarch&quot; name=&quot;ref-REC-webarch&quot;&gt;REC-webarch&lt;/a&gt;]
              Walsh, N. and I. Jacobs, &quot;Architecture of the World Wide
              Web, Volume One&quot;, W3C REC REC-webarch-20041215, December
              2004, &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2004/REC-webarch-20041215&quot;&gt;http://www.w3.org/TR/2004/REC-webarch-20041215&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RNC&quot; name=&quot;ref-RNC&quot;&gt;RNC&lt;/a&gt;]      Clark, J., &quot;RELAX NG Compact Syntax&quot;, December 2001,
              &amp;lt;&lt;a href=&quot;http://www.oasis-open.org/committees/relax-ng/compact-20021121.html&quot;&gt;http://www.oasis-open.org/committees/relax-ng/&lt;/a&gt;&lt;a href=&quot;http://www.oasis-open.org/committees/relax-ng/compact-20021121.html&quot;&gt;compact-20021121.html&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">[ &lt;a id=&quot;ref-NOTE-detect-lost-update&quot; name=&quot;ref-NOTE-detect-lost-update&quot;&gt;NOTE-detect-lost-update&lt;/a&gt; ] Nielsen, H. 및 D. LaLiberte, &quot;웹 편집 : 예약되지 않은 체크 아웃을 사용한 손실 된 업데이트 문제 감지&quot;, 월드 와이드 웹 컨소시엄 NOTE NOTE-detect-lost-update, 1999 년 5 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/1999/04/Editing/&quot;&gt;http://www.w3.org/1999/04/Editing/&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-REC-webarch&quot; name=&quot;ref-REC-webarch&quot;&gt;REC-webarch&lt;/a&gt; ] Walsh, N. 및 I. Jacobs, &quot;World Wide Web의 아키텍처, 볼륨 1&quot;, W3C REC REC-webarch-20041215, 2004 년 12 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2004/REC-webarch-20041215&quot;&gt;http://www.w3.org/TR/ 2004 / REC-webarch-20041215&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-RNC&quot; name=&quot;ref-RNC&quot;&gt;RNC&lt;/a&gt; ] Clark, J., &quot;RELAX NG Compact Syntax&quot;, 2001 년 12 월, &amp;lt; &lt;a href=&quot;http://www.oasis-open.org/committees/relax-ng/compact-20021121.html&quot;&gt;http://www.oasis-open.org/committees/relax-ng/ &lt;/a&gt;&lt;a href=&quot;http://www.oasis-open.org/committees/relax-ng/compact-20021121.html&quot;&gt;compact-20021121.html&lt;/a&gt;&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="9b0101cca3163bcad6c18b71db53c2de9c25f26c" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-REC-XML&quot; name=&quot;ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;]          Bray, T., Paoli, J., Sperberg-McQueen, C., Maler,
                      E., and F. Yergeau, &quot;Extensible Markup Language
                      (XML) 1.0 (Fourth Edition)&quot;, W3C REC-xml-20060816,
                      August 2006,
                      &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-20060816/&quot;&gt;http://www.w3.org/TR/2006/REC-xml-20060816/&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-XML-INFOSET&quot; name=&quot;ref-REC-XML-INFOSET&quot;&gt;REC-XML-INFOSET&lt;/a&gt;]  Cowan, J. and R. Tobin, &quot;XML Information Set
                      (Second Edition)&quot;, W3C REC-xml-infoset-20040204,
                      February 2004, &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-infoset-20040204/&quot;&gt;http://www.w3.org/TR/2004/&lt;/a&gt;&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-infoset-20040204/&quot;&gt;REC-xml-infoset-20040204/&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-XML-NAMES&quot; name=&quot;ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;]    Bray, T., Hollander, D., Layman, A., and R. Tobin,
                      &quot;Namespaces in XML 1.0 (Second Edition)&quot;, W3C REC-
                      xml-names-20060816, August 2006, &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-names-20060816/&quot;&gt;http://&lt;/a&gt;&lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-names-20060816/&quot;&gt;www.w3.org/TR/2006/REC-xml-names-20060816/&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]          Bradner, S., &quot;Key words for use in RFCs to
                      Indicate Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;,
                      March 1997.

   [&lt;a id=&quot;ref-RFC2277&quot; name=&quot;ref-RFC2277&quot;&gt;RFC2277&lt;/a&gt;]          Alvestrand, H., &quot;IETF Policy on Character Sets and
                      Languages&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp18&quot;&gt;BCP 18&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2277&quot;&gt;RFC 2277&lt;/a&gt;, January 1998.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]          Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
                      Masinter, L., Leach, P., and T. Berners-Lee,
                      &quot;Hypertext Transfer Protocol -- HTTP/1.1&quot;,
                      &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999. 

   [&lt;a id=&quot;ref-RFC2617&quot; name=&quot;ref-RFC2617&quot;&gt;RFC2617&lt;/a&gt;]          Franks, J., Hallam-Baker, P., Hostetler, J.,
                      Lawrence, S., Leach, P., Luotonen, A., and L.
                      Stewart, &quot;HTTP Authentication: Basic and Digest
                      Access Authentication&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC3339&quot; name=&quot;ref-RFC3339&quot;&gt;RFC3339&lt;/a&gt;]          Klyne, G., Ed. and C. Newman, &quot;Date and Time on
                      the Internet: Timestamps&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3339&quot;&gt;RFC 3339&lt;/a&gt;, July 2002.

   [&lt;a id=&quot;ref-RFC3629&quot; name=&quot;ref-RFC3629&quot;&gt;RFC3629&lt;/a&gt;]          Yergeau, F., &quot;UTF-8, a transformation format of
                      ISO 10646&quot;, STD 63, &lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC 3629&lt;/a&gt;, November 2003.

   [&lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt;]          Berners-Lee, T., Fielding, R., and L. Masinter,
                      &quot;Uniform Resource Identifier (URI): Generic
                      Syntax&quot;, STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;, January 2005.

   [&lt;a id=&quot;ref-RFC4122&quot; name=&quot;ref-RFC4122&quot;&gt;RFC4122&lt;/a&gt;]          Leach, P., Mealling, M., and R. Salz, &quot;A
                      Universally Unique IDentifier (UUID) URN
                      Namespace&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC 4122&lt;/a&gt;, July 2005.</source>
          <target state="translated">[ &lt;a id=&quot;ref-REC-XML&quot; name=&quot;ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt; ] Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E. 및 F. Yergeau, &quot;Extensible Markup Language (XML) 1.0 (Fourth Edition)&quot;, W3C REC-xml -20060816, 2006 년 8 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-20060816/&quot;&gt;http://www.w3.org/TR/2006/REC-xml-20060816/&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-REC-XML-INFOSET&quot; name=&quot;ref-REC-XML-INFOSET&quot;&gt;REC-XML-INFOSET&lt;/a&gt; ] Cowan, J. 및 R. Tobin, &quot;XML 정보 세트 (제 2 판)&quot;, W3C REC-xml-infoset-20040204, 2004 년 2 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-infoset-20040204/&quot;&gt;http://www.w3.org/TR / 2004 / &lt;/a&gt;&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-infoset-20040204/&quot;&gt;REC-xml-infoset-20040204 /&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-REC-XML-NAMES&quot; name=&quot;ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;] Bray, T., Hollander, D., Layman, A. 및 R. Tobin, &quot;XML 1.0의 네임 스페이스 (제 2 판)&quot;, W3C REC- xml-names-20060816, 2006 년 8 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-names-20060816/&quot;&gt;http : // &lt;/a&gt;&lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-names-20060816/&quot;&gt;www .w3.org / TR / 2006 / REC-xml-names-20060816 /&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner, S., &quot;요구 사항 수준을 &lt;a id=&quot;ref-RFC2277&quot; name=&quot;ref-RFC2277&quot;&gt;나타내는&lt;/a&gt; RFC에 사용되는 키워드 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; , 1997 년 3 월. [ RFC2277 ] Alvestrand, H., &quot;문자 세트 및 언어에 대한 IETF 정책&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp18&quot;&gt;BCP 18&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2277&quot;&gt;RFC 2277&lt;/a&gt; , 1998 년 1 월. [ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. 및 T. Berners-Lee, &quot;Hypertext Transfer Protocol-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; , 1999 년 6 월 [ &lt;a id=&quot;ref-RFC2617&quot; name=&quot;ref-RFC2617&quot;&gt;RFC2617&lt;/a&gt; ] 프랭크 J., 경이 베이커, P., Hostetler, J., 로렌스, S., 리치, P., Luotonen, A. 및 스튜어트 L., &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC3339&quot; name=&quot;ref-RFC3339&quot;&gt;RFC3339&lt;/a&gt; ] Klyne, G., Ed. 및 C. Newman, &quot;인터넷상의 날짜 및 시간 : 타임 스탬프&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3339&quot;&gt;RFC 3339&lt;/a&gt; , 2002 년 7 월. [ &lt;a id=&quot;ref-RFC3629&quot; name=&quot;ref-RFC3629&quot;&gt;RFC3629&lt;/a&gt;] Yergeau, F., &quot;UTF-8, ISO 10646의 변환 형식&quot;, STD 63, &lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC 3629&lt;/a&gt; , 2003 년 11 월. [ &lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt; ] Berners-Lee, T., Fielding, R. 및 L. Masinter, &quot;Uniform URI (Resource Identifier) ​​: 일반 구문 &quot;, STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; , 2005 년 1 월. [ &lt;a id=&quot;ref-RFC4122&quot; name=&quot;ref-RFC4122&quot;&gt;RFC4122&lt;/a&gt; ] Leach, P., Mealling, M. 및 R. Salz,&quot;UUID (Universally Unique Identifier) ​​URN 네임 스페이스 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC 4122&lt;/a&gt; , 2005 년 7 월.</target>
        </trans-unit>
        <trans-unit id="f109ae6f660a3e51addf064374205f31f9fc1367" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-REC-xml&quot; name=&quot;ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;]  Yergeau, F., Paoli, J., Bray, T., Sperberg-McQueen, C.,
              and E. Maler, &quot;Extensible Markup Language (XML) 1.0
              (Fourth Edition)&quot;, World Wide Web Consortium
              Recommendation REC-xml-20060816, August 2006,
              &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-20060816&quot;&gt;http://www.w3.org/TR/2006/REC-xml-20060816&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-xml-infoset&quot; name=&quot;ref-REC-xml-infoset&quot;&gt;REC-xml-infoset&lt;/a&gt;]
              Cowan, J. and R. Tobin, &quot;XML Information Set (Second
              Edition)&quot;, World Wide Web Consortium Recommendation REC-
              xml-infoset-20040204, February 2004,
              &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-infoset-20040204&quot;&gt;http://www.w3.org/TR/2004/REC-xml-infoset-20040204&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-xml-names&quot; name=&quot;ref-REC-xml-names&quot;&gt;REC-xml-names&lt;/a&gt;]
              Hollander, D., Bray, T., Tobin, R., and A. Layman,
              &quot;Namespaces in XML 1.0 (Second Edition)&quot;, World Wide Web
              Consortium Recommendation REC-xml-names-20060816, August
              2006, &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-names-20060816&quot;&gt;http://www.w3.org/TR/2006/REC-xml-names-20060816&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-xmlbase&quot; name=&quot;ref-REC-xmlbase&quot;&gt;REC-xmlbase&lt;/a&gt;]
              Marsh, J., &quot;XML Base&quot;, W3C REC W3C.REC-xmlbase-20010627,
              June 2001,
              &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlbase-20010627&quot;&gt;http://www.w3.org/TR/2001/REC-xmlbase-20010627&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-xmldsig-core&quot; name=&quot;ref-REC-xmldsig-core&quot;&gt;REC-xmldsig-core&lt;/a&gt;]
              Solo, D., Reagle, J., and D. Eastlake, &quot;XML-Signature
              Syntax and Processing&quot;, World Wide Web Consortium
              Recommendation REC-xmldsig-core-20020212, February 2002,
              &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2002/REC-xmldsig-core-20020212&quot;&gt;http://www.w3.org/TR/2002/REC-xmldsig-core-20020212&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-xmlenc-core&quot; name=&quot;ref-REC-xmlenc-core&quot;&gt;REC-xmlenc-core&lt;/a&gt;]
              Eastlake, D. and J. Reagle, &quot;XML Encryption Syntax and
              Processing&quot;, World Wide Web Consortium Recommendation REC-
              xmlenc-core-20021210, December 2002,
              &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2002/REC-xmlenc-core-20021210&quot;&gt;http://www.w3.org/TR/2002/REC-xmlenc-core-20021210&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997. 

   [&lt;a id=&quot;ref-RFC2246&quot; name=&quot;ref-RFC2246&quot;&gt;RFC2246&lt;/a&gt;]  Dierks, T. and C. Allen, &quot;The TLS Protocol Version 1.0&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC 2246&lt;/a&gt;, January 1999.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC2617&quot; name=&quot;ref-RFC2617&quot;&gt;RFC2617&lt;/a&gt;]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
              Leach, P., Luotonen, A., and L. Stewart, &quot;HTTP
              Authentication: Basic and Digest Access Authentication&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC2818&quot; name=&quot;ref-RFC2818&quot;&gt;RFC2818&lt;/a&gt;]  Rescorla, E., &quot;HTTP Over TLS&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt;, May 2000.

   [&lt;a id=&quot;ref-RFC3023&quot; name=&quot;ref-RFC3023&quot;&gt;RFC3023&lt;/a&gt;]  Murata, M., St. Laurent, S., and D. Kohn, &quot;XML Media
              Types&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC 3023&lt;/a&gt;, January 2001.

   [&lt;a id=&quot;ref-RFC3629&quot; name=&quot;ref-RFC3629&quot;&gt;RFC3629&lt;/a&gt;]  Yergeau, F., &quot;UTF-8, a transformation format of ISO
              10646&quot;, STD 63, &lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC 3629&lt;/a&gt;, November 2003.

   [&lt;a id=&quot;ref-RFC3864&quot; name=&quot;ref-RFC3864&quot;&gt;RFC3864&lt;/a&gt;]  Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
              Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;,
              September 2004.

   [&lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt;]  Berners-Lee, T., Fielding, R., and L. Masinter, &quot;Uniform
              Resource Identifier (URI): Generic Syntax&quot;, STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;3986&lt;/a&gt;, January 2005.

   [&lt;a id=&quot;ref-RFC3987&quot; name=&quot;ref-RFC3987&quot;&gt;RFC3987&lt;/a&gt;]  Duerst, M. and M. Suignard, &quot;Internationalized Resource
              Identifiers (IRIs)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC 3987&lt;/a&gt;, January 2005.

   [&lt;a id=&quot;ref-RFC4287&quot; name=&quot;ref-RFC4287&quot;&gt;RFC4287&lt;/a&gt;]  Nottingham, M. and R. Sayre, &quot;The Atom Syndication
              Format&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC 4287&lt;/a&gt;, December 2005.

   [&lt;a id=&quot;ref-RFC4288&quot; name=&quot;ref-RFC4288&quot;&gt;RFC4288&lt;/a&gt;]  Freed, N. and J. Klensin, &quot;Media Type Specifications and
              Registration Procedures&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4288&quot;&gt;RFC 4288&lt;/a&gt;, December 2005.

   [&lt;a id=&quot;ref-RFC4346&quot; name=&quot;ref-RFC4346&quot;&gt;RFC4346&lt;/a&gt;]  Dierks, T. and E. Rescorla, &quot;The Transport Layer Security
              (TLS) Protocol Version 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC 4346&lt;/a&gt;, April 2006.</source>
          <target state="translated">[ &lt;a id=&quot;ref-REC-xml&quot; name=&quot;ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ] Yergeau, F., Paoli, J., Bray, T., Sperberg-McQueen, C. 및 E. Maler, &quot;Extensible Markup Language (XML) 1.0 (Fourth Edition)&quot;, 월드 와이드 웹 컨소시엄 권장 REC-xml-20060816, 2006 년 8 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-20060816&quot;&gt;http://www.w3.org/TR/2006/REC-xml-20060816&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-REC-xml-infoset&quot; name=&quot;ref-REC-xml-infoset&quot;&gt;REC-xml-infoset&lt;/a&gt; ] Cowan, J. 및 R. Tobin, &quot;XML 정보 세트 (제 2 판)&quot;, 월드 와이드 웹 컨소시엄 권장 사항 REC-xml-infoset-20040204, 2004 년 2 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-infoset-20040204&quot;&gt;http : //www.w3 .org / TR / 2004 / REC-xml-infoset-20040204&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-REC-xml-names&quot; name=&quot;ref-REC-xml-names&quot;&gt;REC-xml- 이름&lt;/a&gt;] Hollander, D., Bray, T., Tobin, R. 및 A. Layman, &quot;XML 1.0의 네임 스페이스 (제 2 판)&quot;, 월드 와이드 웹 컨소시엄 권장 사항 REC-xml-names-20060816, 2006 년 8 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-names-20060816&quot;&gt;http : //www.w3.org/TR/2006/REC-xml-names-20060816&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-REC-xmlbase&quot; name=&quot;ref-REC-xmlbase&quot;&gt;REC-xmlbase&lt;/a&gt; ] Marsh, J., &quot;XML Base&quot;, W3C REC W3C.REC-xmlbase-20010627, 2001 년 6 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlbase-20010627&quot;&gt;http://www.w3.org/TR/2001/REC-xmlbase-20010627&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-REC-xmldsig-core&quot; name=&quot;ref-REC-xmldsig-core&quot;&gt;REC-xmldsig-core&lt;/a&gt; ] Solo, D., Reagle, J. 및 D. Eastlake, &quot;XML- 서명 구문 및 처리&quot;, 월드 와이드 웹 컨소시엄 권장 사항 REC-xmldsig-core-20020212, 2002 년 2 월, &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2002/REC-xmldsig-core-20020212&quot;&gt;http://www.w3.org/TR/2002/REC-xmldsig-core-20020212&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-REC-xmlenc-core&quot; name=&quot;ref-REC-xmlenc-core&quot;&gt;REC-xmlenc-core&lt;/a&gt; ] Eastlake, D. 및 J. Reagle, &quot;XML 암호화 구문 및 처리&quot;, 월드 와이드 웹 컨소시엄 권장 사항 REC- xmlenc-core-20021210, 2002 년 12 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2002/REC-xmlenc-core-20021210&quot;&gt;http://www.w3.org / TR / 2002 / REC-xmlenc-core-20021210&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner, S., &quot;요구 사항 수준을 나타내는 RFC에 사용되는 키워드 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; , 1997 년 3 월. [ &lt;a id=&quot;ref-RFC2246&quot; name=&quot;ref-RFC2246&quot;&gt;RFC2246&lt;/a&gt; ] Dierks, T. 및 C. Allen, &quot;TLS 프로토콜 버전 1.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC 2246&lt;/a&gt; , 1999 년 1 월. [ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. 및 T. Berners-Lee, &quot;Hypertext Transfer Protocol-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 261&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC2617&quot; name=&quot;ref-RFC2617&quot;&gt;RFC2617&lt;/a&gt; ] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A. 및 L. Stewart, &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC2818&quot; name=&quot;ref-RFC2818&quot;&gt;RFC2818&lt;/a&gt; ] Rescorla , E.,&quot;HTTP Over TLS &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt; , 2000 년 5 월. [ &lt;a id=&quot;ref-RFC3023&quot; name=&quot;ref-RFC3023&quot;&gt;RFC3023&lt;/a&gt; ] Murata, M., St. Laurent, S. 및 D. Kohn, &quot;XML 미디어 유형&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC 3023&lt;/a&gt; , 2001 년 1 월. [ &lt;a id=&quot;ref-RFC3629&quot; name=&quot;ref-RFC3629&quot;&gt;RFC3629&lt;/a&gt;] Yergeau, F., &quot;UTF-8, ISO 10646의 변환 형식&quot;, STD 63, &lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC 3629&lt;/a&gt; , 2003 년 11 월. [ &lt;a id=&quot;ref-RFC3864&quot; name=&quot;ref-RFC3864&quot;&gt;RFC3864&lt;/a&gt; ] Klyne, G., Nottingham, M. 및 J. Mogul, &quot;등록 절차 메시지 헤더 필드 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt; , 2004 년 9 월. [ &lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt; ] Berners-Lee, T., Fielding, R. 및 L. Masinter,&quot;Uniform Resource Identifier (URI) : Generic Syntax &quot;, STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;3986&lt;/a&gt; , 2005 년 1 월 [ &lt;a id=&quot;ref-RFC3987&quot; name=&quot;ref-RFC3987&quot;&gt;RFC3987&lt;/a&gt; ] Duerst, M. M. 및 Suignard &quot;다국어 리소스 식별자 (아이리스)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC 3987&lt;/a&gt; , 2005 년 1 월 [ &lt;a id=&quot;ref-RFC4287&quot; name=&quot;ref-RFC4287&quot;&gt;RFC4287&lt;/a&gt;] Nottingham, M. 및 R. Sayre, &quot;Atom Syndication Format&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC 4287&lt;/a&gt; , 2005 년 12 월. [ &lt;a id=&quot;ref-RFC4288&quot; name=&quot;ref-RFC4288&quot;&gt;RFC4288&lt;/a&gt; ] Freed, N. 및 J. Klensin, &quot;미디어 유형 사양 및 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc4288&quot;&gt;RFC 4288&lt;/a&gt; , 2005 년 12 월. [ &lt;a id=&quot;ref-RFC4346&quot; name=&quot;ref-RFC4346&quot;&gt;RFC4346&lt;/a&gt; ] Dierks, T. 및 E. Rescorla , &quot;TLS (Transport Layer Security) 프로토콜 버전 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC 4346&lt;/a&gt; , 2006 년 4 월.</target>
        </trans-unit>
        <trans-unit id="aa753c7ca1de65f848d19927144998faa06fdb5d" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC0793&quot; name=&quot;ref-RFC0793&quot;&gt;RFC0793&lt;/a&gt;]     Postel, J., &quot;Transmission Control Protocol&quot;, STD 7,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;RFC 793&lt;/a&gt;, September 1981.

   [&lt;a id=&quot;ref-RFC1950&quot; name=&quot;ref-RFC1950&quot;&gt;RFC1950&lt;/a&gt;]     Deutsch, L. and J-L. Gailly, &quot;ZLIB Compressed Data
                 Format Specification version 3.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-RFC1951&quot; name=&quot;ref-RFC1951&quot;&gt;RFC1951&lt;/a&gt;]     Deutsch, P., &quot;DEFLATE Compressed Data Format
                 Specification version 1.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC 1951&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-RFC1952&quot; name=&quot;ref-RFC1952&quot;&gt;RFC1952&lt;/a&gt;]     Deutsch, P., Gailly, J-L., Adler, M., Deutsch, L., and
                 G. Randers-Pehrson, &quot;GZIP file format specification
                 version 4.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1952&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]     Bradner, S., &quot;Key words for use in RFCs to Indicate
                 Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997.

   [&lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt;]     Berners-Lee, T., Fielding, R., and L. Masinter,
                 &quot;Uniform Resource Identifier (URI): Generic Syntax&quot;,
                 STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;, January 2005.

   [&lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt;]     Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for
                 Syntax Specifications: ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;,
                 January 2008.

   [&lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt;]     Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext
                 Transfer Protocol (HTTP/1.1): Semantics and Content&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt;]     Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext
                 Transfer Protocol (HTTP/1.1): Conditional Requests&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt;]     Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
                 &quot;Hypertext Transfer Protocol (HTTP/1.1): Range
                 Requests&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt;]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
                 Ed., &quot;Hypertext Transfer Protocol (HTTP/1.1): Caching&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7235&quot; name=&quot;ref-RFC7235&quot;&gt;RFC7235&lt;/a&gt;]     Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext
                 Transfer Protocol (HTTP/1.1): Authentication&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt;, June 2014. 

   [&lt;a id=&quot;ref-USASCII&quot; name=&quot;ref-USASCII&quot;&gt;USASCII&lt;/a&gt;]     American National Standards Institute, &quot;Coded Character
                 Set -- 7-bit American Standard Code for Information
                 Interchange&quot;, ANSI X3.4, 1986.

   [&lt;a id=&quot;ref-Welch&quot; name=&quot;ref-Welch&quot;&gt;Welch&lt;/a&gt;]       Welch, T., &quot;A Technique for High-Performance Data
                 Compression&quot;, IEEE Computer 17(6), June 1984.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC0793&quot; name=&quot;ref-RFC0793&quot;&gt;RFC0793&lt;/a&gt; ] Postel, J., &quot;Transmission Control Protocol&quot;, STD 7, &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;RFC 793&lt;/a&gt; , 1981 년 9 월. [ &lt;a id=&quot;ref-RFC1950&quot; name=&quot;ref-RFC1950&quot;&gt;RFC1950&lt;/a&gt; ] Deutsch, L. 및 JL. Gailly, &quot;ZLIB 압축 데이터 형식 사양 버전 3.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt; , 1996 년 5 월. [ &lt;a id=&quot;ref-RFC1951&quot; name=&quot;ref-RFC1951&quot;&gt;RFC1951&lt;/a&gt; ] Deutsch, P., &quot;DEFLATE 압축 데이터 형식 사양 버전 1.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC 1951&lt;/a&gt; , 1996 년 5 월. [ &lt;a id=&quot;ref-RFC1952&quot; name=&quot;ref-RFC1952&quot;&gt;RFC1952&lt;/a&gt; ] Deutsch, P., Gailly, JL., Adler, M., Deutsch, L. 및 G. Randers-Pehrson, &quot;GZIP 파일 형식 사양 버전 4.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1952&lt;/a&gt; , 1996 년 5 월. [ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;] Bradner, S., &quot;요구 사항 수준을 나타내는 RFC에 사용되는 키워드&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; , 1997 년 3 월. [ &lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt; ] Berners-Lee, T., Fielding, R. 및 L. Masinter, &quot;Uniform 자원 식별자 (URI) : 일반 구문 &quot;, STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; , 2005 년 1 월. [ &lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt; ] Crocker, D., Ed. 및 P. Overell, &quot;구문 사양을위한 증강 BNF : ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt; , 2008 년 1 월. [ &lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 의미 및 내용&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;, 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 조건부 요청&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt; ] Fielding, R., Ed., Lafon, Y., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 범위 요청&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt; ] Fielding, R., Ed., Nottingham, M., Ed. 및 J. Reschke, Ed , &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 캐싱&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7235&quot; name=&quot;ref-RFC7235&quot;&gt;RFC7235&lt;/a&gt;] Fielding, R., Ed. J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 인증&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-USASCII&quot; name=&quot;ref-USASCII&quot;&gt;USASCII&lt;/a&gt; ] American National Standards Institute, &quot;코드화 된 문자 세트-정보 교환을위한 7 비트 미국 표준 코드 &quot;, ANSI X3.4, 1986. [ &lt;a id=&quot;ref-Welch&quot; name=&quot;ref-Welch&quot;&gt;Welch&lt;/a&gt; ] Welch, T.,&quot;고성능 데이터 압축 기술 &quot;, IEEE 컴퓨터 17 (6), 1984 년 6 월.</target>
        </trans-unit>
        <trans-unit id="32b5eaf10a6f18bbfaf539b485fd4ae12b86c05e" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC2045&quot; name=&quot;ref-RFC2045&quot;&gt;RFC2045&lt;/a&gt;]  Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
              Extensions (MIME) Part One: Format of Internet Message
              Bodies&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;, November 1996.

   [&lt;a id=&quot;ref-RFC2046&quot; name=&quot;ref-RFC2046&quot;&gt;RFC2046&lt;/a&gt;]  Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
              Extensions (MIME) Part Two: Media Types&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt;,
              November 1996.

   [&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997. 

   [&lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt;]  Berners-Lee, T., Fielding, R., and L. Masinter, &quot;Uniform
              Resource Identifier (URI): Generic Syntax&quot;, STD 66,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;, January 2005.

   [&lt;a id=&quot;ref-RFC4647&quot; name=&quot;ref-RFC4647&quot;&gt;RFC4647&lt;/a&gt;]  Phillips, A., Ed. and M. Davis, Ed., &quot;Matching of Language
              Tags&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp47&quot;&gt;BCP 47&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647&lt;/a&gt;, September 2006.

   [&lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt;]  Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for Syntax
              Specifications: ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;, January 2008.

   [&lt;a id=&quot;ref-RFC5646&quot; name=&quot;ref-RFC5646&quot;&gt;RFC5646&lt;/a&gt;]  Phillips, A., Ed. and M. Davis, Ed., &quot;Tags for Identifying
              Languages&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp47&quot;&gt;BCP 47&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5646&quot;&gt;RFC 5646&lt;/a&gt;, September 2009.

   [&lt;a id=&quot;ref-RFC6365&quot; name=&quot;ref-RFC6365&quot;&gt;RFC6365&lt;/a&gt;]  Hoffman, P. and J. Klensin, &quot;Terminology Used in
              Internationalization in the IETF&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp166&quot;&gt;BCP 166&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC 6365&lt;/a&gt;,
              September 2011.

   [&lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Conditional Requests&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt;]  Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
              &quot;Hypertext Transfer Protocol (HTTP/1.1): Range Requests&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt;]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., &quot;Hypertext Transfer Protocol (HTTP/1.1): Caching&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7235&quot; name=&quot;ref-RFC7235&quot;&gt;RFC7235&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Authentication&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt;, June 2014.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC2045&quot; name=&quot;ref-RFC2045&quot;&gt;RFC2045&lt;/a&gt; ] Freed, N. 및 N. Borenstein, &quot;MIME (Multipurpose Internet Mail Extensions) 1 부 : 인터넷 메시지 본문 형식&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; , 1996 년 11 월. [ &lt;a id=&quot;ref-RFC2046&quot; name=&quot;ref-RFC2046&quot;&gt;RFC2046&lt;/a&gt; ] Free, N. 및 N. Borenstein, &quot;다목적 MIME (Internet Mail Extensions) 2 부 : 미디어 유형 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt; , 1996 년 11 월. [ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner, S.,&quot;요구 사항 수준을 나타내는 RFC에 사용되는 핵심 단어 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; , 1997 년 3 월. [ &lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt; ] Berners-Lee, T., Fielding, R. 및 L. Masinter, &quot;Uniform Resource Identifier (URI) : Generic Syntax&quot;, STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; , 2005 년 1 월. [ &lt;a id=&quot;ref-RFC4647&quot; name=&quot;ref-RFC4647&quot;&gt;RFC4647&lt;/a&gt; ] Phillips, A., Ed. 및 M. Davis, Ed., &quot;언어 태그의 일치&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp47&quot;&gt;BCP 47&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647&lt;/a&gt; , 2006 년 9 월. [ &lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt; ] Crocker, D., Ed. 및 P. Overell, &quot;구문 사양을위한 증강 BNF : ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt; , 2008 년 1 월. [ &lt;a id=&quot;ref-RFC5646&quot; name=&quot;ref-RFC5646&quot;&gt;RFC5646&lt;/a&gt; ] Phillips, A., Ed. 및 M. Davis, Ed., &quot;언어 식별을위한 태그&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp47&quot;&gt;BCP 47&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc5646&quot;&gt;RFC 5646&lt;/a&gt; , 2009 년 9 월. [ &lt;a id=&quot;ref-RFC6365&quot; name=&quot;ref-RFC6365&quot;&gt;RFC6365&lt;/a&gt; ] Hoffman, P. 및 J. Klensin, &quot;IETF 국제화에 사용되는 용어&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp166&quot;&gt;BCP 166&lt;/a&gt; ,&lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC 6365&lt;/a&gt;[ &lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 메시지 구문 및 라우팅&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 조건부 요청&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt; ] Fielding, R., Ed., Lafon, Y., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 범위 요청&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt;] Fielding, R., Ed., Nottingham, M., Ed. 및 J. Reschke, Ed., &quot;Hypertext Transfer Protocol (HTTP / 1.1) : Caching&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7235&quot; name=&quot;ref-RFC7235&quot;&gt;RFC7235&lt;/a&gt; ] Fielding, R 에드 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 인증&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt; , 2014 년 6 월.</target>
        </trans-unit>
        <trans-unit id="0f97a814186cc03d6a95b38611cc68d637712dec" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC2046&quot; name=&quot;ref-RFC2046&quot;&gt;RFC2046&lt;/a&gt;]  Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
              Extensions (MIME) Part Two: Media Types&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt;,
              November 1996.

   [&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997.

   [&lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt;]  Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for Syntax
              Specifications: ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;, January 2008.

   [&lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Conditional Requests&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt;]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., &quot;Hypertext Transfer Protocol (HTTP/1.1): Caching&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;, June 2014.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC2046&quot; name=&quot;ref-RFC2046&quot;&gt;RFC2046&lt;/a&gt; ] Freed, N. 및 N. Borenstein, &quot;MIME (Multipurpose Internet Mail Extensions) 2 부 : 매체 유형&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt; , 1996 년 11 월. [ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner, S., &quot;RFC에서 나타내는 주요 단어 요구 수준 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; , 1997 년 3 월. [ &lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt; ] Crocker, D., Ed. 및 P. Overell, &quot;구문 사양을위한 증강 BNF : ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt; , 2008 년 1 월. [ &lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 메시지 구문 및 라우팅&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;[ &lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 시맨틱 스 및 콘텐츠&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 조건부 요청&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt; ] Fielding, R., Ed., Nottingham, M., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 캐싱&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt; , 2014 년 6 월.</target>
        </trans-unit>
        <trans-unit id="7e13a726cd253b78f479b6c1518755778145f85b" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997.

   [&lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt;]  Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for Syntax
              Specifications: ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;, January 2008.

   [&lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Conditional Requests&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt;]  Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
              &quot;Hypertext Transfer Protocol (HTTP/1.1): Range Requests&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7235&quot; name=&quot;ref-RFC7235&quot;&gt;RFC7235&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Authentication&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt;, June 2014.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner, S., &quot;요구 사항 수준을 나타내는 RFC에 사용되는 키워드 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; , 1997 년 3 월. [ &lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt; ] Crocker, D., Ed. 및 P. Overell, &quot;구문 사양을위한 증강 BNF : ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt; , 2008 년 1 월. [ &lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 메시지 구문 및 라우팅&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 의미 및 내용&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;, 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 조건부 요청&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt; ] Fielding, R., Ed., Lafon, Y., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 범위 요청&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7235&quot; name=&quot;ref-RFC7235&quot;&gt;RFC7235&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 인증&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt; , 2014 년 6 월.</target>
        </trans-unit>
        <trans-unit id="3e9dfb2b3300e3cee5aa29bf83498176e8412766" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997.

   [&lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt;]  Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for Syntax
              Specifications: ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;, January 2008.

   [&lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt;]  Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
              &quot;Hypertext Transfer Protocol (HTTP/1.1): Range Requests&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt;]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., &quot;Hypertext Transfer Protocol (HTTP/1.1): Caching&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;, June 2014.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner, S., &quot;요구 사항 수준을 나타내는 RFC에 사용되는 키워드 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; , 1997 년 3 월. [ &lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt; ] Crocker, D., Ed. 및 P. Overell, &quot;구문 사양을위한 증강 BNF : ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt; , 2008 년 1 월. [ &lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 메시지 구문 및 라우팅&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 의미 및 내용&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;[ &lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt; ] Fielding, R., Ed., Lafon, Y., Ed. 및 J. Reschke, Ed., &quot;Hypertext Transfer Protocol (HTTP / 1.1) : Range Requests&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt; , 2014 년 6 월 [ &lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt; ] Fielding, R., Ed., Nottingham, M., Ed. 및 J. Reschke, Ed., &quot;Hypertext Transfer Protocol (HTTP / 1.1) : Caching&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt; , 2014 년 6 월.</target>
        </trans-unit>
        <trans-unit id="b85249b3b7b5758e2386a2ce786a0724059a28d2" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997.

   [&lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt;]  Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for Syntax
              Specifications: ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;, January 2008.

   [&lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt;]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., &quot;Hypertext Transfer Protocol (HTTP/1.1): Caching&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;, June 2014.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner, S., &quot;요구 사항 수준을 나타내는 RFC에 사용되는 키워드 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; , 1997 년 3 월. [ &lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt; ] Crocker, D., Ed. 및 P. Overell, &quot;구문 사양을위한 증강 BNF : ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt; , 2008 년 1 월. [ &lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 메시지 구문 및 라우팅&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 의미 및 내용&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;[ &lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt; ] Fielding, R., Ed., Nottingham, M., Ed. 및 J. Reschke, Ed., &quot;Hypertext Transfer Protocol (HTTP / 1.1) : Caching&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt; , 2014 년 6 월.</target>
        </trans-unit>
        <trans-unit id="8a4091e2c539cdc5431420dbeb2649f7bc6c3639" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC2291&quot; name=&quot;ref-RFC2291&quot;&gt;RFC2291&lt;/a&gt;]          Slein, J., Vitali, F., Whitehead, E., and D.
                      Durand, &quot;Requirements for a Distributed Authoring
                      and Versioning Protocol for the World Wide Web&quot;,
                      &lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC 2291&lt;/a&gt;, February 1998.

   [&lt;a id=&quot;ref-RFC2518&quot; name=&quot;ref-RFC2518&quot;&gt;RFC2518&lt;/a&gt;]          Goland, Y., Whitehead, E., Faizi, A., Carter, S.,
                      and D. Jensen, &quot;HTTP Extensions for Distributed
                      Authoring -- WEBDAV&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;, February 1999.

   [&lt;a id=&quot;ref-RFC2781&quot; name=&quot;ref-RFC2781&quot;&gt;RFC2781&lt;/a&gt;]          Hoffman, P. and F. Yergeau, &quot;UTF-16, an encoding
                      of ISO 10646&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2781&quot;&gt;RFC 2781&lt;/a&gt;, February 2000.

   [&lt;a id=&quot;ref-RFC3023&quot; name=&quot;ref-RFC3023&quot;&gt;RFC3023&lt;/a&gt;]          Murata, M., St. Laurent, S., and D. Kohn, &quot;XML
                      Media Types&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC 3023&lt;/a&gt;, January 2001.

   [&lt;a id=&quot;ref-RFC3253&quot; name=&quot;ref-RFC3253&quot;&gt;RFC3253&lt;/a&gt;]          Clemm, G., Amsden, J., Ellison, T., Kaler, C., and
                      J. Whitehead, &quot;Versioning Extensions to WebDAV
                      (Web Distributed Authoring and Versioning)&quot;,
                      &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC 3253&lt;/a&gt;, March 2002.

   [&lt;a id=&quot;ref-RFC3648&quot; name=&quot;ref-RFC3648&quot;&gt;RFC3648&lt;/a&gt;]          Whitehead, J. and J. Reschke, Ed., &quot;Web
                      Distributed Authoring and Versioning (WebDAV)
                      Ordered Collections Protocol&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3648&quot;&gt;RFC 3648&lt;/a&gt;,
                      December 2003. 

   [&lt;a id=&quot;ref-RFC3744&quot; name=&quot;ref-RFC3744&quot;&gt;RFC3744&lt;/a&gt;]          Clemm, G., Reschke, J., Sedlar, E., and J.
                      Whitehead, &quot;Web Distributed Authoring and
                      Versioning (WebDAV) Access Control Protocol&quot;,
                      &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC 3744&lt;/a&gt;, May 2004.

   [&lt;a id=&quot;ref-RFC3864&quot; name=&quot;ref-RFC3864&quot;&gt;RFC3864&lt;/a&gt;]          Klyne, G., Nottingham, M., and J. Mogul,
                      &quot;Registration Procedures for Message Header
                      Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;, September 2004.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC2291&quot; name=&quot;ref-RFC2291&quot;&gt;RFC2291&lt;/a&gt; ] Slein, J., Vitali, F., Whitehead, E. 및 D. Durand, &quot;World Wide Web의 분산 작성 및 버전 관리 프로토콜 요구 사항&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC 2291&lt;/a&gt; , 1998 년 2 월. [ &lt;a id=&quot;ref-RFC2518&quot; name=&quot;ref-RFC2518&quot;&gt;RFC2518&lt;/a&gt; ] Goland, Y., Whitehead, E., Faizi, A., Carter, S. 및 D. Jensen, &quot;분산 저작을위한 HTTP 확장 &lt;a id=&quot;ref-RFC2781&quot; name=&quot;ref-RFC2781&quot;&gt;-WEBDAV&lt;/a&gt; &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; , 1999 년 2 월. [ RFC2781 ] Hoffman, P. 및 F. Yergeau, &quot;UTF-16, ISO 10646 인코딩&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2781&quot;&gt;RFC 2781&lt;/a&gt; , 2000 년 2 월. [ &lt;a id=&quot;ref-RFC3023&quot; name=&quot;ref-RFC3023&quot;&gt;RFC3023&lt;/a&gt;] Murata, M., St. Laurent, S. 및 D. Kohn, &quot;XML 미디어 유형&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC 3023&lt;/a&gt; , 2001 년 1 월. [ &lt;a id=&quot;ref-RFC3253&quot; name=&quot;ref-RFC3253&quot;&gt;RFC3253&lt;/a&gt; ] Clemm, G., Amsden, J., Ellison, T., Kaler, C. 및 J. Whitehead, &quot;WebDAV (Web Distributed Authoring and Versioning)의 버전 확장 기능&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC 3253&lt;/a&gt; , 2002 년 3 월. [ &lt;a id=&quot;ref-RFC3648&quot; name=&quot;ref-RFC3648&quot;&gt;RFC3648&lt;/a&gt; ] Whitehead, J. 및 J. Reschke, Ed., &quot;Web Distributed Authoring and Versioning ( WebDAV) Ordered Collections Protocol &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3648&quot;&gt;RFC 3648&lt;/a&gt; , 2003 년 12 월. [ &lt;a id=&quot;ref-RFC3744&quot; name=&quot;ref-RFC3744&quot;&gt;RFC3744&lt;/a&gt;] Clemm, G., Reschke, J., Sedlar, E. 및 J. Whitehead, &quot;WebDAV (Web Distributed Authoring and Versioning) 액세스 제어 프로토콜&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC 3744&lt;/a&gt; , 2004 년 5 월. [ &lt;a id=&quot;ref-RFC3864&quot; name=&quot;ref-RFC3864&quot;&gt;RFC3864&lt;/a&gt; ] Klyne, G., Nottingham , M. 및 J. Mogul, &quot;메시지 헤더 필드의 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt; , 2004 년 9 월.</target>
        </trans-unit>
        <trans-unit id="6572f6bdad9d0df526aa9918bcc18d67193d7284" translate="yes" xml:space="preserve">
          <source>a DNS hostname, or IP address. If a hostname is passed, it will be resolved into an IP address by this function.</source>
          <target state="translated">DNS 호스트 이름 또는 IP 주소 호스트 이름이 전달되면이 기능에 의해 IP 주소로 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="48b988db0ee3a42e7679e7b91940653ba256252b" translate="yes" xml:space="preserve">
          <source>all other domains</source>
          <target state="translated">다른 모든 도메인</target>
        </trans-unit>
        <trans-unit id="22e784a22acfd6fde3c7f0d8be9a48223288b9a2" translate="yes" xml:space="preserve">
          <source>allowlist</source>
          <target state="translated">allowlist</target>
        </trans-unit>
        <trans-unit id="68346a9baa8533152e1b7183f99e607aa69f9b2d" translate="yes" xml:space="preserve">
          <source>an IP address (v4 or v6, optionally with a port, and ipv6 quoted and enclosed in square brackets),</source>
          <target state="translated">IP 주소 (v4 또는 v6, 선택적으로 포트가 있고 ipv6는 따옴표로 묶고 대괄호로 묶음)</target>
        </trans-unit>
        <trans-unit id="5b6e0dfcb0f27620edc54f98b71e760a5ef9f363" translate="yes" xml:space="preserve">
          <source>an IP address pattern in the dot-separated format.</source>
          <target state="translated">도트로 분리 된 형식의 IP 주소 패턴</target>
        </trans-unit>
        <trans-unit id="57c7b5a27584ee2ff2773d5b245085b264d57843" translate="yes" xml:space="preserve">
          <source>an obfuscated identifier (such as &quot;_hidden&quot; or &quot;_secret&quot;),</source>
          <target state="translated">난독 화 된 식별자 (예 : &quot;_hidden&quot;또는 &quot;_secret&quot;)</target>
        </trans-unit>
        <trans-unit id="4e16b4d174e42a23736982e9f2c23c397c8b3108" translate="yes" xml:space="preserve">
          <source>an opaque string, uniquely identifying each version, called the &lt;em&gt;entity tag&lt;/em&gt;, or the &lt;em&gt;etag&lt;/em&gt;.</source>
          <target state="translated">고유 각 버전을 식별하는 불투명 한 문자열은 호출 된 &lt;em&gt;엔터티 태그&lt;/em&gt; 또는 &lt;em&gt;ETAG을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4d46355f32d92f6c77aef67e98124f7e7eef5210" translate="yes" xml:space="preserve">
          <source>an unsecured HTTP request is used and the referring page was received with a secure protocol (HTTPS).</source>
          <target state="translated">보안되지 않은 HTTP 요청이 사용되고 참조 페이지가 보안 프로토콜 (HTTPS)로 수신되었습니다.</target>
        </trans-unit>
        <trans-unit id="d51793deecf3874c1379bd483b7f6e8a8697ba77" translate="yes" xml:space="preserve">
          <source>and finally compression can be defined at the connection level, between two nodes of an HTTP connection.</source>
          <target state="translated">마지막으로 압축은 HTTP 연결의 두 노드 사이의 연결 수준에서 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21ebe7d97514bbc039dd86f94ac3b48072ba7ec0" translate="yes" xml:space="preserve">
          <source>any comma-separated list of HTTP headers [Usually &lt;code&gt;keep-alive&lt;/code&gt; only]</source>
          <target state="translated">쉼표로 구분 된 HTTP 헤더 목록 [일반적으로 연결 &lt;code&gt;keep-alive&lt;/code&gt; 만]</target>
        </trans-unit>
        <trans-unit id="cc1567ff89b862169db893152a7611218a8a4089" translate="yes" xml:space="preserve">
          <source>any domain or path</source>
          <target state="translated">모든 도메인 또는 경로</target>
        </trans-unit>
        <trans-unit id="10b12d00a7d3c421266b22114a2233f8f8621481" translate="yes" xml:space="preserve">
          <source>application/octet-stream</source>
          <target state="translated">application/octet-stream</target>
        </trans-unit>
        <trans-unit id="69f62b376116281af7e0a09a35dafd577e34f4d2" translate="yes" xml:space="preserve">
          <source>application/vnd.mozilla.xul+xml</source>
          <target state="translated">application/vnd.mozilla.xul+xml</target>
        </trans-unit>
        <trans-unit id="237541aefdcd5b729ae836344478d37315abf73f" translate="yes" xml:space="preserve">
          <source>as well as styles loaded using the &lt;a href=&quot;../link&quot;&gt;&lt;code&gt;Link&lt;/code&gt;&lt;/a&gt; header:</source>
          <target state="translated">&lt;a href=&quot;../link&quot;&gt; &lt;code&gt;Link&lt;/code&gt; &lt;/a&gt; 헤더를 사용하여로드 된 스타일 :</target>
        </trans-unit>
        <trans-unit id="4bff8fa686f39f07445a2245133d217187258035" translate="yes" xml:space="preserve">
          <source>as well as styles loaded using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Link&quot;&gt;&lt;code&gt;Link&lt;/code&gt;&lt;/a&gt; header:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Link&quot;&gt; &lt;code&gt;Link&lt;/code&gt; &lt;/a&gt; 헤더를 사용하여로드 된 스타일 과</target>
        </trans-unit>
        <trans-unit id="fba31ebe5b81e900968e1a2412e72f955f8c8d98" translate="yes" xml:space="preserve">
          <source>authentication (to control access to different resources)</source>
          <target state="translated">인증 (다른 자원에 대한 액세스 제어)</target>
        </trans-unit>
        <trans-unit id="b3c23371b391c5c9a5070c1553a367da511602e0" translate="yes" xml:space="preserve">
          <source>authentication headers (e.g., &lt;a href=&quot;authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">인증 헤더 (예 : &lt;a href=&quot;authorization&quot;&gt; &lt;code&gt;Authorization&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a8d227a59c970b0e117bb96f0c53db926fe7e2e8" translate="yes" xml:space="preserve">
          <source>base-uri</source>
          <target state="translated">base-uri</target>
        </trans-unit>
        <trans-unit id="ee7f2acefe0b4b10bcc7d341ee436d1050bbc552" translate="yes" xml:space="preserve">
          <source>base64-encoded version of the above</source>
          <target state="translated">위의 base64 인코딩 버전</target>
        </trans-unit>
        <trans-unit id="ca53353f340229b4d6998a703a022cd1a46f2df7" translate="yes" xml:space="preserve">
          <source>block-all-mixed-content</source>
          <target state="translated">block-all-mixed-content</target>
        </trans-unit>
        <trans-unit id="2db8c22f75474a58cd13fa2d3425017015d392ce" translate="yes" xml:space="preserve">
          <source>boundary</source>
          <target state="translated">boundary</target>
        </trans-unit>
        <trans-unit id="1ffcf1d140fe7ea73a2ca4646ab42ba7ff8d6b38" translate="yes" xml:space="preserve">
          <source>by=&amp;lt;identifier&amp;gt;</source>
          <target state="translated">by=&amp;lt;identifier&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5dc29c0a9fefc5d9085157ab99c1395a78cbea28" translate="yes" xml:space="preserve">
          <source>caching (the cache can be public or private, like the browser cache)</source>
          <target state="translated">캐싱 (브라우저는 브라우저 캐시처럼 공개 또는 개인 캐시 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="16d8d6392988323b4370d2c819891302accb8e78" translate="yes" xml:space="preserve">
          <source>can be allowed for the base-uri policy:</source>
          <target state="translated">기본 URI 정책에 허용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ef5578db8253e578f4a1ad2a317c4cb55a6cccf" translate="yes" xml:space="preserve">
          <source>change the request such that it is a &lt;a href=&quot;#Simple_requests&quot;&gt;simple request&lt;/a&gt; that doesn&amp;rsquo;t cause a preflight</source>
          <target state="translated">프리 플라이트를 발생시키지 않는 &lt;a href=&quot;#Simple_requests&quot;&gt;간단한 요청이&lt;/a&gt; 되도록 요청 을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="e82b4f907665849edc640a3a5ed3f96746a22ae2" translate="yes" xml:space="preserve">
          <source>change the server-side behavior to avoid the preflight and/or to avoid the redirect&amp;mdash;if you have control over the server the request is being made to</source>
          <target state="translated">프리 플라이트 및 / 또는 경로 재 지정을 피하기 위해 서버 측 동작 변경 (서버에 대한 제어 권한이있는 경우)</target>
        </trans-unit>
        <trans-unit id="dcb16d9aacb079fe42fbde349c3319de8033ddd1" translate="yes" xml:space="preserve">
          <source>charset</source>
          <target state="translated">charset</target>
        </trans-unit>
        <trans-unit id="542878754cbbf01f4429e5bc9fad7e8ebe07d51e" translate="yes" xml:space="preserve">
          <source>charset=&amp;lt;charset&amp;gt;</source>
          <target state="translated">charset=&amp;lt;charset&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7624bec80c979807575ec0892f7c6ef4c15f3111" translate="yes" xml:space="preserve">
          <source>child-src</source>
          <target state="translated">child-src</target>
        </trans-unit>
        <trans-unit id="92425df92f162ed857653d72abf9032f6f8e9a9c" translate="yes" xml:space="preserve">
          <source>connect-src</source>
          <target state="translated">connect-src</target>
        </trans-unit>
        <trans-unit id="d59c684e865aae3fcb98cb7011c041b7d231fe6b" translate="yes" xml:space="preserve">
          <source>convert_addr()</source>
          <target state="translated">convert_addr()</target>
        </trans-unit>
        <trans-unit id="a17c9aaa61e80a1bf71d0d850af4e5baa9800bbd" translate="yes" xml:space="preserve">
          <source>data</source>
          <target state="translated">data</target>
        </trans-unit>
        <trans-unit id="7b1dafbb0ae29e20baea414f4e68f00b46dc7817" translate="yes" xml:space="preserve">
          <source>data URL scheme</source>
          <target state="translated">데이터 URL 체계</target>
        </trans-unit>
        <trans-unit id="26dd63ae4093a12d5fe3831767a9965a0355f13a" translate="yes" xml:space="preserve">
          <source>dateRange()</source>
          <target state="translated">dateRange()</target>
        </trans-unit>
        <trans-unit id="a2620cbc10f5198dd03e3f5a1569eb5dcf9a6a87" translate="yes" xml:space="preserve">
          <source>day</source>
          <target state="translated">day</target>
        </trans-unit>
        <trans-unit id="b1d2728d4d92be98cbe896a012245baeb3b5eba5" translate="yes" xml:space="preserve">
          <source>default-src</source>
          <target state="translated">default-src</target>
        </trans-unit>
        <trans-unit id="086b515d51ae4e83ef03faf2897557b0b2354560" translate="yes" xml:space="preserve">
          <source>dnsDomainIs()</source>
          <target state="translated">dnsDomainIs()</target>
        </trans-unit>
        <trans-unit id="d991b834071c9fd3f1c23defce92bbd9aff7f292" translate="yes" xml:space="preserve">
          <source>dnsDomainLevels()</source>
          <target state="translated">dnsDomainLevels()</target>
        </trans-unit>
        <trans-unit id="2b1bb3ec04c8f96d11d4fe26e461b302f090b32c" translate="yes" xml:space="preserve">
          <source>dnsResolve()</source>
          <target state="translated">dnsResolve()</target>
        </trans-unit>
        <trans-unit id="7b93f412c5cc61a7c2e57c97d5cfb718feaca8ba" translate="yes" xml:space="preserve">
          <source>document-domain</source>
          <target state="translated">document-domain</target>
        </trans-unit>
        <trans-unit id="9120580e94f134cb7c9f27cd1e43dbc82980e152" translate="yes" xml:space="preserve">
          <source>domain</source>
          <target state="translated">domain</target>
        </trans-unit>
        <trans-unit id="f1a6172df5508823225ab8bb7fe65a2481016827" translate="yes" xml:space="preserve">
          <source>donottrack.us</source>
          <target state="translated">donottrack.us</target>
        </trans-unit>
        <trans-unit id="40472cae6e0922cdfa8a50845b56a80a1aecab0d" translate="yes" xml:space="preserve">
          <source>draft-ietf-httpbis-rfc6265bis-02</source>
          <target state="translated">draft-ietf-httpbis-rfc6265bis-02</target>
        </trans-unit>
        <trans-unit id="696609a189535007707b4c972a02ca3abcc6c153" translate="yes" xml:space="preserve">
          <source>draft-ietf-httpbis-rfc6265bis-05</source>
          <target state="translated">draft-ietf-httpbis-rfc6265bis-05</target>
        </trans-unit>
        <trans-unit id="10ced556502ccd9ea6cab04a4c6c560574f5619b" translate="yes" xml:space="preserve">
          <source>effective-directive</source>
          <target state="translated">effective-directive</target>
        </trans-unit>
        <trans-unit id="8ed7f834df2e6a2e9619cf288468a7001e5e45c1" translate="yes" xml:space="preserve">
          <source>enforce Optional</source>
          <target state="translated">선택적 시행</target>
        </trans-unit>
        <trans-unit id="971c419dd609331343dee105fffd0f4608dc0bf2" translate="yes" xml:space="preserve">
          <source>file</source>
          <target state="translated">file</target>
        </trans-unit>
        <trans-unit id="bab8f5421577f88a13806c827f40340044f3f46f" translate="yes" xml:space="preserve">
          <source>filename*</source>
          <target state="translated">filename*</target>
        </trans-unit>
        <trans-unit id="f35c166cd0c65005849ff35d7c0cde54422c0eec" translate="yes" xml:space="preserve">
          <source>filtering (like an antivirus scan or parental controls)</source>
          <target state="translated">필터링 (예 : 바이러스 백신 검사 또는 자녀 보호)</target>
        </trans-unit>
        <trans-unit id="9d66faaa0ea10fa0468840dffa09e321853ecb14" translate="yes" xml:space="preserve">
          <source>filtering (like an antivirus scan, parental controls, &amp;hellip;)</source>
          <target state="translated">필터링 (바이러스 백신 검사, 보호자 통제 등)</target>
        </trans-unit>
        <trans-unit id="77ed03a5bd46ed473f79db47d3471ca6396e13b9" translate="yes" xml:space="preserve">
          <source>first some file formats are compressed with specific optimized methods,</source>
          <target state="translated">먼저 일부 파일 형식은 특정 최적화 된 방법으로 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="9b3734e0d856c513f33ee96559374347af0ab6d5" translate="yes" xml:space="preserve">
          <source>font-src</source>
          <target state="translated">font-src</target>
        </trans-unit>
        <trans-unit id="bb84ce39411e03bf6e940d04850c70c9cf4c5af8" translate="yes" xml:space="preserve">
          <source>for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; methods, like &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, which usually tries to fetch a document, the conditional request can be used to send back the document, if relevant only. Therefore, this spares bandwidth.</source>
          <target state="translated">에 대한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;안전&lt;/a&gt; 과 같은 방법 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 일반적으로 문서를 가져 오기 위해 시도, 조건부 요청에만 해당하는 경우, 문서를 다시 전송하는 데 사용할 수 있습니다. 따라서 대역폭이 절약됩니다.</target>
        </trans-unit>
        <trans-unit id="107d7bfa1273d29412288a73d8e3da9310bf0cc4" translate="yes" xml:space="preserve">
          <source>for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;unsafe&lt;/a&gt; methods, like &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, which usually uploads a document, the conditional request can be used to upload the document, only if the original it is based on is the same as that stored on the server.</source>
          <target state="translated">위한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;안전&lt;/a&gt; 같은 방법 &lt;a href=&quot;methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 보통 문서를 업로드, 조건부 요청은 그것이 기초하고있는 원본 서버에 저장된 것과 동일한 경우, 문서를 업로드하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="39c530df8a00ccde8bbcb7f14958e0a8b1db8387" translate="yes" xml:space="preserve">
          <source>for=&amp;lt;identifier&amp;gt;</source>
          <target state="translated">for=&amp;lt;identifier&amp;gt;</target>
        </trans-unit>
        <trans-unit id="462d902515185bbf061ed6e7ad4435aad289c286" translate="yes" xml:space="preserve">
          <source>forceEnable&quot; boolean preferece in about:config.</source>
          <target state="translated">about : config에서 forceEnable &quot;boolean preferece를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f58edcd721fab51d42650b7e6dd010b57980c7f4" translate="yes" xml:space="preserve">
          <source>form-action</source>
          <target state="translated">form-action</target>
        </trans-unit>
        <trans-unit id="ad1ceea2126038a2417f75852c0eaec4fbbe1b44" translate="yes" xml:space="preserve">
          <source>frame-ancestors</source>
          <target state="translated">frame-ancestors</target>
        </trans-unit>
        <trans-unit id="958a17ea17afdc7c73cc1fc1522e81267bf9656e" translate="yes" xml:space="preserve">
          <source>frame-src</source>
          <target state="translated">frame-src</target>
        </trans-unit>
        <trans-unit id="84e21b7649de2b838a3b5ec55c4b65501cf35eed" translate="yes" xml:space="preserve">
          <source>from Firefox 10 on mobile, &lt;code&gt;&lt;var&gt;geckotrail&lt;/var&gt;&lt;/code&gt; is the same as &lt;code&gt;&lt;var&gt;firefoxversion&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">모바일 (10)로부터 파이어 폭스, &lt;code&gt;&lt;var&gt;geckotrail&lt;/var&gt;&lt;/code&gt; 는 동일하다 &lt;code&gt;&lt;var&gt;firefoxversion&lt;/var&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7616bb87bd05f6439e3672ba1b2be55d5beb68b3" translate="yes" xml:space="preserve">
          <source>ftp</source>
          <target state="translated">ftp</target>
        </trans-unit>
        <trans-unit id="1f6d1f05bf03ff30afa6123e0bee2caa2da7cff0" translate="yes" xml:space="preserve">
          <source>gmt</source>
          <target state="translated">gmt</target>
        </trans-unit>
        <trans-unit id="86dd1cf45142e904cb2e99c2721fac3ca198c6ca" translate="yes" xml:space="preserve">
          <source>host</source>
          <target state="translated">host</target>
        </trans-unit>
        <trans-unit id="5f9c88b1b1fe6f524893937345305084a9e1041d" translate="yes" xml:space="preserve">
          <source>host=&amp;lt;host&amp;gt;</source>
          <target state="translated">host=&amp;lt;host&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f980c193395f072f33f35ad30af29c86b869a5aa" translate="yes" xml:space="preserve">
          <source>hostdom</source>
          <target state="translated">hostdom</target>
        </trans-unit>
        <trans-unit id="13dda6d8bc46f099d3816621f1bb02058b8d6263" translate="yes" xml:space="preserve">
          <source>hostname to resolve.</source>
          <target state="translated">확인할 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="813070b0844d4518de154f433d86fb302949e0a5" translate="yes" xml:space="preserve">
          <source>hot stand-by</source>
          <target state="translated">핫 스탠바이</target>
        </trans-unit>
        <trans-unit id="52ab86a87214a453d9f82538264f190854915247" translate="yes" xml:space="preserve">
          <source>hour</source>
          <target state="translated">hour</target>
        </trans-unit>
        <trans-unit id="2c763e6b7d79d93a2a3f3058f224485412fd92cb" translate="yes" xml:space="preserve">
          <source>http/https</source>
          <target state="translated">http/https</target>
        </trans-unit>
        <trans-unit id="cdbe72fa2d6000f2454e1c431b4cd76a6fb92ce1" translate="yes" xml:space="preserve">
          <source>iCalendar format</source>
          <target state="translated">iCalendar 형식</target>
        </trans-unit>
        <trans-unit id="285ee276a061f3e61631c19895f00dd8d96a145d" translate="yes" xml:space="preserve">
          <source>iOS Safari</source>
          <target state="translated">iOS 사파리</target>
        </trans-unit>
        <trans-unit id="849bb725b8563d0596db868195344c611a893724" translate="yes" xml:space="preserve">
          <source>iPad</source>
          <target state="translated">iPad</target>
        </trans-unit>
        <trans-unit id="97f2142cbb711918707b621ea05cbd1662b714ab" translate="yes" xml:space="preserve">
          <source>iPhone</source>
          <target state="translated">iPhone</target>
        </trans-unit>
        <trans-unit id="31e978dda11713a96454c3a1a463212be069c7d2" translate="yes" xml:space="preserve">
          <source>iPod</source>
          <target state="translated">iPod</target>
        </trans-unit>
        <trans-unit id="b6a64338df2eb5baeb40c41185176db2cb96a5ea" translate="yes" xml:space="preserve">
          <source>identifies the protocol (HTTP or HTTPS) that a client used to connect to your proxy or load balancer.</source>
          <target state="translated">클라이언트가 프록시 또는로드 밸런서에 연결하는 데 사용한 프로토콜 (HTTP 또는 HTTPS)을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="20cf626f392079bf9c59553682f4711426d9607e" translate="yes" xml:space="preserve">
          <source>iframe attributes can selectively enable features in certain frames, and not in others, even if those frames contain documents from the same origin.</source>
          <target state="translated">iframe 속성은 특정 프레임에서 동일한 출처의 문서를 포함하더라도 특정 프레임에서 기능을 선택적으로 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ae465c269b02e088bfef75f7203c824c084624e" translate="yes" xml:space="preserve">
          <source>img-src</source>
          <target state="translated">img-src</target>
        </trans-unit>
        <trans-unit id="137adf5541157c6a883d8b1755b3d0a08e52db57" translate="yes" xml:space="preserve">
          <source>indicates the size of the entity-body, in decimal number of octets, sent to the recipient.</source>
          <target state="translated">수신자에게 전송 된 엔티티 본문의 크기를 10 진수 10 진수로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4659c378675fe9020c682803cee1ebb988347f95" translate="yes" xml:space="preserve">
          <source>ipaddr</source>
          <target state="translated">ipaddr</target>
        </trans-unit>
        <trans-unit id="3a8dc0b686296fa059f02e66967fc351233d71ba" translate="yes" xml:space="preserve">
          <source>is a shell expression to compare against.</source>
          <target state="translated">비교할 쉘 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="711f0a4bb1c1c9f8a02a7c34c906fd912a25d9d4" translate="yes" xml:space="preserve">
          <source>is any string to compare (e.g. the URL, or the hostname).</source>
          <target state="translated">비교할 문자열입니다 (예 : URL 또는 호스트 이름).</target>
        </trans-unit>
        <trans-unit id="35bb75f385320807a1b2ab6899c56afe7b2b3abc" translate="yes" xml:space="preserve">
          <source>is the hostname from the URL.</source>
          <target state="translated">URL의 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6628b382993974f4a5cbca2c9b1c1c013ebe9b61" translate="yes" xml:space="preserve">
          <source>is the same as:</source>
          <target state="translated">와 같다:</target>
        </trans-unit>
        <trans-unit id="8b6de35d4682e9a8b14fba6347dcda04a75b0292" translate="yes" xml:space="preserve">
          <source>isInNet()</source>
          <target state="translated">isInNet()</target>
        </trans-unit>
        <trans-unit id="ee9fbe440c9f9cb0fddd58b1a68cf267199af430" translate="yes" xml:space="preserve">
          <source>isPlainHostName()</source>
          <target state="translated">isPlainHostName()</target>
        </trans-unit>
        <trans-unit id="9fa99c6eb1219edba6fb50a9c8f60e235c2a1b47" translate="yes" xml:space="preserve">
          <source>isResolvable()</source>
          <target state="translated">isResolvable()</target>
        </trans-unit>
        <trans-unit id="b6e13ad53d8ec41b034c49f131c64e99cf25207a" translate="yes" xml:space="preserve">
          <source>javascript</source>
          <target state="translated">javascript</target>
        </trans-unit>
        <trans-unit id="7dc0a5e593f649f492088fe836b1065b44a4d240" translate="yes" xml:space="preserve">
          <source>load balancing (to allow multiple servers to serve the different requests)</source>
          <target state="translated">부하 분산 (여러 서버가 다른 요청을 처리 할 수 ​​있도록)</target>
        </trans-unit>
        <trans-unit id="bf90de10d16d33f1ebf146ed81ce2d44a651f670" translate="yes" xml:space="preserve">
          <source>localHostOrDomainIs()</source>
          <target state="translated">localHostOrDomainIs()</target>
        </trans-unit>
        <trans-unit id="f6a2e9d539c4d8c290c040adbe4d56f58a242d54" translate="yes" xml:space="preserve">
          <source>localStorage (executes &lt;code&gt;localStorage.clear&lt;/code&gt;),</source>
          <target state="translated">로컬 스토리지 (실행한다 &lt;code&gt;localStorage.clear&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="07b91ff33236baae20bbe53abf2a67f00e3c50fb" translate="yes" xml:space="preserve">
          <source>logging (allowing the storage of historical information)</source>
          <target state="translated">로깅 (이력 정보 저장 허용)</target>
        </trans-unit>
        <trans-unit id="fe710cd089cb0ba74f588270fe079a392b5e9810" translate="yes" xml:space="preserve">
          <source>mailto</source>
          <target state="translated">mailto</target>
        </trans-unit>
        <trans-unit id="b6b13a0ea86ed568a571ab17aeb46d6c1e820468" translate="yes" xml:space="preserve">
          <source>manifest-src</source>
          <target state="translated">manifest-src</target>
        </trans-unit>
        <trans-unit id="9d4cca1595c30e43d23f14aedf815846f837956a" translate="yes" xml:space="preserve">
          <source>mask</source>
          <target state="translated">mask</target>
        </trans-unit>
        <trans-unit id="10d3ad09751e1c3d8c873feea6420bc613cceed5" translate="yes" xml:space="preserve">
          <source>mask for the IP address pattern informing which parts of the IP address should be matched against. 0 means ignore, 255 means match.</source>
          <target state="translated">IP 주소의 어느 부분이 일치해야하는지 알려주는 IP 주소 패턴 마스크. 0은 무시, 255는 일치를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="28e1c849b6dc898fca0424e31a6995a480cd4f2d" translate="yes" xml:space="preserve">
          <source>max-age</source>
          <target state="translated">max-age</target>
        </trans-unit>
        <trans-unit id="9ac6a36fa13e10d8a3e0e393b6ca9fd66644c093" translate="yes" xml:space="preserve">
          <source>max-age=&amp;lt;expire-time&amp;gt;</source>
          <target state="translated">max-age=&amp;lt;expire-time&amp;gt;</target>
        </trans-unit>
        <trans-unit id="a29bfccdab1c88eed654fe261827d16fb5b5a4b6" translate="yes" xml:space="preserve">
          <source>media-src</source>
          <target state="translated">media-src</target>
        </trans-unit>
        <trans-unit id="483fccd23acd857fcb20f316a053e85dbb71d17d" translate="yes" xml:space="preserve">
          <source>message framing headers (e.g., &lt;a href=&quot;transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">메시지 프레이밍 헤더 (예 : &lt;a href=&quot;transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="b6c935d4f3c7b220fa038613a1f9c1b56b255a86" translate="yes" xml:space="preserve">
          <source>min</source>
          <target state="translated">min</target>
        </trans-unit>
        <trans-unit id="021710fa7866431c1dacaa6cd31eeeb47dce64b6" translate="yes" xml:space="preserve">
          <source>month</source>
          <target state="translated">month</target>
        </trans-unit>
        <trans-unit id="7bf875f389edb2f955a35fd6a689ecbee26de3a2" translate="yes" xml:space="preserve">
          <source>multipart/byteranges</source>
          <target state="translated">multipart/byteranges</target>
        </trans-unit>
        <trans-unit id="12a22dd81cc700d0a382226b74ce386ec575a16a" translate="yes" xml:space="preserve">
          <source>multipart/form-data</source>
          <target state="translated">multipart/form-data</target>
        </trans-unit>
        <trans-unit id="98cb9df8eaa28e53ece0f85d650859e51d70ed53" translate="yes" xml:space="preserve">
          <source>myIpAddress()</source>
          <target state="translated">myIpAddress()</target>
        </trans-unit>
        <trans-unit id="48b9986d88eb74e0d3a4acb3cdad7ac0e26c3cc7" translate="yes" xml:space="preserve">
          <source>myIpAddress() returns the same IP address as the server address returned by &lt;code&gt;nslookup localhost&lt;/code&gt;on a Linux machine. It does not return the public IP address.</source>
          <target state="translated">myIpAddress ()는 Linux 시스템에서 &lt;code&gt;nslookup localhost&lt;/code&gt; 가 리턴 한 서버 주소와 동일한 IP 주소를 리턴 합니다. 퍼블릭 IP 주소는 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64bdcd6a063ffe53f20c5fc8a2a977b0e42bfbde" translate="yes" xml:space="preserve">
          <source>namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;

    pubControl =
       element app:control {
       atomCommonAttributes,
       pubDraft?
       &amp;amp; extensionElement
    }

    pubDraft =
      element app:draft { &quot;yes&quot; | &quot;no&quot; } 

   The &quot;app:control&quot; element MAY appear as a child of an atom:entry that
   is being created or updated via the Atom Publishing Protocol.  The
   app:control element MUST appear only once in an Entry.  The app:
   control element is considered foreign markup as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&amp;nbsp;6
   of [RFC4287]&lt;/a&gt;.

   The app:control element and its child elements MAY be included in
   Atom Feed or Entry Documents.

   The app:control element can contain an &quot;app:draft&quot; element as defined
   below, and it can contain extension elements as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&amp;nbsp;6
   of [RFC4287]&lt;/a&gt;.</source>
          <target state="translated">네임 스페이스 앱 = &quot; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&quot;pubControl&lt;/a&gt; = 요소 app : control {atomCommonAttributes, pubDraft? &amp;amp; extensionElement} pubDraft = 요소 앱 : draft { &quot;yes&quot;| &quot;no&quot;} &quot;app : control&quot;요소는 Atom Publishing Protocol을 통해 작성 또는 업데이트되는 atom : entry의 자식으로 나타날 수 있습니다. app : control 요소는 Entry에 한 번만 나타나야합니다. app : 제어 요소는 &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;[RFC4287]의 섹션 6에&lt;/a&gt; 정의 된 외부 마크 업으로 간주됩니다 . app : control 요소 및 해당 자식 요소는 Atom Feed 또는 Entry Documents에 포함될 수 있습니다. app : control 요소는 아래 정의 된 &quot;app : draft&quot;요소를 포함 할 수 있습니다.에 정의 된 확장 요소를 포함 할 수 있습니다&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;[RFC4287]의 섹션 6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd1286353570c5703799ba76999323b7c7447b06" translate="yes" xml:space="preserve">
          <source>no</source>
          <target state="translated">no</target>
        </trans-unit>
        <trans-unit id="c93bee6c522b9224a267a0391c4dd9d6634f5e43" translate="yes" xml:space="preserve">
          <source>no referrer</source>
          <target state="translated">추천자 없음</target>
        </trans-unit>
        <trans-unit id="73182f77ad56a5ab7236d9553832d35ecf5bbcdd" translate="yes" xml:space="preserve">
          <source>no-cache</source>
          <target state="translated">no-cache</target>
        </trans-unit>
        <trans-unit id="4f70f2f74568eb871171ef25b64e2369fbd0b561" translate="yes" xml:space="preserve">
          <source>no-referrer</source>
          <target state="translated">no-referrer</target>
        </trans-unit>
        <trans-unit id="70ef900efd9d989c7461278efc15fc8b7dd95d38" translate="yes" xml:space="preserve">
          <source>no-referrer-when-downgrade (default)</source>
          <target state="translated">추천하지 않은 경우 다운 그레이드시 (기본값)</target>
        </trans-unit>
        <trans-unit id="9fe350a67b2e91ed9cf66de96117752e35a2720e" translate="yes" xml:space="preserve">
          <source>no-store
      The purpose of the no-store directive is to prevent the
      inadvertent release or retention of sensitive information (for
      example, on backup tapes). The no-store directive applies to the
      entire message, and MAY be sent either in a response or in a
      request. If sent in a request, a cache MUST NOT store any part of
      either this request or any response to it. If sent in a response,
      a cache MUST NOT store any part of either this response or the
      request that elicited it. This directive applies to both non-
      shared and shared caches. &quot;MUST NOT store&quot; in this context means
      that the cache MUST NOT intentionally store the information in
      non-volatile storage, and MUST make a best-effort attempt to
      remove the information from volatile storage as promptly as
      possible after forwarding it.

      Even when this directive is associated with a response, users
      might explicitly store such a response outside of the caching
      system (e.g., with a &quot;Save As&quot; dialog). History buffers MAY store
      such responses as part of their normal operation. 

      The purpose of this directive is to meet the stated requirements
      of certain users and service authors who are concerned about
      accidental releases of information via unanticipated accesses to
      cache data structures. While the use of this directive might
      improve privacy in some cases, we caution that it is NOT in any
      way a reliable or sufficient mechanism for ensuring privacy. In
      particular, malicious or compromised caches might not recognize or
      obey this directive, and communications networks might be
      vulnerable to eavesdropping.</source>
          <target state="translated">no-store no-store 지시문의 목적은 중요한 정보 (예 : 백업 테이프)가 실수로 해제되거나 보존되지 않도록하는 것입니다. no-store 지시문은 전체 메시지에 적용되며 응답 또는 요청으로 전송 될 수 있습니다. 요청으로 전송 된 경우, 캐시는이 요청의 일부 나 응답을 저장해서는 안됩니다 (MUST NOT). 응답으로 전송 된 경우, 캐시는이 응답 또는 요청을 유발 한 요청의 일부를 저장해서는 안됩니다 (MUST NOT). 이 지정 문은 비공유 및 공유 캐시 모두에 적용됩니다. 이 문맥에서 &quot;MUST NOT store&quot;는 캐시가 의도적으로 비 휘발성 스토리지에 정보를 저장해서는 안됨을 의미합니다.휘발성 저장소에서 정보를 전달한 후 가능한 빨리 정보를 제거하기 위해 최선을 다해야합니다. 이 지시문이 응답과 관련되어 있어도 사용자는 캐싱 시스템 외부에 이러한 응답을 명시 적으로 저장할 수 있습니다 (예 : &quot;다른 이름으로 저장&quot;대화 상자 사용). 히스토리 버퍼는 이러한 응답을 정상 작동의 일부로 저장할 수 있습니다. 이 지침의 목적은 캐시 데이터 구조에 대한 예기치 않은 액세스를 통한 우발적 인 정보 공개를 우려하는 특정 사용자 및 서비스 작성자의 명시된 요구 사항을 충족시키는 것입니다. 이 지침을 사용하면 프라이버시가 향상 될 수 있지만 프라이버시를 보장하기위한 신뢰할 수 있거나 충분한 메커니즘은 아닙니다. 특히,악의적이거나 손상된 캐시는이 지침을 인식하거나 따르지 않을 수 있으며 통신 네트워크는 도청에 취약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dd61e2fa66eb6e428ffe8c41835e97bcabf006f" translate="yes" xml:space="preserve">
          <source>no-transform
      Implementors of intermediate caches (proxies) have found it useful
      to convert the media type of certain entity bodies. A non-
      transparent proxy might, for example, convert between image
      formats in order to save cache space or to reduce the amount of
      traffic on a slow link.

      Serious operational problems occur, however, when these
      transformations are applied to entity bodies intended for certain
      kinds of applications. For example, applications for medical 

      imaging, scientific data analysis and those using end-to-end
      authentication, all depend on receiving an entity body that is bit
      for bit identical to the original entity-body.

      Therefore, if a message includes the no-transform directive, an
      intermediate cache or proxy MUST NOT change those headers that are
      listed in &lt;a href=&quot;#section-13.5.2&quot;&gt;section 13.5.2&lt;/a&gt; as being subject to the no-transform
      directive. This implies that the cache or proxy MUST NOT change
      any aspect of the entity-body that is specified by these headers,
      including the value of the entity-body itself.</source>
          <target state="translated">트랜스 폼 없음 중간 캐시 (프록시)의 구현자는 특정 엔티티 본문의 미디어 유형을 변환하는 것이 유용하다는 것을 알게되었습니다. 예를 들어, 투명하지 않은 프록시는 캐시 공간을 절약하거나 저속 링크의 트래픽 양을 줄이기 위해 이미지 형식간에 변환 할 수 있습니다. 그러나 이러한 변환이 특정 종류의 응용 프로그램을위한 엔터티 본문에 적용될 때 심각한 운영 문제가 발생합니다. 예를 들어, 의료 이미징, 과학적 데이터 분석 및 엔드 투 엔드 인증을 사용하는 응용 프로그램은 모두 원래 엔터티 본문과 비트 단위가 동일한 엔터티 본문을받는 데 달려 있습니다. 따라서 메시지에 비 변환 지시문이 포함 된 경우중간 캐시 또는 프록시는 다음에 나열된 헤더를 변경해서는 안됩니다.&lt;a href=&quot;#section-13.5.2&quot;&gt;&lt;/a&gt;변형이없는 지시어의 적용을받는 13.5.2 절 . 이는 캐시 또는 프록시가 엔티티 본문 자체의 값을 포함하여 이러한 헤더로 지정된 엔티티 본문의 모든 측면을 변경해서는 안됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2be88ca4242c76e8253ac62474851065032d6833" translate="yes" xml:space="preserve">
          <source>null</source>
          <target state="translated">null</target>
        </trans-unit>
        <trans-unit id="fe59c8ff1d1a5825d27abedb911d923c444e21fe" translate="yes" xml:space="preserve">
          <source>object-src</source>
          <target state="translated">object-src</target>
        </trans-unit>
        <trans-unit id="da7a68734367828e30b94927f4c2b43ed2c0f652" translate="yes" xml:space="preserve">
          <source>off</source>
          <target state="translated">off</target>
        </trans-unit>
        <trans-unit id="db3d405b10675998c030223177d42e71b4e7a312" translate="yes" xml:space="preserve">
          <source>on</source>
          <target state="translated">on</target>
        </trans-unit>
        <trans-unit id="aea30f37abb10330bc8c614a352e1b917c6470e6" translate="yes" xml:space="preserve">
          <source>or &quot;unknown&quot; when the preceding entity is not known (and you still want to indicate that forwarding of the request was made).</source>
          <target state="translated">또는 선행 엔티티가 알려지지 않은 경우 &quot;알 수 없음&quot;(및 여전히 요청 전달이 이루어 졌음을 표시하려는 경우).</target>
        </trans-unit>
        <trans-unit id="7c3999b951f94fc202bf0c9012a820f7a5eff095" translate="yes" xml:space="preserve">
          <source>or &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;Trailer&lt;/code&gt; itself.</source>
          <target state="translated">또는 &lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;Trailer&lt;/code&gt; 자체입니다.</target>
        </trans-unit>
        <trans-unit id="9049ae3b863750d81d00f3a5864d3d31c54d47b5" translate="yes" xml:space="preserve">
          <source>or when the server is under attack by a client attempting to exploit potential security holes.</source>
          <target state="translated">또는 잠재적 인 보안 허점을 악용하려는 클라이언트가 서버를 공격하는 경우.</target>
        </trans-unit>
        <trans-unit id="b284f94827db1fa2970d9e2014f080413b547a7e" translate="yes" xml:space="preserve">
          <source>origin</source>
          <target state="translated">origin</target>
        </trans-unit>
        <trans-unit id="f15e7af6aa8bcd559fe830043261245629c7cc18" translate="yes" xml:space="preserve">
          <source>origin-when-cross-origin</source>
          <target state="translated">origin-when-cross-origin</target>
        </trans-unit>
        <trans-unit id="91cc2e927b3bfb1d4477b744f7c70221ddb86ef1" translate="yes" xml:space="preserve">
          <source>pattern</source>
          <target state="translated">pattern</target>
        </trans-unit>
        <trans-unit id="78082cd56114be30da891d5687edab8b3c2d66ba" translate="yes" xml:space="preserve">
          <source>plugin-types</source>
          <target state="translated">plugin-types</target>
        </trans-unit>
        <trans-unit id="5576aae4fb0ff352046d4e1fb53e4531ff81712d" translate="yes" xml:space="preserve">
          <source>proto=&amp;lt;http|https&amp;gt;</source>
          <target state="translated">proto=&amp;lt;http|https&amp;gt;</target>
        </trans-unit>
        <trans-unit id="22ea1c649c82946aa6e479e1ffd321e4a318b1b0" translate="yes" xml:space="preserve">
          <source>q</source>
          <target state="translated">q</target>
        </trans-unit>
        <trans-unit id="02452ff4ff23b459e2e73cedf36140315f00f994" translate="yes" xml:space="preserve">
          <source>realm=&amp;lt;realm&amp;gt;</source>
          <target state="translated">realm=&amp;lt;realm&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9ac18ba11d3f1181e7517c3c4f6c8a7eeb0f126a" translate="yes" xml:space="preserve">
          <source>referrer</source>
          <target state="translated">referrer</target>
        </trans-unit>
        <trans-unit id="db8a2cc6922c7b13291841838739062ba64da02f" translate="yes" xml:space="preserve">
          <source>report-to</source>
          <target state="translated">report-to</target>
        </trans-unit>
        <trans-unit id="16e8e5b1a2982629f65e6c928be748b7f6b42e81" translate="yes" xml:space="preserve">
          <source>report-uri</source>
          <target state="translated">report-uri</target>
        </trans-unit>
        <trans-unit id="ed9af1e0f74b3e9a43e1fe4d187f13988917ceb6" translate="yes" xml:space="preserve">
          <source>report-uri=&quot;&amp;lt;uri&amp;gt;&quot; Optional</source>
          <target state="translated">report-uri = &quot;&amp;lt;uri&amp;gt;&quot;선택 사항</target>
        </trans-unit>
        <trans-unit id="6c9e448138869437822e431ba846f0b6bec8887b" translate="yes" xml:space="preserve">
          <source>request modifiers (e.g., controls and conditionals, like &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt;&lt;code&gt;Max-Forwards&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">요청 수정 자 (예 : &lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt; &lt;code&gt;Max-Forwards&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; 와 같은 제어 및 조건 )</target>
        </trans-unit>
        <trans-unit id="2fd8c6d6d1cdada1adf7fbc60eb9cd537414faf0" translate="yes" xml:space="preserve">
          <source>require-sri-for</source>
          <target state="translated">require-sri-for</target>
        </trans-unit>
        <trans-unit id="3ec5852b014415f50f8994ebc739d27e5be55fc8" translate="yes" xml:space="preserve">
          <source>resource: is Firefox only.</source>
          <target state="translated">리소스 : Firefox 만 해당합니다.</target>
        </trans-unit>
        <trans-unit id="904246d4e0ad39b5566db7faad5522ab88629fc8" translate="yes" xml:space="preserve">
          <source>resource: is not defined in any specification.</source>
          <target state="translated">자원 : 사양에 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee7b24ec063b1d39218a7097c3d66d0c03d45aab" translate="yes" xml:space="preserve">
          <source>routing headers (e.g., &lt;a href=&quot;host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">라우팅 헤더 (예 : &lt;a href=&quot;host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="b4e44716dbbf57be3dae2f819d96795a85d06652" translate="yes" xml:space="preserve">
          <source>same-origin</source>
          <target state="translated">same-origin</target>
        </trans-unit>
        <trans-unit id="9ed037b84943c4caa3a520e48a5540181c46c98c" translate="yes" xml:space="preserve">
          <source>sandbox</source>
          <target state="translated">sandbox</target>
        </trans-unit>
        <trans-unit id="3f82a2a461031d4f91afa1274fe48be5b4859c90" translate="yes" xml:space="preserve">
          <source>script-src</source>
          <target state="translated">script-src</target>
        </trans-unit>
        <trans-unit id="920a25ef686c4f7ca6ad23dd109d3ad653161832" translate="yes" xml:space="preserve">
          <source>sec</source>
          <target state="translated">sec</target>
        </trans-unit>
        <trans-unit id="faadae9badfb659aba69d03dbcb89e27a87212ac" translate="yes" xml:space="preserve">
          <source>sessionStorage (executes &lt;code&gt;sessionStorage.clear&lt;/code&gt;),</source>
          <target state="translated">sessionStorage (실행 &lt;code&gt;sessionStorage.clear&lt;/code&gt; 를 )</target>
        </trans-unit>
        <trans-unit id="8110b865d3f7a38f0f0c8d17482913d907e30a41" translate="yes" xml:space="preserve">
          <source>shExpMatch()</source>
          <target state="translated">shExpMatch()</target>
        </trans-unit>
        <trans-unit id="5e301926272bef4fd5df71996b8f60ecc87be92b" translate="yes" xml:space="preserve">
          <source>shexp</source>
          <target state="translated">shexp</target>
        </trans-unit>
        <trans-unit id="828d338a9b04221c9cbe286f50cd389f68de4ecf" translate="yes" xml:space="preserve">
          <source>source</source>
          <target state="translated">source</target>
        </trans-unit>
        <trans-unit id="bce16dd0260827ecf338c787f1206f77860cacc5" translate="yes" xml:space="preserve">
          <source>sources</source>
          <target state="translated">sources</target>
        </trans-unit>
        <trans-unit id="e8b9f665f844bf5da8294a1282fd740a4b17d2a6" translate="yes" xml:space="preserve">
          <source>ssh</source>
          <target state="translated">ssh</target>
        </trans-unit>
        <trans-unit id="3ee173eae5ff5a2d95c7d9eee5a022866ac1d8a0" translate="yes" xml:space="preserve">
          <source>stale-if-error</source>
          <target state="translated">stale-if-error</target>
        </trans-unit>
        <trans-unit id="3442496b96dd01591a8cd44b1eec1368ab728aba" translate="yes" xml:space="preserve">
          <source>str</source>
          <target state="translated">str</target>
        </trans-unit>
        <trans-unit id="39bcb856a1233e31adf544a5830ca93db3b6cd40" translate="yes" xml:space="preserve">
          <source>strict-dynamic</source>
          <target state="translated">strict-dynamic</target>
        </trans-unit>
        <trans-unit id="69c4c5d9ab7b46419b9dd7c14c639c45e5c98fbc" translate="yes" xml:space="preserve">
          <source>strict-origin</source>
          <target state="translated">strict-origin</target>
        </trans-unit>
        <trans-unit id="8a862f20e750cb73a3c4e7d58cca1decb78087b7" translate="yes" xml:space="preserve">
          <source>strict-origin-when-cross-origin</source>
          <target state="translated">strict-origin-when-cross-origin</target>
        </trans-unit>
        <trans-unit id="a69927cfe4b777ac30b5615098bdb59a0ffecb00" translate="yes" xml:space="preserve">
          <source>style-src</source>
          <target state="translated">style-src</target>
        </trans-unit>
        <trans-unit id="cc4c96facde9ef9579c33b6d5473fc4e3feb23bb" translate="yes" xml:space="preserve">
          <source>tel</source>
          <target state="translated">tel</target>
        </trans-unit>
        <trans-unit id="3b01d3ebd10b89a1117c003d909ee9b795730f20" translate="yes" xml:space="preserve">
          <source>telephone</source>
          <target state="translated">telephone</target>
        </trans-unit>
        <trans-unit id="56e2a9f5c50f89339365495e90569bbc839f7473" translate="yes" xml:space="preserve">
          <source>text/css</source>
          <target state="translated">text/css</target>
        </trans-unit>
        <trans-unit id="010acb220a9c2c8c0ee63a1c3a50f915bed739bc" translate="yes" xml:space="preserve">
          <source>text/html</source>
          <target state="translated">text/html</target>
        </trans-unit>
        <trans-unit id="f919d9f152904f6c40db36d416df4901ff69eaa0" translate="yes" xml:space="preserve">
          <source>text/plain</source>
          <target state="translated">text/plain</target>
        </trans-unit>
        <trans-unit id="fcbd9140f62ce9e1bff1b08caa7b6e4989991639" translate="yes" xml:space="preserve">
          <source>the HTTP protocol version</source>
          <target state="translated">HTTP 프로토콜 버전</target>
        </trans-unit>
        <trans-unit id="834b665c2d26fa1848fa0366da509e1120558403" translate="yes" xml:space="preserve">
          <source>the IETF specification 7230, Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing.</source>
          <target state="translated">IETF 사양 7230, 하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 메시지 구문 및 라우팅.</target>
        </trans-unit>
        <trans-unit id="ca3648ddbb8ef94ec160c5cf3dadb9f1a7b069a5" translate="yes" xml:space="preserve">
          <source>the book Nineteen Eighty-Four by George Orwell,</source>
          <target state="translated">George Orwell의 Nineteen Eighty-Four,</target>
        </trans-unit>
        <trans-unit id="e5577fe93428a6ebf166c59f91b76cdd97f2d947" translate="yes" xml:space="preserve">
          <source>the date of last modification of the document, the &lt;em&gt;last-modified&lt;/em&gt; date.</source>
          <target state="translated">문서를 &lt;em&gt;마지막으로 수정 한&lt;/em&gt; 날짜 , &lt;em&gt;마지막으로 수정 한&lt;/em&gt; 날짜</target>
        </trans-unit>
        <trans-unit id="5bdf6c9b9600d50a2caba66d0f436ceb74b141fb" translate="yes" xml:space="preserve">
          <source>the declared type does not match one of specified types in the &lt;code&gt;plugin-types&lt;/code&gt; directive,</source>
          <target state="translated">선언 된 유형이 &lt;code&gt;plugin-types&lt;/code&gt; 지시문 에 지정된 유형 중 하나와 일치하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f5bc1a085176aeaa42eece5f0bc700a3c0ead360" translate="yes" xml:space="preserve">
          <source>the domain name of the server (for virtual hosting).</source>
          <target state="translated">서버의 도메인 이름 (가상 호스팅 용).</target>
        </trans-unit>
        <trans-unit id="4e45e35d9c495396c0ff91a341f11e6470af2942" translate="yes" xml:space="preserve">
          <source>the element to load does not declare a valid MIME type,</source>
          <target state="translated">로드 할 요소가 유효한 MIME 유형을 선언하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0613e7970e123f067d9fc91be46be68bbebfac43" translate="yes" xml:space="preserve">
          <source>the fetched resource does not match the declared type.</source>
          <target state="translated">가져온 자원이 선언 된 유형과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35bca49c0b588b270d7870a552e28ce42f495d97" translate="yes" xml:space="preserve">
          <source>the following script is blocked and won't be loaded or executed:</source>
          <target state="translated">다음 스크립트는 차단되어로드되거나 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46595ae815e949f9ccd5a7a60da356563667824c" translate="yes" xml:space="preserve">
          <source>the following stylesheets are blocked and won't load:</source>
          <target state="translated">다음 스타일 시트는 차단되어로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cce6b26755360a8f56e660b44564e5d1492e4498" translate="yes" xml:space="preserve">
          <source>the path of the document, i.e. an absolute URL without the protocol or domain name</source>
          <target state="translated">문서의 경로, 즉 프로토콜 또는 도메인 이름이없는 절대 URL</target>
        </trans-unit>
        <trans-unit id="a125642013a78025c6dc1c812d7784ec8c9efd5d" translate="yes" xml:space="preserve">
          <source>the referring resource is a local &quot;file&quot; or &quot;data&quot; URI,</source>
          <target state="translated">참조 리소스는 로컬 &quot;파일&quot;또는 &quot;데이터&quot;URI입니다.</target>
        </trans-unit>
        <trans-unit id="565f7f6174bbd09fcb5308490e8e9f6612ca9595" translate="yes" xml:space="preserve">
          <source>then general encryption can happen at the HTTP level (the resource is transmitted compressed from end to end),</source>
          <target state="translated">일반 암호화는 HTTP 수준에서 발생할 수 있습니다 (자원은 끝에서 끝까지 압축되어 전송됩니다).</target>
        </trans-unit>
        <trans-unit id="e8ad0956f6a10cdd51bfe4f85fd25912878e665f" translate="yes" xml:space="preserve">
          <source>timeRange()</source>
          <target state="translated">timeRange()</target>
        </trans-unit>
        <trans-unit id="fdd74bdda1023be7c42ab41eb84f64531d0846b4" translate="yes" xml:space="preserve">
          <source>trailers</source>
          <target state="translated">trailers</target>
        </trans-unit>
        <trans-unit id="5ffe533b830f08a0326348a9160afafc8ada44db" translate="yes" xml:space="preserve">
          <source>true</source>
          <target state="translated">true</target>
        </trans-unit>
        <trans-unit id="9c0978b58597587aa5b55de75fadb6f9093b3bd4" translate="yes" xml:space="preserve">
          <source>unsafe-url</source>
          <target state="translated">unsafe-url</target>
        </trans-unit>
        <trans-unit id="b33cb04ebd3cdadd1aeb5e81ecaeea899d7a3393" translate="yes" xml:space="preserve">
          <source>upgrade-insecure-requests</source>
          <target state="translated">upgrade-insecure-requests</target>
        </trans-unit>
        <trans-unit id="81736358b1645103ae83247b10c5f82af641ddfc" translate="yes" xml:space="preserve">
          <source>url</source>
          <target state="translated">url</target>
        </trans-unit>
        <trans-unit id="b4fbf013919b2cce60a03d4bbe39f2706dc37e06" translate="yes" xml:space="preserve">
          <source>urn</source>
          <target state="translated">urn</target>
        </trans-unit>
        <trans-unit id="1f5327f2352ef7b1f1b876f346c5bbb680a4c2d5" translate="yes" xml:space="preserve">
          <source>v1.1</source>
          <target state="translated">v1.1</target>
        </trans-unit>
        <trans-unit id="e93161848c09c7aa679a6171da3705db378223e7" translate="yes" xml:space="preserve">
          <source>v3.0</source>
          <target state="translated">v3.0</target>
        </trans-unit>
        <trans-unit id="9c99bc69e3a5c0c3968bad4188f883287fc7ad80" translate="yes" xml:space="preserve">
          <source>view-source</source>
          <target state="translated">view-source</target>
        </trans-unit>
        <trans-unit id="99f011705ed86a683afa79366cf7c5e249099cc6" translate="yes" xml:space="preserve">
          <source>wd1 and wd2</source>
          <target state="translated">wd1과 wd2</target>
        </trans-unit>
        <trans-unit id="6c03a1b31371ba66a9b1fe45e5e1d6d826f72412" translate="yes" xml:space="preserve">
          <source>weekdayRange()</source>
          <target state="translated">weekdayRange()</target>
        </trans-unit>
        <trans-unit id="ef398c9cb054596ac18d63a2b4ac04f547c30e83" translate="yes" xml:space="preserve">
          <source>when a client has improperly converted a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request to a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; request with long query information,</source>
          <target state="translated">클라이언트가 긴 쿼리 정보 를 사용하여 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 요청을 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 요청으로 잘못 변환 한 경우 ,</target>
        </trans-unit>
        <trans-unit id="e78f3c4320c633a180f739e552d98e82d2df26fb" translate="yes" xml:space="preserve">
          <source>when the client has descended into a loop of redirection (for example, a redirected URI prefix that points to a suffix of itself),</source>
          <target state="translated">클라이언트가 리디렉션 루프로 내려간 경우 (예 : 자체 접미사를 가리키는 리디렉션 된 URI 접두사)</target>
        </trans-unit>
        <trans-unit id="5b303e5a989fa1e2ccb9a667883bda27da57a397" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;&amp;lt;policy-directive&amp;gt;&lt;/code&gt; consists of: &lt;code&gt;&amp;lt;directive&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt; with no internal punctuation.</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;policy-directive&amp;gt;&lt;/code&gt; 는 내부 구두점이없는 &lt;code&gt;&amp;lt;directive&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt; 로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="773c160f129adf6e625d6ce76db69d1a8471728f" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;&amp;lt;referrer-policy&amp;gt;&lt;/code&gt; can be one of the following values:</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;referrer-policy&amp;gt;&lt;/code&gt; 는 다음 값 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d488f59d749ba9458ba76f4742f735ac2b6168af" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; can optionally be one of the following values:</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; 는 다음 값 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3dd7b31f7bdeaaa2cf5536534301410a606a911" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;responseTime&lt;/code&gt; is the time at which the response was received according to the browser.</source>
          <target state="translated">여기서 &lt;code&gt;responseTime&lt;/code&gt; 은 브라우저에 따라 응답이 수신 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="aac3546247ce5d86e97752180ca56a5ab36799af" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;responseTime&lt;/code&gt; is the time at which the response was received according to the browser. For more information see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;RFC 7234: Hypertext Transfer Protocol (HTTP/1.1): 4.2.2. Calculating Heuristic Freshness&lt;/a&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;responseTime&lt;/code&gt; 은 브라우저에 따라 응답이 수신 된 시간입니다. 자세한 내용은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;RFC 7234 : Hypertext Transfer Protocol (HTTP / 1.1) : 4.2.2를 참조하십시오. 휴리스틱 신선도 계산&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="590f28ad9bc49430eab2e507419f281ee9795369" translate="yes" xml:space="preserve">
          <source>while Chrome will display:</source>
          <target state="translated">Chrome은 다음을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d2dd615236b7f4609e0fcaab6fbb72ec0d8c88a9" translate="yes" xml:space="preserve">
          <source>will act like &lt;code&gt;'unsafe-inline' https:&lt;/code&gt; in browsers that support CSP1, &lt;code&gt;https: 'nonce-abcdefg'&lt;/code&gt; in browsers that support CSP2, and &lt;code&gt;'nonce-abcdefg' 'strict-dynamic'&lt;/code&gt; in browsers that support CSP3.</source>
          <target state="translated">같은 역할을 할 &lt;code&gt;'unsafe-inline' https:&lt;/code&gt; 브라우저를 지원하는 CSP1, &lt;code&gt;https: 'nonce-abcdefg'&lt;/code&gt; 브라우저를 지원하는 CSP2 및 &lt;code&gt;'nonce-abcdefg' 'strict-dynamic'&lt;/code&gt; 지원 CSP3이 브라우저는.</target>
        </trans-unit>
        <trans-unit id="5ec44f50f9e2adfdab15b700641eeb5edc1a3bb9" translate="yes" xml:space="preserve">
          <source>will act like&lt;code&gt;'unsafe-inline' https:&lt;/code&gt; in browsers that support CSP1, &lt;code&gt;https: 'nonce-abcdefg'&lt;/code&gt; in browsers that support CSP2, and &lt;code&gt;'nonce-abcdefg' 'strict-dynamic'&lt;/code&gt; in browsers that support CSP3.</source>
          <target state="translated">같은 역할을 할 &lt;code&gt;'unsafe-inline' https:&lt;/code&gt; 브라우저를 지원하는 CSP1, &lt;code&gt;https: 'nonce-abcdefg'&lt;/code&gt; 브라우저를 지원하는 CSP2 및 &lt;code&gt;'nonce-abcdefg' 'strict-dynamic'&lt;/code&gt; 지원 CSP3이 브라우저는.</target>
        </trans-unit>
        <trans-unit id="359146c2c0b7d880d78f123c47dec4aa164a5ce6" translate="yes" xml:space="preserve">
          <source>will allow to load flash objects:</source>
          <target state="translated">플래시 객체를로드 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5246145bb3df8bcca397eda2448c3a0611835895" translate="yes" xml:space="preserve">
          <source>will be the same as:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="561de84cc0d956b931b695e8e2431c1aa23812d2" translate="yes" xml:space="preserve">
          <source>will send this message:</source>
          <target state="translated">이 메시지를 보내드립니다 :</target>
        </trans-unit>
        <trans-unit id="754446b96fd5ff1ef295c19f7de2c8d1ec26d7f3" translate="yes" xml:space="preserve">
          <source>window.navigator.userAgent</source>
          <target state="translated">window.navigator.userAgent</target>
        </trans-unit>
        <trans-unit id="24c24db3d7a8c4f896163208864ed8cd2a48cf29" translate="yes" xml:space="preserve">
          <source>worker-src</source>
          <target state="translated">worker-src</target>
        </trans-unit>
        <trans-unit id="ce824584424244041990b810ac0e5f0b0dbf2319" translate="yes" xml:space="preserve">
          <source>ws/wss</source>
          <target state="translated">ws/wss</target>
        </trans-unit>
        <trans-unit id="4ff0b1538469338a0073e2cdaab6a517801b6ab4" translate="yes" xml:space="preserve">
          <source>year</source>
          <target state="translated">year</target>
        </trans-unit>
        <trans-unit id="fb360f9c09ac8c5edb2f18be5de4e80ea4c430d0" translate="yes" xml:space="preserve">
          <source>yes</source>
          <target state="translated">yes</target>
        </trans-unit>
        <trans-unit id="2e6411b0e9dcf17f3b4cb3384aeddeb300439036" translate="yes" xml:space="preserve">
          <source>yes, with the additional restriction that values can only be &lt;code&gt;0-9&lt;/code&gt;, &lt;code&gt;A-Z&lt;/code&gt;, &lt;code&gt;a-z&lt;/code&gt;, space or &lt;code&gt;*,-.;=&lt;/code&gt;.</source>
          <target state="translated">예, 값은 &lt;code&gt;0-9&lt;/code&gt; , &lt;code&gt;A-Z&lt;/code&gt; , &lt;code&gt;a-z&lt;/code&gt; , 공백 또는 &lt;code&gt;*,-.;=&lt;/code&gt; 만 가능하다는 추가 제한 사항이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3aced22ca673a8fdd9d2db6167a812ccc095c3e8" translate="yes" xml:space="preserve">
          <source>yes, with the additional restriction that values can't contain a &lt;em&gt;CORS-unsafe request header byte&lt;/em&gt;: 0x00-0x1F (except 0x09 (HT)), &lt;code&gt;&quot;():&amp;lt;&amp;gt;?@[\]{}&lt;/code&gt;, and 0x7F (DEL).</source>
          <target state="translated">예, 값에 &lt;em&gt;CORS 안전하지 않은 요청 헤더 바이트를&lt;/em&gt; 포함 할 수 없다는 추가 제한 사항 : 0x00-0x1F (0x09 (HT) 제외), &lt;code&gt;&quot;():&amp;lt;&amp;gt;?@[\]{}&lt;/code&gt; 및 0x7F (DEL) .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
