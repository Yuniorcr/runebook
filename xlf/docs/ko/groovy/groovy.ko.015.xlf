<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="groovy">
    <body>
      <group id="groovy">
        <trans-unit id="4e8a758e14e042fd44d1644b7c03d56755c84835" translate="yes" xml:space="preserve">
          <source>Subclasses should implement this method to provide good error resolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a548d0b5d2d73bb19fdf6f69c4cddfc9e8f4c9" translate="yes" xml:space="preserve">
          <source>Subclasses should implement this method to set the condition of the interruption statement</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32ab562220ed81620ccefa3948d1a774f1feaa20" translate="yes" xml:space="preserve">
          <source>Subclasses should implement this method whenever they need to perform special checks before the type checker starts working.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c68b5b9b049084fab1d00a3f47d9b682f70fb6da" translate="yes" xml:space="preserve">
          <source>Subclasses should implement this method, which returns the list of accepted closure signatures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa849d16a1883f2b020174ca4e3bb9a8a963f828" translate="yes" xml:space="preserve">
          <source>Subtract a Character from a Number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d501390aa64bdf2c9ae78827d17293277d1d079" translate="yes" xml:space="preserve">
          <source>Subtract a Character from a Number. The ordinal value of the Character is used in the subtraction (the ordinal value is the unicode value which for simple character sets is the ASCII value).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80739b5b536f0252ee4bb49d1cf80dec2291730b" translate="yes" xml:space="preserve">
          <source>Subtract a Number from a Character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2829709b208cdecbc2effaee1c43f216d0c4a2cd" translate="yes" xml:space="preserve">
          <source>Subtract a Number from a Character. The ordinal value of the Character is used in the subtraction (the ordinal value is the unicode value which for simple character sets is the ASCII value).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383c4da009f675500b7dc7ae0296938c1e09b8bf" translate="yes" xml:space="preserve">
          <source>Subtract a number of days from this Timestamp and returns the new Timestamp object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d746887164b2f5e92e086f6b38e7a5028ad395" translate="yes" xml:space="preserve">
          <source>Subtract a number of days from this date and returns the new date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b908a2b53a9eda97aea98291d46913fec1a195" translate="yes" xml:space="preserve">
          <source>Subtract another Date from this one and return the number of days of the difference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90df6944beb186ade6e01024eae5a9be3b4868ce" translate="yes" xml:space="preserve">
          <source>Subtract another date from this one and return the number of days of the difference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1d58f1e1cf47da6c54dce03b400e8ead47438d0" translate="yes" xml:space="preserve">
          <source>Subtract one Character from another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="670e4318f1084845e7f32b29745478fef01a079c" translate="yes" xml:space="preserve">
          <source>Subtract one Character from another. The ordinal values of the Characters is used in the comparison (the ordinal value is the unicode value which for simple character sets is the ASCII value).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8458189362e1f0efadb179882bea2588a89dea40" translate="yes" xml:space="preserve">
          <source>Subtract one date from the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="703b3f4be66eeba14f12112eb0178f45c56b038b" translate="yes" xml:space="preserve">
          <source>Subtraction of two Numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea77f38e191237c8467b9bbbbfa7a3c905eb071f" translate="yes" xml:space="preserve">
          <source>Successful retrievals using get(key) and containsKey(key) usually run without locking. Unsuccessful ones (i.e., when the key is not present) do involve brief synchronization (locking). Also, the size and isEmpty methods are always synchronized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31de501c849ff7913e8233a72f933ee4b40759b9" translate="yes" xml:space="preserve">
          <source>Sums all the given items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6906f65d4bdfb623c3779437b880666d674473e" translate="yes" xml:space="preserve">
          <source>Sums all the items from an array of items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b759da08d81e2982b18ab18cfecdb92173bfcad" translate="yes" xml:space="preserve">
          <source>Sums the items from an Iterator, adding the result to some initial value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3292936c4cef8a406dd185feb7f5e9f5ad4bb035" translate="yes" xml:space="preserve">
          <source>Sums the items from an Iterator, adding the result to some initial value. This is equivalent to invoking the &quot;plus&quot; method on all items from the Iterator. The iterator will become exhausted of elements after determining the sum value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44a8d4cb71f1a9055409cd78474fa859d6e1b627" translate="yes" xml:space="preserve">
          <source>Sums the items from an Iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0828ab8c0d5a6291096701a8058ed787770aa4" translate="yes" xml:space="preserve">
          <source>Sums the items from an Iterator. This is equivalent to invoking the &quot;plus&quot; method on all items from the Iterator. The iterator will become exhausted of elements after determining the sum value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f21ed49c9b3729a874e6b6213a3aec5f55f4984" translate="yes" xml:space="preserve">
          <source>Sums the items in an Iterable, adding the result to some initial value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="938cc031c32a0a74fedcea0fa2ea03bca7774e36" translate="yes" xml:space="preserve">
          <source>Sums the items in an Iterable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05846c3dab4dc24635cdc7e83333eed6761385f2" translate="yes" xml:space="preserve">
          <source>Sums the items in an Iterable. This is equivalent to invoking the &quot;plus&quot; method on all items in the Iterable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f97a9c084454b475824ce176a76670de5bc0260" translate="yes" xml:space="preserve">
          <source>Sums the items in an array, adding the result to some initial value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6bc758df7e10d60725d5fd562f4cb6320501f3" translate="yes" xml:space="preserve">
          <source>Sums the items in an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f12f8dae3d9539e78ab7a3595c0ec92646ea4e58" translate="yes" xml:space="preserve">
          <source>Sums the items in an array. This is equivalent to invoking the &quot;plus&quot; method on all items in the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef7fec05c6f7a205563842bf6c760293ede2e021" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterable to some initial value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c34756e7df8dbbbdc5ad7ddd3d79525b4cabde0" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterable to some initial value. &lt;code&gt;iter.sum(initVal, closure)&lt;/code&gt; is equivalent to: &lt;code&gt;iter.collect(closure).sum(initVal)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22f8d5b1e322146f614b91be417a32eb8dcd5b5" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9cded5e8db4a11cbc31f73eebe70a9d23e9f6e6" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterable. &lt;code&gt;coll.sum(closure)&lt;/code&gt; is equivalent to: &lt;code&gt;coll.collect(closure).sum()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2d6eeefd666db6fd3abb4f06450eaebc3703a21" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterator to some initial value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="138bf57a714ba157c5f8f2140c7144fec48bbd4d" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterator to some initial value. &lt;code&gt;iter.sum(initVal, closure)&lt;/code&gt; is equivalent to: &lt;code&gt;iter.collect(closure).sum(initVal)&lt;/code&gt;. The iterator will become exhausted of elements after determining the sum value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0cb69a7faef35e6438266153f8981b96cdb6d92" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an array to some initial value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45852392f7090c69aedbeec4ac994c8caed08176" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an array to some initial value. &lt;code&gt;array.sum(initVal, closure)&lt;/code&gt; is equivalent to: &lt;code&gt;array.collect(closure).sum(initVal)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46427b8197456a69d06f32a8b3afb429409c9174" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b46103f8e5006bdeea7f9c154e982c8ee536abd8" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an array. &lt;code&gt;array.sum(closure)&lt;/code&gt; is equivalent to: &lt;code&gt;array.collect(closure).sum()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dac66fb8810c157cd97e770e86c48d44f88a2152" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item returned from an iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="377052f5b33eac246887eb27e6c100d565eca611" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item returned from an iterator. &lt;code&gt;iter.sum(closure)&lt;/code&gt; is equivalent to: &lt;code&gt;iter.collect(closure).sum()&lt;/code&gt;. The iterator will become exhausted of elements after determining the sum value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="998c35057b1e937535f109c7111919f1f21ea66a" translate="yes" xml:space="preserve">
          <source>Support a 'least surprising' math model to scripting language users. This means that exact, or decimal math should be used for default calculations. This scheme assumes that by default, groovy literals with decimal points are instantiated as BigDecimal objects rather than binary floating points (Float, Double).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="300e75d2f3f2ad069bf75f6db0f8b032d657028b" translate="yes" xml:space="preserve">
          <source>Support assigning a range of values with a single assignment statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0573add916ac521520ae7e1a7edb406cc686a3" translate="yes" xml:space="preserve">
          <source>Support class for creating XML Factories</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0ac0e736b440225051252fb545f21a87af58be3" translate="yes" xml:space="preserve">
          <source>Support creating a new Date having similar properties to an existing Date (which remains unaltered) but with some fields updated according to a Map of changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="578fcb6595097c58dd9c3c70598121040321a782" translate="yes" xml:space="preserve">
          <source>Support for &lt;a href=&quot;command&quot;&gt;Command&lt;/a&gt; instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27e429f7d79185fd5fa7dcfde4e209338be3fe84" translate="yes" xml:space="preserve">
          <source>Support for Closure &quot;right&quot; currying.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd9aff9c96085971df147f0319c92592cb9998b5" translate="yes" xml:space="preserve">
          <source>Support for Closure &quot;right&quot; currying. Parameters are supplied on the right rather than left as per the normal curry() method. Typical usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07d27c73edc627e408cf52788f3cd8c2cee9798e" translate="yes" xml:space="preserve">
          <source>Support for Closure currying at a given index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77c240308ae9d403e4fdeb9fade24bf133f052c6" translate="yes" xml:space="preserve">
          <source>Support for Closure currying at a given index. Parameters are supplied from index position &quot;n&quot;. Typical usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86fbafb2c6a6ef08ae544def5ecd2f5d1a459fde" translate="yes" xml:space="preserve">
          <source>Support for Closure currying.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6701c883c98ccd374b2032b56f3cdf62e6bdcb1" translate="yes" xml:space="preserve">
          <source>Support for Closure forward composition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c9b5d31f5a9af4bcb77590911799ff25e785f9" translate="yes" xml:space="preserve">
          <source>Support for Closure reverse composition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cd464c7aa84c67ca4cf28f95af944bd7e5c8ae1" translate="yes" xml:space="preserve">
          <source>Support for Groovlets which are Servlets written as a simple Groovy script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="971f277b26127bb2b96f438a43258b36036a9c6e" translate="yes" xml:space="preserve">
          <source>Support for compilation related tasks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2712721bdf08058a3c0b6d90d89d52194d9c6991" translate="yes" xml:space="preserve">
          <source>Support for more complex commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c398c8c180a493660e7da708b15d770393473fcc" translate="yes" xml:space="preserve">
          <source>Support for running a &lt;a href=&quot;shell&quot;&gt;Shell&lt;/a&gt; interactively using the JLine library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7bd721822c04eca7566037be0ea0c447ce0bb1f" translate="yes" xml:space="preserve">
          <source>Support for running a &lt;a href=&quot;shell&quot;&gt;Shell&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e838211f110950da21190e2b4cd394331c2cfaad" translate="yes" xml:space="preserve">
          <source>Support for simple completers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1847ef28b474109bae86b9ff6f88f30c6d1cb1e" translate="yes" xml:space="preserve">
          <source>Support for simple completors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4cd4262c16597d35c917b71e4dacdb860118533" translate="yes" xml:space="preserve">
          <source>Support methods for &lt;a href=&quot;statictypecheckingvisitor&quot;&gt;StaticTypeCheckingVisitor&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b334e44ba370eeb1a9fcce805d296237600394b7" translate="yes" xml:space="preserve">
          <source>Support methods for DefaultGroovyMethods and PluginDefaultMethods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40274db933b81a98b5c697affa7d5c7f16fa92d3" translate="yes" xml:space="preserve">
          <source>Support methods for Groovy category usage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588dfb8cd9cca2180f8096de40629699cecfce75" translate="yes" xml:space="preserve">
          <source>Support mutating a Calendar with a Map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="606b6da19d3862e2b1d54033b51c6a674ad9524f" translate="yes" xml:space="preserve">
          <source>Support mutating a Date with a Map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0065fbb73dfe423e4f2b0b788b77b810d1895bf4" translate="yes" xml:space="preserve">
          <source>Support retrieving a subset of a BitSet using a Range</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cefe376baa46053e6ee5cd1185a7ec7bd5de75a2" translate="yes" xml:space="preserve">
          <source>Support subscript operator for list access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ce8c0aa36043dde1f96ca757bfc9ca258b03f47" translate="yes" xml:space="preserve">
          <source>Support subscript operator for list modification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="948555c5f9bb59c7e564313dae8e9e5e33359ef5" translate="yes" xml:space="preserve">
          <source>Support subscript-style assignment for a BitSet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="277c0c9a0992135998848b12d1623638750f1db0" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for StringBuilder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09c4c0a5e355d7aa584752cfc33a252f0a73e60e" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for StringBuilder. Index values are treated as characters within the builder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd26eb8b1a16f0820319830f663499ae85c68f8" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for a List.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="930099686e74d43336ccb036b84c0e5da6eec9e3" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for an Array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b999effc2096576e1c862e817448092036970953" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for an eager or lazy List.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8024a4e87a055ac0bfbf3a79248d3db4e937f9ff" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for ButtonGroup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8883233fb47d8a916e31ae51ad0682c85c140a3e" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for Collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="137e043d5266d133be830bee498a61305b08656b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for Container.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b736f7865baa83c1f6bc649704d426a52a785a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JComboBox.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a8136fdf49a95aaa951ea4ed67ec07e9acc80a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JMenu.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6bfb46585e8e0eabd4032848ef55c15306e4cd5" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JMenuBar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0c882c6cd60c5c1b40d2bd576e5c94a555b1c4a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JTabbedPane.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67f5eb23bb29271d8db04f6cc3958a10877bd86b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JToolBar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3edb03f1dbd6dbc567ef944a1323b4462a95935b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for ListModel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2b5237de01694410633b548a0f924fa610af129" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for TableColumnModel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26d8833306b343dfe6bb5e4ffca867bd20aad7e" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for TableModel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f63e2cb744c1c451ecc2c5de29107932d57249e8" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for TreeNode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b3703b70c5b77bb85b2a093946ef0c0693b3c5" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for TreePath.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82ca1dcdc1480532f560c6be7abbec186ccf6ee7" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a Bitset</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a337c06c56778b26331f5a920f766882be3b0493" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a Calendar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f7a0636dc8671f55b6f4130764c09c166c7835" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a Date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b96b77d4e05609bf5ebac837d1ea604f4bd48580" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a List.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18104f39e920408c5dbd3d2de4a52926a170a585" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a Map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7d5a370e14d88ca3b733df074745e512491e1b8" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for an Iterable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da54421b2475020061b3a47e604a37ada578e23a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for an Iterable. Typical usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b136f29e517965b9fab5e959f6e4c99faa02cbad" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for an Iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712e012634442f739e8d9439273ee6c5469514b8" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for an Iterator. The iterator will be partially exhausted up until the idx entry after returning if a +ve or 0 idx is used, or fully exhausted if a -ve idx is used or no corresponding entry was found. Typical usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05e1c675a16d28913679eb9bf33a6f3849996840" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for mutating a Calendar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3005a57b2f65de8b8ee3c9e383470c171c93a51" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for mutating a Calendar. Example usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0832f9dcf462ade3391f384e44f33f1d4a5d9801" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for mutating a Date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcdaffd8f1f395b917d10a9f7899c51471d965d2" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a boolean array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38960d85e9835053606b584f60047fc89487b81f" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a byte array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfdd8cbe5169c3fba3ea647b156633a848266f23" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a char array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90742627dc6eb2f9b4d8227c151fad8d57423b85" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a double array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39150a8bf39dcd107e1c51ddc573ad89d6269053" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a float array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e129074b798751ecffc90e0fd782beeab070ad2" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a long array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d242b1c1771299e2b79691a29aaefc7f993eb38" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a short array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="449fc6a9aae0653fc2a2dd933669712b98794a67" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for an int array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406c3c4313afad025dc0f000a9d36af8c01ef6dc" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a boolean array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb5575ed4428458ede0b0ffe18053e0022f2c8b6" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a byte array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e061d0f5fcf78a949d304e48051b333e3509a09b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a char array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d56f743158eb5c5d9a114b722ab2b8aa764c4884" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a double array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6bb5f77572817a5a2d27996636a61f948630a5" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a float array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad8c10b070d78470ed959ae01f3a4b6165c06ea0" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a long array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee52af5b564b8bd5b211088bca646f5f8706167a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a short array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fae014c47830c0263f0c70591acd2cb75401882" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for an int array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b1c738fc5421c1900cbcf82f77be491419f636" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a boolean array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="737a9dafe198558df1a051d1b235f28a914614a9" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a byte array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e85416ac1bef6482c8defff54899a74c630bad" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a char array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308844e7ffcdb4e852e6200501bf93b50edd1146" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a double array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8172d0a1db9a00b56b31db2555af86194397bdf" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a float array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d9f1a77baa8f3f7c7be70b2868cc3da8cbd873b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a long array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="846540f6464f33fa68fb5a18a1bdda484d94be1a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a short array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d49e4722c5856590c8457389b79e367a48336b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for an int array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="135d071ce0e747dd6c86c1f1ea6ff0bd031e49c8" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a byte array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="494432a9314d4c872a0569f09c6de99b5dacc87a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a char array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2efca516ac0e519470608b925ed538b8fb748e45" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a double array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a688426210c62de688f8dcf07f4c2ab964d91970" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a float array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ee30662b569f7f70c6b555a7b4769ca93dd7017" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a long array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92bb07165d787ba1a31571dfaf457860dd156cc3" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a short array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8f69636a462dfdae8f77c74465fe081dcc0144" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for an int array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e81c22dfff611d4ce5af5cc7d3ba8e087782c019" translate="yes" xml:space="preserve">
          <source>Supported syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29082ca330fc6abf963f95d250bbb9faa7ada8ea" translate="yes" xml:space="preserve">
          <source>Supports integer based subscript operators for accessing at numbered columns starting at zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685b4ee9fceb194e1bba657c003c3d9058d640a0" translate="yes" xml:space="preserve">
          <source>Supports integer based subscript operators for accessing at numbered columns starting at zero. Negative indices are supported, they will count from the last column backwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8a1dffb79c3a58bf51ad444252e384308031a1f" translate="yes" xml:space="preserve">
          <source>Supports integer based subscript operators for updating the values of numbered columns starting at zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9040372ef64134ed11c8ca3980f52a75c335178" translate="yes" xml:space="preserve">
          <source>Supports integer based subscript operators for updating the values of numbered columns starting at zero. Negative indices are supported, they will count from the last column backwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e121e3a40b35411dcbf80ace25a2cab09c6a9d81" translate="yes" xml:space="preserve">
          <source>Supports integer-based subscript operators for accessing at numbered columns starting at zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6650b1b6bbaec3d498660928194e1e004714a8ee" translate="yes" xml:space="preserve">
          <source>Supports integer-based subscript operators for accessing at numbered columns starting at zero. Negative indices are supported, they will count from the last column backwards.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6892c78c1164bf275bea2cf843d7c79de2a8d05" translate="yes" xml:space="preserve">
          <source>Supports only the five basic XML entities (gt, lt, quot, amp, apos)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272482f4c74fef3dcf775ef6e04d38a838b4eddf" translate="yes" xml:space="preserve">
          <source>Supports the division operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#dividedBy(long)&quot;&gt;Duration.dividedBy&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e3256613e913c27b4d30572865fb8f14dba9d45" translate="yes" xml:space="preserve">
          <source>Supports the getAt operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/ZoneOffset.html#getLong(java.time.temporal.TemporalField)&quot;&gt;ZoneOffset.getLong&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d1b992b51a3b320adfa7435877250915682a88b" translate="yes" xml:space="preserve">
          <source>Supports the getAt operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAccessor.html#getLong(java.time.temporal.TemporalField)&quot;&gt;TemporalAccessor.getLong&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45b564a7490c0cfc9ab37fb49992105cbdffd741" translate="yes" xml:space="preserve">
          <source>Supports the getAt operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAmount.html#get(TemporalUnit)&quot;&gt;TemporalAmount.get&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fbf8412864ed83f47c19fb2de0ad38b4c2d88bb" translate="yes" xml:space="preserve">
          <source>Supports the multiplication operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#multipliedBy(long)&quot;&gt;Duration.multipliedBy&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c58b6034a8cda0cb4caab3bc1a085313bf5131d" translate="yes" xml:space="preserve">
          <source>Supports the multiply operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html#multipliedBy(int)&quot;&gt;Period.multipliedBy&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f12770c32aa35e5994877bee4b25b602e3e93f3" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for CharSequence or StringBuffer with EmptyRange</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d8232579b8962a2f78045b849d8783bfeba70b" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for CharSequence with IntRange.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="734ac83eea03aa14f6f645cbb62c57d5ebc7a7cb" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for CharSequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c17ccd565eec637aeb61b93388e26907f417969" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for GString with IntRange.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2de30284c9a0e8fcec0804002be4e2ae2ec22240" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for GString.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c21234956f0cebc724e038773b6489ec986cabd2" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for String with IntRange.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30590a771f8986708ccb6659f99345ce35751d79" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for String.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87567806977a560b8169c7b6d539bc7ee1adcfbc" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for StringBuffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5b5e33b1e927360d37b9e7aff1c489178f6ab28" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for StringBuffer. Index values are treated as characters within the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="603e946fa86fe6630cb7e4e41deba0896a06b13b" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for StringBuilder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f1d48bcdcf4c5ad55799e7efb5332d2c727357" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for StringBuilder. Index values are treated as characters within the builder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3868e5ccdf1c52b1bcae61cb67a1658a621b670" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for a GPathResult.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="847373efea045010884a5921e02aeb3939071729" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator for CharSequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="643bb4275fc8f901b11dbe657ab42dacee233538" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator for GString.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c14c15e33602a664d9d6717e5a114f93eff3f995" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator for String.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eeaf121a846e73418ed8bb3f658e4d50c2b1ac6" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator for a GPathResult.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5e7d8728bc31a020c837e7346295444cfb639ed" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d6e6526a6efcf42b637b3fee8333d2c42dfe8a" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator, e.g. &lt;code&gt;matcher[index]&lt;/code&gt;, for a &lt;code&gt;Matcher&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b24a8e67655e2d3680c8d291f8d695bc52b8deef" translate="yes" xml:space="preserve">
          <source>Supports the unary minus operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#negated()&quot;&gt;Duration.negated&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef16973534d92d25c8ba950c50ef216e3d129c99" translate="yes" xml:space="preserve">
          <source>Supports the unary minus operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html#negated()&quot;&gt;Period.negated&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1984ff7448bd1530fcb00a669677ddf234ba06" translate="yes" xml:space="preserve">
          <source>Supports the unary plus operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#abs()&quot;&gt;Duration.abs&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9671c499c2b0eccb12ed3d9fb0e71ffb8f89feef" translate="yes" xml:space="preserve">
          <source>Supports the unary plus operator; returns a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html&quot;&gt;Period&lt;/a&gt; with all unit values positive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2b3726eac67d7b17290df48a691ab6648c417ac" translate="yes" xml:space="preserve">
          <source>Supports the unary plus operator; returns a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html&quot;&gt;Period&lt;/a&gt; with all unit values positive. For example, a period of &quot;2 years, -3 months, and -4 days&quot; would result in a period of &quot;2 years, 3 months, and 4 days.&quot; No normalization is performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444b203ece3ce0e7f35d5c0aef68426d9b0d431c" translate="yes" xml:space="preserve">
          <source>Swaps two elements at the specified positions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11d786b4e23376ea3dc79c4c0a88541bba21feca" translate="yes" xml:space="preserve">
          <source>Swing application to graphically display the tokens produced by the lexer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a505d05672b9c632c10baf50232815e236897342" translate="yes" xml:space="preserve">
          <source>SwingBuilder helper classes for creating components</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4d5fef0fd56423d2005b5f23fc72bafc05788b9" translate="yes" xml:space="preserve">
          <source>Switches the builder's proxyBuilder during the execution of a closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d654f8f369be41ce70e791e599030be1914b8e6" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;a href=&quot;#toSpreadMap(java.util.Map)&quot;&gt;toSpreadMap(java.util.Map)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bf9b65aa3eb7662090be9b911189d54f126ea4c" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;code&gt;compile(Phases.ALL)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e7d4ec9c98e022a28f28595845ab382d8e7b30" translate="yes" xml:space="preserve">
          <source>Synonym for full compilation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922c2e5f4ef255d4058e512453e827f08ec07983" translate="yes" xml:space="preserve">
          <source>Synonym for write(text) allowing file.text = 'foo'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f6827d49ab5f403cdd18485a48da06676e323d" translate="yes" xml:space="preserve">
          <source>Synonym for write(text, charset) allowing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38259ff21e4eb435a46c701dcdd29b24d58b4a78" translate="yes" xml:space="preserve">
          <source>Syntax supported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1de8dba368e7754dc199c99b017f5c51265ee8dc" translate="yes" xml:space="preserve">
          <source>Syntax:</source>
          <target state="translated">Syntax:</target>
        </trans-unit>
        <trans-unit id="92f3ec2c7d54e41b31652ea8927f4cb0fe0d53b2" translate="yes" xml:space="preserve">
          <source>SyntaxErrorReportable</source>
          <target state="translated">SyntaxErrorReportable</target>
        </trans-unit>
        <trans-unit id="989982c92d7d7b069cc494d871290c6c79dd1bea" translate="yes" xml:space="preserve">
          <source>System.currentTimeMillis</source>
          <target state="translated">System.currentTimeMillis</target>
        </trans-unit>
        <trans-unit id="52f9440d82aa136e8330aac61d5581f83dc6cf89" translate="yes" xml:space="preserve">
          <source>Systematically generate permutations. Adapted from Java Code by Michael Gilleland (released with no restrictions) using an algorithm described here: Kenneth H. Rosen, Discrete Mathematics and Its Applications, 2nd edition (NY: McGraw-Hill, 1991), pp. 282-284</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab1fd1e591a63e3e5e200ee8fa3c5a14d2c00db" translate="yes" xml:space="preserve">
          <source>T foo(){}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe6d0b31eb59e6ac337f0b92f98cb3ad502463c" translate="yes" xml:space="preserve">
          <source>TODO Get list of groovydoc tags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="921b6844ab03e31995729bfc75953f8eac7378a3" translate="yes" xml:space="preserve">
          <source>TODO parse groovydoc to get tag content</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4ba86ffe7ca973bae787f6414c279df51d0ddf5" translate="yes" xml:space="preserve">
          <source>TODO: Should return the URI for this source, but we can't know what it is here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf93c98946db5510058c27414ea744e90e3279d8" translate="yes" xml:space="preserve">
          <source>TODO: experimental!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3657c9335058621e4530f335028b3958464c5aa9" translate="yes" xml:space="preserve">
          <source>TODO: experimental! Annotates an AST node with matching contraints. This method should be called on an AST intended to be used as a pattern only. It will put node metadata on the AST node allowing customized behavior in pattern matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1c7a681e02f969b203ba3592fa54d2c692bbb52" translate="yes" xml:space="preserve">
          <source>TableCellEditor</source>
          <target state="translated">TableCellEditor</target>
        </trans-unit>
        <trans-unit id="57561c4bfa715cb5f4cf7c5dbfce29a5881d0950" translate="yes" xml:space="preserve">
          <source>TableModelListener</source>
          <target state="translated">TableModelListener</target>
        </trans-unit>
        <trans-unit id="5d7cbdd762e595f129150b280be1165c581c52dc" translate="yes" xml:space="preserve">
          <source>Takes a statement and wraps it into a block statement which first element is the interruption check statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354438b5f2c2435d85aef9e5e1d521b569efa655" translate="yes" xml:space="preserve">
          <source>Takes a zero based index and convert it into an SQL based 1 based index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="041aa4646c123f7952eaab5d26bd55d6a7709b46" translate="yes" xml:space="preserve">
          <source>Takes a zero based index and convert it into an SQL based 1 based index. A negative index will count backwards from the last column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e15a873cff2714be38f04fe3477dcbcb571d1e" translate="yes" xml:space="preserve">
          <source>Takes the characters between nth (specified by occurrence) pair of &lt;code&gt;enclosure&lt;/code&gt; strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fdd5b94d50723024ee61c7a3f2a6df16695a3b8" translate="yes" xml:space="preserve">
          <source>Takes the characters between the first occurrence of the two subsequent &lt;code&gt;enclosure&lt;/code&gt; strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f5401efdd15336ecf28fb95881261864d11cc09" translate="yes" xml:space="preserve">
          <source>Takes the last ?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad0f94b3f2dd848f00aba4d7d9abd45a61b5b02" translate="yes" xml:space="preserve">
          <source>Takes the last ? tokens of the list that form a simple expression, evaluates it and returns a result. &quot;Simple&quot; means evaluation is known to be side-effect free.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c304b15ae8ce0d2e4f76ba2ec779635f48eea681" translate="yes" xml:space="preserve">
          <source>Target.class</source>
          <target state="translated">Target.class</target>
        </trans-unit>
        <trans-unit id="7a099fd78212cd2ae28a2ff9a08f499c9dc92e4d" translate="yes" xml:space="preserve">
          <source>TargetBinding</source>
          <target state="translated">TargetBinding</target>
        </trans-unit>
        <trans-unit id="da5a824ba0bd242c7a60e17970f2791dec54d4ab" translate="yes" xml:space="preserve">
          <source>Tells if a class is one of the &quot;accept all&quot; classes as the left hand side of an assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e09ff464218acfb2c73af0f0dc15dbca113a8c2" translate="yes" xml:space="preserve">
          <source>Tells if a class node is candidate for class literal bytecode optimization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05493540c669c245f9637bf19d526e8d21f77a68" translate="yes" xml:space="preserve">
          <source>Tells if a class node is candidate for class literal bytecode optimization. If so, bytecode may use LDC instructions instead of static constant Class fields to retrieve class literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1d9bbbc3e04be119c70847b1f19b96ddd5a0d78" translate="yes" xml:space="preserve">
          <source>Tells if an input string matches a token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd4940f1c01e2547dee0d64e72579a3db1df3a96" translate="yes" xml:space="preserve">
          <source>Tells if the given string is a valid Java identifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bf831a8ad75f4c75e56aee27a3bdb1640b165c2" translate="yes" xml:space="preserve">
          <source>Tells if this variable or the accessed variable is used in a closure context, like in the following example :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5816f31fd183aa07200a002c77102dff5452d37" translate="yes" xml:space="preserve">
          <source>Template engine configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e12b935685180af8ae3137efb7001cba2cd17832" translate="yes" xml:space="preserve">
          <source>Template engine for use in templating scenarios where both the template source and the expected output are intended to be XML.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef204f5f3596e2d30194001a07b4928b1a3949d3" translate="yes" xml:space="preserve">
          <source>TemplateEngine.createTemplate</source>
          <target state="translated">TemplateEngine.createTemplate</target>
        </trans-unit>
        <trans-unit id="dbf0ac726f3831ef2074d859816b327c66ed2b43" translate="yes" xml:space="preserve">
          <source>TemplateResolver</source>
          <target state="translated">TemplateResolver</target>
        </trans-unit>
        <trans-unit id="4436c0fa899dfbc2356893b025763c65d2d5384e" translate="yes" xml:space="preserve">
          <source>TemplateServlet.initTemplateEngine</source>
          <target state="translated">TemplateServlet.initTemplateEngine</target>
        </trans-unit>
        <trans-unit id="e593dd8801cfc67b3cac7df9ad54ee66fd2a486b" translate="yes" xml:space="preserve">
          <source>TemplateServlet.setVariables</source>
          <target state="translated">TemplateServlet.setVariables</target>
        </trans-unit>
        <trans-unit id="891b3675d27a4138af5360bd35bb314e25b67789" translate="yes" xml:space="preserve">
          <source>Templates may use the normal '${expression}' and '$variable' notations to insert an arbitrary expression into the template. In addition, support is also provided for special tags: &amp;lt;gsp:scriptlet&amp;gt; (for inserting code fragments) and &amp;lt;gsp:expression&amp;gt; (for code fragments which produce output).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00122ac4f85694e5831e7199490968568e2ab42e" translate="yes" xml:space="preserve">
          <source>Terence Parr parrt@magelang.com John Lilley jlilley@empathy.com Scott Stanchfield thetick@magelang.com Markus Mohnen mohnen@informatik.rwth-aachen.de Peter Williams pete.williams@sun.com Allan Jacobs Allan.Jacobs@eng.sun.com Steve Messick messick@redhills.com James Strachan jstrachan@protique.com John Pybus john@pybus.org John Rose rose00@mac.com Jeremy Rayner groovy@ross-rayner.com Alex Popescu the.mindstorm@gmail.com Martin Kempf mkempf@hsr.ch Reto Kleeb rkleeb@hsr.ch Version 1.00 December 9, 1997 -- initial release Version 1.01 December 10, 1997 fixed bug in octal def (0..7 not 0..8) Version 1.10 August 1998 (parrt) added tree construction fixed definition of WS,comments for mac,pc,unix newlines added unary plus Version 1.11 (Nov 20, 1998) Added &quot;shutup&quot; option to turn off last ambig warning. Fixed inner class def to allow named class defs as statements synchronized requires compound not simple statement add [] after builtInType DOT class in primaryExpression &quot;const&quot; is reserved but not valid..removed from modifiers Version 1.12 (Feb 2, 1999) Changed LITERAL_xxx to xxx in tree grammar. Updated java.g to use tokens {...} now for 2.6.0 (new feature). Version 1.13 (Apr 23, 1999) Didn't have (stat)? for else clause in tree parser. Didn't gen ASTs for interface extends. Updated tree parser too. Updated to 2.6.0. Version 1.14 (Jun 20, 1999) Allowed final/abstract on local classes. Removed local interfaces from methods Put instanceof precedence where it belongs...in relationalExpr It also had expr not type as arg; fixed it. Missing ! on SEMI in classBlock fixed: (expr) + &quot;string&quot; was parsed incorrectly (+ as unary plus). fixed: didn't like Object[].class in parser or tree parser Version 1.15 (Jun 26, 1999) Screwed up rule with instanceof in it. :( Fixed. Tree parser didn't like (expr).something; fixed. Allowed multiple inheritance in tree grammar. oops. Version 1.16 (August 22, 1999) Extending an interface built a wacky tree: had extra EXTENDS. Tree grammar didn't allow multiple superinterfaces. Tree grammar didn't allow empty var initializer: {} Version 1.17 (October 12, 1999) ESC lexer rule allowed 399 max not 377 max. java.tree.g didn't handle the expression of synchronized statements. Version 1.18 (August 12, 2001) Terence updated to Java 2 Version 1.3 by observing/combining work of Allan Jacobs and Steve Messick. Handles 1.3 src. Summary: o primary didn't include boolean.class kind of thing o constructor calls parsed explicitly now: see explicitConstructorInvocation o add strictfp modifier o missing objBlock after new expression in tree grammar o merged local class definition alternatives, moved after declaration o fixed problem with ClassName.super.field o reordered some alternatives to make things more efficient o long and double constants were not differentiated from int/float o whitespace rule was inefficient: matched only one char o add an examples directory with some nasty 1.3 cases o made Main.java use buffered IO and a Reader for Unicode support o supports UNICODE? Using Unicode charVocabulary makes code file big, but only in the bitsets at the end. I need to make ANTLR generate unicode bitsets more efficiently. Version 1.19 (April 25, 2002) Terence added in nice fixes by John Pybus concerning floating constants and problems with super() calls. John did a nice reorg of the primary/postfix expression stuff to read better and makes f.g.super() parse properly (it was METHOD_CALL not a SUPER_CTOR_CALL). Also: o &quot;finally&quot; clause was a root...made it a child of &quot;try&quot; o Added stuff for asserts too for Java 1.4, but *commented out* as it is not backward compatible. Version 1.20 (October 27, 2002) Terence ended up reorging John Pybus' stuff to remove some nondeterminisms and some syntactic predicates. Note that the grammar is stricter now; e.g., this(...) must be the first statement. Trinary ?: operator wasn't working as array name: (isBig ? bigDigits : digits)[i]; Checked parser/tree parser on source for Resin-2.0.5, jive-2.1.1, jdk 1.3.1, Lucene, antlr 2.7.2a4, and the 110k-line jGuru server source. Version 1.21 (October 17, 2003) Fixed lots of problems including: Ray Waldin: add typeDefinition to interfaceBlock in java.tree.g He found a problem/fix with floating point that start with 0 Ray also fixed problem that (int.class) was not recognized. Thorsten van Ellen noticed that \n are allowed incorrectly in strings. TJP fixed CHAR_LITERAL analogously. Version 1.21.2 (March, 2003) Changes by Matt Quail to support generics (as per JDK1.5/JSR14) Notes: o We only allow the &quot;extends&quot; keyword and not the &quot;implements&quot; keyword, since that's what JSR14 seems to imply. o Thanks to Monty Zukowski for his help on the antlr-interest mail list. o Thanks to Alan Eliasen for testing the grammar over his Fink source base Version 1.22 (July, 2004) Changes by Michael Studman to support Java 1.5 language extensions Notes: o Added support for annotations types o Finished off Matt Quail's generics enhancements to support bound type arguments o Added support for new for statement syntax o Added support for static import syntax o Added support for enum types o Tested against JDK 1.5 source base and source base of jdigraph project o Thanks to Matt Quail for doing the hard part by doing most of the generics work Version 1.22.1 (July 28, 2004) Bug/omission fixes for Java 1.5 language support o Fixed tree structure bug with classOrInterface - thanks to Pieter Vangorpto for spotting this o Fixed bug where incorrect handling of SR and BSR tokens would cause type parameters to be recognised as type arguments. o Enabled type parameters on constructors, annotations on enum constants and package definitions o Fixed problems when parsing if ((char.class.equals(c))) {} - solution by Matt Quail at Cenqua Version 1.22.2 (July 28, 2004) Slight refactoring of Java 1.5 language support o Refactored for/&quot;foreach&quot; productions so that original literal &quot;for&quot; literal is still used but the for sub-clauses vary by token type o Fixed bug where type parameter was not included in generic constructor's branch of AST Version 1.22.3 (August 26, 2004) Bug fixes as identified by Michael Stahl; clean up of tabs/spaces and other refactorings o Fixed typeParameters omission in identPrimary and newStatement o Replaced GT reconcilliation code with simple semantic predicate o Adapted enum/assert keyword checking support from Michael Stahl's java15 grammar o Refactored typeDefinition production and field productions to reduce duplication Version 1.22.4 (October 21, 2004) Small bux fixes o Added typeArguments to explicitConstructorInvocation, e.g. new</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a1454ddc5de44915d242d03aefb2a12bcfe0fe" translate="yes" xml:space="preserve">
          <source>Terence Parr parrt@magelang.com John Lilley jlilley@empathy.com Scott Stanchfield thetick@magelang.com Markus Mohnen mohnen@informatik.rwth-aachen.de Peter Williams pete.williams@sun.com Allan Jacobs Allan.Jacobs@eng.sun.com Steve Messick messick@redhills.com John Pybus john@pybus.org Version 1.00 December 9, 1997 -- initial release Version 1.01 December 10, 1997 fixed bug in octal def (0..7 not 0..8) Version 1.10 August 1998 (parrt) added tree construction fixed definition of WS,comments for mac,pc,unix newlines added unary plus Version 1.11 (Nov 20, 1998) Added &quot;shutup&quot; option to turn off last ambig warning. Fixed inner class def to allow named class defs as statements synchronized requires compound not simple statement add [] after builtInType DOT class in primaryExpression &quot;const&quot; is reserved but not valid..removed from modifiers Version 1.12 (Feb 2, 1999) Changed LITERAL_xxx to xxx in tree grammar. Updated java.g to use tokens {...} now for 2.6.0 (new feature). Version 1.13 (Apr 23, 1999) Didn't have (stat)? for else clause in tree parser. Didn't gen ASTs for interface extends. Updated tree parser too. Updated to 2.6.0. Version 1.14 (Jun 20, 1999) Allowed final/abstract on local classes. Removed local interfaces from methods Put instanceof precedence where it belongs...in relationalExpr It also had expr not type as arg; fixed it. Missing ! on SEMI in classBlock fixed: (expr) + &quot;string&quot; was parsed incorrectly (+ as unary plus). fixed: didn't like Object[].class in parser or tree parser Version 1.15 (Jun 26, 1999) Screwed up rule with instanceof in it. :( Fixed. Tree parser didn't like (expr).something; fixed. Allowed multiple inheritance in tree grammar. oops. Version 1.16 (August 22, 1999) Extending an interface built a wacky tree: had extra EXTENDS. Tree grammar didn't allow multiple superinterfaces. Tree grammar didn't allow empty var initializer: {} Version 1.17 (October 12, 1999) ESC lexer rule allowed 399 max not 377 max. java.tree.g didn't handle the expression of synchronized statements. Version 1.18 (August 12, 2001) Terence updated to Java 2 Version 1.3 by observing/combining work of Allan Jacobs and Steve Messick. Handles 1.3 src. Summary: o primary didn't include boolean.class kind of thing o constructor calls parsed explicitly now: see explicitConstructorInvocation o add strictfp modifier o missing objBlock after new expression in tree grammar o merged local class definition alternatives, moved after declaration o fixed problem with ClassName.super.field o reordered some alternatives to make things more efficient o long and double constants were not differentiated from int/float o whitespace rule was inefficient: matched only one char o add an examples directory with some nasty 1.3 cases o made Main.java use buffered IO and a Reader for Unicode support o supports UNICODE? Using Unicode charVocabulay makes code file big, but only in the bitsets at the end. I need to make ANTLR generate unicode bitsets more efficiently. Version 1.19 (April 25, 2002) Terence added in nice fixes by John Pybus concerning floating constants and problems with super() calls. John did a nice reorg of the primary/postfix expression stuff to read better and makes f.g.super() parse properly (it was METHOD_CALL not a SUPER_CTOR_CALL). Also: o &quot;finally&quot; clause was a root...made it a child of &quot;try&quot; o Added stuff for asserts too for Java 1.4, but *commented out* as it is not backward compatible. Version 1.20 (October 27, 2002) Terence ended up reorging John Pybus' stuff to remove some nondeterminisms and some syntactic predicates. Note that the grammar is stricter now; e.g., this(...) must be the first statement. Ternary ?: operator wasn't working as array name: (isBig ? bigDigits : digits)[i]; Checked parser/tree parser on source for Resin-2.0.5, jive-2.1.1, jdk 1.3.1, Lucene, antlr 2.7.2a4, and the 110k-line jGuru server source. Version 1.21 (October 17, 2003) Fixed lots of problems including: Ray Waldin: add typeDefinition to interfaceBlock in java.tree.g He found a problem/fix with floating point that start with 0 Ray also fixed problem that (int.class) was not recognized. Thorsten van Ellen noticed that \n are allowed incorrectly in strings. TJP fixed CHAR_LITERAL analogously. Version 1.21.2 (March, 2003) Changes by Matt Quail to support generics (as per JDK1.5/JSR14) Notes: o We only allow the &quot;extends&quot; keyword and not the &quot;implements&quot; keyword, since that's what JSR14 seems to imply. o Thanks to Monty Zukowski for his help on the antlr-interest mail list. o Thanks to Alan Eliasen for testing the grammar over his Fink source base Version 1.22 (July, 2004) Changes by Michael Studman to support Java 1.5 language extensions Notes: o Added support for annotations types o Finished off Matt Quail's generics enhancements to support bound type arguments o Added support for new for statement syntax o Added support for static import syntax o Added support for enum types o Tested against JDK 1.5 source base and source base of jdigraph project o Thanks to Matt Quail for doing the hard part by doing most of the generics work Version 1.22.1 (July 28, 2004) Bug/omission fixes for Java 1.5 language support o Fixed tree structure bug with classOrInterface - thanks to Pieter Vangorpto for spotting this o Fixed bug where incorrect handling of SR and BSR tokens would cause type parameters to be recognised as type arguments. o Enabled type parameters on constructors, annotations on enum constants and package definitions o Fixed problems when parsing if ((char.class.equals(c))) {} - solution by Matt Quail at Cenqua Version 1.22.2 (July 28, 2004) Slight refactoring of Java 1.5 language support o Refactored for/&quot;foreach&quot; productions so that original literal &quot;for&quot; literal is still used but the for sub-clauses vary by token type o Fixed bug where type parameter was not included in generic constructor's branch of AST Version 1.22.3 (August 26, 2004) Bug fixes as identified by Michael Stahl; clean up of tabs/spaces and other refactorings o Fixed typeParameters omission in identPrimary and newStatement o Replaced GT reconciliation code with simple semantic predicate o Adapted enum/assert keyword checking support from Michael Stahl's java15 grammar o Refactored typeDefinition production and field productions to reduce duplication Version 1.22.4 (October 21, 2004) Small bux fixes o Added typeArguments to explicitConstructorInvocation, e.g. new</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="22d23f24cd32f09242a53db536a945808560295a" translate="yes" xml:space="preserve">
          <source>Test if a method call is recursive if called within a given method node. Handles static calls as well. Currently known simplifications:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ceac294319c34b3b08934255a2a46a704ab7aeb" translate="yes" xml:space="preserve">
          <source>Test to determine if a ClassNode is a primitive type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9403cb8e3b09787aa434a66b33f9f48728feb7eb" translate="yes" xml:space="preserve">
          <source>Test to determine if a ClassNode is a primitive type. Note: this only works for ClassNodes created using a predefined ClassNode</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efcab8f5a7c0064e3a92f17428182ce215e6823b" translate="yes" xml:space="preserve">
          <source>Test to determine if a ClassNode is a type belongs to the list of types which are allowed to initialize constants directly in bytecode instead of using &amp;lt;cinit&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="317d6297ac6952a296eb2ddc257fdae5db4c3acc" translate="yes" xml:space="preserve">
          <source>Tests given value against specified type and changes generics of result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="063eb35b9befe3464dd713e416056ece4259e856" translate="yes" xml:space="preserve">
          <source>Tests given value against specified type and changes generics of result. This is equivalent to: &lt;code&gt;self.filter(it -&amp;gt; it instanceof Type).map(it -&amp;gt; (Type) it)&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="297a33c2b3cbe7da16caded2f3d349714f069bd6" translate="yes" xml:space="preserve">
          <source>Tests if a node is an inner class node, and if it is, then checks if the enclosing method is skipped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="328ba89482a1987881d000e13d7f357f23c9b1d6" translate="yes" xml:space="preserve">
          <source>Tests if groovydoc is present</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb815736873e34454c94811223e0a4810394010" translate="yes" xml:space="preserve">
          <source>Tests if some key maps into the specified value in this table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="add0ba96e90c01761791705826395fed0f349dba" translate="yes" xml:space="preserve">
          <source>Tests if some key maps into the specified value in this table. This operation is more expensive than the &lt;code&gt;containsKey&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e5b79dd75c69804ac69d0b591a74c9eee88301c" translate="yes" xml:space="preserve">
          <source>Tests if the specified object is a key in this table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3838caffb4fd461c7b1a0ac5808c7ae0ee8b59" translate="yes" xml:space="preserve">
          <source>Tests if this CharSequence ends with any specified suffixes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea9b3965b823036214967b36b37dd1a8b716789" translate="yes" xml:space="preserve">
          <source>Tests if this CharSequence is blank.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49212f1b5b77fc1ba50dd42e242f061373833989" translate="yes" xml:space="preserve">
          <source>Tests if this CharSequence starts with any specified prefixes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86c27bae4e49a7c791a1aae1f78c196c87814064" translate="yes" xml:space="preserve">
          <source>Tests if this QName matches another object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ac416154eaf4d481cc125feddea58871c1256c2" translate="yes" xml:space="preserve">
          <source>Tests this QName for equality with another object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9cf2cef79fdf0aa5b76a94b1b479b909d61f565" translate="yes" xml:space="preserve">
          <source>Tests whether the provided class implements MBean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c0a04fe736541754976f6a02d03fdc39f9ee64b" translate="yes" xml:space="preserve">
          <source>Tests whether the provided class implements MBean. It uses the following runes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04001d250c417c421d5d967c360fc90b35f68b2e" translate="yes" xml:space="preserve">
          <source>Text processing helpers for the interactive command line terminal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb34f30402043e44ae32896d840ce387a4b09777" translate="yes" xml:space="preserve">
          <source>That will produce the following output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="ff58e4d37ea3d39dfbb57350dad837205a5b260f" translate="yes" xml:space="preserve">
          <source>The &quot;Ruby-style&quot; new conversions occur automatically unless the 'auto=false' flag is given when using the annotation. You might do this if you create a new method using meta programming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abaf21fddf45033ab2c9f43f7104088d40814a57" translate="yes" xml:space="preserve">
          <source>The &quot;load&quot; command will add the given file or path to the classpath in this configuration object. If the path does not exist, the path will be ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c60ab597093e621854305c3505f5719eaec2ffc7" translate="yes" xml:space="preserve">
          <source>The &quot;main is&quot; part may only be once in the file. The String afterwards is the name of a class with a main method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12e2ad9f4f40932144714a1460d03531ba22986d" translate="yes" xml:space="preserve">
          <source>The &quot;str&quot; variable is closure shared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c847cbc1e1b5981b8a03d4b15cf1bf15d40091e2" translate="yes" xml:space="preserve">
          <source>The &quot;str&quot; variable is closure shared. The variable expression inside the closure references an accessed variable &quot;str&quot; which must have the closure shared flag set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39940fc40491b10b14c8b07773b7fb0c04450a6e" translate="yes" xml:space="preserve">
          <source>The &quot;~&quot; character can be used to represent the user's home directory. It cannot fully complete to other users' homes in all operating systems, since java does not provide any way of determining that easily, but it will attempt a simplistic approach.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a052786f73a4f92e76bad5f0c863ba3cd193790a" translate="yes" xml:space="preserve">
          <source>The 'alias' command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40024a2623baca4354e986fca884b143a6cc6c9f" translate="yes" xml:space="preserve">
          <source>The 'clear' command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b1cbc87993f31ce6273cefc6205a16b17b91a61" translate="yes" xml:space="preserve">
          <source>The 'display' command. Displays the current buffer (e.g. while method declaration was not finished).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49f40f12151358c7d843d53687ed095e487a154e" translate="yes" xml:space="preserve">
          <source>The 'doc' command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc3ffba03d00f8c7b85d7091a061031e0b1eb2b0" translate="yes" xml:space="preserve">
          <source>The 'edit' command. Opens Editor to write into the current Buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3f7c1cec23633cc0cfaa9cb09f02911a1e9d149" translate="yes" xml:space="preserve">
          <source>The 'exit' command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="046ba041acd9691591b162277d1a0f7106c9bb51" translate="yes" xml:space="preserve">
          <source>The 'forClass' annotation attribute for the &lt;code&gt;@Builder&lt;/code&gt; transform isn't applicable for this strategy. The 'useSetters' annotation attribute for the &lt;code&gt;@Builder&lt;/code&gt; transform is ignored by this strategy which always uses setters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45835faea7523426faaaf8fa1e49229a32a26b8c" translate="yes" xml:space="preserve">
          <source>The 'grab' command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="205fbf3975b12113a5c8bd8232bfa1665e8d1f5c" translate="yes" xml:space="preserve">
          <source>The 'help' command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ec27c9e0ddbd2a48fb1d21fc610eca2f90fc72" translate="yes" xml:space="preserve">
          <source>The 'history' command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d489d33aa47e12f822416973b70f3e5da0b4497" translate="yes" xml:space="preserve">
          <source>The 'import' command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8ac89c1c05e64fcbd55e0b499745677ba943e0" translate="yes" xml:space="preserve">
          <source>The 'inspect' command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551c33d159644a8f5ef1c6ac388343537009ae2b" translate="yes" xml:space="preserve">
          <source>The 'load' command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6bc21ba2f0a2893871757da3c856326ee9de094" translate="yes" xml:space="preserve">
          <source>The 'purge' command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba59fbb5346c40fbb6302c6187328e618a3da7ed" translate="yes" xml:space="preserve">
          <source>The 'record' command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c3791604975b9d1fb30c9a2bd534192e00088a0" translate="yes" xml:space="preserve">
          <source>The 'register' command. Registers a class as a new groovysh command. Requires the command to have matching constructors (shell) or (shell, name, alias).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c14b48e8d21dde57913f41162e2eb4486751ed" translate="yes" xml:space="preserve">
          <source>The 'save' command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a925ff93968b41e2b76e842b170f7ec6c6d9eb0" translate="yes" xml:space="preserve">
          <source>The 'set' command, used to set preferences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f931e78f8e44eb712f74c86f1afb6c2a241148eb" translate="yes" xml:space="preserve">
          <source>The 'shadow' command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a09c2bfc8378532d9a0032fb6ba7ae84db4fe0b" translate="yes" xml:space="preserve">
          <source>The 'show' command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a59faad4653d2f4a8eeb438184148004e01411e2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;closure#resolveStrategy&quot;&gt;Closure.resolveStrategy&lt;/a&gt; used by the closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bb77833997045b8a169e0e940948f5de47f4a41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@AutoExternalize&lt;/code&gt; transform is implemented as a combination of the &lt;code&gt;@ExternalizeMethods&lt;/code&gt; and &lt;code&gt;@ExternalizeVerifier&lt;/code&gt; transforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45203388f4746d69eda07f4e8e18ce996ab3c42d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@Builder&lt;/code&gt; AST transformation is used to help write classes that can be created using &lt;em&gt;fluent&lt;/em&gt; api calls. The transform supports multiple building strategies to cover a range of cases and there are a number of configuration options to customize the building process. In addition, a number of annotation attributes let you customise the building process. Not all annotation attributes are supported by all strategies. See the individual strategy documentation for more details. If you're an AST hacker, you can also define your own strategy class. The following strategies are bundled with Groovy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="294af73d6b365f57dad5fbc1d213db079ecf007c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@Canonical&lt;/code&gt; meta-annotation combines the &lt;code&gt;@EqualsAndHashCode&lt;/code&gt;, &lt;code&gt;@ToString&lt;/code&gt; and &lt;code&gt;@TupleConstructor&lt;/code&gt; annotations. It is used to assist in the creation of mutable classes. It instructs the compiler to execute AST transformations which add positional constructors, equals, hashCode and a pretty print toString to your class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0722e38b1652aaa50007eeaae20094f5d8fdb78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@EqualsAndHashCode&lt;/code&gt; annotation instructs the compiler to execute an AST transformation which adds the necessary equals and hashCode methods to the class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256900570749f03c52bd249de8a600a89e77be38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@Immutable&lt;/code&gt; meta-annotation corresponds to adding the following annotations: &lt;a href=&quot;tostring&quot;&gt;ToString&lt;/a&gt;, &lt;a href=&quot;equalsandhashcode&quot;&gt;EqualsAndHashCode&lt;/a&gt;, &lt;a href=&quot;immutablebase&quot;&gt;ImmutableBase&lt;/a&gt;, &lt;a href=&quot;immutableoptions&quot;&gt;ImmutableOptions&lt;/a&gt;, &lt;a href=&quot;propertyoptions&quot;&gt;PropertyOptions&lt;/a&gt;, &lt;a href=&quot;tupleconstructor&quot;&gt;TupleConstructor&lt;/a&gt;, &lt;a href=&quot;mapconstructor&quot;&gt;MapConstructor&lt;/a&gt; and &lt;a href=&quot;knownimmutable&quot;&gt;KnownImmutable&lt;/a&gt;. Together these annotations instruct the compiler to execute the necessary transformations to add the necessary getters, constructors, equals, hashCode and other helper methods that are typically written when creating immutable classes with the defined properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b3e01603be93f6ac5cc7246179a9d14cdfcb6f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@Immutable&lt;/code&gt; transformation in earlier versions of Groovy tried to be smart in the case of an immutable class with a single HashMap property, the supplied Map constructor tried to be compatible with both expected tuple behavior and expected named-argument behavior by peeking into the supplied map and guessing as to which approach might be applicable. Recent versions of Groovy now allow both &lt;code&gt;@TupleConstructor&lt;/code&gt; and &lt;code&gt;@MapConstructor&lt;/code&gt; annotations to co-exist which provide's a more flexible solution to this problem. While more flexible, the new approach isn't fully compatible with the previous approach. If for some reason you need the old behavior, you can try this property handler. Some features of the new approach won't be available to you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8038db35abbd1b507d6ae9f58cbd615d327ce3a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@ImmutableBase&lt;/code&gt; annotation supports customization using &lt;code&gt;@PropertyOptions&lt;/code&gt; which allows a custom property handler to be defined. This is most typically used behind the scenes by the &lt;code&gt;@Immutable&lt;/code&gt; meta-annotation but you can also define your own handler. If a custom handler is present, it will determine the code generated for the getters and setters of any property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d660a9beb8629948ffda2454e012fd620ba319c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@MapConstructor&lt;/code&gt; annotation generates a public constructor unless an applicable &lt;a href=&quot;visibilityoptions&quot;&gt;VisibilityOptions&lt;/a&gt; annotation is also present. It can be useful to change the visibility if you want to also create a builder or provide your own static factory method for object creation. You can make the constructor private and access it from the builder or your factory method. (Note: you'll probably want to use &lt;code&gt;@CompileStatic&lt;/code&gt; in conjunction with such an approach since dynamic Groovy currently gives the ability to access even private constructors.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c060668381620633145cbb9ddc60d4b01c27127" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@MapConstructor&lt;/code&gt; annotation instructs the compiler to execute an AST transformation which adds the necessary constructor method to your class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d30fb89bfdef972798dad631327fddec3510e19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@MapConstructor&lt;/code&gt; annotation supports customization using &lt;code&gt;@PropertyOptions&lt;/code&gt; which allows a custom property handler to be defined. This is most typically used behind the scenes by the &lt;code&gt;@Immutable&lt;/code&gt; meta-annotation but you can also define your own handler. If a custom handler is present, it will determine the code generated when initializing any property (or field).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a6deaa7aa228067bb49f0cfb27c83f7ba76b6ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@TupleConstructor&lt;/code&gt; annotation generates a public constructor unless an applicable &lt;a href=&quot;visibilityoptions&quot;&gt;VisibilityOptions&lt;/a&gt; annotation is also present. It can be useful to change the visibility if you want to also create a builder or provide your own static factory method for object creation. You can make the constructor private and access it from the builder or your factory method. (Note: you'll probably want to use &lt;code&gt;@CompileStatic&lt;/code&gt; in conjunction with such an approach since dynamic Groovy currently gives the ability to access even private constructors.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7629884aa207cf4bfc51ba4ddfb30667cd6e46a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@TupleConstructor&lt;/code&gt; annotation instructs the compiler to execute an AST transformation which adds the necessary constructor method to your class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8727009d134e37d65711ed260dc01f84627258d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@TupleConstructor&lt;/code&gt; annotation supports customization using &lt;code&gt;@PropertyOptions&lt;/code&gt; which allows a custom property handler to be defined. This is most typically used behind the scenes by the &lt;code&gt;@Immutable&lt;/code&gt; meta-annotation but you can also define your own handler. If a custom handler is present, it will determine the code generated when initializing any property (or field).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9da3c536494482e7240624f6308d8ee06c6f86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LineColumnReader&lt;/code&gt; is an extension to &lt;code&gt;BufferedReader&lt;/code&gt; that keeps track of the line and column information of where the cursor is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b12d0acf730deb6bf7ba2f89201e89542b2f1843" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equals()&lt;/code&gt; method compares the values of the individual properties (and optionally fields) of the class. It can also optionally call equals on the super class. Two different equals method implementations are supported both of which support the equals contract outlined in the javadoc for &lt;code&gt;java.lang.Object&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="830e28331ecb056779521290049a9d298a9e660d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hashCode()&lt;/code&gt; method is calculated using Groovy's &lt;code&gt;HashCodeHelper&lt;/code&gt; class which implements an algorithm similar to the one outlined in the book &lt;em&gt;Effective Java&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e63d7611eab2d457e68aebe6268ff6c3ef50435" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;node&lt;/code&gt; variable refers to the AST node where the AST test annotation is put. In the previous example, it means that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80313a71d12f637fc87968a63153d3f3e87a0de9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefix&lt;/code&gt; annotation attribute can be used to create setters with a different naming convention, e.g. with the prefix set to the empty String, you would use your setters as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62dadbb05ea9452a3f8698171e4c3c5adf50c815" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefix&lt;/code&gt; annotation attribute can be used to create setters with a different naming convention. The default is the empty string but you could change that to &quot;set&quot; as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e7da8f8ac1f58f269f14f2223d6021171e84d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefix&lt;/code&gt; annotation attribute, which defaults to the empty String for this strategy, can be used to create setters with a different naming convention, e.g. with the &lt;code&gt;prefix&lt;/code&gt; changed to 'set', you would use your setters as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="530333b1471c9924eaa79d5f2383b3a99efb7aa0" translate="yes" xml:space="preserve">
          <source>The ASM api version to use when loading/parsing classes, and generating proxy adapter classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eacac5260137714b68dfd32df8448636a7cd8c2e" translate="yes" xml:space="preserve">
          <source>The AST transformations state data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc5bdb44ecff5ba8f2ac6aeacb93c47323537a4b" translate="yes" xml:space="preserve">
          <source>The AnnotationCollector can be used to define aliases for groups of annotations. The Alias needs to be a class or annotation annotated with AnnotationCollector, otherwise nothing is required. The alias will be replaced on the AST level and will never appear in later. Any members of the class or annotation will be ignored, but could be used by a custom processor. Annotation arguments are mapped to the aliased annotations if existing. Should the default processor not be able to map one of the arguments and error will be given. Is this not wished or if you want a different mapping a custom processor has to be used. There are two ways of using the alias. The first way is by providing the annotations as list/array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5db2cc4cf1581ed432c22532522a07af4f3dc21e" translate="yes" xml:space="preserve">
          <source>The AstBuilder &quot;from code&quot; approach is used with a single Closure parameter. This transformation converts the ClosureExpression back into source code and rewrites the AST so that the &quot;from string&quot; builder is invoked on the source. In order for this to work, the closure source must be given a goto label. It is the &quot;from string&quot; approach's responsibility to remove the BlockStatement created by the label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba44980ebcb878656a29fe22ac4f96efa9fe21fd" translate="yes" xml:space="preserve">
          <source>The AstBuilder provides several ways to build an abstract syntax tree (AST) of Groovy code. You can convert a String into AST using the buildFromString method. You can convert code into AST using the buildFromCode method. You can use the AST DSL with the buildFromSpec method. For more information, see the resources on the Groovy wiki pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dab7488dc458ebefa3af6c5f3c52ee882f8cbada" translate="yes" xml:space="preserve">
          <source>The Boolean value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c8b0170c089fc67b7592e8b879b1010a6efb451" translate="yes" xml:space="preserve">
          <source>The Class of the caller</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5ebdb121347917420d0529564950593f68fffa" translate="yes" xml:space="preserve">
          <source>The Class of the matched caller, or null if there aren't enough stackframes to satisfy matchLevel</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95afa2b448d534d00f17faabf8897f23ba200f8d" translate="yes" xml:space="preserve">
          <source>The ClassLoader to use during processing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b325fd56fcb36df68df5c37735a434ab8c3e5a2" translate="yes" xml:space="preserve">
          <source>The Closure and Class MetaClasses are not replaceable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f74d6daad2d2751944e6a7ff0057497d3e5b83e" translate="yes" xml:space="preserve">
          <source>The CompilationUnit collects all compilation data as it is generated by the compiler system. You can use this object to add additional source units to the compilation, or force the compilation to be run again (to affect only the deltas).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ae7fb01344a3870d231b2e7c5bef8b061d095f8" translate="yes" xml:space="preserve">
          <source>The ConfigObject instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d6344f85a9a90bbe2e3c76743d0dab1644efa3" translate="yes" xml:space="preserve">
          <source>The GPathResult instance created by consuming a stream of SAX events Note if one of the parse methods has been called then this returns null Note if this is called more than once all calls after the first will return null</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1403f3f787db7ae0a251e57befceef1c173042a" translate="yes" xml:space="preserve">
          <source>The Generated annotation is used to mark members that have been generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fee67b5a59c37f5eb850f04f216505b0ee5359f8" translate="yes" xml:space="preserve">
          <source>The Groovyc Ant task is frequently used in the context of a build system that knows the complete list of source files to be compiled. In such a context, it is wasteful for the Groovy compiler to go searching the classpath when looking for source files and hence by default the Groovyc Ant task calls the compiler in a special mode with such searching turned off. If you wish the compiler to search for source files then you need to set this flag to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a572e6d63360dc8ed46fe486e95453148a82ab3" translate="yes" xml:space="preserve">
          <source>The I/O container for the command to spit stuff out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eac464c463300041620f1317542a0b36de1c9f1" translate="yes" xml:space="preserve">
          <source>The Inspector provides a unified access to an object's information that can be determined by introspection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89049d18696c55626bdc93e465d8d30137733d5c" translate="yes" xml:space="preserve">
          <source>The Internal annotation is used to mark members that are internal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9590c78dcd06317a3989b6bc16c6e0ac5dd7bc8d" translate="yes" xml:space="preserve">
          <source>The JDBC data type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf1f48ddb64e5b808db4de3d772bd99c631f4770" translate="yes" xml:space="preserve">
          <source>The JDK Home to use when forked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3cddd13c50bb85bd71529142341665bd0b10ae0" translate="yes" xml:space="preserve">
          <source>The JDK Home to use when forked. Ignored if &quot;executable&quot; is specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73a1a508d0e588f700050a09964ef490424aaf02" translate="yes" xml:space="preserve">
          <source>The JSON builder implements the &lt;code&gt;Writable&lt;/code&gt; interface, so that you can have the builder serialize itself the JSON payload to a writer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4210607df0d96c450f5b18b723cad635f89b1b1" translate="yes" xml:space="preserve">
          <source>The Java class enhanced by this MetaClass</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ac137cd80780692f3c909dfbfd354042b337fa0" translate="yes" xml:space="preserve">
          <source>The JavaBean class should have a no-args constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd439d1414bf7dc6b93f52c0dc2f310499844e0e" translate="yes" xml:space="preserve">
          <source>The JmxBeanInfoManager creates fully-described model mbean info object using the underlying meta map. The MBeanInfo object is used to provide description about the actual exported MBean instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="872c671635593eaadcddb9effd4d01a4ea959ded" translate="yes" xml:space="preserve">
          <source>The JmxBuilderModelMBean is the MBean class that proxies exported POGO/POJO inside the MBeanServer. When JmxBuilder exports an object instance, an instance of this class is created and exported inside the MBeanServer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f935c6274b761a9b967dde493b59c201774e5020" translate="yes" xml:space="preserve">
          <source>The JmxEventEmitter is a JMX Broadcaster class that is used to send generic events on the MBeanServer's event bus. It is used by the Emitter node () to send event to registered listeners.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d08957bff2b6ad91314499adc0b8343bea9d846" translate="yes" xml:space="preserve">
          <source>The JmxEventListener class is used by the builder to listen to events on the event bus. It is used internally by JmxBuilder to handle attribute-change and operation-invoke events on the bean() node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="791c37595668d995bb3f7137a2837e7869f379f8" translate="yes" xml:space="preserve">
          <source>The JmxMetaMapBuilder class is used to collect meta data passed in JmxBuilder nodes. Once collected, the data is then normalized to be represented uniformly regardless of the resource where it was obtained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1cf8f8fe2a9841c47ea577375d10ab0b3a498ec" translate="yes" xml:space="preserve">
          <source>The JmxTimerFactory class generates a timer() node for JmxBuilder. This node crates a standard JMX Timer object that can be used to provide timing signals to registered JMX listeners.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1015aa5213030445b24890b5298e5c4b7fb29c4" translate="yes" xml:space="preserve">
          <source>The MetaClass</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70b9f38afa55b20e2322eb7214953e5ce4ce9d61" translate="yes" xml:space="preserve">
          <source>The MetaClass instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="260db7c9ae9624cfa33762fdc9180e7061158fff" translate="yes" xml:space="preserve">
          <source>The MetaClassCreationHandle instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="304ce5f140b19a7e8c2ce15e0bd65caaaee29466" translate="yes" xml:space="preserve">
          <source>The MetaProperty or null if it doesn't exist</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7243e642f153efeb15b0cd45bbbcf1e34d8e7b86" translate="yes" xml:space="preserve">
          <source>The Number corresponding to the addition of left and right</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa3b37e69477a774d6c510b9eeda86f2a333e6a" translate="yes" xml:space="preserve">
          <source>The Object can either be an instance of the class that this MetaObjectProtocol instance applies to or the java.lang.Class instance itself. If a method cannot be invoked a MissingMethodException is will be thrown</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01609e35830c98cb8147ed0a154760cc0327e1b" translate="yes" xml:space="preserve">
          <source>The PrintWriter to write the &lt;a href=&quot;#usage&quot;&gt;usage&lt;/a&gt; help message to when &lt;code&gt;cli.usage()&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ad7cb19c2bb4b46ecbb881cff1abf5fe7f4037b" translate="yes" xml:space="preserve">
          <source>The PrintWriter to write the &lt;a href=&quot;#usage&quot;&gt;usage&lt;/a&gt; help message to when &lt;code&gt;cli.usage()&lt;/code&gt; is called. Defaults to stdout but you can provide your own PrintWriter if desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c0b48403b15a903f91f5257a20030e1e3b89f0" translate="yes" xml:space="preserve">
          <source>The PrintWriter to write to when invalid user input was provided to the &lt;a href=&quot;#parse(java.lang.String)&quot;&gt;parse(java.lang.String[])&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127ae9cbb960e452f7333cb76a15c3f3dcc5fd90" translate="yes" xml:space="preserve">
          <source>The PrintWriter to write to when invalid user input was provided to the &lt;a href=&quot;#parse(java.lang.String)&quot;&gt;parse(java.lang.String[])&lt;/a&gt; method. Defaults to stderr but you can provide your own PrintWriter if desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a802aa7bf26ec7a1cc42a344ad8a273e764c485" translate="yes" xml:space="preserve">
          <source>The Swing component being edited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb2fc7e68bc1e57e68935cf223ed7a03e6b0e67" translate="yes" xml:space="preserve">
          <source>The System Property to set as a filename excludes pattern for collection of Classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a1909fe3c15f658c03287f53b875168b744419d" translate="yes" xml:space="preserve">
          <source>The System Property to set as a filename excludes pattern for collection of Classes. When non-empty, the pattern will be used as Regular Expression pattern applied with the find operator against each candidate file.path. Key is &quot;javadocAssertion.src.excludesPattern&quot;. Default value is &quot;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e2f804b26b209506ffe905e468265879b10275e" translate="yes" xml:space="preserve">
          <source>The System Property to set as a filename excludes pattern for collection of Test Cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b63561856de11fdd61e36dc53031f4a4c5c9997a" translate="yes" xml:space="preserve">
          <source>The System Property to set as a filename excludes pattern for collection of Test Cases. When non-empty, the pattern will be used as Regular Expression pattern applied with the find operator against each candidate file.path. Key is &quot;groovy.test.excludesPattern&quot;. Default value is &quot;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b09e49327c616d7dfdf39837fa8bd53af76f55" translate="yes" xml:space="preserve">
          <source>The System Property to set as base directory for collection of Classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eeea8df2c671b1aaf1f285764880655e10de1e1" translate="yes" xml:space="preserve">
          <source>The System Property to set as base directory for collection of Classes. The pattern will be used as an Ant fileset include basedir. Key is &quot;javadocAssertion.src.dir&quot;. Defaults to the &lt;code&gt;./src&lt;/code&gt; directory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bf415e47865f7516d23e95370920077c48370ee" translate="yes" xml:space="preserve">
          <source>The System Property to set as base directory for collection of Test Cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31447f96bb70b187e7844f2b264f55c03201f601" translate="yes" xml:space="preserve">
          <source>The System Property to set as base directory for collection of Test Cases. The pattern will be used as an Ant fileset include basedir. Key is &quot;groovy.test.dir&quot;. Default value is &quot;./test/&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="266958bc55466288051a176e383496d4feb92e74" translate="yes" xml:space="preserve">
          <source>The System Property to set as the filename pattern for collection of Classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a90fedae02d009a3ffad52f02ac8b7d11b8745b" translate="yes" xml:space="preserve">
          <source>The System Property to set as the filename pattern for collection of Classes. The pattern will be used as Regular Expression pattern applied with the find operator against each candidate file.path. Key is &quot;javadocAssertion.src.pattern&quot;. Defaults to including all &lt;code&gt;.java&lt;/code&gt; and &lt;code&gt;.groovy&lt;/code&gt; files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0000bd75ba6a74e57ac9cf53044c50c3c9d010ff" translate="yes" xml:space="preserve">
          <source>The System Property to set as the filename pattern for collection of Test Cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="998db7b8bbfcee3c949aa177d7b90b7dfdb69720" translate="yes" xml:space="preserve">
          <source>The System Property to set as the filename pattern for collection of Test Cases. The pattern will be used as Regular Expression pattern applied with the find operator against each candidate file.path. Key is &quot;groovy.test.pattern&quot;. Default value is &quot;Test.groovy&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84337e91be9e8ef75be1d04b6fdba516cbd8151f" translate="yes" xml:space="preserve">
          <source>The TimeUnit of the value parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="718e7ae897428930781dc6de636d2e594031a23c" translate="yes" xml:space="preserve">
          <source>The TimeUnit of the value parameter. By default it is TimeUnit.SECONDS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c92a8a6f01fd8d4e068bc1d01714e753c4596b32" translate="yes" xml:space="preserve">
          <source>The URL for a repo containing the grape/artifact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de6a560d5da664892b518e4682d24979363ecddc" translate="yes" xml:space="preserve">
          <source>The URL for a repo containing the grape/artifact. A non-empty value is required unless value() is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6aadb5f5ba9e2b129360252950ed1939f90ac0b" translate="yes" xml:space="preserve">
          <source>The URL pattern does not require the &quot;*.groovy&quot; mapping. You can, for example, make it more Struts-like but groovy by making your mapping &quot;*.gdo&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adca94d915cd2e4151b8eb5471618fdec37d9c2b" translate="yes" xml:space="preserve">
          <source>The XML template engine can also be used as the engine for &lt;a href=&quot;../servlet/templateservlet&quot;&gt;TemplateServlet&lt;/a&gt; by placing the following in your web.xml file (plus a corresponding servlet-mapping element):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9495cf1739a07e775ac543e8d0f74d2f8dd5b54" translate="yes" xml:space="preserve">
          <source>The YAML builder implements the &lt;code&gt;Writable&lt;/code&gt; interface, so that you can have the builder serialize itself the YAML payload to a writer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a412e1e1d8cd3a68e2efff325b41048db7ad21bd" translate="yes" xml:space="preserve">
          <source>The above example prints this to standard output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec91d8d1308de75b03d0376ac9545cec66180c83" translate="yes" xml:space="preserve">
          <source>The above example will generate code that is similar to the next snippet. Notice the difference between a String property and a def/Object property:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b257bfac16ef28eecdac4b554708ae5f69748970" translate="yes" xml:space="preserve">
          <source>The actual number of characters skipped</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="052bfa45246c41d68e26ad806f4e38a47fba851d" translate="yes" xml:space="preserve">
          <source>The alternative supported style regards any kind of inheritance as creation of a new type and is illustrated in the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bdb04cd00d0c115ee207c0ae5337f0b546086bb" translate="yes" xml:space="preserve">
          <source>The annotated Collection field must have a generic type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aceff9ab81f781b7ab6d9e62431c1055127d2723" translate="yes" xml:space="preserve">
          <source>The annotated Collection field must not have a generic wildcard declared</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e547ff00f70b525a9f0ec9c47c86f3334dc81ae" translate="yes" xml:space="preserve">
          <source>The annotated variable will become a private field of the script class. The type of the field will be the same as the type of the variable. Example usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f318a85f6a5756ab184456f34f3ce55011832330" translate="yes" xml:space="preserve">
          <source>The annotation being referenced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c20ea5b9d49bb4d3079400f6c7b508d5ddfe6c4" translate="yes" xml:space="preserve">
          <source>The annotation can be placed at the class level in which case it applies to all methods, constructors, and closures within the class and any inner classes. It can also be applied to an individual method, constructor, field with a Closure initial value or a Closure assigned to a local variable. In the case of fields (or local variables) it only adjusts the parameters of the referenced Closure not the field (or local variable) itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9517f13d3119a99ae37232e6f8925dc3dc606f99" translate="yes" xml:space="preserve">
          <source>The annotation can be used on a whole class as shown above or selectively on a particular method, constructor or field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dcd4f54b47563f3bd43966ca8e9a4fbea0a7944" translate="yes" xml:space="preserve">
          <source>The annotation can take the following parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f750d18a3b109b97c136361abf51e190db88be" translate="yes" xml:space="preserve">
          <source>The annotation is intended to be used sparingly; perhaps in DSL scenarios or when using deeply nested structural types. In particular, there is no support for using the facility with two similarly named classes from different packages at the same time. Though it is OK to have different packages in different contexts. Also, there is no support for turning &quot;Ruby-style&quot; conversions off at the method, constructor or field level if already turned on at the class level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3190b6c4518ac7ad1bc48cdc3e3e48499552b444" translate="yes" xml:space="preserve">
          <source>The annotation takes an optional parameter for the name of the field. This field must exist on the class and must be of type ReentrantReadWriteLock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2a41c58f84b983c4307e184fcf2882ccbdc7cf" translate="yes" xml:space="preserve">
          <source>The attribute value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd9423271c2e0be1493ebeaf945a08093f8a561f" translate="yes" xml:space="preserve">
          <source>The attribute values of annotations must be primitive, String or Enum constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e91a7321fc7ae255dea783ee8a8e3fd6aea9d2cb" translate="yes" xml:space="preserve">
          <source>The attribute values of annotations must be primitive, String or Enum constants. In various places, such constants can be seen during type resolution but won't be readily accessible in later phases, e.g. they might be embedded into constructor code. This method transforms constants that would appear in annotations early so they aren't lost. Subsequent processing determines whether they are valid, this method simply retains the constant value as a constant expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba9d0f179fb12288dcac51469b2a074466e2e0af" translate="yes" xml:space="preserve">
          <source>The average of all of the items</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70783273967fb37a38f643afd98e6b9187891321" translate="yes" xml:space="preserve">
          <source>The average of the items</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8395f1aa4e19271ad68a33fd7315e6d494f3ac12" translate="yes" xml:space="preserve">
          <source>The average of the values returned by applying the closure to each item from the Iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eb091fbf86b30307fd9a7fb7c9aaa700930da46" translate="yes" xml:space="preserve">
          <source>The average of the values returned by applying the closure to each item of the Iterable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9801aab1db27901fd7a9be59509eda4d8846c8" translate="yes" xml:space="preserve">
          <source>The average of the values returned by applying the closure to each item of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bbf0434c30c3cf5371d3ed8bebd25d1c43ff05a" translate="yes" xml:space="preserve">
          <source>The bind path object. This class represents one &quot;step&quot; in the bind path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4408519a715193017dfb9b02caa80e83767ca7d0" translate="yes" xml:space="preserve">
          <source>The binding also provides convenient methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8a6a5839bf78280f2f5d8f72a3b8f0dac48502" translate="yes" xml:space="preserve">
          <source>The binding provided by TemplateServlet does already include some default variables. As of this writing, they are (copied from &lt;a href=&quot;servletbinding&quot;&gt;ServletBinding&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="170305b27b6f2f428a171b71d8192fdfc6377fe8" translate="yes" xml:space="preserve">
          <source>The cached class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3de13709d4a99443765990411d8804e7d936d4c5" translate="yes" xml:space="preserve">
          <source>The call should be invoked separately</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed53e69261b2dc331e4fdcb563927c92a857a5a" translate="yes" xml:space="preserve">
          <source>The character read, as an integer in the range 0 to 65535 (0x00-0xffff), or -1 if the end of the stream has been reached</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b1006004394eb9f2a6da42ea7c5b946608b286e" translate="yes" xml:space="preserve">
          <source>The character used to split a single command line argument into parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e358d3e84c4ddc0c51dee898e085378748c11c44" translate="yes" xml:space="preserve">
          <source>The check works &lt;b&gt;only for options &lt;b&gt;one&lt;/b&gt; block below the current block. E.g. &lt;code&gt;config.isSet('foo.password')&lt;/code&gt; will always return false. &lt;dl&gt;
&lt;dt&gt;&lt;b&gt;Parameters:&lt;/b&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;code&gt;option&lt;/code&gt; - The name of the option&lt;/dd&gt;
&lt;/dl&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;b&gt;Returns:&lt;/b&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;code&gt;true&lt;/code&gt; if the option is set &lt;code&gt;false&lt;/code&gt; otherwise&lt;/dd&gt;
&lt;/dl&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;b&gt;Since:&lt;/b&gt;&lt;/dt&gt;
&lt;dd&gt;2.3.0&lt;/dd&gt;
&lt;/dl&gt; &lt;/b&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12f6e1d7ed0f1c99877990e1030d0f1489d503a8" translate="yes" xml:space="preserve">
          <source>The class contained by this metaclass</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02889e40310a5938acf27d4e92b62a80c8bb0b34" translate="yes" xml:space="preserve">
          <source>The class is automatically made final.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d55ce426f3bc5d724c2889dfa22ff395fbda6a39" translate="yes" xml:space="preserve">
          <source>The class passed as a constructor parameter must be an AST transformation annotation. Alternatively, you can apply a global AST transformation by calling the &lt;a href=&quot;asttransformationcustomizer#ASTTransformationCustomizer(org.codehaus.groovy.transform.ASTTransformation)&quot;&gt;AST transformation&lt;/a&gt;. In that case, the transformation is applied once for the whole source unit. Unlike a global AST transformation declared in the META-INF/services/org.codehaus.groovy.transform.ASTTransformation file, which are applied if the file is in the classpath, using this customizer you'll have the choice to apply your transformation selectively. It can also be useful to debug global AST transformations without having to package your annotation in a jar file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cad1da7d481a03ef9916a2ff7d8844930ea3cea" translate="yes" xml:space="preserve">
          <source>The classifier if in use, e.g.: &quot;jdk14&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca27fb66cfe5fba5a9ac754d02a9f29c0105033f" translate="yes" xml:space="preserve">
          <source>The classpath as URL[] from this configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d1bf1f2d2c67f0aae89b6c3bc480661749348cd" translate="yes" xml:space="preserve">
          <source>The classpath as URL[] from this configuration. This can be used to construct a class loader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3926225e9f00ef4ebec16fbc04d966c7fe2b75" translate="yes" xml:space="preserve">
          <source>The closure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="479f86662ac269b97cc2d894e9bac34d9794dd34" translate="yes" xml:space="preserve">
          <source>The closure code is executed after the specified phase has completed. If no phase is provided, then the code is executed after the &lt;a href=&quot;../../org/codehaus/groovy/control/compilephase#SEMANTIC_ANALYSIS&quot;&gt;semantic analysis&lt;/a&gt; phase and each subsequent phase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7e22c2e0c44fd389e3b41fde1dda05fedb35439" translate="yes" xml:space="preserve">
          <source>The closure is wrapped in a thread, and the thread is started immediately, only if the current thread is the EDT, otherwise the closure will be called immediately.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a119bbf2479d278c5b03976bf4d331b5a07a07" translate="yes" xml:space="preserve">
          <source>The closure must accept either 1 or 2 parameters. The first parameter is required and will be instance of the &lt;code&gt;type&lt;/code&gt; for which the closure is registered. The second optional parameter should be of type &lt;code&gt;String&lt;/code&gt; and, if available, will be passed the name of the key associated with this value if serializing a JSON Object. This parameter will be &lt;code&gt;null&lt;/code&gt; when serializing a JSON Array or when there is no way to determine the name of the key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ac82819478a5008a16cf393ea1fa535e93de24" translate="yes" xml:space="preserve">
          <source>The closure will be called with a single argument; the database statement (actually a &lt;code&gt;BatchingStatementWrapper&lt;/code&gt; helper object) associated with this batch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae8cb3c86be077ae32b3b768d99be03b18c7b824" translate="yes" xml:space="preserve">
          <source>The closure will be called with a single argument; the prepared statement (actually a &lt;code&gt;BatchingPreparedStatementWrapper&lt;/code&gt; helper object) associated with this batch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae276d6aaf9c3b8bb8aacf648ffb3e07a64cd0f" translate="yes" xml:space="preserve">
          <source>The column.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a31b50dfe2f995289113fae596103f2b81d59f" translate="yes" xml:space="preserve">
          <source>The command synopsis displayed as the first line in the usage help message, e.g., when &lt;code&gt;cli.usage()&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06cad667cd962638ca743f083a07c3b0502fe46b" translate="yes" xml:space="preserve">
          <source>The command synopsis displayed as the first line in the usage help message, e.g., when &lt;code&gt;cli.usage()&lt;/code&gt; is called. When not set, a default synopsis is generated that shows the supported options and parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18fc7b737edb2f0f86aeb308f5fb82c518e4b38" translate="yes" xml:space="preserve">
          <source>The compile phase after which the test code should run.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afcc42b40006b1f09d9251010aafdffd34d40bec" translate="yes" xml:space="preserve">
          <source>The compiler will call this method each time, in a source file, a method call using a closure literal is encountered and that the target method has the corresponding &lt;a href=&quot;../../lang/closure&quot;&gt;Closure&lt;/a&gt; parameter annotated with &lt;a href=&quot;closureparams&quot;&gt;ClosureParams&lt;/a&gt;. So imagine the following code needs to be compiled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3808e32108176f69751a0339e1ed53d1e06027cc" translate="yes" xml:space="preserve">
          <source>The compiler will not output classes from these, the methods usually do not contain bodies. These kind of ClassNodes will be used in different checks, but not checks that work on the method bodies. For example if such a ClassNode is a super class to a primary ClassNode, then the abstract method test and others will be done with data based on these. Theoretically it is also possible to mix both (1 and 2) kind of classes in a hierarchy, but this probably works only in the newest Groovy versions. Such ClassNodes normally have to isResolved() returning true without having a redirect.In the Groovy compiler the only version of this, that exists, is a ClassNode created through a Class instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850b5efb5f5d9bd3f0560dbbfb14716f649e832f" translate="yes" xml:space="preserve">
          <source>The configuration if in use (normally only used by internal ivy repositories).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7faea022679481783e94841e801c0632c55b402" translate="yes" xml:space="preserve">
          <source>The configuration if in use (normally only used by internal ivy repositories). One or more comma separated values with or without square brackets, e.g. for hibernate you might have &quot;default,proxool,oscache&quot; or &quot;[default,dbcp,swarmcache]&quot;. This last hibernate example assumes you have set up such configurations in your local Ivy repo and have changed your grape config (using grapeConfig.xml) or the &lt;code&gt;@GrabConfig&lt;/code&gt; annotation to point to that repo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a60e2fa853eacff28c12440dec49c56afecdc7" translate="yes" xml:space="preserve">
          <source>The contents of the String builder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a4aab4772591a45dec107fd2e9fe47875d2b895" translate="yes" xml:space="preserve">
          <source>The contents of the character sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f665bdf073d546e255843bb7fa9544a62b7c4f16" translate="yes" xml:space="preserve">
          <source>The current implementation will trigger specialized events in the following scenarios, you need not register a different listener as those events extend from PropertyChangeEvent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa2b0935d80587b9e265b2719d52d7996bf5d785" translate="yes" xml:space="preserve">
          <source>The current phase</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="663e0af727247cd08dbfe73bff52e235110340bf" translate="yes" xml:space="preserve">
          <source>The custom base script may implement the run() method and specify a different method name to be used for the script body by declaring a single abstract method. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2e34c2c7e5c999db4a0824f8059bf7756113c7d" translate="yes" xml:space="preserve">
          <source>The custom loader is used when parsing the template code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca6098954c43f913ba3c64e90df8088c2b564b2" translate="yes" xml:space="preserve">
          <source>The deepest cause of the exception that can be found</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fed7a59b4c24557c03efc1e169c4b5b8e3c0cd8" translate="yes" xml:space="preserve">
          <source>The default implementation allows mutation of MetaClass instances before initialisation (before the initialize() method is called) but not after, thus ensuring Thread safety once a MetaClass has been constructed and placed in the registry</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0369a08ef21d243b44db8e7fa19111fcc8106a0b" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;a href=&quot;../../../../../groovy/transform/typechecked&quot;&gt;TypeChecked&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccbd3d0c31dab791dfc78e2ee441f1186a903c8a" translate="yes" xml:space="preserve">
          <source>The default implementation returns the result of calling &lt;a href=&quot;#visitChildren&quot;&gt;visitChildren&lt;/a&gt; on &lt;code&gt;ctx&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c93b782d28b18159b4ef7fb9a86d95ab87ba8d" translate="yes" xml:space="preserve">
          <source>The default initial capacity</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="921bbe96047cd5f5e009f6b1a8b71ad284e53cc5" translate="yes" xml:space="preserve">
          <source>The default initial number of table slots for this table (32).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a0235f2f6bc645bf5e53f460b490ce2caa3598a" translate="yes" xml:space="preserve">
          <source>The default initial number of table slots for this table (32). Used when not otherwise specified in constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd047e4711d4b6317b4497793f156661db1b11a1" translate="yes" xml:space="preserve">
          <source>The default load factor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4e8b83f74be0aa4cd12586b4ecddbda8abb74e9" translate="yes" xml:space="preserve">
          <source>The default source encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2156c83dec97c28b53d21a341f92ef1aa0daaa7b" translate="yes" xml:space="preserve">
          <source>The default type checking handler is used by the standard type checker and doesn't handle any of the type checking errors by default. This just means that whenever a type checking error is detected, there's no additional information available to the type checker that could help it. The default handler is also capable of handling a collection of delegate handlers. If a list of delegates is set, then the type checker will try all the delegates until one is capable of handling an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93ee9502a59a55344833d10b6e63692489f009a" translate="yes" xml:space="preserve">
          <source>The default value for this option as a String; subject to type conversion and 'convert'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a739b1ad38b841cd2fa04a8074ef1077da23a9a2" translate="yes" xml:space="preserve">
          <source>The default value for this option as a String; subject to type conversion and 'convert'. Ignored for Boolean options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bac4f7d3a0265af4cdda31389b94208873f3c79" translate="yes" xml:space="preserve">
          <source>The delegate type is either the type of the annotated field (or property) or the return type of the annotated method. The method can be thought of as a getter or factory method for the delegate. All public instance methods present in the delegate type and not present in the owner class will be added to owner class at compile time. The implementation of such automatically added methods is code which calls through to the delegate as per the normal delegate pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af551f931ca1824e6ae59d39c1f9fdc65593c1b" translate="yes" xml:space="preserve">
          <source>The delegate used when invoking closures</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5a481646fd9ab2048ec3c70d70d40fc4c25698" translate="yes" xml:space="preserve">
          <source>The description for the remaining non-option arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60c01151d0f392e7605b5a47b38d319dce929d2b" translate="yes" xml:space="preserve">
          <source>The description of this option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acf047b88dc904eaceac2bf0ff491efd1167e629" translate="yes" xml:space="preserve">
          <source>The document filter based on Parrot's lexer is for highlighting the content of text editor</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8897ab667aaab473e278c1a7493c2f1a2afa6c06" translate="yes" xml:space="preserve">
          <source>The empty args call will create a key whose value will be an empty JSON object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4732dbf3c3fe3c33d319cd5d0d9b4500c95066cc" translate="yes" xml:space="preserve">
          <source>The empty args call will create a key whose value will be an empty YAML object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83bac1c4520db67dc9f9751222ec424f3e1dcdc8" translate="yes" xml:space="preserve">
          <source>The encoding as returned by the underlying OutputStreamWriter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7209071caba4b5b26858a3a9b872daaeac068996" translate="yes" xml:space="preserve">
          <source>The encoding as returned by the underlying OutputStreamWriter. Can be the historical name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b32ee3e8c38d4c93010daac30bf6c76f82e10a7e" translate="yes" xml:space="preserve">
          <source>The encoding as returned by the underlying OutputStreamWriter. Will be the preferred name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a1b6c77417175321e74a3e09c3c5bfa3b1a669" translate="yes" xml:space="preserve">
          <source>The example below shows the various possible use cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cda0c1c869121c0516b4b7eef52cfb72926a1f0c" translate="yes" xml:space="preserve">
          <source>The exit code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="507fe61a8f648672fa6038e5dfbc9edeb36a23b2" translate="yes" xml:space="preserve">
          <source>The expanded toString() of this CharSequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d08e701963d2aabc470d83a9d8da90b7362df5" translate="yes" xml:space="preserve">
          <source>The extension method registry is responsible for collecting methods (or static methods) which are added to existing classes and may be called like regular methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa6754ebfc303c012b03fb4abba3b5f12ccb8b6c" translate="yes" xml:space="preserve">
          <source>The extension of the artifact (normally safe to leave at default value of &quot;jar&quot; but other values like &quot;zip&quot; are sometimes useful).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e641d1d3bf6e1800547d3ef352762fcba029ed7" translate="yes" xml:space="preserve">
          <source>The extra grab configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd2c5f11d6d27f858d5d3dc59a3083f35bfd20b" translate="yes" xml:space="preserve">
          <source>The field of this property</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b234649fde6d931b7e01052a7041604ee37062c4" translate="yes" xml:space="preserve">
          <source>The first argument of the method is only used to tell the class for which we add a static method. You can now define an extension module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f1c3d2c6a3794b89910b38b5fc0a80c1e72651e" translate="yes" xml:space="preserve">
          <source>The first element returned by the Iterable's iterator is returned. If the Iterable doesn't guarantee a defined order it may appear like a random element is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f788a50cfac60f792deddd7ec215420ae4c26518" translate="yes" xml:space="preserve">
          <source>The following attributes are optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a78a58b8d15f66560b1ee62392912456c7f7d2b" translate="yes" xml:space="preserve">
          <source>The following code is generated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6db6ec58fab215cd6939fb661b05cc65eb0427a" translate="yes" xml:space="preserve">
          <source>The following example describes a closure as accepting a single signature (List&amp;lt;T&amp;gt; list -&amp;gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1deb2c32e07a91866a38699ca2b5e5576a8b7889" translate="yes" xml:space="preserve">
          <source>The following example shows how you can use this annotation on fields of a class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38490d2869c131045bab21ff7ca6b124ab7e1e94" translate="yes" xml:space="preserve">
          <source>The following is an example usage. Note that within a &quot;with&quot; block you need to specify a parameter name so that this.println is not called instead of IndentPrinter.println:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb6e88658d6aafa0e1c5fb88a8e22112ec44c060" translate="yes" xml:space="preserve">
          <source>The following is sample usage of the annotation forcing the script to timeout after 5 minutes (300 seconds):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7079281a140b1fc8b280d5f645e024ae9a37bc71" translate="yes" xml:space="preserve">
          <source>The following is sample usage of the annotation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="879e99e6a011963f4f6df39ba4aa585918568fcd" translate="yes" xml:space="preserve">
          <source>The following properties are referenced when setting the configuration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20f832237a68dcebeb6521dde3b85b13bd8f5117" translate="yes" xml:space="preserve">
          <source>The following scenarios can not set accessible, i.e. the return value is false 1) SecurityException occurred 2) the accessible object is a Constructor object for the Class class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5775c2755497d25926312a1fe22b019fe16dce69" translate="yes" xml:space="preserve">
          <source>The following servlet init parameter name can be used to specify the encoding TemplateServlet will use to read the template groovy source files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c10ecb3564857baa02ca7a4bdd0fbed3c5fdf34" translate="yes" xml:space="preserve">
          <source>The following shows all of the different syntax forms supported by the node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402c79945cb622bc852b23a63a5a225b6b97c510" translate="yes" xml:space="preserve">
          <source>The following system properties are referenced when setting the configuration optimization options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="589daf472d87f60da3820df2375540a65850b000" translate="yes" xml:space="preserve">
          <source>The following will be output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3affea3413fcaa516e9b68e8682b4216a488ecf1" translate="yes" xml:space="preserve">
          <source>The found MetaProperty or null if it doesn't exist</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="363824e3df035b97ca5a7ffba69200b946d3b768" translate="yes" xml:space="preserve">
          <source>The functionality provided by tr can be achieved using regular expressions but tr provides a much more compact notation and efficient implementation for certain scenarios.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f49e8b4f671d3af1ab3b54839c50c3ad9cb19cd" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;canEqual&lt;/code&gt; methods will be something like below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="016adc8430975ce5b3714e3f00410813056eb5c1" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;toString&lt;/code&gt; will include property names and exclude the &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d5e288e1f29d364f8118145d20f640ba8a3434" translate="yes" xml:space="preserve">
          <source>The generated Groovy class will:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ed368a0eaa66dbac47a9b89c0164f8d4c95bba4" translate="yes" xml:space="preserve">
          <source>The generated equals method will be something like below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1e1567f7025b7a32483c0df7c9b9df0c6d2e4e" translate="yes" xml:space="preserve">
          <source>The generated map constructor will have an argument of type &lt;code&gt;Map&lt;/code&gt; unless a single property (or field) is included and the type of that property (or field) is Object, AbstractMap, Map or HashMap. In this case, the generated constructor will be of type &lt;code&gt;LinkedHashMap&lt;/code&gt;. This allows the possibility of also adding a tuple constructor without conflict, although no such constructor is added automatically. You can disable this behavior by setting the specialNamedArgHandling annotation attribute to false. This means that for the special case mentioned above, you will not be able to also add a tuple constructor with a single Map argument but you can supply any kind of map as your argument. We'd also recommend not having both a map constructor and a tuple constructor with a single Object, AbstractMap or HashMap since it can cause confusion as to which will be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2054e20238e38cbabff60cf87d59cd3bda71ca2d" translate="yes" xml:space="preserve">
          <source>The generated method/constructor retains the visibility and return type of the original method/constructor but the &lt;a href=&quot;visibilityoptions&quot;&gt;VisibilityOptions&lt;/a&gt; annotation can be added to customize the visibility. You could have the annotated method/constructor private for instance but have the generated one be public.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8c55bbbf0e4e8d80618bab6f8e1e859dd3d404" translate="yes" xml:space="preserve">
          <source>The generated methods must not already exist</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c757fafc4af8d85241ca605d29734fb8e7040c3a" translate="yes" xml:space="preserve">
          <source>The groovy.lang.Closure will be given the class name as parameter. the return value decides if the element will be added or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d792c97d713c524a35ad9cb7269ec2f224a2f7" translate="yes" xml:space="preserve">
          <source>The groovy.mock.interceptor is an all-groovy mock testing library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08cb5974fee471582bb6c391e801a198206f54c" translate="yes" xml:space="preserve">
          <source>The handle should be registered with the Groovy runtime &lt;strong&gt;before&lt;/strong&gt; Groovy loads, for example in your main method. &lt;code&gt;GroovySystem.metaClassRegistry.metaClassCreationHandle = new ExpandoMetaClassCreationHandle()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7a6bf7e30e4e5adaebfa336015e1d6db546b0dc" translate="yes" xml:space="preserve">
          <source>The hash table data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be72dcbde8376507858e5e3b4f88ceb470819fe" translate="yes" xml:space="preserve">
          <source>The idea for this AST transformation originated in &lt;a href=&quot;../test/groovytestcase#notYetImplemented()&quot;&gt;GroovyTestCase.notYetImplemented&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e6b7d618961498090102436a153ea6769f4ea92" translate="yes" xml:space="preserve">
          <source>The index of the generic type that will be the type of the closure's delegate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a05df6a03c832914a468e9a8f09e99bb76121ca" translate="yes" xml:space="preserve">
          <source>The index of the generic type that will be the type of the closure's delegate. The generic types are considered with respect to the &lt;code&gt;@DelegatesTo.Target&lt;/code&gt; annotated parameter for this usage, with the index starting at 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f4812f2fcebeff3b4ebb6e2b6159d4da2a14e7a" translate="yes" xml:space="preserve">
          <source>The initial size of the memory for the underlying VM if javac is run externally; ignored otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9906cb8cda50e01b5fc0296c2ebddf1998c07481" translate="yes" xml:space="preserve">
          <source>The initial size of the memory for the underlying VM if javac is run externally; ignored otherwise. Defaults to the standard VM memory setting. (Examples: 83886080, 81920k, or 80m)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09418ac5ed51e2ae7deca28347160febab7297a9" translate="yes" xml:space="preserve">
          <source>The initial value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca553e21f81b340e4552ee970c2d402d976a297" translate="yes" xml:space="preserve">
          <source>The interface implemented by all Groovy objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36584fdf4c93d8244b01640584ce4681a2619d4" translate="yes" xml:space="preserve">
          <source>The isCallToSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly to the super class if necessary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a7346df5fc4b24f592e6ab3da8efbdbdb2e3f57" translate="yes" xml:space="preserve">
          <source>The iterator stepped along by &lt;code&gt;num&lt;/code&gt; elements if they exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="825771f9b59209884bd5990f89392f472ab52a1c" translate="yes" xml:space="preserve">
          <source>The java.lang.Class instance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39162451983f218a6022c93f55c40cf3576ffa56" translate="yes" xml:space="preserve">
          <source>The last element returned by the Iterable's iterator is returned. If the Iterable doesn't guarantee a defined order it may appear like a random element is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2b9d6958fb3428a858e3ff1b7e7d575c9444949" translate="yes" xml:space="preserve">
          <source>The lexer for Groovy programming language, which is based on the lexer generated by Antlr4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bacfbe842c2f1b3272b7632dbf718566ac8d700" translate="yes" xml:space="preserve">
          <source>The lexer reads JSON tokens in a streaming fashion from the underlying reader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ca3610dac449f90a9e358ccee55e7567cc07b1" translate="yes" xml:space="preserve">
          <source>The line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ba62139a54b7638c01550fb541cf6269ed40be" translate="yes" xml:space="preserve">
          <source>The list of (classpath resources) paths to type checking DSL scripts, also known as type checking extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9ece14574ea4cdf3337639446998372a41bef30" translate="yes" xml:space="preserve">
          <source>The listener is invoked by &lt;a href=&quot;concurrentlinkedhashmap&quot;&gt;ConcurrentLinkedHashMap&lt;/a&gt; on a caller's thread and will not block other threads from operating on the map. An implementation should be aware that the caller's thread will not expect long execution times or failures as a side effect of the listener being notified. Execution safety and a fast turn around time can be achieved by performing the operation asynchronously, such as by submitting a task to an &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html&quot;&gt;ExecutorService&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47f12bc7a7163b88b7c40a6143c735e189ed9d15" translate="yes" xml:space="preserve">
          <source>The load factor for the hash table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24eb861382bd4ecd59d0d7b27ffc4a02974042ef" translate="yes" xml:space="preserve">
          <source>The long name of this option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e53b8a2be8a710bfb615e37e77de8bcde7fbfe" translate="yes" xml:space="preserve">
          <source>The long name of this option. Defaults to the name of member being annotated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c14e51c7082ed212704f80fa16a5caa5f4b2e7" translate="yes" xml:space="preserve">
          <source>The lower value in the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70a0a182db9bd82ea7fc6368b0f23fdc024a4f0" translate="yes" xml:space="preserve">
          <source>The main class code visitor responsible for static type checking. It will perform various inspections like checking assignment types, type inference, ... Eventually, class nodes may be annotated with inferred type information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a35d780b7b7d71330b5a704f00aff27069bd32b6" translate="yes" xml:space="preserve">
          <source>The main function of the registry If a meta class exists then return it otherwise create one, put it in the registry and return it</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07dbd7ee535fe35b6529b949ce03a3cdd12de16" translate="yes" xml:space="preserve">
          <source>The main instance method of a script which has variables in scope as defined by the current &lt;a href=&quot;binding&quot;&gt;Binding&lt;/a&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a25dec9e9a77a814a53504ab23b75ca4e697cf0f" translate="yes" xml:space="preserve">
          <source>The map values are the normal values provided as the second parameter to &lt;code&gt;java.util.Calendar#set(int, int)&lt;/code&gt;. The keys can either be the normal fields values provided as the first parameter to that method or one of the following Strings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="731e1e3475853eb36e2f419522ace251acd1d87b" translate="yes" xml:space="preserve">
          <source>The maximum elapsed time the script will be allowed to run for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9744c288c3ec0b1b71c029102e0ca0c0c4e606" translate="yes" xml:space="preserve">
          <source>The maximum elapsed time the script will be allowed to run for. By default it is measure in seconds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c2ffed2aec71628097d548244a5403333d478d2" translate="yes" xml:space="preserve">
          <source>The maximum number of directory levels when recursing (default is -1 which means infinite, set to 0 for no recursion)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3d134d4c35a591a550b0133ec3ffcec626a2ca1" translate="yes" xml:space="preserve">
          <source>The maximum size of the memory for the underlying VM if javac is run externally; ignored otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d53256043cb34b5f9af6acb675b49a62d63df5c8" translate="yes" xml:space="preserve">
          <source>The maximum size of the memory for the underlying VM if javac is run externally; ignored otherwise. Defaults to the standard VM memory setting. (Examples: 83886080, 81920k, or 80m)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be8a261b2c86bdec542c4bdc16f3f9b00cf90718" translate="yes" xml:space="preserve">
          <source>The maximum size the cache can grow to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a932fa7b6f4119b32f6b4708d0afeedb86270516" translate="yes" xml:space="preserve">
          <source>The mechanics: during compilation, all methods are transformed to static ones with an additional self parameter of the type you supply as the annotation parameter (the default type for the self parameters is &lt;code&gt;Object&lt;/code&gt; which might be more broad reaching than you like so it is usually wise to specify a type). Properties invoked using 'this' references are transformed so that they are instead invoked on the additional self parameter and not on the Category instance. (Remember that once the category is applied, the reverse will occur and we will be back to conceptually having methods on the &lt;code&gt;this&lt;/code&gt; references again!)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2666c74280324e9c05645b343443d5ae919ca593" translate="yes" xml:space="preserve">
          <source>The message is a little cryptic, but it is basically the static compiler telling us that the third parameter, &lt;code&gt;age&lt;/code&gt; in our case, is unset. You can also add this annotation to your predefined constructors. These will be made private and an initializer will be set up to call your constructor. Any parameters to your constructor become the properties expected by the initializer. If you use such a builder on a constructor as well as on the class or on more than one constructor, then it is up to you to define unique values for 'builderClassName' and 'builderMethodName' for each annotation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233f1eda634fadbf2d6de9fdbba96a43cfac37b3" translate="yes" xml:space="preserve">
          <source>The meta map generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="481ab6cb4af59496e16e981430f5212574c520b3" translate="yes" xml:space="preserve">
          <source>The method &quot;is&quot; is used to test for equal references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10a0b965a2d07d42bb108200564cd0092fef8a4b" translate="yes" xml:space="preserve">
          <source>The method &quot;is&quot; is used to test for equal references. This method will return true only if the given parameter is null</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="046b59ea660985a374595a12ce69c4e51a167400" translate="yes" xml:space="preserve">
          <source>The method descriptor of the method from the trait</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b11d5e3b0af8fe608284cd9acdeefcad67a7934" translate="yes" xml:space="preserve">
          <source>The method is invoked when an AST Transformation is active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad8ddc19cf1fe16c4946011a31c3d7615aae395" translate="yes" xml:space="preserve">
          <source>The method is invoked when an AST Transformation is active. For local transformations, it is invoked once each time the local annotation is encountered. For global transformations, it is invoked once for every source unit, which is typically a source file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16096b1fa8363d7f7f3486f5931631ff7821604c" translate="yes" xml:space="preserve">
          <source>The method is similar with &lt;a href=&quot;genericsutils#makeDeclaringAndActualGenericsTypeMap(org.codehaus.groovy.ast.ClassNode,%20org.codehaus.groovy.ast.ClassNode)&quot;&gt;GenericsUtils.makeDeclaringAndActualGenericsTypeMap&lt;/a&gt;, The main difference is that the method will try to map all placeholders found to the relevant exact types, but the other will not try even if the parameterized type has placeholders</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebd121539032d1aa634563f13cd1d7bb73f83b33" translate="yes" xml:space="preserve">
          <source>The method name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9107c6d41421afd6c4262deaacc88cd7b897fd8a" translate="yes" xml:space="preserve">
          <source>The method name to use for a builder factory method in the source class for easy access of the builder helper class for strategies which create such a helper class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d156486b828194de0dc1376f435a69303f46b5c6" translate="yes" xml:space="preserve">
          <source>The method name to use for a builder factory method in the source class for easy access of the builder helper class for strategies which create such a helper class. Must not be used if using &lt;code&gt;forClass&lt;/code&gt;. Default is determined by the strategy, e.g. &lt;em&gt;builder&lt;/em&gt; or &lt;em&gt;createInitializer&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19190b8bf1a50223552a2ea9092d0e868f9b58bb" translate="yes" xml:space="preserve">
          <source>The method omits padding and is equivalent to calling &lt;a href=&quot;encodinggroovymethods#encodeBase64Url(Byte%5B%5D,%20boolean)&quot;&gt;EncodingGroovyMethods.encodeBase64Url&lt;/a&gt; with a value of &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd16bad639c8dbfe1c2afb5d210c9fca412a986a" translate="yes" xml:space="preserve">
          <source>The method omits padding and is equivalent to calling &lt;a href=&quot;encodinggroovymethods#encodeBase64Url(byte%5B%5D,%20boolean)&quot;&gt;EncodingGroovyMethods.encodeBase64Url&lt;/a&gt; with a value of &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977caf0a01596f416e854564419eecf39b01c39d" translate="yes" xml:space="preserve">
          <source>The method returns</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="233550ffa2aace49d6789bba08354b9269776fba" translate="yes" xml:space="preserve">
          <source>The methods found in this class are made directly available in type checking scripts through the &lt;a href=&quot;groovytypecheckingextensionsupport&quot;&gt;GroovyTypeCheckingExtensionSupport&lt;/a&gt; class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f7b0d22db711005969846defb7c99717fa91841" translate="yes" xml:space="preserve">
          <source>The modified implementation is based on StringUtils#replace(String text, String searchString, String replacement, int max), Apache commons-lang3-3.6</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50fbba6f75c792f1af5c5472d076319e1dc8e8c0" translate="yes" xml:space="preserve">
          <source>The module or artifact, e.g.: &quot;ant-junit&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ecf7b850507e5a2a96948e13f72e6da5a6b2250" translate="yes" xml:space="preserve">
          <source>The module or artifact, e.g.: &quot;ant-junit&quot;. A non-empty value is required unless value() is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8998068077ca7885c0e4186f470a1345f7bcaabe" translate="yes" xml:space="preserve">
          <source>The module or artifact, e.g.: &quot;ant-junit&quot;; required unless the compact form is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67b83bce5d6428054b151a952a38c76fc1400e95" translate="yes" xml:space="preserve">
          <source>The name of the command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43aae32f2ac7a4701fa066c8a7276ef64ed1c079" translate="yes" xml:space="preserve">
          <source>The name of the property. The name is &quot;get&quot;+ the capitalized propertyName or, in the case of boolean values, &quot;is&quot; + the capitalized propertyName</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38191355c55cbbc00969fffa25036a9e046325a0" translate="yes" xml:space="preserve">
          <source>The name of the property. The name is &quot;set&quot;+ the capitalized propertyName.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a15c19401cb99e1843f9f1f65dd9a34cd037b984" translate="yes" xml:space="preserve">
          <source>The new MetaClass</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3d1a75c8717139ff820f7f834e634eaf7a158b" translate="yes" xml:space="preserve">
          <source>The newly created Calendar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c75c777743c28c6ddb34992b6df6f585ae387f8b" translate="yes" xml:space="preserve">
          <source>The newly created Date</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="343fa99691cb8eb1227394b817b70099749bdacd" translate="yes" xml:space="preserve">
          <source>The next example describes a closure as accepting two signatures (List&amp;lt;T&amp;gt; list -&amp;gt;) and (T t -&amp;gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35ccc24e2e75124aaac905d871e93bf9a5f09134" translate="yes" xml:space="preserve">
          <source>The node must be called with either a value argument or a title: attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032b81eac6a8ead6bf3bea51101baeb3b3e0d8f0" translate="yes" xml:space="preserve">
          <source>The number of characters actually skipped</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c9016a339d21ce2a804e220ce7a8e37661b04db" translate="yes" xml:space="preserve">
          <source>The number of characters read or -1 if there are no more</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecf5ab475eeef8fcb49643a9532fa7b4dc7af88a" translate="yes" xml:space="preserve">
          <source>The number of characters read, or -1 if the end of the stream has been reached</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f80b964b2a13be3af83a2b98edb531c0a483f10" translate="yes" xml:space="preserve">
          <source>The number of needed instructions is thus reduced from 15 to 4. For every entry we save 3 bytecode instructions. This allows better readable bytecode and it allows the JIT to see less bytecode to optimize, helping under the inlining threshold here or there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d66cf7d98d8141c6d3db9afd12ffdb8fc3310252" translate="yes" xml:space="preserve">
          <source>The object holding the data value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850f532ee8584882c8e75e990fb14ebbbde70875" translate="yes" xml:space="preserve">
          <source>The object that registers method calls on it for the use with Mocks and Stubs. For each call a CallSpec object is added to the recorded list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4375205097b015888ab65280d3b96851ded2b956" translate="yes" xml:space="preserve">
          <source>The old MetaClass</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e4156ceefaea5d9509b6380a238b14d924e012" translate="yes" xml:space="preserve">
          <source>The oldest entry(i.e. the Less Recently Used entry) will be evicted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd46ef926874e9055f1e4cf7568213be97d6b34" translate="yes" xml:space="preserve">
          <source>The one and only implementation of a meta class. INTERNAL USE ONLY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a1c774e1d0fe1b0b5303c859052c21b6258376" translate="yes" xml:space="preserve">
          <source>The one-sentence summary for the package derived from the beginning of the description.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b73f8f765fe9a956ade4dde4833c77ee65e1eb9" translate="yes" xml:space="preserve">
          <source>The only difference between Java strings and JavaScript strings is that in JavaScript, a single quote must be escaped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39accb2b332a1b9e56c3ee6ac627961ec2636b16" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;interceptConstruction&lt;/code&gt; flag allows mocking of constructor calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2144302020ab0d839d4af265778a87ee9caa1988" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;interceptConstruction&lt;/code&gt; flag allows mocking of constructor calls. These are represented in the demand specification using the class name as this example shows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d46ce745b7d040a6af0b7952e782405f90be5a6f" translate="yes" xml:space="preserve">
          <source>The optional parameter for tags like &quot;throws&quot; and &quot;param&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e32f979195511f753ad4cf62e43dcd18cd136c7" translate="yes" xml:space="preserve">
          <source>The options array is used to modify the behavior of this hint. Each string in the option array consists of a key=value pair.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b48b46c9d0ec14ed87e0211dbb48b950e8e8d55" translate="yes" xml:space="preserve">
          <source>The order of parameters is given by the properties of any super classes (if &lt;code&gt;includeSuperProperties&lt;/code&gt; is set) with the most super first followed by the properties of the class followed by the fields of the class (if &lt;code&gt;includeFields&lt;/code&gt; is set). Within each grouping the order is as attributes appear within the respective class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fbc45ad553a921f8843e5823598f573c5e856ec" translate="yes" xml:space="preserve">
          <source>The organisation or group, e.g.: &quot;org.apache.ant&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adc438730ea65642ec0cc71f1ada8471e6f24d75" translate="yes" xml:space="preserve">
          <source>The organisation or group, e.g.: &quot;org.apache.ant&quot;. A non-empty value is required unless value() is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c1050236f9bfcb9f997fc983fb0d67f42762c0d" translate="yes" xml:space="preserve">
          <source>The organisation or group, e.g.: &quot;org.apache.ant&quot;; required unless the compact form is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf0ae96fdb2085b66ea3bb93836f5dbda67d76df" translate="yes" xml:space="preserve">
          <source>The original AST or null if it cannot be returned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="463c8561d710e01b478880e4165ed134de96d70b" translate="yes" xml:space="preserve">
          <source>The original Throwable but with a sanitized stack trace</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="550e2fe2cda92d999ef8b8744582f726ca7d70d3" translate="yes" xml:space="preserve">
          <source>The original slurper and lexer use this class. This is kept around in case someone needs its exact behavior. Enum listing all the possible JSON tokens that should be recognized by the lexer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf6c32888a66c7be9b42c3c4ddc926c89cf2d2d" translate="yes" xml:space="preserve">
          <source>The other typical usage, uses the self object while creating some value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0fdc2ddc244d43905d142929aaff47d915c14d" translate="yes" xml:space="preserve">
          <source>The other way is to add annotations to the alias:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e8045bb0c75ecafe6640585dfaad1f947bcf4b" translate="yes" xml:space="preserve">
          <source>The owning shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c2e67b95c48b05cb96c4651b224ecc651abf77" translate="yes" xml:space="preserve">
          <source>The parser for Groovy programming language, which is based on the parser generated by Antlr4</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4db92f843c33741921f53930bfa252393bdb5ad" translate="yes" xml:space="preserve">
          <source>The particular unit decremented by depends on the specific sub-type of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html&quot;&gt;Temporal&lt;/a&gt;. Most sub-types use a unit of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#SECONDS&quot;&gt;ChronoUnit.SECONDS&lt;/a&gt; except for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0931b94d8ae13c47b9a85df31fbc353bf2a74861" translate="yes" xml:space="preserve">
          <source>The particular unit incremented by depends on the specific sub-type of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html&quot;&gt;Temporal&lt;/a&gt;. Most sub-types use a unit of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#SECONDS&quot;&gt;ChronoUnit.SECONDS&lt;/a&gt; except for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3baee579d0f99a112462a4af57608a9a896b5c9" translate="yes" xml:space="preserve">
          <source>The permission groovy.security.GroovyCodeSourcePermission will be used to determine if the given codeBase may be specified. That is, the current Policy set must have a GroovyCodeSourcePermission that implies the codeBase, or an exception will be thrown. This is to prevent callers from hijacking existing codeBase policy entries unless explicitly authorized by the user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b23c39fbfa279511d3e7fc40992076c646fe704c" translate="yes" xml:space="preserve">
          <source>The phases as an array, with a null entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a50aa1f415a2950a9c3ea1c28386340df92373c" translate="yes" xml:space="preserve">
          <source>The phases of the GroovyCompiler. This is an enum facade on top of the Phases object. In general, prefer using this object over Phases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0555c21af552adf2c625446c48cfa44d487360f" translate="yes" xml:space="preserve">
          <source>The position of the curried parameters will be calculated eagerly and implies all arguments prior to the specified n index are supplied. Default parameter values prior to the n index will not be available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b99f34149701f4f317b757b6f7be07e6c77a0502" translate="yes" xml:space="preserve">
          <source>The position of the curried parameters will be calculated lazily, for example, if two overloaded doCall methods are available, the supplied arguments plus the curried arguments will be concatenated and the result used for method selection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d57362120a781eed62a17257a436f5c3b9c1de" translate="yes" xml:space="preserve">
          <source>The position tree of multi-line comments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d2d8d4480d18b9fc0a2174c8cfea817348cc881" translate="yes" xml:space="preserve">
          <source>The prefix to use when creating the setter methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dec45555f03c899ffc22df52915fd879b9c58b0" translate="yes" xml:space="preserve">
          <source>The prefix to use when creating the setter methods. Default is determined by the strategy which might use &quot;&quot; or &quot;set&quot; but you can choose your own, e.g. &quot;with&quot;. If non-empty the first letter of the property will be capitalized before being appended to the prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c03948908d1373a091dc6fd5073476e494fdead0" translate="yes" xml:space="preserve">
          <source>The problem this annotation tries to solve is to define the expected parameter types of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="404ee7e80d97420044d8572424c53f96977d7292" translate="yes" xml:space="preserve">
          <source>The produced code for the above example looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66d47ea438a29f8f03b670b0bcbb6770f0998399" translate="yes" xml:space="preserve">
          <source>The properties to use can be filtered using either the 'includes' or 'excludes' annotation attributes for &lt;code&gt;@Builder&lt;/code&gt;. The &lt;code&gt;@Builder&lt;/code&gt; 'buildMethodName' annotation attribute can be used for configuring the build method's name, default &quot;build&quot;. The &lt;code&gt;@Builder&lt;/code&gt; 'builderMethodName' and 'builderClassName' annotation attributes aren't applicable for this strategy. The &lt;code&gt;@Builder&lt;/code&gt; 'useSetters' annotation attribute is ignored by this strategy which always uses setters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bccb759e3c0e6e0247c634660331a9f94034269" translate="yes" xml:space="preserve">
          <source>The properties value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d776cd3bdbba7c1073d917e7c7a9132e4549183f" translate="yes" xml:space="preserve">
          <source>The properties within the class must themselves be &lt;code&gt;Comparable&lt;/code&gt; or &lt;code&gt;@Sortable&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ed4236c8f797aaa8636050cfd80ec30bfeeed44" translate="yes" xml:space="preserve">
          <source>The property handler class which creates the necessary code for getting, setting or initializing properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c2099cb7601f141e152a819c05e4db6c35a60d7" translate="yes" xml:space="preserve">
          <source>The property name equivalent</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068bd70d79a0f3161e77c6b20503123007a1632e" translate="yes" xml:space="preserve">
          <source>The property to set on compilation failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bed8d7b5a8bdc81a2320b7e7824add1844ac6dc" translate="yes" xml:space="preserve">
          <source>The property to set on compilation failure. This property will be set if the compilation fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b106043c5c6468760b416e5a4f5dc8142c486625" translate="yes" xml:space="preserve">
          <source>The property to set on compilation success.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39baf3f1877fa6a76dce4eda62ece0b8909c7323" translate="yes" xml:space="preserve">
          <source>The property to set on compilation success. This property will not be set if the compilation fails, or if there are no files to compile.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc70b9bacce6273f76ef6e4471c4dab865527fa7" translate="yes" xml:space="preserve">
          <source>The purpose is the reduction of the size of the bytecode. Consider creating a three element Object[] with null values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666faa1948c36e5a23029d8167b7a82bae76aa8a" translate="yes" xml:space="preserve">
          <source>The qualified name including any dimension information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98b1825554dc394c8049d1d532250cea4ed423f2" translate="yes" xml:space="preserve">
          <source>The qualified name including any dimension information. For example, a two dimensional array of String returns &quot;&lt;code&gt;java.lang.String[][]&lt;/code&gt;&quot;, and the parameterized type &lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt; returns &quot;&lt;code&gt;java.util.List&amp;lt;java.lang.Integer&amp;gt;&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6749c09dae1f16ee309de33291725a38354b80c1" translate="yes" xml:space="preserve">
          <source>The qualified name of this type excluding any dimension information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5524ad7e8d6e056655d2c24925da6512f7f6b810" translate="yes" xml:space="preserve">
          <source>The qualified name of this type excluding any dimension information. For example, a two dimensional array of String returns &quot;&lt;code&gt;java.lang.String&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc755459d1d6c162948ac88fb407664086e913e" translate="yes" xml:space="preserve">
          <source>The recommended way of securing shells is to use allowed lists because it is guaranteed that future features of the Groovy language won't be accidentally allowed unless explicitly added to the allowed list. Using disallowed lists, you can limit the features of the language constructs supported by your shell by opting out, but new language features are then implicitly also available and this may not be desirable. The implication is that you might need to update your configuration with each new release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7890a44bd59bb88228f8c74508210c196c09f718" translate="yes" xml:space="preserve">
          <source>The replace method to use on the matcher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d65383712d8a239399641a0d18670d69f0cea91" translate="yes" xml:space="preserve">
          <source>The replacement used by the resource name matcher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="183b2d9cf750ef4356762e7761f879eb6c2e10e8" translate="yes" xml:space="preserve">
          <source>The resgistry</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b60066e74974428693cf317396c392559fe4dcf" translate="yes" xml:space="preserve">
          <source>The resolve strategy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6a1ea6deab0be8f01a56df21bf7e874402baa48" translate="yes" xml:space="preserve">
          <source>The result is a closure which can have the following forms:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8073c98c26e1541e605cf9192ccb46ebece88e7" translate="yes" xml:space="preserve">
          <source>The result of the merge</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4fd3dd77a58f818d8c3faf56a7c1b1b58fac08e" translate="yes" xml:space="preserve">
          <source>The result of the propertyMissing method or throws MissingPropertyException</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="becf539a2208e344834f816674f2d5fcf96548ba" translate="yes" xml:space="preserve">
          <source>The resulting translated &lt;code&gt;String&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d34dfb3088ea17d04b40b40c5f003d8f05e4fe" translate="yes" xml:space="preserve">
          <source>The results of methodMissing or throws MissingMethodException</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="476c927d4d90fe65f6bab20cb57f17b4834562dd" translate="yes" xml:space="preserve">
          <source>The return value of the invocation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f772844e69ffcc0220695a141278b4ea7430de9f" translate="yes" xml:space="preserve">
          <source>The return value of the invoked method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62d80f160e3301c563f71de2f15701a15461fe3a" translate="yes" xml:space="preserve">
          <source>The return value of the method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97df77d5d16cf6f0d57a6d6752ee61825a4cc88" translate="yes" xml:space="preserve">
          <source>The return value of the method which is null if the return type is void</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8583dcdd18eee679eec49286a13176c4259a5294" translate="yes" xml:space="preserve">
          <source>The returning parameter is commonly set to true when using with to simplify object creation, such as this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="875acf317a8f8529a69052fe176958b2bd26bb44" translate="yes" xml:space="preserve">
          <source>The revision or version, e.g.: &quot;1.7.1&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd485b893e87dd0b6efe0f84be74a2b0e50d049" translate="yes" xml:space="preserve">
          <source>The revision or version, e.g.: &quot;1.7.1&quot;. A non-empty value is required unless value() is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c207af991fb99091fa8f287c2da7adabb871197" translate="yes" xml:space="preserve">
          <source>The right way to use it for JUnit 3 is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d858a85c56dc4b03eac0fe169dc4fa68051e7d8" translate="yes" xml:space="preserve">
          <source>The root cause exception instance, with its stace trace modified to filter out groovy runtime classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="865af8ea215cefa5991c9cc5122354fadb48bb74" translate="yes" xml:space="preserve">
          <source>The root cause exception instances, with stack trace modified to filter out groovy runtime classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e93c1b520cbd7836f0f8c1b4fd013c4e8d1129b1" translate="yes" xml:space="preserve">
          <source>The root of the Abstract Syntax Tree for the source</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67a7915a02520c39d9f254645135aa63e22bb403" translate="yes" xml:space="preserve">
          <source>The root of the lexical parsing tree.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56fa669d54b1368623bad8fc50daad712171e89f" translate="yes" xml:space="preserve">
          <source>The short name of this option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d865d69887c0552a76349586553be28eee417b21" translate="yes" xml:space="preserve">
          <source>The short name of this option. Defaults to the name of member being annotated if the longName is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2891c2488b5c6f4342d686b2788cfdf34b392d" translate="yes" xml:space="preserve">
          <source>The shortcut switch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dc02e4e7a9421805995dea237ea87f71134df23" translate="yes" xml:space="preserve">
          <source>The signature of this method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1492be12bee4c707c0282e56184b32b47ef4804" translate="yes" xml:space="preserve">
          <source>The simple name of the annotation including the &quot;@&quot; or null if no such name is defined</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b4b71213506f4e0356dfd5fc20a5f6e429010dd" translate="yes" xml:space="preserve">
          <source>The source units from which this unit is built.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01401bd4b3d5f57ed6503d187a050f41b2a42df8" translate="yes" xml:space="preserve">
          <source>The standard use for this method is when a table has an autoincrement ID column and you want to know what the ID is for a newly inserted row. In this example, we insert a single row into a table in which the first column contains the autoincrement ID:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9275509b872e0adb76980a0373cc6d87c6055af3" translate="yes" xml:space="preserve">
          <source>The stream can be for example a FileInputStream from a file with the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15cc0423f1955111b4c08c47e52328fbdd00b69f" translate="yes" xml:space="preserve">
          <source>The string must be in the form returned by the QName.toString() method, i.e. &quot;{namespaceURI}localPart&quot;, with the &quot;{namespaceURI}&quot; part being optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22771b89b44cb0db24fad01ea17fe01b726ba658" translate="yes" xml:space="preserve">
          <source>The string representation of the annotation reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e599db1ac6ef94f8579d026e88b608cf27ff8b8" translate="yes" xml:space="preserve">
          <source>The string representation of the annotation reference. Initially implemented as a temporary hack stored from the source. To be replaced with strong-typed finer grained information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb22d22c184c47ba3163340422accef7dd9ed1ff" translate="yes" xml:space="preserve">
          <source>The sum of all of the items</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d0ac42b8edc1dae134c503efef716fc53d98f4" translate="yes" xml:space="preserve">
          <source>The sum of all of the items.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="989e25ec9928e09df7ee1acc43fc9c0880df69ad" translate="yes" xml:space="preserve">
          <source>The sum of the values returned by applying the closure to each item from the Iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9e7ecaf4ca357ee681a27b991a11fab6d65dff1" translate="yes" xml:space="preserve">
          <source>The sum of the values returned by applying the closure to each item of the Iterable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e89a462ab069558ccc92abaa6becf7fe7ca0492" translate="yes" xml:space="preserve">
          <source>The sum of the values returned by applying the closure to each item of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0fe680303e1ca58932bb92ab26453355acda86b" translate="yes" xml:space="preserve">
          <source>The sum of the values returned by applying the closure to each item of the collection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ca0e801895a43143eb85bd9dd3e4c911b3a6cad" translate="yes" xml:space="preserve">
          <source>The table is rehashed when its size exceeds this threshold.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8516c49e4447a484bd801473d4d78b70be591b01" translate="yes" xml:space="preserve">
          <source>The table is rehashed when its size exceeds this threshold. (The value of this field is always (int)(capacity * loadFactor).)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2509a2b15c4fec90b1a89dfc73783afc5e5011fd" translate="yes" xml:space="preserve">
          <source>The tag name, e.g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db1db9824ee90a8accc29a6f47094d8320d3122c" translate="yes" xml:space="preserve">
          <source>The tag name, e.g. &quot;deprecated&quot;, &quot;param&quot;, &quot;see&quot; or &quot;author&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bab8307ff605a63f18f27b4b6a7d097cd05e8a14" translate="yes" xml:space="preserve">
          <source>The tail of a declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9066d16633090f75058b4bd1ecc26ce2c11677e" translate="yes" xml:space="preserve">
          <source>The tail of a declaration. Either v1, v2, ... (with possible initializers) or else m(args){body}. The two arguments are the modifier list (if any) and the declaration head (if any). The declaration head is the variable type, or (for a method) the return type. If it is missing, then the variable type is taken from its initializer (if there is one). Otherwise, the variable type defaults to 'any'. DECIDE: Method return types default to the type of the method body, as an expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80c1cd374807e18badc9c825a6ddb035ef579c09" translate="yes" xml:space="preserve">
          <source>The template engine can also be used as the engine for &lt;a href=&quot;../servlet/templateservlet&quot;&gt;TemplateServlet&lt;/a&gt; by placing the following in your &lt;code&gt;web.xml&lt;/code&gt; file (plus a corresponding servlet-mapping element):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c41f5167f4c55b11e4ca434e73cfd1cfefc8c204" translate="yes" xml:space="preserve">
          <source>The template engine makes an effort to throw descriptive exceptions with context lines, ie:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8bfd67b666067ef82bd6d072ceb9ecda1903dc6" translate="yes" xml:space="preserve">
          <source>The template engine uses JSP style &amp;lt;% %&amp;gt; script and &amp;lt;%= %&amp;gt; expression syntax or GString style expressions. The variable '&lt;code&gt;out&lt;/code&gt;' is bound to the writer that the template is being written to.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e19b0f009154f105e8d40314ebe5b64bfebc12" translate="yes" xml:space="preserve">
          <source>The template that will produce the response text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ff9da155da96f8ae444a0f421dd2eedfdd8503" translate="yes" xml:space="preserve">
          <source>The text associated with the tag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79600bf9bc91a3b3f63e7ddccbd148d4dbd124ed" translate="yes" xml:space="preserve">
          <source>The timer task which has been scheduled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a25852356fb8328146e29a2fd46930da5616780" translate="yes" xml:space="preserve">
          <source>The tool to simulate running script files via groovy command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74e34865ea7d26c8fa280a51bc74328d5c56b6b2" translate="yes" xml:space="preserve">
          <source>The total number of mappings in the hash table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10ed76980b7be55f6560da1b7d64f4c53cb55453" translate="yes" xml:space="preserve">
          <source>The traversal can be adapted by providing various options in the &lt;code&gt;options&lt;/code&gt; Map according to the following keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31d840e6eaa37d1fb137aba5bd262f3661e3cc96" translate="yes" xml:space="preserve">
          <source>The type descriptor for a method node is a string containing the name of the method, its return type, and its parameter types in a canonical form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a6d9396902e7a9d90719e486b0ecba2c7fd0a1" translate="yes" xml:space="preserve">
          <source>The type descriptor for a method node is a string containing the name of the method, its return type, and its parameter types in a canonical form. For simplicity, we use the format of a Java declaration without parameter names or generics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfcc6988d78bb654bf23686ac195aa641257ac4b" translate="yes" xml:space="preserve">
          <source>The type member should be used when the type of the delegate cannot be represented with &lt;a href=&quot;#value()&quot;&gt;value()&lt;/a&gt;, &lt;a href=&quot;#genericTypeIndex()&quot;&gt;genericTypeIndex()&lt;/a&gt; or &lt;a href=&quot;#target()&quot;&gt;target()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50630842e00d8b1cbbbfcf22c64fecd77803f9f9" translate="yes" xml:space="preserve">
          <source>The type member should be used when the type of the delegate cannot be represented with &lt;a href=&quot;#value()&quot;&gt;value()&lt;/a&gt;, &lt;a href=&quot;#genericTypeIndex()&quot;&gt;genericTypeIndex()&lt;/a&gt; or &lt;a href=&quot;#target()&quot;&gt;target()&lt;/a&gt;. In this case, it is possible to use a String to represent the type, at the cost of potential uncaught errors at compile time if the type is invalid and increased compile time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bc0f50f2984205e14cb09cbea32c757feab1695" translate="yes" xml:space="preserve">
          <source>The type of exception thrown when timeout is reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3db5653f498161246a313203cbeabe10b294791" translate="yes" xml:space="preserve">
          <source>The type of the artifact (normally safe to leave at default value of &quot;jar&quot; but other values like &quot;sources&quot; and &quot;javadoc&quot; are sometimes useful).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c9e817a3159fb3177fbc64ceea3fd2bfa224982" translate="yes" xml:space="preserve">
          <source>The type of the artifact (normally safe to leave at default value of &quot;jar&quot; but other values like &quot;sources&quot; and &quot;javadoc&quot; are sometimes useful). But see also the &quot;classifier&quot; attribute which is also sometimes used for &quot;sources&quot; and &quot;javadoc&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca920006f30ed914765d9c352a38d568933b700" translate="yes" xml:space="preserve">
          <source>The type of the last encountered &quot;it&quot; implicit parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9145cf3f9b4a0d09e2af2393fd727c71ebcbb50d" translate="yes" xml:space="preserve">
          <source>The type of the variable annotated with &lt;code&gt;@BaseScript&lt;/code&gt; must extend &lt;a href=&quot;../lang/script&quot;&gt;Script&lt;/a&gt;. It will be used as the base script class. The annotated variable will become shortcut to &lt;code&gt;this&lt;/code&gt; object. Using this annotation will override base script set by Groovy compiler or &lt;a href=&quot;../../org/codehaus/groovy/control/compilerconfiguration&quot;&gt;CompilerConfiguration&lt;/a&gt; of &lt;a href=&quot;../lang/groovyshell&quot;&gt;GroovyShell&lt;/a&gt; Example usage:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03953b92d1333f0ce4ca03983b13c88c5391b2e" translate="yes" xml:space="preserve">
          <source>The type of the variable annotated with &lt;code&gt;@SourceURI&lt;/code&gt; must be assignment compatible with &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/net/URI.html&quot;&gt;URI&lt;/a&gt;. It will be used to hold a URI object that references the source for the current script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e862454a23154b9c1eada46b694794e382df1f" translate="yes" xml:space="preserve">
          <source>The type on which the field was attempted to be called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ed994342edba2dd4caa2ae969bfced6ca083812" translate="yes" xml:space="preserve">
          <source>The type on which the method was attempted to be called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f49a0db00f8e949a09804dd63a36e2982c2bdcc0" translate="yes" xml:space="preserve">
          <source>The type on which the property was attempted to be called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a0be639b682e898850486f3c19bb899731dea4" translate="yes" xml:space="preserve">
          <source>The type that could not be resolved</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22bda5fdc5e6227a7a0c58e47015e24d57b30c81" translate="yes" xml:space="preserve">
          <source>The underlying builder</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49cf8100ba29bc770b0147077438349a48624460" translate="yes" xml:space="preserve">
          <source>The underlying template engine or &lt;code&gt;null&lt;/code&gt; on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de822d367304dba12ea8e0e5913a14a4fba0d3f8" translate="yes" xml:space="preserve">
          <source>The unescaped text</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a791c097d23f087f3b2006b4a3b0840ed65768" translate="yes" xml:space="preserve">
          <source>The unqualified name of this type excluding any dimension information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="932bb11f5980b36dd397c11008ff195342c0ab60" translate="yes" xml:space="preserve">
          <source>The unqualified name of this type excluding any dimension information. For example, a two dimensional array of String returns &quot;&lt;code&gt;String&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ffcabf1d928e33cdd955774a39dbcd5dd5d5a5" translate="yes" xml:space="preserve">
          <source>The unqualified name of this type excluding any dimension or nesting information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7aa9ba3ba0215b9edea5f76f8e108e86c3953aa" translate="yes" xml:space="preserve">
          <source>The unqualified name of this type excluding any dimension or nesting information. For example, the class &lt;code&gt;Outer.Inner&lt;/code&gt; returns &quot;&lt;code&gt;Inner&lt;/code&gt;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b210e5f5ae502f06e3eee85bb0d3cddc4c712ed2" translate="yes" xml:space="preserve">
          <source>The updated class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40cc89ba60352f68fafcc4ac4c159121fb14767" translate="yes" xml:space="preserve">
          <source>The upper value in the range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7fce3baf91efcfcd8801fb20b926ae96377e08f" translate="yes" xml:space="preserve">
          <source>The usage message for this example (obtained using &lt;code&gt;cli.usage()&lt;/code&gt;) is shown below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b984acccdc007ab5614270b95defc6666e03e99" translate="yes" xml:space="preserve">
          <source>The valid targetBytecode values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e0cfaca318b8f4da7cebac77fcdbc02f5aa88f" translate="yes" xml:space="preserve">
          <source>The value at which the range originates (may be &lt;code&gt;null&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0402397f26735b2ed2400f8ddcfcc924e0ce9a91" translate="yes" xml:space="preserve">
          <source>The value can be retrieved by calling the &lt;code&gt;get&lt;/code&gt; method with a key that is equal to the original key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f18423b74c988542bc6f5c88a519429fcc1c89e9" translate="yes" xml:space="preserve">
          <source>The value of a QName contains a &lt;b&gt;namespaceURI&lt;/b&gt;, a &lt;b&gt;localPart&lt;/b&gt; and a &lt;b&gt;prefix&lt;/b&gt;. The localPart provides the local part of the qualified name. The namespaceURI is a URI reference identifying the namespace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d581e8a0b9a8abf2d88f586b7d5f11976e2b4718" translate="yes" xml:space="preserve">
          <source>The value of the executable attribute, if any.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9c238280b9b2287b4cd66fc20e8037b6edcacf3" translate="yes" xml:space="preserve">
          <source>The value returned by the script</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87217bb3f735edd3580af114cd6ab58dbbe6f228" translate="yes" xml:space="preserve">
          <source>The value returned from the execution of the script (if supported by the Script engine)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d702c028dc14f7beea06e57a018660f6784af85a" translate="yes" xml:space="preserve">
          <source>The value separator for this multi-valued option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38f5980b9a59a25ffdbd05535eef7c76cba55950" translate="yes" xml:space="preserve">
          <source>The value separator for this multi-valued option. Only allowed for array-typed arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6847d558c266cc9ad7b554d665f6eb7a61327329" translate="yes" xml:space="preserve">
          <source>The value the option should have if it did not appear on the command line. The specified String value will be split into parts with the &lt;code&gt;valueSeparator&lt;/code&gt; and converted to the option &lt;code&gt;type&lt;/code&gt; before it is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3481a95548ae3ca973619a2db287d20033ea8206" translate="yes" xml:space="preserve">
          <source>The values of each of the attributes on the MBean</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53301301b27b5840479d76543713ebc0154d3193" translate="yes" xml:space="preserve">
          <source>The xmlns namespace definition for &lt;code&gt;gsp:&lt;/code&gt; tags will be removed but other namespace definitions will be preserved (but may change to an equivalent position within the XML tree).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba86101ce4cb5b4110e9233defd7487d64710f7" translate="yes" xml:space="preserve">
          <source>Then calling the command line with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21704ce2ef786ce4f4d39ef635a67321094be364" translate="yes" xml:space="preserve">
          <source>Then for the objects defined earlier, the following would be true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef5935a3802e9c731a629c2d3dea2e39fefd2688" translate="yes" xml:space="preserve">
          <source>Then it can be used inside a template like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7717c315c219349dde87bf9f638b3cb7bca01e90" translate="yes" xml:space="preserve">
          <source>Then the output will be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="864c134c8c6b2e00f7e8bc3ed68b30a559cbae27" translate="yes" xml:space="preserve">
          <source>Then this description is supplied to CliBuilder during parsing, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8374b2c2645caacda80d91902c858cf6eea4f9dd" translate="yes" xml:space="preserve">
          <source>Then you can create the structure using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="947e20775c08c2347253e8e5fa3ea40f8f8dd552" translate="yes" xml:space="preserve">
          <source>There are numerous options to customize the format of the generated output. E.g. if you change the first annotation to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="563196ba8420a662ed40e16f59935b76206ff249" translate="yes" xml:space="preserve">
          <source>There are several variables in the script binding:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4572f137c1c0ff3c8ab5a5964aa37a98f650fc5" translate="yes" xml:space="preserve">
          <source>There are three types of ClassNodes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bba0d9440062e4b938ad280aac889cc0eb5c94e" translate="yes" xml:space="preserve">
          <source>There is also a convenience form of ignore that matches the same style as demand. E.g. instead of &lt;code&gt;mock.ignore('hasNext')&lt;/code&gt; you can use &lt;code&gt;mock.ignore.hasNext()&lt;/code&gt;. A Closure variation is also provided. This convenience shorthand only applies to the &lt;code&gt;String&lt;/code&gt; form of ignore and cannot be used with methods from &lt;code&gt;java.lang.Object&lt;/code&gt;. Be careful using this feature while mocking some of the fundamental Java classes like &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;Pattern&lt;/code&gt;. As these are used within the implementation of the ignore capability, strange behavior may be observed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ebe4c456d8370715d9755e4586403958f169f6" translate="yes" xml:space="preserve">
          <source>There is also support for including or excluding fields/properties by name when constructing the equals and hashCode methods as shown here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09e297702b5735499b1fd1768938b8ac48de65f4" translate="yes" xml:space="preserve">
          <source>There's no way in Java or Groovy to express the type signature of the expected closure call method from outside the closure itself, so we rely on an annotation here. Unfortunately, annotations also have limitations (like not being able to use generics placeholder as annotation values) that prevent us from expressing the type directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c18b23776942b361d4b98fa35e6f9472dbefb7b1" translate="yes" xml:space="preserve">
          <source>Therefore, f(x,y, a:p, b:q) {s} is equivalent in all ways to f(x,y, [a:p,b:q], {s}). Spread arguments of sequence type count as unlabeled arguments, while spread arguments of map type count as labeled arguments. (This distinction must sometimes be checked dynamically.) A plain unlabeled argument is allowed to match a trailing Map or Closure argument: f(x, a:p) {s} === f(*[ x, [a:p], {s} ])</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf6f329bdd2bfe03d147cee437e1f28acbe9bec" translate="yes" xml:space="preserve">
          <source>These rules are different from Java's &quot;dumb expression&quot; restriction. Unlike Java, Groovy blocks can end with arbitrary (even dumb) expressions, as a consequence of optional 'return' and 'continue' tokens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd6b0156ded337bff046c6c15b9f9acafbe9d9f" translate="yes" xml:space="preserve">
          <source>Things that can show up as expressions, but only in strict contexts like inside parentheses, argument lists, and list constructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f14934bd3a85bcc4e7a08b55ecfe6eb236ddcff" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.4&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41689f1ac38712a28ee794030339205948d12a07" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.5&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f297bc1639a07cc1f354bdef8b770444ae17d9a" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.6&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fb8c7a4c95ce1386b3f28c134d8693268f0f7af" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.7&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.7.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cb5fc7c5b688d3d7cf1465b6b36be120c55f7d5" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.8&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4db730fb6bbc9127357c8981de76c8767a22995c" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;10&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7253e572c58af323680948d9124eb666a503dc70" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;11&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 11.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a0d2ab0453c0d76f9aec2ffa7dab4ddcaac8ea" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;12&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 12.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92239128e3fca4fd124d3c3ff8f83f20507689db" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;13&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 13.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9227107e2eef78c2490b7685cfcbd9e12fac74d" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;14&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 14.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8c680713844e7c900b549a36c6de7e34f563c98" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;15&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1c463b78b8f124ac2eec3fd756cac7f533dfce9" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;16&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b242e1445386ea26fd4353cac30d1a7873acc0d" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;9&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 9.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beee2f48ce8c2bdd9d82e37070e460c27f51fba0" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../classnode&quot;&gt;ClassNode&lt;/a&gt; specialization is used when the lowest upper bound of two types cannot be represented by an existing type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f55f8d16febb565101695bf40d07384fdcedba3d" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../classnode&quot;&gt;ClassNode&lt;/a&gt; specialization is used when the lowest upper bound of two types cannot be represented by an existing type. For example, if B extends A, C extends A and both C and B implement a common interface not implemented by A, then we use this class to represent the bound. At compile time, some classes like &lt;a href=&quot;../../classgen/asmclassgenerator&quot;&gt;AsmClassGenerator&lt;/a&gt; need to know about a real class node, so we compute a &quot;compile time&quot; node which will be used to return a name and a type class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd4628d474bbecaf52d4fae2554f6f6dafd33e5e" translate="yes" xml:space="preserve">
          <source>This AST transform creates (potentially) numerous constructors. You should take care to avoid constructors with duplicate signatures if you are defining your own constructors or combining with other AST transforms which create constructors (e.g. &lt;code&gt;@TupleConstructor&lt;/code&gt;); the order in which the particular transforms are processed becomes important in that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e36f809432dd63402bc50997d22ab6edaf317f70" translate="yes" xml:space="preserve">
          <source>This AST transform might become a no-op if you are defining your own constructors or combining with other AST transforms which create constructors (e.g. &lt;code&gt;@InheritConstructors&lt;/code&gt;); the order in which the particular transforms are processed becomes important in that case. See the &lt;code&gt;force&lt;/code&gt; attribute for further details about customizing this behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15f2811221f75ab7d18ebc91f442dd8504abe34a" translate="yes" xml:space="preserve">
          <source>This AST transform normally uses default parameter values which creates multiple constructors under the covers. You should use with care if you are defining your own constructors or combining with other AST transforms which create constructors (e.g. &lt;code&gt;@InheritConstructors&lt;/code&gt;); the order in which the particular transforms are processed becomes important in that case. See the &lt;code&gt;defaults&lt;/code&gt; attribute for further details about customizing this behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e45867f90c0607353adaf6e73abff7c9d75404" translate="yes" xml:space="preserve">
          <source>This AST transformation aims at helping in debugging other AST transformations. It provides a basic infrastructure for performing tests on AST nodes. You can place this annotation on any node which accepts an annotation (types, methods, annotations, constructors, fields, local variables, packages or parameters), then use a script which is run against this AST node at a specific phase. For example, you could test the &lt;a href=&quot;field&quot;&gt;Field&lt;/a&gt; AST transformation this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29dcdadce343c996ed956f4651064a49228e35e3" translate="yes" xml:space="preserve">
          <source>This ClassLoader should be used as root of class loaders. Any RootLoader does have its own classpath. When searching for a class or resource this classpath will be used. Parent Classloaders are ignored first. If a class or resource can't be found in the classpath of the RootLoader, then parent is checked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf55f18fc8d0076e97f9f960b82f80de35bb3681" translate="yes" xml:space="preserve">
          <source>This MetaBeanProperty will create a pseudo property whose value is bound to an object using weak references. The values will go out of scope and be garbage collected when the object is collected In fact, this class should be called ExpandoProperty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="704cf8159f321950d7439d8157804780ec00808e" translate="yes" xml:space="preserve">
          <source>This MetaClass is for internal usage only!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="550e8ef2b445d11145333f7d61692b3a9a8521d7" translate="yes" xml:space="preserve">
          <source>This TestHarness exists so that a global transform can be run without using the Jar services mechanism, which requires building a jar. To use this simply create an instance of TransformTestHelper with an ASTTransformation and CompilePhase, then invoke parse(File) or parse(String). This test harness is not exactly the same as executing a global transformation but can greatly aide in debugging and testing a transform. You should still test your global transformation when packaged as a jar service before releasing it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c82a01d51cf967248d2d13c51ea281168a11d159" translate="yes" xml:space="preserve">
          <source>This Writer is used to generate the call invocation byte codes for usage by invokedynamic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d417d2cc7f087e2cdc7df384d7a9c24827840c1" translate="yes" xml:space="preserve">
          <source>This allows callbacks to the ExpandoMetaClass for registering appending methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ec4e7b6ccc818185756b4b5a332b9d3ffec2cf" translate="yes" xml:space="preserve">
          <source>This allows equals to be overridden by a closure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a87473814b341719aa50b456949655ef70f8692" translate="yes" xml:space="preserve">
          <source>This allows hashCode to be overridden by a closure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be7fcf1022ddc09fab428bf809d227229df0478" translate="yes" xml:space="preserve">
          <source>This allows toString to be overridden by a closure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="904b268e24ef2338f73c60ee6653805eb03db45f" translate="yes" xml:space="preserve">
          <source>This annotation adds Java-style listener support to a class based on an annotated Collection-property.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="456bbcadaaaab286f459087a19ee8bf423978b1b" translate="yes" xml:space="preserve">
          <source>This annotation can also be used to help the type checker (&lt;a href=&quot;../transform/typechecked&quot;&gt;TypeChecked&lt;/a&gt;) which would not report errors then if the delegate is of the documented type. Of course, it is also compatible with &lt;a href=&quot;../transform/compilestatic&quot;&gt;CompileStatic&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f85deef9d102451f990e95bce3bc073d25fbab0b" translate="yes" xml:space="preserve">
          <source>This annotation can be added on a trait to declare the list of types that a class implementing that trait is supposed to extend. This is useful when you want to be able to call methods from the class implementing the trait without having to declare all of them as members of the trait. Self types are particularly useful in combination with &lt;a href=&quot;compilestatic&quot;&gt;CompileStatic&lt;/a&gt;, if you know that a trait can only be applied to a specific type but that the trait cannot extend that type itself. For example, imagine the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90bf79a957044e0c4bcbe98180025021e13ba83a" translate="yes" xml:space="preserve">
          <source>This annotation can be used by API or DSL writers to document parameters which accept a closure. In that case, using this annotation, you can specify what the delegate type of the closure will be. This is important for IDE support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecea2ce9782577916440255f7ef418cba5693cc7" translate="yes" xml:space="preserve">
          <source>This annotation can only be applied to a field of type Collection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23faf967c5242f98ba0f1bfb8360a62caf1714ca" translate="yes" xml:space="preserve">
          <source>This annotation is a declarative wrapper around the JDK's &lt;code&gt;java.util.concurrent.locks.ReentrantReadWriteLock&lt;/code&gt;. Objects containing this annotation will have a ReentrantReadWriteLock field named &lt;code&gt;$reentrantLock&lt;/code&gt; added to the class, and method access is protected by the lock. If the method is static then the field is static and named &lt;code&gt;$REENTRANTLOCK&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ee69ca6c59b77f4f301dba9f69b7ae03123c8fb" translate="yes" xml:space="preserve">
          <source>This annotation is added by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284afc2f65c87063203dea977155cf54b2e047bd" translate="yes" xml:space="preserve">
          <source>This annotation is used in conjunction with &lt;a href=&quot;withreadlock&quot;&gt;WithReadLock&lt;/a&gt; to support read and write synchronization on a method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17c946a06e7f552c5a667fd66607967ecf31f9f4" translate="yes" xml:space="preserve">
          <source>This annotation is used in conjunction with &lt;a href=&quot;withwritelock&quot;&gt;WithWriteLock&lt;/a&gt; to support read and write synchronization on a method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="887147df53ade494df6c8d9012ec7612dd2f4226" translate="yes" xml:space="preserve">
          <source>This applies to the grab and resolve calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a921b8a7c1a5d233057197c112f7c4cb8b092bff" translate="yes" xml:space="preserve">
          <source>This behavior can be disabled by setting the annotation's &lt;code&gt;interfaces&lt;/code&gt; element to false, i.e. &lt;code&gt;@Delegate(interfaces = false)&lt;/code&gt;, e.g. in the above example, the delegate definition would become:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788d0e9e6025f3d507fbe4b1a671cab778fcc046" translate="yes" xml:space="preserve">
          <source>This builder supports the usual builder syntax made of nested method calls and closures, but also some specific aspects of JSON data structures, such as list of values, etc. Please make sure to have a look at the various methods provided by this builder to be able to learn about the various possibilities of usage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8635421fede240629f5bedb5b4f58cb9f602fa9" translate="yes" xml:space="preserve">
          <source>This cache contains mappings of file name to class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370ea64c9230c916cbe3b4f3656932f0e6a2c4bc" translate="yes" xml:space="preserve">
          <source>This cache contains mappings of file name to class. It is used to bypass compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88d556d068acd75020d51487e54372a78b6ff46d" translate="yes" xml:space="preserve">
          <source>This class also supports optional guaranteed exclusive reads, simply by surrounding a call within a synchronized block, as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8508f2b4673f6cfee9a6f3c2b3e95fec3b67deb5" translate="yes" xml:space="preserve">
          <source>This class and its views and iterators implement all of the &lt;em&gt;optional&lt;/em&gt; methods of the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; and &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt;Iterator&lt;/a&gt; interfaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7efe531dee1a194a6b26a56274948d2b3619130" translate="yes" xml:space="preserve">
          <source>This class checks the handling of labels in the AST</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c32390b3fa0798fcae7e17bde6e60d95b95add0f" translate="yes" xml:space="preserve">
          <source>This class codes around a silly limitation of StringWriter which doesn't allow a StringBuffer to be passed in as a constructor for some bizarre reason. So we replicate the behaviour of StringWriter here but allow a StringBuffer to be passed in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc053f62ed97562a5d93d1422bb69af81f8e57b" translate="yes" xml:space="preserve">
          <source>This class contains a static utility method &lt;a href=&quot;#doExtendTraits(org.codehaus.groovy.ast.ClassNode,%20org.codehaus.groovy.control.SourceUnit,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;doExtendTraits(org.codehaus.groovy.ast.ClassNode, org.codehaus.groovy.control.SourceUnit, org.codehaus.groovy.control.CompilationUnit)&lt;/a&gt; aimed at generating code for a classnode implementing a trait.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1390a9bb5928eb78b502051fa6490144b85fc73" translate="yes" xml:space="preserve">
          <source>This class contains guards, runtime filters and MethodType signatures used by indy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69d74fd6b193fe5e0c2269389a27f951ab4b1918" translate="yes" xml:space="preserve">
          <source>This class contains helper methods for converting and comparing types. WARNING: This class is for internal use only. do not use it outside of its package and not outside groovy-core.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2eed5867aee96ae1999d8644dc789cf19d0975" translate="yes" xml:space="preserve">
          <source>This class contains math operations used by indy instead of the normal meta method and call site caching system. The goal is to avoid boxing, thus use primitive types for parameters and return types where possible. WARNING: This class is for internal use only. Do not use it outside of the org.codehaus.groovy.vmplugin.v7 package of groovy-core.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c7a1f038c0d6b2a23d2ab51b95c86eac51cf7a" translate="yes" xml:space="preserve">
          <source>This class contains methods special to optimizations used directly from bytecode in Groovy 1.8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="316c4500322f8ef05e5c4de531c7dc7bc6e842c4" translate="yes" xml:space="preserve">
          <source>This class contains several transformers for used during method invocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1768003da8eeae27f66ecf9e1f2dbf815c0a1e83" translate="yes" xml:space="preserve">
          <source>This class contains utility methods to determine which class called the current class to multiple levels of depth. Calls used to handle the groovy MOP are excluded from the level counting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221b99a286abc745efa1b934a4f00c7b6aa4732f" translate="yes" xml:space="preserve">
          <source>This class controls the conversion from a Groovy script as a String into a tree representation of the AST of that script. The script itself will be a tree node, and each class in the script will be a tree node. The conversion creates tree nodes for any concrete class found within an AST visitor. So, if a tree node should be shown once for each ASTNode and the parent types will not appear as nodes. Custom subclasses of expression types will not appear in the tree. The String label of a tree node is defined by classname in AstBrowserProperties.properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d454a30f57963a7de123921ca0b60e62b5e13e35" translate="yes" xml:space="preserve">
          <source>This class defines a single static method taking the string instance as first argument, allowing to define a new instance method on the String class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e8b6ae7361745c2ea205471fce2c8b2f23b8fe8" translate="yes" xml:space="preserve">
          <source>This class defines a wrapper for accessing a specific column in &lt;code&gt;ResultSetMetaData&lt;/code&gt;. This allows iteration over columns using idiomatic Groovy, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f3f0165db0a67f63374a90150dc420fe8fa8906" translate="yes" xml:space="preserve">
          <source>This class defines all the encoding/decoding groovy methods which enhance the normal JDK classes when inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddd6dbb32c165e8ccdc7c778b5ff92b6e5a6e046" translate="yes" xml:space="preserve">
          <source>This class defines all the new SQL-related groovy methods which enhance the normal JDK SQL classes when inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e4cf1f1d1626756e2ccfaa4e27ca5b4fe7667ce" translate="yes" xml:space="preserve">
          <source>This class defines all the new Swing-related groovy methods which enhance the normal JDK Swing classes when inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bc8d743038c2ddaea690f3c08b6f791f09b985b" translate="yes" xml:space="preserve">
          <source>This class defines all the new XML-related groovy methods which enhance the normal JDK XML classes when inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e53123fb5c78332de5d2876769f4a204051159" translate="yes" xml:space="preserve">
          <source>This class defines all the new static groovy methods which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter as the destination class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf10e978d074ae7e5e07e788c9748ff6b749eed" translate="yes" xml:space="preserve">
          <source>This class defines new Groovy methods which appear on normal JDK Date/Time API (java.time) classes inside the Groovy environment. These extensions require JDK 8 or above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8a356a24d0f45345f38f9c5e624401ea122feb" translate="yes" xml:space="preserve">
          <source>This class defines new Java 5 specific groovy methods which extend the normal JDK classes inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3335bc6567d5a0923632b42415b2259b7d1a9ca9" translate="yes" xml:space="preserve">
          <source>This class defines new Java 6 specific groovy methods which extend the normal JDK classes inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbc656debe43046569a9d23c80bd193a41215a53" translate="yes" xml:space="preserve">
          <source>This class defines new Java 6 specific static groovy methods which extend the normal JDK classes inside the Groovy environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48c87f705bf49123468d54ad93a33becf3eeea6d" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods for Files, URLs, URIs which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter being the destination class, i.e. &lt;code&gt;public static long size(File self)&lt;/code&gt; provides a &lt;code&gt;size()&lt;/code&gt; method for &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea9ee44a185e75c57ac3db064101c0dc7b71846" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods for Readers, Writers, InputStreams and OutputStreams which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter being the destination class, i.e. &lt;code&gt;public static T eachLine(InputStream self, Closure c)&lt;/code&gt; provides a &lt;code&gt;eachLine(Closure c)&lt;/code&gt; method for &lt;code&gt;InputStream&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb04b5af77efd219c4b5a9414f1ff8646ff26a61" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods for Sockets which enhance JDK classes inside the Groovy environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94e1494a582102e49d29876303786a0362da0d77" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on Jaxb-related JDK classes (&lt;code&gt;JAXBContext&lt;/code&gt;, &lt;code&gt;Marshaller&lt;/code&gt;) inside the Groovy environment. Static methods are used with the first parameter being the destination class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb7507827959ad4b29159fe5d7fffc42f2f585e" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on String-related JDK classes (String, CharSequence, Matcher) inside the Groovy environment. Static methods are used with the first parameter being the destination class, e.g. &lt;code&gt;public static String reverse(String self)&lt;/code&gt; provides a &lt;code&gt;reverse()&lt;/code&gt; method for &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f855a0c8edce7e177b8b45a6cbe1be9748fa85a5" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on normal JDK Date and Calendar classes inside the Groovy environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7539a6b02de0acc678a620086fdddde40b1d36f7" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter being the destination class, i.e. &lt;code&gt;public static String reverse(String self)&lt;/code&gt; provides a &lt;code&gt;reverse()&lt;/code&gt; method for &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d775343e0c1cedc8e65538de82853d5aec499d" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on normal JDK classes related to process management.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93c83296c1339bc893ca28a97ad7ad9e35c69b38" translate="yes" xml:space="preserve">
          <source>This class defines new groovy static methods which appear on normal JDK Date and Calendar classes inside the Groovy environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48764622300d44ff21eff5891fc9ff2ebe3f07cb" translate="yes" xml:space="preserve">
          <source>This class defines new static extension methods which appear on normal JDK Date/Time API (java.time) classes inside the Groovy environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf24bf76d96add06db8b90790f6d00a2cfad2055" translate="yes" xml:space="preserve">
          <source>This class does not provide the ability to customize the resulting output. A &lt;a href=&quot;jsongenerator&quot;&gt;JsonGenerator&lt;/a&gt; can be used if the ability to alter the resulting output is required.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c469cd04a8269f915fbdad81a3e9c2f515539197" translate="yes" xml:space="preserve">
          <source>This class handles caching internally and its advisable to not store references directly to objects of this class. The static factory method &lt;a href=&quot;classinfo#getClassInfo(java.lang.Class)&quot;&gt;ClassInfo.getClassInfo&lt;/a&gt; should be used to retrieve an instance from the cache. Internally the &lt;code&gt;Class&lt;/code&gt; associated with a &lt;code&gt;ClassInfo&lt;/code&gt; instance is kept as &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ref/WeakReference.html&quot;&gt;WeakReference&lt;/a&gt;, so it not safe to reference and instance without the Class being either strongly or softly reachable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dde5778cb52a324896ffae7cfbf596d97d66c91" translate="yes" xml:space="preserve">
          <source>This class handles converting Strings to ASTNode lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e92e6926c2a201584cdcb9f5d948909b564b830" translate="yes" xml:space="preserve">
          <source>This class handles the invocation of the ASTAnnotationTransformation when it is encountered by a tree walk. One instance of each exists for each phase of the compilation it applies to. Before invocation the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e6d3f76a3c4311415b9304af550d64f39dd083" translate="yes" xml:space="preserve">
          <source>This class has several inner classes that also helps picking generic argument types instead of the parameter type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3837874bec8e4931d877954a86a0917c89371a7f" translate="yes" xml:space="preserve">
          <source>This class is &lt;b&gt;not&lt;/b&gt; thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb171051a560c489be8ec957676e4fd0c5c42c0f" translate="yes" xml:space="preserve">
          <source>This class is a general adapter to adapt a closure to any Java interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1904a5f416e052d74d08f3361764dad66bf5f12b" translate="yes" xml:space="preserve">
          <source>This class is a general adapter to adapt a map of closures to any Java interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd0e9b1d846e158bbf918633b43cd721a0206943" translate="yes" xml:space="preserve">
          <source>This class is a general adapter to map a call to a Java interface to a given delegate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="407993abd5f454fb2d6c0556db6a1d0ca2f05505" translate="yes" xml:space="preserve">
          <source>This class is extended by several hint providers that make it easier to use as annotation values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75718b0560771207235791afb3b9fda1625fc4bb" translate="yes" xml:space="preserve">
          <source>This class is for internal use only! This class will dispatch to the right type adapters according to the kind of binary expression that is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76d7804b1c6dc7652647c993f4fdf0eded744a8a" translate="yes" xml:space="preserve">
          <source>This class is important to the performance of the parser. It stores Value objects in a map where they are evaluated lazily. This is great for JSONPath types of application, and Object Serialization but not for maps that are going to be stored in a cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96572291f640285f4a1f9ecf3aa073f0a992daab" translate="yes" xml:space="preserve">
          <source>This class is instantiated and invoked when an AST transformation is activated. For Global AST Transformations, this interface is called once per SourceUnit, which is usually a Groovy source file. For Local AST Transformations, this interface is invoked once every time the Local annotation marker is encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc67996ced277a761581444c4cf862c08d075467" translate="yes" xml:space="preserve">
          <source>This class is responsible for assembling JMX Attribute Info from the meta map. It cycles through the meta map from the Node and generate JMX Info objects used to expose information in the MBeanServer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="075476029820d79cc983f42159f8eb4cdea63809" translate="yes" xml:space="preserve">
          <source>This class is responsible for assembling JMX Operation Info from the meta map. It cycles through the provided meta map from the bean() node and generate JMX Info objects used to expose information in the MBeanServer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b30124afd1417d4b385c76f80bcf34578d51bd0" translate="yes" xml:space="preserve">
          <source>This class is the base for any annotation alias processor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5924197edb00c649d5d755fc6516a87d87145be3" translate="yes" xml:space="preserve">
          <source>This class is the factory for the emitter node. This node facilitates the declaration of a JMX event emitter. The emitter is used to broadcast arbitrary event on the MBeanServer's event bus. Registered listeners are able to consume event once sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="653683ec37c7baebfd2f2bbe95b36d002cf25d2e" translate="yes" xml:space="preserve">
          <source>This class is used as a pluggable way to resolve class names. An instance of this class has to be added to &lt;a href=&quot;compilationunit&quot;&gt;CompilationUnit&lt;/a&gt; using &lt;a href=&quot;compilationunit#setClassNodeResolver(org.codehaus.groovy.control.ClassNodeResolver)&quot;&gt;CompilationUnit.setClassNodeResolver&lt;/a&gt;. The CompilationUnit will then set the resolver on the &lt;a href=&quot;resolvevisitor&quot;&gt;ResolveVisitor&lt;/a&gt; each time new. The ResolveVisitor will prepare name lookup and then finally ask the resolver if the class exists. This resolver then can return either a SourceUnit or a ClassNode. In case of a SourceUnit the compiler is notified that a new source is to be added to the compilation queue. In case of a ClassNode no further action than the resolving is done. The lookup result is stored in the helper class LookupResult. This class provides a class cache to cache lookups. If you don't want this, you have to override the methods &lt;a href=&quot;classnoderesolver#cacheClass(java.lang.String,%20org.codehaus.groovy.ast.ClassNode)&quot;&gt;ClassNodeResolver.cacheClass&lt;/a&gt; and &lt;a href=&quot;classnoderesolver#getFromClassCache(java.lang.String)&quot;&gt;ClassNodeResolver.getFromClassCache&lt;/a&gt;. Custom lookup logic is supposed to go into the method &lt;a href=&quot;classnoderesolver#findClassNode(java.lang.String,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;ClassNodeResolver.findClassNode&lt;/a&gt; while the entry method is &lt;a href=&quot;classnoderesolver#resolveName(java.lang.String,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;ClassNodeResolver.resolveName&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14354187c290397fd82b9881697595ff4486600" translate="yes" xml:space="preserve">
          <source>This class is used internally by the compiler to transform expressions like multiple assignments into a list of assignments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b644eb64cd81a47f8da1cd879e99bb7530c7027" translate="yes" xml:space="preserve">
          <source>This class is used to describe generic type signatures for ClassNodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6a7563ff7840c43f2735a87393e68cb11d3a71" translate="yes" xml:space="preserve">
          <source>This class is used to make extension methods lookup faster. Basically, it will only collect the list of extension methods (see &lt;a href=&quot;../../runtime/m12n/extensionmodule&quot;&gt;ExtensionModule&lt;/a&gt; if the list of extension modules has changed. It avoids recomputing the whole list each time we perform a method lookup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5036dcc6c04f6c16da5439995a0999d3e2a24e94" translate="yes" xml:space="preserve">
          <source>This class may be used as a direct replacement for any use of java.util.Hashtable that does not depend on readers being blocked during updates. Like Hashtable but unlike java.util.HashMap, this class does NOT allow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d272b41b9db7786d68de80b43d127b8fd19109cd" translate="yes" xml:space="preserve">
          <source>This class mutates the Java AST, whilst it is still a Java AST, in readiness for conversion to Groovy, yippee-ky-a !</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d9c8517d3a0e99ce14f62132a7aaace2185bbd" translate="yes" xml:space="preserve">
          <source>This class provides a very simple linked list of memory managed elements. This class does not support concurrent modifications nor will it check for them. This class is also not thread safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28a37ccc500981db234c339f5342ff417d4b979f" translate="yes" xml:space="preserve">
          <source>This class provides an AST Transformation to add a log field to a class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a68d6bf431714254204e9288b4f6f5070f27cb" translate="yes" xml:space="preserve">
          <source>This class provides an empty implementation of &lt;a href=&quot;groovyparservisitor&quot;&gt;GroovyParserVisitor&lt;/a&gt;, which can be extended to create a visitor which only needs to handle a subset of the available methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9b1f302f9aedce71bb6896db58d1478516c5a7c" translate="yes" xml:space="preserve">
          <source>This class provides helper methods to determine the type from a widening operation for example for a plus operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d718529ccca05eed963c102f62e0edbdeac53d0" translate="yes" xml:space="preserve">
          <source>This class represents a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; that is optimized for a small number of entries. For a number of entries up to &lt;code&gt;listSize&lt;/code&gt; the entries are stored in arrays. After &lt;code&gt;listSize&lt;/code&gt; entries are exceeded storage switches internally to a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; and converts back to being array based when its size is less than or equal to &lt;code&gt;listSize&lt;/code&gt;. Null keys or values are not supported. This class is not thread safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f6265e2af3bfac2864af2a93fa49da29483f821" translate="yes" xml:space="preserve">
          <source>This class represents a MetaMethod that is a closure that pretends to be a static method. It is used by ExpandoMetaClass to allow addition of static methods defined as closures</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ff97f4943b1b4f4e15e6cd296448b65369de926" translate="yes" xml:space="preserve">
          <source>This class represents a list of expressions used to create closures. Example: &lt;code&gt;
 def foo = (1;2;;)
 &lt;/code&gt; The right side is a ClosureListExpression consisting of two ConstantExpressions for the values 1 and 2, and two EmptyStatement entries. The ClosureListExpression defines a new variable scope. All created Closures share this scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e490a48691949cdd943dd24ddf11e92b18b4c106" translate="yes" xml:space="preserve">
          <source>This class represents a property with multiple setters. Unlike a MetaBeanProperty you cannot get the setter in this case. Instead invocation is done through the meta class of the property recevier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9fe55eb136f2d9bda5b170f7ec0b6ef4984da04" translate="yes" xml:space="preserve">
          <source>This class represents a reference to the most actual incarnation of a Metaclass. INTERNAL USE ONLY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1af226539f2899b14379794e0635a39c3ce7e1e" translate="yes" xml:space="preserve">
          <source>This class represents a sequence of &lt;a href=&quot;bytecodeinstruction&quot;&gt;BytecodeInstruction&lt;/a&gt;s or &lt;a href=&quot;../ast/astnode&quot;&gt;ASTNode&lt;/a&gt;s. The evaluation is depending on the type of the visitor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5460585a78cb458d104b1c09f4518524d3250db9" translate="yes" xml:space="preserve">
          <source>This class represents an error that is thrown when a bug is recognized inside the runtime. Basically it is thrown when a constraint is not fulfilled that should be fulfilled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e8efb041e1d70cfb3206ad25e6c209a78c9bbd0" translate="yes" xml:space="preserve">
          <source>This class represents non public API used by AsmClassGenerator. Don't use this class in your code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dc5c7fcffd17f002fdf6362493892385bbec93d" translate="yes" xml:space="preserve">
          <source>This class returns half bound &lt;a href=&quot;fullbinding&quot;&gt;FullBinding&lt;/a&gt;s on the source half to the model object for every property reference (and I do mean every, valid or not, queried before or not). These returned half bindings are stored strongly in a list when generated. Changing the model will keep all existing bindings but change the source on all of the bindings. Formerly Known as Model Binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6c51aebeac50037713f9721b08801c77dc34e7" translate="yes" xml:space="preserve">
          <source>This class returns half bound &lt;a href=&quot;fullbinding&quot;&gt;FullBinding&lt;/a&gt;s on the source half to the model object for every property reference (and I do mean every, valid or not, queried before or not). These returned half bindings are stored strongly in a list when generated. Changing the model will keep all existing bindings but change the source on all of the bininfs Formerly Known as Model Binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8b96a7d9802784a5662432c77e71b4d3622ca61" translate="yes" xml:space="preserve">
          <source>This class takes Groovy source code, compiles it to a specific compile phase, and then decompiles it back to the groovy source. It is used by GroovyConsole's AST Browser, but can also be invoked from the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="806720aed213bca40586cfe6fc91e7e7625aa6f6" translate="yes" xml:space="preserve">
          <source>This class will delegate all calls to a WriterController given in the constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c4727fcfc1ab42e56910178a7ab2ce60355d891" translate="yes" xml:space="preserve">
          <source>This code is executed after the method is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3715f6b9738b222d0f7aca024f9cc5c22e37d357" translate="yes" xml:space="preserve">
          <source>This code is executed after the method is optionally called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93109698a32aa712b1940a99bdbc8567f3433156" translate="yes" xml:space="preserve">
          <source>This code is executed before the method is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ed3577608647dd335811066a354027a410204a" translate="yes" xml:space="preserve">
          <source>This code is executed before the method is optionally called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b42f2f4e1fd4b46e3443559ab2f4536ce215e3" translate="yes" xml:space="preserve">
          <source>This code is transformed by the compiler into something resembling the following snippet. Notice the difference between a String and a def/Object property:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33c1278e97a91dcb6edf06c86644b99e9f271d8" translate="yes" xml:space="preserve">
          <source>This comparator is used when we return the list of methods from DGM which name correspond to a given name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e75617b624f61b0683d73241b7a0d46ab3599d9b" translate="yes" xml:space="preserve">
          <source>This comparator is used when we return the list of methods from DGM which name correspond to a given name. As we also lookup for DGM methods of superclasses or interfaces, it may be possible to find two methods which have the same name and the same arguments. In that case, we should not add the method from superclass or interface otherwise the system won't be able to select the correct method, resulting in an ambiguous method selection for similar methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4894b9b16a69165c0c31e618c60bcc10ce7fe009" translate="yes" xml:space="preserve">
          <source>This compilation customizer allows addiing various types of imports to the compilation unit. Supports adding:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba2a85f884d7fa0e633cdb111b7b24677cc8a10" translate="yes" xml:space="preserve">
          <source>This completer tries to behave as similar as possible to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="050f26d61c4d7297780b69903203f0b647dfe314" translate="yes" xml:space="preserve">
          <source>This constant is for comparing targetBytecode to ensure it is set to JDK 1.5 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8629d832b003b8c89dc03855aac1608ff5226a1" translate="yes" xml:space="preserve">
          <source>This constant is for comparing targetBytecode to ensure it is set to an earlier value than JDK 1.5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d318776f0e97720de67dae45081b1705371f4405" translate="yes" xml:space="preserve">
          <source>This constructor is public to permit tools that require a JavaBean instance to operate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adebfc74f0005704245e8892d5946a9a3b3e0d7b" translate="yes" xml:space="preserve">
          <source>This converts a possibly negative index to a real index into the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89580999f8cc2ab98adcb35587949a71043dac5a" translate="yes" xml:space="preserve">
          <source>This creates and starts the socket server on a new Thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cfe97596d83c01a3c1b2f921489c411e8f50f6a" translate="yes" xml:space="preserve">
          <source>This creates and starts the socket server on a new Thread. There is no need to call run or spawn a new thread yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f210b6ef5e62f107b81d83cc8ea5f60a3593e2ba" translate="yes" xml:space="preserve">
          <source>This customizer allows applying an AST transformation to a source unit with several strategies. Creating a customizer with the &lt;a href=&quot;asttransformationcustomizer#ASTTransformationCustomizer(java.lang.Class)&quot;&gt; class constructor&lt;/a&gt; will trigger an AST transformation for each class node of a source unit. However, you cannot pass parameters to the annotation so the default values will be used. Writing :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c14dcaf1099adb43e65b7bae2bb439c3ad65669" translate="yes" xml:space="preserve">
          <source>This customizer allows securing source code by controlling what code constructs are permitted. This is typically done when using Groovy for its scripting or domain specific language (DSL) features. For example, if you only want to allow arithmetic operations in a groovy shell, you can configure this customizer to restrict package imports, method calls and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5a34da6d1a917395eafdae691fc9b3b8e14c4ed" translate="yes" xml:space="preserve">
          <source>This differs from normal setters in that we need to add a declared exception java.beans.PropertyVetoException</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a09a623dc06b4ba819cd522a87f90fc6033ededc" translate="yes" xml:space="preserve">
          <source>This enumeration can be used whenever it is preferred to annotate a class as &lt;a href=&quot;typechecked&quot;&gt;TypeChecked&lt;/a&gt; in general, but where only one or more methods are &quot;dynamic&quot;. This allows the user to annotate the class itself then annotate only the methods which require exclusion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7e2273d5cb9c0c49c2bb24c5a83bf004429212a" translate="yes" xml:space="preserve">
          <source>This enumeration is used by the AST transformations which rely on static type checking, either to store or to retrieve information from AST node metadata. The values of this enumeration are used as metadata keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab60dfbbe5ec836f7b35f8c976d66e68b2ce1c5a" translate="yes" xml:space="preserve">
          <source>This example prints out file counts and size aggregates for groovy source files within a directory tree:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f387a9504f8b156c1813987d3758205ede705a" translate="yes" xml:space="preserve">
          <source>This example shows a common convention. When mixing short and long names, the short names are often one character in size. One character options with arguments don't require a space between the option and the argument, e.g. &lt;code&gt;-Ddebug=true&lt;/code&gt;. The example also shows the use of '_' when no short option is applicable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2dddbad35ebae3e8699d18932c17e50f8f9d1bb" translate="yes" xml:space="preserve">
          <source>This example uses a mix of the JSP style and GString style placeholders but you can typically use just one style if you wish. Running this example will produce this output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7819bf00abfa1a28062447c4112ec17536e74c15" translate="yes" xml:space="preserve">
          <source>This example will produce this output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a9df6b19f4850ac1dca0ca99754733c1765bf4e" translate="yes" xml:space="preserve">
          <source>This exception is thrown if an attempt is made to set a read only property</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c90e86c15b6995f6996affd8fd0622412caea4" translate="yes" xml:space="preserve">
          <source>This exception is thrown if the runtime is unable to select a method. This class builds the exception text when calling getMessage.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a099c6f741eb0347d0ea40c91b286e1ba7e1c6f" translate="yes" xml:space="preserve">
          <source>This extension also supports optional type checking of the model</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0f02c76915f7464bc8c11fd1e37c238231e442" translate="yes" xml:space="preserve">
          <source>This factory allows the generation of a &lt;a href=&quot;../secureastcustomizer&quot;&gt;SecureASTCustomizer&lt;/a&gt;. Embedded elements are delegated to a &lt;a href=&quot;../secureastcustomizer&quot;&gt;SecureASTCustomizer&lt;/a&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75bc8d98e4b55661fc8e92d226274681ee70c5d6" translate="yes" xml:space="preserve">
          <source>This factory allows the generation of an &lt;a href=&quot;../importcustomizer&quot;&gt;import customizer&lt;/a&gt;. You may embed several elements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6408936103d79d9191656e5b5b91824ad76e65c7" translate="yes" xml:space="preserve">
          <source>This factory class is used to create a listener() node for JmxBuilder. Listener nodes are used to create a generic event listener (that is automatically registered with the MBean) that can handle any event broadcasted on the MBeanServer's event bus.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a41a5aefc83666cff21add72710b51c3a25d2f" translate="yes" xml:space="preserve">
          <source>This factory generates an ASTTransformationCustomizer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613b0e8a47bfd00974cb820fbc8fcdabb33420f9" translate="yes" xml:space="preserve">
          <source>This factory generates an array of compilation customizers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9250f3138d28ed13d750ef456e16992d0448f7fb" translate="yes" xml:space="preserve">
          <source>This factory is the correct way to wire together a Groovy parser and lexer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ce93b17831cccaf34755de29d405aee9ba805a" translate="yes" xml:space="preserve">
          <source>This factory lets a user define a compilation customizer without having to define an anonymous inner class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3cad60cfab134b21507e52064941c3963e3069" translate="yes" xml:space="preserve">
          <source>This factory returns a container node for all other nodes that are used to collect meta data for resources that are exported to the MBeanServer for management.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="974ec32a45157e53b4a9707aa7c20f425a6b5889" translate="yes" xml:space="preserve">
          <source>This factory returns the bean() node. This node is used to declaratively expose a POGO/POJO to be exported to the MBeanServer for management. You can use the builder node to declare the descriptor or embed the descriptor directly in the object being exposed using static variable descriptor (or jmx). You should note that embedded descriptor takes precedence over declared builder descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34a50447c879fcb2342872b489a204ccc49314ed" translate="yes" xml:space="preserve">
          <source>This feature is particularly useful on operating systems which place limitations on the size of the command line (e.g. Windows). The feature is similar to the 'Command Line Argument File' processing supported by javadoc and javac. Consult the corresponding documentation for those tools if you wish to see further examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce367d20dbb2c637770c58d933db6117f53236b0" translate="yes" xml:space="preserve">
          <source>This field is used to track assignments in if/else branches, for loops and while loops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbf12fc93c6526242b10d4458cb6d1beee3e2d25" translate="yes" xml:space="preserve">
          <source>This field is used to track assignments in if/else branches, for loops and while loops. For example, in the following code: &lt;code&gt;if (cond) { x = 1 } else { x = '123' }&lt;/code&gt; the inferred type of x after the if/else statement should be the LUB of int and String.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d467559145b6ea3f70124f19c4aef65c4321104" translate="yes" xml:space="preserve">
          <source>This field used for type derivation Check IfStatement matched pattern: Object var1; if (!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd93366cf93d2b7dd6b74705e67955660b7f0e0" translate="yes" xml:space="preserve">
          <source>This field used for type derivation Check IfStatement matched pattern: Object var1; if (!(var1 instanceOf Runnable)){ return } // Here var1 instance of Runnable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b090238d44551f2e3d0b2f1cf114fd579922fca8" translate="yes" xml:space="preserve">
          <source>This fixes strict jline 2.12 ArgumentCompleter See https://github.com/jline/jline2/pull/202</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850443fd7300e262bc8d43a95f5840748fef1125" translate="yes" xml:space="preserve">
          <source>This gets the code statement of the closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="692a8f7be3be9f9075aa6a114742d6a2eca54b83" translate="yes" xml:space="preserve">
          <source>This gets the code statement of the closure. You can read this method to find out what actions the closure is going to perform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a0d23a5c458818da1444db6470960e4731416f6" translate="yes" xml:space="preserve">
          <source>This has the same interface as the original JsonSlurper written for version 1.8.0, but its implementation has completely changed. It is now up to 20x faster than before, and its speed competes and often substantially exceeds popular common JSON parsers circa Jan, 2014.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01f9c203f4513ef8926ff9ee372b31db329b713" translate="yes" xml:space="preserve">
          <source>This hint handles all those cases by picking the generics from the first argument of the method (by default).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8328da1e3c3000c040f7a4774ac735b142d97837" translate="yes" xml:space="preserve">
          <source>This holds a mapping from value key to value value to maximize laziness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74974d1e6f40fe28cb6229fba49e41c77b4b9dfd" translate="yes" xml:space="preserve">
          <source>This implementation breaks the contract of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html#get(int)&quot;&gt;List.get&lt;/a&gt; as it a) possibly modifies the underlying list and b) does NOT throw an &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/IndexOutOfBoundsException.html&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; when &lt;code&gt;index &amp;lt; 0 || index &amp;gt;= size()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8e1fbe89d11c8857d6efca6ff572126bb4b9fb0" translate="yes" xml:space="preserve">
          <source>This implementation provides a verbosity flag switching log statements. The servlet init parameter name is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfe169c077ea389406a1a9f2f85518f31a03e1e3" translate="yes" xml:space="preserve">
          <source>This interface allows the user to provide a custom expression checker if the dis/allowed expression lists are not sufficient</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f685dd51bbeafd50fa968a283a1c649d74afa7b5" translate="yes" xml:space="preserve">
          <source>This interface allows the user to provide a custom statement checker if the dis/allowed statement lists are not sufficient</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2337efc6043edb753db0bcb30b3f4690571b8928" translate="yes" xml:space="preserve">
          <source>This interface defines a complete generic visitor for a parse tree produced by &lt;a href=&quot;groovyparser&quot;&gt;GroovyParser&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2900e3be61204d298b4a3fee9de9690a314c1fa7" translate="yes" xml:space="preserve">
          <source>This interface defines a high-level API for handling type checking errors. As a dynamic language and a platform for developing DSLs, the Groovy language provides a lot of means to supply custom bindings or methods that are not possible to find at compile time. However, it is still possible to help the compiler, for example by telling it what is the type of an unresolved property. For basic DSL type checking, implementing those methods would help the type checker and make it silent where it normally throws errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a3094142b4fffa63ea1c44ae063fa652e1bd9e" translate="yes" xml:space="preserve">
          <source>This interface is for AST transformations which must be aware of the compilation unit where they are applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b19bc498138b8f77f8e42e14567db95fb471708c" translate="yes" xml:space="preserve">
          <source>This is JmxBuilder's factory builder class. It is the parent node to all other children nodes supported by JmxBuilder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f542101a83909bc55b807fe7fad6cb48b595713" translate="yes" xml:space="preserve">
          <source>This is a Token sub class to track line information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b6cd0c90811ee4dbf92dd31e30b69e6a4b7932" translate="yes" xml:space="preserve">
          <source>This is a basic implementation of a map able to forget its values. This map uses internally a ConcurrentHashMap, thus should be safe for concurrency. hashcode and equals are used to find the entries and should thus be implemented properly for the keys. This map does not support null keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecd84853e48a3218ca7dae60fa14210067325fe4" translate="yes" xml:space="preserve">
          <source>This is a basic parser with no index overlay.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd1aba50be39fcc34d283e005a86755e0b3badd7" translate="yes" xml:space="preserve">
          <source>This is a basic parser with no index overlay. It is wicked fast, but not as fast at the INDEX_OVERLAY. It should be on average the fastest known JSON parser on the JVM circa Jan 2014. But not as fast as INDEX_OVERLAY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d663199a467bd31d2d6cc978eef89dea6a3add1" translate="yes" xml:space="preserve">
          <source>This is a bit of plumbing which resumes collection of string constructor bodies, after an embedded expression has been parsed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="229cccdf96ec491181b6b4aefce4ce6c2b429a0f" translate="yes" xml:space="preserve">
          <source>This is a bit of plumbing which resumes collection of string constructor bodies, after an embedded expression has been parsed. Usage: new GroovyRecognizer(new GroovyLexer(in).plumb()).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0186d9b2589f2bdddecc55d72affdc0ae0321117" translate="yes" xml:space="preserve">
          <source>This is a bit of plumbing which resumes collection of string constructor bodies, after an embedded expression has been parsed. Usage: new JavaRecognizer(new JavaLexer(in).plumb()).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f11df9510d09a2eefc345dd606cc8bb630671ad" translate="yes" xml:space="preserve">
          <source>This is a generated class used internally during the writing of bytecode within the CallSiteWriter logic. This is not a class exposed to users, as is the case with almost all classes in the org.codehaus.groovy packages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8988c21207c9c0283d7bdfe9794fc76b8616da94" translate="yes" xml:space="preserve">
          <source>This is a helper class introduced in Groovy 2.1.0, which is used only by indy. This class is for internal use only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd736de461897ac841a6a4d9f0a851a81005bbd5" translate="yes" xml:space="preserve">
          <source>This is a helper class, to provide a controlled entry point for the groovyc ant task forked mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e04a2a9657e4a822125c0bfc5d51625bdcd91ab" translate="yes" xml:space="preserve">
          <source>This is a hook for subclasses to plugin a custom strategy for mapping names to explicit methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6073183624d646ab13405c550c66ceae2d7e6073" translate="yes" xml:space="preserve">
          <source>This is a hook for subclasses to plugin a custom strategy for mapping names to factories.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3873541ad75fb8f477c82880ea8c90da25f7477f" translate="yes" xml:space="preserve">
          <source>This is a hook for subclasses to plugin a custom strategy for mapping names to property methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="851a6e18d0cb9ae66a159433966e5c40ef10ca00" translate="yes" xml:space="preserve">
          <source>This is a implementation of DL distance between two Object arrays instead of character streams.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5dc74906a59f9ecb021663128a7faa33f6bff55" translate="yes" xml:space="preserve">
          <source>This is a implementation of DL distance between two Object arrays instead of character streams. The objects are compared using their equals method. No objects may be null. This implementation is based on Chas Emerick's implementation of Levenshtein Distance for jakarta commons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f63b7ad6a94acd9220b6ceb153faa4b94cff8d8" translate="yes" xml:space="preserve">
          <source>This is a slightly modified version of the Damerau Levenshtein distance algorithm.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6379b9e33df64353e3c1267e96d9abfd788c6427" translate="yes" xml:space="preserve">
          <source>This is a slightly modified version of the Damerau Levenshtein distance algorithm. It has a additional test to see if a character has switched case, in the original algorithm this counts as a substitution. The &quot;cost&quot; for a substitution is given as 10 instead of 1 in this version, this enables transpositions and case modifications to have a lower cost than substitutions. Currently the lowercase versions of t_j and s_i isn't cached, its probable that some speed could be gained from this. This version is based on Chas Emerick's implementation of Levenshtein Distance for jakarta commons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1edb3c98dd64270eec01a19ffa8efd13aa8ca31a" translate="yes" xml:space="preserve">
          <source>This is a static access auto download enabler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="116aa4ab4439a80ee9ba7112e165f856489f00f2" translate="yes" xml:space="preserve">
          <source>This is a static access auto download enabler. It will set the 'autoDownload' value to the passed in arguments map if not already set. If 'autoDownload' is set the value will not be adjusted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="858274acd50bf067c3073a5802ebcb847cb11033" translate="yes" xml:space="preserve">
          <source>This is a static access kill-switch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fe1b6d5fdbc3093d68f9306c05bf649d9053221" translate="yes" xml:space="preserve">
          <source>This is a static access kill-switch. All of the static shortcut methods in this class will not work if this property is set to false. By default it is set to true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9354b1e014a107432bcac0ae43777acc06c0de53" translate="yes" xml:space="preserve">
          <source>This is a utility class used as a helper for JmxBuilder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5225ac2335eb47576067c0b8960cb72cb13bccd" translate="yes" xml:space="preserve">
          <source>This is also different than scripting.dev.java.net which used an initial lowercase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="579c6bcb0a618a267161c2207b075c96e7d5d24d" translate="yes" xml:space="preserve">
          <source>This is also different than scripting.dev.java.net which used an initial lowercase. But these are proper names and should be capitalized.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85d017a024d6049f47ed0da7428c2774554debb2" translate="yes" xml:space="preserve">
          <source>This is an AST Node that provides some sort of looping mechanism. Typically in the form of a block that will be executed repeatedly. DoWhileStatements, WhileStatements, and ForStatements are all examples of LoopingStatements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c9815db791daee2a8e2b715b6bdfe0a35a3e307" translate="yes" xml:space="preserve">
          <source>This is an annotation on a class, currently just &lt;a href=&quot;asttransformation&quot;&gt;ASTTransformation&lt;/a&gt;. This provides information about how and when to apply the transformation, such as what phase it should be applied in. The allowed phase is a function of how the transformation is introduced into the compile process. If the transform is automatically added via a marker annotation only the SEMANTIC_ANALYSIS and latter phases are legal for the phase(). This is because the annotations are not inspected until after the classes are all resolved. Also, only annotation types present during the SEMANTIC_ANALYSIS phase will be handled. Transformations adding other annotations that are transformable will have those new annotations only considered in latter phases, and only if the type was present in the source unit during SEMANTIC_ANALYSIS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e12582da84504f1479b7b5bbe01a600457f89e" translate="yes" xml:space="preserve">
          <source>This is because the Value construct is a type of index overlay that merely tracks where the token is located in the buffer, and what if any thing we noted about it (like can be converted to a decimal number, etc.).  To mitigate memory leaks this class along with CharSequenceValue implement two constructs, namely, chop, and lazyChop.  A chop is when we convert backing buffer of a Value object into a smaller buffer. A lazyChop is when we do a chop but only when a get operation is called.  The lazyChop is performed on the tree that is touched by the JSONPath expression or its ilk.  The chop operation can be done during parsing or lazily by storing the values in this construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="741dcdf92b314485a30d1f79b83cc4f348ec1d58" translate="yes" xml:space="preserve">
          <source>This is commonly used to simplify object creation, such as this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1248b519078b17c04626ddc0fb70c6f2e9facdfe" translate="yes" xml:space="preserve">
          <source>This is especially useful when executing foreign scripts that you do not have control over. Inject this transformation into a script that you need to interrupt based on some custom criteria.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f713a0f10d16561ee1c527588ce545628f9d79" translate="yes" xml:space="preserve">
          <source>This is especially useful when executing foreign scripts that you do not have control over. Inject this transformation into a script that you need to interrupt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f5f8b6a917691ae26019a384a5b0e4890168174" translate="yes" xml:space="preserve">
          <source>This is especially useful when executing foreign scripts that you do not have control over. Inject this transformation into a script that you want to timeout after a specified amount of time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282c12052be9cf10b5ec3f4611f0fd964e9e4aa8" translate="yes" xml:space="preserve">
          <source>This is for internal use only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58697d7fd61dc831ec59911b870e50930ffb3220" translate="yes" xml:space="preserve">
          <source>This is for internal use only. When an argument method is null, we cannot determine its type, so we use this one as a wildcard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4110ed8e2a3513345d548ed89e5744b457556f9f" translate="yes" xml:space="preserve">
          <source>This is helpful for tests that don't currently work but should work one day, when the tested functionality has been implemented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f30890de5ca0bafe206b76653f0c2a1f3cc299" translate="yes" xml:space="preserve">
          <source>This is just a dummy value used because String annotations values can not be null.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6be2a0c0559d3297ae4eb1f68ef079c6642f7daf" translate="yes" xml:space="preserve">
          <source>This is just a dummy value used because String annotations values can not be null. It will be replaced by the fully qualified class name of the annotated class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cfc24f9ba4df725de185c873e645d95b8f9a980" translate="yes" xml:space="preserve">
          <source>This is mostly for debugging and testing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="755a53945cc3fcceccdbfdf945d1dd8ce166c6d1" translate="yes" xml:space="preserve">
          <source>This is not 100% true for days. Days can actually be 23, 24 or 25 hours long (due to daylight saving adjustments.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69572989e14bc32e4253df5a71968b90a55a7b4" translate="yes" xml:space="preserve">
          <source>This is similar to pop on a Stack where the first item in the list represents the top of the stack. Note: The behavior of this method changed in Groovy 2.5 to align with Java. If you need the old behavior use 'removeLast'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2541054c8b1af0657d417013a4c3cc09b16432fc" translate="yes" xml:space="preserve">
          <source>This is similar to push on a Stack where the first item in the list represents the top of the stack. Note: The behavior of this method changed in Groovy 2.5 to align with Java. If you need the old behavior use 'add'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef33e4880a31dfb6572ddc1eafa9904f03c5153" translate="yes" xml:space="preserve">
          <source>This is so we don't have to reorder the stack when we call this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d75685c8a50a89d652d071d7093c3bf15cd602" translate="yes" xml:space="preserve">
          <source>This is so we don't have to reorder the stack when we call this method. At some point a better name might be in order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f165cfd45f1ba553776e75f2e2f8cd2ea732f465" translate="yes" xml:space="preserve">
          <source>This is the base class for classes responsible for creating modules using properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb852c75331161be3de5047f08fe81e729e8211" translate="yes" xml:space="preserve">
          <source>This is the complement the behavior of the decapitalize(string) method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80b2bed606ff187cd7718223d7b85bc65c304789" translate="yes" xml:space="preserve">
          <source>This is the complement the behavior of the decapitalize(string) method. We handle names that begin with an initial lowerCase followed by upperCase with special JavaBean behavior (which is to make no change). See GROOVY-3211.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa3d520cd1c348add237bd7a66f5ecae3276e75e" translate="yes" xml:space="preserve">
          <source>This is the factory for node JmxBuilder.connectorClient. A call to this node returns an instance of the JMXConnector interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1940febb7e000c374518f8af3b2bab8b6e867ba7" translate="yes" xml:space="preserve">
          <source>This is the grammar for what can follow a dot: x.a, x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f014c6ef17ec9a663f43144dcaa01def5b2977" translate="yes" xml:space="preserve">
          <source>This is the grammar for what can follow a dot: x.a, x.@a, x.&amp;amp;a, x.'a', etc. Note: &lt;code&gt;typeArguments&lt;/code&gt; is handled by the caller of &lt;code&gt;namePart&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3383554d710d086a6eaaccc8bcae06fb7d68886" translate="yes" xml:space="preserve">
          <source>This is the implemented method for NotificationListener.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="443ffb1b205dda6b43691a31bf4efab8981aa292" translate="yes" xml:space="preserve">
          <source>This is the implemented method for NotificationListener. It is called by an event emitter to dispatch JMX events to listeners. Here it handles internal JmxBuilder events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8507fa3ee221e6d15aa495ec0771ccde8a6a13ad" translate="yes" xml:space="preserve">
          <source>This is the main method responsible for writing a tag and its attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e6641635e8b64ec4febd6d638bc3e9143705eca" translate="yes" xml:space="preserve">
          <source>This is the main method responsible for writing a tag and its attributes. The arguments may be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc39540baf6302d792409499cb068b434a441c03" translate="yes" xml:space="preserve">
          <source>This is the management interface for JmxEventEmitter. This MBean is used internally by JmxBuilder to broadcast events to registered listeners of the underlying MBeanServer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5b95a30505f17692ef2b43986549d96c8c4624a" translate="yes" xml:space="preserve">
          <source>This is the original slurper included in case someone relies on its exact behavior. JSON slurper which parses text or reader content into a data structure of lists and maps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a8ced6206d14a027d70a5e32a450ce537c155b" translate="yes" xml:space="preserve">
          <source>This is the parser interface that backs the new JsonSlurper. It was derived from the Boon JSON parser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3d06e9412c890cb691176655a805bf3748ea2d9" translate="yes" xml:space="preserve">
          <source>This is the server connector factory used for node JmxBuilder.connectorServer(). A call to this node returns an instance of JMXConnectorServer interface (rmi default).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="230e13efb9db1565670b6fea571db7753bc5e0ed" translate="yes" xml:space="preserve">
          <source>This is the standard Groovy module factory. This factory will build a module using the &lt;a href=&quot;metainfextensionmodule&quot;&gt;MetaInfExtensionModule&lt;/a&gt; by default, unless a key named &quot;moduleFactory&quot; is found in the properties file. If this is the case, then a new factory is instantiated and used instead of this factory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ec506a9828d694bfe5804799dc8c732a9b5a54" translate="yes" xml:space="preserve">
          <source>This is used to defer content creation until the point when it is streamed to the output destination. Oftentimes, content will be defined but not necessarily created (as is may be the case with a Closure definition.) In that case, the output is then 'deferred' to the point when it is serialized to the writer. This class may be used whenever an object should be responsible for creating its own textual representation, but creating the entire output as a single String would be inefficient (such as outputting a multi-gigabyte XML document.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e14e7d5baf0cfd30f91810036e80282c090c67" translate="yes" xml:space="preserve">
          <source>This is useful to temporary change the building context to another builder without the need for a contrived setup. It will also take care of restoring the previous proxyBuilder when the execution finishes, even if an exception was thrown from inside the closure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad15a34847d2c1a8ad922f0d89041ba75723b49e" translate="yes" xml:space="preserve">
          <source>This is useful to temporary change the building context to another builder without the need for a contrived setup. It will also take care of restoring the previous proxyBuilder when the execution finishes, even if an exception was thrown from inside the closure. Additionally it will use the closure's result as the value for the node identified by 'name' and assign any attributes that might have been set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c37a541753d2b221857f2d671ab7f729da865698" translate="yes" xml:space="preserve">
          <source>This is useful to temporary change the building context to another builder without the need for a contrived setup. It will also take care of restoring the previous proxyBuilder when the execution finishes, even if an exception was thrown from inside the closure. Additionally it will use the closure's result as the value for the node identified by 'name'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="456d789e81e107b1750587cc65f969df3b091526" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using Apache Commons logging. Every method call on a unbound variable named</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccdbe2f2abb77f14d2958b7203c74bc3c3238f26" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using Log4j logging. Every method call on a unbound variable named</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca89366d56f13b0ae77d15760011e4c8ce3c9d6" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using Log4j2 logging. Every method call on a unbound variable named</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c21e31e0e213d1b747f0881d81cf15af0983e63" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using LogBack logging. Every method call on a unbound variable named</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a3244e657380e150930ad3c42321efd1a93ab0" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using java.util.logging. Every method call on a unbound variable named</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f16b0ae746e9cea59cf9a1537bd1d3eab7d8506" translate="yes" xml:space="preserve">
          <source>This map is for object serialization mainly. The idea is the final conversion of the Value objects are delayed until the last possible moment, i.e., just before injected into a bean.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="133261c522611d55bc1ac660860148968370dbb5" translate="yes" xml:space="preserve">
          <source>This maps only builds once you ask for a key for the first time. It is designed to not incur the overhead of creating a map unless needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a8f2d66e087d02e8f596d67c48d249055c88c63" translate="yes" xml:space="preserve">
          <source>This may be true even for values not contained in the range. Example: from = 1.5, to = 3, next() increments by 1 containsWithinBounds(2) == true contains(2) == false</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75f0bf4a66a79592bf20cb9599e2cee6c0cf02d5" translate="yes" xml:space="preserve">
          <source>This may not be available in future groovy.util.CliBuilder versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bf475abb2d654e508f4a3ea6b60068d3049398d" translate="yes" xml:space="preserve">
          <source>This may not be available in future groovy.util.CliBuilder versions. Use groovy.cli.commons.CliBuilder if you need this feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29237a4ce5bb61ce2deb69d6d749c4af551bfff9" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;executeBatch()&lt;/code&gt; will be called automatically after the &lt;code&gt;withBatch&lt;/code&gt; closure has finished but may be called explicitly if desired as well for more fine-grained partitioning of the batch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8281417fefc279cbb9a25f17712e4ba86882d29f" translate="yes" xml:space="preserve">
          <source>This method adds a SyntaxException to the error collector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0973d91b058fb6569284667e2f673bb040878f3c" translate="yes" xml:space="preserve">
          <source>This method adds a SyntaxException to the error collector. The exception should specify the line and column number of the error. This method should be reserved for real errors in the syntax of the SourceUnit. If your error is not in syntax, and is a semantic error, or more general error, then use addException or use the error collector directly by retrieving it with getErrorCollector().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41389a9f429a0e723f818e52d3c8405048d8434" translate="yes" xml:space="preserve">
          <source>This method adds an exception to the error collector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad248a00756ca0b2876764f3cadf2058210b535e" translate="yes" xml:space="preserve">
          <source>This method adds an exception to the error collector. The Exception most likely has no line number attached to it. For this reason you should use this method sparingly. Prefer using addError for syntax errors or add an error to the &lt;a href=&quot;errorcollector&quot;&gt;ErrorCollector&lt;/a&gt; directly by retrieving it with getErrorCollector().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b9b9919b102efb75bc0c62d72758785b908443" translate="yes" xml:space="preserve">
          <source>This method builds a single ModelMBeanAttribute info from a given meta data map object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ef8522c2c1425ca76a2dd9e7f7424d35413e383" translate="yes" xml:space="preserve">
          <source>This method calls the JsonLexer to parser the output of the builder, so this may not be an optimal method to call, and should be used mainly for debugging purpose for a human-readable output of the JSON content.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="573fa6ce3c9bb7134c818285958a90ae1c94d15a" translate="yes" xml:space="preserve">
          <source>This method can be used to ensure that no threaded created by a reference manager will be active.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1267ce3e9e0625435626c7617e6d61f20f27e4e8" translate="yes" xml:space="preserve">
          <source>This method can be used to ensure that no threaded created by a reference manager will be active. This is useful if the Groovy runtime itself is loaded through a class loader which should be disposed off. Without calling this method and if a threaded reference manager is active the class loader cannot be unloaded! Per default no threaded manager will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="736cd8a3422bc2feffa8beea26a3ea358d3a8479" translate="yes" xml:space="preserve">
          <source>This method can return &lt;code&gt;null&lt;/code&gt; if the &lt;code&gt;Class&lt;/code&gt; is no longer reachable through any strong or soft references. A non-null return value indicates that this &lt;code&gt;ClassInfo&lt;/code&gt; is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1756cd8d9775e9730b98c4c1627c9b5e632ec24f" translate="yes" xml:space="preserve">
          <source>This method does not check the elements to verify they contain non-null reference values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="465f96fa4d41f78b2ce5fda3f4227272109aa863" translate="yes" xml:space="preserve">
          <source>This method doesn't do a full validation of the resulting QName. In particular, it doesn't check that the resulting namespace URI is a legal URI (per RFC 2396 and RFC 2732), nor that the resulting local part is a legal NCName per the XML Namespaces specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e513008c99e7d305fccff13849c1a1c80774aa" translate="yes" xml:space="preserve">
          <source>This method exists to be binary compatible with 1.7 - 1.8.6 compiled code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c641e7c52a070377f45e131e44d063d090fa6d00" translate="yes" xml:space="preserve">
          <source>This method extracts ModelMBeanConstructorInfo from provided meta map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c2983f225d2e36614f43dbb936a7baf6ddf732" translate="yes" xml:space="preserve">
          <source>This method extracts ModelMBeanConstructorInfo from provided meta map. It also iterates over any parameters and builds the necessary MBeanParameterInfo array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="150789d2ce17bb14a2771276abea7c787a906d8f" translate="yes" xml:space="preserve">
          <source>This method extracts an array of MBeanConstructorInfo from a list of meta maps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a3e8f2070dce89ae81b802d499b2bd30f90563" translate="yes" xml:space="preserve">
          <source>This method extracts an array of MBeanOperationInfo from a list of meta maps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="263fa2d4242a10d1bba7914ee9c3b6eaba971c49" translate="yes" xml:space="preserve">
          <source>This method is &quot;safe&quot; in that it will always return a value and never throw an exception</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f930ab10785ce3649f57bd225433f23ebd52975" translate="yes" xml:space="preserve">
          <source>This method is a default implementation for the invoke method given in InvocationHandler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="181a7ec346ddcc5f94d1cf5c7bd4f8177dda29ec" translate="yes" xml:space="preserve">
          <source>This method is a default implementation for the invoke method given in InvocationHandler. Any call to a method with a declaring class that is not Object, excluding toString() and default methods is redirected to invokeCustom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0243bed2cf01409831d3e3bb5e0becbccc0e7f22" translate="yes" xml:space="preserve">
          <source>This method is called by he handle to realize the bean constructor with property map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32f82b3d67ea451eb2c3571e5b0255127a98cff1" translate="yes" xml:space="preserve">
          <source>This method is called by the ++ operator for enums.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c4289e3c70251c89708316752c7fc742b1a3b57" translate="yes" xml:space="preserve">
          <source>This method is called by the ++ operator for enums. It will invoke Groovy's default next behaviour for enums do not have their own next method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="457141bbf0ee6f1da111f0f8db21015e1177879a" translate="yes" xml:space="preserve">
          <source>This method is called by the -- operator for enums.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80cf9ab5395bfa1c37797650a89d31d82b67f5fb" translate="yes" xml:space="preserve">
          <source>This method is called by the -- operator for enums. It will invoke Groovy's default previous behaviour for enums that do not have their own previous method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d7f17602988167c7174cc4303d3eb837ccaa4f4" translate="yes" xml:space="preserve">
          <source>This method is called by the handle to realize the bean constructor with property map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3250ef3629af744acf4f1c9198cc633e9a922e7c" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker before throwing an &quot;ambiguous method&quot; error, giving the chance to the extension to select the method properly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf23fd2465394a74d715d408a8f25c8bce28f2b6" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker before throwing an &quot;ambiguous method&quot; error, giving the chance to the extension to select the method properly. This means that when this method is called, the &quot;nodes&quot; parameter contains at least two methods. If the returned list still contains at least two methods, then the type checker will throw an ambiguous method call error. If the returned method contains 1 element, then the type checker will not throw any error. It is invalid to return an empty list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bd058a5f1dad9fd10cd41da813b584b34292dcf" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a method call cannot be resolved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1635a0a9cf4ddc4f991b78c462cd28f64e95f41" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a method call cannot be resolved. Extensions may override this method to handle missing methods and prevent the type checker from throwing an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d562c165b33158604a8d7b6404c28720d2074f3" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a property expression cannot be resolved (for example, when a property doesn't exist).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="132aa2a69d68d1893ec79f63a47c8d6c72a91536" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a property expression cannot be resolved (for example, when a property doesn't exist). It gives the extension a chance to resolve it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1e5a5ee4210f5472ccdfef7a053239430f1f37" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a variable expression cannot be resolved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c7e2b17c02ed11975ad5a1246ebf8e0384df5b" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a variable expression cannot be resolved. It gives the extension a chance to resolve it for the type checker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24c509ff50700509e7072e5bf1d5cfe4ccd9c387" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when an assignment is not allowed by the type checker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="788e0b6b33909d27195a8757233c0e6432f5e5eb" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when an assignment is not allowed by the type checker. Extensions may override this method to allow such assignments where the type checker normally disallows them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae2966d00451172c913ae2ad39d7fd262e4b659" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when an attribute expression cannot be resolved (for example, when an attribute doesn't exist).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f407dcbe206c19d0fc48753b7163e649e8b6df6d" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when an attribute expression cannot be resolved (for example, when an attribute doesn't exist). It gives the extension a chance to resolve it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f24dfabfb34102b6f318752ab09222b7e3d270a2" translate="yes" xml:space="preserve">
          <source>This method is called for all Methods not defined on Object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c123aa6bd463d76f74528853afb07e35dfbd4af8" translate="yes" xml:space="preserve">
          <source>This method is called for all Methods not defined on Object. The delegate should be called here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e263d0484bccb2058d38f8bf9eacd404f003eccc" translate="yes" xml:space="preserve">
          <source>This method is called once the template engine is initialized, providing the resolver with the template engine configuration and its template class loader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d82b61e044bfa56fbd2265af61cf2acecdd51e0" translate="yes" xml:space="preserve">
          <source>This method is called when an exception occurs while invoking this method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3383d8f9c80df52829fdca412aee2ffee5f93888" translate="yes" xml:space="preserve">
          <source>This method is for convenience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9242bd1cd2be2a765050fb4ef347893057fa4da1" translate="yes" xml:space="preserve">
          <source>This method is for convenience. It allows to get around the need for defining dump ctors in subclasses. See unit tests for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7d7725943eccf3c92e66a0d48dd502528f6b703" translate="yes" xml:space="preserve">
          <source>This method is meant to be overridden by custom GroovyDoc implementations, using custom class templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e09772b977dedc07d07d96cc2d72542f64ca1c5" translate="yes" xml:space="preserve">
          <source>This method is meant to be overridden by custom GroovyDoc implementations, using custom doc templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3f94c56bab43f0b3780ed88b92cbab7aa06914d" translate="yes" xml:space="preserve">
          <source>This method is meant to be overridden by custom GroovyDoc implementations, using custom package templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be3f5aaf4fe5b29a387b1c08f22380405a4b43e6" translate="yes" xml:space="preserve">
          <source>This method is not in use anymore.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d479a6f7032861e095021709f96d24a323c7ce9f" translate="yes" xml:space="preserve">
          <source>This method is not in use anymore. Use &lt;a href=&quot;groovyc#makeCompileUnit(groovy.lang.GroovyClassLoader)&quot;&gt;Groovyc.makeCompileUnit&lt;/a&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df7d11b3e43da5003d64921acb230c01052ce02" translate="yes" xml:space="preserve">
          <source>This method is responsible for instantiating a node and configure its properties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2553db016825bd58a6c41d37b4ac7d9fdb343726" translate="yes" xml:space="preserve">
          <source>This method is responsible for performing type inference on closure argument types whenever code like this is found: &lt;code&gt;foo.collect { it.toUpperCase() }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96aa2c86a54f44a86c05cf0e9b642e0ff2c34049" translate="yes" xml:space="preserve">
          <source>This method is responsible for performing type inference on closure argument types whenever code like this is found: &lt;code&gt;foo.collect { it.toUpperCase() }&lt;/code&gt;. In this case, the type checker tries to find if the &lt;code&gt;collect&lt;/code&gt; method has its &lt;a href=&quot;../../../../../groovy/lang/closure&quot;&gt;Closure&lt;/a&gt; argument annotated with &lt;a href=&quot;../../../../../groovy/transform/stc/closureparams&quot;&gt;ClosureParams&lt;/a&gt;. If yes, then additional type inference can be performed and the type of &lt;code&gt;it&lt;/code&gt; may be inferred.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39e70e7519f9c69520febf8336038092afe788f5" translate="yes" xml:space="preserve">
          <source>This method is similar to &lt;a href=&quot;#propX(org.codehaus.groovy.ast.expr.Expression,%20org.codehaus.groovy.ast.expr.Expression)&quot;&gt;propX(Expression, Expression)&lt;/a&gt; but will make sure that if the property being accessed is defined inside the classnode provided as a parameter, then a getter call is generated instead of a field access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5af1f84f364b43bda693a94d6efdcb175387d500" translate="yes" xml:space="preserve">
          <source>This method is used to pull all the new methods out of the local thread context with a particular name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="debc8862f9ee94379022acc734d3d04be7a4a835" translate="yes" xml:space="preserve">
          <source>This method looks up a simple (weak) hash map for an existing template object that matches the source URL. If there is no cache entry, a new one is created by the underlying template engine. This new instance is put to the cache for consecutive calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50f405bf763411bbbae4b569b75520c8c6ab7da2" translate="yes" xml:space="preserve">
          <source>This method looks up a simple (weak) hash map for an existing template object that matches the source file. If the source file didn't change in length and its last modified stamp hasn't changed compared to a precompiled template object, this template is used. Otherwise, there is no or an invalid template object cache entry, a new one is created by the underlying template engine. This new instance is put to the cache for consecutive calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70b580668132556ed8e21d6f55d11fdd505e1db6" translate="yes" xml:space="preserve">
          <source>This method may be used by a caller in class C to check whether to enable access to a member of declaring class D successfully if Java8#checkCanSetAccessible(java.lang.reflect.AccessibleObject, java.lang.Class) returns true and any of the following hold:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="403c2e4b9a79e63110b8121635756398ae996fda" translate="yes" xml:space="preserve">
          <source>This method returns the left hand side of the declaration cast to the TupleExpression type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3eeba1201f99a5e2e68118e5c0e2cd8aa46418b3" translate="yes" xml:space="preserve">
          <source>This method returns the left hand side of the declaration cast to the TupleExpression type. This is an unsafe method to call. In a single assignment statement, the left hand side will be a VariableExpression and a ClassCastException will occur. If you invoke this method then be sure to invoke isMultipleAssignmentDeclaration() first to check that it is safe to do so. If that method returns true then this method is safe to call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781dddff54ea389bba98f4620fb6ffb4990bacbc" translate="yes" xml:space="preserve">
          <source>This method returns the left hand side of the declaration cast to the VariableExpression type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d0cf4b5f8e84212c7ef85c55fbf13a8f51d14d1" translate="yes" xml:space="preserve">
          <source>This method returns the left hand side of the declaration cast to the VariableExpression type. This is an unsafe method to call. In a multiple assignment statement, the left hand side will be a TupleExpression and a ClassCastException will occur. If you invoke this method then be sure to invoke isMultipleAssignmentDeclaration() first to check that it is safe to do so. If that method returns true then this method is safe to call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="557432b29293b21b623d72897910f098d1d9b99f" translate="yes" xml:space="preserve">
          <source>This method returns the list of methods named against the supplied parameter that are defined on the specified receiver, but it will also add &quot;non existing&quot; methods that will be generated afterwards by the compiler, for example if a method is using default values and that the specified class node isn't compiled yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c021d108112247d1976e0f0916701f3b8b31579" translate="yes" xml:space="preserve">
          <source>This method returns the method name as String if it is no dynamic calculated method name, but a constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea5673ca5049872b33d116e64a53321be9dfe401" translate="yes" xml:space="preserve">
          <source>This method satisfies the general contract of the &lt;code&gt;Object.equals&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6de05f9ed26a209b6ba119f444e9aeb1971f83b" translate="yes" xml:space="preserve">
          <source>This method sets the leftExpression for this BinaryExpression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9538691d379a9f29ae41a5c0329eeba449cfee5a" translate="yes" xml:space="preserve">
          <source>This method sets the leftExpression for this BinaryExpression. The parameter must be either a VariableExpression or a TupleExpression with one or more elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cabac7eca3eafa23e66e3fc5b9e599e6f515924d" translate="yes" xml:space="preserve">
          <source>This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; array. See the class Javadoc for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ac687259610806fa3ccf67d52b8a0cdcf309f5f" translate="yes" xml:space="preserve">
          <source>This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; list. Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f6b6d6cce9316b59fc041647b88bdcb3661eb8" translate="yes" xml:space="preserve">
          <source>This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; list. See the class Javadoc for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c38527fe587a9d1b961b352a1036dd0d02b5a0" translate="yes" xml:space="preserve">
          <source>This method supports named and named ordinal parameters. See the class Javadoc for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1cb160878d23efb8494710e1845624e733ba117" translate="yes" xml:space="preserve">
          <source>This method takes source code, compiles it, then reverses it back to source.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1802525bd308357b0932ba02bb3c41457d24c77a" translate="yes" xml:space="preserve">
          <source>This method tells you if this declaration is a multiple assignment declaration, which has the form &quot;def (x, y) = ...&quot; in Groovy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647f4610cd39ef87d4f0b710da06531ff2a5d253" translate="yes" xml:space="preserve">
          <source>This method tells you if this declaration is a multiple assignment declaration, which has the form &quot;def (x, y) = ...&quot; in Groovy. If this method returns true, then the left hand side is an ArgumentListExpression. Do not call &quot;getVariableExpression()&quot; on this object if this method returns true, instead use &quot;getLeftExpression()&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03ceb4930438c953107282fc0e25906885994308" translate="yes" xml:space="preserve">
          <source>This method tokenizes a string by space characters, but ignores spaces in quoted parts,that are parts in '' or &quot;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25594fed498b016c91d8453a3caab76c908e2263" translate="yes" xml:space="preserve">
          <source>This method tokenizes a string by space characters, but ignores spaces in quoted parts,that are parts in '' or &quot;&quot;. The method does allows the usage of &quot;&quot; in '' and '' in &quot;&quot;. The space character between tokens is not returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2a84c08a545e26a0cfa5751f177172834124990" translate="yes" xml:space="preserve">
          <source>This methods creates a list of all methods with this name of the current class and of all super classes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2b2f984e596021625b1464da65d3078af780eae" translate="yes" xml:space="preserve">
          <source>This methods returns a list of all methods of the given name defined in the current class</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45509752471fda490b1c2f1641894ee63c1ba53e" translate="yes" xml:space="preserve">
          <source>This methods returns the same array as used in the constructor. Changing the values will result in changes of the GString. It is not recommended to do so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66768732e0971c70f8284792c2afe59afe722c7" translate="yes" xml:space="preserve">
          <source>This modifies the original instance and returns it, it does not clone</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d03be5ef16854ca34754ab795102a0c1c0f386c3" translate="yes" xml:space="preserve">
          <source>This object is a GUI for looking at the AST that Groovy generates. Usage: java groovy.console.ui.AstBrowser [filename] where [filename] is an existing Groovy script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e97fa1c7af0c729d57b97541a44507ce0cc0d67" translate="yes" xml:space="preserve">
          <source>This object is a GUI for looking at the AST that Groovy generates. Usage: java groovy.inspect.swingui.AstBrowser [filename] where [filename] is an existing Groovy script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2ffc04181a72b4f0f1c3e416c94b05a7ff37bfe" translate="yes" xml:space="preserve">
          <source>This object represents a Groovy script</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3a6a41f25ea556ddea2ab91cb5c7b51b70dd65b" translate="yes" xml:space="preserve">
          <source>This only leaves the 'out' argument unbound. The only method on the &lt;a href=&quot;../lang/writable&quot;&gt;writable&lt;/a&gt; interface is &lt;a href=&quot;../lang/writable#writeTo&quot;&gt;writeTo(Writer out)&lt;/a&gt; so groovy rules about casting a closure to a one-method-interface apply and the above works. I.e. we return the now one argument closure as the Writable which can be serialized to System.out, a file, etc according to the Writable interface contract.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3860a813e268f2ea6fc72207bdceca72d569484a" translate="yes" xml:space="preserve">
          <source>This pattern can therefore be used to avoid explicit casts everywhere you need to call a method that you know is defined in the class that will implement the trait but normally don't have access to, which is often the case where a trait needs to be applied on a class provided by a third-party library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace59be916b50b31486861d73ed18eaca30ec5fa" translate="yes" xml:space="preserve">
          <source>This property allows customizing the program name displayed in the synopsis when &lt;code&gt;cli.usage()&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e8331273416e517eaeaf7fa7a23b0549036735" translate="yes" xml:space="preserve">
          <source>This property allows customizing the program name displayed in the synopsis when &lt;code&gt;cli.usage()&lt;/code&gt; is called. Ignored if the &lt;a href=&quot;#usage&quot;&gt;usage&lt;/a&gt; property is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e7c100040c65811e98b4b5e3b269e9270590f58" translate="yes" xml:space="preserve">
          <source>This property controls whether to include the destination classes directory in the classpath given to the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d2d8961f859455e3fb30c095ca4f0b27f60c5a9" translate="yes" xml:space="preserve">
          <source>This property controls whether to include the destination classes directory in the classpath given to the compiler. The default value is &quot;true&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f8e158e1fb916ac4a14cb9fc36f54eb916b032" translate="yes" xml:space="preserve">
          <source>This queue is backed by a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html&quot;&gt;ConcurrentLinkedQueue&lt;/a&gt; and is thread safe. The iterator will only return non-null values (reachable) and is based on the &quot;weakly consistent&quot; iterator of the underlying &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html&quot;&gt;ConcurrentLinkedQueue&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0554c74e1813aa666f0f951e0bf2132582a22d5" translate="yes" xml:space="preserve">
          <source>This registry makes use of the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html&quot;&gt;ServiceLoader&lt;/a&gt; facility. The preferred method for registering new &lt;a href=&quot;groovyrunner&quot;&gt;GroovyRunner&lt;/a&gt; providers is to place them in a provider-configuration file in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;. The preferred method for accessing the registered runners is by making use of the &lt;code&gt;Iterable&lt;/code&gt; interface using an enhanced for-loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a509478dc010fd7ae4333771f3db41a8b51de80" translate="yes" xml:space="preserve">
          <source>This results in an effective change in the default value, which each @Grab can still override</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
