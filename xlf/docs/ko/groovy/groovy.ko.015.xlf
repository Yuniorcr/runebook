<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="groovy">
    <body>
      <group id="groovy">
        <trans-unit id="4e8a758e14e042fd44d1644b7c03d56755c84835" translate="yes" xml:space="preserve">
          <source>Subclasses should implement this method to provide good error resolution.</source>
          <target state="translated">좋은 오류 해결을 제공하려면 하위 클래스에서이 메서드를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="48a548d0b5d2d73bb19fdf6f69c4cddfc9e8f4c9" translate="yes" xml:space="preserve">
          <source>Subclasses should implement this method to set the condition of the interruption statement</source>
          <target state="translated">서브 클래스는 인터럽트 문의 조건을 설정하기 위해이 메서드를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="32ab562220ed81620ccefa3948d1a774f1feaa20" translate="yes" xml:space="preserve">
          <source>Subclasses should implement this method whenever they need to perform special checks before the type checker starts working.</source>
          <target state="translated">하위 클래스는 유형 검사기가 작동하기 전에 특수 검사를 수행해야 할 때마다이 메서드를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="c68b5b9b049084fab1d00a3f47d9b682f70fb6da" translate="yes" xml:space="preserve">
          <source>Subclasses should implement this method, which returns the list of accepted closure signatures.</source>
          <target state="translated">서브 클래스는 허용 된 클로저 서명 목록을 반환하는이 메서드를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa849d16a1883f2b020174ca4e3bb9a8a963f828" translate="yes" xml:space="preserve">
          <source>Subtract a Character from a Number.</source>
          <target state="translated">숫자에서 문자를 뺍니다.</target>
        </trans-unit>
        <trans-unit id="7d501390aa64bdf2c9ae78827d17293277d1d079" translate="yes" xml:space="preserve">
          <source>Subtract a Character from a Number. The ordinal value of the Character is used in the subtraction (the ordinal value is the unicode value which for simple character sets is the ASCII value).</source>
          <target state="translated">숫자에서 문자를 뺍니다. 문자의 서수 값은 빼기에 사용됩니다 (서수 값은 단순 문자 집합의 경우 ASCII 값인 유니 코드 값입니다).</target>
        </trans-unit>
        <trans-unit id="80739b5b536f0252ee4bb49d1cf80dec2291730b" translate="yes" xml:space="preserve">
          <source>Subtract a Number from a Character.</source>
          <target state="translated">문자에서 숫자를 뺍니다.</target>
        </trans-unit>
        <trans-unit id="2829709b208cdecbc2effaee1c43f216d0c4a2cd" translate="yes" xml:space="preserve">
          <source>Subtract a Number from a Character. The ordinal value of the Character is used in the subtraction (the ordinal value is the unicode value which for simple character sets is the ASCII value).</source>
          <target state="translated">문자에서 숫자를 뺍니다. 문자의 서수 값은 빼기에 사용됩니다 (서수 값은 단순 문자 집합의 경우 ASCII 값인 유니 코드 값입니다).</target>
        </trans-unit>
        <trans-unit id="383c4da009f675500b7dc7ae0296938c1e09b8bf" translate="yes" xml:space="preserve">
          <source>Subtract a number of days from this Timestamp and returns the new Timestamp object.</source>
          <target state="translated">이 Timestamp에서 일 수를 빼고 새 Timestamp 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="73d746887164b2f5e92e086f6b38e7a5028ad395" translate="yes" xml:space="preserve">
          <source>Subtract a number of days from this date and returns the new date.</source>
          <target state="translated">이 날짜에서 일수를 빼고 새 날짜를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d1b908a2b53a9eda97aea98291d46913fec1a195" translate="yes" xml:space="preserve">
          <source>Subtract another Date from this one and return the number of days of the difference.</source>
          <target state="translated">이 날짜에서 다른 날짜를 빼고 차이의 일 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="90df6944beb186ade6e01024eae5a9be3b4868ce" translate="yes" xml:space="preserve">
          <source>Subtract another date from this one and return the number of days of the difference.</source>
          <target state="translated">이 날짜에서 다른 날짜를 빼고 그 차이의 일수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b1d58f1e1cf47da6c54dce03b400e8ead47438d0" translate="yes" xml:space="preserve">
          <source>Subtract one Character from another.</source>
          <target state="translated">다른 문자에서 한 문자를 뺍니다.</target>
        </trans-unit>
        <trans-unit id="670e4318f1084845e7f32b29745478fef01a079c" translate="yes" xml:space="preserve">
          <source>Subtract one Character from another. The ordinal values of the Characters is used in the comparison (the ordinal value is the unicode value which for simple character sets is the ASCII value).</source>
          <target state="translated">다른 문자에서 한 문자를 뺍니다. 문자의 서수 값이 비교에 사용됩니다 (서수 값은 단순 문자 집합의 경우 ASCII 값인 유니 코드 값입니다).</target>
        </trans-unit>
        <trans-unit id="8458189362e1f0efadb179882bea2588a89dea40" translate="yes" xml:space="preserve">
          <source>Subtract one date from the other.</source>
          <target state="translated">다른 날짜에서 하나의 날짜를 뺍니다.</target>
        </trans-unit>
        <trans-unit id="703b3f4be66eeba14f12112eb0178f45c56b038b" translate="yes" xml:space="preserve">
          <source>Subtraction of two Numbers.</source>
          <target state="translated">두 숫자 빼기.</target>
        </trans-unit>
        <trans-unit id="ea77f38e191237c8467b9bbbbfa7a3c905eb071f" translate="yes" xml:space="preserve">
          <source>Successful retrievals using get(key) and containsKey(key) usually run without locking. Unsuccessful ones (i.e., when the key is not present) do involve brief synchronization (locking). Also, the size and isEmpty methods are always synchronized.</source>
          <target state="translated">get (key) 및 containsKey (key)를 사용한 성공적인 검색은 일반적으로 잠금없이 실행됩니다. 실패한 것 (즉, 키가없는 경우)에는 짧은 동기화 (잠금)가 포함됩니다. 또한 size 및 isEmpty 메서드는 항상 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="31de501c849ff7913e8233a72f933ee4b40759b9" translate="yes" xml:space="preserve">
          <source>Sums all the given items.</source>
          <target state="translated">주어진 모든 항목을 더합니다.</target>
        </trans-unit>
        <trans-unit id="a6906f65d4bdfb623c3779437b880666d674473e" translate="yes" xml:space="preserve">
          <source>Sums all the items from an array of items.</source>
          <target state="translated">항목 배열의 모든 항목을 더합니다.</target>
        </trans-unit>
        <trans-unit id="4b759da08d81e2982b18ab18cfecdb92173bfcad" translate="yes" xml:space="preserve">
          <source>Sums the items from an Iterator, adding the result to some initial value.</source>
          <target state="translated">Iterator의 항목을 더하여 결과를 초기 값에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="3292936c4cef8a406dd185feb7f5e9f5ad4bb035" translate="yes" xml:space="preserve">
          <source>Sums the items from an Iterator, adding the result to some initial value. This is equivalent to invoking the &quot;plus&quot; method on all items from the Iterator. The iterator will become exhausted of elements after determining the sum value.</source>
          <target state="translated">Iterator의 항목을 더하여 결과를 초기 값에 추가합니다. 이는 Iterator의 모든 항목에 대해 &quot;plus&quot;메소드를 호출하는 것과 같습니다. 이터레이터는 합계 값을 결정한 후 요소가 고갈됩니다.</target>
        </trans-unit>
        <trans-unit id="44a8d4cb71f1a9055409cd78474fa859d6e1b627" translate="yes" xml:space="preserve">
          <source>Sums the items from an Iterator.</source>
          <target state="translated">반복자의 항목을 더합니다.</target>
        </trans-unit>
        <trans-unit id="7b0828ab8c0d5a6291096701a8058ed787770aa4" translate="yes" xml:space="preserve">
          <source>Sums the items from an Iterator. This is equivalent to invoking the &quot;plus&quot; method on all items from the Iterator. The iterator will become exhausted of elements after determining the sum value.</source>
          <target state="translated">반복자의 항목을 더합니다. 이는 Iterator의 모든 항목에 대해 &quot;plus&quot;메소드를 호출하는 것과 같습니다. 이터레이터는 합계 값을 결정한 후 요소가 고갈됩니다.</target>
        </trans-unit>
        <trans-unit id="0f21ed49c9b3729a874e6b6213a3aec5f55f4984" translate="yes" xml:space="preserve">
          <source>Sums the items in an Iterable, adding the result to some initial value.</source>
          <target state="translated">Iterable의 항목을 합하고 결과를 일부 초기 값에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="938cc031c32a0a74fedcea0fa2ea03bca7774e36" translate="yes" xml:space="preserve">
          <source>Sums the items in an Iterable.</source>
          <target state="translated">Iterable의 항목을 더합니다.</target>
        </trans-unit>
        <trans-unit id="05846c3dab4dc24635cdc7e83333eed6761385f2" translate="yes" xml:space="preserve">
          <source>Sums the items in an Iterable. This is equivalent to invoking the &quot;plus&quot; method on all items in the Iterable.</source>
          <target state="translated">Iterable의 항목을 더합니다. 이것은 Iterable의 모든 항목에 대해 &quot;plus&quot;메소드를 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f97a9c084454b475824ce176a76670de5bc0260" translate="yes" xml:space="preserve">
          <source>Sums the items in an array, adding the result to some initial value.</source>
          <target state="translated">배열의 항목을 더하여 결과를 초기 값에 더합니다.</target>
        </trans-unit>
        <trans-unit id="8e6bc758df7e10d60725d5fd562f4cb6320501f3" translate="yes" xml:space="preserve">
          <source>Sums the items in an array.</source>
          <target state="translated">배열의 항목을 더합니다.</target>
        </trans-unit>
        <trans-unit id="f12f8dae3d9539e78ab7a3595c0ec92646ea4e58" translate="yes" xml:space="preserve">
          <source>Sums the items in an array. This is equivalent to invoking the &quot;plus&quot; method on all items in the array.</source>
          <target state="translated">배열의 항목을 더합니다. 이는 배열의 모든 항목에 대해 &quot;플러스&quot;메소드를 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef7fec05c6f7a205563842bf6c760293ede2e021" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterable to some initial value.</source>
          <target state="translated">Iterable의 각 항목에 클로저를 적용한 결과를 일부 초기 값에 합산합니다.</target>
        </trans-unit>
        <trans-unit id="2c34756e7df8dbbbdc5ad7ddd3d79525b4cabde0" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterable to some initial value. &lt;code&gt;iter.sum(initVal, closure)&lt;/code&gt; is equivalent to: &lt;code&gt;iter.collect(closure).sum(initVal)&lt;/code&gt;.</source>
          <target state="translated">Iterable의 각 항목에 클로저를 적용한 결과를 일부 초기 값에 합산합니다. &lt;code&gt;iter.sum(initVal, closure)&lt;/code&gt; 는 &lt;code&gt;iter.collect(closure).sum(initVal)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="a22f8d5b1e322146f614b91be417a32eb8dcd5b5" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterable.</source>
          <target state="translated">Iterable의 각 항목에 클로저를 적용한 결과를 더합니다.</target>
        </trans-unit>
        <trans-unit id="a9cded5e8db4a11cbc31f73eebe70a9d23e9f6e6" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterable. &lt;code&gt;coll.sum(closure)&lt;/code&gt; is equivalent to: &lt;code&gt;coll.collect(closure).sum()&lt;/code&gt;.</source>
          <target state="translated">Iterable의 각 항목에 클로저를 적용한 결과를 더합니다. &lt;code&gt;coll.sum(closure)&lt;/code&gt; 는 &lt;code&gt;coll.collect(closure).sum()&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a2d6eeefd666db6fd3abb4f06450eaebc3703a21" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterator to some initial value.</source>
          <target state="translated">Iterator의 각 항목에 클로저를 적용한 결과를 일부 초기 값에 더합니다.</target>
        </trans-unit>
        <trans-unit id="138bf57a714ba157c5f8f2140c7144fec48bbd4d" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an Iterator to some initial value. &lt;code&gt;iter.sum(initVal, closure)&lt;/code&gt; is equivalent to: &lt;code&gt;iter.collect(closure).sum(initVal)&lt;/code&gt;. The iterator will become exhausted of elements after determining the sum value.</source>
          <target state="translated">Iterator의 각 항목에 클로저를 적용한 결과를 일부 초기 값에 더합니다. &lt;code&gt;iter.sum(initVal, closure)&lt;/code&gt; 는 &lt;code&gt;iter.collect(closure).sum(initVal)&lt;/code&gt; 합니다. 이터레이터는 합계 값을 결정한 후 요소가 고갈됩니다.</target>
        </trans-unit>
        <trans-unit id="c0cb69a7faef35e6438266153f8981b96cdb6d92" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an array to some initial value.</source>
          <target state="translated">배열의 각 항목에 클로저를 적용한 결과를 일부 초기 값에 더합니다.</target>
        </trans-unit>
        <trans-unit id="45852392f7090c69aedbeec4ac994c8caed08176" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an array to some initial value. &lt;code&gt;array.sum(initVal, closure)&lt;/code&gt; is equivalent to: &lt;code&gt;array.collect(closure).sum(initVal)&lt;/code&gt;.</source>
          <target state="translated">배열의 각 항목에 클로저를 적용한 결과를 일부 초기 값에 더합니다. &lt;code&gt;array.sum(initVal, closure)&lt;/code&gt; 는 &lt;code&gt;array.collect(closure).sum(initVal)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="46427b8197456a69d06f32a8b3afb429409c9174" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an array.</source>
          <target state="translated">배열의 각 항목에 클로저를 적용한 결과를 더합니다.</target>
        </trans-unit>
        <trans-unit id="b46103f8e5006bdeea7f9c154e982c8ee536abd8" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item of an array. &lt;code&gt;array.sum(closure)&lt;/code&gt; is equivalent to: &lt;code&gt;array.collect(closure).sum()&lt;/code&gt;.</source>
          <target state="translated">배열의 각 항목에 클로저를 적용한 결과를 더합니다. &lt;code&gt;array.sum(closure)&lt;/code&gt; 는 &lt;code&gt;array.collect(closure).sum()&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="dac66fb8810c157cd97e770e86c48d44f88a2152" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item returned from an iterator.</source>
          <target state="translated">반복기에서 반환 된 각 항목에 클로저를 적용한 결과를 더합니다.</target>
        </trans-unit>
        <trans-unit id="377052f5b33eac246887eb27e6c100d565eca611" translate="yes" xml:space="preserve">
          <source>Sums the result of applying a closure to each item returned from an iterator. &lt;code&gt;iter.sum(closure)&lt;/code&gt; is equivalent to: &lt;code&gt;iter.collect(closure).sum()&lt;/code&gt;. The iterator will become exhausted of elements after determining the sum value.</source>
          <target state="translated">반복기에서 반환 된 각 항목에 클로저를 적용한 결과를 더합니다. &lt;code&gt;iter.sum(closure)&lt;/code&gt; 는 &lt;code&gt;iter.collect(closure).sum()&lt;/code&gt; 과 동일합니다 . 이터레이터는 합계 값을 결정한 후 요소가 고갈됩니다.</target>
        </trans-unit>
        <trans-unit id="998c35057b1e937535f109c7111919f1f21ea66a" translate="yes" xml:space="preserve">
          <source>Support a 'least surprising' math model to scripting language users. This means that exact, or decimal math should be used for default calculations. This scheme assumes that by default, groovy literals with decimal points are instantiated as BigDecimal objects rather than binary floating points (Float, Double).</source>
          <target state="translated">스크립팅 언어 사용자에게 '가장 놀라운'수학 모델을 지원합니다. 즉, 기본 계산에는 정확한 또는 십진 수학을 사용해야합니다. 이 체계는 기본적으로 소수점이있는 그루비 리터럴이 이진 부동 소수점 (Float, Double)이 아닌 BigDecimal 객체로 인스턴스화된다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="300e75d2f3f2ad069bf75f6db0f8b032d657028b" translate="yes" xml:space="preserve">
          <source>Support assigning a range of values with a single assignment statement.</source>
          <target state="translated">단일 할당 문으로 값 범위 할당을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="eb0573add916ac521520ae7e1a7edb406cc686a3" translate="yes" xml:space="preserve">
          <source>Support class for creating XML Factories</source>
          <target state="translated">XML 팩토리 생성을위한 지원 클래스</target>
        </trans-unit>
        <trans-unit id="a0ac0e736b440225051252fb545f21a87af58be3" translate="yes" xml:space="preserve">
          <source>Support creating a new Date having similar properties to an existing Date (which remains unaltered) but with some fields updated according to a Map of changes.</source>
          <target state="translated">기존 날짜 (변경되지 않은 상태로 유지됨)와 유사한 속성을 갖는 새 날짜 생성을 지원하지만 변경 사항 맵에 따라 일부 필드가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="578fcb6595097c58dd9c3c70598121040321a782" translate="yes" xml:space="preserve">
          <source>Support for &lt;a href=&quot;command&quot;&gt;Command&lt;/a&gt; instances.</source>
          <target state="translated">&lt;a href=&quot;command&quot;&gt;명령&lt;/a&gt; 인스턴스 지원 .</target>
        </trans-unit>
        <trans-unit id="27e429f7d79185fd5fa7dcfde4e209338be3fe84" translate="yes" xml:space="preserve">
          <source>Support for Closure &quot;right&quot; currying.</source>
          <target state="translated">클로저 &quot;오른쪽&quot;커링 지원.</target>
        </trans-unit>
        <trans-unit id="bd9aff9c96085971df147f0319c92592cb9998b5" translate="yes" xml:space="preserve">
          <source>Support for Closure &quot;right&quot; currying. Parameters are supplied on the right rather than left as per the normal curry() method. Typical usage:</source>
          <target state="translated">클로저 &quot;오른쪽&quot;커링 지원. 매개 변수는 일반적인 curry () 메서드에 따라 왼쪽이 아닌 오른쪽에 제공됩니다. 일반적인 사용법 :</target>
        </trans-unit>
        <trans-unit id="07d27c73edc627e408cf52788f3cd8c2cee9798e" translate="yes" xml:space="preserve">
          <source>Support for Closure currying at a given index.</source>
          <target state="translated">지정된 인덱스에서 클로저 커링 지원.</target>
        </trans-unit>
        <trans-unit id="77c240308ae9d403e4fdeb9fade24bf133f052c6" translate="yes" xml:space="preserve">
          <source>Support for Closure currying at a given index. Parameters are supplied from index position &quot;n&quot;. Typical usage:</source>
          <target state="translated">지정된 인덱스에서 클로저 커링 지원. 매개 변수는 색인 위치 &quot;n&quot;에서 제공됩니다. 일반적인 사용법 :</target>
        </trans-unit>
        <trans-unit id="86fbafb2c6a6ef08ae544def5ecd2f5d1a459fde" translate="yes" xml:space="preserve">
          <source>Support for Closure currying.</source>
          <target state="translated">클로저 커링 지원.</target>
        </trans-unit>
        <trans-unit id="b6701c883c98ccd374b2032b56f3cdf62e6bdcb1" translate="yes" xml:space="preserve">
          <source>Support for Closure forward composition.</source>
          <target state="translated">클로저 포워드 구성 지원.</target>
        </trans-unit>
        <trans-unit id="95c9b5d31f5a9af4bcb77590911799ff25e785f9" translate="yes" xml:space="preserve">
          <source>Support for Closure reverse composition.</source>
          <target state="translated">클로저 역 구성 지원.</target>
        </trans-unit>
        <trans-unit id="0cd464c7aa84c67ca4cf28f95af944bd7e5c8ae1" translate="yes" xml:space="preserve">
          <source>Support for Groovlets which are Servlets written as a simple Groovy script.</source>
          <target state="translated">간단한 Groovy 스크립트로 작성된 서블릿 인 Groovlet을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="971f277b26127bb2b96f438a43258b36036a9c6e" translate="yes" xml:space="preserve">
          <source>Support for compilation related tasks.</source>
          <target state="translated">컴파일 관련 작업 지원.</target>
        </trans-unit>
        <trans-unit id="2712721bdf08058a3c0b6d90d89d52194d9c6991" translate="yes" xml:space="preserve">
          <source>Support for more complex commands.</source>
          <target state="translated">더 복잡한 명령을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c398c8c180a493660e7da708b15d770393473fcc" translate="yes" xml:space="preserve">
          <source>Support for running a &lt;a href=&quot;shell&quot;&gt;Shell&lt;/a&gt; interactively using the JLine library.</source>
          <target state="translated">JLine 라이브러리를 사용하여 대화식 으로 &lt;a href=&quot;shell&quot;&gt;쉘&lt;/a&gt; 실행을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="e7bd721822c04eca7566037be0ea0c447ce0bb1f" translate="yes" xml:space="preserve">
          <source>Support for running a &lt;a href=&quot;shell&quot;&gt;Shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;shell&quot;&gt;셸&lt;/a&gt; 실행 지원 .</target>
        </trans-unit>
        <trans-unit id="e838211f110950da21190e2b4cd394331c2cfaad" translate="yes" xml:space="preserve">
          <source>Support for simple completers.</source>
          <target state="translated">단순 완성 자 지원.</target>
        </trans-unit>
        <trans-unit id="b1847ef28b474109bae86b9ff6f88f30c6d1cb1e" translate="yes" xml:space="preserve">
          <source>Support for simple completors.</source>
          <target state="translated">간단한 완성 자 지원.</target>
        </trans-unit>
        <trans-unit id="a4cd4262c16597d35c917b71e4dacdb860118533" translate="yes" xml:space="preserve">
          <source>Support methods for &lt;a href=&quot;statictypecheckingvisitor&quot;&gt;StaticTypeCheckingVisitor&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;statictypecheckingvisitor&quot;&gt;StaticTypeCheckingVisitor에&lt;/a&gt; 대한 지원 메서드 .</target>
        </trans-unit>
        <trans-unit id="b334e44ba370eeb1a9fcce805d296237600394b7" translate="yes" xml:space="preserve">
          <source>Support methods for DefaultGroovyMethods and PluginDefaultMethods.</source>
          <target state="translated">DefaultGroovyMethods 및 PluginDefaultMethods에 대한 지원 메서드.</target>
        </trans-unit>
        <trans-unit id="40274db933b81a98b5c697affa7d5c7f16fa92d3" translate="yes" xml:space="preserve">
          <source>Support methods for Groovy category usage</source>
          <target state="translated">Groovy 카테고리 사용을위한 지원 방법</target>
        </trans-unit>
        <trans-unit id="588dfb8cd9cca2180f8096de40629699cecfce75" translate="yes" xml:space="preserve">
          <source>Support mutating a Calendar with a Map.</source>
          <target state="translated">지도로 캘린더 변경을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="606b6da19d3862e2b1d54033b51c6a674ad9524f" translate="yes" xml:space="preserve">
          <source>Support mutating a Date with a Map.</source>
          <target state="translated">지도로 날짜 변경을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0065fbb73dfe423e4f2b0b788b77b810d1895bf4" translate="yes" xml:space="preserve">
          <source>Support retrieving a subset of a BitSet using a Range</source>
          <target state="translated">Range를 사용하여 BitSet의 하위 집합 검색 지원</target>
        </trans-unit>
        <trans-unit id="cefe376baa46053e6ee5cd1185a7ec7bd5de75a2" translate="yes" xml:space="preserve">
          <source>Support subscript operator for list access.</source>
          <target state="translated">목록 액세스를 위해 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0ce8c0aa36043dde1f96ca757bfc9ca258b03f47" translate="yes" xml:space="preserve">
          <source>Support subscript operator for list modification.</source>
          <target state="translated">목록 수정을 위해 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="948555c5f9bb59c7e564313dae8e9e5e33359ef5" translate="yes" xml:space="preserve">
          <source>Support subscript-style assignment for a BitSet.</source>
          <target state="translated">BitSet에 대한 아래 첨자 스타일 할당을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="277c0c9a0992135998848b12d1623638750f1db0" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for StringBuilder.</source>
          <target state="translated">StringBuilder에 대한 범위 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="09c4c0a5e355d7aa584752cfc33a252f0a73e60e" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for StringBuilder. Index values are treated as characters within the builder.</source>
          <target state="translated">StringBuilder에 대한 범위 첨자 연산자를 지원합니다. 색인 값은 빌더 내에서 문자로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="acd26eb8b1a16f0820319830f663499ae85c68f8" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for a List.</source>
          <target state="translated">목록에 대한 범위 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="930099686e74d43336ccb036b84c0e5da6eec9e3" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for an Array</source>
          <target state="translated">배열에 대한 범위 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="b999effc2096576e1c862e817448092036970953" translate="yes" xml:space="preserve">
          <source>Support the range subscript operator for an eager or lazy List.</source>
          <target state="translated">eager 또는 lazy 목록에 대해 범위 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8024a4e87a055ac0bfbf3a79248d3db4e937f9ff" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for ButtonGroup.</source>
          <target state="translated">ButtonGroup에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8883233fb47d8a916e31ae51ad0682c85c140a3e" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for Collection.</source>
          <target state="translated">Collection에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="137e043d5266d133be830bee498a61305b08656b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for Container.</source>
          <target state="translated">컨테이너에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="07b736f7865baa83c1f6bc649704d426a52a785a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JComboBox.</source>
          <target state="translated">JComboBox에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="31a8136fdf49a95aaa951ea4ed67ec07e9acc80a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JMenu.</source>
          <target state="translated">JMenu에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a6bfb46585e8e0eabd4032848ef55c15306e4cd5" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JMenuBar.</source>
          <target state="translated">JMenuBar에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a0c882c6cd60c5c1b40d2bd576e5c94a555b1c4a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JTabbedPane.</source>
          <target state="translated">JTabbedPane에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="67f5eb23bb29271d8db04f6cc3958a10877bd86b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for JToolBar.</source>
          <target state="translated">JToolBar에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3edb03f1dbd6dbc567ef944a1323b4462a95935b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for ListModel.</source>
          <target state="translated">ListModel에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d2b5237de01694410633b548a0f924fa610af129" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for TableColumnModel.</source>
          <target state="translated">TableColumnModel에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f26d8833306b343dfe6bb5e4ffca867bd20aad7e" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for TableModel.</source>
          <target state="translated">TableModel에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f63e2cb744c1c451ecc2c5de29107932d57249e8" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for TreeNode.</source>
          <target state="translated">TreeNode에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="46b3703b70c5b77bb85b2a093946ef0c0693b3c5" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for TreePath.</source>
          <target state="translated">TreePath에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="82ca1dcdc1480532f560c6be7abbec186ccf6ee7" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a Bitset</source>
          <target state="translated">Bitset에 대한 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="a337c06c56778b26331f5a920f766882be3b0493" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a Calendar.</source>
          <target state="translated">달력에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="77f7a0636dc8671f55b6f4130764c09c166c7835" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a Date.</source>
          <target state="translated">날짜에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b96b77d4e05609bf5ebac837d1ea604f4bd48580" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a List.</source>
          <target state="translated">목록에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="18104f39e920408c5dbd3d2de4a52926a170a585" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for a Map.</source>
          <target state="translated">지도에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b7d5a370e14d88ca3b733df074745e512491e1b8" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for an Iterable.</source>
          <target state="translated">Iterable에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="da54421b2475020061b3a47e604a37ada578e23a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for an Iterable. Typical usage:</source>
          <target state="translated">Iterable에 대한 아래 첨자 연산자를 지원합니다. 일반적인 사용법 :</target>
        </trans-unit>
        <trans-unit id="b136f29e517965b9fab5e959f6e4c99faa02cbad" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for an Iterator.</source>
          <target state="translated">반복자에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="712e012634442f739e8d9439273ee6c5469514b8" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for an Iterator. The iterator will be partially exhausted up until the idx entry after returning if a +ve or 0 idx is used, or fully exhausted if a -ve idx is used or no corresponding entry was found. Typical usage:</source>
          <target state="translated">반복자에 대한 아래 첨자 연산자를 지원합니다. 반복기는 + ve 또는 0 idx가 사용 된 경우 반환 된 후 idx 항목까지 부분적으로 고갈되거나 -ve idx가 사용되거나 해당 항목이 발견되지 않으면 완전히 고갈됩니다. 일반적인 사용법 :</target>
        </trans-unit>
        <trans-unit id="05e1c675a16d28913679eb9bf33a6f3849996840" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for mutating a Calendar.</source>
          <target state="translated">달력 변경을 위해 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e3005a57b2f65de8b8ee3c9e383470c171c93a51" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for mutating a Calendar. Example usage:</source>
          <target state="translated">달력 변경을 위해 아래 첨자 연산자를 지원합니다. 사용 예 :</target>
        </trans-unit>
        <trans-unit id="0832f9dcf462ade3391f384e44f33f1d4a5d9801" translate="yes" xml:space="preserve">
          <source>Support the subscript operator for mutating a Date.</source>
          <target state="translated">날짜 변경을 위해 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="dcdaffd8f1f395b917d10a9f7899c51471d965d2" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a boolean array</source>
          <target state="translated">부울 배열에 대한 컬렉션으로 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="38960d85e9835053606b584f60047fc89487b81f" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a byte array</source>
          <target state="translated">바이트 배열에 대한 컬렉션으로 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="bfdd8cbe5169c3fba3ea647b156633a848266f23" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a char array</source>
          <target state="translated">char 배열에 대한 컬렉션으로 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="90742627dc6eb2f9b4d8227c151fad8d57423b85" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a double array</source>
          <target state="translated">이중 배열에 대한 컬렉션으로 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="39150a8bf39dcd107e1c51ddc573ad89d6269053" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a float array</source>
          <target state="translated">float 배열에 대한 컬렉션으로 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="4e129074b798751ecffc90e0fd782beeab070ad2" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a long array</source>
          <target state="translated">긴 배열에 대한 컬렉션으로 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="7d242b1c1771299e2b79691a29aaefc7f993eb38" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for a short array</source>
          <target state="translated">짧은 배열에 대한 컬렉션으로 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="449fc6a9aae0653fc2a2dd933669712b98794a67" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a collection for an int array</source>
          <target state="translated">int 배열에 대한 컬렉션으로 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="406c3c4313afad025dc0f000a9d36af8c01ef6dc" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a boolean array</source>
          <target state="translated">부울 배열 범위로 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="eb5575ed4428458ede0b0ffe18053e0022f2c8b6" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a byte array</source>
          <target state="translated">바이트 배열 범위로 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="e061d0f5fcf78a949d304e48051b333e3509a09b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a char array</source>
          <target state="translated">char 배열에 대한 범위로 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="d56f743158eb5c5d9a114b722ab2b8aa764c4884" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a double array</source>
          <target state="translated">이중 배열에 대한 범위로 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="dc6bb5f77572817a5a2d27996636a61f948630a5" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a float array</source>
          <target state="translated">float 배열에 대한 범위로 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="ad8c10b070d78470ed959ae01f3a4b6165c06ea0" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a long array</source>
          <target state="translated">긴 배열에 대한 범위로 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="ee52af5b564b8bd5b211088bca646f5f8706167a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for a short array</source>
          <target state="translated">짧은 배열에 대한 범위로 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="1fae014c47830c0263f0c70591acd2cb75401882" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with a range for an int array</source>
          <target state="translated">int 배열에 대한 범위로 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="51b1c738fc5421c1900cbcf82f77be491419f636" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a boolean array</source>
          <target state="translated">부울 배열에 대해 IntRange를 사용하여 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="737a9dafe198558df1a051d1b235f28a914614a9" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a byte array</source>
          <target state="translated">바이트 배열에 대해 IntRange를 사용하여 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="b2e85416ac1bef6482c8defff54899a74c630bad" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a char array</source>
          <target state="translated">char 배열에 대해 IntRange를 사용하여 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="308844e7ffcdb4e852e6200501bf93b50edd1146" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a double array</source>
          <target state="translated">이중 배열에 대해 IntRange를 사용하여 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="e8172d0a1db9a00b56b31db2555af86194397bdf" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a float array</source>
          <target state="translated">부동 배열에 대해 IntRange를 사용하여 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="1d9f1a77baa8f3f7c7be70b2868cc3da8cbd873b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a long array</source>
          <target state="translated">긴 배열에 대해 IntRange를 사용하여 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="846540f6464f33fa68fb5a18a1bdda484d94be1a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for a short array</source>
          <target state="translated">짧은 배열에 대해 IntRange를 사용하여 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="86d49e4722c5856590c8457389b79e367a48336b" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an IntRange for an int array</source>
          <target state="translated">int 배열에 대해 IntRange를 사용하여 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="135d071ce0e747dd6c86c1f1ea6ff0bd031e49c8" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a byte array</source>
          <target state="translated">바이트 배열에 대해 ObjectRange를 사용하여 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="494432a9314d4c872a0569f09c6de99b5dacc87a" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a char array</source>
          <target state="translated">char 배열에 대해 ObjectRange로 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="2efca516ac0e519470608b925ed538b8fb748e45" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a double array</source>
          <target state="translated">이중 배열에 대해 ObjectRange를 사용하여 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="a688426210c62de688f8dcf07f4c2ab964d91970" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a float array</source>
          <target state="translated">float 배열에 대해 ObjectRange로 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="2ee30662b569f7f70c6b555a7b4769ca93dd7017" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a long array</source>
          <target state="translated">긴 배열에 대해 ObjectRange를 사용하여 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="92bb07165d787ba1a31571dfaf457860dd156cc3" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for a short array</source>
          <target state="translated">짧은 배열에 대해 ObjectRange로 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="0d8f69636a462dfdae8f77c74465fe081dcc0144" translate="yes" xml:space="preserve">
          <source>Support the subscript operator with an ObjectRange for an int array</source>
          <target state="translated">int 배열에 대해 ObjectRange를 사용하여 아래 첨자 연산자 지원</target>
        </trans-unit>
        <trans-unit id="e81c22dfff611d4ce5af5cc7d3ba8e087782c019" translate="yes" xml:space="preserve">
          <source>Supported syntax:</source>
          <target state="translated">지원되는 구문 :</target>
        </trans-unit>
        <trans-unit id="29082ca330fc6abf963f95d250bbb9faa7ada8ea" translate="yes" xml:space="preserve">
          <source>Supports integer based subscript operators for accessing at numbered columns starting at zero.</source>
          <target state="translated">0부터 시작하는 번호가 매겨진 열에서 액세스하기 위해 정수 기반 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="685b4ee9fceb194e1bba657c003c3d9058d640a0" translate="yes" xml:space="preserve">
          <source>Supports integer based subscript operators for accessing at numbered columns starting at zero. Negative indices are supported, they will count from the last column backwards.</source>
          <target state="translated">0부터 시작하는 번호가 매겨진 열에서 액세스하기 위해 정수 기반 아래 첨자 연산자를 지원합니다. 음수 인덱스가 지원되며 마지막 열부터 역순으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="d8a1dffb79c3a58bf51ad444252e384308031a1f" translate="yes" xml:space="preserve">
          <source>Supports integer based subscript operators for updating the values of numbered columns starting at zero.</source>
          <target state="translated">0부터 시작하는 번호가 매겨진 열의 값을 업데이트하기 위해 정수 기반 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b9040372ef64134ed11c8ca3980f52a75c335178" translate="yes" xml:space="preserve">
          <source>Supports integer based subscript operators for updating the values of numbered columns starting at zero. Negative indices are supported, they will count from the last column backwards.</source>
          <target state="translated">0부터 시작하는 번호가 매겨진 열의 값을 업데이트하기 위해 정수 기반 아래 첨자 연산자를 지원합니다. 음수 인덱스가 지원되며 마지막 열부터 역순으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="e121e3a40b35411dcbf80ace25a2cab09c6a9d81" translate="yes" xml:space="preserve">
          <source>Supports integer-based subscript operators for accessing at numbered columns starting at zero.</source>
          <target state="translated">0부터 시작하는 번호가 매겨진 열에 액세스하기 위해 정수 기반 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6650b1b6bbaec3d498660928194e1e004714a8ee" translate="yes" xml:space="preserve">
          <source>Supports integer-based subscript operators for accessing at numbered columns starting at zero. Negative indices are supported, they will count from the last column backwards.</source>
          <target state="translated">0부터 시작하는 번호가 매겨진 열에 액세스하기 위해 정수 기반 아래 첨자 연산자를 지원합니다. 음수 인덱스가 지원되며 마지막 열부터 역순으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="f6892c78c1164bf275bea2cf843d7c79de2a8d05" translate="yes" xml:space="preserve">
          <source>Supports only the five basic XML entities (gt, lt, quot, amp, apos)</source>
          <target state="translated">5 개의 기본 XML 엔티티 (gt, lt, quot, amp, apos) 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="272482f4c74fef3dcf775ef6e04d38a838b4eddf" translate="yes" xml:space="preserve">
          <source>Supports the division operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#dividedBy(long)&quot;&gt;Duration.dividedBy&lt;/a&gt; method.</source>
          <target state="translated">나누기 연산자를 지원합니다. &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#dividedBy(long)&quot;&gt;Duration.dividedBy&lt;/a&gt; 메서드 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6e3256613e913c27b4d30572865fb8f14dba9d45" translate="yes" xml:space="preserve">
          <source>Supports the getAt operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/ZoneOffset.html#getLong(java.time.temporal.TemporalField)&quot;&gt;ZoneOffset.getLong&lt;/a&gt; method.</source>
          <target state="translated">getAt 연산자를 지원합니다. &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/ZoneOffset.html#getLong(java.time.temporal.TemporalField)&quot;&gt;ZoneOffset.getLong&lt;/a&gt; 메서드 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3d1b992b51a3b320adfa7435877250915682a88b" translate="yes" xml:space="preserve">
          <source>Supports the getAt operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAccessor.html#getLong(java.time.temporal.TemporalField)&quot;&gt;TemporalAccessor.getLong&lt;/a&gt; method.</source>
          <target state="translated">getAt 연산자를 지원합니다. &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAccessor.html#getLong(java.time.temporal.TemporalField)&quot;&gt;TemporalAccessor.getLong&lt;/a&gt; 메서드 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="45b564a7490c0cfc9ab37fb49992105cbdffd741" translate="yes" xml:space="preserve">
          <source>Supports the getAt operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAmount.html#get(TemporalUnit)&quot;&gt;TemporalAmount.get&lt;/a&gt; method.</source>
          <target state="translated">getAt 연산자를 지원합니다. &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAmount.html#get(TemporalUnit)&quot;&gt;TemporalAmount.get&lt;/a&gt; 메서드 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9fbf8412864ed83f47c19fb2de0ad38b4c2d88bb" translate="yes" xml:space="preserve">
          <source>Supports the multiplication operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#multipliedBy(long)&quot;&gt;Duration.multipliedBy&lt;/a&gt; method.</source>
          <target state="translated">곱셈 연산자를 지원합니다. &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#multipliedBy(long)&quot;&gt;Duration.multipliedBy&lt;/a&gt; 메서드 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9c58b6034a8cda0cb4caab3bc1a085313bf5131d" translate="yes" xml:space="preserve">
          <source>Supports the multiply operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html#multipliedBy(int)&quot;&gt;Period.multipliedBy&lt;/a&gt; method.</source>
          <target state="translated">곱하기 연산자를 지원합니다. &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html#multipliedBy(int)&quot;&gt;Period.multipliedBy&lt;/a&gt; 메서드 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1f12770c32aa35e5994877bee4b25b602e3e93f3" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for CharSequence or StringBuffer with EmptyRange</source>
          <target state="translated">EmptyRange가있는 CharSequence 또는 StringBuffer에 대한 범위 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c2d8232579b8962a2f78045b849d8783bfeba70b" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for CharSequence with IntRange.</source>
          <target state="translated">IntRange가있는 CharSequence에 대한 범위 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="734ac83eea03aa14f6f645cbb62c57d5ebc7a7cb" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for CharSequence.</source>
          <target state="translated">CharSequence에 대한 범위 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1c17ccd565eec637aeb61b93388e26907f417969" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for GString with IntRange.</source>
          <target state="translated">IntRange가있는 GString에 대한 범위 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2de30284c9a0e8fcec0804002be4e2ae2ec22240" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for GString.</source>
          <target state="translated">GString에 대한 범위 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c21234956f0cebc724e038773b6489ec986cabd2" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for String with IntRange.</source>
          <target state="translated">IntRange가있는 문자열에 대한 범위 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="30590a771f8986708ccb6659f99345ce35751d79" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for String.</source>
          <target state="translated">문자열에 대한 범위 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="87567806977a560b8169c7b6d539bc7ee1adcfbc" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for StringBuffer.</source>
          <target state="translated">StringBuffer에 대한 범위 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e5b5e33b1e927360d37b9e7aff1c489178f6ab28" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for StringBuffer. Index values are treated as characters within the buffer.</source>
          <target state="translated">StringBuffer에 대한 범위 첨자 연산자를 지원합니다. 인덱스 값은 버퍼 내에서 문자로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="603e946fa86fe6630cb7e4e41deba0896a06b13b" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for StringBuilder.</source>
          <target state="translated">StringBuilder에 대한 범위 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="76f1d48bcdcf4c5ad55799e7efb5332d2c727357" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for StringBuilder. Index values are treated as characters within the builder.</source>
          <target state="translated">StringBuilder에 대한 범위 첨자 연산자를 지원합니다. 색인 값은 빌더 내에서 문자로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b3868e5ccdf1c52b1bcae61cb67a1658a621b670" translate="yes" xml:space="preserve">
          <source>Supports the range subscript operator for a GPathResult.</source>
          <target state="translated">GPathResult에 대한 범위 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="847373efea045010884a5921e02aeb3939071729" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator for CharSequence.</source>
          <target state="translated">CharSequence에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="643bb4275fc8f901b11dbe657ab42dacee233538" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator for GString.</source>
          <target state="translated">GString에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c14c15e33602a664d9d6717e5a114f93eff3f995" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator for String.</source>
          <target state="translated">문자열에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1eeaf121a846e73418ed8bb3f658e4d50c2b1ac6" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator for a GPathResult.</source>
          <target state="translated">GPathResult에 대한 아래 첨자 연산자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a5e7d8728bc31a020c837e7346295444cfb639ed" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator, e.g.</source>
          <target state="translated">아래 첨자 연산자를 지원합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="63d6e6526a6efcf42b637b3fee8333d2c42dfe8a" translate="yes" xml:space="preserve">
          <source>Supports the subscript operator, e.g. &lt;code&gt;matcher[index]&lt;/code&gt;, for a &lt;code&gt;Matcher&lt;/code&gt;.</source>
          <target state="translated">지원 첨자 연산자, 즉 &lt;code&gt;matcher[index]&lt;/code&gt; A에 대한, &lt;code&gt;Matcher&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="b24a8e67655e2d3680c8d291f8d695bc52b8deef" translate="yes" xml:space="preserve">
          <source>Supports the unary minus operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#negated()&quot;&gt;Duration.negated&lt;/a&gt; method.</source>
          <target state="translated">단항 빼기 연산자를 지원합니다. &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#negated()&quot;&gt;Duration.negated&lt;/a&gt; 메서드 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ef16973534d92d25c8ba950c50ef216e3d129c99" translate="yes" xml:space="preserve">
          <source>Supports the unary minus operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html#negated()&quot;&gt;Period.negated&lt;/a&gt; method.</source>
          <target state="translated">단항 빼기 연산자를 지원합니다. &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html#negated()&quot;&gt;Period.negated&lt;/a&gt; 메서드 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ca1984ff7448bd1530fcb00a669677ddf234ba06" translate="yes" xml:space="preserve">
          <source>Supports the unary plus operator; equivalent to calling the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#abs()&quot;&gt;Duration.abs&lt;/a&gt; method.</source>
          <target state="translated">단항 더하기 연산자를 지원합니다. &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#abs()&quot;&gt;Duration.abs&lt;/a&gt; 메서드 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9671c499c2b0eccb12ed3d9fb0e71ffb8f89feef" translate="yes" xml:space="preserve">
          <source>Supports the unary plus operator; returns a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html&quot;&gt;Period&lt;/a&gt; with all unit values positive.</source>
          <target state="translated">단항 더하기 연산자를 지원합니다. 모든 단위 값이 양수인 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html&quot;&gt;기간&lt;/a&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f2b3726eac67d7b17290df48a691ab6648c417ac" translate="yes" xml:space="preserve">
          <source>Supports the unary plus operator; returns a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html&quot;&gt;Period&lt;/a&gt; with all unit values positive. For example, a period of &quot;2 years, -3 months, and -4 days&quot; would result in a period of &quot;2 years, 3 months, and 4 days.&quot; No normalization is performed.</source>
          <target state="translated">단항 더하기 연산자를 지원합니다. 모든 단위 값이 양수인 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html&quot;&gt;기간&lt;/a&gt; 을 반환합니다 . 예를 들어 &quot;2 년, -3 개월 및 -4 일&quot;의 기간은 &quot;2 년, 3 개월 및 4 일&quot;의 기간이됩니다. 정규화가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="444b203ece3ce0e7f35d5c0aef68426d9b0d431c" translate="yes" xml:space="preserve">
          <source>Swaps two elements at the specified positions.</source>
          <target state="translated">지정된 위치에서 두 요소를 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="11d786b4e23376ea3dc79c4c0a88541bba21feca" translate="yes" xml:space="preserve">
          <source>Swing application to graphically display the tokens produced by the lexer.</source>
          <target state="translated">렉서가 생성 한 토큰을 그래픽으로 표시하는 스윙 애플리케이션.</target>
        </trans-unit>
        <trans-unit id="a505d05672b9c632c10baf50232815e236897342" translate="yes" xml:space="preserve">
          <source>SwingBuilder helper classes for creating components</source>
          <target state="translated">컴포넌트 생성을위한 SwingBuilder 도우미 클래스</target>
        </trans-unit>
        <trans-unit id="b4d5fef0fd56423d2005b5f23fc72bafc05788b9" translate="yes" xml:space="preserve">
          <source>Switches the builder's proxyBuilder during the execution of a closure.</source>
          <target state="translated">클로저를 실행하는 동안 빌더의 proxyBuilder를 전환합니다.</target>
        </trans-unit>
        <trans-unit id="1d654f8f369be41ce70e791e599030be1914b8e6" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;a href=&quot;#toSpreadMap(java.util.Map)&quot;&gt;toSpreadMap(java.util.Map)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#toSpreadMap(java.util.Map)&quot;&gt;toSpreadMap (java.util.Map)의&lt;/a&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="8bf9b65aa3eb7662090be9b911189d54f126ea4c" translate="yes" xml:space="preserve">
          <source>Synonym for &lt;code&gt;compile(Phases.ALL)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;compile(Phases.ALL)&lt;/code&gt; 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="f7e7d4ec9c98e022a28f28595845ab382d8e7b30" translate="yes" xml:space="preserve">
          <source>Synonym for full compilation</source>
          <target state="translated">전체 컴파일의 동의어</target>
        </trans-unit>
        <trans-unit id="922c2e5f4ef255d4058e512453e827f08ec07983" translate="yes" xml:space="preserve">
          <source>Synonym for write(text) allowing file.text = 'foo'.</source>
          <target state="translated">file.text = 'foo'를 허용하는 write (text)의 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="c6f6827d49ab5f403cdd18485a48da06676e323d" translate="yes" xml:space="preserve">
          <source>Synonym for write(text, charset) allowing:</source>
          <target state="translated">다음을 허용하는 write (text, charset)의 동의어 :</target>
        </trans-unit>
        <trans-unit id="38259ff21e4eb435a46c701dcdd29b24d58b4a78" translate="yes" xml:space="preserve">
          <source>Syntax supported:</source>
          <target state="translated">지원되는 구문 :</target>
        </trans-unit>
        <trans-unit id="1de8dba368e7754dc199c99b017f5c51265ee8dc" translate="yes" xml:space="preserve">
          <source>Syntax:</source>
          <target state="translated">Syntax:</target>
        </trans-unit>
        <trans-unit id="92f3ec2c7d54e41b31652ea8927f4cb0fe0d53b2" translate="yes" xml:space="preserve">
          <source>SyntaxErrorReportable</source>
          <target state="translated">SyntaxErrorReportable</target>
        </trans-unit>
        <trans-unit id="989982c92d7d7b069cc494d871290c6c79dd1bea" translate="yes" xml:space="preserve">
          <source>System.currentTimeMillis</source>
          <target state="translated">System.currentTimeMillis</target>
        </trans-unit>
        <trans-unit id="52f9440d82aa136e8330aac61d5581f83dc6cf89" translate="yes" xml:space="preserve">
          <source>Systematically generate permutations. Adapted from Java Code by Michael Gilleland (released with no restrictions) using an algorithm described here: Kenneth H. Rosen, Discrete Mathematics and Its Applications, 2nd edition (NY: McGraw-Hill, 1991), pp. 282-284</source>
          <target state="translated">체계적으로 순열을 생성합니다. 여기에 설명 된 알고리즘을 사용하여 Michael Gilleland (제한없이 릴리스 됨)의 Java 코드에서 수정 : Kenneth H. Rosen, Discrete Mathematics and Its Applications, 2nd edition (NY : McGraw-Hill, 1991), pp. 282-284</target>
        </trans-unit>
        <trans-unit id="dab1fd1e591a63e3e5e200ee8fa3c5a14d2c00db" translate="yes" xml:space="preserve">
          <source>T foo(){}</source>
          <target state="translated">T foo(){}</target>
        </trans-unit>
        <trans-unit id="8fe6d0b31eb59e6ac337f0b92f98cb3ad502463c" translate="yes" xml:space="preserve">
          <source>TODO Get list of groovydoc tags</source>
          <target state="translated">TODO groovydoc 태그 목록 가져 오기</target>
        </trans-unit>
        <trans-unit id="921b6844ab03e31995729bfc75953f8eac7378a3" translate="yes" xml:space="preserve">
          <source>TODO parse groovydoc to get tag content</source>
          <target state="translated">TODO는 groovydoc를 구문 분석하여 태그 콘텐츠를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a4ba86ffe7ca973bae787f6414c279df51d0ddf5" translate="yes" xml:space="preserve">
          <source>TODO: Should return the URI for this source, but we can't know what it is here.</source>
          <target state="translated">TODO :이 소스에 대한 URI를 반환해야하지만 여기에 무엇인지 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cf93c98946db5510058c27414ea744e90e3279d8" translate="yes" xml:space="preserve">
          <source>TODO: experimental!</source>
          <target state="translated">TODO : 실험적입니다!</target>
        </trans-unit>
        <trans-unit id="3657c9335058621e4530f335028b3958464c5aa9" translate="yes" xml:space="preserve">
          <source>TODO: experimental! Annotates an AST node with matching contraints. This method should be called on an AST intended to be used as a pattern only. It will put node metadata on the AST node allowing customized behavior in pattern matching.</source>
          <target state="translated">TODO : 실험적입니다! 제약 조건이 일치하는 AST 노드에 주석을 추가합니다. 이 메서드는 패턴으로 만 사용하기위한 AST에서 호출해야합니다. 패턴 일치에서 사용자 지정 동작을 허용하는 AST 노드에 노드 메타 데이터를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="b1c7a681e02f969b203ba3592fa54d2c692bbb52" translate="yes" xml:space="preserve">
          <source>TableCellEditor</source>
          <target state="translated">TableCellEditor</target>
        </trans-unit>
        <trans-unit id="57561c4bfa715cb5f4cf7c5dbfce29a5881d0950" translate="yes" xml:space="preserve">
          <source>TableModelListener</source>
          <target state="translated">TableModelListener</target>
        </trans-unit>
        <trans-unit id="5d7cbdd762e595f129150b280be1165c581c52dc" translate="yes" xml:space="preserve">
          <source>Takes a statement and wraps it into a block statement which first element is the interruption check statement.</source>
          <target state="translated">문을 가져 와서 첫 번째 요소가 인터럽트 검사 문인 블록 문으로 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="354438b5f2c2435d85aef9e5e1d521b569efa655" translate="yes" xml:space="preserve">
          <source>Takes a zero based index and convert it into an SQL based 1 based index.</source>
          <target state="translated">0 기반 인덱스를 취하여 SQL 기반 1 기반 인덱스로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="041aa4646c123f7952eaab5d26bd55d6a7709b46" translate="yes" xml:space="preserve">
          <source>Takes a zero based index and convert it into an SQL based 1 based index. A negative index will count backwards from the last column.</source>
          <target state="translated">0 기반 인덱스를 취하여 SQL 기반 1 기반 인덱스로 변환합니다. 음수 인덱스는 마지막 열부터 역순으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="72e15a873cff2714be38f04fe3477dcbcb571d1e" translate="yes" xml:space="preserve">
          <source>Takes the characters between nth (specified by occurrence) pair of &lt;code&gt;enclosure&lt;/code&gt; strings.</source>
          <target state="translated">&lt;code&gt;enclosure&lt;/code&gt; 문자열 의 n 번째 (어커런스로 지정됨) 쌍 사이의 문자를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="4fdd5b94d50723024ee61c7a3f2a6df16695a3b8" translate="yes" xml:space="preserve">
          <source>Takes the characters between the first occurrence of the two subsequent &lt;code&gt;enclosure&lt;/code&gt; strings.</source>
          <target state="translated">두 개의 후속 &lt;code&gt;enclosure&lt;/code&gt; 문자열 의 첫 번째 발생 사이의 문자를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="8f5401efdd15336ecf28fb95881261864d11cc09" translate="yes" xml:space="preserve">
          <source>Takes the last ?</source>
          <target state="translated">마지막을 취합니까?</target>
        </trans-unit>
        <trans-unit id="5ad0f94b3f2dd848f00aba4d7d9abd45a61b5b02" translate="yes" xml:space="preserve">
          <source>Takes the last ? tokens of the list that form a simple expression, evaluates it and returns a result. &quot;Simple&quot; means evaluation is known to be side-effect free.</source>
          <target state="translated">마지막을 취합니까? 간단한 표현식을 형성하고 평가하고 결과를 반환하는 목록의 토큰입니다. &quot;단순&quot;은 평가가 부작용이없는 것으로 알려져 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c304b15ae8ce0d2e4f76ba2ec779635f48eea681" translate="yes" xml:space="preserve">
          <source>Target.class</source>
          <target state="translated">Target.class</target>
        </trans-unit>
        <trans-unit id="7a099fd78212cd2ae28a2ff9a08f499c9dc92e4d" translate="yes" xml:space="preserve">
          <source>TargetBinding</source>
          <target state="translated">TargetBinding</target>
        </trans-unit>
        <trans-unit id="da5a824ba0bd242c7a60e17970f2791dec54d4ab" translate="yes" xml:space="preserve">
          <source>Tells if a class is one of the &quot;accept all&quot; classes as the left hand side of an assignment.</source>
          <target state="translated">클래스가 과제의 왼쪽에있는 &quot;모두 수락&quot;클래스 중 하나인지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="0e09ff464218acfb2c73af0f0dc15dbca113a8c2" translate="yes" xml:space="preserve">
          <source>Tells if a class node is candidate for class literal bytecode optimization.</source>
          <target state="translated">클래스 노드가 클래스 리터럴 바이트 코드 최적화의 후보인지 여부를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="05493540c669c245f9637bf19d526e8d21f77a68" translate="yes" xml:space="preserve">
          <source>Tells if a class node is candidate for class literal bytecode optimization. If so, bytecode may use LDC instructions instead of static constant Class fields to retrieve class literals.</source>
          <target state="translated">클래스 노드가 클래스 리터럴 바이트 코드 최적화의 후보인지 여부를 알려줍니다. 그렇다면 바이트 코드는 정적 상수 클래스 필드 대신 LDC 명령어를 사용하여 클래스 리터럴을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1d9bbbc3e04be119c70847b1f19b96ddd5a0d78" translate="yes" xml:space="preserve">
          <source>Tells if an input string matches a token.</source>
          <target state="translated">입력 문자열이 토큰과 일치하는지 여부를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="fd4940f1c01e2547dee0d64e72579a3db1df3a96" translate="yes" xml:space="preserve">
          <source>Tells if the given string is a valid Java identifier.</source>
          <target state="translated">주어진 문자열이 유효한 Java 식별자인지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="2bf831a8ad75f4c75e56aee27a3bdb1640b165c2" translate="yes" xml:space="preserve">
          <source>Tells if this variable or the accessed variable is used in a closure context, like in the following example :</source>
          <target state="translated">이 변수 또는 액세스 된 변수가 다음 예제와 같이 클로저 컨텍스트에서 사용되는지 여부를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="a5816f31fd183aa07200a002c77102dff5452d37" translate="yes" xml:space="preserve">
          <source>Template engine configuration</source>
          <target state="translated">템플릿 엔진 구성</target>
        </trans-unit>
        <trans-unit id="e12b935685180af8ae3137efb7001cba2cd17832" translate="yes" xml:space="preserve">
          <source>Template engine for use in templating scenarios where both the template source and the expected output are intended to be XML.</source>
          <target state="translated">템플릿 소스와 예상 출력이 모두 XML 인 템플릿 시나리오에서 사용하기위한 템플릿 엔진입니다.</target>
        </trans-unit>
        <trans-unit id="ef204f5f3596e2d30194001a07b4928b1a3949d3" translate="yes" xml:space="preserve">
          <source>TemplateEngine.createTemplate</source>
          <target state="translated">TemplateEngine.createTemplate</target>
        </trans-unit>
        <trans-unit id="dbf0ac726f3831ef2074d859816b327c66ed2b43" translate="yes" xml:space="preserve">
          <source>TemplateResolver</source>
          <target state="translated">TemplateResolver</target>
        </trans-unit>
        <trans-unit id="4436c0fa899dfbc2356893b025763c65d2d5384e" translate="yes" xml:space="preserve">
          <source>TemplateServlet.initTemplateEngine</source>
          <target state="translated">TemplateServlet.initTemplateEngine</target>
        </trans-unit>
        <trans-unit id="e593dd8801cfc67b3cac7df9ad54ee66fd2a486b" translate="yes" xml:space="preserve">
          <source>TemplateServlet.setVariables</source>
          <target state="translated">TemplateServlet.setVariables</target>
        </trans-unit>
        <trans-unit id="891b3675d27a4138af5360bd35bb314e25b67789" translate="yes" xml:space="preserve">
          <source>Templates may use the normal '${expression}' and '$variable' notations to insert an arbitrary expression into the template. In addition, support is also provided for special tags: &amp;lt;gsp:scriptlet&amp;gt; (for inserting code fragments) and &amp;lt;gsp:expression&amp;gt; (for code fragments which produce output).</source>
          <target state="translated">템플릿은 일반적인 '$ {expression}'및 '$ variable'표기법을 사용하여 템플릿에 임의의 식을 삽입 할 수 있습니다. 또한 특수 태그 인 &amp;lt;gsp : scriptlet&amp;gt; (코드 조각 삽입 용) 및 &amp;lt;gsp : expression&amp;gt; (출력을 생성하는 코드 조각 용)에 대한 지원도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="00122ac4f85694e5831e7199490968568e2ab42e" translate="yes" xml:space="preserve">
          <source>Terence Parr parrt@magelang.com John Lilley jlilley@empathy.com Scott Stanchfield thetick@magelang.com Markus Mohnen mohnen@informatik.rwth-aachen.de Peter Williams pete.williams@sun.com Allan Jacobs Allan.Jacobs@eng.sun.com Steve Messick messick@redhills.com James Strachan jstrachan@protique.com John Pybus john@pybus.org John Rose rose00@mac.com Jeremy Rayner groovy@ross-rayner.com Alex Popescu the.mindstorm@gmail.com Martin Kempf mkempf@hsr.ch Reto Kleeb rkleeb@hsr.ch Version 1.00 December 9, 1997 -- initial release Version 1.01 December 10, 1997 fixed bug in octal def (0..7 not 0..8) Version 1.10 August 1998 (parrt) added tree construction fixed definition of WS,comments for mac,pc,unix newlines added unary plus Version 1.11 (Nov 20, 1998) Added &quot;shutup&quot; option to turn off last ambig warning. Fixed inner class def to allow named class defs as statements synchronized requires compound not simple statement add [] after builtInType DOT class in primaryExpression &quot;const&quot; is reserved but not valid..removed from modifiers Version 1.12 (Feb 2, 1999) Changed LITERAL_xxx to xxx in tree grammar. Updated java.g to use tokens {...} now for 2.6.0 (new feature). Version 1.13 (Apr 23, 1999) Didn't have (stat)? for else clause in tree parser. Didn't gen ASTs for interface extends. Updated tree parser too. Updated to 2.6.0. Version 1.14 (Jun 20, 1999) Allowed final/abstract on local classes. Removed local interfaces from methods Put instanceof precedence where it belongs...in relationalExpr It also had expr not type as arg; fixed it. Missing ! on SEMI in classBlock fixed: (expr) + &quot;string&quot; was parsed incorrectly (+ as unary plus). fixed: didn't like Object[].class in parser or tree parser Version 1.15 (Jun 26, 1999) Screwed up rule with instanceof in it. :( Fixed. Tree parser didn't like (expr).something; fixed. Allowed multiple inheritance in tree grammar. oops. Version 1.16 (August 22, 1999) Extending an interface built a wacky tree: had extra EXTENDS. Tree grammar didn't allow multiple superinterfaces. Tree grammar didn't allow empty var initializer: {} Version 1.17 (October 12, 1999) ESC lexer rule allowed 399 max not 377 max. java.tree.g didn't handle the expression of synchronized statements. Version 1.18 (August 12, 2001) Terence updated to Java 2 Version 1.3 by observing/combining work of Allan Jacobs and Steve Messick. Handles 1.3 src. Summary: o primary didn't include boolean.class kind of thing o constructor calls parsed explicitly now: see explicitConstructorInvocation o add strictfp modifier o missing objBlock after new expression in tree grammar o merged local class definition alternatives, moved after declaration o fixed problem with ClassName.super.field o reordered some alternatives to make things more efficient o long and double constants were not differentiated from int/float o whitespace rule was inefficient: matched only one char o add an examples directory with some nasty 1.3 cases o made Main.java use buffered IO and a Reader for Unicode support o supports UNICODE? Using Unicode charVocabulary makes code file big, but only in the bitsets at the end. I need to make ANTLR generate unicode bitsets more efficiently. Version 1.19 (April 25, 2002) Terence added in nice fixes by John Pybus concerning floating constants and problems with super() calls. John did a nice reorg of the primary/postfix expression stuff to read better and makes f.g.super() parse properly (it was METHOD_CALL not a SUPER_CTOR_CALL). Also: o &quot;finally&quot; clause was a root...made it a child of &quot;try&quot; o Added stuff for asserts too for Java 1.4, but *commented out* as it is not backward compatible. Version 1.20 (October 27, 2002) Terence ended up reorging John Pybus' stuff to remove some nondeterminisms and some syntactic predicates. Note that the grammar is stricter now; e.g., this(...) must be the first statement. Trinary ?: operator wasn't working as array name: (isBig ? bigDigits : digits)[i]; Checked parser/tree parser on source for Resin-2.0.5, jive-2.1.1, jdk 1.3.1, Lucene, antlr 2.7.2a4, and the 110k-line jGuru server source. Version 1.21 (October 17, 2003) Fixed lots of problems including: Ray Waldin: add typeDefinition to interfaceBlock in java.tree.g He found a problem/fix with floating point that start with 0 Ray also fixed problem that (int.class) was not recognized. Thorsten van Ellen noticed that \n are allowed incorrectly in strings. TJP fixed CHAR_LITERAL analogously. Version 1.21.2 (March, 2003) Changes by Matt Quail to support generics (as per JDK1.5/JSR14) Notes: o We only allow the &quot;extends&quot; keyword and not the &quot;implements&quot; keyword, since that's what JSR14 seems to imply. o Thanks to Monty Zukowski for his help on the antlr-interest mail list. o Thanks to Alan Eliasen for testing the grammar over his Fink source base Version 1.22 (July, 2004) Changes by Michael Studman to support Java 1.5 language extensions Notes: o Added support for annotations types o Finished off Matt Quail's generics enhancements to support bound type arguments o Added support for new for statement syntax o Added support for static import syntax o Added support for enum types o Tested against JDK 1.5 source base and source base of jdigraph project o Thanks to Matt Quail for doing the hard part by doing most of the generics work Version 1.22.1 (July 28, 2004) Bug/omission fixes for Java 1.5 language support o Fixed tree structure bug with classOrInterface - thanks to Pieter Vangorpto for spotting this o Fixed bug where incorrect handling of SR and BSR tokens would cause type parameters to be recognised as type arguments. o Enabled type parameters on constructors, annotations on enum constants and package definitions o Fixed problems when parsing if ((char.class.equals(c))) {} - solution by Matt Quail at Cenqua Version 1.22.2 (July 28, 2004) Slight refactoring of Java 1.5 language support o Refactored for/&quot;foreach&quot; productions so that original literal &quot;for&quot; literal is still used but the for sub-clauses vary by token type o Fixed bug where type parameter was not included in generic constructor's branch of AST Version 1.22.3 (August 26, 2004) Bug fixes as identified by Michael Stahl; clean up of tabs/spaces and other refactorings o Fixed typeParameters omission in identPrimary and newStatement o Replaced GT reconcilliation code with simple semantic predicate o Adapted enum/assert keyword checking support from Michael Stahl's java15 grammar o Refactored typeDefinition production and field productions to reduce duplication Version 1.22.4 (October 21, 2004) Small bux fixes o Added typeArguments to explicitConstructorInvocation, e.g. new</source>
          <target state="translated">Terence Parr parrt@magelang.com John Lilley jlilley@empathy.com Scott Stanchfield thetick@magelang.com Markus Mohnen mohnen@informatik.rwth-aachen.de Peter Williams pete.williams@sun.com Allan Jacobs Allan.Jacobs@eng.sun .com Steve Messick messick@redhills.com James Strachan jstrachan@protique.com John Pybus john@pybus.org John Rose rose00@mac.com Jeremy Rayner groovy@ross-rayner.com Alex Popescu the.mindstorm@gmail.com Martin Kempf mkempf@hsr.ch Reto Kleeb rkleeb@hsr.ch 버전 1.00 1997 년 12 월 9 일-최초 릴리스 버전 1.01 1997 년 12 월 10 일 8 진 정의 (0..7이 아닌 0..7) 버전 1.10 1998 년 8 월 (parrt ) WS의 트리 구성 고정 정의 추가, mac, pc, unix 줄 바꿈 추가 단항 및 버전 1.11 (1998 년 11 월 20 일) 마지막 모호한 경고를 끄는 &quot;종료&quot;옵션이 추가되었습니다.primaryExpression &quot;const&quot;의 builtInType DOT 클래스가 예약되었지만 유효하지 않은 경우 구문이 동기화 된 경우 복합 명령문 add []가 필요하므로 명명 된 클래스 def를 허용하도록 내부 클래스 def를 수정했습니다. 수정 자 버전 1.12 (1999 년 2 월 2 일)에서 제거됨 LITERAL_xxx가 다음과 같이 변경되었습니다. 트리 문법에서 xxx. 2.6.0에 대해 {...} 토큰을 사용하도록 java.g가 업데이트되었습니다 (새 기능). 버전 1.13 (1999 년 4 월 23 일) (통계)가 없습니까? 트리 파서의 else 절. 인터페이스 확장을 위해 AST를 생성하지 않았습니다. 트리 파서도 업데이트되었습니다. 2.6.0으로 업데이트되었습니다. 버전 1.14 (1999 년 6 월 20 일) 로컬 클래스에 대한 최종 / 초록 허용. 메서드에서 로컬 인터페이스를 제거했습니다. instanceof 우선 순위를 해당 위치에 둡니다 ... in relationalExpr 또한 expr 형식이 arg 형식이 아닙니다. 고쳤다. 잃어버린 ! classBlock의 SEMI에 고정 : (expr) + &quot;string&quot;잘못 구문 분석되었습니다 (+는 단항 더하기). 수정 됨 : 파서 ​​또는 트리 파서 버전 1.15 (1999 년 6 월 26 일)의 Object []. class가 마음에 들지 않았습니다. instanceof가 포함 된 규칙이 잘못되었습니다. :( 수정 됨. 트리 파서는 (expr) .something; 수정 됨. 트리 문법에서 다중 상속을 허용했습니다. 죄송합니다. 버전 1.16 (1999 년 8 월 22 일) 인터페이스 확장으로 별난 트리 구축 : 추가 EXTENDS가 있습니다. 트리 문법은 그렇지 않습니다. '여러 수퍼 인터페이스를 허용하지 않습니다. 트리 문법은 빈 var 이니셜 라이저를 허용하지 않았습니다. {} 버전 1.17 (1999 년 10 월 12 일) ESC 렉서 규칙은 최대 377 개가 아닌 399 개를 허용했습니다 .java.tree.g는 동기화 된 명령문의 표현을 처리하지 않았습니다. 버전 1.18 (2001 년 8 월 12 일) Terence는 Allan Jacobs와 Steve Messick의 작업을 관찰 / 결합하여 Java 2 버전 1.3으로 업데이트되었습니다. 1.3 src를 처리합니다. 요약 : o primary에는 부울이 포함되지 않았습니다.클래스 종류의 것 o 생성자 호출이 명시 적으로 구문 분석 됨 : explicitConstructorInvocation 참조 o strictfp 수정 자 추가 o 트리 문법의 새 표현식 후 objBlock 누락 o 선언 후 이동 된 로컬 클래스 정의 대안 병합 o ClassName.super.field의 수정 된 문제 o 일부 대안 재정렬 더 효율적으로 만들기 o long 및 double 상수는 int / float와 구별되지 않았습니다. 공백 규칙이 비효율적이었습니다. 하나의 문자 만 일치 o 불쾌한 1.3 케이스가있는 예제 디렉토리 추가 o Main.java가 버퍼링 된 IO와 유니 코드 지원을 위해 리더를 사용하도록했습니다. o 유니 코드를 지원합니까? 유니 코드 charVocabulary를 사용하면 코드 파일이 커지지 만 끝에있는 비트 셋 만 커집니다. ANTLR이 유니 코드 비트 셋을보다 효율적으로 생성하도록해야합니다. 버전 1.19 (4 월 25 일2002) Terence는 부동 상수 및 super () 호출 문제와 관련하여 John Pybus의 멋진 수정 사항을 추가했습니다. John은 더 잘 읽을 수 있도록 primary / postfix 표현식의 멋진 재구성을 수행하고 fgsuper ()를 올바르게 구문 분석합니다 (SUPER_CTOR_CALL이 아닌 METHOD_CALL이었습니다). 또한 : o &quot;finally&quot;절은 루트였습니다 ... &quot;try&quot;의 자식으로 만들었습니다. o Java 1.4에도 어설 션을 추가했지만 이전 버전과 호환되지 않으므로 * 주석 처리 *되었습니다. 버전 1.20 (2002 년 10 월 27 일) Terence는 결국 John Pybus의 내용을 재구성하여 일부 비결정론과 일부 구문 술어를 제거했습니다. 이제 문법이 더 엄격 해졌습니다. 예를 들어, this (...)는 첫 번째 문이어야합니다. Trinary? : 연산자가 배열 이름으로 작동하지 않았습니다. (isBig? bigDigits : 숫자) [i]; Resin-2.0.5, jive-2.1.1, jdk 1.3.1, Lucene, antlr 2.7에 대한 소스에서 파서 / 트리 파서를 확인했습니다.2a4 및 110k 라인 jGuru 서버 소스. 버전 1.21 (2003 년 10 월 17 일) 다음과 같은 많은 문제를 수정했습니다. Ray Waldin : java.tree.g의 interfaceBlock에 typeDefinition을 추가합니다. 0으로 시작하는 부동 소수점 문제를 발견했습니다. Ray도 문제를 수정했습니다. (int.class) 인식되지 않았습니다. Thorsten van Ellen은 \ n이 문자열에서 잘못 허용된다는 것을 알아 차 렸습니다. TJP는 CHAR_LITERAL을 비슷하게 고정했습니다. 버전 1.21.2 (2003 년 3 월) 제네릭을 지원하기위한 Matt Quail의 변경 사항 (JDK1.5 / JSR14에 따름) 참고 : o JSR14는 &quot;implements&quot;키워드가 아닌 &quot;extends&quot;키워드 만 허용합니다. 암시합니다. o antlr-interest 메일 목록에 도움을 주신 Monty Zukowski에게 감사드립니다. o Alan Eliasen의 Fink 소스 기반 버전 1.22 (2004 년 7 월)에 대한 문법 테스트에 감사드립니다. Michael Studman이 Java 1을 지원하도록 변경했습니다.5 개 언어 확장 참고 : o 주석 유형에 대한 지원 추가 o 바인딩 된 유형 인수를 지원하기 위해 Matt Quail의 제네릭 향상 완료 o 새로운 for 문 구문 지원 추가 o 정적 가져 오기 구문 지원 추가 o enum 유형 지원 추가 o JDK 1.5 소스에 대해 테스트 됨 jdigraph 프로젝트의 기본 및 소스 기반 o 대부분의 제네릭 작업을 수행하여 어려운 부분을 수행 한 Matt Quail에게 감사드립니다. 버전 1.22.1 (2004 년 7 월 28 일) Java 1.5 언어 지원에 대한 버그 / 누락 수정 o classOrInterface의 트리 구조 버그 수정 -이를 발견 한 Pieter Vangorpto에게 감사드립니다. o SR 및 BSR 토큰을 잘못 처리하면 유형 매개 변수가 유형 인수로 인식되는 버그가 수정되었습니다. o 생성자에 대한 유형 매개 변수, 열거 상수 및 패키지 정의에 대한 주석 o if ((char.class.equals (c))) {}-Cenqua 버전 1.22.2에서 Matt Quail의 솔루션 (2004 년 7 월 28 일) Java 1.5 언어 지원에 대한 약간의 리팩토링 o 원래 리터럴 &quot;for&quot;리터럴이되도록 리팩토링 for / &quot;foreach&quot;프로덕션 여전히 사용되지만 for 하위 절은 토큰 유형에 따라 다릅니다. o 유형 매개 변수가 AST 버전 1.22.3 (2004 년 8 월 26 일)의 제네릭 생성자 분기에 포함되지 않은 버그 수정 Michael Stahl이 식별 한 버그 수정; 탭 / 공백 정리 및 기타 리팩토링 o identPrimary 및 newStatement에서 유형 매개 변수 누락 수정 o GT 조정 코드를 단순한 의미 조건 자로 대체 o Michael Stahl의 java15 문법에서 지원하는 열거 형 / assert 키워드 검사 지원 o 리팩터링 된 typeDefinition 제작 및 중복을 줄이기위한 필드 제작 버전 1.22.4 (10 월 21 일2004) 작은 bux 수정 o explicitConstructorInvocation에 typeArguments 추가, 예 : new</target>
        </trans-unit>
        <trans-unit id="48a1454ddc5de44915d242d03aefb2a12bcfe0fe" translate="yes" xml:space="preserve">
          <source>Terence Parr parrt@magelang.com John Lilley jlilley@empathy.com Scott Stanchfield thetick@magelang.com Markus Mohnen mohnen@informatik.rwth-aachen.de Peter Williams pete.williams@sun.com Allan Jacobs Allan.Jacobs@eng.sun.com Steve Messick messick@redhills.com John Pybus john@pybus.org Version 1.00 December 9, 1997 -- initial release Version 1.01 December 10, 1997 fixed bug in octal def (0..7 not 0..8) Version 1.10 August 1998 (parrt) added tree construction fixed definition of WS,comments for mac,pc,unix newlines added unary plus Version 1.11 (Nov 20, 1998) Added &quot;shutup&quot; option to turn off last ambig warning. Fixed inner class def to allow named class defs as statements synchronized requires compound not simple statement add [] after builtInType DOT class in primaryExpression &quot;const&quot; is reserved but not valid..removed from modifiers Version 1.12 (Feb 2, 1999) Changed LITERAL_xxx to xxx in tree grammar. Updated java.g to use tokens {...} now for 2.6.0 (new feature). Version 1.13 (Apr 23, 1999) Didn't have (stat)? for else clause in tree parser. Didn't gen ASTs for interface extends. Updated tree parser too. Updated to 2.6.0. Version 1.14 (Jun 20, 1999) Allowed final/abstract on local classes. Removed local interfaces from methods Put instanceof precedence where it belongs...in relationalExpr It also had expr not type as arg; fixed it. Missing ! on SEMI in classBlock fixed: (expr) + &quot;string&quot; was parsed incorrectly (+ as unary plus). fixed: didn't like Object[].class in parser or tree parser Version 1.15 (Jun 26, 1999) Screwed up rule with instanceof in it. :( Fixed. Tree parser didn't like (expr).something; fixed. Allowed multiple inheritance in tree grammar. oops. Version 1.16 (August 22, 1999) Extending an interface built a wacky tree: had extra EXTENDS. Tree grammar didn't allow multiple superinterfaces. Tree grammar didn't allow empty var initializer: {} Version 1.17 (October 12, 1999) ESC lexer rule allowed 399 max not 377 max. java.tree.g didn't handle the expression of synchronized statements. Version 1.18 (August 12, 2001) Terence updated to Java 2 Version 1.3 by observing/combining work of Allan Jacobs and Steve Messick. Handles 1.3 src. Summary: o primary didn't include boolean.class kind of thing o constructor calls parsed explicitly now: see explicitConstructorInvocation o add strictfp modifier o missing objBlock after new expression in tree grammar o merged local class definition alternatives, moved after declaration o fixed problem with ClassName.super.field o reordered some alternatives to make things more efficient o long and double constants were not differentiated from int/float o whitespace rule was inefficient: matched only one char o add an examples directory with some nasty 1.3 cases o made Main.java use buffered IO and a Reader for Unicode support o supports UNICODE? Using Unicode charVocabulay makes code file big, but only in the bitsets at the end. I need to make ANTLR generate unicode bitsets more efficiently. Version 1.19 (April 25, 2002) Terence added in nice fixes by John Pybus concerning floating constants and problems with super() calls. John did a nice reorg of the primary/postfix expression stuff to read better and makes f.g.super() parse properly (it was METHOD_CALL not a SUPER_CTOR_CALL). Also: o &quot;finally&quot; clause was a root...made it a child of &quot;try&quot; o Added stuff for asserts too for Java 1.4, but *commented out* as it is not backward compatible. Version 1.20 (October 27, 2002) Terence ended up reorging John Pybus' stuff to remove some nondeterminisms and some syntactic predicates. Note that the grammar is stricter now; e.g., this(...) must be the first statement. Ternary ?: operator wasn't working as array name: (isBig ? bigDigits : digits)[i]; Checked parser/tree parser on source for Resin-2.0.5, jive-2.1.1, jdk 1.3.1, Lucene, antlr 2.7.2a4, and the 110k-line jGuru server source. Version 1.21 (October 17, 2003) Fixed lots of problems including: Ray Waldin: add typeDefinition to interfaceBlock in java.tree.g He found a problem/fix with floating point that start with 0 Ray also fixed problem that (int.class) was not recognized. Thorsten van Ellen noticed that \n are allowed incorrectly in strings. TJP fixed CHAR_LITERAL analogously. Version 1.21.2 (March, 2003) Changes by Matt Quail to support generics (as per JDK1.5/JSR14) Notes: o We only allow the &quot;extends&quot; keyword and not the &quot;implements&quot; keyword, since that's what JSR14 seems to imply. o Thanks to Monty Zukowski for his help on the antlr-interest mail list. o Thanks to Alan Eliasen for testing the grammar over his Fink source base Version 1.22 (July, 2004) Changes by Michael Studman to support Java 1.5 language extensions Notes: o Added support for annotations types o Finished off Matt Quail's generics enhancements to support bound type arguments o Added support for new for statement syntax o Added support for static import syntax o Added support for enum types o Tested against JDK 1.5 source base and source base of jdigraph project o Thanks to Matt Quail for doing the hard part by doing most of the generics work Version 1.22.1 (July 28, 2004) Bug/omission fixes for Java 1.5 language support o Fixed tree structure bug with classOrInterface - thanks to Pieter Vangorpto for spotting this o Fixed bug where incorrect handling of SR and BSR tokens would cause type parameters to be recognised as type arguments. o Enabled type parameters on constructors, annotations on enum constants and package definitions o Fixed problems when parsing if ((char.class.equals(c))) {} - solution by Matt Quail at Cenqua Version 1.22.2 (July 28, 2004) Slight refactoring of Java 1.5 language support o Refactored for/&quot;foreach&quot; productions so that original literal &quot;for&quot; literal is still used but the for sub-clauses vary by token type o Fixed bug where type parameter was not included in generic constructor's branch of AST Version 1.22.3 (August 26, 2004) Bug fixes as identified by Michael Stahl; clean up of tabs/spaces and other refactorings o Fixed typeParameters omission in identPrimary and newStatement o Replaced GT reconciliation code with simple semantic predicate o Adapted enum/assert keyword checking support from Michael Stahl's java15 grammar o Refactored typeDefinition production and field productions to reduce duplication Version 1.22.4 (October 21, 2004) Small bux fixes o Added typeArguments to explicitConstructorInvocation, e.g. new</source>
          <target state="translated">Terence Parr parrt@magelang.com John Lilley jlilley@empathy.com Scott Stanchfield thetick@magelang.com Markus Mohnen mohnen@informatik.rwth-aachen.de Peter Williams pete.williams@sun.com Allan Jacobs Allan.Jacobs@eng.sun .com Steve Messick messick@redhills.com John Pybus john@pybus.org 버전 1.00 1997 년 12 월 9 일-최초 릴리스 버전 1.01 1997 년 12 월 10 일 8 진 정의 (0..7이 아닌 0..7) 버전 1.10의 버그 수정 1998 년 8 월 (parrt)은 WS의 트리 구성 고정 정의, mac, pc, unix 줄 바꿈 추가 단항 및 버전 1.11 추가 (1998 년 11 월 20 일) 마지막 모호 경고를 끄는 &quot;종료&quot;옵션을 추가했습니다. primaryExpression &quot;const&quot;의 builtInType DOT 클래스가 예약되었지만 유효하지 않은 후 구문이 동기화되지 않은 복합 명령문 add []가 필요하므로 명명 된 클래스 정의를 허용하도록 내부 클래스 정의를 수정했습니다.수정 자 버전 1.12에서 제거됨 (1999 년 2 월 2 일) 트리 문법에서 LITERAL_xxx를 xxx로 변경했습니다. 2.6.0에 대해 {...} 토큰을 사용하도록 java.g가 업데이트되었습니다 (새 기능). 버전 1.13 (1999 년 4 월 23 일) (통계)가 없습니까? 트리 파서의 else 절. 인터페이스 확장을 위해 AST를 생성하지 않았습니다. 트리 파서도 업데이트되었습니다. 2.6.0으로 업데이트되었습니다. 버전 1.14 (1999 년 6 월 20 일) 로컬 클래스에 대한 최종 / 초록 허용. 메서드에서 로컬 인터페이스를 제거했습니다. instanceof 우선 순위를 해당 위치에 둡니다 ... in relationalExpr 또한 expr 형식이 arg 형식이 아닙니다. 고쳤다. 잃어버린 ! classBlock의 SEMI에서 수정 됨 : (expr) + &quot;string&quot;이 잘못 구문 분석되었습니다 (+는 단항 더하기). 수정 됨 : 파서 ​​또는 트리 파서 버전 1.15 (1999 년 6 월 26 일)의 Object []. class가 마음에 들지 않았습니다. instanceof가 포함 된 규칙이 잘못되었습니다. :( 수정 됨. 트리 파서는 (expr) .something; 수정 됨.트리 문법에서 다중 상속을 허용했습니다. 죄송합니다. 버전 1.16 (1999 년 8 월 22 일) 인터페이스 확장은 별난 트리를 구축했습니다. 추가 EXTENDS가 있습니다. 트리 문법은 여러 수퍼 인터페이스를 허용하지 않았습니다. 트리 문법은 빈 var 이니셜 라이저를 허용하지 않았습니다. {} 버전 1.17 (1999 년 10 월 12 일) ESC 렉서 규칙은 최대 377 개가 아닌 399 개를 허용했습니다. java.tree.g는 동기화 된 명령문의 표현을 처리하지 않았습니다. 버전 1.18 (2001 년 8 월 12 일) Terence는 Allan Jacobs와 Steve Messick의 작업을 관찰 / 결합하여 Java 2 버전 1.3으로 업데이트했습니다. 1.3 src를 처리합니다. 요약 : o primary에는 boolean.class 종류가 포함되지 않았습니다. o 생성자 호출이 지금 명시 적으로 구문 분석되었습니다. explicitConstructorInvocation을 참조하세요. o strictfp 수정자를 추가합니다. o 트리 문법에서 새로운 표현식 뒤에 objBlock이 누락되었습니다. o 병합 된 로컬 클래스 정의 대안,선언 후 이동 o ClassName.super.field로 문제 수정 o 일을 더 효율적으로 만들기 위해 일부 대안을 재정렬 o long 및 double 상수가 int / float와 구별되지 않음 o 공백 규칙이 비효율적 임 : 하나의 문자 만 일치 o 일부와 예제 디렉토리 추가 불쾌한 1.3 케이스 o Main.java가 버퍼링 된 IO를 사용하고 유니 코드 지원을위한 리더 o 유니 코드를 지원합니까? 유니 코드 charVocabulay를 사용하면 코드 파일이 커지지 만 끝에는 비트 셋 만 있습니다. ANTLR이 유니 코드 비트 셋을보다 효율적으로 생성하도록해야합니다. 버전 1.19 (2002 년 4 월 25 일) Terence는 부동 상수 및 super () 호출 문제에 관한 John Pybus의 멋진 수정 사항에 추가되었습니다. John은 더 잘 읽을 수 있도록 primary / postfix 표현식의 멋진 재구성을 수행하고 fgsuper ()를 올바르게 구문 분석합니다 (SUPER_CTOR_CALL이 아닌 METHOD_CALL이었습니다). 또한 : o &quot;finally &quot;절은 루트였습니다 ...&quot;try &quot;의 자식으로 만들었습니다. o Java 1.4에서도 어설 션에 대한 내용을 추가했지만 이전 버전과 호환되지 않기 때문에 * 주석 처리 *되었습니다. 버전 1.20 (2002 년 10 월 27 일) Terence가 종료되었습니다. 일부 비결정론과 일부 구문 술어를 제거하기 위해 John Pybus의 항목을 재구성합니다. 이제 문법이 더 엄격 해졌습니다. 예를 들어 this (...)가 첫 번째 명령문이어야합니다. 삼항? : 연산자가 배열 이름으로 작동하지 않았습니다. (isBig ? bigDigits : numbers) [i]; Resin-2.0.5, jive-2.1.1, jdk 1.3.1, Lucene, antlr 2.7.2a4 및 110k-line jGuru 서버 소스의 소스에서 파서 / 트리 파서를 확인했습니다. 버전 1.21 (2003 년 10 월 17 일) 다음을 포함한 많은 문제를 수정했습니다. Ray Waldin : java.tree.g의 interfaceBlock에 typeDefinition을 추가합니다. 0으로 시작하는 부동 소수점 문제를 발견했습니다. Ray도 문제를 수정했습니다.클래스)가 인식되지 않았습니다. Thorsten van Ellen은 \ n이 문자열에서 잘못 허용된다는 것을 알아 차 렸습니다. TJP는 CHAR_LITERAL을 비슷하게 고정했습니다. 버전 1.21.2 (2003 년 3 월) 제네릭을 지원하기위한 Matt Quail의 변경 사항 (JDK1.5 / JSR14에 따름) 참고 : o JSR14는 &quot;implements&quot;키워드가 아닌 &quot;extends&quot;키워드 만 허용합니다. 암시합니다. o antlr-interest 메일 목록에 도움을 주신 Monty Zukowski에게 감사드립니다. o Fink 소스 기반 버전 1.22 (2004 년 7 월)에 대한 문법을 ​​테스트 해준 Alan Eliasen에게 감사드립니다. Michael Studman이 Java 1.5 언어 확장을 지원하도록 변경 참고 : o 주석 유형에 대한 지원 추가 o Matt Quail 종료s 바인딩 된 유형 인수를 지원하기위한 제네릭 향상 o 새로운 for 문 구문에 대한 지원 추가 o 정적 가져 오기 구문에 대한 지원 추가 o 열거 형 유형에 대한 지원 추가 o jdigraph 프로젝트의 JDK 1.5 소스 기반 및 소스 기반에 대해 테스트 됨 o 다음을 수행 한 Matt Quail에게 감사드립니다. 대부분의 제네릭 작업을 수행하여 어려운 부분 버전 1.22.1 (2004 년 7 월 28 일) Java 1.5 언어 지원에 대한 버그 / 누락 수정 o classOrInterface의 트리 구조 버그 수정-이 문제를 발견 한 Pieter Vangorpto 덕분에 o 잘못된 처리가 발생한 버그 수정 SR 및 BSR 토큰은 유형 매개 변수가 유형 인수로 인식되도록합니다. o 생성자에 대한 유형 매개 변수 활성화, 열거 상수 및 패키지 정의에 대한 주석 o if 구문 분석시 문제 수정 ((char.class.equals (c))) {}-Cenqua 버전 1.22.2에서 Matt Quail의 솔루션 (7 월 28 일,2004) Java 1.5 언어 지원에 대한 약간의 리팩토링 o 원래 리터럴 &quot;for&quot;리터럴이 계속 사용되도록 리팩토링 된 for / &quot;foreach&quot;프로덕션이지만 for 하위 절은 토큰 유형에 따라 다릅니다. o 유형 매개 변수가 일반 생성자에 포함되지 않은 버그 수정 AST 버전 1.22.3의 분기 (2004 년 8 월 26 일) Michael Stahl이 확인한 버그 수정; 탭 / 공백 정리 및 기타 리팩토링 o identPrimary 및 newStatement에서 고정 된 typeParameters 누락 o GT 조정 코드를 간단한 의미 론적 술어로 대체 o Michael Stahl의 java15 문법에서 지원하는 enum / assert 키워드 검사 지원 o 리팩터링 된 typeDefinition 프로덕션 및 중복을 줄이기위한 필드 프로덕션 버전 1.22.4 (2004 년 10 월 21 일) 소규모 bux 수정 o explicitConstructorInvocation에 typeArguments 추가, 예 : new5 개 언어 지원 o 원래 리터럴 &quot;for&quot;리터럴이 계속 사용되도록 리팩터링 된 for / &quot;foreach&quot;프로덕션. for 하위 절은 토큰 유형에 따라 다릅니다. o 유형 매개 변수가 AST 버전 1.22의 제네릭 생성자 분기에 포함되지 않은 버그 수정. 3 (2004 년 8 월 26 일) Michael Stahl이 확인한 버그 수정; 탭 / 공백 정리 및 기타 리팩토링 o identPrimary 및 newStatement에서 고정 된 typeParameters 누락 o GT 조정 코드를 간단한 의미 론적 술어로 대체 o Michael Stahl의 java15 문법에서 지원하는 enum / assert 키워드 검사 지원 o 리팩터링 된 typeDefinition 프로덕션 및 중복을 줄이기위한 필드 프로덕션 버전 1.22.4 (2004 년 10 월 21 일) 소규모 bux 수정 o explicitConstructorInvocation에 typeArguments 추가, 예 : new5 개 언어 지원 o 원래 리터럴 &quot;for&quot;리터럴이 계속 사용되도록 리팩터링 된 for / &quot;foreach&quot;프로덕션. for 하위 절은 토큰 유형에 따라 다릅니다. o 유형 매개 변수가 AST 버전 1.22의 제네릭 생성자 분기에 포함되지 않은 버그 수정. 3 (2004 년 8 월 26 일) Michael Stahl이 확인한 버그 수정; 탭 / 공백 정리 및 기타 리팩토링 o identPrimary 및 newStatement에서 고정 된 typeParameters 누락 o GT 조정 코드를 간단한 의미 론적 술어로 대체 o Michael Stahl의 java15 문법에서 지원하는 enum / assert 키워드 검사 지원 o 리팩터링 된 typeDefinition 프로덕션 및 중복을 줄이기위한 필드 프로덕션 버전 1.22.4 (2004 년 10 월 21 일) 소규모 bux 수정 o explicitConstructorInvocation에 typeArguments 추가, 예 : new원본 리터럴 &quot;for&quot;리터럴이 계속 사용되지만 for 하위 절은 토큰 유형에 따라 다릅니다. o 유형 매개 변수가 AST 버전 1.22.3 (2004 년 8 월 26 일)의 제네릭 생성자 분기에 포함되지 않은 버그 수정 Michael Stahl에 의해 확인 됨; 탭 / 공백 정리 및 기타 리팩토링 o identPrimary 및 newStatement에서 고정 된 typeParameters 누락 o GT 조정 코드를 간단한 의미 론적 술어로 대체 o Michael Stahl의 java15 문법에서 지원하는 enum / assert 키워드 검사 지원 o 리팩터링 된 typeDefinition 프로덕션 및 중복을 줄이기위한 필드 프로덕션 버전 1.22.4 (2004 년 10 월 21 일) 소규모 bux 수정 o explicitConstructorInvocation에 typeArguments 추가, 예 : new원본 리터럴 &quot;for&quot;리터럴이 계속 사용되지만 for 하위 절은 토큰 유형에 따라 다릅니다. o 유형 매개 변수가 AST 버전 1.22.3 (2004 년 8 월 26 일)의 제네릭 생성자 분기에 포함되지 않은 버그 수정 Michael Stahl에 의해 확인 됨; 탭 / 공백 정리 및 기타 리팩토링 o identPrimary 및 newStatement에서 고정 된 typeParameters 누락 o GT 조정 코드를 간단한 의미 론적 술어로 대체 o Michael Stahl의 java15 문법에서 지원하는 enum / assert 키워드 검사 지원 o 리팩터링 된 typeDefinition 프로덕션 및 중복을 줄이기위한 필드 프로덕션 버전 1.22.4 (2004 년 10 월 21 일) 소규모 bux 수정 o explicitConstructorInvocation에 typeArguments 추가, 예 : new리터럴은 여전히 ​​사용되지만 for 하위 절은 토큰 유형에 따라 다릅니다. o 유형 매개 변수가 AST 버전 1.22.3 (2004 년 8 월 26 일)의 제네릭 생성자 분기에 포함되지 않은 버그 수정 Michael Stahl이 식별 한 버그 수정; 탭 / 공백 정리 및 기타 리팩토링 o identPrimary 및 newStatement에서 고정 된 typeParameters 누락 o GT 조정 코드를 간단한 의미 론적 술어로 대체 o Michael Stahl의 java15 문법에서 지원하는 enum / assert 키워드 검사 지원 o 리팩터링 된 typeDefinition 프로덕션 및 중복을 줄이기위한 필드 프로덕션 버전 1.22.4 (2004 년 10 월 21 일) 소규모 bux 수정 o explicitConstructorInvocation에 typeArguments 추가, 예 : new리터럴은 여전히 ​​사용되지만 for 하위 절은 토큰 유형에 따라 다릅니다. o 유형 매개 변수가 AST 버전 1.22.3 (2004 년 8 월 26 일)의 제네릭 생성자 분기에 포함되지 않은 버그 수정 Michael Stahl이 식별 한 버그 수정; 탭 / 공백 정리 및 기타 리팩토링 o identPrimary 및 newStatement에서 고정 된 typeParameters 누락 o GT 조정 코드를 간단한 의미 론적 술어로 대체 o Michael Stahl의 java15 문법에서 지원하는 enum / assert 키워드 검사 지원 o 리팩터링 된 typeDefinition 프로덕션 및 중복을 줄이기위한 필드 프로덕션 버전 1.22.4 (2004 년 10 월 21 일) 소규모 bux 수정 o explicitConstructorInvocation에 typeArguments 추가, 예 : new2004) Michael Stahl이 식별 한 버그 수정; 탭 / 공백 정리 및 기타 리팩토링 o identPrimary 및 newStatement에서 고정 된 typeParameters 누락 o GT 조정 코드를 간단한 의미 론적 술어로 대체 o Michael Stahl의 java15 문법에서 지원하는 enum / assert 키워드 검사 지원 o 리팩터링 된 typeDefinition 프로덕션 및 중복을 줄이기위한 필드 프로덕션 버전 1.22.4 (2004 년 10 월 21 일) 소규모 bux 수정 o explicitConstructorInvocation에 typeArguments 추가, 예 : new2004) Michael Stahl이 식별 한 버그 수정; 탭 / 공백 정리 및 기타 리팩토링 o identPrimary 및 newStatement에서 고정 된 typeParameters 누락 o GT 조정 코드를 간단한 의미 론적 술어로 대체 o Michael Stahl의 java15 문법에서 지원하는 enum / assert 키워드 검사 지원 o 리팩터링 된 typeDefinition 프로덕션 및 중복을 줄이기위한 필드 프로덕션 버전 1.22.4 (2004 년 10 월 21 일) 소규모 bux 수정 o explicitConstructorInvocation에 typeArguments 추가, 예 : news java15 문법 o 중복을 줄이기 위해 리팩토링 된 typeDefinition 프로덕션 및 필드 프로덕션 버전 1.22.4 (2004 년 10 월 21 일) 소규모 bux 수정 o explicitConstructorInvocation에 typeArguments 추가, 예 : news java15 문법 o 중복을 줄이기 위해 리팩토링 된 typeDefinition 프로덕션 및 필드 프로덕션 버전 1.22.4 (2004 년 10 월 21 일) 소규모 bux 수정 o explicitConstructorInvocation에 typeArguments 추가, 예 : new</target>
        </trans-unit>
        <trans-unit id="640ab2bae07bedc4c163f679a746f7ab7fb5d1fa" translate="yes" xml:space="preserve">
          <source>Test</source>
          <target state="translated">Test</target>
        </trans-unit>
        <trans-unit id="22d23f24cd32f09242a53db536a945808560295a" translate="yes" xml:space="preserve">
          <source>Test if a method call is recursive if called within a given method node. Handles static calls as well. Currently known simplifications:</source>
          <target state="translated">주어진 메서드 노드 내에서 호출되는 경우 메서드 호출이 재귀 적인지 테스트합니다. 정적 호출도 처리합니다. 현재 알려진 단순화 :</target>
        </trans-unit>
        <trans-unit id="8ceac294319c34b3b08934255a2a46a704ab7aeb" translate="yes" xml:space="preserve">
          <source>Test to determine if a ClassNode is a primitive type.</source>
          <target state="translated">ClassNode가 기본 유형인지 확인하기 위해 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="9403cb8e3b09787aa434a66b33f9f48728feb7eb" translate="yes" xml:space="preserve">
          <source>Test to determine if a ClassNode is a primitive type. Note: this only works for ClassNodes created using a predefined ClassNode</source>
          <target state="translated">ClassNode가 기본 유형인지 확인하기 위해 테스트합니다. 참고 : 이는 사전 정의 된 ClassNode를 사용하여 생성 된 ClassNode에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="efcab8f5a7c0064e3a92f17428182ce215e6823b" translate="yes" xml:space="preserve">
          <source>Test to determine if a ClassNode is a type belongs to the list of types which are allowed to initialize constants directly in bytecode instead of using &amp;lt;cinit&amp;gt;</source>
          <target state="translated">ClassNode가 유형인지 테스트하여 &amp;lt;cinit&amp;gt;를 사용하는 대신 바이트 코드에서 직접 상수를 초기화 할 수있는 유형 목록에 속하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="317d6297ac6952a296eb2ddc257fdae5db4c3acc" translate="yes" xml:space="preserve">
          <source>Tests given value against specified type and changes generics of result.</source>
          <target state="translated">지정된 유형에 대해 주어진 값을 테스트하고 결과의 제네릭을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="063eb35b9befe3464dd713e416056ece4259e856" translate="yes" xml:space="preserve">
          <source>Tests given value against specified type and changes generics of result. This is equivalent to: &lt;code&gt;self.filter(it -&amp;gt; it instanceof Type).map(it -&amp;gt; (Type) it)&lt;/code&gt;</source>
          <target state="translated">지정된 유형에 대해 주어진 값을 테스트하고 결과의 제네릭을 변경합니다. 이것은 다음과 같습니다 : &lt;code&gt;self.filter(it -&amp;gt; it instanceof Type).map(it -&amp;gt; (Type) it)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="297a33c2b3cbe7da16caded2f3d349714f069bd6" translate="yes" xml:space="preserve">
          <source>Tests if a node is an inner class node, and if it is, then checks if the enclosing method is skipped.</source>
          <target state="translated">노드가 내부 클래스 노드인지 테스트하고, 해당 노드인지 확인한 다음 둘러싸는 메서드를 건너 뛰는 지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="328ba89482a1987881d000e13d7f357f23c9b1d6" translate="yes" xml:space="preserve">
          <source>Tests if groovydoc is present</source>
          <target state="translated">groovydoc이 있는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="5fb815736873e34454c94811223e0a4810394010" translate="yes" xml:space="preserve">
          <source>Tests if some key maps into the specified value in this table.</source>
          <target state="translated">일부 키가이 테이블의 지정된 값에 매핑되는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="add0ba96e90c01761791705826395fed0f349dba" translate="yes" xml:space="preserve">
          <source>Tests if some key maps into the specified value in this table. This operation is more expensive than the &lt;code&gt;containsKey&lt;/code&gt; method.</source>
          <target state="translated">일부 키가이 테이블의 지정된 값에 매핑되는지 테스트합니다. 이 작업은 &lt;code&gt;containsKey&lt;/code&gt; 메서드 보다 더 비쌉니다 .</target>
        </trans-unit>
        <trans-unit id="1e5b79dd75c69804ac69d0b591a74c9eee88301c" translate="yes" xml:space="preserve">
          <source>Tests if the specified object is a key in this table.</source>
          <target state="translated">지정된 개체가이 테이블의 키인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="5a3838caffb4fd461c7b1a0ac5808c7ae0ee8b59" translate="yes" xml:space="preserve">
          <source>Tests if this CharSequence ends with any specified suffixes.</source>
          <target state="translated">이 CharSequence가 지정된 접미사로 끝나는 지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="dea9b3965b823036214967b36b37dd1a8b716789" translate="yes" xml:space="preserve">
          <source>Tests if this CharSequence is blank.</source>
          <target state="translated">이 CharSequence가 비어 있는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="49212f1b5b77fc1ba50dd42e242f061373833989" translate="yes" xml:space="preserve">
          <source>Tests if this CharSequence starts with any specified prefixes.</source>
          <target state="translated">이 CharSequence가 지정된 접두사로 시작하는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="86c27bae4e49a7c791a1aae1f78c196c87814064" translate="yes" xml:space="preserve">
          <source>Tests if this QName matches another object.</source>
          <target state="translated">이 QName이 다른 개체와 일치하는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="0ac416154eaf4d481cc125feddea58871c1256c2" translate="yes" xml:space="preserve">
          <source>Tests this QName for equality with another object.</source>
          <target state="translated">이 QName이 다른 개체와 같은지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="a9cf2cef79fdf0aa5b76a94b1b479b909d61f565" translate="yes" xml:space="preserve">
          <source>Tests whether the provided class implements MBean.</source>
          <target state="translated">제공된 클래스가 MBean을 구현하는지 여부를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="5c0a04fe736541754976f6a02d03fdc39f9ee64b" translate="yes" xml:space="preserve">
          <source>Tests whether the provided class implements MBean. It uses the following runes</source>
          <target state="translated">제공된 클래스가 MBean을 구현하는지 여부를 테스트합니다. 다음 룬을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="04001d250c417c421d5d967c360fc90b35f68b2e" translate="yes" xml:space="preserve">
          <source>Text processing helpers for the interactive command line terminal.</source>
          <target state="translated">대화 형 명령 줄 터미널에 대한 텍스트 처리 도우미입니다.</target>
        </trans-unit>
        <trans-unit id="bb34f30402043e44ae32896d840ce387a4b09777" translate="yes" xml:space="preserve">
          <source>That will produce the following output:</source>
          <target state="translated">그러면 다음과 같은 출력이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="ff58e4d37ea3d39dfbb57350dad837205a5b260f" translate="yes" xml:space="preserve">
          <source>The &quot;Ruby-style&quot; new conversions occur automatically unless the 'auto=false' flag is given when using the annotation. You might do this if you create a new method using meta programming.</source>
          <target state="translated">주석을 사용할 때 'auto = false'플래그가 지정되지 않으면 &quot;Ruby 스타일&quot;새 변환이 자동으로 발생합니다. 메타 프로그래밍을 사용하여 새 메서드를 만드는 경우이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abaf21fddf45033ab2c9f43f7104088d40814a57" translate="yes" xml:space="preserve">
          <source>The &quot;load&quot; command will add the given file or path to the classpath in this configuration object. If the path does not exist, the path will be ignored.</source>
          <target state="translated">&quot;load&quot;명령은이 구성 개체의 클래스 경로에 지정된 파일 또는 경로를 추가합니다. 경로가 존재하지 않으면 경로가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c60ab597093e621854305c3505f5719eaec2ffc7" translate="yes" xml:space="preserve">
          <source>The &quot;main is&quot; part may only be once in the file. The String afterwards is the name of a class with a main method.</source>
          <target state="translated">&quot;주요&quot;부분은 파일에서 한 번만 가능합니다. 이후의 문자열은 기본 메서드가있는 클래스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="12e2ad9f4f40932144714a1460d03531ba22986d" translate="yes" xml:space="preserve">
          <source>The &quot;str&quot; variable is closure shared.</source>
          <target state="translated">&quot;str&quot;변수는 클로저 공유입니다.</target>
        </trans-unit>
        <trans-unit id="c847cbc1e1b5981b8a03d4b15cf1bf15d40091e2" translate="yes" xml:space="preserve">
          <source>The &quot;str&quot; variable is closure shared. The variable expression inside the closure references an accessed variable &quot;str&quot; which must have the closure shared flag set.</source>
          <target state="translated">&quot;str&quot;변수는 클로저 공유입니다. 클로저 내부의 변수 표현식은 클로저 공유 플래그 세트가 있어야하는 액세스 된 변수 &quot;str&quot;을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="39940fc40491b10b14c8b07773b7fb0c04450a6e" translate="yes" xml:space="preserve">
          <source>The &quot;~&quot; character can be used to represent the user's home directory. It cannot fully complete to other users' homes in all operating systems, since java does not provide any way of determining that easily, but it will attempt a simplistic approach.</source>
          <target state="translated">&quot;~&quot;문자는 사용자의 홈 디렉토리를 나타내는 데 사용할 수 있습니다. Java는 쉽게 결정할 수있는 방법을 제공하지 않기 때문에 모든 운영 체제에서 다른 사용자의 집을 완전히 완성 할 수는 없지만 단순한 접근 방식을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="a052786f73a4f92e76bad5f0c863ba3cd193790a" translate="yes" xml:space="preserve">
          <source>The 'alias' command.</source>
          <target state="translated">'별칭'명령.</target>
        </trans-unit>
        <trans-unit id="40024a2623baca4354e986fca884b143a6cc6c9f" translate="yes" xml:space="preserve">
          <source>The 'clear' command.</source>
          <target state="translated">'clear'명령.</target>
        </trans-unit>
        <trans-unit id="3b1cbc87993f31ce6273cefc6205a16b17b91a61" translate="yes" xml:space="preserve">
          <source>The 'display' command. Displays the current buffer (e.g. while method declaration was not finished).</source>
          <target state="translated">'display'명령. 현재 버퍼를 표시합니다 (예 : 메서드 선언이 완료되지 않은 동안).</target>
        </trans-unit>
        <trans-unit id="49f40f12151358c7d843d53687ed095e487a154e" translate="yes" xml:space="preserve">
          <source>The 'doc' command.</source>
          <target state="translated">'doc'명령.</target>
        </trans-unit>
        <trans-unit id="bc3ffba03d00f8c7b85d7091a061031e0b1eb2b0" translate="yes" xml:space="preserve">
          <source>The 'edit' command. Opens Editor to write into the current Buffer.</source>
          <target state="translated">'편집'명령. 현재 버퍼에 쓰기 위해 편집기를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="f3f7c1cec23633cc0cfaa9cb09f02911a1e9d149" translate="yes" xml:space="preserve">
          <source>The 'exit' command.</source>
          <target state="translated">'exit'명령.</target>
        </trans-unit>
        <trans-unit id="046ba041acd9691591b162277d1a0f7106c9bb51" translate="yes" xml:space="preserve">
          <source>The 'forClass' annotation attribute for the &lt;code&gt;@Builder&lt;/code&gt; transform isn't applicable for this strategy. The 'useSetters' annotation attribute for the &lt;code&gt;@Builder&lt;/code&gt; transform is ignored by this strategy which always uses setters.</source>
          <target state="translated">&lt;code&gt;@Builder&lt;/code&gt; 변환 의 'forClass'주석 속성 은이 전략에 적용 할 수 없습니다. &lt;code&gt;@Builder&lt;/code&gt; 변환 의 'useSetters'주석 속성은 항상 setter를 사용하는이 전략에서 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="45835faea7523426faaaf8fa1e49229a32a26b8c" translate="yes" xml:space="preserve">
          <source>The 'grab' command.</source>
          <target state="translated">'grab'명령.</target>
        </trans-unit>
        <trans-unit id="205fbf3975b12113a5c8bd8232bfa1665e8d1f5c" translate="yes" xml:space="preserve">
          <source>The 'help' command.</source>
          <target state="translated">'help'명령.</target>
        </trans-unit>
        <trans-unit id="20ec27c9e0ddbd2a48fb1d21fc610eca2f90fc72" translate="yes" xml:space="preserve">
          <source>The 'history' command.</source>
          <target state="translated">'히스토리'명령.</target>
        </trans-unit>
        <trans-unit id="2d489d33aa47e12f822416973b70f3e5da0b4497" translate="yes" xml:space="preserve">
          <source>The 'import' command.</source>
          <target state="translated">'가져 오기'명령.</target>
        </trans-unit>
        <trans-unit id="7e8ac89c1c05e64fcbd55e0b499745677ba943e0" translate="yes" xml:space="preserve">
          <source>The 'inspect' command.</source>
          <target state="translated">'검사'명령.</target>
        </trans-unit>
        <trans-unit id="551c33d159644a8f5ef1c6ac388343537009ae2b" translate="yes" xml:space="preserve">
          <source>The 'load' command.</source>
          <target state="translated">'로드'명령.</target>
        </trans-unit>
        <trans-unit id="b6bc21ba2f0a2893871757da3c856326ee9de094" translate="yes" xml:space="preserve">
          <source>The 'purge' command.</source>
          <target state="translated">'purge'명령.</target>
        </trans-unit>
        <trans-unit id="ba59fbb5346c40fbb6302c6187328e618a3da7ed" translate="yes" xml:space="preserve">
          <source>The 'record' command.</source>
          <target state="translated">'record'명령.</target>
        </trans-unit>
        <trans-unit id="7c3791604975b9d1fb30c9a2bd534192e00088a0" translate="yes" xml:space="preserve">
          <source>The 'register' command. Registers a class as a new groovysh command. Requires the command to have matching constructors (shell) or (shell, name, alias).</source>
          <target state="translated">'등록'명령. 새로운 groovysh 명령으로 클래스를 등록합니다. 명령에 일치하는 생성자 (셸) 또는 (셸, 이름, 별칭)이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e2c14b48e8d21dde57913f41162e2eb4486751ed" translate="yes" xml:space="preserve">
          <source>The 'save' command.</source>
          <target state="translated">'저장'명령.</target>
        </trans-unit>
        <trans-unit id="9a925ff93968b41e2b76e842b170f7ec6c6d9eb0" translate="yes" xml:space="preserve">
          <source>The 'set' command, used to set preferences.</source>
          <target state="translated">기본 설정을 지정하는 데 사용되는 'set'명령.</target>
        </trans-unit>
        <trans-unit id="f931e78f8e44eb712f74c86f1afb6c2a241148eb" translate="yes" xml:space="preserve">
          <source>The 'shadow' command.</source>
          <target state="translated">'그림자'명령.</target>
        </trans-unit>
        <trans-unit id="5a09c2bfc8378532d9a0032fb6ba7ae84db4fe0b" translate="yes" xml:space="preserve">
          <source>The 'show' command.</source>
          <target state="translated">'show'명령.</target>
        </trans-unit>
        <trans-unit id="a59faad4653d2f4a8eeb438184148004e01411e2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;closure#resolveStrategy&quot;&gt;Closure.resolveStrategy&lt;/a&gt; used by the closure.</source>
          <target state="translated">&lt;a href=&quot;closure#resolveStrategy&quot;&gt;Closure.resolveStrategy는&lt;/a&gt; 폐쇄에 의해 사용.</target>
        </trans-unit>
        <trans-unit id="4bb77833997045b8a169e0e940948f5de47f4a41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@AutoExternalize&lt;/code&gt; transform is implemented as a combination of the &lt;code&gt;@ExternalizeMethods&lt;/code&gt; and &lt;code&gt;@ExternalizeVerifier&lt;/code&gt; transforms.</source>
          <target state="translated">&lt;code&gt;@AutoExternalize&lt;/code&gt; 변환은의 조합으로서 구현된다 &lt;code&gt;@ExternalizeMethods&lt;/code&gt; 및 &lt;code&gt;@ExternalizeVerifier&lt;/code&gt; 변환한다.</target>
        </trans-unit>
        <trans-unit id="45203388f4746d69eda07f4e8e18ce996ab3c42d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@Builder&lt;/code&gt; AST transformation is used to help write classes that can be created using &lt;em&gt;fluent&lt;/em&gt; api calls. The transform supports multiple building strategies to cover a range of cases and there are a number of configuration options to customize the building process. In addition, a number of annotation attributes let you customise the building process. Not all annotation attributes are supported by all strategies. See the individual strategy documentation for more details. If you're an AST hacker, you can also define your own strategy class. The following strategies are bundled with Groovy:</source>
          <target state="translated">&lt;code&gt;@Builder&lt;/code&gt; AST 변환을 사용하여 만들 수 있습니다 도움을 쓰기 클래스에 사용되는 &lt;em&gt;유창&lt;/em&gt; API 호출을. 이 변환은 다양한 경우를 포괄하는 여러 건물 전략을 지원하며 건물 프로세스를 사용자 지정하기위한 여러 구성 옵션이 있습니다. 또한 여러 주석 속성을 사용하여 건물 프로세스를 사용자 정의 할 수 있습니다. 모든 전략에서 모든 주석 속성이 지원되는 것은 아닙니다. 자세한 내용은 개별 전략 문서를 참조하십시오. AST 해커라면 자신 만의 전략 클래스를 정의 할 수도 있습니다. 다음 전략은 Groovy와 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="294af73d6b365f57dad5fbc1d213db079ecf007c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@Canonical&lt;/code&gt; meta-annotation combines the &lt;code&gt;@EqualsAndHashCode&lt;/code&gt;, &lt;code&gt;@ToString&lt;/code&gt; and &lt;code&gt;@TupleConstructor&lt;/code&gt; annotations. It is used to assist in the creation of mutable classes. It instructs the compiler to execute AST transformations which add positional constructors, equals, hashCode and a pretty print toString to your class.</source>
          <target state="translated">&lt;code&gt;@Canonical&lt;/code&gt; 메타 주석이 결합 &lt;code&gt;@EqualsAndHashCode&lt;/code&gt; 을 , &lt;code&gt;@ToString&lt;/code&gt; 및 &lt;code&gt;@TupleConstructor&lt;/code&gt; 의 주석. 변경 가능한 클래스 생성을 지원하는 데 사용됩니다. 위치 생성자, equals, hashCode 및 예쁜 인쇄 toString을 클래스에 추가하는 AST 변환을 실행하도록 컴파일러에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="e0722e38b1652aaa50007eeaae20094f5d8fdb78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@EqualsAndHashCode&lt;/code&gt; annotation instructs the compiler to execute an AST transformation which adds the necessary equals and hashCode methods to the class.</source>
          <target state="translated">&lt;code&gt;@EqualsAndHashCode&lt;/code&gt; 의 주석은 클래스에 필요한 등호와 hashCode 방법 AST 추가하는 변환을 실행하도록 컴파일러에 지시한다.</target>
        </trans-unit>
        <trans-unit id="256900570749f03c52bd249de8a600a89e77be38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@Immutable&lt;/code&gt; meta-annotation corresponds to adding the following annotations: &lt;a href=&quot;tostring&quot;&gt;ToString&lt;/a&gt;, &lt;a href=&quot;equalsandhashcode&quot;&gt;EqualsAndHashCode&lt;/a&gt;, &lt;a href=&quot;immutablebase&quot;&gt;ImmutableBase&lt;/a&gt;, &lt;a href=&quot;immutableoptions&quot;&gt;ImmutableOptions&lt;/a&gt;, &lt;a href=&quot;propertyoptions&quot;&gt;PropertyOptions&lt;/a&gt;, &lt;a href=&quot;tupleconstructor&quot;&gt;TupleConstructor&lt;/a&gt;, &lt;a href=&quot;mapconstructor&quot;&gt;MapConstructor&lt;/a&gt; and &lt;a href=&quot;knownimmutable&quot;&gt;KnownImmutable&lt;/a&gt;. Together these annotations instruct the compiler to execute the necessary transformations to add the necessary getters, constructors, equals, hashCode and other helper methods that are typically written when creating immutable classes with the defined properties.</source>
          <target state="translated">&lt;code&gt;@Immutable&lt;/code&gt; : 다음과 같은 주석을 추가하는 메타 주석 대응 &lt;a href=&quot;tostring&quot;&gt;ToString&lt;/a&gt; , &lt;a href=&quot;equalsandhashcode&quot;&gt;EqualsAndHashCode&lt;/a&gt; , &lt;a href=&quot;immutablebase&quot;&gt;ImmutableBase&lt;/a&gt; , &lt;a href=&quot;immutableoptions&quot;&gt;ImmutableOptions&lt;/a&gt; , &lt;a href=&quot;propertyoptions&quot;&gt;PropertyOptions&lt;/a&gt; , &lt;a href=&quot;tupleconstructor&quot;&gt;TupleConstructor&lt;/a&gt; , &lt;a href=&quot;mapconstructor&quot;&gt;MapConstructor&lt;/a&gt; 및 &lt;a href=&quot;knownimmutable&quot;&gt;KnownImmutable을&lt;/a&gt; . 이러한 주석은 함께 컴파일러에게 필요한 getter, 생성자, equals, hashCode 및 정의 된 속성으로 불변 클래스를 만들 때 일반적으로 작성되는 기타 도우미 메서드를 추가하는 데 필요한 변환을 실행하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="9b3e01603be93f6ac5cc7246179a9d14cdfcb6f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@Immutable&lt;/code&gt; transformation in earlier versions of Groovy tried to be smart in the case of an immutable class with a single HashMap property, the supplied Map constructor tried to be compatible with both expected tuple behavior and expected named-argument behavior by peeking into the supplied map and guessing as to which approach might be applicable. Recent versions of Groovy now allow both &lt;code&gt;@TupleConstructor&lt;/code&gt; and &lt;code&gt;@MapConstructor&lt;/code&gt; annotations to co-exist which provide's a more flexible solution to this problem. While more flexible, the new approach isn't fully compatible with the previous approach. If for some reason you need the old behavior, you can try this property handler. Some features of the new approach won't be available to you.</source>
          <target state="translated">&lt;code&gt;@Immutable&lt;/code&gt; 그루비 이전 버전의 변환은 하나의 HashMap의 속성 불변 클래스의 경우 스마트려고 노력 제공된지도 생성자는 모두 예상 튜플 동작과 호환되도록 노력하고 공급에 엿에 의해 명명 된 인수의 행동을 예상 적용 가능한 접근 방식에 대한지도 및 추측. 최근 Groovy 버전에서는 &lt;code&gt;@TupleConstructor&lt;/code&gt; 및 &lt;code&gt;@MapConstructor&lt;/code&gt; 주석이 모두 공존 할 수 있으므로이 문제에 대한보다 유연한 솔루션을 제공합니다. 더 유연하지만 새로운 접근 방식은 이전 접근 방식과 완전히 호환되지 않습니다. 어떤 이유로 이전 동작이 필요한 경우이 속성 처리기를 시도 할 수 있습니다. 새로운 접근 방식의 일부 기능은 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8038db35abbd1b507d6ae9f58cbd615d327ce3a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@ImmutableBase&lt;/code&gt; annotation supports customization using &lt;code&gt;@PropertyOptions&lt;/code&gt; which allows a custom property handler to be defined. This is most typically used behind the scenes by the &lt;code&gt;@Immutable&lt;/code&gt; meta-annotation but you can also define your own handler. If a custom handler is present, it will determine the code generated for the getters and setters of any property.</source>
          <target state="translated">&lt;code&gt;@ImmutableBase&lt;/code&gt; 의 주석 지원을 사용하여 사용자 정의 &lt;code&gt;@PropertyOptions&lt;/code&gt; 사용자 지정 속성 핸들러가 정의 할 수 있습니다. 이것은 &lt;code&gt;@Immutable&lt;/code&gt; 메타 어노테이션 에서 가장 일반적으로 사용 되지만 자체 핸들러를 정의 할 수도 있습니다. 사용자 지정 처리기가있는 경우 모든 속성의 getter 및 setter에 대해 생성 된 코드를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="d660a9beb8629948ffda2454e012fd620ba319c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@MapConstructor&lt;/code&gt; annotation generates a public constructor unless an applicable &lt;a href=&quot;visibilityoptions&quot;&gt;VisibilityOptions&lt;/a&gt; annotation is also present. It can be useful to change the visibility if you want to also create a builder or provide your own static factory method for object creation. You can make the constructor private and access it from the builder or your factory method. (Note: you'll probably want to use &lt;code&gt;@CompileStatic&lt;/code&gt; in conjunction with such an approach since dynamic Groovy currently gives the ability to access even private constructors.)</source>
          <target state="translated">&lt;code&gt;@MapConstructor&lt;/code&gt; 의 적용 가능한하지 않는 주석 public 생성자를 생성 &lt;a href=&quot;visibilityoptions&quot;&gt;VisibilityOptions의&lt;/a&gt; 주석도 존재한다. 빌더를 생성하거나 객체 생성을위한 고유 한 정적 팩토리 메서드를 제공하려는 경우 가시성을 변경하는 것이 유용 할 수 있습니다. 생성자를 비공개로 만들고 빌더 또는 팩토리 메서드에서 액세스 할 수 있습니다. (참고 : 동적 Groovy는 현재 개인 생성자에도 액세스 할 수있는 기능을 제공하므로 이러한 접근 방식과 함께 &lt;code&gt;@CompileStatic&lt;/code&gt; 을 사용하고 싶을 것입니다 .)</target>
        </trans-unit>
        <trans-unit id="0c060668381620633145cbb9ddc60d4b01c27127" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@MapConstructor&lt;/code&gt; annotation instructs the compiler to execute an AST transformation which adds the necessary constructor method to your class.</source>
          <target state="translated">&lt;code&gt;@MapConstructor&lt;/code&gt; 의 주석은 클래스에 필요한 생성자 메서드를 추가하는 AST 변환을 실행하도록 컴파일러에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="5d30fb89bfdef972798dad631327fddec3510e19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@MapConstructor&lt;/code&gt; annotation supports customization using &lt;code&gt;@PropertyOptions&lt;/code&gt; which allows a custom property handler to be defined. This is most typically used behind the scenes by the &lt;code&gt;@Immutable&lt;/code&gt; meta-annotation but you can also define your own handler. If a custom handler is present, it will determine the code generated when initializing any property (or field).</source>
          <target state="translated">&lt;code&gt;@MapConstructor&lt;/code&gt; 의 주석 지원을 사용하여 사용자 정의 &lt;code&gt;@PropertyOptions&lt;/code&gt; 사용자 지정 속성 핸들러가 정의 할 수 있습니다. 이것은 &lt;code&gt;@Immutable&lt;/code&gt; 메타 어노테이션 에서 가장 일반적으로 사용 되지만 자체 핸들러를 정의 할 수도 있습니다. 사용자 지정 처리기가있는 경우 속성 (또는 필드)을 초기화 할 때 생성되는 코드를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="7a6deaa7aa228067bb49f0cfb27c83f7ba76b6ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@TupleConstructor&lt;/code&gt; annotation generates a public constructor unless an applicable &lt;a href=&quot;visibilityoptions&quot;&gt;VisibilityOptions&lt;/a&gt; annotation is also present. It can be useful to change the visibility if you want to also create a builder or provide your own static factory method for object creation. You can make the constructor private and access it from the builder or your factory method. (Note: you'll probably want to use &lt;code&gt;@CompileStatic&lt;/code&gt; in conjunction with such an approach since dynamic Groovy currently gives the ability to access even private constructors.)</source>
          <target state="translated">&lt;code&gt;@TupleConstructor&lt;/code&gt; 의 적용 가능한하지 않는 주석 public 생성자를 생성 &lt;a href=&quot;visibilityoptions&quot;&gt;VisibilityOptions의&lt;/a&gt; 주석도 존재한다. 빌더를 생성하거나 객체 생성을위한 고유 한 정적 팩토리 메서드를 제공하려는 경우 가시성을 변경하는 것이 유용 할 수 있습니다. 생성자를 비공개로 만들고 빌더 또는 팩토리 메서드에서 액세스 할 수 있습니다. (참고 : 동적 Groovy는 현재 개인 생성자에도 액세스 할 수있는 기능을 제공하므로 이러한 접근 방식과 함께 &lt;code&gt;@CompileStatic&lt;/code&gt; 을 사용하고 싶을 것입니다 .)</target>
        </trans-unit>
        <trans-unit id="7629884aa207cf4bfc51ba4ddfb30667cd6e46a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@TupleConstructor&lt;/code&gt; annotation instructs the compiler to execute an AST transformation which adds the necessary constructor method to your class.</source>
          <target state="translated">&lt;code&gt;@TupleConstructor&lt;/code&gt; 의 주석은 클래스에 필요한 생성자 메서드를 추가하는 AST 변환을 실행하도록 컴파일러에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="e8727009d134e37d65711ed260dc01f84627258d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@TupleConstructor&lt;/code&gt; annotation supports customization using &lt;code&gt;@PropertyOptions&lt;/code&gt; which allows a custom property handler to be defined. This is most typically used behind the scenes by the &lt;code&gt;@Immutable&lt;/code&gt; meta-annotation but you can also define your own handler. If a custom handler is present, it will determine the code generated when initializing any property (or field).</source>
          <target state="translated">&lt;code&gt;@TupleConstructor&lt;/code&gt; 의 주석 지원을 사용하여 사용자 정의 &lt;code&gt;@PropertyOptions&lt;/code&gt; 사용자 지정 속성 핸들러가 정의 할 수 있습니다. 이것은 &lt;code&gt;@Immutable&lt;/code&gt; 메타 어노테이션 에서 가장 일반적으로 사용 되지만 자체 핸들러를 정의 할 수도 있습니다. 사용자 지정 처리기가있는 경우 속성 (또는 필드)을 초기화 할 때 생성되는 코드를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="2c9da3c536494482e7240624f6308d8ee06c6f86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LineColumnReader&lt;/code&gt; is an extension to &lt;code&gt;BufferedReader&lt;/code&gt; that keeps track of the line and column information of where the cursor is.</source>
          <target state="translated">&lt;code&gt;LineColumnReader&lt;/code&gt; 는 에 대한 확장 &lt;code&gt;BufferedReader&lt;/code&gt; 커서가 어디에 라인 및 열 정보를 추적한다.</target>
        </trans-unit>
        <trans-unit id="b12d0acf730deb6bf7ba2f89201e89542b2f1843" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equals()&lt;/code&gt; method compares the values of the individual properties (and optionally fields) of the class. It can also optionally call equals on the super class. Two different equals method implementations are supported both of which support the equals contract outlined in the javadoc for &lt;code&gt;java.lang.Object&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;equals()&lt;/code&gt; 메소드는 클래스의 개별 속성 (및 선택적 필드)의 값을 비교한다. 또한 선택적으로 수퍼 클래스에서 equals를 호출 할 수도 있습니다. 두 개의 서로 다른 equals 메소드 구현이 지원되며 둘 다 &lt;code&gt;java.lang.Object&lt;/code&gt; 에 대한 javadoc에 설명 된 동등 계약을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="830e28331ecb056779521290049a9d298a9e660d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hashCode()&lt;/code&gt; method is calculated using Groovy's &lt;code&gt;HashCodeHelper&lt;/code&gt; class which implements an algorithm similar to the one outlined in the book &lt;em&gt;Effective Java&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;hashCode()&lt;/code&gt; 메소드는 Groovy의 사용하여 계산됩니다 &lt;code&gt;HashCodeHelper&lt;/code&gt; 의 책에 설명 된 것과 유사한 알고리즘 구현 클래스 &lt;em&gt;효과적인 자바&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6e63d7611eab2d457e68aebe6268ff6c3ef50435" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;node&lt;/code&gt; variable refers to the AST node where the AST test annotation is put. In the previous example, it means that</source>
          <target state="translated">&lt;code&gt;node&lt;/code&gt; 변수는 AST 테스트 주석 넣어하는 AST 노드를 의미한다. 이전 예에서 이는</target>
        </trans-unit>
        <trans-unit id="80313a71d12f637fc87968a63153d3f3e87a0de9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefix&lt;/code&gt; annotation attribute can be used to create setters with a different naming convention, e.g. with the prefix set to the empty String, you would use your setters as follows:</source>
          <target state="translated">&lt;code&gt;prefix&lt;/code&gt; 주석 속성은 다음과 같이 당신이 당신의 setter를 사용하는 것이 빈 문자열로 접두사 세트 예를 들어 다른 이름 지정 규칙과 setter를 만드는 데 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="62dadbb05ea9452a3f8698171e4c3c5adf50c815" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefix&lt;/code&gt; annotation attribute can be used to create setters with a different naming convention. The default is the empty string but you could change that to &quot;set&quot; as follows:</source>
          <target state="translated">&lt;code&gt;prefix&lt;/code&gt; 주석 속성은 다른 명명 규칙과 세터를 만드는 데 사용할 수 있습니다. 기본값은 빈 문자열이지만 다음과 같이 &quot;set&quot;으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7e7da8f8ac1f58f269f14f2223d6021171e84d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefix&lt;/code&gt; annotation attribute, which defaults to the empty String for this strategy, can be used to create setters with a different naming convention, e.g. with the &lt;code&gt;prefix&lt;/code&gt; changed to 'set', you would use your setters as follows:</source>
          <target state="translated">&lt;code&gt;prefix&lt;/code&gt; 이 전략의 빈 문자열 기본값의와 다른 명명 규칙, 예와 setter를 만드는 데 사용할 수 있습니다 주석 속성, &lt;code&gt;prefix&lt;/code&gt; 다음과 같이 당신이 당신의 setter를 사용하는 것이 '세트'로 변경 :</target>
        </trans-unit>
        <trans-unit id="530333b1471c9924eaa79d5f2383b3a99efb7aa0" translate="yes" xml:space="preserve">
          <source>The ASM api version to use when loading/parsing classes, and generating proxy adapter classes.</source>
          <target state="translated">클래스를로드 / 파싱하고 프록시 어댑터 클래스를 생성 할 때 사용할 ASM api 버전입니다.</target>
        </trans-unit>
        <trans-unit id="eacac5260137714b68dfd32df8448636a7cd8c2e" translate="yes" xml:space="preserve">
          <source>The AST transformations state data.</source>
          <target state="translated">AST 변환 상태 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="bc5bdb44ecff5ba8f2ac6aeacb93c47323537a4b" translate="yes" xml:space="preserve">
          <source>The AnnotationCollector can be used to define aliases for groups of annotations. The Alias needs to be a class or annotation annotated with AnnotationCollector, otherwise nothing is required. The alias will be replaced on the AST level and will never appear in later. Any members of the class or annotation will be ignored, but could be used by a custom processor. Annotation arguments are mapped to the aliased annotations if existing. Should the default processor not be able to map one of the arguments and error will be given. Is this not wished or if you want a different mapping a custom processor has to be used. There are two ways of using the alias. The first way is by providing the annotations as list/array:</source>
          <target state="translated">AnnotationCollector를 사용하여 주석 그룹에 대한 별칭을 정의 할 수 있습니다. Alias는 AnnotationCollector로 주석이 달린 클래스 또는 주석이어야합니다. 그렇지 않으면 아무것도 필요하지 않습니다. 별칭은 AST 수준에서 대체되며 나중에 나타나지 않습니다. 클래스 또는 주석의 모든 멤버는 무시되지만 사용자 지정 프로세서에서 사용할 수 있습니다. 주석 인수가있는 경우 별칭이 지정된 주석에 매핑됩니다. 기본 프로세서가 인수 중 하나를 매핑 할 수없는 경우 오류가 발생합니다. 원하지 않거나 다른 매핑을 원하는 경우 사용자 지정 프로세서를 사용해야합니다. 별칭을 사용하는 방법에는 두 가지가 있습니다. 첫 번째 방법은 주석을 목록 / 배열로 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5db2cc4cf1581ed432c22532522a07af4f3dc21e" translate="yes" xml:space="preserve">
          <source>The AstBuilder &quot;from code&quot; approach is used with a single Closure parameter. This transformation converts the ClosureExpression back into source code and rewrites the AST so that the &quot;from string&quot; builder is invoked on the source. In order for this to work, the closure source must be given a goto label. It is the &quot;from string&quot; approach's responsibility to remove the BlockStatement created by the label.</source>
          <target state="translated">AstBuilder &quot;코드에서&quot;접근 방식은 단일 Closure 매개 변수와 함께 사용됩니다. 이 변환은 ClosureExpression을 다시 소스 코드로 변환하고 &quot;from string&quot;빌더가 소스에서 호출되도록 AST를 다시 작성합니다. 이것이 작동하려면 클로저 소스에 goto 라벨이 주어져야합니다. 레이블에 의해 생성 된 BlockStatement를 제거하는 것은 &quot;문자열에서&quot;접근 방식의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="ba44980ebcb878656a29fe22ac4f96efa9fe21fd" translate="yes" xml:space="preserve">
          <source>The AstBuilder provides several ways to build an abstract syntax tree (AST) of Groovy code. You can convert a String into AST using the buildFromString method. You can convert code into AST using the buildFromCode method. You can use the AST DSL with the buildFromSpec method. For more information, see the resources on the Groovy wiki pages.</source>
          <target state="translated">AstBuilder는 Groovy 코드의 추상 구문 트리 (AST)를 구축하는 여러 가지 방법을 제공합니다. buildFromString 메소드를 사용하여 문자열을 AST로 변환 할 수 있습니다. buildFromCode 메서드를 사용하여 코드를 AST로 변환 할 수 있습니다. buildFromSpec 메소드와 함께 AST DSL을 사용할 수 있습니다. 자세한 내용은 Groovy 위키 페이지의 리소스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dab7488dc458ebefa3af6c5f3c52ee882f8cbada" translate="yes" xml:space="preserve">
          <source>The Boolean value</source>
          <target state="translated">부울 값</target>
        </trans-unit>
        <trans-unit id="2c8b0170c089fc67b7592e8b879b1010a6efb451" translate="yes" xml:space="preserve">
          <source>The Class of the caller</source>
          <target state="translated">발신자의 클래스</target>
        </trans-unit>
        <trans-unit id="ea5ebdb121347917420d0529564950593f68fffa" translate="yes" xml:space="preserve">
          <source>The Class of the matched caller, or null if there aren't enough stackframes to satisfy matchLevel</source>
          <target state="translated">일치하는 호출자의 클래스, 또는 matchLevel을 만족시키기에 충분한 스택 프레임이없는 경우 null</target>
        </trans-unit>
        <trans-unit id="95afa2b448d534d00f17faabf8897f23ba200f8d" translate="yes" xml:space="preserve">
          <source>The ClassLoader to use during processing</source>
          <target state="translated">처리 중 사용할 ClassLoader</target>
        </trans-unit>
        <trans-unit id="3b325fd56fcb36df68df5c37735a434ab8c3e5a2" translate="yes" xml:space="preserve">
          <source>The Closure and Class MetaClasses are not replaceable.</source>
          <target state="translated">Closure 및 Class MetaClasses는 교체 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f74d6daad2d2751944e6a7ff0057497d3e5b83e" translate="yes" xml:space="preserve">
          <source>The CompilationUnit collects all compilation data as it is generated by the compiler system. You can use this object to add additional source units to the compilation, or force the compilation to be run again (to affect only the deltas).</source>
          <target state="translated">CompilationUnit은 컴파일러 시스템에서 생성되는 모든 컴파일 데이터를 수집합니다. 이 개체를 사용하여 추가 소스 단위를 컴파일에 추가하거나 컴파일을 다시 실행하여 델타에만 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ae7fb01344a3870d231b2e7c5bef8b061d095f8" translate="yes" xml:space="preserve">
          <source>The ConfigObject instance</source>
          <target state="translated">ConfigObject 인스턴스</target>
        </trans-unit>
        <trans-unit id="86d6344f85a9a90bbe2e3c76743d0dab1644efa3" translate="yes" xml:space="preserve">
          <source>The GPathResult instance created by consuming a stream of SAX events Note if one of the parse methods has been called then this returns null Note if this is called more than once all calls after the first will return null</source>
          <target state="translated">SAX 이벤트 스트림을 사용하여 생성 된 GPathResult 인스턴스 참고 구문 분석 메서드 중 하나가 호출 된 경우 null을 반환합니다. Note 이것이 두 번 이상 호출되면 첫 번째 이후의 모든 호출이 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a1403f3f787db7ae0a251e57befceef1c173042a" translate="yes" xml:space="preserve">
          <source>The Generated annotation is used to mark members that have been generated.</source>
          <target state="translated">생성 된 주석은 생성 된 멤버를 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fee67b5a59c37f5eb850f04f216505b0ee5359f8" translate="yes" xml:space="preserve">
          <source>The Groovyc Ant task is frequently used in the context of a build system that knows the complete list of source files to be compiled. In such a context, it is wasteful for the Groovy compiler to go searching the classpath when looking for source files and hence by default the Groovyc Ant task calls the compiler in a special mode with such searching turned off. If you wish the compiler to search for source files then you need to set this flag to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Groovyc Ant 태스크는 컴파일 할 소스 파일의 전체 목록을 알고있는 빌드 시스템의 컨텍스트에서 자주 사용됩니다. 이러한 컨텍스트에서 소스 파일을 찾을 때 Groovy 컴파일러가 클래스 경로를 검색하는 것은 낭비이므로 기본적으로 Groovyc Ant 태스크는 이러한 검색이 꺼진 특수 모드에서 컴파일러를 호출합니다. 컴파일러가 소스 파일을 검색하도록하려면이 플래그를 &lt;code&gt;true&lt;/code&gt; 로 설정해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="8a572e6d63360dc8ed46fe486e95453148a82ab3" translate="yes" xml:space="preserve">
          <source>The I/O container for the command to spit stuff out.</source>
          <target state="translated">명령을 내릴 수있는 I / O 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="9eac464c463300041620f1317542a0b36de1c9f1" translate="yes" xml:space="preserve">
          <source>The Inspector provides a unified access to an object's information that can be determined by introspection.</source>
          <target state="translated">Inspector는 introspection으로 확인할 수있는 개체 정보에 대한 통합 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="89049d18696c55626bdc93e465d8d30137733d5c" translate="yes" xml:space="preserve">
          <source>The Internal annotation is used to mark members that are internal.</source>
          <target state="translated">내부 주석은 내부 멤버를 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9590c78dcd06317a3989b6bc16c6e0ac5dd7bc8d" translate="yes" xml:space="preserve">
          <source>The JDBC data type.</source>
          <target state="translated">JDBC 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bf1f48ddb64e5b808db4de3d772bd99c631f4770" translate="yes" xml:space="preserve">
          <source>The JDK Home to use when forked.</source>
          <target state="translated">분기 될 때 사용할 JDK 홈입니다.</target>
        </trans-unit>
        <trans-unit id="a3cddd13c50bb85bd71529142341665bd0b10ae0" translate="yes" xml:space="preserve">
          <source>The JDK Home to use when forked. Ignored if &quot;executable&quot; is specified.</source>
          <target state="translated">분기 될 때 사용할 JDK 홈입니다. &quot;실행 가능&quot;이 지정된 경우 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="73a1a508d0e588f700050a09964ef490424aaf02" translate="yes" xml:space="preserve">
          <source>The JSON builder implements the &lt;code&gt;Writable&lt;/code&gt; interface, so that you can have the builder serialize itself the JSON payload to a writer.</source>
          <target state="translated">JSON 빌더는 &lt;code&gt;Writable&lt;/code&gt; 인터페이스를 구현 하므로 빌더가 자체적으로 JSON 페이로드를 작성기에 직렬화하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4210607df0d96c450f5b18b723cad635f89b1b1" translate="yes" xml:space="preserve">
          <source>The Java class enhanced by this MetaClass</source>
          <target state="translated">이 MetaClass에 의해 강화 된 Java 클래스</target>
        </trans-unit>
        <trans-unit id="1ac137cd80780692f3c909dfbfd354042b337fa0" translate="yes" xml:space="preserve">
          <source>The JavaBean class should have a no-args constructor.</source>
          <target state="translated">JavaBean 클래스에는 인수가없는 생성자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="dd439d1414bf7dc6b93f52c0dc2f310499844e0e" translate="yes" xml:space="preserve">
          <source>The JmxBeanInfoManager creates fully-described model mbean info object using the underlying meta map. The MBeanInfo object is used to provide description about the actual exported MBean instance.</source>
          <target state="translated">JmxBeanInfoManager는 기본 메타 맵을 사용하여 완전히 설명 된 모델 mbean 정보 객체를 생성합니다. MBeanInfo 객체는 실제 내 보낸 MBean 인스턴스에 대한 설명을 제공하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="872c671635593eaadcddb9effd4d01a4ea959ded" translate="yes" xml:space="preserve">
          <source>The JmxBuilderModelMBean is the MBean class that proxies exported POGO/POJO inside the MBeanServer. When JmxBuilder exports an object instance, an instance of this class is created and exported inside the MBeanServer.</source>
          <target state="translated">JmxBuilderModelMBean은 MBeanServer 내에서 내 보낸 POGO / POJO를 프록시하는 MBean 클래스입니다. JmxBuilder가 객체 인스턴스를 내보낼 때이 클래스의 인스턴스가 생성되고 MBeanServer 내에서 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="f935c6274b761a9b967dde493b59c201774e5020" translate="yes" xml:space="preserve">
          <source>The JmxEventEmitter is a JMX Broadcaster class that is used to send generic events on the MBeanServer's event bus. It is used by the Emitter node () to send event to registered listeners.</source>
          <target state="translated">JmxEventEmitter는 MBeanServer의 이벤트 버스에서 일반 이벤트를 보내는 데 사용되는 JMX 브로드 캐스터 클래스입니다. Emitter 노드 ()에서 등록 된 리스너에게 이벤트를 보내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0d08957bff2b6ad91314499adc0b8343bea9d846" translate="yes" xml:space="preserve">
          <source>The JmxEventListener class is used by the builder to listen to events on the event bus. It is used internally by JmxBuilder to handle attribute-change and operation-invoke events on the bean() node.</source>
          <target state="translated">JmxEventListener 클래스는 빌더가 이벤트 버스에서 이벤트를 수신하는 데 사용됩니다. bean () 노드에서 속성 변경 및 작업 호출 이벤트를 처리하기 위해 JmxBuilder에서 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="791c37595668d995bb3f7137a2837e7869f379f8" translate="yes" xml:space="preserve">
          <source>The JmxMetaMapBuilder class is used to collect meta data passed in JmxBuilder nodes. Once collected, the data is then normalized to be represented uniformly regardless of the resource where it was obtained.</source>
          <target state="translated">JmxMetaMapBuilder 클래스는 JmxBuilder 노드에서 전달 된 메타 데이터를 수집하는 데 사용됩니다. 수집 된 데이터는 획득 한 리소스에 관계없이 균일하게 표현되도록 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="e1cf8f8fe2a9841c47ea577375d10ab0b3a498ec" translate="yes" xml:space="preserve">
          <source>The JmxTimerFactory class generates a timer() node for JmxBuilder. This node crates a standard JMX Timer object that can be used to provide timing signals to registered JMX listeners.</source>
          <target state="translated">JmxTimerFactory 클래스는 JmxBuilder에 대한 timer () 노드를 생성합니다. 이 노드는 등록 된 JMX 리스너에 타이밍 신호를 제공하는 데 사용할 수있는 표준 JMX Timer 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d1015aa5213030445b24890b5298e5c4b7fb29c4" translate="yes" xml:space="preserve">
          <source>The MetaClass</source>
          <target state="translated">MetaClass</target>
        </trans-unit>
        <trans-unit id="70b9f38afa55b20e2322eb7214953e5ce4ce9d61" translate="yes" xml:space="preserve">
          <source>The MetaClass instance</source>
          <target state="translated">MetaClass 인스턴스</target>
        </trans-unit>
        <trans-unit id="260db7c9ae9624cfa33762fdc9180e7061158fff" translate="yes" xml:space="preserve">
          <source>The MetaClassCreationHandle instance</source>
          <target state="translated">MetaClassCreationHandle 인스턴스</target>
        </trans-unit>
        <trans-unit id="304ce5f140b19a7e8c2ce15e0bd65caaaee29466" translate="yes" xml:space="preserve">
          <source>The MetaProperty or null if it doesn't exist</source>
          <target state="translated">MetaProperty 또는 존재하지 않는 경우 null</target>
        </trans-unit>
        <trans-unit id="7243e642f153efeb15b0cd45bbbcf1e34d8e7b86" translate="yes" xml:space="preserve">
          <source>The Number corresponding to the addition of left and right</source>
          <target state="translated">좌우 추가에 해당하는 번호</target>
        </trans-unit>
        <trans-unit id="4aa3b37e69477a774d6c510b9eeda86f2a333e6a" translate="yes" xml:space="preserve">
          <source>The Object can either be an instance of the class that this MetaObjectProtocol instance applies to or the java.lang.Class instance itself. If a method cannot be invoked a MissingMethodException is will be thrown</source>
          <target state="translated">Object는이 MetaObjectProtocol 인스턴스가 적용되는 클래스의 인스턴스이거나 java.lang.Class 인스턴스 자체 일 수 있습니다. 메소드를 호출 할 수없는 경우 MissingMethodException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f01609e35830c98cb8147ed0a154760cc0327e1b" translate="yes" xml:space="preserve">
          <source>The PrintWriter to write the &lt;a href=&quot;#usage&quot;&gt;usage&lt;/a&gt; help message to when &lt;code&gt;cli.usage()&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;cli.usage()&lt;/code&gt; 가 호출 될 때 &lt;a href=&quot;#usage&quot;&gt;사용법&lt;/a&gt; 도움말 메시지 를 쓸 PrintWriter 입니다.</target>
        </trans-unit>
        <trans-unit id="1ad7cb19c2bb4b46ecbb881cff1abf5fe7f4037b" translate="yes" xml:space="preserve">
          <source>The PrintWriter to write the &lt;a href=&quot;#usage&quot;&gt;usage&lt;/a&gt; help message to when &lt;code&gt;cli.usage()&lt;/code&gt; is called. Defaults to stdout but you can provide your own PrintWriter if desired.</source>
          <target state="translated">&lt;code&gt;cli.usage()&lt;/code&gt; 가 호출 될 때 &lt;a href=&quot;#usage&quot;&gt;사용법&lt;/a&gt; 도움말 메시지 를 쓸 PrintWriter 입니다. 기본값은 stdout이지만 원하는 경우 고유 한 PrintWriter를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3c0b48403b15a903f91f5257a20030e1e3b89f0" translate="yes" xml:space="preserve">
          <source>The PrintWriter to write to when invalid user input was provided to the &lt;a href=&quot;#parse(java.lang.String)&quot;&gt;parse(java.lang.String[])&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;#parse(java.lang.String)&quot;&gt;parse (java.lang.String [])&lt;/a&gt; 메서드에 잘못된 사용자 입력이 제공되었을 때 쓸 PrintWriter 입니다.</target>
        </trans-unit>
        <trans-unit id="127ae9cbb960e452f7333cb76a15c3f3dcc5fd90" translate="yes" xml:space="preserve">
          <source>The PrintWriter to write to when invalid user input was provided to the &lt;a href=&quot;#parse(java.lang.String)&quot;&gt;parse(java.lang.String[])&lt;/a&gt; method. Defaults to stderr but you can provide your own PrintWriter if desired.</source>
          <target state="translated">&lt;a href=&quot;#parse(java.lang.String)&quot;&gt;parse (java.lang.String [])&lt;/a&gt; 메서드에 잘못된 사용자 입력이 제공되었을 때 쓸 PrintWriter 입니다. 기본값은 stderr이지만 원하는 경우 고유 한 PrintWriter를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a802aa7bf26ec7a1cc42a344ad8a273e764c485" translate="yes" xml:space="preserve">
          <source>The Swing component being edited.</source>
          <target state="translated">편집중인 Swing 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="bdb2fc7e68bc1e57e68935cf223ed7a03e6b0e67" translate="yes" xml:space="preserve">
          <source>The System Property to set as a filename excludes pattern for collection of Classes.</source>
          <target state="translated">파일 이름으로 설정할 시스템 속성은 클래스 컬렉션에 대한 패턴을 제외합니다.</target>
        </trans-unit>
        <trans-unit id="6a1909fe3c15f658c03287f53b875168b744419d" translate="yes" xml:space="preserve">
          <source>The System Property to set as a filename excludes pattern for collection of Classes. When non-empty, the pattern will be used as Regular Expression pattern applied with the find operator against each candidate file.path. Key is &quot;javadocAssertion.src.excludesPattern&quot;. Default value is &quot;&quot;.</source>
          <target state="translated">파일 이름으로 설정할 시스템 속성은 클래스 컬렉션에 대한 패턴을 제외합니다. 비어 있지 않은 경우 패턴은 각 후보 파일에 대해 찾기 연산자와 함께 적용된 정규식 패턴으로 사용됩니다. 키는 &quot;javadocAssertion.src.excludesPattern&quot;입니다. 기본값은 &quot;&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6e2f804b26b209506ffe905e468265879b10275e" translate="yes" xml:space="preserve">
          <source>The System Property to set as a filename excludes pattern for collection of Test Cases.</source>
          <target state="translated">파일 이름으로 설정할 시스템 속성은 테스트 케이스 수집을위한 패턴을 제외합니다.</target>
        </trans-unit>
        <trans-unit id="b63561856de11fdd61e36dc53031f4a4c5c9997a" translate="yes" xml:space="preserve">
          <source>The System Property to set as a filename excludes pattern for collection of Test Cases. When non-empty, the pattern will be used as Regular Expression pattern applied with the find operator against each candidate file.path. Key is &quot;groovy.test.excludesPattern&quot;. Default value is &quot;&quot;.</source>
          <target state="translated">파일 이름으로 설정할 시스템 속성은 테스트 케이스 수집을위한 패턴을 제외합니다. 비어 있지 않은 경우 패턴은 각 후보 파일에 대해 찾기 연산자와 함께 적용된 정규식 패턴으로 사용됩니다. 키는 &quot;groovy.test.excludesPattern&quot;입니다. 기본값은 &quot;&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="47b09e49327c616d7dfdf39837fa8bd53af76f55" translate="yes" xml:space="preserve">
          <source>The System Property to set as base directory for collection of Classes.</source>
          <target state="translated">클래스 컬렉션의 기본 디렉터리로 설정할 시스템 속성입니다.</target>
        </trans-unit>
        <trans-unit id="4eeea8df2c671b1aaf1f285764880655e10de1e1" translate="yes" xml:space="preserve">
          <source>The System Property to set as base directory for collection of Classes. The pattern will be used as an Ant fileset include basedir. Key is &quot;javadocAssertion.src.dir&quot;. Defaults to the &lt;code&gt;./src&lt;/code&gt; directory</source>
          <target state="translated">클래스 컬렉션의 기본 디렉터리로 설정할 시스템 속성입니다. 패턴은 Ant 파일 세트 포함 basedir로 사용됩니다. 키는 &quot;javadocAssertion.src.dir&quot;입니다. 기본값은 &lt;code&gt;./src&lt;/code&gt; 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="3bf415e47865f7516d23e95370920077c48370ee" translate="yes" xml:space="preserve">
          <source>The System Property to set as base directory for collection of Test Cases.</source>
          <target state="translated">테스트 케이스 수집을위한 기본 디렉토리로 설정할 시스템 속성입니다.</target>
        </trans-unit>
        <trans-unit id="31447f96bb70b187e7844f2b264f55c03201f601" translate="yes" xml:space="preserve">
          <source>The System Property to set as base directory for collection of Test Cases. The pattern will be used as an Ant fileset include basedir. Key is &quot;groovy.test.dir&quot;. Default value is &quot;./test/&quot;.</source>
          <target state="translated">테스트 케이스 수집을위한 기본 디렉토리로 설정할 시스템 속성입니다. 패턴은 Ant 파일 세트 포함 basedir로 사용됩니다. 키는 &quot;groovy.test.dir&quot;입니다. 기본값은 &quot;./test/&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="266958bc55466288051a176e383496d4feb92e74" translate="yes" xml:space="preserve">
          <source>The System Property to set as the filename pattern for collection of Classes.</source>
          <target state="translated">클래스 컬렉션의 파일 이름 패턴으로 설정할 시스템 속성입니다.</target>
        </trans-unit>
        <trans-unit id="2a90fedae02d009a3ffad52f02ac8b7d11b8745b" translate="yes" xml:space="preserve">
          <source>The System Property to set as the filename pattern for collection of Classes. The pattern will be used as Regular Expression pattern applied with the find operator against each candidate file.path. Key is &quot;javadocAssertion.src.pattern&quot;. Defaults to including all &lt;code&gt;.java&lt;/code&gt; and &lt;code&gt;.groovy&lt;/code&gt; files.</source>
          <target state="translated">클래스 컬렉션의 파일 이름 패턴으로 설정할 시스템 속성입니다. 패턴은 각 후보 파일 경로에 대해 찾기 연산자와 함께 적용된 정규식 패턴으로 사용됩니다. 키는 &quot;javadocAssertion.src.pattern&quot;입니다. 기본적으로 모든 &lt;code&gt;.java&lt;/code&gt; 및 &lt;code&gt;.groovy&lt;/code&gt; 파일 을 포함 합니다.</target>
        </trans-unit>
        <trans-unit id="0000bd75ba6a74e57ac9cf53044c50c3c9d010ff" translate="yes" xml:space="preserve">
          <source>The System Property to set as the filename pattern for collection of Test Cases.</source>
          <target state="translated">테스트 케이스 모음의 파일 이름 패턴으로 설정할 시스템 속성입니다.</target>
        </trans-unit>
        <trans-unit id="998db7b8bbfcee3c949aa177d7b90b7dfdb69720" translate="yes" xml:space="preserve">
          <source>The System Property to set as the filename pattern for collection of Test Cases. The pattern will be used as Regular Expression pattern applied with the find operator against each candidate file.path. Key is &quot;groovy.test.pattern&quot;. Default value is &quot;Test.groovy&quot;.</source>
          <target state="translated">테스트 케이스 모음의 파일 이름 패턴으로 설정할 시스템 속성입니다. 패턴은 각 후보 파일 경로에 대해 찾기 연산자와 함께 적용된 정규식 패턴으로 사용됩니다. 키는 &quot;groovy.test.pattern&quot;입니다. 기본값은 &quot;Test.groovy&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="84337e91be9e8ef75be1d04b6fdba516cbd8151f" translate="yes" xml:space="preserve">
          <source>The TimeUnit of the value parameter.</source>
          <target state="translated">값 매개 변수의 TimeUnit입니다.</target>
        </trans-unit>
        <trans-unit id="718e7ae897428930781dc6de636d2e594031a23c" translate="yes" xml:space="preserve">
          <source>The TimeUnit of the value parameter. By default it is TimeUnit.SECONDS.</source>
          <target state="translated">값 매개 변수의 TimeUnit입니다. 기본적으로 TimeUnit.SECONDS입니다.</target>
        </trans-unit>
        <trans-unit id="c92a8a6f01fd8d4e068bc1d01714e753c4596b32" translate="yes" xml:space="preserve">
          <source>The URL for a repo containing the grape/artifact.</source>
          <target state="translated">포도 / 아티팩트를 포함하는 저장소의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="de6a560d5da664892b518e4682d24979363ecddc" translate="yes" xml:space="preserve">
          <source>The URL for a repo containing the grape/artifact. A non-empty value is required unless value() is used.</source>
          <target state="translated">포도 / 아티팩트를 포함하는 저장소의 URL입니다. value ()를 사용하지 않는 한 비어 있지 않은 값이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b6aadb5f5ba9e2b129360252950ed1939f90ac0b" translate="yes" xml:space="preserve">
          <source>The URL pattern does not require the &quot;*.groovy&quot; mapping. You can, for example, make it more Struts-like but groovy by making your mapping &quot;*.gdo&quot;.</source>
          <target state="translated">URL 패턴에는 &quot;* .groovy&quot;매핑이 필요하지 않습니다. 예를 들어 &quot;* .gdo&quot;매핑을 만들어보다 Struts와 비슷하지만 멋지게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adca94d915cd2e4151b8eb5471618fdec37d9c2b" translate="yes" xml:space="preserve">
          <source>The XML template engine can also be used as the engine for &lt;a href=&quot;../servlet/templateservlet&quot;&gt;TemplateServlet&lt;/a&gt; by placing the following in your web.xml file (plus a corresponding servlet-mapping element):</source>
          <target state="translated">XML 템플릿 엔진은 web.xml 파일 (및 해당 servlet-mapping 요소 포함)에 다음을 배치하여 &lt;a href=&quot;../servlet/templateservlet&quot;&gt;TemplateServlet&lt;/a&gt; 의 엔진으로 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9495cf1739a07e775ac543e8d0f74d2f8dd5b54" translate="yes" xml:space="preserve">
          <source>The YAML builder implements the &lt;code&gt;Writable&lt;/code&gt; interface, so that you can have the builder serialize itself the YAML payload to a writer.</source>
          <target state="translated">YAML 빌더는 &lt;code&gt;Writable&lt;/code&gt; 인터페이스를 구현 하므로 빌더가 YAML 페이로드를 작성기에 직렬화하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a412e1e1d8cd3a68e2efff325b41048db7ad21bd" translate="yes" xml:space="preserve">
          <source>The above example prints this to standard output:</source>
          <target state="translated">위의 예는 이것을 표준 출력으로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="ec91d8d1308de75b03d0376ac9545cec66180c83" translate="yes" xml:space="preserve">
          <source>The above example will generate code that is similar to the next snippet. Notice the difference between a String property and a def/Object property:</source>
          <target state="translated">위의 예는 다음 스 니펫과 유사한 코드를 생성합니다. String 속성과 def / Object 속성의 차이점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="b257bfac16ef28eecdac4b554708ae5f69748970" translate="yes" xml:space="preserve">
          <source>The actual number of characters skipped</source>
          <target state="translated">건너 뛴 실제 문자 수</target>
        </trans-unit>
        <trans-unit id="052bfa45246c41d68e26ad806f4e38a47fba851d" translate="yes" xml:space="preserve">
          <source>The alternative supported style regards any kind of inheritance as creation of a new type and is illustrated in the following example:</source>
          <target state="translated">대체 지원 스타일은 모든 종류의 상속을 새 유형의 생성으로 간주하며 다음 예에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bdb04cd00d0c115ee207c0ae5337f0b546086bb" translate="yes" xml:space="preserve">
          <source>The annotated Collection field must have a generic type</source>
          <target state="translated">주석이 달린 컬렉션 필드에는 일반 유형이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="aceff9ab81f781b7ab6d9e62431c1055127d2723" translate="yes" xml:space="preserve">
          <source>The annotated Collection field must not have a generic wildcard declared</source>
          <target state="translated">주석이 달린 컬렉션 필드에는 선언 된 일반 와일드 카드가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="9e547ff00f70b525a9f0ec9c47c86f3334dc81ae" translate="yes" xml:space="preserve">
          <source>The annotated variable will become a private field of the script class. The type of the field will be the same as the type of the variable. Example usage:</source>
          <target state="translated">주석이 달린 변수는 스크립트 클래스의 개인 필드가됩니다. 필드 유형은 변수 유형과 동일합니다. 사용 예 :</target>
        </trans-unit>
        <trans-unit id="f318a85f6a5756ab184456f34f3ce55011832330" translate="yes" xml:space="preserve">
          <source>The annotation being referenced.</source>
          <target state="translated">참조되는 주석입니다.</target>
        </trans-unit>
        <trans-unit id="5c20ea5b9d49bb4d3079400f6c7b508d5ddfe6c4" translate="yes" xml:space="preserve">
          <source>The annotation can be placed at the class level in which case it applies to all methods, constructors, and closures within the class and any inner classes. It can also be applied to an individual method, constructor, field with a Closure initial value or a Closure assigned to a local variable. In the case of fields (or local variables) it only adjusts the parameters of the referenced Closure not the field (or local variable) itself.</source>
          <target state="translated">주석은 클래스 수준에 배치 할 수 있으며이 경우 클래스 및 모든 내부 클래스 내의 모든 메서드, 생성자 및 클로저에 적용됩니다. 또한 Closure 초기 값이있는 개별 메서드, 생성자, 필드 또는 지역 변수에 할당 된 Closure에 적용될 수 있습니다. 필드 (또는 로컬 변수)의 경우 필드 (또는 로컬 변수) 자체가 아닌 참조 된 클로저의 매개 변수 만 조정합니다.</target>
        </trans-unit>
        <trans-unit id="9517f13d3119a99ae37232e6f8925dc3dc606f99" translate="yes" xml:space="preserve">
          <source>The annotation can be used on a whole class as shown above or selectively on a particular method, constructor or field.</source>
          <target state="translated">주석은 위에 표시된대로 전체 클래스에서 사용하거나 특정 메서드, 생성자 또는 필드에서 선택적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dcd4f54b47563f3bd43966ca8e9a4fbea0a7944" translate="yes" xml:space="preserve">
          <source>The annotation can take the following parameters:</source>
          <target state="translated">주석은 다음 매개 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06f750d18a3b109b97c136361abf51e190db88be" translate="yes" xml:space="preserve">
          <source>The annotation is intended to be used sparingly; perhaps in DSL scenarios or when using deeply nested structural types. In particular, there is no support for using the facility with two similarly named classes from different packages at the same time. Though it is OK to have different packages in different contexts. Also, there is no support for turning &quot;Ruby-style&quot; conversions off at the method, constructor or field level if already turned on at the class level.</source>
          <target state="translated">주석은 드물게 사용하기위한 것입니다. 아마도 DSL 시나리오에서 또는 깊게 중첩 된 구조 유형을 사용할 때. 특히, 서로 다른 패키지에서 이름이 비슷한 두 개의 클래스를 동시에 사용하는 기능은 지원되지 않습니다. 상황에 따라 다른 패키지를 사용해도 괜찮습니다. 또한 클래스 수준에서 이미 설정되어있는 경우 메서드, 생성자 또는 필드 수준에서 &quot;Ruby 스타일&quot;변환을 해제하는 기능이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3190b6c4518ac7ad1bc48cdc3e3e48499552b444" translate="yes" xml:space="preserve">
          <source>The annotation takes an optional parameter for the name of the field. This field must exist on the class and must be of type ReentrantReadWriteLock.</source>
          <target state="translated">주석은 필드 이름에 대한 선택적 매개 변수를 사용합니다. 이 필드는 클래스에 있어야하며 ReentrantReadWriteLock 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6d2a41c58f84b983c4307e184fcf2882ccbdc7cf" translate="yes" xml:space="preserve">
          <source>The attribute value</source>
          <target state="translated">속성 값</target>
        </trans-unit>
        <trans-unit id="dd9423271c2e0be1493ebeaf945a08093f8a561f" translate="yes" xml:space="preserve">
          <source>The attribute values of annotations must be primitive, String or Enum constants.</source>
          <target state="translated">주석의 속성 값은 기본, 문자열 또는 열거 상수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e91a7321fc7ae255dea783ee8a8e3fd6aea9d2cb" translate="yes" xml:space="preserve">
          <source>The attribute values of annotations must be primitive, String or Enum constants. In various places, such constants can be seen during type resolution but won't be readily accessible in later phases, e.g. they might be embedded into constructor code. This method transforms constants that would appear in annotations early so they aren't lost. Subsequent processing determines whether they are valid, this method simply retains the constant value as a constant expression.</source>
          <target state="translated">주석의 속성 값은 기본, 문자열 또는 열거 상수 여야합니다. 여러 곳에서 이러한 상수는 유형 확인 중에 볼 수 있지만 이후 단계에서 쉽게 액세스 할 수 없습니다. 예를 들어 생성자 코드에 포함될 수 있습니다. 이 메서드는 어노테이션에 초기에 표시되는 상수를 변환하므로 손실되지 않습니다. 후속 처리는 이들이 유효한지 여부를 판별합니다.이 메소드는 단순히 상수 값을 상수 표현식으로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="ba9d0f179fb12288dcac51469b2a074466e2e0af" translate="yes" xml:space="preserve">
          <source>The average of all of the items</source>
          <target state="translated">모든 항목의 평균</target>
        </trans-unit>
        <trans-unit id="70783273967fb37a38f643afd98e6b9187891321" translate="yes" xml:space="preserve">
          <source>The average of the items</source>
          <target state="translated">항목의 평균</target>
        </trans-unit>
        <trans-unit id="8395f1aa4e19271ad68a33fd7315e6d494f3ac12" translate="yes" xml:space="preserve">
          <source>The average of the values returned by applying the closure to each item from the Iterator.</source>
          <target state="translated">반복기의 각 항목에 클로저를 적용하여 반환 된 값의 평균입니다.</target>
        </trans-unit>
        <trans-unit id="3eb091fbf86b30307fd9a7fb7c9aaa700930da46" translate="yes" xml:space="preserve">
          <source>The average of the values returned by applying the closure to each item of the Iterable.</source>
          <target state="translated">Iterable의 각 항목에 클로저를 적용하여 반환 된 값의 평균입니다.</target>
        </trans-unit>
        <trans-unit id="7c9801aab1db27901fd7a9be59509eda4d8846c8" translate="yes" xml:space="preserve">
          <source>The average of the values returned by applying the closure to each item of the array.</source>
          <target state="translated">배열의 각 항목에 클로저를 적용하여 반환 된 값의 평균입니다.</target>
        </trans-unit>
        <trans-unit id="4bbf0434c30c3cf5371d3ed8bebd25d1c43ff05a" translate="yes" xml:space="preserve">
          <source>The bind path object. This class represents one &quot;step&quot; in the bind path.</source>
          <target state="translated">바인딩 경로 개체입니다. 이 클래스는 바인드 경로의 한 &quot;단계&quot;를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4408519a715193017dfb9b02caa80e83767ca7d0" translate="yes" xml:space="preserve">
          <source>The binding also provides convenient methods:</source>
          <target state="translated">바인딩은 또한 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1c8a6a5839bf78280f2f5d8f72a3b8f0dac48502" translate="yes" xml:space="preserve">
          <source>The binding provided by TemplateServlet does already include some default variables. As of this writing, they are (copied from &lt;a href=&quot;servletbinding&quot;&gt;ServletBinding&lt;/a&gt;):</source>
          <target state="translated">TemplateServlet에서 제공하는 바인딩에는 이미 일부 기본 변수가 포함되어 있습니다. 이 글을 쓰는 시점에서 그것들은 ( &lt;a href=&quot;servletbinding&quot;&gt;ServletBinding&lt;/a&gt; 에서 복사되었습니다 ) :</target>
        </trans-unit>
        <trans-unit id="170305b27b6f2f428a171b71d8192fdfc6377fe8" translate="yes" xml:space="preserve">
          <source>The cached class.</source>
          <target state="translated">캐시 된 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="3de13709d4a99443765990411d8804e7d936d4c5" translate="yes" xml:space="preserve">
          <source>The call should be invoked separately</source>
          <target state="translated">호출은 별도로 호출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fed53e69261b2dc331e4fdcb563927c92a857a5a" translate="yes" xml:space="preserve">
          <source>The character read, as an integer in the range 0 to 65535 (0x00-0xffff), or -1 if the end of the stream has been reached</source>
          <target state="translated">0에서 65535 (0x00-0xffff) 범위의 정수로 읽은 문자 또는 스트림 끝에 도달 한 경우 -1</target>
        </trans-unit>
        <trans-unit id="0b1006004394eb9f2a6da42ea7c5b946608b286e" translate="yes" xml:space="preserve">
          <source>The character used to split a single command line argument into parts.</source>
          <target state="translated">단일 명령 줄 인수를 여러 부분으로 분할하는 데 사용되는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="e358d3e84c4ddc0c51dee898e085378748c11c44" translate="yes" xml:space="preserve">
          <source>The check works &lt;b&gt;only for options &lt;b&gt;one&lt;/b&gt; block below the current block. E.g. &lt;code&gt;config.isSet('foo.password')&lt;/code&gt; will always return false. &lt;dl&gt;
&lt;dt&gt;&lt;b&gt;Parameters:&lt;/b&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;code&gt;option&lt;/code&gt; - The name of the option&lt;/dd&gt;
&lt;/dl&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;b&gt;Returns:&lt;/b&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;code&gt;true&lt;/code&gt; if the option is set &lt;code&gt;false&lt;/code&gt; otherwise&lt;/dd&gt;
&lt;/dl&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;b&gt;Since:&lt;/b&gt;&lt;/dt&gt;
&lt;dd&gt;2.3.0&lt;/dd&gt;
&lt;/dl&gt; &lt;/b&gt;</source>
          <target state="translated">체크 작품 &lt;b&gt;에만 옵션을 &lt;b&gt;하나 개의&lt;/b&gt; 블록을 현재 블록 아래. 예를 들어 &lt;code&gt;config.isSet('foo.password')&lt;/code&gt; 는 항상 false를 반환합니다. &lt;dl&gt; &lt;dt&gt; &lt;b&gt;매개 변수 :&lt;/b&gt; &lt;/dt&gt; &lt;dd&gt; &lt;code&gt;option&lt;/code&gt; -옵션 의 이름 &lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt; &lt;b&gt;보고:&lt;/b&gt; &lt;/dt&gt; &lt;dd&gt; &lt;code&gt;true&lt;/code&gt; 옵션이 설정되어있는 경우 &lt;code&gt;false&lt;/code&gt; , 그렇지 않으면 &lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt; &lt;b&gt;이후:&lt;/b&gt; &lt;/dt&gt; &lt;dd&gt; 2.3.0 &lt;/dd&gt; &lt;/dl&gt; &lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="12f6e1d7ed0f1c99877990e1030d0f1489d503a8" translate="yes" xml:space="preserve">
          <source>The class contained by this metaclass</source>
          <target state="translated">이 메타 클래스에 포함 된 클래스</target>
        </trans-unit>
        <trans-unit id="02889e40310a5938acf27d4e92b62a80c8bb0b34" translate="yes" xml:space="preserve">
          <source>The class is automatically made final.</source>
          <target state="translated">수업은 자동으로 최종 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="d55ce426f3bc5d724c2889dfa22ff395fbda6a39" translate="yes" xml:space="preserve">
          <source>The class passed as a constructor parameter must be an AST transformation annotation. Alternatively, you can apply a global AST transformation by calling the &lt;a href=&quot;asttransformationcustomizer#ASTTransformationCustomizer(org.codehaus.groovy.transform.ASTTransformation)&quot;&gt;AST transformation&lt;/a&gt;. In that case, the transformation is applied once for the whole source unit. Unlike a global AST transformation declared in the META-INF/services/org.codehaus.groovy.transform.ASTTransformation file, which are applied if the file is in the classpath, using this customizer you'll have the choice to apply your transformation selectively. It can also be useful to debug global AST transformations without having to package your annotation in a jar file.</source>
          <target state="translated">생성자 매개 변수로 전달 된 클래스는 AST 변환 주석이어야합니다. 또는, 호출하여 글로벌 AST 변환을 적용 할 수 있습니다 &lt;a href=&quot;asttransformationcustomizer#ASTTransformationCustomizer(org.codehaus.groovy.transform.ASTTransformation)&quot;&gt;AST 변환을&lt;/a&gt; . 이 경우 변환은 전체 소스 단위에 한 번 적용됩니다. 파일이 클래스 경로에있는 경우 적용되는 META-INF / services / org.codehaus.groovy.transform.ASTTransformation 파일에 선언 된 글로벌 AST 변환과 달리이 사용자 지정 프로그램을 사용하면 변환을 선택적으로 적용 할 수 있습니다. . jar 파일에 주석을 패키징하지 않고도 전역 AST 변환을 디버그하는 것도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cad1da7d481a03ef9916a2ff7d8844930ea3cea" translate="yes" xml:space="preserve">
          <source>The classifier if in use, e.g.: &quot;jdk14&quot;</source>
          <target state="translated">사용중인 경우 분류 자, 예 : &quot;jdk14&quot;</target>
        </trans-unit>
        <trans-unit id="ca27fb66cfe5fba5a9ac754d02a9f29c0105033f" translate="yes" xml:space="preserve">
          <source>The classpath as URL[] from this configuration.</source>
          <target state="translated">이 구성의 URL [] 클래스 경로입니다.</target>
        </trans-unit>
        <trans-unit id="8d1bf1f2d2c67f0aae89b6c3bc480661749348cd" translate="yes" xml:space="preserve">
          <source>The classpath as URL[] from this configuration. This can be used to construct a class loader.</source>
          <target state="translated">이 구성의 URL [] 클래스 경로입니다. 이것은 클래스 로더를 구성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd3926225e9f00ef4ebec16fbc04d966c7fe2b75" translate="yes" xml:space="preserve">
          <source>The closure</source>
          <target state="translated">폐쇄</target>
        </trans-unit>
        <trans-unit id="479f86662ac269b97cc2d894e9bac34d9794dd34" translate="yes" xml:space="preserve">
          <source>The closure code is executed after the specified phase has completed. If no phase is provided, then the code is executed after the &lt;a href=&quot;../../org/codehaus/groovy/control/compilephase#SEMANTIC_ANALYSIS&quot;&gt;semantic analysis&lt;/a&gt; phase and each subsequent phase.</source>
          <target state="translated">클로저 코드는 지정된 단계가 완료된 후에 실행됩니다. 단계가 제공되지 않으면 &lt;a href=&quot;../../org/codehaus/groovy/control/compilephase#SEMANTIC_ANALYSIS&quot;&gt;의미 분석&lt;/a&gt; 단계와 이후의 각 단계 후에 코드가 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="d7e22c2e0c44fd389e3b41fde1dda05fedb35439" translate="yes" xml:space="preserve">
          <source>The closure is wrapped in a thread, and the thread is started immediately, only if the current thread is the EDT, otherwise the closure will be called immediately.</source>
          <target state="translated">클로저는 쓰레드에 싸여 있고, 현재 쓰레드가 EDT 인 경우에만 쓰레드가 즉시 시작됩니다. 그렇지 않으면 클로저가 즉시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="66a119bbf2479d278c5b03976bf4d331b5a07a07" translate="yes" xml:space="preserve">
          <source>The closure must accept either 1 or 2 parameters. The first parameter is required and will be instance of the &lt;code&gt;type&lt;/code&gt; for which the closure is registered. The second optional parameter should be of type &lt;code&gt;String&lt;/code&gt; and, if available, will be passed the name of the key associated with this value if serializing a JSON Object. This parameter will be &lt;code&gt;null&lt;/code&gt; when serializing a JSON Array or when there is no way to determine the name of the key.</source>
          <target state="translated">클로저는 1 개 또는 2 개의 매개 변수를 허용해야합니다. 첫 번째 매개 변수는 필수이며 클로저가 등록 된 &lt;code&gt;type&lt;/code&gt; 인스턴스 가됩니다. 두 번째 선택적 매개 변수는 &lt;code&gt;String&lt;/code&gt; 유형이어야하며 사용 가능한 경우 JSON 오브젝트를 직렬화하는 경우이 값과 연관된 키의 이름이 전달됩니다. 이 매개 변수는 JSON 배열을 직렬화하거나 키 이름을 판별 할 방법이없는 경우 &lt;code&gt;null&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="d6ac82819478a5008a16cf393ea1fa535e93de24" translate="yes" xml:space="preserve">
          <source>The closure will be called with a single argument; the database statement (actually a &lt;code&gt;BatchingStatementWrapper&lt;/code&gt; helper object) associated with this batch.</source>
          <target state="translated">클로저는 단일 인수로 호출됩니다. 이 일괄 처리와 관련된 데이터베이스 문 (실제로 &lt;code&gt;BatchingStatementWrapper&lt;/code&gt; 도우미 개체)</target>
        </trans-unit>
        <trans-unit id="ae8cb3c86be077ae32b3b768d99be03b18c7b824" translate="yes" xml:space="preserve">
          <source>The closure will be called with a single argument; the prepared statement (actually a &lt;code&gt;BatchingPreparedStatementWrapper&lt;/code&gt; helper object) associated with this batch.</source>
          <target state="translated">클로저는 단일 인수로 호출됩니다. 이 일괄 처리와 관련된 준비된 문 (실제로 &lt;code&gt;BatchingPreparedStatementWrapper&lt;/code&gt; 도우미 개체)</target>
        </trans-unit>
        <trans-unit id="4ae276d6aaf9c3b8bb8aacf648ffb3e07a64cd0f" translate="yes" xml:space="preserve">
          <source>The column.</source>
          <target state="translated">열.</target>
        </trans-unit>
        <trans-unit id="b8a31b50dfe2f995289113fae596103f2b81d59f" translate="yes" xml:space="preserve">
          <source>The command synopsis displayed as the first line in the usage help message, e.g., when &lt;code&gt;cli.usage()&lt;/code&gt; is called.</source>
          <target state="translated">예를 들어 &lt;code&gt;cli.usage()&lt;/code&gt; 가 호출 될 때 사용법 도움말 메시지의 첫 번째 행으로 표시되는 명령 개요 .</target>
        </trans-unit>
        <trans-unit id="06cad667cd962638ca743f083a07c3b0502fe46b" translate="yes" xml:space="preserve">
          <source>The command synopsis displayed as the first line in the usage help message, e.g., when &lt;code&gt;cli.usage()&lt;/code&gt; is called. When not set, a default synopsis is generated that shows the supported options and parameters.</source>
          <target state="translated">예를 들어 &lt;code&gt;cli.usage()&lt;/code&gt; 가 호출 될 때 사용법 도움말 메시지의 첫 번째 행으로 표시되는 명령 개요 . 설정되지 않은 경우 지원되는 옵션 및 매개 변수를 표시하는 기본 개요가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="d18fc7b737edb2f0f86aeb308f5fb82c518e4b38" translate="yes" xml:space="preserve">
          <source>The compile phase after which the test code should run.</source>
          <target state="translated">테스트 코드가 실행되어야하는 컴파일 단계입니다.</target>
        </trans-unit>
        <trans-unit id="afcc42b40006b1f09d9251010aafdffd34d40bec" translate="yes" xml:space="preserve">
          <source>The compiler will call this method each time, in a source file, a method call using a closure literal is encountered and that the target method has the corresponding &lt;a href=&quot;../../lang/closure&quot;&gt;Closure&lt;/a&gt; parameter annotated with &lt;a href=&quot;closureparams&quot;&gt;ClosureParams&lt;/a&gt;. So imagine the following code needs to be compiled:</source>
          <target state="translated">컴파일러는 소스 파일에서 클로저 리터럴을 사용하는 메서드 호출이 발생하고 대상 메서드 에 &lt;a href=&quot;closureparams&quot;&gt;ClosureParams&lt;/a&gt; 주석이 달린 해당 &lt;a href=&quot;../../lang/closure&quot;&gt;Closure&lt;/a&gt; 매개 변수가 있을 때마다이 메서드 를 호출 합니다. 따라서 다음 코드를 컴파일해야한다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="3808e32108176f69751a0339e1ed53d1e06027cc" translate="yes" xml:space="preserve">
          <source>The compiler will not output classes from these, the methods usually do not contain bodies. These kind of ClassNodes will be used in different checks, but not checks that work on the method bodies. For example if such a ClassNode is a super class to a primary ClassNode, then the abstract method test and others will be done with data based on these. Theoretically it is also possible to mix both (1 and 2) kind of classes in a hierarchy, but this probably works only in the newest Groovy versions. Such ClassNodes normally have to isResolved() returning true without having a redirect.In the Groovy compiler the only version of this, that exists, is a ClassNode created through a Class instance</source>
          <target state="translated">컴파일러는 이들로부터 클래스를 출력하지 않으며, 메서드는 일반적으로 본문을 포함하지 않습니다. 이러한 종류의 ClassNode는 다른 검사에서 사용되지만 메서드 본문에서 작동하는 검사에서는 사용되지 않습니다. 예를 들어, 그러한 ClassNode가 기본 ClassNode에 대한 수퍼 클래스 인 경우 추상 메소드 테스트 및 기타는 이들을 기반으로 한 데이터로 수행됩니다. 이론적으로는 계층 구조에서 (1 및 2) 종류의 클래스를 모두 혼합 할 수도 있지만 이는 아마도 최신 Groovy 버전에서만 작동 할 것입니다. 이러한 ClassNode는 일반적으로 리디렉션없이 true를 반환하는 isResolved ()를 수행해야합니다. Groovy 컴파일러에서 존재하는 유일한 버전은 Class 인스턴스를 통해 생성 된 ClassNode입니다.</target>
        </trans-unit>
        <trans-unit id="850b5efb5f5d9bd3f0560dbbfb14716f649e832f" translate="yes" xml:space="preserve">
          <source>The configuration if in use (normally only used by internal ivy repositories).</source>
          <target state="translated">사용중인 경우 구성 (일반적으로 내부 아이비 저장소에서만 사용됨).</target>
        </trans-unit>
        <trans-unit id="d7faea022679481783e94841e801c0632c55b402" translate="yes" xml:space="preserve">
          <source>The configuration if in use (normally only used by internal ivy repositories). One or more comma separated values with or without square brackets, e.g. for hibernate you might have &quot;default,proxool,oscache&quot; or &quot;[default,dbcp,swarmcache]&quot;. This last hibernate example assumes you have set up such configurations in your local Ivy repo and have changed your grape config (using grapeConfig.xml) or the &lt;code&gt;@GrabConfig&lt;/code&gt; annotation to point to that repo.</source>
          <target state="translated">사용중인 경우 구성 (일반적으로 내부 아이비 저장소에서만 사용됨). 대괄호가 있거나없는 하나 이상의 쉼표로 구분 된 값, 예를 들어 최대 절전 모드의 경우 &quot;default, proxool, oscache&quot;또는 &quot;[default, dbcp, swarmcache]&quot;가있을 수 있습니다. 이 마지막 최대 절전 모드 예제에서는 로컬 Ivy 저장소에서 이러한 구성을 설정했고 해당 저장소를 가리 키도록 포도 구성 (grapeConfig.xml 사용) 또는 &lt;code&gt;@GrabConfig&lt;/code&gt; 주석을 변경했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d1a60e2fa853eacff28c12440dec49c56afecdc7" translate="yes" xml:space="preserve">
          <source>The contents of the String builder.</source>
          <target state="translated">문자열 빌더의 컨텐츠입니다.</target>
        </trans-unit>
        <trans-unit id="4a4aab4772591a45dec107fd2e9fe47875d2b895" translate="yes" xml:space="preserve">
          <source>The contents of the character sequence</source>
          <target state="translated">문자 시퀀스의 내용</target>
        </trans-unit>
        <trans-unit id="f665bdf073d546e255843bb7fa9544a62b7c4f16" translate="yes" xml:space="preserve">
          <source>The current implementation will trigger specialized events in the following scenarios, you need not register a different listener as those events extend from PropertyChangeEvent</source>
          <target state="translated">현재 구현은 다음 시나리오에서 특수 이벤트를 트리거하므로 해당 이벤트가 PropertyChangeEvent에서 확장되므로 다른 리스너를 등록 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="aa2b0935d80587b9e265b2719d52d7996bf5d785" translate="yes" xml:space="preserve">
          <source>The current phase</source>
          <target state="translated">현재 단계</target>
        </trans-unit>
        <trans-unit id="663e0af727247cd08dbfe73bff52e235110340bf" translate="yes" xml:space="preserve">
          <source>The custom base script may implement the run() method and specify a different method name to be used for the script body by declaring a single abstract method. For example:</source>
          <target state="translated">사용자 지정 기본 스크립트는 run () 메서드를 구현하고 단일 추상 메서드를 선언하여 스크립트 본문에 사용할 다른 메서드 이름을 지정할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="f2e34c2c7e5c999db4a0824f8059bf7756113c7d" translate="yes" xml:space="preserve">
          <source>The custom loader is used when parsing the template code</source>
          <target state="translated">템플릿 코드를 구문 분석 할 때 사용자 정의 로더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1ca6098954c43f913ba3c64e90df8088c2b564b2" translate="yes" xml:space="preserve">
          <source>The deepest cause of the exception that can be found</source>
          <target state="translated">찾을 수있는 예외의 가장 깊은 원인</target>
        </trans-unit>
        <trans-unit id="8fed7a59b4c24557c03efc1e169c4b5b8e3c0cd8" translate="yes" xml:space="preserve">
          <source>The default implementation allows mutation of MetaClass instances before initialisation (before the initialize() method is called) but not after, thus ensuring Thread safety once a MetaClass has been constructed and placed in the registry</source>
          <target state="translated">기본 구현은 초기화 전 (initialization () 메서드가 호출되기 전)이 아닌 MetaClass 인스턴스의 변형을 허용하므로 MetaClass가 생성되고 레지스트리에 배치되면 스레드 안전성을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="0369a08ef21d243b44db8e7fa19111fcc8106a0b" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;a href=&quot;../../../../../groovy/transform/typechecked&quot;&gt;TypeChecked&lt;/a&gt;.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;../../../../../groovy/transform/typechecked&quot;&gt;TypeChecked를&lt;/a&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ccbd3d0c31dab791dfc78e2ee441f1186a903c8a" translate="yes" xml:space="preserve">
          <source>The default implementation returns the result of calling &lt;a href=&quot;#visitChildren&quot;&gt;visitChildren&lt;/a&gt; on &lt;code&gt;ctx&lt;/code&gt;.</source>
          <target state="translated">기본 구현은 &lt;code&gt;ctx&lt;/code&gt; 에서&lt;a href=&quot;#visitChildren&quot;&gt;visitChildren&lt;/a&gt; 을 호출 한 결과를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b8c93b782d28b18159b4ef7fb9a86d95ab87ba8d" translate="yes" xml:space="preserve">
          <source>The default initial capacity</source>
          <target state="translated">기본 초기 용량</target>
        </trans-unit>
        <trans-unit id="921bbe96047cd5f5e009f6b1a8b71ad284e53cc5" translate="yes" xml:space="preserve">
          <source>The default initial number of table slots for this table (32).</source>
          <target state="translated">이 테이블에 대한 기본 초기 테이블 슬롯 수 (32).</target>
        </trans-unit>
        <trans-unit id="2a0235f2f6bc645bf5e53f460b490ce2caa3598a" translate="yes" xml:space="preserve">
          <source>The default initial number of table slots for this table (32). Used when not otherwise specified in constructor.</source>
          <target state="translated">이 테이블에 대한 기본 초기 테이블 슬롯 수 (32). 생성자에 달리 지정되지 않은 경우 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cd047e4711d4b6317b4497793f156661db1b11a1" translate="yes" xml:space="preserve">
          <source>The default load factor</source>
          <target state="translated">기본 부하율</target>
        </trans-unit>
        <trans-unit id="b4e8b83f74be0aa4cd12586b4ecddbda8abb74e9" translate="yes" xml:space="preserve">
          <source>The default source encoding.</source>
          <target state="translated">기본 소스 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="2156c83dec97c28b53d21a341f92ef1aa0daaa7b" translate="yes" xml:space="preserve">
          <source>The default type checking handler is used by the standard type checker and doesn't handle any of the type checking errors by default. This just means that whenever a type checking error is detected, there's no additional information available to the type checker that could help it. The default handler is also capable of handling a collection of delegate handlers. If a list of delegates is set, then the type checker will try all the delegates until one is capable of handling an error.</source>
          <target state="translated">기본 유형 검사 핸들러는 표준 유형 검사기에서 사용되며 기본적으로 유형 검사 오류를 처리하지 않습니다. 이것은 유형 검사 오류가 감지 될 때마다이를 도울 수있는 유형 검사기에서 사용할 수있는 추가 정보가 없음을 의미합니다. 기본 처리기는 또한 위임 처리기 컬렉션을 처리 할 수 ​​있습니다. 대리자 목록이 설정된 경우 유형 검사기는 오류를 처리 할 수있을 때까지 모든 대리자를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="c93ee9502a59a55344833d10b6e63692489f009a" translate="yes" xml:space="preserve">
          <source>The default value for this option as a String; subject to type conversion and 'convert'.</source>
          <target state="translated">이 옵션의 기본값은 문자열입니다. 유형 변환 및 '변환'이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a739b1ad38b841cd2fa04a8074ef1077da23a9a2" translate="yes" xml:space="preserve">
          <source>The default value for this option as a String; subject to type conversion and 'convert'. Ignored for Boolean options.</source>
          <target state="translated">이 옵션의 기본값은 문자열입니다. 유형 변환 및 '변환'이 적용됩니다. 부울 옵션에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0bac4f7d3a0265af4cdda31389b94208873f3c79" translate="yes" xml:space="preserve">
          <source>The delegate type is either the type of the annotated field (or property) or the return type of the annotated method. The method can be thought of as a getter or factory method for the delegate. All public instance methods present in the delegate type and not present in the owner class will be added to owner class at compile time. The implementation of such automatically added methods is code which calls through to the delegate as per the normal delegate pattern.</source>
          <target state="translated">대리자 유형은 주석이 달린 필드 (또는 속성)의 유형이거나 주석이 달린 메서드의 반환 유형입니다. 메서드는 델리게이트에 대한 getter 또는 factory 메서드로 생각할 수 있습니다. 대리자 유형에 있고 소유자 클래스에는없는 모든 공용 인스턴스 메서드는 컴파일 타임에 소유자 클래스에 추가됩니다. 이러한 자동 추가 메서드의 구현은 일반 대리자 패턴에 따라 대리자를 호출하는 코드입니다.</target>
        </trans-unit>
        <trans-unit id="0af551f931ca1824e6ae59d39c1f9fdc65593c1b" translate="yes" xml:space="preserve">
          <source>The delegate used when invoking closures</source>
          <target state="translated">클로저를 호출 할 때 사용되는 델리게이트</target>
        </trans-unit>
        <trans-unit id="da5a481646fd9ab2048ec3c70d70d40fc4c25698" translate="yes" xml:space="preserve">
          <source>The description for the remaining non-option arguments</source>
          <target state="translated">나머지 비 옵션 인수에 대한 설명</target>
        </trans-unit>
        <trans-unit id="60c01151d0f392e7605b5a47b38d319dce929d2b" translate="yes" xml:space="preserve">
          <source>The description of this option</source>
          <target state="translated">이 옵션에 대한 설명</target>
        </trans-unit>
        <trans-unit id="acf047b88dc904eaceac2bf0ff491efd1167e629" translate="yes" xml:space="preserve">
          <source>The document filter based on Parrot's lexer is for highlighting the content of text editor</source>
          <target state="translated">Parrot의 렉서를 기반으로하는 문서 필터는 텍스트 편집기의 내용을 강조하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="8897ab667aaab473e278c1a7493c2f1a2afa6c06" translate="yes" xml:space="preserve">
          <source>The empty args call will create a key whose value will be an empty JSON object:</source>
          <target state="translated">빈 args 호출은 값이 빈 JSON 객체가 될 키를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4732dbf3c3fe3c33d319cd5d0d9b4500c95066cc" translate="yes" xml:space="preserve">
          <source>The empty args call will create a key whose value will be an empty YAML object:</source>
          <target state="translated">빈 args 호출은 값이 빈 YAML 객체가되는 키를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="83bac1c4520db67dc9f9751222ec424f3e1dcdc8" translate="yes" xml:space="preserve">
          <source>The encoding as returned by the underlying OutputStreamWriter.</source>
          <target state="translated">기본 OutputStreamWriter에서 반환 한 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="7209071caba4b5b26858a3a9b872daaeac068996" translate="yes" xml:space="preserve">
          <source>The encoding as returned by the underlying OutputStreamWriter. Can be the historical name.</source>
          <target state="translated">기본 OutputStreamWriter에서 반환 한 인코딩입니다. 역사적 이름이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b32ee3e8c38d4c93010daac30bf6c76f82e10a7e" translate="yes" xml:space="preserve">
          <source>The encoding as returned by the underlying OutputStreamWriter. Will be the preferred name.</source>
          <target state="translated">기본 OutputStreamWriter에서 반환 한 인코딩입니다. 선호하는 이름이됩니다.</target>
        </trans-unit>
        <trans-unit id="c4a1b6c77417175321e74a3e09c3c5bfa3b1a669" translate="yes" xml:space="preserve">
          <source>The example below shows the various possible use cases:</source>
          <target state="translated">아래 예는 가능한 다양한 사용 사례를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="cda0c1c869121c0516b4b7eef52cfb72926a1f0c" translate="yes" xml:space="preserve">
          <source>The exit code.</source>
          <target state="translated">종료 코드.</target>
        </trans-unit>
        <trans-unit id="507fe61a8f648672fa6038e5dfbc9edeb36a23b2" translate="yes" xml:space="preserve">
          <source>The expanded toString() of this CharSequence</source>
          <target state="translated">이 CharSequence의 확장 된 toString ()</target>
        </trans-unit>
        <trans-unit id="c2d08e701963d2aabc470d83a9d8da90b7362df5" translate="yes" xml:space="preserve">
          <source>The extension method registry is responsible for collecting methods (or static methods) which are added to existing classes and may be called like regular methods.</source>
          <target state="translated">확장 메서드 레지스트리는 기존 클래스에 추가되고 일반 메서드처럼 호출 될 수있는 메서드 (또는 정적 메서드)를 수집하는 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="aa6754ebfc303c012b03fb4abba3b5f12ccb8b6c" translate="yes" xml:space="preserve">
          <source>The extension of the artifact (normally safe to leave at default value of &quot;jar&quot; but other values like &quot;zip&quot; are sometimes useful).</source>
          <target state="translated">아티팩트의 확장 (일반적으로 기본값 인 &quot;jar&quot;로 두는 것이 안전하지만 &quot;zip&quot;과 같은 다른 값이 유용한 경우도 있음).</target>
        </trans-unit>
        <trans-unit id="2e641d1d3bf6e1800547d3ef352762fcba029ed7" translate="yes" xml:space="preserve">
          <source>The extra grab configuration.</source>
          <target state="translated">추가 그랩 구성.</target>
        </trans-unit>
        <trans-unit id="4cd2c5f11d6d27f858d5d3dc59a3083f35bfd20b" translate="yes" xml:space="preserve">
          <source>The field of this property</source>
          <target state="translated">이 속성의 필드</target>
        </trans-unit>
        <trans-unit id="b234649fde6d931b7e01052a7041604ee37062c4" translate="yes" xml:space="preserve">
          <source>The first argument of the method is only used to tell the class for which we add a static method. You can now define an extension module:</source>
          <target state="translated">메서드의 첫 번째 인수는 정적 메서드를 추가 할 클래스를 알리는 데만 사용됩니다. 이제 확장 모듈을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f1c3d2c6a3794b89910b38b5fc0a80c1e72651e" translate="yes" xml:space="preserve">
          <source>The first element returned by the Iterable's iterator is returned. If the Iterable doesn't guarantee a defined order it may appear like a random element is returned.</source>
          <target state="translated">Iterable의 반복자가 반환 한 첫 번째 요소가 반환됩니다. Iterable이 정의 된 순서를 보장하지 않으면 임의의 요소가 반환되는 것처럼 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f788a50cfac60f792deddd7ec215420ae4c26518" translate="yes" xml:space="preserve">
          <source>The following attributes are optional.</source>
          <target state="translated">다음 속성은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="7a78a58b8d15f66560b1ee62392912456c7f7d2b" translate="yes" xml:space="preserve">
          <source>The following code is generated:</source>
          <target state="translated">다음 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c6db6ec58fab215cd6939fb661b05cc65eb0427a" translate="yes" xml:space="preserve">
          <source>The following example describes a closure as accepting a single signature (List&amp;lt;T&amp;gt; list -&amp;gt;):</source>
          <target state="translated">다음 예제에서는 단일 서명 (List &amp;lt;T&amp;gt; list-&amp;gt;)을 수락하는 것으로 클로저를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1deb2c32e07a91866a38699ca2b5e5576a8b7889" translate="yes" xml:space="preserve">
          <source>The following example shows how you can use this annotation on fields of a class:</source>
          <target state="translated">다음 예제는 클래스의 필드에서이 주석을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="38490d2869c131045bab21ff7ca6b124ab7e1e94" translate="yes" xml:space="preserve">
          <source>The following is an example usage. Note that within a &quot;with&quot; block you need to specify a parameter name so that this.println is not called instead of IndentPrinter.println:</source>
          <target state="translated">다음은 사용 예입니다. IndentPrinter.println 대신 this.println이 호출되지 않도록 &quot;with&quot;블록 내에서 매개 변수 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb6e88658d6aafa0e1c5fb88a8e22112ec44c060" translate="yes" xml:space="preserve">
          <source>The following is sample usage of the annotation forcing the script to timeout after 5 minutes (300 seconds):</source>
          <target state="translated">다음은 5 분 (300 초) 후에 스크립트가 시간 초과되도록하는 주석의 샘플 사용입니다.</target>
        </trans-unit>
        <trans-unit id="7079281a140b1fc8b280d5f645e024ae9a37bc71" translate="yes" xml:space="preserve">
          <source>The following is sample usage of the annotation:</source>
          <target state="translated">다음은 주석의 샘플 사용입니다.</target>
        </trans-unit>
        <trans-unit id="879e99e6a011963f4f6df39ba4aa585918568fcd" translate="yes" xml:space="preserve">
          <source>The following properties are referenced when setting the configuration:</source>
          <target state="translated">구성을 설정할 때 다음 속성이 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="20f832237a68dcebeb6521dde3b85b13bd8f5117" translate="yes" xml:space="preserve">
          <source>The following scenarios can not set accessible, i.e. the return value is false 1) SecurityException occurred 2) the accessible object is a Constructor object for the Class class</source>
          <target state="translated">다음 시나리오는 액세스 가능으로 설정할 수 없습니다. 즉, 반환 값이 false입니다. 1) SecurityException이 발생했습니다. 2) 액세스 가능한 객체가 Class 클래스에 대한 생성자 객체입니다.</target>
        </trans-unit>
        <trans-unit id="5775c2755497d25926312a1fe22b019fe16dce69" translate="yes" xml:space="preserve">
          <source>The following servlet init parameter name can be used to specify the encoding TemplateServlet will use to read the template groovy source files:</source>
          <target state="translated">다음 서블릿 초기화 매개 변수 이름을 사용하여 TemplateServlet이 템플릿 그루비 소스 파일을 읽는 데 사용할 인코딩을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c10ecb3564857baa02ca7a4bdd0fbed3c5fdf34" translate="yes" xml:space="preserve">
          <source>The following shows all of the different syntax forms supported by the node.</source>
          <target state="translated">다음은 노드에서 지원하는 다양한 구문 형식을 모두 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="402c79945cb622bc852b23a63a5a225b6b97c510" translate="yes" xml:space="preserve">
          <source>The following system properties are referenced when setting the configuration optimization options:</source>
          <target state="translated">구성 최적화 옵션을 설정할 때 다음 시스템 속성이 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="589daf472d87f60da3820df2375540a65850b000" translate="yes" xml:space="preserve">
          <source>The following will be output:</source>
          <target state="translated">다음이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="3affea3413fcaa516e9b68e8682b4216a488ecf1" translate="yes" xml:space="preserve">
          <source>The found MetaProperty or null if it doesn't exist</source>
          <target state="translated">발견 된 MetaProperty 또는 존재하지 않는 경우 null</target>
        </trans-unit>
        <trans-unit id="363824e3df035b97ca5a7ffba69200b946d3b768" translate="yes" xml:space="preserve">
          <source>The functionality provided by tr can be achieved using regular expressions but tr provides a much more compact notation and efficient implementation for certain scenarios.</source>
          <target state="translated">tr에서 제공하는 기능은 정규식을 사용하여 얻을 수 있지만 tr은 특정 시나리오에 대해 훨씬 더 간결한 표기법과 효율적인 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8f49e8b4f671d3af1ab3b54839c50c3ad9cb19cd" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;equals&lt;/code&gt; and &lt;code&gt;canEqual&lt;/code&gt; methods will be something like below:</source>
          <target state="translated">생성 된 &lt;code&gt;equals&lt;/code&gt; 및 &lt;code&gt;canEqual&lt;/code&gt; 메소드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="016adc8430975ce5b3714e3f00410813056eb5c1" translate="yes" xml:space="preserve">
          <source>The generated &lt;code&gt;toString&lt;/code&gt; will include property names and exclude the &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; properties.</source>
          <target state="translated">생성 된 &lt;code&gt;toString&lt;/code&gt; 은 속성 이름을 포함하고 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 속성을 제외합니다 .</target>
        </trans-unit>
        <trans-unit id="36d5e288e1f29d364f8118145d20f640ba8a3434" translate="yes" xml:space="preserve">
          <source>The generated Groovy class will:</source>
          <target state="translated">생성 된 Groovy 클래스는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="6ed368a0eaa66dbac47a9b89c0164f8d4c95bba4" translate="yes" xml:space="preserve">
          <source>The generated equals method will be something like below:</source>
          <target state="translated">생성 된 equals 메소드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d1e1567f7025b7a32483c0df7c9b9df0c6d2e4e" translate="yes" xml:space="preserve">
          <source>The generated map constructor will have an argument of type &lt;code&gt;Map&lt;/code&gt; unless a single property (or field) is included and the type of that property (or field) is Object, AbstractMap, Map or HashMap. In this case, the generated constructor will be of type &lt;code&gt;LinkedHashMap&lt;/code&gt;. This allows the possibility of also adding a tuple constructor without conflict, although no such constructor is added automatically. You can disable this behavior by setting the specialNamedArgHandling annotation attribute to false. This means that for the special case mentioned above, you will not be able to also add a tuple constructor with a single Map argument but you can supply any kind of map as your argument. We'd also recommend not having both a map constructor and a tuple constructor with a single Object, AbstractMap or HashMap since it can cause confusion as to which will be called.</source>
          <target state="translated">생성 된 맵 생성자는 단일 속성 (또는 필드)이 포함되지 않고 해당 속성 (또는 필드)의 유형이 Object, AbstractMap, Map 또는 HashMap이 아닌 경우 &lt;code&gt;Map&lt;/code&gt; 유형의 인수를 갖습니다 . 이 경우 생성 된 생성자는 &lt;code&gt;LinkedHashMap&lt;/code&gt; 유형이됩니다.. 이렇게하면 자동으로 추가되는 생성자가 없지만 충돌없이 튜플 생성자를 추가 할 수도 있습니다. specialNamedArgHandling 주석 속성을 false로 설정하여이 동작을 비활성화 할 수 있습니다. 즉, 위에서 언급 한 특수한 경우에 단일 Map 인수로 튜플 생성자를 추가 할 수는 없지만 모든 종류의 맵을 인수로 제공 할 수 있습니다. 또한 하나의 Object, AbstractMap 또는 HashMap이있는지도 생성자와 튜플 생성자를 모두 사용하지 않는 것이 좋습니다. 어느 것이 호출 될지 혼동을 일으킬 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2054e20238e38cbabff60cf87d59cd3bda71ca2d" translate="yes" xml:space="preserve">
          <source>The generated method/constructor retains the visibility and return type of the original method/constructor but the &lt;a href=&quot;visibilityoptions&quot;&gt;VisibilityOptions&lt;/a&gt; annotation can be added to customize the visibility. You could have the annotated method/constructor private for instance but have the generated one be public.</source>
          <target state="translated">생성 된 메서드 / 생성자는 원래 메서드 / 생성자의 가시성과 반환 유형을 유지하지만 &lt;a href=&quot;visibilityoptions&quot;&gt;가시성&lt;/a&gt; 을 사용자 지정하기 위해 VisibilityOptions 주석을 추가 할 수 있습니다. 예를 들어 주석이 달린 메서드 / 생성자를 비공개로 만들 수 있지만 생성 된 것을 공개로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d8c55bbbf0e4e8d80618bab6f8e1e859dd3d404" translate="yes" xml:space="preserve">
          <source>The generated methods must not already exist</source>
          <target state="translated">생성 된 메소드는 이미 존재하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="c757fafc4af8d85241ca605d29734fb8e7040c3a" translate="yes" xml:space="preserve">
          <source>The groovy.lang.Closure will be given the class name as parameter. the return value decides if the element will be added or not.</source>
          <target state="translated">groovy.lang.Closure에는 클래스 이름이 매개 변수로 제공됩니다. 반환 값은 요소를 추가할지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="73d792c97d713c524a35ad9cb7269ec2f224a2f7" translate="yes" xml:space="preserve">
          <source>The groovy.mock.interceptor is an all-groovy mock testing library.</source>
          <target state="translated">groovy.mock.interceptor는 모든 그루비 모의 테스트 라이브러리입니다.</target>
        </trans-unit>
        <trans-unit id="d08cb5974fee471582bb6c391e801a198206f54c" translate="yes" xml:space="preserve">
          <source>The handle should be registered with the Groovy runtime &lt;strong&gt;before&lt;/strong&gt; Groovy loads, for example in your main method. &lt;code&gt;GroovySystem.metaClassRegistry.metaClassCreationHandle = new ExpandoMetaClassCreationHandle()&lt;/code&gt;</source>
          <target state="translated">핸들은 Groovy가로드 &lt;strong&gt;되기 전에&lt;/strong&gt; 예를 들어 메인 메서드에서 Groovy 런타임에 등록되어야합니다 . &lt;code&gt;GroovySystem.metaClassRegistry.metaClassCreationHandle = new ExpandoMetaClassCreationHandle()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d7a6bf7e30e4e5adaebfa336015e1d6db546b0dc" translate="yes" xml:space="preserve">
          <source>The hash table data.</source>
          <target state="translated">해시 테이블 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="0be72dcbde8376507858e5e3b4f88ceb470819fe" translate="yes" xml:space="preserve">
          <source>The idea for this AST transformation originated in &lt;a href=&quot;../test/groovytestcase#notYetImplemented()&quot;&gt;GroovyTestCase.notYetImplemented&lt;/a&gt;.</source>
          <target state="translated">이 AST 변환에 대한 아이디어는 &lt;a href=&quot;../test/groovytestcase#notYetImplemented()&quot;&gt;GroovyTestCase.notYetImplemented&lt;/a&gt; 에서 시작되었습니다 .</target>
        </trans-unit>
        <trans-unit id="1e6b7d618961498090102436a153ea6769f4ea92" translate="yes" xml:space="preserve">
          <source>The index of the generic type that will be the type of the closure's delegate.</source>
          <target state="translated">클로저 대리자의 형식이 될 제네릭 형식의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="4a05df6a03c832914a468e9a8f09e99bb76121ca" translate="yes" xml:space="preserve">
          <source>The index of the generic type that will be the type of the closure's delegate. The generic types are considered with respect to the &lt;code&gt;@DelegatesTo.Target&lt;/code&gt; annotated parameter for this usage, with the index starting at 0.</source>
          <target state="translated">클로저 대리자의 형식이 될 제네릭 형식의 인덱스입니다. 제네릭 형식은 이 사용에 대해 &lt;code&gt;@DelegatesTo.Target&lt;/code&gt; 주석이 달린 매개 변수 와 관련하여 고려되며 인덱스는 0에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="8f4812f2fcebeff3b4ebb6e2b6159d4da2a14e7a" translate="yes" xml:space="preserve">
          <source>The initial size of the memory for the underlying VM if javac is run externally; ignored otherwise.</source>
          <target state="translated">javac가 외부에서 실행되는 경우 기본 VM에 대한 메모리의 초기 크기입니다. 그렇지 않으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9906cb8cda50e01b5fc0296c2ebddf1998c07481" translate="yes" xml:space="preserve">
          <source>The initial size of the memory for the underlying VM if javac is run externally; ignored otherwise. Defaults to the standard VM memory setting. (Examples: 83886080, 81920k, or 80m)</source>
          <target state="translated">javac가 외부에서 실행되는 경우 기본 VM에 대한 메모리의 초기 크기입니다. 그렇지 않으면 무시됩니다. 기본값은 표준 VM 메모리 설정입니다. (예 : 83886080, 81920k 또는 80m)</target>
        </trans-unit>
        <trans-unit id="09418ac5ed51e2ae7deca28347160febab7297a9" translate="yes" xml:space="preserve">
          <source>The initial value</source>
          <target state="translated">초기 값</target>
        </trans-unit>
        <trans-unit id="cca553e21f81b340e4552ee970c2d402d976a297" translate="yes" xml:space="preserve">
          <source>The interface implemented by all Groovy objects.</source>
          <target state="translated">모든 Groovy 개체에 의해 구현 된 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="d36584fdf4c93d8244b01640584ce4681a2619d4" translate="yes" xml:space="preserve">
          <source>The isCallToSuper and fromInsideClass help the Groovy runtime perform optimisations on the call to go directly to the super class if necessary</source>
          <target state="translated">isCallToSuper 및 fromInsideClass는 Groovy 런타임이 필요한 경우 수퍼 클래스로 직접 이동하기 위해 호출에서 최적화를 수행하도록 도와줍니다.</target>
        </trans-unit>
        <trans-unit id="7a7346df5fc4b24f592e6ab3da8efbdbdb2e3f57" translate="yes" xml:space="preserve">
          <source>The iterator stepped along by &lt;code&gt;num&lt;/code&gt; elements if they exist.</source>
          <target state="translated">이터레이터는 존재하는 경우 &lt;code&gt;num&lt;/code&gt; 요소를 따라 이동했습니다 .</target>
        </trans-unit>
        <trans-unit id="825771f9b59209884bd5990f89392f472ab52a1c" translate="yes" xml:space="preserve">
          <source>The java.lang.Class instance</source>
          <target state="translated">java.lang.Class 인스턴스</target>
        </trans-unit>
        <trans-unit id="39162451983f218a6022c93f55c40cf3576ffa56" translate="yes" xml:space="preserve">
          <source>The last element returned by the Iterable's iterator is returned. If the Iterable doesn't guarantee a defined order it may appear like a random element is returned.</source>
          <target state="translated">Iterable의 반복자가 반환 한 마지막 요소가 반환됩니다. Iterable이 정의 된 순서를 보장하지 않으면 임의의 요소가 반환되는 것처럼 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2b9d6958fb3428a858e3ff1b7e7d575c9444949" translate="yes" xml:space="preserve">
          <source>The lexer for Groovy programming language, which is based on the lexer generated by Antlr4</source>
          <target state="translated">Antlr4에서 생성 된 렉서를 기반으로하는 Groovy 프로그래밍 언어 용 렉서</target>
        </trans-unit>
        <trans-unit id="9bacfbe842c2f1b3272b7632dbf718566ac8d700" translate="yes" xml:space="preserve">
          <source>The lexer reads JSON tokens in a streaming fashion from the underlying reader.</source>
          <target state="translated">어휘 분석기는 기본 판독기에서 스트리밍 방식으로 JSON 토큰을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="f5ca3610dac449f90a9e358ccee55e7567cc07b1" translate="yes" xml:space="preserve">
          <source>The line.</source>
          <target state="translated">라인.</target>
        </trans-unit>
        <trans-unit id="b7ba62139a54b7638c01550fb541cf6269ed40be" translate="yes" xml:space="preserve">
          <source>The list of (classpath resources) paths to type checking DSL scripts, also known as type checking extensions.</source>
          <target state="translated">유형 검사 확장이라고도하는 유형 검사 DSL 스크립트에 대한 (classpath 리소스) 경로 목록입니다.</target>
        </trans-unit>
        <trans-unit id="e9ece14574ea4cdf3337639446998372a41bef30" translate="yes" xml:space="preserve">
          <source>The listener is invoked by &lt;a href=&quot;concurrentlinkedhashmap&quot;&gt;ConcurrentLinkedHashMap&lt;/a&gt; on a caller's thread and will not block other threads from operating on the map. An implementation should be aware that the caller's thread will not expect long execution times or failures as a side effect of the listener being notified. Execution safety and a fast turn around time can be achieved by performing the operation asynchronously, such as by submitting a task to an &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html&quot;&gt;ExecutorService&lt;/a&gt;.</source>
          <target state="translated">리스너는 호출자의 스레드에서 &lt;a href=&quot;concurrentlinkedhashmap&quot;&gt;ConcurrentLinkedHashMap&lt;/a&gt; 에 의해 호출되며 다른 스레드가 맵에서 작동하는 것을 차단하지 않습니다. 구현은 호출자의 스레드가 알림을받는 리스너의 부작용으로 긴 실행 시간이나 실패를 예상하지 않는다는 점을 인식해야합니다. &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html&quot;&gt;ExecutorService에&lt;/a&gt; 작업을 제출하는 것과 같이 작업을 비동기 적으로 수행하여 실행 안전성과 빠른 처리 시간을 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47f12bc7a7163b88b7c40a6143c735e189ed9d15" translate="yes" xml:space="preserve">
          <source>The load factor for the hash table.</source>
          <target state="translated">해시 테이블의 부하율입니다.</target>
        </trans-unit>
        <trans-unit id="24eb861382bd4ecd59d0d7b27ffc4a02974042ef" translate="yes" xml:space="preserve">
          <source>The long name of this option.</source>
          <target state="translated">이 옵션의 긴 이름입니다.</target>
        </trans-unit>
        <trans-unit id="16e53b8a2be8a710bfb615e37e77de8bcde7fbfe" translate="yes" xml:space="preserve">
          <source>The long name of this option. Defaults to the name of member being annotated.</source>
          <target state="translated">이 옵션의 긴 이름입니다. 어노테이션을 작성할 멤버의 이름이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="a1c14e51c7082ed212704f80fa16a5caa5f4b2e7" translate="yes" xml:space="preserve">
          <source>The lower value in the range.</source>
          <target state="translated">범위에서 더 낮은 값입니다.</target>
        </trans-unit>
        <trans-unit id="d70a0a182db9bd82ea7fc6368b0f23fdc024a4f0" translate="yes" xml:space="preserve">
          <source>The main class code visitor responsible for static type checking. It will perform various inspections like checking assignment types, type inference, ... Eventually, class nodes may be annotated with inferred type information.</source>
          <target state="translated">정적 유형 검사를 담당하는 기본 클래스 코드 방문자입니다. 할당 유형 확인, 유형 추론 등과 같은 다양한 검사를 수행합니다. 결국 클래스 노드는 추론 된 유형 정보로 주석을 달 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a35d780b7b7d71330b5a704f00aff27069bd32b6" translate="yes" xml:space="preserve">
          <source>The main function of the registry If a meta class exists then return it otherwise create one, put it in the registry and return it</source>
          <target state="translated">레지스트리의 주요 기능 메타 클래스가 존재하면 반환하고 그렇지 않으면 하나를 생성하고 레지스트리에 넣고 반환</target>
        </trans-unit>
        <trans-unit id="e07dbd7ee535fe35b6529b949ce03a3cdd12de16" translate="yes" xml:space="preserve">
          <source>The main instance method of a script which has variables in scope as defined by the current &lt;a href=&quot;binding&quot;&gt;Binding&lt;/a&gt; instance.</source>
          <target state="translated">현재 &lt;a href=&quot;binding&quot;&gt;Binding&lt;/a&gt; 인스턴스에 정의 된 범위에 변수가있는 스크립트의 기본 인스턴스 메서드입니다 .</target>
        </trans-unit>
        <trans-unit id="a25dec9e9a77a814a53504ab23b75ca4e697cf0f" translate="yes" xml:space="preserve">
          <source>The map values are the normal values provided as the second parameter to &lt;code&gt;java.util.Calendar#set(int, int)&lt;/code&gt;. The keys can either be the normal fields values provided as the first parameter to that method or one of the following Strings:</source>
          <target state="translated">맵 값은 &lt;code&gt;java.util.Calendar#set(int, int)&lt;/code&gt; 두 번째 매개 변수로 제공되는 일반 값 입니다. 키는 해당 메소드의 첫 번째 매개 변수로 제공된 일반 필드 값이거나 다음 문자열 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="731e1e3475853eb36e2f419522ace251acd1d87b" translate="yes" xml:space="preserve">
          <source>The maximum elapsed time the script will be allowed to run for.</source>
          <target state="translated">스크립트 실행이 허용되는 최대 경과 시간입니다.</target>
        </trans-unit>
        <trans-unit id="8a9744c288c3ec0b1b71c029102e0ca0c0c4e606" translate="yes" xml:space="preserve">
          <source>The maximum elapsed time the script will be allowed to run for. By default it is measure in seconds</source>
          <target state="translated">스크립트 실행이 허용되는 최대 경과 시간입니다. 기본적으로 초 단위로 측정됩니다.</target>
        </trans-unit>
        <trans-unit id="4c2ffed2aec71628097d548244a5403333d478d2" translate="yes" xml:space="preserve">
          <source>The maximum number of directory levels when recursing (default is -1 which means infinite, set to 0 for no recursion)</source>
          <target state="translated">되풀이 할 때 디렉터리 수준의 최대 수 (기본값은 무한을 의미하는 -1, 재귀가 없으면 0으로 설정 됨)</target>
        </trans-unit>
        <trans-unit id="a3d134d4c35a591a550b0133ec3ffcec626a2ca1" translate="yes" xml:space="preserve">
          <source>The maximum size of the memory for the underlying VM if javac is run externally; ignored otherwise.</source>
          <target state="translated">javac가 외부에서 실행되는 경우 기본 VM의 최대 메모리 크기입니다. 그렇지 않으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d53256043cb34b5f9af6acb675b49a62d63df5c8" translate="yes" xml:space="preserve">
          <source>The maximum size of the memory for the underlying VM if javac is run externally; ignored otherwise. Defaults to the standard VM memory setting. (Examples: 83886080, 81920k, or 80m)</source>
          <target state="translated">javac가 외부에서 실행되는 경우 기본 VM의 최대 메모리 크기입니다. 그렇지 않으면 무시됩니다. 기본값은 표준 VM 메모리 설정입니다. (예 : 83886080, 81920k 또는 80m)</target>
        </trans-unit>
        <trans-unit id="be8a261b2c86bdec542c4bdc16f3f9b00cf90718" translate="yes" xml:space="preserve">
          <source>The maximum size the cache can grow to.</source>
          <target state="translated">캐시가 증가 할 수있는 최대 크기입니다.</target>
        </trans-unit>
        <trans-unit id="a932fa7b6f4119b32f6b4708d0afeedb86270516" translate="yes" xml:space="preserve">
          <source>The mechanics: during compilation, all methods are transformed to static ones with an additional self parameter of the type you supply as the annotation parameter (the default type for the self parameters is &lt;code&gt;Object&lt;/code&gt; which might be more broad reaching than you like so it is usually wise to specify a type). Properties invoked using 'this' references are transformed so that they are instead invoked on the additional self parameter and not on the Category instance. (Remember that once the category is applied, the reverse will occur and we will be back to conceptually having methods on the &lt;code&gt;this&lt;/code&gt; references again!)</source>
          <target state="translated">메커니즘 : 컴파일하는 동안 모든 메서드는 주석 매개 변수로 제공 한 유형의 추가 self 매개 변수를 사용하여 정적 메소드로 변환됩니다 (자체 매개 변수의 기본 유형은 &lt;code&gt;Object&lt;/code&gt; 이며 원하는 것보다 더 광범위하게 도달 할 수 있으므로 일반적으로 유형을 지정하는 것이 좋습니다). 'this'참조를 사용하여 호출 된 속성은 대신 Category 인스턴스가 아닌 추가 self 매개 변수에서 호출되도록 변환됩니다. (카테고리가 적용되면, 반대가 발생하고 우리가 개념적으로 메소드 데 돌아올 것이다 기억 &lt;code&gt;this&lt;/code&gt; 다시 참조를!)</target>
        </trans-unit>
        <trans-unit id="2666c74280324e9c05645b343443d5ae919ca593" translate="yes" xml:space="preserve">
          <source>The message is a little cryptic, but it is basically the static compiler telling us that the third parameter, &lt;code&gt;age&lt;/code&gt; in our case, is unset. You can also add this annotation to your predefined constructors. These will be made private and an initializer will be set up to call your constructor. Any parameters to your constructor become the properties expected by the initializer. If you use such a builder on a constructor as well as on the class or on more than one constructor, then it is up to you to define unique values for 'builderClassName' and 'builderMethodName' for each annotation.</source>
          <target state="translated">메시지는 약간 모호하지만 기본적으로 세 번째 매개 변수 인 &lt;code&gt;age&lt;/code&gt; 가 설정되지 않았 음을 알려주는 정적 컴파일러 입니다. 이 주석을 사전 정의 된 생성자에 추가 할 수도 있습니다. 이것들은 비공개로 만들어지고 이니셜 라이저가 생성자를 호출하도록 설정됩니다. 생성자에 대한 모든 매개 변수는 이니셜 라이저에서 예상하는 속성이됩니다. 생성자뿐만 아니라 클래스 또는 둘 이상의 생성자에서 이러한 빌더를 사용하는 경우 각 주석에 대해 'builderClassName'및 'builderMethodName'에 대한 고유 값을 정의하는 것은 사용자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="233f1eda634fadbf2d6de9fdbba96a43cfac37b3" translate="yes" xml:space="preserve">
          <source>The meta map generated.</source>
          <target state="translated">생성 된 메타 맵.</target>
        </trans-unit>
        <trans-unit id="481ab6cb4af59496e16e981430f5212574c520b3" translate="yes" xml:space="preserve">
          <source>The method &quot;is&quot; is used to test for equal references.</source>
          <target state="translated">&quot;is&quot;메서드는 동일한 참조를 테스트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="10a0b965a2d07d42bb108200564cd0092fef8a4b" translate="yes" xml:space="preserve">
          <source>The method &quot;is&quot; is used to test for equal references. This method will return true only if the given parameter is null</source>
          <target state="translated">&quot;is&quot;메서드는 동일한 참조를 테스트하는 데 사용됩니다. 이 메소드는 주어진 매개 변수가 null 인 경우에만 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="046b59ea660985a374595a12ce69c4e51a167400" translate="yes" xml:space="preserve">
          <source>The method descriptor of the method from the trait</source>
          <target state="translated">트레이 트의 메서드 설명자</target>
        </trans-unit>
        <trans-unit id="0b11d5e3b0af8fe608284cd9acdeefcad67a7934" translate="yes" xml:space="preserve">
          <source>The method is invoked when an AST Transformation is active.</source>
          <target state="translated">이 메서드는 AST Transformation이 활성화 될 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3ad8ddc19cf1fe16c4946011a31c3d7615aae395" translate="yes" xml:space="preserve">
          <source>The method is invoked when an AST Transformation is active. For local transformations, it is invoked once each time the local annotation is encountered. For global transformations, it is invoked once for every source unit, which is typically a source file.</source>
          <target state="translated">이 메서드는 AST Transformation이 활성화 될 때 호출됩니다. 로컬 변환의 경우 로컬 주석이 발생할 때마다 한 번씩 호출됩니다. 전역 변환의 경우 일반적으로 소스 파일 인 모든 소스 단위에 대해 한 번씩 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="16096b1fa8363d7f7f3486f5931631ff7821604c" translate="yes" xml:space="preserve">
          <source>The method is similar with &lt;a href=&quot;genericsutils#makeDeclaringAndActualGenericsTypeMap(org.codehaus.groovy.ast.ClassNode,%20org.codehaus.groovy.ast.ClassNode)&quot;&gt;GenericsUtils.makeDeclaringAndActualGenericsTypeMap&lt;/a&gt;, The main difference is that the method will try to map all placeholders found to the relevant exact types, but the other will not try even if the parameterized type has placeholders</source>
          <target state="translated">이 메서드는 &lt;a href=&quot;genericsutils#makeDeclaringAndActualGenericsTypeMap(org.codehaus.groovy.ast.ClassNode,%20org.codehaus.groovy.ast.ClassNode)&quot;&gt;GenericsUtils.makeDeclaringAndActualGenericsTypeMap&lt;/a&gt; 과 유사합니다 . 주요 차이점은 메서드가 찾은 모든 자리 표시자를 관련 정확한 형식에 매핑하려고 시도하지만 다른 하나는 매개 변수가있는 형식에 자리 표시자가 있어도 시도하지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ebd121539032d1aa634563f13cd1d7bb73f83b33" translate="yes" xml:space="preserve">
          <source>The method name</source>
          <target state="translated">메서드 이름</target>
        </trans-unit>
        <trans-unit id="9107c6d41421afd6c4262deaacc88cd7b897fd8a" translate="yes" xml:space="preserve">
          <source>The method name to use for a builder factory method in the source class for easy access of the builder helper class for strategies which create such a helper class.</source>
          <target state="translated">이러한 헬퍼 클래스를 생성하는 전략에 대한 빌더 헬퍼 클래스에 쉽게 액세스 할 수 있도록 소스 클래스의 빌더 팩토리 메소드에 사용할 메소드 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d156486b828194de0dc1376f435a69303f46b5c6" translate="yes" xml:space="preserve">
          <source>The method name to use for a builder factory method in the source class for easy access of the builder helper class for strategies which create such a helper class. Must not be used if using &lt;code&gt;forClass&lt;/code&gt;. Default is determined by the strategy, e.g. &lt;em&gt;builder&lt;/em&gt; or &lt;em&gt;createInitializer&lt;/em&gt;.</source>
          <target state="translated">이러한 헬퍼 클래스를 생성하는 전략에 대한 빌더 헬퍼 클래스에 쉽게 액세스 할 수 있도록 소스 클래스의 빌더 팩토리 메소드에 사용할 메소드 이름입니다. &lt;code&gt;forClass&lt;/code&gt; 를 사용하는 경우 사용해서는 안됩니다 . 기본값은 전략 (예 : &lt;em&gt;builder&lt;/em&gt; 또는 &lt;em&gt;createInitializer)에&lt;/em&gt; 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="19190b8bf1a50223552a2ea9092d0e868f9b58bb" translate="yes" xml:space="preserve">
          <source>The method omits padding and is equivalent to calling &lt;a href=&quot;encodinggroovymethods#encodeBase64Url(Byte%5B%5D,%20boolean)&quot;&gt;EncodingGroovyMethods.encodeBase64Url&lt;/a&gt; with a value of &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 메서드는 패딩을 생략 하고 값이 &lt;code&gt;false&lt;/code&gt; 인&lt;a href=&quot;encodinggroovymethods#encodeBase64Url(Byte%5B%5D,%20boolean)&quot;&gt;EncodingGroovyMethods.encodeBase64Url&lt;/a&gt; 을 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fd16bad639c8dbfe1c2afb5d210c9fca412a986a" translate="yes" xml:space="preserve">
          <source>The method omits padding and is equivalent to calling &lt;a href=&quot;encodinggroovymethods#encodeBase64Url(byte%5B%5D,%20boolean)&quot;&gt;EncodingGroovyMethods.encodeBase64Url&lt;/a&gt; with a value of &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이 메서드는 패딩을 생략 하고 값이 &lt;code&gt;false&lt;/code&gt; 인&lt;a href=&quot;encodinggroovymethods#encodeBase64Url(byte%5B%5D,%20boolean)&quot;&gt;EncodingGroovyMethods.encodeBase64Url&lt;/a&gt; 을 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="977caf0a01596f416e854564419eecf39b01c39d" translate="yes" xml:space="preserve">
          <source>The method returns</source>
          <target state="translated">이 메서드는</target>
        </trans-unit>
        <trans-unit id="233550ffa2aace49d6789bba08354b9269776fba" translate="yes" xml:space="preserve">
          <source>The methods found in this class are made directly available in type checking scripts through the &lt;a href=&quot;groovytypecheckingextensionsupport&quot;&gt;GroovyTypeCheckingExtensionSupport&lt;/a&gt; class.</source>
          <target state="translated">이 클래스에있는 메서드는 &lt;a href=&quot;groovytypecheckingextensionsupport&quot;&gt;GroovyTypeCheckingExtensionSupport&lt;/a&gt; 클래스를 통해 유형 검사 스크립트에서 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f7b0d22db711005969846defb7c99717fa91841" translate="yes" xml:space="preserve">
          <source>The modified implementation is based on StringUtils#replace(String text, String searchString, String replacement, int max), Apache commons-lang3-3.6</source>
          <target state="translated">수정 된 구현은 StringUtils # replace (String text, String searchString, String replacement, int max), Apache commons-lang3-3.6을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="50fbba6f75c792f1af5c5472d076319e1dc8e8c0" translate="yes" xml:space="preserve">
          <source>The module or artifact, e.g.: &quot;ant-junit&quot;.</source>
          <target state="translated">모듈 또는 아티팩트 (예 : &quot;ant-junit&quot;).</target>
        </trans-unit>
        <trans-unit id="9ecf7b850507e5a2a96948e13f72e6da5a6b2250" translate="yes" xml:space="preserve">
          <source>The module or artifact, e.g.: &quot;ant-junit&quot;. A non-empty value is required unless value() is used.</source>
          <target state="translated">모듈 또는 아티팩트 (예 : &quot;ant-junit&quot;). value ()를 사용하지 않는 한 비어 있지 않은 값이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8998068077ca7885c0e4186f470a1345f7bcaabe" translate="yes" xml:space="preserve">
          <source>The module or artifact, e.g.: &quot;ant-junit&quot;; required unless the compact form is used.</source>
          <target state="translated">모듈 또는 아티팩트, 예 : &quot;ant-junit&quot;; 컴팩트 한 형태가 사용되지 않는 한 필요합니다.</target>
        </trans-unit>
        <trans-unit id="67b83bce5d6428054b151a952a38c76fc1400e95" translate="yes" xml:space="preserve">
          <source>The name of the command.</source>
          <target state="translated">명령의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="43aae32f2ac7a4701fa066c8a7276ef64ed1c079" translate="yes" xml:space="preserve">
          <source>The name of the property. The name is &quot;get&quot;+ the capitalized propertyName or, in the case of boolean values, &quot;is&quot; + the capitalized propertyName</source>
          <target state="translated">속성의 이름입니다. 이름은 &quot;get&quot;+ 대문자 propertyName 또는 부울 값의 경우 &quot;is&quot;+ 대문자 propertyName입니다.</target>
        </trans-unit>
        <trans-unit id="38191355c55cbbc00969fffa25036a9e046325a0" translate="yes" xml:space="preserve">
          <source>The name of the property. The name is &quot;set&quot;+ the capitalized propertyName.</source>
          <target state="translated">속성의 이름입니다. 이름은 &quot;set&quot;+ 대문자로 된 propertyName입니다.</target>
        </trans-unit>
        <trans-unit id="a15c19401cb99e1843f9f1f65dd9a34cd037b984" translate="yes" xml:space="preserve">
          <source>The new MetaClass</source>
          <target state="translated">새로운 MetaClass</target>
        </trans-unit>
        <trans-unit id="ce3d1a75c8717139ff820f7f834e634eaf7a158b" translate="yes" xml:space="preserve">
          <source>The newly created Calendar</source>
          <target state="translated">새로 생성 된 캘린더</target>
        </trans-unit>
        <trans-unit id="c75c777743c28c6ddb34992b6df6f585ae387f8b" translate="yes" xml:space="preserve">
          <source>The newly created Date</source>
          <target state="translated">새로 만든 날짜</target>
        </trans-unit>
        <trans-unit id="343fa99691cb8eb1227394b817b70099749bdacd" translate="yes" xml:space="preserve">
          <source>The next example describes a closure as accepting two signatures (List&amp;lt;T&amp;gt; list -&amp;gt;) and (T t -&amp;gt;):</source>
          <target state="translated">다음 예제에서는 두 개의 서명 (List &amp;lt;T&amp;gt; list-&amp;gt;) 및 (T t-&amp;gt;)을 허용하는 것으로 클로저를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="35ccc24e2e75124aaac905d871e93bf9a5f09134" translate="yes" xml:space="preserve">
          <source>The node must be called with either a value argument or a title: attribute.</source>
          <target state="translated">노드는 값 인수 또는 title : 속성으로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="032b81eac6a8ead6bf3bea51101baeb3b3e0d8f0" translate="yes" xml:space="preserve">
          <source>The number of characters actually skipped</source>
          <target state="translated">실제로 건너 뛴 문자 수</target>
        </trans-unit>
        <trans-unit id="3c9016a339d21ce2a804e220ce7a8e37661b04db" translate="yes" xml:space="preserve">
          <source>The number of characters read or -1 if there are no more</source>
          <target state="translated">읽은 문자 수 또는 더 이상없는 경우 -1</target>
        </trans-unit>
        <trans-unit id="ecf5ab475eeef8fcb49643a9532fa7b4dc7af88a" translate="yes" xml:space="preserve">
          <source>The number of characters read, or -1 if the end of the stream has been reached</source>
          <target state="translated">읽은 문자 수 또는 스트림 끝에 도달 한 경우 -1</target>
        </trans-unit>
        <trans-unit id="0f80b964b2a13be3af83a2b98edb531c0a483f10" translate="yes" xml:space="preserve">
          <source>The number of needed instructions is thus reduced from 15 to 4. For every entry we save 3 bytecode instructions. This allows better readable bytecode and it allows the JIT to see less bytecode to optimize, helping under the inlining threshold here or there.</source>
          <target state="translated">따라서 필요한 명령어의 수는 15 개에서 4 개로 줄어 듭니다. 모든 항목에 대해 3 개의 바이트 코드 명령어를 저장합니다. 이를 통해 더 읽기 쉬운 바이트 코드를 사용할 수 있으며 JIT가 최적화 할 바이트 코드를 더 적게 볼 수 있으므로 여기 저기에서 인라인 임계 값 아래에 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="d66cf7d98d8141c6d3db9afd12ffdb8fc3310252" translate="yes" xml:space="preserve">
          <source>The object holding the data value.</source>
          <target state="translated">데이터 값을 보유하는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="850f532ee8584882c8e75e990fb14ebbbde70875" translate="yes" xml:space="preserve">
          <source>The object that registers method calls on it for the use with Mocks and Stubs. For each call a CallSpec object is added to the recorded list.</source>
          <target state="translated">메서드를 등록하는 개체는 Mocks 및 Stubs와 함께 사용하기 위해 메서드를 호출합니다. 각 호출에 대해 CallSpec 개체가 녹음 된 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4375205097b015888ab65280d3b96851ded2b956" translate="yes" xml:space="preserve">
          <source>The old MetaClass</source>
          <target state="translated">이전 MetaClass</target>
        </trans-unit>
        <trans-unit id="58e4156ceefaea5d9509b6380a238b14d924e012" translate="yes" xml:space="preserve">
          <source>The oldest entry(i.e. the Less Recently Used entry) will be evicted</source>
          <target state="translated">가장 오래된 항목 (예 : 덜 최근에 사용한 항목)이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2dd46ef926874e9055f1e4cf7568213be97d6b34" translate="yes" xml:space="preserve">
          <source>The one and only implementation of a meta class. INTERNAL USE ONLY.</source>
          <target state="translated">메타 클래스의 유일한 구현입니다. 내부 용.</target>
        </trans-unit>
        <trans-unit id="91a1c774e1d0fe1b0b5303c859052c21b6258376" translate="yes" xml:space="preserve">
          <source>The one-sentence summary for the package derived from the beginning of the description.</source>
          <target state="translated">설명의 시작 부분에서 파생 된 패키지에 대한 한 문장 요약입니다.</target>
        </trans-unit>
        <trans-unit id="9b73f8f765fe9a956ade4dde4833c77ee65e1eb9" translate="yes" xml:space="preserve">
          <source>The only difference between Java strings and JavaScript strings is that in JavaScript, a single quote must be escaped.</source>
          <target state="translated">Java 문자열과 JavaScript 문자열의 유일한 차이점은 JavaScript에서 작은 따옴표를 이스케이프해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="39accb2b332a1b9e56c3ee6ac627961ec2636b16" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;interceptConstruction&lt;/code&gt; flag allows mocking of constructor calls.</source>
          <target state="translated">선택적 &lt;code&gt;interceptConstruction&lt;/code&gt; 플래그를 사용하면 생성자 호출을 조롱 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2144302020ab0d839d4af265778a87ee9caa1988" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;interceptConstruction&lt;/code&gt; flag allows mocking of constructor calls. These are represented in the demand specification using the class name as this example shows:</source>
          <target state="translated">선택적 &lt;code&gt;interceptConstruction&lt;/code&gt; 플래그를 사용하면 생성자 호출을 조롱 할 수 있습니다. 이 예제는 다음과 같이 클래스 이름을 사용하여 수요 사양에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d46ce745b7d040a6af0b7952e782405f90be5a6f" translate="yes" xml:space="preserve">
          <source>The optional parameter for tags like &quot;throws&quot; and &quot;param&quot;.</source>
          <target state="translated">&quot;throws&quot;및 &quot;param&quot;과 같은 태그에 대한 선택적 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="7e32f979195511f753ad4cf62e43dcd18cd136c7" translate="yes" xml:space="preserve">
          <source>The options array is used to modify the behavior of this hint. Each string in the option array consists of a key=value pair.</source>
          <target state="translated">옵션 배열은이 힌트의 동작을 수정하는 데 사용됩니다. 옵션 배열의 각 문자열은 키 = 값 쌍으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7b48b46c9d0ec14ed87e0211dbb48b950e8e8d55" translate="yes" xml:space="preserve">
          <source>The order of parameters is given by the properties of any super classes (if &lt;code&gt;includeSuperProperties&lt;/code&gt; is set) with the most super first followed by the properties of the class followed by the fields of the class (if &lt;code&gt;includeFields&lt;/code&gt; is set). Within each grouping the order is as attributes appear within the respective class.</source>
          <target state="translated">매개 변수의 순서는 수퍼 클래스 ( &lt;code&gt;includeSuperProperties&lt;/code&gt; 가 설정된 경우)의 속성에 따라 지정됩니다. 가장 먼저 수퍼 클래스가오고 클래스의 속성과 클래스의 필드 ( &lt;code&gt;includeFields&lt;/code&gt; 가 설정된 경우)가 뒤 따릅니다 . 각 그룹 내에서 순서는 각 클래스 내에 나타나는 속성과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5fbc45ad553a921f8843e5823598f573c5e856ec" translate="yes" xml:space="preserve">
          <source>The organisation or group, e.g.: &quot;org.apache.ant&quot;.</source>
          <target state="translated">조직 또는 그룹 (예 : &quot;org.apache.ant&quot;).</target>
        </trans-unit>
        <trans-unit id="adc438730ea65642ec0cc71f1ada8471e6f24d75" translate="yes" xml:space="preserve">
          <source>The organisation or group, e.g.: &quot;org.apache.ant&quot;. A non-empty value is required unless value() is used.</source>
          <target state="translated">조직 또는 그룹 (예 : &quot;org.apache.ant&quot;). value ()를 사용하지 않는 한 비어 있지 않은 값이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5c1050236f9bfcb9f997fc983fb0d67f42762c0d" translate="yes" xml:space="preserve">
          <source>The organisation or group, e.g.: &quot;org.apache.ant&quot;; required unless the compact form is used.</source>
          <target state="translated">조직 또는 그룹, 예 : &quot;org.apache.ant&quot;; 컴팩트 한 형태가 사용되지 않는 한 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cf0ae96fdb2085b66ea3bb93836f5dbda67d76df" translate="yes" xml:space="preserve">
          <source>The original AST or null if it cannot be returned</source>
          <target state="translated">원래 AST 또는 반환 할 수없는 경우 null</target>
        </trans-unit>
        <trans-unit id="463c8561d710e01b478880e4165ed134de96d70b" translate="yes" xml:space="preserve">
          <source>The original Throwable but with a sanitized stack trace</source>
          <target state="translated">원래 Throwable이지만 정리 된 스택 추적이 있습니다.</target>
        </trans-unit>
        <trans-unit id="550e2fe2cda92d999ef8b8744582f726ca7d70d3" translate="yes" xml:space="preserve">
          <source>The original slurper and lexer use this class. This is kept around in case someone needs its exact behavior. Enum listing all the possible JSON tokens that should be recognized by the lexer.</source>
          <target state="translated">원래 slurper와 lexer는이 클래스를 사용합니다. 누군가가 정확한 행동을 필요로 할 경우에 대비해 보관됩니다. 어휘 분석기가 인식해야하는 가능한 모든 JSON 토큰을 나열하는 열거 형입니다.</target>
        </trans-unit>
        <trans-unit id="4cf6c32888a66c7be9b42c3c4ddc926c89cf2d2d" translate="yes" xml:space="preserve">
          <source>The other typical usage, uses the self object while creating some value:</source>
          <target state="translated">다른 일반적인 사용법은 몇 가지 값을 생성하는 동안 self 객체를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ca0fdc2ddc244d43905d142929aaff47d915c14d" translate="yes" xml:space="preserve">
          <source>The other way is to add annotations to the alias:</source>
          <target state="translated">다른 방법은 별칭에 주석을 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f9e8045bb0c75ecafe6640585dfaad1f947bcf4b" translate="yes" xml:space="preserve">
          <source>The owning shell.</source>
          <target state="translated">소유 셸.</target>
        </trans-unit>
        <trans-unit id="74c2e67b95c48b05cb96c4651b224ecc651abf77" translate="yes" xml:space="preserve">
          <source>The parser for Groovy programming language, which is based on the parser generated by Antlr4</source>
          <target state="translated">Antlr4에서 생성 된 파서를 기반으로하는 Groovy 프로그래밍 언어 용 파서</target>
        </trans-unit>
        <trans-unit id="c4db92f843c33741921f53930bfa252393bdb5ad" translate="yes" xml:space="preserve">
          <source>The particular unit decremented by depends on the specific sub-type of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html&quot;&gt;Temporal&lt;/a&gt;. Most sub-types use a unit of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#SECONDS&quot;&gt;ChronoUnit.SECONDS&lt;/a&gt; except for</source>
          <target state="translated">감소하는 특정 단위는 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html&quot;&gt;Temporal&lt;/a&gt; 의 특정 하위 유형에 따라 다릅니다 . 대부분의 하위 유형의 단위 사용 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#SECONDS&quot;&gt;ChronoUnit.SECONDS를&lt;/a&gt; 제외하고</target>
        </trans-unit>
        <trans-unit id="0931b94d8ae13c47b9a85df31fbc353bf2a74861" translate="yes" xml:space="preserve">
          <source>The particular unit incremented by depends on the specific sub-type of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html&quot;&gt;Temporal&lt;/a&gt;. Most sub-types use a unit of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#SECONDS&quot;&gt;ChronoUnit.SECONDS&lt;/a&gt; except for</source>
          <target state="translated">증가하는 특정 단위는 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/Temporal.html&quot;&gt;Temporal&lt;/a&gt; 의 특정 하위 유형에 따라 다릅니다 . 대부분의 하위 유형의 단위 사용 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoUnit.html#SECONDS&quot;&gt;ChronoUnit.SECONDS를&lt;/a&gt; 제외하고</target>
        </trans-unit>
        <trans-unit id="e3baee579d0f99a112462a4af57608a9a896b5c9" translate="yes" xml:space="preserve">
          <source>The permission groovy.security.GroovyCodeSourcePermission will be used to determine if the given codeBase may be specified. That is, the current Policy set must have a GroovyCodeSourcePermission that implies the codeBase, or an exception will be thrown. This is to prevent callers from hijacking existing codeBase policy entries unless explicitly authorized by the user.</source>
          <target state="translated">groovy.security.GroovyCodeSourcePermission 권한은 주어진 codeBase가 지정 될 수 있는지 결정하는 데 사용됩니다. 즉, 현재 정책 세트에는 codeBase를 의미하는 GroovyCodeSourcePermission이 있어야합니다. 그렇지 않으면 예외가 발생합니다. 이는 사용자가 명시 적으로 승인하지 않는 한 호출자가 기존 codeBase 정책 항목을 가로채는 것을 방지하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="b23c39fbfa279511d3e7fc40992076c646fe704c" translate="yes" xml:space="preserve">
          <source>The phases as an array, with a null entry.</source>
          <target state="translated">널 항목이있는 배열로서의 위상.</target>
        </trans-unit>
        <trans-unit id="5a50aa1f415a2950a9c3ea1c28386340df92373c" translate="yes" xml:space="preserve">
          <source>The phases of the GroovyCompiler. This is an enum facade on top of the Phases object. In general, prefer using this object over Phases.</source>
          <target state="translated">GroovyCompiler의 단계. 이것은 Phases 객체 위에있는 열거 형 파사드입니다. 일반적으로이 개체를 단계보다 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d0555c21af552adf2c625446c48cfa44d487360f" translate="yes" xml:space="preserve">
          <source>The position of the curried parameters will be calculated eagerly and implies all arguments prior to the specified n index are supplied. Default parameter values prior to the n index will not be available.</source>
          <target state="translated">커리 매개 변수의 위치는 열심히 계산되며 지정된 n 인덱스 이전의 모든 인수가 제공됨을 의미합니다. n 인덱스 이전의 기본 매개 변수 값은 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b99f34149701f4f317b757b6f7be07e6c77a0502" translate="yes" xml:space="preserve">
          <source>The position of the curried parameters will be calculated lazily, for example, if two overloaded doCall methods are available, the supplied arguments plus the curried arguments will be concatenated and the result used for method selection.</source>
          <target state="translated">커리 매개 변수의 위치는 느리게 계산됩니다. 예를 들어 두 개의 오버로드 된 doCall 메소드를 사용할 수있는 경우 제공된 인수와 커리 된 인수가 연결되고 결과가 메소드 선택에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d4d57362120a781eed62a17257a436f5c3b9c1de" translate="yes" xml:space="preserve">
          <source>The position tree of multi-line comments.</source>
          <target state="translated">여러 줄 주석의 위치 트리입니다.</target>
        </trans-unit>
        <trans-unit id="3d2d8d4480d18b9fc0a2174c8cfea817348cc881" translate="yes" xml:space="preserve">
          <source>The prefix to use when creating the setter methods.</source>
          <target state="translated">setter 메서드를 만들 때 사용할 접두사입니다.</target>
        </trans-unit>
        <trans-unit id="6dec45555f03c899ffc22df52915fd879b9c58b0" translate="yes" xml:space="preserve">
          <source>The prefix to use when creating the setter methods. Default is determined by the strategy which might use &quot;&quot; or &quot;set&quot; but you can choose your own, e.g. &quot;with&quot;. If non-empty the first letter of the property will be capitalized before being appended to the prefix.</source>
          <target state="translated">setter 메서드를 만들 때 사용할 접두사입니다. 기본값은 &quot;&quot;또는 &quot;set&quot;을 사용할 수있는 전략에 의해 결정되지만 &quot;with&quot;와 같이 사용자가 직접 선택할 수 있습니다. 비어 있지 않으면 속성의 첫 글자가 접두사에 추가되기 전에 대문자로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c03948908d1373a091dc6fd5073476e494fdead0" translate="yes" xml:space="preserve">
          <source>The problem this annotation tries to solve is to define the expected parameter types of the</source>
          <target state="translated">이 주석이 해결하려는 문제는 예상되는 매개 변수 유형을 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="404ee7e80d97420044d8572424c53f96977d7292" translate="yes" xml:space="preserve">
          <source>The produced code for the above example looks like this:</source>
          <target state="translated">위의 예제에서 생성 된 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66d47ea438a29f8f03b670b0bcbb6770f0998399" translate="yes" xml:space="preserve">
          <source>The properties to use can be filtered using either the 'includes' or 'excludes' annotation attributes for &lt;code&gt;@Builder&lt;/code&gt;. The &lt;code&gt;@Builder&lt;/code&gt; 'buildMethodName' annotation attribute can be used for configuring the build method's name, default &quot;build&quot;. The &lt;code&gt;@Builder&lt;/code&gt; 'builderMethodName' and 'builderClassName' annotation attributes aren't applicable for this strategy. The &lt;code&gt;@Builder&lt;/code&gt; 'useSetters' annotation attribute is ignored by this strategy which always uses setters.</source>
          <target state="translated">사용할 속성은 &lt;code&gt;@Builder&lt;/code&gt; 에 대한 'includes'또는 'excludes'주석 속성을 사용하여 필터링 할 수 있습니다 . &lt;code&gt;@Builder&lt;/code&gt; 'buildMethodName'주석 속성은 빌드 방법의 이름, 기본 &quot;빌드&quot;를 구성하는 데 사용할 수 있습니다. &lt;code&gt;@Builder&lt;/code&gt; 'builderMethodName'와 'builderClassName'주석 속성은이 전략을 적용 할 수 없습니다. &lt;code&gt;@Builder&lt;/code&gt; 'useSetters'주석 속성은 항상 세터를 사용하는이 전략에 의해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0bccb759e3c0e6e0247c634660331a9f94034269" translate="yes" xml:space="preserve">
          <source>The properties value</source>
          <target state="translated">속성 값</target>
        </trans-unit>
        <trans-unit id="d776cd3bdbba7c1073d917e7c7a9132e4549183f" translate="yes" xml:space="preserve">
          <source>The properties within the class must themselves be &lt;code&gt;Comparable&lt;/code&gt; or &lt;code&gt;@Sortable&lt;/code&gt;.</source>
          <target state="translated">클래스 내의 속성 자체는 &lt;code&gt;Comparable&lt;/code&gt; 또는 &lt;code&gt;@Sortable&lt;/code&gt; 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="7ed4236c8f797aaa8636050cfd80ec30bfeeed44" translate="yes" xml:space="preserve">
          <source>The property handler class which creates the necessary code for getting, setting or initializing properties.</source>
          <target state="translated">속성 가져 오기, 설정 또는 초기화에 필요한 코드를 만드는 속성 처리기 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="5c2099cb7601f141e152a819c05e4db6c35a60d7" translate="yes" xml:space="preserve">
          <source>The property name equivalent</source>
          <target state="translated">동등한 속성 이름</target>
        </trans-unit>
        <trans-unit id="068bd70d79a0f3161e77c6b20503123007a1632e" translate="yes" xml:space="preserve">
          <source>The property to set on compilation failure.</source>
          <target state="translated">컴파일 실패시 설정할 속성입니다.</target>
        </trans-unit>
        <trans-unit id="1bed8d7b5a8bdc81a2320b7e7824add1844ac6dc" translate="yes" xml:space="preserve">
          <source>The property to set on compilation failure. This property will be set if the compilation fails.</source>
          <target state="translated">컴파일 실패시 설정할 속성입니다. 이 속성은 컴파일이 실패하면 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b106043c5c6468760b416e5a4f5dc8142c486625" translate="yes" xml:space="preserve">
          <source>The property to set on compilation success.</source>
          <target state="translated">컴파일 성공시 설정할 속성입니다.</target>
        </trans-unit>
        <trans-unit id="39baf3f1877fa6a76dce4eda62ece0b8909c7323" translate="yes" xml:space="preserve">
          <source>The property to set on compilation success. This property will not be set if the compilation fails, or if there are no files to compile.</source>
          <target state="translated">컴파일 성공시 설정할 속성입니다. 이 속성은 컴파일이 실패하거나 컴파일 할 파일이없는 경우 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc70b9bacce6273f76ef6e4471c4dab865527fa7" translate="yes" xml:space="preserve">
          <source>The purpose is the reduction of the size of the bytecode. Consider creating a three element Object[] with null values:</source>
          <target state="translated">목적은 바이트 코드의 크기를 줄이는 것입니다. null 값을 사용하여 세 가지 요소 Object []를 만드는 것을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="666faa1948c36e5a23029d8167b7a82bae76aa8a" translate="yes" xml:space="preserve">
          <source>The qualified name including any dimension information.</source>
          <target state="translated">차원 정보를 포함하는 규정 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="98b1825554dc394c8049d1d532250cea4ed423f2" translate="yes" xml:space="preserve">
          <source>The qualified name including any dimension information. For example, a two dimensional array of String returns &quot;&lt;code&gt;java.lang.String[][]&lt;/code&gt;&quot;, and the parameterized type &lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt; returns &quot;&lt;code&gt;java.util.List&amp;lt;java.lang.Integer&amp;gt;&lt;/code&gt;&quot;.</source>
          <target state="translated">차원 정보를 포함하는 규정 된 이름입니다. 예를 들어, String의 2 차원 배열은 &quot; &lt;code&gt;java.lang.String[][]&lt;/code&gt; &quot;을 리턴 하고 매개 변수화 된 유형 &lt;code&gt;List&amp;lt;Integer&amp;gt;&lt;/code&gt; 는 &quot; &lt;code&gt;java.util.List&amp;lt;java.lang.Integer&amp;gt;&lt;/code&gt; &quot;를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="6749c09dae1f16ee309de33291725a38354b80c1" translate="yes" xml:space="preserve">
          <source>The qualified name of this type excluding any dimension information.</source>
          <target state="translated">차원 정보를 제외한이 유형의 규정 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5524ad7e8d6e056655d2c24925da6512f7f6b810" translate="yes" xml:space="preserve">
          <source>The qualified name of this type excluding any dimension information. For example, a two dimensional array of String returns &quot;&lt;code&gt;java.lang.String&lt;/code&gt;&quot;.</source>
          <target state="translated">차원 정보를 제외한이 유형의 규정 된 이름입니다. 예를 들어, 2 차원 String 배열은 &quot; &lt;code&gt;java.lang.String&lt;/code&gt; &quot;을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="afc755459d1d6c162948ac88fb407664086e913e" translate="yes" xml:space="preserve">
          <source>The recommended way of securing shells is to use allowed lists because it is guaranteed that future features of the Groovy language won't be accidentally allowed unless explicitly added to the allowed list. Using disallowed lists, you can limit the features of the language constructs supported by your shell by opting out, but new language features are then implicitly also available and this may not be desirable. The implication is that you might need to update your configuration with each new release.</source>
          <target state="translated">셸을 보호하는 권장되는 방법은 허용 목록에 명시 적으로 추가하지 않는 한 Groovy 언어의 향후 기능이 실수로 허용되지 않도록 보장되므로 허용 목록을 사용하는 것입니다. 허용되지 않는 목록을 사용하면 선택 해제하여 셸에서 지원하는 언어 구조의 기능을 제한 할 수 있지만 새 언어 기능도 암시 적으로 사용할 수 있으므로 바람직하지 않을 수 있습니다. 이는 각각의 새 릴리스로 구성을 업데이트해야 할 수도 있다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="7890a44bd59bb88228f8c74508210c196c09f718" translate="yes" xml:space="preserve">
          <source>The replace method to use on the matcher.</source>
          <target state="translated">matcher에서 사용할 대체 방법입니다.</target>
        </trans-unit>
        <trans-unit id="2d65383712d8a239399641a0d18670d69f0cea91" translate="yes" xml:space="preserve">
          <source>The replacement used by the resource name matcher.</source>
          <target state="translated">리소스 이름 매처에서 사용하는 대체입니다.</target>
        </trans-unit>
        <trans-unit id="183b2d9cf750ef4356762e7761f879eb6c2e10e8" translate="yes" xml:space="preserve">
          <source>The resgistry</source>
          <target state="translated">레지스트리</target>
        </trans-unit>
        <trans-unit id="8b60066e74974428693cf317396c392559fe4dcf" translate="yes" xml:space="preserve">
          <source>The resolve strategy</source>
          <target state="translated">해결 전략</target>
        </trans-unit>
        <trans-unit id="d6a1ea6deab0be8f01a56df21bf7e874402baa48" translate="yes" xml:space="preserve">
          <source>The result is a closure which can have the following forms:</source>
          <target state="translated">결과는 다음과 같은 형태를 가질 수있는 클로저입니다.</target>
        </trans-unit>
        <trans-unit id="f8073c98c26e1541e605cf9192ccb46ebece88e7" translate="yes" xml:space="preserve">
          <source>The result of the merge</source>
          <target state="translated">병합의 결과</target>
        </trans-unit>
        <trans-unit id="b4fd3dd77a58f818d8c3faf56a7c1b1b58fac08e" translate="yes" xml:space="preserve">
          <source>The result of the propertyMissing method or throws MissingPropertyException</source>
          <target state="translated">propertyMissing 메서드의 결과 또는 MissingPropertyException 발생</target>
        </trans-unit>
        <trans-unit id="becf539a2208e344834f816674f2d5fcf96548ba" translate="yes" xml:space="preserve">
          <source>The resulting translated &lt;code&gt;String&lt;/code&gt;</source>
          <target state="translated">결과로 번역 된 &lt;code&gt;String&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c1d34dfb3088ea17d04b40b40c5f003d8f05e4fe" translate="yes" xml:space="preserve">
          <source>The results of methodMissing or throws MissingMethodException</source>
          <target state="translated">methodMissing의 결과 또는 MissingMethodException 발생</target>
        </trans-unit>
        <trans-unit id="476c927d4d90fe65f6bab20cb57f17b4834562dd" translate="yes" xml:space="preserve">
          <source>The return value of the invocation</source>
          <target state="translated">호출의 반환 값</target>
        </trans-unit>
        <trans-unit id="f772844e69ffcc0220695a141278b4ea7430de9f" translate="yes" xml:space="preserve">
          <source>The return value of the invoked method.</source>
          <target state="translated">호출 된 메서드의 반환 값입니다.</target>
        </trans-unit>
        <trans-unit id="62d80f160e3301c563f71de2f15701a15461fe3a" translate="yes" xml:space="preserve">
          <source>The return value of the method</source>
          <target state="translated">메서드의 반환 값</target>
        </trans-unit>
        <trans-unit id="d97df77d5d16cf6f0d57a6d6752ee61825a4cc88" translate="yes" xml:space="preserve">
          <source>The return value of the method which is null if the return type is void</source>
          <target state="translated">반환 유형이 void 인 경우 null 인 메서드의 반환 값</target>
        </trans-unit>
        <trans-unit id="8583dcdd18eee679eec49286a13176c4259a5294" translate="yes" xml:space="preserve">
          <source>The returning parameter is commonly set to true when using with to simplify object creation, such as this example:</source>
          <target state="translated">반환 매개 변수는 일반적으로 with를 사용하여 객체 생성을 단순화 할 때 다음 예와 같이 true로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="875acf317a8f8529a69052fe176958b2bd26bb44" translate="yes" xml:space="preserve">
          <source>The revision or version, e.g.: &quot;1.7.1&quot;.</source>
          <target state="translated">개정 또는 버전 (예 : &quot;1.7.1&quot;).</target>
        </trans-unit>
        <trans-unit id="5cd485b893e87dd0b6efe0f84be74a2b0e50d049" translate="yes" xml:space="preserve">
          <source>The revision or version, e.g.: &quot;1.7.1&quot;. A non-empty value is required unless value() is used.</source>
          <target state="translated">개정 또는 버전 (예 : &quot;1.7.1&quot;). value ()를 사용하지 않는 한 비어 있지 않은 값이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7c207af991fb99091fa8f287c2da7adabb871197" translate="yes" xml:space="preserve">
          <source>The right way to use it for JUnit 3 is:</source>
          <target state="translated">JUnit 3에서 사용하는 올바른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d858a85c56dc4b03eac0fe169dc4fa68051e7d8" translate="yes" xml:space="preserve">
          <source>The root cause exception instance, with its stace trace modified to filter out groovy runtime classes</source>
          <target state="translated">근본 원인 예외 인스턴스, 그루비 런타임 클래스를 필터링하기 위해 수정 된 상태 추적</target>
        </trans-unit>
        <trans-unit id="865af8ea215cefa5991c9cc5122354fadb48bb74" translate="yes" xml:space="preserve">
          <source>The root cause exception instances, with stack trace modified to filter out groovy runtime classes</source>
          <target state="translated">근본 원인 예외 인스턴스 (그루비 런타임 클래스를 필터링하도록 수정 된 스택 추적 포함)</target>
        </trans-unit>
        <trans-unit id="e93c1b520cbd7836f0f8c1b4fd013c4e8d1129b1" translate="yes" xml:space="preserve">
          <source>The root of the Abstract Syntax Tree for the source</source>
          <target state="translated">소스에 대한 추상 구문 트리의 루트</target>
        </trans-unit>
        <trans-unit id="67a7915a02520c39d9f254645135aa63e22bb403" translate="yes" xml:space="preserve">
          <source>The root of the lexical parsing tree.</source>
          <target state="translated">어휘 구문 분석 트리의 루트입니다.</target>
        </trans-unit>
        <trans-unit id="56fa669d54b1368623bad8fc50daad712171e89f" translate="yes" xml:space="preserve">
          <source>The short name of this option.</source>
          <target state="translated">이 옵션의 짧은 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d865d69887c0552a76349586553be28eee417b21" translate="yes" xml:space="preserve">
          <source>The short name of this option. Defaults to the name of member being annotated if the longName is empty.</source>
          <target state="translated">이 옵션의 짧은 이름입니다. longName이 비어있는 경우 주석이 추가되는 멤버의 이름이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="ba2891c2488b5c6f4342d686b2788cfdf34b392d" translate="yes" xml:space="preserve">
          <source>The shortcut switch</source>
          <target state="translated">바로 가기 스위치</target>
        </trans-unit>
        <trans-unit id="1dc02e4e7a9421805995dea237ea87f71134df23" translate="yes" xml:space="preserve">
          <source>The signature of this method</source>
          <target state="translated">이 메서드의 서명</target>
        </trans-unit>
        <trans-unit id="f1492be12bee4c707c0282e56184b32b47ef4804" translate="yes" xml:space="preserve">
          <source>The simple name of the annotation including the &quot;@&quot; or null if no such name is defined</source>
          <target state="translated">&quot;@&quot;를 포함하는 어노테이션의 단순 이름 또는 해당 이름이 정의되지 않은 경우 null</target>
        </trans-unit>
        <trans-unit id="2b4b71213506f4e0356dfd5fc20a5f6e429010dd" translate="yes" xml:space="preserve">
          <source>The source units from which this unit is built.</source>
          <target state="translated">이 단위가 빌드되는 소스 단위입니다.</target>
        </trans-unit>
        <trans-unit id="01401bd4b3d5f57ed6503d187a050f41b2a42df8" translate="yes" xml:space="preserve">
          <source>The standard use for this method is when a table has an autoincrement ID column and you want to know what the ID is for a newly inserted row. In this example, we insert a single row into a table in which the first column contains the autoincrement ID:</source>
          <target state="translated">이 방법의 표준 사용은 테이블에 자동 증가 ID 열이 있고 새로 삽입 된 행에 대한 ID를 알고 자 할 때입니다. 이 예에서는 첫 번째 열에 자동 증가 ID가 포함 된 테이블에 단일 행을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="9275509b872e0adb76980a0373cc6d87c6055af3" translate="yes" xml:space="preserve">
          <source>The stream can be for example a FileInputStream from a file with the following format:</source>
          <target state="translated">스트림은 예를 들어 다음 형식을 가진 파일의 FileInputStream 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15cc0423f1955111b4c08c47e52328fbdd00b69f" translate="yes" xml:space="preserve">
          <source>The string must be in the form returned by the QName.toString() method, i.e. &quot;{namespaceURI}localPart&quot;, with the &quot;{namespaceURI}&quot; part being optional.</source>
          <target state="translated">문자열은 QName.toString () 메서드에서 반환 된 형식이어야합니다. 즉, &quot;{namespaceURI} localPart&quot;이고 &quot;{namespaceURI}&quot;부분은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="22771b89b44cb0db24fad01ea17fe01b726ba658" translate="yes" xml:space="preserve">
          <source>The string representation of the annotation reference.</source>
          <target state="translated">주석 참조의 문자열 표현입니다.</target>
        </trans-unit>
        <trans-unit id="5e599db1ac6ef94f8579d026e88b608cf27ff8b8" translate="yes" xml:space="preserve">
          <source>The string representation of the annotation reference. Initially implemented as a temporary hack stored from the source. To be replaced with strong-typed finer grained information.</source>
          <target state="translated">주석 참조의 문자열 표현입니다. 처음에는 소스에서 저장된 임시 해킹으로 구현되었습니다. 강력한 형식의 세분화 된 정보로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="fb22d22c184c47ba3163340422accef7dd9ed1ff" translate="yes" xml:space="preserve">
          <source>The sum of all of the items</source>
          <target state="translated">모든 항목의 합계</target>
        </trans-unit>
        <trans-unit id="40d0ac42b8edc1dae134c503efef716fc53d98f4" translate="yes" xml:space="preserve">
          <source>The sum of all of the items.</source>
          <target state="translated">모든 항목의 합계입니다.</target>
        </trans-unit>
        <trans-unit id="989e25ec9928e09df7ee1acc43fc9c0880df69ad" translate="yes" xml:space="preserve">
          <source>The sum of the values returned by applying the closure to each item from the Iterator.</source>
          <target state="translated">반복기의 각 항목에 클로저를 적용하여 반환 된 값의 합계입니다.</target>
        </trans-unit>
        <trans-unit id="c9e7ecaf4ca357ee681a27b991a11fab6d65dff1" translate="yes" xml:space="preserve">
          <source>The sum of the values returned by applying the closure to each item of the Iterable.</source>
          <target state="translated">Iterable의 각 항목에 클로저를 적용하여 반환 된 값의 합계입니다.</target>
        </trans-unit>
        <trans-unit id="0e89a462ab069558ccc92abaa6becf7fe7ca0492" translate="yes" xml:space="preserve">
          <source>The sum of the values returned by applying the closure to each item of the array.</source>
          <target state="translated">배열의 각 항목에 클로저를 적용하여 반환 된 값의 합계입니다.</target>
        </trans-unit>
        <trans-unit id="e0fe680303e1ca58932bb92ab26453355acda86b" translate="yes" xml:space="preserve">
          <source>The sum of the values returned by applying the closure to each item of the collection.</source>
          <target state="translated">컬렉션의 각 항목에 클로저를 적용하여 반환 된 값의 합계입니다.</target>
        </trans-unit>
        <trans-unit id="5ca0e801895a43143eb85bd9dd3e4c911b3a6cad" translate="yes" xml:space="preserve">
          <source>The table is rehashed when its size exceeds this threshold.</source>
          <target state="translated">크기가이 임계 값을 초과하면 테이블이 다시 해시됩니다.</target>
        </trans-unit>
        <trans-unit id="8516c49e4447a484bd801473d4d78b70be591b01" translate="yes" xml:space="preserve">
          <source>The table is rehashed when its size exceeds this threshold. (The value of this field is always (int)(capacity * loadFactor).)</source>
          <target state="translated">크기가이 임계 값을 초과하면 테이블이 다시 해시됩니다. (이 필드의 값은 항상 (int) (capacity * loadFactor)입니다.)</target>
        </trans-unit>
        <trans-unit id="2509a2b15c4fec90b1a89dfc73783afc5e5011fd" translate="yes" xml:space="preserve">
          <source>The tag name, e.g.</source>
          <target state="translated">태그 이름, 예 :</target>
        </trans-unit>
        <trans-unit id="db1db9824ee90a8accc29a6f47094d8320d3122c" translate="yes" xml:space="preserve">
          <source>The tag name, e.g. &quot;deprecated&quot;, &quot;param&quot;, &quot;see&quot; or &quot;author&quot;.</source>
          <target state="translated">태그 이름 (예 : &quot;deprecated&quot;, &quot;param&quot;, &quot;see&quot;또는 &quot;author&quot;).</target>
        </trans-unit>
        <trans-unit id="bab8307ff605a63f18f27b4b6a7d097cd05e8a14" translate="yes" xml:space="preserve">
          <source>The tail of a declaration.</source>
          <target state="translated">선언의 꼬리.</target>
        </trans-unit>
        <trans-unit id="f9066d16633090f75058b4bd1ecc26ce2c11677e" translate="yes" xml:space="preserve">
          <source>The tail of a declaration. Either v1, v2, ... (with possible initializers) or else m(args){body}. The two arguments are the modifier list (if any) and the declaration head (if any). The declaration head is the variable type, or (for a method) the return type. If it is missing, then the variable type is taken from its initializer (if there is one). Otherwise, the variable type defaults to 'any'. DECIDE: Method return types default to the type of the method body, as an expression.</source>
          <target state="translated">선언의 꼬리. v1, v2, ... (가능한 이니셜 라이저 포함) 또는 m (args) {body}. 두 인수는 수정 자 목록 (있는 경우)과 선언 헤드 (있는 경우)입니다. 선언 헤드는 변수 유형 또는 (메서드의 경우) 반환 유형입니다. 누락 된 경우 이니셜 라이저에서 변수 유형을 가져옵니다 (있는 경우). 그렇지 않으면 변수 유형의 기본값은 'any'입니다. DECIDE : 메서드 반환 형식은 기본적으로 메서드 본문의 형식 인 식입니다.</target>
        </trans-unit>
        <trans-unit id="80c1cd374807e18badc9c825a6ddb035ef579c09" translate="yes" xml:space="preserve">
          <source>The template engine can also be used as the engine for &lt;a href=&quot;../servlet/templateservlet&quot;&gt;TemplateServlet&lt;/a&gt; by placing the following in your &lt;code&gt;web.xml&lt;/code&gt; file (plus a corresponding servlet-mapping element):</source>
          <target state="translated">템플릿 엔진은 &lt;code&gt;web.xml&lt;/code&gt; 파일 (및 해당 servlet-mapping 요소 포함)에 다음을 배치하여 &lt;a href=&quot;../servlet/templateservlet&quot;&gt;TemplateServlet&lt;/a&gt; 의 엔진으로 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c41f5167f4c55b11e4ca434e73cfd1cfefc8c204" translate="yes" xml:space="preserve">
          <source>The template engine makes an effort to throw descriptive exceptions with context lines, ie:</source>
          <target state="translated">템플릿 엔진은 컨텍스트 줄을 사용하여 설명적인 예외를 발생 시키려고 노력합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="b8bfd67b666067ef82bd6d072ceb9ecda1903dc6" translate="yes" xml:space="preserve">
          <source>The template engine uses JSP style &amp;lt;% %&amp;gt; script and &amp;lt;%= %&amp;gt; expression syntax or GString style expressions. The variable '&lt;code&gt;out&lt;/code&gt;' is bound to the writer that the template is being written to.</source>
          <target state="translated">템플릿 엔진은 JSP 스타일 &amp;lt;% %&amp;gt; 스크립트 및 &amp;lt;% = %&amp;gt; 표현식 구문 또는 GString 스타일 표현식을 사용합니다. ' &lt;code&gt;out&lt;/code&gt; ' 변수 는 템플릿이 기록되는 작성기에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="b1e19b0f009154f105e8d40314ebe5b64bfebc12" translate="yes" xml:space="preserve">
          <source>The template that will produce the response text.</source>
          <target state="translated">응답 텍스트를 생성 할 템플릿입니다.</target>
        </trans-unit>
        <trans-unit id="a5ff9da155da96f8ae444a0f421dd2eedfdd8503" translate="yes" xml:space="preserve">
          <source>The text associated with the tag.</source>
          <target state="translated">태그와 관련된 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="79600bf9bc91a3b3f63e7ddccbd148d4dbd124ed" translate="yes" xml:space="preserve">
          <source>The timer task which has been scheduled.</source>
          <target state="translated">예약 된 타이머 작업입니다.</target>
        </trans-unit>
        <trans-unit id="1a25852356fb8328146e29a2fd46930da5616780" translate="yes" xml:space="preserve">
          <source>The tool to simulate running script files via groovy command</source>
          <target state="translated">groovy 명령을 통해 실행중인 스크립트 파일을 시뮬레이션하는 도구</target>
        </trans-unit>
        <trans-unit id="74e34865ea7d26c8fa280a51bc74328d5c56b6b2" translate="yes" xml:space="preserve">
          <source>The total number of mappings in the hash table.</source>
          <target state="translated">해시 테이블의 총 매핑 수입니다.</target>
        </trans-unit>
        <trans-unit id="10ed76980b7be55f6560da1b7d64f4c53cb55453" translate="yes" xml:space="preserve">
          <source>The traversal can be adapted by providing various options in the &lt;code&gt;options&lt;/code&gt; Map according to the following keys:</source>
          <target state="translated">순회은 다양한 옵션을 제공하여 적용 할 수 있습니다 &lt;code&gt;options&lt;/code&gt; 지도 다음 키에 따라 :</target>
        </trans-unit>
        <trans-unit id="31d840e6eaa37d1fb137aba5bd262f3661e3cc96" translate="yes" xml:space="preserve">
          <source>The type descriptor for a method node is a string containing the name of the method, its return type, and its parameter types in a canonical form.</source>
          <target state="translated">메서드 노드의 형식 설명자는 메서드 이름, 반환 형식 및 표준 형식의 매개 변수 형식을 포함하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="60a6d9396902e7a9d90719e486b0ecba2c7fd0a1" translate="yes" xml:space="preserve">
          <source>The type descriptor for a method node is a string containing the name of the method, its return type, and its parameter types in a canonical form. For simplicity, we use the format of a Java declaration without parameter names or generics.</source>
          <target state="translated">메서드 노드의 형식 설명자는 메서드 이름, 반환 형식 및 표준 형식의 매개 변수 형식을 포함하는 문자열입니다. 간단하게하기 위해 매개 변수 이름이나 제네릭없이 Java 선언 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bfcc6988d78bb654bf23686ac195aa641257ac4b" translate="yes" xml:space="preserve">
          <source>The type member should be used when the type of the delegate cannot be represented with &lt;a href=&quot;#value()&quot;&gt;value()&lt;/a&gt;, &lt;a href=&quot;#genericTypeIndex()&quot;&gt;genericTypeIndex()&lt;/a&gt; or &lt;a href=&quot;#target()&quot;&gt;target()&lt;/a&gt;.</source>
          <target state="translated">대리자의 형식을 &lt;a href=&quot;#value()&quot;&gt;value ()&lt;/a&gt; , &lt;a href=&quot;#genericTypeIndex()&quot;&gt;genericTypeIndex ()&lt;/a&gt; 또는 &lt;a href=&quot;#target()&quot;&gt;target ()&lt;/a&gt; 로 표현할 수없는 경우 형식 멤버를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="50630842e00d8b1cbbbfcf22c64fecd77803f9f9" translate="yes" xml:space="preserve">
          <source>The type member should be used when the type of the delegate cannot be represented with &lt;a href=&quot;#value()&quot;&gt;value()&lt;/a&gt;, &lt;a href=&quot;#genericTypeIndex()&quot;&gt;genericTypeIndex()&lt;/a&gt; or &lt;a href=&quot;#target()&quot;&gt;target()&lt;/a&gt;. In this case, it is possible to use a String to represent the type, at the cost of potential uncaught errors at compile time if the type is invalid and increased compile time.</source>
          <target state="translated">대리자의 형식을 &lt;a href=&quot;#value()&quot;&gt;value ()&lt;/a&gt; , &lt;a href=&quot;#genericTypeIndex()&quot;&gt;genericTypeIndex ()&lt;/a&gt; 또는 &lt;a href=&quot;#target()&quot;&gt;target ()&lt;/a&gt; 로 표현할 수없는 경우 형식 멤버를 사용해야합니다 . 이 경우, 유형이 유효하지 않고 컴파일 시간이 늘어난 경우 컴파일 타임에 포착되지 않은 잠재적 인 오류가 발생하는 대신 String을 사용하여 유형을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bc0f50f2984205e14cb09cbea32c757feab1695" translate="yes" xml:space="preserve">
          <source>The type of exception thrown when timeout is reached.</source>
          <target state="translated">시간 초과에 도달하면 throw되는 예외 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e3db5653f498161246a313203cbeabe10b294791" translate="yes" xml:space="preserve">
          <source>The type of the artifact (normally safe to leave at default value of &quot;jar&quot; but other values like &quot;sources&quot; and &quot;javadoc&quot; are sometimes useful).</source>
          <target state="translated">아티팩트의 유형 (일반적으로 &quot;jar&quot;의 기본값으로 두는 것이 안전하지만 &quot;sources&quot;및 &quot;javadoc&quot;과 같은 다른 값이 유용한 경우도 있음).</target>
        </trans-unit>
        <trans-unit id="9c9e817a3159fb3177fbc64ceea3fd2bfa224982" translate="yes" xml:space="preserve">
          <source>The type of the artifact (normally safe to leave at default value of &quot;jar&quot; but other values like &quot;sources&quot; and &quot;javadoc&quot; are sometimes useful). But see also the &quot;classifier&quot; attribute which is also sometimes used for &quot;sources&quot; and &quot;javadoc&quot;.</source>
          <target state="translated">아티팩트의 유형 (일반적으로 &quot;jar&quot;의 기본값으로 두는 것이 안전하지만 &quot;sources&quot;및 &quot;javadoc&quot;과 같은 다른 값이 유용한 경우도 있음). 그러나 &quot;sources&quot;및 &quot;javadoc&quot;에 가끔 사용되는 &quot;classifier&quot;속성도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4ca920006f30ed914765d9c352a38d568933b700" translate="yes" xml:space="preserve">
          <source>The type of the last encountered &quot;it&quot; implicit parameter.</source>
          <target state="translated">마지막으로 발견 된 &quot;it&quot;암시 적 매개 변수의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9145cf3f9b4a0d09e2af2393fd727c71ebcbb50d" translate="yes" xml:space="preserve">
          <source>The type of the variable annotated with &lt;code&gt;@BaseScript&lt;/code&gt; must extend &lt;a href=&quot;../lang/script&quot;&gt;Script&lt;/a&gt;. It will be used as the base script class. The annotated variable will become shortcut to &lt;code&gt;this&lt;/code&gt; object. Using this annotation will override base script set by Groovy compiler or &lt;a href=&quot;../../org/codehaus/groovy/control/compilerconfiguration&quot;&gt;CompilerConfiguration&lt;/a&gt; of &lt;a href=&quot;../lang/groovyshell&quot;&gt;GroovyShell&lt;/a&gt; Example usage:</source>
          <target state="translated">&lt;code&gt;@BaseScript&lt;/code&gt; 로 주석이 달린 변수 유형은 &lt;a href=&quot;../lang/script&quot;&gt;Script&lt;/a&gt; 를 확장해야합니다 . 기본 스크립트 클래스로 사용됩니다. 주석이 달린 변수는 &lt;code&gt;this&lt;/code&gt; 개체의 바로 가기가됩니다 . 이 주석을 사용하면 그루비 컴파일러 나에 의한 기본 스크립트 세트보다 우선합니다 &lt;a href=&quot;../../org/codehaus/groovy/control/compilerconfiguration&quot;&gt;CompilerConfiguration&lt;/a&gt; 의 &lt;a href=&quot;../lang/groovyshell&quot;&gt;GroovyShell&lt;/a&gt; 사용 예제를 :</target>
        </trans-unit>
        <trans-unit id="e03953b92d1333f0ce4ca03983b13c88c5391b2e" translate="yes" xml:space="preserve">
          <source>The type of the variable annotated with &lt;code&gt;@SourceURI&lt;/code&gt; must be assignment compatible with &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/net/URI.html&quot;&gt;URI&lt;/a&gt;. It will be used to hold a URI object that references the source for the current script.</source>
          <target state="translated">&lt;code&gt;@SourceURI&lt;/code&gt; 로 주석이 달린 변수 유형은 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/net/URI.html&quot;&gt;URI&lt;/a&gt; 와 호환되는 할당이어야합니다 . 현재 스크립트의 소스를 참조하는 URI 개체를 보유하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="72e862454a23154b9c1eada46b694794e382df1f" translate="yes" xml:space="preserve">
          <source>The type on which the field was attempted to be called</source>
          <target state="translated">필드 호출을 시도한 유형</target>
        </trans-unit>
        <trans-unit id="0ed994342edba2dd4caa2ae969bfced6ca083812" translate="yes" xml:space="preserve">
          <source>The type on which the method was attempted to be called</source>
          <target state="translated">메소드 호출을 시도한 유형</target>
        </trans-unit>
        <trans-unit id="f49a0db00f8e949a09804dd63a36e2982c2bdcc0" translate="yes" xml:space="preserve">
          <source>The type on which the property was attempted to be called</source>
          <target state="translated">속성을 호출하려고 시도한 유형</target>
        </trans-unit>
        <trans-unit id="b5a0be639b682e898850486f3c19bb899731dea4" translate="yes" xml:space="preserve">
          <source>The type that could not be resolved</source>
          <target state="translated">해결할 수없는 유형</target>
        </trans-unit>
        <trans-unit id="22bda5fdc5e6227a7a0c58e47015e24d57b30c81" translate="yes" xml:space="preserve">
          <source>The underlying builder</source>
          <target state="translated">기본 빌더</target>
        </trans-unit>
        <trans-unit id="49cf8100ba29bc770b0147077438349a48624460" translate="yes" xml:space="preserve">
          <source>The underlying template engine or &lt;code&gt;null&lt;/code&gt; on error.</source>
          <target state="translated">기본 템플릿 엔진 또는 &lt;code&gt;null&lt;/code&gt; on error.</target>
        </trans-unit>
        <trans-unit id="de822d367304dba12ea8e0e5913a14a4fba0d3f8" translate="yes" xml:space="preserve">
          <source>The unescaped text</source>
          <target state="translated">이스케이프 처리되지 않은 텍스트</target>
        </trans-unit>
        <trans-unit id="66a791c097d23f087f3b2006b4a3b0840ed65768" translate="yes" xml:space="preserve">
          <source>The unqualified name of this type excluding any dimension information.</source>
          <target state="translated">차원 정보를 제외한이 유형의 규정되지 않은 이름입니다.</target>
        </trans-unit>
        <trans-unit id="932bb11f5980b36dd397c11008ff195342c0ab60" translate="yes" xml:space="preserve">
          <source>The unqualified name of this type excluding any dimension information. For example, a two dimensional array of String returns &quot;&lt;code&gt;String&lt;/code&gt;&quot;.</source>
          <target state="translated">차원 정보를 제외한이 유형의 규정되지 않은 이름입니다. 예를 들어, 2 차원 String 배열은 &quot; &lt;code&gt;String&lt;/code&gt; &quot;을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="64ffcabf1d928e33cdd955774a39dbcd5dd5d5a5" translate="yes" xml:space="preserve">
          <source>The unqualified name of this type excluding any dimension or nesting information.</source>
          <target state="translated">차원 또는 중첩 정보를 제외한이 유형의 규정되지 않은 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d7aa9ba3ba0215b9edea5f76f8e108e86c3953aa" translate="yes" xml:space="preserve">
          <source>The unqualified name of this type excluding any dimension or nesting information. For example, the class &lt;code&gt;Outer.Inner&lt;/code&gt; returns &quot;&lt;code&gt;Inner&lt;/code&gt;&quot;.</source>
          <target state="translated">차원 또는 중첩 정보를 제외한이 유형의 규정되지 않은 이름입니다. 예를 들어 &lt;code&gt;Outer.Inner&lt;/code&gt; 클래스 는 &quot; &lt;code&gt;Inner&lt;/code&gt; &quot;를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b210e5f5ae502f06e3eee85bb0d3cddc4c712ed2" translate="yes" xml:space="preserve">
          <source>The updated class</source>
          <target state="translated">업데이트 된 클래스</target>
        </trans-unit>
        <trans-unit id="b40cc89ba60352f68fafcc4ac4c159121fb14767" translate="yes" xml:space="preserve">
          <source>The upper value in the range.</source>
          <target state="translated">범위의 상한 값입니다.</target>
        </trans-unit>
        <trans-unit id="e7fce3baf91efcfcd8801fb20b926ae96377e08f" translate="yes" xml:space="preserve">
          <source>The usage message for this example (obtained using &lt;code&gt;cli.usage()&lt;/code&gt;) is shown below:</source>
          <target state="translated">이 예제의 사용법 메시지 ( &lt;code&gt;cli.usage()&lt;/code&gt; 를 사용하여 얻음 )는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b984acccdc007ab5614270b95defc6666e03e99" translate="yes" xml:space="preserve">
          <source>The valid targetBytecode values.</source>
          <target state="translated">유효한 targetBytecode 값입니다.</target>
        </trans-unit>
        <trans-unit id="26e0cfaca318b8f4da7cebac77fcdbc02f5aa88f" translate="yes" xml:space="preserve">
          <source>The value at which the range originates (may be &lt;code&gt;null&lt;/code&gt;).</source>
          <target state="translated">범위가 시작되는 값 ( &lt;code&gt;null&lt;/code&gt; 일 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="0402397f26735b2ed2400f8ddcfcc924e0ce9a91" translate="yes" xml:space="preserve">
          <source>The value can be retrieved by calling the &lt;code&gt;get&lt;/code&gt; method with a key that is equal to the original key.</source>
          <target state="translated">값은 원래 키와 동일한 키로 &lt;code&gt;get&lt;/code&gt; 메소드를 호출하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f18423b74c988542bc6f5c88a519429fcc1c89e9" translate="yes" xml:space="preserve">
          <source>The value of a QName contains a &lt;b&gt;namespaceURI&lt;/b&gt;, a &lt;b&gt;localPart&lt;/b&gt; and a &lt;b&gt;prefix&lt;/b&gt;. The localPart provides the local part of the qualified name. The namespaceURI is a URI reference identifying the namespace.</source>
          <target state="translated">QName 값에는 &lt;b&gt;namespaceURI&lt;/b&gt; , &lt;b&gt;localPart&lt;/b&gt; 및 &lt;b&gt;접두사가 포함&lt;/b&gt; 됩니다. localPart는 규정 된 이름의 로컬 부분을 제공합니다. namespaceURI는 네임 스페이스를 식별하는 URI 참조입니다.</target>
        </trans-unit>
        <trans-unit id="d581e8a0b9a8abf2d88f586b7d5f11976e2b4718" translate="yes" xml:space="preserve">
          <source>The value of the executable attribute, if any.</source>
          <target state="translated">실행 가능한 속성의 값 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="a9c238280b9b2287b4cd66fc20e8037b6edcacf3" translate="yes" xml:space="preserve">
          <source>The value returned by the script</source>
          <target state="translated">스크립트에서 반환 된 값</target>
        </trans-unit>
        <trans-unit id="87217bb3f735edd3580af114cd6ab58dbbe6f228" translate="yes" xml:space="preserve">
          <source>The value returned from the execution of the script (if supported by the Script engine)</source>
          <target state="translated">스크립트 실행에서 반환 된 값 (스크립트 엔진에서 지원하는 경우)</target>
        </trans-unit>
        <trans-unit id="d702c028dc14f7beea06e57a018660f6784af85a" translate="yes" xml:space="preserve">
          <source>The value separator for this multi-valued option.</source>
          <target state="translated">이 다중 값 옵션의 값 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="38f5980b9a59a25ffdbd05535eef7c76cba55950" translate="yes" xml:space="preserve">
          <source>The value separator for this multi-valued option. Only allowed for array-typed arguments.</source>
          <target state="translated">이 다중 값 옵션의 값 구분 기호입니다. 배열 유형 인수에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="6847d558c266cc9ad7b554d665f6eb7a61327329" translate="yes" xml:space="preserve">
          <source>The value the option should have if it did not appear on the command line. The specified String value will be split into parts with the &lt;code&gt;valueSeparator&lt;/code&gt; and converted to the option &lt;code&gt;type&lt;/code&gt; before it is set.</source>
          <target state="translated">옵션이 명령 줄에 나타나지 않은 경우 가져야하는 값입니다. 지정된 문자열 값은 &lt;code&gt;valueSeparator&lt;/code&gt; 를 사용하여 부분으로 분할되고 설정되기 전에 옵션 &lt;code&gt;type&lt;/code&gt; 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="3481a95548ae3ca973619a2db287d20033ea8206" translate="yes" xml:space="preserve">
          <source>The values of each of the attributes on the MBean</source>
          <target state="translated">MBean의 각 속성 값</target>
        </trans-unit>
        <trans-unit id="53301301b27b5840479d76543713ebc0154d3193" translate="yes" xml:space="preserve">
          <source>The xmlns namespace definition for &lt;code&gt;gsp:&lt;/code&gt; tags will be removed but other namespace definitions will be preserved (but may change to an equivalent position within the XML tree).</source>
          <target state="translated">&lt;code&gt;gsp:&lt;/code&gt; 태그에 대한 xmlns 네임 스페이스 정의는 제거되지만 다른 네임 스페이스 정의는 유지됩니다 (하지만 XML 트리 내에서 동일한 위치로 변경 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="5ba86101ce4cb5b4110e9233defd7487d64710f7" translate="yes" xml:space="preserve">
          <source>Then calling the command line with:</source>
          <target state="translated">그런 다음 다음을 사용하여 명령 줄을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="21704ce2ef786ce4f4d39ef635a67321094be364" translate="yes" xml:space="preserve">
          <source>Then for the objects defined earlier, the following would be true:</source>
          <target state="translated">그러면 이전에 정의 된 개체의 경우 다음이 참이됩니다.</target>
        </trans-unit>
        <trans-unit id="ef5935a3802e9c731a629c2d3dea2e39fefd2688" translate="yes" xml:space="preserve">
          <source>Then it can be used inside a template like this:</source>
          <target state="translated">그런 다음 다음과 같은 템플릿 내에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7717c315c219349dde87bf9f638b3cb7bca01e90" translate="yes" xml:space="preserve">
          <source>Then the output will be:</source>
          <target state="translated">그러면 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="864c134c8c6b2e00f7e8bc3ed68b30a559cbae27" translate="yes" xml:space="preserve">
          <source>Then this description is supplied to CliBuilder during parsing, e.g.:</source>
          <target state="translated">그런 다음이 설명은 구문 분석 중에 CliBuilder에 제공됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="8374b2c2645caacda80d91902c858cf6eea4f9dd" translate="yes" xml:space="preserve">
          <source>Then you can create the structure using:</source>
          <target state="translated">그런 다음 다음을 사용하여 구조를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="947e20775c08c2347253e8e5fa3ea40f8f8dd552" translate="yes" xml:space="preserve">
          <source>There are numerous options to customize the format of the generated output. E.g. if you change the first annotation to:</source>
          <target state="translated">생성 된 출력의 형식을 사용자 정의 할 수있는 다양한 옵션이 있습니다. 예를 들어 첫 번째 주석을 다음과 같이 변경하는 경우 :</target>
        </trans-unit>
        <trans-unit id="563196ba8420a662ed40e16f59935b76206ff249" translate="yes" xml:space="preserve">
          <source>There are several variables in the script binding:</source>
          <target state="translated">스크립트 바인딩에는 여러 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4572f137c1c0ff3c8ab5a5964aa37a98f650fc5" translate="yes" xml:space="preserve">
          <source>There are three types of ClassNodes:</source>
          <target state="translated">ClassNode에는 세 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bba0d9440062e4b938ad280aac889cc0eb5c94e" translate="yes" xml:space="preserve">
          <source>There is also a convenience form of ignore that matches the same style as demand. E.g. instead of &lt;code&gt;mock.ignore('hasNext')&lt;/code&gt; you can use &lt;code&gt;mock.ignore.hasNext()&lt;/code&gt;. A Closure variation is also provided. This convenience shorthand only applies to the &lt;code&gt;String&lt;/code&gt; form of ignore and cannot be used with methods from &lt;code&gt;java.lang.Object&lt;/code&gt;. Be careful using this feature while mocking some of the fundamental Java classes like &lt;code&gt;String&lt;/code&gt; or &lt;code&gt;Pattern&lt;/code&gt;. As these are used within the implementation of the ignore capability, strange behavior may be observed.</source>
          <target state="translated">수요와 동일한 스타일과 일치하는 편리한 형태의 무시도 있습니다. 예를 들어 &lt;code&gt;mock.ignore('hasNext')&lt;/code&gt; 대신 &lt;code&gt;mock.ignore.hasNext()&lt;/code&gt; 사용할 수 있습니다 . 폐쇄 변형도 제공됩니다. 이 편리한 속기 는 무시 의 &lt;code&gt;String&lt;/code&gt; 형식 에만 적용 되며 &lt;code&gt;java.lang.Object&lt;/code&gt; 의 메소드와 함께 사용할 수 없습니다 . &lt;code&gt;String&lt;/code&gt; 또는 &lt;code&gt;Pattern&lt;/code&gt; 과 같은 일부 기본 Java 클래스를 조롱하는 동안이 기능을 사용하는 데주의하십시오 . 이들은 무시 기능 구현 내에서 사용되므로 이상한 동작이 관찰 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16ebe4c456d8370715d9755e4586403958f169f6" translate="yes" xml:space="preserve">
          <source>There is also support for including or excluding fields/properties by name when constructing the equals and hashCode methods as shown here:</source>
          <target state="translated">다음과 같이 equals 및 hashCode 메소드를 구성 할 때 이름별로 필드 / 속성을 포함하거나 제외하는 기능도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="09e297702b5735499b1fd1768938b8ac48de65f4" translate="yes" xml:space="preserve">
          <source>There's no way in Java or Groovy to express the type signature of the expected closure call method from outside the closure itself, so we rely on an annotation here. Unfortunately, annotations also have limitations (like not being able to use generics placeholder as annotation values) that prevent us from expressing the type directly.</source>
          <target state="translated">Java 또는 Groovy에서는 클로저 자체 외부에서 예상 클로저 호출 메서드의 유형 서명을 표현할 방법이 없으므로 여기서 주석에 의존합니다. 안타깝게도 주석에는 유형을 직접 표현할 수없는 제한 사항 (예 : 제네릭 자리 표시자를 주석 값으로 사용할 수 없음)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c18b23776942b361d4b98fa35e6f9472dbefb7b1" translate="yes" xml:space="preserve">
          <source>Therefore, f(x,y, a:p, b:q) {s} is equivalent in all ways to f(x,y, [a:p,b:q], {s}). Spread arguments of sequence type count as unlabeled arguments, while spread arguments of map type count as labeled arguments. (This distinction must sometimes be checked dynamically.) A plain unlabeled argument is allowed to match a trailing Map or Closure argument: f(x, a:p) {s} === f(*[ x, [a:p], {s} ])</source>
          <target state="translated">따라서 f (x, y, a : p, b : q) {s}는 모든면에서 f (x, y, [a : p, b : q], {s})와 동일합니다. 시퀀스 유형의 확산 인수는 레이블이 지정되지 않은 인수로 간주되고 맵 유형의 확산 인수는 레이블이 지정된 인수로 계산됩니다. (이 구별은 때때로 동적으로 확인되어야합니다.) 레이블이없는 일반 인수는 후행 맵 또는 클로저 인수와 일치하도록 허용됩니다. f (x, a : p) {s} === f (* [x, [a : p] , {s}])</target>
        </trans-unit>
        <trans-unit id="bdf6f329bdd2bfe03d147cee437e1f28acbe9bec" translate="yes" xml:space="preserve">
          <source>These rules are different from Java's &quot;dumb expression&quot; restriction. Unlike Java, Groovy blocks can end with arbitrary (even dumb) expressions, as a consequence of optional 'return' and 'continue' tokens.</source>
          <target state="translated">이러한 규칙은 Java의 &quot;dumb expression&quot;제한과 다릅니다. Java와 달리 Groovy 블록은 선택적인 'return'및 'continue'토큰의 결과로 임의의 (심지어 바보 같은) 표현식으로 끝날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dd6b0156ded337bff046c6c15b9f9acafbe9d9f" translate="yes" xml:space="preserve">
          <source>Things that can show up as expressions, but only in strict contexts like inside parentheses, argument lists, and list constructors.</source>
          <target state="translated">표현식으로 표시 될 수 있지만 괄호, 인수 목록 및 목록 생성자와 같은 엄격한 컨텍스트에서만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3f14934bd3a85bcc4e7a08b55ecfe6eb236ddcff" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.4&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.4.</source>
          <target state="translated">이 ( &lt;code&gt;&quot;1.4&quot;&lt;/code&gt; )는 JDK 1.4 용으로 컴파일 할 targetBytecode의 값입니다.</target>
        </trans-unit>
        <trans-unit id="41689f1ac38712a28ee794030339205948d12a07" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.5&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.5.</source>
          <target state="translated">이 ( &lt;code&gt;&quot;1.5&quot;&lt;/code&gt; )는 JDK 1.5 용으로 컴파일 할 targetBytecode의 값입니다.</target>
        </trans-unit>
        <trans-unit id="9f297bc1639a07cc1f354bdef8b770444ae17d9a" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.6&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.6.</source>
          <target state="translated">이 ( &lt;code&gt;&quot;1.6&quot;&lt;/code&gt; )는 JDK 1.6 용으로 컴파일 할 targetBytecode의 값입니다.</target>
        </trans-unit>
        <trans-unit id="9fb8c7a4c95ce1386b3f28c134d8693268f0f7af" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.7&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.7.</source>
          <target state="translated">이 ( &lt;code&gt;&quot;1.7&quot;&lt;/code&gt; )는 JDK 1.7 용으로 컴파일 할 targetBytecode의 값입니다.</target>
        </trans-unit>
        <trans-unit id="1cb5fc7c5b688d3d7cf1465b6b36be120c55f7d5" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;1.8&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 1.8.</source>
          <target state="translated">이 ( &lt;code&gt;&quot;1.8&quot;&lt;/code&gt; )는 JDK 1.8 용으로 컴파일 할 targetBytecode의 값입니다.</target>
        </trans-unit>
        <trans-unit id="4db730fb6bbc9127357c8981de76c8767a22995c" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;10&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 10.</source>
          <target state="translated">이 ( &lt;code&gt;&quot;10&quot;&lt;/code&gt; )는 JDK 10 용으로 컴파일 할 targetBytecode의 값입니다.</target>
        </trans-unit>
        <trans-unit id="7253e572c58af323680948d9124eb666a503dc70" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;11&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 11.</source>
          <target state="translated">이 ( &lt;code&gt;&quot;11&quot;&lt;/code&gt; )는 JDK 11 용으로 컴파일 할 targetBytecode의 값입니다.</target>
        </trans-unit>
        <trans-unit id="f1a0d2ab0453c0d76f9aec2ffa7dab4ddcaac8ea" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;12&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 12.</source>
          <target state="translated">이 ( &lt;code&gt;&quot;12&quot;&lt;/code&gt; )는 JDK 12 용으로 컴파일 할 targetBytecode의 값입니다.</target>
        </trans-unit>
        <trans-unit id="92239128e3fca4fd124d3c3ff8f83f20507689db" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;13&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 13.</source>
          <target state="translated">이 ( &lt;code&gt;&quot;13&quot;&lt;/code&gt; )는 JDK 13 용으로 컴파일 할 targetBytecode의 값입니다.</target>
        </trans-unit>
        <trans-unit id="c9227107e2eef78c2490b7685cfcbd9e12fac74d" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;14&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 14.</source>
          <target state="translated">이 ( &lt;code&gt;&quot;14&quot;&lt;/code&gt; )는 JDK 14 용으로 컴파일 할 targetBytecode의 값입니다.</target>
        </trans-unit>
        <trans-unit id="a8c680713844e7c900b549a36c6de7e34f563c98" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;15&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 15.</source>
          <target state="translated">이 ( &lt;code&gt;&quot;15&quot;&lt;/code&gt; )는 JDK 15 용으로 컴파일 할 targetBytecode의 값입니다.</target>
        </trans-unit>
        <trans-unit id="f1c463b78b8f124ac2eec3fd756cac7f533dfce9" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;16&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 16.</source>
          <target state="translated">이 ( &lt;code&gt;&quot;16&quot;&lt;/code&gt; )는 JDK 16 용으로 컴파일 할 targetBytecode의 값입니다.</target>
        </trans-unit>
        <trans-unit id="7b242e1445386ea26fd4353cac30d1a7873acc0d" translate="yes" xml:space="preserve">
          <source>This (&lt;code&gt;&quot;9&quot;&lt;/code&gt;) is the value for targetBytecode to compile for a JDK 9.</source>
          <target state="translated">이 ( &lt;code&gt;&quot;9&quot;&lt;/code&gt; )는 JDK 9 용으로 컴파일 할 targetBytecode의 값입니다.</target>
        </trans-unit>
        <trans-unit id="beee2f48ce8c2bdd9d82e37070e460c27f51fba0" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../classnode&quot;&gt;ClassNode&lt;/a&gt; specialization is used when the lowest upper bound of two types cannot be represented by an existing type.</source>
          <target state="translated">이 &lt;a href=&quot;../classnode&quot;&gt;ClassNode&lt;/a&gt; 특수화는 두 유형의 최저 상한이 기존 유형으로 표현 될 수 없을 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f55f8d16febb565101695bf40d07384fdcedba3d" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../classnode&quot;&gt;ClassNode&lt;/a&gt; specialization is used when the lowest upper bound of two types cannot be represented by an existing type. For example, if B extends A, C extends A and both C and B implement a common interface not implemented by A, then we use this class to represent the bound. At compile time, some classes like &lt;a href=&quot;../../classgen/asmclassgenerator&quot;&gt;AsmClassGenerator&lt;/a&gt; need to know about a real class node, so we compute a &quot;compile time&quot; node which will be used to return a name and a type class.</source>
          <target state="translated">이 &lt;a href=&quot;../classnode&quot;&gt;ClassNode&lt;/a&gt; 특수화는 두 유형의 최저 상한이 기존 유형으로 표현 될 수 없을 때 사용됩니다. 예를 들어 B가 A를 확장하고 C가 A를 확장하고 C와 B가 모두 A가 구현하지 않은 공통 인터페이스를 구현하는 경우이 클래스를 사용하여 경계를 나타냅니다. 컴파일 타임에 &lt;a href=&quot;../../classgen/asmclassgenerator&quot;&gt;AsmClassGenerator&lt;/a&gt; 와 같은 일부 클래스 는 실제 클래스 노드에 대해 알아야하므로 이름과 유형 클래스를 반환하는 데 사용되는 &quot;컴파일 타임&quot;노드를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="bd4628d474bbecaf52d4fae2554f6f6dafd33e5e" translate="yes" xml:space="preserve">
          <source>This AST transform creates (potentially) numerous constructors. You should take care to avoid constructors with duplicate signatures if you are defining your own constructors or combining with other AST transforms which create constructors (e.g. &lt;code&gt;@TupleConstructor&lt;/code&gt;); the order in which the particular transforms are processed becomes important in that case.</source>
          <target state="translated">이 AST 변환은 (잠재적으로) 수많은 생성자를 생성합니다. 자체 생성자를 정의하거나 생성자를 생성하는 다른 AST 변환 (예 : &lt;code&gt;@TupleConstructor&lt;/code&gt; ) 과 결합하는 경우 중복 서명이있는 생성자를 피하도록주의해야합니다 . 이 경우 특정 변환이 처리되는 순서가 중요합니다.</target>
        </trans-unit>
        <trans-unit id="e36f809432dd63402bc50997d22ab6edaf317f70" translate="yes" xml:space="preserve">
          <source>This AST transform might become a no-op if you are defining your own constructors or combining with other AST transforms which create constructors (e.g. &lt;code&gt;@InheritConstructors&lt;/code&gt;); the order in which the particular transforms are processed becomes important in that case. See the &lt;code&gt;force&lt;/code&gt; attribute for further details about customizing this behavior.</source>
          <target state="translated">자체 생성자를 정의하거나 생성자를 생성하는 다른 AST 변환 (예 : &lt;code&gt;@InheritConstructors&lt;/code&gt; ) 과 결합하는 경우이 AST 변환이 작동하지 않을 수 있습니다 . 이 경우 특정 변환이 처리되는 순서가 중요합니다. 이 동작을 사용자 정의하는 방법에 대한 자세한 내용은 &lt;code&gt;force&lt;/code&gt; 속성을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="15f2811221f75ab7d18ebc91f442dd8504abe34a" translate="yes" xml:space="preserve">
          <source>This AST transform normally uses default parameter values which creates multiple constructors under the covers. You should use with care if you are defining your own constructors or combining with other AST transforms which create constructors (e.g. &lt;code&gt;@InheritConstructors&lt;/code&gt;); the order in which the particular transforms are processed becomes important in that case. See the &lt;code&gt;defaults&lt;/code&gt; attribute for further details about customizing this behavior.</source>
          <target state="translated">이 AST 변환은 일반적으로 내부에서 여러 생성자를 만드는 기본 매개 변수 값을 사용합니다. 자체 생성자를 정의하거나 생성자를 생성하는 다른 AST 변환 (예 : &lt;code&gt;@InheritConstructors&lt;/code&gt; ) 과 결합하는 경우주의해서 사용해야합니다 . 이 경우 특정 변환이 처리되는 순서가 중요합니다. 이 동작을 사용자 정의하는 방법에 대한 자세한 내용은 &lt;code&gt;defaults&lt;/code&gt; 속성을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="81e45867f90c0607353adaf6e73abff7c9d75404" translate="yes" xml:space="preserve">
          <source>This AST transformation aims at helping in debugging other AST transformations. It provides a basic infrastructure for performing tests on AST nodes. You can place this annotation on any node which accepts an annotation (types, methods, annotations, constructors, fields, local variables, packages or parameters), then use a script which is run against this AST node at a specific phase. For example, you could test the &lt;a href=&quot;field&quot;&gt;Field&lt;/a&gt; AST transformation this way:</source>
          <target state="translated">이 AST 변환은 다른 AST 변환 디버깅을 돕는 것을 목표로합니다. AST 노드에서 테스트를 수행하기위한 기본 인프라를 제공합니다. 주석 (유형, 메서드, 주석, 생성자, 필드, 로컬 변수, 패키지 또는 매개 변수)을 허용하는 모든 노드에이 주석을 배치 한 다음 특정 단계에서이 AST 노드에 대해 실행되는 스크립트를 사용할 수 있습니다. 예를 들어 다음과 같은 방법으로 &lt;a href=&quot;field&quot;&gt;Field&lt;/a&gt; AST 변환을 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29dcdadce343c996ed956f4651064a49228e35e3" translate="yes" xml:space="preserve">
          <source>This ClassLoader should be used as root of class loaders. Any RootLoader does have its own classpath. When searching for a class or resource this classpath will be used. Parent Classloaders are ignored first. If a class or resource can't be found in the classpath of the RootLoader, then parent is checked.</source>
          <target state="translated">이 ClassLoader는 클래스 로더의 루트로 사용해야합니다. 모든 RootLoader에는 자체 클래스 경로가 있습니다. 클래스 또는 리소스를 검색 할 때이 클래스 경로가 사용됩니다. 상위 클래스 로더가 먼저 무시됩니다. RootLoader의 클래스 경로에서 클래스 또는 리소스를 찾을 수없는 경우 부모가 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="bf55f18fc8d0076e97f9f960b82f80de35bb3681" translate="yes" xml:space="preserve">
          <source>This MetaBeanProperty will create a pseudo property whose value is bound to an object using weak references. The values will go out of scope and be garbage collected when the object is collected In fact, this class should be called ExpandoProperty.</source>
          <target state="translated">이 MetaBeanProperty는 값이 약한 참조를 사용하여 객체에 바인딩 된 의사 속성을 생성합니다. 값은 범위를 벗어나 개체가 수집 될 때 가비지 수집됩니다. 사실이 클래스는 ExpandoProperty라고해야합니다.</target>
        </trans-unit>
        <trans-unit id="704cf8159f321950d7439d8157804780ec00808e" translate="yes" xml:space="preserve">
          <source>This MetaClass is for internal usage only!</source>
          <target state="translated">이 MetaClass는 내부 전용입니다!</target>
        </trans-unit>
        <trans-unit id="550e8ef2b445d11145333f7d61692b3a9a8521d7" translate="yes" xml:space="preserve">
          <source>This TestHarness exists so that a global transform can be run without using the Jar services mechanism, which requires building a jar. To use this simply create an instance of TransformTestHelper with an ASTTransformation and CompilePhase, then invoke parse(File) or parse(String). This test harness is not exactly the same as executing a global transformation but can greatly aide in debugging and testing a transform. You should still test your global transformation when packaged as a jar service before releasing it.</source>
          <target state="translated">이 TestHarness는 jar를 빌드해야하는 Jar 서비스 메커니즘을 사용하지 않고 전역 변환을 실행할 수 있도록 존재합니다. 이를 사용하려면 ASTTransformation 및 CompilePhase를 사용하여 TransformTestHelper의 인스턴스를 만든 다음 parse (File) 또는 parse (String)를 호출하면됩니다. 이 테스트 도구는 전역 변환을 실행하는 것과 정확히 동일하지는 않지만 변환 디버깅 및 테스트에 크게 도움이 될 수 있습니다. 릴리스하기 전에 jar 서비스로 패키징 된 경우 전역 변환을 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="c82a01d51cf967248d2d13c51ea281168a11d159" translate="yes" xml:space="preserve">
          <source>This Writer is used to generate the call invocation byte codes for usage by invokedynamic.</source>
          <target state="translated">이 작성기는 invokedynamic에서 사용할 호출 호출 바이트 코드를 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3d417d2cc7f087e2cdc7df384d7a9c24827840c1" translate="yes" xml:space="preserve">
          <source>This allows callbacks to the ExpandoMetaClass for registering appending methods</source>
          <target state="translated">이렇게하면 추가 메서드를 등록하기 위해 ExpandoMetaClass에 대한 콜백이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d5ec4e7b6ccc818185756b4b5a332b9d3ffec2cf" translate="yes" xml:space="preserve">
          <source>This allows equals to be overridden by a closure</source>
          <target state="translated">이렇게하면 같음이 클로저로 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a87473814b341719aa50b456949655ef70f8692" translate="yes" xml:space="preserve">
          <source>This allows hashCode to be overridden by a closure</source>
          <target state="translated">이를 통해 hashCode가 클로저로 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9be7fcf1022ddc09fab428bf809d227229df0478" translate="yes" xml:space="preserve">
          <source>This allows toString to be overridden by a closure</source>
          <target state="translated">이렇게하면 toString이 클로저로 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="904b268e24ef2338f73c60ee6653805eb03db45f" translate="yes" xml:space="preserve">
          <source>This annotation adds Java-style listener support to a class based on an annotated Collection-property.</source>
          <target state="translated">이 주석은 주석이 달린 Collection 속성을 기반으로 클래스에 Java 스타일 리스너 지원을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="456bbcadaaaab286f459087a19ee8bf423978b1b" translate="yes" xml:space="preserve">
          <source>This annotation can also be used to help the type checker (&lt;a href=&quot;../transform/typechecked&quot;&gt;TypeChecked&lt;/a&gt;) which would not report errors then if the delegate is of the documented type. Of course, it is also compatible with &lt;a href=&quot;../transform/compilestatic&quot;&gt;CompileStatic&lt;/a&gt;.</source>
          <target state="translated">이 주석은 또한 대리자가 문서화 된 유형 인 경우 오류를보고하지 않는 유형 검사기 ( &lt;a href=&quot;../transform/typechecked&quot;&gt;TypeChecked&lt;/a&gt; ) 를 돕는 데 사용할 수 있습니다 . 물론 &lt;a href=&quot;../transform/compilestatic&quot;&gt;CompileStatic 과도&lt;/a&gt; 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="f85deef9d102451f990e95bce3bc073d25fbab0b" translate="yes" xml:space="preserve">
          <source>This annotation can be added on a trait to declare the list of types that a class implementing that trait is supposed to extend. This is useful when you want to be able to call methods from the class implementing the trait without having to declare all of them as members of the trait. Self types are particularly useful in combination with &lt;a href=&quot;compilestatic&quot;&gt;CompileStatic&lt;/a&gt;, if you know that a trait can only be applied to a specific type but that the trait cannot extend that type itself. For example, imagine the following code:</source>
          <target state="translated">이 어노테이션을 트레이 트에 추가하여 해당 트레이 트를 구현하는 클래스가 확장해야하는 유형 목록을 선언 할 수 있습니다. 이는 트레이 트의 멤버로 모두 선언 할 필요없이 트레이 트를 구현하는 클래스에서 메서드를 호출 할 수 있기를 원할 때 유용합니다. Self 유형은 &lt;a href=&quot;compilestatic&quot;&gt;CompileStatic&lt;/a&gt; 과 함께 사용할 때 특히 유용 합니다. 특성이 특정 유형에만 적용될 수 있지만 특성이 해당 유형 자체를 확장 할 수 없다는 것을 알고있는 경우에 유용 합니다. 예를 들어 다음 코드를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="90bf79a957044e0c4bcbe98180025021e13ba83a" translate="yes" xml:space="preserve">
          <source>This annotation can be used by API or DSL writers to document parameters which accept a closure. In that case, using this annotation, you can specify what the delegate type of the closure will be. This is important for IDE support.</source>
          <target state="translated">이 주석은 API 또는 DSL 작성자가 클로저를 허용하는 매개 변수를 문서화하는 데 사용할 수 있습니다. 이 경우이 주석을 사용하여 클로저의 대리자 유형을 지정할 수 있습니다. 이것은 IDE 지원에 중요합니다.</target>
        </trans-unit>
        <trans-unit id="ecea2ce9782577916440255f7ef418cba5693cc7" translate="yes" xml:space="preserve">
          <source>This annotation can only be applied to a field of type Collection</source>
          <target state="translated">이 주석은 Collection 유형의 필드에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23faf967c5242f98ba0f1bfb8360a62caf1714ca" translate="yes" xml:space="preserve">
          <source>This annotation is a declarative wrapper around the JDK's &lt;code&gt;java.util.concurrent.locks.ReentrantReadWriteLock&lt;/code&gt;. Objects containing this annotation will have a ReentrantReadWriteLock field named &lt;code&gt;$reentrantLock&lt;/code&gt; added to the class, and method access is protected by the lock. If the method is static then the field is static and named &lt;code&gt;$REENTRANTLOCK&lt;/code&gt;.</source>
          <target state="translated">이 주석은 JDK의 &lt;code&gt;java.util.concurrent.locks.ReentrantReadWriteLock&lt;/code&gt; 에 대한 선언적 래퍼 입니다. 이 주석을 포함하는 개체에는 &lt;code&gt;$reentrantLock&lt;/code&gt; 이라는 ReentrantReadWriteLock 필드 가 클래스에 추가되고 메서드 액세스는 잠금으로 보호됩니다. 메서드가 정적이면 필드는 정적이고 이름은 &lt;code&gt;$REENTRANTLOCK&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9ee69ca6c59b77f4f301dba9f69b7ae03123c8fb" translate="yes" xml:space="preserve">
          <source>This annotation is added by</source>
          <target state="translated">이 주석은 다음에 의해 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="284afc2f65c87063203dea977155cf54b2e047bd" translate="yes" xml:space="preserve">
          <source>This annotation is used in conjunction with &lt;a href=&quot;withreadlock&quot;&gt;WithReadLock&lt;/a&gt; to support read and write synchronization on a method.</source>
          <target state="translated">이 주석은 &lt;a href=&quot;withreadlock&quot;&gt;메서드&lt;/a&gt; 에 대한 읽기 및 쓰기 동기화를 지원하기 위해 WithReadLock 과 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="17c946a06e7f552c5a667fd66607967ecf31f9f4" translate="yes" xml:space="preserve">
          <source>This annotation is used in conjunction with &lt;a href=&quot;withwritelock&quot;&gt;WithWriteLock&lt;/a&gt; to support read and write synchronization on a method.</source>
          <target state="translated">이 주석은 &lt;a href=&quot;withwritelock&quot;&gt;WithWriteLock&lt;/a&gt; 과 함께 사용되어 메서드 에 대한 읽기 및 쓰기 동기화를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="887147df53ade494df6c8d9012ec7612dd2f4226" translate="yes" xml:space="preserve">
          <source>This applies to the grab and resolve calls.</source>
          <target state="translated">이것은 Grab 및 Resolve 호출에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a921b8a7c1a5d233057197c112f7c4cb8b092bff" translate="yes" xml:space="preserve">
          <source>This behavior can be disabled by setting the annotation's &lt;code&gt;interfaces&lt;/code&gt; element to false, i.e. &lt;code&gt;@Delegate(interfaces = false)&lt;/code&gt;, e.g. in the above example, the delegate definition would become:</source>
          <target state="translated">이 동작은 어노테이션의 &lt;code&gt;interfaces&lt;/code&gt; 요소를 false 로 설정하여 비활성화 할 수 있습니다 &lt;code&gt;@Delegate(interfaces = false)&lt;/code&gt; 예 : @Delegate (interfaces = false)) . 예를 들어 위의 예에서 대리자 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="788d0e9e6025f3d507fbe4b1a671cab778fcc046" translate="yes" xml:space="preserve">
          <source>This builder supports the usual builder syntax made of nested method calls and closures, but also some specific aspects of JSON data structures, such as list of values, etc. Please make sure to have a look at the various methods provided by this builder to be able to learn about the various possibilities of usage.</source>
          <target state="translated">이 빌더는 중첩 된 메소드 호출 및 클로저로 구성된 일반적인 빌더 구문을 지원하지만 값 목록 등과 같은 JSON 데이터 구조의 일부 특정 측면도 지원합니다.이 빌더에서 제공하는 다양한 메소드를 살펴보십시오. 다양한 사용 가능성에 대해 배울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8635421fede240629f5bedb5b4f58cb9f602fa9" translate="yes" xml:space="preserve">
          <source>This cache contains mappings of file name to class.</source>
          <target state="translated">이 캐시는 클래스에 대한 파일 이름의 매핑을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="370ea64c9230c916cbe3b4f3656932f0e6a2c4bc" translate="yes" xml:space="preserve">
          <source>This cache contains mappings of file name to class. It is used to bypass compilation.</source>
          <target state="translated">이 캐시는 클래스에 대한 파일 이름의 매핑을 포함합니다. 컴파일을 우회하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="88d556d068acd75020d51487e54372a78b6ff46d" translate="yes" xml:space="preserve">
          <source>This class also supports optional guaranteed exclusive reads, simply by surrounding a call within a synchronized block, as in</source>
          <target state="translated">이 클래스는 또한 다음과 같이 동기화 된 블록 내에서 호출을 둘러싸기만하면 선택적으로 보장되는 독점 읽기를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8508f2b4673f6cfee9a6f3c2b3e95fec3b67deb5" translate="yes" xml:space="preserve">
          <source>This class and its views and iterators implement all of the &lt;em&gt;optional&lt;/em&gt; methods of the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; and &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt;Iterator&lt;/a&gt; interfaces.</source>
          <target state="translated">이 클래스와 해당 뷰 및 반복기 는 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; 및 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt;Iterator&lt;/a&gt; 인터페이스 의 모든 &lt;em&gt;선택적&lt;/em&gt; 메서드를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="f7efe531dee1a194a6b26a56274948d2b3619130" translate="yes" xml:space="preserve">
          <source>This class checks the handling of labels in the AST</source>
          <target state="translated">이 클래스는 AST에서 레이블 처리를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c32390b3fa0798fcae7e17bde6e60d95b95add0f" translate="yes" xml:space="preserve">
          <source>This class codes around a silly limitation of StringWriter which doesn't allow a StringBuffer to be passed in as a constructor for some bizarre reason. So we replicate the behaviour of StringWriter here but allow a StringBuffer to be passed in.</source>
          <target state="translated">이 클래스는 기괴한 이유로 StringBuffer가 생성자로 전달되는 것을 허용하지 않는 StringWriter의 어리석은 제한을 둘러싼 코드입니다. 따라서 여기에서 StringWriter의 동작을 복제하지만 StringBuffer가 전달되도록합니다.</target>
        </trans-unit>
        <trans-unit id="ebc053f62ed97562a5d93d1422bb69af81f8e57b" translate="yes" xml:space="preserve">
          <source>This class contains a static utility method &lt;a href=&quot;#doExtendTraits(org.codehaus.groovy.ast.ClassNode,%20org.codehaus.groovy.control.SourceUnit,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;doExtendTraits(org.codehaus.groovy.ast.ClassNode, org.codehaus.groovy.control.SourceUnit, org.codehaus.groovy.control.CompilationUnit)&lt;/a&gt; aimed at generating code for a classnode implementing a trait.</source>
          <target state="translated">이 클래스에는 특성을 구현하는 클래스 노드에 대한 코드를 생성하기위한 정적 유틸리티 메서드 &lt;a href=&quot;#doExtendTraits(org.codehaus.groovy.ast.ClassNode,%20org.codehaus.groovy.control.SourceUnit,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;doExtendTraits (org.codehaus.groovy.ast.ClassNode, org.codehaus.groovy.control.SourceUnit, org.codehaus.groovy.control.CompilationUnit)&lt;/a&gt; 가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1390a9bb5928eb78b502051fa6490144b85fc73" translate="yes" xml:space="preserve">
          <source>This class contains guards, runtime filters and MethodType signatures used by indy.</source>
          <target state="translated">이 클래스는 indy에서 사용하는 가드, 런타임 필터 및 MethodType 서명을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="69d74fd6b193fe5e0c2269389a27f951ab4b1918" translate="yes" xml:space="preserve">
          <source>This class contains helper methods for converting and comparing types. WARNING: This class is for internal use only. do not use it outside of its package and not outside groovy-core.</source>
          <target state="translated">이 클래스에는 유형을 변환하고 비교하기위한 도우미 메서드가 포함되어 있습니다. 경고 :이 클래스는 내부 전용입니다. 패키지 외부에서 사용하지 말고 그루비 코어 외부에서 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0e2eed5867aee96ae1999d8644dc789cf19d0975" translate="yes" xml:space="preserve">
          <source>This class contains math operations used by indy instead of the normal meta method and call site caching system. The goal is to avoid boxing, thus use primitive types for parameters and return types where possible. WARNING: This class is for internal use only. Do not use it outside of the org.codehaus.groovy.vmplugin.v7 package of groovy-core.</source>
          <target state="translated">이 클래스에는 일반 메타 메서드 및 호출 사이트 캐싱 시스템 대신 indy에서 사용하는 수학 연산이 포함되어 있습니다. 목표는 boxing을 피하는 것이므로 가능한 경우 매개 변수 및 반환 유형에 기본 유형을 사용합니다. 경고 :이 클래스는 내부 전용입니다. groovy-core의 org.codehaus.groovy.vmplugin.v7 패키지 외부에서 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="48c7a1f038c0d6b2a23d2ab51b95c86eac51cf7a" translate="yes" xml:space="preserve">
          <source>This class contains methods special to optimizations used directly from bytecode in Groovy 1.8</source>
          <target state="translated">이 클래스에는 Groovy 1.8의 바이트 코드에서 직접 사용되는 최적화에 특별한 메서드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="316c4500322f8ef05e5c4de531c7dc7bc6e842c4" translate="yes" xml:space="preserve">
          <source>This class contains several transformers for used during method invocation.</source>
          <target state="translated">이 클래스에는 메서드 호출 중에 사용되는 여러 변환기가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1768003da8eeae27f66ecf9e1f2dbf815c0a1e83" translate="yes" xml:space="preserve">
          <source>This class contains utility methods to determine which class called the current class to multiple levels of depth. Calls used to handle the groovy MOP are excluded from the level counting.</source>
          <target state="translated">이 클래스에는 현재 클래스를 여러 수준의 깊이로 호출 한 클래스를 결정하는 유틸리티 메서드가 포함되어 있습니다. 그루비 MOP를 처리하는 데 사용되는 호출은 레벨 계산에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="221b99a286abc745efa1b934a4f00c7b6aa4732f" translate="yes" xml:space="preserve">
          <source>This class controls the conversion from a Groovy script as a String into a tree representation of the AST of that script. The script itself will be a tree node, and each class in the script will be a tree node. The conversion creates tree nodes for any concrete class found within an AST visitor. So, if a tree node should be shown once for each ASTNode and the parent types will not appear as nodes. Custom subclasses of expression types will not appear in the tree. The String label of a tree node is defined by classname in AstBrowserProperties.properties.</source>
          <target state="translated">이 클래스는 Groovy 스크립트에서 해당 스크립트의 AST 트리 표현으로의 문자열 변환을 제어합니다. 스크립트 자체는 트리 노드가되고 스크립트의 각 클래스는 트리 노드가됩니다. 변환은 AST 방문자 내에서 발견 된 모든 구체적인 클래스에 대한 트리 노드를 생성합니다. 따라서 트리 노드가 각 ASTNode에 대해 한 번씩 표시되어야하고 상위 유형이 노드로 표시되지 않는 경우. 식 유형의 사용자 지정 하위 클래스는 트리에 나타나지 않습니다. 트리 노드의 문자열 레이블은 AstBrowserProperties.properties에서 클래스 이름으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d454a30f57963a7de123921ca0b60e62b5e13e35" translate="yes" xml:space="preserve">
          <source>This class defines a single static method taking the string instance as first argument, allowing to define a new instance method on the String class:</source>
          <target state="translated">이 클래스는 문자열 인스턴스를 첫 번째 인수로 사용하는 단일 정적 메서드를 정의하여 String 클래스에 새 인스턴스 메서드를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e8b6ae7361745c2ea205471fce2c8b2f23b8fe8" translate="yes" xml:space="preserve">
          <source>This class defines a wrapper for accessing a specific column in &lt;code&gt;ResultSetMetaData&lt;/code&gt;. This allows iteration over columns using idiomatic Groovy, e.g.:</source>
          <target state="translated">이 클래스는 &lt;code&gt;ResultSetMetaData&lt;/code&gt; 의 특정 열에 액세스하기위한 랩퍼를 정의합니다 . 이를 통해 관용적 Groovy를 사용하여 열을 반복 할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="3f3f0165db0a67f63374a90150dc420fe8fa8906" translate="yes" xml:space="preserve">
          <source>This class defines all the encoding/decoding groovy methods which enhance the normal JDK classes when inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="translated">이 클래스는 Groovy 환경 내에서 일반 JDK 클래스를 향상시키는 모든 인코딩 / 디코딩 그루비 메서드를 정의합니다. 정적 메서드는 대상 클래스의 첫 번째 매개 변수와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ddd6dbb32c165e8ccdc7c778b5ff92b6e5a6e046" translate="yes" xml:space="preserve">
          <source>This class defines all the new SQL-related groovy methods which enhance the normal JDK SQL classes when inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="translated">이 클래스는 Groovy 환경 내에서 일반 JDK SQL 클래스를 향상시키는 모든 새로운 SQL 관련 그루비 메서드를 정의합니다. 정적 메서드는 대상 클래스의 첫 번째 매개 변수와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e4cf1f1d1626756e2ccfaa4e27ca5b4fe7667ce" translate="yes" xml:space="preserve">
          <source>This class defines all the new Swing-related groovy methods which enhance the normal JDK Swing classes when inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="translated">이 클래스는 Groovy 환경 내에서 일반 JDK Swing 클래스를 향상시키는 모든 새로운 Swing 관련 그루비 메서드를 정의합니다. 정적 메서드는 대상 클래스의 첫 번째 매개 변수와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6bc8d743038c2ddaea690f3c08b6f791f09b985b" translate="yes" xml:space="preserve">
          <source>This class defines all the new XML-related groovy methods which enhance the normal JDK XML classes when inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="translated">이 클래스는 Groovy 환경 내에서 일반 JDK XML 클래스를 향상시키는 모든 새로운 XML 관련 그루비 메서드를 정의합니다. 정적 메서드는 대상 클래스의 첫 번째 매개 변수와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="98e53123fb5c78332de5d2876769f4a204051159" translate="yes" xml:space="preserve">
          <source>This class defines all the new static groovy methods which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter as the destination class.</source>
          <target state="translated">이 클래스는 Groovy 환경 내의 일반 JDK 클래스에 나타나는 모든 새로운 정적 그루비 메서드를 정의합니다. 정적 메서드는 첫 번째 매개 변수와 함께 대상 클래스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="faf10e978d074ae7e5e07e788c9748ff6b749eed" translate="yes" xml:space="preserve">
          <source>This class defines new Groovy methods which appear on normal JDK Date/Time API (java.time) classes inside the Groovy environment. These extensions require JDK 8 or above.</source>
          <target state="translated">이 클래스는 Groovy 환경 내의 일반 JDK Date / Time API (java.time) 클래스에 나타나는 새로운 Groovy 메서드를 정의합니다. 이러한 확장에는 JDK 8 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5e8a356a24d0f45345f38f9c5e624401ea122feb" translate="yes" xml:space="preserve">
          <source>This class defines new Java 5 specific groovy methods which extend the normal JDK classes inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="translated">이 클래스는 Groovy 환경 내에서 일반 JDK 클래스를 확장하는 새로운 Java 5 특정 그루비 메서드를 정의합니다. 정적 메서드는 대상 클래스의 첫 번째 매개 변수와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3335bc6567d5a0923632b42415b2259b7d1a9ca9" translate="yes" xml:space="preserve">
          <source>This class defines new Java 6 specific groovy methods which extend the normal JDK classes inside the Groovy environment. Static methods are used with the first parameter the destination class.</source>
          <target state="translated">이 클래스는 Groovy 환경 내에서 일반 JDK 클래스를 확장하는 새로운 Java 6 특정 그루비 메서드를 정의합니다. 정적 메서드는 대상 클래스의 첫 번째 매개 변수와 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fbc656debe43046569a9d23c80bd193a41215a53" translate="yes" xml:space="preserve">
          <source>This class defines new Java 6 specific static groovy methods which extend the normal JDK classes inside the Groovy environment.</source>
          <target state="translated">이 클래스는 Groovy 환경 내에서 일반 JDK 클래스를 확장하는 새로운 Java 6 특정 정적 그루비 메서드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="48c87f705bf49123468d54ad93a33becf3eeea6d" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods for Files, URLs, URIs which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter being the destination class, i.e. &lt;code&gt;public static long size(File self)&lt;/code&gt; provides a &lt;code&gt;size()&lt;/code&gt; method for &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 Groovy 환경 내의 일반 JDK 클래스에 나타나는 파일, URL, URI에 대한 새로운 그루비 메서드를 정의합니다. 정적 메서드는 첫 번째 매개 변수는 대상 클래스 인에 사용되는, 즉 &lt;code&gt;public static long size(File self)&lt;/code&gt; 제공 &lt;code&gt;size()&lt;/code&gt; 에 대한 방법 &lt;code&gt;File&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aea9ee44a185e75c57ac3db064101c0dc7b71846" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods for Readers, Writers, InputStreams and OutputStreams which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter being the destination class, i.e. &lt;code&gt;public static T eachLine(InputStream self, Closure c)&lt;/code&gt; provides a &lt;code&gt;eachLine(Closure c)&lt;/code&gt; method for &lt;code&gt;InputStream&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 Groovy 환경 내의 일반 JDK 클래스에 나타나는 Readers, Writers, InputStreams 및 OutputStreams에 대한 새로운 그루비 메서드를 정의합니다. 고정 방법은 첫 번째 파라미터가 대상 클래스 인으로 사용되는, 즉 &lt;code&gt;public static T eachLine(InputStream self, Closure c)&lt;/code&gt; 제공 &lt;code&gt;eachLine(Closure c)&lt;/code&gt; 에 대한 방법 &lt;code&gt;InputStream&lt;/code&gt; 에서 .</target>
        </trans-unit>
        <trans-unit id="eb04b5af77efd219c4b5a9414f1ff8646ff26a61" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods for Sockets which enhance JDK classes inside the Groovy environment.</source>
          <target state="translated">이 클래스는 Groovy 환경 내에서 JDK 클래스를 향상시키는 소켓에 대한 새로운 그루비 메서드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="94e1494a582102e49d29876303786a0362da0d77" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on Jaxb-related JDK classes (&lt;code&gt;JAXBContext&lt;/code&gt;, &lt;code&gt;Marshaller&lt;/code&gt;) inside the Groovy environment. Static methods are used with the first parameter being the destination class.</source>
          <target state="translated">이 클래스는 Groovy 환경 내의 Jaxb 관련 JDK 클래스 ( &lt;code&gt;JAXBContext&lt;/code&gt; , &lt;code&gt;Marshaller&lt;/code&gt; ) 에 나타나는 새로운 그루비 메서드를 정의 합니다. 정적 메서드는 첫 번째 매개 변수가 대상 클래스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="afb7507827959ad4b29159fe5d7fffc42f2f585e" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on String-related JDK classes (String, CharSequence, Matcher) inside the Groovy environment. Static methods are used with the first parameter being the destination class, e.g. &lt;code&gt;public static String reverse(String self)&lt;/code&gt; provides a &lt;code&gt;reverse()&lt;/code&gt; method for &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 Groovy 환경 내의 String 관련 JDK 클래스 (String, CharSequence, Matcher)에 나타나는 새로운 그루비 메서드를 정의합니다. 고정 방법은 첫 번째 파라미터가 대상 클래스 인으로 사용되는, 예를 들어 &lt;code&gt;public static String reverse(String self)&lt;/code&gt; 제공 &lt;code&gt;reverse()&lt;/code&gt; 에 대한 방법 &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f855a0c8edce7e177b8b45a6cbe1be9748fa85a5" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on normal JDK Date and Calendar classes inside the Groovy environment.</source>
          <target state="translated">이 클래스는 Groovy 환경 내의 일반 JDK Date 및 Calendar 클래스에 나타나는 새로운 그루비 메서드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7539a6b02de0acc678a620086fdddde40b1d36f7" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on normal JDK classes inside the Groovy environment. Static methods are used with the first parameter being the destination class, i.e. &lt;code&gt;public static String reverse(String self)&lt;/code&gt; provides a &lt;code&gt;reverse()&lt;/code&gt; method for &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 Groovy 환경 내의 일반 JDK 클래스에 나타나는 새로운 그루비 메서드를 정의합니다. 고정 방법은 첫 번째 파라미터가 대상 클래스 인으로 사용되는, 즉 &lt;code&gt;public static String reverse(String self)&lt;/code&gt; 제공 &lt;code&gt;reverse()&lt;/code&gt; 에 대한 방법 &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22d775343e0c1cedc8e65538de82853d5aec499d" translate="yes" xml:space="preserve">
          <source>This class defines new groovy methods which appear on normal JDK classes related to process management.</source>
          <target state="translated">이 클래스는 프로세스 관리와 관련된 일반 JDK 클래스에 나타나는 새로운 그루비 메서드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="93c83296c1339bc893ca28a97ad7ad9e35c69b38" translate="yes" xml:space="preserve">
          <source>This class defines new groovy static methods which appear on normal JDK Date and Calendar classes inside the Groovy environment.</source>
          <target state="translated">이 클래스는 Groovy 환경 내의 일반 JDK Date 및 Calendar 클래스에 나타나는 새로운 멋진 정적 메서드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="48764622300d44ff21eff5891fc9ff2ebe3f07cb" translate="yes" xml:space="preserve">
          <source>This class defines new static extension methods which appear on normal JDK Date/Time API (java.time) classes inside the Groovy environment.</source>
          <target state="translated">이 클래스는 Groovy 환경 내의 일반 JDK 날짜 / 시간 API (java.time) 클래스에 나타나는 새로운 정적 확장 메서드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="cf24bf76d96add06db8b90790f6d00a2cfad2055" translate="yes" xml:space="preserve">
          <source>This class does not provide the ability to customize the resulting output. A &lt;a href=&quot;jsongenerator&quot;&gt;JsonGenerator&lt;/a&gt; can be used if the ability to alter the resulting output is required.</source>
          <target state="translated">이 클래스는 결과 출력을 사용자 정의하는 기능을 제공하지 않습니다. &lt;a href=&quot;jsongenerator&quot;&gt;JsonGenerator는&lt;/a&gt; 결과 출력을 변경할 수있는 기능이 필요한 경우 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c469cd04a8269f915fbdad81a3e9c2f515539197" translate="yes" xml:space="preserve">
          <source>This class handles caching internally and its advisable to not store references directly to objects of this class. The static factory method &lt;a href=&quot;classinfo#getClassInfo(java.lang.Class)&quot;&gt;ClassInfo.getClassInfo&lt;/a&gt; should be used to retrieve an instance from the cache. Internally the &lt;code&gt;Class&lt;/code&gt; associated with a &lt;code&gt;ClassInfo&lt;/code&gt; instance is kept as &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ref/WeakReference.html&quot;&gt;WeakReference&lt;/a&gt;, so it not safe to reference and instance without the Class being either strongly or softly reachable.</source>
          <target state="translated">이 클래스는 내부적으로 캐싱을 처리하며이 클래스의 객체에 대한 참조를 직접 저장하지 않는 것이 좋습니다. 정적 팩토리 메소드 &lt;a href=&quot;classinfo#getClassInfo(java.lang.Class)&quot;&gt;ClassInfo.getClassInfo&lt;/a&gt; 를 사용하여 캐시에서 인스턴스를 검색해야합니다. 내부적 으로 &lt;code&gt;ClassInfo&lt;/code&gt; 인스턴스 와 연결된 &lt;code&gt;Class&lt;/code&gt; 는 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ref/WeakReference.html&quot;&gt;WeakReference&lt;/a&gt; 로 유지 되므로 클래스가 강력하거나 부드럽게 연결되지 않고 참조 및 인스턴스화하는 것은 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6dde5778cb52a324896ffae7cfbf596d97d66c91" translate="yes" xml:space="preserve">
          <source>This class handles converting Strings to ASTNode lists.</source>
          <target state="translated">이 클래스는 문자열을 ASTNode 목록으로 변환하는 작업을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="9e92e6926c2a201584cdcb9f5d948909b564b830" translate="yes" xml:space="preserve">
          <source>This class handles the invocation of the ASTAnnotationTransformation when it is encountered by a tree walk. One instance of each exists for each phase of the compilation it applies to. Before invocation the</source>
          <target state="translated">이 클래스는 트리 워크에서 만날 때 ASTAnnotationTransformation의 호출을 처리합니다. 적용되는 컴파일의 각 단계마다 각 인스턴스가 하나씩 있습니다. 호출하기 전에</target>
        </trans-unit>
        <trans-unit id="c7e6d3f76a3c4311415b9304af550d64f39dd083" translate="yes" xml:space="preserve">
          <source>This class has several inner classes that also helps picking generic argument types instead of the parameter type.</source>
          <target state="translated">이 클래스에는 매개 변수 유형 대신 일반 인수 유형을 선택하는 데 도움이되는 여러 내부 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3837874bec8e4931d877954a86a0917c89371a7f" translate="yes" xml:space="preserve">
          <source>This class is &lt;b&gt;not&lt;/b&gt; thread-safe.</source>
          <target state="translated">이 클래스는 스레드로부터 안전 &lt;b&gt;하지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="bb171051a560c489be8ec957676e4fd0c5c42c0f" translate="yes" xml:space="preserve">
          <source>This class is a general adapter to adapt a closure to any Java interface.</source>
          <target state="translated">이 클래스는 모든 Java 인터페이스에 대한 클로저를 적용하는 일반 어댑터입니다.</target>
        </trans-unit>
        <trans-unit id="1904a5f416e052d74d08f3361764dad66bf5f12b" translate="yes" xml:space="preserve">
          <source>This class is a general adapter to adapt a map of closures to any Java interface.</source>
          <target state="translated">이 클래스는 모든 Java 인터페이스에 대한 클로저 맵을 적용하는 일반 어댑터입니다.</target>
        </trans-unit>
        <trans-unit id="cd0e9b1d846e158bbf918633b43cd721a0206943" translate="yes" xml:space="preserve">
          <source>This class is a general adapter to map a call to a Java interface to a given delegate.</source>
          <target state="translated">이 클래스는 Java 인터페이스에 대한 호출을 지정된 대리자로 매핑하는 일반 어댑터입니다.</target>
        </trans-unit>
        <trans-unit id="407993abd5f454fb2d6c0556db6a1d0ca2f05505" translate="yes" xml:space="preserve">
          <source>This class is extended by several hint providers that make it easier to use as annotation values.</source>
          <target state="translated">이 클래스는 주석 값으로 더 쉽게 사용할 수있는 여러 힌트 공급자에 의해 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="75718b0560771207235791afb3b9fda1625fc4bb" translate="yes" xml:space="preserve">
          <source>This class is for internal use only! This class will dispatch to the right type adapters according to the kind of binary expression that is provided.</source>
          <target state="translated">이 클래스는 내부 전용입니다! 이 클래스는 제공된 이진 표현식의 종류에 따라 올바른 유형 어댑터로 디스패치합니다.</target>
        </trans-unit>
        <trans-unit id="76d7804b1c6dc7652647c993f4fdf0eded744a8a" translate="yes" xml:space="preserve">
          <source>This class is important to the performance of the parser. It stores Value objects in a map where they are evaluated lazily. This is great for JSONPath types of application, and Object Serialization but not for maps that are going to be stored in a cache.</source>
          <target state="translated">이 클래스는 파서의 성능에 중요합니다. 값 개체를 느리게 평가되는 맵에 저장합니다. 이는 JSONPath 유형의 애플리케이션 및 객체 직렬화에 적합하지만 캐시에 저장 될 맵에는 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96572291f640285f4a1f9ecf3aa073f0a992daab" translate="yes" xml:space="preserve">
          <source>This class is instantiated and invoked when an AST transformation is activated. For Global AST Transformations, this interface is called once per SourceUnit, which is usually a Groovy source file. For Local AST Transformations, this interface is invoked once every time the Local annotation marker is encountered.</source>
          <target state="translated">이 클래스는 AST 변환이 활성화 될 때 인스턴스화되고 호출됩니다. Global AST Transformations의 경우이 인터페이스는 일반적으로 Groovy 소스 파일 인 SourceUnit 당 한 번씩 호출됩니다. Local AST Transformations의 경우이 인터페이스는 Local 주석 마커를 만날 때마다 한 번씩 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cc67996ced277a761581444c4cf862c08d075467" translate="yes" xml:space="preserve">
          <source>This class is responsible for assembling JMX Attribute Info from the meta map. It cycles through the meta map from the Node and generate JMX Info objects used to expose information in the MBeanServer.</source>
          <target state="translated">이 클래스는 메타 맵에서 JMX 속성 정보를 어셈블하는 역할을합니다. 노드에서 메타 맵을 순환하고 MBeanServer에서 정보를 노출하는 데 사용되는 JMX Info 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="075476029820d79cc983f42159f8eb4cdea63809" translate="yes" xml:space="preserve">
          <source>This class is responsible for assembling JMX Operation Info from the meta map. It cycles through the provided meta map from the bean() node and generate JMX Info objects used to expose information in the MBeanServer.</source>
          <target state="translated">이 클래스는 메타 맵에서 JMX 작업 정보를 어셈블하는 역할을합니다. bean () 노드에서 제공된 메타 맵을 순환하고 MBeanServer에서 정보를 노출하는 데 사용되는 JMX Info 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4b30124afd1417d4b385c76f80bcf34578d51bd0" translate="yes" xml:space="preserve">
          <source>This class is the base for any annotation alias processor.</source>
          <target state="translated">이 클래스는 모든 주석 별칭 프로세서의 기본입니다.</target>
        </trans-unit>
        <trans-unit id="5924197edb00c649d5d755fc6516a87d87145be3" translate="yes" xml:space="preserve">
          <source>This class is the factory for the emitter node. This node facilitates the declaration of a JMX event emitter. The emitter is used to broadcast arbitrary event on the MBeanServer's event bus. Registered listeners are able to consume event once sent.</source>
          <target state="translated">이 클래스는 이미 터 노드의 팩토리입니다. 이 노드는 JMX 이벤트 이미 터의 선언을 용이하게합니다. 이미 터는 MBeanServer의 이벤트 버스에서 임의의 이벤트를 브로드 캐스트하는 데 사용됩니다. 등록 된 리스너는 전송 된 이벤트를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="653683ec37c7baebfd2f2bbe95b36d002cf25d2e" translate="yes" xml:space="preserve">
          <source>This class is used as a pluggable way to resolve class names. An instance of this class has to be added to &lt;a href=&quot;compilationunit&quot;&gt;CompilationUnit&lt;/a&gt; using &lt;a href=&quot;compilationunit#setClassNodeResolver(org.codehaus.groovy.control.ClassNodeResolver)&quot;&gt;CompilationUnit.setClassNodeResolver&lt;/a&gt;. The CompilationUnit will then set the resolver on the &lt;a href=&quot;resolvevisitor&quot;&gt;ResolveVisitor&lt;/a&gt; each time new. The ResolveVisitor will prepare name lookup and then finally ask the resolver if the class exists. This resolver then can return either a SourceUnit or a ClassNode. In case of a SourceUnit the compiler is notified that a new source is to be added to the compilation queue. In case of a ClassNode no further action than the resolving is done. The lookup result is stored in the helper class LookupResult. This class provides a class cache to cache lookups. If you don't want this, you have to override the methods &lt;a href=&quot;classnoderesolver#cacheClass(java.lang.String,%20org.codehaus.groovy.ast.ClassNode)&quot;&gt;ClassNodeResolver.cacheClass&lt;/a&gt; and &lt;a href=&quot;classnoderesolver#getFromClassCache(java.lang.String)&quot;&gt;ClassNodeResolver.getFromClassCache&lt;/a&gt;. Custom lookup logic is supposed to go into the method &lt;a href=&quot;classnoderesolver#findClassNode(java.lang.String,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;ClassNodeResolver.findClassNode&lt;/a&gt; while the entry method is &lt;a href=&quot;classnoderesolver#resolveName(java.lang.String,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;ClassNodeResolver.resolveName&lt;/a&gt;</source>
          <target state="translated">이 클래스는 클래스 이름을 확인하기위한 플러그 가능한 방법으로 사용됩니다. 이 클래스의 인스턴스는 &lt;a href=&quot;compilationunit&quot;&gt;CompilationUnit.setClassNodeResolver를&lt;/a&gt; 사용하여 &lt;a href=&quot;compilationunit#setClassNodeResolver(org.codehaus.groovy.control.ClassNodeResolver)&quot;&gt;CompilationUnit에&lt;/a&gt; 추가해야 합니다. 그러면 CompilationUnit은 새로 &lt;a href=&quot;resolvevisitor&quot;&gt;만들&lt;/a&gt; 때마다 ResolveVisitor에 리졸버를 설정합니다 . ResolveVisitor는 이름 조회를 준비한 다음 마지막으로 클래스가 있는지 확인자에게 묻습니다. 이 리졸버는 SourceUnit 또는 ClassNode를 반환 할 수 있습니다. SourceUnit의 경우 컴파일러는 새 소스가 컴파일 큐에 추가된다는 알림을받습니다. ClassNode의 경우 해결보다 더 이상의 조치가 수행되지 않습니다. 조회 결과는 도우미 클래스 LookupResult에 저장됩니다. 이 클래스는 조회를 캐시하기위한 클래스 캐시를 제공합니다. 원하지 않으면 메서드를 재정의해야합니다.&lt;a href=&quot;classnoderesolver#cacheClass(java.lang.String,%20org.codehaus.groovy.ast.ClassNode)&quot;&gt;ClassNodeResolver.cacheClass&lt;/a&gt; 및 &lt;a href=&quot;classnoderesolver#getFromClassCache(java.lang.String)&quot;&gt;ClassNodeResolver.getFromClassCache&lt;/a&gt; . 사용자 지정 조회 논리는 &lt;a href=&quot;classnoderesolver#findClassNode(java.lang.String,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;ClassNodeResolver.findClassNode&lt;/a&gt; 메서드로 이동해야 하며 항목 메서드는 &lt;a href=&quot;classnoderesolver#resolveName(java.lang.String,%20org.codehaus.groovy.control.CompilationUnit)&quot;&gt;ClassNodeResolver.resolveName입니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f14354187c290397fd82b9881697595ff4486600" translate="yes" xml:space="preserve">
          <source>This class is used internally by the compiler to transform expressions like multiple assignments into a list of assignments.</source>
          <target state="translated">이 클래스는 다중 할당과 같은 표현식을 할당 목록으로 변환하기 위해 컴파일러에서 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8b644eb64cd81a47f8da1cd879e99bb7530c7027" translate="yes" xml:space="preserve">
          <source>This class is used to describe generic type signatures for ClassNodes.</source>
          <target state="translated">이 클래스는 ClassNode의 제네릭 형식 서명을 설명하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ec6a7563ff7840c43f2735a87393e68cb11d3a71" translate="yes" xml:space="preserve">
          <source>This class is used to make extension methods lookup faster. Basically, it will only collect the list of extension methods (see &lt;a href=&quot;../../runtime/m12n/extensionmodule&quot;&gt;ExtensionModule&lt;/a&gt; if the list of extension modules has changed. It avoids recomputing the whole list each time we perform a method lookup.</source>
          <target state="translated">이 클래스는 확장 메서드를 더 빠르게 조회하는 데 사용됩니다. 기본적으로 확장 메서드 목록 만 수집합니다 ( 확장 모듈 목록이 변경된 경우 &lt;a href=&quot;../../runtime/m12n/extensionmodule&quot;&gt;ExtensionModule&lt;/a&gt; 참조). 메서드 조회를 수행 할 때마다 전체 목록을 다시 계산하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5036dcc6c04f6c16da5439995a0999d3e2a24e94" translate="yes" xml:space="preserve">
          <source>This class may be used as a direct replacement for any use of java.util.Hashtable that does not depend on readers being blocked during updates. Like Hashtable but unlike java.util.HashMap, this class does NOT allow</source>
          <target state="translated">이 클래스는 업데이트 중에 차단되는 판독기에 의존하지 않는 java.util.Hashtable 사용에 대한 직접 대체로 사용될 수 있습니다. Hashtable과 비슷하지만 java.util.HashMap과 달리이 클래스는</target>
        </trans-unit>
        <trans-unit id="d272b41b9db7786d68de80b43d127b8fd19109cd" translate="yes" xml:space="preserve">
          <source>This class mutates the Java AST, whilst it is still a Java AST, in readiness for conversion to Groovy, yippee-ky-a !</source>
          <target state="translated">이 클래스는 Groovy, yippee-ky-a로 변환 할 준비가 된 상태에서 Java AST를 변경하지만 여전히 Java AST입니다.</target>
        </trans-unit>
        <trans-unit id="55d9c8517d3a0e99ce14f62132a7aaace2185bbd" translate="yes" xml:space="preserve">
          <source>This class provides a very simple linked list of memory managed elements. This class does not support concurrent modifications nor will it check for them. This class is also not thread safe.</source>
          <target state="translated">이 클래스는 메모리 관리 요소의 매우 간단한 연결 목록을 제공합니다. 이 클래스는 동시 수정을 지원하지 않으며이를 확인하지도 않습니다. 이 클래스는 스레드로부터 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28a37ccc500981db234c339f5342ff417d4b979f" translate="yes" xml:space="preserve">
          <source>This class provides an AST Transformation to add a log field to a class.</source>
          <target state="translated">이 클래스는 로그 필드를 클래스에 추가하기위한 AST 변환을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b3a68d6bf431714254204e9288b4f6f5070f27cb" translate="yes" xml:space="preserve">
          <source>This class provides an empty implementation of &lt;a href=&quot;groovyparservisitor&quot;&gt;GroovyParserVisitor&lt;/a&gt;, which can be extended to create a visitor which only needs to handle a subset of the available methods.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;groovyparservisitor&quot;&gt;GroovyParserVisitor&lt;/a&gt; 의 빈 구현을 제공하며 , 사용 가능한 메서드의 하위 집합 만 처리하면되는 방문자를 생성하도록 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9b1f302f9aedce71bb6896db58d1478516c5a7c" translate="yes" xml:space="preserve">
          <source>This class provides helper methods to determine the type from a widening operation for example for a plus operation.</source>
          <target state="translated">이 클래스는 더하기 연산과 같은 확대 연산에서 유형을 결정하는 도우미 메서드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9d718529ccca05eed963c102f62e0edbdeac53d0" translate="yes" xml:space="preserve">
          <source>This class represents a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; that is optimized for a small number of entries. For a number of entries up to &lt;code&gt;listSize&lt;/code&gt; the entries are stored in arrays. After &lt;code&gt;listSize&lt;/code&gt; entries are exceeded storage switches internally to a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; and converts back to being array based when its size is less than or equal to &lt;code&gt;listSize&lt;/code&gt;. Null keys or values are not supported. This class is not thread safe.</source>
          <target state="translated">이 클래스는 적은 수의 항목에 최적화 된 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;맵&lt;/a&gt; 을 나타냅니다 . &lt;code&gt;listSize&lt;/code&gt; 까지의 많은 항목의 경우 항목이 배열에 저장됩니다. &lt;code&gt;listSize&lt;/code&gt; 항목이 초과 된 후 스토리지는 내부적으로 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; 으로 전환되고 크기가 &lt;code&gt;listSize&lt;/code&gt; 보다 작거나 같을 때 다시 배열 기반으로 변환됩니다 . Null 키 또는 값은 지원되지 않습니다. 이 클래스는 스레드로부터 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0f6265e2af3bfac2864af2a93fa49da29483f821" translate="yes" xml:space="preserve">
          <source>This class represents a MetaMethod that is a closure that pretends to be a static method. It is used by ExpandoMetaClass to allow addition of static methods defined as closures</source>
          <target state="translated">이 클래스는 정적 메서드 인 것처럼 가장하는 클로저 인 MetaMethod를 나타냅니다. ExpandoMetaClass에서 클로저로 정의 된 정적 메서드를 추가하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ff97f4943b1b4f4e15e6cd296448b65369de926" translate="yes" xml:space="preserve">
          <source>This class represents a list of expressions used to create closures. Example: &lt;code&gt;
 def foo = (1;2;;)
 &lt;/code&gt; The right side is a ClosureListExpression consisting of two ConstantExpressions for the values 1 and 2, and two EmptyStatement entries. The ClosureListExpression defines a new variable scope. All created Closures share this scope.</source>
          <target state="translated">이 클래스는 클로저를 만드는 데 사용되는 표현식 목록을 나타냅니다. 예 : &lt;code&gt; def foo = (1;2;;) &lt;/code&gt; 오른쪽은 값 1과 2에 대한 두 개의 ConstantExpressions와 두 개의 EmptyStatement 항목으로 구성된 ClosureListExpression입니다. ClosureListExpression은 새로운 변수 범위를 정의합니다. 생성 된 모든 클로저는이 범위를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="e490a48691949cdd943dd24ddf11e92b18b4c106" translate="yes" xml:space="preserve">
          <source>This class represents a property with multiple setters. Unlike a MetaBeanProperty you cannot get the setter in this case. Instead invocation is done through the meta class of the property recevier.</source>
          <target state="translated">이 클래스는 여러 setter가있는 속성을 나타냅니다. MetaBeanProperty와 달리이 경우 setter를 가져올 수 없습니다. 대신 호출은 속성 수신자의 메타 클래스를 통해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b9fe55eb136f2d9bda5b170f7ec0b6ef4984da04" translate="yes" xml:space="preserve">
          <source>This class represents a reference to the most actual incarnation of a Metaclass. INTERNAL USE ONLY.</source>
          <target state="translated">이 클래스는 Metaclass의 가장 실제 화신에 대한 참조를 나타냅니다. 내부 용.</target>
        </trans-unit>
        <trans-unit id="b1af226539f2899b14379794e0635a39c3ce7e1e" translate="yes" xml:space="preserve">
          <source>This class represents a sequence of &lt;a href=&quot;bytecodeinstruction&quot;&gt;BytecodeInstruction&lt;/a&gt;s or &lt;a href=&quot;../ast/astnode&quot;&gt;ASTNode&lt;/a&gt;s. The evaluation is depending on the type of the visitor.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;bytecodeinstruction&quot;&gt;BytecodeInstruction&lt;/a&gt; 또는 &lt;a href=&quot;../ast/astnode&quot;&gt;ASTNode&lt;/a&gt; 시퀀스를 나타냅니다 . 평가는 방문자 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5460585a78cb458d104b1c09f4518524d3250db9" translate="yes" xml:space="preserve">
          <source>This class represents an error that is thrown when a bug is recognized inside the runtime. Basically it is thrown when a constraint is not fulfilled that should be fulfilled.</source>
          <target state="translated">이 클래스는 런타임 내에서 버그가 인식 될 때 발생하는 오류를 나타냅니다. 기본적으로 충족되어야하는 제약 조건이 충족되지 않을 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9e8efb041e1d70cfb3206ad25e6c209a78c9bbd0" translate="yes" xml:space="preserve">
          <source>This class represents non public API used by AsmClassGenerator. Don't use this class in your code</source>
          <target state="translated">이 클래스는 AsmClassGenerator에서 사용하는 비 공용 API를 나타냅니다. 코드에서이 클래스를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8dc5c7fcffd17f002fdf6362493892385bbec93d" translate="yes" xml:space="preserve">
          <source>This class returns half bound &lt;a href=&quot;fullbinding&quot;&gt;FullBinding&lt;/a&gt;s on the source half to the model object for every property reference (and I do mean every, valid or not, queried before or not). These returned half bindings are stored strongly in a list when generated. Changing the model will keep all existing bindings but change the source on all of the bindings. Formerly Known as Model Binding.</source>
          <target state="translated">이 클래스는 모든 속성 참조에 대한 모델 개체에 대한 소스 절반의 절반 바인딩 &lt;a href=&quot;fullbinding&quot;&gt;FullBinding을&lt;/a&gt; 반환합니다 (그리고 이전에 쿼리 된 모든 항목, 유효 여부, 쿼리되지 않음). 이러한 반환 된 절반 바인딩은 생성 될 때 목록에 강력하게 저장됩니다. 모델을 변경하면 기존 바인딩은 모두 유지되지만 모든 바인딩의 소스는 변경됩니다. 이전에는 모델 바인딩으로 알려졌습니다.</target>
        </trans-unit>
        <trans-unit id="9e6c51aebeac50037713f9721b08801c77dc34e7" translate="yes" xml:space="preserve">
          <source>This class returns half bound &lt;a href=&quot;fullbinding&quot;&gt;FullBinding&lt;/a&gt;s on the source half to the model object for every property reference (and I do mean every, valid or not, queried before or not). These returned half bindings are stored strongly in a list when generated. Changing the model will keep all existing bindings but change the source on all of the bininfs Formerly Known as Model Binding.</source>
          <target state="translated">이 클래스는 모든 속성 참조에 대한 모델 개체에 대한 소스 절반의 절반 바인딩 &lt;a href=&quot;fullbinding&quot;&gt;FullBinding을&lt;/a&gt; 반환합니다 (그리고 이전에 쿼리 된 모든 항목, 유효 여부, 쿼리되지 않음). 이러한 반환 된 절반 바인딩은 생성 될 때 목록에 강력하게 저장됩니다. 모델을 변경하면 기존 바인딩은 모두 유지되지만 이전에 모델 바인딩으로 알려진 모든 bininf의 소스는 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="c8b96a7d9802784a5662432c77e71b4d3622ca61" translate="yes" xml:space="preserve">
          <source>This class takes Groovy source code, compiles it to a specific compile phase, and then decompiles it back to the groovy source. It is used by GroovyConsole's AST Browser, but can also be invoked from the command line.</source>
          <target state="translated">이 클래스는 Groovy 소스 코드를 가져 와서 특정 컴파일 단계로 컴파일 한 다음 그루비 소스로 다시 디 컴파일합니다. GroovyConsole의 AST 브라우저에서 사용되지만 명령 줄에서도 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="806720aed213bca40586cfe6fc91e7e7625aa6f6" translate="yes" xml:space="preserve">
          <source>This class will delegate all calls to a WriterController given in the constructor.</source>
          <target state="translated">이 클래스는 생성자에 주어진 WriterController에 모든 호출을 위임합니다.</target>
        </trans-unit>
        <trans-unit id="2c4727fcfc1ab42e56910178a7ab2ce60355d891" translate="yes" xml:space="preserve">
          <source>This code is executed after the method is called.</source>
          <target state="translated">이 코드는 메서드가 호출 된 후에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="3715f6b9738b222d0f7aca024f9cc5c22e37d357" translate="yes" xml:space="preserve">
          <source>This code is executed after the method is optionally called.</source>
          <target state="translated">이 코드는 메서드가 선택적으로 호출 된 후에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="93109698a32aa712b1940a99bdbc8567f3433156" translate="yes" xml:space="preserve">
          <source>This code is executed before the method is called.</source>
          <target state="translated">이 코드는 메서드가 호출되기 전에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="75ed3577608647dd335811066a354027a410204a" translate="yes" xml:space="preserve">
          <source>This code is executed before the method is optionally called.</source>
          <target state="translated">이 코드는 메서드가 선택적으로 호출되기 전에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="c4b42f2f4e1fd4b46e3443559ab2f4536ce215e3" translate="yes" xml:space="preserve">
          <source>This code is transformed by the compiler into something resembling the following snippet. Notice the difference between a String and a def/Object property:</source>
          <target state="translated">이 코드는 컴파일러에 의해 다음 코드 조각과 유사한 것으로 변환됩니다. String과 def / Object 속성의 차이점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="c33c1278e97a91dcb6edf06c86644b99e9f271d8" translate="yes" xml:space="preserve">
          <source>This comparator is used when we return the list of methods from DGM which name correspond to a given name.</source>
          <target state="translated">이 비교기는 주어진 이름에 해당하는 이름이 DGM에서 메서드 목록을 반환 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e75617b624f61b0683d73241b7a0d46ab3599d9b" translate="yes" xml:space="preserve">
          <source>This comparator is used when we return the list of methods from DGM which name correspond to a given name. As we also lookup for DGM methods of superclasses or interfaces, it may be possible to find two methods which have the same name and the same arguments. In that case, we should not add the method from superclass or interface otherwise the system won't be able to select the correct method, resulting in an ambiguous method selection for similar methods.</source>
          <target state="translated">이 비교기는 주어진 이름에 해당하는 이름이 DGM에서 메서드 목록을 반환 할 때 사용됩니다. 슈퍼 클래스 나 인터페이스의 DGM 메서드도 검색 할 때 이름과 인수가 같은 두 메서드를 찾을 수 있습니다. 이 경우 슈퍼 클래스 나 인터페이스에서 메서드를 추가해서는 안됩니다. 그렇지 않으면 시스템이 올바른 메서드를 선택할 수 없어 유사한 메서드에 대해 모호한 메서드 선택이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4894b9b16a69165c0c31e618c60bcc10ce7fe009" translate="yes" xml:space="preserve">
          <source>This compilation customizer allows addiing various types of imports to the compilation unit. Supports adding:</source>
          <target state="translated">이 컴파일 커 스터 마이저를 사용하면 다양한 유형의 가져 오기를 컴파일 단위에 추가 할 수 있습니다. 추가 지원 :</target>
        </trans-unit>
        <trans-unit id="9ba2a85f884d7fa0e633cdb111b7b24677cc8a10" translate="yes" xml:space="preserve">
          <source>This completer tries to behave as similar as possible to</source>
          <target state="translated">이 완료자는 가능한 한 유사하게 작동하려고합니다.</target>
        </trans-unit>
        <trans-unit id="050f26d61c4d7297780b69903203f0b647dfe314" translate="yes" xml:space="preserve">
          <source>This constant is for comparing targetBytecode to ensure it is set to JDK 1.5 or later.</source>
          <target state="translated">이 상수는 targetBytecode를 비교하여 JDK 1.5 이상으로 설정되었는지 확인하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c8629d832b003b8c89dc03855aac1608ff5226a1" translate="yes" xml:space="preserve">
          <source>This constant is for comparing targetBytecode to ensure it is set to an earlier value than JDK 1.5.</source>
          <target state="translated">이 상수는 targetBytecode를 비교하여 JDK 1.5보다 이전 값으로 설정되었는지 확인하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="d318776f0e97720de67dae45081b1705371f4405" translate="yes" xml:space="preserve">
          <source>This constructor is public to permit tools that require a JavaBean instance to operate.</source>
          <target state="translated">이 생성자는 JavaBean 인스턴스가 작동하는 데 필요한 도구를 허용하기 위해 공용입니다.</target>
        </trans-unit>
        <trans-unit id="adebfc74f0005704245e8892d5946a9a3b3e0d7b" translate="yes" xml:space="preserve">
          <source>This converts a possibly negative index to a real index into the array.</source>
          <target state="translated">이것은 음수 인덱스를 배열의 실제 인덱스로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="89580999f8cc2ab98adcb35587949a71043dac5a" translate="yes" xml:space="preserve">
          <source>This creates and starts the socket server on a new Thread.</source>
          <target state="translated">그러면 새 스레드에서 소켓 서버가 생성되고 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="4cfe97596d83c01a3c1b2f921489c411e8f50f6a" translate="yes" xml:space="preserve">
          <source>This creates and starts the socket server on a new Thread. There is no need to call run or spawn a new thread yourself.</source>
          <target state="translated">그러면 새 스레드에서 소켓 서버가 생성되고 시작됩니다. run을 호출하거나 새 스레드를 직접 생성 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f210b6ef5e62f107b81d83cc8ea5f60a3593e2ba" translate="yes" xml:space="preserve">
          <source>This customizer allows applying an AST transformation to a source unit with several strategies. Creating a customizer with the &lt;a href=&quot;asttransformationcustomizer#ASTTransformationCustomizer(java.lang.Class)&quot;&gt; class constructor&lt;/a&gt; will trigger an AST transformation for each class node of a source unit. However, you cannot pass parameters to the annotation so the default values will be used. Writing :</source>
          <target state="translated">이 커 스터 마이저를 사용하면 여러 전략을 사용하여 AST 변환을 소스 유닛에 적용 할 수 있습니다. &lt;a href=&quot;asttransformationcustomizer#ASTTransformationCustomizer(java.lang.Class)&quot;&gt;클래스 생성자&lt;/a&gt; 로 커 스터 마이저를 생성하면 소스 유닛의 각 클래스 노드에 대해 AST 변환이 트리거됩니다. 그러나 매개 변수를 주석에 전달할 수 없으므로 기본값이 사용됩니다. 쓰기 :</target>
        </trans-unit>
        <trans-unit id="7c14dcaf1099adb43e65b7bae2bb439c3ad65669" translate="yes" xml:space="preserve">
          <source>This customizer allows securing source code by controlling what code constructs are permitted. This is typically done when using Groovy for its scripting or domain specific language (DSL) features. For example, if you only want to allow arithmetic operations in a groovy shell, you can configure this customizer to restrict package imports, method calls and so on.</source>
          <target state="translated">이 커 스터 마이저를 사용하면 허용되는 코드 구성을 제어하여 소스 코드를 보호 할 수 있습니다. 일반적으로 스크립팅 또는 DSL (도메인 특정 언어) 기능에 Groovy를 사용할 때 수행됩니다. 예를 들어, 그루비 셸에서 산술 연산 만 허용하려는 경우 패키지 가져 오기, 메서드 호출 등을 제한하도록이 커 스터 마이저를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5a34da6d1a917395eafdae691fc9b3b8e14c4ed" translate="yes" xml:space="preserve">
          <source>This differs from normal setters in that we need to add a declared exception java.beans.PropertyVetoException</source>
          <target state="translated">이것은 선언 된 예외 java.beans.PropertyVetoException을 추가해야한다는 점에서 일반 setter와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a09a623dc06b4ba819cd522a87f90fc6033ededc" translate="yes" xml:space="preserve">
          <source>This enumeration can be used whenever it is preferred to annotate a class as &lt;a href=&quot;typechecked&quot;&gt;TypeChecked&lt;/a&gt; in general, but where only one or more methods are &quot;dynamic&quot;. This allows the user to annotate the class itself then annotate only the methods which require exclusion.</source>
          <target state="translated">이 열거 형은 일반적으로 클래스에 &lt;a href=&quot;typechecked&quot;&gt;TypeChecked&lt;/a&gt; 로 주석을 추가하는 것이 선호 될 때마다 사용할 수 있지만 하나 이상의 메서드 만 &quot;동적&quot;인 경우입니다. 이를 통해 사용자는 클래스 자체에 주석을 추가 한 다음 제외가 필요한 메서드에만 주석을 달 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7e2273d5cb9c0c49c2bb24c5a83bf004429212a" translate="yes" xml:space="preserve">
          <source>This enumeration is used by the AST transformations which rely on static type checking, either to store or to retrieve information from AST node metadata. The values of this enumeration are used as metadata keys.</source>
          <target state="translated">이 열거 형은 AST 노드 메타 데이터에서 정보를 저장하거나 검색하기 위해 정적 유형 검사에 의존하는 AST 변환에서 사용됩니다. 이 열거의 값은 메타 데이터 키로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ab60dfbbe5ec836f7b35f8c976d66e68b2ce1c5a" translate="yes" xml:space="preserve">
          <source>This example prints out file counts and size aggregates for groovy source files within a directory tree:</source>
          <target state="translated">이 예제는 디렉토리 트리 내의 그루비 소스 파일에 대한 파일 수 및 크기 집계를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b3f387a9504f8b156c1813987d3758205ede705a" translate="yes" xml:space="preserve">
          <source>This example shows a common convention. When mixing short and long names, the short names are often one character in size. One character options with arguments don't require a space between the option and the argument, e.g. &lt;code&gt;-Ddebug=true&lt;/code&gt;. The example also shows the use of '_' when no short option is applicable.</source>
          <target state="translated">이 예는 일반적인 규칙을 보여줍니다. 짧은 이름과 긴 이름을 혼합 할 때 짧은 이름은 종종 한 문자 크기입니다. 인수가있는 한 문자 옵션은 옵션과 인수 사이에 공백이 필요하지 않습니다 (예 : &lt;code&gt;-Ddebug=true&lt;/code&gt; ) . 이 예에서는 짧은 옵션을 적용 할 수없는 경우 '_'사용도 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f2dddbad35ebae3e8699d18932c17e50f8f9d1bb" translate="yes" xml:space="preserve">
          <source>This example uses a mix of the JSP style and GString style placeholders but you can typically use just one style if you wish. Running this example will produce this output:</source>
          <target state="translated">이 예에서는 JSP 스타일과 GString 스타일 자리 표시자를 혼합하여 사용하지만 일반적으로 원하는 경우 하나의 스타일 만 사용할 수 있습니다. 이 예제를 실행하면 다음 출력이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7819bf00abfa1a28062447c4112ec17536e74c15" translate="yes" xml:space="preserve">
          <source>This example will produce this output:</source>
          <target state="translated">이 예제는 다음 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6a9df6b19f4850ac1dca0ca99754733c1765bf4e" translate="yes" xml:space="preserve">
          <source>This exception is thrown if an attempt is made to set a read only property</source>
          <target state="translated">읽기 전용 속성을 설정하려고하면이 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c3c90e86c15b6995f6996affd8fd0622412caea4" translate="yes" xml:space="preserve">
          <source>This exception is thrown if the runtime is unable to select a method. This class builds the exception text when calling getMessage.</source>
          <target state="translated">런타임이 메소드를 선택할 수없는 경우이 예외가 발생합니다. 이 클래스는 getMessage를 호출 할 때 예외 텍스트를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="7a099c6f741eb0347d0ea40c91b286e1ba7e1c6f" translate="yes" xml:space="preserve">
          <source>This extension also supports optional type checking of the model</source>
          <target state="translated">이 확장은 모델의 선택적 유형 검사도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2e0f02c76915f7464bc8c11fd1e37c238231e442" translate="yes" xml:space="preserve">
          <source>This factory allows the generation of a &lt;a href=&quot;../secureastcustomizer&quot;&gt;SecureASTCustomizer&lt;/a&gt;. Embedded elements are delegated to a &lt;a href=&quot;../secureastcustomizer&quot;&gt;SecureASTCustomizer&lt;/a&gt; instance.</source>
          <target state="translated">이 팩토리는 &lt;a href=&quot;../secureastcustomizer&quot;&gt;SecureASTCustomizer&lt;/a&gt; 생성을 허용합니다 . 포함 된 요소는 &lt;a href=&quot;../secureastcustomizer&quot;&gt;SecureASTCustomizer&lt;/a&gt; 인스턴스에 위임됩니다 .</target>
        </trans-unit>
        <trans-unit id="75bc8d98e4b55661fc8e92d226274681ee70c5d6" translate="yes" xml:space="preserve">
          <source>This factory allows the generation of an &lt;a href=&quot;../importcustomizer&quot;&gt;import customizer&lt;/a&gt;. You may embed several elements:</source>
          <target state="translated">이 팩토리에서는 &lt;a href=&quot;../importcustomizer&quot;&gt;가져 오기 사용자 정의 프로그램을&lt;/a&gt; 생성 할 수 있습니다 . 여러 요소를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6408936103d79d9191656e5b5b91824ad76e65c7" translate="yes" xml:space="preserve">
          <source>This factory class is used to create a listener() node for JmxBuilder. Listener nodes are used to create a generic event listener (that is automatically registered with the MBean) that can handle any event broadcasted on the MBeanServer's event bus.</source>
          <target state="translated">이 팩토리 클래스는 JmxBuilder 용 listener () 노드를 생성하는 데 사용됩니다. 리스너 노드는 MBeanServer의 이벤트 버스에서 브로드 캐스트 된 모든 이벤트를 처리 할 수있는 일반 이벤트 리스너 (MBean에 자동으로 등록됨)를 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="64a41a5aefc83666cff21add72710b51c3a25d2f" translate="yes" xml:space="preserve">
          <source>This factory generates an ASTTransformationCustomizer.</source>
          <target state="translated">이 팩토리는 ASTTransformationCustomizer를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="613b0e8a47bfd00974cb820fbc8fcdabb33420f9" translate="yes" xml:space="preserve">
          <source>This factory generates an array of compilation customizers.</source>
          <target state="translated">이 팩토리는 컴파일 커 스터 마이저의 배열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9250f3138d28ed13d750ef456e16992d0448f7fb" translate="yes" xml:space="preserve">
          <source>This factory is the correct way to wire together a Groovy parser and lexer.</source>
          <target state="translated">이 팩토리는 Groovy 파서와 렉서를 연결하는 올바른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="92ce93b17831cccaf34755de29d405aee9ba805a" translate="yes" xml:space="preserve">
          <source>This factory lets a user define a compilation customizer without having to define an anonymous inner class.</source>
          <target state="translated">이 팩토리를 사용하면 익명의 내부 클래스를 정의하지 않고도 컴파일 커 스터 마이저를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f3cad60cfab134b21507e52064941c3963e3069" translate="yes" xml:space="preserve">
          <source>This factory returns a container node for all other nodes that are used to collect meta data for resources that are exported to the MBeanServer for management.</source>
          <target state="translated">이 팩토리는 관리를 위해 MBeanServer로 내 보내진 자원의 메타 데이터를 수집하는 데 사용되는 다른 모든 노드에 대한 컨테이너 노드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="974ec32a45157e53b4a9707aa7c20f425a6b5889" translate="yes" xml:space="preserve">
          <source>This factory returns the bean() node. This node is used to declaratively expose a POGO/POJO to be exported to the MBeanServer for management. You can use the builder node to declare the descriptor or embed the descriptor directly in the object being exposed using static variable descriptor (or jmx). You should note that embedded descriptor takes precedence over declared builder descriptor.</source>
          <target state="translated">이 팩토리는 bean () 노드를 반환합니다. 이 노드는 관리를 위해 MBeanServer로 내보낼 POGO / POJO를 선언적으로 노출하는 데 사용됩니다. 빌더 노드를 사용하여 설명자를 선언하거나 정적 변수 설명자 (또는 jmx)를 사용하여 노출되는 오브젝트에 설명자를 직접 임베드 할 수 있습니다. 임베디드 디스크립터는 선언 된 빌더 디스크립터보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="34a50447c879fcb2342872b489a204ccc49314ed" translate="yes" xml:space="preserve">
          <source>This feature is particularly useful on operating systems which place limitations on the size of the command line (e.g. Windows). The feature is similar to the 'Command Line Argument File' processing supported by javadoc and javac. Consult the corresponding documentation for those tools if you wish to see further examples.</source>
          <target state="translated">이 기능은 명령 줄 (예 : Windows)의 크기에 제한을 두는 운영 체제에서 특히 유용합니다. 이 기능은 javadoc 및 javac에서 지원하는 'Command Line Argument File'처리와 유사합니다. 추가 예제를 보려면 해당 도구에 대한 해당 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ce367d20dbb2c637770c58d933db6117f53236b0" translate="yes" xml:space="preserve">
          <source>This field is used to track assignments in if/else branches, for loops and while loops.</source>
          <target state="translated">이 필드는 if / else 분기, for 루프 및 while 루프에서 할당을 추적하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cbf12fc93c6526242b10d4458cb6d1beee3e2d25" translate="yes" xml:space="preserve">
          <source>This field is used to track assignments in if/else branches, for loops and while loops. For example, in the following code: &lt;code&gt;if (cond) { x = 1 } else { x = '123' }&lt;/code&gt; the inferred type of x after the if/else statement should be the LUB of int and String.</source>
          <target state="translated">이 필드는 if / else 분기, for 루프 및 while 루프에서 할당을 추적하는 데 사용됩니다. 예를 들어, 다음 코드에서 &lt;code&gt;if (cond) { x = 1 } else { x = '123' }&lt;/code&gt; if / else 문 뒤에있는 x의 유추 된 유형은 int 및 String의 LUB 여야합니다.</target>
        </trans-unit>
        <trans-unit id="1d467559145b6ea3f70124f19c4aef65c4321104" translate="yes" xml:space="preserve">
          <source>This field used for type derivation Check IfStatement matched pattern: Object var1; if (!</source>
          <target state="translated">이 필드는 유형 파생에 사용됩니다. Check IfStatement 일치 패턴 : Object var1; 만약 (!</target>
        </trans-unit>
        <trans-unit id="0bd93366cf93d2b7dd6b74705e67955660b7f0e0" translate="yes" xml:space="preserve">
          <source>This field used for type derivation Check IfStatement matched pattern: Object var1; if (!(var1 instanceOf Runnable)){ return } // Here var1 instance of Runnable</source>
          <target state="translated">이 필드는 유형 파생에 사용됩니다. Check IfStatement 일치 패턴 : Object var1; if (! (var1 instanceOf Runnable)) {return} // 여기에서 Runnable의 var1 인스턴스</target>
        </trans-unit>
        <trans-unit id="b090238d44551f2e3d0b2f1cf114fd579922fca8" translate="yes" xml:space="preserve">
          <source>This fixes strict jline 2.12 ArgumentCompleter See https://github.com/jline/jline2/pull/202</source>
          <target state="translated">이것은 엄격한 jline 2.12를 수정합니다. ArgumentCompleter https://github.com/jline/jline2/pull/202 참조</target>
        </trans-unit>
        <trans-unit id="850443fd7300e262bc8d43a95f5840748fef1125" translate="yes" xml:space="preserve">
          <source>This gets the code statement of the closure.</source>
          <target state="translated">이것은 클로저의 코드 문을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="692a8f7be3be9f9075aa6a114742d6a2eca54b83" translate="yes" xml:space="preserve">
          <source>This gets the code statement of the closure. You can read this method to find out what actions the closure is going to perform.</source>
          <target state="translated">이것은 클로저의 코드 문을 얻습니다. 이 메서드를 읽고 클로저가 수행 할 작업을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a0d23a5c458818da1444db6470960e4731416f6" translate="yes" xml:space="preserve">
          <source>This has the same interface as the original JsonSlurper written for version 1.8.0, but its implementation has completely changed. It is now up to 20x faster than before, and its speed competes and often substantially exceeds popular common JSON parsers circa Jan, 2014.</source>
          <target state="translated">이것은 버전 1.8.0 용으로 작성된 원래 JsonSlurper와 동일한 인터페이스를 갖지만 구현이 완전히 변경되었습니다. 이제 이전보다 최대 20 배 더 빠르며 속도가 경쟁하며 종종 2014 년 1 월경에 널리 사용되는 일반적인 JSON 파서를 상당히 초과합니다.</target>
        </trans-unit>
        <trans-unit id="f01f9c203f4513ef8926ff9ee372b31db329b713" translate="yes" xml:space="preserve">
          <source>This hint handles all those cases by picking the generics from the first argument of the method (by default).</source>
          <target state="translated">이 힌트는 메서드의 첫 번째 인수 (기본값)에서 제네릭을 선택하여 모든 경우를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8328da1e3c3000c040f7a4774ac735b142d97837" translate="yes" xml:space="preserve">
          <source>This holds a mapping from value key to value value to maximize laziness.</source>
          <target state="translated">게으름을 최대화하기 위해 값 키에서 값 값으로의 매핑을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="74974d1e6f40fe28cb6229fba49e41c77b4b9dfd" translate="yes" xml:space="preserve">
          <source>This implementation breaks the contract of &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html#get(int)&quot;&gt;List.get&lt;/a&gt; as it a) possibly modifies the underlying list and b) does NOT throw an &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/IndexOutOfBoundsException.html&quot;&gt;IndexOutOfBoundsException&lt;/a&gt; when &lt;code&gt;index &amp;lt; 0 || index &amp;gt;= size()&lt;/code&gt;.</source>
          <target state="translated">이 구현은 a) 기본 목록을 수정하고 b) &lt;code&gt;index &amp;lt; 0 || index &amp;gt;= size()&lt;/code&gt; 때 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/IndexOutOfBoundsException.html&quot;&gt;IndexOutOfBoundsException을&lt;/a&gt; 던지지 않기 때문에 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html#get(int)&quot;&gt;List.get&lt;/a&gt; 의 계약을 깨뜨립니다. 색인&amp;gt; = size () .</target>
        </trans-unit>
        <trans-unit id="b8e1fbe89d11c8857d6efca6ff572126bb4b9fb0" translate="yes" xml:space="preserve">
          <source>This implementation provides a verbosity flag switching log statements. The servlet init parameter name is:</source>
          <target state="translated">이 구현은 로그 문을 전환하는 자세한 플래그를 제공합니다. 서블릿 초기화 매개 변수 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bfe169c077ea389406a1a9f2f85518f31a03e1e3" translate="yes" xml:space="preserve">
          <source>This interface allows the user to provide a custom expression checker if the dis/allowed expression lists are not sufficient</source>
          <target state="translated">이 인터페이스를 사용하면 금지 / 허용 된 표현식 목록이 충분하지 않은 경우 사용자가 사용자 정의 표현식 검사기를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f685dd51bbeafd50fa968a283a1c649d74afa7b5" translate="yes" xml:space="preserve">
          <source>This interface allows the user to provide a custom statement checker if the dis/allowed statement lists are not sufficient</source>
          <target state="translated">이 인터페이스를 통해 사용자는 금지 / 허용 된 명령문 목록이 충분하지 않은 경우 사용자 정의 명령문 검사기를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2337efc6043edb753db0bcb30b3f4690571b8928" translate="yes" xml:space="preserve">
          <source>This interface defines a complete generic visitor for a parse tree produced by &lt;a href=&quot;groovyparser&quot;&gt;GroovyParser&lt;/a&gt;.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;groovyparser&quot;&gt;GroovyParser가&lt;/a&gt; 생성 한 구문 분석 트리에 대한 완전한 일반 방문자를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="2900e3be61204d298b4a3fee9de9690a314c1fa7" translate="yes" xml:space="preserve">
          <source>This interface defines a high-level API for handling type checking errors. As a dynamic language and a platform for developing DSLs, the Groovy language provides a lot of means to supply custom bindings or methods that are not possible to find at compile time. However, it is still possible to help the compiler, for example by telling it what is the type of an unresolved property. For basic DSL type checking, implementing those methods would help the type checker and make it silent where it normally throws errors.</source>
          <target state="translated">이 인터페이스는 유형 검사 오류를 처리하기위한 고급 API를 정의합니다. 동적 언어이자 DSL 개발을위한 플랫폼 인 Groovy 언어는 컴파일 타임에 찾을 수없는 사용자 지정 바인딩 또는 메서드를 제공하는 많은 수단을 제공합니다. 그러나 예를 들어 해결되지 않은 속성의 유형을 알려주는 방식으로 컴파일러를 도울 수 있습니다. 기본적인 DSL 유형 검사의 경우 이러한 메서드를 구현하면 유형 검사기가 도움이되고 일반적으로 오류가 발생하는 곳에서 침묵을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14a3094142b4fffa63ea1c44ae063fa652e1bd9e" translate="yes" xml:space="preserve">
          <source>This interface is for AST transformations which must be aware of the compilation unit where they are applied.</source>
          <target state="translated">이 인터페이스는 적용되는 컴파일 단위를 알고 있어야하는 AST 변환 용입니다.</target>
        </trans-unit>
        <trans-unit id="b19bc498138b8f77f8e42e14567db95fb471708c" translate="yes" xml:space="preserve">
          <source>This is JmxBuilder's factory builder class. It is the parent node to all other children nodes supported by JmxBuilder.</source>
          <target state="translated">JmxBuilder의 팩토리 빌더 클래스입니다. JmxBuilder에서 지원하는 다른 모든 자식 노드의 부모 노드입니다.</target>
        </trans-unit>
        <trans-unit id="5f542101a83909bc55b807fe7fad6cb48b595713" translate="yes" xml:space="preserve">
          <source>This is a Token sub class to track line information</source>
          <target state="translated">라인 정보를 추적하는 Token 하위 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="b5b6cd0c90811ee4dbf92dd31e30b69e6a4b7932" translate="yes" xml:space="preserve">
          <source>This is a basic implementation of a map able to forget its values. This map uses internally a ConcurrentHashMap, thus should be safe for concurrency. hashcode and equals are used to find the entries and should thus be implemented properly for the keys. This map does not support null keys.</source>
          <target state="translated">이것은 값을 잊을 수있는지도의 기본 구현입니다. 이 맵은 내부적으로 ConcurrentHashMap을 사용하므로 동시성에 안전해야합니다. 해시 코드와 같음은 항목을 찾는 데 사용되므로 키에 대해 적절하게 구현되어야합니다. 이 맵은 널 키를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ecd84853e48a3218ca7dae60fa14210067325fe4" translate="yes" xml:space="preserve">
          <source>This is a basic parser with no index overlay.</source>
          <target state="translated">인덱스 오버레이가없는 기본 파서입니다.</target>
        </trans-unit>
        <trans-unit id="bd1aba50be39fcc34d283e005a86755e0b3badd7" translate="yes" xml:space="preserve">
          <source>This is a basic parser with no index overlay. It is wicked fast, but not as fast at the INDEX_OVERLAY. It should be on average the fastest known JSON parser on the JVM circa Jan 2014. But not as fast as INDEX_OVERLAY.</source>
          <target state="translated">인덱스 오버레이가없는 기본 파서입니다. 빠르지 만 INDEX_OVERLAY에서는 빠르지 않습니다. 2014 년 1 월경 JVM에서 평균적으로 가장 빠른 JSON 파서 여야합니다.하지만 INDEX_OVERLAY만큼 빠르지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d663199a467bd31d2d6cc978eef89dea6a3add1" translate="yes" xml:space="preserve">
          <source>This is a bit of plumbing which resumes collection of string constructor bodies, after an embedded expression has been parsed.</source>
          <target state="translated">이것은 포함 된 표현식이 구문 분석 된 후 문자열 생성자 본문의 수집을 재개하는 약간의 연결입니다.</target>
        </trans-unit>
        <trans-unit id="229cccdf96ec491181b6b4aefce4ce6c2b429a0f" translate="yes" xml:space="preserve">
          <source>This is a bit of plumbing which resumes collection of string constructor bodies, after an embedded expression has been parsed. Usage: new GroovyRecognizer(new GroovyLexer(in).plumb()).</source>
          <target state="translated">이것은 포함 된 표현식이 구문 분석 된 후 문자열 생성자 본문의 수집을 재개하는 약간의 연결입니다. 사용법 : new GroovyRecognizer (new GroovyLexer (in) .plumb ()).</target>
        </trans-unit>
        <trans-unit id="0186d9b2589f2bdddecc55d72affdc0ae0321117" translate="yes" xml:space="preserve">
          <source>This is a bit of plumbing which resumes collection of string constructor bodies, after an embedded expression has been parsed. Usage: new JavaRecognizer(new JavaLexer(in).plumb()).</source>
          <target state="translated">이것은 포함 된 표현식이 구문 분석 된 후 문자열 생성자 본문의 수집을 재개하는 약간의 연결입니다. 사용법 : new JavaRecognizer (new JavaLexer (in) .plumb ()).</target>
        </trans-unit>
        <trans-unit id="8f11df9510d09a2eefc345dd606cc8bb630671ad" translate="yes" xml:space="preserve">
          <source>This is a generated class used internally during the writing of bytecode within the CallSiteWriter logic. This is not a class exposed to users, as is the case with almost all classes in the org.codehaus.groovy packages.</source>
          <target state="translated">이것은 CallSiteWriter 로직 내에서 바이트 코드를 작성하는 동안 내부적으로 사용되는 생성 된 클래스입니다. 이것은 org.codehaus.groovy 패키지의 거의 모든 클래스의 경우처럼 사용자에게 노출되는 클래스가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8988c21207c9c0283d7bdfe9794fc76b8616da94" translate="yes" xml:space="preserve">
          <source>This is a helper class introduced in Groovy 2.1.0, which is used only by indy. This class is for internal use only.</source>
          <target state="translated">이것은 indy에서만 사용되는 Groovy 2.1.0에 도입 된 도우미 클래스입니다. 이 클래스는 내부 전용입니다.</target>
        </trans-unit>
        <trans-unit id="fd736de461897ac841a6a4d9f0a851a81005bbd5" translate="yes" xml:space="preserve">
          <source>This is a helper class, to provide a controlled entry point for the groovyc ant task forked mode.</source>
          <target state="translated">이것은 groovyc ant 작업 분기 모드에 대한 제어 된 진입 점을 제공하기위한 도우미 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="1e04a2a9657e4a822125c0bfc5d51625bdcd91ab" translate="yes" xml:space="preserve">
          <source>This is a hook for subclasses to plugin a custom strategy for mapping names to explicit methods.</source>
          <target state="translated">이것은 명시 적 메서드에 이름을 매핑하기위한 사용자 지정 전략을 플러그인하는 하위 클래스에 대한 후크입니다.</target>
        </trans-unit>
        <trans-unit id="6073183624d646ab13405c550c66ceae2d7e6073" translate="yes" xml:space="preserve">
          <source>This is a hook for subclasses to plugin a custom strategy for mapping names to factories.</source>
          <target state="translated">이것은 하위 클래스가 이름을 공장에 매핑하기위한 사용자 지정 전략을 플러그인하는 후크입니다.</target>
        </trans-unit>
        <trans-unit id="3873541ad75fb8f477c82880ea8c90da25f7477f" translate="yes" xml:space="preserve">
          <source>This is a hook for subclasses to plugin a custom strategy for mapping names to property methods.</source>
          <target state="translated">이것은 속성 메서드에 이름을 매핑하기위한 사용자 지정 전략을 플러그인하는 하위 클래스에 대한 후크입니다.</target>
        </trans-unit>
        <trans-unit id="851a6e18d0cb9ae66a159433966e5c40ef10ca00" translate="yes" xml:space="preserve">
          <source>This is a implementation of DL distance between two Object arrays instead of character streams.</source>
          <target state="translated">이것은 문자 스트림 대신 두 오브젝트 어레이 사이의 DL 거리 구현입니다.</target>
        </trans-unit>
        <trans-unit id="e5dc74906a59f9ecb021663128a7faa33f6bff55" translate="yes" xml:space="preserve">
          <source>This is a implementation of DL distance between two Object arrays instead of character streams. The objects are compared using their equals method. No objects may be null. This implementation is based on Chas Emerick's implementation of Levenshtein Distance for jakarta commons.</source>
          <target state="translated">이것은 문자 스트림 대신 두 오브젝트 어레이 사이의 DL 거리 구현입니다. 객체는 equals 방법을 사용하여 비교됩니다. 어떤 개체도 null이 될 수 없습니다. 이 구현은 Chas Emerick의 자카르타 커먼즈에 대한 Levenshtein Distance 구현을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="3f63b7ad6a94acd9220b6ceb153faa4b94cff8d8" translate="yes" xml:space="preserve">
          <source>This is a slightly modified version of the Damerau Levenshtein distance algorithm.</source>
          <target state="translated">이것은 Damerau Levenshtein 거리 알고리즘의 약간 수정 된 버전입니다.</target>
        </trans-unit>
        <trans-unit id="6379b9e33df64353e3c1267e96d9abfd788c6427" translate="yes" xml:space="preserve">
          <source>This is a slightly modified version of the Damerau Levenshtein distance algorithm. It has a additional test to see if a character has switched case, in the original algorithm this counts as a substitution. The &quot;cost&quot; for a substitution is given as 10 instead of 1 in this version, this enables transpositions and case modifications to have a lower cost than substitutions. Currently the lowercase versions of t_j and s_i isn't cached, its probable that some speed could be gained from this. This version is based on Chas Emerick's implementation of Levenshtein Distance for jakarta commons.</source>
          <target state="translated">이것은 Damerau Levenshtein 거리 알고리즘의 약간 수정 된 버전입니다. 문자가 대소 문자를 바꾸 었는지 확인하는 추가 테스트가 있습니다. 원래 알고리즘에서는 대체로 간주됩니다. 이 버전에서는 대체에 대한 &quot;비용&quot;이 1 대신 10으로 주어지며,이를 통해 전치 및 대소 문자 수정이 대체보다 비용이 적게 듭니다. 현재 t_j 및 s_i의 소문자 버전은 캐시되지 않으며 이로 인해 약간의 속도를 얻을 수 있습니다. 이 버전은 Chas Emerick의 자카르타 커먼즈를위한 Levenshtein Distance 구현을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="1edb3c98dd64270eec01a19ffa8efd13aa8ca31a" translate="yes" xml:space="preserve">
          <source>This is a static access auto download enabler.</source>
          <target state="translated">이것은 정적 액세스 자동 다운로드 Enabler입니다.</target>
        </trans-unit>
        <trans-unit id="116aa4ab4439a80ee9ba7112e165f856489f00f2" translate="yes" xml:space="preserve">
          <source>This is a static access auto download enabler. It will set the 'autoDownload' value to the passed in arguments map if not already set. If 'autoDownload' is set the value will not be adjusted.</source>
          <target state="translated">이것은 정적 액세스 자동 다운로드 Enabler입니다. 아직 설정되지 않은 경우 'autoDownload'값을 전달 된 인수 맵으로 설정합니다. 'autoDownload'가 설정되어 있으면 값이 조정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="858274acd50bf067c3073a5802ebcb847cb11033" translate="yes" xml:space="preserve">
          <source>This is a static access kill-switch.</source>
          <target state="translated">이것은 정적 액세스 킬 스위치입니다.</target>
        </trans-unit>
        <trans-unit id="6fe1b6d5fdbc3093d68f9306c05bf649d9053221" translate="yes" xml:space="preserve">
          <source>This is a static access kill-switch. All of the static shortcut methods in this class will not work if this property is set to false. By default it is set to true.</source>
          <target state="translated">이것은 정적 액세스 킬 스위치입니다. 이 속성이 false로 설정되면이 클래스의 모든 정적 바로 가기 메서드가 작동하지 않습니다. 기본적으로 true로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9354b1e014a107432bcac0ae43777acc06c0de53" translate="yes" xml:space="preserve">
          <source>This is a utility class used as a helper for JmxBuilder.</source>
          <target state="translated">JmxBuilder의 도우미로 사용되는 유틸리티 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="a5225ac2335eb47576067c0b8960cb72cb13bccd" translate="yes" xml:space="preserve">
          <source>This is also different than scripting.dev.java.net which used an initial lowercase.</source>
          <target state="translated">이것은 초기 소문자를 사용하는 scripting.dev.java.net 과도 다릅니다.</target>
        </trans-unit>
        <trans-unit id="579c6bcb0a618a267161c2207b075c96e7d5d24d" translate="yes" xml:space="preserve">
          <source>This is also different than scripting.dev.java.net which used an initial lowercase. But these are proper names and should be capitalized.</source>
          <target state="translated">이것은 초기 소문자를 사용하는 scripting.dev.java.net 과도 다릅니다. 그러나 이들은 고유 이름이므로 대문자로 표기해야합니다.</target>
        </trans-unit>
        <trans-unit id="85d017a024d6049f47ed0da7428c2774554debb2" translate="yes" xml:space="preserve">
          <source>This is an AST Node that provides some sort of looping mechanism. Typically in the form of a block that will be executed repeatedly. DoWhileStatements, WhileStatements, and ForStatements are all examples of LoopingStatements.</source>
          <target state="translated">이것은 일종의 루핑 메커니즘을 제공하는 AST 노드입니다. 일반적으로 반복적으로 실행되는 블록 형태입니다. DoWhileStatements, WhileStatements 및 ForStatements는 모두 LoopingStatements의 예입니다.</target>
        </trans-unit>
        <trans-unit id="0c9815db791daee2a8e2b715b6bdfe0a35a3e307" translate="yes" xml:space="preserve">
          <source>This is an annotation on a class, currently just &lt;a href=&quot;asttransformation&quot;&gt;ASTTransformation&lt;/a&gt;. This provides information about how and when to apply the transformation, such as what phase it should be applied in. The allowed phase is a function of how the transformation is introduced into the compile process. If the transform is automatically added via a marker annotation only the SEMANTIC_ANALYSIS and latter phases are legal for the phase(). This is because the annotations are not inspected until after the classes are all resolved. Also, only annotation types present during the SEMANTIC_ANALYSIS phase will be handled. Transformations adding other annotations that are transformable will have those new annotations only considered in latter phases, and only if the type was present in the source unit during SEMANTIC_ANALYSIS.</source>
          <target state="translated">이것은 클래스에 대한 주석이며 현재는 &lt;a href=&quot;asttransformation&quot;&gt;ASTTransformation&lt;/a&gt; 입니다. 이는 어떤 단계에 적용되어야하는지와 같이 변환을 적용하는 방법과시기에 대한 정보를 제공합니다. 허용 된 단계는 변환이 컴파일 프로세스에 도입되는 방법에 대한 함수입니다. 마커 주석을 통해 변환이 자동으로 추가되는 경우 SEMANTIC_ANALYSIS 및 후반 단계 만 phase ()에 적합합니다. 이는 클래스가 모두 해결 될 때까지 주석이 검사되지 않기 때문입니다. 또한 SEMANTIC_ANALYSIS 단계 중에 존재하는 주석 유형 만 처리됩니다. 변환 가능한 다른 주석을 추가하는 변환은 SEMANTIC_ANALYSIS 동안 유형이 소스 유닛에 존재하는 경우에만 후반 단계에서만 고려되는 새 주석을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="11e12582da84504f1479b7b5bbe01a600457f89e" translate="yes" xml:space="preserve">
          <source>This is because the Value construct is a type of index overlay that merely tracks where the token is located in the buffer, and what if any thing we noted about it (like can be converted to a decimal number, etc.).  To mitigate memory leaks this class along with CharSequenceValue implement two constructs, namely, chop, and lazyChop.  A chop is when we convert backing buffer of a Value object into a smaller buffer. A lazyChop is when we do a chop but only when a get operation is called.  The lazyChop is performed on the tree that is touched by the JSONPath expression or its ilk.  The chop operation can be done during parsing or lazily by storing the values in this construct.</source>
          <target state="translated">이는 Value 구조가 토큰이 버퍼에있는 위치를 추적하는 인덱스 오버레이 유형이기 때문이며, 우리가 그것에 대해 언급 한 것이 있다면 (십진수로 변환 할 수있는 등) 어떨까요? 메모리 누수를 완화하기 위해이 클래스는 CharSequenceValue와 함께 chop 및 lazyChop이라는 두 가지 구성을 구현합니다. 찹은 Value 객체의 백업 버퍼를 더 작은 버퍼로 변환하는 것입니다. lazyChop은 촙을 할 때이지만 get 오퍼레이션이 호출 될 때만 발생합니다. lazyChop은 JSONPath 표현식 또는 ilk에 의해 접촉되는 트리에서 수행됩니다. 절단 작업은 구문 분석 중 또는이 구문에 값을 저장하여 느리게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="741dcdf92b314485a30d1f79b83cc4f348ec1d58" translate="yes" xml:space="preserve">
          <source>This is commonly used to simplify object creation, such as this example:</source>
          <target state="translated">이것은 일반적으로 다음 예제와 같이 객체 생성을 단순화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1248b519078b17c04626ddc0fb70c6f2e9facdfe" translate="yes" xml:space="preserve">
          <source>This is especially useful when executing foreign scripts that you do not have control over. Inject this transformation into a script that you need to interrupt based on some custom criteria.</source>
          <target state="translated">이것은 제어 할 수없는 외부 스크립트를 실행할 때 특히 유용합니다. 일부 사용자 지정 기준에 따라 중단해야하는 스크립트에이 변환을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="64f713a0f10d16561ee1c527588ce545628f9d79" translate="yes" xml:space="preserve">
          <source>This is especially useful when executing foreign scripts that you do not have control over. Inject this transformation into a script that you need to interrupt.</source>
          <target state="translated">이것은 제어 할 수없는 외부 스크립트를 실행할 때 특히 유용합니다. 중단해야하는 스크립트에이 변환을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="5f5f8b6a917691ae26019a384a5b0e4890168174" translate="yes" xml:space="preserve">
          <source>This is especially useful when executing foreign scripts that you do not have control over. Inject this transformation into a script that you want to timeout after a specified amount of time.</source>
          <target state="translated">이것은 제어 할 수없는 외부 스크립트를 실행할 때 특히 유용합니다. 지정된 시간 후에 시간 초과하려는 스크립트에이 변환을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="282c12052be9cf10b5ec3f4611f0fd964e9e4aa8" translate="yes" xml:space="preserve">
          <source>This is for internal use only.</source>
          <target state="translated">이것은 내부 전용입니다.</target>
        </trans-unit>
        <trans-unit id="58697d7fd61dc831ec59911b870e50930ffb3220" translate="yes" xml:space="preserve">
          <source>This is for internal use only. When an argument method is null, we cannot determine its type, so we use this one as a wildcard.</source>
          <target state="translated">이것은 내부 전용입니다. 인수 메서드가 null이면 형식을 결정할 수 없으므로이 메서드를 와일드 카드로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4110ed8e2a3513345d548ed89e5744b457556f9f" translate="yes" xml:space="preserve">
          <source>This is helpful for tests that don't currently work but should work one day, when the tested functionality has been implemented.</source>
          <target state="translated">이는 현재 작동하지 않지만 테스트 된 기능이 구현 된 어느 날 작동해야하는 테스트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="40f30890de5ca0bafe206b76653f0c2a1f3cc299" translate="yes" xml:space="preserve">
          <source>This is just a dummy value used because String annotations values can not be null.</source>
          <target state="translated">이것은 문자열 주석 값이 null 일 수 없기 때문에 사용되는 더미 값입니다.</target>
        </trans-unit>
        <trans-unit id="6be2a0c0559d3297ae4eb1f68ef079c6642f7daf" translate="yes" xml:space="preserve">
          <source>This is just a dummy value used because String annotations values can not be null. It will be replaced by the fully qualified class name of the annotated class.</source>
          <target state="translated">이것은 문자열 주석 값이 null 일 수 없기 때문에 사용되는 더미 값입니다. 주석이 달린 클래스의 정규화 된 클래스 이름으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="7cfc24f9ba4df725de185c873e645d95b8f9a980" translate="yes" xml:space="preserve">
          <source>This is mostly for debugging and testing.</source>
          <target state="translated">이것은 주로 디버깅 및 테스트 용입니다.</target>
        </trans-unit>
        <trans-unit id="755a53945cc3fcceccdbfdf945d1dd8ce166c6d1" translate="yes" xml:space="preserve">
          <source>This is not 100% true for days. Days can actually be 23, 24 or 25 hours long (due to daylight saving adjustments.)</source>
          <target state="translated">이것은 며칠 동안 100 % 사실이 아닙니다. 실제로 하루는 23, 24 또는 25 시간이 될 수 있습니다 (일광 절약 조정으로 인해).</target>
        </trans-unit>
        <trans-unit id="e69572989e14bc32e4253df5a71968b90a55a7b4" translate="yes" xml:space="preserve">
          <source>This is similar to pop on a Stack where the first item in the list represents the top of the stack. Note: The behavior of this method changed in Groovy 2.5 to align with Java. If you need the old behavior use 'removeLast'.</source>
          <target state="translated">이것은 목록의 첫 번째 항목이 스택의 맨 위를 나타내는 스택의 팝과 유사합니다. 참고 :이 메서드의 동작은 Java에 맞게 Groovy 2.5에서 변경되었습니다. 이전 동작이 필요한 경우 'removeLast'를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2541054c8b1af0657d417013a4c3cc09b16432fc" translate="yes" xml:space="preserve">
          <source>This is similar to push on a Stack where the first item in the list represents the top of the stack. Note: The behavior of this method changed in Groovy 2.5 to align with Java. If you need the old behavior use 'add'.</source>
          <target state="translated">이는 목록의 첫 번째 항목이 스택의 맨 위를 나타내는 스택에 푸시하는 것과 유사합니다. 참고 :이 메서드의 동작은 Java에 맞게 Groovy 2.5에서 변경되었습니다. 이전 동작이 필요한 경우 'add'를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="aef33e4880a31dfb6572ddc1eafa9904f03c5153" translate="yes" xml:space="preserve">
          <source>This is so we don't have to reorder the stack when we call this method.</source>
          <target state="translated">따라서이 메서드를 호출 할 때 스택을 재정렬 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e6d75685c8a50a89d652d071d7093c3bf15cd602" translate="yes" xml:space="preserve">
          <source>This is so we don't have to reorder the stack when we call this method. At some point a better name might be in order.</source>
          <target state="translated">따라서이 메서드를 호출 할 때 스택을 재정렬 할 필요가 없습니다. 어떤 시점에서 더 나은 이름이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f165cfd45f1ba553776e75f2e2f8cd2ea732f465" translate="yes" xml:space="preserve">
          <source>This is the base class for classes responsible for creating modules using properties.</source>
          <target state="translated">속성을 사용하여 모듈을 생성하는 클래스의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="afb852c75331161be3de5047f08fe81e729e8211" translate="yes" xml:space="preserve">
          <source>This is the complement the behavior of the decapitalize(string) method.</source>
          <target state="translated">이것은 decapitalize (string) 메서드의 동작을 보완합니다.</target>
        </trans-unit>
        <trans-unit id="80b2bed606ff187cd7718223d7b85bc65c304789" translate="yes" xml:space="preserve">
          <source>This is the complement the behavior of the decapitalize(string) method. We handle names that begin with an initial lowerCase followed by upperCase with special JavaBean behavior (which is to make no change). See GROOVY-3211.</source>
          <target state="translated">이것은 decapitalize (string) 메서드의 동작을 보완합니다. 우리는 초기 lowerCase로 시작하고 그 뒤에 특별한 JavaBean 동작을 가진 upperCase가 뒤 따르는 이름을 처리합니다. GROOVY-3211을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="aa3d520cd1c348add237bd7a66f5ecae3276e75e" translate="yes" xml:space="preserve">
          <source>This is the factory for node JmxBuilder.connectorClient. A call to this node returns an instance of the JMXConnector interface.</source>
          <target state="translated">JmxBuilder.connectorClient 노드의 팩토리입니다. 이 노드를 호출하면 JMXConnector 인터페이스의 인스턴스가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1940febb7e000c374518f8af3b2bab8b6e867ba7" translate="yes" xml:space="preserve">
          <source>This is the grammar for what can follow a dot: x.a, x.</source>
          <target state="translated">다음은 점을 따를 수있는 것에 대한 문법입니다 : xa, x.</target>
        </trans-unit>
        <trans-unit id="40f014c6ef17ec9a663f43144dcaa01def5b2977" translate="yes" xml:space="preserve">
          <source>This is the grammar for what can follow a dot: x.a, x.@a, x.&amp;amp;a, x.'a', etc. Note: &lt;code&gt;typeArguments&lt;/code&gt; is handled by the caller of &lt;code&gt;namePart&lt;/code&gt;.</source>
          <target state="translated">다음은 점 뒤에 올 수있는 것에 대한 문법입니다. xa, x. @ a, x. &amp;amp; a, x.'a '등 참고 : &lt;code&gt;typeArguments&lt;/code&gt; 는 &lt;code&gt;namePart&lt;/code&gt; 호출자가 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="e3383554d710d086a6eaaccc8bcae06fb7d68886" translate="yes" xml:space="preserve">
          <source>This is the implemented method for NotificationListener.</source>
          <target state="translated">NotificationListener에 구현 된 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="443ffb1b205dda6b43691a31bf4efab8981aa292" translate="yes" xml:space="preserve">
          <source>This is the implemented method for NotificationListener. It is called by an event emitter to dispatch JMX events to listeners. Here it handles internal JmxBuilder events.</source>
          <target state="translated">NotificationListener에 구현 된 메서드입니다. 이벤트 이미 터가 JMX 이벤트를 리스너에게 전달하기 위해 호출합니다. 여기에서 내부 JmxBuilder 이벤트를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8507fa3ee221e6d15aa495ec0771ccde8a6a13ad" translate="yes" xml:space="preserve">
          <source>This is the main method responsible for writing a tag and its attributes.</source>
          <target state="translated">이것은 태그와 그 속성을 작성하는 주요 방법입니다.</target>
        </trans-unit>
        <trans-unit id="8e6641635e8b64ec4febd6d638bc3e9143705eca" translate="yes" xml:space="preserve">
          <source>This is the main method responsible for writing a tag and its attributes. The arguments may be:</source>
          <target state="translated">이것은 태그와 그 속성을 작성하는 주요 방법입니다. 인수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc39540baf6302d792409499cb068b434a441c03" translate="yes" xml:space="preserve">
          <source>This is the management interface for JmxEventEmitter. This MBean is used internally by JmxBuilder to broadcast events to registered listeners of the underlying MBeanServer.</source>
          <target state="translated">JmxEventEmitter의 관리 인터페이스입니다. 이 MBean은 기본 MBeanServer의 등록 된 리스너에 이벤트를 브로드 캐스트하기 위해 JmxBuilder에 의해 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a5b95a30505f17692ef2b43986549d96c8c4624a" translate="yes" xml:space="preserve">
          <source>This is the original slurper included in case someone relies on its exact behavior. JSON slurper which parses text or reader content into a data structure of lists and maps.</source>
          <target state="translated">이것은 누군가가 정확한 행동에 의존하는 경우에 포함 된 원래의 슬러 퍼입니다. 텍스트 또는 리더 콘텐츠를 목록 및지도의 데이터 구조로 구문 분석하는 JSON slurper.</target>
        </trans-unit>
        <trans-unit id="99a8ced6206d14a027d70a5e32a450ce537c155b" translate="yes" xml:space="preserve">
          <source>This is the parser interface that backs the new JsonSlurper. It was derived from the Boon JSON parser.</source>
          <target state="translated">이것은 새로운 JsonSlurper를 지원하는 파서 인터페이스입니다. Boon JSON 파서에서 파생되었습니다.</target>
        </trans-unit>
        <trans-unit id="a3d06e9412c890cb691176655a805bf3748ea2d9" translate="yes" xml:space="preserve">
          <source>This is the server connector factory used for node JmxBuilder.connectorServer(). A call to this node returns an instance of JMXConnectorServer interface (rmi default).</source>
          <target state="translated">JmxBuilder.connectorServer () 노드에 사용되는 서버 커넥터 팩토리입니다. 이 노드를 호출하면 JMXConnectorServer 인터페이스 (rmi 기본값)의 인스턴스가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="230e13efb9db1565670b6fea571db7753bc5e0ed" translate="yes" xml:space="preserve">
          <source>This is the standard Groovy module factory. This factory will build a module using the &lt;a href=&quot;metainfextensionmodule&quot;&gt;MetaInfExtensionModule&lt;/a&gt; by default, unless a key named &quot;moduleFactory&quot; is found in the properties file. If this is the case, then a new factory is instantiated and used instead of this factory.</source>
          <target state="translated">이것은 표준 Groovy 모듈 팩토리입니다. 이 팩토리는 속성 파일에 &quot;moduleFactory&quot;라는 이름의 키가 없으면 기본적으로 &lt;a href=&quot;metainfextensionmodule&quot;&gt;MetaInfExtensionModule&lt;/a&gt; 을 사용하여 모듈을 빌드 합니다. 이 경우이 팩토리 대신 새 팩토리가 인스턴스화되고 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a7ec506a9828d694bfe5804799dc8c732a9b5a54" translate="yes" xml:space="preserve">
          <source>This is used to defer content creation until the point when it is streamed to the output destination. Oftentimes, content will be defined but not necessarily created (as is may be the case with a Closure definition.) In that case, the output is then 'deferred' to the point when it is serialized to the writer. This class may be used whenever an object should be responsible for creating its own textual representation, but creating the entire output as a single String would be inefficient (such as outputting a multi-gigabyte XML document.)</source>
          <target state="translated">이는 출력 대상으로 스트리밍 될 때까지 콘텐츠 생성을 연기하는 데 사용됩니다. 종종 콘텐츠가 정의되지만 반드시 생성되는 것은 아닙니다 (클로저 정의의 경우와 같음).이 경우 출력은 작성자에게 직렬화 될 때까지 '지연'됩니다. 이 클래스는 객체가 자체 텍스트 표현을 생성해야 할 때마다 사용할 수 있지만 전체 출력을 단일 문자열로 생성하는 것은 비효율적입니다 (예 : 다중 기가 바이트 XML 문서 출력).</target>
        </trans-unit>
        <trans-unit id="f8e14e7d5baf0cfd30f91810036e80282c090c67" translate="yes" xml:space="preserve">
          <source>This is useful to temporary change the building context to another builder without the need for a contrived setup. It will also take care of restoring the previous proxyBuilder when the execution finishes, even if an exception was thrown from inside the closure.</source>
          <target state="translated">이는 인위적인 설정없이 건물 컨텍스트를 다른 빌더로 임시 변경하는 데 유용합니다. 또한 클로저 내부에서 예외가 발생하더라도 실행이 완료되면 이전 proxyBuilder를 복원합니다.</target>
        </trans-unit>
        <trans-unit id="ad15a34847d2c1a8ad922f0d89041ba75723b49e" translate="yes" xml:space="preserve">
          <source>This is useful to temporary change the building context to another builder without the need for a contrived setup. It will also take care of restoring the previous proxyBuilder when the execution finishes, even if an exception was thrown from inside the closure. Additionally it will use the closure's result as the value for the node identified by 'name' and assign any attributes that might have been set.</source>
          <target state="translated">이는 인위적인 설정없이 건물 컨텍스트를 다른 빌더로 임시 변경하는 데 유용합니다. 또한 클로저 내부에서 예외가 발생하더라도 실행이 완료되면 이전 proxyBuilder를 복원합니다. 또한 'name'으로 식별되는 노드의 값으로 클로저의 결과를 사용하고 설정되었을 수있는 속성을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="c37a541753d2b221857f2d671ab7f729da865698" translate="yes" xml:space="preserve">
          <source>This is useful to temporary change the building context to another builder without the need for a contrived setup. It will also take care of restoring the previous proxyBuilder when the execution finishes, even if an exception was thrown from inside the closure. Additionally it will use the closure's result as the value for the node identified by 'name'.</source>
          <target state="translated">이는 인위적인 설정없이 건물 컨텍스트를 다른 빌더로 임시 변경하는 데 유용합니다. 또한 클로저 내부에서 예외가 발생하더라도 실행이 완료되면 이전 proxyBuilder를 복원합니다. 또한 'name'으로 식별되는 노드의 값으로 클로저의 결과를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="456d789e81e107b1750587cc65f969df3b091526" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using Apache Commons logging. Every method call on a unbound variable named</source>
          <target state="translated">이 로컬 변환은 Apache Commons 로깅을 사용하여 프로그램에 로깅 기능을 추가합니다. 이름이 바인딩되지 않은 변수에 대한 모든 메서드 호출</target>
        </trans-unit>
        <trans-unit id="ccdbe2f2abb77f14d2958b7203c74bc3c3238f26" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using Log4j logging. Every method call on a unbound variable named</source>
          <target state="translated">이 로컬 변환은 Log4j 로깅을 사용하여 프로그램에 로깅 기능을 추가합니다. 이름이 바인딩되지 않은 변수에 대한 모든 메서드 호출</target>
        </trans-unit>
        <trans-unit id="7ca89366d56f13b0ae77d15760011e4c8ce3c9d6" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using Log4j2 logging. Every method call on a unbound variable named</source>
          <target state="translated">이 로컬 변환은 Log4j2 로깅을 사용하여 프로그램에 로깅 기능을 추가합니다. 이름이 바인딩되지 않은 변수에 대한 모든 메서드 호출</target>
        </trans-unit>
        <trans-unit id="5c21e31e0e213d1b747f0881d81cf15af0983e63" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using LogBack logging. Every method call on a unbound variable named</source>
          <target state="translated">이 로컬 변환은 LogBack 로깅을 사용하여 프로그램에 로깅 기능을 추가합니다. 이름이 바인딩되지 않은 변수에 대한 모든 메서드 호출</target>
        </trans-unit>
        <trans-unit id="f0a3244e657380e150930ad3c42321efd1a93ab0" translate="yes" xml:space="preserve">
          <source>This local transform adds a logging ability to your program using java.util.logging. Every method call on a unbound variable named</source>
          <target state="translated">이 로컬 변환은 java.util.logging을 사용하여 프로그램에 로깅 기능을 추가합니다. 이름이 바인딩되지 않은 변수에 대한 모든 메서드 호출</target>
        </trans-unit>
        <trans-unit id="9f16b0ae746e9cea59cf9a1537bd1d3eab7d8506" translate="yes" xml:space="preserve">
          <source>This map is for object serialization mainly. The idea is the final conversion of the Value objects are delayed until the last possible moment, i.e., just before injected into a bean.</source>
          <target state="translated">이 맵은 주로 객체 직렬화를위한 것입니다. 아이디어는 Value 객체의 최종 변환이 가능한 마지막 순간, 즉 빈에 주입되기 직전에 지연된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="133261c522611d55bc1ac660860148968370dbb5" translate="yes" xml:space="preserve">
          <source>This maps only builds once you ask for a key for the first time. It is designed to not incur the overhead of creating a map unless needed.</source>
          <target state="translated">이 맵은 처음으로 키를 요청한 후에 만 ​​빌드됩니다. 필요한 경우가 아니면 맵을 만드는 오버 헤드가 발생하지 않도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="8a8f2d66e087d02e8f596d67c48d249055c88c63" translate="yes" xml:space="preserve">
          <source>This may be true even for values not contained in the range. Example: from = 1.5, to = 3, next() increments by 1 containsWithinBounds(2) == true contains(2) == false</source>
          <target state="translated">범위에 포함되지 않은 값의 경우에도 마찬가지입니다. 예 : from = 1.5, to = 3, next ()는 1 씩 증가 containsWithinBounds (2) == true contains (2) == false</target>
        </trans-unit>
        <trans-unit id="75f0bf4a66a79592bf20cb9599e2cee6c0cf02d5" translate="yes" xml:space="preserve">
          <source>This may not be available in future groovy.util.CliBuilder versions.</source>
          <target state="translated">향후 groovy.util.CliBuilder 버전에서는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0bf475abb2d654e508f4a3ea6b60068d3049398d" translate="yes" xml:space="preserve">
          <source>This may not be available in future groovy.util.CliBuilder versions. Use groovy.cli.commons.CliBuilder if you need this feature.</source>
          <target state="translated">향후 groovy.util.CliBuilder 버전에서는 사용할 수 없습니다. 이 기능이 필요한 경우 groovy.cli.commons.CliBuilder를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="29237a4ce5bb61ce2deb69d6d749c4af551bfff9" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;executeBatch()&lt;/code&gt; will be called automatically after the &lt;code&gt;withBatch&lt;/code&gt; closure has finished but may be called explicitly if desired as well for more fine-grained partitioning of the batch.</source>
          <target state="translated">즉, &lt;code&gt;executeBatch()&lt;/code&gt; 는 &lt;code&gt;withBatch&lt;/code&gt; 클로저가 완료된 후 자동으로 호출 되지만 원하는 경우 배치의 세분화 된 분할을 위해 명시 적으로 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8281417fefc279cbb9a25f17712e4ba86882d29f" translate="yes" xml:space="preserve">
          <source>This method adds a SyntaxException to the error collector.</source>
          <target state="translated">이 메소드는 오류 콜렉터에 SyntaxException을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0973d91b058fb6569284667e2f673bb040878f3c" translate="yes" xml:space="preserve">
          <source>This method adds a SyntaxException to the error collector. The exception should specify the line and column number of the error. This method should be reserved for real errors in the syntax of the SourceUnit. If your error is not in syntax, and is a semantic error, or more general error, then use addException or use the error collector directly by retrieving it with getErrorCollector().</source>
          <target state="translated">이 메소드는 오류 콜렉터에 SyntaxException을 추가합니다. 예외는 오류의 행 및 열 번호를 지정해야합니다. 이 메서드는 SourceUnit 구문의 실제 오류에 대해 예약되어야합니다. 오류가 구문에 있지 않고 의미 오류이거나보다 일반적인 오류 인 경우 addException을 사용하거나 getErrorCollector ()로 오류를 검색하여 직접 오류 수집기를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d41389a9f429a0e723f818e52d3c8405048d8434" translate="yes" xml:space="preserve">
          <source>This method adds an exception to the error collector.</source>
          <target state="translated">이 메서드는 오류 수집기에 예외를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ad248a00756ca0b2876764f3cadf2058210b535e" translate="yes" xml:space="preserve">
          <source>This method adds an exception to the error collector. The Exception most likely has no line number attached to it. For this reason you should use this method sparingly. Prefer using addError for syntax errors or add an error to the &lt;a href=&quot;errorcollector&quot;&gt;ErrorCollector&lt;/a&gt; directly by retrieving it with getErrorCollector().</source>
          <target state="translated">이 메서드는 오류 수집기에 예외를 추가합니다. 예외에는 대부분의 행 번호가 첨부되어 있지 않습니다. 이러한 이유로이 방법을 조금만 사용해야합니다. 구문 오류에 addError를 사용하는 것을 &lt;a href=&quot;errorcollector&quot;&gt;선호&lt;/a&gt; 하거나 getErrorCollector () 로 오류를 검색 하여 ErrorCollector에 직접 오류를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="26b9b9919b102efb75bc0c62d72758785b908443" translate="yes" xml:space="preserve">
          <source>This method builds a single ModelMBeanAttribute info from a given meta data map object.</source>
          <target state="translated">이 메소드는 주어진 메타 데이터 맵 객체에서 단일 ModelMBeanAttribute 정보를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="7ef8522c2c1425ca76a2dd9e7f7424d35413e383" translate="yes" xml:space="preserve">
          <source>This method calls the JsonLexer to parser the output of the builder, so this may not be an optimal method to call, and should be used mainly for debugging purpose for a human-readable output of the JSON content.</source>
          <target state="translated">이 메서드는 JsonLexer를 호출하여 빌더의 출력을 구문 분석하므로 호출하기에 최적의 메서드가 아닐 수 있으며 주로 사람이 읽을 수있는 JSON 콘텐츠 출력을위한 디버깅 목적으로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="573fa6ce3c9bb7134c818285958a90ae1c94d15a" translate="yes" xml:space="preserve">
          <source>This method can be used to ensure that no threaded created by a reference manager will be active.</source>
          <target state="translated">이 메서드는 참조 관리자가 만든 스레드가 활성화되지 않도록하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1267ce3e9e0625435626c7617e6d61f20f27e4e8" translate="yes" xml:space="preserve">
          <source>This method can be used to ensure that no threaded created by a reference manager will be active. This is useful if the Groovy runtime itself is loaded through a class loader which should be disposed off. Without calling this method and if a threaded reference manager is active the class loader cannot be unloaded! Per default no threaded manager will be used.</source>
          <target state="translated">이 메서드는 참조 관리자가 만든 스레드가 활성화되지 않도록하는 데 사용할 수 있습니다. 이는 Groovy 런타임 자체가 폐기되어야하는 클래스 로더를 통해로드되는 경우 유용합니다. 이 메서드를 호출하지 않고 스레드 참조 관리자가 활성화되어 있으면 클래스 로더를 언로드 할 수 없습니다! 기본적으로 스레드 관리자가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="736cd8a3422bc2feffa8beea26a3ea358d3a8479" translate="yes" xml:space="preserve">
          <source>This method can return &lt;code&gt;null&lt;/code&gt; if the &lt;code&gt;Class&lt;/code&gt; is no longer reachable through any strong or soft references. A non-null return value indicates that this &lt;code&gt;ClassInfo&lt;/code&gt; is valid.</source>
          <target state="translated">이 메서드는 &lt;code&gt;Class&lt;/code&gt; 가 더 이상 강력한 참조 또는 소프트 참조를 통해 도달 할 수없는 경우 &lt;code&gt;null&lt;/code&gt; 을 반환 할 수 있습니다 . null이 아닌 반환 값은이 &lt;code&gt;ClassInfo&lt;/code&gt; 가 유효 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1756cd8d9775e9730b98c4c1627c9b5e632ec24f" translate="yes" xml:space="preserve">
          <source>This method does not check the elements to verify they contain non-null reference values.</source>
          <target state="translated">이 메서드는 null이 아닌 참조 값이 포함되어 있는지 확인하기 위해 요소를 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="465f96fa4d41f78b2ce5fda3f4227272109aa863" translate="yes" xml:space="preserve">
          <source>This method doesn't do a full validation of the resulting QName. In particular, it doesn't check that the resulting namespace URI is a legal URI (per RFC 2396 and RFC 2732), nor that the resulting local part is a legal NCName per the XML Namespaces specification.</source>
          <target state="translated">이 메서드는 결과 QName에 대한 전체 유효성 검사를 수행하지 않습니다. 특히 결과 네임 스페이스 URI가 유효한 URI (RFC 2396 및 RFC 2732에 따라)인지 또는 결과 로컬 부분이 XML 네임 스페이스 사양에 따라 유효한 NCName인지 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="52e513008c99e7d305fccff13849c1a1c80774aa" translate="yes" xml:space="preserve">
          <source>This method exists to be binary compatible with 1.7 - 1.8.6 compiled code.</source>
          <target state="translated">이 메소드는 1.7-1.8.6 컴파일 된 코드와 바이너리 호환이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c641e7c52a070377f45e131e44d063d090fa6d00" translate="yes" xml:space="preserve">
          <source>This method extracts ModelMBeanConstructorInfo from provided meta map.</source>
          <target state="translated">이 메소드는 제공된 메타 맵에서 ModelMBeanConstructorInfo를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="34c2983f225d2e36614f43dbb936a7baf6ddf732" translate="yes" xml:space="preserve">
          <source>This method extracts ModelMBeanConstructorInfo from provided meta map. It also iterates over any parameters and builds the necessary MBeanParameterInfo array.</source>
          <target state="translated">이 메소드는 제공된 메타 맵에서 ModelMBeanConstructorInfo를 추출합니다. 또한 모든 매개 변수를 반복하고 필요한 MBeanParameterInfo 배열을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="150789d2ce17bb14a2771276abea7c787a906d8f" translate="yes" xml:space="preserve">
          <source>This method extracts an array of MBeanConstructorInfo from a list of meta maps.</source>
          <target state="translated">이 메소드는 메타 맵 목록에서 MBeanConstructorInfo 배열을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="60a3e8f2070dce89ae81b802d499b2bd30f90563" translate="yes" xml:space="preserve">
          <source>This method extracts an array of MBeanOperationInfo from a list of meta maps.</source>
          <target state="translated">이 메소드는 메타 맵 목록에서 MBeanOperationInfo 배열을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="263fa2d4242a10d1bba7914ee9c3b6eaba971c49" translate="yes" xml:space="preserve">
          <source>This method is &quot;safe&quot; in that it will always return a value and never throw an exception</source>
          <target state="translated">이 메서드는 항상 값을 반환하고 예외를 throw하지 않는다는 점에서 &quot;안전&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="6f930ab10785ce3649f57bd225433f23ebd52975" translate="yes" xml:space="preserve">
          <source>This method is a default implementation for the invoke method given in InvocationHandler.</source>
          <target state="translated">이 메서드는 InvocationHandler에 지정된 호출 메서드에 대한 기본 구현입니다.</target>
        </trans-unit>
        <trans-unit id="181a7ec346ddcc5f94d1cf5c7bd4f8177dda29ec" translate="yes" xml:space="preserve">
          <source>This method is a default implementation for the invoke method given in InvocationHandler. Any call to a method with a declaring class that is not Object, excluding toString() and default methods is redirected to invokeCustom.</source>
          <target state="translated">이 메서드는 InvocationHandler에 지정된 호출 메서드에 대한 기본 구현입니다. toString () 및 기본 메서드를 제외하고 Object가 아닌 선언 클래스가있는 메서드에 대한 모든 호출은 invokeCustom으로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="0243bed2cf01409831d3e3bb5e0becbccc0e7f22" translate="yes" xml:space="preserve">
          <source>This method is called by he handle to realize the bean constructor with property map.</source>
          <target state="translated">이 메소드는 속성 맵으로 빈 생성자를 실현하기 위해 핸들에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="32f82b3d67ea451eb2c3571e5b0255127a98cff1" translate="yes" xml:space="preserve">
          <source>This method is called by the ++ operator for enums.</source>
          <target state="translated">이 메서드는 열거 형에 대해 ++ 연산자에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1c4289e3c70251c89708316752c7fc742b1a3b57" translate="yes" xml:space="preserve">
          <source>This method is called by the ++ operator for enums. It will invoke Groovy's default next behaviour for enums do not have their own next method.</source>
          <target state="translated">이 메서드는 열거 형에 대해 ++ 연산자에 의해 호출됩니다. enum에 대한 Groovy의 기본 next 동작은 자체 next 메서드가 없습니다.</target>
        </trans-unit>
        <trans-unit id="457141bbf0ee6f1da111f0f8db21015e1177879a" translate="yes" xml:space="preserve">
          <source>This method is called by the -- operator for enums.</source>
          <target state="translated">이 메서드는 열거 형에 대한-연산자에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="80cf9ab5395bfa1c37797650a89d31d82b67f5fb" translate="yes" xml:space="preserve">
          <source>This method is called by the -- operator for enums. It will invoke Groovy's default previous behaviour for enums that do not have their own previous method.</source>
          <target state="translated">이 메서드는 열거 형에 대한-연산자에 의해 호출됩니다. 이전 메서드가없는 열거 형에 대해 Groovy의 기본 이전 동작을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="1d7f17602988167c7174cc4303d3eb837ccaa4f4" translate="yes" xml:space="preserve">
          <source>This method is called by the handle to realize the bean constructor with property map.</source>
          <target state="translated">이 메소드는 속성 맵으로 빈 생성자를 실현하기 위해 핸들에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3250ef3629af744acf4f1c9198cc633e9a922e7c" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker before throwing an &quot;ambiguous method&quot; error, giving the chance to the extension to select the method properly.</source>
          <target state="translated">이 메서드는 &quot;모호한 메서드&quot;오류가 발생하기 전에 형식 검사기에 의해 호출되어 확장 프로그램이 메서드를 올바르게 선택할 수있는 기회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bf23fd2465394a74d715d408a8f25c8bce28f2b6" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker before throwing an &quot;ambiguous method&quot; error, giving the chance to the extension to select the method properly. This means that when this method is called, the &quot;nodes&quot; parameter contains at least two methods. If the returned list still contains at least two methods, then the type checker will throw an ambiguous method call error. If the returned method contains 1 element, then the type checker will not throw any error. It is invalid to return an empty list.</source>
          <target state="translated">이 메서드는 &quot;모호한 메서드&quot;오류가 발생하기 전에 형식 검사기에 의해 호출되어 확장 프로그램이 메서드를 올바르게 선택할 수있는 기회를 제공합니다. 이는이 메서드가 호출 될 때 &quot;nodes&quot;매개 변수에 두 개 이상의 메서드가 포함되어 있음을 의미합니다. 반환 된 목록에 여전히 두 개 이상의 메서드가 포함되어 있으면 형식 검사기가 모호한 메서드 호출 오류를 발생시킵니다. 반환 된 메서드에 1 개의 요소가 포함 된 경우 유형 검사기는 오류를 발생시키지 않습니다. 빈 목록을 반환하는 것은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5bd058a5f1dad9fd10cd41da813b584b34292dcf" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a method call cannot be resolved.</source>
          <target state="translated">이 메서드는 메서드 호출을 확인할 수 없을 때 형식 검사기에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d1635a0a9cf4ddc4f991b78c462cd28f64e95f41" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a method call cannot be resolved. Extensions may override this method to handle missing methods and prevent the type checker from throwing an error.</source>
          <target state="translated">이 메서드는 메서드 호출을 확인할 수 없을 때 형식 검사기에 의해 호출됩니다. 확장은이 메서드를 재정 의하여 누락 된 메서드를 처리하고 유형 검사기가 오류를 발생시키지 않도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d562c165b33158604a8d7b6404c28720d2074f3" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a property expression cannot be resolved (for example, when a property doesn't exist).</source>
          <target state="translated">이 메서드는 속성 식을 확인할 수없는 경우 (예 : 속성이없는 경우) 형식 검사기에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="132aa2a69d68d1893ec79f63a47c8d6c72a91536" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a property expression cannot be resolved (for example, when a property doesn't exist). It gives the extension a chance to resolve it.</source>
          <target state="translated">이 메서드는 속성 식을 확인할 수없는 경우 (예 : 속성이없는 경우) 형식 검사기에 의해 호출됩니다. 확장 프로그램이 문제를 해결할 수있는 기회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="af1e5a5ee4210f5472ccdfef7a053239430f1f37" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a variable expression cannot be resolved.</source>
          <target state="translated">이 메서드는 변수 식을 확인할 수 없을 때 형식 검사기에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="76c7e2b17c02ed11975ad5a1246ebf8e0384df5b" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when a variable expression cannot be resolved. It gives the extension a chance to resolve it for the type checker.</source>
          <target state="translated">이 메서드는 변수 식을 확인할 수 없을 때 형식 검사기에 의해 호출됩니다. 확장 프로그램에 유형 검사기에 대해 해결할 수있는 기회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="24c509ff50700509e7072e5bf1d5cfe4ccd9c387" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when an assignment is not allowed by the type checker.</source>
          <target state="translated">이 메소드는 유형 검사기가 할당을 허용하지 않을 때 유형 검사기에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="788e0b6b33909d27195a8757233c0e6432f5e5eb" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when an assignment is not allowed by the type checker. Extensions may override this method to allow such assignments where the type checker normally disallows them.</source>
          <target state="translated">이 메소드는 유형 검사기가 할당을 허용하지 않을 때 유형 검사기에 의해 호출됩니다. 확장 기능은 유형 검사기가 일반적으로 허용하지 않는 할당을 허용하도록이 메서드를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dae2966d00451172c913ae2ad39d7fd262e4b659" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when an attribute expression cannot be resolved (for example, when an attribute doesn't exist).</source>
          <target state="translated">이 메서드는 특성 식을 확인할 수없는 경우 (예 : 특성이없는 경우) 유형 검사기에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="f407dcbe206c19d0fc48753b7163e649e8b6df6d" translate="yes" xml:space="preserve">
          <source>This method is called by the type checker when an attribute expression cannot be resolved (for example, when an attribute doesn't exist). It gives the extension a chance to resolve it.</source>
          <target state="translated">이 메서드는 특성 식을 확인할 수없는 경우 (예 : 특성이없는 경우) 유형 검사기에 의해 호출됩니다. 확장 프로그램이 문제를 해결할 수있는 기회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f24dfabfb34102b6f318752ab09222b7e3d270a2" translate="yes" xml:space="preserve">
          <source>This method is called for all Methods not defined on Object.</source>
          <target state="translated">이 메서드는 Object에 정의되지 않은 모든 메서드에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c123aa6bd463d76f74528853afb07e35dfbd4af8" translate="yes" xml:space="preserve">
          <source>This method is called for all Methods not defined on Object. The delegate should be called here.</source>
          <target state="translated">이 메서드는 Object에 정의되지 않은 모든 메서드에 대해 호출됩니다. 여기에서 대리인을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="e263d0484bccb2058d38f8bf9eacd404f003eccc" translate="yes" xml:space="preserve">
          <source>This method is called once the template engine is initialized, providing the resolver with the template engine configuration and its template class loader.</source>
          <target state="translated">이 메서드는 템플릿 엔진이 초기화되면 호출되어 리졸버에 템플릿 엔진 구성 및 해당 템플릿 클래스 로더를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0d82b61e044bfa56fbd2265af61cf2acecdd51e0" translate="yes" xml:space="preserve">
          <source>This method is called when an exception occurs while invoking this method.</source>
          <target state="translated">이 메서드를 호출하는 동안 예외가 발생하면이 메서드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3383d8f9c80df52829fdca412aee2ffee5f93888" translate="yes" xml:space="preserve">
          <source>This method is for convenience.</source>
          <target state="translated">이 방법은 편의를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="9242bd1cd2be2a765050fb4ef347893057fa4da1" translate="yes" xml:space="preserve">
          <source>This method is for convenience. It allows to get around the need for defining dump ctors in subclasses. See unit tests for details.</source>
          <target state="translated">이 방법은 편의를위한 것입니다. 서브 클래스에서 덤프 액터를 정의 할 필요성을 피할 수 있습니다. 자세한 내용은 단위 테스트를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="c7d7725943eccf3c92e66a0d48dd502528f6b703" translate="yes" xml:space="preserve">
          <source>This method is meant to be overridden by custom GroovyDoc implementations, using custom class templates.</source>
          <target state="translated">이 메서드는 사용자 지정 클래스 템플릿을 사용하여 사용자 지정 GroovyDoc 구현에 의해 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="8e09772b977dedc07d07d96cc2d72542f64ca1c5" translate="yes" xml:space="preserve">
          <source>This method is meant to be overridden by custom GroovyDoc implementations, using custom doc templates.</source>
          <target state="translated">이 메서드는 사용자 지정 문서 템플릿을 사용하여 사용자 지정 GroovyDoc 구현으로 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e3f94c56bab43f0b3780ed88b92cbab7aa06914d" translate="yes" xml:space="preserve">
          <source>This method is meant to be overridden by custom GroovyDoc implementations, using custom package templates.</source>
          <target state="translated">이 메서드는 사용자 지정 패키지 템플릿을 사용하여 사용자 지정 GroovyDoc 구현으로 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="be3f5aaf4fe5b29a387b1c08f22380405a4b43e6" translate="yes" xml:space="preserve">
          <source>This method is not in use anymore.</source>
          <target state="translated">이 방법은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d479a6f7032861e095021709f96d24a323c7ce9f" translate="yes" xml:space="preserve">
          <source>This method is not in use anymore. Use &lt;a href=&quot;groovyc#makeCompileUnit(groovy.lang.GroovyClassLoader)&quot;&gt;Groovyc.makeCompileUnit&lt;/a&gt; instead.</source>
          <target state="translated">이 방법은 더 이상 사용되지 않습니다. 대신 &lt;a href=&quot;groovyc#makeCompileUnit(groovy.lang.GroovyClassLoader)&quot;&gt;Groovyc.makeCompileUnit&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8df7d11b3e43da5003d64921acb230c01052ce02" translate="yes" xml:space="preserve">
          <source>This method is responsible for instantiating a node and configure its properties.</source>
          <target state="translated">이 메서드는 노드를 인스턴스화하고 해당 속성을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="2553db016825bd58a6c41d37b4ac7d9fdb343726" translate="yes" xml:space="preserve">
          <source>This method is responsible for performing type inference on closure argument types whenever code like this is found: &lt;code&gt;foo.collect { it.toUpperCase() }&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;foo.collect { it.toUpperCase() }&lt;/code&gt; 와 같은 코드가 발견 될 때마다 클로저 인수 유형에 대한 유형 추론을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="96aa2c86a54f44a86c05cf0e9b642e0ff2c34049" translate="yes" xml:space="preserve">
          <source>This method is responsible for performing type inference on closure argument types whenever code like this is found: &lt;code&gt;foo.collect { it.toUpperCase() }&lt;/code&gt;. In this case, the type checker tries to find if the &lt;code&gt;collect&lt;/code&gt; method has its &lt;a href=&quot;../../../../../groovy/lang/closure&quot;&gt;Closure&lt;/a&gt; argument annotated with &lt;a href=&quot;../../../../../groovy/transform/stc/closureparams&quot;&gt;ClosureParams&lt;/a&gt;. If yes, then additional type inference can be performed and the type of &lt;code&gt;it&lt;/code&gt; may be inferred.</source>
          <target state="translated">이 메소드는 &lt;code&gt;foo.collect { it.toUpperCase() }&lt;/code&gt; 와 같은 코드가 발견 될 때마다 클로저 인수 유형에 대한 유형 추론을 수행합니다 . 이 경우 유형 검사기는 &lt;code&gt;collect&lt;/code&gt; 메서드 에 &lt;a href=&quot;../../../../../groovy/transform/stc/closureparams&quot;&gt;ClosureParams&lt;/a&gt; 주석이 달린 &lt;a href=&quot;../../../../../groovy/lang/closure&quot;&gt;Closure&lt;/a&gt; 인수 가 있는지 확인합니다 . 그렇다면, 추가적인 타입 추론을 수행 할 수의 종류 &lt;code&gt;it&lt;/code&gt; 추론 할 수있다.</target>
        </trans-unit>
        <trans-unit id="39e70e7519f9c69520febf8336038092afe788f5" translate="yes" xml:space="preserve">
          <source>This method is similar to &lt;a href=&quot;#propX(org.codehaus.groovy.ast.expr.Expression,%20org.codehaus.groovy.ast.expr.Expression)&quot;&gt;propX(Expression, Expression)&lt;/a&gt; but will make sure that if the property being accessed is defined inside the classnode provided as a parameter, then a getter call is generated instead of a field access.</source>
          <target state="translated">이 메서드는 &lt;a href=&quot;#propX(org.codehaus.groovy.ast.expr.Expression,%20org.codehaus.groovy.ast.expr.Expression)&quot;&gt;propX (Expression, Expression)&lt;/a&gt; 과 유사 하지만 액세스되는 속성이 매개 변수로 제공된 클래스 노드 내에 정의되어 있으면 필드 액세스 대신 getter 호출이 생성되도록합니다.</target>
        </trans-unit>
        <trans-unit id="5af1f84f364b43bda693a94d6efdcb175387d500" translate="yes" xml:space="preserve">
          <source>This method is used to pull all the new methods out of the local thread context with a particular name.</source>
          <target state="translated">이 메서드는 특정 이름을 가진 로컬 스레드 컨텍스트에서 모든 새 메서드를 가져 오는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="debc8862f9ee94379022acc734d3d04be7a4a835" translate="yes" xml:space="preserve">
          <source>This method looks up a simple (weak) hash map for an existing template object that matches the source URL. If there is no cache entry, a new one is created by the underlying template engine. This new instance is put to the cache for consecutive calls.</source>
          <target state="translated">이 메소드는 소스 URL과 일치하는 기존 템플릿 객체에 대한 단순 (약한) 해시 맵을 조회합니다. 캐시 항목이 없으면 기본 템플릿 엔진에서 새 항목을 만듭니다. 이 새 인스턴스는 연속 호출을 위해 캐시에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="50f405bf763411bbbae4b569b75520c8c6ab7da2" translate="yes" xml:space="preserve">
          <source>This method looks up a simple (weak) hash map for an existing template object that matches the source file. If the source file didn't change in length and its last modified stamp hasn't changed compared to a precompiled template object, this template is used. Otherwise, there is no or an invalid template object cache entry, a new one is created by the underlying template engine. This new instance is put to the cache for consecutive calls.</source>
          <target state="translated">이 메소드는 소스 파일과 일치하는 기존 템플릿 객체에 대한 단순 (약한) 해시 맵을 조회합니다. 소스 파일의 길이가 변경되지 않았고 마지막으로 수정 된 스탬프가 미리 컴파일 된 템플릿 개체와 비교하여 변경되지 않은 경우이 템플릿이 사용됩니다. 그렇지 않으면 템플릿 개체 캐시 항목이 없거나 잘못된 경우 기본 템플릿 엔진에서 새 항목을 만듭니다. 이 새 인스턴스는 연속 호출을 위해 캐시에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="70b580668132556ed8e21d6f55d11fdd505e1db6" translate="yes" xml:space="preserve">
          <source>This method may be used by a caller in class C to check whether to enable access to a member of declaring class D successfully if Java8#checkCanSetAccessible(java.lang.reflect.AccessibleObject, java.lang.Class) returns true and any of the following hold:</source>
          <target state="translated">이 메소드는 C 클래스의 호출자가 Java8 # checkCanSetAccessible (java.lang.reflect.AccessibleObject, java.lang.Class)가 true를 반환하고 다음 보류 :</target>
        </trans-unit>
        <trans-unit id="403c2e4b9a79e63110b8121635756398ae996fda" translate="yes" xml:space="preserve">
          <source>This method returns the left hand side of the declaration cast to the TupleExpression type.</source>
          <target state="translated">이 메서드는 TupleExpression 형식으로 캐스팅 된 선언의 왼쪽을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3eeba1201f99a5e2e68118e5c0e2cd8aa46418b3" translate="yes" xml:space="preserve">
          <source>This method returns the left hand side of the declaration cast to the TupleExpression type. This is an unsafe method to call. In a single assignment statement, the left hand side will be a VariableExpression and a ClassCastException will occur. If you invoke this method then be sure to invoke isMultipleAssignmentDeclaration() first to check that it is safe to do so. If that method returns true then this method is safe to call.</source>
          <target state="translated">이 메서드는 TupleExpression 형식으로 캐스팅 된 선언의 왼쪽을 반환합니다. 호출하기에 안전하지 않은 메서드입니다. 단일 할당 문에서 왼쪽은 VariableExpression이되고 ClassCastException이 발생합니다. 이 메서드를 호출하는 경우 먼저 isMultipleAssignmentDeclaration ()을 호출하여 안전한지 확인하십시오. 해당 메서드가 true를 반환하면이 메서드를 호출해도 안전합니다.</target>
        </trans-unit>
        <trans-unit id="781dddff54ea389bba98f4620fb6ffb4990bacbc" translate="yes" xml:space="preserve">
          <source>This method returns the left hand side of the declaration cast to the VariableExpression type.</source>
          <target state="translated">이 메서드는 VariableExpression 형식으로 캐스팅 된 선언의 왼쪽을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6d0cf4b5f8e84212c7ef85c55fbf13a8f51d14d1" translate="yes" xml:space="preserve">
          <source>This method returns the left hand side of the declaration cast to the VariableExpression type. This is an unsafe method to call. In a multiple assignment statement, the left hand side will be a TupleExpression and a ClassCastException will occur. If you invoke this method then be sure to invoke isMultipleAssignmentDeclaration() first to check that it is safe to do so. If that method returns true then this method is safe to call.</source>
          <target state="translated">이 메서드는 VariableExpression 형식으로 캐스팅 된 선언의 왼쪽을 반환합니다. 호출하기에 안전하지 않은 메서드입니다. 다중 할당 문에서 왼쪽은 TupleExpression이되고 ClassCastException이 발생합니다. 이 메서드를 호출하는 경우 먼저 isMultipleAssignmentDeclaration ()을 호출하여 안전한지 확인하십시오. 해당 메서드가 true를 반환하면이 메서드를 호출해도 안전합니다.</target>
        </trans-unit>
        <trans-unit id="557432b29293b21b623d72897910f098d1d9b99f" translate="yes" xml:space="preserve">
          <source>This method returns the list of methods named against the supplied parameter that are defined on the specified receiver, but it will also add &quot;non existing&quot; methods that will be generated afterwards by the compiler, for example if a method is using default values and that the specified class node isn't compiled yet.</source>
          <target state="translated">이 메소드는 지정된 수신자에 정의 된 제공된 매개 변수에 대해 명명 된 메소드 목록을 리턴하지만 나중에 컴파일러에 의해 생성 될 &quot;존재하지 않는&quot;메소드도 추가합니다 (예 : 메소드가 기본값을 사용하고있는 경우). 지정된 클래스 노드가 아직 컴파일되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="7c021d108112247d1976e0f0916701f3b8b31579" translate="yes" xml:space="preserve">
          <source>This method returns the method name as String if it is no dynamic calculated method name, but a constant.</source>
          <target state="translated">이 메서드는 동적 계산 메서드 이름이 아니라 상수 인 경우 메서드 이름을 String으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ea5673ca5049872b33d116e64a53321be9dfe401" translate="yes" xml:space="preserve">
          <source>This method satisfies the general contract of the &lt;code&gt;Object.equals&lt;/code&gt; method.</source>
          <target state="translated">이 메서드는 &lt;code&gt;Object.equals&lt;/code&gt; 메서드 의 일반 계약을 충족합니다 .</target>
        </trans-unit>
        <trans-unit id="e6de05f9ed26a209b6ba119f444e9aeb1971f83b" translate="yes" xml:space="preserve">
          <source>This method sets the leftExpression for this BinaryExpression.</source>
          <target state="translated">이 메서드는이 BinaryExpression에 대해 leftExpression을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9538691d379a9f29ae41a5c0329eeba449cfee5a" translate="yes" xml:space="preserve">
          <source>This method sets the leftExpression for this BinaryExpression. The parameter must be either a VariableExpression or a TupleExpression with one or more elements.</source>
          <target state="translated">이 메서드는이 BinaryExpression에 대해 leftExpression을 설정합니다. 매개 변수는 하나 이상의 요소가있는 VariableExpression 또는 TupleExpression이어야합니다.</target>
        </trans-unit>
        <trans-unit id="cabac7eca3eafa23e66e3fc5b9e599e6f515924d" translate="yes" xml:space="preserve">
          <source>This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; array. See the class Javadoc for more details.</source>
          <target state="translated">이 메서드는 &lt;code&gt;params&lt;/code&gt; 배열 에 이러한 매개 변수를 제공하여 명명 및 명명 된 서수 매개 변수를 지원합니다 . 자세한 내용은 Javadoc 클래스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5ac687259610806fa3ccf67d52b8a0cdcf309f5f" translate="yes" xml:space="preserve">
          <source>This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; list. Here is an example:</source>
          <target state="translated">이 메소드는 &lt;code&gt;params&lt;/code&gt; 목록 에 이러한 매개 변수를 제공하여 명명되고 명명 된 서수 매개 변수를 지원 합니다. 다음은 그 예입니다.</target>
        </trans-unit>
        <trans-unit id="08f6b6d6cce9316b59fc041647b88bdcb3661eb8" translate="yes" xml:space="preserve">
          <source>This method supports named and named ordinal parameters by supplying such parameters in the &lt;code&gt;params&lt;/code&gt; list. See the class Javadoc for more details.</source>
          <target state="translated">이 메소드는 &lt;code&gt;params&lt;/code&gt; 목록 에 이러한 매개 변수를 제공하여 명명되고 명명 된 서수 매개 변수를 지원 합니다. 자세한 내용은 Javadoc 클래스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="35c38527fe587a9d1b961b352a1036dd0d02b5a0" translate="yes" xml:space="preserve">
          <source>This method supports named and named ordinal parameters. See the class Javadoc for more details.</source>
          <target state="translated">이 메서드는 명명 및 명명 된 서수 매개 변수를 지원합니다. 자세한 내용은 Javadoc 클래스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a1cb160878d23efb8494710e1845624e733ba117" translate="yes" xml:space="preserve">
          <source>This method takes source code, compiles it, then reverses it back to source.</source>
          <target state="translated">이 메서드는 소스 코드를 가져 와서 컴파일 한 다음 소스로 되돌립니다.</target>
        </trans-unit>
        <trans-unit id="1802525bd308357b0932ba02bb3c41457d24c77a" translate="yes" xml:space="preserve">
          <source>This method tells you if this declaration is a multiple assignment declaration, which has the form &quot;def (x, y) = ...&quot; in Groovy.</source>
          <target state="translated">이 메서드는이 선언이 Groovy에서 &quot;def (x, y) = ...&quot;형식을 갖는 다중 할당 선언인지 여부를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="647f4610cd39ef87d4f0b710da06531ff2a5d253" translate="yes" xml:space="preserve">
          <source>This method tells you if this declaration is a multiple assignment declaration, which has the form &quot;def (x, y) = ...&quot; in Groovy. If this method returns true, then the left hand side is an ArgumentListExpression. Do not call &quot;getVariableExpression()&quot; on this object if this method returns true, instead use &quot;getLeftExpression()&quot;.</source>
          <target state="translated">이 메서드는이 선언이 Groovy에서 &quot;def (x, y) = ...&quot;형식을 갖는 다중 할당 선언인지 여부를 알려줍니다. 이 메서드가 true를 반환하면 왼쪽은 ArgumentListExpression입니다. 이 메서드가 true를 반환하면이 객체에서 &quot;getVariableExpression ()&quot;을 호출하지 말고 대신 &quot;getLeftExpression ()&quot;을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="03ceb4930438c953107282fc0e25906885994308" translate="yes" xml:space="preserve">
          <source>This method tokenizes a string by space characters, but ignores spaces in quoted parts,that are parts in '' or &quot;&quot;.</source>
          <target state="translated">이 메서드는 공백 문자로 문자열을 토큰 화하지만 ''또는 &quot;&quot;의 일부인 따옴표 부분의 공백은 무시합니다.</target>
        </trans-unit>
        <trans-unit id="25594fed498b016c91d8453a3caab76c908e2263" translate="yes" xml:space="preserve">
          <source>This method tokenizes a string by space characters, but ignores spaces in quoted parts,that are parts in '' or &quot;&quot;. The method does allows the usage of &quot;&quot; in '' and '' in &quot;&quot;. The space character between tokens is not returned.</source>
          <target state="translated">이 메서드는 공백 문자로 문자열을 토큰 화하지만 ''또는 &quot;&quot;의 일부인 따옴표 부분의 공백은 무시합니다. 이 메서드는 ''에서 &quot;&quot;및 &quot;&quot;에서 ''의 사용을 허용합니다. 토큰 사이의 공백 문자는 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2a84c08a545e26a0cfa5751f177172834124990" translate="yes" xml:space="preserve">
          <source>This methods creates a list of all methods with this name of the current class and of all super classes</source>
          <target state="translated">이 메서드는 현재 클래스와 모든 슈퍼 클래스의 이름을 가진 모든 메서드 목록을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d2b2f984e596021625b1464da65d3078af780eae" translate="yes" xml:space="preserve">
          <source>This methods returns a list of all methods of the given name defined in the current class</source>
          <target state="translated">이 메서드는 현재 클래스에 정의 된 이름의 모든 메서드 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="45509752471fda490b1c2f1641894ee63c1ba53e" translate="yes" xml:space="preserve">
          <source>This methods returns the same array as used in the constructor. Changing the values will result in changes of the GString. It is not recommended to do so.</source>
          <target state="translated">이 메서드는 생성자에서 사용 된 것과 동일한 배열을 반환합니다. 값을 변경하면 GString이 변경됩니다. 그렇게하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b66768732e0971c70f8284792c2afe59afe722c7" translate="yes" xml:space="preserve">
          <source>This modifies the original instance and returns it, it does not clone</source>
          <target state="translated">원본 인스턴스를 수정하고 반환하지만 복제하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d03be5ef16854ca34754ab795102a0c1c0f386c3" translate="yes" xml:space="preserve">
          <source>This object is a GUI for looking at the AST that Groovy generates. Usage: java groovy.console.ui.AstBrowser [filename] where [filename] is an existing Groovy script.</source>
          <target state="translated">이 개체는 Groovy가 생성하는 AST를보기위한 GUI입니다. 사용법 : java groovy.console.ui.AstBrowser [filename] 여기서 [filename]은 기존 Groovy 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="3e97fa1c7af0c729d57b97541a44507ce0cc0d67" translate="yes" xml:space="preserve">
          <source>This object is a GUI for looking at the AST that Groovy generates. Usage: java groovy.inspect.swingui.AstBrowser [filename] where [filename] is an existing Groovy script.</source>
          <target state="translated">이 개체는 Groovy가 생성하는 AST를보기위한 GUI입니다. 사용법 : java groovy.inspect.swingui.AstBrowser [filename] 여기서 [filename]은 기존 Groovy 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="e2ffc04181a72b4f0f1c3e416c94b05a7ff37bfe" translate="yes" xml:space="preserve">
          <source>This object represents a Groovy script</source>
          <target state="translated">이 개체는 Groovy 스크립트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a3a6a41f25ea556ddea2ab91cb5c7b51b70dd65b" translate="yes" xml:space="preserve">
          <source>This only leaves the 'out' argument unbound. The only method on the &lt;a href=&quot;../lang/writable&quot;&gt;writable&lt;/a&gt; interface is &lt;a href=&quot;../lang/writable#writeTo&quot;&gt;writeTo(Writer out)&lt;/a&gt; so groovy rules about casting a closure to a one-method-interface apply and the above works. I.e. we return the now one argument closure as the Writable which can be serialized to System.out, a file, etc according to the Writable interface contract.</source>
          <target state="translated">이것은 'out'인수를 바인딩 해제 할뿐입니다. &lt;a href=&quot;../lang/writable&quot;&gt;쓰기 가능한&lt;/a&gt; 인터페이스 의 유일한 방법 은 &lt;a href=&quot;../lang/writable#writeTo&quot;&gt;writeTo (Writer out)&lt;/a&gt; 이므로 하나의 메서드 인터페이스로 클로저를 캐스팅하는 것에 대한 그루비 한 규칙이 적용되고 위의 작업이 적용됩니다. 즉, Writable 인터페이스 계약에 따라 System.out, 파일 등에 직렬화 될 수있는 Writable로 이제 하나의 인수 클로저를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3860a813e268f2ea6fc72207bdceca72d569484a" translate="yes" xml:space="preserve">
          <source>This pattern can therefore be used to avoid explicit casts everywhere you need to call a method that you know is defined in the class that will implement the trait but normally don't have access to, which is often the case where a trait needs to be applied on a class provided by a third-party library.</source>
          <target state="translated">따라서이 패턴은 트레이 트를 구현할 클래스에 정의되어 있지만 일반적으로 액세스 할 수없는 메서드를 호출해야하는 모든 곳에서 명시 적 캐스트를 피하는 데 사용할 수 있습니다. 타사 라이브러리에서 제공하는 클래스에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ace59be916b50b31486861d73ed18eaca30ec5fa" translate="yes" xml:space="preserve">
          <source>This property allows customizing the program name displayed in the synopsis when &lt;code&gt;cli.usage()&lt;/code&gt; is called.</source>
          <target state="translated">이 속성을 사용하면 &lt;code&gt;cli.usage()&lt;/code&gt; 가 호출 될 때 시놉시스에 표시되는 프로그램 이름을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51e8331273416e517eaeaf7fa7a23b0549036735" translate="yes" xml:space="preserve">
          <source>This property allows customizing the program name displayed in the synopsis when &lt;code&gt;cli.usage()&lt;/code&gt; is called. Ignored if the &lt;a href=&quot;#usage&quot;&gt;usage&lt;/a&gt; property is set.</source>
          <target state="translated">이 속성을 사용하면 &lt;code&gt;cli.usage()&lt;/code&gt; 가 호출 될 때 시놉시스에 표시되는 프로그램 이름을 사용자 정의 할 수 있습니다 . &lt;a href=&quot;#usage&quot;&gt;사용&lt;/a&gt; 속성이 설정된 경우 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e7c100040c65811e98b4b5e3b269e9270590f58" translate="yes" xml:space="preserve">
          <source>This property controls whether to include the destination classes directory in the classpath given to the compiler.</source>
          <target state="translated">이 속성은 컴파일러에 제공된 클래스 경로에 대상 클래스 디렉터리를 포함할지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="7d2d8961f859455e3fb30c095ca4f0b27f60c5a9" translate="yes" xml:space="preserve">
          <source>This property controls whether to include the destination classes directory in the classpath given to the compiler. The default value is &quot;true&quot;.</source>
          <target state="translated">이 속성은 컴파일러에 제공된 클래스 경로에 대상 클래스 디렉터리를 포함할지 여부를 제어합니다. 기본값은 &quot;true&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="f9f8e158e1fb916ac4a14cb9fc36f54eb916b032" translate="yes" xml:space="preserve">
          <source>This queue is backed by a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html&quot;&gt;ConcurrentLinkedQueue&lt;/a&gt; and is thread safe. The iterator will only return non-null values (reachable) and is based on the &quot;weakly consistent&quot; iterator of the underlying &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html&quot;&gt;ConcurrentLinkedQueue&lt;/a&gt;.</source>
          <target state="translated">이 큐는 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html&quot;&gt;ConcurrentLinkedQueue에&lt;/a&gt; 의해 지원되며 스레드로부터 안전합니다. 이터레이터는 null이 아닌 값 (도달 가능) 만 반환하며 기본 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html&quot;&gt;ConcurrentLinkedQueue&lt;/a&gt; 의 &quot;약하게 일관된&quot;이터레이터를 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="c0554c74e1813aa666f0f951e0bf2132582a22d5" translate="yes" xml:space="preserve">
          <source>This registry makes use of the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html&quot;&gt;ServiceLoader&lt;/a&gt; facility. The preferred method for registering new &lt;a href=&quot;groovyrunner&quot;&gt;GroovyRunner&lt;/a&gt; providers is to place them in a provider-configuration file in the resource directory &lt;code&gt;META-INF/services&lt;/code&gt;. The preferred method for accessing the registered runners is by making use of the &lt;code&gt;Iterable&lt;/code&gt; interface using an enhanced for-loop.</source>
          <target state="translated">이 레지스트리는 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html&quot;&gt;ServiceLoader&lt;/a&gt; 기능을 사용합니다. 새 &lt;a href=&quot;groovyrunner&quot;&gt;GroovyRunner&lt;/a&gt; 공급자 를 등록하는 데 선호되는 방법 은 리소스 디렉터리 &lt;code&gt;META-INF/services&lt;/code&gt; 의 공급자 구성 파일에 해당 공급자를 배치하는 것입니다 . 등록 된 러너에 액세스하는 데 선호되는 방법 은 향상된 for 루프를 사용하여 &lt;code&gt;Iterable&lt;/code&gt; 인터페이스를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a509478dc010fd7ae4333771f3db41a8b51de80" translate="yes" xml:space="preserve">
          <source>This results in an effective change in the default value, which each @Grab can still override</source>
          <target state="translated">이로 인해 각 @Grab이 여전히 재정의 할 수있는 기본값이 효과적으로 변경됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
