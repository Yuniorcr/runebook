<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="groovy">
    <body>
      <group id="groovy">
        <trans-unit id="2f6d78acbc0aeed01088d8b1b9426ee59fbb2c46" translate="yes" xml:space="preserve">
          <source>A Closure containing statements which will be prepended to the generated constructor. The first statement within the Closure may be &lt;code&gt;super(someArgs)&lt;/code&gt; in which case the no-arg super constructor won't be called.</source>
          <target state="translated">생성 된 생성자 앞에 추가 될 문을 포함하는 Closure. Closure 내의 첫 번째 문은 &lt;code&gt;super(someArgs)&lt;/code&gt; 일 수 있으며 ,이 경우 인수가 없는 슈퍼 생성자가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd4659fcf3ffddd3493de79a99593c8a1b878296" translate="yes" xml:space="preserve">
          <source>A Collections utility class</source>
          <target state="translated">컬렉션 유틸리티 클래스</target>
        </trans-unit>
        <trans-unit id="9418de74a8c5c5084373fafc95d3c0111418901c" translate="yes" xml:space="preserve">
          <source>A Command line to execute groovy.</source>
          <target state="translated">groovy를 실행하는 명령 줄.</target>
        </trans-unit>
        <trans-unit id="83855d36697dc7f2bd5817a052d9107c5aac813a" translate="yes" xml:space="preserve">
          <source>A Comparator which uses a closure to compare 2 values being equal</source>
          <target state="translated">두 값이 같은 것을 비교하기 위해 클로저를 사용하는 비교기</target>
        </trans-unit>
        <trans-unit id="414fb9415a65938777e156dc4974affa9cba06c8" translate="yes" xml:space="preserve">
          <source>A Concrete Syntax Tree of the source</source>
          <target state="translated">소스의 구체적인 구문 트리</target>
        </trans-unit>
        <trans-unit id="d961611a21ba4b31e18ddbccf0cf91717f6ca34a" translate="yes" xml:space="preserve">
          <source>A ConfigObject at a simple level is a Map that creates configuration entries (other ConfigObjects) when referencing them. This means that navigating to foo.bar.stuff will not return null but nested ConfigObjects which are of course empty maps The Groovy truth can be used to check for the existence of &quot;real&quot; entries.</source>
          <target state="translated">단순한 수준의 ConfigObject는 참조 할 때 구성 항목 (다른 ConfigObject)을 생성하는 맵입니다. 즉, foo.bar.stuff로 이동하면 null이 아니라 중첩 된 ConfigObjects (물론 빈 맵)가 반환됩니다. Groovy 진실은 &quot;실제&quot;항목의 존재를 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87060f0963c51b42a783ee24921e7a0629e2ffed" translate="yes" xml:space="preserve">
          <source>A ConfigObject is a tree structure consisting of nested maps.</source>
          <target state="translated">ConfigObject는 중첩 된 맵으로 구성된 트리 구조입니다.</target>
        </trans-unit>
        <trans-unit id="e9690d01421bf94eb0d5d2d78ae54c3ae5d0b9a2" translate="yes" xml:space="preserve">
          <source>A ConfigObject is a tree structure consisting of nested maps. This flattens the maps into a single level structure like a properties file</source>
          <target state="translated">ConfigObject는 중첩 된 맵으로 구성된 트리 구조입니다. 이렇게하면 맵이 속성 파일과 같은 단일 레벨 구조로 평면화됩니다.</target>
        </trans-unit>
        <trans-unit id="03a26e5bbda6d583c934ea6365fded9fd8353a69" translate="yes" xml:space="preserve">
          <source>A DGM-like class which adds support for method calls which are handled specifically by the Groovy compiler.</source>
          <target state="translated">Groovy 컴파일러에서 특별히 처리하는 메서드 호출에 대한 지원을 추가하는 DGM과 유사한 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="3c838959704688fe4023361f4af2d5c2f092cfb3" translate="yes" xml:space="preserve">
          <source>A GString containing a single empty String and no values.</source>
          <target state="translated">하나의 빈 문자열을 포함하고 값이없는 GString입니다.</target>
        </trans-unit>
        <trans-unit id="b6cdd59379fa4fe793d2bd731df39c6b3fb4f138" translate="yes" xml:space="preserve">
          <source>A GString variant of the equivalent CharSequence method &lt;a href=&quot;#dropRight(java.lang.CharSequence,%20int)&quot;&gt;dropRight(CharSequence,int)&lt;/a&gt;.</source>
          <target state="translated">동등한 CharSequence 메소드 &lt;a href=&quot;#dropRight(java.lang.CharSequence,%20int)&quot;&gt;dropRight (CharSequence, int)&lt;/a&gt; 의 GString 변형 .</target>
        </trans-unit>
        <trans-unit id="acf3a25460d426dede483995050de64071c38744" translate="yes" xml:space="preserve">
          <source>A GString variant of the equivalent CharSequence method &lt;a href=&quot;#takeAfter(java.lang.CharSequence,%20java.lang.CharSequence)&quot;&gt;takeAfter(CharSequence,CharSequence)&lt;/a&gt;.</source>
          <target state="translated">동등한 CharSequence 메소드 &lt;a href=&quot;#takeAfter(java.lang.CharSequence,%20java.lang.CharSequence)&quot;&gt;takeAfter (CharSequence, CharSequence)&lt;/a&gt; 의 GString 변형 .</target>
        </trans-unit>
        <trans-unit id="366720cc19b25c5f17ea28a061418ce932d98059" translate="yes" xml:space="preserve">
          <source>A GString variant of the equivalent CharSequence method &lt;a href=&quot;#takeBefore(java.lang.CharSequence,%20java.lang.CharSequence)&quot;&gt;takeBefore(CharSequence,CharSequence)&lt;/a&gt;.</source>
          <target state="translated">동등한 CharSequence 메소드 &lt;a href=&quot;#takeBefore(java.lang.CharSequence,%20java.lang.CharSequence)&quot;&gt;takeBefore (CharSequence, CharSequence)&lt;/a&gt; 의 GString 변형 .</target>
        </trans-unit>
        <trans-unit id="d026ec33fec4933bc6632e1068cb4009383f91ef" translate="yes" xml:space="preserve">
          <source>A GString variant of the equivalent CharSequence method &lt;a href=&quot;#takeBetween(java.lang.CharSequence,%20java.lang.CharSequence)&quot;&gt;takeBetween(CharSequence,CharSequence)&lt;/a&gt;.</source>
          <target state="translated">동등한 CharSequence 메소드 &lt;a href=&quot;#takeBetween(java.lang.CharSequence,%20java.lang.CharSequence)&quot;&gt;takeBetween (CharSequence, CharSequence)&lt;/a&gt; 의 GString 변형 .</target>
        </trans-unit>
        <trans-unit id="53661c8acbb1d718d6b26e495629ecd6e804e41f" translate="yes" xml:space="preserve">
          <source>A GString variant of the equivalent CharSequence method &lt;a href=&quot;#takeBetween(java.lang.CharSequence,%20java.lang.CharSequence,%20int)&quot;&gt;takeBetween(CharSequence,CharSequence,int)&lt;/a&gt;.</source>
          <target state="translated">동등한 CharSequence 메소드 &lt;a href=&quot;#takeBetween(java.lang.CharSequence,%20java.lang.CharSequence,%20int)&quot;&gt;takeBetween (CharSequence, CharSequence, int)&lt;/a&gt; 의 GString 변형 .</target>
        </trans-unit>
        <trans-unit id="3986175a9d36a81123d672e3d4af6824ca08a2b3" translate="yes" xml:space="preserve">
          <source>A GString variant of the equivalent CharSequence method &lt;a href=&quot;#takeBetween(java.lang.CharSequence,%20java.lang.CharSequence,%20java.lang.CharSequence)&quot;&gt;takeBetween(CharSequence,CharSequence,CharSequence)&lt;/a&gt;.</source>
          <target state="translated">동등한 CharSequence 메소드 &lt;a href=&quot;#takeBetween(java.lang.CharSequence,%20java.lang.CharSequence,%20java.lang.CharSequence)&quot;&gt;takeBetween (CharSequence, CharSequence, CharSequence)&lt;/a&gt; 의 GString 변형 .</target>
        </trans-unit>
        <trans-unit id="0b54d145ee7eb0ee85aa9abe01a77c5ba29676e7" translate="yes" xml:space="preserve">
          <source>A GString variant of the equivalent CharSequence method &lt;a href=&quot;#takeBetween(java.lang.CharSequence,%20java.lang.CharSequence,%20java.lang.CharSequence,%20int)&quot;&gt;takeBetween(CharSequence,CharSequence,CharSequence,int)&lt;/a&gt;.</source>
          <target state="translated">동등한 CharSequence 메소드 &lt;a href=&quot;#takeBetween(java.lang.CharSequence,%20java.lang.CharSequence,%20java.lang.CharSequence,%20int)&quot;&gt;takeBetween (CharSequence, CharSequence, CharSequence, int)&lt;/a&gt; 의 GString 변형 .</target>
        </trans-unit>
        <trans-unit id="3d5a505269acc7d3f5f1d99106c78b40fa0e7626" translate="yes" xml:space="preserve">
          <source>A GString variant of the equivalent CharSequence method &lt;a href=&quot;#takeRight(java.lang.CharSequence,%20int)&quot;&gt;takeRight(CharSequence,int)&lt;/a&gt;.</source>
          <target state="translated">동등한 CharSequence 메소드 &lt;a href=&quot;#takeRight(java.lang.CharSequence,%20int)&quot;&gt;takeRight (CharSequence, int)&lt;/a&gt; 의 GString 변형 .</target>
        </trans-unit>
        <trans-unit id="292098c58e042a8d51ac915bde47f9ef60e09e6c" translate="yes" xml:space="preserve">
          <source>A GString variant of the equivalent CharSequence method.</source>
          <target state="translated">동등한 CharSequence 메소드의 GString 변형입니다.</target>
        </trans-unit>
        <trans-unit id="0f43441603cf14d2fd96ceb949917b7f89e8d077" translate="yes" xml:space="preserve">
          <source>A GString variant of the equivalent GString method.</source>
          <target state="translated">동등한 GString 메소드의 GString 변형입니다.</target>
        </trans-unit>
        <trans-unit id="03afd7990dd19999bbe813d9453a3d086d0871bd" translate="yes" xml:space="preserve">
          <source>A Groovy builder that works with Stax processors. A typical usage is as follows:</source>
          <target state="translated">Stax 프로세서와 함께 작동하는 Groovy 빌더. 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b3d1484291258bc86af34f8ed3567917181185ca" translate="yes" xml:space="preserve">
          <source>A Groovy script or simple expression.</source>
          <target state="translated">Groovy 스크립트 또는 간단한 표현.</target>
        </trans-unit>
        <trans-unit id="33c16f503ce1ee967656914faa1897ff07ed6ea1" translate="yes" xml:space="preserve">
          <source>A Groovy script or simple expression. Can be anything legal inside {...}.</source>
          <target state="translated">Groovy 스크립트 또는 간단한 표현. {...} 내부에서 합법적 인 모든 것이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1267af36c412af6f5a5f0b00955918460c6323ad" translate="yes" xml:space="preserve">
          <source>A GroovyMarkup builder for creating Swing user interfaces</source>
          <target state="translated">Swing 사용자 인터페이스를 만들기위한 GroovyMarkup 빌더</target>
        </trans-unit>
        <trans-unit id="156d761cb68241351a71c683ca3b76532c62e576" translate="yes" xml:space="preserve">
          <source>A GroovyObject facade for an underlying MBean which acts like a normal groovy object but which is actually implemented via an underlying JMX MBean. Properties and normal method invocations delegate to the MBeanServer to the actual MBean.</source>
          <target state="translated">일반 그루비 객체처럼 작동하지만 실제로는 기본 JMX MBean을 통해 구현되는 기본 MBean에 대한 GroovyObject 파사드. 프로퍼티와 일반 메소드 호출은 실제 MBean에 대한 MBeanServer에 위임됩니다.</target>
        </trans-unit>
        <trans-unit id="7c4e690e9d4ee4d47b91f0213f7dbf3188d48713" translate="yes" xml:space="preserve">
          <source>A JSON token, with a type, line / column information, and the text of that token.</source>
          <target state="translated">유형, 행 / 열 정보 및 해당 토큰의 텍스트가 포함 된 JSON 토큰.</target>
        </trans-unit>
        <trans-unit id="1d410d9869d9bd3121cee2742e47c35c9f437b83" translate="yes" xml:space="preserve">
          <source>A JUnit 3 &lt;a href=&quot;https://junit.org/junit4/javadoc/latest/junit/framework/TestCase.html&quot;&gt;TestCase&lt;/a&gt; base class in Groovy. In case JUnit 4 is used, see &lt;a href=&quot;../test/groovyassert&quot;&gt;GroovyAssert&lt;/a&gt;.</source>
          <target state="translated">Groovy 의 JUnit 3 &lt;a href=&quot;https://junit.org/junit4/javadoc/latest/junit/framework/TestCase.html&quot;&gt;TestCase&lt;/a&gt; 기본 클래스. JUnit 4를 사용하는 경우 &lt;a href=&quot;../test/groovyassert&quot;&gt;GroovyAssert를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="638989d60ef6a9935147b24d7777c6273f074153" translate="yes" xml:space="preserve">
          <source>A JUnit 3 &lt;a href=&quot;https://junit.org/junit4/javadoc/latest/junit/framework/TestCase.html&quot;&gt;TestCase&lt;/a&gt; base class in Groovy. In case JUnit 4 is used, see &lt;a href=&quot;groovyassert&quot;&gt;GroovyAssert&lt;/a&gt;.</source>
          <target state="translated">Groovy 의 JUnit 3 &lt;a href=&quot;https://junit.org/junit4/javadoc/latest/junit/framework/TestCase.html&quot;&gt;TestCase&lt;/a&gt; 기본 클래스. JUnit 4를 사용하는 경우 &lt;a href=&quot;groovyassert&quot;&gt;GroovyAssert를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed490fad5788a7ac370e1249ff8eb7f4a338011d" translate="yes" xml:space="preserve">
          <source>A JsonGenerator that can be configured with various JsonGenerator.Options. If the default options are sufficient consider using the static &lt;code&gt;JsonOutput.toJson&lt;/code&gt; methods.</source>
          <target state="translated">다양한 JsonGenerator.Options로 구성 할 수있는 JsonGenerator입니다. 기본 옵션으로 충분하면 정적 &lt;code&gt;JsonOutput.toJson&lt;/code&gt; 메서드를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f4a4a1e087b90acb1950d305de50de2f4995ab48" translate="yes" xml:space="preserve">
          <source>A List implementation which is returned by queries on a &lt;a href=&quot;node&quot;&gt;Node&lt;/a&gt; which provides some XPath like helper methods for GPath.</source>
          <target state="translated">GPath에 대한 도우미 메서드와 같은 일부 XPath를 제공 하는 &lt;a href=&quot;node&quot;&gt;노드&lt;/a&gt; 에 대한 쿼리에 의해 반환되는 목록 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="224123b8cb95902ddbec40cd873417bc357db2f2" translate="yes" xml:space="preserve">
          <source>A List of MetaMethods matching the argument types which will be empty if no matching methods exist</source>
          <target state="translated">인수 유형과 일치하는 MetaMethod 목록 (일치하는 메소드가없는 경우 비어 있음)</target>
        </trans-unit>
        <trans-unit id="34a59b5b75c93513acffd7b39c8c22ead0e789aa" translate="yes" xml:space="preserve">
          <source>A List of MetaMethods matching the given name or an empty list if no matching methods exist</source>
          <target state="translated">주어진 이름과 일치하는 MetaMethod 목록 또는 일치하는 메소드가없는 경우 빈 목록</target>
        </trans-unit>
        <trans-unit id="6acc970cba6ed529f8e9ebe111d5b698af46ec74" translate="yes" xml:space="preserve">
          <source>A List of MetaMethods which will be empty if no methods with the given name exist</source>
          <target state="translated">주어진 이름을 가진 메소드가 존재하지 않으면 비어있는 MetaMethods 목록</target>
        </trans-unit>
        <trans-unit id="97a30e462497f5c6e319ae0e1b1e1d5ed32f93df" translate="yes" xml:space="preserve">
          <source>A LoggingStrategy defines how to wire a new logger instance into an existing class.</source>
          <target state="translated">LoggingStrategy는 새 로거 인스턴스를 기존 클래스에 연결하는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="df2607e244da71ae64ade8e09e26042aa1e915b3" translate="yes" xml:space="preserve">
          <source>A LoggingStrategy defines how to wire a new logger instance into an existing class. It is meant to be used with the</source>
          <target state="translated">LoggingStrategy는 새 로거 인스턴스를 기존 클래스에 연결하는 방법을 정의합니다. 함께 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="dff317e957586d43dd64fc011140dcf501479a1b" translate="yes" xml:space="preserve">
          <source>A MOP Writer that skips the generation of MOP methods. This writer is used when a class is *fully* statically compiled. In mixed mode, MOP methods are still generated.</source>
          <target state="translated">MOP 메소드 생성을 건너 뛰는 MOP 작성기. 이 작성기는 클래스가 * 완전 * 정적으로 컴파일 될 때 사용됩니다. 혼합 모드에서는 MOP 방법이 계속 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f552e25ed80c5715dbd952e038038cd6e0ca6716" translate="yes" xml:space="preserve">
          <source>A Main instance has a Groovysh member representing the shell, and a startGroovysh() method to run an interactive shell. Subclasses should preferably extend createIO() or configure the shell via getShell prior to invoking startGroovysh. Clients may use configureAndStartGroovysh to provide the same CLI params but a different Groovysh implementation (implementing getIO() and run()). The class also has static utility methods to manipulate the static ansi state using the jAnsi library. Main CLI entry-point for</source>
          <target state="translated">Main 인스턴스에는 셸을 나타내는 Groovysh 멤버와 대화 형 셸을 실행하는 startGroovysh () 메서드가 있습니다. 서브 클래스는 가급적이면 createIO ()를 확장하거나 startGroovysh를 호출하기 전에 getShell을 통해 쉘을 구성해야합니다. 클라이언트는 configureAndStartGroovysh를 사용하여 동일한 CLI 매개 변수를 제공하지만 다른 Groovysh 구현 (getIO () 및 run () 구현)을 제공 할 수 있습니다. 클래스에는 또한 jAnsi 라이브러리를 사용하여 정적 ansi 상태를 조작하는 정적 유틸리티 메소드가 있습니다. 에 대한 기본 CLI 진입 점</target>
        </trans-unit>
        <trans-unit id="8a1bcb46fa2bbfaf8462496f7d2f18cf223a122a" translate="yes" xml:space="preserve">
          <source>A Map of maps that can be navigating with dot de-referencing syntax to obtain configuration entries</source>
          <target state="translated">구성 항목을 얻기 위해 점 역 참조 구문으로 탐색 할 수있는 맵 맵</target>
        </trans-unit>
        <trans-unit id="80b6f976edca9bd0498348922485b0ed6f6c22ee" translate="yes" xml:space="preserve">
          <source>A Map.Entry implementation.</source>
          <target state="translated">Map.Entry 구현.</target>
        </trans-unit>
        <trans-unit id="d6bec4d0f9624f5f9f88e218056b2dceb3496c5d" translate="yes" xml:space="preserve">
          <source>A MetaClass within Groovy defines the behaviour of any given Groovy or Java class</source>
          <target state="translated">Groovy 내의 MetaClass는 주어진 Groovy 또는 Java 클래스의 동작을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4359d4338da210e4d2f96e65b6409c4703d99ab2" translate="yes" xml:space="preserve">
          <source>A MetaClass within Groovy defines the behaviour of any given Groovy or Java class. The MetaClass interface defines two parts. The client API, which is defined via the extend MetaObjectProtocol interface and the contract with the Groovy runtime system. In general the compiler and Groovy runtime engine interact with methods on this class whilst MetaClass clients interact with the method defined by the MetaObjectProtocol interface</source>
          <target state="translated">Groovy 내의 MetaClass는 주어진 Groovy 또는 Java 클래스의 동작을 정의합니다. MetaClass 인터페이스는 두 부분을 정의합니다. 확장 MetaObjectProtocol 인터페이스 및 Groovy 런타임 시스템과의 계약을 통해 정의 된 클라이언트 API. 일반적으로 컴파일러 및 Groovy 런타임 엔진은이 클래스의 메서드와 상호 작용하는 반면 MetaClass 클라이언트는 MetaObjectProtocol 인터페이스에 정의 된 메서드와 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="d831e36c0da29fd84eca3181710f80cc8cf7ff84" translate="yes" xml:space="preserve">
          <source>A MetaClassRegistry is an object that is responsible for managing the a cache of MetaClass instances. Each java.lang.Class instance has an associated MetaClass and client code can query this interface for the MetaClass for a given associated java.lang.Class</source>
          <target state="translated">MetaClassRegistry는 MetaClass 인스턴스의 캐시를 관리하는 객체입니다. 각 java.lang.Class 인스턴스에는 연관된 MetaClass가 있으며 클라이언트 코드는 주어진 연관된 java.lang.Class에 대한 MetaClass에 대해이 인터페이스를 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="361c65cfd06f0b1e731bed406f5478a12f7903d3" translate="yes" xml:space="preserve">
          <source>A MetaMethod implementation useful for implementing coercion based invocations</source>
          <target state="translated">강제 기반 호출을 구현하는 데 유용한 MetaMethod 구현</target>
        </trans-unit>
        <trans-unit id="5f8c606f398112236be5998214cb97cbf2e8cab0" translate="yes" xml:space="preserve">
          <source>A MetaMethod implementation where the underlying method is really a static helper method on some class but it appears to be an instance method on a class. This implementation is used to add new methods to the JDK writing them as normal static methods with the first parameter being the class on which the method is added.</source>
          <target state="translated">기본 메서드가 실제로 일부 클래스의 정적 도우미 메서드이지만 클래스의 인스턴스 메서드 인 것처럼 보이는 MetaMethod 구현입니다. 이 구현은 JDK에 새 메소드를 추가하는 데 사용되며 첫 번째 매개 변수가 메소드가 추가되는 클래스 인 일반 정적 메소드로 작성합니다.</target>
        </trans-unit>
        <trans-unit id="3b00ca6193a8b38d448a7c0f657f526c15300a1e" translate="yes" xml:space="preserve">
          <source>A MetaMethod implementation where the underlying method is really a static helper method on some class. This implementation is used to add new static methods to the JDK writing them as normal static methods with the first parameter being the class on which the method is added.</source>
          <target state="translated">기본 메서드가 실제로 일부 클래스의 정적 도우미 메서드 인 MetaMethod 구현입니다. 이 구현은 JDK에 새 정적 메소드를 추가하는 데 사용되며 첫 번째 매개 변수가 메소드가 추가되는 클래스 인 일반 정적 메소드로 작성합니다.</target>
        </trans-unit>
        <trans-unit id="aeacbac7b43efd2e80f98775658d57983520b615" translate="yes" xml:space="preserve">
          <source>A MetaMethod or null if it doesn't exist</source>
          <target state="translated">MetaMethod 또는 존재하지 않는 경우 null</target>
        </trans-unit>
        <trans-unit id="84098d2706ab0e22e644220b88647da7b9200bff" translate="yes" xml:space="preserve">
          <source>A MetaMethod that accepts a closure in the constructor which is invoked when the MetaMethod is called. The delegate of the closure is set to the instance that the MetaMethod is invoked on when called.</source>
          <target state="translated">MetaMethod가 호출 될 때 호출되는 생성자에서 클로저를 받아들이는 MetaMethod. 클로저의 델리게이트는 MetaMethod가 호출 될 때 호출되는 인스턴스로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c6770a5e2228cde5ebccbee9f4f9786135964fc3" translate="yes" xml:space="preserve">
          <source>A MetaProperty or null</source>
          <target state="translated">MetaProperty 또는 null</target>
        </trans-unit>
        <trans-unit id="fe769ed93c1ba1b97e7bed39376f487dd3e3c241" translate="yes" xml:space="preserve">
          <source>A NullObject pattern implementation for ProtectionStorage Doesn't protect any resources. Used when the user doesn't mind to eventually have the whole memoize cache emptied by gc.</source>
          <target state="translated">ProtectionStorage에 대한 NullObject 패턴 구현은 리소스를 보호하지 않습니다. 사용자가 결국 gc에 의해 전체 메모 캐시를 비워도 괜찮을 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="84f4e03b6b87f31cd08e087e5e3b26f633fb5ba7" translate="yes" xml:space="preserve">
          <source>A NumberRange's hashCode is based on hashCode values of the discrete items it represents.</source>
          <target state="translated">NumberRange의 hashCode는 나타내는 개별 항목의 hashCode 값을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="d45bbcd1d4f63b9713650783b2f6e30ec100a505" translate="yes" xml:space="preserve">
          <source>A Period will be returned for types &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Year.html&quot;&gt;Year&lt;/a&gt;, &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/YearMonth.html&quot;&gt;YearMonth&lt;/a&gt;, and &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/chrono/ChronoLocalDate.html&quot;&gt;ChronoLocalDate&lt;/a&gt;; otherwise, a Duration will be returned.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Year.html&quot;&gt;Year&lt;/a&gt; , &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/YearMonth.html&quot;&gt;YearMonth&lt;/a&gt; 및 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/chrono/ChronoLocalDate.html&quot;&gt;ChronoLocalDate&lt;/a&gt; 유형에 대해 기간이 리턴됩니다 . 그렇지 않으면 Duration이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="94a87e628268e6d4abac604f4e0acb56e4307e52" translate="yes" xml:space="preserve">
          <source>A PrintStream that outputs objects in Groovy style. That means print(Object) uses InvokerHelper.toString(Object) to produce the same results as Writer.print(Object).</source>
          <target state="translated">Groovy 스타일로 개체를 출력하는 PrintStream입니다. 즉, print (Object)는 InvokerHelper.toString (Object)을 사용하여 Writer.print (Object)와 동일한 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="553919043e383ea1d7bef7b426c8eb375493c097" translate="yes" xml:space="preserve">
          <source>A PrintWriter that outputs objects in Groovy style. That means print(Object) uses InvokerHelper.toString(Object) to produce the same results as Writer.print(Object).</source>
          <target state="translated">Groovy 스타일로 개체를 출력하는 PrintWriter입니다. 즉, print (Object)는 InvokerHelper.toString (Object)을 사용하여 Writer.print (Object)와 동일한 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="bd2c4e7a683d004dd3046fc5036353da247a8e70" translate="yes" xml:space="preserve">
          <source>A Range represents the list of discrete items between some starting (or &lt;code&gt;from&lt;/code&gt;) value and &lt;em&gt;working up&lt;/em&gt; towards some ending (or &lt;code&gt;to&lt;/code&gt;) value. For a reverse range, the list is obtained by starting at the &lt;code&gt;to&lt;/code&gt; value and &lt;em&gt;working down&lt;/em&gt; towards the &lt;code&gt;from&lt;/code&gt; value. The concept of &lt;em&gt;working up&lt;/em&gt; and &lt;em&gt;working down&lt;/em&gt; is dependent on the range implementation. In the general case, working up involves successive calls to the first item's &lt;code&gt;next()&lt;/code&gt; method while working down involves calling the &lt;code&gt;previous()&lt;/code&gt; method. Optimized numerical ranges may apply numeric addition or subtraction of some numerical step size. Particular range implementations may also support the notion of inclusivity and exclusivity with respect to the ending value in the range. E.g. &lt;code&gt;1..3 == [1, 2, 3]&lt;/code&gt;; but &lt;code&gt;1..&amp;lt;3 == [1, 2]&lt;/code&gt;. In general, the second boundary may not be contained in the range, and &lt;code&gt;a..b&lt;/code&gt; may produce a different set of elements than &lt;code&gt;(b..a).reversed()&lt;/code&gt;. E.g. &lt;code&gt;1..2.5 == [1, 2]&lt;/code&gt;; but &lt;code&gt;2.5..1 == [2.5, 1.5]&lt;/code&gt;. Implementations can be memory efficient by storing just the &lt;code&gt;from&lt;/code&gt; and &lt;code&gt;to&lt;/code&gt; boundary values rather than eagerly creating all discrete items in the conceptual list. The actual discrete items can be lazily calculated on an as needed basis (e.g. when calling methods from the &lt;code&gt;java.util.List&lt;/code&gt; interface or the additional &lt;code&gt;step&lt;/code&gt; methods in the &lt;code&gt;Range&lt;/code&gt; interface). In addition to the methods related to a Range's &quot;discrete items&quot; abstraction, there is a method, &lt;code&gt;containsWithinBounds&lt;/code&gt; which, for numerical ranges, allows checking within the continuous interval between the Range's boundary values.</source>
          <target state="translated">범위는 일부 시작 (또는 사이에 개별 항목의 목록을 나타냅니다 &lt;code&gt;from&lt;/code&gt; ) 값과 &lt;em&gt;최대 작업&lt;/em&gt; 일부 종료 (또는 방향 &lt;code&gt;to&lt;/code&gt; ) 값입니다. 역방향 범위 목록은 시작하여 얻어지는 &lt;code&gt;to&lt;/code&gt; 값 &lt;em&gt;아래로 작동&lt;/em&gt; 쪽으로 &lt;code&gt;from&lt;/code&gt; 값. 의 개념 &lt;em&gt;까지 작업&lt;/em&gt; 하고 &lt;em&gt;아래 작업은&lt;/em&gt; 범위의 구현에 따라 달라집니다. 일반적으로 작업은 첫 번째 항목의 &lt;code&gt;next()&lt;/code&gt; 메서드 에 대한 연속 호출을 포함하고 작업을 수행하려면 &lt;code&gt;previous()&lt;/code&gt; 호출을 포함합니다.방법. 최적화 된 숫자 범위는 일부 숫자 단계 크기의 숫자 더하기 또는 빼기를 적용 할 수 있습니다. 특정 범위 구현은 범위의 종료 값과 관련하여 포괄 성 및 배타성 개념을 지원할 수도 있습니다. 예 : &lt;code&gt;1..3 == [1, 2, 3]&lt;/code&gt; ; 그러나 &lt;code&gt;1..&amp;lt;3 == [1, 2]&lt;/code&gt; . 일반적으로 두 번째 경계는 범위에 포함되지 않을 수 있으며 &lt;code&gt;a..b&lt;/code&gt; 는 &lt;code&gt;(b..a).reversed()&lt;/code&gt; 와 다른 요소 집합을 생성 할 수 있습니다 . 예 : &lt;code&gt;1..2.5 == [1, 2]&lt;/code&gt; ; 그러나 &lt;code&gt;2.5..1 == [2.5, 1.5]&lt;/code&gt; . 구현은 단지 저장함으로써 메모리 효율적일 수 &lt;code&gt;from&lt;/code&gt; 및 &lt;code&gt;to&lt;/code&gt; 개념 목록에서 모든 개별 항목을 열심히 만드는 대신 경계 값. 실제 개별 항목은 필요에 따라 느리게 계산 될 수 있습니다 (예 : &lt;code&gt;java.util.List&lt;/code&gt; 인터페이스 에서 메서드를 호출 하거나 &lt;code&gt;Range&lt;/code&gt; 인터페이스 에서 추가 &lt;code&gt;step&lt;/code&gt; 메서드를 호출 할 때 ). Range의 &quot;이산 항목&quot;추상화와 관련된 메서드 외에도 숫자 범위의 경우 Range 경계 값 사이의 연속 간격 내에서 확인할 수있는 &lt;code&gt;containsWithinBounds&lt;/code&gt; 메서드가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4b4072014ebd12ec595b93e1d89adbb8defa6d5a" translate="yes" xml:space="preserve">
          <source>A ReaderSource for source files hosted at a URL.</source>
          <target state="translated">URL에서 호스팅되는 소스 파일에 대한 ReaderSource입니다.</target>
        </trans-unit>
        <trans-unit id="6f4f9cf62a9b35501175bba1b165af3be349f604" translate="yes" xml:space="preserve">
          <source>A ReaderSource for source files.</source>
          <target state="translated">소스 파일에 대한 ReaderSource입니다.</target>
        </trans-unit>
        <trans-unit id="7e6ea701e1b097692e065d214feb25192f0c3cc5" translate="yes" xml:space="preserve">
          <source>A ReaderSource for source strings.</source>
          <target state="translated">소스 문자열에 대한 ReaderSource입니다.</target>
        </trans-unit>
        <trans-unit id="4e53797486bce26e164a0b992606941c5b299e86" translate="yes" xml:space="preserve">
          <source>A Realm is the representation of a metaclass layer in a tree of realm objects.</source>
          <target state="translated">Realm은 영역 객체 트리에있는 메타 클래스 계층의 표현입니다.</target>
        </trans-unit>
        <trans-unit id="c4cefa9b21f4fce70debe432fada646f94874aca" translate="yes" xml:space="preserve">
          <source>A ResultSet out parameter.</source>
          <target state="translated">ResultSet out 매개 변수.</target>
        </trans-unit>
        <trans-unit id="d84c9ee86ec2babca3643d79ce6802bdccbc14d8" translate="yes" xml:space="preserve">
          <source>A Runnable which waits for a process to complete together with a notification scheme allowing another thread to wait a maximum number of seconds for the process to complete before killing it.</source>
          <target state="translated">프로세스가 종료되기 전에 다른 스레드가 프로세스가 완료 될 때까지 최대 시간 (초) 동안 대기 할 수 있도록하는 알림 체계와 함께 프로세스가 완료되기를 기다리는 Runnable입니다.</target>
        </trans-unit>
        <trans-unit id="0d11e5390941be1221e2781f372eb9a14a22882e" translate="yes" xml:space="preserve">
          <source>A SAX handler for turning XML into Groovy scripts</source>
          <target state="translated">XML을 Groovy 스크립트로 변환하기위한 SAX 핸들러</target>
        </trans-unit>
        <trans-unit id="3a7b8a6940dbefd3e48e086f5a7c72ee240f1f30" translate="yes" xml:space="preserve">
          <source>A Serializable class for barrier lock *</source>
          <target state="translated">장벽 잠금을위한 직렬화 가능 클래스 *</target>
        </trans-unit>
        <trans-unit id="f0760b2f562dafa13f7175a6bf21fb839ea2683d" translate="yes" xml:space="preserve">
          <source>A String containing the capitalized toString() of the CharSequence</source>
          <target state="translated">CharSequence의 대문자 toString ()을 포함하는 문자열</target>
        </trans-unit>
        <trans-unit id="db6d1021028e3cbf16df11dca2fd2f2666ebbd60" translate="yes" xml:space="preserve">
          <source>A String containing the contents of the line, not including any line-termination characters, or null if the end of the stream has been reached</source>
          <target state="translated">줄 종료 문자를 포함하지 않고 줄의 내용을 포함하는 문자열 또는 스트림의 끝에 도달 한 경우 null</target>
        </trans-unit>
        <trans-unit id="73534becd736698b4fef999cfdfef2f66e888fbb" translate="yes" xml:space="preserve">
          <source>A String containing the uncapitalized toString() of the CharSequence</source>
          <target state="translated">CharSequence의 대문자없는 toString ()을 포함하는 문자열</target>
        </trans-unit>
        <trans-unit id="2adef6b2010f873ba900029df3e69c1423334620" translate="yes" xml:space="preserve">
          <source>A String variant of the equivalent CharSequence method &lt;a href=&quot;#dropRight(java.lang.CharSequence,%20int)&quot;&gt;dropRight(CharSequence,int)&lt;/a&gt;.</source>
          <target state="translated">동등한 CharSequence 메서드 &lt;a href=&quot;#dropRight(java.lang.CharSequence,%20int)&quot;&gt;dropRight (CharSequence, int)&lt;/a&gt; 의 문자열 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="85e4088ede3d846e3e783631a3203efa057e1daf" translate="yes" xml:space="preserve">
          <source>A String variant of the equivalent CharSequence method &lt;a href=&quot;#takeAfter(java.lang.CharSequence,%20java.lang.CharSequence)&quot;&gt;takeAfter(CharSequence,CharSequence)&lt;/a&gt;.</source>
          <target state="translated">동등한 CharSequence 메소드 &lt;a href=&quot;#takeAfter(java.lang.CharSequence,%20java.lang.CharSequence)&quot;&gt;takeAfter (CharSequence, CharSequence)&lt;/a&gt; 의 문자열 변형 .</target>
        </trans-unit>
        <trans-unit id="c06d71fab2df61a7ddfc325ec2617d4838f93183" translate="yes" xml:space="preserve">
          <source>A String variant of the equivalent CharSequence method &lt;a href=&quot;#takeBefore(java.lang.CharSequence,%20java.lang.CharSequence)&quot;&gt;takeBefore(CharSequence,CharSequence)&lt;/a&gt;.</source>
          <target state="translated">동등한 CharSequence 메서드 &lt;a href=&quot;#takeBefore(java.lang.CharSequence,%20java.lang.CharSequence)&quot;&gt;takeBefore (CharSequence, CharSequence)&lt;/a&gt; 의 문자열 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="6e15b8a4294a9309b7a96d3880a5c27c1b8f8c6e" translate="yes" xml:space="preserve">
          <source>A String variant of the equivalent CharSequence method &lt;a href=&quot;#takeBetween(java.lang.CharSequence,%20java.lang.CharSequence)&quot;&gt;takeBetween(CharSequence,CharSequence)&lt;/a&gt;.</source>
          <target state="translated">동등한 CharSequence 메서드 &lt;a href=&quot;#takeBetween(java.lang.CharSequence,%20java.lang.CharSequence)&quot;&gt;takeBetween (CharSequence, CharSequence)&lt;/a&gt; 의 String 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="bed43d79143f31cb37255e4d163e0cc57f904e98" translate="yes" xml:space="preserve">
          <source>A String variant of the equivalent CharSequence method &lt;a href=&quot;#takeBetween(java.lang.CharSequence,%20java.lang.CharSequence,%20int)&quot;&gt;takeBetween(CharSequence,CharSequence,int)&lt;/a&gt;.</source>
          <target state="translated">동등한 CharSequence 메서드 &lt;a href=&quot;#takeBetween(java.lang.CharSequence,%20java.lang.CharSequence,%20int)&quot;&gt;takeBetween (CharSequence, CharSequence, int)&lt;/a&gt; 의 String 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="3896e44b2c02eb57787e0889aadd32f32797c3f4" translate="yes" xml:space="preserve">
          <source>A String variant of the equivalent CharSequence method &lt;a href=&quot;#takeBetween(java.lang.CharSequence,%20java.lang.CharSequence,%20java.lang.CharSequence)&quot;&gt;takeBetween(CharSequence,CharSequence,CharSequence)&lt;/a&gt;.</source>
          <target state="translated">동등한 CharSequence 메서드 &lt;a href=&quot;#takeBetween(java.lang.CharSequence,%20java.lang.CharSequence,%20java.lang.CharSequence)&quot;&gt;takeBetween (CharSequence, CharSequence, CharSequence)&lt;/a&gt; 의 문자열 변형 .</target>
        </trans-unit>
        <trans-unit id="4b9abc50bc4ceb0f7599ed670c80cf61a06d7097" translate="yes" xml:space="preserve">
          <source>A String variant of the equivalent CharSequence method &lt;a href=&quot;#takeBetween(java.lang.CharSequence,%20java.lang.CharSequence,%20java.lang.CharSequence,%20int)&quot;&gt;takeBetween(CharSequence,CharSequence,CharSequence,int)&lt;/a&gt;.</source>
          <target state="translated">동등한 CharSequence 메서드 &lt;a href=&quot;#takeBetween(java.lang.CharSequence,%20java.lang.CharSequence,%20java.lang.CharSequence,%20int)&quot;&gt;takeBetween (CharSequence, CharSequence, CharSequence, int)&lt;/a&gt; 의 문자열 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="3633f27c29c5a5f1b263d740f5816349d0ff99a4" translate="yes" xml:space="preserve">
          <source>A String variant of the equivalent CharSequence method &lt;a href=&quot;#takeRight(java.lang.CharSequence,%20int)&quot;&gt;takeRight(CharSequence,int)&lt;/a&gt;.</source>
          <target state="translated">동등한 CharSequence 메서드 &lt;a href=&quot;#takeRight(java.lang.CharSequence,%20int)&quot;&gt;takeRight (CharSequence, int)&lt;/a&gt; 의 String 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="2627e9877b75b153bef89b9589139bbd1516517b" translate="yes" xml:space="preserve">
          <source>A String variant of the equivalent CharSequence method.</source>
          <target state="translated">동등한 CharSequence 메서드의 String 변형입니다.</target>
        </trans-unit>
        <trans-unit id="5867b64b069605865d51b149b234e9d2ce202ac1" translate="yes" xml:space="preserve">
          <source>A SyntaxErrorReportable is a recognizer that can report syntax error</source>
          <target state="translated">SyntaxErrorReportable은 구문 오류를보고 할 수있는 인식기입니다.</target>
        </trans-unit>
        <trans-unit id="4e523d33e65bb17eeaad2d74b6fdab440e1fa865" translate="yes" xml:space="preserve">
          <source>A TestSuite which will run a Groovy unit test case inside any Java IDE either as a unit test case or as an application.</source>
          <target state="translated">단위 테스트 케이스 또는 애플리케이션으로 Java IDE 내에서 Groovy 단위 테스트 케이스를 실행하는 TestSuite.</target>
        </trans-unit>
        <trans-unit id="582abba5f38bc8924dc696211bb7f91e12baa959" translate="yes" xml:space="preserve">
          <source>A Two-pass method is used. First all candidate annotations are added to a list then the transformations are called on those collected annotations. This is done to avoid concurrent modification exceptions during the AST tree walk and allows the transformations to alter any portion of the AST tree. Hence annotations that are added in this phase will not be processed as transformations. They will only be handled in later phases (and then only if the type was in the AST prior to any AST transformations being run against it).</source>
          <target state="translated">투 패스 방식이 사용됩니다. 먼저 모든 후보 주석이 목록에 추가 된 다음 수집 된 주석에서 변환이 호출됩니다. 이는 AST 트리 워크 중 동시 수정 예외를 방지하고 변환이 AST 트리의 모든 부분을 변경할 수 있도록하기 위해 수행됩니다. 따라서이 단계에서 추가 된 주석은 변환으로 처리되지 않습니다. 이후 단계에서만 처리됩니다 (그런 다음 AST 변환이 실행되기 전에 유형이 AST에있는 경우에만).</target>
        </trans-unit>
        <trans-unit id="6063c10195a560fdaf2704af33da5eb22855f9cd" translate="yes" xml:space="preserve">
          <source>A Writable File.</source>
          <target state="translated">쓰기 가능한 파일.</target>
        </trans-unit>
        <trans-unit id="493ebae6c449ea326b4fca8003d449531188e777" translate="yes" xml:space="preserve">
          <source>A Writable Path.</source>
          <target state="translated">쓰기 가능한 경로.</target>
        </trans-unit>
        <trans-unit id="71659e8f516b3bc7222fdfa2c2b82efd5abf6769" translate="yes" xml:space="preserve">
          <source>A base class dealing with common HTTP servlet API housekeeping aspects.</source>
          <target state="translated">일반적인 HTTP 서블릿 API 하우스 키핑 측면을 다루는 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="0f03563be96acbb523f772611dec05bbaa761c16" translate="yes" xml:space="preserve">
          <source>A base class for collecting messages and errors during processing. Each CompilationUnit should have an ErrorCollector, and the SourceUnits should share their ErrorCollector with the CompilationUnit.</source>
          <target state="translated">처리 중 메시지 및 오류를 수집하기위한 기본 클래스입니다. 각 CompilationUnit에는 ErrorCollector가 있어야하며 SourceUnit은 해당 ErrorCollector를 CompilationUnit과 공유해야합니다.</target>
        </trans-unit>
        <trans-unit id="023f6a7afed848535fff4f26bb69bf07e13ac89f" translate="yes" xml:space="preserve">
          <source>A base class for compilation messages.</source>
          <target state="translated">컴파일 메시지의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="d6a3f2ed13c0c43d29da5e3900e3011d035b9f27" translate="yes" xml:space="preserve">
          <source>A base class for customizers which only have to be applied on specific source units. This is for example useful if you want a customizer to be applied only for files matching some extensions.</source>
          <target state="translated">특정 소스 유닛에만 적용하면되는 커 스터 마이저의 기본 클래스입니다. 예를 들어 일부 확장자와 일치하는 파일에만 사용자 정의 프로그램을 적용하려는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="daa954f3a47d51ec4539bf92693f034891f3a1f7" translate="yes" xml:space="preserve">
          <source>A base class for data structures that can collect messages and errors during processing.</source>
          <target state="translated">처리 중에 메시지와 오류를 수집 할 수있는 데이터 구조의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="321fbdcacaf76c82506138569368d46588612958" translate="yes" xml:space="preserve">
          <source>A bit simplified lock designed to be inherited by.</source>
          <target state="translated">상속되도록 설계된 약간 단순화 된 잠금입니다.</target>
        </trans-unit>
        <trans-unit id="1d42f3f3d6dafdab41f5f1e52ed9ecdf9a0f9b40" translate="yes" xml:space="preserve">
          <source>A block body is a parade of zero or more statements or expressions.</source>
          <target state="translated">블록 본문은 0 개 이상의 문이나 표현의 퍼레이드입니다.</target>
        </trans-unit>
        <trans-unit id="9dd6997a82011ac3a1e873a4afcfc4ecad666ee3" translate="yes" xml:space="preserve">
          <source>A block known to be a closure, but which omits its arguments, is given this placeholder.</source>
          <target state="translated">클로저로 알려져 있지만 인수가 생략 된 블록에이 자리 표시자가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="fb938f157bacc5fa580bd4bf214b2e5ba8978933" translate="yes" xml:space="preserve">
          <source>A block known to be a closure, but which omits its arguments, is given this placeholder. A subsequent pass is responsible for deciding if there is an implicit 'it' parameter, or if the parameter list should be empty.</source>
          <target state="translated">클로저로 알려져 있지만 인수가 생략 된 블록에이 자리 표시자가 제공됩니다. 후속 패스는 암시 적 'it'매개 변수가 있는지 또는 매개 변수 목록이 비어 있어야하는지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="5e7e177d0e4a44e781de4177c17add50be93f60b" translate="yes" xml:space="preserve">
          <source>A block which is known to be a closure, even if it has no apparent arguments.</source>
          <target state="translated">명백한 인수가 없더라도 클로저로 알려진 블록.</target>
        </trans-unit>
        <trans-unit id="ce9c6083e0df0459f211e7fea14bc499d3713183" translate="yes" xml:space="preserve">
          <source>A block which is known to be a closure, even if it has no apparent arguments. A block inside an expression or after a method call is always assumed to be a closure. Only labeled, unparameterized blocks which occur directly as substatements are kept open.</source>
          <target state="translated">명백한 인수가 없더라도 클로저로 알려진 블록. 표현식 내부 또는 메서드 호출 이후의 블록은 항상 클로저로 간주됩니다. 하위 명령문으로 직접 발생하는 레이블이 지정되고 매개 변수화되지 않은 블록 만 열린 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="3debea91d4d8aa1001768022daabbdaeb69ff2fa" translate="yes" xml:space="preserve">
          <source>A boolean indicating that the 'postDir' closure should be applied at the root level</source>
          <target state="translated">'postDir'클로저가 루트 수준에서 적용되어야 함을 나타내는 부울</target>
        </trans-unit>
        <trans-unit id="a4d177f6cd82fccf94d7b6d8c3b9047221c4e6be" translate="yes" xml:space="preserve">
          <source>A boolean indicating that the 'preDir' closure should be applied at the root level</source>
          <target state="translated">'preDir'클로저가 루트 수준에서 적용되어야 함을 나타내는 부울</target>
        </trans-unit>
        <trans-unit id="a578b275a5c139722151e0564e5115f94f8c403e" translate="yes" xml:space="preserve">
          <source>A boolean indicating that the given closure should be applied for the root dir (not applicable if the 'type' is set to &lt;a href=&quot;../../../../../groovy/io/filetype#FILES&quot;&gt;FileType.FILES&lt;/a&gt;)</source>
          <target state="translated">주어진 클로저가 루트 디렉토리에 적용되어야 함을 나타내는 부울 ( 'type'이 &lt;a href=&quot;../../../../../groovy/io/filetype#FILES&quot;&gt;FileType.FILES&lt;/a&gt; 로 설정된 경우 적용되지 않음 )</target>
        </trans-unit>
        <trans-unit id="5328f178753d4310ec4d318e73ba1fbb92e83585" translate="yes" xml:space="preserve">
          <source>A boolean indicating that the given closure should be applied for the root dir (not applicable if the 'type' is set to &lt;a href=&quot;../../../../groovy/io/filetype#FILES&quot;&gt;FileType.FILES&lt;/a&gt;)</source>
          <target state="translated">주어진 클로저가 루트 디렉토리에 적용되어야 함을 나타내는 부울 ( 'type'이 &lt;a href=&quot;../../../../groovy/io/filetype#FILES&quot;&gt;FileType.FILES&lt;/a&gt; 로 설정된 경우 적용되지 않음 )</target>
        </trans-unit>
        <trans-unit id="84ee8c24cc80e5e3a91a6ff9f6614bf6c39d00ed" translate="yes" xml:space="preserve">
          <source>A buffered writer only for OutputStreamWriter that is aware of the encoding of the OutputStreamWriter.</source>
          <target state="translated">OutputStreamWriter의 인코딩을 인식하는 OutputStreamWriter 전용 버퍼링 된 작성기입니다.</target>
        </trans-unit>
        <trans-unit id="0dd21d2430d8af1b08f9a63961a95473e1aeacdf" translate="yes" xml:space="preserve">
          <source>A buffered writer that gobbles any \r characters and replaces every \n with a platform specific newline. In many places Groovy normalises streams to only have \n characters but when creating files that must be used by other platform-aware tools, you sometimes want the newlines to match what the platform expects.</source>
          <target state="translated">\ r 문자를 잡아 먹고 모든 \ n을 플랫폼 별 개행 문자로 대체하는 버퍼링 된 작성기입니다. 많은 곳에서 Groovy는 \ n 문자 만 포함하도록 스트림을 정규화하지만 다른 플랫폼 인식 도구에서 사용해야하는 파일을 만들 때 플랫폼이 기대하는 것과 일치하는 줄 바꿈을 원할 때가 있습니다.</target>
        </trans-unit>
        <trans-unit id="37071e36361dd207b80ec80f4c631c9db0ba8e9b" translate="yes" xml:space="preserve">
          <source>A builder class for creating XML markup. This implementation uses a &lt;a href=&quot;streamingmarkupsupport/streamingmarkupwriter&quot;&gt;StreamingMarkupWriter&lt;/a&gt; to handle output.</source>
          <target state="translated">XML 마크 업을 만들기위한 빌더 클래스입니다. 이 구현은 &lt;a href=&quot;streamingmarkupsupport/streamingmarkupwriter&quot;&gt;StreamingMarkupWriter&lt;/a&gt; 를 사용하여 출력을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="196704e265c29ef2ac1f7794c043f7f9d205f783" translate="yes" xml:space="preserve">
          <source>A builder dedicated at generating a file directory structure from a specification. For example, imagine that you want to create the following tree:</source>
          <target state="translated">사양에서 파일 디렉토리 구조를 생성하기위한 전용 빌더입니다. 예를 들어 다음과 같은 트리를 생성한다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="375479847b2624413e0cd539283ac5d83acd4907" translate="yes" xml:space="preserve">
          <source>A builder for creating JSON payloads.</source>
          <target state="translated">JSON 페이로드를 생성하기위한 빌더입니다.</target>
        </trans-unit>
        <trans-unit id="22bda7e88b9aa6053fe68668e4c3ae3c1551e12e" translate="yes" xml:space="preserve">
          <source>A builder for creating YAML payloads.</source>
          <target state="translated">YAML 페이로드를 생성하기위한 빌더입니다.</target>
        </trans-unit>
        <trans-unit id="c8fd4f81972be3a185ba0e294f3b58b4dea7c2e3" translate="yes" xml:space="preserve">
          <source>A builder for creating object graphs.</source>
          <target state="translated">개체 그래프를 만들기위한 작성기입니다.</target>
        </trans-unit>
        <trans-unit id="f5de7659976ba6471cdf7fc1182f63c9df8c945e" translate="yes" xml:space="preserve">
          <source>A builder for generating W3C SAX events. Use similar to MarkupBuilder.</source>
          <target state="translated">W3C SAX 이벤트 생성을위한 빌더. MarkupBuilder와 유사하게 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2f57815a92a966f2712008f3675834dca3895962" translate="yes" xml:space="preserve">
          <source>A builder that creates &lt;a href=&quot;concurrentlinkedhashmap&quot;&gt;ConcurrentLinkedHashMap&lt;/a&gt; instances.</source>
          <target state="translated">&lt;a href=&quot;concurrentlinkedhashmap&quot;&gt;ConcurrentLinkedHashMap&lt;/a&gt; 인스턴스 를 작성하는 빌더입니다 .</target>
        </trans-unit>
        <trans-unit id="2123d04e60e48402ec738ff707152866443653f4" translate="yes" xml:space="preserve">
          <source>A builder that creates &lt;a href=&quot;concurrentlinkedhashmap&quot;&gt;ConcurrentLinkedHashMap&lt;/a&gt; instances. It provides a flexible approach for constructing customized instances with a named parameter syntax. It can be used in the following manner:</source>
          <target state="translated">&lt;a href=&quot;concurrentlinkedhashmap&quot;&gt;ConcurrentLinkedHashMap&lt;/a&gt; 인스턴스 를 작성하는 빌더입니다 . 명명 된 매개 변수 구문을 사용하여 사용자 지정 인스턴스를 구성하기위한 유연한 접근 방식을 제공합니다. 다음과 같은 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7086f0d376b5977165946afd68e60a54af78baf" translate="yes" xml:space="preserve">
          <source>A builder used to construct a &lt;a href=&quot;jsongenerator&quot;&gt;JsonGenerator&lt;/a&gt; instance that allows control over the serialized JSON output.</source>
          <target state="translated">직렬화 된 JSON 출력을 제어 할 수 있는 &lt;a href=&quot;jsongenerator&quot;&gt;JsonGenerator&lt;/a&gt; 인스턴스 를 구성하는 데 사용되는 빌더 입니다.</target>
        </trans-unit>
        <trans-unit id="abe5c7c988db10802afe3415166036ee9f84951c" translate="yes" xml:space="preserve">
          <source>A builder used to construct a &lt;a href=&quot;jsongenerator&quot;&gt;JsonGenerator&lt;/a&gt; instance that allows control over the serialized JSON output. If you do not need to customize the output it is recommended to use the static &lt;code&gt;JsonOutput.toJson&lt;/code&gt; methods.</source>
          <target state="translated">직렬화 된 JSON 출력을 제어 할 수 있는 &lt;a href=&quot;jsongenerator&quot;&gt;JsonGenerator&lt;/a&gt; 인스턴스 를 구성하는 데 사용되는 빌더 입니다. 출력을 사용자 정의 할 필요가없는 경우 정적 &lt;code&gt;JsonOutput.toJson&lt;/code&gt; 메소드 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="02debaca81049ecaec7f5e501ea8dfbf14115ca9" translate="yes" xml:space="preserve">
          <source>A builder which allows easy configuration of compilation customizers. Instead of creating various compilation customizers by hand, you may use this builder instead, which provides a shorter syntax and removes most of the verbosity.</source>
          <target state="translated">컴파일 커 스터 마이저를 쉽게 구성 할 수있는 빌더. 다양한 컴파일 커 스터 마이저를 직접 만드는 대신이 빌더를 사용하면 더 짧은 구문을 제공하고 대부분의 상세 정보를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c4fbcaf0f1b873f500e728918c1ca7508542115" translate="yes" xml:space="preserve">
          <source>A byte buffer of 4KB is used to be able to guess the encoding.</source>
          <target state="translated">인코딩을 추측 할 수 있도록 4KB의 바이트 버퍼가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="12f8a1287471c3bc65b0f2e80645b0cafde34312" translate="yes" xml:space="preserve">
          <source>A cache backed by a ConcurrentHashMap</source>
          <target state="translated">ConcurrentHashMap에 의해 지원되는 캐시</target>
        </trans-unit>
        <trans-unit id="854b4649f99354918b58d3cb8aa70c9af072f444" translate="yes" xml:space="preserve">
          <source>A cache backed by a ConcurrentLinkedHashMap</source>
          <target state="translated">ConcurrentLinkedHashMap에 의해 지원되는 캐시</target>
        </trans-unit>
        <trans-unit id="3d0acbc6b9ed9f4bfe1fd949da2f9f8e5b9c5fe4" translate="yes" xml:space="preserve">
          <source>A call site writer which replaces call site caching with static calls. This means that the generated code looks more like Java code than dynamic Groovy code. Best effort is made to use JVM instructions instead of calls to helper methods.</source>
          <target state="translated">호출 사이트 캐싱을 정적 호출로 대체하는 호출 사이트 작성기. 이는 생성 된 코드가 동적 Groovy 코드보다 Java 코드와 더 비슷하다는 것을 의미합니다. 도우미 메서드를 호출하는 대신 JVM 명령을 사용하는 것이 최선입니다.</target>
        </trans-unit>
        <trans-unit id="ea2c8bb5c597f9376baff57734bb71adc0b6c144" translate="yes" xml:space="preserve">
          <source>A call-back notification that the entry was evicted.</source>
          <target state="translated">항목이 제거되었다는 콜백 알림입니다.</target>
        </trans-unit>
        <trans-unit id="644874c9963d199cefe921b6c8846031fd98c485" translate="yes" xml:space="preserve">
          <source>A callback for use during &lt;a href=&quot;#classgen&quot;&gt;classgen&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#classgen&quot;&gt;classgen&lt;/a&gt; 동안 사용할 콜백</target>
        </trans-unit>
        <trans-unit id="7a2ebf8813642b6b3333996d45d6f16d4bbd40f0" translate="yes" xml:space="preserve">
          <source>A callback for use during &lt;a href=&quot;#compile()&quot;&gt;compile()&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#compile()&quot;&gt;compile ()&lt;/a&gt; 동안 사용할 콜백</target>
        </trans-unit>
        <trans-unit id="9a54c8114e2bc142a9fbf71fdf7340c2a3930417" translate="yes" xml:space="preserve">
          <source>A callback interface you can use to &quot;accompany&quot; the classgen() code as it traverses the ClassNode tree.</source>
          <target state="translated">ClassNode 트리를 탐색 할 때 classgen () 코드를 &quot;동반&quot;하는 데 사용할 수있는 콜백 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="de71b888e5c52d859660038334ef3ad59c87ef68" translate="yes" xml:space="preserve">
          <source>A callback interface you can use to &quot;accompany&quot; the classgen() code as it traverses the ClassNode tree. You will be called-back for each primary and inner class. Use setClassgenCallback() before running compile() to set your callback.</source>
          <target state="translated">ClassNode 트리를 탐색 할 때 classgen () 코드를 &quot;동반&quot;하는 데 사용할 수있는 콜백 인터페이스입니다. 각 기본 및 내부 클래스에 대해 콜백됩니다. 콜백을 설정하려면 compile ()을 실행하기 전에 setClassgenCallback ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="88f7c07aeb48e979059dc8a6899a5baa06674f94" translate="yes" xml:space="preserve">
          <source>A callback interface you can use to get a callback after every unit of the compile process.</source>
          <target state="translated">컴파일 프로세스의 모든 단위 후에 콜백을 가져 오는 데 사용할 수있는 콜백 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="d4d98a3f5e07706f35330ba6e0e592bad7f828c4" translate="yes" xml:space="preserve">
          <source>A callback interface you can use to get a callback after every unit of the compile process. You will be called-back with a ProcessingUnit and a phase indicator. Use setProgressCallback() before running compile() to set your callback.</source>
          <target state="translated">컴파일 프로세스의 모든 단위 후에 콜백을 가져 오는 데 사용할 수있는 콜백 인터페이스입니다. ProcessingUnit 및 단계 표시기로 콜백됩니다. 콜백을 설정하려면 compile ()을 실행하기 전에 setProgressCallback ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="067d24d81479f807a1014375e849b0fc43f9fd21" translate="yes" xml:space="preserve">
          <source>A candidate as String with additional jansi formatting codes</source>
          <target state="translated">추가 jansi 형식화 코드가있는 문자열 후보</target>
        </trans-unit>
        <trans-unit id="61ed5940f3224898a6105bd2be2e5e7f010a5d81" translate="yes" xml:space="preserve">
          <source>A character range using regex-style syntax can also be used, e.g. here is an example which converts a word from lower to uppercase:</source>
          <target state="translated">정규식 스타일 구문을 사용하는 문자 범위도 사용할 수 있습니다. 예를 들어 다음은 단어를 소문자에서 대문자로 변환하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="059044ec3bb5a6939464bea2ab4820ab7bcd105b" translate="yes" xml:space="preserve">
          <source>A class annotation used to make a class Comparable by (potentially) multiple Comparators. As an example, given this class:</source>
          <target state="translated">(잠재적으로) 여러 비교기에 의해 클래스를 비교할 수 있도록 만드는 데 사용되는 클래스 주석입니다. 예를 들어 다음 클래스가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d482b966db2a339120466d6a90e54f9ddacfa88a" translate="yes" xml:space="preserve">
          <source>A class capturing the builder strategy</source>
          <target state="translated">빌더 전략을 파악하는 클래스</target>
        </trans-unit>
        <trans-unit id="ec6b4d6602a85224decd4c2fa49138768c5e96e4" translate="yes" xml:space="preserve">
          <source>A class code visitor which is capable of remembering the context of the current visit. This makes it easier for subclasses to perform context-dependent transformations, where for example it is necessary to check the parent nodes of an AST node before performing some operations.</source>
          <target state="translated">현재 방문의 컨텍스트를 기억할 수있는 클래스 코드 방문자입니다. 이렇게하면 하위 클래스가 컨텍스트 종속 변환을 쉽게 수행 할 수 있습니다. 예를 들어 일부 작업을 수행하기 전에 AST 노드의 부모 노드를 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="e421e80cc621ea7e2efbcf9a601ecbee03559d3f" translate="yes" xml:space="preserve">
          <source>A class created in this way has the following characteristics:</source>
          <target state="translated">이러한 방식으로 생성 된 클래스에는 다음과 같은 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f041af2949fc2dc6ca31093e82ad5dc9487602d9" translate="yes" xml:space="preserve">
          <source>A class created using &lt;code&gt;@Canonical&lt;/code&gt; has the following characteristics:</source>
          <target state="translated">&lt;code&gt;@Canonical&lt;/code&gt; 을 사용하여 생성 된 클래스 에는 다음과 같은 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="48d605b677136b279aa9574f053805b90628e3fe" translate="yes" xml:space="preserve">
          <source>A class for error messages produced by the parser system.</source>
          <target state="translated">파서 시스템에서 생성 한 오류 메시지에 대한 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="2e808628828fa2bc8ab45c44ca17289994c34660" translate="yes" xml:space="preserve">
          <source>A class for warning messages.</source>
          <target state="translated">경고 메시지를위한 클래스.</target>
        </trans-unit>
        <trans-unit id="1cc5d6a0e6cd81beff0d8c2780f17c319912a9e8" translate="yes" xml:space="preserve">
          <source>A class for which builder methods should be created.</source>
          <target state="translated">작성기 메소드를 작성해야하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="0a1e104c8712a2a0acc1a5ef59a9415236c252a3" translate="yes" xml:space="preserve">
          <source>A class for which builder methods should be created. It will be an error to leave this attribute with its default value for some strategies.</source>
          <target state="translated">작성기 메소드를 작성해야하는 클래스입니다. 일부 전략에 대해이 속성을 기본값으로두면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="940968f0ce94de3c0b3756a58c5d3e3c6cc29139" translate="yes" xml:space="preserve">
          <source>A class that can determine the weight of a value. The total weight threshold is used to determine when an eviction is required.</source>
          <target state="translated">값의 가중치를 결정할 수있는 클래스입니다. 총 중량 임계 값은 퇴거가 필요한시기를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4e2b3cbbc8ed3ef9ade05a9c7641dd6403d50631" translate="yes" xml:space="preserve">
          <source>A class that can determine the weight of an entry. The total weight threshold is used to determine when an eviction is required.</source>
          <target state="translated">항목의 가중치를 결정할 수있는 클래스입니다. 총 중량 임계 값은 퇴거가 필요한시기를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="078fc19a5cb4c4896c0c4acd76c2f24b8006114f" translate="yes" xml:space="preserve">
          <source>A class to write out the optimized statements.</source>
          <target state="translated">최적화 된 문을 작성하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="d26edf4a7eab2a2fc04dfbcc55ea8f18f539ab42" translate="yes" xml:space="preserve">
          <source>A closure hint class is responsible for generating the list of arguments that a closure accepts. Since closures may accept several signatures, &lt;a href=&quot;#getClosureSignatures(org.codehaus.groovy.ast.MethodNode,%20org.codehaus.groovy.control.SourceUnit,%20org.codehaus.groovy.control.CompilationUnit,%20java.lang.String,%20org.codehaus.groovy.ast.ASTNode)&quot;&gt;getClosureSignatures(org.codehaus.groovy.ast.MethodNode, org.codehaus.groovy.control.SourceUnit, org.codehaus.groovy.control.CompilationUnit, String[], org.codehaus.groovy.ast.ASTNode)&lt;/a&gt; should return a list.</source>
          <target state="translated">클로저 힌트 클래스는 클로저가 허용하는 인수 목록을 생성합니다. 클로저는 여러 서명을 받아 들일 수 있으므로 &lt;a href=&quot;#getClosureSignatures(org.codehaus.groovy.ast.MethodNode,%20org.codehaus.groovy.control.SourceUnit,%20org.codehaus.groovy.control.CompilationUnit,%20java.lang.String,%20org.codehaus.groovy.ast.ASTNode)&quot;&gt;getClosureSignatures (org.codehaus.groovy.ast.MethodNode, org.codehaus.groovy.control.SourceUnit, org.codehaus.groovy.control.CompilationUnit, String [], org.codehaus.groovy.ast .ASTNode)&lt;/a&gt; 는 목록을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="cff63fd5f380f97ce837ee8dd95a813c5b3760fb" translate="yes" xml:space="preserve">
          <source>A closure parameter hint class that is convenient if you want to use a String representation of the signature. It makes use of the &lt;a href=&quot;closureparams#options()&quot;&gt;option strings&lt;/a&gt;, where each string corresponds to a single signature.</source>
          <target state="translated">서명의 문자열 표현을 사용하려는 경우 편리한 클로저 매개 변수 힌트 클래스입니다. 각 문자열이 단일 서명에 해당하는 &lt;a href=&quot;closureparams#options()&quot;&gt;옵션 문자열&lt;/a&gt; 을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="b94071c00924ccbd6cbd1898f7ce813d51c291c7" translate="yes" xml:space="preserve">
          <source>A closure passed to a JSON builder will create a root JSON object</source>
          <target state="translated">JSON 빌더에 전달 된 클로저는 루트 JSON 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7e0b5a3c5396eabc3c8a6e082178916100cae060" translate="yes" xml:space="preserve">
          <source>A closure passed to a YAML builder will create a root YAML object</source>
          <target state="translated">YAML 빌더에 전달 된 클로저는 루트 YAML 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4d5554976b4a729557fa907dd94fe3a9dfe14c9d" translate="yes" xml:space="preserve">
          <source>A closure signature hint class is always used in conjunction with the &lt;a href=&quot;closureparams&quot;&gt;ClosureParams&lt;/a&gt; annotation. It is called at compile time (or may be used by IDEs) to infer the types of the parameters of a &lt;a href=&quot;../../lang/closure&quot;&gt;Closure&lt;/a&gt;.</source>
          <target state="translated">클로저 서명 힌트 클래스는 항상 &lt;a href=&quot;closureparams&quot;&gt;ClosureParams&lt;/a&gt; 주석 과 함께 사용됩니다 . &lt;a href=&quot;../../lang/closure&quot;&gt;Closure&lt;/a&gt; 의 매개 변수 유형을 추론하기 위해 컴파일 타임에 호출됩니다 (또는 IDE에서 사용할 수 있음) .</target>
        </trans-unit>
        <trans-unit id="d4df2359d44e5af1c5e761acfa85bf7927d7ba22" translate="yes" xml:space="preserve">
          <source>A closure that takes a single String parameter and returns an object converted to the &lt;code&gt;type&lt;/code&gt; of this option. The picocli equivalent is the &lt;code&gt;&lt;a href=&quot;http://picocli.info/#_custom_type_converters&quot;&gt;ITypeConverter&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="translated">단일 String 매개 변수를 취하고이 옵션 의 &lt;code&gt;type&lt;/code&gt; 으로 변환 된 객체를 반환하는 클로저입니다 . picocli에 해당하는 것은 &lt;code&gt;&lt;a href=&quot;http://picocli.info/#_custom_type_converters&quot;&gt;ITypeConverter&lt;/a&gt;&lt;/code&gt; 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="e6af97a4ec04c4dd66bb788eddff15eb498de448" translate="yes" xml:space="preserve">
          <source>A closure which is executed against the annotated node after the specified phase has completed.</source>
          <target state="translated">지정된 단계가 완료된 후 주석이 달린 노드에 대해 실행되는 클로저입니다.</target>
        </trans-unit>
        <trans-unit id="563b840d5553c0f9fab7d8186fc13f31d7237534" translate="yes" xml:space="preserve">
          <source>A closure which stores calls in a List so that method calls can be iterated over in a 'yield' style way</source>
          <target state="translated">메서드 호출이 'yield'스타일 방식으로 반복 될 수 있도록 호출을 List에 저장하는 클로저</target>
        </trans-unit>
        <trans-unit id="c1f5d6ca9918c4630bceceb50107b9806ba25cce" translate="yes" xml:space="preserve">
          <source>A closure, which will execute the original closure on a trampoline.</source>
          <target state="translated">트램폴린에서 원래의 폐쇄를 실행하는 폐쇄.</target>
        </trans-unit>
        <trans-unit id="df413fa404270092b052f30f111cb0830fed3645" translate="yes" xml:space="preserve">
          <source>A collection and closure passed to a JSON builder will create a root JSON array applying the closure to each object in the collection</source>
          <target state="translated">JSON 빌더에 전달 된 컬렉션 및 클로저는 컬렉션의 각 객체에 클로저를 적용하는 루트 JSON 배열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f1b011fdf8e346e11e590935a91934ae7823ede4" translate="yes" xml:space="preserve">
          <source>A collection and closure passed to a YAML builder will create a root YAML array applying the closure to each object in the collection</source>
          <target state="translated">YAML 빌더에 전달 된 컬렉션 및 클로저는 컬렉션의 각 객체에 클로저를 적용하는 루트 YAML 배열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="dcfdfde3961f78ebf08a0db2ff9de1d891ed5d3b" translate="yes" xml:space="preserve">
          <source>A collection of utility methods used to deal with traits.</source>
          <target state="translated">특성을 처리하는 데 사용되는 유틸리티 메서드 모음입니다.</target>
        </trans-unit>
        <trans-unit id="0d503c58ebfaf207a26b9e19cbb2c8d140ae9b38" translate="yes" xml:space="preserve">
          <source>A colon-separated list of filename extensions to look for when searching for files to process in a given directory.</source>
          <target state="translated">지정된 디렉토리에서 처리 할 파일을 검색 할 때 찾을 콜론으로 구분 된 파일 이름 확장자 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d3805c04fd9a5091d93fb4b4726882770ba99c70" translate="yes" xml:space="preserve">
          <source>A colon-separated list of filename extensions to look for when searching for files to process in a given directory. Default value: &lt;code&gt;.java:.groovy:.gv:.gvy:.gsh&lt;/code&gt;</source>
          <target state="translated">지정된 디렉토리에서 처리 할 파일을 검색 할 때 찾을 콜론으로 구분 된 파일 이름 확장자 목록입니다. 기본값 : &lt;code&gt;.java:.groovy:.gv:.gvy:.gsh&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b370c3389f462e46184d60293fba05f31fb24bc2" translate="yes" xml:space="preserve">
          <source>A common base class of AST helper methods which can be shared across the classic and new parsers</source>
          <target state="translated">클래식 및 새 파서에서 공유 할 수있는 AST 도우미 메서드의 공통 기본 클래스</target>
        </trans-unit>
        <trans-unit id="3f814b778381e7323260fdbd75e768829ede9a78" translate="yes" xml:space="preserve">
          <source>A common set of &lt;a href=&quot;weigher&quot;&gt;Weigher&lt;/a&gt; and &lt;a href=&quot;entryweigher&quot;&gt;EntryWeigher&lt;/a&gt; implementations.</source>
          <target state="translated">의 공통 &lt;a href=&quot;weigher&quot;&gt;계량기&lt;/a&gt; 및 &lt;a href=&quot;entryweigher&quot;&gt;EntryWeigher&lt;/a&gt; 구현.</target>
        </trans-unit>
        <trans-unit id="fb52df3c6e187dbbea466a817c82dfbd0713d61f" translate="yes" xml:space="preserve">
          <source>A completer within compatible strings (single/double quotes, single/double triple quotes) showing informational alternatives that can occur after the backslash escape character. No completion occurs and the cursor remains where it is.</source>
          <target state="translated">백 슬래시 이스케이프 문자 다음에 발생할 수있는 정보 대체를 표시하는 호환되는 문자열 (작은 따옴표 / 큰 따옴표, 작은 따옴표 / 큰 따옴표) 내의 완성 자입니다. 완료가 발생하지 않고 커서는 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="40e56aff842cabfd79cd2de422fbf8843cc0a71f" translate="yes" xml:space="preserve">
          <source>A composite of the supplied list of antlr AST visitors.</source>
          <target state="translated">제공된 antlr AST 방문자 목록의 조합입니다.</target>
        </trans-unit>
        <trans-unit id="6f7561c90678f1159a480ccea2b59622d391b873" translate="yes" xml:space="preserve">
          <source>A constructor call.</source>
          <target state="translated">생성자 호출.</target>
        </trans-unit>
        <trans-unit id="0c9f6f925d0b7e0e574913d5bfef63ff50107189" translate="yes" xml:space="preserve">
          <source>A context shared across generations of a class and its inner classes</source>
          <target state="translated">클래스의 세대와 내부 클래스간에 공유되는 컨텍스트</target>
        </trans-unit>
        <trans-unit id="e0ed530022b745739d66e33a7e6292627f936e74" translate="yes" xml:space="preserve">
          <source>A convenience for getting a default configuration.</source>
          <target state="translated">기본 구성을 가져 오는 데 편리합니다.</target>
        </trans-unit>
        <trans-unit id="70121d7e5d5156cadb2495e7114ac985f146601b" translate="yes" xml:space="preserve">
          <source>A convenience for getting a default configuration. Do not modify it! See &lt;a href=&quot;#CompilerConfiguration(java.util.Properties)&quot;&gt;CompilerConfiguration(Properties)&lt;/a&gt; for an example on how to make a suitable copy to modify. But if you're really starting from a default context, then you probably just want &lt;code&gt;new CompilerConfiguration()&lt;/code&gt;.</source>
          <target state="translated">기본 구성을 가져 오는 데 편리합니다. 수정하지 마십시오! 수정할 적절한 복사본을 만드는 방법에 대한 예제는 &lt;a href=&quot;#CompilerConfiguration(java.util.Properties)&quot;&gt;CompilerConfiguration (Properties)&lt;/a&gt; 을 참조하십시오 . 그러나 실제로 기본 컨텍스트에서 시작하는 경우 &lt;code&gt;new CompilerConfiguration()&lt;/code&gt; 원할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="6120b337ca9056a57ecfd755785b3fa91bc9a3b8" translate="yes" xml:space="preserve">
          <source>A convenience front end for getting standard compilations done. All compile() routines generate classes to the filesystem.</source>
          <target state="translated">표준 컴파일을 수행하기위한 편리한 프런트 엔드. 모든 compile () 루틴은 파일 시스템에 대한 클래스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="88bc7fc40e07517fd61791abbdaa4f144102be6a" translate="yes" xml:space="preserve">
          <source>A convenience method for creating a synchronized Collection.</source>
          <target state="translated">동기화 된 컬렉션을 만드는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="1ed10e3150852e021677b80e1e84b42c685f5e8f" translate="yes" xml:space="preserve">
          <source>A convenience method for creating a synchronized List.</source>
          <target state="translated">동기화 된 목록을 만드는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="82d4dfefd43edec63b5485ceb18e957059a3f4eb" translate="yes" xml:space="preserve">
          <source>A convenience method for creating a synchronized Map.</source>
          <target state="translated">동기화 된지도를 만드는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="1e94f4829d4dcd63e1c679bcb34187f4ca8ba0c1" translate="yes" xml:space="preserve">
          <source>A convenience method for creating a synchronized Set.</source>
          <target state="translated">동기화 된 세트를 생성하는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="c4e801b12f994764eb304c2f9c6abe12b22609ee" translate="yes" xml:space="preserve">
          <source>A convenience method for creating a synchronized SortedMap.</source>
          <target state="translated">동기화 된 SortedMap을 만드는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="fed5927bc30ac8c98de179055e3d3f71391549d7" translate="yes" xml:space="preserve">
          <source>A convenience method for creating a synchronized SortedSet.</source>
          <target state="translated">동기화 된 SortedSet을 만드는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="a713e87d51139260227ee98381677bb3e4ac1c2d" translate="yes" xml:space="preserve">
          <source>A convenience method for creating an immutable Collection.</source>
          <target state="translated">변경 불가능한 컬렉션을 만드는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="664a6f846cb064ed39dabd14364cc6b447ce7d66" translate="yes" xml:space="preserve">
          <source>A convenience method for creating an immutable List.</source>
          <target state="translated">불변 목록을 만드는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="05d98c5b90b5b49432d3de1b3e3d08a0c5cc0f79" translate="yes" xml:space="preserve">
          <source>A convenience method for creating an immutable Map.</source>
          <target state="translated">변경 불가능한지도를 만드는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="5cd220e19cd7507f820298e51e6fe49d094c07d6" translate="yes" xml:space="preserve">
          <source>A convenience method for creating an immutable Set.</source>
          <target state="translated">불변의 집합을 만드는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="bdae694066e5935a0162ff468ecef4b4e4896dc6" translate="yes" xml:space="preserve">
          <source>A convenience method for creating an immutable SortedMap.</source>
          <target state="translated">불변의 SortedMap을 만드는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="3019886ebe4a3cc3132b04150a9df2b6eaf37b4c" translate="yes" xml:space="preserve">
          <source>A convenience method for creating an immutable SortedSet.</source>
          <target state="translated">불변의 SortedSet을 생성하기위한 편리한 방법.</target>
        </trans-unit>
        <trans-unit id="f14fcdc5e8014c9b44e08bb36d6572cb9a20794b" translate="yes" xml:space="preserve">
          <source>A convenience method for making a List unique using a Closure to determine duplicate (equal) items.</source>
          <target state="translated">중복 (동등한) 항목을 결정하기 위해 Closure를 사용하여 목록을 고유하게 만드는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="6f9387902417cbe370094d68ddefabc841e2df9c" translate="yes" xml:space="preserve">
          <source>A convenience method for making a List unique using a Closure to determine duplicate (equal) items. If mutate is true, it works on the receiver object and returns it. If mutate is false, a new collection is returned.</source>
          <target state="translated">중복 (동등한) 항목을 결정하기 위해 Closure를 사용하여 목록을 고유하게 만드는 편리한 방법입니다. mutate가 true이면 수신자 객체에서 작동하고 반환합니다. mutate가 false이면 새 컬렉션이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9380d5542f660c159911db19e127c6dd855dfdff" translate="yes" xml:space="preserve">
          <source>A convenience method for making a collection unique using a Closure to determine duplicate (equal) items.</source>
          <target state="translated">복제 (동일) 항목을 결정하기 위해 Closure를 사용하여 컬렉션을 고유하게 만드는 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d69fd233db45496d6748e496a3eecd5527745f52" translate="yes" xml:space="preserve">
          <source>A convenience method for making a collection unique using a Closure to determine duplicate (equal) items. If mutate is true, it works on the receiver object and returns it. If mutate is false, a new collection is returned.</source>
          <target state="translated">복제 (동일) 항목을 결정하기 위해 Closure를 사용하여 컬렉션을 고유하게 만드는 편리한 방법입니다. mutate가 true이면 수신자 객체에서 작동하고 반환합니다. mutate가 false이면 새 컬렉션이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b19ed6137086dcade9af394c0637d066771c35b8" translate="yes" xml:space="preserve">
          <source>A convenience routine to create a standalone SourceUnit on a String with defaults for almost everything that is configurable.</source>
          <target state="translated">구성 가능한 거의 모든 것에 대한 기본값을 사용하여 문자열에 독립형 SourceUnit을 만드는 편리한 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="2476e5d547ee6ff3aedaf114a440db58f3200b7f" translate="yes" xml:space="preserve">
          <source>A conversion closure to convert the incoming String into the desired object</source>
          <target state="translated">들어오는 문자열을 원하는 객체로 변환하는 변환 클로저</target>
        </trans-unit>
        <trans-unit id="c1dc77d2d47613ba6d742e0c90d5669e1b6a7fce" translate="yes" xml:space="preserve">
          <source>A converter for converting YAML to JSON, vice versa</source>
          <target state="translated">YAML을 JSON으로 또는 그 반대로 변환하기위한 변환기</target>
        </trans-unit>
        <trans-unit id="b0c1e4c37af3456fcac8586639fbdd350f0dd7d2" translate="yes" xml:space="preserve">
          <source>A converter that handles converting a given type using a closure.</source>
          <target state="translated">클로저를 사용하여 주어진 유형의 변환을 처리하는 변환기.</target>
        </trans-unit>
        <trans-unit id="98b3a1922235c40f7f9b0175565038a158e66e4b" translate="yes" xml:space="preserve">
          <source>A custom exception class to flag template execution errors</source>
          <target state="translated">템플릿 실행 오류에 플래그를 지정하는 사용자 지정 예외 클래스</target>
        </trans-unit>
        <trans-unit id="7a73f45add4cd30eb722b295c235ecf078e91088" translate="yes" xml:space="preserve">
          <source>A custom exception class to flag template parsing errors</source>
          <target state="translated">템플릿 구문 분석 오류에 플래그를 지정하는 사용자 지정 예외 클래스</target>
        </trans-unit>
        <trans-unit id="00eee0a2c9ccb20310602adc0b278a83155fe20d" translate="yes" xml:space="preserve">
          <source>A declaration is the creation of a reference or primitive-type variable, or (if arguments are present) of a method.</source>
          <target state="translated">선언은 참조 또는 기본 유형 변수 또는 메서드 (인수가있는 경우)의 생성입니다.</target>
        </trans-unit>
        <trans-unit id="80ed451e75c5c0cdbf65f83560e22c1833daea5e" translate="yes" xml:space="preserve">
          <source>A declaration is the creation of a reference or primitive-type variable, or (if arguments are present) of a method. Generically, this is called a 'variable' definition, even in the case of a class field or method. It may start with the modifiers and/or a declaration keyword &quot;def&quot;. It may also start with the modifiers and a capitalized type name.</source>
          <target state="translated">선언은 참조 또는 기본 유형 변수 또는 메서드 (인수가있는 경우)의 생성입니다. 일반적으로 이것은 클래스 필드 또는 메서드의 경우에도 '변수'정의라고합니다. 수정 자 및 / 또는 선언 키워드 &quot;def&quot;로 시작할 수 있습니다. 수정 자 및 대문자 형식 이름으로 시작할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b59a55812df24ebb2e0abda390b3902c61dcd63b" translate="yes" xml:space="preserve">
          <source>A declaration with one declarator and no initialization, like a parameterDeclaration.</source>
          <target state="translated">parameterDeclaration과 같이 선언자가 하나이고 초기화가없는 선언입니다.</target>
        </trans-unit>
        <trans-unit id="46ad78483e607986854284931bc2418644cf417d" translate="yes" xml:space="preserve">
          <source>A declaration with one declarator and no initialization, like a parameterDeclaration. Used to parse loops like &lt;code&gt;for (int x in y)&lt;/code&gt; (up to the &lt;code&gt;in&lt;/code&gt; keyword).</source>
          <target state="translated">parameterDeclaration과 같이 선언자가 하나이고 초기화가없는 선언입니다. &lt;code&gt;for (int x in y)&lt;/code&gt; ( &lt;code&gt;in&lt;/code&gt; 키워드 까지 ) 와 같은 루프를 구문 분석하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c1ff4388f500955eeae3a9d8ab0e7a0829030996" translate="yes" xml:space="preserve">
          <source>A declaration with one declarator and optional initialization, like a parameterDeclaration.</source>
          <target state="translated">하나의 선언자와 선택적 초기화가있는 선언 (예 : parameterDeclaration).</target>
        </trans-unit>
        <trans-unit id="c93dbb4659ab7de7f3b9939bde8104ca1592ae57" translate="yes" xml:space="preserve">
          <source>A declaration with one declarator and optional initialization, like a parameterDeclaration. Used to parse declarations used for both binding and effect, in places like argument lists and &lt;code&gt;while&lt;/code&gt; statements.</source>
          <target state="translated">하나의 선언자와 선택적 초기화가있는 선언 (예 : parameterDeclaration). 인수 목록 및 &lt;code&gt;while&lt;/code&gt; 문과 같은 위치에서 바인딩 및 효과에 사용되는 선언을 구문 분석하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ecc5bd05491c5684a05f77d659cf72ff7a408d74" translate="yes" xml:space="preserve">
          <source>A default action implementation</source>
          <target state="translated">기본 액션 구현</target>
        </trans-unit>
        <trans-unit id="57a1a035770cab782a9e711cfcc65ba33a1090cd" translate="yes" xml:space="preserve">
          <source>A default implementation of MethodKey</source>
          <target state="translated">MethodKey의 기본 구현</target>
        </trans-unit>
        <trans-unit id="ee26deb6edda438915ebe8f7fe1be6fcba8fb3ed" translate="yes" xml:space="preserve">
          <source>A default implementation of all visitor methods. If you extend this class, any un-overridden visit methods will call visitDefault.</source>
          <target state="translated">모든 방문자 메소드의 기본 구현입니다. 이 클래스를 확장하면 재정의되지 않은 모든 방문 메서드가 visitDefault를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="f31a9fa7f23a008b8efb327b5464caddf05f2cab" translate="yes" xml:space="preserve">
          <source>A default table model made up of PropertyModels on a Value model.</source>
          <target state="translated">값 모델의 PropertyModel로 구성된 기본 테이블 모델입니다.</target>
        </trans-unit>
        <trans-unit id="656385d9b00802c05c25dc45bb5d7d42e6f259c1" translate="yes" xml:space="preserve">
          <source>A delimiter to use to qualify completions.</source>
          <target state="translated">완료를 한정하는 데 사용할 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="d301a0e039a758af5c427534a7e43ab7583fce35" translate="yes" xml:space="preserve">
          <source>A descriptive name of the source unit.</source>
          <target state="translated">소스 장치를 설명하는 이름입니다.</target>
        </trans-unit>
        <trans-unit id="1805e772b4325e3e34a4b81e23684da773789f6f" translate="yes" xml:space="preserve">
          <source>A descriptive name of the source unit. This name shouldn't be used for controlling the SourceUnit, it is only for error messages and to determine the name of the class for a script.</source>
          <target state="translated">소스 장치를 설명하는 이름입니다. 이 이름은 SourceUnit을 제어하는 ​​데 사용해서는 안되며, 오류 메시지와 스크립트의 클래스 이름을 확인하는 데만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="28fc3ccf7160975f5e10f8757a09f74dca7e514a" translate="yes" xml:space="preserve">
          <source>A entry weigher backed by the specified weigher.</source>
          <target state="translated">지정된 계량기가 지원하는 항목 계량기.</target>
        </trans-unit>
        <trans-unit id="62a5cc0e5276e625203458d2a2f52e38abc52566" translate="yes" xml:space="preserve">
          <source>A entry weigher backed by the specified weigher. The weight of the value determines the weight of the entry.</source>
          <target state="translated">지정된 계량기가 지원하는 항목 계량기. 값의 가중치는 항목의 가중치를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="50023fe5879adf02f50065bd34eb300e74589cf8" translate="yes" xml:space="preserve">
          <source>A entry weigher view of the specified weigher.</source>
          <target state="translated">지정된 계량기의 항목 계량기보기.</target>
        </trans-unit>
        <trans-unit id="777d8a3b149b83eb34cc5901b972e432bb2608cf" translate="yes" xml:space="preserve">
          <source>A facade over Java's normal JDBC APIs providing greatly simplified resource management and result set handling. Under the covers the facade hides away details associated with getting connections, constructing and configuring statements, interacting with the connection, closing resources and logging errors. Special features of the facade include using closures to iterate through result sets, a special GString syntax for representing prepared statements and treating result sets like collections of maps with the normal Groovy collection methods available.</source>
          <target state="translated">Java의 일반 JDBC API에 대한 파사드로 매우 단순화 된 리소스 관리 및 결과 집합 처리를 제공합니다. 내부적으로 파사드는 연결 얻기, 명령문 구성 및 구성, 연결과 상호 작용, 리소스 닫기 및 오류 로깅과 관련된 세부 정보를 숨 깁니다. 파사드의 특별한 기능에는 결과 집합을 반복하는 클로저 사용, 준비된 명령문을 나타내는 특수 GString 구문, 사용 가능한 일반 Groovy 수집 방법을 사용하여지도 모음처럼 결과 집합을 처리하는 것이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="70227a2d724ec8ef8243a9d6a678e8bbea91c5a7" translate="yes" xml:space="preserve">
          <source>A factory class conforming to JSR-223 which is used to instantiate Groovy &lt;code&gt;ScriptEngines&lt;/code&gt; and also exposes metadata describing Groovy's engine class. Adapted from original by Mike Grogan and A. Sundararajan</source>
          <target state="translated">Groovy &lt;code&gt;ScriptEngines&lt;/code&gt; 을 인스턴스화하는 데 사용되며 Groovy의 엔진 클래스를 설명하는 메타 데이터도 노출 하는 JSR-223을 준수하는 팩토리 클래스입니다. Mike Grogan과 A. Sundararajan의 원작을 각색했습니다.</target>
        </trans-unit>
        <trans-unit id="673613a12ff6982e89cde6a22c889b1f008e1b60" translate="yes" xml:space="preserve">
          <source>A factory of parser plugin instances.</source>
          <target state="translated">파서 플러그인 인스턴스의 팩토리.</target>
        </trans-unit>
        <trans-unit id="63e53ab72a5ce37b78ac4435291d8bd4286e7a85" translate="yes" xml:space="preserve">
          <source>A file name completer takes the buffer and issues a list of potential completions.</source>
          <target state="translated">파일 이름 완성자는 버퍼를 가져와 잠재적 인 완료 목록을 발행합니다.</target>
        </trans-unit>
        <trans-unit id="ece5f5deadafb2635264d2d3d55d43ac056ccee9" translate="yes" xml:space="preserve">
          <source>A filter to perform on the name of traversed files/directories (using the &lt;a href=&quot;../../../../codehaus/groovy/runtime/defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; method). If set, only files/dirs which match are candidates for visiting. (Must not be set if 'filter' is set)</source>
          <target state="translated">순회 된 파일 / 디렉터리의 이름에 대해 수행 할 필터 ( &lt;a href=&quot;../../../../codehaus/groovy/runtime/defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; 메서드 사용). 설정된 경우 일치하는 파일 / 디렉터리 만 방문 후보입니다. ( '필터'설정시 설정 불가)</target>
        </trans-unit>
        <trans-unit id="d2c488279760fd22739536b17813dd28876ac6fc" translate="yes" xml:space="preserve">
          <source>A filter to perform on the name of traversed files/directories (using the &lt;a href=&quot;defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; method). If set, only files/dirs which match are candidates for visiting. (Must not be set if 'filter' is set)</source>
          <target state="translated">순회 된 파일 / 디렉터리의 이름에 대해 수행 할 필터 ( &lt;a href=&quot;defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; 메서드 사용). 설정된 경우 일치하는 파일 / 디렉터리 만 방문 후보입니다. ( '필터'설정시 설정 불가)</target>
        </trans-unit>
        <trans-unit id="6c7dbf40b0e5c0ec871086e7e6a01b397f972122" translate="yes" xml:space="preserve">
          <source>A filter to perform on the names of traversed files/directories (using the &lt;a href=&quot;../../../../codehaus/groovy/runtime/defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; method). If set, any candidates which match won't be visited. (Must not be set if 'excludeFilter' is set)</source>
          <target state="translated">순회 된 파일 / 디렉터리의 이름에 대해 수행 할 필터 ( &lt;a href=&quot;../../../../codehaus/groovy/runtime/defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; 메서드 사용). 설정되면 일치하는 후보를 방문하지 않습니다. ( 'excludeFilter'가 설정된 경우 설정하지 않아야 함)</target>
        </trans-unit>
        <trans-unit id="ad0a76b2769f248f990df087b8f5792f45d89c6e" translate="yes" xml:space="preserve">
          <source>A filter to perform on the names of traversed files/directories (using the &lt;a href=&quot;defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; method). If set, any candidates which match won't be visited. (Must not be set if 'excludeFilter' is set)</source>
          <target state="translated">순회 된 파일 / 디렉터리의 이름에 대해 수행 할 필터 ( &lt;a href=&quot;defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; 메서드 사용). 설정되면 일치하는 후보를 방문하지 않습니다. ( 'excludeFilter'가 설정된 경우 설정하지 않아야 함)</target>
        </trans-unit>
        <trans-unit id="214858a9e7487edd41d69e54c54dd93b1e145ab5" translate="yes" xml:space="preserve">
          <source>A filter to perform on traversed files/directories (using the &lt;a href=&quot;../../../../codehaus/groovy/runtime/defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; method). If set, any candidates which match won't be visited.</source>
          <target state="translated">순회 된 파일 / 디렉터리에서 수행 할 필터 ( &lt;a href=&quot;../../../../codehaus/groovy/runtime/defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; 메서드 사용). 설정되면 일치하는 후보를 방문하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28536e7e06aebc7f874a7778fc6501949cd435ce" translate="yes" xml:space="preserve">
          <source>A filter to perform on traversed files/directories (using the &lt;a href=&quot;../../../../codehaus/groovy/runtime/defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; method). If set, only files/dirs which match are candidates for visiting.</source>
          <target state="translated">순회 된 파일 / 디렉터리에서 수행 할 필터 ( &lt;a href=&quot;../../../../codehaus/groovy/runtime/defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; 메서드 사용). 설정된 경우 일치하는 파일 / 디렉터리 만 방문 후보입니다.</target>
        </trans-unit>
        <trans-unit id="ec163ebb50ebade16a04ce89e8f9452dbc973800" translate="yes" xml:space="preserve">
          <source>A filter to perform on traversed files/directories (using the &lt;a href=&quot;defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; method). If set, any candidates which match won't be visited.</source>
          <target state="translated">순회 된 파일 / 디렉터리에서 수행 할 필터 ( &lt;a href=&quot;defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; 메서드 사용). 설정되면 일치하는 후보를 방문하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="886f57d612097ffc91dde66b6fdc6f6af313df00" translate="yes" xml:space="preserve">
          <source>A filter to perform on traversed files/directories (using the &lt;a href=&quot;defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; method). If set, only files/dirs which match are candidates for visiting.</source>
          <target state="translated">순회 된 파일 / 디렉터리에서 수행 할 필터 ( &lt;a href=&quot;defaultgroovymethods#isCase(java.lang.Object,%20java.lang.Object)&quot;&gt;DefaultGroovyMethods.isCase&lt;/a&gt; 메서드 사용). 설정된 경우 일치하는 파일 / 디렉터리 만 방문 후보입니다.</target>
        </trans-unit>
        <trans-unit id="a9175fa564b132eb44558707c3cfe366ecb98ec5" translate="yes" xml:space="preserve">
          <source>A fire method is created for each public method in the target class. In this case, ActionListener only has one method. For a four method interface, four fire methods would be created.</source>
          <target state="translated">대상 클래스의 각 공용 메서드에 대해 화재 메서드가 생성됩니다. 이 경우 ActionListener에는 하나의 메서드 만 있습니다. 4 개의 메소드 인터페이스의 경우 4 개의 화재 메소드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2db385eead8036a69ca3b4b93e7cc0fa07498d80" translate="yes" xml:space="preserve">
          <source>A formal parameter for a method or closure.</source>
          <target state="translated">메서드 또는 클로저의 형식 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="5e332bb31edde77e1eabb07df6daea00dd5e8c8b" translate="yes" xml:space="preserve">
          <source>A front-end class for &lt;a href=&quot;../../classgen/asm/expressionasvariableslot&quot;&gt;ExpressionAsVariableSlot&lt;/a&gt; which allows defining temporary variables loaded from variable slots directly at the AST level, without any knowledge of &lt;a href=&quot;../../classgen/asmclassgenerator&quot;&gt;AsmClassGenerator&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../classgen/asmclassgenerator&quot;&gt;AsmClassGenerator에&lt;/a&gt; 대한 지식 없이도 AST 수준에서 직접 변수 슬롯에서로드 된 임시 변수를 정의 할 수있는 &lt;a href=&quot;../../classgen/asm/expressionasvariableslot&quot;&gt;ExpressionAsVariableSlot&lt;/a&gt; 의 프런트 엔드 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="56c8f33ce11d786ae0e1f3aa22278e14055ef1d1" translate="yes" xml:space="preserve">
          <source>A generic servlet for serving (mostly HTML) templates.</source>
          <target state="translated">템플릿 (대부분 HTML)을 제공하기위한 일반 서블릿입니다.</target>
        </trans-unit>
        <trans-unit id="fb7052944c216d36a53641abd32960dd9fdb76a7" translate="yes" xml:space="preserve">
          <source>A handle for the MetaClassRegistry that changes all classes loaded into the Grails VM to use ExpandoMetaClass instances</source>
          <target state="translated">ExpandoMetaClass 인스턴스를 사용하기 위해 Grails VM에로드 된 모든 클래스를 변경하는 MetaClassRegistry에 대한 핸들</target>
        </trans-unit>
        <trans-unit id="2b93c2fe4402d9dfc915b489be117eed7c89a29a" translate="yes" xml:space="preserve">
          <source>A hash table supporting full concurrency of retrievals, adjustable expected concurrency for updates, and a maximum capacity to bound the map by. This implementation differs from &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt; in that it maintains a page replacement algorithm that is used to evict an entry when the map has exceeded its capacity. Unlike the</source>
          <target state="translated">검색의 전체 동시성, 업데이트에 대한 조정 가능한 예상 동시성 및 맵을 바인딩 할 최대 용량을 지원하는 해시 테이블입니다. 이 구현은 맵이 용량을 초과 할 때 항목을 제거하는 데 사용되는 페이지 교체 알고리즘을 유지한다는 점에서 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html&quot;&gt;ConcurrentHashMap&lt;/a&gt; 과 다릅니다 . 달리</target>
        </trans-unit>
        <trans-unit id="3f24e19e7f727b8f15909919be6516b9f5e8e4db" translate="yes" xml:space="preserve">
          <source>A hash table that supports mostly-concurrent reading, but exclusive writing. Because reads are not limited to periods without writes, a concurrent reader policy is weaker than a classic reader/writer policy, but is generally faster and allows more concurrency. This class is a good choice especially for tables that are mainly created by one thread during the start-up phase of a program, and from then on, are mainly read (with perhaps occasional additions or removals) in many threads. If you also need concurrency among writes, consider instead using ConcurrentHashMap.</source>
          <target state="translated">대부분 동시 읽기를 지원하지만 독점 쓰기를 지원하는 해시 테이블입니다. 읽기는 쓰기가없는 기간으로 제한되지 않기 때문에 동시 읽기 정책은 기존 읽기 / 쓰기 정책보다 약하지만 일반적으로 더 빠르고 더 많은 동시성을 허용합니다. 이 클래스는 프로그램의 시작 단계에서 주로 하나의 스레드에 의해 생성되고 그 이후로 많은 스레드에서 주로 읽기 (가끔 추가 또는 제거)되는 테이블에 특히 적합합니다. 쓰기간에 동시성이 필요한 경우 대신 ConcurrentHashMap을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d1b0330bb6e02b7ea16bdfe9a86b3414332d7b08" translate="yes" xml:space="preserve">
          <source>A helper class for MarkupBuilder.</source>
          <target state="translated">MarkupBuilder의 도우미 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="7b6b88ea73f43583501233c928accb1302e79811" translate="yes" xml:space="preserve">
          <source>A helper class for bytecode generation with AsmClassGenerator.</source>
          <target state="translated">AsmClassGenerator를 사용한 바이트 코드 생성을위한 도우미 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="383832fb3a967c00668a7084b98117b2453fb543" translate="yes" xml:space="preserve">
          <source>A helper class for creating Swing widgets using GroovyMarkup</source>
          <target state="translated">GroovyMarkup을 사용하여 Swing 위젯을 만들기위한 도우미 클래스</target>
        </trans-unit>
        <trans-unit id="1ac258756e3852c95c826247610ee4419a813f37" translate="yes" xml:space="preserve">
          <source>A helper class for creating XML or HTML markup. The builder supports various 'pretty printed' formats.</source>
          <target state="translated">XML 또는 HTML 마크 업을 만들기위한 도우미 클래스입니다. 빌더는 다양한 '예쁜 인쇄'형식을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8c738ab31782d2a9b2a749c575d130a68b367694" translate="yes" xml:space="preserve">
          <source>A helper class for creating a W3C DOM tree</source>
          <target state="translated">W3C DOM 트리를 만들기위한 도우미 클래스</target>
        </trans-unit>
        <trans-unit id="9543d01ed8fe1436f1ce7257b40bf7c0486d6600" translate="yes" xml:space="preserve">
          <source>A helper class for creating namespaced GroovyMarkup</source>
          <target state="translated">네임 스페이스 GroovyMarkup을 만들기위한 도우미 클래스</target>
        </trans-unit>
        <trans-unit id="ec0f88810b56dd3174795b6f58a0ad2906945c73" translate="yes" xml:space="preserve">
          <source>A helper class for creating namespaces for GroovyMarkup</source>
          <target state="translated">GroovyMarkup 용 네임 스페이스를 생성하기위한 도우미 클래스</target>
        </trans-unit>
        <trans-unit id="04190600bbcd3f19f6ffbd27edf8a76306a1207f" translate="yes" xml:space="preserve">
          <source>A helper class for creating nested trees of Node objects for handling arbitrary data</source>
          <target state="translated">임의의 데이터를 처리하기 위해 Node 객체의 중첩 된 트리를 생성하기위한 도우미 클래스</target>
        </trans-unit>
        <trans-unit id="6a2a426dbd8d909b89fa2a8c12a11375f2de244e" translate="yes" xml:space="preserve">
          <source>A helper class for creating nested trees of data</source>
          <target state="translated">중첩 된 데이터 트리를 만들기위한 도우미 클래스</target>
        </trans-unit>
        <trans-unit id="1e07801545a723fc6f9eb641f0d618268b60bb88" translate="yes" xml:space="preserve">
          <source>A helper class for parsing XML into a tree of Node instances for a simple way of processing XML. This parser does not preserve the XML InfoSet - if that's what you need try using W3C DOM, dom4j, JDOM, XOM etc. This parser ignores comments and processing instructions and converts the XML into a Node for each element in the XML with attributes and child Nodes and Strings. This simple model is sufficient for most simple use cases of processing XML.</source>
          <target state="translated">XML을 처리하는 간단한 방법을 위해 XML을 Node 인스턴스 트리로 구문 분석하는 도우미 클래스입니다. 이 구문 분석기는 XML InfoSet을 보존하지 않습니다. 필요한 경우 W3C DOM, dom4j, JDOM, XOM 등을 사용해보십시오.이 구문 분석기는 주석 및 처리 지침을 무시하고 XML의 각 요소에 대한 XML을 속성 및 하위 항목에 대한 노드로 변환합니다. 노드와 문자열. 이 간단한 모델은 XML 처리의 가장 간단한 사용 사례에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="8c37ebfef1f601b113eeaef75a2164fd7cb2694c" translate="yes" xml:space="preserve">
          <source>A helper class for printing indented text. This can be used stand-alone or, more commonly, from Builders.</source>
          <target state="translated">들여 쓰기 된 텍스트를 인쇄하기위한 도우미 클래스입니다. 이것은 독립 실행 형으로 또는 더 일반적으로 빌더에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="546c2664a1a30e402306acf350038050ef574563" translate="yes" xml:space="preserve">
          <source>A helper class for sorting objects via a closure to return the field or operation on which to sort.</source>
          <target state="translated">정렬 할 필드 또는 작업을 반환하기 위해 클로저를 통해 개체를 정렬하는 도우미 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="2ea8552ec77a2d9aa2a2542ba78c331ce83a006f" translate="yes" xml:space="preserve">
          <source>A helper class to allow parser exceptions to be thrown anywhere in the code. Should be replaced when no longer required.</source>
          <target state="translated">파서 예외가 코드의 어느 곳에서나 throw 될 수 있도록하는 도우미 클래스입니다. 더 이상 필요하지 않을 때 교체해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f23bacbe522207d2cd4382803c3ded9260090b8" translate="yes" xml:space="preserve">
          <source>A helper class to invoke methods more easily in ASM</source>
          <target state="translated">ASM에서보다 쉽게 ​​메서드를 호출하는 도우미 클래스</target>
        </trans-unit>
        <trans-unit id="4cd30db1ff2b01b7d1e1e613b88ab879da2eabf5" translate="yes" xml:space="preserve">
          <source>A helper class used to generate bytecode for method pointer expressions.</source>
          <target state="translated">메서드 포인터 식에 대한 바이트 코드를 생성하는 데 사용되는 도우미 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="5f96d6d01238d35651c09ec502ae7f8541b5e02d" translate="yes" xml:space="preserve">
          <source>A helper class used to generate bytecode for method reference expressions.</source>
          <target state="translated">메서드 참조 식에 대한 바이트 코드를 생성하는 데 사용되는 도우미 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="bc075b8633c99d759315fd8a8d7414b363ef0c2d" translate="yes" xml:space="preserve">
          <source>A helper class used to generate bytecode for unary expressions. AST transformations willing to use a custom unary expression helper may set the &lt;a href=&quot;writercontrollerfactory&quot;&gt;WriterControllerFactory&lt;/a&gt; node metadata on a class node to provide a custom &lt;a href=&quot;writercontroller&quot;&gt;WriterController&lt;/a&gt; which would in turn use a custom expression helper.</source>
          <target state="translated">단항 표현식에 대한 바이트 코드를 생성하는 데 사용되는 도우미 클래스입니다. 사용자 지정 단항 식 도우미를 사용하려는 AST 변환 은 클래스 노드에 &lt;a href=&quot;writercontrollerfactory&quot;&gt;WriterControllerFactory&lt;/a&gt; 노드 메타 데이터를 설정하여 사용자 지정 식 도우미를 사용하는 사용자 지정 &lt;a href=&quot;writercontroller&quot;&gt;WriterController&lt;/a&gt; 를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3c5476ba96261d0e1e771852aaf2d8cfa285ef7" translate="yes" xml:space="preserve">
          <source>A helper class used to resolve references found in ASM-decompiled classes.</source>
          <target state="translated">ASM 디 컴파일 된 클래스에서 발견 된 참조를 해결하는 데 사용되는 도우미 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="38ca23034a46f3810b748d5d1c38947aca1661fe" translate="yes" xml:space="preserve">
          <source>A helper constructor used in main(String[]) method calls</source>
          <target state="translated">main (String []) 메서드 호출에 사용되는 도우미 생성자</target>
        </trans-unit>
        <trans-unit id="be8b50a9a7032d331568035557985d1c82bef048" translate="yes" xml:space="preserve">
          <source>A helper interface for factories which require post processing of generated nodes.</source>
          <target state="translated">생성 된 노드의 사후 처리가 필요한 공장을위한 도우미 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="8e23e085b655dc45f1aa42bfc4ebd9b91edbf7e2" translate="yes" xml:space="preserve">
          <source>A helper method so that dynamic dispatch of the writer.write(object) method will always use the more efficient Writable.writeTo(writer) mechanism if the object implements the Writable interface.</source>
          <target state="translated">객체가 Writable 인터페이스를 구현하는 경우 writer.write (object) 메서드의 동적 디스패치가 항상 더 효율적인 Writable.writeTo (writer) 메커니즘을 사용하도록하는 도우미 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="92b8c70aec7c18d9c704ed2ac9b07946362928c3" translate="yes" xml:space="preserve">
          <source>A helper method that can be used to evaluate expressions as found in annotation parameters.</source>
          <target state="translated">주석 매개 변수에있는 표현식을 평가하는 데 사용할 수있는 도우미 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="24746b26f63c969b64972b6f72482c2038ae41b6" translate="yes" xml:space="preserve">
          <source>A helper method that can be used to evaluate expressions as found in annotation parameters. For example, it will evaluate a constant, be it referenced directly as an integer or as a reference to a field.</source>
          <target state="translated">주석 매개 변수에있는 표현식을 평가하는 데 사용할 수있는 도우미 메서드입니다. 예를 들어 정수 또는 필드에 대한 참조로 직접 참조되는 상수를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="a6fa8c447b2705ac2690f9c28f3fe586950a4ad9" translate="yes" xml:space="preserve">
          <source>A helper method to allow GPathResults to work with subscript operators</source>
          <target state="translated">GPathResults가 첨자 연산자와 함께 작동하도록하는 도우미 메서드</target>
        </trans-unit>
        <trans-unit id="a86aedd91cee6c6fb9ace62c0f6745772bdca0d9" translate="yes" xml:space="preserve">
          <source>A helper method to allow lists to work with subscript operators.</source>
          <target state="translated">목록이 아래 첨자 연산자와 함께 작동하도록하는 도우미 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="d08155ea6a4402bc468e3748f311a97c85cbb2e8" translate="yes" xml:space="preserve">
          <source>A helper method to allow maps to work with subscript operators</source>
          <target state="translated">지도가 아래 첨자 연산자와 함께 작동하도록하는 도우미 메서드</target>
        </trans-unit>
        <trans-unit id="60e1c630db9f489019ae61431e6b954856e0692f" translate="yes" xml:space="preserve">
          <source>A helper method to allow scripts to be run taking command line arguments</source>
          <target state="translated">명령 줄 인수를 사용하여 스크립트를 실행할 수있는 도우미 메서드</target>
        </trans-unit>
        <trans-unit id="6f06ad03f6413a84924c37a31b69a829cd37dca7" translate="yes" xml:space="preserve">
          <source>A helper method to allow the dynamic evaluation of groovy expressions using this scripts binding as the variable scope</source>
          <target state="translated">이 스크립트 바인딩을 변수 범위로 사용하여 그루비 표현식의 동적 평가를 허용하는 도우미 메서드</target>
        </trans-unit>
        <trans-unit id="34d82f89a5ad5ac60cffc9420f8d3632d5ab4207" translate="yes" xml:space="preserve">
          <source>A helper method to format the arguments types as a comma-separated list.</source>
          <target state="translated">인수 유형을 쉼표로 구분 된 목록으로 형식화하는 도우미 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="eb622eebefc8a341546ee9f6c36121cd6f220629" translate="yes" xml:space="preserve">
          <source>A helper method to parse the given text as XML</source>
          <target state="translated">주어진 텍스트를 XML로 구문 분석하는 도우미 메서드</target>
        </trans-unit>
        <trans-unit id="72447eea8bc4b4026a3073738c21c25c4c001a57" translate="yes" xml:space="preserve">
          <source>A helper method to parse the given text as XML.</source>
          <target state="translated">주어진 텍스트를 XML로 구문 분석하는 도우미 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="5fa052027018c857fb445645adfd448fd7543f91" translate="yes" xml:space="preserve">
          <source>A helper method to return the string representation of a list with bracket boundaries &quot;[&quot; and &quot;]&quot;.</source>
          <target state="translated">대괄호 경계 &quot;[&quot;및 &quot;]&quot;가있는 목록의 문자열 표현을 반환하는 도우미 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="b363f4f9577d9a9a111029fa36a953d5da47f80e" translate="yes" xml:space="preserve">
          <source>A helper method to return the string representation of a map with bracket boundaries &quot;[&quot; and &quot;]&quot;.</source>
          <target state="translated">대괄호 경계 &quot;[&quot;및 &quot;]&quot;가있는 맵의 문자열 표현을 반환하는 도우미 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="0076e37b531516c7e8519c622ba7e0cb0ed79609" translate="yes" xml:space="preserve">
          <source>A helper method to return the string representation of an array of objects with brace boundaries &quot;[&quot; and &quot;]&quot;.</source>
          <target state="translated">중괄호 경계 &quot;[&quot;및 &quot;]&quot;가있는 개체 배열의 문자열 표현을 반환하는 도우미 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="dc92d004528207f590124125ba9876f1c0461665" translate="yes" xml:space="preserve">
          <source>A helper method which determines which receiver class should be used in error messages when a field or attribute is not found.</source>
          <target state="translated">필드 또는 속성을 찾을 수 없을 때 오류 메시지에 사용해야하는 수신자 클래스를 결정하는 도우미 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="6a29662b470b5d10cb2498623c48bc9f57f0a1b8" translate="yes" xml:space="preserve">
          <source>A helper method which determines which receiver class should be used in error messages when a field or attribute is not found. The returned type class depends on whether we have temporary type information available (due to instanceof checks) and whether there is a single candidate in that case.</source>
          <target state="translated">필드 또는 속성을 찾을 수 없을 때 오류 메시지에 사용해야하는 수신자 클래스를 결정하는 도우미 메서드입니다. 반환 된 유형 클래스는 (instanceof 검사로 인해) 임시 유형 정보를 사용할 수 있는지 여부와이 경우 단일 후보가 있는지 여부에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="718dbbe4f31fcdaa75021f4fee09f3f145f2e5bd" translate="yes" xml:space="preserve">
          <source>A helper method which runs the given cl script with the given command line arguments</source>
          <target state="translated">주어진 명령 줄 인수로 주어진 cl 스크립트를 실행하는 도우미 메서드</target>
        </trans-unit>
        <trans-unit id="cb88f36b947274cdda095aeec79572c947f01f8c" translate="yes" xml:space="preserve">
          <source>A helper method which runs the given script file with the given command line arguments</source>
          <target state="translated">주어진 명령 줄 인수로 주어진 스크립트 파일을 실행하는 도우미 메서드</target>
        </trans-unit>
        <trans-unit id="3198f41213761751d28c72937f36acfd54b2eaff" translate="yes" xml:space="preserve">
          <source>A helper method which will extract the n-th generic type from a class node.</source>
          <target state="translated">클래스 노드에서 n 번째 제네릭 유형을 추출하는 도우미 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="28ddd89a5d15de3a34b1e06cac9ff470ebb4d178" translate="yes" xml:space="preserve">
          <source>A helper method which will extract the n-th generic type from the n-th parameter of a method node.</source>
          <target state="translated">메소드 노드의 n 번째 매개 변수에서 n 번째 제네릭 유형을 추출하는 도우미 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="a4d2fe18222f52010efdc15b06030f2731cb5397" translate="yes" xml:space="preserve">
          <source>A hint used to instruct the type checker to pick the first generic type of the first parameter type. For example:</source>
          <target state="translated">유형 검사기에 첫 번째 매개 변수 유형의 첫 번째 제네릭 유형을 선택하도록 지시하는 데 사용되는 힌트입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="b6c3cc4c8db4a4774f08f38b71ba6bdee47ac68b" translate="yes" xml:space="preserve">
          <source>A hint used to instruct the type checker to pick the first generic type of the second parameter type. For example:</source>
          <target state="translated">두 번째 매개 변수 유형의 첫 번째 제네릭 유형을 선택하도록 유형 검사기에 지시하는 데 사용되는 힌트입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="3966ac1e28662d2c187a3391ee5610d386d85dd1" translate="yes" xml:space="preserve">
          <source>A hint used to instruct the type checker to pick the first generic type of the third parameter type. For example:</source>
          <target state="translated">세 번째 매개 변수 유형의 첫 번째 제네릭 유형을 선택하도록 유형 검사기에 지시하는 데 사용되는 힌트입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="6b8fe834307cc58e6b15a3dd308819d5799f283a" translate="yes" xml:space="preserve">
          <source>A hint used to instruct the type checker to pick the first parameter type. For example:</source>
          <target state="translated">유형 검사기에 첫 번째 매개 변수 유형을 선택하도록 지시하는 데 사용되는 힌트입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="c9491b84294af2ffdced8238f03045c8ceb862fd" translate="yes" xml:space="preserve">
          <source>A hint used to instruct the type checker to pick the second generic type of the first parameter type. For example:</source>
          <target state="translated">유형 검사기에 첫 번째 매개 변수 유형의 두 번째 제네릭 유형을 선택하도록 지시하는 데 사용되는 힌트입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="93d66101be0450edaec84541d773755f3171e64a" translate="yes" xml:space="preserve">
          <source>A hint used to instruct the type checker to pick the second generic type of the second parameter type. For example:</source>
          <target state="translated">두 번째 매개 변수 유형의 두 번째 제네릭 유형을 선택하도록 유형 검사기에 지시하는 데 사용되는 힌트입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="81b93933680b5d1b78bbd15014bf5eb2bfe9f7d9" translate="yes" xml:space="preserve">
          <source>A hint used to instruct the type checker to pick the second generic type of the third parameter type. For example:</source>
          <target state="translated">세 번째 매개 변수 유형의 두 번째 제네릭 유형을 선택하도록 유형 검사기에 지시하는 데 사용되는 힌트입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="ee5900695de2a7db36021fc97286bf6980da1af0" translate="yes" xml:space="preserve">
          <source>A hint used to instruct the type checker to pick the second parameter type. For example:</source>
          <target state="translated">유형 검사기에 두 번째 매개 변수 유형을 선택하도록 지시하는 데 사용되는 힌트입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="285248f5950ef1c4cbb947f9f6a138161e138b63" translate="yes" xml:space="preserve">
          <source>A hint used to instruct the type checker to pick the third generic type of the first parameter type. For example:</source>
          <target state="translated">유형 검사기에 첫 번째 매개 변수 유형의 세 번째 제네릭 유형을 선택하도록 지시하는 데 사용되는 힌트입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="d3dee737e4b11703a623cae392e33d7dad4b4ee5" translate="yes" xml:space="preserve">
          <source>A hint used to instruct the type checker to pick the third parameter type. For example:</source>
          <target state="translated">유형 검사기에 세 번째 매개 변수 유형을 선택하도록 지시하는 데 사용되는 힌트입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="d546afc5c78f709e216ba217c1e3cb448e92d193" translate="yes" xml:space="preserve">
          <source>A hint used to instruct the type checker to pick the type of the component of the first parameter type, which is therefore expected to be an array, like in this example:</source>
          <target state="translated">다음 예제와 같이 배열이 될 것으로 예상되는 첫 번째 매개 변수 유형의 구성 요소 유형을 선택하도록 유형 검사기에 지시하는 데 사용되는 힌트입니다.</target>
        </trans-unit>
        <trans-unit id="8ee53f82a8f2ac89d4319bf40f9c8347055f78a6" translate="yes" xml:space="preserve">
          <source>A hint used to instruct the type checker to pick the type of the component of the second parameter type, which is therefore expected to be an array, like in this example:</source>
          <target state="translated">두 번째 매개 변수 유형의 구성 요소 유형을 선택하도록 유형 검사기에 지시하는 데 사용되는 힌트입니다. 따라서 다음 예제와 같이 배열이 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="807f3643d42c99a8f8e8af4910cd1d1fca1441b9" translate="yes" xml:space="preserve">
          <source>A hint used to instruct the type checker to pick the type of the component of the third parameter type, which is therefore expected to be an array, like in this example:</source>
          <target state="translated">세 번째 매개 변수 유형의 구성 요소 유형을 선택하도록 유형 검사기에 지시하는 데 사용되는 힌트입니다. 따라서 다음 예제와 같이 배열이 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="4e62746af1851e2ea5732ed769a48bd085cb7d40" translate="yes" xml:space="preserve">
          <source>A hook after the factory creates the node and before attributes are set.</source>
          <target state="translated">공장에서 노드를 생성 한 후 속성이 설정되기 전의 후크입니다.</target>
        </trans-unit>
        <trans-unit id="14c4570e6d85cb35df76e47e7ada7d1639f5cbe6" translate="yes" xml:space="preserve">
          <source>A hook before the factory creates the node.</source>
          <target state="translated">공장에서 노드를 만들기 전의 후크.</target>
        </trans-unit>
        <trans-unit id="76bb05085a1f72c43221442d5987702a65b92765" translate="yes" xml:space="preserve">
          <source>A hook to allow names to be converted into some other object such as a QName in XML or ObjectName in JMX.</source>
          <target state="translated">이름을 XML의 QName 또는 JMX의 ObjectName과 같은 다른 객체로 변환 할 수 있도록하는 후크입니다.</target>
        </trans-unit>
        <trans-unit id="c9d164296acdcc27c1011ed81e619caea16c40a5" translate="yes" xml:space="preserve">
          <source>A hook to allow nodes to be processed once they have had all of their children applied and allows the actual node object that represents the Markup element to be changed.</source>
          <target state="translated">모든 자식이 적용된 후 노드를 처리 할 수 ​​있도록하는 후크이며 Markup 요소를 나타내는 실제 노드 개체를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="caaf4964f485842a4188e32fb85c6d5fff92fdda" translate="yes" xml:space="preserve">
          <source>A hook to allow nodes to be processed once they have had all of their children applied.</source>
          <target state="translated">모든 자식이 적용된 후 노드를 처리 할 수 ​​있도록하는 후크입니다.</target>
        </trans-unit>
        <trans-unit id="54cf3a8607b16cb16c3437e803e15eff087a774c" translate="yes" xml:space="preserve">
          <source>A java.util.Properties instance</source>
          <target state="translated">java.util.Properties 인스턴스</target>
        </trans-unit>
        <trans-unit id="0172f03e800c543a900733523c8c1a6b6dbdc314" translate="yes" xml:space="preserve">
          <source>A label for an argument is of the form a:b, 'a':b, &quot;a&quot;:b, (a):b, etc..</source>
          <target state="translated">인수에 대한 레이블은 a : b, 'a': b, &quot;a&quot;: b, (a) : b 등의 형식입니다.</target>
        </trans-unit>
        <trans-unit id="e41d6356e837f238bafe7234863d7bd4e95d0573" translate="yes" xml:space="preserve">
          <source>A label for an argument is of the form a:b, 'a':b, &quot;a&quot;:b, (a):b, etc.. The labels in (a:b), ('a':b), and (&quot;a&quot;:b) are in all ways equivalent, except that the quotes allow more spellings. Equivalent dynamically computed labels are (('a'):b) and (&quot;${'a'}&quot;:b) but not ((a):b) or &quot;$a&quot;:b, since the latter cases evaluate (a) as a normal identifier. Bottom line: If you want a truly variable label, use parens and say ((a):b).</source>
          <target state="translated">인수의 레이블은 a : b, 'a': b, &quot;a&quot;: b, (a) : b 등의 형식입니다. (a : b), ( 'a': b)의 레이블 , 및 ( &quot;a&quot;: b)는 따옴표가 더 많은 철자를 허용한다는 점을 제외하고는 모든면에서 동일합니다. 동적으로 계산 된 동등한 레이블은 (( 'a') : b) 및 ( &quot;$ { 'a'}&quot;: b)이지만 ((a) : b) 또는 &quot;$ a&quot;: b는 아닙니다. a) 일반 식별자로. 결론 : 진정한 가변 레이블을 원한다면 괄호를 사용하고 ((a) : b)라고 말하십시오.</target>
        </trans-unit>
        <trans-unit id="ebd4fe3592548ee9feb253ae90d387d0f47898a8" translate="yes" xml:space="preserve">
          <source>A labeled statement, consisting of a vanilla identifier followed by a colon.</source>
          <target state="translated">바닐라 식별자와 콜론으로 구성된 레이블이있는 문.</target>
        </trans-unit>
        <trans-unit id="7aabf00154960409248cac7e5ee25d4f6adc2935" translate="yes" xml:space="preserve">
          <source>A list constructor is a argument list enclosed in square brackets, without labels.</source>
          <target state="translated">목록 생성자는 레이블없이 대괄호로 묶인 인수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="5acfe53d3ecb1d72b65b2c133d3b230ec0f35775" translate="yes" xml:space="preserve">
          <source>A list constructor is a argument list enclosed in square brackets, without labels. Any argument can be decorated with a spread operator (*x), but not a label (a:x). Examples: [], [1], [1,2], [1,*l1,2], [*l1,*l2]. (The l1, l2 must be a sequence or null.)</source>
          <target state="translated">목록 생성자는 레이블없이 대괄호로 묶인 인수 목록입니다. 모든 인수는 스프레드 연산자 (* x)로 데코 레이팅 할 수 있지만 레이블 (a : x)은 사용할 수 없습니다. 예 : [], [1], [1,2], [1, * l1,2], [* l1, * l2]. (l1, l2는 시퀀스이거나 널이어야합니다.)</target>
        </trans-unit>
        <trans-unit id="1505463a05cfe016b12b533c9b537ed5333fcdb5" translate="yes" xml:space="preserve">
          <source>A list of MetaMethod instances</source>
          <target state="translated">MetaMethod 인스턴스 목록</target>
        </trans-unit>
        <trans-unit id="1d61df2bfbfa8dc437b1aedcbd9955190d89417b" translate="yes" xml:space="preserve">
          <source>A list of MetaMethods</source>
          <target state="translated">MetaMethods 목록</target>
        </trans-unit>
        <trans-unit id="5f6b20a47fc4cbb54f0bb519f29a9002fc9b7a04" translate="yes" xml:space="preserve">
          <source>A list of MetaProperty instances</source>
          <target state="translated">MetaProperty 인스턴스 목록</target>
        </trans-unit>
        <trans-unit id="1d1013d07e5c51d8bc2c5c69c989b67dac4f5725" translate="yes" xml:space="preserve">
          <source>A list of all of the registered commands.</source>
          <target state="translated">등록 된 모든 명령 목록입니다.</target>
        </trans-unit>
        <trans-unit id="18897120f4ae9fc1436f410cb86c746be22bd3b5" translate="yes" xml:space="preserve">
          <source>A list of elements as arguments to the JSON builder creates a root JSON array</source>
          <target state="translated">JSON 빌더에 대한 인수로 요소 목록은 루트 JSON 배열을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="c32e2b0904e0b9e88ac1467de4c86cc4ec22ca69" translate="yes" xml:space="preserve">
          <source>A list of elements as arguments to the YAML builder creates a root YAML array</source>
          <target state="translated">YAML 빌더에 대한 인수로 요소 목록은 루트 YAML 배열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ed0990a4d24eeca4e87b9fa05fe46e0d24fc8e4b" translate="yes" xml:space="preserve">
          <source>A list of one or more modifier, annotation, or &quot;def&quot;.</source>
          <target state="translated">하나 이상의 수정 자, 주석 또는 &quot;def&quot;목록입니다.</target>
        </trans-unit>
        <trans-unit id="5c4cceac80996861f28adea0c54fd27c8ad23071" translate="yes" xml:space="preserve">
          <source>A list of statements and a scope.</source>
          <target state="translated">명령문 및 범위 목록입니다.</target>
        </trans-unit>
        <trans-unit id="a183936f2d934ec756c79ffb3318223e772a74f1" translate="yes" xml:space="preserve">
          <source>A list of the auto-generated column values for each inserted row (typically auto-generated keys)</source>
          <target state="translated">삽입 된 각 행에 대해 자동 생성 된 열 값 목록 (일반적으로 자동 생성 된 키)</target>
        </trans-unit>
        <trans-unit id="c54a966cb184a24ef3f33dc80bdcf90fa85634e5" translate="yes" xml:space="preserve">
          <source>A list of the auto-generated row results for each inserted row (typically auto-generated keys)</source>
          <target state="translated">삽입 된 각 행에 대한 자동 생성 된 행 결과 목록 (일반적으로 자동 생성 된 키)</target>
        </trans-unit>
        <trans-unit id="d436eb64e89470412c3196f502bc90952836cb2f" translate="yes" xml:space="preserve">
          <source>A list of zero or more formal parameters.</source>
          <target state="translated">0 개 이상의 형식 매개 변수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="11a6f49bda5bb6e5cdb660b5b9e036520b189164" translate="yes" xml:space="preserve">
          <source>A list of zero or more formal parameters. If a parameter is variable length (e.g. String... myArg) it should be to the right of any other parameters of the same kind. General form: (req, ..., opt, ..., [rest], key, ..., [restKeys], [block] This must be sorted out after parsing, since the various declaration forms are impossible to tell apart without backtracking.</source>
          <target state="translated">0 개 이상의 형식 매개 변수 목록입니다. 매개 변수가 가변 길이 (예 : String ... myArg) 인 경우 동일한 종류의 다른 매개 변수의 오른쪽에 있어야합니다. 일반 형식 : (req, ..., opt, ..., [rest], key, ..., [restKeys], [block] 다양한 선언 형식을 알 수 없기 때문에 구문 분석 후에 정렬해야합니다. 역 추적없이 떨어져 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4139f536882fa30bfa11a6d7cf8d26cdc1c7970" translate="yes" xml:space="preserve">
          <source>A list of zero or more modifiers, annotations, or &quot;def&quot;.</source>
          <target state="translated">0 개 이상의 수정 자, 주석 또는 &quot;def&quot;목록입니다.</target>
        </trans-unit>
        <trans-unit id="341c28f2b3d1cd5effad441d0e69a710cbe83bdf" translate="yes" xml:space="preserve">
          <source>A listener called whenever a constant MetaClass is set, removed or replaced.</source>
          <target state="translated">상수 MetaClass가 설정, 제거 또는 교체 될 때마다 호출되는 리스너입니다.</target>
        </trans-unit>
        <trans-unit id="eb186514a78117854838bac901dd6b0280f69a11" translate="yes" xml:space="preserve">
          <source>A listener registered for notification when an entry is evicted. An instance may be called concurrently by multiple threads to process entries. An implementation should avoid performing blocking calls or synchronizing on shared resources.</source>
          <target state="translated">항목이 제거 될 때 알림을 위해 등록 된 리스너입니다. 항목을 처리하기 위해 여러 스레드에서 인스턴스를 동시에 호출 할 수 있습니다. 구현은 차단 호출을 수행하거나 공유 리소스에 대한 동기화를 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="df950d2a3f6050eb16c1a16ad97613a15a58f8fd" translate="yes" xml:space="preserve">
          <source>A little GUI to show some of the Inspector capabilities. Starting this script opens the ObjectBrowser on &quot;some String&quot;. Use it in groovysh or groovyConsole to inspect your object of interest with: &lt;code&gt;
 ObjectBrowser.inspect(myObject)
 &lt;/code&gt;.</source>
          <target state="translated">Inspector 기능의 일부를 보여주는 작은 GUI. 이 스크립트를 시작하면 &quot;some String&quot;에서 ObjectBrowser가 열립니다. groovysh 또는 groovyConsole에서 사용하여 &lt;code&gt; ObjectBrowser.inspect(myObject) &lt;/code&gt; 하여 관심있는 개체를 검사합니다 .</target>
        </trans-unit>
        <trans-unit id="3ac37f398dad707aa5c480f8a5753fa0b37f390d" translate="yes" xml:space="preserve">
          <source>A loop driver for applying operations to all SourceUnits.</source>
          <target state="translated">모든 SourceUnit에 작업을 적용하기위한 루프 드라이버입니다.</target>
        </trans-unit>
        <trans-unit id="5f1ba4cb0eb2d9c51dcd8f7da17de68cda6320d1" translate="yes" xml:space="preserve">
          <source>A loop driver for applying operations to all SourceUnits. Automatically skips units that have already been processed through the current phase.</source>
          <target state="translated">모든 SourceUnit에 작업을 적용하기위한 루프 드라이버입니다. 현재 단계를 통해 이미 처리 된 단위를 자동으로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="85b85d588cd9eebffcee0cfe2fdeca59579e6f4e" translate="yes" xml:space="preserve">
          <source>A loop driver for applying operations to all primary ClassNodes in our AST.</source>
          <target state="translated">AST의 모든 기본 클래스 노드에 작업을 적용하기위한 루프 드라이버.</target>
        </trans-unit>
        <trans-unit id="e972effbec9c0e4fce88292d574cf2bb9a1638be" translate="yes" xml:space="preserve">
          <source>A loop driver for applying operations to all primary ClassNodes in our AST. Automatically skips units that have already been processed through the current phase.</source>
          <target state="translated">AST의 모든 기본 클래스 노드에 작업을 적용하기위한 루프 드라이버. 현재 단계를 통해 이미 처리 된 단위를 자동으로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="d645bd8b785b218d1ce7a7bbf943130aa2470c84" translate="yes" xml:space="preserve">
          <source>A map constructor is an argument list enclosed in square brackets, with labels everywhere, except on spread arguments, which stand for whole maps spliced in. A colon alone between the brackets also forces the expression to be an empty map constructor. Examples: [:], [a:1], [a:1,b:2], [a:1,*:m1,b:2], [*:m1,*:m2] (The m1, m2 must be a map or null.) Values associated with identical keys overwrite from left to right: [a:1,a:2] === [a:2]</source>
          <target state="translated">맵 생성자는 전체 맵을 연결하는 스프레드 인수를 제외하고 모든 곳에서 레이블이있는 대괄호로 묶인 인수 목록입니다. 괄호 사이에 콜론 만 있으면 표현식이 빈 맵 생성자가됩니다. 예 : [:], [a : 1], [a : 1, b : 2], [a : 1, * : m1, b : 2], [* : m1, * : m2] (m1, m2 맵이거나 null이어야합니다.) 동일한 키와 관련된 값은 왼쪽에서 오른쪽으로 덮어 씁니다. [a : 1, a : 2] === [a : 2]</target>
        </trans-unit>
        <trans-unit id="b4fd44e837b72ba99199223f79ed649aae5a50d2" translate="yes" xml:space="preserve">
          <source>A map constructor is created which sets properties, and optionally fields and super properties if the property/field name is a key within the map.</source>
          <target state="translated">속성을 설정하는 맵 생성자가 생성되며, 속성 / 필드 이름이 맵 내의 키인 경우 선택적으로 필드 및 수퍼 속성을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="588880c2c3b5b86508c1aa8ea2568b1556469413" translate="yes" xml:space="preserve">
          <source>A map of methods</source>
          <target state="translated">방법지도</target>
        </trans-unit>
        <trans-unit id="699fa6da8b702f43317ce1c37e6b555748d01340" translate="yes" xml:space="preserve">
          <source>A map used to store every type used in closure shared variable assignments.</source>
          <target state="translated">클로저 공유 변수 할당에 사용되는 모든 유형을 저장하는 데 사용되는 맵입니다.</target>
        </trans-unit>
        <trans-unit id="695f7f624dc05cd9897ce0cddfde7bed3020738c" translate="yes" xml:space="preserve">
          <source>A map used to store every type used in closure shared variable assignments. In a second pass, we will compute the LUB of each type and check that method calls on those variables are valid.</source>
          <target state="translated">클로저 공유 변수 할당에 사용되는 모든 유형을 저장하는 데 사용되는 맵입니다. 두 번째 단계에서는 각 유형의 LUB를 계산하고 해당 변수에 대한 메서드 호출이 유효한지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f8700238fd73fd8ba536b778e6231af28fc2f56e" translate="yes" xml:space="preserve">
          <source>A map-based constructor is provided which allows you to set properties by name.</source>
          <target state="translated">이름으로 속성을 설정할 수있는지도 기반 생성자가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3da7cd3ae77a52b61d819df2d781741f1562d5d4" translate="yes" xml:space="preserve">
          <source>A meaningful name for a repo containing the grape/artifact.</source>
          <target state="translated">포도 / 아티팩트를 포함하는 저장소의 의미있는 이름입니다.</target>
        </trans-unit>
        <trans-unit id="92114e2ef508aa91c31489584ddf046929d51fd9" translate="yes" xml:space="preserve">
          <source>A meaningful name for a repo containing the grape/artifact. A non-empty value is required unless value() is used.</source>
          <target state="translated">포도 / 아티팩트를 포함하는 저장소의 의미있는 이름입니다. value ()를 사용하지 않는 한 비어 있지 않은 값이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bb092736c333116794978718dcf5ebed49452a22" translate="yes" xml:space="preserve">
          <source>A member name (x.y) or element name (x[y]) can serve as a command name, which may be followed by a list of arguments.</source>
          <target state="translated">멤버 이름 (xy) 또는 요소 이름 (x [y])은 명령 이름으로 사용할 수 있으며 그 뒤에 인수 목록이 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30413befde5272f37dec5a786eddfdd1aa166216" translate="yes" xml:space="preserve">
          <source>A member name (x.y) or element name (x[y]) can serve as a command name, which may be followed by a list of arguments. Unlike parenthesized arguments, these must be plain expressions, without labels or spread operators.</source>
          <target state="translated">멤버 이름 (xy) 또는 요소 이름 (x [y])은 명령 이름으로 사용할 수 있으며 그 뒤에 인수 목록이 올 수 있습니다. 괄호로 묶인 인수와는 달리 레이블 또는 스프레드 연산자가없는 일반 표현식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b4c34c11691fe145d8e1cd1511d16f65dd66c417" translate="yes" xml:space="preserve">
          <source>A meta class for closures generated by the Groovy compiler. These classes have special characteristics this MetaClass uses. One of these is that a generated Closure has only additional doCall methods, all other methods are in the Closure class as well. To use this fact this MetaClass uses a MetaClass for Closure as static field And delegates calls to this MetaClass if needed. This allows a lean implementation for this MetaClass. Multiple generated closures will then use the same MetaClass for Closure. For static dispatching this class uses the MetaClass of Class, again all instances of this class will share that MetaClass. The Class MetaClass is initialized lazy, because most operations do not need this MetaClass.</source>
          <target state="translated">Groovy 컴파일러에 의해 생성 된 클로저를위한 메타 클래스. 이러한 클래스에는이 MetaClass가 사용하는 특별한 특성이 있습니다. 이 중 하나는 생성 된 Closure에 추가 doCall 메서드 만 있고 다른 모든 메서드도 Closure 클래스에 있다는 것입니다. 이 사실을 사용하기 위해이 MetaClass는 Closure 용 MetaClass를 정적 필드로 사용하고 필요한 경우이 MetaClass에 대한 호출을 위임합니다. 이것은이 MetaClass에 대한 린 구현을 허용합니다. 생성 된 여러 클로저는 클로저에 동일한 MetaClass를 사용합니다. 정적 디스패치의 경우이 클래스는 클래스의 MetaClass를 사용하며 다시이 클래스의 모든 인스턴스는 해당 MetaClass를 공유합니다. 클래스 MetaClass는 대부분의 작업에이 MetaClass가 필요하지 않기 때문에 지연 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="6c4db53dc723d2dce0bfd2858ebb171743881da5" translate="yes" xml:space="preserve">
          <source>A method call on an object or class.</source>
          <target state="translated">개체 또는 클래스에 대한 메서드 호출입니다.</target>
        </trans-unit>
        <trans-unit id="4e3e3cbb4217d459ac560d18b319fe3da0c899f8" translate="yes" xml:space="preserve">
          <source>A method call on the JSON builder instance will create a root object with only one key whose name is the name of the method being called.</source>
          <target state="translated">JSON 빌더 인스턴스에 대한 메서드 호출은 이름이 호출되는 메서드의 이름 인 키가 하나만있는 루트 개체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f06e876add17ff2c91201edd8943a455268001c0" translate="yes" xml:space="preserve">
          <source>A method call on the JSON builder instance will create a root object with only one key whose name is the name of the method being called. This method takes as arguments:</source>
          <target state="translated">JSON 빌더 인스턴스에 대한 메서드 호출은 이름이 호출되는 메서드의 이름 인 키가 하나만있는 루트 개체를 만듭니다. 이 메서드는 인수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8dd588471a00d979f47fc1253ebfa7f91f78bae6" translate="yes" xml:space="preserve">
          <source>A method call on the YAML builder instance will create a root object with only one key whose name is the name of the method being called.</source>
          <target state="translated">YAML 빌더 인스턴스에 대한 메서드 호출은 이름이 호출되는 메서드의 이름 인 키가 하나만있는 루트 개체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7add00a90091eb734c3a41dacc792c3c6de511f6" translate="yes" xml:space="preserve">
          <source>A method call on the YAML builder instance will create a root object with only one key whose name is the name of the method being called. This method takes as arguments:</source>
          <target state="translated">YAML 빌더 인스턴스에 대한 메서드 호출은 이름이 호출되는 메서드의 이름 인 키가 하나만있는 루트 개체를 만듭니다. 이 메서드는 인수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="586f0e86be2c832ac915f3ee6f415ed8dc57ac53" translate="yes" xml:space="preserve">
          <source>A method for determining from and to information when using this IntRange to index an aggregate object of the specified size.</source>
          <target state="translated">이 IntRange를 사용하여 지정된 크기의 집계 개체를 인덱싱 할 때 정보의 시작 및 끝을 결정하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="58d3b429deba731bd462df46779a46f2ec9f7810" translate="yes" xml:space="preserve">
          <source>A method for determining from and to information when using this IntRange to index an aggregate object of the specified size. Normally only used internally within Groovy but useful if adding range indexing support for your own aggregates.</source>
          <target state="translated">이 IntRange를 사용하여 지정된 크기의 집계 개체를 인덱싱 할 때 정보의 시작 및 끝을 결정하는 방법입니다. 일반적으로 Groovy 내부에서만 사용되지만 자체 집계에 대한 범위 인덱싱 지원을 추가하는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c1ff19125ea8078b0dd13c88d1bdd814e875e341" translate="yes" xml:space="preserve">
          <source>A module extension scanner is responsible for searching classpath modules, loading metadata from module descriptors, then perform custom tasks for each module. This class was introduced as a fix for GROOVY-6008</source>
          <target state="translated">모듈 확장 스캐너는 클래스 경로 모듈 검색, 모듈 설명자에서 메타 데이터로드, 각 모듈에 대한 사용자 지정 작업 수행을 담당합니다. 이 클래스는 GROOVY-6008에 대한 수정으로 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="bf43713199c973967bf1a5aa30ff2c008dbd9700" translate="yes" xml:space="preserve">
          <source>A more elaborate build file showing joint compilation:</source>
          <target state="translated">공동 컴파일을 보여주는보다 정교한 빌드 파일 :</target>
        </trans-unit>
        <trans-unit id="4547fbbf83b951c2c3dd9d41d551016ebf65b488" translate="yes" xml:space="preserve">
          <source>A more elaborate example:</source>
          <target state="translated">더 정교한 예 :</target>
        </trans-unit>
        <trans-unit id="e43dce03bd661b97fbc6f22679fad35af59ecc5e" translate="yes" xml:space="preserve">
          <source>A name and a closure passed to a JSON builder will create a key with a JSON object</source>
          <target state="translated">JSON 빌더에 전달 된 이름과 클로저는 JSON 객체로 키를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="876df8ab391f828a613294996a0189375adb09e0" translate="yes" xml:space="preserve">
          <source>A name, a collection and closure passed to a JSON builder will create a root JSON array applying the closure to each object in the collection</source>
          <target state="translated">JSON 빌더에 전달 된 이름, 컬렉션 및 클로저는 컬렉션의 각 객체에 클로저를 적용하는 루트 JSON 배열을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f1bcd2f2c003993933522795b7f637b8f3885bf2" translate="yes" xml:space="preserve">
          <source>A new array containing elements from left with those from right appended.</source>
          <target state="translated">왼쪽부터 오른쪽 요소가 추가 된 새 배열입니다.</target>
        </trans-unit>
        <trans-unit id="261b3ec475aba3283d6bd797bca4d737eb19dc39" translate="yes" xml:space="preserve">
          <source>A new array containing left with right appended to it.</source>
          <target state="translated">왼쪽에 오른쪽이 추가 된 새 배열입니다.</target>
        </trans-unit>
        <trans-unit id="3fb3f5032bc7fe592aa60679b6a493542ca2396a" translate="yes" xml:space="preserve">
          <source>A new array containing right appended to left.</source>
          <target state="translated">오른쪽이 왼쪽에 추가 된 새 배열입니다.</target>
        </trans-unit>
        <trans-unit id="627dd4fb25f6fbed026d5db93626559e21dd0229" translate="yes" xml:space="preserve">
          <source>A new closure forwarding to the original one while caching the results</source>
          <target state="translated">결과를 캐싱하는 동안 원래 클로저로 전달되는 새로운 클로저</target>
        </trans-unit>
        <trans-unit id="94019288aa7146589858c0d481be78ded186a3b5" translate="yes" xml:space="preserve">
          <source>A new function forwarding to the original one while caching the results</source>
          <target state="translated">결과를 캐싱하는 동안 원본으로 전달하는 새로운 기능</target>
        </trans-unit>
        <trans-unit id="3e1885c34dc089e8a2f03f7edb106d97df61913b" translate="yes" xml:space="preserve">
          <source>A new memoized closure</source>
          <target state="translated">새로운 메모 마감</target>
        </trans-unit>
        <trans-unit id="8af4699237b13472929b868f3631cec1ddebf4a3" translate="yes" xml:space="preserve">
          <source>A new string in which all characters that require escaping have been replaced with the corresponding XML entities.</source>
          <target state="translated">이스케이프가 필요한 모든 문자가 해당 XML 엔티티로 대체 된 새 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="783a7e69fd60ce6f34238dbc1e78ddf4c5e6acd4" translate="yes" xml:space="preserve">
          <source>A new string in which all characters that require escaping have been replaced with the corresponding replacements as determined by the &lt;code&gt;transform&lt;/code&gt; Closure.</source>
          <target state="translated">이스케이프가 필요한 모든 문자가 &lt;code&gt;transform&lt;/code&gt; 클로저에 의해 결정된 해당 대체 문자로 대체 된 새 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="36accc556c4e5b88ae905ba49b3504b13e9b922d" translate="yes" xml:space="preserve">
          <source>A new string in which all characters that require escaping have been replaced with the corresponding replacements as determined by the &lt;code&gt;transform&lt;/code&gt; function.</source>
          <target state="translated">이스케이프가 필요한 모든 문자가 &lt;code&gt;transform&lt;/code&gt; 함수에 의해 결정된 해당 대체 문자로 대체 된 새 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="547d568250563d9de313183f1a3f806eacd23713" translate="yes" xml:space="preserve">
          <source>A new unescaped &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; if null string input</source>
          <target state="translated">새로운 이스케이프 &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; 의 경우는 null 문자열 입력</target>
        </trans-unit>
        <trans-unit id="c87148a9e796115d09444a65c9528a96bc70c9ce" translate="yes" xml:space="preserve">
          <source>A no-arg constructor is provided which allows you to set properties by name using Groovy's normal bean conventions.</source>
          <target state="translated">인수가없는 생성자가 제공되어 Groovy의 일반 빈 규칙을 사용하여 이름으로 속성을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c689e4192457f647a68bdb4730f8964cbfc5fbb9" translate="yes" xml:space="preserve">
          <source>A non static factory to get alternative writer controller to be stored in the meta data</source>
          <target state="translated">메타 데이터에 저장할 대체 작성기 컨트롤러를 가져 오는 비 정적 팩토리</target>
        </trans-unit>
        <trans-unit id="0d33803365b751a7cd2953ae62bc754dd574bba2" translate="yes" xml:space="preserve">
          <source>A null object always coerces to false.</source>
          <target state="translated">null 개체는 항상 false로 강제 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="aa4cd78960531efc3c7c7b969916e35328dc1b21" translate="yes" xml:space="preserve">
          <source>A parameter to be returned from a CallableStatement.</source>
          <target state="translated">CallableStatement에서 반환되는 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="6aa7352271e6ea2486027230328f5417321d3907" translate="yes" xml:space="preserve">
          <source>A parser plugin factory for the new parser.</source>
          <target state="translated">새 파서를위한 파서 플러그인 팩토리.</target>
        </trans-unit>
        <trans-unit id="0edeb00803d936bcaa9f3342c7b706d58303914e" translate="yes" xml:space="preserve">
          <source>A parser plugin for the new parser.</source>
          <target state="translated">새 파서 용 파서 플러그인.</target>
        </trans-unit>
        <trans-unit id="2e04662defb7404b7feb2d61ed008372543c086d" translate="yes" xml:space="preserve">
          <source>A parser plugin which adapts the JSR Antlr Parser to the Groovy runtime.</source>
          <target state="translated">JSR Antlr Parser를 Groovy 런타임에 맞게 조정하는 구문 분석기 플러그인입니다.</target>
        </trans-unit>
        <trans-unit id="22e7fd1729aa9569bcd468ba52955566fe521451" translate="yes" xml:space="preserve">
          <source>A primary ClassNode is one where we have a source representation which is to be compiled by Groovy and which we have an AST for. The groovy compiler will output one class for each such ClassNode that passes through AsmBytecodeGenerator... not more, not less. That means for example Closures become such ClassNodes too at some point.</source>
          <target state="translated">기본 ClassNode는 Groovy에 의해 컴파일되고 AST가있는 소스 표현이있는 곳입니다. 그루비 컴파일러는 AsmBytecodeGenerator를 통과하는 각 ClassNode에 대해 하나의 클래스를 출력합니다. 이는 예를 들어 Closure가 어느 시점에서 그러한 ClassNode가됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="425e16193c9515cb774e49f3d8bb8812bfa0322b" translate="yes" xml:space="preserve">
          <source>A property path full binding</source>
          <target state="translated">속성 경로 전체 바인딩</target>
        </trans-unit>
        <trans-unit id="8633319a96e500ed93822944d04c72c19b07c39e" translate="yes" xml:space="preserve">
          <source>A proxy generator responsible for mapping a map of closures to a class implementing a list of interfaces. For example, the following code:</source>
          <target state="translated">인터페이스 목록을 구현하는 클래스에 클로저 맵을 매핑하는 프록시 생성기입니다. 예를 들어, 다음 코드 :</target>
        </trans-unit>
        <trans-unit id="d667db648696165e964b7c5698eebdec4515782a" translate="yes" xml:space="preserve">
          <source>A queue that stores values wrapped in a Reference, the type of which is determined by the provided &lt;a href=&quot;referencebundle&quot;&gt;ReferenceBundle&lt;/a&gt;. References stored in this queue will be removed when reference processing occurs.</source>
          <target state="translated">제공된 &lt;a href=&quot;referencebundle&quot;&gt;ReferenceBundle에&lt;/a&gt; 의해 결정되는 유형 인 참조에 래핑 된 값을 저장하는 큐입니다 . 이 대기열에 저장된 참조는 참조 처리가 발생하면 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b8439f74a09bfce41d0fc03491ebc77c63e3c3fd" translate="yes" xml:space="preserve">
          <source>A registry of MetaClass instances which caches introspection and reflection information and allows methods to be dynamically added to existing classes at runtime</source>
          <target state="translated">내부 검사 및 반영 정보를 캐시하고 런타임시 기존 클래스에 동적으로 메서드를 추가 할 수있는 MetaClass 인스턴스의 레지스트리</target>
        </trans-unit>
        <trans-unit id="e0767988264bfc00a15c743d68b45399e56a44f3" translate="yes" xml:space="preserve">
          <source>A registry of shell &lt;a href=&quot;command&quot;&gt;Command&lt;/a&gt; instances which may be executed.</source>
          <target state="translated">실행될 수있는 쉘 &lt;a href=&quot;command&quot;&gt;명령&lt;/a&gt; 인스턴스 의 레지스트리 .</target>
        </trans-unit>
        <trans-unit id="1627e3e332d410b95ebe7dac4c1ae44558168512" translate="yes" xml:space="preserve">
          <source>A relaxed parser, which tends to allow more, but won't really catch valid syntax errors.</source>
          <target state="translated">더 많은 것을 허용하는 경향이 있지만 실제로 유효한 구문 오류를 포착하지 않는 완화 된 파서.</target>
        </trans-unit>
        <trans-unit id="b78ef24fcd22f72704a792cfca1dd798262228a8" translate="yes" xml:space="preserve">
          <source>A return statement</source>
          <target state="translated">반환 진술</target>
        </trans-unit>
        <trans-unit id="0e17fdeb37c62fab22b2ddeb7f1dc198fcfc9c47" translate="yes" xml:space="preserve">
          <source>A reverse iterator over a list. Utilizes the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ListIterator.html&quot;&gt;ListIterator&lt;/a&gt; obtained from the provided &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html&quot;&gt;List&lt;/a&gt; and converts it to an &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt;Iterator&lt;/a&gt; that efficiently traverses the &lt;code&gt;List&lt;/code&gt; in reverse. The fail-fast semantics of this iterator are the same as the semantics of the underlying &lt;code&gt;ListIterator&lt;/code&gt;.</source>
          <target state="translated">목록에 대한 역방향 반복기입니다. 제공된 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html&quot;&gt;List&lt;/a&gt; 에서 얻은 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/ListIterator.html&quot;&gt;ListIterator&lt;/a&gt; 를 활용하고 &lt;code&gt;List&lt;/code&gt; 를 역방향으로 효율적으로 순회 하는 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html&quot;&gt;Iterator&lt;/a&gt; 로 변환합니다 . 이 반복자의 fail-fast 시맨틱은 기본 &lt;code&gt;ListIterator&lt;/code&gt; 의 시맨틱과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="1c2217a6699e46870add8b383a7ad4a8b082f30c" translate="yes" xml:space="preserve">
          <source>A signature codec is responsible for encoding and decoding of inferred returned types as stored in bytecode. The signature must contain an appropriate version number so that future versions of Groovy remain capable of decoding previous versions.</source>
          <target state="translated">서명 코덱은 바이트 코드에 저장된 유추 된 반환 유형의 인코딩 및 디코딩을 담당합니다. 서명에는 적절한 버전 번호가 포함되어 있어야 Groovy의 향후 버전이 이전 버전을 디코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea1441867159b516f742d798e84c7fa9fd876854" translate="yes" xml:space="preserve">
          <source>A simple ValueModel implementation which is a holder of an object value. Used to share local variables with closures</source>
          <target state="translated">객체 값의 소유자 인 간단한 ValueModel 구현입니다. 클로저와 지역 변수를 공유하는 데 사용</target>
        </trans-unit>
        <trans-unit id="fe7110e8e9240c465b4fb732c8a180c26681e66a" translate="yes" xml:space="preserve">
          <source>A simple antlr AST visitor that collects all nodes into a List.</source>
          <target state="translated">모든 노드를 목록으로 수집하는 간단한 antlr AST 방문자.</target>
        </trans-unit>
        <trans-unit id="3dcd6b25e851eba478b5a80c3f6404261124b882" translate="yes" xml:space="preserve">
          <source>A simple antlr AST visitor that outputs the tokenName of each node in a pseudo xml style.</source>
          <target state="translated">의사 xml 스타일로 각 노드의 tokenName을 출력하는 간단한 antlr AST 방문자.</target>
        </trans-unit>
        <trans-unit id="cf87df90eff1d94a327aa351701732fd3d27bbe1" translate="yes" xml:space="preserve">
          <source>A simple buffer that provides line/col access to chunks of source code held within itself.</source>
          <target state="translated">자체 내에 보유 된 소스 코드 청크에 대한 라인 / 콜 액세스를 제공하는 간단한 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="b390538da1c7e66a131e806e3a18fc860183585d" translate="yes" xml:space="preserve">
          <source>A simple extension point to allow us to switch between the classic Groovy parser and the new Antlr based parser(s).</source>
          <target state="translated">고전적인 Groovy 파서와 새로운 Antlr 기반 파서 사이를 전환 할 수있는 간단한 확장 점입니다.</target>
        </trans-unit>
        <trans-unit id="a7ada20ac2427ea998486322b3d1508a18d63b0d" translate="yes" xml:space="preserve">
          <source>A simple helper class which acts as a factory of &lt;a href=&quot;../namespace/qname&quot;&gt;QName&lt;/a&gt; instances.</source>
          <target state="translated">&lt;a href=&quot;../namespace/qname&quot;&gt;QName&lt;/a&gt; 인스턴스 의 팩토리 역할을하는 간단한 도우미 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="ebf625b4651f39749cb980ee50d4ecf3f9fa77da" translate="yes" xml:space="preserve">
          <source>A simple iterator over an ordered (flat) List of the nodes of the AST.</source>
          <target state="translated">AST 노드의 정렬 된 (플랫) 목록에 대한 단순 반복기입니다.</target>
        </trans-unit>
        <trans-unit id="505482f29bd948ad995a60a2e3d8fe57ab434be5" translate="yes" xml:space="preserve">
          <source>A simple preorder traversal over the supplied antlr AST.</source>
          <target state="translated">제공된 antlr AST에 대한 간단한 사전 주문 순회.</target>
        </trans-unit>
        <trans-unit id="865cb3ad64ecf0f41a4d25bb888853269231e2a3" translate="yes" xml:space="preserve">
          <source>A simple shell for invoking commands from a command-line.</source>
          <target state="translated">명령 줄에서 명령을 호출하기위한 간단한 셸입니다.</target>
        </trans-unit>
        <trans-unit id="33df7663ccecd9b1ccd6285e80b58c24fa7def13" translate="yes" xml:space="preserve">
          <source>A simple statement such as a method call where the return value is ignored</source>
          <target state="translated">반환 값이 무시되는 메서드 호출과 같은 간단한 문</target>
        </trans-unit>
        <trans-unit id="fa7371771921e2147bea4478e745edcfec22da6d" translate="yes" xml:space="preserve">
          <source>A simple text pane that is printable and wrapping is optional.</source>
          <target state="translated">인쇄 가능하고 줄 바꿈이있는 간단한 텍스트 창은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="4acbe07d7d4219d51c272a9a532f018b9d5f8c01" translate="yes" xml:space="preserve">
          <source>A simplified version of a &lt;a href=&quot;closuresignaturehint&quot;&gt;ClosureSignatureHint&lt;/a&gt; which is suitable for monomorphic closures, that is to say closures which only respond to a single signature.</source>
          <target state="translated">&lt;a href=&quot;closuresignaturehint&quot;&gt;Monomorphic&lt;/a&gt; 클로저, 즉 단일 서명에만 응답하는 클로저에 적합한 ClosureSignatureHint 의 단순화 된 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="897b03120b46e9019b89390ed88423b968b6751a" translate="yes" xml:space="preserve">
          <source>A single argument in (...) or [...].</source>
          <target state="translated">(...) 또는 [...]의 단일 인수.</target>
        </trans-unit>
        <trans-unit id="13d3efe692186c54480561711a7eb521cc5106b7" translate="yes" xml:space="preserve">
          <source>A single argument in (...) or [...]. Corresponds to to a method or closure parameter. May be labeled. May be modified by the spread operator '*' ('*:' for keywords).</source>
          <target state="translated">(...) 또는 [...]의 단일 인수. 메소드 또는 클로저 매개 변수에 해당합니다. 레이블이있을 수 있습니다. 스프레드 연산자 '*'(키워드의 경우 '* :')로 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce0fbfbc9cf09097d825cc18f8d1900cecb0ac8e" translate="yes" xml:space="preserve">
          <source>A sorter for TableModels. The sorter has a model (conforming to TableModel) and itself implements TableModel. TableSorter does not store or copy the data in the TableModel, instead it maintains an array of integers which it keeps the same size as the number of rows in its model. When the model changes it notifies the sorter that something has changed eg. &quot;rowsAdded&quot; so that its internal array of integers can be reallocated. As requests are made of the sorter (like getValueAt(row, col) it redirects them to its model via the mapping array. That way the TableSorter appears to hold another copy of the table with the rows in a different order. The sorting algorithm used is stable which means that it does not move around rows when its comparison function returns 0 to denote that they are equivalent.</source>
          <target state="translated">TableModels에 대한 분류기. 분류기에는 모델 (TableModel 준수)이 있으며 자체적으로 TableModel을 구현합니다. TableSorter는 TableModel에 데이터를 저장하거나 복사하지 않고 대신 모델의 행 수와 동일한 크기를 유지하는 정수 배열을 유지합니다. 모델이 변경되면 분류기에게 무언가 변경되었음을 알립니다. 내부 정수 배열을 재 할당 할 수 있도록 &quot;row 추가&quot;. 정렬 기 (예 : getValueAt (row, col))에서 요청이 이루어지면 매핑 배열을 통해 요청을 해당 모델로 리디렉션합니다. 이렇게하면 TableSorter가 다른 순서로 행이있는 테이블의 다른 복사본을 보유하는 것처럼 보입니다. 사용 된 정렬 알고리즘 이는 비교 함수가 동일 함을 나타 내기 위해 0을 반환 할 때 행 주위를 이동하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="73d389510321d5877761a72a37063239e8053834" translate="yes" xml:space="preserve">
          <source>A special &quot;marker&quot; style interface allowing Groovy classes to implement both Runnable and Callable yet give preference to Runnable (for backwards compatibility) for APIs having both Runnable and Callable methods. You should generally NOT use this method in your own code.</source>
          <target state="translated">Groovy 클래스가 Runnable과 Callable을 모두 구현하도록 허용하는 특수 &quot;마커&quot;스타일 인터페이스는 Runnable 및 Callable 메서드를 모두 갖는 API에 대해 Runnable (이전 버전과의 호환성을 위해)을 우선적으로 제공합니다. 일반적으로 자신의 코드에서이 방법을 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="77409f949b5b774fc58be3a656321cc6b88cab62" translate="yes" xml:space="preserve">
          <source>A special hint which handles a common use case in the Groovy methods that work on maps. In case of an iteration on a list of map entries, you often want the user to be able to work either on a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map/Entry.html&quot;&gt;Entry&lt;/a&gt; map entry or on a key,value pair.</source>
          <target state="translated">지도에서 작동하는 Groovy 메서드의 일반적인 사용 사례를 처리하는 특별한 힌트입니다. 맵 항목 목록에 대한 반복의 경우 사용자가 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map/Entry.html&quot;&gt;항목&lt;/a&gt; 맵 항목 또는 키, 값 쌍 에서 작업 할 수 있기를 원하는 경우가 많습니다 .</target>
        </trans-unit>
        <trans-unit id="8c400ef2997ffcf589032995199558963f290eb1" translate="yes" xml:space="preserve">
          <source>A special visitor for working with the structure of a class. In general, your will want to use the Abstract class based on this class &lt;a href=&quot;classcodevisitorsupport&quot;&gt;ClassCodeVisitorSupport&lt;/a&gt;.</source>
          <target state="translated">클래스 구조 작업을위한 특별 방문자. 일반적으로 &lt;a href=&quot;classcodevisitorsupport&quot;&gt;ClassCodeVisitorSupport&lt;/a&gt; 클래스를 기반으로하는 Abstract 클래스를 사용하고 싶을 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0166a27d9097da9c19114e9021525ec47164cbc0" translate="yes" xml:space="preserve">
          <source>A specialized Groovy AST visitor meant to perform additional verifications upon the current AST. Currently it does checks on annotated nodes and annotations itself.</source>
          <target state="translated">전문 Groovy AST 방문자는 현재 AST에 대해 추가 확인을 수행하기위한 것입니다. 현재 주석이 달린 노드와 주석 자체를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="340ed005a3a16698c2df6053130761fdda7a028f" translate="yes" xml:space="preserve">
          <source>A specialized version of the multi type binary expression dispatcher which is aware of static compilation. It is able to generate optimized bytecode for some operations using JVM instructions when available.</source>
          <target state="translated">정적 컴파일을 인식하는 다중 유형 이진 표현식 디스패처의 특수 버전입니다. 가능한 경우 JVM 명령을 사용하여 일부 작업에 대해 최적화 된 바이트 코드를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a7dc2707154ab6a70b0df111109330875485d53" translate="yes" xml:space="preserve">
          <source>A stack less exception used to indicate, that the execution of a missingMethod method failed with a MissingMethodException. This is used to prevent a call to invokeMethod for GroovyObject implementing classes.</source>
          <target state="translated">MissingMethodException으로 인해 missingMethod 메서드의 실행이 실패했음을 나타내는 데 사용되는 스택없는 예외입니다. 이것은 GroovyObject 구현 클래스에 대한 invokeMethod 호출을 방지하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1c2800edb74c84578c9b12f3adfc4a269a9d6f76" translate="yes" xml:space="preserve">
          <source>A statement is an element of a block.</source>
          <target state="translated">문은 블록의 요소입니다.</target>
        </trans-unit>
        <trans-unit id="f481b1f5161e72308844da3e6fd2ee9560257c1a" translate="yes" xml:space="preserve">
          <source>A statement is an element of a block. Typical statements are declarations (which are scoped to the block) and expressions.</source>
          <target state="translated">문은 블록의 요소입니다. 일반적인 명령문은 선언 (블록 범위)과 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="be742c65f535a7a13287b2b36877109b8cb5201e" translate="yes" xml:space="preserve">
          <source>A statement separator is either a semicolon or a significant newline.</source>
          <target state="translated">문 구분 기호는 세미콜론 또는 중요한 줄 바꿈입니다.</target>
        </trans-unit>
        <trans-unit id="c2cf1021cecca577d22453a41d95f3a5ced8b4ba" translate="yes" xml:space="preserve">
          <source>A statement separator is either a semicolon or a significant newline. Any number of additional (insignificant) newlines may accompany it.</source>
          <target state="translated">문 구분 기호는 세미콜론 또는 중요한 줄 바꿈입니다. 몇 개의 추가 (중요하지 않은) 줄 바꿈도 함께 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="147dd39ceeed2436f2b03de945b18110da20af27" translate="yes" xml:space="preserve">
          <source>A static compilation type checking extension, responsible for transforming unresolved method calls into direct calls to &lt;a href=&quot;basetemplate#methodMissing(java.lang.String,%20java.lang.Object)&quot;&gt;BaseTemplate.methodMissing&lt;/a&gt; for faster rendering.</source>
          <target state="translated">더 빠른 렌더링을 위해 해결되지 않은 메서드 호출을 &lt;a href=&quot;basetemplate#methodMissing(java.lang.String,%20java.lang.Object)&quot;&gt;BaseTemplate.methodMissing에&lt;/a&gt; 대한 직접 호출로 변환하는 정적 컴파일 유형 검사 확장 입니다.</target>
        </trans-unit>
        <trans-unit id="4fe0d0dd6687f009bb2aae5cd63cec35e180c8d7" translate="yes" xml:space="preserve">
          <source>A static helper class to interface bytecode and runtime</source>
          <target state="translated">바이트 코드와 런타임을 인터페이스하는 정적 도우미 클래스</target>
        </trans-unit>
        <trans-unit id="c5210eae7ce0168eeb1037f2f3326e1359ff23af" translate="yes" xml:space="preserve">
          <source>A static helper class to make bytecode generation easier and act as a facade over the Invoker</source>
          <target state="translated">바이트 코드 생성을 더 쉽게 만들고 Invoker에 대한 파사드 역할을하는 정적 도우미 클래스</target>
        </trans-unit>
        <trans-unit id="ecd0bf63df3e01e77841e34016568512e8d60607" translate="yes" xml:space="preserve">
          <source>A static method call on a class</source>
          <target state="translated">클래스에 대한 정적 메서드 호출</target>
        </trans-unit>
        <trans-unit id="0f19cacad29d3003a5b5012f51deb2b5c0fcb519" translate="yes" xml:space="preserve">
          <source>A strategy method to allow derived builders to use builder-trees and switch in different kinds of builders.</source>
          <target state="translated">파생 된 빌더가 빌더 트리를 사용하고 다른 종류의 빌더로 전환 할 수 있도록하는 전략 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ad737e2511fafbf53c01d065449202c463e7f184" translate="yes" xml:space="preserve">
          <source>A strategy method to allow derived builders to use builder-trees and switch in different kinds of builders. This method should call the setDelegate() method on the closure which by default passes in this but if node is-a builder we could pass that in instead (or do something wacky too)</source>
          <target state="translated">파생 된 빌더가 빌더 트리를 사용하고 다른 종류의 빌더로 전환 할 수 있도록하는 전략 방법입니다. 이 메서드는 클로저에서 setDelegate () 메서드를 호출해야합니다. 기본적으로이 메서드를 전달하지만 노드가 빌더 인 경우 대신 전달할 수 있습니다 (또는 엉뚱한 작업도 수행)</target>
        </trans-unit>
        <trans-unit id="68621365c26831acb2ff18dabe5c49f36cc5b1f8" translate="yes" xml:space="preserve">
          <source>A strategy method to allow derived builders to use builder-trees and switch in different kinds of builders. This method should call the setDelegate() method on the closure which by default passes in this but if node is-a builder we could pass that in instead (or do something wacky too).</source>
          <target state="translated">파생 된 빌더가 빌더 트리를 사용하고 다른 종류의 빌더로 전환 할 수 있도록하는 전략 방법입니다. 이 메서드는 클로저에서 setDelegate () 메서드를 호출해야합니다. 기본적으로이 메서드를 전달하지만 노드가 빌더 인 경우 대신 전달할 수 있습니다 (또는 이상한 작업도 수행 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="78e7319db203c169b2fa7c2dde773c67ec981266" translate="yes" xml:space="preserve">
          <source>A sub-block of a block can be either open or closable.</source>
          <target state="translated">블록의 하위 블록은 열리거나 닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c89d4049e244f6523e067677a1fee2210458d74" translate="yes" xml:space="preserve">
          <source>A sub-block of a block can be either open or closable. It is closable if and only if there are explicit closure arguments. Compare this to a block which is appended to a method call, which is given closure arguments, even if they are not explicit in the code.</source>
          <target state="translated">블록의 하위 블록은 열리거나 닫을 수 있습니다. 명시적인 클로저 인수가있는 경우에만 클로징 가능합니다. 이것을 코드에서 명시 적이 지 않더라도 클로저 인자가 주어진 메서드 호출에 추가 된 블록과 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="28e4715718360e5f6e9527524ff4dc3e0524b375" translate="yes" xml:space="preserve">
          <source>A suffix for creating the add, remove, and get methods defaulting to the name of the listener type, e.g. if name is set to MyListener, then the class will have addMyListener, removeMyListener, and getMyListeners methods.</source>
          <target state="translated">리스너 유형의 이름을 기본값으로하는 add, remove 및 get 메서드를 만들기위한 접미사입니다. 예를 들어 name이 MyListener로 설정된 경우 클래스에는 addMyListener, removeMyListener 및 getMyListeners 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5a7685dddd01b8fd4fd44560a95bc0338db96dd" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;code&gt;dot( base, &quot;&quot; )&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dot( base, &quot;&quot; )&lt;/code&gt; 의 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="4b89d0ccacafcee813d0b7f4ca6d5146ced5c0f1" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;code&gt;gotoPhase(getPhase() + 1)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gotoPhase(getPhase() + 1)&lt;/code&gt; 의 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="122e25e2e11e7c63d4014d23aefa7f10031ce3d6" translate="yes" xml:space="preserve">
          <source>A synonym for write( writer, owner, null ).</source>
          <target state="translated">write (writer, owner, null)의 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="1ac3a13af320dd989d573391821abd34cfb55677" translate="yes" xml:space="preserve">
          <source>A syntax reduction, produced by the &lt;code&gt;Parser&lt;/code&gt;.</source>
          <target state="translated">구문 &lt;code&gt;Parser&lt;/code&gt; 의해 생성 된 구문 감소 .</target>
        </trans-unit>
        <trans-unit id="3505c7b438e7b7652faee53528baedb5fe66842f" translate="yes" xml:space="preserve">
          <source>A table cell editor that will return a button automatically if it is the cell value, a text field if the value exists, or null otherwise (non editable cell). This hack allows to interact with buttons in a cell.</source>
          <target state="translated">버튼이 셀 값이면 자동으로, 값이 있으면 텍스트 필드를, 그렇지 않으면 null (편집 불가능한 셀)을 반환하는 테이블 셀 편집기입니다. 이 핵은 셀의 버튼과 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c14646573b08fbd1a6ef8d62d4a59519ef6a2d41" translate="yes" xml:space="preserve">
          <source>A table cell renderer that will return a component instead of drawing it, or call the default in the case of a non component object. This hack allows to render a button shape in a table cell.</source>
          <target state="translated">구성 요소를 그리는 대신 반환하거나 구성 요소가 아닌 개체의 경우 기본값을 호출하는 테이블 셀 렌더러입니다. 이 핵은 테이블 셀에서 버튼 모양을 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="533326563f1b9847855f025db5693df07a576cde" translate="yes" xml:space="preserve">
          <source>A template engine is a factory for creating a Template instance for a given text input.</source>
          <target state="translated">템플릿 엔진은 주어진 텍스트 입력에 대한 템플릿 인스턴스를 생성하기위한 팩토리입니다.</target>
        </trans-unit>
        <trans-unit id="22a7eb9d381e98be9f6fe951ecfeb9d4c4eb49b2" translate="yes" xml:space="preserve">
          <source>A template engine which leverages &lt;a href=&quot;../../xml/streamingmarkupbuilder&quot;&gt;StreamingMarkupBuilder&lt;/a&gt; to generate XML/XHTML.</source>
          <target state="translated">&lt;a href=&quot;../../xml/streamingmarkupbuilder&quot;&gt;StreamingMarkupBuilder&lt;/a&gt; 를 활용 하여 XML / XHTML을 생성 하는 템플릿 엔진 .</target>
        </trans-unit>
        <trans-unit id="a46d6c1c67070b6d2ff777beac4a1fcf7570666e" translate="yes" xml:space="preserve">
          <source>A template is a block of text with an associated binding that can be output to a writer or evaluated to a string.</source>
          <target state="translated">템플릿은 작성자에게 출력하거나 문자열로 평가할 수있는 연결된 바인딩이있는 텍스트 블록입니다.</target>
        </trans-unit>
        <trans-unit id="02c11f102b4f3bd84bbf951aaf2a0232d2590425" translate="yes" xml:space="preserve">
          <source>A template resolver which avoids calling &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#getResource(java.lang.String)&quot;&gt;ClassLoader.getResource&lt;/a&gt; if a template path already has been queried before.</source>
          <target state="translated">템플릿 경로가 이전에 이미 쿼리 된 경우 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#getResource(java.lang.String)&quot;&gt;ClassLoader.getResource&lt;/a&gt; 호출을 피하는 템플릿 리졸버 .</target>
        </trans-unit>
        <trans-unit id="2b82a7dc43191688a0d67dde5432de4de191b494" translate="yes" xml:space="preserve">
          <source>A template resolver which avoids calling &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#getResource(java.lang.String)&quot;&gt;ClassLoader.getResource&lt;/a&gt; if a template path already has been queried before. This improves performance if caching is enabled in the configuration.</source>
          <target state="translated">템플릿 경로가 이전에 이미 쿼리 된 경우 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#getResource(java.lang.String)&quot;&gt;ClassLoader.getResource&lt;/a&gt; 호출을 피하는 템플릿 리졸버 . 이렇게하면 구성에서 캐싱이 활성화 된 경우 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="8c158fa08a347ae71e997206ebd8a60f5a097068" translate="yes" xml:space="preserve">
          <source>A temporary implementation of MethodKey used to perform a fast lookup for a method using a set of arguments to a method</source>
          <target state="translated">메서드에 대한 인수 집합을 사용하여 메서드에 대한 빠른 조회를 수행하는 데 사용되는 MethodKey의 임시 구현</target>
        </trans-unit>
        <trans-unit id="44f4af1ec481ce4ee16224c5dad16fe1d973300c" translate="yes" xml:space="preserve">
          <source>A treewalker for the antlr generated AST that attempts to visit the AST nodes in the order needed to generate valid groovy source code.</source>
          <target state="translated">antlr에 대한 treewalker는 유효한 그루비 소스 코드를 생성하는 데 필요한 순서대로 AST 노드를 방문하려고 시도하는 AST를 생성했습니다.</target>
        </trans-unit>
        <trans-unit id="5de38746a21bed56578666bdd4417bca96b3d905" translate="yes" xml:space="preserve">
          <source>A tuple constructor is created with a parameter for each property (and optionally field and super properties). The default order is properties, pseudo/JavaBean properties and then fields for parent classes first (if includeSuperXxx annotation attributes are used). A default value is provided (using Java's default values) for all parameters in the constructor. Groovy's normal conventions then allows any number of parameters to be left off the end of the parameter list including all of the parameters - giving a no-arg constructor which can be used with the map-style naming conventions.</source>
          <target state="translated">튜플 생성자는 각 속성 (및 선택적으로 필드 및 수퍼 속성)에 대한 매개 변수로 생성됩니다. 기본 순서는 속성, 의사 / JavaBean 속성 및 상위 클래스에 대한 필드입니다 (includeSuperXxx 주석 속성이 사용되는 경우). 생성자의 모든 매개 변수에 대해 기본값이 제공됩니다 (Java의 기본값 사용). 그런 다음 Groovy의 일반 규칙은 모든 매개 변수를 포함하여 매개 변수 목록의 끝에서 임의의 수의 매개 변수를 생략 할 수 있도록합니다. 맵 스타일 이름 지정 규칙과 함께 사용할 수있는 인수가없는 생성자를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3882daa24ee487d0e09096053cb713d7d2ddacb7" translate="yes" xml:space="preserve">
          <source>A tuple-style constructor is provided which allows you to set properties in the same order as they are defined.</source>
          <target state="translated">정의 된 것과 동일한 순서로 속성을 설정할 수있는 튜플 스타일 생성자가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="bddc616a852b88b2a618253303a623bee2fac72b" translate="yes" xml:space="preserve">
          <source>A type checking extension that will take care of handling errors which are specific to enums. In particular, it will handle the enum constants within switch-case statement.</source>
          <target state="translated">열거 형과 관련된 오류 처리를 처리하는 형식 검사 확장입니다. 특히 switch-case 문 내에서 열거 형 상수를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="70fd0f3f1bf3caf0a5db607ff3b0e4e1401e1fa6" translate="yes" xml:space="preserve">
          <source>A type checking extension that will take care of handling errors which are specific to traits. In particular, it will handle the &quot;super&quot; method calls within a trait.</source>
          <target state="translated">트레이 트에 특정한 오류를 처리하는 유형 검사 확장입니다. 특히 트레이 트 내에서 &quot;super&quot;메서드 호출을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="7c3158f41fffa36ce2821217af0a9545e47bfa57" translate="yes" xml:space="preserve">
          <source>A typed parameter passed to, and returned from a CallableStatement.</source>
          <target state="translated">CallableStatement에 전달되고 반환되는 형식화 된 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="3619fe4a23eff5a59a3fbc80c1156186391b9f00" translate="yes" xml:space="preserve">
          <source>A typed parameter to pass to a query</source>
          <target state="translated">쿼리에 전달할 형식화 된 매개 변수</target>
        </trans-unit>
        <trans-unit id="63479eeffe462af85ef146803099b04a6fa4e2ca" translate="yes" xml:space="preserve">
          <source>A utilities for managing groovydoc, e.g. 1) extracting groovydoc from groovy AST; 2) TODO extracting tags from groovydoc; 3) attach groovydoc to AST node as metadata</source>
          <target state="translated">groovydoc 관리를위한 유틸리티, 예. 1) groovy AST에서 groovydoc 추출; 2) groovydoc에서 태그를 추출하는 TODO; 3) groovydoc을 AST 노드에 메타 데이터로 연결</target>
        </trans-unit>
        <trans-unit id="6f269a17587b1b972464d6fc25ad4b4436e39409" translate="yes" xml:space="preserve">
          <source>A utility class responsible for decompiling JVM class files and producing &lt;a href=&quot;classstub&quot;&gt;ClassStub&lt;/a&gt; objects reflecting their structure.</source>
          <target state="translated">JVM 클래스 파일을 디 컴파일하고 해당 구조를 반영 하는 &lt;a href=&quot;classstub&quot;&gt;ClassStub&lt;/a&gt; 객체를 생성하는 유틸리티 클래스 입니다.</target>
        </trans-unit>
        <trans-unit id="8fb276d79f82edb20bef6f0a24353b8188626751" translate="yes" xml:space="preserve">
          <source>A utility class to help calculate hashcode values using an algorithm similar to that outlined in &quot;Effective Java, Joshua Bloch, 2nd Edition&quot;.</source>
          <target state="translated">&quot;Effective Java, Joshua Bloch, 2nd Edition&quot;에 설명 된 것과 유사한 알고리즘을 사용하여 해시 코드 값을 계산하는 데 도움이되는 유틸리티 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="47ee2d87ef50c450c2ea841f692ae61092875ab5" translate="yes" xml:space="preserve">
          <source>A utility for getting information of types</source>
          <target state="translated">유형 정보를 얻는 유틸리티</target>
        </trans-unit>
        <trans-unit id="429dafd17c115c98d42ba5e34e94b6b3e01f291d" translate="yes" xml:space="preserve">
          <source>A value recorded during evaluation of an assertion, along with the column it is associated with in the assertion's normalized source text.</source>
          <target state="translated">어설 션의 정규화 된 소스 텍스트에서 연관된 열과 함께 어설 션 평가 중에 기록 된 값입니다.</target>
        </trans-unit>
        <trans-unit id="2594aa76a190025324a198bf688dd01d5e8c699c" translate="yes" xml:space="preserve">
          <source>A value supplied by the interceptor</source>
          <target state="translated">인터셉터가 제공하는 값</target>
        </trans-unit>
        <trans-unit id="182cc242133cc39c8a3900a99903b390cbfaa4a7" translate="yes" xml:space="preserve">
          <source>A value with a weight of</source>
          <target state="translated">가중치가있는 값</target>
        </trans-unit>
        <trans-unit id="0438c3e7210938d561e328d64a82318f749894f4" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#eachRow(java.lang.String,%20java.util.List,%20groovy.lang.Closure)&quot;&gt;eachRow(String, java.util.List, groovy.lang.Closure)&lt;/a&gt; useful when providing the named parameters as a map.</source>
          <target state="translated">이름이 지정된 매개 변수를 맵으로 제공 할 때 유용한 &lt;a href=&quot;#eachRow(java.lang.String,%20java.util.List,%20groovy.lang.Closure)&quot;&gt;eachRow (String, java.util.List, groovy.lang.Closure)&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="e0340fde4e85290646ec9d0396a20d9a2f737157" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#eachRow(java.lang.String,%20java.util.List,%20groovy.lang.Closure)&quot;&gt;eachRow(String, java.util.List, groovy.lang.Closure)&lt;/a&gt; useful when providing the named parameters as named arguments.</source>
          <target state="translated">명명 된 매개 변수를 명명 된 인수로 제공 할 때 유용한 &lt;a href=&quot;#eachRow(java.lang.String,%20java.util.List,%20groovy.lang.Closure)&quot;&gt;eachRow (String, java.util.List, groovy.lang.Closure)&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="cd80b16000c9a7f3656faf840e7be83c24bf6e5f" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#eachRow(java.lang.String,%20java.util.List,%20groovy.lang.Closure,%20groovy.lang.Closure)&quot;&gt;eachRow(String, java.util.List, groovy.lang.Closure, groovy.lang.Closure)&lt;/a&gt; useful when providing the named parameters as a map.</source>
          <target state="translated">명명 된 매개 변수를 맵으로 제공 할 때 유용한 &lt;a href=&quot;#eachRow(java.lang.String,%20java.util.List,%20groovy.lang.Closure,%20groovy.lang.Closure)&quot;&gt;eachRow (String, java.util.List, groovy.lang.Closure, groovy.lang.Closure)&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="d0d7978ae6b542da6b42d8f711bb3267294e0ec5" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#eachRow(java.lang.String,%20java.util.List,%20groovy.lang.Closure,%20groovy.lang.Closure)&quot;&gt;eachRow(String, java.util.List, groovy.lang.Closure, groovy.lang.Closure)&lt;/a&gt; useful when providing the named parameters as named arguments.</source>
          <target state="translated">명명 된 매개 변수를 명명 된 인수로 제공 할 때 유용한 &lt;a href=&quot;#eachRow(java.lang.String,%20java.util.List,%20groovy.lang.Closure,%20groovy.lang.Closure)&quot;&gt;eachRow (String, java.util.List, groovy.lang.Closure, groovy.lang.Closure)&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="b2f48bbf72746eeb11597db79d3b78b50c1f73b6" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#eachRow(java.lang.String,%20java.util.List,%20groovy.lang.Closure,%20int,%20int,%20groovy.lang.Closure)&quot;&gt;eachRow(String, java.util.List, groovy.lang.Closure, int, int, groovy.lang.Closure)&lt;/a&gt; allowing the named parameters to be supplied as named arguments.</source>
          <target state="translated">각 &lt;a href=&quot;#eachRow(java.lang.String,%20java.util.List,%20groovy.lang.Closure,%20int,%20int,%20groovy.lang.Closure)&quot;&gt;Row (String, java.util.List, groovy.lang.Closure, int, int, groovy.lang.Closure)&lt;/a&gt; 의 변형으로 명명 된 매개 변수를 명명 된 인수로 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a93f7f71cdfc484eb94b54be5b55c8f2e4752fc" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#eachRow(java.lang.String,%20java.util.List,%20groovy.lang.Closure,%20int,%20int,%20groovy.lang.Closure)&quot;&gt;eachRow(String, java.util.List, groovy.lang.Closure, int, int, groovy.lang.Closure)&lt;/a&gt; allowing the named parameters to be supplied in a map.</source>
          <target state="translated">각 &lt;a href=&quot;#eachRow(java.lang.String,%20java.util.List,%20groovy.lang.Closure,%20int,%20int,%20groovy.lang.Closure)&quot;&gt;Row (String, java.util.List, groovy.lang.Closure, int, int, groovy.lang.Closure)&lt;/a&gt; 의 변형으로 명명 된 매개 변수를 맵에 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2630606ce5149dbbe80761fabf590bba3f29ef3" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#eachRow(java.lang.String,%20java.util.List,%20int,%20int,%20groovy.lang.Closure)&quot;&gt;eachRow(String, java.util.List, int, int, groovy.lang.Closure)&lt;/a&gt; useful when providing the named parameters as a map.</source>
          <target state="translated">이름이 지정된 매개 변수를 맵으로 제공 할 때 유용한 &lt;a href=&quot;#eachRow(java.lang.String,%20java.util.List,%20int,%20int,%20groovy.lang.Closure)&quot;&gt;eachRow (String, java.util.List, int, int, groovy.lang.Closure)&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="06c059c442df0c6c79ea4dadf915a4f9507fc281" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#eachRow(java.lang.String,%20java.util.List,%20int,%20int,%20groovy.lang.Closure)&quot;&gt;eachRow(String, java.util.List, int, int, groovy.lang.Closure)&lt;/a&gt; useful when providing the named parameters as named arguments.</source>
          <target state="translated">명명 된 매개 변수를 명명 된 인수로 제공 할 때 유용한 &lt;a href=&quot;#eachRow(java.lang.String,%20java.util.List,%20int,%20int,%20groovy.lang.Closure)&quot;&gt;eachRow (String, java.util.List, int, int, groovy.lang.Closure)&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="22ae7e17c4afa27ed261b71c401949343c291e7d" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#execute(java.lang.String,%20java.util.List)&quot;&gt;execute(String, java.util.List)&lt;/a&gt; useful when providing the named parameters as named arguments.</source>
          <target state="translated">명명 된 매개 변수를 명명 된 인수로 제공 할 때 유용한 &lt;a href=&quot;#execute(java.lang.String,%20java.util.List)&quot;&gt;execute (String, java.util.List)&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="d4b971396500373b0ffe72bb28f936e2f4601d1c" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#execute(java.lang.String,%20java.util.List,%20groovy.lang.Closure)&quot;&gt;execute(String, java.util.List, Closure)&lt;/a&gt; useful when providing the named parameters as named arguments.</source>
          <target state="translated">명명 된 매개 변수를 명명 된 인수로 제공 할 때 유용한 &lt;a href=&quot;#execute(java.lang.String,%20java.util.List,%20groovy.lang.Closure)&quot;&gt;execute (String, java.util.List, Closure)&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="cae1cc77786cbc50c17177c7538166d3830d67e8" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#executeInsert(java.lang.String,%20java.util.List)&quot;&gt;executeInsert(String, java.util.List)&lt;/a&gt; useful when providing the named parameters as named arguments.</source>
          <target state="translated">명명 된 매개 변수를 명명 된 인수로 제공 할 때 유용한 &lt;a href=&quot;#executeInsert(java.lang.String,%20java.util.List)&quot;&gt;executeInsert (String, java.util.List)&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="24aa7d50922187efcd79a094a60797cc47f4d28e" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#executeInsert(java.lang.String,%20java.util.List,%20java.util.List)&quot;&gt;executeInsert(String, List, List)&lt;/a&gt; useful when providing the named parameters as named arguments.</source>
          <target state="translated">명명 된 매개 변수를 명명 된 인수로 제공 할 때 유용한 &lt;a href=&quot;#executeInsert(java.lang.String,%20java.util.List,%20java.util.List)&quot;&gt;executeInsert (String, List, List)&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="0962f4039c5163a09096ab730190b10996f15975" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#executeInsert(java.lang.String,%20java.util.List,%20java.util.List)&quot;&gt;executeInsert(String, List, List)&lt;/a&gt; useful when providing the named parameters as named arguments. This variant allows you to receive the values of any auto-generated columns, such as an autoincrement ID field (or fields) when you know the column name(s) of the ID field(s).</source>
          <target state="translated">명명 된 매개 변수를 명명 된 인수로 제공 할 때 유용한 &lt;a href=&quot;#executeInsert(java.lang.String,%20java.util.List,%20java.util.List)&quot;&gt;executeInsert (String, List, List)&lt;/a&gt; 의 변형입니다 . 이 변형을 사용하면 ID 필드의 열 이름을 알고있을 때 자동 증가 ID 필드 (또는 필드)와 같은 자동 생성 열의 값을받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eed9df53d2156adabcf89fa51aaa0f1929226513" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#executeUpdate(java.lang.String,%20java.util.List)&quot;&gt;executeUpdate(String, java.util.List)&lt;/a&gt; useful when providing the named parameters as named arguments.</source>
          <target state="translated">명명 된 매개 변수를 명명 된 인수로 제공 할 때 유용한 &lt;a href=&quot;#executeUpdate(java.lang.String,%20java.util.List)&quot;&gt;executeUpdate (String, java.util.List)&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="0c151fb1016966b39e6c8e046fec4b1507f13d5a" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#firstRow(java.lang.String,%20java.util.List)&quot;&gt;firstRow(String, java.util.List)&lt;/a&gt; useful when providing the named parameters as named arguments.</source>
          <target state="translated">명명 된 매개 변수를 명명 된 인수로 제공 할 때 유용한 &lt;a href=&quot;#firstRow(java.lang.String,%20java.util.List)&quot;&gt;firstRow (String, java.util.List)&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="8723ff5fcf0b2bfd303b4e5a4e787d094c63e5df" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#query(java.lang.String,%20java.util.List,%20groovy.lang.Closure)&quot;&gt;query(String, java.util.List, groovy.lang.Closure)&lt;/a&gt; useful when providing the named parameters as a map.</source>
          <target state="translated">명명 된 매개 변수를 맵으로 제공 할 때 유용한 &lt;a href=&quot;#query(java.lang.String,%20java.util.List,%20groovy.lang.Closure)&quot;&gt;query (String, java.util.List, groovy.lang.Closure)&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="902b8d45fec1a0b2e57c86b5a37b7bb8945c58a4" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#query(java.lang.String,%20java.util.List,%20groovy.lang.Closure)&quot;&gt;query(String, java.util.List, groovy.lang.Closure)&lt;/a&gt; useful when providing the named parameters as named arguments.</source>
          <target state="translated">명명 된 매개 변수를 명명 된 인수로 제공 할 때 유용한 &lt;a href=&quot;#query(java.lang.String,%20java.util.List,%20groovy.lang.Closure)&quot;&gt;query (String, java.util.List, groovy.lang.Closure)&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="d15f23d7d3c8fb9ac946bbaebddfadf65b3ab6a3" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#rows(java.lang.String,%20java.util.List)&quot;&gt;rows(String, java.util.List)&lt;/a&gt; useful when providing the named parameters as named arguments.</source>
          <target state="translated">명명 된 매개 변수를 명명 된 인수로 제공 할 때 유용한 &lt;a href=&quot;#rows(java.lang.String,%20java.util.List)&quot;&gt;행 (String, java.util.List)&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="6365ea03d9b5842b2b398429cf7beb396ca8d6ba" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#rows(java.lang.String,%20java.util.List,%20groovy.lang.Closure)&quot;&gt;rows(String, java.util.List, groovy.lang.Closure)&lt;/a&gt; useful when providing the named parameters as a map.</source>
          <target state="translated">명명 된 매개 변수를 맵으로 제공 할 때 유용한 &lt;a href=&quot;#rows(java.lang.String,%20java.util.List,%20groovy.lang.Closure)&quot;&gt;행&lt;/a&gt; 변형 (String, java.util.List, groovy.lang.Closure) 입니다.</target>
        </trans-unit>
        <trans-unit id="33e0dec64892021e6736acb26e91fbd5ffc61eaf" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#rows(java.lang.String,%20java.util.List,%20groovy.lang.Closure)&quot;&gt;rows(String, java.util.List, groovy.lang.Closure)&lt;/a&gt; useful when providing the named parameters as named arguments.</source>
          <target state="translated">명명 된 매개 변수를 명명 된 인수로 제공 할 때 유용한 &lt;a href=&quot;#rows(java.lang.String,%20java.util.List,%20groovy.lang.Closure)&quot;&gt;행&lt;/a&gt; 변형 (String, java.util.List, groovy.lang.Closure) 입니다.</target>
        </trans-unit>
        <trans-unit id="8cb8eb13c9b2f8ada425b500bf1e859ce8094395" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#rows(java.lang.String,%20java.util.List,%20int,%20int)&quot;&gt;rows(String, java.util.List, int, int)&lt;/a&gt; useful when providing the named parameters as a map.</source>
          <target state="translated">명명 된 매개 변수를 맵으로 제공 할 때 유용한 &lt;a href=&quot;#rows(java.lang.String,%20java.util.List,%20int,%20int)&quot;&gt;행 (String, java.util.List, int, int)&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="90b94128f5975e59c5e816c72f8e0e129d238857" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#rows(java.lang.String,%20java.util.List,%20int,%20int)&quot;&gt;rows(String, java.util.List, int, int)&lt;/a&gt; useful when providing the named parameters as named arguments.</source>
          <target state="translated">명명 된 매개 변수를 명명 된 인수로 제공 할 때 유용한 &lt;a href=&quot;#rows(java.lang.String,%20java.util.List,%20int,%20int)&quot;&gt;행 (String, java.util.List, int, int)&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="842dad57fd8c8aac7efaf2a53d738bcc958de561" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#rows(java.lang.String,%20java.util.List,%20int,%20int,%20groovy.lang.Closure)&quot;&gt;rows(String, java.util.List, int, int, groovy.lang.Closure)&lt;/a&gt; useful when providing the named parameters as a map.</source>
          <target state="translated">명명 된 매개 변수를 맵으로 제공 할 때 유용한 &lt;a href=&quot;#rows(java.lang.String,%20java.util.List,%20int,%20int,%20groovy.lang.Closure)&quot;&gt;행&lt;/a&gt; 변형 (String, java.util.List, int, int, groovy.lang.Closure) 입니다.</target>
        </trans-unit>
        <trans-unit id="b2db5bc551cbda7b94642b908b6f27ffb623af2b" translate="yes" xml:space="preserve">
          <source>A variant of &lt;a href=&quot;#rows(java.lang.String,%20java.util.List,%20int,%20int,%20groovy.lang.Closure)&quot;&gt;rows(String, java.util.List, int, int, groovy.lang.Closure)&lt;/a&gt; useful when providing the named parameters as named arguments.</source>
          <target state="translated">명명 된 매개 변수를 명명 된 인수로 제공 할 때 유용한 &lt;a href=&quot;#rows(java.lang.String,%20java.util.List,%20int,%20int,%20groovy.lang.Closure)&quot;&gt;행&lt;/a&gt; 변형 (String, java.util.List, int, int, groovy.lang.Closure) 입니다.</target>
        </trans-unit>
        <trans-unit id="1cc780a42c269df9f167bcd87b2d5f77d7ffd224" translate="yes" xml:space="preserve">
          <source>A variant of collectEntries for Iterable objects using the identity closure as the transform.</source>
          <target state="translated">ID 클로저를 변환으로 사용하는 Iterable 개체에 대한 collectEntries 변형입니다.</target>
        </trans-unit>
        <trans-unit id="951ac163e309833cb5e057d8f60b9c5ac3b884ab" translate="yes" xml:space="preserve">
          <source>A variant of collectEntries for Iterable objects using the identity closure as the transform. The source Iterable should contain a list of &lt;code&gt;[key, value]&lt;/code&gt; tuples or &lt;code&gt;Map.Entry&lt;/code&gt; objects.</source>
          <target state="translated">ID 클로저를 변환으로 사용하는 Iterable 개체에 대한 collectEntries 변형입니다. 소스 Iterable은 &lt;code&gt;[key, value]&lt;/code&gt; 튜플 또는 &lt;code&gt;Map.Entry&lt;/code&gt; 객체 목록을 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7c4714caa90724091353f8de3448dd1b48a4fa65" translate="yes" xml:space="preserve">
          <source>A variant of collectEntries for Iterables using the identity closure as the transform and a supplied map as the destination of transformed entries.</source>
          <target state="translated">ID 클로저를 변환으로 사용하고 제공된 맵을 변환 된 항목의 대상으로 사용하는 Iterables 용 collectEntries의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="187a884f1b0b54b49e917a436dafe393b4dbe242" translate="yes" xml:space="preserve">
          <source>A variant of collectEntries for Iterators using a supplied map as the destination of transformed entries.</source>
          <target state="translated">제공된 맵을 변환 된 항목의 대상으로 사용하는 반복 기용 collectEntries의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="23c84e9be13aceb564ae11ffb6ad2da2ce641e23" translate="yes" xml:space="preserve">
          <source>A variant of collectEntries for Iterators using the identity closure as the transform and a supplied map as the destination of transformed entries.</source>
          <target state="translated">ID 클로저를 변환으로 사용하고 제공된 맵을 변환 된 항목의 대상으로 사용하는 Iterators 용 collectEntries의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="11b2a6bf9c01c9ce3a251150121318a631b29cb1" translate="yes" xml:space="preserve">
          <source>A variant of collectEntries for Iterators using the identity closure as the transform.</source>
          <target state="translated">ID 클로저를 변환으로 사용하는 반복 자용 collectEntries의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="3290c9327e10ba9b0134c1f7d8929e97651cd8f2" translate="yes" xml:space="preserve">
          <source>A variant of collectEntries for Iterators.</source>
          <target state="translated">반복자를위한 collectEntries의 변형.</target>
        </trans-unit>
        <trans-unit id="e75133de41f537cc827f7b21e007b501bf68d8ce" translate="yes" xml:space="preserve">
          <source>A variant of collectEntries using the identity closure as the transform.</source>
          <target state="translated">ID 클로저를 변환으로 사용하는 collectEntries의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="1f5b276258ec859c5cef69ccb0b1e745441354b5" translate="yes" xml:space="preserve">
          <source>A visitor that prints a html tags of each node to the supplied PrintStream</source>
          <target state="translated">제공된 PrintStream에 각 노드의 html 태그를 인쇄하는 방문자</target>
        </trans-unit>
        <trans-unit id="2d344a9d438b047ef05b8bd137236b12f5a324d7" translate="yes" xml:space="preserve">
          <source>A visitor that prints a html tags, for each node, to the supplied PrintStream.</source>
          <target state="translated">제공된 PrintStream에 각 노드에 대해 html 태그를 인쇄하는 방문자입니다.</target>
        </trans-unit>
        <trans-unit id="9d82ccf68f43c7945532dd4c082476d4e1dee65a" translate="yes" xml:space="preserve">
          <source>A visitor that prints a pseudo xml output to the supplied PrintStream</source>
          <target state="translated">제공된 PrintStream에 의사 xml 출력을 인쇄하는 방문자</target>
        </trans-unit>
        <trans-unit id="700e2a6c9d4978a0ebf617b57699748b445489ab" translate="yes" xml:space="preserve">
          <source>A visitor that prints groovy source code for each node visited.</source>
          <target state="translated">방문한 각 노드에 대한 멋진 소스 코드를 인쇄하는 방문자.</target>
        </trans-unit>
        <trans-unit id="775af2cc27d2378fa3719655ed28ef9adac9b08b" translate="yes" xml:space="preserve">
          <source>A visitor which collects Groovydoc information.</source>
          <target state="translated">Groovydoc 정보를 수집하는 방문자.</target>
        </trans-unit>
        <trans-unit id="569c21853c206c9756ab9b5890ad117420efb618" translate="yes" xml:space="preserve">
          <source>A visitor which collects the list of variable expressions which are closure shared.</source>
          <target state="translated">클로저가 공유되는 변수 표현식 목록을 수집하는 방문자.</target>
        </trans-unit>
        <trans-unit id="93014f9dc4f3b287b8763047ec597506a17bc910" translate="yes" xml:space="preserve">
          <source>A weigher where a value has a weight of</source>
          <target state="translated">값의 가중치가있는 계량기</target>
        </trans-unit>
        <trans-unit id="cef7c48ae5b1d28190d744907d72cb9ac8c9a213" translate="yes" xml:space="preserve">
          <source>A weigher where a value takes one unit of capacity.</source>
          <target state="translated">값이 한 단위 용량을 차지하는 계량기.</target>
        </trans-unit>
        <trans-unit id="fb4c3b4795d1ef0081e7a37e97a8a2a1dc905047" translate="yes" xml:space="preserve">
          <source>A weigher where an entry has a weight of</source>
          <target state="translated">항목의 가중치가있는 계량기</target>
        </trans-unit>
        <trans-unit id="3365b3436c91ad65bead70d1efaf351033dc8d81" translate="yes" xml:space="preserve">
          <source>A weigher where each byte takes one unit of capacity.</source>
          <target state="translated">각 바이트가 하나의 용량 단위를 차지하는 계량기.</target>
        </trans-unit>
        <trans-unit id="4d0808a689b4c32e2d650b2e08adbbd248752425" translate="yes" xml:space="preserve">
          <source>A weigher where each element takes one unit of capacity.</source>
          <target state="translated">각 요소가 한 단위 용량을 차지하는 계량기.</target>
        </trans-unit>
        <trans-unit id="d08333cb694a39f90a36bccfbe826468d749a8ad" translate="yes" xml:space="preserve">
          <source>A weigher where each entry takes one unit of capacity.</source>
          <target state="translated">각 항목이 한 단위 용량을 차지하는 계량기.</target>
        </trans-unit>
        <trans-unit id="5e1297106801ba887052a139f19f213c30d1cd9f" translate="yes" xml:space="preserve">
          <source>A weigher where the value is a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html&quot;&gt;Iterable&lt;/a&gt; and its weight is the number of elements.</source>
          <target state="translated">값이 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html&quot;&gt;Iterable&lt;/a&gt; 이고 가중치가 요소 수인 계량기 입니다.</target>
        </trans-unit>
        <trans-unit id="e80e0ddf684fd4f348717fc3863ffc81e0b23857" translate="yes" xml:space="preserve">
          <source>A weigher where the value is a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html&quot;&gt;Iterable&lt;/a&gt; and its weight is the number of elements. This weigher only should be used when the alternative &lt;a href=&quot;#collection()&quot;&gt;collection()&lt;/a&gt; weigher cannot be, as evaluation takes O(n) time. A map bounded with this weigher will evict when the total number of elements exceeds the capacity rather than the number of key-value pairs in the map.</source>
          <target state="translated">값이 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html&quot;&gt;Iterable&lt;/a&gt; 이고 가중치가 요소 수인 계량기 입니다. 이 계량기 는 평가에 O (n) 시간이 걸리므로 대체 &lt;a href=&quot;#collection()&quot;&gt;collection ()&lt;/a&gt; 계량기를 사용할 수없는 경우에만 사용해야합니다 . 이 가중치로 묶인 맵은 맵의 키-값 쌍 수가 아니라 총 요소 수가 용량을 초과 할 때 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2c8f8dfead177d95cc7b29543ae56e20e4b130f5" translate="yes" xml:space="preserve">
          <source>A weigher where the value is a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html&quot;&gt;Collection&lt;/a&gt; and its weight is the number of elements.</source>
          <target state="translated">값이 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html&quot;&gt;컬렉션&lt;/a&gt; 이고 무게가 요소의 수인 계량기 .</target>
        </trans-unit>
        <trans-unit id="cb443d19e584091fe8deeab89d07fd58dfcd8f39" translate="yes" xml:space="preserve">
          <source>A weigher where the value is a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html&quot;&gt;Collection&lt;/a&gt; and its weight is the number of elements. A map bounded with this weigher will evict when the total number of elements exceeds the capacity rather than the number of key-value pairs in the map.</source>
          <target state="translated">값이 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html&quot;&gt;컬렉션&lt;/a&gt; 이고 무게가 요소의 수인 계량기 . 이 가중치로 묶인 맵은 맵의 키-값 쌍 수가 아니라 총 요소 수가 용량을 초과 할 때 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="f0a4bafb6367f9b860366f2fae4536239e196352" translate="yes" xml:space="preserve">
          <source>A weigher where the value is a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html&quot;&gt;List&lt;/a&gt; and its weight is the number of elements.</source>
          <target state="translated">값이 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html&quot;&gt;목록&lt;/a&gt; 이고 무게가 요소의 수인 계량기 .</target>
        </trans-unit>
        <trans-unit id="3ed32aea01671919965375b25e823eb0ae3e5666" translate="yes" xml:space="preserve">
          <source>A weigher where the value is a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html&quot;&gt;List&lt;/a&gt; and its weight is the number of elements. A map bounded with this weigher will evict when the total number of elements exceeds the capacity rather than the number of key-value pairs in the map.</source>
          <target state="translated">값이 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html&quot;&gt;목록&lt;/a&gt; 이고 무게가 요소의 수인 계량기 . 이 가중치로 묶인 맵은 맵의 키-값 쌍 수가 아니라 총 요소 수가 용량을 초과 할 때 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="59c3169db3bf09590e63e2f29ce2980949e41ccb" translate="yes" xml:space="preserve">
          <source>A weigher where the value is a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; and its weight is the number of entries.</source>
          <target state="translated">값이 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;지도&lt;/a&gt; 이고 무게가 항목 수인 계량기 .</target>
        </trans-unit>
        <trans-unit id="78dedde5b830f98ea61ceeb68212e309cc8c6a5c" translate="yes" xml:space="preserve">
          <source>A weigher where the value is a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;Map&lt;/a&gt; and its weight is the number of entries. A map bounded with this weigher will evict when the total number of entries across all values exceeds the capacity rather than the number of key-value pairs in the map.</source>
          <target state="translated">값이 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map.html&quot;&gt;지도&lt;/a&gt; 이고 무게가 항목 수인 계량기 . 이 계량기로 묶인 맵은 모든 값의 총 항목 수가 맵의 키-값 쌍 수가 아닌 용량을 초과 할 때 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="bc2c7984e1fc773e7cc98af45c4596804ea17c09" translate="yes" xml:space="preserve">
          <source>A weigher where the value is a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Set.html&quot;&gt;Set&lt;/a&gt; and its weight is the number of elements.</source>
          <target state="translated">값이 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Set.html&quot;&gt;세트&lt;/a&gt; 이고 무게가 요소의 수인 계량기 .</target>
        </trans-unit>
        <trans-unit id="313ba1f460ebcff6e76f040e10b87f5a177fcedd" translate="yes" xml:space="preserve">
          <source>A weigher where the value is a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Set.html&quot;&gt;Set&lt;/a&gt; and its weight is the number of elements. A map bounded with this weigher will evict when the total number of elements exceeds the capacity rather than the number of key-value pairs in the map.</source>
          <target state="translated">값이 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Set.html&quot;&gt;세트&lt;/a&gt; 이고 무게가 요소의 수인 계량기 . 이 가중치로 묶인 맵은 맵의 키-값 쌍 수가 아니라 총 요소 수가 용량을 초과 할 때 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="affd766eb6b2a1f687236dd93ed2cf71eec2a4e3" translate="yes" xml:space="preserve">
          <source>A weigher where the value is a byte array and its weight is the number of bytes.</source>
          <target state="translated">값이 바이트 배열이고 가중치가 바이트 수인 계량기.</target>
        </trans-unit>
        <trans-unit id="6c8dc641a576c683037a7da1cc47d864c7dc261b" translate="yes" xml:space="preserve">
          <source>A weigher where the value is a byte array and its weight is the number of bytes. A map bounded with this weigher will evict when the number of bytes exceeds the capacity rather than the number of key-value pairs in the map. This allows for restricting the capacity based on the memory-consumption and is primarily for usage by dedicated caching servers that hold the serialized data.</source>
          <target state="translated">값이 바이트 배열이고 가중치가 바이트 수인 계량기. 이 가중치로 묶인 맵은 바이트 수가 맵의 키-값 쌍 수가 아닌 용량을 초과 할 때 제거됩니다. 이를 통해 메모리 사용량에 따라 용량을 제한 할 수 있으며 주로 직렬화 된 데이터를 보유하는 전용 캐싱 서버에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="21f6ab40897d8a4e542925a0f5e01e11c71b2058" translate="yes" xml:space="preserve">
          <source>A wrapper for &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html&quot;&gt;List&lt;/a&gt; which automatically grows the list when either &lt;a href=&quot;#get(int)&quot;&gt;get(int)&lt;/a&gt; or &lt;a href=&quot;#getAt(int)&quot;&gt;getAt(int)&lt;/a&gt; is called with an index greater than or equal to &lt;code&gt;size()&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#get(int)&quot;&gt;get (int)&lt;/a&gt; 또는 &lt;a href=&quot;#getAt(int)&quot;&gt;getAt (int)&lt;/a&gt; 이 &lt;code&gt;size()&lt;/code&gt; 보다 크거나 같은 인덱스로 호출 될 때 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/List.html&quot;&gt;목록&lt;/a&gt; 을 자동으로 늘리는 List 의 래퍼입니다 .</target>
        </trans-unit>
        <trans-unit id="7e4029ca47de5e3af5fb0fa3d6cf5faf70299741" translate="yes" xml:space="preserve">
          <source>A wrapper for Closure to support composition. Normally used only internally through the &lt;code&gt;rightShift()&lt;/code&gt; and &lt;code&gt;leftShift()&lt;/code&gt; methods on &lt;code&gt;Closure&lt;/code&gt;.</source>
          <target state="translated">작성을 지원하기위한 Closure 용 래퍼입니다. 일반적으로 &lt;code&gt;Closure&lt;/code&gt; 의 &lt;code&gt;rightShift()&lt;/code&gt; 및 &lt;code&gt;leftShift()&lt;/code&gt; 메서드를 통해 내부적으로 만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="29c713118b23107659d2079441632ffded8a14fa" translate="yes" xml:space="preserve">
          <source>A wrapper for Closure to support currying. Normally used only internally through the &lt;code&gt;curry()&lt;/code&gt;, &lt;code&gt;rcurry()&lt;/code&gt; or &lt;code&gt;ncurry()&lt;/code&gt; methods on &lt;code&gt;Closure&lt;/code&gt;. Typical usages:</source>
          <target state="translated">카레를 지원하기위한 Closure 용 포장지입니다. 일반적으로 &lt;code&gt;Closure&lt;/code&gt; 의 &lt;code&gt;curry()&lt;/code&gt; , &lt;code&gt;rcurry()&lt;/code&gt; 또는 &lt;code&gt;ncurry()&lt;/code&gt; 메서드를 통해 내부적으로 만 사용됩니다 . 일반적인 용도 :</target>
        </trans-unit>
        <trans-unit id="d62c991bc91a313f91eb2ec0623f215fd8d1b052" translate="yes" xml:space="preserve">
          <source>A wrapper for Map which allows a default value to be specified.</source>
          <target state="translated">기본값을 지정할 수있는 Map의 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="36f976ad7c7b4f99ca17011ebad8f3e8bcbafce2" translate="yes" xml:space="preserve">
          <source>A writer which delegates to another writer and supports an additional indenting level.</source>
          <target state="translated">다른 작성자에게 위임하고 추가 들여 쓰기 수준을 지원하는 작성자입니다.</target>
        </trans-unit>
        <trans-unit id="edf676600d7dbd580b263209161163f8e5d54586" translate="yes" xml:space="preserve">
          <source>API.</source>
          <target state="translated">API.</target>
        </trans-unit>
        <trans-unit id="c217a1c77434398486565be4e0776cea1a75ee07" translate="yes" xml:space="preserve">
          <source>AST completion</source>
          <target state="translated">AST 완료</target>
        </trans-unit>
        <trans-unit id="0f7e932cd6845d0f350d49f90570da50067150eb" translate="yes" xml:space="preserve">
          <source>AST effect: Create a separate Type/Var tree for each var in the var list. Must be guarded, as in (declarationStart) =&amp;gt; declaration.</source>
          <target state="translated">AST 효과 : var 목록의 각 var에 대해 별도의 Type / Var 트리를 만듭니다. (declarationStart) =&amp;gt; 선언과 같이 보호되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2e5e8402f3b09d08e95812a2244c2de145a67850" translate="yes" xml:space="preserve">
          <source>AST nodes for Groovy expressions</source>
          <target state="translated">Groovy 표현식을위한 AST 노드</target>
        </trans-unit>
        <trans-unit id="ec75671496c8e7774e06fb08c5812ecd728093bb" translate="yes" xml:space="preserve">
          <source>AST nodes for Groovy statements</source>
          <target state="translated">Groovy 문을위한 AST 노드</target>
        </trans-unit>
        <trans-unit id="83d2f83378581611a11cf2d8113977a393193d9f" translate="yes" xml:space="preserve">
          <source>AST semantic analysis and elucidation</source>
          <target state="translated">AST 의미 분석 및 해명</target>
        </trans-unit>
        <trans-unit id="34079af8ec81c9e419ba24dd531f2913363db524" translate="yes" xml:space="preserve">
          <source>ASTTransformation</source>
          <target state="translated">ASTTransformation</target>
        </trans-unit>
        <trans-unit id="c7d3fe558f46cd2d321834af0cec41ec3735deb2" translate="yes" xml:space="preserve">
          <source>Abstract base class for any GroovyCodeVisitor which by default just walks the code and expression tree</source>
          <target state="translated">모든 GroovyCodeVisitor에 대한 추상 기본 클래스는 기본적으로 코드 및 표현식 트리를 이동합니다.</target>
        </trans-unit>
        <trans-unit id="6b9096b433569b5730d098e76523fd5b54a00965" translate="yes" xml:space="preserve">
          <source>Abstract base class for generator of Java class versions of Groovy AST classes</source>
          <target state="translated">Groovy AST 클래스의 Java 클래스 버전 생성을위한 추상 기본 클래스</target>
        </trans-unit>
        <trans-unit id="657152b4f3229039c7b6b2ef8e2885fbf55c18a6" translate="yes" xml:space="preserve">
          <source>AbstractConcurrentMapBaseEntry</source>
          <target state="translated">AbstractConcurrentMapBaseEntry</target>
        </trans-unit>
        <trans-unit id="eb957844acc156e1f473fcf3815a80d331d9e58d" translate="yes" xml:space="preserve">
          <source>AbstractConcurrentMapEntry</source>
          <target state="translated">AbstractConcurrentMapEntry</target>
        </trans-unit>
        <trans-unit id="27ac80297a33b13abf26e00ff51245665998944f" translate="yes" xml:space="preserve">
          <source>AbstractFunctionalInterfaceWriter</source>
          <target state="translated">AbstractFunctionalInterfaceWriter</target>
        </trans-unit>
        <trans-unit id="9db95a6438006f1577a3a34c3e5ca51f2b813d05" translate="yes" xml:space="preserve">
          <source>Abstraction for Java version dependent ClassValue implementations.</source>
          <target state="translated">Java 버전 종속 ClassValue 구현에 대한 추상화.</target>
        </trans-unit>
        <trans-unit id="a3096472fc4309d4545d7243ff1ebdb443cf0c34" translate="yes" xml:space="preserve">
          <source>Accepted Properties...</source>
          <target state="translated">허용 된 속성 ...</target>
        </trans-unit>
        <trans-unit id="3f7f88af3a8143a862663a17396bd1f21d7fb44c" translate="yes" xml:space="preserve">
          <source>Accepted Properties... group? source ((sourceProperty) | (sourceEvent sourceValue)) (target targetProperty)? (? use default javabeans property if targetProperty is not present?)</source>
          <target state="translated">허용 된 속성 ... 그룹? 소스 ((sourceProperty) | (sourceEvent sourceValue)) (대상 targetProperty)? (? targetProperty가없는 경우 기본 javabeans 속성을 사용 하시겠습니까?)</target>
        </trans-unit>
        <trans-unit id="2fa4d2b71f9b36e0ec08477ae79a200aeda2dea4" translate="yes" xml:space="preserve">
          <source>Accepts a connection and passes the resulting Socket to the closure which runs in a new Thread or the calling thread, as needed.</source>
          <target state="translated">연결을 수락하고 필요에 따라 결과 Socket을 새 스레드 또는 호출 스레드에서 실행되는 클로저로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="2e4032d634920b2841b825ea6370cf5ed9b879bb" translate="yes" xml:space="preserve">
          <source>Accepts a connection and passes the resulting Socket to the closure which runs in a new Thread.</source>
          <target state="translated">연결을 수락하고 결과 Socket을 새 스레드에서 실행되는 클로저로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="29c58decf494e0250cba52549919cb4e9ae0f84d" translate="yes" xml:space="preserve">
          <source>Access the return type for this method</source>
          <target state="translated">이 메서드의 반환 유형에 액세스</target>
        </trans-unit>
        <trans-unit id="85faed1d5df6c3365168b3db7c196c80dded0591" translate="yes" xml:space="preserve">
          <source>Access to the GroovyDoc tool from Ant.</source>
          <target state="translated">Ant에서 GroovyDoc 도구에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="cd3d773db8248b8cf242eb75dafdd3ed0b6ebc14" translate="yes" xml:space="preserve">
          <source>According to the initial entry count, calculate the initial capacity of hash map, which is power of 2 (SEE https://stackoverflow.com/questions/8352378/why-does-hashmap-require-that-the-initial-capacity-be-a-power-of-two)</source>
          <target state="translated">초기 항목 수에 따라 2의 거듭 제곱 인 해시 맵의 초기 용량을 계산합니다 (https://stackoverflow.com/questions/8352378/why-does-hashmap-require-that-the-initial-capacity- 참조). 2의 거듭 제곱)</target>
        </trans-unit>
        <trans-unit id="198a121a1937a7b234221a96faf83ed76c1555f5" translate="yes" xml:space="preserve">
          <source>Accumulates the elements of stream into a new List.</source>
          <target state="translated">스트림의 요소를 새 목록에 누적합니다.</target>
        </trans-unit>
        <trans-unit id="29e564eaba5209d86b74024711021340489f35a2" translate="yes" xml:space="preserve">
          <source>Accumulates the elements of stream into a new Set.</source>
          <target state="translated">스트림의 요소를 새 세트로 축적합니다.</target>
        </trans-unit>
        <trans-unit id="c7341c99f5edf01729e1e0990500962c2dce957d" translate="yes" xml:space="preserve">
          <source>ActionListener</source>
          <target state="translated">ActionListener</target>
        </trans-unit>
        <trans-unit id="1ae1a45bd87aa1a40f027ca0d57bcbde6ede8763" translate="yes" xml:space="preserve">
          <source>Adapted from ConcurrentHashMap (Doug Lea)</source>
          <target state="translated">ConcurrentHashMap (Doug Lea)에서 수정</target>
        </trans-unit>
        <trans-unit id="9ef4bad019492bab7685f6badc7ddccbdeaba4c4" translate="yes" xml:space="preserve">
          <source>AdaptingMetaClass</source>
          <target state="translated">AdaptingMetaClass</target>
        </trans-unit>
        <trans-unit id="34b98767738f3900382e3ba13e1f1232d2340a0a" translate="yes" xml:space="preserve">
          <source>Adapts Grails taglibs for use in the template engine. An adapter may be created like this:</source>
          <target state="translated">템플릿 엔진에서 사용하기 위해 Grails taglibs를 조정합니다. 어댑터는 다음과 같이 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd2d5398ed0110f6eb20d29713c1b0cfd8ae9097" translate="yes" xml:space="preserve">
          <source>Add a Character and a Number.</source>
          <target state="translated">문자와 숫자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="971e11b4dfe87679ad6c69fadcd5ee74f7902b08" translate="yes" xml:space="preserve">
          <source>Add a Character and a Number. The ordinal value of the Character is used in the addition (the ordinal value is the unicode value which for simple character sets is the ASCII value). This operation will always create a new object for the result, while the operands remain unchanged.</source>
          <target state="translated">문자와 숫자를 추가합니다. 문자의 서수 값이 추가에 사용됩니다 (서수 값은 단순 문자 집합의 경우 ASCII 값인 유니 코드 값입니다). 이 연산은 항상 결과에 대한 새 객체를 생성하지만 피연산자는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="efdebe2ec0231c052bc36d0f533d20bf6b82afe4" translate="yes" xml:space="preserve">
          <source>Add a Number and a Character.</source>
          <target state="translated">숫자와 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="87e4095a314431e0de2742ef5fd59c145c9145ce" translate="yes" xml:space="preserve">
          <source>Add a Number and a Character. The ordinal value of the Character is used in the addition (the ordinal value is the unicode value which for simple character sets is the ASCII value).</source>
          <target state="translated">숫자와 문자를 추가합니다. 문자의 서수 값이 추가에 사용됩니다 (서수 값은 단순 문자 집합의 경우 ASCII 값인 유니 코드 값입니다).</target>
        </trans-unit>
        <trans-unit id="ff0f5c63f03ae22c44cd3bef3f2fe229577da518" translate="yes" xml:space="preserve">
          <source>Add a PropertyChangeListener to the listener list.</source>
          <target state="translated">리스너 목록에 PropertyChangeListener를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f3b2830c75ebdb5edf85d21ded9c3bf06d9ca348" translate="yes" xml:space="preserve">
          <source>Add a constructed class node as a placeholder to resolve outer nested class further.</source>
          <target state="translated">생성 된 클래스 노드를 자리 표시 자로 추가하여 외부 중첩 클래스를 추가로 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e9d40252ec0609a021142d9288201078cb898bf4" translate="yes" xml:space="preserve">
          <source>Add a method and mark it as &lt;code&gt;@Generated&lt;/code&gt;.</source>
          <target state="translated">메서드를 추가하고 &lt;code&gt;@Generated&lt;/code&gt; 로 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="26b52bf160b4606debb1d91d48d8d8d6cc26f2fc" translate="yes" xml:space="preserve">
          <source>Add a method that is marked as &lt;code&gt;@Generated&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@Generated&lt;/code&gt; 로 표시된 메서드를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="25a982d0e8b09cd90c2380a7a175f50c4bf085e7" translate="yes" xml:space="preserve">
          <source>Add a nodeCompletion delegate so it can intercept nodes after they done with building.</source>
          <target state="translated">노드가 빌드를 마친 후 가로 챌 수 있도록 nodeCompletion 델리게이트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9224663269d73dd9141326e8f6bed6cb908b4a10" translate="yes" xml:space="preserve">
          <source>Add a nodeCompletion delegate so it can intercept nodes after they done with building. NodeCompletion delegates are fired in a FILO pattern, so that nested delegates get first crack.</source>
          <target state="translated">노드가 빌드를 마친 후 가로 챌 수 있도록 nodeCompletion 델리게이트를 추가합니다. NodeCompletion 델리게이트는 FILO 패턴으로 실행되므로 중첩 된 델리게이트가 첫 번째 크랙을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="c756c69ecf72f9c5cc4bbdb15a1b56d5a57bdcc8" translate="yes" xml:space="preserve">
          <source>Add a number of days to this date and returns the new date.</source>
          <target state="translated">이 날짜에 일 수를 더하고 새 날짜를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="72f7f48be699ee0caacc4368359aa3739b814590" translate="yes" xml:space="preserve">
          <source>Add a postInstantiate delegate so it can intercept nodes after they are created.</source>
          <target state="translated">노드가 생성 된 후 가로 챌 수 있도록 postInstantiate 델리게이트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ae731944d2b4cb8f04921b135f1af71ec064d6fa" translate="yes" xml:space="preserve">
          <source>Add a postInstantiate delegate so it can intercept nodes after they are created. PostInstantiate delegates are fired in a FILO pattern, so that nested delegates get first crack.</source>
          <target state="translated">노드가 생성 된 후 가로 챌 수 있도록 postInstantiate 델리게이트를 추가합니다. PostInstantiate 델리게이트는 FILO 패턴으로 실행되므로 중첩 된 델리게이트가 먼저 크랙됩니다.</target>
        </trans-unit>
        <trans-unit id="9414867aae63b1c3038d13cd5ea9d932eb2d9a5c" translate="yes" xml:space="preserve">
          <source>Add a preInstantiate delegate so it can intercept nodes before they are created.</source>
          <target state="translated">노드가 생성되기 전에 가로 챌 수 있도록 사전 인스턴스화 델리게이트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="10f83f1c985c240651ea40286e484dd2b6a877da" translate="yes" xml:space="preserve">
          <source>Add a preInstantiate delegate so it can intercept nodes before they are created. PreInstantiate delegates are fired in a FILO pattern, so that nested delegates get first crack.</source>
          <target state="translated">노드가 생성되기 전에 가로 챌 수 있도록 사전 인스턴스화 델리게이트를 추가합니다. PreInstantiate 델리게이트는 FILO 패턴으로 실행되므로 중첩 된 델리게이트가 먼저 크랙됩니다.</target>
        </trans-unit>
        <trans-unit id="0b24c5c6b8f61a592ce1ef96d1577d2a57fa8f34" translate="yes" xml:space="preserve">
          <source>Add an attribute delegate so it can intercept attributes being set.</source>
          <target state="translated">설정되는 속성을 가로 챌 수 있도록 속성 위임을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="9430cc1d509e1fafb92dc368af4b8db814410ff7" translate="yes" xml:space="preserve">
          <source>Add an attribute delegate so it can intercept attributes being set. Attribute delegates are fired in a FILO pattern, so that nested delegates get first crack.</source>
          <target state="translated">설정되는 속성을 가로 챌 수 있도록 속성 위임을 추가하십시오. 속성 델리게이트는 FILO 패턴으로 시작되므로 중첩 된 델리게이트가 먼저 크랙됩니다.</target>
        </trans-unit>
        <trans-unit id="b013efb40f4289af7e4cd1018ce50701234c7487" translate="yes" xml:space="preserve">
          <source>Add an inner class that is marked as &lt;code&gt;@Generated&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@Generated&lt;/code&gt; 로 표시된 내부 클래스를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="17c098e16b28af2fc64279c3b10cb0f261271d3a" translate="yes" xml:space="preserve">
          <source>Add another element to the initializer expressions</source>
          <target state="translated">이니셜 라이저 표현식에 다른 요소 추가</target>
        </trans-unit>
        <trans-unit id="1f10ade6105a8b2a03b4d1593e3fc5c042036a71" translate="yes" xml:space="preserve">
          <source>Add listeners to a specific object.</source>
          <target state="translated">특정 객체에 리스너를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="45411891c3c88d7642e25dbbbcc21a4afaa8fe6d" translate="yes" xml:space="preserve">
          <source>Add listeners to a specific object. Updates the bould flags and update set</source>
          <target state="translated">특정 객체에 리스너를 추가합니다. bould 플래그 및 업데이트 세트 업데이트</target>
        </trans-unit>
        <trans-unit id="a7396e86f052dd1f498968edbee8957d61aac1da" translate="yes" xml:space="preserve">
          <source>Add methods from the super class.</source>
          <target state="translated">수퍼 클래스에서 메서드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="55b871a6a840cdb446acc6659ab88ab1b0f92b1a" translate="yes" xml:space="preserve">
          <source>Add number of days to this Timestamp and returns the new Timestamp object.</source>
          <target state="translated">이 Timestamp에 일 수를 추가하고 새 Timestamp 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4ea7e37a513f833e593139c9408cbb8cd0865a7a" translate="yes" xml:space="preserve">
          <source>Add one Character to another.</source>
          <target state="translated">한 캐릭터를 다른 캐릭터에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="860157d69bab2298c4fe7b14e3cbd15007041bc4" translate="yes" xml:space="preserve">
          <source>Add one Character to another. The ordinal values of the Characters are used in the addition (the ordinal value is the unicode value which for simple character sets is the ASCII value). This operation will always create a new object for the result, while the operands remain unchanged.</source>
          <target state="translated">한 캐릭터를 다른 캐릭터에 추가합니다. 문자의 서수 값이 추가에 사용됩니다 (서수 값은 단순 문자 세트의 경우 ASCII 값인 유니 코드 값입니다). 이 연산은 항상 결과에 대한 새 객체를 생성하지만 피연산자는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e7e099ea3de9feff1afdedae22b5d86e2147ce6" translate="yes" xml:space="preserve">
          <source>Add the FilterChain element.</source>
          <target state="translated">FilterChain 요소를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="585de26ca09b1db132989a22ba92f62fad71445a" translate="yes" xml:space="preserve">
          <source>Add the configured nested javac task if present to initiate joint compilation.</source>
          <target state="translated">공동 컴파일을 시작하려면 구성된 중첩 javac 작업을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6b1509a5b2c62640e11dfe472c4725a03b939847" translate="yes" xml:space="preserve">
          <source>Add two numbers and return the result.</source>
          <target state="translated">두 개의 숫자를 더하고 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f07ff3c85ababa2b232c6e2b2c2aa9be95800dab" translate="yes" xml:space="preserve">
          <source>Added code includes:</source>
          <target state="translated">추가 된 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43d8de82f921f67b75e7f8e08253a39be78c388f" translate="yes" xml:space="preserve">
          <source>Additional Java 9 based functions will be added here as needed.</source>
          <target state="translated">필요에 따라 추가 Java 9 기반 기능이 여기에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6743184994ad7dc844a3688a662abbb51037bd8f" translate="yes" xml:space="preserve">
          <source>Additional methods/constructors as needed for default parameters</source>
          <target state="translated">기본 매개 변수에 필요한 추가 메서드 / 생성자</target>
        </trans-unit>
        <trans-unit id="9bdd71ccfad440561b1037e9c1a6b55ff165c795" translate="yes" xml:space="preserve">
          <source>Additional usage examples can be found in the unit test for this class.</source>
          <target state="translated">추가 사용 예제는이 클래스의 단위 테스트에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d709ca49f43a930b4c18af06f476182c95b8982" translate="yes" xml:space="preserve">
          <source>Additionally it adds corresponding fire&amp;lt;Event&amp;gt; methods.</source>
          <target state="translated">또한 해당하는 fire &amp;lt;Event&amp;gt; 메서드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c21d3bd942e701cddbaedcb8f6328a219ec409a2" translate="yes" xml:space="preserve">
          <source>Additionally, closures are polymorphic. This means that a single closure can be used with different, valid, parameter signatures. A typical use case can be found when a closure accepts either a &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map/Entry.html&quot;&gt;Entry&lt;/a&gt; or a (key,value) pair, like the &lt;a href=&quot;../../../org/codehaus/groovy/runtime/defaultgroovymethods#each(java.util.Map,%20groovy.lang.Closure)&quot;&gt;DefaultGroovyMethods.each&lt;/a&gt; method.</source>
          <target state="translated">또한 클로저는 다형성입니다. 이는 단일 클로저가 다른 유효한 매개 변수 시그니처와 함께 사용될 수 있음을 의미합니다. 일반적인 사용 사례는 &lt;a href=&quot;../../../org/codehaus/groovy/runtime/defaultgroovymethods#each(java.util.Map,%20groovy.lang.Closure)&quot;&gt;DefaultGroovyMethods.each&lt;/a&gt; 메서드 와 같이 클로저가 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Map/Entry.html&quot;&gt;Entry&lt;/a&gt; 또는 (key, value) 쌍을 수락 할 때 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b9030d66dcea4e7a0756a4773c4c2285a635a78" translate="yes" xml:space="preserve">
          <source>Additionally, single char strings are converted to 'char' types.</source>
          <target state="translated">또한 단일 문자 문자열은 'char'유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="32c22464bc5c9230cba83a8dad55e5b9bc21a9e8" translate="yes" xml:space="preserve">
          <source>Adds GroovyCollections#combinations(Iterable) as a method on Iterables.</source>
          <target state="translated">Iterables에서 GroovyCollections # combinations (Iterable)를 메서드로 추가합니다.</target>
        </trans-unit>
        <trans-unit id="622f36b50c41b13074ec524a74ab9a63ddfe8f53" translate="yes" xml:space="preserve">
          <source>Adds GroovyCollections#combinations(Iterable, Closure) as a method on collections.</source>
          <target state="translated">컬렉션에 대한 메서드로 GroovyCollections # combinations (Iterable, Closure)를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8543cd300997d3a61fbc82c2d1dabd2424df6e9b" translate="yes" xml:space="preserve">
          <source>Adds GroovyCollections#transpose(List) as a method on lists.</source>
          <target state="translated">GroovyCollections # transpose (List)를 목록의 메서드로 추가합니다.</target>
        </trans-unit>
        <trans-unit id="affeb38fcb1ce41bc2ffcfeeb7c47d0d10bbb729" translate="yes" xml:space="preserve">
          <source>Adds GroovyCollections#transpose(List) as a method on lists. A Transpose Function takes a collection of columns and returns a collection of rows. The first row consists of the first element from each column. Successive rows are constructed similarly.</source>
          <target state="translated">GroovyCollections # transpose (List)를 목록의 메서드로 추가합니다. Transpose 함수는 열 컬렉션을 취하고 행 컬렉션을 반환합니다. 첫 번째 행은 각 열의 첫 번째 요소로 구성됩니다. 연속 행은 유사하게 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3f333155336d240c70bc2c9256d79657ff86cc35" translate="yes" xml:space="preserve">
          <source>Adds a &quot;metaClass&quot; property to all class objects so you can use the syntax &lt;code&gt;String.metaClass.myMethod = { println &quot;foo&quot; }&lt;/code&gt;</source>
          <target state="translated">모든 클래스 개체에 &quot;metaClass&quot;속성을 추가하여 &lt;code&gt;String.metaClass.myMethod = { println &quot;foo&quot; }&lt;/code&gt; 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d37567280534f469fe3060dc41b81ef6bd9792e" translate="yes" xml:space="preserve">
          <source>Adds a ClassNode directly to the unit (ie. without source).</source>
          <target state="translated">ClassNode를 유닛에 직접 추가합니다 (즉, 소스없이).</target>
        </trans-unit>
        <trans-unit id="7c0bd2537a1c7fee9a1b8644f75be4ba97a13afd" translate="yes" xml:space="preserve">
          <source>Adds a ClassNode directly to the unit (ie. without source). WARNING: the source is needed for error reporting, using this method without setting a SourceUnit will cause NullPinterExceptions</source>
          <target state="translated">ClassNode를 유닛에 직접 추가합니다 (즉, 소스없이). 경고 : 오류보고를 위해 소스가 필요합니다. SourceUnit을 설정하지 않고이 메서드를 사용하면 NullPinterExceptions가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f07ef578fba1a1a57eb09f15aa263b8151776984" translate="yes" xml:space="preserve">
          <source>Adds a InputStream source to the unit.</source>
          <target state="translated">장치에 InputStream 소스를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="55c2dedeec4b45a3bee93ecf9586ccd6f773b0a5" translate="yes" xml:space="preserve">
          <source>Adds a SourceUnit to the unit.</source>
          <target state="translated">장치에 SourceUnit을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4325ba7bbea3f8a1bb2605eac42b31c8da81c1c9" translate="yes" xml:space="preserve">
          <source>Adds a class to the unit.</source>
          <target state="translated">유닛에 클래스를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="15c397b088c3ae3939636b4075f32ab2abbac77e" translate="yes" xml:space="preserve">
          <source>Adds a classpath to this configuration.</source>
          <target state="translated">이 구성에 클래스 경로를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="de0a60e6a3a63e79727a0606a15f8c528baa87a7" translate="yes" xml:space="preserve">
          <source>Adds a classpath to this configuration. It expects a string with multiple paths, separated by the system dependent path separator. Expands wildcards, e.g. dir/* into all the jars in dir.</source>
          <target state="translated">이 구성에 클래스 경로를 추가합니다. 시스템 종속 경로 구분 기호로 구분 된 여러 경로가있는 문자열이 필요합니다. 와일드 카드, 예를 들어 dir / *를 dir의 모든 jar로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="d6ec1a9bec8789dd9bfa1e20baad755a660cc399" translate="yes" xml:space="preserve">
          <source>Adds a closure based column to the table</source>
          <target state="translated">테이블에 마감 기반 열을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e28c9855e1e9f8052ccd1ff3fb59953efaab2fa8" translate="yes" xml:space="preserve">
          <source>Adds a file to the classpath if it exists.</source>
          <target state="translated">파일이있는 경우 클래스 경로에 파일을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="077534ba208a87f4f806adaab8378cc410ee7ebc" translate="yes" xml:space="preserve">
          <source>Adds a fileset (nested fileset attribute) which should represent a single source file.</source>
          <target state="translated">단일 소스 파일을 나타내야하는 파일 세트 (중첩 된 파일 세트 속성)를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7f693b96e7c318c7f928add35c63bafbbc361124" translate="yes" xml:space="preserve">
          <source>Adds a groovy.lang.Closure to test whether the stack trace element should be added or not.</source>
          <target state="translated">스택 추적 요소를 추가해야하는지 여부를 테스트하기 위해 groovy.lang.Closure를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2d115a47162fc60bc22d2615e4dd2dbc854b804c" translate="yes" xml:space="preserve">
          <source>Adds a listener for constant meta classes.</source>
          <target state="translated">상수 메타 클래스에 대한 리스너를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="933ad0a810a7371d2f6470fe46c4aa5105bdd0f3" translate="yes" xml:space="preserve">
          <source>Adds a listener for constant meta classes. This listener cannot be removed!</source>
          <target state="translated">상수 메타 클래스에 대한 리스너를 추가합니다. 이 리스너는 제거 할 수 없습니다!</target>
        </trans-unit>
        <trans-unit id="77afc5cc9cefb60e10bc34080d825d1d59099514" translate="yes" xml:space="preserve">
          <source>Adds a meta class change listener for constant meta classes</source>
          <target state="translated">상수 메타 클래스에 대한 메타 클래스 변경 리스너 추가</target>
        </trans-unit>
        <trans-unit id="e98f5c67718a98e9e120d79d612278af10ebea70" translate="yes" xml:space="preserve">
          <source>Adds a meta class change listener for constant meta classes.</source>
          <target state="translated">상수 메타 클래스에 대한 메타 클래스 변경 리스너를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9e18c21d2db3d7d94189e0601f56e96e23c5f91c" translate="yes" xml:space="preserve">
          <source>Adds a meta class change listener for constant meta classes. This listener cannot be removed!</source>
          <target state="translated">상수 메타 클래스에 대한 메타 클래스 변경 리스너를 추가합니다. 이 리스너는 제거 할 수 없습니다!</target>
        </trans-unit>
        <trans-unit id="c0c4c1e169a1914aa6d390234e2f2666e12f6034" translate="yes" xml:space="preserve">
          <source>Adds a metaclass to the registry for the given class</source>
          <target state="translated">주어진 클래스의 레지스트리에 메타 클래스를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="99a868fc9b1a33548d48748e476174c30459d5de" translate="yes" xml:space="preserve">
          <source>Adds a new MapItemValue to the mapping.</source>
          <target state="translated">매핑에 새 MapItemValue를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b2ae5450b73f55c541be7e3983fef0b4ffa18242" translate="yes" xml:space="preserve">
          <source>Adds a new MetaBeanProperty to the MetaClass</source>
          <target state="translated">MetaClass에 새로운 MetaBeanProperty를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b6d707c67c54ef5c0e14f8140683a99c23f413c9" translate="yes" xml:space="preserve">
          <source>Adds a new MetaMethod to the MetaClass</source>
          <target state="translated">MetaClass에 새 MetaMethod를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1c9ceac8d1cfe96cb630d908cc4164335ad9c70a" translate="yes" xml:space="preserve">
          <source>Adds a new cell to the current grid</source>
          <target state="translated">현재 그리드에 새 셀을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="57c106f6ed87c3d07e323c0bb1554a89debbfd97" translate="yes" xml:space="preserve">
          <source>Adds a new cell to this row</source>
          <target state="translated">이 행에 새 셀을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="862e49eb113e9c46ad5ecdb684673471614294d1" translate="yes" xml:space="preserve">
          <source>Adds a new column definition to the table</source>
          <target state="translated">테이블에 새 열 정의를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="93a5b904f35f0867cbc98945fbee6ce2c1f9a78f" translate="yes" xml:space="preserve">
          <source>Adds a new field:</source>
          <target state="translated">새 필드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="54ae8261db9ec4dab0bd6ea61ec384cacec870d7" translate="yes" xml:space="preserve">
          <source>Adds a new field: &lt;code&gt;&quot;protected final java.beans.VetoableChangeSupport this$vetoableChangeSupport = new java.beans.VetoableChangeSupport(this)&quot;&lt;/code&gt;</source>
          <target state="translated">새 필드 추가 : &lt;code&gt;&quot;protected final java.beans.VetoableChangeSupport this$vetoableChangeSupport = new java.beans.VetoableChangeSupport(this)&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61bb71211a6955be3c0a6157c82208f71b35dbbf" translate="yes" xml:space="preserve">
          <source>Adds a new line to the output.</source>
          <target state="translated">출력에 새 줄을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a9fc9150b7e57635cda6dadc1a5dae684e3e10e6" translate="yes" xml:space="preserve">
          <source>Adds a new line to the output. The new line string can be configured by &lt;a href=&quot;templateconfiguration#setNewLineString(String)&quot;&gt;TemplateConfiguration.setNewLineString&lt;/a&gt;</source>
          <target state="translated">출력에 새 줄을 추가합니다. 새 줄 문자열은 &lt;a href=&quot;templateconfiguration#setNewLineString(String)&quot;&gt;TemplateConfiguration.setNewLineString&lt;/a&gt; 으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4249c9fc66429a890eb5c12b170e791f6471af09" translate="yes" xml:space="preserve">
          <source>Adds a new row to the result set</source>
          <target state="translated">결과 세트에 새 행을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9e1927e5bd68b45783f51a62459821c3aea13647" translate="yes" xml:space="preserve">
          <source>Adds a new row to this result set</source>
          <target state="translated">이 결과 세트에 새 행을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a68e103bc085d9f1c495be0fa275c332a77f419f" translate="yes" xml:space="preserve">
          <source>Adds a new syntax error to the source unit and then continues.</source>
          <target state="translated">소스 장치에 새 구문 오류를 추가 한 다음 계속합니다.</target>
        </trans-unit>
        <trans-unit id="b74052825147a96e3fb369517254763029004481" translate="yes" xml:space="preserve">
          <source>Adds a non-fatal error to the message set, which may cause a failure if the error threshold is exceeded.</source>
          <target state="translated">치명적이지 않은 오류를 메시지 세트에 추가하여 오류 임계 값을 초과하면 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5174a7ed89449d41435f1eaa14004d17169cef7f" translate="yes" xml:space="preserve">
          <source>Adds a non-fatal error to the message set, which may cause a failure if the error threshold is exceeded. The message is not required to have a source line and column specified, but it is best practice to try and include that information.</source>
          <target state="translated">치명적이지 않은 오류를 메시지 세트에 추가하여 오류 임계 값을 초과하면 실패 할 수 있습니다. 메시지에 소스 행과 열을 지정하지 않아도되지만 해당 정보를 포함하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a55880900bef2fd0eb484467d7a30f6468c61c8b" translate="yes" xml:space="preserve">
          <source>Adds a path for source compilation.</source>
          <target state="translated">소스 컴파일 경로를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="89c2758992be4838224a0630279bf324a908cb50" translate="yes" xml:space="preserve">
          <source>Adds a path to sourcepath.</source>
          <target state="translated">소스 경로에 경로를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="43072a1ac687237623935e80f4a099aa90546de5" translate="yes" xml:space="preserve">
          <source>Adds a path to the classpath.</source>
          <target state="translated">클래스 경로에 경로를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ea460ac601da23815bf1dae9e185f9dd939a70e1" translate="yes" xml:space="preserve">
          <source>Adds a property model column to the table</source>
          <target state="translated">테이블에 속성 모델 열을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ab7e6c2ba7edd7282d6eefc645fa56727442cfc9" translate="yes" xml:space="preserve">
          <source>Adds a reference to a classpath defined elsewhere.</source>
          <target state="translated">다른 곳에 정의 된 클래스 경로에 대한 참조를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="bd752faa06ef3efea25a0107e68d418900a91285" translate="yes" xml:space="preserve">
          <source>Adds a reference to a source path defined elsewhere.</source>
          <target state="translated">다른 곳에 정의 된 소스 경로에 대한 참조를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8bd310bb74ee50d33a2d23081619210608e2058e" translate="yes" xml:space="preserve">
          <source>Adds a set of file paths to the unit.</source>
          <target state="translated">장치에 파일 경로 세트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="280ec9857814e18982183d36e42bebb6b3f882ae" translate="yes" xml:space="preserve">
          <source>Adds a set of files (nested fileset attribute).</source>
          <target state="translated">파일 세트 (중첩 된 파일 세트 속성)를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8eaedb0b1a761e9b0c51041eaa5f2d8464a6a35b" translate="yes" xml:space="preserve">
          <source>Adds a set of source files to the unit.</source>
          <target state="translated">장치에 소스 파일 세트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0cff1a367e2d80ad55141a27b7d67eed1ceff396" translate="yes" xml:space="preserve">
          <source>Adds a source file to the unit.</source>
          <target state="translated">장치에 소스 파일을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4488c0062d5d1c2eef0d286aee97b46b30b4f16a" translate="yes" xml:space="preserve">
          <source>Adds a statement to the object initializer.</source>
          <target state="translated">개체 이니셜 라이저에 문을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6b09666e9af864b73f1b98ab2449eb6269b6f78e" translate="yes" xml:space="preserve">
          <source>Adds a synthetic method as part of the compilation process.</source>
          <target state="translated">컴파일 프로세스의 일부로 합성 방법을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8ee466fb53224c4d1d330440518d1f7489ce7008" translate="yes" xml:space="preserve">
          <source>Adds a type checking error, which will be displayed to the user during compilation.</source>
          <target state="translated">컴파일 중에 사용자에게 표시되는 유형 검사 오류를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="5516b9e98cbe7d8f7ce982ce74c0d2558b7d086a" translate="yes" xml:space="preserve">
          <source>Adds a type transformer applied at runtime.</source>
          <target state="translated">런타임에 적용되는 유형 변환기를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c8e37f34432046a2040d49af9fab77a2d56cc29b" translate="yes" xml:space="preserve">
          <source>Adds a type transformer applied at runtime. This method handles transformations to String from GString, array transformations and number based transformations</source>
          <target state="translated">런타임에 적용되는 유형 변환기를 추가합니다. 이 메소드는 GString, 배열 변환 및 숫자 기반 변환에서 문자열로의 변환을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="352c2a4dbe34873e888de860ff016cd6a7ea0c98" translate="yes" xml:space="preserve">
          <source>Adds a warning to the message set if it is relevant.</source>
          <target state="translated">관련된 경우 메시지 세트에 경고를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a10adfc7e1a7598c21fca91117d008784c3b900c" translate="yes" xml:space="preserve">
          <source>Adds a warning to the message set.</source>
          <target state="translated">메시지 세트에 경고를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="923e07793c63842ed9ce7916150da9b3a1264270" translate="yes" xml:space="preserve">
          <source>Adds all children of the specified node to this one.</source>
          <target state="translated">지정된 노드의 모든 자식을이 노드에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="970c33328bc111a88151145b9583ef5bc07db631" translate="yes" xml:space="preserve">
          <source>Adds all children of the specified node to this one. Not all nodes support this operation!</source>
          <target state="translated">지정된 노드의 모든 자식을이 노드에 추가합니다. 모든 노드가이 작업을 지원하는 것은 아닙니다!</target>
        </trans-unit>
        <trans-unit id="c841bd3df0c87de44e418f0a639aad20dc1178d9" translate="yes" xml:space="preserve">
          <source>Adds all entries from the given Map to the registry.</source>
          <target state="translated">지정된 맵의 모든 항목을 레지스트리에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e0f736114d0fa1435ed61b60b9b0b82abc7d62d8" translate="yes" xml:space="preserve">
          <source>Adds all entries from the given Map to the registry. Any entries in the provided Map that contain a &lt;code&gt;null&lt;/code&gt; key or value will be ignored.</source>
          <target state="translated">지정된 맵의 모든 항목을 레지스트리에 추가합니다. &lt;code&gt;null&lt;/code&gt; 키 또는 값 을 포함하는 제공된 Map의 모든 항목은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0553d55bdb2d31b7efc6e98a40e8dea74e710047" translate="yes" xml:space="preserve">
          <source>Adds all items from the iterable to the Collection.</source>
          <target state="translated">이터 러블의 모든 항목을 컬렉션에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b5a558366d3b9a42034e3e1787e29b0b0eeadcd5" translate="yes" xml:space="preserve">
          <source>Adds all items from the iterator to the Collection.</source>
          <target state="translated">반복기의 모든 항목을 컬렉션에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6d367d408d24d93c1f3faaba3b98b0c9b817bbe3" translate="yes" xml:space="preserve">
          <source>Adds all the listeners to the objects in the bind path.</source>
          <target state="translated">바인드 경로의 객체에 모든 리스너를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4636a043cd5febbd582b8a4e1785638046ae3503" translate="yes" xml:space="preserve">
          <source>Adds all the listeners to the objects in the bind path. This assumes that we are not added as listeners to any of them, hence it is not idempotent.</source>
          <target state="translated">바인드 경로의 객체에 모든 리스너를 추가합니다. 이것은 우리가 그들 중 어느 것도 리스너로 추가되지 않았기 때문에 멱 등성이 아니라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f86946c13e935bc8bef2e91764f7aec3c4a856e2" translate="yes" xml:space="preserve">
          <source>Adds an element to the node.</source>
          <target state="translated">노드에 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="15155e5f874603299f71c8230b780b3449f24211" translate="yes" xml:space="preserve">
          <source>Adds an element to the node. Returns the element for convenience. Not all nodes support this operation!</source>
          <target state="translated">노드에 요소를 추가합니다. 편의를 위해 요소를 반환합니다. 모든 노드가이 작업을 지원하는 것은 아닙니다!</target>
        </trans-unit>
        <trans-unit id="f5e4a57a3faeaa02351b2faa3b470f3d325bb705" translate="yes" xml:space="preserve">
          <source>Adds an error to the message set and throws CompilationFailedException.</source>
          <target state="translated">메시지 세트에 오류를 추가하고 CompilationFailedException을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="5971faeecd1cad7e41281dd45e73863696f6edc2" translate="yes" xml:space="preserve">
          <source>Adds an error to the message set, but does not cause a failure.</source>
          <target state="translated">메시지 세트에 오류를 추가하지만 실패를 일으키지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="1456c7879be83d236e03c2c10b952671f5bda60b" translate="yes" xml:space="preserve">
          <source>Adds an error to the message set, but does not cause a failure. The message is not required to have a source line and column specified, but it is best practice to try and include that information.</source>
          <target state="translated">메시지 세트에 오류를 추가하지만 실패를 일으키지는 않습니다. 메시지에 소스 행과 열을 지정하지 않아도되지만 해당 정보를 포함하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cc1b8cb2bf936ee9b2df4daeb160a324a856b41a" translate="yes" xml:space="preserve">
          <source>Adds an object as a new child to this Node.</source>
          <target state="translated">이 노드에 개체를 새 자식으로 추가합니다.</target>
        </trans-unit>
        <trans-unit id="70ebb33118ee383fa9531be10a8005cb067af0fd" translate="yes" xml:space="preserve">
          <source>Adds an optionally-fatal error to the message set.</source>
          <target state="translated">선택적으로 치명적 오류를 메시지 세트에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="abfd2ccd977a11e94d67e0e1dde28ffd00ed6343" translate="yes" xml:space="preserve">
          <source>Adds an optionally-fatal error to the message set. The message is not required to have a source line and column specified, but it is best practice to try and include that information.</source>
          <target state="translated">선택적으로 치명적 오류를 메시지 세트에 추가합니다. 메시지에 소스 행과 열을 지정하지 않아도되지만 해당 정보를 포함하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ade1bf40d64188aeb3ba13cdae490830ed2c2fc6" translate="yes" xml:space="preserve">
          <source>Adds compilation customizers to the compilation process.</source>
          <target state="translated">컴파일 프로세스에 컴파일 커 스터 마이저를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a275b32bee77ab7572c17c184fc255aaeb7a86d6" translate="yes" xml:space="preserve">
          <source>Adds compilation customizers to the compilation process. A compilation customizer is a class node operation which performs various operations going from adding imports to access control.</source>
          <target state="translated">컴파일 프로세스에 컴파일 커 스터 마이저를 추가합니다. 컴파일 커 스터 마이 저는 가져 오기 추가에서 액세스 제어까지 다양한 작업을 수행하는 클래스 노드 작업입니다.</target>
        </trans-unit>
        <trans-unit id="f48103b99fc29aa0d3712d6c9be28f87445c4885" translate="yes" xml:space="preserve">
          <source>Adds explicit return statements to implicit return points in a closure. This is necessary since tail-recursion is detected by having the recursive call within the return statement.</source>
          <target state="translated">클로저의 암시 적 반환 지점에 명시 적 return 문을 추가합니다. 이는 return 문 내에서 재귀 호출을 통해 꼬리 재귀를 감지하기 때문에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8b3195f00c501b596f89c34d2338666cd78b30b5" translate="yes" xml:space="preserve">
          <source>Adds max() method to Iterable objects.</source>
          <target state="translated">Iterable 객체에 max () 메서드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="315a98a84d70841fb1c2e86f684d9ee53764e81d" translate="yes" xml:space="preserve">
          <source>Adds max() method to Iterator objects.</source>
          <target state="translated">Iterator 객체에 max () 메서드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8789b773ece07c50fb9828aef91c1a8f6652485e" translate="yes" xml:space="preserve">
          <source>Adds max() method to Iterator objects. The iterator will become exhausted of elements after determining the maximum value.</source>
          <target state="translated">Iterator 객체에 max () 메서드를 추가합니다. 이터레이터는 최대 값을 결정한 후 요소가 고갈됩니다.</target>
        </trans-unit>
        <trans-unit id="b49877ad8d9fdc83dab4b878af3f42e9f36354b2" translate="yes" xml:space="preserve">
          <source>Adds max() method to Object arrays.</source>
          <target state="translated">Object 배열에 max () 메서드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c981e3e52b76fa5be7516bdd06754f59303593a4" translate="yes" xml:space="preserve">
          <source>Adds methods from all interfaces.</source>
          <target state="translated">모든 인터페이스에서 메서드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="3fb74562e389d58d851d1360aaff75c76bdf3598" translate="yes" xml:space="preserve">
          <source>Adds methods from all interfaces. Existing entries in the methods map take precedence. Methods from interfaces visited early take precedence over later ones.</source>
          <target state="translated">모든 인터페이스에서 메서드를 추가합니다. 메소드 맵의 기존 항목이 우선합니다. 초기에 방문한 인터페이스의 메소드가 이후 인터페이스보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="3e6d50e050ec147d89c4b1933fb99fc7e5e1a174" translate="yes" xml:space="preserve">
          <source>Adds methods from interfaces and parent interfaces.</source>
          <target state="translated">인터페이스 및 부모 인터페이스에서 메서드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9ff95449b67529411428e381aeb98495847727a3" translate="yes" xml:space="preserve">
          <source>Adds methods from interfaces and parent interfaces. Existing entries in the methods map take precedence. Methods from interfaces visited early take precedence over later ones.</source>
          <target state="translated">인터페이스 및 부모 인터페이스에서 메서드를 추가합니다. 메소드 맵의 기존 항목이 우선합니다. 초기에 방문한 인터페이스의 메소드가 이후 인터페이스보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="1df0d752b61fd2e8c1ec76861e593fe2a2a7a557" translate="yes" xml:space="preserve">
          <source>Adds min() method to Collection objects.</source>
          <target state="translated">Collection 객체에 min () 메서드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ff738258a94de9b97e42a38c7491f209642b403d" translate="yes" xml:space="preserve">
          <source>Adds min() method to Iterator objects.</source>
          <target state="translated">Iterator 객체에 min () 메서드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6c1dd453c577aa03ae72c31982ab04eaa6c31458" translate="yes" xml:space="preserve">
          <source>Adds min() method to Iterator objects. The iterator will become exhausted of elements after determining the minimum value.</source>
          <target state="translated">Iterator 객체에 min () 메서드를 추가합니다. 이터레이터는 최소값을 결정한 후 요소가 고갈됩니다.</target>
        </trans-unit>
        <trans-unit id="f12cc233030e8f5ae5e9505ceb8a38eed6184f7a" translate="yes" xml:space="preserve">
          <source>Adds min() method to Object arrays.</source>
          <target state="translated">min () 메서드를 Object 배열에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6b0364c0ab8ad54f83ea3536a0bb60e06a79b41a" translate="yes" xml:space="preserve">
          <source>Adds navigable properties to the list of candidates if they match the prefix</source>
          <target state="translated">접두사와 일치하는 경우 탐색 가능한 속성을 후보 목록에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="cf5ecf45abc8d41f7688c3333a110bf0618c0f81" translate="yes" xml:space="preserve">
          <source>Adds or replaces the parent of the node.</source>
          <target state="translated">노드의 부모를 추가하거나 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="2d891a97aad8bf935d483fc483a04d54a0571d4c" translate="yes" xml:space="preserve">
          <source>Adds or replaces the value of the node.</source>
          <target state="translated">노드 값을 추가하거나 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="d7213b817e5d46d8984308a84bd3fbd319a806e2" translate="yes" xml:space="preserve">
          <source>Adds return statements to given method whenever an implicit return is detected.</source>
          <target state="translated">암시 적 반환이 감지 될 때마다 주어진 메서드에 return 문을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2629c2b77a1b4215201be89223b536828b6167f9" translate="yes" xml:space="preserve">
          <source>Adds sibling nodes (defined using builder-style notation via a Closure) after the current node.</source>
          <target state="translated">현재 노드 뒤에 형제 노드 (클로저를 통해 빌더 스타일 표기법을 사용하여 정의 됨)를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8b92579277858bb8dd28f3a2b9195a846f592d13" translate="yes" xml:space="preserve">
          <source>Adds the add&amp;lt;Listener&amp;gt; method like:</source>
          <target state="translated">다음과 같이 add &amp;lt;Listener&amp;gt; 메서드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e8699cfaac6b265ad6dd3cc3ea46a761e8972ad6" translate="yes" xml:space="preserve">
          <source>Adds the annotation to the internal target list if a match is found.</source>
          <target state="translated">일치하는 항목이있는 경우 내부 대상 목록에 주석을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="46943e448c9a4f86ea3887378cf0bb8c8cb201e7" translate="yes" xml:space="preserve">
          <source>Adds the class paths (if any)</source>
          <target state="translated">클래스 경로를 추가합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="7d8d344dead564652a5308927671c33eb95371e5" translate="yes" xml:space="preserve">
          <source>Adds the fire&amp;lt;Event&amp;gt; methods like:</source>
          <target state="translated">다음과 같은 fire &amp;lt;Event&amp;gt; 메소드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b6c526912e23b665b2d18226e053b601abc4ad64" translate="yes" xml:space="preserve">
          <source>Adds the get&amp;lt;Listener&amp;gt;s method like:</source>
          <target state="translated">다음과 같은 get &amp;lt;Listener&amp;gt; s 메소드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="daf5b60ed1d944638f0e4b6a64a49e1b6c5aeca4" translate="yes" xml:space="preserve">
          <source>Adds the necessary field and methods to support property change support.</source>
          <target state="translated">속성 변경 지원을 지원하는 데 필요한 필드 및 메서드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7856cca281003b001be6439903a31d9acb5eebd4" translate="yes" xml:space="preserve">
          <source>Adds the necessary field and methods to support vetoable change support.</source>
          <target state="translated">거부 가능한 변경 지원을 지원하기 위해 필요한 필드 및 방법을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f0a56bc012b1aefe0ccad93ba734f94cfa1d5ac6" translate="yes" xml:space="preserve">
          <source>Adds the provided map of key-value pairs as a new row in the table represented by this DataSet.</source>
          <target state="translated">제공된 키-값 쌍 맵을이 DataSet이 나타내는 테이블의 새 행으로 추가합니다.</target>
        </trans-unit>
        <trans-unit id="205d2650ad8cfaa505d72e784a17d1518adc5386" translate="yes" xml:space="preserve">
          <source>Adds the remove&amp;lt;Listener&amp;gt; method like:</source>
          <target state="translated">다음과 같이 remove &amp;lt;Listener&amp;gt; 메서드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f9a47c563cd88d13e26482c51a7e48261248e7c8" translate="yes" xml:space="preserve">
          <source>Adds the specified map of prefix to namespace mappings to this GPathResult.</source>
          <target state="translated">이 GPathResult에 대한 네임 스페이스 매핑에 지정된 접두사 맵을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="bafbf09055b90bf367dc5e748128460a117820c6" translate="yes" xml:space="preserve">
          <source>Adds the specified map of prefix to namespace mappings to this GPathResult. Already existing prefixes are overwritten.</source>
          <target state="translated">이 GPathResult에 대한 네임 스페이스 매핑에 지정된 접두사 맵을 추가합니다. 이미 존재하는 접두사를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="8c64d983f54c3db5bbe1a12ee7852b93764ca279" translate="yes" xml:space="preserve">
          <source>Adds the specified value to the queue.</source>
          <target state="translated">큐에 지정된 값을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="22fa78f53e0c3cac1443c275e1ffd327ebd35a01" translate="yes" xml:space="preserve">
          <source>Adds to result the identified tokens for the bufferLines</source>
          <target state="translated">bufferLines에 대해 식별 된 토큰을 결과에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d66eeda00ab3ed8777b4f45b95b55f5e3c509d1b" translate="yes" xml:space="preserve">
          <source>After every &lt;code&gt;batchSize&lt;/code&gt;&lt;code&gt;addBatch(params)&lt;/code&gt; operations, automatically calls an &lt;code&gt;executeBatch()&lt;/code&gt; operation to &quot;chunk&quot; up the database operations into partitions. Though not normally needed, you can also explicitly call &lt;code&gt;executeBatch()&lt;/code&gt; which after executing the current batch, resets the batch count back to zero.</source>
          <target state="translated">모든 &lt;code&gt;batchSize&lt;/code&gt; &lt;code&gt;addBatch(params)&lt;/code&gt; 작업 후, 자동으로 &lt;code&gt;executeBatch()&lt;/code&gt; 작업을 호출 하여 데이터베이스 작업을 파티션으로 &quot;청크&quot;합니다. 일반적으로 필요하지는 않지만 현재 배치를 실행 한 후 배치 카운트를 다시 0으로 재설정하는 &lt;code&gt;executeBatch()&lt;/code&gt; 를 명시 적으로 호출 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78548303c193f021502f4535342824bc61362a3b" translate="yes" xml:space="preserve">
          <source>After every &lt;code&gt;batchSize&lt;/code&gt;&lt;code&gt;addBatch(sqlBatchOperation)&lt;/code&gt; operations, automatically calls an &lt;code&gt;executeBatch()&lt;/code&gt; operation to &quot;chunk&quot; up the database operations into partitions. Though not normally needed, you can also explicitly call &lt;code&gt;executeBatch()&lt;/code&gt; which after executing the current batch, resets the batch count back to zero.</source>
          <target state="translated">모든 &lt;code&gt;batchSize&lt;/code&gt; &lt;code&gt;addBatch(sqlBatchOperation)&lt;/code&gt; 작업 후, 자동으로 &lt;code&gt;executeBatch()&lt;/code&gt; 작업을 호출 하여 데이터베이스 작업을 파티션으로 &quot;청크&quot;합니다. 일반적으로 필요하지는 않지만 현재 배치를 실행 한 후 배치 카운트를 다시 0으로 재설정하는 &lt;code&gt;executeBatch()&lt;/code&gt; 를 명시 적으로 호출 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63e70612889f8f630734b34c23a6c3bd9092da73" translate="yes" xml:space="preserve">
          <source>After performing the execute operation and making use of its return, it's necessary to free the resources allocated for the statement.</source>
          <target state="translated">실행 작업을 수행하고 반환 값을 사용한 후 문에 할당 된 리소스를 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="dce5b05b3c9f74aa330dfe30de1f89c36385e30b" translate="yes" xml:space="preserve">
          <source>After some type names, where zero or more empty bracket pairs are allowed.</source>
          <target state="translated">0 개 이상의 빈 대괄호 쌍이 허용되는 일부 유형 이름 뒤에.</target>
        </trans-unit>
        <trans-unit id="ea28b341f60dc0fc78fe87fa7b060a9366b5f70d" translate="yes" xml:space="preserve">
          <source>After some type names, where zero or more empty bracket pairs are allowed. We use ARRAY_DECLARATOR to represent this.</source>
          <target state="translated">0 개 이상의 빈 대괄호 쌍이 허용되는 일부 유형 이름 뒤에. 이것을 표현하기 위해 ARRAY_DECLARATOR를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8a8855c7badbfce3b9a940f42cf2a15ea1f44e47" translate="yes" xml:space="preserve">
          <source>After the AST transformation, the following code is passed on for further compilation:</source>
          <target state="translated">AST 변환 후 추가 컴파일을 위해 다음 코드가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="02b8d59b9d4b3f0f21ea21edf89b81e5d704f096" translate="yes" xml:space="preserve">
          <source>Alexander Day Chaffee</source>
          <target state="translated">Alexander Day Chaffee</target>
        </trans-unit>
        <trans-unit id="5df284f5cd3747df2bf87b9c4becc967d6c89ef6" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#equalsNullX(org.codehaus.groovy.ast.expr.Expression)&quot;&gt;equalsNullX(Expression)&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#equalsNullX(org.codehaus.groovy.ast.expr.Expression)&quot;&gt;equalsNullX (Expression)에&lt;/a&gt; 대한 별칭</target>
        </trans-unit>
        <trans-unit id="21d0844a01b17206e895d0139ce4129703416362" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#leftShift(groovy.lang.Closure)&quot;&gt;leftShift(Closure)&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#leftShift(groovy.lang.Closure)&quot;&gt;leftShift (Closure)에&lt;/a&gt; 대한 별칭</target>
        </trans-unit>
        <trans-unit id="f6b6a15e4ce07eb78e724466c079b10c4f61bc0c" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#rightShift(groovy.lang.Closure)&quot;&gt;rightShift(Closure)&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#rightShift(groovy.lang.Closure)&quot;&gt;rightShift (Closure)의&lt;/a&gt; 별칭</target>
        </trans-unit>
        <trans-unit id="924ec4ae43876c6837b75d49a36a09cab18f4050" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#setDisallowedTokens(java.util.List)&quot;&gt;setDisallowedTokens(List)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#setDisallowedTokens(java.util.List)&quot;&gt;setDisallowedTokens (List)의&lt;/a&gt; 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="54e60131a969d50ec08d79ea8bf8be93bbc7bec3" translate="yes" xml:space="preserve">
          <source>Alias for calling a Closure for non-closure arguments.</source>
          <target state="translated">비 클로저 인수에 대한 클로저를 호출하기위한 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="74ea21f9c0331e528cf28a8b829bf0e8dffbaf8d" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;ResultSetMetaData&lt;/code&gt; column methods taking a column index are available on a column either as a no-arg getter or via a property.</source>
          <target state="translated">열 인덱스를 사용하는 모든 &lt;code&gt;ResultSetMetaData&lt;/code&gt; 열 메서드는 인수가없는 getter 또는 속성을 통해 열에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adbd2168487dab7b4ddbc2cfdb81c97b55b9f439" translate="yes" xml:space="preserve">
          <source>All Implemented Interfaces and Traits:</source>
          <target state="translated">구현 된 모든 인터페이스 및 특성 :</target>
        </trans-unit>
        <trans-unit id="ed0203d6946d7c14ba9bce96c8bed4953c201838" translate="yes" xml:space="preserve">
          <source>All Superinterfaces:</source>
          <target state="translated">모든 수퍼 인터페이스 :</target>
        </trans-unit>
        <trans-unit id="d4752340319a5a80a009d39ec91aaa5cc10c2cf4" translate="yes" xml:space="preserve">
          <source>All classes and interfaces in this package optionally limited to just the included ones.</source>
          <target state="translated">이 패키지의 모든 클래스와 인터페이스는 포함 된 것으로 선택적으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="dd8f0c9b02fcad264b60f88cb2af68a2abb0b6d1" translate="yes" xml:space="preserve">
          <source>All implemented methods will throw an instance of this exception constructed using its no-arg constructor. You can also supply a single &lt;code&gt;message&lt;/code&gt; annotation attribute in which case the message will be passed as an argument during exception construction as shown in the following example:</source>
          <target state="translated">구현 된 모든 메서드는 인수가없는 생성자를 사용하여 생성 된이 예외의 인스턴스를 throw합니다. 다음 예제와 같이 예외 생성 중에 메시지가 인수로 전달되는 경우 단일 &lt;code&gt;message&lt;/code&gt; 주석 속성을 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a45f0ecda068e4ab25c217a981bf164448f9fc77" translate="yes" xml:space="preserve">
          <source>All included classes and interfaces in this package.</source>
          <target state="translated">이 패키지에 포함 된 모든 클래스 및 인터페이스.</target>
        </trans-unit>
        <trans-unit id="7194cd5b52d1d086dfc53e938b19b607c63b5eaf" translate="yes" xml:space="preserve">
          <source>All lines starting with &quot;#&quot; are ignored.</source>
          <target state="translated">&quot;#&quot;로 시작하는 모든 줄은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b2207a645d31589d307bc9c76fca55b9399871b3" translate="yes" xml:space="preserve">
          <source>All methods defined in the owner class (including static, abstract or private etc.) take precedence over methods with identical signatures from a &lt;code&gt;@Delegate&lt;/code&gt; target</source>
          <target state="translated">소유자 클래스에 정의 된 모든 메서드 (정적, 추상 또는 개인 등 포함)는 &lt;code&gt;@Delegate&lt;/code&gt; 대상의 동일한 서명이있는 메서드보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="80d5595485a0e9b821bd3e547179f7a6170b8a9e" translate="yes" xml:space="preserve">
          <source>All resources including the ResultSet are closed automatically after the closure is called.</source>
          <target state="translated">ResultSet을 포함한 모든 리소스는 클로저가 호출 된 후 자동으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="f67acc4eb2dc208a52d283fd4976112adb17c716" translate="yes" xml:space="preserve">
          <source>All templates compiled through &lt;a href=&quot;markuptemplateengine&quot;&gt;MarkupTemplateEngine&lt;/a&gt; extend this abstract class, which provides a number of utility methods to generate markup. An instance of this class can be obtained after calling &lt;a href=&quot;../template#make()&quot;&gt;Template.make&lt;/a&gt; or &lt;a href=&quot;../template#make(java.util.Map)&quot;&gt;Template.make&lt;/a&gt;)} on a template generated by &lt;a href=&quot;markuptemplateengine#createTemplate(java.io.Reader)&quot;&gt;MarkupTemplateEngine.createTemplate&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;markuptemplateengine&quot;&gt;MarkupTemplateEngine을&lt;/a&gt; 통해 컴파일 된 모든 템플릿 은 마크 업을 생성하는 여러 유틸리티 메서드를 제공하는이 추상 클래스를 확장합니다. 이 클래스의 인스턴스는 &lt;a href=&quot;markuptemplateengine#createTemplate(java.io.Reader)&quot;&gt;MarkupTemplateEngine.createTemplate에&lt;/a&gt; 의해 생성 된 템플릿에서 &lt;a href=&quot;../template#make()&quot;&gt;Template.make&lt;/a&gt; 또는 &lt;a href=&quot;../template#make(java.util.Map)&quot;&gt;Template.make&lt;/a&gt; )}를 호출 한 후에 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a0b23a3a0a76b980d2bc4725ad97a3d71c3c013" translate="yes" xml:space="preserve">
          <source>All variables bound the binding are passed to the template source text, e.g. the HTML file, when the template is merged.</source>
          <target state="translated">바인딩에 바인딩 된 모든 변수는 템플릿이 병합 될 때 HTML 파일과 같은 템플릿 소스 텍스트로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="41b13c4c07c1aca2b1158e8530db2da076e54102" translate="yes" xml:space="preserve">
          <source>AllTestSuite can be used in extension of GroovyTestSuite to execute TestCases written in Groovy from inside a Java IDE. AllTestSuite collects all files below a given directory that comply to a given pattern. From these files, a TestSuite is constructed that can be run via an IDE graphical Test runner. The files are assumed to be Groovy source files and be either a TestCase or a Script that can be wrapped transparently into a TestCase. The directory and the pattern can be set via System properties (see this classes' constants for details.)</source>
          <target state="translated">AllTestSuite는 GroovyTestSuite의 확장에서 사용되어 Java IDE 내부에서 Groovy로 작성된 TestCase를 실행할 수 있습니다. AllTestSuite는 주어진 패턴을 준수하는 주어진 디렉토리 아래의 모든 파일을 수집합니다. 이 파일에서 IDE 그래픽 테스트 실행기를 통해 실행할 수있는 TestSuite가 구성됩니다. 파일은 Groovy 소스 파일로 가정되며 TestCase 또는 TestCase에 투명하게 래핑 될 수있는 스크립트입니다. 디렉토리와 패턴은 시스템 속성을 통해 설정할 수 있습니다 (자세한 내용은이 클래스의 상수 참조).</target>
        </trans-unit>
        <trans-unit id="41876e13908c6cca5794d4d44f3da26ef34c3aba" translate="yes" xml:space="preserve">
          <source>Allow DefaultListModel to work with subscript operators.</source>
          <target state="translated">DefaultListModel이 첨자 연산자와 함께 작동하도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b085cdcd2b892d6f8579b365511607d2b4bd3d5e" translate="yes" xml:space="preserve">
          <source>Allow DefaultTableModel to work with subscript operators.</source>
          <target state="translated">DefaultTableModel이 아래 첨자 연산자와 함께 작동하도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a26255ed21cfbaec57975e3ebdf24c2d620a6645" translate="yes" xml:space="preserve">
          <source>Allow MutableComboBoxModel to work with subscript operators.</source>
          <target state="translated">MutableComboBoxModel이 첨자 연산자와 함께 작동하도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="43609ae75456d6c9b8a11d65a959d3eafaab875b" translate="yes" xml:space="preserve">
          <source>Allow MutableTreeNode to work with subscript operators.</source>
          <target state="translated">MutableTreeNode가 첨자 연산자와 함께 작동하도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="1f6d4ec730cbfbe1da39a1c369f4a3deb15f5dab" translate="yes" xml:space="preserve">
          <source>Allow an anonymous function to be declared and invoked</source>
          <target state="translated">익명 함수를 선언하고 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76166bbfcd99b17e85ed0fb65687de68ab8d1737" translate="yes" xml:space="preserve">
          <source>Allow automatic detection of namespace declared in the attributes</source>
          <target state="translated">속성에 선언 된 네임 스페이스의 자동 감지 허용</target>
        </trans-unit>
        <trans-unit id="0cec0e878b4a1cb5c308661468007ed126166b67" translate="yes" xml:space="preserve">
          <source>Allows &quot;interrupt-safe&quot; executions of scripts by adding Thread.currentThread().isInterrupted() checks into loops (for, while) and at the start of closures and methods.</source>
          <target state="translated">Thread.currentThread (). isInterrupted () 체크를 루프 (for, while)에 추가하고 클로저 및 메서드 시작시 스크립트의 &quot;중단 안전&quot;실행을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9ba7f583b1e87211c0be41617f91dc47a794b0bb" translate="yes" xml:space="preserve">
          <source>Allows &quot;interrupt-safe&quot; executions of scripts by adding Thread.currentThread().isInterrupted() checks on loops (for, while, do) and first statement of closures. By default, also adds an interrupt check statement on the beginning of method calls.</source>
          <target state="translated">루프 (for, while, do)에 대한 Thread.currentThread (). isInterrupted () 검사 및 첫 번째 클로저 문을 추가하여 스크립트의 &quot;중단 안전&quot;실행을 허용합니다. 기본적으로 메서드 호출 시작시 인터럽트 검사 문도 추가합니다.</target>
        </trans-unit>
        <trans-unit id="eb25d4b822908c2d73b13caf1632f30bc4b61e89" translate="yes" xml:space="preserve">
          <source>Allows &quot;interrupt-safe&quot; executions of scripts by adding a custom check for interruption into loops (for, while, ...) and at the start of closures and methods.</source>
          <target state="translated">루프 (for, while, ...)와 클로저 및 메소드 시작시 인터럽트에 대한 사용자 정의 검사를 추가하여 스크립트의 &quot;인터럽트 안전&quot;실행을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="80bd685ffe7df40fb08a5830871d3e4e4fd5edb3" translate="yes" xml:space="preserve">
          <source>Allows &quot;interrupt-safe&quot; executions of scripts by adding a custom conditional check on loops (for, while, do) and first statement of closures. By default, also adds an interrupt check statement on the beginning of method calls.</source>
          <target state="translated">루프 (for, while, do) 및 첫 번째 클로저 문에 대한 사용자 지정 조건 검사를 추가하여 스크립트의 &quot;중단 안전&quot;실행을 허용합니다. 기본적으로 메서드 호출 시작시 인터럽트 검사 문도 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e5c18feeb7bb3b33530b041edc6bbde66a4a3b90" translate="yes" xml:space="preserve">
          <source>Allows &quot;interrupt-safe&quot; executions of scripts by adding timer expiration checks on loops (for, while, do) and first statement of closures. By default, also adds an interrupt check statement on the beginning of method calls.</source>
          <target state="translated">루프 (for, while, do) 및 첫 번째 클로저 문에 타이머 만료 검사를 추가하여 스크립트의 &quot;인터럽트 안전&quot;실행을 허용합니다. 기본적으로 메서드 호출 시작시 인터럽트 검사 문도 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2a60d2ecfa572667cc348354905e97eb06ce2897" translate="yes" xml:space="preserve">
          <source>Allows &lt;a href=&quot;http://ant.apache.org/manual/coretasklist.html&quot;&gt;Ant tasks&lt;/a&gt; to be used with a Groovy builder-style markup. Requires that {{ant.jar}} is on your classpath which will happen automatically if you are using the Groovy distribution but will be up to you to organize if you are embedding Groovy. If you wish to use the &lt;a href=&quot;http://ant.apache.org/manual/install#optionalTasks&quot;&gt;optional tasks&lt;/a&gt; you will need to add one or more additional jars from the ant distribution to your classpath - see the &lt;a href=&quot;http://ant.apache.org/manual/install.html#librarydependencies&quot;&gt;library dependencies&lt;/a&gt; for more details.</source>
          <target state="translated">수 &lt;a href=&quot;http://ant.apache.org/manual/coretasklist.html&quot;&gt;개미 작업은&lt;/a&gt; 멋져요 빌더 스타일의 마크 업을 사용할 수 있습니다. {{ant.jar}}가 Groovy 배포판을 사용하는 경우 자동으로 발생하지만 Groovy를 포함하는 경우에는 구성 할 수있는 클래스 경로에 있어야합니다. &lt;a href=&quot;http://ant.apache.org/manual/install#optionalTasks&quot;&gt;선택적 작업&lt;/a&gt; 을 사용하려면 ant 배포에서 하나 이상의 추가 jar를 클래스 경로 에 추가해야합니다. 자세한 내용 은 &lt;a href=&quot;http://ant.apache.org/manual/install.html#librarydependencies&quot;&gt;라이브러리 종속성&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="46c90576fe51deebc40afa5f54cf3c5758443274" translate="yes" xml:space="preserve">
          <source>Allows a Map to be iterated through in reverse order using a closure.</source>
          <target state="translated">클로저를 사용하여지도를 역순으로 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ce956be3149abbccc14600c19678df58960857a" translate="yes" xml:space="preserve">
          <source>Allows a Map to be iterated through in reverse order using a closure. In general, the order in which the map contents are processed cannot be guaranteed. In practise, specialized forms of Map, e.g. a TreeMap will have its contents processed according to the reverse of the natural ordering of the map.</source>
          <target state="translated">클로저를 사용하여지도를 역순으로 반복 할 수 있습니다. 일반적으로지도 콘텐츠의 처리 순서는 보장 할 수 없습니다. 실제로, 특수화 된 형태의 Map, 예를 들어 TreeMap은 맵의 자연스러운 순서의 역순에 따라 내용을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8376883f288876d3fc889af54a58c2d2315bb753" translate="yes" xml:space="preserve">
          <source>Allows a Map to be iterated through using a closure.</source>
          <target state="translated">클로저를 사용하여 맵을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="876cdf629b188f6d94077397f3db52c2db5e1b64" translate="yes" xml:space="preserve">
          <source>Allows a Map to be iterated through using a closure. If the closure takes one parameter then it will be passed the Map.Entry otherwise if the closure takes two parameters then it will be passed the key and the value.</source>
          <target state="translated">클로저를 사용하여 맵을 반복 할 수 있습니다. 클로저가 하나의 매개 변수를 취하면 Map.Entry가 전달되고 그렇지 않으면 클로저가 두 개의 매개 변수를 취하면 키와 값이 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="6c0ea78903ba2b7557e13182cd2dbf0527b8d2ee" translate="yes" xml:space="preserve">
          <source>Allows a Map to be iterated through using a closure. If the closure takes two parameters then it will be passed the Map.Entry and the item's index (a counter starting at zero) otherwise if the closure takes three parameters then it will be passed the key, the value, and the index.</source>
          <target state="translated">클로저를 사용하여 맵을 반복 할 수 있습니다. 클로저가 두 개의 매개 변수를 사용하면 Map.Entry와 항목의 인덱스 (0에서 시작하는 카운터)가 전달됩니다. 그렇지 않으면 클로저가 세 개의 매개 변수를 사용하면 키, 값 및 색인이 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="711df1a717038418789c93654afc4f89aa7b9349" translate="yes" xml:space="preserve">
          <source>Allows a closure to be passed in to configure the JDBC statements before they are executed.</source>
          <target state="translated">실행되기 전에 JDBC 문을 구성하기 위해 클로저를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aad2b90ec9741e4465065723b7abc92ed2cea432" translate="yes" xml:space="preserve">
          <source>Allows a closure to be passed in to configure the JDBC statements before they are executed. It can be used to do things like set the query size etc. When this method is invoked, the supplied closure is saved. Statements subsequently created from other methods will then be configured using this closure. The statement being configured is passed into the closure as its single argument, e.g.:</source>
          <target state="translated">실행되기 전에 JDBC 문을 구성하기 위해 클로저를 전달할 수 있습니다. 쿼리 크기 설정 등과 같은 작업을 수행하는 데 사용할 수 있습니다.이 메서드가 호출되면 제공된 클로저가 저장됩니다. 이후에 다른 메서드에서 생성 된 문은이 클로저를 사용하여 구성됩니다. 구성중인 명령문은 단일 인수로 클로저에 전달됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="bc05e8e3141f1a2273469be6a061c3f2c1f43606" translate="yes" xml:space="preserve">
          <source>Allows a file to return a Writable implementation that can output itself to a Writer stream.</source>
          <target state="translated">파일이 Writer 스트림에 자신을 출력 할 수있는 쓰기 가능한 구현을 반환 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="ed8d5d3bdf046fa1aefd67f238c062648b30defd" translate="yes" xml:space="preserve">
          <source>Allows a more compact convenience form in one of two formats with optional appended attributes.</source>
          <target state="translated">선택적 추가 속성을 사용하여 두 가지 형식 중 하나로보다 간결한 편의 양식을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="f4e973681bee50efd9cdc7d4418b5435a6f7b732" translate="yes" xml:space="preserve">
          <source>Allows a more compact convenience form in one of two formats with optional appended attributes. Must not be used if group(), module() or version() are used.</source>
          <target state="translated">선택적 추가 속성을 사용하여 두 가지 형식 중 하나로보다 간결한 편의 양식을 허용합니다. group (), module () 또는 version ()을 사용하는 경우 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="6a5a51575c65df3e09223cc4c38eeb73dcf5f8c9" translate="yes" xml:space="preserve">
          <source>Allows a more traditional instance-style mocking paradigm.</source>
          <target state="translated">보다 전통적인 인스턴스 스타일의 모의 패러다임을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="12a522f8602e21d110870105cbae8b3c4916d96b" translate="yes" xml:space="preserve">
          <source>Allows a more traditional instance-style mocking paradigm. This is the recommended method to call to use the instance-style with Groovy classes. When mocking interfaces or abstract classes, a compatible proxy instance will be returned. When mocking Java classes, a compatible Groovy class will be generated and proxy instance returned. A MockProxyMetaClass will be instantiated for the original class. Typical example:</source>
          <target state="translated">보다 전통적인 인스턴스 스타일의 모의 패러다임을 허용합니다. 이것은 Groovy 클래스와 함께 인스턴스 스타일을 사용하기 위해 호출하는 데 권장되는 메서드입니다. 인터페이스 또는 추상 클래스를 모의 할 때 호환되는 프록시 인스턴스가 반환됩니다. Java 클래스를 모의 할 때 호환되는 Groovy 클래스가 생성되고 프록시 인스턴스가 반환됩니다. MockProxyMetaClass는 원래 클래스에 대해 인스턴스화됩니다. 전형적인 예 :</target>
        </trans-unit>
        <trans-unit id="7d27716d6f9a0badd4f68302e35d60daa25fd665" translate="yes" xml:space="preserve">
          <source>Allows a more traditional instance-style mocking paradigm. This is the recommended method to call to use the instance-style with Java classes. When mocking interfaces or abstract classes, a compatible proxy instance will be returned. When mocking Java classes, a compatible Groovy class will be generated and proxy instance returned. A MockProxyMetaClass will be instantiated for the class of the instance (i.e. may be on the generated class not the original class).</source>
          <target state="translated">보다 전통적인 인스턴스 스타일의 모의 패러다임을 허용합니다. Java 클래스에서 인스턴스 스타일을 사용하기 위해 호출하는 데 권장되는 메소드입니다. 인터페이스 또는 추상 클래스를 모의 할 때 호환되는 프록시 인스턴스가 반환됩니다. Java 클래스를 모의 할 때 호환되는 Groovy 클래스가 생성되고 프록시 인스턴스가 반환됩니다. MockProxyMetaClass는 인스턴스의 클래스에 대해 인스턴스화됩니다 (즉, 원래 클래스가 아닌 생성 된 클래스에있을 수 있음).</target>
        </trans-unit>
        <trans-unit id="9e0fa65ebf7738739c5f18062adac5f79a28bc03" translate="yes" xml:space="preserve">
          <source>Allows a more traditional instance-style stubbing paradigm.</source>
          <target state="translated">보다 전통적인 인스턴스 스타일의 스터 빙 패러다임을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="8a84a12fe59f1b753703c06da0cf36fa9d1ad0bd" translate="yes" xml:space="preserve">
          <source>Allows a more traditional instance-style stubbing paradigm. This is the recommended method to call to use the instance-style with Groovy classes.</source>
          <target state="translated">보다 전통적인 인스턴스 스타일의 스터 빙 패러다임을 허용합니다. 이것은 Groovy 클래스와 함께 인스턴스 스타일을 사용하기 위해 호출하는 데 권장되는 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="7be6ecdbbf2663f9e81ca1eb299282a85630df38" translate="yes" xml:space="preserve">
          <source>Allows a more traditional instance-style stubbing paradigm. This is the recommended method to call to use the instance-style with Java classes.</source>
          <target state="translated">보다 전통적인 인스턴스 스타일의 스터 빙 패러다임을 허용합니다. Java 클래스에서 인스턴스 스타일을 사용하기 위해 호출하는 데 권장되는 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="20b01c6ee4d6802b2cd415e7fe57c84090e3cc78" translate="yes" xml:space="preserve">
          <source>Allows a shorthand form which sets the name and root to this value.</source>
          <target state="translated">이름과 루트를이 값으로 설정하는 약식 형식을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="7534dbc6d3298eb4d5547efaddb888e4bd95e666" translate="yes" xml:space="preserve">
          <source>Allows a shorthand form which sets the name and root to this value. Must not be used if name() or root() is non-empty.</source>
          <target state="translated">이름과 루트를이 값으로 설정하는 약식 형식을 허용합니다. name () 또는 root ()가 비어 있지 않으면 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d6d1645e149607f9464acd02d1d709c3e122aada" translate="yes" xml:space="preserve">
          <source>Allows a simple syntax for using timers.</source>
          <target state="translated">타이머 사용을위한 간단한 구문을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9da268c7fdc70be97a547cb1988841f04e9a8b99" translate="yes" xml:space="preserve">
          <source>Allows a simple syntax for using timers. This timer will execute the given closure after the given delay.</source>
          <target state="translated">타이머 사용을위한 간단한 구문을 허용합니다. 이 타이머는 주어진 지연 후에 주어진 클로저를 실행할 것입니다.</target>
        </trans-unit>
        <trans-unit id="207c2dd9176be854457cb1c0c7c238d31d4cf7cb" translate="yes" xml:space="preserve">
          <source>Allows an Enumeration to behave like an Iterator.</source>
          <target state="translated">Enumeration이 Iterator처럼 동작하도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="2161d0b0a5342b77fb0f0be75484287c481b22dd" translate="yes" xml:space="preserve">
          <source>Allows an Enumeration to behave like an Iterator. Note that the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html#remove()%20remove()&quot;&gt;Iterator.remove&lt;/a&gt; method is unsupported since the underlying Enumeration does not provide a mechanism for removing items.</source>
          <target state="translated">Enumeration이 Iterator처럼 동작하도록 허용합니다. 참고 것으로 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html#remove()%20remove()&quot;&gt;는, Iterator.remove&lt;/a&gt; 기본 열거 항목을 제거하기위한 메커니즘을 제공하지 않기 때문에 방법은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7703e9d266d2d7faefadd9eba1e85c7477858f69" translate="yes" xml:space="preserve">
          <source>Allows arrays to behave similar to collections.</source>
          <target state="translated">배열이 컬렉션과 유사하게 동작하도록합니다.</target>
        </trans-unit>
        <trans-unit id="57f44b07dc31b564b49de1edf1df2937d80ddc37" translate="yes" xml:space="preserve">
          <source>Allows construction of a named-arg equivalent method or constructor. The method or constructor will have at least a first argument of type &lt;code&gt;Map&lt;/code&gt; and may have more arguments. As such, it can be called using Groovy's named-arg syntax. The original method/constructor is retained and is called by the generated method/constructor. One benefit of this approach is the potential for improved type checking. The annotated &quot;tuple&quot; method/constructor can be type rich and will be checked as such during normal compilation. The generated method/constructor using the map argument will be named-argument friendly but the map also hides type information. The generated method however contains no business logic so the chance of errors is minimal. Any arguments identified as named arguments will be supplied as part of the map. Any additional arguments are supplied in the normal tuple style. Named parameters are identified in one of three ways:</source>
          <target state="translated">명명 된 인수에 해당하는 메서드 또는 생성자를 생성 할 수 있습니다. 메서드 또는 생성자에는 &lt;code&gt;Map&lt;/code&gt; 형식의 첫 번째 인수가 최소한 하나 있습니다.더 많은 인수가있을 수 있습니다. 따라서 Groovy의 named-arg 구문을 사용하여 호출 할 수 있습니다. 원래 메서드 / 생성자는 유지되며 생성 된 메서드 / 생성자에 의해 호출됩니다. 이 접근 방식의 한 가지 이점은 향상된 유형 검사의 가능성입니다. 주석이 달린 &quot;튜플&quot;메서드 / 생성자는 형식이 풍부 할 수 있으며 일반 컴파일 중에 확인됩니다. map 인수를 사용하여 생성 된 메서드 / 생성자는 명명 된 인수에 친숙하지만 맵은 유형 정보도 숨 깁니다. 그러나 생성 된 메서드에는 비즈니스 논리가 포함되어 있지 않으므로 오류 가능성이 최소화됩니다. 명명 된 인수로 식별 된 모든 인수는 맵의 일부로 제공됩니다. 추가 인수는 일반 튜플 스타일로 제공됩니다. 명명 된 매개 변수는 다음 세 가지 방법 중 하나로 식별됩니다.</target>
        </trans-unit>
        <trans-unit id="51a19624c2e564f32c6a6686e32bfe26a8bec271" translate="yes" xml:space="preserve">
          <source>Allows conversion of arrays into a mutable List</source>
          <target state="translated">배열을 변경 가능한 목록으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d01aa34e18f07df4816cdb692256f9d6a084b151" translate="yes" xml:space="preserve">
          <source>Allows conversion of arrays into a mutable List.</source>
          <target state="translated">배열을 변경 가능한 목록으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3b07c5c1c007a892b2e710b4ff157648250ba14" translate="yes" xml:space="preserve">
          <source>Allows customisation of the usage message width.</source>
          <target state="translated">사용 메시지 너비를 사용자 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9092b0eba07aa0bac26c02cd8c6bf6b975bb044" translate="yes" xml:space="preserve">
          <source>Allows empty attributes to be removed from the generated markup.</source>
          <target state="translated">생성 된 마크 업에서 빈 속성을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5a8c64503e8085887f6642e2225681982efebe8" translate="yes" xml:space="preserve">
          <source>Allows frameworks that integrate with Groovy to determine how Groovy files are resolved.</source>
          <target state="translated">Groovy와 통합되는 프레임 워크가 Groovy 파일을 확인하는 방법을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ae54b9e82f12b5ba2e0d95d633321da06a22091" translate="yes" xml:space="preserve">
          <source>Allows methods to be dynamically added to existing classes at runtime</source>
          <target state="translated">런타임시 기존 클래스에 메서드를 동적으로 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e01939a4a728b28227ee02f04bf8df4b234f4ed6" translate="yes" xml:space="preserve">
          <source>Allows null attributes to be removed from the generated markup.</source>
          <target state="translated">생성 된 마크 업에서 null 속성을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0c151d07faa8136719194c53afb0bdd8ba8f382" translate="yes" xml:space="preserve">
          <source>Allows one Process to asynchronously pipe data to another Process.</source>
          <target state="translated">한 프로세스가 데이터를 다른 프로세스로 비동기 적으로 파이프 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="0ab530a344b85cbc2b62b0d5ae6c13bf3f7482ae" translate="yes" xml:space="preserve">
          <source>Allows particular method calls to be ignored and not treated as part of the required behavior specification.</source>
          <target state="translated">특정 메서드 호출을 무시하고 필수 동작 사양의 일부로 처리하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="447d1c802ca66356bc1177ada83aae8e8fe5ba1c" translate="yes" xml:space="preserve">
          <source>Allows particular method calls to be ignored and not treated as part of the required behavior specification. If you don't specify a return closure the method call will fall through to the underlying instance, i.e. half-mock style. The &lt;code&gt;filter&lt;/code&gt; object is invoked using the normal Groovy &lt;code&gt;isCase()&lt;/code&gt; semantics.</source>
          <target state="translated">특정 메서드 호출을 무시하고 필수 동작 사양의 일부로 처리하지 않도록합니다. 반환 클로저를 지정하지 않으면 메서드 호출이 기본 인스턴스 (예 : half-mock 스타일)로 넘어갑니다. &lt;code&gt;filter&lt;/code&gt; 오브젝트는 통상 사용 그루비 호출 &lt;code&gt;isCase()&lt;/code&gt; 의미한다.</target>
        </trans-unit>
        <trans-unit id="3d6b620d528eed7b6bd2ccdfc235bfe9b46a6b8b" translate="yes" xml:space="preserve">
          <source>Allows particular method calls to be ignored and not treated as part of the required behavior specification. If you don't specify a return closure the method call will fall through to the underlying instance, i.e. half-mock style. The &lt;code&gt;filter&lt;/code&gt; object is invoked using the normal Groovy &lt;code&gt;isCase()&lt;/code&gt; semantics. Here are some examples:</source>
          <target state="translated">특정 메서드 호출을 무시하고 필수 동작 사양의 일부로 처리하지 않도록합니다. 반환 클로저를 지정하지 않으면 메서드 호출이 기본 인스턴스 (예 : half-mock 스타일)로 넘어갑니다. &lt;code&gt;filter&lt;/code&gt; 오브젝트는 통상 사용 그루비 호출 &lt;code&gt;isCase()&lt;/code&gt; 의미한다. 여기 예시들이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a3a6ff4ca96edcaa7d55e6702ec17f3750cccd8f" translate="yes" xml:space="preserve">
          <source>Allows safe timed executions of scripts by adding elapsed time checks into loops (for, while) and at the start of closures and methods and throwing an exception if a timeout occurs.</source>
          <target state="translated">루프 (for, while) 및 클로저 및 메서드 시작시 경과 시간 검사를 추가하고 시간 초과가 발생하면 예외를 발생시켜 안전한 시간 제한 스크립트 실행을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="da3ea58fa6dc03c1091fd6bf63de66365931be43" translate="yes" xml:space="preserve">
          <source>Allows selection of parser type for new new JsonSlurper.</source>
          <target state="translated">새 JsonSlurper에 대한 구문 분석기 유형을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="329f1fadf989fd43fd15718f2154d16bcc86107d" translate="yes" xml:space="preserve">
          <source>Allows subclasses to provide their own visitor.</source>
          <target state="translated">하위 클래스가 자신의 방문자를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a594e61f3baa6f644b6f7e646f7b9550675ad17" translate="yes" xml:space="preserve">
          <source>Allows subclasses to provide their own visitor. This is useful for example for transformations relying on the static type checker.</source>
          <target state="translated">하위 클래스가 자신의 방문자를 제공 할 수 있습니다. 이것은 예를 들어 정적 유형 검사기에 의존하는 변환에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="450f2e863d2b363c0b032198e4b3e11d60fed76b" translate="yes" xml:space="preserve">
          <source>Allows the MetaClass to be replaced with a derived implementation.</source>
          <target state="translated">MetaClass를 파생 된 구현으로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b1333e12b2fb7bd534da8dd88d2368c2c967297" translate="yes" xml:space="preserve">
          <source>Allows the closure to be called for NullObject</source>
          <target state="translated">NullObject에 대해 클로저를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d596990fba1ef230ec19d02bf74cfbcb13c620e" translate="yes" xml:space="preserve">
          <source>Allows the closure to be called for the object reference self (similar to &lt;code&gt;with&lt;/code&gt; and always returns self.</source>
          <target state="translated">객체 참조 self에 대해 클로저를 호출 할 수 있습니다 ( &lt;code&gt;with&lt;/code&gt; 와 유사 하며 항상 self를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="516361e5ee9c735d2e1e89bef04037ae02fd4e0b" translate="yes" xml:space="preserve">
          <source>Allows the closure to be called for the object reference self.</source>
          <target state="translated">객체 참조 자체에 대해 클로저를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="621acf6cf2fbb085b155543d41e3d417d3eaf8cb" translate="yes" xml:space="preserve">
          <source>Allows the closure to be called for the object reference self. Synonym for 'with()'.</source>
          <target state="translated">객체 참조 자체에 대해 클로저를 호출 할 수 있습니다. 'with ()'의 동의어.</target>
        </trans-unit>
        <trans-unit id="8c8c40709e434026d026f1e7069d725a7d817b8c" translate="yes" xml:space="preserve">
          <source>Allows the delegate to be changed such as when performing markup building</source>
          <target state="translated">마크 업 작성을 수행 할 때와 같이 델리게이트를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50f9cdffe69a3d23cb2579ff3004bea9e666de3e" translate="yes" xml:space="preserve">
          <source>Allows the extension to catch incompatible return types.</source>
          <target state="translated">확장 프로그램이 호환되지 않는 반환 유형을 포착 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="706d09d4a3b97d275f1a5d7d161ecbb7ee9dc029" translate="yes" xml:space="preserve">
          <source>Allows the extension to catch incompatible return types. This event is called whenever the type checker finds that an inferred return type is incompatible with the declared return type of a method.</source>
          <target state="translated">확장 프로그램이 호환되지 않는 반환 유형을 포착 할 수 있도록합니다. 이 이벤트는 유추 된 반환 유형이 메서드의 선언 된 반환 유형과 호환되지 않는 것을 유형 검사기가 발견 할 때마다 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4f6988aae4dfc82c9256787faf5bee190294fd72" translate="yes" xml:space="preserve">
          <source>Allows the extension to listen to method selection events.</source>
          <target state="translated">확장 프로그램이 메서드 선택 이벤트를 수신 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="0141f0b4a772c8bcb5cbf0e23390becfeff8a92c" translate="yes" xml:space="preserve">
          <source>Allows the extension to listen to method selection events. Given an expression, which may be a method call expression, a static method call expression, a pre/postfix expression, ..., if a corresponding method is found, this method is called.</source>
          <target state="translated">확장 프로그램이 메서드 선택 이벤트를 수신 할 수 있도록합니다. 메소드 호출 표현식, 정적 메소드 호출 표현식, 앞 / 뒤 표현식 등이 될 수있는 표현식이 주어지면 해당 메소드가 발견되면이 메소드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0e1ef4c9e092dd59497aa869467e7fbb46a1edbd" translate="yes" xml:space="preserve">
          <source>Allows the extension to perform additional tasks after the type checker actually visited a class node.</source>
          <target state="translated">유형 검사기가 실제로 클래스 노드를 방문한 후 확장이 추가 작업을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="025c2fd2ebc54a828c20fdb6705bd8128a65c2a5" translate="yes" xml:space="preserve">
          <source>Allows the extension to perform additional tasks after the type checker actually visited a class node. Compared to a custom visitor, this method ensures that the node being visited is a node which would have been visited by the type checker. This is in particular important for nodes which are marked with &lt;a href=&quot;../../../../../groovy/transform/typecheckingmode#SKIP&quot;&gt;TypeCheckingMode.SKIP&lt;/a&gt;.</source>
          <target state="translated">유형 검사기가 실제로 클래스 노드를 방문한 후 확장이 추가 작업을 수행 할 수 있도록합니다. 사용자 지정 방문자와 비교하여이 방법은 방문중인 노드가 유형 검사기가 방문한 노드인지 확인합니다. 이것은 &lt;a href=&quot;../../../../../groovy/transform/typecheckingmode#SKIP&quot;&gt;TypeCheckingMode.SKIP&lt;/a&gt; 로 표시된 노드에 특히 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="91a9bd2dbe004d85ee8ca09d7f68335a999389d1" translate="yes" xml:space="preserve">
          <source>Allows the extension to perform additional tasks after the type checker actually visited a method node.</source>
          <target state="translated">유형 검사기가 실제로 메서드 노드를 방문한 후 확장 프로그램이 추가 작업을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="efb9bc7a2e101d66bd3d1550ee2c852e5f6bf34e" translate="yes" xml:space="preserve">
          <source>Allows the extension to perform additional tasks after the type checker actually visited a method node. Compared to a custom visitor, this method ensures that the node being visited is a node which would have been visited by the type checker. This is in particular important for nodes which are marked with &lt;a href=&quot;../../../../../groovy/transform/typecheckingmode#SKIP&quot;&gt;TypeCheckingMode.SKIP&lt;/a&gt;.</source>
          <target state="translated">유형 검사기가 실제로 메서드 노드를 방문한 후 확장 프로그램이 추가 작업을 수행 할 수 있도록합니다. 사용자 지정 방문자와 비교하여이 방법은 방문중인 노드가 유형 검사기가 방문한 노드인지 확인합니다. 이것은 &lt;a href=&quot;../../../../../groovy/transform/typecheckingmode#SKIP&quot;&gt;TypeCheckingMode.SKIP&lt;/a&gt; 로 표시된 노드에 특히 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="577721e583140c944601421891215c585112b492" translate="yes" xml:space="preserve">
          <source>Allows the extension to perform additional tasks after the type checker actually visits a method call.</source>
          <target state="translated">유형 검사기가 실제로 메서드 호출을 방문한 후 확장 프로그램이 추가 작업을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="9dabcdbba4e3089744ac1ff34ebf4f6e91e77d0c" translate="yes" xml:space="preserve">
          <source>Allows the extension to perform additional tasks after the type checker actually visits a method call. Compared to a custom visitor, this method ensures that the node being visited is a node which would have been visited by the type checker. This is in particular important for nodes which are marked with &lt;a href=&quot;../../../../../groovy/transform/typecheckingmode#SKIP&quot;&gt;TypeCheckingMode.SKIP&lt;/a&gt;.</source>
          <target state="translated">유형 검사기가 실제로 메서드 호출을 방문한 후 확장 프로그램이 추가 작업을 수행 할 수 있도록합니다. 사용자 지정 방문자와 비교하여이 방법은 방문중인 노드가 유형 검사기가 방문한 노드인지 확인합니다. 이것은 &lt;a href=&quot;../../../../../groovy/transform/typecheckingmode#SKIP&quot;&gt;TypeCheckingMode.SKIP&lt;/a&gt; 로 표시된 노드에 특히 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="2a0bf7a2c9f3069dde843fa6505d9b42cff5dbee" translate="yes" xml:space="preserve">
          <source>Allows the extension to perform additional tasks before the type checker actually visits a class node.</source>
          <target state="translated">유형 검사기가 실제로 클래스 노드를 방문하기 전에 확장이 추가 작업을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="7f4f99f6f382500efb80de6f43491850d9858fb4" translate="yes" xml:space="preserve">
          <source>Allows the extension to perform additional tasks before the type checker actually visits a class node. Compared to a custom visitor, this method ensures that the node being visited is a node which would have been visited by the type checker. This is in particular important for nodes which are marked with &lt;a href=&quot;../../../../../groovy/transform/typecheckingmode#SKIP&quot;&gt;TypeCheckingMode.SKIP&lt;/a&gt;.</source>
          <target state="translated">유형 검사기가 실제로 클래스 노드를 방문하기 전에 확장이 추가 작업을 수행 할 수 있도록합니다. 사용자 지정 방문자와 비교하여이 방법은 방문중인 노드가 유형 검사기가 방문한 노드인지 확인합니다. 이것은 &lt;a href=&quot;../../../../../groovy/transform/typecheckingmode#SKIP&quot;&gt;TypeCheckingMode.SKIP&lt;/a&gt; 로 표시된 노드에 특히 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="e936bc0c783eb37bfca3d7672a7a96b8493c1ec4" translate="yes" xml:space="preserve">
          <source>Allows the extension to perform additional tasks before the type checker actually visits a method call.</source>
          <target state="translated">확장 프로그램이 유형 검사기가 실제로 메서드 호출을 방문하기 전에 추가 작업을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="2cdd944e5ee067618f72ae2e7cb1cdf34bbee0b3" translate="yes" xml:space="preserve">
          <source>Allows the extension to perform additional tasks before the type checker actually visits a method call. Compared to a custom visitor, this method ensures that the node being visited is a node which would have been visited by the type checker. This is in particular important for nodes which are marked with &lt;a href=&quot;../../../../../groovy/transform/typecheckingmode#SKIP&quot;&gt;TypeCheckingMode.SKIP&lt;/a&gt;.</source>
          <target state="translated">확장 프로그램이 유형 검사기가 실제로 메서드 호출을 방문하기 전에 추가 작업을 수행 할 수 있도록합니다. 사용자 지정 방문자와 비교하여이 방법은 방문중인 노드가 유형 검사기가 방문한 노드인지 확인합니다. 이것은 &lt;a href=&quot;../../../../../groovy/transform/typecheckingmode#SKIP&quot;&gt;TypeCheckingMode.SKIP&lt;/a&gt; 로 표시된 노드에 특히 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="49827dbc8730bf8d46021f59664828fd0f9641fe" translate="yes" xml:space="preserve">
          <source>Allows the extension to perform additional tasks before the type checker actually visits a method node.</source>
          <target state="translated">유형 검사기가 실제로 메서드 노드를 방문하기 전에 확장 프로그램이 추가 작업을 수행 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="2aa7ba86cf901453e690d6c2a6e502e882cf4941" translate="yes" xml:space="preserve">
          <source>Allows the extension to perform additional tasks before the type checker actually visits a method node. Compared to a custom visitor, this method ensures that the node being visited is a node which would have been visited by the type checker. This is in particular important for nodes which are marked with &lt;a href=&quot;../../../../../groovy/transform/typecheckingmode#SKIP&quot;&gt;TypeCheckingMode.SKIP&lt;/a&gt;.</source>
          <target state="translated">유형 검사기가 실제로 메서드 노드를 방문하기 전에 확장 프로그램이 추가 작업을 수행 할 수 있도록합니다. 사용자 지정 방문자와 비교하여이 방법은 방문중인 노드가 유형 검사기가 방문한 노드인지 확인합니다. 이것은 &lt;a href=&quot;../../../../../groovy/transform/typecheckingmode#SKIP&quot;&gt;TypeCheckingMode.SKIP&lt;/a&gt; 로 표시된 노드에 특히 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="54aff03b63af3b07b6b078a278ba34ce5f595304" translate="yes" xml:space="preserve">
          <source>Allows the subscript operator to be used to lookup dynamic property values.</source>
          <target state="translated">아래 첨자 연산자를 사용하여 동적 속성 값을 조회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcebe11b9ed08f4071c1faeacafd366ece886fe9" translate="yes" xml:space="preserve">
          <source>Allows the subscript operator to be used to lookup dynamic property values. &lt;code&gt;bean[somePropertyNameExpression]&lt;/code&gt;. The normal property notation of groovy is neater and more concise but only works with compile-time known property names.</source>
          <target state="translated">아래 첨자 연산자를 사용하여 동적 속성 값을 조회 할 수 있습니다. &lt;code&gt;bean[somePropertyNameExpression]&lt;/code&gt; . groovy의 일반 속성 표기법은 더 깔끔하고 간결하지만 컴파일시 알려진 속성 이름에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="307aa543dab66b1bbf95bcd6b94aae4376111c5b" translate="yes" xml:space="preserve">
          <source>Allows the subscript operator to be used to set dynamically named property values.</source>
          <target state="translated">아래 첨자 연산자를 사용하여 동적으로 명명 된 속성 값을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="402b095bb6db211deb3f8ce0ead18e948e5aeb7e" translate="yes" xml:space="preserve">
          <source>Allows the subscript operator to be used to set dynamically named property values. &lt;code&gt;bean[somePropertyNameExpression] = foo&lt;/code&gt;. The normal property notation of groovy is neater and more concise but only works with property names which are known at compile time.</source>
          <target state="translated">아래 첨자 연산자를 사용하여 동적으로 명명 된 속성 값을 설정할 수 있습니다. &lt;code&gt;bean[somePropertyNameExpression] = foo&lt;/code&gt; . groovy의 일반적인 속성 표기법은 더 깔끔하고 간결하지만 컴파일 타임에 알려진 속성 이름에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="66d10fbefda364d2c1e74d92d6145f80bb3488c8" translate="yes" xml:space="preserve">
          <source>Allows the usage of a one-element string for a mnemonic</source>
          <target state="translated">니모닉에 단일 요소 문자열을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84d48b24727204cb6d7dd2f526299a3bdbf8c225" translate="yes" xml:space="preserve">
          <source>Allows the usage of addShutdownHook without getting the runtime first.</source>
          <target state="translated">런타임을 먼저 가져 오지 않고 addShutdownHook 사용을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="cc4bb1e4cd59538dd1832f3a1ac4f5eca7afcb4b" translate="yes" xml:space="preserve">
          <source>Allows this AutoCloseable to be used within the closure, ensuring that it is closed once the closure has been executed and before this method returns.</source>
          <target state="translated">이 AutoCloseable을 클로저 내에서 사용할 수있게하여 클로저가 실행 된 후이 메서드가 반환되기 전에 닫히도록합니다.</target>
        </trans-unit>
        <trans-unit id="67ed6e06741b1e062d2dd31e9d1db03ffac6106a" translate="yes" xml:space="preserve">
          <source>Allows this closeable to be used within the closure, ensuring that it is closed once the closure has been executed and before this method returns.</source>
          <target state="translated">클로저 내에서이 클로저를 사용할 수 있도록 허용하여 클로저가 실행 된 후이 메서드가 반환되기 전에 닫히도록합니다.</target>
        </trans-unit>
        <trans-unit id="1eb7ab0445363d8344d8bd1499632612c108580a" translate="yes" xml:space="preserve">
          <source>Allows this input stream to be used within the closure, ensuring that it is flushed and closed before this method returns.</source>
          <target state="translated">이 입력 스트림이 클로저 내에서 사용되도록 허용하여이 메서드가 반환되기 전에 플러시되고 닫히도록합니다.</target>
        </trans-unit>
        <trans-unit id="143d63d055ba2c9da6bb6a4f8642448bd4169cec" translate="yes" xml:space="preserve">
          <source>Allows this reader to be used within the closure, ensuring that it is closed before this method returns.</source>
          <target state="translated">이 판독기가 클로저 내에서 사용되도록 허용하여이 메서드가 반환되기 전에 닫혔는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="19722b54c6ba4000f30c726b202d7d173cd80eb7" translate="yes" xml:space="preserve">
          <source>Allows this writer to be used within the closure, ensuring that it is flushed and closed before this method returns.</source>
          <target state="translated">이 작성기가 클로저 내에서 사용되도록 허용하여이 메서드가 반환되기 전에 플러시되고 닫히도록합니다.</target>
        </trans-unit>
        <trans-unit id="5a0fb620be9e71bc59f234ded82951e64fc6aeee" translate="yes" xml:space="preserve">
          <source>Allows to add a String to null.</source>
          <target state="translated">null에 문자열을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6f5968d3c04de9f008d7a8def20518db3ed1e30" translate="yes" xml:space="preserve">
          <source>Allows to add a String to null. The result is concatenated String of the result of calling toString() on this object and the String in the parameter.</source>
          <target state="translated">null에 문자열을 추가 할 수 있습니다. 결과는이 객체에서 toString ()을 호출 한 결과와 매개 변수의 String이 연결된 String입니다.</target>
        </trans-unit>
        <trans-unit id="7a8c294b5d2d5065b6e9978b37be869afd7cf31b" translate="yes" xml:space="preserve">
          <source>Allows to throw a checked exception unchecked. INTERNAL USE ONLY.</source>
          <target state="translated">확인되지 않은 확인 된 예외를 throw 할 수 있습니다. 내부 용.</target>
        </trans-unit>
        <trans-unit id="ccd822cf4ef0368b7c450d1712785b6336580d95" translate="yes" xml:space="preserve">
          <source>Allows you to provide &lt;code&gt;@Immutable&lt;/code&gt; with a list of classes which are deemed immutable.</source>
          <target state="translated">불변으로 간주되는 클래스 목록을 &lt;code&gt;@Immutable&lt;/code&gt; 에 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2e003ed877f0e85c60b6675784dae8c9e8be642" translate="yes" xml:space="preserve">
          <source>Allows you to provide &lt;code&gt;@Immutable&lt;/code&gt; with a list of classes which are deemed immutable. By supplying a class in this list, you are vouching for its immutability and &lt;code&gt;@Immutable&lt;/code&gt; will do no further checks. Example:</source>
          <target state="translated">불변으로 간주되는 클래스 목록을 &lt;code&gt;@Immutable&lt;/code&gt; 에 제공 할 수 있습니다 . 이 목록에 클래스를 제공하면 불변성을 보증하고 &lt;code&gt;@Immutable&lt;/code&gt; 은 더 이상 확인하지 않습니다. 예:</target>
        </trans-unit>
        <trans-unit id="37831816e7994d3a3bc25fade097d8fd9b3f6dfa" translate="yes" xml:space="preserve">
          <source>Allows you to provide &lt;code&gt;@Immutable&lt;/code&gt; with a list of property names which are deemed immutable.</source>
          <target state="translated">불변으로 간주되는 속성 이름 목록을 &lt;code&gt;@Immutable&lt;/code&gt; 에 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="15e7d6d5dce974e6b3fe7813cfc94faa15b760b1" translate="yes" xml:space="preserve">
          <source>Allows you to provide &lt;code&gt;@Immutable&lt;/code&gt; with a list of property names which are deemed immutable. By supplying a property's name in this list, you are vouching for its immutability and &lt;code&gt;@Immutable&lt;/code&gt; will do no further checks. Example:</source>
          <target state="translated">불변으로 간주되는 속성 이름 목록을 &lt;code&gt;@Immutable&lt;/code&gt; 에 제공 할 수 있습니다 . 이 목록에 속성 이름을 제공하면 불변성을 보증하는 것이며 &lt;code&gt;@Immutable&lt;/code&gt; 은 더 이상 확인하지 않습니다. 예:</target>
        </trans-unit>
        <trans-unit id="4120c9da6cf775a295ed92f50baba87c48407a55" translate="yes" xml:space="preserve">
          <source>Allows you to specify the group (organisation) and the module (artifact) in one of two compact convenience formats, e.g.: &lt;code&gt;@GrabExclude('org.apache.ant:ant-junit')&lt;/code&gt; or &lt;code&gt;@GrabExclude('org.apache.ant#ant-junit')&lt;/code&gt;</source>
          <target state="translated">그룹 (조직)과 모듈 (아티팩트)을 두 가지 편리한 형식 중 하나로 지정할 수 있습니다. 예 : &lt;code&gt;@GrabExclude('org.apache.ant:ant-junit')&lt;/code&gt; 또는 &lt;code&gt;@GrabExclude('org.apache.ant#ant-junit')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7210b0bce8fe606682a56490bb5f7fb9d38abfb7" translate="yes" xml:space="preserve">
          <source>Allows you to use a list of categories, specifying the list as varargs.</source>
          <target state="translated">목록을 varargs로 지정하여 카테고리 목록을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bc82574b9b3b109de7e6f8b15ba915a20d8b8de" translate="yes" xml:space="preserve">
          <source>Allows you to use a list of categories, specifying the list as varargs. &lt;code&gt;use(CategoryClass1, CategoryClass2) { ... }&lt;/code&gt; This method saves having to wrap the category classes in a list.</source>
          <target state="translated">목록을 varargs로 지정하여 카테고리 목록을 사용할 수 있습니다. &lt;code&gt;use(CategoryClass1, CategoryClass2) { ... }&lt;/code&gt; 이 메서드는 목록에서 범주 클래스를 래핑 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2abd3867d48f6c136827682dfd381ea7c61394a2" translate="yes" xml:space="preserve">
          <source>Also adds support methods:</source>
          <target state="translated">또한 지원 방법을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="94d491fc6f2035c8e8c0279b6dd241bfe57b1672" translate="yes" xml:space="preserve">
          <source>Also adds support methods: &lt;code&gt;public void addVetoableChangeListener(java.beans.VetoableChangeListener)&lt;/code&gt;&lt;code&gt;public void addVetoableChangeListener(String, java.beans.VetoableChangeListener)&lt;/code&gt;&lt;code&gt;public void removeVetoableChangeListener(java.beans.VetoableChangeListener)&lt;/code&gt;&lt;code&gt;public void removeVetoableChangeListener(String, java.beans.VetoableChangeListener)&lt;/code&gt;&lt;code&gt;public java.beans.VetoableChangeListener[] getVetoableChangeListeners()&lt;/code&gt;</source>
          <target state="translated">또한,지지 수단을 추가 &lt;code&gt;public void addVetoableChangeListener(java.beans.VetoableChangeListener)&lt;/code&gt; &lt;code&gt;public void addVetoableChangeListener(String, java.beans.VetoableChangeListener)&lt;/code&gt; &lt;code&gt;public void removeVetoableChangeListener(java.beans.VetoableChangeListener)&lt;/code&gt; &lt;code&gt;public void removeVetoableChangeListener(String, java.beans.VetoableChangeListener)&lt;/code&gt; &lt;code&gt;public java.beans.VetoableChangeListener[] getVetoableChangeListeners()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ab6daa89397b81dacc8ad5af71db5999868b835b" translate="yes" xml:space="preserve">
          <source>Also implements Groovy's &lt;a href=&quot;../util/resourceconnector&quot;&gt;ResourceConnector&lt;/a&gt; in a dynamic manner. It allows you to modify the resource name that is searched for with a</source>
          <target state="translated">또한 Groovy의 &lt;a href=&quot;../util/resourceconnector&quot;&gt;ResourceConnector&lt;/a&gt; 를 동적 방식으로 구현 합니다. 검색되는 리소스 이름을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83de9e179bdc30c3d9d2cab3aed08b8338628d69" translate="yes" xml:space="preserve">
          <source>Also note that '_' was used multiple times. This is supported but if any other shortOpt or any longOpt is repeated, then the behavior is undefined.</source>
          <target state="translated">또한 '_'이 여러 번 사용되었습니다. 이는 지원되지만 다른 shortOpt 또는 longOpt가 반복되는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c07d1cb709f691bcd04d18a5299f080a5d00d044" translate="yes" xml:space="preserve">
          <source>Also note that '_' was used multiple times. This is supported but if any other shortOpt or any longOpt is repeated, then the underlying library throws an exception.</source>
          <target state="translated">또한 '_'이 여러 번 사용되었습니다. 이는 지원되지만 다른 shortOpt 또는 longOpt가 반복되면 기본 라이브러리에서 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8c0e38c29865f1a11e0913e051c73f10050804ba" translate="yes" xml:space="preserve">
          <source>Also, &lt;code&gt;eachRow&lt;/code&gt; and &lt;code&gt;rows&lt;/code&gt; support paging. Here's an example:</source>
          <target state="translated">또한 &lt;code&gt;eachRow&lt;/code&gt; 및 &lt;code&gt;rows&lt;/code&gt; 는 페이징을 지원합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="116ee6a478f2ddf6edfd15615afd49337a61cae5" translate="yes" xml:space="preserve">
          <source>Also, if the expression starts with a closure, it needs to have an explicit parameter list, in order to avoid the appearance of a compound statement. This is a hard error.</source>
          <target state="translated">또한 표현식이 클로저로 시작하는 경우 복합 명령문의 출현을 방지하기 위해 명시적인 매개 변수 목록이 있어야합니다. 이것은 어려운 오류입니다.</target>
        </trans-unit>
        <trans-unit id="597630bfb1bea84fe74e0339f15c77d132560898" translate="yes" xml:space="preserve">
          <source>Alternatively, 'tap' is an alias for 'with(true)', so that method can be used instead. The other main use case for with is when returning a value calculated using self as shown here:</source>
          <target state="translated">또는 'tap'은 'with (true)'의 별칭이므로 대신 해당 메서드를 사용할 수 있습니다. with의 다른 주요 사용 사례는 다음과 같이 self를 사용하여 계산 된 값을 반환 할 때입니다.</target>
        </trans-unit>
        <trans-unit id="434771c8cf6014219bac5b3cc81c19a02bf8f09c" translate="yes" xml:space="preserve">
          <source>Alternatively, 'with' is an alias for 'with(false)', so the boolean parameter can be omitted instead.</source>
          <target state="translated">또는 'with'는 'with (false)'의 별칭이므로 대신 부울 매개 변수를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e454f936bdf7a78e7d21c31cf7ec1e8d7d95f6f8" translate="yes" xml:space="preserve">
          <source>Alternatively, if &lt;code&gt;isMultipleAssignmentDeclaration()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; you can use the method &quot;&lt;code&gt;VariableExpression getVariableExpression()&lt;/code&gt;&quot; method. Similarly, if &lt;code&gt;isMultipleAssignmentDeclaration()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; you can use the method &quot;&lt;code&gt;TupleExpression getTupleExpression()&lt;/code&gt;&quot; method. Calling either of these expression getters when the &quot;isMultipleAssignment&quot; condition is not appropriate is unsafe and will result in a &lt;code&gt;ClassCastException&lt;/code&gt;.</source>
          <target state="translated">또는 &lt;code&gt;isMultipleAssignmentDeclaration()&lt;/code&gt; 이 &lt;code&gt;false&lt;/code&gt; 이면 &quot; &lt;code&gt;VariableExpression getVariableExpression()&lt;/code&gt; &quot;메서드를 사용할 수 있습니다 . 마찬가지로 &lt;code&gt;isMultipleAssignmentDeclaration()&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 이면 &quot; &lt;code&gt;TupleExpression getTupleExpression()&lt;/code&gt; &quot;메서드를 사용할 수 있습니다 . &quot;isMultipleAssignment&quot;조건이 적절하지 않을 때 이러한 표현식 getter 중 하나를 호출하는 것은 안전하지 않으며 &lt;code&gt;ClassCastException&lt;/code&gt; 이 발생 합니다 .</target>
        </trans-unit>
        <trans-unit id="e20392dc5ce21457dbd3d3348040b9b50b5f1acf" translate="yes" xml:space="preserve">
          <source>Alternatively, the method may look like this:</source>
          <target state="translated">또는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f261559c8a581638abcc4c70069ff784e46bf93" translate="yes" xml:space="preserve">
          <source>Although CliBuilder on the whole hides away the underlying library used for processing the arguments, it does provide some hooks which let you make use of the underlying library directly should the need arise. For example, the last two lines of the 'curl' example above could be replaced with the following:</source>
          <target state="translated">CliBuilder는 전체적으로 인수 처리에 사용되는 기본 라이브러리를 숨기지 만 필요한 경우 기본 라이브러리를 직접 사용할 수있는 몇 가지 후크를 제공합니다. 예를 들어, 위의 'curl'예제의 마지막 두 줄을 다음으로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8204d604e9950c0ce44837c669e0a0911f64256c" translate="yes" xml:space="preserve">
          <source>Always 0 for an empty range.</source>
          <target state="translated">빈 범위의 경우 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="58849f5cb590e833734090ce086224eaa31aa520" translate="yes" xml:space="preserve">
          <source>Always does nothing for an empty range.</source>
          <target state="translated">빈 범위에 대해서는 항상 아무것도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca89a48309fa11cf6445def870eb88c910432e1c" translate="yes" xml:space="preserve">
          <source>Always returns an empty list for an empty range.</source>
          <target state="translated">빈 범위에 대해 항상 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="28f38d6013729c82924114f1c091d3050cb53f34" translate="yes" xml:space="preserve">
          <source>Always throws &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/SecurityException.html&quot;&gt;SecurityException&lt;/a&gt;.</source>
          <target state="translated">항상 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/SecurityException.html&quot;&gt;SecurityException을 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="4e7086efb60d5bbadf5dc2cec95243e7620ac955" translate="yes" xml:space="preserve">
          <source>Always throws &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; for an empty range.</source>
          <target state="translated">빈 범위에 대해 항상 &lt;code&gt;IndexOutOfBoundsException&lt;/code&gt; 을 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="949b210e9d2954dd75704428d63a6a6bb8453d69" translate="yes" xml:space="preserve">
          <source>Always throws &lt;code&gt;UnsupportedOperationException&lt;/code&gt; for an empty range.</source>
          <target state="translated">빈 범위에 대해 항상 &lt;code&gt;UnsupportedOperationException&lt;/code&gt; 을 throw 합니다.</target>
        </trans-unit>
        <trans-unit id="9e984526c670dfd887f53126414ad84bb5648d91" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;evictionlistener&quot;&gt;EvictionListener&lt;/a&gt; may be supplied for notification when an entry is evicted from the map. This listener is invoked on a caller's thread and will not block other threads from operating on the map. An implementation should be aware that the caller's thread will not expect long execution times or failures as a side effect of the listener being notified. Execution safety and a fast turn around time can be achieved by performing the operation asynchronously, such as by submitting a task to an &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html&quot;&gt;ExecutorService&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;evictionlistener&quot;&gt;EvictionListener는&lt;/a&gt; 항목이지도에서 제거 될 때 통지를 제공 할 수있다. 이 리스너는 호출자의 스레드에서 호출되며 다른 스레드가 맵에서 작동하는 것을 차단하지 않습니다. 구현은 호출자의 스레드가 알림을받는 리스너의 부작용으로 긴 실행 시간이나 실패를 예상하지 않는다는 점을 인식해야합니다. &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html&quot;&gt;ExecutorService에&lt;/a&gt; 작업을 제출하는 것과 같이 작업을 비동기 적으로 수행하여 실행 안전성과 빠른 처리 시간을 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9d7de633c0c08a318c5e0b16af0e1a215e68116" translate="yes" xml:space="preserve">
          <source>An AST transform with the ability to report errors.</source>
          <target state="translated">오류보고 기능이있는 AST 변환.</target>
        </trans-unit>
        <trans-unit id="39aec4a8379deb02fa1d759f535d177546b9b45a" translate="yes" xml:space="preserve">
          <source>An Annotation visitor responsible for:</source>
          <target state="translated">다음을 담당하는 주석 방문자 :</target>
        </trans-unit>
        <trans-unit id="c04e66499c6e6408829804408c70f57b14338d06" translate="yes" xml:space="preserve">
          <source>An IDENT token whose spelling is required to start with an uppercase letter.</source>
          <target state="translated">대문자로 시작하기 위해 철자가 필요한 IDENT 토큰입니다.</target>
        </trans-unit>
        <trans-unit id="7d0a670ccbde4835ccf4ec6452f94517c5ebb2a8" translate="yes" xml:space="preserve">
          <source>An IDENT token whose spelling is required to start with an uppercase letter. In the case of a simple statement {UpperID name} the identifier is taken to be a type name, not a command name.</source>
          <target state="translated">대문자로 시작하기 위해 철자가 필요한 IDENT 토큰입니다. 간단한 문 {UpperID name}의 경우 식별자는 명령 이름이 아닌 유형 이름으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="669ed57d9c4deac4a1891c9131f30f14a5d1430e" translate="yes" xml:space="preserve">
          <source>An IO exception occurred trying to append to a StringWriter which should never happen.</source>
          <target state="translated">발생하지 않아야하는 StringWriter에 추가하려는 중에 IO 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="e923950f1559538a6578d073fbdd185b29fa17f7" translate="yes" xml:space="preserve">
          <source>An MVC model package for working with user interfaces and data structures and arbitrary Java and Groovy objects</source>
          <target state="translated">사용자 인터페이스 및 데이터 구조와 임의의 Java 및 Groovy 객체 작업을위한 MVC 모델 패키지</target>
        </trans-unit>
        <trans-unit id="bde3aa303d9791b611b7dce06109f09ade29a22f" translate="yes" xml:space="preserve">
          <source>An MetaClass instance</source>
          <target state="translated">MetaClass 인스턴스</target>
        </trans-unit>
        <trans-unit id="836f83c12727d3995ba98943f8add7b6fa7c3efa" translate="yes" xml:space="preserve">
          <source>An Object array variant of &lt;a href=&quot;#call(java.lang.String,%20java.util.List)&quot;&gt;call(String, List)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#call(java.lang.String,%20java.util.List)&quot;&gt;call (String, List)&lt;/a&gt; 의 Object 배열 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="65f0cb3657ef737e4fa8e530cbc08d1355541c48" translate="yes" xml:space="preserve">
          <source>An Object array variant of &lt;a href=&quot;#execute(java.lang.String,%20java.util.List)&quot;&gt;execute(String, List)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#execute(java.lang.String,%20java.util.List)&quot;&gt;execute (String, List)&lt;/a&gt; 의 Object 배열 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="e1de4e3ff480b9cf6f14c81959d1ed6459ed34a7" translate="yes" xml:space="preserve">
          <source>An Object array variant of &lt;a href=&quot;#execute(java.lang.String,%20java.util.List,%20groovy.lang.Closure)&quot;&gt;execute(String, List, Closure)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#execute(java.lang.String,%20java.util.List,%20groovy.lang.Closure)&quot;&gt;execute (String, List, Closure)&lt;/a&gt; 의 개체 배열 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="8ddfb31ec6fdb40598a28b6707f2bbd44dffbec0" translate="yes" xml:space="preserve">
          <source>An Object array variant of &lt;a href=&quot;#executeInsert(java.lang.String,%20java.util.List)&quot;&gt;executeInsert(String, List)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#executeInsert(java.lang.String,%20java.util.List)&quot;&gt;executeInsert (String, List)&lt;/a&gt; 의 Object 배열 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="12ff017e846f27cf9a191fe8ba5c74bd253a6cc8" translate="yes" xml:space="preserve">
          <source>An Object array variant of &lt;a href=&quot;#executeUpdate(java.lang.String,%20java.util.List)&quot;&gt;executeUpdate(String, List)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#executeUpdate(java.lang.String,%20java.util.List)&quot;&gt;executeUpdate (String, List)&lt;/a&gt; 의 Object 배열 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="09d7ab17cd78952b24da19141af7dc1bf614135f" translate="yes" xml:space="preserve">
          <source>An Object array variant of &lt;a href=&quot;#firstRow(java.lang.String,%20java.util.List)&quot;&gt;firstRow(String, List)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#firstRow(java.lang.String,%20java.util.List)&quot;&gt;firstRow (String, List)&lt;/a&gt; 의 Object 배열 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="e40d5bd45bd608faf93e57dbaab2ac3e17d9eb7e" translate="yes" xml:space="preserve">
          <source>An Object array variant of &lt;a href=&quot;#rows(java.lang.String,%20java.util.List)&quot;&gt;rows(String, List)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#rows(java.lang.String,%20java.util.List)&quot;&gt;rows (String, List)&lt;/a&gt; 의 Object 배열 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="58db654b5cbbfc543db657a1a9fbcfa84ede0bee" translate="yes" xml:space="preserve">
          <source>An Object array variant of &lt;a href=&quot;#rows(java.lang.String,%20java.util.List,%20int,%20int)&quot;&gt;rows(String, List, int, int)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#rows(java.lang.String,%20java.util.List,%20int,%20int)&quot;&gt;rows (String, List, int, int)&lt;/a&gt; 의 객체 배열 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="92f4f54d02197791688420a22f2582a623f9e1c3" translate="yes" xml:space="preserve">
          <source>An Writer than eats its input.</source>
          <target state="translated">입력을 먹는 작가.</target>
        </trans-unit>
        <trans-unit id="7fc6727b617fbd3b4adf4cf188f000732a75874b" translate="yes" xml:space="preserve">
          <source>An abstract base class for a key used for comparators and Map keys to lookup a method by name and parameter types</source>
          <target state="translated">비교기에 사용되는 키의 추상 기본 클래스와 이름 및 매개 변수 유형별로 메서드를 조회하기위한 키 매핑</target>
        </trans-unit>
        <trans-unit id="b03413d6922fdbcef06e5b6eeb1400dedc69cfae" translate="yes" xml:space="preserve">
          <source>An abstract base class for nodes in the concrete syntax tree that is the result of parsing. Note that the CSTNode is inextricably linked with the Token in that every CSTNode has a Token as its root.</source>
          <target state="translated">구문 분석의 결과 인 구체적인 구문 트리의 노드에 대한 추상 기본 클래스입니다. CSTNode는 모든 CSTNode가 토큰을 루트로 가지고 있다는 점에서 토큰과 불가분의 관계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9064340a2ca7e25b093653d6e391fb57828ae977" translate="yes" xml:space="preserve">
          <source>An abstract syntax tree (AST) is created from token trees</source>
          <target state="translated">추상 구문 트리 (AST)는 토큰 트리에서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4443e9de2c8c72e64c734883cffa38d09bc42e42" translate="yes" xml:space="preserve">
          <source>An adapter to make any Groovy Script class an instance of a JUnit Test</source>
          <target state="translated">Groovy Script 클래스를 JUnit 테스트의 인스턴스로 만드는 어댑터</target>
        </trans-unit>
        <trans-unit id="0236910808eb246b3e4384427527ada795847d0a" translate="yes" xml:space="preserve">
          <source>An agent that can be used to defer cleanup operations to a later time. Users much implement the HasCleanup interface.</source>
          <target state="translated">나중에 정리 작업을 연기하는 데 사용할 수있는 에이전트입니다. 사용자는 HasCleanup 인터페이스를 많이 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f2fe84c7815f324cc7eee5cd16de968427a5f8ad" translate="yes" xml:space="preserve">
          <source>An aggregation of multiple bindings</source>
          <target state="translated">여러 바인딩의 집계</target>
        </trans-unit>
        <trans-unit id="3482dcd525c901f4b80ba4001eda21d2ca0bf7be" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;withLazyDefault&lt;/code&gt; which decorates a list allowing it to grow when called with index values outside the normal list bounds.</source>
          <target state="translated">일반 목록 경계를 벗어난 인덱스 값으로 호출 될 때 성장할 수 있도록 목록을 장식하는 &lt;code&gt;withLazyDefault&lt;/code&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="f25c69d47f0a852aecaaec7b32781f4e2518fb18" translate="yes" xml:space="preserve">
          <source>An alias method so that a process appears similar to System.out, System.in, System.err; you can use process.in, process.out, process.err in a similar fashion.</source>
          <target state="translated">프로세스가 System.out, System.in, System.err과 유사하게 보이도록하는 별칭 메서드. process.in, process.out, process.err을 비슷한 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b14b1afa639f1c113ee03af3175dd31501a37397" translate="yes" xml:space="preserve">
          <source>An alternative &lt;a href=&quot;../writercontroller&quot;&gt;WriterController&lt;/a&gt; which handles static types and method dispatch. In case of a &quot;mixed mode&quot; where only some methods are annotated with &lt;a href=&quot;../../../../../../groovy/transform/typechecked&quot;&gt;TypeChecked&lt;/a&gt; then this writer will delegate to the classic writer controller.</source>
          <target state="translated">정적 유형 및 메서드 디스패치를 ​​처리 하는 대체 &lt;a href=&quot;../writercontroller&quot;&gt;WriterController&lt;/a&gt; 입니다. 일부 메소드 만 &lt;a href=&quot;../../../../../../groovy/transform/typechecked&quot;&gt;TypeChecked&lt;/a&gt; 로 주석 처리 된 &quot;혼합 모드&quot;의 경우이 작성기는 클래식 작성기 컨트롤러에 위임됩니다.</target>
        </trans-unit>
        <trans-unit id="15ed613138bb69cb85e7e6f334e9498ed510ebe8" translate="yes" xml:space="preserve">
          <source>An alternative way of setting &lt;a href=&quot;#setDisallowedReceivers(java.util.List)&quot;&gt;receiver classes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#setDisallowedReceivers(java.util.List)&quot;&gt;수신자 클래스&lt;/a&gt; 를 설정하는 다른 방법 .</target>
        </trans-unit>
        <trans-unit id="249d07974f50c5c3dc917962ca9e4dba4e0319db" translate="yes" xml:space="preserve">
          <source>An alternative way of setting &lt;a href=&quot;#setReceiversWhiteList(java.util.List)&quot;&gt;receiver classes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#setReceiversWhiteList(java.util.List)&quot;&gt;수신자 클래스&lt;/a&gt; 를 설정하는 다른 방법 .</target>
        </trans-unit>
        <trans-unit id="e1282668406b8f0451fb3655385a215bf4c869e5" translate="yes" xml:space="preserve">
          <source>An alternative way of setting constant types.</source>
          <target state="translated">상수 유형을 설정하는 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b1ec7ca3feb0a851c4da31a34ab16d9a1cd4d87e" translate="yes" xml:space="preserve">
          <source>An annotation to hold the groovydoc for the annotated element at runtime, we call it &quot;Runtime Groovydoc&quot;. Runtime Groovydoc is a bit like Python's Documentation Strings and will be useful for IDE and developers who set a high value on documentations. The usage is very simple, just place @ at the beginning of the content of groovydoc, i.e. starts with /**@, then the new parser Parrot will attach the annotation Groovydoc automatically</source>
          <target state="translated">런타임시 주석이 추가 된 요소에 대한 groovydoc을 보유하는 주석으로 &quot;Runtime Groovydoc&quot;이라고합니다. 런타임 Groovydoc은 Python의 문서 문자열과 약간 유사하며 문서에 높은 가치를 설정하는 IDE 및 개발자에게 유용합니다. 사용법은 매우 간단합니다. groovydoc의 내용 시작 부분에 @를 입력하면됩니다. 즉 / ** @로 시작하면 새 파서 Parrot이 자동으로 Groovydoc 주석을 첨부합니다.</target>
        </trans-unit>
        <trans-unit id="ba7064d0f480d7ea101f70395a8db69d95b9a1b3" translate="yes" xml:space="preserve">
          <source>An annotation which is just a shortcut for @CompileStatic(TypeCheckingMode.SKIP). This can be used for example if you statically compile a full class but you want to skip some methods without having to use the full annotation.</source>
          <target state="translated">@CompileStatic (TypeCheckingMode.SKIP)에 대한 바로 가기 인 주석입니다. 예를 들어 전체 클래스를 정적으로 컴파일하지만 전체 주석을 사용하지 않고 일부 메서드를 건너 뛰려는 경우에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5a7bbee03811e3eb769d307b65a7451fa2ae677" translate="yes" xml:space="preserve">
          <source>An antlr AST visitor that prints groovy source code for each visited node to the supplied PrintStream.</source>
          <target state="translated">제공된 PrintStream에 방문한 각 노드에 대한 멋진 소스 코드를 인쇄하는 antlr AST 방문자입니다.</target>
        </trans-unit>
        <trans-unit id="69be16927afbae1449e7197a40a882927b9205f9" translate="yes" xml:space="preserve">
          <source>An appended block follows any expression.</source>
          <target state="translated">추가 된 블록은 모든 표현식을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="9fbb1e2147349baf166ec2353ccaf1f5de4c0df7" translate="yes" xml:space="preserve">
          <source>An appended block follows any expression. If the expression is not a method call, it is given an empty argument list.</source>
          <target state="translated">추가 된 블록은 모든 표현식을 따릅니다. 식이 메서드 호출이 아니면 빈 인수 목록이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="447880cdc2430e1a0e43573d2b889e755ca392a7" translate="yes" xml:space="preserve">
          <source>An array variant of &lt;a href=&quot;#executeInsert(java.lang.String,%20java.util.List,%20java.util.List)&quot;&gt;executeInsert(String, List, List)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#executeInsert(java.lang.String,%20java.util.List,%20java.util.List)&quot;&gt;executeInsert (String, List, List)&lt;/a&gt; 의 배열 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="1846eda4259af175f9ee3ca4a48d8ca5d3d777ce" translate="yes" xml:space="preserve">
          <source>An assignment operator '=' followed by an expression.</source>
          <target state="translated">할당 연산자 '='뒤에 표현식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4784ff64dcfa0d508c85ecbaee9906102e9235e2" translate="yes" xml:space="preserve">
          <source>An assignment operator '=' followed by an expression. (Never empty.)</source>
          <target state="translated">할당 연산자 '='뒤에 표현식이 있습니다. (비워 두지 마십시오.)</target>
        </trans-unit>
        <trans-unit id="7cf270d0a4d33a43ee3aa0865f9bf4820e98ecea" translate="yes" xml:space="preserve">
          <source>An encoded type information.</source>
          <target state="translated">인코딩 된 유형 정보입니다.</target>
        </trans-unit>
        <trans-unit id="71e3211690c8dd3f19ab2e7e73e452c6001f7181" translate="yes" xml:space="preserve">
          <source>An enhancement of Groovy's Sql class providing support for accessing and querying databases using POGO fields and operators rather than JDBC-level API calls and RDBMS column names. So, instead of a query like:</source>
          <target state="translated">JDBC 수준의 API 호출 및 RDBMS 열 이름이 아닌 POGO 필드 및 연산자를 사용하여 데이터베이스에 액세스하고 쿼리 할 수 ​​있도록 지원하는 Groovy의 Sql 클래스 향상. 따라서 다음과 같은 쿼리 대신 :</target>
        </trans-unit>
        <trans-unit id="bb5fc16761351896d078b6b93da579f8e554b5fb" translate="yes" xml:space="preserve">
          <source>An entry is evicted from the map when the</source>
          <target state="translated">항목은 다음과 같은 경우지도에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="7e58d326039a4258587d27f8bbf696cfba7a7c3d" translate="yes" xml:space="preserve">
          <source>An event used to propagate meta class updates</source>
          <target state="translated">메타 클래스 업데이트를 전파하는 데 사용되는 이벤트</target>
        </trans-unit>
        <trans-unit id="cd0135d2482f6d8f331846633602c6fbc34651f9" translate="yes" xml:space="preserve">
          <source>An example involving databases:</source>
          <target state="translated">데이터베이스와 관련된 예 :</target>
        </trans-unit>
        <trans-unit id="1de9e0c53e8c586fa3cab8353b44c341ef57230d" translate="yes" xml:space="preserve">
          <source>An example of this copy constructor at work:</source>
          <target state="translated">직장에서이 복사 생성자의 예 :</target>
        </trans-unit>
        <trans-unit id="1d486b1757b0482acffcaad369e263caaed820f8" translate="yes" xml:space="preserve">
          <source>An example showing a &lt;code&gt;use&lt;/code&gt; statement (allowing fine-grained application of the category methods):</source>
          <target state="translated">&lt;code&gt;use&lt;/code&gt; 문을 보여주는 예 (범주 메서드의 세분화 된 적용 허용) :</target>
        </trans-unit>
        <trans-unit id="68ddb73be0db75aa193ec568486003e28365ef5c" translate="yes" xml:space="preserve">
          <source>An example showing how to use the annotation at different levels:</source>
          <target state="translated">다양한 수준에서 주석을 사용하는 방법을 보여주는 예 :</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">예 :</target>
        </trans-unit>
        <trans-unit id="8dd9f66a7012d632b0656e2809561b9b654b1d1b" translate="yes" xml:space="preserve">
          <source>An exception occurred if a dynamic field dispatch fails with an unknown field. Note that the Missing*Exception classes were named for consistency and to avoid conflicts with JDK exceptions of the same name.</source>
          <target state="translated">동적 필드 디스패치가 알 수없는 필드로 실패하는 경우 예외가 발생했습니다. Missing * Exception 클래스는 일관성과 동일한 이름의 JDK 예외와의 충돌을 피하기 위해 이름이 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="baa39f78e4ac034bc737a8791647da347a5e2e3b" translate="yes" xml:space="preserve">
          <source>An exception occurred if a dynamic method dispatch fails with an unknown class. Note that the Missing*Exception classes were named for consistency and to avoid conflicts with JDK exceptions of the same name.</source>
          <target state="translated">알 수없는 클래스로 인해 동적 메소드 디스패치가 실패하면 예외가 발생했습니다. Missing * Exception 클래스는 일관성과 동일한 이름의 JDK 예외와의 충돌을 피하기 위해 이름이 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="bb0595e6018cd452290a402973cc67eba94d3d35" translate="yes" xml:space="preserve">
          <source>An exception occurred if a dynamic method dispatch fails with an unknown method.</source>
          <target state="translated">동적 메소드 디스패치가 알 수없는 메소드로 실패하면 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="2a4c6180069f06150e35225a79f168de0348a87d" translate="yes" xml:space="preserve">
          <source>An exception occurred if a dynamic property dispatch fails with a field not accessible.</source>
          <target state="translated">필드에 액세스 할 수없는 상태에서 동적 속성 디스패치가 실패하면 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="396972bf8057d1110e71986e8bdf780bec896c80" translate="yes" xml:space="preserve">
          <source>An exception occurred if a dynamic property dispatch fails with an unknown property. Note that the Missing*Exception classes were named for consistency and to avoid conflicts with JDK exceptions of the same name.</source>
          <target state="translated">동적 속성 디스패치가 알 수없는 속성으로 실패하면 예외가 발생했습니다. Missing * Exception 클래스는 일관성과 동일한 이름의 JDK 예외와의 충돌을 피하기 위해 이름이 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="ceb1dfc4dfbe75237e2b96645b62c886e4324c35" translate="yes" xml:space="preserve">
          <source>An exception occurred when invoking a Closure with the wrong number and/or types of arguments</source>
          <target state="translated">잘못된 수 및 / 또는 인수 유형을 사용하여 Closure를 호출 할 때 예외가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="82b43e0c798dfb1e1f7676733e1fd9e2d6fd5700" translate="yes" xml:space="preserve">
          <source>An exception thrown by a closure invocation</source>
          <target state="translated">클로저 호출로 인한 예외</target>
        </trans-unit>
        <trans-unit id="345498a4bb8a2134879bc3bac1cb1647374d19fa" translate="yes" xml:space="preserve">
          <source>An exception thrown by the class generator</source>
          <target state="translated">클래스 생성기에서 발생한 예외</target>
        </trans-unit>
        <trans-unit id="b29c9169229b5b6888eb10ad74474da930f2d251" translate="yes" xml:space="preserve">
          <source>An exception thrown by the interpreter</source>
          <target state="translated">인터프리터가 던진 예외</target>
        </trans-unit>
        <trans-unit id="0fb65b774536d52b51d0a7eb9624ffd24a622abe" translate="yes" xml:space="preserve">
          <source>An exception thrown if a method is called and an exception occurred</source>
          <target state="translated">메서드가 호출되고 예외가 발생한 경우 throw되는 예외</target>
        </trans-unit>
        <trans-unit id="12442562193e09b14bdf2499761f36367b68a886" translate="yes" xml:space="preserve">
          <source>An expression helper which generates optimized bytecode depending on the current type on top of the operand stack.</source>
          <target state="translated">피연산자 스택 상단의 현재 유형에 따라 최적화 된 바이트 코드를 생성하는 표현식 도우미입니다.</target>
        </trans-unit>
        <trans-unit id="d90cdabb132ee8f5d627e9429df63369688c5cc8" translate="yes" xml:space="preserve">
          <source>An expression may be followed by [...].</source>
          <target state="translated">표현식 뒤에 [...]가 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5acc44b610971c828ae1d033e3648eaf9d47708c" translate="yes" xml:space="preserve">
          <source>An expression may be followed by [...]. Unlike Java, these brackets may contain a general argument list, which is passed to the array element operator, which can make of it what it wants. The brackets may also be empty, as in T[]. This is how Groovy names array types.</source>
          <target state="translated">표현식 뒤에 [...]가 올 수 있습니다. Java와 달리 이러한 대괄호에는 일반적인 인수 목록이 포함될 수 있습니다.이 목록은 배열 요소 연산자로 전달되어 원하는대로 만들 수 있습니다. 대괄호는 T []와 같이 비어있을 수도 있습니다. 이것이 Groovy가 배열 유형을 명명하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="e2e07a487e58cd131f3df1951c23356ef84cff3e" translate="yes" xml:space="preserve">
          <source>An expression may be followed by one or both of (...) and {...}.</source>
          <target state="translated">표현식 뒤에 (...) 및 {...} 중 하나 또는 둘 다가 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eddc75426281b96ccf920c7acb499e18451bd9f3" translate="yes" xml:space="preserve">
          <source>An expression may be followed by one or both of (...) and {...}. Note: If either is (...) or {...} present, it is a method call. The {...} is appended to the argument list, and matches a formal of type Closure. If there is no method member, a property (or field) is used instead, and must itself be callable.</source>
          <target state="translated">표현식 뒤에 (...) 및 {...} 중 하나 또는 둘 다가 올 수 있습니다. 참고 : (...) 또는 {...} 중 하나가 있으면 메서드 호출입니다. {...}는 인수 목록에 추가되고 클로저 유형의 형식과 일치합니다. 메서드 멤버가 없으면 대신 속성 (또는 필드)이 사용되며 자체적으로 호출 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="042cc8d2306a6b6aec7132ca852708135dccb173" translate="yes" xml:space="preserve">
          <source>An expression statement can also be a &lt;em&gt;command&lt;/em&gt;, which is a simple method call in which the outermost parentheses are omitted.</source>
          <target state="translated">표현식 문은 가장 바깥 쪽 괄호가 생략 된 간단한 메서드 호출 인 &lt;em&gt;command&lt;/em&gt; 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93d0501133ae82c62aa6f80f42a9be1747b20a89" translate="yes" xml:space="preserve">
          <source>An expression statement can be any general expression.</source>
          <target state="translated">식 문은 모든 일반식이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c52e2cf701a01ae8ba3dc424512c377267f189b" translate="yes" xml:space="preserve">
          <source>An expression transformer used in the process of replacing the access to variables</source>
          <target state="translated">변수에 대한 액세스를 대체하는 프로세스에 사용되는 표현식 변환기</target>
        </trans-unit>
        <trans-unit id="9b22fe3870ff9f294fe67cf112c94be02be876fd" translate="yes" xml:space="preserve">
          <source>An extension module is a class responsible for providing a list of &lt;a href=&quot;../../../../../groovy/lang/metamethod&quot;&gt;meta methods&lt;/a&gt; to the Groovy compiler and runtime. Those methods are use to &quot;dynamically extend&quot; existing classes by adding methods to existing classes.</source>
          <target state="translated">확장 모듈은 Groovy 컴파일러 및 런타임 에 &lt;a href=&quot;../../../../../groovy/lang/metamethod&quot;&gt;메타 메서드&lt;/a&gt; 목록을 제공하는 클래스 입니다. 이러한 메서드는 기존 클래스에 메서드를 추가하여 기존 클래스를 &quot;동적으로 확장&quot;하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6670b06ae4503c43fbbf1f1c95bb0e30f9b9b771" translate="yes" xml:space="preserve">
          <source>An extension module which provides extension methods using a &lt;a href=&quot;../defaultgroovymethods&quot;&gt;DefaultGroovyMethods&lt;/a&gt;-like implementation, that is to say using static methods defined in an &quot;extension class&quot;.</source>
          <target state="translated">&lt;a href=&quot;../defaultgroovymethods&quot;&gt;DefaultGroovyMethods&lt;/a&gt; 와 유사한 구현, 즉 &quot;확장 클래스&quot;에 정의 된 정적 메서드를 사용하여 확장 메서드를 제공하는 확장 모듈입니다 .</target>
        </trans-unit>
        <trans-unit id="b3ec255e06dde7921225fe404d4ca17b2071bbc0" translate="yes" xml:space="preserve">
          <source>An extension point allowing derived classes to change the behavior of connection creation.</source>
          <target state="translated">파생 클래스가 연결 생성 동작을 변경할 수 있도록하는 확장 점입니다.</target>
        </trans-unit>
        <trans-unit id="7593217609d7d5334ad064d1653effaa8188966c" translate="yes" xml:space="preserve">
          <source>An extension point allowing derived classes to change the behavior of connection creation. The default behavior is to either use the supplied connection or obtain it from the supplied datasource.</source>
          <target state="translated">파생 클래스가 연결 생성 동작을 변경할 수 있도록하는 확장 점입니다. 기본 동작은 제공된 연결을 사용하거나 제공된 데이터 소스에서 가져 오는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2222d1d352aa79812cdfbb723af409de2ee5a140" translate="yes" xml:space="preserve">
          <source>An extension point allowing derived classes to change the behavior of resource closing.</source>
          <target state="translated">파생 클래스가 리소스 닫기 동작을 변경할 수 있도록하는 확장 점입니다.</target>
        </trans-unit>
        <trans-unit id="dfab41e3ac5af0fded2ceda7ed5d81f1b8fd13aa" translate="yes" xml:space="preserve">
          <source>An extension point allowing the behavior of resource closing to be overridden in derived classes.</source>
          <target state="translated">파생 클래스에서 리소스 닫기 동작을 재정의 할 수있는 확장 점입니다.</target>
        </trans-unit>
        <trans-unit id="abfac0adc6d23d1039c7113ef317699df390da6b" translate="yes" xml:space="preserve">
          <source>An identifier that should be used to disambiguate targets when there are multiple &lt;code&gt;@DelegatesTo.Target&lt;/code&gt; annotated parameters.</source>
          <target state="translated">&lt;code&gt;@DelegatesTo.Target&lt;/code&gt; 어노테이션이있는 매개 변수 가 여러 개있을 때 대상을 명확하게하는 데 사용해야하는 식별자입니다 .</target>
        </trans-unit>
        <trans-unit id="dde9b6195dfaa9c21f80e9ac599040bb294f977b" translate="yes" xml:space="preserve">
          <source>An identity function for iterators, supporting 'duck-typing' when trying to get an iterator for each object within a collection, some of which may already be iterators.</source>
          <target state="translated">컬렉션 내의 각 개체에 대한 반복자를 가져 오려고 할 때 '오리 입력'을 지원하는 반복기의 ID 함수입니다. 일부는 이미 반복 기일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd2603ea1540ce23d60ea20ee550bcd379c7ef37" translate="yes" xml:space="preserve">
          <source>An implementation for BufferedIterator wraps Iterator.</source>
          <target state="translated">BufferedIterator에 대한 구현은 Iterator를 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="49cc77433f46213685fde1673e3ba605669f4524" translate="yes" xml:space="preserve">
          <source>An implementation for BufferedIterator wraps ListIterator. This version provides an implementation for remove().</source>
          <target state="translated">BufferedIterator에 대한 구현은 ListIterator를 래핑합니다. 이 버전은 remove ()에 대한 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="725b2f343c1cf619ad90fcb4f685f34d7d46a46f" translate="yes" xml:space="preserve">
          <source>An implementation of the visitor pattern for working with ASTNodes.</source>
          <target state="translated">ASTNodes 작업을위한 방문자 패턴 구현입니다.</target>
        </trans-unit>
        <trans-unit id="d52961cb76cd4860ed28fccc6b23eeb6efa99251" translate="yes" xml:space="preserve">
          <source>An import of a single type, i.e. &lt;code&gt;import pack.Type&lt;/code&gt; or &lt;code&gt;import pack.Type as Alias&lt;/code&gt;</source>
          <target state="translated">단일 유형 &lt;code&gt;import pack.Type&lt;/code&gt; , 즉 import pack.Type 또는 &lt;code&gt;import pack.Type as Alias&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41f708432dec96ac86ae9978bda7d48e1dcf063c" translate="yes" xml:space="preserve">
          <source>An import of a static field or method of a type, i.e. &lt;code&gt;import static pack.Type.name&lt;/code&gt; or &lt;code&gt;import static pack.Type.name as alias&lt;/code&gt;</source>
          <target state="translated">정적 필드 또는 유형의 메소드 &lt;code&gt;import static pack.Type.name&lt;/code&gt; 예 : 정적 pack.Type.name &lt;code&gt;import static pack.Type.name as alias&lt;/code&gt; 또는 별칭으로 정적 pack.Type.name 가져 오기)</target>
        </trans-unit>
        <trans-unit id="655ba261dcf136265be9c34f2ba650181eda9b81" translate="yes" xml:space="preserve">
          <source>An import of all static members of a type, i.e. &lt;code&gt;import static pack.Type.*&lt;/code&gt;</source>
          <target state="translated">유형의 모든 정적 멤버 &lt;code&gt;import static pack.Type.*&lt;/code&gt; , 즉 import static pack.Type. *</target>
        </trans-unit>
        <trans-unit id="136570a8b03bf1e6a0d823fefc4fad793e3725c6" translate="yes" xml:space="preserve">
          <source>An import of all types in a package, i.e. &lt;code&gt;import pack.*&lt;/code&gt;</source>
          <target state="translated">패키지의 모든 유형 &lt;code&gt;import pack.*&lt;/code&gt; , 즉 가져 오기 팩. *</target>
        </trans-unit>
        <trans-unit id="6fa788e5b4da82cdfeca0ff1034e5d73a1b63ebf" translate="yes" xml:space="preserve">
          <source>An instance of the java.lang.Class that this MetaObjectProtocol object applies to</source>
          <target state="translated">이 MetaObjectProtocol 객체가 적용되는 java.lang.Class의 인스턴스</target>
        </trans-unit>
        <trans-unit id="7da9f9d4d4340d8710760513b2d06eccfcb4516f" translate="yes" xml:space="preserve">
          <source>An interactive command line terminal along with a Swing console for evaluating Groovy scripts and inspecting objects, AST and bytecode information.</source>
          <target state="translated">Groovy 스크립트를 평가하고 객체, AST 및 바이트 코드 정보를 검사하기위한 Swing 콘솔과 함께 대화 형 명령 줄 터미널.</target>
        </trans-unit>
        <trans-unit id="ff3c52785adf1154b1c87e4139bf1ae652236a25" translate="yes" xml:space="preserve">
          <source>An interactive command line terminal along with a Swing console for evaluating Groovy scripts.</source>
          <target state="translated">Groovy 스크립트를 평가하기위한 Swing 콘솔과 함께 대화 형 명령 줄 터미널.</target>
        </trans-unit>
        <trans-unit id="c2d24e06e9c9ed48271c85b931996f1452a91516" translate="yes" xml:space="preserve">
          <source>An interactive shell for evaluating Groovy code from the command-line (aka. groovysh). The set of available commands can be modified by placing a file in the classpath named &lt;code&gt;org/codehaus/groovy/tools/shell/commands.xml&lt;/code&gt; See &lt;a href=&quot;util/xmlcommandregistrar&quot;&gt;XmlCommandRegistrar&lt;/a&gt;</source>
          <target state="translated">명령 줄 (일명 groovysh)에서 Groovy 코드를 평가하기위한 대화 형 쉘입니다. 사용 가능한 명령의 세트라는 이름의 클래스 경로에 파일을 배치하여 수정할 수 있습니다 &lt;code&gt;org/codehaus/groovy/tools/shell/commands.xml&lt;/code&gt; 참조 &lt;a href=&quot;util/xmlcommandregistrar&quot;&gt;XmlCommandRegistrar&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="149ec0e58f50b91b7dbad17c891a791e7290cd5a" translate="yes" xml:space="preserve">
          <source>An interface for MetaClass instances that &quot;adapt&quot; other MetaClass instances such as a proxy or delegating MetaClass.</source>
          <target state="translated">프록시 또는 위임 MetaClass와 같은 다른 MetaClass 인스턴스를 &quot;적응&quot;하는 MetaClass 인스턴스 용 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="63e1c9cd7b27e1ac089a836b73d6506b846c0174" translate="yes" xml:space="preserve">
          <source>An interface for MetaMethods that invoke closures to implements. Used by ExpandoMetaClass</source>
          <target state="translated">구현할 클로저를 호출하는 MetaMethods 용 인터페이스입니다. ExpandoMetaClass에서 사용</target>
        </trans-unit>
        <trans-unit id="d508b08ff93fe66a2762a135f27dbfdd6fb38284" translate="yes" xml:space="preserve">
          <source>An interface for processing antlr AST objects</source>
          <target state="translated">antlr AST 오브젝트 처리를위한 인터페이스</target>
        </trans-unit>
        <trans-unit id="d61ee9aae1cf6aaff2a1bee799ad2b0030959d8f" translate="yes" xml:space="preserve">
          <source>An interface for things that can supply (and potentially resupply) a Reader on a source stream.</source>
          <target state="translated">소스 스트림에서 리더를 공급할 수있는 (그리고 잠재적으로 재 공급할 수있는) 사물에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="0979b7c1be06cf9e5dfed9a3b26406a5e62c12d6" translate="yes" xml:space="preserve">
          <source>An interface for things that need to be cleaned up after operations complete.</source>
          <target state="translated">작업 완료 후 정리해야하는 항목에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="4921d5d5c4b5a0a9a6c1c751be6f06cfa85bd3b6" translate="yes" xml:space="preserve">
          <source>An interface for visiting a GroovySourceAST node.</source>
          <target state="translated">GroovySourceAST 노드를 방문하기위한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="72b33ef35193d6cfb5341eb2ed573472baf40277" translate="yes" xml:space="preserve">
          <source>An interface implemented by some Groovy proxies which gives access to the proxied object. In particular, dynamically generated proxies that implement traits will implement this interface in order to give access to the proxied instance.</source>
          <target state="translated">프록시 된 객체에 대한 액세스를 제공하는 일부 Groovy 프록시에 의해 구현 된 인터페이스입니다. 특히, 특성을 구현하는 동적으로 생성 된 프록시는 프록시 된 인스턴스에 대한 액세스 권한을 부여하기 위해이 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="fe46a8e9f6b65f0fa51edab069fa67eec6e8bf86" translate="yes" xml:space="preserve">
          <source>An interface that adds the ability to intercept property getters/setters</source>
          <target state="translated">속성 getter / setter를 가로채는 기능을 추가하는 인터페이스</target>
        </trans-unit>
        <trans-unit id="39f08ce3019139dd1216deaaee16022b8df7c677" translate="yes" xml:space="preserve">
          <source>An interface that defines methods that implementers of mutable Meta classes should specify. It provides operations to perform mutations on the MetaClass instance.</source>
          <target state="translated">변경 가능한 Meta 클래스의 구현자가 지정해야하는 메서드를 정의하는 인터페이스입니다. MetaClass 인스턴스에서 변형을 수행하는 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5d57a4c4b7f42fa6852ab5b04649d7ba38c1806c" translate="yes" xml:space="preserve">
          <source>An interface that defines the API usable by clients of Groovy's Meta Object Protocol (MOP). These methods are implemented by the reference implementation of the &lt;a href=&quot;metaclass&quot;&gt;MetaClass&lt;/a&gt; interface.</source>
          <target state="translated">Groovy의 MOP (Meta Object Protocol) 클라이언트가 사용할 수있는 API를 정의하는 인터페이스입니다. 이러한 메서드는 &lt;a href=&quot;metaclass&quot;&gt;MetaClass&lt;/a&gt; 인터페이스 의 참조 구현에 의해 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="7fdd0f31e1a8dd7fa42106d5c84f101bde178e18" translate="yes" xml:space="preserve">
          <source>An interface to mark a node being able to handle metadata.</source>
          <target state="translated">메타 데이터를 처리 할 수있는 노드를 표시하는 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="93f0276093b80d863208015f9bfd26c706f61fe7" translate="yes" xml:space="preserve">
          <source>An iterator that allows examining the next element without consuming it.</source>
          <target state="translated">다음 요소를 소비하지 않고 검사 할 수있는 반복기입니다.</target>
        </trans-unit>
        <trans-unit id="6587a50469f24cc063e384fb1825b23eaf615f7d" translate="yes" xml:space="preserve">
          <source>An object is deemed equal to this NumberRange if it represents a List of items and those items equal the list of discrete items represented by this NumberRange.</source>
          <target state="translated">개체가 항목 목록을 나타내고 해당 항목이이 NumberRange로 표시되는 개별 항목 목록과 같은 경우이 NumberRange와 같은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ad785d93ad147c4f5d2dc326dd3e11b7c24b277b" translate="yes" xml:space="preserve">
          <source>An object representing a line and column position</source>
          <target state="translated">선 및 열 위치를 나타내는 개체</target>
        </trans-unit>
        <trans-unit id="2d9404a512533e77273353f99d2c3835a1bc7ebd" translate="yes" xml:space="preserve">
          <source>An object which supports GPath expressions</source>
          <target state="translated">GPath 표현식을 지원하는 객체</target>
        </trans-unit>
        <trans-unit id="ddfff4ea58d7ba6b87d025e6aa923fdfae7fc71f" translate="yes" xml:space="preserve">
          <source>An open block is not allowed to have closure arguments.</source>
          <target state="translated">열린 블록은 클로저 인수를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac6af64a7c6d623f71c7dfecb686dbb283ec499e" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;visibilityId&lt;/code&gt; attribute can be specified. If present, it must match the optional &lt;code&gt;id&lt;/code&gt; attribute of an applicable &lt;code&gt;VisibilityOptions&lt;/code&gt; annotation. This can be useful if multiple &lt;code&gt;VisibilityOptions&lt;/code&gt; annotations are needed.</source>
          <target state="translated">선택적 &lt;code&gt;visibilityId&lt;/code&gt; 속성을 지정할 수 있습니다. 존재 하는 경우 적용 가능한 &lt;code&gt;VisibilityOptions&lt;/code&gt; 주석 의 선택적 &lt;code&gt;id&lt;/code&gt; 속성 과 일치해야합니다 . 여러 &lt;code&gt;VisibilityOptions&lt;/code&gt; 주석이 필요한 경우 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0108543a71e82876406b6350df0c0a4ac28cf83" translate="yes" xml:space="preserve">
          <source>An optional Closure may be specified and will work as a filter, if it returns true the property will trigger an event (if the value indeed changed), otherwise it won't. The Closure may receive 1 or 2 parameters, the single one being the value, the other one both the key and value, for example:</source>
          <target state="translated">선택적 Closure가 지정 될 수 있으며 필터로 작동합니다. true를 반환하면 속성이 이벤트를 트리거하고 (값이 실제로 변경된 경우) 그렇지 않으면 그렇지 않습니다. Closure는 1 개 또는 2 개의 매개 변수를 수신 할 수 있습니다. 하나는 값이고 다른 하나는 키와 값입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="361f0e65ae2e905732baf1f27254576e76c5dba9" translate="yes" xml:space="preserve">
          <source>An underlying parser that supports what is called argument 'bursting' is used by default. Bursting would convert '-alt' into '-a -l -t' provided no long option exists with value 'alt' and provided that none of 'a', 'l' or 't' takes an argument (in fact the last one is allowed to take an argument). The bursting behavior can be turned off by configuring the underlying parser. The simplest way to achieve this is by setting the posix property on the CliBuilder to false, i.e. include &lt;code&gt;posix: false&lt;/code&gt; in the constructor call.</source>
          <target state="translated">기본적으로 인수 '버스 팅'을 지원하는 기본 파서가 사용됩니다. 버스 팅은 '-alt'를 '-a -l -t'로 변환합니다. 하나는 논쟁을 할 수 있습니다). 버스 팅 동작은 기본 파서를 구성하여 해제 할 수 있습니다. 이를 달성하는 가장 간단한 방법은 CliBuilder의 posix 속성을 false로 설정하는 것입니다. 즉 , 생성자 호출에 &lt;code&gt;posix: false&lt;/code&gt; 를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="5d417e0092154a30a82d618a2fa68b2169ed2fe1" translate="yes" xml:space="preserve">
          <source>An underlying parser that supports what is called argument 'bursting' is used by default. Bursting would convert '-alt' into '-a -l -t' provided no long option exists with value 'alt' and provided that none of 'a', 'l' or 't' takes an argument (in fact the last one is allowed to take an argument). The bursting behavior can be turned off by using an alternate underlying parser. The simplest way to achieve this is by using the deprecated GnuParser from Commons CLI with the parser property on the CliBuilder, i.e. include &lt;code&gt;parser: new GnuParser()&lt;/code&gt; in the constructor call.</source>
          <target state="translated">기본적으로 인수 '버스 팅'을 지원하는 기본 파서가 사용됩니다. 버스 팅은 '-alt'를 '-a -l -t'로 변환합니다. 단, 'alt'값이있는 긴 옵션이없고 'a', 'l'또는 't'가 인수를받지 않는 경우 (사실 마지막 하나는 논쟁을 할 수 있습니다). 버스 팅 동작은 대체 기본 파서를 사용하여 해제 할 수 있습니다. 이를 달성하는 가장 간단한 방법은 CliBuilder의 parser 속성과 함께 Commons CLI에서 더 이상 사용되지 않는 GnuParser를 사용하는 것입니다. 즉 , 생성자 호출에 &lt;code&gt;parser: new GnuParser()&lt;/code&gt; 를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="946708df4de50bf4ab15310e00caaf56cf30f708" translate="yes" xml:space="preserve">
          <source>An utility class which can be used in test cases to dump generated bytecode.</source>
          <target state="translated">생성 된 바이트 코드를 덤프하기 위해 테스트 케이스에서 사용할 수있는 유틸리티 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="b99a39cc3ba0dde646dbbf624abead7a7e338ec6" translate="yes" xml:space="preserve">
          <source>And after normal default parameter processing takes place, the following overloaded methods will exist:</source>
          <target state="translated">그리고 정상적인 기본 매개 변수 처리가 발생한 후에는 다음과 같은 오버로드 된 메서드가 존재합니다.</target>
        </trans-unit>
        <trans-unit id="31100864e4bca9061d66be89d21e7b597d33a35f" translate="yes" xml:space="preserve">
          <source>And if called with the following arguments '-logfile foo -Dbar=baz -lib=/tmp,/usr/lib,~/libs target' then the following assertions would be true:</source>
          <target state="translated">그리고 '-logfile foo -Dbar = baz -lib = / tmp, / usr / lib, ~ / libs target'인수를 사용하여 호출하면 다음 어설 션이 참이됩니다.</target>
        </trans-unit>
        <trans-unit id="0a1b902883cba83627357533ce7a06f444452e39" translate="yes" xml:space="preserve">
          <source>And if called with the following arguments '-logfile foo -Dbar=baz target' then the following assertions would be true:</source>
          <target state="translated">그리고 다음 인수 '-logfile foo -Dbar = baz target'을 사용하여 호출하면 다음 주장이 참이됩니다.</target>
        </trans-unit>
        <trans-unit id="ef1687099b5e72342f7b6d7222a8af7322427097" translate="yes" xml:space="preserve">
          <source>And these nested tasks:</source>
          <target state="translated">그리고 이러한 중첩 된 작업 :</target>
        </trans-unit>
        <trans-unit id="62db03f1c30c83748bc98a8c21af6a37e8739371" translate="yes" xml:space="preserve">
          <source>And via implicit hard-coded keywords:</source>
          <target state="translated">그리고 암시 적 하드 코딩 된 키워드를 통해 :</target>
        </trans-unit>
        <trans-unit id="e1060ddb882a373584a09180888ccacaed217a42" translate="yes" xml:space="preserve">
          <source>And you also have to contend with a possible &lt;code&gt;SecurityException&lt;/code&gt; when getting the system properties (See &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getProperties()&quot;&gt;System.getProperties&lt;/a&gt;). A safer approach would be to copy a default &lt;code&gt;CompilerConfiguration&lt;/code&gt; and make your changes there using the setter:</source>
          <target state="translated">또한 시스템 속성을 가져올 때 가능한 &lt;code&gt;SecurityException&lt;/code&gt; 과 경쟁해야 합니다 ( &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getProperties()&quot;&gt;System.getProperties&lt;/a&gt; 참조 ). 더 안전한 방법은 기본 &lt;code&gt;CompilerConfiguration&lt;/code&gt; 을 복사 하고 setter를 사용하여 변경하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="feb0f5ed0ed2780340132eee761f316fa9ce7bf4" translate="yes" xml:space="preserve">
          <source>Annotates a groovy property or a class.</source>
          <target state="translated">그루비 속성이나 클래스에 주석을 답니다.</target>
        </trans-unit>
        <trans-unit id="18a29dbf803be2522bf37d4c26e4311bd6194c51" translate="yes" xml:space="preserve">
          <source>Annotates a groovy property or a class. When annotating a property it indicates that the property should be a bound property according to the JavaBeans spec, announcing to listeners that the value has changed.</source>
          <target state="translated">그루비 속성이나 클래스에 주석을 답니다. 속성에 주석을 달 때 속성이 JavaBeans 사양에 따라 바인딩 된 속성이어야 함을 나타내며 리스너에게 값이 변경되었음을 알립니다.</target>
        </trans-unit>
        <trans-unit id="73e4d41262a615051e78a930a713101d193fc99e" translate="yes" xml:space="preserve">
          <source>Annotating anything in a script will cause for loops, while loops, methods, and closures to make a check against the specified closure. If the closure yields true (according to GroovyTruth), then the script will throw an InterruptedException. The annotation by default applies to any classes defined in the script as well. Annotated a class will cause (by default) all classes in the entire file ('Compilation Unit') to be enhanced. You can fine tune what is enhanced using the annotation parameters.</source>
          <target state="translated">스크립트의 모든 것에 주석을 달면 for 루프가 발생하고 루프, 메서드 및 클로저는 지정된 클로저를 확인합니다. 클로저가 참이면 (GroovyTruth에 따라) 스크립트는 InterruptedException을 던질 것입니다. 기본적으로 주석은 스크립트에 정의 된 모든 클래스에도 적용됩니다. 클래스에 주석을 달면 (기본적으로) 전체 파일 ( 'Compilation Unit')의 모든 클래스가 향상됩니다. 주석 매개 변수를 사용하여 향상된 기능을 미세 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a51115cd32549d9d8074a93d2249af8dd040afff" translate="yes" xml:space="preserve">
          <source>Annotating anything in a script will cause for loops, while loops, methods, and closures to make an elapsed time check and throw a TimeoutException if the check yields true. The annotation by default will apply to any classes defined in the script as well. Annotating a class will cause (by default) all classes in the entire file ('Compilation Unit') to be enhanced. You can fine tune what is enhanced using the annotation parameters. Static methods and static fields are ignored.</source>
          <target state="translated">스크립트에 주석을 추가하면 for 루프가 발생하고 루프, 메서드 및 클로저는 경과 시간을 확인하고 확인 결과가 참이면 TimeoutException을 발생시킵니다. 기본적으로 주석은 스크립트에 정의 된 모든 클래스에도 적용됩니다. 클래스에 주석을 달면 (기본적으로) 전체 파일 ( 'Compilation Unit')의 모든 클래스가 향상됩니다. 주석 매개 변수를 사용하여 향상된 기능을 미세 조정할 수 있습니다. 정적 메서드 및 정적 필드는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9fbbbe6655e23b1f935f3e3a9f096fe7b42766aa" translate="yes" xml:space="preserve">
          <source>Annotating anything in a script will cause for loops, while loops, methods, and closures to make an isInterruptedCheck and throw a InterruptedException if the check yields true. The annotation by default will apply to any classes defined in the script as well. Annotated a class will cause (by default) all classes in the entire file ('Compilation Unit') to be enhanced. You can fine tune what is enhanced using the annotation parameters.</source>
          <target state="translated">스크립트에 주석을 추가하면 for 루프가 발생하고, 루프, 메서드 및 클로저는 isInterruptedCheck를 만들고 확인 결과가 참이면 InterruptedException을 발생시킵니다. 기본적으로 주석은 스크립트에 정의 된 모든 클래스에도 적용됩니다. 클래스에 주석을 달면 (기본적으로) 전체 파일 ( 'Compilation Unit')의 모든 클래스가 향상됩니다. 주석 매개 변수를 사용하여 향상된 기능을 미세 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de3b78b64190965365f72568ffbe049d4ba32c22" translate="yes" xml:space="preserve">
          <source>Annotation</source>
          <target state="translated">Annotation</target>
        </trans-unit>
        <trans-unit id="3bd2ae4bd4853126b72b32664fbc95c556c37a66" translate="yes" xml:space="preserve">
          <source>Annotation that supports writing constructor call expressions without the 'new' keyword. Instead they can be written &quot;Ruby-style&quot; as a method call to a 'new' method or &quot;Python-style&quot; by just omitting the 'new' keyword.</source>
          <target state="translated">'new'키워드없이 생성자 호출 표현식 작성을 지원하는 주석. 대신 'new'키워드를 생략하여 'new'메소드 또는 'Python 스타일'에 대한 메소드 호출로 &quot;Ruby 스타일&quot;로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4096cd9b027c657a5e7d97844010020f67ac89be" translate="yes" xml:space="preserve">
          <source>Annotation to automatically add the final qualifier to method, constructor, and closure parameters.</source>
          <target state="translated">메서드, 생성자 및 클로저 매개 변수에 최종 한정자를 자동으로 추가하는 주석입니다.</target>
        </trans-unit>
        <trans-unit id="106111539f1c83706b8831f53c2b23e41bd0c3f6" translate="yes" xml:space="preserve">
          <source>Annotation to automatically delegate part of the functionality of an owner class to the annotated delegation target. The target can be a field (or property) or a method's return value.</source>
          <target state="translated">소유자 클래스 기능의 일부를 주석이 달린 위임 대상에 자동으로 위임하는 주석입니다. 대상은 필드 (또는 속성) 또는 메서드의 반환 값일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32e5b99987de4a53d5e4800a718596c542dd5273" translate="yes" xml:space="preserve">
          <source>Annotation to indicate experimental and still to be refined API, which may change at any time</source>
          <target state="translated">실험적이며 아직 정제되지 않은 API를 나타내는 주석 (언제든지 변경 될 수 있음)</target>
        </trans-unit>
        <trans-unit id="628916cfdb6a1d3bf1782011f1fd7d59375ec9f6" translate="yes" xml:space="preserve">
          <source>Annotation used for turning off Groovy's auto visibility conventions. By default, Groovy automatically turns package protected fields into properties and makes package protected methods, constructors and classes public. This annotation allows this feature to be turned off and revert back to Java behavior if needed. Place it on classes, fields, constructors or methods of interest as follows:</source>
          <target state="translated">Groovy의 자동 가시성 규칙을 끄는 데 사용되는 주석입니다. 기본적으로 Groovy는 자동으로 패키지 보호 필드를 속성으로 변환하고 패키지 보호 메서드, 생성자 및 클래스를 공개합니다. 이 주석을 사용하면이 기능을 끄고 필요한 경우 Java 동작으로 되돌릴 수 있습니다. 다음과 같이 관심있는 클래스, 필드, 생성자 또는 메서드에 배치합니다.</target>
        </trans-unit>
        <trans-unit id="deb49c12844bdde0681de09dfb9c7074626d4e63" translate="yes" xml:space="preserve">
          <source>AnnotationCollector</source>
          <target state="translated">AnnotationCollector</target>
        </trans-unit>
        <trans-unit id="e38bdf70a194edb101cc7fa00c749c22ea2c2906" translate="yes" xml:space="preserve">
          <source>AnnotationCollectorMode.DUPLICATE</source>
          <target state="translated">AnnotationCollectorMode.DUPLICATE</target>
        </trans-unit>
        <trans-unit id="bba8527e63248d9280c9192eb1f3030178320255" translate="yes" xml:space="preserve">
          <source>AnnotationCollectorTransform</source>
          <target state="translated">AnnotationCollectorTransform</target>
        </trans-unit>
        <trans-unit id="79edee40f276c7eba97545c42f45abac2cd48f79" translate="yes" xml:space="preserve">
          <source>AnnotationCollectorTransform.visit</source>
          <target state="translated">AnnotationCollectorTransform.visit</target>
        </trans-unit>
        <trans-unit id="4ba4b7f2791ac2aa4c80109d535fbfb13d73d36f" translate="yes" xml:space="preserve">
          <source>Annotations from the annotation collection will always be inserted.</source>
          <target state="translated">주석 컬렉션의 주석은 항상 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="3f4336d76b091e123652532142e19af4499712fd" translate="yes" xml:space="preserve">
          <source>Annotations from the annotation collection will always be inserted. After all transforms have been run, it will be an error if multiple annotations (excluding those with SOURCE retention) exist.</source>
          <target state="translated">주석 컬렉션의 주석은 항상 삽입됩니다. 모든 변환이 실행 된 후 여러 주석 (SOURCE 보존이있는 주석 제외)이 있으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5de36616705f2e389180b9498b6b1ab0c7a8fbc9" translate="yes" xml:space="preserve">
          <source>Annotations from the collector will be added and any existing annotations with the same name will be removed but any new parameters found within existing annotations will be merged into the added annotation.</source>
          <target state="translated">컬렉터의 주석이 추가되고 이름이 같은 기존 주석이 제거되지만 기존 주석에서 발견 된 새 매개 변수는 추가 된 주석에 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="082f52885597923998442bf595f2313f72d502e0" translate="yes" xml:space="preserve">
          <source>Annotations from the collector will be added and any existing annotations with the same name will be removed.</source>
          <target state="translated">컬렉터의 주석이 추가되고 동일한 이름을 가진 기존 주석이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2da74bf2e8e6d09f35515442bf09f5b8f02527a9" translate="yes" xml:space="preserve">
          <source>Annotations from the collector will be ignored if any existing annotations with the same name are found but any new parameters on the collector annotation will be added to existing annotations.</source>
          <target state="translated">동일한 이름의 기존 주석이 발견되었지만 수집기 주석의 새 매개 변수가 기존 주석에 추가되는 경우 수집기의 주석은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5a9a0199226016d5b1b18d7d912b26efeef64d52" translate="yes" xml:space="preserve">
          <source>Annotations from the collector will be ignored if any existing annotations with the same name are found.</source>
          <target state="translated">동일한 이름의 기존 주석이 발견되면 수집기의 주석이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1b528c18044c72ae7fe8abebdfa61d1a41bf02f6" translate="yes" xml:space="preserve">
          <source>Annotations with &lt;a href=&quot;../../runtime/generatedclosure&quot;&gt;GeneratedClosure&lt;/a&gt; members are not supported at present.</source>
          <target state="translated">&lt;a href=&quot;../../runtime/generatedclosure&quot;&gt;GeneratedClosure&lt;/a&gt; 멤버가있는 주석은 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74ab3d024375e18ccfacabaf502d9b35ec855e6f" translate="yes" xml:space="preserve">
          <source>Annotations with &lt;a href=&quot;../runtime/generatedclosure&quot;&gt;GeneratedClosure&lt;/a&gt; members are not supported for now.</source>
          <target state="translated">&lt;a href=&quot;../runtime/generatedclosure&quot;&gt;GeneratedClosure&lt;/a&gt; 멤버가있는 주석은 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a974c8eff5cff7b5c43b5fa88878cb32de387a3" translate="yes" xml:space="preserve">
          <source>Another example (partial emulation of arg processing for 'ant' command line):</source>
          <target state="translated">다른 예 ( 'ant'명령 줄에 대한 arg 처리의 부분 에뮬레이션) :</target>
        </trans-unit>
        <trans-unit id="9a40fa4b45ca995e58556903f036267951fa9d14" translate="yes" xml:space="preserve">
          <source>Another example involving XStream:</source>
          <target state="translated">XStream과 관련된 또 다른 예 :</target>
        </trans-unit>
        <trans-unit id="2d069dc51ac9f6061526017dda463400ab1cdb15" translate="yes" xml:space="preserve">
          <source>Another example showing long options (partial emulation of arg processing for 'curl' command line):</source>
          <target state="translated">긴 옵션을 보여주는 또 다른 예 ( 'curl'명령 줄에 대한 arg 처리의 부분 에뮬레이션) :</target>
        </trans-unit>
        <trans-unit id="dedf5ccdeb6bf446ef7cfb01d8db4c4b042b2078" translate="yes" xml:space="preserve">
          <source>Another example:</source>
          <target state="translated">다른 예시:</target>
        </trans-unit>
        <trans-unit id="cd48c6280554d20fdd43c23eea44d262ee2b8cd2" translate="yes" xml:space="preserve">
          <source>Another popular cloning strategy is known as the copy constructor pattern. If any of your fields are &lt;code&gt;final&lt;/code&gt; and &lt;code&gt;Cloneable&lt;/code&gt; you should set &lt;code&gt;style=COPY_CONSTRUCTOR&lt;/code&gt; which will then use the copy constructor pattern. Here is an example making use of the copy constructor pattern:</source>
          <target state="translated">또 다른 인기있는 복제 전략은 복사 생성자 패턴으로 알려져 있습니다. 당신의 모든 필드 인 경우 &lt;code&gt;final&lt;/code&gt; 와 &lt;code&gt;Cloneable&lt;/code&gt; 를 당신은 설정해야합니다 &lt;code&gt;style=COPY_CONSTRUCTOR&lt;/code&gt; 다음 복사 생성자 패턴을 사용합니다. 다음은 복사 생성자 패턴을 사용하는 예제입니다.</target>
        </trans-unit>
        <trans-unit id="f86cfc49ec4d81202737f953eea5fa57fb586c8a" translate="yes" xml:space="preserve">
          <source>Ant tasks for working with Groovy - such as groovyc for compiling Groovy source code to Java bytecode</source>
          <target state="translated">Groovy 작업을위한 Ant 작업-Groovy 소스 코드를 Java 바이트 코드로 컴파일하기위한 groovyc 등</target>
        </trans-unit>
        <trans-unit id="9f66a95960f2966786a81cb9e800a0e4b10717d0" translate="yes" xml:space="preserve">
          <source>AntlrASTProcessor</source>
          <target state="translated">AntlrASTProcessor</target>
        </trans-unit>
        <trans-unit id="2908aff1680b0629928812356c928991240dc5ab" translate="yes" xml:space="preserve">
          <source>Antony Riley</source>
          <target state="translated">안토니 라일리</target>
        </trans-unit>
        <trans-unit id="fe08285a7402bf91e62292bfd94155f068e60b77" translate="yes" xml:space="preserve">
          <source>Any method annotated with &lt;code&gt;@&lt;/code&gt;WithReadLock will obtain a read lock and release it in a finally block.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; WithReadLock으로 주석이 달린 모든 메서드 는 읽기 잠금을 얻고 finally 블록에서 해제합니다.</target>
        </trans-unit>
        <trans-unit id="ab81fd5f531cd65baea5ab73bb7bcf9f44198bf6" translate="yes" xml:space="preserve">
          <source>Any method annotated with &lt;code&gt;@&lt;/code&gt;WithWriteLock will obtain a write lock and release it in a finally block.</source>
          <target state="translated">&lt;code&gt;@&lt;/code&gt; WithWriteLock으로 주석이 달린 모든 메서드 는 쓰기 잠금을 얻고 finally 블록에서 해제합니다.</target>
        </trans-unit>
        <trans-unit id="8a783ed15740c3826664477498103047d4aacf0f" translate="yes" xml:space="preserve">
          <source>Any method invoked inside the closure will first be invoked on the self reference. For example, the following method calls to the append() method are invoked on the StringBuilder instance and then, because 'returning' is true, the self instance is returned:</source>
          <target state="translated">클로저 내부에서 호출 된 모든 메서드는 먼저 자체 참조에서 호출됩니다. 예를 들어 다음과 같은 append () 메서드 호출이 StringBuilder 인스턴스에서 호출 된 다음 'returning'이 true이므로 자체 인스턴스가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b67714d41e37f1b15e7d89200544d6d41a984451" translate="yes" xml:space="preserve">
          <source>Any method invoked inside the closure will first be invoked on the self reference. For instance, the following method calls to the append() method are invoked on the StringBuilder instance:</source>
          <target state="translated">클로저 내부에서 호출 된 모든 메서드는 먼저 자체 참조에서 호출됩니다. 예를 들어 다음과 같은 append () 메서드 호출이 StringBuilder 인스턴스에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="03243dc9d4207588c8cad00c322142551fdcd237" translate="yes" xml:space="preserve">
          <source>Any regular expression matches are passed to the closure, if there are no capture groups, there will be one parameter for the match:</source>
          <target state="translated">모든 정규식 일치는 클로저로 전달되며 캡처 그룹이없는 경우 일치에 대한 하나의 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5571423cfc2ec42711dee62376228de30693781a" translate="yes" xml:space="preserve">
          <source>Any regular expression matches are returned in a list, and all regex capture groupings are ignored, only the full match is returned:</source>
          <target state="translated">모든 정규식 일치가 목록에 반환되고 모든 정규식 캡처 그룹이 무시되고 전체 일치 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cfcffb25034a47ebc022d21da6755be4e6a3d17e" translate="yes" xml:space="preserve">
          <source>Any two Converter instances registered for the same type are considered to be equal.</source>
          <target state="translated">동일한 유형에 대해 등록 된 두 개의 Converter 인스턴스는 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="ff7f33bd66215965b64304530414110c62ae3d51" translate="yes" xml:space="preserve">
          <source>Any two Converter instances registered for the same type are considered to be equal. This comparison makes managing instances in a Set easier; since there is no chaining of Converters it makes sense to only allow one per type.</source>
          <target state="translated">동일한 유형에 대해 등록 된 두 개의 Converter 인스턴스는 동일한 것으로 간주됩니다. 이 비교를 통해 Set에서 인스턴스를 더 쉽게 관리 할 수 ​​있습니다. 변환기 체인이 없기 때문에 유형 당 하나만 허용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cec7965f9160369e2cc29488469a86d264e6979c" translate="yes" xml:space="preserve">
          <source>Apache Jakarta Turbine</source>
          <target state="translated">Apache Jakarta 터빈</target>
        </trans-unit>
        <trans-unit id="7dc2013ffd126c7fac496ea878c004c70c256a3b" translate="yes" xml:space="preserve">
          <source>Apache Software Foundation</source>
          <target state="translated">Apache 소프트웨어 재단</target>
        </trans-unit>
        <trans-unit id="3117e9499ec693715c12e56d8b7b41fb305eb428" translate="yes" xml:space="preserve">
          <source>Append binary data to the file.</source>
          <target state="translated">바이너리 데이터를 파일에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="36ffc6d4db82515ab25d27983cc26a65790dc5f3" translate="yes" xml:space="preserve">
          <source>Append binary data to the file. It &lt;strong&gt;will not&lt;/strong&gt; be interpreted as text.</source>
          <target state="translated">바이너리 데이터를 파일에 추가합니다. 그것은 &lt;strong&gt;하지 않습니다&lt;/strong&gt; 텍스트로 해석 될 수있다.</target>
        </trans-unit>
        <trans-unit id="6eb7e55a134470a05109863ebffc28b8938f5f70" translate="yes" xml:space="preserve">
          <source>Append binary data to the file. See &lt;a href=&quot;#append(java.io.File,%20java.io.InputStream)&quot;&gt;append(java.io.File, java.io.InputStream)&lt;/a&gt;</source>
          <target state="translated">바이너리 데이터를 파일에 추가합니다. 참조 &lt;a href=&quot;#append(java.io.File,%20java.io.InputStream)&quot;&gt;APPEND (java.io.File에, java.io.InputStream를)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ed15ed08c94aa719618e719c3de9dd649a2480d" translate="yes" xml:space="preserve">
          <source>Append binary data to the file. See &lt;a href=&quot;#append(java.nio.file.Path,%20java.io.InputStream)&quot;&gt;append(Path, java.io.InputStream)&lt;/a&gt;</source>
          <target state="translated">바이너리 데이터를 파일에 추가합니다. 참조 &lt;a href=&quot;#append(java.nio.file.Path,%20java.io.InputStream)&quot;&gt;APPEND (경로, java.io.InputStream를)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52dd5a699da45bb83aee8ce8b8479e12cb6fe696" translate="yes" xml:space="preserve">
          <source>Append bytes to the end of a File.</source>
          <target state="translated">파일 끝에 바이트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="fa93b165bd55a1af44497909723a836ae7883dd9" translate="yes" xml:space="preserve">
          <source>Append bytes to the end of a File. It &lt;strong&gt;will not&lt;/strong&gt; be interpreted as text.</source>
          <target state="translated">파일 끝에 바이트를 추가합니다. 그것은 &lt;strong&gt;하지 않습니다&lt;/strong&gt; 텍스트로 해석 될 수있다.</target>
        </trans-unit>
        <trans-unit id="655f2059c99e7f7c74c9da5ee8c2cd5ddfd4b698" translate="yes" xml:space="preserve">
          <source>Append bytes to the end of a Path.</source>
          <target state="translated">Path 끝에 바이트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="48ccac7bbec8e5a392d6fb4d151cdc9700462e36" translate="yes" xml:space="preserve">
          <source>Append bytes to the end of a Path. It &lt;strong&gt;will not&lt;/strong&gt; be interpreted as text.</source>
          <target state="translated">Path 끝에 바이트를 추가합니다. 그것은 &lt;strong&gt;하지 않습니다&lt;/strong&gt; 텍스트로 해석 될 수있다.</target>
        </trans-unit>
        <trans-unit id="8e3a81ed18bb533a3dba37d05ab2cf10f8b96a59" translate="yes" xml:space="preserve">
          <source>Append the text at the end of the File without writing a BOM, using a specified encoding.</source>
          <target state="translated">지정된 인코딩을 사용하여 BOM을 작성하지 않고 파일 끝에 텍스트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="fed092b941b7392979e4b913890bd6121a7dd7e7" translate="yes" xml:space="preserve">
          <source>Append the text at the end of the File without writing a BOM.</source>
          <target state="translated">BOM을 작성하지 않고 파일 끝에 텍스트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0a8ec98fca7ce0946f0d6db8898583f8a65a25a7" translate="yes" xml:space="preserve">
          <source>Append the text at the end of the File, using a specified encoding.</source>
          <target state="translated">지정된 인코딩을 사용하여 파일 끝에 텍스트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d7629b6391efc921d708783c6b1d1abbdfb3aa00" translate="yes" xml:space="preserve">
          <source>Append the text at the end of the File, using a specified encoding. If the given charset is &quot;UTF-16BE&quot; or &quot;UTF-16LE&quot; (or an equivalent alias), &lt;code&gt;writeBom&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and the file doesn't already exist, the requisite byte order mark is written to the file before the text is appended.</source>
          <target state="translated">지정된 인코딩을 사용하여 파일 끝에 텍스트를 추가합니다. 주어진 문자 세트가 &quot;UTF-16BE&quot;또는 &quot;UTF-16LE&quot;(또는 이에 상응하는 별칭)이고 &lt;code&gt;writeBom&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 이고 파일이 이미 존재하지 않는 경우 텍스트가 시작되기 전에 필수 바이트 순서 표시가 파일에 기록됩니다. 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="146dedbd95debeeee6bf4ed558648d465acf36d0" translate="yes" xml:space="preserve">
          <source>Append the text at the end of the File.</source>
          <target state="translated">파일 끝에 텍스트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="05451ee0ebec6a5cd7d3e3f17222d2398bfa04f4" translate="yes" xml:space="preserve">
          <source>Append the text at the end of the File. If the default charset is &quot;UTF-16BE&quot; or &quot;UTF-16LE&quot; (or an equivalent alias) and &lt;code&gt;writeBom&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the requisite byte order mark is written to the file before the text.</source>
          <target state="translated">파일 끝에 텍스트를 추가합니다. 기본 문자 세트가 &quot;UTF-16BE&quot;또는 &quot;UTF-16LE&quot;(또는 이에 상응하는 별칭)이고 &lt;code&gt;writeBom&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 이면 필요한 바이트 순서 표시가 텍스트 앞에 파일에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="9737fbdf8e26a129ced8e30ea1d2f02756a3abfe" translate="yes" xml:space="preserve">
          <source>Append the text at the end of the Path without writing a BOM, using a specified encoding.</source>
          <target state="translated">지정된 인코딩을 사용하여 BOM을 작성하지 않고 경로 끝에 텍스트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6985342498ff9cc013798e67251e8ed139de4eb1" translate="yes" xml:space="preserve">
          <source>Append the text at the end of the Path without writing a BOM.</source>
          <target state="translated">BOM을 작성하지 않고 경로 끝에 텍스트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="297c739710d07ced61439301b807037de5041200" translate="yes" xml:space="preserve">
          <source>Append the text at the end of the Path, using a specified encoding.</source>
          <target state="translated">지정된 인코딩을 사용하여 경로 끝에 텍스트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="21375aa3a02a1357dd34e852adf9ee09e1f0dc4e" translate="yes" xml:space="preserve">
          <source>Append the text at the end of the Path, using a specified encoding. If the given charset is &quot;UTF-16BE&quot; or &quot;UTF-16LE&quot; (or an equivalent alias), &lt;code&gt;writeBom&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and the file doesn't already exist, the requisite byte order mark is written to the file before the text is appended.</source>
          <target state="translated">지정된 인코딩을 사용하여 경로 끝에 텍스트를 추가합니다. 주어진 문자 세트가 &quot;UTF-16BE&quot;또는 &quot;UTF-16LE&quot;(또는 이에 상응하는 별칭)이고 &lt;code&gt;writeBom&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 이고 파일이 이미 존재하지 않는 경우 텍스트가 시작되기 전에 필수 바이트 순서 표시가 파일에 기록됩니다. 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="c32d029cfdd148c244fddd48fea77ee594fe746e" translate="yes" xml:space="preserve">
          <source>Append the text at the end of the Path.</source>
          <target state="translated">경로 끝에 텍스트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="bdfb9d38a9c069d9a4cfbf4edd7b036b51d04756" translate="yes" xml:space="preserve">
          <source>Append the text at the end of the Path. If the default charset is &quot;UTF-16BE&quot; or &quot;UTF-16LE&quot; (or an equivalent alias) and &lt;code&gt;writeBom&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the requisite byte order mark is written to the file before the text.</source>
          <target state="translated">경로 끝에 텍스트를 추가합니다. 기본 문자 세트가 &quot;UTF-16BE&quot;또는 &quot;UTF-16LE&quot;(또는 이에 상응하는 별칭)이고 &lt;code&gt;writeBom&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 이면 필요한 바이트 순서 표시가 텍스트 앞에 파일에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="2f0368d2b969ad8882e89e7093d8065880c69a27" translate="yes" xml:space="preserve">
          <source>Append the text supplied by the Reader at the end of the File without writing a BOM, using a specified encoding.</source>
          <target state="translated">지정된 인코딩을 사용하여 BOM을 작성하지 않고 파일 끝에 판독기가 제공 한 텍스트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="4995ff10e11b0269196aa840375cf071fe4ef588" translate="yes" xml:space="preserve">
          <source>Append the text supplied by the Reader at the end of the File, using a specified encoding.</source>
          <target state="translated">지정된 인코딩을 사용하여 파일 끝에 판독기가 제공 한 텍스트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="966577dc99ce2ef27a719544dcc5429fc699bb12" translate="yes" xml:space="preserve">
          <source>Append the text supplied by the Reader at the end of the File, using a specified encoding. If the given charset is &quot;UTF-16BE&quot; or &quot;UTF-16LE&quot; (or an equivalent alias), &lt;code&gt;writeBom&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and the file doesn't already exist, the requisite byte order mark is written to the file before the text is appended.</source>
          <target state="translated">지정된 인코딩을 사용하여 파일 끝에 판독기가 제공 한 텍스트를 추가합니다. 주어진 문자 세트가 &quot;UTF-16BE&quot;또는 &quot;UTF-16LE&quot;(또는 이에 상응하는 별칭)이고 &lt;code&gt;writeBom&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 이고 파일이 이미 존재하지 않는 경우 텍스트가 시작되기 전에 필수 바이트 순서 표시가 파일에 기록됩니다. 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="fb146cbf6859bffe3c255ba0f73dc0f690c90abd" translate="yes" xml:space="preserve">
          <source>Append the text supplied by the Writer at the end of the File without writing a BOM, using a specified encoding.</source>
          <target state="translated">지정된 인코딩을 사용하여 BOM을 작성하지 않고 작성기가 제공 한 텍스트를 파일 끝에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e0292ca1746be34f00bf6d89364de22069d471ad" translate="yes" xml:space="preserve">
          <source>Append the text supplied by the Writer at the end of the File without writing a BOM.</source>
          <target state="translated">BOM을 작성하지 않고 파일 끝에 작성자가 제공 한 텍스트를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7b23adb7f1833987b2ffbf44bf3ae6296df8804f" translate="yes" xml:space="preserve">
          <source>Append the text supplied by the Writer at the end of the File, using a specified encoding.</source>
          <target state="translated">지정된 인코딩을 사용하여 작성기가 제공 한 텍스트를 파일 끝에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="01c55b2b842cb17c8d894820872394bf69c844f8" translate="yes" xml:space="preserve">
          <source>Append the text supplied by the Writer at the end of the File, using a specified encoding. If the given charset is &quot;UTF-16BE&quot; or &quot;UTF-16LE&quot; (or an equivalent alias), &lt;code&gt;writeBom&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and the file doesn't already exist, the requisite byte order mark is written to the file before the text is appended.</source>
          <target state="translated">지정된 인코딩을 사용하여 작성기가 제공 한 텍스트를 파일 끝에 추가합니다. 주어진 문자 세트가 &quot;UTF-16BE&quot;또는 &quot;UTF-16LE&quot;(또는 이에 상응하는 별칭)이고 &lt;code&gt;writeBom&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 이고 파일이 이미 존재하지 않는 경우 텍스트가 시작되기 전에 필수 바이트 순서 표시가 파일에 기록됩니다. 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="a3eced28558d7e6ad510e4e5f792c3988d9ce078" translate="yes" xml:space="preserve">
          <source>Append the text supplied by the Writer at the end of the File.</source>
          <target state="translated">작성자가 제공 한 텍스트를 파일 끝에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7171caeeaae97345c474f199b9d4d4d456fd0e9e" translate="yes" xml:space="preserve">
          <source>Append the text supplied by the Writer at the end of the File. If the default charset is &quot;UTF-16BE&quot; or &quot;UTF-16LE&quot; (or an equivalent alias) and &lt;code&gt;writeBom&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the requisite byte order mark is written to the file before the text.</source>
          <target state="translated">작성자가 제공 한 텍스트를 파일 끝에 추가합니다. 기본 문자 세트가 &quot;UTF-16BE&quot;또는 &quot;UTF-16LE&quot;(또는 이에 상응하는 별칭)이고 &lt;code&gt;writeBom&lt;/code&gt; 이 &lt;code&gt;true&lt;/code&gt; 이면 필요한 바이트 순서 표시가 텍스트 앞에 파일에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="a206d68287f9fc8c21f70a7080aeb15ee4beb64e" translate="yes" xml:space="preserve">
          <source>Appends a String to the string representation of this number.</source>
          <target state="translated">이 숫자의 문자열 표현에 문자열을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="68a52dbab4bdda0f883548bdb4781f60014e93e5" translate="yes" xml:space="preserve">
          <source>Appends a String to this StringBuffer.</source>
          <target state="translated">이 StringBuffer에 String을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="953951d55707df238a92b56f27419a478454b6fa" translate="yes" xml:space="preserve">
          <source>Appends a String to this StringBuilder.</source>
          <target state="translated">이 StringBuilder에 문자열을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d70572efa2ddde8480a0883f8d05973841fc48e5" translate="yes" xml:space="preserve">
          <source>Appends a character sequence to this Writer.</source>
          <target state="translated">이 Writer에 문자 시퀀스를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="43a182e4344e119c6c431c06b73d413b05e35781" translate="yes" xml:space="preserve">
          <source>Appends a child to the current node.</source>
          <target state="translated">현재 노드에 자식을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f6087e382a65ba20dbe7fffcf6a050563d27924c" translate="yes" xml:space="preserve">
          <source>Appends a portion of a character sequence to the &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html&quot;&gt;StringBuilder&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html&quot;&gt;StringBuilder에&lt;/a&gt; 문자 시퀀스의 일부를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="8e1b6dc512c5a1577fb5e0fb5bac25e1d5319974" translate="yes" xml:space="preserve">
          <source>Appends a single character to this Writer.</source>
          <target state="translated">이 Writer에 단일 문자를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9363d3fa15c260fa89b766d9dec292067fed6700" translate="yes" xml:space="preserve">
          <source>Appends an object to an Appendable using Groovy's default representation for the object.</source>
          <target state="translated">객체에 대한 Groovy의 기본 표현을 사용하여 Appendable에 객체를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="3e4b49055e720c793680be4f23d71e599ca36e4a" translate="yes" xml:space="preserve">
          <source>Appends the String representation of the given operand to this CharSequence.</source>
          <target state="translated">지정된 피연산자의 String 표현을이 CharSequence에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9590f0b6dd98c0e34d7e9eb9f1aee0ee0b5df00a" translate="yes" xml:space="preserve">
          <source>Appends the String representation of the given operand to this string.</source>
          <target state="translated">지정된 피연산자의 String 표현을이 문자열에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7b7f43193d2ceb1993fd4d9256a6b72551d21303" translate="yes" xml:space="preserve">
          <source>Applies a function on each combination of the input lists.</source>
          <target state="translated">입력 목록의 각 조합에 함수를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="9426828b74186a29130c137066f1d7ddc92ff0b7" translate="yes" xml:space="preserve">
          <source>Apply a number of methods to allow convenient Date/Time manipulation,such as:</source>
          <target state="translated">다음과 같은 편리한 날짜 / 시간 조작을 허용하는 여러 방법을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="c2326a83c26d515fb26d05f4e78f2cca339a0771" translate="yes" xml:space="preserve">
          <source>Apply a transformer as filter.</source>
          <target state="translated">변압기를 필터로 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="434d7948db20089de086f297ab4f8c8bc14e34d0" translate="yes" xml:space="preserve">
          <source>Apply a transformer as filter. The filter may not match exactly in the types. In this case needed additional type transformations are done by &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandle.html#asType(java.lang.invoke.MethodType)&quot;&gt;MethodHandle.asType&lt;/a&gt;</source>
          <target state="translated">변압기를 필터로 적용하십시오. 필터는 유형에서 정확히 일치하지 않을 수 있습니다. 이 경우 필요한 추가 형식 변환은 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/lang/invoke/MethodHandle.html#asType(java.lang.invoke.MethodType)&quot;&gt;MethodHandle.asType에&lt;/a&gt; 의해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="5445225d06fce4ee4f98447e409d923244cfb18a" translate="yes" xml:space="preserve">
          <source>Are whitespace tokens included?</source>
          <target state="translated">공백 토큰이 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="155e47d740dd65562329d8aefc415c57f481e93d" translate="yes" xml:space="preserve">
          <source>Argument type matching could be more specific in case of static compilation</source>
          <target state="translated">정적 컴파일의 경우 인수 유형 일치가 더 구체적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="194ad3ae168c46e97f030c78e2fe99a8bc0c7448" translate="yes" xml:space="preserve">
          <source>Arguments in the (...) can be labeled, and the appended block can be labeled also. If there is a mix of unlabeled and labeled arguments, all the labeled arguments must follow the unlabeled arguments, except that the closure (labeled or not) is always a separate final argument. Labeled arguments are collected up and passed as a single argument to a formal of type Map.</source>
          <target state="translated">(...)의 인수에 레이블을 지정할 수 있으며 추가 된 블록에도 레이블을 지정할 수 있습니다. 레이블이 지정되지 않은 인수와 레이블이 지정된 인수가 혼합되어있는 경우 모든 레이블이 지정된 인수는 레이블이 지정되거나 지정되지 않은 클로저가 항상 별도의 최종 인수라는 점을 제외하고는 레이블이 지정되지 않은 인수를 따라야합니다. 레이블이있는 인수는 수집되어 Map 형식의 형식에 단일 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="ed00b010c5288389ea668919bf8a469628bf9575" translate="yes" xml:space="preserve">
          <source>ArithmeticException if numeric overflow occurs</source>
          <target state="translated">숫자 오버플로가 발생하는 경우 ArithmeticException</target>
        </trans-unit>
        <trans-unit id="f060f507760bdfacf2746176d5da136e24896d36" translate="yes" xml:space="preserve">
          <source>Array of StringArrays that can be indexed with the MEMBER_xxx_IDX constants</source>
          <target state="translated">MEMBER_xxx_IDX 상수로 인덱싱 할 수있는 StringArray 배열</target>
        </trans-unit>
        <trans-unit id="17f3d834c909f91543323d2da6d7e392df7fc04d" translate="yes" xml:space="preserve">
          <source>Array utilities.</source>
          <target state="translated">어레이 유틸리티.</target>
        </trans-unit>
        <trans-unit id="5f933d48639cdd786246bd2cebf2ce954876e4d2" translate="yes" xml:space="preserve">
          <source>Array.getLength</source>
          <target state="translated">Array.getLength</target>
        </trans-unit>
        <trans-unit id="06e91bca6460b35d08e2a1e9e90aedb7d62b4820" translate="yes" xml:space="preserve">
          <source>As a final example, if your class already implements the &lt;code&gt;Serializable&lt;/code&gt; or &lt;code&gt;Externalizable&lt;/code&gt; interface, you can choose the following cloning style:</source>
          <target state="translated">마지막 예로, 클래스가 이미 &lt;code&gt;Serializable&lt;/code&gt; 또는 &lt;code&gt;Externalizable&lt;/code&gt; 인터페이스를 구현 한 경우 다음 복제 스타일을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be3818908b9a99e4821d431f7d86fae59ff20121" translate="yes" xml:space="preserve">
          <source>As a final example, we sometimes need to pass such mixed in classes or objects into Java methods which require a given static type but the ExpandoMetaClass mixin approach uses a very dynamic approach based on duck typing rather than static interface definitions, so doesn't by default produce objects matching the required static type. Luckily, there is a mixins capability within ExpandoMetaClass which supports the use of Groovy's common 'as StaticType' notation to produce an object having the correct static type so that it can be passed to the Java method call in question. A slightly contrived example illustrating this feature:</source>
          <target state="translated">마지막 예로서, 때때로 우리는 주어진 정적 유형을 필요로하는 Java 메소드에 이러한 혼합 된 클래스 또는 객체를 전달해야하지만 ExpandoMetaClass mixin 접근법은 정적 인터페이스 정의가 아닌 덕 타이핑을 기반으로하는 매우 동적 인 접근법을 사용합니다. 기본적으로 필요한 정적 유형과 일치하는 객체를 생성합니다. 다행히도 ExpandoMetaClass에는 올바른 정적 유형을 가진 객체를 생성하기 위해 Groovy의 일반적인 'as StaticType'표기법 사용을 지원하는 mixins 기능이있어 문제의 Java 메서드 호출에 전달할 수 있습니다. 이 기능을 설명하는 약간 인위적인 예 :</target>
        </trans-unit>
        <trans-unit id="3879e95a2519889c33cbeb8c2620bed416d52612" translate="yes" xml:space="preserve">
          <source>As a result, the previous signature can be written like this:</source>
          <target state="translated">결과적으로 이전 서명은 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdb30e19c53961a6c300903fe784879b09eb3f4b" translate="yes" xml:space="preserve">
          <source>As a variation of the last two styles, if you set &lt;code&gt;style=SIMPLE&lt;/code&gt; then the no-arg constructor will be called followed by setting the individual properties (and/or fields) calling &lt;code&gt;clone()&lt;/code&gt; if the property/field implements &lt;code&gt;Cloneable&lt;/code&gt;. Here is an example:</source>
          <target state="translated">마지막 두 스타일의 변형으로 &lt;code&gt;style=SIMPLE&lt;/code&gt; 을 설정하면 인수가 없는 생성자가 호출 되고 속성 / 필드가 &lt;code&gt;Cloneable&lt;/code&gt; 을 구현하는 경우 &lt;code&gt;clone()&lt;/code&gt; 호출하는 개별 속성 (및 / 또는 필드)을 설정합니다 . 다음은 그 예입니다.</target>
        </trans-unit>
        <trans-unit id="b1efad073decde291a99ffbb9b86883d27785234" translate="yes" xml:space="preserve">
          <source>As an example, consider this code:</source>
          <target state="translated">예를 들어 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="944df76a58bd4ab514570139bdaa563c5e80eed5" translate="yes" xml:space="preserve">
          <source>As another example, consider the following class definitions:</source>
          <target state="translated">또 다른 예로, 다음 클래스 정의를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="26b4220eac2bb0f252a48212360c29f7ea305f57" translate="yes" xml:space="preserve">
          <source>As another example, see &lt;a href=&quot;#call(java.lang.String,%20java.util.List,%20groovy.lang.Closure)&quot;&gt;call(String, List, Closure)&lt;/a&gt; for more details about creating a &lt;code&gt;FullName(IN first)&lt;/code&gt; stored function. Once created, it can be called like this:</source>
          <target state="translated">또 다른 예로 &lt;code&gt;FullName(IN first)&lt;/code&gt; 저장 함수 생성에 대한 자세한 내용 은 &lt;a href=&quot;#call(java.lang.String,%20java.util.List,%20groovy.lang.Closure)&quot;&gt;call (String, List, Closure)&lt;/a&gt; 를 참조하십시오 . 생성되면 다음과 같이 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9831a597b8c211d7db55125d3887a2114d2137e" translate="yes" xml:space="preserve">
          <source>As another example, the &lt;code&gt;usageMessage&lt;/code&gt; property gives fine-grained control over the usage help message (see the &lt;a href=&quot;http://picocli.info/#_usage_help_with_styles_and_colors&quot;&gt;picocli user manual&lt;/a&gt; for details):</source>
          <target state="translated">또 다른 예로 &lt;code&gt;usageMessage&lt;/code&gt; 속성은 사용 도움말 메시지에 대한 세밀한 제어를 제공합니다 (자세한 내용은 &lt;a href=&quot;http://picocli.info/#_usage_help_with_styles_and_colors&quot;&gt;picocli 사용자 매뉴얼&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="4c62da74d16372e8a480c2f1cb0373f6a5e33f77" translate="yes" xml:space="preserve">
          <source>As another example, this:</source>
          <target state="translated">또 다른 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4f674346eb25550b8d1ca11237dfe8d88a3936d4" translate="yes" xml:space="preserve">
          <source>As another example, we can also define a no dup queue by mixing in some Queue and Set functionality as follows:</source>
          <target state="translated">또 다른 예로, 다음과 같이 일부 Queue 및 Set 기능을 혼합하여 no dup 대기열을 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef97035b57036ee22c850b3c2917d10d3ab7e512" translate="yes" xml:space="preserve">
          <source>As outlined above, &lt;code&gt;Collection&lt;/code&gt;s and &lt;code&gt;Map&lt;/code&gt;s are wrapped by immutable wrapper classes (but not deeply cloned!).</source>
          <target state="translated">위에서 설명한대로 &lt;code&gt;Collection&lt;/code&gt; 및 &lt;code&gt;Map&lt;/code&gt; 은 변경 불가능한 래퍼 클래스로 래핑됩니다 (하지만 깊이 복제되지는 않습니다!).</target>
        </trans-unit>
        <trans-unit id="32bbc8a21a875d446389c3b9e88f5ab7890ad6b4" translate="yes" xml:space="preserve">
          <source>As outlined above, Arrays and &lt;code&gt;Cloneable&lt;/code&gt; objects use the &lt;code&gt;clone&lt;/code&gt; method. For your own classes, it is up to you to define this method and use deep cloning if appropriate.</source>
          <target state="translated">위에서 설명한 바와 같이, 배열 및 &lt;code&gt;Cloneable&lt;/code&gt; 을 개체 사용 &lt;code&gt;clone&lt;/code&gt; 방법. 자신의 클래스에 대해이 방법을 정의하고 적절한 경우 딥 클로닝을 사용하는 것은 사용자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="a45e117f5c18eb3b5415b62b221097ceb258f6e3" translate="yes" xml:space="preserve">
          <source>As part of the Groovy compiler, code resembling this is produced:</source>
          <target state="translated">Groovy 컴파일러의 일부로 다음과 유사한 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ab2dea72cff45f736a46dce1639ad7051dd1e1d7" translate="yes" xml:space="preserve">
          <source>As per the Servlet specification, a call to &lt;code&gt;response.getWriter()&lt;/code&gt; should not be done if a call to &lt;code&gt;response.getOutputStream()&lt;/code&gt; has already occurred or the other way around. You may wonder then how the above lazy variables can possibly be provided - since setting them up would involve calling both of the above methods. The trick is catered for behind the scenes using lazy variables. Lazy bound variables can be requested without side effects; under the covers the writer and stream are wrapped. That means &lt;code&gt;response.getWriter()&lt;/code&gt; is never directly called until some output is done using 'out' or 'html'. Once a write method call is done using either of these variable, then an attempt to write using 'sout' will cause an &lt;code&gt;IllegalStateException&lt;/code&gt;. Similarly, if a write method call on 'sout' has been done already, then any further write method call on 'out' or 'html' will cause an &lt;code&gt;IllegalStateException&lt;/code&gt;.</source>
          <target state="translated">Servlet 사양에 &lt;code&gt;response.getWriter()&lt;/code&gt; 대한 호출 이 이미 발생했거나 그 반대의 경우 &lt;code&gt;response.getOutputStream()&lt;/code&gt; 에 대한 호출을 수행해서는 안됩니다 . 위의 지연 변수를 어떻게 제공 할 수 있는지 궁금 할 것입니다. 설정하려면 위의 두 메서드를 모두 호출해야하기 때문입니다. 이 트릭은 지연 변수를 사용하여 배후에서 제공됩니다. 지연 바운드 변수는 부작용없이 요청할 수 있습니다. 커버 아래에는 작가와 스트림이 포장되어 있습니다. 즉, 'out'또는 'html'을 사용하여 일부 출력이 완료 될 때까지 &lt;code&gt;response.getWriter()&lt;/code&gt; 가 직접 호출되지 않습니다. 이러한 변수 중 하나를 사용하여 쓰기 메서드 호출이 완료되면 'sout'을 사용하여 쓰기를 시도하면 &lt;code&gt;IllegalStateException&lt;/code&gt; 이 발생 합니다.. 마찬가지로 'sout'에 대한 쓰기 메서드 호출이 이미 수행 된 경우 'out'또는 'html'에 대한 추가 쓰기 메서드 호출은 &lt;code&gt;IllegalStateException&lt;/code&gt; 을 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="2a67fc2a8f8f48c8963e6bc9c7ae44b94dceb6d8" translate="yes" xml:space="preserve">
          <source>As subclass of MetaClass, ProxyMetaClass manages calls from Groovy Objects to POJOs. It enriches MetaClass with the feature of making method invocations interceptable by an Interceptor. To this end, it acts as a decorator (decorator pattern) allowing to add or withdraw this feature at runtime. See groovy/lang/InterceptorTest.groovy for details.</source>
          <target state="translated">MetaClass의 하위 클래스 인 ProxyMetaClass는 Groovy Objects에서 POJO 로의 호출을 관리합니다. Interceptor가 메소드 호출을 가로 챌 수 있도록하는 기능으로 MetaClass를 강화합니다. 이를 위해 런타임에이 기능을 추가하거나 철회 할 수있는 데코레이터 (데커 레이터 패턴) 역할을합니다. 자세한 내용은 groovy / lang / InterceptorTest.groovy를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5b2d2f926a6789b94e551ad89bc5e260c5e99772" translate="yes" xml:space="preserve">
          <source>As with the try-with-resources statement, if multiple exceptions are thrown the exception from the closure will be returned and the exception from closing will be added as a suppressed exception.</source>
          <target state="translated">try-with-resources 문과 마찬가지로 여러 예외가 throw되면 클로저의 예외가 반환되고 클로저의 예외가 억제 된 예외로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4e200f4208238bd977e7a3addaac97e6ab11786d" translate="yes" xml:space="preserve">
          <source>Ask the nodes to be registered</source>
          <target state="translated">등록 할 노드 요청</target>
        </trans-unit>
        <trans-unit id="921eee5aa1fc39775ba4eea8a5233bc5232cb81e" translate="yes" xml:space="preserve">
          <source>AsmClassGenerator</source>
          <target state="translated">AsmClassGenerator</target>
        </trans-unit>
        <trans-unit id="01069e3629b24fc3d02bd0f97757dd77eb92662e" translate="yes" xml:space="preserve">
          <source>AsmDecompiler</source>
          <target state="translated">AsmDecompiler</target>
        </trans-unit>
        <trans-unit id="dd7f78aca7f63e87d033921c90bd6e27a6ae50d6" translate="yes" xml:space="preserve">
          <source>AssertionError.class</source>
          <target state="translated">AssertionError.class</target>
        </trans-unit>
        <trans-unit id="5729966da77859e1dfab9575ee7274db64bcf947" translate="yes" xml:space="preserve">
          <source>Asserts that the array of characters contains a given char</source>
          <target state="translated">문자 배열에 주어진 문자가 포함되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="88e7b5ad638bf379637fd371207c37f05252e3f1" translate="yes" xml:space="preserve">
          <source>Asserts that the array of characters has a given length</source>
          <target state="translated">문자 배열의 길이가 지정되었음을 확인</target>
        </trans-unit>
        <trans-unit id="5eca372a9b35cfb618243246b1b319d1775c1342" translate="yes" xml:space="preserve">
          <source>Asserts that the array of ints contains a given int</source>
          <target state="translated">int 배열에 주어진 int가 포함되어 있음을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="14d7de0b2e2e56c1adf008d88d2e449d927c0289" translate="yes" xml:space="preserve">
          <source>Asserts that the array of ints has a given length</source>
          <target state="translated">int 배열이 주어진 길이를 가지고 있음을 확인</target>
        </trans-unit>
        <trans-unit id="7751a3b9485b15e61cf772e3ee8e4b9907186b9b" translate="yes" xml:space="preserve">
          <source>Asserts that the array of objects has a given length</source>
          <target state="translated">객체 배열의 길이가 지정되어 있음을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="4ff254bdfdbf26604e1f9739383783cd263ade94" translate="yes" xml:space="preserve">
          <source>Asserts that the arrays are equivalent and contain the same values</source>
          <target state="translated">배열이 동일하고 동일한 값을 포함하는지 확인</target>
        </trans-unit>
        <trans-unit id="5a180a510cdf3f0cb7af1a9dd8981130eb70ac1e" translate="yes" xml:space="preserve">
          <source>Asserts that the given code closure fails when it is evaluated</source>
          <target state="translated">주어진 코드 클로저가 평가 될 때 실패한다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="1197f1622e698e5ce6794f602a979b803e173a8f" translate="yes" xml:space="preserve">
          <source>Asserts that the given code closure fails when it is evaluated and that a particular Exception type can be attributed to the cause.</source>
          <target state="translated">지정된 코드 클로저가 평가 될 때 실패하고 특정 예외 유형이 원인에 기인 할 수 있음을 어설 션합니다.</target>
        </trans-unit>
        <trans-unit id="d7257b7b04b8a63c45d75ad7f7b4e76523a101be" translate="yes" xml:space="preserve">
          <source>Asserts that the given code closure fails when it is evaluated and that a particular Exception type can be attributed to the cause. The expected exception class is compared recursively with any nested exceptions using getCause() until either a match is found or no more nested exceptions exist.</source>
          <target state="translated">지정된 코드 클로저가 평가 될 때 실패하고 특정 예외 유형이 원인에 기인 할 수 있음을 어설 션합니다. 예상 예외 클래스는 일치 항목이 발견되거나 더 이상 중첩 된 예외가 없을 때까지 getCause ()를 사용하여 중첩 된 예외와 재귀 적으로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="c3c15f1b2ad86778cae0f6e83f0c8ed5ec5fe9cd" translate="yes" xml:space="preserve">
          <source>Asserts that the given code closure fails when it is evaluated and that a particular exception can be attributed to the cause.</source>
          <target state="translated">주어진 코드 클로저가 평가 될 때 실패하고 특정 예외가 원인에 기인 할 수 있음을 어설 션합니다.</target>
        </trans-unit>
        <trans-unit id="75224beef3d9c3fb36a66f7c24e32ff6ceb8aecf" translate="yes" xml:space="preserve">
          <source>Asserts that the given code closure fails when it is evaluated and that a particular exception can be attributed to the cause. The expected exception class is compared recursively with any nested exceptions using getCause() until either a match is found or no more nested exceptions exist.</source>
          <target state="translated">주어진 코드 클로저가 평가 될 때 실패하고 특정 예외가 원인에 기인 할 수 있음을 어설 션합니다. 예상 예외 클래스는 일치 항목이 발견되거나 더 이상 중첩 된 예외가 없을 때까지 getCause ()를 사용하여 중첩 된 예외와 재귀 적으로 비교됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
