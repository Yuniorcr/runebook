<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="4bab6b7179d748b7bd5e0233cc4bee7fd29fef76" translate="yes" xml:space="preserve">
          <source>Enable output processing.</source>
          <target state="translated">출력 처리를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="412d02d844a8c91867b64526a04ce736b5034569" translate="yes" xml:space="preserve">
          <source>Enable parity check on input.</source>
          <target state="translated">입력시 패리티 검사를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="ac72b92dafda7ef51841541aaa002e202a5f9ecb" translate="yes" xml:space="preserve">
          <source>Enable parity generation and detection.</source>
          <target state="translated">패리티 생성 및 감지를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="770fcb2eeb894c2e9d37a541226e5eca47597530" translate="yes" xml:space="preserve">
          <source>Enable the set of warnings corresponding to letter. The letter may be uppercase or lowercase.</source>
          <target state="translated">문자에 해당하는 경고 세트를 활성화합니다. 문자는 대문자 또는 소문자 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58f210fa0832e7afc94eb19ba465c6cfb9687d2d" translate="yes" xml:space="preserve">
          <source>Enable the set of warnings corresponding to uppercase-letter.</source>
          <target state="translated">대문자에 해당하는 경고 세트를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="47140cbacce9eae9e7a7806fc75b0c141d4a9ebc" translate="yes" xml:space="preserve">
          <source>Enable warning number num.</source>
          <target state="translated">경고 번호 번호를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="265fc90bc531f6f35f959332fc17890c9912c555" translate="yes" xml:space="preserve">
          <source>Enable warnings in the given range.</source>
          <target state="translated">주어진 범위에서 경고를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="a218e074ec01ec172f8afd6aad1e646363974278" translate="yes" xml:space="preserve">
          <source>Enable, disable, or mark as fatal the warnings specified by the argument warning-list. Each warning can be &lt;em&gt;enabled&lt;/em&gt; or &lt;em&gt;disabled&lt;/em&gt;, and each warning can be &lt;em&gt;fatal&lt;/em&gt; or &lt;em&gt;non-fatal&lt;/em&gt;. If a warning is disabled, it isn&amp;rsquo;t displayed and doesn&amp;rsquo;t affect compilation in any way (even if it is fatal). If a warning is enabled, it is displayed normally by the compiler whenever the source code triggers it. If it is enabled and fatal, the compiler will also stop with an error after displaying it.</source>
          <target state="translated">warning-list 인수에 지정된 경고를 활성화, 비활성화 또는 치명적인 것으로 표시합니다. 각 경고 할 수 있습니다 &lt;em&gt;활성화&lt;/em&gt; 또는 &lt;em&gt;비활성화&lt;/em&gt; 하고, 각 경고가 될 수 &lt;em&gt;치명적&lt;/em&gt; 또는 &lt;em&gt;비 치명적&lt;/em&gt; . 경고가 비활성화 된 경우 표시되지 않으며 어떤 식 으로든 컴파일에 영향을주지 않습니다 (심각한 경우에도). 경고가 활성화되면 소스 코드가 경고를 트리거 할 때마다 컴파일러에 의해 정상적으로 표시됩니다. 활성화되고 치명적이면 컴파일러도 오류를 표시 한 후 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="14b271b15e5841b95bcc16da04d7676aa55f327e" translate="yes" xml:space="preserve">
          <source>Enables the PowerPC large model allowing the TOC (table of contents) to be arbitrarily large. This is the default since 4.11.</source>
          <target state="translated">PowerPC 대형 모델을 활성화하여 TOC (목차)를 임의로 크게 만들 수 있습니다. 이것은 4.11 이후의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="03401ca3edfdb4128312d6293c8a35421e582859" translate="yes" xml:space="preserve">
          <source>Enables the PowerPC small model allowing the TOC to be up to 64 kbytes per compilation unit. Prior to 4.11 this was the default behaviour.</source>
          <target state="translated">PowerPC 소형 모델을 활성화하여 TOC가 컴파일 단위당 최대 64KB가 될 수 있습니다. 4.11 이전에는 이것이 기본 동작이었습니다.</target>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="de8640801b22a0d8a7941409721bb3a98cd33e94" translate="yes" xml:space="preserve">
          <source>End of pretty-printing: resets the pretty-printer to initial state.</source>
          <target state="translated">예쁜 인쇄 종료 : pretty-printer를 초기 상태로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="c50b618f1beb796972a9fd07d7599cf8ab8e9054" translate="yes" xml:space="preserve">
          <source>End-of-file character (usually ctrl-D).</source>
          <target state="translated">파일 끝 문자 (일반적으로 ctrl-D).</target>
        </trans-unit>
        <trans-unit id="3b725184f8cc36a4f8ee2394c69c2dd8fd868d7e" translate="yes" xml:space="preserve">
          <source>Enforce the separation between types string and bytes, thereby making strings read-only. This is the default.</source>
          <target state="translated">문자열 유형과 바이트 유형을 구분하여 문자열을 읽기 전용으로 만듭니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="0036f2b2e208fafb5dfcdf20fc4bf2ebd0e85c42" translate="yes" xml:space="preserve">
          <source>Ensure 32-bit compatibility</source>
          <target state="translated">32 비트 호환성 보장</target>
        </trans-unit>
        <trans-unit id="541ccf2eac21a70a4145827ccb7cd6a05e98125f" translate="yes" xml:space="preserve">
          <source>Enumerated types are a special case of variant types, where all alternatives are constants:</source>
          <target state="translated">열거 유형은 모든 대안이 상수 인 변형 유형의 특수한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="5b52f0dc6b40b4c37e2f81f6f54bc6aa05c7bffc" translate="yes" xml:space="preserve">
          <source>Environment queries</source>
          <target state="translated">환경 쿼리</target>
        </trans-unit>
        <trans-unit id="31712ff509a3de90defb9dc714b99a9f1ce278f8" translate="yes" xml:space="preserve">
          <source>Ephemeron</source>
          <target state="translated">Ephemeron</target>
        </trans-unit>
        <trans-unit id="d8381b886ce8e021a29bdc573e5df829fee81936" translate="yes" xml:space="preserve">
          <source>Ephemeron with arbitrary arity and untyped</source>
          <target state="translated">임의의 arity 및 형식없는 Ephemeron</target>
        </trans-unit>
        <trans-unit id="9483411c3a45e44db6a73f050d8e84f9ac980a3c" translate="yes" xml:space="preserve">
          <source>Ephemerons and weak hash tables</source>
          <target state="translated">Ephemerons 및 약한 해시 테이블</target>
        </trans-unit>
        <trans-unit id="68dcdfc77c7716500d652b8b54eddd5f8823b37a" translate="yes" xml:space="preserve">
          <source>Ephemerons and weak hash tables are useful when one wants to cache or memorize the computation of a function, as long as the arguments and the function are used, without creating memory leaks by continuously keeping old computation results that are not useful anymore because one argument or the function is freed. An implementation using &lt;a href=&quot;hashtbl#TYPEt&quot;&gt;&lt;code&gt;Hashtbl.t&lt;/code&gt;&lt;/a&gt; is not suitable because all associations would keep the arguments and the result in memory.</source>
          <target state="translated">Ephemerons 및 약한 해시 테이블은 인수와 함수를 사용하는 한 함수의 계산을 캐시하거나 암기하고 싶을 때 유용합니다. 기능이 해제됩니다. &lt;a href=&quot;hashtbl#TYPEt&quot;&gt; &lt;code&gt;Hashtbl.t&lt;/code&gt; 를&lt;/a&gt; 사용하는 구현 은 모든 연관이 인수와 결과를 메모리에 유지하므로 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8055532213ae7a60925ad194d9e4810c98071c69" translate="yes" xml:space="preserve">
          <source>Ephemerons are defined in a language agnostic way in this paper: B. Hayes, Ephemerons: A New Finalization Mechanism, OOPSLA'97</source>
          <target state="translated">Ephemerons는이 문서에서 언어에 구애받지 않는 방식으로 정의됩니다. B. Hayes, Ephemerons : A New Finalization Mechanism, OOPSLA'97</target>
        </trans-unit>
        <trans-unit id="41096c468df31c97917965c8d891ad108e26d1fc" translate="yes" xml:space="preserve">
          <source>Ephemerons can also be used for &quot;adding&quot; a field to an arbitrary boxed OCaml value: you can attach some information to a value created by an external library without memory leaks.</source>
          <target state="translated">Ephemerons는 임의의 박스형 OCaml 값에 필드를 &quot;추가&quot;하는 데 사용할 수도 있습니다. 메모리 누수없이 외부 라이브러리에서 생성 한 값에 일부 정보를 첨부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="509e85975836d7ac50cc9b68b081f475f1b2961c" translate="yes" xml:space="preserve">
          <source>Ephemerons hold some keys and one or no data. They are all boxed OCaml values. The keys of an ephemeron have the same behavior as weak pointers according to the garbage collector. In fact OCaml weak pointers are implemented as ephemerons without data.</source>
          <target state="translated">Ephemeron은 일부 키와 하나의 데이터를 보유하고 있습니다. 모두 박스형 OCaml 값입니다. ephemeron의 키는 가비지 수집기에 따라 약한 포인터와 동일한 동작을합니다. 실제로 OCaml 약한 포인터는 데이터가없는 ephemeron으로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="f749997472bd5134a97950c6d780f4f1c597e624" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;format#VALprint_flush&quot;&gt;&lt;code&gt;Format.print_flush&lt;/code&gt;&lt;/a&gt; followed by a new line. See corresponding words of caution for &lt;a href=&quot;format#VALprint_flush&quot;&gt;&lt;code&gt;Format.print_flush&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;format#VALprint_flush&quot;&gt; &lt;code&gt;Format.print_flush&lt;/code&gt; &lt;/a&gt; 다음에 새 줄이 오는 것과 같습니다 . &lt;a href=&quot;format#VALprint_flush&quot;&gt; &lt;code&gt;Format.print_flush&lt;/code&gt; 에&lt;/a&gt; 대한 해당주의 단어를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="132ad0d3139178d3cc06065a05035275b2ff94c6" translate="yes" xml:space="preserve">
          <source>Erase character (usually DEL or ctrl-H).</source>
          <target state="translated">문자를 지 웁니다 (일반적으로 DEL 또는 ctrl-H).</target>
        </trans-unit>
        <trans-unit id="e96e1ad38c0966dc375be617296d87a44b956217" translate="yes" xml:space="preserve">
          <source>Erroneous printed signature.</source>
          <target state="translated">인쇄 된 서명이 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="08f25135109ebab1ec1d489737e84df517dc0927" translate="yes" xml:space="preserve">
          <source>Error in environment variable.</source>
          <target state="translated">환경 변수에 오류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee7ccdbc8221cdeaf56848e96bf3b929db5cb197" translate="yes" xml:space="preserve">
          <source>Error recovery is supported as follows: when the parser reaches an error state (no grammar rules can apply), it calls a function named parse_error with the string &quot;syntax error&quot; as argument. The default parse_error function does nothing and returns, thus initiating error recovery (see below). The user can define a customized parse_error function in the header section of the grammar file.</source>
          <target state="translated">오류 복구는 다음과 같이 지원됩니다. 구문 분석기가 오류 상태에 도달하면 (문법 규칙을 적용 할 수 없음) &quot;syntax error&quot;문자열을 인수로 사용하여 parse_error라는 함수를 호출합니다. 기본 parse_error 함수는 아무 작업도 수행하지 않고 반환하므로 오류 복구가 시작됩니다 (아래 참조). 사용자는 문법 파일의 헤더 섹션에서 사용자 정의 parse_error 함수를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e31c347b987a17f7cb3d98f8aa8b10ea251a784" translate="yes" xml:space="preserve">
          <source>Error report</source>
          <target state="translated">오류보고</target>
        </trans-unit>
        <trans-unit id="c933b897af92835c337f8c15d042afda6a862cd4" translate="yes" xml:space="preserve">
          <source>Error reporting</source>
          <target state="translated">오류보고</target>
        </trans-unit>
        <trans-unit id="29ed179aaaaf044198d2d4b099b8f9cdd60f5ea6" translate="yes" xml:space="preserve">
          <source>Errors in dynamic linking are reported by raising the &lt;code&gt;Error&lt;/code&gt; exception with a description of the error.</source>
          <target state="translated">동적 연결의 &lt;code&gt;Error&lt;/code&gt; 는 오류 에 대한 설명과 함께 오류 예외를 발생시켜보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="0efc5d69dd69fd2174db30c880c7b6bb09d8c0c9" translate="yes" xml:space="preserve">
          <source>Errors in dynamic linking are reported by raising the &lt;code&gt;Error&lt;/code&gt; exception with a description of the error. A common case is the dynamic library not being found on the system: this is reported via &lt;code&gt;Cannot_open_dynamic_library&lt;/code&gt; (the enclosed exception may be platform-specific).</source>
          <target state="translated">동적 연결의 &lt;code&gt;Error&lt;/code&gt; 는 오류 에 대한 설명과 함께 오류 예외를 발생시켜보고됩니다 . 일반적인 경우는 시스템에서 동적 라이브러리를 찾을 수없는 경우입니다. 이는 &lt;code&gt;Cannot_open_dynamic_library&lt;/code&gt; 를 통해보고됩니다 (포함 된 예외는 플랫폼별로 다를 수 있음).</target>
        </trans-unit>
        <trans-unit id="505e7e8c7959ad784a122d78879a599b96f2bf97" translate="yes" xml:space="preserve">
          <source>Escape accented characters in Info files.</source>
          <target state="translated">Info 파일에서 악센트 부호가있는 문자를 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="fde05190b55a3eed2e7dcfc6d80db47e06a76f0e" translate="yes" xml:space="preserve">
          <source>Especially when writing benchmarking suites that run non-side-effecting algorithms in loops, it may be found that the optimiser entirely elides the code being benchmarked. This behaviour can be prevented by using the Sys.opaque_identity function (which indeed behaves as a normal OCaml function and does not possess any &amp;ldquo;magic&amp;rdquo; semantics). The documentation of the Sys module should be consulted for further details.</source>
          <target state="translated">특히 루프에서 부작용이없는 알고리즘을 실행하는 벤치마킹 스위트를 작성할 때 옵티마이 저가 벤치마킹되는 코드를 완전히 제거한다는 것을 알 수 있습니다. 이 동작은 Sys.opaque_identity 함수를 사용하여 방지 할 수 있습니다 (실제로 일반 OCaml 함수로 동작하고 &quot;마법&quot;의미 체계를 갖지 않음). 자세한 내용은 Sys 모듈의 문서를 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="709722b0c7e8d8e13600ac9f62e2965e7a3f0dc3" translate="yes" xml:space="preserve">
          <source>Establish a server on the given address.</source>
          <target state="translated">주어진 주소에 서버를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0f1ae88cb41c8981c081c8dce853cd4b9948f674" translate="yes" xml:space="preserve">
          <source>Establish a server on the given address. The function given as first argument is called for each connection with two buffered channels connected to the client. A new process is created for each connection. The function &lt;a href=&quot;unix#VALestablish_server&quot;&gt;&lt;code&gt;Unix.establish_server&lt;/code&gt;&lt;/a&gt; never returns normally.</source>
          <target state="translated">주어진 주소에 서버를 설정하십시오. 첫 번째 인수로 주어진 함수는 클라이언트에 연결된 두 개의 버퍼링 된 채널이있는 각 연결에 대해 호출됩니다. 각 연결에 대해 새 프로세스가 생성됩니다. &lt;a href=&quot;unix#VALestablish_server&quot;&gt; &lt;code&gt;Unix.establish_server&lt;/code&gt; &lt;/a&gt; 함수 는 정상적으로 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="560d397e92aaad3554bd23d10de9d5e52de2dee9" translate="yes" xml:space="preserve">
          <source>Establish a server on the given address. The function given as first argument is called for each connection with two buffered channels connected to the client. A new process is created for each connection. The function &lt;a href=&quot;unixlabels#VALestablish_server&quot;&gt;&lt;code&gt;UnixLabels.establish_server&lt;/code&gt;&lt;/a&gt; never returns normally.</source>
          <target state="translated">주어진 주소에 서버를 설정하십시오. 첫 번째 인수로 주어진 함수는 클라이언트에 연결된 두 개의 버퍼링 된 채널이있는 각 연결에 대해 호출됩니다. 각 연결에 대해 새 프로세스가 생성됩니다. &lt;a href=&quot;unixlabels#VALestablish_server&quot;&gt; &lt;code&gt;UnixLabels.establish_server&lt;/code&gt; &lt;/a&gt; 함수 는 정상적으로 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40a6caa3a0a19447950f461ddf1293d94c142f80" translate="yes" xml:space="preserve">
          <source>Even function composition is definable:</source>
          <target state="translated">함수 구성도 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c21414076c7e3bcf34bf847855694be0bc01134" translate="yes" xml:space="preserve">
          <source>Even if a value has a fixed variant type, one can still give it a larger type through coercions. Coercions are normally written with both the source type and the destination type, but in simple cases the source type may be omitted.</source>
          <target state="translated">값에 고정 변형 유형이 있더라도 강제 변환을 통해 더 큰 유형을 제공 할 수 있습니다. 강제 변환은 일반적으로 소스 유형과 대상 유형 모두로 작성되지만 간단한 경우 소스 유형이 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad8919ace091b14011c6439cfd5e1707b58f5abd" translate="yes" xml:space="preserve">
          <source>Event</source>
          <target state="translated">Event</target>
        </trans-unit>
        <trans-unit id="002a13e663c95fdf83e648de45960c94bd85c63d" translate="yes" xml:space="preserve">
          <source>Events are &amp;ldquo;interesting&amp;rdquo; locations in the source code, corresponding to the beginning or end of evaluation of &amp;ldquo;interesting&amp;rdquo; sub-expressions. Events are the unit of single-stepping (stepping goes to the next or previous event encountered in the program execution). Also, breakpoints can only be set at events. Thus, events play the role of line numbers in debuggers for conventional languages.</source>
          <target state="translated">이벤트는 &quot;흥미로운&quot;하위 표현식 평가의 시작 또는 끝에 해당하는 소스 코드의 &quot;흥미로운&quot;위치입니다. 이벤트는 단일 스테핑의 단위입니다 (스테핑은 프로그램 실행에서 발생한 다음 또는 이전 이벤트로 이동 함). 또한 중단 점은 이벤트에서만 설정할 수 있습니다. 따라서 이벤트는 기존 언어의 디버거에서 줄 번호 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="39f8fea95f2f905afaf5702b20b4c2af865028ce" translate="yes" xml:space="preserve">
          <source>Every break hint in a vertical box splits the line.</source>
          <target state="translated">세로 상자의 모든 나누기 힌트는 선을 분할합니다.</target>
        </trans-unit>
        <trans-unit id="c43eedd80f49a7cd19f66f688554ddc3114ee51c" translate="yes" xml:space="preserve">
          <source>Every function in this module raises &lt;code&gt;Sys_error&lt;/code&gt; with an informative message when the underlying system call signal an error.</source>
          <target state="translated">이 모듈의 모든 함수 는 기본 시스템 호출이 오류를 신호 할 때 정보 메시지와 함께 &lt;code&gt;Sys_error&lt;/code&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="53c17e0e359a4c32fb2e90ba769249f80da0ed09" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;printf&amp;nbsp;&quot;@[%s@&amp;nbsp;%d@]@.&quot;&amp;nbsp;&quot;x&amp;nbsp;=&quot;&amp;nbsp;1&lt;/code&gt; is equivalent to &lt;code&gt;open_box&amp;nbsp;();&amp;nbsp;print_string&amp;nbsp;&quot;x&amp;nbsp;=&quot;;&amp;nbsp;print_space&amp;nbsp;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;print_int&amp;nbsp;1;&amp;nbsp;close_box&amp;nbsp;();&amp;nbsp;print_newline&amp;nbsp;()&lt;/code&gt;. It prints &lt;code&gt;x&amp;nbsp;=&amp;nbsp;1&lt;/code&gt; within a pretty-printing 'horizontal-or-vertical' box.</source>
          <target state="translated">예 : &lt;code&gt;printf&amp;nbsp;&quot;@[%s@&amp;nbsp;%d@]@.&quot;&amp;nbsp;&quot;x&amp;nbsp;=&quot;&amp;nbsp;1&lt;/code&gt; 은 &lt;code&gt;open_box&amp;nbsp;();&amp;nbsp;print_string&amp;nbsp;&quot;x&amp;nbsp;=&quot;;&amp;nbsp;print_space&amp;nbsp;();&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;print_int&amp;nbsp;1;&amp;nbsp;close_box&amp;nbsp;();&amp;nbsp;print_newline&amp;nbsp;()&lt;/code&gt; . 이는 인쇄 &lt;code&gt;x&amp;nbsp;=&amp;nbsp;1&lt;/code&gt; 꽤 인자 '수평 또는 수직'박스 내.</target>
        </trans-unit>
        <trans-unit id="7867675b155e93124d37b927a09603512264fe69" translate="yes" xml:space="preserve">
          <source>Example: a lexer suitable for a desk calculator is obtained by</source>
          <target state="translated">예 : 탁상용 계산기에 적합한 어휘 분석기는 다음과 같이 구합니다.</target>
        </trans-unit>
        <trans-unit id="895e8f203a6495776734a740f015692cd2b3b1aa" translate="yes" xml:space="preserve">
          <source>Example: the following C primitive invokes gethostbyname to find the IP address of a host name. The gethostbyname function can block for a long time, so we choose to release the OCaml run-time system while it is running.</source>
          <target state="translated">예 : 다음 C 프리미티브는 gethostbyname을 호출하여 호스트 이름의 IP 주소를 찾습니다. gethostbyname 함수는 오랫동안 차단 될 수 있으므로 실행중인 동안 OCaml 런타임 시스템을 해제하도록 선택합니다.</target>
        </trans-unit>
        <trans-unit id="811da335fb02658aeea8e581a3a2ee5c053b4621" translate="yes" xml:space="preserve">
          <source>Examples (&lt;code&gt;cmd&lt;/code&gt; is assumed to be the command name):</source>
          <target state="translated">예 ( &lt;code&gt;cmd&lt;/code&gt; 는 명령 이름으로 간주 됨) :</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="3f519a0ed2ab9c204d38ec6035c856c982aaeca9" translate="yes" xml:space="preserve">
          <source>Exception definitions add new constructors to the built-in variant type &lt;code&gt;exn&lt;/code&gt; of exception values. The constructors are declared as for a definition of a variant type.</source>
          <target state="translated">예외 정의 는 예외 값 의 기본 제공 변형 유형 &lt;code&gt;exn&lt;/code&gt; 에 새 생성자를 추가 합니다. 생성자는 변형 유형의 정의와 같이 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="b4b0dfe7027c1d349ba13a7e79558e44ec341bd8" translate="yes" xml:space="preserve">
          <source>Exception handling</source>
          <target state="translated">예외 처리</target>
        </trans-unit>
        <trans-unit id="d431d2533016ca9ad29f4d173d1b14c07b74bb13" translate="yes" xml:space="preserve">
          <source>Exception raised by input functions to signal that the end of file has been reached.</source>
          <target state="translated">파일 끝에 도달했음을 알리기 위해 입력 함수에서 발생하는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="82978f55e4581497009424eb5b42bd93b3ca7e49" translate="yes" xml:space="preserve">
          <source>Exception raised by integer division and remainder operations when their second argument is zero.</source>
          <target state="translated">두 번째 인수가 0 일 때 정수 나누기 및 나머지 연산에 의해 발생하는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="20d4510a4445338226928ea929221d7a1a2b7357" translate="yes" xml:space="preserve">
          <source>Exception raised by library functions to signal that the given arguments do not make sense.</source>
          <target state="translated">주어진 인수가 의미가 없음을 알리기 위해 라이브러리 함수에서 발생하는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="7ce3e5fe0fb1d8b41956476928546ec08a9de8a9" translate="yes" xml:space="preserve">
          <source>Exception raised by library functions to signal that the given arguments do not make sense. The string gives some information to the programmer. As a general rule, this exception should not be caught, it denotes a programming error and the code should be modified not to trigger it.</source>
          <target state="translated">주어진 인수가 의미가 없음을 알리기 위해 라이브러리 함수에서 발생하는 예외입니다. 이 문자열은 프로그래머에게 몇 가지 정보를 제공합니다. 일반적으로이 예외는 포착되지 않아야하며 프로그래밍 오류를 나타내며이를 트리거하지 않도록 코드를 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd340ed580df2f3db47ef85feb52884932b1b6a4" translate="yes" xml:space="preserve">
          <source>Exception raised by library functions to signal that they are undefined on the given arguments.</source>
          <target state="translated">주어진 인수에 정의되지 않았 음을 알리기 위해 라이브러리 함수에서 발생하는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="8fa93c3585b8f661e83ab6ba8e4b8cff0539794a" translate="yes" xml:space="preserve">
          <source>Exception raised by library functions to signal that they are undefined on the given arguments. The string is meant to give some information to the programmer; you must &lt;em&gt;not&lt;/em&gt; pattern match on the string literal because it may change in future versions (use &lt;code&gt;Failure _&lt;/code&gt; instead).</source>
          <target state="translated">주어진 인수에 정의되지 않았 음을 알리기 위해 라이브러리 함수에서 발생하는 예외입니다. 이 문자열은 프로그래머에게 몇 가지 정보를 제공하기위한 것입니다. 당신은 있어야 &lt;em&gt;되지&lt;/em&gt; 는 (사용의 향후 버전에서는 문자열 리터럴에 패턴 일치를 변경할 수 있기 때문에 &lt;code&gt;Failure _&lt;/code&gt; 대신).</target>
        </trans-unit>
        <trans-unit id="797259d42c53292ad6d9cae5fe9499225a450501" translate="yes" xml:space="preserve">
          <source>Exception raised by library functions to signal that they are undefined on the given arguments. The string is meant to give some information to the programmer; you must not pattern match on the string literal because it may change in future versions (use Failure _ instead).</source>
          <target state="translated">주어진 인수에 정의되지 않았 음을 알리기 위해 라이브러리 함수에서 발생하는 예외입니다. 이 문자열은 프로그래머에게 몇 가지 정보를 제공하기위한 것입니다. 이후 버전에서 변경 될 수 있으므로 문자열 리터럴에서 패턴 일치를 사용하면 안됩니다 (대신 Failure _ 사용).</target>
        </trans-unit>
        <trans-unit id="6a939c6f19243a7a27b33817d6c3cccd399f0471" translate="yes" xml:space="preserve">
          <source>Exception raised by search functions when the desired object could not be found.</source>
          <target state="translated">원하는 개체를 찾을 수 없을 때 검색 기능에서 발생하는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="74e471d3322f6cf64419d195e08e460252e2c212" translate="yes" xml:space="preserve">
          <source>Exception raised by the bytecode interpreter when the evaluation stack reaches its maximal size.</source>
          <target state="translated">평가 스택이 최대 크기에 도달 할 때 바이트 코드 인터프리터에서 발생하는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="a5e572e45624dcdfce646146b1c59f0702b1de31" translate="yes" xml:space="preserve">
          <source>Exception raised by the bytecode interpreter when the evaluation stack reaches its maximal size. This often indicates infinite or excessively deep recursion in the user&amp;rsquo;s program. Before 4.10, it was not fully implemented by the native-code compiler.</source>
          <target state="translated">평가 스택이 최대 크기에 도달 할 때 바이트 코드 인터프리터에서 발생하는 예외입니다. 이것은 종종 사용자 프로그램에서 무한하거나 지나치게 깊은 재귀를 나타냅니다. 4.10 이전에는 네이티브 코드 컴파일러에 의해 완전히 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="eafbe2aa6287023677ed95d39e464d69f627603a" translate="yes" xml:space="preserve">
          <source>Exception raised by the bytecode interpreter when the evaluation stack reaches its maximal size. This often indicates infinite or excessively deep recursion in the user's program.</source>
          <target state="translated">평가 스택이 최대 크기에 도달 할 때 바이트 코드 인터프리터에서 발생하는 예외입니다. 이것은 종종 사용자 프로그램에서 무한하거나 지나치게 깊은 재귀를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="25c82737838d58bf71651d2fbaaf6dcd90b0e977" translate="yes" xml:space="preserve">
          <source>Exception raised by the garbage collector when there is insufficient memory to complete the computation.</source>
          <target state="translated">계산을 완료하기위한 메모리가 부족할 때 가비지 수집기에서 발생하는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="86afff90609a22e194dc3619fb61e1382a6dfa8b" translate="yes" xml:space="preserve">
          <source>Exception raised by the garbage collector when there is insufficient memory to complete the computation. (Not reliable for allocations on the minor heap.)</source>
          <target state="translated">계산을 완료하기위한 메모리가 부족할 때 가비지 수집기에서 발생하는 예외입니다. (부 힙에 대한 할당에는 신뢰할 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="04f61cd268d77caa95705043d94ff400c1717740" translate="yes" xml:space="preserve">
          <source>Exception raised by the input/output functions to report an operating system error.</source>
          <target state="translated">운영 체제 오류를보고하기 위해 입력 / 출력 함수에서 발생한 예외입니다.</target>
        </trans-unit>
        <trans-unit id="e3bf7bb486274539ef14aee9c61a39c45080f2b2" translate="yes" xml:space="preserve">
          <source>Exception raised by the input/output functions to report an operating system error. The string is meant to give some information to the programmer; you must &lt;em&gt;not&lt;/em&gt; pattern match on the string literal because it may change in future versions (use &lt;code&gt;Sys_error _&lt;/code&gt; instead).</source>
          <target state="translated">운영 체제 오류를보고하기 위해 입력 / 출력 함수에서 발생한 예외입니다. 이 문자열은 프로그래머에게 몇 가지 정보를 제공하기위한 것입니다. 당신은해야 &lt;em&gt;하지&lt;/em&gt; 문자열 리터럴에 패턴 일치는 (사용 향후 버전에서 변경 될 수 있기 때문에 &lt;code&gt;Sys_error _&lt;/code&gt; 대신).</target>
        </trans-unit>
        <trans-unit id="0581cb33548055979f48d1861e6b229eba7ab670" translate="yes" xml:space="preserve">
          <source>Exception raised by the input/output functions to report an operating system error. The string is meant to give some information to the programmer; you must not pattern match on the string literal because it may change in future versions (use Sys_error _ instead).</source>
          <target state="translated">운영 체제 오류를보고하기 위해 입력 / 출력 함수에서 발생한 예외입니다. 이 문자열은 프로그래머에게 몇 가지 정보를 제공하기위한 것입니다. 이후 버전에서 변경 될 수 있으므로 문자열 리터럴에서 패턴 일치를 사용하면 안됩니다 (대신 Sys_error _ 사용).</target>
        </trans-unit>
        <trans-unit id="cf3b34162fd333f111fabc4e1219ee5b7ee0f141" translate="yes" xml:space="preserve">
          <source>Exception raised on interactive interrupt if &lt;a href=&quot;sys#VALcatch_break&quot;&gt;&lt;code&gt;Sys.catch_break&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="translated">&lt;a href=&quot;sys#VALcatch_break&quot;&gt; &lt;code&gt;Sys.catch_break&lt;/code&gt; &lt;/a&gt; 가 켜져있는 경우 대화 형 인터럽트에서 예외가 발생 했습니다.</target>
        </trans-unit>
        <trans-unit id="7be295586a8b968373c605fa23bab4f0788068a9" translate="yes" xml:space="preserve">
          <source>Exception raised when an assertion fails.</source>
          <target state="translated">어설 션이 실패하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6b18713a9f11df2a32a9f4552d5cc9de4147090a" translate="yes" xml:space="preserve">
          <source>Exception raised when an assertion fails. The arguments are the location of the assert keyword in the source code (file name, line number, column number).</source>
          <target state="translated">어설 션이 실패하면 예외가 발생합니다. 인수는 소스 코드에서 assert 키워드의 위치입니다 (파일 이름, 줄 번호, 열 번호).</target>
        </trans-unit>
        <trans-unit id="3f697fde1fd79527c41f5e00a6e22980baa8cb48" translate="yes" xml:space="preserve">
          <source>Exception raised when an ill-founded recursive module definition is evaluated.</source>
          <target state="translated">잘못된 재귀 모듈 정의가 평가 될 때 발생하는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="2a113d2a72fa73bfe6280e7724ea7861fe51a705" translate="yes" xml:space="preserve">
          <source>Exception raised when an ill-founded recursive module definition is evaluated. (See section &lt;a href=&quot;manual024#s%3Arecursive-modules&quot;&gt;8.2&lt;/a&gt;.) The arguments are the location of the definition in the source code (file name, line number, column number).</source>
          <target state="translated">잘못된 재귀 모듈 정의가 평가 될 때 발생하는 예외입니다. (섹션 &lt;a href=&quot;manual024#s%3Arecursive-modules&quot;&gt;8.2&lt;/a&gt; 참조 .) 인수는 소스 코드에서 정의 위치 (파일 이름, 줄 번호, 열 번호)입니다.</target>
        </trans-unit>
        <trans-unit id="fdb4b79613ced915c490c09e8d6900bf35cdc038" translate="yes" xml:space="preserve">
          <source>Exception raised when an ill-founded recursive module definition is evaluated. The arguments are the location of the definition in the source code (file name, line number, column number).</source>
          <target state="translated">잘못된 재귀 모듈 정의가 평가 될 때 발생하는 예외입니다. 인수는 소스 코드의 정의 위치 (파일 이름, 줄 번호, 열 번호)입니다.</target>
        </trans-unit>
        <trans-unit id="a6a958202f1e3608e7a8ea01d2ca2751bd4bea07" translate="yes" xml:space="preserve">
          <source>Exception raised when none of the cases of a pattern-matching apply.</source>
          <target state="translated">패턴 일치 사례가 적용되지 않는 경우 발생하는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="de14bb71c34237905f8dcebb811a688e4de7f45d" translate="yes" xml:space="preserve">
          <source>Exception raised when none of the cases of a pattern-matching apply. The arguments are the location of the match keyword in the source code (file name, line number, column number).</source>
          <target state="translated">패턴 일치 사례가 적용되지 않는 경우 발생하는 예외입니다. 인수는 소스 코드 (파일 이름, 줄 번호, 열 번호)에서 일치 키워드의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="3e3cff116501149a61e1bc172f77a1f0dc84b3e9" translate="yes" xml:space="preserve">
          <source>Exception slots</source>
          <target state="translated">예외 슬롯</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="2238f9897bfd70f8e17c597ae32443c2178f3778" translate="yes" xml:space="preserve">
          <source>Exceptions are defined with the syntax exception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; or exception&lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt;=&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;.</source>
          <target state="translated">예외는 예외 &lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; 또는 예외 &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt; = &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; 구문으로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd41474f597589f8ce75091ee7c9d450a6dace1b" translate="yes" xml:space="preserve">
          <source>Exceptions are used throughout the standard library to signal cases where the library functions cannot complete normally. For instance, the List.assoc function, which returns the data associated with a given key in a list of (key, data) pairs, raises the predefined exception Not_found when the key does not appear in the list:</source>
          <target state="translated">예외는 라이브러리 함수가 정상적으로 완료 될 수없는 경우를 알리기 위해 표준 라이브러리 전체에서 사용됩니다. 예를 들어 (키, 데이터) 쌍 목록에서 주어진 키와 관련된 데이터를 반환하는 List.assoc 함수는 키가 목록에 나타나지 않을 때 미리 정의 된 예외 Not_found를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="dedd1c7c976e1735c5590d9e4db8485865a74ba0" translate="yes" xml:space="preserve">
          <source>Exceptions arising from allocation points, for example &amp;ldquo;out of memory&amp;rdquo; or exceptions propagated from finalizers or signal handlers, are treated as &amp;ldquo;effects out of the ether&amp;rdquo; and thus ignored for our determination here of effectfulness. The same goes for floating point operations that may cause hardware traps on some platforms.</source>
          <target state="translated">할당 지점에서 발생하는 예외 (예 : &quot;메모리 부족&quot;또는 종료 자 또는 신호 처리기에서 전파 된 예외)는 &quot;이더에서 나온 효과&quot;로 처리되므로 여기에서 유효성을 판단 할 때 무시됩니다. 일부 플랫폼에서 하드웨어 트랩을 유발할 수있는 부동 소수점 연산도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="991e714f33417fc77efb0b8c274e6fb8c4a2e225" translate="yes" xml:space="preserve">
          <source>Exceptions can be trapped with the try&amp;hellip;with construct:</source>
          <target state="translated">try&amp;hellip; with 구문으로 예외를 포착 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="372172c1d79adf3d5e9eda6ccfe3f8d90f9945ca" translate="yes" xml:space="preserve">
          <source>Exceptions during scanning</source>
          <target state="translated">스캔 중 예외</target>
        </trans-unit>
        <trans-unit id="e2554291b193ac0bbead288da0987203e8cf0cef" translate="yes" xml:space="preserve">
          <source>Exceptions: A function application followed by a function return is replaced by the compiler by a jump (tail-call optimization). In this case, no event is put after the function application.</source>
          <target state="translated">예외 : 함수 응용 프로그램 뒤에 함수 반환이 오는 경우 컴파일러에서 점프 (꼬리 호출 최적화)로 대체됩니다. 이 경우 함수 적용 후 이벤트가 발생하지 않습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="6a8396b2656b2d03ab3b6f1d6e1517dcf7f9323c" translate="yes" xml:space="preserve">
          <source>Executables generated by ocamlopt are native, stand-alone executable files that can be invoked directly. They do not depend on the ocamlrun bytecode runtime system nor on dynamically-loaded C/OCaml stub libraries.</source>
          <target state="translated">ocamlopt에 의해 생성 된 실행 파일은 직접 호출 할 수있는 기본 독립 실행 형 실행 파일입니다. ocamlrun 바이트 코드 런타임 시스템이나 동적으로로드 된 C / OCaml 스텁 라이브러리에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a75cb0fbe6e1f95d107a45c86db811a6af245781" translate="yes" xml:space="preserve">
          <source>Execute a command and evaluate its output as if it had been captured to a file and passed to #use.</source>
          <target state="translated">명령을 실행하고 파일에 캡처되어 #use에 전달 된 것처럼 출력을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="cd6abf7887c4d2e28797ef14bbf252bcefcb389d" translate="yes" xml:space="preserve">
          <source>Execute the given command, wait until it terminates, and return its termination status.</source>
          <target state="translated">주어진 명령을 실행하고 종료 될 때까지 기다린 다음 종료 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="574778ff914e7f066648409df6d7571f66b0628f" translate="yes" xml:space="preserve">
          <source>Execute the given command, wait until it terminates, and return its termination status. The string is interpreted by the shell &lt;code&gt;/bin/sh&lt;/code&gt; (or the command interpreter &lt;code&gt;cmd.exe&lt;/code&gt; on Windows) and therefore can contain redirections, quotes, variables, etc. To properly quote whitespace and shell special characters occurring in file names or command arguments, the use of &lt;a href=&quot;filename#VALquote_command&quot;&gt;&lt;code&gt;Filename.quote_command&lt;/code&gt;&lt;/a&gt; is recommended. The result &lt;code&gt;WEXITED&amp;nbsp;127&lt;/code&gt; indicates that the shell couldn't be executed.</source>
          <target state="translated">주어진 명령을 실행하고 종료 될 때까지 기다린 다음 종료 상태를 반환합니다. 문자열은 쉘 &lt;code&gt;/bin/sh&lt;/code&gt; (또는 Windows의 경우 명령 인터프리터 &lt;code&gt;cmd.exe&lt;/code&gt; ) 에 의해 해석 되므로 리디렉션, 따옴표, 변수 등을 포함 할 수 있습니다. 파일 이름 또는 명령 인수에 나타나는 공백 및 쉘 특수 문자를 올바르게 인용하려면, &lt;a href=&quot;filename#VALquote_command&quot;&gt; &lt;code&gt;Filename.quote_command&lt;/code&gt; 를&lt;/a&gt; 사용하는 것이 좋습니다. &lt;code&gt;WEXITED&amp;nbsp;127&lt;/code&gt; 이라는 결과 는 셸을 실행할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f7d77de49a824f25b1c29a5f4eec5fd988f90820" translate="yes" xml:space="preserve">
          <source>Execute the given command, wait until it terminates, and return its termination status. The string is interpreted by the shell &lt;code&gt;/bin/sh&lt;/code&gt; and therefore can contain redirections, quotes, variables, etc. The result &lt;code&gt;WEXITED&amp;nbsp;127&lt;/code&gt; indicates that the shell couldn't be executed.</source>
          <target state="translated">주어진 명령을 실행하고 종료 될 때까지 기다린 다음 종료 상태를 반환합니다. 문자열은 쉘 &lt;code&gt;/bin/sh&lt;/code&gt; 에 의해 해석 되므로 리디렉션, 따옴표, 변수 등을 포함 할 수 있습니다. 결과 &lt;code&gt;WEXITED&amp;nbsp;127&lt;/code&gt; 은 쉘을 실행할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0608baa8a78b5ae914f3003511af7be2c2c93014" translate="yes" xml:space="preserve">
          <source>Execute the given shell command and return its exit code.</source>
          <target state="translated">주어진 셸 명령을 실행하고 종료 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0af194ef467afd2c1974b37ed62f0bacbfce09b8" translate="yes" xml:space="preserve">
          <source>Execute the next formatting command if the preceding line has just been split.</source>
          <target state="translated">이전 줄이 방금 분할 된 경우 다음 형식 지정 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="a7de809064d068ca06042492cbbecc713a130fb0" translate="yes" xml:space="preserve">
          <source>Execute the next formatting command if the preceding line has just been split. Otherwise, ignore the next formatting command.</source>
          <target state="translated">이전 줄이 방금 분할 된 경우 다음 형식 지정 명령을 실행합니다. 그렇지 않으면 다음 포맷 명령을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="e6f74a11401cd4113f73bb69746c60cbce990f88" translate="yes" xml:space="preserve">
          <source>Execute the program backward from current time. Mostly useful to go to the last breakpoint encountered before the current time.</source>
          <target state="translated">현재 시간에서 뒤로 프로그램을 실행합니다. 현재 시간 이전에 발생한 마지막 중단 점으로 이동하는 데 가장 유용합니다.</target>
        </trans-unit>
        <trans-unit id="df078a291452a67568ddc09970c248124955e570" translate="yes" xml:space="preserve">
          <source>Execute the program forward from current time. Stops at next breakpoint or when the program terminates.</source>
          <target state="translated">현재 시간부터 프로그램을 앞으로 실행합니다. 다음 중단 점 또는 프로그램이 종료 될 때 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="c02112c85adf1b08f7e5853b39572e0ee9bc6c34" translate="yes" xml:space="preserve">
          <source>Execution permission</source>
          <target state="translated">실행 권한</target>
        </trans-unit>
        <trans-unit id="3e880ccfcb55dc69e7de8a37d9266e752fe53e6d" translate="yes" xml:space="preserve">
          <source>Execution speed of instrumented programs may be increased by using a compiler configured with the -disable-libunwind option. This prevents collection of profiling information from C stubs.</source>
          <target state="translated">-disable-libunwind 옵션으로 구성된 컴파일러를 사용하여 계측 된 프로그램의 실행 속도를 높일 수 있습니다. 이렇게하면 C 스텁에서 프로파일 링 정보가 수집되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6612d96f1b19e6fcd3bf9e1ca12e32ac3e408b29" translate="yes" xml:space="preserve">
          <source>Exit the toplevel loop and terminate the ocaml command.</source>
          <target state="translated">최상위 루프를 종료하고 ocaml 명령을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="4613952597a60f36dc738da2fc8adbdc7b73e160" translate="yes" xml:space="preserve">
          <source>Explain that the element may raise the exception Exc.</source>
          <target state="translated">요소가 Exc 예외를 발생시킬 수 있음을 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="2bbb0891217ae52a1ab104fe98d015359de8bd2c" translate="yes" xml:space="preserve">
          <source>Explicit polymorphic annotations are however not sufficient to cover all the cases where the inferred type of a function is less general than expected. A similar problem arises when using polymorphic functions as arguments of higher-order functions. For instance, we may want to compute the average depth or length of two nested lists:</source>
          <target state="translated">그러나 명시 적 다형성 주석은 추론 된 함수 유형이 예상보다 덜 일반적인 모든 경우를 포괄하기에 충분하지 않습니다. 다형성 함수를 고차 함수의 인수로 사용할 때 유사한 문제가 발생합니다. 예를 들어, 두 개의 중첩 된 목록의 평균 깊이 또는 길이를 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e27dcc67d74da822483f4a87bdb412456ae6c72" translate="yes" xml:space="preserve">
          <source>Exponential.</source>
          <target state="translated">Exponential.</target>
        </trans-unit>
        <trans-unit id="00626a4a235bb8c7d8a4523a50b2711b29b68253" translate="yes" xml:space="preserve">
          <source>Exponentiation.</source>
          <target state="translated">Exponentiation.</target>
        </trans-unit>
        <trans-unit id="19211cb05426c63a6dfeb4df4f1124b3d1c45b8a" translate="yes" xml:space="preserve">
          <source>Exponentiation. &lt;code&gt;exp&amp;nbsp;z&lt;/code&gt; returns &lt;code&gt;e&lt;/code&gt; to the &lt;code&gt;z&lt;/code&gt; power.</source>
          <target state="translated">지수화. &lt;code&gt;exp&amp;nbsp;z&lt;/code&gt; 는 &lt;code&gt;e&lt;/code&gt; 의 &lt;code&gt;z&lt;/code&gt; 거듭 제곱 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c8d13444fe741e7b3307739c09714d1365b0f345" translate="yes" xml:space="preserve">
          <source>Exponentiation. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">지수화. 오른쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="c203b1d6525313f2263e8e1944c32119cb764891" translate="yes" xml:space="preserve">
          <source>Expression on the left-hand side of a sequence that doesn&amp;rsquo;t have type unit (and that is not a function, see warning number 5).</source>
          <target state="translated">유형 단위가없는 시퀀스의 왼쪽에있는 표현식입니다 (함수가 아님, 경고 번호 5 참조).</target>
        </trans-unit>
        <trans-unit id="60f1705d75bccd5f48e15260577376d17aae18ac" translate="yes" xml:space="preserve">
          <source>Expressions can be evaluated and bound before defining the object body of the class. This is useful to enforce invariants. For instance, points can be automatically adjusted to the nearest point on a grid, as follows:</source>
          <target state="translated">클래스의 개체 본문을 정의하기 전에 식을 평가하고 바인딩 할 수 있습니다. 이것은 불변성을 적용하는 데 유용합니다. 예를 들어, 포인트는 다음과 같이 그리드에서 가장 가까운 포인트로 자동 조정될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23bad0bff2cfb9167ce61cc77278d82a1d641c32" translate="yes" xml:space="preserve">
          <source>Expressions found to be constant will be lifted to symbol bindings&amp;mdash;that is to say, they will be statically allocated in the object file&amp;mdash;when they evaluate to boxed values. Such constants may be straightforward numeric constants, such as the floating-point number 42.0, or more complicated values such as constant closures.</source>
          <target state="translated">상수로 확인 된 표현식은 박스형 값으로 평가 될 때 심볼 바인딩으로 해제됩니다. 즉, 개체 파일에 정적으로 할당됩니다. 이러한 상수는 부동 소수점 숫자 42.0과 같은 간단한 숫자 상수이거나 상수 클로저와 같은 더 복잡한 값일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ad4d4956756b40be94add29cb72479307f0f0b9" translate="yes" xml:space="preserve">
          <source>Expressions that can be printed are a subset of OCaml expressions, as described by the following grammar:</source>
          <target state="translated">인쇄 할 수있는 식은 다음 문법에 설명 된대로 OCaml 식의 하위 집합입니다.</target>
        </trans-unit>
        <trans-unit id="3dc85e1b2d1a796e6a7518d332650d75cedd74aa" translate="yes" xml:space="preserve">
          <source>Expressions whose type contains object or polymorphic variant types can be explicitly coerced (weakened) to a supertype. The expression (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;:&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;) coerces the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; to type &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;. The expression (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;) coerces the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; from type &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to type &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="translated">유형에 객체 또는 다형성 변형 유형이 포함 된 표현식은 명시 적으로 수퍼 유형으로 강제 (약화) 될 수 있습니다. 표현식 ( &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; :&amp;gt; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; )은 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 표현식 을 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; 유형으로 강제 합니다. 표현식 ( &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; : &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; :&amp;gt; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; )은 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 표현식을 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 유형에서 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 유형으로 강제 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="61b81693815dc1bf7299ce7a39fbde9dd09e2888" translate="yes" xml:space="preserve">
          <source>Extensible buffers.</source>
          <target state="translated">확장 가능한 버퍼.</target>
        </trans-unit>
        <trans-unit id="a7bb5fa60fa6d03a7e762271e49bf8b6f67aabc7" translate="yes" xml:space="preserve">
          <source>Extensible variant constructors can be declared private. As with regular variants, this prevents them from being constructed directly by constructor application while still allowing them to be de-structured in pattern-matching.</source>
          <target state="translated">확장 가능한 변형 생성자는 비공개로 선언 할 수 있습니다. 일반 변형과 마찬가지로 이는 생성자 응용 프로그램에 의해 직접 구성되는 것을 방지하는 동시에 패턴 일치에서 구조화를 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a751b1c007eb71d24f98009b78b3028fcfd142ad" translate="yes" xml:space="preserve">
          <source>Extensible variant constructors can be rebound to a different name. This allows exporting variants from another module.</source>
          <target state="translated">확장 가능한 변형 생성자는 다른 이름으로 리 바인드 될 수 있습니다. 이를 통해 다른 모듈에서 변형을 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb163e8407915a65efaeea5f20e5a40195d135d5" translate="yes" xml:space="preserve">
          <source>Extensible variant types are variant types which can be extended with new variant constructors. Extensible variant types are defined using ... New variant constructors are added using +=.</source>
          <target state="translated">확장 가능한 변형 유형은 새로운 변형 생성자로 확장 할 수있는 변형 유형입니다. 확장 가능한 변형 유형은 ...를 사용하여 정의됩니다. 새 변형 생성자는 + =를 사용하여 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="bbae4e45fe35ccd27009a7f6ac4d50b75dc776ba" translate="yes" xml:space="preserve">
          <source>Extensible variant types can be declared private. This prevents new constructors from being declared directly, but allows extension constructors to be referred to in interfaces.</source>
          <target state="translated">확장 가능한 변형 유형은 비공개로 선언 할 수 있습니다. 이렇게하면 새 생성자가 직접 선언되지 않지만 확장 생성자가 인터페이스에서 참조 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abad3f737769af1c5381da23ef9ef6b76a078836" translate="yes" xml:space="preserve">
          <source>Extension nodes are generic placeholders in the syntax tree. They are rejected by the type-checker and are intended to be &amp;ldquo;expanded&amp;rdquo; by external tools such as -ppx rewriters.</source>
          <target state="translated">확장 노드는 구문 트리의 일반적인 자리 표시 자입니다. 유형 검사기에 의해 거부되며 -ppx rewriters와 같은 외부 도구에 의해 &quot;확장&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="2d5c126d6514cf4043869b49a67a530848a05b30" translate="yes" xml:space="preserve">
          <source>Extension nodes share the same notion of identifier and payload as attributes &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;8.12&lt;/a&gt;.</source>
          <target state="translated">확장 노드는 &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;8.12&lt;/a&gt; 속성과 동일한 식별자 및 페이로드 개념을 공유합니다 .</target>
        </trans-unit>
        <trans-unit id="4cf67e72b2f02af1dfb2d6ba5dfec301a7a98be7" translate="yes" xml:space="preserve">
          <source>External functions thus defined can be specified in interface files or sig&amp;hellip;end signatures either as regular values</source>
          <target state="translated">이렇게 정의 된 외부 함수는 인터페이스 파일 또는 sig&amp;hellip; end 서명에 일반 값으로 지정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac72a44ed810b210da3e88f1a54857ee291d450b" translate="yes" xml:space="preserve">
          <source>Extra labeled libraries.</source>
          <target state="translated">레이블이 추가 된 라이브러리.</target>
        </trans-unit>
        <trans-unit id="f790fb266cf755446d7f9e758cc6eb9851e8e4a0" translate="yes" xml:space="preserve">
          <source>Extract a column (one-dimensional slice) of the given two-dimensional Bigarray.</source>
          <target state="translated">주어진 2 차원 Bigarray의 열 (1 차원 슬라이스)을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="833297ee7526e57b208b20f4c18e1d5dca4a7686" translate="yes" xml:space="preserve">
          <source>Extract a column (one-dimensional slice) of the given two-dimensional Bigarray. The integer parameter is the index of the column to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array2.slice_right&lt;/code&gt; applies only to arrays with Fortran layout.</source>
          <target state="translated">주어진 2 차원 Bigarray의 열 (1 차원 슬라이스)을 추출합니다. 정수 매개 변수는 추출 할 열의 색인입니다. 자세한 내용은 &lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt; &lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. &lt;code&gt;Array2.slice_right&lt;/code&gt; 는 Fortran 레이아웃이있는 배열에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="bb22154616f00f2f011552b3ea60d6b2aecf319e" translate="yes" xml:space="preserve">
          <source>Extract a one-dimensional slice of the given three-dimensional Bigarray by fixing the first two coordinates.</source>
          <target state="translated">처음 두 좌표를 고정하여 주어진 3 차원 Bigarray의 1 차원 슬라이스를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="ad37ffd1656e9bfa0f39271771a3d21b053f2b47" translate="yes" xml:space="preserve">
          <source>Extract a one-dimensional slice of the given three-dimensional Bigarray by fixing the first two coordinates. The integer parameters are the coordinates of the slice to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array3.slice_left_1&lt;/code&gt; applies only to arrays with C layout.</source>
          <target state="translated">처음 두 좌표를 고정하여 주어진 3 차원 Bigarray의 1 차원 슬라이스를 추출합니다. 정수 매개 변수는 추출 할 슬라이스의 좌표입니다. 자세한 내용은 &lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt; &lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. &lt;code&gt;Array3.slice_left_1&lt;/code&gt; 은 C 레이아웃이있는 배열에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d6010cd1774b0e36289453cc1e6dfe0970661753" translate="yes" xml:space="preserve">
          <source>Extract a one-dimensional slice of the given three-dimensional Bigarray by fixing the last two coordinates.</source>
          <target state="translated">마지막 두 좌표를 고정하여 주어진 3 차원 Bigarray의 1 차원 슬라이스를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="cf737c09a505d01b3f96a5a97197df81b81dd1a3" translate="yes" xml:space="preserve">
          <source>Extract a one-dimensional slice of the given three-dimensional Bigarray by fixing the last two coordinates. The integer parameters are the coordinates of the slice to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array3.slice_right_1&lt;/code&gt; applies only to arrays with Fortran layout.</source>
          <target state="translated">마지막 두 좌표를 고정하여 주어진 3 차원 Bigarray의 1 차원 슬라이스를 추출합니다. 정수 매개 변수는 추출 할 슬라이스의 좌표입니다. 자세한 내용은 &lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt; &lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. &lt;code&gt;Array3.slice_right_1&lt;/code&gt; 은 Fortran 레이아웃이있는 배열에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a0e5512943bae825f5c013cca4f39482aa0889f2" translate="yes" xml:space="preserve">
          <source>Extract a row (one-dimensional slice) of the given two-dimensional Bigarray.</source>
          <target state="translated">주어진 2 차원 Bigarray의 행 (1 차원 슬라이스)을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="26d59417fe2650d9c47ddc3625b1cd42e8be0565" translate="yes" xml:space="preserve">
          <source>Extract a row (one-dimensional slice) of the given two-dimensional Bigarray. The integer parameter is the index of the row to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array2.slice_left&lt;/code&gt; applies only to arrays with C layout.</source>
          <target state="translated">주어진 2 차원 Bigarray의 행 (1 차원 슬라이스)을 추출합니다. 정수 매개 변수는 추출 할 행의 색인입니다. 자세한 내용은 &lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt; &lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. &lt;code&gt;Array2.slice_left&lt;/code&gt; 는 C 레이아웃이있는 배열에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f298454ec85bb5b2575358f7258eca1d4945ff16" translate="yes" xml:space="preserve">
          <source>Extract a scalar (zero-dimensional slice) of the given one-dimensional Bigarray.</source>
          <target state="translated">주어진 1 차원 Bigarray의 스칼라 (0 차원 슬라이스)를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="4d9a56c0a314a42963df6eba68beda2c406199e0" translate="yes" xml:space="preserve">
          <source>Extract a scalar (zero-dimensional slice) of the given one-dimensional Bigarray. The integer parameter is the index of the scalar to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">주어진 1 차원 Bigarray의 스칼라 (0 차원 슬라이스)를 추출합니다. 정수 매개 변수는 추출 할 스칼라의 색인입니다. 자세한 내용은 &lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt; &lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt; &lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4890dc1e2a164bc3bd30e8680621df9dc17f4f52" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of lower dimension from the given Bigarray by fixing one or several of the first (left-most) coordinates.</source>
          <target state="translated">첫 번째 (가장 왼쪽) 좌표 중 하나 또는 여러 개를 고정하여 주어진 Bigarray에서 더 낮은 차원의 하위 배열을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="40d6af71cee95b994ed1e0170824c34a05edad4a" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of lower dimension from the given Bigarray by fixing one or several of the first (left-most) coordinates. &lt;code&gt;Genarray.slice_left&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...&amp;nbsp;;&amp;nbsp;iM|]&lt;/code&gt; returns the 'slice' of &lt;code&gt;a&lt;/code&gt; obtained by setting the first &lt;code&gt;M&lt;/code&gt; coordinates to &lt;code&gt;i1&lt;/code&gt;, ..., &lt;code&gt;iM&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has &lt;code&gt;N&lt;/code&gt; dimensions, the slice has dimension &lt;code&gt;N&amp;nbsp;-&amp;nbsp;M&lt;/code&gt;, and the element at coordinates &lt;code&gt;[|j1;&amp;nbsp;...;&amp;nbsp;j(N-M)|]&lt;/code&gt; in the slice is identical to the element at coordinates &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iM;&amp;nbsp;j1;&amp;nbsp;...;&amp;nbsp;j(N-M)|]&lt;/code&gt; in the original array &lt;code&gt;a&lt;/code&gt;. No copying of elements is involved: the slice and the original array share the same storage space.</source>
          <target state="translated">첫 번째 (가장 왼쪽) 좌표 중 하나 또는 여러 개를 고정하여 주어진 Bigarray에서 더 낮은 차원의 하위 배열을 추출합니다. &lt;code&gt;Genarray.slice_left&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...&amp;nbsp;;&amp;nbsp;iM|]&lt;/code&gt; 은 첫 번째 &lt;code&gt;M&lt;/code&gt; 좌표를 &lt;code&gt;i1&lt;/code&gt; , ..., &lt;code&gt;iM&lt;/code&gt; 으로 설정하여 얻은 &lt;code&gt;a&lt;/code&gt; 의 '슬라이스'를 반환합니다 . &lt;code&gt;a&lt;/code&gt; 에 &lt;code&gt;N&lt;/code&gt; 개의 차원 이 있으면 슬라이스의 차원은 &lt;code&gt;N&amp;nbsp;-&amp;nbsp;M&lt;/code&gt; 이고 요소는 좌표 &lt;code&gt;[|j1;&amp;nbsp;...;&amp;nbsp;j(N-M)|]&lt;/code&gt; ...; 슬라이스의 j (NM) |] 은 좌표 &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iM;&amp;nbsp;j1;&amp;nbsp;...;&amp;nbsp;j(N-M)|]&lt;/code&gt; ...; iM; j1; ...; j (NM) |] 원래 배열 &lt;code&gt;a&lt;/code&gt; . 요소의 복사는 포함되지 않습니다. 슬라이스와 원본 어레이는 동일한 저장 공간을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="4991d63b98b224377a908b9a4d6c71e3eaac9a4c" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of lower dimension from the given Bigarray by fixing one or several of the last (right-most) coordinates.</source>
          <target state="translated">마지막 (가장 오른쪽) 좌표 중 하나 또는 여러 개를 고정하여 주어진 Bigarray에서 더 낮은 차원의 하위 배열을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="3da691a1efc9418f8852a37e8c7a82a916c26169" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of lower dimension from the given Bigarray by fixing one or several of the last (right-most) coordinates. &lt;code&gt;Genarray.slice_right&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...&amp;nbsp;;&amp;nbsp;iM|]&lt;/code&gt; returns the 'slice' of &lt;code&gt;a&lt;/code&gt; obtained by setting the last &lt;code&gt;M&lt;/code&gt; coordinates to &lt;code&gt;i1&lt;/code&gt;, ..., &lt;code&gt;iM&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has &lt;code&gt;N&lt;/code&gt; dimensions, the slice has dimension &lt;code&gt;N&amp;nbsp;-&amp;nbsp;M&lt;/code&gt;, and the element at coordinates &lt;code&gt;[|j1;&amp;nbsp;...;&amp;nbsp;j(N-M)|]&lt;/code&gt; in the slice is identical to the element at coordinates &lt;code&gt;[|j1;&amp;nbsp;...;&amp;nbsp;j(N-M);&amp;nbsp;i1;&amp;nbsp;...;&amp;nbsp;iM|]&lt;/code&gt; in the original array &lt;code&gt;a&lt;/code&gt;. No copying of elements is involved: the slice and the original array share the same storage space.</source>
          <target state="translated">마지막 (가장 오른쪽) 좌표 중 하나 또는 여러 개를 고정하여 주어진 Bigarray에서 더 낮은 차원의 하위 배열을 추출합니다. &lt;code&gt;Genarray.slice_right&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...&amp;nbsp;;&amp;nbsp;iM|]&lt;/code&gt; 은 마지막 &lt;code&gt;M&lt;/code&gt; 좌표를 &lt;code&gt;i1&lt;/code&gt; , ..., &lt;code&gt;iM&lt;/code&gt; 으로 설정하여 얻은 &lt;code&gt;a&lt;/code&gt; 의 '슬라이스'를 반환합니다 . &lt;code&gt;a&lt;/code&gt; 에 &lt;code&gt;N&lt;/code&gt; 개의 차원 이 있으면 슬라이스의 차원은 &lt;code&gt;N&amp;nbsp;-&amp;nbsp;M&lt;/code&gt; 이고 요소는 좌표 &lt;code&gt;[|j1;&amp;nbsp;...;&amp;nbsp;j(N-M)|]&lt;/code&gt; ...; 슬라이스의 j (NM) |] 은 좌표 &lt;code&gt;[|j1;&amp;nbsp;...;&amp;nbsp;j(N-M);&amp;nbsp;i1;&amp;nbsp;...;&amp;nbsp;iM|]&lt;/code&gt; ...; j (NM); i1; ...; iM |] 원래 배열 &lt;code&gt;a&lt;/code&gt; . 요소의 복사는 포함되지 않습니다. 슬라이스와 원본 어레이는 동일한 저장 공간을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="c46828383a7b610302db9977200dc3af956d9d40" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of the given Bigarray by restricting the first (left-most) dimension.</source>
          <target state="translated">첫 번째 (가장 왼쪽) 차원을 제한하여 지정된 Bigarray의 하위 배열을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="4aff802ef1d94d3ecbad0ecdb29da0e7d90a7532" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of the given Bigarray by restricting the first (left-most) dimension. &lt;code&gt;Genarray.sub_left&amp;nbsp;a&amp;nbsp;ofs&amp;nbsp;len&lt;/code&gt; returns a Bigarray with the same number of dimensions as &lt;code&gt;a&lt;/code&gt;, and the same dimensions as &lt;code&gt;a&lt;/code&gt;, except the first dimension, which corresponds to the interval &lt;code&gt;[ofs&amp;nbsp;...&amp;nbsp;ofs&amp;nbsp;+&amp;nbsp;len&amp;nbsp;-&amp;nbsp;1]&lt;/code&gt; of the first dimension of &lt;code&gt;a&lt;/code&gt;. No copying of elements is involved: the sub-array and the original array share the same storage space. In other terms, the element at coordinates &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; of the sub-array is identical to the element at coordinates &lt;code&gt;[|i1+ofs;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; of the original array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">첫 번째 (가장 왼쪽) 차원을 제한하여 지정된 Bigarray의 하위 배열을 추출합니다. &lt;code&gt;Genarray.sub_left&amp;nbsp;a&amp;nbsp;ofs&amp;nbsp;len&lt;/code&gt; 같은 크기의 같은 번호를 가진 Bigarray를 반환 와 동일한 크기 제 사이즈를 제외한, 상기 간격에 대응 &lt;code&gt;[ofs&amp;nbsp;...&amp;nbsp;ofs&amp;nbsp;+&amp;nbsp;len&amp;nbsp;-&amp;nbsp;1]&lt;/code&gt; 제 차원 의 . 요소의 복사는 포함되지 않습니다. 하위 어레이와 원래 어레이는 동일한 저장 공간을 공유합니다. 즉, 좌표 &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; 하위 배열의 iN |] 은 좌표 &lt;code&gt;[|i1+ofs;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; 원래 배열 &lt;code&gt;a&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec56516e6aae1f3b317a5b584d2632b8a7b8895e" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of the given Bigarray by restricting the last (right-most) dimension.</source>
          <target state="translated">마지막 (가장 오른쪽) 차원을 제한하여 주어진 Bigarray의 하위 배열을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="a34e0eda1631250d817bcac2137b343bc89c7dd1" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of the given Bigarray by restricting the last (right-most) dimension. &lt;code&gt;Genarray.sub_right&amp;nbsp;a&amp;nbsp;ofs&amp;nbsp;len&lt;/code&gt; returns a Bigarray with the same number of dimensions as &lt;code&gt;a&lt;/code&gt;, and the same dimensions as &lt;code&gt;a&lt;/code&gt;, except the last dimension, which corresponds to the interval &lt;code&gt;[ofs&amp;nbsp;...&amp;nbsp;ofs&amp;nbsp;+&amp;nbsp;len&amp;nbsp;-&amp;nbsp;1]&lt;/code&gt; of the last dimension of &lt;code&gt;a&lt;/code&gt;. No copying of elements is involved: the sub-array and the original array share the same storage space. In other terms, the element at coordinates &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; of the sub-array is identical to the element at coordinates &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iN+ofs|]&lt;/code&gt; of the original array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">마지막 (가장 오른쪽) 차원을 제한하여 주어진 Bigarray의 하위 배열을 추출합니다. &lt;code&gt;Genarray.sub_right&amp;nbsp;a&amp;nbsp;ofs&amp;nbsp;len&lt;/code&gt; 은 마지막 차원의 &lt;code&gt;[ofs&amp;nbsp;...&amp;nbsp;ofs&amp;nbsp;+&amp;nbsp;len&amp;nbsp;-&amp;nbsp;1]&lt;/code&gt; 간격에 해당하는 마지막 차원을 제외하고 &lt;code&gt;a&lt;/code&gt; 와 동일한 수의 차원 및 &lt;code&gt;a&lt;/code&gt; 와 동일한 차원을 가진 Bigarray를 반환 합니다. 의 . 요소의 복사는 포함되지 않습니다. 하위 어레이와 원본 어레이는 동일한 저장 공간을 공유합니다. 즉, 좌표 &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; ...; 하위 배열의 iN |] 은 좌표 &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iN+ofs|]&lt;/code&gt; ...; iN + ofs |] 원래 배열 &lt;code&gt;a&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f5554ff9dda92542b6f7561e6614060047356a2b" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of the given one-dimensional Bigarray.</source>
          <target state="translated">주어진 1 차원 Bigarray의 하위 배열을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="d0974dd62db48917a734039db3543ccc1edaf6d5" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of the given one-dimensional Bigarray. See &lt;a href=&quot;bigarray.genarray#VALsub_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.sub_left&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">주어진 1 차원 Bigarray의 하위 배열을 추출합니다. 자세한 내용은 &lt;a href=&quot;bigarray.genarray#VALsub_left&quot;&gt; &lt;code&gt;Bigarray.Genarray.sub_left&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e53e9d490ec58fcd840b3ecff5aa4d740c5a251b" translate="yes" xml:space="preserve">
          <source>Extract a three-dimensional sub-array of the given three-dimensional Bigarray by restricting the first dimension.</source>
          <target state="translated">첫 번째 차원을 제한하여 주어진 3 차원 Bigarray의 3 차원 하위 ​​배열을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="2dbaf2cc98d146044211330545282dd4bf053e2b" translate="yes" xml:space="preserve">
          <source>Extract a three-dimensional sub-array of the given three-dimensional Bigarray by restricting the first dimension. See &lt;a href=&quot;bigarray.genarray#VALsub_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.sub_left&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array3.sub_left&lt;/code&gt; applies only to arrays with C layout.</source>
          <target state="translated">첫 번째 차원을 제한하여 주어진 3 차원 Bigarray의 3 차원 하위 ​​배열을 추출합니다. 자세한 내용은 &lt;a href=&quot;bigarray.genarray#VALsub_left&quot;&gt; &lt;code&gt;Bigarray.Genarray.sub_left&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. &lt;code&gt;Array3.sub_left&lt;/code&gt; 는 C 레이아웃이있는 배열에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c7316b8d9a713505a81c0b289dbb0aa52b6e1f01" translate="yes" xml:space="preserve">
          <source>Extract a three-dimensional sub-array of the given three-dimensional Bigarray by restricting the second dimension.</source>
          <target state="translated">두 번째 차원을 제한하여 주어진 3 차원 Bigarray의 3 차원 하위 ​​배열을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="056b02ba98ed67c31e20bd342a4e027d66f1e6cc" translate="yes" xml:space="preserve">
          <source>Extract a three-dimensional sub-array of the given three-dimensional Bigarray by restricting the second dimension. See &lt;a href=&quot;bigarray.genarray#VALsub_right&quot;&gt;&lt;code&gt;Bigarray.Genarray.sub_right&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array3.sub_right&lt;/code&gt; applies only to arrays with Fortran layout.</source>
          <target state="translated">두 번째 차원을 제한하여 주어진 3 차원 Bigarray의 3 차원 하위 ​​배열을 추출합니다. 자세한 내용은 &lt;a href=&quot;bigarray.genarray#VALsub_right&quot;&gt; &lt;code&gt;Bigarray.Genarray.sub_right&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. &lt;code&gt;Array3.sub_right&lt;/code&gt; 는 Fortran 레이아웃이있는 배열에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6c50856385dbad4b307a8ae71cadaf999e22cc35" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional slice of the given three-dimensional Bigarray by fixing the first coordinate.</source>
          <target state="translated">첫 번째 좌표를 고정하여 주어진 3 차원 Bigarray의 2 차원 슬라이스를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="d59aaaea254d72dfb6345bd1442c286d26075296" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional slice of the given three-dimensional Bigarray by fixing the first coordinate. The integer parameter is the first coordinate of the slice to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array3.slice_left_2&lt;/code&gt; applies only to arrays with C layout.</source>
          <target state="translated">첫 번째 좌표를 고정하여 주어진 3 차원 Bigarray의 2 차원 슬라이스를 추출합니다. 정수 매개 변수는 추출 할 슬라이스의 첫 번째 좌표입니다. 자세한 내용은 &lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt; &lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. &lt;code&gt;Array3.slice_left_2&lt;/code&gt; 는 C 레이아웃이있는 배열에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d3c305334b5904d71fa016401a34c6c315c3352" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional slice of the given three-dimensional Bigarray by fixing the last coordinate.</source>
          <target state="translated">마지막 좌표를 고정하여 주어진 3 차원 Bigarray의 2 차원 슬라이스를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="3884aec3f88c9f1f2b2e3b25f39bd946908fcc74" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional slice of the given three-dimensional Bigarray by fixing the last coordinate. The integer parameter is the coordinate of the slice to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array3.slice_right_2&lt;/code&gt; applies only to arrays with Fortran layout.</source>
          <target state="translated">마지막 좌표를 고정하여 주어진 3 차원 Bigarray의 2 차원 슬라이스를 추출합니다. 정수 매개 변수는 추출 할 슬라이스의 좌표입니다. 자세한 내용은 &lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt; &lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. &lt;code&gt;Array3.slice_right_2&lt;/code&gt; 는 Fortran 레이아웃이있는 배열에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d60284e2482e2e7da314ae1de64dae482731ef85" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional sub-array of the given two-dimensional Bigarray by restricting the first dimension.</source>
          <target state="translated">첫 번째 차원을 제한하여 주어진 2 차원 Bigarray의 2 차원 하위 ​​배열을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="3a423ddd0f0211bed822fd7dfab480315f3a9a59" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional sub-array of the given two-dimensional Bigarray by restricting the first dimension. See &lt;a href=&quot;bigarray.genarray#VALsub_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.sub_left&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array2.sub_left&lt;/code&gt; applies only to arrays with C layout.</source>
          <target state="translated">첫 번째 차원을 제한하여 주어진 2 차원 Bigarray의 2 차원 하위 ​​배열을 추출합니다. 자세한 내용은 &lt;a href=&quot;bigarray.genarray#VALsub_left&quot;&gt; &lt;code&gt;Bigarray.Genarray.sub_left&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. &lt;code&gt;Array2.sub_left&lt;/code&gt; 는 C 레이아웃이있는 배열에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3ed998f4ffe6b722cf6d8ef34b19960eb7ede4ad" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional sub-array of the given two-dimensional Bigarray by restricting the second dimension.</source>
          <target state="translated">2 차원을 제한하여 주어진 2 차원 Bigarray의 2 차원 하위 ​​배열을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="ccaeebe42f0e1c15c6787813703cfa497e76749e" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional sub-array of the given two-dimensional Bigarray by restricting the second dimension. See &lt;a href=&quot;bigarray.genarray#VALsub_right&quot;&gt;&lt;code&gt;Bigarray.Genarray.sub_right&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array2.sub_right&lt;/code&gt; applies only to arrays with Fortran layout.</source>
          <target state="translated">2 차원을 제한하여 주어진 2 차원 Bigarray의 2 차원 하위 ​​배열을 추출합니다. 자세한 내용은 &lt;a href=&quot;bigarray.genarray#VALsub_right&quot;&gt; &lt;code&gt;Bigarray.Genarray.sub_right&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. &lt;code&gt;Array2.sub_right&lt;/code&gt; 는 Fortran 레이아웃이있는 배열에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ad5026b7dc3bacdd43b7f246a7f6d355abdaa47" translate="yes" xml:space="preserve">
          <source>Extracting substrings</source>
          <target state="translated">부분 문자열 추출</target>
        </trans-unit>
        <trans-unit id="99b9db1548668247eee1e8880959fa3591e3a3f0" translate="yes" xml:space="preserve">
          <source>Extracts the user-friendly &lt;code&gt;backtrace_slot&lt;/code&gt; from a low-level &lt;code&gt;raw_backtrace_slot&lt;/code&gt;.</source>
          <target state="translated">낮은 수준의 &lt;code&gt;raw_backtrace_slot&lt;/code&gt; 에서 사용자 친화적 인 &lt;code&gt;backtrace_slot&lt;/code&gt; 을 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="9b227096d517556947fe5ddf19ad842bf0317b23" translate="yes" xml:space="preserve">
          <source>Facilities for printing exceptions and inspecting current call stack.</source>
          <target state="translated">예외를 인쇄하고 현재 호출 스택을 검사하는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="5ea25d08286e5c67d1bfdcc8c7290314f442be43" translate="yes" xml:space="preserve">
          <source>Fail if existing</source>
          <target state="translated">존재하는 경우 실패</target>
        </trans-unit>
        <trans-unit id="ecb4bd69a6ae63ba2585855d8e2360544daa005f" translate="yes" xml:space="preserve">
          <source>Fail if host name cannot be determined</source>
          <target state="translated">호스트 이름을 확인할 수없는 경우 실패</target>
        </trans-unit>
        <trans-unit id="49181351ef86b5c339057ac4b44372106d23409e" translate="yes" xml:space="preserve">
          <source>Fall back to building a statically linked library if a problem occurs while building the shared library (e.g. some of the support libraries are not available as shared libraries).</source>
          <target state="translated">공유 라이브러리를 빌드하는 동안 문제가 발생하면 정적으로 링크 된 라이브러리를 빌드하는 것으로 대체합니다 (예 : 일부 지원 라이브러리는 공유 라이브러리로 사용할 수 없음).</target>
        </trans-unit>
        <trans-unit id="7f914367bce8b82c6d2195d3b60d9769e3807c9c" translate="yes" xml:space="preserve">
          <source>Field(v, n) returns the value contained in the n&lt;sup&gt;th&lt;/sup&gt; field of the structured block v. Fields are numbered from 0 to Wosize_val(v)&amp;minus;1.</source>
          <target state="translated">Field (v, n)은 구조화 된 블록 v 의 n &lt;sup&gt;번째&lt;/sup&gt; 필드에 포함 된 값을 반환합니다 . 필드는 0에서 Wosize_val (v) -1까지 번호가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="1357f987d25405bca293332f1eeee71384be4553" translate="yes" xml:space="preserve">
          <source>File descriptor for standard error.</source>
          <target state="translated">표준 오류에 대한 파일 설명자입니다.</target>
        </trans-unit>
        <trans-unit id="77574dc3227cd0b3aba7be8d0ef544f784522a63" translate="yes" xml:space="preserve">
          <source>File descriptor for standard input.</source>
          <target state="translated">표준 입력을위한 파일 설명자.</target>
        </trans-unit>
        <trans-unit id="9e96c4faba360baae26988330ca973ca4d0050a8" translate="yes" xml:space="preserve">
          <source>File descriptor for standard output.</source>
          <target state="translated">표준 출력을위한 파일 설명자.</target>
        </trans-unit>
        <trans-unit id="e4abf36a5ea54ec41cce22ec0fe706639aba0b93" translate="yes" xml:space="preserve">
          <source>File exists</source>
          <target state="translated">파일이 존재</target>
        </trans-unit>
        <trans-unit id="af796a734908b2af6a033fc6dd399e38e2271966" translate="yes" xml:space="preserve">
          <source>File operations on large files</source>
          <target state="translated">대용량 파일에 대한 파일 작업</target>
        </trans-unit>
        <trans-unit id="c76015cd07e74ef92d5b2a92fce2d1e110d93be0" translate="yes" xml:space="preserve">
          <source>File operations on large files.</source>
          <target state="translated">대용량 파일에 대한 파일 작업.</target>
        </trans-unit>
        <trans-unit id="5216af1ac5b2e2dabbd11ec27979253222912a30" translate="yes" xml:space="preserve">
          <source>File operations on large files. This sub-module provides 64-bit variants of the functions &lt;a href=&quot;unix#VALlseek&quot;&gt;&lt;code&gt;Unix.lseek&lt;/code&gt;&lt;/a&gt; (for positioning a file descriptor), &lt;a href=&quot;unix#VALtruncate&quot;&gt;&lt;code&gt;Unix.truncate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unix#VALftruncate&quot;&gt;&lt;code&gt;Unix.ftruncate&lt;/code&gt;&lt;/a&gt; (for changing the size of a file), and &lt;a href=&quot;unix#VALstat&quot;&gt;&lt;code&gt;Unix.stat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unix#VALlstat&quot;&gt;&lt;code&gt;Unix.lstat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unix#VALfstat&quot;&gt;&lt;code&gt;Unix.fstat&lt;/code&gt;&lt;/a&gt; (for obtaining information on files). These alternate functions represent positions and sizes by 64-bit integers (type &lt;code&gt;int64&lt;/code&gt;) instead of regular integers (type &lt;code&gt;int&lt;/code&gt;), thus allowing operating on files whose sizes are greater than &lt;code&gt;max_int&lt;/code&gt;.</source>
          <target state="translated">대용량 파일에 대한 파일 작업. 이 하위 모듈은 &lt;a href=&quot;unix#VALlseek&quot;&gt; &lt;code&gt;Unix.lseek&lt;/code&gt; &lt;/a&gt; (파일 설명자 위치 지정 용), &lt;a href=&quot;unix#VALtruncate&quot;&gt; &lt;code&gt;Unix.truncate&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;unix#VALftruncate&quot;&gt; &lt;code&gt;Unix.ftruncate&lt;/code&gt; &lt;/a&gt; (파일 크기 변경 용), &lt;a href=&quot;unix#VALstat&quot;&gt; &lt;code&gt;Unix.stat&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;unix#VALlstat&quot;&gt; &lt;code&gt;Unix.lstat&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;unix#VALfstat&quot;&gt; &lt;code&gt;Unix.fstat&lt;/code&gt; &lt;/a&gt; 함수의 64 비트 변형을 제공합니다. .fstat (파일에 대한 정보를 얻기 위해). 이러한 대체 함수는 위치와 크기 를 일반 정수 ( &lt;code&gt;int&lt;/code&gt; 유형) 대신 64 비트 정수 ( &lt;code&gt;int64&lt;/code&gt; 유형 )로 &lt;code&gt;max_int&lt;/code&gt; 크기가 max_int 보다 큰 파일에서 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebe66056a71a2dfbc4eea74801f25159274efcb1" translate="yes" xml:space="preserve">
          <source>File operations on large files. This sub-module provides 64-bit variants of the functions &lt;a href=&quot;unixlabels#VALlseek&quot;&gt;&lt;code&gt;UnixLabels.lseek&lt;/code&gt;&lt;/a&gt; (for positioning a file descriptor), &lt;a href=&quot;unixlabels#VALtruncate&quot;&gt;&lt;code&gt;UnixLabels.truncate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unixlabels#VALftruncate&quot;&gt;&lt;code&gt;UnixLabels.ftruncate&lt;/code&gt;&lt;/a&gt; (for changing the size of a file), and &lt;a href=&quot;unixlabels#VALstat&quot;&gt;&lt;code&gt;UnixLabels.stat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unixlabels#VALlstat&quot;&gt;&lt;code&gt;UnixLabels.lstat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unixlabels#VALfstat&quot;&gt;&lt;code&gt;UnixLabels.fstat&lt;/code&gt;&lt;/a&gt; (for obtaining information on files). These alternate functions represent positions and sizes by 64-bit integers (type &lt;code&gt;int64&lt;/code&gt;) instead of regular integers (type &lt;code&gt;int&lt;/code&gt;), thus allowing operating on files whose sizes are greater than &lt;code&gt;max_int&lt;/code&gt;.</source>
          <target state="translated">대용량 파일에 대한 파일 작업. 이 서브 모듈은 64 비트의 기능 변형 제공 &lt;a href=&quot;unixlabels#VALlseek&quot;&gt; &lt;code&gt;UnixLabels.lseek&lt;/code&gt; &lt;/a&gt; (파일 기술자를 위치시키는) &lt;a href=&quot;unixlabels#VALtruncate&quot;&gt; &lt;code&gt;UnixLabels.truncate&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;unixlabels#VALftruncate&quot;&gt; &lt;code&gt;UnixLabels.ftruncate&lt;/code&gt; &lt;/a&gt; (파일의 사이즈를 변경) 및 &lt;a href=&quot;unixlabels#VALstat&quot;&gt; &lt;code&gt;UnixLabels.stat&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;unixlabels#VALlstat&quot;&gt; &lt;code&gt;UnixLabels.lstat&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;unixlabels#VALfstat&quot;&gt; &lt;code&gt;UnixLabels.fstat&lt;/code&gt; &lt;/a&gt; (파일에 대한 정보를 얻기 위해). 이러한 대체 함수는 위치와 크기 를 일반 정수 ( &lt;code&gt;int&lt;/code&gt; 유형) 대신 64 비트 정수 ( &lt;code&gt;int64&lt;/code&gt; 유형 )로 &lt;code&gt;max_int&lt;/code&gt; 크기가 max_int 보다 큰 파일에서 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fbef3ee3d6f5c033c6b0bfc9ab2581751e1aa6e" translate="yes" xml:space="preserve">
          <source>File permissions and ownership</source>
          <target state="translated">파일 권한 및 소유권</target>
        </trans-unit>
        <trans-unit id="28350cca828096efd67f5a171372164c14d8d2d6" translate="yes" xml:space="preserve">
          <source>File size limit exceeded</source>
          <target state="translated">파일 크기 제한 초과</target>
        </trans-unit>
        <trans-unit id="ce8eb49cc7bfa53c4610e26085f92f61b9a4f0a4" translate="yes" xml:space="preserve">
          <source>File size or position not representable</source>
          <target state="translated">표현할 수없는 파일 크기 또는 위치</target>
        </trans-unit>
        <trans-unit id="23d0dc8812f4ca4c291d107ca6848e74d92c16dd" translate="yes" xml:space="preserve">
          <source>File status</source>
          <target state="translated">파일 상태</target>
        </trans-unit>
        <trans-unit id="a0704a4eaa055ab08e3766911e446737f4f2a445" translate="yes" xml:space="preserve">
          <source>File too large</source>
          <target state="translated">파일이 너무 큽니다</target>
        </trans-unit>
        <trans-unit id="a3cbb98ddf5ee976bc1c3be5221d66ce3ca2e867" translate="yes" xml:space="preserve">
          <source>Filename</source>
          <target state="translated">Filename</target>
        </trans-unit>
        <trans-unit id="5ba8d30ffba45db4e2f3f220829fe902e2fd990f" translate="yes" xml:space="preserve">
          <source>Filename too long</source>
          <target state="translated">파일 이름이 너무 깁니다.</target>
        </trans-unit>
        <trans-unit id="81d0bcfe0109818a103380175b84cf616a760f08" translate="yes" xml:space="preserve">
          <source>Fill the &lt;code&gt;ai_canonname&lt;/code&gt; field of the result</source>
          <target state="translated">결과 의 &lt;code&gt;ai_canonname&lt;/code&gt; 필드를 채우십시오.</target>
        </trans-unit>
        <trans-unit id="8ecdaab3e6d2d606bd8449af095659f45138d642" translate="yes" xml:space="preserve">
          <source>Fill the given Bigarray with the given value.</source>
          <target state="translated">주어진 Bigarray를 주어진 값으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="6426f6cf359319ede0b204876e95f5ca2c6e0acd" translate="yes" xml:space="preserve">
          <source>Fill the given Bigarray with the given value. See &lt;a href=&quot;bigarray.genarray#VALfill&quot;&gt;&lt;code&gt;Bigarray.Genarray.fill&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">주어진 Bigarray를 주어진 값으로 채 웁니다. 자세한 내용은 &lt;a href=&quot;bigarray.genarray#VALfill&quot;&gt; &lt;code&gt;Bigarray.Genarray.fill&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a9fc75d6ebb6ea7b34fae8807788459e575487d7" translate="yes" xml:space="preserve">
          <source>Finally, a phrase can also consist in a toplevel directive, starting with # (the sharp sign). These directives control the behavior of the toplevel; they are listed below in section &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;.</source>
          <target state="translated">마지막으로 구는 # (예리한 기호)로 시작하는 최상위 지시문으로 구성 될 수도 있습니다. 이러한 지시문은 최상위 수준의 동작을 제어합니다. 아래 섹션 &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2에&lt;/a&gt; 나열되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f8b257b998bf370bb0864536531b33eb161b3e4" translate="yes" xml:space="preserve">
          <source>Finally, create a library containing all the compilation units, and export all the compiled interfaces.</source>
          <target state="translated">마지막으로 모든 컴파일 단위를 포함하는 라이브러리를 만들고 컴파일 된 모든 인터페이스를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="50d88cc7e5d915fe4d69c0be69de0f08fe1b0b62" translate="yes" xml:space="preserve">
          <source>Finally, if including the right headers is not enough, or if you need to support version older than OCaml 4.04, the header file caml/version.h should help you to define your own compatibility layer. This file provides few macros defining the current OCaml version. In particular, the OCAML_VERSION macro describes the current version, its format is MmmPP. For example, if you need some specific handling for versions older than 4.10.0, you could write</source>
          <target state="translated">마지막으로, 올바른 헤더를 포함하는 것으로 충분하지 않거나 OCaml 4.04 이전 버전을 지원해야하는 경우 헤더 파일 caml / version.h는 자신의 호환성 계층을 정의하는 데 도움이 될 것입니다. 이 파일은 현재 OCaml 버전을 정의하는 몇 가지 매크로를 제공합니다. 특히 OCAML_VERSION 매크로는 현재 버전을 설명하며 형식은 MmmPP입니다. 예를 들어 4.10.0 이전 버전에 대한 특정 처리가 필요한 경우 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9372cdb14bc15de60bc5e7493ee69b5c137db75b" translate="yes" xml:space="preserve">
          <source>Finally, we gather several versions of the account into a module Account abstracted over some currency.</source>
          <target state="translated">마지막으로 몇 가지 버전의 계정을 일부 통화로 추상화 된 모듈 계정으로 수집합니다.</target>
        </trans-unit>
        <trans-unit id="ad882b96aa31ea8bc7379f773276601fa589c285" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;group&lt;/code&gt; with the given group id, or raise &lt;code&gt;Not_found&lt;/code&gt; if the matching entry is not found.</source>
          <target state="translated">주어진 그룹 ID를 가진 &lt;code&gt;group&lt;/code&gt; 에서 항목을 찾 거나 일치하는 항목이 없으면 &lt;code&gt;Not_found&lt;/code&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="5d26059b49746e12250bbbdde11904eb0a2908b9" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;group&lt;/code&gt; with the given group id.</source>
          <target state="translated">주어진 그룹 ID를 가진 &lt;code&gt;group&lt;/code&gt; 에서 항목을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="415672a50455cf18e72d28b263ffd7e70776bbce" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;group&lt;/code&gt; with the given name, or raise &lt;code&gt;Not_found&lt;/code&gt; if the matching entry is not found.</source>
          <target state="translated">주어진 이름을 가진 &lt;code&gt;group&lt;/code&gt; 에서 항목을 찾 거나 일치하는 항목이 없으면 &lt;code&gt;Not_found&lt;/code&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="92938192f2f9c813f7a89a800c2c6c6ea821e47d" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;group&lt;/code&gt; with the given name.</source>
          <target state="translated">주어진 이름을 가진 &lt;code&gt;group&lt;/code&gt; 에서 항목을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="a0dce113945863d2224b0beb1e150e7180b7e955" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;hosts&lt;/code&gt; with the given address, or raise &lt;code&gt;Not_found&lt;/code&gt;.</source>
          <target state="translated">주어진 주소를 가진 &lt;code&gt;hosts&lt;/code&gt; 에서 항목을 찾 거나 &lt;code&gt;Not_found&lt;/code&gt; 를 올립니다 .</target>
        </trans-unit>
        <trans-unit id="30ddd89ef5b82ec68bbf502dfb947c7b9bd0e70b" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;hosts&lt;/code&gt; with the given address.</source>
          <target state="translated">주어진 주소를 가진 &lt;code&gt;hosts&lt;/code&gt; 에서 항목을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="81a3eb4a551ad19524b170ab21163001e6371bac" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;hosts&lt;/code&gt; with the given name, or raise &lt;code&gt;Not_found&lt;/code&gt;.</source>
          <target state="translated">주어진 이름을 가진 &lt;code&gt;hosts&lt;/code&gt; 에서 항목을 찾 거나 &lt;code&gt;Not_found&lt;/code&gt; 를 올립니다 .</target>
        </trans-unit>
        <trans-unit id="7b86d33490f4cae6fae2da0fe5ecd27bc2fc74df" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;hosts&lt;/code&gt; with the given name.</source>
          <target state="translated">주어진 이름을 가진 &lt;code&gt;hosts&lt;/code&gt; 에서 항목을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="6cc118e247a8d977a586a8aed063f755749a92c5" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;passwd&lt;/code&gt; with the given name, or raise &lt;code&gt;Not_found&lt;/code&gt; if the matching entry is not found.</source>
          <target state="translated">주어진 이름을 가진 &lt;code&gt;passwd&lt;/code&gt; 에서 항목을 찾 거나 일치하는 항목이 없으면 &lt;code&gt;Not_found&lt;/code&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="2239e5756daa56658451b2b6060633b9a9cbe318" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;passwd&lt;/code&gt; with the given name.</source>
          <target state="translated">주어진 이름을 가진 &lt;code&gt;passwd&lt;/code&gt; 에서 항목을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="c4956c4aaa9568df15a5e919f5fa7dbcb39bfe35" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;passwd&lt;/code&gt; with the given user id, or raise &lt;code&gt;Not_found&lt;/code&gt; if the matching entry is not found.</source>
          <target state="translated">주어진 사용자 ID 로 &lt;code&gt;passwd&lt;/code&gt; 에서 항목을 찾 거나 일치하는 항목이 없으면 &lt;code&gt;Not_found&lt;/code&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="dc1c8ede71044655837ceea95734b149dfdb1446" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;passwd&lt;/code&gt; with the given user id.</source>
          <target state="translated">주어진 사용자 ID 로 &lt;code&gt;passwd&lt;/code&gt; 에서 항목을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="2491f8eb89441b7ffa07d073b5e5195dba3665c0" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;protocols&lt;/code&gt; with the given name, or raise &lt;code&gt;Not_found&lt;/code&gt;.</source>
          <target state="translated">주어진 이름을 가진 &lt;code&gt;protocols&lt;/code&gt; 에서 항목을 찾 거나 &lt;code&gt;Not_found&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="325fdfe66274840cb9feff3f357702550e5e78f1" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;protocols&lt;/code&gt; with the given name.</source>
          <target state="translated">주어진 이름을 가진 &lt;code&gt;protocols&lt;/code&gt; 에서 항목을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="c7c982b244a847e041753c0f4d8e15cef7f19d9c" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;protocols&lt;/code&gt; with the given protocol number, or raise &lt;code&gt;Not_found&lt;/code&gt;.</source>
          <target state="translated">주어진 프로토콜 번호를 가진 &lt;code&gt;protocols&lt;/code&gt; 에서 항목을 찾 거나 &lt;code&gt;Not_found&lt;/code&gt; 를 올립니다 .</target>
        </trans-unit>
        <trans-unit id="47dd1860c6bae894b93ee4c1a2019df843e7ab0e" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;protocols&lt;/code&gt; with the given protocol number.</source>
          <target state="translated">주어진 프로토콜 번호를 가진 &lt;code&gt;protocols&lt;/code&gt; 에서 항목을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="aa44dc4c834bf5ab60c686285de2c6235d10c301" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;services&lt;/code&gt; with the given name, or raise &lt;code&gt;Not_found&lt;/code&gt;.</source>
          <target state="translated">주어진 이름을 가진 &lt;code&gt;services&lt;/code&gt; 에서 항목을 찾 거나 &lt;code&gt;Not_found&lt;/code&gt; 를 올립니다 .</target>
        </trans-unit>
        <trans-unit id="9d662695744400a189d48c36205ae8921c8e43f1" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;services&lt;/code&gt; with the given name.</source>
          <target state="translated">주어진 이름을 가진 &lt;code&gt;services&lt;/code&gt; 에서 항목을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="b9c773c60870eda8ae407ffce7a213a96aeb9ce7" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;services&lt;/code&gt; with the given service number, or raise &lt;code&gt;Not_found&lt;/code&gt;.</source>
          <target state="translated">주어진 서비스 번호를 가진 &lt;code&gt;services&lt;/code&gt; 에서 항목을 찾 거나 &lt;code&gt;Not_found&lt;/code&gt; 를 올립니다 .</target>
        </trans-unit>
        <trans-unit id="711cd41753b69e36be6081e673e29c9bba5549ef" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;services&lt;/code&gt; with the given service number.</source>
          <target state="translated">주어진 서비스 번호 로 &lt;code&gt;services&lt;/code&gt; 항목을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="224b0f27dd417f552000763b5bba3875baadfe82" translate="yes" xml:space="preserve">
          <source>First, types whose name starts with a $ are existentials.</source>
          <target state="translated">첫째, 이름이 $로 시작하는 유형은 실존 적입니다.</target>
        </trans-unit>
        <trans-unit id="de6dd7f2a65d07b376909c34498631be78cbdea7" translate="yes" xml:space="preserve">
          <source>First-class synchronous communication.</source>
          <target state="translated">일류 동기식 통신.</target>
        </trans-unit>
        <trans-unit id="1f6ff868642ca48eb4b81c33bcd5b9b519321189" translate="yes" xml:space="preserve">
          <source>First-in first-out queues.</source>
          <target state="translated">선입 선출 대기열.</target>
        </trans-unit>
        <trans-unit id="12c38d1674ad0209e2429c06f4b4d86c81433a53" translate="yes" xml:space="preserve">
          <source>Flags for &lt;a href=&quot;unix#VALwaitpid&quot;&gt;&lt;code&gt;Unix.waitpid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALwaitpid&quot;&gt; &lt;code&gt;Unix.waitpid&lt;/code&gt; 에&lt;/a&gt; 대한 플래그 .</target>
        </trans-unit>
        <trans-unit id="91c7e7cca135a02bd447cc6e7d8f0122b119c272" translate="yes" xml:space="preserve">
          <source>Flags for &lt;a href=&quot;unixlabels#VALwaitpid&quot;&gt;&lt;code&gt;UnixLabels.waitpid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALwaitpid&quot;&gt; &lt;code&gt;UnixLabels.waitpid&lt;/code&gt; 에&lt;/a&gt; 대한 플래그 .</target>
        </trans-unit>
        <trans-unit id="4a84fb5772adecead6ba93384fad981b2515026b" translate="yes" xml:space="preserve">
          <source>Flags for the &lt;a href=&quot;unix#VALaccess&quot;&gt;&lt;code&gt;Unix.access&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">&lt;a href=&quot;unix#VALaccess&quot;&gt; &lt;code&gt;Unix.access&lt;/code&gt; &lt;/a&gt; 호출에 대한 플래그입니다 .</target>
        </trans-unit>
        <trans-unit id="c04b5e36ad94721fdf773f89577544e40df649c7" translate="yes" xml:space="preserve">
          <source>Flags for the &lt;a href=&quot;unixlabels#VALaccess&quot;&gt;&lt;code&gt;UnixLabels.access&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALaccess&quot;&gt; &lt;code&gt;UnixLabels.access&lt;/code&gt; &lt;/a&gt; 호출에 대한 플래그입니다 .</target>
        </trans-unit>
        <trans-unit id="5fcd3d30dcc0ef0e2661f1baca5e3584ddbdad0c" translate="yes" xml:space="preserve">
          <source>Flambda aims to make it easier to write idiomatic OCaml code without incurring performance penalties.</source>
          <target state="translated">Flambda는 성능 저하없이 관용적 인 OCaml 코드를 더 쉽게 작성할 수 있도록하는 것을 목표로합니다.</target>
        </trans-unit>
        <trans-unit id="8594db97e2953372022ef97b5a0aa23e010af265" translate="yes" xml:space="preserve">
          <source>Flambda does not yet optimise array or string bounds checks. Neither does it take hints for optimisation from any assertions written by the user in the code.</source>
          <target state="translated">Flambda는 아직 배열 또는 문자열 경계 검사를 최적화하지 않습니다. 또한 코드에서 사용자가 작성한 어설 션에서 최적화를위한 힌트를받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f181cc9d2dc162d147e6a4c0a48c733ee687d31" translate="yes" xml:space="preserve">
          <source>Flambda operates in &lt;em&gt;rounds&lt;/em&gt;: one round consists of a certain sequence of transformations that may then be repeated in order to achieve more satisfactory results. The number of rounds can be set manually using the -rounds parameter (although this is not necessary when using predefined optimisation levels such as with -O2 and -O3). For high optimisation the number of rounds might be set at 3 or 4.</source>
          <target state="translated">Flambda가 동작한다 &lt;em&gt;발사&lt;/em&gt; : 일주 후 더 만족스러운 결과를 달성하기 위해 반복 될 수 변환의 특정 시퀀스로 구성된다. 라운드 수는 -rounds 매개 변수를 사용하여 수동으로 설정할 수 있습니다 (-O2 및 -O3와 같이 사전 정의 된 최적화 수준을 사용할 때는 필요하지 않음). 높은 최적화를 위해 라운드 수를 3 또는 4로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a5104c85ccca5769d7427f3784e8923de3f98aa" translate="yes" xml:space="preserve">
          <source>Flambda performs a simple analysis analogous to that performed elsewhere in the compiler that can transform refs into mutable variables that may then be held in registers (or on the stack as appropriate) rather than being allocated on the OCaml heap. This only happens so long as the reference concerned can be shown to not escape from its defining scope.</source>
          <target state="translated">Flambda는 참조를 가변 변수로 변환 할 수있는 컴파일러의 다른 곳에서 수행 된 것과 유사한 간단한 분석을 수행하여 OCaml 힙에 할당되지 않고 레지스터 (또는 적절한 경우 스택)에 보관할 수 있습니다. 이것은 관련 참조가 정의 범위에서 벗어나지 않는 것으로 표시 될 수있는 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="efb9d7aff651e52ca05571e619d1613ce6de9b63" translate="yes" xml:space="preserve">
          <source>Flambda provides full optimisation across different compilation units, so long as the .cmx files for the dependencies of the unit currently being compiled are available. (A compilation unit corresponds to a single .ml source file.) However it does not yet act entirely as a whole-program compiler: for example, elimination of dead code across a complete set of compilation units is not supported.</source>
          <target state="translated">Flambda는 현재 컴파일중인 단위의 종속성에 대한 .cmx 파일을 사용할 수있는 한 다양한 컴파일 단위에 대해 전체 최적화를 제공합니다. (컴파일 단위는 단일 .ml 소스 파일에 해당합니다.) 그러나 아직 전체 프로그램 컴파일러로 작동하지는 않습니다. 예를 들어 전체 컴파일 단위 집합에서 데드 코드를 제거하는 것은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a889b00bf27975324866ab0b134e19b27ed12786" translate="yes" xml:space="preserve">
          <source>Flambda provides significantly enhanced inlining capabilities relative to previous versions of the compiler.</source>
          <target state="translated">Flambda는 이전 버전의 컴파일러에 비해 크게 향상된 인라인 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="61063e2e8cd24e333286a73b0688eea6bacd5de4" translate="yes" xml:space="preserve">
          <source>Flambda should not in general affect the semantics of existing programs. Two exceptions to this rule are: possible elimination of pure code that is being benchmarked (see section &lt;a href=&quot;#s%3Aflambda-inhibition&quot;&gt;21.14&lt;/a&gt;) and changes in behaviour of code using unsafe operations (see section &lt;a href=&quot;#s%3Aflambda-unsafe&quot;&gt;21.15&lt;/a&gt;).</source>
          <target state="translated">Flambda는 일반적으로 기존 프로그램의 의미에 영향을주지 않아야합니다. 이 규칙에 대한 두 가지 예외는 벤치마킹중인 순수 코드 제거 (섹션 &lt;a href=&quot;#s%3Aflambda-inhibition&quot;&gt;21.14&lt;/a&gt; 참조 )와 안전하지 않은 작업을 사용한 코드 동작 변경 (섹션 &lt;a href=&quot;#s%3Aflambda-unsafe&quot;&gt;21.15&lt;/a&gt; 참조 )입니다.</target>
        </trans-unit>
        <trans-unit id="219d126ce0d3a407f2d7b93cc5f4b89615a19194" translate="yes" xml:space="preserve">
          <source>Flambda-specific flags are silently accepted even when the -flambda option was not provided to the configure script. (There is no means provided to change this behaviour.) This is intended to make it more straightforward to run benchmarks with and without the Flambda optimisers in effect.</source>
          <target state="translated">-flambda 옵션이 configure 스크립트에 제공되지 않은 경우에도 Flambda 관련 플래그가 자동으로 허용됩니다. (이 동작을 변경할 수있는 방법은 없습니다.) 이는 Flambda 옵티 마이저를 사용하거나 사용하지 않고 벤치 마크를보다 쉽게 ​​실행할 수 있도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="ef48c1926ca51bd2de8c60212500cb953953e6a1" translate="yes" xml:space="preserve">
          <source>Flambda-specific flags do not affect linking with the exception of affecting the optimisation of code in the startup file (containing generated functions such as currying helpers). Typically such optimisation will not be significant, so eliding such flags at link time might be reasonable.</source>
          <target state="translated">Flambda 관련 플래그는 시작 파일 (커링 도우미와 같은 생성 된 함수 포함)의 코드 최적화에 영향을주는 것을 제외하고는 연결에 영향을주지 않습니다. 일반적으로 이러한 최적화는 중요하지 않으므로 링크 타임에 이러한 플래그를 제거하는 것이 합리적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64435fd82de7b1d614dfb9844848a48b14c6cd2c" translate="yes" xml:space="preserve">
          <source>Float</source>
          <target state="translated">Float</target>
        </trans-unit>
        <trans-unit id="6ffeb4861d9e563d23963be8720e425492dd6b6d" translate="yes" xml:space="preserve">
          <source>Float arrays are unboxed in OCaml, however the C function foo expect its arguments as boxed floats and returns a boxed float. Hence the OCaml compiler has no choice but to box a.(i) and b.(i) and unbox the result of foo. This results in the allocation of 3 * len temporary float values.</source>
          <target state="translated">Float 배열은 OCaml에서 unboxed이지만 C 함수 foo는 인수를 boxed float로 예상하고 boxed float를 반환합니다. 따라서 OCaml 컴파일러는 a. (i) 및 b. (i)를 boxing하고 foo의 결과를 unbox하는 것 외에는 선택의 여지가 없습니다. 결과적으로 3 * len 임시 부동 값이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="1a46defc33b52ea1fd99787071741a560caaf453" translate="yes" xml:space="preserve">
          <source>Floating-point addition.</source>
          <target state="translated">부동 소수점 더하기.</target>
        </trans-unit>
        <trans-unit id="b0e8ad1ad83559c0c5808e64187ad5bb46bccbb8" translate="yes" xml:space="preserve">
          <source>Floating-point addition. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">부동 소수점 더하기. 왼쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="5548b469c373345d73eac57637c80c81b15b6bd5" translate="yes" xml:space="preserve">
          <source>Floating-point arithmetic</source>
          <target state="translated">부동 소수점 산술</target>
        </trans-unit>
        <trans-unit id="82bbccf62a08df179a146bbe466cb94a3dbaa8e5" translate="yes" xml:space="preserve">
          <source>Floating-point decimal literals consist in an integer part, a fractional part and an exponent part. The integer part is a sequence of one or more digits, optionally preceded by a minus sign. The fractional part is a decimal point followed by zero, one or more digits. The exponent part is the character e or E followed by an optional + or - sign, followed by one or more digits. It is interpreted as a power of 10. The fractional part or the exponent part can be omitted but not both, to avoid ambiguity with integer literals. The interpretation of floating-point literals that fall outside the range of representable floating-point values is undefined.</source>
          <target state="translated">부동 소수점 십진 리터럴은 정수 부분, 소수 부분 및 지수 부분으로 구성됩니다. 정수 부분은 선택적으로 마이너스 기호가 앞에 오는 하나 이상의 숫자 시퀀스입니다. 소수 부분은 소수점 뒤에 0, 하나 이상의 숫자가 나옵니다. 지수 부분은 문자 e 또는 E 다음에 선택적인 + 또는-기호와 하나 이상의 숫자가 오는 것입니다. 10의 거듭 제곱으로 해석됩니다. 정수 리터럴과의 모호함을 피하기 위해 소수 부분 또는 지수 부분을 생략 할 수 있지만 둘 다 생략 할 수는 없습니다. 표현 가능한 부동 소수점 값의 범위를 벗어나는 부동 소수점 리터럴의 해석은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="16456ba987f358b0776a485f82949a05fc38ee78" translate="yes" xml:space="preserve">
          <source>Floating-point division.</source>
          <target state="translated">부동 소수점 나누기.</target>
        </trans-unit>
        <trans-unit id="118ec0967c6c4699de4c4f7b7fda2a6e7b561167" translate="yes" xml:space="preserve">
          <source>Floating-point division. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">부동 소수점 나누기. 왼쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="ede89b6074416fcf7162abe3bb4236d8bee181aa" translate="yes" xml:space="preserve">
          <source>Floating-point exponentiation.</source>
          <target state="translated">부동 소수점 지수.</target>
        </trans-unit>
        <trans-unit id="0dc9d81781f770a9fc1d9a06be148d35f363d87c" translate="yes" xml:space="preserve">
          <source>Floating-point hexadecimal literals are denoted with the 0x or 0X prefix. The syntax is similar to that of floating-point decimal literals, with the following differences. The integer part and the fractional part use hexadecimal digits. The exponent part starts with the character p or P. It is written in decimal and interpreted as a power of 2.</source>
          <target state="translated">부동 소수점 16 진수 리터럴은 0x 또는 0X 접두사로 표시됩니다. 구문은 부동 소수점 십진 리터럴의 구문과 비슷하지만 다음과 같은 차이점이 있습니다. 정수 부분과 소수 부분은 16 진수를 사용합니다. 지수 부분은 문자 p 또는 P로 시작합니다. 십진수로 작성되고 2의 거듭 제곱으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="9e5d932dc924f91fa346a44f4dc03694cd49183a" translate="yes" xml:space="preserve">
          <source>Floating-point multiplication.</source>
          <target state="translated">부동 소수점 곱셈.</target>
        </trans-unit>
        <trans-unit id="b556a86592a9630ea4fbca18c7d08e9fc3c949d9" translate="yes" xml:space="preserve">
          <source>Floating-point multiplication. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">부동 소수점 곱셈. 왼쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="e1149ab45a20d6e882aa6782cb72e44b70e97f03" translate="yes" xml:space="preserve">
          <source>Floating-point negation.</source>
          <target state="translated">부동 소수점 부정.</target>
        </trans-unit>
        <trans-unit id="73f034cf9e5de13353e55867f163be1f87c7d920" translate="yes" xml:space="preserve">
          <source>Floating-point subtraction.</source>
          <target state="translated">부동 소수점 빼기.</target>
        </trans-unit>
        <trans-unit id="0d7e0c17deed8b8d3fb7e4c7f3f78d69fa0c9040" translate="yes" xml:space="preserve">
          <source>Floating-point subtraction. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">부동 소수점 빼기. 왼쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="df61acf8521b8784a6eac17abf66a88f13856f14" translate="yes" xml:space="preserve">
          <source>Floating-point values are numbers in floating-point representation. The current implementation uses double-precision floating-point numbers conforming to the IEEE 754 standard, with 53 bits of mantissa and an exponent ranging from &amp;minus;1022 to 1023.</source>
          <target state="translated">부동 소수점 값은 부동 소수점 표현의 숫자입니다. 현재 구현에서는 53 비트 가수와 -1022에서 1023까지의 지수를 사용하여 IEEE 754 표준을 준수하는 배정 밀도 부동 소수점 숫자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="85b4ec19158158ac7f6dbb77dc432e2d531582f9" translate="yes" xml:space="preserve">
          <source>Flush all open output channels; ignore errors.</source>
          <target state="translated">열려있는 모든 출력 채널을 플러시합니다. 오류를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="2b5f8a08a46ed12d56a1e210ad48361645fed373" translate="yes" xml:space="preserve">
          <source>Flush file buffers to disk.</source>
          <target state="translated">파일 버퍼를 디스크로 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="23c758f9a0907444c6837d8b7f0fb71eaee1124e" translate="yes" xml:space="preserve">
          <source>Flush standard output, then read characters from standard input until a newline character is encountered.</source>
          <target state="translated">표준 출력을 플러시 한 다음 개행 문자가 나타날 때까지 표준 입력에서 문자를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="e2f82045180a47247f213825886ff12b05d6ecc9" translate="yes" xml:space="preserve">
          <source>Flush standard output, then read characters from standard input until a newline character is encountered. Return the string of all characters read, without the newline character at the end.</source>
          <target state="translated">표준 출력을 플러시 한 다음 개행 문자가 나타날 때까지 표준 입력에서 문자를 읽습니다. 끝에 개행 문자없이 읽은 모든 문자의 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cbd185b6d4bbe3f64d1306999887965c95045eef" translate="yes" xml:space="preserve">
          <source>Flush standard output, then read one line from standard input and convert it to a floating-point number.</source>
          <target state="translated">표준 출력을 플러시 한 다음 표준 입력에서 한 줄을 읽고 부동 소수점 숫자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="72f1a6e603eff2a865514ec6cd7588b58a57b5c3" translate="yes" xml:space="preserve">
          <source>Flush standard output, then read one line from standard input and convert it to an integer.</source>
          <target state="translated">표준 출력을 플러시 한 다음 표준 입력에서 한 줄을 읽고이를 정수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="560c3ecff79a18ab3e691bb4c8af82a10b26ee5d" translate="yes" xml:space="preserve">
          <source>Flush the buffer associated with the given output channel, performing all pending writes on that channel.</source>
          <target state="translated">지정된 출력 채널과 관련된 버퍼를 플러시하여 해당 채널에서 보류중인 모든 쓰기를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8b26c6acfdd5ca2fd64e7704f6ddb8ef3f40e2eb" translate="yes" xml:space="preserve">
          <source>Flush the buffer associated with the given output channel, performing all pending writes on that channel. Interactive programs must be careful about flushing standard output and standard error at the right time.</source>
          <target state="translated">지정된 출력 채널과 관련된 버퍼를 플러시하여 해당 채널에서 보류중인 모든 쓰기를 수행합니다. 대화 형 프로그램은 적시에 표준 출력 및 표준 오류를 플러시하는 데주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="becd01c004b1c1adc714fa5f5a61b400195543a6" translate="yes" xml:space="preserve">
          <source>Following a function application:</source>
          <target state="translated">기능 응용 프로그램에 따라 :</target>
        </trans-unit>
        <trans-unit id="1486f893b1fa18a37d5aac444c9bb86be10dc16e" translate="yes" xml:space="preserve">
          <source>Following the &lt;code&gt;%&lt;/code&gt; character that introduces a conversion, there may be the special flag &lt;code&gt;_&lt;/code&gt;: the conversion that follows occurs as usual, but the resulting value is discarded. For instance, if &lt;code&gt;f&lt;/code&gt; is the function &lt;code&gt;fun&amp;nbsp;i&amp;nbsp;-&amp;gt;&amp;nbsp;i&amp;nbsp;+&amp;nbsp;1&lt;/code&gt;, and &lt;code&gt;s&lt;/code&gt; is the string &lt;code&gt;&quot;x&amp;nbsp;=&amp;nbsp;1&quot;&lt;/code&gt;, then &lt;code&gt;Scanf.sscanf&amp;nbsp;s&amp;nbsp;&quot;%_s&amp;nbsp;=&amp;nbsp;%i&quot;&amp;nbsp;f&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">변환을 도입하는 &lt;code&gt;%&lt;/code&gt; 문자 뒤에 특수 플래그 &lt;code&gt;_&lt;/code&gt; 가있을 수 있습니다. 다음과 같은 변환은 평소와 같이 발생하지만 결과 값은 삭제됩니다. 예를 들어, &lt;code&gt;f&lt;/code&gt; 가 &lt;code&gt;fun&amp;nbsp;i&amp;nbsp;-&amp;gt;&amp;nbsp;i&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; 함수 이고 &lt;code&gt;s&lt;/code&gt; 가 문자열 &lt;code&gt;&quot;x&amp;nbsp;=&amp;nbsp;1&quot;&lt;/code&gt; 이면 &lt;code&gt;Scanf.sscanf&amp;nbsp;s&amp;nbsp;&quot;%_s&amp;nbsp;=&amp;nbsp;%i&quot;&amp;nbsp;f&lt;/code&gt; 는 &lt;code&gt;2&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a590e523ffcfaed89183301d6dd22ee5be58604e" translate="yes" xml:space="preserve">
          <source>For a gentle introduction to the basics of pretty-printing using &lt;code&gt;Format&lt;/code&gt;, read &lt;a href=&quot;http://caml.inria.fr/resources/doc/guides/format.en.html&quot;&gt; http://caml.inria.fr/resources/doc/guides/format.en.html&lt;/a&gt;.</source>
          <target state="translated">사용 꽤 - 인쇄의 기본에 부드러운 소개는 &lt;code&gt;Format&lt;/code&gt; 읽고 &lt;a href=&quot;http://caml.inria.fr/resources/doc/guides/format.en.html&quot;&gt;http://caml.inria.fr/resources/doc/guides/format.en.html을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c9fce93886551abb9ce788db94f91b9982821506" translate="yes" xml:space="preserve">
          <source>For a program with an extended running time where the collection of only a small sample of events is required, using the &lt;em&gt;eventlog_resume&lt;/em&gt; and &lt;em&gt;eventlog_pause&lt;/em&gt; primitives may help relieve some of the tracing induced performance impact.</source>
          <target state="translated">작은 이벤트 샘플 만 수집해야하는 확장 된 실행 시간이있는 프로그램의 경우 &lt;em&gt;eventlog_resume&lt;/em&gt; 및 &lt;em&gt;eventlog_pause&lt;/em&gt; 프리미티브를 사용하면 추적으로 인한 성능 영향을 완화하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d15720a480acc3d4e8c66981b163dda12c3ec8be" translate="yes" xml:space="preserve">
          <source>For compatibility with previous releases, ocamlcp also accepts the -p option, with the same arguments and behaviour as -P.</source>
          <target state="translated">이전 릴리스와의 호환성을 위해 ocamlcp는 -P와 동일한 인수 및 동작으로 -p 옵션도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="d87cc1fd5174e33b97151dfeeb14c60cfa60df82" translate="yes" xml:space="preserve">
          <source>For compatibility with toplevel phrases (chapter &lt;a href=&quot;toplevel#c%3Acamllight&quot;&gt;10&lt;/a&gt;), optional ;; are allowed after and before each definition in a structure. These ;; have no semantic meanings. Similarly, an &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; preceded by ;; is allowed as a component of a structure. It is equivalent to let_=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;, i.e. &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; is evaluated for its side-effects but is not bound to any identifier. If &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; is the first component of a structure, the preceding ;; can be omitted.</source>
          <target state="translated">최상위 구문 ( &lt;a href=&quot;toplevel#c%3Acamllight&quot;&gt;10&lt;/a&gt; 장 ) 과의 호환성을 위해 선택 사항 ;; 구조의 각 정의 전후에 허용됩니다. 이것들 ;; 의미 론적 의미가 없습니다. 마찬가지로, &lt;a href=&quot;expr#expr&quot;&gt;만약 expr은&lt;/a&gt; 선행; 구조의 구성 요소로 허용됩니다. let_ = &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; 과 동일합니다 . 즉, &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; 은 부작용에 대해 평가되지만 식별자에 바인딩되지 않습니다. 경우 &lt;a href=&quot;expr#expr&quot;&gt;expr이&lt;/a&gt; 구조의 제 성분 인 선행; 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d5a74d2294717e9f00b62a89200b1ae35d6a075" translate="yes" xml:space="preserve">
          <source>For convenicence, when all arguments and the result are annotated with [@unboxed], it is possible to put the attribute only once on the declaration itself. So we can also write instead:</source>
          <target state="translated">편의상 모든 인수와 결과에 [@unboxed] 주석을 달면 선언 자체에 속성을 한 번만 넣을 수 있습니다. 따라서 대신 다음과 같이 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="536cfe27f79288497ed369a6675bd6604800b397" translate="yes" xml:space="preserve">
          <source>For convenience and readability, underscore characters (_) are accepted (and ignored) within floating-point literals.</source>
          <target state="translated">편의성과 가독성을 위해 부동 소수점 리터럴 내에서 밑줄 문자 (_)가 허용되고 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="be43f583e22841e0ae2a3b643c27e327a6714b66" translate="yes" xml:space="preserve">
          <source>For convenience and readability, underscore characters (_) are accepted (and ignored) within integer literals.</source>
          <target state="translated">편의성과 가독성을 위해 정수 리터럴 내에서 밑줄 문자 (_)가 허용되고 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="838d471f3710333420afe459f6352b41b3ee184b" translate="yes" xml:space="preserve">
          <source>For directives that take file names as arguments, if the given file name specifies no directory, the file is searched in the following directories:</source>
          <target state="translated">파일 이름을 인수로 사용하는 지시문의 경우 지정된 파일 이름이 디렉토리를 지정하지 않으면 파일은 다음 디렉토리에서 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="93af2f267be6958b0eb68cd4c18a340833d38fe2" translate="yes" xml:space="preserve">
          <source>For easy reference, the modules are listed below in alphabetical order of module names. For each module, the declarations from its signature are printed one by one in typewriter font, followed by a short comment. All modules and the identifiers they export are indexed at the end of this report.</source>
          <target state="translated">쉽게 참조 할 수 있도록 모듈은 모듈 이름의 알파벳 순서로 아래에 나열되어 있습니다. 각 모듈에 대해 서명의 선언이 타자기 글꼴로 하나씩 인쇄되고 그 뒤에 짧은 주석이 표시됩니다. 내보내는 모든 모듈과 식별자는이 보고서의 끝에 색인이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="68c41afc8eaf8ac4f5e1db0cdcc821f1a67ead25" translate="yes" xml:space="preserve">
          <source>For example given the following code:</source>
          <target state="translated">예를 들어 다음 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들면</target>
        </trans-unit>
        <trans-unit id="87c9f97659bbc1005f4870ae62bce8f4807d2d04" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;find_first&amp;nbsp;(fun&amp;nbsp;e&amp;nbsp;-&amp;gt;&amp;nbsp;Ord.compare&amp;nbsp;e&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0)&amp;nbsp;s&lt;/code&gt; will return the first element &lt;code&gt;e&lt;/code&gt; of &lt;code&gt;s&lt;/code&gt; where &lt;code&gt;Ord.compare&amp;nbsp;e&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; (intuitively: &lt;code&gt;e&amp;nbsp;&amp;gt;=&amp;nbsp;x&lt;/code&gt;), or raise &lt;code&gt;Not_found&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is greater than any element of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;find_first&amp;nbsp;(fun&amp;nbsp;e&amp;nbsp;-&amp;gt;&amp;nbsp;Ord.compare&amp;nbsp;e&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0)&amp;nbsp;s&lt;/code&gt; 제 1 엘리먼트 리턴 &lt;code&gt;e&lt;/code&gt; 의 &lt;code&gt;s&lt;/code&gt; 어디에 &lt;code&gt;Ord.compare&amp;nbsp;e&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; (직관적 : &lt;code&gt;e&amp;nbsp;&amp;gt;=&amp;nbsp;x&lt;/code&gt; ), 또는 인상 &lt;code&gt;Not_found&lt;/code&gt; 만약 &lt;code&gt;x&lt;/code&gt; 가 큰 인 &lt;code&gt;s&lt;/code&gt; 의 어떤 요소보다 .</target>
        </trans-unit>
        <trans-unit id="00ef4fa9fc5360d62b1c94aa516c65ad36494ff8" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;find_first&amp;nbsp;(fun&amp;nbsp;k&amp;nbsp;-&amp;gt;&amp;nbsp;Ord.compare&amp;nbsp;k&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0)&amp;nbsp;m&lt;/code&gt; will return the first binding &lt;code&gt;k,&amp;nbsp;v&lt;/code&gt; of &lt;code&gt;m&lt;/code&gt; where &lt;code&gt;Ord.compare&amp;nbsp;k&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; (intuitively: &lt;code&gt;k&amp;nbsp;&amp;gt;=&amp;nbsp;x&lt;/code&gt;), or raise &lt;code&gt;Not_found&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is greater than any element of &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;find_first&amp;nbsp;(fun&amp;nbsp;k&amp;nbsp;-&amp;gt;&amp;nbsp;Ord.compare&amp;nbsp;k&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0)&amp;nbsp;m&lt;/code&gt; 은 첫 번째 바인딩 &lt;code&gt;k,&amp;nbsp;v&lt;/code&gt; of &lt;code&gt;m&lt;/code&gt; 을 반환합니다. 여기서 &lt;code&gt;Ord.compare&amp;nbsp;k&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; (직관적으로 : &lt;code&gt;k&amp;nbsp;&amp;gt;=&amp;nbsp;x&lt;/code&gt; ) 또는 &lt;code&gt;x&lt;/code&gt; 인 경우 &lt;code&gt;Not_found&lt;/code&gt; 를 올립니다. &lt;code&gt;m&lt;/code&gt; 의 어떤 요소보다 큽니다 .</target>
        </trans-unit>
        <trans-unit id="aa7ea3a77b2622ee6a146e8cc0a886c6052f7d06" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;unfold&amp;nbsp;(function&amp;nbsp;[]&amp;nbsp;-&amp;gt;&amp;nbsp;None&amp;nbsp;|&amp;nbsp;h::t&amp;nbsp;-&amp;gt;&amp;nbsp;Some&amp;nbsp;(h,t))&amp;nbsp;l&lt;/code&gt; is equivalent to &lt;code&gt;List.to_seq&amp;nbsp;l&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;unfold&amp;nbsp;(function&amp;nbsp;[]&amp;nbsp;-&amp;gt;&amp;nbsp;None&amp;nbsp;|&amp;nbsp;h::t&amp;nbsp;-&amp;gt;&amp;nbsp;Some&amp;nbsp;(h,t))&amp;nbsp;l&lt;/code&gt; 은 &lt;code&gt;List.to_seq&amp;nbsp;l&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8681ad0bc326c2d10abfd81e1d8d51f3f545e5ec" translate="yes" xml:space="preserve">
          <source>For example, on a 32-bit machine, under bash the command</source>
          <target state="translated">예를 들어, 32 비트 시스템의 경우 bash에서 다음 명령을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="584aecfa53603994f1cf6a98815016088d92742e" translate="yes" xml:space="preserve">
          <source>For example, string literals are implicitly shared by the compiler, so you never uniquely own them.</source>
          <target state="translated">예를 들어, 문자열 리터럴은 컴파일러에 의해 암시 적으로 공유되므로 고유하게 소유 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="75ec36932e874a0857807a9a9cf34d66fdff1115" translate="yes" xml:space="preserve">
          <source>For example, the following function on maps whose values are lists</source>
          <target state="translated">예를 들어, 값이 목록 인지도의 다음 함수는</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="e07ee358d5cb6c26c5c1a633d2d3ce795afcd785" translate="yes" xml:space="preserve">
          <source>For experts only: &lt;code&gt;set_field&lt;/code&gt; et al can be made safe by first wrapping the block in &lt;a href=&quot;sys#VALopaque_identity&quot;&gt;&lt;code&gt;Sys.opaque_identity&lt;/code&gt;&lt;/a&gt;, so any information about its contents will not be propagated.</source>
          <target state="translated">전문가 전용 : 먼저 &lt;a href=&quot;sys#VALopaque_identity&quot;&gt; &lt;code&gt;Sys.opaque_identity&lt;/code&gt; &lt;/a&gt; 에서 블록을 래핑하여 &lt;code&gt;set_field&lt;/code&gt; 등을 안전하게 만들 수 있으므로 해당 내용에 대한 정보가 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f54deaf4ec2c70a7011f50eff9d2285fdad7e767" translate="yes" xml:space="preserve">
          <source>For functions to decode the information recorded by the profiler, see the Spacetime offline library in otherlibs/.</source>
          <target state="translated">프로파일 러가 기록한 정보를 디코딩하는 함수는 otherlibs /의 Spacetime 오프라인 라이브러리를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="070398a78bcfebe5c401a9687fd0dd0a09274ac7" translate="yes" xml:space="preserve">
          <source>For instance let&amp;rsquo;s consider this example:</source>
          <target state="translated">예를 들어 다음 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="3ec0bc79713c604935cc8be72edeaf053af246af" translate="yes" xml:space="preserve">
          <source>For instance, &lt;code&gt;(float,&amp;nbsp;float32_elt,&amp;nbsp;fortran_layout)&amp;nbsp;Genarray.t&lt;/code&gt; is the type of generic Bigarrays containing 32-bit floats in Fortran layout; reads and writes in this array use the OCaml type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;(float,&amp;nbsp;float32_elt,&amp;nbsp;fortran_layout)&amp;nbsp;Genarray.t&lt;/code&gt; 는 Fortran 레이아웃에 32 비트 부동 소수점을 포함하는 일반 Bigarray 유형입니다. 이 배열에서 읽고 쓰기는 OCaml 유형 &lt;code&gt;float&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="483a4414986412b8b6120205236d6d13002c06a3" translate="yes" xml:space="preserve">
          <source>For instance, &lt;code&gt;Genarray.create&amp;nbsp;int32&amp;nbsp;c_layout&amp;nbsp;[|4;6;8|]&lt;/code&gt; returns a fresh Bigarray of 32-bit integers, in C layout, having three dimensions, the three dimensions being 4, 6 and 8 respectively.</source>
          <target state="translated">예를 들어 &lt;code&gt;Genarray.create&amp;nbsp;int32&amp;nbsp;c_layout&amp;nbsp;[|4;6;8|]&lt;/code&gt; 은 C 레이아웃에서 3 차원을 갖는 32 비트 정수의 새로운 Bigarray를 반환합니다. 3 차원은 각각 4, 6 및 8입니다.</target>
        </trans-unit>
        <trans-unit id="53f092886c491eb1e8ce0e4ca3d4d961ae0d2d09" translate="yes" xml:space="preserve">
          <source>For instance, a module can be constrained when opened with</source>
          <target state="translated">예를 들어, 모듈은 다음으로 열 때 제한 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0f95c0ca2f0669635f59d67f76dce1ba345c8a8" translate="yes" xml:space="preserve">
          <source>For instance, compiling with ocamlcp -P film profiles function calls, if&amp;hellip;then&amp;hellip;else&amp;hellip;, loops and pattern matching.</source>
          <target state="translated">예를 들어, ocamlcp -P 필름 프로파일 함수를 사용하여 컴파일하면 if&amp;hellip; then&amp;hellip; else&amp;hellip;, 루프 및 패턴 일치가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="62237974c29e3d511bf080a9b8f7425ffcc10235" translate="yes" xml:space="preserve">
          <source>For instance, given a &lt;a href=&quot;buffer#TYPEt&quot;&gt;&lt;code&gt;Buffer.t&lt;/code&gt;&lt;/a&gt; buffer &lt;code&gt;b&lt;/code&gt;, &lt;a href=&quot;format#VALformatter_of_buffer&quot;&gt;&lt;code&gt;Format.formatter_of_buffer&lt;/code&gt;&lt;/a&gt;&lt;code&gt;b&lt;/code&gt; returns a new formatter using buffer &lt;code&gt;b&lt;/code&gt; as its output device. Similarly, given a &lt;a href=&quot;stdlib#TYPEout_channel&quot;&gt;&lt;code&gt;out_channel&lt;/code&gt;&lt;/a&gt; output channel &lt;code&gt;oc&lt;/code&gt;, &lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt;&lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt;&lt;/a&gt;&lt;code&gt;oc&lt;/code&gt; returns a new formatter using channel &lt;code&gt;oc&lt;/code&gt; as its output device.</source>
          <target state="translated">예를 들어, 주어진 &lt;a href=&quot;buffer#TYPEt&quot;&gt; &lt;code&gt;Buffer.t&lt;/code&gt; 용&lt;/a&gt; 버퍼 &lt;code&gt;b&lt;/code&gt; , &lt;a href=&quot;format#VALformatter_of_buffer&quot;&gt; &lt;code&gt;Format.formatter_of_buffer&lt;/code&gt; &lt;/a&gt; &lt;code&gt;b&lt;/code&gt; 리턴 버퍼 이용한 새로운 포맷 &lt;code&gt;b&lt;/code&gt; 출력 장치로한다. 유사하게, 주어진 &lt;a href=&quot;stdlib#TYPEout_channel&quot;&gt; &lt;code&gt;out_channel&lt;/code&gt; 의&lt;/a&gt; 출력 채널 &lt;code&gt;oc&lt;/code&gt; , &lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt; &lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt; 의&lt;/a&gt; &lt;code&gt;oc&lt;/code&gt; 채널 사용 새로운 포매터 반환 &lt;code&gt;oc&lt;/code&gt; 출력 장치로한다.</target>
        </trans-unit>
        <trans-unit id="41e374315bd8271c505be4e5174fd509da4383f5" translate="yes" xml:space="preserve">
          <source>For instance, if &lt;code&gt;f&lt;/code&gt; is the function &lt;code&gt;fun&amp;nbsp;s&amp;nbsp;i&amp;nbsp;-&amp;gt;&amp;nbsp;i&amp;nbsp;+&amp;nbsp;1&lt;/code&gt;, then &lt;code&gt;Scanf.sscanf&amp;nbsp;&quot;x=&amp;nbsp;1&quot;&amp;nbsp;&quot;%s&amp;nbsp;=&amp;nbsp;%i&quot;&amp;nbsp;f&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;f&lt;/code&gt; 가 &lt;code&gt;fun&amp;nbsp;s&amp;nbsp;i&amp;nbsp;-&amp;gt;&amp;nbsp;i&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; 함수 이면 &lt;code&gt;Scanf.sscanf&amp;nbsp;&quot;x=&amp;nbsp;1&quot;&amp;nbsp;&quot;%s&amp;nbsp;=&amp;nbsp;%i&quot;&amp;nbsp;f&lt;/code&gt; 는 &lt;code&gt;2&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="88ada3238f384f9a83a9a0095d4afa6a65d12f78" translate="yes" xml:space="preserve">
          <source>For instance, if the module type name S is bound to the signature</source>
          <target state="translated">예를 들어, 모듈 유형 이름 S가 서명에 바인딩 된 경우</target>
        </trans-unit>
        <trans-unit id="313fce915b91c1b76f4ab6d75d2a8fd584e24576" translate="yes" xml:space="preserve">
          <source>For instance, if you are allocating a finalized block holding an X Windows bitmap of w by h pixels, and you&amp;rsquo;d rather not have more than 1 mega-pixels of unreclaimed bitmaps, specify used = w * h and max = 1000000.</source>
          <target state="translated">예를 들어 w x h 픽셀의 X Windows 비트 맵을 포함하는 최종 블록을 할당하고 재생되지 않은 비트 맵의 ​​1 메가 픽셀을 초과하지 않으려면 used = w * h 및 max = 1000000을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="aa39538e599aa28212b48c635f444fbb356477cb" translate="yes" xml:space="preserve">
          <source>For instance, in ('a' as x) | ( 'a' (_ as x) ) the variable x is of type char, whereas in (&quot;ab&quot; as x) | ( 'a' (_ as x) ? ) the variable x is of type string option.</source>
          <target state="translated">예를 들어, in ( 'a'as x) | ( 'a'(_ as x)) 변수 x는 char 유형이지만 in ( &quot;ab&quot;as x) | ( 'a'(_ as x)?) 변수 x는 문자열 옵션 유형입니다.</target>
        </trans-unit>
        <trans-unit id="2c8e2bf323177696f201e4d65a89fe9a6376e58c" translate="yes" xml:space="preserve">
          <source>For instance, in the case of add_nat, the declaration is:</source>
          <target state="translated">예를 들어 add_nat의 경우 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30e031fb5cea37ca6a741ad15e3c21518c5b98ed" translate="yes" xml:space="preserve">
          <source>For instance, one might want to specialize a table for integer keys:</source>
          <target state="translated">예를 들어 정수 키에 대한 테이블을 전문화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec3b52fde3e16586ca37ede9c046fc9f0a2cf0ce" translate="yes" xml:space="preserve">
          <source>For instance, rather than redefining caml_young_limit:</source>
          <target state="translated">예를 들어, caml_young_limit를 재정의하는 대신 :</target>
        </trans-unit>
        <trans-unit id="b2c4a72ef20876d65a567d804865d99313488768" translate="yes" xml:space="preserve">
          <source>For instance, the &lt;a href=&quot;scanf#VALscanf&quot;&gt;&lt;code&gt;Scanf.scanf&lt;/code&gt;&lt;/a&gt; function below has type &lt;code&gt;('a,&amp;nbsp;'b,&amp;nbsp;'c,&amp;nbsp;'d)&amp;nbsp;scanner&lt;/code&gt;, since it is a formatted input function that reads from &lt;a href=&quot;scanf.scanning#VALstdin&quot;&gt;&lt;code&gt;Scanf.Scanning.stdin&lt;/code&gt;&lt;/a&gt;: &lt;code&gt;scanf&amp;nbsp;fmt&amp;nbsp;f&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; to the arguments specified by &lt;code&gt;fmt&lt;/code&gt;, reading those arguments from &lt;a href=&quot;stdlib#VALstdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; as expected.</source>
          <target state="translated">예를 들어, 아래 의 &lt;a href=&quot;scanf#VALscanf&quot;&gt; &lt;code&gt;Scanf.scanf&lt;/code&gt; &lt;/a&gt; 함수는 &lt;code&gt;('a,&amp;nbsp;'b,&amp;nbsp;'c,&amp;nbsp;'d)&amp;nbsp;scanner&lt;/code&gt; &lt;a href=&quot;scanf.scanning#VALstdin&quot;&gt; &lt;code&gt;Scanf.Scanning.stdin&lt;/code&gt; &lt;/a&gt; . Scanf.Scanning.stdin 에서 읽는 형식화 된 입력 함수이기 때문입니다 . &lt;code&gt;scanf&amp;nbsp;fmt&amp;nbsp;f&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 를 인수에 적용 합니다. &lt;code&gt;fmt&lt;/code&gt; 로 지정되며 예상대로 &lt;a href=&quot;stdlib#VALstdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; 에서 해당 인수를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="d79fda01c9ead474ffcd0f48c1cb8618d654db68" translate="yes" xml:space="preserve">
          <source>For instance, the sequence &lt;code&gt;open_box&amp;nbsp;0;&amp;nbsp;print_string&amp;nbsp;&quot;x&amp;nbsp;=&quot;;&amp;nbsp;print_space&amp;nbsp;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print_int&amp;nbsp;1;&amp;nbsp;close_box&amp;nbsp;();&amp;nbsp;print_newline&amp;nbsp;()&lt;/code&gt; that prints &lt;code&gt;x&amp;nbsp;=&amp;nbsp;1&lt;/code&gt; within a pretty-printing box, can be abbreviated as &lt;code&gt;printf&amp;nbsp;&quot;@[%s@&amp;nbsp;%i@]@.&quot;&amp;nbsp;&quot;x&amp;nbsp;=&quot;&amp;nbsp;1&lt;/code&gt;, or even shorter &lt;code&gt;printf&amp;nbsp;&quot;@[x&amp;nbsp;=@&amp;nbsp;%i@]@.&quot;&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 시퀀스 &lt;code&gt;open_box&amp;nbsp;0;&amp;nbsp;print_string&amp;nbsp;&quot;x&amp;nbsp;=&quot;;&amp;nbsp;print_space&amp;nbsp;();&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print_int&amp;nbsp;1;&amp;nbsp;close_box&amp;nbsp;();&amp;nbsp;print_newline&amp;nbsp;()&lt;/code&gt; 예쁜 인쇄 상자 안에 &lt;code&gt;x&amp;nbsp;=&amp;nbsp;1&lt;/code&gt; 을 인쇄하는 print_newline () 은 &lt;code&gt;printf&amp;nbsp;&quot;@[%s@&amp;nbsp;%i@]@.&quot;&amp;nbsp;&quot;x&amp;nbsp;=&quot;&amp;nbsp;1&lt;/code&gt; 로 축약 할 수 있습니다 . &quot;x =&quot;1 , 또는 더 짧은 &lt;code&gt;printf&amp;nbsp;&quot;@[x&amp;nbsp;=@&amp;nbsp;%i@]@.&quot;&amp;nbsp;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="512b11c86beb8f337cea3cd6a56846b5135a314c" translate="yes" xml:space="preserve">
          <source>For instance, type +'a t declares t as an abstract type that is covariant in its parameter; this means that if the type &amp;tau; is a subtype of the type &amp;sigma;, then &amp;tau;  t is a subtype of &amp;sigma;  t. Similarly, type -'a t declares that the abstract type t is contravariant in its parameter: if &amp;tau; is a subtype of &amp;sigma;, then &amp;sigma;  t is a subtype of &amp;tau;  t. If no + or - variance annotation is given, the type constructor is assumed non-variant in the corresponding parameter. For instance, the abstract type declaration type 'a t means that &amp;tau;  t is neither a subtype nor a supertype of &amp;sigma;  t if &amp;tau; is subtype of &amp;sigma;.</source>
          <target state="translated">예를 들어, 유형 + 'at는 t를 매개 변수에서 공변하는 추상 유형으로 선언합니다. 즉, 유형 &amp;tau;가 유형 &amp;sigma;의 하위 유형이면 &amp;tau; t는 &amp;sigma; t의 하위 유형입니다. 유사하게, type -'at는 그 매개 변수에서 추상 유형 t가 반 변성임을 선언합니다. &amp;tau;가 &amp;sigma;의 하위 유형이면 &amp;sigma; t는 &amp;tau; t의 하위 유형입니다. + 또는-분산 주석이 제공되지 않으면 유형 생성자는 해당 매개 변수에서 비 변형으로 간주됩니다. 예를 들어, 추상 유형 선언 유형 'at는 &amp;tau;가 &amp;sigma;의 하위 유형 인 경우 &amp;tau; t가 하위 유형도 아니고 &amp;sigma; t의 상위 유형도 아님을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2f9a2d4de3a321ed1ced899fb52be83e582b336c" translate="yes" xml:space="preserve">
          <source>For instance, you can use {%sql|...|} to represent arbitrary SQL statements &amp;ndash; assuming you have a ppx-rewriter that recognizes the %sql extension.</source>
          <target state="translated">예를 들어, % sql 확장을 인식하는 ppx-rewriter가 있다고 가정하면 {% sql | ... |}을 사용하여 임의의 SQL 문을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="f06f4a1629e356fbed3dca17ffbbc00b47ee8f6a" translate="yes" xml:space="preserve">
          <source>For interactive use of the bigarray compatibility library, do:</source>
          <target state="translated">bigarray 호환성 라이브러리를 대화식으로 사용하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0f35fd96a6a5a2ac581557d5abe5d3d602ccdd36" translate="yes" xml:space="preserve">
          <source>For interactive use of the compiler-libs library, start ocaml and type</source>
          <target state="translated">compiler-libs 라이브러리를 대화식으로 사용하려면 ocaml을 시작하고 다음을 입력합니다.</target>
        </trans-unit>
        <trans-unit id="c316cf9a16e0fa7fc1229baa23a24494a5548cb8" translate="yes" xml:space="preserve">
          <source>For interactive use of the str library, do:</source>
          <target state="translated">str 라이브러리를 대화식으로 사용하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="699e3e7671ce8003396b2ad0dfb9479eb8a59585" translate="yes" xml:space="preserve">
          <source>For interactive use of the unix library, do:</source>
          <target state="translated">유닉스 라이브러리를 대화식으로 사용하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="aab7d183ac64c6f5627d01cb1a929c8a0cc3c3d8" translate="yes" xml:space="preserve">
          <source>For let, the attributes are applied to each bindings:</source>
          <target state="translated">let의 경우 속성이 각 바인딩에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dde1e7361b04b1aa4b5279b99eac062b8cfc93f4" translate="yes" xml:space="preserve">
          <source>For lists, some syntactic sugar is provided. The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;::&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; stands for the constructor (::) applied to the arguments (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;,&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;), and therefore evaluates to the list whose head is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and whose tail is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. The expression [&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] is equivalent to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:: &amp;hellip; ::&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;::[], and therefore evaluates to the list whose elements are the values of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">목록의 경우 일부 구문 설탕이 제공됩니다. 식은 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; :: &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;2 개&lt;/sub&gt; 생성자 (용 스탠드 : :) (인수인가 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; , &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; ), 따라서 그 헤드의 값리스트로 평가 &lt;a href=&quot;#expr&quot;&gt;expr에 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 및 그 꼬리 값 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; . 표현식 [ &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;; &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; ]에 상당 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; :: ... :: &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; : [], 따라서, 그 요소의 값이다 목록 평가 &lt;a href=&quot;#expr&quot;&gt;expr에 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 행&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; .</target>
        </trans-unit>
        <trans-unit id="e8a86e99ce6f9ce032dc05c5a6a2ecf3f7ba6b26" translate="yes" xml:space="preserve">
          <source>For more information about &lt;em&gt;eventlog-tools&lt;/em&gt;, refer to the project&amp;rsquo;s main page: &lt;a href=&quot;https://github.com/ocaml-multicore/eventlog-tools&quot;&gt;https://github.com/ocaml-multicore/eventlog-tools&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;eventlog-tools&lt;/em&gt; 에 대한 자세한 정보 는 프로젝트의 메인 페이지를 참조하십시오 : &lt;a href=&quot;https://github.com/ocaml-multicore/eventlog-tools&quot;&gt;https://github.com/ocaml-multicore/eventlog-tools&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e3fdaa3af3a3833df037c917261156243c0a3426" translate="yes" xml:space="preserve">
          <source>For more information about conversion specifications and formatting indications available, read the documentation of modules &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 변환 사양 및 형식 지정 표시에 대한 자세한 내용은 &lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;printf&quot;&gt; &lt;code&gt;Printf&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt; 모듈의 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c98a7299a1e114d6c8fcd25e0f9ad620f2b15437" translate="yes" xml:space="preserve">
          <source>For more information on &lt;em&gt;babeltrace&lt;/em&gt;, see the website at: &lt;a href=&quot;https://babeltrace.org/&quot;&gt;https://babeltrace.org/&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;babeltrace&lt;/em&gt; 에 대한 자세한 내용은 &lt;a href=&quot;https://babeltrace.org/&quot;&gt;https://babeltrace.org/&lt;/a&gt; 웹 사이트를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eded1ae5f4e85162d085a1067ff14d61f49ceb5d" translate="yes" xml:space="preserve">
          <source>For more information on afl-fuzz, see the website at &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;http://lcamtuf.coredump.cx/afl/&lt;/a&gt;.</source>
          <target state="translated">afl-fuzz에 대한 자세한 내용은 &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;http://lcamtuf.coredump.cx/afl/&lt;/a&gt; 웹 사이트를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e368ef71e03b57e9465a3c040880f0c3f8f7488" translate="yes" xml:space="preserve">
          <source>For more information on the &lt;em&gt;Common Trace Format&lt;/em&gt;, see &lt;a href=&quot;https://diamon.org/ctf/&quot;&gt;https://diamon.org/ctf/&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;Common Trace Format&lt;/em&gt; 에 대한 자세한 내용 은 &lt;a href=&quot;https://diamon.org/ctf/&quot;&gt;https://diamon.org/ctf/를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6047f289f64afe60d156adbc2d91f375cf39e18f" translate="yes" xml:space="preserve">
          <source>For more information, see the description of module Lazy in the standard library (module &lt;a href=&quot;libref/lazy&quot;&gt;Lazy&lt;/a&gt;).</source>
          <target state="translated">자세한 내용은 표준 라이브러리 (모듈 &lt;a href=&quot;libref/lazy&quot;&gt;Lazy&lt;/a&gt; ) 의 모듈 Lazy에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c4464097eb1cea9b9bac89b09a00caecac51a81" translate="yes" xml:space="preserve">
          <source>For patterns, local opens are limited to the &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.(&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;) construction. This construction locally opens the module referred to by the module path &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; in the scope of the pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;.</source>
          <target state="translated">패턴의 경우 로컬 열기는 &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; . ( &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; ) 구성 으로 제한됩니다 . 이 구성 은 패턴 &lt;a href=&quot;#pattern&quot;&gt;패턴&lt;/a&gt; 범위에서 모듈 경로 &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; 에서 참조하는 모듈을 로컬로 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="aef2b59d23fff41131044485051539866a8c3ac8" translate="yes" xml:space="preserve">
          <source>For pointers that are at least 2-aligned (the low bit is guaranteed to be zero), we have yet another valid representation as an OCaml tagged integer.</source>
          <target state="translated">적어도 2로 정렬 된 포인터 (하위 비트는 0이 보장됨)의 경우 OCaml 태그가 지정된 정수로 또 다른 유효한 표현이 있습니다.</target>
        </trans-unit>
        <trans-unit id="73f3879c76d10b585df3a2eafc7157a6760d3bbd" translate="yes" xml:space="preserve">
          <source>For recursive functions the relevant attributes are:</source>
          <target state="translated">재귀 함수의 경우 관련 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ebf1588f6cdfdc9ffed9431d4da1f119970c3bc" translate="yes" xml:space="preserve">
          <source>For scripting purpose, matching against &amp;lsquo;{PID}&amp;lsquo;, as well as the .eventlog file extension should provide enough control over the generated files.</source>
          <target state="translated">스크립팅 목적으로 '{PID}'및 .eventlog 파일 확장자에 대한 일치는 생성 된 파일에 대한 충분한 제어를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d009d07e3cdd357f1da6c6c41490e4b69ddef46" translate="yes" xml:space="preserve">
          <source>For small functions that are called repeatedly, this indirection can have a big impact on performances. However this is not needed if we know that the C function doesn&amp;rsquo;t allocate, doesn&amp;rsquo;t raise exceptions, and doesn&amp;rsquo;t release the master lock (see section &lt;a href=&quot;#ss%3Aparallel-execution-long-running-c-code&quot;&gt;20.12.2&lt;/a&gt;). We can instruct the OCaml native-code compiler of this fact by annotating the external declaration with the attribute [@@noalloc]:</source>
          <target state="translated">반복적으로 호출되는 작은 함수의 경우이 간접적 인 방법은 성능에 큰 영향을 줄 수 있습니다. 그러나 C 함수가 할당하지 않고 예외를 발생시키지 않고 마스터 잠금을 해제하지 않는다는 것을 알고있는 경우에는 필요하지 않습니다 (섹션 &lt;a href=&quot;#ss%3Aparallel-execution-long-running-c-code&quot;&gt;20.12.2&lt;/a&gt; 참조 ). [@@ noalloc] 속성을 사용하여 외부 선언에 주석을 추가하여이 사실을 OCaml 네이티브 코드 컴파일러에 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e528ec5a4e42d84e77d36a471eae26958b074f6" translate="yes" xml:space="preserve">
          <source>For specifying a module component that is a functor, one may write</source>
          <target state="translated">펑터 인 모듈 구성 요소를 지정하려면 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51c50a9c50ed7f2e407b8a69772825eb202f692f" translate="yes" xml:space="preserve">
          <source>For the final linking phase, in addition to the object file produced by -output-obj, you will have to provide the OCaml runtime library (libcamlrun.a for bytecode, libasmrun.a for native-code), as well as all C libraries that are required by the OCaml libraries used. For instance, assume the OCaml part of your program uses the Unix library. With ocamlc, you should do:</source>
          <target state="translated">최종 연결 단계에서는 -output-obj에 의해 생성 된 개체 파일 외에도 OCaml 런타임 라이브러리 (바이트 코드의 경우 libcamlrun.a, 네이티브 코드의 경우 libasmrun.a)와 모든 C 라이브러리를 제공해야합니다. 사용 된 OCaml 라이브러리에 필요합니다. 예를 들어, 프로그램의 OCaml 부분이 Unix 라이브러리를 사용한다고 가정합니다. ocamlc를 사용하면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="7da283fed0922afd4ea51a82bd3ebbaecf48b3da" translate="yes" xml:space="preserve">
          <source>For the following examples, we will use the following example program:</source>
          <target state="translated">다음 예제에서는 다음 예제 프로그램을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8462057be99ab190b24cbcda3c885f2c8e84c711" translate="yes" xml:space="preserve">
          <source>For the following files, do not include delayed dependencies for module aliases. This option assumes that they are compiled using options -no-alias-deps -w -49, and that those files or their interface are passed with the -map option when computing dependencies for other files. Note also that for dependencies to be correct in the implementation of a map file, its interface should not coerce any of the aliases it contains.</source>
          <target state="translated">다음 파일의 경우 모듈 별칭에 대한 지연된 종속성을 포함하지 마십시오. 이 옵션은 -no-alias-deps -w -49 옵션을 사용하여 컴파일되고 다른 파일에 대한 종속성을 계산할 때 해당 파일 또는 해당 인터페이스가 -map 옵션과 함께 전달된다고 가정합니다. 또한 맵 파일의 구현에서 종속성이 정확하려면 해당 인터페이스가 포함 된 별칭을 강요해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d34193bb871e307746e89150d6b73785a0ab6119" translate="yes" xml:space="preserve">
          <source>For the majority of installations the native toplevel will not have been installed along with the rest of the OCaml toolchain. In such circumstances it will be necessary to build the OCaml distribution from source. From the built source tree of the distribution you may use make natruntop to build and execute a native toplevel. (Alternatively make ocamlnat can be used, which just performs the build step.)</source>
          <target state="translated">대부분의 설치에서 기본 최상위 수준은 나머지 OCaml 도구 모음과 함께 설치되지 않습니다. 이러한 상황에서는 소스에서 OCaml 배포를 빌드해야합니다. 배포판의 빌드 된 소스 트리에서 make natruntop을 사용하여 네이티브 최상위 수준을 빌드하고 실행할 수 있습니다. (또는 빌드 단계 만 수행하는 ocamlnat를 사용할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="6ea68bef1bfd3292b6bb1895b9e027db0dba7842" translate="yes" xml:space="preserve">
          <source>For the printing function, we take into account the usual precedence rules (i.e. * binds tighter than +) to avoid printing unnecessary parentheses. To this end, we maintain the current operator precedence and print parentheses around an operator only if its precedence is less than the current precedence.</source>
          <target state="translated">인쇄 기능의 경우 불필요한 괄호 인쇄를 방지하기 위해 일반적인 우선 순위 규칙 (예 : *가 +보다 더 엄격하게 바인딩 됨)을 고려합니다. 이를 위해 현재 연산자 우선 순위를 유지하고 우선 순위가 현재 우선 순위보다 낮은 경우에만 연산자 주위에 괄호를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="51b39efa922285a3273b661042d8cdef22ef9a84" translate="yes" xml:space="preserve">
          <source>For the purposes of optimization, &lt;code&gt;opaque_identity&lt;/code&gt; behaves like an unknown (and thus possibly side-effecting) function.</source>
          <target state="translated">최적화를 위해 &lt;code&gt;opaque_identity&lt;/code&gt; 는 알려지지 않은 (따라서 부작용이있을 수있는) 함수처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1e267fe9f8c40f023788aff73390761c297ce2ff" translate="yes" xml:space="preserve">
          <source>For the user to be able to specify anonymous arguments starting with a &lt;code&gt;-&lt;/code&gt;, include for example &lt;code&gt;(&quot;-&quot;,&amp;nbsp;String&amp;nbsp;anon_fun,&amp;nbsp;doc)&lt;/code&gt; in &lt;code&gt;speclist&lt;/code&gt;.</source>
          <target state="translated">사용자가 &lt;code&gt;-&lt;/code&gt; 로 시작하는 익명 인수를 지정할 수 있도록하려면 &lt;code&gt;(&quot;-&quot;,&amp;nbsp;String&amp;nbsp;anon_fun,&amp;nbsp;doc)&lt;/code&gt; 에 예를 들어 ( &quot;-&quot;, String anon_fun, doc) 를 포함 &lt;code&gt;speclist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19c1a10da802041b9fb470f3102a59cc151979bc" translate="yes" xml:space="preserve">
          <source>For this overview of OCaml, we use the interactive system, which is started by running ocaml from the Unix shell, or by launching the OCamlwin.exe application under Windows. This tutorial is presented as the transcript of a session with the interactive system: lines starting with # represent user input; the system responses are printed below, without a leading #.</source>
          <target state="translated">이 OCaml 개요를 위해 Unix 셸에서 ocaml을 실행하거나 Windows에서 OCamlwin.exe 응용 프로그램을 시작하여 시작되는 대화 형 시스템을 사용합니다. 이 자습서는 대화 형 시스템 세션의 대본으로 제공됩니다. #으로 시작하는 줄은 사용자 입력을 나타냅니다. 시스템 응답은 앞에 #없이 아래에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="0a580402e4ad9306e87473671cf0faf7d2f7ab1a" translate="yes" xml:space="preserve">
          <source>For this reason, you must be more careful about making types explicit when you use polymorphic variants. When you write a library, this is easy since you can describe exact types in interfaces, but for simple programs you are probably better off with core language variants.</source>
          <target state="translated">따라서 다형성 변형을 사용할 때 유형을 명시 적으로 만드는 데 더주의해야합니다. 라이브러리를 작성할 때 인터페이스에서 정확한 유형을 설명 할 수 있기 때문에 이것은 쉽지만 단순한 프로그램의 경우 핵심 언어 변형을 사용하는 것이 더 나을 것입니다.</target>
        </trans-unit>
        <trans-unit id="af957d60ed570105b0b392af1c056d6167910718" translate="yes" xml:space="preserve">
          <source>For type-checking purposes (and starting from OCaml 4.02), package types are compared using the structural comparison of module types.</source>
          <target state="translated">유형 검사 목적 (및 OCaml 4.02부터)을 위해 패키지 유형은 모듈 유형의 ​​구조적 비교를 사용하여 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="34f5bb35507ceece551d8584537a151ed8d0b764" translate="yes" xml:space="preserve">
          <source>For user-defined types, the variance is automatically inferred: a parameter is covariant if it has only covariant occurrences, contravariant if it has only contravariant occurrences, variance-free if it has no occurrences, and nonvariant otherwise. A variance-free parameter may change freely through subtyping, it does not have to be a subtype or a supertype. For abstract and private types, the variance must be given explicitly (see section &lt;a href=&quot;typedecl#ss%3Atypedefs&quot;&gt;7.8.1&lt;/a&gt;), otherwise the default is nonvariant. This is also the case for constrained arguments in type definitions.</source>
          <target state="translated">사용자 정의 유형의 경우 분산은 자동으로 유추됩니다. 매개 변수는 공변 발생 만있는 경우 공변, 반 변성 발생 만있는 경우 반변, 발생이 없으면 분산이없고 그렇지 않으면 비 변이입니다. 분산이없는 매개 변수는 하위 유형 지정을 통해 자유롭게 변경할 수 있으며 하위 유형 또는 상위 유형일 필요는 없습니다. 추상 및 개인 유형의 경우 분산을 명시 적으로 제공해야합니다 (섹션 &lt;a href=&quot;typedecl#ss%3Atypedefs&quot;&gt;7.8.1&lt;/a&gt; 참조 ). 그렇지 않으면 기본값이 비 변형입니다. 이는 유형 정의에서 제한된 인수의 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="6424726f5a111f674b5264a50bb99313ad270bad" translate="yes" xml:space="preserve">
          <source>Forbid binding an IPv6 socket to an IPv4 address</source>
          <target state="translated">IPv6 소켓을 IPv4 주소에 바인딩하는 것을 금지</target>
        </trans-unit>
        <trans-unit id="5cb81eb5ee90252463cf66685d1856591ccc439a" translate="yes" xml:space="preserve">
          <source>Force a new line in the current pretty-printing box.</source>
          <target state="translated">현재 예쁜 인쇄 상자에 새 줄을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="125afb80bbeb391648654a9060fd49b75954e783" translate="yes" xml:space="preserve">
          <source>Force all modules contained in libraries to be linked in. If this flag is not given, unreferenced modules are not linked in. When building a library (option -a), setting the -linkall option forces all subsequent links of programs involving that library to link all the modules contained in the library. When compiling a module (option -c), setting the -linkall option ensures that this module will always be linked if it is put in a library and this library is linked.</source>
          <target state="translated">라이브러리에 포함 된 모든 모듈이 링크되도록 강제합니다.이 플래그를 지정하지 않으면 참조되지 않은 모듈이 링크되지 않습니다. 라이브러리를 빌드 할 때 (옵션 -a) -linkall 옵션을 설정하면 해당 라이브러리와 관련된 프로그램의 모든 후속 링크가 라이브러리에 포함 된 모든 모듈을 연결합니다. 모듈을 컴파일 할 때 (옵션 -c) -linkall 옵션을 설정하면이 모듈이 라이브러리에 있고이 라이브러리가 링크 된 경우 항상 링크됩니다.</target>
        </trans-unit>
        <trans-unit id="035f3fa8787b038845df69761d559e46584335ee" translate="yes" xml:space="preserve">
          <source>Force error messages to show absolute paths for file names.</source>
          <target state="translated">오류 메시지가 파일 이름에 대한 절대 경로를 표시하도록합니다.</target>
        </trans-unit>
        <trans-unit id="b18cad2a21c9b98f70be09ebac9958393c7c0edc" translate="yes" xml:space="preserve">
          <source>Force the construction of a statically linked library only, even if dynamic linking is supported.</source>
          <target state="translated">동적 링크가 지원 되더라도 정적으로 링크 된 라이브러리 만 강제로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="46882fa3a62ce5fc4e4b0d025aabceb392c26854" translate="yes" xml:space="preserve">
          <source>Force the left-hand part of each sequence to have type unit.</source>
          <target state="translated">각 시퀀스의 왼쪽 부분이 유형 단위를 갖도록합니다.</target>
        </trans-unit>
        <trans-unit id="0a683f099c5cd32d972be2f3a92f5a845ceb5fd5" translate="yes" xml:space="preserve">
          <source>Foreword</source>
          <target state="translated">Foreword</target>
        </trans-unit>
        <trans-unit id="304eeec5641ac1e5522186b7555dcdb91736d26d" translate="yes" xml:space="preserve">
          <source>Fork a new process.</source>
          <target state="translated">새로운 프로세스를 포크하십시오.</target>
        </trans-unit>
        <trans-unit id="236e1aa20d58ae0da8f5448ac108dbc6e91a6c14" translate="yes" xml:space="preserve">
          <source>Fork a new process. The returned integer is 0 for the child process, the pid of the child process for the parent process.</source>
          <target state="translated">새로운 프로세스를 포크하십시오. 반환 된 정수는 자식 프로세스의 경우 0이고 부모 프로세스의 경우 자식 프로세스의 pid입니다.</target>
        </trans-unit>
        <trans-unit id="1a98756856d684441ecaf6f9fd69f196389c0e67" translate="yes" xml:space="preserve">
          <source>Formal parameters and arguments are matched according to their respective labels&lt;sup&gt;&lt;a href=&quot;#note1&quot; id=&quot;text1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, the absence of label being interpreted as the empty label. This allows commuting arguments in applications. One can also partially apply a function on any argument, creating a new function of the remaining parameters.</source>
          <target state="translated">형식 매개 변수와 인수는 각각의 레이블 &lt;sup&gt;&lt;a href=&quot;#note1&quot; id=&quot;text1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; 에 따라 일치 하며 레이블이 없으면 빈 레이블로 해석됩니다. 이를 통해 응용 프로그램에서 인수를 교환 할 수 있습니다. 인수에 함수를 부분적으로 적용하여 나머지 매개 변수의 새 함수를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="58a23074c162bcd840e8739dd410d344b7804635" translate="yes" xml:space="preserve">
          <source>Formally, an estimate of runtime performance benefit is computed by first summing the cost of the operations that are known to be removed as a result of the inlining and subsequent simplification of the inlined body. The individual costs for the various kinds of operations may be adjusted using the various -inline-...-cost flags as follows. Costs are specified as integers. All of these flags accept a single argument describing such integers using the conventions detailed in section &lt;a href=&quot;#ss%3Aflambda-rounds&quot;&gt;21.2.1&lt;/a&gt;.</source>
          <target state="translated">공식적으로 런타임 성능 이점의 추정치는 먼저 인라인 된 본문의 인라인 및 후속 단순화의 결과로 제거되는 것으로 알려진 작업 비용을 합산하여 계산됩니다. 다양한 종류의 작업에 대한 개별 비용은 다음과 같이 다양한 -inline -...- cost 플래그를 사용하여 조정할 수 있습니다. 비용은 정수로 지정됩니다. 이러한 모든 플래그는 섹션 &lt;a href=&quot;#ss%3Aflambda-rounds&quot;&gt;21.2.1에&lt;/a&gt; 자세히 설명 된 규칙을 사용하여 이러한 정수를 설명하는 단일 인수를 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="cd766e4c3a23f7c2da8587cebfb482091c1dccb5" translate="yes" xml:space="preserve">
          <source>Format string description</source>
          <target state="translated">형식 문자열 설명</target>
        </trans-unit>
        <trans-unit id="fb420b10080f1dd9257bcd67f1d8aee25cf5a4f3" translate="yes" xml:space="preserve">
          <source>Format strings are character strings with special lexical conventions that defines the functionality of formatted input/output functions. Format strings are used to read data with formatted input functions from module &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; and to print data with formatted output functions from modules &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">형식 문자열은 형식화 된 입력 / 출력 함수의 기능을 정의하는 특수 어휘 규칙이있는 문자열입니다. 형식 문자열은 &lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt; 모듈에서 형식화 된 입력 함수로 데이터를 읽고 &lt;a href=&quot;printf&quot;&gt; &lt;code&gt;Printf&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt; 모듈에서 형식화 된 출력 함수로 데이터를 인쇄하는 데 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="c62c8f7675da4c277f6225623ec0c47dda029d6d" translate="yes" xml:space="preserve">
          <source>Format strings are made of three kinds of entities:</source>
          <target state="translated">형식 문자열은 다음과 같은 세 가지 유형의 항목으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f06a845dc5cb646f90245c5fc3022aea03416143" translate="yes" xml:space="preserve">
          <source>Format strings have a general and highly polymorphic type &lt;code&gt;('a,&amp;nbsp;'b,&amp;nbsp;'c,&amp;nbsp;'d,&amp;nbsp;'e,&amp;nbsp;'f)&amp;nbsp;format6&lt;/code&gt;. The two simplified types, &lt;code&gt;format&lt;/code&gt; and &lt;code&gt;format4&lt;/code&gt; below are included for backward compatibility with earlier releases of OCaml.</source>
          <target state="translated">형식 문자열은 일반적이고 고도로 다형성 유형 &lt;code&gt;('a,&amp;nbsp;'b,&amp;nbsp;'c,&amp;nbsp;'d,&amp;nbsp;'e,&amp;nbsp;'f)&amp;nbsp;format6&lt;/code&gt; . 아래의 두 가지 단순화 된 유형, &lt;code&gt;format&lt;/code&gt; 및 &lt;code&gt;format4&lt;/code&gt; 는 이전 OCaml 릴리스와의 역 호환성을 위해 포함되었습니다.</target>
        </trans-unit>
        <trans-unit id="252c8b72c38b953722001b0d7e1faa8cdee47d48" translate="yes" xml:space="preserve">
          <source>Formatted Pretty-Printing with continuations.</source>
          <target state="translated">연속되는 형식의 Pretty-Printing.</target>
        </trans-unit>
        <trans-unit id="3a2d3f703bd5b043248ec990cc1f4c5007ff3f0e" translate="yes" xml:space="preserve">
          <source>Formatted input as a functional feature</source>
          <target state="translated">기능적 특징으로 형식화 된 입력</target>
        </trans-unit>
        <trans-unit id="77bd2d9934254f11979d82347140567c1ddb102e" translate="yes" xml:space="preserve">
          <source>Formatted input channel</source>
          <target state="translated">형식화 된 입력 채널</target>
        </trans-unit>
        <trans-unit id="be2d12d3c9bb417bd5c2c00ad2a7d80739b67fe6" translate="yes" xml:space="preserve">
          <source>Formatted input functions.</source>
          <target state="translated">형식화 된 입력 함수.</target>
        </trans-unit>
        <trans-unit id="3f2c32e9b045d340dc3d1db20b06b3312b9dffe7" translate="yes" xml:space="preserve">
          <source>Formatted output functions with continuations.</source>
          <target state="translated">연속 된 형식화 된 출력 함수.</target>
        </trans-unit>
        <trans-unit id="711a36aaf3243301d4bdbe36c688f9d583325bf4" translate="yes" xml:space="preserve">
          <source>Formatted output functions.</source>
          <target state="translated">형식화 된 출력 함수.</target>
        </trans-unit>
        <trans-unit id="2f3ced1470e4fb0a82a21db25542a6f1c80d4639" translate="yes" xml:space="preserve">
          <source>Formatted pretty-printing</source>
          <target state="translated">예쁜 인쇄 형식</target>
        </trans-unit>
        <trans-unit id="f51b052e6b6929080b4b2c0e3ee6499327d38158" translate="yes" xml:space="preserve">
          <source>Formatting functions</source>
          <target state="translated">서식 기능</target>
        </trans-unit>
        <trans-unit id="b31bab41071c2ba216bb20fa4ecdf43ff5be0ae1" translate="yes" xml:space="preserve">
          <source>Fragile constant pattern.</source>
          <target state="translated">깨지기 쉬운 일정한 패턴.</target>
        </trans-unit>
        <trans-unit id="733886e0c1a7b21f20a0e73b04dc5e1666cb2517" translate="yes" xml:space="preserve">
          <source>Fragile pattern matching: matching that will remain complete even if additional constructors are added to one of the variant types matched.</source>
          <target state="translated">취약한 패턴 일치 : 일치하는 변형 유형 중 하나에 추가 생성자가 추가 된 경우에도 완전하게 유지되는 일치입니다.</target>
        </trans-unit>
        <trans-unit id="103d90d5cbdf56cc8c46155df2e012b9e7f0d6e6" translate="yes" xml:space="preserve">
          <source>Freeing the memory blocks that were allocated by the runtime with malloc. Inside C primitives, it is advised to use caml_stat_* functions from memory.h for managing static (that is, non-moving) blocks of heap memory, as all the blocks allocated with these functions are automatically freed by caml_shutdown. For ensuring compatibility with legacy C stubs that have used caml_stat_* incorrectly, this behaviour is only enabled if the runtime is started with a specialized caml_startup_pooled function.</source>
          <target state="translated">malloc을 사용하여 런타임에 의해 할당 된 메모리 블록을 해제합니다. C 프리미티브에서는 이러한 함수로 할당 된 모든 블록이 caml_shutdown에 의해 자동으로 해제되므로 힙 메모리의 정적 (즉, 이동하지 않는) 블록을 관리하기 위해 memory.h의 caml_stat_ * 함수를 사용하는 것이 좋습니다. caml_stat_ *를 잘못 사용한 레거시 C 스텁과의 호환성을 보장하기 위해이 동작은 런타임이 특수 caml_startup_pooled 함수로 시작된 경우에만 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="381e8105b7f65611bdbccad4e376930184ddb809" translate="yes" xml:space="preserve">
          <source>From the point of view of the writer of C stubs, the challenges of interacting with Windows Unicode APIs are twofold:</source>
          <target state="translated">C 스텁 작성자의 관점에서 Windows 유니 코드 API와 상호 작용하는 문제는 두 가지입니다.</target>
        </trans-unit>
        <trans-unit id="5006d76ef1ff0edee9bb268edecad3b64ee9a5fb" translate="yes" xml:space="preserve">
          <source>From the standpoint of the allocation functions, blocks are divided according to their size as zero-sized blocks, small blocks (with size less than or equal to &lt;code&gt;Max_young_wosize&lt;/code&gt;), and large blocks (with size greater than &lt;code&gt;Max_young_wosize&lt;/code&gt;). The constant &lt;code&gt;Max_young_wosize&lt;/code&gt; is declared in the include file mlvalues.h. It is guaranteed to be at least 64 (words), so that any block with constant size less than or equal to 64 can be assumed to be small. For blocks whose size is computed at run-time, the size must be compared against &lt;code&gt;Max_young_wosize&lt;/code&gt; to determine the correct allocation procedure.</source>
          <target state="translated">할당 함수의 관점에서 블록은 크기에 따라 크기가 0 인 블록, 작은 블록 ( &lt;code&gt;Max_young_wosize&lt;/code&gt; 보다 작거나 같은 크기 ) 및 큰 블록 ( &lt;code&gt;Max_young_wosize&lt;/code&gt; 보다 큰 크기 )으로 나뉩니다 . 상수 &lt;code&gt;Max_young_wosize&lt;/code&gt; 는 포함 파일 mlvalues.h에 선언되어 있습니다. 최소 64 (워드)가 보장되므로 일정한 크기가 64보다 작거나 같은 모든 블록은 작은 것으로 간주 할 수 있습니다. 런타임에 크기가 계산되는 블록의 경우 크기를 &lt;code&gt;Max_young_wosize&lt;/code&gt; 와 비교 하여 올바른 할당 절차를 결정 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="56fb6077bdf4f3c5cdb464d60eaad6a7f0d65be3" translate="yes" xml:space="preserve">
          <source>Full specifications of variant tags are only used for non-exact closed types. They can be understood as a conjunctive type for the argument: it is intended to have all the types enumerated in the specification.</source>
          <target state="translated">변형 태그의 전체 사양은 정확하지 않은 폐쇄 유형에만 사용됩니다. 그것들은 인수에 대한 결합 유형으로 이해 될 수 있습니다. 이것은 명세서에 열거 된 모든 유형을 갖도록 의도 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="5f941ab65fbabe87f41cd73c9136f5a4c97087e8" translate="yes" xml:space="preserve">
          <source>Fun</source>
          <target state="translated">Fun</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="f13929b48377daed175f9b82a9945ecfe03b8a18" translate="yes" xml:space="preserve">
          <source>Function application is denoted by juxtaposition of (possibly labeled) expressions. The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; evaluates the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; and those appearing in &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; must evaluate to a functional value f, which is then applied to the values of &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">함수 적용은 (라벨이 붙은) 표현식의 병치로 표시됩니다. 발현 &lt;a href=&quot;#expr&quot;&gt;EXPR의 &lt;/a&gt;&lt;a href=&quot;#argument&quot;&gt;인수 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ... &lt;a href=&quot;#argument&quot;&gt;인수 &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; 평가하여 발현 &lt;a href=&quot;#expr&quot;&gt;을 expr&lt;/a&gt; 과 나타나는 것과 &lt;a href=&quot;#argument&quot;&gt;인수 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 로 &lt;a href=&quot;#argument&quot;&gt;인수 &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; . &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 표현식 은 함수 값 f로 평가되어야하며, 이는 &lt;a href=&quot;#argument&quot;&gt;인수 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip;, &lt;a href=&quot;#argument&quot;&gt;인수 &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 의 값에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f41d8a2104aaa68d4125738c3fccd8fde3ee5b3" translate="yes" xml:space="preserve">
          <source>Function interrupted by signal</source>
          <target state="translated">신호에 의해 중단 된 기능</target>
        </trans-unit>
        <trans-unit id="d2c76e1ede161471ccd802e477febd466535fb41" translate="yes" xml:space="preserve">
          <source>Function manipulation.</source>
          <target state="translated">기능 조작.</target>
        </trans-unit>
        <trans-unit id="bc8a59f44f5ba9847650733c0cafd473c4eed11f" translate="yes" xml:space="preserve">
          <source>Function not supported</source>
          <target state="translated">지원되지 않는 기능</target>
        </trans-unit>
        <trans-unit id="5ef8a9128beb0af02eff674dd02f5540cdf4c052" translate="yes" xml:space="preserve">
          <source>Functional Iterators</source>
          <target state="translated">기능적 반복자</target>
        </trans-unit>
        <trans-unit id="13fe4e6e39b49747e662e4d40927c17b0001a35e" translate="yes" xml:space="preserve">
          <source>Functional input with format strings</source>
          <target state="translated">형식 문자열이있는 기능 입력</target>
        </trans-unit>
        <trans-unit id="c0c0cf6a585e5822f9daed0b884effec99c37c70" translate="yes" xml:space="preserve">
          <source>Functional update is often used in conjunction with binary methods as illustrated in section &lt;a href=&quot;advexamples#ss%3Astring-as-class&quot;&gt;6.2.1&lt;/a&gt;.</source>
          <target state="translated">기능 업데이트는 섹션 &lt;a href=&quot;advexamples#ss%3Astring-as-class&quot;&gt;6.2.1에&lt;/a&gt; 설명 된대로 바이너리 메서드와 함께 자주 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="994ce6abbd94a0acd9b9688ad57d717223e20bb2" translate="yes" xml:space="preserve">
          <source>Functional values are mappings from values to values.</source>
          <target state="translated">기능적 값은 값에서 값으로의 매핑입니다.</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="594192b50b04507e237e1cfb87230a7ae4c1d67b" translate="yes" xml:space="preserve">
          <source>Functions for lexer semantic actions</source>
          <target state="translated">렉서 시맨틱 액션을위한 함수</target>
        </trans-unit>
        <trans-unit id="8c55c9cbdceda57907c400a338a436f167c64fd5" translate="yes" xml:space="preserve">
          <source>Functions in &lt;code&gt;spec&lt;/code&gt; or &lt;code&gt;anon_fun&lt;/code&gt; can raise &lt;code&gt;Arg.Bad&lt;/code&gt; with an error message to reject invalid arguments.</source>
          <target state="translated">&lt;code&gt;spec&lt;/code&gt; 또는 &lt;code&gt;anon_fun&lt;/code&gt; 의 함수는 잘못된 인수를 거부하는 오류 메시지와 함께 &lt;code&gt;Arg.Bad&lt;/code&gt; 를 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8248c90bba77a29916a1cdfddf8e3aba54354454" translate="yes" xml:space="preserve">
          <source>Functions in &lt;code&gt;spec&lt;/code&gt; or &lt;code&gt;anon_fun&lt;/code&gt; can raise &lt;code&gt;Arg.Bad&lt;/code&gt; with an error message to reject invalid arguments. &lt;code&gt;Arg.Bad&lt;/code&gt; is also raised by &lt;a href=&quot;arg#VALparse_argv&quot;&gt;&lt;code&gt;Arg.parse_argv&lt;/code&gt;&lt;/a&gt; in case of an error.</source>
          <target state="translated">&lt;code&gt;spec&lt;/code&gt; 또는 &lt;code&gt;anon_fun&lt;/code&gt; 의 함수는 잘못된 인수를 거부하는 오류 메시지와 함께 &lt;code&gt;Arg.Bad&lt;/code&gt; 를 발생 시킬 수 있습니다 . &lt;code&gt;Arg.Bad&lt;/code&gt; 는 또한 오류가 발생하는 경우 &lt;a href=&quot;arg#VALparse_argv&quot;&gt; &lt;code&gt;Arg.parse_argv&lt;/code&gt; &lt;/a&gt; 에 의해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1b86afa845a1585328545e5f3991b68610497328" translate="yes" xml:space="preserve">
          <source>Functions that decode signed (resp. unsigned) 8-bit or 16-bit integers represented by &lt;code&gt;int&lt;/code&gt; values sign-extend (resp. zero-extend) their result.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 값으로 표시되는 부호있는 (부호없는 각) 8 비트 또는 16 비트 정수를 디코딩하는 함수는 결과를 부호 확장 (각각 0 확장)합니다.</target>
        </trans-unit>
        <trans-unit id="e3b7f5c27f44d3411501edb47a9a661138103758" translate="yes" xml:space="preserve">
          <source>Functions that encode 8-bit or 16-bit integers represented by &lt;code&gt;int&lt;/code&gt; values truncate their input to their least significant bytes.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 값으로 표현되는 8 비트 또는 16 비트 정수를 인코딩하는 함수는 입력을 최하위 바이트로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="2f86e81c17a3239f2ed2ba7a90d878f1fcd2d69d" translate="yes" xml:space="preserve">
          <source>Functions that take other functions as arguments are called &amp;ldquo;functionals&amp;rdquo;, or &amp;ldquo;higher-order functions&amp;rdquo;. Functionals are especially useful to provide iterators or similar generic operations over a data structure. For instance, the standard OCaml library provides a List.map functional that applies a given function to each element of a list, and returns the list of the results:</source>
          <target state="translated">다른 함수를 인수로 취하는 함수를 &quot;함수&quot;또는 &quot;고차 함수&quot;라고합니다. 함수는 데이터 구조에 대해 반복기 또는 유사한 일반 작업을 제공하는 데 특히 유용합니다. 예를 들어, 표준 OCaml 라이브러리는 주어진 함수를 목록의 각 요소에 적용하고 결과 목록을 반환하는 List.map 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3ea47ba4b29a471c05740d1b6b2aef7fcf7b007e" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.GenHashTable.MakeSeeded</source>
          <target state="translated">Functor Ephemeron.GenHashTable.MakeSeeded</target>
        </trans-unit>
        <trans-unit id="2ba75f98b1daeb726f09c0d9b8ebf4ca742bd9a0" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.K1.Make</source>
          <target state="translated">Functor Ephemeron.K1.Make</target>
        </trans-unit>
        <trans-unit id="791c73df8d4dc4a293cb5fc5df93e2d713e170be" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.K1.MakeSeeded</source>
          <target state="translated">Functor Ephemeron.K1.MakeSeeded</target>
        </trans-unit>
        <trans-unit id="13076ed4adc02650a2456124fd63360d574f170b" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.K2.Make</source>
          <target state="translated">Functor Ephemeron.K2.Make</target>
        </trans-unit>
        <trans-unit id="9f37977f2244653f5138488517907c339e2caad0" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.K2.MakeSeeded</source>
          <target state="translated">Functor Ephemeron.K2.MakeSeeded</target>
        </trans-unit>
        <trans-unit id="eb798cabd754ea8bd143b300b9c00949f911c4d0" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.Kn.Make</source>
          <target state="translated">Functor Ephemeron.Kn.Make</target>
        </trans-unit>
        <trans-unit id="95ecfc616841fe061e9170e804dc5953460e4e22" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.Kn.MakeSeeded</source>
          <target state="translated">Functor Ephemeron.Kn.MakeSeeded</target>
        </trans-unit>
        <trans-unit id="3844df36a31614de4703ed307f9104110c66c133" translate="yes" xml:space="preserve">
          <source>Functor Hashtbl.Make</source>
          <target state="translated">Functor Hashtbl.Make</target>
        </trans-unit>
        <trans-unit id="743dbedb9473f776f428bc156c6dc4f18a3c7c2c" translate="yes" xml:space="preserve">
          <source>Functor Hashtbl.MakeSeeded</source>
          <target state="translated">Functor Hashtbl.MakeSeeded</target>
        </trans-unit>
        <trans-unit id="6a14323bcc1d6553a2f876a23442561ccf9a8898" translate="yes" xml:space="preserve">
          <source>Functor Map.Make</source>
          <target state="translated">Functor Map.Make</target>
        </trans-unit>
        <trans-unit id="32b02c18c6fd2de2991bdf0f998f4324f7413b8e" translate="yes" xml:space="preserve">
          <source>Functor MoreLabels.Hashtbl.Make</source>
          <target state="translated">Functor MoreLabels.Hashtbl.Make</target>
        </trans-unit>
        <trans-unit id="ae21d10a3065dbf4c56f4f993cd9e0afc7222c78" translate="yes" xml:space="preserve">
          <source>Functor MoreLabels.Hashtbl.MakeSeeded</source>
          <target state="translated">Functor MoreLabels.Hashtbl.MakeSeeded</target>
        </trans-unit>
        <trans-unit id="e35d41c98a0f8cb263549b344d89e05e0044a9a8" translate="yes" xml:space="preserve">
          <source>Functor MoreLabels.Map.Make</source>
          <target state="translated">Functor MoreLabels.Map.Make</target>
        </trans-unit>
        <trans-unit id="d7b37e87c0ae76c5e486380751816f2b5ce6f130" translate="yes" xml:space="preserve">
          <source>Functor MoreLabels.Set.Make</source>
          <target state="translated">Functor MoreLabels.Set.Make</target>
        </trans-unit>
        <trans-unit id="aa7642967c480650911cf8ff0961dfdebfe66970" translate="yes" xml:space="preserve">
          <source>Functor Set.Make</source>
          <target state="translated">Functor Set.Make</target>
        </trans-unit>
        <trans-unit id="7d4d7c62aec0f8b013f1e8a2e51f494583ed6792" translate="yes" xml:space="preserve">
          <source>Functor Sys.Immediate64.Make</source>
          <target state="translated">Functor Sys.Immediate64.Make</target>
        </trans-unit>
        <trans-unit id="c626045c07d526e8e111e54420d804ac453b7f39" translate="yes" xml:space="preserve">
          <source>Functor Weak.Make</source>
          <target state="translated">Functor Weak.Make</target>
        </trans-unit>
        <trans-unit id="b699610366ffb2bc1456841560d326de9dd34f9f" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of a weak hash table</source>
          <target state="translated">약한 해시 테이블 구현을 구축하는 Functor</target>
        </trans-unit>
        <trans-unit id="389dbe43bbc83f6add8186ac8132f778ad57371f" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of a weak hash table.</source>
          <target state="translated">약한 해시 테이블의 구현을 구축하는 Functor.</target>
        </trans-unit>
        <trans-unit id="cbb9434445367d8b10366b98ee9760b028541c96" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of a weak hash table. The seed is similar to the one of &lt;a href=&quot;hashtbl.makeseeded&quot;&gt;&lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">약한 해시 테이블의 구현을 구축하는 Functor. 씨앗은 &lt;a href=&quot;hashtbl.makeseeded&quot;&gt; &lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt; &lt;/a&gt; 중 하나와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="4ad5d99d5b99b9109a80f197da9462e8c2eb0f11" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of an hash table that use the container for keeping the information given</source>
          <target state="translated">주어진 정보를 유지하기 위해 컨테이너를 사용하는 해시 테이블의 구현을 구축하는 Functor</target>
        </trans-unit>
        <trans-unit id="ff02a7e7b2976b75351293a5e3b0329ad3b5e347" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the hashtable structure.</source>
          <target state="translated">해시 테이블 구조의 구현을 구축하는 Functor.</target>
        </trans-unit>
        <trans-unit id="e736518d7c53ed3a67bef9cb74bed1672d054303" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the hashtable structure. The functor &lt;code&gt;Hashtbl.Make&lt;/code&gt; returns a structure containing a type &lt;code&gt;key&lt;/code&gt; of keys and a type &lt;code&gt;'a&amp;nbsp;t&lt;/code&gt; of hash tables associating data of type &lt;code&gt;'a&lt;/code&gt; to keys of type &lt;code&gt;key&lt;/code&gt;. The operations perform similarly to those of the generic interface, but use the hashing and equality functions specified in the functor argument &lt;code&gt;H&lt;/code&gt; instead of generic equality and hashing. Since the hash function is not seeded, the &lt;code&gt;create&lt;/code&gt; operation of the result structure always returns non-randomized hash tables.</source>
          <target state="translated">해시 테이블 구조의 구현을 구축하는 Functor. 펑터 &lt;code&gt;Hashtbl.Make&lt;/code&gt; 는 타입 함유 구조 리턴 &lt;code&gt;key&lt;/code&gt; 키 입력하고 &lt;code&gt;'a&amp;nbsp;t&lt;/code&gt; 종류의 데이터를 연결하는 해시 테이블 &lt;code&gt;'a&lt;/code&gt; 입력 키의 &lt;code&gt;key&lt;/code&gt; . 작업은 일반 인터페이스의 작업과 유사하게 수행되지만 일반 같음 및 해싱 대신 functor 인수 &lt;code&gt;H&lt;/code&gt; 에 지정된 해싱 및 같음 함수를 사용합니다 . 해시 함수가 시드되지 않았으므로 결과 구조 의 &lt;code&gt;create&lt;/code&gt; 작업은 항상 무작위 화되지 않은 해시 테이블을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7fa7f1ef8b7a2c11e209c2793d5c2dd4a871de19" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the hashtable structure. The functor &lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt; returns a structure containing a type &lt;code&gt;key&lt;/code&gt; of keys and a type &lt;code&gt;'a&amp;nbsp;t&lt;/code&gt; of hash tables associating data of type &lt;code&gt;'a&lt;/code&gt; to keys of type &lt;code&gt;key&lt;/code&gt;. The operations perform similarly to those of the generic interface, but use the seeded hashing and equality functions specified in the functor argument &lt;code&gt;H&lt;/code&gt; instead of generic equality and hashing. The &lt;code&gt;create&lt;/code&gt; operation of the result structure supports the &lt;code&gt;~random&lt;/code&gt; optional parameter and returns randomized hash tables if &lt;code&gt;~random:true&lt;/code&gt; is passed or if randomization is globally on (see &lt;a href=&quot;hashtbl#VALrandomize&quot;&gt;&lt;code&gt;Hashtbl.randomize&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">해시 테이블 구조의 구현을 구축하는 Functor. 펑은 &lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt; 되돌 타입 함유 구조 &lt;code&gt;key&lt;/code&gt; 키 입력하고 &lt;code&gt;'a&amp;nbsp;t&lt;/code&gt; 종류의 데이터를 연결하는 해시 테이블 &lt;code&gt;'a&lt;/code&gt; 입력 키의 &lt;code&gt;key&lt;/code&gt; . 작업은 일반 인터페이스의 작업과 유사하게 수행되지만 일반 같음 및 해싱 대신 functor 인수 &lt;code&gt;H&lt;/code&gt; 에 지정된 시드 된 해싱 및 같음 함수를 사용합니다 . 결과 구조 의 &lt;code&gt;create&lt;/code&gt; 작업은 &lt;code&gt;~random&lt;/code&gt; 선택적 매개 변수를 지원하고 &lt;code&gt;~random:true&lt;/code&gt; 가 전달되거나 무작위 화가 전역 적으로 켜져있는 경우 무작위 화 된 해시 테이블을 반환합니다 (참조 :&lt;a href=&quot;hashtbl#VALrandomize&quot;&gt; &lt;code&gt;Hashtbl.randomize&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f83ea0beecbcf2f703dd91eb33b58d38977c526c" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the map structure given a totally ordered type.</source>
          <target state="translated">완전히 정렬 된 유형이 주어진 맵 구조의 구현을 빌드하는 Functor.</target>
        </trans-unit>
        <trans-unit id="5c59513445794edf5f86a24f7a69c2e920f5ea85" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the set structure given a totally ordered type.</source>
          <target state="translated">완전히 정렬 된 유형이 지정된 집합 구조의 구현을 빌드하는 Functor.</target>
        </trans-unit>
        <trans-unit id="d7ee355281f6ad25a690b039e1ce78ea8323eda0" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the weak hash set structure.</source>
          <target state="translated">약한 해시 세트 구조의 구현을 구축하는 Functor.</target>
        </trans-unit>
        <trans-unit id="14416cb42fb32afba2f0aa5e6b2e714075343250" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the weak hash set structure. &lt;code&gt;H.equal&lt;/code&gt; can't be the physical equality, since only shallow copies of the elements in the set are given to it.</source>
          <target state="translated">약한 해시 세트 구조의 구현을 구축하는 Functor. &lt;code&gt;H.equal&lt;/code&gt; 은 집합에있는 요소의 얕은 복사본 만 주어지기 때문에 물리적 동등성이 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0eb68f70b3b05995b7d69acf8715b7a8bfc794f9" translate="yes" xml:space="preserve">
          <source>Functorial interface</source>
          <target state="translated">기능 인터페이스</target>
        </trans-unit>
        <trans-unit id="40cacb900d73a801423574b27a6596efb4e78908" translate="yes" xml:space="preserve">
          <source>Functors are &amp;ldquo;functions&amp;rdquo; from modules to modules. Functors let you create parameterized modules and then provide other modules as parameter(s) to get a specific implementation. For instance, a Set module implementing sets as sorted lists could be parameterized to work with any module that provides an element type and a comparison function compare (such as OrderedString):</source>
          <target state="translated">Functor는 모듈에서 모듈로의 &quot;함수&quot;입니다. Functor를 사용하면 매개 변수화 된 모듈을 만든 다음 다른 모듈을 매개 변수로 제공하여 특정 구현을 얻을 수 있습니다. 예를 들어, 정렬 된 목록으로 집합을 구현하는 Set 모듈은 요소 유형 및 비교 함수 비교 (예 : OrderedString)를 제공하는 모든 모듈과 함께 작동하도록 매개 변수화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2aa3173a1816096d6ad12168dbc1f9f4f467900" translate="yes" xml:space="preserve">
          <source>Furthermore, quoted strings {|...|} can be combined with extension nodes to embed foreign syntax fragments. Those fragments can be interpreted by a preprocessor and turned into OCaml code without requiring escaping quotes. A syntax shortcut is available for them:</source>
          <target state="translated">또한 따옴표로 묶인 문자열 {| ... |}을 확장 노드와 결합하여 외부 구문 조각을 포함 할 수 있습니다. 이러한 조각은 전처리기에 의해 해석 될 수 있으며 이스케이프 따옴표없이 OCaml 코드로 변환 될 수 있습니다. 구문 바로 가기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="2e0c6454c25618b51c33652f1af456d60881e227" translate="yes" xml:space="preserve">
          <source>GADT pattern-matching may also add type equations to non-local abstract types. The behaviour is the same as with local abstract types. Reusing the above eq type, one can write:</source>
          <target state="translated">GADT 패턴 매칭은 비 로컬 추상 유형에 유형 방정식을 추가 할 수도 있습니다. 동작은 로컬 추상 유형과 동일합니다. 위의 eq 유형을 재사용하면 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e770dda21552fdb9094fb60f7cc36a895a76025d" translate="yes" xml:space="preserve">
          <source>Gc</source>
          <target state="translated">Gc</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="67069e1d09b05959a8399aadc22a86b8f23aaa51" translate="yes" xml:space="preserve">
          <source>General input functions</source>
          <target state="translated">일반 입력 기능</target>
        </trans-unit>
        <trans-unit id="87ca3ca5de8ba6c9c5bd65df11e3e917c3bc1a34" translate="yes" xml:space="preserve">
          <source>General output functions</source>
          <target state="translated">일반 출력 기능</target>
        </trans-unit>
        <trans-unit id="92e8a116a60d135308df04f70f6a61a19de331d5" translate="yes" xml:space="preserve">
          <source>Generalized algebraic datatypes, or GADTs, extend usual sum types in two ways: constraints on type parameters may change depending on the value constructor, and some type variables may be existentially quantified. Adding constraints is done by giving an explicit return type (the rightmost &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; in the above syntax), where type parameters are instantiated. This return type must use the same type constructor as the type being defined, and have the same number of parameters. Variables are made existential when they appear inside a constructor&amp;rsquo;s argument, but not in its return type.</source>
          <target state="translated">일반화 된 대수 데이터 유형 (GADT)은 두 가지 방법으로 일반적인 합계 유형을 확장합니다. 유형 매개 변수에 대한 제약은 값 생성자에 따라 변경 될 수 있으며 일부 유형 변수는 실존 적으로 정량화 될 수 있습니다. 제약 조건 추가는 명시 적 반환 유형 ( 위 구문에서 가장 오른쪽에있는 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr)&lt;/a&gt; 을 제공하여 수행되며 , 여기서 유형 매개 변수는 인스턴스화됩니다. 이 반환 유형은 정의되는 유형과 동일한 유형 생성자를 사용해야하며 동일한 수의 매개 변수를 가져야합니다. 변수는 생성자의 인수 안에 나타날 때 존재하지만 반환 유형에는 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0692177f9aa82986e7e68bb21bd552d660b0fb2a" translate="yes" xml:space="preserve">
          <source>Generally speaking, the formatted input functions have 3 arguments:</source>
          <target state="translated">일반적으로 형식화 된 입력 함수에는 3 개의 인수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae547ac3f788ba5ce6bb43946b8b3189c176f64a" translate="yes" xml:space="preserve">
          <source>Generate a bytecode executable file that can be executed on the custom runtime system runtime-name, built earlier with ocamlc -make-runtimeruntime-name. See section &lt;a href=&quot;intfc#ss%3Acustom-runtime&quot;&gt;20.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">ocamlc -make-runtimeruntime-name을 사용하여 이전에 빌드 된 사용자 지정 런타임 시스템 런타임 이름에서 실행할 수있는 바이트 코드 실행 파일을 생성합니다. 자세한 내용은 섹션 &lt;a href=&quot;intfc#ss%3Acustom-runtime&quot;&gt;20.1.6&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e7384f4e0f133518743705b706281153ceace0aa" translate="yes" xml:space="preserve">
          <source>Generate a dependency graph for the toplevel modules, in a format suitable for displaying and processing by dot. The dot tool is available from &lt;a href=&quot;https://graphviz.org/&quot;&gt;https://graphviz.org/&lt;/a&gt;. The textual representation of the graph is written to the file ocamldoc.out, or to the file specified with the -o option. Use dot ocamldoc.out to display it.</source>
          <target state="translated">점으로 표시하고 처리하는 데 적합한 형식으로 최상위 모듈에 대한 종속성 그래프를 생성합니다. 도트 도구는 &lt;a href=&quot;https://graphviz.org/&quot;&gt;https://graphviz.org/&lt;/a&gt; 에서 사용할 수 있습니다 . 그래프의 텍스트 표현은 ocamldoc.out 파일 또는 -o 옵션으로 지정된 파일에 기록됩니다. 그것을 표시하려면 dot ocamldoc.out을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="156fdd8d300b8c00d971004d85456ef8219690af" translate="yes" xml:space="preserve">
          <source>Generate a description of the parsing tables and a report on conflicts resulting from ambiguities in the grammar. The description is put in file grammar.output.</source>
          <target state="translated">구문 분석 테이블에 대한 설명과 문법의 모호함으로 인한 충돌에 대한 보고서를 생성합니다. 설명은 grammar.output 파일에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="49a9fa22c03767adb75add693dfa90c38c0ebdbe" translate="yes" xml:space="preserve">
          <source>Generate an object file (.cmo) that can later be included as a sub-module (with the given access path) of a compilation unit constructed with -pack. For instance, ocamlc -for-pack P -c A.ml will generate a..cmo that can later be used with ocamlc -pack -o P.cmo a.cmo. Note: you can still pack a module that was compiled without -for-pack but in this case exceptions will be printed with the wrong names.</source>
          <target state="translated">-pack으로 구성된 컴파일 단위의 하위 모듈 (주어진 액세스 경로 포함)로 나중에 포함될 수있는 개체 파일 (.cmo)을 생성합니다. 예를 들어, ocamlc -for-pack P -c A.ml은 나중에 ocamlc -pack -o P.cmo a.cmo와 함께 사용할 수있는 a..cmo를 생성합니다. 참고 : -for-pack없이 컴파일 된 모듈을 여전히 패킹 할 수 있지만이 경우 예외가 잘못된 이름으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="7103fb059f2d362dcfc616012cde802b4f623d5e" translate="yes" xml:space="preserve">
          <source>Generate an object file (.cmx and .o/.obj files) that can later be included as a sub-module (with the given access path) of a compilation unit constructed with -pack. For instance, ocamlopt -for-pack P -c A.ml will generate a..cmx and a.o files that can later be used with ocamlopt -pack -o P.cmx a.cmx. Note: you can still pack a module that was compiled without -for-pack but in this case exceptions will be printed with the wrong names.</source>
          <target state="translated">나중에 -pack으로 구성된 컴파일 단위의 하위 모듈 (주어진 액세스 경로 포함)로 포함될 수있는 개체 파일 (.cmx 및 .o / .obj 파일)을 생성합니다. 예를 들어, ocamlopt -for-pack P -c A.ml은 나중에 ocamlopt -pack -o P.cmx a.cmx와 함께 사용할 수있는 a..cmx 및 ao 파일을 생성합니다. 참고 : -for-pack없이 컴파일 된 모듈을 여전히 패킹 할 수 있지만이 경우 예외가 잘못된 이름으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="266d7ee3cde25ec4eb6f33154bf1ffb8dd2f15a2" translate="yes" xml:space="preserve">
          <source>Generate dependencies for a pure native-code program (no bytecode version). When an implementation file (.ml file) has no explicit interface file (.mli file), ocamldep generates dependencies on the bytecode compiled file (.cmo file) to reflect interface changes. This can cause unnecessary bytecode recompilations for programs that are compiled to native-code only. The flag -native causes dependencies on native compiled files (.cmx) to be generated instead of on .cmo files. (This flag makes no difference if all source files have explicit .mli interface files.)</source>
          <target state="translated">순수 네이티브 코드 프로그램에 대한 종속성을 생성합니다 (바이트 코드 버전 없음). 구현 파일 (.ml 파일)에 명시 적 인터페이스 파일 (.mli 파일)이없는 경우 ocamldep는 인터페이스 변경 사항을 반영하기 위해 바이트 코드 컴파일 파일 (.cmo 파일)에 대한 종속성을 생성합니다. 이로 인해 네이티브 코드로만 컴파일 된 프로그램에 대해 불필요한 바이트 코드 재 컴파일이 발생할 수 있습니다. -native 플래그를 사용하면 .cmo 파일 대신 네이티브 컴파일 된 파일 (.cmx)에 대한 종속성이 생성됩니다. (모든 소스 파일에 명시적인 .mli 인터페이스 파일이있는 경우이 플래그는 차이가 없습니다.)</target>
        </trans-unit>
        <trans-unit id="f287ec97b2026108a81dd10e2f4d965c4671c59e" translate="yes" xml:space="preserve">
          <source>Generate dependencies for native plugin files (.cmxs) in addition to native compiled files (.cmx).</source>
          <target state="translated">네이티브 컴파일 된 파일 (.cmx) 외에 네이티브 플러그인 파일 (.cmxs)에 대한 종속성을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d376a113a8253e681531eb700236c93f62c7c75e" translate="yes" xml:space="preserve">
          <source>Generate dependencies on all required files, rather than assuming implicit dependencies.</source>
          <target state="translated">암시 적 종속성을 가정하는 대신 모든 필수 파일에 대한 종속성을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="aea577157b1392082ac83b9fe585387f3b557796" translate="yes" xml:space="preserve">
          <source>Generate documentation as a set of Unix man pages. The generated pages are stored in the current directory, or in the directory specified with the -d option.</source>
          <target state="translated">문서를 Unix 매뉴얼 페이지 세트로 생성합니다. 생성 된 페이지는 현재 디렉토리 또는 -d 옵션으로 지정된 디렉토리에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="e5d87db23ea095f4cc3759103db7592876ea4306" translate="yes" xml:space="preserve">
          <source>Generate documentation in HTML default format. The generated HTML pages are stored in the current directory, or in the directory specified with the -d option. You can customize the style of the generated pages by editing the generated style.css file, or by providing your own style sheet using option -css-style. The file style.css is not generated if it already exists or if -css-style is used.</source>
          <target state="translated">HTML 기본 형식으로 문서를 생성합니다. 생성 된 HTML 페이지는 현재 디렉토리 또는 -d 옵션으로 지정된 디렉토리에 저장됩니다. 생성 된 style.css 파일을 편집하거나 -css-style 옵션을 사용하여 고유 한 스타일 시트를 제공하여 생성 된 페이지의 스타일을 사용자 정의 할 수 있습니다. style.css 파일이 이미 존재하거나 -css-style이 사용되는 경우 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f58b7853c614a36ff0c342792e60a65dbe4ad9b5" translate="yes" xml:space="preserve">
          <source>Generate documentation in L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X default format. The generated L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X document is saved in file ocamldoc.out, or in the file specified with the -o option. The document uses the style file ocamldoc.sty. This file is generated when using the -latex option, if it does not already exist. You can change this file to customize the style of your L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X documentation.</source>
          <target state="translated">L &lt;sup&gt;A&lt;/sup&gt; T &lt;sub&gt;E&lt;/sub&gt; X 기본 형식으로 문서를 생성 합니다. 생성 된 L &lt;sup&gt;A&lt;/sup&gt; T &lt;sub&gt;E&lt;/sub&gt; X 문서는 ocamldoc.out 파일 또는 -o 옵션으로 지정된 파일에 저장됩니다. 이 문서는 스타일 파일 ocamldoc.sty를 사용합니다. 이 파일은 -latex 옵션을 사용할 때 생성됩니다 (아직없는 경우). 이 파일을 변경하여 L &lt;sup&gt;A&lt;/sup&gt; T &lt;sub&gt;E&lt;/sub&gt; X 문서 의 스타일을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="129f3a9bee36c9ea1bf962aa07ce63970022d326" translate="yes" xml:space="preserve">
          <source>Generate documentation in TeXinfo default format. The generated L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X document is saved in file ocamldoc.out, or in the file specified with the -o option.</source>
          <target state="translated">TeXinfo 기본 형식으로 문서를 생성합니다. 생성 된 L &lt;sup&gt;A&lt;/sup&gt; T &lt;sub&gt;E&lt;/sub&gt; X 문서는 ocamldoc.out 파일 또는 -o 옵션으로 지정된 파일에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="c9fc266b6949eb96df1f7eb844b75ca64039217c" translate="yes" xml:space="preserve">
          <source>Generate files in directory dir, rather than the current directory.</source>
          <target state="translated">현재 디렉토리가 아닌 디렉토리 디렉토리에 파일을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="285e44cc7e6dbcf78a91ff365658da2f4d1959ff" translate="yes" xml:space="preserve">
          <source>Generate man pages only for modules, module types, classes and class types, instead of pages for all elements.</source>
          <target state="translated">모든 요소에 대한 페이지 대신 모듈, 모듈 유형, 클래스 및 클래스 유형에 대해서만 매뉴얼 페이지를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="f9864da8bda2a0e22bc4b39c31b0e724fe7a1a47" translate="yes" xml:space="preserve">
          <source>Generate one .tex file per toplevel module, instead of the global ocamldoc.out file.</source>
          <target state="translated">전역 ocamldoc.out 파일 대신 최상위 모듈 당 하나의 .tex 파일을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ff2e0a3174325a031b5ee70731f141a8ca8cc0cd" translate="yes" xml:space="preserve">
          <source>Generate only index files.</source>
          <target state="translated">색인 파일 만 생성합니다.</target>
        </trans-unit>
        <trans-unit id="98e76556f478e02273e6352c5a860d5aa13d870c" translate="yes" xml:space="preserve">
          <source>Generate position-dependent machine code.</source>
          <target state="translated">위치에 따른 기계어 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="73e6af12f0ccf65fb7a1459aa5aac3451674ec09" translate="yes" xml:space="preserve">
          <source>Generate position-independent machine code. This is the default.</source>
          <target state="translated">위치 독립적 인 기계어 코드를 생성합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="39c8ea337bb1a13e369fcb0e566aaf3fd0c0a061" translate="yes" xml:space="preserve">
          <source>Generate signal on INTR, QUIT, SUSP.</source>
          <target state="translated">INTR, QUIT, SUSP에서 신호를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="44c2b556ff44e4d16b71ff51d7440841b3fbf5c4" translate="yes" xml:space="preserve">
          <source>Generic arrays (of arbitrarily many dimensions)</source>
          <target state="translated">일반 배열 (임의로 많은 차원)</target>
        </trans-unit>
        <trans-unit id="a9003821b402d9b7458c8ef820262746bf0c5a25" translate="yes" xml:space="preserve">
          <source>Generic interface</source>
          <target state="translated">일반 인터페이스</target>
        </trans-unit>
        <trans-unit id="ca8b79d76f57f976b0d3a762bfe49c3a3887f695" translate="yes" xml:space="preserve">
          <source>Genlex</source>
          <target state="translated">Genlex</target>
        </trans-unit>
        <trans-unit id="9e32ad0c42ab8bdae8747cff4350874077b93e6d" translate="yes" xml:space="preserve">
          <source>Geometric functions can be used to manipulate simultaneously the coupled variables, margin and maxixum indentation limit.</source>
          <target state="translated">기하학적 함수를 사용하여 결합 된 변수, 여백 및 최대 들여 쓰기 한계를 동시에 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d1226717c2fc305626512b0a1ae618fddfee0b9" translate="yes" xml:space="preserve">
          <source>Geometry</source>
          <target state="translated">Geometry</target>
        </trans-unit>
        <trans-unit id="6ea2b05a0cc3942bd2ab24dd1445538e05f32023" translate="yes" xml:space="preserve">
          <source>Get the n-th character of the buffer.</source>
          <target state="translated">버퍼의 n 번째 문자를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="5785aa5d35936984cbd882807965031baa875625" translate="yes" xml:space="preserve">
          <source>Give a prefix to use for the labels of the values in the generated L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X document. The default prefix is the empty string. You can also use the options -latex-type-prefix, -latex-exception-prefix, -latex-module-prefix, -latex-module-type-prefix, -latex-class-prefix, -latex-class-type-prefix, -latex-attribute-prefix and -latex-method-prefix.</source>
          <target state="translated">생성 된 L &lt;sup&gt;A&lt;/sup&gt; T &lt;sub&gt;E&lt;/sub&gt; X 문서 에서 값의 레이블에 사용할 접두어를 지정하십시오 . 기본 접두사는 빈 문자열입니다. -latex-type-prefix, -latex-exception-prefix, -latex-module-prefix, -latex-module-type-prefix, -latex-class-prefix, -latex-class-type- 옵션을 사용할 수도 있습니다. 접두사, -latex-attribute-prefix 및 -latex-method-prefix.</target>
        </trans-unit>
        <trans-unit id="038e7979ee15f8f5c9e696afa315dfe00ad4b50f" translate="yes" xml:space="preserve">
          <source>Give arguments as command-line arguments for the program.</source>
          <target state="translated">프로그램에 대한 명령 줄 인수로 인수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="58fb754d9855207400580560fa5a499d34953865" translate="yes" xml:space="preserve">
          <source>Give help about the command command.</source>
          <target state="translated">명령 명령에 대한 도움말을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="05560101179d8cd9a5824eb9bc4979bd6dc98da1" translate="yes" xml:space="preserve">
          <source>Give help about the variable variable. The list of all debugger variables can be obtained with help set.</source>
          <target state="translated">변수 변수에 대한 도움말을 제공하십시오. 모든 디버거 변수 목록은 도움말 세트로 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="371d25ecfb079465a60b6b0a5de188a1933588cb" translate="yes" xml:space="preserve">
          <source>Give help about topic. Use help info to get a list of known topics.</source>
          <target state="translated">주제에 대한 도움을주십시오. 도움말 정보를 사용하여 알려진 주제 목록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="604df0eab7062b6f55919a0389be07618d669c2c" translate="yes" xml:space="preserve">
          <source>Give information about the given subject. For instance, info breakpoints will print the list of all breakpoints.</source>
          <target state="translated">주어진 주제에 대한 정보를 제공하십시오. 예를 들어, 정보 중단 점은 모든 중단 점 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="1454ccaeebb872ec2b102caf5995ceb3ec79caa0" translate="yes" xml:space="preserve">
          <source>Given a byte sequence &lt;code&gt;s&lt;/code&gt; of length &lt;code&gt;l&lt;/code&gt;, we can access each of the &lt;code&gt;l&lt;/code&gt; bytes of &lt;code&gt;s&lt;/code&gt; via its index in the sequence. Indexes start at &lt;code&gt;0&lt;/code&gt;, and we will call an index valid in &lt;code&gt;s&lt;/code&gt; if it falls within the range &lt;code&gt;[0...l-1]&lt;/code&gt; (inclusive). A position is the point between two bytes or at the beginning or end of the sequence. We call a position valid in &lt;code&gt;s&lt;/code&gt; if it falls within the range &lt;code&gt;[0...l]&lt;/code&gt; (inclusive). Note that the byte at index &lt;code&gt;n&lt;/code&gt; is between positions &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;n+1&lt;/code&gt;.</source>
          <target state="translated">길이가 &lt;code&gt;l&lt;/code&gt; 인 바이트 시퀀스 &lt;code&gt;s&lt;/code&gt; 가 주어지면 시퀀스 의 인덱스를 통해 &lt;code&gt;s&lt;/code&gt; 의 &lt;code&gt;l&lt;/code&gt; 바이트 각각에 액세스 할 수 있습니다 . 인덱스는 &lt;code&gt;0&lt;/code&gt; 에서 시작하며 &lt;code&gt;[0...l-1]&lt;/code&gt; (포함) 범위 내에 있으면 &lt;code&gt;s&lt;/code&gt; 에서 유효한 인덱스를 호출합니다 . 위치는 두 바이트 사이 또는 시퀀스의 시작 또는 끝 지점입니다. 범위 &lt;code&gt;[0...l]&lt;/code&gt; (포함) 내에 있으면 &lt;code&gt;s&lt;/code&gt; 에서 유효한 위치를 호출합니다 . 인덱스 &lt;code&gt;n&lt;/code&gt; 의 바이트는 위치 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;n+1&lt;/code&gt; 사이에 있습니다.</target>
        </trans-unit>
        <trans-unit id="2adb0b9ad2ceb5bfe49b0ecb92caf5f3fae05f4f" translate="yes" xml:space="preserve">
          <source>Given a string &lt;code&gt;s&lt;/code&gt; of length &lt;code&gt;l&lt;/code&gt;, we can access each of the &lt;code&gt;l&lt;/code&gt; characters of &lt;code&gt;s&lt;/code&gt; via its index in the sequence. Indexes start at &lt;code&gt;0&lt;/code&gt;, and we will call an index valid in &lt;code&gt;s&lt;/code&gt; if it falls within the range &lt;code&gt;[0...l-1]&lt;/code&gt; (inclusive). A position is the point between two characters or at the beginning or end of the string. We call a position valid in &lt;code&gt;s&lt;/code&gt; if it falls within the range &lt;code&gt;[0...l]&lt;/code&gt; (inclusive). Note that the character at index &lt;code&gt;n&lt;/code&gt; is between positions &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;n+1&lt;/code&gt;.</source>
          <target state="translated">길이가 &lt;code&gt;l&lt;/code&gt; 인 문자열 &lt;code&gt;s&lt;/code&gt; 가 주어지면 시퀀스의 인덱스를 통해 &lt;code&gt;s&lt;/code&gt; 의 &lt;code&gt;l&lt;/code&gt; 문자 각각에 액세스 할 수 있습니다 . 인덱스는 &lt;code&gt;0&lt;/code&gt; 에서 시작하며 &lt;code&gt;[0...l-1]&lt;/code&gt; (포함) 범위 내에 있으면 &lt;code&gt;s&lt;/code&gt; 에서 유효한 인덱스를 호출합니다 . 위치는 두 문자 사이 또는 문자열의 시작 또는 끝 지점입니다. 범위 &lt;code&gt;[0...l]&lt;/code&gt; (포함) 내에 있으면 &lt;code&gt;s&lt;/code&gt; 에서 유효한 위치를 호출합니다 . 인덱스 &lt;code&gt;n&lt;/code&gt; 의 문자는 위치 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;n+1&lt;/code&gt; 사이에 있습니다.</target>
        </trans-unit>
        <trans-unit id="6aa38b172ec5c9d2284f131cd775ec188b5d8628" translate="yes" xml:space="preserve">
          <source>Go back to the latest time recorded in the execution history. With an argument, do it count times.</source>
          <target state="translated">실행 이력에 기록 된 최근 시간으로 돌아갑니다. 인수를 사용하여 횟수를 세십시오.</target>
        </trans-unit>
        <trans-unit id="9b60e6e076c005d616d2d916072eb065e52ae28e" translate="yes" xml:space="preserve">
          <source>Going further, this construction can introduce local components inside a structure,</source>
          <target state="translated">더 나아가이 구조는 구조 내부에 로컬 구성 요소를 도입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0aeace163a6adb474f8a266503a9076db84dd3da" translate="yes" xml:space="preserve">
          <source>Govern whether unsafe object files are allowed to be dynamically linked.</source>
          <target state="translated">안전하지 않은 개체 파일을 동적으로 연결할 수 있는지 여부를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="d84ed49173cfa176fb1c99f2a3dec80f80b0aba6" translate="yes" xml:space="preserve">
          <source>Govern whether unsafe object files are allowed to be dynamically linked. A compilation unit is 'unsafe' if it contains declarations of external functions, which can break type safety. By default, dynamic linking of unsafe object files is not allowed. In native code, this function does nothing; object files with external functions are always allowed to be dynamically linked.</source>
          <target state="translated">안전하지 않은 개체 파일을 동적으로 연결할 수 있는지 여부를 관리합니다. 컴파일 단위는 외부 함수 선언이 포함 된 경우 '안전하지 않은'것으로, 형식 안전성을 손상시킬 수 있습니다. 기본적으로 안전하지 않은 개체 파일의 동적 연결은 허용되지 않습니다. 네이티브 코드에서이 함수는 아무 작업도 수행하지 않습니다. 외부 기능이있는 개체 파일은 항상 동적으로 연결될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9c481167a949ba9541e5157f33a16bc75dec6fe" translate="yes" xml:space="preserve">
          <source>Grammar definitions have the following format:</source>
          <target state="translated">문법 정의의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f1e950667e2e44adf45b58bf09492bae226c4f8" translate="yes" xml:space="preserve">
          <source>Group ID of the file's group</source>
          <target state="translated">파일 그룹의 그룹 ID</target>
        </trans-unit>
        <trans-unit id="6419b6179edfb45b0221e7cd7ed865964d5bab58" translate="yes" xml:space="preserve">
          <source>Growing and shrinking of the heap.</source>
          <target state="translated">힙의 증가 및 축소.</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="b8ec02c8c64e872c7dd1918af95f84fc205739fb" translate="yes" xml:space="preserve">
          <source>Hang up on last close.</source>
          <target state="translated">마지막 마감에 전화를 끊습니다.</target>
        </trans-unit>
        <trans-unit id="92d2f449cc1e7472e355886e114b989d0112305b" translate="yes" xml:space="preserve">
          <source>Hangup on controlling terminal</source>
          <target state="translated">제어 터미널에서 전화 끊기</target>
        </trans-unit>
        <trans-unit id="f156c0d6e4e285c95352406b7047bb7ecc056fb3" translate="yes" xml:space="preserve">
          <source>Hardware I/O error</source>
          <target state="translated">하드웨어 I / O 오류</target>
        </trans-unit>
        <trans-unit id="c5989bb5f874fe020eb5b05197afeb1595f9e30f" translate="yes" xml:space="preserve">
          <source>Hash tables and hash functions.</source>
          <target state="translated">해시 테이블 및 해시 함수.</target>
        </trans-unit>
        <trans-unit id="5152ba26a0f6c91803db8e6e54eb626e6caf15e9" translate="yes" xml:space="preserve">
          <source>Hash tables are hashed association tables, with in-place modification.</source>
          <target state="translated">해시 테이블은 내부 수정이있는 해시 된 연관 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="92bab01eaa07991ec1d5268ad63bfd41d8f81ce4" translate="yes" xml:space="preserve">
          <source>Hashtbl</source>
          <target state="translated">Hashtbl</target>
        </trans-unit>
        <trans-unit id="8de9b03544fae209b6d485a82f3fb0bc61712994" translate="yes" xml:space="preserve">
          <source>Having been given the following code, the compiler will inline loop into f, and then observe inv being invariant and always the pair formed by adding 42 and 43 to the argument x of the function f.</source>
          <target state="translated">다음 코드가 주어지면 컴파일러는 f로 루프를 인라인하고 inv가 불변이고 항상 함수 f의 인수 x에 42와 43을 더하여 형성된 쌍을 관찰합니다.</target>
        </trans-unit>
        <trans-unit id="00999d5419281dc73a86b97d51f054b1c30f6f29" translate="yes" xml:space="preserve">
          <source>Heap compaction is triggered when the estimated amount of &quot;wasted&quot; memory is more than &lt;code&gt;max_overhead&lt;/code&gt; percent of the amount of live data. If &lt;code&gt;max_overhead&lt;/code&gt; is set to 0, heap compaction is triggered at the end of each major GC cycle (this setting is intended for testing purposes only). If &lt;code&gt;max_overhead&amp;nbsp;&amp;gt;=&amp;nbsp;1000000&lt;/code&gt;, compaction is never triggered. If compaction is permanently disabled, it is strongly suggested to set &lt;code&gt;allocation_policy&lt;/code&gt; to 2. Default: 500.</source>
          <target state="translated">힙 압축은 &quot;낭비 된&quot;메모리의 예상 양이 라이브 데이터 양의 &lt;code&gt;max_overhead&lt;/code&gt; 퍼센트를 초과 할 때 트리거됩니다 . 경우 &lt;code&gt;max_overhead&lt;/code&gt; 가 0으로 설정되어, 힙 압축이 각 주요 GC주기의 끝에서 트리거 (이 설정은 목적으로 만 테스트를위한 것입니다). 경우 &lt;code&gt;max_overhead&amp;nbsp;&amp;gt;=&amp;nbsp;1000000&lt;/code&gt; , 압축 트리거되지 않습니다. 압축 영구적으로 사용할 경우, 강하게 설정에 제안 &lt;code&gt;allocation_policy&lt;/code&gt; 2. 기본에 : 500.</target>
        </trans-unit>
        <trans-unit id="f9c50122226f9d6dcf71b56ac7a7f8d8b4c3c78a" translate="yes" xml:space="preserve">
          <source>Heap compaction.</source>
          <target state="translated">힙 압축.</target>
        </trans-unit>
        <trans-unit id="758afbd2a13c2682e468e247eb3f98ab9f95fabf" translate="yes" xml:space="preserve">
          <source>Hence, a typical call to the formatted input function &lt;a href=&quot;scanf#VALbscanf&quot;&gt;&lt;code&gt;Scanf.bscanf&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;bscanf&amp;nbsp;ic&amp;nbsp;fmt&amp;nbsp;f&lt;/code&gt;, where:</source>
          <target state="translated">따라서 형식이 지정된 입력 함수 &lt;a href=&quot;scanf#VALbscanf&quot;&gt; &lt;code&gt;Scanf.bscanf&lt;/code&gt; 에&lt;/a&gt; 대한 일반적인 호출 은 &lt;code&gt;bscanf&amp;nbsp;ic&amp;nbsp;fmt&amp;nbsp;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14ac05929489e0ffc8dddd667d63b054e933d010" translate="yes" xml:space="preserve">
          <source>Hence, the clients do not have direct access to the balance, nor the history of their own accounts. Their only way to change their balance is to deposit or withdraw money. It is important to give the clients a class and not just the ability to create accounts (such as the promotional discount account), so that they can personalize their account. For instance, a client may refine the deposit and withdraw methods so as to do his own financial bookkeeping, automatically. On the other hand, the function discount is given as such, with no possibility for further personalization.</source>
          <target state="translated">따라서 고객은 잔액이나 자신의 계정 내역에 직접 액세스 할 수 없습니다. 잔액을 변경하는 유일한 방법은 돈을 입금하거나 인출하는 것입니다. 고객이 계정을 개인화 할 수 있도록 계정 (예 : 프로모션 할인 계정)을 만드는 기능뿐만 아니라 클래스를 제공하는 것이 중요합니다. 예를 들어, 고객은 자신의 재정 부기를 자동으로 수행하기 위해 입금 및 인출 방법을 조정할 수 있습니다. 반면에 기능 할인은 그대로 제공되며 추가 개인화 가능성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="03570ac90dade998e56b554e41239c2460db8925" translate="yes" xml:space="preserve">
          <source>Hence, this conversion always succeeds: it returns an empty string if the bounding condition holds when the scan begins.</source>
          <target state="translated">따라서이 변환은 항상 성공합니다. 스캔이 시작될 때 경계 조건이 유지되면 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c78f7a697615de15b124ff10dc612688faeddea6" translate="yes" xml:space="preserve">
          <source>Here (test () ()) is already (0,0,0) and cannot be further applied.</source>
          <target state="translated">여기서 (test () ())는 이미 (0,0,0)이며 더 이상 적용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="translated">여기 예시들이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c2d3820c838ff6ce0440d2b2700f2e77ee57f5a5" translate="yes" xml:space="preserve">
          <source>Here are some of the label names you will find throughout the libraries.</source>
          <target state="translated">다음은 라이브러리 전체에서 찾을 수있는 몇 가지 레이블 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a24a6072e91fffecf48135b656042082bc3b6e9a" translate="yes" xml:space="preserve">
          <source>Here f1 and f2 both accept the variant tags `A and `B, but the argument of `A is int for f1 and string for f2. In f&amp;rsquo;s type `C, only accepted by f1, disappears, but both argument types appear for `A as int &amp;amp; string. This means that if we pass the variant tag `A to f, its argument should be &lt;em&gt;both&lt;/em&gt;int and string. Since there is no such value, f cannot be applied to `A, and `B is the only accepted input.</source>
          <target state="translated">여기서 f1과 f2는 모두 변형 태그`A와`B를 허용하지만`A의 인수는 f1의 경우 int이고 f2의 경우 문자열입니다. f의 유형`C에서 f1에서만 허용되는 것은 사라지지만 두 인수 유형 모두`A에 대해 int &amp;amp; string으로 나타납니다. 즉, 변형 태그`A를 f에 전달하면 인수는 int와 문자열 이 &lt;em&gt;모두&lt;/em&gt; 되어야 합니다. 그런 값이 없기 때문에 f는`A에 적용 할 수없고`B는 유일하게 받아 들여지는 입력이다.</target>
        </trans-unit>
        <trans-unit id="561164ceab5ebc70c0d64deefe4330729b9658fb" translate="yes" xml:space="preserve">
          <source>Here is a concrete example:</source>
          <target state="translated">다음은 구체적인 예입니다.</target>
        </trans-unit>
        <trans-unit id="aba64a5365a5818e1799acb408be84f8f2c8e9d4" translate="yes" xml:space="preserve">
          <source>Here is a naive decoder example, using &lt;em&gt;babeltrace&lt;/em&gt;&amp;rsquo;s Python library, and &lt;em&gt;Python 3.8&lt;/em&gt;:</source>
          <target state="translated">다음은 &lt;em&gt;babeltrace&lt;/em&gt; 의 Python 라이브러리와 &lt;em&gt;Python 3.8을&lt;/em&gt; 사용하는 순진한 디코더 예입니다 .</target>
        </trans-unit>
        <trans-unit id="59957446a4d33ae4c96bc863ccc6ed285dc68c5a" translate="yes" xml:space="preserve">
          <source>Here is a template Makefile for a OCaml program.</source>
          <target state="translated">다음은 OCaml 프로그램 용 템플릿 Makefile입니다.</target>
        </trans-unit>
        <trans-unit id="f39d81d7a3d048698fdf682899353d5db74f1a73" translate="yes" xml:space="preserve">
          <source>Here is an example of a polymorphic function that takes the runtime representation of some type t and a value of the same type, then pretty-prints the value as a string:</source>
          <target state="translated">다음은 일부 유형 t의 런타임 표현과 동일한 유형의 값을 취한 다음 값을 문자열로 예쁘게 출력하는 다형성 함수의 예입니다.</target>
        </trans-unit>
        <trans-unit id="89e03958ef86650f0911d60b7395939fdf73500e" translate="yes" xml:space="preserve">
          <source>Here is an example of encapsulation of out-of-heap pointers of C type ty * inside Abstract_tag blocks. Section &lt;a href=&quot;#s%3Ac-intf-example&quot;&gt;20.6&lt;/a&gt; gives a more complete example using Custom_tag blocks.</source>
          <target state="translated">다음은 Abstract_tag 블록 내부에서 C 유형 ty *의 힙 외부 포인터를 캡슐화하는 예입니다. 섹션 &lt;a href=&quot;#s%3Ac-intf-example&quot;&gt;20.6&lt;/a&gt; 은 Custom_tag 블록을 사용하는보다 완전한 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="308b0d78062d0ad0003e582da279f23acb702da1" translate="yes" xml:space="preserve">
          <source>Here is an example using both singleton types and equality witnesses to implement dynamic types.</source>
          <target state="translated">다음은 단일 유형과 동등 증인을 모두 사용하여 동적 유형을 구현하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="a225c0d46c3cbb924c84a138670dbc8f06f0cc3e" translate="yes" xml:space="preserve">
          <source>Here is another example:</source>
          <target state="translated">다음은 또 다른 예입니다.</target>
        </trans-unit>
        <trans-unit id="284f8d0b01b42153fa84e0b1f00a100c6214fbc8" translate="yes" xml:space="preserve">
          <source>Here is how to develop a HTML generator handling your custom tags.</source>
          <target state="translated">사용자 정의 태그를 처리하는 HTML 생성기를 개발하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c2dbaf9de1c69f014cb64b41bd3b7343fac784a8" translate="yes" xml:space="preserve">
          <source>Here is how to rewrite the pretty-printer using fprintf:</source>
          <target state="translated">fprintf를 사용하여 pretty-printer를 다시 작성하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8aa1b2114ba8ea9e3cf06e2d4912d6761acbe4be" translate="yes" xml:space="preserve">
          <source>Here is the BNF grammar for the simple markup language used to format text descriptions.</source>
          <target state="translated">다음은 텍스트 설명의 형식을 지정하는 데 사용되는 간단한 마크 업 언어에 대한 BNF 문법입니다.</target>
        </trans-unit>
        <trans-unit id="388da24303f96c71ff151f75e86ac54ea859531d" translate="yes" xml:space="preserve">
          <source>Here is the C stub code for calling these functions from C:</source>
          <target state="translated">다음은 C에서 이러한 함수를 호출하기위한 C 스텁 코드입니다.</target>
        </trans-unit>
        <trans-unit id="7e741bd10b766cf1796a36394a51e7d62035fecd" translate="yes" xml:space="preserve">
          <source>Here is the definition for the corresponding lexer:</source>
          <target state="translated">다음은 해당 렉서에 대한 정의입니다.</target>
        </trans-unit>
        <trans-unit id="056f1f0f51eab79857c6e29e42baa016f78d2977" translate="yes" xml:space="preserve">
          <source>Here is the main program, that combines the parser with the lexer:</source>
          <target state="translated">다음은 파서를 렉서와 결합하는 주요 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="446b11c3be57d6c60ef1fd0ac52fa6e52063c114" translate="yes" xml:space="preserve">
          <source>Here is the same function written using the low-level allocation functions. We notice that the cons cells are small blocks and can be allocated with caml_alloc_small, and filled by direct assignments on their fields.</source>
          <target state="translated">다음은 저수준 할당 함수를 사용하여 작성된 동일한 함수입니다. cons 셀은 작은 블록이고 caml_alloc_small로 할당 될 수 있으며 필드에 직접 할당되어 채워질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18941c3984943cc307db931410d47e92fe4df6de" translate="yes" xml:space="preserve">
          <source>Here is where the debugger events (written ǧ) are located in the source code:</source>
          <target state="translated">다음은 소스 코드에서 디버거 이벤트 (ǧ로 작성)가있는 위치입니다.</target>
        </trans-unit>
        <trans-unit id="5b08d25e0d333e96aba2f91f119d4d2b7bffff20" translate="yes" xml:space="preserve">
          <source>Here the return type int is never mixed with a, so it is seen as non-ambiguous, and can be inferred. When using such partial type annotations we strongly suggest specifying the -principal mode, to check that inference is principal.</source>
          <target state="translated">여기서 반환 유형 int는 a와 혼합되지 않으므로 모호하지 않은 것으로 간주되며 추론 할 수 있습니다. 이러한 부분 유형 어노테이션을 사용할 때 추론이 원칙인지 확인하기 위해 -principal 모드를 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="10cb8cd98c3cdedd87ca3af31d62baffc2ee326e" translate="yes" xml:space="preserve">
          <source>Here type eq has only one constructor, and by matching on it one adds a local constraint allowing the conversion between a and b. By building such equality witnesses, one can make equal types which are syntactically different.</source>
          <target state="translated">여기서 유형 eq에는 생성자가 하나만 있으며 일치함으로써 a와 b 사이의 변환을 허용하는 로컬 제약 조건을 추가합니다. 이러한 평등 증인을 구축함으로써 구문이 다른 동일한 유형을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b271b0c3304eb3ee95f254204f52094adf07587" translate="yes" xml:space="preserve">
          <source>Here unix is the identifier for the alert. If this alert category is enabled, any reference to U.fork will produce a message at compile time, which can be turned or not into a fatal error.</source>
          <target state="translated">여기서 unix는 경고의 식별자입니다. 이 경고 범주가 활성화 된 경우 U.fork에 대한 모든 참조는 컴파일 타임에 메시지를 생성하며, 이는 치명적인 오류가 될 수도 있고 그렇지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e022f6709dae55bc7a223efa347b05eb7e8f59f3" translate="yes" xml:space="preserve">
          <source>Here we are seeing two phenomena. First, since this matching is open (the last case catches any tag), we obtain the type [&amp;gt; `A | `B] rather than [&amp;lt; `A | `B] in a closed matching. Then, since x is returned as is, input and return types are identical. The notation as 'a denotes such type sharing. If we apply f to yet another tag `E, it gets added to the list.</source>
          <target state="translated">여기서 우리는 두 가지 현상을보고 있습니다. 첫째,이 매칭이 열려 있기 때문에 (마지막 케이스는 모든 태그를 잡는다), 우리는 [&amp;gt;`A | [&amp;lt;`A | 닫힌 매칭에서`B]. 그러면 x가있는 그대로 반환되므로 입력 및 반환 유형이 동일합니다. 'a'라는 표기는 이러한 유형 공유를 나타냅니다. f를 또 다른 태그`E에 적용하면 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="fc63fa497589a6334b111c69df1747a0dd97fc2a" translate="yes" xml:space="preserve">
          <source>Here, OCaml has inferred that the possible choices for the type of {x;z} are first_record and middle_record, since the type last_record has no field z. Ocaml then picks the type middle_record as the last defined type between the two possibilities.</source>
          <target state="translated">여기서 OCaml은 last_record 유형에 z 필드가 없기 때문에 {x; z} 유형에 대해 가능한 선택이 first_record 및 middle_record라고 추론했습니다. 그런 다음 Ocaml은 두 가능성 사이에서 마지막으로 정의 된 유형으로 middle_record 유형을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="b060c78130d7f93cdd27667dbd10437fa706949d" translate="yes" xml:space="preserve">
          <source>Here, exposing the representation of strings is probably harmless. We do could also hide the representation of strings as we hid the currency in the class money of section &lt;a href=&quot;objectexamples#s%3Afriends&quot;&gt;3.17&lt;/a&gt;.</source>
          <target state="translated">여기서 문자열 표현을 노출하는 것은 아마도 무해 할 것입니다. &lt;a href=&quot;objectexamples#s%3Afriends&quot;&gt;3.17&lt;/a&gt; 섹션의 money 클래스에서 통화를 숨 겼기 때문에 문자열 표현을 숨길 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="acd4519239484578811a092a4daeaa544e7eb37d" translate="yes" xml:space="preserve">
          <source>Here, the private declaration ensures that in any value of type M.t, the argument to the B constructor is always a positive integer.</source>
          <target state="translated">여기서 private 선언은 Mt 유형의 모든 값에서 B 생성자에 대한 인수가 항상 양의 정수임을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="1ee51e87098916ce5e24ed6b88b7de69de869c00" translate="yes" xml:space="preserve">
          <source>Here, the registering of result is not strictly needed, because no allocation takes place after it gets its value, but it&amp;rsquo;s easier and safer to simply register all the local variables that have type value.</source>
          <target state="translated">여기서는 값을 얻은 후에 할당이 일어나지 않기 때문에 결과 등록이 꼭 필요한 것은 아니지만 값 유형이있는 모든 지역 변수를 등록하는 것이 더 쉽고 안전합니다.</target>
        </trans-unit>
        <trans-unit id="e432da26179fd3758bb19dd844fa23eec9ba8078" translate="yes" xml:space="preserve">
          <source>Here, the representation of the object is known only to a particular object. To make it available to other objects of the same class, we are forced to make it available to the whole world. However we can easily restrict the visibility of the representation using the module system.</source>
          <target state="translated">여기서 객체의 표현은 특정 객체에만 알려져 있습니다. 같은 클래스의 다른 개체에서 사용할 수 있도록하려면 전 세계에서 사용할 수 있도록해야합니다. 그러나 우리는 모듈 시스템을 사용하여 표현의 가시성을 쉽게 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fa5773c339f395510cdd47c4eb05d1e72c299e1" translate="yes" xml:space="preserve">
          <source>Hide the given complete module names in the generated documentation. modules is a list of complete module names separated by &amp;rsquo;,&amp;rsquo;, without blanks. For instance: Stdlib,M2.M3.</source>
          <target state="translated">생성 된 문서에서 주어진 전체 모듈 이름을 숨 깁니다. modules는 공백없이 ','로 구분 된 전체 모듈 이름 목록입니다. 예 : Stdlib, M2.M3.</target>
        </trans-unit>
        <trans-unit id="29ab4f5df7d32ff189d23eeac09eea791a2f04d4" translate="yes" xml:space="preserve">
          <source>High levels of inlining performed by Flambda may expose bugs in code thought previously to be correct. Take care, for example, not to add type annotations that claim some mutable value is always immediate if it might be possible for an unsafe operation to update it to a boxed value.</source>
          <target state="translated">Flambda가 수행하는 높은 수준의 인라인은 이전에 정확하다고 생각되는 코드에서 버그를 노출 할 수 있습니다. 예를 들어 안전하지 않은 작업이이를 boxed 값으로 업데이트 할 수있는 경우 일부 변경 가능한 값이 항상 즉각적이라고 주장하는 유형 주석을 추가하지 않도록주의하십시오.</target>
        </trans-unit>
        <trans-unit id="660cd8080dffe58889ce5763038bf5300dc31acd" translate="yes" xml:space="preserve">
          <source>High-level network connection functions</source>
          <target state="translated">높은 수준의 네트워크 연결 기능</target>
        </trans-unit>
        <trans-unit id="64fc91bf4f5322a745e7df5d0f9481f4d5653b51" translate="yes" xml:space="preserve">
          <source>High-level pipe and process management.</source>
          <target state="translated">높은 수준의 파이프 및 프로세스 관리.</target>
        </trans-unit>
        <trans-unit id="d630cd51e2ab49c23404375744103dcb9ddf12c0" translate="yes" xml:space="preserve">
          <source>High-level pipe and process management. The first argument specifies the command to run, and the second argument specifies the argument array passed to the command. This function runs the command in parallel with the program. The standard output of the command is redirected to a pipe, which can be read via the returned input channel.</source>
          <target state="translated">높은 수준의 파이프 및 프로세스 관리. 첫 번째 인수는 실행할 명령을 지정하고 두 번째 인수는 명령에 전달되는 인수 배열을 지정합니다. 이 함수는 프로그램과 병렬로 명령을 실행합니다. 명령의 표준 출력은 반환 된 입력 채널을 통해 읽을 수있는 파이프로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="a31d961a8252f33564ca1cdad952791054058fa6" translate="yes" xml:space="preserve">
          <source>High-level pipe and process management. This function runs the given command in parallel with the program. The standard output of the command is redirected to a pipe, which can be read via the returned input channel. The command is interpreted by the shell &lt;code&gt;/bin/sh&lt;/code&gt; (cf. &lt;code&gt;system&lt;/code&gt;).</source>
          <target state="translated">높은 수준의 파이프 및 프로세스 관리. 이 함수는 프로그램과 병렬로 주어진 명령을 실행합니다. 명령의 표준 출력은 반환 된 입력 채널을 통해 읽을 수있는 파이프로 리디렉션됩니다. 이 명령은 쉘 &lt;code&gt;/bin/sh&lt;/code&gt; 에 의해 해석됩니다 (참조 : &lt;code&gt;system&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3a456b402f5a87f65dd79e5881fc3236030290cf" translate="yes" xml:space="preserve">
          <source>High-level pipe and process management. This function runs the given command in parallel with the program. The standard output of the command is redirected to a pipe, which can be read via the returned input channel. The command is interpreted by the shell &lt;code&gt;/bin/sh&lt;/code&gt; (or &lt;code&gt;cmd.exe&lt;/code&gt; on Windows), cf. &lt;a href=&quot;unix#VALsystem&quot;&gt;&lt;code&gt;Unix.system&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;filename#VALquote_command&quot;&gt;&lt;code&gt;Filename.quote_command&lt;/code&gt;&lt;/a&gt; function can be used to quote the command and its arguments as appropriate for the shell being used. If the command does not need to be run through the shell, &lt;a href=&quot;unix#VALopen_process_args_in&quot;&gt;&lt;code&gt;Unix.open_process_args_in&lt;/code&gt;&lt;/a&gt; can be used as a more robust and more efficient alternative to &lt;a href=&quot;unix#VALopen_process_in&quot;&gt;&lt;code&gt;Unix.open_process_in&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">높은 수준의 파이프 및 프로세스 관리. 이 함수는 프로그램과 병렬로 주어진 명령을 실행합니다. 명령의 표준 출력은 반환 된 입력 채널을 통해 읽을 수있는 파이프로 리디렉션됩니다. 명령은 쉘 &lt;code&gt;/bin/sh&lt;/code&gt; (또는 Windows의 경우 &lt;code&gt;cmd.exe&lt;/code&gt; ) 에 의해 해석됩니다. &lt;a href=&quot;unix#VALsystem&quot;&gt; &lt;code&gt;Unix.system&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;filename#VALquote_command&quot;&gt; &lt;code&gt;Filename.quote_command&lt;/code&gt; 의&lt;/a&gt; 기능은 명령과 쉘에 맞게 인수를 사용하고 인용 할 수 있습니다. 쉘을 통해 명령을 실행할 필요가없는 경우 &lt;a href=&quot;unix#VALopen_process_args_in&quot;&gt; &lt;code&gt;Unix.open_process_args_in&lt;/code&gt; 을 Unix.open_process_in&lt;/a&gt; 보다 강력하고 효율적인 대안으로 &lt;a href=&quot;unix#VALopen_process_in&quot;&gt; &lt;code&gt;Unix.open_process_in&lt;/code&gt; &lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="a29172035d6d85dc663ba7e39082390589b775be" translate="yes" xml:space="preserve">
          <source>High-level process and redirection management</source>
          <target state="translated">높은 수준의 프로세스 및 리디렉션 관리</target>
        </trans-unit>
        <trans-unit id="2a33c2b6a314329b777f9efd6ddae94062b493db" translate="yes" xml:space="preserve">
          <source>Histogram of bucket sizes. This array &lt;code&gt;histo&lt;/code&gt; has length &lt;code&gt;max_bucket_length&amp;nbsp;+&amp;nbsp;1&lt;/code&gt;. The value of &lt;code&gt;histo.(i)&lt;/code&gt; is the number of buckets whose size is &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">버킷 크기의 히스토그램. 이 배열 &lt;code&gt;histo&lt;/code&gt; 길이 갖는다 &lt;code&gt;max_bucket_length&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; . &lt;code&gt;histo.(i)&lt;/code&gt; 의 값은 크기가 &lt;code&gt;i&lt;/code&gt; 인 버킷의 수입니다 .</target>
        </trans-unit>
        <trans-unit id="9fc8eded9808dd321a05fbe7b423579b8ee46feb" translate="yes" xml:space="preserve">
          <source>Host and protocol databases</source>
          <target state="translated">호스트 및 프로토콜 데이터베이스</target>
        </trans-unit>
        <trans-unit id="7e44bbbaded72ef9b5085984836ab8806136eb0e" translate="yes" xml:space="preserve">
          <source>Host and service information returned by &lt;a href=&quot;unix#VALgetnameinfo&quot;&gt;&lt;code&gt;Unix.getnameinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALgetnameinfo&quot;&gt; &lt;code&gt;Unix.getnameinfo&lt;/code&gt; 에서&lt;/a&gt; 반환하는 호스트 및 서비스 정보 입니다.</target>
        </trans-unit>
        <trans-unit id="a5a7e131a5cb8762553101bda765297974113fa2" translate="yes" xml:space="preserve">
          <source>Host is down</source>
          <target state="translated">호스트가 다운되었습니다</target>
        </trans-unit>
        <trans-unit id="e6b20c4f18fba11bf22b7eb25c422f7383d8a3f3" translate="yes" xml:space="preserve">
          <source>Hours 0..23</source>
          <target state="translated">시간 0..23</target>
        </trans-unit>
        <trans-unit id="a3b35a8d557fc5292ba116b9b094f27e8f1f0b10" translate="yes" xml:space="preserve">
          <source>How many rounds of optimisation to perform. See section &lt;a href=&quot;#ss%3Aflambda-rounds&quot;&gt;21.2.1&lt;/a&gt;.</source>
          <target state="translated">수행 할 최적화 라운드 수입니다. 섹션 &lt;a href=&quot;#ss%3Aflambda-rounds&quot;&gt;21.2.1을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54107178e78d43729885a7720437da1670a7ca51" translate="yes" xml:space="preserve">
          <source>How much to add to the major heap when increasing it. If this number is less than or equal to 1000, it is a percentage of the current heap size (i.e. setting it to 100 will double the heap size at each increase). If it is more than 1000, it is a fixed number of words that will be added to the heap. Default: 15.</source>
          <target state="translated">증가 할 때 주요 힙에 추가 할 양입니다. 이 숫자가 1000보다 작거나 같으면 현재 힙 크기의 백분율입니다 (즉, 100으로 설정하면 증가 할 때마다 힙 크기가 두 배가됩니다). 1000보다 크면 힙에 추가되는 고정 된 수의 단어입니다. 기본값 : 15.</target>
        </trans-unit>
        <trans-unit id="3e08adcc4e52311113e7bfcb35cebc7fc05cb528" translate="yes" xml:space="preserve">
          <source>However the following code will still return 42:</source>
          <target state="translated">그러나 다음 코드는 여전히 42를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8da81d46307b91fff8fddf943d3b6f54904f4acb" translate="yes" xml:space="preserve">
          <source>However, another semantics may be considered more natural here: any pair that has one side passing the test will take the branch. With this semantics the previous code fragment would be equivalent to</source>
          <target state="translated">그러나 여기서는 다른 의미론이 더 자연스러운 것으로 간주 될 수 있습니다. 한쪽이 테스트를 통과하는 모든 쌍이 분기를 차지합니다. 이 의미 체계를 사용하면 이전 코드 조각은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b11631e4eb742b73778c9e3a1a94f9ec22cd9e49" translate="yes" xml:space="preserve">
          <source>However, before referencing another compilation unit, an implementation of that unit must be present in memory. At start-up, the toplevel system contains implementations for all the modules in the the standard library. Implementations for user modules can be entered with the #load directive described above. Referencing a unit for which no implementation has been provided results in the error Reference to undefined global `...'.</source>
          <target state="translated">그러나 다른 컴파일 단위를 참조하기 전에 해당 단위의 구현이 메모리에 있어야합니다. 시작시 최상위 시스템에는 표준 라이브러리의 모든 모듈에 대한 구현이 포함됩니다. 사용자 모듈에 대한 구현은 위에서 설명한 #load 지시문을 사용하여 입력 할 수 있습니다. 구현이 제공되지 않은 유닛을 참조하면 Reference to undefined global`... '오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="41e8753db777bb602f194cf91bcdc0dd3f1d1843" translate="yes" xml:space="preserve">
          <source>However, if lexer rules are introduced with the shortest keyword in place of the parse keyword, then the &amp;ldquo;shortest match&amp;rdquo; rule applies: the shortest prefix of the input is selected. In case of tie, the regular expression that occurs earlier in the rule is still selected. This feature is not intended for use in ordinary lexical analyzers, it may facilitate the use of ocamllex as a simple text processing tool.</source>
          <target state="translated">그러나 구문 분석 키워드 대신 가장 짧은 키워드를 사용하여 어휘 분석기 규칙이 도입되면 &quot;가장 짧은 일치&quot;규칙이 적용됩니다. 입력의 가장 짧은 접두사가 선택됩니다. 동점의 경우 규칙의 앞부분에있는 정규식이 계속 선택됩니다. 이 기능은 일반 어휘 분석기에서 사용하기위한 것이 아니며, 간단한 텍스트 처리 도구로 ocamllex를 쉽게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="944f5f03f5c76a0cf57976a0a3d9c3e3e582504a" translate="yes" xml:space="preserve">
          <source>However, if the program is changed to include a call to Gc.eventlog_resume, events payloads can be seen again in the trace file.</source>
          <target state="translated">그러나 프로그램이 Gc.eventlog_resume에 대한 호출을 포함하도록 변경되면 추적 파일에서 이벤트 페이로드를 다시 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76abd1d96d1c865f566606abb7355db8f0cf0b1f" translate="yes" xml:space="preserve">
          <source>However, the abbreviation #c' cannot be defined directly in a similar way. It can only be defined by a class or a class-type definition. This is because a #-abbreviation carries an implicit anonymous variable .. that cannot be explicitly named. The closer you get to it is:</source>
          <target state="translated">그러나 약어 #c '는 유사한 방식으로 직접 정의 할 수 없습니다. 클래스 또는 클래스 유형 정의에 의해서만 정의 될 수 있습니다. 이는 #-약어가 명시 적으로 이름을 지정할 수없는 암시 적 익명 변수 ..를 전달하기 때문입니다. 더 가까이 다가 갈수록 :</target>
        </trans-unit>
        <trans-unit id="453dcc94eeb7e578d8082b01f6ebd6cec66637be" translate="yes" xml:space="preserve">
          <source>However, the bug might be fixed more safely by the following definition:</source>
          <target state="translated">그러나 다음 정의를 통해 버그를보다 안전하게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c720d37ad34c33bb2deaffa9bd67b5537585a52d" translate="yes" xml:space="preserve">
          <source>However, the domain of the coercion cannot always be omitted. In that case, the solution is to use the explicit form. Sometimes, a change in the class-type definition can also solve the problem</source>
          <target state="translated">그러나 강제 영역이 항상 생략 될 수는 없습니다. 이 경우 해결책은 명시 적 형식을 사용하는 것입니다. 때로는 클래스 유형 정의를 변경하여 문제를 해결할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0ee79bd6d9b251f8a82a82d67365c84132c706f" translate="yes" xml:space="preserve">
          <source>However, the former pattern is generally more appropriate, since the code for adjustment is part of the definition of the class and will be inherited.</source>
          <target state="translated">그러나 조정을위한 코드는 클래스 정의의 일부이며 상속되기 때문에 전자 패턴이 일반적으로 더 적절합니다.</target>
        </trans-unit>
        <trans-unit id="87a9a30d2a6c456b46a8651fb0691f17ba51e44f" translate="yes" xml:space="preserve">
          <source>However, the method escaped returns an object of the class ostring, and not an object of the current class. Hence, if the class is further extended, the method escaped will only return an object of the parent class.</source>
          <target state="translated">그러나 이스케이프 된 메서드는 현재 클래스의 개체가 아닌 ostring 클래스의 개체를 반환합니다. 따라서 클래스가 더 확장되면 이스케이프 된 메서드는 부모 클래스의 개체 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="de0a5f6db4da9e37735ab3e4188716aa13cde57d" translate="yes" xml:space="preserve">
          <source>However, the method fold of a given object can only be applied to functions that all have the same type:</source>
          <target state="translated">그러나 주어진 객체의 메서드 폴드는 모두 동일한 유형을 갖는 함수에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a60f20a882847a637b446acbd0fe979a6ba07d99" translate="yes" xml:space="preserve">
          <source>However, the most common instance of this problem, coercing self to its current class, is detected as a special case by the type checker, and properly typed.</source>
          <target state="translated">그러나이 문제의 가장 일반적인 인스턴스 (self를 현재 클래스로 강제 변환)는 유형 검사기에 의해 특수한 경우로 감지되고 적절하게 입력됩니다.</target>
        </trans-unit>
        <trans-unit id="64a966fbd7bd3413811c97fa093d7055e1ad7af5" translate="yes" xml:space="preserve">
          <source>However, the two classes of window_subject and window_observer are not mutually recursive.</source>
          <target state="translated">그러나 window_subject와 window_observer의 두 클래스는 상호 재귀 적이 지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e88098ed1eace82320b4d12264fb903f3a2eedeb" translate="yes" xml:space="preserve">
          <source>However, the type can be completely omitted in the class definition if it is already known, through inheritance or type constraints on self. Here is an example of method overriding.</source>
          <target state="translated">그러나 유형이 이미 알려진 경우 자체에 대한 상속 또는 유형 제약 조건을 통해 클래스 정의에서 유형을 완전히 생략 할 수 있습니다. 다음은 메서드 재정의의 예입니다.</target>
        </trans-unit>
        <trans-unit id="03d00554dc54be9a5828e5bbe84dea5a6534accc" translate="yes" xml:space="preserve">
          <source>However, the type of average len is less generic than the type of average_len, since it requires the type of the first and second argument to be the same:</source>
          <target state="translated">그러나 평균 len의 유형은 첫 번째 및 두 번째 인수의 유형이 동일해야하므로 average_len 유형보다 덜 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="7404314c946d8e6c9565bd2a5ce313929c2a9744" translate="yes" xml:space="preserve">
          <source>However, when there is only one argument, it is often left unlabeled.</source>
          <target state="translated">그러나 인수가 하나 뿐인 경우 종종 레이블이 지정되지 않은 상태로 남습니다.</target>
        </trans-unit>
        <trans-unit id="2c2bbe2630aa2be12c44f2d61e0d58373ebbab9e" translate="yes" xml:space="preserve">
          <source>However, writing a method for iterating over a stack is more problematic. A method fold would have type ('b -&amp;gt; 'a -&amp;gt; 'b) -&amp;gt; 'b -&amp;gt; 'b. Here 'a is the parameter of the stack. The parameter 'b is not related to the class 'a stack but to the argument that will be passed to the method fold. A naive approach is to make 'b an extra parameter of class stack:</source>
          <target state="translated">그러나 스택을 반복하는 메서드를 작성하는 것이 더 문제가됩니다. 메소드 폴드는 유형 ( 'b-&amp;gt;'a-&amp;gt; 'b)-&amp;gt;'b-&amp;gt; 'b를 갖습니다. 여기서 a는 스택의 매개 변수입니다. 'b'매개 변수는 'a 스택'클래스와는 관련이 없지만 메서드 폴드에 전달 될 인수와 관련이 있습니다. 순진한 접근 방식은 'b를 클래스 스택의 추가 매개 변수로 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c05320fb14f6e5d064c5c867a6851bf5b8c0cc4a" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine.</source>
          <target state="translated">쌍곡 코사인.</target>
        </trans-unit>
        <trans-unit id="4416a526cde7aaa7102f8da4d2d9fa9ab04023c8" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine. Argument is in radians.</source>
          <target state="translated">쌍곡 코사인. 인수는 라디안입니다.</target>
        </trans-unit>
        <trans-unit id="50ede5ec0ac7aaa68576130553561ac3c86fd2ea" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine.</source>
          <target state="translated">쌍곡 사인.</target>
        </trans-unit>
        <trans-unit id="1d254284446de08654124bede74d08ac424f8d08" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine. Argument is in radians.</source>
          <target state="translated">쌍곡 사인. 인수는 라디안입니다.</target>
        </trans-unit>
        <trans-unit id="b717ac903ad6476810dfdda159430e764de6cda7" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent.</source>
          <target state="translated">쌍곡 탄젠트.</target>
        </trans-unit>
        <trans-unit id="9f8a0e2dc65ee66bc03be8ca221132887633049c" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent. Argument is in radians.</source>
          <target state="translated">쌍곡 탄젠트. 인수는 라디안입니다.</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="e121a2cf51a1e00de2e2696e63934fe06010dee8" translate="yes" xml:space="preserve">
          <source>IEEE double precision (2 * 64 bits) floating-point complex numbers (&lt;a href=&quot;bigarray#TYPEcomplex64_elt&quot;&gt;&lt;code&gt;Bigarray.complex64_elt&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">IEEE 배정 밀도 (2 * 64 비트) 부동 소수점 복소수 ( &lt;a href=&quot;bigarray#TYPEcomplex64_elt&quot;&gt; &lt;code&gt;Bigarray.complex64_elt&lt;/code&gt; &lt;/a&gt; ),</target>
        </trans-unit>
        <trans-unit id="11bfef51ab97ad183ddf039572bf34ff80a7c9de" translate="yes" xml:space="preserve">
          <source>IEEE double precision (64 bits) floating-point numbers (&lt;a href=&quot;bigarray#TYPEfloat64_elt&quot;&gt;&lt;code&gt;Bigarray.float64_elt&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">IEEE 배정 밀도 (64 비트) 부동 소수점 숫자 ( &lt;a href=&quot;bigarray#TYPEfloat64_elt&quot;&gt; &lt;code&gt;Bigarray.float64_elt&lt;/code&gt; &lt;/a&gt; ),</target>
        </trans-unit>
        <trans-unit id="54ee940288ca134cc7cc56200b21d07e91766c05" translate="yes" xml:space="preserve">
          <source>IEEE single precision (2 * 32 bits) floating-point complex numbers (&lt;a href=&quot;bigarray#TYPEcomplex32_elt&quot;&gt;&lt;code&gt;Bigarray.complex32_elt&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">IEEE 단 정밀도 (2 * 32 비트) 부동 소수점 복소수 ( &lt;a href=&quot;bigarray#TYPEcomplex32_elt&quot;&gt; &lt;code&gt;Bigarray.complex32_elt&lt;/code&gt; &lt;/a&gt; ),</target>
        </trans-unit>
        <trans-unit id="e57793d87153a9ff4dbb8b05395ad2a5ce3baeca" translate="yes" xml:space="preserve">
          <source>IEEE single precision (32 bits) floating-point numbers (&lt;a href=&quot;bigarray#TYPEfloat32_elt&quot;&gt;&lt;code&gt;Bigarray.float32_elt&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">IEEE 단 정밀도 (32 비트) 부동 소수점 숫자 ( &lt;a href=&quot;bigarray#TYPEfloat32_elt&quot;&gt; &lt;code&gt;Bigarray.float32_elt&lt;/code&gt; &lt;/a&gt; ),</target>
        </trans-unit>
        <trans-unit id="73cbb2fc3a0a2ebb88df2442c2ac6e1ecdf80a05" translate="yes" xml:space="preserve">
          <source>Identical to &lt;a href=&quot;arg#VALread_arg&quot;&gt;&lt;code&gt;Arg.read_arg&lt;/code&gt;&lt;/a&gt; but assumes null character terminated command line arguments.</source>
          <target state="translated">&lt;a href=&quot;arg#VALread_arg&quot;&gt; &lt;code&gt;Arg.read_arg&lt;/code&gt; 와&lt;/a&gt; 동일 하지만 널 문자로 끝나는 명령 줄 인수를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="379fe7f50ad648171482ca58ad0ca76b53a14cbd" translate="yes" xml:space="preserve">
          <source>Identical to &lt;a href=&quot;arg#VALwrite_arg&quot;&gt;&lt;code&gt;Arg.write_arg&lt;/code&gt;&lt;/a&gt; but uses the null character for terminator instead of newline.</source>
          <target state="translated">&lt;a href=&quot;arg#VALwrite_arg&quot;&gt; &lt;code&gt;Arg.write_arg&lt;/code&gt; 와&lt;/a&gt; 동일 하지만 개행 대신 종료 자에 널 문자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="19fbdf2c6cc1f0d599912101bcc2320f7df6346b" translate="yes" xml:space="preserve">
          <source>Identifiers are sequences of letters, digits, _ (the underscore character), and ' (the single quote), starting with a letter or an underscore. Letters contain at least the 52 lowercase and uppercase letters from the ASCII set. The current implementation also recognizes as letters some characters from the ISO 8859-1 set (characters 192&amp;ndash;214 and 216&amp;ndash;222 as uppercase letters; characters 223&amp;ndash;246 and 248&amp;ndash;255 as lowercase letters). This feature is deprecated and should be avoided for future compatibility.</source>
          <target state="translated">식별자는 문자 또는 밑줄로 시작하는 문자, 숫자, _ (밑줄 문자) 및 '(작은 따옴표)의 시퀀스입니다. 문자에는 ASCII 세트에서 최소 52 개의 소문자 및 대문자가 포함됩니다. 현재 구현은 또한 ISO 8859-1 집합의 일부 문자를 문자로 인식합니다 (문자 192&amp;ndash;214 및 216&amp;ndash;222는 대문자로, 223&amp;ndash;246 및 248&amp;ndash;255는 소문자로). 이 기능은 더 이상 사용되지 않으며 향후 호환성을 위해 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="bf2182b3c192855891eae1040965f486e80e675f" translate="yes" xml:space="preserve">
          <source>Identifiers are used to give names to several classes of language objects and refer to these objects by name later:</source>
          <target state="translated">식별자는 여러 클래스의 언어 개체에 이름을 부여하고 나중에 이러한 개체를 이름으로 참조하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="252dcf0638748c4bce9e1885e5ea0b583d3a4258" translate="yes" xml:space="preserve">
          <source>Identifiers in struct custom_operations must be chosen carefully, since they must identify uniquely the data structure for serialization and deserialization operations. In particular, consider including a version number in the identifier; this way, the format of the data can be changed later, yet backward-compatible deserialisation functions can be provided.</source>
          <target state="translated">struct custom_operations의 식별자는 직렬화 및 역 직렬화 작업을위한 데이터 구조를 고유하게 식별해야하므로 신중하게 선택해야합니다. 특히 식별자에 버전 번호를 포함하는 것을 고려하십시오. 이런 식으로 데이터 형식은 나중에 변경할 수 있지만 이전 버전과 호환되는 역 직렬화 기능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9eef2b3f53493dc9c8afc794fc2b6d8165407f3" translate="yes" xml:space="preserve">
          <source>Identifiers starting with _ (an underscore character) are reserved for the OCaml runtime system; do not use them for your custom data. We recommend to use a URL (http://mymachine.mydomain.com/mylibrary/version-number) or a Java-style package name (com.mydomain.mymachine.mylibrary.version-number) as identifiers, to minimize the risk of identifier collision.</source>
          <target state="translated">_ (밑줄 문자)로 시작하는 식별자는 OCaml 런타임 시스템 용으로 예약되어 있습니다. 사용자 지정 데이터에 사용하지 마십시오. 위험을 최소화하려면 URL (http://mymachine.mydomain.com/mylibrary/version-number) 또는 Java 스타일 패키지 이름 (com.mydomain.mymachine.mylibrary.version-number)을 식별자로 사용하는 것이 좋습니다. 식별자 충돌의.</target>
        </trans-unit>
        <trans-unit id="1e9520ba53b50a96883830ad8837005fe5c1553f" translate="yes" xml:space="preserve">
          <source>Identify the types string and bytes, thereby making strings writable. This is intended for compatibility with old source code and should not be used with new software.</source>
          <target state="translated">유형 문자열과 바이트를 식별하여 문자열을 쓰기 가능하게 만듭니다. 이는 이전 소스 코드와의 호환성을위한 것이며 새 소프트웨어와 함께 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d30bcc4516a3f540514e40999e656b1a8b2df5e6" translate="yes" xml:space="preserve">
          <source>Identifying the exact context in which polymorphic types should be replaced by weak types in a modular way is a difficult question. Indeed the type system must handle the possibility that functions may hide persistent mutable states. For instance, the following function uses an internal reference to implement a delayed identity function</source>
          <target state="translated">다형성 유형이 모듈 방식으로 약한 유형으로 대체되어야하는 정확한 컨텍스트를 식별하는 것은 어려운 질문입니다. 실제로 유형 시스템은 함수가 영구적 인 변경 가능 상태를 숨길 수있는 가능성을 처리해야합니다. 예를 들어, 다음 함수는 내부 참조를 사용하여 지연된 식별 함수를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="29f7c4df05ef0f7f20a0f4baf77fac76b9a430dd" translate="yes" xml:space="preserve">
          <source>If '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; denotes an explicit polymorphic variable, and &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; denotes either an object or polymorphic variant type, the row variable of &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; is captured by '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;, and quantified upon.</source>
          <target state="translated">이 ' &lt;a href=&quot;lex#ident&quot;&gt;식별자는&lt;/a&gt; 명시 적 다형성 변수 및 나타낸다 &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; 나타낸다 객체 또는 다형 변형 유형을 하나의 행 변수 &lt;a href=&quot;#typexpr&quot;&gt;typexpr는&lt;/a&gt; 에 포착되는' &lt;a href=&quot;lex#ident&quot;&gt;식별자&lt;/a&gt; 및 정량시.</target>
        </trans-unit>
        <trans-unit id="1af83e49192d3b9055cda1d966bf6a005de3d634" translate="yes" xml:space="preserve">
          <source>If -cclib or -ccopt options are passed on the command line, these options are stored in the resulting .cmxalibrary. Then, linking with this library automatically adds back the -cclib and -ccopt options as if they had been provided on the command line, unless the -noautolink option is given.</source>
          <target state="translated">-cclib 또는 -ccopt 옵션이 명령 줄에 전달되면 이러한 옵션은 결과 .cmxalibrary에 저장됩니다. 그런 다음이 라이브러리와 연결하면 -noautolink 옵션이 제공되지 않는 한 명령 줄에 제공된 것처럼 -cclib 및 -ccopt 옵션이 자동으로 다시 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e7bf1c478aa7887dedd7adc474f78a180f3a1e68" translate="yes" xml:space="preserve">
          <source>If -custom, -cclib or -ccopt options are passed on the command line, these options are stored in the resulting .cmalibrary. Then, linking with this library automatically adds back the -custom, -cclib and -ccopt options as if they had been provided on the command line, unless the -noautolink option is given.</source>
          <target state="translated">-custom, -cclib 또는 -ccopt 옵션이 명령 줄에 전달되면 이러한 옵션은 결과 .cmalibrary에 저장됩니다. 그런 다음이 라이브러리와 연결하면 -noautolink 옵션이 제공되지 않는 한 명령 줄에 제공된 것처럼 -custom, -cclib 및 -ccopt 옵션이 자동으로 다시 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="dfecdd4c68900c96970ac5e52ae011bd5e9a0e2a" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; is a polymorphic method, its type should be known at the invocation site. This is true for instance if &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is the name of a fresh object (let&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; = new&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; &amp;hellip; ) or if there is a type constraint. Principality of the derivation can be checked in the -principal mode.</source>
          <target state="translated">경우 &lt;a href=&quot;names#method-name&quot;&gt;메소드 이름이&lt;/a&gt; 다형성 방법, 그 유형은 호출 사이트에서 알려 져야한다. 예를 들어 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 이 새로운 객체의 이름 (let &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; = new &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; &amp;hellip;)이거나 유형 제약이있는 경우에 해당됩니다. 파생의 공국은 -principal 모드에서 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc3a54443b9c753a78e2f01944d38b93f7a5164e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&amp;nbsp;&amp;gt;&amp;nbsp;3&lt;/code&gt;, alternate syntax is provided: you can write &lt;code&gt;a.{i1,&amp;nbsp;i2,&amp;nbsp;...,&amp;nbsp;iN}&amp;nbsp;&amp;lt;-&amp;nbsp;v&lt;/code&gt; instead of &lt;code&gt;Genarray.set&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&amp;nbsp;v&lt;/code&gt;. (The syntax &lt;code&gt;a.{...}&amp;nbsp;&amp;lt;-&amp;nbsp;v&lt;/code&gt; with one, two or three coordinates is reserved for updating one-, two- and three-dimensional arrays as described below.)</source>
          <target state="translated">경우 &lt;code&gt;N&amp;nbsp;&amp;gt;&amp;nbsp;3&lt;/code&gt; , 대체 구문이 제공됩니다 : 당신이 쓸 수 있습니다 &lt;code&gt;a.{i1,&amp;nbsp;i2,&amp;nbsp;...,&amp;nbsp;iN}&amp;nbsp;&amp;lt;-&amp;nbsp;v&lt;/code&gt; 대신 &lt;code&gt;Genarray.set&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&amp;nbsp;v&lt;/code&gt; . ( 1, 2 또는 3 개의 좌표가 있는 구문 &lt;code&gt;a.{...}&amp;nbsp;&amp;lt;-&amp;nbsp;v&lt;/code&gt; 는 아래에 설명 된대로 1 차원, 2 차원 및 3 차원 배열을 업데이트하기 위해 예약되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="4203c94450a640c56f05a68d1e3adc5328030de4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&amp;nbsp;&amp;gt;&amp;nbsp;3&lt;/code&gt;, alternate syntax is provided: you can write &lt;code&gt;a.{i1,&amp;nbsp;i2,&amp;nbsp;...,&amp;nbsp;iN}&lt;/code&gt; instead of &lt;code&gt;Genarray.get&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt;. (The syntax &lt;code&gt;a.{...}&lt;/code&gt; with one, two or three coordinates is reserved for accessing one-, two- and three-dimensional arrays as described below.)</source>
          <target state="translated">경우 &lt;code&gt;N&amp;nbsp;&amp;gt;&amp;nbsp;3&lt;/code&gt; , 대체 구문이 제공됩니다 : 당신이 쓸 수 있습니다 &lt;code&gt;a.{i1,&amp;nbsp;i2,&amp;nbsp;...,&amp;nbsp;iN}&lt;/code&gt; 대신 &lt;code&gt;Genarray.get&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; . ( 1, 2 또는 3 개의 좌표가 있는 구문 &lt;code&gt;a.{...}&lt;/code&gt; 는 아래 설명 된대로 1 차원, 2 차원 및 3 차원 배열에 액세스하기 위해 예약되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="809bd12920c48726136236802722ab0be08e88f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has C layout, the coordinates must be greater or equal than 0 and strictly less than the corresponding dimensions of &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has Fortran layout, the coordinates must be greater or equal than 1 and less or equal than the corresponding dimensions of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; C의 레이아웃을 가지며, 좌표 커야 또는 상응하는 치수보다 덜 엄격 0과 같해야 . 경우 &lt;code&gt;a&lt;/code&gt; 포트란 레이아웃이, 좌표 커야 또는 해당 치수보다 같 1과 작거나 같아야한다 . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d4132333c30642f60620cc9c7ac94c15c80f1f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;d&lt;/code&gt; is greater or equal than the current margin, it is ignored, and the current maximum indentation limit is kept.</source>
          <target state="translated">경우 &lt;code&gt;d&lt;/code&gt; 는 크거나 같 전류 마진, 그것은 무시되고, 현재의 최대 압입 제한은 유지된다.</target>
        </trans-unit>
        <trans-unit id="e9c0840202ac828ab864cc2fb33a9e5dc2f4e78e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;d&lt;/code&gt; is too large, the limit is set to the maximum admissible value (which is greater than &lt;code&gt;10&amp;nbsp;^&amp;nbsp;9&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;d&lt;/code&gt; 는 너무 큰 한계는 (이상이고 최대 허용 가능한 값으로 설정되는 &lt;code&gt;10&amp;nbsp;^&amp;nbsp;9&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ead1963ff555b5cb572c908c83e685f09cbbeebf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;Marshal.Compat_32&lt;/code&gt;, marshaling fails when it encounters an integer value outside the range &lt;code&gt;[-2{^30},&amp;nbsp;2{^30}-1]&lt;/code&gt; of integers that are representable on a 32-bit platform. This ensures that marshaled data generated on a 64-bit platform can be safely read back on a 32-bit platform. If &lt;code&gt;flags&lt;/code&gt; does not contain &lt;code&gt;Marshal.Compat_32&lt;/code&gt;, integer values outside the range &lt;code&gt;[-2{^30},&amp;nbsp;2{^30}-1]&lt;/code&gt; are marshaled, and can be read back on a 64-bit platform, but will cause an error at un-marshaling time when read back on a 32-bit platform. The &lt;code&gt;Mashal.Compat_32&lt;/code&gt; flag only matters when marshaling is performed on a 64-bit platform; it has no effect if marshaling is performed on a 32-bit platform.</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 포함 &lt;code&gt;Marshal.Compat_32&lt;/code&gt; 를 이 범위 외의 정수 값을 발견하면, 마샬링 실패 &lt;code&gt;[-2{^30},&amp;nbsp;2{^30}-1]&lt;/code&gt; 32 비트 플랫폼에서 표현할 수있는 정수. 이렇게하면 64 비트 플랫폼에서 생성 된 마샬링 된 데이터를 32 비트 플랫폼에서 안전하게 다시 읽을 수 있습니다. 경우에 &lt;code&gt;flags&lt;/code&gt; 가 포함되어 있지 않는 &lt;code&gt;Marshal.Compat_32&lt;/code&gt; 외부의 정수 값 범위 &lt;code&gt;[-2{^30},&amp;nbsp;2{^30}-1]&lt;/code&gt; 마샬링하고, 다시 64 비트 플랫폼에 판독 될 수 있지만, 에러가 발생할 32 비트 플랫폼에서 다시 읽을 때 마샬링 해제시. &lt;code&gt;Mashal.Compat_32&lt;/code&gt; 플래그는 64 비트 플랫폼에서 마샬링이 수행 될 때만 중요합니다. 마샬링이 32 비트 플랫폼에서 수행되는 경우에는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5f3049c4d97c242e2115fb288272135a4ad280a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; does not contain &lt;code&gt;Marshal.Closures&lt;/code&gt;, marshaling fails when it encounters a functional value inside &lt;code&gt;v&lt;/code&gt;: only 'pure' data structures, containing neither functions nor objects, can safely be transmitted between different programs. If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;Marshal.Closures&lt;/code&gt;, functional values will be marshaled as a the position in the code of the program together with the values corresponding to the free variables captured in the closure. In this case, the output of marshaling can only be read back in processes that run exactly the same program, with exactly the same compiled code. (This is checked at un-marshaling time, using an MD5 digest of the code transmitted along with the code position.)</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 포함되어 있지 않습니다 &lt;code&gt;Marshal.Closures&lt;/code&gt; 을 가 내부 함수 값 발생하면, 마샬링 실패 &lt;code&gt;v&lt;/code&gt; : 어느 기능이나 개체를 포함 전용 '순수'데이터 구조, 안전하게 다른 프로그램 사이에 전송 될 수있다. &lt;code&gt;flags&lt;/code&gt; 에 &lt;code&gt;Marshal.Closures&lt;/code&gt; 가 포함 된 경우 기능 값은 클로저에 캡처 된 자유 변수에 해당하는 값과 함께 프로그램 코드의 위치로 마샬링됩니다. 이 경우 마샬링의 출력은 정확히 동일한 컴파일 된 코드로 정확히 동일한 프로그램을 실행하는 프로세스에서만 다시 읽을 수 있습니다. (이것은 코드 위치와 함께 전송 된 코드의 MD5 다이제스트를 사용하여 마샬링 해제시 확인됩니다.)</target>
        </trans-unit>
        <trans-unit id="1603f8892a112133f08e3aa42f06e2938ef7d3e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; does not contain &lt;code&gt;Marshal.No_sharing&lt;/code&gt;, circularities and sharing inside the value &lt;code&gt;v&lt;/code&gt; are detected and preserved in the sequence of bytes produced. In particular, this guarantees that marshaling always terminates. Sharing between values marshaled by successive calls to &lt;code&gt;Marshal.to_channel&lt;/code&gt; is neither detected nor preserved, though. If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;Marshal.No_sharing&lt;/code&gt;, sharing is ignored. This results in faster marshaling if &lt;code&gt;v&lt;/code&gt; contains no shared substructures, but may cause slower marshaling and larger byte representations if &lt;code&gt;v&lt;/code&gt; actually contains sharing, or even non-termination if &lt;code&gt;v&lt;/code&gt; contains cycles.</source>
          <target state="translated">경우 &lt;code&gt;flags&lt;/code&gt; 포함되어 있지 &lt;code&gt;Marshal.No_sharing&lt;/code&gt; 을 , 값 및 공유 내부 원형도 &lt;code&gt;v&lt;/code&gt; 검출되고 일어난다 바이트 시퀀스에서 보존된다. 특히 이것은 마샬링이 항상 종료되도록 보장합니다. 그러나 &lt;code&gt;Marshal.to_channel&lt;/code&gt; 에 대한 연속 호출로 마샬링 된 값 간의 공유는 감지되거나 보존되지 않습니다. &lt;code&gt;flags&lt;/code&gt; 에 &lt;code&gt;Marshal.No_sharing&lt;/code&gt; 이 포함되어 있으면 공유가 무시됩니다. 이로 인해 &lt;code&gt;v&lt;/code&gt; 에 공유 된 하위 구조가없는 경우 마샬링이 빨라지 지만 &lt;code&gt;v&lt;/code&gt; 에 실제로 공유가 포함되어 있으면 마샬링이 느려지고 바이트 표현이 더 커지고 &lt;code&gt;v&lt;/code&gt; 에주기가 포함되어 있으면 비 종결이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c639bd784b8f54da115e8e01089e6eaa4c4437c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; raises an exception, both the exceptions passed to &lt;code&gt;fn&lt;/code&gt; and raised by &lt;code&gt;fn&lt;/code&gt; will be printed with their respective backtrace.</source>
          <target state="translated">경우 &lt;code&gt;fn&lt;/code&gt; 예외가 발생, 모두에 전달 된 예외 &lt;code&gt;fn&lt;/code&gt; 에 의해 제기 &lt;code&gt;fn&lt;/code&gt; 각각의 역 추적으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="16c27e9ffbfb7a1b0d49335a6eaeccc52715afa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is nonnegative, &lt;code&gt;Digest.channel&amp;nbsp;ic&amp;nbsp;len&lt;/code&gt; reads &lt;code&gt;len&lt;/code&gt; characters from channel &lt;code&gt;ic&lt;/code&gt; and returns their digest, or raises &lt;code&gt;End_of_file&lt;/code&gt; if end-of-file is reached before &lt;code&gt;len&lt;/code&gt; characters are read.</source>
          <target state="translated">경우 &lt;code&gt;len&lt;/code&gt; 음이 아닌이며, &lt;code&gt;Digest.channel&amp;nbsp;ic&amp;nbsp;len&lt;/code&gt; 읽어 &lt;code&gt;len&lt;/code&gt; 채널에서 문자를 &lt;code&gt;ic&lt;/code&gt; 자신의 다이제스트를 반환하거나 제기 &lt;code&gt;End_of_file&lt;/code&gt; 을 하기 전에-의 파일 마지막에 이르렀을 경우는 &lt;code&gt;len&lt;/code&gt; 문자를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="63c13d957f65e898b543bbbae2d79a73a515bf1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is nonnegative, &lt;code&gt;Digest.channel&amp;nbsp;ic&amp;nbsp;len&lt;/code&gt; reads &lt;code&gt;len&lt;/code&gt; characters from channel &lt;code&gt;ic&lt;/code&gt; and returns their digest, or raises &lt;code&gt;End_of_file&lt;/code&gt; if end-of-file is reached before &lt;code&gt;len&lt;/code&gt; characters are read. If &lt;code&gt;len&lt;/code&gt; is negative, &lt;code&gt;Digest.channel&amp;nbsp;ic&amp;nbsp;len&lt;/code&gt; reads all characters from &lt;code&gt;ic&lt;/code&gt; until end-of-file is reached and return their digest.</source>
          <target state="translated">경우 &lt;code&gt;len&lt;/code&gt; 음이 아닌이며, &lt;code&gt;Digest.channel&amp;nbsp;ic&amp;nbsp;len&lt;/code&gt; 읽어 &lt;code&gt;len&lt;/code&gt; 채널에서 문자를 &lt;code&gt;ic&lt;/code&gt; 자신의 다이제스트를 반환하거나 제기 &lt;code&gt;End_of_file&lt;/code&gt; 을 하기 전에-의 파일 마지막에 이르렀을 경우는 &lt;code&gt;len&lt;/code&gt; 문자를 읽습니다. 경우 &lt;code&gt;len&lt;/code&gt; 음수, &lt;code&gt;Digest.channel&amp;nbsp;ic&amp;nbsp;len&lt;/code&gt; 모든 문자를 읽어 &lt;code&gt;ic&lt;/code&gt; 에 도달하고 자신의 다이제스트를 반환되는 파일의 마지막에이를 때까지합니다.</target>
        </trans-unit>
        <trans-unit id="5c5226280b1d5d0eb026f180e4fc7ada42aef4f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;seq&amp;nbsp;=&amp;nbsp;[1;2;3]&lt;/code&gt;, then &lt;code&gt;map&amp;nbsp;f&amp;nbsp;seq&amp;nbsp;=&amp;nbsp;[f&amp;nbsp;1;&amp;nbsp;f&amp;nbsp;2;&amp;nbsp;f&amp;nbsp;3]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;seq&amp;nbsp;=&amp;nbsp;[1;2;3]&lt;/code&gt; 다음 &lt;code&gt;map&amp;nbsp;f&amp;nbsp;seq&amp;nbsp;=&amp;nbsp;[f&amp;nbsp;1;&amp;nbsp;f&amp;nbsp;2;&amp;nbsp;f&amp;nbsp;3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1398dea40559c8782ca5a31856feff2954ca0102" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shared&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, all modifications performed on the array are reflected in the file. This requires that &lt;code&gt;fd&lt;/code&gt; be opened with write permissions. If &lt;code&gt;shared&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, modifications performed on the array are done in memory only, using copy-on-write of the modified pages; the underlying file is not affected.</source>
          <target state="translated">경우 &lt;code&gt;shared&lt;/code&gt; 있다 &lt;code&gt;true&lt;/code&gt; , 배열에 수행 된 모든 수정 사항이 파일에 반영됩니다. 이를 위해서는 쓰기 권한으로 &lt;code&gt;fd&lt;/code&gt; 를 열어야합니다. 경우에 &lt;code&gt;shared&lt;/code&gt; 있다 &lt;code&gt;false&lt;/code&gt; 배열 수행 변형 복사 (copy-on-write) 수정 된 페이지를 사용하여, 메모리에서만 수행되며 기본 파일은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e714373b0cf3d52636fccd7cd853dd106784943" translate="yes" xml:space="preserve">
          <source>If OCAMLRUNPARAM is not found in the environment, then CAMLRUNPARAM will be used instead. If CAMLRUNPARAM is also not found, then the default values will be used.</source>
          <target state="translated">OCAMLRUNPARAM이 환경에 없으면 CAMLRUNPARAM이 대신 사용됩니다. CAMLRUNPARAM도 찾을 수없는 경우 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1e527c776a333861fa6472e7246947c15efddcc3" translate="yes" xml:space="preserve">
          <source>If OCAMLRUNPARAM is not found in the environment, then CAMLRUNPARAM will be used instead. If CAMLRUNPARAM is not found, then the default values will be used.</source>
          <target state="translated">OCAMLRUNPARAM이 환경에 없으면 CAMLRUNPARAM이 대신 사용됩니다. CAMLRUNPARAM이 없으면 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="52f378a118e070cfc5dc38fe1dedd97d46322a83" translate="yes" xml:space="preserve">
          <source>If a C primitive runs for a long time or performs potentially blocking input-output operations, it can explicitly release the master lock, enabling other OCaml threads to run concurrently with its operations. The C code must re-acquire the master lock before returning to OCaml. This is achieved with the following functions, declared in the include file &amp;lt;caml/threads.h&amp;gt;.</source>
          <target state="translated">C 프리미티브가 오랫동안 실행되거나 잠재적으로 차단 입력-출력 작업을 수행하는 경우 마스터 잠금을 명시 적으로 해제하여 다른 OCaml 스레드가 작업과 동시에 실행되도록 할 수 있습니다. C 코드는 OCaml로 돌아 가기 전에 마스터 잠금을 다시 획득해야합니다. 이는 포함 파일 &amp;lt;caml / threads.h&amp;gt;에 선언 된 다음 함수를 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="144bd9ae4b17d62ca7c4dd2000f8e45755b76c41" translate="yes" xml:space="preserve">
          <source>If a compatible dump file already exists in the current directory, then the profiling information is accumulated in this dump file. This allows, for instance, the profiling of several executions of a program on different inputs. Note that dump files produced by byte-code executables (compiled with ocamlcp) are compatible with the dump files produced by native executables (compiled with ocamloptp).</source>
          <target state="translated">호환 가능한 덤프 파일이 현재 디렉토리에 이미있는 경우 프로파일 링 정보가이 덤프 파일에 누적됩니다. 이를 통해 예를 들어 서로 다른 입력에서 프로그램의 여러 실행을 프로파일 링 할 수 있습니다. 바이트 코드 실행 파일 (ocamlcp로 컴파일 됨)에 의해 생성 된 덤프 파일은 원시 실행 파일 (ocamloptp로 컴파일 됨)에 의해 생성 된 덤프 파일과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="a268efd3934421fc54ada79e5bb503d1d9c1baf3" translate="yes" xml:space="preserve">
          <source>If a local definition occurs at the very beginning of a class definition, it will be evaluated when the class is created (just as if the definition was outside of the class). Otherwise, it will be evaluated when the object constructor is called.</source>
          <target state="translated">로컬 정의가 클래스 정의의 맨 처음에 발생하면 클래스가 생성 될 때 평가됩니다 (정의가 클래스 외부에있는 것처럼). 그렇지 않으면 개체 생성자가 호출 될 때 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="db03536423f4f4f52cd6fcffd6bb81f40d46d972" translate="yes" xml:space="preserve">
          <source>If a module (.ml file) doesn&amp;rsquo;t have a corresponding interface (.mli file), then compiling it with ocamlcp will produce object files (.cmi and .cmo) that are not compatible with the ones produced by ocamlc, which may lead to problems (if the .cmi or .cmo is still around) when switching between profiling and non-profiling compilations. To avoid this problem, you should always have a .mli file for each .ml file. The same problem exists with ocamloptp.</source>
          <target state="translated">모듈 (.ml 파일)에 해당 인터페이스 (.mli 파일)가없는 경우 ocamlcp로 컴파일하면 ocamlc에서 생성 한 것과 호환되지 않는 개체 파일 (.cmi 및 .cmo)이 생성됩니다. 프로파일 링 컴파일과 비 프로파일 링 컴파일 사이를 전환 할 때 문제가 발생합니다 (.cmi 또는 .cmo가 여전히 주변에있는 경우). 이 문제를 방지하려면 각 .ml 파일에 대해 항상 .mli 파일이 있어야합니다. ocamloptp에도 동일한 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="361ced0e78aa187459f0f204ee3347fb375be201" translate="yes" xml:space="preserve">
          <source>If a parameter is specified as optional (label prefixed by ?) in the type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, the corresponding argument will be automatically wrapped with the constructor Some, except if the argument itself is also prefixed by ?, in which case it is passed as is. If a non-labeled argument is passed, and its corresponding parameter is preceded by one or several optional parameters, then these parameters are &lt;em&gt;defaulted&lt;/em&gt;, &lt;em&gt;i.e.&lt;/em&gt; the value None will be passed for them. All other missing parameters (without corresponding argument), both optional and non-optional, will be kept, and the result of the function will still be a function of these missing parameters to the body of f.</source>
          <target state="translated">매개 변수가 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 유형에서 선택 사항 (접두사?가 붙은 레이블)로 지정 되면 해당 인수는 생성자 Some으로 자동 래핑됩니다. 단, 인수 자체에도?가 접두사로 붙은 경우에는 그대로 전달됩니다. . 레이블이 지정되지 않은 인수가 전달되고 해당 매개 변수 앞에 하나 또는 여러 개의 선택적 매개 변수가있는 경우 이러한 매개 변수는 &lt;em&gt;기본값이됩니다&lt;/em&gt; . &lt;em&gt;즉&lt;/em&gt; , None 값이 전달됩니다. 다른 모든 누락 된 매개 변수 (해당 인수가 없음) (선택적 및 비 선택적)는 유지되며 함수의 결과는 여전히 f의 본문에 대한 이러한 누락 된 매개 변수의 함수입니다.</target>
        </trans-unit>
        <trans-unit id="037083f7231a68d14836692b419032967beaefec" translate="yes" xml:space="preserve">
          <source>If all dimensions of the Bigarray are given, the file size is matched against the size of the Bigarray. If the file is larger than the Bigarray, only the initial portion of the file is mapped to the Bigarray. If the file is smaller than the big array, the file is automatically grown to the size of the Bigarray. This requires write permissions on &lt;code&gt;fd&lt;/code&gt;.</source>
          <target state="translated">Bigarray의 모든 차원이 제공되면 파일 크기가 Bigarray의 크기와 일치합니다. 파일이 Bigarray보다 크면 파일의 초기 부분 만 Bigarray에 매핑됩니다. 파일이 큰 배열보다 작 ​​으면 파일이 자동으로 Bigarray 크기로 커집니다. 이를 위해서는 &lt;code&gt;fd&lt;/code&gt; 에 대한 쓰기 권한이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="f1ff51fc7a2f5a64a4761a8119a652dcd1f52ad5" translate="yes" xml:space="preserve">
          <source>If an allocation-tracking or promotion-tracking function returns &lt;code&gt;None&lt;/code&gt;, memprof stops tracking the corresponding value.</source>
          <target state="translated">할당 추적 또는 프로모션 추적 함수가 &lt;code&gt;None&lt;/code&gt; 을 반환 하면 memprof는 해당 값 추적을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="c69093d47c505a2742c6e9e51b6c1bedfd5d8eaa" translate="yes" xml:space="preserve">
          <source>If an error occurs, &lt;code&gt;Arg.parse&lt;/code&gt; exits the program, after printing to standard error an error message as follows:</source>
          <target state="translated">오류가 발생하면 &lt;code&gt;Arg.parse&lt;/code&gt; 는 프로그램을 종료하고 표준 오류로 인쇄 한 후 다음과 같은 오류 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7467ecdd482037d95bee094a12bc474e7d7c71fc" translate="yes" xml:space="preserve">
          <source>If dynamic linking is supported on the target platform, a .so (respectively, .dll) shared library built from the C object files given as arguments, and automatically referencing the support libraries.</source>
          <target state="translated">대상 플랫폼에서 동적 연결이 지원되는 경우 인수로 제공된 C 개체 파일에서 빌드 된 .so (각각 .dll) 공유 라이브러리가 지원 라이브러리를 자동으로 참조합니다.</target>
        </trans-unit>
        <trans-unit id="30089f87216cb371be1de9772b23268664fcb2e2" translate="yes" xml:space="preserve">
          <source>If filename has the format mod.cmi, this means you have referenced the compilation unit mod, but its compiled interface could not be found. Fix: compile mod.mli or mod.ml first, to create the compiled interface mod.cmi.</source>
          <target state="translated">filename의 형식이 mod.cmi 인 경우 이는 컴파일 단위 모드를 참조했지만 컴파일 된 인터페이스를 찾을 수 없음을 의미합니다. 수정 : mod.mli 또는 mod.ml을 먼저 컴파일하여 컴파일 된 인터페이스 mod.cmi를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e9686537313707922f0bda205e9360d942cceb1a" translate="yes" xml:space="preserve">
          <source>If filename has the format mod.cmo, this means you are trying to link a bytecode object file that does not exist yet. Fix: compile mod.ml first.</source>
          <target state="translated">filename의 형식이 mod.cmo이면 아직 존재하지 않는 바이트 코드 개체 파일을 연결하려고한다는 의미입니다. 수정 : mod.ml을 먼저 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="ea2277b8c214def4154d2529e1b31435dc3cac3a" translate="yes" xml:space="preserve">
          <source>If filename has the format mod.cmo, this means you are trying to load with #load a bytecode object file that does not exist yet. Fix: compile mod.ml first.</source>
          <target state="translated">filename의 형식이 mod.cmo이면 아직 존재하지 않는 바이트 코드 객체 파일을 #load로로드하려고한다는 의미입니다. 수정 : mod.ml을 먼저 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="a3b22a28469371f7e82ec0e9c892a2ff1b6f3dae" translate="yes" xml:space="preserve">
          <source>If filename is the name of a self-executable bytecode file, this means that either that file does not exist, or that it failed to run the ocamlrun bytecode interpreter on itself. The second possibility indicates that OCaml has not been properly installed on your system.</source>
          <target state="translated">filename이 자체 실행 가능한 바이트 코드 파일의 이름이면 해당 파일이 존재하지 않거나 자체적으로 ocamlrun 바이트 코드 인터프리터를 실행하지 못했음을 의미합니다. 두 번째 가능성은 OCaml이 시스템에 제대로 설치되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4bcfc607ddea008cb5d00122be6715bc9b44adf1" translate="yes" xml:space="preserve">
          <source>If inlining the function is not clearly beneficial, then inlining will be performed &lt;em&gt;speculatively&lt;/em&gt; inside the function itself. The search for speculative inlining possibilities is controlled by two parameters: the &lt;em&gt;inlining threshold&lt;/em&gt; and the &lt;em&gt;inlining depth&lt;/em&gt;. (These are described in more detail below.)</source>
          <target state="translated">함수를 인라인하는 것이 분명히 유익하지 않은 경우 인라인은 함수 자체 내에서 &lt;em&gt;추측 적&lt;/em&gt; 으로 수행 됩니다. 추측 적 인라인 가능성 검색은 &lt;em&gt;인라인 임계 값&lt;/em&gt; 과 &lt;em&gt;인라인 깊이&lt;/em&gt; 의 두 가지 매개 변수에 의해 제어됩니다 . (아래에 자세히 설명되어 있습니다.)</target>
        </trans-unit>
        <trans-unit id="b44e70f5ebb940c1b0391784dfe69b24f75a37ab" translate="yes" xml:space="preserve">
          <source>If it does not split the line, then the &lt;code&gt;s1&lt;/code&gt; is emitted, then &lt;code&gt;n&lt;/code&gt; spaces, then &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">이 광고를 분할하지 않는 경우, &lt;code&gt;s1&lt;/code&gt; 다음, 출사 &lt;code&gt;n&lt;/code&gt; 다음 공간 &lt;code&gt;s2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e489f470887d376d32aea06970fd61f3751f9ee5" translate="yes" xml:space="preserve">
          <source>If it must be the case that code has to be written that triggers warning 59, but the code is known to actually be correct (for some definition of correct), then Sys.opaque_identity may be used to wrap the value before unsafe operations are performed upon it. Great care must be taken when doing this to ensure that the opacity is added at the correct place. It must be emphasised that this use of Sys.opaque_identity is only for exceptional cases. It should not be used in normal code or to try to guide the optimiser.</source>
          <target state="translated">경고 59를 트리거하는 코드를 작성해야하지만 코드가 실제로 올바른 것으로 알려진 경우 (올바른 정의에 대해) Sys.opaque_identity를 사용하여 안전하지 않은 작업이 수행되기 전에 값을 래핑 할 수 있습니다. 올라가서. 이 작업을 수행 할 때 불투명도가 올바른 위치에 추가되도록 세심한주의를 기울여야합니다. Sys.opaque_identity의 이러한 사용은 예외적 인 경우에만 사용된다는 점을 강조해야합니다. 일반 코드에서 사용하거나 옵티 마이저를 안내하기 위해 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="686a1fa801a7187be3913a423d2506998f796f50" translate="yes" xml:space="preserve">
          <source>If it splits the line, then it emits the &lt;code&gt;s3&lt;/code&gt; string, then an indent (according to the box rules), then an offset of &lt;code&gt;m&lt;/code&gt; spaces, then the &lt;code&gt;s4&lt;/code&gt; string.</source>
          <target state="translated">선을 분할하면 &lt;code&gt;s3&lt;/code&gt; 문자열, 들여 쓰기 (상자 규칙에 따라), &lt;code&gt;m&lt;/code&gt; 공백 의 오프셋 , &lt;code&gt;s4&lt;/code&gt; 문자열 을 차례로 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="72c5657376e07c2d9a3e4b1acbffce97186b2022" translate="yes" xml:space="preserve">
          <source>If n is zero or less, nothing happens.</source>
          <target state="translated">n이 0 이하이면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f705b48d406f77c738cb668c2876820fc083247" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;~random&lt;/code&gt; parameter is given, hash tables are created in non-random mode by default. This default can be changed either programmatically by calling &lt;a href=&quot;hashtbl#VALrandomize&quot;&gt;&lt;code&gt;Hashtbl.randomize&lt;/code&gt;&lt;/a&gt; or by setting the &lt;code&gt;R&lt;/code&gt; flag in the &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;~random&lt;/code&gt; 매개 변수를 지정 하지 않으면 기본적으로 비 랜덤 모드로 해시 테이블이 생성됩니다. 이 기본값은 &lt;a href=&quot;hashtbl#VALrandomize&quot;&gt; &lt;code&gt;Hashtbl.randomize&lt;/code&gt; &lt;/a&gt; 를 호출 하거나 &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; 환경 변수 에 &lt;code&gt;R&lt;/code&gt; 플래그를 설정하여 프로그래밍 방식으로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a0c0ccea27bc9150aae629a6c3346f36d1efee2" translate="yes" xml:space="preserve">
          <source>If no element of &lt;code&gt;s&lt;/code&gt; is changed by &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt; is returned unchanged. (If each output of &lt;code&gt;f&lt;/code&gt; is physically equal to its input, the returned set is physically equal to &lt;code&gt;s&lt;/code&gt;.)</source>
          <target state="translated">어떠한 경우 소자 &lt;code&gt;s&lt;/code&gt; 에 의해 변경되지 &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;s&lt;/code&gt; 그대로 리턴된다. ( &lt;code&gt;f&lt;/code&gt; 의 각 출력 이 물리적으로 입력과 같으면 반환 된 집합은 물리적으로 &lt;code&gt;s&lt;/code&gt; 와 같습니다 .)</target>
        </trans-unit>
        <trans-unit id="6eb7e9f1e3b33fc029b525d2db6314c65ae09453" translate="yes" xml:space="preserve">
          <source>If no element of &lt;code&gt;s&lt;/code&gt; is changed or dropped by &lt;code&gt;f&lt;/code&gt; (if &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;Some&amp;nbsp;x&lt;/code&gt; for each element &lt;code&gt;x&lt;/code&gt;), then &lt;code&gt;s&lt;/code&gt; is returned unchanged: the result of the function is then physically equal to &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 의 요소 가 &lt;code&gt;f&lt;/code&gt; 에 의해 변경되거나 삭제 되지 않으면 ( &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;Some&amp;nbsp;x&lt;/code&gt; 각 요소 &lt;code&gt;x&lt;/code&gt; 에 대해 일부 x ) &lt;code&gt;s&lt;/code&gt; 는 변경되지 않은 상태로 반환됩니다. 함수의 결과는 물리적으로 &lt;code&gt;s&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="daf74767dc0fd113b13b0f693b209b1bddcc18bd" translate="yes" xml:space="preserve">
          <source>If no scriptfile is given on the command line, the toplevel system enters interactive mode: phrases are read on standard input, results are printed on standard output, errors on standard error. End-of-file on standard input terminates ocaml (see also the #quit directive in section &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;).</source>
          <target state="translated">명령 줄에 스크립트 파일이 제공되지 않으면 최상위 시스템은 대화 형 모드로 전환됩니다. 표준 입력에서는 구문을 읽고 결과는 표준 출력에서 ​​인쇄하고 표준 오류에서는 오류를 표시합니다. 표준 입력의 파일 끝은 ocaml을 종료합니다 (섹션 &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt; 의 #quit 지시문 참조 ).</target>
        </trans-unit>
        <trans-unit id="00843a889b066ce4bbfdb0caf01e681f6e157c16" translate="yes" xml:space="preserve">
          <source>If not already set on a tabulation marker, the insertion point moves to the first tabulation marker on the right and the pretty-printer prints &lt;code&gt;nspaces&lt;/code&gt; spaces.</source>
          <target state="translated">표 표식에 아직 설정하지 않은 경우 삽입 지점이 오른쪽의 첫 번째 표 표식으로 이동하고 pretty-printer는 &lt;code&gt;nspaces&lt;/code&gt; 공백을 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="94467592d909a5e6ff672d3db0301b49ec0281fc" translate="yes" xml:space="preserve">
          <source>If scriptfile is given on the command-line to ocaml, the toplevel system enters script mode: the contents of the file are read as a sequence of OCaml phrases and executed, as per the #use directive (section &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;). The outcome of the evaluation is not printed. On reaching the end of file, the ocaml command exits immediately. No commands are read from standard input. Sys.argv is transformed, ignoring all OCaml parameters, and starting with the script file name in Sys.argv.(0).</source>
          <target state="translated">스크립트 파일이 명령 줄에서 ocaml로 지정되면 최상위 시스템은 스크립트 모드로 들어갑니다. 파일의 내용은 #use 지시문 (섹션 &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt; )에 따라 OCaml 구문의 시퀀스로 읽혀 실행됩니다 . 평가 결과는 인쇄되지 않습니다. 파일 끝에 도달하면 ocaml 명령이 즉시 종료됩니다. 표준 입력에서 읽은 명령이 없습니다. Sys.argv는 모든 OCaml 매개 변수를 무시하고 Sys.argv. (0)의 스크립트 파일 이름으로 시작하여 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="2363061063be15ef51f3f1a53b8b361078b64015" translate="yes" xml:space="preserve">
          <source>If several arguments of a function bear the same label (or no label), they will not commute among themselves, and order matters. But they can still commute with other arguments.</source>
          <target state="translated">함수의 여러 인수에 동일한 레이블이 있거나 레이블이없는 경우 서로 통근하지 않으며 순서가 중요합니다. 그러나 그들은 여전히 ​​다른 논쟁으로 통근 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96cd48975e8c5184733565898c33a2f04befd578" translate="yes" xml:space="preserve">
          <source>If several locally abstract types need to be introduced, it is possible to use the syntax fun(type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;)-&amp;gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; as syntactic sugar for fun(type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;)-&amp;gt; &amp;hellip; -&amp;gt;fun(type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;)-&amp;gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;. For instance,</source>
          <target state="translated">여러 로컬 추상 유형을 도입해야하는 경우 fun (type &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; )-&amp;gt; &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; 구문을 fun (type &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; )-&amp;gt;&amp;hellip;-&amp;gt; 구문 설탕으로 사용할 수 있습니다. fun (type &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; )-&amp;gt; &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; . 예를 들어</target>
        </trans-unit>
        <trans-unit id="c10affbc46bccdf7827eee5ed3b04a7a8c3bd654" translate="yes" xml:space="preserve">
          <source>If several patterns match the argument v, the one that occurs first in the function definition is selected. If none of the patterns matches the argument, the exception Match_failure is raised.</source>
          <target state="translated">여러 패턴이 인수 v와 일치하면 함수 정의에서 가장 먼저 발생하는 패턴이 선택됩니다. 인수와 일치하는 패턴이 없으면 Match_failure 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ebba3b8dc9a7c52a91ba9cffdda6fc1e415cedf9" translate="yes" xml:space="preserve">
          <source>If several regular expressions match a prefix of the input, the &amp;ldquo;longest match&amp;rdquo; rule applies: the regular expression that matches the longest prefix of the input is selected. In case of tie, the regular expression that occurs earlier in the rule is selected.</source>
          <target state="translated">여러 정규식이 입력 접두사와 일치하는 경우 &quot;가장 긴 일치&quot;규칙이 적용됩니다. 입력의 가장 긴 접두사와 일치하는 정규식이 선택됩니다. 동점의 경우 규칙의 앞부분에있는 정규식이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="33304e670e9c468dea25676c51b9d5272c2372ac" translate="yes" xml:space="preserve">
          <source>If several specifications are present for the same method, they must have compatible types. Any non-private specification of a method forces it to be public.</source>
          <target state="translated">동일한 방법에 대해 여러 사양이있는 경우 호환 가능한 유형이 있어야합니다. 비공개가 아닌 메소드 사양은 공개로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c4e1e876c6319fc9f155e179bfdf47b95b75ca18" translate="yes" xml:space="preserve">
          <source>If shared libraries are not supported, the following commands are performed instead:</source>
          <target state="translated">공유 라이브러리가 지원되지 않는 경우 다음 명령이 대신 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ba2e2086c5f2a5e933519c52e53ae93fb624fa5d" translate="yes" xml:space="preserve">
          <source>If shared libraries are supported, this performs the following commands:</source>
          <target state="translated">공유 라이브러리가 지원되는 경우 다음 명령을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="13e2923fd0864337da7b7bba91620b61b5fbb40a" translate="yes" xml:space="preserve">
          <source>If such a suffix does not exist, &lt;code&gt;extension&amp;nbsp;name&lt;/code&gt; is the empty string.</source>
          <target state="translated">이러한 접미사가없는 경우 &lt;code&gt;extension&amp;nbsp;name&lt;/code&gt; 은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="8535daa443a5878fa88dbc8284c870ced5360d87" translate="yes" xml:space="preserve">
          <source>If such speculation shows that performing some inlining inside the function would be beneficial, then such inlining is performed and the resulting function inlined at the original call site.</source>
          <target state="translated">그러한 추측이 함수 내부에서 인라인을 수행하는 것이 유익하다는 것을 보여 주면 그러한 인라인이 수행되고 결과 함수가 원래 호출 사이트에서 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="35d741725edfca4bf5d082c545ffd10d25a7dc01" translate="yes" xml:space="preserve">
          <source>If the -inlining-report option is provided to the compiler then a file will be emitted corresponding to each round of optimisation. For the OCaml source file &lt;em&gt;basename&lt;/em&gt;.ml the files are named &lt;em&gt;basename&lt;/em&gt;.&lt;em&gt;round&lt;/em&gt;.inlining.org, with &lt;em&gt;round&lt;/em&gt; a zero-based integer. Inside the files, which are formatted as &amp;ldquo;org mode&amp;rdquo;, will be found English prose describing the decisions that the inliner took.</source>
          <target state="translated">-inlining-report 옵션이 컴파일러에 제공되면 각 최적화 라운드에 해당하는 파일이 생성됩니다. OCaml 소스 파일 &lt;em&gt;basename&lt;/em&gt; .ml의 경우 파일 이름은 &lt;em&gt;basename&lt;/em&gt; 입니다. &lt;em&gt;라운드&lt;/em&gt; 와 .inlining.org, &lt;em&gt;둥근&lt;/em&gt; 제로하는 정수. &quot;org 모드&quot;로 포맷 된 파일 안에는 인라이너가 취한 결정을 설명하는 영어 산문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="02572179ec480974381c99532d430d9fdd5784e0" translate="yes" xml:space="preserve">
          <source>If the C code wishes to catch exceptions escaping the OCaml function, it can use the functions caml_callback_exn, caml_callback2_exn, caml_callback3_exn, caml_callbackN_exn. These functions take the same arguments as their non-_exn counterparts, but catch escaping exceptions and return them to the C code. The return value v of the caml_callback*_exn functions must be tested with the macro Is_exception_result(v). If the macro returns &amp;ldquo;false&amp;rdquo;, no exception occurred, and v is the value returned by the OCaml function. If Is_exception_result(v) returns &amp;ldquo;true&amp;rdquo;, an exception escaped, and its value (the exception descriptor) can be recovered using Extract_exception(v).</source>
          <target state="translated">C 코드가 OCaml 함수를 이스케이프하는 예외를 포착하려는 경우 caml_callback_exn, caml_callback2_exn, caml_callback3_exn, caml_callbackN_exn 함수를 사용할 수 있습니다. 이러한 함수는 _exn이 아닌 해당 함수와 동일한 인수를 사용하지만 이스케이프 예외를 포착하여 C 코드로 반환합니다. caml_callback * _exn 함수의 반환 값 v는 매크로 Is_exception_result (v)를 사용하여 테스트해야합니다. 매크로가 &quot;false&quot;를 반환하면 예외가 발생하지 않았으며 v는 OCaml 함수에서 반환 된 값입니다. Is_exception_result (v)가 &quot;true&quot;를 반환하면 예외가 이스케이프되고 해당 값 (예외 설명자)은 Extract_exception (v)을 사용하여 복구 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="630c7dca602616b8abb79db5171a1e3090693e64" translate="yes" xml:space="preserve">
          <source>If the OCaml function returned with an exception, Extract_exception should be applied to the exception result prior to calling a function that may trigger garbage collection. Otherwise, if v is reachable during garbage collection, the runtime can crash since v does not contain a valid value.</source>
          <target state="translated">OCaml 함수가 예외와 함께 반환되면 가비지 수집을 트리거 할 수있는 함수를 호출하기 전에 Extract_exception을 예외 결과에 적용해야합니다. 그렇지 않으면 가비지 콜렉션 중에 v에 도달 할 수있는 경우 v에 유효한 값이 포함되어 있지 않기 때문에 런타임이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0b4dadfc6f13fd380794c2f3f44ed17e6443186" translate="yes" xml:space="preserve">
          <source>If the argument is true, check information paths during type-checking, to make sure that all types are derived in a principal way. If the argument is false, do not check information paths.</source>
          <target state="translated">인수가 true이면 유형 검사 중에 정보 경로를 확인하여 모든 유형이 주요 방식으로 파생되었는지 확인합니다. 인수가 거짓이면 정보 경로를 확인하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e1a5cad8cc059522a4fee23706b19131d9a15d23" translate="yes" xml:space="preserve">
          <source>If the array is of size four or less, the expression will create a fresh block and write the values into it one by one. There is no reference to the initialising array as a whole.</source>
          <target state="translated">배열의 크기가 4 이하인 경우 식은 새 블록을 만들고 값을 하나씩 씁니다. 초기화 배열 전체에 대한 참조는 없습니다.</target>
        </trans-unit>
        <trans-unit id="87ba360226aef14289ad1c74a68816339b211735" translate="yes" xml:space="preserve">
          <source>If the call is not inside an exception handler, the returned backtrace is unspecified. If the call is after some exception-catching code (before in the handler, or in a when-guard during the matching of the exception handler), the backtrace may correspond to a later exception than the handled one.</source>
          <target state="translated">호출이 예외 처리기 내부에 없으면 반환 된 역 추적이 지정되지 않습니다. 호출이 일부 예외 포착 코드 (처리기 전 또는 예외 처리기 일치 중 when-guard) 이후 인 경우, 역 추적은 처리 된 예외보다 나중 예외에 해당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3699887b7248910d086e978d7aa47ea89c5f6bf9" translate="yes" xml:space="preserve">
          <source>If the computation of &lt;code&gt;x&lt;/code&gt; raises an exception, it is unspecified whether &lt;code&gt;force_val&amp;nbsp;x&lt;/code&gt; raises the same exception or &lt;a href=&quot;lazy#EXCEPTIONUndefined&quot;&gt;&lt;code&gt;Lazy.Undefined&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 계산 에서 예외가 발생하면 &lt;code&gt;force_val&amp;nbsp;x&lt;/code&gt; 가 동일한 예외를 발생 하는지 Lazy.Undefined 인지 여부가 지정되지 &lt;a href=&quot;lazy#EXCEPTIONUndefined&quot;&gt; &lt;code&gt;Lazy.Undefined&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9cc33d7f4560db5b0839b107c0565d6921cb731" translate="yes" xml:space="preserve">
          <source>If the contents of the global variable v are seldom modified after registration, better performance can be achieved by calling caml_register_generational_global_root(&amp;amp;v) to register v (after its initialization with a valid value, but before any allocation or call to the GC functions), and caml_remove_generational_global_root(&amp;amp;v) to un-register it. In this case, you must not modify the value of v directly, but you must use caml_modify_generational_global_root(&amp;amp;v,x) to set it to x. The garbage collector takes advantage of the guarantee that v is not modified between calls to caml_modify_generational_global_root to scan it less often. This improves performance if the modifications of v happen less often than minor collections.</source>
          <target state="translated">등록 후 전역 변수 v의 내용이 거의 수정되지 않는 경우 caml_register_generational_global_root (&amp;amp; v)를 호출하여 v를 등록함으로써 (유효한 값으로 초기화 한 후, GC 함수에 대한 할당 또는 호출 전) 더 나은 성능을 얻을 수 있습니다. caml_remove_generational_global_root (&amp;amp; v)를 사용하여 등록을 취소합니다. 이 경우 v 값을 직접 수정해서는 안되지만 caml_modify_generational_global_root (&amp;amp; v, x)를 사용하여 x로 설정해야합니다. 가비지 컬렉터는 v가 덜 자주 스캔하기 위해 caml_modify_generational_global_root 호출 사이에 수정되지 않는다는 보장을 활용합니다. 이는 v의 수정이 사소한 콜렉션보다 덜 자주 발생하는 경우 성능을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="9bd80053dd21abc2f1786fb591aa8cce37e37cef" translate="yes" xml:space="preserve">
          <source>If the element is a custom block it is not copied.</source>
          <target state="translated">요소가 사용자 블록이면 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86e7bd7a523ed97a9611f3d74bd5a6534bba8424" translate="yes" xml:space="preserve">
          <source>If the environment variable OCAMLPROF_DUMP is set when the program exits, its value is used as the file name instead of ocamlprof.dump.</source>
          <target state="translated">프로그램이 종료 될 때 환경 변수 OCAMLPROF_DUMP가 설정되면 해당 값이 ocamlprof.dump 대신 파일 이름으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="59b3e7898281ba717abfe0d4e0cfd223c49314a7" translate="yes" xml:space="preserve">
          <source>If the estimated benefit exceeds the increase in code size then the inlined version of the function will be kept. Otherwise the function will not be inlined.</source>
          <target state="translated">예상 이익이 코드 크기 증가를 초과하면 함수의 인라인 버전이 유지됩니다. 그렇지 않으면 함수가 인라인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="526eae114b014fd19cf9658190d7f52e6cfa38d8" translate="yes" xml:space="preserve">
          <source>If the first form is used, with a single integer specified, the value will apply to all rounds.</source>
          <target state="translated">단일 정수가 지정된 첫 번째 형식을 사용하면 값이 모든 라운드에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="928707051883035a6a2490616c9c4666b3b8054b" translate="yes" xml:space="preserve">
          <source>If the format &lt;code&gt;fmt&lt;/code&gt; has some &lt;code&gt;%r&lt;/code&gt; indications, the corresponding formatted input functions must be provided &lt;em&gt;before&lt;/em&gt; receiver function &lt;code&gt;f&lt;/code&gt;. For instance, if &lt;code&gt;read_elem&lt;/code&gt; is an input function for values of type &lt;code&gt;t&lt;/code&gt;, then &lt;code&gt;bscanf&amp;nbsp;ic&amp;nbsp;&quot;%r;&quot;&amp;nbsp;read_elem&amp;nbsp;f&lt;/code&gt; reads a value &lt;code&gt;v&lt;/code&gt; of type &lt;code&gt;t&lt;/code&gt; followed by a &lt;code&gt;';'&lt;/code&gt; character, and returns &lt;code&gt;f&amp;nbsp;v&lt;/code&gt;.</source>
          <target state="translated">형식 &lt;code&gt;fmt&lt;/code&gt; 에 일부 &lt;code&gt;%r&lt;/code&gt; 표시가있는 경우 해당 형식화 된 입력 함수가 수신기 함수 &lt;code&gt;f&lt;/code&gt; &lt;em&gt;전에&lt;/em&gt; 제공되어야합니다 . 예를 들어, &lt;code&gt;read_elem&lt;/code&gt; 이 &lt;code&gt;t&lt;/code&gt; 유형의 값에 대한 입력 함수 인 경우 &lt;code&gt;bscanf&amp;nbsp;ic&amp;nbsp;&quot;%r;&quot;&amp;nbsp;read_elem&amp;nbsp;f&lt;/code&gt; 는 &lt;code&gt;';'&lt;/code&gt; 이 뒤에 오는 &lt;code&gt;t&lt;/code&gt; 유형 의 값 &lt;code&gt;v&lt;/code&gt; 를 읽습니다 . 문자이고 &lt;code&gt;f&amp;nbsp;v&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="eaebb55224d923b372338ae66433b2e72d6c1dbb" translate="yes" xml:space="preserve">
          <source>If the function f does not return, but raises an exception that escapes the scope of the application, then this exception is propagated to the next enclosing OCaml code, skipping over the C code. That is, if an OCaml function f calls a C function g that calls back an OCaml function h that raises a stray exception, then the execution of g is interrupted and the exception is propagated back into f.</source>
          <target state="translated">함수 f가 반환되지 않지만 응용 프로그램의 범위를 벗어나는 예외가 발생하면이 예외는 C 코드를 건너 뛰고 다음 둘러싸는 OCaml 코드로 전파됩니다. 즉, OCaml 함수 f가 stray 예외를 발생시키는 OCaml 함수 h를 다시 호출하는 C 함수 g를 호출하면 g 실행이 중단되고 예외가 f로 다시 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="83eb3ec9e1e3f016668f3beedc828600400ab1c4" translate="yes" xml:space="preserve">
          <source>If the function in question is involved in a recursive group then unboxing of specialised arguments may be immediately replicated across the group based on the dataflow between invariant arguments.</source>
          <target state="translated">문제의 함수가 재귀 적 그룹에 포함 된 경우 특수 인수의 박싱 해제는 불변 인수 간의 데이터 흐름을 기반으로 그룹 전체에 즉시 복제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2217874359b71d84901f80859119f98479923fa3" translate="yes" xml:space="preserve">
          <source>If the given directory starts with +, it is taken relative to the standard library directory. For instance, -I +unix adds the subdirectory unix of the standard library to the search path.</source>
          <target state="translated">주어진 디렉토리가 +로 시작하면 표준 라이브러리 디렉토리를 기준으로합니다. 예를 들어, -I + unix는 표준 라이브러리의 하위 디렉토리 unix를 검색 경로에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="031818e3fc1bf521466078fbb8e8be0fa0c0fb91" translate="yes" xml:space="preserve">
          <source>If the hash table was created in non-randomized mode, the order in which the bindings are enumerated is reproducible between successive runs of the program, and even between minor versions of OCaml. For randomized hash tables, the order of enumeration is entirely random.</source>
          <target state="translated">해시 테이블이 무작위 화되지 않은 모드로 생성 된 경우 바인딩이 열거되는 순서는 프로그램의 연속 실행간에, 심지어 OCaml의 부 버전 간에도 재현 할 수 있습니다. 무작위 해시 테이블의 경우 열거 순서는 전적으로 무작위입니다.</target>
        </trans-unit>
        <trans-unit id="cea4ad36d0decb77c4fb5241f963c83815372664" translate="yes" xml:space="preserve">
          <source>If the interface file x.mli exists, the implementation x.ml is checked against the corresponding compiled interface x.cmi, which is assumed to exist. If no interface x.mli is provided, the compilation of x.ml produces a compiled interface file x.cmi in addition to the compiled object code file x.cmo. The file x.cmi produced corresponds to an interface that exports everything that is defined in the implementation x.ml.</source>
          <target state="translated">인터페이스 파일 x.mli가있는 경우 구현 x.ml은 존재하는 것으로 간주되는 해당 컴파일 된 인터페이스 x.cmi에 대해 확인됩니다. x.mli 인터페이스가 제공되지 않으면 x.ml을 컴파일하면 컴파일 된 개체 코드 파일 x.cmo와 함께 컴파일 된 인터페이스 파일 x.cmi가 생성됩니다. 생성 된 x.cmi 파일은 x.ml 구현에 정의 된 모든 것을 내보내는 인터페이스에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="269f2549d5b0381849a3b6047e9fc8dbb8d0667d" translate="yes" xml:space="preserve">
          <source>If the libunwind library is not available on the system then it will not be possible for Spacetime to profile allocations occurring within C stubs. If the libunwind library is available but in an unusual location then that location may be specified to the configure script using the -libunwinddir option (or alternatively, using separate -libunwindinclude and -libunwindlib options).</source>
          <target state="translated">libunwind 라이브러리를 시스템에서 사용할 수 없으면 Spacetime이 C 스텁 내에서 발생하는 할당을 프로파일 링 할 수 없습니다. libunwind 라이브러리를 사용할 수 있지만 비정상적인 위치에있는 경우 해당 위치는 -libunwinddir 옵션을 사용하여 구성 스크립트에 지정 될 수 있습니다 (또는 별도의 -libunwindinclude 및 -libunwindlib 옵션 사용).</target>
        </trans-unit>
        <trans-unit id="60d15c75ed47033c0e5c57361e18bc1a28cba287" translate="yes" xml:space="preserve">
          <source>If the make install command is run after having built the native toplevel then the ocamlnat program (either from the source or the installation directory) may be invoked directly rather than using make natruntop.</source>
          <target state="translated">기본 최상위 레벨을 빌드 한 후 make install 명령을 실행하면 make natruntop을 사용하는 대신 ocamlnat 프로그램 (소스 또는 설치 디렉토리에서)을 직접 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57209cae8f03f39e03c3475e4a102e0e7a017631" translate="yes" xml:space="preserve">
          <source>If the named file is a directory, raises:</source>
          <target state="translated">명명 된 파일이 디렉토리 인 경우 다음을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="bfd36587a150830740da4e5b8e12155c63eb3d08" translate="yes" xml:space="preserve">
          <source>If the option letter is not recognized, the whole parameter is ignored; if the equal sign or the number is missing, the value is taken as 1; if the multiplier is not recognized, it is ignored.</source>
          <target state="translated">옵션 문자가 인식되지 않으면 전체 매개 변수가 무시됩니다. 등호 또는 숫자가 누락 된 경우 값은 1로 간주됩니다. 승수가 인식되지 않으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c6cd58692278da4b786278a83770b1d8a2642045" translate="yes" xml:space="preserve">
          <source>If the pretty-printer splits the line in the box, &lt;code&gt;d&lt;/code&gt; is added to the current indentation.</source>
          <target state="translated">pretty-printer가 상자의 줄을 분할하면 &lt;code&gt;d&lt;/code&gt; 가 현재 들여 쓰기에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7ef6acdf03d0f87940ead45d51f79d17fc14180f" translate="yes" xml:space="preserve">
          <source>If the pretty-printer splits the line in the box, offset &lt;code&gt;d&lt;/code&gt; is added to the current indentation.</source>
          <target state="translated">pretty-printer가 상자에서 줄을 분할하면 오프셋 &lt;code&gt;d&lt;/code&gt; 가 현재 들여 쓰기에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="361c4ed6a2a48ff1b42271ec1d3dc181183d0467" translate="yes" xml:space="preserve">
          <source>If the pretty-printer splits the line, &lt;code&gt;offset&lt;/code&gt; is added to the current indentation.</source>
          <target state="translated">pretty-printer가 줄을 분할하면 &lt;code&gt;offset&lt;/code&gt; 이 현재 들여 쓰기에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4599aba8403a5552d8717f0e5fce41f734d86310" translate="yes" xml:space="preserve">
          <source>If the previous command has been successful, a blank line (typing just RET) will repeat it.</source>
          <target state="translated">이전 명령이 성공한 경우 빈 줄 (RET 입력)이 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="0350c5cb5c18afaa3af79f9ae281828c0226be68" translate="yes" xml:space="preserve">
          <source>If the remaining arguments to process are of the form &lt;code&gt;[&quot;-foo&quot;;&amp;nbsp;&quot;arg&quot;]&amp;nbsp;@&amp;nbsp;rest&lt;/code&gt; where &quot;foo&quot; is registered as &lt;code&gt;Expand&amp;nbsp;f&lt;/code&gt;, then the arguments &lt;code&gt;f&amp;nbsp;&quot;arg&quot;&amp;nbsp;@&amp;nbsp;rest&lt;/code&gt; are processed. Only allowed in &lt;code&gt;parse_and_expand_argv_dynamic&lt;/code&gt;.</source>
          <target state="translated">처리 할 나머지 인수가 &lt;code&gt;[&quot;-foo&quot;;&amp;nbsp;&quot;arg&quot;]&amp;nbsp;@&amp;nbsp;rest&lt;/code&gt; 여기서 &quot;foo&quot;가 &lt;code&gt;Expand&amp;nbsp;f&lt;/code&gt; 로 등록 된 다음 인수 &lt;code&gt;f&amp;nbsp;&quot;arg&quot;&amp;nbsp;@&amp;nbsp;rest&lt;/code&gt; 가 처리됩니다. &lt;code&gt;parse_and_expand_argv_dynamic&lt;/code&gt; 에서만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3dc02053bcf7f04a6a9f0b8d70f87bdfcc90ced" translate="yes" xml:space="preserve">
          <source>If the second form is used, zero-based &lt;em&gt;round&lt;/em&gt; integers specify values which are to be used only for those rounds.</source>
          <target state="translated">두 번째 형식이 사용되는 경우 0부터 시작하는 &lt;em&gt;라운드&lt;/em&gt; 정수는 해당 라운드에만 사용할 값을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="23147d67da9a3357fd714ad7bd712b354fdbe027" translate="yes" xml:space="preserve">
          <source>If the type [('a,'b,&amp;hellip;)] &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; = [`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;| &amp;hellip; |`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] is defined, then the pattern #&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; is a shorthand for the following or-pattern: (`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;(_:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;)| &amp;hellip; |`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;(_:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;)). It matches all values of type [&amp;lt;&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;].</source>
          <target state="translated">유형 [( 'a,'b,&amp;hellip;)] &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; = [` &lt;a href=&quot;names#tag-name&quot;&gt;tag-name &lt;/a&gt;&lt;sub&gt;1 &lt;/sub&gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; | &amp;hellip; |` &lt;a href=&quot;names#tag-name&quot;&gt;tag-name &lt;/a&gt;&lt;sub&gt;n &lt;/sub&gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; ]이 정의되면 패턴 # &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; 은 다음 or-pattern의 약어입니다 : (` &lt;a href=&quot;names#tag-name&quot;&gt;tag-name &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; (_ : &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ) |&amp;hellip; |` &lt;a href=&quot;names#tag-name&quot;&gt;tag-name &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; (_ : &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; )). 유형 [&amp;lt; &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; ] 의 모든 값과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="6934c8c175e921d36d82df098f9aaaaba6060c8a" translate="yes" xml:space="preserve">
          <source>If the value of its argument its None, the printer returned by pp_option printer prints None otherwise it uses the provided printer to print Some .</source>
          <target state="translated">인수의 값이 None이면 pp_option 프린터가 반환 한 프린터는 None을 인쇄합니다. 그렇지 않으면 제공된 프린터를 사용하여 Some을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="02bfb791a4aefd529589de31a34af8d62fb05206" translate="yes" xml:space="preserve">
          <source>If there are no safe modules along a dependency cycle, an error is raised</source>
          <target state="translated">종속성주기에 안전한 모듈이 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0a28412182364c49d7b1c7ff896cdb24ffe2090a" translate="yes" xml:space="preserve">
          <source>If there is no next tabulation marker on the right, the pretty-printer splits the line at this point, then insertion point moves to the leftmost tabulation marker of the box.</source>
          <target state="translated">오른쪽에 다음 표 표시가 없으면 pretty-printer가이 지점에서 선을 분할 한 다음 삽입 지점이 상자의 가장 왼쪽 표 표식으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="93e986ba889d48b83a3b585c29a13d802a48e88f" translate="yes" xml:space="preserve">
          <source>If there is no special character in the argument that needs escaping, return the original string itself, not a copy.</source>
          <target state="translated">이스케이프가 필요한 인수에 특수 문자가 없으면 복사본이 아닌 원래 문자열 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="650636821137156f9b89bf7d83008b87c146680c" translate="yes" xml:space="preserve">
          <source>If using automatic snapshots the presence of the &lt;code&gt;save_event_for_automatic_snapshots&lt;/code&gt; function, below, should be noted.</source>
          <target state="translated">자동 스냅 샷을 사용하는 경우 아래 의 &lt;code&gt;save_event_for_automatic_snapshots&lt;/code&gt; 기능이 있음을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="af7f9f8dc289a45aa7abb853b1e6e0f99bdabaa2" translate="yes" xml:space="preserve">
          <source>If v is a OCaml value representing a Bigarray, the expression Caml_ba_data_val(v) returns a pointer to the data part of the array. This pointer is of type void * and can be cast to the appropriate C type for the array (e.g. double [], char [][10], etc).</source>
          <target state="translated">v가 Bigarray를 나타내는 OCaml 값이면 Caml_ba_data_val (v) 표현식은 배열의 데이터 부분에 대한 포인터를 리턴합니다. 이 포인터는 void * 유형이며 배열에 적합한 C 유형 (예 : double [], char [] [10] 등)으로 캐스트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e57d1cd0be66bfd79fceee72f6e460b8f16042be" translate="yes" xml:space="preserve">
          <source>If we ignore labels, which will only be meaningful at function application, this is equivalent to</source>
          <target state="translated">함수 적용에서만 의미가있는 레이블을 무시하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a12dddd1ed24396bf32965cc98f1c85d9b5a043d" translate="yes" xml:space="preserve">
          <source>If we were able to coerce x to the type xy ref as a variable xy, we could use xy to store the value `Y inside the reference and then use the x value to read this content as a value of type x, which would break the type system.</source>
          <target state="translated">xy를 변수 xy로 xy ref 유형으로 강제 변환 할 수 있다면 xy를 사용하여 참조 내부에`Y 값을 저장 한 다음 x 값을 사용하여이 내용을 x 유형의 값으로 읽을 수 있습니다. 유형 시스템.</target>
        </trans-unit>
        <trans-unit id="938dc89ad7bb75f8b6b5234d0f82aeee4a2b6b87" translate="yes" xml:space="preserve">
          <source>If you are using internal C variables, do not redefine them by hand. You should import those variables by including the corresponding header files. The representation of those variables has already changed once in OCaml 4.10, and is still under evolution. If your code relies on such internal and brittle properties, it will be broken at some point in time.</source>
          <target state="translated">내부 C 변수를 사용하는 경우 수동으로 재정의하지 마십시오. 해당 헤더 파일을 포함하여 해당 변수를 가져와야합니다. 이러한 변수의 표현은 OCaml 4.10에서 이미 한 번 변경되었으며 여전히 진화 중입니다. 코드가 내부적이고 부서지기 쉬운 속성에 의존하는 경우 특정 시점에 손상 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="4684963cdc7330d90fbde44bf1de388d5ea4d30c" translate="yes" xml:space="preserve">
          <source>If you are using the native-code compiler ocamlopt, the -custom flag is not needed, as the final linking phase of ocamlopt always builds a standalone executable. To build a mixed OCaml/C executable, execute the ocamlopt command with:</source>
          <target state="translated">네이티브 코드 컴파일러 ocamlopt를 사용하는 경우 ocamlopt의 최종 연결 단계가 항상 독립 실행 형 실행 파일을 빌드하므로 -custom 플래그가 필요하지 않습니다. 혼합 된 OCaml / C 실행 파일을 빌드하려면 다음을 사용하여 ocamlopt 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="a9e51a95e1449f47a9a997884fd92f2e9640f19f" translate="yes" xml:space="preserve">
          <source>If you are using the opam package manager, you should install the corresponding graphics package:</source>
          <target state="translated">opam 패키지 관리자를 사용하는 경우 해당 그래픽 패키지를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e2b19145c81285ba95d5206a4aef01e47305c6b" translate="yes" xml:space="preserve">
          <source>If you choose to use the compatibility library, you must link your programs as follows:</source>
          <target state="translated">호환성 라이브러리를 사용하기로 선택한 경우 다음과 같이 프로그램을 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="a7aae036d3d0305ff1e81bf7e09e7219b84487d6" translate="yes" xml:space="preserve">
          <source>If you have a look at modules ending in Labels in the standard library, you will see that function types have annotations you did not have in the functions you defined yourself.</source>
          <target state="translated">표준 라이브러리에서 레이블로 끝나는 모듈을 살펴보면 함수 유형에 사용자가 직접 정의한 함수에없는 주석이 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d8ec7283da5154d3c5f9741853ea4731d05f757" translate="yes" xml:space="preserve">
          <source>If you really need name to have a polymorphic type, turn its defining expression into a function by adding an extra parameter. For instance, instead of writing</source>
          <target state="translated">다형성 유형을 갖기 위해 이름이 정말로 필요한 경우 추가 매개 변수를 추가하여 정의 표현식을 함수로 바꾸십시오. 예를 들어, 쓰는 대신</target>
        </trans-unit>
        <trans-unit id="3cc2b54b4fe8b9babd50993b19aa3de4b1112f06" translate="yes" xml:space="preserve">
          <source>If you really need to allocate before the fields can receive their final value, first initialize with a constant value (e.g. Val_unit), then allocate, then modify the fields with the correct value (see rule 6).</source>
          <target state="translated">필드가 최종 값을 받기 전에 할당해야하는 경우 먼저 상수 값 (예 : Val_unit)으로 초기화 한 다음 할당 한 다음 올바른 값으로 필드를 수정합니다 (규칙 6 참조).</target>
        </trans-unit>
        <trans-unit id="5a4f00d7d346ec3d9a159649e84ffda00feee562" translate="yes" xml:space="preserve">
          <source>If you use module aliases to give shorter names to modules, you need to change the above definitions. Assuming that your map file is called mylib.mli, here are minimal modifications.</source>
          <target state="translated">모듈 별칭을 사용하여 모듈에 더 짧은 이름을 제공하는 경우 위의 정의를 변경해야합니다. 맵 파일이 mylib.mli라고 가정하면 여기에 최소한의 수정 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="445ff9fe29411614baa1aba0c77e6b3c07963936" translate="yes" xml:space="preserve">
          <source>If your code raises this warning, you should &lt;em&gt;not&lt;/em&gt; change the way you test for the specific string to avoid the warning (for example using a string equality inside the right-hand-side instead of a literal pattern), as your code would remain fragile. You should instead enlarge the scope of the pattern by matching on all possible values.</source>
          <target state="translated">코드에서이 경고 가 발생하면 경고를 피하기 위해 특정 문자열을 테스트하는 방식을 변경 해서는 &lt;em&gt;안됩니다&lt;/em&gt; (예 : 리터럴 패턴 대신 오른쪽 내부에 문자열 같음 사용). 코드는 취약한 상태로 유지됩니다. . 대신 가능한 모든 값을 일치시켜 패턴의 범위를 확대해야합니다.</target>
        </trans-unit>
        <trans-unit id="b87ed6fde2df7c4b454ca4c9bbdd14667b228435" translate="yes" xml:space="preserve">
          <source>If your finalized blocks contain no pointers to out-of-heap resources, or if the previous discussion made little sense to you, just take used = 0 and max = 1. But if you later find that the finalization functions are not called &amp;ldquo;often enough&amp;rdquo;, consider increasing the used / max ratio.</source>
          <target state="translated">완성 된 블록에 힙이 부족한 리소스에 대한 포인터가 없거나 이전 논의가 이해가되지 않는 경우 used = 0 및 max = 1을 사용하십시오. 그러나 나중에 마무리 함수가 &quot;자주 충분합니다.&amp;rdquo;, 사용 / 최대 비율을 늘리는 것을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="192602c36fe264c7bb72e181d69fc51ec2ab7ac6" translate="yes" xml:space="preserve">
          <source>If your program spans several directories, this error can also appear because you haven&amp;rsquo;t specified the directories to look into. Fix: add the correct -I options to the command line.</source>
          <target state="translated">프로그램이 여러 디렉터리에 걸쳐있는 경우 조사 할 디렉터리를 지정하지 않았기 때문에이 오류가 나타날 수도 있습니다. 수정 : 명령 줄에 올바른 -I 옵션을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a4413f87552659e0c51237304101e749ef0f1523" translate="yes" xml:space="preserve">
          <source>If your program spans several directories, this error can also appear because you haven&amp;rsquo;t specified the directories to look into. Fix: use the #directory directive to add the correct directories to the search path.</source>
          <target state="translated">프로그램이 여러 디렉터리에 걸쳐있는 경우 조사 할 디렉터리를 지정하지 않았기 때문에이 오류가 나타날 수도 있습니다. 수정 : #directory 지시문을 사용하여 검색 경로에 올바른 디렉토리를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="04dca8ad26b4c54518389383583f6a6c77bac6ff" translate="yes" xml:space="preserve">
          <source>Ignore CR on input.</source>
          <target state="translated">입력시 CR을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="c5bdb39e4b8dd017918a8e726872a7f1642a7810" translate="yes" xml:space="preserve">
          <source>Ignore characters with parity errors.</source>
          <target state="translated">패리티 오류가있는 문자는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="0c2318243f67f315a4b8a9f29efe92c076e89ddd" translate="yes" xml:space="preserve">
          <source>Ignore labels in function types if argument is false, or switch back to default behaviour (commuting style) if argument is true.</source>
          <target state="translated">인수가 거짓이면 함수 유형의 레이블을 무시하고 인수가 참이면 기본 동작 (커뮤팅 스타일)으로 다시 전환합니다.</target>
        </trans-unit>
        <trans-unit id="236cc3c9f521b0fbfe59c2c79bd30f8c85081542" translate="yes" xml:space="preserve">
          <source>Ignore modem status lines.</source>
          <target state="translated">모뎀 상태 표시 줄을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="cc25631b490cc9dc3eae61a416673381002ebaea" translate="yes" xml:space="preserve">
          <source>Ignore non-optional labels in types.</source>
          <target state="translated">유형에서 선택 사항이 아닌 레이블은 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="8221a4e278c3aef5f3541066115c1b84f80bf481" translate="yes" xml:space="preserve">
          <source>Ignore non-optional labels in types. Labels cannot be used in applications, and parameter order becomes strict.</source>
          <target state="translated">유형에서 선택 사항이 아닌 레이블은 무시하십시오. 레이블은 응용 프로그램에서 사용할 수 없으며 매개 변수 순서가 엄격 해집니다.</target>
        </trans-unit>
        <trans-unit id="8f8ed3358c226fa964cfafc27575cd3a5ffdead1" translate="yes" xml:space="preserve">
          <source>Ignore the break condition.</source>
          <target state="translated">중단 조건을 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="73e3cd2bf31dccb18ec366d4ab12d7eebaea2ee2" translate="yes" xml:space="preserve">
          <source>Illegal attribute payload.</source>
          <target state="translated">잘못된 속성 페이로드입니다.</target>
        </trans-unit>
        <trans-unit id="8e292013c5db7783c6e4d84fc6547a66bca7ad0b" translate="yes" xml:space="preserve">
          <source>Illegal backslash escape in a string constant.</source>
          <target state="translated">문자열 상수에 잘못된 백 슬래시 이스케이프가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a2a7f348bbdc4825046979cfd8b768f4fac13a7" translate="yes" xml:space="preserve">
          <source>Immediate objects have two weaknesses compared to classes: their types are not abbreviated, and you cannot inherit from them. But these two weaknesses can be advantages in some situations, as we will see in sections &lt;a href=&quot;#s%3Areference-to-self&quot;&gt;3.3&lt;/a&gt; and &lt;a href=&quot;#s%3Aparameterized-classes&quot;&gt;3.10&lt;/a&gt;.</source>
          <target state="translated">즉각적인 개체는 클래스에 비해 두 가지 약점이 있습니다. 유형이 축약되지 않고 상속 할 수 없습니다. 그러나이 두 가지 약점은 섹션 &lt;a href=&quot;#s%3Areference-to-self&quot;&gt;3.3&lt;/a&gt; 과 &lt;a href=&quot;#s%3Aparameterized-classes&quot;&gt;3.10&lt;/a&gt; 에서 볼 수 있듯이 상황에 따라 장점이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54ba8c8554c6b105de4bb1e2e2bd6ecba60273ca" translate="yes" xml:space="preserve">
          <source>Implementing a user primitive is actually two separate tasks: on the one hand, decoding the arguments to extract C values from the given OCaml values, and encoding the return value as an OCaml value; on the other hand, actually computing the result from the arguments. Except for very simple primitives, it is often preferable to have two distinct C functions to implement these two tasks. The first function actually implements the primitive, taking native C values as arguments and returning a native C value. The second function, often called the &amp;ldquo;stub code&amp;rdquo;, is a simple wrapper around the first function that converts its arguments from OCaml values to C values, call the first function, and convert the returned C value to OCaml value. For instance, here is the stub code for the input primitive:</source>
          <target state="translated">사용자 프리미티브를 구현하는 것은 실제로 두 개의 개별 작업입니다. 한편으로는 인수를 디코딩하여 주어진 OCaml 값에서 C 값을 추출하고 반환 값을 OCaml 값으로 인코딩합니다. 반면에 실제로 인수의 결과를 계산합니다. 매우 단순한 프리미티브를 제외하고는이 두 작업을 구현하기 위해 두 개의 별개의 C 함수를 갖는 것이 선호되는 경우가 많습니다. 첫 번째 함수는 실제로 원시 C 값을 인수로 취하고 원시 C 값을 반환하는 기본 요소를 구현합니다. 종종 &quot;스텁 코드&quot;라고하는 두 번째 함수는 인수를 OCaml 값에서 C 값으로 변환하고, 첫 번째 함수를 호출하고, 반환 된 C 값을 OCaml 값으로 변환하는 첫 번째 함수를 둘러싼 간단한 래퍼입니다. 예를 들어, 다음은 입력 프리미티브에 대한 스텁 코드입니다.</target>
        </trans-unit>
        <trans-unit id="30dd7b027ecbf0176e983b1c6d8e3ff43f86ac1a" translate="yes" xml:space="preserve">
          <source>Implementing sets leads to another difficulty. Indeed, the method union needs to be able to access the internal representation of another object of the same class.</source>
          <target state="translated">세트를 구현하는 것은 또 다른 어려움으로 이어집니다. 사실, 메소드 공용체는 동일한 클래스의 다른 객체의 내부 표현에 액세스 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="cb06de5305a8cd588b4b2090243c7c818837829e" translate="yes" xml:space="preserve">
          <source>Implicit elimination of optional arguments.</source>
          <target state="translated">선택적 인수의 암시 적 제거.</target>
        </trans-unit>
        <trans-unit id="9320eec5e654eb93a5ec38ac96a5b6831671bb90" translate="yes" xml:space="preserve">
          <source>Impose the given protocol</source>
          <target state="translated">주어진 프로토콜을 부과</target>
        </trans-unit>
        <trans-unit id="f84f9ef20beeb6870c2739752e2d02c1ffd0734c" translate="yes" xml:space="preserve">
          <source>Impose the given socket domain</source>
          <target state="translated">주어진 소켓 도메인 부과</target>
        </trans-unit>
        <trans-unit id="49c1a4ccb12bf83d3c389505eddce7022eb2d2f8" translate="yes" xml:space="preserve">
          <source>Impose the given socket type</source>
          <target state="translated">주어진 소켓 유형 부과</target>
        </trans-unit>
        <trans-unit id="9f01d5e440fa709806dd2194e638ac6c655d4223" translate="yes" xml:space="preserve">
          <source>In -Oclassic mode the behaviour of the Flambda inliner mimics previous versions of the compiler. (Code may still be subject to further optimisations not performed by previous versions of the compiler: functors may be inlined, constants are lifted and unused code is eliminated all as described elsewhere in this chapter. See sections &lt;a href=&quot;#sss%3Aflambda-functors&quot;&gt;21.3.3&lt;/a&gt;, &lt;a href=&quot;#ss%3Aflambda-lift-const&quot;&gt;21.8.1&lt;/a&gt; and &lt;a href=&quot;#s%3Aflambda-remove-unused&quot;&gt;21.10&lt;/a&gt;. At the definition site of a function, the body of the function is measured. It will then be marked as eligible for inlining (and hence inlined at every direct call site) if:</source>
          <target state="translated">-Oclassic 모드에서 Flambda 인라이너의 동작은 이전 버전의 컴파일러를 모방합니다. (코드는 이전 버전의 컴파일러에서 수행되지 않은 추가 최적화의 대상이 될 수 있습니다.이 장의 다른 곳에서 설명한대로 펑터가 인라인되고 상수가 해제되고 사용되지 않는 코드가 모두 제거됩니다. 섹션 &lt;a href=&quot;#sss%3Aflambda-functors&quot;&gt;21.3.3&lt;/a&gt; , &lt;a href=&quot;#ss%3Aflambda-lift-const&quot;&gt;21.8.1&lt;/a&gt; 및 &lt;a href=&quot;#s%3Aflambda-remove-unused&quot;&gt;21.10을&lt;/a&gt; 참조하십시오. . 함수의 정의 사이트에서 함수의 본문이 측정됩니다. 그런 다음 다음과 같은 경우 인라인에 적합한 것으로 표시됩니다 (따라서 모든 직접 호출 사이트에서 인라인 됨).</target>
        </trans-unit>
        <trans-unit id="7b7e88e3104809cced60ca047035fc79d790e127" translate="yes" xml:space="preserve">
          <source>In OCaml, compilation units are special cases of structures and signatures, and the relationship between the units can be explained easily in terms of the module system. A compilation unit A comprises two files:</source>
          <target state="translated">OCaml에서 컴파일 단위는 구조와 시그니처의 특수한 경우이며, 단위 시스템의 관점에서 단위 간의 관계를 쉽게 설명 할 수 있습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 컴파일 단위 A는 두 개의 파일로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="145f72b5a6e94195611949a3aeaa2a7ac11729f1" translate="yes" xml:space="preserve">
          <source>In OCaml, there are two ways to introduce this kind of explicit universally quantified types: universally quantified record fields,</source>
          <target state="translated">OCaml에는 이러한 종류의 명시 적 범용 정량화 된 유형을 도입하는 두 가지 방법이 있습니다. 범용 정량화 된 레코드 필드,</target>
        </trans-unit>
        <trans-unit id="bc3a2778a1685965f7577f444b98e2832d2ae8ce" translate="yes" xml:space="preserve">
          <source>In a class body, the pattern (&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;] ) is matched against self, therefore providing a binding for self and self type. Self can only be used in method and initializers.</source>
          <target state="translated">클래스 본문에서 패턴 ( &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; [: &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; ])은 self와 일치하므로 self 및 self 유형에 대한 바인딩을 제공합니다. Self는 메서드와 이니셜 라이저에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70397c150edca7640c04b63beb83552a9ba1f06e" translate="yes" xml:space="preserve">
          <source>In a module, there must not be two classes, two class types or a class and a class type with the same name.</source>
          <target state="translated">모듈에는 두 개의 클래스, 두 개의 클래스 유형 또는 동일한 이름의 클래스와 클래스 유형이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="40aee30082742b60c78c6aa0f902e60e3255ab7f" translate="yes" xml:space="preserve">
          <source>In a module, there must not be two modules, two module types or a module and a module type with the same name. In the default HTML generator, modules ab and AB will be printed to the same file on case insensitive file systems.</source>
          <target state="translated">모듈에는 두 개의 모듈, 두 개의 모듈 유형 또는 이름이 같은 모듈과 모듈 유형이 있어서는 안됩니다. 기본 HTML 생성기에서 모듈 ab 및 AB는 대소 문자를 구분하지 않는 파일 시스템의 동일한 파일에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="d7e6cfb9260eacd797ec6d4742da8c29b966e366" translate="yes" xml:space="preserve">
          <source>In a module, there must not be two values, two types, or two exceptions with the same name.</source>
          <target state="translated">모듈에는 이름이 같은 두 개의 값, 두 가지 유형 또는 두 개의 예외가 있어서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9eaaa21ac3ef3ccade4409a2792f201883504cc8" translate="yes" xml:space="preserve">
          <source>In absence of an explicit polymorphic annotation, a monomorphic type is inferred for the recursive function. If a recursive call occurs inside the function definition at a type that involves an existential GADT type variable, this variable flows to the type of the recursive function, and thus escapes its scope. In the above example, this happens in the branch App(f,x) when eval is called with f as an argument. In this branch, the type of f is ($App_ 'b-&amp;gt; a). The prefix $ in $App_ 'b denotes an existential type named by the compiler (see &lt;a href=&quot;#p%3Aexistential-names&quot;&gt;8.10&lt;/a&gt;). Since the type of eval is 'a term -&amp;gt; 'a, the call eval f makes the existential type $App_'b flow to the type variable 'a and escape its scope. This triggers the above error.</source>
          <target state="translated">명시 적 다형성 주석이없는 경우 재귀 함수에 대해 단일형 유형이 유추됩니다. 재귀 호출이 존재하는 GADT 유형 변수를 포함하는 유형의 함수 정의 내에서 발생하면이 변수는 재귀 함수의 유형으로 이동하여 범위를 이스케이프합니다. 위의 예에서 이는 f를 인수로 사용하여 eval이 호출 될 때 App (f, x) 분기에서 발생합니다. 이 분기에서 f의 유형은 ($ App_ 'b-&amp;gt; a)입니다. $ App_ 'b의 접두사 $는 컴파일러에 의해 명명 된 존재 유형을 나타냅니다 ( &lt;a href=&quot;#p%3Aexistential-names&quot;&gt;8.10&lt;/a&gt; 참조 ). eval의 유형이 'a term-&amp;gt;'a이므로 호출 eval f는 존재 유형 $ App_'b를 유형 변수 'a로 흐르게하고 범위를 이스케이프합니다. 이로 인해 위의 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="83a4780fdda72224bf7c404686bee6b0dd38a00f" translate="yes" xml:space="preserve">
          <source>In addition to integers and floating-point numbers, OCaml offers the usual basic data types:</source>
          <target state="translated">정수 및 부동 소수점 숫자 외에도 OCaml은 일반적인 기본 데이터 유형을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6f1c1d50be627c43f3ca0ba8417dadf3c27859e0" translate="yes" xml:space="preserve">
          <source>In addition to program documentation, class interfaces can be used to constrain the type of a class. Both concrete instance variables and concrete private methods can be hidden by a class type constraint. Public methods and virtual members, however, cannot.</source>
          <target state="translated">프로그램 문서 외에도 클래스 인터페이스를 사용하여 클래스 유형을 제한 할 수 있습니다. 구체적인 인스턴스 변수와 구체적인 비공개 메서드는 모두 클래스 유형 제약 조건에 의해 숨길 수 있습니다. 그러나 공용 메소드와 가상 멤버는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="ff972760c30a42809d4bcb7b88b56d292a034872" translate="yes" xml:space="preserve">
          <source>In addition, Emacs displays the source files containing the current event (the current position in the program execution) and highlights the location of the event. This display is updated synchronously with the debugger action.</source>
          <target state="translated">또한 Emacs는 현재 이벤트 (프로그램 실행의 현재 위치)를 포함하는 소스 파일을 표시하고 이벤트 위치를 강조 표시합니다. 이 디스플레이는 디버거 작업과 동시에 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="c7116193945dcb705fd31b47667c53f6ed878fa4" translate="yes" xml:space="preserve">
          <source>In addition, the following options are recognized:</source>
          <target state="translated">또한 다음 옵션이 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="02a9d67825df2ad654535d9305a175a49c2e92ae" translate="yes" xml:space="preserve">
          <source>In all buffers in OCaml editing mode, the following debugger commands are also available:</source>
          <target state="translated">OCaml 편집 모드의 모든 버퍼에서 다음 디버거 명령도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34fa2ed3ea28bd96a31c074309c173fda8ea3d66" translate="yes" xml:space="preserve">
          <source>In all cases but exact match of order and labels, without optional parameters, the function type should be known at the application point. This can be ensured by adding a type constraint. Principality of the derivation can be checked in the -principal mode.</source>
          <target state="translated">선택적 매개 변수없이 순서와 레이블의 정확한 일치를 제외한 모든 경우에 함수 유형은 애플리케이션 지점에서 알아야합니다. 이것은 유형 제약을 추가하여 보장 할 수 있습니다. 파생의 공국은 -principal 모드에서 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8df4f3c4b7e3901c28cc625ce0fcca37b5cf5b16" translate="yes" xml:space="preserve">
          <source>In all three cases, tags may be either specified directly in the `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; [of&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;] form, or indirectly through a type expression, which must expand to an exact variant type, whose tag specifications are inserted in its place.</source>
          <target state="translated">세 가지 경우 모두 태그는` &lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; [of &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; ] 형식으로 직접 지정 되거나, 태그 사양이 그 자리에 삽입 된 정확한 변형 유형으로 확장되어야하는 유형 표현식을 통해 간접적으로 지정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7baa740e37d7218dfa915e6dbf869155b1be9ec" translate="yes" xml:space="preserve">
          <source>In an attempt to write the type constraint above more elegantly, one may wish to name the signature of the structure returned by the functor, then use that signature in the constraint:</source>
          <target state="translated">위의 유형 제약 조건을보다 우아하게 작성하려는 시도에서 functor가 반환 한 구조의 서명 이름을 지정한 다음 제약 조건에서 해당 서명을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a30f385b51a5770584633407723813633df87fa2" translate="yes" xml:space="preserve">
          <source>In both cases, at least one of the integer and fractional parts must be given; the exponent part is optional.</source>
          <target state="translated">두 경우 모두 정수 부분과 소수 부분 중 하나 이상을 제공해야합니다. 지수 부분은 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="aeab98a5938308a7ca7c5d621826d698eeb35974" translate="yes" xml:space="preserve">
          <source>In both cases, the whole for expression evaluates to the unit value ().</source>
          <target state="translated">두 경우 모두 for 식 전체가 단위 값 ()으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="eb7d81806d62938e65661891480f3bf1c340bdef" translate="yes" xml:space="preserve">
          <source>In bytecode, the identity function.</source>
          <target state="translated">바이트 코드에서 식별 기능.</target>
        </trans-unit>
        <trans-unit id="8eef554bc6e9693f24dc173cd6cec6650313f5d0" translate="yes" xml:space="preserve">
          <source>In bytecode, the identity function. In native code, replace the last extension with &lt;code&gt;.cmxs&lt;/code&gt;.</source>
          <target state="translated">바이트 코드에서 식별 기능. 네이티브 코드에서 마지막 확장자를 &lt;code&gt;.cmxs&lt;/code&gt; 로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="4a627abf55d958271115777925dd0ee4cea9f6d0" translate="yes" xml:space="preserve">
          <source>In bytecode: load the given bytecode object file (&lt;code&gt;.cmo&lt;/code&gt; file) or bytecode library file (&lt;code&gt;.cma&lt;/code&gt; file), and link it with the running program.</source>
          <target state="translated">바이트 코드에서 : 주어진 바이트 코드 객체 파일 ( &lt;code&gt;.cmo&lt;/code&gt; 파일) 또는 바이트 코드 라이브러리 파일 ( &lt;code&gt;.cma&lt;/code&gt; 파일)을로드하고 실행중인 프로그램과 연결합니다.</target>
        </trans-unit>
        <trans-unit id="b1240e451018dbc380a6a35faaf32c3363a7ae3c" translate="yes" xml:space="preserve">
          <source>In bytecode: load the given bytecode object file (&lt;code&gt;.cmo&lt;/code&gt; file) or bytecode library file (&lt;code&gt;.cma&lt;/code&gt; file), and link it with the running program. In native code: load the given OCaml plugin file (usually &lt;code&gt;.cmxs&lt;/code&gt;), and link it with the running program.</source>
          <target state="translated">바이트 코드에서 : 주어진 바이트 코드 객체 파일 ( &lt;code&gt;.cmo&lt;/code&gt; 파일) 또는 바이트 코드 라이브러리 파일 ( &lt;code&gt;.cma&lt;/code&gt; 파일)을로드하고 실행중인 프로그램과 연결합니다. 네이티브 코드에서 : 주어진 OCaml 플러그인 파일 (일반적으로 &lt;code&gt;.cmxs&lt;/code&gt; )을 로드 하고 실행중인 프로그램과 연결합니다.</target>
        </trans-unit>
        <trans-unit id="c05a5ebf291f79b9d8204d27a74aaf7e66a3bd26" translate="yes" xml:space="preserve">
          <source>In case of interactive use, each phrase is executed in the initial state of the standard pretty-printer: after each phrase execution, the interactive system closes all open pretty-printing boxes, flushes all pending text, and resets the standard pretty-printer.</source>
          <target state="translated">대화 형 사용의 경우 각 구문은 표준 pretty-printer의 초기 상태에서 실행됩니다. 각 구문 실행 후 대화 형 시스템은 열려있는 모든 pretty-printing 상자를 닫고 보류중인 모든 텍스트를 비우고 표준 pretty-printer를 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="4492c5d50795eada8a5ec4ba7632113061a4720c" translate="yes" xml:space="preserve">
          <source>In case of multiple and related calls to &lt;code&gt;sprintf&lt;/code&gt; to output material on a single string, you should consider using &lt;code&gt;fprintf&lt;/code&gt; with the predefined formatter &lt;code&gt;str_formatter&lt;/code&gt; and call &lt;code&gt;flush_str_formatter&amp;nbsp;()&lt;/code&gt; to get the final result.</source>
          <target state="translated">단일 문자열에서 자료를 출력 하기 위해 &lt;code&gt;sprintf&lt;/code&gt; 를 여러 번 호출하는 경우 사전 정의 된 포맷터 &lt;code&gt;str_formatter&lt;/code&gt; 와 함께 &lt;code&gt;fprintf&lt;/code&gt; 를 사용 하고 최종 결과를 얻기 위해 &lt;code&gt;flush_str_formatter&amp;nbsp;()&lt;/code&gt; 를 호출 해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d2984bfe0a6d541921bf01ae808e7774f69005e" translate="yes" xml:space="preserve">
          <source>In case the shared library produced with -output-obj is to be loaded and unloaded repeatedly by a single process, care must be taken to unload the OCaml runtime explicitly, in order to avoid various system resource leaks.</source>
          <target state="translated">-output-obj로 생성 된 공유 라이브러리가 단일 프로세스에 의해 반복적으로로드 및 언로드되는 경우 다양한 시스템 리소스 누출을 방지하기 위해 OCaml 런타임을 명시 적으로 언로드하도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="44b7cbadbf1b0a98e780a49d929bc95e7c7a1618" translate="yes" xml:space="preserve">
          <source>In conclusion: dynamic linking is highly recommended under the native Windows port, because there are no portability problems and it is much more convenient for the end users. Under Unix, dynamic linking should be considered for mature, frequently used libraries because it enhances platform-independence of bytecode executables. For new or rarely-used libraries, static linking is much simpler to set up in a portable way.</source>
          <target state="translated">결론 : 동적 연결은 이식성 문제가없고 최종 사용자에게 훨씬 더 편리하기 때문에 기본 Windows 포트에서 적극 권장됩니다. Unix에서 동적 링크는 바이트 코드 실행 파일의 플랫폼 독립성을 향상시키기 때문에 성숙하고 자주 사용되는 라이브러리에 대해 고려되어야합니다. 새롭거나 거의 사용되지 않는 라이브러리의 경우 정적 링크는 이식 가능한 방식으로 설정하는 것이 훨씬 간단합니다.</target>
        </trans-unit>
        <trans-unit id="d29d579e5fcb07ee03fdf350892fb2426fe79f73" translate="yes" xml:space="preserve">
          <source>In earlier versions of OCaml, it was possible to use word-aligned pointers to addresses outside the heap as OCaml values, just by casting the pointer to type value. Starting with OCaml 4.11, this usage is deprecated and will stop being supported in OCaml 5.00.</source>
          <target state="translated">이전 버전의 OCaml에서는 포인터를 형식 값으로 캐스팅하는 것만으로 힙 외부의 주소에 대한 단어 정렬 포인터를 OCaml 값으로 사용할 수있었습니다. OCaml 4.11부터이 사용법은 더 이상 사용되지 않으며 OCaml 5.00에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="93d3688e1bbb7be44366be8e265ab0e92df16094" translate="yes" xml:space="preserve">
          <source>In error recovery mode, the parser discards states from the stack until it reaches a place where the error token can be shifted. It then discards tokens from the input until it finds three successive tokens that can be accepted, and starts processing with the first of these. If no state can be uncovered where the error token can be shifted, then the parser aborts by raising the Parsing.Parse_error exception.</source>
          <target state="translated">오류 복구 모드에서 구문 분석기는 오류 토큰을 이동할 수있는 위치에 도달 할 때까지 스택에서 상태를 버립니다. 그런 다음 수락 할 수있는 세 개의 연속 토큰을 찾을 때까지 입력에서 토큰을 버리고 첫 번째 토큰으로 처리를 시작합니다. 오류 토큰을 이동할 수있는 상태를 찾을 수없는 경우 구문 분석기는 Parsing.Parse_error 예외를 발생시켜 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="0052f286e501146744357d1f715c84752a4801d2" translate="yes" xml:space="preserve">
          <source>In fact, Oo.copy p will behave as p#copy assuming that a public method copy with body {&amp;lt; &amp;gt;} has been defined in the class of p.</source>
          <target state="translated">사실, Oo.copy p는 p의 클래스에 본문 {&amp;lt;&amp;gt;}가있는 공용 메소드 사본이 정의되었다고 가정 할 때 p # copy로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="88b998217306cf98a0431358725952a2c40a0011" translate="yes" xml:space="preserve">
          <source>In general, the module expression (val&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) cannot be used in the body of a functor, because this could cause unsoundness in conjunction with applicative functors. Since OCaml 4.02, this is relaxed in two ways: if &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; does not contain nominal type declarations (&lt;em&gt;i.e.&lt;/em&gt; types that are created with a proper identity), then this expression can be used anywhere, and even if it contains such types it can be used inside the body of a generative functor, described in section &lt;a href=&quot;generativefunctors#s%3Agenerative-functors&quot;&gt;8.15&lt;/a&gt;. It can also be used anywhere in the context of a local module binding letmodule&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;=(val&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;)in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="translated">일반적으로 모듈 표현식 (val &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; : &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; )은 펑터 본문에서 사용할 수 없습니다. 펑터와 관련하여 불건전 함을 유발할 수 있기 때문입니다. OCaml 4.02 이후로 이것은 두 가지 방식으로 완화됩니다. &lt;a href=&quot;#package-type&quot;&gt;패키지 유형에&lt;/a&gt; 명목 유형 선언 ( &lt;em&gt;즉&lt;/em&gt; , 적절한 ID로 생성 된 유형)이 포함되어 있지 않으면 이 표현식은 어디에서나 사용할 수 있으며 이러한 유형이 포함되어 있어도 사용할 수 있습니다. 섹션 &lt;a href=&quot;generativefunctors#s%3Agenerative-functors&quot;&gt;8.15에&lt;/a&gt; 설명 된 생성 펑터의 몸체 내부에서 사용됩니다 . 또한 로컬 모듈 바인딩의 컨텍스트 어디에서나 사용할 수 있습니다. letmodule &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; = (val &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; : &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; ) in&lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; .</target>
        </trans-unit>
        <trans-unit id="e5c98ff88089f23a3d0986fcd57f4fffdbd72c5c" translate="yes" xml:space="preserve">
          <source>In last resort, if there is not enough information to disambiguate between different fields or constructors, Ocaml picks the last defined type amongst all locally valid choices:</source>
          <target state="translated">최후의 수단으로, 서로 다른 필드 또는 생성자간에 명확하게하기위한 정보가 충분하지 않은 경우 Ocaml은 모든 로컬에서 유효한 선택 중에서 마지막으로 정의 된 유형을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="d6bffcb3669ad49ba8135b0e8be4c55178bd1806" translate="yes" xml:space="preserve">
          <source>In many places, OCaml makes a distinction between capitalized identifiers and identifiers that begin with a lowercase letter. The underscore character is considered a lowercase letter for this purpose.</source>
          <target state="translated">많은 곳에서 OCaml은 대문자 식별자와 소문자로 시작하는 식별자를 구분합니다. 이 목적을 위해 밑줄 문자는 소문자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="216e9b10a826eed18b60a2c7b92a349ea1836a4e" translate="yes" xml:space="preserve">
          <source>In method m1, o must be an object with at least a method n1, itself polymorphic. In method m2, the argument of n2 and x must have the same type, which is quantified at the same level as 'a.</source>
          <target state="translated">방법 m1에서 o는 그 자체가 다형성 인 방법 n1 이상을 갖는 객체 여야합니다. 방법 m2에서 n2와 x의 인수는 'a와 동일한 수준에서 수량화되는 동일한 유형을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="a4879ead4b7fe51c64df3dc284efd5b46cf97cbb" translate="yes" xml:space="preserve">
          <source>In more detail, at each call site the following procedure is followed:</source>
          <target state="translated">보다 자세하게는 각 호출 사이트에서 다음 절차를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="e4a5218af84a08375004a9b8c8f30976425e0ea1" translate="yes" xml:space="preserve">
          <source>In native code this function does not allocate.</source>
          <target state="translated">네이티브 코드에서이 함수는 할당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46e607d66b5b324deff28adfb00c36b67e461bd5" translate="yes" xml:space="preserve">
          <source>In normal operation, a mixed OCaml/C program starts by executing the OCaml initialization code, which then may proceed to call C functions. We say that the main program is the OCaml code. In some applications, it is desirable that the C code plays the role of the main program, calling OCaml functions when needed. This can be achieved as follows:</source>
          <target state="translated">정상적인 작동에서 혼합 된 OCaml / C 프로그램은 OCaml 초기화 코드를 실행하여 시작되며, 이후 C 함수 호출을 진행할 수 있습니다. 메인 프로그램은 OCaml 코드라고합니다. 일부 응용 프로그램에서는 C 코드가 필요할 때 OCaml 함수를 호출하는 주 프로그램의 역할을 수행하는 것이 바람직합니다. 이는 다음과 같이 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d6c0bbded532eaac460fed9f095eb72cfd28e5f" translate="yes" xml:space="preserve">
          <source>In order to be able to run the garbage collector in the middle of a C function, the OCaml native-code compiler generates some bookkeeping code around C calls. Technically it wraps every C call with the C function caml_c_call which is part of the OCaml runtime.</source>
          <target state="translated">C 함수 중간에서 가비지 수집기를 실행할 수 있도록 OCaml 네이티브 코드 컴파일러는 C 호출에 대한 몇 가지 부기 코드를 생성합니다. 기술적으로 모든 C 호출을 OCaml 런타임의 일부인 C 함수 caml_c_call로 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="705f0d7e5ce98c35ddf45a8b90e4166d527197ef" translate="yes" xml:space="preserve">
          <source>In order to properly delimit printed entities, a semantic tag must be opened before and closed after the entity. Semantic tags must be properly nested like parentheses using &lt;a href=&quot;format#VALpp_open_stag&quot;&gt;&lt;code&gt;Format.pp_open_stag&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;format#VALpp_close_stag&quot;&gt;&lt;code&gt;Format.pp_close_stag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인쇄 된 엔터티를 올바르게 구분하려면 엔터티 앞과 뒤에 시맨틱 태그를 열어야합니다. 시맨틱 태그는 &lt;a href=&quot;format#VALpp_open_stag&quot;&gt; &lt;code&gt;Format.pp_open_stag&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;format#VALpp_close_stag&quot;&gt; &lt;code&gt;Format.pp_close_stag&lt;/code&gt; 를&lt;/a&gt; 사용하여 괄호처럼 적절하게 중첩되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c99bae7df15a0847fae04eb1c0499dc97289ad36" translate="yes" xml:space="preserve">
          <source>In other words, x :&amp;gt; xy implies that x list :&amp;gt; xy list, therefore the type constructor 'a list is covariant (it preserves subtyping) in its parameter 'a.</source>
          <target state="translated">즉, x :&amp;gt; xy는 x list :&amp;gt; xy 목록을 의미하므로 유형 생성자 'a 목록은 해당 매개 변수'a에서 공변 (부분 유형 유지)입니다.</target>
        </trans-unit>
        <trans-unit id="b5f46ca739529e04a39f1aab5af3dba32a684971" translate="yes" xml:space="preserve">
          <source>In particular this multi-index notation makes it possible to uniformly handle indexing Genarray and other implementations of multidimensional arrays.</source>
          <target state="translated">특히이 다중 인덱스 표기법을 사용하면 인덱싱 Genarray 및 기타 다차원 배열 구현을 균일하게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="0aab86acd922ebcbea9163dc56fc9283939f580d" translate="yes" xml:space="preserve">
          <source>In particular, Main can refer to Aux: the definitions and declarations contained in Main.ml and Main.mli can refer to definition in Aux.ml, using the Aux.ident notation, provided these definitions are exported in Aux.mli.</source>
          <target state="translated">특히 Main은 Aux를 참조 할 수 있습니다. Main.ml 및 Main.mli에 포함 된 정의 및 선언은 Aux.ident 표기법을 사용하여 Aux.ml의 정의를 참조 할 수 있습니다 (이러한 정의가 Aux.mli로 내 보내진 경우).</target>
        </trans-unit>
        <trans-unit id="ae0710f72489debbe41f038cbacd70ca72e1c4ed" translate="yes" xml:space="preserve">
          <source>In particular, all built-in exceptions with a string argument have this attribute set: Invalid_argument, Failure, Sys_error will all raise this warning if you match for a specific string argument.</source>
          <target state="translated">특히, 문자열 인수가있는 모든 내장 예외에는 다음 속성이 설정되어 있습니다. Invalid_argument, Failure, Sys_error는 특정 문자열 인수와 일치하는 경우 모두이 경고를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b074470bc685e81d978d3c12fec323bc92cacce4" translate="yes" xml:space="preserve">
          <source>In particular, if you want a regular expression that matches a single backslash character, you need to quote it in the argument to &lt;code&gt;regexp&lt;/code&gt; (according to the last item of the list above) by adding a second backslash. Then you need to quote both backslashes (according to the syntax of string constants in OCaml) by doubling them again, so you need to write four backslash characters: &lt;code&gt;Str.regexp&amp;nbsp;&quot;\\\\&quot;&lt;/code&gt;.</source>
          <target state="translated">특히, 단일 백 슬래시 문자와 일치하는 정규식을 원하는 경우 두 번째 백 슬래시를 추가하여 &lt;code&gt;regexp&lt;/code&gt; 에 대한 인수에 인용해야합니다 (위 목록의 마지막 항목에 따름). 그런 다음 두 백 슬래시를 다시 두 배로 &lt;code&gt;Str.regexp&amp;nbsp;&quot;\\\\&quot;&lt;/code&gt; OCaml의 문자열 상수 구문에 따라) 인용해야합니다. 따라서 네 개의 백 슬래시 문자 인 Str.regexp &quot;\\\\&quot; 를 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2f7e072637e54b00ab8fa95f737650edcfbf010b" translate="yes" xml:space="preserve">
          <source>In particular, it is forbidden to change any value (for example using Obj.set_field or Obj.set_tag) that is not mutable. (Values returned from C stubs are always treated as mutable.) The compiler will emit warning 59 if it detects such a write&amp;mdash;but it cannot warn in all cases. Here is an example of code that will trigger the warning:</source>
          <target state="translated">특히 변경 불가능한 값 (예 : Obj.set_field 또는 Obj.set_tag 사용)을 변경하는 것은 금지되어 있습니다. (C 스텁에서 반환 된 값은 항상 변경 가능한 것으로 처리됩니다.) 컴파일러는 이러한 쓰기를 감지하면 경고 59를 내 보냅니다. 그러나 모든 경우에 경고 할 수는 없습니다. 다음은 경고를 트리거하는 코드의 예입니다.</target>
        </trans-unit>
        <trans-unit id="ade5ca771cb6e9b09d87215a726868aac65e1c3f" translate="yes" xml:space="preserve">
          <source>In particular, this does not require the knowledge of the implementation of the method deposit.</source>
          <target state="translated">특히 이것은 방법 예금의 구현에 대한 지식이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5fc135baac0c5f362e717cdfa21fa7d3c9fdb0d" translate="yes" xml:space="preserve">
          <source>In practice, first define a symbolic output buffer &lt;code&gt;b&lt;/code&gt; using:</source>
          <target state="translated">실제로는 먼저 다음을 사용하여 기호 출력 버퍼 &lt;code&gt;b&lt;/code&gt; 를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="071912257bcdf51deb295b9dfc5fee29b88e66d1" translate="yes" xml:space="preserve">
          <source>In practice, such problems appear mostly when using objects whose methods have optional arguments, so that writing the type of object arguments is often a good idea.</source>
          <target state="translated">실제로 이러한 문제는 메서드에 선택적 인수가있는 개체를 사용할 때 주로 나타나므로 개체 인수 유형을 작성하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="231cbc44094ac9d8485720744f05b0f46784e83e" translate="yes" xml:space="preserve">
          <source>In practice, type inference is a bit more clever than that: type annotations do not need to be immediately on the pattern-matching, and the types do not have to be always closed. As a result, it is usually enough to only annotate functions, as in the example above. Type annotations are propagated in two ways: for the scrutinee, they follow the flow of type inference, in a way similar to polymorphic methods; for the return type, they follow the structure of the program, they are split on functions, propagated to all branches of a pattern matching, and go through tuples, records, and sum types. Moreover, the notion of ambiguity used is stronger: a type is only seen as ambiguous if it was mixed with incompatible types (equated by constraints), without type annotations between them. For instance, the following program types correctly.</source>
          <target state="translated">실제로 유형 추론은 그보다 조금 더 영리합니다. 유형 주석은 패턴 일치에 즉시있을 필요가 없으며 유형을 항상 닫을 필요는 없습니다. 결과적으로 위의 예에서와 같이 일반적으로 함수에 주석을 추가하는 것으로 충분합니다. 유형 주석은 두 가지 방식으로 전파됩니다. 스크 루틴의 경우 다형성 방법과 유사한 방식으로 유형 추론의 흐름을 따릅니다. 반환 유형의 경우 프로그램의 구조를 따르고 함수에서 분할되고 패턴 일치의 모든 분기로 전파되며 튜플, 레코드 및 합계 유형을 통과합니다. 더욱이 사용 된 모호성의 개념은 더 강력합니다. 유형은 유형 주석이없는 호환되지 않는 유형 (제약과 동일)과 혼합 된 경우에만 모호한 것으로 간주됩니다. 예를 들어, 다음 프로그램은 올바르게 입력됩니다.</target>
        </trans-unit>
        <trans-unit id="b4ec2dc15612b4e9552fe86a4c1e5b9778f4b360" translate="yes" xml:space="preserve">
          <source>In practice, unique ownership of string values is extremely difficult to reason about correctly. You should always assume strings are shared, never uniquely owned.</source>
          <target state="translated">실제로 문자열 값의 고유 한 소유권은 올바르게 추론하기가 매우 어렵습니다. 항상 문자열이 공유되고 고유하게 소유되지 않는다고 가정해야합니다.</target>
        </trans-unit>
        <trans-unit id="675c86cc7771a8adaaf8916ec39061e81a549695" translate="yes" xml:space="preserve">
          <source>In presence of a refutation case, the exhaustiveness check will first compute the intersection of the pattern with the complement of the cases preceding it. It then checks whether the resulting patterns can really match any concrete values by trying to type-check them. Wild cards in the generated patterns are handled in a special way: if their type is a variant type with only GADT constructors, then the pattern is split into the different constructors, in order to check whether any of them is possible (this splitting is not done for arguments of these constructors, to avoid non-termination). We also split tuples and variant types with only one case, since they may contain GADTs inside. For instance, the following code is deemed exhaustive:</source>
          <target state="translated">반박 사례가있는 경우 완전성 검사는 먼저 패턴의 교차점과 이전 사례의 보완을 계산합니다. 그런 다음 결과 패턴이 유형 검사를 시도하여 구체적인 값과 실제로 일치 할 수 있는지 여부를 확인합니다. 생성 된 패턴의 와일드 카드는 특별한 방식으로 처리됩니다. 유형이 GADT 생성자 만있는 변형 유형 인 경우 패턴이 다른 생성자로 분할되어 가능한지 확인합니다 (이 분할은 그렇지 않습니다. 비 종결을 피하기 위해 이러한 생성자의 인수에 대해 수행됨). 또한 내부에 GADT가 포함될 수 있으므로 튜플과 변형 유형을 하나의 케이스로 분할합니다. 예를 들어 다음 코드는 완전한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="5162e7ccdac1a4d75bd7ab724a1804dfb5ac71c9" translate="yes" xml:space="preserve">
          <source>In programs, polymorphic variants work like usual ones. You just have to prefix their names with a backquote character `.</source>
          <target state="translated">프로그램에서 다형성 변형은 일반적인 변형처럼 작동합니다. 이름 앞에 역 따옴표 문자`를 붙이기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="8e52f850e1e21d53f51e85e344a1dc361b2df51a" translate="yes" xml:space="preserve">
          <source>In rare cases, it is useful to control the amount of instrumentation generated. By passing the -afl-inst-ratio N argument to ocamlopt with N less than 100, instrumentation can be generated for only N% of branches. (See the afl-fuzz documentation on the parameter AFL_INST_RATIO for the precise effect of this).</source>
          <target state="translated">드물지만 생성되는 계측의 양을 제어하는 ​​것이 유용합니다. -afl-inst-ratio N 인수를 N이 100 미만인 ocamlopt에 전달하면 분기의 N %에 대해서만 계측을 생성 할 수 있습니다. (이의 정확한 효과는 AFL_INST_RATIO 매개 변수에 대한 afl-fuzz 문서를 참조하십시오).</target>
        </trans-unit>
        <trans-unit id="34098be7f93d78af7d951548f23b26575531f537" translate="yes" xml:space="preserve">
          <source>In script mode, the directory containing the script currently executing; in interactive mode, the current working directory.</source>
          <target state="translated">스크립트 모드에서 현재 실행중인 스크립트를 포함하는 디렉토리. 대화식 모드에서 현재 작업 디렉토리.</target>
        </trans-unit>
        <trans-unit id="0910a7b3a20b997c573d806f5d3f327bd2180db6" translate="yes" xml:space="preserve">
          <source>In script mode, the first line of the script is ignored if it starts with #!. Thus, it should be possible to make the script itself executable and put as first line #!/usr/local/bin/ocaml, thus calling the toplevel system automatically when the script is run. However, ocaml itself is a #! script on most installations of OCaml, and Unix kernels usually do not handle nested #! scripts. A better solution is to put the following as the first line of the script:</source>
          <target state="translated">스크립트 모드에서 스크립트의 첫 번째 줄은 #!로 시작하면 무시됩니다. 따라서 스크립트 자체를 실행 가능하게 만들고 첫 번째 줄 #! / usr / local / bin / ocaml로 입력하여 스크립트가 실행될 때 자동으로 최상위 시스템을 호출 할 수 있어야합니다. 그러나 ocaml 자체는 #! 대부분의 OCaml 및 Unix 커널 설치의 스크립트는 일반적으로 중첩 된 #! 스크립트. 더 나은 해결책은 다음을 스크립트의 첫 번째 줄에 넣는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b3ca139fc0e78af6203d9e577fcd6f73d39da1eb" translate="yes" xml:space="preserve">
          <source>In short, a conversion specification consists in the &lt;code&gt;%&lt;/code&gt; character, followed by optional modifiers and a type which is made of one or two characters.</source>
          <target state="translated">요컨대, 변환 사양은 &lt;code&gt;%&lt;/code&gt; 문자, 선택적 수정 자 및 하나 또는 두 문자로 구성된 유형으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="dfc44adbe1d76bbb9087ab9eb6bae00365f83692" translate="yes" xml:space="preserve">
          <source>In some cases, a successful match may not yield a unique set of bindings. For instance the matching of &lt;code&gt;aba&lt;/code&gt; by the regular expression (('a'|&quot;ab&quot;) as x) ((&quot;ba&quot;|'a') as y) may result in binding either &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;&quot;ab&quot;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;&quot;a&quot;&lt;/code&gt;, or &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;&quot;ba&quot;&lt;/code&gt;. The automata produced ocamllex on such ambiguous regular expressions will select one of the possible resulting sets of bindings. The selected set of bindings is purposely left unspecified.</source>
          <target state="translated">경우에 따라 성공적으로 일치해도 고유 한 바인딩 집합이 생성되지 않을 수 있습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 예를 들어 정규 표현식 (( 'a'| &quot;ab&quot;)을 x로) (( &quot;ba&quot;| 'a')를 y로)에 의해 &lt;code&gt;aba&lt;/code&gt; 를 일치 시키면 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;&quot;ab&quot;&lt;/code&gt; 에 바인딩 하고 &lt;code&gt;y&lt;/code&gt; 를 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 에 바인딩 할 수 있습니다. a &quot; 또는 &lt;code&gt;x&lt;/code&gt; 에서 &lt;code&gt;&quot;a&quot;&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 에서 &lt;code&gt;&quot;ba&quot;&lt;/code&gt; . 이러한 모호한 정규 표현식에서 자동 생성 된 오 카멜 렉스는 가능한 결과 바인딩 세트 중 하나를 선택합니다. 선택한 바인딩 집합은 의도적으로 지정되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="5e5f8acb11224ef16504bf821b1a4f3846e25f8a" translate="yes" xml:space="preserve">
          <source>In some cases, it is hard to understand why the two types t&lt;sub&gt;1&lt;/sub&gt; and t&lt;sub&gt;2&lt;/sub&gt; are incompatible. For instance, the compiler can report that &amp;ldquo;expression of type foo cannot be used with type foo&amp;rdquo;, and it really seems that the two types foo are compatible. This is not always true. Two type constructors can have the same name, but actually represent different types. This can happen if a type constructor is redefined. Example:</source>
          <target state="translated">경우에 따라 두 유형 t &lt;sub&gt;1&lt;/sub&gt; 및 t &lt;sub&gt;2&lt;/sub&gt; 가 호환되지 않는 이유를 이해하기 어렵습니다 . 예를 들어 컴파일러는 &quot;foo 유형의 표현식은 foo 유형과 함께 사용할 수 없습니다&quot;라고보고 할 수 있으며 실제로 두 유형 foo가 호환되는 것으로 보입니다. 이것은 항상 사실이 아닙니다. 두 유형 생성자는 동일한 이름을 가질 수 있지만 실제로는 다른 유형을 나타냅니다. 이는 형식 생성자가 재정의 된 경우 발생할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="79e640798597484a7600545dc82e4c33ed1a5752" translate="yes" xml:space="preserve">
          <source>In some cases, you may want to turn reverse execution off. This speeds up the program execution, and is also sometimes useful for interactive programs.</source>
          <target state="translated">경우에 따라 역 실행을 해제 할 수 있습니다. 이렇게하면 프로그램 실행 속도가 빨라지며 대화 형 프로그램에도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="72952c8f05afa090a6398eb7a7e68cd59e600681" translate="yes" xml:space="preserve">
          <source>In some special cases, you may need to store a polymorphic function in a data structure, keeping its polymorphism. Doing this requires user-provided type annotations, since polymorphism is only introduced automatically for global definitions. However, you can explicitly give polymorphic types to record fields.</source>
          <target state="translated">일부 특별한 경우에는 데이터 구조에 다형성 함수를 저장하여 다형성을 유지해야 할 수 있습니다. 이를 위해서는 다형성이 전역 정의에 대해서만 자동으로 도입되기 때문에 사용자가 제공 한 유형 주석이 필요합니다. 그러나 레코드 필드에 다형성 유형을 명시 적으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d8bd8bd0c73e5581100c0f0fdc21cf6dc82fc9c" translate="yes" xml:space="preserve">
          <source>In terms of char_os, both functions take an argument of type char_os * and return a result of the same type. We begin by choosing the right implementation of the function to bind:</source>
          <target state="translated">char_os 측면에서 두 함수 모두 char_os * 유형의 인수를 취하고 동일한 유형의 결과를 반환합니다. 바인딩 할 함수의 올바른 구현을 선택하는 것으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="922859d863be18c8537dbf92ff8a561e25d814f1" translate="yes" xml:space="preserve">
          <source>In the &amp;ldquo;custom runtime&amp;rdquo; mode, the OCaml linker scans the object files and determines the set of required primitives. Then, it builds a suitable runtime system, by calling the native code linker with:</source>
          <target state="translated">&quot;사용자 지정 런타임&quot;모드에서 OCaml 링커는 개체 파일을 스캔하고 필요한 기본 요소 집합을 결정합니다. 그런 다음 다음을 사용하여 네이티브 코드 링커를 호출하여 적절한 런타임 시스템을 구축합니다.</target>
        </trans-unit>
        <trans-unit id="ad74914aa0f5096cdf7ded3e98edc3fa9085e8eb" translate="yes" xml:space="preserve">
          <source>In the C-style layout, array indices start at 0, and multi-dimensional arrays are laid out in row-major format. That is, for a two-dimensional array, all elements of row 0 are contiguous in memory, followed by all elements of row 1, etc. In other terms, the array elements at &lt;code&gt;(x,y)&lt;/code&gt; and &lt;code&gt;(x,&amp;nbsp;y+1)&lt;/code&gt; are adjacent in memory.</source>
          <target state="translated">C 스타일 레이아웃에서 배열 인덱스는 0에서 시작하고 다차원 배열은 행 중심 형식으로 레이아웃됩니다. 즉, 2 차원 배열의 경우 행 0의 모든 요소가 메모리에서 연속되고 행 1의 모든 요소가 뒤 따릅니다. 즉, &lt;code&gt;(x,y)&lt;/code&gt; 및 &lt;code&gt;(x,&amp;nbsp;y+1)&lt;/code&gt; 의 배열 요소 ) ) 는 메모리에서 인접합니다.</target>
        </trans-unit>
        <trans-unit id="726cf9559718642bb4a9ce924e67bf43e58f9a8d" translate="yes" xml:space="preserve">
          <source>In the Fortran-style layout, array indices start at 1, and multi-dimensional arrays are laid out in column-major format. That is, for a two-dimensional array, all elements of column 0 are contiguous in memory, followed by all elements of column 1, etc. In other terms, the array elements at &lt;code&gt;(x,y)&lt;/code&gt; and &lt;code&gt;(x+1,&amp;nbsp;y)&lt;/code&gt; are adjacent in memory.</source>
          <target state="translated">Fortran 스타일 레이아웃에서 배열 인덱스는 1부터 시작하고 다차원 배열은 열 주요 형식으로 레이아웃됩니다. 즉, 2 차원 배열의 경우 열 0의 모든 요소가 메모리에서 연속적이며 그 뒤에 열 1의 모든 요소가 이어집니다. 즉, &lt;code&gt;(x,y)&lt;/code&gt; 및 &lt;code&gt;(x+1,&amp;nbsp;y)&lt;/code&gt; 의 배열 요소 ) ) 는 메모리에서 인접합니다.</target>
        </trans-unit>
        <trans-unit id="e2cea060daca649c697673805c9646270333dad7" translate="yes" xml:space="preserve">
          <source>In the absence of meaningful comment on the last constructor of a type, an empty comment (**) can be used instead:</source>
          <target state="translated">유형의 마지막 생성자에 대한 의미있는 주석이 없으면 대신 빈 주석 (**)을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f44983950ca3c3197004ea73c999cd5259f3070f" translate="yes" xml:space="preserve">
          <source>In the case of variant constructors or record field, the constructor or field name should be preceded by the name of the correspond type &amp;ndash; to avoid the ambiguity of several types having the same constructor names. For example, the constructor Node of the type tree will be referenced as {!tree.Node} or {!const:tree.Node}, or possibly {!Mod1.Mod2.tree.Node} from outside the module.</source>
          <target state="translated">변형 생성자 또는 레코드 필드의 경우, 생성자 이름이 동일한 여러 유형의 모호함을 피하기 위해 생성자 또는 필드 이름 앞에 해당 유형의 이름이 와야합니다. 예를 들어, 유형 트리의 생성자 Node는 모듈 외부에서 {! tree.Node} 또는 {! const : tree.Node} 또는 {! Mod1.Mod2.tree.Node}로 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="f10b0cb476350af30f28ed8856736d1b9672116b" translate="yes" xml:space="preserve">
          <source>In the default mode, the OCaml linker produces bytecode for the standard runtime system, with a standard set of primitives. References to primitives that are not in this standard set result in the &amp;ldquo;unavailable C primitive&amp;rdquo; error. (Unless dynamic loading of C libraries is supported &amp;ndash; see section &lt;a href=&quot;#ss%3Adynlink-c-code&quot;&gt;20.1.4&lt;/a&gt; below.)</source>
          <target state="translated">기본 모드에서 OCaml 링커는 표준 프리미티브 세트를 사용하여 표준 런타임 시스템에 대한 바이트 코드를 생성합니다. 이 표준 세트에없는 프리미티브에 대한 참조는 &quot;사용할 수없는 C 프리미티브&quot;오류를 발생시킵니다. (C 라이브러리의 동적로드가 지원되지 않는 경우 &amp;ndash; 아래 섹션 &lt;a href=&quot;#ss%3Adynlink-c-code&quot;&gt;20.1.4&lt;/a&gt; 참조)</target>
        </trans-unit>
        <trans-unit id="ada7794c2f0108a93984c8df43895634c9cecfad" translate="yes" xml:space="preserve">
          <source>In the description of a value, type, exception, module, module type, class or class type, the &lt;em&gt;first sentence&lt;/em&gt; is sometimes used in indexes, or when just a part of the description is needed. The first sentence is composed of the first characters of the description, until</source>
          <target state="translated">값, 유형, 예외, 모듈, 모듈 유형, 클래스 또는 클래스 유형에 대한 설명에서 &lt;em&gt;첫 번째 문장&lt;/em&gt; 은 때때로 인덱스에 사용되거나 설명의 일부만 필요할 때 사용됩니다. 첫 번째 문장은 설명의 첫 번째 문자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f380b30f7f2a3bd63aab448ca63ae784823c0a52" translate="yes" xml:space="preserve">
          <source>In the first example, (r:first_record) is an explicit annotation telling OCaml that the type of r is first_record. With this annotation, Ocaml knows that r.x refers to the x field of the first record type. Similarly, the type annotation in the second example makes it clear to OCaml that the constructors A, B and C come from the first variant type. Contrarily, in the last example, OCaml has inferred by itself that the type of r can only be first_record and there are no needs for explicit type annotations.</source>
          <target state="translated">첫 번째 예에서 (r : first_record)는 r의 유형이 first_record임을 OCaml에 알리는 명시 적 주석입니다. 이 주석을 통해 Ocaml은 rx가 첫 번째 레코드 유형의 x 필드를 참조한다는 것을 알고 있습니다. 마찬가지로 두 번째 예제의 유형 어노테이션은 생성자 A, B 및 C가 첫 번째 변형 유형에서 온다는 것을 OCaml에 명확하게합니다. 반대로, 마지막 예제에서 OCaml은 r의 유형이 first_record 일 수 있고 명시적인 유형 주석이 필요하지 않다고 스스로 추론했습니다.</target>
        </trans-unit>
        <trans-unit id="72414e01b80ae620788634a295dac8455ca20b7c" translate="yes" xml:space="preserve">
          <source>In the following code (which might typically occur when g is too large to inline) the value of x would usually be communicated to the application of the + function via the closure of g.</source>
          <target state="translated">다음 코드 (일반적으로 g가 인라인하기에 너무 클 때 발생할 수 있음)에서 x 값은 일반적으로 g의 클로저를 통해 + 함수의 응용 프로그램에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d393b54aa4ad994d5181f438481ee687fee1c9c4" translate="yes" xml:space="preserve">
          <source>In the following code, the compiler observes that the closure returned from the function f contains a variable pair (free in the body of f) that may be split into two separate variables.</source>
          <target state="translated">다음 코드에서 컴파일러는 함수 f에서 반환 된 클로저에 두 개의 개별 변수로 분할 될 수있는 변수 쌍 (f 본문에 무료)이 포함되어 있음을 관찰합니다.</target>
        </trans-unit>
        <trans-unit id="7bc6fdbc296fa731282af07ad9f312e34ebb596f" translate="yes" xml:space="preserve">
          <source>In the following code, there are two closure variables that would typically cause closure allocations. One is called fv and occurs inside the function baz; the other is called z and occurs inside the function bar. In this toy (yet sophisticated) example we again use an attribute to simulate the typical situation where the first argument of baz is too large to inline.</source>
          <target state="translated">다음 코드에는 일반적으로 클로저 할당을 유발하는 두 개의 클로저 변수가 있습니다. 하나는 fv라고하며 baz 함수 내에서 발생합니다. 다른 하나는 z라고하며 기능 표시 줄 내부에서 발생합니다. 이 장난감 (아직 정교함) 예제에서는 baz의 첫 번째 인수가 너무 커서 인라인 할 수없는 일반적인 상황을 시뮬레이션하기 위해 다시 속성을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="721fe5ea332cbc9570673fd6bb094c20e430f05a" translate="yes" xml:space="preserve">
          <source>In the ideal, the right function name with right labels should be enough to understand the function&amp;rsquo;s meaning. Since one can get this information with OCamlBrowser or the ocaml toplevel, the documentation is only used when a more detailed specification is needed.</source>
          <target state="translated">이상적으로 올바른 레이블이있는 올바른 함수 이름은 함수의 의미를 이해하기에 충분해야합니다. OCamlBrowser 또는 ocaml 최상위 수준에서이 정보를 얻을 수 있으므로 설명서는 더 자세한 사양이 필요할 때만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2d0067298cd5d40acc2465837dd4dda28acd2d1e" translate="yes" xml:space="preserve">
          <source>In the object-oriented version of sets, we only need to add an additional method tag to return the representation of a set. Since sets are parametric in the type of elements, the method tag has a parametric type 'a tag, concrete within the module definition but abstract in its signature. From outside, it will then be guaranteed that two objects with a method tag of the same type will share the same representation.</source>
          <target state="translated">객체 지향 버전의 집합에서는 집합의 표현을 반환하기 위해 메서드 태그를 추가하기 만하면됩니다. 집합은 요소 유형에서 매개 변수이기 때문에 메소드 태그에는 모듈 정의 내에서 구체적이지만 서명에서 추상화 된 매개 변수 유형 '태그'가 있습니다. 그러면 외부에서 동일한 유형의 메서드 태그가있는 두 개체가 동일한 표현을 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="291e0dbbf80eac70186d0d4251b427b33b48b1bf" translate="yes" xml:space="preserve">
          <source>In the presence of multiple OCaml threads it should be assumed that any particular finaliser may be executed in any of the threads.</source>
          <target state="translated">여러 OCaml 스레드가있는 경우 특정 종료자가 스레드 중 하나에서 실행될 수 있다고 가정해야합니다.</target>
        </trans-unit>
        <trans-unit id="91ffcab04046ac0c20cbcca9068d8e573beb8496" translate="yes" xml:space="preserve">
          <source>In the return array, the slot at index &lt;code&gt;0&lt;/code&gt; corresponds to the most recent function call, raise, or primitive &lt;code&gt;get_backtrace&lt;/code&gt; call in the trace.</source>
          <target state="translated">반환 배열에서 인덱스 &lt;code&gt;0&lt;/code&gt; 의 슬롯 은 가장 최근의 함수 호출, raise 또는 추적의 기본 &lt;code&gt;get_backtrace&lt;/code&gt; 호출에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="f04d4bfc534031b19b244ea21cf28affe8b39664" translate="yes" xml:space="preserve">
          <source>In the right-hand side of type definitions, references to one of the type constructor name being defined are considered as recursive, unless type is followed by nonrec. The nonrec keyword was introduced in OCaml 4.02.2.</source>
          <target state="translated">유형 정의의 오른쪽에서 정의되는 유형 생성자 이름 중 하나에 대한 참조는 type 뒤에 nonrec가 뒤 따르지 않는 한 재귀적인 것으로 간주됩니다. nonrec 키워드는 OCaml 4.02.2에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="a5f2952289734f5793eb520f8e1b35b465c9b780" translate="yes" xml:space="preserve">
          <source>In the second form, when the body of a local open is itself delimited by parentheses, braces or bracket, the parentheses of the local open can be omitted. For instance,</source>
          <target state="translated">두 번째 형식에서 로컬 열기의 본문 자체가 괄호, 중괄호 또는 대괄호로 구분 된 경우 로컬 열기의 괄호를 생략 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="95d2831b55ddf61b23e5bb88d88a73ddc646b145" translate="yes" xml:space="preserve">
          <source>In the two branches of a conditional expression:</source>
          <target state="translated">조건식의 두 가지 분기 :</target>
        </trans-unit>
        <trans-unit id="7637452d36fadd2ef81ce53e1a83c6e0f70ac963" translate="yes" xml:space="preserve">
          <source>In the two examples above, the list is built bottom-up. Here is an alternate way, that proceeds top-down. It is less efficient, but illustrates the use of caml_modify.</source>
          <target state="translated">위의 두 예에서 목록은 상향식으로 작성됩니다. 하향식으로 진행되는 다른 방법이 있습니다. 덜 효율적이지만 caml_modify의 사용을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="13ef23781b1ec2de1604fab5007923acd1ad0364" translate="yes" xml:space="preserve">
          <source>In the type expression _&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; , the anonymous type expression _ stands in for anonymous type parameters and is equivalent to (_, &amp;hellip;,_) with as many repetitions of _ as the arity of &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;.</source>
          <target state="translated">유형 표현식 _ &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; 에서 익명 유형 표현식 _은 익명 유형 매개 변수를 &lt;a href=&quot;names#typeconstr&quot;&gt;나타내며 typeconstr&lt;/a&gt; 의 배열 만큼 _ 반복 횟수가있는 (_,&amp;hellip;, _)와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="aeaa83fc28e0aae7a51149b7a6b03865bb7a3a40" translate="yes" xml:space="preserve">
          <source>In the type of depth, 'a.'a nested -&amp;gt; int, the type variable 'a is universally quantified. In other words, 'a.'a nested -&amp;gt; int reads as &amp;ldquo;for all type 'a, depth maps 'a nested values to integers&amp;rdquo;. Whereas the standard type 'a nested -&amp;gt; int can be interpreted as &amp;ldquo;let be a type variable 'a, then depth maps 'a nested values to integers&amp;rdquo;. There are two major differences with these two type expressions. First, the explicit polymorphic annotation indicates to the type checker that it needs to introduce a new type variable every times the function depth is applied. This solves our problem with the definition of the function depth.</source>
          <target state="translated">깊이 유형 'a.'a 중첩-&amp;gt; int에서 유형 변수'a는 보편적으로 정량화됩니다. 즉, 'a.'a 중첩-&amp;gt; int는 &quot;모든 유형'a에 대해 깊이가 '중첩 된 값을 정수로 매핑합니다.'로 읽습니다. 표준 유형 'a nested-&amp;gt; int는 &quot;유형 변수'a가되자. 이 두 유형 표현식에는 두 가지 주요 차이점이 있습니다. 첫째, 명시 적 다형성 주석은 함수 깊이가 적용될 때마다 새로운 유형 변수를 도입해야 함을 유형 검사기에 나타냅니다. 이것은 함수 깊이의 정의에 대한 우리의 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="baf32ca6edcb79b806067cc323225825f9b58ce1" translate="yes" xml:space="preserve">
          <source>In this case calling bar from OCaml is as cheap as calling any other OCaml function, except for the fact that the OCaml compiler can&amp;rsquo;t inline C functions...</source>
          <target state="translated">이 경우 OCaml에서 bar를 호출하는 것은 OCaml 컴파일러가 C 함수를 인라인 할 수 없다는 사실을 제외하고는 다른 OCaml 함수를 호출하는 것만 큼 저렴합니다.</target>
        </trans-unit>
        <trans-unit id="f00477d2b2741ddd83a9732844ec5d63894429c4" translate="yes" xml:space="preserve">
          <source>In this case the C functions must look like:</source>
          <target state="translated">이 경우 C 함수는 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="46b3277155ed08f7a13b1d39181a22abf8d356af" translate="yes" xml:space="preserve">
          <source>In this case, OCamldoc will associate Bar.x to the x of module Foo defined just above, instead of to the Bar.x defined in the opened module Foo.</source>
          <target state="translated">이 경우 OCamldoc은 Bar.x를 열린 모듈 Foo에 정의 된 Bar.x 대신 위에 정의 된 모듈 Foo의 x에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="2c7d87e16fce5514152b5af5de0d55e2067da6ca" translate="yes" xml:space="preserve">
          <source>In this case, the function colored_point_to_point is an instance of the function to_point. This is not always true, however. The fully explicit coercion is more precise and is sometimes unavoidable. Consider, for example, the following class:</source>
          <target state="translated">이 경우 colors_point_to_point 함수는 to_point 함수의 인스턴스입니다. 그러나 이것은 항상 사실이 아닙니다. 완전히 명시적인 강제는 더 정확하고 때로는 피할 수 없습니다. 예를 들어 다음 클래스를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9a4b829ccac478d8513bb46a453a748cf8017f00" translate="yes" xml:space="preserve">
          <source>In this case, the type constructor is defined as an abbreviation for the type expression given in the equation, but in addition the constructors or fields given in the representation remain attached to the defined type constructor. The type expression in the equation part must agree with the representation: it must be of the same kind (record or variant) and have exactly the same constructors or fields, in the same order, with the same arguments. Moreover, the new type constructor must have the same arity and the same type constraints as the original type constructor.</source>
          <target state="translated">이 경우 형식 생성자는 방정식에 제공된 형식 식의 약어로 정의되지만 표현에 지정된 생성자 또는 필드는 정의 된 형식 생성자에 연결된 상태로 유지됩니다. 방정식 부분의 유형 표현식은 표현과 일치해야합니다. 동일한 종류 (레코드 또는 변형) 여야하며 동일한 인수를 사용하여 동일한 순서로 정확히 동일한 생성자 또는 필드를 가져야합니다. 또한 새 형식 생성자는 원래 형식 생성자와 동일한 배열 및 형식 제약 조건을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="7bed9185f2bb4af262638e20c9572165f24df5d4" translate="yes" xml:space="preserve">
          <source>In this case, we have x :&amp;gt; xy implies xy proc :&amp;gt; x proc. Notice that the second subtyping relation reverse the order of x and xy: the type constructor 'a proc is contravariant in its parameter 'a. More generally, the function type constructor 'a -&amp;gt; 'b is covariant in its return type 'b and contravariant in its argument type 'a.</source>
          <target state="translated">이 경우 x :&amp;gt; xy는 xy proc :&amp;gt; x proc을 의미합니다. 두 번째 하위 유형 관계는 x와 xy의 순서를 반대로합니다. 유형 생성자 'a proc은 매개 변수'a에서 반 변성입니다. 보다 일반적으로 함수 유형 생성자 'a-&amp;gt;'b는 반환 유형 'b에서 공변이고 인수 유형'a에서 반 변성입니다.</target>
        </trans-unit>
        <trans-unit id="4508d1c66982f1ffb116edbbf95e424005c3367c" translate="yes" xml:space="preserve">
          <source>In this case, we would like to inline f into g, because a conditional jump can be eliminated and the code size should reduce. If the inlining decision has been made after the declaration of f without seeing the use, its size would have probably made it ineligible for inlining; but at the call site, its final size can be known. Further, this function should probably not be inlined systematically: if b is unknown, or indeed false, there is little benefit to trade off against a large increase in code size. In the existing non-Flambda inliner this isn&amp;rsquo;t a great problem because chains of inlining were cut off fairly quickly. However it has led to excessive use of overly-large inlining parameters such as -inline 10000.</source>
          <target state="translated">이 경우 f를 g에 인라인하려고합니다. 조건부 점프를 제거 할 수 있고 코드 크기를 줄여야하기 때문입니다. f 선언 후에 사용을 보지 않고 인라이닝 결정이 내려 졌다면 그 크기로 인해 인라이닝에 적합하지 않을 것입니다. 그러나 호출 사이트에서는 최종 크기를 알 수 있습니다. 또한이 함수는 체계적으로 인라인되어서는 안됩니다. b가 알려지지 않았거나 실제로 거짓이면 코드 크기가 크게 증가하는 것에 대해 절충 할 수있는 이점이 거의 없습니다. 기존 non-Flambda 인라이너에서는 인라인 체인이 상당히 빨리 끊어 졌기 때문에 이것은 큰 문제가 아닙니다. 그러나 -inline 10000과 같이 지나치게 큰 인라인 매개 변수를 과도하게 사용하게되었습니다.</target>
        </trans-unit>
        <trans-unit id="ed102dfb8d13fe24c7ee911f7ad9ad616344d097" translate="yes" xml:space="preserve">
          <source>In this chapter, we show some larger examples using objects, classes and modules. We review many of the object features simultaneously on the example of a bank account. We show how modules taken from the standard library can be expressed as classes. Lastly, we describe a programming pattern known as &lt;em&gt;virtual types&lt;/em&gt; through the example of window managers.</source>
          <target state="translated">이 장에서는 객체, 클래스 및 모듈을 사용하는 몇 가지 더 큰 예제를 보여줍니다. 은행 계좌의 예에서 동시에 많은 개체 기능을 검토합니다. 표준 라이브러리에서 가져온 모듈을 클래스로 표현하는 방법을 보여줍니다. 마지막으로 창 관리자의 예를 통해 &lt;em&gt;가상 유형으로&lt;/em&gt; 알려진 프로그래밍 패턴을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="a536879627c56054020a13fd4e78494ffa306676" translate="yes" xml:space="preserve">
          <source>In this chapter, we use the word &lt;em&gt;element&lt;/em&gt; to refer to any of the following parts of an OCaml source file: a type declaration, a value, a module, an exception, a module type, a type constructor, a record field, a class, a class type, a class method, a class value or a class inheritance clause.</source>
          <target state="translated">이 장에서 우리 는 OCaml 소스 파일의 다음 부분을 참조하기 위해 &lt;em&gt;요소&lt;/em&gt; 라는 단어를 사용 합니다 : 유형 선언, 값, 모듈, 예외, 모듈 유형, 유형 생성자, 레코드 필드, 클래스 , 클래스 유형, 클래스 메서드, 클래스 값 또는 클래스 상속 절.</target>
        </trans-unit>
        <trans-unit id="984f3b4b8f15c43c4ecf6aaa09632d698c5d7be4" translate="yes" xml:space="preserve">
          <source>In this example, the trace will be available at path /tmp/a_prefix.{PID}.eventlog.</source>
          <target state="translated">이 예에서 추적은 /tmp/a_prefix.{PID}.eventlog 경로에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdb410675373da3ea9d54a5f332e8f794b09205d" translate="yes" xml:space="preserve">
          <source>In this section, we illustrate most aspects of Object and inheritance by refining, debugging, and specializing the following initial naive definition of a simple bank account. (We reuse the module Euro defined at the end of chapter &lt;a href=&quot;objectexamples#c%3Aobjectexamples&quot;&gt;3&lt;/a&gt;.)</source>
          <target state="translated">이 섹션에서는 간단한 은행 계좌에 대한 다음과 같은 순진한 정의를 구체화, 디버깅 및 전문화하여 객체 및 상속의 대부분의 측면을 설명합니다. (우리는 &lt;a href=&quot;objectexamples#c%3Aobjectexamples&quot;&gt;3&lt;/a&gt; 장 끝에 정의 된 Euro 모듈을 재사용합니다 .)</target>
        </trans-unit>
        <trans-unit id="7539064d77e16b304225f0f906a69a083f243dd9" translate="yes" xml:space="preserve">
          <source>In this situation, when coercing the module List2 to the module type COLLECTION, the type checker forgets that 'a List2.t was covariant in 'a. Consequently, the relaxed value restriction does not apply anymore:</source>
          <target state="translated">이 상황에서 모듈 List2를 모듈 유형 COLLECTION으로 강제 변환 할 때 유형 검사기는 'List2.t가'a. 결과적으로 완화 된 값 제한은 더 이상 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f55d180a28b55d335204d82281bbcb00ea879279" translate="yes" xml:space="preserve">
          <source>In this use-case, we do not promise that &lt;code&gt;s&lt;/code&gt; will never be mutated after the call to &lt;code&gt;bytes_length&amp;nbsp;s&lt;/code&gt;. The &lt;a href=&quot;string#VALlength&quot;&gt;&lt;code&gt;String.length&lt;/code&gt;&lt;/a&gt; function temporarily borrows unique ownership of the byte sequence (and sees it as a &lt;code&gt;string&lt;/code&gt;), but returns this ownership back to the caller, which may assume that &lt;code&gt;s&lt;/code&gt; is still a valid byte sequence after the call. Note that this is only correct because we know that &lt;a href=&quot;string#VALlength&quot;&gt;&lt;code&gt;String.length&lt;/code&gt;&lt;/a&gt; does not capture its argument -- it could escape by a side-channel such as a memoization combinator.</source>
          <target state="translated">이 사용 사례에서는 &lt;code&gt;s&lt;/code&gt; 가 &lt;code&gt;bytes_length&amp;nbsp;s&lt;/code&gt; 호출 한 후에 절대로 변하지 않을 것이라고 약속하지 않습니다 . &lt;a href=&quot;string#VALlength&quot;&gt; &lt;code&gt;String.length&lt;/code&gt; &lt;/a&gt; 기능을 일시적으로 바이트 시퀀스의 유일한 소유권을 차용 (그리고로 보는 &lt;code&gt;string&lt;/code&gt; ), 그러나 가정 할 수있다 발신자,이 소유권 다시 반환 &lt;code&gt;s&lt;/code&gt; 여전히 호출 후 유효한 바이트 순서입니다. 이것은 &lt;a href=&quot;string#VALlength&quot;&gt; &lt;code&gt;String.length&lt;/code&gt; &lt;/a&gt; 가 인수를 캡처하지 않는다는 것을 알고 있기 때문에 정확합니다 . 메모 화 결합기와 같은 부 채널에 의해 이스케이프 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7981d44158719efab0bd42ae90948f53010bea2f" translate="yes" xml:space="preserve">
          <source>In those situations, local substitutions(see &lt;a href=&quot;signaturesubstitution#ss%3Alocal-substitution&quot;&gt;8.7.2&lt;/a&gt;) can be used instead.</source>
          <target state="translated">이러한 상황에서 로컬 대체 ( &lt;a href=&quot;signaturesubstitution#ss%3Alocal-substitution&quot;&gt;8.7.2&lt;/a&gt; 참조 )를 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90a54a6c41b6e2f305dbef8e3cddea03753f6bf7" translate="yes" xml:space="preserve">
          <source>In what follows, we say that a string has the &lt;em&gt;OCaml encoding&lt;/em&gt; if it is encoded in UTF-8 when in Unicode mode, in the current code page in legacy mode, or is an arbitrary string under Unix. A string has the &lt;em&gt;platform encoding&lt;/em&gt; if it is encoded in UTF-16 under Windows or is an arbitrary string under Unix.</source>
          <target state="translated">다음에서 문자열은 유니 코드 모드에서 UTF-8로 인코딩되거나 레거시 모드의 현재 코드 페이지에서 인코딩되거나 Unix에서 임의의 문자열 인 경우 &lt;em&gt;OCaml 인코딩&lt;/em&gt; 이 있다고 말합니다 . 문자열은 Windows에서 UTF-16으로 인코딩되거나 Unix에서 임의의 문자열 인 경우 &lt;em&gt;플랫폼 인코딩을&lt;/em&gt; 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="7790a0c7a8cccc64f38d56e2325db218d5c6811d" translate="yes" xml:space="preserve">
          <source>Inappropriate I/O control operation</source>
          <target state="translated">부적절한 I / O 제어 작동</target>
        </trans-unit>
        <trans-unit id="2167632468a6eb19b88638f904885e75bed8e2c3" translate="yes" xml:space="preserve">
          <source>Include all modules in the dot output, not only modules given on the command line or loaded with the -load option.</source>
          <target state="translated">명령 줄에 제공되거나 -load 옵션으로로드 된 모듈뿐만 아니라 모든 모듈을 도트 출력에 포함합니다.</target>
        </trans-unit>
        <trans-unit id="dc0da023e49fc7b9722125176291007176551c43" translate="yes" xml:space="preserve">
          <source>Include file</source>
          <target state="translated">파일 포함</target>
        </trans-unit>
        <trans-unit id="936808b03c5417ee614099d8cff4070db8f25a29" translate="yes" xml:space="preserve">
          <source>Include the runtime system in the generated program. This is the default.</source>
          <target state="translated">생성 된 프로그램에 런타임 시스템을 포함합니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="15fc1b72deb0a330387cb4254adc44132b197dbf" translate="yes" xml:space="preserve">
          <source>Increment the integer contained in the given reference.</source>
          <target state="translated">주어진 참조에 포함 된 정수를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="59d0461a6012e030af72a2a2731fc0dc665abb6d" translate="yes" xml:space="preserve">
          <source>Increment the integer contained in the given reference. Equivalent to &lt;code&gt;fun&amp;nbsp;r&amp;nbsp;-&amp;gt;&amp;nbsp;r&amp;nbsp;:=&amp;nbsp;succ&amp;nbsp;!r&lt;/code&gt;.</source>
          <target state="translated">주어진 참조에 포함 된 정수를 증가시킵니다. 상당 &lt;code&gt;fun&amp;nbsp;r&amp;nbsp;-&amp;gt;&amp;nbsp;r&amp;nbsp;:=&amp;nbsp;succ&amp;nbsp;!r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b11b483c20b98095c6b381f3de3e92d1855cc71" translate="yes" xml:space="preserve">
          <source>Indeed, looking at the type of store, we see that the weak type '_weak1 has been replaced by the type int</source>
          <target state="translated">실제로 저장소 유형을 살펴보면 약한 유형 '_weak1이 int 유형으로 대체되었음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76cd4494b768ff6e2b09ff91039093a0249d5c70" translate="yes" xml:space="preserve">
          <source>Indeed, narrowing coercions without runtime checks would be unsafe. Runtime type checks might raise exceptions, and they would require the presence of type information at runtime, which is not the case in the OCaml system. For these reasons, there is no such operation available in the language.</source>
          <target state="translated">실제로 런타임 검사없이 강제 변환을 좁히는 것은 안전하지 않습니다. 런타임 유형 검사는 예외를 발생시킬 수 있으며 OCaml 시스템에서는 그렇지 않은 런타임에 유형 정보가 있어야합니다. 이러한 이유로 해당 언어로 사용할 수있는 작업이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b1073844359beadf5a16114b4cc53a73e228c78" translate="yes" xml:space="preserve">
          <source>Indeed, the latter is safer since the call to deposit will automatically benefit from safety checks and from the trace. Let&amp;rsquo;s test it:</source>
          <target state="translated">실제로 후자는 입금 요청이 안전 점검 및 추적에서 자동으로 혜택을 받기 때문에 더 안전합니다. 테스트 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="cf6cab5c3dce9df70b18150162d696626edc8f58" translate="yes" xml:space="preserve">
          <source>Index of exceptions</source>
          <target state="translated">예외 색인</target>
        </trans-unit>
        <trans-unit id="acdc0800d0656472ebfb5222d7328b080a5b1896" translate="yes" xml:space="preserve">
          <source>Index of keywords</source>
          <target state="translated">키워드 색인</target>
        </trans-unit>
        <trans-unit id="ec495fbe379a155a1562a723fa634c92e4aadb45" translate="yes" xml:space="preserve">
          <source>Index of module types</source>
          <target state="translated">모듈 유형 색인</target>
        </trans-unit>
        <trans-unit id="bbeb088aa2e1f48a2526d4af87412592cfa16c85" translate="yes" xml:space="preserve">
          <source>Index of modules</source>
          <target state="translated">모듈 색인</target>
        </trans-unit>
        <trans-unit id="f3c5f25fe0170a55faf806d3bc5e16c8e3ad5961" translate="yes" xml:space="preserve">
          <source>Index of types</source>
          <target state="translated">유형 색인</target>
        </trans-unit>
        <trans-unit id="47c7c1963655c5cb95aa9b1b9fed86c5ce38b1fc" translate="yes" xml:space="preserve">
          <source>Index of values</source>
          <target state="translated">가치 색인</target>
        </trans-unit>
        <trans-unit id="25c63fb7555ce1007deae3f494c7de8045880005" translate="yes" xml:space="preserve">
          <source>Indicate when the element was introduced.</source>
          <target state="translated">요소가 도입 된시기를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="8e8bd8b065fdca29c6a5b91240b13af0f286f2c2" translate="yes" xml:space="preserve">
          <source>Indirect call site</source>
          <target state="translated">간접 호출 사이트</target>
        </trans-unit>
        <trans-unit id="191d440868ddc01217ec4c3c696c8932eaf72c0e" translate="yes" xml:space="preserve">
          <source>Infix and prefix symbols do not have a fixed meaning: they are simply interpreted as applications of functions bound to the names corresponding to the symbols. The expression &lt;a href=&quot;lex#prefix-symbol&quot;&gt;prefix-symbol&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is interpreted as the application (&lt;a href=&quot;lex#prefix-symbol&quot;&gt;prefix-symbol&lt;/a&gt;)&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. Similarly, the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;lex#infix-symbol&quot;&gt;infix-symbol&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is interpreted as the application (&lt;a href=&quot;lex#infix-symbol&quot;&gt;infix-symbol&lt;/a&gt;)&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="translated">중위 및 접두사 기호는 고정 된 의미가 없습니다. 단순히 기호에 해당하는 이름에 바인딩 된 함수의 응용 프로그램으로 해석됩니다. 표현식 &lt;a href=&quot;lex#prefix-symbol&quot;&gt;prefix-symbol &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 은 application ( &lt;a href=&quot;lex#prefix-symbol&quot;&gt;prefix-symbol&lt;/a&gt; ) &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 로 해석됩니다 . 마찬가지로 표현식 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1 &lt;/sub&gt;&lt;a href=&quot;lex#infix-symbol&quot;&gt;infix-symbol &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 는 application ( &lt;a href=&quot;lex#infix-symbol&quot;&gt;infix-symbol&lt;/a&gt; ) &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1 &lt;/sub&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe7734c62845cd6e1a492fb7d09067d4ff38b544" translate="yes" xml:space="preserve">
          <source>Information on a module can be extracted either from the .mli or .ml file, or both, depending on the files given on the command line. When both .mli and .ml files are given for the same module, information extracted from these files is merged according to the following rules:</source>
          <target state="translated">모듈에 대한 정보는 명령 줄에 제공된 파일에 따라 .mli 또는 .ml 파일에서 추출하거나 둘 다에서 추출 할 수 있습니다. 동일한 모듈에 대해 .mli 및 .ml 파일이 모두 제공되면 이러한 파일에서 추출 된 정보는 다음 규칙에 따라 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="2d1caa25b463767e262eac6152e176e3ab952570" translate="yes" xml:space="preserve">
          <source>Initial meaning</source>
          <target state="translated">초기 의미</target>
        </trans-unit>
        <trans-unit id="9dbb564f9dda009f80e001d3b6ad4b6730abcccc" translate="yes" xml:space="preserve">
          <source>Initialize the generator with a random seed chosen in a system-dependent way.</source>
          <target state="translated">시스템 종속 방식으로 선택한 임의의 시드로 생성기를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="e3705fbbfc33bff4987a51058b1e193b68718b84" translate="yes" xml:space="preserve">
          <source>Initialize the generator with a random seed chosen in a system-dependent way. If &lt;code&gt;/dev/urandom&lt;/code&gt; is available on the host machine, it is used to provide a highly random initial seed. Otherwise, a less random seed is computed from system parameters (current time, process IDs).</source>
          <target state="translated">시스템 종속 방식으로 선택한 임의의 시드로 생성기를 초기화합니다. 경우 &lt;code&gt;/dev/urandom&lt;/code&gt; 호스트 컴퓨터로 볼 수 있습니다, 매우 임의 초기 씨앗을 제공하는 데 사용됩니다. 그렇지 않으면 시스템 매개 변수 (현재 시간, 프로세스 ID)에서 덜 임의의 시드가 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="d0558cb2a265a245a0a77457b30a3ebd5743bac6" translate="yes" xml:space="preserve">
          <source>Initialize the generator, using the argument as a seed.</source>
          <target state="translated">인수를 시드로 사용하여 생성기를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="9a062ab889be546ba6ce3373ed6772b07b5c2ea5" translate="yes" xml:space="preserve">
          <source>Initialize the generator, using the argument as a seed. The same seed will always yield the same sequence of numbers.</source>
          <target state="translated">인수를 시드로 사용하여 생성기를 초기화합니다. 동일한 시드는 항상 동일한 일련의 숫자를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9e19123dd5402986d7ab5c0b5abd27d1fded34ec" translate="yes" xml:space="preserve">
          <source>Initializers cannot be overridden. On the contrary, all initializers are evaluated sequentially. Initializers are particularly useful to enforce invariants. Another example can be seen in section &lt;a href=&quot;advexamples#s%3Aextended-bank-accounts&quot;&gt;6.1&lt;/a&gt;.</source>
          <target state="translated">이니셜 라이저는 재정의 할 수 없습니다. 반대로 모든 이니셜 라이저는 순차적으로 평가됩니다. 이니셜 라이저는 특히 불변성을 적용하는 데 유용합니다. &lt;a href=&quot;advexamples#s%3Aextended-bank-accounts&quot;&gt;6.1&lt;/a&gt; 절에서 또 다른 예를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="62be43bf10903b9dc899eb01b40be45122b8d091" translate="yes" xml:space="preserve">
          <source>Initially all compilation units composing the program currently running are available for reference from dynamically-linked units. &lt;code&gt;set_allowed_units&lt;/code&gt; can be used to restrict access to a subset of these units, e.g. to the units that compose the API for dynamically-linked code, and prevent access to all other units, e.g. private, internal modules of the running program.</source>
          <target state="translated">처음에는 현재 실행중인 프로그램을 구성하는 모든 컴파일 단위를 동적으로 연결된 단위에서 참조 할 수 있습니다. &lt;code&gt;set_allowed_units&lt;/code&gt; 를 사용하여 이러한 단위의 하위 집합 (예 : 동적으로 연결된 코드 용 API를 구성하는 단위)에 대한 액세스를 제한하고 실행중인 프로그램의 비공개 내부 모듈과 같은 다른 모든 단위에 대한 액세스를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b06c7e11e0b9786df67b9cc22d90d3a95785831" translate="yes" xml:space="preserve">
          <source>Inlining impossible.</source>
          <target state="translated">인라인 불가능.</target>
        </trans-unit>
        <trans-unit id="3b0e45ff90a6d9597b56ccc3164ed9d48a57e6e5" translate="yes" xml:space="preserve">
          <source>Inlining is performed together with all of the other Flambda optimisation passes, that is to say, after closure conversion. This has three particular advantages over a potentially more straightforward implementation prior to closure conversion:</source>
          <target state="translated">인라인은 다른 모든 Flambda 최적화 단계, 즉 클로저 변환 후 함께 수행됩니다. 이것은 클로저 변환 이전에 잠재적으로 더 간단한 구현에 비해 세 가지 특별한 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6913b13f09c798d326ff4e05ee1ae94c7cf9c288" translate="yes" xml:space="preserve">
          <source>Inlining typically results in an increase in code size, which if left unchecked, may not only lead to grossly large executables and excessive compilation times but also a decrease in performance due to worse locality. As such, the Flambda inliner trades off the change in code size against the expected runtime performance benefit, with the benefit being computed based on the number of operations that the compiler observes may be removed as a result of inlining.</source>
          <target state="translated">인라이닝은 일반적으로 코드 크기를 증가시킵니다. 체크하지 않으면 실행 파일이 엄청나게 커지고 컴파일 시간이 과도하게 증가 할뿐만 아니라 지역성이 악화되어 성능이 저하 될 수 있습니다. 따라서 Flambda 인라이너는 예상되는 런타임 성능 이점과 코드 크기 변경을 상쇄하며 컴파일러가 관찰하는 작업 수를 기반으로 계산되는 이점은 인라인 결과로 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b56e2846e27a402309f12b5d96bce8a00e3f7444" translate="yes" xml:space="preserve">
          <source>Inlining within recursive functions of calls to other functions in the same mutually-recursive group is kept in check by an &lt;em&gt;unrolling depth&lt;/em&gt;, described below. This ensures that functions are not unrolled to excess. (Unrolling is only enabled if -O3 optimisation level is selected and/or the -inline-max-unroll flag is passed with an argument greater than zero.)</source>
          <target state="translated">동일한 상호 재귀 그룹의 다른 함수에 대한 호출의 재귀 함수 내 인라인 은 아래에 설명 된대로 &lt;em&gt;풀림 깊이에&lt;/em&gt; 의해 확인됩니다 . 이렇게하면 기능이 과도하게 풀리지 않습니다. (언 롤링은 -O3 최적화 수준이 선택되고 / 또는 -inline-max-unroll 플래그가 0보다 큰 인수와 함께 전달되는 경우에만 활성화됩니다.)</target>
        </trans-unit>
        <trans-unit id="f4ae3ab2d64c2a48b49309cd566806beea18ab73" translate="yes" xml:space="preserve">
          <source>Innocuous unused variable: unused variable that is not bound with let nor as, and doesn&amp;rsquo;t start with an underscore (_) character.</source>
          <target state="translated">무해한 미사용 변수 : let이나 as로 묶이지 않고 밑줄 (_) 문자로 시작하지 않는 미사용 변수입니다.</target>
        </trans-unit>
        <trans-unit id="18969234f3dbfdf448abc9f07e07414d5833db11" translate="yes" xml:space="preserve">
          <source>Inode number</source>
          <target state="translated">Inode 번호</target>
        </trans-unit>
        <trans-unit id="2e286662d51034aaf951f8c590e939c61a0c7752" translate="yes" xml:space="preserve">
          <source>Input baud rate.</source>
          <target state="translated">입력 전송 속도.</target>
        </trans-unit>
        <trans-unit id="2af110399d643ab732597b92ca411b83ee621406" translate="yes" xml:space="preserve">
          <source>Input functions on standard input</source>
          <target state="translated">표준 입력의 입력 기능</target>
        </trans-unit>
        <trans-unit id="fb0a243ff8f728fbc19eee3b8e30be0cbc1fada8" translate="yes" xml:space="preserve">
          <source>Input signature of the functor &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">펑터 &lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; &lt;/a&gt; 의 입력 서명 .</target>
        </trans-unit>
        <trans-unit id="106aa4d5f66d17b870cd55da1c3ba9108d80de1e" translate="yes" xml:space="preserve">
          <source>Input signature of the functor &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">펑터 &lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; &lt;/a&gt; 의 입력 서명 .</target>
        </trans-unit>
        <trans-unit id="cb4637425273984e359cae1faec33aab011257fa" translate="yes" xml:space="preserve">
          <source>Input to the toplevel can span several lines. It is terminated by ;; (a double-semicolon). The toplevel input consists in one or several toplevel phrases, with the following syntax:</source>
          <target state="translated">최상위 수준에 대한 입력은 여러 줄에 걸쳐있을 수 있습니다. ;;에 의해 종료됩니다. (이중 세미콜론). 최상위 입력은 다음 구문을 사용하는 하나 이상의 최상위 구문으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="249f397392db7fe682a1d1ecc1a52c8e40ceb983" translate="yes" xml:space="preserve">
          <source>Input/output</source>
          <target state="translated">Input/output</target>
        </trans-unit>
        <trans-unit id="3bbbd8e97ab8a67ba17de562bff8af90fa53faaf" translate="yes" xml:space="preserve">
          <source>Input/output with timeout</source>
          <target state="translated">시간 초과가있는 입력 / 출력</target>
        </trans-unit>
        <trans-unit id="bb706c985ba3ad0bfe191f4ce7255d21cd26c340" translate="yes" xml:space="preserve">
          <source>Inside a class definition, newly defined types are not available for subtyping, as the type abbreviations are not yet completely defined. There is an exception for coercing self to the (exact) type of its class: this is allowed if the type of self does not appear in a contravariant position in the class type, &lt;em&gt;i.e.&lt;/em&gt; if there are no binary methods.</source>
          <target state="translated">클래스 정의 내에서 새로 정의 된 유형은 유형 약어가 아직 완전히 정의되지 않았기 때문에 하위 유형에 사용할 수 없습니다. self를 클래스의 (정확한) 유형으로 강제하는 예외가 있습니다. self 유형이 클래스 유형에서 반 변성 위치에 나타나지 않는 경우 , &lt;em&gt;즉&lt;/em&gt; 이진 메소드가없는 경우 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a205e6f672b9fdfb59c252492e5d0840aba8c432" translate="yes" xml:space="preserve">
          <source>Inside a tabulation box, special &lt;em&gt;tabulation markers&lt;/em&gt; defines points of interest on the line (for instance to delimit cell boundaries). Function &lt;a href=&quot;format#VALset_tab&quot;&gt;&lt;code&gt;Format.set_tab&lt;/code&gt;&lt;/a&gt; sets a tabulation marker at insertion point.</source>
          <target state="translated">표 상자 내에서 특수 &lt;em&gt;표 표식&lt;/em&gt; 은 선에서 관심 지점을 정의합니다 (예 : 셀 경계를 구분하기 위해). &lt;a href=&quot;format#VALset_tab&quot;&gt; &lt;code&gt;Format.set_tab&lt;/code&gt; &lt;/a&gt; 함수 는 삽입 지점에 표 표시 자를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d4bc21673d22d7a226cf1a154d1dc9f5b82d92ea" translate="yes" xml:space="preserve">
          <source>Inside signatures, extended opens are limited to extended module paths,</source>
          <target state="translated">서명 내에서 확장 된 열기는 확장 된 모듈 경로로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="08d3888f1ab23958e132facd2acfbe644974db97" translate="yes" xml:space="preserve">
          <source>Instance variable overridden.</source>
          <target state="translated">인스턴스 변수가 재정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="22f04c4ba964874db6809362b1a8926b072c78c2" translate="yes" xml:space="preserve">
          <source>Instance variables</source>
          <target state="translated">인스턴스 변수</target>
        </trans-unit>
        <trans-unit id="f37452f8cdfca7d287d0436f2a77363400920136" translate="yes" xml:space="preserve">
          <source>Instance variables can also be declared as virtual, with the same effect as with methods.</source>
          <target state="translated">인스턴스 변수는 메서드와 동일한 효과로 가상으로 선언 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cbf3c792bd63a3e48e2769ecf3367f834405f89" translate="yes" xml:space="preserve">
          <source>Instead of building simultaneously the bytecode library, the native-code library and the C libraries, ocamlmklib can be called three times to build each separately. Thus,</source>
          <target state="translated">바이트 코드 라이브러리, 네이티브 코드 라이브러리 및 C 라이브러리를 동시에 빌드하는 대신 ocamlmklib를 세 번 호출하여 각각 개별적으로 빌드 할 수 있습니다. 그러므로,</target>
        </trans-unit>
        <trans-unit id="5c04639e128bd9a951383bb5ff32e6f5c8aaf672" translate="yes" xml:space="preserve">
          <source>Instead of manually taking profiling heap snapshots with this module it is possible to use an automatic snapshot facility that writes profiling information at fixed intervals to a file. To enable this, all that needs to be done is to build the relevant program using a compiler configured with -spacetime; and set the environment variable OCAML_SPACETIME_INTERVAL to an integer number of milliseconds giving the interval between profiling heap snapshots. This interval should not be made excessively small relative to the running time of the program. A typical interval to start with might be 1/100 of the running time of the program. The program must exit &quot;normally&quot; (i.e. by calling &lt;code&gt;exit&lt;/code&gt;, with whatever exit code, rather than being abnormally terminated by a signal) so that the snapshot file is correctly completed.</source>
          <target state="translated">이 모듈을 사용하여 수동으로 프로파일 링 힙 스냅 샷을 만드는 대신 고정 된 간격으로 파일에 프로파일 링 정보를 쓰는 자동 스냅 샷 기능을 사용할 수 있습니다. 이 기능을 사용하려면 -spacetime으로 구성된 컴파일러를 사용하여 관련 프로그램을 빌드하기 만하면됩니다. 환경 변수 OCAML_SPACETIME_INTERVAL을 프로파일 링 힙 스냅 샷 사이의 간격을 제공하는 정수 밀리 초로 설정합니다. 이 간격은 프로그램의 실행 시간에 비해 지나치게 작게 만들어서는 안됩니다. 시작하는 일반적인 간격은 프로그램 실행 시간의 1/100입니다. 프로그램은 &quot;정상적으로&quot;(즉 , 신호에 의해 비정상적으로 종료되지 않고 종료 코드로 &lt;code&gt;exit&lt;/code&gt; 를 호출 하여) 종료되어야 스냅 샷 파일이 올바르게 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="e943b527aa4ff5b9d82f9025dbdd34ab27b52c5d" translate="yes" xml:space="preserve">
          <source>Instead of using the automatic snapshot facility described above it is also possible to manually control Spacetime profiling. (The environment variables OCAML_SPACETIME_INTERVAL and OCAML_SPACETIME_SNAPSHOT_DIR are then not relevant.) Full documentation as regards this method of profiling is provided in the standard library documentation (section &lt;a href=&quot;stdlib#c%3Astdlib&quot;&gt;26&lt;/a&gt;) for the Spacetime module.</source>
          <target state="translated">위에서 설명한 자동 스냅 샷 기능을 사용하는 대신 Spacetime 프로파일 링을 수동으로 제어 할 수도 있습니다. (환경 변수 OCAML_SPACETIME_INTERVAL 및 OCAML_SPACETIME_SNAPSHOT_DIR은 관련이 없습니다.)이 프로파일 링 방법과 관련된 전체 문서 는 Spacetime 모듈 에 대한 표준 라이브러리 문서 (섹션 &lt;a href=&quot;stdlib#c%3Astdlib&quot;&gt;26&lt;/a&gt; )에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="00c73f5f7ad74401722214f0974a3eff4d870dcf" translate="yes" xml:space="preserve">
          <source>Instead you should make sure that &lt;code&gt;v&lt;/code&gt; is not in the closure of the finalisation function by writing:</source>
          <target state="translated">대신 다음 과 같이 작성하여 &lt;code&gt;v&lt;/code&gt; 가 종료 함수를 닫지 않도록 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="25f985c284e754031dd21f1a5c5f41e90ae95c89" translate="yes" xml:space="preserve">
          <source>Instead, we compile with afl-fuzz instrumentation enabled:</source>
          <target state="translated">대신 afl-fuzz 계측을 활성화하여 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="15381ff97a37fb400782fdaa2c7388f15a9ffe29" translate="yes" xml:space="preserve">
          <source>Int and float literals followed by an one-letter identifier in the range [g..z∣ G..Z] are extension-only literals.</source>
          <target state="translated">[g..z∣ G..Z] 범위에서 한 글자 식별자가 뒤 따르는 Int 및 float 리터럴은 확장 전용 리터럴입니다.</target>
        </trans-unit>
        <trans-unit id="f4753a4dee54ee10a75b28c6d04eb9ea0d19acce" translate="yes" xml:space="preserve">
          <source>Int32</source>
          <target state="translated">Int32</target>
        </trans-unit>
        <trans-unit id="2ce3094d56f1473f235bddadb9d8bc7ef3c8506c" translate="yes" xml:space="preserve">
          <source>Int32_val(v) returns the 32-bit integer contained in the int32v.</source>
          <target state="translated">Int32_val (v)는 int32v에 포함 된 32 비트 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="180fcbe698d0f2c44101a06215c472930bbd0a01" translate="yes" xml:space="preserve">
          <source>Int64</source>
          <target state="translated">Int64</target>
        </trans-unit>
        <trans-unit id="01401a6dfc8f66f16b91660dc052300e61a41944" translate="yes" xml:space="preserve">
          <source>Int64_val(v) returns the 64-bit integer contained in the int64v.</source>
          <target state="translated">Int64_val (v)는 int64v에 포함 된 64 비트 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ca17dea0b5499b7267626775e6fb9adb332e238d" translate="yes" xml:space="preserve">
          <source>Int_val(v) returns the int encoded in value v.</source>
          <target state="translated">Int_val (v)는 v 값으로 인코딩 된 int를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="32ddd0cbe8aab89d143f0365d7027496f8c8f9b4" translate="yes" xml:space="preserve">
          <source>Integer addition.</source>
          <target state="translated">정수 더하기.</target>
        </trans-unit>
        <trans-unit id="51469f7cf19f5aef555ff312b610dd3233d7b502" translate="yes" xml:space="preserve">
          <source>Integer addition. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">정수 더하기. 왼쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="799eea857bb7f3051065789cb42f9d772482ce76" translate="yes" xml:space="preserve">
          <source>Integer arithmetic</source>
          <target state="translated">정수 산술</target>
        </trans-unit>
        <trans-unit id="7b97f0e3b005e1c50bd3f2e901953649a16fbfda" translate="yes" xml:space="preserve">
          <source>Integer division.</source>
          <target state="translated">정수 나누기.</target>
        </trans-unit>
        <trans-unit id="497f091783378895fdc4d9e7953e5a08e182ce5c" translate="yes" xml:space="preserve">
          <source>Integer division. Integer division rounds the real quotient of its arguments towards zero. More precisely, if &lt;code&gt;x&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; and &lt;code&gt;y&amp;nbsp;&amp;gt;&amp;nbsp;0&lt;/code&gt;, &lt;code&gt;x&amp;nbsp;/&amp;nbsp;y&lt;/code&gt; is the greatest integer less than or equal to the real quotient of &lt;code&gt;x&lt;/code&gt; by &lt;code&gt;y&lt;/code&gt;. Moreover, &lt;code&gt;(-&amp;nbsp;x)&amp;nbsp;/&amp;nbsp;y&amp;nbsp;=&amp;nbsp;x&amp;nbsp;/&amp;nbsp;(-&amp;nbsp;y)&amp;nbsp;=&amp;nbsp;-&amp;nbsp;(x&amp;nbsp;/&amp;nbsp;y)&lt;/code&gt;. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">정수 나누기. 정수 나눗셈은 인수의 실제 몫을 0으로 반올림합니다. 보다 구체적으로, 만약 &lt;code&gt;x&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; 및 &lt;code&gt;y&amp;nbsp;&amp;gt;&amp;nbsp;0&lt;/code&gt; , &lt;code&gt;x&amp;nbsp;/&amp;nbsp;y&lt;/code&gt; 보다 작은 최대의 정수이거나 실제의 몫과 동일한 &lt;code&gt;x&lt;/code&gt; 의해 &lt;code&gt;y&lt;/code&gt; . 또한 &lt;code&gt;(-&amp;nbsp;x)&amp;nbsp;/&amp;nbsp;y&amp;nbsp;=&amp;nbsp;x&amp;nbsp;/&amp;nbsp;(-&amp;nbsp;y)&amp;nbsp;=&amp;nbsp;-&amp;nbsp;(x&amp;nbsp;/&amp;nbsp;y)&lt;/code&gt; . 왼쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="cd2f1f4758df5a6c46bd95dca7106b6f2bd262a0" translate="yes" xml:space="preserve">
          <source>Integer division. Raise Division_by_zero if second argument is zero.</source>
          <target state="translated">정수 나누기. 두 번째 인수가 0이면 Division_by_zero를 올립니다.</target>
        </trans-unit>
        <trans-unit id="9277b24b9c7ec7c2802db27cc9cc0d888c4a2627" translate="yes" xml:space="preserve">
          <source>Integer division. This division rounds the real quotient of its arguments towards zero, as specified for &lt;a href=&quot;stdlib#VAL(/)&quot;&gt;&lt;code&gt;(/)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정수 나누기. 이 나눗셈은 &lt;a href=&quot;stdlib#VAL(/)&quot;&gt; &lt;code&gt;(/)&lt;/code&gt; 에&lt;/a&gt; 지정된대로 인수의 실수 몫을 0으로 반올림합니다 .</target>
        </trans-unit>
        <trans-unit id="a70bb5f8ea15b1d1eb87ef3499d1ad101d2ec5ac" translate="yes" xml:space="preserve">
          <source>Integer modulus. Raise Division_by_zero if second argument is zero.</source>
          <target state="translated">정수 계수. 두 번째 인수가 0이면 Division_by_zero를 올립니다.</target>
        </trans-unit>
        <trans-unit id="4e1c23fc1293a5342dcbb3f224d5a8468fa0f38f" translate="yes" xml:space="preserve">
          <source>Integer multiplication.</source>
          <target state="translated">정수 곱셈.</target>
        </trans-unit>
        <trans-unit id="8648a8d2bc260aeaf65eefba9783a89ca4ed0085" translate="yes" xml:space="preserve">
          <source>Integer multiplication. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">정수 곱셈. 왼쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="032eaf1313070ba2c07142e51665d3b149104407" translate="yes" xml:space="preserve">
          <source>Integer negation.</source>
          <target state="translated">정수 부정.</target>
        </trans-unit>
        <trans-unit id="02df94240577ba3af6cd59998f11bcb26c753b82" translate="yes" xml:space="preserve">
          <source>Integer remainder.</source>
          <target state="translated">정수 나머지.</target>
        </trans-unit>
        <trans-unit id="608e0fbf1419a8074d877b3d35e821cc489e0512" translate="yes" xml:space="preserve">
          <source>Integer remainder. If &lt;code&gt;y&lt;/code&gt; is not zero, the result of &lt;code&gt;Int32.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; satisfies the following property: &lt;code&gt;x&amp;nbsp;=&amp;nbsp;Int32.add&amp;nbsp;(Int32.mul&amp;nbsp;(Int32.div&amp;nbsp;x&amp;nbsp;y)&amp;nbsp;y)&amp;nbsp;(Int32.rem&amp;nbsp;x&amp;nbsp;y)&lt;/code&gt;. If &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;, &lt;code&gt;Int32.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; raises &lt;code&gt;Division_by_zero&lt;/code&gt;.</source>
          <target state="translated">정수 나머지. 경우 &lt;code&gt;y&lt;/code&gt; 는 0이 아닌, 결과 &lt;code&gt;Int32.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; 만족하는 다음의 속성 : &lt;code&gt;x&amp;nbsp;=&amp;nbsp;Int32.add&amp;nbsp;(Int32.mul&amp;nbsp;(Int32.div&amp;nbsp;x&amp;nbsp;y)&amp;nbsp;y)&amp;nbsp;(Int32.rem&amp;nbsp;x&amp;nbsp;y)&lt;/code&gt; . 경우 &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt; , &lt;code&gt;Int32.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; 제기 &lt;code&gt;Division_by_zero&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="487f9e5fe125fb675e3c64cef0e69cc68128df1c" translate="yes" xml:space="preserve">
          <source>Integer remainder. If &lt;code&gt;y&lt;/code&gt; is not zero, the result of &lt;code&gt;Int64.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; satisfies the following property: &lt;code&gt;x&amp;nbsp;=&amp;nbsp;Int64.add&amp;nbsp;(Int64.mul&amp;nbsp;(Int64.div&amp;nbsp;x&amp;nbsp;y)&amp;nbsp;y)&amp;nbsp;(Int64.rem&amp;nbsp;x&amp;nbsp;y)&lt;/code&gt;. If &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;, &lt;code&gt;Int64.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; raises &lt;code&gt;Division_by_zero&lt;/code&gt;.</source>
          <target state="translated">정수 나머지. 경우 &lt;code&gt;y&lt;/code&gt; 는 0이 아닌, 결과 &lt;code&gt;Int64.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; 만족하는 다음의 속성 : &lt;code&gt;x&amp;nbsp;=&amp;nbsp;Int64.add&amp;nbsp;(Int64.mul&amp;nbsp;(Int64.div&amp;nbsp;x&amp;nbsp;y)&amp;nbsp;y)&amp;nbsp;(Int64.rem&amp;nbsp;x&amp;nbsp;y)&lt;/code&gt; . 경우 &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt; , &lt;code&gt;Int64.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; 제기 &lt;code&gt;Division_by_zero&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="e3fbea780e541621ae7cf3f5b034731f03103fd9" translate="yes" xml:space="preserve">
          <source>Integer remainder. If &lt;code&gt;y&lt;/code&gt; is not zero, the result of &lt;code&gt;Nativeint.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; satisfies the following properties: &lt;code&gt;Nativeint.zero&amp;nbsp;&amp;lt;=&amp;nbsp;Nativeint.rem&amp;nbsp;x&amp;nbsp;y&amp;nbsp;&amp;lt;&amp;nbsp;Nativeint.abs&amp;nbsp;y&lt;/code&gt; and &lt;code&gt;x&amp;nbsp;=&amp;nbsp;Nativeint.add&amp;nbsp;(Nativeint.mul&amp;nbsp;(Nativeint.div&amp;nbsp;x&amp;nbsp;y)&amp;nbsp;y)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(Nativeint.rem&amp;nbsp;x&amp;nbsp;y)&lt;/code&gt;. If &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;, &lt;code&gt;Nativeint.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; raises &lt;code&gt;Division_by_zero&lt;/code&gt;.</source>
          <target state="translated">정수 나머지. 경우 &lt;code&gt;y&lt;/code&gt; 는 0이 아닌, 결과 &lt;code&gt;Nativeint.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; 다음 특성을 만족 : &lt;code&gt;Nativeint.zero&amp;nbsp;&amp;lt;=&amp;nbsp;Nativeint.rem&amp;nbsp;x&amp;nbsp;y&amp;nbsp;&amp;lt;&amp;nbsp;Nativeint.abs&amp;nbsp;y&lt;/code&gt; 및 &lt;code&gt;x&amp;nbsp;=&amp;nbsp;Nativeint.add&amp;nbsp;(Nativeint.mul&amp;nbsp;(Nativeint.div&amp;nbsp;x&amp;nbsp;y)&amp;nbsp;y)&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(Nativeint.rem&amp;nbsp;x&amp;nbsp;y)&lt;/code&gt; . 경우 &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt; , &lt;code&gt;Nativeint.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; 제기 &lt;code&gt;Division_by_zero&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="dfd76a7086e3cc42170f403e6e55cc09afe26cb2" translate="yes" xml:space="preserve">
          <source>Integer remainder. If &lt;code&gt;y&lt;/code&gt; is not zero, the result of &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; satisfies the following properties: &lt;code&gt;x&amp;nbsp;=&amp;nbsp;(x&amp;nbsp;/&amp;nbsp;y)&amp;nbsp;*&amp;nbsp;y&amp;nbsp;+&amp;nbsp;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; and &lt;code&gt;abs(x&amp;nbsp;mod&amp;nbsp;y)&amp;nbsp;&amp;lt;=&amp;nbsp;abs(y)&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;. If &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;, &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; raises &lt;code&gt;Division_by_zero&lt;/code&gt;. Note that &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; is negative only if &lt;code&gt;x&amp;nbsp;&amp;lt;&amp;nbsp;0&lt;/code&gt;. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">정수 나머지. 경우 &lt;code&gt;y&lt;/code&gt; 는 0이 아닌, 결과 &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; 만족하는 다음의 속성 : &lt;code&gt;x&amp;nbsp;=&amp;nbsp;(x&amp;nbsp;/&amp;nbsp;y)&amp;nbsp;*&amp;nbsp;y&amp;nbsp;+&amp;nbsp;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; 및 &lt;code&gt;abs(x&amp;nbsp;mod&amp;nbsp;y)&amp;nbsp;&amp;lt;=&amp;nbsp;abs(y)&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; . 경우 &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt; , &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; 제기 &lt;code&gt;Division_by_zero&lt;/code&gt; 이 . 주 &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; 음수 인 경우에만 &lt;code&gt;x&amp;nbsp;&amp;lt;&amp;nbsp;0&lt;/code&gt; . 왼쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="9b01a6a7b79fbcb183062af64aaaa63eeb3f2718" translate="yes" xml:space="preserve">
          <source>Integer subtraction.</source>
          <target state="translated">정수 빼기.</target>
        </trans-unit>
        <trans-unit id="80d24914c47006eb02f4dff06d0cd904dc2d2c7e" translate="yes" xml:space="preserve">
          <source>Integer subtraction. Left-associative operator, , see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">정수 빼기. 왼쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="7ee1ee4b4f11b2969952d343f112afa9881a1bab" translate="yes" xml:space="preserve">
          <source>Integer values are integer numbers from &amp;minus;2&lt;sup&gt;30&lt;/sup&gt; to 2&lt;sup&gt;30&lt;/sup&gt;&amp;minus;1, that is &amp;minus;1073741824 to 1073741823. The implementation may support a wider range of integer values: on 64-bit platforms, the current implementation supports integers ranging from &amp;minus;2&lt;sup&gt;62&lt;/sup&gt; to 2&lt;sup&gt;62&lt;/sup&gt;&amp;minus;1.</source>
          <target state="translated">정수 값은 &amp;minus;2 &lt;sup&gt;30&lt;/sup&gt; ~ 2 &lt;sup&gt;30&lt;/sup&gt; &amp;minus;1 범위의 정수, 즉 &amp;minus;1073741824 ~ 1073741823입니다. 구현시 더 넓은 범위의 정수 값을 지원할 수 있습니다. 64 비트 플랫폼에서 현재 구현은 &amp;minus;2 &lt;sup&gt;62&lt;/sup&gt; ~ 2 &lt;sup&gt;(62)&lt;/sup&gt; -1.</target>
        </trans-unit>
        <trans-unit id="712ee29f7fc5c28dea5cc603b21eca7741d78fbd" translate="yes" xml:space="preserve">
          <source>Integer values encode 63-bit signed integers (31-bit on 32-bit architectures). They are unboxed (unallocated).</source>
          <target state="translated">정수 값은 부호있는 63 비트 정수 (32 비트 아키텍처의 경우 31 비트)를 인코딩합니다. 상자가 풀립니다 (할당되지 않음).</target>
        </trans-unit>
        <trans-unit id="f83aa7411530d0444302d56a388b902fdce29d91" translate="yes" xml:space="preserve">
          <source>Integer values.</source>
          <target state="translated">정수 값.</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="bc497571cb33f7c1a8b4b38e571f47e9c94eb5e7" translate="yes" xml:space="preserve">
          <source>Integers are &lt;a href=&quot;sys#VALint_size&quot;&gt;&lt;code&gt;Sys.int_size&lt;/code&gt;&lt;/a&gt; bits wide and use two's complement representation. All operations are taken modulo 2&lt;sup&gt;&lt;code&gt;Sys.int_size&lt;/code&gt;&lt;/sup&gt;. They do not fail on overflow.</source>
          <target state="translated">정수는 &lt;a href=&quot;sys#VALint_size&quot;&gt; &lt;code&gt;Sys.int_size&lt;/code&gt; &lt;/a&gt; 비트 폭이며 2의 보수 표현을 사용합니다. 모든 작업은 2 &lt;sup&gt; &lt;code&gt;Sys.int_size&lt;/code&gt; &lt;/sup&gt; 모듈로 수행됩니다 . 오버플로시 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4241877025d1966580ad7c3f3b0ff442755310e" translate="yes" xml:space="preserve">
          <source>Integers are &lt;code&gt;Sys.int_size&lt;/code&gt; bits wide. All operations are taken modulo 2&lt;sup&gt;&lt;code&gt;Sys.int_size&lt;/code&gt;&lt;/sup&gt;. They do not fail on overflow.</source>
          <target state="translated">정수는 &lt;code&gt;Sys.int_size&lt;/code&gt; 비트 폭입니다. 모든 작업은 2 &lt;sup&gt; &lt;code&gt;Sys.int_size&lt;/code&gt; &lt;/sup&gt; 모듈로 수행됩니다 . 오버플로시 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4a102c4a574ecfadd9a7c5f1722bd0399b5d2cd" translate="yes" xml:space="preserve">
          <source>Integers are not allocated and cannot be stored in weak arrays.</source>
          <target state="translated">정수는 할당되지 않으며 약한 배열에 저장할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="935ae25e71bde4c78ba85d5dac1b5c31c4661273" translate="yes" xml:space="preserve">
          <source>Interactive interrupt (ctrl-C)</source>
          <target state="translated">대화 형 인터럽트 (ctrl-C)</target>
        </trans-unit>
        <trans-unit id="04543475f0af93a9b1f70f2a38be6ff47c43ef12" translate="yes" xml:space="preserve">
          <source>Interactive stop</source>
          <target state="translated">인터랙티브 스톱</target>
        </trans-unit>
        <trans-unit id="9cc0bc31a21623037df91a449af1758c1ea53779" translate="yes" xml:space="preserve">
          <source>Interactive termination</source>
          <target state="translated">대화 형 종료</target>
        </trans-unit>
        <trans-unit id="152a2569e2c91ee227ddb8f5534f2eae5eb0d12f" translate="yes" xml:space="preserve">
          <source>Interface to the Unix system.</source>
          <target state="translated">Unix 시스템에 대한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="b9f4c23d2b8212406b51e7046c93c96a1a7f1146" translate="yes" xml:space="preserve">
          <source>Interface to the Unix system. To use as replacement to default &lt;a href=&quot;unix&quot;&gt;&lt;code&gt;Unix&lt;/code&gt;&lt;/a&gt; module, add &lt;code&gt;module&amp;nbsp;Unix&amp;nbsp;=&amp;nbsp;UnixLabels&lt;/code&gt; in your implementation.</source>
          <target state="translated">Unix 시스템에 대한 인터페이스. 기본 &lt;a href=&quot;unix&quot;&gt; &lt;code&gt;Unix&lt;/code&gt; &lt;/a&gt; 모듈 대신 사용하려면 구현에 &lt;code&gt;module&amp;nbsp;Unix&amp;nbsp;=&amp;nbsp;UnixLabels&lt;/code&gt; 모듈을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="467f8304012cd505625c260277e4cae411499ca2" translate="yes" xml:space="preserve">
          <source>Interfacing with the standard input/output library</source>
          <target state="translated">표준 입력 / 출력 라이브러리와 인터페이스</target>
        </trans-unit>
        <trans-unit id="8d7c946b4a793edf3af449c46e4c2c299d575469" translate="yes" xml:space="preserve">
          <source>Internet addresses</source>
          <target state="translated">인터넷 주소</target>
        </trans-unit>
        <trans-unit id="c4ecff40bc2b8c11c2e5679d0ffe558077996225" translate="yes" xml:space="preserve">
          <source>Internet domain (IPv4)</source>
          <target state="translated">인터넷 도메인 (IPv4)</target>
        </trans-unit>
        <trans-unit id="857d078139ed411f7ba1150677d3393807432577" translate="yes" xml:space="preserve">
          <source>Internet domain (IPv6)</source>
          <target state="translated">인터넷 도메인 (IPv6)</target>
        </trans-unit>
        <trans-unit id="b995e53883804fd20a387b321cb4b4c4302563e5" translate="yes" xml:space="preserve">
          <source>Interrupt character (usually ctrl-C).</source>
          <target state="translated">인터럽트 문자 (일반적으로 ctrl-C).</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="279042ba487b938485f08f0399290c5d0cf49331" translate="yes" xml:space="preserve">
          <source>Intuition: a &amp;ldquo;blocking section&amp;rdquo; is a piece of C code that does not use the OCaml run-time system, typically a blocking input/output operation.</source>
          <target state="translated">직관 : &quot;차단 섹션&quot;은 OCaml 런타임 시스템을 사용하지 않는 C 코드 조각으로, 일반적으로 입력 / 출력 작업을 차단합니다.</target>
        </trans-unit>
        <trans-unit id="50d8afba7764b4a5e45be2c963d38829c02898a1" translate="yes" xml:space="preserve">
          <source>Intuitively, a value of type 'a nested is a list of list &amp;hellip;of list of elements a with k nested list. We can then adapt the maximal_depth function defined on regular_depth into a depth function that computes this k. As a first try, we may define</source>
          <target state="translated">직관적으로 'a nested'유형의 값은 k 개의 중첩 된 목록이있는 요소 목록의 목록입니다. 그런 다음 regular_depth에 정의 된 maximal_depth 함수를이 k를 계산하는 깊이 함수로 조정할 수 있습니다. 첫 번째 시도로</target>
        </trans-unit>
        <trans-unit id="45ff4427a9f1fb0c18cbcdf6b26d6a2d22f2df2f" translate="yes" xml:space="preserve">
          <source>Invalid argument</source>
          <target state="translated">잘못된 인수</target>
        </trans-unit>
        <trans-unit id="eb51873a166a0ca612be5e39e25b496f16f0edd3" translate="yes" xml:space="preserve">
          <source>Invalid hardware instruction</source>
          <target state="translated">잘못된 하드웨어 명령</target>
        </trans-unit>
        <trans-unit id="3aaeaeb6ec3f8154506ce18b333531c275dcb035" translate="yes" xml:space="preserve">
          <source>Invalid link</source>
          <target state="translated">유효하지 않은 링크</target>
        </trans-unit>
        <trans-unit id="1835382968f46a5f88dff8462ccb2b244e21516d" translate="yes" xml:space="preserve">
          <source>Invalid memory reference</source>
          <target state="translated">잘못된 메모리 참조</target>
        </trans-unit>
        <trans-unit id="9851d3714a00331607464ec1db51c684493f3fde" translate="yes" xml:space="preserve">
          <source>Invalid seek e.g. on a pipe</source>
          <target state="translated">잘못된 탐색 (예 : 파이프에서)</target>
        </trans-unit>
        <trans-unit id="d82b06adf1a876d702b6a3905d8d56b51827e40e" translate="yes" xml:space="preserve">
          <source>Is a directory</source>
          <target state="translated">디렉토리</target>
        </trans-unit>
        <trans-unit id="d246b366cbb2a7b87d693c8eb7b14afb327f18c3" translate="yes" xml:space="preserve">
          <source>Is_block(v) is true if value v is a pointer to a block, and false if it is an immediate integer.</source>
          <target state="translated">Is_block (v)는 v 값이 블록에 대한 포인터이면 true이고, 즉치 정수이면 false입니다.</target>
        </trans-unit>
        <trans-unit id="162a91bb1ae1511c1a14b48fc9b99ad1c1b64c87" translate="yes" xml:space="preserve">
          <source>Is_long(v) is true if value v is an immediate integer, false otherwise</source>
          <target state="translated">값 v가 즉치 정수이면 Is_long (v)는 true이고 그렇지 않으면 false입니다.</target>
        </trans-unit>
        <trans-unit id="90960e35ff8d0e1edddd78784b82e7ac0c892d5d" translate="yes" xml:space="preserve">
          <source>It becomes more straightforward to optimise closure allocations since the layout of closures does not have to be estimated in any way: it is known. Similarly, it becomes more straightforward to control which variables end up in which closures, helping to avoid closure bloat.</source>
          <target state="translated">클로저 레이아웃을 어떤 식 으로든 추정 할 필요가 없기 때문에 클로저 할당을 최적화하는 것이 더 간단 해집니다. 마찬가지로, 어떤 변수가 어떤 클로저로 끝나는지를 제어하는 ​​것이 더 간단 해져 클로저 팽창을 방지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="e7c1a2b53a967f6be04a8b2e559ade5c3657e377" translate="yes" xml:space="preserve">
          <source>It can be given the following specification:</source>
          <target state="translated">다음 사양을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82b604d7f25795726169718eb6d7ffbabff67881" translate="yes" xml:space="preserve">
          <source>It generates the following outputs:</source>
          <target state="translated">다음 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="044d9b1336b13c24f31c6087a0884aa833908413" translate="yes" xml:space="preserve">
          <source>It is also extremely useful for first-class modules (see section &lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;8.5&lt;/a&gt;) and generalized algebraic datatypes (GADTs: see section &lt;a href=&quot;gadts#s%3Agadts&quot;&gt;8.10&lt;/a&gt;).</source>
          <target state="translated">또한 일류 모듈 (섹션 &lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;8.5&lt;/a&gt; 참조 ) 및 일반화 된 대수 데이터 유형 (GADT : 섹션 &lt;a href=&quot;gadts#s%3Agadts&quot;&gt;8.10&lt;/a&gt; 참조)에 매우 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="bea3ffa0da3a6a64e26d92217f56bc5dc0ee88ad" translate="yes" xml:space="preserve">
          <source>It is also possible to copy the components of a module inside another module by using an include statement. This can be particularly useful to extend existing modules. As an illustration, we could add functions that returns an optional value rather than an exception when the priority queue is empty.</source>
          <target state="translated">include 문을 사용하여 다른 모듈 내부의 모듈 구성 요소를 복사 할 수도 있습니다. 이는 기존 모듈을 확장하는 데 특히 유용 할 수 있습니다. 예를 들어, 우선 순위 큐가 비어있을 때 예외가 아닌 선택적 값을 반환하는 함수를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b378569adc4da470dbea88424425ba33922ddf5" translate="yes" xml:space="preserve">
          <source>It is also possible to specify attributes using an infix syntax. For instance:</source>
          <target state="translated">중위 구문을 사용하여 속성을 지정할 수도 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="47fcca3d515f217455ee5cbe30c0a352c5140f35" translate="yes" xml:space="preserve">
          <source>It is also possible to use a virtual class. Inheriting from this class simultaneously forces all methods of c to have the same type as the methods of c'.</source>
          <target state="translated">가상 클래스를 사용하는 것도 가능합니다. 이 클래스에서 상속하면 c의 모든 메소드가 동시에 c '의 메소드와 동일한 유형을 갖도록 강제합니다.</target>
        </trans-unit>
        <trans-unit id="cd58beaddeffd7ca4bb4171ee18d2d1d171993da" translate="yes" xml:space="preserve">
          <source>It is assumed in the compiler that expressions with no effects, whose results are not used, may be eliminated. (This typically happens where the expression in question is the defining expression of a let; in such cases the let-expression will be eliminated.) It is further assumed that such expressions with no effects may be duplicated (and thus possibly executed more than once).</source>
          <target state="translated">컴파일러에서는 결과가 사용되지 않는 효과가없는 식을 제거 할 수 있다고 가정합니다. (이것은 일반적으로 문제의 표현식이 let의 정의 표현식 인 경우에 발생합니다. 이러한 경우 let-expression은 제거됩니다.) 또한 효과가없는 이러한 표현식은 중복 될 수 있다고 가정합니다 (따라서 두 번 이상 실행될 수 있음). ).</target>
        </trans-unit>
        <trans-unit id="13d2ff83781a8a7489c112130f8ee70344794950" translate="yes" xml:space="preserve">
          <source>It is assumed in the compiler that, subject to data dependencies, expressions with neither effects nor coeffects may be reordered with respect to other expressions.</source>
          <target state="translated">컴파일러에서는 데이터 종속성에 따라 효과 나 보조 효과가없는식이 다른 식과 관련하여 재정렬 될 수 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ac5a661dd59eecff9dd10ceec465f901059e4cc2" translate="yes" xml:space="preserve">
          <source>It is automatically &amp;ldquo;opened&amp;rdquo; when a compilation starts, or when the toplevel system is launched. Hence, it is possible to use unqualified identifiers to refer to the functions provided by the Stdlib module, without adding a open Stdlib directive.</source>
          <target state="translated">컴파일이 시작되거나 최상위 시스템이 시작될 때 자동으로 &quot;열립니다&quot;. 따라서 개방형 Stdlib 지시문을 추가하지 않고도 정규화되지 않은 식별자를 사용하여 Stdlib 모듈에서 제공하는 함수를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cd4849d026298aa7f6ab63f07e5240537d04447" translate="yes" xml:space="preserve">
          <source>It is automatically linked with the user&amp;rsquo;s object code files by the ocamlc command (chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;).</source>
          <target state="translated">ocamlc 명령 ( &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; 장 )에 의해 사용자의 개체 코드 파일과 자동으로 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="a83064bce61d18a3c463038ddbd763bdd7b618f8" translate="yes" xml:space="preserve">
          <source>It is defined as &lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt;&lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;stdlib#VALstderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt; &lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;stdlib#VALstderr&quot;&gt; &lt;code&gt;stderr&lt;/code&gt; &lt;/a&gt; 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="de9bd2e9555690ad21a6a0c4218827b24b71e84a" translate="yes" xml:space="preserve">
          <source>It is defined as &lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt;&lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;stdlib#VALstdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt; &lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;stdlib#VALstdout&quot;&gt; &lt;code&gt;stdout&lt;/code&gt; &lt;/a&gt; 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="8b06674c64e7087d6cd54c0e34bb489d7d00dd20" translate="yes" xml:space="preserve">
          <source>It is easier to integrate with cross-module optimisation, since imported information about other modules is already in the correct intermediate language.</source>
          <target state="translated">다른 모듈에 대해 가져온 정보가 이미 올바른 중간 언어로되어 있기 때문에 교차 모듈 최적화와 통합하기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="8c7e38f3c9e1798fbab9e90c5865cda5877abcfa" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;print_tbreak&amp;nbsp;0&amp;nbsp;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;print_tbreak&amp;nbsp;0&amp;nbsp;0&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3f1f54bf27ff0a3758919f394790ff7b25c9d1f8" translate="yes" xml:space="preserve">
          <source>It is however possible to define functions that manipulate objects of type either money or money2: the function min will return the minimum of any two objects whose type unifies with #comparable. The type of min is not the same as #comparable -&amp;gt; #comparable -&amp;gt; #comparable, as the abbreviation #comparable hides a type variable (an ellipsis). Each occurrence of this abbreviation generates a new variable.</source>
          <target state="translated">그러나 money 또는 money2 유형의 객체를 조작하는 함수를 정의 할 수 있습니다. min 함수는 유형이 #comparable로 통합되는 두 객체 중 최소값을 반환합니다. min의 유형은 #comparable-&amp;gt; #comparable-&amp;gt; #comparable과 동일하지 않습니다. 약어 #comparable은 유형 변수 (줄임표)를 숨 깁니다. 이 약어가 나타날 때마다 새 변수가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="06505630dc097368cdf81588999cb42bce21605e" translate="yes" xml:space="preserve">
          <source>It is important to note that the exported front-end interface follows the evolution of the OCaml language and implementation, and thus does not provide any backwards compatibility guarantees.</source>
          <target state="translated">내 보낸 프런트 엔드 인터페이스는 OCaml 언어 및 구현의 발전을 따르므로 이전 버전과의 호환성을 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="df425a65ea13fa3de15879ad0ff948e700f992b5" translate="yes" xml:space="preserve">
          <source>It is important to provide the client&amp;rsquo;s view as a functor Client so that client accounts can still be built after a possible specialization of the bank. The functor Client may remain unchanged and be passed the new definition to initialize a client&amp;rsquo;s view of the extended account.</source>
          <target state="translated">은행의 가능한 전문화 후에도 고객 계좌를 구축 할 수 있도록 고객의 관점을 functor 고객으로 제공하는 것이 중요합니다. 펑터 클라이언트는 변경되지 않고 새 정의를 전달하여 확장 계정에 대한 클라이언트의보기를 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a013a33299e01ccd1972c4a799393bbe9b322fa8" translate="yes" xml:space="preserve">
          <source>It is important to remark that the function eval is using the polymorphic syntax for locally abstract types. When defining a recursive function that manipulates a GADT, explicit polymorphic recursion should generally be used. For instance, the following definition fails with a type error:</source>
          <target state="translated">eval 함수가 로컬 추상 유형에 대해 다형성 구문을 사용하고 있다는 점에 주목하는 것이 중요합니다. GADT를 조작하는 재귀 함수를 정의 할 때 일반적으로 명시 적 다형성 재귀를 사용해야합니다. 예를 들어 다음 정의는 유형 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="33f0de9451006df17669b54818c85d11fb78b04d" translate="yes" xml:space="preserve">
          <source>It is not possible to mix native-code object files produced by ocamlopt with bytecode object files produced by ocamlc: a program must be compiled entirely with ocamlopt or entirely with ocamlc. Native-code object files produced by ocamlopt cannot be loaded in the toplevel system ocaml.</source>
          <target state="translated">ocamlopt에 의해 생성 된 네이티브 코드 개체 파일과 ocamlc에 의해 생성 된 바이트 코드 개체 파일을 혼합하는 것은 불가능합니다. 프로그램은 완전히 ocamlopt로 또는 완전히 ocamlc로 컴파일해야합니다. ocamlopt에 의해 생성 된 네이티브 코드 개체 파일은 최상위 시스템 ocaml에로드 할 수 없습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="cf6d73db6c27ba0773eb0db381d42efb65e8e409" translate="yes" xml:space="preserve">
          <source>It is often a security hole to leak file descriptors opened on, say, a private file to an external program: the program, then, gets access to the private file and can do bad things with it. Hence, it is highly recommended to set all file descriptors ``close-on-exec'', except in the very few cases where a file descriptor actually needs to be transmitted to another program.</source>
          <target state="translated">개인 파일에서 열린 파일 설명자가 외부 프로그램으로 유출되는 것은 종종 보안 허점입니다. 그러면 프로그램이 개인 파일에 액세스하여 나쁜 일을 할 수 있습니다. 따라서 파일 디스크립터가 실제로 다른 프로그램으로 전송되어야하는 극소수의 경우를 제외하고 모든 파일 디스크립터를``close-on-exec ''로 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="79cb04a19a396d38be69e08c2821e7ce44154b03" translate="yes" xml:space="preserve">
          <source>It is only possible to coerce an expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; from type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, if the type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is an instance of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; (like for a type annotation), and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. The type of the coerced expression is an instance of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. If the types contain variables, they may be instantiated by the subtyping algorithm, but this is only done after determining whether &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a potential subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. This means that typing may fail during this latter unification step, even if some instance of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a subtype of some instance of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. In the following paragraphs we describe the subtyping relation used.</source>
          <target state="translated">이 발현 억압 만 가능 &lt;a href=&quot;#expr&quot;&gt;EXPR을&lt;/a&gt; 형식에서 &lt;a href=&quot;types#typexpr&quot;&gt;통상 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 입력 &lt;a href=&quot;types#typexpr&quot;&gt;일반 &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 의 입력하면 &lt;a href=&quot;#expr&quot;&gt;expr이&lt;/a&gt; 인스턴스 인 &lt;a href=&quot;types#typexpr&quot;&gt;일반 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; (a 형 주석 대 등) 및 &lt;a href=&quot;types#typexpr&quot;&gt;통상 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 의 하위 유형 &lt;a href=&quot;types#typexpr&quot;&gt;일반 &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; . 강제 표현식의 유형은 &lt;a href=&quot;types#typexpr&quot;&gt;typ &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 의 인스턴스입니다 . 유형 변수를 포함 할 경우,이 하위 유형의 알고리즘에 의해 인스턴스화 할 수 있지만,이 경우에만 여부를 결정 후에 완료됩니다 &lt;a href=&quot;types#typexpr&quot;&gt;일반 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 의 잠재적 인 하위 유형 인 &lt;a href=&quot;types#typexpr&quot;&gt;일반 &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. 즉, &lt;a href=&quot;types#typexpr&quot;&gt;typ &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 의 일부 인스턴스가 &lt;a href=&quot;types#typexpr&quot;&gt;typ &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 의 일부 인스턴스의 하위 유형 인 경우에도이 후자의 통합 단계에서 입력이 실패 할 수 있습니다 . 다음 단락에서는 사용 된 하위 유형 관계를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ebc436df5f472c76f9b857cad66e30b424d794e2" translate="yes" xml:space="preserve">
          <source>It is possible to declare a method without actually defining it, using the keyword virtual. This method will be provided later in subclasses. A class containing virtual methods must be flagged virtual, and cannot be instantiated (that is, no object of this class can be created). It still defines type abbreviations (treating virtual methods as other methods.)</source>
          <target state="translated">가상 키워드를 사용하여 실제로 정의하지 않고 메소드를 선언 할 수 있습니다. 이 메서드는 나중에 하위 클래스에서 제공됩니다. 가상 메서드를 포함하는 클래스는 가상으로 플래그 지정되어야하며 인스턴스화 될 수 없습니다 (즉,이 클래스의 개체를 만들 수 없음). 여전히 유형 약어를 정의합니다 (가상 방법을 다른 방법으로 처리).</target>
        </trans-unit>
        <trans-unit id="21e850727b9f6478bee4607ccc53d1de385121ba" translate="yes" xml:space="preserve">
          <source>It is possible to define a generator class in several modules, which are defined in several files file&lt;sub&gt;1&lt;/sub&gt;.ml[i], file&lt;sub&gt;2&lt;/sub&gt;.ml[i], ..., file&lt;sub&gt;n&lt;/sub&gt;.ml[i]. A .cma library file must be created, including all these files.</source>
          <target state="translated">여러 모듈에서 생성기 클래스를 정의 할 수 있습니다.이 클래스는 여러 파일 파일 &lt;sub&gt;1&lt;/sub&gt; .ml [i], 파일 &lt;sub&gt;2&lt;/sub&gt; .ml [i], ..., 파일 &lt;sub&gt;n&lt;/sub&gt; .ml [i]에 정의되어 있습니다. 이러한 모든 파일을 포함하여 .cma 라이브러리 파일을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="2faea6818157cac9f0988b494ec9a1fb10a63786" translate="yes" xml:space="preserve">
          <source>It is possible to define local exceptions in expressions: letexception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; . The syntactic scope of the exception constructor is the inner expression, but nothing prevents exception values created with this constructor from escaping this scope. Two executions of the definition above result in two incompatible exception constructors (as for any exception definition). For instance, the following assertion is true:</source>
          <target state="translated">표현식에서 로컬 예외를 정의 할 수 있습니다 : letexception &lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; in &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; . 예외 생성자의 구문 범위는 내부 표현식이지만이 생성자로 생성 된 예외 값이이 범위를 이스케이프하는 것을 막는 것은 없습니다. 위의 정의를 두 번 실행하면 두 개의 호환되지 않는 예외 생성자가 발생합니다 (예외 정의의 경우). 예를 들어, 다음 주장은 참입니다.</target>
        </trans-unit>
        <trans-unit id="61c1a7eb6e17934cbe039ce2d9565c2d1a043e49" translate="yes" xml:space="preserve">
          <source>It is possible to write a version of class point without assignments on the instance variables. The override construct {&amp;lt; ... &amp;gt;} returns a copy of &amp;ldquo;self&amp;rdquo; (that is, the current object), possibly changing the value of some instance variables.</source>
          <target state="translated">인스턴스 변수에 할당하지 않고 클래스 포인트 버전을 작성할 수 있습니다. 재정의 구문 {&amp;lt;...&amp;gt;}은 &quot;self&quot;(즉, 현재 개체)의 복사본을 반환하여 일부 인스턴스 변수의 값을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2b8c74a40907020aea23679f7d3a1e47e89c876" translate="yes" xml:space="preserve">
          <source>It is recommended that applications or Web frameworks that need to protect themselves against the denial-of-service attack described in &lt;a href=&quot;hashtbl#VALcreate&quot;&gt;&lt;code&gt;Hashtbl.create&lt;/code&gt;&lt;/a&gt; call &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; at initialization time.</source>
          <target state="translated">&lt;a href=&quot;hashtbl#VALcreate&quot;&gt; &lt;code&gt;Hashtbl.create&lt;/code&gt; 에&lt;/a&gt; 설명 된 서비스 거부 공격으로부터 자신을 보호해야하는 응용 프로그램이나 웹 프레임 워크 는 초기화시 &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; 를 호출하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="de79eca76d0232a8de08f10b0fc7e60c155d206d" translate="yes" xml:space="preserve">
          <source>It is recommended to inherit from the current generator of the same kind as the one you want to define. Doing so, it is possible to load various custom generators to combine improvements brought by each one.</source>
          <target state="translated">정의하려는 것과 같은 종류의 현재 생성기에서 상속하는 것이 좋습니다. 이렇게하면 다양한 사용자 지정 생성기를로드하여 각 생성자가 가져온 개선 사항을 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfaad68f50ca8cd128072213cb8026032d1a1ddb" translate="yes" xml:space="preserve">
          <source>It is sometimes inconvenient to build a custom runtime system each time OCaml code is linked with C libraries, like ocamlc -custom does. For one thing, the building of the runtime system is slow on some systems (that have bad linkers or slow remote file systems); for another thing, the platform-independence of bytecode files is lost, forcing to perform one ocamlc -custom link per platform of interest.</source>
          <target state="translated">ocamlc -custom처럼 OCaml 코드가 C 라이브러리와 링크 될 때마다 사용자 정의 런타임 시스템을 구축하는 것은 때때로 불편합니다. 우선 일부 시스템 (불량한 링커 또는 느린 원격 파일 시스템이있는 시스템)에서는 런타임 시스템 구축이 느립니다. 다른 한 가지로, 바이트 코드 파일의 플랫폼 독립성이 손실되어 관심있는 플랫폼 당 하나의 ocamlc -custom 링크를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ccaf02d4a67360ff683564b219f17b5312faf2d" translate="yes" xml:space="preserve">
          <source>It may also be useful to relay an optional argument from a function call to another. This can be done by prefixing the applied argument with ?. This question mark disables the wrapping of optional argument in an option type.</source>
          <target state="translated">함수 호출에서 다른 인수로 선택적 인수를 릴레이하는 것도 유용 할 수 있습니다. 적용된 인수 앞에?를 붙여서 수행 할 수 있습니다. 이 물음표는 옵션 유형에서 선택적 인수의 래핑을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="db2ae4f4dfef6ee049420fc585397e822cd1841d" translate="yes" xml:space="preserve">
          <source>It may become the case during compilation that one or more invariant arguments to a function become specialised to a particular value. When such values are themselves boxed the corresponding specialised arguments may be split into more specialised arguments corresponding to the projections out of the boxed value that occur within the function body. This transformation is called &lt;em&gt;unboxing of specialised arguments&lt;/em&gt;. It is only applied when there is reasonable certainty that the boxed argument itself is unused within the function.</source>
          <target state="translated">컴파일 중에 함수에 대한 하나 이상의 고정 인수가 특정 값에 특화되는 경우가 발생할 수 있습니다. 이러한 값이 자체적으로 boxing 될 때 해당하는 특수 인수는 함수 본문 내에서 발생하는 boxed 값의 프로젝션에 해당하는보다 전문화 된 인수로 분할 될 수 있습니다. 이 변환 &lt;em&gt;을 특수 인수의 박싱 해제&lt;/em&gt; 라고 합니다. boxed 인수 자체가 함수 내에서 사용되지 않는다는 합리적인 확신이있을 때만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2113b64361ed06b2fb660d291ef792f576530d08" translate="yes" xml:space="preserve">
          <source>It particular, it provides the basic operations over the built-in types (numbers, booleans, byte sequences, strings, exceptions, references, lists, arrays, input-output channels, ...) and the &lt;a href=&quot;stdlib#modules&quot;&gt;standard library modules&lt;/a&gt;.</source>
          <target state="translated">특히 내장 유형 (숫자, 부울, 바이트 시퀀스, 문자열, 예외, 참조, 목록, 배열, 입력-출력 채널 등) 및 &lt;a href=&quot;stdlib#modules&quot;&gt;표준 라이브러리 모듈에&lt;/a&gt; 대한 기본 작업을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="72e1bb8314f0b54fe82043439ead06c77dd005bd" translate="yes" xml:space="preserve">
          <source>It permits higher-order inlining, for example when a non-inlinable function always returns the same function yet with different environments of definition. Not all such cases are supported yet, but it is intended that such support will be improved in future.</source>
          <target state="translated">예를 들어 인라인 불가능한 함수가 항상 동일한 함수를 반환하지만 정의 환경이 다른 경우 고차 인라인을 허용합니다. 이러한 모든 사례가 아직 지원되는 것은 아니지만 향후 이러한 지원이 개선 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="d62dc081b8f1528625d07f7e633e0a268ec1a67b" translate="yes" xml:space="preserve">
          <source>It raises &lt;code&gt;End_of_file&lt;/code&gt; if the function has already reached the end of file when starting to read from the channel, and raises &lt;code&gt;Failure&amp;nbsp;&quot;input_value:&amp;nbsp;truncated&amp;nbsp;object&quot;&lt;/code&gt; if it reaches the end of file later during the unmarshalling.</source>
          <target state="translated">채널에서 읽기를 시작할 때 함수가 이미 파일 끝에 도달 하면 &lt;code&gt;End_of_file&lt;/code&gt; 을 발생시키고 , 비 정렬 화 중에 나중에 파일 끝에 도달 하면 &lt;code&gt;Failure&amp;nbsp;&quot;input_value:&amp;nbsp;truncated&amp;nbsp;object&quot;&lt;/code&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d7eeb9110a841ac9d46371abdaeea4230b064629" translate="yes" xml:space="preserve">
          <source>It should be noted that the &lt;em&gt;unboxing of closures&lt;/em&gt; pass (see below) can introduce specialised arguments on non-recursive functions. (No other place in the compiler currently does this.)</source>
          <target state="translated">&lt;em&gt;클로저&lt;/em&gt; 의 &lt;em&gt;unboxing&lt;/em&gt; 패스 (아래 참조)는 비 재귀 함수에 대한 특수 인수를 도입 할 수 있습니다. (현재 컴파일러의 다른 곳에서는이 작업을 수행하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="5f1b6ac17c7b6c87ec71a416499d7641064d1ab8" translate="yes" xml:space="preserve">
          <source>It should be noted that the blocks corresponding to initialise-symbol bindings are kept alive forever, by virtue of them occurring in a static table of GC roots within the object file. This extended lifetime of expressions may on occasion be surprising. If it is desired to create some non-constant value (for example when writing GC tests) that does not have this extended lifetime, then it may be created and used inside a function, with the application point of that function (perhaps at toplevel)&amp;mdash;or indeed the function declaration itself&amp;mdash;marked as to never be inlined. This technique prevents lifting of the definition of the value in question (assuming of course that it is not constant).</source>
          <target state="translated">초기화 기호 바인딩에 해당하는 블록은 객체 파일 내의 GC 루트의 정적 테이블에서 발생하기 때문에 영원히 살아남습니다. 이 연장 된 표현 수명은 때때로 놀랍습니다. 이 연장 된 수명을 갖지 않는 상수가 아닌 값 (예 : GC 테스트 작성시)을 생성하려는 경우 해당 함수의 애플리케이션 포인트 (아마도 최상위 수준)와 함께 함수 내에서 생성 및 사용할 수 있습니다. 또는 실제로 함수 선언 자체는 인라인되지 않는 것으로 표시됩니다. 이 기술은 해당 값의 정의를 해제하는 것을 방지합니다 (물론 일정하지 않다고 가정).</target>
        </trans-unit>
        <trans-unit id="d67c39d8ce8aefbd00cfb85541a53fdf588caae0" translate="yes" xml:space="preserve">
          <source>It will be accepted if each one of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; is statically constructive with respect to name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt;, is not immediately linked to any of name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt;, and is not an array constructor whose arguments have abstract type.</source>
          <target state="translated">이 허용 될 경우의 각 &lt;a href=&quot;expr#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ... &lt;a href=&quot;expr#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; 존중 이름으로 정적 건설적 &lt;sub&gt;1&lt;/sub&gt; ... 이름 &lt;sub&gt;N&lt;/sub&gt; 즉시 이름의 연결되지 않은 &lt;sub&gt;1&lt;/sub&gt; ... 이름 &lt;sub&gt;N&lt;/sub&gt; 및 그 인수 추상 타입이 배열 생성자 아니다.</target>
        </trans-unit>
        <trans-unit id="c1efde60809be61ee856277b8eeaecd2343156c0" translate="yes" xml:space="preserve">
          <source>It would be incorrect to perform Field(r, 1) = tail directly, because the allocation of tail has taken place since r was allocated.</source>
          <target state="translated">Field (r, 1) = tail을 직접 수행하는 것은 올바르지 않습니다. r이 할당 된 이후로 tail 할당이 이루어 졌기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="6e56ebc8d92919227f4b41f4b34fc2bd72f5bbb0" translate="yes" xml:space="preserve">
          <source>It would be natural to factorize these two definitions as:</source>
          <target state="translated">이 두 정의를 다음과 같이 인수 분해하는 것은 당연합니다.</target>
        </trans-unit>
        <trans-unit id="033f25fa120ee864f9ba41bac8624f68584547d1" translate="yes" xml:space="preserve">
          <source>It would be unsound to apply this fake_id function to values with different types. The function fake_id is therefore rightfully assigned the type '_weak3 -&amp;gt; '_weak3 rather than 'a -&amp;gt; 'a. At the same time, it ought to be possible to use a local mutable state without impacting the type of a function.</source>
          <target state="translated">이 fake_id 함수를 다른 유형의 값에 적용하는 것은 타당하지 않습니다. 따라서 함수 fake_id에는 'a-&amp;gt;'a가 아닌 '_weak3-&amp;gt;'_weak3 유형이 올바르게 할당됩니다. 동시에 함수 유형에 영향을주지 않고 로컬 가변 상태를 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2da9a22f0bb03dc04334b781283f4d9b2b79cd9d" translate="yes" xml:space="preserve">
          <source>Items produced by symbolic pretty-printers</source>
          <target state="translated">상징적 인 프리티 프린터가 제작 한 아이템</target>
        </trans-unit>
        <trans-unit id="3c475641298983202fb5bb4c85bf773502af819b" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order</source>
          <target state="translated">오름차순으로 어레이에서 반복</target>
        </trans-unit>
        <trans-unit id="c4e251fe0eee2437464dec9a234fc1b325f32052" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order, yielding indices along elements</source>
          <target state="translated">배열을 오름차순으로 반복하여 요소를 따라 인덱스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b6d6cc59b755b47fc8e1cdb410adb3abe777160d" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order, yielding indices along elements.</source>
          <target state="translated">배열을 오름차순으로 반복하여 요소를 따라 인덱스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="74fa1984f98f87ade05a77d2d30ccf29617c61c6" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order, yielding indices along elements. Modifications of the array during iteration will be reflected in the iterator.</source>
          <target state="translated">배열을 오름차순으로 반복하여 요소를 따라 인덱스를 생성합니다. 반복 중 배열 수정은 반복기에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="cc753a1a200932eacd72d4b7ac2810d8ee977b0f" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order.</source>
          <target state="translated">배열에서 오름차순으로 반복합니다.</target>
        </trans-unit>
        <trans-unit id="72365e84c44abbdabda346bfd2a72b67f6a2f040" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order. Modifications of the array during iteration will be reflected in the iterator.</source>
          <target state="translated">배열에서 오름차순으로 반복합니다. 반복 중 배열 수정은 반복기에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="57d6da7fff2897e2fdb9323a2fa6acc42d8e4f3c" translate="yes" xml:space="preserve">
          <source>Iterate on the buffer, in increasing order, yielding indices along chars.</source>
          <target state="translated">버퍼를 오름차순으로 반복하여 문자를 따라 인덱스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a59b1457067d268a42e29eef63f4228e79bc1f79" translate="yes" xml:space="preserve">
          <source>Iterate on the buffer, in increasing order, yielding indices along chars. Modification of the buffer during iteration is undefined behavior.</source>
          <target state="translated">버퍼를 오름차순으로 반복하여 문자를 따라 인덱스를 생성합니다. 반복 중 버퍼 수정은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="53111c31562ee5692d94ba95750e9d8128aa9335" translate="yes" xml:space="preserve">
          <source>Iterate on the buffer, in increasing order.</source>
          <target state="translated">버퍼에서 오름차순으로 반복합니다.</target>
        </trans-unit>
        <trans-unit id="52718e109f8ea9e93b899d8a8c03df0ab8a5e288" translate="yes" xml:space="preserve">
          <source>Iterate on the buffer, in increasing order. Modification of the buffer during iteration is undefined behavior.</source>
          <target state="translated">버퍼에서 오름차순으로 반복합니다. 반복 중 버퍼 수정은 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="3f7e2d0218e27b69ec7b7e2712b13e76087fea47" translate="yes" xml:space="preserve">
          <source>Iterate on the floatarray, in increasing order, yielding indices along elements.</source>
          <target state="translated">floatarray를 오름차순으로 반복하여 요소를 따라 인덱스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4c13a9362e94273776029d2c08f652f705e4760a" translate="yes" xml:space="preserve">
          <source>Iterate on the floatarray, in increasing order, yielding indices along elements. Modifications of the floatarray during iteration will be reflected in the iterator.</source>
          <target state="translated">floatarray를 오름차순으로 반복하여 요소를 따라 인덱스를 생성합니다. 반복 중에 floatarray를 수정하면 반복기에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="8b731e40512294d27a66934701878da5e53e3950" translate="yes" xml:space="preserve">
          <source>Iterate on the floatarray, in increasing order.</source>
          <target state="translated">floatarray를 오름차순으로 반복합니다.</target>
        </trans-unit>
        <trans-unit id="e6a301a25721beaf25e58fa63b6a4fc32321de99" translate="yes" xml:space="preserve">
          <source>Iterate on the floatarray, in increasing order. Modifications of the floatarray during iteration will be reflected in the iterator.</source>
          <target state="translated">floatarray를 오름차순으로 반복합니다. 반복 중에 floatarray를 수정하면 반복기에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="08358549ccfddcf0b104c824624f18dbe99ff7fa" translate="yes" xml:space="preserve">
          <source>Iterate on the list</source>
          <target state="translated">목록에서 반복</target>
        </trans-unit>
        <trans-unit id="8b0797886b2f424b48d1cd58859fb9af00b7784b" translate="yes" xml:space="preserve">
          <source>Iterate on the queue, in front-to-back order.</source>
          <target state="translated">대기열에서 앞뒤 순서로 반복합니다.</target>
        </trans-unit>
        <trans-unit id="c25db6012c3533afa619b7a8a7742b0a42cb7afd" translate="yes" xml:space="preserve">
          <source>Iterate on the queue, in front-to-back order. The behavior is not defined if the queue is modified during the iteration.</source>
          <target state="translated">대기열에서 앞뒤 순서로 반복합니다. 반복 중에 큐가 수정되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6f0bd8ad0f81cad6d96bacf14d0331f3a6e12dbd" translate="yes" xml:space="preserve">
          <source>Iterate on the sequence, calling the (imperative) function on every element.</source>
          <target state="translated">모든 요소에 대해 (명령어) 함수를 호출하여 시퀀스를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="7ff7477ff445e072b84d4239e6c7d7c3aa347e47" translate="yes" xml:space="preserve">
          <source>Iterate on the sequence, calling the (imperative) function on every element. The traversal happens immediately and will not terminate on infinite sequences.</source>
          <target state="translated">모든 요소에 대해 (명령어) 함수를 호출하여 시퀀스를 반복합니다. 순회는 즉시 발생하며 무한 시퀀스에서 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8c886336160d913779eb591bdee0d4b0e15e45e" translate="yes" xml:space="preserve">
          <source>Iterate on the stack, top to bottom.</source>
          <target state="translated">스택에서 위에서 아래로 반복합니다.</target>
        </trans-unit>
        <trans-unit id="e94cac5480ab8007065d1c6001b6f46bf9c31673" translate="yes" xml:space="preserve">
          <source>Iterate on the stack, top to bottom. It is safe to modify the stack during iteration.</source>
          <target state="translated">스택에서 위에서 아래로 반복합니다. 반복 중에 스택을 수정하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="6f621778fd05a26d4f34ddb7acf9a152913cceff" translate="yes" xml:space="preserve">
          <source>Iterate on the string, in increasing index order.</source>
          <target state="translated">인덱스 순서가 오름차순으로 문자열을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="edcd995c03b85f6200cad5b28912c76d3ebd838a" translate="yes" xml:space="preserve">
          <source>Iterate on the string, in increasing index order. Modifications of the string during iteration will be reflected in the iterator.</source>
          <target state="translated">인덱스 순서가 오름차순으로 문자열을 반복합니다. 반복 중에 문자열을 수정하면 반복기에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="83efc6c1259a0086cd4741e82ac58d922ad5c76a" translate="yes" xml:space="preserve">
          <source>Iterate on the string, in increasing order, yielding indices along chars</source>
          <target state="translated">문자열을 오름차순으로 반복하여 문자를 따라 인덱스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d2b702d271270fdfb0f8e97fdc65aa27aa84c7e5" translate="yes" xml:space="preserve">
          <source>Iterate on the whole map, in ascending order of keys</source>
          <target state="translated">키의 오름차순으로 전체 맵에서 반복</target>
        </trans-unit>
        <trans-unit id="c0fbfcbff3c4717a90de3169e97500f554fe0e8f" translate="yes" xml:space="preserve">
          <source>Iterate on the whole set, in ascending order</source>
          <target state="translated">전체 세트에서 오름차순으로 반복</target>
        </trans-unit>
        <trans-unit id="e7d061daf3db9ad7ba0961da1a7a84cd239402bf" translate="yes" xml:space="preserve">
          <source>Iterate on the whole table.</source>
          <target state="translated">전체 테이블을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="e9d8c94aa5374233499af2d9864d692b5eaf8400" translate="yes" xml:space="preserve">
          <source>Iterate on the whole table. The order in which the bindings appear in the sequence is unspecified. However, if the table contains several bindings for the same key, they appear in reversed order of introduction, that is, the most recent binding appears first.</source>
          <target state="translated">전체 테이블을 반복합니다. 바인딩이 시퀀스에 나타나는 순서는 지정되지 않습니다. 그러나 테이블에 동일한 키에 대한 여러 바인딩이 포함되어있는 경우 도입의 역순으로 나타납니다. 즉, 가장 최근의 바인딩이 먼저 나타납니다.</target>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="92a60e08e4214743467aeef16832efbb28d68b7b" translate="yes" xml:space="preserve">
          <source>Iterators on two arrays</source>
          <target state="translated">두 배열의 반복자</target>
        </trans-unit>
        <trans-unit id="cf924725c2b8039b9d275152dc025994654f8e3d" translate="yes" xml:space="preserve">
          <source>Iterators on two lists</source>
          <target state="translated">두 목록의 반복자</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="ffb8b7268bc0ef366e246e15fb194af699da0d9a" translate="yes" xml:space="preserve">
          <source>Jump to the given time.</source>
          <target state="translated">주어진 시간으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="624a232e29c6285e85daf176c56dfb635d3dd7fd" translate="yes" xml:space="preserve">
          <source>Just as in the toplevel system (section &lt;a href=&quot;toplevel#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;), the user can register functions for printing values of certain types. For technical reasons, the debugger cannot call printing functions that reside in the program being debugged. The code for the printing functions must therefore be loaded explicitly in the debugger.</source>
          <target state="translated">최상위 시스템 (섹션 &lt;a href=&quot;toplevel#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt; )에서와 마찬가지로 사용자는 특정 유형의 값을 인쇄하기위한 기능을 등록 할 수 있습니다. 기술적 인 이유로 디버거는 디버깅중인 프로그램에있는 인쇄 기능을 호출 할 수 없습니다. 따라서 인쇄 기능에 대한 코드는 디버거에서 명시 적으로로드되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="a940001b3198e7ae1e643d753be086d8c3542efb" translate="yes" xml:space="preserve">
          <source>Keep connection active</source>
          <target state="translated">연결 유지</target>
        </trans-unit>
        <trans-unit id="274136e14622e37b8b6331a086d3f3366e3831f5" translate="yes" xml:space="preserve">
          <source>Keep elements placed after/between the (**/**) special comment(s) (see section &lt;a href=&quot;#s%3Aocamldoc-comments&quot;&gt;16.2&lt;/a&gt;).</source>
          <target state="translated">(** / **) 특수 주석 뒤 / 사이에 요소를 배치합니다 (섹션 &lt;a href=&quot;#s%3Aocamldoc-comments&quot;&gt;16.2&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4d62255be0ec9f781a5f40b46da0c3024c36bab8" translate="yes" xml:space="preserve">
          <source>Keep the assembly code produced during the compilation. The assembly code for the source file x.ml is saved in the file x.s.</source>
          <target state="translated">컴파일 중에 생성 된 어셈블리 코드를 유지합니다. 소스 파일 x.ml의 어셈블리 코드는 xs 파일에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="14983f1a3e8d2301fc0a539f434e69ec9ea45c93" translate="yes" xml:space="preserve">
          <source>Kill line character (usually ctrl-U).</source>
          <target state="translated">줄 문자를 죽입니다 (일반적으로 ctrl-U).</target>
        </trans-unit>
        <trans-unit id="c60b8fa8d42c209a51f605ad6c17c5d3484a13de" translate="yes" xml:space="preserve">
          <source>Kill the program being executed. This command is mainly useful if you wish to recompile the program without leaving the debugger.</source>
          <target state="translated">실행중인 프로그램을 종료합니다. 이 명령은 디버거를 떠나지 않고 프로그램을 다시 컴파일하려는 경우 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c67374519f2f22eab63c039c77b42da37349cc81" translate="yes" xml:space="preserve">
          <source>Kind of the file</source>
          <target state="translated">파일의 종류</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="74341e3c271df3c784e595b804b1f90be0f80429" translate="yes" xml:space="preserve">
          <source>Label</source>
          <target state="translated">Label</target>
        </trans-unit>
        <trans-unit id="ce4744e6d2befcbbcee49b587ff32fe4d8b6dfef" translate="yes" xml:space="preserve">
          <source>Label names, tag names, method names and instance variable names need not be qualified: the former three are global labels, while the latter are local to a class.</source>
          <target state="translated">레이블 이름, 태그 이름, 메서드 이름 및 인스턴스 변수 이름은 정규화 할 필요가 없습니다. 앞의 세 개는 전역 레이블이고 후자는 클래스에 로컬입니다.</target>
        </trans-unit>
        <trans-unit id="f7566409fe33db7c1382047b4b33d525174722c1" translate="yes" xml:space="preserve">
          <source>Label omitted in function application.</source>
          <target state="translated">기능 응용 프로그램에서 레이블이 생략되었습니다.</target>
        </trans-unit>
        <trans-unit id="2228985493d9e43e461c7be5525529248735ad9c" translate="yes" xml:space="preserve">
          <source>Labels</source>
          <target state="translated">Labels</target>
        </trans-unit>
        <trans-unit id="09193ca3e31ac574fb94c2e9ba86583737f30c6d" translate="yes" xml:space="preserve">
          <source>Labels are not ignored in types, labels may be used in applications, and labelled parameters can be given in any order. This is the default.</source>
          <target state="translated">레이블은 유형에서 무시되지 않으며 레이블은 애플리케이션에서 사용될 수 있으며 레이블이 지정된 매개 변수는 임의의 순서로 제공 될 수 있습니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="2d07567828d6157c7a0bbfacdccc17fbf690bde4" translate="yes" xml:space="preserve">
          <source>Labels obey the same rules as other identifiers in OCaml, that is you cannot use a reserved keyword (like in or to) as label.</source>
          <target state="translated">레이블은 OCaml의 다른 식별자와 동일한 규칙을 따릅니다. 즉, 예약 된 키워드 (예 : in 또는 to)를 레이블로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac290ed377f5383ec5a1609fac7d51da07b74769" translate="yes" xml:space="preserve">
          <source>Large, multi-dimensional, numerical arrays.</source>
          <target state="translated">큰 다차원 숫자 배열.</target>
        </trans-unit>
        <trans-unit id="d27ea870e756a4996b6e5548e72dad903dff893f" translate="yes" xml:space="preserve">
          <source>Last access time</source>
          <target state="translated">마지막 액세스 시간</target>
        </trans-unit>
        <trans-unit id="97ae7c6bdca85d087ad5892abd46d332ae4415d4" translate="yes" xml:space="preserve">
          <source>Last modification time</source>
          <target state="translated">마지막 수정 시간</target>
        </trans-unit>
        <trans-unit id="5bd551a9da615e1f482b38b0b5800894d52c749c" translate="yes" xml:space="preserve">
          <source>Last status change time</source>
          <target state="translated">마지막 상태 변경 시간</target>
        </trans-unit>
        <trans-unit id="96a1892b560a2dae03d58c477f42a35e2fc92bf8" translate="yes" xml:space="preserve">
          <source>Last-in first-out stacks.</source>
          <target state="translated">후입 선출 스택.</target>
        </trans-unit>
        <trans-unit id="84e98cf97551805d46a1030b73cb47aa40988008" translate="yes" xml:space="preserve">
          <source>Lazy</source>
          <target state="translated">Lazy</target>
        </trans-unit>
        <trans-unit id="7f09861439451aa36330c7bf95178c6ddcb46e50" translate="yes" xml:space="preserve">
          <source>Lazy patterns provide another way to force a lazy expression.</source>
          <target state="translated">게으른 패턴은 게으른 표현을 강제하는 또 다른 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="634afef2094c369bdd48d1f752631ea2a14a676c" translate="yes" xml:space="preserve">
          <source>Leave out-of-band data in line</source>
          <target state="translated">대역 외 데이터를 줄에 둡니다.</target>
        </trans-unit>
        <trans-unit id="85f5ed01117b556dfcfb05f94fe84491fe8dcbb5" translate="yes" xml:space="preserve">
          <source>Less commonly-used options:</source>
          <target state="translated">덜 일반적으로 사용되는 옵션 :</target>
        </trans-unit>
        <trans-unit id="f8e205d5e74a87e2d51ce5ba5fc4154c84a89a9f" translate="yes" xml:space="preserve">
          <source>Let custom.ml be the file defining a new generator class. Compilation of custom.ml can be performed by the following command :</source>
          <target state="translated">custom.ml을 새 생성기 클래스를 정의하는 파일로 둡니다. custom.ml 컴파일은 다음 명령으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a90f57fc3563e16d5d28640fa27a45b5626288d1" translate="yes" xml:space="preserve">
          <source>Let us consider a more complex example: define a circle, whose center may be any kind of point. We put an additional type constraint in method move, since no free variables must remain unaccounted for by the class type parameters.</source>
          <target state="translated">좀 더 복잡한 예를 살펴 보겠습니다. 중심이 어떤 종류의 점이 될 수있는 원을 정의합니다. 클래스 유형 매개 변수에 의해 설명되지 않은 자유 변수가 남아 있어서는 안되므로 이동 메소드에 추가 유형 제약 조건을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="97ad92c4c358eba8bbc5b8a0969daf464a03c61f" translate="yes" xml:space="preserve">
          <source>Let-bindings within class definitions are evaluated before the object is constructed. It is also possible to evaluate an expression immediately after the object has been built. Such code is written as an anonymous hidden method called an initializer. Therefore, it can access self and the instance variables.</source>
          <target state="translated">클래스 정의 내의 Let 바인딩은 개체가 생성되기 전에 평가됩니다. 객체가 빌드 된 직후 표현식을 평가할 수도 있습니다. 이러한 코드는 이니셜 라이저라는 익명의 숨겨진 메서드로 작성됩니다. 따라서 self 및 인스턴스 변수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c78e74717b8e8ca45266657c33dd0aa134152b63" translate="yes" xml:space="preserve">
          <source>Lexer buffers</source>
          <target state="translated">Lexer 버퍼</target>
        </trans-unit>
        <trans-unit id="eba638f354cbd4eea4869aa7af64033d01e9baca" translate="yes" xml:space="preserve">
          <source>Lexer buffers are an abstract data type implemented in the standard library module Lexing. The functions Lexing.from_channel, Lexing.from_string and Lexing.from_function create lexer buffers that read from an input channel, a character string, or any reading function, respectively. (See the description of module Lexing in chapter &lt;a href=&quot;stdlib#c%3Astdlib&quot;&gt;26&lt;/a&gt;.)</source>
          <target state="translated">Lexer 버퍼는 표준 라이브러리 모듈 Lexing에서 구현 된 추상 데이터 유형입니다. Lexing.from_channel, Lexing.from_string 및 Lexing.from_function 함수는 각각 입력 채널, 문자열 또는 읽기 함수에서 읽는 렉서 버퍼를 생성합니다. ( &lt;a href=&quot;stdlib#c%3Astdlib&quot;&gt;26&lt;/a&gt; 장의 Lexing 모듈에 대한 설명을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="92672530b6de1c7c2b6aa008abe880f35c25185c" translate="yes" xml:space="preserve">
          <source>Lexers can optionally maintain the &lt;code&gt;lex_curr_p&lt;/code&gt; and &lt;code&gt;lex_start_p&lt;/code&gt; position fields. This &quot;position tracking&quot; mode is the default, and it corresponds to passing &lt;code&gt;~with_position:true&lt;/code&gt; to functions that create lexer buffers. In this mode, the lexing engine and lexer actions are co-responsible for properly updating the position fields, as described in the next paragraph. When the mode is explicitly disabled (with &lt;code&gt;~with_position:false&lt;/code&gt;), the lexing engine will not touch the position fields and the lexer actions should be careful not to do it either; the &lt;code&gt;lex_curr_p&lt;/code&gt; and &lt;code&gt;lex_start_p&lt;/code&gt; field will then always hold the &lt;code&gt;dummy_pos&lt;/code&gt; invalid position. Not tracking positions avoids allocations and memory writes and can significantly improve the performance of the lexer in contexts where &lt;code&gt;lex_start_p&lt;/code&gt; and &lt;code&gt;lex_curr_p&lt;/code&gt; are not needed.</source>
          <target state="translated">Lexer는 선택적으로 &lt;code&gt;lex_curr_p&lt;/code&gt; 및 &lt;code&gt;lex_start_p&lt;/code&gt; 위치 필드를 유지할 수 있습니다. 이 &quot;위치 추적&quot;모드는 기본값이며 렉서 버퍼를 생성하는 함수에 &lt;code&gt;~with_position:true&lt;/code&gt; 를 전달하는 것에 해당합니다 . 이 모드에서 렉싱 엔진과 렉서 액션은 다음 단락에 설명 된대로 위치 필드를 적절하게 업데이트하기 위해 공동 책임을집니다. 모드가 명시 적으로 비활성화 된 경우 ( &lt;code&gt;~with_position:false&lt;/code&gt; ), 렉싱 엔진은 위치 필드를 건드리지 않으며 렉서 작업도이를 수행하지 않도록주의해야합니다. &lt;code&gt;lex_curr_p&lt;/code&gt; 및 &lt;code&gt;lex_start_p&lt;/code&gt; 필드는 항상 개최한다 &lt;code&gt;dummy_pos&lt;/code&gt; 을잘못된 위치. 위치를 추적하지 않으면 할당 및 메모리 쓰기를 피하고 &lt;code&gt;lex_start_p&lt;/code&gt; 및 &lt;code&gt;lex_curr_p&lt;/code&gt; 가 필요하지 않은 컨텍스트에서 렉서의 성능을 크게 향상시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a3917223ea7504c595a7ef33cb226700969d3360" translate="yes" xml:space="preserve">
          <source>Lexical ambiguities are resolved according to the &amp;ldquo;longest match&amp;rdquo; rule: when a character sequence can be decomposed into two tokens in several different ways, the decomposition retained is the one with the longest first token.</source>
          <target state="translated">어휘 모호성은 &quot;가장 긴 일치&quot;규칙에 따라 해결됩니다. 문자 시퀀스가 ​​여러 가지 방법으로 두 개의 토큰으로 분해 될 수있는 경우 유지되는 분해는 가장 긴 첫 번째 토큰이있는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c0a202cc33085b7bb25725a4f379636b34841789" translate="yes" xml:space="preserve">
          <source>Lexing</source>
          <target state="translated">Lexing</target>
        </trans-unit>
        <trans-unit id="a70e713317076c077fd1641566d360708f118d2a" translate="yes" xml:space="preserve">
          <source>Lexing.lexeme lexbuf</source>
          <target state="translated">Lexing.lexeme lexbuf</target>
        </trans-unit>
        <trans-unit id="16bbfe7d8b55633595dd6244e6f0439507cf30e5" translate="yes" xml:space="preserve">
          <source>Lexing.lexeme_char lexbuf n</source>
          <target state="translated">Lexing.lexeme_char lexbuf n</target>
        </trans-unit>
        <trans-unit id="c74ea0f938e819ae2026560af60f9bf7b4293e6d" translate="yes" xml:space="preserve">
          <source>Lexing.lexeme_end lexbuf</source>
          <target state="translated">Lexing.lexeme_end lexbuf</target>
        </trans-unit>
        <trans-unit id="dbd5d51aa0344b0018430731ae4cef689fd5ac6c" translate="yes" xml:space="preserve">
          <source>Lexing.lexeme_start lexbuf</source>
          <target state="translated">Lexing.lexeme_start lexbuf</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="29af859893fdcdadf9189b04f68a9abe34f1c20e" translate="yes" xml:space="preserve">
          <source>Lifting of constants to toplevel reduces allocation at runtime.</source>
          <target state="translated">상수를 최상위 수준으로 올리면 런타임에 할당이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="ccb0377305aff6b2536761bb8210a8352e72ce63" translate="yes" xml:space="preserve">
          <source>Lightweight threads for Posix &lt;code&gt;1003.1c&lt;/code&gt; and Win32.</source>
          <target state="translated">Posix &lt;code&gt;1003.1c&lt;/code&gt; 및 Win32 용 경량 스레드 .</target>
        </trans-unit>
        <trans-unit id="850af4b7ba532914fbbab5d04f50f07c734c1799" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array1#VALget&quot;&gt;&lt;code&gt;Bigarray.Array1.get&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="translated">&lt;a href=&quot;bigarray.array1#VALget&quot;&gt; &lt;code&gt;Bigarray.Array1.get&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만 경계 검사가 항상 수행되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="10e8e123fe0b1dc99bead7adea2aec6a3d1ac2c9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array1#VALget&quot;&gt;&lt;code&gt;Bigarray.Array1.get&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed. Use with caution and only when the program logic guarantees that the access is within bounds.</source>
          <target state="translated">&lt;a href=&quot;bigarray.array1#VALget&quot;&gt; &lt;code&gt;Bigarray.Array1.get&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만 경계 검사가 항상 수행되는 것은 아닙니다. 주의해서 사용하고 프로그램 논리가 액세스가 범위 내에 있음을 보장하는 경우에만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="17cf409f10899743c833d44d422e8ce9982b9a92" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array1#VALset&quot;&gt;&lt;code&gt;Bigarray.Array1.set&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="translated">&lt;a href=&quot;bigarray.array1#VALset&quot;&gt; &lt;code&gt;Bigarray.Array1.set&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만 경계 검사가 항상 수행되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0d6c54b020c7c7d74936820b2eb4bd3d379258c9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array1#VALset&quot;&gt;&lt;code&gt;Bigarray.Array1.set&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed. Use with caution and only when the program logic guarantees that the access is within bounds.</source>
          <target state="translated">&lt;a href=&quot;bigarray.array1#VALset&quot;&gt; &lt;code&gt;Bigarray.Array1.set&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만 경계 검사가 항상 수행되는 것은 아닙니다. 주의해서 사용하고 프로그램 논리가 액세스가 범위 내에 있음을 보장하는 경우에만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bfadb351771bde10f24fe7abed8ab6142dcbd0a1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array2#VALget&quot;&gt;&lt;code&gt;Bigarray.Array2.get&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="translated">&lt;a href=&quot;bigarray.array2#VALget&quot;&gt; &lt;code&gt;Bigarray.Array2.get&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만 경계 검사가 항상 수행되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="221178edad17fc6894a4c266434a7aa9bc5afe69" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array2#VALset&quot;&gt;&lt;code&gt;Bigarray.Array2.set&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="translated">&lt;a href=&quot;bigarray.array2#VALset&quot;&gt; &lt;code&gt;Bigarray.Array2.set&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만 경계 검사가 항상 수행되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ffbb6f02cca19cfee80223b75c549f0acb3031ee" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array3#VALget&quot;&gt;&lt;code&gt;Bigarray.Array3.get&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="translated">&lt;a href=&quot;bigarray.array3#VALget&quot;&gt; &lt;code&gt;Bigarray.Array3.get&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만 경계 검사가 항상 수행되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="36ea99c63be240916526a60717058a5a7e0e8f87" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array3#VALset&quot;&gt;&lt;code&gt;Bigarray.Array3.set&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="translated">&lt;a href=&quot;bigarray.array3#VALset&quot;&gt; &lt;code&gt;Bigarray.Array3.set&lt;/code&gt; &lt;/a&gt; 과 비슷 하지만 경계 검사가 항상 수행되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7b9e4e4e60b86cce032b0d708e5c35fefc9ea9ae" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;spacetime.series#VALsave_event&quot;&gt;&lt;code&gt;Spacetime.Series.save_event&lt;/code&gt;&lt;/a&gt;, but writes to the automatic snapshot file.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;spacetime.series#VALsave_event&quot;&gt; &lt;code&gt;Spacetime.Series.save_event&lt;/code&gt; &lt;/a&gt; 자동 스냅 샷 파일에 있지만, 쓰기.</target>
        </trans-unit>
        <trans-unit id="9bbbb7a679272947e8eb9d35cbee8a2de10a3c47" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;spacetime.series#VALsave_event&quot;&gt;&lt;code&gt;Spacetime.Series.save_event&lt;/code&gt;&lt;/a&gt;, but writes to the automatic snapshot file. This function is a no-op if OCAML_SPACETIME_INTERVAL was not set.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;spacetime.series#VALsave_event&quot;&gt; &lt;code&gt;Spacetime.Series.save_event&lt;/code&gt; &lt;/a&gt; 자동 스냅 샷 파일에 있지만, 쓰기. 이 함수는 OCAML_SPACETIME_INTERVAL이 설정되지 않은 경우 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="285f14140f3588801dee3a1d5fb94c57e5e969c9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lexeme_end&lt;/code&gt;, but return a complete &lt;code&gt;position&lt;/code&gt; instead of an offset.</source>
          <target state="translated">&lt;code&gt;lexeme_end&lt;/code&gt; 와 비슷 하지만 오프셋 대신 완전한 &lt;code&gt;position&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="89e8a3b2000bfdbec151fc2e1f14f86877e2c204" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lexeme_end&lt;/code&gt;, but return a complete &lt;code&gt;position&lt;/code&gt; instead of an offset. When position tracking is disabled, the function returns &lt;code&gt;dummy_pos&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lexeme_end&lt;/code&gt; 와 비슷 하지만 오프셋 대신 완전한 &lt;code&gt;position&lt;/code&gt; 를 반환합니다 . 위치 추적이 비활성화되면 함수는 &lt;code&gt;dummy_pos&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d05df27d0e208419cdd29b6ff60273cb7cdd7768" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lexeme_start&lt;/code&gt;, but return a complete &lt;code&gt;position&lt;/code&gt; instead of an offset.</source>
          <target state="translated">&lt;code&gt;lexeme_start&lt;/code&gt; 와 비슷 하지만 오프셋 대신 완전한 &lt;code&gt;position&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b4e5ff07d8ec0b1c6d8bcaabede4dea51cec8d1b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lexeme_start&lt;/code&gt;, but return a complete &lt;code&gt;position&lt;/code&gt; instead of an offset. When position tracking is disabled, the function returns &lt;code&gt;dummy_pos&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lexeme_start&lt;/code&gt; 와 비슷 하지만 오프셋 대신 완전한 &lt;code&gt;position&lt;/code&gt; 를 반환합니다 . 위치 추적이 비활성화되면 함수는 &lt;code&gt;dummy_pos&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7bc734516e0de9e6a8e3e99a4330cf58d7f961f5" translate="yes" xml:space="preserve">
          <source>Like constructed terms, polymorphic variant values are represented either as integers (for polymorphic variants without argument), or as blocks (for polymorphic variants with an argument). Unlike constructed terms, variant constructors are not numbered starting from 0, but identified by a hash value (an OCaml integer), as computed by the C function hash_variant (declared in &amp;lt;caml/mlvalues.h&amp;gt;): the hash value for a variant constructor named, say, VConstr is hash_variant(&quot;VConstr&quot;).</source>
          <target state="translated">구성된 용어와 마찬가지로 다형 변형 값은 정수 (인수가없는 다형 변형의 경우) 또는 블록 (인수가있는 다형 변형의 경우)으로 표시됩니다. 생성 된 용어와 달리 변형 생성자는 0부터 시작하는 번호가 지정되지 않지만 C 함수 hash_variant (&amp;lt;caml / mlvalues.h&amp;gt;에 선언 됨)에 의해 계산 된 해시 값 (OCaml 정수)으로 식별됩니다. 변형의 해시 값 VConstr이라는 이름의 생성자는 hash_variant ( &quot;VConstr&quot;)입니다.</target>
        </trans-unit>
        <trans-unit id="84db1f1935fb847355e19d1183905165a54092aa" translate="yes" xml:space="preserve">
          <source>Like for modules, it is possible to include a signature to copy its components inside the current signature. For instance, we can extend the PRIOQUEUE signature with the extract_opt function:</source>
          <target state="translated">모듈의 경우와 마찬가지로 현재 서명 내에 구성 요소를 복사하는 서명을 포함 할 수 있습니다. 예를 들어 extract_opt 함수를 사용하여 PRIOQUEUE 서명을 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bed73780596b7f834ced053725e46c0df1f9817" translate="yes" xml:space="preserve">
          <source>Like for names, choosing labels for functions is not an easy task. A good labeling is a labeling which</source>
          <target state="translated">이름과 마찬가지로 기능에 대한 레이블을 선택하는 것은 쉬운 작업이 아닙니다. 좋은 라벨링은 다음과 같은 라벨링입니다.</target>
        </trans-unit>
        <trans-unit id="43e1d0d1bfc15d7766298ee68fb31b046e1b23e5" translate="yes" xml:space="preserve">
          <source>Like in function definitions, the definition above can be abbreviated as:</source>
          <target state="translated">함수 정의에서와 마찬가지로 위의 정의는 다음과 같이 축약 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ffd97eca67dfa1c7ecded513f14bd0f5af7f65f" translate="yes" xml:space="preserve">
          <source>Likewise.</source>
          <target state="translated">Likewise.</target>
        </trans-unit>
        <trans-unit id="d6a89f5f5aab1dc9ec97d86beabe3da25c8f6ddd" translate="yes" xml:space="preserve">
          <source>Limit the number of value nodes printed to at most n. Remaining parts of values are printed as ... (ellipsis).</source>
          <target state="translated">인쇄되는 값 노드 수를 최대 n 개로 제한합니다. 값의 나머지 부분은 ... (줄임표)로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="8ad9b678b8122b484b49d4fd677c60e7b110f651" translate="yes" xml:space="preserve">
          <source>Limit the printing of values to a maximal depth of d.</source>
          <target state="translated">값의 인쇄를 최대 깊이 d로 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="fe294dbc375ee535fc34452b44543c9389175384" translate="yes" xml:space="preserve">
          <source>Limit the printing of values to a maximal depth of n. The parts of values whose depth exceeds n are printed as ... (ellipsis).</source>
          <target state="translated">값 인쇄를 최대 깊이 n으로 제한합니다. 깊이가 n을 초과하는 값 부분은 ... (줄임표)로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="12c82d004dcdb36148874aaf0cae92f27ef7fbfb" translate="yes" xml:space="preserve">
          <source>Limit the printing of values to at most l nodes printed.</source>
          <target state="translated">값의 인쇄를 최대 l 개의 노드로 제한하십시오.</target>
        </trans-unit>
        <trans-unit id="e07f2e960f4ea462077ce5669747d94a6df33827" translate="yes" xml:space="preserve">
          <source>Link in &amp;ldquo;custom runtime&amp;rdquo; mode. In the default linking mode, the linker produces bytecode that is intended to be executed with the shared runtime system, ocamlrun. In the custom runtime mode, the linker produces an output file that contains both the runtime system and the bytecode for the program. The resulting file is larger, but it can be executed directly, even if the ocamlrun command is not installed. Moreover, the &amp;ldquo;custom runtime&amp;rdquo; mode enables static linking of OCaml code with user-defined C functions, as described in chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;.</source>
          <target state="translated">&quot;사용자 지정 런타임&quot;모드로 연결합니다. 기본 연결 모드에서 링커는 공유 런타임 시스템 인 ocamlrun과 함께 실행되도록 의도 된 바이트 코드를 생성합니다. 사용자 정의 런타임 모드에서 링커는 런타임 시스템과 프로그램의 바이트 코드를 모두 포함하는 출력 파일을 생성합니다. 결과 파일은 더 크지 만 ocamlrun 명령이 설치되지 않은 경우에도 직접 실행할 수 있습니다. 또한 &quot;사용자 지정 런타임&quot;모드는 &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt; 장에 설명 된대로 사용자 정의 C 함수와 OCaml 코드의 정적 링크를 가능하게 합니다.</target>
        </trans-unit>
        <trans-unit id="90e15b2364cc575d6dbc34984468f8d6d885901b" translate="yes" xml:space="preserve">
          <source>Link in &amp;ldquo;custom runtime&amp;rdquo; mode. See the corresponding option for ocamlc, in chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;.</source>
          <target state="translated">&quot;사용자 지정 런타임&quot;모드로 연결합니다. &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; 장의 ocamlc에 대한 해당 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="dc3d988645b4957d3dd83740735d0cb6d66953cf" translate="yes" xml:space="preserve">
          <source>List concatenation.</source>
          <target state="translated">목록 연결.</target>
        </trans-unit>
        <trans-unit id="dbd013775c64eff58dc6132a245c0ce270a850c6" translate="yes" xml:space="preserve">
          <source>List concatenation. Not tail-recursive (length of the first argument). Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">목록 연결. 꼬리 재귀가 아닙니다 (첫 번째 인수의 길이). 오른쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="0365ae410f8457307452f898da684eba14b29c5f" translate="yes" xml:space="preserve">
          <source>List of directories searched to find the bytecode executable file.</source>
          <target state="translated">바이트 코드 실행 파일을 찾기 위해 검색된 디렉토리 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9eaa95db5646e28fe7153c07d0f70fa876dd1b94" translate="yes" xml:space="preserve">
          <source>List of format elements.</source>
          <target state="translated">형식 요소 목록입니다.</target>
        </trans-unit>
        <trans-unit id="7094bd5e681efcce9038e6d995bf2d060fc85079" translate="yes" xml:space="preserve">
          <source>List operations</source>
          <target state="translated">목록 작업</target>
        </trans-unit>
        <trans-unit id="2136f9decb402dc033169190742a9590a2e8171a" translate="yes" xml:space="preserve">
          <source>List operations.</source>
          <target state="translated">목록 작업.</target>
        </trans-unit>
        <trans-unit id="3b37d6672e7f341dcb945c17aabc1b419dec4f50" translate="yes" xml:space="preserve">
          <source>List reversal.</source>
          <target state="translated">목록 반전.</target>
        </trans-unit>
        <trans-unit id="637c60434c34ad7a7432343dd717e34e34be9418" translate="yes" xml:space="preserve">
          <source>List scanning</source>
          <target state="translated">목록 스캔</target>
        </trans-unit>
        <trans-unit id="76ca755f57f387a8fa5a689d0657d056de2dbb3e" translate="yes" xml:space="preserve">
          <source>List searching</source>
          <target state="translated">목록 검색</target>
        </trans-unit>
        <trans-unit id="6e130b5fdd6ede5933f5e364b277835f131b8204" translate="yes" xml:space="preserve">
          <source>List the source of module module, from line number beginning to line number end. By default, 20 lines of the current module are displayed, starting 10 lines before the current position.</source>
          <target state="translated">줄 번호 시작부터 줄 번호 끝까지 모듈 모듈의 소스를 나열합니다. 기본적으로 현재 모듈의 20 줄이 현재 위치보다 10 줄 이전부터 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6ca5f98ec9772c0239bb1a06bbafbaa7dccb5d4c" translate="yes" xml:space="preserve">
          <source>ListLabels</source>
          <target state="translated">ListLabels</target>
        </trans-unit>
        <trans-unit id="caa56fb279e78a5e60984ad896e4f99d33cd9ba0" translate="yes" xml:space="preserve">
          <source>Lists of pairs</source>
          <target state="translated">쌍 목록</target>
        </trans-unit>
        <trans-unit id="7c9984cdc3b0e43d1b8e01a6016b6b16f60122a8" translate="yes" xml:space="preserve">
          <source>Literals for 32-bit integers are suffixed by l:</source>
          <target state="translated">32 비트 정수에 대한 리터럴에는 l이 접미사로 붙습니다.</target>
        </trans-unit>
        <trans-unit id="0f376ff18d781ef4e7ce630da2eb8cc5e0867f63" translate="yes" xml:space="preserve">
          <source>Literals for 64-bit integers are suffixed by L:</source>
          <target state="translated">64 비트 정수에 대한 리터럴은 L이 접미사로 붙습니다.</target>
        </trans-unit>
        <trans-unit id="6259c5bb5a0b49cb897bdeab6a0b94ebf736355f" translate="yes" xml:space="preserve">
          <source>Literals for native integers are suffixed by n:</source>
          <target state="translated">네이티브 정수에 대한 리터럴은 n이 접미사로 붙습니다.</target>
        </trans-unit>
        <trans-unit id="68b1043a802b867b1154a51397b46d475fcc1b1c" translate="yes" xml:space="preserve">
          <source>Little-endian (resp. big-endian) encoding means that least (resp. most) significant bytes are stored first. Big-endian is also known as network byte order. Native-endian encoding is either little-endian or big-endian depending on &lt;a href=&quot;sys#VALbig_endian&quot;&gt;&lt;code&gt;Sys.big_endian&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리틀 엔디안 (각각 빅 엔디안) 인코딩은 최소 (각각 가장) 중요한 바이트가 먼저 저장됨을 의미합니다. Big-endian은 네트워크 바이트 순서라고도합니다. 네이티브 엔디안 인코딩은 &lt;a href=&quot;sys#VALbig_endian&quot;&gt; &lt;code&gt;Sys.big_endian&lt;/code&gt; &lt;/a&gt; 에 따라 little-endian 또는 big-endian 입니다.</target>
        </trans-unit>
        <trans-unit id="6cf6da19f9240117d92be77adf519c48a64293ee" translate="yes" xml:space="preserve">
          <source>Load in memory a bytecode object file (.cmo file) or library file (.cma file) produced by the batch compiler ocamlc.</source>
          <target state="translated">배치 컴파일러 ocamlc에서 생성 한 바이트 코드 개체 파일 (.cmo 파일) 또는 라이브러리 파일 (.cma 파일)을 메모리에로드합니다.</target>
        </trans-unit>
        <trans-unit id="10cbe4ea6dac6abfc435470246f61cb80c7ae677" translate="yes" xml:space="preserve">
          <source>Load in memory a bytecode object file (.cmo file) or library file (.cma file) produced by the batch compiler ocamlc. When loading an object file that depends on other modules which have not been loaded yet, the .cmo files for these modules are searched and loaded as well, recursively. The loading order is not specified.</source>
          <target state="translated">배치 컴파일러 ocamlc에서 생성 한 바이트 코드 개체 파일 (.cmo 파일) 또는 라이브러리 파일 (.cma 파일)을 메모리에로드합니다. 아직로드되지 않은 다른 모듈에 종속 된 개체 파일을로드 할 때 이러한 모듈에 대한 .cmo 파일도 반복적으로 검색되고로드됩니다. 로드 순서가 지정되지 않았습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
