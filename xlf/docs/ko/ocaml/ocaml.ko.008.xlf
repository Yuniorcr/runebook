<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="4bab6b7179d748b7bd5e0233cc4bee7fd29fef76" translate="yes" xml:space="preserve">
          <source>Enable output processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="412d02d844a8c91867b64526a04ce736b5034569" translate="yes" xml:space="preserve">
          <source>Enable parity check on input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac72b92dafda7ef51841541aaa002e202a5f9ecb" translate="yes" xml:space="preserve">
          <source>Enable parity generation and detection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="770fcb2eeb894c2e9d37a541226e5eca47597530" translate="yes" xml:space="preserve">
          <source>Enable the set of warnings corresponding to letter. The letter may be uppercase or lowercase.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58f210fa0832e7afc94eb19ba465c6cfb9687d2d" translate="yes" xml:space="preserve">
          <source>Enable the set of warnings corresponding to uppercase-letter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47140cbacce9eae9e7a7806fc75b0c141d4a9ebc" translate="yes" xml:space="preserve">
          <source>Enable warning number num.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="265fc90bc531f6f35f959332fc17890c9912c555" translate="yes" xml:space="preserve">
          <source>Enable warnings in the given range.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a218e074ec01ec172f8afd6aad1e646363974278" translate="yes" xml:space="preserve">
          <source>Enable, disable, or mark as fatal the warnings specified by the argument warning-list. Each warning can be &lt;em&gt;enabled&lt;/em&gt; or &lt;em&gt;disabled&lt;/em&gt;, and each warning can be &lt;em&gt;fatal&lt;/em&gt; or &lt;em&gt;non-fatal&lt;/em&gt;. If a warning is disabled, it isn&amp;rsquo;t displayed and doesn&amp;rsquo;t affect compilation in any way (even if it is fatal). If a warning is enabled, it is displayed normally by the compiler whenever the source code triggers it. If it is enabled and fatal, the compiler will also stop with an error after displaying it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14b271b15e5841b95bcc16da04d7676aa55f327e" translate="yes" xml:space="preserve">
          <source>Enables the PowerPC large model allowing the TOC (table of contents) to be arbitrarily large. This is the default since 4.11.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03401ca3edfdb4128312d6293c8a35421e582859" translate="yes" xml:space="preserve">
          <source>Enables the PowerPC small model allowing the TOC to be up to 64 kbytes per compilation unit. Prior to 4.11 this was the default behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5821fec7ee87050117e2081a31b307f34868a8ad" translate="yes" xml:space="preserve">
          <source>Encoding</source>
          <target state="translated">Encoding</target>
        </trans-unit>
        <trans-unit id="de8640801b22a0d8a7941409721bb3a98cd33e94" translate="yes" xml:space="preserve">
          <source>End of pretty-printing: resets the pretty-printer to initial state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50b618f1beb796972a9fd07d7599cf8ab8e9054" translate="yes" xml:space="preserve">
          <source>End-of-file character (usually ctrl-D).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b725184f8cc36a4f8ee2394c69c2dd8fd868d7e" translate="yes" xml:space="preserve">
          <source>Enforce the separation between types string and bytes, thereby making strings read-only. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0036f2b2e208fafb5dfcdf20fc4bf2ebd0e85c42" translate="yes" xml:space="preserve">
          <source>Ensure 32-bit compatibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541ccf2eac21a70a4145827ccb7cd6a05e98125f" translate="yes" xml:space="preserve">
          <source>Enumerated types are a special case of variant types, where all alternatives are constants:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b52f0dc6b40b4c37e2f81f6f54bc6aa05c7bffc" translate="yes" xml:space="preserve">
          <source>Environment queries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31712ff509a3de90defb9dc714b99a9f1ce278f8" translate="yes" xml:space="preserve">
          <source>Ephemeron</source>
          <target state="translated">Ephemeron</target>
        </trans-unit>
        <trans-unit id="d8381b886ce8e021a29bdc573e5df829fee81936" translate="yes" xml:space="preserve">
          <source>Ephemeron with arbitrary arity and untyped</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9483411c3a45e44db6a73f050d8e84f9ac980a3c" translate="yes" xml:space="preserve">
          <source>Ephemerons and weak hash tables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68dcdfc77c7716500d652b8b54eddd5f8823b37a" translate="yes" xml:space="preserve">
          <source>Ephemerons and weak hash tables are useful when one wants to cache or memorize the computation of a function, as long as the arguments and the function are used, without creating memory leaks by continuously keeping old computation results that are not useful anymore because one argument or the function is freed. An implementation using &lt;a href=&quot;hashtbl#TYPEt&quot;&gt;&lt;code&gt;Hashtbl.t&lt;/code&gt;&lt;/a&gt; is not suitable because all associations would keep the arguments and the result in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8055532213ae7a60925ad194d9e4810c98071c69" translate="yes" xml:space="preserve">
          <source>Ephemerons are defined in a language agnostic way in this paper: B. Hayes, Ephemerons: A New Finalization Mechanism, OOPSLA'97</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41096c468df31c97917965c8d891ad108e26d1fc" translate="yes" xml:space="preserve">
          <source>Ephemerons can also be used for &quot;adding&quot; a field to an arbitrary boxed OCaml value: you can attach some information to a value created by an external library without memory leaks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="509e85975836d7ac50cc9b68b081f475f1b2961c" translate="yes" xml:space="preserve">
          <source>Ephemerons hold some keys and one or no data. They are all boxed OCaml values. The keys of an ephemeron have the same behavior as weak pointers according to the garbage collector. In fact OCaml weak pointers are implemented as ephemerons without data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f749997472bd5134a97950c6d780f4f1c597e624" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;format#VALprint_flush&quot;&gt;&lt;code&gt;Format.print_flush&lt;/code&gt;&lt;/a&gt; followed by a new line. See corresponding words of caution for &lt;a href=&quot;format#VALprint_flush&quot;&gt;&lt;code&gt;Format.print_flush&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="132ad0d3139178d3cc06065a05035275b2ff94c6" translate="yes" xml:space="preserve">
          <source>Erase character (usually DEL or ctrl-H).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e96e1ad38c0966dc375be617296d87a44b956217" translate="yes" xml:space="preserve">
          <source>Erroneous printed signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f25135109ebab1ec1d489737e84df517dc0927" translate="yes" xml:space="preserve">
          <source>Error in environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7ccdbc8221cdeaf56848e96bf3b929db5cb197" translate="yes" xml:space="preserve">
          <source>Error recovery is supported as follows: when the parser reaches an error state (no grammar rules can apply), it calls a function named parse_error with the string &quot;syntax error&quot; as argument. The default parse_error function does nothing and returns, thus initiating error recovery (see below). The user can define a customized parse_error function in the header section of the grammar file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e31c347b987a17f7cb3d98f8aa8b10ea251a784" translate="yes" xml:space="preserve">
          <source>Error report</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c933b897af92835c337f8c15d042afda6a862cd4" translate="yes" xml:space="preserve">
          <source>Error reporting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ed179aaaaf044198d2d4b099b8f9cdd60f5ea6" translate="yes" xml:space="preserve">
          <source>Errors in dynamic linking are reported by raising the &lt;code&gt;Error&lt;/code&gt; exception with a description of the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0efc5d69dd69fd2174db30c880c7b6bb09d8c0c9" translate="yes" xml:space="preserve">
          <source>Errors in dynamic linking are reported by raising the &lt;code&gt;Error&lt;/code&gt; exception with a description of the error. A common case is the dynamic library not being found on the system: this is reported via &lt;code&gt;Cannot_open_dynamic_library&lt;/code&gt; (the enclosed exception may be platform-specific).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505e7e8c7959ad784a122d78879a599b96f2bf97" translate="yes" xml:space="preserve">
          <source>Escape accented characters in Info files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fde05190b55a3eed2e7dcfc6d80db47e06a76f0e" translate="yes" xml:space="preserve">
          <source>Especially when writing benchmarking suites that run non-side-effecting algorithms in loops, it may be found that the optimiser entirely elides the code being benchmarked. This behaviour can be prevented by using the Sys.opaque_identity function (which indeed behaves as a normal OCaml function and does not possess any &amp;ldquo;magic&amp;rdquo; semantics). The documentation of the Sys module should be consulted for further details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="709722b0c7e8d8e13600ac9f62e2965e7a3f0dc3" translate="yes" xml:space="preserve">
          <source>Establish a server on the given address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f1ae88cb41c8981c081c8dce853cd4b9948f674" translate="yes" xml:space="preserve">
          <source>Establish a server on the given address. The function given as first argument is called for each connection with two buffered channels connected to the client. A new process is created for each connection. The function &lt;a href=&quot;unix#VALestablish_server&quot;&gt;&lt;code&gt;Unix.establish_server&lt;/code&gt;&lt;/a&gt; never returns normally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="560d397e92aaad3554bd23d10de9d5e52de2dee9" translate="yes" xml:space="preserve">
          <source>Establish a server on the given address. The function given as first argument is called for each connection with two buffered channels connected to the client. A new process is created for each connection. The function &lt;a href=&quot;unixlabels#VALestablish_server&quot;&gt;&lt;code&gt;UnixLabels.establish_server&lt;/code&gt;&lt;/a&gt; never returns normally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a6caa3a0a19447950f461ddf1293d94c142f80" translate="yes" xml:space="preserve">
          <source>Even function composition is definable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c21414076c7e3bcf34bf847855694be0bc01134" translate="yes" xml:space="preserve">
          <source>Even if a value has a fixed variant type, one can still give it a larger type through coercions. Coercions are normally written with both the source type and the destination type, but in simple cases the source type may be omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad8919ace091b14011c6439cfd5e1707b58f5abd" translate="yes" xml:space="preserve">
          <source>Event</source>
          <target state="translated">Event</target>
        </trans-unit>
        <trans-unit id="002a13e663c95fdf83e648de45960c94bd85c63d" translate="yes" xml:space="preserve">
          <source>Events are &amp;ldquo;interesting&amp;rdquo; locations in the source code, corresponding to the beginning or end of evaluation of &amp;ldquo;interesting&amp;rdquo; sub-expressions. Events are the unit of single-stepping (stepping goes to the next or previous event encountered in the program execution). Also, breakpoints can only be set at events. Thus, events play the role of line numbers in debuggers for conventional languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f8fea95f2f905afaf5702b20b4c2af865028ce" translate="yes" xml:space="preserve">
          <source>Every break hint in a vertical box splits the line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43eedd80f49a7cd19f66f688554ddc3114ee51c" translate="yes" xml:space="preserve">
          <source>Every function in this module raises &lt;code&gt;Sys_error&lt;/code&gt; with an informative message when the underlying system call signal an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="53c17e0e359a4c32fb2e90ba769249f80da0ed09" translate="yes" xml:space="preserve">
          <source>Example: &lt;code&gt;printf&amp;nbsp;&quot;@[%s@&amp;nbsp;%d@]@.&quot;&amp;nbsp;&quot;x&amp;nbsp;=&quot;&amp;nbsp;1&lt;/code&gt; is equivalent to &lt;code&gt;open_box&amp;nbsp;();&amp;nbsp;print_string&amp;nbsp;&quot;x&amp;nbsp;=&quot;;&amp;nbsp;print_space&amp;nbsp;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;print_int&amp;nbsp;1;&amp;nbsp;close_box&amp;nbsp;();&amp;nbsp;print_newline&amp;nbsp;()&lt;/code&gt;. It prints &lt;code&gt;x&amp;nbsp;=&amp;nbsp;1&lt;/code&gt; within a pretty-printing 'horizontal-or-vertical' box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7867675b155e93124d37b927a09603512264fe69" translate="yes" xml:space="preserve">
          <source>Example: a lexer suitable for a desk calculator is obtained by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="895e8f203a6495776734a740f015692cd2b3b1aa" translate="yes" xml:space="preserve">
          <source>Example: the following C primitive invokes gethostbyname to find the IP address of a host name. The gethostbyname function can block for a long time, so we choose to release the OCaml run-time system while it is running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="811da335fb02658aeea8e581a3a2ee5c053b4621" translate="yes" xml:space="preserve">
          <source>Examples (&lt;code&gt;cmd&lt;/code&gt; is assumed to be the command name):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="3f519a0ed2ab9c204d38ec6035c856c982aaeca9" translate="yes" xml:space="preserve">
          <source>Exception definitions add new constructors to the built-in variant type &lt;code&gt;exn&lt;/code&gt; of exception values. The constructors are declared as for a definition of a variant type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4b0dfe7027c1d349ba13a7e79558e44ec341bd8" translate="yes" xml:space="preserve">
          <source>Exception handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d431d2533016ca9ad29f4d173d1b14c07b74bb13" translate="yes" xml:space="preserve">
          <source>Exception raised by input functions to signal that the end of file has been reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82978f55e4581497009424eb5b42bd93b3ca7e49" translate="yes" xml:space="preserve">
          <source>Exception raised by integer division and remainder operations when their second argument is zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d4510a4445338226928ea929221d7a1a2b7357" translate="yes" xml:space="preserve">
          <source>Exception raised by library functions to signal that the given arguments do not make sense.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ce3e5fe0fb1d8b41956476928546ec08a9de8a9" translate="yes" xml:space="preserve">
          <source>Exception raised by library functions to signal that the given arguments do not make sense. The string gives some information to the programmer. As a general rule, this exception should not be caught, it denotes a programming error and the code should be modified not to trigger it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd340ed580df2f3db47ef85feb52884932b1b6a4" translate="yes" xml:space="preserve">
          <source>Exception raised by library functions to signal that they are undefined on the given arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa93c3585b8f661e83ab6ba8e4b8cff0539794a" translate="yes" xml:space="preserve">
          <source>Exception raised by library functions to signal that they are undefined on the given arguments. The string is meant to give some information to the programmer; you must &lt;em&gt;not&lt;/em&gt; pattern match on the string literal because it may change in future versions (use &lt;code&gt;Failure _&lt;/code&gt; instead).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="797259d42c53292ad6d9cae5fe9499225a450501" translate="yes" xml:space="preserve">
          <source>Exception raised by library functions to signal that they are undefined on the given arguments. The string is meant to give some information to the programmer; you must not pattern match on the string literal because it may change in future versions (use Failure _ instead).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a939c6f19243a7a27b33817d6c3cccd399f0471" translate="yes" xml:space="preserve">
          <source>Exception raised by search functions when the desired object could not be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74e471d3322f6cf64419d195e08e460252e2c212" translate="yes" xml:space="preserve">
          <source>Exception raised by the bytecode interpreter when the evaluation stack reaches its maximal size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5e572e45624dcdfce646146b1c59f0702b1de31" translate="yes" xml:space="preserve">
          <source>Exception raised by the bytecode interpreter when the evaluation stack reaches its maximal size. This often indicates infinite or excessively deep recursion in the user&amp;rsquo;s program. Before 4.10, it was not fully implemented by the native-code compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eafbe2aa6287023677ed95d39e464d69f627603a" translate="yes" xml:space="preserve">
          <source>Exception raised by the bytecode interpreter when the evaluation stack reaches its maximal size. This often indicates infinite or excessively deep recursion in the user's program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c82737838d58bf71651d2fbaaf6dcd90b0e977" translate="yes" xml:space="preserve">
          <source>Exception raised by the garbage collector when there is insufficient memory to complete the computation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86afff90609a22e194dc3619fb61e1382a6dfa8b" translate="yes" xml:space="preserve">
          <source>Exception raised by the garbage collector when there is insufficient memory to complete the computation. (Not reliable for allocations on the minor heap.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04f61cd268d77caa95705043d94ff400c1717740" translate="yes" xml:space="preserve">
          <source>Exception raised by the input/output functions to report an operating system error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3bf7bb486274539ef14aee9c61a39c45080f2b2" translate="yes" xml:space="preserve">
          <source>Exception raised by the input/output functions to report an operating system error. The string is meant to give some information to the programmer; you must &lt;em&gt;not&lt;/em&gt; pattern match on the string literal because it may change in future versions (use &lt;code&gt;Sys_error _&lt;/code&gt; instead).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0581cb33548055979f48d1861e6b229eba7ab670" translate="yes" xml:space="preserve">
          <source>Exception raised by the input/output functions to report an operating system error. The string is meant to give some information to the programmer; you must not pattern match on the string literal because it may change in future versions (use Sys_error _ instead).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf3b34162fd333f111fabc4e1219ee5b7ee0f141" translate="yes" xml:space="preserve">
          <source>Exception raised on interactive interrupt if &lt;a href=&quot;sys#VALcatch_break&quot;&gt;&lt;code&gt;Sys.catch_break&lt;/code&gt;&lt;/a&gt; is on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be295586a8b968373c605fa23bab4f0788068a9" translate="yes" xml:space="preserve">
          <source>Exception raised when an assertion fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b18713a9f11df2a32a9f4552d5cc9de4147090a" translate="yes" xml:space="preserve">
          <source>Exception raised when an assertion fails. The arguments are the location of the assert keyword in the source code (file name, line number, column number).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f697fde1fd79527c41f5e00a6e22980baa8cb48" translate="yes" xml:space="preserve">
          <source>Exception raised when an ill-founded recursive module definition is evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a113d2a72fa73bfe6280e7724ea7861fe51a705" translate="yes" xml:space="preserve">
          <source>Exception raised when an ill-founded recursive module definition is evaluated. (See section &lt;a href=&quot;manual024#s%3Arecursive-modules&quot;&gt;8.2&lt;/a&gt;.) The arguments are the location of the definition in the source code (file name, line number, column number).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdb4b79613ced915c490c09e8d6900bf35cdc038" translate="yes" xml:space="preserve">
          <source>Exception raised when an ill-founded recursive module definition is evaluated. The arguments are the location of the definition in the source code (file name, line number, column number).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6a958202f1e3608e7a8ea01d2ca2751bd4bea07" translate="yes" xml:space="preserve">
          <source>Exception raised when none of the cases of a pattern-matching apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de14bb71c34237905f8dcebb811a688e4de7f45d" translate="yes" xml:space="preserve">
          <source>Exception raised when none of the cases of a pattern-matching apply. The arguments are the location of the match keyword in the source code (file name, line number, column number).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3cff116501149a61e1bc172f77a1f0dc84b3e9" translate="yes" xml:space="preserve">
          <source>Exception slots</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="2238f9897bfd70f8e17c597ae32443c2178f3778" translate="yes" xml:space="preserve">
          <source>Exceptions are defined with the syntax exception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; or exception&lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt;=&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd41474f597589f8ce75091ee7c9d450a6dace1b" translate="yes" xml:space="preserve">
          <source>Exceptions are used throughout the standard library to signal cases where the library functions cannot complete normally. For instance, the List.assoc function, which returns the data associated with a given key in a list of (key, data) pairs, raises the predefined exception Not_found when the key does not appear in the list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dedd1c7c976e1735c5590d9e4db8485865a74ba0" translate="yes" xml:space="preserve">
          <source>Exceptions arising from allocation points, for example &amp;ldquo;out of memory&amp;rdquo; or exceptions propagated from finalizers or signal handlers, are treated as &amp;ldquo;effects out of the ether&amp;rdquo; and thus ignored for our determination here of effectfulness. The same goes for floating point operations that may cause hardware traps on some platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991e714f33417fc77efb0b8c274e6fb8c4a2e225" translate="yes" xml:space="preserve">
          <source>Exceptions can be trapped with the try&amp;hellip;with construct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="372172c1d79adf3d5e9eda6ccfe3f8d90f9945ca" translate="yes" xml:space="preserve">
          <source>Exceptions during scanning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2554291b193ac0bbead288da0987203e8cf0cef" translate="yes" xml:space="preserve">
          <source>Exceptions: A function application followed by a function return is replaced by the compiler by a jump (tail-call optimization). In this case, no event is put after the function application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8396b2656b2d03ab3b6f1d6e1517dcf7f9323c" translate="yes" xml:space="preserve">
          <source>Executables generated by ocamlopt are native, stand-alone executable files that can be invoked directly. They do not depend on the ocamlrun bytecode runtime system nor on dynamically-loaded C/OCaml stub libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a75cb0fbe6e1f95d107a45c86db811a6af245781" translate="yes" xml:space="preserve">
          <source>Execute a command and evaluate its output as if it had been captured to a file and passed to #use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd6abf7887c4d2e28797ef14bbf252bcefcb389d" translate="yes" xml:space="preserve">
          <source>Execute the given command, wait until it terminates, and return its termination status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="574778ff914e7f066648409df6d7571f66b0628f" translate="yes" xml:space="preserve">
          <source>Execute the given command, wait until it terminates, and return its termination status. The string is interpreted by the shell &lt;code&gt;/bin/sh&lt;/code&gt; (or the command interpreter &lt;code&gt;cmd.exe&lt;/code&gt; on Windows) and therefore can contain redirections, quotes, variables, etc. To properly quote whitespace and shell special characters occurring in file names or command arguments, the use of &lt;a href=&quot;filename#VALquote_command&quot;&gt;&lt;code&gt;Filename.quote_command&lt;/code&gt;&lt;/a&gt; is recommended. The result &lt;code&gt;WEXITED&amp;nbsp;127&lt;/code&gt; indicates that the shell couldn't be executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7d77de49a824f25b1c29a5f4eec5fd988f90820" translate="yes" xml:space="preserve">
          <source>Execute the given command, wait until it terminates, and return its termination status. The string is interpreted by the shell &lt;code&gt;/bin/sh&lt;/code&gt; and therefore can contain redirections, quotes, variables, etc. The result &lt;code&gt;WEXITED&amp;nbsp;127&lt;/code&gt; indicates that the shell couldn't be executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0608baa8a78b5ae914f3003511af7be2c2c93014" translate="yes" xml:space="preserve">
          <source>Execute the given shell command and return its exit code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0af194ef467afd2c1974b37ed62f0bacbfce09b8" translate="yes" xml:space="preserve">
          <source>Execute the next formatting command if the preceding line has just been split.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7de809064d068ca06042492cbbecc713a130fb0" translate="yes" xml:space="preserve">
          <source>Execute the next formatting command if the preceding line has just been split. Otherwise, ignore the next formatting command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6f74a11401cd4113f73bb69746c60cbce990f88" translate="yes" xml:space="preserve">
          <source>Execute the program backward from current time. Mostly useful to go to the last breakpoint encountered before the current time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df078a291452a67568ddc09970c248124955e570" translate="yes" xml:space="preserve">
          <source>Execute the program forward from current time. Stops at next breakpoint or when the program terminates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c02112c85adf1b08f7e5853b39572e0ee9bc6c34" translate="yes" xml:space="preserve">
          <source>Execution permission</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e880ccfcb55dc69e7de8a37d9266e752fe53e6d" translate="yes" xml:space="preserve">
          <source>Execution speed of instrumented programs may be increased by using a compiler configured with the -disable-libunwind option. This prevents collection of profiling information from C stubs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6612d96f1b19e6fcd3bf9e1ca12e32ac3e408b29" translate="yes" xml:space="preserve">
          <source>Exit the toplevel loop and terminate the ocaml command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4613952597a60f36dc738da2fc8adbdc7b73e160" translate="yes" xml:space="preserve">
          <source>Explain that the element may raise the exception Exc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bbb0891217ae52a1ab104fe98d015359de8bd2c" translate="yes" xml:space="preserve">
          <source>Explicit polymorphic annotations are however not sufficient to cover all the cases where the inferred type of a function is less general than expected. A similar problem arises when using polymorphic functions as arguments of higher-order functions. For instance, we may want to compute the average depth or length of two nested lists:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e27dcc67d74da822483f4a87bdb412456ae6c72" translate="yes" xml:space="preserve">
          <source>Exponential.</source>
          <target state="translated">Exponential.</target>
        </trans-unit>
        <trans-unit id="00626a4a235bb8c7d8a4523a50b2711b29b68253" translate="yes" xml:space="preserve">
          <source>Exponentiation.</source>
          <target state="translated">Exponentiation.</target>
        </trans-unit>
        <trans-unit id="19211cb05426c63a6dfeb4df4f1124b3d1c45b8a" translate="yes" xml:space="preserve">
          <source>Exponentiation. &lt;code&gt;exp&amp;nbsp;z&lt;/code&gt; returns &lt;code&gt;e&lt;/code&gt; to the &lt;code&gt;z&lt;/code&gt; power.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8d13444fe741e7b3307739c09714d1365b0f345" translate="yes" xml:space="preserve">
          <source>Exponentiation. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c203b1d6525313f2263e8e1944c32119cb764891" translate="yes" xml:space="preserve">
          <source>Expression on the left-hand side of a sequence that doesn&amp;rsquo;t have type unit (and that is not a function, see warning number 5).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f1705d75bccd5f48e15260577376d17aae18ac" translate="yes" xml:space="preserve">
          <source>Expressions can be evaluated and bound before defining the object body of the class. This is useful to enforce invariants. For instance, points can be automatically adjusted to the nearest point on a grid, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23bad0bff2cfb9167ce61cc77278d82a1d641c32" translate="yes" xml:space="preserve">
          <source>Expressions found to be constant will be lifted to symbol bindings&amp;mdash;that is to say, they will be statically allocated in the object file&amp;mdash;when they evaluate to boxed values. Such constants may be straightforward numeric constants, such as the floating-point number 42.0, or more complicated values such as constant closures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ad4d4956756b40be94add29cb72479307f0f0b9" translate="yes" xml:space="preserve">
          <source>Expressions that can be printed are a subset of OCaml expressions, as described by the following grammar:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc85e1b2d1a796e6a7518d332650d75cedd74aa" translate="yes" xml:space="preserve">
          <source>Expressions whose type contains object or polymorphic variant types can be explicitly coerced (weakened) to a supertype. The expression (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;:&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;) coerces the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; to type &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;. The expression (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;) coerces the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; from type &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to type &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b81693815dc1bf7299ce7a39fbde9dd09e2888" translate="yes" xml:space="preserve">
          <source>Extensible buffers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7bb5fa60fa6d03a7e762271e49bf8b6f67aabc7" translate="yes" xml:space="preserve">
          <source>Extensible variant constructors can be declared private. As with regular variants, this prevents them from being constructed directly by constructor application while still allowing them to be de-structured in pattern-matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a751b1c007eb71d24f98009b78b3028fcfd142ad" translate="yes" xml:space="preserve">
          <source>Extensible variant constructors can be rebound to a different name. This allows exporting variants from another module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb163e8407915a65efaeea5f20e5a40195d135d5" translate="yes" xml:space="preserve">
          <source>Extensible variant types are variant types which can be extended with new variant constructors. Extensible variant types are defined using ... New variant constructors are added using +=.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbae4e45fe35ccd27009a7f6ac4d50b75dc776ba" translate="yes" xml:space="preserve">
          <source>Extensible variant types can be declared private. This prevents new constructors from being declared directly, but allows extension constructors to be referred to in interfaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abad3f737769af1c5381da23ef9ef6b76a078836" translate="yes" xml:space="preserve">
          <source>Extension nodes are generic placeholders in the syntax tree. They are rejected by the type-checker and are intended to be &amp;ldquo;expanded&amp;rdquo; by external tools such as -ppx rewriters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d5c126d6514cf4043869b49a67a530848a05b30" translate="yes" xml:space="preserve">
          <source>Extension nodes share the same notion of identifier and payload as attributes &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;8.12&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf67e72b2f02af1dfb2d6ba5dfec301a7a98be7" translate="yes" xml:space="preserve">
          <source>External functions thus defined can be specified in interface files or sig&amp;hellip;end signatures either as regular values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac72a44ed810b210da3e88f1a54857ee291d450b" translate="yes" xml:space="preserve">
          <source>Extra labeled libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f790fb266cf755446d7f9e758cc6eb9851e8e4a0" translate="yes" xml:space="preserve">
          <source>Extract a column (one-dimensional slice) of the given two-dimensional Bigarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833297ee7526e57b208b20f4c18e1d5dca4a7686" translate="yes" xml:space="preserve">
          <source>Extract a column (one-dimensional slice) of the given two-dimensional Bigarray. The integer parameter is the index of the column to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array2.slice_right&lt;/code&gt; applies only to arrays with Fortran layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb22154616f00f2f011552b3ea60d6b2aecf319e" translate="yes" xml:space="preserve">
          <source>Extract a one-dimensional slice of the given three-dimensional Bigarray by fixing the first two coordinates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad37ffd1656e9bfa0f39271771a3d21b053f2b47" translate="yes" xml:space="preserve">
          <source>Extract a one-dimensional slice of the given three-dimensional Bigarray by fixing the first two coordinates. The integer parameters are the coordinates of the slice to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array3.slice_left_1&lt;/code&gt; applies only to arrays with C layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6010cd1774b0e36289453cc1e6dfe0970661753" translate="yes" xml:space="preserve">
          <source>Extract a one-dimensional slice of the given three-dimensional Bigarray by fixing the last two coordinates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf737c09a505d01b3f96a5a97197df81b81dd1a3" translate="yes" xml:space="preserve">
          <source>Extract a one-dimensional slice of the given three-dimensional Bigarray by fixing the last two coordinates. The integer parameters are the coordinates of the slice to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array3.slice_right_1&lt;/code&gt; applies only to arrays with Fortran layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0e5512943bae825f5c013cca4f39482aa0889f2" translate="yes" xml:space="preserve">
          <source>Extract a row (one-dimensional slice) of the given two-dimensional Bigarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26d59417fe2650d9c47ddc3625b1cd42e8be0565" translate="yes" xml:space="preserve">
          <source>Extract a row (one-dimensional slice) of the given two-dimensional Bigarray. The integer parameter is the index of the row to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array2.slice_left&lt;/code&gt; applies only to arrays with C layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f298454ec85bb5b2575358f7258eca1d4945ff16" translate="yes" xml:space="preserve">
          <source>Extract a scalar (zero-dimensional slice) of the given one-dimensional Bigarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d9a56c0a314a42963df6eba68beda2c406199e0" translate="yes" xml:space="preserve">
          <source>Extract a scalar (zero-dimensional slice) of the given one-dimensional Bigarray. The integer parameter is the index of the scalar to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4890dc1e2a164bc3bd30e8680621df9dc17f4f52" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of lower dimension from the given Bigarray by fixing one or several of the first (left-most) coordinates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40d6af71cee95b994ed1e0170824c34a05edad4a" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of lower dimension from the given Bigarray by fixing one or several of the first (left-most) coordinates. &lt;code&gt;Genarray.slice_left&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...&amp;nbsp;;&amp;nbsp;iM|]&lt;/code&gt; returns the 'slice' of &lt;code&gt;a&lt;/code&gt; obtained by setting the first &lt;code&gt;M&lt;/code&gt; coordinates to &lt;code&gt;i1&lt;/code&gt;, ..., &lt;code&gt;iM&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has &lt;code&gt;N&lt;/code&gt; dimensions, the slice has dimension &lt;code&gt;N&amp;nbsp;-&amp;nbsp;M&lt;/code&gt;, and the element at coordinates &lt;code&gt;[|j1;&amp;nbsp;...;&amp;nbsp;j(N-M)|]&lt;/code&gt; in the slice is identical to the element at coordinates &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iM;&amp;nbsp;j1;&amp;nbsp;...;&amp;nbsp;j(N-M)|]&lt;/code&gt; in the original array &lt;code&gt;a&lt;/code&gt;. No copying of elements is involved: the slice and the original array share the same storage space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4991d63b98b224377a908b9a4d6c71e3eaac9a4c" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of lower dimension from the given Bigarray by fixing one or several of the last (right-most) coordinates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3da691a1efc9418f8852a37e8c7a82a916c26169" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of lower dimension from the given Bigarray by fixing one or several of the last (right-most) coordinates. &lt;code&gt;Genarray.slice_right&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...&amp;nbsp;;&amp;nbsp;iM|]&lt;/code&gt; returns the 'slice' of &lt;code&gt;a&lt;/code&gt; obtained by setting the last &lt;code&gt;M&lt;/code&gt; coordinates to &lt;code&gt;i1&lt;/code&gt;, ..., &lt;code&gt;iM&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has &lt;code&gt;N&lt;/code&gt; dimensions, the slice has dimension &lt;code&gt;N&amp;nbsp;-&amp;nbsp;M&lt;/code&gt;, and the element at coordinates &lt;code&gt;[|j1;&amp;nbsp;...;&amp;nbsp;j(N-M)|]&lt;/code&gt; in the slice is identical to the element at coordinates &lt;code&gt;[|j1;&amp;nbsp;...;&amp;nbsp;j(N-M);&amp;nbsp;i1;&amp;nbsp;...;&amp;nbsp;iM|]&lt;/code&gt; in the original array &lt;code&gt;a&lt;/code&gt;. No copying of elements is involved: the slice and the original array share the same storage space.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c46828383a7b610302db9977200dc3af956d9d40" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of the given Bigarray by restricting the first (left-most) dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aff802ef1d94d3ecbad0ecdb29da0e7d90a7532" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of the given Bigarray by restricting the first (left-most) dimension. &lt;code&gt;Genarray.sub_left&amp;nbsp;a&amp;nbsp;ofs&amp;nbsp;len&lt;/code&gt; returns a Bigarray with the same number of dimensions as &lt;code&gt;a&lt;/code&gt;, and the same dimensions as &lt;code&gt;a&lt;/code&gt;, except the first dimension, which corresponds to the interval &lt;code&gt;[ofs&amp;nbsp;...&amp;nbsp;ofs&amp;nbsp;+&amp;nbsp;len&amp;nbsp;-&amp;nbsp;1]&lt;/code&gt; of the first dimension of &lt;code&gt;a&lt;/code&gt;. No copying of elements is involved: the sub-array and the original array share the same storage space. In other terms, the element at coordinates &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; of the sub-array is identical to the element at coordinates &lt;code&gt;[|i1+ofs;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; of the original array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec56516e6aae1f3b317a5b584d2632b8a7b8895e" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of the given Bigarray by restricting the last (right-most) dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34e0eda1631250d817bcac2137b343bc89c7dd1" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of the given Bigarray by restricting the last (right-most) dimension. &lt;code&gt;Genarray.sub_right&amp;nbsp;a&amp;nbsp;ofs&amp;nbsp;len&lt;/code&gt; returns a Bigarray with the same number of dimensions as &lt;code&gt;a&lt;/code&gt;, and the same dimensions as &lt;code&gt;a&lt;/code&gt;, except the last dimension, which corresponds to the interval &lt;code&gt;[ofs&amp;nbsp;...&amp;nbsp;ofs&amp;nbsp;+&amp;nbsp;len&amp;nbsp;-&amp;nbsp;1]&lt;/code&gt; of the last dimension of &lt;code&gt;a&lt;/code&gt;. No copying of elements is involved: the sub-array and the original array share the same storage space. In other terms, the element at coordinates &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; of the sub-array is identical to the element at coordinates &lt;code&gt;[|i1;&amp;nbsp;...;&amp;nbsp;iN+ofs|]&lt;/code&gt; of the original array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5554ff9dda92542b6f7561e6614060047356a2b" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of the given one-dimensional Bigarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0974dd62db48917a734039db3543ccc1edaf6d5" translate="yes" xml:space="preserve">
          <source>Extract a sub-array of the given one-dimensional Bigarray. See &lt;a href=&quot;bigarray.genarray#VALsub_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.sub_left&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e53e9d490ec58fcd840b3ecff5aa4d740c5a251b" translate="yes" xml:space="preserve">
          <source>Extract a three-dimensional sub-array of the given three-dimensional Bigarray by restricting the first dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dbaf2cc98d146044211330545282dd4bf053e2b" translate="yes" xml:space="preserve">
          <source>Extract a three-dimensional sub-array of the given three-dimensional Bigarray by restricting the first dimension. See &lt;a href=&quot;bigarray.genarray#VALsub_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.sub_left&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array3.sub_left&lt;/code&gt; applies only to arrays with C layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7316b8d9a713505a81c0b289dbb0aa52b6e1f01" translate="yes" xml:space="preserve">
          <source>Extract a three-dimensional sub-array of the given three-dimensional Bigarray by restricting the second dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="056b02ba98ed67c31e20bd342a4e027d66f1e6cc" translate="yes" xml:space="preserve">
          <source>Extract a three-dimensional sub-array of the given three-dimensional Bigarray by restricting the second dimension. See &lt;a href=&quot;bigarray.genarray#VALsub_right&quot;&gt;&lt;code&gt;Bigarray.Genarray.sub_right&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array3.sub_right&lt;/code&gt; applies only to arrays with Fortran layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c50856385dbad4b307a8ae71cadaf999e22cc35" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional slice of the given three-dimensional Bigarray by fixing the first coordinate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59aaaea254d72dfb6345bd1442c286d26075296" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional slice of the given three-dimensional Bigarray by fixing the first coordinate. The integer parameter is the first coordinate of the slice to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_left&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array3.slice_left_2&lt;/code&gt; applies only to arrays with C layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3c305334b5904d71fa016401a34c6c315c3352" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional slice of the given three-dimensional Bigarray by fixing the last coordinate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3884aec3f88c9f1f2b2e3b25f39bd946908fcc74" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional slice of the given three-dimensional Bigarray by fixing the last coordinate. The integer parameter is the coordinate of the slice to extract. See &lt;a href=&quot;bigarray.genarray#VALslice_right&quot;&gt;&lt;code&gt;Bigarray.Genarray.slice_right&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array3.slice_right_2&lt;/code&gt; applies only to arrays with Fortran layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d60284e2482e2e7da314ae1de64dae482731ef85" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional sub-array of the given two-dimensional Bigarray by restricting the first dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a423ddd0f0211bed822fd7dfab480315f3a9a59" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional sub-array of the given two-dimensional Bigarray by restricting the first dimension. See &lt;a href=&quot;bigarray.genarray#VALsub_left&quot;&gt;&lt;code&gt;Bigarray.Genarray.sub_left&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array2.sub_left&lt;/code&gt; applies only to arrays with C layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed998f4ffe6b722cf6d8ef34b19960eb7ede4ad" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional sub-array of the given two-dimensional Bigarray by restricting the second dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccaeebe42f0e1c15c6787813703cfa497e76749e" translate="yes" xml:space="preserve">
          <source>Extract a two-dimensional sub-array of the given two-dimensional Bigarray by restricting the second dimension. See &lt;a href=&quot;bigarray.genarray#VALsub_right&quot;&gt;&lt;code&gt;Bigarray.Genarray.sub_right&lt;/code&gt;&lt;/a&gt; for more details. &lt;code&gt;Array2.sub_right&lt;/code&gt; applies only to arrays with Fortran layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad5026b7dc3bacdd43b7f246a7f6d355abdaa47" translate="yes" xml:space="preserve">
          <source>Extracting substrings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b9db1548668247eee1e8880959fa3591e3a3f0" translate="yes" xml:space="preserve">
          <source>Extracts the user-friendly &lt;code&gt;backtrace_slot&lt;/code&gt; from a low-level &lt;code&gt;raw_backtrace_slot&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="9b227096d517556947fe5ddf19ad842bf0317b23" translate="yes" xml:space="preserve">
          <source>Facilities for printing exceptions and inspecting current call stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ea25d08286e5c67d1bfdcc8c7290314f442be43" translate="yes" xml:space="preserve">
          <source>Fail if existing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecb4bd69a6ae63ba2585855d8e2360544daa005f" translate="yes" xml:space="preserve">
          <source>Fail if host name cannot be determined</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49181351ef86b5c339057ac4b44372106d23409e" translate="yes" xml:space="preserve">
          <source>Fall back to building a statically linked library if a problem occurs while building the shared library (e.g. some of the support libraries are not available as shared libraries).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f914367bce8b82c6d2195d3b60d9769e3807c9c" translate="yes" xml:space="preserve">
          <source>Field(v, n) returns the value contained in the n&lt;sup&gt;th&lt;/sup&gt; field of the structured block v. Fields are numbered from 0 to Wosize_val(v)&amp;minus;1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1357f987d25405bca293332f1eeee71384be4553" translate="yes" xml:space="preserve">
          <source>File descriptor for standard error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77574dc3227cd0b3aba7be8d0ef544f784522a63" translate="yes" xml:space="preserve">
          <source>File descriptor for standard input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e96c4faba360baae26988330ca973ca4d0050a8" translate="yes" xml:space="preserve">
          <source>File descriptor for standard output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4abf36a5ea54ec41cce22ec0fe706639aba0b93" translate="yes" xml:space="preserve">
          <source>File exists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af796a734908b2af6a033fc6dd399e38e2271966" translate="yes" xml:space="preserve">
          <source>File operations on large files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76015cd07e74ef92d5b2a92fce2d1e110d93be0" translate="yes" xml:space="preserve">
          <source>File operations on large files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5216af1ac5b2e2dabbd11ec27979253222912a30" translate="yes" xml:space="preserve">
          <source>File operations on large files. This sub-module provides 64-bit variants of the functions &lt;a href=&quot;unix#VALlseek&quot;&gt;&lt;code&gt;Unix.lseek&lt;/code&gt;&lt;/a&gt; (for positioning a file descriptor), &lt;a href=&quot;unix#VALtruncate&quot;&gt;&lt;code&gt;Unix.truncate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unix#VALftruncate&quot;&gt;&lt;code&gt;Unix.ftruncate&lt;/code&gt;&lt;/a&gt; (for changing the size of a file), and &lt;a href=&quot;unix#VALstat&quot;&gt;&lt;code&gt;Unix.stat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unix#VALlstat&quot;&gt;&lt;code&gt;Unix.lstat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unix#VALfstat&quot;&gt;&lt;code&gt;Unix.fstat&lt;/code&gt;&lt;/a&gt; (for obtaining information on files). These alternate functions represent positions and sizes by 64-bit integers (type &lt;code&gt;int64&lt;/code&gt;) instead of regular integers (type &lt;code&gt;int&lt;/code&gt;), thus allowing operating on files whose sizes are greater than &lt;code&gt;max_int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe66056a71a2dfbc4eea74801f25159274efcb1" translate="yes" xml:space="preserve">
          <source>File operations on large files. This sub-module provides 64-bit variants of the functions &lt;a href=&quot;unixlabels#VALlseek&quot;&gt;&lt;code&gt;UnixLabels.lseek&lt;/code&gt;&lt;/a&gt; (for positioning a file descriptor), &lt;a href=&quot;unixlabels#VALtruncate&quot;&gt;&lt;code&gt;UnixLabels.truncate&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unixlabels#VALftruncate&quot;&gt;&lt;code&gt;UnixLabels.ftruncate&lt;/code&gt;&lt;/a&gt; (for changing the size of a file), and &lt;a href=&quot;unixlabels#VALstat&quot;&gt;&lt;code&gt;UnixLabels.stat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unixlabels#VALlstat&quot;&gt;&lt;code&gt;UnixLabels.lstat&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unixlabels#VALfstat&quot;&gt;&lt;code&gt;UnixLabels.fstat&lt;/code&gt;&lt;/a&gt; (for obtaining information on files). These alternate functions represent positions and sizes by 64-bit integers (type &lt;code&gt;int64&lt;/code&gt;) instead of regular integers (type &lt;code&gt;int&lt;/code&gt;), thus allowing operating on files whose sizes are greater than &lt;code&gt;max_int&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fbef3ee3d6f5c033c6b0bfc9ab2581751e1aa6e" translate="yes" xml:space="preserve">
          <source>File permissions and ownership</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28350cca828096efd67f5a171372164c14d8d2d6" translate="yes" xml:space="preserve">
          <source>File size limit exceeded</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce8eb49cc7bfa53c4610e26085f92f61b9a4f0a4" translate="yes" xml:space="preserve">
          <source>File size or position not representable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23d0dc8812f4ca4c291d107ca6848e74d92c16dd" translate="yes" xml:space="preserve">
          <source>File status</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0704a4eaa055ab08e3766911e446737f4f2a445" translate="yes" xml:space="preserve">
          <source>File too large</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3cbb98ddf5ee976bc1c3be5221d66ce3ca2e867" translate="yes" xml:space="preserve">
          <source>Filename</source>
          <target state="translated">Filename</target>
        </trans-unit>
        <trans-unit id="5ba8d30ffba45db4e2f3f220829fe902e2fd990f" translate="yes" xml:space="preserve">
          <source>Filename too long</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d0bcfe0109818a103380175b84cf616a760f08" translate="yes" xml:space="preserve">
          <source>Fill the &lt;code&gt;ai_canonname&lt;/code&gt; field of the result</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ecdaab3e6d2d606bd8449af095659f45138d642" translate="yes" xml:space="preserve">
          <source>Fill the given Bigarray with the given value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6426f6cf359319ede0b204876e95f5ca2c6e0acd" translate="yes" xml:space="preserve">
          <source>Fill the given Bigarray with the given value. See &lt;a href=&quot;bigarray.genarray#VALfill&quot;&gt;&lt;code&gt;Bigarray.Genarray.fill&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9fc75d6ebb6ea7b34fae8807788459e575487d7" translate="yes" xml:space="preserve">
          <source>Finally, a phrase can also consist in a toplevel directive, starting with # (the sharp sign). These directives control the behavior of the toplevel; they are listed below in section &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f8b257b998bf370bb0864536531b33eb161b3e4" translate="yes" xml:space="preserve">
          <source>Finally, create a library containing all the compilation units, and export all the compiled interfaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d88cc7e5d915fe4d69c0be69de0f08fe1b0b62" translate="yes" xml:space="preserve">
          <source>Finally, if including the right headers is not enough, or if you need to support version older than OCaml 4.04, the header file caml/version.h should help you to define your own compatibility layer. This file provides few macros defining the current OCaml version. In particular, the OCAML_VERSION macro describes the current version, its format is MmmPP. For example, if you need some specific handling for versions older than 4.10.0, you could write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9372cdb14bc15de60bc5e7493ee69b5c137db75b" translate="yes" xml:space="preserve">
          <source>Finally, we gather several versions of the account into a module Account abstracted over some currency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad882b96aa31ea8bc7379f773276601fa589c285" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;group&lt;/code&gt; with the given group id, or raise &lt;code&gt;Not_found&lt;/code&gt; if the matching entry is not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d26059b49746e12250bbbdde11904eb0a2908b9" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;group&lt;/code&gt; with the given group id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="415672a50455cf18e72d28b263ffd7e70776bbce" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;group&lt;/code&gt; with the given name, or raise &lt;code&gt;Not_found&lt;/code&gt; if the matching entry is not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92938192f2f9c813f7a89a800c2c6c6ea821e47d" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;group&lt;/code&gt; with the given name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0dce113945863d2224b0beb1e150e7180b7e955" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;hosts&lt;/code&gt; with the given address, or raise &lt;code&gt;Not_found&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30ddd89ef5b82ec68bbf502dfb947c7b9bd0e70b" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;hosts&lt;/code&gt; with the given address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a3eb4a551ad19524b170ab21163001e6371bac" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;hosts&lt;/code&gt; with the given name, or raise &lt;code&gt;Not_found&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b86d33490f4cae6fae2da0fe5ecd27bc2fc74df" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;hosts&lt;/code&gt; with the given name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cc118e247a8d977a586a8aed063f755749a92c5" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;passwd&lt;/code&gt; with the given name, or raise &lt;code&gt;Not_found&lt;/code&gt; if the matching entry is not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2239e5756daa56658451b2b6060633b9a9cbe318" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;passwd&lt;/code&gt; with the given name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4956c4aaa9568df15a5e919f5fa7dbcb39bfe35" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;passwd&lt;/code&gt; with the given user id, or raise &lt;code&gt;Not_found&lt;/code&gt; if the matching entry is not found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc1c8ede71044655837ceea95734b149dfdb1446" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;passwd&lt;/code&gt; with the given user id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2491f8eb89441b7ffa07d073b5e5195dba3665c0" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;protocols&lt;/code&gt; with the given name, or raise &lt;code&gt;Not_found&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="325fdfe66274840cb9feff3f357702550e5e78f1" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;protocols&lt;/code&gt; with the given name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c982b244a847e041753c0f4d8e15cef7f19d9c" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;protocols&lt;/code&gt; with the given protocol number, or raise &lt;code&gt;Not_found&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47dd1860c6bae894b93ee4c1a2019df843e7ab0e" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;protocols&lt;/code&gt; with the given protocol number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa44dc4c834bf5ab60c686285de2c6235d10c301" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;services&lt;/code&gt; with the given name, or raise &lt;code&gt;Not_found&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d662695744400a189d48c36205ae8921c8e43f1" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;services&lt;/code&gt; with the given name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9c773c60870eda8ae407ffce7a213a96aeb9ce7" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;services&lt;/code&gt; with the given service number, or raise &lt;code&gt;Not_found&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711cd41753b69e36be6081e673e29c9bba5549ef" translate="yes" xml:space="preserve">
          <source>Find an entry in &lt;code&gt;services&lt;/code&gt; with the given service number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="224b0f27dd417f552000763b5bba3875baadfe82" translate="yes" xml:space="preserve">
          <source>First, types whose name starts with a $ are existentials.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de6dd7f2a65d07b376909c34498631be78cbdea7" translate="yes" xml:space="preserve">
          <source>First-class synchronous communication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6ff868642ca48eb4b81c33bcd5b9b519321189" translate="yes" xml:space="preserve">
          <source>First-in first-out queues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c38d1674ad0209e2429c06f4b4d86c81433a53" translate="yes" xml:space="preserve">
          <source>Flags for &lt;a href=&quot;unix#VALwaitpid&quot;&gt;&lt;code&gt;Unix.waitpid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91c7e7cca135a02bd447cc6e7d8f0122b119c272" translate="yes" xml:space="preserve">
          <source>Flags for &lt;a href=&quot;unixlabels#VALwaitpid&quot;&gt;&lt;code&gt;UnixLabels.waitpid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a84fb5772adecead6ba93384fad981b2515026b" translate="yes" xml:space="preserve">
          <source>Flags for the &lt;a href=&quot;unix#VALaccess&quot;&gt;&lt;code&gt;Unix.access&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04b5e36ad94721fdf773f89577544e40df649c7" translate="yes" xml:space="preserve">
          <source>Flags for the &lt;a href=&quot;unixlabels#VALaccess&quot;&gt;&lt;code&gt;UnixLabels.access&lt;/code&gt;&lt;/a&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fcd3d30dcc0ef0e2661f1baca5e3584ddbdad0c" translate="yes" xml:space="preserve">
          <source>Flambda aims to make it easier to write idiomatic OCaml code without incurring performance penalties.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8594db97e2953372022ef97b5a0aa23e010af265" translate="yes" xml:space="preserve">
          <source>Flambda does not yet optimise array or string bounds checks. Neither does it take hints for optimisation from any assertions written by the user in the code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f181cc9d2dc162d147e6a4c0a48c733ee687d31" translate="yes" xml:space="preserve">
          <source>Flambda operates in &lt;em&gt;rounds&lt;/em&gt;: one round consists of a certain sequence of transformations that may then be repeated in order to achieve more satisfactory results. The number of rounds can be set manually using the -rounds parameter (although this is not necessary when using predefined optimisation levels such as with -O2 and -O3). For high optimisation the number of rounds might be set at 3 or 4.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a5104c85ccca5769d7427f3784e8923de3f98aa" translate="yes" xml:space="preserve">
          <source>Flambda performs a simple analysis analogous to that performed elsewhere in the compiler that can transform refs into mutable variables that may then be held in registers (or on the stack as appropriate) rather than being allocated on the OCaml heap. This only happens so long as the reference concerned can be shown to not escape from its defining scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efb9d7aff651e52ca05571e619d1613ce6de9b63" translate="yes" xml:space="preserve">
          <source>Flambda provides full optimisation across different compilation units, so long as the .cmx files for the dependencies of the unit currently being compiled are available. (A compilation unit corresponds to a single .ml source file.) However it does not yet act entirely as a whole-program compiler: for example, elimination of dead code across a complete set of compilation units is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a889b00bf27975324866ab0b134e19b27ed12786" translate="yes" xml:space="preserve">
          <source>Flambda provides significantly enhanced inlining capabilities relative to previous versions of the compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61063e2e8cd24e333286a73b0688eea6bacd5de4" translate="yes" xml:space="preserve">
          <source>Flambda should not in general affect the semantics of existing programs. Two exceptions to this rule are: possible elimination of pure code that is being benchmarked (see section &lt;a href=&quot;#s%3Aflambda-inhibition&quot;&gt;21.14&lt;/a&gt;) and changes in behaviour of code using unsafe operations (see section &lt;a href=&quot;#s%3Aflambda-unsafe&quot;&gt;21.15&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="219d126ce0d3a407f2d7b93cc5f4b89615a19194" translate="yes" xml:space="preserve">
          <source>Flambda-specific flags are silently accepted even when the -flambda option was not provided to the configure script. (There is no means provided to change this behaviour.) This is intended to make it more straightforward to run benchmarks with and without the Flambda optimisers in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef48c1926ca51bd2de8c60212500cb953953e6a1" translate="yes" xml:space="preserve">
          <source>Flambda-specific flags do not affect linking with the exception of affecting the optimisation of code in the startup file (containing generated functions such as currying helpers). Typically such optimisation will not be significant, so eliding such flags at link time might be reasonable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64435fd82de7b1d614dfb9844848a48b14c6cd2c" translate="yes" xml:space="preserve">
          <source>Float</source>
          <target state="translated">Float</target>
        </trans-unit>
        <trans-unit id="6ffeb4861d9e563d23963be8720e425492dd6b6d" translate="yes" xml:space="preserve">
          <source>Float arrays are unboxed in OCaml, however the C function foo expect its arguments as boxed floats and returns a boxed float. Hence the OCaml compiler has no choice but to box a.(i) and b.(i) and unbox the result of foo. This results in the allocation of 3 * len temporary float values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a46defc33b52ea1fd99787071741a560caaf453" translate="yes" xml:space="preserve">
          <source>Floating-point addition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e8ad1ad83559c0c5808e64187ad5bb46bccbb8" translate="yes" xml:space="preserve">
          <source>Floating-point addition. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5548b469c373345d73eac57637c80c81b15b6bd5" translate="yes" xml:space="preserve">
          <source>Floating-point arithmetic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82bbccf62a08df179a146bbe466cb94a3dbaa8e5" translate="yes" xml:space="preserve">
          <source>Floating-point decimal literals consist in an integer part, a fractional part and an exponent part. The integer part is a sequence of one or more digits, optionally preceded by a minus sign. The fractional part is a decimal point followed by zero, one or more digits. The exponent part is the character e or E followed by an optional + or - sign, followed by one or more digits. It is interpreted as a power of 10. The fractional part or the exponent part can be omitted but not both, to avoid ambiguity with integer literals. The interpretation of floating-point literals that fall outside the range of representable floating-point values is undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16456ba987f358b0776a485f82949a05fc38ee78" translate="yes" xml:space="preserve">
          <source>Floating-point division.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="118ec0967c6c4699de4c4f7b7fda2a6e7b561167" translate="yes" xml:space="preserve">
          <source>Floating-point division. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ede89b6074416fcf7162abe3bb4236d8bee181aa" translate="yes" xml:space="preserve">
          <source>Floating-point exponentiation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc9d81781f770a9fc1d9a06be148d35f363d87c" translate="yes" xml:space="preserve">
          <source>Floating-point hexadecimal literals are denoted with the 0x or 0X prefix. The syntax is similar to that of floating-point decimal literals, with the following differences. The integer part and the fractional part use hexadecimal digits. The exponent part starts with the character p or P. It is written in decimal and interpreted as a power of 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e5d932dc924f91fa346a44f4dc03694cd49183a" translate="yes" xml:space="preserve">
          <source>Floating-point multiplication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b556a86592a9630ea4fbca18c7d08e9fc3c949d9" translate="yes" xml:space="preserve">
          <source>Floating-point multiplication. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1149ab45a20d6e882aa6782cb72e44b70e97f03" translate="yes" xml:space="preserve">
          <source>Floating-point negation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73f034cf9e5de13353e55867f163be1f87c7d920" translate="yes" xml:space="preserve">
          <source>Floating-point subtraction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7e0c17deed8b8d3fb7e4c7f3f78d69fa0c9040" translate="yes" xml:space="preserve">
          <source>Floating-point subtraction. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df61acf8521b8784a6eac17abf66a88f13856f14" translate="yes" xml:space="preserve">
          <source>Floating-point values are numbers in floating-point representation. The current implementation uses double-precision floating-point numbers conforming to the IEEE 754 standard, with 53 bits of mantissa and an exponent ranging from &amp;minus;1022 to 1023.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b4ec19158158ac7f6dbb77dc432e2d531582f9" translate="yes" xml:space="preserve">
          <source>Flush all open output channels; ignore errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b5f8a08a46ed12d56a1e210ad48361645fed373" translate="yes" xml:space="preserve">
          <source>Flush file buffers to disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23c758f9a0907444c6837d8b7f0fb71eaee1124e" translate="yes" xml:space="preserve">
          <source>Flush standard output, then read characters from standard input until a newline character is encountered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f82045180a47247f213825886ff12b05d6ecc9" translate="yes" xml:space="preserve">
          <source>Flush standard output, then read characters from standard input until a newline character is encountered. Return the string of all characters read, without the newline character at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbd185b6d4bbe3f64d1306999887965c95045eef" translate="yes" xml:space="preserve">
          <source>Flush standard output, then read one line from standard input and convert it to a floating-point number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f1a6e603eff2a865514ec6cd7588b58a57b5c3" translate="yes" xml:space="preserve">
          <source>Flush standard output, then read one line from standard input and convert it to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="560c3ecff79a18ab3e691bb4c8af82a10b26ee5d" translate="yes" xml:space="preserve">
          <source>Flush the buffer associated with the given output channel, performing all pending writes on that channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b26c6acfdd5ca2fd64e7704f6ddb8ef3f40e2eb" translate="yes" xml:space="preserve">
          <source>Flush the buffer associated with the given output channel, performing all pending writes on that channel. Interactive programs must be careful about flushing standard output and standard error at the right time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="becd01c004b1c1adc714fa5f5a61b400195543a6" translate="yes" xml:space="preserve">
          <source>Following a function application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1486f893b1fa18a37d5aac444c9bb86be10dc16e" translate="yes" xml:space="preserve">
          <source>Following the &lt;code&gt;%&lt;/code&gt; character that introduces a conversion, there may be the special flag &lt;code&gt;_&lt;/code&gt;: the conversion that follows occurs as usual, but the resulting value is discarded. For instance, if &lt;code&gt;f&lt;/code&gt; is the function &lt;code&gt;fun&amp;nbsp;i&amp;nbsp;-&amp;gt;&amp;nbsp;i&amp;nbsp;+&amp;nbsp;1&lt;/code&gt;, and &lt;code&gt;s&lt;/code&gt; is the string &lt;code&gt;&quot;x&amp;nbsp;=&amp;nbsp;1&quot;&lt;/code&gt;, then &lt;code&gt;Scanf.sscanf&amp;nbsp;s&amp;nbsp;&quot;%_s&amp;nbsp;=&amp;nbsp;%i&quot;&amp;nbsp;f&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a590e523ffcfaed89183301d6dd22ee5be58604e" translate="yes" xml:space="preserve">
          <source>For a gentle introduction to the basics of pretty-printing using &lt;code&gt;Format&lt;/code&gt;, read &lt;a href=&quot;http://caml.inria.fr/resources/doc/guides/format.en.html&quot;&gt; http://caml.inria.fr/resources/doc/guides/format.en.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9fce93886551abb9ce788db94f91b9982821506" translate="yes" xml:space="preserve">
          <source>For a program with an extended running time where the collection of only a small sample of events is required, using the &lt;em&gt;eventlog_resume&lt;/em&gt; and &lt;em&gt;eventlog_pause&lt;/em&gt; primitives may help relieve some of the tracing induced performance impact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d15720a480acc3d4e8c66981b163dda12c3ec8be" translate="yes" xml:space="preserve">
          <source>For compatibility with previous releases, ocamlcp also accepts the -p option, with the same arguments and behaviour as -P.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d87cc1fd5174e33b97151dfeeb14c60cfa60df82" translate="yes" xml:space="preserve">
          <source>For compatibility with toplevel phrases (chapter &lt;a href=&quot;toplevel#c%3Acamllight&quot;&gt;10&lt;/a&gt;), optional ;; are allowed after and before each definition in a structure. These ;; have no semantic meanings. Similarly, an &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; preceded by ;; is allowed as a component of a structure. It is equivalent to let_=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;, i.e. &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; is evaluated for its side-effects but is not bound to any identifier. If &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; is the first component of a structure, the preceding ;; can be omitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5a74d2294717e9f00b62a89200b1ae35d6a075" translate="yes" xml:space="preserve">
          <source>For convenicence, when all arguments and the result are annotated with [@unboxed], it is possible to put the attribute only once on the declaration itself. So we can also write instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="536cfe27f79288497ed369a6675bd6604800b397" translate="yes" xml:space="preserve">
          <source>For convenience and readability, underscore characters (_) are accepted (and ignored) within floating-point literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be43f583e22841e0ae2a3b643c27e327a6714b66" translate="yes" xml:space="preserve">
          <source>For convenience and readability, underscore characters (_) are accepted (and ignored) within integer literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="838d471f3710333420afe459f6352b41b3ee184b" translate="yes" xml:space="preserve">
          <source>For directives that take file names as arguments, if the given file name specifies no directory, the file is searched in the following directories:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93af2f267be6958b0eb68cd4c18a340833d38fe2" translate="yes" xml:space="preserve">
          <source>For easy reference, the modules are listed below in alphabetical order of module names. For each module, the declarations from its signature are printed one by one in typewriter font, followed by a short comment. All modules and the identifiers they export are indexed at the end of this report.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68c41afc8eaf8ac4f5e1db0cdcc821f1a67ead25" translate="yes" xml:space="preserve">
          <source>For example given the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c9f97659bbc1005f4870ae62bce8f4807d2d04" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;find_first&amp;nbsp;(fun&amp;nbsp;e&amp;nbsp;-&amp;gt;&amp;nbsp;Ord.compare&amp;nbsp;e&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0)&amp;nbsp;s&lt;/code&gt; will return the first element &lt;code&gt;e&lt;/code&gt; of &lt;code&gt;s&lt;/code&gt; where &lt;code&gt;Ord.compare&amp;nbsp;e&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; (intuitively: &lt;code&gt;e&amp;nbsp;&amp;gt;=&amp;nbsp;x&lt;/code&gt;), or raise &lt;code&gt;Not_found&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is greater than any element of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00ef4fa9fc5360d62b1c94aa516c65ad36494ff8" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;find_first&amp;nbsp;(fun&amp;nbsp;k&amp;nbsp;-&amp;gt;&amp;nbsp;Ord.compare&amp;nbsp;k&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0)&amp;nbsp;m&lt;/code&gt; will return the first binding &lt;code&gt;k,&amp;nbsp;v&lt;/code&gt; of &lt;code&gt;m&lt;/code&gt; where &lt;code&gt;Ord.compare&amp;nbsp;k&amp;nbsp;x&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; (intuitively: &lt;code&gt;k&amp;nbsp;&amp;gt;=&amp;nbsp;x&lt;/code&gt;), or raise &lt;code&gt;Not_found&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is greater than any element of &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa7ea3a77b2622ee6a146e8cc0a886c6052f7d06" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;unfold&amp;nbsp;(function&amp;nbsp;[]&amp;nbsp;-&amp;gt;&amp;nbsp;None&amp;nbsp;|&amp;nbsp;h::t&amp;nbsp;-&amp;gt;&amp;nbsp;Some&amp;nbsp;(h,t))&amp;nbsp;l&lt;/code&gt; is equivalent to &lt;code&gt;List.to_seq&amp;nbsp;l&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8681ad0bc326c2d10abfd81e1d8d51f3f545e5ec" translate="yes" xml:space="preserve">
          <source>For example, on a 32-bit machine, under bash the command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="584aecfa53603994f1cf6a98815016088d92742e" translate="yes" xml:space="preserve">
          <source>For example, string literals are implicitly shared by the compiler, so you never uniquely own them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75ec36932e874a0857807a9a9cf34d66fdff1115" translate="yes" xml:space="preserve">
          <source>For example, the following function on maps whose values are lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07ee358d5cb6c26c5c1a633d2d3ce795afcd785" translate="yes" xml:space="preserve">
          <source>For experts only: &lt;code&gt;set_field&lt;/code&gt; et al can be made safe by first wrapping the block in &lt;a href=&quot;sys#VALopaque_identity&quot;&gt;&lt;code&gt;Sys.opaque_identity&lt;/code&gt;&lt;/a&gt;, so any information about its contents will not be propagated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f54deaf4ec2c70a7011f50eff9d2285fdad7e767" translate="yes" xml:space="preserve">
          <source>For functions to decode the information recorded by the profiler, see the Spacetime offline library in otherlibs/.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="070398a78bcfebe5c401a9687fd0dd0a09274ac7" translate="yes" xml:space="preserve">
          <source>For instance let&amp;rsquo;s consider this example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23b7041567e33cbc564ac905e83c0e92b5fee08b" translate="yes" xml:space="preserve">
          <source>For instance,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ec0bc79713c604935cc8be72edeaf053af246af" translate="yes" xml:space="preserve">
          <source>For instance, &lt;code&gt;(float,&amp;nbsp;float32_elt,&amp;nbsp;fortran_layout)&amp;nbsp;Genarray.t&lt;/code&gt; is the type of generic Bigarrays containing 32-bit floats in Fortran layout; reads and writes in this array use the OCaml type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="483a4414986412b8b6120205236d6d13002c06a3" translate="yes" xml:space="preserve">
          <source>For instance, &lt;code&gt;Genarray.create&amp;nbsp;int32&amp;nbsp;c_layout&amp;nbsp;[|4;6;8|]&lt;/code&gt; returns a fresh Bigarray of 32-bit integers, in C layout, having three dimensions, the three dimensions being 4, 6 and 8 respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53f092886c491eb1e8ce0e4ca3d4d961ae0d2d09" translate="yes" xml:space="preserve">
          <source>For instance, a module can be constrained when opened with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0f95c0ca2f0669635f59d67f76dce1ba345c8a8" translate="yes" xml:space="preserve">
          <source>For instance, compiling with ocamlcp -P film profiles function calls, if&amp;hellip;then&amp;hellip;else&amp;hellip;, loops and pattern matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62237974c29e3d511bf080a9b8f7425ffcc10235" translate="yes" xml:space="preserve">
          <source>For instance, given a &lt;a href=&quot;buffer#TYPEt&quot;&gt;&lt;code&gt;Buffer.t&lt;/code&gt;&lt;/a&gt; buffer &lt;code&gt;b&lt;/code&gt;, &lt;a href=&quot;format#VALformatter_of_buffer&quot;&gt;&lt;code&gt;Format.formatter_of_buffer&lt;/code&gt;&lt;/a&gt;&lt;code&gt;b&lt;/code&gt; returns a new formatter using buffer &lt;code&gt;b&lt;/code&gt; as its output device. Similarly, given a &lt;a href=&quot;stdlib#TYPEout_channel&quot;&gt;&lt;code&gt;out_channel&lt;/code&gt;&lt;/a&gt; output channel &lt;code&gt;oc&lt;/code&gt;, &lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt;&lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt;&lt;/a&gt;&lt;code&gt;oc&lt;/code&gt; returns a new formatter using channel &lt;code&gt;oc&lt;/code&gt; as its output device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e374315bd8271c505be4e5174fd509da4383f5" translate="yes" xml:space="preserve">
          <source>For instance, if &lt;code&gt;f&lt;/code&gt; is the function &lt;code&gt;fun&amp;nbsp;s&amp;nbsp;i&amp;nbsp;-&amp;gt;&amp;nbsp;i&amp;nbsp;+&amp;nbsp;1&lt;/code&gt;, then &lt;code&gt;Scanf.sscanf&amp;nbsp;&quot;x=&amp;nbsp;1&quot;&amp;nbsp;&quot;%s&amp;nbsp;=&amp;nbsp;%i&quot;&amp;nbsp;f&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88ada3238f384f9a83a9a0095d4afa6a65d12f78" translate="yes" xml:space="preserve">
          <source>For instance, if the module type name S is bound to the signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="313fce915b91c1b76f4ab6d75d2a8fd584e24576" translate="yes" xml:space="preserve">
          <source>For instance, if you are allocating a finalized block holding an X Windows bitmap of w by h pixels, and you&amp;rsquo;d rather not have more than 1 mega-pixels of unreclaimed bitmaps, specify used = w * h and max = 1000000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa39538e599aa28212b48c635f444fbb356477cb" translate="yes" xml:space="preserve">
          <source>For instance, in ('a' as x) | ( 'a' (_ as x) ) the variable x is of type char, whereas in (&quot;ab&quot; as x) | ( 'a' (_ as x) ? ) the variable x is of type string option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c8e2bf323177696f201e4d65a89fe9a6376e58c" translate="yes" xml:space="preserve">
          <source>For instance, in the case of add_nat, the declaration is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e031fb5cea37ca6a741ad15e3c21518c5b98ed" translate="yes" xml:space="preserve">
          <source>For instance, one might want to specialize a table for integer keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec3b52fde3e16586ca37ede9c046fc9f0a2cf0ce" translate="yes" xml:space="preserve">
          <source>For instance, rather than redefining caml_young_limit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c4a72ef20876d65a567d804865d99313488768" translate="yes" xml:space="preserve">
          <source>For instance, the &lt;a href=&quot;scanf#VALscanf&quot;&gt;&lt;code&gt;Scanf.scanf&lt;/code&gt;&lt;/a&gt; function below has type &lt;code&gt;('a,&amp;nbsp;'b,&amp;nbsp;'c,&amp;nbsp;'d)&amp;nbsp;scanner&lt;/code&gt;, since it is a formatted input function that reads from &lt;a href=&quot;scanf.scanning#VALstdin&quot;&gt;&lt;code&gt;Scanf.Scanning.stdin&lt;/code&gt;&lt;/a&gt;: &lt;code&gt;scanf&amp;nbsp;fmt&amp;nbsp;f&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; to the arguments specified by &lt;code&gt;fmt&lt;/code&gt;, reading those arguments from &lt;a href=&quot;stdlib#VALstdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt; as expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79fda01c9ead474ffcd0f48c1cb8618d654db68" translate="yes" xml:space="preserve">
          <source>For instance, the sequence &lt;code&gt;open_box&amp;nbsp;0;&amp;nbsp;print_string&amp;nbsp;&quot;x&amp;nbsp;=&quot;;&amp;nbsp;print_space&amp;nbsp;();&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print_int&amp;nbsp;1;&amp;nbsp;close_box&amp;nbsp;();&amp;nbsp;print_newline&amp;nbsp;()&lt;/code&gt; that prints &lt;code&gt;x&amp;nbsp;=&amp;nbsp;1&lt;/code&gt; within a pretty-printing box, can be abbreviated as &lt;code&gt;printf&amp;nbsp;&quot;@[%s@&amp;nbsp;%i@]@.&quot;&amp;nbsp;&quot;x&amp;nbsp;=&quot;&amp;nbsp;1&lt;/code&gt;, or even shorter &lt;code&gt;printf&amp;nbsp;&quot;@[x&amp;nbsp;=@&amp;nbsp;%i@]@.&quot;&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="512b11c86beb8f337cea3cd6a56846b5135a314c" translate="yes" xml:space="preserve">
          <source>For instance, type +'a t declares t as an abstract type that is covariant in its parameter; this means that if the type &amp;tau; is a subtype of the type &amp;sigma;, then &amp;tau;  t is a subtype of &amp;sigma;  t. Similarly, type -'a t declares that the abstract type t is contravariant in its parameter: if &amp;tau; is a subtype of &amp;sigma;, then &amp;sigma;  t is a subtype of &amp;tau;  t. If no + or - variance annotation is given, the type constructor is assumed non-variant in the corresponding parameter. For instance, the abstract type declaration type 'a t means that &amp;tau;  t is neither a subtype nor a supertype of &amp;sigma;  t if &amp;tau; is subtype of &amp;sigma;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f9a2d4de3a321ed1ced899fb52be83e582b336c" translate="yes" xml:space="preserve">
          <source>For instance, you can use {%sql|...|} to represent arbitrary SQL statements &amp;ndash; assuming you have a ppx-rewriter that recognizes the %sql extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06f4a1629e356fbed3dca17ffbbc00b47ee8f6a" translate="yes" xml:space="preserve">
          <source>For interactive use of the bigarray compatibility library, do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f35fd96a6a5a2ac581557d5abe5d3d602ccdd36" translate="yes" xml:space="preserve">
          <source>For interactive use of the compiler-libs library, start ocaml and type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c316cf9a16e0fa7fc1229baa23a24494a5548cb8" translate="yes" xml:space="preserve">
          <source>For interactive use of the str library, do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="699e3e7671ce8003396b2ad0dfb9479eb8a59585" translate="yes" xml:space="preserve">
          <source>For interactive use of the unix library, do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aab7d183ac64c6f5627d01cb1a929c8a0cc3c3d8" translate="yes" xml:space="preserve">
          <source>For let, the attributes are applied to each bindings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dde1e7361b04b1aa4b5279b99eac062b8cfc93f4" translate="yes" xml:space="preserve">
          <source>For lists, some syntactic sugar is provided. The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;::&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; stands for the constructor (::) applied to the arguments (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;,&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;), and therefore evaluates to the list whose head is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and whose tail is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. The expression [&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] is equivalent to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:: &amp;hellip; ::&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;::[], and therefore evaluates to the list whose elements are the values of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a86e99ce6f9ce032dc05c5a6a2ecf3f7ba6b26" translate="yes" xml:space="preserve">
          <source>For more information about &lt;em&gt;eventlog-tools&lt;/em&gt;, refer to the project&amp;rsquo;s main page: &lt;a href=&quot;https://github.com/ocaml-multicore/eventlog-tools&quot;&gt;https://github.com/ocaml-multicore/eventlog-tools&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3fdaa3af3a3833df037c917261156243c0a3426" translate="yes" xml:space="preserve">
          <source>For more information about conversion specifications and formatting indications available, read the documentation of modules &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c98a7299a1e114d6c8fcd25e0f9ad620f2b15437" translate="yes" xml:space="preserve">
          <source>For more information on &lt;em&gt;babeltrace&lt;/em&gt;, see the website at: &lt;a href=&quot;https://babeltrace.org/&quot;&gt;https://babeltrace.org/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eded1ae5f4e85162d085a1067ff14d61f49ceb5d" translate="yes" xml:space="preserve">
          <source>For more information on afl-fuzz, see the website at &lt;a href=&quot;http://lcamtuf.coredump.cx/afl/&quot;&gt;http://lcamtuf.coredump.cx/afl/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e368ef71e03b57e9465a3c040880f0c3f8f7488" translate="yes" xml:space="preserve">
          <source>For more information on the &lt;em&gt;Common Trace Format&lt;/em&gt;, see &lt;a href=&quot;https://diamon.org/ctf/&quot;&gt;https://diamon.org/ctf/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6047f289f64afe60d156adbc2d91f375cf39e18f" translate="yes" xml:space="preserve">
          <source>For more information, see the description of module Lazy in the standard library (module &lt;a href=&quot;libref/lazy&quot;&gt;Lazy&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4464097eb1cea9b9bac89b09a00caecac51a81" translate="yes" xml:space="preserve">
          <source>For patterns, local opens are limited to the &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.(&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;) construction. This construction locally opens the module referred to by the module path &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; in the scope of the pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef2b59d23fff41131044485051539866a8c3ac8" translate="yes" xml:space="preserve">
          <source>For pointers that are at least 2-aligned (the low bit is guaranteed to be zero), we have yet another valid representation as an OCaml tagged integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73f3879c76d10b585df3a2eafc7157a6760d3bbd" translate="yes" xml:space="preserve">
          <source>For recursive functions the relevant attributes are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ebf1588f6cdfdc9ffed9431d4da1f119970c3bc" translate="yes" xml:space="preserve">
          <source>For scripting purpose, matching against &amp;lsquo;{PID}&amp;lsquo;, as well as the .eventlog file extension should provide enough control over the generated files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d009d07e3cdd357f1da6c6c41490e4b69ddef46" translate="yes" xml:space="preserve">
          <source>For small functions that are called repeatedly, this indirection can have a big impact on performances. However this is not needed if we know that the C function doesn&amp;rsquo;t allocate, doesn&amp;rsquo;t raise exceptions, and doesn&amp;rsquo;t release the master lock (see section &lt;a href=&quot;#ss%3Aparallel-execution-long-running-c-code&quot;&gt;20.12.2&lt;/a&gt;). We can instruct the OCaml native-code compiler of this fact by annotating the external declaration with the attribute [@@noalloc]:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e528ec5a4e42d84e77d36a471eae26958b074f6" translate="yes" xml:space="preserve">
          <source>For specifying a module component that is a functor, one may write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c50a9c50ed7f2e407b8a69772825eb202f692f" translate="yes" xml:space="preserve">
          <source>For the final linking phase, in addition to the object file produced by -output-obj, you will have to provide the OCaml runtime library (libcamlrun.a for bytecode, libasmrun.a for native-code), as well as all C libraries that are required by the OCaml libraries used. For instance, assume the OCaml part of your program uses the Unix library. With ocamlc, you should do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7da283fed0922afd4ea51a82bd3ebbaecf48b3da" translate="yes" xml:space="preserve">
          <source>For the following examples, we will use the following example program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8462057be99ab190b24cbcda3c885f2c8e84c711" translate="yes" xml:space="preserve">
          <source>For the following files, do not include delayed dependencies for module aliases. This option assumes that they are compiled using options -no-alias-deps -w -49, and that those files or their interface are passed with the -map option when computing dependencies for other files. Note also that for dependencies to be correct in the implementation of a map file, its interface should not coerce any of the aliases it contains.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34193bb871e307746e89150d6b73785a0ab6119" translate="yes" xml:space="preserve">
          <source>For the majority of installations the native toplevel will not have been installed along with the rest of the OCaml toolchain. In such circumstances it will be necessary to build the OCaml distribution from source. From the built source tree of the distribution you may use make natruntop to build and execute a native toplevel. (Alternatively make ocamlnat can be used, which just performs the build step.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ea68bef1bfd3292b6bb1895b9e027db0dba7842" translate="yes" xml:space="preserve">
          <source>For the printing function, we take into account the usual precedence rules (i.e. * binds tighter than +) to avoid printing unnecessary parentheses. To this end, we maintain the current operator precedence and print parentheses around an operator only if its precedence is less than the current precedence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51b39efa922285a3273b661042d8cdef22ef9a84" translate="yes" xml:space="preserve">
          <source>For the purposes of optimization, &lt;code&gt;opaque_identity&lt;/code&gt; behaves like an unknown (and thus possibly side-effecting) function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e267fe9f8c40f023788aff73390761c297ce2ff" translate="yes" xml:space="preserve">
          <source>For the user to be able to specify anonymous arguments starting with a &lt;code&gt;-&lt;/code&gt;, include for example &lt;code&gt;(&quot;-&quot;,&amp;nbsp;String&amp;nbsp;anon_fun,&amp;nbsp;doc)&lt;/code&gt; in &lt;code&gt;speclist&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19c1a10da802041b9fb470f3102a59cc151979bc" translate="yes" xml:space="preserve">
          <source>For this overview of OCaml, we use the interactive system, which is started by running ocaml from the Unix shell, or by launching the OCamlwin.exe application under Windows. This tutorial is presented as the transcript of a session with the interactive system: lines starting with # represent user input; the system responses are printed below, without a leading #.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a580402e4ad9306e87473671cf0faf7d2f7ab1a" translate="yes" xml:space="preserve">
          <source>For this reason, you must be more careful about making types explicit when you use polymorphic variants. When you write a library, this is easy since you can describe exact types in interfaces, but for simple programs you are probably better off with core language variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af957d60ed570105b0b392af1c056d6167910718" translate="yes" xml:space="preserve">
          <source>For type-checking purposes (and starting from OCaml 4.02), package types are compared using the structural comparison of module types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34f5bb35507ceece551d8584537a151ed8d0b764" translate="yes" xml:space="preserve">
          <source>For user-defined types, the variance is automatically inferred: a parameter is covariant if it has only covariant occurrences, contravariant if it has only contravariant occurrences, variance-free if it has no occurrences, and nonvariant otherwise. A variance-free parameter may change freely through subtyping, it does not have to be a subtype or a supertype. For abstract and private types, the variance must be given explicitly (see section &lt;a href=&quot;typedecl#ss%3Atypedefs&quot;&gt;7.8.1&lt;/a&gt;), otherwise the default is nonvariant. This is also the case for constrained arguments in type definitions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6424726f5a111f674b5264a50bb99313ad270bad" translate="yes" xml:space="preserve">
          <source>Forbid binding an IPv6 socket to an IPv4 address</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cb81eb5ee90252463cf66685d1856591ccc439a" translate="yes" xml:space="preserve">
          <source>Force a new line in the current pretty-printing box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="125afb80bbeb391648654a9060fd49b75954e783" translate="yes" xml:space="preserve">
          <source>Force all modules contained in libraries to be linked in. If this flag is not given, unreferenced modules are not linked in. When building a library (option -a), setting the -linkall option forces all subsequent links of programs involving that library to link all the modules contained in the library. When compiling a module (option -c), setting the -linkall option ensures that this module will always be linked if it is put in a library and this library is linked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="035f3fa8787b038845df69761d559e46584335ee" translate="yes" xml:space="preserve">
          <source>Force error messages to show absolute paths for file names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b18cad2a21c9b98f70be09ebac9958393c7c0edc" translate="yes" xml:space="preserve">
          <source>Force the construction of a statically linked library only, even if dynamic linking is supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46882fa3a62ce5fc4e4b0d025aabceb392c26854" translate="yes" xml:space="preserve">
          <source>Force the left-hand part of each sequence to have type unit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a683f099c5cd32d972be2f3a92f5a845ceb5fd5" translate="yes" xml:space="preserve">
          <source>Foreword</source>
          <target state="translated">Foreword</target>
        </trans-unit>
        <trans-unit id="304eeec5641ac1e5522186b7555dcdb91736d26d" translate="yes" xml:space="preserve">
          <source>Fork a new process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="236e1aa20d58ae0da8f5448ac108dbc6e91a6c14" translate="yes" xml:space="preserve">
          <source>Fork a new process. The returned integer is 0 for the child process, the pid of the child process for the parent process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a98756856d684441ecaf6f9fd69f196389c0e67" translate="yes" xml:space="preserve">
          <source>Formal parameters and arguments are matched according to their respective labels&lt;sup&gt;&lt;a href=&quot;#note1&quot; id=&quot;text1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, the absence of label being interpreted as the empty label. This allows commuting arguments in applications. One can also partially apply a function on any argument, creating a new function of the remaining parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58a23074c162bcd840e8739dd410d344b7804635" translate="yes" xml:space="preserve">
          <source>Formally, an estimate of runtime performance benefit is computed by first summing the cost of the operations that are known to be removed as a result of the inlining and subsequent simplification of the inlined body. The individual costs for the various kinds of operations may be adjusted using the various -inline-...-cost flags as follows. Costs are specified as integers. All of these flags accept a single argument describing such integers using the conventions detailed in section &lt;a href=&quot;#ss%3Aflambda-rounds&quot;&gt;21.2.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="cd766e4c3a23f7c2da8587cebfb482091c1dccb5" translate="yes" xml:space="preserve">
          <source>Format string description</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb420b10080f1dd9257bcd67f1d8aee25cf5a4f3" translate="yes" xml:space="preserve">
          <source>Format strings are character strings with special lexical conventions that defines the functionality of formatted input/output functions. Format strings are used to read data with formatted input functions from module &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; and to print data with formatted output functions from modules &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c62c8f7675da4c277f6225623ec0c47dda029d6d" translate="yes" xml:space="preserve">
          <source>Format strings are made of three kinds of entities:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06a845dc5cb646f90245c5fc3022aea03416143" translate="yes" xml:space="preserve">
          <source>Format strings have a general and highly polymorphic type &lt;code&gt;('a,&amp;nbsp;'b,&amp;nbsp;'c,&amp;nbsp;'d,&amp;nbsp;'e,&amp;nbsp;'f)&amp;nbsp;format6&lt;/code&gt;. The two simplified types, &lt;code&gt;format&lt;/code&gt; and &lt;code&gt;format4&lt;/code&gt; below are included for backward compatibility with earlier releases of OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="252c8b72c38b953722001b0d7e1faa8cdee47d48" translate="yes" xml:space="preserve">
          <source>Formatted Pretty-Printing with continuations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a2d3f703bd5b043248ec990cc1f4c5007ff3f0e" translate="yes" xml:space="preserve">
          <source>Formatted input as a functional feature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77bd2d9934254f11979d82347140567c1ddb102e" translate="yes" xml:space="preserve">
          <source>Formatted input channel</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be2d12d3c9bb417bd5c2c00ad2a7d80739b67fe6" translate="yes" xml:space="preserve">
          <source>Formatted input functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2c32e9b045d340dc3d1db20b06b3312b9dffe7" translate="yes" xml:space="preserve">
          <source>Formatted output functions with continuations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711a36aaf3243301d4bdbe36c688f9d583325bf4" translate="yes" xml:space="preserve">
          <source>Formatted output functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3ced1470e4fb0a82a21db25542a6f1c80d4639" translate="yes" xml:space="preserve">
          <source>Formatted pretty-printing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51b052e6b6929080b4b2c0e3ee6499327d38158" translate="yes" xml:space="preserve">
          <source>Formatting functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b31bab41071c2ba216bb20fa4ecdf43ff5be0ae1" translate="yes" xml:space="preserve">
          <source>Fragile constant pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733886e0c1a7b21f20a0e73b04dc5e1666cb2517" translate="yes" xml:space="preserve">
          <source>Fragile pattern matching: matching that will remain complete even if additional constructors are added to one of the variant types matched.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="103d90d5cbdf56cc8c46155df2e012b9e7f0d6e6" translate="yes" xml:space="preserve">
          <source>Freeing the memory blocks that were allocated by the runtime with malloc. Inside C primitives, it is advised to use caml_stat_* functions from memory.h for managing static (that is, non-moving) blocks of heap memory, as all the blocks allocated with these functions are automatically freed by caml_shutdown. For ensuring compatibility with legacy C stubs that have used caml_stat_* incorrectly, this behaviour is only enabled if the runtime is started with a specialized caml_startup_pooled function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="381e8105b7f65611bdbccad4e376930184ddb809" translate="yes" xml:space="preserve">
          <source>From the point of view of the writer of C stubs, the challenges of interacting with Windows Unicode APIs are twofold:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5006d76ef1ff0edee9bb268edecad3b64ee9a5fb" translate="yes" xml:space="preserve">
          <source>From the standpoint of the allocation functions, blocks are divided according to their size as zero-sized blocks, small blocks (with size less than or equal to &lt;code&gt;Max_young_wosize&lt;/code&gt;), and large blocks (with size greater than &lt;code&gt;Max_young_wosize&lt;/code&gt;). The constant &lt;code&gt;Max_young_wosize&lt;/code&gt; is declared in the include file mlvalues.h. It is guaranteed to be at least 64 (words), so that any block with constant size less than or equal to 64 can be assumed to be small. For blocks whose size is computed at run-time, the size must be compared against &lt;code&gt;Max_young_wosize&lt;/code&gt; to determine the correct allocation procedure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56fb6077bdf4f3c5cdb464d60eaad6a7f0d65be3" translate="yes" xml:space="preserve">
          <source>Full specifications of variant tags are only used for non-exact closed types. They can be understood as a conjunctive type for the argument: it is intended to have all the types enumerated in the specification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f941ab65fbabe87f41cd73c9136f5a4c97087e8" translate="yes" xml:space="preserve">
          <source>Fun</source>
          <target state="translated">Fun</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="f13929b48377daed175f9b82a9945ecfe03b8a18" translate="yes" xml:space="preserve">
          <source>Function application is denoted by juxtaposition of (possibly labeled) expressions. The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; evaluates the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; and those appearing in &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; must evaluate to a functional value f, which is then applied to the values of &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f41d8a2104aaa68d4125738c3fccd8fde3ee5b3" translate="yes" xml:space="preserve">
          <source>Function interrupted by signal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2c76e1ede161471ccd802e477febd466535fb41" translate="yes" xml:space="preserve">
          <source>Function manipulation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc8a59f44f5ba9847650733c0cafd473c4eed11f" translate="yes" xml:space="preserve">
          <source>Function not supported</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ef8a9128beb0af02eff674dd02f5540cdf4c052" translate="yes" xml:space="preserve">
          <source>Functional Iterators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13fe4e6e39b49747e662e4d40927c17b0001a35e" translate="yes" xml:space="preserve">
          <source>Functional input with format strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0c0cf6a585e5822f9daed0b884effec99c37c70" translate="yes" xml:space="preserve">
          <source>Functional update is often used in conjunction with binary methods as illustrated in section &lt;a href=&quot;advexamples#ss%3Astring-as-class&quot;&gt;6.2.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994ce6abbd94a0acd9b9688ad57d717223e20bb2" translate="yes" xml:space="preserve">
          <source>Functional values are mappings from values to values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="594192b50b04507e237e1cfb87230a7ae4c1d67b" translate="yes" xml:space="preserve">
          <source>Functions for lexer semantic actions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c55c9cbdceda57907c400a338a436f167c64fd5" translate="yes" xml:space="preserve">
          <source>Functions in &lt;code&gt;spec&lt;/code&gt; or &lt;code&gt;anon_fun&lt;/code&gt; can raise &lt;code&gt;Arg.Bad&lt;/code&gt; with an error message to reject invalid arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8248c90bba77a29916a1cdfddf8e3aba54354454" translate="yes" xml:space="preserve">
          <source>Functions in &lt;code&gt;spec&lt;/code&gt; or &lt;code&gt;anon_fun&lt;/code&gt; can raise &lt;code&gt;Arg.Bad&lt;/code&gt; with an error message to reject invalid arguments. &lt;code&gt;Arg.Bad&lt;/code&gt; is also raised by &lt;a href=&quot;arg#VALparse_argv&quot;&gt;&lt;code&gt;Arg.parse_argv&lt;/code&gt;&lt;/a&gt; in case of an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b86afa845a1585328545e5f3991b68610497328" translate="yes" xml:space="preserve">
          <source>Functions that decode signed (resp. unsigned) 8-bit or 16-bit integers represented by &lt;code&gt;int&lt;/code&gt; values sign-extend (resp. zero-extend) their result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3b7f5c27f44d3411501edb47a9a661138103758" translate="yes" xml:space="preserve">
          <source>Functions that encode 8-bit or 16-bit integers represented by &lt;code&gt;int&lt;/code&gt; values truncate their input to their least significant bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f86e81c17a3239f2ed2ba7a90d878f1fcd2d69d" translate="yes" xml:space="preserve">
          <source>Functions that take other functions as arguments are called &amp;ldquo;functionals&amp;rdquo;, or &amp;ldquo;higher-order functions&amp;rdquo;. Functionals are especially useful to provide iterators or similar generic operations over a data structure. For instance, the standard OCaml library provides a List.map functional that applies a given function to each element of a list, and returns the list of the results:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ea47ba4b29a471c05740d1b6b2aef7fcf7b007e" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.GenHashTable.MakeSeeded</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ba75f98b1daeb726f09c0d9b8ebf4ca742bd9a0" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.K1.Make</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="791c73df8d4dc4a293cb5fc5df93e2d713e170be" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.K1.MakeSeeded</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13076ed4adc02650a2456124fd63360d574f170b" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.K2.Make</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f37977f2244653f5138488517907c339e2caad0" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.K2.MakeSeeded</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb798cabd754ea8bd143b300b9c00949f911c4d0" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.Kn.Make</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ecfc616841fe061e9170e804dc5953460e4e22" translate="yes" xml:space="preserve">
          <source>Functor Ephemeron.Kn.MakeSeeded</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3844df36a31614de4703ed307f9104110c66c133" translate="yes" xml:space="preserve">
          <source>Functor Hashtbl.Make</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="743dbedb9473f776f428bc156c6dc4f18a3c7c2c" translate="yes" xml:space="preserve">
          <source>Functor Hashtbl.MakeSeeded</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a14323bcc1d6553a2f876a23442561ccf9a8898" translate="yes" xml:space="preserve">
          <source>Functor Map.Make</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b02c18c6fd2de2991bdf0f998f4324f7413b8e" translate="yes" xml:space="preserve">
          <source>Functor MoreLabels.Hashtbl.Make</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae21d10a3065dbf4c56f4f993cd9e0afc7222c78" translate="yes" xml:space="preserve">
          <source>Functor MoreLabels.Hashtbl.MakeSeeded</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e35d41c98a0f8cb263549b344d89e05e0044a9a8" translate="yes" xml:space="preserve">
          <source>Functor MoreLabels.Map.Make</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b37e87c0ae76c5e486380751816f2b5ce6f130" translate="yes" xml:space="preserve">
          <source>Functor MoreLabels.Set.Make</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa7642967c480650911cf8ff0961dfdebfe66970" translate="yes" xml:space="preserve">
          <source>Functor Set.Make</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4d7c62aec0f8b013f1e8a2e51f494583ed6792" translate="yes" xml:space="preserve">
          <source>Functor Sys.Immediate64.Make</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c626045c07d526e8e111e54420d804ac453b7f39" translate="yes" xml:space="preserve">
          <source>Functor Weak.Make</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b699610366ffb2bc1456841560d326de9dd34f9f" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of a weak hash table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="389dbe43bbc83f6add8186ac8132f778ad57371f" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of a weak hash table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb9434445367d8b10366b98ee9760b028541c96" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of a weak hash table. The seed is similar to the one of &lt;a href=&quot;hashtbl.makeseeded&quot;&gt;&lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad5d99d5b99b9109a80f197da9462e8c2eb0f11" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of an hash table that use the container for keeping the information given</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff02a7e7b2976b75351293a5e3b0329ad3b5e347" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the hashtable structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e736518d7c53ed3a67bef9cb74bed1672d054303" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the hashtable structure. The functor &lt;code&gt;Hashtbl.Make&lt;/code&gt; returns a structure containing a type &lt;code&gt;key&lt;/code&gt; of keys and a type &lt;code&gt;'a&amp;nbsp;t&lt;/code&gt; of hash tables associating data of type &lt;code&gt;'a&lt;/code&gt; to keys of type &lt;code&gt;key&lt;/code&gt;. The operations perform similarly to those of the generic interface, but use the hashing and equality functions specified in the functor argument &lt;code&gt;H&lt;/code&gt; instead of generic equality and hashing. Since the hash function is not seeded, the &lt;code&gt;create&lt;/code&gt; operation of the result structure always returns non-randomized hash tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa7f1ef8b7a2c11e209c2793d5c2dd4a871de19" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the hashtable structure. The functor &lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt; returns a structure containing a type &lt;code&gt;key&lt;/code&gt; of keys and a type &lt;code&gt;'a&amp;nbsp;t&lt;/code&gt; of hash tables associating data of type &lt;code&gt;'a&lt;/code&gt; to keys of type &lt;code&gt;key&lt;/code&gt;. The operations perform similarly to those of the generic interface, but use the seeded hashing and equality functions specified in the functor argument &lt;code&gt;H&lt;/code&gt; instead of generic equality and hashing. The &lt;code&gt;create&lt;/code&gt; operation of the result structure supports the &lt;code&gt;~random&lt;/code&gt; optional parameter and returns randomized hash tables if &lt;code&gt;~random:true&lt;/code&gt; is passed or if randomization is globally on (see &lt;a href=&quot;hashtbl#VALrandomize&quot;&gt;&lt;code&gt;Hashtbl.randomize&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83ea0beecbcf2f703dd91eb33b58d38977c526c" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the map structure given a totally ordered type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c59513445794edf5f86a24f7a69c2e920f5ea85" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the set structure given a totally ordered type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7ee355281f6ad25a690b039e1ce78ea8323eda0" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the weak hash set structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14416cb42fb32afba2f0aa5e6b2e714075343250" translate="yes" xml:space="preserve">
          <source>Functor building an implementation of the weak hash set structure. &lt;code&gt;H.equal&lt;/code&gt; can't be the physical equality, since only shallow copies of the elements in the set are given to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0eb68f70b3b05995b7d69acf8715b7a8bfc794f9" translate="yes" xml:space="preserve">
          <source>Functorial interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40cacb900d73a801423574b27a6596efb4e78908" translate="yes" xml:space="preserve">
          <source>Functors are &amp;ldquo;functions&amp;rdquo; from modules to modules. Functors let you create parameterized modules and then provide other modules as parameter(s) to get a specific implementation. For instance, a Set module implementing sets as sorted lists could be parameterized to work with any module that provides an element type and a comparison function compare (such as OrderedString):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2aa3173a1816096d6ad12168dbc1f9f4f467900" translate="yes" xml:space="preserve">
          <source>Furthermore, quoted strings {|...|} can be combined with extension nodes to embed foreign syntax fragments. Those fragments can be interpreted by a preprocessor and turned into OCaml code without requiring escaping quotes. A syntax shortcut is available for them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="2e0c6454c25618b51c33652f1af456d60881e227" translate="yes" xml:space="preserve">
          <source>GADT pattern-matching may also add type equations to non-local abstract types. The behaviour is the same as with local abstract types. Reusing the above eq type, one can write:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e770dda21552fdb9094fb60f7cc36a895a76025d" translate="yes" xml:space="preserve">
          <source>Gc</source>
          <target state="translated">Gc</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="67069e1d09b05959a8399aadc22a86b8f23aaa51" translate="yes" xml:space="preserve">
          <source>General input functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ca3ca5de8ba6c9c5bd65df11e3e917c3bc1a34" translate="yes" xml:space="preserve">
          <source>General output functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92e8a116a60d135308df04f70f6a61a19de331d5" translate="yes" xml:space="preserve">
          <source>Generalized algebraic datatypes, or GADTs, extend usual sum types in two ways: constraints on type parameters may change depending on the value constructor, and some type variables may be existentially quantified. Adding constraints is done by giving an explicit return type (the rightmost &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; in the above syntax), where type parameters are instantiated. This return type must use the same type constructor as the type being defined, and have the same number of parameters. Variables are made existential when they appear inside a constructor&amp;rsquo;s argument, but not in its return type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0692177f9aa82986e7e68bb21bd552d660b0fb2a" translate="yes" xml:space="preserve">
          <source>Generally speaking, the formatted input functions have 3 arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae547ac3f788ba5ce6bb43946b8b3189c176f64a" translate="yes" xml:space="preserve">
          <source>Generate a bytecode executable file that can be executed on the custom runtime system runtime-name, built earlier with ocamlc -make-runtimeruntime-name. See section &lt;a href=&quot;intfc#ss%3Acustom-runtime&quot;&gt;20.1.6&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7384f4e0f133518743705b706281153ceace0aa" translate="yes" xml:space="preserve">
          <source>Generate a dependency graph for the toplevel modules, in a format suitable for displaying and processing by dot. The dot tool is available from &lt;a href=&quot;https://graphviz.org/&quot;&gt;https://graphviz.org/&lt;/a&gt;. The textual representation of the graph is written to the file ocamldoc.out, or to the file specified with the -o option. Use dot ocamldoc.out to display it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="156fdd8d300b8c00d971004d85456ef8219690af" translate="yes" xml:space="preserve">
          <source>Generate a description of the parsing tables and a report on conflicts resulting from ambiguities in the grammar. The description is put in file grammar.output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49a9fa22c03767adb75add693dfa90c38c0ebdbe" translate="yes" xml:space="preserve">
          <source>Generate an object file (.cmo) that can later be included as a sub-module (with the given access path) of a compilation unit constructed with -pack. For instance, ocamlc -for-pack P -c A.ml will generate a..cmo that can later be used with ocamlc -pack -o P.cmo a.cmo. Note: you can still pack a module that was compiled without -for-pack but in this case exceptions will be printed with the wrong names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7103fb059f2d362dcfc616012cde802b4f623d5e" translate="yes" xml:space="preserve">
          <source>Generate an object file (.cmx and .o/.obj files) that can later be included as a sub-module (with the given access path) of a compilation unit constructed with -pack. For instance, ocamlopt -for-pack P -c A.ml will generate a..cmx and a.o files that can later be used with ocamlopt -pack -o P.cmx a.cmx. Note: you can still pack a module that was compiled without -for-pack but in this case exceptions will be printed with the wrong names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="266d7ee3cde25ec4eb6f33154bf1ffb8dd2f15a2" translate="yes" xml:space="preserve">
          <source>Generate dependencies for a pure native-code program (no bytecode version). When an implementation file (.ml file) has no explicit interface file (.mli file), ocamldep generates dependencies on the bytecode compiled file (.cmo file) to reflect interface changes. This can cause unnecessary bytecode recompilations for programs that are compiled to native-code only. The flag -native causes dependencies on native compiled files (.cmx) to be generated instead of on .cmo files. (This flag makes no difference if all source files have explicit .mli interface files.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f287ec97b2026108a81dd10e2f4d965c4671c59e" translate="yes" xml:space="preserve">
          <source>Generate dependencies for native plugin files (.cmxs) in addition to native compiled files (.cmx).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d376a113a8253e681531eb700236c93f62c7c75e" translate="yes" xml:space="preserve">
          <source>Generate dependencies on all required files, rather than assuming implicit dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea577157b1392082ac83b9fe585387f3b557796" translate="yes" xml:space="preserve">
          <source>Generate documentation as a set of Unix man pages. The generated pages are stored in the current directory, or in the directory specified with the -d option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5d87db23ea095f4cc3759103db7592876ea4306" translate="yes" xml:space="preserve">
          <source>Generate documentation in HTML default format. The generated HTML pages are stored in the current directory, or in the directory specified with the -d option. You can customize the style of the generated pages by editing the generated style.css file, or by providing your own style sheet using option -css-style. The file style.css is not generated if it already exists or if -css-style is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f58b7853c614a36ff0c342792e60a65dbe4ad9b5" translate="yes" xml:space="preserve">
          <source>Generate documentation in L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X default format. The generated L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X document is saved in file ocamldoc.out, or in the file specified with the -o option. The document uses the style file ocamldoc.sty. This file is generated when using the -latex option, if it does not already exist. You can change this file to customize the style of your L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="129f3a9bee36c9ea1bf962aa07ce63970022d326" translate="yes" xml:space="preserve">
          <source>Generate documentation in TeXinfo default format. The generated L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X document is saved in file ocamldoc.out, or in the file specified with the -o option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9fc266b6949eb96df1f7eb844b75ca64039217c" translate="yes" xml:space="preserve">
          <source>Generate files in directory dir, rather than the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285e44cc7e6dbcf78a91ff365658da2f4d1959ff" translate="yes" xml:space="preserve">
          <source>Generate man pages only for modules, module types, classes and class types, instead of pages for all elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9864da8bda2a0e22bc4b39c31b0e724fe7a1a47" translate="yes" xml:space="preserve">
          <source>Generate one .tex file per toplevel module, instead of the global ocamldoc.out file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2e0a3174325a031b5ee70731f141a8ca8cc0cd" translate="yes" xml:space="preserve">
          <source>Generate only index files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e76556f478e02273e6352c5a860d5aa13d870c" translate="yes" xml:space="preserve">
          <source>Generate position-dependent machine code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e6af12f0ccf65fb7a1459aa5aac3451674ec09" translate="yes" xml:space="preserve">
          <source>Generate position-independent machine code. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c8ea337bb1a13e369fcb0e566aaf3fd0c0a061" translate="yes" xml:space="preserve">
          <source>Generate signal on INTR, QUIT, SUSP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c2b556ff44e4d16b71ff51d7440841b3fbf5c4" translate="yes" xml:space="preserve">
          <source>Generic arrays (of arbitrarily many dimensions)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9003821b402d9b7458c8ef820262746bf0c5a25" translate="yes" xml:space="preserve">
          <source>Generic interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca8b79d76f57f976b0d3a762bfe49c3a3887f695" translate="yes" xml:space="preserve">
          <source>Genlex</source>
          <target state="translated">Genlex</target>
        </trans-unit>
        <trans-unit id="9e32ad0c42ab8bdae8747cff4350874077b93e6d" translate="yes" xml:space="preserve">
          <source>Geometric functions can be used to manipulate simultaneously the coupled variables, margin and maxixum indentation limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1226717c2fc305626512b0a1ae618fddfee0b9" translate="yes" xml:space="preserve">
          <source>Geometry</source>
          <target state="translated">Geometry</target>
        </trans-unit>
        <trans-unit id="6ea2b05a0cc3942bd2ab24dd1445538e05f32023" translate="yes" xml:space="preserve">
          <source>Get the n-th character of the buffer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5785aa5d35936984cbd882807965031baa875625" translate="yes" xml:space="preserve">
          <source>Give a prefix to use for the labels of the values in the generated L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X document. The default prefix is the empty string. You can also use the options -latex-type-prefix, -latex-exception-prefix, -latex-module-prefix, -latex-module-type-prefix, -latex-class-prefix, -latex-class-type-prefix, -latex-attribute-prefix and -latex-method-prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="038e7979ee15f8f5c9e696afa315dfe00ad4b50f" translate="yes" xml:space="preserve">
          <source>Give arguments as command-line arguments for the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58fb754d9855207400580560fa5a499d34953865" translate="yes" xml:space="preserve">
          <source>Give help about the command command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05560101179d8cd9a5824eb9bc4979bd6dc98da1" translate="yes" xml:space="preserve">
          <source>Give help about the variable variable. The list of all debugger variables can be obtained with help set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="371d25ecfb079465a60b6b0a5de188a1933588cb" translate="yes" xml:space="preserve">
          <source>Give help about topic. Use help info to get a list of known topics.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="604df0eab7062b6f55919a0389be07618d669c2c" translate="yes" xml:space="preserve">
          <source>Give information about the given subject. For instance, info breakpoints will print the list of all breakpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1454ccaeebb872ec2b102caf5995ceb3ec79caa0" translate="yes" xml:space="preserve">
          <source>Given a byte sequence &lt;code&gt;s&lt;/code&gt; of length &lt;code&gt;l&lt;/code&gt;, we can access each of the &lt;code&gt;l&lt;/code&gt; bytes of &lt;code&gt;s&lt;/code&gt; via its index in the sequence. Indexes start at &lt;code&gt;0&lt;/code&gt;, and we will call an index valid in &lt;code&gt;s&lt;/code&gt; if it falls within the range &lt;code&gt;[0...l-1]&lt;/code&gt; (inclusive). A position is the point between two bytes or at the beginning or end of the sequence. We call a position valid in &lt;code&gt;s&lt;/code&gt; if it falls within the range &lt;code&gt;[0...l]&lt;/code&gt; (inclusive). Note that the byte at index &lt;code&gt;n&lt;/code&gt; is between positions &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;n+1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2adb0b9ad2ceb5bfe49b0ecb92caf5f3fae05f4f" translate="yes" xml:space="preserve">
          <source>Given a string &lt;code&gt;s&lt;/code&gt; of length &lt;code&gt;l&lt;/code&gt;, we can access each of the &lt;code&gt;l&lt;/code&gt; characters of &lt;code&gt;s&lt;/code&gt; via its index in the sequence. Indexes start at &lt;code&gt;0&lt;/code&gt;, and we will call an index valid in &lt;code&gt;s&lt;/code&gt; if it falls within the range &lt;code&gt;[0...l-1]&lt;/code&gt; (inclusive). A position is the point between two characters or at the beginning or end of the string. We call a position valid in &lt;code&gt;s&lt;/code&gt; if it falls within the range &lt;code&gt;[0...l]&lt;/code&gt; (inclusive). Note that the character at index &lt;code&gt;n&lt;/code&gt; is between positions &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;n+1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa38b172ec5c9d2284f131cd775ec188b5d8628" translate="yes" xml:space="preserve">
          <source>Go back to the latest time recorded in the execution history. With an argument, do it count times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b60e6e076c005d616d2d916072eb065e52ae28e" translate="yes" xml:space="preserve">
          <source>Going further, this construction can introduce local components inside a structure,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aeace163a6adb474f8a266503a9076db84dd3da" translate="yes" xml:space="preserve">
          <source>Govern whether unsafe object files are allowed to be dynamically linked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d84ed49173cfa176fb1c99f2a3dec80f80b0aba6" translate="yes" xml:space="preserve">
          <source>Govern whether unsafe object files are allowed to be dynamically linked. A compilation unit is 'unsafe' if it contains declarations of external functions, which can break type safety. By default, dynamic linking of unsafe object files is not allowed. In native code, this function does nothing; object files with external functions are always allowed to be dynamically linked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9c481167a949ba9541e5157f33a16bc75dec6fe" translate="yes" xml:space="preserve">
          <source>Grammar definitions have the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1e950667e2e44adf45b58bf09492bae226c4f8" translate="yes" xml:space="preserve">
          <source>Group ID of the file's group</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6419b6179edfb45b0221e7cd7ed865964d5bab58" translate="yes" xml:space="preserve">
          <source>Growing and shrinking of the heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="b8ec02c8c64e872c7dd1918af95f84fc205739fb" translate="yes" xml:space="preserve">
          <source>Hang up on last close.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92d2f449cc1e7472e355886e114b989d0112305b" translate="yes" xml:space="preserve">
          <source>Hangup on controlling terminal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f156c0d6e4e285c95352406b7047bb7ecc056fb3" translate="yes" xml:space="preserve">
          <source>Hardware I/O error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5989bb5f874fe020eb5b05197afeb1595f9e30f" translate="yes" xml:space="preserve">
          <source>Hash tables and hash functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5152ba26a0f6c91803db8e6e54eb626e6caf15e9" translate="yes" xml:space="preserve">
          <source>Hash tables are hashed association tables, with in-place modification.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92bab01eaa07991ec1d5268ad63bfd41d8f81ce4" translate="yes" xml:space="preserve">
          <source>Hashtbl</source>
          <target state="translated">Hashtbl</target>
        </trans-unit>
        <trans-unit id="8de9b03544fae209b6d485a82f3fb0bc61712994" translate="yes" xml:space="preserve">
          <source>Having been given the following code, the compiler will inline loop into f, and then observe inv being invariant and always the pair formed by adding 42 and 43 to the argument x of the function f.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00999d5419281dc73a86b97d51f054b1c30f6f29" translate="yes" xml:space="preserve">
          <source>Heap compaction is triggered when the estimated amount of &quot;wasted&quot; memory is more than &lt;code&gt;max_overhead&lt;/code&gt; percent of the amount of live data. If &lt;code&gt;max_overhead&lt;/code&gt; is set to 0, heap compaction is triggered at the end of each major GC cycle (this setting is intended for testing purposes only). If &lt;code&gt;max_overhead&amp;nbsp;&amp;gt;=&amp;nbsp;1000000&lt;/code&gt;, compaction is never triggered. If compaction is permanently disabled, it is strongly suggested to set &lt;code&gt;allocation_policy&lt;/code&gt; to 2. Default: 500.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9c50122226f9d6dcf71b56ac7a7f8d8b4c3c78a" translate="yes" xml:space="preserve">
          <source>Heap compaction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="758afbd2a13c2682e468e247eb3f98ab9f95fabf" translate="yes" xml:space="preserve">
          <source>Hence, a typical call to the formatted input function &lt;a href=&quot;scanf#VALbscanf&quot;&gt;&lt;code&gt;Scanf.bscanf&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;bscanf&amp;nbsp;ic&amp;nbsp;fmt&amp;nbsp;f&lt;/code&gt;, where:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14ac05929489e0ffc8dddd667d63b054e933d010" translate="yes" xml:space="preserve">
          <source>Hence, the clients do not have direct access to the balance, nor the history of their own accounts. Their only way to change their balance is to deposit or withdraw money. It is important to give the clients a class and not just the ability to create accounts (such as the promotional discount account), so that they can personalize their account. For instance, a client may refine the deposit and withdraw methods so as to do his own financial bookkeeping, automatically. On the other hand, the function discount is given as such, with no possibility for further personalization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03570ac90dade998e56b554e41239c2460db8925" translate="yes" xml:space="preserve">
          <source>Hence, this conversion always succeeds: it returns an empty string if the bounding condition holds when the scan begins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78f7a697615de15b124ff10dc612688faeddea6" translate="yes" xml:space="preserve">
          <source>Here (test () ()) is already (0,0,0) and cannot be further applied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0931022beea83b3afc095873234631b7243eeca4" translate="yes" xml:space="preserve">
          <source>Here are some examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d3820c838ff6ce0440d2b2700f2e77ee57f5a5" translate="yes" xml:space="preserve">
          <source>Here are some of the label names you will find throughout the libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a24a6072e91fffecf48135b656042082bc3b6e9a" translate="yes" xml:space="preserve">
          <source>Here f1 and f2 both accept the variant tags `A and `B, but the argument of `A is int for f1 and string for f2. In f&amp;rsquo;s type `C, only accepted by f1, disappears, but both argument types appear for `A as int &amp;amp; string. This means that if we pass the variant tag `A to f, its argument should be &lt;em&gt;both&lt;/em&gt;int and string. Since there is no such value, f cannot be applied to `A, and `B is the only accepted input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="561164ceab5ebc70c0d64deefe4330729b9658fb" translate="yes" xml:space="preserve">
          <source>Here is a concrete example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aba64a5365a5818e1799acb408be84f8f2c8e9d4" translate="yes" xml:space="preserve">
          <source>Here is a naive decoder example, using &lt;em&gt;babeltrace&lt;/em&gt;&amp;rsquo;s Python library, and &lt;em&gt;Python 3.8&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59957446a4d33ae4c96bc863ccc6ed285dc68c5a" translate="yes" xml:space="preserve">
          <source>Here is a template Makefile for a OCaml program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f39d81d7a3d048698fdf682899353d5db74f1a73" translate="yes" xml:space="preserve">
          <source>Here is an example of a polymorphic function that takes the runtime representation of some type t and a value of the same type, then pretty-prints the value as a string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e03958ef86650f0911d60b7395939fdf73500e" translate="yes" xml:space="preserve">
          <source>Here is an example of encapsulation of out-of-heap pointers of C type ty * inside Abstract_tag blocks. Section &lt;a href=&quot;#s%3Ac-intf-example&quot;&gt;20.6&lt;/a&gt; gives a more complete example using Custom_tag blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308b0d78062d0ad0003e582da279f23acb702da1" translate="yes" xml:space="preserve">
          <source>Here is an example using both singleton types and equality witnesses to implement dynamic types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a225c0d46c3cbb924c84a138670dbc8f06f0cc3e" translate="yes" xml:space="preserve">
          <source>Here is another example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="284f8d0b01b42153fa84e0b1f00a100c6214fbc8" translate="yes" xml:space="preserve">
          <source>Here is how to develop a HTML generator handling your custom tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2dbaf9de1c69f014cb64b41bd3b7343fac784a8" translate="yes" xml:space="preserve">
          <source>Here is how to rewrite the pretty-printer using fprintf:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa1b2114ba8ea9e3cf06e2d4912d6761acbe4be" translate="yes" xml:space="preserve">
          <source>Here is the BNF grammar for the simple markup language used to format text descriptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="388da24303f96c71ff151f75e86ac54ea859531d" translate="yes" xml:space="preserve">
          <source>Here is the C stub code for calling these functions from C:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e741bd10b766cf1796a36394a51e7d62035fecd" translate="yes" xml:space="preserve">
          <source>Here is the definition for the corresponding lexer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="056f1f0f51eab79857c6e29e42baa016f78d2977" translate="yes" xml:space="preserve">
          <source>Here is the main program, that combines the parser with the lexer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="446b11c3be57d6c60ef1fd0ac52fa6e52063c114" translate="yes" xml:space="preserve">
          <source>Here is the same function written using the low-level allocation functions. We notice that the cons cells are small blocks and can be allocated with caml_alloc_small, and filled by direct assignments on their fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18941c3984943cc307db931410d47e92fe4df6de" translate="yes" xml:space="preserve">
          <source>Here is where the debugger events (written ǧ) are located in the source code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b08d25e0d333e96aba2f91f119d4d2b7bffff20" translate="yes" xml:space="preserve">
          <source>Here the return type int is never mixed with a, so it is seen as non-ambiguous, and can be inferred. When using such partial type annotations we strongly suggest specifying the -principal mode, to check that inference is principal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10cb8cd98c3cdedd87ca3af31d62baffc2ee326e" translate="yes" xml:space="preserve">
          <source>Here type eq has only one constructor, and by matching on it one adds a local constraint allowing the conversion between a and b. By building such equality witnesses, one can make equal types which are syntactically different.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b271b0c3304eb3ee95f254204f52094adf07587" translate="yes" xml:space="preserve">
          <source>Here unix is the identifier for the alert. If this alert category is enabled, any reference to U.fork will produce a message at compile time, which can be turned or not into a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e022f6709dae55bc7a223efa347b05eb7e8f59f3" translate="yes" xml:space="preserve">
          <source>Here we are seeing two phenomena. First, since this matching is open (the last case catches any tag), we obtain the type [&amp;gt; `A | `B] rather than [&amp;lt; `A | `B] in a closed matching. Then, since x is returned as is, input and return types are identical. The notation as 'a denotes such type sharing. If we apply f to yet another tag `E, it gets added to the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc63fa497589a6334b111c69df1747a0dd97fc2a" translate="yes" xml:space="preserve">
          <source>Here, OCaml has inferred that the possible choices for the type of {x;z} are first_record and middle_record, since the type last_record has no field z. Ocaml then picks the type middle_record as the last defined type between the two possibilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b060c78130d7f93cdd27667dbd10437fa706949d" translate="yes" xml:space="preserve">
          <source>Here, exposing the representation of strings is probably harmless. We do could also hide the representation of strings as we hid the currency in the class money of section &lt;a href=&quot;objectexamples#s%3Afriends&quot;&gt;3.17&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd4519239484578811a092a4daeaa544e7eb37d" translate="yes" xml:space="preserve">
          <source>Here, the private declaration ensures that in any value of type M.t, the argument to the B constructor is always a positive integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ee51e87098916ce5e24ed6b88b7de69de869c00" translate="yes" xml:space="preserve">
          <source>Here, the registering of result is not strictly needed, because no allocation takes place after it gets its value, but it&amp;rsquo;s easier and safer to simply register all the local variables that have type value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e432da26179fd3758bb19dd844fa23eec9ba8078" translate="yes" xml:space="preserve">
          <source>Here, the representation of the object is known only to a particular object. To make it available to other objects of the same class, we are forced to make it available to the whole world. However we can easily restrict the visibility of the representation using the module system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa5773c339f395510cdd47c4eb05d1e72c299e1" translate="yes" xml:space="preserve">
          <source>Hide the given complete module names in the generated documentation. modules is a list of complete module names separated by &amp;rsquo;,&amp;rsquo;, without blanks. For instance: Stdlib,M2.M3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ab4f5df7d32ff189d23eeac09eea791a2f04d4" translate="yes" xml:space="preserve">
          <source>High levels of inlining performed by Flambda may expose bugs in code thought previously to be correct. Take care, for example, not to add type annotations that claim some mutable value is always immediate if it might be possible for an unsafe operation to update it to a boxed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="660cd8080dffe58889ce5763038bf5300dc31acd" translate="yes" xml:space="preserve">
          <source>High-level network connection functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64fc91bf4f5322a745e7df5d0f9481f4d5653b51" translate="yes" xml:space="preserve">
          <source>High-level pipe and process management.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d630cd51e2ab49c23404375744103dcb9ddf12c0" translate="yes" xml:space="preserve">
          <source>High-level pipe and process management. The first argument specifies the command to run, and the second argument specifies the argument array passed to the command. This function runs the command in parallel with the program. The standard output of the command is redirected to a pipe, which can be read via the returned input channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a31d961a8252f33564ca1cdad952791054058fa6" translate="yes" xml:space="preserve">
          <source>High-level pipe and process management. This function runs the given command in parallel with the program. The standard output of the command is redirected to a pipe, which can be read via the returned input channel. The command is interpreted by the shell &lt;code&gt;/bin/sh&lt;/code&gt; (cf. &lt;code&gt;system&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a456b402f5a87f65dd79e5881fc3236030290cf" translate="yes" xml:space="preserve">
          <source>High-level pipe and process management. This function runs the given command in parallel with the program. The standard output of the command is redirected to a pipe, which can be read via the returned input channel. The command is interpreted by the shell &lt;code&gt;/bin/sh&lt;/code&gt; (or &lt;code&gt;cmd.exe&lt;/code&gt; on Windows), cf. &lt;a href=&quot;unix#VALsystem&quot;&gt;&lt;code&gt;Unix.system&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;filename#VALquote_command&quot;&gt;&lt;code&gt;Filename.quote_command&lt;/code&gt;&lt;/a&gt; function can be used to quote the command and its arguments as appropriate for the shell being used. If the command does not need to be run through the shell, &lt;a href=&quot;unix#VALopen_process_args_in&quot;&gt;&lt;code&gt;Unix.open_process_args_in&lt;/code&gt;&lt;/a&gt; can be used as a more robust and more efficient alternative to &lt;a href=&quot;unix#VALopen_process_in&quot;&gt;&lt;code&gt;Unix.open_process_in&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a29172035d6d85dc663ba7e39082390589b775be" translate="yes" xml:space="preserve">
          <source>High-level process and redirection management</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a33c2b6a314329b777f9efd6ddae94062b493db" translate="yes" xml:space="preserve">
          <source>Histogram of bucket sizes. This array &lt;code&gt;histo&lt;/code&gt; has length &lt;code&gt;max_bucket_length&amp;nbsp;+&amp;nbsp;1&lt;/code&gt;. The value of &lt;code&gt;histo.(i)&lt;/code&gt; is the number of buckets whose size is &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fc8eded9808dd321a05fbe7b423579b8ee46feb" translate="yes" xml:space="preserve">
          <source>Host and protocol databases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e44bbbaded72ef9b5085984836ab8806136eb0e" translate="yes" xml:space="preserve">
          <source>Host and service information returned by &lt;a href=&quot;unix#VALgetnameinfo&quot;&gt;&lt;code&gt;Unix.getnameinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a7e131a5cb8762553101bda765297974113fa2" translate="yes" xml:space="preserve">
          <source>Host is down</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6b20c4f18fba11bf22b7eb25c422f7383d8a3f3" translate="yes" xml:space="preserve">
          <source>Hours 0..23</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b35a8d557fc5292ba116b9b094f27e8f1f0b10" translate="yes" xml:space="preserve">
          <source>How many rounds of optimisation to perform. See section &lt;a href=&quot;#ss%3Aflambda-rounds&quot;&gt;21.2.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54107178e78d43729885a7720437da1670a7ca51" translate="yes" xml:space="preserve">
          <source>How much to add to the major heap when increasing it. If this number is less than or equal to 1000, it is a percentage of the current heap size (i.e. setting it to 100 will double the heap size at each increase). If it is more than 1000, it is a fixed number of words that will be added to the heap. Default: 15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e08adcc4e52311113e7bfcb35cebc7fc05cb528" translate="yes" xml:space="preserve">
          <source>However the following code will still return 42:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8da81d46307b91fff8fddf943d3b6f54904f4acb" translate="yes" xml:space="preserve">
          <source>However, another semantics may be considered more natural here: any pair that has one side passing the test will take the branch. With this semantics the previous code fragment would be equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b11631e4eb742b73778c9e3a1a94f9ec22cd9e49" translate="yes" xml:space="preserve">
          <source>However, before referencing another compilation unit, an implementation of that unit must be present in memory. At start-up, the toplevel system contains implementations for all the modules in the the standard library. Implementations for user modules can be entered with the #load directive described above. Referencing a unit for which no implementation has been provided results in the error Reference to undefined global `...'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e8753db777bb602f194cf91bcdc0dd3f1d1843" translate="yes" xml:space="preserve">
          <source>However, if lexer rules are introduced with the shortest keyword in place of the parse keyword, then the &amp;ldquo;shortest match&amp;rdquo; rule applies: the shortest prefix of the input is selected. In case of tie, the regular expression that occurs earlier in the rule is still selected. This feature is not intended for use in ordinary lexical analyzers, it may facilitate the use of ocamllex as a simple text processing tool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944f5f03f5c76a0cf57976a0a3d9c3e3e582504a" translate="yes" xml:space="preserve">
          <source>However, if the program is changed to include a call to Gc.eventlog_resume, events payloads can be seen again in the trace file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76abd1d96d1c865f566606abb7355db8f0cf0b1f" translate="yes" xml:space="preserve">
          <source>However, the abbreviation #c' cannot be defined directly in a similar way. It can only be defined by a class or a class-type definition. This is because a #-abbreviation carries an implicit anonymous variable .. that cannot be explicitly named. The closer you get to it is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="453dcc94eeb7e578d8082b01f6ebd6cec66637be" translate="yes" xml:space="preserve">
          <source>However, the bug might be fixed more safely by the following definition:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c720d37ad34c33bb2deaffa9bd67b5537585a52d" translate="yes" xml:space="preserve">
          <source>However, the domain of the coercion cannot always be omitted. In that case, the solution is to use the explicit form. Sometimes, a change in the class-type definition can also solve the problem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0ee79bd6d9b251f8a82a82d67365c84132c706f" translate="yes" xml:space="preserve">
          <source>However, the former pattern is generally more appropriate, since the code for adjustment is part of the definition of the class and will be inherited.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87a9a30d2a6c456b46a8651fb0691f17ba51e44f" translate="yes" xml:space="preserve">
          <source>However, the method escaped returns an object of the class ostring, and not an object of the current class. Hence, if the class is further extended, the method escaped will only return an object of the parent class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de0a5f6db4da9e37735ab3e4188716aa13cde57d" translate="yes" xml:space="preserve">
          <source>However, the method fold of a given object can only be applied to functions that all have the same type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a60f20a882847a637b446acbd0fe979a6ba07d99" translate="yes" xml:space="preserve">
          <source>However, the most common instance of this problem, coercing self to its current class, is detected as a special case by the type checker, and properly typed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a966fbd7bd3413811c97fa093d7055e1ad7af5" translate="yes" xml:space="preserve">
          <source>However, the two classes of window_subject and window_observer are not mutually recursive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88098ed1eace82320b4d12264fb903f3a2eedeb" translate="yes" xml:space="preserve">
          <source>However, the type can be completely omitted in the class definition if it is already known, through inheritance or type constraints on self. Here is an example of method overriding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d00554dc54be9a5828e5bbe84dea5a6534accc" translate="yes" xml:space="preserve">
          <source>However, the type of average len is less generic than the type of average_len, since it requires the type of the first and second argument to be the same:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7404314c946d8e6c9565bd2a5ce313929c2a9744" translate="yes" xml:space="preserve">
          <source>However, when there is only one argument, it is often left unlabeled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c2bbe2630aa2be12c44f2d61e0d58373ebbab9e" translate="yes" xml:space="preserve">
          <source>However, writing a method for iterating over a stack is more problematic. A method fold would have type ('b -&amp;gt; 'a -&amp;gt; 'b) -&amp;gt; 'b -&amp;gt; 'b. Here 'a is the parameter of the stack. The parameter 'b is not related to the class 'a stack but to the argument that will be passed to the method fold. A naive approach is to make 'b an extra parameter of class stack:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05320fb14f6e5d064c5c867a6851bf5b8c0cc4a" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4416a526cde7aaa7102f8da4d2d9fa9ab04023c8" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine. Argument is in radians.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ede5ec0ac7aaa68576130553561ac3c86fd2ea" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d254284446de08654124bede74d08ac424f8d08" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine. Argument is in radians.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b717ac903ad6476810dfdda159430e764de6cda7" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f8a0e2dc65ee66bc03be8ca221132887633049c" translate="yes" xml:space="preserve">
          <source>Hyperbolic tangent. Argument is in radians.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="e121a2cf51a1e00de2e2696e63934fe06010dee8" translate="yes" xml:space="preserve">
          <source>IEEE double precision (2 * 64 bits) floating-point complex numbers (&lt;a href=&quot;bigarray#TYPEcomplex64_elt&quot;&gt;&lt;code&gt;Bigarray.complex64_elt&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11bfef51ab97ad183ddf039572bf34ff80a7c9de" translate="yes" xml:space="preserve">
          <source>IEEE double precision (64 bits) floating-point numbers (&lt;a href=&quot;bigarray#TYPEfloat64_elt&quot;&gt;&lt;code&gt;Bigarray.float64_elt&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ee940288ca134cc7cc56200b21d07e91766c05" translate="yes" xml:space="preserve">
          <source>IEEE single precision (2 * 32 bits) floating-point complex numbers (&lt;a href=&quot;bigarray#TYPEcomplex32_elt&quot;&gt;&lt;code&gt;Bigarray.complex32_elt&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57793d87153a9ff4dbb8b05395ad2a5ce3baeca" translate="yes" xml:space="preserve">
          <source>IEEE single precision (32 bits) floating-point numbers (&lt;a href=&quot;bigarray#TYPEfloat32_elt&quot;&gt;&lt;code&gt;Bigarray.float32_elt&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73cbb2fc3a0a2ebb88df2442c2ac6e1ecdf80a05" translate="yes" xml:space="preserve">
          <source>Identical to &lt;a href=&quot;arg#VALread_arg&quot;&gt;&lt;code&gt;Arg.read_arg&lt;/code&gt;&lt;/a&gt; but assumes null character terminated command line arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="379fe7f50ad648171482ca58ad0ca76b53a14cbd" translate="yes" xml:space="preserve">
          <source>Identical to &lt;a href=&quot;arg#VALwrite_arg&quot;&gt;&lt;code&gt;Arg.write_arg&lt;/code&gt;&lt;/a&gt; but uses the null character for terminator instead of newline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19fbdf2c6cc1f0d599912101bcc2320f7df6346b" translate="yes" xml:space="preserve">
          <source>Identifiers are sequences of letters, digits, _ (the underscore character), and ' (the single quote), starting with a letter or an underscore. Letters contain at least the 52 lowercase and uppercase letters from the ASCII set. The current implementation also recognizes as letters some characters from the ISO 8859-1 set (characters 192&amp;ndash;214 and 216&amp;ndash;222 as uppercase letters; characters 223&amp;ndash;246 and 248&amp;ndash;255 as lowercase letters). This feature is deprecated and should be avoided for future compatibility.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf2182b3c192855891eae1040965f486e80e675f" translate="yes" xml:space="preserve">
          <source>Identifiers are used to give names to several classes of language objects and refer to these objects by name later:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="252dcf0638748c4bce9e1885e5ea0b583d3a4258" translate="yes" xml:space="preserve">
          <source>Identifiers in struct custom_operations must be chosen carefully, since they must identify uniquely the data structure for serialization and deserialization operations. In particular, consider including a version number in the identifier; this way, the format of the data can be changed later, yet backward-compatible deserialisation functions can be provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9eef2b3f53493dc9c8afc794fc2b6d8165407f3" translate="yes" xml:space="preserve">
          <source>Identifiers starting with _ (an underscore character) are reserved for the OCaml runtime system; do not use them for your custom data. We recommend to use a URL (http://mymachine.mydomain.com/mylibrary/version-number) or a Java-style package name (com.mydomain.mymachine.mylibrary.version-number) as identifiers, to minimize the risk of identifier collision.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e9520ba53b50a96883830ad8837005fe5c1553f" translate="yes" xml:space="preserve">
          <source>Identify the types string and bytes, thereby making strings writable. This is intended for compatibility with old source code and should not be used with new software.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d30bcc4516a3f540514e40999e656b1a8b2df5e6" translate="yes" xml:space="preserve">
          <source>Identifying the exact context in which polymorphic types should be replaced by weak types in a modular way is a difficult question. Indeed the type system must handle the possibility that functions may hide persistent mutable states. For instance, the following function uses an internal reference to implement a delayed identity function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f7c4df05ef0f7f20a0f4baf77fac76b9a430dd" translate="yes" xml:space="preserve">
          <source>If '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; denotes an explicit polymorphic variable, and &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; denotes either an object or polymorphic variant type, the row variable of &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; is captured by '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;, and quantified upon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af83e49192d3b9055cda1d966bf6a005de3d634" translate="yes" xml:space="preserve">
          <source>If -cclib or -ccopt options are passed on the command line, these options are stored in the resulting .cmxalibrary. Then, linking with this library automatically adds back the -cclib and -ccopt options as if they had been provided on the command line, unless the -noautolink option is given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7bf1c478aa7887dedd7adc474f78a180f3a1e68" translate="yes" xml:space="preserve">
          <source>If -custom, -cclib or -ccopt options are passed on the command line, these options are stored in the resulting .cmalibrary. Then, linking with this library automatically adds back the -custom, -cclib and -ccopt options as if they had been provided on the command line, unless the -noautolink option is given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfecdd4c68900c96970ac5e52ae011bd5e9a0e2a" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; is a polymorphic method, its type should be known at the invocation site. This is true for instance if &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is the name of a fresh object (let&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; = new&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; &amp;hellip; ) or if there is a type constraint. Principality of the derivation can be checked in the -principal mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc3a54443b9c753a78e2f01944d38b93f7a5164e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&amp;nbsp;&amp;gt;&amp;nbsp;3&lt;/code&gt;, alternate syntax is provided: you can write &lt;code&gt;a.{i1,&amp;nbsp;i2,&amp;nbsp;...,&amp;nbsp;iN}&amp;nbsp;&amp;lt;-&amp;nbsp;v&lt;/code&gt; instead of &lt;code&gt;Genarray.set&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&amp;nbsp;v&lt;/code&gt;. (The syntax &lt;code&gt;a.{...}&amp;nbsp;&amp;lt;-&amp;nbsp;v&lt;/code&gt; with one, two or three coordinates is reserved for updating one-, two- and three-dimensional arrays as described below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4203c94450a640c56f05a68d1e3adc5328030de4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&amp;nbsp;&amp;gt;&amp;nbsp;3&lt;/code&gt;, alternate syntax is provided: you can write &lt;code&gt;a.{i1,&amp;nbsp;i2,&amp;nbsp;...,&amp;nbsp;iN}&lt;/code&gt; instead of &lt;code&gt;Genarray.get&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt;. (The syntax &lt;code&gt;a.{...}&lt;/code&gt; with one, two or three coordinates is reserved for accessing one-, two- and three-dimensional arrays as described below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="809bd12920c48726136236802722ab0be08e88f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has C layout, the coordinates must be greater or equal than 0 and strictly less than the corresponding dimensions of &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has Fortran layout, the coordinates must be greater or equal than 1 and less or equal than the corresponding dimensions of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4132333c30642f60620cc9c7ac94c15c80f1f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;d&lt;/code&gt; is greater or equal than the current margin, it is ignored, and the current maximum indentation limit is kept.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c0840202ac828ab864cc2fb33a9e5dc2f4e78e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;d&lt;/code&gt; is too large, the limit is set to the maximum admissible value (which is greater than &lt;code&gt;10&amp;nbsp;^&amp;nbsp;9&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ead1963ff555b5cb572c908c83e685f09cbbeebf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;Marshal.Compat_32&lt;/code&gt;, marshaling fails when it encounters an integer value outside the range &lt;code&gt;[-2{^30},&amp;nbsp;2{^30}-1]&lt;/code&gt; of integers that are representable on a 32-bit platform. This ensures that marshaled data generated on a 64-bit platform can be safely read back on a 32-bit platform. If &lt;code&gt;flags&lt;/code&gt; does not contain &lt;code&gt;Marshal.Compat_32&lt;/code&gt;, integer values outside the range &lt;code&gt;[-2{^30},&amp;nbsp;2{^30}-1]&lt;/code&gt; are marshaled, and can be read back on a 64-bit platform, but will cause an error at un-marshaling time when read back on a 32-bit platform. The &lt;code&gt;Mashal.Compat_32&lt;/code&gt; flag only matters when marshaling is performed on a 64-bit platform; it has no effect if marshaling is performed on a 32-bit platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3049c4d97c242e2115fb288272135a4ad280a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; does not contain &lt;code&gt;Marshal.Closures&lt;/code&gt;, marshaling fails when it encounters a functional value inside &lt;code&gt;v&lt;/code&gt;: only 'pure' data structures, containing neither functions nor objects, can safely be transmitted between different programs. If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;Marshal.Closures&lt;/code&gt;, functional values will be marshaled as a the position in the code of the program together with the values corresponding to the free variables captured in the closure. In this case, the output of marshaling can only be read back in processes that run exactly the same program, with exactly the same compiled code. (This is checked at un-marshaling time, using an MD5 digest of the code transmitted along with the code position.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1603f8892a112133f08e3aa42f06e2938ef7d3e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; does not contain &lt;code&gt;Marshal.No_sharing&lt;/code&gt;, circularities and sharing inside the value &lt;code&gt;v&lt;/code&gt; are detected and preserved in the sequence of bytes produced. In particular, this guarantees that marshaling always terminates. Sharing between values marshaled by successive calls to &lt;code&gt;Marshal.to_channel&lt;/code&gt; is neither detected nor preserved, though. If &lt;code&gt;flags&lt;/code&gt; contains &lt;code&gt;Marshal.No_sharing&lt;/code&gt;, sharing is ignored. This results in faster marshaling if &lt;code&gt;v&lt;/code&gt; contains no shared substructures, but may cause slower marshaling and larger byte representations if &lt;code&gt;v&lt;/code&gt; actually contains sharing, or even non-termination if &lt;code&gt;v&lt;/code&gt; contains cycles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c639bd784b8f54da115e8e01089e6eaa4c4437c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; raises an exception, both the exceptions passed to &lt;code&gt;fn&lt;/code&gt; and raised by &lt;code&gt;fn&lt;/code&gt; will be printed with their respective backtrace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c27e9ffbfb7a1b0d49335a6eaeccc52715afa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is nonnegative, &lt;code&gt;Digest.channel&amp;nbsp;ic&amp;nbsp;len&lt;/code&gt; reads &lt;code&gt;len&lt;/code&gt; characters from channel &lt;code&gt;ic&lt;/code&gt; and returns their digest, or raises &lt;code&gt;End_of_file&lt;/code&gt; if end-of-file is reached before &lt;code&gt;len&lt;/code&gt; characters are read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c13d957f65e898b543bbbae2d79a73a515bf1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; is nonnegative, &lt;code&gt;Digest.channel&amp;nbsp;ic&amp;nbsp;len&lt;/code&gt; reads &lt;code&gt;len&lt;/code&gt; characters from channel &lt;code&gt;ic&lt;/code&gt; and returns their digest, or raises &lt;code&gt;End_of_file&lt;/code&gt; if end-of-file is reached before &lt;code&gt;len&lt;/code&gt; characters are read. If &lt;code&gt;len&lt;/code&gt; is negative, &lt;code&gt;Digest.channel&amp;nbsp;ic&amp;nbsp;len&lt;/code&gt; reads all characters from &lt;code&gt;ic&lt;/code&gt; until end-of-file is reached and return their digest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c5226280b1d5d0eb026f180e4fc7ada42aef4f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;seq&amp;nbsp;=&amp;nbsp;[1;2;3]&lt;/code&gt;, then &lt;code&gt;map&amp;nbsp;f&amp;nbsp;seq&amp;nbsp;=&amp;nbsp;[f&amp;nbsp;1;&amp;nbsp;f&amp;nbsp;2;&amp;nbsp;f&amp;nbsp;3]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1398dea40559c8782ca5a31856feff2954ca0102" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shared&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, all modifications performed on the array are reflected in the file. This requires that &lt;code&gt;fd&lt;/code&gt; be opened with write permissions. If &lt;code&gt;shared&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, modifications performed on the array are done in memory only, using copy-on-write of the modified pages; the underlying file is not affected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e714373b0cf3d52636fccd7cd853dd106784943" translate="yes" xml:space="preserve">
          <source>If OCAMLRUNPARAM is not found in the environment, then CAMLRUNPARAM will be used instead. If CAMLRUNPARAM is also not found, then the default values will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e527c776a333861fa6472e7246947c15efddcc3" translate="yes" xml:space="preserve">
          <source>If OCAMLRUNPARAM is not found in the environment, then CAMLRUNPARAM will be used instead. If CAMLRUNPARAM is not found, then the default values will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52f378a118e070cfc5dc38fe1dedd97d46322a83" translate="yes" xml:space="preserve">
          <source>If a C primitive runs for a long time or performs potentially blocking input-output operations, it can explicitly release the master lock, enabling other OCaml threads to run concurrently with its operations. The C code must re-acquire the master lock before returning to OCaml. This is achieved with the following functions, declared in the include file &amp;lt;caml/threads.h&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="144bd9ae4b17d62ca7c4dd2000f8e45755b76c41" translate="yes" xml:space="preserve">
          <source>If a compatible dump file already exists in the current directory, then the profiling information is accumulated in this dump file. This allows, for instance, the profiling of several executions of a program on different inputs. Note that dump files produced by byte-code executables (compiled with ocamlcp) are compatible with the dump files produced by native executables (compiled with ocamloptp).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a268efd3934421fc54ada79e5bb503d1d9c1baf3" translate="yes" xml:space="preserve">
          <source>If a local definition occurs at the very beginning of a class definition, it will be evaluated when the class is created (just as if the definition was outside of the class). Otherwise, it will be evaluated when the object constructor is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db03536423f4f4f52cd6fcffd6bb81f40d46d972" translate="yes" xml:space="preserve">
          <source>If a module (.ml file) doesn&amp;rsquo;t have a corresponding interface (.mli file), then compiling it with ocamlcp will produce object files (.cmi and .cmo) that are not compatible with the ones produced by ocamlc, which may lead to problems (if the .cmi or .cmo is still around) when switching between profiling and non-profiling compilations. To avoid this problem, you should always have a .mli file for each .ml file. The same problem exists with ocamloptp.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361ced0e78aa187459f0f204ee3347fb375be201" translate="yes" xml:space="preserve">
          <source>If a parameter is specified as optional (label prefixed by ?) in the type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, the corresponding argument will be automatically wrapped with the constructor Some, except if the argument itself is also prefixed by ?, in which case it is passed as is. If a non-labeled argument is passed, and its corresponding parameter is preceded by one or several optional parameters, then these parameters are &lt;em&gt;defaulted&lt;/em&gt;, &lt;em&gt;i.e.&lt;/em&gt; the value None will be passed for them. All other missing parameters (without corresponding argument), both optional and non-optional, will be kept, and the result of the function will still be a function of these missing parameters to the body of f.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037083f7231a68d14836692b419032967beaefec" translate="yes" xml:space="preserve">
          <source>If all dimensions of the Bigarray are given, the file size is matched against the size of the Bigarray. If the file is larger than the Bigarray, only the initial portion of the file is mapped to the Bigarray. If the file is smaller than the big array, the file is automatically grown to the size of the Bigarray. This requires write permissions on &lt;code&gt;fd&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1ff51fc7a2f5a64a4761a8119a652dcd1f52ad5" translate="yes" xml:space="preserve">
          <source>If an allocation-tracking or promotion-tracking function returns &lt;code&gt;None&lt;/code&gt;, memprof stops tracking the corresponding value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c69093d47c505a2742c6e9e51b6c1bedfd5d8eaa" translate="yes" xml:space="preserve">
          <source>If an error occurs, &lt;code&gt;Arg.parse&lt;/code&gt; exits the program, after printing to standard error an error message as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7467ecdd482037d95bee094a12bc474e7d7c71fc" translate="yes" xml:space="preserve">
          <source>If dynamic linking is supported on the target platform, a .so (respectively, .dll) shared library built from the C object files given as arguments, and automatically referencing the support libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30089f87216cb371be1de9772b23268664fcb2e2" translate="yes" xml:space="preserve">
          <source>If filename has the format mod.cmi, this means you have referenced the compilation unit mod, but its compiled interface could not be found. Fix: compile mod.mli or mod.ml first, to create the compiled interface mod.cmi.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9686537313707922f0bda205e9360d942cceb1a" translate="yes" xml:space="preserve">
          <source>If filename has the format mod.cmo, this means you are trying to link a bytecode object file that does not exist yet. Fix: compile mod.ml first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2277b8c214def4154d2529e1b31435dc3cac3a" translate="yes" xml:space="preserve">
          <source>If filename has the format mod.cmo, this means you are trying to load with #load a bytecode object file that does not exist yet. Fix: compile mod.ml first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3b22a28469371f7e82ec0e9c892a2ff1b6f3dae" translate="yes" xml:space="preserve">
          <source>If filename is the name of a self-executable bytecode file, this means that either that file does not exist, or that it failed to run the ocamlrun bytecode interpreter on itself. The second possibility indicates that OCaml has not been properly installed on your system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bcfc607ddea008cb5d00122be6715bc9b44adf1" translate="yes" xml:space="preserve">
          <source>If inlining the function is not clearly beneficial, then inlining will be performed &lt;em&gt;speculatively&lt;/em&gt; inside the function itself. The search for speculative inlining possibilities is controlled by two parameters: the &lt;em&gt;inlining threshold&lt;/em&gt; and the &lt;em&gt;inlining depth&lt;/em&gt;. (These are described in more detail below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b44e70f5ebb940c1b0391784dfe69b24f75a37ab" translate="yes" xml:space="preserve">
          <source>If it does not split the line, then the &lt;code&gt;s1&lt;/code&gt; is emitted, then &lt;code&gt;n&lt;/code&gt; spaces, then &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e489f470887d376d32aea06970fd61f3751f9ee5" translate="yes" xml:space="preserve">
          <source>If it must be the case that code has to be written that triggers warning 59, but the code is known to actually be correct (for some definition of correct), then Sys.opaque_identity may be used to wrap the value before unsafe operations are performed upon it. Great care must be taken when doing this to ensure that the opacity is added at the correct place. It must be emphasised that this use of Sys.opaque_identity is only for exceptional cases. It should not be used in normal code or to try to guide the optimiser.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="686a1fa801a7187be3913a423d2506998f796f50" translate="yes" xml:space="preserve">
          <source>If it splits the line, then it emits the &lt;code&gt;s3&lt;/code&gt; string, then an indent (according to the box rules), then an offset of &lt;code&gt;m&lt;/code&gt; spaces, then the &lt;code&gt;s4&lt;/code&gt; string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72c5657376e07c2d9a3e4b1acbffce97186b2022" translate="yes" xml:space="preserve">
          <source>If n is zero or less, nothing happens.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f705b48d406f77c738cb668c2876820fc083247" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;~random&lt;/code&gt; parameter is given, hash tables are created in non-random mode by default. This default can be changed either programmatically by calling &lt;a href=&quot;hashtbl#VALrandomize&quot;&gt;&lt;code&gt;Hashtbl.randomize&lt;/code&gt;&lt;/a&gt; or by setting the &lt;code&gt;R&lt;/code&gt; flag in the &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; environment variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0c0ccea27bc9150aae629a6c3346f36d1efee2" translate="yes" xml:space="preserve">
          <source>If no element of &lt;code&gt;s&lt;/code&gt; is changed by &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt; is returned unchanged. (If each output of &lt;code&gt;f&lt;/code&gt; is physically equal to its input, the returned set is physically equal to &lt;code&gt;s&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eb7e9f1e3b33fc029b525d2db6314c65ae09453" translate="yes" xml:space="preserve">
          <source>If no element of &lt;code&gt;s&lt;/code&gt; is changed or dropped by &lt;code&gt;f&lt;/code&gt; (if &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;Some&amp;nbsp;x&lt;/code&gt; for each element &lt;code&gt;x&lt;/code&gt;), then &lt;code&gt;s&lt;/code&gt; is returned unchanged: the result of the function is then physically equal to &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf74767dc0fd113b13b0f693b209b1bddcc18bd" translate="yes" xml:space="preserve">
          <source>If no scriptfile is given on the command line, the toplevel system enters interactive mode: phrases are read on standard input, results are printed on standard output, errors on standard error. End-of-file on standard input terminates ocaml (see also the #quit directive in section &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00843a889b066ce4bbfdb0caf01e681f6e157c16" translate="yes" xml:space="preserve">
          <source>If not already set on a tabulation marker, the insertion point moves to the first tabulation marker on the right and the pretty-printer prints &lt;code&gt;nspaces&lt;/code&gt; spaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94467592d909a5e6ff672d3db0301b49ec0281fc" translate="yes" xml:space="preserve">
          <source>If scriptfile is given on the command-line to ocaml, the toplevel system enters script mode: the contents of the file are read as a sequence of OCaml phrases and executed, as per the #use directive (section &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;). The outcome of the evaluation is not printed. On reaching the end of file, the ocaml command exits immediately. No commands are read from standard input. Sys.argv is transformed, ignoring all OCaml parameters, and starting with the script file name in Sys.argv.(0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2363061063be15ef51f3f1a53b8b361078b64015" translate="yes" xml:space="preserve">
          <source>If several arguments of a function bear the same label (or no label), they will not commute among themselves, and order matters. But they can still commute with other arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96cd48975e8c5184733565898c33a2f04befd578" translate="yes" xml:space="preserve">
          <source>If several locally abstract types need to be introduced, it is possible to use the syntax fun(type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;)-&amp;gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; as syntactic sugar for fun(type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;)-&amp;gt; &amp;hellip; -&amp;gt;fun(type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;)-&amp;gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;. For instance,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10affbc46bccdf7827eee5ed3b04a7a8c3bd654" translate="yes" xml:space="preserve">
          <source>If several patterns match the argument v, the one that occurs first in the function definition is selected. If none of the patterns matches the argument, the exception Match_failure is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebba3b8dc9a7c52a91ba9cffdda6fc1e415cedf9" translate="yes" xml:space="preserve">
          <source>If several regular expressions match a prefix of the input, the &amp;ldquo;longest match&amp;rdquo; rule applies: the regular expression that matches the longest prefix of the input is selected. In case of tie, the regular expression that occurs earlier in the rule is selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33304e670e9c468dea25676c51b9d5272c2372ac" translate="yes" xml:space="preserve">
          <source>If several specifications are present for the same method, they must have compatible types. Any non-private specification of a method forces it to be public.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e1e876c6319fc9f155e179bfdf47b95b75ca18" translate="yes" xml:space="preserve">
          <source>If shared libraries are not supported, the following commands are performed instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba2e2086c5f2a5e933519c52e53ae93fb624fa5d" translate="yes" xml:space="preserve">
          <source>If shared libraries are supported, this performs the following commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13e2923fd0864337da7b7bba91620b61b5fbb40a" translate="yes" xml:space="preserve">
          <source>If such a suffix does not exist, &lt;code&gt;extension&amp;nbsp;name&lt;/code&gt; is the empty string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8535daa443a5878fa88dbc8284c870ced5360d87" translate="yes" xml:space="preserve">
          <source>If such speculation shows that performing some inlining inside the function would be beneficial, then such inlining is performed and the resulting function inlined at the original call site.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35d741725edfca4bf5d082c545ffd10d25a7dc01" translate="yes" xml:space="preserve">
          <source>If the -inlining-report option is provided to the compiler then a file will be emitted corresponding to each round of optimisation. For the OCaml source file &lt;em&gt;basename&lt;/em&gt;.ml the files are named &lt;em&gt;basename&lt;/em&gt;.&lt;em&gt;round&lt;/em&gt;.inlining.org, with &lt;em&gt;round&lt;/em&gt; a zero-based integer. Inside the files, which are formatted as &amp;ldquo;org mode&amp;rdquo;, will be found English prose describing the decisions that the inliner took.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02572179ec480974381c99532d430d9fdd5784e0" translate="yes" xml:space="preserve">
          <source>If the C code wishes to catch exceptions escaping the OCaml function, it can use the functions caml_callback_exn, caml_callback2_exn, caml_callback3_exn, caml_callbackN_exn. These functions take the same arguments as their non-_exn counterparts, but catch escaping exceptions and return them to the C code. The return value v of the caml_callback*_exn functions must be tested with the macro Is_exception_result(v). If the macro returns &amp;ldquo;false&amp;rdquo;, no exception occurred, and v is the value returned by the OCaml function. If Is_exception_result(v) returns &amp;ldquo;true&amp;rdquo;, an exception escaped, and its value (the exception descriptor) can be recovered using Extract_exception(v).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="630c7dca602616b8abb79db5171a1e3090693e64" translate="yes" xml:space="preserve">
          <source>If the OCaml function returned with an exception, Extract_exception should be applied to the exception result prior to calling a function that may trigger garbage collection. Otherwise, if v is reachable during garbage collection, the runtime can crash since v does not contain a valid value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b4dadfc6f13fd380794c2f3f44ed17e6443186" translate="yes" xml:space="preserve">
          <source>If the argument is true, check information paths during type-checking, to make sure that all types are derived in a principal way. If the argument is false, do not check information paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1a5cad8cc059522a4fee23706b19131d9a15d23" translate="yes" xml:space="preserve">
          <source>If the array is of size four or less, the expression will create a fresh block and write the values into it one by one. There is no reference to the initialising array as a whole.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87ba360226aef14289ad1c74a68816339b211735" translate="yes" xml:space="preserve">
          <source>If the call is not inside an exception handler, the returned backtrace is unspecified. If the call is after some exception-catching code (before in the handler, or in a when-guard during the matching of the exception handler), the backtrace may correspond to a later exception than the handled one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3699887b7248910d086e978d7aa47ea89c5f6bf9" translate="yes" xml:space="preserve">
          <source>If the computation of &lt;code&gt;x&lt;/code&gt; raises an exception, it is unspecified whether &lt;code&gt;force_val&amp;nbsp;x&lt;/code&gt; raises the same exception or &lt;a href=&quot;lazy#EXCEPTIONUndefined&quot;&gt;&lt;code&gt;Lazy.Undefined&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9cc33d7f4560db5b0839b107c0565d6921cb731" translate="yes" xml:space="preserve">
          <source>If the contents of the global variable v are seldom modified after registration, better performance can be achieved by calling caml_register_generational_global_root(&amp;amp;v) to register v (after its initialization with a valid value, but before any allocation or call to the GC functions), and caml_remove_generational_global_root(&amp;amp;v) to un-register it. In this case, you must not modify the value of v directly, but you must use caml_modify_generational_global_root(&amp;amp;v,x) to set it to x. The garbage collector takes advantage of the guarantee that v is not modified between calls to caml_modify_generational_global_root to scan it less often. This improves performance if the modifications of v happen less often than minor collections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bd80053dd21abc2f1786fb591aa8cce37e37cef" translate="yes" xml:space="preserve">
          <source>If the element is a custom block it is not copied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86e7bd7a523ed97a9611f3d74bd5a6534bba8424" translate="yes" xml:space="preserve">
          <source>If the environment variable OCAMLPROF_DUMP is set when the program exits, its value is used as the file name instead of ocamlprof.dump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59b3e7898281ba717abfe0d4e0cfd223c49314a7" translate="yes" xml:space="preserve">
          <source>If the estimated benefit exceeds the increase in code size then the inlined version of the function will be kept. Otherwise the function will not be inlined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="526eae114b014fd19cf9658190d7f52e6cfa38d8" translate="yes" xml:space="preserve">
          <source>If the first form is used, with a single integer specified, the value will apply to all rounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="928707051883035a6a2490616c9c4666b3b8054b" translate="yes" xml:space="preserve">
          <source>If the format &lt;code&gt;fmt&lt;/code&gt; has some &lt;code&gt;%r&lt;/code&gt; indications, the corresponding formatted input functions must be provided &lt;em&gt;before&lt;/em&gt; receiver function &lt;code&gt;f&lt;/code&gt;. For instance, if &lt;code&gt;read_elem&lt;/code&gt; is an input function for values of type &lt;code&gt;t&lt;/code&gt;, then &lt;code&gt;bscanf&amp;nbsp;ic&amp;nbsp;&quot;%r;&quot;&amp;nbsp;read_elem&amp;nbsp;f&lt;/code&gt; reads a value &lt;code&gt;v&lt;/code&gt; of type &lt;code&gt;t&lt;/code&gt; followed by a &lt;code&gt;';'&lt;/code&gt; character, and returns &lt;code&gt;f&amp;nbsp;v&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaebb55224d923b372338ae66433b2e72d6c1dbb" translate="yes" xml:space="preserve">
          <source>If the function f does not return, but raises an exception that escapes the scope of the application, then this exception is propagated to the next enclosing OCaml code, skipping over the C code. That is, if an OCaml function f calls a C function g that calls back an OCaml function h that raises a stray exception, then the execution of g is interrupted and the exception is propagated back into f.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83eb3ec9e1e3f016668f3beedc828600400ab1c4" translate="yes" xml:space="preserve">
          <source>If the function in question is involved in a recursive group then unboxing of specialised arguments may be immediately replicated across the group based on the dataflow between invariant arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2217874359b71d84901f80859119f98479923fa3" translate="yes" xml:space="preserve">
          <source>If the given directory starts with +, it is taken relative to the standard library directory. For instance, -I +unix adds the subdirectory unix of the standard library to the search path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031818e3fc1bf521466078fbb8e8be0fa0c0fb91" translate="yes" xml:space="preserve">
          <source>If the hash table was created in non-randomized mode, the order in which the bindings are enumerated is reproducible between successive runs of the program, and even between minor versions of OCaml. For randomized hash tables, the order of enumeration is entirely random.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cea4ad36d0decb77c4fb5241f963c83815372664" translate="yes" xml:space="preserve">
          <source>If the interface file x.mli exists, the implementation x.ml is checked against the corresponding compiled interface x.cmi, which is assumed to exist. If no interface x.mli is provided, the compilation of x.ml produces a compiled interface file x.cmi in addition to the compiled object code file x.cmo. The file x.cmi produced corresponds to an interface that exports everything that is defined in the implementation x.ml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269f2549d5b0381849a3b6047e9fc8dbb8d0667d" translate="yes" xml:space="preserve">
          <source>If the libunwind library is not available on the system then it will not be possible for Spacetime to profile allocations occurring within C stubs. If the libunwind library is available but in an unusual location then that location may be specified to the configure script using the -libunwinddir option (or alternatively, using separate -libunwindinclude and -libunwindlib options).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60d15c75ed47033c0e5c57361e18bc1a28cba287" translate="yes" xml:space="preserve">
          <source>If the make install command is run after having built the native toplevel then the ocamlnat program (either from the source or the installation directory) may be invoked directly rather than using make natruntop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57209cae8f03f39e03c3475e4a102e0e7a017631" translate="yes" xml:space="preserve">
          <source>If the named file is a directory, raises:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfd36587a150830740da4e5b8e12155c63eb3d08" translate="yes" xml:space="preserve">
          <source>If the option letter is not recognized, the whole parameter is ignored; if the equal sign or the number is missing, the value is taken as 1; if the multiplier is not recognized, it is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6cd58692278da4b786278a83770b1d8a2642045" translate="yes" xml:space="preserve">
          <source>If the pretty-printer splits the line in the box, &lt;code&gt;d&lt;/code&gt; is added to the current indentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ef6acdf03d0f87940ead45d51f79d17fc14180f" translate="yes" xml:space="preserve">
          <source>If the pretty-printer splits the line in the box, offset &lt;code&gt;d&lt;/code&gt; is added to the current indentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361c4ed6a2a48ff1b42271ec1d3dc181183d0467" translate="yes" xml:space="preserve">
          <source>If the pretty-printer splits the line, &lt;code&gt;offset&lt;/code&gt; is added to the current indentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4599aba8403a5552d8717f0e5fce41f734d86310" translate="yes" xml:space="preserve">
          <source>If the previous command has been successful, a blank line (typing just RET) will repeat it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0350c5cb5c18afaa3af79f9ae281828c0226be68" translate="yes" xml:space="preserve">
          <source>If the remaining arguments to process are of the form &lt;code&gt;[&quot;-foo&quot;;&amp;nbsp;&quot;arg&quot;]&amp;nbsp;@&amp;nbsp;rest&lt;/code&gt; where &quot;foo&quot; is registered as &lt;code&gt;Expand&amp;nbsp;f&lt;/code&gt;, then the arguments &lt;code&gt;f&amp;nbsp;&quot;arg&quot;&amp;nbsp;@&amp;nbsp;rest&lt;/code&gt; are processed. Only allowed in &lt;code&gt;parse_and_expand_argv_dynamic&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3dc02053bcf7f04a6a9f0b8d70f87bdfcc90ced" translate="yes" xml:space="preserve">
          <source>If the second form is used, zero-based &lt;em&gt;round&lt;/em&gt; integers specify values which are to be used only for those rounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23147d67da9a3357fd714ad7bd712b354fdbe027" translate="yes" xml:space="preserve">
          <source>If the type [('a,'b,&amp;hellip;)] &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; = [`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;| &amp;hellip; |`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] is defined, then the pattern #&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; is a shorthand for the following or-pattern: (`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;(_:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;)| &amp;hellip; |`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;(_:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;)). It matches all values of type [&amp;lt;&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6934c8c175e921d36d82df098f9aaaaba6060c8a" translate="yes" xml:space="preserve">
          <source>If the value of its argument its None, the printer returned by pp_option printer prints None otherwise it uses the provided printer to print Some .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02bfb791a4aefd529589de31a34af8d62fb05206" translate="yes" xml:space="preserve">
          <source>If there are no safe modules along a dependency cycle, an error is raised</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a28412182364c49d7b1c7ff896cdb24ffe2090a" translate="yes" xml:space="preserve">
          <source>If there is no next tabulation marker on the right, the pretty-printer splits the line at this point, then insertion point moves to the leftmost tabulation marker of the box.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e986ba889d48b83a3b585c29a13d802a48e88f" translate="yes" xml:space="preserve">
          <source>If there is no special character in the argument that needs escaping, return the original string itself, not a copy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="650636821137156f9b89bf7d83008b87c146680c" translate="yes" xml:space="preserve">
          <source>If using automatic snapshots the presence of the &lt;code&gt;save_event_for_automatic_snapshots&lt;/code&gt; function, below, should be noted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af7f9f8dc289a45aa7abb853b1e6e0f99bdabaa2" translate="yes" xml:space="preserve">
          <source>If v is a OCaml value representing a Bigarray, the expression Caml_ba_data_val(v) returns a pointer to the data part of the array. This pointer is of type void * and can be cast to the appropriate C type for the array (e.g. double [], char [][10], etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57d1cd0be66bfd79fceee72f6e460b8f16042be" translate="yes" xml:space="preserve">
          <source>If we ignore labels, which will only be meaningful at function application, this is equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a12dddd1ed24396bf32965cc98f1c85d9b5a043d" translate="yes" xml:space="preserve">
          <source>If we were able to coerce x to the type xy ref as a variable xy, we could use xy to store the value `Y inside the reference and then use the x value to read this content as a value of type x, which would break the type system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="938dc89ad7bb75f8b6b5234d0f82aeee4a2b6b87" translate="yes" xml:space="preserve">
          <source>If you are using internal C variables, do not redefine them by hand. You should import those variables by including the corresponding header files. The representation of those variables has already changed once in OCaml 4.10, and is still under evolution. If your code relies on such internal and brittle properties, it will be broken at some point in time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4684963cdc7330d90fbde44bf1de388d5ea4d30c" translate="yes" xml:space="preserve">
          <source>If you are using the native-code compiler ocamlopt, the -custom flag is not needed, as the final linking phase of ocamlopt always builds a standalone executable. To build a mixed OCaml/C executable, execute the ocamlopt command with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e51a95e1449f47a9a997884fd92f2e9640f19f" translate="yes" xml:space="preserve">
          <source>If you are using the opam package manager, you should install the corresponding graphics package:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e2b19145c81285ba95d5206a4aef01e47305c6b" translate="yes" xml:space="preserve">
          <source>If you choose to use the compatibility library, you must link your programs as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7aae036d3d0305ff1e81bf7e09e7219b84487d6" translate="yes" xml:space="preserve">
          <source>If you have a look at modules ending in Labels in the standard library, you will see that function types have annotations you did not have in the functions you defined yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8ec7283da5154d3c5f9741853ea4731d05f757" translate="yes" xml:space="preserve">
          <source>If you really need name to have a polymorphic type, turn its defining expression into a function by adding an extra parameter. For instance, instead of writing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc2b54b4fe8b9babd50993b19aa3de4b1112f06" translate="yes" xml:space="preserve">
          <source>If you really need to allocate before the fields can receive their final value, first initialize with a constant value (e.g. Val_unit), then allocate, then modify the fields with the correct value (see rule 6).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a4f00d7d346ec3d9a159649e84ffda00feee562" translate="yes" xml:space="preserve">
          <source>If you use module aliases to give shorter names to modules, you need to change the above definitions. Assuming that your map file is called mylib.mli, here are minimal modifications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="445ff9fe29411614baa1aba0c77e6b3c07963936" translate="yes" xml:space="preserve">
          <source>If your code raises this warning, you should &lt;em&gt;not&lt;/em&gt; change the way you test for the specific string to avoid the warning (for example using a string equality inside the right-hand-side instead of a literal pattern), as your code would remain fragile. You should instead enlarge the scope of the pattern by matching on all possible values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87ed6fde2df7c4b454ca4c9bbdd14667b228435" translate="yes" xml:space="preserve">
          <source>If your finalized blocks contain no pointers to out-of-heap resources, or if the previous discussion made little sense to you, just take used = 0 and max = 1. But if you later find that the finalization functions are not called &amp;ldquo;often enough&amp;rdquo;, consider increasing the used / max ratio.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192602c36fe264c7bb72e181d69fc51ec2ab7ac6" translate="yes" xml:space="preserve">
          <source>If your program spans several directories, this error can also appear because you haven&amp;rsquo;t specified the directories to look into. Fix: add the correct -I options to the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4413f87552659e0c51237304101e749ef0f1523" translate="yes" xml:space="preserve">
          <source>If your program spans several directories, this error can also appear because you haven&amp;rsquo;t specified the directories to look into. Fix: use the #directory directive to add the correct directories to the search path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04dca8ad26b4c54518389383583f6a6c77bac6ff" translate="yes" xml:space="preserve">
          <source>Ignore CR on input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5bdb39e4b8dd017918a8e726872a7f1642a7810" translate="yes" xml:space="preserve">
          <source>Ignore characters with parity errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c2318243f67f315a4b8a9f29efe92c076e89ddd" translate="yes" xml:space="preserve">
          <source>Ignore labels in function types if argument is false, or switch back to default behaviour (commuting style) if argument is true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="236cc3c9f521b0fbfe59c2c79bd30f8c85081542" translate="yes" xml:space="preserve">
          <source>Ignore modem status lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc25631b490cc9dc3eae61a416673381002ebaea" translate="yes" xml:space="preserve">
          <source>Ignore non-optional labels in types.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8221a4e278c3aef5f3541066115c1b84f80bf481" translate="yes" xml:space="preserve">
          <source>Ignore non-optional labels in types. Labels cannot be used in applications, and parameter order becomes strict.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f8ed3358c226fa964cfafc27575cd3a5ffdead1" translate="yes" xml:space="preserve">
          <source>Ignore the break condition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73e3cd2bf31dccb18ec366d4ab12d7eebaea2ee2" translate="yes" xml:space="preserve">
          <source>Illegal attribute payload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e292013c5db7783c6e4d84fc6547a66bca7ad0b" translate="yes" xml:space="preserve">
          <source>Illegal backslash escape in a string constant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a2a7f348bbdc4825046979cfd8b768f4fac13a7" translate="yes" xml:space="preserve">
          <source>Immediate objects have two weaknesses compared to classes: their types are not abbreviated, and you cannot inherit from them. But these two weaknesses can be advantages in some situations, as we will see in sections &lt;a href=&quot;#s%3Areference-to-self&quot;&gt;3.3&lt;/a&gt; and &lt;a href=&quot;#s%3Aparameterized-classes&quot;&gt;3.10&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54ba8c8554c6b105de4bb1e2e2bd6ecba60273ca" translate="yes" xml:space="preserve">
          <source>Implementing a user primitive is actually two separate tasks: on the one hand, decoding the arguments to extract C values from the given OCaml values, and encoding the return value as an OCaml value; on the other hand, actually computing the result from the arguments. Except for very simple primitives, it is often preferable to have two distinct C functions to implement these two tasks. The first function actually implements the primitive, taking native C values as arguments and returning a native C value. The second function, often called the &amp;ldquo;stub code&amp;rdquo;, is a simple wrapper around the first function that converts its arguments from OCaml values to C values, call the first function, and convert the returned C value to OCaml value. For instance, here is the stub code for the input primitive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30dd7b027ecbf0176e983b1c6d8e3ff43f86ac1a" translate="yes" xml:space="preserve">
          <source>Implementing sets leads to another difficulty. Indeed, the method union needs to be able to access the internal representation of another object of the same class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb06de5305a8cd588b4b2090243c7c818837829e" translate="yes" xml:space="preserve">
          <source>Implicit elimination of optional arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9320eec5e654eb93a5ec38ac96a5b6831671bb90" translate="yes" xml:space="preserve">
          <source>Impose the given protocol</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f84f9ef20beeb6870c2739752e2d02c1ffd0734c" translate="yes" xml:space="preserve">
          <source>Impose the given socket domain</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49c1a4ccb12bf83d3c389505eddce7022eb2d2f8" translate="yes" xml:space="preserve">
          <source>Impose the given socket type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f01d5e440fa709806dd2194e638ac6c655d4223" translate="yes" xml:space="preserve">
          <source>In -Oclassic mode the behaviour of the Flambda inliner mimics previous versions of the compiler. (Code may still be subject to further optimisations not performed by previous versions of the compiler: functors may be inlined, constants are lifted and unused code is eliminated all as described elsewhere in this chapter. See sections &lt;a href=&quot;#sss%3Aflambda-functors&quot;&gt;21.3.3&lt;/a&gt;, &lt;a href=&quot;#ss%3Aflambda-lift-const&quot;&gt;21.8.1&lt;/a&gt; and &lt;a href=&quot;#s%3Aflambda-remove-unused&quot;&gt;21.10&lt;/a&gt;. At the definition site of a function, the body of the function is measured. It will then be marked as eligible for inlining (and hence inlined at every direct call site) if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b7e88e3104809cced60ca047035fc79d790e127" translate="yes" xml:space="preserve">
          <source>In OCaml, compilation units are special cases of structures and signatures, and the relationship between the units can be explained easily in terms of the module system. A compilation unit A comprises two files:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="145f72b5a6e94195611949a3aeaa2a7ac11729f1" translate="yes" xml:space="preserve">
          <source>In OCaml, there are two ways to introduce this kind of explicit universally quantified types: universally quantified record fields,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc3a2778a1685965f7577f444b98e2832d2ae8ce" translate="yes" xml:space="preserve">
          <source>In a class body, the pattern (&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;] ) is matched against self, therefore providing a binding for self and self type. Self can only be used in method and initializers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70397c150edca7640c04b63beb83552a9ba1f06e" translate="yes" xml:space="preserve">
          <source>In a module, there must not be two classes, two class types or a class and a class type with the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40aee30082742b60c78c6aa0f902e60e3255ab7f" translate="yes" xml:space="preserve">
          <source>In a module, there must not be two modules, two module types or a module and a module type with the same name. In the default HTML generator, modules ab and AB will be printed to the same file on case insensitive file systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7e6cfb9260eacd797ec6d4742da8c29b966e366" translate="yes" xml:space="preserve">
          <source>In a module, there must not be two values, two types, or two exceptions with the same name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eaaa21ac3ef3ccade4409a2792f201883504cc8" translate="yes" xml:space="preserve">
          <source>In absence of an explicit polymorphic annotation, a monomorphic type is inferred for the recursive function. If a recursive call occurs inside the function definition at a type that involves an existential GADT type variable, this variable flows to the type of the recursive function, and thus escapes its scope. In the above example, this happens in the branch App(f,x) when eval is called with f as an argument. In this branch, the type of f is ($App_ 'b-&amp;gt; a). The prefix $ in $App_ 'b denotes an existential type named by the compiler (see &lt;a href=&quot;#p%3Aexistential-names&quot;&gt;8.10&lt;/a&gt;). Since the type of eval is 'a term -&amp;gt; 'a, the call eval f makes the existential type $App_'b flow to the type variable 'a and escape its scope. This triggers the above error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83a4780fdda72224bf7c404686bee6b0dd38a00f" translate="yes" xml:space="preserve">
          <source>In addition to integers and floating-point numbers, OCaml offers the usual basic data types:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f1c1d50be627c43f3ca0ba8417dadf3c27859e0" translate="yes" xml:space="preserve">
          <source>In addition to program documentation, class interfaces can be used to constrain the type of a class. Both concrete instance variables and concrete private methods can be hidden by a class type constraint. Public methods and virtual members, however, cannot.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff972760c30a42809d4bcb7b88b56d292a034872" translate="yes" xml:space="preserve">
          <source>In addition, Emacs displays the source files containing the current event (the current position in the program execution) and highlights the location of the event. This display is updated synchronously with the debugger action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7116193945dcb705fd31b47667c53f6ed878fa4" translate="yes" xml:space="preserve">
          <source>In addition, the following options are recognized:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a9d67825df2ad654535d9305a175a49c2e92ae" translate="yes" xml:space="preserve">
          <source>In all buffers in OCaml editing mode, the following debugger commands are also available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34fa2ed3ea28bd96a31c074309c173fda8ea3d66" translate="yes" xml:space="preserve">
          <source>In all cases but exact match of order and labels, without optional parameters, the function type should be known at the application point. This can be ensured by adding a type constraint. Principality of the derivation can be checked in the -principal mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df4f3c4b7e3901c28cc625ce0fcca37b5cf5b16" translate="yes" xml:space="preserve">
          <source>In all three cases, tags may be either specified directly in the `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; [of&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;] form, or indirectly through a type expression, which must expand to an exact variant type, whose tag specifications are inserted in its place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7baa740e37d7218dfa915e6dbf869155b1be9ec" translate="yes" xml:space="preserve">
          <source>In an attempt to write the type constraint above more elegantly, one may wish to name the signature of the structure returned by the functor, then use that signature in the constraint:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a30f385b51a5770584633407723813633df87fa2" translate="yes" xml:space="preserve">
          <source>In both cases, at least one of the integer and fractional parts must be given; the exponent part is optional.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeab98a5938308a7ca7c5d621826d698eeb35974" translate="yes" xml:space="preserve">
          <source>In both cases, the whole for expression evaluates to the unit value ().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb7d81806d62938e65661891480f3bf1c340bdef" translate="yes" xml:space="preserve">
          <source>In bytecode, the identity function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eef554bc6e9693f24dc173cd6cec6650313f5d0" translate="yes" xml:space="preserve">
          <source>In bytecode, the identity function. In native code, replace the last extension with &lt;code&gt;.cmxs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a627abf55d958271115777925dd0ee4cea9f6d0" translate="yes" xml:space="preserve">
          <source>In bytecode: load the given bytecode object file (&lt;code&gt;.cmo&lt;/code&gt; file) or bytecode library file (&lt;code&gt;.cma&lt;/code&gt; file), and link it with the running program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1240e451018dbc380a6a35faaf32c3363a7ae3c" translate="yes" xml:space="preserve">
          <source>In bytecode: load the given bytecode object file (&lt;code&gt;.cmo&lt;/code&gt; file) or bytecode library file (&lt;code&gt;.cma&lt;/code&gt; file), and link it with the running program. In native code: load the given OCaml plugin file (usually &lt;code&gt;.cmxs&lt;/code&gt;), and link it with the running program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05a5ebf291f79b9d8204d27a74aaf7e66a3bd26" translate="yes" xml:space="preserve">
          <source>In case of interactive use, each phrase is executed in the initial state of the standard pretty-printer: after each phrase execution, the interactive system closes all open pretty-printing boxes, flushes all pending text, and resets the standard pretty-printer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4492c5d50795eada8a5ec4ba7632113061a4720c" translate="yes" xml:space="preserve">
          <source>In case of multiple and related calls to &lt;code&gt;sprintf&lt;/code&gt; to output material on a single string, you should consider using &lt;code&gt;fprintf&lt;/code&gt; with the predefined formatter &lt;code&gt;str_formatter&lt;/code&gt; and call &lt;code&gt;flush_str_formatter&amp;nbsp;()&lt;/code&gt; to get the final result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d2984bfe0a6d541921bf01ae808e7774f69005e" translate="yes" xml:space="preserve">
          <source>In case the shared library produced with -output-obj is to be loaded and unloaded repeatedly by a single process, care must be taken to unload the OCaml runtime explicitly, in order to avoid various system resource leaks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44b7cbadbf1b0a98e780a49d929bc95e7c7a1618" translate="yes" xml:space="preserve">
          <source>In conclusion: dynamic linking is highly recommended under the native Windows port, because there are no portability problems and it is much more convenient for the end users. Under Unix, dynamic linking should be considered for mature, frequently used libraries because it enhances platform-independence of bytecode executables. For new or rarely-used libraries, static linking is much simpler to set up in a portable way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d29d579e5fcb07ee03fdf350892fb2426fe79f73" translate="yes" xml:space="preserve">
          <source>In earlier versions of OCaml, it was possible to use word-aligned pointers to addresses outside the heap as OCaml values, just by casting the pointer to type value. Starting with OCaml 4.11, this usage is deprecated and will stop being supported in OCaml 5.00.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93d3688e1bbb7be44366be8e265ab0e92df16094" translate="yes" xml:space="preserve">
          <source>In error recovery mode, the parser discards states from the stack until it reaches a place where the error token can be shifted. It then discards tokens from the input until it finds three successive tokens that can be accepted, and starts processing with the first of these. If no state can be uncovered where the error token can be shifted, then the parser aborts by raising the Parsing.Parse_error exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0052f286e501146744357d1f715c84752a4801d2" translate="yes" xml:space="preserve">
          <source>In fact, Oo.copy p will behave as p#copy assuming that a public method copy with body {&amp;lt; &amp;gt;} has been defined in the class of p.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88b998217306cf98a0431358725952a2c40a0011" translate="yes" xml:space="preserve">
          <source>In general, the module expression (val&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) cannot be used in the body of a functor, because this could cause unsoundness in conjunction with applicative functors. Since OCaml 4.02, this is relaxed in two ways: if &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; does not contain nominal type declarations (&lt;em&gt;i.e.&lt;/em&gt; types that are created with a proper identity), then this expression can be used anywhere, and even if it contains such types it can be used inside the body of a generative functor, described in section &lt;a href=&quot;generativefunctors#s%3Agenerative-functors&quot;&gt;8.15&lt;/a&gt;. It can also be used anywhere in the context of a local module binding letmodule&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;=(val&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;)in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5c98ff88089f23a3d0986fcd57f4fffdbd72c5c" translate="yes" xml:space="preserve">
          <source>In last resort, if there is not enough information to disambiguate between different fields or constructors, Ocaml picks the last defined type amongst all locally valid choices:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6bffcb3669ad49ba8135b0e8be4c55178bd1806" translate="yes" xml:space="preserve">
          <source>In many places, OCaml makes a distinction between capitalized identifiers and identifiers that begin with a lowercase letter. The underscore character is considered a lowercase letter for this purpose.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="216e9b10a826eed18b60a2c7b92a349ea1836a4e" translate="yes" xml:space="preserve">
          <source>In method m1, o must be an object with at least a method n1, itself polymorphic. In method m2, the argument of n2 and x must have the same type, which is quantified at the same level as 'a.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4879ead4b7fe51c64df3dc284efd5b46cf97cbb" translate="yes" xml:space="preserve">
          <source>In more detail, at each call site the following procedure is followed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a5218af84a08375004a9b8c8f30976425e0ea1" translate="yes" xml:space="preserve">
          <source>In native code this function does not allocate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46e607d66b5b324deff28adfb00c36b67e461bd5" translate="yes" xml:space="preserve">
          <source>In normal operation, a mixed OCaml/C program starts by executing the OCaml initialization code, which then may proceed to call C functions. We say that the main program is the OCaml code. In some applications, it is desirable that the C code plays the role of the main program, calling OCaml functions when needed. This can be achieved as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d6c0bbded532eaac460fed9f095eb72cfd28e5f" translate="yes" xml:space="preserve">
          <source>In order to be able to run the garbage collector in the middle of a C function, the OCaml native-code compiler generates some bookkeeping code around C calls. Technically it wraps every C call with the C function caml_c_call which is part of the OCaml runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="705f0d7e5ce98c35ddf45a8b90e4166d527197ef" translate="yes" xml:space="preserve">
          <source>In order to properly delimit printed entities, a semantic tag must be opened before and closed after the entity. Semantic tags must be properly nested like parentheses using &lt;a href=&quot;format#VALpp_open_stag&quot;&gt;&lt;code&gt;Format.pp_open_stag&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;format#VALpp_close_stag&quot;&gt;&lt;code&gt;Format.pp_close_stag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c99bae7df15a0847fae04eb1c0499dc97289ad36" translate="yes" xml:space="preserve">
          <source>In other words, x :&amp;gt; xy implies that x list :&amp;gt; xy list, therefore the type constructor 'a list is covariant (it preserves subtyping) in its parameter 'a.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5f46ca739529e04a39f1aab5af3dba32a684971" translate="yes" xml:space="preserve">
          <source>In particular this multi-index notation makes it possible to uniformly handle indexing Genarray and other implementations of multidimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aab86acd922ebcbea9163dc56fc9283939f580d" translate="yes" xml:space="preserve">
          <source>In particular, Main can refer to Aux: the definitions and declarations contained in Main.ml and Main.mli can refer to definition in Aux.ml, using the Aux.ident notation, provided these definitions are exported in Aux.mli.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0710f72489debbe41f038cbacd70ca72e1c4ed" translate="yes" xml:space="preserve">
          <source>In particular, all built-in exceptions with a string argument have this attribute set: Invalid_argument, Failure, Sys_error will all raise this warning if you match for a specific string argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b074470bc685e81d978d3c12fec323bc92cacce4" translate="yes" xml:space="preserve">
          <source>In particular, if you want a regular expression that matches a single backslash character, you need to quote it in the argument to &lt;code&gt;regexp&lt;/code&gt; (according to the last item of the list above) by adding a second backslash. Then you need to quote both backslashes (according to the syntax of string constants in OCaml) by doubling them again, so you need to write four backslash characters: &lt;code&gt;Str.regexp&amp;nbsp;&quot;\\\\&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f7e072637e54b00ab8fa95f737650edcfbf010b" translate="yes" xml:space="preserve">
          <source>In particular, it is forbidden to change any value (for example using Obj.set_field or Obj.set_tag) that is not mutable. (Values returned from C stubs are always treated as mutable.) The compiler will emit warning 59 if it detects such a write&amp;mdash;but it cannot warn in all cases. Here is an example of code that will trigger the warning:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ade5ca771cb6e9b09d87215a726868aac65e1c3f" translate="yes" xml:space="preserve">
          <source>In particular, this does not require the knowledge of the implementation of the method deposit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5fc135baac0c5f362e717cdfa21fa7d3c9fdb0d" translate="yes" xml:space="preserve">
          <source>In practice, first define a symbolic output buffer &lt;code&gt;b&lt;/code&gt; using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="071912257bcdf51deb295b9dfc5fee29b88e66d1" translate="yes" xml:space="preserve">
          <source>In practice, such problems appear mostly when using objects whose methods have optional arguments, so that writing the type of object arguments is often a good idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="231cbc44094ac9d8485720744f05b0f46784e83e" translate="yes" xml:space="preserve">
          <source>In practice, type inference is a bit more clever than that: type annotations do not need to be immediately on the pattern-matching, and the types do not have to be always closed. As a result, it is usually enough to only annotate functions, as in the example above. Type annotations are propagated in two ways: for the scrutinee, they follow the flow of type inference, in a way similar to polymorphic methods; for the return type, they follow the structure of the program, they are split on functions, propagated to all branches of a pattern matching, and go through tuples, records, and sum types. Moreover, the notion of ambiguity used is stronger: a type is only seen as ambiguous if it was mixed with incompatible types (equated by constraints), without type annotations between them. For instance, the following program types correctly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ec2dc15612b4e9552fe86a4c1e5b9778f4b360" translate="yes" xml:space="preserve">
          <source>In practice, unique ownership of string values is extremely difficult to reason about correctly. You should always assume strings are shared, never uniquely owned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="675c86cc7771a8adaaf8916ec39061e81a549695" translate="yes" xml:space="preserve">
          <source>In presence of a refutation case, the exhaustiveness check will first compute the intersection of the pattern with the complement of the cases preceding it. It then checks whether the resulting patterns can really match any concrete values by trying to type-check them. Wild cards in the generated patterns are handled in a special way: if their type is a variant type with only GADT constructors, then the pattern is split into the different constructors, in order to check whether any of them is possible (this splitting is not done for arguments of these constructors, to avoid non-termination). We also split tuples and variant types with only one case, since they may contain GADTs inside. For instance, the following code is deemed exhaustive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5162e7ccdac1a4d75bd7ab724a1804dfb5ac71c9" translate="yes" xml:space="preserve">
          <source>In programs, polymorphic variants work like usual ones. You just have to prefix their names with a backquote character `.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e52f850e1e21d53f51e85e344a1dc361b2df51a" translate="yes" xml:space="preserve">
          <source>In rare cases, it is useful to control the amount of instrumentation generated. By passing the -afl-inst-ratio N argument to ocamlopt with N less than 100, instrumentation can be generated for only N% of branches. (See the afl-fuzz documentation on the parameter AFL_INST_RATIO for the precise effect of this).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34098be7f93d78af7d951548f23b26575531f537" translate="yes" xml:space="preserve">
          <source>In script mode, the directory containing the script currently executing; in interactive mode, the current working directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0910a7b3a20b997c573d806f5d3f327bd2180db6" translate="yes" xml:space="preserve">
          <source>In script mode, the first line of the script is ignored if it starts with #!. Thus, it should be possible to make the script itself executable and put as first line #!/usr/local/bin/ocaml, thus calling the toplevel system automatically when the script is run. However, ocaml itself is a #! script on most installations of OCaml, and Unix kernels usually do not handle nested #! scripts. A better solution is to put the following as the first line of the script:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3ca139fc0e78af6203d9e577fcd6f73d39da1eb" translate="yes" xml:space="preserve">
          <source>In short, a conversion specification consists in the &lt;code&gt;%&lt;/code&gt; character, followed by optional modifiers and a type which is made of one or two characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfc44adbe1d76bbb9087ab9eb6bae00365f83692" translate="yes" xml:space="preserve">
          <source>In some cases, a successful match may not yield a unique set of bindings. For instance the matching of &lt;code&gt;aba&lt;/code&gt; by the regular expression (('a'|&quot;ab&quot;) as x) ((&quot;ba&quot;|'a') as y) may result in binding either &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;&quot;ab&quot;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;&quot;a&quot;&lt;/code&gt;, or &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;&quot;a&quot;&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to &lt;code&gt;&quot;ba&quot;&lt;/code&gt;. The automata produced ocamllex on such ambiguous regular expressions will select one of the possible resulting sets of bindings. The selected set of bindings is purposely left unspecified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e5f8acb11224ef16504bf821b1a4f3846e25f8a" translate="yes" xml:space="preserve">
          <source>In some cases, it is hard to understand why the two types t&lt;sub&gt;1&lt;/sub&gt; and t&lt;sub&gt;2&lt;/sub&gt; are incompatible. For instance, the compiler can report that &amp;ldquo;expression of type foo cannot be used with type foo&amp;rdquo;, and it really seems that the two types foo are compatible. This is not always true. Two type constructors can have the same name, but actually represent different types. This can happen if a type constructor is redefined. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e640798597484a7600545dc82e4c33ed1a5752" translate="yes" xml:space="preserve">
          <source>In some cases, you may want to turn reverse execution off. This speeds up the program execution, and is also sometimes useful for interactive programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72952c8f05afa090a6398eb7a7e68cd59e600681" translate="yes" xml:space="preserve">
          <source>In some special cases, you may need to store a polymorphic function in a data structure, keeping its polymorphism. Doing this requires user-provided type annotations, since polymorphism is only introduced automatically for global definitions. However, you can explicitly give polymorphic types to record fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d8bd8bd0c73e5581100c0f0fdc21cf6dc82fc9c" translate="yes" xml:space="preserve">
          <source>In terms of char_os, both functions take an argument of type char_os * and return a result of the same type. We begin by choosing the right implementation of the function to bind:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="922859d863be18c8537dbf92ff8a561e25d814f1" translate="yes" xml:space="preserve">
          <source>In the &amp;ldquo;custom runtime&amp;rdquo; mode, the OCaml linker scans the object files and determines the set of required primitives. Then, it builds a suitable runtime system, by calling the native code linker with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad74914aa0f5096cdf7ded3e98edc3fa9085e8eb" translate="yes" xml:space="preserve">
          <source>In the C-style layout, array indices start at 0, and multi-dimensional arrays are laid out in row-major format. That is, for a two-dimensional array, all elements of row 0 are contiguous in memory, followed by all elements of row 1, etc. In other terms, the array elements at &lt;code&gt;(x,y)&lt;/code&gt; and &lt;code&gt;(x,&amp;nbsp;y+1)&lt;/code&gt; are adjacent in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="726cf9559718642bb4a9ce924e67bf43e58f9a8d" translate="yes" xml:space="preserve">
          <source>In the Fortran-style layout, array indices start at 1, and multi-dimensional arrays are laid out in column-major format. That is, for a two-dimensional array, all elements of column 0 are contiguous in memory, followed by all elements of column 1, etc. In other terms, the array elements at &lt;code&gt;(x,y)&lt;/code&gt; and &lt;code&gt;(x+1,&amp;nbsp;y)&lt;/code&gt; are adjacent in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2cea060daca649c697673805c9646270333dad7" translate="yes" xml:space="preserve">
          <source>In the absence of meaningful comment on the last constructor of a type, an empty comment (**) can be used instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f44983950ca3c3197004ea73c999cd5259f3070f" translate="yes" xml:space="preserve">
          <source>In the case of variant constructors or record field, the constructor or field name should be preceded by the name of the correspond type &amp;ndash; to avoid the ambiguity of several types having the same constructor names. For example, the constructor Node of the type tree will be referenced as {!tree.Node} or {!const:tree.Node}, or possibly {!Mod1.Mod2.tree.Node} from outside the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f10b0cb476350af30f28ed8856736d1b9672116b" translate="yes" xml:space="preserve">
          <source>In the default mode, the OCaml linker produces bytecode for the standard runtime system, with a standard set of primitives. References to primitives that are not in this standard set result in the &amp;ldquo;unavailable C primitive&amp;rdquo; error. (Unless dynamic loading of C libraries is supported &amp;ndash; see section &lt;a href=&quot;#ss%3Adynlink-c-code&quot;&gt;20.1.4&lt;/a&gt; below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ada7794c2f0108a93984c8df43895634c9cecfad" translate="yes" xml:space="preserve">
          <source>In the description of a value, type, exception, module, module type, class or class type, the &lt;em&gt;first sentence&lt;/em&gt; is sometimes used in indexes, or when just a part of the description is needed. The first sentence is composed of the first characters of the description, until</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f380b30f7f2a3bd63aab448ca63ae784823c0a52" translate="yes" xml:space="preserve">
          <source>In the first example, (r:first_record) is an explicit annotation telling OCaml that the type of r is first_record. With this annotation, Ocaml knows that r.x refers to the x field of the first record type. Similarly, the type annotation in the second example makes it clear to OCaml that the constructors A, B and C come from the first variant type. Contrarily, in the last example, OCaml has inferred by itself that the type of r can only be first_record and there are no needs for explicit type annotations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72414e01b80ae620788634a295dac8455ca20b7c" translate="yes" xml:space="preserve">
          <source>In the following code (which might typically occur when g is too large to inline) the value of x would usually be communicated to the application of the + function via the closure of g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d393b54aa4ad994d5181f438481ee687fee1c9c4" translate="yes" xml:space="preserve">
          <source>In the following code, the compiler observes that the closure returned from the function f contains a variable pair (free in the body of f) that may be split into two separate variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc6fdbc296fa731282af07ad9f312e34ebb596f" translate="yes" xml:space="preserve">
          <source>In the following code, there are two closure variables that would typically cause closure allocations. One is called fv and occurs inside the function baz; the other is called z and occurs inside the function bar. In this toy (yet sophisticated) example we again use an attribute to simulate the typical situation where the first argument of baz is too large to inline.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="721fe5ea332cbc9570673fd6bb094c20e430f05a" translate="yes" xml:space="preserve">
          <source>In the ideal, the right function name with right labels should be enough to understand the function&amp;rsquo;s meaning. Since one can get this information with OCamlBrowser or the ocaml toplevel, the documentation is only used when a more detailed specification is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0067298cd5d40acc2465837dd4dda28acd2d1e" translate="yes" xml:space="preserve">
          <source>In the object-oriented version of sets, we only need to add an additional method tag to return the representation of a set. Since sets are parametric in the type of elements, the method tag has a parametric type 'a tag, concrete within the module definition but abstract in its signature. From outside, it will then be guaranteed that two objects with a method tag of the same type will share the same representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="291e0dbbf80eac70186d0d4251b427b33b48b1bf" translate="yes" xml:space="preserve">
          <source>In the presence of multiple OCaml threads it should be assumed that any particular finaliser may be executed in any of the threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91ffcab04046ac0c20cbcca9068d8e573beb8496" translate="yes" xml:space="preserve">
          <source>In the return array, the slot at index &lt;code&gt;0&lt;/code&gt; corresponds to the most recent function call, raise, or primitive &lt;code&gt;get_backtrace&lt;/code&gt; call in the trace.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f04d4bfc534031b19b244ea21cf28affe8b39664" translate="yes" xml:space="preserve">
          <source>In the right-hand side of type definitions, references to one of the type constructor name being defined are considered as recursive, unless type is followed by nonrec. The nonrec keyword was introduced in OCaml 4.02.2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5f2952289734f5793eb520f8e1b35b465c9b780" translate="yes" xml:space="preserve">
          <source>In the second form, when the body of a local open is itself delimited by parentheses, braces or bracket, the parentheses of the local open can be omitted. For instance,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d2831b55ddf61b23e5bb88d88a73ddc646b145" translate="yes" xml:space="preserve">
          <source>In the two branches of a conditional expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7637452d36fadd2ef81ce53e1a83c6e0f70ac963" translate="yes" xml:space="preserve">
          <source>In the two examples above, the list is built bottom-up. Here is an alternate way, that proceeds top-down. It is less efficient, but illustrates the use of caml_modify.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13ef23781b1ec2de1604fab5007923acd1ad0364" translate="yes" xml:space="preserve">
          <source>In the type expression _&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; , the anonymous type expression _ stands in for anonymous type parameters and is equivalent to (_, &amp;hellip;,_) with as many repetitions of _ as the arity of &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeaa83fc28e0aae7a51149b7a6b03865bb7a3a40" translate="yes" xml:space="preserve">
          <source>In the type of depth, 'a.'a nested -&amp;gt; int, the type variable 'a is universally quantified. In other words, 'a.'a nested -&amp;gt; int reads as &amp;ldquo;for all type 'a, depth maps 'a nested values to integers&amp;rdquo;. Whereas the standard type 'a nested -&amp;gt; int can be interpreted as &amp;ldquo;let be a type variable 'a, then depth maps 'a nested values to integers&amp;rdquo;. There are two major differences with these two type expressions. First, the explicit polymorphic annotation indicates to the type checker that it needs to introduce a new type variable every times the function depth is applied. This solves our problem with the definition of the function depth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf32ca6edcb79b806067cc323225825f9b58ce1" translate="yes" xml:space="preserve">
          <source>In this case calling bar from OCaml is as cheap as calling any other OCaml function, except for the fact that the OCaml compiler can&amp;rsquo;t inline C functions...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00477d2b2741ddd83a9732844ec5d63894429c4" translate="yes" xml:space="preserve">
          <source>In this case the C functions must look like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b3277155ed08f7a13b1d39181a22abf8d356af" translate="yes" xml:space="preserve">
          <source>In this case, OCamldoc will associate Bar.x to the x of module Foo defined just above, instead of to the Bar.x defined in the opened module Foo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7d87e16fce5514152b5af5de0d55e2067da6ca" translate="yes" xml:space="preserve">
          <source>In this case, the function colored_point_to_point is an instance of the function to_point. This is not always true, however. The fully explicit coercion is more precise and is sometimes unavoidable. Consider, for example, the following class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a4b829ccac478d8513bb46a453a748cf8017f00" translate="yes" xml:space="preserve">
          <source>In this case, the type constructor is defined as an abbreviation for the type expression given in the equation, but in addition the constructors or fields given in the representation remain attached to the defined type constructor. The type expression in the equation part must agree with the representation: it must be of the same kind (record or variant) and have exactly the same constructors or fields, in the same order, with the same arguments. Moreover, the new type constructor must have the same arity and the same type constraints as the original type constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bed9185f2bb4af262638e20c9572165f24df5d4" translate="yes" xml:space="preserve">
          <source>In this case, we have x :&amp;gt; xy implies xy proc :&amp;gt; x proc. Notice that the second subtyping relation reverse the order of x and xy: the type constructor 'a proc is contravariant in its parameter 'a. More generally, the function type constructor 'a -&amp;gt; 'b is covariant in its return type 'b and contravariant in its argument type 'a.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4508d1c66982f1ffb116edbbf95e424005c3367c" translate="yes" xml:space="preserve">
          <source>In this case, we would like to inline f into g, because a conditional jump can be eliminated and the code size should reduce. If the inlining decision has been made after the declaration of f without seeing the use, its size would have probably made it ineligible for inlining; but at the call site, its final size can be known. Further, this function should probably not be inlined systematically: if b is unknown, or indeed false, there is little benefit to trade off against a large increase in code size. In the existing non-Flambda inliner this isn&amp;rsquo;t a great problem because chains of inlining were cut off fairly quickly. However it has led to excessive use of overly-large inlining parameters such as -inline 10000.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed102dfb8d13fe24c7ee911f7ad9ad616344d097" translate="yes" xml:space="preserve">
          <source>In this chapter, we show some larger examples using objects, classes and modules. We review many of the object features simultaneously on the example of a bank account. We show how modules taken from the standard library can be expressed as classes. Lastly, we describe a programming pattern known as &lt;em&gt;virtual types&lt;/em&gt; through the example of window managers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a536879627c56054020a13fd4e78494ffa306676" translate="yes" xml:space="preserve">
          <source>In this chapter, we use the word &lt;em&gt;element&lt;/em&gt; to refer to any of the following parts of an OCaml source file: a type declaration, a value, a module, an exception, a module type, a type constructor, a record field, a class, a class type, a class method, a class value or a class inheritance clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984f3b4b8f15c43c4ecf6aaa09632d698c5d7be4" translate="yes" xml:space="preserve">
          <source>In this example, the trace will be available at path /tmp/a_prefix.{PID}.eventlog.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdb410675373da3ea9d54a5f332e8f794b09205d" translate="yes" xml:space="preserve">
          <source>In this section, we illustrate most aspects of Object and inheritance by refining, debugging, and specializing the following initial naive definition of a simple bank account. (We reuse the module Euro defined at the end of chapter &lt;a href=&quot;objectexamples#c%3Aobjectexamples&quot;&gt;3&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7539064d77e16b304225f0f906a69a083f243dd9" translate="yes" xml:space="preserve">
          <source>In this situation, when coercing the module List2 to the module type COLLECTION, the type checker forgets that 'a List2.t was covariant in 'a. Consequently, the relaxed value restriction does not apply anymore:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f55d180a28b55d335204d82281bbcb00ea879279" translate="yes" xml:space="preserve">
          <source>In this use-case, we do not promise that &lt;code&gt;s&lt;/code&gt; will never be mutated after the call to &lt;code&gt;bytes_length&amp;nbsp;s&lt;/code&gt;. The &lt;a href=&quot;string#VALlength&quot;&gt;&lt;code&gt;String.length&lt;/code&gt;&lt;/a&gt; function temporarily borrows unique ownership of the byte sequence (and sees it as a &lt;code&gt;string&lt;/code&gt;), but returns this ownership back to the caller, which may assume that &lt;code&gt;s&lt;/code&gt; is still a valid byte sequence after the call. Note that this is only correct because we know that &lt;a href=&quot;string#VALlength&quot;&gt;&lt;code&gt;String.length&lt;/code&gt;&lt;/a&gt; does not capture its argument -- it could escape by a side-channel such as a memoization combinator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7981d44158719efab0bd42ae90948f53010bea2f" translate="yes" xml:space="preserve">
          <source>In those situations, local substitutions(see &lt;a href=&quot;signaturesubstitution#ss%3Alocal-substitution&quot;&gt;8.7.2&lt;/a&gt;) can be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a54a6c41b6e2f305dbef8e3cddea03753f6bf7" translate="yes" xml:space="preserve">
          <source>In what follows, we say that a string has the &lt;em&gt;OCaml encoding&lt;/em&gt; if it is encoded in UTF-8 when in Unicode mode, in the current code page in legacy mode, or is an arbitrary string under Unix. A string has the &lt;em&gt;platform encoding&lt;/em&gt; if it is encoded in UTF-16 under Windows or is an arbitrary string under Unix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7790a0c7a8cccc64f38d56e2325db218d5c6811d" translate="yes" xml:space="preserve">
          <source>Inappropriate I/O control operation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2167632468a6eb19b88638f904885e75bed8e2c3" translate="yes" xml:space="preserve">
          <source>Include all modules in the dot output, not only modules given on the command line or loaded with the -load option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc0da023e49fc7b9722125176291007176551c43" translate="yes" xml:space="preserve">
          <source>Include file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="936808b03c5417ee614099d8cff4070db8f25a29" translate="yes" xml:space="preserve">
          <source>Include the runtime system in the generated program. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15fc1b72deb0a330387cb4254adc44132b197dbf" translate="yes" xml:space="preserve">
          <source>Increment the integer contained in the given reference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59d0461a6012e030af72a2a2731fc0dc665abb6d" translate="yes" xml:space="preserve">
          <source>Increment the integer contained in the given reference. Equivalent to &lt;code&gt;fun&amp;nbsp;r&amp;nbsp;-&amp;gt;&amp;nbsp;r&amp;nbsp;:=&amp;nbsp;succ&amp;nbsp;!r&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b11b483c20b98095c6b381f3de3e92d1855cc71" translate="yes" xml:space="preserve">
          <source>Indeed, looking at the type of store, we see that the weak type '_weak1 has been replaced by the type int</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76cd4494b768ff6e2b09ff91039093a0249d5c70" translate="yes" xml:space="preserve">
          <source>Indeed, narrowing coercions without runtime checks would be unsafe. Runtime type checks might raise exceptions, and they would require the presence of type information at runtime, which is not the case in the OCaml system. For these reasons, there is no such operation available in the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b1073844359beadf5a16114b4cc53a73e228c78" translate="yes" xml:space="preserve">
          <source>Indeed, the latter is safer since the call to deposit will automatically benefit from safety checks and from the trace. Let&amp;rsquo;s test it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6cab5c3dce9df70b18150162d696626edc8f58" translate="yes" xml:space="preserve">
          <source>Index of exceptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acdc0800d0656472ebfb5222d7328b080a5b1896" translate="yes" xml:space="preserve">
          <source>Index of keywords</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec495fbe379a155a1562a723fa634c92e4aadb45" translate="yes" xml:space="preserve">
          <source>Index of module types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbeb088aa2e1f48a2526d4af87412592cfa16c85" translate="yes" xml:space="preserve">
          <source>Index of modules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c5f25fe0170a55faf806d3bc5e16c8e3ad5961" translate="yes" xml:space="preserve">
          <source>Index of types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47c7c1963655c5cb95aa9b1b9fed86c5ce38b1fc" translate="yes" xml:space="preserve">
          <source>Index of values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25c63fb7555ce1007deae3f494c7de8045880005" translate="yes" xml:space="preserve">
          <source>Indicate when the element was introduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e8bd8b065fdca29c6a5b91240b13af0f286f2c2" translate="yes" xml:space="preserve">
          <source>Indirect call site</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191d440868ddc01217ec4c3c696c8932eaf72c0e" translate="yes" xml:space="preserve">
          <source>Infix and prefix symbols do not have a fixed meaning: they are simply interpreted as applications of functions bound to the names corresponding to the symbols. The expression &lt;a href=&quot;lex#prefix-symbol&quot;&gt;prefix-symbol&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is interpreted as the application (&lt;a href=&quot;lex#prefix-symbol&quot;&gt;prefix-symbol&lt;/a&gt;)&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. Similarly, the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;lex#infix-symbol&quot;&gt;infix-symbol&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is interpreted as the application (&lt;a href=&quot;lex#infix-symbol&quot;&gt;infix-symbol&lt;/a&gt;)&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe7734c62845cd6e1a492fb7d09067d4ff38b544" translate="yes" xml:space="preserve">
          <source>Information on a module can be extracted either from the .mli or .ml file, or both, depending on the files given on the command line. When both .mli and .ml files are given for the same module, information extracted from these files is merged according to the following rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d1caa25b463767e262eac6152e176e3ab952570" translate="yes" xml:space="preserve">
          <source>Initial meaning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dbb564f9dda009f80e001d3b6ad4b6730abcccc" translate="yes" xml:space="preserve">
          <source>Initialize the generator with a random seed chosen in a system-dependent way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3705fbbfc33bff4987a51058b1e193b68718b84" translate="yes" xml:space="preserve">
          <source>Initialize the generator with a random seed chosen in a system-dependent way. If &lt;code&gt;/dev/urandom&lt;/code&gt; is available on the host machine, it is used to provide a highly random initial seed. Otherwise, a less random seed is computed from system parameters (current time, process IDs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0558cb2a265a245a0a77457b30a3ebd5743bac6" translate="yes" xml:space="preserve">
          <source>Initialize the generator, using the argument as a seed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a062ab889be546ba6ce3373ed6772b07b5c2ea5" translate="yes" xml:space="preserve">
          <source>Initialize the generator, using the argument as a seed. The same seed will always yield the same sequence of numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e19123dd5402986d7ab5c0b5abd27d1fded34ec" translate="yes" xml:space="preserve">
          <source>Initializers cannot be overridden. On the contrary, all initializers are evaluated sequentially. Initializers are particularly useful to enforce invariants. Another example can be seen in section &lt;a href=&quot;advexamples#s%3Aextended-bank-accounts&quot;&gt;6.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62be43bf10903b9dc899eb01b40be45122b8d091" translate="yes" xml:space="preserve">
          <source>Initially all compilation units composing the program currently running are available for reference from dynamically-linked units. &lt;code&gt;set_allowed_units&lt;/code&gt; can be used to restrict access to a subset of these units, e.g. to the units that compose the API for dynamically-linked code, and prevent access to all other units, e.g. private, internal modules of the running program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b06c7e11e0b9786df67b9cc22d90d3a95785831" translate="yes" xml:space="preserve">
          <source>Inlining impossible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b0e45ff90a6d9597b56ccc3164ed9d48a57e6e5" translate="yes" xml:space="preserve">
          <source>Inlining is performed together with all of the other Flambda optimisation passes, that is to say, after closure conversion. This has three particular advantages over a potentially more straightforward implementation prior to closure conversion:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6913b13f09c798d326ff4e05ee1ae94c7cf9c288" translate="yes" xml:space="preserve">
          <source>Inlining typically results in an increase in code size, which if left unchecked, may not only lead to grossly large executables and excessive compilation times but also a decrease in performance due to worse locality. As such, the Flambda inliner trades off the change in code size against the expected runtime performance benefit, with the benefit being computed based on the number of operations that the compiler observes may be removed as a result of inlining.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b56e2846e27a402309f12b5d96bce8a00e3f7444" translate="yes" xml:space="preserve">
          <source>Inlining within recursive functions of calls to other functions in the same mutually-recursive group is kept in check by an &lt;em&gt;unrolling depth&lt;/em&gt;, described below. This ensures that functions are not unrolled to excess. (Unrolling is only enabled if -O3 optimisation level is selected and/or the -inline-max-unroll flag is passed with an argument greater than zero.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4ae3ab2d64c2a48b49309cd566806beea18ab73" translate="yes" xml:space="preserve">
          <source>Innocuous unused variable: unused variable that is not bound with let nor as, and doesn&amp;rsquo;t start with an underscore (_) character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18969234f3dbfdf448abc9f07e07414d5833db11" translate="yes" xml:space="preserve">
          <source>Inode number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e286662d51034aaf951f8c590e939c61a0c7752" translate="yes" xml:space="preserve">
          <source>Input baud rate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af110399d643ab732597b92ca411b83ee621406" translate="yes" xml:space="preserve">
          <source>Input functions on standard input</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb0a243ff8f728fbc19eee3b8e30be0cbc1fada8" translate="yes" xml:space="preserve">
          <source>Input signature of the functor &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="106aa4d5f66d17b870cd55da1c3ba9108d80de1e" translate="yes" xml:space="preserve">
          <source>Input signature of the functor &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4637425273984e359cae1faec33aab011257fa" translate="yes" xml:space="preserve">
          <source>Input to the toplevel can span several lines. It is terminated by ;; (a double-semicolon). The toplevel input consists in one or several toplevel phrases, with the following syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="249f397392db7fe682a1d1ecc1a52c8e40ceb983" translate="yes" xml:space="preserve">
          <source>Input/output</source>
          <target state="translated">Input/output</target>
        </trans-unit>
        <trans-unit id="3bbbd8e97ab8a67ba17de562bff8af90fa53faaf" translate="yes" xml:space="preserve">
          <source>Input/output with timeout</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb706c985ba3ad0bfe191f4ce7255d21cd26c340" translate="yes" xml:space="preserve">
          <source>Inside a class definition, newly defined types are not available for subtyping, as the type abbreviations are not yet completely defined. There is an exception for coercing self to the (exact) type of its class: this is allowed if the type of self does not appear in a contravariant position in the class type, &lt;em&gt;i.e.&lt;/em&gt; if there are no binary methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a205e6f672b9fdfb59c252492e5d0840aba8c432" translate="yes" xml:space="preserve">
          <source>Inside a tabulation box, special &lt;em&gt;tabulation markers&lt;/em&gt; defines points of interest on the line (for instance to delimit cell boundaries). Function &lt;a href=&quot;format#VALset_tab&quot;&gt;&lt;code&gt;Format.set_tab&lt;/code&gt;&lt;/a&gt; sets a tabulation marker at insertion point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4bc21673d22d7a226cf1a154d1dc9f5b82d92ea" translate="yes" xml:space="preserve">
          <source>Inside signatures, extended opens are limited to extended module paths,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d3888f1ab23958e132facd2acfbe644974db97" translate="yes" xml:space="preserve">
          <source>Instance variable overridden.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22f04c4ba964874db6809362b1a8926b072c78c2" translate="yes" xml:space="preserve">
          <source>Instance variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f37452f8cdfca7d287d0436f2a77363400920136" translate="yes" xml:space="preserve">
          <source>Instance variables can also be declared as virtual, with the same effect as with methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cbf3c792bd63a3e48e2769ecf3367f834405f89" translate="yes" xml:space="preserve">
          <source>Instead of building simultaneously the bytecode library, the native-code library and the C libraries, ocamlmklib can be called three times to build each separately. Thus,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c04639e128bd9a951383bb5ff32e6f5c8aaf672" translate="yes" xml:space="preserve">
          <source>Instead of manually taking profiling heap snapshots with this module it is possible to use an automatic snapshot facility that writes profiling information at fixed intervals to a file. To enable this, all that needs to be done is to build the relevant program using a compiler configured with -spacetime; and set the environment variable OCAML_SPACETIME_INTERVAL to an integer number of milliseconds giving the interval between profiling heap snapshots. This interval should not be made excessively small relative to the running time of the program. A typical interval to start with might be 1/100 of the running time of the program. The program must exit &quot;normally&quot; (i.e. by calling &lt;code&gt;exit&lt;/code&gt;, with whatever exit code, rather than being abnormally terminated by a signal) so that the snapshot file is correctly completed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e943b527aa4ff5b9d82f9025dbdd34ab27b52c5d" translate="yes" xml:space="preserve">
          <source>Instead of using the automatic snapshot facility described above it is also possible to manually control Spacetime profiling. (The environment variables OCAML_SPACETIME_INTERVAL and OCAML_SPACETIME_SNAPSHOT_DIR are then not relevant.) Full documentation as regards this method of profiling is provided in the standard library documentation (section &lt;a href=&quot;stdlib#c%3Astdlib&quot;&gt;26&lt;/a&gt;) for the Spacetime module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00c73f5f7ad74401722214f0974a3eff4d870dcf" translate="yes" xml:space="preserve">
          <source>Instead you should make sure that &lt;code&gt;v&lt;/code&gt; is not in the closure of the finalisation function by writing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25f985c284e754031dd21f1a5c5f41e90ae95c89" translate="yes" xml:space="preserve">
          <source>Instead, we compile with afl-fuzz instrumentation enabled:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c89edcac2811a6a9e8072517cae7f3cbfd5049d" translate="yes" xml:space="preserve">
          <source>Int</source>
          <target state="translated">Int</target>
        </trans-unit>
        <trans-unit id="15381ff97a37fb400782fdaa2c7388f15a9ffe29" translate="yes" xml:space="preserve">
          <source>Int and float literals followed by an one-letter identifier in the range [g..z∣ G..Z] are extension-only literals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4753a4dee54ee10a75b28c6d04eb9ea0d19acce" translate="yes" xml:space="preserve">
          <source>Int32</source>
          <target state="translated">Int32</target>
        </trans-unit>
        <trans-unit id="2ce3094d56f1473f235bddadb9d8bc7ef3c8506c" translate="yes" xml:space="preserve">
          <source>Int32_val(v) returns the 32-bit integer contained in the int32v.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="180fcbe698d0f2c44101a06215c472930bbd0a01" translate="yes" xml:space="preserve">
          <source>Int64</source>
          <target state="translated">Int64</target>
        </trans-unit>
        <trans-unit id="01401a6dfc8f66f16b91660dc052300e61a41944" translate="yes" xml:space="preserve">
          <source>Int64_val(v) returns the 64-bit integer contained in the int64v.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca17dea0b5499b7267626775e6fb9adb332e238d" translate="yes" xml:space="preserve">
          <source>Int_val(v) returns the int encoded in value v.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32ddd0cbe8aab89d143f0365d7027496f8c8f9b4" translate="yes" xml:space="preserve">
          <source>Integer addition.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51469f7cf19f5aef555ff312b610dd3233d7b502" translate="yes" xml:space="preserve">
          <source>Integer addition. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799eea857bb7f3051065789cb42f9d772482ce76" translate="yes" xml:space="preserve">
          <source>Integer arithmetic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b97f0e3b005e1c50bd3f2e901953649a16fbfda" translate="yes" xml:space="preserve">
          <source>Integer division.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="497f091783378895fdc4d9e7953e5a08e182ce5c" translate="yes" xml:space="preserve">
          <source>Integer division. Integer division rounds the real quotient of its arguments towards zero. More precisely, if &lt;code&gt;x&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; and &lt;code&gt;y&amp;nbsp;&amp;gt;&amp;nbsp;0&lt;/code&gt;, &lt;code&gt;x&amp;nbsp;/&amp;nbsp;y&lt;/code&gt; is the greatest integer less than or equal to the real quotient of &lt;code&gt;x&lt;/code&gt; by &lt;code&gt;y&lt;/code&gt;. Moreover, &lt;code&gt;(-&amp;nbsp;x)&amp;nbsp;/&amp;nbsp;y&amp;nbsp;=&amp;nbsp;x&amp;nbsp;/&amp;nbsp;(-&amp;nbsp;y)&amp;nbsp;=&amp;nbsp;-&amp;nbsp;(x&amp;nbsp;/&amp;nbsp;y)&lt;/code&gt;. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd2f1f4758df5a6c46bd95dca7106b6f2bd262a0" translate="yes" xml:space="preserve">
          <source>Integer division. Raise Division_by_zero if second argument is zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9277b24b9c7ec7c2802db27cc9cc0d888c4a2627" translate="yes" xml:space="preserve">
          <source>Integer division. This division rounds the real quotient of its arguments towards zero, as specified for &lt;a href=&quot;stdlib#VAL(/)&quot;&gt;&lt;code&gt;(/)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a70bb5f8ea15b1d1eb87ef3499d1ad101d2ec5ac" translate="yes" xml:space="preserve">
          <source>Integer modulus. Raise Division_by_zero if second argument is zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e1c23fc1293a5342dcbb3f224d5a8468fa0f38f" translate="yes" xml:space="preserve">
          <source>Integer multiplication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8648a8d2bc260aeaf65eefba9783a89ca4ed0085" translate="yes" xml:space="preserve">
          <source>Integer multiplication. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032eaf1313070ba2c07142e51665d3b149104407" translate="yes" xml:space="preserve">
          <source>Integer negation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02df94240577ba3af6cd59998f11bcb26c753b82" translate="yes" xml:space="preserve">
          <source>Integer remainder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608e0fbf1419a8074d877b3d35e821cc489e0512" translate="yes" xml:space="preserve">
          <source>Integer remainder. If &lt;code&gt;y&lt;/code&gt; is not zero, the result of &lt;code&gt;Int32.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; satisfies the following property: &lt;code&gt;x&amp;nbsp;=&amp;nbsp;Int32.add&amp;nbsp;(Int32.mul&amp;nbsp;(Int32.div&amp;nbsp;x&amp;nbsp;y)&amp;nbsp;y)&amp;nbsp;(Int32.rem&amp;nbsp;x&amp;nbsp;y)&lt;/code&gt;. If &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;, &lt;code&gt;Int32.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; raises &lt;code&gt;Division_by_zero&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="487f9e5fe125fb675e3c64cef0e69cc68128df1c" translate="yes" xml:space="preserve">
          <source>Integer remainder. If &lt;code&gt;y&lt;/code&gt; is not zero, the result of &lt;code&gt;Int64.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; satisfies the following property: &lt;code&gt;x&amp;nbsp;=&amp;nbsp;Int64.add&amp;nbsp;(Int64.mul&amp;nbsp;(Int64.div&amp;nbsp;x&amp;nbsp;y)&amp;nbsp;y)&amp;nbsp;(Int64.rem&amp;nbsp;x&amp;nbsp;y)&lt;/code&gt;. If &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;, &lt;code&gt;Int64.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; raises &lt;code&gt;Division_by_zero&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3fbea780e541621ae7cf3f5b034731f03103fd9" translate="yes" xml:space="preserve">
          <source>Integer remainder. If &lt;code&gt;y&lt;/code&gt; is not zero, the result of &lt;code&gt;Nativeint.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; satisfies the following properties: &lt;code&gt;Nativeint.zero&amp;nbsp;&amp;lt;=&amp;nbsp;Nativeint.rem&amp;nbsp;x&amp;nbsp;y&amp;nbsp;&amp;lt;&amp;nbsp;Nativeint.abs&amp;nbsp;y&lt;/code&gt; and &lt;code&gt;x&amp;nbsp;=&amp;nbsp;Nativeint.add&amp;nbsp;(Nativeint.mul&amp;nbsp;(Nativeint.div&amp;nbsp;x&amp;nbsp;y)&amp;nbsp;y)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(Nativeint.rem&amp;nbsp;x&amp;nbsp;y)&lt;/code&gt;. If &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;, &lt;code&gt;Nativeint.rem&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; raises &lt;code&gt;Division_by_zero&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfd76a7086e3cc42170f403e6e55cc09afe26cb2" translate="yes" xml:space="preserve">
          <source>Integer remainder. If &lt;code&gt;y&lt;/code&gt; is not zero, the result of &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; satisfies the following properties: &lt;code&gt;x&amp;nbsp;=&amp;nbsp;(x&amp;nbsp;/&amp;nbsp;y)&amp;nbsp;*&amp;nbsp;y&amp;nbsp;+&amp;nbsp;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; and &lt;code&gt;abs(x&amp;nbsp;mod&amp;nbsp;y)&amp;nbsp;&amp;lt;=&amp;nbsp;abs(y)&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;. If &lt;code&gt;y&amp;nbsp;=&amp;nbsp;0&lt;/code&gt;, &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; raises &lt;code&gt;Division_by_zero&lt;/code&gt;. Note that &lt;code&gt;x&amp;nbsp;mod&amp;nbsp;y&lt;/code&gt; is negative only if &lt;code&gt;x&amp;nbsp;&amp;lt;&amp;nbsp;0&lt;/code&gt;. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b01a6a7b79fbcb183062af64aaaa63eeb3f2718" translate="yes" xml:space="preserve">
          <source>Integer subtraction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d24914c47006eb02f4dff06d0cd904dc2d2c7e" translate="yes" xml:space="preserve">
          <source>Integer subtraction. Left-associative operator, , see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ee1ee4b4f11b2969952d343f112afa9881a1bab" translate="yes" xml:space="preserve">
          <source>Integer values are integer numbers from &amp;minus;2&lt;sup&gt;30&lt;/sup&gt; to 2&lt;sup&gt;30&lt;/sup&gt;&amp;minus;1, that is &amp;minus;1073741824 to 1073741823. The implementation may support a wider range of integer values: on 64-bit platforms, the current implementation supports integers ranging from &amp;minus;2&lt;sup&gt;62&lt;/sup&gt; to 2&lt;sup&gt;62&lt;/sup&gt;&amp;minus;1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="712ee29f7fc5c28dea5cc603b21eca7741d78fbd" translate="yes" xml:space="preserve">
          <source>Integer values encode 63-bit signed integers (31-bit on 32-bit architectures). They are unboxed (unallocated).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f83aa7411530d0444302d56a388b902fdce29d91" translate="yes" xml:space="preserve">
          <source>Integer values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="bc497571cb33f7c1a8b4b38e571f47e9c94eb5e7" translate="yes" xml:space="preserve">
          <source>Integers are &lt;a href=&quot;sys#VALint_size&quot;&gt;&lt;code&gt;Sys.int_size&lt;/code&gt;&lt;/a&gt; bits wide and use two's complement representation. All operations are taken modulo 2&lt;sup&gt;&lt;code&gt;Sys.int_size&lt;/code&gt;&lt;/sup&gt;. They do not fail on overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4241877025d1966580ad7c3f3b0ff442755310e" translate="yes" xml:space="preserve">
          <source>Integers are &lt;code&gt;Sys.int_size&lt;/code&gt; bits wide. All operations are taken modulo 2&lt;sup&gt;&lt;code&gt;Sys.int_size&lt;/code&gt;&lt;/sup&gt;. They do not fail on overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a102c4a574ecfadd9a7c5f1722bd0399b5d2cd" translate="yes" xml:space="preserve">
          <source>Integers are not allocated and cannot be stored in weak arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="935ae25e71bde4c78ba85d5dac1b5c31c4661273" translate="yes" xml:space="preserve">
          <source>Interactive interrupt (ctrl-C)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04543475f0af93a9b1f70f2a38be6ff47c43ef12" translate="yes" xml:space="preserve">
          <source>Interactive stop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc0bc31a21623037df91a449af1758c1ea53779" translate="yes" xml:space="preserve">
          <source>Interactive termination</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="152a2569e2c91ee227ddb8f5534f2eae5eb0d12f" translate="yes" xml:space="preserve">
          <source>Interface to the Unix system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9f4c23d2b8212406b51e7046c93c96a1a7f1146" translate="yes" xml:space="preserve">
          <source>Interface to the Unix system. To use as replacement to default &lt;a href=&quot;unix&quot;&gt;&lt;code&gt;Unix&lt;/code&gt;&lt;/a&gt; module, add &lt;code&gt;module&amp;nbsp;Unix&amp;nbsp;=&amp;nbsp;UnixLabels&lt;/code&gt; in your implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="467f8304012cd505625c260277e4cae411499ca2" translate="yes" xml:space="preserve">
          <source>Interfacing with the standard input/output library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d7c946b4a793edf3af449c46e4c2c299d575469" translate="yes" xml:space="preserve">
          <source>Internet addresses</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4ecff40bc2b8c11c2e5679d0ffe558077996225" translate="yes" xml:space="preserve">
          <source>Internet domain (IPv4)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="857d078139ed411f7ba1150677d3393807432577" translate="yes" xml:space="preserve">
          <source>Internet domain (IPv6)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b995e53883804fd20a387b321cb4b4c4302563e5" translate="yes" xml:space="preserve">
          <source>Interrupt character (usually ctrl-C).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="279042ba487b938485f08f0399290c5d0cf49331" translate="yes" xml:space="preserve">
          <source>Intuition: a &amp;ldquo;blocking section&amp;rdquo; is a piece of C code that does not use the OCaml run-time system, typically a blocking input/output operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50d8afba7764b4a5e45be2c963d38829c02898a1" translate="yes" xml:space="preserve">
          <source>Intuitively, a value of type 'a nested is a list of list &amp;hellip;of list of elements a with k nested list. We can then adapt the maximal_depth function defined on regular_depth into a depth function that computes this k. As a first try, we may define</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45ff4427a9f1fb0c18cbcdf6b26d6a2d22f2df2f" translate="yes" xml:space="preserve">
          <source>Invalid argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb51873a166a0ca612be5e39e25b496f16f0edd3" translate="yes" xml:space="preserve">
          <source>Invalid hardware instruction</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aaeaeb6ec3f8154506ce18b333531c275dcb035" translate="yes" xml:space="preserve">
          <source>Invalid link</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1835382968f46a5f88dff8462ccb2b244e21516d" translate="yes" xml:space="preserve">
          <source>Invalid memory reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9851d3714a00331607464ec1db51c684493f3fde" translate="yes" xml:space="preserve">
          <source>Invalid seek e.g. on a pipe</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d82b06adf1a876d702b6a3905d8d56b51827e40e" translate="yes" xml:space="preserve">
          <source>Is a directory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d246b366cbb2a7b87d693c8eb7b14afb327f18c3" translate="yes" xml:space="preserve">
          <source>Is_block(v) is true if value v is a pointer to a block, and false if it is an immediate integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162a91bb1ae1511c1a14b48fc9b99ad1c1b64c87" translate="yes" xml:space="preserve">
          <source>Is_long(v) is true if value v is an immediate integer, false otherwise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90960e35ff8d0e1edddd78784b82e7ac0c892d5d" translate="yes" xml:space="preserve">
          <source>It becomes more straightforward to optimise closure allocations since the layout of closures does not have to be estimated in any way: it is known. Similarly, it becomes more straightforward to control which variables end up in which closures, helping to avoid closure bloat.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c1a2b53a967f6be04a8b2e559ade5c3657e377" translate="yes" xml:space="preserve">
          <source>It can be given the following specification:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82b604d7f25795726169718eb6d7ffbabff67881" translate="yes" xml:space="preserve">
          <source>It generates the following outputs:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="044d9b1336b13c24f31c6087a0884aa833908413" translate="yes" xml:space="preserve">
          <source>It is also extremely useful for first-class modules (see section &lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;8.5&lt;/a&gt;) and generalized algebraic datatypes (GADTs: see section &lt;a href=&quot;gadts#s%3Agadts&quot;&gt;8.10&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bea3ffa0da3a6a64e26d92217f56bc5dc0ee88ad" translate="yes" xml:space="preserve">
          <source>It is also possible to copy the components of a module inside another module by using an include statement. This can be particularly useful to extend existing modules. As an illustration, we could add functions that returns an optional value rather than an exception when the priority queue is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b378569adc4da470dbea88424425ba33922ddf5" translate="yes" xml:space="preserve">
          <source>It is also possible to specify attributes using an infix syntax. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47fcca3d515f217455ee5cbe30c0a352c5140f35" translate="yes" xml:space="preserve">
          <source>It is also possible to use a virtual class. Inheriting from this class simultaneously forces all methods of c to have the same type as the methods of c'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd58beaddeffd7ca4bb4171ee18d2d1d171993da" translate="yes" xml:space="preserve">
          <source>It is assumed in the compiler that expressions with no effects, whose results are not used, may be eliminated. (This typically happens where the expression in question is the defining expression of a let; in such cases the let-expression will be eliminated.) It is further assumed that such expressions with no effects may be duplicated (and thus possibly executed more than once).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13d2ff83781a8a7489c112130f8ee70344794950" translate="yes" xml:space="preserve">
          <source>It is assumed in the compiler that, subject to data dependencies, expressions with neither effects nor coeffects may be reordered with respect to other expressions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac5a661dd59eecff9dd10ceec465f901059e4cc2" translate="yes" xml:space="preserve">
          <source>It is automatically &amp;ldquo;opened&amp;rdquo; when a compilation starts, or when the toplevel system is launched. Hence, it is possible to use unqualified identifiers to refer to the functions provided by the Stdlib module, without adding a open Stdlib directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd4849d026298aa7f6ab63f07e5240537d04447" translate="yes" xml:space="preserve">
          <source>It is automatically linked with the user&amp;rsquo;s object code files by the ocamlc command (chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a83064bce61d18a3c463038ddbd763bdd7b618f8" translate="yes" xml:space="preserve">
          <source>It is defined as &lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt;&lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;stdlib#VALstderr&quot;&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de9bd2e9555690ad21a6a0c4218827b24b71e84a" translate="yes" xml:space="preserve">
          <source>It is defined as &lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt;&lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;stdlib#VALstdout&quot;&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b06674c64e7087d6cd54c0e34bb489d7d00dd20" translate="yes" xml:space="preserve">
          <source>It is easier to integrate with cross-module optimisation, since imported information about other modules is already in the correct intermediate language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c7e38f3c9e1798fbab9e90c5865cda5877abcfa" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;print_tbreak&amp;nbsp;0&amp;nbsp;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f1f54bf27ff0a3758919f394790ff7b25c9d1f8" translate="yes" xml:space="preserve">
          <source>It is however possible to define functions that manipulate objects of type either money or money2: the function min will return the minimum of any two objects whose type unifies with #comparable. The type of min is not the same as #comparable -&amp;gt; #comparable -&amp;gt; #comparable, as the abbreviation #comparable hides a type variable (an ellipsis). Each occurrence of this abbreviation generates a new variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06505630dc097368cdf81588999cb42bce21605e" translate="yes" xml:space="preserve">
          <source>It is important to note that the exported front-end interface follows the evolution of the OCaml language and implementation, and thus does not provide any backwards compatibility guarantees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df425a65ea13fa3de15879ad0ff948e700f992b5" translate="yes" xml:space="preserve">
          <source>It is important to provide the client&amp;rsquo;s view as a functor Client so that client accounts can still be built after a possible specialization of the bank. The functor Client may remain unchanged and be passed the new definition to initialize a client&amp;rsquo;s view of the extended account.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a013a33299e01ccd1972c4a799393bbe9b322fa8" translate="yes" xml:space="preserve">
          <source>It is important to remark that the function eval is using the polymorphic syntax for locally abstract types. When defining a recursive function that manipulates a GADT, explicit polymorphic recursion should generally be used. For instance, the following definition fails with a type error:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33f0de9451006df17669b54818c85d11fb78b04d" translate="yes" xml:space="preserve">
          <source>It is not possible to mix native-code object files produced by ocamlopt with bytecode object files produced by ocamlc: a program must be compiled entirely with ocamlopt or entirely with ocamlc. Native-code object files produced by ocamlopt cannot be loaded in the toplevel system ocaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6d73db6c27ba0773eb0db381d42efb65e8e409" translate="yes" xml:space="preserve">
          <source>It is often a security hole to leak file descriptors opened on, say, a private file to an external program: the program, then, gets access to the private file and can do bad things with it. Hence, it is highly recommended to set all file descriptors ``close-on-exec'', except in the very few cases where a file descriptor actually needs to be transmitted to another program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79cb04a19a396d38be69e08c2821e7ce44154b03" translate="yes" xml:space="preserve">
          <source>It is only possible to coerce an expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; from type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, if the type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is an instance of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; (like for a type annotation), and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. The type of the coerced expression is an instance of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. If the types contain variables, they may be instantiated by the subtyping algorithm, but this is only done after determining whether &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a potential subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. This means that typing may fail during this latter unification step, even if some instance of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a subtype of some instance of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. In the following paragraphs we describe the subtyping relation used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc436df5f472c76f9b857cad66e30b424d794e2" translate="yes" xml:space="preserve">
          <source>It is possible to declare a method without actually defining it, using the keyword virtual. This method will be provided later in subclasses. A class containing virtual methods must be flagged virtual, and cannot be instantiated (that is, no object of this class can be created). It still defines type abbreviations (treating virtual methods as other methods.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21e850727b9f6478bee4607ccc53d1de385121ba" translate="yes" xml:space="preserve">
          <source>It is possible to define a generator class in several modules, which are defined in several files file&lt;sub&gt;1&lt;/sub&gt;.ml[i], file&lt;sub&gt;2&lt;/sub&gt;.ml[i], ..., file&lt;sub&gt;n&lt;/sub&gt;.ml[i]. A .cma library file must be created, including all these files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2faea6818157cac9f0988b494ec9a1fb10a63786" translate="yes" xml:space="preserve">
          <source>It is possible to define local exceptions in expressions: letexception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; . The syntactic scope of the exception constructor is the inner expression, but nothing prevents exception values created with this constructor from escaping this scope. Two executions of the definition above result in two incompatible exception constructors (as for any exception definition). For instance, the following assertion is true:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c1a7eb6e17934cbe039ce2d9565c2d1a043e49" translate="yes" xml:space="preserve">
          <source>It is possible to write a version of class point without assignments on the instance variables. The override construct {&amp;lt; ... &amp;gt;} returns a copy of &amp;ldquo;self&amp;rdquo; (that is, the current object), possibly changing the value of some instance variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2b8c74a40907020aea23679f7d3a1e47e89c876" translate="yes" xml:space="preserve">
          <source>It is recommended that applications or Web frameworks that need to protect themselves against the denial-of-service attack described in &lt;a href=&quot;hashtbl#VALcreate&quot;&gt;&lt;code&gt;Hashtbl.create&lt;/code&gt;&lt;/a&gt; call &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; at initialization time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de79eca76d0232a8de08f10b0fc7e60c155d206d" translate="yes" xml:space="preserve">
          <source>It is recommended to inherit from the current generator of the same kind as the one you want to define. Doing so, it is possible to load various custom generators to combine improvements brought by each one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfaad68f50ca8cd128072213cb8026032d1a1ddb" translate="yes" xml:space="preserve">
          <source>It is sometimes inconvenient to build a custom runtime system each time OCaml code is linked with C libraries, like ocamlc -custom does. For one thing, the building of the runtime system is slow on some systems (that have bad linkers or slow remote file systems); for another thing, the platform-independence of bytecode files is lost, forcing to perform one ocamlc -custom link per platform of interest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ccaf02d4a67360ff683564b219f17b5312faf2d" translate="yes" xml:space="preserve">
          <source>It may also be useful to relay an optional argument from a function call to another. This can be done by prefixing the applied argument with ?. This question mark disables the wrapping of optional argument in an option type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2ae4f4dfef6ee049420fc585397e822cd1841d" translate="yes" xml:space="preserve">
          <source>It may become the case during compilation that one or more invariant arguments to a function become specialised to a particular value. When such values are themselves boxed the corresponding specialised arguments may be split into more specialised arguments corresponding to the projections out of the boxed value that occur within the function body. This transformation is called &lt;em&gt;unboxing of specialised arguments&lt;/em&gt;. It is only applied when there is reasonable certainty that the boxed argument itself is unused within the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2113b64361ed06b2fb660d291ef792f576530d08" translate="yes" xml:space="preserve">
          <source>It particular, it provides the basic operations over the built-in types (numbers, booleans, byte sequences, strings, exceptions, references, lists, arrays, input-output channels, ...) and the &lt;a href=&quot;stdlib#modules&quot;&gt;standard library modules&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e1bb8314f0b54fe82043439ead06c77dd005bd" translate="yes" xml:space="preserve">
          <source>It permits higher-order inlining, for example when a non-inlinable function always returns the same function yet with different environments of definition. Not all such cases are supported yet, but it is intended that such support will be improved in future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62dc081b8f1528625d07f7e633e0a268ec1a67b" translate="yes" xml:space="preserve">
          <source>It raises &lt;code&gt;End_of_file&lt;/code&gt; if the function has already reached the end of file when starting to read from the channel, and raises &lt;code&gt;Failure&amp;nbsp;&quot;input_value:&amp;nbsp;truncated&amp;nbsp;object&quot;&lt;/code&gt; if it reaches the end of file later during the unmarshalling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7eeb9110a841ac9d46371abdaeea4230b064629" translate="yes" xml:space="preserve">
          <source>It should be noted that the &lt;em&gt;unboxing of closures&lt;/em&gt; pass (see below) can introduce specialised arguments on non-recursive functions. (No other place in the compiler currently does this.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f1b6ac17c7b6c87ec71a416499d7641064d1ab8" translate="yes" xml:space="preserve">
          <source>It should be noted that the blocks corresponding to initialise-symbol bindings are kept alive forever, by virtue of them occurring in a static table of GC roots within the object file. This extended lifetime of expressions may on occasion be surprising. If it is desired to create some non-constant value (for example when writing GC tests) that does not have this extended lifetime, then it may be created and used inside a function, with the application point of that function (perhaps at toplevel)&amp;mdash;or indeed the function declaration itself&amp;mdash;marked as to never be inlined. This technique prevents lifting of the definition of the value in question (assuming of course that it is not constant).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67c39d8ce8aefbd00cfb85541a53fdf588caae0" translate="yes" xml:space="preserve">
          <source>It will be accepted if each one of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; is statically constructive with respect to name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt;, is not immediately linked to any of name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt;, and is not an array constructor whose arguments have abstract type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1efde60809be61ee856277b8eeaecd2343156c0" translate="yes" xml:space="preserve">
          <source>It would be incorrect to perform Field(r, 1) = tail directly, because the allocation of tail has taken place since r was allocated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e56ebc8d92919227f4b41f4b34fc2bd72f5bbb0" translate="yes" xml:space="preserve">
          <source>It would be natural to factorize these two definitions as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="033f25fa120ee864f9ba41bac8624f68584547d1" translate="yes" xml:space="preserve">
          <source>It would be unsound to apply this fake_id function to values with different types. The function fake_id is therefore rightfully assigned the type '_weak3 -&amp;gt; '_weak3 rather than 'a -&amp;gt; 'a. At the same time, it ought to be possible to use a local mutable state without impacting the type of a function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da9a22f0bb03dc04334b781283f4d9b2b79cd9d" translate="yes" xml:space="preserve">
          <source>Items produced by symbolic pretty-printers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c475641298983202fb5bb4c85bf773502af819b" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4e251fe0eee2437464dec9a234fc1b325f32052" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order, yielding indices along elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d6cc59b755b47fc8e1cdb410adb3abe777160d" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order, yielding indices along elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fa1984f98f87ade05a77d2d30ccf29617c61c6" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order, yielding indices along elements. Modifications of the array during iteration will be reflected in the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc753a1a200932eacd72d4b7ac2810d8ee977b0f" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72365e84c44abbdabda346bfd2a72b67f6a2f040" translate="yes" xml:space="preserve">
          <source>Iterate on the array, in increasing order. Modifications of the array during iteration will be reflected in the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57d6da7fff2897e2fdb9323a2fa6acc42d8e4f3c" translate="yes" xml:space="preserve">
          <source>Iterate on the buffer, in increasing order, yielding indices along chars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a59b1457067d268a42e29eef63f4228e79bc1f79" translate="yes" xml:space="preserve">
          <source>Iterate on the buffer, in increasing order, yielding indices along chars. Modification of the buffer during iteration is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53111c31562ee5692d94ba95750e9d8128aa9335" translate="yes" xml:space="preserve">
          <source>Iterate on the buffer, in increasing order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52718e109f8ea9e93b899d8a8c03df0ab8a5e288" translate="yes" xml:space="preserve">
          <source>Iterate on the buffer, in increasing order. Modification of the buffer during iteration is undefined behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f7e2d0218e27b69ec7b7e2712b13e76087fea47" translate="yes" xml:space="preserve">
          <source>Iterate on the floatarray, in increasing order, yielding indices along elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c13a9362e94273776029d2c08f652f705e4760a" translate="yes" xml:space="preserve">
          <source>Iterate on the floatarray, in increasing order, yielding indices along elements. Modifications of the floatarray during iteration will be reflected in the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b731e40512294d27a66934701878da5e53e3950" translate="yes" xml:space="preserve">
          <source>Iterate on the floatarray, in increasing order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6a301a25721beaf25e58fa63b6a4fc32321de99" translate="yes" xml:space="preserve">
          <source>Iterate on the floatarray, in increasing order. Modifications of the floatarray during iteration will be reflected in the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08358549ccfddcf0b104c824624f18dbe99ff7fa" translate="yes" xml:space="preserve">
          <source>Iterate on the list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b0797886b2f424b48d1cd58859fb9af00b7784b" translate="yes" xml:space="preserve">
          <source>Iterate on the queue, in front-to-back order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25db6012c3533afa619b7a8a7742b0a42cb7afd" translate="yes" xml:space="preserve">
          <source>Iterate on the queue, in front-to-back order. The behavior is not defined if the queue is modified during the iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f0bd8ad0f81cad6d96bacf14d0331f3a6e12dbd" translate="yes" xml:space="preserve">
          <source>Iterate on the sequence, calling the (imperative) function on every element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ff7477ff445e072b84d4239e6c7d7c3aa347e47" translate="yes" xml:space="preserve">
          <source>Iterate on the sequence, calling the (imperative) function on every element. The traversal happens immediately and will not terminate on infinite sequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8c886336160d913779eb591bdee0d4b0e15e45e" translate="yes" xml:space="preserve">
          <source>Iterate on the stack, top to bottom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e94cac5480ab8007065d1c6001b6f46bf9c31673" translate="yes" xml:space="preserve">
          <source>Iterate on the stack, top to bottom. It is safe to modify the stack during iteration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f621778fd05a26d4f34ddb7acf9a152913cceff" translate="yes" xml:space="preserve">
          <source>Iterate on the string, in increasing index order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edcd995c03b85f6200cad5b28912c76d3ebd838a" translate="yes" xml:space="preserve">
          <source>Iterate on the string, in increasing index order. Modifications of the string during iteration will be reflected in the iterator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83efc6c1259a0086cd4741e82ac58d922ad5c76a" translate="yes" xml:space="preserve">
          <source>Iterate on the string, in increasing order, yielding indices along chars</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2b702d271270fdfb0f8e97fdc65aa27aa84c7e5" translate="yes" xml:space="preserve">
          <source>Iterate on the whole map, in ascending order of keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0fbfcbff3c4717a90de3169e97500f554fe0e8f" translate="yes" xml:space="preserve">
          <source>Iterate on the whole set, in ascending order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7d061daf3db9ad7ba0961da1a7a84cd239402bf" translate="yes" xml:space="preserve">
          <source>Iterate on the whole table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9d8c94aa5374233499af2d9864d692b5eaf8400" translate="yes" xml:space="preserve">
          <source>Iterate on the whole table. The order in which the bindings appear in the sequence is unspecified. However, if the table contains several bindings for the same key, they appear in reversed order of introduction, that is, the most recent binding appears first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="909a5f0dfd8c3a4ef79cd1458e2b5fb136ad7fae" translate="yes" xml:space="preserve">
          <source>Iterators</source>
          <target state="translated">Iterators</target>
        </trans-unit>
        <trans-unit id="92a60e08e4214743467aeef16832efbb28d68b7b" translate="yes" xml:space="preserve">
          <source>Iterators on two arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf924725c2b8039b9d275152dc025994654f8e3d" translate="yes" xml:space="preserve">
          <source>Iterators on two lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="ffb8b7268bc0ef366e246e15fb194af699da0d9a" translate="yes" xml:space="preserve">
          <source>Jump to the given time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="624a232e29c6285e85daf176c56dfb635d3dd7fd" translate="yes" xml:space="preserve">
          <source>Just as in the toplevel system (section &lt;a href=&quot;toplevel#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;), the user can register functions for printing values of certain types. For technical reasons, the debugger cannot call printing functions that reside in the program being debugged. The code for the printing functions must therefore be loaded explicitly in the debugger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="a940001b3198e7ae1e643d753be086d8c3542efb" translate="yes" xml:space="preserve">
          <source>Keep connection active</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="274136e14622e37b8b6331a086d3f3366e3831f5" translate="yes" xml:space="preserve">
          <source>Keep elements placed after/between the (**/**) special comment(s) (see section &lt;a href=&quot;#s%3Aocamldoc-comments&quot;&gt;16.2&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d62255be0ec9f781a5f40b46da0c3024c36bab8" translate="yes" xml:space="preserve">
          <source>Keep the assembly code produced during the compilation. The assembly code for the source file x.ml is saved in the file x.s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14983f1a3e8d2301fc0a539f434e69ec9ea45c93" translate="yes" xml:space="preserve">
          <source>Kill line character (usually ctrl-U).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c60b8fa8d42c209a51f605ad6c17c5d3484a13de" translate="yes" xml:space="preserve">
          <source>Kill the program being executed. This command is mainly useful if you wish to recompile the program without leaving the debugger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c67374519f2f22eab63c039c77b42da37349cc81" translate="yes" xml:space="preserve">
          <source>Kind of the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="74341e3c271df3c784e595b804b1f90be0f80429" translate="yes" xml:space="preserve">
          <source>Label</source>
          <target state="translated">Label</target>
        </trans-unit>
        <trans-unit id="ce4744e6d2befcbbcee49b587ff32fe4d8b6dfef" translate="yes" xml:space="preserve">
          <source>Label names, tag names, method names and instance variable names need not be qualified: the former three are global labels, while the latter are local to a class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7566409fe33db7c1382047b4b33d525174722c1" translate="yes" xml:space="preserve">
          <source>Label omitted in function application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2228985493d9e43e461c7be5525529248735ad9c" translate="yes" xml:space="preserve">
          <source>Labels</source>
          <target state="translated">Labels</target>
        </trans-unit>
        <trans-unit id="09193ca3e31ac574fb94c2e9ba86583737f30c6d" translate="yes" xml:space="preserve">
          <source>Labels are not ignored in types, labels may be used in applications, and labelled parameters can be given in any order. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d07567828d6157c7a0bbfacdccc17fbf690bde4" translate="yes" xml:space="preserve">
          <source>Labels obey the same rules as other identifiers in OCaml, that is you cannot use a reserved keyword (like in or to) as label.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac290ed377f5383ec5a1609fac7d51da07b74769" translate="yes" xml:space="preserve">
          <source>Large, multi-dimensional, numerical arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27ea870e756a4996b6e5548e72dad903dff893f" translate="yes" xml:space="preserve">
          <source>Last access time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ae7c6bdca85d087ad5892abd46d332ae4415d4" translate="yes" xml:space="preserve">
          <source>Last modification time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bd551a9da615e1f482b38b0b5800894d52c749c" translate="yes" xml:space="preserve">
          <source>Last status change time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96a1892b560a2dae03d58c477f42a35e2fc92bf8" translate="yes" xml:space="preserve">
          <source>Last-in first-out stacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84e98cf97551805d46a1030b73cb47aa40988008" translate="yes" xml:space="preserve">
          <source>Lazy</source>
          <target state="translated">Lazy</target>
        </trans-unit>
        <trans-unit id="7f09861439451aa36330c7bf95178c6ddcb46e50" translate="yes" xml:space="preserve">
          <source>Lazy patterns provide another way to force a lazy expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="634afef2094c369bdd48d1f752631ea2a14a676c" translate="yes" xml:space="preserve">
          <source>Leave out-of-band data in line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f5ed01117b556dfcfb05f94fe84491fe8dcbb5" translate="yes" xml:space="preserve">
          <source>Less commonly-used options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8e205d5e74a87e2d51ce5ba5fc4154c84a89a9f" translate="yes" xml:space="preserve">
          <source>Let custom.ml be the file defining a new generator class. Compilation of custom.ml can be performed by the following command :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90f57fc3563e16d5d28640fa27a45b5626288d1" translate="yes" xml:space="preserve">
          <source>Let us consider a more complex example: define a circle, whose center may be any kind of point. We put an additional type constraint in method move, since no free variables must remain unaccounted for by the class type parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ad92c4c358eba8bbc5b8a0969daf464a03c61f" translate="yes" xml:space="preserve">
          <source>Let-bindings within class definitions are evaluated before the object is constructed. It is also possible to evaluate an expression immediately after the object has been built. Such code is written as an anonymous hidden method called an initializer. Therefore, it can access self and the instance variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78e74717b8e8ca45266657c33dd0aa134152b63" translate="yes" xml:space="preserve">
          <source>Lexer buffers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eba638f354cbd4eea4869aa7af64033d01e9baca" translate="yes" xml:space="preserve">
          <source>Lexer buffers are an abstract data type implemented in the standard library module Lexing. The functions Lexing.from_channel, Lexing.from_string and Lexing.from_function create lexer buffers that read from an input channel, a character string, or any reading function, respectively. (See the description of module Lexing in chapter &lt;a href=&quot;stdlib#c%3Astdlib&quot;&gt;26&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92672530b6de1c7c2b6aa008abe880f35c25185c" translate="yes" xml:space="preserve">
          <source>Lexers can optionally maintain the &lt;code&gt;lex_curr_p&lt;/code&gt; and &lt;code&gt;lex_start_p&lt;/code&gt; position fields. This &quot;position tracking&quot; mode is the default, and it corresponds to passing &lt;code&gt;~with_position:true&lt;/code&gt; to functions that create lexer buffers. In this mode, the lexing engine and lexer actions are co-responsible for properly updating the position fields, as described in the next paragraph. When the mode is explicitly disabled (with &lt;code&gt;~with_position:false&lt;/code&gt;), the lexing engine will not touch the position fields and the lexer actions should be careful not to do it either; the &lt;code&gt;lex_curr_p&lt;/code&gt; and &lt;code&gt;lex_start_p&lt;/code&gt; field will then always hold the &lt;code&gt;dummy_pos&lt;/code&gt; invalid position. Not tracking positions avoids allocations and memory writes and can significantly improve the performance of the lexer in contexts where &lt;code&gt;lex_start_p&lt;/code&gt; and &lt;code&gt;lex_curr_p&lt;/code&gt; are not needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3917223ea7504c595a7ef33cb226700969d3360" translate="yes" xml:space="preserve">
          <source>Lexical ambiguities are resolved according to the &amp;ldquo;longest match&amp;rdquo; rule: when a character sequence can be decomposed into two tokens in several different ways, the decomposition retained is the one with the longest first token.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0a202cc33085b7bb25725a4f379636b34841789" translate="yes" xml:space="preserve">
          <source>Lexing</source>
          <target state="translated">Lexing</target>
        </trans-unit>
        <trans-unit id="a70e713317076c077fd1641566d360708f118d2a" translate="yes" xml:space="preserve">
          <source>Lexing.lexeme lexbuf</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16bbfe7d8b55633595dd6244e6f0439507cf30e5" translate="yes" xml:space="preserve">
          <source>Lexing.lexeme_char lexbuf n</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c74ea0f938e819ae2026560af60f9bf7b4293e6d" translate="yes" xml:space="preserve">
          <source>Lexing.lexeme_end lexbuf</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbd5d51aa0344b0018430731ae4cef689fd5ac6c" translate="yes" xml:space="preserve">
          <source>Lexing.lexeme_start lexbuf</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="29af859893fdcdadf9189b04f68a9abe34f1c20e" translate="yes" xml:space="preserve">
          <source>Lifting of constants to toplevel reduces allocation at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb0377305aff6b2536761bb8210a8352e72ce63" translate="yes" xml:space="preserve">
          <source>Lightweight threads for Posix &lt;code&gt;1003.1c&lt;/code&gt; and Win32.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850af4b7ba532914fbbab5d04f50f07c734c1799" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array1#VALget&quot;&gt;&lt;code&gt;Bigarray.Array1.get&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e8e123fe0b1dc99bead7adea2aec6a3d1ac2c9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array1#VALget&quot;&gt;&lt;code&gt;Bigarray.Array1.get&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed. Use with caution and only when the program logic guarantees that the access is within bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17cf409f10899743c833d44d422e8ce9982b9a92" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array1#VALset&quot;&gt;&lt;code&gt;Bigarray.Array1.set&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d6c54b020c7c7d74936820b2eb4bd3d379258c9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array1#VALset&quot;&gt;&lt;code&gt;Bigarray.Array1.set&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed. Use with caution and only when the program logic guarantees that the access is within bounds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfadb351771bde10f24fe7abed8ab6142dcbd0a1" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array2#VALget&quot;&gt;&lt;code&gt;Bigarray.Array2.get&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="221178edad17fc6894a4c266434a7aa9bc5afe69" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array2#VALset&quot;&gt;&lt;code&gt;Bigarray.Array2.set&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffbb6f02cca19cfee80223b75c549f0acb3031ee" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array3#VALget&quot;&gt;&lt;code&gt;Bigarray.Array3.get&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36ea99c63be240916526a60717058a5a7e0e8f87" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;bigarray.array3#VALset&quot;&gt;&lt;code&gt;Bigarray.Array3.set&lt;/code&gt;&lt;/a&gt;, but bounds checking is not always performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9e4e4e60b86cce032b0d708e5c35fefc9ea9ae" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;spacetime.series#VALsave_event&quot;&gt;&lt;code&gt;Spacetime.Series.save_event&lt;/code&gt;&lt;/a&gt;, but writes to the automatic snapshot file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bbbb7a679272947e8eb9d35cbee8a2de10a3c47" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;spacetime.series#VALsave_event&quot;&gt;&lt;code&gt;Spacetime.Series.save_event&lt;/code&gt;&lt;/a&gt;, but writes to the automatic snapshot file. This function is a no-op if OCAML_SPACETIME_INTERVAL was not set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285f14140f3588801dee3a1d5fb94c57e5e969c9" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lexeme_end&lt;/code&gt;, but return a complete &lt;code&gt;position&lt;/code&gt; instead of an offset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89e8a3b2000bfdbec151fc2e1f14f86877e2c204" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lexeme_end&lt;/code&gt;, but return a complete &lt;code&gt;position&lt;/code&gt; instead of an offset. When position tracking is disabled, the function returns &lt;code&gt;dummy_pos&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d05df27d0e208419cdd29b6ff60273cb7cdd7768" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lexeme_start&lt;/code&gt;, but return a complete &lt;code&gt;position&lt;/code&gt; instead of an offset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4e5ff07d8ec0b1c6d8bcaabede4dea51cec8d1b" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;lexeme_start&lt;/code&gt;, but return a complete &lt;code&gt;position&lt;/code&gt; instead of an offset. When position tracking is disabled, the function returns &lt;code&gt;dummy_pos&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc734516e0de9e6a8e3e99a4330cf58d7f961f5" translate="yes" xml:space="preserve">
          <source>Like constructed terms, polymorphic variant values are represented either as integers (for polymorphic variants without argument), or as blocks (for polymorphic variants with an argument). Unlike constructed terms, variant constructors are not numbered starting from 0, but identified by a hash value (an OCaml integer), as computed by the C function hash_variant (declared in &amp;lt;caml/mlvalues.h&amp;gt;): the hash value for a variant constructor named, say, VConstr is hash_variant(&quot;VConstr&quot;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84db1f1935fb847355e19d1183905165a54092aa" translate="yes" xml:space="preserve">
          <source>Like for modules, it is possible to include a signature to copy its components inside the current signature. For instance, we can extend the PRIOQUEUE signature with the extract_opt function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bed73780596b7f834ced053725e46c0df1f9817" translate="yes" xml:space="preserve">
          <source>Like for names, choosing labels for functions is not an easy task. A good labeling is a labeling which</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e1d0d1bfc15d7766298ee68fb31b046e1b23e5" translate="yes" xml:space="preserve">
          <source>Like in function definitions, the definition above can be abbreviated as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffd97eca67dfa1c7ecded513f14bd0f5af7f65f" translate="yes" xml:space="preserve">
          <source>Likewise.</source>
          <target state="translated">Likewise.</target>
        </trans-unit>
        <trans-unit id="d6a89f5f5aab1dc9ec97d86beabe3da25c8f6ddd" translate="yes" xml:space="preserve">
          <source>Limit the number of value nodes printed to at most n. Remaining parts of values are printed as ... (ellipsis).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ad9b678b8122b484b49d4fd677c60e7b110f651" translate="yes" xml:space="preserve">
          <source>Limit the printing of values to a maximal depth of d.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe294dbc375ee535fc34452b44543c9389175384" translate="yes" xml:space="preserve">
          <source>Limit the printing of values to a maximal depth of n. The parts of values whose depth exceeds n are printed as ... (ellipsis).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c82d004dcdb36148874aaf0cae92f27ef7fbfb" translate="yes" xml:space="preserve">
          <source>Limit the printing of values to at most l nodes printed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e07f2e960f4ea462077ce5669747d94a6df33827" translate="yes" xml:space="preserve">
          <source>Link in &amp;ldquo;custom runtime&amp;rdquo; mode. In the default linking mode, the linker produces bytecode that is intended to be executed with the shared runtime system, ocamlrun. In the custom runtime mode, the linker produces an output file that contains both the runtime system and the bytecode for the program. The resulting file is larger, but it can be executed directly, even if the ocamlrun command is not installed. Moreover, the &amp;ldquo;custom runtime&amp;rdquo; mode enables static linking of OCaml code with user-defined C functions, as described in chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e15b2364cc575d6dbc34984468f8d6d885901b" translate="yes" xml:space="preserve">
          <source>Link in &amp;ldquo;custom runtime&amp;rdquo; mode. See the corresponding option for ocamlc, in chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="dc3d988645b4957d3dd83740735d0cb6d66953cf" translate="yes" xml:space="preserve">
          <source>List concatenation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbd013775c64eff58dc6132a245c0ce270a850c6" translate="yes" xml:space="preserve">
          <source>List concatenation. Not tail-recursive (length of the first argument). Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0365ae410f8457307452f898da684eba14b29c5f" translate="yes" xml:space="preserve">
          <source>List of directories searched to find the bytecode executable file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eaa95db5646e28fe7153c07d0f70fa876dd1b94" translate="yes" xml:space="preserve">
          <source>List of format elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7094bd5e681efcce9038e6d995bf2d060fc85079" translate="yes" xml:space="preserve">
          <source>List operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2136f9decb402dc033169190742a9590a2e8171a" translate="yes" xml:space="preserve">
          <source>List operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b37d6672e7f341dcb945c17aabc1b419dec4f50" translate="yes" xml:space="preserve">
          <source>List reversal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="637c60434c34ad7a7432343dd717e34e34be9418" translate="yes" xml:space="preserve">
          <source>List scanning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76ca755f57f387a8fa5a689d0657d056de2dbb3e" translate="yes" xml:space="preserve">
          <source>List searching</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e130b5fdd6ede5933f5e364b277835f131b8204" translate="yes" xml:space="preserve">
          <source>List the source of module module, from line number beginning to line number end. By default, 20 lines of the current module are displayed, starting 10 lines before the current position.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca5f98ec9772c0239bb1a06bbafbaa7dccb5d4c" translate="yes" xml:space="preserve">
          <source>ListLabels</source>
          <target state="translated">ListLabels</target>
        </trans-unit>
        <trans-unit id="caa56fb279e78a5e60984ad896e4f99d33cd9ba0" translate="yes" xml:space="preserve">
          <source>Lists of pairs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9984cdc3b0e43d1b8e01a6016b6b16f60122a8" translate="yes" xml:space="preserve">
          <source>Literals for 32-bit integers are suffixed by l:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f376ff18d781ef4e7ce630da2eb8cc5e0867f63" translate="yes" xml:space="preserve">
          <source>Literals for 64-bit integers are suffixed by L:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6259c5bb5a0b49cb897bdeab6a0b94ebf736355f" translate="yes" xml:space="preserve">
          <source>Literals for native integers are suffixed by n:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68b1043a802b867b1154a51397b46d475fcc1b1c" translate="yes" xml:space="preserve">
          <source>Little-endian (resp. big-endian) encoding means that least (resp. most) significant bytes are stored first. Big-endian is also known as network byte order. Native-endian encoding is either little-endian or big-endian depending on &lt;a href=&quot;sys#VALbig_endian&quot;&gt;&lt;code&gt;Sys.big_endian&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cf6da19f9240117d92be77adf519c48a64293ee" translate="yes" xml:space="preserve">
          <source>Load in memory a bytecode object file (.cmo file) or library file (.cma file) produced by the batch compiler ocamlc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10cbe4ea6dac6abfc435470246f61cb80c7ae677" translate="yes" xml:space="preserve">
          <source>Load in memory a bytecode object file (.cmo file) or library file (.cma file) produced by the batch compiler ocamlc. When loading an object file that depends on other modules which have not been loaded yet, the .cmo files for these modules are searched and loaded as well, recursively. The loading order is not specified.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
