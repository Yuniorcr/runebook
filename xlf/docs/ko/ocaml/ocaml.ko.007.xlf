<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="7fe36a70c00075434c397a228dd28b19a5b40291" translate="yes" xml:space="preserve">
          <source>Add a type constraint or a .mli file to give a monomorphic type (without type variables) to name. For instance, instead of writing</source>
          <target state="translated">유형 제약 조건 또는 .mli 파일을 추가하여 이름에 단형 유형 (유형 변수 없음)을 제공합니다. 예를 들어, 쓰는 대신</target>
        </trans-unit>
        <trans-unit id="d8d460cb8c37089106d003c1064dc954647c1bde" translate="yes" xml:space="preserve">
          <source>Add chars to the buffer</source>
          <target state="translated">버퍼에 문자 추가</target>
        </trans-unit>
        <trans-unit id="affd53b88d19affb53002eff0f7ab10e5f0630fe" translate="yes" xml:space="preserve">
          <source>Add debugging information while compiling and linking. This option is required in order to be able to debug the program with ocamldebug (see chapter &lt;a href=&quot;debugger#c%3Adebugger&quot;&gt;17&lt;/a&gt;), and to produce stack backtraces when the program terminates on an uncaught exception (see section &lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt;).</source>
          <target state="translated">컴파일 및 링크하는 동안 디버깅 정보를 추가합니다. 이 옵션은 ocamldebug로 프로그램을 디버깅 할 수 있고 ( &lt;a href=&quot;debugger#c%3Adebugger&quot;&gt;17&lt;/a&gt; 장 참조 ), 프로그램이 포착되지 않은 예외에서 종료 될 때 스택 역 추적을 생성하기 위해 필요합니다 (섹션 &lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f703a0da73682e7d141b1e27a7036a264d64a0be" translate="yes" xml:space="preserve">
          <source>Add debugging information while compiling and linking. This option is required in order to produce stack backtraces when the program terminates on an uncaught exception (see section &lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt;).</source>
          <target state="translated">컴파일 및 링크하는 동안 디버깅 정보를 추가합니다. 이 옵션은 프로그램이 포착되지 않은 예외에서 종료 될 때 스택 역 추적을 생성하기 위해 필요합니다 (섹션 &lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="455a2ac695c6d841be54d9f6f0655b40013388f9" translate="yes" xml:space="preserve">
          <source>Add dir to the search path for support libraries (-llib).</source>
          <target state="translated">지원 라이브러리 (-llib)의 검색 경로에 dir을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="116b0bc4c5e306f590fdd8ab71c4f3dc593b0c74" translate="yes" xml:space="preserve">
          <source>Add directory to the list of directories search for compiled interface files (.cmi files).</source>
          <target state="translated">디렉토리 목록에 디렉토리를 추가하여 컴파일 된 인터페이스 파일 (.cmi 파일)을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="878c236c047eba2ad1017cde59fa0100f152504e" translate="yes" xml:space="preserve">
          <source>Add directory to the list of directories searched for source files and compiled files. (See also the directory command.)</source>
          <target state="translated">소스 파일 및 컴파일 된 파일을 검색 한 디렉토리 목록에 디렉토리를 추가하십시오. (디렉토리 명령도 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="be49e6e9b0eecf83542277ada9d3da7115d88260" translate="yes" xml:space="preserve">
          <source>Add information about character encoding being charset (default is iso-8859-1).</source>
          <target state="translated">문자 집합이되는 문자 인코딩에 대한 정보를 추가합니다 (기본값은 iso-8859-1).</target>
        </trans-unit>
        <trans-unit id="3b6ef14ba006276ead07154782672d0457bf2569" translate="yes" xml:space="preserve">
          <source>Add the elements from the generator to the end of the queue</source>
          <target state="translated">생성기의 요소를 대기열 끝에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6ac5528706d79b74ed1b9c9192758668ff8b43c2" translate="yes" xml:space="preserve">
          <source>Add the elements from the iterator on the top of the stack.</source>
          <target state="translated">스택 맨 위에있는 반복기의 요소를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f7dc7879ac55573a76496ddd53427351b0d604a9" translate="yes" xml:space="preserve">
          <source>Add the given bindings to the map, in order.</source>
          <target state="translated">지정된 바인딩을 순서대로 맵에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e0fad10cd0ddb0c2dfbda0638ff0f97fa42bff42" translate="yes" xml:space="preserve">
          <source>Add the given bindings to the table, using &lt;a href=&quot;hashtbl#VALadd&quot;&gt;&lt;code&gt;Hashtbl.add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;hashtbl#VALadd&quot;&gt; &lt;code&gt;Hashtbl.add&lt;/code&gt; 를&lt;/a&gt; 사용하여 주어진 바인딩을 테이블에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="abd7c11fca19595f5a44b83f3967232eedefd40a" translate="yes" xml:space="preserve">
          <source>Add the given bindings to the table, using &lt;a href=&quot;hashtbl#VALreplace&quot;&gt;&lt;code&gt;Hashtbl.replace&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;hashtbl#VALreplace&quot;&gt; &lt;code&gt;Hashtbl.replace&lt;/code&gt; 를&lt;/a&gt; 사용하여 주어진 바인딩을 테이블에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a1a38a85af367f6bd745ea024df2117e2ce32273" translate="yes" xml:space="preserve">
          <source>Add the given directories to the search path. These directories are added at the front, and will therefore be searched first.</source>
          <target state="translated">지정된 디렉토리를 검색 경로에 추가하십시오. 이러한 디렉토리는 맨 앞에 추가되므로 먼저 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="7c2a498cca321b2fed042a8d0a9f1d47b869451f" translate="yes" xml:space="preserve">
          <source>Add the given directory to the list of directories searched for compiled interface files (.cmi), compiled object code files (.cmx), and libraries (.cmxa). By default, the current directory is searched first, then the standard library directory. Directories added with -I are searched after the current directory, in the order in which they were given on the command line, but before the standard library directory. See also option -nostdlib.</source>
          <target state="translated">컴파일 된 인터페이스 파일 (.cmi), 컴파일 된 개체 코드 파일 (.cmx) 및 라이브러리 (.cmxa)를 검색 한 디렉터리 목록에 지정된 디렉터리를 추가합니다. 기본적으로 현재 디렉토리가 먼저 검색된 다음 표준 라이브러리 디렉토리가 검색됩니다. -I로 추가 된 디렉토리는 명령 줄에 지정된 순서대로 현재 디렉토리 뒤에서 검색되지만 표준 라이브러리 디렉토리 이전에서 검색됩니다. -nostdlib 옵션도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c8aa612e0bd4e90878648990b0d60b2f8b470f23" translate="yes" xml:space="preserve">
          <source>Add the given directory to the list of directories searched for compiled interface files (.cmi), compiled object code files .cmo, libraries (.cma) and C libraries specified with -cclib -lxxx. By default, the current directory is searched first, then the standard library directory. Directories added with -I are searched after the current directory, in the order in which they were given on the command line, but before the standard library directory. See also option -nostdlib.</source>
          <target state="translated">컴파일 된 인터페이스 파일 (.cmi), 컴파일 된 오브젝트 코드 파일 .cmo, 라이브러리 (.cma) 및 -cclib -lxxx로 지정된 C 라이브러리를 검색 한 디렉토리 목록에 지정된 디렉토리를 추가하십시오. 기본적으로 현재 디렉토리가 먼저 검색된 다음 표준 라이브러리 디렉토리가 검색됩니다. -I로 추가 된 디렉토리는 명령 줄에 지정된 순서대로 현재 디렉토리 뒤에서 검색되지만 표준 라이브러리 디렉토리 이전에서 검색됩니다. -nostdlib 옵션도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="80cdc17897cdef0ea127e80a815a02cb302ed598" translate="yes" xml:space="preserve">
          <source>Add the given directory to the list of directories searched for compiled object code files (.cmo and .cma).</source>
          <target state="translated">컴파일 된 개체 코드 파일 (.cmo 및 .cma)을 검색 한 디렉터리 목록에 지정된 디렉터리를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f21f70a2b309db4bc3ef2020833733d08aefdc27" translate="yes" xml:space="preserve">
          <source>Add the given directory to the list of directories searched for source and compiled files.</source>
          <target state="translated">소스 및 컴파일 된 파일을 검색 한 디렉토리 목록에 지정된 디렉토리를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e9b72349c349661191e6ab2b2f4321482a5c93cf" translate="yes" xml:space="preserve">
          <source>Add the given directory to the list of directories searched for source and compiled files. By default, the current directory is searched first, then the standard library directory. Directories added with -I are searched after the current directory, in the order in which they were given on the command line, but before the standard library directory. See also option -nostdlib.</source>
          <target state="translated">소스 및 컴파일 된 파일을 검색 한 디렉토리 목록에 지정된 디렉토리를 추가합니다. 기본적으로 현재 디렉토리가 먼저 검색된 다음 표준 라이브러리 디렉토리가 검색됩니다. -I로 추가 된 디렉토리는 명령 줄에 지정된 순서대로 현재 디렉토리 뒤에서 검색되지만 표준 라이브러리 디렉토리 이전에서 검색됩니다. -nostdlib 옵션도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="55301a601e766daeea1fded3c06e3dc26a7f2ce1" translate="yes" xml:space="preserve">
          <source>Add the given directory to the list of directories searched for source files. If a source file foo.ml mentions an external compilation unit Bar, a dependency on that unit&amp;rsquo;s interface bar.cmi is generated only if the source for bar is found in the current directory or in one of the directories specified with -I. Otherwise, Bar is assumed to be a module from the standard library, and no dependencies are generated. For programs that span multiple directories, it is recommended to pass ocamldep the same -I options that are passed to the compiler.</source>
          <target state="translated">소스 파일을 검색 한 디렉토리 목록에 지정된 디렉토리를 추가합니다. 소스 파일 foo.ml이 외부 컴파일 단위 Bar를 언급하면 ​​해당 단위의 인터페이스 bar.cmi에 대한 종속성은 bar의 소스가 현재 디렉토리 또는 -I로 지정된 디렉토리 중 하나에있는 경우에만 생성됩니다. 그렇지 않으면 Bar는 표준 라이브러리의 모듈로 간주되며 종속성이 생성되지 않습니다. 여러 디렉토리에 걸쳐있는 프로그램의 경우 컴파일러에 전달되는 것과 동일한 -I 옵션을 ocamldep에 전달하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="29e7020b45f1262cb41170e433ca8235ad7c946e" translate="yes" xml:space="preserve">
          <source>Add the given directory to the path where to look for custom generators.</source>
          <target state="translated">사용자 지정 생성기를 찾을 경로에 지정된 디렉터리를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="5d0af8f38e88eae6f30e6f6e5ee8f246c3bf179e" translate="yes" xml:space="preserve">
          <source>Add the given elements to the set, in order.</source>
          <target state="translated">주어진 요소를 순서대로 세트에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="1ddbfb3e864dea530a3009f02fcf2d7ae593b572" translate="yes" xml:space="preserve">
          <source>Add the suffix string to the name of the runtime library used by the program. Currently, only one such suffix is supported: d, and only if the OCaml compiler was configured with option -with-debug-runtime. This suffix gives the debug version of the runtime, which is useful for debugging pointer problems in low-level code such as C stubs.</source>
          <target state="translated">프로그램에서 사용하는 런타임 라이브러리 이름에 접미사 문자열을 추가합니다. 현재는 이러한 접미사 d 하나만 지원되며 OCaml 컴파일러가 -with-debug-runtime 옵션으로 구성된 경우에만 지원됩니다. 이 접미사는 C 스텁과 같은 저수준 코드에서 포인터 문제를 디버깅하는 데 유용한 런타임의 디버그 버전을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fde07839c2e1ab1f3cdd8033814a37ff821e5c7d" translate="yes" xml:space="preserve">
          <source>Adding such a wrapper will penalise indirect calls to the function (which might exist in arbitrary places; remember that this transformation is not for example applied only on functions the compiler has produced as a result of specialisation) since such calls will bounce through the wrapper. To mitigate this, if a function is small enough when weighed up against the number of free variables being removed, it will be duplicated by the transformation to obtain two versions: the original (used for indirect calls, since we can do no better) and the wrapper/rewritten function pair as described in the previous paragraph. The wrapper/rewritten function pair will only be used at direct call sites of the function. (The wrapper in this case is known as a &lt;em&gt;direct call surrogate&lt;/em&gt;, since it takes the place of another function&amp;mdash;the unchanged version used for indirect calls&amp;mdash;at direct call sites.)</source>
          <target state="translated">이러한 래퍼를 추가하면 함수에 대한 간접 호출 (임의의 위치에 존재할 수 있음)에 페널티를줍니다. 이러한 변환은 예를 들어 컴파일러가 특수화의 결과로 생성 한 함수에만 적용되지 않습니다. 이러한 호출은 래퍼를 통해 바운스되기 때문입니다. 이를 완화하기 위해 함수가 제거되는 자유 변수의 수와 비교했을 때 충분히 작 으면 변환에 의해 복제되어 원본 (간접 호출에 사용됨)과 두 가지 버전을 얻습니다. 이전 단락에서 설명한대로 래퍼 / 재 작성된 함수 쌍. 래퍼 / 재 작성된 함수 쌍은 함수의 직접 호출 사이트에서만 사용됩니다. (이 경우 래퍼를 &lt;em&gt;직접 통화 대리라고합니다.&lt;/em&gt;, 직접 호출 사이트에서 간접 호출에 사용되는 변경되지 않은 버전 인 다른 기능을 대신하기 때문입니다.)</target>
        </trans-unit>
        <trans-unit id="8e8428e85c661f03dd33db8f12b20a010ab5be5e" translate="yes" xml:space="preserve">
          <source>Addition</source>
          <target state="translated">Addition</target>
        </trans-unit>
        <trans-unit id="e372ea45fd570b0859356c6972474a58f8da3b86" translate="yes" xml:space="preserve">
          <source>Addition.</source>
          <target state="translated">Addition.</target>
        </trans-unit>
        <trans-unit id="b36e2f53930600a65d8f90fb7c04d3c68cb6a078" translate="yes" xml:space="preserve">
          <source>Additional directories to search for compiled object code files (.cmi, .cmo and .cma). The specified directories are considered from left to right, after the include directories specified on the command line via -I have been searched. Available since OCaml 4.08.</source>
          <target state="translated">컴파일 된 개체 코드 파일 (.cmi, .cmo 및 .cma)을 검색하기위한 추가 디렉터리입니다. -I를 통해 명령 줄에 지정된 포함 디렉터리를 검색 한 후 지정된 디렉터리는 왼쪽에서 오른쪽으로 간주됩니다. OCaml 4.08부터 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="020cf7d20693ee54765c9f2fb5a0cc253fce23c6" translate="yes" xml:space="preserve">
          <source>Additional directories to search for dynamically-loaded libraries (see section &lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;).</source>
          <target state="translated">동적으로로드 된 라이브러리를 검색하기위한 추가 디렉토리 (섹션 &lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2e0a4e8cb19afd44c38722faacb960225f305ceb" translate="yes" xml:space="preserve">
          <source>Additionally, built-in exceptions with a structured argument that includes a string also have the attribute set: Assert_failure and Match_failure will raise the warning for a pattern that uses a literal string to match the first element of their tuple argument.</source>
          <target state="translated">또한 문자열을 포함하는 구조화 된 인수가있는 내장 예외에는 속성 세트도 있습니다. Assert_failure 및 Match_failure는 리터럴 문자열을 사용하여 튜플 인수의 첫 번째 요소와 일치하는 패턴에 대한 경고를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d70f93df5e8f9b55be44fbeee9d203972e3383d4" translate="yes" xml:space="preserve">
          <source>Address</source>
          <target state="translated">Address</target>
        </trans-unit>
        <trans-unit id="53cce0631f5ba4546493e150cc5ef970434eef7f" translate="yes" xml:space="preserve">
          <source>Address already in use</source>
          <target state="translated">이미 사용중인 주소</target>
        </trans-unit>
        <trans-unit id="cf3745f20c2bcb9c33dec185e795a8e5bec761e0" translate="yes" xml:space="preserve">
          <source>Address family not supported by protocol family</source>
          <target state="translated">프로토콜 제품군에서 지원하지 않는 주소 제품군</target>
        </trans-unit>
        <trans-unit id="84b449a1c0e4b819e90ee96bb46539dc08f8d4fc" translate="yes" xml:space="preserve">
          <source>Address information returned by &lt;a href=&quot;unix#VALgetaddrinfo&quot;&gt;&lt;code&gt;Unix.getaddrinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALgetaddrinfo&quot;&gt; &lt;code&gt;Unix.getaddrinfo&lt;/code&gt; 에서&lt;/a&gt; 반환하는 주소 정보 입니다.</target>
        </trans-unit>
        <trans-unit id="5270967f8aa725bc38f8d3001d92c3c290cfd4e3" translate="yes" xml:space="preserve">
          <source>Adds the directory dir to the run-time search path for shared C libraries. At link-time, shared libraries are searched in the standard search path (the one corresponding to the -I option). The -dllpath option simply stores dir in the produced executable file, where ocamlrun can find it and use it as described in section &lt;a href=&quot;runtime#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;.</source>
          <target state="translated">공유 C 라이브러리의 런타임 검색 경로에 디렉토리 dir을 추가합니다. 링크 타임에 공유 라이브러리는 표준 검색 경로 (-I 옵션에 해당하는 경로)에서 검색됩니다. -dllpath 옵션은 생성 된 실행 파일에 dir을 저장합니다. 여기서 ocamlrun은 섹션 &lt;a href=&quot;runtime#s%3Aocamlrun-dllpath&quot;&gt;11.3에&lt;/a&gt; 설명 된대로 찾아서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b8d4ba924eb9ae0cdf52c36ae7d6177d243e3d97" translate="yes" xml:space="preserve">
          <source>Advanced functions</source>
          <target state="translated">고급 기능</target>
        </trans-unit>
        <trans-unit id="5be1dccb0ebeabdbef35b5315c8f47e16cedaecc" translate="yes" xml:space="preserve">
          <source>Advanced options, only needed for detailed tuning:</source>
          <target state="translated">세부 조정에만 필요한 고급 옵션 :</target>
        </trans-unit>
        <trans-unit id="7fd85ae0c465f1d173aeb4b1bcfa8f8c49970ca7" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;Hashtbl.randomize()&lt;/code&gt;, hash tables are created in randomized mode by default: &lt;a href=&quot;hashtbl#VALcreate&quot;&gt;&lt;code&gt;Hashtbl.create&lt;/code&gt;&lt;/a&gt; returns randomized hash tables, unless the &lt;code&gt;~random:false&lt;/code&gt; optional parameter is given.</source>
          <target state="translated">&lt;code&gt;Hashtbl.randomize()&lt;/code&gt; 호출하면 기본적으로 무작위 모드로 해시 테이블이 생성됩니다 . &lt;code&gt;~random:false&lt;/code&gt; 선택적 매개 변수가 제공 되지 않는 한 &lt;a href=&quot;hashtbl#VALcreate&quot;&gt; &lt;code&gt;Hashtbl.create&lt;/code&gt; &lt;/a&gt; 는 무작위 해시 테이블을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="02e705c02a6171a4c6d4fea54dc86bfd5ddbe3e1" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;Hashtbl.randomize()&lt;/code&gt;, hash tables are created in randomized mode by default: &lt;a href=&quot;hashtbl#VALcreate&quot;&gt;&lt;code&gt;Hashtbl.create&lt;/code&gt;&lt;/a&gt; returns randomized hash tables, unless the &lt;code&gt;~random:false&lt;/code&gt; optional parameter is given. The same effect can be achieved by setting the &lt;code&gt;R&lt;/code&gt; parameter in the &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;Hashtbl.randomize()&lt;/code&gt; 호출하면 기본적으로 무작위 모드로 해시 테이블이 생성됩니다 . &lt;code&gt;~random:false&lt;/code&gt; 선택적 매개 변수가 제공 되지 않는 한 &lt;a href=&quot;hashtbl#VALcreate&quot;&gt; &lt;code&gt;Hashtbl.create&lt;/code&gt; &lt;/a&gt; 는 무작위 해시 테이블을 반환합니다 . &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; 환경 변수 에서 &lt;code&gt;R&lt;/code&gt; 매개 변수를 설정하여 동일한 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac648fcd20415a281eac85d7cfc4129ef642c1e4" translate="yes" xml:space="preserve">
          <source>After caml_release_runtime_system() was called and until caml_acquire_runtime_system() is called, the C code must not access any OCaml data, nor call any function of the run-time system, nor call back into OCaml code. Consequently, arguments provided by OCaml to the C primitive must be copied into C data structures before calling caml_release_runtime_system(), and results to be returned to OCaml must be encoded as OCaml values after caml_acquire_runtime_system() returns.</source>
          <target state="translated">caml_release_runtime_system ()이 호출 된 후 caml_acquire_runtime_system ()이 호출 될 때까지 C 코드는 OCaml 데이터에 액세스하거나 런타임 시스템의 함수를 호출하거나 OCaml 코드로 다시 호출해서는 안됩니다. 결과적으로, OCaml이 C 프리미티브에 제공하는 인수는 caml_release_runtime_system ()을 호출하기 전에 C 데이터 구조로 복사되어야하며, OCaml로 반환 될 결과는 caml_acquire_runtime_system ()이 반환 된 후 OCaml 값으로 인코딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="22f3f0c73dbb8d47c45b8752a616d7f9c2523dbd" translate="yes" xml:space="preserve">
          <source>After executing this directive, all calls to the function named function-name will be &amp;ldquo;traced&amp;rdquo;. That is, the argument and the result are displayed for each call, as well as the exceptions escaping out of the function, raised either by the function itself or by another function it calls. If the function is curried, each argument is printed as it is passed to the function.</source>
          <target state="translated">이 지시문을 실행 한 후 function-name이라는 함수에 대한 모든 호출이 &quot;추적&quot;됩니다. 즉, 함수 자체 또는 호출하는 다른 함수에 의해 발생하는 함수에서 이스케이프되는 예외뿐만 아니라 각 호출에 대해 인수와 결과가 표시됩니다. 함수가 커리되면 함수에 전달 될 때 각 인수가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="257160058fb41d4072933c8170fd8f8c677a4ecd" translate="yes" xml:space="preserve">
          <source>After having described two different ways of linking C code with OCaml code, we now review the pros and cons of each, to help developers of mixed OCaml/C libraries decide.</source>
          <target state="translated">C 코드를 OCaml 코드와 연결하는 두 가지 다른 방법을 설명한 후 이제 혼합 된 OCaml / C 라이브러리의 개발자가 결정하는 데 도움이되도록 각각의 장단점을 검토합니다.</target>
        </trans-unit>
        <trans-unit id="f4b712f12ee962e9088425b2d7e23377568c3262" translate="yes" xml:space="preserve">
          <source>After parsing, pipe the abstract syntax tree through the preprocessor command.</source>
          <target state="translated">구문 분석 후 전 처리기 명령을 통해 추상 구문 트리를 파이프하십시오.</target>
        </trans-unit>
        <trans-unit id="ee48a1ecc4cbaee8ef092b9aba20f2e0cf9fdf5e" translate="yes" xml:space="preserve">
          <source>After parsing, pipe the abstract syntax tree through the preprocessor command. The module Ast_mapper, described in chapter &lt;a href=&quot;parsing#c%3Aparsinglib&quot;&gt;27&lt;/a&gt;: &lt;a href=&quot;https://www.ocaml.org/releases/4.11/htmlman/compilerlibref/Ast_mapper.html&quot;&gt; Ast_mapper &lt;/a&gt; , implements the external interface of a preprocessor.</source>
          <target state="translated">구문 분석 후 전 처리기 명령을 통해 추상 구문 트리를 파이프하십시오. &lt;a href=&quot;parsing#c%3Aparsinglib&quot;&gt;27&lt;/a&gt; 장 : &lt;a href=&quot;https://www.ocaml.org/releases/4.11/htmlman/compilerlibref/Ast_mapper.html&quot;&gt;Ast_mapper&lt;/a&gt; 에서 설명한 모듈 Ast_mapper 는 전 처리기의 외부 인터페이스를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="dd92f6a0efeae359634460366d11e9ed96823d66" translate="yes" xml:space="preserve">
          <source>After seeing the power of polymorphic variants, one may wonder why they were added to core language variants, rather than replacing them.</source>
          <target state="translated">다형성 변형의 힘을 확인한 후, 대체하는 것이 아니라 핵심 언어 변형에 추가 된 이유를 궁금해 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98077527fdcfbdc6101af79b0d0d9c0e8c053b7f" translate="yes" xml:space="preserve">
          <source>After some simplification one obtains:</source>
          <target state="translated">몇 가지 단순화 후 다음을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="a7dfd6ec974bc59afe5b3477ea504301f11b2496" translate="yes" xml:space="preserve">
          <source>After storing an int inside another_store, the type of another_store has been updated from '_weak2 option ref to int option ref. This distinction between weakly and generic polymorphic type variable protects OCaml programs from unsoundness and runtime errors. To understand from where unsoundness might come, consider this simple function which swaps a value x with the value stored inside a store reference, if there is such value:</source>
          <target state="translated">another_store에 int를 저장 한 후 another_store의 유형이 '_weak2 option ref에서 int 옵션 ref로 업데이트되었습니다. 약한 다형성 유형 변수와 일반적인 다형성 유형 변수의 이러한 구별은 OCaml 프로그램을 불건전 함과 런타임 오류로부터 보호합니다. 불건전 함이 어디에서 올 수 있는지 이해하려면 값 x를 스토어 참조 내에 저장된 값으로 바꾸는 다음과 같은 간단한 함수를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="de2424914b6a7484490fab4a07f86daa99ea2b9c" translate="yes" xml:space="preserve">
          <source>After these three swaps the stored value is 3. Everything is fine up to now. We can then try to swap 3 with a more interesting value, for instance a function:</source>
          <target state="translated">이 세 번의 스왑 후 저장된 값은 3입니다. 지금까지는 괜찮습니다. 그런 다음 3을 더 흥미로운 값 (예 : 함수)으로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b9ebba0b459da8f8a959c4937a6826b5bb4adc4" translate="yes" xml:space="preserve">
          <source>After these two transformations, expressions are of the form</source>
          <target state="translated">이 두 가지 변환 후 표현식은 다음과 같은 형식입니다.</target>
        </trans-unit>
        <trans-unit id="68b46d92c4b3bfc51be50c9bc62acab867d8d2bb" translate="yes" xml:space="preserve">
          <source>Again, there is nothing magical with references: they are implemented as a single-field mutable record, as follows.</source>
          <target state="translated">다시 말하지만, 참조에는 마법 같은 것이 없습니다. 참조는 다음과 같이 단일 필드 가변 레코드로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="ecd0fa8e76723ac77809d90f781cf47149c2c8dc" translate="yes" xml:space="preserve">
          <source>Alert categories are identified by a symbolic identifier (a lowercase identifier, following the usual lexical rules) and an optional message. The identifier is used to control which alerts are enabled, and which ones are turned into fatal errors. The message is reported to the user when the alert is triggered (i.e. when the marked component is referenced).</source>
          <target state="translated">경고 범주는 기호 식별자 (일반 어휘 규칙을 따르는 소문자 식별자) 및 선택적 메시지로 식별됩니다. 식별자는 활성화 된 경고와 치명적인 오류로 전환되는 경고를 제어하는 ​​데 사용됩니다. 경고가 트리거 될 때 (즉, 표시된 구성 요소가 참조 될 때) 메시지가 사용자에게보고됩니다.</target>
        </trans-unit>
        <trans-unit id="821334d0607e9afb49ba329bf32f1077eb433ccf" translate="yes" xml:space="preserve">
          <source>Alias for warning 10.</source>
          <target state="translated">경고 별칭 10.</target>
        </trans-unit>
        <trans-unit id="4b5faefdecb0d6fd295593a70f0d88b7f5386973" translate="yes" xml:space="preserve">
          <source>Alias for warning 13.</source>
          <target state="translated">경고 별칭 13.</target>
        </trans-unit>
        <trans-unit id="6eece4bf4c590c7dca347390d3119eb2ce22ea01" translate="yes" xml:space="preserve">
          <source>Alias for warning 26.</source>
          <target state="translated">경고 별칭 26.</target>
        </trans-unit>
        <trans-unit id="4163b3aea847321829d86afa31a4866fa132ed79" translate="yes" xml:space="preserve">
          <source>Alias for warning 27.</source>
          <target state="translated">경고 별칭 27.</target>
        </trans-unit>
        <trans-unit id="32df4d86c18ecdcc1901160c34d77742ec601179" translate="yes" xml:space="preserve">
          <source>Alias for warning 3.</source>
          <target state="translated">경고 별칭 3.</target>
        </trans-unit>
        <trans-unit id="bd24a64bfd177df95e265236817244ef9d001bc3" translate="yes" xml:space="preserve">
          <source>Alias for warning 4.</source>
          <target state="translated">경고 별칭 4.</target>
        </trans-unit>
        <trans-unit id="7880efc4150138dded4fa14b7a41acde0e894e3f" translate="yes" xml:space="preserve">
          <source>Alias for warning 5.</source>
          <target state="translated">경고 별칭 5.</target>
        </trans-unit>
        <trans-unit id="77c8d2d8da2b271f2b475dfe61c813fbeffb3ca5" translate="yes" xml:space="preserve">
          <source>Alias for warning 6.</source>
          <target state="translated">경고 별칭 6.</target>
        </trans-unit>
        <trans-unit id="215bcb589afee870a003884e4452475af7c5ed14" translate="yes" xml:space="preserve">
          <source>Alias for warning 7.</source>
          <target state="translated">경고 별칭 7.</target>
        </trans-unit>
        <trans-unit id="963fdff6a5307cc304547c984bd4142a3b4696d5" translate="yes" xml:space="preserve">
          <source>Alias for warning 8.</source>
          <target state="translated">경고 별칭 8.</target>
        </trans-unit>
        <trans-unit id="088453e73019790a41f30c40d4205f51a852ec4c" translate="yes" xml:space="preserve">
          <source>Alias for warning 9.</source>
          <target state="translated">경고 별칭 9.</target>
        </trans-unit>
        <trans-unit id="cd069e9b1f6d0a212cf41e18091994c486044df3" translate="yes" xml:space="preserve">
          <source>Align the documentation strings by inserting spaces at the first alignment separator (tab or, if tab is not found, space), according to the length of the keyword.</source>
          <target state="translated">키워드의 길이에 따라 첫 번째 정렬 구분 기호 (탭 또는 탭을 찾을 수없는 경우 공백)에 공백을 삽입하여 문서 문자열을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="7e3d3b738466251ab926226a86221e4d1ccacf36" translate="yes" xml:space="preserve">
          <source>Align the documentation strings by inserting spaces at the first alignment separator (tab or, if tab is not found, space), according to the length of the keyword. Use a alignment separator as the first character in a doc string if you want to align the whole string. The doc strings corresponding to &lt;code&gt;Symbol&lt;/code&gt; arguments are aligned on the next line.</source>
          <target state="translated">키워드의 길이에 따라 첫 번째 정렬 구분 기호 (탭 또는 탭을 찾을 수없는 경우 공백)에 공백을 삽입하여 문서 문자열을 정렬합니다. 전체 문자열을 정렬하려면 문서 문자열의 첫 번째 문자로 정렬 구분 기호를 사용하십시오. &lt;code&gt;Symbol&lt;/code&gt; 인수에 해당하는 문서 문자열 은 다음 줄에 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="50e67b08d6e3d9f789945f9c7fdbe8a81e2fa03b" translate="yes" xml:space="preserve">
          <source>All OCaml objects are represented by the C type value, defined in the include file caml/mlvalues.h, along with macros to manipulate values of that type. An object of type value is either:</source>
          <target state="translated">모든 OCaml 객체는 해당 유형의 값을 조작하는 매크로와 함께 포함 파일 caml / mlvalues.h에 정의 된 C 유형 값으로 표시됩니다. 값 유형의 개체는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="df48daa3b9798ecd1f34fe9ea2fad4646f39d23f" translate="yes" xml:space="preserve">
          <source>All characters in an identifier are meaningful. The current implementation accepts identifiers up to 16000000 characters in length.</source>
          <target state="translated">식별자의 모든 문자는 의미가 있습니다. 현재 구현은 최대 16000000 자 길이의 식별자를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="f6df6defb9629939a8b8045bff562a3ca8d0bf6b" translate="yes" xml:space="preserve">
          <source>All examples given so far were executed under the interactive system. OCaml code can also be compiled separately and executed non-interactively using the batch compilers ocamlc and ocamlopt. The source code must be put in a file with extension .ml. It consists of a sequence of phrases, which will be evaluated at runtime in their order of appearance in the source file. Unlike in interactive mode, types and values are not printed automatically; the program must call printing functions explicitly to produce some output. The ;; used in the interactive examples is not required in source files created for use with OCaml compilers, but can be helpful to mark the end of a top-level expression unambiguously even when there are syntax errors. Here is a sample standalone program to print the greatest common divisor (gcd) of two numbers:</source>
          <target state="translated">지금까지 제공된 모든 예제는 대화 형 시스템에서 실행되었습니다. OCaml 코드는 별도로 컴파일 할 수 있으며 배치 컴파일러 ocamlc 및 ocamlopt를 사용하여 비대화 형으로 실행할 수 있습니다. 소스 코드는 확장자가 .ml 인 파일에 넣어야합니다. 소스 파일에 나타나는 순서대로 런타임에 평가되는 일련의 구문으로 구성됩니다. 대화 형 모드와 달리 유형 및 값은 자동으로 인쇄되지 않습니다. 프로그램은 출력을 생성하기 위해 명시 적으로 인쇄 함수를 호출해야합니다. ;; 대화식 예제에서 사용되는 것은 OCaml 컴파일러와 함께 사용하기 위해 생성 된 소스 파일에 필요하지 않지만 구문 오류가있는 경우에도 최상위 수준 표현식의 끝을 모호하지 않게 표시하는 데 도움이 될 수 있습니다. 다음은 두 숫자의 최대 공약수 (gcd)를 인쇄하는 샘플 독립 실행 형 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="ca5470f7fbad01a79cf6d9fb16235ab7f64f936b" translate="yes" xml:space="preserve">
          <source>All examples of modules so far have been given in the context of the interactive system. However, modules are most useful for large, batch-compiled programs. For these programs, it is a practical necessity to split the source into several files, called compilation units, that can be compiled separately, thus minimizing recompilation after changes.</source>
          <target state="translated">지금까지 모듈의 모든 예는 대화식 시스템의 맥락에서 제공되었습니다. 그러나 모듈은 대규모 일괄 컴파일 프로그램에 가장 유용합니다. 이러한 프로그램의 경우 소스를 컴파일 단위라고하는 여러 파일로 분할해야합니다.이 파일은 개별적으로 컴파일 할 수 있으므로 변경 후 재 컴파일을 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="39c8d1b1c4caf1c601b893772f4974723068b285" translate="yes" xml:space="preserve">
          <source>All following functions raise &lt;code&gt;Invalid_argument&lt;/code&gt; if the space needed at index &lt;code&gt;i&lt;/code&gt; to decode or encode the integer is not available.</source>
          <target state="translated">정수를 디코딩하거나 인코딩하기 위해 인덱스 &lt;code&gt;i&lt;/code&gt; 에 필요한 공간을 사용할 수없는 경우 다음 모든 함수는 &lt;code&gt;Invalid_argument&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="4350dcd576a4e74e66f577f6d6df18a6f84b5433" translate="yes" xml:space="preserve">
          <source>All identifiers starting with __ocaml_lex are reserved for use by ocamllex; do not use any such identifier in your programs.</source>
          <target state="translated">__ocaml_lex로 시작하는 모든 식별자는 ocamllex에서 사용하도록 예약되어 있습니다. 프로그램에서 이러한 식별자를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="71e79e2a4589c52dc85926f87b5a7800dc39bd3b" translate="yes" xml:space="preserve">
          <source>All of this contrasts with the normal Flambda mode, that is to say without -Oclassic, where:</source>
          <target state="translated">이 모든 것은 일반적인 Flambda 모드, 즉 -Oclassic이없는 모드와 대조됩니다.</target>
        </trans-unit>
        <trans-unit id="c797607c91b085bf9b06812cc7196d849ff516b3" translate="yes" xml:space="preserve">
          <source>All open pretty-printing boxes are closed, all pending text is printed.</source>
          <target state="translated">열린 예쁜 인쇄 상자가 모두 닫히고 보류중인 모든 텍스트가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="d0b207b88f6d453906fd55cf2a3659eb2c4f68c8" translate="yes" xml:space="preserve">
          <source>All open pretty-printing boxes are closed, all pending text is printed. In addition, the pretty-printer low level output device is flushed to ensure that all pending text is really displayed.</source>
          <target state="translated">열린 예쁜 인쇄 상자가 모두 닫히고 보류중인 모든 텍스트가 인쇄됩니다. 또한 모든 보류중인 텍스트가 실제로 표시되도록 pretty-printer 저수준 출력 장치가 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="6551aef0a45b5b4f68c9d4cf5ba28e52be6a56df" translate="yes" xml:space="preserve">
          <source>All other expressions.</source>
          <target state="translated">다른 모든 표현.</target>
        </trans-unit>
        <trans-unit id="c885373b4f263d43af575175d00b5ef8dd474226" translate="yes" xml:space="preserve">
          <source>All the already tracked blocks are discarded.</source>
          <target state="translated">이미 추적 된 모든 블록이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="206daea334aed98570a738274bdc211c4eba092a" translate="yes" xml:space="preserve">
          <source>All the macros described in this section are declared in the memory.h header file.</source>
          <target state="translated">이 섹션에서 설명하는 모든 매크로는 memory.h 헤더 파일에서 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="fcce04f333a29fbbb1662957786419fcadd58918" translate="yes" xml:space="preserve">
          <source>All the types defined in this module cannot be marshaled using &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt; or the functions of the &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">이 모듈에 정의 된 모든 유형은 &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt; &lt;code&gt;output_value&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;marshal&quot;&gt; &lt;code&gt;Marshal&lt;/code&gt; &lt;/a&gt; 모듈 의 함수를 사용하여 마샬링 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="5a19322561e155e0a2ce027d9a7b57fb495aafc3" translate="yes" xml:space="preserve">
          <source>All these are only suggestions, but keep in mind that the choice of labels is essential for readability. Bizarre choices will make the program harder to maintain.</source>
          <target state="translated">이 모든 것은 제안 일 뿐이지 만 라벨 선택은 가독성을 위해 필수적입니다. 기괴한 선택은 프로그램을 유지하기 어렵게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="17ff6b82a7573e6fc2606123d9479ee9046c5f88" translate="yes" xml:space="preserve">
          <source>All toplevel expressions in the loaded compilation units are evaluated. No facilities are provided to access value names defined by the unit. Therefore, the unit must itself register its entry points with the main program (or a previously-loaded library) e.g. by modifying tables of functions.</source>
          <target state="translated">로드 된 컴파일 단위의 모든 최상위 표현식이 평가됩니다. 단위에서 정의한 값 이름에 액세스 할 수있는 기능이 제공되지 않습니다. 따라서 장치는 예를 들어 함수 테이블을 수정하여 기본 프로그램 (또는 이전에로드 된 라이브러리)에 진입 점을 등록해야합니다.</target>
        </trans-unit>
        <trans-unit id="cff492aa66c39fd91b14adc9bbf1e9b13c1f3ced" translate="yes" xml:space="preserve">
          <source>Allow arbitrary recursive types during type-checking. By default, only recursive types where the recursion goes through an object type are supported.</source>
          <target state="translated">유형 검사 중에 임의의 재귀 유형을 허용합니다. 기본적으로 재귀가 객체 유형을 통과하는 재귀 유형 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="bfccfe308745d0b85e1ddbf443fd40e1997b55e3" translate="yes" xml:space="preserve">
          <source>Allow arbitrary recursive types during type-checking. By default, only recursive types where the recursion goes through an object type are supported.Note that once you have created an interface using this flag, you must use it again for all dependencies.</source>
          <target state="translated">유형 검사 중에 임의의 재귀 유형을 허용합니다. 기본적으로 재귀가 객체 유형을 통과하는 재귀 유형 만 지원됩니다.이 플래그를 사용하여 인터페이스를 만든 후에는 모든 종속성에 대해 다시 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="aacfe39edb68023f9b53979cfb137d43eb38557f" translate="yes" xml:space="preserve">
          <source>Allow arbitrary recursive types during type-checking. Note: once enabled, this option cannot be disabled because that would lead to unsoundness of the type system.</source>
          <target state="translated">유형 검사 중에 임의의 재귀 유형을 허용합니다. 참고 : 활성화 된 후에는 유형 시스템의 불건전 함을 유발할 수 있으므로이 옵션을 비활성화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d16d714ce85383f7fc519249166d89d83b1fed95" translate="yes" xml:space="preserve">
          <source>Allow arbitrary recursive types. (See the -rectypes option to ocamlc.)</source>
          <target state="translated">임의의 재귀 유형을 허용합니다. (ocamlc에 대한 -rectypes 옵션을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="9e6cfa8f1f0745980bd8e3a9df75ee4c71720548" translate="yes" xml:space="preserve">
          <source>Allow falling back on a lexer-based approximation when parsing fails.</source>
          <target state="translated">구문 분석이 실패 할 때 어휘 분석기 기반 근사치로 폴백 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6a7ba8579f52788429ec3c986d236f094628562" translate="yes" xml:space="preserve">
          <source>Allow reuse of local addresses for bind</source>
          <target state="translated">바인드에 로컬 주소 재사용 허용</target>
        </trans-unit>
        <trans-unit id="bb7adde246f249f8dc82789201ca6af6580832c5" translate="yes" xml:space="preserve">
          <source>Allow the compiler to use some optimizations that are valid only for code that is never dynlinked.</source>
          <target state="translated">컴파일러가 dynlink되지 않은 코드에만 유효한 일부 최적화를 사용하도록 허용합니다.</target>
        </trans-unit>
        <trans-unit id="1ca705a2ff6c8f1e818a0c819bb67a88c184d39c" translate="yes" xml:space="preserve">
          <source>Also note that exceptions raised by user code in the interactive toplevel are not passed to this function as they are caught by the toplevel itself.</source>
          <target state="translated">또한 대화 형 최상위 수준에서 사용자 코드에 의해 발생한 예외는 최상위 수준 자체에서 포착되므로이 함수에 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73c938c60afba012453b4b0c8907a74c515465fa" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;list#VALfold_left&quot;&gt;&lt;code&gt;List.fold_left&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;list#VALfold_left&quot;&gt; &lt;code&gt;List.fold_left&lt;/code&gt; &lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c4b2c25bebd20c1df230a4e4e8766f8390e7df9e" translate="yes" xml:space="preserve">
          <source>Also, finalization can be performed by trapping all exceptions, performing the finalization, then re-raising the exception:</source>
          <target state="translated">또한 모든 예외를 트랩하고 종료를 수행 한 다음 예외를 다시 발생시켜 종료를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="762745851a3dbf826d56e09e22e9a0b4a5051807" translate="yes" xml:space="preserve">
          <source>Alternate end-of-line char. (usually none).</source>
          <target state="translated">대체 줄 끝 문자. (보통 없음).</target>
        </trans-unit>
        <trans-unit id="a8e1724ceb669eb15e9b85abbb432d9fd0962e04" translate="yes" xml:space="preserve">
          <source>Alternative executable to use instead of the configured value. Primarily used for bootstrapping.</source>
          <target state="translated">구성된 값 대신 사용할 대체 실행 파일입니다. 주로 부트 스트랩에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="20a3dd320f432929619399edc970bd7bc9279557" translate="yes" xml:space="preserve">
          <source>Alternative executable to use on native Windows for flexlink instead of the configured value. Primarily used for bootstrapping.</source>
          <target state="translated">구성된 값 대신 기본 Windows에서 flexlink 용으로 사용할 대체 실행 파일입니다. 주로 부트 스트랩에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c9e397bee97f159dc7f7a7adecb64951a2a4af03" translate="yes" xml:space="preserve">
          <source>Alternatively, given &lt;code&gt;out_funs&lt;/code&gt;, a complete set of output functions for a formatter, then &lt;a href=&quot;format#VALformatter_of_out_functions&quot;&gt;&lt;code&gt;Format.formatter_of_out_functions&lt;/code&gt;&lt;/a&gt;&lt;code&gt;out_funs&lt;/code&gt; computes a new formatter using those functions for output.</source>
          <target state="translated">또는 &lt;code&gt;out_funs&lt;/code&gt; 에 대한 완전한 출력 함수 세트 인 out_funs가 주어 지면 &lt;a href=&quot;format#VALformatter_of_out_functions&quot;&gt; &lt;code&gt;Format.formatter_of_out_functions&lt;/code&gt; &lt;/a&gt; &lt;code&gt;out_funs&lt;/code&gt; 는 출력을 위해 해당 함수를 사용하여 새 포맷터를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a2378a94f2955b1ab0316e6ec9c0c06da7e7f400" translate="yes" xml:space="preserve">
          <source>Alternatively, out-of-heap pointers can be treated as &amp;ldquo;native&amp;rdquo; integers, that is, boxed 32-bit integers on a 32-bit platform and boxed 64-bit integers on a 64-bit platform.</source>
          <target state="translated">또는 힙이 아닌 포인터는 &quot;기본&quot;정수, 즉 32 비트 플랫폼에서는 박스형 32 비트 정수로, 64 비트 플랫폼에서는 박스형 64 비트 정수로 취급 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22956d1c15dfacc465b97fb1216a724af81628b4" translate="yes" xml:space="preserve">
          <source>Alternatively, the selection can be performed within a function:</source>
          <target state="translated">또는 함수 내에서 선택을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af98d4c955e2ccef6756948db1dc2a57c6318273" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;code&gt;Format.fprintf&lt;/code&gt; with a formatter writing to a buffer of your own: flushing the formatter and the buffer at the end of pretty-printing returns the desired string.</source>
          <target state="translated">또는 자신의 버퍼에 쓰는 포맷터와 함께 &lt;code&gt;Format.fprintf&lt;/code&gt; 를 사용할 수 있습니다 . 포맷터를 플러시하고 예쁜 인쇄가 끝날 때 버퍼가 원하는 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4726692b1723191b531b8e035b61a6c25efd7572" translate="yes" xml:space="preserve">
          <source>Although their types are mutually recursive, the classes widget and window are themselves independent.</source>
          <target state="translated">유형은 상호 재귀 적이지만 클래스 위젯과 창은 자체적으로 독립적입니다.</target>
        </trans-unit>
        <trans-unit id="7c908f24c3f9127570182550db0e5d68e44a44f0" translate="yes" xml:space="preserve">
          <source>Always keep the source code for values, methods and instance variables, when available.</source>
          <target state="translated">사용 가능한 경우 값, 메서드 및 인스턴스 변수에 대한 소스 코드를 항상 보관하십시오.</target>
        </trans-unit>
        <trans-unit id="e311d4a9e00e01c3467c09939095dc2e546b21f9" translate="yes" xml:space="preserve">
          <source>Always return a copy of the argument, even if there is no escape sequence in the argument.</source>
          <target state="translated">인수에 이스케이프 시퀀스가없는 경우에도 항상 인수의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2a65be1ce8c39c33cb18ddead7b98c2d7c382ae6" translate="yes" xml:space="preserve">
          <source>Always return host as IP address</source>
          <target state="translated">항상 호스트를 IP 주소로 반환</target>
        </trans-unit>
        <trans-unit id="ad666310edb265f674bc11f8775c66a735702bac" translate="yes" xml:space="preserve">
          <source>Always return service as port number</source>
          <target state="translated">항상 포트 번호로 서비스 반환</target>
        </trans-unit>
        <trans-unit id="f9929d854921839b4c7c71e3b9b8cd03f9593e78" translate="yes" xml:space="preserve">
          <source>Ambiguous constructor or label name.</source>
          <target state="translated">모호한 생성자 또는 레이블 이름입니다.</target>
        </trans-unit>
        <trans-unit id="10ea978f8642bd9c15dc5c2e1359af1c0f49c808" translate="yes" xml:space="preserve">
          <source>Ambiguous or-pattern variables under guard.</source>
          <target state="translated">보호받는 모호한 또는 패턴 변수.</target>
        </trans-unit>
        <trans-unit id="86e2d740f02490dab43c8609e88cb1c2412ec0e6" translate="yes" xml:space="preserve">
          <source>American fuzzy lop (&amp;ldquo;afl-fuzz&amp;rdquo;) is a &lt;em&gt;fuzzer&lt;/em&gt;, a tool for testing software by providing randomly-generated inputs, searching for those inputs which cause the program to crash.</source>
          <target state="translated">American fuzzy lop ( &quot;afl-fuzz&quot;)은 무작위로 생성 된 입력을 제공하여 프로그램을 충돌시키는 입력을 검색하여 소프트웨어를 테스트하는 도구 인 &lt;em&gt;fuzzer&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c87e40750c7790bbaecda1715323b2a074993318" translate="yes" xml:space="preserve">
          <source>An OCaml bytecode library .cma incorporating the .cmo and .ml OCaml files given as arguments, and automatically referencing the C library generated with the C object files.</source>
          <target state="translated">인수로 제공된 .cmo 및 .ml OCaml 파일을 통합하고 C 개체 파일로 생성 된 C 라이브러리를 자동으로 참조하는 OCaml 바이트 코드 라이브러리 .cma.</target>
        </trans-unit>
        <trans-unit id="ec67d9125ab88dc6496a757820db820c3fd6614c" translate="yes" xml:space="preserve">
          <source>An OCaml native-code library .cmxa incorporating the .cmx and .ml OCaml files given as arguments, and automatically referencing the C library generated with the C object files.</source>
          <target state="translated">인수로 제공된 .cmx 및 .ml OCaml 파일을 통합하고 C 개체 파일로 생성 된 C 라이브러리를 자동으로 참조하는 OCaml 네이티브 코드 라이브러리 .cmxa.</target>
        </trans-unit>
        <trans-unit id="2da66ccddbbcfc69305f9b4de6de7b35a0a2c218" translate="yes" xml:space="preserve">
          <source>An abstract module type specification moduletype&lt;a href=&quot;names#modtype-name&quot;&gt;modtype-name&lt;/a&gt; allows the name &lt;a href=&quot;names#modtype-name&quot;&gt;modtype-name&lt;/a&gt; to be implemented by any module type in a matching signature, but hides the implementation of the module type to all users of the signature.</source>
          <target state="translated">추상 모듈 유형 사양 &lt;a href=&quot;names#modtype-name&quot;&gt;moduletype modtype-name&lt;/a&gt; 은 일치하는 서명의 모든 모듈 유형에 의해 &lt;a href=&quot;names#modtype-name&quot;&gt;modtype-name 이름&lt;/a&gt; 이 구현되도록 허용하지만 서명의 모든 사용자에게 모듈 유형의 ​​구현을 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="2dda98608502104a1eef0559ef406e0808aa2e72" translate="yes" xml:space="preserve">
          <source>An alarm is a piece of data that calls a user function at the end of each major GC cycle.</source>
          <target state="translated">알람은 각 주요 GC주기가 끝날 때 사용자 함수를 호출하는 데이터 조각입니다.</target>
        </trans-unit>
        <trans-unit id="4fceb9745728936fccfd146268101c81198650cd" translate="yes" xml:space="preserve">
          <source>An alarm is a piece of data that calls a user function at the end of each major GC cycle. The following functions are provided to create and delete alarms.</source>
          <target state="translated">알람은 각 주요 GC주기가 끝날 때 사용자 함수를 호출하는 데이터 조각입니다. 알람 생성 및 삭제를 위해 다음과 같은 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b6f6cdde9216626eff9ef96ec87f6e970e7b2170" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;scanf.scanning#VALopen_in&quot;&gt;&lt;code&gt;Scanf.Scanning.open_in&lt;/code&gt;&lt;/a&gt; above.</source>
          <target state="translated">위의 &lt;a href=&quot;scanf.scanning#VALopen_in&quot;&gt; &lt;code&gt;Scanf.Scanning.open_in&lt;/code&gt; &lt;/a&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="d94611d8043a8545b1e3bbc68d41c964950c9b2a" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;scanf.scanning#VALopen_in_bin&quot;&gt;&lt;code&gt;Scanf.Scanning.open_in_bin&lt;/code&gt;&lt;/a&gt; above.</source>
          <target state="translated">위의 &lt;a href=&quot;scanf.scanning#VALopen_in_bin&quot;&gt; &lt;code&gt;Scanf.Scanning.open_in_bin&lt;/code&gt; &lt;/a&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="cc6d78a4f564a612f02eb3e53a69348dfb2281bc" translate="yes" xml:space="preserve">
          <source>An alias for &lt;code&gt;concat&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="9d62a81c2fb2390b9c75965ab9fc1bcdf2f00c8e" translate="yes" xml:space="preserve">
          <source>An alias for the type of 32-bit integers.</source>
          <target state="translated">32 비트 정수 유형의 별명입니다.</target>
        </trans-unit>
        <trans-unit id="70ad5e4e644da616967cd0761ef38fc4fa930352" translate="yes" xml:space="preserve">
          <source>An alias for the type of 64-bit integers.</source>
          <target state="translated">64 비트 정수 유형의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="0ffd43f5a6ac5577677a3e5c18ebc5c3c0e13f18" translate="yes" xml:space="preserve">
          <source>An alias for the type of arrays.</source>
          <target state="translated">배열 유형의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="ecf287949a68ee4658b6d4c3e3ffed4775da1907" translate="yes" xml:space="preserve">
          <source>An alias for the type of byte sequences.</source>
          <target state="translated">바이트 시퀀스 유형에 대한 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="7684332c689d34b944c7cc9c560de0bb8ee46fb6" translate="yes" xml:space="preserve">
          <source>An alias for the type of characters.</source>
          <target state="translated">문자 유형의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="059f0dfd54c481e45b90ac7f1f5e71ce3f8423cf" translate="yes" xml:space="preserve">
          <source>An alias for the type of floating-point numbers.</source>
          <target state="translated">부동 소수점 숫자 유형에 대한 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="f82332069f6fb0eaa86c82b6251782c31af87810" translate="yes" xml:space="preserve">
          <source>An alias for the type of lists.</source>
          <target state="translated">목록 유형의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="c247acfde9a1c78ec191af8d28b66b8a3b355b2d" translate="yes" xml:space="preserve">
          <source>An alias for the type of native integers.</source>
          <target state="translated">네이티브 정수 유형의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="eccdacab8e7fee56a7a0223a9c11b8b3c6770334" translate="yes" xml:space="preserve">
          <source>An alias for the type of strings.</source>
          <target state="translated">문자열 유형에 대한 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="618bfd3d18801f1e655e28f356be63bd7b8562e3" translate="yes" xml:space="preserve">
          <source>An alternate definition of circle, using a constraint clause in the class definition, is shown below. The type #point used below in the constraint clause is an abbreviation produced by the definition of class point. This abbreviation unifies with the type of any object belonging to a subclass of class point. It actually expands to &amp;lt; get_x : int; move : int -&amp;gt; unit; .. &amp;gt;. This leads to the following alternate definition of circle, which has slightly stronger constraints on its argument, as we now expect center to have a method get_x.</source>
          <target state="translated">클래스 정의에서 제약 절을 사용하는 원의 대체 정의는 다음과 같습니다. 제약 조건 절에서 아래에 사용되는 유형 #point는 클래스 포인트의 정의에 의해 생성 된 약어입니다. 이 약어는 클래스 포인트의 하위 클래스에 속하는 모든 객체의 유형과 통합됩니다. 실제로는 &amp;lt;get_x : int; 이동 : int-&amp;gt; 단위; ..&amp;gt;. 이것은 우리가 이제 center가 get_x 메소드를 가질 것으로 예상하기 때문에 인수에 약간 더 강한 제약을 갖는 다음과 같은 원의 대체 정의로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="7b47cacb3bfd9fd1aba0d42f40eff979b6e704b9" translate="yes" xml:space="preserve">
          <source>An alternate solution would have been to define the adjustment in a special allocation function:</source>
          <target state="translated">대체 솔루션은 특수 할당 기능에서 조정을 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="129be3c9c278634e0d586c38102180489ee3087c" translate="yes" xml:space="preserve">
          <source>An alternate syntax is provided for the above:</source>
          <target state="translated">위의 경우 대체 구문이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6e37cc574f0bc60ac62ba6fcfb9007dcb2805bd8" translate="yes" xml:space="preserve">
          <source>An alternate syntax is provided to bind variables to functional values: instead of writing</source>
          <target state="translated">변수를 기능적 값에 바인딩하기위한 대체 구문이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="37c7f98b5cff9fff6fb1cf1038c9406754cd6c8f" translate="yes" xml:space="preserve">
          <source>An alternative definition is</source>
          <target state="translated">대체 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6dc3ea4727cbb968c6cf582f484a4b8e18d853df" translate="yes" xml:space="preserve">
          <source>An alternative is to embed the bytecode in the C code. The -output-obj option to ocamlc is provided for this purpose. It causes the ocamlc compiler to output a C object file (.o file, .obj under Windows) containing the bytecode for the OCaml part of the program, as well as a caml_startup function. The C object file produced by ocamlc -output-obj can then be linked with C code using the standard C compiler, or stored in a C library.</source>
          <target state="translated">대안은 C 코드에 바이트 코드를 포함하는 것입니다. 이를 위해 ocamlc에 대한 -output-obj 옵션이 제공됩니다. 이는 ocamlc 컴파일러가 프로그램의 OCaml 부분에 대한 바이트 코드와 caml_startup 함수를 포함하는 C 개체 파일 (Windows에서는 .o 파일, .obj)을 출력하도록합니다. ocamlc -output-obj에 의해 생성 된 C 개체 파일은 표준 C 컴파일러를 사용하여 C 코드와 연결되거나 C 라이브러리에 저장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95ade0a1f9ad45bcd451d104ffbe3e9e40771842" translate="yes" xml:space="preserve">
          <source>An alternative to ocamlc -custom is to build separately a custom runtime system integrating the desired C libraries, then generate &amp;ldquo;pure&amp;rdquo; bytecode executables (not containing their own runtime system) that can run on this custom runtime. This is achieved by the -make-runtime and -use-runtime flags to ocamlc. For example, to build a custom runtime system integrating the C parts of the &amp;ldquo;Unix&amp;rdquo; and &amp;ldquo;Threads&amp;rdquo; libraries, do:</source>
          <target state="translated">ocamlc -custom의 대안은 원하는 C 라이브러리를 통합하는 사용자 지정 런타임 시스템을 별도로 구축 한 다음이 사용자 지정 런타임에서 실행할 수있는 &quot;순수한&quot;바이트 코드 실행 파일 (자체 런타임 시스템을 포함하지 않음)을 생성하는 것입니다. 이것은 ocamlc에 대한 -make-runtime 및 -use-runtime 플래그에 의해 수행됩니다. 예를 들어, &quot;Unix&quot;및 &quot;Threads&quot;라이브러리의 C 부분을 통합하는 사용자 정의 런타임 시스템을 구축하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c55d8d7fa1b47cf10b362effa434052f1405ea7c" translate="yes" xml:space="preserve">
          <source>An alternative to try&amp;hellip;with is to catch the exception while pattern matching:</source>
          <target state="translated">try&amp;hellip; with의 대안은 패턴 일치 중에 예외를 포착하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="440131e5b5bff0388b1ca084c1c73f82f7b75cfe" translate="yes" xml:space="preserve">
          <source>An ancestor can be bound by appending as&lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt; to the inheritance construct. &lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt; is not a true variable and can only be used to select a method, i.e. in an expression &lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt;#&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;. This gives access to the method &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; as it was defined in the parent class even if it is redefined in the current class. The scope of this ancestor binding is limited to the current class. The ancestor method may be called from a subclass but only indirectly.</source>
          <target state="translated">상속 구조에 &lt;a href=&quot;lex#lowercase-ident&quot;&gt;소문자 -ident&lt;/a&gt; 를 추가하여 조상을 바인딩 할 수 있습니다 . &lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt; 는 실제 변수가 아니며 방법을 선택하는 데만 사용할 수 있습니다. 즉, &lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt; # &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; 표현식에서 사용할 수 있습니다 . 이렇게하면 현재 클래스에서 재정의 된 경우에도 부모 클래스에 정의 된 &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; 메서드에 액세스 할 수 있습니다 . 이 상위 바인딩의 범위는 현재 클래스로 제한됩니다. 상위 메서드는 하위 클래스에서 호출 할 수 있지만 간접적으로 만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bc69c843c1bcd58389ebb2099cebb2fafcfd92a" translate="yes" xml:space="preserve">
          <source>An applicative should provide a module implementing the following interface:</source>
          <target state="translated">지원서는 다음 인터페이스를 구현하는 모듈을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="006daedb74f512410dc697574b790c690eac412a" translate="yes" xml:space="preserve">
          <source>An argument to a function that is known to always hold a particular value at runtime. These are introduced by the inliner when specialising recursive functions; and the unbox-closures pass. (See section &lt;a href=&quot;#s%3Aflambda-specialisation&quot;&gt;21.4&lt;/a&gt;.)</source>
          <target state="translated">런타임에 항상 특정 값을 보유하는 것으로 알려진 함수에 대한 인수입니다. 재귀 함수를 전문화 할 때 인라이너에 의해 도입됩니다. 그리고 unbox-closures가 통과됩니다. (섹션 &lt;a href=&quot;#s%3Aflambda-specialisation&quot;&gt;21.4&lt;/a&gt; 참조 .)</target>
        </trans-unit>
        <trans-unit id="68a60b893728b3292dec521dfb12ae61670dfbaf" translate="yes" xml:space="preserve">
          <source>An array or record of double-precision floating-point numbers.</source>
          <target state="translated">배정 밀도 부동 소수점 숫자의 배열 또는 레코드입니다.</target>
        </trans-unit>
        <trans-unit id="de099d6b9bf898b11e949a8188e992306f13f2b6" translate="yes" xml:space="preserve">
          <source>An attribute ([@@boxed] or [@@unboxed]) on the type declaration.</source>
          <target state="translated">유형 선언의 속성 ([@@ boxed] 또는 [@@ unboxed]).</target>
        </trans-unit>
        <trans-unit id="a7d66ba6e7828a1111bf1a161c41ab1d141e5ef9" translate="yes" xml:space="preserve">
          <source>An exception will also be raised if the given library defines toplevel modules whose name matches that of an interface depended on by a module existing in either the main program or a shared library previously loaded with &lt;code&gt;loadfile&lt;/code&gt;. This applies even if such dependency is only a &quot;module alias&quot; dependency (i.e. just on the name rather than the contents of the interface).</source>
          <target state="translated">주어진 라이브러리가 메인 프로그램이나 이전에 &lt;code&gt;loadfile&lt;/code&gt; 로 로드 된 공유 라이브러리에있는 모듈에 의존하는 인터페이스의 이름과 일치하는 최상위 모듈을 정의하는 경우에도 예외가 발생합니다 . 이러한 종속성이 &quot;모듈 별칭&quot;종속성 인 경우에도 적용됩니다 (예 : 인터페이스의 내용이 아닌 이름에만 해당).</target>
        </trans-unit>
        <trans-unit id="5375646ebb366bf5116bc2ae873c1a496825dc9f" translate="yes" xml:space="preserve">
          <source>An exception will be raised if the given library defines toplevel modules whose names clash with modules existing either in the main program or a shared library previously loaded with &lt;code&gt;loadfile&lt;/code&gt;. Modules from shared libraries previously loaded with &lt;code&gt;loadfile_private&lt;/code&gt; are not included in this restriction.</source>
          <target state="translated">주어진 라이브러리가 메인 프로그램이나 이전에 &lt;code&gt;loadfile&lt;/code&gt; 로 로드 된 공유 라이브러리에있는 모듈과 이름이 충돌하는 최상위 모듈을 정의하면 예외가 발생합니다 . 이전에 &lt;code&gt;loadfile_private&lt;/code&gt; 로 로드 된 공유 라이브러리의 모듈은 이 제한에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b0e9adb3f15c17f5fbeab56e0dab47efabe68d43" translate="yes" xml:space="preserve">
          <source>An exception will be raised if the given library defines toplevel modules whose names clash with modules existing in either the main program or a shared library previously loaded with &lt;code&gt;loadfile&lt;/code&gt;. Modules from shared libraries previously loaded with &lt;code&gt;loadfile_private&lt;/code&gt; are not included in this restriction.</source>
          <target state="translated">주어진 라이브러리가 메인 프로그램이나 이전에 &lt;code&gt;loadfile&lt;/code&gt; 로 로드 된 공유 라이브러리에있는 모듈과 이름이 충돌하는 최상위 모듈을 정의하면 예외가 발생합니다 . 이전에 &lt;code&gt;loadfile_private&lt;/code&gt; 로 로드 된 공유 라이브러리의 모듈은 이 제한에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90025c98f5b4890323289b196947781e6340b557" translate="yes" xml:space="preserve">
          <source>An expression consisting in a constant evaluates to this constant.</source>
          <target state="translated">상수로 구성된 표현식은이 상수로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="ace90c1621b08aa00c8a96b15f6d30d331d6e13d" translate="yes" xml:space="preserve">
          <source>An expression consisting in an access path evaluates to the value bound to this path in the current evaluation environment. The path can be either a value name or an access path to a value component of a module.</source>
          <target state="translated">액세스 경로로 구성된 표현식은 현재 평가 환경에서이 경로에 바인드 된 값으로 평가됩니다. 경로는 값 이름이거나 모듈의 값 구성 요소에 대한 액세스 경로 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73cfae8499d582540d3d82d2b347d5585283e5c5" translate="yes" xml:space="preserve">
          <source>An expression e is said to be &lt;em&gt;immediately linked to&lt;/em&gt; the variable name in the following cases:</source>
          <target state="translated">표현식 e는 다음과 같은 경우 변수 이름에 &lt;em&gt;즉시 연결&lt;/em&gt; 된다고합니다 .</target>
        </trans-unit>
        <trans-unit id="c225cbf4f764068b682bb84533296870c62e4bb3" translate="yes" xml:space="preserve">
          <source>An expression e is said to be &lt;em&gt;statically constructive with respect to&lt;/em&gt; the variables name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt; if at least one of the following conditions is true:</source>
          <target state="translated">표현식 e는 다음 조건 중 하나 이상이 참인 경우 변수 이름 &lt;sub&gt;1&lt;/sub&gt; &amp;hellip; 이름 &lt;sub&gt;n에 &lt;/sub&gt;&lt;em&gt;대해 정적으로 구성&lt;/em&gt; 적이라고 합니다.&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="8924323657caeb3c679eee6ea2840479395084ba" translate="yes" xml:space="preserve">
          <source>An expression in the current program which is not enclosed within any function declaration.</source>
          <target state="translated">함수 선언에 포함되지 않은 현재 프로그램의 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="f0596299a4f05385df32ae22667956b3d842ca85" translate="yes" xml:space="preserve">
          <source>An important remark here is that it is not needed to explicit fully the type of depth: it is sufficient to add annotations only for the universally quantified type variables:</source>
          <target state="translated">여기서 중요한 점은 깊이 유형을 완전히 명시 할 필요가 없다는 것입니다. 보편적으로 수량화 된 유형 변수에 대해서만 주석을 추가하는 것으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="52648597fa8dcc7ffc682bd503ba0967a3f2392b" translate="yes" xml:space="preserve">
          <source>An infix form is available for extension nodes when the payload is of the same kind (expression with expression, pattern with pattern ...).</source>
          <target state="translated">페이로드가 동일한 종류 (표현식이있는 표현식, 패턴이있는 패턴 ...) 인 경우 확장 노드에 중위 형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d344863eeb9df892e71ea50feb4a625f576874f" translate="yes" xml:space="preserve">
          <source>An instance of the class point is now a function that expects an initial parameter to create a point object:</source>
          <target state="translated">클래스 포인트의 인스턴스는 이제 포인트 객체를 생성하기 위해 초기 매개 변수가 필요한 함수입니다.</target>
        </trans-unit>
        <trans-unit id="0aabcf4fb88a6b9ab3702ebe7eaa0626b8c43f86" translate="yes" xml:space="preserve">
          <source>An instance variable can only be used in the methods and initializers that follow its definition.</source>
          <target state="translated">인스턴스 변수는 정의를 따르는 메서드와 이니셜 라이저에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cfec687c7cd2e25fe15cf75db3a2694a19473d5" translate="yes" xml:space="preserve">
          <source>An instance variable specification will hide any previous specification of an instance variable of the same name.</source>
          <target state="translated">인스턴스 변수 사양은 동일한 이름의 인스턴스 변수에 대한 이전 사양을 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="a41b8be11a84d152d295d2336d67b91e8d2c3060" translate="yes" xml:space="preserve">
          <source>An integer literal is a sequence of one or more digits, optionally preceded by a minus sign. By default, integer literals are in decimal (radix 10). The following prefixes select a different radix:</source>
          <target state="translated">정수 리터럴은 선택적으로 마이너스 기호가 앞에 오는 하나 이상의 숫자 시퀀스입니다. 기본적으로 정수 리터럴은 10 진수 (기수 10)입니다. 다음 접두사는 다른 기수를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="d9d626a896ab2f190fc7998987ce76e7091c1c26" translate="yes" xml:space="preserve">
          <source>An interesting feature of labeled arguments is that they can be made optional. For optional parameters, the question mark ? replaces the tilde ~ of non-optional ones, and the label is also prefixed by ? in the function type. Default values may be given for such optional parameters.</source>
          <target state="translated">레이블이 지정된 인수의 흥미로운 기능은 선택 사항으로 만들 수 있다는 것입니다. 선택적 매개 변수의 경우 물음표? 선택 사항이 아닌 것의 물결표 ~를 대체하며 레이블 앞에?가 붙습니다. 함수 유형에서. 이러한 선택적 매개 변수에 대해 기본값이 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f65036af4512f44ececdc3f62c446b6b61294da" translate="yes" xml:space="preserve">
          <source>An object can be duplicated using the library function Oo.copy (see module &lt;a href=&quot;libref/oo&quot;&gt;Oo&lt;/a&gt;). Inside a method, the expression {&amp;lt; [&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;] { ;&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;] }] &amp;gt;} returns a copy of self with the given instance variables replaced by the values of the associated expressions. A single instance variable name id stands for id=id. Other instance variables have the same value in the returned object as in self.</source>
          <target state="translated">객체는 라이브러리 함수 Oo.copy를 사용하여 복제 할 수 있습니다 (모듈 &lt;a href=&quot;libref/oo&quot;&gt;Oo&lt;/a&gt; 참조 ). 메소드 내에서 표현식 {&amp;lt;[ &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; [= &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; ] {; &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; [= &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; ]}]&amp;gt;}은 주어진 인스턴스 변수가 관련 표현식의 값으로 대체 된 self의 복사본을 반환합니다. 단일 인스턴스 변수 이름 id는 id = id를 나타냅니다. 다른 인스턴스 변수는 반환 된 객체에서 self와 동일한 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="f8fca591c68a23ba5ea157e601f3721c015e06e3" translate="yes" xml:space="preserve">
          <source>An object of type t can be seen as an object of type t' only if t is a subtype of t'. For instance, a point cannot be seen as a colored point.</source>
          <target state="translated">t 유형의 객체는 t가 t '의 하위 유형 인 경우에만 t'유형의 객체로 볼 수 있습니다. 예를 들어, 포인트는 컬러 포인트로 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b5a053fc34f79e3900acd980c4393bdf188d2ba6" translate="yes" xml:space="preserve">
          <source>An object type &amp;lt; [&lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt; { ;&lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt; }] &amp;gt; is a record of method types.</source>
          <target state="translated">객체 유형 &amp;lt;[ &lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt; {; &lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt; }]&amp;gt;은 메서드 유형의 레코드입니다.</target>
        </trans-unit>
        <trans-unit id="7e06bba980b7f45d05db95ce6a7fd85388df6efe" translate="yes" xml:space="preserve">
          <source>An optional ;; is allowed after each specification in a signature. It serves as a syntactic separator with no semantic meaning.</source>
          <target state="translated">선택적 ;; 서명의 각 사양 뒤에 허용됩니다. 의미 론적 의미가없는 구문 구분 기호 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="66032c41f549bccac9d0b6f0351898e608c2cda4" translate="yes" xml:space="preserve">
          <source>An optional type constraint &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; can be added before -&amp;gt; to enforce the type of the result to be compatible with the constraint &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;:</source>
          <target state="translated">선택적 유형 제약 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; 을-&amp;gt; 앞에 추가하여 제약 &lt;a href=&quot;types#typexpr&quot;&gt;유형 xpr&lt;/a&gt; 과 호환되도록 결과 유형을 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc2fcf6b100ec44acc00a333e7fc5f05e4b0696a" translate="yes" xml:space="preserve">
          <source>Analogous to a let-expression but working at the level of symbols defined in the object file. The address of a symbol is fixed, but it may be bound to both constant and non-constant expressions.</source>
          <target state="translated">let-expression과 유사하지만 개체 파일에 정의 된 기호 수준에서 작동합니다. 심볼의 주소는 고정되어 있지만 상수 및 비상 수 식 모두에 바인딩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9da5adc9da340a9bff818430088217c4a6bb634" translate="yes" xml:space="preserve">
          <source>And here is another example as a floating attribute on top of an &amp;ldquo;.mli&amp;rdquo; file (i.e. before any other non-attribute item) or on top of an &amp;ldquo;.ml&amp;rdquo; file without a corresponding interface file, so that any reference to that unit will trigger the alert:</source>
          <target state="translated">그리고 여기에 &quot;.mli&quot;파일 위에 (즉, 다른 비 속성 항목 앞) 또는 해당 인터페이스 파일이없는 &quot;.ml&quot;파일 위에 부동 속성이있는 또 다른 예가 있습니다. 단위는 경고를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="ce86f92e74f90bcfd232c04d5cf35384550f0a84" translate="yes" xml:space="preserve">
          <source>Another addition is that the redundancy check is now aware of GADTs: a case will be detected as redundant if it could be replaced by a refutation case using the same pattern.</source>
          <target state="translated">또 다른 추가 사항은 중복 검사가 이제 GADT를 인식한다는 것입니다. 동일한 패턴을 사용하는 반박 사례로 대체 될 수있는 경우 사례가 중복으로 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="11568aaad65fc90346f51e27ec62e346c87f9060" translate="yes" xml:space="preserve">
          <source>Another advantage of dynamic linking is that the final users of the library do not need to have a C compiler, C linker, and C runtime libraries installed on their machines. This is no big deal under Unix and Cygwin, but many Windows users are reluctant to install Microsoft Visual C just to be able to do ocamlc -custom.</source>
          <target state="translated">동적 연결의 또 다른 장점은 라이브러리의 최종 사용자가 컴퓨터에 C 컴파일러, C 링커 및 C 런타임 라이브러리를 설치할 필요가 없다는 것입니다. 이것은 Unix와 Cygwin에서 큰 문제가 아니지만 많은 Windows 사용자는 ocamlc -custom을 수행하기 위해 Microsoft Visual C를 설치하는 것을 꺼립니다.</target>
        </trans-unit>
        <trans-unit id="379ccd865ef9bf08d87e4fe3728fcd421c371281" translate="yes" xml:space="preserve">
          <source>Another application where the absence of strengthening comes handy, is to provide an alternative implementation for an existing module.</source>
          <target state="translated">강화의 부재가 편리한 또 다른 애플리케이션은 기존 모듈에 대한 대체 구현을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="35b204a1efbf2c2ea400dd0dffecaa4d167d1127" translate="yes" xml:space="preserve">
          <source>Another constructor of the class string can be defined to return a new string of a given length:</source>
          <target state="translated">클래스 문자열의 다른 생성자를 정의하여 주어진 길이의 새 문자열을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3008a5155b842268cb1cca835a9c65bc01d33f21" translate="yes" xml:space="preserve">
          <source>Another derived form is</source>
          <target state="translated">또 다른 파생 형태는</target>
        </trans-unit>
        <trans-unit id="d7fc62ee868df41b11c6605c1d3d1e9e51b532e5" translate="yes" xml:space="preserve">
          <source>Another difficulty is the implementation of the method concat. In order to concatenate a string with another string of the same class, one must be able to access the instance variable externally. Thus, a method repr returning s must be defined. Here is the correct definition of strings:</source>
          <target state="translated">또 다른 어려움은 concat 메서드의 구현입니다. 문자열을 동일한 클래스의 다른 문자열과 연결하려면 인스턴스 변수에 외부 적으로 액세스 할 수 있어야합니다. 따라서 s를 반환하는 메서드 repr을 정의해야합니다. 다음은 문자열의 올바른 정의입니다.</target>
        </trans-unit>
        <trans-unit id="960c7f9039396fdf9b6183a614ddd5ba1364d740" translate="yes" xml:space="preserve">
          <source>Another example of friend functions may be found in section &lt;a href=&quot;advexamples#ss%3Aset-as-class&quot;&gt;6.2.3&lt;/a&gt;. These examples occur when a group of objects (here objects of the same class) and functions should see each others internal representation, while their representation should be hidden from the outside. The solution is always to define all friends in the same module, give access to the representation and use a signature constraint to make the representation abstract outside the module.</source>
          <target state="translated">친구 기능의 또 다른 예는 섹션 &lt;a href=&quot;advexamples#ss%3Aset-as-class&quot;&gt;6.2.3&lt;/a&gt; 에서 찾을 수 있습니다 . 이러한 예는 객체 그룹 (여기서는 동일한 클래스의 객체)과 함수가 서로 내부 표현을보아야하는 반면 표현은 외부에서 숨겨야 할 때 발생합니다. 해결책은 항상 동일한 모듈의 모든 친구를 정의하고 표현에 대한 액세스 권한을 부여하고 서명 제약 조건을 사용하여 표현을 모듈 외부에서 추상화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="17374fb3064ba6870c538e1b446bdebf215dc251" translate="yes" xml:space="preserve">
          <source>Another frequent application of GADTs is equality witnesses.</source>
          <target state="translated">GADT의 또 다른 빈번한 적용은 평등 증인입니다.</target>
        </trans-unit>
        <trans-unit id="00b8b9dedc14e6b1cd6fe0e01857af1aa6404068" translate="yes" xml:space="preserve">
          <source>Another interesting example of variant type is the built-in 'a option type which represents either a value of type 'a or an absence of value:</source>
          <target state="translated">변형 유형의 또 다른 흥미로운 예는 'a 유형의 값 또는 값의 부재를 나타내는 기본 제공 옵션 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e98e486b7a409b5e3ad08f1b7aa8b7aed3ea6303" translate="yes" xml:space="preserve">
          <source>Another method of the class Odoc_html.info will look for the function associated to a custom tag and apply it to the text given to the tag. If no function is associated to a custom tag, then the method prints a warning message on stderr.</source>
          <target state="translated">Odoc_html.info 클래스의 또 다른 메서드는 사용자 정의 태그와 관련된 함수를 찾아 태그에 지정된 텍스트에 적용합니다. 사용자 정의 태그에 연결된 함수가 없으면 메서드는 stderr에 경고 메시지를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="ae0ec1f90755688bc1d5656265057eb9e769167b" translate="yes" xml:space="preserve">
          <source>Another possibility is to immediately open the result of a functor application</source>
          <target state="translated">또 다른 가능성은 펑터 응용 프로그램의 결과를 즉시 여는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e716b700e6f647eba563f1ccf76da8c18bce9786" translate="yes" xml:space="preserve">
          <source>Another possibility is to open the module, which brings all identifiers defined inside the module in the scope of the current structure.</source>
          <target state="translated">또 다른 가능성은 모듈을 여는 것입니다. 현재 구조의 범위에서 모듈 내에 정의 된 모든 식별자를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f4cb70ba16214437ff5bfea383ebc35af2799280" translate="yes" xml:space="preserve">
          <source>Another possibility is to use the registration mechanism provided by OCaml. This registration mechanism enables OCaml code to register OCaml functions under some global name, and C code to retrieve the corresponding closure by this global name.</source>
          <target state="translated">또 다른 가능성은 OCaml에서 제공하는 등록 메커니즘을 사용하는 것입니다. 이 등록 메커니즘을 통해 OCaml 코드는 일부 전역 이름으로 OCaml 함수를 등록하고 C 코드는이 전역 이름으로 해당 클로저를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d34661685e35893e694d0332d27bae708ed4c0a2" translate="yes" xml:space="preserve">
          <source>Another use of polymorphic methods is to allow some form of implicit subtyping in method arguments. We have already seen in section &lt;a href=&quot;#s%3Ainheritance&quot;&gt;3.8&lt;/a&gt; how some functions may be polymorphic in the class of their argument. This can be extended to methods.</source>
          <target state="translated">다형성 메서드의 또 다른 용도는 메서드 인수에 암시 적 하위 유형 지정을 허용하는 것입니다. 우리는 이미 섹션 &lt;a href=&quot;#s%3Ainheritance&quot;&gt;3.8&lt;/a&gt; 에서 일부 함수가 인수 클래스에서 다형성이되는 방법을 살펴 보았습니다 . 이것은 메소드로 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42742cf10f5bbb6d6cd3179117e1520377a19a5b" translate="yes" xml:space="preserve">
          <source>Another way to describe the effect of the used and max parameters is in terms of full GC cycles. If you allocate many custom blocks with used / max = 1 / N, the GC will then do one full cycle (examining every object in the heap and calling finalization functions on those that are unreachable) every N allocations. For instance, if used = 1 and max = 1000, the GC will do one full cycle at least every 1000 allocations of custom blocks.</source>
          <target state="translated">used 및 max 매개 변수의 효과를 설명하는 또 다른 방법은 전체 GC주기에 관한 것입니다. used / max = 1 / N으로 많은 사용자 정의 블록을 할당하면 GC는 N 할당마다 하나의 전체주기를 수행합니다 (힙의 모든 객체를 검사하고 도달 할 수없는 객체에 대해 종료 함수를 호출). 예를 들어, used = 1이고 max = 1000 인 경우 GC는 사용자 지정 블록의 최소 1000 개 할당마다 하나의 전체주기를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="dad308b9fe900c0c0e039593bedec472af636fdb" translate="yes" xml:space="preserve">
          <source>Anything reachable from the closure of finalisation functions is considered reachable, so the following code will not work as expected:</source>
          <target state="translated">종료 함수를 닫아서 도달 할 수있는 모든 것은 도달 가능한 것으로 간주되므로 다음 코드는 예상대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="604a218f5f4aab645a4a1009e1f31b43f5ed165f" translate="yes" xml:space="preserve">
          <source>Application operator: &lt;code&gt;g&amp;nbsp;@@&amp;nbsp;f&amp;nbsp;@@&amp;nbsp;x&lt;/code&gt; is exactly equivalent to &lt;code&gt;g&amp;nbsp;(f&amp;nbsp;(x))&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램 연산자 : &lt;code&gt;g&amp;nbsp;@@&amp;nbsp;f&amp;nbsp;@@&amp;nbsp;x&lt;/code&gt; 는 &lt;code&gt;g&amp;nbsp;(f&amp;nbsp;(x))&lt;/code&gt; 와 정확히 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="df2efc8b148be52f9c8ed183190fada16314613f" translate="yes" xml:space="preserve">
          <source>Application operator: &lt;code&gt;g&amp;nbsp;@@&amp;nbsp;f&amp;nbsp;@@&amp;nbsp;x&lt;/code&gt; is exactly equivalent to &lt;code&gt;g&amp;nbsp;(f&amp;nbsp;(x))&lt;/code&gt;. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">응용 프로그램 연산자 : &lt;code&gt;g&amp;nbsp;@@&amp;nbsp;f&amp;nbsp;@@&amp;nbsp;x&lt;/code&gt; 는 &lt;code&gt;g&amp;nbsp;(f&amp;nbsp;(x))&lt;/code&gt; 와 정확히 동일합니다 . 오른쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="1fa4b8e03aa156418c5cda350eaad3455e137511" translate="yes" xml:space="preserve">
          <source>Application-defined signal 1</source>
          <target state="translated">애플리케이션 정의 신호 1</target>
        </trans-unit>
        <trans-unit id="26c1a4dff4fd312fdfb5fb1c0029c4b22bf24f5e" translate="yes" xml:space="preserve">
          <source>Application-defined signal 2</source>
          <target state="translated">애플리케이션 정의 신호 2</target>
        </trans-unit>
        <trans-unit id="61e847f0c9cb6ddd254ec9bee8f6186c8f3855b9" translate="yes" xml:space="preserve">
          <source>Applications of functors at toplevel are biased in favour of inlining. (This bias may be adjusted: see the documentation for -inline-lifting-benefit below.)</source>
          <target state="translated">최상위에서 펑터의 응용 프로그램은 인라인에 유리하게 편향되어 있습니다. (이 편향은 조정될 수 있습니다. 아래의 -inline-lifting-benefit에 대한 문서를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="bd544829c5c539d781194c7e44400d0c1a9dda50" translate="yes" xml:space="preserve">
          <source>Applications of functors at toplevel will be given an additional benefit (which may be controlled by the -inline-lifting-benefit flag) to bias inlining in such situations towards keeping the inlined version.</source>
          <target state="translated">최상위 수준에서 펑터를 적용하면 인라인 버전을 유지하기 위해 이러한 상황에서 인라인을 편향시킬 수있는 추가 이점 (-inline-lifting-benefit 플래그에 의해 제어 될 수 있음)이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a3e0674aabf5c4d680c8d5e09367402b58266d96" translate="yes" xml:space="preserve">
          <source>Applications of functors not at toplevel, for example in a local module inside some other expression, are treated by the inliner identically to normal function calls.</source>
          <target state="translated">예를 들어 다른 표현식 내부의 로컬 모듈에서와 같이 최상위 수준이 아닌 펑터의 응용 프로그램은 일반 함수 호출과 동일하게 인라이너에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e11dd7ffe23599b55aaefbac7a8a5cc476bbdddf" translate="yes" xml:space="preserve">
          <source>Apply the function to every element; if &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;None&lt;/code&gt; then &lt;code&gt;x&lt;/code&gt; is dropped; if &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;Some&amp;nbsp;y&lt;/code&gt; then &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="translated">모든 요소에 기능을 적용하십시오. 만약 &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;None&lt;/code&gt; 후 &lt;code&gt;x&lt;/code&gt; 삭제되지 않는다; 만약 &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;Some&amp;nbsp;y&lt;/code&gt; 다음 &lt;code&gt;y&lt;/code&gt; 리턴된다.</target>
        </trans-unit>
        <trans-unit id="4df0a0fae2dc98bab23f83a8fda3ec3235322c88" translate="yes" xml:space="preserve">
          <source>Apply the function to every element; if &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;None&lt;/code&gt; then &lt;code&gt;x&lt;/code&gt; is dropped; if &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;Some&amp;nbsp;y&lt;/code&gt; then &lt;code&gt;y&lt;/code&gt; is returned. This transformation is lazy, it only applies when the result is traversed.</source>
          <target state="translated">모든 요소에 기능을 적용하십시오. 만약 &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;None&lt;/code&gt; 후 &lt;code&gt;x&lt;/code&gt; 삭제되지 않는다; 만약 &lt;code&gt;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;Some&amp;nbsp;y&lt;/code&gt; 다음 &lt;code&gt;y&lt;/code&gt; 리턴된다. 이 변환은 게으 르며 결과가 순회 될 때만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9203406f752d0f2cd60c227bf6f44b27a75accdc" translate="yes" xml:space="preserve">
          <source>Arbitrary effects:</source>
          <target state="translated">임의의 효과 :</target>
        </trans-unit>
        <trans-unit id="5271441f98aeb358bf2d4f9a6f13e679fe628438" translate="yes" xml:space="preserve">
          <source>Arc cosine.</source>
          <target state="translated">아크 코사인.</target>
        </trans-unit>
        <trans-unit id="be6663925560899dfcf830b9356632b7066599ce" translate="yes" xml:space="preserve">
          <source>Arc cosine. The argument must fall within the range &lt;code&gt;[-1.0,&amp;nbsp;1.0]&lt;/code&gt;. Result is in radians and is between &lt;code&gt;0.0&lt;/code&gt; and &lt;code&gt;pi&lt;/code&gt;.</source>
          <target state="translated">아크 코사인. 인수는 &lt;code&gt;[-1.0,&amp;nbsp;1.0]&lt;/code&gt; 범위 내에 있어야합니다 . 결과는 라디안이며 &lt;code&gt;0.0&lt;/code&gt; 과 &lt;code&gt;pi&lt;/code&gt; 사이 입니다.</target>
        </trans-unit>
        <trans-unit id="b8e8ba2c58206d6af15ec8c8ce21d9d4340480e6" translate="yes" xml:space="preserve">
          <source>Arc sine.</source>
          <target state="translated">아크 사인.</target>
        </trans-unit>
        <trans-unit id="2e664c763343c0ce420ab4f8b7918cc8fec98013" translate="yes" xml:space="preserve">
          <source>Arc sine. The argument must fall within the range &lt;code&gt;[-1.0,&amp;nbsp;1.0]&lt;/code&gt;. Result is in radians and is between &lt;code&gt;-pi/2&lt;/code&gt; and &lt;code&gt;pi/2&lt;/code&gt;.</source>
          <target state="translated">아크 사인. 인수는 &lt;code&gt;[-1.0,&amp;nbsp;1.0]&lt;/code&gt; 범위 내에 있어야합니다 . 결과는 라디안이며 &lt;code&gt;-pi/2&lt;/code&gt; 와 &lt;code&gt;pi/2&lt;/code&gt; 사이 입니다.</target>
        </trans-unit>
        <trans-unit id="266c8124a574fe03155e38f56dd49a8f10def8a9" translate="yes" xml:space="preserve">
          <source>Arc tangent.</source>
          <target state="translated">아크 탄젠트.</target>
        </trans-unit>
        <trans-unit id="e2997407cb014180b9ea6377f06c6afb487aba39" translate="yes" xml:space="preserve">
          <source>Arc tangent. Result is in radians and is between &lt;code&gt;-pi/2&lt;/code&gt; and &lt;code&gt;pi/2&lt;/code&gt;.</source>
          <target state="translated">아크 탄젠트. 결과는 라디안이며 &lt;code&gt;-pi/2&lt;/code&gt; 와 &lt;code&gt;pi/2&lt;/code&gt; 사이 입니다.</target>
        </trans-unit>
        <trans-unit id="27cb7fb1af71b4cc6c9c97447cc986c742906de1" translate="yes" xml:space="preserve">
          <source>Arg</source>
          <target state="translated">Arg</target>
        </trans-unit>
        <trans-unit id="b8bc95515466bfd1d5820bfea495f62a49211b2b" translate="yes" xml:space="preserve">
          <source>Argument list too long</source>
          <target state="translated">인수 목록이 너무 깁니다.</target>
        </trans-unit>
        <trans-unit id="a33eb8c83de075f26368d8d83e467d02a06fefb8" translate="yes" xml:space="preserve">
          <source>Argument.</source>
          <target state="translated">Argument.</target>
        </trans-unit>
        <trans-unit id="94e2cab63df34c564db734a97c71978e506fbdc1" translate="yes" xml:space="preserve">
          <source>Argument. The argument of a complex number is the angle in the complex plane between the positive real axis and a line passing through zero and the number. This angle ranges from &lt;code&gt;-pi&lt;/code&gt; to &lt;code&gt;pi&lt;/code&gt;. This function has a discontinuity along the negative real axis.</source>
          <target state="translated">논의. 복소수의 인수는 양의 실수 축과 0과 숫자를 통과하는 선 사이의 복소 평면의 각도입니다. 이 각도의 범위는 &lt;code&gt;-pi&lt;/code&gt; 에서 &lt;code&gt;pi&lt;/code&gt; 입니다. 이 함수는 음의 실수 축을 따라 불연속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbc3ed9a0a50398139b12d56cc9eb1c8aad70aa4" translate="yes" xml:space="preserve">
          <source>Arguments &lt;code&gt;r1&lt;/code&gt; to &lt;code&gt;rN&lt;/code&gt; are user-defined input functions that read the argument corresponding to the &lt;code&gt;%r&lt;/code&gt; conversions specified in the format string.</source>
          <target state="translated">인수 &lt;code&gt;r1&lt;/code&gt; ~ &lt;code&gt;rN&lt;/code&gt; 은 형식 문자열에 지정된 &lt;code&gt;%r&lt;/code&gt; 변환에 해당하는 인수를 읽는 사용자 정의 입력 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="bddb1ca12c5cd34d740d1681c0e6da5090d8ebc1" translate="yes" xml:space="preserve">
          <source>Arguments and parameters are matched according to their respective labels. Argument order is irrelevant, except among arguments with the same label, or no label.</source>
          <target state="translated">인수와 매개 변수는 각각의 레이블에 따라 일치합니다. 레이블이 같거나 레이블이없는 인수 사이를 제외하고 인수 순서는 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e4aa3dace9de47afa590535c6430637432fcb775" translate="yes" xml:space="preserve">
          <source>Arguments ending in .c are passed to the C compiler, which generates a .o object file (.obj under Windows). This object file is linked with the program if the -custom flag is set (see the description of -custom below).</source>
          <target state="translated">.c로 끝나는 인수는 .o 개체 파일 (Windows에서는 .obj)을 생성하는 C 컴파일러에 전달됩니다. 이 오브젝트 파일은 -custom 플래그가 설정된 경우 프로그램과 링크됩니다 (아래 -custom 설명 참조).</target>
        </trans-unit>
        <trans-unit id="7e64866919ffd0c1908ab66afb8bab953b71239c" translate="yes" xml:space="preserve">
          <source>Arguments ending in .c are passed to the C compiler, which generates a .o/.obj object file. This object file is linked with the program.</source>
          <target state="translated">.c로 끝나는 인수는 .o / .obj 개체 파일을 생성하는 C 컴파일러에 전달됩니다. 이 개체 파일은 프로그램과 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c11692d0c25badb1d4399f0c388c3baf4a014789" translate="yes" xml:space="preserve">
          <source>Arguments ending in .cma are taken to be libraries of object bytecode. A library of object bytecode packs in a single file a set of object bytecode files (.cmo files). Libraries are built with ocamlc -a (see the description of the -a option below). The object files contained in the library are linked as regular .cmo files (see above), in the order specified when the .cma file was built. The only difference is that if an object file contained in a library is not referenced anywhere in the program, then it is not linked in.</source>
          <target state="translated">.cma로 끝나는 인수는 개체 바이트 코드의 라이브러리로 간주됩니다. 개체 바이트 코드 라이브러리는 개체 바이트 코드 파일 집합 (.cmo 파일)을 단일 파일로 압축합니다. 라이브러리는 ocamlc -a로 빌드됩니다 (아래 -a 옵션에 대한 설명 참조). 라이브러리에 포함 된 오브젝트 파일은 .cma 파일이 빌드 될 때 지정된 순서대로 일반 .cmo 파일 (위 참조)로 링크됩니다. 유일한 차이점은 라이브러리에 포함 된 오브젝트 파일이 프로그램의 어느 곳에서도 참조되지 않으면 링크되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd46a96b2deb69174fd6074578fbde3a1033ca71" translate="yes" xml:space="preserve">
          <source>Arguments ending in .cmo are taken to be compiled object bytecode. These files are linked together, along with the object files obtained by compiling .ml arguments (if any), and the OCaml standard library, to produce a standalone executable program. The order in which .cmo and .ml arguments are presented on the command line is relevant: compilation units are initialized in that order at run-time, and it is a link-time error to use a component of a unit before having initialized it. Hence, a given x.cmo file must come before all .cmo files that refer to the unit x.</source>
          <target state="translated">.cmo로 끝나는 인수는 컴파일 된 객체 바이트 코드로 간주됩니다. 이러한 파일은 .ml 인수 (있는 경우)를 컴파일하여 얻은 개체 파일 및 OCaml 표준 라이브러리와 함께 연결되어 독립 실행 형 실행 프로그램을 생성합니다. .cmo 및 .ml 인수가 명령 줄에 표시되는 순서는 관련이 있습니다. 컴파일 단위는 런타임에 해당 순서로 초기화되며 초기화하기 전에 단위의 구성 요소를 사용하는 것은 링크 타임 오류입니다. . 따라서 주어진 x.cmo 파일은 단위 x를 참조하는 모든 .cmo 파일 앞에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="27c51513642c4d98fce646f2cf850e04390e54e5" translate="yes" xml:space="preserve">
          <source>Arguments ending in .cmx are taken to be compiled object code. These files are linked together, along with the object files obtained by compiling .ml arguments (if any), and the OCaml standard library, to produce a native-code executable program. The order in which .cmx and .ml arguments are presented on the command line is relevant: compilation units are initialized in that order at run-time, and it is a link-time error to use a component of a unit before having initialized it. Hence, a given x.cmx file must come before all .cmx files that refer to the unit x.</source>
          <target state="translated">.cmx로 끝나는 인수는 컴파일 된 개체 코드로 간주됩니다. 이러한 파일은 .ml 인수 (있는 경우)를 컴파일하여 얻은 개체 파일 및 OCaml 표준 라이브러리와 함께 연결되어 네이티브 코드 실행 프로그램을 생성합니다. .cmx 및 .ml 인수가 명령 줄에 표시되는 순서는 관련이 있습니다. 컴파일 단위는 런타임에 해당 순서로 초기화되며 초기화하기 전에 단위의 구성 요소를 사용하는 것은 링크 타임 오류입니다. . 따라서 주어진 x.cmx 파일은 단위 x를 참조하는 모든 .cmx 파일 앞에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="753f2485fe970a0539a08cbdcdd898a19f368dff" translate="yes" xml:space="preserve">
          <source>Arguments ending in .cmxa are taken to be libraries of object code. Such a library packs in two files (lib.cmxa and lib.a/.lib) a set of object files (.cmx and .o/.obj files). Libraries are build with ocamlopt -a (see the description of the -a option below). The object files contained in the library are linked as regular .cmx files (see above), in the order specified when the library was built. The only difference is that if an object file contained in a library is not referenced anywhere in the program, then it is not linked in.</source>
          <target state="translated">.cmxa로 끝나는 인수는 개체 코드의 라이브러리로 간주됩니다. 이러한 라이브러리는 두 개의 파일 (lib.cmxa 및 lib.a / .lib)에 개체 파일 집합 (.cmx 및 .o / .obj 파일)을 포함합니다. 라이브러리는 ocamlopt -a로 빌드됩니다 (아래 -a 옵션에 대한 설명 참조). 라이브러리에 포함 된 오브젝트 파일은 라이브러리가 빌드 될 때 지정된 순서대로 일반 .cmx 파일 (위 참조)로 링크됩니다. 유일한 차이점은 라이브러리에 포함 된 오브젝트 파일이 프로그램의 어느 곳에서도 참조되지 않으면 링크되지 않는다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b15608ca7cbe9709e52f1f2a1ead35427cf44c51" translate="yes" xml:space="preserve">
          <source>Arguments ending in .ml are taken to be source files for compilation unit implementations. Implementations provide definitions for the names exported by the unit, and also contain expressions to be evaluated for their side-effects. From the file x.ml, the ocamlc compiler produces compiled object bytecode in the file x.cmo.</source>
          <target state="translated">.ml로 끝나는 인수는 컴파일 단위 구현을위한 소스 파일로 간주됩니다. 구현은 단위에서 내 보낸 이름에 대한 정의를 제공하며 부작용에 대해 평가할 표현식도 포함합니다. x.ml 파일에서 ocamlc 컴파일러는 x.cmo 파일에 컴파일 된 개체 바이트 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="927a384236546c16bb894121e3e38006a9e3ec5f" translate="yes" xml:space="preserve">
          <source>Arguments ending in .ml are taken to be source files for compilation unit implementations. Implementations provide definitions for the names exported by the unit, and also contain expressions to be evaluated for their side-effects. From the file x.ml, the ocamlopt compiler produces two files: x.o, containing native object code, and x.cmx, containing extra information for linking and optimization of the clients of the unit. The compiled implementation should always be referred to under the name x.cmx (when given a .o or .obj file, ocamlopt assumes that it contains code compiled from C, not from OCaml).</source>
          <target state="translated">.ml로 끝나는 인수는 컴파일 단위 구현을위한 소스 파일로 간주됩니다. 구현은 단위에서 내 보낸 이름에 대한 정의를 제공하며 부작용에 대해 평가할 표현식도 포함합니다. x.ml 파일에서 ocamlopt 컴파일러는 네이티브 개체 코드를 포함하는 xo와 유닛의 클라이언트 연결 및 최적화를위한 추가 정보를 포함하는 x.cmx의 두 파일을 생성합니다. 컴파일 된 구현은 항상 x.cmx라는 이름으로 참조되어야합니다 (.o 또는 .obj 파일이 주어지면 ocamlopt는 OCaml이 아닌 C에서 컴파일 된 코드를 포함한다고 가정합니다).</target>
        </trans-unit>
        <trans-unit id="2b5a1961767c9a016aad419b660ee2c45f6b243d" translate="yes" xml:space="preserve">
          <source>Arguments ending in .mli are taken to be source files for compilation unit interfaces. Interfaces specify the names exported by compilation units: they declare value names with their types, define public data types, declare abstract data types, and so on. From the file x.mli, the ocamlc compiler produces a compiled interface in the file x.cmi.</source>
          <target state="translated">.mli로 끝나는 인수는 컴파일 단위 인터페이스의 소스 파일로 간주됩니다. 인터페이스는 컴파일 단위로 내 보낸 이름을 지정합니다. 유형과 함께 값 이름을 선언하고, 공용 데이터 유형을 정의하고, 추상 데이터 유형을 선언하는 등의 작업을 수행합니다. x.mli 파일에서 ocamlc 컴파일러는 x.cmi 파일에 컴파일 된 인터페이스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="25f655c44ea5ff1321183c50ad8e4c5f74128d49" translate="yes" xml:space="preserve">
          <source>Arguments ending in .mli are taken to be source files for compilation unit interfaces. Interfaces specify the names exported by compilation units: they declare value names with their types, define public data types, declare abstract data types, and so on. From the file x.mli, the ocamlopt compiler produces a compiled interface in the file x.cmi. The interface produced is identical to that produced by the bytecode compiler ocamlc.</source>
          <target state="translated">.mli로 끝나는 인수는 컴파일 단위 인터페이스의 소스 파일로 간주됩니다. 인터페이스는 컴파일 단위로 내 보낸 이름을 지정합니다. 유형과 함께 값 이름을 선언하고, 공용 데이터 유형을 정의하고, 추상 데이터 유형을 선언하는 등의 작업을 수행합니다. x.mli 파일에서 ocamlopt 컴파일러는 x.cmi 파일에 컴파일 된 인터페이스를 생성합니다. 생성 된 인터페이스는 바이트 코드 컴파일러 ocamlc에 의해 생성 된 인터페이스와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7173e5b0967ce88f54ecd20d265aa72b4f28c658" translate="yes" xml:space="preserve">
          <source>Arguments ending in .o or .a (.obj or .lib under Windows) are assumed to be C object files and libraries. They are passed to the C linker when linking in -custom mode (see the description of -custom below).</source>
          <target state="translated">.o 또는 .a (Windows에서는 .obj 또는 .lib)로 끝나는 인수는 C 개체 파일 및 라이브러리로 간주됩니다. -custom 모드에서 링크 할 때 C 링커로 전달됩니다 (아래의 -custom 설명 참조).</target>
        </trans-unit>
        <trans-unit id="1c067102e7e1c8c13a1e6e57ba950d7491209f87" translate="yes" xml:space="preserve">
          <source>Arguments ending in .o, .a or .so (.obj, .lib and .dll under Windows) are assumed to be C object files and libraries. They are linked with the program.</source>
          <target state="translated">.o, .a 또는 .so (Windows에서는 .obj, .lib 및 .dll)로 끝나는 인수는 C 개체 파일 및 라이브러리로 간주됩니다. 그들은 프로그램과 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc1ab2c6381764fbe6cadd894bd7ef8c2b84a0f9" translate="yes" xml:space="preserve">
          <source>Arguments ending in .so (.dll under Windows) are assumed to be C shared libraries (DLLs). During linking, they are searched for external C functions referenced from the OCaml code, and their names are written in the generated bytecode executable. The run-time system ocamlrun then loads them dynamically at program start-up time.</source>
          <target state="translated">.so (Windows에서는 .dll)로 끝나는 인수는 C 공유 라이브러리 (DLL)로 간주됩니다. 링크하는 동안 OCaml 코드에서 참조 된 외부 C 함수를 검색하고 해당 이름은 생성 된 바이트 코드 실행 파일에 기록됩니다. 그런 다음 런타임 시스템 ocamlrun은 프로그램 시작시 동적으로로드합니다.</target>
        </trans-unit>
        <trans-unit id="8ad3d398f9ad29c4fd230211d5ebfa56a0ba7f1c" translate="yes" xml:space="preserve">
          <source>Arithmetic exception</source>
          <target state="translated">산술 예외</target>
        </trans-unit>
        <trans-unit id="185bf7f331062c4c3e9e4a6aba44aec8b810f20a" translate="yes" xml:space="preserve">
          <source>Arrange for the C shared library dlllibname.so (dlllibname.dll under Windows) to be loaded dynamically by the run-time system ocamlrun at program start-up time.</source>
          <target state="translated">프로그램 시작시 런타임 시스템 ocamlrun에서 동적으로로드 할 C 공유 라이브러리 dlllibname.so (Windows의 경우 dlllibname.dll)를 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="107004472b7ba4e5e31f3082ee1fb5a1239eec61" translate="yes" xml:space="preserve">
          <source>Array</source>
          <target state="translated">Array</target>
        </trans-unit>
        <trans-unit id="431205b0376562fedb6d7afe64934615b543a4b4" translate="yes" xml:space="preserve">
          <source>Array accesses are bounds-checked, but the bounds are determined by the initial call to &lt;code&gt;map_file&lt;/code&gt;. Therefore, you should make sure no other process modifies the mapped file while you're accessing it, or a SIGBUS signal may be raised. This happens, for instance, if the file is shrunk.</source>
          <target state="translated">배열 액세스는 경계가 확인되지만 경계는 &lt;code&gt;map_file&lt;/code&gt; 에 대한 초기 호출에 의해 결정됩니다 . 따라서 액세스하는 동안 다른 프로세스가 매핑 된 파일을 수정하지 않도록해야합니다. 그렇지 않으면 SIGBUS 신호가 발생할 수 있습니다. 예를 들어 파일이 축소 된 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6a80d94da93b9720aae715b13c57b162feacae54" translate="yes" xml:space="preserve">
          <source>Array layouts</source>
          <target state="translated">배열 레이아웃</target>
        </trans-unit>
        <trans-unit id="3bb3c7a55000274933287d81122c47cc23dd9bcf" translate="yes" xml:space="preserve">
          <source>Array operations</source>
          <target state="translated">어레이 작업</target>
        </trans-unit>
        <trans-unit id="cc3f55326329e50888cc261427317ad3c95e07c6" translate="yes" xml:space="preserve">
          <source>Array operations.</source>
          <target state="translated">어레이 작업.</target>
        </trans-unit>
        <trans-unit id="ac52c7170210e2cde0563a8a7cc378d8d3bab67e" translate="yes" xml:space="preserve">
          <source>Array scanning</source>
          <target state="translated">어레이 스캐닝</target>
        </trans-unit>
        <trans-unit id="1302b4894cb1cf89e91ae78809a8c87e194848ee" translate="yes" xml:space="preserve">
          <source>ArrayLabels</source>
          <target state="translated">ArrayLabels</target>
        </trans-unit>
        <trans-unit id="993b203e29af9582fe002cf1c0a611c787dcb4d5" translate="yes" xml:space="preserve">
          <source>Arrays are finite, variable-sized sequences of values of the same type. The current implementation supports arrays containing up to 2&lt;sup&gt;22&lt;/sup&gt; &amp;minus; 1 elements (4194303 elements) unless the elements are floating-point numbers (2097151 elements in this case); on 64-bit platforms, the limit is 2&lt;sup&gt;54&lt;/sup&gt; &amp;minus; 1 for all arrays.</source>
          <target state="translated">배열은 동일한 유형의 값의 유한 가변 크기 시퀀스입니다. 2 개까지 함유 현재 구현 지원 어레이 &lt;sup&gt;22&lt;/sup&gt; - 1 요소 (요소 4,194,303) 요소가되지 않는 한 부동 소수점 수 (이 경우 소자 2,097,151); 64 비트 플랫폼에 제한은 2 &lt;sup&gt;54&lt;/sup&gt; (1) 모두 배열 -.</target>
        </trans-unit>
        <trans-unit id="3dbf05ada7bef68e8d497df01ba4407cb02175f1" translate="yes" xml:space="preserve">
          <source>Arrays of floating-point numbers (type float array) have a special, unboxed, more efficient representation. These arrays are represented by pointers to blocks with tag Double_array_tag. They should be accessed with the Double_field and Store_double_field macros.</source>
          <target state="translated">부동 소수점 숫자 배열 (float 배열 유형)은 특수하고 박싱되지 않은보다 효율적인 표현을 갖습니다. 이러한 배열은 Double_array_tag 태그가있는 블록에 대한 포인터로 표시됩니다. Double_field 및 Store_double_field 매크로를 사용하여 액세스해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ac7294b1d303d14c1ea81ae76623f8e989d7450" translate="yes" xml:space="preserve">
          <source>Arrays of integers and pointers are represented like tuples, that is, as pointers to blocks tagged 0. They are accessed with the Field macro for reading and the caml_modify function for writing.</source>
          <target state="translated">정수 및 포인터 배열은 튜플처럼 표시됩니다. 즉, 태그가 0 인 블록에 대한 포인터로 표시됩니다. 읽기 용 필드 매크로와 쓰기 용 caml_modify 함수를 사용하여 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="f16f611272747884cf686e3d446de513132a0e8d" translate="yes" xml:space="preserve">
          <source>Arrays of values declared using CAMLlocalN must not be written to using Store_field. Use the normal C array syntax instead.</source>
          <target state="translated">CAMLlocalN을 사용하여 선언 된 값의 배열은 Store_field를 사용하여 작성하면 안됩니다. 대신 일반 C 배열 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="80832a08a4bc7a800951f197511d4c16855f54d1" translate="yes" xml:space="preserve">
          <source>Arrays of weak pointers and hash sets of weak pointers.</source>
          <target state="translated">약한 포인터의 배열과 약한 포인터의 해시 세트.</target>
        </trans-unit>
        <trans-unit id="a9312b18524288526ab3bb3e65773d033af7e75d" translate="yes" xml:space="preserve">
          <source>As a consequence, if the coercion is applied to self, as in the following example, the type of self is unified with the closed type c (a closed object type is an object type without ellipsis). This would constrain the type of self be closed and is thus rejected. Indeed, the type of self cannot be closed: this would prevent any further extension of the class. Therefore, a type error is generated when the unification of this type with another type would result in a closed object type.</source>
          <target state="translated">결과적으로 다음 예제와 같이 self에 강제가 적용되면 self 유형은 닫힌 유형 c로 통합됩니다 (닫힌 객체 유형은 줄임표가없는 객체 유형입니다). 이것은 자기가 닫히는 유형을 제한하므로 거부됩니다. 실제로 self 유형은 닫을 수 없습니다. 이것은 클래스의 더 이상의 확장을 막을 것입니다. 따라서이 유형을 다른 유형과 통합하면 닫힌 객체 유형이 생성 될 때 유형 오류가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="236760b37470c1f5e34cd659fbad69bc911cec3c" translate="yes" xml:space="preserve">
          <source>As a convenience, caml/mlvalues.h defines the macros Val_unit, Val_false and Val_true to refer to (), false and true.</source>
          <target state="translated">편의상 caml / mlvalues.h는 매크로 Val_unit, Val_false 및 Val_true를 정의하여 (), false 및 true를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="d6708b84bc9659abee628ea692bfc6191fdb3835" translate="yes" xml:space="preserve">
          <source>As a shared library may have several clients simultaneously, it is made for convenience that caml_startup (and caml_startup_pooled) may be called multiple times, given that each such call is paired with a corresponding call to caml_shutdown (in a nested fashion). The runtime will be unloaded once there are no outstanding calls to caml_startup.</source>
          <target state="translated">공유 라이브러리는 동시에 여러 클라이언트를 가질 수 있으므로 각 호출이 (중첩 된 방식으로) caml_shutdown에 대한 해당 호출과 쌍을 이루는 경우 caml_startup (및 caml_startup_pooled)을 여러 번 호출 할 수 있습니다. caml_startup에 대한 미해결 호출이 없으면 런타임이 언로드됩니다.</target>
        </trans-unit>
        <trans-unit id="84d9ea1b251e88997b679926917f2a4432728a0f" translate="yes" xml:space="preserve">
          <source>As a side-effect of this generativity, one is allowed to unpack first-class modules in the body of generative functors.</source>
          <target state="translated">이 생성의 부작용으로 생성 펑터의 몸체에서 일류 모듈을 풀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c21716682d59482dd8cc66a86332eb9340c37df" translate="yes" xml:space="preserve">
          <source>As a side-effect, these 3 keywords avoid the warnings 7 (method override) and 13 (instance variable override). Note that warning 7 is disabled by default.</source>
          <target state="translated">부작용으로 이러한 3 개의 키워드는 경고 7 (메소드 재정의) 및 13 (인스턴스 변수 재정의)을 피합니다. 경고 7은 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a81290b5b966f9efcf2c6b0cb0f65e7caee04d82" translate="yes" xml:space="preserve">
          <source>As a special case, assert false is reduced to raise(Assert_failure ...), which gives it a polymorphic type. This means that it can be used in place of any expression (for example as a branch of any pattern-matching). It also means that the assert false &amp;ldquo;assertions&amp;rdquo; cannot be turned off by the -noassert option.</source>
          <target state="translated">특별한 경우로 assert false는 raise (Assert_failure ...)로 축소되어 다형성 유형을 제공합니다. 이는 표현식 대신 사용할 수 있음을 의미합니다 (예 : 패턴 일치의 분기로). 이는 또한 -noassert 옵션으로 거짓 &quot;어설 션&quot;어설 션을 해제 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="acf0e568489d8aa1699963c95f2533d75f92737b" translate="yes" xml:space="preserve">
          <source>As a special case, if id is all, it stands for all alerts.</source>
          <target state="translated">특별한 경우로 id가 all이면 모든 경고를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c52ed11f3bffe509a76486b6deece909f9053706" translate="yes" xml:space="preserve">
          <source>As a special case, if the function has a known arity, all the arguments are unlabeled, and their number matches the number of non-optional parameters, then labels are ignored and non-optional parameters are matched in their definition order. Optional arguments are defaulted.</source>
          <target state="translated">특별한 경우로 함수에 알려진 arity가 있고 모든 인수에 레이블이 지정되지 않고 해당 인수의 수가 선택적이 아닌 매개 변수의 수와 일치하면 레이블이 무시되고 선택적이 아닌 매개 변수가 정의 순서대로 일치됩니다. 선택적 인수가 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="a938adb6f0aea5e4af4fb92f58e17c47a9825ed3" translate="yes" xml:space="preserve">
          <source>As an example, consider the following lexer that is parametrized over an arbitrary monad:</source>
          <target state="translated">예를 들어, 임의의 모나드에 대해 매개 변수화 된 다음 렉서를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="f0d510e5dbaebaaf3fcb5f83b6a111b4d9ae064d" translate="yes" xml:space="preserve">
          <source>As an example, this code will return the integer 1:</source>
          <target state="translated">예를 들어이 코드는 정수 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4f90f529d98bdc2a64de636cdc4ec8125e7bb221" translate="yes" xml:space="preserve">
          <source>As an example, we fuzz-test the following program, readline.ml:</source>
          <target state="translated">예를 들어 readline.ml 프로그램을 퍼즈 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="c2e17b3e7ef6d5d7fd46be15fe9cc1c0f4c1ec6b" translate="yes" xml:space="preserve">
          <source>As an exception to the above parameter matching rules, if an application is total (omitting all optional arguments), labels may be omitted. In practice, many applications are total, so that labels can often be omitted.</source>
          <target state="translated">위의 매개 변수 일치 규칙에 대한 예외로 애플리케이션이 전체 (모든 선택적 인수 생략) 인 경우 레이블을 생략 할 수 있습니다. 실제로 많은 응용 프로그램이 전체이므로 레이블을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e90091a05125db96622a5dd1550905e80e47ce30" translate="yes" xml:space="preserve">
          <source>As an optimization, records whose fields all have static type float are represented as arrays of floating-point numbers, with tag Double_array_tag. (See the section below on arrays.)</source>
          <target state="translated">최적화를 위해 필드가 모두 부동 소수점 유형을 갖는 레코드는 Double_array_tag 태그를 사용하여 부동 소수점 숫자의 배열로 표시됩니다. (어레이에 대한 아래 섹션을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="f9b07ba0ea2f0d698023e6db84093874e3feaa2a" translate="yes" xml:space="preserve">
          <source>As an optimization, unboxable concrete data types are represented specially; a concrete data type is unboxable if it has exactly one constructor and this constructor has exactly one argument. Unboxable concrete data types are represented in the same ways as unboxable record types: see the description in section &lt;a href=&quot;#ss%3Ac-tuples-and-records&quot;&gt;20.3.2&lt;/a&gt;.</source>
          <target state="translated">최적화로서 unboxable 구체적인 데이터 유형은 특별히 표현됩니다. 정확히 하나의 생성자가 있고이 생성자에 정확히 하나의 인수가있는 경우 구체적인 데이터 유형은 박싱 할 수 없습니다. Unboxable 구체적인 데이터 유형은 unboxable 레코드 유형과 동일한 방식으로 표시됩니다 . 섹션 &lt;a href=&quot;#ss%3Ac-tuples-and-records&quot;&gt;20.3.2&lt;/a&gt; 의 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e389f44aa5a062928a493d520912df25e67b105" translate="yes" xml:space="preserve">
          <source>As another optimization, unboxable record types are represented specially; unboxable record types are the immutable record types that have only one field. An unboxable type will be represented in one of two ways: boxed or unboxed. Boxed record types are represented as described above (by a block with tag 0 or Double_array_tag). An unboxed record type is represented directly by the value of its field (i.e. there is no block to represent the record itself).</source>
          <target state="translated">또 다른 최적화로 박싱 할 수없는 레코드 유형이 특별히 표시됩니다. unboxable 레코드 유형은 필드가 하나만있는 변경 불가능한 레코드 유형입니다. unboxable 유형은 boxed 또는 unboxed의 두 가지 방법 중 하나로 표시됩니다. 박스형 레코드 유형은 위에서 설명한대로 표시됩니다 (태그 0 또는 Double_array_tag가있는 블록). 박싱되지 않은 레코드 유형은 해당 필드의 값으로 직접 표시됩니다 (즉, 레코드 자체를 나타내는 블록이 없음).</target>
        </trans-unit>
        <trans-unit id="ab0914c80dac70311bbc335c79d02e0ca7dabf33" translate="yes" xml:space="preserve">
          <source>As can be expected, the type of window is recursive.</source>
          <target state="translated">예상대로 창 유형은 재귀 적입니다.</target>
        </trans-unit>
        <trans-unit id="36451f7154d544b297a165c4f3d0b643fc88da62" translate="yes" xml:space="preserve">
          <source>As checkpointing is quite expensive, it must not be done too often. On the other hand, backward execution is faster when checkpoints are taken more often. In particular, backward single-stepping is more responsive when many checkpoints have been taken just before the current time. To fine-tune the checkpointing strategy, the debugger does not take checkpoints at the same frequency for long displacements (e.g. run) and small ones (e.g. step). The two variables bigstep and smallstep contain the number of events between two checkpoints in each case.</source>
          <target state="translated">체크 포인트는 비용이 많이 들기 때문에 너무 자주 수행해서는 안됩니다. 반면에 체크 포인트를 더 자주 사용하면 역방향 실행이 더 빠릅니다. 특히, 역방향 단일 스테핑은 현재 시간 직전에 많은 체크 포인트를 수행 한 경우 더 반응이 좋습니다. 체크 포인트 전략을 미세 조정하기 위해 디버거는 긴 변위 (예 : 실행)와 작은 변위 (예 : 단계)에 대해 동일한 빈도로 체크 포인트를 사용하지 않습니다. 두 변수 bigstep 및 smallstep에는 각 경우에 두 체크 포인트 사이의 이벤트 수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0c2e49921371c9b9ceab2b2609b751d4d8a6ae6b" translate="yes" xml:space="preserve">
          <source>As described above, there are three parameters that restrict the search for inlining opportunities during speculation:</source>
          <target state="translated">위에서 설명한대로 추측 중에 인라인 기회 검색을 제한하는 세 가지 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="04ce6fc5d3fc7d51652851a17e88a921906c733e" translate="yes" xml:space="preserve">
          <source>As in the PrioQueue example, it would be good style to hide the actual implementation of the type set, so that users of the structure will not rely on sets being lists, and we can switch later to another, more efficient representation of sets without breaking their code. This can be achieved by restricting Set by a suitable functor signature:</source>
          <target state="translated">PrioQueue 예제에서와 같이 구조의 사용자가 목록이되는 집합에 의존하지 않도록 형식 집합의 실제 구현을 숨기는 것이 좋습니다. 그들의 코드. 이는 적절한 펑터 시그니처로 Set을 제한하여 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7636d82194e3efe6c5e09ed9156713f2d8407a4" translate="yes" xml:space="preserve">
          <source>As in the case of simple structures, an alternate syntax is provided for defining functors and restricting their result:</source>
          <target state="translated">단순한 구조의 경우와 같이 펑터를 정의하고 그 결과를 제한하기위한 대체 구문이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="95375c7ef1a71d2bf1c6e19c4cf628da86c59bbb" translate="yes" xml:space="preserve">
          <source>As in the case of static linking, it is possible (and recommended) to record the names of C libraries in an OCaml .cma library archive. Consider again an OCaml library mylib.cma, built from the OCaml object files a.cmo and b.cmo, which reference C code in dllmylib.so. If the library is built as follows:</source>
          <target state="translated">정적 링크의 경우와 마찬가지로 OCaml .cma 라이브러리 아카이브에 C 라이브러리의 이름을 기록하는 것이 가능하고 권장됩니다. dllmylib.so의 C 코드를 참조하는 OCaml 오브젝트 파일 a.cmo 및 b.cmo에서 빌드 된 OCaml 라이브러리 mylib.cma를 다시 고려하십시오. 라이브러리가 다음과 같이 빌드 된 경우 :</target>
        </trans-unit>
        <trans-unit id="5d584f24e6917e93c9448a575b3606f6a5980280" translate="yes" xml:space="preserve">
          <source>As mentioned above, a plain character in the format string is just matched with the next character of the input; however, two characters are special exceptions to this rule: the space character (&lt;code&gt;'&amp;nbsp;'&lt;/code&gt; or ASCII code 32) and the line feed character (&lt;code&gt;'\n'&lt;/code&gt; or ASCII code 10). A space does not match a single space character, but any amount of 'whitespace' in the input. More precisely, a space inside the format string matches &lt;em&gt;any number&lt;/em&gt; of tab, space, line feed and carriage return characters. Similarly, a line feed character in the format string matches either a single line feed or a carriage return followed by a line feed.</source>
          <target state="translated">위에서 언급했듯이 형식 문자열의 일반 문자는 입력의 다음 문자와 일치합니다. 그러나 두 문자는이 규칙에 대한 특별한 예외입니다. 공백 문자 ( &lt;code&gt;'&amp;nbsp;'&lt;/code&gt; 또는 ASCII 코드 32)와 줄 바꿈 문자 ( &lt;code&gt;'\n'&lt;/code&gt; 또는 ASCII 코드 10)입니다. 공백은 단일 공백 ​​문자와 일치하지 않지만 입력에서 '공백'의 양에 관계없이 일치합니다. 보다 정확하게는 형식 문자열 내부의 공백 은 탭, 공백, 줄 바꿈 및 캐리지 리턴 문자와 일치 &lt;em&gt;합니다&lt;/em&gt; . 마찬가지로 형식 문자열의 줄 바꿈 문자는 단일 줄 바꿈 또는 줄 바꿈 뒤에 오는 캐리지 리턴과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="910ea56dc6edf679b6fb9258db1d763027e94506" translate="yes" xml:space="preserve">
          <source>As mentioned in chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;, the bytecode executable files produced by the ocamlc command are self-executable, and manage to launch the ocamlrun command on themselves automatically. That is, assuming a.out is a bytecode executable file,</source>
          <target state="translated">&lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; 장에서 언급했듯이 ocamlc 명령에 의해 생성 된 바이트 코드 실행 파일은 자체 실행 가능하며 자동으로 ocamlrun 명령을 실행하도록 관리합니다. 즉, a.out이 바이트 코드 실행 파일이라고 가정하면,</target>
        </trans-unit>
        <trans-unit id="4a210b9b840985d0d92278ed85640a6045dd1b85" translate="yes" xml:space="preserve">
          <source>As mentioned in section &lt;a href=&quot;expr#sss%3Aexpr-localdef&quot;&gt;7.7.2&lt;/a&gt;, the letrec binding construct, in addition to the definition of recursive functions, also supports a certain class of recursive definitions of non-functional values, such as</source>
          <target state="translated">섹션 &lt;a href=&quot;expr#sss%3Aexpr-localdef&quot;&gt;7.7.2&lt;/a&gt; 에서 언급했듯이 재귀 함수의 정의 외에도 letrec 바인딩 구조는 다음과 같은 비 기능적 값의 특정 클래스의 재귀 정의를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="34bca80111a01f2e351f1111c7ac3f009fc572ff" translate="yes" xml:space="preserve">
          <source>As previously with polymorphic recursion, the problem stems from the fact that type variables are introduced only at the start of the let definitions. When we compute both f x and f y, the type of x and y are unified together. To avoid this unification, we need to indicate to the type checker that f is polymorphic in its first argument. In some sense, we would want average to have type</source>
          <target state="translated">이전에 다형성 재귀와 마찬가지로 문제는 형식 변수가 let 정의의 시작 부분에만 도입된다는 사실에서 비롯됩니다. fx와 fy를 모두 계산할 때 x와 y의 유형은 함께 통합됩니다. 이러한 통일을 피하기 위해 우리는 f가 첫 번째 인자에서 다형성이라는 것을 타입 검사기에 알려야합니다. 어떤 의미에서는 평균이 유형을 갖기를 원할 것입니다.</target>
        </trans-unit>
        <trans-unit id="0bc8c1d2e201eb9b8575e1d067fe0b0a35105b61" translate="yes" xml:space="preserve">
          <source>As seen in section &lt;a href=&quot;objectexamples#s%3Abinary-methods&quot;&gt;3.16&lt;/a&gt;, the solution is to use functional update instead. We need to create an instance variable containing the representation s of the string.</source>
          <target state="translated">섹션 &lt;a href=&quot;objectexamples#s%3Abinary-methods&quot;&gt;3.16&lt;/a&gt; 에서 볼 수 있듯이 해결책은 기능 업데이트를 대신 사용하는 것입니다. 문자열의 표현을 포함하는 인스턴스 변수를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="146268ca5c35e116ecdc1071a5c5b8b50d37a961" translate="yes" xml:space="preserve">
          <source>As shown above, prefix and infix symbols as well as some keywords can be used as value names, provided they are written between parentheses. The capitalization rules are summarized in the table below.</source>
          <target state="translated">위와 같이 접두사 및 중위 기호와 일부 키워드는 괄호로 묶인 경우 값 이름으로 사용할 수 있습니다. 대문자 표기 규칙은 아래 표에 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="34d83d9e79f521c6e091052dc06397df06c37842" translate="yes" xml:space="preserve">
          <source>As shown by the last item, the current behavior is imperfect and may be improved in future versions.</source>
          <target state="translated">마지막 항목에서 볼 수 있듯이 현재 동작은 불완전하며 향후 버전에서 개선 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f52e265c35555d5dd6376d7c8518f28bfcf8591" translate="yes" xml:space="preserve">
          <source>As shown by the types of the values above, Bigarrays of kind &lt;code&gt;float32_elt&lt;/code&gt; and &lt;code&gt;float64_elt&lt;/code&gt; are accessed using the OCaml type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">위의 값 유형에서 볼 수 있듯이 &lt;code&gt;float32_elt&lt;/code&gt; 및 &lt;code&gt;float64_elt&lt;/code&gt; 종류의 Bigarray 는 OCaml 유형 &lt;code&gt;float&lt;/code&gt; 를 사용하여 액세스됩니다 .</target>
        </trans-unit>
        <trans-unit id="8476c185d0c89ce2f99fd45d0702217ddcf47f6c" translate="yes" xml:space="preserve">
          <source>As shown by the types of the values above, Bigarrays of kind &lt;code&gt;float32_elt&lt;/code&gt; and &lt;code&gt;float64_elt&lt;/code&gt; are accessed using the OCaml type &lt;code&gt;float&lt;/code&gt;. Bigarrays of complex kinds &lt;code&gt;complex32_elt&lt;/code&gt;, &lt;code&gt;complex64_elt&lt;/code&gt; are accessed with the OCaml type &lt;a href=&quot;complex#TYPEt&quot;&gt;&lt;code&gt;Complex.t&lt;/code&gt;&lt;/a&gt;. Bigarrays of integer kinds are accessed using the smallest OCaml integer type large enough to represent the array elements: &lt;code&gt;int&lt;/code&gt; for 8- and 16-bit integer Bigarrays, as well as OCaml-integer Bigarrays; &lt;code&gt;int32&lt;/code&gt; for 32-bit integer Bigarrays; &lt;code&gt;int64&lt;/code&gt; for 64-bit integer Bigarrays; and &lt;code&gt;nativeint&lt;/code&gt; for platform-native integer Bigarrays. Finally, Bigarrays of kind &lt;code&gt;int8_unsigned_elt&lt;/code&gt; can also be accessed as arrays of characters instead of arrays of small integers, by using the kind value &lt;code&gt;char&lt;/code&gt; instead of &lt;code&gt;int8_unsigned&lt;/code&gt;.</source>
          <target state="translated">위의 값 유형에서 볼 수 있듯이 &lt;code&gt;float32_elt&lt;/code&gt; 및 &lt;code&gt;float64_elt&lt;/code&gt; 종류의 Bigarray 는 OCaml 유형 &lt;code&gt;float&lt;/code&gt; 를 사용하여 액세스됩니다 . 복잡한 종류의 &lt;code&gt;complex32_elt&lt;/code&gt; , &lt;code&gt;complex64_elt&lt;/code&gt; 는 OCaml 유형 &lt;a href=&quot;complex#TYPEt&quot;&gt; &lt;code&gt;Complex.t&lt;/code&gt; &lt;/a&gt; 로 액세스됩니다 . 정수 종류의 Bigarray는 배열 요소를 표현하기에 충분히 큰 가장 작은 OCaml 정수 유형을 사용하여 액세스합니다. 8 비트 및 16 비트 정수 Bigarray의 경우 &lt;code&gt;int&lt;/code&gt; 및 OCaml 정수 Bigarrays; 32 비트 정수 Bigarray의 경우 &lt;code&gt;int32&lt;/code&gt; ; 64 비트 정수 Bigarray의 경우 &lt;code&gt;int64&lt;/code&gt; ; 및 &lt;code&gt;nativeint&lt;/code&gt; 로 플랫폼 네이티브 정수 Bigarrays합니다. 마지막으로, 종류의 Bigarrays &lt;code&gt;int8_unsigned_elt&lt;/code&gt; 는 대신 작은 정수의 배열의 문자의 배열로, 종류 값을 사용하여 액세스 할 수있는 &lt;code&gt;char&lt;/code&gt; 대신 &lt;code&gt;int8_unsigned&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13a7da1695c3c5352050cfec39a769dbb674cfcd" translate="yes" xml:space="preserve">
          <source>As shown in the examples above, the internal representation (also called &lt;em&gt;abstract syntax&lt;/em&gt;) of expressions quickly becomes hard to read and write as the expressions get larger. We need a printer and a parser to go back and forth between the abstract syntax and the &lt;em&gt;concrete syntax&lt;/em&gt;, which in the case of expressions is the familiar algebraic notation (e.g. 2*x+1).</source>
          <target state="translated">위의 예에서 볼 수 있듯이 표현식 의 내부 표현 ( &lt;em&gt;추상 구문&lt;/em&gt; 이라고도 함 )은 표현식이 커짐에 따라 빠르게 읽고 쓰기가 어려워집니다. 추상 구문과 &lt;em&gt;구체적인 구문&lt;/em&gt; 사이를 오 가려면 프린터와 파서가 필요합니다. 표현식의 경우 익숙한 대수 표기법 (예 : 2 * x + 1)입니다.</target>
        </trans-unit>
        <trans-unit id="59652ec2d12ee8e1992d0d09b42d5fef7eaa31f9" translate="yes" xml:space="preserve">
          <source>As shown in the inferred type, the methods escaped and sub now return objects of the same type as the one of the class.</source>
          <target state="translated">추론 된 유형에서 볼 수 있듯이 이스케이프 된 메소드와 sub는 이제 클래스 중 하나와 동일한 유형의 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1677cf6090ca5f51486302f94edd1cbfae80aa0e" translate="yes" xml:space="preserve">
          <source>As such, n behaves as the &amp;ldquo;maximum depth of unrolling&amp;rdquo;.</source>
          <target state="translated">따라서 n은 &quot;최대 풀림 깊이&quot;로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f163934b9085a82e3861515a2a64c2855047ac0e" translate="yes" xml:space="preserve">
          <source>As suggested above, the expression &lt;code&gt;bscanf&amp;nbsp;ic&amp;nbsp;&quot;%d&quot;&amp;nbsp;f&lt;/code&gt; reads a decimal integer &lt;code&gt;n&lt;/code&gt; from the source of characters &lt;code&gt;ic&lt;/code&gt; and returns &lt;code&gt;f&amp;nbsp;n&lt;/code&gt;.</source>
          <target state="translated">위에서 제안한대로 &lt;code&gt;bscanf&amp;nbsp;ic&amp;nbsp;&quot;%d&quot;&amp;nbsp;f&lt;/code&gt; 표현식 은 문자 &lt;code&gt;ic&lt;/code&gt; 의 소스에서 10 진수 &lt;code&gt;n&lt;/code&gt; 을 읽고 &lt;code&gt;f&amp;nbsp;n&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b63ec4df080300cfa9da6aea74b52a0e1970e4f4" translate="yes" xml:space="preserve">
          <source>As usual in format strings, &lt;code&gt;%&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt; characters must be escaped using &lt;code&gt;%%&lt;/code&gt; and &lt;code&gt;%@&lt;/code&gt;; this rule still holds within range specifications and scanning indications. For instance, format &lt;code&gt;&quot;%s@%%&quot;&lt;/code&gt; reads a string up to the next &lt;code&gt;%&lt;/code&gt; character, and format &lt;code&gt;&quot;%s@%@&quot;&lt;/code&gt; reads a string up to the next &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">형식 문자열에서 평소와 같이 &lt;code&gt;%&lt;/code&gt; 및 &lt;code&gt;@&lt;/code&gt; 문자는 &lt;code&gt;%%&lt;/code&gt; 및 &lt;code&gt;%@&lt;/code&gt; 사용하여 이스케이프해야합니다 . 이 규칙은 여전히 ​​범위 사양 및 스캔 표시 내에서 유지됩니다. 예를 들어, &lt;code&gt;&quot;%s@%%&quot;&lt;/code&gt; 형식 은 다음 &lt;code&gt;%&lt;/code&gt; 문자 까지 문자열을 읽고 &lt;code&gt;&quot;%s@%@&quot;&lt;/code&gt; 형식 은 다음 &lt;code&gt;@&lt;/code&gt; 까지 문자열을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="9513a3413b439631dd1d7bb4477ddee65ef66765" translate="yes" xml:space="preserve">
          <source>As with all other OCaml data structures, lists do not need to be explicitly allocated and deallocated from memory: all memory management is entirely automatic in OCaml. Similarly, there is no explicit handling of pointers: the OCaml compiler silently introduces pointers where necessary.</source>
          <target state="translated">다른 모든 OCaml 데이터 구조와 마찬가지로 목록을 명시 적으로 할당하고 메모리에서 할당 해제 할 필요가 없습니다. 모든 메모리 관리는 OCaml에서 완전히 자동으로 이루어집니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 마찬가지로 포인터를 명시 적으로 처리하지 않습니다. OCaml 컴파일러는 필요한 곳에 포인터를 자동으로 도입합니다.</target>
        </trans-unit>
        <trans-unit id="faa7b814a8e7a19b930b22e13ead91aad6715db7" translate="yes" xml:space="preserve">
          <source>As with most OCaml data structures, inspecting and destructuring lists is performed by pattern-matching. List patterns have exactly the same form as list expressions, with identifiers representing unspecified parts of the list. As an example, here is insertion sort on a list:</source>
          <target state="translated">대부분의 OCaml 데이터 구조와 마찬가지로 목록 검사 및 구조 해제는 패턴 일치를 통해 수행됩니다. 목록 패턴은 목록의 지정되지 않은 부분을 나타내는 식별자가있는 목록 표현식과 정확히 동일한 형식을 갖습니다. 예를 들어, 다음은 목록에 대한 삽입 정렬입니다.</target>
        </trans-unit>
        <trans-unit id="a1eb0836959399cedd4347276c1b98d0ca3d0c82" translate="yes" xml:space="preserve">
          <source>As with records, the form {&amp;lt; x &amp;gt;} is an elided version of {&amp;lt; x = x &amp;gt;} which avoids the repetition of the instance variable name. Note that the type abbreviation functional_point is recursive, which can be seen in the class type of functional_point: the type of self is 'a and 'a appears inside the type of the method move.</source>
          <target state="translated">레코드와 마찬가지로 {&amp;lt;x&amp;gt;} 형식은 인스턴스 변수 이름의 반복을 방지하는 {&amp;lt;x = x&amp;gt;}의 생략 된 버전입니다. 유형 약어 functional_point는 재귀 적이며, 이는 functional_point의 클래스 유형에서 볼 수 있습니다. self의 유형은 'a이고'a는 메소드 이동 유형 내부에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="17f13c41da6e3c55107056baa15f8a3dbb68f91b" translate="yes" xml:space="preserve">
          <source>As x is a subtype of xy, we can convert a value of type x to a value of type xy:</source>
          <target state="translated">x는 xy의 하위 유형이므로 x 유형의 값을 xy 유형의 값으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27d585775436817b8bbfb4935a528c62bb777faa" translate="yes" xml:space="preserve">
          <source>As you can see in the class type shown by the compiler, while polymorphic method types must be fully explicit in class definitions (appearing immediately after the method name), quantified type variables can be left implicit in class descriptions. Why require types to be explicit? The problem is that (int -&amp;gt; int -&amp;gt; int) -&amp;gt; int -&amp;gt; int would also be a valid type for fold, and it happens to be incompatible with the polymorphic type we gave (automatic instantiation only works for toplevel types variables, not for inner quantifiers, where it becomes an undecidable problem.) So the compiler cannot choose between those two types, and must be helped.</source>
          <target state="translated">컴파일러에 표시된 클래스 유형에서 볼 수 있듯이 다형성 메서드 유형은 클래스 정의에서 완전히 명시 적이어야하지만 (메서드 이름 바로 뒤에 표시됨) 수량화 된 유형 변수는 클래스 설명에서 암시 적으로 남을 수 있습니다. 유형이 명시 적이어야하는 이유는 무엇입니까? 문제는 (int-&amp;gt; int-&amp;gt; int)-&amp;gt; int-&amp;gt; int도 폴드에 유효한 유형이며 우리가 제공 한 다형성 유형과 호환되지 않는다는 것입니다 (자동 인스턴스화는 최상위 유형 변수에 대해서만 작동합니다. 결정 불가능한 문제가되는 내부 한정자는 아닙니다. 따라서 컴파일러는이 두 유형 중에서 선택할 수 없으며 도움을 받아야합니다.</target>
        </trans-unit>
        <trans-unit id="11d6e59058333963706b9356b3eee7ab6f10414a" translate="yes" xml:space="preserve">
          <source>As you move through the program, the debugger maintains an history of the successive times you stop at. The last command can be used to revisit these times: each last command moves one step back through the history. That is useful mainly to undo commands such as step and next.</source>
          <target state="translated">프로그램을 통해 이동할 때 디버거는 사용자가 정지 한 연속 시간의 기록을 유지합니다. 마지막 명령을 사용하여 이러한 시간을 다시 방문 할 수 있습니다. 마지막 명령이 각각 기록에서 한 단계 뒤로 이동합니다. 이는 주로 단계 및 다음과 같은 명령을 실행 취소하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="65354bb2656ea18d389b5fe5b411f5ee0d5e3d75" translate="yes" xml:space="preserve">
          <source>Assign an element of a generic Bigarray.</source>
          <target state="translated">일반 Bigarray의 요소를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="511e2f6557588ce6cb49fae5b91217ffb45c65de" translate="yes" xml:space="preserve">
          <source>Assign an element of a generic Bigarray. &lt;code&gt;Genarray.set&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&amp;nbsp;v&lt;/code&gt; stores the value &lt;code&gt;v&lt;/code&gt; in the element of &lt;code&gt;a&lt;/code&gt; whose coordinates are &lt;code&gt;i1&lt;/code&gt; in the first dimension, &lt;code&gt;i2&lt;/code&gt; in the second dimension, ..., &lt;code&gt;iN&lt;/code&gt; in the &lt;code&gt;N&lt;/code&gt;-th dimension.</source>
          <target state="translated">일반 Bigarray의 요소를 지정하십시오. &lt;code&gt;Genarray.set&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&amp;nbsp;v&lt;/code&gt; 는 좌표가 첫 번째 차원에서 &lt;code&gt;i1&lt;/code&gt; , 두 번째 차원에서 &lt;code&gt;i2&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; 번째 차원 에서 ..., &lt;code&gt;iN&lt;/code&gt; 인 &lt;code&gt;a&lt;/code&gt; 의 요소에 값 &lt;code&gt;v&lt;/code&gt; 를 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="8e4441e6b01109409d7db5b3985d7033187d4a2e" translate="yes" xml:space="preserve">
          <source>Assignment to non-mutable value.</source>
          <target state="translated">변경할 수없는 값에 할당.</target>
        </trans-unit>
        <trans-unit id="693b1e8e0efde6572420480f71fd8ac02e79cc56" translate="yes" xml:space="preserve">
          <source>Associate precedences and associativities to the given symbols. All symbols on the same line are given the same precedence. They have higher precedence than symbols declared before in a &lt;code&gt;%left&lt;/code&gt;, &lt;code&gt;%right&lt;/code&gt; or &lt;code&gt;%nonassoc&lt;/code&gt; line. They have lower precedence than symbols declared after in a &lt;code&gt;%left&lt;/code&gt;, &lt;code&gt;%right&lt;/code&gt; or &lt;code&gt;%nonassoc&lt;/code&gt; line. The symbols are declared to associate to the left (&lt;code&gt;%left&lt;/code&gt;), to the right (&lt;code&gt;%right&lt;/code&gt;), or to be non-associative (&lt;code&gt;%nonassoc&lt;/code&gt;). The symbols are usually tokens. They can also be dummy nonterminals, for use with the &lt;code&gt;%prec&lt;/code&gt; directive inside the rules.</source>
          <target state="translated">우선 순위 및 연관성을 주어진 기호에 연결합니다. 같은 줄에있는 모든 기호에는 같은 우선 순위가 부여됩니다. &lt;code&gt;%left&lt;/code&gt; , &lt;code&gt;%right&lt;/code&gt; 또는 &lt;code&gt;%nonassoc&lt;/code&gt; 행 에서 이전에 선언 된 기호보다 우선 순위가 높습니다 . &lt;code&gt;%left&lt;/code&gt; , &lt;code&gt;%right&lt;/code&gt; 또는 &lt;code&gt;%nonassoc&lt;/code&gt; 행 에서 뒤에 선언 된 기호보다 우선 순위가 낮 습니다. 기호는 왼쪽 ( &lt;code&gt;%left&lt;/code&gt; ), 오른쪽 ( &lt;code&gt;%right&lt;/code&gt; ) 또는 비 연관 ( &lt;code&gt;%nonassoc&lt;/code&gt; ) 에 연결되도록 선언됩니다 . 기호는 일반적으로 토큰입니다. 규칙 내에서 &lt;code&gt;%prec&lt;/code&gt; 지시문 과 함께 사용하기위한 더미 비 터미널 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afd5b4fd5a802d12133439bb6c727c5550f6bdba" translate="yes" xml:space="preserve">
          <source>Associate style number n to the given L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X sectioning command style, e.g. section or subsection. (L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X only.) This is useful when including the generated document in another L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X document, at a given sectioning level. The default association is 1 for section, 2 for subsection, 3 for subsubsection, 4 for paragraph and 5 for subparagraph.</source>
          <target state="translated">스타일 번호 n을 지정된 L &lt;sup&gt;A&lt;/sup&gt; T &lt;sub&gt;E&lt;/sub&gt; X 단면 명령 스타일 (예 : 섹션 또는 하위 섹션)에 연결합니다. (L &lt;sup&gt;A&lt;/sup&gt; T &lt;sub&gt;E&lt;/sub&gt; X에만 해당) 이것은 생성 된 문서를 주어진 섹션 레벨 에서 다른 L &lt;sup&gt;A&lt;/sup&gt; T &lt;sub&gt;E&lt;/sub&gt; X 문서 에 포함시킬 때 유용 합니다. 기본 연결은 섹션의 경우 1, 하위 섹션의 경우 2, 하위 섹션의 경우 3, 단락의 경우 4, 하위 단락의 경우 5입니다.</target>
        </trans-unit>
        <trans-unit id="c524fc36c86bd0a5d156287f9e272e9da389f023" translate="yes" xml:space="preserve">
          <source>Associate the given description (&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;) to the given parameter name id. This tag is used for functions, methods, classes and functors.</source>
          <target state="translated">주어진 설명 ( &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt; )을 주어진 매개 변수 이름 ID에 연결합니다. 이 태그는 함수, 메서드, 클래스 및 펑터에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ec8233ec4293e18af80d1bdb5a2abfd01936116" translate="yes" xml:space="preserve">
          <source>Associate the given description (&lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;) to the given version in order to document compatibility issues.</source>
          <target state="translated">호환성 문제를 문서화하기 위해 주어진 설명 ( &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt; )을 주어진 버전에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="55db56ff500f9ca6b11e56023800331829b479b0" translate="yes" xml:space="preserve">
          <source>Association lists</source>
          <target state="translated">협회 목록</target>
        </trans-unit>
        <trans-unit id="933443d0e9517ae1d7a08acaa81c31f178831777" translate="yes" xml:space="preserve">
          <source>Association tables over ordered types.</source>
          <target state="translated">주문 된 유형에 대한 연관 테이블.</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="2a1741771c0cc3890682eb4ba730ff53f9e9d5dd" translate="yes" xml:space="preserve">
          <source>Assume that module module is opened before parsing each of the following files.</source>
          <target state="translated">다음 각 파일을 구문 분석하기 전에 모듈 모듈이 열려 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="732d31f2e28996ce7c1526a4c29db2def23d8755" translate="yes" xml:space="preserve">
          <source>Assuming &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt; denotes a signature, the expression &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;with&lt;a href=&quot;#mod-constraint&quot;&gt;mod-constraint&lt;/a&gt; { and&lt;a href=&quot;#mod-constraint&quot;&gt;mod-constraint&lt;/a&gt; } denotes the same signature where type equations have been added to some of the type specifications, as described by the constraints following the with keyword. The constraint type [&lt;a href=&quot;classes#type-parameters&quot;&gt;type-parameters&lt;/a&gt;] &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; adds the type equation =&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; to the specification of the type component named &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; of the constrained signature. The constraint module&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;=&lt;a href=&quot;names#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt; adds type equations to all type components of the sub-structure denoted by &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;, making them equivalent to the corresponding type components of the structure denoted by &lt;a href=&quot;names#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt;.</source>
          <target state="translated">가정 &lt;a href=&quot;#module-type&quot;&gt;모듈 형하는&lt;/a&gt; 서명을 나타내고, 식 &lt;a href=&quot;#module-type&quot;&gt;모듈 형&lt;/a&gt; 으로 &lt;a href=&quot;#mod-constraint&quot;&gt;개조 - 제약&lt;/a&gt; {및 &lt;a href=&quot;#mod-constraint&quot;&gt;개조 - 제약&lt;/a&gt; } 제약에 의해 기술 된 바와 같이 입력 방정식, 타입 규격의 일부에 추가 된 동일한 서명 키워드로는 다음을 나타낸다. 제약 유형 [ &lt;a href=&quot;classes#type-parameters&quot;&gt;type-parameters&lt;/a&gt; ] &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; = &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; 은 제약 된 시그니처의 &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; 이라는 형식 구성 요소의 사양에 형식 방정식 = &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; 을 추가합니다 . 제약 모듈 &lt;a href=&quot;names#module-path&quot;&gt;모듈 경로&lt;/a&gt; = &lt;a href=&quot;names#extended-module-path&quot;&gt;확장 모듈 경로&lt;/a&gt;&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; 로 표시된 하위 구조의 모든 유형 구성 요소에 유형 방정식을 추가 하여 &lt;a href=&quot;names#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt; 로 표시된 구조의 해당 유형 구성 요소와 동일하게 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="4abe40bc093a635fe5f2393dd098c162da653457" translate="yes" xml:space="preserve">
          <source>Assuming unique ownership of strings that are not string literals, but are (partly) built from string literals, is also incorrect. For example, mutating &lt;code&gt;unsafe_of_string&amp;nbsp;(&quot;foo&quot;&amp;nbsp;^&amp;nbsp;s)&lt;/code&gt; could mutate the shared string &lt;code&gt;&quot;foo&quot;&lt;/code&gt; -- assuming a rope-like representation of strings. More generally, functions operating on strings will assume shared ownership, they do not preserve unique ownership. It is thus incorrect to assume unique ownership of the result of &lt;code&gt;unsafe_of_string&lt;/code&gt;.</source>
          <target state="translated">문자열 리터럴은 아니지만 문자열 리터럴에서 (부분적으로) 빌드 된 문자열의 고유 한 소유권을 가정하는 것도 올바르지 않습니다. 예를 들어, &lt;code&gt;unsafe_of_string&amp;nbsp;(&quot;foo&quot;&amp;nbsp;^&amp;nbsp;s)&lt;/code&gt; 을 변경하면 공유 문자열 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 가 변경 될 수 있습니다. 보다 일반적으로 문자열에서 작동하는 함수는 공유 소유권을 가정하고 고유 소유권을 유지하지 않습니다. 따라서 &lt;code&gt;unsafe_of_string&lt;/code&gt; 결과의 고유 한 소유권을 가정하는 것은 올바르지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0bf8057d6f5fa665b07dbede310cfe4a69c03150" translate="yes" xml:space="preserve">
          <source>Astute readers may have wondered what happens when two or more record fields or constructors share the same name</source>
          <target state="translated">예리한 독자는 둘 이상의 레코드 필드 또는 생성자가 동일한 이름을 공유 할 때 어떤 일이 발생하는지 궁금해했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="9b1c0634cae4469e9d81ecf95e188f347608b54f" translate="yes" xml:space="preserve">
          <source>At any point, the parsing, compilation or evaluation of the current phrase can be interrupted by pressing ctrl-C (or, more precisely, by sending the INTR signal to the ocaml process). The toplevel then immediately returns to the # prompt.</source>
          <target state="translated">언제든지 ctrl-C를 눌러 (또는 더 정확하게는 INTR 신호를 ocaml 프로세스로 전송하여) 현재 구문의 구문 분석, 컴파일 또는 평가를 중단 할 수 있습니다. 그러면 최상위 수준은 즉시 # 프롬프트로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="e0f954f80a0891f6d5cf340cf9dd1de0665d55eb" translate="yes" xml:space="preserve">
          <source>At any time, one of the stack frames is &amp;ldquo;selected&amp;rdquo; by the debugger; several debugger commands refer implicitly to the selected frame. In particular, whenever you ask the debugger for the value of a local variable, the value is found in the selected frame. The commands frame, up and down select whichever frame you are interested in.</source>
          <target state="translated">언제든지 스택 프레임 중 하나는 디버거에 의해 &quot;선택&quot;됩니다. 여러 디버거 명령은 선택한 프레임을 암시 적으로 참조합니다. 특히 디버거에 지역 변수의 값을 요청할 때마다 선택한 프레임에서 값을 찾습니다. 명령 프레임, 위아래로 관심있는 프레임을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="0dc1f362156648d6f2461a3991beac3755f48ca1" translate="yes" xml:space="preserve">
          <source>At first look, we seem to have a polymorphic iterator, however this does not work in practice.</source>
          <target state="translated">처음에는 다형성 반복자가있는 것처럼 보이지만 실제로는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b360f9d1eec9c2be338db85e91ea4dcbd8c92d8" translate="yes" xml:space="preserve">
          <source>At last, (**) is the empty documentation comment.</source>
          <target state="translated">마지막으로 (**)는 빈 문서 주석입니다.</target>
        </trans-unit>
        <trans-unit id="75750c4cc5cbc3e0ac4fdd64ce772e90747028f1" translate="yes" xml:space="preserve">
          <source>At last, it is possible to update few fields of a record at once:</source>
          <target state="translated">마침내 한 번에 몇 개의 레코드 필드를 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24a9bd7e79cc365e9058d6659c3e41e323547e2e" translate="yes" xml:space="preserve">
          <source>At present there may be a small penalty in terms of actual runtime performance when this transformation is enabled, although more stable performance may be obtained due to reduced allocation. It is recommended that developers experiment to determine whether the option is beneficial for their code. (It is expected that in the future it will be possible for the performance degradation to be removed.)</source>
          <target state="translated">현재이 변환이 활성화되면 실제 런타임 성능 측면에서 약간의 불이익이있을 수 있지만 할당 감소로 인해보다 안정적인 성능을 얻을 수 있습니다. 개발자는 옵션이 코드에 유익한 지 확인하기 위해 실험하는 것이 좋습니다. (향후 성능 저하를 제거 할 수있을 것으로 예상됩니다.)</target>
        </trans-unit>
        <trans-unit id="54dd7dd52291d1b6f1c195771e2d20eb9e881245" translate="yes" xml:space="preserve">
          <source>At run-time, the ocamlyacc-generated parser can be debugged by setting the p option in the OCAMLRUNPARAM environment variable (see section &lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt;). This causes the pushdown automaton executing the parser to print a trace of its action (tokens shifted, rules reduced, etc). The trace mentions rule numbers and state numbers that can be interpreted by looking at the file grammar.output generated by ocamlyacc -v.</source>
          <target state="translated">런타임에 ocamlyacc 생성 파서는 OCAMLRUNPARAM 환경 변수에 p 옵션을 설정하여 디버깅 할 수 있습니다 (섹션 &lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt; 참조 ). 이로 인해 파서를 실행하는 푸시 다운 자동 장치가 작업 추적 (토큰 이동, 규칙 감소 등)을 인쇄합니다. 추적은 ocamlyacc -v에 의해 생성 된 grammar.output 파일을보고 해석 할 수있는 규칙 번호 및 상태 번호를 언급합니다.</target>
        </trans-unit>
        <trans-unit id="d2f00cca88cba919167a69aefb8aca0e72bd25ac" translate="yes" xml:space="preserve">
          <source>At runtime, &lt;code&gt;opaque_identity&lt;/code&gt; disappears altogether.</source>
          <target state="translated">런타임에 &lt;code&gt;opaque_identity&lt;/code&gt; 는 모두 사라집니다.</target>
        </trans-unit>
        <trans-unit id="a9dc01fd9b8fd2388a520e411cae0d934f399e38" translate="yes" xml:space="preserve">
          <source>At some point, the C code must call caml_main(argv) to initialize the OCaml code. The argv argument is a C array of strings (type char **), terminated with a NULL pointer, which represents the command-line arguments, as passed as second argument to main. The OCaml array Sys.argv will be initialized from this parameter. For the bytecode compiler, argv[0] and argv[1] are also consulted to find the file containing the bytecode.</source>
          <target state="translated">어떤 시점에서 C 코드는 OCaml 코드를 초기화하기 위해 caml_main (argv)를 호출해야합니다. argv 인수는 두 번째 인수로 main에 전달 된대로 명령 줄 인수를 나타내는 NULL 포인터로 종료되는 문자열의 C 배열 (char ** 유형)입니다. OCaml 배열 Sys.argv는이 매개 변수에서 초기화됩니다. 바이트 코드 컴파일러의 경우, 바이트 코드가 포함 된 파일을 찾기 위해 argv [0] 및 argv [1]도 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="6144d2f50b69132b6f0e43a3d8df29f0e099b424" translate="yes" xml:space="preserve">
          <source>At the beginning of each iteration of a loop:</source>
          <target state="translated">루프의 각 반복 시작시 :</target>
        </trans-unit>
        <trans-unit id="276d173e91530ea988de8831effc50db36e2cd99" translate="yes" xml:space="preserve">
          <source>At this point, the type checker rightfully complains that it is not possible to swap an integer and a function, and that an int should always be traded for another int. Furthermore, the type checker prevents us to change manually the type of the value stored by store:</source>
          <target state="translated">이 시점에서 타입 검사기는 정수와 함수를 교환 할 수 없으며 int는 항상 다른 int와 교환되어야한다고 정당하게 불평합니다. 또한 유형 검사기는 상점에 저장된 값의 유형을 수동으로 변경하는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="baefb49296d510841d2323ca6269711e7aab517d" translate="yes" xml:space="preserve">
          <source>Atom(t) returns an &amp;ldquo;atom&amp;rdquo; (zero-sized block) with tag t. Zero-sized blocks are preallocated outside of the heap. It is incorrect to try and allocate a zero-sized block using the functions below. For instance, Atom(0) represents the empty array.</source>
          <target state="translated">Atom (t)는 태그 t가있는 &quot;atom&quot;(크기가 0 인 블록)을 반환합니다. 크기가 0 인 블록은 힙 외부에 미리 할당됩니다. 아래 함수를 사용하여 크기가 0 인 블록을 시도하고 할당하는 것은 올바르지 않습니다. 예를 들어, Atom (0)은 빈 배열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4596b982bdd8c86e98fef6030471fc19a2011ab4" translate="yes" xml:space="preserve">
          <source>Attached to a &lt;em&gt;declaration&lt;/em&gt; of a function or functor, these direct the inliner to either always or never inline, irrespective of the size/benefit calculation. (If the function is recursive then the body is substituted and no special action is taken for the recursive call site(s).) @@inline with no argument is equivalent to @@inline always.</source>
          <target state="translated">함수 또는 펑터 의 &lt;em&gt;선언&lt;/em&gt; 에 첨부되어 크기 / 이점 계산에 관계없이 인라이너가 항상 또는 절대 인라인하지 않도록 지시합니다. (함수가 재귀 적이면 본문이 대체되고 재귀 호출 사이트에 대해 특별한 조치가 취해지지 않습니다.) 인수가없는 @@ inline은 항상 @@ inline과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="802fa8cc9235819a2e3ca4b7e5ad5a55102ca722" translate="yes" xml:space="preserve">
          <source>Attached to a declaration of a function or functor, this directs the inliner to either always or never specialise the function so long as it has appropriate contextual knowledge, irrespective of the size/benefit calculation. @@specialise with no argument is equivalent to @@specialise always.</source>
          <target state="translated">함수 또는 펑터의 선언에 첨부되어 크기 / 이점 계산에 관계없이 적절한 컨텍스트 지식이있는 한 인라이너가 함수를 항상 또는 전혀 전문화하지 않도록 지시합니다. 인수가없는 @@ specialise는 항상 @@ specialise와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="e01f52df1214db8e3914c14829a8d5d286049aea" translate="yes" xml:space="preserve">
          <source>Attached to a function &lt;em&gt;application&lt;/em&gt;, these direct the inliner likewise. These attributes at call sites override any other attribute that may be present on the corresponding declaration. @inlined with no argument is equivalent to @inlined always. @@inlined hint is equivalent to @@inline always except that it will not trigger warning 55 if the function application cannot be inlined.</source>
          <target state="translated">함수 &lt;em&gt;애플리케이션&lt;/em&gt; 에 연결되어 인라이너도 마찬가지로 지시합니다. 호출 사이트의 이러한 특성은 해당 선언에있을 수있는 다른 특성을 재정의합니다. 인수가없는 @inlined는 항상 @inlined와 동일합니다. @@ inlined 힌트는 함수 응용 프로그램을 인라인 할 수없는 경우 경고 55를 트리거하지 않는다는 점을 제외하면 항상 @@ inline과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="577cc545cd56605f7a335573934c186d1c5c7a5e" translate="yes" xml:space="preserve">
          <source>Attached to a function application, this directs the inliner likewise. This attribute at a call site overrides any other attribute that may be present on the corresponding declaration. (Note that the function will still only be specialised if there exist one or more invariant parameters whose values are known.) @specialised with no argument is equivalent to @specialised always.</source>
          <target state="translated">함수 응용 프로그램에 연결하면 인라이너도 마찬가지로 지시됩니다. 호출 사이트의이 특성은 해당 선언에있을 수있는 다른 특성을 재정의합니다. (함수는 값이 알려진 하나 이상의 고정 매개 변수가있는 경우에만 특수화됩니다.) 인수가없는 @specialised는 항상 @specialised와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1728583c4e4935b573475fde344d9528bb9ac187" translate="yes" xml:space="preserve">
          <source>Attribute cannot appear in this context.</source>
          <target state="translated">이 컨텍스트에는 속성을 표시 할 수 없습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="4070acc0b0373988065e52262412987a5bd978b2" translate="yes" xml:space="preserve">
          <source>Attribute used more than once on an expression.</source>
          <target state="translated">표현식에서 두 번 이상 사용 된 속성입니다.</target>
        </trans-unit>
        <trans-unit id="5990efd0ab5779ce4f416b7925179828c4ee7318" translate="yes" xml:space="preserve">
          <source>Attributes are &amp;ldquo;decorations&amp;rdquo; of the syntax tree which are mostly ignored by the type-checker but can be used by external tools. An attribute is made of an identifier and a payload, which can be a structure, a type expression (prefixed with :), a signature (prefixed with :) or a pattern (prefixed with ?) optionally followed by a when clause:</source>
          <target state="translated">속성은 대부분 유형 검사기에서 무시되지만 외부 도구에서 사용할 수있는 구문 트리의 &quot;장식&quot;입니다. 속성은 식별자와 페이로드로 구성되며, 구조, 유형 표현식 (접두사 :), 서명 (접두사 :) 또는 패턴 (접두사?</target>
        </trans-unit>
        <trans-unit id="1f1f8b09e882b8bdbac720d714a972f55a4914cb" translate="yes" xml:space="preserve">
          <source>August 19, 2020</source>
          <target state="translated">2020 년 8 월 19 일</target>
        </trans-unit>
        <trans-unit id="681b5b5ae10b994e61d9fc53cf8a95498ff0df39" translate="yes" xml:space="preserve">
          <source>Availability</source>
          <target state="translated">Availability</target>
        </trans-unit>
        <trans-unit id="24aced72f5f433a578a6c9a6998684afc743e91e" translate="yes" xml:space="preserve">
          <source>Avoid the following construction:</source>
          <target state="translated">다음 구성을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="603bfbbca70684e9b081257d12079a348cfb4ae1" translate="yes" xml:space="preserve">
          <source>Backend type currently executing the OCaml program.</source>
          <target state="translated">현재 OCaml 프로그램을 실행중인 백엔드 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1afefdad8f394c65ed6d000a865d699a38489c6f" translate="yes" xml:space="preserve">
          <source>Bad address</source>
          <target state="translated">잘못된 주소</target>
        </trans-unit>
        <trans-unit id="c3d27fc57dc9d9f238fc65173552cc838eeef367" translate="yes" xml:space="preserve">
          <source>Bad argument to routine</source>
          <target state="translated">루틴에 대한 잘못된 인수</target>
        </trans-unit>
        <trans-unit id="100269e198b12a051ab659ff66bd324a08031278" translate="yes" xml:space="preserve">
          <source>Bad file descriptor</source>
          <target state="translated">잘못된 파일 설명자</target>
        </trans-unit>
        <trans-unit id="8951a0674378b9d01744b0df5ceff44c017f170d" translate="yes" xml:space="preserve">
          <source>Bad module name: the source file name is not a valid OCaml module name.</source>
          <target state="translated">잘못된 모듈 이름 : 소스 파일 이름이 유효한 OCaml 모듈 이름이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4eb2f5b83ca06e2054445f5793507dccb214e76c" translate="yes" xml:space="preserve">
          <source>Base 10 logarithm.</source>
          <target state="translated">밑이 10 인 로그.</target>
        </trans-unit>
        <trans-unit id="16d2d5bc5f9c1c788a0de9d9941705860dc2b3ce" translate="yes" xml:space="preserve">
          <source>Basic file input/output</source>
          <target state="translated">기본 파일 입력 / 출력</target>
        </trans-unit>
        <trans-unit id="58c96a6812d6bac9777029dd40fb7e6afd5c8c94" translate="yes" xml:space="preserve">
          <source>Basic functions</source>
          <target state="translated">기본 기능</target>
        </trans-unit>
        <trans-unit id="7074f9544472955bb39bd2591371cef9276556d5" translate="yes" xml:space="preserve">
          <source>Basic input/output</source>
          <target state="translated">기본 입력 / 출력</target>
        </trans-unit>
        <trans-unit id="e51905526a8ccdb787933df456dfe816843d0ee8" translate="yes" xml:space="preserve">
          <source>Be aware that subtyping and inheritance are not related. Inheritance is a syntactic relation between classes while subtyping is a semantic relation between types. For instance, the class of colored points could have been defined directly, without inheriting from the class of points; the type of colored points would remain unchanged and thus still be a subtype of points.</source>
          <target state="translated">하위 유형 지정과 상속은 관련이 없습니다. 상속은 클래스 간의 구문 관계이며 하위 유형은 유형 간의 의미 관계입니다. 예를 들어, 컬러 포인트 클래스는 포인트 클래스에서 상속하지 않고 직접 정의 할 수 있습니다. 컬러 포인트의 유형은 변경되지 않고 여전히 포인트의 하위 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bdc8260c792f0fd4d9bb961f3934f71b326ac1eb" translate="yes" xml:space="preserve">
          <source>Before 4.10, it was not fully implemented by the native-code compiler.</source>
          <target state="translated">4.10 이전에는 네이티브 코드 컴파일러에 의해 완전히 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b74f4732c6818d44f09006d1f07ce5f4af4c8740" translate="yes" xml:space="preserve">
          <source>Before 4.10, stack overflows, typically caused by excessively deep recursion, are not always turned into a Stack_overflow exception like with the bytecode compiler. The runtime system makes a best effort to trap stack overflows and raise the Stack_overflow exception, but sometimes it fails and a &amp;ldquo;segmentation fault&amp;rdquo; or another system fault occurs instead.</source>
          <target state="translated">4.10 이전에는 일반적으로 지나치게 깊은 재귀로 인해 발생하는 스택 오버플로가 바이트 코드 컴파일러와 같이 항상 Stack_overflow 예외로 바뀌지는 않습니다. 런타임 시스템은 스택 오버플로를 트랩하고 Stack_overflow 예외를 발생시키기 위해 최선을 다하지만 때때로 실패하고 &quot;세그먼트 오류&quot;또는 다른 시스템 오류가 대신 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cb21f986b61750e9afb09c606ad7c4cb297548ed" translate="yes" xml:space="preserve">
          <source>Before OCaml 4.08, there was support for a single kind of deprecation alert. It is now known as the deprecated alert, but legacy attributes to trigger it and the legacy ways to control it as warning 3 are still supported. For instance, passing -w +3 on the command-line is equivant to -alert +deprecated, and:</source>
          <target state="translated">OCaml 4.08 이전에는 단일 종류의 사용 중단 경고가 지원되었습니다. 이제는 더 이상 사용되지 않는 경고로 알려져 있지만이를 트리거하는 레거시 속성과 경고 3으로 제어하는 ​​레거시 방법은 계속 지원됩니다. 예를 들어, 명령 줄에서 -w +3을 전달하는 것은 -alert + deprecated와 동일하며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2de7f66ef195f2ee3a503b74c10b402e912c79ce" translate="yes" xml:space="preserve">
          <source>Before OCaml 4.09, this package simply ensures that the graphics library was installed by the compiler, and starting from OCaml 4.09 this package effectively provides the graphics library.</source>
          <target state="translated">OCaml 4.09 이전에이 패키지는 단순히 그래픽 라이브러리가 컴파일러에 의해 설치되었는지 확인하고 OCaml 4.09부터이 패키지는 그래픽 라이브러리를 효과적으로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e622083eb29748ddeeec3a04799aa00ee19ac13f" translate="yes" xml:space="preserve">
          <source>Before including any of these files, you should define the OCAML_NAME_SPACE macro. For instance,</source>
          <target state="translated">이러한 파일을 포함하기 전에 OCAML_NAME_SPACE 매크로를 정의해야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="3e4184edb42a26ccfe7484a8b5fb01a18a764ebd" translate="yes" xml:space="preserve">
          <source>Before profiling an execution, the program must be compiled in profiling mode, using the ocamlcp front-end to the ocamlc compiler (see chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;) or the ocamloptp front-end to the ocamlopt compiler (see chapter &lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt;). When compiling modules separately, ocamlcp or ocamloptp must be used when compiling the modules (production of .cmo or .cmx files), and can also be used (though this is not strictly necessary) when linking them together.</source>
          <target state="translated">실행을 프로파일 링하기 전에 프로그램은 ocamlcp 프런트 엔드를 ocamlc 컴파일러 ( &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; 장 참조 ) 또는 ocamloptp 프런트 엔드를 ocamlopt 컴파일러 ( &lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt; 장 참조)에 사용하여 프로파일 링 모드에서 컴파일해야합니다 . 모듈을 개별적으로 컴파일 할 때는 모듈을 컴파일 할 때 ocamlcp 또는 ocamloptp를 사용해야하며 (.cmo 또는 .cmx 파일 생성) 함께 연결할 때도 사용할 수 있습니다 (엄격하게 필요한 것은 아닙니다).</target>
        </trans-unit>
        <trans-unit id="d51fe98572851ae3a2060aa9cce6148029d326e3" translate="yes" xml:space="preserve">
          <source>Before the debugger can be used, the program must be compiled and linked with the -g option: all .cmo and .cma files that are part of the program should have been created with ocamlc -g, and they must be linked together with ocamlc -g.</source>
          <target state="translated">디버거를 사용하기 전에 프로그램을 컴파일하고 -g 옵션으로 링크해야합니다. 프로그램의 일부인 모든 .cmo 및 .cma 파일은 ocamlc -g로 작성되어야하며 ocamlc와 함께 링크되어야합니다. -지.</target>
        </trans-unit>
        <trans-unit id="7224b7ef29ead465950bd04b8cbe2bc5541ba937" translate="yes" xml:space="preserve">
          <source>Behave as &lt;a href=&quot;threadunix#VALread&quot;&gt;&lt;code&gt;ThreadUnix.read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;threadunix#VALwrite&quot;&gt;&lt;code&gt;ThreadUnix.write&lt;/code&gt;&lt;/a&gt;, except that &lt;code&gt;Unix_error(ETIMEDOUT,_,_)&lt;/code&gt; is raised if no data is available for reading or ready for writing after &lt;code&gt;d&lt;/code&gt; seconds.</source>
          <target state="translated">로 행동 &lt;a href=&quot;threadunix#VALread&quot;&gt; &lt;code&gt;ThreadUnix.read&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;threadunix#VALwrite&quot;&gt; &lt;code&gt;ThreadUnix.write&lt;/code&gt; &lt;/a&gt; 것을 제외하고, &lt;code&gt;Unix_error(ETIMEDOUT,_,_)&lt;/code&gt; 데이터가 후 기입 읽을 수 또는 준비가없는 경우 발생 &lt;code&gt;d&lt;/code&gt; 개 초.</target>
        </trans-unit>
        <trans-unit id="c62be5fdf722fa0cb2c996d270b26e047fd26ba0" translate="yes" xml:space="preserve">
          <source>Behave as &lt;a href=&quot;threadunix#VALread&quot;&gt;&lt;code&gt;ThreadUnix.read&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;threadunix#VALwrite&quot;&gt;&lt;code&gt;ThreadUnix.write&lt;/code&gt;&lt;/a&gt;, except that &lt;code&gt;Unix_error(ETIMEDOUT,_,_)&lt;/code&gt; is raised if no data is available for reading or ready for writing after &lt;code&gt;d&lt;/code&gt; seconds. The delay &lt;code&gt;d&lt;/code&gt; is given in the fifth argument, in seconds.</source>
          <target state="translated">로 행동 &lt;a href=&quot;threadunix#VALread&quot;&gt; &lt;code&gt;ThreadUnix.read&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;threadunix#VALwrite&quot;&gt; &lt;code&gt;ThreadUnix.write&lt;/code&gt; &lt;/a&gt; 것을 제외하고, &lt;code&gt;Unix_error(ETIMEDOUT,_,_)&lt;/code&gt; 데이터가 후 기입 읽을 수 또는 준비가없는 경우 발생 &lt;code&gt;d&lt;/code&gt; 개 초. 지연 &lt;code&gt;d&lt;/code&gt; 는 초 단위로 다섯 번째 인수에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3044d7453db8cbe2dec3a026dd466846b73be035" translate="yes" xml:space="preserve">
          <source>Being written directly into the output device of the formatter, semantic tag marker strings are not considered as part of the printing material that drives line splitting (in other words, the length of the strings corresponding to tag markers is considered as zero for line splitting).</source>
          <target state="translated">시맨틱 태그 마커 문자열은 포맷터의 출력 장치에 직접 기록되므로 라인 분할을 구동하는 인쇄 자료의 일부로 간주되지 않습니다 (즉, 태그 마커에 해당하는 문자열의 길이는 라인 분할을 위해 0으로 간주 됨). .</target>
        </trans-unit>
        <trans-unit id="69bf3db7f530d816adacc226db72ff8b952d7e77" translate="yes" xml:space="preserve">
          <source>Between subexpressions of a sequence:</source>
          <target state="translated">시퀀스의 하위 표현식 사이 :</target>
        </trans-unit>
        <trans-unit id="e01187252d64e42965e1df4b1a6807e200efab0e" translate="yes" xml:space="preserve">
          <source>Between the header and the entry points, one can give names to frequently-occurring regular expressions. This is written let&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;=&lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;. In regular expressions that follow this declaration, the identifier ident can be used as shorthand for regexp.</source>
          <target state="translated">헤더와 진입 점 사이에서 자주 발생하는 정규식에 이름을 지정할 수 있습니다. 이것은 let &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; = &lt;a href=&quot;#regexp&quot;&gt;regexp로&lt;/a&gt; 작성되었습니다 . 이 선언을 따르는 정규식에서 식별자 ident는 regexp의 약어로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0762b857edb23abb186d37a5e2a1cf9b1db82d70" translate="yes" xml:space="preserve">
          <source>Beware also that some idioms make trivial errors very hard to find. For instance, the following code is probably wrong but the compiler has no way to see it.</source>
          <target state="translated">또한 일부 관용구는 사소한 오류를 찾기가 매우 어렵게 만듭니다. 예를 들어, 다음 코드는 아마도 잘못되었을 수 있지만 컴파일러는 그것을 볼 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e96e5378f7f04072916e26ed0422a2ca7fee4ed6" translate="yes" xml:space="preserve">
          <source>Beware of the small syntactic difference between a type constraint on the last parameter</source>
          <target state="translated">마지막 매개 변수에 대한 유형 제약 조건 간의 작은 구문 차이에주의하십시오.</target>
        </trans-unit>
        <trans-unit id="0863d7cb6a04fad42cda06f67cbcf747fb4740c8" translate="yes" xml:space="preserve">
          <source>Beware that channels are buffered so more characters may have been read from the file descriptor than those accessed using channel functions. Channels also keep a copy of the current position in the file.</source>
          <target state="translated">채널이 버퍼링되므로 채널 함수를 사용하여 액세스 한 것보다 파일 설명자에서 더 많은 문자를 읽었을 수 있습니다. 채널은 또한 파일에서 현재 위치의 복사본을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="9a7e376571acd2b703f175df9ba62834f1210318" translate="yes" xml:space="preserve">
          <source>Beware that channels are buffered so you may have to &lt;code&gt;flush&lt;/code&gt; them to ensure that all data has been sent to the file descriptor. Channels also keep a copy of the current position in the file.</source>
          <target state="translated">채널이 버퍼링되므로 모든 데이터가 파일 설명자에 전송되었는지 확인하기 위해 채널을 &lt;code&gt;flush&lt;/code&gt; 해야 할 수 있습니다 . 채널은 또한 파일에서 현재 위치의 복사본을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="ecbdc1b64ef7dc2e9165f4238a760cb0019a726a" translate="yes" xml:space="preserve">
          <source>Beware that this extension is not available inside class definitions:</source>
          <target state="translated">이 확장은 클래스 정의 내에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7c29307b11084a93c6603a32d5d737b8390831ae" translate="yes" xml:space="preserve">
          <source>Beware that this last resort disambiguation is local: once Ocaml has chosen a disambiguation, it sticks to this choice, even if it leads to an ulterior type error:</source>
          <target state="translated">이 마지막 수단의 명확성은 지역적이라는 점에 유의하십시오. Ocaml이 명확성을 선택하면 은밀한 유형 오류가 발생하더라도이 선택을 고수합니다.</target>
        </trans-unit>
        <trans-unit id="f7b2a8eecc3712331ab94305233f63d504f21583" translate="yes" xml:space="preserve">
          <source>Bigarray</source>
          <target state="translated">Bigarray</target>
        </trans-unit>
        <trans-unit id="7380a093245acf7191eec9ec92e09a46e18e884e" translate="yes" xml:space="preserve">
          <source>Bigarray.Array1.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;</source>
          <target state="translated">Bigarray.Array1.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="4836645873279d91f4ef6d2469cebce7bf5a1513" translate="yes" xml:space="preserve">
          <source>Bigarray.Array1.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">Bigarray.Array1.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="294760cd59cde90db4052169e314f7fd0306af03" translate="yes" xml:space="preserve">
          <source>Bigarray.Array2.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;</source>
          <target state="translated">Bigarray.Array2.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="1e8ad3137dd1b9a26a9779ee12d030fac6493896" translate="yes" xml:space="preserve">
          <source>Bigarray.Array2.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">Bigarray.Array2.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="99bb9e3898bd689c37ba94b52b1bc73b90a6f4ab" translate="yes" xml:space="preserve">
          <source>Bigarray.Array3.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;</source>
          <target state="translated">Bigarray.Array3.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="bf4b044934c55212e0d48ca2144367b12b0b6cdc" translate="yes" xml:space="preserve">
          <source>Bigarray.Array3.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">Bigarray.Array3.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cfde812cd151ad76b57b0ef94c12067805e1b7a8" translate="yes" xml:space="preserve">
          <source>Bigarray.Genarray.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;[|&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|]</source>
          <target state="translated">Bigarray.Genarray.get &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;[|&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|]</target>
        </trans-unit>
        <trans-unit id="e5eae93e4a3f09b82ba2713ee1b9fab39405ccae" translate="yes" xml:space="preserve">
          <source>Bigarray.Genarray.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;[|&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|]&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">Bigarray.Genarray.set &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;[|&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|]&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="164b37e902bccec375adcec6ac207f8d8528851b" translate="yes" xml:space="preserve">
          <source>Bigarrays are multi-dimensional. Any number of dimensions between 0 and 16 is supported. In contrast, OCaml arrays are mono-dimensional and require encoding multi-dimensional arrays as arrays of arrays.</source>
          <target state="translated">Bigarray는 다차원입니다. 0에서 16 사이의 모든 차원이 지원됩니다. 대조적으로, OCaml 배열은 1 차원이며 배열의 배열로 다차원 배열을 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="6b10643bcaf2c18dffa1745f8ce67e9efe32a9b7" translate="yes" xml:space="preserve">
          <source>Bigarrays are not limited in size, unlike OCaml arrays. (Normal float arrays are limited to 2,097,151 elements on a 32-bit platform, and normal arrays of other types to 4,194,303 elements.)</source>
          <target state="translated">Bigarray는 OCaml 배열과 달리 크기가 제한되지 않습니다. (일반 float 배열은 32 비트 플랫폼에서 2,097,151 요소로 제한되고 다른 유형의 일반 배열은 4,194,303 요소로 제한됩니다.)</target>
        </trans-unit>
        <trans-unit id="b3c068760255c39d7cfb8804626af3c6a04134aa" translate="yes" xml:space="preserve">
          <source>Bigarrays can contain elements of the following kinds:</source>
          <target state="translated">Bigarray는 다음과 같은 종류의 요소를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06bbb03d095ef0403ef39ce3bec731f64c4edc60" translate="yes" xml:space="preserve">
          <source>Bigarrays can only contain integers and floating-point numbers, while OCaml arrays can contain arbitrary OCaml data types.</source>
          <target state="translated">Bigarray는 정수와 부동 소수점 숫자 만 포함 할 수있는 반면 OCaml 배열은 임의의 OCaml 데이터 유형을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dde73a8c5eb1bd7ebbe27f805e2f18a62417b5de" translate="yes" xml:space="preserve">
          <source>Bigarrays provide more space-efficient storage of integer and floating-point elements than normal OCaml arrays, in particular because they support 'small' types such as single-precision floats and 8 and 16-bit integers, in addition to the standard OCaml types of double-precision floats and 32 and 64-bit integers.</source>
          <target state="translated">Bigarray는 일반 OCaml 배열보다 정수 및 부동 소수점 요소의 공간 효율적인 스토리지를 제공합니다. 특히 표준 OCaml 유형 외에도 단 정밀도 부동 소수점 및 8 비트 및 16 비트 정수와 같은 '작은'유형을 지원하기 때문입니다. 배정 밀도 부동 소수점과 32 비트 및 64 비트 정수.</target>
        </trans-unit>
        <trans-unit id="3b30eba7780f6a33ce03c9072c579c3a782adda9" translate="yes" xml:space="preserve">
          <source>Bigarrays returned by &lt;code&gt;Genarray.create&lt;/code&gt; are not initialized: the initial values of array elements is unspecified.</source>
          <target state="translated">Genarray.create에 의해 반환 된 &lt;code&gt;Genarray.create&lt;/code&gt; 는 초기화되지 않습니다. 배열 요소의 초기 값이 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="062335b880b9c90adbbcca33a681878e4c2f925f" translate="yes" xml:space="preserve">
          <source>Bigarrays support all the OCaml ad-hoc polymorphic operations:</source>
          <target state="translated">Bigarray는 모든 OCaml 임시 다형성 연산을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="b78c464588eab46be79b11f66000060a0a82592e" translate="yes" xml:space="preserve">
          <source>Bigarrays support interesting high-level operations that normal arrays do not provide efficiently, such as extracting sub-arrays and 'slicing' a multi-dimensional array along certain dimensions, all without any copying.</source>
          <target state="translated">Bigarray는 복사없이 하위 배열을 추출하고 특정 차원을 따라 다차원 배열을 '분할'하는 것과 같이 일반 배열이 효율적으로 제공하지 않는 흥미로운 상위 수준 작업을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="fc7ba9c56ac265afa1c83c3f5860425f6f8d05c6" translate="yes" xml:space="preserve">
          <source>Binary encoding of integers</source>
          <target state="translated">정수의 이진 인코딩</target>
        </trans-unit>
        <trans-unit id="dbb694c389c0cdbf75c25a19ef2b17058523cf0a" translate="yes" xml:space="preserve">
          <source>Binary encoding/decoding of integers</source>
          <target state="translated">정수의 이진 인코딩 / 디코딩</target>
        </trans-unit>
        <trans-unit id="c67c6977825a3171348c86b630d52532cd50075d" translate="yes" xml:space="preserve">
          <source>Bind a socket to an address.</source>
          <target state="translated">소켓을 주소에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="d545537631f4daa805af6977069a1ae659ac89fa" translate="yes" xml:space="preserve">
          <source>Bind the substring matched by &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt; to identifier &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt; 와 일치하는 하위 문자열 을 식별자 &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; 에 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="98010387d59d504f717882ee0e29ce9561ef02f7" translate="yes" xml:space="preserve">
          <source>Bitwise arithmetic shift right on integers.</source>
          <target state="translated">정수에서 비트 산술 오른쪽으로 시프트합니다.</target>
        </trans-unit>
        <trans-unit id="1ad662d09220d0d46d46b6bfecb1798cd38adcc0" translate="yes" xml:space="preserve">
          <source>Bitwise logical &amp;ldquo;and&amp;rdquo; on integers.</source>
          <target state="translated">정수에 대한 비트 논리 &quot;and&quot;.</target>
        </trans-unit>
        <trans-unit id="49aac382b8e35200a9044197b1ea4c4df4708643" translate="yes" xml:space="preserve">
          <source>Bitwise logical &amp;ldquo;exclusive or&amp;rdquo; on integers.</source>
          <target state="translated">정수에 대한 비트 논리 &quot;배타적 또는&quot;.</target>
        </trans-unit>
        <trans-unit id="286b2e0f11888729ecb5275bfd01f89e609e86af" translate="yes" xml:space="preserve">
          <source>Bitwise logical &amp;ldquo;or&amp;rdquo; on integers.</source>
          <target state="translated">정수의 비트 논리 &quot;또는&quot;.</target>
        </trans-unit>
        <trans-unit id="38f47fa82a9e81696cb44cafa1b49f3b15a8d783" translate="yes" xml:space="preserve">
          <source>Bitwise logical and.</source>
          <target state="translated">비트 논리 및.</target>
        </trans-unit>
        <trans-unit id="f8120788c98e6228e8b9d7bcf0ec24a6003d5162" translate="yes" xml:space="preserve">
          <source>Bitwise logical and. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">비트 논리 및. 왼쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="e12d57bf21bac825baf9ff63c9856f69ab644445" translate="yes" xml:space="preserve">
          <source>Bitwise logical exclusive or.</source>
          <target state="translated">비트 논리 배타적 또는.</target>
        </trans-unit>
        <trans-unit id="d9b30b925799da28ec0ac76d3e01a3f81148da08" translate="yes" xml:space="preserve">
          <source>Bitwise logical exclusive or. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">비트 논리 배타적 또는. 왼쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="1e959911aefbddc80325181098fb38e48a8332ea" translate="yes" xml:space="preserve">
          <source>Bitwise logical negation.</source>
          <target state="translated">비트 논리 부정.</target>
        </trans-unit>
        <trans-unit id="a2b2038f4572ce60bed7fe655e3af57ae6849b39" translate="yes" xml:space="preserve">
          <source>Bitwise logical or.</source>
          <target state="translated">비트 논리 또는.</target>
        </trans-unit>
        <trans-unit id="40f0ebc0438d2a8b3f7d8ab17a47e2fc7e9a6733" translate="yes" xml:space="preserve">
          <source>Bitwise logical or. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">비트 논리 또는. 왼쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="51e629b6c338431a80d282be3b9738ea06d447a3" translate="yes" xml:space="preserve">
          <source>Bitwise logical shift left on integers.</source>
          <target state="translated">정수에서 왼쪽으로 비트 논리 시프트.</target>
        </trans-unit>
        <trans-unit id="1c1d051215d4090b7e416aa0c5b96654c34c3df3" translate="yes" xml:space="preserve">
          <source>Bitwise logical shift right on integers.</source>
          <target state="translated">정수에서 오른쪽으로 비트 논리 시프트.</target>
        </trans-unit>
        <trans-unit id="67445a8812f7cd259e3b6e21272d2fddff30a9e2" translate="yes" xml:space="preserve">
          <source>Bitwise operations</source>
          <target state="translated">비트 연산</target>
        </trans-unit>
        <trans-unit id="e2f8396020dfba14aa5dc6b1bd83f4647bd8ef67" translate="yes" xml:space="preserve">
          <source>Block device</source>
          <target state="translated">블록 장치</target>
        </trans-unit>
        <trans-unit id="f44f089c39b56e3f8dc6fad275cc2d75db99650b" translate="yes" xml:space="preserve">
          <source>Block with size = 2 and tag = 0; first field contains h, second field t.</source>
          <target state="translated">크기가 2이고 태그가 0 인 블록; 첫 번째 필드에는 h, 두 번째 필드 t가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="28d4367bfac6247903d75f1f870462ae73cd80c5" translate="yes" xml:space="preserve">
          <source>Blocks in the heap are garbage-collected, and therefore have strict structure constraints. Each block includes a header containing the size of the block (in words), and the tag of the block. The tag governs how the contents of the blocks are structured. A tag lower than No_scan_tag indicates a structured block, containing well-formed values, which is recursively traversed by the garbage collector. A tag greater than or equal to No_scan_tag indicates a raw block, whose contents are not scanned by the garbage collector. For the benefit of ad-hoc polymorphic primitives such as equality and structured input-output, structured and raw blocks are further classified according to their tags as follows:</source>
          <target state="translated">힙의 블록은 가비지 수집되므로 엄격한 구조 제약이 있습니다. 각 블록에는 블록의 크기 (단어)와 블록의 태그가 포함 된 헤더가 포함되어 있습니다. 태그는 블록의 내용이 구성되는 방식을 제어합니다. No_scan_tag보다 낮은 태그는 잘 구성된 값을 포함하는 구조화 된 블록을 나타내며 가비지 수집기에 의해 재귀 적으로 통과됩니다. No_scan_tag보다 크거나 같은 태그는 가비지 수집기가 콘텐츠를 검색하지 않는 원시 블록을 나타냅니다. 동등성 및 구조화 된 입출력과 같은 임시 다형성 프리미티브의 이점을 위해 구조화 된 블록과 원시 블록은 태그에 따라 다음과 같이 추가로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="d52377d4f36f405cfd1e7a45f168ae549d215d39" translate="yes" xml:space="preserve">
          <source>Blocks with tag Custom_tag contain both arbitrary user data and a pointer to a C struct, with type struct custom_operations, that associates user-provided finalization, comparison, hashing, serialization and deserialization functions to this block.</source>
          <target state="translated">Custom_tag 태그가있는 블록에는 사용자가 제공 한 종료, 비교, 해싱, 직렬화 및 역 직렬화 기능을이 블록에 연결하는 struct custom_operations 유형의 C 구조체에 대한 포인터와 임의의 사용자 데이터가 모두 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f8c46ad79d1dd84b74158fed8d17c80696f45ae5" translate="yes" xml:space="preserve">
          <source>Blocks with tag Custom_tag.</source>
          <target state="translated">Custom_tag 태그가있는 블록.</target>
        </trans-unit>
        <trans-unit id="c12647fc73d7d1c9966497cc2c05ac43b902e3a4" translate="yes" xml:space="preserve">
          <source>Blocks with tag Double_tag.</source>
          <target state="translated">Double_tag 태그가있는 블록.</target>
        </trans-unit>
        <trans-unit id="7474968263988ef1fdd02a5d43ba5d0ef74d1f29" translate="yes" xml:space="preserve">
          <source>Blocks with tag String_tag.</source>
          <target state="translated">태그 String_tag가있는 블록.</target>
        </trans-unit>
        <trans-unit id="daf760a167a8047cee872015a8e80002f3b67442" translate="yes" xml:space="preserve">
          <source>Bool</source>
          <target state="translated">Bool</target>
        </trans-unit>
        <trans-unit id="72c318f119ab639d07f13e4bb5d9f5319d190b18" translate="yes" xml:space="preserve">
          <source>Bool_val(v) returns 0 if v is the OCaml boolean false, 1 if v is true.</source>
          <target state="translated">Bool_val (v)는 v가 OCaml 부울 거짓이면 0을 반환하고, v가 참이면 1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0ec6611901208bd78d162029849792816f5b2deb" translate="yes" xml:space="preserve">
          <source>Boolean conjunction.</source>
          <target state="translated">부울 접속.</target>
        </trans-unit>
        <trans-unit id="edfcfb577d5e30b5e6899078780ad10f83147239" translate="yes" xml:space="preserve">
          <source>Boolean disjunction.</source>
          <target state="translated">부울 분리.</target>
        </trans-unit>
        <trans-unit id="30d9ef559552bdd87313d89c8796d8136275e739" translate="yes" xml:space="preserve">
          <source>Boolean operations</source>
          <target state="translated">부울 연산</target>
        </trans-unit>
        <trans-unit id="e29add877007424818746892be55cde474c75bba" translate="yes" xml:space="preserve">
          <source>Boolean values.</source>
          <target state="translated">부울 값.</target>
        </trans-unit>
        <trans-unit id="0786cdff946e6084c50bb7df6cacd8ed965599fa" translate="yes" xml:space="preserve">
          <source>Booleans</source>
          <target state="translated">Booleans</target>
        </trans-unit>
        <trans-unit id="e117da47e3d7be3e9e0a3f82f9b8350253013973" translate="yes" xml:space="preserve">
          <source>Bound on floating garbage for out-of-heap memory held by custom values in the minor heap. A minor GC is triggered when this much memory is held by custom values located in the minor heap. Expressed as a percentage of minor heap size. Note: this only applies to values allocated with &lt;code&gt;caml_alloc_custom_mem&lt;/code&gt; (e.g. bigarrays). Default: 100.</source>
          <target state="translated">부 힙의 사용자 지정 값이 보유한 힙 부족 메모리에 대한 부동 가비지에 바인딩됩니다. 마이너 힙에있는 사용자 정의 값이이 정도의 메모리를 보유하면 마이너 GC가 트리거됩니다. 부 힙 크기의 백분율로 표시됩니다. 참고 : 이것은 &lt;code&gt;caml_alloc_custom_mem&lt;/code&gt; (예 : bigarrays)으로 할당 된 값에만 적용됩니다 . 기본값 : 100.</target>
        </trans-unit>
        <trans-unit id="08b716c0794dbc0057215ee2f154e80bba251c2e" translate="yes" xml:space="preserve">
          <source>Break hints</source>
          <target state="translated">휴식 힌트</target>
        </trans-unit>
        <trans-unit id="310549596be621bab70cac3b1e9df753e4f4a81d" translate="yes" xml:space="preserve">
          <source>Break hints are used to separate printing items and are mandatory to let the pretty-printer correctly split lines and indent items.</source>
          <target state="translated">구분 힌트는 인쇄 항목을 구분하는 데 사용되며 pretty-printer가 줄을 올바르게 분할하고 항목을 들여 쓰도록하는 데 필수입니다.</target>
        </trans-unit>
        <trans-unit id="c82e2d18efe99fcf7dc512f1f1e8d815a8811ce1" translate="yes" xml:space="preserve">
          <source>Break hints in a horizontal box never split the line. (Line splitting may still occur inside boxes nested deeper).</source>
          <target state="translated">가로 상자의 구분 힌트는 선을 분할하지 않습니다. (줄 분할은 더 깊게 중첩 된 상자 내에서 계속 발생할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="c7dfd8323fd5e72ce649953eb9bbb100abdbf328" translate="yes" xml:space="preserve">
          <source>Broken pipe</source>
          <target state="translated">깨진 파이프</target>
        </trans-unit>
        <trans-unit id="2be5f64b36230104ef9c6e230215846a83d18df6" translate="yes" xml:space="preserve">
          <source>Buffer</source>
          <target state="translated">Buffer</target>
        </trans-unit>
        <trans-unit id="a22edc1d8185e0421ca424eaf16cf9e2dafd3a13" translate="yes" xml:space="preserve">
          <source>Build a bytecode object file (.cmo file) and its associated compiled interface (.cmi) that combines the object files given on the command line, making them appear as sub-modules of the output .cmo file. The name of the output .cmo file must be given with the -o option. For instance,</source>
          <target state="translated">명령 줄에 제공된 개체 파일을 결합하여 출력 .cmo 파일의 하위 모듈로 표시되는 바이트 코드 개체 파일 (.cmo 파일) 및 관련 컴파일 된 인터페이스 (.cmi)를 빌드합니다. 출력 .cmo 파일의 이름은 -o 옵션과 함께 제공되어야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="8c491ef5b62f19f72f7c09ad96021606366a71f4" translate="yes" xml:space="preserve">
          <source>Build a custom runtime system (in the file specified by option -o) incorporating the C object files and libraries given on the command line. This custom runtime system can be used later to execute bytecode executables produced with the ocamlc -use-runtimeruntime-name option. See section &lt;a href=&quot;intfc#ss%3Acustom-runtime&quot;&gt;20.1.6&lt;/a&gt; for more information.</source>
          <target state="translated">명령 줄에 제공된 C 개체 파일 및 라이브러리를 통합하는 사용자 지정 런타임 시스템 (옵션 -o로 지정된 파일)을 빌드합니다. 이 사용자 지정 런타임 시스템은 나중에 ocamlc -use-runtimeruntime-name 옵션으로 생성 된 바이트 코드 실행 파일을 실행하는 데 사용할 수 있습니다. 자세한 내용은 섹션 &lt;a href=&quot;intfc#ss%3Acustom-runtime&quot;&gt;20.1.6&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="689a03030d28c2fe2318c8c8f9722c5b8054bdb7" translate="yes" xml:space="preserve">
          <source>Build a library(.cma file) with the object files ( .cmo files) given on the command line, instead of linking them into an executable file. The name of the library must be set with the -o option.</source>
          <target state="translated">실행 파일에 연결하는 대신 명령 줄에 제공된 개체 파일 (.cmo 파일)로 라이브러리 (.cma 파일)를 빌드합니다. 라이브러리 이름은 -o 옵션으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d3c6d896e003bfea1990e747dab4717403d4a43c" translate="yes" xml:space="preserve">
          <source>Build a library(.cmxa and .a/.lib files) with the object files (.cmx and .o/.obj files) given on the command line, instead of linking them into an executable file. The name of the library must be set with the -o option.</source>
          <target state="translated">실행 파일로 연결하는 대신 명령 줄에 제공된 개체 파일 (.cmx 및 .o / .obj 파일)로 라이브러리 (.cmxa 및 .a / .lib 파일)를 빌드합니다. 라이브러리 이름은 -o 옵션으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a7fc2d180dacf6e6dc88e07dfb99b1916ef75f25" translate="yes" xml:space="preserve">
          <source>Build a map from the given bindings</source>
          <target state="translated">주어진 바인딩에서지도를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7291990c98b91f383cf392959b02f1108bd054ae" translate="yes" xml:space="preserve">
          <source>Build a one-dimensional Bigarray initialized from the given array.</source>
          <target state="translated">주어진 배열에서 초기화 된 1 차원 Bigarray를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="18cd8e2d3ddf697fe8d31528763b8007962db336" translate="yes" xml:space="preserve">
          <source>Build a plugin (usually .cmxs) that can be dynamically loaded with the Dynlink module. The name of the plugin must be set with the -o option. A plugin can include a number of OCaml modules and libraries, and extra native objects (.o, .obj, .a, .lib files). Building native plugins is only supported for some operating system. Under some systems (currently, only Linux AMD 64), all the OCaml code linked in a plugin must have been compiled without the -nodynlink flag. Some constraints might also apply to the way the extra native objects have been compiled (under Linux AMD 64, they must contain only position-independent code).</source>
          <target state="translated">Dynlink 모듈로 동적으로로드 할 수있는 플러그인 (일반적으로 .cmxs)을 빌드합니다. 플러그인 이름은 -o 옵션으로 설정해야합니다. 플러그인에는 여러 OCaml 모듈 및 라이브러리와 추가 기본 개체 (.o, .obj, .a, .lib 파일)가 포함될 수 있습니다. 네이티브 플러그인 빌드는 일부 운영 체제에서만 지원됩니다. 일부 시스템 (현재는 Linux AMD 64 만 해당)에서 플러그인에 연결된 모든 OCaml 코드는 -nodynlink 플래그없이 컴파일되어야합니다. 일부 제약은 추가 네이티브 개체가 컴파일 된 방식에도 적용될 수 있습니다 (Linux AMD 64에서는 위치 독립적 인 코드 만 포함해야 함).</target>
        </trans-unit>
        <trans-unit id="069a1c0c668653aee76345e068c67b55843bbe6f" translate="yes" xml:space="preserve">
          <source>Build a self-contained executable by linking a C object file containing the bytecode program, the OCaml runtime system and any other static C code given to ocamlc. The resulting effect is similar to -custom, except that the bytecode is embedded in the C code so it is no longer accessible to tools such as ocamldebug. On the other hand, the resulting binary is resistant to strip.</source>
          <target state="translated">바이트 코드 프로그램, OCaml 런타임 시스템 및 ocamlc에 제공된 기타 정적 C 코드를 포함하는 C 개체 파일을 연결하여 자체 포함 된 실행 파일을 빌드합니다. 결과 효과는 바이트 코드가 C 코드에 포함되어 더 이상 ocamldebug와 같은 도구에 액세스 할 수 없다는 점을 제외하면 -custom과 유사합니다. 반면에 결과 바이너리는 스트립에 강합니다.</target>
        </trans-unit>
        <trans-unit id="12091461d26b4a9178ef9b7fb79d4ea74a7322de" translate="yes" xml:space="preserve">
          <source>Build a sequence from a step function and an initial value.</source>
          <target state="translated">단계 함수와 초기 값에서 시퀀스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="89302c14cbe821b3cc65efb42319c0731273420e" translate="yes" xml:space="preserve">
          <source>Build a sequence from a step function and an initial value. &lt;code&gt;unfold&amp;nbsp;f&amp;nbsp;u&lt;/code&gt; returns &lt;code&gt;empty&lt;/code&gt; if &lt;code&gt;f&amp;nbsp;u&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, or &lt;code&gt;fun&amp;nbsp;()&amp;nbsp;-&amp;gt;&amp;nbsp;Cons&amp;nbsp;(x,&amp;nbsp;unfold&amp;nbsp;f&amp;nbsp;y)&lt;/code&gt; if &lt;code&gt;f&amp;nbsp;u&lt;/code&gt; returns &lt;code&gt;Some&amp;nbsp;(x,&amp;nbsp;y)&lt;/code&gt;.</source>
          <target state="translated">단계 함수와 초기 값에서 시퀀스를 만듭니다. &lt;code&gt;unfold&amp;nbsp;f&amp;nbsp;u&lt;/code&gt; 는 &lt;code&gt;f&amp;nbsp;u&lt;/code&gt; 가 &lt;code&gt;None&lt;/code&gt; 을 반환 하면 &lt;code&gt;empty&lt;/code&gt; 를 반환하고 , &lt;code&gt;f&amp;nbsp;u&lt;/code&gt; 가 &lt;code&gt;Some&amp;nbsp;(x,&amp;nbsp;y)&lt;/code&gt; 반환 하면 &lt;code&gt;fun&amp;nbsp;()&amp;nbsp;-&amp;gt;&amp;nbsp;Cons&amp;nbsp;(x,&amp;nbsp;unfold&amp;nbsp;f&amp;nbsp;y)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="40f99ba2c885b0621a0361f7903d103f89a1bcdc" translate="yes" xml:space="preserve">
          <source>Build a set from the given bindings</source>
          <target state="translated">주어진 바인딩에서 세트 빌드</target>
        </trans-unit>
        <trans-unit id="7703cf54010e3d2a2a46e2aa34796e3417727340" translate="yes" xml:space="preserve">
          <source>Build a table from the given bindings.</source>
          <target state="translated">주어진 바인딩에서 테이블을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="bed507cdc786047af911f4641801d1284f48b787" translate="yes" xml:space="preserve">
          <source>Build a table from the given bindings. The bindings are added in the same order they appear in the sequence, using &lt;a href=&quot;hashtbl#VALreplace_seq&quot;&gt;&lt;code&gt;Hashtbl.replace_seq&lt;/code&gt;&lt;/a&gt;, which means that if two pairs have the same key, only the latest one will appear in the table.</source>
          <target state="translated">주어진 바인딩에서 테이블을 만듭니다. 바인딩은 &lt;a href=&quot;hashtbl#VALreplace_seq&quot;&gt; &lt;code&gt;Hashtbl.replace_seq&lt;/code&gt; 를&lt;/a&gt; 사용하여 시퀀스에 나타나는 것과 동일한 순서로 추가됩니다. 즉, 두 쌍이 동일한 키를 갖는 경우 최신 키만 테이블에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ef17975a5143add151e0e399318d7995c25ed2ae" translate="yes" xml:space="preserve">
          <source>Build a three-dimensional Bigarray initialized from the given array of arrays of arrays.</source>
          <target state="translated">주어진 배열 배열에서 초기화 된 3 차원 Bigarray를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="e21da3902ed80a10d9124a19e5502821d530b38d" translate="yes" xml:space="preserve">
          <source>Build a two-dimensional Bigarray initialized from the given array of arrays.</source>
          <target state="translated">주어진 배열 배열에서 초기화 된 2 차원 Bigarray를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="0baba8d3207ccbde756c21e219772188993d76ba" translate="yes" xml:space="preserve">
          <source>Build a zero-dimensional Bigarray initialized from the given value.</source>
          <target state="translated">주어진 값에서 초기화 된 0 차원 Bigarray를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="b1263e4d5769f672b1f15f28232e6f937c00bc59" translate="yes" xml:space="preserve">
          <source>Build an object file (.cmx and .o/.obj files) and its associated compiled interface (.cmi) that combines the .cmx object files given on the command line, making them appear as sub-modules of the output .cmx file. The name of the output .cmx file must be given with the -o option. For instance,</source>
          <target state="translated">명령 줄에 제공된 .cmx 개체 파일을 결합하여 출력 .cmx 파일의 하위 모듈로 표시되는 개체 파일 (.cmx 및 .o / .obj 파일) 및 관련 컴파일 된 인터페이스 (.cmi)를 빌드합니다. . 출력 .cmx 파일의 이름은 -o 옵션과 함께 제공되어야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="f2635951b3208897985aea8ec1147e0e9b763177" translate="yes" xml:space="preserve">
          <source>Builtins to reduce code size</source>
          <target state="translated">코드 크기를 줄이는 내장 기능</target>
        </trans-unit>
        <trans-unit id="c6160c6225b900be02bb14ce176681dae0c8f8da" translate="yes" xml:space="preserve">
          <source>Bus error</source>
          <target state="translated">버스 오류</target>
        </trans-unit>
        <trans-unit id="fe6c2475ca710215707c319b5b130842b36b44da" translate="yes" xml:space="preserve">
          <source>But beware that functions like ListLabels.fold_left whose result type is a type variable will never be considered as totally applied.</source>
          <target state="translated">그러나 결과 유형이 유형 변수 인 ListLabels.fold_left와 같은 함수는 완전히 적용된 것으로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d51ba5b49681459c1a354add2ac5d24ca30fd49" translate="yes" xml:space="preserve">
          <source>By applying the Set functor to a structure implementing an ordered type, we obtain set operations for this type:</source>
          <target state="translated">정렬 된 유형을 구현하는 구조에 Set 펑터를 적용하여이 유형에 대한 집합 연산을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="0113e077a12f76985e5f478d2a05438d5de8f770" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;parse&lt;/code&gt; recognizes two unit options, &lt;code&gt;-help&lt;/code&gt; and &lt;code&gt;--help&lt;/code&gt;, which will print to standard output &lt;code&gt;usage_msg&lt;/code&gt; and the list of options, and exit the program. You can override this behaviour by specifying your own &lt;code&gt;-help&lt;/code&gt; and &lt;code&gt;--help&lt;/code&gt; options in &lt;code&gt;speclist&lt;/code&gt;.</source>
          <target state="translated">기본적으로 &lt;code&gt;parse&lt;/code&gt; 는 표준 출력 &lt;code&gt;usage_msg&lt;/code&gt; 및 옵션 목록으로 인쇄 하고 프로그램을 종료하는 두 개의 단위 옵션 인 &lt;code&gt;-help&lt;/code&gt; 및 &lt;code&gt;--help&lt;/code&gt; 를 인식 합니다. &lt;code&gt;speclist&lt;/code&gt; 에서 고유 한 &lt;code&gt;-help&lt;/code&gt; 및 &lt;code&gt;--help&lt;/code&gt; 옵션을 지정하여이 동작을 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="67b1de1205669f7876e1c1fd966de8ff32344e89" translate="yes" xml:space="preserve">
          <source>By default, when ocamllex reaches the end of its lexing buffer, it will silently call the refill_buff function of lexbuf structure and continue lexing. It is sometimes useful to be able to take control of refilling action; typically, if you use a library for asynchronous computation, you may want to wrap the refilling action in a delaying function to avoid blocking synchronous operations.</source>
          <target state="translated">기본적으로 ocamllex가 렉싱 버퍼의 끝에 도달하면 lexbuf 구조의 refill_buff 함수를 자동으로 호출하고 렉싱을 계속합니다. 리필 작업을 제어 할 수있는 것이 때때로 유용합니다. 일반적으로 비동기 계산을 위해 라이브러리를 사용하는 경우 동기 작업 차단을 방지하기 위해 지연 함수에 다시 채우기 작업을 래핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bd008e3d3a06d94fef9fb0520a149f7342a3b92" translate="yes" xml:space="preserve">
          <source>By default:</source>
          <target state="translated">기본적으로:</target>
        </trans-unit>
        <trans-unit id="571d97b05671e800889e1f8be66af8e1839c41a3" translate="yes" xml:space="preserve">
          <source>By inspecting instrumentation output, the fuzzer finds the crashing input quickly.</source>
          <target state="translated">계측 출력을 검사하여 퍼 저는 충돌하는 입력을 빠르게 찾습니다.</target>
        </trans-unit>
        <trans-unit id="fdb1ab62b1d1a61cd2bf6abb826d55b2452baa20" translate="yes" xml:space="preserve">
          <source>Bypass the standard routing algorithms</source>
          <target state="translated">표준 라우팅 알고리즘 우회</target>
        </trans-unit>
        <trans-unit id="81a27c85cc78cf7082f8f4aa81367cc7aa73bbd6" translate="yes" xml:space="preserve">
          <source>Byte sequence operations.</source>
          <target state="translated">바이트 시퀀스 작업.</target>
        </trans-unit>
        <trans-unit id="1c3dcbe0c430e581c3ba7ac724f0f6e253c1162e" translate="yes" xml:space="preserve">
          <source>Byte sequences can be modified in place, for instance via the &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;blit&lt;/code&gt; functions described below. See also strings (module &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;), which are almost the same data structure, but cannot be modified in place.</source>
          <target state="translated">예를 들어 아래에 설명 된 &lt;code&gt;set&lt;/code&gt; 및 &lt;code&gt;blit&lt;/code&gt; 함수 를 통해 바이트 시퀀스를 제자리에서 수정할 수 있습니다 . 거의 동일한 데이터 구조이지만 제자리에서 수정할 수없는 문자열 (모듈 &lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; ) 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="adb4a16c1c179874a37042f14ee4006ef6638ed6" translate="yes" xml:space="preserve">
          <source>Byte(v, n) returns the n&lt;sup&gt;th&lt;/sup&gt; byte of the string or byte sequence v, with type char. Bytes are numbered from 0 to string_length(v)&amp;minus;1.</source>
          <target state="translated">Byte (v, n)은 char 유형을 사용하여 문자열 또는 바이트 시퀀스 v 의 n &lt;sup&gt;번째&lt;/sup&gt; 바이트를 반환합니다 . 바이트는 0에서 string_length (v) -1까지 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="e56c24ce60fe3442e00e45a21c6a40ce9981947b" translate="yes" xml:space="preserve">
          <source>Byte_u(v, n) returns the n&lt;sup&gt;th&lt;/sup&gt; byte of the string or byte sequence v, with type unsigned char. Bytes are numbered from 0 to string_length(v)&amp;minus;1.</source>
          <target state="translated">Byte_u (v, n)은 unsigned char 유형으로 문자열 의 n &lt;sup&gt;번째&lt;/sup&gt; 바이트 또는 바이트 시퀀스 v를 반환합니다 . 바이트는 0에서 string_length (v) -1까지 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="8e5fdab92dece79d7629d6d901687613ddc6ab5a" translate="yes" xml:space="preserve">
          <source>Bytes</source>
          <target state="translated">Bytes</target>
        </trans-unit>
        <trans-unit id="ee4b734d209787513981ac3c4587edcc9fd97576" translate="yes" xml:space="preserve">
          <source>Bytes are represented by the OCaml type &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">바이트는 OCaml 유형 &lt;code&gt;char&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7f1a4abc7d926b88b0ebb920ad333dc56ea8d84" translate="yes" xml:space="preserve">
          <source>BytesLabels</source>
          <target state="translated">BytesLabels</target>
        </trans-unit>
        <trans-unit id="f88d6f50d25613e6ba9716a6ec32d0fac19418c8" translate="yes" xml:space="preserve">
          <source>Bytes_val(v) returns a pointer to the first byte of the byte sequence v, with type unsigned char *.</source>
          <target state="translated">Bytes_val (v)는 unsigned char * 형식으로 바이트 시퀀스 v의 첫 번째 바이트에 대한 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="5cdbd402c1d7266786e985245bde0656f198525c" translate="yes" xml:space="preserve">
          <source>C expression</source>
          <target state="translated">C 표현</target>
        </trans-unit>
        <trans-unit id="c8e4b97f10fef4bff0c780402b8dd25cf8309940" translate="yes" xml:space="preserve">
          <source>C functions can apply OCaml function values (closures) to OCaml values. The following functions are provided to perform the applications:</source>
          <target state="translated">C 함수는 OCaml 함수 값 (클로저)을 OCaml 값에 적용 할 수 있습니다. 응용 프로그램을 수행하기 위해 다음 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="bc5854e4455891ebb06ded2070bbca910df9ff80" translate="yes" xml:space="preserve">
          <source>C object files (.o, .a, respectively, .obj, .lib) comprising the C part of the library;</source>
          <target state="translated">라이브러리의 C 부분을 포함하는 C 개체 파일 (각각 .o, .a, .obj, .lib)</target>
        </trans-unit>
        <trans-unit id="502ca6c945d9f8aee115c49e01f9edd12a50b0c8" translate="yes" xml:space="preserve">
          <source>C type</source>
          <target state="translated">C 유형</target>
        </trans-unit>
        <trans-unit id="5c2691a3da47675d7786da9056ed654e4329e370" translate="yes" xml:space="preserve">
          <source>C-c &amp;gt;</source>
          <target state="translated">참조&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d5895e3b6464a2f42c548ae3a42edfd0331e5913" translate="yes" xml:space="preserve">
          <source>C-c &amp;lt;</source>
          <target state="translated">참조 &amp;lt;</target>
        </trans-unit>
        <trans-unit id="63d94b505b28b164240bf9389a0b04f654a4efe7" translate="yes" xml:space="preserve">
          <source>C-c C-d</source>
          <target state="translated">C-c C-d</target>
        </trans-unit>
        <trans-unit id="7b336d22bd8ba7c961026c225d6dae53a99180fe" translate="yes" xml:space="preserve">
          <source>C-c C-f</source>
          <target state="translated">참조 참조</target>
        </trans-unit>
        <trans-unit id="e157811222162c64e14516608ab7ec113770f6cc" translate="yes" xml:space="preserve">
          <source>C-c C-k</source>
          <target state="translated">C-c C-k</target>
        </trans-unit>
        <trans-unit id="35aab979b96b2084fb79f26513be2807d179fa9d" translate="yes" xml:space="preserve">
          <source>C-c C-l</source>
          <target state="translated">C-c C-l</target>
        </trans-unit>
        <trans-unit id="703476705fbc5c81f1fcd2e97899e90376b8bb77" translate="yes" xml:space="preserve">
          <source>C-c C-n</source>
          <target state="translated">C-c C-n</target>
        </trans-unit>
        <trans-unit id="b6b8a659d5ecf6f6de2e42c686ddf4655002e381" translate="yes" xml:space="preserve">
          <source>C-c C-p</source>
          <target state="translated">C-c C-p</target>
        </trans-unit>
        <trans-unit id="35a5eefc071272ad5677c99c4db64e5fe4dc5d2d" translate="yes" xml:space="preserve">
          <source>C-c C-r</source>
          <target state="translated">참조 Cr</target>
        </trans-unit>
        <trans-unit id="b1d45f9433ffa51171e234792f3e833fd92a28ea" translate="yes" xml:space="preserve">
          <source>C-c C-s</source>
          <target state="translated">참조 Cs</target>
        </trans-unit>
        <trans-unit id="5a7afd726a50bc021ba933c58863ceeb5085e993" translate="yes" xml:space="preserve">
          <source>C-c C-t</source>
          <target state="translated">C-c C-t</target>
        </trans-unit>
        <trans-unit id="51f8ced1b6f72805535bc35bcfb934e6a1af5d91" translate="yes" xml:space="preserve">
          <source>C-c C-v</source>
          <target state="translated">C-c C-v</target>
        </trans-unit>
        <trans-unit id="a7600b59263607e2e35bc0920247fd20391c74a2" translate="yes" xml:space="preserve">
          <source>C-x C-a C-b</source>
          <target state="translated">C-x C-a C-b</target>
        </trans-unit>
        <trans-unit id="bb5cfbe7597b16e6935dc781b66c74990211b37b" translate="yes" xml:space="preserve">
          <source>C-x C-a C-d</source>
          <target state="translated">C-x C-a C-d</target>
        </trans-unit>
        <trans-unit id="cb356c30fbc883e430534abb90e0f8ff779ffa95" translate="yes" xml:space="preserve">
          <source>C-x C-a C-p</source>
          <target state="translated">C-x C-a C-p</target>
        </trans-unit>
        <trans-unit id="0428d8d3b172e413bd41a84ee63c3aa76341d6f4" translate="yes" xml:space="preserve">
          <source>CAMLRUNPARAM</source>
          <target state="translated">CAMLRUNPARAM</target>
        </trans-unit>
        <trans-unit id="06ef60af17229bb84ed6cf51b34ad6a256455e79" translate="yes" xml:space="preserve">
          <source>CAML_BA_CAML_INT</source>
          <target state="translated">CAML_BA_CAML_INT</target>
        </trans-unit>
        <trans-unit id="29bf970ee1f3dcd0c4d491bf35cc1f3f5d511fb6" translate="yes" xml:space="preserve">
          <source>CAML_BA_FLOAT32</source>
          <target state="translated">CAML_BA_FLOAT32</target>
        </trans-unit>
        <trans-unit id="b0b45028fc165a76fdf7ef3c4b9544abf779f48e" translate="yes" xml:space="preserve">
          <source>CAML_BA_FLOAT64</source>
          <target state="translated">CAML_BA_FLOAT64</target>
        </trans-unit>
        <trans-unit id="c0a392f0c20d6938ed691222ff33a9ed03be26ee" translate="yes" xml:space="preserve">
          <source>CAML_BA_INT32</source>
          <target state="translated">CAML_BA_INT32</target>
        </trans-unit>
        <trans-unit id="28d3388f7484b35006ab4e33d099e8b1394d2ada" translate="yes" xml:space="preserve">
          <source>CAML_BA_INT64</source>
          <target state="translated">CAML_BA_INT64</target>
        </trans-unit>
        <trans-unit id="4ae0dcc3f1cb59220d53e50caf55af1eec638efe" translate="yes" xml:space="preserve">
          <source>CAML_BA_NATIVE_INT</source>
          <target state="translated">CAML_BA_NATIVE_INT</target>
        </trans-unit>
        <trans-unit id="12d8a9c4f45f9611251c206d7770c086b489bd77" translate="yes" xml:space="preserve">
          <source>CAML_BA_SINT16</source>
          <target state="translated">CAML_BA_SINT16</target>
        </trans-unit>
        <trans-unit id="4f8b28cf737d73c2546166e229b3ed6d00a4ec46" translate="yes" xml:space="preserve">
          <source>CAML_BA_SINT8</source>
          <target state="translated">CAML_BA_SINT8</target>
        </trans-unit>
        <trans-unit id="42c72be3c2d002cde18ad0cc888645508241b618" translate="yes" xml:space="preserve">
          <source>CAML_BA_UINT16</source>
          <target state="translated">CAML_BA_UINT16</target>
        </trans-unit>
        <trans-unit id="0b4fdfc80a15bdaea2467c74579a11c08063d303" translate="yes" xml:space="preserve">
          <source>CAML_BA_UINT8</source>
          <target state="translated">CAML_BA_UINT8</target>
        </trans-unit>
        <trans-unit id="862e38c8fdffac6697987f398fd840cb4757c5c6" translate="yes" xml:space="preserve">
          <source>CAML_LD_LIBRARY_PATH</source>
          <target state="translated">CAML_LD_LIBRARY_PATH</target>
        </trans-unit>
        <trans-unit id="1efcd7218656916b1a34ec7ace30f76879ccc769" translate="yes" xml:space="preserve">
          <source>Call site</source>
          <target state="translated">전화 사이트</target>
        </trans-unit>
        <trans-unit id="439ff774888e42456ac505657951f952d4018c9c" translate="yes" xml:space="preserve">
          <source>Call the function with a bool argument</source>
          <target state="translated">bool 인수를 사용하여 함수 호출</target>
        </trans-unit>
        <trans-unit id="b54d32e84799e629832cc3cf6d3d70a7415a5e3d" translate="yes" xml:space="preserve">
          <source>Call the function with a float argument</source>
          <target state="translated">float 인수를 사용하여 함수 호출</target>
        </trans-unit>
        <trans-unit id="1194b8c4e54a903611beb2fc6666d747a1e0e365" translate="yes" xml:space="preserve">
          <source>Call the function with a string argument</source>
          <target state="translated">문자열 인수를 사용하여 함수 호출</target>
        </trans-unit>
        <trans-unit id="1362db1cb4c46430a08897ce0bd10b0e6ea8a20d" translate="yes" xml:space="preserve">
          <source>Call the function with an int argument</source>
          <target state="translated">int 인수를 사용하여 함수 호출</target>
        </trans-unit>
        <trans-unit id="d5b1b5aaabaa5c8dc3fa786515c78609ee362d34" translate="yes" xml:space="preserve">
          <source>Call the function with unit argument</source>
          <target state="translated">단위 인수로 함수 호출</target>
        </trans-unit>
        <trans-unit id="42fb639b7313463881ed7d9bae34cc709237f03b" translate="yes" xml:space="preserve">
          <source>Callback</source>
          <target state="translated">Callback</target>
        </trans-unit>
        <trans-unit id="5e3acd60f1a3a903622de6021e3383b98e3f2383" translate="yes" xml:space="preserve">
          <source>Callbacks from C to OCaml are possible only if the calling thread is known to the OCaml run-time system. Threads created from OCaml (through the Thread.create function of the system threads library) are automatically known to the run-time system. If the application creates additional threads from C and wishes to callback into OCaml code from these threads, it must first register them with the run-time system. The following functions are declared in the include file &amp;lt;caml/threads.h&amp;gt;.</source>
          <target state="translated">C에서 OCaml 로의 콜백은 호출 스레드가 OCaml 런타임 시스템에 알려진 경우에만 가능합니다. OCaml에서 생성 된 스레드 (시스템 스레드 라이브러리의 Thread.create 함수를 통해)는 런타임 시스템에 자동으로 알려집니다. 애플리케이션이 C에서 추가 스레드를 생성하고 이러한 스레드에서 OCaml 코드로 콜백하려는 경우 먼저 런타임 시스템에 해당 스레드를 등록해야합니다. 다음 함수는 포함 파일 &amp;lt;caml / threads.h&amp;gt;에 선언되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e6bc26cd9de8a0ee5e063309082a78314bbdfd7" translate="yes" xml:space="preserve">
          <source>Callbacks from C to OCaml must be performed while holding the master lock to the OCaml run-time system. This is naturally the case if the callback is performed by a C primitive that did not release the run-time system. If the C primitive released the run-time system previously, or the callback is performed from other C code that was not invoked from OCaml (e.g. an event loop in a GUI application), the run-time system must be acquired before the callback and released after:</source>
          <target state="translated">C에서 OCaml 로의 콜백은 OCaml 런타임 시스템에 대한 마스터 잠금을 유지하는 동안 수행되어야합니다. 런타임 시스템을 해제하지 않은 C 프리미티브에 의해 콜백이 수행되는 경우는 당연히 그렇습니다. C 프리미티브가 이전에 런타임 시스템을 릴리스했거나 OCaml에서 호출되지 않은 다른 C 코드 (예 : GUI 애플리케이션의 이벤트 루프)에서 콜백이 수행 된 경우, 런타임 시스템은 콜백 전에 획득해야합니다. 이후 출시 :</target>
        </trans-unit>
        <trans-unit id="0f420b0e05a7d24397a2c4cbac41b11132d82dc0" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;Thread.exit&lt;/code&gt; in a callback is currently unsafe and can result in undefined behavior.</source>
          <target state="translated">콜백에서 &lt;code&gt;Thread.exit&lt;/code&gt; 를 호출 하는 것은 현재 안전하지 않으며 정의되지 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee8b6fad857d73ca89a28b745d68e7d25285cbc2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;stop&lt;/code&gt; when a callback is running can lead to callbacks not being called even though some events happened.</source>
          <target state="translated">콜백이 실행 중일 때 &lt;code&gt;stop&lt;/code&gt; 을 호출 하면 일부 이벤트가 발생하더라도 콜백이 호출되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88d0bd91811ae57feae3dc49557f93b46fb40091" translate="yes" xml:space="preserve">
          <source>Calling ocamlcp or ocamloptp without the -P option defaults to -P fm, meaning that only function calls and pattern matching are profiled.</source>
          <target state="translated">-P 옵션없이 ocamlcp 또는 ocamloptp를 호출하면 기본값은 -P fm이며, 이는 함수 호출 및 패턴 일치 만 프로파일 링됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c76f4f235bcaa15b4e9e55e904d12a0353c6937f" translate="yes" xml:space="preserve">
          <source>Calling of finalization functions</source>
          <target state="translated">종료 함수 호출</target>
        </trans-unit>
        <trans-unit id="320ce4f3dd86e7b41979fa738908cf8ebc9f4093" translate="yes" xml:space="preserve">
          <source>Caml_ba_array_val(v)-&amp;gt;dim[i]</source>
          <target state="translated">Caml_ba_array_val(v)-&amp;gt;dim[i]</target>
        </trans-unit>
        <trans-unit id="4965db9dfe36a2388ff16d79621b65a90fdc3268" translate="yes" xml:space="preserve">
          <source>Caml_ba_array_val(v)-&amp;gt;flags &amp;amp; BIGARRAY_KIND_MASK</source>
          <target state="translated">Caml_ba_array_val (v)-&amp;gt; 플래그 &amp;amp; BIGARRAY_KIND_MASK</target>
        </trans-unit>
        <trans-unit id="a8153f9a1f29a01a8d1e13a9a8facbe074e41d60" translate="yes" xml:space="preserve">
          <source>Caml_ba_array_val(v)-&amp;gt;num_dims</source>
          <target state="translated">Caml_ba_array_val(v)-&amp;gt;num_dims</target>
        </trans-unit>
        <trans-unit id="b0826ae23f5c2aa6ec97d420d36156941be754c2" translate="yes" xml:space="preserve">
          <source>CamlinternalFormat</source>
          <target state="translated">CamlinternalFormat</target>
        </trans-unit>
        <trans-unit id="bb3e916c18c2e6c422542bf46f49c0d62f6e3c8f" translate="yes" xml:space="preserve">
          <source>CamlinternalFormatBasics</source>
          <target state="translated">CamlinternalFormatBasics</target>
        </trans-unit>
        <trans-unit id="481a5bc3eb5c42fe3b8d720d5e80798ff2509a6f" translate="yes" xml:space="preserve">
          <source>CamlinternalLazy</source>
          <target state="translated">CamlinternalLazy</target>
        </trans-unit>
        <trans-unit id="c3c09679073e3d5fb5469d0ee68e0dda2efb23c6" translate="yes" xml:space="preserve">
          <source>CamlinternalMod</source>
          <target state="translated">CamlinternalMod</target>
        </trans-unit>
        <trans-unit id="de3a6cdf4fe88074a43fdcad59d0f8af4cd7f6fd" translate="yes" xml:space="preserve">
          <source>CamlinternalOO</source>
          <target state="translated">CamlinternalOO</target>
        </trans-unit>
        <trans-unit id="d4281385821580139685e13cccf01eef5faad5fd" translate="yes" xml:space="preserve">
          <source>Can't assign requested address</source>
          <target state="translated">요청한 주소를 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b11fa6f27d953791f239e466488fe3cc3dab71f" translate="yes" xml:space="preserve">
          <source>Can't send after socket shutdown</source>
          <target state="translated">소켓 종료 후 보낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fa179cda87a1dfd4a3c00c1a3a16ee3fa6ec361b" translate="yes" xml:space="preserve">
          <source>Cannot exec ocamlrun</source>
          <target state="translated">ocamlrun을 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c76131d25b0f2f61dc3ec32dd51584863650417b" translate="yes" xml:space="preserve">
          <source>Cannot find file filename</source>
          <target state="translated">파일 이름을 찾을수 없습니다</target>
        </trans-unit>
        <trans-unit id="6e970cebe7ef506f91128a59d1bb09ee8b8b3c86" translate="yes" xml:space="preserve">
          <source>Cannot find the bytecode file</source>
          <target state="translated">바이트 코드 파일을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="20838d73bbc97dc3bb06bd228fc74b46a7848212" translate="yes" xml:space="preserve">
          <source>Canonical host name</source>
          <target state="translated">정식 호스트 이름</target>
        </trans-unit>
        <trans-unit id="2176321ef1668ac2925aa2334216301b069265ea" translate="yes" xml:space="preserve">
          <source>Case of first letter</source>
          <target state="translated">첫 글자의 경우</target>
        </trans-unit>
        <trans-unit id="152c573fc4d3829f2755ceb071de4e226c7a2b55" translate="yes" xml:space="preserve">
          <source>Cases with such a toplevel pattern are called &amp;ldquo;exception cases&amp;rdquo;, as opposed to regular &amp;ldquo;value cases&amp;rdquo;. Exception cases are applied when the evaluation of the matched expression raises an exception. The exception value is then matched against all the exception cases and re-raised if none of them accept the exception (as with a try...with block). Since the bodies of all exception and value cases are outside the scope of the exception handler, they are all considered to be in tail-position: if the match...with block itself is in tail position in the current function, any function call in tail position in one of the case bodies results in an actual tail call.</source>
          <target state="translated">이러한 최상위 패턴이있는 케이스를 일반 &quot;가치 케이스&quot;와 달리 &quot;예외 케이스&quot;라고합니다. 일치하는 표현식의 평가에서 예외가 발생하면 예외 케이스가 적용됩니다. 그런 다음 예외 값은 모든 예외 사례와 일치하고 예외를 수락하지 않는 경우 다시 발생합니다 (try ... with 블록과 같이). 모든 예외 및 값 사례의 본문은 예외 처리기의 범위를 벗어나므로 모두 꼬리 위치에있는 것으로 간주됩니다. match ... with 블록 자체가 현재 함수의 꼬리 위치에있는 경우 모든 함수 호출 케이스 본문 중 하나의 꼬리 위치에서 실제 꼬리 호출이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a7bfa68b59ae09ff7937d27d80909654e0911df3" translate="yes" xml:space="preserve">
          <source>Catenate two lists.</source>
          <target state="translated">두 개의 목록을 분류하십시오.</target>
        </trans-unit>
        <trans-unit id="bf6d1257bb5471d1a26f3650edf26a9b7ce4748e" translate="yes" xml:space="preserve">
          <source>Catenate two lists. Same function as the infix operator &lt;code&gt;@&lt;/code&gt;. Not tail-recursive (length of the first argument). The &lt;code&gt;@&lt;/code&gt; operator is not tail-recursive either.</source>
          <target state="translated">두 개의 목록을 분류하십시오. 중위 연산자 &lt;code&gt;@&lt;/code&gt; 와 동일한 기능 입니다. 꼬리 재귀가 아닙니다 (첫 번째 인수의 길이). &lt;code&gt;@&lt;/code&gt; 의 연산자 중 하나를 꼬리 재귀되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3927eac7c0bbd9cb2a05b8b9b1bc048f32eed24a" translate="yes" xml:space="preserve">
          <source>Cause ocamldep to call the given command as a preprocessor for each source file.</source>
          <target state="translated">ocamldep가 각 소스 파일의 전처리기로 주어진 명령을 호출하도록합니다.</target>
        </trans-unit>
        <trans-unit id="66d65060239114c8da1c3ee5f06497c9c0388478" translate="yes" xml:space="preserve">
          <source>Cause the compiler to call the given command as a preprocessor for each source file. The output of command is redirected to an intermediate file, which is compiled. If there are no compilation errors, the intermediate file is deleted afterwards.</source>
          <target state="translated">컴파일러가 각 소스 파일에 대한 전처리기로 주어진 명령을 호출하도록합니다. 명령의 출력은 컴파일 된 중간 파일로 리디렉션됩니다. 컴파일 오류가 없으면 중간 파일은 나중에 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="a9ad0bc61108fd0f03730d7b8c62d48c4504661e" translate="yes" xml:space="preserve">
          <source>Cause the compiler to print all defined names (with their inferred types or their definitions) when compiling an implementation (.ml file). No compiled files (.cmo and .cmi files) are produced. This can be useful to check the types inferred by the compiler. Also, since the output follows the syntax of interfaces, it can help in writing an explicit interface (.mli file) for a file: just redirect the standard output of the compiler to a .mli file, and edit that file to remove all declarations of unexported names.</source>
          <target state="translated">컴파일러가 구현 (.ml 파일)을 컴파일 할 때 정의 된 모든 이름 (추론 된 유형 또는 정의 포함)을 인쇄하도록합니다. 컴파일 된 파일 (.cmo 및 .cmi 파일)이 생성되지 않습니다. 이것은 컴파일러가 유추 한 유형을 확인하는 데 유용 할 수 있습니다. 또한 출력이 인터페이스 구문을 따르기 때문에 파일에 대한 명시 적 인터페이스 (.mli 파일)를 작성하는 데 도움이 될 수 있습니다. 컴파일러의 표준 출력을 .mli 파일로 리디렉션하고 해당 파일을 편집하여 모든 선언을 제거하기 만하면됩니다. 수출되지 않은 이름의.</target>
        </trans-unit>
        <trans-unit id="c6e7e3cc29834386322cdfd94e38c57364643191" translate="yes" xml:space="preserve">
          <source>Cause the linker to produce a C object file instead of a bytecode executable file. This is useful to wrap OCaml code as a C library, callable from any C program. See chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;, section &lt;a href=&quot;intfc#ss%3Ac-embedded-code&quot;&gt;20.7.5&lt;/a&gt;. The name of the output object file must be set with the -o option. This option can also be used to produce a C source file (.c extension) or a compiled shared/dynamic library (.so extension, .dll under Windows).</source>
          <target state="translated">링커가 바이트 코드 실행 파일 대신 C 개체 파일을 생성하도록합니다. 이것은 OCaml 코드를 모든 C 프로그램에서 호출 할 수있는 C 라이브러리로 래핑하는 데 유용합니다. &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt; 장 , &lt;a href=&quot;intfc#ss%3Ac-embedded-code&quot;&gt;20.7.5&lt;/a&gt; 절을 참조하십시오 . 출력 개체 파일의 이름은 -o 옵션으로 설정해야합니다. 이 옵션은 C 소스 파일 (.c 확장자) 또는 컴파일 된 공유 / 동적 라이브러리 (.so 확장자, Windows에서는 .dll)를 생성하는데도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f2d52792e36f929afa45992d5b9371329947d44" translate="yes" xml:space="preserve">
          <source>Cause the linker to produce a C object file instead of an executable file. This is useful to wrap OCaml code as a C library, callable from any C program. See chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;, section &lt;a href=&quot;intfc#ss%3Ac-embedded-code&quot;&gt;20.7.5&lt;/a&gt;. The name of the output object file must be set with the -o option. This option can also be used to produce a compiled shared/dynamic library (.so extension, .dll under Windows).</source>
          <target state="translated">링커가 실행 파일 대신 C 개체 파일을 생성하도록합니다. 이것은 OCaml 코드를 모든 C 프로그램에서 호출 할 수있는 C 라이브러리로 래핑하는 데 유용합니다. &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt; 장 , &lt;a href=&quot;intfc#ss%3Ac-embedded-code&quot;&gt;20.7.5&lt;/a&gt; 절을 참조하십시오 . 출력 개체 파일의 이름은 -o 옵션으로 설정해야합니다. 이 옵션을 사용하여 컴파일 된 공유 / 동적 라이브러리 (.so 확장자, Windows에서는 .dll)를 생성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b850e3fb0d5b46820871c2935dfe3766bdbb938d" translate="yes" xml:space="preserve">
          <source>Change of GC parameters.</source>
          <target state="translated">GC 매개 변수 변경.</target>
        </trans-unit>
        <trans-unit id="85ddb2f3053e5e3a61aa51801cc581d3f377f0ca" translate="yes" xml:space="preserve">
          <source>Change the current working directory of the process.</source>
          <target state="translated">프로세스의 현재 작업 디렉토리를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="0a59a356a5fb89b1c7225a986140a24f071468d3" translate="yes" xml:space="preserve">
          <source>Change the current working directory.</source>
          <target state="translated">현재 작업 디렉토리를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="1fc8ee486e678a2b93da90c36026c5c882c13c46" translate="yes" xml:space="preserve">
          <source>Change the owner uid and owner gid of an opened file.</source>
          <target state="translated">열린 파일의 소유자 uid 및 소유자 gid를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="7ff1b3a39f21500ee841c3b355ca9394dab29e7f" translate="yes" xml:space="preserve">
          <source>Change the owner uid and owner gid of an opened file. On Windows: not implemented (make no sense on a DOS file system).</source>
          <target state="translated">열린 파일의 소유자 uid 및 소유자 gid를 변경하십시오. Windows : 구현되지 않음 (DOS 파일 시스템에서는 의미가 없음).</target>
        </trans-unit>
        <trans-unit id="0c6826ef95971c6bcc713d9272d2f3957ce4e077" translate="yes" xml:space="preserve">
          <source>Change the owner uid and owner gid of the named file.</source>
          <target state="translated">명명 된 파일의 소유자 uid 및 소유자 gid를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="eff00fe5b2a8e18dd9ab37b5013d51ebb074f663" translate="yes" xml:space="preserve">
          <source>Change the owner uid and owner gid of the named file. On Windows: not implemented (make no sense on a DOS file system).</source>
          <target state="translated">명명 된 파일의 소유자 uid 및 소유자 gid를 변경하십시오. Windows : 구현되지 않음 (DOS 파일 시스템에서는 의미가 없음).</target>
        </trans-unit>
        <trans-unit id="bed0198ddea8ebff0f55e60936d9d3744ed76277" translate="yes" xml:space="preserve">
          <source>Change the permissions of an opened file.</source>
          <target state="translated">열린 파일의 권한을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="be2f04cee52320988b31c4157241e0ae0e8b9395" translate="yes" xml:space="preserve">
          <source>Change the permissions of an opened file. On Windows: not implemented.</source>
          <target state="translated">열린 파일의 권한을 변경합니다. Windows : 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="3dfd116dac46b84058c527a10dea8d7eb9d90f28" translate="yes" xml:space="preserve">
          <source>Change the permissions of the named file.</source>
          <target state="translated">명명 된 파일의 권한을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="059df7ed36823c0a5f15c733d667630994b09dfc" translate="yes" xml:space="preserve">
          <source>Change the process priority.</source>
          <target state="translated">프로세스 우선 순위를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="4af895b8fed10993d46dc76e555515a59117c378" translate="yes" xml:space="preserve">
          <source>Change the process priority. The integer argument is added to the ``nice'' value. (Higher values of the ``nice'' value mean lower priorities.) Return the new nice value.</source>
          <target state="translated">프로세스 우선 순위를 변경합니다. 정수 인수가``nice ''값에 추가됩니다. (``nice ''값이 높을수록 우선 순위가 낮습니다.) 새로운 nice 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="525fb07cd9a161e6eede24edf36a6f523c0304e8" translate="yes" xml:space="preserve">
          <source>Change the process root directory.</source>
          <target state="translated">프로세스 루트 디렉토리를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="0b7679db58768be2f4e8b5dcad79023cb2410bef" translate="yes" xml:space="preserve">
          <source>Change the process root directory. On Windows: not implemented.</source>
          <target state="translated">프로세스 루트 디렉토리를 변경하십시오. Windows : 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c22f0bfd902da519c120d02a47bbc28f988fe88b" translate="yes" xml:space="preserve">
          <source>Change the process working directory.</source>
          <target state="translated">프로세스 작업 디렉토리를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="f6247262a4ca64128524a7b46fe29e0adce2d3a4" translate="yes" xml:space="preserve">
          <source>Change the temporary directory returned by &lt;a href=&quot;filename#VALget_temp_dir_name&quot;&gt;&lt;code&gt;Filename.get_temp_dir_name&lt;/code&gt;&lt;/a&gt; and used by &lt;a href=&quot;filename#VALtemp_file&quot;&gt;&lt;code&gt;Filename.temp_file&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;filename#VALopen_temp_file&quot;&gt;&lt;code&gt;Filename.open_temp_file&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">임시 디렉토리에 의해 반환 변경 &lt;a href=&quot;filename#VALget_temp_dir_name&quot;&gt; &lt;code&gt;Filename.get_temp_dir_name&lt;/code&gt; &lt;/a&gt; 에 의해 사용 &lt;a href=&quot;filename#VALtemp_file&quot;&gt; &lt;code&gt;Filename.temp_file&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;filename#VALopen_temp_file&quot;&gt; &lt;code&gt;Filename.open_temp_file&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ed43f5a28f32e3c670541a45ef01f44121648f3" translate="yes" xml:space="preserve">
          <source>Chapter 1 The core language</source>
          <target state="translated">1 장 핵심 언어</target>
        </trans-unit>
        <trans-unit id="f0b85dee7429fe72c76a05950f827ee16db3524d" translate="yes" xml:space="preserve">
          <source>Chapter 10 The toplevel system or REPL (ocaml)</source>
          <target state="translated">10 장 최상위 시스템 또는 REPL (ocaml)</target>
        </trans-unit>
        <trans-unit id="001839bacc443f251cfd2c927f4f6758c410072e" translate="yes" xml:space="preserve">
          <source>Chapter 11 The runtime system (ocamlrun)</source>
          <target state="translated">11 장 런타임 시스템 (ocamlrun)</target>
        </trans-unit>
        <trans-unit id="410707e0a197616d24db0cf28623150b0fd9bbf1" translate="yes" xml:space="preserve">
          <source>Chapter 12 Native-code compilation (ocamlopt)</source>
          <target state="translated">12 장 네이티브 코드 컴파일 (ocamlopt)</target>
        </trans-unit>
        <trans-unit id="8a6c191b9a4d617a739da661e8ae774b6ea4bf3b" translate="yes" xml:space="preserve">
          <source>Chapter 13 Lexer and parser generators (ocamllex, ocamlyacc)</source>
          <target state="translated">13 장 렉서 및 파서 생성기 (ocamllex, ocamlyacc)</target>
        </trans-unit>
        <trans-unit id="43aac2b85afd5512793e5351074e2a49b841dd1f" translate="yes" xml:space="preserve">
          <source>Chapter 14 Dependency generator (ocamldep)</source>
          <target state="translated">14 장 종속성 생성기 (ocamldep)</target>
        </trans-unit>
        <trans-unit id="c3749109d031480d3bd81dbe0edd1a4e6240de1d" translate="yes" xml:space="preserve">
          <source>Chapter 15 The browser/editor (ocamlbrowser)</source>
          <target state="translated">15 장 브라우저 / 편집기 (ocamlbrowser)</target>
        </trans-unit>
        <trans-unit id="30a554141c94c8a595a0ef2d51b365bc92da3410" translate="yes" xml:space="preserve">
          <source>Chapter 16 The documentation generator (ocamldoc)</source>
          <target state="translated">16 장 문서 생성기 (ocamldoc)</target>
        </trans-unit>
        <trans-unit id="795917bcc2fe3d841a2020a62bda17476ffc5bab" translate="yes" xml:space="preserve">
          <source>Chapter 17 The debugger (ocamldebug)</source>
          <target state="translated">17 장 디버거 (ocamldebug)</target>
        </trans-unit>
        <trans-unit id="9798fdf8ebfc25a72ac812bc7bebb20f7bb87cf3" translate="yes" xml:space="preserve">
          <source>Chapter 18 Profiling (ocamlprof)</source>
          <target state="translated">18 장 프로파일 링 (ocamlprof)</target>
        </trans-unit>
        <trans-unit id="f5bc6351790005d4d54dd018de1ed7222e66ff92" translate="yes" xml:space="preserve">
          <source>Chapter 19 The ocamlbuild compilation manager</source>
          <target state="translated">19 장 ocamlbuild 컴파일 관리자</target>
        </trans-unit>
        <trans-unit id="c269d97f2761aea9b7eaea373eec2819293a83aa" translate="yes" xml:space="preserve">
          <source>Chapter 2 The module system</source>
          <target state="translated">2 장 모듈 시스템</target>
        </trans-unit>
        <trans-unit id="de06f01aba4e638c618d8a261f9859d128cb1e0d" translate="yes" xml:space="preserve">
          <source>Chapter 20 Interfacing C with OCaml</source>
          <target state="translated">20 장 OCaml과 C의 인터페이스</target>
        </trans-unit>
        <trans-unit id="076a91db60f3e8f0cac45b804159393c0f3106d6" translate="yes" xml:space="preserve">
          <source>Chapter 21 Optimisation with Flambda</source>
          <target state="translated">21 장 Flambda를 사용한 최적화</target>
        </trans-unit>
        <trans-unit id="d15de4a495e291c78283893fc4e762621d85a00d" translate="yes" xml:space="preserve">
          <source>Chapter 22 Memory profiling with Spacetime</source>
          <target state="translated">22 장 Spacetime을 사용한 메모리 프로파일 링</target>
        </trans-unit>
        <trans-unit id="f8cd41c063dcd4b4438b8dbdb483110eb38bd31d" translate="yes" xml:space="preserve">
          <source>Chapter 23 Fuzzing with afl-fuzz</source>
          <target state="translated">23 장 afl-fuzz로 퍼징하기</target>
        </trans-unit>
        <trans-unit id="a4a791f8f6f8c0d8a4ad00bed731a1667316e104" translate="yes" xml:space="preserve">
          <source>Chapter 24 Runtime tracing with the instrumented runtime</source>
          <target state="translated">24 장 계측 된 런타임을 사용한 런타임 추적</target>
        </trans-unit>
        <trans-unit id="dd5072f88a3e588aa13c91fd059d66f2d6f5ab85" translate="yes" xml:space="preserve">
          <source>Chapter 25 The core library</source>
          <target state="translated">25 장 핵심 라이브러리</target>
        </trans-unit>
        <trans-unit id="1d1e656bf488be3aeb94f939e1a3a6ce5c39307f" translate="yes" xml:space="preserve">
          <source>Chapter 26 The standard library</source>
          <target state="translated">26 장 표준 라이브러리</target>
        </trans-unit>
        <trans-unit id="2b882a43356571b7b90c97eef6ad2c38753586fc" translate="yes" xml:space="preserve">
          <source>Chapter 27 The compiler front-end</source>
          <target state="translated">27 장 컴파일러 프런트 엔드</target>
        </trans-unit>
        <trans-unit id="4d9b946afe127a69a4a6fd1e867c3901de646cce" translate="yes" xml:space="preserve">
          <source>Chapter 28 The unix library: Unix system calls</source>
          <target state="translated">28 장 유닉스 라이브러리 : 유닉스 시스템 호출</target>
        </trans-unit>
        <trans-unit id="43e77b1c65a3b715d2db33e651d357a448b28637" translate="yes" xml:space="preserve">
          <source>Chapter 29 The num library: arbitrary-precision rational arithmetic</source>
          <target state="translated">29 장 num 라이브러리 : 임의 정밀도의 합리적인 산술</target>
        </trans-unit>
        <trans-unit id="7e30811f338538f3c0d38f9d6d42248053bfbe1d" translate="yes" xml:space="preserve">
          <source>Chapter 3 Objects in OCaml</source>
          <target state="translated">3 장 OCaml의 객체</target>
        </trans-unit>
        <trans-unit id="b8a3a02a9cae42ecda284ccbe84e3c4056117fcd" translate="yes" xml:space="preserve">
          <source>Chapter 30 The str library: regular expressions and string processing</source>
          <target state="translated">30 장 str 라이브러리 : 정규식과 문자열 처리</target>
        </trans-unit>
        <trans-unit id="fa16c195ce280b138dd01abe2b38e59c60633da6" translate="yes" xml:space="preserve">
          <source>Chapter 31 The threads library</source>
          <target state="translated">31 장 스레드 라이브러리</target>
        </trans-unit>
        <trans-unit id="4fa73c279162cd152d0c19a54753ed4b092a6f44" translate="yes" xml:space="preserve">
          <source>Chapter 32 The graphics library</source>
          <target state="translated">32 장 그래픽 라이브러리</target>
        </trans-unit>
        <trans-unit id="7273034c7b0640dc1b3db6600c2ce523db39d3c4" translate="yes" xml:space="preserve">
          <source>Chapter 33 The dynlink library: dynamic loading and linking of object files</source>
          <target state="translated">33 장 dynlink 라이브러리 : 개체 파일의 동적로드 및 링크</target>
        </trans-unit>
        <trans-unit id="c45f56f7818d55915c239211feb596da3ef30b64" translate="yes" xml:space="preserve">
          <source>Chapter 34 The bigarray library</source>
          <target state="translated">34 장 bigarray 라이브러리</target>
        </trans-unit>
        <trans-unit id="2d169dd1a467fd491bd155eb638e1ccdc56f2688" translate="yes" xml:space="preserve">
          <source>Chapter 4 Labels and variants</source>
          <target state="translated">4 장 라벨 및 변형</target>
        </trans-unit>
        <trans-unit id="47acd2509ab08220cd88716a4d5adad74e851efa" translate="yes" xml:space="preserve">
          <source>Chapter 5 Polymorphism and its limitations</source>
          <target state="translated">5 장 다형성과 그 한계</target>
        </trans-unit>
        <trans-unit id="ea957655c2d829d612062883bdcdc3375bb972f9" translate="yes" xml:space="preserve">
          <source>Chapter 6 Advanced examples with classes and modules</source>
          <target state="translated">6 장 클래스 및 모듈을 사용한 고급 예제</target>
        </trans-unit>
        <trans-unit id="21be5d98e1e33b0bbdf4ea2e078c6d2b805d67b9" translate="yes" xml:space="preserve">
          <source>Chapter 7 The OCaml language</source>
          <target state="translated">7 장 OCaml 언어</target>
        </trans-unit>
        <trans-unit id="46ab86a56b7497600bb8e714a88e9abef74c7fa3" translate="yes" xml:space="preserve">
          <source>Chapter 8 Language extensions</source>
          <target state="translated">8 장 언어 확장</target>
        </trans-unit>
        <trans-unit id="391b169f6153a4b9d3a6bcce4a613a60664189dd" translate="yes" xml:space="preserve">
          <source>Chapter 9 Batch compilation (ocamlc)</source>
          <target state="translated">9 장 배치 컴파일 (ocamlc)</target>
        </trans-unit>
        <trans-unit id="0f9ba953e35135a3f8ec268817cc92f2557202a9" translate="yes" xml:space="preserve">
          <source>Char</source>
          <target state="translated">Char</target>
        </trans-unit>
        <trans-unit id="b2f83f280f0ba4673ff9b860af0167edcb7dc5eb" translate="yes" xml:space="preserve">
          <source>Character denoted</source>
          <target state="translated">표시되는 문자</target>
        </trans-unit>
        <trans-unit id="c11b0e685f81f6a610a7012ef3b9b40a0b7893d9" translate="yes" xml:space="preserve">
          <source>Character device</source>
          <target state="translated">캐릭터 장치</target>
        </trans-unit>
        <trans-unit id="9cda61e490d068bb818a82546143deb1856eba54" translate="yes" xml:space="preserve">
          <source>Character literals are delimited by ' (single quote) characters. The two single quotes enclose either one character different from ' and \, or one of the escape sequences below:</source>
          <target state="translated">문자 리터럴은 '(작은 따옴표) 문자로 구분됩니다. 두 개의 작은 따옴표는 '및 \와 다른 하나의 문자 또는 아래의 이스케이프 시퀀스 중 하나를 묶습니다.</target>
        </trans-unit>
        <trans-unit id="93d160e081a31096ac20a234dcd5857d1dd2c533" translate="yes" xml:space="preserve">
          <source>Character operations</source>
          <target state="translated">캐릭터 작업</target>
        </trans-unit>
        <trans-unit id="3ed87e23d6eb7a0d480742eab3f278ad3edc9072" translate="yes" xml:space="preserve">
          <source>Character operations.</source>
          <target state="translated">캐릭터 작업.</target>
        </trans-unit>
        <trans-unit id="7eb3c3d69869dc4d46c112661656a874dc159d9e" translate="yes" xml:space="preserve">
          <source>Character values are represented as 8-bit integers between 0 and 255. Character codes between 0 and 127 are interpreted following the ASCII standard. The current implementation interprets character codes between 128 and 255 following the ISO 8859-1 standard.</source>
          <target state="translated">문자 값은 0에서 255 사이의 8 비트 정수로 표시됩니다. 0에서 127 사이의 문자 코드는 ASCII 표준에 따라 해석됩니다. 현재 구현은 ISO 8859-1 표준에 따라 128에서 255 사이의 문자 코드를 해석합니다.</target>
        </trans-unit>
        <trans-unit id="b5c6a1aad15eafbbc861ff217eae35aa29ad75f6" translate="yes" xml:space="preserve">
          <source>Check if the formatter geometry is valid: &lt;code&gt;1&amp;nbsp;&amp;lt;&amp;nbsp;max_indent&amp;nbsp;&amp;lt;&amp;nbsp;margin&lt;/code&gt;</source>
          <target state="translated">포맷터 지오메트리가 유효한지 확인하십시오. &lt;code&gt;1&amp;nbsp;&amp;lt;&amp;nbsp;max_indent&amp;nbsp;&amp;lt;&amp;nbsp;margin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5cf0c2762d6bb5f500fd8d57ef70e961f0d11397" translate="yes" xml:space="preserve">
          <source>Check information path during type-checking, to make sure that all types are derived in a principal way. When using labelled arguments and/or polymorphic methods, this flag is required to ensure future versions of the compiler will be able to infer types correctly, even if internal algorithms change. All programs accepted in -principal mode are also accepted in the default mode with equivalent types, but different binary signatures, and this may slow down type checking; yet it is a good idea to use it once before publishing source code.</source>
          <target state="translated">유형 검사 중에 정보 경로를 확인하여 모든 유형이 주된 방식으로 파생되었는지 확인하십시오. 레이블이 지정된 인수 및 / 또는 다형성 메서드를 사용할 때 내부 알고리즘이 변경 되더라도 향후 버전의 컴파일러가 형식을 올바르게 추론 할 수 있도록하려면이 플래그가 필요합니다. -principal 모드에서 허용되는 모든 프로그램은 동일한 유형이지만 다른 이진 서명을 사용하는 기본 모드에서도 허용되며 이로 인해 유형 검사 속도가 느려질 수 있습니다. 그러나 소스 코드를 게시하기 전에 한 번 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e981f123821139261d30477b7436fc5a55b64f1b" translate="yes" xml:space="preserve">
          <source>Check that the generated bytecode executable can run on 32-bit platforms and signal an error if it cannot. This is useful when compiling bytecode on a 64-bit machine.</source>
          <target state="translated">생성 된 바이트 코드 실행 파일이 32 비트 플랫폼에서 실행될 수 있는지 확인하고 실행할 수없는 경우 오류 신호를 보냅니다. 이것은 64 비트 시스템에서 바이트 코드를 컴파일 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="605d9d3370c8fb91a9c430b3f8bc3429e0117aa7" translate="yes" xml:space="preserve">
          <source>Check that the process has the given permissions over the named file.</source>
          <target state="translated">프로세스가 명명 된 파일에 대해 주어진 권한을 가지고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="83dfb869c6a27841e790ad08cb50f233ca1f4045" translate="yes" xml:space="preserve">
          <source>Check that the process has the given permissions over the named file. Raise &lt;code&gt;Unix_error&lt;/code&gt; otherwise.</source>
          <target state="translated">프로세스가 명명 된 파일에 대해 주어진 권한을 가지고 있는지 확인하십시오. 올리 &lt;code&gt;Unix_error&lt;/code&gt; 에게 그렇지.</target>
        </trans-unit>
        <trans-unit id="e6097bb19d940e5685334990aa89b56295b3b220" translate="yes" xml:space="preserve">
          <source>Child process terminated</source>
          <target state="translated">하위 프로세스가 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="ceda17985ac6b3f5a4c93ac5d7c217a8d28d7bcb" translate="yes" xml:space="preserve">
          <source>Class application is denoted by juxtaposition of (possibly labeled) expressions. It denotes the class whose constructor is the first expression applied to the given arguments. The arguments are evaluated as for expression application, but the constructor itself will only be evaluated when objects are created. In particular, side-effects caused by the application of the constructor will only occur at object creation time.</source>
          <target state="translated">클래스 적용은 (라벨이 붙은) 표현의 병치로 표시됩니다. 생성자가 주어진 인수에 적용되는 첫 번째 표현식 인 클래스를 나타냅니다. 인수는 식 응용 프로그램과 같이 평가되지만 생성자 자체는 개체가 생성 될 때만 평가됩니다. 특히 생성자의 적용으로 인한 부작용은 객체 생성시에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8876b2e72d29d328da5ecb8760743ad996296c94" translate="yes" xml:space="preserve">
          <source>Class expressions are the class-level equivalent of value expressions: they evaluate to classes, thus providing implementations for the specifications expressed in class types.</source>
          <target state="translated">클래스 표현식은 값 표현식에 해당하는 클래스 수준입니다. 클래스로 평가되므로 클래스 유형으로 표현 된 사양에 대한 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="108c4260793c1e17098c25078141189b9f80ad27" translate="yes" xml:space="preserve">
          <source>Class interfaces are inferred from class definitions. They may also be defined directly and used to restrict the type of a class. Like class declarations, they also define a new type abbreviation.</source>
          <target state="translated">클래스 인터페이스는 클래스 정의에서 유추됩니다. 또한 직접 정의하여 클래스 유형을 제한하는 데 사용할 수도 있습니다. 클래스 선언과 마찬가지로 새 유형 약어도 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c857b3c0f35a1cf445f8db99a25973f3c3b2e890" translate="yes" xml:space="preserve">
          <source>Class specifications are described more precisely in section &lt;a href=&quot;classes#ss%3Aclass-spec&quot;&gt;7.9.4&lt;/a&gt;.</source>
          <target state="translated">클래스 사양은 섹션 &lt;a href=&quot;classes#ss%3Aclass-spec&quot;&gt;7.9.4에&lt;/a&gt; 더 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6cac64186cec5136028f17ddf4f650c957d03d5d" translate="yes" xml:space="preserve">
          <source>Class types are the class-level equivalent of type expressions: they specify the general shape and type properties of classes.</source>
          <target state="translated">클래스 유형은 유형 표현식에 해당하는 클래스 수준입니다. 클래스의 일반적인 모양과 유형 속성을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Classes</target>
        </trans-unit>
        <trans-unit id="47bea575c5d9baad367210dd15b04c4c182dce19" translate="yes" xml:space="preserve">
          <source>Classes are defined using a small language, similar to the module language.</source>
          <target state="translated">클래스는 모듈 언어와 유사한 작은 언어를 사용하여 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="8afd240a4acd3b80e8530e285fba9a2f238dc1dc" translate="yes" xml:space="preserve">
          <source>Classes window_observer and window_subject can still be extended by inheritance. For instance, one may enrich the subject with new behaviors and refine the behavior of the observer.</source>
          <target state="translated">window_observer 및 window_subject 클래스는 상속을 통해 계속 확장 할 수 있습니다. 예를 들어, 새로운 행동으로 주제를 풍부하게하고 관찰자의 행동을 개선 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a01eb9463326201b62bd18afc119f471a20a46d3" translate="yes" xml:space="preserve">
          <source>Clear the ``close-on-exec'' flag on the given descriptor.</source>
          <target state="translated">주어진 설명자에서``close-on-exec ''플래그를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="4bc43d79488f3b27bccafdf17c420f0d747526c8" translate="yes" xml:space="preserve">
          <source>Clear the ``close-on-exec'' flag on the given descriptor. See &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt;&lt;code&gt;Unix.set_close_on_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 설명자에서``close-on-exec ''플래그를 지 웁니다. &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt; &lt;code&gt;Unix.set_close_on_exec&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a59376799f540da74c603bc50f48227a56704df" translate="yes" xml:space="preserve">
          <source>Clear the ``close-on-exec'' flag on the given descriptor. See &lt;a href=&quot;unixlabels#VALset_close_on_exec&quot;&gt;&lt;code&gt;UnixLabels.set_close_on_exec&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 설명자에서``close-on-exec ''플래그를 지 웁니다. &lt;a href=&quot;unixlabels#VALset_close_on_exec&quot;&gt; &lt;code&gt;UnixLabels.set_close_on_exec&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d0843662a0ae553306f085b13e4737ae2561db27" translate="yes" xml:space="preserve">
          <source>Clear the ``non-blocking'' flag on the given descriptor.</source>
          <target state="translated">주어진 설명자에서``비 차단 ''플래그를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="fd1c73dfdb7d3867700cd7ea86d4dd6c48d8ee02" translate="yes" xml:space="preserve">
          <source>Clear the ``non-blocking'' flag on the given descriptor. See &lt;a href=&quot;unix#VALset_nonblock&quot;&gt;&lt;code&gt;Unix.set_nonblock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 설명자에서``비 차단 ''플래그를 지 웁니다. &lt;a href=&quot;unix#VALset_nonblock&quot;&gt; &lt;code&gt;Unix.set_nonblock&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23ed5871b75d708804ee3f41ea756675082150ec" translate="yes" xml:space="preserve">
          <source>Clear the ``non-blocking'' flag on the given descriptor. See &lt;a href=&quot;unixlabels#VALset_nonblock&quot;&gt;&lt;code&gt;UnixLabels.set_nonblock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 설명자에서``비 차단 ''플래그를 지 웁니다. &lt;a href=&quot;unixlabels#VALset_nonblock&quot;&gt; &lt;code&gt;UnixLabels.set_nonblock&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb4c990b5652dae59a6be6a792769aef18fde455" translate="yes" xml:space="preserve">
          <source>Clear the close-on-exec flag. This is currently the default.</source>
          <target state="translated">close-on-exec 플래그를 지 웁니다. 이것은 현재 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="bdb21a46e06b56087078be6b4aff4ce68b24daea" translate="yes" xml:space="preserve">
          <source>Cloning and override have a non empty intersection. They are interchangeable when used within an object and without overriding any field:</source>
          <target state="translated">복제 및 재정의에는 비어 있지 않은 교차점이 있습니다. 객체 내에서 사용될 때 필드를 재정의하지 않고 상호 교환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfbe69f4a604ebda49f0c8e440a558ccd8966474" translate="yes" xml:space="preserve">
          <source>Cloning can also be used to provide facilities for saving and restoring the state of objects.</source>
          <target state="translated">복제는 객체의 상태를 저장하고 복원하는 기능을 제공하는데도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="241b9beb2f7204a7ae1316941e73e2b9fa4afd0c" translate="yes" xml:space="preserve">
          <source>Close a directory descriptor.</source>
          <target state="translated">디렉토리 설명자를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="afd2c6b2e7b89772b6708c7aca8a6d5a888f5146" translate="yes" xml:space="preserve">
          <source>Close a file descriptor.</source>
          <target state="translated">파일 설명자를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="ab162827cb467aeef1cfdbabbced6f4ac7ae6731" translate="yes" xml:space="preserve">
          <source>Close both</source>
          <target state="translated">둘 다 닫기</target>
        </trans-unit>
        <trans-unit id="ca279507e900048762edd58a735705649ef1441a" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unix#VALopen_process&quot;&gt;&lt;code&gt;Unix.open_process&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process&quot;&gt; &lt;code&gt;Unix.open_process&lt;/code&gt; &lt;/a&gt; 에 의해 열린 채널을 닫고 관련 명령이 종료 될 때까지 기다린 다음 종료 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aa4ea9d16cdeb07884420e45a9b4a955b46da461" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unix#VALopen_process_full&quot;&gt;&lt;code&gt;Unix.open_process_full&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process_full&quot;&gt; &lt;code&gt;Unix.open_process_full&lt;/code&gt; &lt;/a&gt; 에 의해 열린 채널을 닫고 관련 명령이 종료 될 때까지 기다린 다음 종료 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd5848e9973d58846ccebfcc487fe6068111200e" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unix#VALopen_process_in&quot;&gt;&lt;code&gt;Unix.open_process_in&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process_in&quot;&gt; &lt;code&gt;Unix.open_process_in&lt;/code&gt; &lt;/a&gt; 에 의해 열린 채널을 닫고 관련 명령이 종료 될 때까지 기다린 다음 종료 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4a7c2328f3cb9873b3f974f2c82eac788b54581c" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unix#VALopen_process_out&quot;&gt;&lt;code&gt;Unix.open_process_out&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process_out&quot;&gt; &lt;code&gt;Unix.open_process_out&lt;/code&gt; &lt;/a&gt; 에 의해 열린 채널을 닫고 관련 명령이 종료 될 때까지 기다린 다음 종료 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="40dccb11bde36cc9d87578fff4b5574199a6f237" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unixlabels#VALopen_process&quot;&gt;&lt;code&gt;UnixLabels.open_process&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALopen_process&quot;&gt; &lt;code&gt;UnixLabels.open_process&lt;/code&gt; &lt;/a&gt; 에 의해 열린 채널을 닫고 관련 명령이 종료 될 때까지 기다린 다음 종료 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="104a97fe326dc92db83909431482619107f79d7f" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unixlabels#VALopen_process_full&quot;&gt;&lt;code&gt;UnixLabels.open_process_full&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALopen_process_full&quot;&gt; &lt;code&gt;UnixLabels.open_process_full&lt;/code&gt; &lt;/a&gt; 에 의해 열린 채널을 닫고 관련 명령이 종료 될 때까지 기다린 다음 종료 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc2ac483e1e28bbc2dae7a1dcbdb428a53ea65db" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unixlabels#VALopen_process_in&quot;&gt;&lt;code&gt;UnixLabels.open_process_in&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALopen_process_in&quot;&gt; &lt;code&gt;UnixLabels.open_process_in&lt;/code&gt; &lt;/a&gt; 에 의해 열린 채널을 닫고 관련 명령이 종료 될 때까지 기다린 다음 종료 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="987835cf216c09d3d3659c353042acf47eb82cb6" translate="yes" xml:space="preserve">
          <source>Close channels opened by &lt;a href=&quot;unixlabels#VALopen_process_out&quot;&gt;&lt;code&gt;UnixLabels.open_process_out&lt;/code&gt;&lt;/a&gt;, wait for the associated command to terminate, and return its termination status.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALopen_process_out&quot;&gt; &lt;code&gt;UnixLabels.open_process_out&lt;/code&gt; &lt;/a&gt; 에 의해 열린 채널을 닫고 관련 명령이 종료 될 때까지 기다린 다음 종료 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ea5708310a7ccde2ea99739644bf345de4466c25" translate="yes" xml:space="preserve">
          <source>Close for receiving</source>
          <target state="translated">수신 종료</target>
        </trans-unit>
        <trans-unit id="805fb7fdd53fdd68744184a36444efa2cf87c672" translate="yes" xml:space="preserve">
          <source>Close for sending</source>
          <target state="translated">보내기 닫기</target>
        </trans-unit>
        <trans-unit id="8b3f52183f139b54fa0f6f2fbb72a62dd79a1c1a" translate="yes" xml:space="preserve">
          <source>Close the given channel, flushing all buffered write operations.</source>
          <target state="translated">지정된 채널을 닫고 버퍼 된 모든 쓰기 작업을 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="41f5ceda25cbace756e58b1de142e130a58c7a95" translate="yes" xml:space="preserve">
          <source>Close the given channel, flushing all buffered write operations. Output functions raise a &lt;code&gt;Sys_error&lt;/code&gt; exception when they are applied to a closed output channel, except &lt;code&gt;close_out&lt;/code&gt; and &lt;code&gt;flush&lt;/code&gt;, which do nothing when applied to an already closed channel. Note that &lt;code&gt;close_out&lt;/code&gt; may raise &lt;code&gt;Sys_error&lt;/code&gt; if the operating system signals an error when flushing or closing.</source>
          <target state="translated">지정된 채널을 닫고 버퍼링 된 모든 쓰기 작업을 플러시합니다. 출력 함수 는 이미 닫힌 채널에 적용될 때 아무것도하지 않는 &lt;code&gt;close_out&lt;/code&gt; 및 &lt;code&gt;flush&lt;/code&gt; 를 제외하고 닫힌 출력 채널에 적용될 때 &lt;code&gt;Sys_error&lt;/code&gt; 예외를 발생 시킵니다 . 참고 &lt;code&gt;close_out&lt;/code&gt; 을 올릴 &lt;code&gt;Sys_error&lt;/code&gt; 를 세척하거나 닫을 때 운영 체제가 에러를 IF 신호.</target>
        </trans-unit>
        <trans-unit id="5befc2f5b4184ff319029954a3ebf8773fc60aa3" translate="yes" xml:space="preserve">
          <source>Close the given channel.</source>
          <target state="translated">주어진 채널을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="855dc6dc2be39d04f3f61cd8c3fd1df32f67ae63" translate="yes" xml:space="preserve">
          <source>Close the given channel. Input functions raise a &lt;code&gt;Sys_error&lt;/code&gt; exception when they are applied to a closed input channel, except &lt;code&gt;close_in&lt;/code&gt;, which does nothing when applied to an already closed channel.</source>
          <target state="translated">주어진 채널을 닫습니다. 입력 함수 는 이미 닫힌 채널에 적용될 때 아무 작업도 수행하지 않는 &lt;code&gt;close_in&lt;/code&gt; 을 제외하고 닫힌 입력 채널에 적용될 때 &lt;code&gt;Sys_error&lt;/code&gt; 예외를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="9baa0ea016defeba1648df1c2d1bbcade0cfb062" translate="yes" xml:space="preserve">
          <source>Closed function</source>
          <target state="translated">폐쇄 기능</target>
        </trans-unit>
        <trans-unit id="8e571180f5e0fe0a1fdd6d813d79acaf0ccfafa6" translate="yes" xml:space="preserve">
          <source>Closes the &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt;&lt;code&gt;in_channel&lt;/code&gt;&lt;/a&gt; associated with the given &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt; formatted input channel.</source>
          <target state="translated">주어진 &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt; &lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt; &lt;/a&gt; 형식의 입력 채널 과 연결된 &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt; &lt;code&gt;in_channel&lt;/code&gt; 을&lt;/a&gt; 닫습니다 .</target>
        </trans-unit>
        <trans-unit id="92b5986b3d61e6de67170fcc909df02aeafde6d5" translate="yes" xml:space="preserve">
          <source>Closes the most recently open pretty-printing box.</source>
          <target state="translated">가장 최근에 열린 예쁜 인쇄 상자를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="ca307b38101cc962b95e89e6fb0f008aaea2cbd9" translate="yes" xml:space="preserve">
          <source>Closes the most recently opened tabulation box.</source>
          <target state="translated">가장 최근에 연 표 상자를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="68e5fec7b2f5ac26ce08ec9bc3f5ffc7a6bf53c7" translate="yes" xml:space="preserve">
          <source>Closing an account can be done with the following polymorphic function:</source>
          <target state="translated">다음 다형성 함수를 사용하여 계정을 닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84e77ec95c5a92eb909c6ac217e1a65e9bf9d350" translate="yes" xml:space="preserve">
          <source>Closure</source>
          <target state="translated">Closure</target>
        </trans-unit>
        <trans-unit id="ab1d845e18aa99c6b3ee6f2e85015ce183551e94" translate="yes" xml:space="preserve">
          <source>Closure variable</source>
          <target state="translated">폐쇄 변수</target>
        </trans-unit>
        <trans-unit id="1cd8c868a0be56feb09ac75a044fb7f0ae532487" translate="yes" xml:space="preserve">
          <source>Closure_tag</source>
          <target state="translated">Closure_tag</target>
        </trans-unit>
        <trans-unit id="1ebf4e3e7bbb419f530260ca7275b893d6cbb63a" translate="yes" xml:space="preserve">
          <source>Code_val(v) returns the code part of the closure v.</source>
          <target state="translated">Code_val (v)는 클로저 v의 코드 부분을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7fcd900e853fff06e8f7a1bd2e3f903467af8dcd" translate="yes" xml:space="preserve">
          <source>Coercions between generic Bigarrays and fixed-dimension Bigarrays</source>
          <target state="translated">일반 Bigarray와 고정 차원 Bigarray 간의 강제 변환</target>
        </trans-unit>
        <trans-unit id="8d11cb9b589ffcbe8510661b59242a872e6798ab" translate="yes" xml:space="preserve">
          <source>Collected metrics include time spent executing the &lt;em&gt;garbage collector&lt;/em&gt;. The overall execution time of individual pauses are measured down to the time spent in specific parts of the garbage collection. Insight is also given on memory allocation and motion by recording the size of allocated memory blocks, as well as value promotions from the &lt;em&gt;minor heap&lt;/em&gt; to the &lt;em&gt;major heap&lt;/em&gt;.</source>
          <target state="translated">수집 된 메트릭에는 &lt;em&gt;가비지 수집기를&lt;/em&gt; 실행하는 데 소요 된 시간이 포함됩니다 . 개별 일시 중지의 전체 실행 시간은 가비지 수집의 특정 부분에 소요 된 시간까지 측정됩니다. 또한 할당 된 메모리 블록의 크기를 기록하고 &lt;em&gt;부 힙&lt;/em&gt; 에서 &lt;em&gt;주 힙&lt;/em&gt; 으로의 값 승격을 기록하여 메모리 할당 및 동작에 대한 통찰력을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="c87dcdd72a40f6bb0a5079a52dd8623dedfe7f0f" translate="yes" xml:space="preserve">
          <source>Colorize the OCaml code enclosed in [ ] and {[ ]}, using colors to emphasize keywords, etc. If the code fragments are not syntactically correct, no color is added.</source>
          <target state="translated">키워드를 강조하기 위해 색상을 사용하여 [] 및 {[]}로 묶인 OCaml 코드를 색상 화합니다. 코드 조각이 구문 상 정확하지 않으면 색상이 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25e719594fe4392044efc80322d910ef4492ead1" translate="yes" xml:space="preserve">
          <source>Combinators</source>
          <target state="translated">Combinators</target>
        </trans-unit>
        <trans-unit id="6c17ee03a306b91971412221a882fcd419f9e636" translate="yes" xml:space="preserve">
          <source>Command-line flags that may apply per round, for example those with -cost in the name, accept arguments of the form:</source>
          <target state="translated">라운드마다 적용될 수있는 명령 줄 플래그 (예 : 이름에 -cost가있는 플래그)는 다음 형식의 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c25ddda331004e4397b9f28e2859119842f8dc5d" translate="yes" xml:space="preserve">
          <source>Commands for &lt;a href=&quot;unix#VALlockf&quot;&gt;&lt;code&gt;Unix.lockf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALlockf&quot;&gt; &lt;code&gt;Unix.lockf&lt;/code&gt; &lt;/a&gt; 명령 .</target>
        </trans-unit>
        <trans-unit id="8fe2bb252511c0dcd32f92897ba3957e1e2a7bb9" translate="yes" xml:space="preserve">
          <source>Commands for &lt;a href=&quot;unixlabels#VALlockf&quot;&gt;&lt;code&gt;UnixLabels.lockf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALlockf&quot;&gt; &lt;code&gt;UnixLabels.lockf&lt;/code&gt; &lt;/a&gt; 명령 .</target>
        </trans-unit>
        <trans-unit id="153d7a58b3a3e898fcbdd04c462af308414bd09d" translate="yes" xml:space="preserve">
          <source>Comment</source>
          <target state="translated">Comment</target>
        </trans-unit>
        <trans-unit id="a3122e7df96ccf5ef3d6e6a21777fc3539282091" translate="yes" xml:space="preserve">
          <source>Comments are delimited by (* and *), as in OCaml. The parse keyword, can be replaced by the shortest keyword, with the semantic consequences explained below.</source>
          <target state="translated">주석은 OCaml에서와 같이 (* 및 *)로 구분됩니다. 구문 분석 키워드는 아래에 설명 된 의미 론적 결과와 함께 가장 짧은 키워드로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0c1fef4daa2204e1362a69f73112badb4d24614" translate="yes" xml:space="preserve">
          <source>Comments are enclosed between &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt; (as in C) in the &amp;ldquo;declarations&amp;rdquo; and &amp;ldquo;rules&amp;rdquo; sections, and between &lt;code&gt;(*&lt;/code&gt; and &lt;code&gt;*)&lt;/code&gt; (as in OCaml) in the &amp;ldquo;header&amp;rdquo; and &amp;ldquo;trailer&amp;rdquo; sections.</source>
          <target state="translated">주석은 &quot;선언&quot;및 &quot;규칙&quot;섹션에서 &lt;code&gt;/*&lt;/code&gt; 및 &lt;code&gt;*/&lt;/code&gt; (C에서와 같이) 사이 에, &quot;헤더&quot;및 &quot;트레일러&quot;섹션에서 OCaml에서와 같이 &lt;code&gt;(*&lt;/code&gt; 와 &lt;code&gt;*)&lt;/code&gt; 사이에 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="ecc11b72dffe0da3e8d97afd6ad9a45f16491b95" translate="yes" xml:space="preserve">
          <source>Comments are introduced by the two characters (*, with no intervening blanks, and terminated by the characters *), with no intervening blanks. Comments are treated as blank characters. Comments do not occur inside string or character literals. Nested comments are handled correctly.</source>
          <target state="translated">주석은 공백없이 두 문자 (*, 중간 공백 없음 및 * 문자로 종료)로 도입됩니다. 주석은 공백 문자로 처리됩니다. 문자열이나 문자 리터럴에는 주석이 없습니다. 중첩 된 주석은 올바르게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="f75c107f6586a424d755198fc82176b1d5f1dff9" translate="yes" xml:space="preserve">
          <source>Comments containing documentation material are called &lt;em&gt;special comments&lt;/em&gt; and are written between (** and *). Special comments must start exactly with (**. Comments beginning with ( and more than two * are ignored.</source>
          <target state="translated">문서 자료를 포함하는 주석을 &lt;em&gt;특수 주석&lt;/em&gt; 이라고 하며 (**와 *) 사이에 작성됩니다. 특수 주석은 정확히 (**로 시작해야합니다. (로 시작하는 주석과 *가 두 개 이상인 주석은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="03e0a1731c9889297d187cff3225ed905ba87b0e" translate="yes" xml:space="preserve">
          <source>Comments surrounded by blank lines that appear within structures, signatures, classes or class types are converted into &lt;a href=&quot;attributes#floating-attribute&quot;&gt;floating-attribute&lt;/a&gt;s. For example:</source>
          <target state="translated">구조, 서명, 클래스 또는 클래스 유형 내에 나타나는 빈 줄로 둘러싸인 주석은 &lt;a href=&quot;attributes#floating-attribute&quot;&gt;부동 속성&lt;/a&gt; 으로 변환됩니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="d590b93e87bc1ca65038f4d51e929c8c079658f0" translate="yes" xml:space="preserve">
          <source>Comments which appear &lt;em&gt;immediately after&lt;/em&gt; a labelled argument, record field, variant constructor, object method or polymorphic variant constructor are are converted into &lt;a href=&quot;attributes#attribute&quot;&gt;attribute&lt;/a&gt;s. Immediately after means that there must be no blank lines or other documentation comments between them. For example:</source>
          <target state="translated">레이블이 지정된 인수, 레코드 필드, 변형 생성자, 객체 메서드 또는 다형성 변형 생성자 &lt;em&gt;바로 뒤에&lt;/em&gt; 나타나는 주석은 &lt;a href=&quot;attributes#attribute&quot;&gt;속성&lt;/a&gt; 으로 변환됩니다 . 즉시 이후는 그 사이에 빈 줄이나 기타 문서 주석이 없어야 함을 의미합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="6b07191143ad093b41ed81db204e258405ef704d" translate="yes" xml:space="preserve">
          <source>Comments which appear &lt;em&gt;immediately before&lt;/em&gt; or &lt;em&gt;immediately after&lt;/em&gt; a structure item, signature item, class item or class type item are converted into &lt;a href=&quot;attributes#item-attribute&quot;&gt;item-attribute&lt;/a&gt;s. Immediately before or immediately after means that there must be no blank lines, ;;, or other documentation comments between them. For example:</source>
          <target state="translated">구조 항목, 서명 항목, 클래스 항목 또는 클래스 유형 항목의 &lt;em&gt;직전&lt;/em&gt; 또는 &lt;em&gt;직후에&lt;/em&gt; 나타나는 주석은 &lt;a href=&quot;attributes#item-attribute&quot;&gt;항목 속성&lt;/a&gt; 으로 변환됩니다 . 직전 또는 직후는 그 사이에 빈 줄, ;; 또는 기타 문서 주석이 없어야 함을 의미합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="b7e64151aaa26674586f987552e2a0ae124e42ca" translate="yes" xml:space="preserve">
          <source>Comments which start with ** are also used by the ocamldoc documentation generator (see &lt;a href=&quot;ocamldoc#c%3Aocamldoc&quot;&gt;16&lt;/a&gt;). The three comment forms recognised by the compiler are a subset of the forms accepted by ocamldoc (see &lt;a href=&quot;ocamldoc#s%3Aocamldoc-comments&quot;&gt;16.2&lt;/a&gt;).</source>
          <target state="translated">**로 시작하는 주석은 ocamldoc 문서 생성기에서도 사용됩니다 ( &lt;a href=&quot;ocamldoc#c%3Aocamldoc&quot;&gt;16&lt;/a&gt; 참조 ). 컴파일러에서 인식하는 세 가지 주석 형식은 ocamldoc에서 허용하는 형식의 하위 집합입니다 ( &lt;a href=&quot;ocamldoc#s%3Aocamldoc-comments&quot;&gt;16.2&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="547a2cc3c515433ea933b36b097f47f32287dbd8" translate="yes" xml:space="preserve">
          <source>Comments which start with ** are treated specially by the compiler. They are automatically converted during parsing into attributes (see &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;8.12&lt;/a&gt;) to allow tools to process them as documentation.</source>
          <target state="translated">**로 시작하는 주석은 컴파일러에서 특별히 처리합니다. 도구가 문서로 처리 할 수 ​​있도록 속성으로 구문 분석하는 동안 자동으로 변환됩니다 ( &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;8.12&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d13ad45db1dc27f552c9c8e0654c622cd0ecc95b" translate="yes" xml:space="preserve">
          <source>Common usage of semantic tags is text decoration to get specific font or text size rendering for a display device, or marking delimitation of entities (e.g. HTML or TeX elements or terminal escape sequences). More sophisticated usage of semantic tags could handle dynamic modification of the pretty-printer behavior to properly print the material within some specific tags. For instance, we can define an RGB tag like so:</source>
          <target state="translated">시맨틱 태그의 일반적인 용도는 디스플레이 장치에 대한 특정 글꼴 또는 텍스트 크기 렌더링을 가져 오는 텍스트 장식 또는 엔터티 구분 표시 (예 : HTML 또는 TeX 요소 또는 터미널 이스케이프 시퀀스)입니다. 시맨틱 태그를보다 정교하게 사용하면 예쁜 프린터 동작의 동적 수정을 처리하여 일부 특정 태그 내에서 자료를 올바르게 인쇄 할 수 있습니다. 예를 들어 다음과 같이 RGB 태그를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97496bca65dfa73c8db0f1c633b8c699b9ca1bae" translate="yes" xml:space="preserve">
          <source>Commonly-used options:</source>
          <target state="translated">일반적으로 사용되는 옵션 :</target>
        </trans-unit>
        <trans-unit id="69e3408c9830bff719edb4bd317094b20c392982" translate="yes" xml:space="preserve">
          <source>Compare the length of a list to an integer.</source>
          <target state="translated">목록의 길이를 정수와 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="160a38d938d09531dcc37101c8a48af67237c4f6" translate="yes" xml:space="preserve">
          <source>Compare the length of a list to an integer. &lt;code&gt;compare_length_with&amp;nbsp;l&amp;nbsp;n&lt;/code&gt; is equivalent to &lt;code&gt;compare&amp;nbsp;(length&amp;nbsp;l)&amp;nbsp;n&lt;/code&gt;, except that the computation stops after at most &lt;code&gt;n&lt;/code&gt; iterations on the list.</source>
          <target state="translated">목록의 길이를 정수와 비교하십시오. &lt;code&gt;compare_length_with&amp;nbsp;l&amp;nbsp;n&lt;/code&gt; 은 목록 에서 최대 &lt;code&gt;n&lt;/code&gt; 번의 반복 후에 계산이 중지된다는 점을 제외하면 &lt;code&gt;compare&amp;nbsp;(length&amp;nbsp;l)&amp;nbsp;n&lt;/code&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="b5b86b090c0daa980723dd4a0e6e2467eeba31e6" translate="yes" xml:space="preserve">
          <source>Compare the lengths of two lists.</source>
          <target state="translated">두 목록의 길이를 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="fbac14054ab6f68fcc3f6240710fbda158a49236" translate="yes" xml:space="preserve">
          <source>Compare the lengths of two lists. &lt;code&gt;compare_lengths&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; is equivalent to &lt;code&gt;compare&amp;nbsp;(length&amp;nbsp;l1)&amp;nbsp;(length&amp;nbsp;l2)&lt;/code&gt;, except that the computation stops after itering on the shortest list.</source>
          <target state="translated">두 목록의 길이를 비교하십시오. &lt;code&gt;compare_lengths&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; 는 &lt;code&gt;compare&amp;nbsp;(length&amp;nbsp;l1)&amp;nbsp;(length&amp;nbsp;l2)&lt;/code&gt; 와 동일합니다. 단, 가장 짧은 목록을 반복 한 후 계산이 중지된다는 점이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e46ee00fde40e955c86abe019a61121e06d653c9" translate="yes" xml:space="preserve">
          <source>Comparisons</source>
          <target state="translated">Comparisons</target>
        </trans-unit>
        <trans-unit id="5087a62fc321853c1ed733d0f0c235d307ad40e8" translate="yes" xml:space="preserve">
          <source>Compilation of modules that are able to be statically allocated (for example, the module corresponding to an entire compilation unit, as opposed to a first class module dependent on values computed at runtime) initially follows the strategy used for bytecode. A sequence of let-bindings, which may be interspersed with arbitrary effects, surrounds a record creation that becomes the module block. The Flambda-specific transformation follows: these bindings are lifted to toplevel symbols, as described above.</source>
          <target state="translated">정적으로 할당 될 수있는 모듈 (예 : 런타임에 계산 된 값에 의존하는 첫 번째 클래스 모듈과 달리 전체 컴파일 단위에 해당하는 모듈)의 컴파일은 처음에 바이트 코드에 사용되는 전략을 따릅니다. 임의의 효과로 산재 할 수있는 일련의 let 바인딩은 모듈 블록이되는 레코드 생성을 둘러 쌉니다. Flambda 관련 변환은 다음과 같습니다. 이러한 바인딩은 위에서 설명한대로 최상위 기호로 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="89736122b4f9e6c854312216700fafb53d78c2c9" translate="yes" xml:space="preserve">
          <source>Compilation units bridge the module system and the separate compilation system. A compilation unit is composed of two parts: an interface and an implementation. The interface contains a sequence of specifications, just as the inside of a sig &amp;hellip; end signature expression. The implementation contains a sequence of definitions and expressions, just as the inside of a struct &amp;hellip; end module expression. A compilation unit also has a name unit-name, derived from the names of the files containing the interface and the implementation (see chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; for more details). A compilation unit behaves roughly as the module definition</source>
          <target state="translated">컴파일 유닛은 모듈 시스템과 별도의 컴파일 시스템을 연결합니다. 컴파일 단위는 인터페이스와 구현의 두 부분으로 구성됩니다. 인터페이스는 sig&amp;hellip; end 시그니처 표현식의 내부와 마찬가지로 일련의 사양을 포함합니다. 구현에는 struct&amp;hellip; end 모듈 표현식의 내부와 마찬가지로 일련의 정의 및 표현식이 포함됩니다. 컴파일 단위에는 인터페이스와 구현을 포함하는 파일 이름에서 파생 된 이름 단위 이름도 있습니다 (자세한 내용은 &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; 장 참조). 컴파일 단위는 대략 모듈 정의처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="76d0c7b86e662ef638a28a1ba63b2bf600c9a068" translate="yes" xml:space="preserve">
          <source>Compilation units that use the threads library must also be compiled with the -I +threads option (see chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;).</source>
          <target state="translated">스레드 라이브러리를 사용하는 컴파일 유닛은 -I + threads 옵션으로도 컴파일해야합니다 ( &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; 장 참조 ).</target>
        </trans-unit>
        <trans-unit id="5561032adf17bb14b32847302c46e8b6f2562175" translate="yes" xml:space="preserve">
          <source>Compile Mylib.ml using -no-alias-deps, and the other files using -no-alias-deps and -openMylib (the last one is equivalent to adding the line open!Mylib at the top of each file).</source>
          <target state="translated">-no-alias-deps를 사용하여 Mylib.ml을 컴파일하고 -no-alias-deps 및 -openMylib를 사용하여 다른 파일을 컴파일합니다 (마지막 파일은 각 파일의 맨 위에 open! Mylib 줄을 추가하는 것과 동일합니다).</target>
        </trans-unit>
        <trans-unit id="0781426396e8d6e4ddff539e7a4bd1c018f11c8a" translate="yes" xml:space="preserve">
          <source>Compile a regular expression.</source>
          <target state="translated">정규식을 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="379347737d11075d4adc510a0c49219cd575a386" translate="yes" xml:space="preserve">
          <source>Compile a regular expression. The following constructs are recognized:</source>
          <target state="translated">정규식을 컴파일하십시오. 다음 구조가 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="9e82ad175e2f5dacb9db3b9f212ed757afd81633" translate="yes" xml:space="preserve">
          <source>Compile only. Suppress the linking phase of the compilation. Source code files are turned into compiled files, but no executable file is produced. This option is useful to compile modules separately.</source>
          <target state="translated">컴파일 만합니다. 컴파일의 연결 단계를 억제합니다. 소스 코드 파일은 컴파일 된 파일로 변환되지만 실행 파일은 생성되지 않습니다. 이 옵션은 모듈을 개별적으로 컴파일하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e75f188aa5bbb4470a9e0906d4ab6e6752a8b3a3" translate="yes" xml:space="preserve">
          <source>Compile the file filename as an implementation file, even if its extension is not .ml.</source>
          <target state="translated">확장자가 .ml이 아니더라도 파일 filename을 구현 파일로 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="899b4c58ed78c400dbe712c3db1a649a9c6d6a72" translate="yes" xml:space="preserve">
          <source>Compile the file filename as an interface file, even if its extension is not .mli.</source>
          <target state="translated">확장자가 .mli가 아니더라도 파일 filename을 인터페이스 파일로 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="299b080c443dece1ea245d410a53d3e92be360bb" translate="yes" xml:space="preserve">
          <source>Compiled bytecode files (.cmo files), on the other hand, can be freely renamed once created. That&amp;rsquo;s because the linker never attempts to find by itself the .cmo file that implements a module with a given name: it relies instead on the user providing the list of .cmo files by hand.</source>
          <target state="translated">반면 컴파일 된 바이트 코드 파일 (.cmo 파일)은 생성 된 후에 자유롭게 이름을 바꿀 수 있습니다. 링커는 주어진 이름의 모듈을 구현하는 .cmo 파일을 스스로 찾으려고하지 않기 때문입니다. 대신 사용자가 직접 .cmo 파일 목록을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="c8d36c73ee25d65a59259585e736e00c1c87f0a3" translate="yes" xml:space="preserve">
          <source>Compiler options</source>
          <target state="translated">컴파일러 옵션</target>
        </trans-unit>
        <trans-unit id="17d018534cc6444c276f058ff3cb2e0e87d24e89" translate="yes" xml:space="preserve">
          <source>Compiling with -g entails no penalty on the running time of programs: object files and bytecode executable files are bigger and take longer to produce, but the executable files run at exactly the same speed as if they had been compiled without -g.</source>
          <target state="translated">-g로 컴파일하면 프로그램 실행 시간에 대한 불이익이 없습니다. 개체 파일과 바이트 코드 실행 파일은 더 크고 생성하는 데 더 오래 걸리지 만 실행 파일은 -g없이 컴파일 된 것과 동일한 속도로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="10b26b96b1c573965f14a325ef88109f84be8e3b" translate="yes" xml:space="preserve">
          <source>Complex</source>
          <target state="translated">Complex</target>
        </trans-unit>
        <trans-unit id="7611b3d644720e341343c4b145fe3d01e8fd3e09" translate="yes" xml:space="preserve">
          <source>Complex numbers.</source>
          <target state="translated">복소수.</target>
        </trans-unit>
        <trans-unit id="a41458c6695371dbb3a5a9986252d1ee23df137d" translate="yes" xml:space="preserve">
          <source>Composition operators</source>
          <target state="translated">컴포지션 연산자</target>
        </trans-unit>
        <trans-unit id="ae0f112d5883b3ed0b4cd635980e9b3e4954b4d1" translate="yes" xml:space="preserve">
          <source>Computation of compaction-triggering condition.</source>
          <target state="translated">압축 트리거 조건 계산.</target>
        </trans-unit>
        <trans-unit id="d679feceea0c84fcb7b9d34d0e5bd48c86acaa87" translate="yes" xml:space="preserve">
          <source>Computation of major GC slice size.</source>
          <target state="translated">주요 GC 슬라이스 크기 계산.</target>
        </trans-unit>
        <trans-unit id="1ead95ccbb832522b24581d6c389102a9d297f79" translate="yes" xml:space="preserve">
          <source>Compute dependencies, as the ocamldep command would do. The remaining arguments are interpreted as if they were given to the ocamldep command.</source>
          <target state="translated">ocamldep 명령처럼 종속성을 계산합니다. 나머지 인수는 ocamldep 명령에 제공된 것처럼 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="3fd62d65b81816c32e4d92808204724e2d5c82fc" translate="yes" xml:space="preserve">
          <source>Computes the total size (in words, including the headers) of all heap blocks accessible from the argument.</source>
          <target state="translated">인수에서 액세스 할 수있는 모든 힙 블록의 전체 크기 (헤더 포함)를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="518143af77e23baf0875a2af2ee9be3bba904a09" translate="yes" xml:space="preserve">
          <source>Computes the total size (in words, including the headers) of all heap blocks accessible from the argument. Statically allocated blocks are excluded.</source>
          <target state="translated">인수에서 액세스 할 수있는 모든 힙 블록의 전체 크기 (헤더 포함)를 계산합니다. 정적으로 할당 된 블록은 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="7e753af33c5e8b0b810748b18ff7f60b83d5a7d0" translate="yes" xml:space="preserve">
          <source>Concatenate a list of lists.</source>
          <target state="translated">목록 목록을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="c4261005ac92aba9c70cd9071850bc5e978c5334" translate="yes" xml:space="preserve">
          <source>Concatenate a list of lists. The elements of the argument are all concatenated together (in the same order) to give the result. Not tail-recursive (length of the argument + length of the longest sub-list).</source>
          <target state="translated">목록 목록을 연결합니다. 인수의 요소는 모두 동일한 순서로 함께 연결되어 결과를 제공합니다. 꼬리 재귀 적이 지 않습니다 (인수 길이 + 가장 긴 하위 목록의 길이).</target>
        </trans-unit>
        <trans-unit id="c21ae36c663b5598bb7f776455d5f7afa5edba88" translate="yes" xml:space="preserve">
          <source>Concatenate two lists.</source>
          <target state="translated">두 목록을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="cf199bfa330ffd5961a47d9da430fec2620a9ae5" translate="yes" xml:space="preserve">
          <source>Concatenate two lists. Same as the infix operator &lt;code&gt;@&lt;/code&gt;. Not tail-recursive (length of the first argument).</source>
          <target state="translated">두 목록을 연결합니다. 중위 연산자 &lt;code&gt;@&lt;/code&gt; 와 동일합니다 . 꼬리 재귀가 아닙니다 (첫 번째 인수의 길이).</target>
        </trans-unit>
        <trans-unit id="1119e8da11a04af6ca0a753792995fcee08b2edc" translate="yes" xml:space="preserve">
          <source>Concatenating its elements using &lt;code&gt;sep&lt;/code&gt; as a separator returns a string equal to the input (&lt;code&gt;String.concat&amp;nbsp;(String.make&amp;nbsp;1&amp;nbsp;sep)&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(String.split_on_char&amp;nbsp;sep&amp;nbsp;s)&amp;nbsp;=&amp;nbsp;s&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;sep&lt;/code&gt; 를 구분 기호로 사용하여 요소를 연결 하면 입력과 동일한 문자열이 반환됩니다 ( &lt;code&gt;String.concat&amp;nbsp;(String.make&amp;nbsp;1&amp;nbsp;sep)&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(String.split_on_char&amp;nbsp;sep&amp;nbsp;s)&amp;nbsp;=&amp;nbsp;s&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="61ff79974f16dba8d693a91da2e607160a4f439a" translate="yes" xml:space="preserve">
          <source>Concerning the precedences of operators, # has the highest precedence, followed by *, + and ?, then concatenation, then | (alternation), then as.</source>
          <target state="translated">연산자의 우선 순위와 관련하여 #의 우선 순위가 가장 높고 *, + 및?, 연결, | (교체), 다음으로.</target>
        </trans-unit>
        <trans-unit id="2f4979324e03e4571b1d7eba701226670c2ee2da" translate="yes" xml:space="preserve">
          <source>Condition</source>
          <target state="translated">Condition</target>
        </trans-unit>
        <trans-unit id="ae369e3bb89711211abac6ae92d6ff255dbe265e" translate="yes" xml:space="preserve">
          <source>Condition variables are used when one thread wants to wait until another thread has finished doing something: the former thread 'waits' on the condition variable, the latter thread 'signals' the condition when it is done. Condition variables should always be protected by a mutex. The typical use is (if &lt;code&gt;D&lt;/code&gt; is a shared data structure, &lt;code&gt;m&lt;/code&gt; its mutex, and &lt;code&gt;c&lt;/code&gt; is a condition variable):</source>
          <target state="translated">조건 변수는 한 스레드가 다른 스레드가 작업을 완료 할 때까지 대기하려고 할 때 사용됩니다. 전자 스레드는 조건 변수에서 '대기'하고 후자 스레드는 완료되면 조건을 '신호'합니다. 조건 변수는 항상 뮤텍스로 보호되어야합니다. 일반적인 용도는 다음과 같습니다 ( &lt;code&gt;D&lt;/code&gt; 가 공유 데이터 구조이고 &lt;code&gt;m&lt;/code&gt; 뮤텍스, &lt;code&gt;c&lt;/code&gt; 가 조건 변수 인 경우).</target>
        </trans-unit>
        <trans-unit id="3c9f5175bc76dab872dcca0a8f4945ab47e57882" translate="yes" xml:space="preserve">
          <source>Condition variables to synchronize between threads.</source>
          <target state="translated">스레드간에 동기화 할 조건 변수입니다.</target>
        </trans-unit>
        <trans-unit id="fee141f68e4704140703200ef223fa3472ef6c33" translate="yes" xml:space="preserve">
          <source>Conjugate: given the complex &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt;, returns &lt;code&gt;x&amp;nbsp;-&amp;nbsp;i.y&lt;/code&gt;.</source>
          <target state="translated">어원은 : 복잡한 주어진 &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt; 반환, &lt;code&gt;x&amp;nbsp;-&amp;nbsp;i.y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8479889b89034bc022c57bd8893185ae0364f595" translate="yes" xml:space="preserve">
          <source>Connect a socket to an address.</source>
          <target state="translated">소켓을 주소에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="b06164f137b6b54ef3d5592c316dbf54c71cfc6d" translate="yes" xml:space="preserve">
          <source>Connect to a server at the given address.</source>
          <target state="translated">주어진 주소에서 서버에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="80bf1adde48d120cd79946b31d85d02da38b97cb" translate="yes" xml:space="preserve">
          <source>Connect to a server at the given address. Return a pair of buffered channels connected to the server. Remember to call &lt;a href=&quot;stdlib#VALflush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; on the output channel at the right times to ensure correct synchronization.</source>
          <target state="translated">주어진 주소에서 서버에 연결합니다. 서버에 연결된 버퍼링 된 채널 쌍을 반환합니다. 올바른 동기화를 보장하기 위해 적절한 시간에 출력 채널에서 &lt;a href=&quot;stdlib#VALflush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; 를 호출하는 것을 잊지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="96f7e671b1e48da4a2700769f8225126847b97cf" translate="yes" xml:space="preserve">
          <source>Connection refused</source>
          <target state="translated">연결이 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="2986a51d253e6221052722aab2efbc181246b417" translate="yes" xml:space="preserve">
          <source>Connection reset by peer</source>
          <target state="translated">피어에 의한 연결 재설정</target>
        </trans-unit>
        <trans-unit id="52c871ea22dada6554a1363ee61f9567c44efd80" translate="yes" xml:space="preserve">
          <source>Connection timed out</source>
          <target state="translated">연결 시간이 초과되었습니다</target>
        </trans-unit>
        <trans-unit id="8f72e1d193c8d460ed969566e06ff72f178f5e73" translate="yes" xml:space="preserve">
          <source>Consider an OCaml interface to the standard libz C library for reading and writing compressed files. Assume this library resides in /usr/local/zlib. This interface is composed of an OCaml part zip.cmo/zip.cmx and a C part zipstubs.o containing the stub code around the libz entry points. The following command builds the OCaml libraries zip.cma and zip.cmxa, as well as the companion C libraries dllzip.so and libzip.a:</source>
          <target state="translated">압축 파일을 읽고 쓰기 위해 표준 libz C 라이브러리에 대한 OCaml 인터페이스를 고려하십시오. 이 라이브러리가 / usr / local / zlib에 있다고 가정합니다. 이 인터페이스는 OCaml 부분 zip.cmo / zip.cmx와 libz 진입 점 주변의 스텁 코드를 포함하는 C 부분 zipstubs.o로 ​​구성됩니다. 다음 명령은 OCaml 라이브러리 zip.cma 및 zip.cmxa와 함께 제공되는 C 라이브러리 dllzip.so 및 libzip.a를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="f229a35ad8b444a6b385bd0bbc84911cc773a8ae" translate="yes" xml:space="preserve">
          <source>Consider the given extension (with leading dot) to be a synonym for .ml.</source>
          <target state="translated">주어진 확장자 (선행 점 포함)를 .ml의 동의어로 간주하십시오.</target>
        </trans-unit>
        <trans-unit id="2f60faccd60355e261afc4acf9b9359997518724" translate="yes" xml:space="preserve">
          <source>Consider the given extension (with leading dot) to be a synonym for .mli.</source>
          <target state="translated">주어진 확장자 (선행 점 포함)를 .mli의 동의어로 간주하십시오.</target>
        </trans-unit>
        <trans-unit id="e850dfc5bd591d629fab1f8c55c2012ff29b5daf" translate="yes" xml:space="preserve">
          <source>Consider the service as UDP-based instead of the default TCP</source>
          <target state="translated">서비스를 기본 TCP 대신 UDP 기반으로 간주하십시오.</target>
        </trans-unit>
        <trans-unit id="733fd2b4c4e1bca4c7d0e3c2e1c341bcd1d34269" translate="yes" xml:space="preserve">
          <source>Constant</source>
          <target state="translated">Constant</target>
        </trans-unit>
        <trans-unit id="adcae46226442190d49d512a839dba8c470eb3cd" translate="yes" xml:space="preserve">
          <source>Constant closure</source>
          <target state="translated">지속적인 폐쇄</target>
        </trans-unit>
        <trans-unit id="5b2ef079e6ae98b281f8cdb764b9043d153c622f" translate="yes" xml:space="preserve">
          <source>Constant float arrays at the toplevel are mutable and never shared. (That is to say, for each such definition there is a distinct symbol in the data section of the object file pointing at the array.)</source>
          <target state="translated">최상위에있는 상수 float 배열은 변경 가능하며 절대 공유되지 않습니다. (즉, 각 정의에 대해 배열을 가리키는 오브젝트 파일의 데이터 섹션에 고유 한 기호가 있습니다.)</target>
        </trans-unit>
        <trans-unit id="091bc5369699349a2b7818b4093bfda40449b4e6" translate="yes" xml:space="preserve">
          <source>Constant float arrays not at toplevel are mutable and are created each time the expression is evaluated. This can be thought of as an operation that takes an immutable array (which in the source code has no associated name; let us call it the &lt;em&gt;initialising array&lt;/em&gt;) and duplicates it into a fresh mutable array.</source>
          <target state="translated">최상위에 있지 않은 상수 부동 배열은 변경 가능하며 표현식이 평가 될 때마다 생성됩니다. 이것은 변경 불가능한 배열 (소스 코드에는 연관된 이름이 없습니다. &lt;em&gt;초기화 배열&lt;/em&gt; 이라고 부릅니다 )을 가져와 새로운 변경 가능한 배열로 복제하는 작업으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df73dfd589730df5a6d45da4297228a1572f788f" translate="yes" xml:space="preserve">
          <source>Constraints are added left to right. After each constraint has been applied, the resulting signature must be a subtype of the signature before the constraint was applied. Thus, the with operator can only add information on the type components of a signature, but never remove information.</source>
          <target state="translated">제약 조건은 왼쪽에서 오른쪽으로 추가됩니다. 각 제약 조건이 적용된 후 결과 서명은 제약 조건이 적용되기 전에 서명의 하위 유형이어야합니다. 따라서 with 연산자는 서명의 유형 구성 요소에 대한 정보 만 추가 할 수 있지만 정보를 제거 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="b1e8eac434f49462f355fa784ffa70e49747333e" translate="yes" xml:space="preserve">
          <source>Construct the lexer function.</source>
          <target state="translated">렉서 함수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a061bb0abb78e79e2f6fd7d764e9b588faff175a" translate="yes" xml:space="preserve">
          <source>Construct the lexer function. The first argument is the list of keywords. An identifier &lt;code&gt;s&lt;/code&gt; is returned as &lt;code&gt;Kwd&amp;nbsp;s&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; belongs to this list, and as &lt;code&gt;Ident&amp;nbsp;s&lt;/code&gt; otherwise. A special character &lt;code&gt;s&lt;/code&gt; is returned as &lt;code&gt;Kwd&amp;nbsp;s&lt;/code&gt; if &lt;code&gt;s&lt;/code&gt; belongs to this list, and cause a lexical error (exception &lt;a href=&quot;stream#EXCEPTIONError&quot;&gt;&lt;code&gt;Stream.Error&lt;/code&gt;&lt;/a&gt; with the offending lexeme as its parameter) otherwise. Blanks and newlines are skipped. Comments delimited by &lt;code&gt;(*&lt;/code&gt; and &lt;code&gt;*)&lt;/code&gt; are skipped as well, and can be nested. A &lt;a href=&quot;stream#EXCEPTIONFailure&quot;&gt;&lt;code&gt;Stream.Failure&lt;/code&gt;&lt;/a&gt; exception is raised if end of stream is unexpectedly reached.</source>
          <target state="translated">렉서 함수를 생성합니다. 첫 번째 인수는 키워드 목록입니다. 식별자 &lt;code&gt;s&lt;/code&gt; 로 반환 &lt;code&gt;Kwd&amp;nbsp;s&lt;/code&gt; 경우 &lt;code&gt;s&lt;/code&gt; 이 목록에 속하고 &lt;code&gt;Ident&amp;nbsp;s&lt;/code&gt; 달리. &lt;code&gt;s&lt;/code&gt; 가이 목록에 속 하면 특수 문자 &lt;code&gt;s&lt;/code&gt; 가 &lt;code&gt;Kwd&amp;nbsp;s&lt;/code&gt; 로 반환되고 , 그렇지 않으면 어휘 오류가 발생합니다 ( 파라미터로 문제가되는 lexeme가있는 &lt;a href=&quot;stream#EXCEPTIONError&quot;&gt; &lt;code&gt;Stream.Error&lt;/code&gt; &lt;/a&gt; 예외 ). 공백과 줄 바꿈은 건너 뜁니다. &lt;code&gt;(*&lt;/code&gt; 및 &lt;code&gt;*)&lt;/code&gt; 로 구분 된 주석 도 건너 뛰고 중첩 될 수 있습니다. &lt;a href=&quot;stream#EXCEPTIONFailure&quot;&gt; &lt;code&gt;Stream.Failure&lt;/code&gt; 의&lt;/a&gt; 스트림의 끝이 예기치 않게 도달하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="88ce4c1c12e94557da36c6eead56b4b8c0febfb9" translate="yes" xml:space="preserve">
          <source>Constructed term</source>
          <target state="translated">구성 용어</target>
        </trans-unit>
        <trans-unit id="ecff4df31a7f2f32be511ceea60554afcb2a1798" translate="yes" xml:space="preserve">
          <source>Constructed terms are represented either by unboxed integers (for constant constructors) or by blocks whose tag encode the constructor (for non-constant constructors). The constant constructors and the non-constant constructors for a given concrete type are numbered separately, starting from 0, in the order in which they appear in the concrete type declaration. A constant constructor is represented by the unboxed integer equal to its constructor number. A non-constant constructor declared with n arguments is represented by a block of size n, tagged with the constructor number; the n fields contain its arguments. Example:</source>
          <target state="translated">생성 된 용어는 박스 화되지 않은 정수 (상수 생성자의 경우) 또는 태그가 생성자를 인코딩하는 블록 (비상 수 생성자의 경우)으로 표시됩니다. 주어진 구체적인 유형에 대한 상수 생성자와 상수가 아닌 생성자는 구체적인 유형 선언에 나타나는 순서대로 0부터 시작하여 별도로 번호가 매겨집니다. 상수 생성자는 생성자 번호와 동일한 박싱되지 않은 정수로 표시됩니다. n 개의 인수로 선언 된 상수가 아닌 생성자는 생성자 번호로 태그가 지정된 n 크기의 블록으로 표시됩니다. n 필드에는 인수가 포함됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="33c0fcb39098c99481dbabaef595556e1d6382af" translate="yes" xml:space="preserve">
          <source>Construction or operator</source>
          <target state="translated">건설 또는 운영자</target>
        </trans-unit>
        <trans-unit id="edb7861f190be64ab7c7a39786a00727bb16847d" translate="yes" xml:space="preserve">
          <source>Constructor</source>
          <target state="translated">Constructor</target>
        </trans-unit>
        <trans-unit id="4dcc0e86f7ec49506f86ec0239fe32f8d5ecfc33" translate="yes" xml:space="preserve">
          <source>Constructor application, Tag application</source>
          <target state="translated">생성자 애플리케이션, 태그 애플리케이션</target>
        </trans-unit>
        <trans-unit id="a57a499db413be645296d9a22122e646866b53d6" translate="yes" xml:space="preserve">
          <source>Constructor or label name used out of scope.</source>
          <target state="translated">범위를 벗어난 생성자 또는 레이블 이름이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="60a5c966a71a24034f9238685790a526710ef75d" translate="yes" xml:space="preserve">
          <source>Constructors</source>
          <target state="translated">Constructors</target>
        </trans-unit>
        <trans-unit id="b1aff6232fa572c823b5ca4e0a0129e7ab716449" translate="yes" xml:space="preserve">
          <source>Consult the &lt;em&gt;Glossary&lt;/em&gt; at the end of this chapter for definitions of technical terms used below.</source>
          <target state="translated">아래에 사용 된 기술 용어에 대한 정의는이 장 끝에 있는 &lt;em&gt;용어집&lt;/em&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">Contents</target>
        </trans-unit>
        <trans-unit id="4dfc2782cd72d273592670acab33392686fa763f" translate="yes" xml:space="preserve">
          <source>Contents of the block</source>
          <target state="translated">블록의 내용</target>
        </trans-unit>
        <trans-unit id="7ef50d03cf1626a58aa34b0e16915da06db0ad2e" translate="yes" xml:space="preserve">
          <source>Contextual control of command-line options</source>
          <target state="translated">명령 줄 옵션의 상황 별 제어</target>
        </trans-unit>
        <trans-unit id="2e02623966f9391facf6eaefc8b079ed5b630bee" translate="yes" xml:space="preserve">
          <source>Continue</source>
          <target state="translated">Continue</target>
        </trans-unit>
        <trans-unit id="a5765b37016775dde6c6f0a25c6231ac5868c966" translate="yes" xml:space="preserve">
          <source>Contrarily, if we have a function that can handle values of type xy</source>
          <target state="translated">반대로 xy 유형의 값을 처리 할 수있는 함수가있는 경우</target>
        </trans-unit>
        <trans-unit id="44e574919fb4b279c4aa016ee88a030406704659" translate="yes" xml:space="preserve">
          <source>Control debugging support for &lt;code&gt;ocamlyacc&lt;/code&gt;-generated parsers.</source>
          <target state="translated">&lt;code&gt;ocamlyacc&lt;/code&gt; 생성 파서에 대한 디버깅 지원을 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="ea8016b69c5c63c94758b8d9afd091d63f269088" translate="yes" xml:space="preserve">
          <source>Control debugging support for &lt;code&gt;ocamlyacc&lt;/code&gt;-generated parsers. After &lt;code&gt;Parsing.set_trace&amp;nbsp;true&lt;/code&gt;, the pushdown automaton that executes the parsers prints a trace of its actions (reading a token, shifting a state, reducing by a rule) on standard output. &lt;code&gt;Parsing.set_trace&amp;nbsp;false&lt;/code&gt; turns this debugging trace off. The boolean returned is the previous state of the trace flag.</source>
          <target state="translated">&lt;code&gt;ocamlyacc&lt;/code&gt; 생성 파서에 대한 디버깅 지원을 제어합니다 . &lt;code&gt;Parsing.set_trace&amp;nbsp;true&lt;/code&gt; 후 파서를 실행하는 푸시 다운 오토 마톤은 표준 출력에 해당 작업 (토큰 읽기, 상태 이동, 규칙에 따라 감소)의 추적을 인쇄합니다. &lt;code&gt;Parsing.set_trace&amp;nbsp;false&lt;/code&gt; 는이 디버깅 추적을 해제합니다. 반환 된 부울은 추적 플래그의 이전 상태입니다.</target>
        </trans-unit>
        <trans-unit id="a581af7c17aaf436ca9b9d0b8cc4b52024e23c6c" translate="yes" xml:space="preserve">
          <source>Control the Nagle algorithm for TCP sockets</source>
          <target state="translated">TCP 소켓에 대한 Nagle 알고리즘 제어</target>
        </trans-unit>
        <trans-unit id="01f6ce64b088c1d86a1cc628890b28def1724c57" translate="yes" xml:space="preserve">
          <source>Control the way error messages and warnings are printed. The following modes are supported:</source>
          <target state="translated">오류 메시지 및 경고가 인쇄되는 방식을 제어합니다. 다음 모드가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c54c927dcfd25ea6169be951e934da94f9e3db5c" translate="yes" xml:space="preserve">
          <source>Control whether the OCaml runtime system can emit warnings on stderr.</source>
          <target state="translated">OCaml 런타임 시스템이 stderr에서 경고를 생성 할 수 있는지 여부를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="158cedb78544ff7bbffffff2c57e102bc5772791" translate="yes" xml:space="preserve">
          <source>Control whether the OCaml runtime system can emit warnings on stderr. Currently, the only supported warning is triggered when a channel created by &lt;code&gt;open_*&lt;/code&gt; functions is finalized without being closed. Runtime warnings are disabled by default.</source>
          <target state="translated">OCaml 런타임 시스템이 stderr에서 경고를 생성 할 수 있는지 여부를 제어합니다. 현재 유일하게 지원되는 경고는 &lt;code&gt;open_*&lt;/code&gt; 함수에 의해 생성 된 채널 이 닫히지 않고 종료 될 때 트리거됩니다 . 런타임 경고는 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="60df4ef37e363b7e927a63a861aa42ec8b55d7e9" translate="yes" xml:space="preserve">
          <source>Controlling which alerts are enabled and whether they are turned into fatal errors is done either through the compiler&amp;rsquo;s command-line option -alert &amp;lt;spec&amp;gt; or locally in the code through the alert or ocaml.alert attribute taking a single string payload &amp;lt;spec&amp;gt;. In both cases, the syntax for &amp;lt;spec&amp;gt; is a concatenation of items of the form:</source>
          <target state="translated">활성화 된 경고와 치명적인 오류로 전환되는지 여부를 제어하는 ​​것은 컴파일러의 명령 줄 옵션 -alert &amp;lt;spec&amp;gt;을 통해 수행되거나 단일 문자열 페이로드 &amp;lt;spec&amp;gt;을 사용하는 경고 또는 ocaml.alert 속성을 통해 코드에서 로컬로 수행됩니다. 두 경우 모두 &amp;lt;spec&amp;gt;의 구문은 다음 형식의 항목을 연결 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="933cc834a01ad3244115777194487cf144f0ecdd" translate="yes" xml:space="preserve">
          <source>Controls how the inliner assesses the runtime performance penalties associated with various operations. See section &lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;21.3.5&lt;/a&gt;.</source>
          <target state="translated">인라이너가 다양한 작업과 관련된 런타임 성능 패널티를 평가하는 방법을 제어합니다. 섹션 &lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;21.3.5를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b21ecd4fcc9a8d4ea30185fe486acd99672a553f" translate="yes" xml:space="preserve">
          <source>Controls how the inliner assesses whether a code path is likely to be hot or cold. See section &lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;21.3.5&lt;/a&gt;.</source>
          <target state="translated">인라이너가 코드 경로가 뜨겁거나 차가운 지 여부를 평가하는 방법을 제어합니다. 섹션 &lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;21.3.5를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9fa7a499f4a55d9e4e13932642f1433a08a09c0" translate="yes" xml:space="preserve">
          <source>Controls inlining of functors at toplevel. See section &lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;21.3.5&lt;/a&gt;.</source>
          <target state="translated">최상위에서 펑터의 인라인을 제어합니다. 섹션 &lt;a href=&quot;#ss%3Aflambda-assessment-inlining&quot;&gt;21.3.5를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="293ff2efcde405fd53b38d3396adbe0390c9bd33" translate="yes" xml:space="preserve">
          <source>Convenience formatting functions.</source>
          <target state="translated">편리한 서식 지정 기능.</target>
        </trans-unit>
        <trans-unit id="61856b8c17a4ff32006fe4b7dcc6f96f253b2120" translate="yes" xml:space="preserve">
          <source>Conventions</source>
          <target state="translated">Conventions</target>
        </trans-unit>
        <trans-unit id="5cd6a9211102cdfa59a068840e929afa53f5eabc" translate="yes" xml:space="preserve">
          <source>Conversely, the module expression (val&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) evaluates the core language expression &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; to a value, which must have type module&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;, and extracts the module that was encapsulated in this value. Again &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; can be omitted if the type of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; is known. If the module expression is already parenthesized, like the arguments of functors are, no additional parens are needed: Map.Make(val key).</source>
          <target state="translated">반대로 모듈 표현식 (val &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; : &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; )은 핵심 언어 표현식 &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; 을 값으로 평가합니다 .이 값은 module &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; 유형을 가져야 하며이 값 으로 캡슐화 된 모듈을 추출합니다. &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; 의 유형 이 알려진 경우 다시 &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; 을 생략 할 수 있습니다 . functor의 인수처럼 모듈 표현식이 이미 괄호로 묶여 있으면 추가 괄호가 필요하지 않습니다 : Map.Make (val key).</target>
        </trans-unit>
        <trans-unit id="c76f66df18ce8edc9efd1881966c3c39e47be201" translate="yes" xml:space="preserve">
          <source>Conversely, whitespace or special shell characters occurring in command names or in their arguments must be quoted or escaped so that the shell does not interpret them. The quoting rules vary between the POSIX shell and the Windows shell. The &lt;a href=&quot;filename#VALquote_command&quot;&gt;&lt;code&gt;Filename.quote_command&lt;/code&gt;&lt;/a&gt; performs the appropriate quoting given a command name, a list of arguments, and optional file redirections.</source>
          <target state="translated">반대로 명령 이름이나 인수에 나오는 공백 또는 특수 쉘 문자는 따옴표로 묶거나 이스케이프 처리하여 쉘이 해석하지 않도록해야합니다. 인용 규칙은 POSIX 셸과 Windows 셸간에 다릅니다. &lt;a href=&quot;filename#VALquote_command&quot;&gt; &lt;code&gt;Filename.quote_command&lt;/code&gt; 는&lt;/a&gt; 적절한 명령 이름, 인수 목록 및 옵션 파일의 리디렉션을 제공 인용을 수행한다.</target>
        </trans-unit>
        <trans-unit id="6a64eefe7afd3acbb2a3fcb4bbbe7751fd9c8af3" translate="yes" xml:space="preserve">
          <source>Conversion from functions with default values to functions with patterns only works identically for class functions as for normal functions.</source>
          <target state="translated">기본값이있는 함수에서 패턴이있는 함수로의 변환은 일반 함수와 동일하게 클래스 함수에 대해서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e91ad5abdc78b39b4ce92904e5396ec1f786248c" translate="yes" xml:space="preserve">
          <source>Conversion from the printable representation of an Internet address to its internal representation.</source>
          <target state="translated">인터넷 주소의 인쇄 가능한 표현에서 내부 표현으로 변환.</target>
        </trans-unit>
        <trans-unit id="92b79bd86888a46b8955becf95db977c77d0ac25" translate="yes" xml:space="preserve">
          <source>Conversion from the printable representation of an Internet address to its internal representation. The argument string consists of 4 numbers separated by periods (&lt;code&gt;XXX.YYY.ZZZ.TTT&lt;/code&gt;) for IPv4 addresses, and up to 8 numbers separated by colons for IPv6 addresses.</source>
          <target state="translated">인터넷 주소의 인쇄 가능한 표현에서 내부 표현으로 변환. 인수 문자열은 IPv4 주소의 경우 마침표 ( &lt;code&gt;XXX.YYY.ZZZ.TTT&lt;/code&gt; )로 구분 된 4 개의 숫자 와 IPv6 주소의 경우 콜론으로 구분 된 최대 8 개의 숫자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="85ea1a5bd106d39445b87322996d86ec7c632630" translate="yes" xml:space="preserve">
          <source>Conversion from the printable representation of an Internet address to its internal representation. The argument string consists of 4 numbers separated by periods (&lt;code&gt;XXX.YYY.ZZZ.TTT&lt;/code&gt;) for IPv4 addresses, and up to 8 numbers separated by colons for IPv6 addresses. Raise &lt;code&gt;Failure&lt;/code&gt; when given a string that does not match these formats.</source>
          <target state="translated">인터넷 주소의 인쇄 가능한 표현에서 내부 표현으로 변환. 인수 문자열은 IPv4 주소의 경우 마침표 ( &lt;code&gt;XXX.YYY.ZZZ.TTT&lt;/code&gt; )로 구분 된 4 개의 숫자 와 IPv6 주소의 경우 콜론으로 구분 된 최대 8 개의 숫자로 구성됩니다. 올리 &lt;code&gt;Failure&lt;/code&gt; 이러한 형식과 일치하지 않는 문자열이 주어 졌을 때.</target>
        </trans-unit>
        <trans-unit id="7d97210aeab0bd3ebce234df3ec8fe7e4a70ca7f" translate="yes" xml:space="preserve">
          <source>Conversion specifications consist in the &lt;code&gt;%&lt;/code&gt; character, followed by an optional flag, an optional field width, and followed by one or two conversion characters.</source>
          <target state="translated">변환 스펙은 &lt;code&gt;%&lt;/code&gt; 문자, 선택적 플래그, 선택적 필드 너비 및 하나 또는 두 개의 변환 문자로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="ab980193d03ab0985dd1b4bc77c12b22e232db45" translate="yes" xml:space="preserve">
          <source>Conversion specifications have the following form:</source>
          <target state="translated">변환 사양의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c06747952c1535df9eef8f493a0e2f59c85b975" translate="yes" xml:space="preserve">
          <source>Conversion specifications in format strings</source>
          <target state="translated">형식 문자열의 변환 사양</target>
        </trans-unit>
        <trans-unit id="c1c32e11691d111083462c54b49004696a9a09d1" translate="yes" xml:space="preserve">
          <source>Convert a date and time, specified by the &lt;code&gt;tm&lt;/code&gt; argument, into a time in seconds, as returned by &lt;a href=&quot;unix#VALtime&quot;&gt;&lt;code&gt;Unix.time&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;tm&lt;/code&gt; 인수로 지정된 날짜 및 시간 을 &lt;a href=&quot;unix#VALtime&quot;&gt; &lt;code&gt;Unix.time&lt;/code&gt; 에서&lt;/a&gt; 반환하는 초 단위의 시간으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="c792e891ce8ae61fdaebbd94276bd3662c41af32" translate="yes" xml:space="preserve">
          <source>Convert a date and time, specified by the &lt;code&gt;tm&lt;/code&gt; argument, into a time in seconds, as returned by &lt;a href=&quot;unix#VALtime&quot;&gt;&lt;code&gt;Unix.time&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;tm_isdst&lt;/code&gt;, &lt;code&gt;tm_wday&lt;/code&gt; and &lt;code&gt;tm_yday&lt;/code&gt; fields of &lt;code&gt;tm&lt;/code&gt; are ignored. Also return a normalized copy of the given &lt;code&gt;tm&lt;/code&gt; record, with the &lt;code&gt;tm_wday&lt;/code&gt;, &lt;code&gt;tm_yday&lt;/code&gt;, and &lt;code&gt;tm_isdst&lt;/code&gt; fields recomputed from the other fields, and the other fields normalized (so that, e.g., 40 October is changed into 9 November). The &lt;code&gt;tm&lt;/code&gt; argument is interpreted in the local time zone.</source>
          <target state="translated">&lt;code&gt;tm&lt;/code&gt; 인수로 지정된 날짜 및 시간 을 &lt;a href=&quot;unix#VALtime&quot;&gt; &lt;code&gt;Unix.time&lt;/code&gt; 에서&lt;/a&gt; 반환하는 초 단위의 시간으로 변환 합니다. &lt;code&gt;tm&lt;/code&gt; 의 &lt;code&gt;tm_isdst&lt;/code&gt; , &lt;code&gt;tm_wday&lt;/code&gt; 및 &lt;code&gt;tm_yday&lt;/code&gt; 필드 는 무시됩니다. 또한 &lt;code&gt;tm_wday&lt;/code&gt; , &lt;code&gt;tm_yday&lt;/code&gt; 및 &lt;code&gt;tm_isdst&lt;/code&gt; 필드가 다른 필드에서 재 계산되고 다른 필드가 정규화 된 (예 : 10 월 40 일이 11 월 9 일로 변경됨) 지정된 &lt;code&gt;tm&lt;/code&gt; 레코드 의 정규화 된 사본을 반환합니다 . &lt;code&gt;tm&lt;/code&gt; 인수는 로컬 타임 존으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="166e14cf3638ad0b673e006de2b94c19860f26cb" translate="yes" xml:space="preserve">
          <source>Convert a date and time, specified by the &lt;code&gt;tm&lt;/code&gt; argument, into a time in seconds, as returned by &lt;a href=&quot;unixlabels#VALtime&quot;&gt;&lt;code&gt;UnixLabels.time&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;tm&lt;/code&gt; 인수로 지정된 날짜 및 시간 을 &lt;a href=&quot;unixlabels#VALtime&quot;&gt; &lt;code&gt;UnixLabels.time&lt;/code&gt; 에서&lt;/a&gt; 반환하는 초 단위의 시간으로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="7836de995e3285dfa0c8406853b5347a044422f1" translate="yes" xml:space="preserve">
          <source>Convert a date and time, specified by the &lt;code&gt;tm&lt;/code&gt; argument, into a time in seconds, as returned by &lt;a href=&quot;unixlabels#VALtime&quot;&gt;&lt;code&gt;UnixLabels.time&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;tm_isdst&lt;/code&gt;, &lt;code&gt;tm_wday&lt;/code&gt; and &lt;code&gt;tm_yday&lt;/code&gt; fields of &lt;code&gt;tm&lt;/code&gt; are ignored. Also return a normalized copy of the given &lt;code&gt;tm&lt;/code&gt; record, with the &lt;code&gt;tm_wday&lt;/code&gt;, &lt;code&gt;tm_yday&lt;/code&gt;, and &lt;code&gt;tm_isdst&lt;/code&gt; fields recomputed from the other fields, and the other fields normalized (so that, e.g., 40 October is changed into 9 November). The &lt;code&gt;tm&lt;/code&gt; argument is interpreted in the local time zone.</source>
          <target state="translated">&lt;code&gt;tm&lt;/code&gt; 인수로 지정된 날짜 및 시간 을 &lt;a href=&quot;unixlabels#VALtime&quot;&gt; &lt;code&gt;UnixLabels.time&lt;/code&gt; 에서&lt;/a&gt; 반환하는 초 단위의 시간으로 변환 합니다. &lt;code&gt;tm&lt;/code&gt; 의 &lt;code&gt;tm_isdst&lt;/code&gt; , &lt;code&gt;tm_wday&lt;/code&gt; 및 &lt;code&gt;tm_yday&lt;/code&gt; 필드 는 무시됩니다. 또한 &lt;code&gt;tm_wday&lt;/code&gt; , &lt;code&gt;tm_yday&lt;/code&gt; 및 &lt;code&gt;tm_isdst&lt;/code&gt; 필드가 다른 필드에서 재 계산되고 다른 필드가 정규화 된 (예 : 10 월 40 일이 11 월 9 일로 변경됨) 지정된 &lt;code&gt;tm&lt;/code&gt; 레코드 의 정규화 된 사본을 반환합니다 . &lt;code&gt;tm&lt;/code&gt; 인수는 로컬 타임 존으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="b9ed34778c74b1876e28a09ef2bb4037d0b1602b" translate="yes" xml:space="preserve">
          <source>Convert a hexadecimal representation back into the corresponding digest.</source>
          <target state="translated">16 진수 표현을 해당 다이제스트로 다시 변환합니다.</target>
        </trans-unit>
        <trans-unit id="80ace682affc7ecae8d4105bd127d456bb9e4912" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unix#VALtime&quot;&gt;&lt;code&gt;Unix.time&lt;/code&gt;&lt;/a&gt;, into a date and a time.</source>
          <target state="translated">&lt;a href=&quot;unix#VALtime&quot;&gt; &lt;code&gt;Unix.time&lt;/code&gt; &lt;/a&gt; 에서 반환 한 초 단위의 시간을 날짜와 시간으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2edee9666a075f72e6c7a588f50ef593d07338fc" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unix#VALtime&quot;&gt;&lt;code&gt;Unix.time&lt;/code&gt;&lt;/a&gt;, into a date and a time. Assumes UTC (Coordinated Universal Time), also known as GMT. To perform the inverse conversion, set the TZ environment variable to &quot;UTC&quot;, use &lt;a href=&quot;unix#VALmktime&quot;&gt;&lt;code&gt;Unix.mktime&lt;/code&gt;&lt;/a&gt;, and then restore the original value of TZ.</source>
          <target state="translated">&lt;a href=&quot;unix#VALtime&quot;&gt; &lt;code&gt;Unix.time&lt;/code&gt; &lt;/a&gt; 에서 반환 한 초 단위의 시간을 날짜와 시간으로 변환합니다. GMT라고도하는 UTC (협정 세계시)를 가정합니다. 역변환을 수행하려면 TZ 환경 변수를 &quot;UTC&quot;로 설정하고 &lt;a href=&quot;unix#VALmktime&quot;&gt; &lt;code&gt;Unix.mktime&lt;/code&gt; 을 사용한&lt;/a&gt; 다음 TZ의 원래 값을 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="f5a03657cb3a62a7760f59bceeacb0c77fd66446" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unix#VALtime&quot;&gt;&lt;code&gt;Unix.time&lt;/code&gt;&lt;/a&gt;, into a date and a time. Assumes the local time zone. The function performing the inverse conversion is &lt;a href=&quot;unix#VALmktime&quot;&gt;&lt;code&gt;Unix.mktime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALtime&quot;&gt; &lt;code&gt;Unix.time&lt;/code&gt; &lt;/a&gt; 에서 반환 한 초 단위의 시간을 날짜와 시간으로 변환합니다. 현지 시간대를 가정합니다. 역변환을 수행하는 함수는 &lt;a href=&quot;unix#VALmktime&quot;&gt; &lt;code&gt;Unix.mktime&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2bc9a0b90092a31e3fd77ab9bbe39a71117dbb38" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unixlabels#VALtime&quot;&gt;&lt;code&gt;UnixLabels.time&lt;/code&gt;&lt;/a&gt;, into a date and a time.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALtime&quot;&gt; &lt;code&gt;UnixLabels.time&lt;/code&gt; &lt;/a&gt; 에서 반환 된 시간 (초)을 날짜와 시간으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="aeb5627989cc9828b7f0b2b5062d617c78dd2e67" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unixlabels#VALtime&quot;&gt;&lt;code&gt;UnixLabels.time&lt;/code&gt;&lt;/a&gt;, into a date and a time. Assumes UTC (Coordinated Universal Time), also known as GMT.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALtime&quot;&gt; &lt;code&gt;UnixLabels.time&lt;/code&gt; &lt;/a&gt; 에서 반환 된 시간 (초)을 날짜와 시간으로 변환합니다. GMT라고도하는 UTC (협정 세계시)를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="4e49f724bd9a1b75ab1bd5c379646f6a4ff69bc3" translate="yes" xml:space="preserve">
          <source>Convert a time in seconds, as returned by &lt;a href=&quot;unixlabels#VALtime&quot;&gt;&lt;code&gt;UnixLabels.time&lt;/code&gt;&lt;/a&gt;, into a date and a time. Assumes the local time zone.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALtime&quot;&gt; &lt;code&gt;UnixLabels.time&lt;/code&gt; &lt;/a&gt; 에서 반환 된 시간 (초)을 날짜와 시간으로 변환합니다. 현지 시간대를 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f93ecd2ce5ab11da436caae653e82540aed74786" translate="yes" xml:space="preserve">
          <source>Convert an error description to a printable message.</source>
          <target state="translated">오류 설명을 인쇄 가능한 메시지로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="03cb0b9780f37bd211d882819f132343734c8465" translate="yes" xml:space="preserve">
          <source>Convert an integer to floating-point.</source>
          <target state="translated">정수를 부동 소수점으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f3cef616f14d50a47152db143f35cc307563ca92" translate="yes" xml:space="preserve">
          <source>Convert the given 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;) to a 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;).</source>
          <target state="translated">주어진 32 비트 정수 ( &lt;code&gt;int32&lt;/code&gt; 형식 )를 64 비트 정수 ( &lt;code&gt;int64&lt;/code&gt; 형식 )로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="411b3a0b25ac912caaa9c2f1d7ed837e3af70f3f" translate="yes" xml:space="preserve">
          <source>Convert the given 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;) to a native integer.</source>
          <target state="translated">주어진 32 비트 정수 ( &lt;code&gt;int32&lt;/code&gt; 유형 )를 기본 정수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="1be3acecc320ef8bb4b8ad656c48b398c14be616" translate="yes" xml:space="preserve">
          <source>Convert the given 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;) to an integer (type &lt;code&gt;int&lt;/code&gt;).</source>
          <target state="translated">주어진 32 비트 정수 ( &lt;code&gt;int32&lt;/code&gt; 형식 )를 정수 ( &lt;code&gt;int&lt;/code&gt; 형식)로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="93f62b9cc8d76e35705b0ce4bdbf71d21a9df25e" translate="yes" xml:space="preserve">
          <source>Convert the given 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;) to an integer (type &lt;code&gt;int&lt;/code&gt;). On 32-bit platforms, the 32-bit integer is taken modulo 2&lt;sup&gt;31&lt;/sup&gt;, i.e. the high-order bit is lost during the conversion. On 64-bit platforms, the conversion is exact.</source>
          <target state="translated">주어진 32 비트 정수 ( &lt;code&gt;int32&lt;/code&gt; 형식 )를 정수 ( &lt;code&gt;int&lt;/code&gt; 형식)로 변환합니다 . 32 비트 플랫폼에서 32 비트 정수는 모듈로 2 &lt;sup&gt;31을&lt;/sup&gt; 취합니다 . 즉, 상위 비트는 변환 중에 손실됩니다. 64 비트 플랫폼에서는 변환이 정확합니다.</target>
        </trans-unit>
        <trans-unit id="014bbb3bbf0643a138bb48038c7eaab32ae13c44" translate="yes" xml:space="preserve">
          <source>Convert the given 32-bit integer to a floating-point number.</source>
          <target state="translated">주어진 32 비트 정수를 부동 소수점 숫자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="9f59aef95dedbe83b6777c4e724a128aced4162e" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;) to a 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;).</source>
          <target state="translated">주어진 64 비트 정수 ( &lt;code&gt;int64&lt;/code&gt; 형식 )를 32 비트 정수 ( &lt;code&gt;int32&lt;/code&gt; 형식 )로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2a8c52d49afae53eeb13c5e454150dfee5751bcf" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;) to a 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;). The 64-bit integer is taken modulo 2&lt;sup&gt;32&lt;/sup&gt;, i.e. the top 32 bits are lost during the conversion.</source>
          <target state="translated">주어진 64 비트 정수 ( &lt;code&gt;int64&lt;/code&gt; 형식 )를 32 비트 정수 ( &lt;code&gt;int32&lt;/code&gt; 형식 )로 변환합니다. 64 비트 정수는 모듈로 2 &lt;sup&gt;32를&lt;/sup&gt; 취합니다 . 즉, 상위 32 비트는 변환 중에 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="c54dd450fd275471e93b471cb0a1d306996989fe" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;) to a native integer.</source>
          <target state="translated">주어진 64 비트 정수 ( &lt;code&gt;int64&lt;/code&gt; 형식 )를 네이티브 정수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3cca923cfddf0036de4f3e2ea85fc94c1f82ef40" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;) to a native integer. On 32-bit platforms, the 64-bit integer is taken modulo 2&lt;sup&gt;32&lt;/sup&gt;. On 64-bit platforms, the conversion is exact.</source>
          <target state="translated">주어진 64 비트 정수 ( &lt;code&gt;int64&lt;/code&gt; 형식 )를 네이티브 정수로 변환합니다. 32 비트 플랫폼에서 64 비트 정수는 모듈로 2 &lt;sup&gt;32&lt;/sup&gt; 취 합니다. 64 비트 플랫폼에서는 변환이 정확합니다.</target>
        </trans-unit>
        <trans-unit id="a8506d7c598044a6201c1a0f6c8f93251b1073a0" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;) to an integer (type &lt;code&gt;int&lt;/code&gt;).</source>
          <target state="translated">주어진 64 비트 정수 ( &lt;code&gt;int64&lt;/code&gt; 형식 )를 정수 ( &lt;code&gt;int&lt;/code&gt; 형식)로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="95b8e9bc57fe5a67ea7ffcefe1594c337c38a927" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;) to an integer (type &lt;code&gt;int&lt;/code&gt;). On 64-bit platforms, the 64-bit integer is taken modulo 2&lt;sup&gt;63&lt;/sup&gt;, i.e. the high-order bit is lost during the conversion. On 32-bit platforms, the 64-bit integer is taken modulo 2&lt;sup&gt;31&lt;/sup&gt;, i.e. the top 33 bits are lost during the conversion.</source>
          <target state="translated">주어진 64 비트 정수 ( &lt;code&gt;int64&lt;/code&gt; 형식 )를 정수 ( &lt;code&gt;int&lt;/code&gt; 형식)로 변환합니다 . 64 비트 플랫폼에서 64 비트 정수는 모듈로 2 &lt;sup&gt;63을&lt;/sup&gt; 취합니다 . 즉, 상위 비트는 변환 중에 손실됩니다. 32 비트 플랫폼에서 64 비트 정수는 모듈로 2 &lt;sup&gt;31을&lt;/sup&gt; 취합니다 . 즉, 상위 33 비트는 변환 중에 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="9c6929450b6383bc9247464a59404dd3a1bdd763" translate="yes" xml:space="preserve">
          <source>Convert the given 64-bit integer to a floating-point number.</source>
          <target state="translated">주어진 64 비트 정수를 부동 소수점 숫자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b64aaae03809d3b5a65a5b282cb97472c52416af" translate="yes" xml:space="preserve">
          <source>Convert the given character to its equivalent lowercase character, using the ISO Latin-1 (8859-1) character set.</source>
          <target state="translated">ISO Latin-1 (8859-1) 문자 세트를 사용하여 주어진 문자를 동등한 소문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="1cef781019641479d8714145b7af1e60404822ad" translate="yes" xml:space="preserve">
          <source>Convert the given character to its equivalent lowercase character, using the US-ASCII character set.</source>
          <target state="translated">US-ASCII 문자 세트를 사용하여 주어진 문자를 동등한 소문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="10738094bd74009109a3d94ef91c5ed6b5c299bf" translate="yes" xml:space="preserve">
          <source>Convert the given character to its equivalent uppercase character, using the ISO Latin-1 (8859-1) character set.</source>
          <target state="translated">ISO Latin-1 (8859-1) 문자 세트를 사용하여 주어진 문자를 동등한 대문자로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="dc257554c0317b3dd5566d489ad3fde9331403d9" translate="yes" xml:space="preserve">
          <source>Convert the given character to its equivalent uppercase character, using the US-ASCII character set.</source>
          <target state="translated">US-ASCII 문자 집합을 사용하여 주어진 문자를 해당하는 대문자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="bf675d948a6aff1ee29c25ddcb8bee6dd88d8aec" translate="yes" xml:space="preserve">
          <source>Convert the given floating-point number to a 32-bit integer, discarding the fractional part (truncate towards 0).</source>
          <target state="translated">주어진 부동 소수점 숫자를 32 비트 정수로 변환하여 소수 부분을 버립니다 (0으로 자름).</target>
        </trans-unit>
        <trans-unit id="c2af0a4c1e0f6e2efe957e1a8efff3d2473b8403" translate="yes" xml:space="preserve">
          <source>Convert the given floating-point number to a 32-bit integer, discarding the fractional part (truncate towards 0). The result of the conversion is undefined if, after truncation, the number is outside the range [&lt;a href=&quot;int32#VALmin_int&quot;&gt;&lt;code&gt;Int32.min_int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;int32#VALmax_int&quot;&gt;&lt;code&gt;Int32.max_int&lt;/code&gt;&lt;/a&gt;].</source>
          <target state="translated">주어진 부동 소수점 숫자를 32 비트 정수로 변환하여 소수 부분을 버립니다 (0으로 자름). 잘린 후 숫자가 [ &lt;a href=&quot;int32#VALmin_int&quot;&gt; &lt;code&gt;Int32.min_int&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;int32#VALmax_int&quot;&gt; &lt;code&gt;Int32.max_int&lt;/code&gt; &lt;/a&gt; ] 범위를 벗어나면 변환 결과가 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5fcb051564865ed8de2eb491570af0a4f45f4edd" translate="yes" xml:space="preserve">
          <source>Convert the given floating-point number to a 64-bit integer, discarding the fractional part (truncate towards 0).</source>
          <target state="translated">주어진 부동 소수점 숫자를 64 비트 정수로 변환하여 소수 부분을 버립니다 (0으로 자름).</target>
        </trans-unit>
        <trans-unit id="580bb45852738cdd647d7446f484386b0a804244" translate="yes" xml:space="preserve">
          <source>Convert the given floating-point number to a 64-bit integer, discarding the fractional part (truncate towards 0). The result of the conversion is undefined if, after truncation, the number is outside the range [&lt;a href=&quot;int64#VALmin_int&quot;&gt;&lt;code&gt;Int64.min_int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;int64#VALmax_int&quot;&gt;&lt;code&gt;Int64.max_int&lt;/code&gt;&lt;/a&gt;].</source>
          <target state="translated">주어진 부동 소수점 숫자를 64 비트 정수로 변환하여 소수 부분을 버립니다 (0으로 자름). 잘린 후 숫자가 [ &lt;a href=&quot;int64#VALmin_int&quot;&gt; &lt;code&gt;Int64.min_int&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;int64#VALmax_int&quot;&gt; &lt;code&gt;Int64.max_int&lt;/code&gt; &lt;/a&gt; ] 범위를 벗어나면 변환 결과가 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5031b270a977528f20d0e7a11194d07248c96172" translate="yes" xml:space="preserve">
          <source>Convert the given floating-point number to a native integer, discarding the fractional part (truncate towards 0).</source>
          <target state="translated">주어진 부동 소수점 숫자를 기본 정수로 변환하고 소수 부분을 버립니다 (0으로 자름).</target>
        </trans-unit>
        <trans-unit id="1725d3597c69c9439f05f46ee38743a2c137c782" translate="yes" xml:space="preserve">
          <source>Convert the given floating-point number to a native integer, discarding the fractional part (truncate towards 0). The result of the conversion is undefined if, after truncation, the number is outside the range [&lt;a href=&quot;nativeint#VALmin_int&quot;&gt;&lt;code&gt;Nativeint.min_int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;nativeint#VALmax_int&quot;&gt;&lt;code&gt;Nativeint.max_int&lt;/code&gt;&lt;/a&gt;].</source>
          <target state="translated">주어진 부동 소수점 숫자를 기본 정수로 변환하고 소수 부분을 버립니다 (0으로 자름). 잘린 후 숫자가 [ &lt;a href=&quot;nativeint#VALmin_int&quot;&gt; &lt;code&gt;Nativeint.min_int&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;nativeint#VALmax_int&quot;&gt; &lt;code&gt;Nativeint.max_int&lt;/code&gt; &lt;/a&gt; ] 범위를 벗어나면 변환 결과가 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6050cb5e0048524aee2d160ae0cce485161ded2d" translate="yes" xml:space="preserve">
          <source>Convert the given integer (type &lt;code&gt;int&lt;/code&gt;) to a 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;).</source>
          <target state="translated">주어진 정수 ( &lt;code&gt;int&lt;/code&gt; 형식 )를 32 비트 정수 ( &lt;code&gt;int32&lt;/code&gt; 형식 )로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c3887945b57ea121fcdf0f14b5a759fdbaad36e7" translate="yes" xml:space="preserve">
          <source>Convert the given integer (type &lt;code&gt;int&lt;/code&gt;) to a 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;). On 64-bit platforms, the argument is taken modulo 2&lt;sup&gt;32&lt;/sup&gt;.</source>
          <target state="translated">주어진 정수 ( &lt;code&gt;int&lt;/code&gt; 형식 )를 32 비트 정수 ( &lt;code&gt;int32&lt;/code&gt; 형식 )로 변환합니다. 64 비트 플랫폼에서 인수는 모듈로 2 &lt;sup&gt;32를&lt;/sup&gt; 취 합니다.</target>
        </trans-unit>
        <trans-unit id="4debd3cb988d635b8f41534836b6a2b48d409ed0" translate="yes" xml:space="preserve">
          <source>Convert the given integer (type &lt;code&gt;int&lt;/code&gt;) to a 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;).</source>
          <target state="translated">주어진 정수 ( &lt;code&gt;int&lt;/code&gt; 형식 )를 64 비트 정수 ( &lt;code&gt;int64&lt;/code&gt; 형식 )로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4921b162e3c39cc7cd9396df60a318a087afa590" translate="yes" xml:space="preserve">
          <source>Convert the given integer (type &lt;code&gt;int&lt;/code&gt;) to a native integer (type &lt;code&gt;nativeint&lt;/code&gt;).</source>
          <target state="translated">주어진 정수 ( &lt;code&gt;int&lt;/code&gt; 형식 )를 네이티브 정수 ( &lt;code&gt;nativeint&lt;/code&gt; 형식)로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="dd3c57e865f3508e17aade52701128e682c09fd7" translate="yes" xml:space="preserve">
          <source>Convert the given native integer (type &lt;code&gt;nativeint&lt;/code&gt;) to a 64-bit integer (type &lt;code&gt;int64&lt;/code&gt;).</source>
          <target state="translated">지정된 네이티브 정수 ( &lt;code&gt;nativeint&lt;/code&gt; 형식 )를 64 비트 정수 ( &lt;code&gt;int64&lt;/code&gt; 형식 )로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="63c44f46b0858567098c36f81e612d99fcc9adc8" translate="yes" xml:space="preserve">
          <source>Convert the given native integer (type &lt;code&gt;nativeint&lt;/code&gt;) to an integer (type &lt;code&gt;int&lt;/code&gt;).</source>
          <target state="translated">주어진 네이티브 정수 ( &lt;code&gt;nativeint&lt;/code&gt; 형식 )를 정수 ( &lt;code&gt;int&lt;/code&gt; 형식)로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="da94aa8d40c08299bdebdd7ca1f19bdf6f8a60cb" translate="yes" xml:space="preserve">
          <source>Convert the given native integer (type &lt;code&gt;nativeint&lt;/code&gt;) to an integer (type &lt;code&gt;int&lt;/code&gt;). The high-order bit is lost during the conversion.</source>
          <target state="translated">주어진 네이티브 정수 ( &lt;code&gt;nativeint&lt;/code&gt; 형식 )를 정수 ( &lt;code&gt;int&lt;/code&gt; 형식)로 변환합니다 . 상위 비트는 변환 중에 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="9cc4c17f687227c32c9382b73f0b0e3cba1ffd79" translate="yes" xml:space="preserve">
          <source>Convert the given native integer to a 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;).</source>
          <target state="translated">주어진 네이티브 정수를 32 비트 정수로 변환합니다 ( &lt;code&gt;int32&lt;/code&gt; 형식 ).</target>
        </trans-unit>
        <trans-unit id="f14b0131a571b73ccad1485e208ed7eab1af27b0" translate="yes" xml:space="preserve">
          <source>Convert the given native integer to a 32-bit integer (type &lt;code&gt;int32&lt;/code&gt;). On 64-bit platforms, the 64-bit native integer is taken modulo 2&lt;sup&gt;32&lt;/sup&gt;, i.e. the top 32 bits are lost. On 32-bit platforms, the conversion is exact.</source>
          <target state="translated">주어진 네이티브 정수를 32 비트 정수로 변환합니다 ( &lt;code&gt;int32&lt;/code&gt; 형식 ). 64 비트 플랫폼에서 64 비트 기본 정수는 모듈로 2 &lt;sup&gt;32를&lt;/sup&gt; 취합니다 . 즉, 상위 32 비트가 손실됩니다. 32 비트 플랫폼에서는 변환이 정확합니다.</target>
        </trans-unit>
        <trans-unit id="b84b8167237f0e84a7eba52f0611f41b25ced1e1" translate="yes" xml:space="preserve">
          <source>Convert the given native integer to a floating-point number.</source>
          <target state="translated">주어진 기본 정수를 부동 소수점 숫자로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="7c7d3886a056c01164226ca8f21d8885519399a9" translate="yes" xml:space="preserve">
          <source>Convert the given string to a 32-bit integer.</source>
          <target state="translated">주어진 문자열을 32 비트 정수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="f2799240478510b8655a29381484f108391a1adb" translate="yes" xml:space="preserve">
          <source>Convert the given string to a 32-bit integer. The string is read in decimal (by default, or if the string begins with &lt;code&gt;0u&lt;/code&gt;) or in hexadecimal, octal or binary if the string begins with &lt;code&gt;0x&lt;/code&gt;, &lt;code&gt;0o&lt;/code&gt; or &lt;code&gt;0b&lt;/code&gt; respectively.</source>
          <target state="translated">주어진 문자열을 32 비트 정수로 변환합니다. 문자열은 10 진수 (기본적으로 또는 문자열이 &lt;code&gt;0u&lt;/code&gt; 로 시작하는 경우 ) 또는 문자열이 각각 &lt;code&gt;0x&lt;/code&gt; , &lt;code&gt;0o&lt;/code&gt; 또는 &lt;code&gt;0b&lt;/code&gt; 로 시작하는 경우 16 진수, 8 진수 또는 2 진수 로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="c0d4202b90328e10c2df68813b3b1f8eb79b0f98" translate="yes" xml:space="preserve">
          <source>Convert the given string to a 64-bit integer.</source>
          <target state="translated">주어진 문자열을 64 비트 정수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="fd390af034ba87ea38383f34f7b32709bfd5568f" translate="yes" xml:space="preserve">
          <source>Convert the given string to a 64-bit integer. The string is read in decimal (by default, or if the string begins with &lt;code&gt;0u&lt;/code&gt;) or in hexadecimal, octal or binary if the string begins with &lt;code&gt;0x&lt;/code&gt;, &lt;code&gt;0o&lt;/code&gt; or &lt;code&gt;0b&lt;/code&gt; respectively.</source>
          <target state="translated">주어진 문자열을 64 비트 정수로 변환합니다. 문자열은 10 진수 (기본적으로 또는 문자열이 &lt;code&gt;0u&lt;/code&gt; 로 시작하는 경우 ) 또는 문자열이 각각 &lt;code&gt;0x&lt;/code&gt; , &lt;code&gt;0o&lt;/code&gt; 또는 &lt;code&gt;0b&lt;/code&gt; 로 시작하는 경우 16 진수, 8 진수 또는 2 진수 로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="046905d098af9c9b18df1bfb0e99207e44814271" translate="yes" xml:space="preserve">
          <source>Convert the given string to a boolean.</source>
          <target state="translated">주어진 문자열을 부울로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3cb27f7eac6e919033f75b4bb9b0ad927cf3a2cc" translate="yes" xml:space="preserve">
          <source>Convert the given string to a float.</source>
          <target state="translated">주어진 문자열을 부동 소수점으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e405970d44a177d8f59d8de438813e89e623f942" translate="yes" xml:space="preserve">
          <source>Convert the given string to a float. The string is read in decimal (by default) or in hexadecimal (marked by &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;).</source>
          <target state="translated">주어진 문자열을 부동 소수점으로 변환합니다. 문자열은 10 진수 (기본값) 또는 16 진수 ( &lt;code&gt;0x&lt;/code&gt; 또는 &lt;code&gt;0X&lt;/code&gt; 로 표시)로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="c724ac3d5dc6e9e705e1e17a5f0ea7c150159b6b" translate="yes" xml:space="preserve">
          <source>Convert the given string to a float. The string is read in decimal (by default) or in hexadecimal (marked by &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;). The format of decimal floating-point numbers is &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;dd.ddd&amp;nbsp;(e|E)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; stands for a decimal digit. The format of hexadecimal floating-point numbers is &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;0(x|X)&amp;nbsp;hh.hhh&amp;nbsp;(p|P)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt;, where &lt;code&gt;h&lt;/code&gt; stands for an hexadecimal digit and &lt;code&gt;d&lt;/code&gt; for a decimal digit. In both cases, at least one of the integer and fractional parts must be given; the exponent part is optional. The &lt;code&gt;_&lt;/code&gt; (underscore) character can appear anywhere in the string and is ignored. Depending on the execution platforms, other representations of floating-point numbers can be accepted, but should not be relied upon.</source>
          <target state="translated">주어진 문자열을 부동 소수점으로 변환합니다. 문자열은 10 진수 (기본값) 또는 16 진수 ( &lt;code&gt;0x&lt;/code&gt; 또는 &lt;code&gt;0X&lt;/code&gt; 로 표시)로 읽습니다 . 10 진수 부동 소수점 숫자의 형식은 &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;dd.ddd&amp;nbsp;(e|E)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt; . 여기서 &lt;code&gt;d&lt;/code&gt; 는 10 진수를 나타냅니다. 16 진수 부동 소수점 숫자의 형식은 &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;0(x|X)&amp;nbsp;hh.hhh&amp;nbsp;(p|P)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt; . 여기서 &lt;code&gt;h&lt;/code&gt; 는 16 진수를 나타내고 &lt;code&gt;d&lt;/code&gt; 는 10 진수를 나타냅니다 . 두 경우 모두 정수 부분과 소수 부분 중 하나 이상을 제공해야합니다. 지수 부분은 선택 사항입니다. &lt;code&gt;_&lt;/code&gt; (밑줄) 문자는 문자열의 아무 곳에 나 나타날 수 있으며 무시됩니다. 실행 플랫폼에 따라 부동 소수점 숫자의 다른 표현이 허용 될 수 있지만 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b9970fe070e5622757e45b32117233a0163be3ba" translate="yes" xml:space="preserve">
          <source>Convert the given string to a native integer.</source>
          <target state="translated">주어진 문자열을 네이티브 정수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="a0a3df43f4c2b1e962a393e752d6bbadfbb2aff4" translate="yes" xml:space="preserve">
          <source>Convert the given string to a native integer. The string is read in decimal (by default, or if the string begins with &lt;code&gt;0u&lt;/code&gt;) or in hexadecimal, octal or binary if the string begins with &lt;code&gt;0x&lt;/code&gt;, &lt;code&gt;0o&lt;/code&gt; or &lt;code&gt;0b&lt;/code&gt; respectively.</source>
          <target state="translated">주어진 문자열을 네이티브 정수로 변환합니다. 문자열은 10 진수 (기본적으로 또는 문자열이 &lt;code&gt;0u&lt;/code&gt; 로 시작하는 경우 ) 또는 문자열이 각각 &lt;code&gt;0x&lt;/code&gt; , &lt;code&gt;0o&lt;/code&gt; 또는 &lt;code&gt;0b&lt;/code&gt; 로 시작하는 경우 16 진수, 8 진수 또는 2 진수 로 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="debd9a11f6bb577291b4caf3926d0227e1808f46" translate="yes" xml:space="preserve">
          <source>Convert the given string to an integer.</source>
          <target state="translated">주어진 문자열을 정수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c7206df3c20e1d25190b72034c967fc58a3ca235" translate="yes" xml:space="preserve">
          <source>Convert the given string to an integer. The string is read in decimal (by default, or if the string begins with &lt;code&gt;0u&lt;/code&gt;), in hexadecimal (if it begins with &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;), in octal (if it begins with &lt;code&gt;0o&lt;/code&gt; or &lt;code&gt;0O&lt;/code&gt;), or in binary (if it begins with &lt;code&gt;0b&lt;/code&gt; or &lt;code&gt;0B&lt;/code&gt;).</source>
          <target state="translated">주어진 문자열을 정수로 변환합니다. 문자열은 십진수로 읽기 (기본적으로, 또는 문자열로 시작되는 경우 &lt;code&gt;0u&lt;/code&gt; (가로 시작하는 경우 진수) &lt;code&gt;0x&lt;/code&gt; 또는 &lt;code&gt;0X&lt;/code&gt; (가 시작하면 8 진수) &lt;code&gt;0o&lt;/code&gt; 에서 또는 &lt;code&gt;0O&lt;/code&gt; 이 시작되는 경우 (진), 또는 와 &lt;code&gt;0b&lt;/code&gt; 또는 &lt;code&gt;0B&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3bcef0a610e933857faac2e83c490abb8af3cab1" translate="yes" xml:space="preserve">
          <source>Converting</source>
          <target state="translated">Converting</target>
        </trans-unit>
        <trans-unit id="796fed19f815a7871b9f55ad1bb6d03d63143aee" translate="yes" xml:space="preserve">
          <source>Converts a format string into a string.</source>
          <target state="translated">형식 문자열을 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="714801eba41aa2625b2a713ececaf6f421fd187f" translate="yes" xml:space="preserve">
          <source>Copy all elements of a Bigarray in another Bigarray.</source>
          <target state="translated">Bigarray의 모든 요소를 ​​다른 Bigarray에 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="f33c856c6fe179d2a83dff4070691e79ceca7dae" translate="yes" xml:space="preserve">
          <source>Copy all elements of a Bigarray in another Bigarray. &lt;code&gt;Genarray.blit&amp;nbsp;src&amp;nbsp;dst&lt;/code&gt; copies all elements of &lt;code&gt;src&lt;/code&gt; into &lt;code&gt;dst&lt;/code&gt;. Both arrays &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt; must have the same number of dimensions and equal dimensions. Copying a sub-array of &lt;code&gt;src&lt;/code&gt; to a sub-array of &lt;code&gt;dst&lt;/code&gt; can be achieved by applying &lt;code&gt;Genarray.blit&lt;/code&gt; to sub-array or slices of &lt;code&gt;src&lt;/code&gt; and &lt;code&gt;dst&lt;/code&gt;.</source>
          <target state="translated">Bigarray의 모든 요소를 ​​다른 Bigarray에 복사하십시오. &lt;code&gt;Genarray.blit&amp;nbsp;src&amp;nbsp;dst&lt;/code&gt; 는 &lt;code&gt;src&lt;/code&gt; 의 모든 요소 를 &lt;code&gt;dst&lt;/code&gt; 로 복사 합니다. &lt;code&gt;src&lt;/code&gt; 및 &lt;code&gt;dst&lt;/code&gt; 배열 모두 동일한 수의 차원과 동일한 차원을 가져야합니다. &lt;code&gt;src&lt;/code&gt; 의 하위 배열을 &lt;code&gt;dst&lt;/code&gt; 의 하위 배열에 복사하는 것은 &lt;code&gt;Genarray.blit&lt;/code&gt; 을 하위 배열 또는 &lt;code&gt;src&lt;/code&gt; 및 &lt;code&gt;dst&lt;/code&gt; 슬라이스 에 적용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f98913bf026616eee1f70a64e0abe6968048030" translate="yes" xml:space="preserve">
          <source>Copy the first Bigarray to the second Bigarray.</source>
          <target state="translated">첫 번째 Bigarray를 두 번째 Bigarray에 복사합니다.</target>
        </trans-unit>
        <trans-unit id="4e63802c10caf95b9698af675ba70745b8440d3c" translate="yes" xml:space="preserve">
          <source>Copy the first Bigarray to the second Bigarray. See &lt;a href=&quot;bigarray.genarray#VALblit&quot;&gt;&lt;code&gt;Bigarray.Genarray.blit&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">첫 번째 Bigarray를 두 번째 Bigarray에 복사합니다. 자세한 내용은 &lt;a href=&quot;bigarray.genarray#VALblit&quot;&gt; &lt;code&gt;Bigarray.Genarray.blit&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="749a2a1ff67c24e1aaefeb4893cf456a09300335" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 2020 Institut National de Recherche en Informatique et en Automatique</source>
          <target state="translated">Copyright &amp;copy; 2020 Institut National de Recherche en Informatique et en en Automatique</target>
        </trans-unit>
        <trans-unit id="a9f0ee0d8c723707d5631f23f004103955272851" translate="yes" xml:space="preserve">
          <source>Correct use of exceptional return, in particular in the presence of garbage collection, is further detailed in Section &lt;a href=&quot;#ss%3Ac-callbacks&quot;&gt;20.7.1&lt;/a&gt;.</source>
          <target state="translated">특히 가비지 컬렉션이있는 경우 예외 반환의 올바른 사용은 섹션 &lt;a href=&quot;#ss%3Ac-callbacks&quot;&gt;20.7.1에&lt;/a&gt; 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9221f888b1436de6082936ddd6d55309f806fb1b" translate="yes" xml:space="preserve">
          <source>Corrupted compiled interface filename</source>
          <target state="translated">컴파일 된 인터페이스 파일 이름이 손상되었습니다.</target>
        </trans-unit>
        <trans-unit id="7a82a6d806181e70fe9be0edf237bd49a8998364" translate="yes" xml:space="preserve">
          <source>Cosine.</source>
          <target state="translated">Cosine.</target>
        </trans-unit>
        <trans-unit id="3909ef6abac31cfe9a35b22ea080c9d194f203ef" translate="yes" xml:space="preserve">
          <source>Cosine. Argument is in radians.</source>
          <target state="translated">코사인. 인수는 라디안입니다.</target>
        </trans-unit>
        <trans-unit id="72cd010c4394bea276d4bdb151886625642b9b8b" translate="yes" xml:space="preserve">
          <source>Count the number of elements in the table.</source>
          <target state="translated">테이블의 요소 수를 세십시오.</target>
        </trans-unit>
        <trans-unit id="e082d8bf67432c245dd736e9ca7132061f24ca80" translate="yes" xml:space="preserve">
          <source>Count the number of elements in the table. &lt;code&gt;count&amp;nbsp;t&lt;/code&gt; gives the same result as &lt;code&gt;fold&amp;nbsp;(fun&amp;nbsp;_&amp;nbsp;n&amp;nbsp;-&amp;gt;&amp;nbsp;n+1)&amp;nbsp;t&amp;nbsp;0&lt;/code&gt; but does not delay the deallocation of the dead elements.</source>
          <target state="translated">테이블의 요소 수를 세십시오. &lt;code&gt;count&amp;nbsp;t&lt;/code&gt; 는 &lt;code&gt;fold&amp;nbsp;(fun&amp;nbsp;_&amp;nbsp;n&amp;nbsp;-&amp;gt;&amp;nbsp;n+1)&amp;nbsp;t&amp;nbsp;0&lt;/code&gt; 과 동일한 결과를 제공 하지만 죽은 요소의 할당 해제를 지연시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec5cab66331e1f63a891d845b54e584c2f2ac037" translate="yes" xml:space="preserve">
          <source>Create a buffer from the generator</source>
          <target state="translated">생성기에서 버퍼 만들기</target>
        </trans-unit>
        <trans-unit id="19e34d2262662f5708968cd7624e835c13757358" translate="yes" xml:space="preserve">
          <source>Create a directory with the given permissions (see &lt;a href=&quot;unix#VALumask&quot;&gt;&lt;code&gt;Unix.umask&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">주어진 권한으로 디렉토리를 만듭니다 ( &lt;a href=&quot;unix#VALumask&quot;&gt; &lt;code&gt;Unix.umask&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="70d3168ae617afccee2b8028fe4d89dc16e329c7" translate="yes" xml:space="preserve">
          <source>Create a directory with the given permissions.</source>
          <target state="translated">주어진 권한으로 디렉토리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="dc44996afbaa5cd1d76fa615bb2991b6a12175a4" translate="yes" xml:space="preserve">
          <source>Create a lexer buffer on the given input channel.</source>
          <target state="translated">주어진 입력 채널에 렉서 버퍼를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5143503b6006ea03b7e3bd6f9b08f1d8aa2fdea1" translate="yes" xml:space="preserve">
          <source>Create a lexer buffer on the given input channel. &lt;code&gt;Lexing.from_channel&amp;nbsp;inchan&lt;/code&gt; returns a lexer buffer which reads from the input channel &lt;code&gt;inchan&lt;/code&gt;, at the current reading position.</source>
          <target state="translated">주어진 입력 채널에 렉서 버퍼를 만듭니다. &lt;code&gt;Lexing.from_channel&amp;nbsp;inchan&lt;/code&gt; 은 현재 읽기 위치에서 입력 채널 &lt;code&gt;inchan&lt;/code&gt; 에서 읽는 렉서 버퍼를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e81abb60f55d65a6d038b5d9a363404318029de3" translate="yes" xml:space="preserve">
          <source>Create a lexer buffer which reads from the given string.</source>
          <target state="translated">주어진 문자열에서 읽는 렉서 버퍼를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6407d31fa51c4c55eb4598c03876535a93c6952f" translate="yes" xml:space="preserve">
          <source>Create a lexer buffer which reads from the given string. Reading starts from the first character in the string. An end-of-input condition is generated when the end of the string is reached.</source>
          <target state="translated">주어진 문자열에서 읽는 렉서 버퍼를 만듭니다. 읽기는 문자열의 첫 번째 문자부터 시작됩니다. 문자열 끝에 도달하면 입력 끝 조건이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="190ca8ac4f2c64e047dbc76197c1ff595fa6b031" translate="yes" xml:space="preserve">
          <source>Create a lexer buffer with the given function as its reading method.</source>
          <target state="translated">주어진 함수를 읽기 방법으로 사용하여 렉서 버퍼를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a8735b8a50290dcf794da46bfe74dd3527a8550a" translate="yes" xml:space="preserve">
          <source>Create a lexer buffer with the given function as its reading method. When the scanner needs more characters, it will call the given function, giving it a byte sequence &lt;code&gt;s&lt;/code&gt; and a byte count &lt;code&gt;n&lt;/code&gt;. The function should put &lt;code&gt;n&lt;/code&gt; bytes or fewer in &lt;code&gt;s&lt;/code&gt;, starting at index 0, and return the number of bytes provided. A return value of 0 means end of input.</source>
          <target state="translated">주어진 함수를 읽기 방법으로 사용하여 렉서 버퍼를 만듭니다. 스캐너에 더 많은 문자가 필요하면 주어진 함수를 호출하여 바이트 시퀀스 &lt;code&gt;s&lt;/code&gt; 및 바이트 수 &lt;code&gt;n&lt;/code&gt; 을 제공 합니다. 이 함수는 &lt;code&gt;s&lt;/code&gt; 에 인덱스 0부터 시작하여 &lt;code&gt;n&lt;/code&gt; 바이트 이하를 입력 하고 제공된 바이트 수를 반환해야합니다. 반환 값 0은 입력 종료를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="30ba288a50ae1fece1cf0423426f78280eed622a" translate="yes" xml:space="preserve">
          <source>Create a list from the iterator</source>
          <target state="translated">반복기에서 목록 만들기</target>
        </trans-unit>
        <trans-unit id="3456a1163b51311f839b8cf00cd30de750a651d3" translate="yes" xml:space="preserve">
          <source>Create a named pipe with the given permissions (see &lt;a href=&quot;unix#VALumask&quot;&gt;&lt;code&gt;Unix.umask&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">주어진 권한으로 명명 된 파이프를 만듭니다 ( &lt;a href=&quot;unix#VALumask&quot;&gt; &lt;code&gt;Unix.umask&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a3d10d804380675a899416b24f92318eeb66d264" translate="yes" xml:space="preserve">
          <source>Create a named pipe with the given permissions (see &lt;a href=&quot;unix#VALumask&quot;&gt;&lt;code&gt;Unix.umask&lt;/code&gt;&lt;/a&gt;). On Windows: not implemented.</source>
          <target state="translated">주어진 권한으로 명명 된 파이프를 만듭니다 ( &lt;a href=&quot;unix#VALumask&quot;&gt; &lt;code&gt;Unix.umask&lt;/code&gt; &lt;/a&gt; 참조 ). Windows : 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c2fdff70665a56d05f0ee5d27d9da24708eb1894" translate="yes" xml:space="preserve">
          <source>Create a named pipe with the given permissions.</source>
          <target state="translated">주어진 권한으로 명명 된 파이프를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="aa1a16120ae466a832076e7d380310e5ff6301b8" translate="yes" xml:space="preserve">
          <source>Create a new socket in the given domain, and with the given kind.</source>
          <target state="translated">주어진 도메인에 주어진 종류로 새 소켓을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="093f73e0ca46114cb3907dbd3c6ba4b8e4823414" translate="yes" xml:space="preserve">
          <source>Create a new socket in the given domain, and with the given kind. The third argument is the protocol type; 0 selects the default protocol for that kind of sockets.</source>
          <target state="translated">주어진 도메인에 주어진 종류로 새 소켓을 만듭니다. 세 번째 인수는 프로토콜 유형입니다. 0은 해당 종류의 소켓에 대한 기본 프로토콜을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="3f3cf678cd161d0a98fd3f5d42b3cb008ce1a48a" translate="yes" xml:space="preserve">
          <source>Create a new socket in the given domain, and with the given kind. The third argument is the protocol type; 0 selects the default protocol for that kind of sockets. See &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt;&lt;code&gt;Unix.set_close_on_exec&lt;/code&gt;&lt;/a&gt; for documentation on the &lt;code&gt;cloexec&lt;/code&gt; optional argument.</source>
          <target state="translated">주어진 도메인에 주어진 종류로 새 소켓을 만듭니다. 세 번째 인수는 프로토콜 유형입니다. 0은 해당 종류의 소켓에 대한 기본 프로토콜을 선택합니다. &lt;code&gt;cloexec&lt;/code&gt; 선택적 인수 에 대한 문서는 &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt; &lt;code&gt;Unix.set_close_on_exec&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="03a14162d305ff52f22126d9ba6cafa4d78574a8" translate="yes" xml:space="preserve">
          <source>Create a new state and initialize it with a system-dependent low-entropy seed.</source>
          <target state="translated">새 상태를 만들고 시스템 종속 낮은 엔트로피 시드로 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="9db61f76a5c74fd7a62aa832c9c1832527ee6e66" translate="yes" xml:space="preserve">
          <source>Create a new state and initialize it with the given seed.</source>
          <target state="translated">새 상태를 만들고 주어진 시드로 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="3b2f60955c649908da20c0760f6c08367ad20db1" translate="yes" xml:space="preserve">
          <source>Create a packing interface Mylib.ml, containing the following lines.</source>
          <target state="translated">다음 줄을 포함하는 패킹 인터페이스 Mylib.ml을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="533abcfd8c9a401ae37bd05c83664abd41b3978f" translate="yes" xml:space="preserve">
          <source>Create a pair of unnamed sockets, connected together.</source>
          <target state="translated">함께 연결된 이름없는 소켓 쌍을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f3b413102c7a4e886a94cd1ccf3432e8ee8a268c" translate="yes" xml:space="preserve">
          <source>Create a pair of unnamed sockets, connected together. See &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt;&lt;code&gt;Unix.set_close_on_exec&lt;/code&gt;&lt;/a&gt; for documentation on the &lt;code&gt;cloexec&lt;/code&gt; optional argument.</source>
          <target state="translated">함께 연결된 이름없는 소켓 쌍을 만듭니다. &lt;code&gt;cloexec&lt;/code&gt; 선택적 인수 에 대한 문서는 &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt; &lt;code&gt;Unix.set_close_on_exec&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ecb3637f50b940e9ab5fbcaa7d0e3d9d8adca50" translate="yes" xml:space="preserve">
          <source>Create a pipe.</source>
          <target state="translated">파이프를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="30af9bcb81b48bf202dd963116fe928f0c53fcfd" translate="yes" xml:space="preserve">
          <source>Create a pipe. The first component of the result is opened for reading, that's the exit to the pipe. The second component is opened for writing, that's the entrance to the pipe.</source>
          <target state="translated">파이프를 만듭니다. 결과의 첫 번째 구성 요소는 읽기를 위해 열립니다. 즉 파이프의 출구입니다. 두 번째 구성 요소는 쓰기를 위해 열립니다. 파이프 입구입니다.</target>
        </trans-unit>
        <trans-unit id="cd252b1ca191e7bced4e2176974be7bd120d4a47" translate="yes" xml:space="preserve">
          <source>Create a pipe. The first component of the result is opened for reading, that's the exit to the pipe. The second component is opened for writing, that's the entrance to the pipe. See &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt;&lt;code&gt;Unix.set_close_on_exec&lt;/code&gt;&lt;/a&gt; for documentation on the &lt;code&gt;cloexec&lt;/code&gt; optional argument.</source>
          <target state="translated">파이프를 만듭니다. 결과의 첫 번째 구성 요소는 읽기를 위해 열립니다. 즉 파이프의 출구입니다. 두 번째 구성 요소는 쓰기를 위해 열립니다. 파이프 입구입니다. &lt;code&gt;cloexec&lt;/code&gt; 선택적 인수 에 대한 문서는 &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt; &lt;code&gt;Unix.set_close_on_exec&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="21dc9f570d12477a38ca2a08e98e4c0750a86675" translate="yes" xml:space="preserve">
          <source>Create a queue from the generator</source>
          <target state="translated">생성기에서 대기열 만들기</target>
        </trans-unit>
        <trans-unit id="a770574699ea3d33080750f7cc2703aad4c9a772" translate="yes" xml:space="preserve">
          <source>Create a stack from the iterator</source>
          <target state="translated">반복기에서 스택 만들기</target>
        </trans-unit>
        <trans-unit id="ee45c92ea429789a619f70851af380b2976438fe" translate="yes" xml:space="preserve">
          <source>Create a string from the generator</source>
          <target state="translated">생성기에서 문자열 만들기</target>
        </trans-unit>
        <trans-unit id="4d42ea6eec79d2dc2d2ce4ff68459ef19908da18" translate="yes" xml:space="preserve">
          <source>Create an array from the generator</source>
          <target state="translated">생성기에서 배열 만들기</target>
        </trans-unit>
        <trans-unit id="eaa3a15a2bb90fcfee2212ff47808afd2d02c456" translate="yes" xml:space="preserve">
          <source>Create an array from the generator.</source>
          <target state="translated">생성기에서 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="47a23ab49072d38a59b186d4a3917b754a37143e" translate="yes" xml:space="preserve">
          <source>Create an input channel reading from the given descriptor.</source>
          <target state="translated">주어진 설명자에서 읽는 입력 채널을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1be3c0896f6ff928d2c5d93f64972c34596328b6" translate="yes" xml:space="preserve">
          <source>Create an input channel reading from the given descriptor. The channel is initially in binary mode; use &lt;code&gt;set_binary_mode_in&amp;nbsp;ic&amp;nbsp;false&lt;/code&gt; if text mode is desired.</source>
          <target state="translated">주어진 설명자에서 읽는 입력 채널을 만듭니다. 채널은 초기에 바이너리 모드입니다. 텍스트 모드가 필요한 경우 &lt;code&gt;set_binary_mode_in&amp;nbsp;ic&amp;nbsp;false&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="09b45b6f8c3f7cfba77d056c3802a69e5892dcce" translate="yes" xml:space="preserve">
          <source>Create an input channel reading from the given descriptor. The channel is initially in binary mode; use &lt;code&gt;set_binary_mode_in&amp;nbsp;ic&amp;nbsp;false&lt;/code&gt; if text mode is desired. Text mode is supported only if the descriptor refers to a file or pipe, but is not supported if it refers to a socket. On Windows, &lt;code&gt;set_binary_mode_in&lt;/code&gt; always fails on channels created with this function.</source>
          <target state="translated">주어진 설명자에서 읽는 입력 채널을 만듭니다. 채널은 초기에 바이너리 모드입니다. 텍스트 모드가 필요한 경우 &lt;code&gt;set_binary_mode_in&amp;nbsp;ic&amp;nbsp;false&lt;/code&gt; 사용 하십시오 . 텍스트 모드는 디스크립터가 파일 또는 파이프를 참조하는 경우에만 지원되지만 소켓을 참조하는 경우 지원되지 않습니다. Windows에서 &lt;code&gt;set_binary_mode_in&lt;/code&gt; 은이 함수로 생성 된 채널에서 항상 실패합니다.</target>
        </trans-unit>
        <trans-unit id="117259bf956aec536c5e186ca77e9ac5c916fcea" translate="yes" xml:space="preserve">
          <source>Create an output channel writing on the given descriptor.</source>
          <target state="translated">주어진 설명자에 쓰는 출력 채널을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="aef56a146856b79a283846092c16431e8f33cd0e" translate="yes" xml:space="preserve">
          <source>Create an output channel writing on the given descriptor. The channel is initially in binary mode; use &lt;code&gt;set_binary_mode_out&amp;nbsp;oc&amp;nbsp;false&lt;/code&gt; if text mode is desired.</source>
          <target state="translated">주어진 설명자에 쓰는 출력 채널을 만듭니다. 채널은 초기에 바이너리 모드입니다. 텍스트 모드가 필요한 경우 &lt;code&gt;set_binary_mode_out&amp;nbsp;oc&amp;nbsp;false&lt;/code&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3b9a3797ea26619d3139009eea19109e07b38e3" translate="yes" xml:space="preserve">
          <source>Create an output channel writing on the given descriptor. The channel is initially in binary mode; use &lt;code&gt;set_binary_mode_out&amp;nbsp;oc&amp;nbsp;false&lt;/code&gt; if text mode is desired. Text mode is supported only if the descriptor refers to a file or pipe, but is not supported if it refers to a socket. On Windows, &lt;code&gt;set_binary_mode_out&lt;/code&gt; always fails on channels created with this function.</source>
          <target state="translated">주어진 설명자에 쓰는 출력 채널을 만듭니다. 채널은 초기에 바이너리 모드입니다. 텍스트 모드가 필요한 경우 &lt;code&gt;set_binary_mode_out&amp;nbsp;oc&amp;nbsp;false&lt;/code&gt; 사용 하십시오 . 텍스트 모드는 디스크립터가 파일 또는 파이프를 참조하는 경우에만 지원되지만 소켓을 참조하는 경우 지원되지 않습니다. Windows에서 &lt;code&gt;set_binary_mode_out&lt;/code&gt; 은이 함수로 생성 된 채널에서 항상 실패합니다.</target>
        </trans-unit>
        <trans-unit id="fe6800f26660081a63257b90928fee7fe0195a50" translate="yes" xml:space="preserve">
          <source>Create if nonexistent</source>
          <target state="translated">존재하지 않는 경우 생성</target>
        </trans-unit>
        <trans-unit id="6b2f57520b3f8b6769816f831656e126cef6ab78" translate="yes" xml:space="preserve">
          <source>Creating directly an object through the object&lt;a href=&quot;classes#class-body&quot;&gt;class-body&lt;/a&gt;end construct is operationally equivalent to defining locally a class&lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt;=object&lt;a href=&quot;classes#class-body&quot;&gt;class-body&lt;/a&gt;end &amp;mdash;see sections &lt;a href=&quot;classes#sss%3Aclass-body&quot;&gt;7.9.2&lt;/a&gt; and following for the syntax of &lt;a href=&quot;classes#class-body&quot;&gt;class-body&lt;/a&gt;&amp;mdash; and immediately creating a single object from it by new&lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt;.</source>
          <target state="translated">오브젝트를 통해 객체를 직접 생성 &lt;a href=&quot;classes#class-body&quot;&gt;클래스 본체&lt;/a&gt; 단부 제물은 국소 클래스 정의에 동작 적 동등 &lt;a href=&quot;names#class-name&quot;&gt;클래스 이름&lt;/a&gt; = 객체 &lt;a href=&quot;classes#class-body&quot;&gt;클래스 본체&lt;/a&gt; 단부 이따 섹션 &lt;a href=&quot;classes#sss%3Aclass-body&quot;&gt;7.9.2을&lt;/a&gt; 과의 구문은 다음과 같은 &lt;a href=&quot;classes#class-body&quot;&gt;급 본체&lt;/a&gt; 즉시 하나를 생성 - new &lt;a href=&quot;names#class-name&quot;&gt;class-name에&lt;/a&gt; 의한 객체 .</target>
        </trans-unit>
        <trans-unit id="601cb9beb4be7bd6b430fc5e8f28883c4379c1d3" translate="yes" xml:space="preserve">
          <source>Cross-references are fully qualified element names, as in the example {!Foo.Bar.t}. This is an ambiguous reference as it may designate a type name, a value name, a class name, etc. It is possible to make explicit the intended syntactic class, using {!type:Foo.Bar.t} to designate a type, and {!val:Foo.Bar.t} a value of the same name.</source>
          <target state="translated">상호 참조는 {! Foo.Bar.t} 예제에서와 같이 완전한 요소 이름입니다. 이것은 타입 이름, 값 이름, 클래스 이름 등을 지정할 수 있으므로 모호한 참조입니다. 유형을 지정하기 위해 {! type : Foo.Bar.t}를 사용하여 의도 한 구문 클래스를 명시 적으로 만들 수 있습니다. 및 {! val : Foo.Bar.t}는 동일한 이름의 값입니다.</target>
        </trans-unit>
        <trans-unit id="37fe7fe65c32d93c2ca449d110fef079f2b333b8" translate="yes" xml:space="preserve">
          <source>Current call stack</source>
          <target state="translated">현재 호출 스택</target>
        </trans-unit>
        <trans-unit id="560d25076243183549a3366eeffb8ff8432d896d" translate="yes" xml:space="preserve">
          <source>Current size of the stack, in words.</source>
          <target state="translated">스택의 현재 크기 (단어)입니다.</target>
        </trans-unit>
        <trans-unit id="2dfd3c4c638243840bd240275ac5f3fed807c54e" translate="yes" xml:space="preserve">
          <source>Current value of the timer</source>
          <target state="translated">타이머의 현재 값</target>
        </trans-unit>
        <trans-unit id="812249ab55025e47f0d8297bf9cf8f98c1593c35" translate="yes" xml:space="preserve">
          <source>Currently, the compiler requires that all dependency cycles between the recursively-defined module identifiers go through at least one &amp;ldquo;safe&amp;rdquo; module. A module is &amp;ldquo;safe&amp;rdquo; if all value definitions that it contains have function types &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. Evaluation of a recursive module definition proceeds by building initial values for the safe modules involved, binding all (functional) values to fun_-&amp;gt;raiseUndefined_recursive_module. The defining module expressions are then evaluated, and the initial values for the safe modules are replaced by the values thus computed. If a function component of a safe module is applied during this computation (which corresponds to an ill-founded recursive definition), the Undefined_recursive_module exception is raised at runtime:</source>
          <target state="translated">현재 컴파일러는 재귀 적으로 정의 된 모듈 식별자 사이의 모든 종속성주기가 적어도 하나의 &quot;안전한&quot;모듈을 통과해야합니다. 모듈에 포함 된 모든 값 정의에 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1-&lt;/sub&gt; &amp;gt; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 함수 유형이있는 경우 모듈은 &quot;안전&quot;합니다.&lt;sub&gt;&lt;/sub&gt;. 재귀 모듈 정의의 평가는 관련된 안전 모듈에 대한 초기 값을 빌드하고 모든 (기능적) 값을 fun _-&amp;gt; raiseUndefined_recursive_module에 바인딩하여 진행됩니다. 그런 다음 정의하는 모듈식이 평가되고 안전한 모듈의 초기 값이 계산 된 값으로 대체됩니다. 이 계산 중에 안전 모듈의 함수 구성 요소가 적용되면 (잘 근거가없는 재귀 정의에 해당) Undefined_recursive_module 예외가 런타임에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="38664408d8c3d30f0a6346765b3283aa12c40bf5" translate="yes" xml:space="preserve">
          <source>Currently, the official distribution only supports &lt;code&gt;Native&lt;/code&gt; and &lt;code&gt;Bytecode&lt;/code&gt;, but it can be other backends with alternative compilers, for example, javascript.</source>
          <target state="translated">현재 공식 배포판은 &lt;code&gt;Native&lt;/code&gt; 및 &lt;code&gt;Bytecode&lt;/code&gt; 만 지원 하지만 javascript와 같은 대체 컴파일러가있는 다른 백엔드 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4bda26164af65ad302861503513ecff5571b51a" translate="yes" xml:space="preserve">
          <source>Custom blocks generalize the finalized blocks that were present in OCaml prior to version 3.00. For backward compatibility, the format of custom blocks is compatible with that of finalized blocks, and the alloc_final function is still available to allocate a custom block with a given finalization function, but default comparison, hashing and serialization functions. caml_alloc_final(n, f, used, max) returns a fresh custom block of size n+1 words, with finalization function f. The first word is reserved for storing the custom operations; the other n words are available for your data. The two parameters used and max are used to control the speed of garbage collection, as described for caml_alloc_custom.</source>
          <target state="translated">사용자 지정 블록은 버전 3.00 이전에 OCaml에 있던 최종 블록을 일반화합니다. 이전 버전과의 호환성을 위해 사용자 지정 블록의 형식은 완성 된 블록의 형식과 호환되며, alloc_final 함수는 지정된 종료 기능이있는 사용자 지정 블록을 할당하는 데 여전히 사용할 수 있지만 기본 비교, 해싱 및 직렬화 기능이 있습니다. caml_alloc_final (n, f, used, max)는 종료 함수 f를 사용하여 n + 1 단어 크기의 새로운 사용자 정의 블록을 반환합니다. 첫 번째 단어는 사용자 지정 작업을 저장하기 위해 예약되어 있습니다. 다른 n 개의 단어를 데이터에 사용할 수 있습니다. 사용되는 두 개의 매개 변수와 max는 caml_alloc_custom에 대해 설명 된대로 가비지 콜렉션의 속도를 제어하는 ​​데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7d420f0c61810f3ee6a674eb6f4cdb6097699b24" translate="yes" xml:space="preserve">
          <source>Custom blocks must be allocated via caml_alloc_custom or caml_alloc_custom_mem:</source>
          <target state="translated">사용자 지정 블록은 caml_alloc_custom 또는 caml_alloc_custom_mem을 통해 할당해야합니다.</target>
        </trans-unit>
        <trans-unit id="0696943310470dcd9412c58452a376f47cd4d8e7" translate="yes" xml:space="preserve">
          <source>Custom_tag</source>
          <target state="translated">Custom_tag</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="876131551ef5b34a0ae26c45b8606a6d1e20f0ec" translate="yes" xml:space="preserve">
          <source>Damien Doligez, Alain Frisch, Jacques Garrigue, Didier R&amp;eacute;my and J&amp;eacute;r&amp;ocirc;me Vouillon</source>
          <target state="translated">Damien Doligez, Alain Frisch, Jacques Garrigue, Didier R&amp;eacute;my 및 J&amp;eacute;r&amp;ocirc;me Vouillon</target>
        </trans-unit>
        <trans-unit id="9bb8e492ef8785784d3763a2dd035cbcb3a6f48d" translate="yes" xml:space="preserve">
          <source>Data_custom_val(v) returns a pointer to the data part of the custom block v. This pointer has type void * and must be cast to the type of the data contained in the custom block.</source>
          <target state="translated">Data_custom_val (v)는 사용자 정의 블록 v의 데이터 부분에 대한 포인터를 반환합니다.이 포인터는 void * 유형을 가지며 사용자 정의 블록에 포함 된 데이터 유형으로 캐스트되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6c61aac6c59c97a9391046663cc1f0a559430d2b" translate="yes" xml:space="preserve">
          <source>Datagram socket</source>
          <target state="translated">데이터 그램 소켓</target>
        </trans-unit>
        <trans-unit id="ae5e1b484adfb0832aee424b80fdbf0749c94471" translate="yes" xml:space="preserve">
          <source>Day of month 1..31</source>
          <target state="translated">달의 일 1..31</target>
        </trans-unit>
        <trans-unit id="a6b30c19d064061d359d4bd864a0a544b299c73f" translate="yes" xml:space="preserve">
          <source>Day of week (Sunday is 0)</source>
          <target state="translated">요일 (일요일은 0)</target>
        </trans-unit>
        <trans-unit id="b762515612697efddec23840f7a8446cf18c9759" translate="yes" xml:space="preserve">
          <source>Day of year 0..365</source>
          <target state="translated">0..365</target>
        </trans-unit>
        <trans-unit id="3b0dbb1420972511e036436a9980700df7df5ce2" translate="yes" xml:space="preserve">
          <source>Daylight time savings in effect</source>
          <target state="translated">유효한 일광 절약 시간</target>
        </trans-unit>
        <trans-unit id="2fadfd27832ae372bd710d8badba7a9b539b27e1" translate="yes" xml:space="preserve">
          <source>Deactivates the applicative behaviour of functors. With this option, each functor application generates new types in its result and applying the same functor twice to the same argument yields two incompatible structures.</source>
          <target state="translated">펑터의 적용 가능한 동작을 비활성화합니다. 이 옵션을 사용하면 각 functor 응용 프로그램은 결과에 새로운 유형을 생성하고 동일한 인수에 동일한 functor를 두 번 적용하면 두 개의 호환되지 않는 구조가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="751472bbc1120d8b191832a2b8fcc18014817d7f" translate="yes" xml:space="preserve">
          <source>Deactivates the constant propagation for floating-point operations. This option should be given if the program changes the float rounding mode during its execution.</source>
          <target state="translated">부동 소수점 연산에 대한 상수 전파를 비활성화합니다. 프로그램이 실행 중에 부동 반올림 모드를 변경하는 경우이 옵션을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="2678ad56aeb7875f3c2d5de90981064d8f642b7a" translate="yes" xml:space="preserve">
          <source>Declarations are given one per line. They all start with a &lt;code&gt;%&lt;/code&gt; sign.</source>
          <target state="translated">선언은 한 줄에 하나씩 제공됩니다. 모두 &lt;code&gt;%&lt;/code&gt; 기호로 시작 합니다.</target>
        </trans-unit>
        <trans-unit id="dea55cd40a5af4aaba5005b973e60323ff6e05fa" translate="yes" xml:space="preserve">
          <source>Declare the given symbols &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; &amp;hellip; &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; as tokens (terminal symbols). These symbols are added as constant constructors for the token concrete type.</source>
          <target state="translated">주어진 기호 &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; &amp;hellip; &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; 을 토큰 (터미널 기호)으로 선언하십시오 . 이러한 기호는 토큰 구체 유형에 대한 상수 생성자로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="71ce3434b9f14435902a3d78ef46a7ad71688c6e" translate="yes" xml:space="preserve">
          <source>Declare the given symbols &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; &amp;hellip; &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; as tokens with an attached attribute of the given type. These symbols are added as constructors with arguments of the given type for the token concrete type. The &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; part is an arbitrary OCaml type expression, except that all type constructor names must be fully qualified (e.g. Modname.typename) for all types except standard built-in types, even if the proper &lt;code&gt;open&lt;/code&gt; directives (e.g. &lt;code&gt;open Modname&lt;/code&gt;) were given in the header section. That&amp;rsquo;s because the header is copied only to the .ml output file, but not to the .mli output file, while the &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; part of a &lt;code&gt;%token&lt;/code&gt; declaration is copied to both.</source>
          <target state="translated">주어진 기호 &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; &amp;hellip; &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; 을 주어진 유형의 첨부 된 속성이있는 토큰으로 선언하십시오 . 이러한 기호는 토큰 구체 유형에 대해 지정된 유형의 인수를 사용하여 생성자로 추가됩니다. &lt;a href=&quot;types#typexpr&quot;&gt;typexpr의&lt;/a&gt; 부분은 모든 타입의 생성자 이름을 제외한 모든 유형 (예 : Modname.typename) 완전해야하는 것을 제외하고, 임의의 OCaml의 타입의 표현이다 표준 내장 유형, 적절한 경우에도 &lt;code&gt;open&lt;/code&gt; 지시 (예를 들면 &lt;code&gt;open Modname&lt;/code&gt; )에 주어졌다 헤더 섹션. 헤더는 .ml 출력 파일에만 복사되고 .mli 출력 파일에는 복사되지 않고 &lt;code&gt;%token&lt;/code&gt; 선언 의 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; 부분은 둘 다에 복사되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ae20b0b5091f27b6010031e7c755cac286e05951" translate="yes" xml:space="preserve">
          <source>Declare the given symbols as entry points for the grammar. For each entry point, a parsing function with the same name is defined in the output module. Non-terminals that are not declared as entry points have no such parsing function. Start symbols must be given a type with the &lt;code&gt;%type&lt;/code&gt; directive below.</source>
          <target state="translated">주어진 기호를 문법의 진입 점으로 선언하십시오. 각 진입 점에 대해 동일한 이름의 구문 분석 함수가 출력 모듈에 정의됩니다. 진입 점으로 선언되지 않은 비 터미널에는 이러한 구문 분석 기능이 없습니다. 시작 기호에는 아래 &lt;code&gt;%type&lt;/code&gt; 지시문이 있는 유형이 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e036180d7b4330c36ccc46169e89f1d9c0e3c6b6" translate="yes" xml:space="preserve">
          <source>Decrement the integer contained in the given reference.</source>
          <target state="translated">주어진 참조에 포함 된 정수를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="47c2c2f15d575288567819a78318c5d8b38a36ce" translate="yes" xml:space="preserve">
          <source>Decrement the integer contained in the given reference. Equivalent to &lt;code&gt;fun&amp;nbsp;r&amp;nbsp;-&amp;gt;&amp;nbsp;r&amp;nbsp;:=&amp;nbsp;pred&amp;nbsp;!r&lt;/code&gt;.</source>
          <target state="translated">주어진 참조에 포함 된 정수를 줄입니다. 상당 &lt;code&gt;fun&amp;nbsp;r&amp;nbsp;-&amp;gt;&amp;nbsp;r&amp;nbsp;:=&amp;nbsp;pred&amp;nbsp;!r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c11b83f7c1a5251b3d34dbe51f9955f77470d6d" translate="yes" xml:space="preserve">
          <source>Default callbacks simply return &lt;code&gt;None&lt;/code&gt; or &lt;code&gt;()&lt;/code&gt;</source>
          <target state="translated">기본 콜백은 단순히 &lt;code&gt;None&lt;/code&gt; 또는 &lt;code&gt;()&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="80afbff2abe8c0d7fd33c9ccd7830a6e8695af59" translate="yes" xml:space="preserve">
          <source>Default directories searched by the system dynamic loader. Under Unix, these generally include /lib and /usr/lib, plus the directories listed in the file /etc/ld.so.conf and the environment variable LD_LIBRARY_PATH. Under Windows, these include the Windows system directories, plus the directories listed in the PATH environment variable.</source>
          <target state="translated">시스템 동적 로더가 검색하는 기본 디렉토리입니다. Unix에서는 일반적으로 / lib 및 / usr / lib와 /etc/ld.so.conf 파일 및 환경 변수 LD_LIBRARY_PATH에 나열된 디렉토리가 포함됩니다. Windows에서 여기에는 Windows 시스템 디렉터리와 PATH 환경 변수에 나열된 디렉터리가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7d3a0856d835d1235dff9d8788c3557c03ede792" translate="yes" xml:space="preserve">
          <source>Default tag-marking functions behave the HTML way: &lt;a href=&quot;format#TYPEtag&quot;&gt;string tags&lt;/a&gt; are enclosed in &quot;&amp;lt;&quot; and &quot;&amp;gt;&quot; while other tags are ignored; hence, opening marker for tag string &lt;code&gt;&quot;t&quot;&lt;/code&gt; is &lt;code&gt;&quot;&amp;lt;t&amp;gt;&quot;&lt;/code&gt; and closing marker is &lt;code&gt;&quot;&amp;lt;/t&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">기본 태그 표시 기능은 HTML 방식으로 작동합니다. &lt;a href=&quot;format#TYPEtag&quot;&gt;문자열 태그&lt;/a&gt; 는 &quot;&amp;lt;&quot;및 &quot;&amp;gt;&quot;로 묶이고 다른 태그는 무시됩니다. 따라서 태그 문자열 &lt;code&gt;&quot;t&quot;&lt;/code&gt; 의 여는 마커 는 &lt;code&gt;&quot;&amp;lt;t&amp;gt;&quot;&lt;/code&gt; 이고 닫는 마커는 &lt;code&gt;&quot;&amp;lt;/t&amp;gt;&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4a62a2e3e7ee2c9c2ee80559a4f3229d3577d48f" translate="yes" xml:space="preserve">
          <source>Default tag-printing functions just do nothing.</source>
          <target state="translated">기본 태그 인쇄 기능은 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9eed4a181452e1959a48bc782bac0f8f566e7c0f" translate="yes" xml:space="preserve">
          <source>Default: 0.</source>
          <target state="translated">기본값 : 0.</target>
        </trans-unit>
        <trans-unit id="9082a1e7f923e7fce6486c509c1beb8c25f7fe15" translate="yes" xml:space="preserve">
          <source>Deferred computations.</source>
          <target state="translated">지연된 계산.</target>
        </trans-unit>
        <trans-unit id="bcf39e9d321a7d8c8984215b8972f37f40d07337" translate="yes" xml:space="preserve">
          <source>Define a hash table on generic containers which have a notion of &quot;death&quot; and aliveness. If a binding is dead the hash table can automatically remove it.</source>
          <target state="translated">&quot;죽음&quot;과 생존의 개념을 가진 일반 컨테이너에 해시 테이블을 정의하십시오. 바인딩이 작동하지 않으면 해시 테이블이 자동으로 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f21fc769210bfcaf86eb46d5f61d271368778b97" translate="yes" xml:space="preserve">
          <source>Defining expression</source>
          <target state="translated">표현 정의</target>
        </trans-unit>
        <trans-unit id="7c4de55230924b0c3c5fc761cc7d4686a36f7dc3" translate="yes" xml:space="preserve">
          <source>Defining formatters</source>
          <target state="translated">포맷터 정의</target>
        </trans-unit>
        <trans-unit id="4911c404436a822d9f0fbfab26950a91ad559e29" translate="yes" xml:space="preserve">
          <source>Defining new formatters permits unrelated output of material in parallel on several output devices. All the parameters of a formatter are local to the formatter: right margin, maximum indentation limit, maximum number of pretty-printing boxes simultaneously open, ellipsis, and so on, are specific to each formatter and may be fixed independently.</source>
          <target state="translated">새로운 포맷터를 정의하면 여러 출력 장치에서 관련없는 자료를 병렬로 출력 할 수 있습니다. 포맷터의 모든 매개 변수는 포맷터에 국한됩니다. 오른쪽 여백, 최대 들여 쓰기 제한, 동시에 열리는 예쁜 인쇄 상자의 최대 수, 줄임표 등은 각 포맷터에 따라 다르며 독립적으로 고정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e0b554ed773f7f64c570b11feb5887c9cc07fe5" translate="yes" xml:space="preserve">
          <source>Delete the specified breakpoints. Without argument, all breakpoints are deleted (after asking for confirmation).</source>
          <target state="translated">지정된 중단 점을 삭제하십시오. 인수가 없으면 모든 중단 점이 삭제됩니다 (확인 요청 후).</target>
        </trans-unit>
        <trans-unit id="f97978b86bb138adaba2fd837574900d5922d00e" translate="yes" xml:space="preserve">
          <source>Dependencies are generated both for compiling with the bytecode compiler ocamlc and with the native-code compiler ocamlopt.</source>
          <target state="translated">종속성은 바이트 코드 컴파일러 ocamlc 및 네이티브 코드 컴파일러 ocamlopt로 컴파일하기 위해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b0d4c46a17ce0b5e730857044f9bf49c709590e2" translate="yes" xml:space="preserve">
          <source>Depending on the execution platforms, other representations of floating-point numbers can be accepted, but should not be relied upon.</source>
          <target state="translated">실행 플랫폼에 따라 부동 소수점 숫자의 다른 표현이 허용 될 수 있지만 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="527600bf0272b6bf3abcb495a99c6ee346bb82b2" translate="yes" xml:space="preserve">
          <source>Deprecated</source>
          <target state="translated">Deprecated</target>
        </trans-unit>
        <trans-unit id="74254f9d66f6a56051d0eaae6dea96f7d55c67a0" translate="yes" xml:space="preserve">
          <source>Deprecated since OCaml 4.11. Please use -bin-annot instead.</source>
          <target state="translated">OCaml 4.11부터 사용되지 않습니다. 대신 -bin-annot을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ef0c6a5ddb045b6ece785229e78cf805f0b1a89d" translate="yes" xml:space="preserve">
          <source>Deprecated synonym for the &amp;rsquo;deprecated&amp;rsquo; alert.</source>
          <target state="translated">'사용되지 않음'경고의 사용되지 않는 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="8e967cec8e8fdbe014b3a9f6bbf388f62bb46fa7" translate="yes" xml:space="preserve">
          <source>Deprecated. Use &lt;a href=&quot;unix#VALgetsockopt_error&quot;&gt;&lt;code&gt;Unix.getsockopt_error&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 &lt;a href=&quot;unix#VALgetsockopt_error&quot;&gt; &lt;code&gt;Unix.getsockopt_error&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2224f5d5269c5bc0b6728399953ed547eb0d09f0" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;a href=&quot;arraylabels#VALmake_float&quot;&gt;&lt;code&gt;ArrayLabels.make_float&lt;/code&gt;&lt;/a&gt; is an alias for &lt;a href=&quot;arraylabels#VALcreate_float&quot;&gt;&lt;code&gt;ArrayLabels.create_float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 이상 사용되지 않습니다. &lt;a href=&quot;arraylabels#VALmake_float&quot;&gt; &lt;code&gt;ArrayLabels.make_float&lt;/code&gt; 는&lt;/a&gt; 별칭입니다 &lt;a href=&quot;arraylabels#VALcreate_float&quot;&gt; &lt;code&gt;ArrayLabels.create_float&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="778bc3674d64e797ac3bcdc24c0d0ca9cba0734e" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;a href=&quot;stdlib#VAL(&amp;amp;&amp;amp;)&quot;&gt;&lt;code&gt;(&amp;amp;&amp;amp;)&lt;/code&gt;&lt;/a&gt; should be used instead. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 &lt;a href=&quot;stdlib#VAL(&amp;amp;&amp;amp;)&quot;&gt; &lt;code&gt;(&amp;amp;&amp;amp;)&lt;/code&gt; 를&lt;/a&gt; 사용해야합니다. 오른쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="3fca9f421cfdb9f0454d469cdb1dcaa8ace5429e" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;(||)&lt;/code&gt; should be used instead. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">더 이상 사용되지 않습니다. 대신 &lt;code&gt;(||)&lt;/code&gt; 를 사용해야합니다. 오른쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="a150df40019aac9b002359089017a86258f19d9f" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;Array.create&lt;/code&gt; is an alias for &lt;a href=&quot;array#VALmake&quot;&gt;&lt;code&gt;Array.make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 이상 사용되지 않습니다. &lt;code&gt;Array.create&lt;/code&gt; 는 별칭입니다 &lt;a href=&quot;array#VALmake&quot;&gt; &lt;code&gt;Array.make&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e89b4c51bb7679bf855f7c9eec368867486ddd1" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;Array.create_matrix&lt;/code&gt; is an alias for &lt;a href=&quot;array#VALmake_matrix&quot;&gt;&lt;code&gt;Array.make_matrix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 이상 사용되지 않습니다. &lt;code&gt;Array.create_matrix&lt;/code&gt; 는 별칭입니다 &lt;a href=&quot;array#VALmake_matrix&quot;&gt; &lt;code&gt;Array.make_matrix&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50bae5862dab3413cad88ccda1ead1a473864665" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;Array.make_float&lt;/code&gt; is an alias for &lt;a href=&quot;array#VALcreate_float&quot;&gt;&lt;code&gt;Array.create_float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 이상 사용되지 않습니다. &lt;code&gt;Array.make_float&lt;/code&gt; 는 별칭입니다 &lt;a href=&quot;array#VALcreate_float&quot;&gt; &lt;code&gt;Array.create_float&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea64d85c2e594370c18faa8e1d13550273cdb567" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;Scanf.fscanf&lt;/code&gt; is error prone and deprecated since 4.03.0. This function violates the following invariant of the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module: To preserve scanning semantics, all scanning functions defined in &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; must read from a user defined &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt; formatted input channel. If you need to read from a &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt;&lt;code&gt;in_channel&lt;/code&gt;&lt;/a&gt; input channel &lt;code&gt;ic&lt;/code&gt;, simply define a &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt; formatted input channel as in &lt;code&gt;let&amp;nbsp;ib&amp;nbsp;=&amp;nbsp;Scanning.from_channel&amp;nbsp;ic&lt;/code&gt;, then use &lt;code&gt;Scanf.bscanf&amp;nbsp;ib&lt;/code&gt; as usual.</source>
          <target state="translated">더 이상 사용되지 않습니다. &lt;code&gt;Scanf.fscanf&lt;/code&gt; 는 오류가 발생하기 쉬우 며 4.03.0부터 더 이상 사용되지 않습니다. 이 함수는 &lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt; 모듈 의 다음 불변을 위반합니다 . 스캔 의미를 보존하려면 &lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; 에&lt;/a&gt; 정의 된 모든 스캔 기능 이 사용자 정의 &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt; &lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt; &lt;/a&gt; 형식의 입력 채널 에서 읽어야합니다 . &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt; &lt;code&gt;in_channel&lt;/code&gt; &lt;/a&gt; 입력 채널 &lt;code&gt;ic&lt;/code&gt; 에서 읽어야하는 경우 &lt;code&gt;let&amp;nbsp;ib&amp;nbsp;=&amp;nbsp;Scanning.from_channel&amp;nbsp;ic&lt;/code&gt; 와 같이 &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt; &lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt; &lt;/a&gt; 형식의 입력 채널을 정의한 다음 평소와 같이 &lt;code&gt;Scanf.bscanf&amp;nbsp;ib&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="1ce9cc4e47d57231b6a0bca0e76722fe4b7860a4" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;Scanf.kfscanf&lt;/code&gt; is error prone and deprecated since 4.03.0.</source>
          <target state="translated">더 이상 사용되지 않습니다. &lt;code&gt;Scanf.kfscanf&lt;/code&gt; 는 오류가 발생하기 쉬우 며 4.03.0부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f594cb170e0e9c8ecd301b0b815c721b26b065d" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;create&lt;/code&gt; is an alias for &lt;a href=&quot;arraylabels#VALmake&quot;&gt;&lt;code&gt;ArrayLabels.make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 이상 사용되지 않습니다. &lt;code&gt;create&lt;/code&gt; 는 &lt;a href=&quot;arraylabels#VALmake&quot;&gt; &lt;code&gt;ArrayLabels.make&lt;/code&gt; &lt;/a&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="5ce71a4bfc97c24d6d8d5947007a2b7beb8109c0" translate="yes" xml:space="preserve">
          <source>Deprecated.&lt;code&gt;create_matrix&lt;/code&gt; is an alias for &lt;a href=&quot;arraylabels#VALmake_matrix&quot;&gt;&lt;code&gt;ArrayLabels.make_matrix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 이상 사용되지 않습니다. &lt;code&gt;create_matrix&lt;/code&gt; 는 별칭입니다 &lt;a href=&quot;arraylabels#VALmake_matrix&quot;&gt; &lt;code&gt;ArrayLabels.make_matrix&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19939082fb7f2eee871d26aedbf72b901c3112f7" translate="yes" xml:space="preserve">
          <source>Deprecated.An alias for &lt;code&gt;ksprintf&lt;/code&gt;.</source>
          <target state="translated">Deprecated . &lt;code&gt;ksprintf&lt;/code&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="e5109e0782a729eff640730e6ab1a3e754505085" translate="yes" xml:space="preserve">
          <source>Deprecated.Because strings are immutable, it doesn't make much sense to make identical copies of them.</source>
          <target state="translated">Deprecated. 문자열은 변경할 수 없기 때문에 동일한 복사본을 만드는 것은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="750ec831f3c087b18622dc178ec61b7cb38e9e32" translate="yes" xml:space="preserve">
          <source>Deprecated.Functions operating on Latin-1 character set are deprecated.</source>
          <target state="translated">더 이상 사용되지 않음 Latin-1 문자 집합에서 작동하는 함수는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea75bf6e5b032cf8e893592df0f821c5e5f96d64" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#TYPEformatter_stag_functions&quot;&gt;&lt;code&gt;Format.formatter_stag_functions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 이상 사용되지 않습니다 . &lt;a href=&quot;format#TYPEformatter_stag_functions&quot;&gt; &lt;code&gt;Format.formatter_stag_functions&lt;/code&gt; &lt;/a&gt; 에 종속 됩니다.</target>
        </trans-unit>
        <trans-unit id="0c97116701943fcfc6c2f740afe560b14ec3898d" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALclose_stag&quot;&gt;&lt;code&gt;Format.close_stag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Deprecated . &lt;a href=&quot;format#VALclose_stag&quot;&gt; &lt;code&gt;Format.close_stag&lt;/code&gt; 에&lt;/a&gt; 의해 종속 됩니다.</target>
        </trans-unit>
        <trans-unit id="fca73c717756fa77071fb29946903b95deed41a6" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALget_formatter_stag_functions&quot;&gt;&lt;code&gt;Format.get_formatter_stag_functions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Deprecated . &lt;a href=&quot;format#VALget_formatter_stag_functions&quot;&gt; &lt;code&gt;Format.get_formatter_stag_functions&lt;/code&gt; 에&lt;/a&gt; 의해 종속 됩니다.</target>
        </trans-unit>
        <trans-unit id="d93054ebdf71f3812384f734ddd0e2d1f78da6e2" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALopen_stag&quot;&gt;&lt;code&gt;Format.open_stag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Deprecated . &lt;a href=&quot;format#VALopen_stag&quot;&gt; &lt;code&gt;Format.open_stag&lt;/code&gt; 에&lt;/a&gt; 의해 종속 됩니다.</target>
        </trans-unit>
        <trans-unit id="281c574fe529db292e92addfbf152b24d9bdbbf3" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALpp_close_stag&quot;&gt;&lt;code&gt;Format.pp_close_stag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 이상 사용되지 않습니다 . &lt;a href=&quot;format#VALpp_close_stag&quot;&gt; &lt;code&gt;Format.pp_close_stag&lt;/code&gt; &lt;/a&gt; 에 종속 됩니다.</target>
        </trans-unit>
        <trans-unit id="641c68cac8b19078637ee0e40e70a3a5d64a22f6" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALpp_get_formatter_stag_functions&quot;&gt;&lt;code&gt;Format.pp_get_formatter_stag_functions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 이상 사용되지 않습니다 . &lt;a href=&quot;format#VALpp_get_formatter_stag_functions&quot;&gt; &lt;code&gt;Format.pp_get_formatter_stag_functions&lt;/code&gt; 에&lt;/a&gt; 의해 종속 됩니다.</target>
        </trans-unit>
        <trans-unit id="3ccb247c568c8d05554c40ee2105c8bf4f8476b4" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALpp_open_stag&quot;&gt;&lt;code&gt;Format.pp_open_stag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 이상 사용되지 않습니다 . &lt;a href=&quot;format#VALpp_open_stag&quot;&gt; &lt;code&gt;Format.pp_open_stag&lt;/code&gt; &lt;/a&gt; 에 종속 됩니다.</target>
        </trans-unit>
        <trans-unit id="f2602cd2b6f3d43929ce834f849335fcef5dae37" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALpp_set_formatter_stag_functions&quot;&gt;&lt;code&gt;Format.pp_set_formatter_stag_functions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 이상 사용되지 않습니다 . &lt;a href=&quot;format#VALpp_set_formatter_stag_functions&quot;&gt; &lt;code&gt;Format.pp_set_formatter_stag_functions&lt;/code&gt; &lt;/a&gt; 에 종속 됩니다.</target>
        </trans-unit>
        <trans-unit id="afa368f3af7d6061271ddaa3583db9fd9dfb7bca" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;a href=&quot;format#VALset_formatter_stag_functions&quot;&gt;&lt;code&gt;Format.set_formatter_stag_functions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Deprecated . &lt;a href=&quot;format#VALset_formatter_stag_functions&quot;&gt; &lt;code&gt;Format.set_formatter_stag_functions&lt;/code&gt; 에&lt;/a&gt; 의해 종속 됩니다.</target>
        </trans-unit>
        <trans-unit id="c33425025d507c5cd7b36ca43602379d421c4dc9" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;code&gt;get_formatter_out_functions&lt;/code&gt;.</source>
          <target state="translated">Deprecated . &lt;code&gt;get_formatter_out_functions&lt;/code&gt; 에 의해 종속 됩니다.</target>
        </trans-unit>
        <trans-unit id="9b2a76881889cf4cb991a8f48ab00eec047820ff" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;code&gt;pp_get_formatter_out_functions&lt;/code&gt;.</source>
          <target state="translated">더 이상 사용되지 않습니다 . &lt;code&gt;pp_get_formatter_out_functions&lt;/code&gt; 에 종속 됩니다.</target>
        </trans-unit>
        <trans-unit id="027d489c4ef0ad9d201d300c80987ca970dd611d" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;code&gt;pp_set_formatter_out_functions&lt;/code&gt;.</source>
          <target state="translated">더 이상 사용되지 않습니다 . &lt;code&gt;pp_set_formatter_out_functions&lt;/code&gt; 에 종속 됩니다.</target>
        </trans-unit>
        <trans-unit id="ca3dcb5b6debc7e2c15801aa508b5d41a02ae9fc" translate="yes" xml:space="preserve">
          <source>Deprecated.Subsumed by &lt;code&gt;set_formatter_out_functions&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set_formatter_out_functions&lt;/code&gt; . set_formatter_out_functions에 의해 종속 됩니다.</target>
        </trans-unit>
        <trans-unit id="c0f8f5969e6b8a63fecae4c32ed1ceb9fde348db" translate="yes" xml:space="preserve">
          <source>Deprecated.The functionality of this module has been merged back into the &lt;a href=&quot;unix&quot;&gt;&lt;code&gt;Unix&lt;/code&gt;&lt;/a&gt; module. Threaded programs can now call the functions from module &lt;a href=&quot;unix&quot;&gt;&lt;code&gt;Unix&lt;/code&gt;&lt;/a&gt; directly, and still get the correct behavior (block the calling thread, if required, but do not block all threads in the process).</source>
          <target state="translated">Deprecated.이 모듈의 기능이 &lt;a href=&quot;unix&quot;&gt; &lt;code&gt;Unix&lt;/code&gt; &lt;/a&gt; 모듈 로 다시 병합되었습니다 . 스레드 프로그램은 이제 모듈 &lt;a href=&quot;unix&quot;&gt; &lt;code&gt;Unix&lt;/code&gt; 에서&lt;/a&gt; 직접 함수를 호출 할 수 있으며 여전히 올바른 동작을 얻을 수 있습니다 (필요한 경우 호출 스레드를 차단하지만 프로세스의 모든 스레드를 차단하지는 않음).</target>
        </trans-unit>
        <trans-unit id="3242d82a29f5555016d27f6fdf4642b2322aa5a3" translate="yes" xml:space="preserve">
          <source>Deprecated.This function is error prone. Do not use it. This function is neither compositional nor incremental, since it flushes the pretty-printer queue at each call. If you need to print to some buffer &lt;code&gt;b&lt;/code&gt;, you must first define a formatter writing to &lt;code&gt;b&lt;/code&gt;, using &lt;code&gt;let&amp;nbsp;to_b&amp;nbsp;=&amp;nbsp;formatter_of_buffer&amp;nbsp;b&lt;/code&gt;; then use regular calls to &lt;code&gt;Format.fprintf&lt;/code&gt; with formatter &lt;code&gt;to_b&lt;/code&gt;.</source>
          <target state="translated">Deprecated.이 함수는 오류가 발생하기 쉽습니다. 그것을 사용하지 마십시오. 이 함수는 각 호출에서 pretty-printer 대기열을 플러시하기 때문에 구성도 증분도 아닙니다. &lt;code&gt;b&lt;/code&gt; 버퍼에 인쇄해야하는 경우 먼저 &lt;code&gt;let&amp;nbsp;to_b&amp;nbsp;=&amp;nbsp;formatter_of_buffer&amp;nbsp;b&lt;/code&gt; 사용하여 &lt;code&gt;b&lt;/code&gt; 에 쓰는 포맷터를 정의해야합니다 . 그런 다음 &lt;code&gt;to_b&lt;/code&gt; 포맷터와 함께 &lt;code&gt;Format.fprintf&lt;/code&gt; 에 대한 일반 호출을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d129f235645dc88a9f2ee69c1b366ec77d5e6af0" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;bytes#VALcreate&quot;&gt;&lt;code&gt;Bytes.create&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Deprecated . &lt;a href=&quot;bytes#VALcreate&quot;&gt; &lt;code&gt;Bytes.create&lt;/code&gt; &lt;/a&gt; 의 더 이상 사용되지 않는 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="ea0d72f83cc5b5f92d01d7c247da799f1cf025dd" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;bytes#VALfill&quot;&gt;&lt;code&gt;Bytes.fill&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Deprecated . &lt;a href=&quot;bytes#VALfill&quot;&gt; &lt;code&gt;Bytes.fill&lt;/code&gt; &lt;/a&gt; 의 더 이상 사용되지 않는 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="5b1d7aec9a40e9b929be4e8acc4d6af5f1afb54e" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;bytes#VALset&quot;&gt;&lt;code&gt;Bytes.set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Deprecated . &lt;a href=&quot;bytes#VALset&quot;&gt; &lt;code&gt;Bytes.set&lt;/code&gt; &lt;/a&gt; 의 더 이상 사용되지 않는 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="94967cc879b015aef449bb6fdb01c7b7b10b4307" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;byteslabels#VALcreate&quot;&gt;&lt;code&gt;BytesLabels.create&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Deprecated . &lt;a href=&quot;byteslabels#VALcreate&quot;&gt; &lt;code&gt;BytesLabels.create&lt;/code&gt; &lt;/a&gt; 의 더 이상 사용되지 않는 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="12aaa67606a221f7b76061f12289e38192d36dab" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;byteslabels#VALfill&quot;&gt;&lt;code&gt;BytesLabels.fill&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Deprecated . &lt;a href=&quot;byteslabels#VALfill&quot;&gt; &lt;code&gt;BytesLabels.fill&lt;/code&gt; &lt;/a&gt; 의 더 이상 사용되지 않는 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="b97555fc7a6d84d213dab655a6b7779fcd3941c9" translate="yes" xml:space="preserve">
          <source>Deprecated.This is a deprecated alias of &lt;a href=&quot;byteslabels#VALset&quot;&gt;&lt;code&gt;BytesLabels.set&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Deprecated . &lt;a href=&quot;byteslabels#VALset&quot;&gt; &lt;code&gt;BytesLabels.set&lt;/code&gt; &lt;/a&gt; 의 더 이상 사용되지 않는 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="8eb4d0a700ae5d08d5df97d7d36b72776b3f990e" translate="yes" xml:space="preserve">
          <source>Deprecated.You should use &lt;a href=&quot;filename#VALget_temp_dir_name&quot;&gt;&lt;code&gt;Filename.get_temp_dir_name&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Deprecated . 대신 &lt;a href=&quot;filename#VALget_temp_dir_name&quot;&gt; &lt;code&gt;Filename.get_temp_dir_name&lt;/code&gt; &lt;/a&gt; 을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="288e17a817fd8dee0e659a5930d009274e344a1a" translate="yes" xml:space="preserve">
          <source>Deprecated.synonym for &lt;code&gt;from_fun&lt;/code&gt;.</source>
          <target state="translated">대한 Deprecated.synonym &lt;code&gt;from_fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fc633f74d2489b4a203e2ddf0b1d55195cf9e76" translate="yes" xml:space="preserve">
          <source>Deprecated.synonym for &lt;code&gt;from_val&lt;/code&gt;.</source>
          <target state="translated">대한 Deprecated.synonym &lt;code&gt;from_val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29f1d014a7b64bfd88ddaa57f0c63ab52af2c740" translate="yes" xml:space="preserve">
          <source>Deprecated.synonym for &lt;code&gt;is_val&lt;/code&gt;.</source>
          <target state="translated">대한 Deprecated.synonym &lt;code&gt;is_val&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c61ae75bfda87e7eb880e442b4f35b49765a4e6" translate="yes" xml:space="preserve">
          <source>Deprecated: now part of warning 8.</source>
          <target state="translated">더 이상 사용되지 않음 : 이제 경고 8의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="9c30d33385a5d3cd74cc6904ab3e2c26ba272b0c" translate="yes" xml:space="preserve">
          <source>Dereferencing (return the current contents of a reference).</source>
          <target state="translated">역 참조 (참조의 현재 콘텐츠 반환).</target>
        </trans-unit>
        <trans-unit id="556c70c19023a2dd4cddc34ffa2fb962927700b6" translate="yes" xml:space="preserve">
          <source>Describe the currently selected stack frame.</source>
          <target state="translated">현재 선택된 스택 프레임을 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="30204445e59c24675d5d45718f49e0d965ced7fa" translate="yes" xml:space="preserve">
          <source>Describe the return value and its possible values. This tag is used for functions and methods.</source>
          <target state="translated">반환 값과 가능한 값을 설명하십시오. 이 태그는 함수 및 메서드에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="df6067c118d1f66def5a1a8be905127318b0e21e" translate="yes" xml:space="preserve">
          <source>Descriptions of elements and descriptions in @-tags are handled as follows. If a description for the same element or in the same @-tag of the same element is present in both files, then the description of the .ml file is concatenated to the one in the .mli file, if the corresponding -m flag is given on the command line. If a description is present in the .ml file and not in the .mli file, the .ml description is kept. In either case, all the information given in the .mli file is kept.</source>
          <target state="translated">@-태그의 요소 및 설명에 대한 설명은 다음과 같이 처리됩니다. 동일한 요소 또는 동일한 요소의 동일한 @-태그에 대한 설명이 두 파일에 모두있는 경우 해당 -m 플래그가 다음과 같으면 .ml 파일의 설명이 .mli 파일의 설명에 연결됩니다. 명령 줄에 제공됩니다. 설명이 .mli 파일이 아닌 .ml 파일에있는 경우 .ml 설명이 유지됩니다. 두 경우 모두 .mli 파일에 제공된 모든 정보가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="67d799aee373a2f6c263ebf58e0280d66136d9e5" translate="yes" xml:space="preserve">
          <source>Despite &lt;a href=&quot;#label&quot;&gt;label&lt;/a&gt; and &lt;a href=&quot;#optlabel&quot;&gt;optlabel&lt;/a&gt; being lexical entities in expressions, their expansions ~&lt;a href=&quot;#label-name&quot;&gt;label-name&lt;/a&gt;: and ?&lt;a href=&quot;#label-name&quot;&gt;label-name&lt;/a&gt;: will be used in grammars, for the sake of readability. Note also that inside type expressions, this expansion can be taken literally, &lt;em&gt;i.e.&lt;/em&gt; there are really 3 tokens, with optional blanks between them.</source>
          <target state="translated">&lt;a href=&quot;#label&quot;&gt;label&lt;/a&gt; 및 &lt;a href=&quot;#optlabel&quot;&gt;optlabel&lt;/a&gt; 이 표현식의 어휘 엔티티 임에도 불구하고 확장은 ~ &lt;a href=&quot;#label-name&quot;&gt;label-name&lt;/a&gt; : 및? &lt;a href=&quot;#label-name&quot;&gt;label-name&lt;/a&gt; : 가독성을 위해 문법에서 사용됩니다. 또한 유형 표현식 내부에서이 확장은 문자 그대로 취할 수 있습니다. &lt;em&gt;즉&lt;/em&gt; , 실제로 3 개의 토큰이 있고 그 사이에 선택적 공백이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6f646066bdf4b1ec66764f189ea43f9555404f9" translate="yes" xml:space="preserve">
          <source>Destination address required</source>
          <target state="translated">목적지 주소가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="70d38e034fc41445f66a84bbc7421aae75cb369d" translate="yes" xml:space="preserve">
          <source>Determine whether it is clear that inlining would be beneficial without, for the moment, doing any inlining within the function itself. (The exact assessment of &lt;em&gt;benefit&lt;/em&gt; is described below.) If so, the function is inlined.</source>
          <target state="translated">함수 자체 내에서 인라인을 수행하지 않고도 인라인이 도움이 될 수 있는지 여부를 결정하십시오. ( &lt;em&gt;혜택&lt;/em&gt; 의 정확한 평가는 아래에 설명되어 있습니다.) 그렇다면 함수가 인라인됩니다.</target>
        </trans-unit>
        <trans-unit id="fe861f03852b09cf76716d7e041be8378ee86f6e" translate="yes" xml:space="preserve">
          <source>Device ID (if special file)</source>
          <target state="translated">장치 ID (특수 파일 인 경우)</target>
        </trans-unit>
        <trans-unit id="6fa7dda8b47dbe32f43cc7e7cbb154977cdd4b4b" translate="yes" xml:space="preserve">
          <source>Device number</source>
          <target state="translated">장치 번호</target>
        </trans-unit>
        <trans-unit id="47fdd58bee4dc86df2b978107102a22b9c44345b" translate="yes" xml:space="preserve">
          <source>Digest</source>
          <target state="translated">Digest</target>
        </trans-unit>
        <trans-unit id="03b5690384bc40a11bbb9c00e423e54e65806954" translate="yes" xml:space="preserve">
          <source>Direct call site</source>
          <target state="translated">직통 전화 사이트</target>
        </trans-unit>
        <trans-unit id="6511f8b22675dad2defbfb3fe082bbb561af35ab" translate="yes" xml:space="preserve">
          <source>Direct the memory manager to print some progress messages on standard error. This is equivalent to setting v=63 in the OCAMLRUNPARAM environment variable (see below).</source>
          <target state="translated">메모리 관리자에게 표준 오류에 대한 진행 메시지를 인쇄하도록 지시하십시오. 이는 OCAMLRUNPARAM 환경 변수에서 v = 63을 설정하는 것과 동일합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="1029544ae8b46287a52a74595462c217cf60a5a9" translate="yes" xml:space="preserve">
          <source>Directories</source>
          <target state="translated">Directories</target>
        </trans-unit>
        <trans-unit id="6c8a1a100ae0fc810383f2b9a2878d99ecc4ed7c" translate="yes" xml:space="preserve">
          <source>Directories added with the #directory directive.</source>
          <target state="translated">#directory 지시문으로 추가 된 디렉토리.</target>
        </trans-unit>
        <trans-unit id="2d54c02b2c2c47443482e970156b799ac791785a" translate="yes" xml:space="preserve">
          <source>Directories can also be added to the list once the toplevel is running with the #directory directive (section &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;).</source>
          <target state="translated">#directory 지시문 (섹션 &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt; )을 사용 하여 최상위 레벨이 실행되면 디렉토리를 목록에 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="baa1af9dcf811b5cb577d789120d5a9a8e401eb8" translate="yes" xml:space="preserve">
          <source>Directories given on the command line with -I options.</source>
          <target state="translated">-I 옵션을 사용하여 명령 줄에 제공된 디렉토리.</target>
        </trans-unit>
        <trans-unit id="4fca1322bb244459d6be50257fca52fdf7eac5df" translate="yes" xml:space="preserve">
          <source>Directories specified at link-time via the -dllpath option to ocamlc. (These directories are recorded in the bytecode executable file.)</source>
          <target state="translated">ocamlc에 대한 -dllpath 옵션을 통해 링크 타임에 지정된 디렉토리. (이 디렉토리는 바이트 코드 실행 파일에 기록됩니다.)</target>
        </trans-unit>
        <trans-unit id="ff079471e218f45b2873844ac43f1b9da8c17ff6" translate="yes" xml:space="preserve">
          <source>Directories specified in the CAML_LD_LIBRARY_PATH environment variable.</source>
          <target state="translated">CAML_LD_LIBRARY_PATH 환경 변수에 지정된 디렉터리입니다.</target>
        </trans-unit>
        <trans-unit id="fea42a5c86d3619520a1c10b093343dc1f30f5a2" translate="yes" xml:space="preserve">
          <source>Directories specified in the file ld.conf. This file resides in the OCaml standard library directory, and lists directory names (one per line) to be searched. Typically, it contains only one line naming the stublibs subdirectory of the OCaml standard library directory. Users can add there the names of other directories containing frequently-used shared libraries; however, for consistency of installation, we recommend that shared libraries are installed directly in the system stublibs directory, rather than adding lines to the ld.conf file.</source>
          <target state="translated">ld.conf 파일에 지정된 디렉토리. 이 파일은 OCaml 표준 라이브러리 디렉토리에 있으며 검색 할 디렉토리 이름 (한 줄에 하나씩)을 나열합니다. 일반적으로 OCaml 표준 라이브러리 디렉토리의 stublibs 하위 디렉토리를 명명하는 한 줄만 포함됩니다. 사용자는 자주 사용하는 공유 라이브러리를 포함하는 다른 디렉토리의 이름을 추가 할 수 있습니다. 그러나 설치의 일관성을 위해 ld.conf 파일에 행을 추가하는 대신 공유 라이브러리를 시스템 stublibs 디렉토리에 직접 설치하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4425c83626ad0d492312630fa584010dc2ea7687" translate="yes" xml:space="preserve">
          <source>Directories specified on the ocamlrun command line with the -I option.</source>
          <target state="translated">-I 옵션을 사용하여 ocamlrun 명령 줄에 지정된 디렉토리.</target>
        </trans-unit>
        <trans-unit id="4b892fe0c040fa8a944037d1d2817c41ab7da958" translate="yes" xml:space="preserve">
          <source>Directory</source>
          <target state="translated">Directory</target>
        </trans-unit>
        <trans-unit id="ca827528d6904965fcebbbcad976a987f5f845b3" translate="yes" xml:space="preserve">
          <source>Directory not empty</source>
          <target state="translated">디렉토리가 비어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77ccc74e22667a82ec8374d5503fa0741496e682" translate="yes" xml:space="preserve">
          <source>Disable flush after INTR, QUIT, SUSP.</source>
          <target state="translated">INTR, QUIT, SUSP 후 플러시를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="8e4bdf9a6eacfa2697016cd0108d461fcf7421b2" translate="yes" xml:space="preserve">
          <source>Disable the set of warnings corresponding to letter. The letter may be uppercase or lowercase.</source>
          <target state="translated">문자에 해당하는 경고 세트를 비활성화합니다. 문자는 대문자 또는 소문자 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dcea52c1515117c58919743de2a2da57c540121" translate="yes" xml:space="preserve">
          <source>Disable the set of warnings corresponding to lowercase-letter.</source>
          <target state="translated">소문자에 해당하는 경고 세트를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c19f04c2757dbb7f8de14c35e1cce96d6a55c8a6" translate="yes" xml:space="preserve">
          <source>Disable warning number num.</source>
          <target state="translated">경고 번호 번호를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="aec8cd3e0abf9d3de01b24e3782506475ae87211" translate="yes" xml:space="preserve">
          <source>Disable warnings in the given range.</source>
          <target state="translated">주어진 범위에서 경고를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="eff551fe5c7d7e0f50ac103c39a57bea5895ef26" translate="yes" xml:space="preserve">
          <source>Disambiguated constructor or label name (compatibility warning).</source>
          <target state="translated">명확한 생성자 또는 레이블 이름 (호환성 경고).</target>
        </trans-unit>
        <trans-unit id="b228a139422f11ea4357c7d2efc32f85d808b19b" translate="yes" xml:space="preserve">
          <source>Discard all elements from a queue.</source>
          <target state="translated">대기열에서 모든 요소를 ​​버립니다.</target>
        </trans-unit>
        <trans-unit id="a763423157ebaef14af264de95dfd62aeae53cfc" translate="yes" xml:space="preserve">
          <source>Discard all elements from a stack.</source>
          <target state="translated">스택에서 모든 요소를 ​​버립니다.</target>
        </trans-unit>
        <trans-unit id="85ac75ec9ac382b61445173e38bfa779b2b19f5c" translate="yes" xml:space="preserve">
          <source>Discard data written on the given file descriptor but not yet transmitted, or data received but not yet read, depending on the second argument: &lt;code&gt;TCIFLUSH&lt;/code&gt; flushes data received but not read, &lt;code&gt;TCOFLUSH&lt;/code&gt; flushes data written but not transmitted, and &lt;code&gt;TCIOFLUSH&lt;/code&gt; flushes both.</source>
          <target state="translated">폐기 된 데이터는 주어진 파일 디스크립터에 기록되었지만 아직 전송되지 않은, 또는 데이터가 수신되었지만 아직 읽지 번째 인수에 따라 : &lt;code&gt;TCIFLUSH&lt;/code&gt; 는 수신 된 데이터를 플러시하지만 읽을, &lt;code&gt;TCOFLUSH&lt;/code&gt; 데이터가 전송 기입 아니라 플러싱하고 &lt;code&gt;TCIOFLUSH&lt;/code&gt; 가 모두를 플러시.</target>
        </trans-unit>
        <trans-unit id="57521250b5897b35eb18446005dde0a337ba5726" translate="yes" xml:space="preserve">
          <source>Discard the contents of the buffer and reset the current position to 0.</source>
          <target state="translated">버퍼의 내용을 버리고 현재 위치를 0으로 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c324ee3bd77d8cdc9882e8d0fc0aa86700e2b4ff" translate="yes" xml:space="preserve">
          <source>Discard the contents of the buffer and reset the current position to 0. The next use of the lexbuf will trigger a refill.</source>
          <target state="translated">버퍼의 내용을 버리고 현재 위치를 0으로 재설정합니다. 다음에 lexbuf를 사용하면 리필이 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="3a3793c75090c266feef9865c31883fbe011f366" translate="yes" xml:space="preserve">
          <source>Discard the value of its argument and return &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">인수 값을 버리고 &lt;code&gt;()&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="59e4d950f2d4305046840b504d37718518d243de" translate="yes" xml:space="preserve">
          <source>Discard the value of its argument and return &lt;code&gt;()&lt;/code&gt;. For instance, &lt;code&gt;ignore(f&amp;nbsp;x)&lt;/code&gt; discards the result of the side-effecting function &lt;code&gt;f&lt;/code&gt;. It is equivalent to &lt;code&gt;f&amp;nbsp;x;&amp;nbsp;()&lt;/code&gt;, except that the latter may generate a compiler warning; writing &lt;code&gt;ignore(f&amp;nbsp;x)&lt;/code&gt; instead avoids the warning.</source>
          <target state="translated">인수 값을 버리고 &lt;code&gt;()&lt;/code&gt; 를 반환 합니다. 예를 들어, &lt;code&gt;ignore(f&amp;nbsp;x)&lt;/code&gt; 는 부작용 함수 &lt;code&gt;f&lt;/code&gt; 의 결과를 버립니다 . &lt;code&gt;f&amp;nbsp;x;&amp;nbsp;()&lt;/code&gt; 와 동일합니다 . () , 단 후자는 컴파일러 경고를 생성 할 수 있습니다. 쓰기 &lt;code&gt;ignore(f&amp;nbsp;x)&lt;/code&gt; 하는 대신 경고를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e3db82a71cdff092fe3c4e674d2cf59d344c98c" translate="yes" xml:space="preserve">
          <source>Display a short usage summary and exit.</source>
          <target state="translated">간단한 사용 요약을 표시하고 종료합니다.</target>
        </trans-unit>
        <trans-unit id="35dc839559848f5eb2c3fe73488f70904e3ae41c" translate="yes" xml:space="preserve">
          <source>Display the complete list of parameters for functions and methods.</source>
          <target state="translated">함수 및 방법에 대한 전체 매개 변수 목록을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d83946df95c85b27e03a0eceda28c6b18faddcf0" translate="yes" xml:space="preserve">
          <source>Display the custom generators default directory.</source>
          <target state="translated">사용자 정의 생성기 기본 디렉토리를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="bbbec44416269797757a1579d0b1247911acd066" translate="yes" xml:space="preserve">
          <source>Division</source>
          <target state="translated">Division</target>
        </trans-unit>
        <trans-unit id="c1615505a10cd0a8a96dbd7380ce2c53780aa017" translate="yes" xml:space="preserve">
          <source>Do &lt;em&gt;not&lt;/em&gt; set the -custom flag, otherwise you&amp;rsquo;re back to static linking as described in section &lt;a href=&quot;#ss%3Astaticlink-c-code&quot;&gt;20.1.3&lt;/a&gt;. The ocamlmklib tool (see section &lt;a href=&quot;#s%3Aocamlmklib&quot;&gt;20.14&lt;/a&gt;) automates steps 2 and 3.</source>
          <target state="translated">수행 &lt;em&gt;하지&lt;/em&gt; 당신은 정적 링크 방법입니다 다시 섹션에 설명 된대로, 그렇지 않으면 - 사용자 정의 플래그를 설정 &lt;a href=&quot;#ss%3Astaticlink-c-code&quot;&gt;20.1.3&lt;/a&gt; . ocamlmklib 도구 (섹션 &lt;a href=&quot;#s%3Aocamlmklib&quot;&gt;20.14&lt;/a&gt; 참조 )는 2 단계와 3 단계를 자동화합니다.</target>
        </trans-unit>
        <trans-unit id="4c47225fbda414465a615e36d4177b55dd3eaa1c" translate="yes" xml:space="preserve">
          <source>Do a minor collection and finish the current major collection cycle.</source>
          <target state="translated">소규모 수집을 수행하고 현재 주요 수집주기를 완료합니다.</target>
        </trans-unit>
        <trans-unit id="7e67bacde12033f167102017edabc6ea724d07c0" translate="yes" xml:space="preserve">
          <source>Do a minor collection, finish the current major collection cycle, and perform a complete new cycle.</source>
          <target state="translated">마이너 수집을 수행하고 현재의 주요 수집주기를 완료하고 완전히 새로운주기를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="04b6ceedb393ff292e5063adf221897afc4e187a" translate="yes" xml:space="preserve">
          <source>Do a minor collection, finish the current major collection cycle, and perform a complete new cycle. This will collect all currently unreachable blocks.</source>
          <target state="translated">마이너 수집을 수행하고 현재의 주요 수집주기를 완료하고 완전히 새로운주기를 수행합니다. 현재 도달 할 수없는 모든 블록을 수집합니다.</target>
        </trans-unit>
        <trans-unit id="0daaabef3025f3c8281acefcdc36265b713e5d45" translate="yes" xml:space="preserve">
          <source>Do not add current working directory to the list of include directories.</source>
          <target state="translated">현재 작업 디렉토리를 포함 디렉토리 목록에 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0dd6861951e2b753da997ead7a08426d22baa2a3" translate="yes" xml:space="preserve">
          <source>Do not allow custom @-tags (see section &lt;a href=&quot;#ss%3Aocamldoc-tags&quot;&gt;16.2.5&lt;/a&gt;).</source>
          <target state="translated">사용자 지정 @-태그를 허용하지 마십시오 (섹션 &lt;a href=&quot;#ss%3Aocamldoc-tags&quot;&gt;16.2.5&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7ddb859954f4b0f1267022be18664ce369f4d72a" translate="yes" xml:space="preserve">
          <source>Do not automatically add the standard library directory to the list of directories searched for compiled interface files (.cmi), compiled object code files (.cmx), and libraries (.cmxa). See also option -I.</source>
          <target state="translated">컴파일 된 인터페이스 파일 (.cmi), 컴파일 된 오브젝트 코드 파일 (.cmx) 및 라이브러리 (.cmxa)를 검색 한 디렉토리 목록에 표준 라이브러리 디렉토리를 자동으로 추가하지 마십시오. 옵션 -I도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4b22d46ee16ff416c80772315f7396494ea3fc5e" translate="yes" xml:space="preserve">
          <source>Do not block if no child has died yet, but immediately return with a pid equal to 0.</source>
          <target state="translated">아직 자식이 죽지 않았다면 차단하지 말고 즉시 0과 같은 pid를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="031865d55aa41b6e70421f3ce5c1a293a99cbfc7" translate="yes" xml:space="preserve">
          <source>Do not build index for Info files.</source>
          <target state="translated">Info 파일에 대한 색인을 작성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3dd45f175e92b8eaae1b91c01a1d09ad1da05182" translate="yes" xml:space="preserve">
          <source>Do not call name resolver, expect numeric IP address</source>
          <target state="translated">이름 해석기를 호출하지 말고 숫자 IP 주소를 예상하십시오.</target>
        </trans-unit>
        <trans-unit id="f826060748a4f9075bc43b6d058cc0ba05d77389" translate="yes" xml:space="preserve">
          <source>Do not compile assertion checks. Note that the special form assert false is always compiled because it is typed specially.</source>
          <target state="translated">어설 션 검사를 컴파일하지 마십시오. 특수 형식 assert false는 특수하게 입력 되었기 때문에 항상 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="28cdfa96ccebfb982ad25f616a5461bcce5db594" translate="yes" xml:space="preserve">
          <source>Do not compile assertion checks. Note that the special form assert false is always compiled because it is typed specially. This flag has no effect when linking already-compiled files.</source>
          <target state="translated">어설 션 검사를 컴파일하지 마십시오. 특수 형식 assert false는 특수하게 입력 되었기 때문에 항상 컴파일됩니다. 이 플래그는 이미 컴파일 된 파일을 링크 할 때 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6b4151d019da73db9b1b47237e17df5a70d431b4" translate="yes" xml:space="preserve">
          <source>Do not display any prompt when waiting for input.</source>
          <target state="translated">입력을 기다릴 때 프롬프트를 표시하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4587f67b20caed188543780983919bc73577d989" translate="yes" xml:space="preserve">
          <source>Do not display the secondary prompt when waiting for continuation lines in multi-line inputs. This should be used e.g. when running ocaml in an emacs window.</source>
          <target state="translated">다중 라인 입력에서 연속 라인을 기다릴 때 보조 프롬프트를 표시하지 마십시오. 이것은 예를 들어 emacs 창에서 ocaml을 실행할 때 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="87cc23e1ce95050f53c83e4fc4b5197b57a26719" translate="yes" xml:space="preserve">
          <source>Do not generate a table of contents.</source>
          <target state="translated">목차를 생성하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c19a0b4c326541165d9a51372f39e571198ccf18" translate="yes" xml:space="preserve">
          <source>Do not include the standard library directory in the list of directories searched for compiled interface files (.cmi), compiled object code files (.cmo), libraries (.cma), and C libraries specified with -cclib -lxxx. See also option -I.</source>
          <target state="translated">컴파일 된 인터페이스 파일 (.cmi), 컴파일 된 오브젝트 코드 파일 (.cmo), 라이브러리 (.cma) 및 -cclib -lxxx로 지정된 C 라이브러리를 검색 한 디렉토리 목록에 표준 라이브러리 디렉토리를 포함하지 마십시오. 옵션 -I도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="064821cea7940442efa1520725382b3b4955526f" translate="yes" xml:space="preserve">
          <source>Do not include the standard library directory in the list of directories searched for source and compiled files.</source>
          <target state="translated">소스 및 컴파일 된 파일을 검색 한 디렉토리 목록에 표준 라이브러리 디렉토리를 포함하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="253be060206824d9b4dd7af9b8790b6551c7c9cd" translate="yes" xml:space="preserve">
          <source>Do not print OCamldoc warnings.</source>
          <target state="translated">OCamldoc 경고를 인쇄하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d0e3c326d3220da0354ae7c4e91ad6fb36af0dbe" translate="yes" xml:space="preserve">
          <source>Do not print the version banner at startup.</source>
          <target state="translated">시작시 버전 배너를 인쇄하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a518f2812d3306324e4ce68e86acbedd313390cc" translate="yes" xml:space="preserve">
          <source>Do not qualify local host names</source>
          <target state="translated">로컬 호스트 이름을 규정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="15165b95be0530c8689212758b6f87ed55a19591" translate="yes" xml:space="preserve">
          <source>Do not record dependencies for module aliases. See section &lt;a href=&quot;modulealias#s%3Amodule-alias&quot;&gt;8.8&lt;/a&gt; for more information.</source>
          <target state="translated">모듈 별칭에 대한 종속성을 기록하지 마십시오. 자세한 내용은 섹션 &lt;a href=&quot;modulealias#s%3Amodule-alias&quot;&gt;8.8&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="17c810b750e959c8744be3fb11ef3f3b863e75d1" translate="yes" xml:space="preserve">
          <source>Do not unbox arguments to which functions have been specialised. See section &lt;a href=&quot;#ss%3Aflambda-unbox-spec-args&quot;&gt;21.9.2&lt;/a&gt;.</source>
          <target state="translated">함수가 특수화 된 인수의 상자를 풀지 마십시오. 섹션 &lt;a href=&quot;#ss%3Aflambda-unbox-spec-args&quot;&gt;21.9.2를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94446f6fa3c2614682fdb6a2f38f1eea9d15a5cd" translate="yes" xml:space="preserve">
          <source>Do not unbox closure variables. See section &lt;a href=&quot;#ss%3Aflambda-unbox-fvs&quot;&gt;21.9.1&lt;/a&gt;.</source>
          <target state="translated">클로저 변수의 박스를 풀지 마십시오. 섹션 &lt;a href=&quot;#ss%3Aflambda-unbox-fvs&quot;&gt;21.9.1을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="83efe30f6e83b800163ecbaf2a13c9f7320f78be" translate="yes" xml:space="preserve">
          <source>Do note that the indices passed to &lt;code&gt;f&lt;/code&gt; may not start at &lt;code&gt;0&lt;/code&gt; in the general case. For example, &lt;code&gt;[&amp;lt;&amp;nbsp;'0;&amp;nbsp;'1;&amp;nbsp;Stream.from&amp;nbsp;f&amp;nbsp;&amp;gt;]&lt;/code&gt; would call &lt;code&gt;f&lt;/code&gt; the first time with count &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 에 전달 된 인덱스 는 일반적인 경우 &lt;code&gt;0&lt;/code&gt; 에서 시작하지 않을 수 있습니다 . 예를 들어, &lt;code&gt;[&amp;lt;&amp;nbsp;'0;&amp;nbsp;'1;&amp;nbsp;Stream.from&amp;nbsp;f&amp;nbsp;&amp;gt;]&lt;/code&gt; 는 count &lt;code&gt;2&lt;/code&gt; 를 사용 하여 &lt;code&gt;f&lt;/code&gt; 를 처음 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="e115cdb1fc49a35afc65cded140e7aac8702d30d" translate="yes" xml:space="preserve">
          <source>Documentation and user&amp;rsquo;s manual</source>
          <target state="translated">문서 및 사용자 설명서</target>
        </trans-unit>
        <trans-unit id="35ee6007715742773c38d4eb75befc2fcd192d39" translate="yes" xml:space="preserve">
          <source>Domain error for math functions, etc.</source>
          <target state="translated">수학 함수 등에 대한 도메인 오류</target>
        </trans-unit>
        <trans-unit id="cbb4365752b3a355adb85f2c09fa26922f6de928" translate="yes" xml:space="preserve">
          <source>Don't make this dev a controlling tty</source>
          <target state="translated">이 개발자를 제어하는 ​​tty로 만들지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e2c9fea25fd7a1fe50f26d27cf3ecd6a65b6a25b" translate="yes" xml:space="preserve">
          <source>Don't preserve sharing</source>
          <target state="translated">공유를 보존하지 마십시오</target>
        </trans-unit>
        <trans-unit id="50c809cff2d695209e704f8197dab6f54e225936" translate="yes" xml:space="preserve">
          <source>Double the default</source>
          <target state="translated">기본값의 두 배</target>
        </trans-unit>
        <trans-unit id="15e85994c9a5443f990f6afb5b898c774627a852" translate="yes" xml:space="preserve">
          <source>Double_array_tag</source>
          <target state="translated">Double_array_tag</target>
        </trans-unit>
        <trans-unit id="ca8bf75e9f0596d733ef4d95e5e307e4a331e94d" translate="yes" xml:space="preserve">
          <source>Double_field(v, n) returns the n&lt;sup&gt;th&lt;/sup&gt; element of the array of floating-point numbers v (a block tagged Double_array_tag).</source>
          <target state="translated">Double_field (v, n) 은 부동 소수점 숫자 v (Double_array_tag 태그가 지정된 블록) 배열의 n &lt;sup&gt;번째&lt;/sup&gt; 요소를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1c671ea4bfc33386e2575fa5b03150428efb4ede" translate="yes" xml:space="preserve">
          <source>Double_tag</source>
          <target state="translated">Double_tag</target>
        </trans-unit>
        <trans-unit id="bbc4dbcceef59b6f089abaa4a71a66bb23b3e7be" translate="yes" xml:space="preserve">
          <source>Double_val(v) returns the floating-point number contained in value v, with type double.</source>
          <target state="translated">Double_val (v)는 double 유형으로 값 v에 포함 된 부동 소수점 숫자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="85e07ec423183b97e7e54906d287288e1be1ffc2" translate="yes" xml:space="preserve">
          <source>Due to the way that format string are build, storing a format string requires an explicit type annotation:</source>
          <target state="translated">형식 문자열이 빌드되는 방식으로 인해 형식 문자열을 저장하려면 명시적인 유형 주석이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="38da2b2f7c5e5067497c455981267218324b40aa" translate="yes" xml:space="preserve">
          <source>Dump collected information into file. This information can be read with the -load option in a subsequent invocation of ocamldoc.</source>
          <target state="translated">수집 된 정보를 파일로 덤프합니다. 이 정보는 ocamldoc의 후속 호출에서 -load 옵션을 사용하여 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f7d57f9e20eda3c41fb941c658194cfee284a2a" translate="yes" xml:space="preserve">
          <source>Dump detailed information about the compilation (types, bindings, tail-calls, etc) in binary format. The information for file src.ml (resp. src.mli) is put into file src.cmt (resp. src.cmti). In case of a type error, dump all the information inferred by the type-checker before the error. The *.cmt and *.cmti files produced by -bin-annot contain more information and are much more compact than the files produced by -annot.</source>
          <target state="translated">컴파일에 대한 자세한 정보 (유형, 바인딩, 마무리 호출 등)를 바이너리 형식으로 덤프합니다. src.ml (resp. src.mli) 파일에 대한 정보는 src.cmt (resp. src.cmti) 파일에 저장됩니다. 유형 오류의 경우 오류 전에 유형 검사기가 유추 한 모든 정보를 덤프합니다. -bin-annot에 의해 생성 된 * .cmt 및 * .cmti 파일은 -annot에 의해 생성 된 파일보다 더 많은 정보를 포함하고 훨씬 더 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="d734c14d897b78ff2c878be1ef4830dddaf75aad" translate="yes" xml:space="preserve">
          <source>Dump the delayed dependency map for each map file.</source>
          <target state="translated">각 맵 파일에 대해 지연된 종속성 맵을 덤프하십시오.</target>
        </trans-unit>
        <trans-unit id="e11fe1c6936a32f898ab53021b1b505b77ad3f51" translate="yes" xml:space="preserve">
          <source>During execution of an ocamlopt-generated executable, the following environment variables are also consulted:</source>
          <target state="translated">ocamlopt 생성 실행 파일을 실행하는 동안 다음 환경 변수도 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="a527567660be56f12ce37a951df19c1ce6570fac" translate="yes" xml:space="preserve">
          <source>During execution, a trace file will be generated in the program&amp;rsquo;s current working directory.</source>
          <target state="translated">실행 중에 프로그램의 현재 작업 디렉토리에 추적 파일이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="52da08cd6051434fc2f3b7662122ca9fcd53bd40" translate="yes" xml:space="preserve">
          <source>During program execution, a counter is incremented at each event encountered. The value of this counter is referred as the &lt;em&gt;current time&lt;/em&gt;. Thanks to reverse execution, it is possible to jump back and forth to any time of the execution.</source>
          <target state="translated">프로그램 실행 중에 카운터는 각 이벤트가 발생할 때마다 증가합니다. 이 카운터의 값을 &lt;em&gt;현재 시간&lt;/em&gt; 이라고합니다 . 리버스 실행 덕분에 실행의 어느 시점 으로든 앞뒤로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45953970e1ac64460d95053cf011f3147fc2549a" translate="yes" xml:space="preserve">
          <source>Dynamic loading of .cmo, .cma and .cmxs files.</source>
          <target state="translated">.cmo, .cma 및 .cmxs 파일의 동적로드.</target>
        </trans-unit>
        <trans-unit id="ade230ae2af559c6a2da6c3d0adbdf4a6b8d6c90" translate="yes" xml:space="preserve">
          <source>Dynamic loading of compiled files</source>
          <target state="translated">컴파일 된 파일의 동적로드</target>
        </trans-unit>
        <trans-unit id="00ae303d73198569285e7493b0488fa5e452c626" translate="yes" xml:space="preserve">
          <source>Dynamically load the given file, which defines a custom documentation generator. See section &lt;a href=&quot;#ss%3Aocamldoc-compilation-and-usage&quot;&gt;16.4.1&lt;/a&gt;. This option is supported by the ocamldoc command (to load .cmo and .cma files) and by its native-code version ocamldoc.opt (to load .cmxs files). If the given file is a simple one and does not exist in the current directory, then ocamldoc looks for it in the custom generators default directory, and in the directories specified with optional -i options.</source>
          <target state="translated">사용자 정의 문서 생성기를 정의하는 주어진 파일을 동적으로로드합니다. 섹션 &lt;a href=&quot;#ss%3Aocamldoc-compilation-and-usage&quot;&gt;16.4.1&lt;/a&gt; 참조 . 이 옵션은 ocamldoc 명령 (.cmo 및 .cma 파일로드)과 네이티브 코드 버전 ocamldoc.opt (.cmxs 파일로드)에서 지원됩니다. 주어진 파일이 단순하고 현재 디렉토리에 존재하지 않는 경우, ocamldoc은 사용자 정의 생성기 기본 디렉토리와 선택적 -i 옵션으로 지정된 디렉토리에서 파일을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="72b629ad314d21b66226424fb0bb2acf4d780051" translate="yes" xml:space="preserve">
          <source>Dynamically, the variable s is bound at the invocation of a method. In particular, when the class printable_point is inherited, the variable s will be correctly bound to the object of the subclass.</source>
          <target state="translated">동적으로 변수 s는 메서드 호출시 바인딩됩니다. 특히 printable_point 클래스가 상속되면 변수 s가 하위 클래스의 객체에 올바르게 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="1f1033247aecb214d97e3f11b5184ebfb54ae7b8" translate="yes" xml:space="preserve">
          <source>Dynlink</source>
          <target state="translated">Dynlink</target>
        </trans-unit>
        <trans-unit id="e0184adedf913b076626646d3f52c3b49c39ad6d" translate="yes" xml:space="preserve">
          <source>E</source>
          <target state="translated">E</target>
        </trans-unit>
        <trans-unit id="5c6318466a052c1420b0b08a980cddb451bd6d60" translate="yes" xml:space="preserve">
          <source>Each different pretty-printing box kind introduces a specific line splitting policy:</source>
          <target state="translated">각기 다른 예쁜 인쇄 상자 종류는 특정 줄 분할 정책을 도입합니다.</target>
        </trans-unit>
        <trans-unit id="2c16499eb0943acc5eb62a31f9bc88221763dc01" translate="yes" xml:space="preserve">
          <source>Each element kind is represented at the type level by one of the &lt;code&gt;*_elt&lt;/code&gt; types defined below (defined with a single constructor instead of abstract types for technical injectivity reasons).</source>
          <target state="translated">각 요소 종류는 아래에 정의 된 &lt;code&gt;*_elt&lt;/code&gt; 유형 중 하나에 의해 유형 수준에서 표현 됩니다 (기술적 인 주입을 위해 추상 유형 대신 단일 생성자로 정의 됨).</target>
        </trans-unit>
        <trans-unit id="1caee92a2ad2725943710d2a2bd8290a46c8e471" translate="yes" xml:space="preserve">
          <source>Each layout style is identified at the type level by the phantom types &lt;a href=&quot;bigarray#VALc_layout&quot;&gt;&lt;code&gt;Bigarray.c_layout&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;bigarray#VALfortran_layout&quot;&gt;&lt;code&gt;Bigarray.fortran_layout&lt;/code&gt;&lt;/a&gt; respectively.</source>
          <target state="translated">각 레이아웃 스타일은 팬텀 유형 &lt;a href=&quot;bigarray#VALc_layout&quot;&gt; &lt;code&gt;Bigarray.c_layout&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;bigarray#VALfortran_layout&quot;&gt; &lt;code&gt;Bigarray.fortran_layout&lt;/code&gt; &lt;/a&gt; 각각에 의해 유형 레벨에서 식별 됩니다.</target>
        </trans-unit>
        <trans-unit id="afd355e1568c837c2d8a8aa22882d7a019020c0f" translate="yes" xml:space="preserve">
          <source>Each method may have an explicit polymorphic type: { '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; }&lt;sup&gt;+&lt;/sup&gt;.&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;. Explicit polymorphic variables have a local scope, and an explicit polymorphic type can only be unified to an equivalent one, where only the order and names of polymorphic variables may change.</source>
          <target state="translated">각 메소드는 명시 적 다형성 유형을 가질 수 있습니다 : { ' &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; } &lt;sup&gt;+&lt;/sup&gt; . &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; . 명시 적 다형성 변수에는 로컬 범위가 있으며 명시 적 다형성 유형은 다형성 변수의 순서와 이름 만 변경 될 수있는 동등한 유형으로 만 통합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c5d98785b7743a02a2a0703c996991daf64afaa" translate="yes" xml:space="preserve">
          <source>Each time a program is started in the debugger, it inherits its working directory from the current working directory of the debugger. This working directory is initially whatever it inherited from its parent process (typically the shell), but you can specify a new working directory in the debugger with the cd command or the -cd command-line option.</source>
          <target state="translated">프로그램이 디버거에서 시작될 때마다 디버거의 현재 작업 디렉토리에서 작업 디렉토리를 상속합니다. 이 작업 디렉터리는 처음에는 부모 프로세스 (일반적으로 셸)에서 상속 된 모든 것이지만, cd 명령 또는 -cd 명령 줄 옵션을 사용하여 디버거에서 새 작업 디렉터리를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb29aeedb459a9843173566eb9da0953840aa4b6" translate="yes" xml:space="preserve">
          <source>Each time the program performs a function application, it saves the location of the application (the return address) in a block of data called a stack frame. The frame also contains the local variables of the caller function. All the frames are allocated in a region of memory called the call stack. The command backtrace (or bt) displays parts of the call stack.</source>
          <target state="translated">프로그램이 함수 응용 프로그램을 수행 할 때마다 응용 프로그램의 위치 (반환 주소)를 스택 프레임이라는 데이터 블록에 저장합니다. 프레임에는 호출자 함수의 지역 변수도 포함됩니다. 모든 프레임은 호출 스택이라는 메모리 영역에 할당됩니다. backtrace (또는 bt) 명령은 호출 스택의 일부를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="58a82f869d0845906f5636307dfedb10af696ef7" translate="yes" xml:space="preserve">
          <source>Each type definition in the signature specifies an optional type equation =&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; and an optional type representation =&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; &amp;hellip; or ={&lt;a href=&quot;typedecl#field-decl&quot;&gt;field-decl&lt;/a&gt; &amp;hellip; }. The implementation of the type name in a matching structure must be compatible with the type expression specified in the equation (if given), and have the specified representation (if given). Conversely, users of that signature will be able to rely on the type equation or type representation, if given. More precisely, we have the following four situations:</source>
          <target state="translated">서명의 각 유형 정의는 선택적 유형 방정식 = &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; 및 선택적 유형 표현 = &lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; &amp;hellip; 또는 = { &lt;a href=&quot;typedecl#field-decl&quot;&gt;field-decl&lt;/a&gt; &amp;hellip;}을 지정합니다. 일치하는 구조에서 유형 이름의 구현은 방정식에 지정된 유형 표현식 (주어진 경우)과 호환되어야하며 지정된 표현 (주어진 경우)을 가져야합니다. 반대로, 해당 서명의 사용자는 유형 방정식 또는 유형 표현 (주어진 경우)에 의존 할 수 있습니다. 보다 정확하게는 다음과 같은 네 가지 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7aa85b74327e7f9399b7bfe326e5c61749ad3fe" translate="yes" xml:space="preserve">
          <source>Echo ERASE (to erase previous character).</source>
          <target state="translated">Echo ERASE (이전 문자 지우기).</target>
        </trans-unit>
        <trans-unit id="59905cd91eac129936169f92306974b7eb5df3e3" translate="yes" xml:space="preserve">
          <source>Echo KILL (to erase the current line).</source>
          <target state="translated">Echo KILL (현재 라인 삭제).</target>
        </trans-unit>
        <trans-unit id="818b41a3180b8626f2b705affbca4a9bb2d1edf0" translate="yes" xml:space="preserve">
          <source>Echo NL even if c_echo is not set.</source>
          <target state="translated">c_echo가 설정되지 않은 경우에도 NL을 에코합니다.</target>
        </trans-unit>
        <trans-unit id="b12403c7dc9b7aed8fe8263fa437f6a29922cd13" translate="yes" xml:space="preserve">
          <source>Echo input characters.</source>
          <target state="translated">에코 입력 문자.</target>
        </trans-unit>
        <trans-unit id="790ff9d91988a9f91bae9a1e80b3ea470a8793a7" translate="yes" xml:space="preserve">
          <source>Effects are classified as follows:</source>
          <target state="translated">효과는 다음과 같이 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="a1fe848d140abbda761fcab4b0a8ee4bff9b5618" translate="yes" xml:space="preserve">
          <source>Element kind</source>
          <target state="translated">요소 종류</target>
        </trans-unit>
        <trans-unit id="0c901356ec250da6646a0d255d0a5012286fed26" translate="yes" xml:space="preserve">
          <source>Element kinds</source>
          <target state="translated">요소 종류</target>
        </trans-unit>
        <trans-unit id="773ebef232798eb1bcd798e64d46f5fd4d344ed8" translate="yes" xml:space="preserve">
          <source>Elements of this type can still be compared and hashed: when two elements are equal, then they represent the same source location (the converse is not necessarily true in presence of inlining, for example).</source>
          <target state="translated">이 유형의 요소는 여전히 비교 및 ​​해시 될 수 있습니다. 두 요소가 같으면 동일한 소스 위치를 나타냅니다 (예를 들어 인라인이있는 경우 그 반대가 반드시 사실은 아닙니다).</target>
        </trans-unit>
        <trans-unit id="6ff0f4a868ef59be803181103a0f8dacda1099dd" translate="yes" xml:space="preserve">
          <source>Ellipsis</source>
          <target state="translated">Ellipsis</target>
        </trans-unit>
        <trans-unit id="a951b7cdcb19dc8f856bf6e83e270d878bd2aebe" translate="yes" xml:space="preserve">
          <source>Emit .inlining files (one per round of optimisation) showing all of the inliner&amp;rsquo;s decisions.</source>
          <target state="translated">모든 인라이너의 결정을 보여주는 .inlining 파일 (최적화 라운드 당 하나씩)을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="0b66f486cf8274cb9bca30676fc931fad21f1de5" translate="yes" xml:space="preserve">
          <source>Emit XON/XOFF chars to control input flow.</source>
          <target state="translated">입력 흐름을 제어하기 위해 XON / XOFF 문자를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="ae6d8285d87efe002dc771b241b8d06271e73877" translate="yes" xml:space="preserve">
          <source>Empty a hash table and shrink the size of the bucket table to its initial size.</source>
          <target state="translated">해시 테이블을 비우고 버킷 테이블의 크기를 초기 크기로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="e37b57ef58e23b53c8f30296b9c000edeef1ce74" translate="yes" xml:space="preserve">
          <source>Empty a hash table.</source>
          <target state="translated">해시 테이블을 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="00055027ec241f03bc3323a54fed41f0a8808bad" translate="yes" xml:space="preserve">
          <source>Empty a hash table. Use &lt;code&gt;reset&lt;/code&gt; instead of &lt;code&gt;clear&lt;/code&gt; to shrink the size of the bucket table to its initial size.</source>
          <target state="translated">해시 테이블을 비 웁니다. &lt;code&gt;clear&lt;/code&gt; 대신 &lt;code&gt;reset&lt;/code&gt; 을 사용 하여 버킷 테이블의 크기를 초기 크기로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="41e879386eb7dfd68165ba47fe880a837898c987" translate="yes" xml:space="preserve">
          <source>Empty the buffer and deallocate the internal byte sequence holding the buffer contents, replacing it with the initial internal byte sequence of length &lt;code&gt;n&lt;/code&gt; that was allocated by &lt;a href=&quot;buffer#VALcreate&quot;&gt;&lt;code&gt;Buffer.create&lt;/code&gt;&lt;/a&gt;&lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">버퍼를 비우고 버퍼 내용을 보유한 내부 바이트 시퀀스를 할당 해제하여 &lt;a href=&quot;buffer#VALcreate&quot;&gt; &lt;code&gt;Buffer.create&lt;/code&gt; &lt;/a&gt; &lt;code&gt;n&lt;/code&gt; 에 의해 할당 된 길이 &lt;code&gt;n&lt;/code&gt; 의 초기 내부 바이트 시퀀스로 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="fc2a8448f140b28c370341466e87e932ee8786a1" translate="yes" xml:space="preserve">
          <source>Empty the buffer and deallocate the internal byte sequence holding the buffer contents, replacing it with the initial internal byte sequence of length &lt;code&gt;n&lt;/code&gt; that was allocated by &lt;a href=&quot;buffer#VALcreate&quot;&gt;&lt;code&gt;Buffer.create&lt;/code&gt;&lt;/a&gt;&lt;code&gt;n&lt;/code&gt;. For long-lived buffers that may have grown a lot, &lt;code&gt;reset&lt;/code&gt; allows faster reclamation of the space used by the buffer.</source>
          <target state="translated">버퍼를 비우고 버퍼 내용을 보유한 내부 바이트 시퀀스를 할당 해제하여 &lt;a href=&quot;buffer#VALcreate&quot;&gt; &lt;code&gt;Buffer.create&lt;/code&gt; &lt;/a&gt; &lt;code&gt;n&lt;/code&gt; 에 의해 할당 된 길이 &lt;code&gt;n&lt;/code&gt; 의 초기 내부 바이트 시퀀스로 바꿉니다 . 많이 증가했을 수있는 수명이 긴 버퍼의 경우 &lt;code&gt;reset&lt;/code&gt; 사용하면 버퍼에서 사용하는 공간을 더 빨리 회수 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebf089f9c5c1c0373c6ce76e0a9cc360bcd1ef69" translate="yes" xml:space="preserve">
          <source>Empty the buffer.</source>
          <target state="translated">버퍼를 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="b00390bd2f9505f4d62d808cec4546f6464f7fed" translate="yes" xml:space="preserve">
          <source>Empty the parser stack.</source>
          <target state="translated">파서 스택을 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="f101e78b0fa42d75dcdc4adb6d4084b4a601834d" translate="yes" xml:space="preserve">
          <source>Empty the parser stack. Call it just after a parsing function has returned, to remove all pointers from the parser stack to structures that were built by semantic actions during parsing. This is optional, but lowers the memory requirements of the programs.</source>
          <target state="translated">파서 스택을 비 웁니다. 구문 분석 함수가 반환 된 직후에이를 호출하여 구문 분석 중에 의미 론적 작업에 의해 빌드 된 구조에 대한 구문 분석기 스택의 모든 포인터를 제거합니다. 이것은 선택 사항이지만 프로그램의 메모리 요구 사항을 낮 춥니 다.</target>
        </trans-unit>
        <trans-unit id="0074df63c6d023e7952d43a2b914df91ffff8c57" translate="yes" xml:space="preserve">
          <source>Enable and mark as fatal the set of warnings corresponding to letter. The letter may be uppercase or lowercase.</source>
          <target state="translated">문자에 해당하는 경고 세트를 활성화하고 치명적인 것으로 표시합니다. 문자는 대문자 또는 소문자 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3599d807d73244d1d2b2c6bbb5870d2aa02d3a1a" translate="yes" xml:space="preserve">
          <source>Enable and mark as fatal warning number num.</source>
          <target state="translated">치명적인 경고 번호 num을 활성화하고 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a8d07d21892b973a86c258d424467b16d34fb15e" translate="yes" xml:space="preserve">
          <source>Enable and mark as fatal warnings in the given range.</source>
          <target state="translated">지정된 범위에서 치명적인 경고를 활성화하고 표시합니다.</target>
        </trans-unit>
        <trans-unit id="c78968437d3375a093ddfb521ecf6242e8d1eedd" translate="yes" xml:space="preserve">
          <source>Enable canonical processing (line buffering and editing)</source>
          <target state="translated">표준 처리 사용 (라인 버퍼링 및 편집)</target>
        </trans-unit>
        <trans-unit id="929680a8eee524b77121874d47b6662082176d5c" translate="yes" xml:space="preserve">
          <source>Enable or disable colors in compiler messages (especially warnings and errors). The following modes are supported:</source>
          <target state="translated">컴파일러 메시지 (특히 경고 및 오류)에서 색상을 활성화하거나 비활성화합니다. 다음 모드가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c3548fe32ed1474e82f947e74c5e0161162ca1d4" translate="yes" xml:space="preserve">
          <source>Enable or disable warnings according to the argument.</source>
          <target state="translated">인수에 따라 경고를 활성화하거나 비활성화합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
