<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="13f248c7dff46b33a22350ddd81e8c58ed82286f" translate="yes" xml:space="preserve">
          <source>Return an integer identifying this object, unique for the current execution of the program. The generic comparison and hashing functions are based on this integer. When an object is obtained by unmarshaling, the id is refreshed, and thus different from the original object. As a consequence, the internal invariants of data structures such as hash table or sets containing objects are broken after unmarshaling the data structures.</source>
          <target state="translated">현재 프로그램 실행에 고유 한이 객체를 식별하는 정수를 반환합니다. 일반 비교 및 ​​해싱 함수는이 정수를 기반으로합니다. 언 마샬링으로 객체를 얻으면 ID가 새로 고쳐 지므로 원래 객체와 다릅니다. 결과적으로 해시 테이블 또는 개체를 포함하는 집합과 같은 데이터 구조의 내부 불변은 데이터 구조를 마샬링 해제 한 후 깨집니다.</target>
        </trans-unit>
        <trans-unit id="804397fe4360a7b93b1321b1e8d68c91a432d7e1" translate="yes" xml:space="preserve">
          <source>Return one binding of the given map, or &lt;code&gt;None&lt;/code&gt; if the map is empty.</source>
          <target state="translated">주어진 맵의 바인딩 하나를 반환하거나 맵이 비어있는 경우 &lt;code&gt;None&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc7bb0cd7be56d08766ada3849b3bc9cf97fa116" translate="yes" xml:space="preserve">
          <source>Return one binding of the given map, or &lt;code&gt;None&lt;/code&gt; if the map is empty. Which binding is chosen is unspecified, but equal bindings will be chosen for equal maps.</source>
          <target state="translated">주어진 맵의 바인딩 하나를 반환하거나 맵이 비어있는 경우 &lt;code&gt;None&lt;/code&gt; 을 반환합니다. 선택한 바인딩은 지정되지 않지만 동일한 맵에 대해 동일한 바인딩이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="230572b81a15aeef6cca691ef685c7861b2c3403" translate="yes" xml:space="preserve">
          <source>Return one binding of the given map, or raise &lt;code&gt;Not_found&lt;/code&gt; if the map is empty.</source>
          <target state="translated">주어진 맵의 바인딩 하나를 반환하거나 맵이 비어 있으면 &lt;code&gt;Not_found&lt;/code&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="124a277abe9168405efebc5229d58eb1ce179fff" translate="yes" xml:space="preserve">
          <source>Return one binding of the given map, or raise &lt;code&gt;Not_found&lt;/code&gt; if the map is empty. Which binding is chosen is unspecified, but equal bindings will be chosen for equal maps.</source>
          <target state="translated">주어진 맵의 바인딩 하나를 반환하거나 맵이 비어 있으면 &lt;code&gt;Not_found&lt;/code&gt; 를 발생시킵니다. 선택한 바인딩은 지정되지 않지만 동일한 맵에 대해 동일한 바인딩이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="1ebf20277e5047adf3133b397b741b144bdd0bde" translate="yes" xml:space="preserve">
          <source>Return one element of the given set, or &lt;code&gt;None&lt;/code&gt; if the set is empty.</source>
          <target state="translated">주어진 집합의 한 요소를 반환하거나 집합이 비어 있으면 &lt;code&gt;None&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c4448d26f33d8f4ec291a782cfccb39dca2a6be" translate="yes" xml:space="preserve">
          <source>Return one element of the given set, or &lt;code&gt;None&lt;/code&gt; if the set is empty. Which element is chosen is unspecified, but equal elements will be chosen for equal sets.</source>
          <target state="translated">주어진 집합의 한 요소를 반환하거나 집합이 비어 있으면 &lt;code&gt;None&lt;/code&gt; 을 반환합니다. 선택된 요소는 지정되지 않지만 동일한 세트에 대해 동일한 요소가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="e50b9d9e24aa0f6fb2f8db6ce9e9c79af9f3eba9" translate="yes" xml:space="preserve">
          <source>Return one element of the given set, or raise &lt;code&gt;Not_found&lt;/code&gt; if the set is empty.</source>
          <target state="translated">주어진 집합의 한 요소를 반환하거나 집합이 비어 있으면 &lt;code&gt;Not_found&lt;/code&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b24191c024f2ae60011ab6b0eaa33a89e12e8bc5" translate="yes" xml:space="preserve">
          <source>Return one element of the given set, or raise &lt;code&gt;Not_found&lt;/code&gt; if the set is empty. Which element is chosen is unspecified, but equal elements will be chosen for equal sets.</source>
          <target state="translated">주어진 집합의 한 요소를 반환하거나 집합이 비어 있으면 &lt;code&gt;Not_found&lt;/code&gt; 를 발생시킵니다. 선택된 요소는 지정되지 않지만 동일한 세트에 대해 동일한 요소가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="a2668767821e82c723e2b93b0851a6112d9b6d7c" translate="yes" xml:space="preserve">
          <source>Return statistics on the table.</source>
          <target state="translated">테이블에 대한 통계를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="39c19f3fe502749c27276fc6e62020dc173d3ed4" translate="yes" xml:space="preserve">
          <source>Return statistics on the table. The numbers are, in order: table length, number of entries, sum of bucket lengths, smallest bucket length, median bucket length, biggest bucket length.</source>
          <target state="translated">테이블에 대한 통계를 반환합니다. 숫자는 순서대로 테이블 길이, 항목 수, 버킷 길이 합계, 최소 버킷 길이, 중간 버킷 길이, 가장 큰 버킷 길이입니다.</target>
        </trans-unit>
        <trans-unit id="3b14bc9c2b106d546f0f2fd2df64962aa24dc4cb" translate="yes" xml:space="preserve">
          <source>Return the &lt;code&gt;n&lt;/code&gt;-th element of the given list.</source>
          <target state="translated">주어진 목록 의 &lt;code&gt;n&lt;/code&gt; 번째 요소를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="26efcbf81d6b8b4c2e871a9a53668bd5e1a815fe" translate="yes" xml:space="preserve">
          <source>Return the &lt;code&gt;n&lt;/code&gt;-th element of the given list. The first element (head of the list) is at position 0.</source>
          <target state="translated">주어진 목록 의 &lt;code&gt;n&lt;/code&gt; 번째 요소를 반환합니다 . 첫 번째 요소 (목록의 헤드)는 위치 0에 있습니다.</target>
        </trans-unit>
        <trans-unit id="439f68fc82739159c89fa8bd3a099b303fff11d0" translate="yes" xml:space="preserve">
          <source>Return the &lt;code&gt;n&lt;/code&gt;-th element of the given list. The first element (head of the list) is at position 0. Return &lt;code&gt;None&lt;/code&gt; if the list is too short.</source>
          <target state="translated">주어진 목록 의 &lt;code&gt;n&lt;/code&gt; 번째 요소를 반환합니다 . 첫 번째 요소 (목록의 헤드)는 위치 0 에 있습니다. 목록이 너무 짧으면 &lt;code&gt;None&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="880749007a41766d110001af9265fa1871ef60e1" translate="yes" xml:space="preserve">
          <source>Return the ASCII code of the argument.</source>
          <target state="translated">인수의 ASCII 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="62309110a8b557ea8cae3a1d13024ea105ebe175" translate="yes" xml:space="preserve">
          <source>Return the absolute position in the input text of the beginning of the matched string (i.e. the offset of the first character of the matched string). The first character read from the input text has offset 0.</source>
          <target state="translated">일치하는 문자열의 시작 부분에있는 입력 텍스트의 절대 위치를 반환합니다 (예 : 일치하는 문자열의 첫 문자 오프셋). 입력 텍스트에서 읽은 첫 번째 문자의 오프셋은 0입니다.</target>
        </trans-unit>
        <trans-unit id="a38456990b8f53a5e41580437c2b772f29fbbcd5" translate="yes" xml:space="preserve">
          <source>Return the absolute position in the input text of the end of the matched string (i.e. the offset of the first character after the matched string). The first character read from the input text has offset 0.</source>
          <target state="translated">일치하는 문자열 끝의 입력 텍스트에서 절대 위치를 반환합니다 (예 : 일치 된 문자열 뒤의 첫 번째 문자 오프셋). 입력 텍스트에서 읽은 첫 번째 문자의 오프셋은 0입니다.</target>
        </trans-unit>
        <trans-unit id="3d6cef13623598e5301ce130fae4c314144a19cd" translate="yes" xml:space="preserve">
          <source>Return the absolute value of its argument.</source>
          <target state="translated">인수의 절대 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0f4af466676d95e077ec7d0c0eb365f94b3b64d5" translate="yes" xml:space="preserve">
          <source>Return the absolute value of the argument.</source>
          <target state="translated">인수의 절대 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="17ea151ac7470057db09f6562f8d1f70a4d6035e" translate="yes" xml:space="preserve">
          <source>Return the absolute value of the argument. Note that this may be negative if the argument is &lt;code&gt;min_int&lt;/code&gt;.</source>
          <target state="translated">인수의 절대 값을 반환합니다. 인수가 &lt;code&gt;min_int&lt;/code&gt; 인 경우 음수 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9a4944787a25989444442aa9e3a355615036d44" translate="yes" xml:space="preserve">
          <source>Return the address of the given socket.</source>
          <target state="translated">주어진 소켓의 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1d88b6381fa842d1f4f6342c5da6ca29e60697e5" translate="yes" xml:space="preserve">
          <source>Return the address of the host connected to the given socket.</source>
          <target state="translated">주어진 소켓에 연결된 호스트의 주소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b23d1b53534dc72170ae7e7df22ce7e3b6e63a0b" translate="yes" xml:space="preserve">
          <source>Return the binding with the smallest key in a given map (with respect to the &lt;code&gt;Ord.compare&lt;/code&gt; ordering), or raise &lt;code&gt;Not_found&lt;/code&gt; if the map is empty.</source>
          <target state="translated">( &lt;code&gt;Ord.compare&lt;/code&gt; 순서 와 관련하여) 주어진 맵에서 가장 작은 키로 바인딩을 반환 하거나 맵이 비어 있으면 &lt;code&gt;Not_found&lt;/code&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="70bcb73b7fd699f6c85a0c103b4b8b010b19a5fd" translate="yes" xml:space="preserve">
          <source>Return the binding with the smallest key in the given map (with respect to the &lt;code&gt;Ord.compare&lt;/code&gt; ordering), or &lt;code&gt;None&lt;/code&gt; if the map is empty.</source>
          <target state="translated">( &lt;code&gt;Ord.compare&lt;/code&gt; 순서 와 관련하여) 주어진 맵에서 가장 작은 키를 사용하여 바인딩을 반환 하거나 맵이 비어있는 경우 &lt;code&gt;None&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a6becf53316957bcff27455506fc07eb7ab5f5b3" translate="yes" xml:space="preserve">
          <source>Return the character with the given ASCII code.</source>
          <target state="translated">주어진 ASCII 코드로 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4730bd2de886423d30f0d19b51f0a1b9479a1640" translate="yes" xml:space="preserve">
          <source>Return the class of the given floating-point number: normal, subnormal, zero, infinite, or not a number.</source>
          <target state="translated">주어진 부동 소수점 숫자의 클래스를 반환합니다 : 정상, 비정규, 0, 무한 또는 숫자 아님.</target>
        </trans-unit>
        <trans-unit id="297faae34a2f7b1feb5518dd123e21cb6367aaf9" translate="yes" xml:space="preserve">
          <source>Return the current count of the stream elements, i.e.</source>
          <target state="translated">스트림 요소의 현재 개수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f1000e714fb7aea64ea12d37a444505d73c718ac" translate="yes" xml:space="preserve">
          <source>Return the current count of the stream elements, i.e. the number of the stream elements discarded.</source>
          <target state="translated">스트림 요소의 현재 개수, 즉 폐기 된 스트림 요소의 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cf89807c32bb79e188d60fe9f5c2ecba00abf545" translate="yes" xml:space="preserve">
          <source>Return the current geometry of the formatter</source>
          <target state="translated">포맷터의 현재 지오메트리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9ca644d1cd0b6c0e16996557a51ed8ab650ed7de" translate="yes" xml:space="preserve">
          <source>Return the current output functions of the pretty-printer, including line splitting and indentation functions.</source>
          <target state="translated">줄 분할 및 들여 쓰기 기능을 포함하여 pretty-printer의 현재 출력 기능을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="14b2c9e70475a936059f7c3930230d44b092c2c3" translate="yes" xml:space="preserve">
          <source>Return the current output functions of the pretty-printer, including line splitting and indentation functions. Useful to record the current setting and restore it afterwards.</source>
          <target state="translated">줄 분할 및 들여 쓰기 기능을 포함하여 pretty-printer의 현재 출력 기능을 반환합니다. 현재 설정을 기록하고 나중에 복원하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b794103dee584cdb1d544ad3755a731469d7fb13" translate="yes" xml:space="preserve">
          <source>Return the current output functions of the standard pretty-printer.</source>
          <target state="translated">표준 pretty-printer의 현재 출력 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eff9b824a0e019fcb1034af9bd056ef1df654d9b" translate="yes" xml:space="preserve">
          <source>Return the current reading position for the given channel.</source>
          <target state="translated">주어진 채널에 대한 현재 읽기 위치를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="afe223ce43f4b699ad9d10edf014aa134257db24" translate="yes" xml:space="preserve">
          <source>Return the current semantic tag operation functions of the standard pretty-printer.</source>
          <target state="translated">표준 pretty-printer의 현재 의미 태그 작업 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5bd7128a788ba19d6246c464eeb82cab7819d195" translate="yes" xml:space="preserve">
          <source>Return the current size of the free space inside the minor heap.</source>
          <target state="translated">부 힙 내부의 현재 여유 공간 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1c243dd17b2c9d8d725b1a348f37d36f5f593f9a" translate="yes" xml:space="preserve">
          <source>Return the current state of the generator used by the basic functions.</source>
          <target state="translated">기본 함수에서 사용하는 생성기의 현재 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="943c6a72d4cef970955cf8a0baf23383f000fbb7" translate="yes" xml:space="preserve">
          <source>Return the current status of a boolean-valued option in the given socket.</source>
          <target state="translated">주어진 소켓에서 부울 값 옵션의 현재 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="88480a696e89616baae30b34bdb2d51b04386c45" translate="yes" xml:space="preserve">
          <source>Return the current status of tag-marking operations.</source>
          <target state="translated">태그 표시 작업의 현재 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3cb446fa637b6b8d3341bc3ef1f6743acef08ad0" translate="yes" xml:space="preserve">
          <source>Return the current status of tag-printing operations.</source>
          <target state="translated">태그 인쇄 작업의 현재 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="69bd3c1db63c0329eef857a80c044eca2802fdb7" translate="yes" xml:space="preserve">
          <source>Return the current status of the given interval timer.</source>
          <target state="translated">주어진 간격 타이머의 현재 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="98e82fae89baddf835782503fb6225d243eabc1f" translate="yes" xml:space="preserve">
          <source>Return the current time since 00:00:00 GMT, Jan.</source>
          <target state="translated">1 월 00:00:00 GMT 이후의 현재 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0a38919a96af9027370dc236253891b359d8cae5" translate="yes" xml:space="preserve">
          <source>Return the current time since 00:00:00 GMT, Jan. 1, 1970, in seconds.</source>
          <target state="translated">1970 년 1 월 1 일 00:00:00 GMT 이후의 현재 시간을 초 단위로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f6196ac3aa3eec6746fc840473651108f002d8ef" translate="yes" xml:space="preserve">
          <source>Return the current values of the GC parameters in a &lt;code&gt;control&lt;/code&gt; record.</source>
          <target state="translated">&lt;code&gt;control&lt;/code&gt; 레코드 에서 GC 매개 변수의 현재 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="44719d7e8bb31855760dce4861d3c60c50d390cf" translate="yes" xml:space="preserve">
          <source>Return the current values of the memory management counters in a &lt;code&gt;stat&lt;/code&gt; record.</source>
          <target state="translated">&lt;code&gt;stat&lt;/code&gt; 레코드 에서 메모리 관리 카운터의 현재 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2b116d8325e3d4fc3b7bbb805c51a92a5e4ca950" translate="yes" xml:space="preserve">
          <source>Return the current values of the memory management counters in a &lt;code&gt;stat&lt;/code&gt; record. This function examines every heap block to get the statistics.</source>
          <target state="translated">&lt;code&gt;stat&lt;/code&gt; 레코드 에서 메모리 관리 카운터의 현재 값을 반환합니다 . 이 함수는 통계를 얻기 위해 모든 힙 블록을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="b51f594db2ca91923182a8a03e87942bbdf3dd65" translate="yes" xml:space="preserve">
          <source>Return the current working directory of the process.</source>
          <target state="translated">프로세스의 현재 작업 디렉토리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b9fdf5ba7864c712d65c10e01b2df194f8c4798a" translate="yes" xml:space="preserve">
          <source>Return the current writing position for the given channel.</source>
          <target state="translated">주어진 채널의 현재 쓰기 위치를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b8a1bd4616f338e6148dd3304b4f698e1f7dfc7e" translate="yes" xml:space="preserve">
          <source>Return the current writing position for the given channel. Does not work on channels opened with the &lt;code&gt;Open_append&lt;/code&gt; flag (returns unspecified results).</source>
          <target state="translated">주어진 채널의 현재 쓰기 위치를 반환합니다. &lt;code&gt;Open_append&lt;/code&gt; 플래그로 열린 채널에서는 작동하지 않습니다 (지정되지 않은 결과 반환).</target>
        </trans-unit>
        <trans-unit id="2343a41b996d55a8d25ecddc78423dc6b799a99f" translate="yes" xml:space="preserve">
          <source>Return the descriptor corresponding to an input channel.</source>
          <target state="translated">입력 채널에 해당하는 설명자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8911533c9b1c801a828b9754a01fdb4faa39a9bf" translate="yes" xml:space="preserve">
          <source>Return the descriptor corresponding to an output channel.</source>
          <target state="translated">출력 채널에 해당하는 설명자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9e02fc3737cd0829b6678335c27fbe932f631180" translate="yes" xml:space="preserve">
          <source>Return the digest of the file whose name is given.</source>
          <target state="translated">이름이 주어진 파일의 다이제스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b515b9e20b23a0a3279dcddb264ee7e4e625794c" translate="yes" xml:space="preserve">
          <source>Return the digest of the given byte sequence.</source>
          <target state="translated">주어진 바이트 시퀀스의 다이제스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fb9443c254d54b0479884ecc92745eee7fbc192c" translate="yes" xml:space="preserve">
          <source>Return the digest of the given string.</source>
          <target state="translated">주어진 문자열의 다이제스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f91e50e6edb1482d99464ee157aeb985e2039702" translate="yes" xml:space="preserve">
          <source>Return the effective group id under which the process runs.</source>
          <target state="translated">프로세스가 실행되는 유효 그룹 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="119bac2074c3825d2b1c5479ab32d82aea1ad7a6" translate="yes" xml:space="preserve">
          <source>Return the effective group id under which the process runs. On Windows, always return &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">프로세스가 실행되는 유효 그룹 ID를 반환합니다. Windows에서는 항상 &lt;code&gt;1&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="fbe498ef01b9bf595af9e3d24374ea71398f98f1" translate="yes" xml:space="preserve">
          <source>Return the effective user id under which the process runs.</source>
          <target state="translated">프로세스가 실행되는 유효 사용자 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0f897629460b4a3a8c93f1dc57b0ec69c8498278" translate="yes" xml:space="preserve">
          <source>Return the effective user id under which the process runs. On Windows, always return &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">프로세스가 실행되는 유효 사용자 ID를 반환합니다. Windows에서는 항상 &lt;code&gt;1&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="68010ab93fd161a3fbf3c3cb740b170262747251" translate="yes" xml:space="preserve">
          <source>Return the error condition associated with the given socket, and clear it.</source>
          <target state="translated">주어진 소켓과 관련된 오류 조건을 반환하고 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="e4e4079fcd2deec8751ab333613cb019236f602f" translate="yes" xml:space="preserve">
          <source>Return the execution times of the process.</source>
          <target state="translated">프로세스의 실행 시간을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="361c27e98de822a527a95a05249324e1c20ba145" translate="yes" xml:space="preserve">
          <source>Return the execution times of the process. On Windows, it is partially implemented, will not report timings for child processes.</source>
          <target state="translated">프로세스의 실행 시간을 반환합니다. Windows에서는 부분적으로 구현되며 하위 프로세스에 대한 타이밍을보고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8f74d0d37d740c194c05fdbe3ea6ce00b232066" translate="yes" xml:space="preserve">
          <source>Return the first component of a pair.</source>
          <target state="translated">쌍의 첫 번째 구성 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5c835e8304c5686221cc688117adb8f1cb010c68" translate="yes" xml:space="preserve">
          <source>Return the first dimension of the given three-dimensional Bigarray.</source>
          <target state="translated">주어진 3 차원 Bigarray의 첫 번째 차원을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="061442e7ed48f7ee1e9d425b6ff921b12a846bca" translate="yes" xml:space="preserve">
          <source>Return the first dimension of the given two-dimensional Bigarray.</source>
          <target state="translated">주어진 2 차원 Bigarray의 첫 번째 차원을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="536a414181a39a9345425eff5341faaa394d3b1b" translate="yes" xml:space="preserve">
          <source>Return the first element of the given list.</source>
          <target state="translated">주어진 목록의 첫 번째 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3d8fffadcb1b4ea149990ff4a30172b6ca997a6a" translate="yes" xml:space="preserve">
          <source>Return the first element of the stream and remove it from the stream.</source>
          <target state="translated">스트림의 첫 번째 요소를 반환하고 스트림에서 제거합니다.</target>
        </trans-unit>
        <trans-unit id="56ffa9e9d4748719dcf1e8a5b7e7590761c6fbf4" translate="yes" xml:space="preserve">
          <source>Return the floating-point number whose internal representation, according to the IEEE 754 floating-point 'double format' bit layout, is the given &lt;code&gt;int64&lt;/code&gt;.</source>
          <target state="translated">IEEE 754 부동 소수점 'double 형식'비트 레이아웃에 따라 내부 표현이 지정된 &lt;code&gt;int64&lt;/code&gt; 인 부동 소수점 숫자를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0255e8862323a496e08690b4bf401e80e550ddc1" translate="yes" xml:space="preserve">
          <source>Return the floating-point number whose internal representation, according to the IEEE 754 floating-point 'single format' bit layout, is the given &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="translated">IEEE 754 부동 소수점 '단일 형식'비트 레이아웃에 따른 내부 표현이 지정된 &lt;code&gt;int32&lt;/code&gt; 인 부동 소수점 숫자를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e9c4c901a6eb1a0977dadc6e69d61a34194fc8ba" translate="yes" xml:space="preserve">
          <source>Return the generic Bigarray corresponding to the given one-dimensional Bigarray.</source>
          <target state="translated">주어진 1 차원 Bigarray에 해당하는 일반 Bigarray를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="280989a968e0d4678c5045e97ddbadc039ff9b3c" translate="yes" xml:space="preserve">
          <source>Return the generic Bigarray corresponding to the given three-dimensional Bigarray.</source>
          <target state="translated">주어진 3 차원 Bigarray에 해당하는 일반 Bigarray를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f88ffd32401e861a73d7457bdcce4cdadb2fb158" translate="yes" xml:space="preserve">
          <source>Return the generic Bigarray corresponding to the given two-dimensional Bigarray.</source>
          <target state="translated">주어진 2 차원 Bigarray에 해당하는 일반 Bigarray를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c478846fce1e2099ff024506834a919a61d55151" translate="yes" xml:space="preserve">
          <source>Return the generic Bigarray corresponding to the given zero-dimensional Bigarray.</source>
          <target state="translated">주어진 0 차원 Bigarray에 해당하는 일반 Bigarray를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc9490bf41cb044a767d8ecda3e6d8e764af360c" translate="yes" xml:space="preserve">
          <source>Return the given file name without its extension, as defined in &lt;a href=&quot;filename#VALextension&quot;&gt;&lt;code&gt;Filename.extension&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;filename#VALextension&quot;&gt; &lt;code&gt;Filename.extension&lt;/code&gt; 에&lt;/a&gt; 정의 된대로 확장자없이 주어진 파일 이름을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cbeb5a95f618b68d571b483955e1a67b0f5d9cd7" translate="yes" xml:space="preserve">
          <source>Return the given file name without its extension, as defined in &lt;a href=&quot;filename#VALextension&quot;&gt;&lt;code&gt;Filename.extension&lt;/code&gt;&lt;/a&gt;. If the extension is empty, the function returns the given file name.</source>
          <target state="translated">&lt;a href=&quot;filename#VALextension&quot;&gt; &lt;code&gt;Filename.extension&lt;/code&gt; 에&lt;/a&gt; 정의 된대로 확장자없이 주어진 파일 이름을 반환합니다 . 확장자가 비어 있으면 함수는 주어진 파일 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="57c4fc04ba0210ef8155903de749f6f7f8e5fdc1" translate="yes" xml:space="preserve">
          <source>Return the given list without its first element.</source>
          <target state="translated">첫 번째 요소없이 주어진 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6b8379eddac2088338789ec888081d219b0da1fe" translate="yes" xml:space="preserve">
          <source>Return the greater of the two arguments.</source>
          <target state="translated">두 인수 중 더 큰 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0f018fb98f8c4b680128d0c14134a0a9a3aaac43" translate="yes" xml:space="preserve">
          <source>Return the greater of the two arguments. The result is unspecified if one of the arguments contains the float value &lt;code&gt;nan&lt;/code&gt;.</source>
          <target state="translated">두 인수 중 더 큰 값을 반환합니다. 인수 중 하나에 float 값 &lt;code&gt;nan&lt;/code&gt; 이 포함되어 있으면 결과가 지정되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a9ec2343573237cf912dc10bb02e5eb00f995cca" translate="yes" xml:space="preserve">
          <source>Return the group id of the user executing the process.</source>
          <target state="translated">프로세스를 실행하는 사용자의 그룹 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="88ec1b3e6c12c625146f2658f42ac0c2f03a9ea6" translate="yes" xml:space="preserve">
          <source>Return the group id of the user executing the process. On Windows, always return &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">프로세스를 실행하는 사용자의 그룹 ID를 반환합니다. Windows에서는 항상 &lt;code&gt;1&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="a5d4df811b30db7cbb3591895b60fd73a1f6e9be" translate="yes" xml:space="preserve">
          <source>Return the identifier of the given thread.</source>
          <target state="translated">주어진 스레드의 식별자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8437064a240279d144b769a630d31ad04d45b176" translate="yes" xml:space="preserve">
          <source>Return the identifier of the given thread. A thread identifier is an integer that identifies uniquely the thread. It can be used to build data structures indexed by threads.</source>
          <target state="translated">주어진 스레드의 식별자를 반환합니다. 스레드 식별자는 스레드를 고유하게 식별하는 정수입니다. 스레드로 인덱싱 된 데이터 구조를 빌드하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53986db338c1e46f958b3889beea87e4b36619a7" translate="yes" xml:space="preserve">
          <source>Return the information for the file associated with the given descriptor.</source>
          <target state="translated">주어진 설명자와 관련된 파일에 대한 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a89a7e4971dc8dcc70684378487c7e7b89e6ad2b" translate="yes" xml:space="preserve">
          <source>Return the information for the named file.</source>
          <target state="translated">명명 된 파일에 대한 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4475177546721efc569c34552e395c02ed640a3a" translate="yes" xml:space="preserve">
          <source>Return the internal representation of the given float according to the IEEE 754 floating-point 'double format' bit layout.</source>
          <target state="translated">IEEE 754 부동 소수점 '이중 형식'비트 레이아웃에 따라 지정된 부동 소수점의 내부 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="93502737e716d9f9757a61699777755986f72a0e" translate="yes" xml:space="preserve">
          <source>Return the internal representation of the given float according to the IEEE 754 floating-point 'double format' bit layout. Bit 63 of the result represents the sign of the float; bits 62 to 52 represent the (biased) exponent; bits 51 to 0 represent the mantissa.</source>
          <target state="translated">IEEE 754 부동 소수점 '이중 형식'비트 레이아웃에 따라 지정된 부동 소수점의 내부 표현을 반환합니다. 결과의 비트 63은 float의 부호를 나타냅니다. 비트 62에서 52는 (편향된) 지수를 나타냅니다. 비트 51에서 0은 가수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bacbef4f17d22fba8858dbc5349f881670a4c0ab" translate="yes" xml:space="preserve">
          <source>Return the internal representation of the given float according to the IEEE 754 floating-point 'single format' bit layout.</source>
          <target state="translated">IEEE 754 부동 소수점 '단일 형식'비트 레이아웃에 따라 지정된 부동 소수점의 내부 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7fa42e30351ddbdb81bb4073e644aadc8ef7a5bb" translate="yes" xml:space="preserve">
          <source>Return the internal representation of the given float according to the IEEE 754 floating-point 'single format' bit layout. Bit 31 of the result represents the sign of the float; bits 30 to 23 represent the (biased) exponent; bits 22 to 0 represent the mantissa.</source>
          <target state="translated">IEEE 754 부동 소수점 '단일 형식'비트 레이아웃에 따라 지정된 부동 소수점의 내부 표현을 반환합니다. 결과의 비트 31은 float의 부호를 나타냅니다. 비트 30에서 23은 (편향된) 지수를 나타냅니다. 비트 22에서 0은 가수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7f2dc311581df1a1868e9b032519df8c89f6f55c" translate="yes" xml:space="preserve">
          <source>Return the kind of the given Bigarray.</source>
          <target state="translated">주어진 Bigarray의 종류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b55b427355dfe2cbb97cc49a217e5f7072008653" translate="yes" xml:space="preserve">
          <source>Return the layout of the given Bigarray.</source>
          <target state="translated">주어진 Bigarray의 레이아웃을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0349c494e937b3174164e1099b097cf8bd380e34" translate="yes" xml:space="preserve">
          <source>Return the length (number of bytes) of the argument.</source>
          <target state="translated">인수의 길이 (바이트 수)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="01e555b83a9a4fca65f457cd4b9ea918071e72f4" translate="yes" xml:space="preserve">
          <source>Return the length (number of characters) of the given string.</source>
          <target state="translated">주어진 문자열의 길이 (문자 수)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dca8f2d37620459f1a9a11d79e584a46d5e19f17" translate="yes" xml:space="preserve">
          <source>Return the length (number of elements) of the given array.</source>
          <target state="translated">주어진 배열의 길이 (요소 수)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b89723d06bf13b4a9eed201fbc2ea988b3af71eb" translate="yes" xml:space="preserve">
          <source>Return the length (number of elements) of the given floatarray.</source>
          <target state="translated">주어진 floatarray의 길이 (요소 수)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7dec03523e932f78284e510187eaa01cf693885e" translate="yes" xml:space="preserve">
          <source>Return the length (number of elements) of the given list.</source>
          <target state="translated">주어진 목록의 길이 (요소 수)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="48676ed71ee6c65819552a6e630eea359c21817a" translate="yes" xml:space="preserve">
          <source>Return the list of all bindings of the given map.</source>
          <target state="translated">주어진 맵의 모든 바인딩 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="059abc0a91c72aae1c317f8f630ca2bc69a23869" translate="yes" xml:space="preserve">
          <source>Return the list of all bindings of the given map. The returned list is sorted in increasing order of keys with respect to the ordering &lt;code&gt;Ord.compare&lt;/code&gt;, where &lt;code&gt;Ord&lt;/code&gt; is the argument given to &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 맵의 모든 바인딩 목록을 반환합니다. 반환 된 목록은 &lt;code&gt;Ord.compare&lt;/code&gt; 순서에 따라 키의 오름차순으로 정렬 됩니다 . 여기서 &lt;code&gt;Ord&lt;/code&gt; 는 &lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; 에&lt;/a&gt; 지정된 인수 입니다.</target>
        </trans-unit>
        <trans-unit id="d4c129d57ead162de7fc3aadfccf44081331889f" translate="yes" xml:space="preserve">
          <source>Return the list of all elements of the given set.</source>
          <target state="translated">주어진 세트의 모든 요소 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="532b8441cf3070f6987728e45ca3989a31cae74b" translate="yes" xml:space="preserve">
          <source>Return the list of all elements of the given set. The returned list is sorted in increasing order with respect to the ordering &lt;code&gt;Ord.compare&lt;/code&gt;, where &lt;code&gt;Ord&lt;/code&gt; is the argument given to &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 세트의 모든 요소 목록을 반환합니다. 반환 된 목록은 &lt;code&gt;Ord.compare&lt;/code&gt; 순서에 따라 오름차순으로 정렬됩니다 . 여기서 &lt;code&gt;Ord&lt;/code&gt; 는 &lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; 에&lt;/a&gt; 지정된 인수 입니다.</target>
        </trans-unit>
        <trans-unit id="c7165c129eabb85b52248e1854cabbc7dc158870" translate="yes" xml:space="preserve">
          <source>Return the list of compilation units that form the main program (i.e.</source>
          <target state="translated">메인 프로그램을 구성하는 컴파일 단위 목록을 반환합니다 (예 :</target>
        </trans-unit>
        <trans-unit id="d3ac56bfe9bb0dd951530aefcb02722ef531c1e1" translate="yes" xml:space="preserve">
          <source>Return the list of compilation units that form the main program (i.e. are not dynamically linked).</source>
          <target state="translated">주 프로그램을 구성하는 컴파일 단위 목록을 반환합니다 (즉, 동적으로 연결되지 않음).</target>
        </trans-unit>
        <trans-unit id="0c5c84e5aab94485a3b9e83f3977f1e9404351c9" translate="yes" xml:space="preserve">
          <source>Return the list of compilation units that form the main program together with those that have been dynamically loaded via &lt;code&gt;loadfile&lt;/code&gt; (and not via &lt;code&gt;loadfile_private&lt;/code&gt;).</source>
          <target state="translated">동적 통해로드 된 것들과 주 프로그램 함께 형성 컴파일 단위의 목록 반환 &lt;code&gt;loadfile&lt;/code&gt; (그리고를 통해 &lt;code&gt;loadfile_private&lt;/code&gt; 을 ).</target>
        </trans-unit>
        <trans-unit id="147b9884b8f49168a597ea2ac2e755dd8393f845" translate="yes" xml:space="preserve">
          <source>Return the list of compilation units that have been dynamically loaded via &lt;code&gt;loadfile&lt;/code&gt; (and not via &lt;code&gt;loadfile_private&lt;/code&gt;).</source>
          <target state="translated">동적 통해로드 된 컴파일 단위의 목록 반환 &lt;code&gt;loadfile&lt;/code&gt; (그리고를 통해 &lt;code&gt;loadfile_private&lt;/code&gt; 을 ).</target>
        </trans-unit>
        <trans-unit id="14b5e5afca199c0c51e4aadc57d91a2bb554477f" translate="yes" xml:space="preserve">
          <source>Return the list of compilation units that have been dynamically loaded via &lt;code&gt;loadfile&lt;/code&gt; (and not via &lt;code&gt;loadfile_private&lt;/code&gt;). Note that compilation units loaded dynamically cannot be unloaded.</source>
          <target state="translated">동적 통해로드 된 컴파일 단위의 목록 반환 &lt;code&gt;loadfile&lt;/code&gt; (그리고를 통해 &lt;code&gt;loadfile_private&lt;/code&gt; 을 ). 동적으로로드 된 컴파일 단위는 언로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a791391dcfd868f76e569d8bb9810a70ac2dd6fb" translate="yes" xml:space="preserve">
          <source>Return the list of groups to which the user executing the process belongs.</source>
          <target state="translated">프로세스를 실행하는 사용자가 속한 그룹 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd25d8674e41c2053e759649badd76e8f1c2b56a" translate="yes" xml:space="preserve">
          <source>Return the list of groups to which the user executing the process belongs. On Windows, always return &lt;code&gt;[|1|]&lt;/code&gt;.</source>
          <target state="translated">프로세스를 실행하는 사용자가 속한 그룹 목록을 반환합니다. Windows에서는 항상 &lt;code&gt;[|1|]&lt;/code&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="432b0e6150bdec0e0f47512d9349f84a5540dcb4" translate="yes" xml:space="preserve">
          <source>Return the login name of the user executing the process.</source>
          <target state="translated">프로세스를 실행하는 사용자의 로그인 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c523ab0b7ce7c47b28f213568fdcbceb94fe2f9d" translate="yes" xml:space="preserve">
          <source>Return the matched string.</source>
          <target state="translated">일치하는 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3209accfd9532d56fc6c3df89e2932af224337e1" translate="yes" xml:space="preserve">
          <source>Return the maximum indentation limit (in characters).</source>
          <target state="translated">최대 들여 쓰기 제한 (문자)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d36d286f55e4acb1d562548251be082a2f530a40" translate="yes" xml:space="preserve">
          <source>Return the n&lt;sup&gt;th&lt;/sup&gt; character in the matched string. The first character corresponds to n = 0.</source>
          <target state="translated">일치하는 문자열에서 n &lt;sup&gt;번째&lt;/sup&gt; 문자를 반환합니다 . 첫 번째 문자는 n = 0에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="d060a450eacfd8908f0d0e1ea8bdaf949864d47e" translate="yes" xml:space="preserve">
          <source>Return the name of the current working directory.</source>
          <target state="translated">현재 작업 디렉토리의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8a3c277db7014cd8ef6cc35588b182fc8b12e5a8" translate="yes" xml:space="preserve">
          <source>Return the name of the local host.</source>
          <target state="translated">로컬 호스트의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2a57bbe820f575de0130805b1e3013f7326c56f0" translate="yes" xml:space="preserve">
          <source>Return the name of the runtime variant the program is running on.</source>
          <target state="translated">프로그램이 실행중인 런타임 변형의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3b2452bf5ae2acb0f47220b39949c4f5c1dc7be9" translate="yes" xml:space="preserve">
          <source>Return the name of the runtime variant the program is running on. This is normally the argument given to &lt;code&gt;-runtime-variant&lt;/code&gt; at compile time, but for byte-code it can be changed after compilation.</source>
          <target state="translated">프로그램이 실행중인 런타임 변형의 이름을 반환합니다. 일반적으로 컴파일 시간 에 &lt;code&gt;-runtime-variant&lt;/code&gt; 에 제공되는 인수 이지만 바이트 코드의 경우 컴파일 후에 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f847d1780107205b367596c4ccb4550703388531" translate="yes" xml:space="preserve">
          <source>Return the names of all files present in the given directory.</source>
          <target state="translated">주어진 디렉토리에있는 모든 파일의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4f0d068f9a289d9154e8c9134aeea8bb89c3307d" translate="yes" xml:space="preserve">
          <source>Return the names of all files present in the given directory. Names denoting the current directory and the parent directory (&lt;code&gt;&quot;.&quot;&lt;/code&gt; and &lt;code&gt;&quot;..&quot;&lt;/code&gt; in Unix) are not returned. Each string in the result is a file name rather than a complete path. There is no guarantee that the name strings in the resulting array will appear in any specific order; they are not, in particular, guaranteed to appear in alphabetical order.</source>
          <target state="translated">주어진 디렉토리에있는 모든 파일의 이름을 반환합니다. 현재 디렉토리와 상위 디렉토리 ( Unix에서는 &lt;code&gt;&quot;.&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;..&quot;&lt;/code&gt; ) 를 나타내는 이름 은 반환되지 않습니다. 결과의 각 문자열은 전체 경로가 아닌 파일 이름입니다. 결과 배열의 이름 문자열이 특정 순서로 표시된다는 보장은 없습니다. 특히 알파벳 순서로 표시되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="3312ceffd4d08b82e00804a61715b59bdfe025ba" translate="yes" xml:space="preserve">
          <source>Return the next entry in a directory.</source>
          <target state="translated">디렉토리의 다음 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ed62118703f31eabe09b7dcc079392d9d8d8d55a" translate="yes" xml:space="preserve">
          <source>Return the number of bindings of a map.</source>
          <target state="translated">맵의 바인딩 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="17ac0ea6114557ed8db7487d9cd7054d24bd7426" translate="yes" xml:space="preserve">
          <source>Return the number of characters currently contained in the buffer.</source>
          <target state="translated">현재 버퍼에 포함 된 문자 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="639f930e9c3e7929b330d084069f913aab704216" translate="yes" xml:space="preserve">
          <source>Return the number of dimensions of the given Bigarray.</source>
          <target state="translated">주어진 Bigarray의 차원 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0f26ed6dbbeca49055e192d75d80831d107ea2ad" translate="yes" xml:space="preserve">
          <source>Return the number of elements in a queue.</source>
          <target state="translated">큐의 요소 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="594a0db2d4c39d5eb0f40f63644d0784043c13b2" translate="yes" xml:space="preserve">
          <source>Return the number of elements in a stack.</source>
          <target state="translated">스택의 요소 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6b8a90637291878f581313af8ced21884e6238a9" translate="yes" xml:space="preserve">
          <source>Return the number of elements in a stack. Time complexity O(1)</source>
          <target state="translated">스택의 요소 수를 반환합니다. 시간 복잡도 O (1)</target>
        </trans-unit>
        <trans-unit id="b060333d4e41f0edefda15da4347ecf299979957" translate="yes" xml:space="preserve">
          <source>Return the number of elements of a set.</source>
          <target state="translated">집합의 요소 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f6f97404a7718cfbd5bf704eec36cf800dd5480d" translate="yes" xml:space="preserve">
          <source>Return the number of times we tried to map huge pages and had to fall back to small pages.</source>
          <target state="translated">거대한 페이지를 매핑하려고 시도하고 작은 페이지로 돌아 가야하는 횟수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a4890281d997ebb5b7c0eade0ae65a3c189fb318" translate="yes" xml:space="preserve">
          <source>Return the number of times we tried to map huge pages and had to fall back to small pages. This is always 0 if &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; contains &lt;code&gt;H=1&lt;/code&gt;.</source>
          <target state="translated">거대한 페이지를 매핑하려고 시도하고 작은 페이지로 돌아 가야하는 횟수를 반환합니다. &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; 에 &lt;code&gt;H=1&lt;/code&gt; 이 포함되어 있으면 항상 0 입니다.</target>
        </trans-unit>
        <trans-unit id="8d5b2c94610054b78ee29a7cd3806b95350ccd75" translate="yes" xml:space="preserve">
          <source>Return the one-dimensional Bigarray corresponding to the given generic Bigarray.</source>
          <target state="translated">주어진 제네릭 Bigarray에 해당하는 1 차원 Bigarray를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9bb97945a3219f3314034bc592a66c7579d2c816" translate="yes" xml:space="preserve">
          <source>Return the pid of a process opened via &lt;a href=&quot;unix#VALopen_process&quot;&gt;&lt;code&gt;Unix.open_process&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;unix#VALopen_process_args&quot;&gt;&lt;code&gt;Unix.open_process_args&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process&quot;&gt; &lt;code&gt;Unix.open_process&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;unix#VALopen_process_args&quot;&gt; &lt;code&gt;Unix.open_process_args&lt;/code&gt; &lt;/a&gt; 를 통해 열린 프로세스의 pid를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2d5205e52283f91c20c83e59223daba0e11d4478" translate="yes" xml:space="preserve">
          <source>Return the pid of a process opened via &lt;a href=&quot;unix#VALopen_process_full&quot;&gt;&lt;code&gt;Unix.open_process_full&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;unix#VALopen_process_args_full&quot;&gt;&lt;code&gt;Unix.open_process_args_full&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process_full&quot;&gt; &lt;code&gt;Unix.open_process_full&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;unix#VALopen_process_args_full&quot;&gt; &lt;code&gt;Unix.open_process_args_full&lt;/code&gt; 을&lt;/a&gt; 통해 열린 프로세스의 pid를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7ac5c9764c3e03d14bf34e52a526c179d070e483" translate="yes" xml:space="preserve">
          <source>Return the pid of a process opened via &lt;a href=&quot;unix#VALopen_process_in&quot;&gt;&lt;code&gt;Unix.open_process_in&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;unix#VALopen_process_args_in&quot;&gt;&lt;code&gt;Unix.open_process_args_in&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process_in&quot;&gt; &lt;code&gt;Unix.open_process_in&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;unix#VALopen_process_args_in&quot;&gt; &lt;code&gt;Unix.open_process_args_in&lt;/code&gt; 을&lt;/a&gt; 통해 열린 프로세스의 pid를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="787ebf8ffca7b6ff030134e3fe40bcc62566b004" translate="yes" xml:space="preserve">
          <source>Return the pid of a process opened via &lt;a href=&quot;unix#VALopen_process_out&quot;&gt;&lt;code&gt;Unix.open_process_out&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;unix#VALopen_process_args_out&quot;&gt;&lt;code&gt;Unix.open_process_args_out&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process_out&quot;&gt; &lt;code&gt;Unix.open_process_out&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;unix#VALopen_process_args_out&quot;&gt; &lt;code&gt;Unix.open_process_args_out&lt;/code&gt; 을&lt;/a&gt; 통해 열린 프로세스의 pid를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="066d5df069b8686294fade3cbf497b782421071e" translate="yes" xml:space="preserve">
          <source>Return the pid of the parent process.</source>
          <target state="translated">부모 프로세스의 pid를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bede9cb911c8dfcb4a6e2ecbcb8ce5e755123f26" translate="yes" xml:space="preserve">
          <source>Return the pid of the parent process. On Windows: not implemented (because it is meaningless).</source>
          <target state="translated">부모 프로세스의 pid를 반환합니다. Windows에서 : 구현되지 않았습니다 (무의미하기 때문에).</target>
        </trans-unit>
        <trans-unit id="95add63bcee088049f2068e23dac1999a30e09b8" translate="yes" xml:space="preserve">
          <source>Return the pid of the process.</source>
          <target state="translated">프로세스의 pid를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5d8b1b7080f9a9afc56d8385fe26c87879c9a10f" translate="yes" xml:space="preserve">
          <source>Return the printable hexadecimal representation of the given digest.</source>
          <target state="translated">주어진 다이제스트의 인쇄 가능한 16 진수 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ca3b93e99f769c3e84bd27ac8a6981dd6d6dc951" translate="yes" xml:space="preserve">
          <source>Return the printable representation of the given Internet address.</source>
          <target state="translated">주어진 인터넷 주소의 인쇄 가능한 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="667620674c47d750eff43fe29b99fe07851842bc" translate="yes" xml:space="preserve">
          <source>Return the printable representation of the given Internet address. See &lt;a href=&quot;unix#VALinet_addr_of_string&quot;&gt;&lt;code&gt;Unix.inet_addr_of_string&lt;/code&gt;&lt;/a&gt; for a description of the printable representation.</source>
          <target state="translated">주어진 인터넷 주소의 인쇄 가능한 표현을 반환합니다. 인쇄 가능한 표현에 대한 설명은 &lt;a href=&quot;unix#VALinet_addr_of_string&quot;&gt; &lt;code&gt;Unix.inet_addr_of_string&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="83e8c2e9bdb415dc67f1776111054bc46b48b196" translate="yes" xml:space="preserve">
          <source>Return the process environment, as an array of strings with the format ``variable=value''.</source>
          <target state="translated">``variable = value ''형식의 문자열 배열로 프로세스 환경을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bb812b6a69643735c6f91806d12aa7f6598130de" translate="yes" xml:space="preserve">
          <source>Return the process environment, as an array of strings with the format ``variable=value''. The returned array is empty if the process has special privileges.</source>
          <target state="translated">``variable = value ''형식의 문자열 배열로 프로세스 환경을 반환합니다. 프로세스에 특수 권한이있는 경우 반환 된 배열은 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="92dc2a363c825786f643ce61f53ad0bd7a2b71eb" translate="yes" xml:space="preserve">
          <source>Return the process environment, as an array of strings with the format ``variable=value''. Unlike &lt;a href=&quot;unix#VALenvironment&quot;&gt;&lt;code&gt;Unix.environment&lt;/code&gt;&lt;/a&gt;, this function returns a populated array even if the process has special privileges. See the documentation for &lt;a href=&quot;unix#VALunsafe_getenv&quot;&gt;&lt;code&gt;Unix.unsafe_getenv&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">``variable = value ''형식의 문자열 배열로 프로세스 환경을 반환합니다. &lt;a href=&quot;unix#VALenvironment&quot;&gt; &lt;code&gt;Unix.environment&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 프로세스에 특별한 권한이 있더라도 채워진 배열을 반환합니다. 자세한 내용은 &lt;a href=&quot;unix#VALunsafe_getenv&quot;&gt; &lt;code&gt;Unix.unsafe_getenv&lt;/code&gt; 에&lt;/a&gt; 대한 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bc4ff511c6533314bfb899ed62cdf5d01d0264f9" translate="yes" xml:space="preserve">
          <source>Return the processor time, in seconds, used by the program since the beginning of execution.</source>
          <target state="translated">실행 시작 이후 프로그램에서 사용한 프로세서 시간 (초)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3fe6f782cc73d7991c0b16d399258b87ea7d7955" translate="yes" xml:space="preserve">
          <source>Return the second component of a pair.</source>
          <target state="translated">쌍의 두 번째 구성 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a33e3510a3756dde4637fb6206310d406ce2cfc7" translate="yes" xml:space="preserve">
          <source>Return the second dimension of the given three-dimensional Bigarray.</source>
          <target state="translated">주어진 3 차원 Bigarray의 두 번째 차원을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d7386d51069db87a0d398116b234ebf88cb0b9f8" translate="yes" xml:space="preserve">
          <source>Return the second dimension of the given two-dimensional Bigarray.</source>
          <target state="translated">주어진 2 차원 Bigarray의 두 번째 차원을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="01a8ffb964a264b8ead464a4a5f3e109f45cf335" translate="yes" xml:space="preserve">
          <source>Return the set of blocked signals that are currently pending.</source>
          <target state="translated">현재 보류중인 차단 된 신호 집합을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="446e78f1f8342de1d12c809b390dda818f81383e" translate="yes" xml:space="preserve">
          <source>Return the size (dimension) of the given one-dimensional Bigarray.</source>
          <target state="translated">주어진 1 차원 Bigarray의 크기 (차원)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="152f80d1b4cac00a75ef58117b5c1fc5fb5de070" translate="yes" xml:space="preserve">
          <source>Return the size (number of characters) of the regular file on which the given channel is opened.</source>
          <target state="translated">주어진 채널이 열리는 일반 파일의 크기 (문자 수)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="934f0833c834fdbff755694a296f32142833ff9f" translate="yes" xml:space="preserve">
          <source>Return the size (number of characters) of the regular file on which the given channel is opened. If the channel is opened on a file that is not a regular file, the result is meaningless.</source>
          <target state="translated">주어진 채널이 열리는 일반 파일의 크기 (문자 수)를 반환합니다. 일반 파일이 아닌 파일에서 채널을 열면 결과는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f2d3e2ad1363d51312c94d1ab2c440f4434cdb5a" translate="yes" xml:space="preserve">
          <source>Return the size (number of characters) of the regular file on which the given channel is opened. If the channel is opened on a file that is not a regular file, the result is meaningless. The returned size does not take into account the end-of-line translations that can be performed when reading from a channel opened in text mode.</source>
          <target state="translated">주어진 채널이 열리는 일반 파일의 크기 (문자 수)를 반환합니다. 일반 파일이 아닌 파일에서 채널을 열면 결과는 의미가 없습니다. 반환 된 크기는 텍스트 모드로 열린 채널에서 읽을 때 수행 할 수있는 줄 끝 번역을 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="efc1426e6a49e14a68f242752b5549ab528f4a47" translate="yes" xml:space="preserve">
          <source>Return the smaller of the two arguments.</source>
          <target state="translated">두 인수 중 더 작은 인수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="25854eb1dc4fc26311440442b6bf7d8025a9e571" translate="yes" xml:space="preserve">
          <source>Return the smaller of the two arguments. The result is unspecified if one of the arguments contains the float value &lt;code&gt;nan&lt;/code&gt;.</source>
          <target state="translated">두 인수 중 더 작은 인수를 반환합니다. 인수 중 하나에 float 값 &lt;code&gt;nan&lt;/code&gt; 이 포함되어 있으면 결과가 지정되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b03d77470c1acc851a09cd269fa127fba2de50aa" translate="yes" xml:space="preserve">
          <source>Return the smallest element of the given set (with respect to the &lt;code&gt;Ord.compare&lt;/code&gt; ordering), or &lt;code&gt;None&lt;/code&gt; if the set is empty.</source>
          <target state="translated">( &lt;code&gt;Ord.compare&lt;/code&gt; 순서 와 관련하여) 주어진 세트의 가장 작은 요소를 반환 하거나 , 세트가 비어 있으면 &lt;code&gt;None&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="017dac5bead542d5017ba0e9fa30c30a01c06cbe" translate="yes" xml:space="preserve">
          <source>Return the smallest element of the given set (with respect to the &lt;code&gt;Ord.compare&lt;/code&gt; ordering), or raise &lt;code&gt;Not_found&lt;/code&gt; if the set is empty.</source>
          <target state="translated">( &lt;code&gt;Ord.compare&lt;/code&gt; 순서 와 관련하여) 주어진 세트의 가장 작은 요소를 반환 하거나 , 세트가 비어 있으면 &lt;code&gt;Not_found&lt;/code&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="9537b164e407090d6db868adb40dbd03a0792a42" translate="yes" xml:space="preserve">
          <source>Return the socket domain adequate for the given socket address.</source>
          <target state="translated">주어진 소켓 주소에 적합한 소켓 도메인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6b7a8bb7b9eeb7b6627344301bf648aa4daaa779" translate="yes" xml:space="preserve">
          <source>Return the status of the terminal referred to by the given file descriptor.</source>
          <target state="translated">주어진 파일 기술자가 참조하는 터미널의 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5626ec7d4ca2da5a8d3bb9ed2c527c644e4678e9" translate="yes" xml:space="preserve">
          <source>Return the status of the terminal referred to by the given file descriptor. On Windows, not implemented.</source>
          <target state="translated">주어진 파일 기술자가 참조하는 터미널의 상태를 반환합니다. Windows에서는 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c9cdfde85589c923cd4ca02542d13d0cca96b93" translate="yes" xml:space="preserve">
          <source>Return the stream holding the elements of the list in the same order.</source>
          <target state="translated">목록의 요소를 동일한 순서로 포함하는 스트림을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a05fa5b07eb6ebbdf933bdfc2d40f15060722ade" translate="yes" xml:space="preserve">
          <source>Return the stream of the characters of the bytes parameter.</source>
          <target state="translated">bytes 매개 변수의 문자 스트림을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="caf78826f68b6e198d276cec474aaeeb8f27d184" translate="yes" xml:space="preserve">
          <source>Return the stream of the characters of the string parameter.</source>
          <target state="translated">문자열 매개 변수의 문자 스트림을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2468af7842aa35af943ca1d47042c1d86e8d6c47" translate="yes" xml:space="preserve">
          <source>Return the stream of the characters read from the input channel.</source>
          <target state="translated">입력 채널에서 읽은 문자의 스트림을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dd1b7572b59c2595ba97bfeecd0a7e61e9a67f8b" translate="yes" xml:space="preserve">
          <source>Return the string representation of a boolean.</source>
          <target state="translated">부울의 문자열 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="15835b97f4ff7af238cdc0ad3af680b29be0eed3" translate="yes" xml:space="preserve">
          <source>Return the string representation of a boolean. As the returned values may be shared, the user should not modify them directly.</source>
          <target state="translated">부울의 문자열 표현을 반환합니다. 반환 된 값은 공유 될 수 있으므로 사용자가 직접 수정해서는 안됩니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="aa0425121ad48174987f6ebd15d09075898ff670" translate="yes" xml:space="preserve">
          <source>Return the string representation of a floating-point number.</source>
          <target state="translated">부동 소수점 숫자의 문자열 표현을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="48fdc654647800e5ec41090dcf080e361a49adc8" translate="yes" xml:space="preserve">
          <source>Return the string representation of an integer, in decimal.</source>
          <target state="translated">정수의 문자열 표현을 10 진수로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4b9638e46d453c3b7eed3f92aba7fd9fb4a69f06" translate="yes" xml:space="preserve">
          <source>Return the string representation of its argument, in decimal.</source>
          <target state="translated">인수의 문자열 표현을 10 진수로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5993a8566afc49eebb9d190077edf1da30dc40c4" translate="yes" xml:space="preserve">
          <source>Return the string representation of its argument, in signed decimal.</source>
          <target state="translated">인수의 문자열 표현을 부호있는 10 진수로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cee061fa1ce7e36f10472aaebc71d041f385f79a" translate="yes" xml:space="preserve">
          <source>Return the text of the ellipsis.</source>
          <target state="translated">줄임표의 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f1687fb65b0b5dee545f3581d2861e0adb08cf5" translate="yes" xml:space="preserve">
          <source>Return the third dimension of the given three-dimensional Bigarray.</source>
          <target state="translated">주어진 3 차원 Bigarray의 3 차원을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fded3ea1551782765551c15274e9f9e22ce90b1c" translate="yes" xml:space="preserve">
          <source>Return the thread currently executing.</source>
          <target state="translated">현재 실행중인 스레드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7f82693ea095e57e92edc69fb4af99e6e665c6b3" translate="yes" xml:space="preserve">
          <source>Return the three-dimensional Bigarray corresponding to the given generic Bigarray.</source>
          <target state="translated">주어진 일반 Bigarray에 해당하는 3 차원 Bigarray를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eaba934f777d3a28c03ff2df1af97dba235b90b0" translate="yes" xml:space="preserve">
          <source>Return the total number of bytes allocated since the program was started.</source>
          <target state="translated">프로그램이 시작된 이후 할당 된 총 바이트 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a6b924475ae21a46972a34b8a9f1d42c3ca1337" translate="yes" xml:space="preserve">
          <source>Return the total number of bytes allocated since the program was started. It is returned as a &lt;code&gt;float&lt;/code&gt; to avoid overflow problems with &lt;code&gt;int&lt;/code&gt; on 32-bit machines.</source>
          <target state="translated">프로그램이 시작된 이후 할당 된 총 바이트 수를 반환합니다. 32 비트 시스템에서 &lt;code&gt;int&lt;/code&gt; 의 오버플로 문제를 방지하기 위해 &lt;code&gt;float&lt;/code&gt; 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="f40589a863b0d64e0c0727552da1b9334eb57468" translate="yes" xml:space="preserve">
          <source>Return the two-dimensional Bigarray corresponding to the given generic Bigarray.</source>
          <target state="translated">주어진 제네릭 Bigarray에 해당하는 2 차원 Bigarray를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="49064cf0b703a2346a564495d95c297ee09b80dc" translate="yes" xml:space="preserve">
          <source>Return the user id of the user executing the process.</source>
          <target state="translated">프로세스를 실행하는 사용자의 사용자 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="16fc68a13982d232eda790fc2a50a0dcaffa9cf0" translate="yes" xml:space="preserve">
          <source>Return the user id of the user executing the process. On Windows, always return &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">프로세스를 실행하는 사용자의 사용자 ID를 반환합니다. Windows에서는 항상 &lt;code&gt;1&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c7c49ef3e833d46240486c64f87be23c5629ea57" translate="yes" xml:space="preserve">
          <source>Return the value associated to a variable in the process environment or &lt;code&gt;None&lt;/code&gt; if the variable is unbound.</source>
          <target state="translated">프로세스 환경의 변수에 연결된 값을 반환하거나 변수가 바인딩되지 않은 경우 &lt;code&gt;None&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="85057500b567df16b19c1cf118645b5d304c6b1b" translate="yes" xml:space="preserve">
          <source>Return the value associated to a variable in the process environment, unless the process has special privileges.</source>
          <target state="translated">프로세스에 특별한 권한이없는 경우 프로세스 환경의 변수와 관련된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f395b0f40289db78c2fd037a9a9f2b7eab458192" translate="yes" xml:space="preserve">
          <source>Return the value associated to a variable in the process environment.</source>
          <target state="translated">프로세스 환경의 변수와 관련된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d7eeaed60e457f15050fb8745c16d9d0615537f1" translate="yes" xml:space="preserve">
          <source>Return the value associated to a variable in the process environment. Raise &lt;code&gt;Not_found&lt;/code&gt; if the variable is unbound. (This function is identical to &lt;code&gt;Sys.getenv&lt;/code&gt;.)</source>
          <target state="translated">프로세스 환경의 변수와 관련된 값을 반환합니다. 올리 &lt;code&gt;Not_found&lt;/code&gt; 변수가 결합되지 않은 경우. (이 함수는 &lt;code&gt;Sys.getenv&lt;/code&gt; 와 동일합니다 .)</target>
        </trans-unit>
        <trans-unit id="654f9530e978b351bceb2513786137bd29a6568c" translate="yes" xml:space="preserve">
          <source>Return the value of the runtime parameters, in the same format as the contents of the &lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;OCAMLRUNPARAM&lt;/code&gt; 환경 변수 의 내용과 동일한 형식으로 런타임 매개 변수의 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="81893980ccabfca942d3ed99ddbb558ef05ef17b" translate="yes" xml:space="preserve">
          <source>Return the zero-dimensional Bigarray corresponding to the given generic Bigarray.</source>
          <target state="translated">주어진 제네릭 Bigarray에 해당하는 0 차원 Bigarray를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="85a34743b7fda569f680af55a3f32d4e6549551c" translate="yes" xml:space="preserve">
          <source>Return whether runtime warnings are currently enabled.</source>
          <target state="translated">런타임 경고가 현재 활성화되어 있는지 여부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9582a02f141fc4b345b2936eba691cd0654efebc" translate="yes" xml:space="preserve">
          <source>Returns</source>
          <target state="translated">Returns</target>
        </trans-unit>
        <trans-unit id="07671ae050d7c23c0f7e43b9f1b20ad161743db2" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the given name refers to a directory, &lt;code&gt;false&lt;/code&gt; if it refers to another kind of file.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 주어진 이름이 디렉토리를 참조하는 경우, &lt;code&gt;false&lt;/code&gt; 이 파일의 다른 종류를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="34f876cd5c30fd695157f74860c4acccf9ffdf71" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the user is able to create symbolic links.</source>
          <target state="translated">사용자가 심볼릭 링크를 만들 수 있으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="0c642c27c99cf713605f23dbe275499f37af0259" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the user is able to create symbolic links. On Windows, this indicates that the user not only has the SeCreateSymbolicLinkPrivilege but is also running elevated, if necessary. On other platforms, this is simply indicates that the symlink system call is available.</source>
          <target state="translated">사용자가 심볼릭 링크를 만들 수 있으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . Windows에서 이는 사용자에게 SeCreateSymbolicLinkPrivilege가있을뿐만 아니라 필요한 경우 상승 된 권한으로 실행되고 있음을 나타냅니다. 다른 플랫폼에서 이것은 단순히 symlink 시스템 호출을 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c425a222194f2017b152701d584dd760b71e0ec4" translate="yes" xml:space="preserve">
          <source>Returns the material printed with &lt;code&gt;str_formatter&lt;/code&gt;, flushes the formatter and resets the corresponding buffer.</source>
          <target state="translated">&lt;code&gt;str_formatter&lt;/code&gt; 로 인쇄 된 자료를 반환하고 포맷터 를 비우고 해당 버퍼를 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="56b58b0830c1aefdead60d25be62cc605ba270db" translate="yes" xml:space="preserve">
          <source>Returns the maximum number of pretty-printing boxes allowed before ellipsis.</source>
          <target state="translated">줄임표 앞에 허용되는 예쁜 인쇄 상자의 최대 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fae6bb2e3dfb5a16b6f5f0913a95eab503656ba7" translate="yes" xml:space="preserve">
          <source>Returns the message that would have been printed by &lt;a href=&quot;arg#VALusage&quot;&gt;&lt;code&gt;Arg.usage&lt;/code&gt;&lt;/a&gt;, if provided with the same parameters.</source>
          <target state="translated">동일한 매개 변수가 제공되면 &lt;a href=&quot;arg#VALusage&quot;&gt; &lt;code&gt;Arg.usage&lt;/code&gt; &lt;/a&gt; 에 의해 인쇄되었을 메시지를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0f47eb1d3f9355ea817a9a85f7df9a2a66db5b79" translate="yes" xml:space="preserve">
          <source>Returns the position of the right margin.</source>
          <target state="translated">오른쪽 여백의 위치를 ​​반환합니다.</target>
        </trans-unit>
        <trans-unit id="c24b11724f17e6b30a567867f73a1d47f577b8b9" translate="yes" xml:space="preserve">
          <source>Returns the slots of a raw backtrace, or &lt;code&gt;None&lt;/code&gt; if none of them contain useful information.</source>
          <target state="translated">원시 역 추적의 슬롯을 반환하거나 유용한 정보를 포함하지 않는 경우 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2d63c3284627826c87cf50ba1ac7bc94e7935ec0" translate="yes" xml:space="preserve">
          <source>Reverse the precedence of implementations and interfaces when merging. All elements in implementation files are kept, and the -m option indicates which parts of the comments in interface files are merged with the comments in implementation files.</source>
          <target state="translated">병합 할 때 구현 및 인터페이스의 우선 순위를 바꿉니다. 구현 파일의 모든 요소가 유지되고 -m 옵션은 구현 파일의 주석과 병합되는 인터페이스 파일의 주석 부분을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4862f22e5984f9029900ba9255ea8df3a380fd39" translate="yes" xml:space="preserve">
          <source>Reverse-application operator: &lt;code&gt;x&amp;nbsp;|&amp;gt;&amp;nbsp;f&amp;nbsp;|&amp;gt;&amp;nbsp;g&lt;/code&gt; is exactly equivalent to &lt;code&gt;g&amp;nbsp;(f&amp;nbsp;(x))&lt;/code&gt;.</source>
          <target state="translated">역 적용 연산자 : &lt;code&gt;x&amp;nbsp;|&amp;gt;&amp;nbsp;f&amp;nbsp;|&amp;gt;&amp;nbsp;g&lt;/code&gt; 는 &lt;code&gt;g&amp;nbsp;(f&amp;nbsp;(x))&lt;/code&gt; 와 정확히 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="26319486b216ea03bb91a3ce9cccb058c2d9c39f" translate="yes" xml:space="preserve">
          <source>Reverse-application operator: &lt;code&gt;x&amp;nbsp;|&amp;gt;&amp;nbsp;f&amp;nbsp;|&amp;gt;&amp;nbsp;g&lt;/code&gt; is exactly equivalent to &lt;code&gt;g&amp;nbsp;(f&amp;nbsp;(x))&lt;/code&gt;. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">역 적용 연산자 : &lt;code&gt;x&amp;nbsp;|&amp;gt;&amp;nbsp;f&amp;nbsp;|&amp;gt;&amp;nbsp;g&lt;/code&gt; 는 &lt;code&gt;g&amp;nbsp;(f&amp;nbsp;(x))&lt;/code&gt; 와 정확히 동일합니다 . 왼쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="7419326f5a02dc9021eb6c48a2476ea7739f629e" translate="yes" xml:space="preserve">
          <source>Roughly speaking, tag-marking is commonly used to get a better rendering of texts in the rendering device, while tag-printing allows fine tuning of printing routines to print the same entity differently according to the semantic tags (i.e. print additional material or even omit parts of the output).</source>
          <target state="translated">대략적으로 말하면, 태그 마킹은 일반적으로 렌더링 장치에서 텍스트의 더 나은 렌더링을 얻기 위해 사용되는 반면, 태그 프린팅을 사용하면 인쇄 루틴을 미세 조정하여 의미 론적 태그에 따라 동일한 엔티티를 다르게 인쇄 할 수 있습니다 (예 : 추가 자료를 인쇄하거나 생략 할 수도 있음). 출력의 일부).</target>
        </trans-unit>
        <trans-unit id="c25f7e55ae525e900e70fdb2687e2204e7652e5b" translate="yes" xml:space="preserve">
          <source>Round above to an integer value.</source>
          <target state="translated">위의 정수 값으로 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="9fb35ef8469a6766094f0b5b1f62d7fce93f0c4c" translate="yes" xml:space="preserve">
          <source>Round above to an integer value. &lt;code&gt;ceil&amp;nbsp;f&lt;/code&gt; returns the least integer value greater than or equal to &lt;code&gt;f&lt;/code&gt;. The result is returned as a float.</source>
          <target state="translated">위의 정수 값으로 반올림합니다. &lt;code&gt;ceil&amp;nbsp;f&lt;/code&gt; 복귀 이상의 정수 값보다 크거나 같음 &lt;code&gt;f&lt;/code&gt; . 결과는 부동 소수점으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="95f6d1f314177a003e8063dc1372e721bbd39e9b" translate="yes" xml:space="preserve">
          <source>Round below to an integer value.</source>
          <target state="translated">아래에서 정수 값으로 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="9a0377b4336ea34b53e0e7d18d7b1fd4710116ee" translate="yes" xml:space="preserve">
          <source>Round below to an integer value. &lt;code&gt;floor&amp;nbsp;f&lt;/code&gt; returns the greatest integer value less than or equal to &lt;code&gt;f&lt;/code&gt;. The result is returned as a float.</source>
          <target state="translated">아래에서 정수 값으로 반올림합니다. &lt;code&gt;floor&amp;nbsp;f&lt;/code&gt; 큰 정수 값 이하로 복귀하거나 동일 &lt;code&gt;f&lt;/code&gt; . 결과는 부동 소수점으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ef9abff6d1f85e9545c3432b7c0c7e71077e6b73" translate="yes" xml:space="preserve">
          <source>Rule 1&lt;em&gt; A function that has parameters or local variables of type value must begin with a call to one of the CAMLparam macros and return with CAMLreturn, CAMLreturn0, or CAMLreturnT. In particular, CAMLlocal and CAMLxparam can only be called &lt;/em&gt;after &lt;em&gt;CAMLparam. &lt;/em&gt;</source>
          <target state="translated">규칙 1 &lt;em&gt;매개 변수 또는 값 유형의 로컬 변수가있는 함수는 CAMLparam 매크로 중 하나에 대한 호출로 시작하고 CAMLreturn, CAMLreturn0 또는 CAMLreturnT로 반환해야합니다. 특히 CAMLlocal 및 CAMLxparam은 &lt;/em&gt;&lt;em&gt;CAMLparam&lt;/em&gt; 후에 &lt;em&gt;만 호출 할 수 있습니다 &lt;/em&gt;&lt;em&gt;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f21947935e72c0abfbdf1506eabae74ecf389254" translate="yes" xml:space="preserve">
          <source>Rule 2&lt;em&gt; Local variables of type value must be declared with one of the CAMLlocal macros. Arrays of values are declared with CAMLlocalN. These macros must be used at the beginning of the function, not in a nested block. &lt;/em&gt;</source>
          <target state="translated">규칙 2 &lt;em&gt;값 유형의 로컬 변수는 CAMLlocal 매크로 중 하나를 사용하여 선언해야합니다. 값 배열은 CAMLlocalN으로 선언됩니다. 이러한 매크로는 중첩 된 블록이 아닌 함수 시작 부분에 사용해야합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="76cbf47c8b79ed4302114b968f1a67cd223a2fcb" translate="yes" xml:space="preserve">
          <source>Rule 3&lt;em&gt; Assignments to the fields of structured blocks must be done with the Store_field macro (for normal blocks) or Store_double_field macro (for arrays and records of floating-point numbers). Other assignments must not use Store_field nor Store_double_field. &lt;/em&gt;</source>
          <target state="translated">규칙 3 &lt;em&gt;구조화 된 블록의 필드에 대한 할당은 Store_field 매크로 (일반 블록의 경우) 또는 Store_double_field 매크로 (부동 소수점 숫자의 배열 및 레코드의 경우)를 사용하여 수행해야합니다. 다른 할당은 Store_field 또는 Store_double_field를 사용하지 않아야합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2f845dabc56cc41449c2f14e79e50b3ff0cb4238" translate="yes" xml:space="preserve">
          <source>Rule 4&lt;em&gt; Global variables containing values must be registered with the garbage collector using the caml_register_global_root function, save that global variables and locations that will only ever contain OCaml integers (and never pointers) do not have to be registered.&lt;/em&gt;</source>
          <target state="translated">규칙 4 &lt;em&gt;값을 포함하는 전역 변수는 caml_register_global_root 함수를 사용하여 가비지 수집기에 등록해야합니다. 전역 변수와 OCaml 정수만 포함하고 포인터는 포함하지 않는 위치는 등록 할 필요가 없습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="194be911fcb6f65c97a5b034bbe99f8ab89e30d8" translate="yes" xml:space="preserve">
          <source>Rule 5&lt;em&gt; After a structured block (a block with tag less than No_scan_tag) is allocated with the low-level functions, all fields of this block must be filled with well-formed values before the next allocation operation. If the block has been allocated with caml_alloc_small, filling is performed by direct assignment to the fields of the block: &lt;/em&gt;</source>
          <target state="translated">규칙 5 &lt;em&gt;구조화 된 블록 (No_scan_tag보다 작은 태그가있는 블록)에 하위 수준 기능이 할당 된 후이 블록의 모든 필드는 다음 할당 작업 전에 올바른 형식의 값으로 채워 져야합니다. 블록이 caml_alloc_small로 할당 된 경우 채우기는 블록의 필드에 직접 할당하여 수행됩니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2b47bc84b25954ee1bf67cab8c46516531760e13" translate="yes" xml:space="preserve">
          <source>Rule 6&lt;em&gt; Direct assignment to a field of a block, as in &lt;/em&gt;</source>
          <target state="translated">규칙 6 &lt;em&gt;에서와 같이 블록의 필드에 직접 할당&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e18f6921eef2446f5828775de5f17f14a495f57f" translate="yes" xml:space="preserve">
          <source>Rule of thumb for casual users of this library:</source>
          <target state="translated">이 라이브러리의 일반 사용자를위한 경험 법칙 :</target>
        </trans-unit>
        <trans-unit id="f08ad5ff7b0faaf640cdcfb91593e99a8405a091" translate="yes" xml:space="preserve">
          <source>Rules can also contain the &lt;code&gt;%prec &lt;/code&gt;symbol directive in the right-hand side part, to override the default precedence and associativity of the rule with the precedence and associativity of the given symbol.</source>
          <target state="translated">규칙 의 오른쪽 부분에 &lt;code&gt;%prec &lt;/code&gt; 기호 지시문을 포함하여 규칙 의 기본 우선 순위 및 연관성을 주어진 기호의 우선 순위 및 연관성으로 재정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee103b7d23d4ebd84acdfdab56301124f798767f" translate="yes" xml:space="preserve">
          <source>Run the debugger program from the working directory dir, instead of the current directory. (See also the cd command.)</source>
          <target state="translated">현재 디렉토리 대신 작업 디렉토리 dir에서 디버거 프로그램을 실행하십시오. (cd 명령도 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="e33d046f2f0d6b65906192102d14ad40ae93db06" translate="yes" xml:space="preserve">
          <source>Run the program and stop at the next event, skipping over function calls. With an argument, do it count times.</source>
          <target state="translated">프로그램을 실행하고 다음 이벤트에서 중지하고 함수 호출을 건너 뜁니다. 인수를 사용하여 횟수를 세십시오.</target>
        </trans-unit>
        <trans-unit id="baa6e0df32a74c39740ce1a2b36cd7a7922138e2" translate="yes" xml:space="preserve">
          <source>Run the program and stop at the next event. With an argument, do it count times. If count is 0, run until the program terminates or a breakpoint is hit.</source>
          <target state="translated">프로그램을 실행하고 다음 이벤트에서 중지하십시오. 인수를 사용하여 횟수를 세십시오. count가 0이면 프로그램이 종료되거나 중단 점에 도달 할 때까지 실행합니다.</target>
        </trans-unit>
        <trans-unit id="b0d820af83a79aac98fd79a203da3f7b31ae9108" translate="yes" xml:space="preserve">
          <source>Run the program backward and stop at the first event before the current function invocation.</source>
          <target state="translated">프로그램을 뒤로 실행하고 현재 함수 호출 이전의 첫 번째 이벤트에서 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="3574794cee2b6fb669e40f9d67c17ce96c3066dc" translate="yes" xml:space="preserve">
          <source>Run the program backward and stop at the previous event, skipping over function calls. With an argument, do it count times.</source>
          <target state="translated">프로그램을 뒤로 실행하고 이전 이벤트에서 중지하고 함수 호출을 건너 뜁니다. 인수를 사용하여 횟수를 세십시오.</target>
        </trans-unit>
        <trans-unit id="1e6a7ba4e2430e332885d3303baa5a56f52adbb0" translate="yes" xml:space="preserve">
          <source>Run the program backward and stop at the previous event. With an argument, do it count times.</source>
          <target state="translated">프로그램을 뒤로 실행하고 이전 이벤트에서 중지합니다. 인수를 사용하여 횟수를 세십시오.</target>
        </trans-unit>
        <trans-unit id="9fdbe39fb34c974e9361059c25a583544867c5da" translate="yes" xml:space="preserve">
          <source>Run the program until a breakpoint is hit, or the program terminates.</source>
          <target state="translated">중단 점에 도달하거나 프로그램이 종료 될 때까지 프로그램을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="dfa7f2c2df34a908be406227638b3c40e639a4fe" translate="yes" xml:space="preserve">
          <source>Run the program until the current function returns.</source>
          <target state="translated">현재 함수가 반환 될 때까지 프로그램을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="ccb5264557e071871ebff30ddc1c06100adcbe29" translate="yes" xml:space="preserve">
          <source>Run-time support for lazy values.</source>
          <target state="translated">지연 값에 대한 런타임 지원.</target>
        </trans-unit>
        <trans-unit id="e5cb34a03309c89d171d482ce75481aa7e18e73f" translate="yes" xml:space="preserve">
          <source>Run-time support for lazy values. All functions in this module are for system use only, not for the casual user.</source>
          <target state="translated">지연 값에 대한 런타임 지원. 이 모듈의 모든 기능은 일반 사용자가 아닌 시스템 전용입니다.</target>
        </trans-unit>
        <trans-unit id="6fa46548db63e22eae023361f073ead35c19731b" translate="yes" xml:space="preserve">
          <source>Run-time support for objects and classes.</source>
          <target state="translated">개체 및 클래스에 대한 런타임 지원.</target>
        </trans-unit>
        <trans-unit id="edc459881e396679e8f3b89e53ed6d439ad46f0e" translate="yes" xml:space="preserve">
          <source>Run-time support for objects and classes. All functions in this module are for system use only, not for the casual user.</source>
          <target state="translated">개체 및 클래스에 대한 런타임 지원. 이 모듈의 모든 기능은 일반 사용자가 아닌 시스템 전용입니다.</target>
        </trans-unit>
        <trans-unit id="53e81fa9c83d38e3ac1edd3552a0eb335aae424d" translate="yes" xml:space="preserve">
          <source>Run-time support for recursive modules.</source>
          <target state="translated">재귀 모듈에 대한 런타임 지원.</target>
        </trans-unit>
        <trans-unit id="a6822b33e0e8a0dd70c1220928d28080e57dc226" translate="yes" xml:space="preserve">
          <source>Run-time support for recursive modules. All functions in this module are for system use only, not for the casual user.</source>
          <target state="translated">재귀 모듈에 대한 런타임 지원. 이 모듈의 모든 기능은 일반 사용자가 아닌 시스템 전용입니다.</target>
        </trans-unit>
        <trans-unit id="2b8e0528452ff03ac8c5f5bd6d0cbc5d3759ad9b" translate="yes" xml:space="preserve">
          <source>Running an executable that has been compiled with ocamlcp or ocamloptp records the execution counts for the specified parts of the program and saves them in a file called ocamlprof.dump in the current directory.</source>
          <target state="translated">ocamlcp 또는 ocamloptp로 컴파일 된 실행 파일을 실행하면 프로그램의 지정된 부분에 대한 실행 횟수가 기록되고 현재 디렉터리의 ocamlprof.dump라는 파일에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="b10f6c4c510f606cd3d403871fcca1878d1a0557" translate="yes" xml:space="preserve">
          <source>Running the functions that were registered with Stdlib.at_exit.</source>
          <target state="translated">Stdlib.at_exit에 등록 된 함수 실행.</target>
        </trans-unit>
        <trans-unit id="5b12e58b1b71d75c02b19aa32a3b1b980fda40c2" translate="yes" xml:space="preserve">
          <source>Running the program provided earlier with OCAML_EVENTLOG_ENABLED=p will for example yield the following result.</source>
          <target state="translated">예를 들어 이전에 OCAML_EVENTLOG_ENABLED = p로 제공된 프로그램을 실행하면 다음과 같은 결과가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="02aa629c8b16cd17a44f3a0efec2feed43937642" translate="yes" xml:space="preserve">
          <source>S</source>
          <target state="translated">S</target>
        </trans-unit>
        <trans-unit id="efc4d12ca6df051f4b726e278e83476d7e281d35" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;arg#VALparse&quot;&gt;&lt;code&gt;Arg.parse&lt;/code&gt;&lt;/a&gt;, except that the &lt;code&gt;Expand&lt;/code&gt; arguments are allowed and the &lt;a href=&quot;arg#VALcurrent&quot;&gt;&lt;code&gt;Arg.current&lt;/code&gt;&lt;/a&gt; reference is not updated.</source>
          <target state="translated">동일 &lt;a href=&quot;arg#VALparse&quot;&gt; &lt;code&gt;Arg.parse&lt;/code&gt; &lt;/a&gt; 는 점을 제외하고 &lt;code&gt;Expand&lt;/code&gt; 인수가 허용되고 &lt;a href=&quot;arg#VALcurrent&quot;&gt; &lt;code&gt;Arg.current&lt;/code&gt; &lt;/a&gt; 참조가 업데이트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c759642e5b9ae84c517018cf93477f18794403c8" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;arg#VALparse&quot;&gt;&lt;code&gt;Arg.parse&lt;/code&gt;&lt;/a&gt;, except that the &lt;code&gt;speclist&lt;/code&gt; argument is a reference and may be updated during the parsing.</source>
          <target state="translated">&lt;code&gt;speclist&lt;/code&gt; 인수가 참조이고 구문 분석 중에 업데이트 될 수 있다는 점을 제외하면 &lt;a href=&quot;arg#VALparse&quot;&gt; &lt;code&gt;Arg.parse&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="4a5d41ff5725e6195edce3879692f86e84de9daf" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;arg#VALparse&quot;&gt;&lt;code&gt;Arg.parse&lt;/code&gt;&lt;/a&gt;, except that the &lt;code&gt;speclist&lt;/code&gt; argument is a reference and may be updated during the parsing. A typical use for this feature is to parse command lines of the form:</source>
          <target state="translated">&lt;code&gt;speclist&lt;/code&gt; 인수가 참조이고 구문 분석 중에 업데이트 될 수 있다는 점을 제외하면 &lt;a href=&quot;arg#VALparse&quot;&gt; &lt;code&gt;Arg.parse&lt;/code&gt; &lt;/a&gt; 와 동일 합니다. 이 기능의 일반적인 용도는 다음 형식의 명령 줄을 구문 분석하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0ce272610bebb178f81b99ce34d02c3bea9037e7" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;arg#VALparse_argv&quot;&gt;&lt;code&gt;Arg.parse_argv&lt;/code&gt;&lt;/a&gt;, except that the &lt;code&gt;speclist&lt;/code&gt; argument is a reference and may be updated during the parsing.</source>
          <target state="translated">&lt;code&gt;speclist&lt;/code&gt; 인수가 참조이고 구문 분석 중에 업데이트 될 수 있다는 점을 제외하면 &lt;a href=&quot;arg#VALparse_argv&quot;&gt; &lt;code&gt;Arg.parse_argv&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="bfb57f9a251755a25bd673901e8c89fce7f7e000" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;arg#VALparse_argv&quot;&gt;&lt;code&gt;Arg.parse_argv&lt;/code&gt;&lt;/a&gt;, except that the &lt;code&gt;speclist&lt;/code&gt; argument is a reference and may be updated during the parsing. See &lt;a href=&quot;arg#VALparse_dynamic&quot;&gt;&lt;code&gt;Arg.parse_dynamic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;speclist&lt;/code&gt; 인수가 참조이고 구문 분석 중에 업데이트 될 수 있다는 점을 제외하면 &lt;a href=&quot;arg#VALparse_argv&quot;&gt; &lt;code&gt;Arg.parse_argv&lt;/code&gt; &lt;/a&gt; 와 동일 합니다. &lt;a href=&quot;arg#VALparse_dynamic&quot;&gt; &lt;code&gt;Arg.parse_dynamic&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d06f407f48f537e3bf9f0aab3c0fd9ae569fd10f" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;arg#VALparse_argv_dynamic&quot;&gt;&lt;code&gt;Arg.parse_argv_dynamic&lt;/code&gt;&lt;/a&gt;, except that the &lt;code&gt;argv&lt;/code&gt; argument is a reference and may be updated during the parsing of &lt;code&gt;Expand&lt;/code&gt; arguments.</source>
          <target state="translated">동일 &lt;a href=&quot;arg#VALparse_argv_dynamic&quot;&gt; &lt;code&gt;Arg.parse_argv_dynamic&lt;/code&gt; &lt;/a&gt; 는 점을 제외하고 &lt;code&gt;argv&lt;/code&gt; 인수가 참조이며, 구문 분석 중에 업데이트 될 수 &lt;code&gt;Expand&lt;/code&gt; 인수를.</target>
        </trans-unit>
        <trans-unit id="d30daa2e8eb7a5fafb2e2f378489fb8c36d77c2f" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;arg#VALparse_argv_dynamic&quot;&gt;&lt;code&gt;Arg.parse_argv_dynamic&lt;/code&gt;&lt;/a&gt;, except that the &lt;code&gt;argv&lt;/code&gt; argument is a reference and may be updated during the parsing of &lt;code&gt;Expand&lt;/code&gt; arguments. See &lt;a href=&quot;arg#VALparse_argv_dynamic&quot;&gt;&lt;code&gt;Arg.parse_argv_dynamic&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">동일 &lt;a href=&quot;arg#VALparse_argv_dynamic&quot;&gt; &lt;code&gt;Arg.parse_argv_dynamic&lt;/code&gt; &lt;/a&gt; 는 점을 제외하고 &lt;code&gt;argv&lt;/code&gt; 인수가 참조이며, 구문 분석 중에 업데이트 될 수 &lt;code&gt;Expand&lt;/code&gt; 인수를. &lt;a href=&quot;arg#VALparse_argv_dynamic&quot;&gt; &lt;code&gt;Arg.parse_argv_dynamic&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="919867a5682adf2b806f5aafe9260ca926982189" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;array#VALappend&quot;&gt;&lt;code&gt;Array.append&lt;/code&gt;&lt;/a&gt;, but concatenates a list of arrays.</source>
          <target state="translated">&lt;a href=&quot;array#VALappend&quot;&gt; &lt;code&gt;Array.append&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 배열 목록을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="1d2f1fe85367029b3e28f1054ca7d3c59e03c6d7" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;array#VALexists&quot;&gt;&lt;code&gt;Array.exists&lt;/code&gt;&lt;/a&gt;, but for a two-argument predicate.</source>
          <target state="translated">&lt;a href=&quot;array#VALexists&quot;&gt; &lt;code&gt;Array.exists&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 인수가 두 개인 술어 용입니다.</target>
        </trans-unit>
        <trans-unit id="b242815a316810b7ec12598a3e1e5ec439a88f1c" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;array#VALfor_all&quot;&gt;&lt;code&gt;Array.for_all&lt;/code&gt;&lt;/a&gt;, but for a two-argument predicate.</source>
          <target state="translated">&lt;a href=&quot;array#VALfor_all&quot;&gt; &lt;code&gt;Array.for_all&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 2 인수 술어 용입니다.</target>
        </trans-unit>
        <trans-unit id="0dcf223688ef7e3edd57527f52f13eb8a194f9d1" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;array#VALiter&quot;&gt;&lt;code&gt;Array.iter&lt;/code&gt;&lt;/a&gt;, but the function is applied with the index of the element as first argument, and the element itself as second argument.</source>
          <target state="translated">&lt;a href=&quot;array#VALiter&quot;&gt; &lt;code&gt;Array.iter&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 요소의 인덱스를 첫 번째 인수로 사용하고 요소 자체를 두 번째 인수로 사용하여 함수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="7f0d694b677271f60d7455685d0d21ae0dcfd8c2" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;array#VALmap&quot;&gt;&lt;code&gt;Array.map&lt;/code&gt;&lt;/a&gt;, but the function is applied to the index of the element as first argument, and the element itself as second argument.</source>
          <target state="translated">&lt;a href=&quot;array#VALmap&quot;&gt; &lt;code&gt;Array.map&lt;/code&gt; &lt;/a&gt; 과 동일 하지만이 함수는 요소의 인덱스에 첫 번째 인수로 적용되고 요소 자체는 두 번째 인수로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="27264073342409963f6b45f54dae3a7263c03cf1" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;array#VALmem&quot;&gt;&lt;code&gt;Array.mem&lt;/code&gt;&lt;/a&gt;, but uses physical equality instead of structural equality to compare elements.</source>
          <target state="translated">&lt;a href=&quot;array#VALmem&quot;&gt; &lt;code&gt;Array.mem&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 구조적 동등성 대신 물리적 동등성을 사용하여 요소를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="fc576d9ed15b363a6f59f930c00c545f126a56e7" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;array#VALsort&quot;&gt;&lt;code&gt;Array.sort&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;array#VALstable_sort&quot;&gt;&lt;code&gt;Array.stable_sort&lt;/code&gt;&lt;/a&gt;, whichever is faster on typical input.</source>
          <target state="translated">&lt;a href=&quot;array#VALsort&quot;&gt; &lt;code&gt;Array.sort&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;array#VALstable_sort&quot;&gt; &lt;code&gt;Array.stable_sort&lt;/code&gt; &lt;/a&gt; 중 일반적인 입력에서 더 빠른 것과 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="6244692cedb700735cc510ac2331f20dd448794a" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;array#VALsort&quot;&gt;&lt;code&gt;Array.sort&lt;/code&gt;&lt;/a&gt;, but the sorting algorithm is stable (i.e.</source>
          <target state="translated">&lt;a href=&quot;array#VALsort&quot;&gt; &lt;code&gt;Array.sort&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 정렬 알고리즘은 안정적입니다 (예 :</target>
        </trans-unit>
        <trans-unit id="97405025fa431a41a3706696600e09871c75f655" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;array#VALsort&quot;&gt;&lt;code&gt;Array.sort&lt;/code&gt;&lt;/a&gt;, but the sorting algorithm is stable (i.e. elements that compare equal are kept in their original order) and not guaranteed to run in constant heap space.</source>
          <target state="translated">&lt;a href=&quot;array#VALsort&quot;&gt; &lt;code&gt;Array.sort&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 정렬 알고리즘은 안정적이며 (즉, 동일하게 비교되는 요소가 원래 순서대로 유지됨) 일정한 힙 공간에서 실행되지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b86be45b6d8f2d1d0b25368390b70d922ded97a7" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;arraylabels#VALappend&quot;&gt;&lt;code&gt;ArrayLabels.append&lt;/code&gt;&lt;/a&gt;, but concatenates a list of arrays.</source>
          <target state="translated">&lt;a href=&quot;arraylabels#VALappend&quot;&gt; &lt;code&gt;ArrayLabels.append&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 배열 목록을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="9fb78a6f8069873a797a227f4767a378fba78ed5" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;arraylabels#VALexists&quot;&gt;&lt;code&gt;ArrayLabels.exists&lt;/code&gt;&lt;/a&gt;, but for a two-argument predicate.</source>
          <target state="translated">&lt;a href=&quot;arraylabels#VALexists&quot;&gt; &lt;code&gt;ArrayLabels.exists&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 인수가 두 개인 술어 용입니다.</target>
        </trans-unit>
        <trans-unit id="3b6f80792c25a21550e4d43edda9eaa91e95d6ad" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;arraylabels#VALfor_all&quot;&gt;&lt;code&gt;ArrayLabels.for_all&lt;/code&gt;&lt;/a&gt;, but for a two-argument predicate.</source>
          <target state="translated">&lt;a href=&quot;arraylabels#VALfor_all&quot;&gt; &lt;code&gt;ArrayLabels.for_all&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 2 인수 술어 용입니다.</target>
        </trans-unit>
        <trans-unit id="2e5323fc47789f794fe72351563f0e1fa65f473f" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;arraylabels#VALiter&quot;&gt;&lt;code&gt;ArrayLabels.iter&lt;/code&gt;&lt;/a&gt;, but the function is applied to the index of the element as first argument, and the element itself as second argument.</source>
          <target state="translated">&lt;a href=&quot;arraylabels#VALiter&quot;&gt; &lt;code&gt;ArrayLabels.iter&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 함수는 요소의 인덱스에 첫 번째 인수로 적용되고 요소 자체는 두 번째 인수로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5393f82003c7eb52395c936d7585a0e877ed2b95" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;arraylabels#VALmap&quot;&gt;&lt;code&gt;ArrayLabels.map&lt;/code&gt;&lt;/a&gt;, but the function is applied to the index of the element as first argument, and the element itself as second argument.</source>
          <target state="translated">&lt;a href=&quot;arraylabels#VALmap&quot;&gt; &lt;code&gt;ArrayLabels.map&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 함수는 요소의 인덱스에 첫 번째 인수로 적용되고 요소 자체는 두 번째 인수로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ebb3b59a0eaa483463885c9027782941f2d161cb" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;arraylabels#VALmem&quot;&gt;&lt;code&gt;ArrayLabels.mem&lt;/code&gt;&lt;/a&gt;, but uses physical equality instead of structural equality to compare list elements.</source>
          <target state="translated">&lt;a href=&quot;arraylabels#VALmem&quot;&gt; &lt;code&gt;ArrayLabels.mem&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 구조적 동등성 대신 물리적 동등성을 사용하여 목록 요소를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="8be4945b92031a35d5f612f1af651ac5977e8264" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;arraylabels#VALsort&quot;&gt;&lt;code&gt;ArrayLabels.sort&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;arraylabels#VALstable_sort&quot;&gt;&lt;code&gt;ArrayLabels.stable_sort&lt;/code&gt;&lt;/a&gt;, whichever is faster on typical input.</source>
          <target state="translated">&lt;a href=&quot;arraylabels#VALsort&quot;&gt; &lt;code&gt;ArrayLabels.sort&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;arraylabels#VALstable_sort&quot;&gt; &lt;code&gt;ArrayLabels.stable_sort&lt;/code&gt; &lt;/a&gt; 중 일반적인 입력에서 더 빠른 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="dbfe25a44867f93bc1075f276a30db7fc5848089" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;arraylabels#VALsort&quot;&gt;&lt;code&gt;ArrayLabels.sort&lt;/code&gt;&lt;/a&gt;, but the sorting algorithm is stable (i.e.</source>
          <target state="translated">&lt;a href=&quot;arraylabels#VALsort&quot;&gt; &lt;code&gt;ArrayLabels.sort&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 정렬 알고리즘은 안정적입니다 (예 :</target>
        </trans-unit>
        <trans-unit id="d0cd5d947233a03e68947c4e597c0ed72f23130f" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;arraylabels#VALsort&quot;&gt;&lt;code&gt;ArrayLabels.sort&lt;/code&gt;&lt;/a&gt;, but the sorting algorithm is stable (i.e. elements that compare equal are kept in their original order) and not guaranteed to run in constant heap space.</source>
          <target state="translated">&lt;a href=&quot;arraylabels#VALsort&quot;&gt; &lt;code&gt;ArrayLabels.sort&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 정렬 알고리즘은 안정적이며 (즉, 동일하게 비교되는 요소는 원래 순서대로 유지됨) 일정한 힙 공간에서 실행되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45265fb607f4846e899fbf60e6e85fa49d1982dc" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;bytes#VALblit_string&quot;&gt;&lt;code&gt;Bytes.blit_string&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bytes#VALblit_string&quot;&gt; &lt;code&gt;Bytes.blit_string&lt;/code&gt; &lt;/a&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d98a5b698c78e1cbbe8ea64b1623654ceb4caee8" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;bytes#VALiter&quot;&gt;&lt;code&gt;Bytes.iter&lt;/code&gt;&lt;/a&gt;, but the function is applied to the index of the byte as first argument and the byte itself as second argument.</source>
          <target state="translated">&lt;a href=&quot;bytes#VALiter&quot;&gt; &lt;code&gt;Bytes.iter&lt;/code&gt; &lt;/a&gt; 와 동일 하지만이 함수는 바이트의 인덱스에 첫 번째 인수로 적용되고 바이트 자체는 두 번째 인수로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b76ea0dfff831d30c32dc2ea7243f0184a031e06" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;ephemeron.k1#VALblit_data&quot;&gt;&lt;code&gt;Ephemeron.K1.blit_data&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ephemeron.k1#VALblit_data&quot;&gt; &lt;code&gt;Ephemeron.K1.blit_data&lt;/code&gt; &lt;/a&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="12d4c6a33a99707fe445670f42fa9cb9e5b60c0e" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;ephemeron.k1#VALblit_key&quot;&gt;&lt;code&gt;Ephemeron.K1.blit_key&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ephemeron.k1#VALblit_key&quot;&gt; &lt;code&gt;Ephemeron.K1.blit_key&lt;/code&gt; &lt;/a&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="db3cb019318b41aa1ccd210ba658180378e9a151" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;ephemeron.k1#VALcheck_data&quot;&gt;&lt;code&gt;Ephemeron.K1.check_data&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ephemeron.k1#VALcheck_data&quot;&gt; &lt;code&gt;Ephemeron.K1.check_data&lt;/code&gt; &lt;/a&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="adbd2ee1680f6517ff228f585758f02f4374dd14" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;ephemeron.k1#VALcheck_key&quot;&gt;&lt;code&gt;Ephemeron.K1.check_key&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ephemeron.k1#VALcheck_key&quot;&gt; &lt;code&gt;Ephemeron.K1.check_key&lt;/code&gt; &lt;/a&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="d2042d70e36b40ca89faeb0b202f4b5ab4fff165" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;ephemeron.k1#VALcreate&quot;&gt;&lt;code&gt;Ephemeron.K1.create&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ephemeron.k1#VALcreate&quot;&gt; &lt;code&gt;Ephemeron.K1.create&lt;/code&gt; &lt;/a&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="e209f2bfc77ca97fd02c7ce069d28edc6165de7e" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;ephemeron.k1#VALget_data&quot;&gt;&lt;code&gt;Ephemeron.K1.get_data&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ephemeron.k1#VALget_data&quot;&gt; &lt;code&gt;Ephemeron.K1.get_data&lt;/code&gt; &lt;/a&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="568c761efffb54b66e93649175fc779f688d1b3d" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;ephemeron.k1#VALget_data_copy&quot;&gt;&lt;code&gt;Ephemeron.K1.get_data_copy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ephemeron.k1#VALget_data_copy&quot;&gt; &lt;code&gt;Ephemeron.K1.get_data_copy&lt;/code&gt; &lt;/a&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="0c2ab2cc6cc01aa7278b7d4280b1f56854a8b988" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;ephemeron.k1#VALget_key&quot;&gt;&lt;code&gt;Ephemeron.K1.get_key&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ephemeron.k1#VALget_key&quot;&gt; &lt;code&gt;Ephemeron.K1.get_key&lt;/code&gt; &lt;/a&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="2b72029dfa1493b874920908ebbd9e791e5c4d0c" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;ephemeron.k1#VALget_key_copy&quot;&gt;&lt;code&gt;Ephemeron.K1.get_key_copy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ephemeron.k1#VALget_key_copy&quot;&gt; &lt;code&gt;Ephemeron.K1.get_key_copy&lt;/code&gt; &lt;/a&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="7f84cc672a834fb988ea1c9c659545484fa7398e" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;ephemeron.k1#VALset_data&quot;&gt;&lt;code&gt;Ephemeron.K1.set_data&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ephemeron.k1#VALset_data&quot;&gt; &lt;code&gt;Ephemeron.K1.set_data&lt;/code&gt; &lt;/a&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="d9b9609b57f58f8d58ea6c8c2a0440f09557a2f6" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;ephemeron.k1#VALset_key&quot;&gt;&lt;code&gt;Ephemeron.K1.set_key&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ephemeron.k1#VALset_key&quot;&gt; &lt;code&gt;Ephemeron.K1.set_key&lt;/code&gt; &lt;/a&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="c96eb276bc3d191c4e9ab0cea3c2305d4a1ea719" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;ephemeron.k1#VALunset_data&quot;&gt;&lt;code&gt;Ephemeron.K1.unset_data&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ephemeron.k1#VALunset_data&quot;&gt; &lt;code&gt;Ephemeron.K1.unset_data&lt;/code&gt; &lt;/a&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="ceeb86f3b4637cf4b5ba1a3b6ffc60b8913fc62e" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;ephemeron.k1#VALunset_key&quot;&gt;&lt;code&gt;Ephemeron.K1.unset_key&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;ephemeron.k1#VALunset_key&quot;&gt; &lt;code&gt;Ephemeron.K1.unset_key&lt;/code&gt; &lt;/a&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="b786bfda5e45a89cfc3b00c5b661d97ebd87018b" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;filename#VALremove_extension&quot;&gt;&lt;code&gt;Filename.remove_extension&lt;/code&gt;&lt;/a&gt;, but raise &lt;code&gt;Invalid_argument&lt;/code&gt; if the given name has an empty extension.</source>
          <target state="translated">&lt;a href=&quot;filename#VALremove_extension&quot;&gt; &lt;code&gt;Filename.remove_extension&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 주어진 이름에 빈 확장자가 있으면 &lt;code&gt;Invalid_argument&lt;/code&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="20ed289cc37a407068da0e36ad9ed957eca24a83" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;filename#VALtemp_file&quot;&gt;&lt;code&gt;Filename.temp_file&lt;/code&gt;&lt;/a&gt;, but returns both the name of a fresh temporary file, and an output channel opened (atomically) on this file.</source>
          <target state="translated">&lt;a href=&quot;filename#VALtemp_file&quot;&gt; &lt;code&gt;Filename.temp_file&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 새 임시 파일의 이름과이 파일에서 (원자 적으로) 열린 출력 채널을 모두 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2e82ce81e07c7c9bac6ea7fcdb7f2faea5c40461" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;filename#VALtemp_file&quot;&gt;&lt;code&gt;Filename.temp_file&lt;/code&gt;&lt;/a&gt;, but returns both the name of a fresh temporary file, and an output channel opened (atomically) on this file. This function is more secure than &lt;code&gt;temp_file&lt;/code&gt;: there is no risk that the temporary file will be modified (e.g. replaced by a symbolic link) before the program opens it. The optional argument &lt;code&gt;mode&lt;/code&gt; is a list of additional flags to control the opening of the file. It can contain one or several of &lt;code&gt;Open_append&lt;/code&gt;, &lt;code&gt;Open_binary&lt;/code&gt;, and &lt;code&gt;Open_text&lt;/code&gt;. The default is &lt;code&gt;[Open_text]&lt;/code&gt; (open in text mode). The file is created with permissions &lt;code&gt;perms&lt;/code&gt; (defaults to readable and writable only by the file owner, &lt;code&gt;0o600&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;filename#VALtemp_file&quot;&gt; &lt;code&gt;Filename.temp_file&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 새 임시 파일의 이름과이 파일에서 (원자 적으로) 열린 출력 채널을 모두 반환합니다. 이 함수는 &lt;code&gt;temp_file&lt;/code&gt; 보다 안전 합니다. 프로그램이 열기 전에 임시 파일이 수정 (예 : 심볼릭 링크로 대체) 될 위험이 없습니다. 선택적 인수 &lt;code&gt;mode&lt;/code&gt; 는 파일 열기를 제어하는 ​​추가 플래그 목록입니다. &lt;code&gt;Open_append&lt;/code&gt; , &lt;code&gt;Open_binary&lt;/code&gt; 및 &lt;code&gt;Open_text&lt;/code&gt; 중 하나 또는 여러 개를 포함 할 수 있습니다 . 기본값은 &lt;code&gt;[Open_text]&lt;/code&gt; (텍스트 모드에서 열기)입니다. 파일은 권한 &lt;code&gt;perms&lt;/code&gt; 로 생성됩니다 (기본값은 파일 소유자 만 읽기 및 쓰기 가능, &lt;code&gt;0o600&lt;/code&gt; ).).</target>
        </trans-unit>
        <trans-unit id="0b303c6d712e6976b4e45797412d70eb55774196" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;float.array#VALappend&quot;&gt;&lt;code&gt;Float.Array.append&lt;/code&gt;&lt;/a&gt;, but concatenates a list of floatarrays.</source>
          <target state="translated">&lt;a href=&quot;float.array#VALappend&quot;&gt; &lt;code&gt;Float.Array.append&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 floatarray 목록을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="41416d7a8b7b0adf79c3afce58707991794941ab" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;float.array#VALiter&quot;&gt;&lt;code&gt;Float.Array.iter&lt;/code&gt;&lt;/a&gt;, but the function is applied with the index of the element as first argument, and the element itself as second argument.</source>
          <target state="translated">&lt;a href=&quot;float.array#VALiter&quot;&gt; &lt;code&gt;Float.Array.iter&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 요소의 인덱스를 첫 번째 인수로 사용하고 요소 자체를 두 번째 인수로 사용하여 함수가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c22ed5bf79a3a77efc5132d1cbf4fd101f23251e" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;float.array#VALmap&quot;&gt;&lt;code&gt;Float.Array.map&lt;/code&gt;&lt;/a&gt;, but the function is applied to the index of the element as first argument, and the element itself as second argument.</source>
          <target state="translated">&lt;a href=&quot;float.array#VALmap&quot;&gt; &lt;code&gt;Float.Array.map&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 함수는 요소의 인덱스에 첫 번째 인수로 적용되고 요소 자체는 두 번째 인수로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="91c1f693de3156b9c1f1b88f26bf9a4022236c7c" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;float.array#VALmem&quot;&gt;&lt;code&gt;Float.Array.mem&lt;/code&gt;&lt;/a&gt;, but uses IEEE equality instead of structural equality.</source>
          <target state="translated">&lt;a href=&quot;float.array#VALmem&quot;&gt; &lt;code&gt;Float.Array.mem&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 구조적 동등성 대신 IEEE 동등성을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="014312ce8b144c294f55b09e82f32dec292be133" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;float.array#VALsort&quot;&gt;&lt;code&gt;Float.Array.sort&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;float.array#VALstable_sort&quot;&gt;&lt;code&gt;Float.Array.stable_sort&lt;/code&gt;&lt;/a&gt;, whichever is faster on typical input.</source>
          <target state="translated">&lt;a href=&quot;float.array#VALsort&quot;&gt; &lt;code&gt;Float.Array.sort&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;float.array#VALstable_sort&quot;&gt; &lt;code&gt;Float.Array.stable_sort&lt;/code&gt; &lt;/a&gt; 중 일반적인 입력에서 더 빠른 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="a11082ec4b9195ccb2340ff67467acf4a9e5f254" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;float.array#VALsort&quot;&gt;&lt;code&gt;Float.Array.sort&lt;/code&gt;&lt;/a&gt;, but the sorting algorithm is stable (i.e.</source>
          <target state="translated">&lt;a href=&quot;float.array#VALsort&quot;&gt; &lt;code&gt;Float.Array.sort&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 정렬 알고리즘은 안정적입니다 (예 :</target>
        </trans-unit>
        <trans-unit id="731672c2481f05624bc863ac9f33958c6862957f" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;float.array#VALsort&quot;&gt;&lt;code&gt;Float.Array.sort&lt;/code&gt;&lt;/a&gt;, but the sorting algorithm is stable (i.e. elements that compare equal are kept in their original order) and not guaranteed to run in constant heap space.</source>
          <target state="translated">&lt;a href=&quot;float.array#VALsort&quot;&gt; &lt;code&gt;Float.Array.sort&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 정렬 알고리즘은 안정적이며 (즉, 동일하게 비교되는 요소가 원래 순서대로 유지됨) 일정한 힙 공간에서 실행된다는 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3076ad9c1b68cc0dc33d09e4995af18afdaec8ff" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;format#VALdprintf&quot;&gt;&lt;code&gt;Format.dprintf&lt;/code&gt;&lt;/a&gt; above, but instead of returning immediately, passes the suspended printer to its first argument at the end of printing.</source>
          <target state="translated">위의 &lt;a href=&quot;format#VALdprintf&quot;&gt; &lt;code&gt;Format.dprintf&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 즉시 반환하지 않고 인쇄가 끝날 때 일시 중단 된 프린터를 첫 번째 인수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="94faa50d6e3570c70190979e67a4200ea73ab2f8" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;format#VALfprintf&quot;&gt;&lt;code&gt;Format.fprintf&lt;/code&gt;&lt;/a&gt;, except the formatter is the last argument.</source>
          <target state="translated">동일 &lt;a href=&quot;format#VALfprintf&quot;&gt; &lt;code&gt;Format.fprintf&lt;/code&gt; &lt;/a&gt; , 포맷터를 제외하고 마지막 인수입니다.</target>
        </trans-unit>
        <trans-unit id="36d45c0db0bff5a17e8e45a96a8c25c3c5132671" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;format#VALfprintf&quot;&gt;&lt;code&gt;Format.fprintf&lt;/code&gt;&lt;/a&gt;, except the formatter is the last argument. &lt;code&gt;dprintf&amp;nbsp;&quot;...&quot;&amp;nbsp;a&amp;nbsp;b&amp;nbsp;c&lt;/code&gt; is a function of type &lt;code&gt;formatter&amp;nbsp;-&amp;gt;&amp;nbsp;unit&lt;/code&gt; which can be given to a format specifier &lt;code&gt;%t&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;a href=&quot;format#VALfprintf&quot;&gt; &lt;code&gt;Format.fprintf&lt;/code&gt; &lt;/a&gt; , 포맷터를 제외하고 마지막 인수입니다. &lt;code&gt;dprintf&amp;nbsp;&quot;...&quot;&amp;nbsp;a&amp;nbsp;b&amp;nbsp;c&lt;/code&gt; 는 형식 지정자 &lt;code&gt;%t&lt;/code&gt; 지정할 수있는 형식 &lt;code&gt;formatter&amp;nbsp;-&amp;gt;&amp;nbsp;unit&lt;/code&gt; 의 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="5f274669a2e20f92f9badea13b7f97452af6fa67" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;int32#VALcompare&quot;&gt;&lt;code&gt;Int32.compare&lt;/code&gt;&lt;/a&gt;, except that arguments are interpreted as &lt;em&gt;unsigned&lt;/em&gt; 32-bit integers.</source>
          <target state="translated">동일 &lt;a href=&quot;int32#VALcompare&quot;&gt; &lt;code&gt;Int32.compare&lt;/code&gt; &lt;/a&gt; , 인수로 해석됩니다 것을 제외하고 &lt;em&gt;부호없는&lt;/em&gt; 32 비트 정수.</target>
        </trans-unit>
        <trans-unit id="fff9bfcc5a9e17755dfb27df27fbc91a079014e6" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;int32#VALdiv&quot;&gt;&lt;code&gt;Int32.div&lt;/code&gt;&lt;/a&gt;, except that arguments and result are interpreted as &lt;em&gt; unsigned&lt;/em&gt; 32-bit integers.</source>
          <target state="translated">동일 &lt;a href=&quot;int32#VALdiv&quot;&gt; &lt;code&gt;Int32.div&lt;/code&gt; &lt;/a&gt; 그 인수 및 결과를 제외하고는,로 해석됩니다 &lt;em&gt;부호없는&lt;/em&gt; 32 비트 정수.</target>
        </trans-unit>
        <trans-unit id="d84d92bbd30a74d2b88c12316cd188e476d6d8bc" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;int32#VALrem&quot;&gt;&lt;code&gt;Int32.rem&lt;/code&gt;&lt;/a&gt;, except that arguments and result are interpreted as &lt;em&gt; unsigned&lt;/em&gt; 32-bit integers.</source>
          <target state="translated">동일 &lt;a href=&quot;int32#VALrem&quot;&gt; &lt;code&gt;Int32.rem&lt;/code&gt; &lt;/a&gt; 그 인수 및 결과를 제외하고는,로 해석됩니다 &lt;em&gt;부호없는&lt;/em&gt; 32 비트 정수.</target>
        </trans-unit>
        <trans-unit id="0ea26c69ce64b1fa8ceb8dd688190e7834b14e26" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;int32#VALto_int&quot;&gt;&lt;code&gt;Int32.to_int&lt;/code&gt;&lt;/a&gt;, but interprets the argument as an &lt;em&gt;unsigned&lt;/em&gt; integer.</source>
          <target state="translated">&lt;a href=&quot;int32#VALto_int&quot;&gt; &lt;code&gt;Int32.to_int&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 인수를 &lt;em&gt;부호없는&lt;/em&gt; 정수 로 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="9995f0b680b006745f18fbeb910b9c619f12ee1d" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;int32#VALto_int&quot;&gt;&lt;code&gt;Int32.to_int&lt;/code&gt;&lt;/a&gt;, but interprets the argument as an &lt;em&gt;unsigned&lt;/em&gt; integer. Returns &lt;code&gt;None&lt;/code&gt; if the unsigned value of the argument cannot fit into an &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;int32#VALto_int&quot;&gt; &lt;code&gt;Int32.to_int&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 인수를 &lt;em&gt;부호없는&lt;/em&gt; 정수 로 해석합니다 . 인수의 부호없는 값이 &lt;code&gt;int&lt;/code&gt; 에 맞지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="fcdb7e538aa6eb0d824f0648197ea429fdf7b20b" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;int64#VALcompare&quot;&gt;&lt;code&gt;Int64.compare&lt;/code&gt;&lt;/a&gt;, except that arguments are interpreted as &lt;em&gt;unsigned&lt;/em&gt; 64-bit integers.</source>
          <target state="translated">동일 &lt;a href=&quot;int64#VALcompare&quot;&gt; &lt;code&gt;Int64.compare&lt;/code&gt; &lt;/a&gt; , 인수로 해석됩니다 것을 제외하고 &lt;em&gt;부호없는&lt;/em&gt; 64 비트 정수.</target>
        </trans-unit>
        <trans-unit id="a769851b36b207e29beabede1916d10e5c4663ee" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;int64#VALdiv&quot;&gt;&lt;code&gt;Int64.div&lt;/code&gt;&lt;/a&gt;, except that arguments and result are interpreted as &lt;em&gt; unsigned&lt;/em&gt; 64-bit integers.</source>
          <target state="translated">동일 &lt;a href=&quot;int64#VALdiv&quot;&gt; &lt;code&gt;Int64.div&lt;/code&gt; &lt;/a&gt; 그 인수 및 결과를 제외하고는,로 해석됩니다 &lt;em&gt;부호없는&lt;/em&gt; 64 비트 정수.</target>
        </trans-unit>
        <trans-unit id="9bf11ed7dcb0af4f5f3813d836d90f0a4c77a9d9" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;int64#VALrem&quot;&gt;&lt;code&gt;Int64.rem&lt;/code&gt;&lt;/a&gt;, except that arguments and result are interpreted as &lt;em&gt; unsigned&lt;/em&gt; 64-bit integers.</source>
          <target state="translated">동일 &lt;a href=&quot;int64#VALrem&quot;&gt; &lt;code&gt;Int64.rem&lt;/code&gt; &lt;/a&gt; 그 인수 및 결과를 제외하고는,로 해석됩니다 &lt;em&gt;부호없는&lt;/em&gt; 64 비트 정수.</target>
        </trans-unit>
        <trans-unit id="e4cde4a302ee1c248d1a0b7fed8e51d321db14da" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;int64#VALto_int&quot;&gt;&lt;code&gt;Int64.to_int&lt;/code&gt;&lt;/a&gt;, but interprets the argument as an &lt;em&gt;unsigned&lt;/em&gt; integer.</source>
          <target state="translated">&lt;a href=&quot;int64#VALto_int&quot;&gt; &lt;code&gt;Int64.to_int&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 인수를 &lt;em&gt;부호없는&lt;/em&gt; 정수 로 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="7c3d3062b85da8155cb99e06e6571f9a806ca7f9" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;int64#VALto_int&quot;&gt;&lt;code&gt;Int64.to_int&lt;/code&gt;&lt;/a&gt;, but interprets the argument as an &lt;em&gt;unsigned&lt;/em&gt; integer. Returns &lt;code&gt;None&lt;/code&gt; if the unsigned value of the argument cannot fit into an &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;int64#VALto_int&quot;&gt; &lt;code&gt;Int64.to_int&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 인수를 &lt;em&gt;부호없는&lt;/em&gt; 정수 로 해석합니다 . 인수의 부호없는 값이 &lt;code&gt;int&lt;/code&gt; 에 맞지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ca7fd8d6590c8efe475a70a0aedf69e8db28e06a" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;list#VALassoc&quot;&gt;&lt;code&gt;List.assoc&lt;/code&gt;&lt;/a&gt;, but simply return true if a binding exists, and false if no bindings exist for the given key.</source>
          <target state="translated">&lt;a href=&quot;list#VALassoc&quot;&gt; &lt;code&gt;List.assoc&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 바인딩이 있으면 true를 반환하고 지정된 키에 대한 바인딩이 없으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="abb04a099455e95ba278f304b686fa96ad60f397" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;list#VALassoc&quot;&gt;&lt;code&gt;List.assoc&lt;/code&gt;&lt;/a&gt;, but uses physical equality instead of structural equality to compare keys.</source>
          <target state="translated">&lt;a href=&quot;list#VALassoc&quot;&gt; &lt;code&gt;List.assoc&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 구조적 동등성 대신 물리적 동등성을 사용하여 키를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="5274f117aa288d7ee172f3d75b9197ab989714b8" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;list#VALassoc_opt&quot;&gt;&lt;code&gt;List.assoc_opt&lt;/code&gt;&lt;/a&gt;, but uses physical equality instead of structural equality to compare keys.</source>
          <target state="translated">&lt;a href=&quot;list#VALassoc_opt&quot;&gt; &lt;code&gt;List.assoc_opt&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 구조적 동등성 대신 물리적 동등성을 사용하여 키를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="fff8e1dee5a0d14caeb4eba5ade8bf2472f7f586" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;list#VALexists&quot;&gt;&lt;code&gt;List.exists&lt;/code&gt;&lt;/a&gt;, but for a two-argument predicate.</source>
          <target state="translated">&lt;a href=&quot;list#VALexists&quot;&gt; &lt;code&gt;List.exists&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 두 인수 조건 자에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="92dfeb9bef3c640ac9c0a770511436bfd14bde4f" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;list#VALfilter&quot;&gt;&lt;code&gt;List.filter&lt;/code&gt;&lt;/a&gt;, but the predicate is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</source>
          <target state="translated">&lt;a href=&quot;list#VALfilter&quot;&gt; &lt;code&gt;List.filter&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 조건자는 요소의 인덱스에 첫 번째 인수 (0부터 계산)로 적용되고 요소 자체는 두 번째 인수로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e20aa8c2058bf36d3e8b459ad3395b6b300c531e" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;list#VALfor_all&quot;&gt;&lt;code&gt;List.for_all&lt;/code&gt;&lt;/a&gt;, but for a two-argument predicate.</source>
          <target state="translated">&lt;a href=&quot;list#VALfor_all&quot;&gt; &lt;code&gt;List.for_all&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 2 인수 술어 용입니다.</target>
        </trans-unit>
        <trans-unit id="b29d1bfe23107ab0449213a9cd11570013035e69" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;list#VALiter&quot;&gt;&lt;code&gt;List.iter&lt;/code&gt;&lt;/a&gt;, but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</source>
          <target state="translated">&lt;a href=&quot;list#VALiter&quot;&gt; &lt;code&gt;List.iter&lt;/code&gt; &lt;/a&gt; 와 동일 하지만이 함수는 요소의 인덱스에 첫 번째 인수 (0부터 계산)로 적용되고 요소 자체는 두 번째 인수로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dc684def61a91898b8e700c661c25c45499194c9" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;list#VALmap&quot;&gt;&lt;code&gt;List.map&lt;/code&gt;&lt;/a&gt;, but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</source>
          <target state="translated">&lt;a href=&quot;list#VALmap&quot;&gt; &lt;code&gt;List.map&lt;/code&gt; &lt;/a&gt; 과 동일 하지만이 함수는 요소의 인덱스에 첫 번째 인수 (0부터 계산)로 적용되고 요소 자체는 두 번째 인수로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="07e5da54b3e58cffce5dcf975ee537ee0049f347" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;list#VALmap&quot;&gt;&lt;code&gt;List.map&lt;/code&gt;&lt;/a&gt;, but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument. Not tail-recursive.</source>
          <target state="translated">&lt;a href=&quot;list#VALmap&quot;&gt; &lt;code&gt;List.map&lt;/code&gt; &lt;/a&gt; 과 동일 하지만이 함수는 요소의 인덱스에 첫 번째 인수 (0부터 계산)로 적용되고 요소 자체는 두 번째 인수로 적용됩니다. 꼬리 재귀가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f278f01b75f84339a95f02cf174f13fe98b87140" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;list#VALmem&quot;&gt;&lt;code&gt;List.mem&lt;/code&gt;&lt;/a&gt;, but uses physical equality instead of structural equality to compare list elements.</source>
          <target state="translated">&lt;a href=&quot;list#VALmem&quot;&gt; &lt;code&gt;List.mem&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 구조적 동등성 대신 물리적 동등성을 사용하여 목록 요소를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="cc597dd383c32c2fe212eea61ec88c51a1c705b7" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;list#VALmem_assoc&quot;&gt;&lt;code&gt;List.mem_assoc&lt;/code&gt;&lt;/a&gt;, but uses physical equality instead of structural equality to compare keys.</source>
          <target state="translated">&lt;a href=&quot;list#VALmem_assoc&quot;&gt; &lt;code&gt;List.mem_assoc&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 구조적 동등성 대신 물리적 동등성을 사용하여 키를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="c5648092d04fe28c8f412cb5f697baca8b54584a" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;list#VALremove_assoc&quot;&gt;&lt;code&gt;List.remove_assoc&lt;/code&gt;&lt;/a&gt;, but uses physical equality instead of structural equality to compare keys.</source>
          <target state="translated">&lt;a href=&quot;list#VALremove_assoc&quot;&gt; &lt;code&gt;List.remove_assoc&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 구조적 동등성 대신 물리적 동등성을 사용하여 키를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="cb15cbdfe0a952963566629782ecdca0c3663773" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;list#VALremove_assoc&quot;&gt;&lt;code&gt;List.remove_assoc&lt;/code&gt;&lt;/a&gt;, but uses physical equality instead of structural equality to compare keys. Not tail-recursive.</source>
          <target state="translated">&lt;a href=&quot;list#VALremove_assoc&quot;&gt; &lt;code&gt;List.remove_assoc&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 구조적 동등성 대신 물리적 동등성을 사용하여 키를 비교합니다. 꼬리 재귀가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="0c2bcc43ad0b1cf93273485e22b4686193cf40bf" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;list#VALsort&quot;&gt;&lt;code&gt;List.sort&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;list#VALstable_sort&quot;&gt;&lt;code&gt;List.stable_sort&lt;/code&gt;&lt;/a&gt;, whichever is faster on typical input.</source>
          <target state="translated">&lt;a href=&quot;list#VALsort&quot;&gt; &lt;code&gt;List.sort&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;list#VALstable_sort&quot;&gt; &lt;code&gt;List.stable_sort&lt;/code&gt; &lt;/a&gt; 중 일반적인 입력에서 더 빠른 것과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="f01e9ec044e06917acbacbf12f225663c50f555b" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;list#VALsort&quot;&gt;&lt;code&gt;List.sort&lt;/code&gt;&lt;/a&gt;, but also remove duplicates.</source>
          <target state="translated">&lt;a href=&quot;list#VALsort&quot;&gt; &lt;code&gt;List.sort&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 중복도 제거합니다.</target>
        </trans-unit>
        <trans-unit id="9ccf422348eea44e7c9498d76b6ec57751e6a10f" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;list#VALsort&quot;&gt;&lt;code&gt;List.sort&lt;/code&gt;&lt;/a&gt;, but the sorting algorithm is guaranteed to be stable (i.e.</source>
          <target state="translated">&lt;a href=&quot;list#VALsort&quot;&gt; &lt;code&gt;List.sort&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 정렬 알고리즘은 안정적입니다 (예 :</target>
        </trans-unit>
        <trans-unit id="7a12065f1cedfb3082a4e7c5cd09a36bb8788703" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;list#VALsort&quot;&gt;&lt;code&gt;List.sort&lt;/code&gt;&lt;/a&gt;, but the sorting algorithm is guaranteed to be stable (i.e. elements that compare equal are kept in their original order) .</source>
          <target state="translated">&lt;a href=&quot;list#VALsort&quot;&gt; &lt;code&gt;List.sort&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 정렬 알고리즘은 안정적입니다 (예 : 동일하게 비교되는 요소가 원래 순서대로 유지됨).</target>
        </trans-unit>
        <trans-unit id="5e41d8e08e07b0a5dc42e6f1c646ca9a18b1229d" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;map.s#VALmap&quot;&gt;&lt;code&gt;Map.S.map&lt;/code&gt;&lt;/a&gt;, but the function receives as arguments both the key and the associated value for each binding of the map.</source>
          <target state="translated">&lt;a href=&quot;map.s#VALmap&quot;&gt; &lt;code&gt;Map.S.map&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 함수는 맵의 각 바인딩에 대한 키 및 관련 값을 인수로받습니다.</target>
        </trans-unit>
        <trans-unit id="84610c6c6e340ae9eca648775ba33b1d58392e90" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;map.s#VALmin_binding&quot;&gt;&lt;code&gt;Map.S.min_binding&lt;/code&gt;&lt;/a&gt;, but returns the binding with the largest key in the given map.</source>
          <target state="translated">&lt;a href=&quot;map.s#VALmin_binding&quot;&gt; &lt;code&gt;Map.S.min_binding&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 주어진 맵에서 가장 큰 키를 가진 바인딩을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b5b97dc9f28ec2f18b7151b69bf9322fca370e94" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;map.s#VALmin_binding_opt&quot;&gt;&lt;code&gt;Map.S.min_binding_opt&lt;/code&gt;&lt;/a&gt;, but returns the binding with the largest key in the given map.</source>
          <target state="translated">&lt;a href=&quot;map.s#VALmin_binding_opt&quot;&gt; &lt;code&gt;Map.S.min_binding_opt&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 주어진 맵에서 가장 큰 키를 가진 바인딩을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="33c2489468e9f3f979019c6d86283fa45eaaad05" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;mutex#VALlock&quot;&gt;&lt;code&gt;Mutex.lock&lt;/code&gt;&lt;/a&gt;, but does not suspend the calling thread if the mutex is already locked: just return &lt;code&gt;false&lt;/code&gt; immediately in that case.</source>
          <target state="translated">&lt;a href=&quot;mutex#VALlock&quot;&gt; &lt;code&gt;Mutex.lock&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 뮤텍스가 이미 잠겨 있으면 호출 스레드를 일시 중단하지 않습니다 .이 경우 즉시 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="7bf9f1cc52702f4bf949ebd2de44c29ddce8d82d" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;mutex#VALlock&quot;&gt;&lt;code&gt;Mutex.lock&lt;/code&gt;&lt;/a&gt;, but does not suspend the calling thread if the mutex is already locked: just return &lt;code&gt;false&lt;/code&gt; immediately in that case. If the mutex is unlocked, lock it and return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;mutex#VALlock&quot;&gt; &lt;code&gt;Mutex.lock&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 뮤텍스가 이미 잠겨 있으면 호출 스레드를 일시 중단하지 않습니다 .이 경우 즉시 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다. 뮤텍스가 잠금 해제 된 경우 잠그고 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="29bb30b08c76e9218330938ed5acf4b7bd43235f" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;nativeint#VALcompare&quot;&gt;&lt;code&gt;Nativeint.compare&lt;/code&gt;&lt;/a&gt;, except that arguments are interpreted as &lt;em&gt;unsigned&lt;/em&gt; native integers.</source>
          <target state="translated">동일 &lt;a href=&quot;nativeint#VALcompare&quot;&gt; &lt;code&gt;Nativeint.compare&lt;/code&gt; &lt;/a&gt; , 인수로 해석됩니다 것을 제외하고 &lt;em&gt;서명되지 않은&lt;/em&gt; 기본 정수.</target>
        </trans-unit>
        <trans-unit id="6ac5f2fa99301d1533783bef4faf9022ba510be2" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;nativeint#VALdiv&quot;&gt;&lt;code&gt;Nativeint.div&lt;/code&gt;&lt;/a&gt;, except that arguments and result are interpreted as &lt;em&gt; unsigned&lt;/em&gt; native integers.</source>
          <target state="translated">동일 &lt;a href=&quot;nativeint#VALdiv&quot;&gt; &lt;code&gt;Nativeint.div&lt;/code&gt; &lt;/a&gt; 그 인수 및 결과를 제외하고는,로 해석됩니다 &lt;em&gt;부호없는&lt;/em&gt; 기본 정수.</target>
        </trans-unit>
        <trans-unit id="48ed9d59b23177b4aeda7c57295a325c64d73dfb" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;nativeint#VALrem&quot;&gt;&lt;code&gt;Nativeint.rem&lt;/code&gt;&lt;/a&gt;, except that arguments and result are interpreted as &lt;em&gt; unsigned&lt;/em&gt; native integers.</source>
          <target state="translated">동일 &lt;a href=&quot;nativeint#VALrem&quot;&gt; &lt;code&gt;Nativeint.rem&lt;/code&gt; &lt;/a&gt; 그 인수 및 결과를 제외하고는,로 해석됩니다 &lt;em&gt;부호없는&lt;/em&gt; 기본 정수.</target>
        </trans-unit>
        <trans-unit id="6979a20df1226ab09dd0bba9c80d7b3a5fd8d882" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;nativeint#VALto_int&quot;&gt;&lt;code&gt;Nativeint.to_int&lt;/code&gt;&lt;/a&gt;, but interprets the argument as an &lt;em&gt;unsigned&lt;/em&gt; integer.</source>
          <target state="translated">&lt;a href=&quot;nativeint#VALto_int&quot;&gt; &lt;code&gt;Nativeint.to_int&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 인수를 &lt;em&gt;부호없는&lt;/em&gt; 정수 로 해석합니다 .</target>
        </trans-unit>
        <trans-unit id="1ee21bd32ca71f640d563ef90f2b892055a57a73" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;nativeint#VALto_int&quot;&gt;&lt;code&gt;Nativeint.to_int&lt;/code&gt;&lt;/a&gt;, but interprets the argument as an &lt;em&gt;unsigned&lt;/em&gt; integer. Returns &lt;code&gt;None&lt;/code&gt; if the unsigned value of the argument cannot fit into an &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;nativeint#VALto_int&quot;&gt; &lt;code&gt;Nativeint.to_int&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 인수를 &lt;em&gt;부호없는&lt;/em&gt; 정수 로 해석합니다 . 인수의 부호없는 값이 &lt;code&gt;int&lt;/code&gt; 에 맞지 않으면 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="f93f6e6d4ceb9e25ff2460d13da6de6e961e6619" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;parsing#VALsymbol_start&quot;&gt;&lt;code&gt;Parsing.symbol_start&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;parsing#VALsymbol_end&quot;&gt;&lt;code&gt;Parsing.symbol_end&lt;/code&gt;&lt;/a&gt;, but return the offset of the string matching the &lt;code&gt;n&lt;/code&gt;th item on the right-hand side of the rule, where &lt;code&gt;n&lt;/code&gt; is the integer parameter to &lt;code&gt;rhs_start&lt;/code&gt; and &lt;code&gt;rhs_end&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;a href=&quot;parsing#VALsymbol_start&quot;&gt; &lt;code&gt;Parsing.symbol_start&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;parsing#VALsymbol_end&quot;&gt; &lt;code&gt;Parsing.symbol_end&lt;/code&gt; &lt;/a&gt; 하지만, 일치하는 문자열의 오프셋을 돌려주는 &lt;code&gt;n&lt;/code&gt; 규칙의 오른쪽에 제 항목 &lt;code&gt;n&lt;/code&gt; 의 정수 파라미터 &lt;code&gt;rhs_start&lt;/code&gt; 및 &lt;code&gt;rhs_end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e44ea14896b49d8694c81026509f0a4272d72a4" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;parsing#VALsymbol_start&quot;&gt;&lt;code&gt;Parsing.symbol_start&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;parsing#VALsymbol_end&quot;&gt;&lt;code&gt;Parsing.symbol_end&lt;/code&gt;&lt;/a&gt;, but return the offset of the string matching the &lt;code&gt;n&lt;/code&gt;th item on the right-hand side of the rule, where &lt;code&gt;n&lt;/code&gt; is the integer parameter to &lt;code&gt;rhs_start&lt;/code&gt; and &lt;code&gt;rhs_end&lt;/code&gt;. &lt;code&gt;n&lt;/code&gt; is 1 for the leftmost item.</source>
          <target state="translated">동일 &lt;a href=&quot;parsing#VALsymbol_start&quot;&gt; &lt;code&gt;Parsing.symbol_start&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;parsing#VALsymbol_end&quot;&gt; &lt;code&gt;Parsing.symbol_end&lt;/code&gt; &lt;/a&gt; 하지만, 일치하는 문자열의 오프셋을 돌려주는 &lt;code&gt;n&lt;/code&gt; 규칙의 오른쪽에 제 항목 &lt;code&gt;n&lt;/code&gt; 의 정수 파라미터 &lt;code&gt;rhs_start&lt;/code&gt; 및 &lt;code&gt;rhs_end&lt;/code&gt; . &lt;code&gt;n&lt;/code&gt; 은 가장 왼쪽 항목의 경우 1입니다.</target>
        </trans-unit>
        <trans-unit id="6cb7ceb07c3d1a6b6d400da25ad838125aa3c850" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;printf#VALbprintf&quot;&gt;&lt;code&gt;Printf.bprintf&lt;/code&gt;&lt;/a&gt;, but does not print anything.</source>
          <target state="translated">&lt;a href=&quot;printf#VALbprintf&quot;&gt; &lt;code&gt;Printf.bprintf&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 아무것도 인쇄하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="597d77ddd034f823f008ceac00b46c902306198d" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;printf#VALbprintf&quot;&gt;&lt;code&gt;Printf.bprintf&lt;/code&gt;&lt;/a&gt;, but does not print anything. Useful to ignore some material when conditionally printing.</source>
          <target state="translated">&lt;a href=&quot;printf#VALbprintf&quot;&gt; &lt;code&gt;Printf.bprintf&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 아무것도 인쇄하지 않습니다. 조건부로 인쇄 할 때 일부 자료를 무시하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="05a2091c4119f6172112c2ac5717acc5da8f9018" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;printf#VALfprintf&quot;&gt;&lt;code&gt;Printf.fprintf&lt;/code&gt;&lt;/a&gt;, but does not print anything.</source>
          <target state="translated">&lt;a href=&quot;printf#VALfprintf&quot;&gt; &lt;code&gt;Printf.fprintf&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 아무것도 인쇄하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="116d3974ff88722606a899c2f2d0e80529debebf" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;printf#VALfprintf&quot;&gt;&lt;code&gt;Printf.fprintf&lt;/code&gt;&lt;/a&gt;, but does not print anything. Useful to ignore some material when conditionally printing.</source>
          <target state="translated">&lt;a href=&quot;printf#VALfprintf&quot;&gt; &lt;code&gt;Printf.fprintf&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 아무것도 인쇄하지 않습니다. 조건부로 인쇄 할 때 일부 자료를 무시하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="98bf747b8baf691783a29088f7de04889b8227d7" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;printf#VALfprintf&quot;&gt;&lt;code&gt;Printf.fprintf&lt;/code&gt;&lt;/a&gt;, but instead of printing on an output channel, append the formatted arguments to the given extensible buffer (see module &lt;a href=&quot;buffer&quot;&gt;&lt;code&gt;Buffer&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;printf#VALfprintf&quot;&gt; &lt;code&gt;Printf.fprintf&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 출력 채널에 인쇄하는 대신 지정된 확장 가능한 버퍼에 형식화 된 인수를 추가합니다 ( &lt;a href=&quot;buffer&quot;&gt; &lt;code&gt;Buffer&lt;/code&gt; &lt;/a&gt; 모듈 참조 ).</target>
        </trans-unit>
        <trans-unit id="2dbd5088eeeb6897ec892724ea0d0eb339118411" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;printf#VALfprintf&quot;&gt;&lt;code&gt;Printf.fprintf&lt;/code&gt;&lt;/a&gt;, but instead of printing on an output channel, return a string containing the result of formatting the arguments.</source>
          <target state="translated">&lt;a href=&quot;printf#VALfprintf&quot;&gt; &lt;code&gt;Printf.fprintf&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 출력 채널에 인쇄하는 대신 인수 형식화 결과가 포함 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="903835fc5ab41ecba837a51ccab77d4ddaf2f12f" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;printf#VALfprintf&quot;&gt;&lt;code&gt;Printf.fprintf&lt;/code&gt;&lt;/a&gt;, but output on &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;printf#VALfprintf&quot;&gt; &lt;code&gt;Printf.fprintf&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 &lt;code&gt;stderr&lt;/code&gt; 에 출력 됩니다.</target>
        </trans-unit>
        <trans-unit id="0627b2dfc136353cfa912810f662e028607e49e1" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;printf#VALfprintf&quot;&gt;&lt;code&gt;Printf.fprintf&lt;/code&gt;&lt;/a&gt;, but output on &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;printf#VALfprintf&quot;&gt; &lt;code&gt;Printf.fprintf&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 &lt;code&gt;stdout&lt;/code&gt; 에 출력됩니다 .</target>
        </trans-unit>
        <trans-unit id="605fd49a2fc5b49e6640ac52ec79127278757dd6" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;random#VALinit&quot;&gt;&lt;code&gt;Random.init&lt;/code&gt;&lt;/a&gt; but takes more data as seed.</source>
          <target state="translated">&lt;a href=&quot;random#VALinit&quot;&gt; &lt;code&gt;Random.init&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 더 많은 데이터를 시드로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="38c97b0749b6e2e68c84c9c4c1d523339f996017" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;scanf#VALbscanf&quot;&gt;&lt;code&gt;Scanf.bscanf&lt;/code&gt;&lt;/a&gt;, but reads from the given string.</source>
          <target state="translated">&lt;a href=&quot;scanf#VALbscanf&quot;&gt; &lt;code&gt;Scanf.bscanf&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 주어진 문자열에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="b7a9aa3ce5444c788f6bafbb53a27b4625a5fdac" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;scanf#VALbscanf&quot;&gt;&lt;code&gt;Scanf.bscanf&lt;/code&gt;&lt;/a&gt;, but reads from the predefined formatted input channel &lt;a href=&quot;scanf.scanning#VALstdin&quot;&gt;&lt;code&gt;Scanf.Scanning.stdin&lt;/code&gt;&lt;/a&gt; that is connected to &lt;a href=&quot;stdlib#VALstdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;scanf#VALbscanf&quot;&gt; &lt;code&gt;Scanf.bscanf&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 &lt;a href=&quot;stdlib#VALstdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; 에&lt;/a&gt; 연결된 미리 정의 된 형식의 입력 채널 &lt;a href=&quot;scanf.scanning#VALstdin&quot;&gt; &lt;code&gt;Scanf.Scanning.stdin&lt;/code&gt; &lt;/a&gt; 에서 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="7e275ae24fb70616c1c93959eab119121e5bc039" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;scanf#VALbscanf&quot;&gt;&lt;code&gt;Scanf.bscanf&lt;/code&gt;&lt;/a&gt;, but takes an additional function argument &lt;code&gt;ef&lt;/code&gt; that is called in case of error: if the scanning process or some conversion fails, the scanning function aborts and calls the error handling function &lt;code&gt;ef&lt;/code&gt; with the formatted input channel and the exception that aborted the scanning process as arguments.</source>
          <target state="translated">&lt;a href=&quot;scanf#VALbscanf&quot;&gt; &lt;code&gt;Scanf.bscanf&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 오류시 호출 되는 추가 함수 인수 &lt;code&gt;ef&lt;/code&gt; 를 사용합니다. 스캔 프로세스 또는 일부 변환이 실패하면 스캔 함수가 중단되고 형식이 지정된 입력 채널 및 예외를 사용 하여 오류 처리 함수 &lt;code&gt;ef&lt;/code&gt; 를 호출합니다. 스캔 프로세스를 인수로 중단했습니다.</target>
        </trans-unit>
        <trans-unit id="07f65fb6c848e411824e9128a096ea90d81db9af" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;scanf#VALbscanf_format&quot;&gt;&lt;code&gt;Scanf.bscanf_format&lt;/code&gt;&lt;/a&gt;, but reads from the given string.</source>
          <target state="translated">&lt;a href=&quot;scanf#VALbscanf_format&quot;&gt; &lt;code&gt;Scanf.bscanf_format&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 주어진 문자열에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="5309bcd41583f28972ebfef8e49e8bce448e4527" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;scanf#VALkscanf&quot;&gt;&lt;code&gt;Scanf.kscanf&lt;/code&gt;&lt;/a&gt; but reads from the given string.</source>
          <target state="translated">&lt;a href=&quot;scanf#VALkscanf&quot;&gt; &lt;code&gt;Scanf.kscanf&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 주어진 문자열에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="323e86ec70bd89677346a6583a829ebbe2ae7330" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;set.s#VALmin_elt&quot;&gt;&lt;code&gt;Set.S.min_elt&lt;/code&gt;&lt;/a&gt;, but returns the largest element of the given set.</source>
          <target state="translated">&lt;a href=&quot;set.s#VALmin_elt&quot;&gt; &lt;code&gt;Set.S.min_elt&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 주어진 집합에서 가장 큰 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4d87d14d0afc47f407599cb66efa429712c223dc" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;set.s#VALmin_elt_opt&quot;&gt;&lt;code&gt;Set.S.min_elt_opt&lt;/code&gt;&lt;/a&gt;, but returns the largest element of the given set.</source>
          <target state="translated">&lt;a href=&quot;set.s#VALmin_elt_opt&quot;&gt; &lt;code&gt;Set.S.min_elt_opt&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 주어진 집합에서 가장 큰 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2f9f5003c9600b6a1f306994666e30bcb5ce7c91" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;stdlib#VALbool_of_string_opt&quot;&gt;&lt;code&gt;bool_of_string_opt&lt;/code&gt;&lt;/a&gt;, but raise &lt;code&gt;Invalid_argument&amp;nbsp;&quot;bool_of_string&quot;&lt;/code&gt; instead of returning &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALbool_of_string_opt&quot;&gt; &lt;code&gt;bool_of_string_opt&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 &lt;code&gt;None&lt;/code&gt; 을 반환하는 대신 &lt;code&gt;Invalid_argument&amp;nbsp;&quot;bool_of_string&quot;&lt;/code&gt; 을 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="411b9f76037f4296364868efdfde037a2156c23a" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;stdlib#VALfloat_of_int&quot;&gt;&lt;code&gt;float_of_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALfloat_of_int&quot;&gt; &lt;code&gt;float_of_int&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="6ce8917bfbdaf74dd0dc77a9bc97edf18aa8cf85" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;stdlib#VALfloat_of_string_opt&quot;&gt;&lt;code&gt;float_of_string_opt&lt;/code&gt;&lt;/a&gt;, but raise &lt;code&gt;Failure&amp;nbsp;&quot;float_of_string&quot;&lt;/code&gt; instead of returning &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALfloat_of_string_opt&quot;&gt; &lt;code&gt;float_of_string_opt&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 &lt;code&gt;None&lt;/code&gt; 을 반환하는 대신 &lt;code&gt;Failure&amp;nbsp;&quot;float_of_string&quot;&lt;/code&gt; 을 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="7fe6d67d833098b31b91689dfff0d8e1d7c7eef0" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;stdlib#VALinput_char&quot;&gt;&lt;code&gt;input_char&lt;/code&gt;&lt;/a&gt;, but return the 8-bit integer representing the character.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALinput_char&quot;&gt; &lt;code&gt;input_char&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 문자를 나타내는 8 비트 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9247863ad3361094f638c21625cd94974860a2e1" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;stdlib#VALint_of_float&quot;&gt;&lt;code&gt;int_of_float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALint_of_float&quot;&gt; &lt;code&gt;int_of_float&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f05f7c8c1bc41d854474c20c8ad2e9d8bb05f930" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;stdlib#VALint_of_string_opt&quot;&gt;&lt;code&gt;int_of_string_opt&lt;/code&gt;&lt;/a&gt;, but raise &lt;code&gt;Failure&amp;nbsp;&quot;int_of_string&quot;&lt;/code&gt; instead of returning &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALint_of_string_opt&quot;&gt; &lt;code&gt;int_of_string_opt&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 &lt;code&gt;None&lt;/code&gt; 을 반환하는 대신 &lt;code&gt;Failure&amp;nbsp;&quot;int_of_string&quot;&lt;/code&gt; 을 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="3c53cd139a31694470cf050f422d3a0265b9112a" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;stdlib#VALopen_in&quot;&gt;&lt;code&gt;open_in&lt;/code&gt;&lt;/a&gt;, but the file is opened in binary mode, so that no translation takes place during reads.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALopen_in&quot;&gt; &lt;code&gt;open_in&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 파일이 바이너리 모드로 열리므로 읽기 중에 변환이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55ecc123ad0cb37869733b8983aa4916c8f93d14" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;stdlib#VALopen_in&quot;&gt;&lt;code&gt;open_in&lt;/code&gt;&lt;/a&gt;, but the file is opened in binary mode, so that no translation takes place during reads. On operating systems that do not distinguish between text mode and binary mode, this function behaves like &lt;a href=&quot;stdlib#VALopen_in&quot;&gt;&lt;code&gt;open_in&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALopen_in&quot;&gt; &lt;code&gt;open_in&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 파일이 바이너리 모드로 열리므로 읽기 중에 변환이 발생하지 않습니다. 텍스트 모드와 바이너리 모드를 구분하지 않는 운영 체제에서이 함수는 &lt;a href=&quot;stdlib#VALopen_in&quot;&gt; &lt;code&gt;open_in&lt;/code&gt; &lt;/a&gt; 처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="323f16be34977b08ef0742f0a4d6244d3ca7c57e" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;stdlib#VALopen_out&quot;&gt;&lt;code&gt;open_out&lt;/code&gt;&lt;/a&gt;, but the file is opened in binary mode, so that no translation takes place during writes.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALopen_out&quot;&gt; &lt;code&gt;open_out&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 파일이 바이너리 모드로 열리므로 쓰기 중에 변환이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d93234224074545ee7a9e2b9a86554a2981b69e2" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;stdlib#VALopen_out&quot;&gt;&lt;code&gt;open_out&lt;/code&gt;&lt;/a&gt;, but the file is opened in binary mode, so that no translation takes place during writes. On operating systems that do not distinguish between text mode and binary mode, this function behaves like &lt;a href=&quot;stdlib#VALopen_out&quot;&gt;&lt;code&gt;open_out&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALopen_out&quot;&gt; &lt;code&gt;open_out&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 파일이 바이너리 모드로 열리므로 쓰기 중에 변환이 발생하지 않습니다. 텍스트 모드와 바이너리 모드를 구분하지 않는 운영 체제에서이 함수는 &lt;a href=&quot;stdlib#VALopen_out&quot;&gt; &lt;code&gt;open_out&lt;/code&gt; &lt;/a&gt; 처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="24481b089af2657000809001c238b6f9b0f4e0af" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;stdlib#VALread_float_opt&quot;&gt;&lt;code&gt;read_float_opt&lt;/code&gt;&lt;/a&gt;, but raise &lt;code&gt;Failure&amp;nbsp;&quot;float_of_string&quot;&lt;/code&gt; instead of returning &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">동일 &lt;a href=&quot;stdlib#VALread_float_opt&quot;&gt; &lt;code&gt;read_float_opt&lt;/code&gt; &lt;/a&gt; 하지만 인상 &lt;code&gt;Failure&amp;nbsp;&quot;float_of_string&quot;&lt;/code&gt; 대신 반환하지의 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48c74b7de295eba63ba5f3a919e8f2c6adbd8a33" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;stdlib#VALread_int_opt&quot;&gt;&lt;code&gt;read_int_opt&lt;/code&gt;&lt;/a&gt;, but raise &lt;code&gt;Failure&amp;nbsp;&quot;int_of_string&quot;&lt;/code&gt; instead of returning &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALread_int_opt&quot;&gt; &lt;code&gt;read_int_opt&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 &lt;code&gt;None&lt;/code&gt; 을 반환하는 대신 &lt;code&gt;Failure&amp;nbsp;&quot;int_of_string&quot;&lt;/code&gt; 을 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="8ddba8b73df312e3bb8a4a4dd00d3f77a1490c51" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;str#VALbounded_split&quot;&gt;&lt;code&gt;Str.bounded_split&lt;/code&gt;&lt;/a&gt;, but occurrences of the delimiter at the beginning and at the end of the string are recognized and returned as empty strings in the result.</source>
          <target state="translated">&lt;a href=&quot;str#VALbounded_split&quot;&gt; &lt;code&gt;Str.bounded_split&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 문자열의 시작과 끝에서 구분 기호가 발생하면 결과에서 빈 문자열로 인식되고 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6982fa0eb06337a7c3dae1ced9283df7661e381e" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;str#VALbounded_split_delim&quot;&gt;&lt;code&gt;Str.bounded_split_delim&lt;/code&gt;&lt;/a&gt;, but returns the delimiters as well as the substrings contained between delimiters.</source>
          <target state="translated">&lt;a href=&quot;str#VALbounded_split_delim&quot;&gt; &lt;code&gt;Str.bounded_split_delim&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 구분 기호와 구분 기호 사이에 포함 된 하위 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e64952e02cabe857b0729cf1e9340753ed51e7ff" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;str#VALbounded_split_delim&quot;&gt;&lt;code&gt;Str.bounded_split_delim&lt;/code&gt;&lt;/a&gt;, but returns the delimiters as well as the substrings contained between delimiters. The former are tagged &lt;code&gt;Delim&lt;/code&gt; in the result list; the latter are tagged &lt;code&gt;Text&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;str#VALbounded_split_delim&quot;&gt; &lt;code&gt;Str.bounded_split_delim&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 구분 기호와 구분 기호 사이에 포함 된 하위 문자열을 반환합니다. 전자는 결과 목록에서 &lt;code&gt;Delim&lt;/code&gt; 태그가 지정 됩니다. 후자는 &lt;code&gt;Text&lt;/code&gt; 태그가 지정 됩니다.</target>
        </trans-unit>
        <trans-unit id="e1609c94404d88fc9d53b1da97ce9d20515d7246" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;str#VALglobal_replace&quot;&gt;&lt;code&gt;Str.global_replace&lt;/code&gt;&lt;/a&gt;, except that only the first substring matching the regular expression is replaced.</source>
          <target state="translated">&lt;a href=&quot;str#VALglobal_replace&quot;&gt; &lt;code&gt;Str.global_replace&lt;/code&gt; &lt;/a&gt; 와 동일하지만 정규식 과 일치하는 첫 번째 하위 문자열 만 대체된다는 점이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="fd9b2a60d8afcf0ca57919fb33a2a161d8146a3c" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;str#VALglobal_substitute&quot;&gt;&lt;code&gt;Str.global_substitute&lt;/code&gt;&lt;/a&gt;, except that only the first substring matching the regular expression is replaced.</source>
          <target state="translated">&lt;a href=&quot;str#VALglobal_substitute&quot;&gt; &lt;code&gt;Str.global_substitute&lt;/code&gt; &lt;/a&gt; 와 동일하지만 정규 표현식과 일치하는 첫 번째 하위 문자열 만 대체된다는 점이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="645dbfce7f97a3c08c8bb5134f87363d3ea98801" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;str#VALsplit&quot;&gt;&lt;code&gt;Str.split&lt;/code&gt;&lt;/a&gt; but occurrences of the delimiter at the beginning and at the end of the string are recognized and returned as empty strings in the result.</source>
          <target state="translated">&lt;a href=&quot;str#VALsplit&quot;&gt; &lt;code&gt;Str.split&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 문자열의 시작과 끝에서 구분 기호가 발생하면 결과에서 빈 문자열로 인식되고 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="69b2ab41a3851df0e07eb8f0456bd4d76cffc716" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;str#VALsplit&quot;&gt;&lt;code&gt;Str.split&lt;/code&gt;&lt;/a&gt; but occurrences of the delimiter at the beginning and at the end of the string are recognized and returned as empty strings in the result. For instance, &lt;code&gt;split_delim&amp;nbsp;(regexp&amp;nbsp;&quot;&amp;nbsp;&quot;)&amp;nbsp;&quot;&amp;nbsp;abc&amp;nbsp;&quot;&lt;/code&gt; returns &lt;code&gt;[&quot;&quot;;&amp;nbsp;&quot;abc&quot;;&amp;nbsp;&quot;&quot;]&lt;/code&gt;, while &lt;code&gt;split&lt;/code&gt; with the same arguments returns &lt;code&gt;[&quot;abc&quot;]&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;str#VALsplit&quot;&gt; &lt;code&gt;Str.split&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 문자열의 시작과 끝에서 구분 기호가 발생하면 결과에서 빈 문자열로 인식되고 반환됩니다. 예를 들어, &lt;code&gt;split_delim&amp;nbsp;(regexp&amp;nbsp;&quot;&amp;nbsp;&quot;)&amp;nbsp;&quot;&amp;nbsp;abc&amp;nbsp;&quot;&lt;/code&gt; 는 &lt;code&gt;[&quot;&quot;;&amp;nbsp;&quot;abc&quot;;&amp;nbsp;&quot;&quot;]&lt;/code&gt; 반환합니다 . &quot;알파벳&quot;; &quot;&quot;] , 동일한 인수로 &lt;code&gt;split&lt;/code&gt; 하면 &lt;code&gt;[&quot;abc&quot;]&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8b0b8ef7d1667633a23a5a4ee7b93a1e32d8b88d" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;str#VALsplit&quot;&gt;&lt;code&gt;Str.split&lt;/code&gt;&lt;/a&gt;, but splits into at most &lt;code&gt;n&lt;/code&gt; substrings, where &lt;code&gt;n&lt;/code&gt; is the extra integer parameter.</source>
          <target state="translated">&lt;a href=&quot;str#VALsplit&quot;&gt; &lt;code&gt;Str.split&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 최대 &lt;code&gt;n&lt;/code&gt; 개의 하위 문자열 로 분할됩니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은 추가 정수 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="2b72a1f0b7788615dc64f6f1c8fbca31f272f622" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;str#VALsplit_delim&quot;&gt;&lt;code&gt;Str.split_delim&lt;/code&gt;&lt;/a&gt;, but returns the delimiters as well as the substrings contained between delimiters.</source>
          <target state="translated">&lt;a href=&quot;str#VALsplit_delim&quot;&gt; &lt;code&gt;Str.split_delim&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 구분 기호와 구분 기호 사이에 포함 된 하위 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="15f877265312f461d1096d92069bf7f458372831" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;str#VALsplit_delim&quot;&gt;&lt;code&gt;Str.split_delim&lt;/code&gt;&lt;/a&gt;, but returns the delimiters as well as the substrings contained between delimiters. The former are tagged &lt;code&gt;Delim&lt;/code&gt; in the result list; the latter are tagged &lt;code&gt;Text&lt;/code&gt;. For instance, &lt;code&gt;full_split&amp;nbsp;(regexp&amp;nbsp;&quot;[{}]&quot;)&amp;nbsp;&quot;{ab}&quot;&lt;/code&gt; returns &lt;code&gt;[Delim&amp;nbsp;&quot;{&quot;;&amp;nbsp;Text&amp;nbsp;&quot;ab&quot;;&amp;nbsp;Delim&amp;nbsp;&quot;}&quot;]&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;str#VALsplit_delim&quot;&gt; &lt;code&gt;Str.split_delim&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 구분 기호와 구분 기호 사이에 포함 된 하위 문자열을 반환합니다. 전자는 결과 목록에서 &lt;code&gt;Delim&lt;/code&gt; 태그가 지정 됩니다. 후자는 &lt;code&gt;Text&lt;/code&gt; 태그가 지정 됩니다. 예를 들어 &lt;code&gt;full_split&amp;nbsp;(regexp&amp;nbsp;&quot;[{}]&quot;)&amp;nbsp;&quot;{ab}&quot;&lt;/code&gt; 는 &lt;code&gt;[Delim&amp;nbsp;&quot;{&quot;;&amp;nbsp;Text&amp;nbsp;&quot;ab&quot;;&amp;nbsp;Delim&amp;nbsp;&quot;}&quot;]&lt;/code&gt; 반환합니다 . 텍스트 &quot;ab&quot;; DELIM &quot;}&quot;] .</target>
        </trans-unit>
        <trans-unit id="d0692f3a3cee00e3b8603778a4c7712906ec4621" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;string#VALiter&quot;&gt;&lt;code&gt;String.iter&lt;/code&gt;&lt;/a&gt;, but the function is applied to the index of the element as first argument (counting from 0), and the character itself as second argument.</source>
          <target state="translated">&lt;a href=&quot;string#VALiter&quot;&gt; &lt;code&gt;String.iter&lt;/code&gt; &lt;/a&gt; 와 동일 하지만이 함수는 요소의 인덱스에 첫 번째 인수 (0부터 계산)로 적용되고 문자 자체는 두 번째 인수로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d7968ed5b081149c89f1e0fa86bf0d5f30d7c69e" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;sys#VALsignal&quot;&gt;&lt;code&gt;Sys.signal&lt;/code&gt;&lt;/a&gt; but return value is ignored.</source>
          <target state="translated">&lt;a href=&quot;sys#VALsignal&quot;&gt; &lt;code&gt;Sys.signal&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 반환 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5daa4aa669d6140b1f11939508bb7452da79a67c" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALexecv&quot;&gt;&lt;code&gt;Unix.execv&lt;/code&gt;&lt;/a&gt;, except that the program is searched in the path.</source>
          <target state="translated">프로그램이 경로에서 검색된다는 점을 제외하면 &lt;a href=&quot;unix#VALexecv&quot;&gt; &lt;code&gt;Unix.execv&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="2a708d9cd30d9bcb873a2bbdec55ad092a2283c6" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALexecv&quot;&gt;&lt;code&gt;Unix.execv&lt;/code&gt;&lt;/a&gt;, except that the third argument provides the environment to the program executed.</source>
          <target state="translated">세 번째 인수가 실행되는 프로그램에 환경을 제공한다는 점을 제외하면 &lt;a href=&quot;unix#VALexecv&quot;&gt; &lt;code&gt;Unix.execv&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="b893cf728ed7c290ea4d8de6a765228904e7e9cd" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALexecve&quot;&gt;&lt;code&gt;Unix.execve&lt;/code&gt;&lt;/a&gt;, except that the program is searched in the path.</source>
          <target state="translated">프로그램이 경로에서 검색된다는 점을 제외하면 &lt;a href=&quot;unix#VALexecve&quot;&gt; &lt;code&gt;Unix.execve&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="d6c6b3275127e4a2b0e15806210c78557a90a641" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALgetsockopt&quot;&gt;&lt;code&gt;Unix.getsockopt&lt;/code&gt;&lt;/a&gt; for a socket option whose value is a floating-point number.</source>
          <target state="translated">값이 부동 소수점 숫자 인 소켓 옵션에 대한 &lt;a href=&quot;unix#VALgetsockopt&quot;&gt; &lt;code&gt;Unix.getsockopt&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="e0552634335a6244379f872d5afcf9b8ff17abac" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALgetsockopt&quot;&gt;&lt;code&gt;Unix.getsockopt&lt;/code&gt;&lt;/a&gt; for a socket option whose value is an &lt;code&gt;int&amp;nbsp;option&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;int&amp;nbsp;option&lt;/code&gt; 인 소켓 옵션에 대한 &lt;a href=&quot;unix#VALgetsockopt&quot;&gt; &lt;code&gt;Unix.getsockopt&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="6ccd2775d37b244d589570b5a83bf1fff470f930" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALgetsockopt&quot;&gt;&lt;code&gt;Unix.getsockopt&lt;/code&gt;&lt;/a&gt; for an integer-valued socket option.</source>
          <target state="translated">정수 값 소켓 옵션에 대한 &lt;a href=&quot;unix#VALgetsockopt&quot;&gt; &lt;code&gt;Unix.getsockopt&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="d0de5100000461ea91875aa316785dbb2c728a71" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALopen_process_args_in&quot;&gt;&lt;code&gt;Unix.open_process_args_in&lt;/code&gt;&lt;/a&gt;, but redirect the standard input of the command to a pipe.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process_args_in&quot;&gt; &lt;code&gt;Unix.open_process_args_in&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 명령의 표준 입력을 파이프로 리디렉션합니다.</target>
        </trans-unit>
        <trans-unit id="04a6dbb90158d0d77adf57f026936d0c57220866" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALopen_process_args_in&quot;&gt;&lt;code&gt;Unix.open_process_args_in&lt;/code&gt;&lt;/a&gt;, but redirect the standard input of the command to a pipe. Data written to the returned output channel is sent to the standard input of the command. Warning: writes on output channels are buffered, hence be careful to call &lt;a href=&quot;stdlib#VALflush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; at the right times to ensure correct synchronization.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process_args_in&quot;&gt; &lt;code&gt;Unix.open_process_args_in&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 명령의 표준 입력을 파이프로 리디렉션합니다. 반환 된 출력 채널에 기록 된 데이터는 명령의 표준 입력으로 전송됩니다. 경고 : 출력 채널에 대한 쓰기는 버퍼링되므로 올바른 동기화를 보장하기 위해 적절한시기에 &lt;a href=&quot;stdlib#VALflush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; 를 호출하도록주의 하십시오.</target>
        </trans-unit>
        <trans-unit id="1ca74917dcbeb57f2b329b75e10bb25b503b0a8f" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALopen_process_args_out&quot;&gt;&lt;code&gt;Unix.open_process_args_out&lt;/code&gt;&lt;/a&gt;, but redirects both the standard input and standard output of the command to pipes connected to the two returned channels.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process_args_out&quot;&gt; &lt;code&gt;Unix.open_process_args_out&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 명령의 표준 입력 및 표준 출력을 두 개의 반환 된 채널에 연결된 파이프로 리디렉션합니다.</target>
        </trans-unit>
        <trans-unit id="6730908a84b3cb3f1a13eccdf0036a5d8fb4fe3f" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALopen_process_args_out&quot;&gt;&lt;code&gt;Unix.open_process_args_out&lt;/code&gt;&lt;/a&gt;, but redirects both the standard input and standard output of the command to pipes connected to the two returned channels. The input channel is connected to the output of the command, and the output channel to the input of the command.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process_args_out&quot;&gt; &lt;code&gt;Unix.open_process_args_out&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 명령의 표준 입력 및 표준 출력을 두 개의 반환 된 채널에 연결된 파이프로 리디렉션합니다. 입력 채널은 명령의 출력에 연결되고 출력 채널은 명령의 입력에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="fd4f33fc262e197a9c5c5faa35e1af02e51522fb" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALopen_process_in&quot;&gt;&lt;code&gt;Unix.open_process_in&lt;/code&gt;&lt;/a&gt;, but redirect the standard input of the command to a pipe.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process_in&quot;&gt; &lt;code&gt;Unix.open_process_in&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 명령의 표준 입력을 파이프로 리디렉션합니다.</target>
        </trans-unit>
        <trans-unit id="4432b186980b65050b14ebe524d6ccb0effe1cbe" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALopen_process_in&quot;&gt;&lt;code&gt;Unix.open_process_in&lt;/code&gt;&lt;/a&gt;, but redirect the standard input of the command to a pipe. Data written to the returned output channel is sent to the standard input of the command. Warning: writes on output channels are buffered, hence be careful to call &lt;a href=&quot;stdlib#VALflush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; at the right times to ensure correct synchronization. If the command does not need to be run through the shell, &lt;a href=&quot;unix#VALopen_process_args_out&quot;&gt;&lt;code&gt;Unix.open_process_args_out&lt;/code&gt;&lt;/a&gt; can be used instead of &lt;a href=&quot;unix#VALopen_process_out&quot;&gt;&lt;code&gt;Unix.open_process_out&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process_in&quot;&gt; &lt;code&gt;Unix.open_process_in&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 명령의 표준 입력을 파이프로 리디렉션합니다. 반환 된 출력 채널에 기록 된 데이터는 명령의 표준 입력으로 전송됩니다. 경고 : 출력 채널에 대한 쓰기는 버퍼링되므로 올바른 동기화를 보장하기 위해 적절한시기에 &lt;a href=&quot;stdlib#VALflush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; 를 호출하도록주의 하십시오. 명령 쉘을 실행할 필요가없는 경우, &lt;a href=&quot;unix#VALopen_process_args_out&quot;&gt; &lt;code&gt;Unix.open_process_args_out&lt;/code&gt; 는&lt;/a&gt; 대신 사용할 수 있습니다 &lt;a href=&quot;unix#VALopen_process_out&quot;&gt; &lt;code&gt;Unix.open_process_out&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="400f201b658e10b1fb5d5ee1a5edd0d521281cc3" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALopen_process_out&quot;&gt;&lt;code&gt;Unix.open_process_out&lt;/code&gt;&lt;/a&gt;, but redirects both the standard input and standard output of the command to pipes connected to the two returned channels.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process_out&quot;&gt; &lt;code&gt;Unix.open_process_out&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 명령의 표준 입력 및 표준 출력을 두 개의 반환 된 채널에 연결된 파이프로 리디렉션합니다.</target>
        </trans-unit>
        <trans-unit id="9bd93e8c46769e4a63980a0df1c06c4705ad215f" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALopen_process_out&quot;&gt;&lt;code&gt;Unix.open_process_out&lt;/code&gt;&lt;/a&gt;, but redirects both the standard input and standard output of the command to pipes connected to the two returned channels. The input channel is connected to the output of the command, and the output channel to the input of the command. If the command does not need to be run through the shell, &lt;a href=&quot;unix#VALopen_process_args&quot;&gt;&lt;code&gt;Unix.open_process_args&lt;/code&gt;&lt;/a&gt; can be used instead of &lt;a href=&quot;unix#VALopen_process&quot;&gt;&lt;code&gt;Unix.open_process&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process_out&quot;&gt; &lt;code&gt;Unix.open_process_out&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 명령의 표준 입력 및 표준 출력을 두 개의 반환 된 채널에 연결된 파이프로 리디렉션합니다. 입력 채널은 명령의 출력에 연결되고 출력 채널은 명령의 입력에 연결됩니다. 명령 쉘을 실행할 필요가없는 경우, &lt;a href=&quot;unix#VALopen_process_args&quot;&gt; &lt;code&gt;Unix.open_process_args&lt;/code&gt; 는&lt;/a&gt; 대신 사용할 수 있습니다 &lt;a href=&quot;unix#VALopen_process&quot;&gt; &lt;code&gt;Unix.open_process&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6543a4be336cd7a10bc2562d9d658e2168377e8" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALsetsockopt&quot;&gt;&lt;code&gt;Unix.setsockopt&lt;/code&gt;&lt;/a&gt; for a socket option whose value is a floating-point number.</source>
          <target state="translated">값이 부동 소수점 숫자 인 소켓 옵션에 대한 &lt;a href=&quot;unix#VALsetsockopt&quot;&gt; &lt;code&gt;Unix.setsockopt&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="6c5b76333b4e99e6a9ab705b4249e48d9dd668ad" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALsetsockopt&quot;&gt;&lt;code&gt;Unix.setsockopt&lt;/code&gt;&lt;/a&gt; for a socket option whose value is an &lt;code&gt;int&amp;nbsp;option&lt;/code&gt;.</source>
          <target state="translated">값이 &lt;code&gt;int&amp;nbsp;option&lt;/code&gt; 인 소켓 옵션에 대한 &lt;a href=&quot;unix#VALsetsockopt&quot;&gt; &lt;code&gt;Unix.setsockopt&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="fed90d80a7d1a730063ec7a3b8b32ff6edc3351e" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALsetsockopt&quot;&gt;&lt;code&gt;Unix.setsockopt&lt;/code&gt;&lt;/a&gt; for an integer-valued socket option.</source>
          <target state="translated">정수 값 소켓 옵션에 대한 &lt;a href=&quot;unix#VALsetsockopt&quot;&gt; &lt;code&gt;Unix.setsockopt&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="3c98f0bea8300ac91fb9f63d0fd4a61c14dd081b" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALstat&quot;&gt;&lt;code&gt;Unix.stat&lt;/code&gt;&lt;/a&gt;, but in case the file is a symbolic link, return the information for the link itself.</source>
          <target state="translated">&lt;a href=&quot;unix#VALstat&quot;&gt; &lt;code&gt;Unix.stat&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 파일이 심볼릭 링크 인 경우 링크 자체에 대한 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d0f0bbf3af3fd498bd73c1b249f8494b3b0d662b" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALtime&quot;&gt;&lt;code&gt;Unix.time&lt;/code&gt;&lt;/a&gt;, but with resolution better than 1 second.</source>
          <target state="translated">&lt;a href=&quot;unix#VALtime&quot;&gt; &lt;code&gt;Unix.time&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 해상도가 1 초 이상입니다.</target>
        </trans-unit>
        <trans-unit id="a21154fa6f6e436f37ee974e7f6836eda29d4db4" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALwait&quot;&gt;&lt;code&gt;Unix.wait&lt;/code&gt;&lt;/a&gt;, but waits for the child process whose pid is given.</source>
          <target state="translated">동일 &lt;a href=&quot;unix#VALwait&quot;&gt; &lt;code&gt;Unix.wait&lt;/code&gt; &lt;/a&gt; PID가 주어진다 자식 프로세스에 대한,하지만 기다립니다.</target>
        </trans-unit>
        <trans-unit id="608298b1f57c96bf9fc4424262d4f324a7df0264" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unix#VALwait&quot;&gt;&lt;code&gt;Unix.wait&lt;/code&gt;&lt;/a&gt;, but waits for the child process whose pid is given. A pid of &lt;code&gt;-1&lt;/code&gt; means wait for any child. A pid of &lt;code&gt;0&lt;/code&gt; means wait for any child in the same process group as the current process. Negative pid arguments represent process groups. The list of options indicates whether &lt;code&gt;waitpid&lt;/code&gt; should return immediately without waiting, and whether it should report stopped children.</source>
          <target state="translated">동일 &lt;a href=&quot;unix#VALwait&quot;&gt; &lt;code&gt;Unix.wait&lt;/code&gt; &lt;/a&gt; PID가 주어진다 자식 프로세스에 대한,하지만 기다립니다. &lt;code&gt;-1&lt;/code&gt; 의 pid는 모든 자식을 기다림을 의미합니다. pid가 &lt;code&gt;0&lt;/code&gt; 이면 현재 프로세스와 동일한 프로세스 그룹에서 자식을 기다립니다. 음의 pid 인수는 프로세스 그룹을 나타냅니다. 옵션 목록은 &lt;code&gt;waitpid&lt;/code&gt; 가 기다리지 않고 즉시 반환해야하는지 여부와 중지 된 자식을보고해야하는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="caf47a2e07a1307ccaa0e16933dbac1c3da8ff4a" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unixlabels#VALexecv&quot;&gt;&lt;code&gt;UnixLabels.execv&lt;/code&gt;&lt;/a&gt;, except that the program is searched in the path.</source>
          <target state="translated">프로그램이 경로에서 검색된다는 점을 제외하면 &lt;a href=&quot;unixlabels#VALexecv&quot;&gt; &lt;code&gt;UnixLabels.execv&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="17608b7ce230e91245ac7189baaf4b5d7c629aae" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unixlabels#VALexecv&quot;&gt;&lt;code&gt;UnixLabels.execv&lt;/code&gt;&lt;/a&gt;, except that the third argument provides the environment to the program executed.</source>
          <target state="translated">세 번째 인수가 실행되는 프로그램에 환경을 제공한다는 점을 제외하면 &lt;a href=&quot;unixlabels#VALexecv&quot;&gt; &lt;code&gt;UnixLabels.execv&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="ab31c3ea08cf5e6e296addd6e070d481600d65ca" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unixlabels#VALexecve&quot;&gt;&lt;code&gt;UnixLabels.execve&lt;/code&gt;&lt;/a&gt;, except that the program is searched in the path.</source>
          <target state="translated">프로그램이 경로에서 검색된다는 점을 제외하면 &lt;a href=&quot;unixlabels#VALexecve&quot;&gt; &lt;code&gt;UnixLabels.execve&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="a98a38c1ab8a2c589f6d8614fd139b40081fdbef" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unixlabels#VALopen_process_in&quot;&gt;&lt;code&gt;UnixLabels.open_process_in&lt;/code&gt;&lt;/a&gt;, but redirect the standard input of the command to a pipe.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALopen_process_in&quot;&gt; &lt;code&gt;UnixLabels.open_process_in&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 명령의 표준 입력을 파이프로 리디렉션합니다.</target>
        </trans-unit>
        <trans-unit id="56dd9b0f8e60849f5e1ccd200832c2368f0a5c6d" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unixlabels#VALopen_process_in&quot;&gt;&lt;code&gt;UnixLabels.open_process_in&lt;/code&gt;&lt;/a&gt;, but redirect the standard input of the command to a pipe. Data written to the returned output channel is sent to the standard input of the command. Warning: writes on output channels are buffered, hence be careful to call &lt;a href=&quot;stdlib#VALflush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; at the right times to ensure correct synchronization.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALopen_process_in&quot;&gt; &lt;code&gt;UnixLabels.open_process_in&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 명령의 표준 입력을 파이프로 리디렉션합니다. 반환 된 출력 채널에 기록 된 데이터는 명령의 표준 입력으로 전송됩니다. 경고 : 출력 채널에 대한 쓰기는 버퍼링되므로 올바른 동기화를 보장하기 위해 적절한시기에 &lt;a href=&quot;stdlib#VALflush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; 를 호출하도록주의 하십시오.</target>
        </trans-unit>
        <trans-unit id="c53f3ebb5a3a3ec8212e53346d9dfbc917d46153" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unixlabels#VALopen_process_out&quot;&gt;&lt;code&gt;UnixLabels.open_process_out&lt;/code&gt;&lt;/a&gt;, but redirects both the standard input and standard output of the command to pipes connected to the two returned channels.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALopen_process_out&quot;&gt; &lt;code&gt;UnixLabels.open_process_out&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 명령의 표준 입력 및 표준 출력을 두 개의 반환 된 채널에 연결된 파이프로 리디렉션합니다.</target>
        </trans-unit>
        <trans-unit id="9ff2be04cc4a4f2bd8a41d7809f3c42b1b3fd623" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unixlabels#VALopen_process_out&quot;&gt;&lt;code&gt;UnixLabels.open_process_out&lt;/code&gt;&lt;/a&gt;, but redirects both the standard input and standard output of the command to pipes connected to the two returned channels. The input channel is connected to the output of the command, and the output channel to the input of the command.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALopen_process_out&quot;&gt; &lt;code&gt;UnixLabels.open_process_out&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 명령의 표준 입력 및 표준 출력을 두 개의 반환 된 채널에 연결된 파이프로 리디렉션합니다. 입력 채널은 명령의 출력에 연결되고 출력 채널은 명령의 입력에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="303c640a353eb6c65832957f63f4a41545d98822" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unixlabels#VALstat&quot;&gt;&lt;code&gt;UnixLabels.stat&lt;/code&gt;&lt;/a&gt;, but in case the file is a symbolic link, return the information for the link itself.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALstat&quot;&gt; &lt;code&gt;UnixLabels.stat&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 파일이 심볼릭 링크 인 경우 링크 자체에 대한 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b718023cdbaf7a0d1781215e8a8748920d9f2df" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unixlabels#VALtime&quot;&gt;&lt;code&gt;UnixLabels.time&lt;/code&gt;&lt;/a&gt;, but with resolution better than 1 second.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALtime&quot;&gt; &lt;code&gt;UnixLabels.time&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 해상도가 1 초 이상입니다.</target>
        </trans-unit>
        <trans-unit id="407561584b38a5960b1bf7c185b210603368a748" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unixlabels#VALwait&quot;&gt;&lt;code&gt;UnixLabels.wait&lt;/code&gt;&lt;/a&gt;, but waits for the child process whose pid is given.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALwait&quot;&gt; &lt;code&gt;UnixLabels.wait&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 pid가 주어진 자식 프로세스를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="fb6c5594c06859b6b1695bad3261a2a664f2a4fb" translate="yes" xml:space="preserve">
          <source>Same as &lt;a href=&quot;unixlabels#VALwait&quot;&gt;&lt;code&gt;UnixLabels.wait&lt;/code&gt;&lt;/a&gt;, but waits for the child process whose pid is given. A pid of &lt;code&gt;-1&lt;/code&gt; means wait for any child. A pid of &lt;code&gt;0&lt;/code&gt; means wait for any child in the same process group as the current process. Negative pid arguments represent process groups. The list of options indicates whether &lt;code&gt;waitpid&lt;/code&gt; should return immediately without waiting, or also report stopped children.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALwait&quot;&gt; &lt;code&gt;UnixLabels.wait&lt;/code&gt; &lt;/a&gt; 와 동일 하지만 pid가 주어진 자식 프로세스를 기다립니다. &lt;code&gt;-1&lt;/code&gt; 의 pid는 모든 자식을 기다림을 의미합니다. pid가 &lt;code&gt;0&lt;/code&gt; 이면 현재 프로세스와 동일한 프로세스 그룹에서 자식을 기다립니다. 음의 pid 인수는 프로세스 그룹을 나타냅니다. 옵션 목록은 &lt;code&gt;waitpid&lt;/code&gt; 가 기다리지 않고 즉시 반환해야하는지 또는 중지 된 자식을보고 해야하는지 여부를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="5a8bd99c7460ce991b1f76d7dcf77ff141574343" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;Seq.map&amp;nbsp;fst&amp;nbsp;(to_seq&amp;nbsp;m)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Seq.map&amp;nbsp;fst&amp;nbsp;(to_seq&amp;nbsp;m)&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="7ef87ad5fdb766aea3427cbbe06977d8fb00c341" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;Seq.map&amp;nbsp;snd&amp;nbsp;(to_seq&amp;nbsp;m)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Seq.map&amp;nbsp;snd&amp;nbsp;(to_seq&amp;nbsp;m)&lt;/code&gt; 와 동일</target>
        </trans-unit>
        <trans-unit id="e7756dac8c5684d7502c839de58fd561337b099e" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;asprintf&lt;/code&gt; above, but instead of returning the string, passes it to the first argument.</source>
          <target state="translated">위의 &lt;code&gt;asprintf&lt;/code&gt; 와 동일 하지만 문자열을 반환하는 대신 첫 번째 인수에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="2de1149116241df59ce72d742b17cc08c1f28ba3" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;bprintf&lt;/code&gt;, but instead of returning immediately, passes the buffer to its first argument at the end of printing.</source>
          <target state="translated">&lt;code&gt;bprintf&lt;/code&gt; 와 동일 하지만 즉시 반환하는 대신 인쇄가 끝날 때 버퍼를 첫 번째 인수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="61229c95603a206567541d2bae31c03be44a6ab5" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;close_in&lt;/code&gt;, but ignore all errors.</source>
          <target state="translated">&lt;code&gt;close_in&lt;/code&gt; 과 동일 하지만 모든 오류를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="5d80a1452822a59937e135872716a381c7e03182" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;close_out&lt;/code&gt;, but ignore all errors.</source>
          <target state="translated">&lt;code&gt;close_out&lt;/code&gt; 과 동일 하지만 모든 오류를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="2d6ca41e5568da892b2762ee089046bff8ba2459" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;concat&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="d8fa7f17194e3019021ddf61c6f46e34ecaa33b8" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;concat&lt;/code&gt;. Not tail-recursive (length of the argument + length of the longest sub-list).</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; 과 동일합니다 . 꼬리 재귀 적이 지 않습니다 (인수 길이 + 가장 긴 하위 목록의 길이).</target>
        </trans-unit>
        <trans-unit id="dd4c33c9d65f70c9d7ee1af0731dc7e8afd8c5c1" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;fprintf&lt;/code&gt; above, but does not print anything.</source>
          <target state="translated">동일 &lt;code&gt;fprintf&lt;/code&gt; 와 위,하지만 아무것도 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="165e8a97fa41eb82e0c8c1d8cfb0b30aab69602d" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;fprintf&lt;/code&gt; above, but does not print anything. Useful to ignore some material when conditionally printing.</source>
          <target state="translated">동일 &lt;code&gt;fprintf&lt;/code&gt; 와 위,하지만 아무것도 인쇄되지 않습니다. 조건부로 인쇄 할 때 일부 자료를 무시하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="09958f5b48b2b309b5ea3a63488376b83e2afe60" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;fprintf&lt;/code&gt; above, but instead of returning immediately, passes the formatter to its first argument at the end of printing.</source>
          <target state="translated">위의 &lt;code&gt;fprintf&lt;/code&gt; 와 동일 하지만 즉시 반환하는 대신 인쇄가 끝날 때 포맷터를 첫 번째 인수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="d32e61b52c71a7c9fd70e10a78dcb52a61a03a27" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;fprintf&lt;/code&gt; above, but output on &lt;code&gt;err_formatter&lt;/code&gt;.</source>
          <target state="translated">위의 &lt;code&gt;fprintf&lt;/code&gt; 와 동일 하지만 &lt;code&gt;err_formatter&lt;/code&gt; 에 출력됩니다 .</target>
        </trans-unit>
        <trans-unit id="28b5d440509fc53579868ce26db55574dadde8f3" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;fprintf&lt;/code&gt; above, but output on &lt;code&gt;std_formatter&lt;/code&gt;.</source>
          <target state="translated">위의 &lt;code&gt;fprintf&lt;/code&gt; 와 동일 하지만 &lt;code&gt;std_formatter&lt;/code&gt; 에 출력됩니다 .</target>
        </trans-unit>
        <trans-unit id="fca0121f9ecc3f9eea36751ece9717cff6b5ca08" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;fprintf&lt;/code&gt;, but instead of returning immediately, passes the out channel to its first argument at the end of printing.</source>
          <target state="translated">&lt;code&gt;fprintf&lt;/code&gt; 와 동일 하지만 즉시 반환하지 않고 출력이 끝날 때 출력 채널을 첫 번째 인수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="85477ad9607910645a4cae463af0194fcbcbbd82" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;from_bytes&lt;/code&gt; but take a string as argument instead of a byte sequence.</source>
          <target state="translated">동일 &lt;code&gt;from_bytes&lt;/code&gt; 하지만 인수 대신 바이트 시퀀스로 문자열을.</target>
        </trans-unit>
        <trans-unit id="f902a890b4677fdb53fb593b92d348fd89e4ecad" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;kbprintf&lt;/code&gt; above, but does not print anything.</source>
          <target state="translated">위의 &lt;code&gt;kbprintf&lt;/code&gt; 와 동일 하지만 아무것도 인쇄하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="323e7c74b03ec833b5f658d968f462e2f00a6fde" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;kbprintf&lt;/code&gt; above, but does not print anything. Useful to ignore some material when conditionally printing.</source>
          <target state="translated">위의 &lt;code&gt;kbprintf&lt;/code&gt; 와 동일 하지만 아무것도 인쇄하지 않습니다. 조건부로 인쇄 할 때 일부 자료를 무시하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e6b9b887c852a909f173f4fe9d2c194966481272" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;kfprintf&lt;/code&gt; above, but does not print anything.</source>
          <target state="translated">동일 &lt;code&gt;kfprintf&lt;/code&gt; 위,하지만 아무것도 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9a0812a679830e5f1a73eded5030020c526bfe4" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;kfprintf&lt;/code&gt; above, but does not print anything. Useful to ignore some material when conditionally printing.</source>
          <target state="translated">동일 &lt;code&gt;kfprintf&lt;/code&gt; 위,하지만 아무것도 인쇄되지 않습니다. 조건부로 인쇄 할 때 일부 자료를 무시하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="eee6fff015990c50ecc5fe249480a12a9634bf27" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;loadfile&lt;/code&gt;, except that the compilation units just loaded are hidden (cannot be referenced) from other modules dynamically loaded afterwards.</source>
          <target state="translated">동일 &lt;code&gt;loadfile&lt;/code&gt; 단지로드 컴파일 단위가 숨겨져있는 것을 제외하고, 동적 이후에로드 된 다른 모듈에서 (참조 할 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="48345963e7cc4adb3c40b2554f5eb535743ade0b" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;of_string&lt;/code&gt;, but return &lt;code&gt;None&lt;/code&gt; instead of raising.</source>
          <target state="translated">동일 &lt;code&gt;of_string&lt;/code&gt; 하지만, 반환 &lt;code&gt;None&lt;/code&gt; 대신 모금.</target>
        </trans-unit>
        <trans-unit id="c361c25057b9bffccefbf7a19e0a3b5f29828cbb" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;of_string&lt;/code&gt;, but returns &lt;code&gt;None&lt;/code&gt; instead of raising.</source>
          <target state="translated">과 동일 &lt;code&gt;of_string&lt;/code&gt; 하지만, 반환 &lt;code&gt;None&lt;/code&gt; 대신 모금.</target>
        </trans-unit>
        <trans-unit id="86057e6fc58542ce6470d1356aa453ddd23f0003" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;output&lt;/code&gt; but take a string as argument instead of a byte sequence.</source>
          <target state="translated">&lt;code&gt;output&lt;/code&gt; 과 동일 하지만 바이트 시퀀스 대신 문자열을 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a365765c385649c35170a1d62d4e139abc842c29" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;printf&lt;/code&gt; above, but instead of printing on a formatter, returns a string containing the result of formatting the arguments.</source>
          <target state="translated">위의 &lt;code&gt;printf&lt;/code&gt; 와 동일 하지만 포맷터에 인쇄하는 대신 인수를 포맷 한 결과가 포함 된 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b219cd221033e5561185d56137b7eea562e4b09" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;printf&lt;/code&gt; above, but instead of printing on a formatter, returns a string containing the result of formatting the arguments. Note that the pretty-printer queue is flushed at the end of &lt;em&gt;each call&lt;/em&gt; to &lt;code&gt;sprintf&lt;/code&gt;.</source>
          <target state="translated">위의 &lt;code&gt;printf&lt;/code&gt; 와 동일 하지만 포맷터에 인쇄하는 대신 인수를 포맷 한 결과가 포함 된 문자열을 반환합니다. 예쁜 - 프린터 큐의 끝에서 플러시합니다 &lt;em&gt;각 호출&lt;/em&gt; 에 &lt;code&gt;sprintf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e81d9086ebf44148891816f93a6e76c592f3978e" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;printf&lt;/code&gt; above, but instead of printing on a formatter, returns a string containing the result of formatting the arguments. The type of &lt;code&gt;asprintf&lt;/code&gt; is general enough to interact nicely with &lt;code&gt;%a&lt;/code&gt; conversions.</source>
          <target state="translated">위의 &lt;code&gt;printf&lt;/code&gt; 와 동일 하지만 포맷터에 인쇄하는 대신 인수를 포맷 한 결과가 포함 된 문자열을 반환합니다. &lt;code&gt;asprintf&lt;/code&gt; 유형은 &lt;code&gt;%a&lt;/code&gt; 변환 과 잘 상호 작용할 수있을만큼 일반적 입니다.</target>
        </trans-unit>
        <trans-unit id="fd7b48bd5c2197002483acb223b697bff0e3eba4" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;regexp&lt;/code&gt;, but the compiled expression will match text in a case-insensitive way: uppercase and lowercase letters will be considered equivalent.</source>
          <target state="translated">&lt;code&gt;regexp&lt;/code&gt; 와 동일 하지만 컴파일 된 표현식은 대소 문자를 구분하지 않는 방식으로 텍스트와 일치합니다. 대문자와 소문자는 동등한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="457184985758494e7a293224dbb7a5261a63aa7d" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;rhs_end&lt;/code&gt;, but return a &lt;code&gt;position&lt;/code&gt; instead of an offset.</source>
          <target state="translated">&lt;code&gt;rhs_end&lt;/code&gt; 와 동일 하지만 오프셋 대신 &lt;code&gt;position&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a72b7e9c224a9ccb1f2f53e778523b27aac6ffab" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;rhs_start&lt;/code&gt;, but return a &lt;code&gt;position&lt;/code&gt; instead of an offset.</source>
          <target state="translated">&lt;code&gt;rhs_start&lt;/code&gt; 와 동일 하지만 오프셋 대신 &lt;code&gt;position&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7b335828744b489e53f0f480711956e971ada67e" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;send&lt;/code&gt;, but take the data from a string instead of a byte sequence.</source>
          <target state="translated">&lt;code&gt;send&lt;/code&gt; 와 동일 하지만 바이트 시퀀스 대신 문자열에서 데이터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7eb3a73795775f6f04310a222acafcac613122f8" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;sendto&lt;/code&gt;, but take the data from a string instead of a byte sequence.</source>
          <target state="translated">&lt;code&gt;sendto&lt;/code&gt; 와 동일 하지만 바이트 시퀀스 대신 문자열에서 데이터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f54b43ff13273c160359917038aac331c82c04f9" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;single_write&lt;/code&gt;, but take the data from a string instead of a byte sequence.</source>
          <target state="translated">&lt;code&gt;single_write&lt;/code&gt; 와 동일 하지만 바이트 시퀀스 대신 문자열에서 데이터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e509318a36aae9745538e3cff924b7f09940dcbc" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;sprintf&lt;/code&gt; above, but instead of returning the string, passes it to the first argument.</source>
          <target state="translated">위의 &lt;code&gt;sprintf&lt;/code&gt; 와 동일 하지만 문자열을 반환하는 대신 첫 번째 인수에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="32c369585a4d9e703310e60740d96bc801e60e3b" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;stat&lt;/code&gt; except that &lt;code&gt;live_words&lt;/code&gt;, &lt;code&gt;live_blocks&lt;/code&gt;, &lt;code&gt;free_words&lt;/code&gt;, &lt;code&gt;free_blocks&lt;/code&gt;, &lt;code&gt;largest_free&lt;/code&gt;, and &lt;code&gt;fragments&lt;/code&gt; are set to 0.</source>
          <target state="translated">&lt;code&gt;live_words&lt;/code&gt; , &lt;code&gt;live_blocks&lt;/code&gt; , &lt;code&gt;free_words&lt;/code&gt; , &lt;code&gt;free_blocks&lt;/code&gt; , &lt;code&gt;largest_free&lt;/code&gt; 및 &lt;code&gt;fragments&lt;/code&gt; 가 0으로 설정 된다는 점을 제외하면 &lt;code&gt;stat&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="c121c44f363a196365879e856b71cfa44216b1ff" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;stat&lt;/code&gt; except that &lt;code&gt;live_words&lt;/code&gt;, &lt;code&gt;live_blocks&lt;/code&gt;, &lt;code&gt;free_words&lt;/code&gt;, &lt;code&gt;free_blocks&lt;/code&gt;, &lt;code&gt;largest_free&lt;/code&gt;, and &lt;code&gt;fragments&lt;/code&gt; are set to 0. This function is much faster than &lt;code&gt;stat&lt;/code&gt; because it does not need to go through the heap.</source>
          <target state="translated">&lt;code&gt;live_words&lt;/code&gt; , &lt;code&gt;live_blocks&lt;/code&gt; , &lt;code&gt;free_words&lt;/code&gt; , &lt;code&gt;free_blocks&lt;/code&gt; , &lt;code&gt;largest_free&lt;/code&gt; 및 &lt;code&gt;fragments&lt;/code&gt; 가 0으로 설정 된다는 점을 제외하면 &lt;code&gt;stat&lt;/code&gt; 와 동일 합니다.이 함수는 힙을 통과 할 필요가 없기 때문에 &lt;code&gt;stat&lt;/code&gt; 보다 훨씬 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="f6ea64a04e25d166c8d8eaf4749b7ca5ff5d5f50" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;sub&lt;/code&gt; but return a string instead of a byte sequence.</source>
          <target state="translated">동일 &lt;code&gt;sub&lt;/code&gt; 하지만 대신 문자열의 바이트 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c09ed6459a018a79cfc1bc66f1086cb01ca523d5" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;symbol_end&lt;/code&gt;, but return a &lt;code&gt;position&lt;/code&gt; instead of an offset.</source>
          <target state="translated">&lt;code&gt;symbol_end&lt;/code&gt; 와 동일 하지만 오프셋 대신 &lt;code&gt;position&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e6fccc465944f04367da0ead152881f9e04a7e81" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;symbol_start&lt;/code&gt;, but return a &lt;code&gt;position&lt;/code&gt; instead of an offset.</source>
          <target state="translated">&lt;code&gt;symbol_start&lt;/code&gt; 와 동일 하지만 오프셋 대신 &lt;code&gt;position&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="af62a4434a21011f6e9180e3a60ca8d8125a6b26" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;to_bytes&lt;/code&gt; but return the result as a string instead of a byte sequence.</source>
          <target state="translated">동일 &lt;code&gt;to_bytes&lt;/code&gt; 하지만 대신 문자열의 바이트 순서로 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e369a07c4ea8f7e07ae61d5585560d651b9a9707" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;write&lt;/code&gt;, but attempts to write only once.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 와 동일 하지만 한 번만 쓰기를 시도합니다.</target>
        </trans-unit>
        <trans-unit id="b0ab15da80e429ebe8aeea44dd2d827709e48e38" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;write&lt;/code&gt;, but attempts to write only once. Thus, if an error occurs, &lt;code&gt;single_write&lt;/code&gt; guarantees that no data has been written.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 와 동일 하지만 한 번만 쓰기를 시도합니다. 따라서 오류가 발생하면 &lt;code&gt;single_write&lt;/code&gt; 는 데이터가 기록되지 않았 음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="3594c2736ae1bcbba2b97c88636073c3f47a55c4" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;write&lt;/code&gt;, but take the data from a string instead of a byte sequence.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 와 동일 하지만 바이트 시퀀스 대신 문자열에서 데이터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8481cdaf533433ae0c1f1fd3a549797cd49b6c98" translate="yes" xml:space="preserve">
          <source>Same as caml_ba_alloc, but the sizes of the array in each dimension are listed as extra arguments in the function call, rather than being passed as an array.</source>
          <target state="translated">caml_ba_alloc과 동일하지만 각 차원의 배열 크기는 배열로 전달되지 않고 함수 호출에서 추가 인수로 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="4326414e7d274f430f0f5afb1025c66fad82b993" translate="yes" xml:space="preserve">
          <source>Same as default</source>
          <target state="translated">기본값과 동일</target>
        </trans-unit>
        <trans-unit id="81635e2b4b2d81e962ad3462eb815e2981abd3a4" translate="yes" xml:space="preserve">
          <source>Same as directorydirectorynames, but the given directories will be searched only when looking for the source file of a module that has been packed into modulename.</source>
          <target state="translated">directorydirectorynames와 동일하지만 지정된 디렉토리는 modulename에 압축 된 모듈의 소스 파일을 찾을 때만 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="3e403a04412363e40f5f3e5fb7a9e63d1be63e7e" translate="yes" xml:space="preserve">
          <source>Same as print, but limit the depth of printing to 1. Useful to browse large data structures without printing them in full. display can be abbreviated as d.</source>
          <target state="translated">인쇄와 동일하지만 인쇄 깊이를 1로 제한합니다. 전체를 인쇄하지 않고 큰 데이터 구조를 탐색하는 데 유용합니다. 디스플레이는 d로 축약 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a664314bf8d6048fecd76f5fdce508da73f1f80" translate="yes" xml:space="preserve">
          <source>Same usage as in ocamlrun (see section &lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt;), except that option l is ignored (the operating system&amp;rsquo;s stack size limit is used instead).</source>
          <target state="translated">옵션 l이 무시된다는 점을 제외하고 는 ocamlrun (섹션 &lt;a href=&quot;runtime#s%3Aocamlrun-options&quot;&gt;11.2&lt;/a&gt; 참조)에서와 동일하게 사용됩니다 ( 대신 운영 체제의 스택 크기 제한이 사용됨).</target>
        </trans-unit>
        <trans-unit id="dbe8cbf2f2b94ce111ab0ab7f35a6d6e6c42c8e6" translate="yes" xml:space="preserve">
          <source>Sample code to iterate over all frames (inlined and non-inlined):</source>
          <target state="translated">모든 프레임 (인라인 및 비 인라인)을 반복하는 샘플 코드 :</target>
        </trans-unit>
        <trans-unit id="bd442e4ab9396a11176172c091d7cee7add08639" translate="yes" xml:space="preserve">
          <source>Sampling is temporarily disabled when calling a callback for the current thread. So they do not need to be reentrant if the program is single-threaded. However, if threads are used, it is possible that a context switch occurs during a callback, in this case the callback functions must be reentrant.</source>
          <target state="translated">현재 스레드에 대한 콜백을 호출 할 때 샘플링이 일시적으로 비활성화됩니다. 따라서 프로그램이 단일 스레드 인 경우 재진입 할 ​​필요가 없습니다. 그러나 스레드를 사용하는 경우 콜백 중에 컨텍스트 전환이 발생할 수 있습니다.이 경우 콜백 함수는 재진입해야합니다.</target>
        </trans-unit>
        <trans-unit id="27f0ff259c8112bb799c30c20ec70580cdb5253a" translate="yes" xml:space="preserve">
          <source>Scaling factor for benefit calculation when using -unbox-closures. See section &lt;a href=&quot;#ss%3Aflambda-unbox-closures&quot;&gt;21.9.3&lt;/a&gt;.</source>
          <target state="translated">-unbox-closures를 사용할 때 혜택 계산을위한 배율 인수입니다. 섹션 &lt;a href=&quot;#ss%3Aflambda-unbox-closures&quot;&gt;21.9.3을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="28cb15f1110ec48e7f98551a0ec23abfd0c1e5f1" translate="yes" xml:space="preserve">
          <source>Scanf</source>
          <target state="translated">Scanf</target>
        </trans-unit>
        <trans-unit id="6d3fbf50e39a89b9875d7e6bb1a322a49865ba47" translate="yes" xml:space="preserve">
          <source>Scanners may raise the following exceptions when the input cannot be read according to the format string:</source>
          <target state="translated">형식 문자열에 따라 입력을 읽을 수없는 경우 스캐너는 다음 예외를 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a70efc0f7828c46836202c2d47457d38736373e" translate="yes" xml:space="preserve">
          <source>Scanning indications appear just after the string conversions &lt;code&gt;%s&lt;/code&gt; and &lt;code&gt;%[&amp;nbsp;range&amp;nbsp;]&lt;/code&gt; to delimit the end of the token. A scanning indication is introduced by a &lt;code&gt;@&lt;/code&gt; character, followed by some plain character &lt;code&gt;c&lt;/code&gt;. It means that the string token should end just before the next matching &lt;code&gt;c&lt;/code&gt; (which is skipped). If no &lt;code&gt;c&lt;/code&gt; character is encountered, the string token spreads as much as possible. For instance, &lt;code&gt;&quot;%s@\t&quot;&lt;/code&gt; reads a string up to the next tab character or to the end of input. If a &lt;code&gt;@&lt;/code&gt; character appears anywhere else in the format string, it is treated as a plain character.</source>
          <target state="translated">스캔 표시 는 토큰의 끝을 구분하기 위해 문자열 변환 &lt;code&gt;%s&lt;/code&gt; 및 &lt;code&gt;%[&amp;nbsp;range&amp;nbsp;]&lt;/code&gt; 바로 뒤에 나타납니다 . 스캔 표시는 &lt;code&gt;@&lt;/code&gt; 문자와 일반 문자 &lt;code&gt;c&lt;/code&gt; 로 시작 됩니다. 이는 문자열 토큰이 다음 일치 &lt;code&gt;c&lt;/code&gt; (건너 뛰기) 바로 전에 끝나야 함을 의미합니다 . &lt;code&gt;c&lt;/code&gt; 문자가 없으면 문자열 토큰이 가능한 한 많이 퍼집니다. 예를 들어, &lt;code&gt;&quot;%s@\t&quot;&lt;/code&gt; 는 다음 탭 문자 또는 입력 끝까지 문자열을 읽습니다. 경우 &lt;code&gt;@&lt;/code&gt; 의 문자가 형식 문자열에 다른 곳 나타납니다, 그것은 일반 문자로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="95ed0e6d3bf4c13f8f5fbff20a20ce2709295670" translate="yes" xml:space="preserve">
          <source>Scanning indications in format strings</source>
          <target state="translated">형식 문자열의 스캔 표시</target>
        </trans-unit>
        <trans-unit id="20e2d37f170896ea7062b0ad6f0fcdfff1d85f14" translate="yes" xml:space="preserve">
          <source>Schedule a &lt;code&gt;SIGALRM&lt;/code&gt; signal after the given number of seconds.</source>
          <target state="translated">주어진 시간 (초) 후에 &lt;code&gt;SIGALRM&lt;/code&gt; 신호를 예약합니다 .</target>
        </trans-unit>
        <trans-unit id="f2e7e26f280f080d905292f0c4d79db8e6aa9dd3" translate="yes" xml:space="preserve">
          <source>Search the directory dir for dynamically-loaded libraries, in addition to the standard search path (see section &lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;).</source>
          <target state="translated">표준 검색 경로에 추가하여 동적으로로드 된 라이브러리에 대한 디렉토리 dir을 검색합니다 (섹션 &lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="fc6f32a5a536661bf7b4474da8fc1cec8ffabad4" translate="yes" xml:space="preserve">
          <source>Second, it also notifies the type checker that the type of the function should be polymorphic. Indeed, without explicit polymorphic type annotation, the following type annotation is perfectly valid</source>
          <target state="translated">둘째, 함수의 유형이 다형성이어야 함을 유형 검사기에 알립니다. 실제로 명시 적 다형성 유형 주석이 없으면 다음 유형 주석이 완벽하게 유효합니다.</target>
        </trans-unit>
        <trans-unit id="0d57ad8155ed417cf280a7c6ed005bbd68271208" translate="yes" xml:space="preserve">
          <source>Secondly, for records, OCaml can also deduce the right record type by looking at the whole set of fields used in a expression or pattern:</source>
          <target state="translated">둘째, 레코드의 경우 OCaml은 표현식 또는 패턴에 사용 된 전체 필드 집합을 확인하여 올바른 레코드 유형을 추론 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8e7f0bb110fb501e896f97abb678f94792aa78c" translate="yes" xml:space="preserve">
          <source>Seconds 0..60</source>
          <target state="translated">초 0..60</target>
        </trans-unit>
        <trans-unit id="ac86401d783cffa201b981e085f799bf8498d263" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;bigarray#VALchar&quot;&gt;&lt;code&gt;Bigarray.char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bigarray#VALchar&quot;&gt; &lt;code&gt;Bigarray.char&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4da4f758e9da516c2485f9f68d993993d7fc8cc5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;bigarray#VALfortran_layout&quot;&gt;&lt;code&gt;Bigarray.fortran_layout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bigarray#VALfortran_layout&quot;&gt; &lt;code&gt;Bigarray.fortran_layout&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c41ef46129783d44de423e15dd183806b44f6399" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;filename#VALbasename&quot;&gt;&lt;code&gt;Filename.basename&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;filename#VALbasename&quot;&gt; &lt;code&gt;Filename.basename&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="71122fe0c946308ef4312bedb5d901dde6d2e503" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;filename#VALbasename&quot;&gt;&lt;code&gt;Filename.basename&lt;/code&gt;&lt;/a&gt;. This function conforms to the specification of POSIX.1-2008 for the &lt;code&gt;dirname&lt;/code&gt; utility.</source>
          <target state="translated">&lt;a href=&quot;filename#VALbasename&quot;&gt; &lt;code&gt;Filename.basename&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 . 이 함수는 &lt;code&gt;dirname&lt;/code&gt; 유틸리티에 대한 POSIX.1-2008 사양을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="2191c81cd8e40179143cee672778664dc62022d6" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;marshal#VALheader_size&quot;&gt;&lt;code&gt;Marshal.header_size&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;marshal#VALheader_size&quot;&gt; &lt;code&gt;Marshal.header_size&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3a0e158d5b4d4995559ddcada00f718a47ed6ab" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;parsing#VALrhs_start&quot;&gt;&lt;code&gt;Parsing.rhs_start&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;parsing#VALrhs_start&quot;&gt; &lt;code&gt;Parsing.rhs_start&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1fd68a9cd836e826e538692b0f518ceb6d95b1f3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;parsing#VALsymbol_start&quot;&gt;&lt;code&gt;Parsing.symbol_start&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;parsing#VALsymbol_start&quot;&gt; &lt;code&gt;Parsing.symbol_start&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7473460fb55093a88c939ddf07bf5b97080d85d7" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;thread#VALwait_timed_write&quot;&gt;&lt;code&gt;Thread.wait_timed_write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;thread#VALwait_timed_write&quot;&gt; &lt;code&gt;Thread.wait_timed_write&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9d4bf83db9715a2cdd0b54cccc0eccada72d457" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;thread#VALwait_write&quot;&gt;&lt;code&gt;Thread.wait_write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;thread#VALwait_write&quot;&gt; &lt;code&gt;Thread.wait_write&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="117ae8697e149c8b10ba9fb72213dc70d8413f0c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;threadunix#VALtimed_write&quot;&gt;&lt;code&gt;ThreadUnix.timed_write&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;threadunix#VALtimed_write&quot;&gt; &lt;code&gt;ThreadUnix.timed_write&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="062b9eb85ac4f6537585317c419c75e1ead04a8b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;unix#VALftruncate&quot;&gt;&lt;code&gt;Unix.ftruncate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALftruncate&quot;&gt; &lt;code&gt;Unix.ftruncate&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="267f5d6d48db716a4209f785b2802c68df998040" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;unix#VALlseek&quot;&gt;&lt;code&gt;Unix.lseek&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALlseek&quot;&gt; &lt;code&gt;Unix.lseek&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7983bce1c7f5e7fb1e1f7b1727f347d34f1b4769" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;unix#VALtruncate&quot;&gt;&lt;code&gt;Unix.truncate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALtruncate&quot;&gt; &lt;code&gt;Unix.truncate&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="934e88396276c0c2240b775ffe7d702c1fad214e" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;(&amp;gt;=)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(&amp;gt;=)&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="afbdc53c2a856487304d86079f81868501dce464" translate="yes" xml:space="preserve">
          <source>See &lt;code&gt;(&amp;gt;=)&lt;/code&gt;. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;code&gt;(&amp;gt;=)&lt;/code&gt; 를 참조하십시오 . 왼쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="cf550f11a6d457559150bea06847214db84bceb9" translate="yes" xml:space="preserve">
          <source>See &lt;em&gt;direct call site&lt;/em&gt; and &lt;em&gt;indirect call site&lt;/em&gt; below.</source>
          <target state="translated">아래의 &lt;em&gt;직접 호출 사이트&lt;/em&gt; 및 &lt;em&gt;간접 호출 사이트를&lt;/em&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="42b4ebf3df5f1933706bd49f1f810739f86769b9" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;format#VALpp_set_geometry&quot;&gt;&lt;code&gt;Format.pp_set_geometry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;format#VALpp_set_geometry&quot;&gt; &lt;code&gt;Format.pp_set_geometry&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bada19b24002891e2127f82d655fb232612c4165" translate="yes" xml:space="preserve">
          <source>See also the following language extension: &lt;a href=&quot;extensionsyntax#ss%3Aextension-literals&quot;&gt;extension literals&lt;/a&gt;.</source>
          <target state="translated">다음 언어 확장도 참조하십시오 : &lt;a href=&quot;extensionsyntax#ss%3Aextension-literals&quot;&gt;확장 리터럴&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e2ee9c6eaaebba14087cba6c7dccbeafb26f9f20" translate="yes" xml:space="preserve">
          <source>See also the following language extension: &lt;a href=&quot;indexops#s%3Aindex-operators&quot;&gt;extended indexing operators&lt;/a&gt;.</source>
          <target state="translated">다음 언어 확장을 참조하십시오. &lt;a href=&quot;indexops#s%3Aindex-operators&quot;&gt;확장 인덱싱 연산자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7bc7936690111208cf1b4540a43bfc4e86d021b" translate="yes" xml:space="preserve">
          <source>See also the following language extensions: &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;attributes&lt;/a&gt; and &lt;a href=&quot;extensionnodes#s%3Aextension-nodes&quot;&gt;extension nodes&lt;/a&gt;.</source>
          <target state="translated">다음 언어 확장도 참조하십시오 : &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;속성&lt;/a&gt; 및 &lt;a href=&quot;extensionnodes#s%3Aextension-nodes&quot;&gt;확장 노드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ae0da72a16b2577a45cfe9897b6e643bb9e2ca8f" translate="yes" xml:space="preserve">
          <source>See also the following language extensions: &lt;a href=&quot;extensionsyntax#s%3Aext-ops&quot;&gt;extension operators&lt;/a&gt;, &lt;a href=&quot;indexops#s%3Aindex-operators&quot;&gt;extended indexing operators&lt;/a&gt;, and &lt;a href=&quot;bindingops#s%3Abinding-operators&quot;&gt;binding operators&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;extensionsyntax#s%3Aext-ops&quot;&gt;확장 연산자&lt;/a&gt; , &lt;a href=&quot;indexops#s%3Aindex-operators&quot;&gt;확장 인덱싱 연산자&lt;/a&gt; 및 &lt;a href=&quot;bindingops#s%3Abinding-operators&quot;&gt;바인딩 연산자&lt;/a&gt; 와 같은 언어 확장도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34c73179224e83424f2b6565f0815572a59180a7" translate="yes" xml:space="preserve">
          <source>See also the following language extensions: &lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;first-class modules&lt;/a&gt;, &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;attributes&lt;/a&gt; and &lt;a href=&quot;extensionnodes#s%3Aextension-nodes&quot;&gt;extension nodes&lt;/a&gt;.</source>
          <target state="translated">다음 언어 확장도 참조하십시오 : &lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;일급 모듈&lt;/a&gt; , &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;속성&lt;/a&gt; 및 &lt;a href=&quot;extensionnodes#s%3Aextension-nodes&quot;&gt;확장 노드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10f6e72f671a03b0649dd1686771098f16fd87b2" translate="yes" xml:space="preserve">
          <source>See also the following language extensions: &lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;first-class modules&lt;/a&gt;, &lt;a href=&quot;overridingopen#s%3Aexplicit-overriding-open&quot;&gt;overriding in open statements&lt;/a&gt;, &lt;a href=&quot;bigarray#s%3Abigarray-access&quot;&gt;syntax for Bigarray access&lt;/a&gt;, &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;attributes&lt;/a&gt;, &lt;a href=&quot;extensionnodes#s%3Aextension-nodes&quot;&gt;extension nodes&lt;/a&gt; and &lt;a href=&quot;indexops#s%3Aindex-operators&quot;&gt;extended indexing operators&lt;/a&gt;.</source>
          <target state="translated">또한 다음 언어 확장을 참조하십시오 : &lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;퍼스트 클래스 모듈&lt;/a&gt; , &lt;a href=&quot;overridingopen#s%3Aexplicit-overriding-open&quot;&gt;open 문에서 재정의&lt;/a&gt; , &lt;a href=&quot;bigarray#s%3Abigarray-access&quot;&gt;Bigarray 액세스 구문&lt;/a&gt; , &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;속성&lt;/a&gt; , &lt;a href=&quot;extensionnodes#s%3Aextension-nodes&quot;&gt;확장 노드&lt;/a&gt; 및 &lt;a href=&quot;indexops#s%3Aindex-operators&quot;&gt;확장 인덱싱 연산자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51afb98b828bb552a973a63ab8dfb1e7968deae7" translate="yes" xml:space="preserve">
          <source>See also the following language extensions: &lt;a href=&quot;locallyabstract#s%3Alocally-abstract&quot;&gt;locally abstract types&lt;/a&gt;, &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;attributes&lt;/a&gt; and &lt;a href=&quot;extensionnodes#s%3Aextension-nodes&quot;&gt;extension nodes&lt;/a&gt;.</source>
          <target state="translated">다음 언어 확장을 참조하십시오 : &lt;a href=&quot;locallyabstract#s%3Alocally-abstract&quot;&gt;로컬 추상 유형&lt;/a&gt; , &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;속성&lt;/a&gt; 및 &lt;a href=&quot;extensionnodes#s%3Aextension-nodes&quot;&gt;확장 노드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d964850f6cd04102cc69cbd15792541865759d3e" translate="yes" xml:space="preserve">
          <source>See also the following language extensions: &lt;a href=&quot;manual024#s%3Arecursive-modules&quot;&gt;recursive modules&lt;/a&gt;, &lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;first-class modules&lt;/a&gt;, &lt;a href=&quot;overridingopen#s%3Aexplicit-overriding-open&quot;&gt;overriding in open statements&lt;/a&gt;, &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;attributes&lt;/a&gt;, &lt;a href=&quot;extensionnodes#s%3Aextension-nodes&quot;&gt;extension nodes&lt;/a&gt; and &lt;a href=&quot;generativefunctors#s%3Agenerative-functors&quot;&gt;generative functors&lt;/a&gt;.</source>
          <target state="translated">다음 언어 확장을 참조하십시오 : &lt;a href=&quot;manual024#s%3Arecursive-modules&quot;&gt;재귀 모듈&lt;/a&gt; , &lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;일급 모듈&lt;/a&gt; , &lt;a href=&quot;overridingopen#s%3Aexplicit-overriding-open&quot;&gt;open 문에서 재정의&lt;/a&gt; , &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;속성&lt;/a&gt; , &lt;a href=&quot;extensionnodes#s%3Aextension-nodes&quot;&gt;확장 노드&lt;/a&gt; 및 &lt;a href=&quot;generativefunctors#s%3Agenerative-functors&quot;&gt;생성 펑터&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a720c82ecb5b1fb607f1b4d9f4172063164c829c" translate="yes" xml:space="preserve">
          <source>See also the following language extensions: &lt;a href=&quot;moduletypeof#s%3Amodule-type-of&quot;&gt;recovering the type of a module&lt;/a&gt;, &lt;a href=&quot;signaturesubstitution#s%3Asignature-substitution&quot;&gt;substitution inside a signature&lt;/a&gt;, &lt;a href=&quot;modulealias#s%3Amodule-alias&quot;&gt;type-level module aliases&lt;/a&gt;, &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;attributes&lt;/a&gt;, &lt;a href=&quot;extensionnodes#s%3Aextension-nodes&quot;&gt;extension nodes&lt;/a&gt; and &lt;a href=&quot;generativefunctors#s%3Agenerative-functors&quot;&gt;generative functors&lt;/a&gt;.</source>
          <target state="translated">또한 다음과 같은 언어 확장을 참조하십시오 &lt;a href=&quot;moduletypeof#s%3Amodule-type-of&quot;&gt;는 A 모듈의 유형 회복&lt;/a&gt; , &lt;a href=&quot;signaturesubstitution#s%3Asignature-substitution&quot;&gt;서명 내부의 대체&lt;/a&gt; , &lt;a href=&quot;modulealias#s%3Amodule-alias&quot;&gt;형 수준의 모듈 별명&lt;/a&gt; , &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;속성&lt;/a&gt; , &lt;a href=&quot;extensionnodes#s%3Aextension-nodes&quot;&gt;확장 노드&lt;/a&gt; 및 &lt;a href=&quot;generativefunctors#s%3Agenerative-functors&quot;&gt;생식 펑터&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e29a84ccf334151d915afcb3f2e6e7537d68cd15" translate="yes" xml:space="preserve">
          <source>See also the following language extensions: &lt;a href=&quot;privatetypes#s%3Aprivate-types&quot;&gt;private types&lt;/a&gt;, &lt;a href=&quot;gadts#s%3Agadts&quot;&gt;generalized algebraic datatypes&lt;/a&gt;, &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;attributes&lt;/a&gt;, &lt;a href=&quot;extensionnodes#s%3Aextension-nodes&quot;&gt;extension nodes&lt;/a&gt;, &lt;a href=&quot;extensiblevariants#s%3Aextensible-variants&quot;&gt;extensible variant types&lt;/a&gt; and &lt;a href=&quot;inlinerecords#s%3Ainline-records&quot;&gt;inline records&lt;/a&gt;.</source>
          <target state="translated">다음 언어 확장을 참조하십시오 : &lt;a href=&quot;privatetypes#s%3Aprivate-types&quot;&gt;개인 유형&lt;/a&gt; , &lt;a href=&quot;gadts#s%3Agadts&quot;&gt;일반화 된 대수 데이터 유형&lt;/a&gt; , &lt;a href=&quot;attributes#s%3Aattributes&quot;&gt;속성&lt;/a&gt; , &lt;a href=&quot;extensionnodes#s%3Aextension-nodes&quot;&gt;확장 노드&lt;/a&gt; , &lt;a href=&quot;extensiblevariants#s%3Aextensible-variants&quot;&gt;확장 가능한 변형 유형&lt;/a&gt; 및 &lt;a href=&quot;inlinerecords#s%3Ainline-records&quot;&gt;인라인 레코드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e968b9a4f8cf9c493b7f7b75dc2169f869275ef3" translate="yes" xml:space="preserve">
          <source>See chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; and chapter &lt;a href=&quot;runtime#c%3Aruntime&quot;&gt;11&lt;/a&gt; for more information about ocamlc and ocamlrun.</source>
          <target state="translated">ocamlc 및 ocamlrun에 대한 자세한 내용은 &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; 장 및 &lt;a href=&quot;runtime#c%3Aruntime&quot;&gt;11&lt;/a&gt; 장을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfcccc261b9612e2f14b7e419031fa265dba4cb6" translate="yes" xml:space="preserve">
          <source>See definition of type &lt;a href=&quot;format#TYPEformatter_out_functions&quot;&gt;&lt;code&gt;Format.formatter_out_functions&lt;/code&gt;&lt;/a&gt; for the meaning of argument &lt;code&gt;out_funs&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;out_funs&lt;/code&gt; 의 의미는 &lt;a href=&quot;format#TYPEformatter_out_functions&quot;&gt; &lt;code&gt;Format.formatter_out_functions&lt;/code&gt; &lt;/a&gt; 유형 정의를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5d3c6c1254d43caf08c4fc9fb0f0446b516d896" translate="yes" xml:space="preserve">
          <source>See section &lt;a href=&quot;comp#s%3Acomp-errors&quot;&gt;9.4&lt;/a&gt;.</source>
          <target state="translated">섹션 &lt;a href=&quot;comp#s%3Acomp-errors&quot;&gt;9.4를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f192eddf70c2ef4aad319edd7fbd3100374bc82" translate="yes" xml:space="preserve">
          <source>See the documentation of type &lt;code&gt;lexbuf&lt;/code&gt; for information about how the lexing engine will manage positions.</source>
          <target state="translated">렉싱 엔진이 위치를 관리하는 방법에 대한 정보는 &lt;code&gt;lexbuf&lt;/code&gt; 유형의 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="078de8e8cb0a0be314bfef55ec6a63ca5273d8c4" translate="yes" xml:space="preserve">
          <source>Seeking and truncating</source>
          <target state="translated">찾기 및 자르기</target>
        </trans-unit>
        <trans-unit id="d0d35cbfc8ed9fd20bcc34424eb4686772749654" translate="yes" xml:space="preserve">
          <source>Select a stack frame by number and describe it. The frame currently executing when the program stopped has number 0; its caller has number 1; and so on up the call stack.</source>
          <target state="translated">번호로 스택 프레임을 선택하고 설명하십시오. 프로그램이 중지되었을 때 현재 실행중인 프레임은 번호 0입니다. 발신자 번호는 1입니다. 그리고 호출 스택 위로 올라갑니다.</target>
        </trans-unit>
        <trans-unit id="8d8452dd0699a1a23b96c5aa8df33d39a7e9dbaf" translate="yes" xml:space="preserve">
          <source>Select and display the stack frame just &amp;ldquo;above&amp;rdquo; the selected frame, that is, the frame that called the selected frame. An argument says how many frames to go up.</source>
          <target state="translated">선택한 프레임, 즉 선택한 프레임을 호출 한 프레임 바로 위에 스택 프레임을 선택하고 표시합니다. 몇 개의 프레임이 올라갈 지에 대한 논쟁이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f04958a6b748a73393b1c5f640955358c4f8954c" translate="yes" xml:space="preserve">
          <source>Select and display the stack frame just &amp;ldquo;below&amp;rdquo; the selected frame, that is, the frame that was called by the selected frame. An argument says how many frames to go down.</source>
          <target state="translated">선택한 프레임, 즉 선택한 프레임에서 호출 한 프레임 바로 아래에 스택 프레임을 선택하고 표시합니다. 몇 개의 프레임이 내려갈 것인지에 대한 논쟁이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8141835065ce052c6a2b2ffe055e3f74e2c9cb62" translate="yes" xml:space="preserve">
          <source>Select whether the debugger makes checkpoints or not.</source>
          <target state="translated">디버거가 체크 포인트를 만들지 여부를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="4ee6fc3a6c80dc0fdd9a0fa5a8d6a3e707e73481" translate="yes" xml:space="preserve">
          <source>Select whether to follow the child or the parent in case of a call to fork.</source>
          <target state="translated">분기 호출의 경우 자식 또는 부모를 따를 지 여부를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="9951163a39424a7abbbc84b6339ca822c1c0c3ff" translate="yes" xml:space="preserve">
          <source>Select whether to stop after loading new code.</source>
          <target state="translated">새 코드를로드 한 후 중지할지 여부를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="18235832d8dac1ddcfbe78e75d7c4f1ed339c2fa" translate="yes" xml:space="preserve">
          <source>Self type cannot be a closed object type, so that the class remains extensible.</source>
          <target state="translated">자체 유형은 닫힌 객체 유형이 될 수 없으므로 클래스가 확장 가능한 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="5113dee834dec087ca084bd3afde0c50a62cefa1" translate="yes" xml:space="preserve">
          <source>Semantic actions are arbitrary OCaml expressions, that are evaluated to produce the semantic attribute attached to the defined nonterminal. The semantic actions can access the semantic attributes of the symbols in the right-hand side of the rule with the &lt;code&gt;$&lt;/code&gt; notation: &lt;code&gt;$1&lt;/code&gt; is the attribute for the first (leftmost) symbol, &lt;code&gt;$2&lt;/code&gt; is the attribute for the second symbol, etc.</source>
          <target state="translated">시맨틱 조치는 정의 된 비 터미널에 첨부 된 시맨틱 속성을 생성하기 위해 평가되는 임의의 OCaml 표현식입니다. 시맨틱 액션은 &lt;code&gt;$&lt;/code&gt; 표기법 을 사용하여 규칙의 오른쪽에있는 기호의 시맨틱 속성에 액세스 할 수 있습니다 . &lt;code&gt;$1&lt;/code&gt; 은 첫 번째 (가장 왼쪽) 기호에 대한 속성 이고 &lt;code&gt;$2&lt;/code&gt; 는 두 번째 기호에 대한 속성입니다.</target>
        </trans-unit>
        <trans-unit id="8a1392c344896296c101306a21e132080b369fb8" translate="yes" xml:space="preserve">
          <source>Semantic tag operations may be set on or off with &lt;a href=&quot;format#VALset_tags&quot;&gt;&lt;code&gt;Format.set_tags&lt;/code&gt;&lt;/a&gt;. Tag-marking operations may be set on or off with &lt;a href=&quot;format#VALset_mark_tags&quot;&gt;&lt;code&gt;Format.set_mark_tags&lt;/code&gt;&lt;/a&gt;. Tag-printing operations may be set on or off with &lt;a href=&quot;format#VALset_print_tags&quot;&gt;&lt;code&gt;Format.set_print_tags&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시맨틱 태그 작업은 &lt;a href=&quot;format#VALset_tags&quot;&gt; &lt;code&gt;Format.set_tags&lt;/code&gt; 를 사용&lt;/a&gt; 하여 설정하거나 해제 할 수 있습니다 . 태그 표시 작업은 &lt;a href=&quot;format#VALset_mark_tags&quot;&gt; &lt;code&gt;Format.set_mark_tags&lt;/code&gt; 를 사용&lt;/a&gt; 하여 설정하거나 해제 할 수 있습니다 . 태그 인쇄 작업은 &lt;a href=&quot;format#VALset_print_tags&quot;&gt; &lt;code&gt;Format.set_print_tags&lt;/code&gt; &lt;/a&gt; 로 설정하거나 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1190d7996932cb0ed68afaf24a43b49448d1e5f" translate="yes" xml:space="preserve">
          <source>Semantic tags</source>
          <target state="translated">시맨틱 태그</target>
        </trans-unit>
        <trans-unit id="794f749100510e2d53794fd5fc728f8ca18cb7c3" translate="yes" xml:space="preserve">
          <source>Send a break condition on the given file descriptor.</source>
          <target state="translated">주어진 파일 설명자에 중단 조건을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="63d09c8723edfdef0a4a50d0f35d4d918ef4e469" translate="yes" xml:space="preserve">
          <source>Send a break condition on the given file descriptor. The second argument is the duration of the break, in 0.1s units; 0 means standard duration (0.25s).</source>
          <target state="translated">주어진 파일 설명자에 중단 조건을 보냅니다. 두 번째 인수는 휴식 시간 (0.1 초 단위)입니다. 0은 표준 지속 시간 (0.25 초)을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7c756d9c6312c8e89151799f61dfa59089e8683c" translate="yes" xml:space="preserve">
          <source>Send data over a connected socket.</source>
          <target state="translated">연결된 소켓을 통해 데이터를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="9e1fd933b74ca801a025dc26097da110a2f1aad5" translate="yes" xml:space="preserve">
          <source>Send data over an unconnected socket.</source>
          <target state="translated">연결되지 않은 소켓을 통해 데이터를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="0d4346390f1e8fcea53c881ce751b35f83eab1e2" translate="yes" xml:space="preserve">
          <source>Send function closures</source>
          <target state="translated">함수 클로저 보내기</target>
        </trans-unit>
        <trans-unit id="fa328f49b32e6dbe61c90ab9a659303e1d388d15" translate="yes" xml:space="preserve">
          <source>Seq</source>
          <target state="translated">Seq</target>
        </trans-unit>
        <trans-unit id="5c8f4e0e1a2281faf562976c2410f76c3d8fbc95" translate="yes" xml:space="preserve">
          <source>Sequence</source>
          <target state="translated">Sequence</target>
        </trans-unit>
        <trans-unit id="df4c406a13049baa1ab0e76a8f8df17494a4f5fc" translate="yes" xml:space="preserve">
          <source>Sequenced packets socket</source>
          <target state="translated">시퀀스 된 패킷 소켓</target>
        </trans-unit>
        <trans-unit id="6bbd522eaa45c773d474dd7812f92e43182cca64" translate="yes" xml:space="preserve">
          <source>Sequences of &amp;ldquo;operator characters&amp;rdquo;, such as &amp;lt;=&amp;gt; or !!, are read as a single token from the &lt;a href=&quot;#infix-symbol&quot;&gt;infix-symbol&lt;/a&gt; or &lt;a href=&quot;#prefix-symbol&quot;&gt;prefix-symbol&lt;/a&gt; class. These symbols are parsed as prefix and infix operators inside expressions, but otherwise behave like normal identifiers.</source>
          <target state="translated">&amp;lt;=&amp;gt; 또는 !!와 같은 &quot;연산자 문자&quot;시퀀스는 &lt;a href=&quot;#infix-symbol&quot;&gt;infix-symbol&lt;/a&gt; 또는 &lt;a href=&quot;#prefix-symbol&quot;&gt;prefix-symbol&lt;/a&gt; 클래스 에서 단일 토큰으로 읽습니다 . 이러한 기호는 표현식 내에서 접두사 및 중위 연산자로 구문 분석되지만 그렇지 않으면 일반 식별자처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b199937d4e88abb4b12f2d98e271f5e0b4e49d03" translate="yes" xml:space="preserve">
          <source>Serialization functions are attached to the custom blocks to which they apply. Obviously, deserialization functions cannot be attached this way, since the custom block does not exist yet when deserialization begins! Thus, the struct custom_operations that contain deserialization functions must be registered with the deserializer in advance, using the register_custom_operations function declared in &amp;lt;caml/custom.h&amp;gt;. Deserialization proceeds by reading the identifier off the input stream, allocating a custom block of the size specified in the input stream, searching the registered struct custom_operation blocks for one with the same identifier, and calling its deserialize function to fill the data part of the custom block.</source>
          <target state="translated">직렬화 함수는 적용되는 사용자 지정 블록에 연결됩니다. 분명히 deserialization이 시작될 때 사용자 지정 블록이 아직 존재하지 않기 때문에 deserialization 함수는 이러한 방식으로 연결할 수 없습니다! 따라서 deserialization 함수를 포함하는 struct custom_operations는 &amp;lt;caml / custom.h&amp;gt;에 선언 된 register_custom_operations 함수를 사용하여 사전에 deserializer에 등록되어야합니다. 역 직렬화는 입력 스트림에서 식별자를 읽고, 입력 스트림에 지정된 크기의 사용자 지정 블록을 할당하고, 등록 된 구조체 custom_operation 블록에서 동일한 식별자를 가진 블록을 검색하고, deserialize 함수를 호출하여 사용자 지정의 데이터 부분을 채우는 방식으로 진행됩니다. 블록.</target>
        </trans-unit>
        <trans-unit id="448ab73ba1c21e671e218fb91f2644c834f0c16f" translate="yes" xml:space="preserve">
          <source>Set</source>
          <target state="translated">Set</target>
        </trans-unit>
        <trans-unit id="5f794630188a70bb0410585f48c66ba173e50bf0" translate="yes" xml:space="preserve">
          <source>Set a breakpoint at code address frag:pc. The integer frag is the identifier of a code fragment, a set of modules that have been loaded at once, either initially or with the Dynlink module. The integer pc is the instruction counter within this code fragment. If frag is omitted, it defaults to 0, which is the code fragment of the program loaded initially.</source>
          <target state="translated">코드 주소 frag : pc에 중단 점을 설정합니다. 정수 조각은 초기에 또는 Dynlink 모듈과 함께 한 번에로드 된 모듈 집합 인 코드 조각의 식별자입니다. 정수 pc는이 코드 조각 내의 명령어 카운터입니다. frag가 생략되면 기본값은 0으로 초기에로드 된 프로그램의 코드 조각입니다.</target>
        </trans-unit>
        <trans-unit id="f67fd0c07eb651e26b3507b50bb26fc61d911351" translate="yes" xml:space="preserve">
          <source>Set a breakpoint at the beginning of function. This works only when the functional value of the identifier function has been computed and assigned to the identifier. Hence this command cannot be used at the very beginning of the program execution, when all identifiers are still undefined; use gototime to advance execution until the functional value is available.</source>
          <target state="translated">함수 시작 부분에 중단 점을 설정합니다. 이것은 식별자 함수의 기능적 값이 계산되고 식별자에 할당 된 경우에만 작동합니다. 따라서이 명령은 모든 식별자가 아직 정의되지 않은 프로그램 실행 초기에 사용할 수 없습니다. 함수 값을 사용할 수있을 때까지 실행을 진행하려면 gototime을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dcc5e402aac9a8ffa33b3c043b2fbbddc6771b37" translate="yes" xml:space="preserve">
          <source>Set a breakpoint at the current position in the program execution. The current position must be on an event (i.e., neither at the beginning, nor at the end of the program).</source>
          <target state="translated">프로그램 실행의 현재 위치에 중단 점을 설정합니다. 현재 위치는 이벤트에 있어야합니다 (즉, 프로그램의 시작 부분이나 끝 부분이 아님).</target>
        </trans-unit>
        <trans-unit id="2e4aa9eedb69d42da9d6668e8997f4aad5c09196" translate="yes" xml:space="preserve">
          <source>Set a breakpoint in module module (or in the current module if module is not given), at the event closest to line line, column column.</source>
          <target state="translated">줄 줄, 열 열에 가장 가까운 이벤트에서 모듈 모듈 (또는 모듈이 지정되지 않은 경우 현재 모듈)에 중단 점을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="4310fb9d3477018a1c35b651ff34434bb6935cce" translate="yes" xml:space="preserve">
          <source>Set a breakpoint in module module (or in the current module if module is not given), at the first event of line line.</source>
          <target state="translated">줄 줄의 첫 번째 이벤트에서 모듈 모듈 (또는 모듈이 지정되지 않은 경우 현재 모듈)에 중단 점을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e277ccf247de560e48662efb52ccdfd1595175a9" translate="yes" xml:space="preserve">
          <source>Set a breakpoint in module module at the event closest to character number character.</source>
          <target state="translated">문자 번호 문자에 가장 가까운 이벤트에서 모듈 모듈에 중단 점을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="41542810756d3748a80cb8b0e04eaa0f786f07fc" translate="yes" xml:space="preserve">
          <source>Set address to ``any'' address for use with &lt;a href=&quot;unix#VALbind&quot;&gt;&lt;code&gt;Unix.bind&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;unix#VALbind&quot;&gt; &lt;code&gt;Unix.bind&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 주소를``임의의 ''주소로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="d4768fb4642e9409d9ee6be09ebc15a97d8bef70" translate="yes" xml:space="preserve">
          <source>Set aggressiveness of inlining to n, where n is a positive integer. Specifying -inline 0 prevents all functions from being inlined, except those whose body is smaller than the call site. Thus, inlining causes no expansion in code size. The default aggressiveness, -inline 1, allows slightly larger functions to be inlined, resulting in a slight expansion in code size. Higher values for the -inline option cause larger and larger functions to become candidate for inlining, but can result in a serious increase in code size.</source>
          <target state="translated">인라인의 강도를 n으로 설정합니다. 여기서 n은 양의 정수입니다. -inline 0을 지정하면 본문이 호출 사이트보다 작은 함수를 제외한 모든 함수가 인라인되지 않습니다. 따라서 인라인으로 인해 코드 크기가 확장되지 않습니다. 기본 공격성 인 -inline 1은 약간 더 큰 함수를 인라인 할 수있게하여 코드 크기가 약간 확장됩니다. -inline 옵션의 값이 높을수록 더 크고 더 큰 함수가 인라인 대상이되지만 코드 크기가 크게 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d700f315433099cdc0af2bac288d1f008cfe4955" translate="yes" xml:space="preserve">
          <source>Set all elements of a Bigarray to a given value.</source>
          <target state="translated">Bigarray의 모든 요소를 ​​주어진 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="29c906b1b0c5c8936b5e14c8bc5cc977d6cb17aa" translate="yes" xml:space="preserve">
          <source>Set all elements of a Bigarray to a given value. &lt;code&gt;Genarray.fill&amp;nbsp;a&amp;nbsp;v&lt;/code&gt; stores the value &lt;code&gt;v&lt;/code&gt; in all elements of the Bigarray &lt;code&gt;a&lt;/code&gt;. Setting only some elements of &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt; can be achieved by applying &lt;code&gt;Genarray.fill&lt;/code&gt; to a sub-array or a slice of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Bigarray의 모든 요소를 ​​주어진 값으로 설정합니다. &lt;code&gt;Genarray.fill&amp;nbsp;a&amp;nbsp;v&lt;/code&gt; 저장 께 값 &lt;code&gt;v&lt;/code&gt; Bigarray의 모든 요소 . 단지 일부 요소 설정 에 &lt;code&gt;v&lt;/code&gt; 함으로써 달성 될 수 &lt;code&gt;Genarray.fill&lt;/code&gt; 를 서브 어레이 또는 슬라이스로 . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d867b8f186c18471e57de3ac1801d69260d1c58e" translate="yes" xml:space="preserve">
          <source>Set difference: &lt;code&gt;diff&amp;nbsp;s1&amp;nbsp;s2&lt;/code&gt; contains the elements of &lt;code&gt;s1&lt;/code&gt; that are not in &lt;code&gt;s2&lt;/code&gt;.</source>
          <target state="translated">집합 차이 : &lt;code&gt;diff&amp;nbsp;s1&amp;nbsp;s2&lt;/code&gt; 의 요소가 포함 &lt;code&gt;s1&lt;/code&gt; 에없는 &lt;code&gt;s2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39d01c4f837c63566e016e072eadb650b0fec4af" translate="yes" xml:space="preserve">
          <source>Set filename in the initial tracked position to &lt;code&gt;file&lt;/code&gt; in &lt;code&gt;lexbuf&lt;/code&gt;.</source>
          <target state="translated">초기 추적 위치의 파일 이름을 &lt;code&gt;lexbuf&lt;/code&gt; 의 &lt;code&gt;file&lt;/code&gt; 로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="fa5595845e5f6e6fe2aeae20fa1474b57ec66014" translate="yes" xml:space="preserve">
          <source>Set intersection.</source>
          <target state="translated">교차로를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="a0b352005cac28824fa150d78f1cbfd0124f0743" translate="yes" xml:space="preserve">
          <source>Set or clear a boolean-valued option in the given socket.</source>
          <target state="translated">주어진 소켓에서 부울 값 옵션을 설정하거나 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="559666fe411d68ab6d59bfe3e574adcc245f6007" translate="yes" xml:space="preserve">
          <source>Set the ``close-on-exec'' flag on the given descriptor.</source>
          <target state="translated">주어진 설명자에``close-on-exec ''플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2c6db1debac2e11f674310c3d33dc2aa64f573ad" translate="yes" xml:space="preserve">
          <source>Set the ``close-on-exec'' flag on the given descriptor. A descriptor with the close-on-exec flag is automatically closed when the current process starts another program with one of the &lt;code&gt;exec&lt;/code&gt; functions.</source>
          <target state="translated">주어진 설명자에``close-on-exec ''플래그를 설정합니다. close-on-exec 플래그가있는 설명자는 현재 프로세스가 &lt;code&gt;exec&lt;/code&gt; 함수 중 하나를 사용하여 다른 프로그램을 시작할 때 자동으로 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="3be7a3e35944da3c67cba65625d93fe03af274e4" translate="yes" xml:space="preserve">
          <source>Set the ``close-on-exec'' flag on the given descriptor. A descriptor with the close-on-exec flag is automatically closed when the current process starts another program with one of the &lt;code&gt;exec&lt;/code&gt;, &lt;code&gt;create_process&lt;/code&gt; and &lt;code&gt;open_process&lt;/code&gt; functions.</source>
          <target state="translated">주어진 설명자에``close-on-exec ''플래그를 설정합니다. close-on-exec 플래그가있는 설명자는 현재 프로세스가 &lt;code&gt;exec&lt;/code&gt; , &lt;code&gt;create_process&lt;/code&gt; 및 &lt;code&gt;open_process&lt;/code&gt; 함수 중 하나로 다른 프로그램을 시작할 때 자동으로 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="7ffc9d4f7d54313e28aea022cdafcbd43fe7d38b" translate="yes" xml:space="preserve">
          <source>Set the ``non-blocking'' flag on the given descriptor.</source>
          <target state="translated">주어진 설명자에``비 차단 ''플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6a81fdf519c1d5d613550e22c6593e795e28ca60" translate="yes" xml:space="preserve">
          <source>Set the ``non-blocking'' flag on the given descriptor. When the non-blocking flag is set, reading on a descriptor on which there is temporarily no data available raises the &lt;code&gt;EAGAIN&lt;/code&gt; or &lt;code&gt;EWOULDBLOCK&lt;/code&gt; error instead of blocking; writing on a descriptor on which there is temporarily no room for writing also raises &lt;code&gt;EAGAIN&lt;/code&gt; or &lt;code&gt;EWOULDBLOCK&lt;/code&gt;.</source>
          <target state="translated">주어진 설명자에``비 차단 ''플래그를 설정합니다. 비 차단 플래그가 설정된 경우 일시적으로 사용 가능한 데이터가없는 디스크립터를 읽으면 차단 대신 &lt;code&gt;EAGAIN&lt;/code&gt; 또는 &lt;code&gt;EWOULDBLOCK&lt;/code&gt; 오류가 발생합니다. 일시적으로 쓸 여지가없는 디스크립터에 쓰면 &lt;code&gt;EAGAIN&lt;/code&gt; 또는 &lt;code&gt;EWOULDBLOCK&lt;/code&gt; 이 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="0a189281e8ddbee43149f8636d4156e072b23d1e" translate="yes" xml:space="preserve">
          <source>Set the behavior of the system on receipt of a given signal.</source>
          <target state="translated">주어진 신호를 수신 할 때 시스템의 동작을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7401aa97a51a58a6184a906cd8b63d767fe0cfb2" translate="yes" xml:space="preserve">
          <source>Set the behavior of the system on receipt of a given signal. The first argument is the signal number. Return the behavior previously associated with the signal. If the signal number is invalid (or not available on your system), an &lt;code&gt;Invalid_argument&lt;/code&gt; exception is raised.</source>
          <target state="translated">주어진 신호를 수신 할 때 시스템의 동작을 설정합니다. 첫 번째 인수는 신호 번호입니다. 이전에 신호와 관련된 동작을 반환합니다. 신호 번호가 유효하지 않거나 시스템에서 사용할 수없는 경우 &lt;code&gt;Invalid_argument&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d28cff793cc4c826a5938c2cae37dba2b6187746" translate="yes" xml:space="preserve">
          <source>Set the close-on-exec flag on the descriptor returned by &lt;a href=&quot;unix#VALopenfile&quot;&gt;&lt;code&gt;Unix.openfile&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt;&lt;code&gt;Unix.set_close_on_exec&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopenfile&quot;&gt; &lt;code&gt;Unix.openfile&lt;/code&gt; 이&lt;/a&gt; 반환 한 설명자에 close-on-exec 플래그를 설정합니다 . 자세한 내용은 &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt; &lt;code&gt;Unix.set_close_on_exec&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="923fd2bd40692f311e28beeef94b004d48a2ef9a" translate="yes" xml:space="preserve">
          <source>Set the close-on-exec flag on the descriptor returned by &lt;a href=&quot;unixlabels#VALopenfile&quot;&gt;&lt;code&gt;UnixLabels.openfile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALopenfile&quot;&gt; &lt;code&gt;UnixLabels.openfile&lt;/code&gt; 에서&lt;/a&gt; 반환 한 설명자에 close-on-exec 플래그를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="577e0abb1a0491dac220bc63e2e1bf990b7b538e" translate="yes" xml:space="preserve">
          <source>Set the current position for a file descriptor, and return the resulting offset (from the beginning of the file).</source>
          <target state="translated">파일 설명 자의 현재 위치를 설정하고 결과 오프셋 (파일 시작부터)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2b69e933a718d8f6ef580a6e4c89ad941663652b" translate="yes" xml:space="preserve">
          <source>Set the debugger variable variable to the value value.</source>
          <target state="translated">디버거 변수 변수를 값 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c8dfbcd023f476a67f43c27904c2b7ceb6809b74" translate="yes" xml:space="preserve">
          <source>Set the initial tracked input position for &lt;code&gt;lexbuf&lt;/code&gt; to a custom value.</source>
          <target state="translated">&lt;code&gt;lexbuf&lt;/code&gt; 에 대한 초기 추적 입력 위치를 사용자 지정 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="cd6edebbdfc394070896b55f61daf11e0964398b" translate="yes" xml:space="preserve">
          <source>Set the initial tracked input position for &lt;code&gt;lexbuf&lt;/code&gt; to a custom value. Ignores &lt;code&gt;pos_fname&lt;/code&gt;. See &lt;a href=&quot;lexing#VALset_filename&quot;&gt;&lt;code&gt;Lexing.set_filename&lt;/code&gt;&lt;/a&gt; for changing this field.</source>
          <target state="translated">&lt;code&gt;lexbuf&lt;/code&gt; 에 대한 초기 추적 입력 위치를 사용자 지정 값으로 설정합니다. &lt;code&gt;pos_fname&lt;/code&gt; 무시합니다 . 이 필드를 변경 &lt;a href=&quot;lexing#VALset_filename&quot;&gt; &lt;code&gt;Lexing.set_filename&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="66e946e49b39fb11e9ad3eafab1ed3bf7031c2fc" translate="yes" xml:space="preserve">
          <source>Set the last access time (second arg) and last modification time (third arg) for a file.</source>
          <target state="translated">파일에 대한 마지막 액세스 시간 (두 번째 인수) 및 마지막 수정 시간 (세 번째 인수)을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0801471051311b2e948d922eed12bfac0800e655" translate="yes" xml:space="preserve">
          <source>Set the last access time (second arg) and last modification time (third arg) for a file. Times are expressed in seconds from 00:00:00 GMT, Jan. 1, 1970. A time of &lt;code&gt;0.0&lt;/code&gt; is interpreted as the current time.</source>
          <target state="translated">파일에 대한 마지막 액세스 시간 (두 번째 인수) 및 마지막 수정 시간 (세 번째 인수)을 설정합니다. 시간은 1970 년 1 월 1 일 00:00:00 GMT부터 초 단위로 표시됩니다. 시간 &lt;code&gt;0.0&lt;/code&gt; 은 현재 시간으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="4a91c50ce8269242fb58be1767c73a683dd0d047" translate="yes" xml:space="preserve">
          <source>Set the last access time (second arg) and last modification time (third arg) for a file. Times are expressed in seconds from 00:00:00 GMT, Jan. 1, 1970. If both times are &lt;code&gt;0.0&lt;/code&gt;, the access and last modification times are both set to the current time.</source>
          <target state="translated">파일에 대한 마지막 액세스 시간 (두 번째 인수) 및 마지막 수정 시간 (세 번째 인수)을 설정합니다. 시간은 1970 년 1 월 1 일 00:00:00 GMT부터 초 단위로 표시됩니다. 두 시간이 모두 &lt;code&gt;0.0&lt;/code&gt; 이면 액세스 및 마지막 수정 시간이 모두 현재 시간으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="185eb91284ecd22b41ba674e1219388c6b167ef9" translate="yes" xml:space="preserve">
          <source>Set the list of compilation units that may be referenced from units that are dynamically loaded in the future to be exactly the given value.</source>
          <target state="translated">앞으로 동적으로로드되는 단위에서 참조 할 수있는 컴파일 단위 목록을 지정된 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9c4b8d871e2b2886d073bd654f1c86fb95bdb9d2" translate="yes" xml:space="preserve">
          <source>Set the maximum number of checkpoints to count. More checkpoints facilitate going far back in time, but use more memory and create more Unix processes.</source>
          <target state="translated">계산할 최대 체크 포인트 수를 설정합니다. 더 많은 체크 포인트는 시간을 거슬러 올라가는 것을 용이하게하지만 더 많은 메모리를 사용하고 더 많은 Unix 프로세스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d2f77a1c0b85caa6a763950d3c33aa375b7e0fdc" translate="yes" xml:space="preserve">
          <source>Set the maximum number of simultaneously live checkpoints to count.</source>
          <target state="translated">계산할 동시 라이브 체크 포인트의 최대 수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="09edd36e6c8e0e32ae3c9fce19236b50da00ff16" translate="yes" xml:space="preserve">
          <source>Set the name of the generated C library. ocamlmklib will generate liboutputc.so (if shared libraries are supported) and liboutputc.a. If not specified, defaults to the output name given with -o.</source>
          <target state="translated">생성 된 C 라이브러리의 이름을 설정합니다. ocamlmklib는 liboutputc.so (공유 라이브러리가 지원되는 경우) 및 liboutputc.a를 생성합니다. 지정되지 않은 경우 기본값은 -o와 함께 제공된 출력 이름입니다.</target>
        </trans-unit>
        <trans-unit id="1d7c54f201f52beadb4a8e3dc1e5a3b45dafc3f9" translate="yes" xml:space="preserve">
          <source>Set the name of the generated OCaml library. ocamlmklib will generate output.cma and/or output.cmxa. If not specified, defaults to a.</source>
          <target state="translated">생성 된 OCaml 라이브러리의 이름을 설정합니다. ocamlmklib는 output.cma 및 / 또는 output.cmxa를 생성합니다. 지정하지 않으면 기본값은 a입니다.</target>
        </trans-unit>
        <trans-unit id="cfd5bc4c54a4ee7b1ef577814ca237667f216b5c" translate="yes" xml:space="preserve">
          <source>Set the number of events between two checkpoints for long displacements.</source>
          <target state="translated">긴 변위에 대한 두 체크 포인트 사이의 이벤트 수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="2e3c679e454f616c096ddd2e445f6a7e9b0614f8" translate="yes" xml:space="preserve">
          <source>Set the number of events between two checkpoints for small displacements.</source>
          <target state="translated">작은 변위에 대한 두 체크 포인트 사이의 이벤트 수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="4312ad660e95018ad6202f57a1580edad689397c" translate="yes" xml:space="preserve">
          <source>Set the number of rows of context used for optimization during pattern matching compilation. The default value is 32. Lower values cause faster compilation, but less optimized code. This advanced option is meant for use in the event that a pattern-match-heavy program leads to significant increases in compilation time.</source>
          <target state="translated">패턴 일치 컴파일 중에 최적화에 사용되는 컨텍스트 행 수를 설정합니다. 기본값은 32입니다. 값이 낮을수록 컴파일 속도는 빨라지지만 코드 최적화는 떨어집니다. 이 고급 옵션은 패턴 일치가 많은 프로그램으로 인해 컴파일 시간이 크게 증가하는 경우에 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5dd4f19f7ee20639e18918f2bb65174f4e6a5c29" translate="yes" xml:space="preserve">
          <source>Set the process's file mode creation mask, and return the previous mask.</source>
          <target state="translated">프로세스의 파일 모드 생성 마스크를 설정하고 이전 마스크를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="04957e74200149a3abc2c9909388498556010333" translate="yes" xml:space="preserve">
          <source>Set the process's file mode creation mask, and return the previous mask. On Windows: not implemented.</source>
          <target state="translated">프로세스의 파일 모드 생성 마스크를 설정하고 이전 마스크를 반환합니다. Windows : 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="3890f58a5c4bd5d20e9bc02f64aca7a889291317" translate="yes" xml:space="preserve">
          <source>Set the program name to file.</source>
          <target state="translated">프로그램 이름을 파일로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1cdb3db725a2dc949ffdc1b6bda172d217346214" translate="yes" xml:space="preserve">
          <source>Set the real group id and effective group id for the process.</source>
          <target state="translated">프로세스에 대한 실제 그룹 ID 및 유효 그룹 ID를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="625d0b4d8c96326f0e509da591b26c3ed252acb9" translate="yes" xml:space="preserve">
          <source>Set the real group id and effective group id for the process. On Windows: not implemented.</source>
          <target state="translated">프로세스에 대한 실제 그룹 ID 및 유효 그룹 ID를 설정하십시오. Windows : 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="29eb017dd2fc17259e2110f32f4e6e52fa4c3a21" translate="yes" xml:space="preserve">
          <source>Set the real user id and effective user id for the process.</source>
          <target state="translated">프로세스에 대한 실제 사용자 ID와 유효 사용자 ID를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="3f429b536c18c7b528cbf990829dea199587106c" translate="yes" xml:space="preserve">
          <source>Set the real user id and effective user id for the process. On Windows: not implemented.</source>
          <target state="translated">프로세스에 대한 실제 사용자 ID와 유효 사용자 ID를 설정하십시오. Windows : 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="68d67a2d91d8163aa7eb4ac3fe77fae83d83888a" translate="yes" xml:space="preserve">
          <source>Set the reference to false</source>
          <target state="translated">참조를 false로 설정</target>
        </trans-unit>
        <trans-unit id="a999238e1f043ca2e3b51b9e405f032f3de38d77" translate="yes" xml:space="preserve">
          <source>Set the reference to the float argument</source>
          <target state="translated">float 인수에 대한 참조 설정</target>
        </trans-unit>
        <trans-unit id="cba5bb4a58f5debb26e8458f918a62172e0560b8" translate="yes" xml:space="preserve">
          <source>Set the reference to the int argument</source>
          <target state="translated">int 인수에 대한 참조 설정</target>
        </trans-unit>
        <trans-unit id="2a2fa91e83dd3e8725c6474fe2f0be917da3ce21" translate="yes" xml:space="preserve">
          <source>Set the reference to the string argument</source>
          <target state="translated">문자열 인수에 대한 참조 설정</target>
        </trans-unit>
        <trans-unit id="f9462a23157a2b8632f223d537a23034f8765868" translate="yes" xml:space="preserve">
          <source>Set the reference to true</source>
          <target state="translated">참조를 true로 설정</target>
        </trans-unit>
        <trans-unit id="17571cb3b69669ab030fc74c006854d56dbb61ea" translate="yes" xml:space="preserve">
          <source>Set the runtime system options and garbage collection parameters. (If OCAMLRUNPARAM is not set, CAMLRUNPARAM will be used instead.) This variable must be a sequence of parameter specifications separated by commas. A parameter specification is an option letter followed by an = sign, a decimal number (or an hexadecimal number prefixed by 0x), and an optional multiplier. The options are documented below; the last six correspond to the fields of the control record documented in &lt;a href=&quot;libref/gc&quot;&gt;Module Gc&lt;/a&gt;.</source>
          <target state="translated">런타임 시스템 옵션 및 가비지 수집 매개 변수를 설정합니다. (OCAMLRUNPARAM이 설정되지 않은 경우 CAMLRUNPARAM이 대신 사용됩니다.)이 변수는 쉼표로 구분 된 매개 변수 스펙 시퀀스 여야합니다. 매개 변수 사양은 옵션 문자 다음에 = 기호, 10 진수 (또는 0x 접두사가 붙은 16 진수) 및 선택적 승수입니다. 옵션은 아래에 설명되어 있습니다. 마지막 6 개는 &lt;a href=&quot;libref/gc&quot;&gt;모듈 Gc에&lt;/a&gt; 문서화 된 제어 레코드의 필드에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="2e70a362a30dc32ec5295b3216ee79d934141efa" translate="yes" xml:space="preserve">
          <source>Set the section number used for generated man filenames. Default is &amp;rsquo;3&amp;rsquo;.</source>
          <target state="translated">생성 된 man 파일 이름에 사용되는 섹션 번호를 설정합니다. 기본값은 '3'입니다.</target>
        </trans-unit>
        <trans-unit id="60c0bbe1c7f126d62252bc8aeeea0afb769c2016" translate="yes" xml:space="preserve">
          <source>Set the size of the execution history.</source>
          <target state="translated">실행 이력의 크기를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="3a7116e6d97ed745df00bb2d437dbdaa0874a881" translate="yes" xml:space="preserve">
          <source>Set the state of the generator used by the basic functions.</source>
          <target state="translated">기본 기능에서 사용하는 생성기의 상태를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f9735d601f636e8000a577f96f90a54dec7a9320" translate="yes" xml:space="preserve">
          <source>Set the status of the terminal referred to by the given file descriptor.</source>
          <target state="translated">주어진 파일 설명자가 참조하는 터미널의 상태를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="0ef0ceaca247026faede9fe880785cde60d386d3" translate="yes" xml:space="preserve">
          <source>Set the status of the terminal referred to by the given file descriptor. The second argument indicates when the status change takes place: immediately (&lt;code&gt;TCSANOW&lt;/code&gt;), when all pending output has been transmitted (&lt;code&gt;TCSADRAIN&lt;/code&gt;), or after flushing all input that has been received but not read (&lt;code&gt;TCSAFLUSH&lt;/code&gt;). &lt;code&gt;TCSADRAIN&lt;/code&gt; is recommended when changing the output parameters; &lt;code&gt;TCSAFLUSH&lt;/code&gt;, when changing the input parameters.</source>
          <target state="translated">주어진 파일 설명자가 참조하는 터미널의 상태를 설정합니다. 두 번째 인수는 상태 변경이 발생하는시기를 나타냅니다. 즉시 ( &lt;code&gt;TCSANOW&lt;/code&gt; ), 보류중인 모든 출력이 전송 된 경우 ( &lt;code&gt;TCSADRAIN&lt;/code&gt; ) 또는 수신되었지만 읽지 않은 모든 입력을 플러시 한 후 ( &lt;code&gt;TCSAFLUSH&lt;/code&gt; ). &lt;code&gt;TCSADRAIN&lt;/code&gt; 은 출력 매개 변수를 변경할 때 권장됩니다. &lt;code&gt;TCSAFLUSH&lt;/code&gt; , 입력 매개 변수를 변경할 때.</target>
        </trans-unit>
        <trans-unit id="4f19583658e227b08c0063b0ee48f99dc946e688" translate="yes" xml:space="preserve">
          <source>Set the suffix used for generated man filenames. Default is &amp;rsquo;3o&amp;rsquo;, as in List.3o.</source>
          <target state="translated">생성 된 man 파일 이름에 사용되는 접미사를 설정합니다. 기본값은 List.3o에서와 같이 '3o'입니다.</target>
        </trans-unit>
        <trans-unit id="ce3de3c8737b8c685ff7d7d5183a0ae5a23b5a07" translate="yes" xml:space="preserve">
          <source>Set the text of the ellipsis printed when too many pretty-printing boxes are open (a single dot, &lt;code&gt;.&lt;/code&gt;, by default).</source>
          <target state="translated">예쁜 인쇄 상자가 너무 많이 열려있을 때 인쇄되는 줄임표의 텍스트를 설정합니다 ( 기본적으로 단일 점, &lt;code&gt;.&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="31f21a3553861b0bc4c154c47440c25cf06db10d" translate="yes" xml:space="preserve">
          <source>Set the working directory for ocamldebug to directory.</source>
          <target state="translated">ocamldebug의 작업 디렉토리를 directory로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8640d7d98c95569c8a27941f1cceb667e63daf27" translate="yes" xml:space="preserve">
          <source>Set union.</source>
          <target state="translated">조합을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="015294ab9557093ab8ef3f4758adf636f86f2699" translate="yes" xml:space="preserve">
          <source>Set up a socket for receiving connection requests.</source>
          <target state="translated">연결 요청을 받기위한 소켓을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="126c2a22413412e2612fe5d80353e96755c171d4" translate="yes" xml:space="preserve">
          <source>Set up a socket for receiving connection requests. The integer argument is the maximal number of pending requests.</source>
          <target state="translated">연결 요청을 받기위한 소켓을 설정합니다. 정수 인수는 보류중인 요청의 최대 수입니다.</target>
        </trans-unit>
        <trans-unit id="d0e061c96cfcc2740e44edf97c61308d74477a19" translate="yes" xml:space="preserve">
          <source>Sets a tabulation marker at current insertion point.</source>
          <target state="translated">현재 삽입 지점에 표 표시자를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="5ba802095863c730620b6e522ab417b749d4c61a" translate="yes" xml:space="preserve">
          <source>Sets over ordered types.</source>
          <target state="translated">주문 된 유형에 대해 설정합니다.</target>
        </trans-unit>
        <trans-unit id="fb449f71834cd30ec14d00c9d50ba85c232186d3" translate="yes" xml:space="preserve">
          <source>Setting</source>
          <target state="translated">Setting</target>
        </trans-unit>
        <trans-unit id="b8f0cdd8935e519ffb7f3404fbd0cd7cd5f6ab79" translate="yes" xml:space="preserve">
          <source>Setting the OCAML_SPACETIME_INTERVAL environment variable to an integer representing a number of milliseconds before running a program built with Spacetime will cause memory profiling to be in operation when the program is started. The contents of the OCaml heap will be sampled each time the number of milliseconds that the program has spent executing since the last sample exceeds the given number. (Note that the time base is combined user plus system time&amp;mdash;&lt;em&gt;not&lt;/em&gt; wall clock time. This peculiarity may be changed in future.)</source>
          <target state="translated">OCAML_SPACETIME_INTERVAL 환경 변수를 Spacetime으로 빌드 된 프로그램을 실행하기 전에 밀리 초 수를 나타내는 정수로 설정하면 프로그램이 시작될 때 메모리 프로파일 링이 작동하게됩니다. OCaml 힙의 내용은 마지막 샘플이 주어진 수를 초과 한 이후 프로그램이 실행하는 데 걸린 시간 (밀리 초)이 매번 샘플링됩니다. (시간축은 벽시계 시간이 &lt;em&gt;아니라&lt;/em&gt; 사용자와 시스템 시간을 결합한 것입니다.이 특성은 향후 변경 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="3d67b0d686985163b75cc6f60585023872675c7a" translate="yes" xml:space="preserve">
          <source>Several variables enables to fine-tune the debugger. Reasonable defaults are provided, and you should normally not have to change them.</source>
          <target state="translated">여러 변수를 사용하여 디버거를 미세 조정할 수 있습니다. 합리적인 기본값이 제공되며 일반적으로 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d7da9bae4232e30381e9ccc7d82a3d3dff0749c5" translate="yes" xml:space="preserve">
          <source>Shared ownership: the data has several owners, that may only access it, not mutate it.</source>
          <target state="translated">공유 소유권 : 데이터에는 여러 소유자가 있으며, 데이터에 액세스 만 할 수 있으며 변경은 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8fc300b3858ae9ce2ba85a4fe2dd0789623bd15b" translate="yes" xml:space="preserve">
          <source>Should the inliner prove recalcitrant and refuse to inline a particular function, or if the observed inlining decisions are not to the programmer&amp;rsquo;s satisfaction for some other reason, inlining behaviour can be dictated by the programmer directly in the source code. One example where this might be appropriate is when the programmer, but not the compiler, knows that a particular function call is on a cold code path. It might be desirable to prevent inlining of the function so that the code size along the hot path is kept smaller, so as to increase locality.</source>
          <target state="translated">인라이너가 난해한 것으로 판명되고 특정 기능의 인라인을 거부하거나 관찰 된 인라인 결정이 다른 이유로 프로그래머의 만족에 맞지 않는 경우 소스 코드에서 프로그래머가 직접 인라인 동작을 지시 할 수 있습니다. 이것이 적절할 수있는 한 가지 예는 컴파일러가 아닌 프로그래머가 특정 함수 호출이 콜드 코드 경로에 있음을 알고있는 경우입니다. 지역성을 높이기 위해 핫 경로를 따라 코드 크기를 더 작게 유지하도록 함수의 인라인을 방지하는 것이 바람직 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51d5c1d2533d4a222462ad94a689b7cce34101e0" translate="yes" xml:space="preserve">
          <source>Show absolute filenames in error messages.</source>
          <target state="translated">오류 메시지에 절대 파일 이름을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="fb7362c779f885975ff09e3a25bc5897262fab3f" translate="yes" xml:space="preserve">
          <source>Show the description of all available warning numbers.</source>
          <target state="translated">사용 가능한 모든 경고 번호에 대한 설명을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="f4ca6694d54dd6489a83d8b39f9d9cd98963cbec" translate="yes" xml:space="preserve">
          <source>Shutdown a socket connection.</source>
          <target state="translated">소켓 연결을 종료합니다.</target>
        </trans-unit>
        <trans-unit id="9c8a4815f67ac9a7d69bff16d4ed5655a6b6b3be" translate="yes" xml:space="preserve">
          <source>Shutdown a socket connection. &lt;code&gt;SHUTDOWN_SEND&lt;/code&gt; as second argument causes reads on the other end of the connection to return an end-of-file condition. &lt;code&gt;SHUTDOWN_RECEIVE&lt;/code&gt; causes writes on the other end of the connection to return a closed pipe condition (&lt;code&gt;SIGPIPE&lt;/code&gt; signal).</source>
          <target state="translated">소켓 연결을 종료합니다. &lt;code&gt;SHUTDOWN_SEND&lt;/code&gt; 를 두 번째 인수로 사용하면 연결의 다른 쪽 끝에서 읽기가 파일 끝 조건을 반환합니다. &lt;code&gt;SHUTDOWN_RECEIVE&lt;/code&gt; 는 연결의 다른 쪽 끝에서 쓰기가 닫힌 파이프 상태 ( &lt;code&gt;SIGPIPE&lt;/code&gt; 신호) 를 반환하도록 합니다.</target>
        </trans-unit>
        <trans-unit id="43d6f2a50d9070ba8af0bf2249d46f60014587a0" translate="yes" xml:space="preserve">
          <source>Signal an error during deserialization; input_value or Marshal.from_... raise a Failure exception after cleaning up their internal data structures</source>
          <target state="translated">역 직렬화 중에 오류 신호를 보냅니다. input_value 또는 Marshal.from _...은 내부 데이터 구조를 정리 한 후 실패 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="dda1c34f3e7ae5e716370d772211709548003ec4" translate="yes" xml:space="preserve">
          <source>Signal handling</source>
          <target state="translated">신호 처리</target>
        </trans-unit>
        <trans-unit id="9e415b59d5f90a505f7744e1ba6f59f0f4039873" translate="yes" xml:space="preserve">
          <source>Signal handling follows the POSIX thread model: signals generated by a thread are delivered to that thread; signals generated externally are delivered to one of the threads that does not block it. Each thread possesses a set of blocked signals, which can be modified using &lt;a href=&quot;thread#VALsigmask&quot;&gt;&lt;code&gt;Thread.sigmask&lt;/code&gt;&lt;/a&gt;. This set is inherited at thread creation time. Per-thread signal masks are supported only by the system thread library under Unix, but not under Win32, nor by the VM thread library.</source>
          <target state="translated">신호 처리는 POSIX 스레드 모델을 따릅니다. 스레드에서 생성 된 신호는 해당 스레드로 전달됩니다. 외부에서 생성 된 신호는이를 차단하지 않는 스레드 중 하나로 전달됩니다. 각 스레드에는 차단 된 신호 세트가 있으며 &lt;a href=&quot;thread#VALsigmask&quot;&gt; &lt;code&gt;Thread.sigmask&lt;/code&gt; 를&lt;/a&gt; 사용하여 수정할 수 있습니다 . 이 세트는 스레드 생성시 상속됩니다. 스레드 별 신호 마스크는 Unix의 시스템 스레드 라이브러리에서만 지원되며 Win32 또는 VM 스레드 라이브러리에서는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9311ddf008a50fe257c90a1196997c277af9ab4" translate="yes" xml:space="preserve">
          <source>Signal interrupt on break condition.</source>
          <target state="translated">중단 상태에서 신호 인터럽트.</target>
        </trans-unit>
        <trans-unit id="78f0164440d5b6c728963e4c5496d15ee0199c98" translate="yes" xml:space="preserve">
          <source>Signal numbers for the standard POSIX signals.</source>
          <target state="translated">표준 POSIX 신호에 대한 신호 번호.</target>
        </trans-unit>
        <trans-unit id="2346a18ea3002ff04eca3a130c7f40e65c56f0c9" translate="yes" xml:space="preserve">
          <source>Signals</source>
          <target state="translated">Signals</target>
        </trans-unit>
        <trans-unit id="11de8e6e96acdf7704df5910480a4dcc8fe36151" translate="yes" xml:space="preserve">
          <source>Signals are detected only when the program performs an allocation in the heap. That is, if a signal is delivered while in a piece of code that does not allocate, its handler will not be called until the next heap allocation.</source>
          <target state="translated">프로그램이 힙에서 할당을 수행하는 경우에만 신호가 감지됩니다. 즉, 할당되지 않은 코드에있는 동안 신호가 전달되면 다음 힙 할당까지 해당 핸들러가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d7b79c51a7108560360ba735396db85158b3113" translate="yes" xml:space="preserve">
          <source>Signatures are interfaces for structures. A signature specifies which components of a structure are accessible from the outside, and with which type. It can be used to hide some components of a structure (e.g. local function definitions) or export some components with a restricted type. For instance, the signature below specifies the three priority queue operations empty, insert and extract, but not the auxiliary function remove_top. Similarly, it makes the queue type abstract (by not providing its actual representation as a concrete type).</source>
          <target state="translated">서명은 구조를위한 인터페이스입니다. 서명은 외부에서 액세스 할 수있는 구조의 구성 요소와 유형을 지정합니다. 구조의 일부 구성 요소 (예 : 로컬 함수 정의)를 숨기거나 제한된 유형으로 일부 구성 요소를 내보내는 데 사용할 수 있습니다. 예를 들어, 아래의 서명은 빈, 삽입 및 추출의 세 가지 우선 순위 대기열 작업을 지정하지만 보조 기능 remove_top은 지정하지 않습니다. 유사하게 큐 유형을 추상화합니다 (실제 표현을 구체적인 유형으로 제공하지 않음).</target>
        </trans-unit>
        <trans-unit id="0799b1c5b5c705ede3db466efc79912f2251c444" translate="yes" xml:space="preserve">
          <source>Signatures are type specifications for structures. Signatures sig &amp;hellip; end are collections of type specifications for value names, type names, exceptions, module names and module type names. A structure will match a signature if the structure provides definitions (implementations) for all the names specified in the signature (and possibly more), and these definitions meet the type requirements given in the signature.</source>
          <target state="translated">서명은 구조에 대한 유형 사양입니다. 서명 sig&amp;hellip; end는 값 이름, 유형 이름, 예외, 모듈 이름 및 모듈 유형 이름에 대한 유형 사양 모음입니다. 구조가 서명에 지정된 모든 이름 (또는 그 이상)에 대한 정의 (구현)를 제공하고 이러한 정의가 서명에 제공된 유형 요구 사항을 충족하는 경우 구조는 서명과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c0fcf14805d5bb21d1394f6f62f3947836ae1ca6" translate="yes" xml:space="preserve">
          <source>Similar to #use but also wrap the code into a top-level module of the same name as capitalized file name without extensions, following semantics of the compiler.</source>
          <target state="translated">#use와 유사하지만 컴파일러의 의미 체계에 따라 확장명이없는 대문자 파일 이름과 동일한 이름의 최상위 모듈로 코드를 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="c76cbdc21e4b3567672c60ec1215127342f83044" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;str#VALstring_match&quot;&gt;&lt;code&gt;Str.string_match&lt;/code&gt;&lt;/a&gt;, but also returns true if the argument string is a prefix of a string that matches.</source>
          <target state="translated">&lt;a href=&quot;str#VALstring_match&quot;&gt; &lt;code&gt;Str.string_match&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 인수 문자열이 일치하는 문자열의 접두사 인 경우에도 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="06853b76b05e43df457ddfb2bcae3f857c0d6a4e" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;str#VALstring_match&quot;&gt;&lt;code&gt;Str.string_match&lt;/code&gt;&lt;/a&gt;, but also returns true if the argument string is a prefix of a string that matches. This includes the case of a true complete match.</source>
          <target state="translated">&lt;a href=&quot;str#VALstring_match&quot;&gt; &lt;code&gt;Str.string_match&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 인수 문자열이 일치하는 문자열의 접두사 인 경우에도 true를 반환합니다. 여기에는 진정한 완전 일치의 경우가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="45f29146c0b592c6ffbd18d22abb6283b786360f" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;unix#VALopen_process&quot;&gt;&lt;code&gt;Unix.open_process&lt;/code&gt;&lt;/a&gt;, but the second argument specifies the environment passed to the command.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process&quot;&gt; &lt;code&gt;Unix.open_process&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 두 번째 인수는 명령에 전달되는 환경을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5e0e701577791f5cf187fc0edb8e1fe8be2ec0ba" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;unix#VALopen_process&quot;&gt;&lt;code&gt;Unix.open_process&lt;/code&gt;&lt;/a&gt;, but the second argument specifies the environment passed to the command. The result is a triple of channels connected respectively to the standard output, standard input, and standard error of the command. If the command does not need to be run through the shell, &lt;a href=&quot;unix#VALopen_process_args_full&quot;&gt;&lt;code&gt;Unix.open_process_args_full&lt;/code&gt;&lt;/a&gt; can be used instead of &lt;a href=&quot;unix#VALopen_process_full&quot;&gt;&lt;code&gt;Unix.open_process_full&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process&quot;&gt; &lt;code&gt;Unix.open_process&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 두 번째 인수는 명령에 전달되는 환경을 지정합니다. 그 결과 명령의 표준 출력, 표준 입력 및 표준 오류에 각각 연결된 세 개의 채널이 생성됩니다. 명령 쉘을 실행할 필요가없는 경우, &lt;a href=&quot;unix#VALopen_process_args_full&quot;&gt; &lt;code&gt;Unix.open_process_args_full&lt;/code&gt; 는&lt;/a&gt; 대신 사용할 수 있습니다 &lt;a href=&quot;unix#VALopen_process_full&quot;&gt; &lt;code&gt;Unix.open_process_full&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c0b98907bce96d78dfe42a3e18fe2e7ca3ebcb5" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;unix#VALopen_process_args&quot;&gt;&lt;code&gt;Unix.open_process_args&lt;/code&gt;&lt;/a&gt;, but the third argument specifies the environment passed to the command.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process_args&quot;&gt; &lt;code&gt;Unix.open_process_args&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 세 번째 인수는 명령에 전달되는 환경을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="677334462e1ae82342d0dcb52850960bd974932a" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;unix#VALopen_process_args&quot;&gt;&lt;code&gt;Unix.open_process_args&lt;/code&gt;&lt;/a&gt;, but the third argument specifies the environment passed to the command. The result is a triple of channels connected respectively to the standard output, standard input, and standard error of the command.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_process_args&quot;&gt; &lt;code&gt;Unix.open_process_args&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 세 번째 인수는 명령에 전달되는 환경을 지정합니다. 그 결과 명령의 표준 출력, 표준 입력 및 표준 오류에 각각 연결된 세 개의 채널이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a1514fb8d353a5c12e6c485587d3a8cc11982c9e" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;unixlabels#VALopen_process&quot;&gt;&lt;code&gt;UnixLabels.open_process&lt;/code&gt;&lt;/a&gt;, but the second argument specifies the environment passed to the command.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALopen_process&quot;&gt; &lt;code&gt;UnixLabels.open_process&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 두 번째 인수는 명령에 전달되는 환경을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="41eff9ce6b4d4a58a474810a3cf22b40cb6b7bde" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;unixlabels#VALopen_process&quot;&gt;&lt;code&gt;UnixLabels.open_process&lt;/code&gt;&lt;/a&gt;, but the second argument specifies the environment passed to the command. The result is a triple of channels connected respectively to the standard output, standard input, and standard error of the command.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALopen_process&quot;&gt; &lt;code&gt;UnixLabels.open_process&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 두 번째 인수는 명령에 전달되는 환경을 지정합니다. 그 결과 명령의 표준 출력, 표준 입력 및 표준 오류에 각각 연결된 세 개의 채널이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="d313b8e52b393d5cf6147ba4249f7eca53294df8" translate="yes" xml:space="preserve">
          <source>Similarly to abstract types, the variance of type parameters is not inferred, and must be given explicitly.</source>
          <target state="translated">추상 유형과 유사하게 유형 매개 변수의 분산은 유추되지 않으며 명시 적으로 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e9ce25462976ce5eb1ef837e2ed0739d90ee5d4e" translate="yes" xml:space="preserve">
          <source>Similarly, if we have a value of type x list, we can convert it to a value of type xy list, since we could convert each element one by one:</source>
          <target state="translated">유사하게, 우리가 유형 x 목록의 값을 가지고 있다면, 우리는 각 요소를 하나씩 변환 할 수 있기 때문에 그것을 xy 목록 유형의 값으로 변환 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="d313ab9b0494c745db6b22c28b2cff11a10b496d" translate="yes" xml:space="preserve">
          <source>Similarly, it is possible to pass untagged OCaml integers between OCaml and C. This is done by annotating the arguments and/or result with [@untagged]:</source>
          <target state="translated">마찬가지로 OCaml과 C간에 태그가 지정되지 않은 OCaml 정수를 전달할 수 있습니다. 이는 인수 및 / 또는 결과에 [@untagged] 주석을 추가하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="f92741dcb5f21be8a2e70d1205e848fdf0320b01" translate="yes" xml:space="preserve">
          <source>Similarly, it may be necessary to use more than one explicitly polymorphic type variables, like for computing the nested list of list lengths of the nested list:</source>
          <target state="translated">마찬가지로, 중첩 된 목록의 목록 길이의 중첩 된 목록을 계산하는 것과 같이 명시 적으로 다형성 유형 변수를 두 개 이상 사용해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f2c5d03b5b9c8dd6ba0678a65d5351c8cd98413" translate="yes" xml:space="preserve">
          <source>Similarly, the type money2 below is not a subtype of type money.</source>
          <target state="translated">마찬가지로 아래의 money2 유형은 money 유형의 하위 유형이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c869e53520a631cc815df7228f90ac1d103f73c0" translate="yes" xml:space="preserve">
          <source>Simple break hints are:</source>
          <target state="translated">간단한 중단 힌트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0cbdf297ad58c249eb6a884743adad5ebf58ec52" translate="yes" xml:space="preserve">
          <source>Simplification, which is run in conjunction with inlining, propagates information (known as &lt;em&gt;approximations&lt;/em&gt;) about which variables hold what values at runtime. Certain relationships between variables and symbols are also tracked: for example, some variable may be known to always hold the same value as some other variable; or perhaps some variable may be known to always hold the value pointed to by some symbol.</source>
          <target state="translated">인라인과 함께 실행되는 단순화 는 어떤 변수가 런타임에 어떤 값을 보유하는지에 대한 정보 ( &lt;em&gt;근사치&lt;/em&gt; 라고 함)를 전파 합니다. 변수와 기호 사이의 특정 관계도 추적됩니다. 예를 들어, 일부 변수는 항상 다른 변수와 동일한 값을 보유하는 것으로 알려져있을 수 있습니다. 또는 어떤 변수는 어떤 기호가 가리키는 값을 항상 보유하는 것으로 알려져있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55ea8cc7a44b0c2bd5856cb347cbbb1643e7f85f" translate="yes" xml:space="preserve">
          <source>Since 4.03 it raises the more helpful message</source>
          <target state="translated">4.03 이후로 더 유용한 메시지를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="73ade97bea138f3fb9efb25ef0d7f126ecd46f02" translate="yes" xml:space="preserve">
          <source>Since 4.05, caml_shutdown function can be used to shut the runtime down gracefully, which equals the following:</source>
          <target state="translated">4.05부터 caml_shutdown 함수를 사용하여 런타임을 정상적으로 종료 할 수 있습니다. 이는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="81ba141f2bfeface334c39bbfdb23f3bb8205301" translate="yes" xml:space="preserve">
          <source>Since 4.10, allocation functions are guaranteed not to call any OCaml callbacks from C, including finalisers and signal handlers, and delay their execution instead.</source>
          <target state="translated">4.10부터 할당 함수는 종료 자 및 신호 처리기를 포함하여 C에서 OCaml 콜백을 호출하지 않고 대신 실행을 지연시킵니다.</target>
        </trans-unit>
        <trans-unit id="b82b13aad43c297f1863ddbcfef759a67cc30d99" translate="yes" xml:space="preserve">
          <source>Since OCaml 4.01, it is an error if the same method or instance variable name is defined several times in the same class body.</source>
          <target state="translated">OCaml 4.01 이후 동일한 클래스 본문에 동일한 메소드 또는 인스턴스 변수 이름을 여러 번 정의하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="be0f0ea20cac38b243eaa241996cd121a3a25b22" translate="yes" xml:space="preserve">
          <source>Since OCaml 4.01, open statements shadowing an existing identifier (which is later used) trigger the warning 44. Adding a ! character after the open keyword indicates that such a shadowing is intentional and should not trigger the warning.</source>
          <target state="translated">OCaml 4.01 이후로 기존 식별자 (나중에 사용됨)를 숨기는 열린 문은 경고 44를 트리거합니다. open 키워드 뒤의 문자는 그러한 섀도 잉이 의도적이며 경고를 트리거하지 않아야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4c19851dc798d0e9efd68333f02e9775f883e6a8" translate="yes" xml:space="preserve">
          <source>Since OCaml 4.02, it is possible to specify a refill-handler, a function that will be called when refill happens. It is passed the continuation of the lexing, on which it has total control. The OCaml expression used as refill action should have a type that is an instance of</source>
          <target state="translated">OCaml 4.02부터는 refill이 발생할 때 호출되는 함수 인 refill-handler를 지정할 수 있습니다. 그것은 완전한 통제권을 가진 어휘의 연속을 통과합니다. 보충 작업으로 사용되는 OCaml 표현식은 다음의 인스턴스 인 유형을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="703a6e0ead56321fd4ccc207048572bfb9890b37" translate="yes" xml:space="preserve">
          <source>Since OCaml 4.04, it is possible to get access to every part of the internal runtime API by defining the CAML_INTERNALS macro before loading caml header files. If this macro is not defined, parts of the internal runtime API are hidden.</source>
          <target state="translated">OCaml 4.04부터 caml 헤더 파일을로드하기 전에 CAML_INTERNALS 매크로를 정의하여 내부 런타임 API의 모든 부분에 액세스 할 수 있습니다. 이 매크로가 정의되지 않은 경우 내부 런타임 API의 일부가 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="5ef10155ca428da06ee8b6867d58296ace73ef7f" translate="yes" xml:space="preserve">
          <source>Since OCaml 4.08, it is possible to mark components (such as value or type declarations) in signatures with &amp;ldquo;alerts&amp;rdquo; that will be reported when those components are referenced. This generalizes the notion of &amp;ldquo;deprecated&amp;rdquo; components which were previously reported as warning 3. Those alerts can be used for instance to report usage of unsafe features, or of features which are only available on some platforms, etc.</source>
          <target state="translated">OCaml 4.08부터는 해당 구성 요소가 참조 될 때보고되는 &quot;경고&quot;로 서명의 구성 요소 (예 : 값 또는 유형 선언)를 표시 할 수 있습니다. 이는 이전에 경고 3으로보고 된 &quot;사용되지 않는&quot;구성 요소의 개념을 일반화합니다. 이러한 경고는 예를 들어 안전하지 않은 기능 또는 일부 플랫폼에서만 사용할 수있는 기능의 사용을보고하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fb784bd027538e4265b84b801b820609e843b9e" translate="yes" xml:space="preserve">
          <source>Since OCaml 4.09, the graphics library is distributed as an external package. Its new home is:</source>
          <target state="translated">OCaml 4.09부터 그래픽 라이브러리는 외부 패키지로 배포됩니다. 새 집은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="47910afc78d4869690c0ed5c357621b1abf65b2a" translate="yes" xml:space="preserve">
          <source>Since OCaml version 4.02, the OCamlBrowser tool and the Labltk library are distributed separately from the OCaml compiler. The project is now hosted at &lt;a href=&quot;https://forge.ocamlcore.org/projects/labltk/&quot;&gt;https://forge.ocamlcore.org/projects/labltk/&lt;/a&gt;.</source>
          <target state="translated">OCaml 버전 4.02부터 OCamlBrowser 도구 및 Labltk 라이브러리는 OCaml 컴파일러와 별도로 배포됩니다. 프로젝트는 이제 &lt;a href=&quot;https://forge.ocamlcore.org/projects/labltk/&quot;&gt;https://forge.ocamlcore.org/projects/labltk/&lt;/a&gt; 에서 호스팅됩니다 .</target>
        </trans-unit>
        <trans-unit id="85aeea25da4f851d04af97132f25d53038ece0d4" translate="yes" xml:space="preserve">
          <source>Since OCaml version 4.03, the ocamlbuild compilation manager is distributed separately from the OCaml compiler. The project is now hosted at &lt;a href=&quot;https://github.com/ocaml/ocamlbuild/&quot;&gt;https://github.com/ocaml/ocamlbuild/&lt;/a&gt;.</source>
          <target state="translated">OCaml 버전 4.03부터 ocamlbuild 컴파일 관리자는 OCaml 컴파일러와 별도로 배포됩니다. 프로젝트는 이제 &lt;a href=&quot;https://github.com/ocaml/ocamlbuild/&quot;&gt;https://github.com/ocaml/ocamlbuild/&lt;/a&gt; 에서 호스팅됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3c42e6e2c2dc841c6813ede2648ca45d6e38f24" translate="yes" xml:space="preserve">
          <source>Since Ocaml 3.12, the keywords inherit!, val! and method! have the same semantics as inherit, val and method, but they additionally require the definition they introduce to be overriding. Namely, method! requires &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; to be already defined in this class, val! requires &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; to be already defined in this class, and inherit! requires &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; to override some definitions. If no such overriding occurs, an error is signaled.</source>
          <target state="translated">Ocaml 3.12부터 키워드는 inherit !, val! 및 방법! inherit, val 및 method와 동일한 의미를 갖지만 추가로 오버라이드하기 위해 도입하는 정의가 필요합니다. 즉, 방법! 이 클래스 val!에 &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; 이 이미 정의되어 있어야합니다 . 필요 &lt;a href=&quot;names#inst-var-name&quot;&gt;VAR-이름이 INST-&lt;/a&gt; 이미 클래스 및 상속에 정의되어야한다! 일부 정의를 재정의 하려면 &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; 이 필요합니다 . 이러한 재정의가 발생하지 않으면 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b41b06211bb56a2cb0a28226137e946166598852" translate="yes" xml:space="preserve">
          <source>Since blocks are composed of several words, a block can potentially be sampled several times. If a block is sampled several times, then each of the callback is called once for each event of this block: the multiplicity is given in the &lt;code&gt;n_samples&lt;/code&gt; field of the &lt;code&gt;allocation&lt;/code&gt; structure.</source>
          <target state="translated">블록은 여러 단어로 구성되어 있으므로 블록은 잠재적으로 여러 번 샘플링 될 수 있습니다. 블록이 여러 번 샘플링되면 각 콜백은이 블록의 각 이벤트에 대해 한 번씩 호출됩니다. 다중성은 &lt;code&gt;allocation&lt;/code&gt; 구조 의 &lt;code&gt;n_samples&lt;/code&gt; 필드에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="879e48e0d81c1920490f9453989dbafc873931d1" translate="yes" xml:space="preserve">
          <source>Since the fields x and y can only appear simultaneously in the first record type, OCaml infers that the type of project_and_rotate is first_record -&amp;gt; first_record.</source>
          <target state="translated">x 및 y 필드는 첫 번째 레코드 유형에서만 동시에 나타날 수 있으므로 OCaml은 project_and_rotate 유형이 first_record-&amp;gt; first_record라고 추론합니다.</target>
        </trans-unit>
        <trans-unit id="11b5947847de732bcf3a69fffb2afbb29de82849" translate="yes" xml:space="preserve">
          <source>Since the functions have sufficiently few arguments, more specialised arguments will be added. After some simplification one obtains:</source>
          <target state="translated">함수에는 인수가 충분히 적기 때문에 더 전문화 된 인수가 추가됩니다. 몇 가지 단순화 후 다음을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="607a6de4f0d6d6061a214efa4d56f36e0fd649f8" translate="yes" xml:space="preserve">
          <source>Since the type of None is 'a option and the function ref has type 'b -&amp;gt; 'b ref, a natural deduction for the type of store would be 'a option ref. However, the inferred type, '_weak1 option ref, is different. Type variables whose name starts with a _weak prefix like '_weak1 are weakly polymorphic type variables, sometimes shortened as weak type variables. A weak type variable is a placeholder for a single type that is currently unknown. Once the specific type t behind the placeholder type '_weak1 is known, all occurrences of '_weak1 will be replaced by t. For instance, we can define another option reference and store an int inside:</source>
          <target state="translated">None의 유형은 'a 옵션이고 함수 ref의 유형은'b-&amp;gt; 'b ref이므로 저장소 유형에 대한 자연적인 추론은'a option ref. 그러나 유추 된 유형 '_weak1 옵션 참조'는 다릅니다. 이름이 '_weak1과 같이 _weak 접두사로 시작하는 유형 변수는 약한 다형성 유형 변수이며 때로는 약한 유형 변수로 축약됩니다. 약한 유형 변수는 현재 알려지지 않은 단일 유형에 대한 자리 표시 자입니다. 자리 표시 자 유형 '_weak1 뒤의 특정 유형 t가 알려지면'_weak1의 모든 항목이 t로 대체됩니다. 예를 들어, 다른 옵션 참조를 정의하고 내부에 int를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f454df85c0505167cc193264f5f21518fa34f8d9" translate="yes" xml:space="preserve">
          <source>Since the use of a return type often eliminates the need to name type parameters in the left-hand side of a type definition, one can replace them with anonymous types _ in that case.</source>
          <target state="translated">반환 유형을 사용하면 유형 정의의 왼쪽에 유형 매개 변수의 이름을 지정할 필요가없는 경우가 많으므로이 경우 익명 유형 _으로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ecba5078a243b75e15bfb04595710b711f37d53" translate="yes" xml:space="preserve">
          <source>Since there is only one case in this pattern matching, it is safe to expand directly the argument r in a record pattern:</source>
          <target state="translated">이 패턴 일치에는 케이스가 하나뿐이므로 레코드 패턴에서 인수 r을 직접 확장하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="6388c54547c979489e38f3575180f088b92eef41" translate="yes" xml:space="preserve">
          <source>Since version 3.10, redefinitions of a visible instance variable with the same name do not create a new variable, but are merged, using the last value for initialization. They must have identical types and mutability. However, if an instance variable is hidden by omitting it from an interface, it will be kept distinct from other instance variables with the same name.</source>
          <target state="translated">버전 3.10 이후, 동일한 이름을 가진 보이는 인스턴스 변수의 재정의는 새 변수를 생성하지 않고 초기화를위한 마지막 값을 사용하여 병합됩니다. 동일한 유형과 변경 가능성이 있어야합니다. 그러나 인스턴스 변수가 인터페이스에서 생략되어 숨겨지면 동일한 이름을 가진 다른 인스턴스 변수와 구별됩니다.</target>
        </trans-unit>
        <trans-unit id="cc7b7e27599e0ea9a03712ac291946d71c69a826" translate="yes" xml:space="preserve">
          <source>Sine.</source>
          <target state="translated">Sine.</target>
        </trans-unit>
        <trans-unit id="49bb3c5b34d4f790f63a5f9bea42c5d394baa7d3" translate="yes" xml:space="preserve">
          <source>Sine. Argument is in radians.</source>
          <target state="translated">사인. 인수는 라디안입니다.</target>
        </trans-unit>
        <trans-unit id="850e57a1ee5fae18b0892f2cbd53b13443f4e553" translate="yes" xml:space="preserve">
          <source>Size (in words) of the largest block in the free list.</source>
          <target state="translated">사용 가능한 목록에서 가장 큰 블록의 크기 (단어 단위).</target>
        </trans-unit>
        <trans-unit id="23aa6e811d60088ebfe23efb308861aa99dcc44c" translate="yes" xml:space="preserve">
          <source>Size in bytes</source>
          <target state="translated">크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="45cf1f454a042183408948a20c84cf3be2a96f7b" translate="yes" xml:space="preserve">
          <source>Size of &lt;code&gt;int&lt;/code&gt;, in bits.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 의 크기 ( 비트).</target>
        </trans-unit>
        <trans-unit id="8d1eb5965b0e8500bb02fadfe8d12ee828f16ead" translate="yes" xml:space="preserve">
          <source>Size of &lt;code&gt;int&lt;/code&gt;, in bits. It is 31 (resp. 63) when using OCaml on a 32-bit (resp. 64-bit) platform. It may differ for other implementations, e.g. it can be 32 bits when compiling to JavaScript.</source>
          <target state="translated">&lt;code&gt;int&lt;/code&gt; 의 크기 ( 비트). 32 비트 (각각 64 비트) 플랫폼에서 OCaml을 사용하는 경우 31 (각각 63)입니다. 다른 구현에서는 다를 수 있습니다. 예를 들어 JavaScript로 컴파일 할 때 32 비트가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="811814293c14ee9d45359fd381dbd3619cdced86" translate="yes" xml:space="preserve">
          <source>Size of one word on the machine currently executing the OCaml program, in bits: 32 or 64.</source>
          <target state="translated">현재 OCaml 프로그램을 실행중인 컴퓨터에서 한 단어의 크기 (비트 단위 : 32 또는 64).</target>
        </trans-unit>
        <trans-unit id="8f670099c33bb6a9695a8b24391cc3ee7a94ec07" translate="yes" xml:space="preserve">
          <source>Size of received buffer</source>
          <target state="translated">수신 된 버퍼의 크기</target>
        </trans-unit>
        <trans-unit id="3a091b3f09d5cc7e72f0c3a89f2986c55176bed8" translate="yes" xml:space="preserve">
          <source>Size of send buffer</source>
          <target state="translated">송신 버퍼 크기</target>
        </trans-unit>
        <trans-unit id="a5ba5bd7b7fe69d79153223545822822aa2cdcaf" translate="yes" xml:space="preserve">
          <source>So far, we have described how to call C functions from OCaml. In this section, we show how C functions can call OCaml functions, either as callbacks (OCaml calls C which calls OCaml), or with the main program written in C.</source>
          <target state="translated">지금까지 OCaml에서 C 함수를 호출하는 방법을 설명했습니다. 이 섹션에서는 C 함수가 콜백 (OCaml이 OCaml을 호출하는 C를 호출 함)으로 또는 C로 작성된 기본 프로그램을 사용하여 OCaml 함수를 호출하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="93c6a1f183694628e37ced41591147bfc0da1908" translate="yes" xml:space="preserve">
          <source>Socket</source>
          <target state="translated">Socket</target>
        </trans-unit>
        <trans-unit id="2cfd29f9858165eacbb559bf3f07fe2ff6c6692a" translate="yes" xml:space="preserve">
          <source>Socket domain</source>
          <target state="translated">소켓 도메인</target>
        </trans-unit>
        <trans-unit id="2e98a4ed23c4c749f9fc8167cd3bde6181cd3ddb" translate="yes" xml:space="preserve">
          <source>Socket is already connected</source>
          <target state="translated">소켓이 이미 연결되었습니다.</target>
        </trans-unit>
        <trans-unit id="ff89f748bc36cfa9b24752455509275ea67d6018" translate="yes" xml:space="preserve">
          <source>Socket is not connected</source>
          <target state="translated">소켓이 연결되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ba3a2f86cdfbc4d51c8dd0104aa25dd69c9ae5eb" translate="yes" xml:space="preserve">
          <source>Socket operation on non-socket</source>
          <target state="translated">비 소켓에서 소켓 작업</target>
        </trans-unit>
        <trans-unit id="3348447c0d2adbd99decc7a8738b6dea888ab6ca" translate="yes" xml:space="preserve">
          <source>Socket options</source>
          <target state="translated">소켓 옵션</target>
        </trans-unit>
        <trans-unit id="c9ad407a2d95af30c4033ba9ae9c8dae9a728edf" translate="yes" xml:space="preserve">
          <source>Socket protocol number</source>
          <target state="translated">소켓 프로토콜 번호</target>
        </trans-unit>
        <trans-unit id="44977f379f1c02803857933034b64abf658f4fbb" translate="yes" xml:space="preserve">
          <source>Socket type</source>
          <target state="translated">소켓 유형</target>
        </trans-unit>
        <trans-unit id="1d0a063107fb2a5027e2f89664a6337ddcb70691" translate="yes" xml:space="preserve">
          <source>Socket type not supported</source>
          <target state="translated">지원되지 않는 소켓 유형</target>
        </trans-unit>
        <trans-unit id="508c36b3241ae34627fb1cadebb1f27b16e0f61a" translate="yes" xml:space="preserve">
          <source>Sockets</source>
          <target state="translated">Sockets</target>
        </trans-unit>
        <trans-unit id="da7e8a5db4d27cd8e808680b636e1905c8ab337a" translate="yes" xml:space="preserve">
          <source>Software caused connection abort</source>
          <target state="translated">소프트웨어로 인해 연결이 중단되었습니다.</target>
        </trans-unit>
        <trans-unit id="ac38d3ac2b8f5582491bf72aa187e55579c2e9be" translate="yes" xml:space="preserve">
          <source>Some attributes are understood by the type-checker:</source>
          <target state="translated">일부 속성은 유형 검사기가 이해합니다.</target>
        </trans-unit>
        <trans-unit id="8cfecef4a7de8587a8731429a921ca7d4dfb4fd2" translate="yes" xml:space="preserve">
          <source>Some constructors, such as the exception constructors Failure and Invalid_argument, take as parameter a string value holding a text message intended for the user.</source>
          <target state="translated">예외 생성자 Failure 및 Invalid_argument와 같은 일부 생성자는 사용자를위한 텍스트 메시지를 포함하는 문자열 값을 매개 변수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="65db1c59080316bcf74caa7e0683333457ad28c6" translate="yes" xml:space="preserve">
          <source>Some elements support only a subset of all @-tags. Tags that are not relevant to the documented element are simply ignored. For instance, all tags are ignored when documenting type constructors, record fields, and class inheritance clauses. Similarly, a @param tag on a class instance variable is ignored.</source>
          <target state="translated">일부 요소는 모든 @-태그의 하위 집합 만 지원합니다. 문서화 된 요소와 관련이없는 태그는 무시됩니다. 예를 들어, 유형 생성자, 레코드 필드 및 클래스 상속 절을 문서화 할 때 모든 태그가 무시됩니다. 마찬가지로 클래스 인스턴스 변수의 @param 태그는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f3e4e360257048c8ac9623c4484c27cbb25c848b" translate="yes" xml:space="preserve">
          <source>Some entity (typically an expression) the value of which is known by the compiler at compile time. Constantness may be explicit from the source code or inferred by the Flambda optimisers.</source>
          <target state="translated">컴파일 타임에 컴파일러가 그 값을 알고있는 일부 엔티티 (일반적으로 표현식)입니다. 상수는 소스 코드에서 명시 적이거나 Flambda 옵티 마이저에 의해 추론 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4108bc1b80291fcd27aa85d3bc69508cd42011b" translate="yes" xml:space="preserve">
          <source>Some extension nodes are understood by the compiler itself:</source>
          <target state="translated">일부 확장 노드는 컴파일러 자체에서 이해합니다.</target>
        </trans-unit>
        <trans-unit id="ac91f25bdfaca0fd0f24bc1c048bd2a822908634" translate="yes" xml:space="preserve">
          <source>Some functions are flagged as not tail-recursive. A tail-recursive function uses constant stack space, while a non-tail-recursive function uses stack space proportional to the length of its list argument, which can be a problem with very long lists. When the function takes several list arguments, an approximate formula giving stack usage (in some unspecified constant unit) is shown in parentheses.</source>
          <target state="translated">일부 함수는 꼬리 재귀가 아닌 것으로 플래그가 지정됩니다. 꼬리 재귀 함수는 일정한 스택 공간을 사용하는 반면 비 꼬리 재귀 함수는 목록 인수의 길이에 비례하는 스택 공간을 사용하므로 매우 긴 목록에서 문제가 될 수 있습니다. 함수가 여러 목록 인수를 사용하는 경우 스택 사용량을 제공하는 대략적인 공식 (일부 지정되지 않은 상수 단위)이 괄호 안에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="415760abd20f9a3ddcb87f0308d37d8d1a8acca5" translate="yes" xml:space="preserve">
          <source>Some of the Flambda flags may be subject to change in future releases.</source>
          <target state="translated">일부 Flambda 플래그는 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8faaa28b910e81e493d1ec8c3ff366be796ccb5" translate="yes" xml:space="preserve">
          <source>Some possible reasons for failing to return a location are as follow:</source>
          <target state="translated">위치 반환에 실패하는 몇 가지 가능한 이유는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="352a26fd5c9966e34dc532660aeee492db89a4c8" translate="yes" xml:space="preserve">
          <source>Some possible reasons for returning &lt;code&gt;None&lt;/code&gt; are as follow:</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 을 반환하는 몇 가지 가능한 이유 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a491a5b9ff21fc1c712012884a3f6d5255eb641d" translate="yes" xml:space="preserve">
          <source>Some special expressions are available in method bodies for manipulating instance variables and duplicating self:</source>
          <target state="translated">인스턴스 변수를 조작하고 self를 복제하기 위해 메서드 본문에서 몇 가지 특수 표현식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dd7671731908ef2e0dae4c0fec50f5db2c9e9ac" translate="yes" xml:space="preserve">
          <source>Some syntactic constructions are accepted during parsing and rejected during type checking. These syntactic constructions can therefore not be used directly in vanilla OCaml. However, -ppx rewriters and other external tools can exploit this parser leniency to extend the language with these new syntactic constructions by rewriting them to vanilla constructions.</source>
          <target state="translated">구문 분석 중에 일부 구문 구조가 허용되고 유형 검사 중에 거부됩니다. 따라서 이러한 구문 구조는 바닐라 OCaml에서 직접 사용할 수 없습니다. 그러나 -ppx 재 작성기 및 기타 외부 도구는이 구문 분석기의 관대함을 이용하여 새로운 구문 구조를 바닐라 구조로 다시 작성하여 언어를 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc75d8733433957f6ed3394f8f48aaaa13a230d6" translate="yes" xml:space="preserve">
          <source>Sort a floatarray in increasing order according to a comparison function.</source>
          <target state="translated">비교 함수에 따라 오름차순으로 floatarray를 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="12b9742f0225797751f8d045f36f092bce5f2a25" translate="yes" xml:space="preserve">
          <source>Sort a floatarray in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see below for a complete specification). For example, &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; is a suitable comparison function. After calling &lt;code&gt;sort&lt;/code&gt;, the array is sorted in place in increasing order. &lt;code&gt;sort&lt;/code&gt; is guaranteed to run in constant heap space and (at most) logarithmic stack space.</source>
          <target state="translated">비교 함수에 따라 오름차순으로 floatarray를 정렬합니다. 비교 함수는 인수가 같으면 0을, 첫 번째 값이 더 크면 양의 정수를, 첫 번째 값이 더 작 으면 음의 정수를 반환해야합니다 (전체 사양은 아래 참조). 예를 들어, &lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt; 는 적절한 비교 기능입니다. &lt;code&gt;sort&lt;/code&gt; 를 호출 하면 배열이 오름차순으로 정렬됩니다. &lt;code&gt;sort&lt;/code&gt; 은 일정한 힙 공간과 (최대) 로그 스택 공간에서 실행되도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="646c2222ce8e2809d04501367fe92adb8b901099" translate="yes" xml:space="preserve">
          <source>Sort a list in increasing order according to a comparison function.</source>
          <target state="translated">비교 함수에 따라 오름차순으로 목록을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="03d3137b9feb06bf6e9a2e8f8dca4845b6ea1be1" translate="yes" xml:space="preserve">
          <source>Sort a list in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification). For example, &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; is a suitable comparison function. The resulting list is sorted in increasing order. &lt;code&gt;List.sort&lt;/code&gt; is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.</source>
          <target state="translated">비교 함수에 따라 오름차순으로 목록을 정렬합니다. 비교 함수는 인수가 같으면 0을, 첫 번째가 더 크면 양의 정수를, 첫 번째가 더 작 으면 음의 정수를 반환해야합니다 (전체 사양은 Array.sort 참조). 예를 들어, &lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt; 는 적절한 비교 기능입니다. 결과 목록은 오름차순으로 정렬됩니다. &lt;code&gt;List.sort&lt;/code&gt; 는 결과 목록의 크기와 함께 일정한 힙 공간과 로그 스택 공간에서 실행되도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="58d97caa0b4ab44fd3739d173807df802d224d9e" translate="yes" xml:space="preserve">
          <source>Sort an array in increasing order according to a comparison function.</source>
          <target state="translated">비교 함수에 따라 오름차순으로 배열을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="f4bce5c3631201bcc5ecaef3a611067df24b6202" translate="yes" xml:space="preserve">
          <source>Sort an array in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see below for a complete specification). For example, &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; is a suitable comparison function, provided there are no floating-point NaN values in the data. After calling &lt;code&gt;sort&lt;/code&gt;, the array is sorted in place in increasing order. &lt;code&gt;sort&lt;/code&gt; is guaranteed to run in constant heap space and (at most) logarithmic stack space.</source>
          <target state="translated">비교 함수에 따라 오름차순으로 배열을 정렬합니다. 비교 함수는 인수가 같으면 0을, 첫 번째 값이 더 크면 양의 정수를, 첫 번째 값이 더 작 으면 음의 정수를 반환해야합니다 (전체 사양은 아래 참조). 예를 들어, &lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt; 적절한 비교 함수이고, 데이터의 부동 소수점의 NaN 값이 없을 제공. &lt;code&gt;sort&lt;/code&gt; 를 호출 하면 배열이 오름차순으로 정렬됩니다. &lt;code&gt;sort&lt;/code&gt; 은 일정한 힙 공간과 (최대) 로그 스택 공간에서 실행되도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="b83d35f48bff1338b8ffef8c14c816e297c383b8" translate="yes" xml:space="preserve">
          <source>Sort an array in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see below for a complete specification). For example, &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; is a suitable comparison function. After calling &lt;code&gt;Array.sort&lt;/code&gt;, the array is sorted in place in increasing order. &lt;code&gt;Array.sort&lt;/code&gt; is guaranteed to run in constant heap space and (at most) logarithmic stack space.</source>
          <target state="translated">비교 함수에 따라 오름차순으로 배열을 정렬합니다. 비교 함수는 인수가 같으면 0을, 첫 번째 값이 더 크면 양의 정수를, 첫 번째 값이 더 작 으면 음의 정수를 반환해야합니다 (전체 사양은 아래 참조). 예를 들어, &lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt; 는 적절한 비교 기능입니다. &lt;code&gt;Array.sort&lt;/code&gt; 를 호출 하면 배열이 오름차순으로 정렬됩니다. &lt;code&gt;Array.sort&lt;/code&gt; 는 일정한 힙 공간과 (최대) 로그 스택 공간에서 실행되도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="01152a07b57f8764c6289151ce131fa414021b94" translate="yes" xml:space="preserve">
          <source>Sort files according to their dependencies.</source>
          <target state="translated">종속성에 따라 파일을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="0a0c9ee78d00c49fdb36745d008f1df78dd6c77a" translate="yes" xml:space="preserve">
          <source>Sort the list of top-level modules before generating the documentation.</source>
          <target state="translated">문서를 생성하기 전에 최상위 모듈 목록을 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="378e9e163b7eecefadb4415cae533096e336c4ab" translate="yes" xml:space="preserve">
          <source>Sorting</source>
          <target state="translated">Sorting</target>
        </trans-unit>
        <trans-unit id="ae89003b504fabd08ec3be7403f79794ab72855c" translate="yes" xml:space="preserve">
          <source>Spacetime</source>
          <target state="translated">Spacetime</target>
        </trans-unit>
        <trans-unit id="1f8cf16b7ea8f93bf5c99c3fb2607d56d944da70" translate="yes" xml:space="preserve">
          <source>Spacetime is currently only available for x86-64 targets and has only been tested on Linux systems (although it is expected to work on most modern Unix-like systems and provision has been made for running under Windows). It is expected that the set of supported platforms will be extended in the future.</source>
          <target state="translated">Spacetime은 현재 x86-64 대상에서만 사용할 수 있으며 Linux 시스템에서만 테스트되었습니다 (대부분의 최신 Unix 계열 시스템에서 작동 할 것으로 예상되고 Windows에서 실행되도록 프로비저닝되었습니다). 향후 지원되는 플랫폼 세트가 확장 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="ac584b81666b3bc3363ef560830c1cfe8b0e82d8" translate="yes" xml:space="preserve">
          <source>Spacetime is the name given to functionality within the OCaml compiler that provides for accurate profiling of the memory behaviour of a program. Using Spacetime it is possible to determine the source of memory leaks and excess memory allocation quickly and easily. Excess allocation slows programs down both by imposing a higher load on the garbage collector and reducing the cache locality of the program&amp;rsquo;s code. Spacetime provides full backtraces for every allocation that occurred on the OCaml heap during the lifetime of the program including those in C stubs.</source>
          <target state="translated">Spacetime은 프로그램의 메모리 동작에 대한 정확한 프로파일 링을 제공하는 OCaml 컴파일러 내의 기능에 부여 된 이름입니다. Spacetime을 사용하면 메모리 누수 및 초과 메모리 할당의 원인을 빠르고 쉽게 확인할 수 있습니다. 초과 할당은 가비지 수집기에 더 높은 부하를 부과하고 프로그램 코드의 캐시 지역성을 줄임으로써 프로그램 속도를 저하시킵니다. Spacetime은 C 스텁의 항목을 포함하여 프로그램 수명 동안 OCaml 힙에서 발생한 모든 할당에 대해 전체 역 추적을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="48a679b4fef93210c99c2867dca8b855aae9f079" translate="yes" xml:space="preserve">
          <source>Spacetime only analyses the memory behaviour of a program with respect to the OCaml heap allocators and garbage collector. It does not analyse allocation on the C heap. Spacetime does not affect the memory behaviour of a program being profiled with the exception of any change caused by the overhead of profiling (see section &lt;a href=&quot;#s%3Aspacetime-runtimeoverhead&quot;&gt;22.3&lt;/a&gt;)&amp;mdash;for example the program running slower might cause it to allocate less memory in total.</source>
          <target state="translated">Spacetime은 OCaml 힙 할당 자 및 가비지 수집기와 관련하여 프로그램의 메모리 동작 만 분석합니다. C 힙에 대한 할당을 분석하지 않습니다. 시공간은 프로파일 링 오버 헤드로 인한 변경을 제외하고는 프로파일 링되는 프로그램의 메모리 동작에 영향을주지 않습니다 (섹션 &lt;a href=&quot;#s%3Aspacetime-runtimeoverhead&quot;&gt;22.3&lt;/a&gt; 참조 ). 예를 들어 프로그램이 느리게 실행되면 전체 메모리를 더 적게 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bfc66fca52f849b22836f519ac13502d262a97d" translate="yes" xml:space="preserve">
          <source>Spacetime-configured compilers run slower and occupy more memory than their counterparts. It is hoped this will be fixed in the future as part of improved cross compilation support.</source>
          <target state="translated">시공간 구성 컴파일러는 해당 컴파일러보다 느리게 실행되고 더 많은 메모리를 차지합니다. 이것은 개선 된 크로스 컴파일 지원의 일환으로 향후 수정되기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="0f3d7da024c878836fb44bec74f82a857945e099" translate="yes" xml:space="preserve">
          <source>Specialised argument</source>
          <target state="translated">전문화 된 주장</target>
        </trans-unit>
        <trans-unit id="36d1cca4de316b0f3ff4a4a7aea712ca5d0b8416" translate="yes" xml:space="preserve">
          <source>Specialised formatted input functions</source>
          <target state="translated">특수 형식의 입력 함수</target>
        </trans-unit>
        <trans-unit id="c7ee5cdce5b5adc99a16107f8a0cbad11ccbdc8e" translate="yes" xml:space="preserve">
          <source>Specialized version of &lt;a href=&quot;bigarray#VALreshape&quot;&gt;&lt;code&gt;Bigarray.reshape&lt;/code&gt;&lt;/a&gt; for reshaping to one-dimensional arrays.</source>
          <target state="translated">1 차원 배열로 재구성하기위한 특수화 된 &lt;a href=&quot;bigarray#VALreshape&quot;&gt; &lt;code&gt;Bigarray.reshape&lt;/code&gt; &lt;/a&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="9c8e450d4639c979ec29c285647dd2fe5e10040b" translate="yes" xml:space="preserve">
          <source>Specialized version of &lt;a href=&quot;bigarray#VALreshape&quot;&gt;&lt;code&gt;Bigarray.reshape&lt;/code&gt;&lt;/a&gt; for reshaping to three-dimensional arrays.</source>
          <target state="translated">3 차원 배열로 재구성하기위한 특수화 된 &lt;a href=&quot;bigarray#VALreshape&quot;&gt; &lt;code&gt;Bigarray.reshape&lt;/code&gt; &lt;/a&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="7be8395c98cd0223aab91f0599a991b4dc5afc58" translate="yes" xml:space="preserve">
          <source>Specialized version of &lt;a href=&quot;bigarray#VALreshape&quot;&gt;&lt;code&gt;Bigarray.reshape&lt;/code&gt;&lt;/a&gt; for reshaping to two-dimensional arrays.</source>
          <target state="translated">2 차원 배열로 재구성하기위한 특수화 된 &lt;a href=&quot;bigarray#VALreshape&quot;&gt; &lt;code&gt;Bigarray.reshape&lt;/code&gt; &lt;/a&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="43c35773327940730b665961e4752362a3b5e73d" translate="yes" xml:space="preserve">
          <source>Specialized version of &lt;a href=&quot;bigarray#VALreshape&quot;&gt;&lt;code&gt;Bigarray.reshape&lt;/code&gt;&lt;/a&gt; for reshaping to zero-dimensional arrays.</source>
          <target state="translated">0 차원 배열로 재구성하기위한 특수화 된 &lt;a href=&quot;bigarray#VALreshape&quot;&gt; &lt;code&gt;Bigarray.reshape&lt;/code&gt; &lt;/a&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="78b2052c026f21ce8899e084abfbef4c7c52450f" translate="yes" xml:space="preserve">
          <source>Specific annotations may be added in the format strings to give pretty-printing commands to the pretty-printing engine.</source>
          <target state="translated">pretty-printing 엔진에 pretty-printing 명령을 제공하기 위해 형식 문자열에 특정 주석을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2c3dd0891ac4b24b95fb75f329dbcf06edc414d" translate="yes" xml:space="preserve">
          <source>Specification of the comparison function: Let &lt;code&gt;a&lt;/code&gt; be the array and &lt;code&gt;cmp&lt;/code&gt; the comparison function. The following must be true for all &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; :</source>
          <target state="translated">비교 함수의 지정 : &lt;code&gt;a&lt;/code&gt; 를 배열로, &lt;code&gt;cmp&lt;/code&gt; 를 비교 함수로 지정합니다. 다음은 모두 참이어야 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;z&lt;/code&gt; 의 : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="264268d95295992703c12c188ef6048251a383d4" translate="yes" xml:space="preserve">
          <source>Specification of the comparison function: Let &lt;code&gt;a&lt;/code&gt; be the array and &lt;code&gt;cmp&lt;/code&gt; the comparison function. The following must be true for all x, y, z in a :</source>
          <target state="translated">비교 함수의 지정 : &lt;code&gt;a&lt;/code&gt; 를 배열로, &lt;code&gt;cmp&lt;/code&gt; 를 비교 함수로 지정합니다. a의 모든 x, y, z에 대해 다음이 참이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4c87398d6e8515ee08416522a6df16c4bee30fa5" translate="yes" xml:space="preserve">
          <source>Specification of the comparison function: Let &lt;code&gt;a&lt;/code&gt; be the floatarray and &lt;code&gt;cmp&lt;/code&gt; the comparison function. The following must be true for all &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;z&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt; :</source>
          <target state="translated">비교 함수의 지정 : &lt;code&gt;a&lt;/code&gt; 를 floatarray로하고 비교 함수를 &lt;code&gt;cmp&lt;/code&gt; 로 지정 합니다. 다음은 모두 참이어야 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;z&lt;/code&gt; 의 : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d11d12414ac6591fc5217e352ba4806e18c81fbd" translate="yes" xml:space="preserve">
          <source>Specifies an additional string to be output with profiling information. By default, ocamlprof will annotate programs with comments of the form (* n *) where n is the counter value for a profiling point. With option -F s, the annotation will be (* sn *).</source>
          <target state="translated">프로파일 링 정보와 함께 출력 할 추가 문자열을 지정합니다. 기본적으로 ocamlprof는 (* n *) 형식의 주석으로 프로그램에 주석을 달 것입니다. 여기서 n은 프로파일 링 지점에 대한 카운터 값입니다. -F 옵션을 사용하면 주석이 (* sn *)이됩니다.</target>
        </trans-unit>
        <trans-unit id="b2ecbd64b6f63c8a41ad755311ef578f6fdd8a7a" translate="yes" xml:space="preserve">
          <source>Specifies an alternate dump file of profiling information to be read.</source>
          <target state="translated">읽을 프로파일 링 정보의 대체 덤프 파일을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="78189676774d8a03ffec36cdd021f56d4ff85ad2" translate="yes" xml:space="preserve">
          <source>Specify Info directory entry.</source>
          <target state="translated">정보 디렉토리 항목을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="764c1c2ac8fdb8df6ca241276b753400dbadf23e" translate="yes" xml:space="preserve">
          <source>Specify merge options between interfaces and implementations. (see section &lt;a href=&quot;#ss%3Aocamldoc-merge&quot;&gt;16.1.2&lt;/a&gt; for details). flags can be one or several of the following characters:</source>
          <target state="translated">인터페이스와 구현 간의 병합 옵션을 지정합니다. (자세한 내용은 섹션 &lt;a href=&quot;#ss%3Aocamldoc-merge&quot;&gt;16.1.2&lt;/a&gt; 참조). 플래그는 다음 문자 중 하나 또는 여러 문자 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9b2722d55e0ed667661be2e505491b3e2508aee" translate="yes" xml:space="preserve">
          <source>Specify odd parity instead of even.</source>
          <target state="translated">짝수 대신 홀수 패리티를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="b9eb61307c6397dc068c4836d5615b32db4f1bce" translate="yes" xml:space="preserve">
          <source>Specify section of Info directory.</source>
          <target state="translated">Info 디렉토리의 섹션을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3cf69310aaf4ba0ff88c8c11acbb5d9e874ea7a9" translate="yes" xml:space="preserve">
          <source>Specify the colors to use in the generated dot code. When generating module dependencies, ocamldoc uses different colors for modules, depending on the directories in which they reside. When generating types dependencies, ocamldoc uses different colors for types, depending on the modules in which they are defined. colors is a list of color names separated by &amp;rsquo;,&amp;rsquo;, as in Red,Blue,Green. The available colors are the ones supported by the dot tool.</source>
          <target state="translated">생성 된 도트 코드에 사용할 색상을 지정합니다. 모듈 종속성을 생성 할 때 ocamldoc은 모듈이있는 디렉토리에 따라 모듈에 다른 색상을 사용합니다. 유형 종속성을 생성 할 때 ocamldoc은 정의 된 모듈에 따라 유형에 대해 다른 색상을 사용합니다. colors는 Red, Blue, Green과 같이 ','로 구분 된 색상 이름 목록입니다. 사용 가능한 색상은 점 도구에서 지원하는 색상입니다.</target>
        </trans-unit>
        <trans-unit id="d1a04c4094800d4a25e3996a323a80970407a756" translate="yes" xml:space="preserve">
          <source>Specify the name of the output file produced by ocamllex. The default is the input file name with its extension replaced by .ml.</source>
          <target state="translated">ocamllex에서 생성 한 출력 파일의 이름을 지정합니다. 기본값은 확장자가 .ml로 대체 된 입력 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5bf2268a91aceafedecc7a037c499f825f2acf2f" translate="yes" xml:space="preserve">
          <source>Specify the name of the output file produced by the compiler. The default output name is a.out under Unix and camlprog.exe under Windows. If the -a option is given, specify the name of the library produced. If the -pack option is given, specify the name of the packed object file produced. If the -output-obj option is given, specify the name of the output file produced. If the -c option is given, specify the name of the object file produced for the &lt;em&gt;next&lt;/em&gt; source file that appears on the command line.</source>
          <target state="translated">컴파일러에서 생성 한 출력 파일의 이름을 지정합니다. 기본 출력 이름은 Unix에서는 a.out이고 Windows에서는 camlprog.exe입니다. -a 옵션이 제공되면 생성 된 라이브러리의 이름을 지정하십시오. -pack 옵션이 제공되면 생성 된 압축 된 오브젝트 파일의 이름을 지정하십시오. -output-obj 옵션이 제공되면 생성 된 출력 파일의 이름을 지정하십시오. -c 옵션이 제공되면 명령 줄에 나타나는 &lt;em&gt;다음&lt;/em&gt; 소스 파일에 대해 생성 된 개체 파일의 이름을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="d328a3d88738a8d3eadb3b8aefcee241c2d7a300" translate="yes" xml:space="preserve">
          <source>Specify the name of the output file produced by the linker. The default output name is a.out under Unix and camlprog.exe under Windows. If the -a option is given, specify the name of the library produced. If the -pack option is given, specify the name of the packed object file produced. If the -output-obj option is given, specify the name of the output file produced. If the -shared option is given, specify the name of plugin file produced.</source>
          <target state="translated">링커에서 생성 한 출력 파일의 이름을 지정합니다. 기본 출력 이름은 Unix에서는 a.out이고 Windows에서는 camlprog.exe입니다. -a 옵션이 제공되면 생성 된 라이브러리의 이름을 지정하십시오. -pack 옵션이 제공되면 생성 된 압축 된 오브젝트 파일의 이름을 지정하십시오. -output-obj 옵션이 제공되면 생성 된 출력 파일의 이름을 지정하십시오. -shared 옵션이 제공되면 생성 된 플러그인 파일의 이름을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="eac56ecb3edcec97524e457cb8e36bfda3addec2" translate="yes" xml:space="preserve">
          <source>Specify the name of the toplevel file produced by the linker. The default is a.out.</source>
          <target state="translated">링커에서 생성 한 최상위 파일의 이름을 지정합니다. 기본값은 a.out입니다.</target>
        </trans-unit>
        <trans-unit id="49fbb0a75dfa6081ddf8737f80eeb75c46445512" translate="yes" xml:space="preserve">
          <source>Specify the type of the semantic attributes for the given symbols. This is mandatory for start symbols only. Other nonterminal symbols need not be given types by hand: these types will be inferred when running the output files through the OCaml compiler (unless the &lt;code&gt;-s&lt;/code&gt; option is in effect). The &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; part is an arbitrary OCaml type expression, except that all type constructor names must be fully qualified, as explained above for %token.</source>
          <target state="translated">주어진 기호에 대한 의미 속성 유형을 지정합니다. 시작 기호에만 필수입니다. 다른 비 터미널 기호는 직접 유형을 지정할 필요가 없습니다. 이러한 유형은 OCaml 컴파일러를 통해 출력 파일을 실행할 때 유추됩니다 ( &lt;code&gt;-s&lt;/code&gt; 옵션이 적용 되지 않는 경우 ). &lt;a href=&quot;types#typexpr&quot;&gt;typexpr의&lt;/a&gt; % 토큰 위에서 설명한 바와 같이 부분은 모든 타입 생성자 이름은 완전해야하는 것을 제외하고, 임의의 OCaml의 타입의 표현이다.</target>
        </trans-unit>
        <trans-unit id="dc0c554e640ae69ee83bf329f25eaa01f80aabef" translate="yes" xml:space="preserve">
          <source>Split a file name into directory name / base file name.</source>
          <target state="translated">파일 이름을 디렉토리 이름 / 기본 파일 이름으로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="0ef2916d6063e59b7dc104bdabcd5daed75d687b" translate="yes" xml:space="preserve">
          <source>Split a file name into directory name / base file name. If &lt;code&gt;name&lt;/code&gt; is a valid file name, then &lt;code&gt;concat&amp;nbsp;(dirname&amp;nbsp;name)&amp;nbsp;(basename&amp;nbsp;name)&lt;/code&gt; returns a file name which is equivalent to &lt;code&gt;name&lt;/code&gt;. Moreover, after setting the current directory to &lt;code&gt;dirname&amp;nbsp;name&lt;/code&gt; (with &lt;a href=&quot;sys#VALchdir&quot;&gt;&lt;code&gt;Sys.chdir&lt;/code&gt;&lt;/a&gt;), references to &lt;code&gt;basename&amp;nbsp;name&lt;/code&gt; (which is a relative file name) designate the same file as &lt;code&gt;name&lt;/code&gt; before the call to &lt;a href=&quot;sys#VALchdir&quot;&gt;&lt;code&gt;Sys.chdir&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파일 이름을 디렉토리 이름 / 기본 파일 이름으로 분할합니다. 경우 &lt;code&gt;name&lt;/code&gt; 유효한 파일 이름, 다음 &lt;code&gt;concat&amp;nbsp;(dirname&amp;nbsp;name)&amp;nbsp;(basename&amp;nbsp;name)&lt;/code&gt; 에 해당하는 파일 이름 반환 &lt;code&gt;name&lt;/code&gt; . 또한 현재 디렉토리를 &lt;code&gt;dirname&amp;nbsp;name&lt;/code&gt; ( &lt;a href=&quot;sys#VALchdir&quot;&gt; &lt;code&gt;Sys.chdir&lt;/code&gt; 사용&lt;/a&gt; )으로 설정 한 후 &lt;code&gt;basename&amp;nbsp;name&lt;/code&gt; (상대 파일 이름)에 대한 참조 는 &lt;a href=&quot;sys#VALchdir&quot;&gt; &lt;code&gt;Sys.chdir&lt;/code&gt; &lt;/a&gt; 호출 이전의 &lt;code&gt;name&lt;/code&gt; 과 동일한 파일을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="18a9705b01dc9c170d51771a987c403f46a25076" translate="yes" xml:space="preserve">
          <source>Splitting</source>
          <target state="translated">Splitting</target>
        </trans-unit>
        <trans-unit id="16df53085eea45d012180a01d9c65e4d69715793" translate="yes" xml:space="preserve">
          <source>Square root.</source>
          <target state="translated">제곱근.</target>
        </trans-unit>
        <trans-unit id="0d3138eae7ebb469e62a43de3996f397bab11b30" translate="yes" xml:space="preserve">
          <source>Square root. The result &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt; is such that &lt;code&gt;x&amp;nbsp;&amp;gt;&amp;nbsp;0&lt;/code&gt; or &lt;code&gt;x&amp;nbsp;=&amp;nbsp;0&lt;/code&gt; and &lt;code&gt;y&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt;. This function has a discontinuity along the negative real axis.</source>
          <target state="translated">제곱근. 결과 &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt; 는 &lt;code&gt;x&amp;nbsp;&amp;gt;&amp;nbsp;0&lt;/code&gt; 또는 &lt;code&gt;x&amp;nbsp;=&amp;nbsp;0&lt;/code&gt; 및 &lt;code&gt;y&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; 입니다. 이 함수는 음의 실수 축을 따라 불연속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="83e5a0d3d2ef19df258412a4d3ef3f9533b0c0c1" translate="yes" xml:space="preserve">
          <source>Stack</source>
          <target state="translated">Stack</target>
        </trans-unit>
        <trans-unit id="119f5ab8a4f65aecd72a4d4c15e7238c1dd30516" translate="yes" xml:space="preserve">
          <source>Standard labeled libraries.</source>
          <target state="translated">표준 레이블이있는 라이브러리.</target>
        </trans-unit>
        <trans-unit id="508cfdd242a4dbc44b800a23c67d10428e2c6d2c" translate="yes" xml:space="preserve">
          <source>Standard library modules</source>
          <target state="translated">표준 라이브러리 모듈</target>
        </trans-unit>
        <trans-unit id="e4da9a8e1b11d834d3eab1b30b53670f8388f8aa" translate="yes" xml:space="preserve">
          <source>Start character (usually ctrl-Q).</source>
          <target state="translated">시작 문자 (일반적으로 ctrl-Q).</target>
        </trans-unit>
        <trans-unit id="277ac8ecc15e2c9171fab8c17452880f42607be5" translate="yes" xml:space="preserve">
          <source>Start of major GC cycle.</source>
          <target state="translated">주요 GC주기 시작.</target>
        </trans-unit>
        <trans-unit id="90e0161012dde2267255594a35194c6fbd832e5d" translate="yes" xml:space="preserve">
          <source>Start the sampling with the given parameters.</source>
          <target state="translated">주어진 매개 변수로 샘플링을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="19cc28c4f6b24df76b4178e0a8799f0454427c48" translate="yes" xml:space="preserve">
          <source>Start the sampling with the given parameters. Fails if sampling is already active.</source>
          <target state="translated">주어진 매개 변수로 샘플링을 시작합니다. 샘플링이 이미 활성화 된 경우 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f830a13dce8adcb0cabc74755c312cfc51e5017b" translate="yes" xml:space="preserve">
          <source>Starting with Objective Caml 3.00, it is possible to record the -custom option as well as the names of C libraries in an OCaml library file .cma or .cmxa. For instance, consider an OCaml library mylib.cma, built from the OCaml object files a.cmo and b.cmo, which reference C code in libmylib.a. If the library is built as follows:</source>
          <target state="translated">Objective Caml 3.00부터는 -custom 옵션과 C 라이브러리의 이름을 OCaml 라이브러리 파일 .cma 또는 .cmxa에 기록 할 수 있습니다. 예를 들어, libmylib.a의 C 코드를 참조하는 OCaml 오브젝트 파일 a.cmo 및 b.cmo에서 빌드 된 OCaml 라이브러리 mylib.cma를 고려하십시오. 라이브러리가 다음과 같이 빌드 된 경우 :</target>
        </trans-unit>
        <trans-unit id="b91eda3d5a614d7d82dcfba7938bafd9738269ae" translate="yes" xml:space="preserve">
          <source>Starting with Objective Caml 3.03, an alternative to static linking of C code using the -custom code is provided. In this mode, the OCaml linker generates a pure bytecode executable (no embedded custom runtime system) that simply records the names of dynamically-loaded libraries containing the C code. The standard OCaml runtime system ocamlrun then loads dynamically these libraries, and resolves references to the required primitives, before executing the bytecode.</source>
          <target state="translated">Objective Caml 3.03부터는 -custom 코드를 사용하는 C 코드의 정적 링크에 대한 대안이 제공됩니다. 이 모드에서 OCaml 링커는 C 코드를 포함하는 동적으로로드 된 라이브러리의 이름을 단순히 기록하는 순수 바이트 코드 실행 파일 (내장 된 사용자 지정 런타임 시스템 없음)을 생성합니다. 그런 다음 표준 OCaml 런타임 시스템 ocamlrun은 이러한 라이브러리를 동적으로로드하고 바이트 코드를 실행하기 전에 필요한 기본 요소에 대한 참조를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1f59cc0afb2e7a12e0dd36361604146e391913c8" translate="yes" xml:space="preserve">
          <source>Startup messages (loading the bytecode executable file, resolving shared libraries).</source>
          <target state="translated">시작 메시지 (바이트 코드 실행 파일로드, 공유 라이브러리 분석).</target>
        </trans-unit>
        <trans-unit id="2086b21f8f49274138c38d476bee317a84a8aecc" translate="yes" xml:space="preserve">
          <source>Statistics</source>
          <target state="translated">Statistics</target>
        </trans-unit>
        <trans-unit id="29757350cc40a874924e4f8603f0be72611f1555" translate="yes" xml:space="preserve">
          <source>StdLabels</source>
          <target state="translated">StdLabels</target>
        </trans-unit>
        <trans-unit id="e4480faf0e810a556a7a3d6b1944ea9990b30303" translate="yes" xml:space="preserve">
          <source>Stdlib</source>
          <target state="translated">Stdlib</target>
        </trans-unit>
        <trans-unit id="9e253470c876ee6d5c720eb777aeb82d4c26e28f" translate="yes" xml:space="preserve">
          <source>Stop</source>
          <target state="translated">Stop</target>
        </trans-unit>
        <trans-unit id="cac94c65840b164f967c185720ce5d2d22fcd8fc" translate="yes" xml:space="preserve">
          <source>Stop character (usually ctrl-S).</source>
          <target state="translated">중지 문자 (일반적으로 ctrl-S).</target>
        </trans-unit>
        <trans-unit id="dd2d0badca0107bfe00c8bf707f6cbbc66e875ef" translate="yes" xml:space="preserve">
          <source>Stop compilation after the given compilation pass. The currently supported passes are: parsing, typing.</source>
          <target state="translated">주어진 컴파일 패스 후에 컴파일을 중지합니다. 현재 지원되는 패스는 구문 분석, 입력입니다.</target>
        </trans-unit>
        <trans-unit id="acb0dcfd6906c0d9e5e828dfe6db5b7a0e08dae4" translate="yes" xml:space="preserve">
          <source>Stop execution for the given number of seconds.</source>
          <target state="translated">주어진 시간 (초) 동안 실행을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="ba8848ffcb6b76a0d727951fcafac4b2adee910f" translate="yes" xml:space="preserve">
          <source>Stop execution for the given number of seconds. Like &lt;code&gt;sleep&lt;/code&gt;, but fractions of seconds are supported.</source>
          <target state="translated">주어진 시간 (초) 동안 실행을 중지합니다. 마찬가지로 &lt;code&gt;sleep&lt;/code&gt; 하지만 초 분수가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9f39332271b648b33b9216188c148ca185ccff4c" translate="yes" xml:space="preserve">
          <source>Stop interpreting keywords and call the function with each remaining argument</source>
          <target state="translated">키워드 해석을 중지하고 나머지 인수를 사용하여 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="54caba6c5e005665e19c471a9869196aa5fe758e" translate="yes" xml:space="preserve">
          <source>Stop the sampling.</source>
          <target state="translated">샘플링을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="aa8698fd09970a6af5ef2746988e8701f18facae" translate="yes" xml:space="preserve">
          <source>Stop the sampling. Fails if sampling is not active.</source>
          <target state="translated">샘플링을 중지합니다. 샘플링이 활성화되지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="31ef85d3886324ac0daa432598f7f28c17c3ca8f" translate="yes" xml:space="preserve">
          <source>Stop tracing all functions traced so far.</source>
          <target state="translated">지금까지 추적 한 모든 기능의 추적을 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="2cef2a78b119882569894c0a7f505f95f3af25ea" translate="yes" xml:space="preserve">
          <source>Stop tracing the given function.</source>
          <target state="translated">주어진 함수 추적을 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="159480ac5536641c98c16dc1a2fc1666f43ed18c" translate="yes" xml:space="preserve">
          <source>Store_double_field(v, n, d) stores the double precision floating-point number d in the n&lt;sup&gt;th&lt;/sup&gt; element of the array of floating-point numbers v.</source>
          <target state="translated">Store_double_field (v, n, d)는 부동 소수점 숫자 v 배열의 n &lt;sup&gt;번째&lt;/sup&gt; 요소에 배정 밀도 부동 소수점 숫자 d를 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="ba2305bf40cfd2ed7e52c98519e2076d13f1f2a8" translate="yes" xml:space="preserve">
          <source>Store_field (b, n, v) stores the value v in the field number n of value b, which must be a block (i.e. Is_block(b) must be true).</source>
          <target state="translated">Store_field (b, n, v)는 블록이어야하는 값 b의 필드 번호 n에 값 v를 저장합니다 (즉, Is_block (b)가 true 여야 함).</target>
        </trans-unit>
        <trans-unit id="382e914de22199d46f8d0ef5c5b6a457fd5f5f88" translate="yes" xml:space="preserve">
          <source>Store_field(b, n, v) stores the value v in the field number n of value b, which must be a structured block.</source>
          <target state="translated">Store_field (b, n, v)는 구조화 된 블록이어야하는 값 b의 필드 번호 n에 값 v를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="5dfe08d5f0fd501cb4cb5c9b5ab1306e28c9aaa5" translate="yes" xml:space="preserve">
          <source>Str</source>
          <target state="translated">Str</target>
        </trans-unit>
        <trans-unit id="df063869e11d7a9aa132cd4a984f7b5eb870d656" translate="yes" xml:space="preserve">
          <source>Stream</source>
          <target state="translated">Stream</target>
        </trans-unit>
        <trans-unit id="b48e1a50e3eb18053b14d5bfc02d99c1f824c681" translate="yes" xml:space="preserve">
          <source>Stream builders</source>
          <target state="translated">스트림 빌더</target>
        </trans-unit>
        <trans-unit id="9712546075280428be043f28e86353de8b8e9c67" translate="yes" xml:space="preserve">
          <source>Stream iterator</source>
          <target state="translated">스트림 반복자</target>
        </trans-unit>
        <trans-unit id="c1df93dbb42814b12d5b273e5758a6fac66a2de5" translate="yes" xml:space="preserve">
          <source>Stream socket</source>
          <target state="translated">스트림 소켓</target>
        </trans-unit>
        <trans-unit id="fb2e7e5cdfa180129198e529d8ea2621c317804f" translate="yes" xml:space="preserve">
          <source>Streams and parsers.</source>
          <target state="translated">스트림 및 파서.</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="bb36019440cc173d127c3aae1c10a96090c6c585" translate="yes" xml:space="preserve">
          <source>String concatenation.</source>
          <target state="translated">문자열 연결.</target>
        </trans-unit>
        <trans-unit id="0d310b2b99cc668b17af0b02d5702685919572c5" translate="yes" xml:space="preserve">
          <source>String concatenation. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">문자열 연결. 오른쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="0c14d9fcd0e402fa5d59a8deada34328c2183ab1" translate="yes" xml:space="preserve">
          <source>String conversion functions</source>
          <target state="translated">문자열 변환 함수</target>
        </trans-unit>
        <trans-unit id="e8c67bee324dda8862ee44968e54400194cc2d63" translate="yes" xml:space="preserve">
          <source>String literals are delimited by &quot; (double quote) characters. The two double quotes enclose a sequence of either characters different from &quot; and \, or escape sequences from the table given above for character literals, or a Unicode character escape sequence.</source>
          <target state="translated">문자열 리터럴은 &quot;(큰 따옴표) 문자로 구분됩니다. 두 개의 큰 따옴표는&quot;및 \와 다른 문자 시퀀스 나 문자 리터럴에 대해 위에 제공된 표의 이스케이프 시퀀스 또는 유니 코드 문자 이스케이프 시퀀스를 묶습니다.</target>
        </trans-unit>
        <trans-unit id="8c7906868ba95400fc8a6d36abebe6392b45e269" translate="yes" xml:space="preserve">
          <source>String matching and searching</source>
          <target state="translated">문자열 일치 및 검색</target>
        </trans-unit>
        <trans-unit id="766f45c1227c8c7d13e31b3c8218c7c441dc99b1" translate="yes" xml:space="preserve">
          <source>String operations</source>
          <target state="translated">문자열 연산</target>
        </trans-unit>
        <trans-unit id="8d5d12fe85ff3629c70f06fe2ccba98f2ef750ad" translate="yes" xml:space="preserve">
          <source>String operations.</source>
          <target state="translated">문자열 연산.</target>
        </trans-unit>
        <trans-unit id="6e7ccab3bf9ed59fa3897eaea798c56c7684cd59" translate="yes" xml:space="preserve">
          <source>String operations. This module is intended to be used through &lt;a href=&quot;stdlabels&quot;&gt;&lt;code&gt;StdLabels&lt;/code&gt;&lt;/a&gt; which replaces &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; with their labeled counterparts</source>
          <target state="translated">문자열 연산. 이 모듈은 &lt;a href=&quot;array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;bytes&quot;&gt; &lt;code&gt;Bytes&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 을 레이블이 지정된 대응 &lt;a href=&quot;stdlabels&quot;&gt; &lt;code&gt;StdLabels&lt;/code&gt; &lt;/a&gt; 로 대체하는 StdLabels 를 통해 사용하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0dd53d6d05f395fe64d03b9c25a5955171c3d33f" translate="yes" xml:space="preserve">
          <source>String tags</source>
          <target state="translated">문자열 태그</target>
        </trans-unit>
        <trans-unit id="398d9ddb73ee4947a6d92a53a3b99ed8de605451" translate="yes" xml:space="preserve">
          <source>String values are finite sequences of characters. The current implementation supports strings containing up to 2&lt;sup&gt;24&lt;/sup&gt; &amp;minus; 5 characters (16777211 characters); on 64-bit platforms, the limit is 2&lt;sup&gt;57&lt;/sup&gt; &amp;minus; 9.</source>
          <target state="translated">문자열 값은 유한 한 문자 시퀀스입니다. 2 개까지 함유 현재 구현 지지체 문자열 &lt;sup&gt;24&lt;/sup&gt; - 5 자 (16,777,211 자); 64 비트 플랫폼에서 제한은 2 &lt;sup&gt;57-9&lt;/sup&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="34a998adbb8ec8935e29af4fede0169191c33176" translate="yes" xml:space="preserve">
          <source>StringLabels</source>
          <target state="translated">StringLabels</target>
        </trans-unit>
        <trans-unit id="f9ce9e410646789b1991a03fbd23ed1074dfa4df" translate="yes" xml:space="preserve">
          <source>String_tag</source>
          <target state="translated">String_tag</target>
        </trans-unit>
        <trans-unit id="2d498b782702d956bea922cd280afa2515d69410" translate="yes" xml:space="preserve">
          <source>String_val(v) returns a pointer to the first byte of the string v, with type char * or, when OCaml is configured with -force-safe-string, with type const char *. This pointer is a valid C string: there is a null byte after the last byte in the string. However, OCaml strings can contain embedded null bytes, which will confuse the usual C functions over strings.</source>
          <target state="translated">String_val (v)은 문자열 v의 첫 번째 바이트에 대한 포인터를 반환합니다. 유형은 char *이거나 OCaml이 -force-safe-string으로 구성된 경우 const char * 유형입니다. 이 포인터는 유효한 C 문자열입니다. 문자열의 마지막 바이트 뒤에 널 바이트가 있습니다. 그러나 OCaml 문자열은 포함 된 null 바이트를 포함 할 수 있으므로 문자열보다 일반적인 C 함수를 혼동합니다.</target>
        </trans-unit>
        <trans-unit id="060ca5b23f65b0299c216dd4e8511069f47054f4" translate="yes" xml:space="preserve">
          <source>Strip 8th bit on input characters.</source>
          <target state="translated">입력 문자에서 8 번째 비트를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="7c0e13fdadda30bb92194b7ff31353209f1c6453" translate="yes" xml:space="preserve">
          <source>Structural equality test.</source>
          <target state="translated">구조적 동등성 테스트.</target>
        </trans-unit>
        <trans-unit id="1420a8bfe553843800a5e0eeda6eeea10bcce063" translate="yes" xml:space="preserve">
          <source>Structural inequality test.</source>
          <target state="translated">구조적 불평등 테스트.</target>
        </trans-unit>
        <trans-unit id="964f4aa676065898b1577b34f94afc2774c1ff8d" translate="yes" xml:space="preserve">
          <source>Structural ordering functions.</source>
          <target state="translated">구조적 순서 기능.</target>
        </trans-unit>
        <trans-unit id="ba988a59552bfb50a703210d543593242c424d01" translate="yes" xml:space="preserve">
          <source>Structural ordering functions. These functions coincide with the usual orderings over integers, characters, strings, byte sequences and floating-point numbers, and extend them to a total ordering over all types. The ordering is compatible with &lt;code&gt;(&amp;nbsp;=&amp;nbsp;)&lt;/code&gt;. As in the case of &lt;code&gt;(&amp;nbsp;=&amp;nbsp;)&lt;/code&gt;, mutable structures are compared by contents. Comparison between functional values raises &lt;code&gt;Invalid_argument&lt;/code&gt;. Comparison between cyclic structures may not terminate. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">구조적 순서 기능. 이러한 함수는 정수, 문자, 문자열, 바이트 시퀀스 및 부동 소수점 숫자에 대한 일반적인 순서와 일치하며 모든 유형에 대한 전체 순서로 확장합니다. 주문은 &lt;code&gt;(&amp;nbsp;=&amp;nbsp;)&lt;/code&gt; 와 호환됩니다 . &lt;code&gt;(&amp;nbsp;=&amp;nbsp;)&lt;/code&gt; 의 경우와 같이 변경 가능한 구조는 내용별로 비교됩니다. 함수 값을 비교하면 &lt;code&gt;Invalid_argument&lt;/code&gt; 가 발생 합니다. 순환 구조 간의 비교는 종료되지 않을 수 있습니다. 왼쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="fa1a6ce691e6d5ffdcd5ca0d0bf720c77435180e" translate="yes" xml:space="preserve">
          <source>Structure of entries in the &lt;code&gt;groups&lt;/code&gt; database.</source>
          <target state="translated">&lt;code&gt;groups&lt;/code&gt; 데이터베이스 의 항목 구조 .</target>
        </trans-unit>
        <trans-unit id="598293f4d4d38fb64e25a27801c5bb777aed096f" translate="yes" xml:space="preserve">
          <source>Structure of entries in the &lt;code&gt;hosts&lt;/code&gt; database.</source>
          <target state="translated">&lt;code&gt;hosts&lt;/code&gt; 데이터베이스 의 항목 구조 .</target>
        </trans-unit>
        <trans-unit id="d7118c10fc2f1d94d9826bee980fe8f7908c0e0c" translate="yes" xml:space="preserve">
          <source>Structure of entries in the &lt;code&gt;passwd&lt;/code&gt; database.</source>
          <target state="translated">&lt;code&gt;passwd&lt;/code&gt; 데이터베이스 의 항목 구조 .</target>
        </trans-unit>
        <trans-unit id="abf82e0dcc97048077ad807e874664a09c91e309" translate="yes" xml:space="preserve">
          <source>Structure of entries in the &lt;code&gt;protocols&lt;/code&gt; database.</source>
          <target state="translated">&lt;code&gt;protocols&lt;/code&gt; 데이터베이스 의 항목 구조 .</target>
        </trans-unit>
        <trans-unit id="a6c3d4928c346aafd5529fad82c13ccca99e8e53" translate="yes" xml:space="preserve">
          <source>Structure of entries in the &lt;code&gt;services&lt;/code&gt; database.</source>
          <target state="translated">&lt;code&gt;services&lt;/code&gt; 데이터베이스 의 항목 구조 .</target>
        </trans-unit>
        <trans-unit id="d2e5835f238715991fb675b2b1d62d25b388199e" translate="yes" xml:space="preserve">
          <source>Structures struct &amp;hellip; end are collections of definitions for value names, type names, exceptions, module names and module type names. The definitions are evaluated in the order in which they appear in the structure. The scopes of the bindings performed by the definitions extend to the end of the structure. As a consequence, a definition may refer to names bound by earlier definitions in the same structure.</source>
          <target state="translated">구조체 struct&amp;hellip; end는 값 이름, 유형 이름, 예외, 모듈 이름 및 모듈 유형 이름에 대한 정의 모음입니다. 정의는 구조에 나타나는 순서대로 평가됩니다. 정의에 의해 수행되는 바인딩의 범위는 구조의 끝까지 확장됩니다. 결과적으로 정의는 동일한 구조에서 이전 정의로 묶인 이름을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5b58ce4dec6fe8562096a10da3109ac06c55815" translate="yes" xml:space="preserve">
          <source>Subtraction</source>
          <target state="translated">Subtraction</target>
        </trans-unit>
        <trans-unit id="85e16c85547da9b7ef56410541850d43ba4b72ba" translate="yes" xml:space="preserve">
          <source>Subtraction.</source>
          <target state="translated">Subtraction.</target>
        </trans-unit>
        <trans-unit id="f23d83765c27480ace90dc29b354fcb3af5074ca" translate="yes" xml:space="preserve">
          <source>Subtyping is never implicit. There are, however, two ways to perform subtyping. The most general construction is fully explicit: both the domain and the codomain of the type coercion must be given.</source>
          <target state="translated">하위 유형 지정은 절대로 암시되지 않습니다. 그러나 하위 입력을 수행하는 방법에는 두 가지가 있습니다. 가장 일반적인 구성은 완전히 명시 적입니다. 강제 유형의 도메인과 공동 도메인을 모두 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="267236f12d087c344c732b17967129639c89c2dd" translate="yes" xml:space="preserve">
          <source>Successor.</source>
          <target state="translated">Successor.</target>
        </trans-unit>
        <trans-unit id="695eff1526e154751f93eceb9ecae7ae62843717" translate="yes" xml:space="preserve">
          <source>Successor. &lt;code&gt;Int32.succ&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Int32.add&amp;nbsp;x&amp;nbsp;Int32.one&lt;/code&gt;.</source>
          <target state="translated">후임. &lt;code&gt;Int32.succ&amp;nbsp;x&lt;/code&gt; 는 &lt;code&gt;Int32.add&amp;nbsp;x&amp;nbsp;Int32.one&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a88899200e53819e4fca75e68b1f2d7ef4f59f99" translate="yes" xml:space="preserve">
          <source>Successor. &lt;code&gt;Int64.succ&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Int64.add&amp;nbsp;x&amp;nbsp;Int64.one&lt;/code&gt;.</source>
          <target state="translated">후임. &lt;code&gt;Int64.succ&amp;nbsp;x&lt;/code&gt; 는 &lt;code&gt;Int64.add&amp;nbsp;x&amp;nbsp;Int64.one&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8a33602394a98e9f181e6510ea20dbadc6f37f28" translate="yes" xml:space="preserve">
          <source>Successor. &lt;code&gt;Nativeint.succ&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Nativeint.add&amp;nbsp;x&amp;nbsp;Nativeint.one&lt;/code&gt;.</source>
          <target state="translated">후임. &lt;code&gt;Nativeint.succ&amp;nbsp;x&lt;/code&gt; 는 &lt;code&gt;Nativeint.add&amp;nbsp;x&amp;nbsp;Nativeint.one&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b03e8df028a515393350967ae4387f5ffddb3921" translate="yes" xml:space="preserve">
          <source>Such abbreviations may be used alone,</source>
          <target state="translated">이러한 약어는 단독으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9a9a4018c6e87434fce0fcbcb6811297262044d" translate="yes" xml:space="preserve">
          <source>Such annotations of the form name: are called &lt;em&gt;labels&lt;/em&gt;. They are meant to document the code, allow more checking, and give more flexibility to function application. You can give such names to arguments in your programs, by prefixing them with a tilde ~.</source>
          <target state="translated">name : 형식의 이러한 주석을 &lt;em&gt;레이블&lt;/em&gt; 이라고 합니다. 이는 코드를 문서화하고 더 많은 검사를 허용하며 기능 응용 프로그램에 더 많은 유연성을 제공하기위한 것입니다. 프로그램의 인수에 물결표 ~를 접두사로 붙여 이러한 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afe84014593353fc3502a2dfb59069e9aa563fb9" translate="yes" xml:space="preserve">
          <source>Such comments can take three forms: &lt;em&gt;floating comments&lt;/em&gt;, &lt;em&gt;item comments&lt;/em&gt; and &lt;em&gt;label comments&lt;/em&gt;. Any comment starting with ** which does not match one of these forms will cause the compiler to emit warning 50.</source>
          <target state="translated">이러한 주석은 &lt;em&gt;부동 주석&lt;/em&gt; , &lt;em&gt;항목 주석&lt;/em&gt; 및 &lt;em&gt;레이블 주석의&lt;/em&gt; 세 가지 형식을 취할 수 있습니다 . 이러한 형식 중 하나와 일치하지 않는 **로 시작하는 주석은 컴파일러에서 경고 50을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="25da4ed1a780e343dd3f4f8e9110f06bf0afad4e" translate="yes" xml:space="preserve">
          <source>Such conjunctive constraints may be unsatisfiable. In such a case the corresponding tag may not be used in a value of this type. This does not mean that the whole type is not valid: one can still use other available tags. Conjunctive constraints are mainly intended as output from the type checker. When they are used in source programs, unsolvable constraints may cause early failures.</source>
          <target state="translated">이러한 결합 적 제약은 만족스럽지 않을 수 있습니다. 이 경우 해당 태그를이 유형의 값에 사용할 수 없습니다. 이것은 전체 유형이 유효하지 않다는 것을 의미하지 않습니다. 하나는 여전히 사용 가능한 다른 태그를 사용할 수 있습니다. 결합 제약은 주로 유형 검사기의 출력으로 사용됩니다. 소스 프로그램에서 사용되는 경우 해결할 수없는 제약 조건으로 인해 조기 실패가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="608e778255c58bb721e1518cfabc05ef86956e7e" translate="yes" xml:space="preserve">
          <source>Such specifications are also inferred. Namely, when P is a path satisfying the above constraints,</source>
          <target state="translated">이러한 사양도 추론됩니다. 즉, P가 위의 제약을 만족하는 경로 일 때,</target>
        </trans-unit>
        <trans-unit id="20dbe04d5924d91567646631274eb2f545fc830d" translate="yes" xml:space="preserve">
          <source>Support libraries for the C part (-llib).</source>
          <target state="translated">C 파트 (-llib)에 대한 지원 라이브러리.</target>
        </trans-unit>
        <trans-unit id="345aca003e713e405c83d4690e078d5d7eeef4ce" translate="yes" xml:space="preserve">
          <source>Supported layouts</source>
          <target state="translated">지원되는 레이아웃</target>
        </trans-unit>
        <trans-unit id="e58a2db5e9aa8c332609520b8b74074728fd429c" translate="yes" xml:space="preserve">
          <source>Suppress header in generated documentation.</source>
          <target state="translated">생성 된 문서에서 헤더를 억제합니다.</target>
        </trans-unit>
        <trans-unit id="de50b1b14218cb87a2945d6e8e68eda23b7643ee" translate="yes" xml:space="preserve">
          <source>Suppress trailer in generated documentation.</source>
          <target state="translated">생성 된 문서에서 트레일러를 억제합니다.</target>
        </trans-unit>
        <trans-unit id="7b699c4e85571d84428b248779bbe8ae1bbcbfbf" translate="yes" xml:space="preserve">
          <source>Suspend or restart reception or transmission of data on the given file descriptor, depending on the second argument: &lt;code&gt;TCOOFF&lt;/code&gt; suspends output, &lt;code&gt;TCOON&lt;/code&gt; restarts output, &lt;code&gt;TCIOFF&lt;/code&gt; transmits a STOP character to suspend input, and &lt;code&gt;TCION&lt;/code&gt; transmits a START character to restart input.</source>
          <target state="translated">두 번째 인수에 따라 주어진 파일 설명자에서 데이터 수신 또는 전송을 일시 중단하거나 다시 시작합니다. &lt;code&gt;TCOOFF&lt;/code&gt; 는 출력을 일시 중단하고 &lt;code&gt;TCOON&lt;/code&gt; 은 출력을 다시 시작하며 &lt;code&gt;TCIOFF&lt;/code&gt; 는 STOP 문자를 전송하여 입력을 일시 중단하고 &lt;code&gt;TCION&lt;/code&gt; 은 START 문자를 전송하여 입력을 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="4f79bf2cca20cb87f53d54a2eae520b086d8ef01" translate="yes" xml:space="preserve">
          <source>Suspend the execution of the calling thread until at least one character or EOF is available for reading (&lt;code&gt;wait_read&lt;/code&gt;) or one character can be written without blocking (&lt;code&gt;wait_write&lt;/code&gt;) on the given Unix file descriptor.</source>
          <target state="translated">적어도 하나 개의 문자까지 호출 스레드의 실행을 일시 중단 또는 EOF는 (읽기 사용할 수 있습니다 &lt;code&gt;wait_read&lt;/code&gt; (블록하지 않고 쓸 수있다) 또는 하나 개의 문자를 &lt;code&gt;wait_write&lt;/code&gt; 을 주어진 유닉스 파일 기술자에).</target>
        </trans-unit>
        <trans-unit id="b9e7e7483847182bf81440a5b48041aad821bf57" translate="yes" xml:space="preserve">
          <source>Suspend the execution of the calling thread until at least one character or EOF is available for reading (&lt;code&gt;wait_read&lt;/code&gt;) or one character can be written without blocking (&lt;code&gt;wait_write&lt;/code&gt;) on the given Unix file descriptor. Wait for at most the amount of time given as second argument (in seconds). Return &lt;code&gt;true&lt;/code&gt; if the file descriptor is ready for input/output and &lt;code&gt;false&lt;/code&gt; if the timeout expired.</source>
          <target state="translated">적어도 하나 개의 문자까지 호출 스레드의 실행을 일시 중단 또는 EOF는 (읽기 사용할 수 있습니다 &lt;code&gt;wait_read&lt;/code&gt; (블록하지 않고 쓸 수있다) 또는 하나 개의 문자를 &lt;code&gt;wait_write&lt;/code&gt; 을 주어진 유닉스 파일 기술자에). 두 번째 인수로 지정된 시간 (초)까지 기다립니다. 반환 &lt;code&gt;true&lt;/code&gt; 파일 기술자가 입력 / 출력에 대한 준비가되어있는 경우 &lt;code&gt;false&lt;/code&gt; 시간 제한이 만료 된 경우.</target>
        </trans-unit>
        <trans-unit id="dd698dfe06d0932557c1eb650583aff1c0a8f274" translate="yes" xml:space="preserve">
          <source>Suspend the execution of the calling thread until input/output becomes possible on the given Unix file descriptors.</source>
          <target state="translated">주어진 Unix 파일 설명자에서 입력 / 출력이 가능해질 때까지 호출 스레드의 실행을 일시 중단합니다.</target>
        </trans-unit>
        <trans-unit id="89b43cd2f521875a54a83bde786aa4892b785359" translate="yes" xml:space="preserve">
          <source>Suspend the execution of the calling thread until input/output becomes possible on the given Unix file descriptors. The arguments and results have the same meaning as for &lt;code&gt;Unix.select&lt;/code&gt;. This function is not implemented yet under Win32.</source>
          <target state="translated">주어진 Unix 파일 설명자에서 입력 / 출력이 가능해질 때까지 호출 스레드의 실행을 일시 중단합니다. 인수와 결과는 &lt;code&gt;Unix.select&lt;/code&gt; 와 동일한 의미를 갖습니다 . 이 기능은 아직 Win32에서 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c5ee688ede72fd80011cbf7bc6580d8f7239f6ae" translate="yes" xml:space="preserve">
          <source>Suspending threads</source>
          <target state="translated">스레드 일시 중단</target>
        </trans-unit>
        <trans-unit id="6174b4bb3312bb6b8d643916247f5c5c92a0cf44" translate="yes" xml:space="preserve">
          <source>Suspicious unused variable: unused variable that is bound with let or as, and doesn&amp;rsquo;t start with an underscore (_) character.</source>
          <target state="translated">사용되지 않은 의심스러운 변수 : let 또는 as로 묶이고 밑줄 (_) 문자로 시작하지 않는 사용되지 않는 변수입니다.</target>
        </trans-unit>
        <trans-unit id="11e58b2b3353eee96248693f8d563d3b5cd65b17" translate="yes" xml:space="preserve">
          <source>Suspicious-looking end-of-comment mark.</source>
          <target state="translated">의심스러워 보이는 댓글 끝 표시입니다.</target>
        </trans-unit>
        <trans-unit id="ddf970710a96e309a4df7c47f666103b40de5ebd" translate="yes" xml:space="preserve">
          <source>Suspicious-looking start-of-comment mark.</source>
          <target state="translated">의심스러워 보이는 주석 시작 표시.</target>
        </trans-unit>
        <trans-unit id="3f84ef531f9db996694ad09a8fdddbca1440577e" translate="yes" xml:space="preserve">
          <source>Symbol</source>
          <target state="translated">Symbol</target>
        </trans-unit>
        <trans-unit id="cb92d9d71dc582fcaac304377564d4e993a5d6c9" translate="yes" xml:space="preserve">
          <source>Symbol binding</source>
          <target state="translated">심볼 바인딩</target>
        </trans-unit>
        <trans-unit id="8f08528b34287dbeb205e28df6f893eefe4bb6b5" translate="yes" xml:space="preserve">
          <source>Symbolic link</source>
          <target state="translated">심볼릭 링크</target>
        </trans-unit>
        <trans-unit id="1af7d6c34ea3d7825f1508a7baf71357f217a173" translate="yes" xml:space="preserve">
          <source>Symbolic links</source>
          <target state="translated">심볼릭 링크</target>
        </trans-unit>
        <trans-unit id="4bf49d12b0b857b45245352554b4248820e1c127" translate="yes" xml:space="preserve">
          <source>Symbolic pretty-printing</source>
          <target state="translated">상징적 인 예쁜 인쇄</target>
        </trans-unit>
        <trans-unit id="0fcc57bd9e40ddf977219a1819544a0cbcd1da68" translate="yes" xml:space="preserve">
          <source>Symbolic pretty-printing is pretty-printing using a symbolic formatter, i.e. a formatter that outputs symbolic pretty-printing items.</source>
          <target state="translated">Symbolic pretty-printing은 상징적 포맷터, 즉 상징적 pretty-printing 항목을 출력하는 포맷터를 사용하여 예쁘게 인쇄하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c30177fee17f9de0bfd94e899114fd091110383c" translate="yes" xml:space="preserve">
          <source>Symbols from the class &lt;a href=&quot;lex#infix-symbol&quot;&gt;infix-symbol&lt;/a&gt;, as well as the keywords *, +, -, -., =, !=, &amp;lt;, &amp;gt;, or, ||, &amp;amp;, &amp;amp;&amp;amp;, :=, mod, land, lor, lxor, lsl, lsr, and asr can appear in infix position (between two expressions). Symbols from the class &lt;a href=&quot;lex#prefix-symbol&quot;&gt;prefix-symbol&lt;/a&gt;, as well as the keywords - and -. can appear in prefix position (in front of an expression).</source>
          <target state="translated">&lt;a href=&quot;lex#infix-symbol&quot;&gt;infix-symbol&lt;/a&gt; 클래스 의 기호 와 키워드 *, +,-,-., =,! =, &amp;lt;,&amp;gt;, 또는, ||, &amp;amp;, &amp;amp;&amp;amp;, : =, mod, land, lor, lxor , lsl, lsr 및 asr은 중위 위치 (두 표현식 사이)에 나타날 수 있습니다. 클래스 &lt;a href=&quot;lex#prefix-symbol&quot;&gt;prefix-symbol&lt;/a&gt; 및 키워드-및-의 기호. 접두사 위치 (표현식 앞)에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b8e8468d047790eb587f1fdac4b8b2c2a97f950" translate="yes" xml:space="preserve">
          <source>Syntactically, building or matching constructors with such an inline record argument is similar to working with a unary constructor whose unique argument is a declared record type. A pattern can bind the inline record as a pseudo-value, but the record cannot escape the scope of the binding and can only be used with the dot-notation to extract or modify fields or to build new constructor values.</source>
          <target state="translated">구문 적으로 이러한 인라인 레코드 인수를 사용하여 생성자를 빌드하거나 일치시키는 것은 고유 인수가 선언 된 레코드 유형 인 단항 생성자를 사용하는 것과 유사합니다. 패턴은 인라인 레코드를 의사 값으로 바인딩 할 수 있지만 레코드는 바인딩 범위를 벗어날 수 없으며 점 표기법과 함께 만 사용하여 필드를 추출 또는 수정하거나 새 생성자 값을 빌드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92a7a4f198e3ad53204452742e2bcd85c8b76c8e" translate="yes" xml:space="preserve">
          <source>Syntax of command lines: A keyword is a character string starting with a &lt;code&gt;-&lt;/code&gt;. An option is a keyword alone or followed by an argument. The types of keywords are: &lt;code&gt;Unit&lt;/code&gt;, &lt;code&gt;Bool&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Clear&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;, &lt;code&gt;Set_string&lt;/code&gt;, &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Set_int&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt;, &lt;code&gt;Set_float&lt;/code&gt;, &lt;code&gt;Tuple&lt;/code&gt;, &lt;code&gt;Symbol&lt;/code&gt;, and &lt;code&gt;Rest&lt;/code&gt;. &lt;code&gt;Unit&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; and &lt;code&gt;Clear&lt;/code&gt; keywords take no argument. A &lt;code&gt;Rest&lt;/code&gt; keyword takes the remaining of the command line as arguments. Every other keyword takes the following word on the command line as argument. For compatibility with GNU getopt_long, &lt;code&gt;keyword=arg&lt;/code&gt; is also allowed. Arguments not preceded by a keyword are called anonymous arguments.</source>
          <target state="translated">명령 줄 구문 : 키워드는 &lt;code&gt;-&lt;/code&gt; 로 시작하는 문자열 입니다. 옵션은 키워드 단독이거나 인수가 뒤에 오는 것입니다. 키워드 유형은 &lt;code&gt;Unit&lt;/code&gt; , &lt;code&gt;Bool&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;Clear&lt;/code&gt; , &lt;code&gt;String&lt;/code&gt; , &lt;code&gt;Set_string&lt;/code&gt; , &lt;code&gt;Int&lt;/code&gt; , &lt;code&gt;Set_int&lt;/code&gt; , &lt;code&gt;Float&lt;/code&gt; , &lt;code&gt;Set_float&lt;/code&gt; , &lt;code&gt;Tuple&lt;/code&gt; , &lt;code&gt;Symbol&lt;/code&gt; 및 &lt;code&gt;Rest&lt;/code&gt; 입니다. &lt;code&gt;Unit&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; 및 &lt;code&gt;Clear&lt;/code&gt; 키워드에는 인수가 없습니다. &lt;code&gt;Rest&lt;/code&gt; keyword는 나머지 명령 줄을 인수로 사용합니다. 다른 모든 키워드는 명령 줄에서 다음 단어를 인수로 사용합니다. GNU getopt_long과의 호환성을 위해 &lt;code&gt;keyword=arg&lt;/code&gt; 도 허용됩니다. 키워드가 앞에 나오지 않는 인수를 익명 인수라고합니다.</target>
        </trans-unit>
        <trans-unit id="eea5f6535cf1464538bf913c29432e06b44c8a00" translate="yes" xml:space="preserve">
          <source>Sys</source>
          <target state="translated">Sys</target>
        </trans-unit>
        <trans-unit id="8f7a8d4494a0d458d18524d29c3ede9485be05c9" translate="yes" xml:space="preserve">
          <source>Sys.argv is an array of strings containing the command-line parameters. Sys.argv.(1) is thus the first command-line parameter. The program above is compiled and executed with the following shell commands:</source>
          <target state="translated">Sys.argv는 명령 줄 매개 변수를 포함하는 문자열 배열입니다. 따라서 Sys.argv. (1)은 첫 번째 명령 줄 매개 변수입니다. 위의 프로그램은 다음 쉘 명령으로 컴파일 및 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="77b1ff317375845ec33475f1b5fb67e6cbb973f9" translate="yes" xml:space="preserve">
          <source>System interface.</source>
          <target state="translated">시스템 인터페이스.</target>
        </trans-unit>
        <trans-unit id="475b7fafddd719ea508a449badf45b0789ac88b8" translate="yes" xml:space="preserve">
          <source>System threads. This implementation builds on the OS-provided threads facilities: POSIX 1003.1c threads for Unix, and Win32 threads for Windows. When available, system threads support both bytecode and native-code programs.</source>
          <target state="translated">시스템 스레드. 이 구현은 OS에서 제공하는 스레드 기능인 Unix 용 POSIX 1003.1c 스레드 및 Windows 용 Win32 스레드를 기반으로합니다. 사용 가능한 경우 시스템 스레드는 바이트 코드 및 원시 코드 프로그램을 모두 지원합니다.</target>
        </trans-unit>
        <trans-unit id="99901e02a798f32cd5219f56e51ca3215b2961b1" translate="yes" xml:space="preserve">
          <source>System time for the children processes</source>
          <target state="translated">하위 프로세스의 시스템 시간</target>
        </trans-unit>
        <trans-unit id="34a877dc56d7b6f22f1f4507a6f98d13c327981d" translate="yes" xml:space="preserve">
          <source>System time for the process</source>
          <target state="translated">프로세스의 시스템 시간</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="b3db3af9a0e0243f28ed20fcc3b1d5d1faaafbb6" translate="yes" xml:space="preserve">
          <source>TERM</source>
          <target state="translated">TERM</target>
        </trans-unit>
        <trans-unit id="c068ca8b042bac0232c1a1485f2405cfa98b7a00" translate="yes" xml:space="preserve">
          <source>Table cache</source>
          <target state="translated">테이블 캐시</target>
        </trans-unit>
        <trans-unit id="88d5168e6958719b1f51075705e987c63433b18e" translate="yes" xml:space="preserve">
          <source>Tabulation boxes</source>
          <target state="translated">표 상자</target>
        </trans-unit>
        <trans-unit id="982963c1c41cbed8cab073724749592fe35c532b" translate="yes" xml:space="preserve">
          <source>Tag</source>
          <target state="translated">Tag</target>
        </trans-unit>
        <trans-unit id="70ebce0319098abe29a21e0fc7bf392fb3792b10" translate="yes" xml:space="preserve">
          <source>Tag specific operations occur any time a tag is opened or closed, At each occurrence, two kinds of operations are performed &lt;em&gt;tag-marking&lt;/em&gt; and &lt;em&gt;tag-printing&lt;/em&gt;:</source>
          <target state="translated">태그 특정 작업은 태그가 열리거나 닫힐 때마다 발생하며, 각 발생시 &lt;em&gt;태그 표시&lt;/em&gt; 및 &lt;em&gt;태그 인쇄&lt;/em&gt; 두 종류의 작업이 수행 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="21049d0d0e09867c94c7bfdcd7af965832440243" translate="yes" xml:space="preserve">
          <source>Tag-marking a semantic tag means calling the formatter specific function &lt;code&gt;mark_open_stag&lt;/code&gt; (resp. &lt;code&gt;mark_close_stag&lt;/code&gt;) with the name of the tag as argument: that tag-marking function can then return the 'tag-opening marker' (resp. `tag-closing marker') for direct output into the output device of the formatter.</source>
          <target state="translated">의미 론적 태그에 태그 표시는 태그 이름을 인수로 사용 하여 포맷터 특정 함수 &lt;code&gt;mark_open_stag&lt;/code&gt; (resp. &lt;code&gt;mark_close_stag&lt;/code&gt; )를 호출하는 것을 의미 합니다. 그러면 해당 태그 표시 함수는 '태그 열기 마커'(관련`태그 닫기 마커)를 반환 할 수 있습니다. ') 포맷터의 출력 장치로 직접 출력합니다.</target>
        </trans-unit>
        <trans-unit id="d0850e7bae659968c87fcd011c8098d48caf5ca1" translate="yes" xml:space="preserve">
          <source>Tag-marking and tag-printing functions are user definable and can be set by calling &lt;a href=&quot;format#VALset_formatter_stag_functions&quot;&gt;&lt;code&gt;Format.set_formatter_stag_functions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">태그 표시 및 태그 인쇄 기능은 사용자가 정의 할 수 있으며 &lt;a href=&quot;format#VALset_formatter_stag_functions&quot;&gt; &lt;code&gt;Format.set_formatter_stag_functions&lt;/code&gt; &lt;/a&gt; 를 호출하여 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f087082b531d3d70af061b2f9983efc04fdab93a" translate="yes" xml:space="preserve">
          <source>Tag-printing a semantic tag means calling the formatter specific function &lt;code&gt;print_open_stag&lt;/code&gt; (resp. &lt;code&gt;print_close_stag&lt;/code&gt;) with the name of the tag as argument: that tag-printing function can then print any regular material to the formatter (so that this material is enqueued as usual in the formatter queue for further line splitting computation).</source>
          <target state="translated">의미 론적 태그를 태그 인쇄하는 것은 태그 이름을 인수로 사용 하여 포맷터 특정 함수 &lt;code&gt;print_open_stag&lt;/code&gt; (resp. &lt;code&gt;print_close_stag&lt;/code&gt; )를 호출하는 것을 의미 합니다. 그러면 해당 태그 인쇄 함수는 모든 일반 자료를 포맷터에 인쇄 할 수 있습니다 (이 자료는 평소와 같이 대기열에 포함됩니다). 추가 라인 분할 계산을 위해 포맷터 큐에서).</target>
        </trans-unit>
        <trans-unit id="3d968d48d29a395bb82a38da27ee9373279edc48" translate="yes" xml:space="preserve">
          <source>Tag_val(v) returns the tag of the block v.</source>
          <target state="translated">Tag_val (v)는 v 블록의 태그를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="69680e9274247feaf41570c80b33d43c4f2d8bcd" translate="yes" xml:space="preserve">
          <source>Take one of the symbols as argument and call the function with the symbol</source>
          <target state="translated">기호 중 하나를 인수로 취하고 기호를 사용하여 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="9d6b053ba3ae57bbab0f9ae23dd3906806ecb54b" translate="yes" xml:space="preserve">
          <source>Take several arguments according to the spec list</source>
          <target state="translated">사양 목록에 따라 여러 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="10762317d708b72b78e81e7071b82e94c42de1fc" translate="yes" xml:space="preserve">
          <source>Tangent.</source>
          <target state="translated">Tangent.</target>
        </trans-unit>
        <trans-unit id="780ae66c320e72eed30e1ed6d7739b9ecffb29da" translate="yes" xml:space="preserve">
          <source>Tangent. Argument is in radians.</source>
          <target state="translated">접선. 인수는 라디안입니다.</target>
        </trans-unit>
        <trans-unit id="8038dd5c0175f8f3d04e597ad2fbb9eac4f72a1c" translate="yes" xml:space="preserve">
          <source>Target ratio of floating garbage to major heap size for out-of-heap memory held by custom values located in the major heap. The GC speed is adjusted to try to use this much memory for dead values that are not yet collected. Expressed as a percentage of major heap size. The default value keeps the out-of-heap floating garbage about the same size as the in-heap overhead. Note: this only applies to values allocated with &lt;code&gt;caml_alloc_custom_mem&lt;/code&gt; (e.g. bigarrays). Default: 44.</source>
          <target state="translated">메이저 힙에있는 사용자 지정 값이 보유한 힙 부족 메모리에 대한 부동 가비지 대 메이저 힙 크기의 목표 비율입니다. GC 속도는 아직 수집되지 않은 데드 값에 대해이 정도의 메모리를 사용하도록 조정됩니다. 주요 힙 크기의 백분율로 표시됩니다. 기본값은 힙이 아닌 부동 가비지를 힙 내 오버 헤드와 거의 같은 크기로 유지합니다. 참고 : 이것은 &lt;code&gt;caml_alloc_custom_mem&lt;/code&gt; (예 : bigarrays)으로 할당 된 값에만 적용됩니다 . 기본값 : 44.</target>
        </trans-unit>
        <trans-unit id="2fe258cc46692204a632aee373f4075f030d57a7" translate="yes" xml:space="preserve">
          <source>Tell the debugger it is executed under Emacs. (See section &lt;a href=&quot;#s%3Ainf-debugger&quot;&gt;17.10&lt;/a&gt; for information on how to run the debugger under Emacs.)</source>
          <target state="translated">디버거에게 Emacs에서 실행된다고 알려줍니다. ( Emacs에서 디버거를 실행하는 방법에 대한 정보는 섹션 &lt;a href=&quot;#s%3Ainf-debugger&quot;&gt;17.10&lt;/a&gt; 을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="19b9145b33f4838c5f3973e7a6ea5d0f05c03b03" translate="yes" xml:space="preserve">
          <source>Tell whether the lexer buffer keeps track of position fields &lt;code&gt;lex_curr_p&lt;/code&gt; / &lt;code&gt;lex_start_p&lt;/code&gt;, as determined by the corresponding optional argument for functions that create lexer buffers (whose default value is &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">렉서 버퍼 를 생성하는 함수에 대한 해당 선택적 인수 (기본값이 &lt;code&gt;true&lt;/code&gt; )에 의해 결정된대로 렉서 버퍼가 위치 필드 &lt;code&gt;lex_curr_p&lt;/code&gt; / &lt;code&gt;lex_start_p&lt;/code&gt; 를 추적하는지 여부를 알려줍니다 .</target>
        </trans-unit>
        <trans-unit id="d7cd37004c27ae67bd613fe7aaf8dda4c2d384cf" translate="yes" xml:space="preserve">
          <source>Terminal interface</source>
          <target state="translated">터미널 인터페이스</target>
        </trans-unit>
        <trans-unit id="df7e4a1d29e38609effa51863fd181383dbf7780" translate="yes" xml:space="preserve">
          <source>Terminal read from background process</source>
          <target state="translated">백그라운드 프로세스에서 읽은 터미널</target>
        </trans-unit>
        <trans-unit id="69f382ea876bbdcbdd4d90e629da7780e4617313" translate="yes" xml:space="preserve">
          <source>Terminal write from background process</source>
          <target state="translated">백그라운드 프로세스에서 터미널 쓰기</target>
        </trans-unit>
        <trans-unit id="4813943164d0564fe70ad323f19653347b352115" translate="yes" xml:space="preserve">
          <source>Terminate prematurely the currently executing thread.</source>
          <target state="translated">현재 실행중인 스레드를 조기에 종료합니다.</target>
        </trans-unit>
        <trans-unit id="56b1260afe50cb577a901efc314311be666089c4" translate="yes" xml:space="preserve">
          <source>Terminate prematurely the thread whose handle is given.</source>
          <target state="translated">핸들이 주어진 스레드를 조기에 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="26070bd7d4995159490297bd3d133957b3f011a9" translate="yes" xml:space="preserve">
          <source>Terminate the process, returning the given status code to the operating system: usually 0 to indicate no errors, and a small positive integer to indicate failure.</source>
          <target state="translated">프로세스를 종료하고 주어진 상태 코드를 운영 체제에 반환합니다. 일반적으로 오류가없는 경우 0을, 실패를 나타내는 작은 양의 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0574c95a3a93d600e83a6f17eb926a568c0f9796" translate="yes" xml:space="preserve">
          <source>Terminate the process, returning the given status code to the operating system: usually 0 to indicate no errors, and a small positive integer to indicate failure. All open output channels are flushed with &lt;code&gt;flush_all&lt;/code&gt;. An implicit &lt;code&gt;exit&amp;nbsp;0&lt;/code&gt; is performed each time a program terminates normally. An implicit &lt;code&gt;exit&amp;nbsp;2&lt;/code&gt; is performed if the program terminates early because of an uncaught exception.</source>
          <target state="translated">프로세스를 종료하고 주어진 상태 코드를 운영 체제에 반환합니다. 일반적으로 오류가없는 경우 0을, 실패를 나타내는 작은 양의 정수를 반환합니다. 열려있는 모든 출력 채널은 &lt;code&gt;flush_all&lt;/code&gt; 으로 플러시됩니다 . 내재적 &lt;code&gt;exit&amp;nbsp;0&lt;/code&gt; 은 프로그램이 정상적으로 종료 될 때마다 수행됩니다. 포착되지 않은 예외로 인해 프로그램이 조기에 종료되는 경우 내재적 &lt;code&gt;exit&amp;nbsp;2&lt;/code&gt; 가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2ee85218866a19e0d9f6c52c176e4eaf9d0877b2" translate="yes" xml:space="preserve">
          <source>Termination</source>
          <target state="translated">Termination</target>
        </trans-unit>
        <trans-unit id="158a94f8a2ff46fde496827d38e93851db51f5cc" translate="yes" xml:space="preserve">
          <source>Termination (cannot be ignored)</source>
          <target state="translated">종료 (무시할 수 없음)</target>
        </trans-unit>
        <trans-unit id="bb7a1f1e99b2c211113bd77cc5e7ef277a13ed74" translate="yes" xml:space="preserve">
          <source>Test &amp;ldquo;greater than or equal&amp;rdquo;.</source>
          <target state="translated">&quot;크거나 같음&quot;을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="cf55a085e33342b3081a9dd990d9070f808b5872" translate="yes" xml:space="preserve">
          <source>Test &amp;ldquo;greater than&amp;rdquo;.</source>
          <target state="translated">&quot;보다 큼&quot;을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="8c0f5c5dfaba7d5a348d0be90ebda99ec96925bd" translate="yes" xml:space="preserve">
          <source>Test &amp;ldquo;less than or equal&amp;rdquo;.</source>
          <target state="translated">&quot;작거나 같음&quot;을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="9023e669869c2a8e4df262bd37b076a1baa1f732" translate="yes" xml:space="preserve">
          <source>Test &amp;ldquo;less than&amp;rdquo;.</source>
          <target state="translated">&quot;보다 작음&quot;을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="4da88b01def945bdf24685deea788a8bc6d1da26" translate="yes" xml:space="preserve">
          <source>Test a region for other process locks</source>
          <target state="translated">다른 프로세스 잠금에 대한 영역 테스트</target>
        </trans-unit>
        <trans-unit id="1787fedd7d2ced2ae48a3c3ae605449bb9a29103" translate="yes" xml:space="preserve">
          <source>Test if a file with the given name exists.</source>
          <target state="translated">주어진 이름의 파일이 존재하는지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="b5d1af12b9f30270fd2ed2ad3dee29830b903b74" translate="yes" xml:space="preserve">
          <source>Test if two sets are disjoint.</source>
          <target state="translated">두 세트가 분리되어 있는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="e1ac6c65bc9783f51306843b3f179afc02bc939b" translate="yes" xml:space="preserve">
          <source>Test whether a map is empty or not.</source>
          <target state="translated">지도가 비어 있는지 여부를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="9521be20f61e3370ee61a403fa6f607a9a6420ea" translate="yes" xml:space="preserve">
          <source>Test whether a set is empty or not.</source>
          <target state="translated">세트가 비어 있는지 여부를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="862bb20b2924b0e1bad9177d10a2c297215a311c" translate="yes" xml:space="preserve">
          <source>Tests if the maximum number of pretty-printing boxes allowed have already been opened.</source>
          <target state="translated">허용되는 예쁜 인쇄 상자의 최대 수가 이미 열려 있는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="d4721ae7197912536ec105c3ffe10fe5fe1d70fa" translate="yes" xml:space="preserve">
          <source>That is, the fun expression above evaluates to a curried function with n arguments: after applying this function n times to the values v&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; v&lt;sub&gt;n&lt;/sub&gt;, the values will be matched in parallel against the patterns &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. If the matching succeeds, the function returns the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; in an environment enriched by the bindings performed during the matchings. If the matching fails, the exception Match_failure is raised.</source>
          <target state="translated">즉, 위의 fun 표현식은 n 개의 인수가있는 카레 함수로 평가됩니다.이 함수를 값 v &lt;sub&gt;1&lt;/sub&gt; &amp;hellip; v &lt;sub&gt;n에&lt;/sub&gt; n 번 적용 하면 값이 패턴 &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 에 대해 병렬로 일치됩니다 . 일치가 성공하면 함수는 일치하는 동안 수행 된 바인딩으로 강화 된 환경에서 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 값을 반환합니다 . 일치가 실패하면 Match_failure 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bb5dc7fe2f26372eda5226bac4a48e313d4e2b62" translate="yes" xml:space="preserve">
          <source>That is, to define a new generator, one must implement a module with the expected signature, and with the given generator class, providing the generate method as entry point to make the generator generates documentation for a given list of modules :</source>
          <target state="translated">즉, 새 생성기를 정의하려면 예상되는 서명이있는 모듈을 구현하고 주어진 생성기 클래스를 사용하여 생성기가 주어진 모듈 목록에 대한 문서를 생성하도록 생성 메소드를 진입 점으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="7ed38f27c94cab8c8d12304ae06126526d04b8bb" translate="yes" xml:space="preserve">
          <source>The (type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;) syntax construction by itself does not make polymorphic the type variable it introduces, but it can be combined with explicit polymorphic annotations where needed. The above rule is provided as syntactic sugar to make this easier:</source>
          <target state="translated">(type &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt; ) 구문 생성 자체는 그것이 도입하는 유형 변수를 다형성으로 만들지 않지만 필요한 경우 명시 적 다형성 주석과 결합 할 수 있습니다. 위의 규칙은이를 쉽게하기 위해 구문 설탕으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c4991a041e774dadbe4b581939be63f5a7cbe4ea" translate="yes" xml:space="preserve">
          <source>The -no-stop option to ocamldoc causes the Stop special comments to be ignored.</source>
          <target state="translated">ocamldoc에 대한 -no-stop 옵션을 사용하면 Stop 특수 주석이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3147fca5c37d9a1563cc013c628673b530b03e57" translate="yes" xml:space="preserve">
          <source>The -opaque option, available since 4.04, disables cross-module optimization information for the currently compiled unit. When compiling .mli interface, using -opaque marks the compiled .cmi interface so that subsequent compilations of modules that depend on it will not rely on the corresponding .cmx file, nor warn if it is absent. When the native compiler compiles a .ml implementation, using -opaque generates a .cmx that does not contain any cross-module optimization information.</source>
          <target state="translated">4.04부터 사용 가능한 -opaque 옵션은 현재 컴파일 된 유닛에 대한 교차 모듈 최적화 정보를 비활성화합니다. .mli 인터페이스를 컴파일 할 때 -opaque를 사용하면 컴파일 된 .cmi 인터페이스가 표시되어 이에 종속 된 모듈의 후속 컴파일이 해당 .cmx 파일에 의존하지 않거나없는 경우 경고하지 않습니다. 네이티브 컴파일러가 .ml 구현을 컴파일 할 때 -opaque를 사용하면 교차 모듈 최적화 정보가 포함되지 않은 .cmx가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="564904d19df6fc8011ad3d2bee2ea1a4e77ad2e7" translate="yes" xml:space="preserve">
          <source>The -output-obj option can also be used to obtain the C source file. More interestingly, the same option can also produce directly a shared library (.so file, .dll under Windows) that contains the OCaml code, the OCaml runtime system and any other static C code given to ocamlc (.o, .a, respectively, .obj, .lib). This use of -output-obj is very similar to a normal linking step, but instead of producing a main program that automatically runs the OCaml code, it produces a shared library that can run the OCaml code on demand. The three possible behaviors of -output-obj are selected according to the extension of the resulting file (given with -o).</source>
          <target state="translated">-output-obj 옵션을 사용하여 C 소스 파일을 가져올 수도 있습니다. 더 흥미롭게도 동일한 옵션은 OCaml 코드, OCaml 런타임 시스템 및 ocamlc에 제공된 기타 정적 C 코드 (각각 .o, .a)를 포함하는 공유 라이브러리 (Windows에서는 .so 파일, .dll)를 직접 생성 할 수도 있습니다. , .obj, .lib). -output-obj의 사용은 일반적인 연결 단계와 매우 유사하지만 OCaml 코드를 자동으로 실행하는 주 프로그램을 생성하는 대신 요청시 OCaml 코드를 실행할 수있는 공유 라이브러리를 생성합니다. -output-obj의 세 가지 가능한 동작은 결과 파일의 확장자 (-o로 제공됨)에 따라 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="3b36f21e3b344b1468a19dcfe1a7ba5421f00dae" translate="yes" xml:space="preserve">
          <source>The -unbox-closures-factor command line flag, which takes an integer, may be used to adjust the point at which a function is deemed large enough to be ineligible for duplication. The benefit of duplication is scaled by the integer before being evaluated against the size.</source>
          <target state="translated">정수를 취하는 -unbox-closures-factor 명령 행 플래그는 함수가 복제에 적합하지 않을만큼 충분히 큰 것으로 간주되는 지점을 조정하는 데 사용될 수 있습니다. 중복의 이점은 크기에 대해 평가되기 전에 정수로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="a2209f3894b8163766592d29f0ebe68de13e2bfb" translate="yes" xml:space="preserve">
          <source>The .cmi and .cmo files produced by the compiler have the same base name as the source file. Hence, the compiled files always have their base name equal (modulo capitalization of the first letter) to the name of the module they describe (for .cmi files) or implement (for .cmo files).</source>
          <target state="translated">컴파일러에서 생성 된 .cmi 및 .cmo 파일은 소스 파일과 동일한 기본 이름을 갖습니다. 따라서 컴파일 된 파일은 항상 설명 (.cmi 파일의 경우) 또는 구현 (.cmo 파일의 경우) 모듈의 이름과 동일한 기본 이름 (첫 글자의 모듈로 대문자 사용)을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b721260b32a59d156249128e83aba8efd5e1aba3" translate="yes" xml:space="preserve">
          <source>The .cmx object files being combined must have been compiled with the appropriate -for-pack option. In the example above, A.cmx, B.cmx and C.cmx must have been compiled with ocamlopt -for-pack P.</source>
          <target state="translated">결합되는 .cmx 개체 파일은 적절한 -for-pack 옵션으로 컴파일되어야합니다. 위의 예에서 A.cmx, B.cmx 및 C.cmx는 ocamlopt -for-pack P로 컴파일되어야합니다.</target>
        </trans-unit>
        <trans-unit id="19cf8b2f632836f4f34c4d1b723f6f2c4408241e" translate="yes" xml:space="preserve">
          <source>The 32-bit integer -1.</source>
          <target state="translated">32 비트 정수 -1입니다.</target>
        </trans-unit>
        <trans-unit id="25bfbe3425f7612c84c4a60433757b0cd2caa725" translate="yes" xml:space="preserve">
          <source>The 32-bit integer 0.</source>
          <target state="translated">32 비트 정수 0입니다.</target>
        </trans-unit>
        <trans-unit id="adf5ef41fc3f6cfaf4d8f1db7abf1ec88c03da49" translate="yes" xml:space="preserve">
          <source>The 32-bit integer 1.</source>
          <target state="translated">32 비트 정수 1입니다.</target>
        </trans-unit>
        <trans-unit id="006eed8987b86bde9c7f054166d4c4843fab6c03" translate="yes" xml:space="preserve">
          <source>The 64-bit integer -1.</source>
          <target state="translated">64 비트 정수 -1입니다.</target>
        </trans-unit>
        <trans-unit id="157479d5f01ffa68d3fe29e3a78c6d437b79bcf0" translate="yes" xml:space="preserve">
          <source>The 64-bit integer 0.</source>
          <target state="translated">64 비트 정수 0입니다.</target>
        </trans-unit>
        <trans-unit id="629c9977446445c9cf7c1aa59f2924bbe702fd82" translate="yes" xml:space="preserve">
          <source>The 64-bit integer 1.</source>
          <target state="translated">64 비트 정수 1입니다.</target>
        </trans-unit>
        <trans-unit id="6b95251b3f2b1a3e28a4b746eb2d6fd549aedfc0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; syntactic class appearing in the (module&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) type expression and in the annotated forms represents a subset of module types. This subset consists of named module types with optional constraints of a limited form: only non-parametrized types can be specified.</source>
          <target state="translated">&lt;a href=&quot;#package-type&quot;&gt;패키지 형&lt;/a&gt; 제 (모듈에서 나타나는 통사 클래스 &lt;a href=&quot;#package-type&quot;&gt;패키지 형&lt;/a&gt; ) 형 식과 주석 형태는 모듈 종류의 서브 세트를 나타낸다. 이 하위 집합은 제한된 형식의 선택적 제약 조건이있는 명명 된 모듈 유형으로 구성됩니다. 매개 변수화되지 않은 유형 만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6682753740053ec4013bd76f06934bf2221ce480" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt; should describe when the element was deprecated, what to use as a replacement, and possibly the reason for deprecation.</source>
          <target state="translated">&lt;a href=&quot;#text&quot;&gt;텍스트&lt;/a&gt; 요소가 사용되지 않습니다 때, 교체 및 중단에 대한 가능한 이유로 무엇을 사용하여 설명한다.</target>
        </trans-unit>
        <trans-unit id="cde17ed2d9a66d67e67d6fe2b53d455fb37fc839" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; functor constructs implementations for any type, given a &lt;code&gt;compare&lt;/code&gt; function. For instance:</source>
          <target state="translated">&lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; 의&lt;/a&gt; 펑 주어진 어떤 타입의 구현을 구성 &lt;code&gt;compare&lt;/code&gt; 기능. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="a4ed2561f30b1f4e9552cc537f7755aeeba34c0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0u&lt;/code&gt; prefix reads the input as an unsigned integer in the range &lt;code&gt;[0,&amp;nbsp;2*Int32.max_int+1]&lt;/code&gt;. If the input exceeds &lt;a href=&quot;int32#VALmax_int&quot;&gt;&lt;code&gt;Int32.max_int&lt;/code&gt;&lt;/a&gt; it is converted to the signed integer &lt;code&gt;Int32.min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;Int32.max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0u&lt;/code&gt; 프리픽스 범위의 부호없는 정수로 입력을 판독 &lt;code&gt;[0,&amp;nbsp;2*Int32.max_int+1]&lt;/code&gt; . 입력이 &lt;a href=&quot;int32#VALmax_int&quot;&gt; &lt;code&gt;Int32.max_int&lt;/code&gt; 를&lt;/a&gt; 초과 하면 부호있는 정수 &lt;code&gt;Int32.min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;Int32.max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="23dffe6eb51ba2abaa4cfa566ea1b02078814e57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0u&lt;/code&gt; prefix reads the input as an unsigned integer in the range &lt;code&gt;[0,&amp;nbsp;2*Int64.max_int+1]&lt;/code&gt;. If the input exceeds &lt;a href=&quot;int64#VALmax_int&quot;&gt;&lt;code&gt;Int64.max_int&lt;/code&gt;&lt;/a&gt; it is converted to the signed integer &lt;code&gt;Int64.min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;Int64.max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0u&lt;/code&gt; 프리픽스 범위의 부호없는 정수로 입력을 판독 &lt;code&gt;[0,&amp;nbsp;2*Int64.max_int+1]&lt;/code&gt; . 입력이 &lt;a href=&quot;int64#VALmax_int&quot;&gt; &lt;code&gt;Int64.max_int&lt;/code&gt; 를&lt;/a&gt; 초과 하면 부호있는 정수 &lt;code&gt;Int64.min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;Int64.max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="2bdf559646ed66e4c76c9311859fb36ebd722036" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0u&lt;/code&gt; prefix reads the input as an unsigned integer in the range &lt;code&gt;[0,&amp;nbsp;2*Nativeint.max_int+1]&lt;/code&gt;. If the input exceeds &lt;a href=&quot;nativeint#VALmax_int&quot;&gt;&lt;code&gt;Nativeint.max_int&lt;/code&gt;&lt;/a&gt; it is converted to the signed integer &lt;code&gt;Int64.min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;Nativeint.max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0u&lt;/code&gt; 프리픽스 범위의 부호없는 정수로 입력을 판독 &lt;code&gt;[0,&amp;nbsp;2*Nativeint.max_int+1]&lt;/code&gt; . 입력이 &lt;a href=&quot;nativeint#VALmax_int&quot;&gt; &lt;code&gt;Nativeint.max_int&lt;/code&gt; 를&lt;/a&gt; 초과 하면 부호있는 정수 &lt;code&gt;Int64.min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;Nativeint.max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="3d37cd54b36382c9e5496e2092f5aaa8dc45ad01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0u&lt;/code&gt; prefix reads the input as an unsigned integer in the range &lt;code&gt;[0,&amp;nbsp;2*max_int+1]&lt;/code&gt;. If the input exceeds &lt;a href=&quot;stdlib#VALmax_int&quot;&gt;&lt;code&gt;max_int&lt;/code&gt;&lt;/a&gt; it is converted to the signed integer &lt;code&gt;min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0u&lt;/code&gt; 프리픽스 범위의 부호없는 정수로 입력을 판독 &lt;code&gt;[0,&amp;nbsp;2*max_int+1]&lt;/code&gt; . 입력이 &lt;a href=&quot;stdlib#VALmax_int&quot;&gt; &lt;code&gt;max_int&lt;/code&gt; 를&lt;/a&gt; 초과 하면 부호있는 정수 &lt;code&gt;min_int&amp;nbsp;+&amp;nbsp;input&amp;nbsp;-&amp;nbsp;max_int&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="61b166f6086faf0c742754df16fab62941896c59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Exit&lt;/code&gt; exception is not raised by any library function.</source>
          <target state="translated">&lt;code&gt;Exit&lt;/code&gt; 예외는 어떤 라이브러리 함수에 의해 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="618dcafc239b4a1cd930e5a52c4ba8ab644cc7e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Exit&lt;/code&gt; exception is not raised by any library function. It is provided for use in your programs.</source>
          <target state="translated">&lt;code&gt;Exit&lt;/code&gt; 예외는 어떤 라이브러리 함수에 의해 발생하지 않습니다. 프로그램에서 사용하기 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="54bcc8ec2f507902da16600415bbcb8e20ed4f95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;F_LOCK&lt;/code&gt; and &lt;code&gt;F_TLOCK&lt;/code&gt; commands attempts to put a write lock on the specified region. The &lt;code&gt;F_RLOCK&lt;/code&gt; and &lt;code&gt;F_TRLOCK&lt;/code&gt; commands attempts to put a read lock on the specified region. If one or several locks put by another process prevent the current process from acquiring the lock, &lt;code&gt;F_LOCK&lt;/code&gt; and &lt;code&gt;F_RLOCK&lt;/code&gt; block until these locks are removed, while &lt;code&gt;F_TLOCK&lt;/code&gt; and &lt;code&gt;F_TRLOCK&lt;/code&gt; fail immediately with an exception. The &lt;code&gt;F_ULOCK&lt;/code&gt; removes whatever locks the current process has on the specified region. Finally, the &lt;code&gt;F_TEST&lt;/code&gt; command tests whether a write lock can be acquired on the specified region, without actually putting a lock. It returns immediately if successful, or fails otherwise.</source>
          <target state="translated">&lt;code&gt;F_LOCK&lt;/code&gt; 및 &lt;code&gt;F_TLOCK&lt;/code&gt; 명령 시도는 지정된 지역에 쓰기 잠금을 넣어. &lt;code&gt;F_RLOCK&lt;/code&gt; 및 &lt;code&gt;F_TRLOCK&lt;/code&gt; 는 지정된 지역에 읽기 잠금을 넣어 시도를 명령한다. 다른 프로세스가 하나 또는 여러 개의 잠금을 설정하여 현재 프로세스가 잠금을 획득하지 못하는 경우 이러한 잠금이 제거 될 때까지 &lt;code&gt;F_LOCK&lt;/code&gt; 및 &lt;code&gt;F_RLOCK&lt;/code&gt; 이 차단되고 &lt;code&gt;F_TLOCK&lt;/code&gt; 및 &lt;code&gt;F_TRLOCK&lt;/code&gt; 은 예외와 함께 즉시 실패합니다. &lt;code&gt;F_ULOCK&lt;/code&gt; 의 현재 프로세스를 고정 무엇이든 제거합니다는 지정된 지역에 있습니다. 마지막으로 &lt;code&gt;F_TEST&lt;/code&gt; 명령은 실제로 잠금을 설정하지 않고 지정된 영역에서 쓰기 잠금을 획득 할 수 있는지 여부를 테스트합니다. 성공하면 즉시 반환되고 그렇지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="38136ee726cf908eb5522e7345bd976551936ebd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Format&lt;/code&gt; module is versatile enough to let you completely redefine the meaning of pretty-printing output: you may provide your own functions to define how to handle indentation, line splitting, and even printing of all the characters that have to be printed!</source>
          <target state="translated">&lt;code&gt;Format&lt;/code&gt; 모듈은 완전히 꽤 - 인쇄 출력의 의미를 다시 정의 할 수 있도록 다양한 충분하다 : 당신은 들여 쓰기, 줄 분할, 심지어 인쇄 할 수있는 모든 문자의 인쇄를 처리하는 방법을 정의하기 위해 자신의 기능을 제공 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="68315cad3ec5fa750806e2fcfa1b99271143dfe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_&lt;/code&gt; (underscore) character can appear anywhere in the string and is ignored.</source>
          <target state="translated">&lt;code&gt;_&lt;/code&gt; (밑줄) 문자는 어디 문자열에 나타날 수 있으며 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0dcf95ffbbacb39e9db9049899df2d9baf6d087f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cloexec&lt;/code&gt; optional arguments and the &lt;code&gt;O_KEEPEXEC&lt;/code&gt; flag were introduced in OCaml 4.05. Earlier, the common practice was to create file descriptors in the default, ``keep-on-exec'' mode, then call &lt;code&gt;set_close_on_exec&lt;/code&gt; on those freshly-created file descriptors. This is not as safe as creating the file descriptor in ``close-on-exec'' mode because, in multithreaded programs, a window of vulnerability exists between the time when the file descriptor is created and the time &lt;code&gt;set_close_on_exec&lt;/code&gt; completes. If another thread spawns another program during this window, the descriptor will leak, as it is still in the ``keep-on-exec'' mode.</source>
          <target state="translated">&lt;code&gt;cloexec&lt;/code&gt; 선택적 인수와 &lt;code&gt;O_KEEPEXEC&lt;/code&gt; 의 플래그가 OCaml의 4.05에 도입되었다. 이전에는 기본``keep-on-exec ''모드에서 파일 설명자를 만든 다음 새로 만든 파일 설명자에 대해 &lt;code&gt;set_close_on_exec&lt;/code&gt; 를 호출하는 것이 일반적이었습니다 . 다중 스레드 프로그램에서는 파일 설명자가 생성 된 시점과 &lt;code&gt;set_close_on_exec&lt;/code&gt; 가 완료 되는 시점 사이에 취약점이 존재하기 때문에``close-on-exec ''모드에서 파일 설명자를 생성하는 것만 큼 안전하지 않습니다 . 이 기간 동안 다른 스레드가 다른 프로그램을 생성하면 디스크립터가 여전히``keep-on-exec ''모드에 있기 때문에 누출됩니다.</target>
        </trans-unit>
        <trans-unit id="1eb7c114770073f6910d08925899aa9381142883" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compare&lt;/code&gt; function can be used as the comparison function required by the &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt; functors, as well as the &lt;a href=&quot;list#VALsort&quot;&gt;&lt;code&gt;List.sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;array#VALsort&quot;&gt;&lt;code&gt;Array.sort&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">&lt;code&gt;compare&lt;/code&gt; 함수가 필요한 비교 함수로서 사용될 수있다 &lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; &lt;/a&gt; 펑뿐만 아니라 &lt;a href=&quot;list#VALsort&quot;&gt; &lt;code&gt;List.sort&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;array#VALsort&quot;&gt; &lt;code&gt;Array.sort&lt;/code&gt; &lt;/a&gt; 기능한다.</target>
        </trans-unit>
        <trans-unit id="9e2d6e8ecc1f534250d3b0fe9ad0f7fcb8f3fbb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equal&lt;/code&gt; relation must be able to work on a shallow copy of the values and give the same result as with the values themselves.</source>
          <target state="translated">&lt;code&gt;equal&lt;/code&gt; 관계는 값의 얕은 복사 작업 및 값 자체와 동일한 결과를 제공 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="42475c29a84bb6547470710fd8e643615f2c721d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;f&lt;/code&gt; function can use all features of OCaml, including assignments that make the value reachable again. It can also loop forever (in this case, the other finalisation functions will not be called during the execution of f, unless it calls &lt;code&gt;finalise_release&lt;/code&gt;). It can call &lt;code&gt;finalise&lt;/code&gt; on &lt;code&gt;v&lt;/code&gt; or other values to register other functions or even itself. It can raise an exception; in this case the exception will interrupt whatever the program was doing when the function was called.</source>
          <target state="translated">&lt;code&gt;f&lt;/code&gt; 기능은 다시 값 도달을 배정을 포함한 OCaml의 모든 기능을 사용할 수 있습니다. 또한 영원히 반복 될 수 있습니다 (이 경우 &lt;code&gt;finalise_release&lt;/code&gt; 를 호출하지 않는 한 다른 종료 함수는 f 실행 중에 호출되지 않습니다 ). &lt;code&gt;v&lt;/code&gt; 또는 다른 값 에 대해 &lt;code&gt;finalise&lt;/code&gt; 를 호출 하여 다른 함수 또는 자체를 등록 할 수 있습니다. 예외가 발생할 수 있습니다. 이 경우 예외는 함수가 호출되었을 때 프로그램이 수행하던 모든 작업을 중단합니다.</target>
        </trans-unit>
        <trans-unit id="b556f0336e223bedcd6066a8e647fbdbfaf3934e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flush&lt;/code&gt; function is called whenever the pretty-printer is flushed (via conversion &lt;code&gt;%!&lt;/code&gt;, or pretty-printing indications &lt;code&gt;@?&lt;/code&gt; or &lt;code&gt;@.&lt;/code&gt;, or using low level functions &lt;code&gt;print_flush&lt;/code&gt; or &lt;code&gt;print_newline&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;flush&lt;/code&gt; 기능은 매우 인쇄기가 플러싱 될 때마다 (변환 통해 호출 &lt;code&gt;%!&lt;/code&gt; , 또는 징후를 꽤 인자 &lt;code&gt;@?&lt;/code&gt; 또는 &lt;code&gt;@.&lt;/code&gt; 또는 로우 레벨 기능을 사용 &lt;code&gt;print_flush&lt;/code&gt; 또는 &lt;code&gt;print_newline&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="27ca5eda4c43f08d46a2c695faa646d521db2882" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;out&lt;/code&gt; function performs all the pretty-printer string output. It is called with a string &lt;code&gt;s&lt;/code&gt;, a start position &lt;code&gt;p&lt;/code&gt;, and a number of characters &lt;code&gt;n&lt;/code&gt;; it is supposed to output characters &lt;code&gt;p&lt;/code&gt; to &lt;code&gt;p&amp;nbsp;+&amp;nbsp;n&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; 기능을 수행하는 모든 꽤-프린터 문자열 출력. 문자열 &lt;code&gt;s&lt;/code&gt; , 시작 위치 &lt;code&gt;p&lt;/code&gt; 및 여러 문자 &lt;code&gt;n&lt;/code&gt; 으로 호출됩니다 . 그것은 출력 문자로 예상되는 &lt;code&gt;p&lt;/code&gt; 에 &lt;code&gt;p&amp;nbsp;+&amp;nbsp;n&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; 의 &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75d43060306ebfa6fa32ab493326575601269afa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;print_&lt;/code&gt; field of the record contains the tag-printing functions that are called at tag opening and tag closing time, to output regular material in the pretty-printer queue.</source>
          <target state="translated">레코드 의 &lt;code&gt;print_&lt;/code&gt; 필드에는 프리티 프린터 대기열에 일반 자료를 출력하기 위해 태그 열기 및 태그 닫기 시간에 호출되는 태그 인쇄 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="056af88ed3bcf5589ed5c7b7003c98a7067f4a6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;print_open_stag&lt;/code&gt; tag-printing function of the formatter is called with &lt;code&gt;t&lt;/code&gt; as argument; then the opening tag marker for &lt;code&gt;t&lt;/code&gt;, as given by &lt;code&gt;mark_open_stag&amp;nbsp;t&lt;/code&gt;, is written into the output device of the formatter.</source>
          <target state="translated">&lt;code&gt;print_open_stag&lt;/code&gt; 의 print_open_stag 태그 인쇄 함수는 &lt;code&gt;t&lt;/code&gt; 를 인수로 사용 하여 호출됩니다 . 그런 다음 &lt;code&gt;mark_open_stag&amp;nbsp;t&lt;/code&gt; 로 지정된 &lt;code&gt;t&lt;/code&gt; 의 여는 태그 마커 가 포맷터의 출력 장치에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="e08dda4298e3191068d142ddd263ae997f8088ec" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;eventlog_metadata&lt;/em&gt; file can be found at this path and copied in the same directory as the generated trace file. However, &lt;em&gt;babeltrace&lt;/em&gt; expects the file to be named metadata in order to process the trace. Thus, it will need to be renamed when copied to the trace&amp;rsquo;s directory.</source>
          <target state="translated">&lt;em&gt;eventlog_metadata의&lt;/em&gt; 파일이 경로에서 발견 생성 된 추적 파일과 같은 디렉토리에 복사 할 수 있습니다. 그러나 &lt;em&gt;babeltrace&lt;/em&gt; 는 추적을 처리하기 위해 파일이 메타 데이터로 명명 될 것으로 예상합니다. 따라서 추적 디렉토리에 복사 할 때 이름을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="f53775be5e375c4dc7ef58b639a6d408285df99f" translate="yes" xml:space="preserve">
          <source>The AMD64 code generator (64-bit versions of Intel Pentium and AMD Athlon) supports the following additional options:</source>
          <target state="translated">AMD64 코드 생성기 (64 비트 버전의 Intel Pentium 및 AMD Athlon)는 다음과 같은 추가 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="fb87a73c92ae01d9c7c4db3849eb48ff0818dc23" translate="yes" xml:space="preserve">
          <source>The C code can then invoke OCaml functions using the callback mechanism (see section &lt;a href=&quot;#ss%3Ac-callbacks&quot;&gt;20.7.1&lt;/a&gt;).</source>
          <target state="translated">그런 다음 C 코드는 콜백 메커니즘을 사용하여 OCaml 함수를 호출 할 수 있습니다 (섹션 &lt;a href=&quot;#ss%3Ac-callbacks&quot;&gt;20.7.1&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="8e464c9797631ebce99ef6cccb7cb68c06035632" translate="yes" xml:space="preserve">
          <source>The C code can then recover the exception identifier using caml_named_value and pass it as first argument to the functions raise_constant, raise_with_arg, and raise_with_string (described in section &lt;a href=&quot;#ss%3Ac-exceptions&quot;&gt;20.4.5&lt;/a&gt;) to actually raise the exception. For example, here is a C function that raises the Error exception with the given argument:</source>
          <target state="translated">C 코드는 caml_named_value를 사용하여 예외 식별자를 복구하고 (제 절에서 설명 된 기능에 raise_constant 인수 raise_with_arg 및 raise_with_string로 전달할 수 &lt;a href=&quot;#ss%3Ac-exceptions&quot;&gt;20.4.5&lt;/a&gt; 실제 예외가 발생)이다. 예를 들어, 다음은 주어진 인수로 Error 예외를 발생시키는 C 함수입니다.</target>
        </trans-unit>
        <trans-unit id="aa93c2abc45968f3784b93eb9dcd8bd6529c1ecd" translate="yes" xml:space="preserve">
          <source>The C part of the program must provide a main function, which will override the default main function provided by the OCaml runtime system. Execution will start in the user-defined main function just like for a regular C program.</source>
          <target state="translated">프로그램의 C 부분은 OCaml 런타임 시스템에서 제공하는 기본 기본 기능을 재정의하는 기본 기능을 제공해야합니다. 일반 C 프로그램과 마찬가지로 사용자 정의 주 함수에서 실행이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="50e4f4eda019d6551e91347a8e71357c4a87e23b" translate="yes" xml:space="preserve">
          <source>The CAML macros use identifiers (local variables, type identifiers, structure tags) that start with caml__. Do not use any identifier starting with caml__ in your programs.</source>
          <target state="translated">CAML 매크로는 caml__로 시작하는 식별자 (로컬 변수, 유형 식별자, 구조 태그)를 사용합니다. 프로그램에서 caml__로 시작하는 식별자를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="947f7ca3d56e80606a767e9b12f1a9e600046008" translate="yes" xml:space="preserve">
          <source>The Flambda inlining heuristics, used whenever the compiler is configured for Flambda and -Oclassic was not specified, make inlining decisions at call sites. This helps in situations where the context is important. For example:</source>
          <target state="translated">컴파일러가 Flambda에 대해 구성되고 -Oclassic이 지정되지 않았을 때마다 사용되는 Flambda 인라인 휴리스틱은 호출 사이트에서 인라인 결정을 내립니다. 이는 컨텍스트가 중요한 상황에서 도움이됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="3d5b0d2b11b3ee57c6f9a2ae20c6f1a2b2492c1f" translate="yes" xml:space="preserve">
          <source>The Flambda mode is described in the next section.</source>
          <target state="translated">Flambda 모드는 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1a8cbe3e5a223fda241e040fe66da36a6dedfca0" translate="yes" xml:space="preserve">
          <source>The Flambda optimisers classify expressions in order to determine whether an expression:</source>
          <target state="translated">Flambda 옵티마이 저는 표현식이 다음과 같은지 여부를 결정하기 위해 표현식을 분류합니다.</target>
        </trans-unit>
        <trans-unit id="4a55df8086c936ee6955c4d5f1e4e9c60c3a3b17" translate="yes" xml:space="preserve">
          <source>The Flambda optimisers provide a variety of command-line flags that may be used to control their behaviour. Detailed descriptions of each flag are given in the referenced sections. Those sections also describe any arguments which the particular flags take.</source>
          <target state="translated">Flambda 옵티마이 저는 동작을 제어하는 ​​데 사용할 수있는 다양한 명령 줄 플래그를 제공합니다. 각 플래그에 대한 자세한 설명은 참조 섹션에 제공됩니다. 이 섹션은 또한 특정 플래그가 취하는 모든 인수를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1f41ece3d458792a5a112edf6fe3a0fc355449cf" translate="yes" xml:space="preserve">
          <source>The GADT type &lt;code&gt;'a&amp;nbsp;layout&lt;/code&gt; represents one of the two supported memory layouts: C-style or Fortran-style. Its constructors are re-exported as values below for backward-compatibility reasons.</source>
          <target state="translated">GADT 유형 &lt;code&gt;'a&amp;nbsp;layout&lt;/code&gt; 은 지원되는 두 가지 메모리 레이아웃 (C 스타일 또는 포트란 스타일) 중 하나를 나타냅니다. 생성자는 이전 버전과의 호환성을 위해 아래 값으로 다시 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="9592e7237389ee2174122cfd60652798cead6941" translate="yes" xml:space="preserve">
          <source>The GADT type &lt;code&gt;('a,&amp;nbsp;'b)&amp;nbsp;kind&lt;/code&gt; captures this association of an OCaml type &lt;code&gt;'a&lt;/code&gt; for values read or written in the Bigarray, and of an element kind &lt;code&gt;'b&lt;/code&gt; which represents the actual contents of the Bigarray. Its constructors list all possible associations of OCaml types with element kinds, and are re-exported below for backward-compatibility reasons.</source>
          <target state="translated">GADT 유형 &lt;code&gt;('a,&amp;nbsp;'b)&amp;nbsp;kind&lt;/code&gt; 는 Bigarray에서 읽거나 쓴 값 에 대한 OCaml 유형 &lt;code&gt;'a&lt;/code&gt; 와 Bigarray 의 실제 콘텐츠를 나타내는 요소 종류 &lt;code&gt;'b&lt;/code&gt; 의 이러한 연관성을 캡처합니다. 생성자는 요소 종류와 OCaml 유형의 가능한 모든 연관을 나열하며 이전 버전과의 호환성을 위해 아래에서 다시 내보내집니다.</target>
        </trans-unit>
        <trans-unit id="dd7b721d0850765e0f33c133f4e389240cfc627b" translate="yes" xml:space="preserve">
          <source>The GC parameters are given as a &lt;code&gt;control&lt;/code&gt; record.</source>
          <target state="translated">GC 매개 변수는 &lt;code&gt;control&lt;/code&gt; 레코드 로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="95efad48009e26c2e773fa9f3a23237febe8ef7a" translate="yes" xml:space="preserve">
          <source>The GC parameters are given as a &lt;code&gt;control&lt;/code&gt; record. Note that these parameters can also be initialised by setting the OCAMLRUNPARAM environment variable. See the documentation of &lt;code&gt;ocamlrun&lt;/code&gt;.</source>
          <target state="translated">GC 매개 변수는 &lt;code&gt;control&lt;/code&gt; 레코드 로 제공됩니다 . 이러한 매개 변수는 OCAMLRUNPARAM 환경 변수를 설정하여 초기화 할 수도 있습니다. &lt;code&gt;ocamlrun&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c85d7c1fb9f174f09ac7febf2cc5071806120427" translate="yes" xml:space="preserve">
          <source>The GC will call the finalisation functions in the order of deallocation. When several values become unreachable at the same time (i.e. during the same GC cycle), the finalisation functions will be called in the reverse order of the corresponding calls to &lt;code&gt;finalise&lt;/code&gt;. If &lt;code&gt;finalise&lt;/code&gt; is called in the same order as the values are allocated, that means each value is finalised before the values it depends upon. Of course, this becomes false if additional dependencies are introduced by assignments.</source>
          <target state="translated">GC는 할당 해제 순서대로 종료 함수를 호출합니다. 여러 값에 동시에 도달 할 수없는 경우 (즉, 동일한 GC주기 동안) finalization 함수는 해당 호출의 역순으로 &lt;code&gt;finalise&lt;/code&gt; 호출합니다 . &lt;code&gt;finalise&lt;/code&gt; 가 값이 할당 된 순서와 동일한 순서로 호출 되면 각 값이 종속 된 값보다 먼저 완료됨을 의미합니다. 물론 할당에 의해 추가 종속성이 도입되면 이는 거짓이됩니다.</target>
        </trans-unit>
        <trans-unit id="7795741ff8b943ea1be2628f77110237f9e449f7" translate="yes" xml:space="preserve">
          <source>The HTML tags &amp;lt;b&amp;gt;..&amp;lt;/b&amp;gt;, &amp;lt;code&amp;gt;..&amp;lt;/code&amp;gt;, &amp;lt;i&amp;gt;..&amp;lt;/i&amp;gt;, &amp;lt;ul&amp;gt;..&amp;lt;/ul&amp;gt;, &amp;lt;ol&amp;gt;..&amp;lt;/ol&amp;gt;, &amp;lt;li&amp;gt;..&amp;lt;/li&amp;gt;, &amp;lt;center&amp;gt;..&amp;lt;/center&amp;gt; and &amp;lt;h[0-9]&amp;gt;..&amp;lt;/h[0-9]&amp;gt; can be used instead of, respectively, {b ..} , [..] , {i ..} , {ul ..} , {ol ..} , {li ..} , {C ..} and {[0-9] ..}.</source>
          <target state="translated">HTML 태그 &amp;lt;b&amp;gt; .. &amp;lt;/ b&amp;gt;, &amp;lt;code&amp;gt; .. &amp;lt;/ code&amp;gt;, &amp;lt;i&amp;gt; .. &amp;lt;/ i&amp;gt;, &amp;lt;ul&amp;gt; .. &amp;lt;/ ul&amp;gt;, &amp;lt;ol&amp;gt; .. &amp;lt;/ ol&amp;gt;, &amp;lt;li&amp;gt; .. &amp;lt;/ li&amp;gt;, &amp;lt;center&amp;gt; .. &amp;lt;/ center&amp;gt; 및 &amp;lt;h [0-9]&amp;gt; .. &amp;lt;/ h [0-9]&amp;gt;를 각각 대신 사용할 수 있습니다. {b ..}, [..], {i ..}, {ul ..}, {ol ..}, {li ..}, {C ..} 및 {[0-9] ..} .</target>
        </trans-unit>
        <trans-unit id="e0385ec9d501a25d53c3aad498dad447e84092fe" translate="yes" xml:space="preserve">
          <source>The IA32 code generator (Intel Pentium, AMD Athlon) supports the following additional option:</source>
          <target state="translated">IA32 코드 생성기 (Intel Pentium, AMD Athlon)는 다음과 같은 추가 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f406da7037c42f4a4f464bf9db0658f383ecf08c" translate="yes" xml:space="preserve">
          <source>The OCaml Standard library.</source>
          <target state="translated">OCaml 표준 라이브러리.</target>
        </trans-unit>
        <trans-unit id="3cd9888d4cc0302f8bc1d09fa4ef39df6a3ff2b8" translate="yes" xml:space="preserve">
          <source>The OCaml debugger has a simple on-line help system, which gives a brief description of each command and variable.</source>
          <target state="translated">OCaml 디버거에는 각 명령과 변수에 대한 간략한 설명을 제공하는 간단한 온라인 도움말 시스템이 있습니다.</target>
        </trans-unit>
        <trans-unit id="75b7f273467919c29f03470504af44cab3766154" translate="yes" xml:space="preserve">
          <source>The OCaml debugger is invoked by running the program ocamldebug with the name of the bytecode executable file as first argument:</source>
          <target state="translated">OCaml 디버거는 첫 번째 인수로 바이트 코드 실행 파일의 이름을 사용하여 프로그램 ocamldebug를 실행하여 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="13488dcd67078760c0511e807304bd3a788513ec" translate="yes" xml:space="preserve">
          <source>The OCaml debugger is started under Emacs by the command M-x camldebug, with argument the name of the executable file progname to debug. Communication with the debugger takes place in an Emacs buffer named *camldebug-progname*. The editing and history facilities of Shell mode are available for interacting with the debugger.</source>
          <target state="translated">OCaml 디버거는 디버깅 할 실행 파일 progname의 인수와 함께 Mx camldebug 명령에 의해 Emacs에서 시작됩니다. 디버거와의 통신은 * camldebug-progname *이라는 Emacs 버퍼에서 발생합니다. 셸 모드의 편집 및 기록 기능은 디버거와 상호 작용하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0701bb96dd9335c1a8b9cd5991613a9554bc96eb" translate="yes" xml:space="preserve">
          <source>The OCaml documentation and user&amp;rsquo;s manual is copyright &amp;copy; 2020 Institut National de Recherche en Informatique et en Automatique (INRIA).</source>
          <target state="translated">OCaml 문서 및 사용자 매뉴얼은 저작권 &amp;copy; 2020 Institut National de Recherche en Informatique et en en Automatique (INRIA)에 있습니다.</target>
        </trans-unit>
        <trans-unit id="1af4680eb3a182fd7749d661362740023609c59f" translate="yes" xml:space="preserve">
          <source>The OCaml documentation and user's manual is licensed under a &lt;a href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;Creative Commons Attribution-ShareAlike 4.0 International License&lt;/a&gt;.</source>
          <target state="translated">OCaml 문서 및 사용자 설명서는 &lt;a href=&quot;http://creativecommons.org/licenses/by-sa/4.0/&quot;&gt;Creative Commons Attribution-ShareAlike 4.0 International License에&lt;/a&gt; 따라 사용이 허가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5a12bf6d10452a673a4059a176328235b4073891" translate="yes" xml:space="preserve">
          <source>The OCaml notation for the type of a function with multiple arguments is</source>
          <target state="translated">인수가 여러 개인 함수 유형에 대한 OCaml 표기법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b300bbe66442808bbe9b55b3a38db2ca2b4dfb4" translate="yes" xml:space="preserve">
          <source>The OCaml run-time system is not reentrant: at any time, at most one thread can be executing OCaml code or C code that uses the OCaml run-time system. Technically, this is enforced by a &amp;ldquo;master lock&amp;rdquo; that any thread must hold while executing such code.</source>
          <target state="translated">OCaml 런타임 시스템은 재진입이 불가능합니다. 언제든지 최대 하나의 스레드가 OCaml 코드 또는 OCaml 런타임 시스템을 사용하는 C 코드를 실행할 수 있습니다. 기술적으로 이것은 이러한 코드를 실행하는 동안 모든 스레드가 보유해야하는 &quot;마스터 잠금&quot;에 의해 시행됩니다.</target>
        </trans-unit>
        <trans-unit id="e888d1165d4d21dea5f4e7b7872ca6fbab7bdab8" translate="yes" xml:space="preserve">
          <source>The OCaml runtime system comprises three main parts: the bytecode interpreter, the memory manager, and a set of C functions that implement the primitive operations. Some bytecode instructions are provided to call these C functions, designated by their offset in a table of functions (the table of primitives).</source>
          <target state="translated">OCaml 런타임 시스템은 바이트 코드 인터프리터, 메모리 관리자 및 기본 연산을 구현하는 C 함수 세트의 세 가지 주요 부분으로 구성됩니다. 이러한 C 함수를 호출하기 위해 일부 바이트 코드 명령어가 제공되며, 함수 테이블 (기본 요소 테이블)에서 오프셋으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="0a9ec24fe8572105b571386cc4dee94c3a1b7683" translate="yes" xml:space="preserve">
          <source>The OCaml scanning facility is reminiscent of the corresponding C feature. However, it is also largely different, simpler, and yet more powerful: the formatted input functions are higher-order functionals and the parameter passing mechanism is just the regular function application not the variable assignment based mechanism which is typical for formatted input in imperative languages; the OCaml format strings also feature useful additions to easily define complex tokens; as expected within a functional programming language, the formatted input functions also support polymorphism, in particular arbitrary interaction with polymorphic user-defined scanners. Furthermore, the OCaml formatted input facility is fully type-checked at compile time.</source>
          <target state="translated">OCaml 스캐닝 기능은 해당 C 기능을 연상시킵니다. 그러나 그것은 또한 크게 다르고 더 간단하지만 더 강력합니다. 형식화 된 입력 함수는 고차 함수이며 매개 변수 전달 메커니즘은 명령형 언어의 형식화 된 입력에 일반적으로 사용되는 변수 할당 기반 메커니즘이 아닌 일반 함수 응용 프로그램 일뿐입니다. ; OCaml 형식 문자열에는 복잡한 토큰을 쉽게 정의 할 수있는 유용한 추가 기능도 있습니다. 함수형 프로그래밍 언어 내에서 예상 한대로 형식화 된 입력 함수는 다형성, 특히 다형성 사용자 정의 스캐너와의 임의의 상호 작용도 지원합니다. 또한 OCaml 형식의 입력 기능은 컴파일 시간에 완전히 유형 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="abc31968fdf618dcf3aa38d81db7bcb91f6bbaf6" translate="yes" xml:space="preserve">
          <source>The OCaml system</source>
          <target state="translated">OCaml 시스템</target>
        </trans-unit>
        <trans-unit id="c00ea3211d757c3befa9662576a06b2a3d185969" translate="yes" xml:space="preserve">
          <source>The OCaml system computes both the value and the type for each phrase. Even function parameters need no explicit type declaration: the system infers their types from their usage in the function. Notice also that integers and floating-point numbers are distinct types, with distinct operators: + and * operate on integers, but +. and *. operate on floats.</source>
          <target state="translated">OCaml 시스템은 각 구문의 값과 유형을 모두 계산합니다. 함수 매개 변수조차도 명시적인 유형 선언이 필요하지 않습니다. 시스템은 함수에서의 사용에서 유형을 유추합니다. 또한 정수와 부동 소수점 숫자는 고유 한 유형이며 고유 한 연산자가 있습니다. + 및 *는 정수에서 작동하지만 +는 작동합니다. 및 *. 수레에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="108a7dca000ccd9968ece57a159ab22379aec497" translate="yes" xml:space="preserve">
          <source>The OCaml system is copyright &amp;copy; 1996&amp;ndash;2020 Institut National de Recherche en Informatique et en Automatique (INRIA). INRIA holds all ownership rights to the OCaml system.</source>
          <target state="translated">OCaml 시스템은 저작권 &amp;copy; 1996&amp;ndash;2020 INRIA (Institut National de Recherche en Informatique et en Automatique)에 있습니다. INRIA는 OCaml 시스템에 대한 모든 소유권을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="1e41ebd883056d903f296e46ca32d4e99959d066" translate="yes" xml:space="preserve">
          <source>The OCaml system is open source and can be freely redistributed. See the file LICENSE in the distribution for licensing information.</source>
          <target state="translated">OCaml 시스템은 오픈 소스이며 자유롭게 재배포 할 수 있습니다. 라이센스 정보는 배포판의 LICENSE 파일을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6a6d62f8ada2e0a3471af00a4f2d72e08bf53548" translate="yes" xml:space="preserve">
          <source>The OCaml system under Windows can be configured at build time in one of two modes:</source>
          <target state="translated">Windows의 OCaml 시스템은 빌드시 다음 두 가지 모드 중 하나로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46e485e11802130ef8432b55f6c33406ef03529e" translate="yes" xml:space="preserve">
          <source>The OCaml type system checks that the type of the arguments and the specifiers are compatible. If you pass it an argument of a type that does not correspond to the format specifier, the compiler will display an error message:</source>
          <target state="translated">OCaml 유형 시스템은 인수 유형과 지정자가 호환되는지 확인합니다. 형식 지정자에 해당하지 않는 유형의 인수를 전달하면 컴파일러는 오류 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b075ff3a2ce27b8853b8203828c331ee0dc266ff" translate="yes" xml:space="preserve">
          <source>The PowerPC code generator supports the following additional options:</source>
          <target state="translated">PowerPC 코드 생성기는 다음과 같은 추가 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="595a52e6177f37e25c12ad26af16912ffc174450" translate="yes" xml:space="preserve">
          <source>The Windows API uses the UTF-16 encoding to support Unicode. The runtime system performs the necessary conversions so that the OCaml programmer only needs to deal with the OCaml encoding. C stubs that call Windows Unicode APIs need to use specific runtime functions to perform the necessary conversions in a compatible way.</source>
          <target state="translated">Windows API는 UTF-16 인코딩을 사용하여 유니 코드를 지원합니다. 런타임 시스템은 필요한 변환을 수행하므로 OCaml 프로그래머는 OCaml 인코딩 만 처리하면됩니다. Windows 유니 코드 API를 호출하는 C 스텁은 호환 가능한 방식으로 필요한 변환을 수행하기 위해 특정 런타임 함수를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5e58e4ef240f0b79192b60989a00c3560ae96550" translate="yes" xml:space="preserve">
          <source>The above class money reveals a problem that often occurs with binary methods. In order to interact with other objects of the same class, the representation of money objects must be revealed, using a method such as value. If we remove all binary methods (here plus and leq), the representation can easily be hidden inside objects by removing the method value as well. However, this is not possible as soon as some binary method requires access to the representation of objects of the same class (other than self).</source>
          <target state="translated">위의 클래스 돈은 바이너리 메서드에서 자주 발생하는 문제를 보여줍니다. 같은 클래스의 다른 객체와 상호 작용하기 위해서는 value와 같은 방법을 사용하여 money 객체의 표현이 드러나야합니다. 모든 이진 메서드 (여기서는 plus 및 leq)를 제거하면 메서드 값도 제거하여 표현을 객체 내부에 쉽게 숨길 수 있습니다. 그러나 일부 이진 메서드에서 self가 아닌 동일한 클래스의 개체 표현에 액세스해야하는 즉시 이것은 가능하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c2b2bc28098b3a5ed96c8509e9d54181688aacc" translate="yes" xml:space="preserve">
          <source>The above considerations can usually be ignored if your lists are not longer than about 10000 elements.</source>
          <target state="translated">목록이 약 10000 요소를 넘지 않는 경우 위의 고려 사항은 일반적으로 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1275e5b0fd632a0adb161ae45fd343dd0a7ed674" translate="yes" xml:space="preserve">
          <source>The above definition of functional_point is not equivalent to the following:</source>
          <target state="translated">위의 functional_point 정의는 다음과 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca1370db07df54b9210798f4a752f3703b356815" translate="yes" xml:space="preserve">
          <source>The above definition will only backup one level. The backup facility can be added to any class by using multiple inheritance.</source>
          <target state="translated">위의 정의는 한 수준 만 백업합니다. 다중 상속을 사용하여 모든 클래스에 백업 기능을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="044810ffbb768ce3b2056b4a6f6c69fc26ffde37" translate="yes" xml:space="preserve">
          <source>The above specification, inside a signature, only matches a module definition equal to &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;. Conversely, a type-level module alias can be matched by itself, or by any supertype of the type of the module it references.</source>
          <target state="translated">서명 내부의 위 사양은 &lt;a href=&quot;names#module-path&quot;&gt;module-path와&lt;/a&gt; 동일한 모듈 정의와 만 일치합니다 . 반대로, 유형 수준 모듈 별칭은 자체적으로 또는 참조하는 모듈 유형의 ​​상위 유형에 의해 일치 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a4efe688ae0c8753fcbb050f0706980508ba0af" translate="yes" xml:space="preserve">
          <source>The above variant types were polymorphic, allowing further refinement. When writing type annotations, one will most often describe fixed variant types, that is types that cannot be refined. This is also the case for type abbreviations. Such types do not contain &amp;lt; or &amp;gt;, but just an enumeration of the tags and their associated types, just like in a normal datatype definition.</source>
          <target state="translated">위의 변형 유형은 다형성이어서 더 세분화 할 수 있습니다. 유형 주석을 작성할 때 수정 될 수없는 유형 인 고정 된 변형 유형을 가장 자주 설명합니다. 유형 약어의 경우에도 마찬가지입니다. 이러한 유형에는 &amp;lt;또는&amp;gt;가 포함되지 않고 일반 데이터 유형 정의에서와 같이 태그 및 관련 유형의 열거 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4ef217485c89f7960da6716b91dd0fabc645656e" translate="yes" xml:space="preserve">
          <source>The abstract type &lt;code&gt;backtrace_slot&lt;/code&gt; represents a single slot of a backtrace.</source>
          <target state="translated">추상 유형 &lt;code&gt;backtrace_slot&lt;/code&gt; 은 역 추적 의 단일 슬롯을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="739286bc505e97139a598fe8147fb7a3765c2deb" translate="yes" xml:space="preserve">
          <source>The abstract type &lt;code&gt;raw_backtrace&lt;/code&gt; stores a backtrace in a low-level format, instead of directly exposing them as string as the &lt;code&gt;get_backtrace()&lt;/code&gt; function does.</source>
          <target state="translated">추상 유형 &lt;code&gt;raw_backtrace&lt;/code&gt; 는 &lt;code&gt;get_backtrace()&lt;/code&gt; 함수가 수행 하는 것처럼 문자열로 직접 노출하는 대신 저수준 형식으로 역 추적을 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="af764d88af01f9903675386eab28fc1408ce8155" translate="yes" xml:space="preserve">
          <source>The abstract type of Internet addresses.</source>
          <target state="translated">인터넷 주소의 추상 유형입니다.</target>
        </trans-unit>
        <trans-unit id="481d24b8ea9ec5881b68246c8998a8f47be76742" translate="yes" xml:space="preserve">
          <source>The abstract type of buffers.</source>
          <target state="translated">추상 유형의 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="4026004092ed45c6dd9c41b6b253ecdb6f12e44c" translate="yes" xml:space="preserve">
          <source>The abstract type of file descriptors.</source>
          <target state="translated">추상 유형의 파일 설명자입니다.</target>
        </trans-unit>
        <trans-unit id="012fb3dc8bc487525d0af4de37a9ed3cffd39a71" translate="yes" xml:space="preserve">
          <source>The actions are arbitrary OCaml expressions. They are evaluated in a context where the identifiers defined by using the as construct are bound to subparts of the matched string. Additionally, lexbuf is bound to the current lexer buffer. Some typical uses for lexbuf, in conjunction with the operations on lexer buffers provided by the Lexing standard library module, are listed below.</source>
          <target state="translated">액션은 임의의 OCaml 표현식입니다. as 구문을 사용하여 정의 된 식별자가 일치하는 문자열의 하위 부분에 바인딩되는 컨텍스트에서 평가됩니다. 또한 lexbuf는 현재 렉서 버퍼에 바인딩됩니다. Lexing 표준 라이브러리 모듈에서 제공하는 렉서 버퍼에 대한 작업과 함께 lexbuf의 몇 가지 일반적인 용도가 아래에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f24608a60c588712f36527d1438e6185c4caa81b" translate="yes" xml:space="preserve">
          <source>The advantage of those printers based on the %a specifier is that they can be composed together to create more complex printers step by step. We can define a combinator that can turn a printer for 'a type into a printer for 'a optional:</source>
          <target state="translated">% a 지정자를 기반으로하는 이러한 프린터의 장점은 더 복잡한 프린터를 단계별로 만들기 위해 함께 구성 할 수 있다는 것입니다. 우리는 '유형을'선택적 프린터로 '에 대한 프린터를 전환 할 수있는 결합자를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08b7a0d96acbf6b2533907cd2c43896611cce1c8" translate="yes" xml:space="preserve">
          <source>The aims of inlining are:</source>
          <target state="translated">인라인의 목적은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e4b4f885867a255a22ab6931eddd051e8225ed9" translate="yes" xml:space="preserve">
          <source>The all-time favorite: a desk calculator. This program reads arithmetic expressions on standard input, one per line, and prints their values. Here is the grammar definition:</source>
          <target state="translated">가장 좋아하는 앱 : 탁상용 계산기. 이 프로그램은 표준 입력에서 한 줄에 하나씩 산술 표현식을 읽고 그 값을 인쇄합니다. 문법 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ac2c39dacdc6a9be5743e68f1dd99fbde2e43c29" translate="yes" xml:space="preserve">
          <source>The allocation of the pair has been eliminated.</source>
          <target state="translated">쌍의 할당이 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="3bdf6e627c88ed40af03f752c75a521013dd60d7" translate="yes" xml:space="preserve">
          <source>The allocation of the pair within f has been removed. (Since the two closures for loop&amp;rsquo; and loop2&amp;rsquo; are constant they will also be lifted to toplevel with no runtime allocation penalty. This would also happen without having run the transformation to unbox specialise arguments.)</source>
          <target state="translated">f 내의 쌍 할당이 제거되었습니다. (loop '와 loop2'에 대한 두 개의 클로저가 일정하기 때문에 런타임 할당 패널티없이 최상위 레벨로 올라갑니다. 이것은 unbox specialize 인수로 변환을 실행하지 않고도 발생합니다.)</target>
        </trans-unit>
        <trans-unit id="f2de0b011f578d5d6e9c61968919404fdcc2ece6" translate="yes" xml:space="preserve">
          <source>The alternative is of course to build the library without extra options:</source>
          <target state="translated">대안은 물론 추가 옵션없이 라이브러리를 빌드하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0e2dd4f451a8dcf054a1812b560aca93e651aa0b" translate="yes" xml:space="preserve">
          <source>The amount of profiling information can be controlled through the -P option to ocamlcp or ocamloptp, followed by one or several letters indicating which parts of the program should be profiled:</source>
          <target state="translated">프로파일 링 정보의 양은 ocamlcp 또는 ocamloptp에 대한 -P 옵션을 통해 제어 할 수 있으며 그 뒤에 프로그램의 어느 부분을 프로파일 링해야 하는지를 나타내는 하나 또는 여러 개의 문자가 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="8ab3f2331e8b1749d459c0080607551039b5ae36" translate="yes" xml:space="preserve">
          <source>The annotation virtual here is only used to mention a method without providing its definition. Since we didn&amp;rsquo;t add the private annotation, this makes the method public, keeping the original definition.</source>
          <target state="translated">여기서 virtual 주석은 정의를 제공하지 않고 메소드를 언급하는 데만 사용됩니다. 비공개 주석을 추가하지 않았기 때문에 메서드를 공개하고 원래 정의를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="f58bb108f6951aa34759425d8ee753adc0f3924e" translate="yes" xml:space="preserve">
          <source>The answer is that when confronted with multiple options, OCaml tries to use locally available information to disambiguate between the various fields and constructors. First, if the type of the record or variant is known, OCaml can pick unambiguously the corresponding field or constructor. For instance:</source>
          <target state="translated">대답은 여러 옵션에 직면했을 때 OCaml이 로컬에서 사용 가능한 정보를 사용하여 다양한 필드와 생성자 사이의 모호성을 없애려고한다는 것입니다. 첫째, 레코드 또는 변형의 유형이 알려진 경우 OCaml은 해당 필드 또는 생성자를 명확하게 선택할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="611a6a75c3c1ff11eb7d3c599a9f649411be363a" translate="yes" xml:space="preserve">
          <source>The answer is twofold. One first aspect is that while being pretty efficient, the lack of static type information allows for less optimizations, and makes polymorphic variants slightly heavier than core language ones. However noticeable differences would only appear on huge data structures.</source>
          <target state="translated">대답은 두 가지입니다. 첫 번째 측면 중 하나는 매우 효율적이지만 정적 유형 정보가 부족하면 최적화가 적고 다형성 변형이 핵심 언어보다 약간 무겁습니다. 그러나 눈에 띄는 차이는 거대한 데이터 구조에서만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="2e0ae228161936f806d34344dc59d7232112d71f" translate="yes" xml:space="preserve">
          <source>The argument f to iter is invariant so the function may be specialised:</source>
          <target state="translated">iter에 대한 인수 f는 변하지 않으므로 함수가 특수화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3e5632dfa7a2b83bf829cdc816e3c1a87c98674" translate="yes" xml:space="preserve">
          <source>The argument of &lt;a href=&quot;sys#VALcommand&quot;&gt;&lt;code&gt;Sys.command&lt;/code&gt;&lt;/a&gt; is generally the name of a command followed by zero, one or several arguments, separated by whitespace. The given argument is interpreted by a shell: either the Windows shell &lt;code&gt;cmd.exe&lt;/code&gt; for the Win32 ports of OCaml, or the POSIX shell &lt;code&gt;sh&lt;/code&gt; for other ports. It can contain shell builtin commands such as &lt;code&gt;echo&lt;/code&gt;, and also special characters such as file redirections &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt;, which will be honored by the shell.</source>
          <target state="translated">&lt;a href=&quot;sys#VALcommand&quot;&gt; &lt;code&gt;Sys.command&lt;/code&gt; &lt;/a&gt; 의 인수 는 일반적으로 공백으로 구분 된 0 개, 1 개 또는 여러 개의 인수가 뒤에 오는 명령 이름입니다. 주어진 인수는 쉘에 의해 해석됩니다 : OCaml의 Win32 포트를위한 Windows 쉘 &lt;code&gt;cmd.exe&lt;/code&gt; 또는 다른 포트를위한 POSIX 쉘 &lt;code&gt;sh&lt;/code&gt; . &lt;code&gt;echo&lt;/code&gt; 와 같은 쉘 내장 명령과 쉘에서 인정하는 파일 리디렉션 &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;&lt;/code&gt; 와 같은 특수 문자도 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c32b048d109d34646b19b7212d9e49b0e7c2fe1" translate="yes" xml:space="preserve">
          <source>The arguments following program are optional, and are passed as command-line arguments to the program being debugged. (See also the set arguments command.)</source>
          <target state="translated">program 다음의 인수는 선택 사항이며 디버깅중인 프로그램에 명령 줄 인수로 전달됩니다. (set arguments 명령도 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="adbf5b37a6462b0983b5bf9cd33bf85f4db819aa" translate="yes" xml:space="preserve">
          <source>The arguments of sum-type constructors can now be defined using the same syntax as records. Mutable and polymorphic fields are allowed. GADT syntax is supported. Attributes can be specified on individual fields.</source>
          <target state="translated">합계 유형 생성자의 인수는 이제 레코드와 동일한 구문을 사용하여 정의 할 수 있습니다. 가변 및 다형성 필드가 허용됩니다. GADT 구문이 지원됩니다. 개별 필드에 속성을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82ce2f746abf0188689410ed58dc502e67dced4e" translate="yes" xml:space="preserve">
          <source>The arity (number of arguments) of a primitive is automatically determined from its OCaml type in the external declaration, by counting the number of function arrows in the type. For instance, input above has arity 4, and the input C function is called with four arguments. Similarly,</source>
          <target state="translated">프리미티브의 배열 (인수 수)은 유형의 함수 화살표 수를 계산하여 외부 선언의 OCaml 유형에서 자동으로 결정됩니다. 예를 들어 위의 입력은 arity 4이고 입력 C 함수는 4 개의 인수로 호출됩니다. 비슷하게,</target>
        </trans-unit>
        <trans-unit id="2ab01eca841b7f4d65b6116a30c2bd33e79dbb17" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;a&lt;/code&gt; must have exactly &lt;code&gt;N&lt;/code&gt; dimensions, and all coordinates must lie inside the array bounds, as described for &lt;code&gt;Genarray.get&lt;/code&gt;; otherwise, &lt;code&gt;Invalid_argument&lt;/code&gt; is raised.</source>
          <target state="translated">배열 &lt;code&gt;a&lt;/code&gt; 는 정확히 &lt;code&gt;N&lt;/code&gt; 개의 차원을 가져야 하며 모든 좌표는 &lt;code&gt;Genarray.get&lt;/code&gt; 에 대해 설명한대로 배열 경계 내에 있어야합니다 . 그렇지 않으면 &lt;code&gt;Invalid_argument&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="868ea2ab054abe050c8bc298a300a68a34cb7e0b" translate="yes" xml:space="preserve">
          <source>The as construct is similar to &amp;ldquo;&lt;em&gt;groups&lt;/em&gt;&amp;rdquo; as provided by numerous regular expression packages. The type of these variables can be string, char, string option or char option.</source>
          <target state="translated">as 구성은 수많은 정규식 패키지에서 제공하는 &quot; &lt;em&gt;그룹&lt;/em&gt; &quot; 과 유사 합니다. 이러한 변수의 유형은 문자열, 문자, 문자열 옵션 또는 문자 옵션 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73177bb5797d8e28b73870b15973e78612bd93d2" translate="yes" xml:space="preserve">
          <source>The associated parser would be a function from &lt;code&gt;token&amp;nbsp;stream&lt;/code&gt; to, for instance, &lt;code&gt;int&lt;/code&gt;, and would have rules such as:</source>
          <target state="translated">연관된 파서는 &lt;code&gt;token&amp;nbsp;stream&lt;/code&gt; 에서 &lt;code&gt;int&lt;/code&gt; 등으로 의 함수 이며 다음과 같은 규칙을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="2420f95fc8ad57ab7c1da6f7e6377e30752e6e0e" translate="yes" xml:space="preserve">
          <source>The author of the element. One author per @author tag. There may be several @author tags for the same element.</source>
          <target state="translated">요소의 작성자입니다. @author 태그 당 한 명의 작성자. 동일한 요소에 대해 여러 개의 @author 태그가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c7873377d2e12a00df000be90fb6b4a6087455b" translate="yes" xml:space="preserve">
          <source>The basic form for defining a module component is module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;=&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;, which evaluates &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; and binds the result to the name &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;.</source>
          <target state="translated">모듈의 구성 요소를 정의하는 기본형 모듈 인 &lt;a href=&quot;names#module-name&quot;&gt;모듈 이름&lt;/a&gt; = &lt;a href=&quot;#module-expr&quot;&gt;모듈 EXPR&lt;/a&gt; 평가, &lt;a href=&quot;#module-expr&quot;&gt;모듈을 expr&lt;/a&gt; 및 이름에 따라서 결합 &lt;a href=&quot;names#module-name&quot;&gt;모듈 이름&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="842164f73b83f27f15ffe93e1ec98838de6e836b" translate="yes" xml:space="preserve">
          <source>The behavior is not defined if the hash table is modified by &lt;code&gt;f&lt;/code&gt; during the iteration.</source>
          <target state="translated">반복 중에 &lt;code&gt;f&lt;/code&gt; 에 의해 해시 테이블이 수정되면 동작이 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c7911b90c87825476ae85d935bdfc9f902a9f2ea" translate="yes" xml:space="preserve">
          <source>The behavior is not defined if the hash table is modified during the iteration.</source>
          <target state="translated">반복 중에 해시 테이블이 수정되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d6058839cd5d6f864ed769e103e1c4571b14c4b" translate="yes" xml:space="preserve">
          <source>The behavior of other forms of letrec definitions is implementation-dependent. The current implementation also supports a certain class of recursive definitions of non-functional values, as explained in section &lt;a href=&quot;letrecvalues#s%3Aletrecvalues&quot;&gt;8.1&lt;/a&gt;.</source>
          <target state="translated">다른 형식의 letrec 정의 동작은 구현에 따라 다릅니다. 현재 구현은 섹션 &lt;a href=&quot;letrecvalues#s%3Aletrecvalues&quot;&gt;8.1에&lt;/a&gt; 설명 된대로 비 기능적 값에 대한 특정 클래스의 재귀 적 정의를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="1ff67900c42b4aee958325c5f4f3657cfb01e905" translate="yes" xml:space="preserve">
          <source>The behavior of pretty-printing commands is unspecified if there is no open pretty-printing box. Each box opened by one of the &lt;code&gt;open_&lt;/code&gt; functions below must be closed using &lt;code&gt;close_box&lt;/code&gt; for proper formatting. Otherwise, some of the material printed in the boxes may not be output, or may be formatted incorrectly.</source>
          <target state="translated">pretty-printing 상자가 열려 있지 않으면 pretty-printing 명령의 동작이 지정되지 않습니다. 아래 의 &lt;code&gt;open_&lt;/code&gt; 함수 중 하나에 의해 열린 각 상자 는 적절한 형식화를 위해 &lt;code&gt;close_box&lt;/code&gt; 를 사용하여 닫아야 합니다. 그렇지 않으면 상자에 인쇄 된 일부 자료가 출력되지 않거나 잘못 형식화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="294b4ce3a6ec7d9526f89437cbfa0a62dbc20037" translate="yes" xml:space="preserve">
          <source>The behaviour depends on whether -Oclassic is used.</source>
          <target state="translated">동작은 -Oclassic이 사용되는지 여부에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="37716c4181d6f75c920bfc58fd4811b40988028e" translate="yes" xml:space="preserve">
          <source>The behaviour of the Flambda simplification pass means that certain unsafe operations, which may without Flambda or when using previous versions of the compiler be safe, must not be used. This specifically refers to functions found in the Obj module.</source>
          <target state="translated">Flambda 단순화 패스의 동작은 Flambda가 없거나 이전 버전의 컴파일러를 사용할 때 안전 할 수있는 특정 안전하지 않은 작업을 사용해서는 안됨을 의미합니다. 이것은 특히 Obj 모듈에있는 함수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="eee0f3f481dbee307882214b9d43efeec2d8af62" translate="yes" xml:space="preserve">
          <source>The benefit of specialisation is assessed in a similar way as for inlining. Specialised argument information may mean that the body of the function being specialised can be simplified: the removed operations are accumulated into a benefit. This, together with the size of the duplicated (specialised) function declaration, is then assessed against the size of the call to the original function.</source>
          <target state="translated">전문화의 이점은 인라인과 유사한 방식으로 평가됩니다. 특수화 된 인수 정보는 특수화되는 함수의 본문이 단순화 될 수 있음을 의미 할 수 있습니다. 제거 된 작업은 이익으로 누적됩니다. 이것은 복제 된 (특수화 된) 함수 선언의 크기와 함께 원래 함수에 대한 호출 크기에 대해 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="0b2c4a9ea1966c2159ce87a9dbf7fed0e3ab528e" translate="yes" xml:space="preserve">
          <source>The best way to set a file descriptor ``close-on-exec'' is to create it in this state. To this end, the &lt;code&gt;openfile&lt;/code&gt; function has &lt;code&gt;O_CLOEXEC&lt;/code&gt; and &lt;code&gt;O_KEEPEXEC&lt;/code&gt; flags to enforce ``close-on-exec'' mode or ``keep-on-exec'' mode, respectively. All other operations in the Unix module that create file descriptors have an optional argument &lt;code&gt;?cloexec:bool&lt;/code&gt; to indicate whether the file descriptor should be created in ``close-on-exec'' mode (by writing &lt;code&gt;~cloexec:true&lt;/code&gt;) or in ``keep-on-exec'' mode (by writing &lt;code&gt;~cloexec:false&lt;/code&gt;). For historical reasons, the default file descriptor creation mode is ``keep-on-exec'', if no &lt;code&gt;cloexec&lt;/code&gt; optional argument is given. This is not a safe default, hence it is highly recommended to pass explicit &lt;code&gt;cloexec&lt;/code&gt; arguments to operations that create file descriptors.</source>
          <target state="translated">파일 설명자``close-on-exec ''를 설정하는 가장 좋은 방법은이 상태에서 만드는 것입니다. 이를 위해 &lt;code&gt;openfile&lt;/code&gt; 함수에는 각각 ``close-on-exec ''모드 또는``keep-on-exec ''모드를 적용하는 &lt;code&gt;O_CLOEXEC&lt;/code&gt; 및 &lt;code&gt;O_KEEPEXEC&lt;/code&gt; 플래그가 있습니다. 파일 기술자를 만들 유닉스 모듈의 다른 모든 작업은 선택적 인수가 &lt;code&gt;?cloexec:bool&lt;/code&gt; 가까이 온 간부 ''모드 (작성하여 파일 기술자가``에 작성해야하는지 여부를 나타냅니다 &lt;code&gt;~cloexec:true&lt;/code&gt; `또는에서) `keep-on-exec ''모드 ( &lt;code&gt;~cloexec:false&lt;/code&gt; 작성 ). 역사적 이유로 기본 파일 설명자 생성 모드는 &lt;code&gt;cloexec&lt;/code&gt; 가없는 경우``keep-on-exec ''입니다.선택적 인수가 제공됩니다. 이것은 안전한 기본값이 아니므로 파일 설명자를 만드는 작업에 명시 적 &lt;code&gt;cloexec&lt;/code&gt; 인수를 전달하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="86498a92f17f772fbb61c7717d965395dedb151e" translate="yes" xml:space="preserve">
          <source>The bigarray functionality may now be found in the standard library &lt;a href=&quot;libref/bigarray&quot;&gt;Bigarray module&lt;/a&gt;, except for the map_file function which is now part of the &lt;a href=&quot;libunix#c%3Aunix&quot;&gt;Unix library&lt;/a&gt;. The documentation has been integrated into the documentation for the standard library.</source>
          <target state="translated">bigarray 기능은 이제 &lt;a href=&quot;libunix#c%3Aunix&quot;&gt;Unix 라이브러리의&lt;/a&gt; 일부인 map_file 함수를 제외하고 표준 라이브러리 &lt;a href=&quot;libref/bigarray&quot;&gt;Bigarray 모듈&lt;/a&gt; 에서 찾을 수 있습니다 . 문서는 표준 라이브러리에 대한 문서에 통합되었습니다.</target>
        </trans-unit>
        <trans-unit id="c17f0e116811b46fb1a7e57d12263409833bc755" translate="yes" xml:space="preserve">
          <source>The bigarray library has now been integrated into OCaml&amp;rsquo;s standard library.</source>
          <target state="translated">bigarray 라이브러리는 이제 OCaml의 표준 라이브러리에 통합되었습니다.</target>
        </trans-unit>
        <trans-unit id="f6a6099570dff5141c480a3752e67d9450054231" translate="yes" xml:space="preserve">
          <source>The boolean 'and'.</source>
          <target state="translated">부울 'and'.</target>
        </trans-unit>
        <trans-unit id="353c4c988751affe11b91a3216ece019b7e4c283" translate="yes" xml:space="preserve">
          <source>The boolean 'and'. Evaluation is sequential, left-to-right: in &lt;code&gt;e1&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;e2&lt;/code&gt;, &lt;code&gt;e1&lt;/code&gt; is evaluated first, and if it returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;e2&lt;/code&gt; is not evaluated at all. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">부울 'and'. 평가는 왼쪽에서 오른쪽으로 순차적입니다. &lt;code&gt;e1&amp;nbsp;&amp;amp;&amp;amp;&amp;nbsp;e2&lt;/code&gt; 에서는 &lt;code&gt;e1&lt;/code&gt; 이 먼저 평가되고 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 &lt;code&gt;e2&lt;/code&gt; 는 전혀 평가되지 않습니다. 오른쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="3c5b81b1af0be4a909b4ff180ecd97e7f3ba74ce" translate="yes" xml:space="preserve">
          <source>The boolean 'or'.</source>
          <target state="translated">부울 'or'.</target>
        </trans-unit>
        <trans-unit id="a7978a7e64fa2a3b90ad7ad3cd09291d62fe4c55" translate="yes" xml:space="preserve">
          <source>The boolean 'or'. Evaluation is sequential, left-to-right: in &lt;code&gt;e1&amp;nbsp;||&amp;nbsp;e2&lt;/code&gt;, &lt;code&gt;e1&lt;/code&gt; is evaluated first, and if it returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;e2&lt;/code&gt; is not evaluated at all. Right-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">부울 'or'. 평가는 순차적이며 왼쪽에서 오른쪽으로 : &lt;code&gt;e1&amp;nbsp;||&amp;nbsp;e2&lt;/code&gt; , &lt;code&gt;e1&lt;/code&gt; 이 먼저 평가되고 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 &lt;code&gt;e2&lt;/code&gt; 가 전혀 평가되지 않습니다. 오른쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="57f592a468f9e49822816c7b0706ff6890f3319b" translate="yes" xml:space="preserve">
          <source>The boolean negation.</source>
          <target state="translated">부울 부정.</target>
        </trans-unit>
        <trans-unit id="e3356fbfc82845f932c40854238e79297422bf18" translate="yes" xml:space="preserve">
          <source>The boolean operators &amp;amp; and or are deprecated synonyms for (respectively) &amp;amp;&amp;amp; and ||.</source>
          <target state="translated">부울 연산자 &amp;amp; 및 또는는 (각각) &amp;amp;&amp;amp; 및 ||에 대해 더 이상 사용되지 않는 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="4b049f36521b991b87ac5a40eab10383da5bcce8" translate="yes" xml:space="preserve">
          <source>The bytecode compiler in custom runtime mode (ocamlc -custom) normally appends the bytecode to the executable file containing the custom runtime. This has two consequences. First, the final linking step must be performed by ocamlc. Second, the OCaml runtime library must be able to find the name of the executable file from the command-line arguments. When using caml_main(argv) as in section &lt;a href=&quot;#ss%3Amain-c&quot;&gt;20.7.4&lt;/a&gt;, this means that argv[0] or argv[1] must contain the executable file name.</source>
          <target state="translated">사용자 지정 런타임 모드 (ocamlc -custom)의 바이트 코드 컴파일러는 일반적으로 사용자 지정 런타임이 포함 된 실행 파일에 바이트 코드를 추가합니다. 이것은 두 가지 결과를 가져옵니다. 첫째, 최종 연결 단계는 ocamlc에 의해 수행되어야합니다. 둘째, OCaml 런타임 라이브러리는 명령 줄 인수에서 실행 파일의 이름을 찾을 수 있어야합니다. 섹션 &lt;a href=&quot;#ss%3Amain-c&quot;&gt;20.7.4&lt;/a&gt; 에서와 같이 caml_main (argv)를 사용 하는 경우 이는 argv [0] 또는 argv [1]에 실행 파일 이름이 포함되어야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ae71aa32bd811f5994a5593dcd1cb87c5ea5d8e1" translate="yes" xml:space="preserve">
          <source>The bytecode executable myprog can then be launched as usual: myprogargs or /home/me/ocamlunixrun myprogargs.</source>
          <target state="translated">그런 다음 바이트 코드 실행 파일 myprog를 평소처럼 myprogargs 또는 / home / me / ocamlunixrun myprogargs로 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31c8711898f71d43a2b4ca33e6558e5b43e7cda7" translate="yes" xml:space="preserve">
          <source>The bytes representing a marshaled value are composed of a fixed-size header and a variable-sized data part, whose size can be determined from the header.</source>
          <target state="translated">마샬링 된 값을 나타내는 바이트는 고정 크기 헤더와 가변 크기 데이터 부분으로 구성되며, 헤더에서 크기를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6cf8ac9f4453cd731df08caa3e42856639d786a" translate="yes" xml:space="preserve">
          <source>The bytes representing a marshaled value are composed of a fixed-size header and a variable-sized data part, whose size can be determined from the header. &lt;a href=&quot;marshal#VALheader_size&quot;&gt;&lt;code&gt;Marshal.header_size&lt;/code&gt;&lt;/a&gt; is the size, in bytes, of the header. &lt;a href=&quot;marshal#VALdata_size&quot;&gt;&lt;code&gt;Marshal.data_size&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&amp;nbsp;buff&amp;nbsp;ofs&lt;/code&gt; is the size, in bytes, of the data part, assuming a valid header is stored in &lt;code&gt;buff&lt;/code&gt; starting at position &lt;code&gt;ofs&lt;/code&gt;. Finally, &lt;a href=&quot;marshal#VALtotal_size&quot;&gt;&lt;code&gt;Marshal.total_size&lt;/code&gt;&lt;/a&gt;&lt;code&gt;buff&amp;nbsp;ofs&lt;/code&gt; is the total size, in bytes, of the marshaled value. Both &lt;a href=&quot;marshal#VALdata_size&quot;&gt;&lt;code&gt;Marshal.data_size&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;marshal#VALtotal_size&quot;&gt;&lt;code&gt;Marshal.total_size&lt;/code&gt;&lt;/a&gt; raise &lt;code&gt;Failure&lt;/code&gt; if &lt;code&gt;buff&lt;/code&gt;, &lt;code&gt;ofs&lt;/code&gt; does not contain a valid header.</source>
          <target state="translated">마샬링 된 값을 나타내는 바이트는 고정 크기 헤더와 가변 크기 데이터 부분으로 구성되며, 헤더에서 크기를 결정할 수 있습니다. &lt;a href=&quot;marshal#VALheader_size&quot;&gt; &lt;code&gt;Marshal.header_size&lt;/code&gt; &lt;/a&gt; 는 헤더의 크기 (바이트)입니다. &lt;a href=&quot;marshal#VALdata_size&quot;&gt; &lt;code&gt;Marshal.data_size&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&amp;nbsp;buff&amp;nbsp;ofs&lt;/code&gt; 올바른 헤더에 저장되어있는 가정하면, 데이터 부분의 크기 (바이트 단위) 인 &lt;code&gt;buff&lt;/code&gt; 위치에서 시작 &lt;code&gt;ofs&lt;/code&gt; . 마지막으로 &lt;a href=&quot;marshal#VALtotal_size&quot;&gt; &lt;code&gt;Marshal.total_size&lt;/code&gt; &lt;/a&gt; &lt;code&gt;buff&amp;nbsp;ofs&lt;/code&gt; 는 마샬링 된 값의 총 크기 (바이트)입니다. 두 &lt;a href=&quot;marshal#VALdata_size&quot;&gt; &lt;code&gt;Marshal.data_size&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;marshal#VALtotal_size&quot;&gt; &lt;code&gt;Marshal.total_size&lt;/code&gt; &lt;/a&gt; 인상 &lt;code&gt;Failure&lt;/code&gt; 하면 &lt;code&gt;buff&lt;/code&gt; , &lt;code&gt;ofs&lt;/code&gt; 유효한 헤더가 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d1103a29f51d40271f1f9e57f4afef462874497" translate="yes" xml:space="preserve">
          <source>The call to caml_main initializes the OCaml runtime system, loads the bytecode (in the case of the bytecode compiler), and executes the initialization code of the OCaml program. Typically, this initialization code registers callback functions using Callback.register. Once the OCaml initialization code is complete, control returns to the C code that called caml_main.</source>
          <target state="translated">caml_main에 대한 호출은 OCaml 런타임 시스템을 초기화하고 바이트 코드 (바이트 코드 컴파일러의 경우)를로드하고 OCaml 프로그램의 초기화 코드를 실행합니다. 일반적으로이 초기화 코드는 Callback.register를 사용하여 콜백 함수를 등록합니다. OCaml 초기화 코드가 완료되면 제어는 caml_main을 호출 한 C 코드로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="9a133408bb95ba502b3a3f1d4a608ee2cbee5abd" translate="yes" xml:space="preserve">
          <source>The call to print_int can indeed be inlined:</source>
          <target state="translated">print_int에 대한 호출은 실제로 인라인 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94ba4fe5d5732c256fe3a8bfe75e3f359200cfb9" translate="yes" xml:space="preserve">
          <source>The caller may not mutate &lt;code&gt;s&lt;/code&gt; while the string is borrowed (it has temporarily given up ownership). This affects concurrent programs, but also higher-order functions: if &lt;a href=&quot;string#VALlength&quot;&gt;&lt;code&gt;String.length&lt;/code&gt;&lt;/a&gt; returned a closure to be called later, &lt;code&gt;s&lt;/code&gt; should not be mutated until this closure is fully applied and returns ownership.</source>
          <target state="translated">호출자는 문자열이 차용되는 동안 &lt;code&gt;s&lt;/code&gt; 를 변경할 수 없습니다 (일시적으로 소유권을 포기했습니다). 이것은 동시 프로그램에 영향을 미칠뿐만 아니라 고차 함수에도 영향을 미칩니다. &lt;a href=&quot;string#VALlength&quot;&gt; &lt;code&gt;String.length&lt;/code&gt; 가&lt;/a&gt; 나중에 호출 할 클로저를 반환 한 경우이 클로저가 완전히 적용되고 소유권을 반환 할 때까지 &lt;code&gt;s&lt;/code&gt; 를 변경 해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="a0f9579a2db02b7e2d6ea5033fac1d3e370d16d1" translate="yes" xml:space="preserve">
          <source>The callstack for the allocation.</source>
          <target state="translated">할당을위한 호출 스택입니다.</target>
        </trans-unit>
        <trans-unit id="622bd19b67cd4c019f61e03bb878afac5759460b" translate="yes" xml:space="preserve">
          <source>The caml_startup function calls the uncaught exception handler (or enters the debugger, if running under ocamldebug) if an exception escapes from a top-level module initialiser. Such exceptions may be caught in the C code by instead using the caml_startup_exn function and testing the result using Is_exception_result (followed by Extract_exception if appropriate).</source>
          <target state="translated">caml_startup 함수는 예외가 최상위 모듈 이니셜 라이저에서 이스케이프되는 경우 포착되지 않은 예외 처리기를 호출합니다 (또는 ocamldebug에서 실행중인 경우 디버거에 들어갑니다). 이러한 예외는 대신 caml_startup_exn 함수를 사용하고 Is_exception_result (적절한 경우 Extract_exception 다음에 이어짐)를 사용하여 결과를 테스트하여 C 코드에서 포착 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="264cb221ad2c5021cb06f4e90ab892974f6027b4" translate="yes" xml:space="preserve">
          <source>The caml_startup function must be called from the main C program in order to initialize the OCaml runtime and execute the OCaml initialization code. Just like caml_main, it takes one argv parameter containing the command-line parameters. Unlike caml_main, this argv parameter is used only to initialize Sys.argv, but not for finding the name of the executable file.</source>
          <target state="translated">OCaml 런타임을 초기화하고 OCaml 초기화 코드를 실행하려면 주 C 프로그램에서 caml_startup 함수를 호출해야합니다. caml_main과 마찬가지로 명령 줄 매개 변수를 포함하는 하나의 argv 매개 변수를 사용합니다. caml_main과 달리이 argv 매개 변수는 Sys.argv를 초기화하는 데만 사용되며 실행 파일의 이름을 찾는 데는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2affb46e2f6bba633bb7602b97c665a41396ccad" translate="yes" xml:space="preserve">
          <source>The cases of a pattern matching (in the function, match and try constructs) can include guard expressions, which are arbitrary boolean expressions that must evaluate to true for the match case to be selected. Guards occur just before the -&amp;gt; token and are introduced by the when keyword:</source>
          <target state="translated">패턴 일치의 경우 (함수, match 및 try 구문에서)에는 일치 케이스를 선택하기 위해 true로 평가해야하는 임의의 부울 표현식 인 가드 표현식이 포함될 수 있습니다. 가드는-&amp;gt; 토큰 바로 전에 발생하며 when 키워드에 의해 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="c57a5996cc3de19dcd4e1eed39d89bc12a76cdf5" translate="yes" xml:space="preserve">
          <source>The change in code size is also estimated: morally speaking it should be the change in machine code size, but since that is not available to the inliner, an approximation is used.</source>
          <target state="translated">코드 크기의 변경도 추정됩니다. 도덕적으로 말하면 기계 코드 크기의 변경이어야하지만 인라이너에서 사용할 수 없기 때문에 근사치가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ca1b550469abfe316a8551222d7494a0d41f29ab" translate="yes" xml:space="preserve">
          <source>The class Odoc_html.Generator.html inherits from the class Odoc_html.info, containing a field tag_functions which is a list pairs composed of a custom tag (e.g. &quot;foo&quot;) and a function taking a text and returning HTML code (of type string). To handle a new tag bar, extend the current HTML generator and complete the tag_functions field:</source>
          <target state="translated">Odoc_html.Generator.html 클래스는 Odoc_html.info 클래스에서 상속되며 사용자 정의 태그 (예 : &quot;foo&quot;)와 텍스트를 가져와 HTML 코드 (문자열 유형)를 반환하는 함수로 구성된 목록 쌍인 tag_functions 필드를 포함합니다. . 새 태그 막대를 처리하려면 현재 HTML 생성기를 확장하고 tag_functions 필드를 완료하십시오.</target>
        </trans-unit>
        <trans-unit id="926c19980b2db5430ad107b75fe1458a4f3fbdcc" translate="yes" xml:space="preserve">
          <source>The class bank is the &lt;em&gt;real&lt;/em&gt; implementation of the bank account (it could have been inlined). This is the one that will be used for further extensions, refinements, etc. Conversely, the client will only be given the client view.</source>
          <target state="translated">클래스 은행은 은행 계좌 의 &lt;em&gt;실제&lt;/em&gt; 구현입니다 (인라인되었을 수 있음). 이것은 추가 확장, 개선 등에 사용될 것입니다. 반대로, 클라이언트는 클라이언트 뷰만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="e75252ec56a2bb1491e257e9361045a0dd0b5821" translate="yes" xml:space="preserve">
          <source>The class colored_circle is a specialized version of class circle that requires the type of the center to unify with #colored_point, and adds a method color. Note that when specializing a parameterized class, the instance of type parameter must always be explicitly given. It is again written between [ and ].</source>
          <target state="translated">colors_circle 클래스는 #colored_point와 통합하기 위해 중심의 유형을 요구하고 메소드 색상을 추가하는 클래스 서클의 특수 버전입니다. 매개 변수화 된 클래스를 전문화 할 때 매개 변수 유형의 인스턴스는 항상 명시 적으로 제공되어야합니다. 다시 [와] 사이에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="79b45dbbed1c7c5a93e33df7a349eb52d30c016c" translate="yes" xml:space="preserve">
          <source>The class money could naturally carry another binary method. Here is a direct definition:</source>
          <target state="translated">클래스 돈은 자연스럽게 또 다른 이진 방법을 수행 할 수 있습니다. 다음은 직접적인 정의입니다.</target>
        </trans-unit>
        <trans-unit id="8da53bfa481f42c4800f57d82c95a21c851133c0" translate="yes" xml:space="preserve">
          <source>The class observer has a distinguished method notify that requires two arguments, a subject and an event to execute an action.</source>
          <target state="translated">클래스 옵저버에는 두 개의 인수, 주제 및 작업을 실행하는 이벤트가 필요한 고유 한 방법 알림이 있습니다.</target>
        </trans-unit>
        <trans-unit id="df3bd4e2828bcd091f80465c81ab6f432a8b0a11" translate="yes" xml:space="preserve">
          <source>The class point below defines one instance variable x and two methods get_x and move. The initial value of the instance variable is 0. The variable x is declared mutable, so the method move can change its value.</source>
          <target state="translated">아래의 클래스 포인트는 하나의 인스턴스 변수 x와 두 개의 get_x 및 move 메소드를 정의합니다. 인스턴스 변수의 초기 값은 0입니다. 변수 x는 변경 가능으로 선언되므로 move 메서드는 값을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4593d18e4f9e303d386e01a8341f25ec6716bf22" translate="yes" xml:space="preserve">
          <source>The class point can also be abstracted over the initial values of the x coordinate.</source>
          <target state="translated">클래스 포인트는 x 좌표의 초기 값에 대해 추상화 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d631271177c3626e572631b72bb8a711d8d83fe5" translate="yes" xml:space="preserve">
          <source>The class subject remembers a list of observers in an instance variable, and has a distinguished method notify_observers to broadcast the message notify to all observers with a particular event e.</source>
          <target state="translated">클래스 주체는 인스턴스 변수의 관찰자 목록을 기억하고 특정 이벤트 e와 함께 모든 관찰자에게 메시지 알림을 브로드 캐스트하는 고유 한 방법 notify_observers를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="4100d907acfdcabf2433a494dd1a3e4d594e0d96" translate="yes" xml:space="preserve">
          <source>The class type expression &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;-&amp;gt;&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt; is the type of class functions (functions from values to classes) that take as argument a value of type &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; and return as result a class of type &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;.</source>
          <target state="translated">클래스 타입 발현 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr는&lt;/a&gt; -&amp;gt; &lt;a href=&quot;#class-type&quot;&gt;클래스 타입은&lt;/a&gt; 인수로 입력 값이 걸릴 (클래스 값으로부터 함수) 클래스 함수의 타입 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; 및 결과로서 리턴 형의 클래스 &lt;a href=&quot;#class-type&quot;&gt;클래스 타입&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ccb1b7cb0b9bf09c44c246b3d8b635b8df171c1b" translate="yes" xml:space="preserve">
          <source>The class type expression object [(&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;)] {&lt;a href=&quot;#class-field-spec&quot;&gt;class-field-spec&lt;/a&gt;} end is the type of a class body. It specifies its instance variables and methods. In this type, &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; is matched against the self type, therefore providing a name for the self type.</source>
          <target state="translated">클래스 유형 표현식 객체 [( &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; )] { &lt;a href=&quot;#class-field-spec&quot;&gt;class-field-spec&lt;/a&gt; } end는 클래스 본문의 유형입니다. 인스턴스 변수와 메서드를 지정합니다. 이 유형에서 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; 은 자체 유형과 일치하므로 자체 유형의 이름을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="54e83d883d9c89940ee922a012fe9586b0e83667" translate="yes" xml:space="preserve">
          <source>The class type parameters correspond to the ones of the class type and of the two type abbreviations defined by the class binding. They must be bound to actual types in the class definition using type constraints. So that the abbreviations are well-formed, type variables of the inferred type of the class must either be type parameters or be bound in the constraint clause.</source>
          <target state="translated">클래스 유형 매개 변수는 클래스 유형 중 하나와 클래스 바인딩에 의해 정의 된 두 가지 유형 약어에 해당합니다. 유형 제약 조건을 사용하여 클래스 정의의 실제 유형에 바인딩되어야합니다. 약어가 잘 구성되도록 클래스의 유추 된 유형의 유형 변수는 유형 매개 변수이거나 제약 조건 절에 바인딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a5fa7a046792c2877d81d775912d2e5ba688e9f6" translate="yes" xml:space="preserve">
          <source>The closing tag marker, as given by &lt;code&gt;mark_close_stag&amp;nbsp;t&lt;/code&gt;, is written into the output device of the formatter; then the &lt;code&gt;print_close_stag&lt;/code&gt; tag-printing function of the formatter is called with &lt;code&gt;t&lt;/code&gt; as argument.</source>
          <target state="translated">&lt;code&gt;mark_close_stag&amp;nbsp;t&lt;/code&gt; 에서 제공하는 닫는 태그 마커 는 포맷터의 출력 장치에 기록됩니다. 그러면 &lt;code&gt;print_close_stag&lt;/code&gt; 의 print_close_stag 태그 인쇄 함수가 &lt;code&gt;t&lt;/code&gt; 를 인수로 사용하여 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4f5a0cc5c3693ff9428c3a313f5f025808cf9ecb" translate="yes" xml:space="preserve">
          <source>The code resulting from applying -O3 -unbox-closures to this code passes the free variables via function arguments in order to eliminate all closure allocation in this example (aside from any that might be performed inside printf).</source>
          <target state="translated">이 코드에 -O3 -unbox-closures를 적용한 결과 코드는이 예제에서 모든 클로저 할당을 제거하기 위해 함수 인수를 통해 자유 변수를 전달합니다 (printf 내부에서 수행 될 수있는 항목 제외).</target>
        </trans-unit>
        <trans-unit id="a56e3d3e4c999f25e3f562df13ab73e9511528d5" translate="yes" xml:space="preserve">
          <source>The command line analysis is performed after loading the module containing the documentation generator, thus allowing command line options to be added to the list of existing ones. Adding an option can be done with the function</source>
          <target state="translated">명령 줄 분석은 문서 ​​생성기가 포함 된 모듈을로드 한 후 수행되므로 기존 옵션 목록에 명령 줄 옵션을 추가 할 수 있습니다. 옵션 추가는 기능으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="713e03c7df6783cbf595d790dada27c89d701a1d" translate="yes" xml:space="preserve">
          <source>The command line arguments given to the process.</source>
          <target state="translated">프로세스에 제공된 명령 줄 인수입니다.</target>
        </trans-unit>
        <trans-unit id="7aeece9eee37cad413bcf22ebfdfa0c87857f155" translate="yes" xml:space="preserve">
          <source>The command line arguments given to the process. The first element is the command name used to invoke the program. The following elements are the command-line arguments given to the program.</source>
          <target state="translated">프로세스에 제공된 명령 줄 인수입니다. 첫 번째 요소는 프로그램을 호출하는 데 사용되는 명령 이름입니다. 다음 요소는 프로그램에 제공되는 명령 줄 인수입니다.</target>
        </trans-unit>
        <trans-unit id="351afc02e66d69b38e7fb7bbf282c52d820d0b73" translate="yes" xml:space="preserve">
          <source>The command quit exits the debugger. You can also exit the debugger by typing an end-of-file character (usually ctrl-D).</source>
          <target state="translated">quit 명령은 디버거를 종료합니다. 파일 끝 문자 (일반적으로 ctrl-D)를 입력하여 디버거를 종료 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e23e32f6685f8bb7b921c0aa6a10415254fe4726" translate="yes" xml:space="preserve">
          <source>The compare field can be set to custom_compare_default; this default comparison function simply raises Failure.</source>
          <target state="translated">비교 필드는 custom_compare_default로 설정할 수 있습니다. 이 기본 비교 함수는 단순히 실패를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="400936dd851589bd58319e0915e19ac225ad000b" translate="yes" xml:space="preserve">
          <source>The compare field contains a pointer to a C function that is called whenever two custom blocks are compared using OCaml&amp;rsquo;s generic comparison operators (=, &amp;lt;&amp;gt;, &amp;lt;=, &amp;gt;=, &amp;lt;, &amp;gt; and compare). The C function should return 0 if the data contained in the two blocks are structurally equal, a negative integer if the data from the first block is less than the data from the second block, and a positive integer if the data from the first block is greater than the data from the second block.</source>
          <target state="translated">비교 필드에는 OCaml의 일반 비교 연산자 (=, &amp;lt;&amp;gt;, &amp;lt;=,&amp;gt; =, &amp;lt;,&amp;gt; 및 비교)를 사용하여 두 개의 사용자 지정 블록을 비교할 때마다 호출되는 C 함수에 대한 포인터가 포함되어 있습니다. C 함수는 두 블록에 포함 된 데이터가 구조적으로 동일하면 0을 반환하고, 첫 번째 블록의 데이터가 두 번째 블록의 데이터보다 작 으면 음의 정수를, 첫 번째 블록의 데이터가 다음과 같으면 양의 정수를 반환해야합니다. 두 번째 블록의 데이터보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="fc7b967b6bfa6059a95a5177a3d4d949e36cefb7" translate="yes" xml:space="preserve">
          <source>The compare_ext field can be set to custom_compare_ext_default; this default comparison function simply raises Failure.</source>
          <target state="translated">compare_ext 필드는 custom_compare_ext_default로 설정할 수 있습니다. 이 기본 비교 함수는 단순히 실패를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="2e507c128d533ecafbf0707e3311fd3954593733" translate="yes" xml:space="preserve">
          <source>The comparison function for 16-character digest, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; and the implementation shared with &lt;a href=&quot;string#VALcompare&quot;&gt;&lt;code&gt;String.compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">16 문자의 비교 기능이 동일한 사양, 다이제스트 &lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt; 및 공유 구현 &lt;a href=&quot;string#VALcompare&quot;&gt; &lt;code&gt;String.compare&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d93ed75e8c4197749446b6127b8c28c77f22cc5" translate="yes" xml:space="preserve">
          <source>The comparison function for 16-character digest, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt; and the implementation shared with &lt;a href=&quot;string#VALcompare&quot;&gt;&lt;code&gt;String.compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;Digest&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">16 문자의 비교 기능이 동일한 사양, 다이제스트 &lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt; 및 공유 구현 &lt;a href=&quot;string#VALcompare&quot;&gt; &lt;code&gt;String.compare&lt;/code&gt; &lt;/a&gt; . 이 함수 &lt;code&gt;compare&lt;/code&gt; 는 &lt;code&gt;t&lt;/code&gt; 유형과 함께 모듈 &lt;code&gt;Digest&lt;/code&gt; 가 펑터 &lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; 에&lt;/a&gt; 인수로 전달되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="e9f9a53259e71203663f8e69d67e5c99f6aeaf69" translate="yes" xml:space="preserve">
          <source>The comparison function for 32-bit integers, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt; 와 사양이 동일한 32 비트 정수에 대한 비교 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="52c057344f74f3ec299881602b4bac70c2781e4d" translate="yes" xml:space="preserve">
          <source>The comparison function for 32-bit integers, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;Int32&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt; 와 사양이 동일한 32 비트 정수에 대한 비교 함수입니다 . 유형 &lt;code&gt;t&lt;/code&gt; 와 함께이 함수 &lt;code&gt;compare&lt;/code&gt; 통해 모듈 &lt;code&gt;Int32&lt;/code&gt; 를 함수 &lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; 에&lt;/a&gt; 인수로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="32ed748cfcec44e96e26180791258594924fa2f5" translate="yes" xml:space="preserve">
          <source>The comparison function for 64-bit integers, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt; 와 사양이 동일한 64 비트 정수에 대한 비교 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="5d3cd3ac1cd893b13ee278ef969766aaeeb6d9d9" translate="yes" xml:space="preserve">
          <source>The comparison function for 64-bit integers, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;Int64&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt; 와 사양이 동일한 64 비트 정수에 대한 비교 함수입니다 . 유형 &lt;code&gt;t&lt;/code&gt; 와 함께이 함수 &lt;code&gt;compare&lt;/code&gt; 통해 모듈 &lt;code&gt;Int64&lt;/code&gt; 를 펑터 &lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; 에&lt;/a&gt; 인수로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bea1fb4f967f6e930a0a3f1b6dd8b3d9440baccf" translate="yes" xml:space="preserve">
          <source>The comparison function for byte sequences, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt; 와 동일한 사양을 가진 바이트 시퀀스에 대한 비교 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="c0c8f9bc7e72b4041efc638ebe36bb3de869d339" translate="yes" xml:space="preserve">
          <source>The comparison function for byte sequences, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;Bytes&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt; 와 동일한 사양을 가진 바이트 시퀀스에 대한 비교 함수입니다 . 유형 &lt;code&gt;t&lt;/code&gt; 와 함께이 함수 &lt;code&gt;compare&lt;/code&gt; 는 모듈 &lt;code&gt;Bytes&lt;/code&gt; 가 펑터 &lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; 에&lt;/a&gt; 인수로 전달되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="4248cb5972f6600877776ee5b7caa863058e709e" translate="yes" xml:space="preserve">
          <source>The comparison function for characters, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt; 와 동일한 사양을 가진 문자에 대한 비교 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="7f1c4568057988fd6052ab54ff61953ad29435a0" translate="yes" xml:space="preserve">
          <source>The comparison function for characters, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;Char&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt; 와 동일한 사양을 가진 문자에 대한 비교 함수입니다 . 유형 &lt;code&gt;t&lt;/code&gt; 와 함께이 함수 &lt;code&gt;compare&lt;/code&gt; 사용하면 모듈 &lt;code&gt;Char&lt;/code&gt; 가 함수 &lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; 에&lt;/a&gt; 인수로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c2863b10b77fa26a22a5fb611bbcda7b42b0bce" translate="yes" xml:space="preserve">
          <source>The comparison function for native integers, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt; 와 동일한 사양을 사용하는 네이티브 정수에 대한 비교 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="13b4368747939c68aea788a4bc151e1321dcb60a" translate="yes" xml:space="preserve">
          <source>The comparison function for native integers, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;Nativeint&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt; 와 동일한 사양을 사용하는 네이티브 정수에 대한 비교 함수입니다 . 유형 &lt;code&gt;t&lt;/code&gt; 와 함께이 함수 &lt;code&gt;compare&lt;/code&gt; 사용하면 모듈 &lt;code&gt;Nativeint&lt;/code&gt; 가 함수 &lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; 에&lt;/a&gt; 인수로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6d081b56d1fdbb9331b6bc0b8263048c0154295" translate="yes" xml:space="preserve">
          <source>The comparison function for strings, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt; 와 사양이 동일한 문자열에 대한 비교 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="73fb41656984243b49dbd382d60fab144a75f5a1" translate="yes" xml:space="preserve">
          <source>The comparison function for strings, with the same specification as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;. Along with the type &lt;code&gt;t&lt;/code&gt;, this function &lt;code&gt;compare&lt;/code&gt; allows the module &lt;code&gt;String&lt;/code&gt; to be passed as argument to the functors &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt; 와 사양이 동일한 문자열에 대한 비교 함수입니다 . 유형 &lt;code&gt;t&lt;/code&gt; 와 함께이 함수 &lt;code&gt;compare&lt;/code&gt; 를 사용하면 모듈 &lt;code&gt;String&lt;/code&gt; 을 펑터 &lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; 에&lt;/a&gt; 인수로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf96782a960b80262c43276b69181745eee6a160" translate="yes" xml:space="preserve">
          <source>The compilation units loaded by this function are added to the &quot;allowed units&quot; list (see &lt;a href=&quot;dynlink#VALset_allowed_units&quot;&gt;&lt;code&gt;Dynlink.set_allowed_units&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 함수에 의해로드 된 컴파일 단위는 &quot;허용 된 단위&quot;목록에 추가됩니다 ( &lt;a href=&quot;dynlink#VALset_allowed_units&quot;&gt; &lt;code&gt;Dynlink.set_allowed_units&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="2f8562bc429c53a9ee1fb8567862cc87267a563b" translate="yes" xml:space="preserve">
          <source>The compilation units loaded by this function are not added to the &quot;allowed units&quot; list (see &lt;a href=&quot;dynlink#VALset_allowed_units&quot;&gt;&lt;code&gt;Dynlink.set_allowed_units&lt;/code&gt;&lt;/a&gt;) since they cannot be referenced from other compilation units.</source>
          <target state="translated">이 함수에 의해로드 된 컴파일 단위 는 다른 컴파일 단위에서 참조 할 수 없으므로 &quot;허용 된 단위&quot;목록 ( &lt;a href=&quot;dynlink#VALset_allowed_units&quot;&gt; &lt;code&gt;Dynlink.set_allowed_units&lt;/code&gt; &lt;/a&gt; 참조 )에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="707933d508f6c3a7f70392088950a49fbd52b59f" translate="yes" xml:space="preserve">
          <source>The compiler aims to share constants lifted to toplevel such that there are no duplicate definitions. However if .cmx files are hidden from the compiler then maximal sharing may not be possible.</source>
          <target state="translated">컴파일러는 중복 정의가 없도록 최상위로 들어 올려 진 상수를 공유하는 것을 목표로합니다. 그러나 .cmx 파일이 컴파일러에서 숨겨지면 최대 공유가 불가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5839a1745e82e6942b420724963de7198ab2be1" translate="yes" xml:space="preserve">
          <source>The compiler always derives the module name by taking the capitalized base name of the source file (.ml or .mli file). That is, it strips the leading directory name, if any, as well as the .ml or .mli suffix; then, it set the first letter to uppercase, in order to comply with the requirement that module names must be capitalized. For instance, compiling the file mylib/misc.ml provides an implementation for the module named Misc. Other compilation units may refer to components defined in mylib/misc.ml under the names Misc.name; they can also do open Misc, then use unqualified names name.</source>
          <target state="translated">컴파일러는 항상 소스 파일 (.ml 또는 .mli 파일)의 대문자 기본 이름을 사용하여 모듈 이름을 파생합니다. 즉, 선행 디렉토리 이름 (있는 경우)과 .ml 또는 .mli 접미사를 제거합니다. 그런 다음 모듈 이름을 대문자로 표기해야한다는 요구 사항을 준수하기 위해 첫 글자를 대문자로 설정합니다. 예를 들어 mylib / misc.ml 파일을 컴파일하면 Misc라는 모듈에 대한 구현이 제공됩니다. 다른 컴파일 단위는 Misc.name이라는 이름으로 mylib / misc.ml에 정의 된 구성 요소를 참조 할 수 있습니다. 또한 Misc를 열고 정규화되지 않은 이름 이름을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="12a0d3bf4431d29fd5d6cebb56459fe2a6246977" translate="yes" xml:space="preserve">
          <source>The compiler can prove invariance of function arguments across multiple functions within a recursive group (although this has some limitations, as shown by the example below).</source>
          <target state="translated">컴파일러는 재귀 그룹 내의 여러 함수에 걸쳐 함수 인수의 불변성을 증명할 수 있습니다 (아래 예제에 표시된 것처럼 몇 가지 제한 사항이 있음).</target>
        </trans-unit>
        <trans-unit id="c3a13caf32a0850458a50504a9f9b67fbe141403" translate="yes" xml:space="preserve">
          <source>The compiler cannot currently detect invariance in cases such as the following.</source>
          <target state="translated">컴파일러는 현재 다음과 같은 경우 불변성을 감지 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6c5469d71b4fc3737466081b4134fc0bcc32f1c5" translate="yes" xml:space="preserve">
          <source>The compiler command line can be modified &amp;ldquo;from the outside&amp;rdquo; with the following mechanisms. These are experimental and subject to change. They should be used only for experimental and development work, not in released packages.</source>
          <target state="translated">컴파일러 명령 줄은 다음 메커니즘을 사용하여 &quot;외부에서&quot;수정할 수 있습니다. 이는 실험적이며 변경 될 수 있습니다. 릴리스 된 패키지가 아닌 실험 및 개발 작업에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9b6fd616c3d14b8722315aee0f9e2a79310b0ab4" translate="yes" xml:space="preserve">
          <source>The compiler distribution does not itself provide the facility for analysing Spacetime output files; this is left to external tools. The first such tool will appear in OPAM as a package called prof_spacetime. That tool will provide interactive graphical and terminal-based visualisation of the results of profiling.</source>
          <target state="translated">컴파일러 배포판 자체는 Spacetime 출력 파일을 분석하기위한 기능을 제공하지 않습니다. 이것은 외부 도구에 맡겨져 있습니다. 첫 번째 도구는 OPAM에 prof_spacetime이라는 패키지로 나타납니다. 이 도구는 프로파일 링 결과에 대한 대화 형 그래픽 및 터미널 기반 시각화를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="431b5a10ae44ff4efacaa2847555e5ec57afda8d" translate="yes" xml:space="preserve">
          <source>The compiler distribution provides an &amp;ldquo;otherlibs&amp;rdquo; library called raw_spacetime_lib for decoding Spacetime files. This library provides facilities to read not only memory profiling information but also the full dynamic call graph of the profiled program which is written into Spacetime output files.</source>
          <target state="translated">컴파일러 배포판은 Spacetime 파일을 디코딩하기 위해 raw_spacetime_lib라는 &quot;otherlibs&quot;라이브러리를 제공합니다. 이 라이브러리는 메모리 프로파일 링 정보뿐만 아니라 Spacetime 출력 파일에 기록 된 프로파일 링 된 프로그램의 전체 동적 호출 그래프를 읽을 수있는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="36caea4a11df67f29a0533e03c9c03a280e97c4b" translate="yes" xml:space="preserve">
          <source>The compiler does not include the runtime system (nor a reference to it) in the generated program; it must be supplied separately.</source>
          <target state="translated">컴파일러는 생성 된 프로그램에 런타임 시스템 (또는 이에 대한 참조)을 포함하지 않습니다. 별도로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="9fb9134b61ba76fc9c4316c0291fbc13063e70af" translate="yes" xml:space="preserve">
          <source>The compiler is able to emit some information on its internal stages. It can output .cmt files for the implementation of the compilation unit and .cmti for signatures if the option -bin-annot is passed to it (see the description of -bin-annot below). Each such file contains a typed abstract syntax tree (AST), that is produced during the type checking procedure. This tree contains all available information about the location and the specific type of each term in the source file. The AST is partial if type checking was unsuccessful.</source>
          <target state="translated">컴파일러는 내부 단계에서 일부 정보를 내보낼 수 있습니다. -bin-annot 옵션이 전달되면 컴파일 단위 구현을위한 .cmt 파일과 서명을위한 .cmti를 출력 할 수 있습니다 (아래 -bin-annot 설명 참조). 이러한 각 파일에는 형식 검사 절차 중에 생성되는 형식화 된 AST (추상 구문 트리)가 포함되어 있습니다. 이 트리에는 소스 파일에있는 각 용어의 특정 유형 및 위치에 대한 사용 가능한 모든 정보가 포함되어 있습니다. 유형 검사가 실패한 경우 AST는 부분적입니다.</target>
        </trans-unit>
        <trans-unit id="48ebb88864057cd3c0c7e6531c5d37c29d605813" translate="yes" xml:space="preserve">
          <source>The compiler notes down that for the function iter&amp;rsquo;, the argument f is specialised to the constant closure print_int. This means that the body of iter&amp;rsquo; may be simplified:</source>
          <target state="translated">컴파일러는 iter '함수의 경우 인수 f가 상수 클로저 print_int에 특화되어 있음을 기록합니다. 이것은 iter '의 본문이 단순화 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="65c5761f18846d3de8e8d4bc7344497dc351852c" translate="yes" xml:space="preserve">
          <source>The compiler produces this error when it tries to read a compiled interface file (.cmi file) that has the wrong structure. This means something went wrong when this .cmi file was written: the disk was full, the compiler was interrupted in the middle of the file creation, and so on. This error can also appear if a .cmi file is modified after its creation by the compiler. Fix: remove the corrupted .cmi file, and rebuild it.</source>
          <target state="translated">컴파일러는 잘못된 구조를 가진 컴파일 된 인터페이스 파일 (.cmi 파일)을 읽으려고 할 때이 오류를 생성합니다. 이것은이 .cmi 파일이 기록 될 때 문제가 발생했음을 의미합니다. 디스크가 꽉 찼거나 파일 생성 중에 컴파일러가 중단되는 등의 일이 발생했습니다. 이 오류는 컴파일러에서 .cmi 파일을 만든 후 수정 한 경우에도 나타날 수 있습니다. 수정 : 손상된 .cmi 파일을 제거하고 다시 빌드하십시오.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
