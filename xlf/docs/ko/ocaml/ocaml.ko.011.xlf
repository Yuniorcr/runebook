<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="20b2d8ee46fbd0ec43648349d2f501735b50eb59" translate="yes" xml:space="preserve">
          <source>The complete OCaml distribution can be accessed via the &lt;a href=&quot;https://ocaml.org/&quot;&gt;ocaml.org website&lt;/a&gt;. This site contains a lot of additional information on OCaml.</source>
          <target state="translated">전체 OCaml 배포판은 &lt;a href=&quot;https://ocaml.org/&quot;&gt;ocaml.org 웹 사이트&lt;/a&gt; 를 통해 액세스 할 수 있습니다 . 이 사이트에는 OCaml에 대한 많은 추가 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="581d160324d6b1dcf6f5966e788655a0b8d7c61c" translate="yes" xml:space="preserve">
          <source>The complex number &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">복소수 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a94f375eaa7012dabdc57ca285225234540e0a33" translate="yes" xml:space="preserve">
          <source>The complex number &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">복소수 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b43370e6d1b0c376b1980b552194da8b6181987d" translate="yes" xml:space="preserve">
          <source>The complex number &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">복소수 &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ad39316a87edf772e43a6c5b64a3e41e9c0e181" translate="yes" xml:space="preserve">
          <source>The concrete type describing the behavior associated with a keyword.</source>
          <target state="translated">키워드와 관련된 동작을 설명하는 구체적인 유형입니다.</target>
        </trans-unit>
        <trans-unit id="79be6aae51e8c401b2476f5b4f2a107a9fdc32ef" translate="yes" xml:space="preserve">
          <source>The constant pi.</source>
          <target state="translated">상수 파이.</target>
        </trans-unit>
        <trans-unit id="8ad8c44fad65df83c02fac0ee5f9d77f6672d992" translate="yes" xml:space="preserve">
          <source>The constraint on self&amp;rsquo;s type is requiring a public move method, and this is sufficient to override private.</source>
          <target state="translated">self의 유형에 대한 제약은 공개 이동 방법을 필요로하며 이는 비공개를 재정의하기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="a279814e737c452af822699c5733e5455892c221" translate="yes" xml:space="preserve">
          <source>The constraints associated to each constructor can be recovered through pattern-matching. Namely, if the type of the scrutinee of a pattern-matching contains a locally abstract type, this type can be refined according to the constructor used. These extra constraints are only valid inside the corresponding branch of the pattern-matching. If a constructor has some existential variables, fresh locally abstract types are generated, and they must not escape the scope of this branch.</source>
          <target state="translated">각 생성자에 연결된 제약 조건은 패턴 일치를 통해 복구 할 수 있습니다. 즉, 패턴 매칭의 스크 루틴 유형에 국부적으로 추상적 인 유형이 포함 된 경우이 유형은 사용 된 생성자에 따라 정제 될 수 있습니다. 이러한 추가 제약은 패턴 일치의 해당 분기 내에서만 유효합니다. 생성자에 실존 변수가있는 경우 새로운 로컬 추상 유형이 생성되며이 분기의 범위를 벗어나지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="72a6619fc6d35a54f266cbb1b53bb99ad5b03227" translate="yes" xml:space="preserve">
          <source>The construct constraint'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; allows the specification of type parameters. Any actual type argument corresponding to the type parameter &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; has to be an instance of &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; (more precisely, &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; are unified). Type variables of &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; can appear in the type equation and the type declaration.</source>
          <target state="translated">&lt;a href=&quot;types#typexpr&quot;&gt;컨스 트럭 트&lt;/a&gt; 제약의 &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; = typexpr 은 타입 매개 변수의 지정을 허용합니다. 유형 매개 변수 &lt;a href=&quot;lex#ident&quot;&gt;ident에&lt;/a&gt; 해당하는 실제 유형 인수 는 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; 의 인스턴스 여야합니다 (보다 정확하게는 &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; 및 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; 이 통합됨 ). &lt;a href=&quot;types#typexpr&quot;&gt;typexpr의&lt;/a&gt; 유형 변수는 유형 방정식 및 유형 선언에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6dcf637d8dc6131f0b0eb619e7d7999e61b6d1b" translate="yes" xml:space="preserve">
          <source>The construct constraint&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; forces the two type expressions to be equal. This is typically used to specify type parameters: in this way, they can be bound to specific type expressions.</source>
          <target state="translated">구문 제약 조건 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 는 두 형식식이 동일하도록 강제합니다. 일반적으로 유형 매개 변수를 지정하는 데 사용됩니다. 이러한 방식으로 특정 유형 표현식에 바인딩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e91937a9ebb9b2f875d8df7aec3ae920407278b6" translate="yes" xml:space="preserve">
          <source>The construct constraint&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; forces the two type expressions to be equals. This is typically used to specify type parameters: in that way they can be bound to specific type expressions.</source>
          <target state="translated">컨스 &lt;a href=&quot;types#typexpr&quot;&gt;트럭 트&lt;/a&gt; 제약 typexpr &lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 는 두 유형 표현식을 동일하게 만듭니다. 이것은 일반적으로 유형 매개 변수를 지정하는 데 사용됩니다. 이러한 방식으로 특정 유형 표현식에 바인드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4111af28e88c74529d924590f2259579d7eddcd6" translate="yes" xml:space="preserve">
          <source>The construction moduletypeof&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; expands to the module type (signature or functor type) inferred for the module expression &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;. To make this module type reusable in many situations, it is intentionally not strengthened: abstract types and datatypes are not explicitly related with the types of the original module. For the same reason, module aliases in the inferred type are expanded.</source>
          <target state="translated">&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; 의 구성 moduletype 은 모듈 표현식 &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr에&lt;/a&gt; 대해 유추 된 모듈 유형 (서명 또는 함수 유형)으로 확장됩니다 . 이 모듈 유형을 여러 상황에서 재사용 할 수 있도록하기 위해 의도적으로 강화되지 않았습니다. 추상 유형 및 데이터 유형은 원래 모듈 유형과 명시 적으로 관련되지 않습니다. 같은 이유로 유추 된 유형의 모듈 별칭이 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="760fdc00af3cbc0e13df9af8553cc7a286bca119" translate="yes" xml:space="preserve">
          <source>The constructor &lt;code&gt;()&lt;/code&gt; is included here so that it has a path, but it is not intended to be used in user-defined data types.</source>
          <target state="translated">생성자 &lt;code&gt;()&lt;/code&gt; 는 여기에 포함되어 경로를 갖지만 사용자 정의 데이터 유형에 사용하기위한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a3003c0bbe668e94ab79defd3f710132d87092a6" translate="yes" xml:space="preserve">
          <source>The constructors &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; are included here so that they have paths, but they are not intended to be used in user-defined data types.</source>
          <target state="translated">생성자 &lt;code&gt;false&lt;/code&gt; 및 &lt;code&gt;true&lt;/code&gt; 가 여기에 포함되어 경로가 있지만 사용자 정의 데이터 유형에서 사용하기위한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="16640eb9daf1519aa608d0b29675645a8a35f3cb" translate="yes" xml:space="preserve">
          <source>The content inside {%foo: ... %} is target-specific and will only be interpreted by the backend foo, and ignored by the others. The backends of the distribution are latex, html, texi and man. If no target is specified (syntax {% ... %}), latex is chosen by default. Custom generators may support their own target prefix.</source>
          <target state="translated">{% foo : ... %}의 내용은 타겟에 따라 다르며 백엔드 foo에 의해서만 해석되고 나머지는 무시됩니다. 배포판의 백엔드는 latex, html, texi 및 man입니다. 대상이 지정되지 않은 경우 (구문 {% ... %}) 기본적으로 라텍스가 선택됩니다. 사용자 지정 생성기는 자체 대상 접두사를 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c5c2fffb0418b713216d4c77f75ee03f3710a80" translate="yes" xml:space="preserve">
          <source>The contents of custom blocks are not scanned by the garbage collector, and must therefore not contain any pointer inside the OCaml heap. In other terms, never store an OCaml value in a custom block, and do not use Field, Store_field nor caml_modify to access the data part of a custom block. Conversely, any C data structure (not containing heap pointers) can be stored in a custom block.</source>
          <target state="translated">사용자 정의 블록의 내용은 가비지 수집기에 의해 스캔되지 않으므로 OCaml 힙 내부에 포인터를 포함하지 않아야합니다. 즉, 사용자 지정 블록에 OCaml 값을 저장하지 말고 Field, Store_field 또는 caml_modify를 사용하여 사용자 지정 블록의 데이터 부분에 액세스하지 마십시오. 반대로 모든 C 데이터 구조 (힙 포인터를 포함하지 않음)는 사용자 정의 블록에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="785642c4a4c006be73a07a4f7ec8afa9d91aa1ff" translate="yes" xml:space="preserve">
          <source>The conventional name for the current directory (e.g.</source>
          <target state="translated">현재 디렉토리의 일반적인 이름 (예 :</target>
        </trans-unit>
        <trans-unit id="ab0089cb61bfc166d7c15a2b68e795215831943d" translate="yes" xml:space="preserve">
          <source>The conventional name for the current directory (e.g. &lt;code&gt;.&lt;/code&gt; in Unix).</source>
          <target state="translated">현재 디렉토리에 대한 일반적인 이름 (예 &lt;code&gt;.&lt;/code&gt; 유닉스에서).</target>
        </trans-unit>
        <trans-unit id="545670a3a8b2e0fff49a5ac43c08636390916185" translate="yes" xml:space="preserve">
          <source>The conventional name for the parent of the current directory (e.g.</source>
          <target state="translated">현재 디렉토리의 상위에 대한 일반적인 이름 (예 :</target>
        </trans-unit>
        <trans-unit id="9b950ea81536e7df7421680a6cf3781982072c75" translate="yes" xml:space="preserve">
          <source>The conventional name for the parent of the current directory (e.g. &lt;code&gt;..&lt;/code&gt; in Unix).</source>
          <target state="translated">현재 디렉토리의 상위에 대한 일반적인 이름 (예 : Unix에서는 &lt;code&gt;..&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="33e422b54f028d0f9f99ad979df276c42ced7356" translate="yes" xml:space="preserve">
          <source>The conversion characters and their meanings are:</source>
          <target state="translated">변환 문자와 그 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8cb23e02c094574c60663d78adfeb6ade600463a" translate="yes" xml:space="preserve">
          <source>The corresponding C type must be intnat.</source>
          <target state="translated">해당 C 유형은 intnat 여야합니다.</target>
        </trans-unit>
        <trans-unit id="31b0b9138835461b550a52acf6e1102fcf625f54" translate="yes" xml:space="preserve">
          <source>The cost of a &lt;em&gt;primitive&lt;/em&gt;. Primitives encompass operations including arithmetic and memory access.</source>
          <target state="translated">a의 비용 &lt;em&gt;원시적&lt;/em&gt; . 프리미티브는 산술 및 메모리 액세스를 포함한 연산을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="2821dc95f75734aab94e295a923c218e0df1c9bf" translate="yes" xml:space="preserve">
          <source>The cost of a branch.</source>
          <target state="translated">지점 비용.</target>
        </trans-unit>
        <trans-unit id="c804487a1287d7acc06a19d856642958b1444628" translate="yes" xml:space="preserve">
          <source>The cost of a direct function call.</source>
          <target state="translated">직접 함수 호출 비용.</target>
        </trans-unit>
        <trans-unit id="534cefa77673c331e56e7d9f6dd6b1f2ed24344c" translate="yes" xml:space="preserve">
          <source>The cost of an allocation.</source>
          <target state="translated">할당 비용.</target>
        </trans-unit>
        <trans-unit id="9c86a389e7f94b0cbdc2d7b61509a2068780aa63" translate="yes" xml:space="preserve">
          <source>The cost of an indirect function call.</source>
          <target state="translated">간접 함수 호출 비용.</target>
        </trans-unit>
        <trans-unit id="3ad4c2d03309e92f9ae01be1d5e41f51136f454b" translate="yes" xml:space="preserve">
          <source>The current default is next-fit, as the best-fit policy is new and not yet widely tested. We expect best-fit to become the default in the future.</source>
          <target state="translated">최적 정책은 새롭고 아직 광범위하게 테스트되지 않았으므로 현재 기본값은 next-fit입니다. 우리는 best-fit이 향후 기본값이 될 것으로 기대합니다.</target>
        </trans-unit>
        <trans-unit id="3b8c08752945457971d1f3f4ac09df0af940d32a" translate="yes" xml:space="preserve">
          <source>The current implementation limits each variant type to have at most 246 non-constant constructors and 2&lt;sup&gt;30&lt;/sup&gt;&amp;minus;1 constant constructors.</source>
          <target state="translated">현재 구현 많아야 246 아닌 상수 생성자 및도 2가 각 변형 유형을 제한 &lt;sup&gt;30&lt;/sup&gt; -1 상수 생성자.</target>
        </trans-unit>
        <trans-unit id="f9a96ae8d528ab0d30d73879bd55f0ed974647fc" translate="yes" xml:space="preserve">
          <source>The current implementation places practically no restrictions on the length of string literals.</source>
          <target state="translated">현재 구현에서는 문자열 리터럴의 길이에 사실상 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8888fe7c320796681a86d9fc38d5331494f11ea4" translate="yes" xml:space="preserve">
          <source>The current implementation uses Heap Sort. It runs in constant stack space.</source>
          <target state="translated">현재 구현에서는 힙 정렬을 사용합니다. 일정한 스택 공간에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="aa3296295a4df646c086eb4650f57f70f9f85c18" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</source>
          <target state="translated">현재 구현에서는 병합 정렬을 사용합니다. 일정한 힙 공간과 로그 스택 공간에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b5d51df06a97d47df008e45a13c0928311228904" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It uses &lt;code&gt;n/2&lt;/code&gt; words of heap space, where &lt;code&gt;n&lt;/code&gt; is the length of the array. It is usually faster than the current implementation of &lt;a href=&quot;arraylabels#VALsort&quot;&gt;&lt;code&gt;ArrayLabels.sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 구현에서는 병합 정렬을 사용합니다. 그것은 사용하는 &lt;code&gt;n/2&lt;/code&gt; 더미 공간 단어, 여기서 &lt;code&gt;n&lt;/code&gt; 은 어레이의 길이이다. 일반적으로 &lt;a href=&quot;arraylabels#VALsort&quot;&gt; &lt;code&gt;ArrayLabels.sort&lt;/code&gt; &lt;/a&gt; 의 현재 구현보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="d71af0bf722f0a317f82d7cfc36b49481534370f" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It uses a temporary array of length &lt;code&gt;n/2&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the length of the array. It is usually faster than the current implementation of &lt;a href=&quot;array#VALsort&quot;&gt;&lt;code&gt;Array.sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 구현에서는 병합 정렬을 사용합니다. 길이가 &lt;code&gt;n/2&lt;/code&gt; 인 임시 배열을 사용합니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은 배열의 길이입니다. 일반적으로 현재 &lt;a href=&quot;array#VALsort&quot;&gt; &lt;code&gt;Array.sort&lt;/code&gt; &lt;/a&gt; 구현보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="bdff8609298ac6203743f842126dd2f7ca872714" translate="yes" xml:space="preserve">
          <source>The current implementation uses Merge Sort. It uses a temporary floatarray of length &lt;code&gt;n/2&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the length of the floatarray. It is usually faster than the current implementation of &lt;a href=&quot;float.array#VALsort&quot;&gt;&lt;code&gt;Float.Array.sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 구현에서는 병합 정렬을 사용합니다. 길이가 &lt;code&gt;n/2&lt;/code&gt; 인 임시 floatarray를 사용합니다 . 여기서 &lt;code&gt;n&lt;/code&gt; 은 floatarray의 길이입니다. 일반적으로 &lt;a href=&quot;float.array#VALsort&quot;&gt; &lt;code&gt;Float.Array.sort&lt;/code&gt; &lt;/a&gt; 의 현재 구현보다 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="b20647dbf18c92523a7fd6b83c3b58c9724e3e7a" translate="yes" xml:space="preserve">
          <source>The custom break is useful if you want to change which visible (non-whitespace) characters are printed in case of break or no break. For example, when printing a list</source>
          <target state="translated">사용자 지정 구분은 구분이 있거나 구분이없는 경우 인쇄되는 표시되는 (공백이 아닌) 문자를 변경하려는 경우에 유용합니다. 예를 들어, 목록을 인쇄 할 때</target>
        </trans-unit>
        <trans-unit id="8b24549afabe1745d997e15b64b4d2aae161436a" translate="yes" xml:space="preserve">
          <source>The data is considered by the garbage collector alive if all the full keys are alive and if the ephemeron is alive. When one of the keys is not considered alive anymore by the GC, the data is emptied from the ephemeron. The data could be alive for another reason and in that case the GC will not free it, but the ephemeron will not hold the data anymore.</source>
          <target state="translated">모든 전체 키가 활성 상태이고 ephemeron이 활성 상태이면 가비지 수집기에서 데이터를 활성 상태로 간주합니다. GC에서 키 중 하나가 더 이상 활성 상태로 간주되지 않으면 데이터가 에페 메론에서 비워집니다. 데이터는 다른 이유로 살아있을 수 있으며이 경우 GC는 데이터를 해제하지 않지만 ephemeron은 더 이상 데이터를 보유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac0854565c0cabc94cf88db7d79f91eea95e9a7c" translate="yes" xml:space="preserve">
          <source>The data part of a custom block v can be accessed via the pointer Data_custom_val(v). This pointer has type void * and should be cast to the actual type of the data stored in the custom block.</source>
          <target state="translated">사용자 지정 블록 v의 데이터 부분은 Data_custom_val (v) 포인터를 통해 액세스 할 수 있습니다. 이 포인터는 void * 유형을 가지며 사용자 정의 블록에 저장된 데이터의 실제 유형으로 캐스트되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e8e6e6b562a36d00a364c6de4dc0a4ef30f6a91f" translate="yes" xml:space="preserve">
          <source>The debugger can print the current value of simple expressions. The expressions can involve program variables: all the identifiers that are in scope at the selected program point can be accessed.</source>
          <target state="translated">디버거는 단순 표현식의 현재 값을 인쇄 할 수 있습니다. 식에는 프로그램 변수가 포함될 수 있습니다. 선택한 프로그램 지점에서 범위에있는 모든 식별자에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8c3dc260564ad64dea40270472823def2648071" translate="yes" xml:space="preserve">
          <source>The debugger communicate with the program being debugged through a Unix socket. You may need to change the socket name, for example if you need to run the debugger on a machine and your program on another.</source>
          <target state="translated">디버거는 Unix 소켓을 통해 디버깅중인 프로그램과 통신합니다. 예를 들어 컴퓨터에서 디버거를 실행하고 다른 컴퓨터에서 프로그램을 실행해야하는 경우 소켓 이름을 변경해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89cf1e71a9b9ce7771fbb1158aff4c5ec71b350f" translate="yes" xml:space="preserve">
          <source>The debugger execute the OCaml runtime ocamlrun on the program. Rarely useful; moreover it prevents the debugging of programs compiled in &amp;ldquo;custom runtime&amp;rdquo; mode.</source>
          <target state="translated">디버거는 프로그램에서 OCaml 런타임 ocamlrun을 실행합니다. 거의 유용하지 않습니다. 또한 &quot;사용자 지정 런타임&quot;모드에서 컴파일 된 프로그램의 디버깅을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="d8a4e05ea8e12b749680b25bf9ad4fb77bd551fb" translate="yes" xml:space="preserve">
          <source>The debugger is compatible with the Dynlink module. However, when an external module is not yet loaded, it is impossible to set a breakpoint in its code. In order to facilitate setting breakpoints in dynamically loaded code, the debugger stops the program each time new modules are loaded. This behavior can be disabled using the break_on_load variable:</source>
          <target state="translated">디버거는 Dynlink 모듈과 호환됩니다. 그러나 외부 모듈이 아직로드되지 않은 경우 해당 코드에 중단 점을 설정할 수 없습니다. 동적으로로드 된 코드에서 중단 점 설정을 용이하게하기 위해 디버거는 새 모듈이로드 될 때마다 프로그램을 중지합니다. 이 동작은 break_on_load 변수를 사용하여 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67085f47487648631c3de0d3b7f5a54b54f116e7" translate="yes" xml:space="preserve">
          <source>The debugger searches for source files and compiled interface files in a list of directories, the search path. The search path initially contains the current directory . and the standard library directory. The directory command adds directories to the path.</source>
          <target state="translated">디버거는 디렉토리 목록 인 검색 경로에서 소스 파일과 컴파일 된 인터페이스 파일을 검색합니다. 검색 경로는 처음에 현재 디렉토리를 포함합니다. 및 표준 라이브러리 디렉토리. directory 명령은 경로에 디렉토리를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="d81bce2c8314b77a05e6061c8832d983f35d9089" translate="yes" xml:space="preserve">
          <source>The debugger starts executing the debugged program only when needed. This allows setting breakpoints or assigning debugger variables before execution starts. There are several ways to start execution:</source>
          <target state="translated">디버거는 필요한 경우에만 디버깅 된 프로그램 실행을 시작합니다. 이를 통해 실행이 시작되기 전에 중단 점을 설정하거나 디버거 변수를 할당 할 수 있습니다. 실행을 시작하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c85faabbbf8e1f661bc7a77c9db172d2189ae3c" translate="yes" xml:space="preserve">
          <source>The declaration of a variant type lists all possible forms for values of that type. Each case is identified by a name, called a constructor, which serves both for constructing values of the variant type and inspecting them by pattern-matching. Constructor names are capitalized to distinguish them from variable names (which must start with a lowercase letter). For instance, here is a variant type for doing mixed arithmetic (integers and floats):</source>
          <target state="translated">변형 유형의 선언은 해당 유형의 값에 대해 가능한 모든 형식을 나열합니다. 각 케이스는 생성자라고하는 이름으로 식별되며, 이는 변형 유형의 값을 구성하고 패턴 일치로 검사하는 데 모두 사용됩니다. 생성자 이름은 변수 이름 (소문자로 시작해야 함)과 구별하기 위해 대문자로 표시됩니다. 예를 들어 다음은 혼합 산술 (정수 및 부동 소수점)을 수행하기위한 변형 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6dc771c421fb48e91d66c641d430796a079c9f9c" translate="yes" xml:space="preserve">
          <source>The declarations of the built-in types and the components of module Stdlib are printed one by one in typewriter font, followed by a short comment. All library modules and the components they provide are indexed at the end of this report.</source>
          <target state="translated">내장 유형의 선언과 모듈 Stdlib의 구성 요소는 타자기 글꼴로 하나씩 인쇄되고 그 뒤에 짧은 주석이 표시됩니다. 모든 라이브러리 모듈과 이들이 제공하는 구성 요소는이 보고서의 끝 부분에 인덱싱됩니다.</target>
        </trans-unit>
        <trans-unit id="2765fb82c88da6a8123fcc1afb411e9f247fbfa9" translate="yes" xml:space="preserve">
          <source>The default representation. In the present version of OCaml, the default is the boxed representation.</source>
          <target state="translated">기본 표현입니다. 현재 버전의 OCaml에서 기본값은 박스형 표현입니다.</target>
        </trans-unit>
        <trans-unit id="74b33452fd1e9690245e62c43fa2151918346419" translate="yes" xml:space="preserve">
          <source>The default setting is &amp;rsquo;auto&amp;rsquo;, and the current heuristic checks that the TERM environment variable exists and is not empty or dumb, and that &amp;rsquo;isatty(stderr)&amp;rsquo; holds.</source>
          <target state="translated">기본 설정은 'auto'이며 현재 휴리스틱은 TERM 환경 변수가 존재하고 비어 있거나 벙어리가 아닌지, 'isatty (stderr)'가 유지되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="08126df5b12a33c60b2609d1299988ea98c261cf" translate="yes" xml:space="preserve">
          <source>The default setting is -w +a-4-6-7-9-27-29-32..42-44-45-48-50-60. It is displayed by  -help. Note that warnings 5 and 10 are not always triggered, depending on the internals of the type checker.</source>
          <target state="translated">기본 설정은 -w + a-4-6-7-9-27-29-32..42-44-45-48-50-60입니다. -help로 표시됩니다. 유형 검사기의 내부에 따라 경고 5 및 10이 항상 트리거되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ed097a6c98a3e8cb9832ea96755d5d9244c148bd" translate="yes" xml:space="preserve">
          <source>The default setting is -w +a-4-6-7-9-27-29-32..42-44-45-48-50-60. It is displayed by ocamlc -help. Note that warnings 5 and 10 are not always triggered, depending on the internals of the type checker.</source>
          <target state="translated">기본 설정은 -w + a-4-6-7-9-27-29-32..42-44-45-48-50-60입니다. ocamlc -help에 의해 표시됩니다. 유형 검사기의 내부에 따라 경고 5 및 10이 항상 트리거되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7ab6f8a18cb9ae711fa680c3d32f93edfefbee98" translate="yes" xml:space="preserve">
          <source>The default setting is -w +a-4-6-7-9-27-29-32..42-44-45-48-50-60. It is displayed by ocamlopt -help. Note that warnings 5 and 10 are not always triggered, depending on the internals of the type checker.</source>
          <target state="translated">기본 설정은 -w + a-4-6-7-9-27-29-32..42-44-45-48-50-60입니다. ocamlopt -help에 의해 표시됩니다. 유형 검사기의 내부에 따라 경고 5 및 10이 항상 트리거되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3eff228cd3aa401186be612172c09c21427569b2" translate="yes" xml:space="preserve">
          <source>The default setting is -warn-error -a+31 (only warning 31 is fatal).</source>
          <target state="translated">기본 설정은 -warn-error -a + 31입니다 (경고 31 만 치명적 임).</target>
        </trans-unit>
        <trans-unit id="d8b548e294caad0232bcef920b432423c497646b" translate="yes" xml:space="preserve">
          <source>The default setting is contextual.</source>
          <target state="translated">기본 설정은 컨텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="4549da8d617844ebcd908e7e44273e838886bca2" translate="yes" xml:space="preserve">
          <source>The default settings (when not using -Oclassic) are for one round of optimisation using the following parameters.</source>
          <target state="translated">기본 설정 (-Oclassic을 사용하지 않는 경우)은 다음 매개 변수를 사용하는 한 번의 최적화를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5f4796a7bec8a2fd44bd0c64ad6daa008bf2c968" translate="yes" xml:space="preserve">
          <source>The default trace filename is caml-{PID}.eventlog, where {PID} is the process identifier of the traced program.</source>
          <target state="translated">기본 추적 파일 이름은 caml- {PID} .eventlog입니다. 여기서 {PID}는 추적 된 프로그램의 프로세스 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="56ba28d4eda458e2debd6c11d3035373c9678204" translate="yes" xml:space="preserve">
          <source>The definition val [mutable] &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; adds an instance variable &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; whose initial value is the value of expression &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;. The flag mutable allows physical modification of this variable by methods.</source>
          <target state="translated">val [mutable] &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; = &lt;a href=&quot;expr#expr&quot;&gt;expr 정의&lt;/a&gt; 는 초기 값이 &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; 표현식의 값인 인스턴스 변수 &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name을&lt;/a&gt; 추가합니다 . mutable 플래그는 메소드에 의해이 변수의 물리적 수정을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a51442850ae9805c91c304fd05e9989dc50518ce" translate="yes" xml:space="preserve">
          <source>The deserialize field can be set to custom_deserialize_default to indicate that deserialization is not supported. In this case, do not register the struct custom_operations with the deserializer using register_custom_operations (see below).</source>
          <target state="translated">deserialize 필드를 custom_deserialize_default로 설정하여 deserialization이 지원되지 않음을 나타낼 수 있습니다. 이 경우 register_custom_operations를 사용하여 deserializer에 custom_operations 구조체를 등록하지 마십시오 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="7d06ebe0f4fedec527437bd502a65f8f670ba5db" translate="yes" xml:space="preserve">
          <source>The deserialize field contains a pointer to a C function that is called whenever a custom block with identifier identifier needs to be deserialized (un-marshaled) using the OCaml functions input_value or Marshal.from_.... This user-provided function is responsible for reading back the data written by the serialize operation, using the deserialize_... functions defined in &amp;lt;caml/intext.h&amp;gt; and listed below. It must then rebuild the data part of the custom block and store it at the pointer given as the dst argument. Finally, it returns the size in bytes of the data part of the custom block. This size must be identical to the wsize_32 result of the serialize operation if the architecture is 32 bits, or wsize_64 if the architecture is 64 bits.</source>
          <target state="translated">deserialize 필드에는 OCaml 함수 input_value 또는 Marshal.from _....을 사용하여 식별자 식별자가있는 사용자 정의 블록을 역 직렬화 (비 정렬 화)해야 할 때마다 호출되는 C 함수에 대한 포인터가 포함됩니다.이 사용자 제공 함수는 &amp;lt;caml / intext.h&amp;gt;에 정의되고 아래에 나열된 deserialize _... 함수를 사용하여 직렬화 작업에 의해 쓰여진 데이터를 다시 읽습니다. 그런 다음 사용자 지정 블록의 데이터 부분을 다시 빌드하고 dst 인수로 지정된 포인터에 저장해야합니다. 마지막으로 사용자 지정 블록의 데이터 부분 크기를 바이트 단위로 반환합니다. 이 크기는 아키텍처가 32 비트 인 경우 직렬화 작업의 wsize_32 결과와 동일해야하며 아키텍처가 64 비트 인 경우 wsize_64와 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="e12a3fa498a55d5d0c412779070a2ed53e0f6b56" translate="yes" xml:space="preserve">
          <source>The deterministic automata generated by ocamllex are limited to at most 32767 transitions. The message above indicates that your lexer definition is too complex and overflows this limit. This is commonly caused by lexer definitions that have separate rules for each of the alphabetic keywords of the language, as in the following example.</source>
          <target state="translated">ocamllex에 의해 생성 된 결정 론적 오토마타는 최대 32767 개의 전환으로 제한됩니다. 위의 메시지는 렉서 정의가 너무 복잡하고이 제한을 초과했음을 나타냅니다. 이는 일반적으로 다음 예제와 같이 언어의 각 알파벳 키워드에 대해 별도의 규칙이있는 어휘 분석기 정의로 인해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f264a27cdcd5df325cf7076559a44cc284c906a3" translate="yes" xml:space="preserve">
          <source>The deterministic automata generated by ocamllex maintain a table of positions inside the scanned lexer buffer. The size of this table is limited to at most 255 cells. This error should not show up in normal situations.</source>
          <target state="translated">ocamllex에 의해 생성 된 결정 론적 오토마타는 스캔 된 렉서 버퍼 내부의 위치 테이블을 유지합니다. 이 테이블의 크기는 최대 255 개의 셀로 제한됩니다. 이 오류는 정상적인 상황에서는 나타나지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="3158707a3751ac6c5252dbe261969b8247c51cac" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;1.0&lt;/code&gt; and the smallest exactly representable floating-point number greater than &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;1.0&lt;/code&gt; 과 &lt;code&gt;1.0&lt;/code&gt; 보다 큰 정확히 표현할 수있는 가장 작은 부동 소수점 숫자 사이의 차이 입니다.</target>
        </trans-unit>
        <trans-unit id="2adcbc0a31dc0085a55ca93ed2f074bdee4bf581" translate="yes" xml:space="preserve">
          <source>The difference between open and include is that open simply provides short names for the components of the opened structure, without defining any components of the current structure, while include also adds definitions for the components of the included structure.</source>
          <target state="translated">open과 include의 차이점은 open은 현재 구조의 구성 요소를 정의하지 않고 열린 구조의 구성 요소에 대한 짧은 이름을 제공하는 반면 include는 포함 된 구조의 구성 요소에 대한 정의도 추가한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9aa0efd021b346152ef35413cf1dcb66bfc3d8c0" translate="yes" xml:space="preserve">
          <source>The difficulty usually lies in defining instances of the pattern above by inheritance. This can be done in a natural and obvious manner in OCaml, as shown on the following example manipulating windows.</source>
          <target state="translated">어려움은 일반적으로 상속을 통해 위의 패턴 인스턴스를 정의하는 데 있습니다. 이것은 창을 조작하는 다음 예제와 같이 OCaml에서 자연스럽고 분명한 방식으로 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c440f9c47d69da4fc51fae25d28e485866ceeae" translate="yes" xml:space="preserve">
          <source>The directory containing the OCaml standard library. (If OCAMLLIB is not set, CAMLLIB will be used instead.) Used to locate the ld.conf configuration file for dynamic loading (see section &lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;). If not set, default to the library directory specified when compiling OCaml.</source>
          <target state="translated">OCaml 표준 라이브러리가 포함 된 디렉토리입니다. (OCAMLLIB가 설정되지 않은 경우 CAMLLIB가 대신 사용됩니다.) 동적로드를위한 ld.conf 구성 파일을 찾는 데 사용됩니다 (섹션 &lt;a href=&quot;#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt; 참조 ). 설정되지 않은 경우 OCaml을 컴파일 할 때 지정된 라이브러리 디렉토리를 기본값으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="84d3f5e5913ebfecb51ac69e325978cd0b7f44c0" translate="yes" xml:space="preserve">
          <source>The directory separator (e.g.</source>
          <target state="translated">디렉토리 구분자 (예 :</target>
        </trans-unit>
        <trans-unit id="6ff406baa499fe8d2e26970180e41618d3f08eae" translate="yes" xml:space="preserve">
          <source>The directory separator (e.g. &lt;code&gt;/&lt;/code&gt; in Unix).</source>
          <target state="translated">디렉토리 구분자 (예 : Unix의 &lt;code&gt;/&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cabc8641d53a500b754d86780ff17e145160ba34" translate="yes" xml:space="preserve">
          <source>The distinction between &lt;code&gt;bytes&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt; was introduced in OCaml 4.02, and the &quot;unsafe-string&quot; compatibility mode was the default until OCaml 4.05. Starting with 4.06, the compatibility mode is opt-in; we intend to remove the option in the future.</source>
          <target state="translated">&lt;code&gt;bytes&lt;/code&gt; 와 &lt;code&gt;string&lt;/code&gt; 의 구분은 OCaml 4.02에서 도입되었으며 &quot;안전하지 않은 문자열&quot;호환성 모드는 OCaml 4.05까지 기본값이었습니다. 4.06부터 호환성 모드는 옵트 인입니다. 향후이 옵션을 제거 할 예정입니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="8186633942c846dfc9406083eb5c8a8657d3ebba" translate="yes" xml:space="preserve">
          <source>The domain of a coercion can often be omitted. For instance, one can define:</source>
          <target state="translated">강제의 영역은 종종 생략 될 수 있습니다. 예를 들어 다음을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f7c83c21065a6dbadc8d2a47e55b23520a044b2" translate="yes" xml:space="preserve">
          <source>The dump file is written only if the program terminates normally (by calling exit or by falling through). It is not written if the program terminates with an uncaught exception.</source>
          <target state="translated">덤프 파일은 프로그램이 정상적으로 종료되는 경우에만 작성됩니다 (exit 호출 또는 폴 스루). 프로그램이 포착되지 않은 예외로 종료되면 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73f7bba6640e6313fca9805d26493bd64599c1bc" translate="yes" xml:space="preserve">
          <source>The dynlink library supports type-safe dynamic loading and linking of bytecode object files (.cmo and .cma files) in a running bytecode program, or of native plugins (usually .cmxs files) in a running native program. Type safety is ensured by limiting the set of modules from the running program that the loaded object file can access, and checking that the running program and the loaded object file have been compiled against the same interfaces for these modules. In native code, there are also some compatibility checks on the implementations (to avoid errors with cross-module optimizations); it might be useful to hide .cmx files when building native plugins so that they remain independent of the implementation of modules in the main program.</source>
          <target state="translated">dynlink 라이브러리는 실행중인 바이트 코드 프로그램에서 바이트 코드 개체 파일 (.cmo 및 .cma 파일) 또는 실행중인 기본 프로그램에서 기본 플러그인 (일반적으로 .cmxs 파일)의 유형 안전 동적로드 및 링크를 지원합니다. 로드 된 개체 파일이 액세스 할 수있는 실행중인 프로그램의 모듈 집합을 제한하고 실행중인 프로그램과로드 된 개체 파일이 이러한 모듈에 대해 동일한 인터페이스에 대해 컴파일되었는지 확인하여 형식 안전성이 보장됩니다. 네이티브 코드에는 구현에 대한 호환성 검사도 있습니다 (교차 모듈 최적화로 오류를 방지하기 위해). 기본 플러그인을 빌드 할 때 .cmx 파일을 숨기면 기본 프로그램의 모듈 구현과 독립적으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="bfccb11647d7c3a22dd1b9fca91bf4419d42d590" translate="yes" xml:space="preserve">
          <source>The easiest way to define a custom generator is the following this example, here extending the current HTML generator. We don&amp;rsquo;t have to know if this is the original HTML generator defined in ocamldoc or if it has been extended already by a previously loaded custom generator :</source>
          <target state="translated">사용자 정의 생성기를 정의하는 가장 쉬운 방법은 현재 HTML 생성기를 확장하는 다음 예제입니다. 이것이 ocamldoc에 정의 된 원래 HTML 생성기인지 또는 이전에로드 된 사용자 정의 생성기에 의해 이미 확장되었는지 알 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="58f055689b02c7748240c0805950d6c0e3a0e111" translate="yes" xml:space="preserve">
          <source>The elements are passed to &lt;code&gt;f&lt;/code&gt; in increasing order with respect to the ordering over the type of the elements.</source>
          <target state="translated">요소는 요소 유형에 대한 순서와 관련하여 오름차순 으로 &lt;code&gt;f&lt;/code&gt; 에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="6710aa8b225c8ca5f7b41012a718cf1001e66889" translate="yes" xml:space="preserve">
          <source>The else&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; part can be omitted, in which case it defaults to else().</source>
          <target state="translated">else &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; 부분은 생략 할 수 있으며,이 경우 기본값은 else ()입니다.</target>
        </trans-unit>
        <trans-unit id="9282996444b9faf1c947138395efb723dd3e6881" translate="yes" xml:space="preserve">
          <source>The empty map.</source>
          <target state="translated">빈지도.</target>
        </trans-unit>
        <trans-unit id="8e51b0d5d7e271c88e867edd7cf3a56d6061ba51" translate="yes" xml:space="preserve">
          <source>The empty sequence, containing no elements.</source>
          <target state="translated">요소가없는 빈 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="0ac903ee0be4b8d03c2629dea67dc51a5e1dc555" translate="yes" xml:space="preserve">
          <source>The empty set.</source>
          <target state="translated">빈 세트.</target>
        </trans-unit>
        <trans-unit id="bcc5ac53238f78e7ccd13efd320b3aba2a2a43c4" translate="yes" xml:space="preserve">
          <source>The environment variable OCAML_COLOR is considered if -color is not provided. Its values are auto/always/never as above.</source>
          <target state="translated">-color가 제공되지 않으면 환경 변수 OCAML_COLOR가 고려됩니다. 그 값은 위와 같이 auto / always / never입니다.</target>
        </trans-unit>
        <trans-unit id="bc5a16c0802c0d6eab8dd39659b932cb9d3eeec2" translate="yes" xml:space="preserve">
          <source>The environment variable OCAML_ERROR_STYLE is considered if -error-style is not provided. Its values are short/contextual as above.</source>
          <target state="translated">-error-style이 제공되지 않으면 환경 변수 OCAML_ERROR_STYLE이 고려됩니다. 그 값은 위와 같이 짧고 문맥 적입니다.</target>
        </trans-unit>
        <trans-unit id="d7f093c02c802f297eef039f1f8ed6be219bfe78" translate="yes" xml:space="preserve">
          <source>The ephemerons complicate the notion of liveness of values, because it is not anymore an equivalence with the reachability from root value by usual pointers (not weak and not ephemerons). With ephemerons the notion of liveness is constructed by the least fixpoint of: A value is alive if:</source>
          <target state="translated">에페 메론은 더 이상 일반적인 포인터 (약하지 않고 에페 메론이 아님)에 의한 루트 값의 도달 가능성과 동등하지 않기 때문에 값의 활성 개념을 복잡하게 만듭니다. 에페 메론을 사용하면 활성 개념은 다음 중 최소 고정 점으로 구성됩니다. 다음과 같은 경우 값이 살아 있습니다.</target>
        </trans-unit>
        <trans-unit id="f38c615e4885039a9f6a96adebc7d8b6a2703f76" translate="yes" xml:space="preserve">
          <source>The equal function for 16-character digest.</source>
          <target state="translated">16 자 다이제스트에 대한 동등한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="4745822a26883aa3e079c90a04c121006a19e95e" translate="yes" xml:space="preserve">
          <source>The equal function for chars.</source>
          <target state="translated">문자에 대한 동등한 기능.</target>
        </trans-unit>
        <trans-unit id="975faf8015348dfd4f8f27ef557f89666b74bd4f" translate="yes" xml:space="preserve">
          <source>The equal function for floating-point numbers, compared using &lt;a href=&quot;float#VALcompare&quot;&gt;&lt;code&gt;Float.compare&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;float#VALcompare&quot;&gt; &lt;code&gt;Float.compare&lt;/code&gt; 를&lt;/a&gt; 사용하여 비교 한 부동 소수점 숫자에 대한 동일한 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="9f25af14cf81fd197468c0aef6ee60036c040bc5" translate="yes" xml:space="preserve">
          <source>The equal function for int32s.</source>
          <target state="translated">int32s에 대한 동일한 함수입니다.</target>
        </trans-unit>
        <trans-unit id="43353326c31a51a2e1e40be3cfbc055a576f0c46" translate="yes" xml:space="preserve">
          <source>The equal function for int64s.</source>
          <target state="translated">int64s에 대한 동등한 기능.</target>
        </trans-unit>
        <trans-unit id="9acc244879540dd60658943a5fc7d40212cd5702" translate="yes" xml:space="preserve">
          <source>The equal function for native ints.</source>
          <target state="translated">네이티브 정수에 대한 동등한 함수입니다.</target>
        </trans-unit>
        <trans-unit id="287fd038b43c08ac15387236db89c8b9dfd89564" translate="yes" xml:space="preserve">
          <source>The equal function for strings.</source>
          <target state="translated">문자열에 대한 동등한 기능.</target>
        </trans-unit>
        <trans-unit id="4a7926a9ee2ed830da3e6706d16691abddc39c2a" translate="yes" xml:space="preserve">
          <source>The equality function for byte sequences.</source>
          <target state="translated">바이트 시퀀스에 대한 같음 함수입니다.</target>
        </trans-unit>
        <trans-unit id="af06b8ab4789de98e0de35bd84609d867593cd6b" translate="yes" xml:space="preserve">
          <source>The equality predicate used to compare keys.</source>
          <target state="translated">키를 비교하는 데 사용되는 같음 조건 자입니다.</target>
        </trans-unit>
        <trans-unit id="83858c6c1566ad5f65edb208e38dd2558053de52" translate="yes" xml:space="preserve">
          <source>The equivalent of -inline but used when speculative inlining starts at toplevel. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;. Not used in -Oclassic mode.</source>
          <target state="translated">-inline과 동일하지만 추측 인라인이 최상위에서 시작될 때 사용됩니다. 섹션 &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6을&lt;/a&gt; 참조하십시오 . -Oclassic 모드에서는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94cdb8a214ed46b885c25876cd3600fef2503877" translate="yes" xml:space="preserve">
          <source>The error messages are almost identical to those of ocamlc. See section &lt;a href=&quot;comp#s%3Acomp-errors&quot;&gt;9.4&lt;/a&gt;.</source>
          <target state="translated">오류 메시지는 ocamlc의 메시지와 거의 동일합니다. 섹션 &lt;a href=&quot;comp#s%3Acomp-errors&quot;&gt;9.4를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f378c773556e60ceb5a7a9d15fb2d1a81df83d7" translate="yes" xml:space="preserve">
          <source>The evaluation of the body of a class only takes place at object creation time. Therefore, in the following example, the instance variable x is initialized to different values for two different objects.</source>
          <target state="translated">클래스 본문의 평가는 객체 생성시에만 발생합니다. 따라서 다음 예제에서 인스턴스 변수 x는 서로 다른 두 개체에 대해 서로 다른 값으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="823e43ea0dd60b51d8777275d399ee78c608b08d" translate="yes" xml:space="preserve">
          <source>The exact definition of which free variables are captured in a closure is not specified and can vary between bytecode and native code (and according to optimization flags). In particular, a function value accessing a global reference may or may not include the reference in its closure. If it does, unmarshaling the corresponding closure will create a new reference, different from the global one.</source>
          <target state="translated">클로저에서 캡처되는 자유 변수에 대한 정확한 정의는 지정되지 않았으며 바이트 코드와 네이티브 코드 (및 최적화 플래그에 따라)간에 다를 수 있습니다. 특히, 전역 참조에 액세스하는 함수 값은 클로저에 참조를 포함하거나 포함하지 않을 수 있습니다. 그렇다면 해당 클로저를 비 정렬 화하면 전역 참조와 다른 새 참조가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="367c1c92926004568a37375dcb37462e755ae202" translate="yes" xml:space="preserve">
          <source>The execution of a program is affected by certain information it receives when the debugger starts it, such as the command-line arguments to the program and its working directory. The debugger provides commands to specify this information (set arguments and cd). These commands must be used before program execution starts. If you try to change the arguments or the working directory after starting your program, the debugger will kill the program (after asking for confirmation).</source>
          <target state="translated">프로그램 실행은 프로그램 및 작업 디렉터리에 대한 명령 줄 인수와 같이 디버거가 시작할 때 수신하는 특정 정보의 영향을받습니다. 디버거는이 정보를 지정하는 명령을 제공합니다 (인수 및 cd 설정). 이러한 명령은 프로그램 실행이 시작되기 전에 사용해야합니다. 프로그램을 시작한 후 인수 또는 작업 디렉토리를 변경하려고하면 디버거가 프로그램을 종료합니다 (확인 요청 후).</target>
        </trans-unit>
        <trans-unit id="891519fb02f7659ffef41323f18ea6f26295ee67" translate="yes" xml:space="preserve">
          <source>The execution times (CPU times) of a process.</source>
          <target state="translated">프로세스의 실행 시간 (CPU 시간).</target>
        </trans-unit>
        <trans-unit id="ea3566383d4d77e6af67a2d9e1c982e58d1aacae" translate="yes" xml:space="preserve">
          <source>The exhaustiveness check is aware of GADT constraints, and can automatically infer that some cases cannot happen. For instance, the following pattern matching is correctly seen as exhaustive (the Add case cannot happen).</source>
          <target state="translated">완전성 검사는 GADT 제약 조건을 인식하고 일부 경우가 발생할 수 없음을 자동으로 추론 할 수 있습니다. 예를 들어, 다음 패턴 일치는 전체적으로 올바르게 표시됩니다 (Add 케이스는 발생할 수 없음).</target>
        </trans-unit>
        <trans-unit id="682f2afe18d27a6b2d5109af77f4241c373f09ce" translate="yes" xml:space="preserve">
          <source>The expression</source>
          <target state="translated">표현식</target>
        </trans-unit>
        <trans-unit id="48d5ec0634b8a1782837ee8b1ca9761b0c8a2b02" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;) evaluates to the same module as &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;.</source>
          <target state="translated">표현식 ( &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; )은 &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; 과 동일한 모듈로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="fc9adc4308aa68c065cc84caf08fbc1ea795d7aa" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;:&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;) checks that &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt; matches the type of &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; (that is, that the implementation &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; meets the type specification &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;). The whole expression evaluates to the same class as &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;, except that all components not specified in &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt; are hidden and can no longer be accessed.</source>
          <target state="translated">표현식 ( &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; : &lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt; )은 &lt;a href=&quot;#class-type&quot;&gt;class-&lt;/a&gt; type이 &lt;a href=&quot;#class-expr&quot;&gt;class-expr &lt;/a&gt;유형 과 일치 하는지 ( 즉, 구현 &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; 이 유형 사양 &lt;a href=&quot;#class-type&quot;&gt;class-type을&lt;/a&gt; 충족하는지 ) 확인합니다. 전체 표현식 은 &lt;a href=&quot;#class-type&quot;&gt;class-type에&lt;/a&gt; 지정되지 않은 모든 구성 요소 가 숨겨져 더 이상 액세스 할 수 없다는 점을 제외하고는 &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; 과 동일한 클래스로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f1374da867ccabac7aad3663177813cdc0a9fa8" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;) evaluates to the same module as &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;.</source>
          <target state="translated">표현식 ( &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; )은 &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; 과 동일한 모듈로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="1fd1fd31681b7a2cf0269cba7eed69aec7e48ffe" translate="yes" xml:space="preserve">
          <source>The expression (&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) checks that the type of &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; is a subtype of &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;, that is, that all components specified in &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; are implemented in &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;, and their implementation meets the requirements given in &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;. In other terms, it checks that the implementation &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; meets the type specification &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;. The whole expression evaluates to the same module as &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;, except that all components not specified in &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; are hidden and can no longer be accessed.</source>
          <target state="translated">표현식 ( &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; : &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; )은 &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; 유형이 &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; 의 하위 유형 인지, 즉 &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type에&lt;/a&gt; 지정된 모든 구성 요소 가 &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; 에서 구현되고 해당 구현이 다음을 충족하는지 확인합니다. &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type에&lt;/a&gt; 주어진 요구 사항 . 다른 관점에서, 구현 것을 확인 &lt;a href=&quot;#module-expr&quot;&gt;모듈 expr이&lt;/a&gt; 타입 사양에 맞는 &lt;a href=&quot;modtypes#module-type&quot;&gt;모듈 형&lt;/a&gt; . 전체 표현식 은 &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type에&lt;/a&gt; 지정되지 않은 모든 구성 요소 가 숨겨져 있고 더 이상 액세스 할 수 없다는 점을 제외하면 &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; 과 동일한 모듈로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="bef2d23b52ee970fade1b06935e7b9ced9f528d5" translate="yes" xml:space="preserve">
          <source>The expression (module&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) converts the module (structure or functor) denoted by module expression &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; to a value of the core language that encapsulates this module. The type of this core language value is (module&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;). The &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; annotation can be omitted if it can be inferred from the context.</source>
          <target state="translated">표현식 (module &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; : &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; )은 모듈 표현식 &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; 로 표시된 모듈 (구조 또는 함수)을이 모듈 을 캡슐화하는 핵심 언어의 값으로 변환합니다. 이 핵심 언어 값의 유형은 (module &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; )입니다. &lt;a href=&quot;#package-type&quot;&gt;패키지 형&lt;/a&gt; 이 문맥에서 유추 할 수있는 경우 주석을 생략 할 수있다.</target>
        </trans-unit>
        <trans-unit id="c3d05c07c0894d4fd053f92bb2e5d69fce8d15a3" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;#&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; invokes the method &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; of the object denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;.</source>
          <target state="translated">발현 &lt;a href=&quot;#expr&quot;&gt;위해 expr&lt;/a&gt; #의 &lt;a href=&quot;names#method-name&quot;&gt;메소드 이름&lt;/a&gt; 메소드 호출 &lt;a href=&quot;names#method-name&quot;&gt;방법 이름&lt;/a&gt; 붙이고 오브젝트 &lt;a href=&quot;#expr&quot;&gt;을 expr&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5fe9ec8f9aa27454f205256c37ed9a50e6170e6" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&amp;amp;&amp;amp;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to true if both &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluate to true; otherwise, it evaluates to false. The first component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, is evaluated first. The second component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, is not evaluated if the first component evaluates to false. Hence, the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;&amp;amp;&amp;amp;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; behaves exactly as</source>
          <target state="translated">&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;amp;&amp;amp; &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 표현식 은 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 과 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 가 모두 true로 평가되면 true로 평가됩니다. 그렇지 않으면 거짓으로 평가됩니다. 첫 번째 구성 요소 인 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 이 먼저 평가됩니다. 두 번째 구성 요소 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 는 첫 번째 구성 요소가 false로 평가되면 평가되지 않습니다. 따라서 표현식 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;amp;&amp;amp; &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2는&lt;/sub&gt; 정확히 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="67be0419a621a610a2e5884430cdee8308e61e8d" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; evaluates to the n-tuple of the values of expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. The evaluation order of the subexpressions is not specified.</source>
          <target state="translated">발현 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; , ..., &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; 식의 값의 n 튜플 평가는 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 위해 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; . 하위 표현식의 평가 순서가 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="f82e349965c8472e346c4996f8f13cfaa04ee8f5" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;) returns the value of element number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; in the array denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. The first element has number 0; the last element has number n&amp;minus;1, where n is the size of the array. The exception Invalid_argument is raised if the access is out of bounds.</source>
          <target state="translated">발현 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;하나&lt;/sub&gt; . ( &lt;a href=&quot;#expr&quot;&gt;만약 expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; ) 요소의 수의 값을 반환 &lt;a href=&quot;#expr&quot;&gt;expr에 &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 로 표시된 어레이 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; . 첫 번째 요소의 숫자는 0입니다. 마지막 요소의 숫자는 n-1이며, 여기서 n은 배열의 크기입니다. 액세스가 범위를 벗어난 경우 Invalid_argument 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b86cf48755f90d38c3703b093a559d201d41505d" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;)&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; modifies in-place the array denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, replacing element number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; by the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;. The exception Invalid_argument is raised if the access is out of bounds. The value of the whole expression is ().</source>
          <target state="translated">표현식 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1.&lt;/sub&gt; ( &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; ) &amp;lt; &lt;a href=&quot;#expr&quot;&gt;-expr &lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; 은 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 로 표시된 배열을 제자리에서 수정 하여 요소 번호 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 를 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; 값으로 대체 합니다. 액세스가 범위를 벗어난 경우 Invalid_argument 예외가 발생합니다. 전체 표현식의 값은 ()입니다.</target>
        </trans-unit>
        <trans-unit id="82e23d1a40c45b5cca334a602a3b8464c8cb5ac6" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a record value, and returns the value associated to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; in this record value.</source>
          <target state="translated">표현식 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; . &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; 는 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 을 레코드 값으로 평가 하고이 레코드 값의 &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; 에 연결된 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fac0b26bb16a9c0e18d3fa3496db97765aa8519f" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a record value, which is then modified in-place by replacing the value associated to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; in this record by the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. This operation is permitted only if &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; has been declared mutable in the definition of the record type. The whole expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to the unit value ().</source>
          <target state="translated">표현식 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; . &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; &amp;lt; &lt;a href=&quot;#expr&quot;&gt;-expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 는 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 을 레코드 값으로 평가 한 다음 이 레코드의 &lt;a href=&quot;names#field&quot;&gt;필드&lt;/a&gt; 와 연관된 값을 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 값으로 대체하여 제자리에서 수정됩니다 . 이 작업은 &lt;a href=&quot;names#field&quot;&gt;필드&lt;/a&gt; 가 레코드 유형의 정의에서 변경 가능하다고 선언 된 경우에만 허용됩니다 . 전체 표현식 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; . &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; &amp;lt; &lt;a href=&quot;#expr&quot;&gt;-expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 는 단위 값 ()으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="7cd6fc3dc672a6d7077ed6957a582e1952b94590" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.[&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;] returns the value of character number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; in the string denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. The first character has number 0; the last character has number n&amp;minus;1, where n is the length of the string. The exception Invalid_argument is raised if the access is out of bounds.</source>
          <target state="translated">발현 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; . &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; ] 문자 숫자의 값을 반환 &lt;a href=&quot;#expr&quot;&gt;expr에 &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 로 표시된 문자열 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; . 첫 번째 문자는 숫자 0입니다. 마지막 문자의 숫자는 n-1이며, 여기서 n은 문자열의 길이입니다. 액세스가 범위를 벗어난 경우 Invalid_argument 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="19a3eefaad7e437247b3bc6db656e1c074dfe4b0" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.[&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;]&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; modifies in-place the string denoted by &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, replacing character number &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; by the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;. The exception Invalid_argument is raised if the access is out of bounds. The value of the whole expression is ().</source>
          <target state="translated">표현식 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1.&lt;/sub&gt; [ &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; ] &amp;lt; &lt;a href=&quot;#expr&quot;&gt;-expr &lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; 은 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 로 표시된 문자열을 제자리에서 수정 하여 문자 번호 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 를 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; 값으로 대체합니다 . 액세스가 범위를 벗어난 경우 Invalid_argument 예외가 발생합니다. 전체 표현식의 값은 ()입니다.</target>
        </trans-unit>
        <trans-unit id="54bc0bbda0902a87059f4ab52fd17c9a2c5cb0cd" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; first, then &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, and returns the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="translated">표현식 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ; &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;2 개&lt;/sub&gt; 평가하여이 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;한&lt;/sub&gt; 후, 제 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; , 및 리턴 값 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; .</target>
        </trans-unit>
        <trans-unit id="c3309f1c657c39dcf14b482d1d2b52b485c6e1c1" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;||&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to true if one of the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; evaluates to true; otherwise, it evaluates to false. The first component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, is evaluated first. The second component, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, is not evaluated if the first component evaluates to true. Hence, the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;||&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; behaves exactly as</source>
          <target state="translated">식 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; || &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;이 개&lt;/sub&gt; 표현 중 하나가있는 경우는 true로 평가 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1 개&lt;/sub&gt; 및 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;이&lt;/sub&gt; 참으로 평가를; 그렇지 않으면 거짓으로 평가됩니다. 첫 번째 구성 요소 인 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 이 먼저 평가됩니다. 두 번째 구성 요소 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 는 첫 번째 구성 요소가 true로 평가되면 평가되지 않습니다. 따라서 표현식 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; || &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2는&lt;/sub&gt; 정확히 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="465cc162397700c3a7233e4d6be2e63f71fde0fe" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;(&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;) evaluates &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a functor and &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; to a module, and applies the former to the latter. The type of &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; must match the type expected for the arguments of the functor &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-expr&quot;&gt;module-expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ( &lt;a href=&quot;#module-expr&quot;&gt;module-expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; ) 표현식 은 &lt;a href=&quot;#module-expr&quot;&gt;module-expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 을 펑터로, &lt;a href=&quot;#module-expr&quot;&gt;module-expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 를 모듈로 평가하고 전자를 후자에 적용합니다. 유형 &lt;a href=&quot;#module-expr&quot;&gt;모듈 EXPR &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 펑터의 인수 예상 유형과 일치해야 &lt;a href=&quot;#module-expr&quot;&gt;모듈 EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; .</target>
        </trans-unit>
        <trans-unit id="1e4e8d9bdc0d328e50497d061e05aaaa6759bfe6" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to the class bound to the name &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt;. Similarly, the expression [&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;]&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to the parametric class bound to the name &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt;, in which type parameters have been instantiated respectively to &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">표현의 &lt;a href=&quot;names#class-path&quot;&gt;클래스 경로는&lt;/a&gt; 이름에 바인딩 클래스로 평가 &lt;a href=&quot;names#class-path&quot;&gt;클래스 경로&lt;/a&gt; . 마찬가지로, 표현식 [ &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; ] &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; 는 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n으로&lt;/sub&gt; 각각 인스턴스화 된 type 매개 변수가 &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; 이름에 바인딩 된 매개 변수 클래스 로 평가됩니다 .&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="88f78fb35dd0d933beef57fab438013880471ef8" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; is equivalent to the class type bound to the name &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;. Similarly, the expression [&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;]&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; is equivalent to the parametric class type bound to the name &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;, in which type parameters have been instantiated to respectively &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; 표현식은 classtype-path 이름에 바인딩 된 클래스 유형과 동일 &lt;a href=&quot;names#classtype-path&quot;&gt;합니다&lt;/a&gt; . 마찬가지로, 표현식 [ &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; ] &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; 는 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 으로 각각 인스턴스화 된 type 매개 변수에서 &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; 이름에 바인딩 된 매개 변수 클래스 유형과 동일합니다 .&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="9bdccee9cf7f9a846ebb0d6ce9a9a4d063b0d4f4" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;) evaluates to the variant value whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;, and whose arguments are the values of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">식 &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; ( &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip;, &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; )은 생성자가 &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; 이고 인수가 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n의&lt;/sub&gt; 값인 변형 값으로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="fd2b0c9502549e5b50e4ab2002a089216e807b74" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates to the unary variant value whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;, and whose argument is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. Similarly, the expression &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;) evaluates to the n-ary variant value whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; and whose arguments are the values of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">표현식 &lt;a href=&quot;names#constr&quot;&gt;constr &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 은 생성자가 &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; 이고 인수가 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 값인 단항 변형 값으로 평가됩니다 . 마찬가지로 표현식 &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; ( &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip;, &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; )은 생성자가 &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; 이고 인수가 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip;, &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n의&lt;/sub&gt; 값인 n 항 변형 값으로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="86658bc3c80f7feb554c6583c0fa9ad438f2d77f" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&amp;lt;-&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; modifies in-place the current object by replacing the value associated to &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; by the value of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;. Of course, this instance variable must have been declared mutable.</source>
          <target state="translated">식 &lt;a href=&quot;names#inst-var-name&quot;&gt;이달 VAR-이름&lt;/a&gt; &amp;lt;- &lt;a href=&quot;expr#expr&quot;&gt;expr에&lt;/a&gt; 제자리 수정에 관련된 값을 대체하여 현재 오브젝트 &lt;a href=&quot;names#inst-var-name&quot;&gt;이달 VAR-이름&lt;/a&gt; 의 값 &lt;a href=&quot;expr#expr&quot;&gt;을 expr&lt;/a&gt; . 물론이 인스턴스 변수는 변경 가능으로 선언되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7ac13a35707432acbcfeb9a3119c7ad181cc342a" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#modtype-path&quot;&gt;modtype-path&lt;/a&gt; is equivalent to the module type bound to the name &lt;a href=&quot;names#modtype-path&quot;&gt;modtype-path&lt;/a&gt;. The expression (&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;) denotes the same type as &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;names#modtype-path&quot;&gt;modtype-path&lt;/a&gt; 표현식은 modtype-path 이름에 바인딩 된 모듈 유형과 동일 &lt;a href=&quot;names#modtype-path&quot;&gt;합니다&lt;/a&gt; . 식 ( &lt;a href=&quot;#module-type&quot;&gt;모듈 형&lt;/a&gt; )와 같은 형태이다 &lt;a href=&quot;#module-type&quot;&gt;모듈 형&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="63b697cf7e46dafd21affd4bfc9ae60ca539fafc" translate="yes" xml:space="preserve">
          <source>The expression &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; evaluates to the module bound to the name &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.</source>
          <target state="translated">표현의 &lt;a href=&quot;names#module-path&quot;&gt;모듈 경로&lt;/a&gt; 이름에 바인드 된 모듈로 평가 &lt;a href=&quot;names#module-path&quot;&gt;모듈 경로&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="374fd1d5eec03fb1c40077ef206acff290b1b338" translate="yes" xml:space="preserve">
          <source>The expression [|&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|] evaluates to a n-element array, whose elements are initialized with the values of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; respectively. The order in which these expressions are evaluated is unspecified.</source>
          <target state="translated">식 [| &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;; &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; |]은 요소가 각각 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 에서 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 까지 의 값으로 초기화되는 n 개 요소 배열로 평가됩니다 . 이러한식이 평가되는 순서는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e45182f3efd80314e85a55d033c068a05794bdeb" translate="yes" xml:space="preserve">
          <source>The expression `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates to the polymorphic variant value whose tag is &lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;, and whose argument is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;.</source>
          <target state="translated">` &lt;a href=&quot;names#tag-name&quot;&gt;tag-name &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 표현식 은 태그가 &lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; 이고 인수가 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 의 값인 다형성 변형 값으로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="c7801f0a175513fedc9db3b2ea095ee870659f32" translate="yes" xml:space="preserve">
          <source>The expression does not change the observable state of the world save for possibly affecting the state of the garbage collector by performing an allocation. Expressions that only have generative effects and whose results are unused may be eliminated by the compiler. However, unlike expressions with &amp;ldquo;no effects&amp;rdquo;, such expressions will never be eligible for duplication.</source>
          <target state="translated">표현식은 할당을 수행하여 가비지 수집기의 상태에 영향을 줄 수 있으므로 세계의 관찰 가능한 상태를 변경하지 않습니다. 생성 효과 만 있고 그 결과가 사용되지 않는 식은 컴파일러에서 제거 할 수 있습니다. 그러나 &quot;효과 없음&quot;이있는 표현과 달리 이러한 표현은 복제 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="06268c11c08cbf54ec4d6dfccb9fea053ea40756" translate="yes" xml:space="preserve">
          <source>The expression does not change the observable state of the world. For example, it must not write to any mutable storage, call arbitrary external functions or change control flow (e.g. by raising an exception). Note that allocation is &lt;em&gt;not&lt;/em&gt; classed as having &amp;ldquo;no effects&amp;rdquo; (see below).</source>
          <target state="translated">이 표현은 세계의 관찰 가능한 상태를 바꾸지 않습니다. 예를 들어, 변경 가능한 저장소에 쓰거나 임의의 외부 함수를 호출하거나 제어 흐름을 변경해서는 안됩니다 (예 : 예외 발생). 할당은 &quot;효과 없음&quot;으로 분류 &lt;em&gt;되지 않습니다&lt;/em&gt; (아래 참조).</target>
        </trans-unit>
        <trans-unit id="54674c43e48502affde9ef34390ab16ef7402518" translate="yes" xml:space="preserve">
          <source>The expression does not observe the effects (in the sense described above) of other expressions. For example, it must not read from any mutable storage or call arbitrary external functions.</source>
          <target state="translated">이 표현은 다른 표현의 효과 (위에서 설명한 의미에서)를 관찰하지 않습니다. 예를 들어, 변경 가능한 저장소에서 읽거나 임의의 외부 함수를 호출해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="66513182b7246bbaa2fec620bc98c1dc1505d3a1" translate="yes" xml:space="preserve">
          <source>The expression e in let x = e in e&amp;rsquo;.</source>
          <target state="translated">let x = e in e '의 표현 e.</target>
        </trans-unit>
        <trans-unit id="fafa3e808d29aa326f8219b2a729faf94bb92f2f" translate="yes" xml:space="preserve">
          <source>The expression forname=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;downto&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;do&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;done evaluates similarly, except that name is successively bound to the values n, n&amp;minus;1, &amp;hellip;, p+1, p. The loop body is never evaluated if n &amp;lt; p.</source>
          <target state="translated">forname = &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; downto &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; do &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; done은 이름이 n, n-1,&amp;hellip;, p + 1, p 값에 연속적으로 바인딩된다는 점을 제외하면 비슷하게 평가됩니다. n &amp;lt;p이면 루프 본문이 평가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d57f96f2e7c598ac2e5a92cdba5ecd224f400d7" translate="yes" xml:space="preserve">
          <source>The expression forname=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;to&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;do&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt;done first evaluates the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; (the boundaries) into integer values n and p. Then, the loop body &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; is repeatedly evaluated in an environment where name is successively bound to the values n, n+1, &amp;hellip;, p&amp;minus;1, p. The loop body is never evaluated if n &amp;gt; p.</source>
          <target state="translated">forname = &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ~ &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; do &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; done first는 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 및 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; (경계) 표현식 을 정수 값 n 및 p로 평가합니다. 그런 다음 이름이 n, n + 1,&amp;hellip;, p-1, p 값에 연속적으로 바인딩 된 환경에서 루프 본문 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; 이 반복적으로 평가됩니다. n&amp;gt; p이면 루프 본문이 평가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="13ea45faff3269f614a52ad4b80de5d2a8ebf30f" translate="yes" xml:space="preserve">
          <source>The expression fun [[?]&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;:] &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;-&amp;gt;&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; evaluates to a function from values to classes. When this function is applied to a value v, this value is matched against the pattern &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; and the result is the result of the evaluation of &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; in the extended environment.</source>
          <target state="translated">표현의 재미 [[]? &lt;a href=&quot;lex#label-name&quot;&gt;레이블 이름&lt;/a&gt; :] &lt;a href=&quot;patterns#pattern&quot;&gt;패턴&lt;/a&gt; -&amp;gt; &lt;a href=&quot;#class-expr&quot;&gt;클래스 EXPR의&lt;/a&gt; 클래스 값에서 함수를 평가한다. 이 함수가 v 값에 적용되면이 값은 패턴 &lt;a href=&quot;patterns#pattern&quot;&gt;패턴&lt;/a&gt; 과 일치 하며 결과는 확장 환경에서 &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; 평가의 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="5a2641611d76e3a4d8e4ffbce3daf0019fe517c9" translate="yes" xml:space="preserve">
          <source>The expression fun(type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; introduces a type constructor named &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt; which is considered abstract in the scope of the sub-expression, but then replaced by a fresh type variable. Note that contrary to what the syntax could suggest, the expression fun(type&lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; itself does not suspend the evaluation of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; as a regular abstraction would. The syntax has been chosen to fit nicely in the context of function declarations, where it is generally used. It is possible to freely mix regular function parameters with pseudo type parameters, as in:</source>
          <target state="translated">fun (type &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt; )-&amp;gt; &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; 표현식 은 &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt; 이라는 유형 생성자를 소개합니다. typeconstr-name 은 하위 표현식의 범위에서 추상으로 간주되지만 새로운 유형 변수로 대체됩니다. 구문이 제안 할 수있는 것과는 반대로, 표현식 fun (type &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt; )-&amp;gt; &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; 자체는 정규 추상화처럼 &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; 의 평가를 중단하지 않습니다 . 구문은 일반적으로 사용되는 함수 선언의 컨텍스트에 잘 맞도록 선택되었습니다. 다음과 같이 일반 함수 매개 변수와 의사 유형 매개 변수를 자유롭게 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc2f0b7a211a145ce7e8a7301a70f0d4c7d342fe" translate="yes" xml:space="preserve">
          <source>The expression functor(&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; evaluates to a functor that takes as argument modules of the type &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, binds &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; to these modules, evaluates &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; in the extended environment, and returns the resulting modules as results. No restrictions are placed on the type of the functor argument; in particular, a functor may take another functor as argument (&amp;ldquo;higher-order&amp;rdquo; functor).</source>
          <target state="translated">발현 펑 ( &lt;a href=&quot;names#module-name&quot;&gt;모듈 이름&lt;/a&gt; : &lt;a href=&quot;modtypes#module-type&quot;&gt;모듈 형&lt;/a&gt; ) -&amp;gt; &lt;a href=&quot;#module-expr&quot;&gt;모듈 EXPR의&lt;/a&gt; 유형의 인자 모듈로서 취하는 펑 평가 &lt;a href=&quot;modtypes#module-type&quot;&gt;모듈 형 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; , 귀속 &lt;a href=&quot;names#module-name&quot;&gt;모듈 이름&lt;/a&gt; 이 모듈가 평가 &lt;a href=&quot;#module-expr&quot;&gt;모듈 EXPR&lt;/a&gt; 확장 환경 , 결과 모듈을 결과로 반환합니다. functor 인수의 유형에는 제한이 없습니다. 특히, 펑 터는 다른 펑터를 인수로 취할 수 있습니다 ( &quot;고차&quot;펑터).</target>
        </trans-unit>
        <trans-unit id="39045ca493f5041229a426581d36cb35d6454361" translate="yes" xml:space="preserve">
          <source>The expression if&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;then&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;else&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; evaluates to the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; if &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; evaluates to the boolean true, and to the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; if &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; evaluates to the boolean false.</source>
          <target state="translated">발현 경우 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;한&lt;/sub&gt; 후 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 다른 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;3 개&lt;/sub&gt; 의 값으로 평가 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 경우 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1 개&lt;/sub&gt; 부울 참으로 평가 한 값에 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;3&lt;/sub&gt; 경우 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 부울 거짓으로 평가.</target>
        </trans-unit>
        <trans-unit id="4cee2fb74666dafe45945b12c3589890b3ad2f7a" translate="yes" xml:space="preserve">
          <source>The expression include&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; in a structure re-exports in the current structure all definitions of the structure denoted by &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;. For instance, if you define a module S as below</source>
          <target state="translated">식은 구조에 &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; 을 포함 하여 현재 구조에서 &lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt; 로 표시된 구조의 모든 정의를 다시 내 보냅니다 . 예를 들어 아래와 같이 모듈 S를 정의하면</target>
        </trans-unit>
        <trans-unit id="5348485cb90b4b3e0999ac25862d4723d8c8e9d9" translate="yes" xml:space="preserve">
          <source>The expression include&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt; in a signature performs textual inclusion of the components of the signature denoted by &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;. It behaves as if the components of the included signature were copied at the location of the include. The &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt; argument must refer to a module type that is a signature, not a functor type.</source>
          <target state="translated">시그니처의 include &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt; 표현식은 module-type 으로 표시된 시그니처 구성 요소의 텍스트 포함을 수행 &lt;a href=&quot;#module-type&quot;&gt;합니다&lt;/a&gt; . 포함 된 서명의 구성 요소가 포함 위치에 복사 된 것처럼 작동합니다. &lt;a href=&quot;#module-type&quot;&gt;모듈 형&lt;/a&gt; 인수는 서명하지 펑터 타입 모듈 유형을 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2aa219207ffe702cd009fe575887afe0cfda1d7" translate="yes" xml:space="preserve">
          <source>The expression is not evaluated this time; notice that &amp;ldquo;lazy_two evaluation&amp;rdquo; is not printed. The result of the initial computation is simply returned.</source>
          <target state="translated">이번에는 표현식이 평가되지 않습니다. &quot;lazy_two evaluation&quot;이 인쇄되지 않습니다. 초기 계산의 결과는 간단히 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8bad5791aee2947a352057622227636c6db71ed9" translate="yes" xml:space="preserve">
          <source>The expression lazy&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; returns a value v of type Lazy.t that encapsulates the computation of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. The argument &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is not evaluated at this point in the program. Instead, its evaluation will be performed the first time the function Lazy.force is applied to the value v, returning the actual value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. Subsequent applications of Lazy.force to v do not evaluate &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; again. Applications of Lazy.force may be implicit through pattern matching (see &lt;a href=&quot;patterns#sss%3Apat-lazy&quot;&gt;7.6&lt;/a&gt;).</source>
          <target state="translated">lazy &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 표현식 은 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 계산을 캡슐화하는 Lazy.t 유형의 값 v를 반환합니다 . 인수 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 은 프로그램의이 시점에서 평가되지 않습니다. 대신 Lazy.force 함수가 v 값에 처음 적용될 때 평가가 수행되어 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 의 실제 값을 반환합니다 . Lazy.force를 v에 적용하면 &lt;a href=&quot;#expr&quot;&gt;expr을&lt;/a&gt; 다시 평가하지 않습니다 . Lazy.force의 적용은 패턴 매칭을 통해 암시적일 수 있습니다 ( &lt;a href=&quot;patterns#sss%3Apat-lazy&quot;&gt;7.6&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d836be1d196aa1c9fd598fef8e21c88679d68ac4" translate="yes" xml:space="preserve">
          <source>The expression letmodule&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;=&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; locally binds the module expression &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; to the identifier &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; during the evaluation of the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. It then returns the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. For example:</source>
          <target state="translated">발현 letmodule의 &lt;a href=&quot;names#module-name&quot;&gt;모듈 명&lt;/a&gt; = &lt;a href=&quot;modules#module-expr&quot;&gt;모듈 EXPR&lt;/a&gt; 에 &lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt; 로컬 모듈 식 결합 &lt;a href=&quot;modules#module-expr&quot;&gt;모듈 EXPR&lt;/a&gt; 식별자에 &lt;a href=&quot;names#module-name&quot;&gt;모듈 명&lt;/a&gt; 표현식 평가 동안 &lt;a href=&quot;#expr&quot;&gt;을 expr&lt;/a&gt; . 그런 다음 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 값을 반환합니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="f314e61bf1988c22719a609f5831e22bbdc7dc32" translate="yes" xml:space="preserve">
          <source>The expression object&lt;a href=&quot;#class-body&quot;&gt;class-body&lt;/a&gt;end denotes a class body. This is the prototype for an object : it lists the instance variables and methods of an object of this class.</source>
          <target state="translated">표현식 객체 &lt;a href=&quot;#class-body&quot;&gt;class-body&lt;/a&gt; end는 클래스 본문을 나타냅니다. 이것은 객체의 프로토 타입입니다.이 클래스의 객체의 인스턴스 변수와 메서드를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="6d92cd34881d32ef8ac6eb5fb33636280b1183b9" translate="yes" xml:space="preserve">
          <source>The expression open&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; in a signature does not specify any components. It simply affects the parsing of the following items of the signature, allowing components of the module denoted by &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; to be referred to by their simple names name instead of path accesses &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.name. The scope of the open stops at the end of the signature expression.</source>
          <target state="translated">서명의 open &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; 표현식 은 구성 요소를 지정하지 않습니다. 이는 단순히 서명의 다음 항목의 구문 분석에 영향을 미치므로 &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; 로 표시된 모듈의 구성 요소가 path 대신 단순한 이름 이름으로 참조 될 수 있도록 허용 합니다. &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; .name에 액세스 합니다 . 열린 범위는 서명 표현식의 끝에서 멈 춥니 다.</target>
        </trans-unit>
        <trans-unit id="3374b1493b2b2832203e28fc7202ca2b6bc44cc6" translate="yes" xml:space="preserve">
          <source>The expression open&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; in a structure does not define any components nor perform any bindings. It simply affects the parsing of the following items of the structure, allowing components of the module denoted by &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; to be referred to by their simple names name instead of path accesses &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.name. The scope of the open stops at the end of the structure expression.</source>
          <target state="translated">구조의 open &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; 표현식 은 구성 요소를 정의하거나 바인딩을 수행하지 않습니다. 이는 단순히 구조의 다음 항목의 구문 분석에 영향을 미치므로 &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; 로 표시된 모듈의 구성 요소를 path 대신 단순한 이름 이름으로 참조 할 수 있도록 허용 합니다. &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; .name에 액세스 합니다 . 열린 범위는 구조 표현식의 끝에서 멈 춥니 다.</target>
        </trans-unit>
        <trans-unit id="d045a7e48acb78229180ba1f49811e331b9b826a" translate="yes" xml:space="preserve">
          <source>The expression while&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;do&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;done repeatedly evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; while &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; evaluates to true. The loop condition &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is evaluated and tested at the beginning of each iteration. The whole while &amp;hellip; done expression evaluates to the unit value ().</source>
          <target state="translated">반면 표현은 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 할 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;이 개&lt;/sub&gt; 반복적으로 수행 평가하여이 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;이&lt;/sub&gt; 잠시 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; true로 평가합니다. 루프 조건 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 은 각 반복이 시작될 때 평가되고 테스트됩니다. 전체 while&amp;hellip; done 표현식은 단위 값 ()으로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="e7999e39ad27377cd7dc800aeafcf6be489d1e7a" translate="yes" xml:space="preserve">
          <source>The expression {&amp;lt;&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;&amp;gt;} evaluates to a copy of the current object in which the values of instance variables &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; have been replaced by the values of the corresponding expressions &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">표현식 {&amp;lt; &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;; &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; = &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; &amp;gt;}은 인스턴스 변수 &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip;, &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 의 값이 해당하는 값으로 대체 된 현재 객체의 복사본으로 평가됩니다. 표현식 &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip;, &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; .</target>
        </trans-unit>
        <trans-unit id="a02ea084f763d805328a3e7ce4d219962ddcb521" translate="yes" xml:space="preserve">
          <source>The expression {&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;with&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;] ; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] } builds a fresh record with fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; equal to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, and all other fields having the same value as in the record &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. In other terms, it returns a shallow copy of the record &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, except for the fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, which are initialized to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. As previously, single identifier &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;, a qualified identifier &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; and it is possible to add an optional type constraint on each field being updated with {&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;with&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;}.</source>
          <target state="translated">표현식 { &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; with &lt;a href=&quot;names#field&quot;&gt;field &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [= &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ]; &amp;hellip;; &lt;a href=&quot;names#field&quot;&gt;field &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [= &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; ]}은 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 과 동일한 필드 &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#field&quot;&gt;field &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 및 레코드 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 과 동일한 값을 갖는 다른 모든 필드로 새 레코드를 빌드합니다 . 즉, &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;으로 초기화되는 필드 &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;n을&lt;/sub&gt; 제외하고 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 레코드의 얕은 사본을 리턴합니다 .&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; . 이전과 같이 단일 식별자 &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; 는 자격을 갖춘 식별자 &lt;a href=&quot;names#module-path&quot;&gt;module-path 인 &lt;/a&gt;&lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; = &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;k를&lt;/sub&gt; 나타냅니다 . &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; 는 &lt;a href=&quot;names#module-path&quot;&gt;모듈 경로를&lt;/a&gt; 나타냅니다 . &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; = &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; 이고 { &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; with &lt;a href=&quot;names#field&quot;&gt;field &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; : &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;; &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; : &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; = &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;n&lt;/sub&gt; }.</target>
        </trans-unit>
        <trans-unit id="81df39f38d8523b1217ede44454dadcb59a82246" translate="yes" xml:space="preserve">
          <source>The expression {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;] ; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;]} evaluates to the record value { field&lt;sub&gt;1&lt;/sub&gt; = v&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip;; field&lt;sub&gt;n&lt;/sub&gt; = v&lt;sub&gt;n&lt;/sub&gt; } where v&lt;sub&gt;i&lt;/sub&gt; is the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; for i = 1,&amp;hellip; , n. A single identifier &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;, and a qualified identifier &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;. The fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; must all belong to the same record type; each field of this record type must appear exactly once in the record expression, though they can appear in any order. The order in which &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are evaluated is not specified. Optional type constraints can be added after each field {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;;&amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;} to force the type of &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; to be compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;.</source>
          <target state="translated">표현식 { &lt;a href=&quot;names#field&quot;&gt;field &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [= &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ]; &amp;hellip;; &lt;a href=&quot;names#field&quot;&gt;field &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [= &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; ]}은 레코드 값 {field &lt;sub&gt;1&lt;/sub&gt; = v &lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;; field &lt;sub&gt;n&lt;/sub&gt; = v &lt;sub&gt;n&lt;/sub&gt; } 여기서 v &lt;sub&gt;i&lt;/sub&gt; 는 i = 1,&amp;hellip;, n에 대한 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; 의 값입니다 . 단일 식별자 &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; 는 &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; = &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; 및 정규화 된 식별자 &lt;a href=&quot;names#module-path&quot;&gt;module-path를 나타&lt;/a&gt; 냅니다. &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; 는 &lt;a href=&quot;names#module-path&quot;&gt;모듈 경로를&lt;/a&gt; 나타냅니다 . &lt;a href=&quot;names#field&quot;&gt;들&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; = &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; . 필드 &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 에서 &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;n까지&lt;/sub&gt; 모두 동일한 레코드 유형에 속해야합니다. 이 레코드 유형의 각 필드는 순서에 관계없이 나타날 수 있지만 레코드 식에서 정확히 한 번만 나타나야합니다. &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ~ &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 이 평가 되는 순서는 지정되지 않습니다. 선택적 유형 제약 조건은 각 필드 뒤에 추가 할 수 있습니다 { &lt;a href=&quot;names#field&quot;&gt;field &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; : &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ;&amp;hellip;; &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; : &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; = &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; }&lt;a href=&quot;names#field&quot;&gt;&lt;/a&gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; 와 호환되는 필드 &lt;sub&gt;k&lt;/sub&gt; .&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="770439db3ff36f7c9028cd337c7098117fa187ed" translate="yes" xml:space="preserve">
          <source>The expressions (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;) and begin&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;end have the same value as &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;. The two constructs are semantically equivalent, but it is good style to use begin &amp;hellip; end inside control structures:</source>
          <target state="translated">식 ( &lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt; ) 및 시작 &lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt; 끝은 같은 값이 &lt;a href=&quot;#expr&quot;&gt;EXPR을&lt;/a&gt; . 두 구문은 의미 상 동일하지만 begin&amp;hellip; end inside control structure를 사용하는 것이 좋은 스타일입니다.</target>
        </trans-unit>
        <trans-unit id="c9bf76fd4e9d4e7583a34999f67c07a62a02f933" translate="yes" xml:space="preserve">
          <source>The expressions Field(v, n), Byte(v, n) and Byte_u(v, n) are valid l-values. Hence, they can be assigned to, resulting in an in-place modification of value v. Assigning directly to Field(v, n) must be done with care to avoid confusing the garbage collector (see below).</source>
          <target state="translated">Field (v, n), Byte (v, n) 및 Byte_u (v, n) 표현식은 유효한 l- 값입니다. 따라서 할당 될 수 있으므로 값 v가 제자리에 수정됩니다. Field (v, n)에 직접 할당하는 것은 가비지 수집기를 혼동하지 않도록주의해서 수행해야합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="d39a1aaa7be45538447c135e96180858a54150e6" translate="yes" xml:space="preserve">
          <source>The expressions letopen&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; and &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.(&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;) are strictly equivalent. These constructions locally open the module referred to by the module path &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; in the respective scope of the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;.</source>
          <target state="translated">letopen 발현 &lt;a href=&quot;names#module-path&quot;&gt;모듈 경로&lt;/a&gt; 에 &lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt; 및 &lt;a href=&quot;names#module-path&quot;&gt;모듈 경로&lt;/a&gt; . ( &lt;a href=&quot;#expr&quot;&gt;EXPR는&lt;/a&gt; ) 엄격 동등하다. 이러한 구성은 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 표현식의 각 범위에서 모듈 경로 &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; 에 의해 참조되는 모듈을 로컬로 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="e1d5d2150f39dd154ec68fa36cfff5333db652cf" translate="yes" xml:space="preserve">
          <source>The external function f is not available</source>
          <target state="translated">외부 기능 f를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5f529de453636246288677488101d22e2108e01" translate="yes" xml:space="preserve">
          <source>The field width is composed of an optional integer literal indicating the maximal width of the token to read. For instance, &lt;code&gt;%6d&lt;/code&gt; reads an integer, having at most 6 decimal digits; &lt;code&gt;%4f&lt;/code&gt; reads a float with at most 4 characters; and &lt;code&gt;%8[\000-\255]&lt;/code&gt; returns the next 8 characters (or all the characters still available, if fewer than 8 characters are available in the input).</source>
          <target state="translated">필드 너비는 읽을 토큰의 최대 너비를 나타내는 선택적 정수 리터럴로 구성됩니다. 예를 들어, &lt;code&gt;%6d&lt;/code&gt; 는 최대 6 개의 십진수를 가진 정수를 읽습니다. &lt;code&gt;%4f&lt;/code&gt; 는 최대 4 자의 부동 소수점을 읽습니다. 및 &lt;code&gt;%8[\000-\255]&lt;/code&gt; (8 개 미만의 문자 입력에 사용할 수있는 경우, 또는 모든 문자 여전히 가능) 다음 8 개 문자를 반환한다.</target>
        </trans-unit>
        <trans-unit id="ae52f5d3cbe515efd2a7aaa53a21566c409e073d" translate="yes" xml:space="preserve">
          <source>The file curses_stubs.c can be compiled with:</source>
          <target state="translated">curses_stubs.c 파일은 다음으로 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9cf1595a49bfb32957e71e1d6050587722d1094" translate="yes" xml:space="preserve">
          <source>The file custom.cmo is created and can be used this way :</source>
          <target state="translated">custom.cmo 파일이 생성되고 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="139f2d48257c0343c4b071f4794d59ad6e533fc9" translate="yes" xml:space="preserve">
          <source>The file that ocamlrun is trying to execute (e.g. the file given as first non-option argument to ocamlrun) either does not exist, or is not a valid executable bytecode file.</source>
          <target state="translated">ocamlrun이 실행하려는 파일 (예 : ocamlrun에 대한 첫 번째 비 옵션 인수로 제공된 파일)이 존재하지 않거나 유효한 실행 가능한 바이트 코드 파일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9df79524971faf6930542e99bcb97fb7e6ed0d2f" translate="yes" xml:space="preserve">
          <source>The file that ocamlrun is trying to execute is not a valid executable bytecode file. Probably it has been truncated or mangled since created. Erase and rebuild it.</source>
          <target state="translated">ocamlrun이 실행하려는 파일은 유효한 실행 가능한 바이트 코드 파일이 아닙니다. 아마도 생성 된 이후로 잘 리거나 잘 렸을 것입니다. 지우고 다시 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="1479d9789eb939b776377dc8d01919fe50c91085" translate="yes" xml:space="preserve">
          <source>The files that define the compilation units can be compiled separately using the ocamlc -c command (the -c option means &amp;ldquo;compile only, do not try to link&amp;rdquo;); this produces compiled interface files (with extension .cmi) and compiled object code files (with extension .cmo). When all units have been compiled, their .cmo files are linked together using the ocamlc command. For instance, the following commands compile and link a program composed of two compilation units Aux and Main:</source>
          <target state="translated">컴파일 단위를 정의하는 파일은 ocamlc -c 명령을 사용하여 별도로 컴파일 할 수 있습니다 (-c 옵션은 &quot;컴파일 전용, 링크 시도 안 함&quot;을 의미합니다). 이렇게하면 컴파일 된 인터페이스 파일 (확장자 .cmi)과 컴파일 된 개체 코드 파일 (확장자 .cmo)이 생성됩니다. 모든 장치가 컴파일되면 해당 .cmo 파일이 ocamlc 명령을 사용하여 함께 연결됩니다. 예를 들어, 다음 명령은 두 개의 컴파일 단위 Aux 및 Main으로 구성된 프로그램을 컴파일하고 연결합니다.</target>
        </trans-unit>
        <trans-unit id="218142a8cd84298a616575dd3b1a7d204717b40e" translate="yes" xml:space="preserve">
          <source>The files you can use to define custom generators are installed in the ocamldoc sub-directory of the OCaml standard library.</source>
          <target state="translated">사용자 정의 생성기를 정의하는 데 사용할 수있는 파일은 OCaml 표준 라이브러리의 ocamldoc 하위 디렉토리에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="59dbb07f3aaa12eeacf11b0514d46f8f8f33f5ee" translate="yes" xml:space="preserve">
          <source>The finalize field contains a pointer to a C function that is called when the block becomes unreachable and is about to be reclaimed. The block is passed as first argument to the function. The finalize field can also be custom_finalize_default to indicate that no finalization function is associated with the block.</source>
          <target state="translated">finalize 필드에는 블록에 도달 할 수 없게되어 재 확보 될 때 호출되는 C 함수에 대한 포인터가 포함되어 있습니다. 블록은 함수의 첫 번째 인수로 전달됩니다. finalize 필드는 custom_finalize_default가되어 블록과 연관된 종료 기능이 없음을 나타낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="db242e09b65549d74785bc5f6a999727dbb33d18" translate="yes" xml:space="preserve">
          <source>The first argument of Store_field and Store_double_field must be a variable declared by CAMLparam* or a parameter declared by CAMLlocal* to ensure that a garbage collection triggered by the evaluation of the other arguments will not invalidate the first argument after it is computed.</source>
          <target state="translated">Store_field 및 Store_double_field의 첫 번째 인수는 CAMLparam *에 의해 선언 된 변수이거나 CAMLlocal *에 의해 선언 된 매개 변수 여야 다른 인수의 평가에 의해 트리거 된 가비지 수집이 계산 된 후 첫 번째 인수를 무효화하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="483025a84206923192f7c9762bbef7fe0c59cbd8" translate="yes" xml:space="preserve">
          <source>The first case is an exact variant type: all possible tags are known, with their associated types, and they can all be present. Its structure is fully known.</source>
          <target state="translated">첫 번째 경우는 정확한 변형 유형입니다. 가능한 모든 태그가 관련 유형과 함께 알려져 있으며 모두 존재할 수 있습니다. 그 구조는 완전히 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="26e2eb8f32164f7d7049d034e263952e663d7410" translate="yes" xml:space="preserve">
          <source>The first case is simple: g is passed ~y and then ~x, but f expects ~x and then ~y. This is correctly handled if we know the type of g to be x:int -&amp;gt; y:int -&amp;gt; int in advance, but otherwise this causes the above type clash. The simplest workaround is to apply formal parameters in a standard order.</source>
          <target state="translated">첫 번째 경우는 간단합니다. g는 ~ y 다음에 ~ x를 전달하지만 f는 ~ x와 ~ y를 예상합니다. g의 유형이 x : int-&amp;gt; y : int-&amp;gt; int 인 것을 미리 알고 있으면 올바르게 처리되지만 그렇지 않으면 위 유형 충돌이 발생합니다. 가장 간단한 해결 방법은 표준 순서로 형식 매개 변수를 적용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ddf571ff45a432684168e808086b6b09e060a7b" translate="yes" xml:space="preserve">
          <source>The first declaration is incorrect, because the string literal &lt;code&gt;&quot;hello&quot;&lt;/code&gt; could be shared by the compiler with other parts of the program, and mutating &lt;code&gt;incorrect&lt;/code&gt; is a bug. You must always use the second version, which performs a copy and is thus correct.</source>
          <target state="translated">첫 번째 선언은 올바르지 않습니다. 왜냐하면 문자열 리터럴 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 는 컴파일러가 프로그램의 다른 부분과 공유 할 수 있기 때문이며 &lt;code&gt;incorrect&lt;/code&gt; 변경 은 버그입니다. 항상 복사를 수행하므로 올바른 두 번째 버전을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7a8e55f0808e48aad9f2858718bff1a1afbe6952" translate="yes" xml:space="preserve">
          <source>The first form of attributes is attached with a postfix notation on &amp;ldquo;algebraic&amp;rdquo; categories:</source>
          <target state="translated">속성의 첫 번째 형식은 &quot;대수&quot;범주에 접미사 표기법으로 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="c20d4143c725e414a8fe296ef743e273f408fd33" translate="yes" xml:space="preserve">
          <source>The first form of extension node is used for &amp;ldquo;algebraic&amp;rdquo; categories:</source>
          <target state="translated">확장 노드의 첫 번째 형식은 &quot;대수&quot;범주에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9e06920ecf0cdfc759a972552119b98dac760381" translate="yes" xml:space="preserve">
          <source>The first non-option argument is taken to be the name of the file containing the executable bytecode. (That file is searched in the executable path as well as in the current directory.) The remaining arguments are passed to the OCaml program, in the string array Sys.argv. Element 0 of this array is the name of the bytecode executable file; elements 1 to n are the remaining arguments arg&lt;sub&gt;1&lt;/sub&gt; to arg&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">옵션이 아닌 첫 번째 인수는 실행 가능한 바이트 코드를 포함하는 파일의 이름으로 간주됩니다. (해당 파일은 현재 디렉토리뿐만 아니라 실행 가능한 경로에서도 검색됩니다.) 나머지 인수는 문자열 배열 Sys.argv에서 OCaml 프로그램에 전달됩니다. 이 배열의 요소 0은 바이트 코드 실행 파일의 이름입니다. 요소 1 ~ n은 나머지 인수 arg &lt;sub&gt;1&lt;/sub&gt; ~ arg &lt;sub&gt;n&lt;/sub&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4b219d7a443ce004c101ae67774c3ff8d7838f69" translate="yes" xml:space="preserve">
          <source>The first two cases refer to a value identifier, either unqualified or qualified by the path to the structure that define it. * refers to the result just computed (typically, the value of a function application), and is valid only if the selected event is an &amp;ldquo;after&amp;rdquo; event (typically, a function application). $integer refer to a previously printed value. The remaining four forms select part of an expression: respectively, a record field, an array element, a string element, and the current contents of a reference.</source>
          <target state="translated">처음 두 경우는 값 식별자를 참조하며, 값 식별자는이를 정의하는 구조에 대한 경로에 의해 규정되지 않거나 규정됩니다. *는 방금 계산 된 결과 (일반적으로 함수 응용 프로그램의 값)를 나타내며 선택한 이벤트가 &quot;이후&quot;이벤트 (일반적으로 함수 응용 프로그램) 인 경우에만 유효합니다. $ integer는 이전에 인쇄 된 값을 나타냅니다. 나머지 네 가지 양식은 각각 레코드 필드, 배열 요소, 문자열 요소 및 참조의 현재 내용 등 표현식의 일부를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="2239d147af301ebf1848d9c3aed42b025297f0fd" translate="yes" xml:space="preserve">
          <source>The five classes of floating-point numbers, as determined by the &lt;a href=&quot;float#VALclassify_float&quot;&gt;&lt;code&gt;Float.classify_float&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;float#VALclassify_float&quot;&gt; &lt;code&gt;Float.classify_float&lt;/code&gt; &lt;/a&gt; 함수에 의해 결정된 5 가지 부동 소수점 숫자 클래스 .</target>
        </trans-unit>
        <trans-unit id="e5f4b14dbb83404562f202cb46321bbf598f23f0" translate="yes" xml:space="preserve">
          <source>The five classes of floating-point numbers, as determined by the &lt;a href=&quot;stdlib#VALclassify_float&quot;&gt;&lt;code&gt;classify_float&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALclassify_float&quot;&gt; &lt;code&gt;classify_float&lt;/code&gt; &lt;/a&gt; 함수에 의해 결정된 5 가지 부동 소수점 숫자 클래스 .</target>
        </trans-unit>
        <trans-unit id="681b526c61bdcee2f004dd7b0da14d09277654dc" translate="yes" xml:space="preserve">
          <source>The flags -Oclassic, -O2 and -O3 are applied before all other flags, meaning that certain parameters may be overridden without having to specify every parameter usually invoked by the given optimisation level.</source>
          <target state="translated">-Oclassic, -O2 및 -O3 플래그는 다른 모든 플래그보다 먼저 적용됩니다. 즉, 주어진 최적화 레벨에서 일반적으로 호출되는 모든 매개 변수를 지정하지 않고도 특정 매개 변수를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41e4ad6689358b23fa1eb693a69c5cf4c073612a" translate="yes" xml:space="preserve">
          <source>The flags for &lt;a href=&quot;unix#VALrecv&quot;&gt;&lt;code&gt;Unix.recv&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unix#VALrecvfrom&quot;&gt;&lt;code&gt;Unix.recvfrom&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unix#VALsend&quot;&gt;&lt;code&gt;Unix.send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unix#VALsendto&quot;&gt;&lt;code&gt;Unix.sendto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALrecv&quot;&gt; &lt;code&gt;Unix.recv&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;unix#VALrecvfrom&quot;&gt; &lt;code&gt;Unix.recvfrom&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;unix#VALsend&quot;&gt; &lt;code&gt;Unix.send&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;unix#VALsendto&quot;&gt; &lt;code&gt;Unix.sendto&lt;/code&gt; 에&lt;/a&gt; 대한 플래그입니다 .</target>
        </trans-unit>
        <trans-unit id="7fd4283b647a522a0c9037980c206ad3a14cfba5" translate="yes" xml:space="preserve">
          <source>The flags for &lt;a href=&quot;unixlabels#VALrecv&quot;&gt;&lt;code&gt;UnixLabels.recv&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unixlabels#VALrecvfrom&quot;&gt;&lt;code&gt;UnixLabels.recvfrom&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;unixlabels#VALsend&quot;&gt;&lt;code&gt;UnixLabels.send&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unixlabels#VALsendto&quot;&gt;&lt;code&gt;UnixLabels.sendto&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALrecv&quot;&gt; &lt;code&gt;UnixLabels.recv&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;unixlabels#VALrecvfrom&quot;&gt; &lt;code&gt;UnixLabels.recvfrom&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;unixlabels#VALsend&quot;&gt; &lt;code&gt;UnixLabels.send&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;unixlabels#VALsendto&quot;&gt; &lt;code&gt;UnixLabels.sendto&lt;/code&gt; 에&lt;/a&gt; 대한 플래그입니다 .</target>
        </trans-unit>
        <trans-unit id="e26b9a410e534dd152b1e84e847e91afe66a6921" translate="yes" xml:space="preserve">
          <source>The flags to &lt;a href=&quot;unix#VALopenfile&quot;&gt;&lt;code&gt;Unix.openfile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopenfile&quot;&gt; &lt;code&gt;Unix.openfile&lt;/code&gt; 에&lt;/a&gt; 대한 플래그 .</target>
        </trans-unit>
        <trans-unit id="92926c8ba910a78b19eb9560e04391f617314f85" translate="yes" xml:space="preserve">
          <source>The flags to &lt;a href=&quot;unixlabels#VALopenfile&quot;&gt;&lt;code&gt;UnixLabels.openfile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALopenfile&quot;&gt; &lt;code&gt;UnixLabels.openfile&lt;/code&gt; 에&lt;/a&gt; 대한 플래그 입니다.</target>
        </trans-unit>
        <trans-unit id="da416c9b0c9ec887e3c9fed14c90d2a6cfe00274" translate="yes" xml:space="preserve">
          <source>The flags to the &lt;code&gt;Marshal.to_*&lt;/code&gt; functions below.</source>
          <target state="translated">아래 의 &lt;code&gt;Marshal.to_*&lt;/code&gt; 함수에 대한 플래그 입니다.</target>
        </trans-unit>
        <trans-unit id="e8910a8a70e1456ec6a90eb77007ffc0da7c2187" translate="yes" xml:space="preserve">
          <source>The floating point 0.</source>
          <target state="translated">부동 소수점 0.</target>
        </trans-unit>
        <trans-unit id="4ab9429d7283ec75f0e02bc07dcd3134a72594e2" translate="yes" xml:space="preserve">
          <source>The floating-point -1.</source>
          <target state="translated">부동 소수점 -1.</target>
        </trans-unit>
        <trans-unit id="2f12a48f02e6b8cb1bc97e090aa405bfffaff9d2" translate="yes" xml:space="preserve">
          <source>The floating-point 1.</source>
          <target state="translated">부동 소수점 1입니다.</target>
        </trans-unit>
        <trans-unit id="0cf650e7443d1e286b4973d2572d41f2dd1c5a71" translate="yes" xml:space="preserve">
          <source>The following bindings for the most common debugger commands are available in the *camldebug-progname* buffer:</source>
          <target state="translated">가장 일반적인 디버거 명령에 대한 다음 바인딩은 * camldebug-progname * 버퍼에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa8fb8f6579c8a754f8160f2c545902f2c3649f3" translate="yes" xml:space="preserve">
          <source>The following built-in types and predefined exceptions are always defined in the compilation environment, but are not part of any module. As a consequence, they can only be referred by their short names.</source>
          <target state="translated">다음 내장 유형 및 사전 정의 된 예외는 항상 컴파일 환경에서 정의되지만 모듈의 일부는 아닙니다. 따라서 짧은 이름으로 만 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="741949c165a3e82c7b1f8762527481edfe04447a" translate="yes" xml:space="preserve">
          <source>The following character sequences are also keywords:</source>
          <target state="translated">다음 문자 시퀀스도 키워드입니다.</target>
        </trans-unit>
        <trans-unit id="34ab75b655a01e99e773cf2e772887f93cd01533" translate="yes" xml:space="preserve">
          <source>The following characters are considered as blanks: space, horizontal tabulation, carriage return, line feed and form feed. Blanks are ignored, but they separate adjacent identifiers, literals and keywords that would otherwise be confused as one single identifier, literal or keyword.</source>
          <target state="translated">공백, 가로 표, 캐리지 리턴, 줄 바꿈 및 용지 공급과 같은 문자는 공백으로 간주됩니다. 공백은 무시되지만 하나의 단일 식별자, 리터럴 또는 키워드로 혼동 될 수있는 인접한 식별자, 리터럴 및 키워드를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="bfd936c99ec75ec8467efb2fa73208d1cfd7da18" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlc. The options -pack, -a, -c and -output-obj are mutually exclusive.</source>
          <target state="translated">다음 명령 줄 옵션은 ocamlc에서 인식합니다. -pack, -a, -c 및 -output-obj 옵션은 상호 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="8fe55eff2fce3bd36f31017706fd97b0e53f6496" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamldep.</source>
          <target state="translated">다음 명령 줄 옵션은 ocamldep에서 인식합니다.</target>
        </trans-unit>
        <trans-unit id="885f4ff9e5ff4ddb2e7d9854020f77ada3553ef5" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamllex.</source>
          <target state="translated">다음 명령 줄 옵션은 ocamllex에서 인식합니다.</target>
        </trans-unit>
        <trans-unit id="ba3896a823e9e144bf0d4b7e1f61010aad966b5f" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlmktop.</source>
          <target state="translated">다음 명령 줄 옵션은 ocamlmktop에서 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="1edcf650050ceecdfe0b7ab459ca56279ebf0aae" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlopt. The options -pack, -a, -shared, -c and -output-obj are mutually exclusive.</source>
          <target state="translated">다음 명령 줄 옵션은 ocamlopt에서 인식합니다. -pack, -a, -shared, -c 및 -output-obj 옵션은 상호 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="f01e63f748272442f586e0dcde7deabec94a1be5" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by ocamlrun.</source>
          <target state="translated">다음 명령 줄 옵션은 ocamlrun에서 인식합니다.</target>
        </trans-unit>
        <trans-unit id="df87076d9fe00726ba61eaa8293d8eef997abd39" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized by the ocaml command.</source>
          <target state="translated">다음 명령 줄 옵션은 ocaml 명령으로 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="d8652df34978643d1ab214e3a8b1d14afa637e47" translate="yes" xml:space="preserve">
          <source>The following command-line options are recognized:</source>
          <target state="translated">다음 명령 줄 옵션이 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="ea03de4698c2ebdfac27067880c0104b3ab3bd1f" translate="yes" xml:space="preserve">
          <source>The following commands create the custom.cma file from files file&lt;sub&gt;1&lt;/sub&gt;.ml[i], ..., file&lt;sub&gt;n&lt;/sub&gt;.ml[i] :</source>
          <target state="translated">다음 명령은 파일 &lt;sub&gt;1&lt;/sub&gt; .ml [i], ..., 파일 &lt;sub&gt;n&lt;/sub&gt; .ml [i] 에서 custom.cma 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="2ef4512268a1e60220a903be3d8066db5cafc567" translate="yes" xml:space="preserve">
          <source>The following commands display information on checkpoints and events:</source>
          <target state="translated">다음 명령은 체크 포인트 및 이벤트에 대한 정보를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d56705239611e41383cc5a0fc4c62ec9ece9f729" translate="yes" xml:space="preserve">
          <source>The following commands execute the program forward or backward, starting at the current time. The execution will stop either when specified by the command or when a breakpoint is encountered.</source>
          <target state="translated">다음 명령은 현재 시간부터 프로그램을 앞으로 또는 뒤로 실행합니다. 명령에 의해 지정되거나 중단 점이 발생하면 실행이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="aa8b474e507be285882f655940a333fef3ed7e16" translate="yes" xml:space="preserve">
          <source>The following constants are treated like built-in constant constructors:</source>
          <target state="translated">다음 상수는 내장 상수 생성자처럼 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="f046204697990bb2d0f4cd47a0f626a4abb10376" translate="yes" xml:space="preserve">
          <source>The following directives control the toplevel behavior, load files in memory, and trace program execution.</source>
          <target state="translated">다음 지시문은 최상위 동작을 제어하고, 메모리에 파일을로드하고, 프로그램 실행을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="0e3f41e76fac899ccc6e7dc6bb71eadc7f7839bf" translate="yes" xml:space="preserve">
          <source>The following environment variables are also consulted:</source>
          <target state="translated">다음 환경 변수도 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="86dc8be3269b92b9232bc979a84ec53ac86636df" translate="yes" xml:space="preserve">
          <source>The following example illustrates how statically-allocated C and Fortran arrays can be made available to OCaml.</source>
          <target state="translated">다음 예제는 OCaml에서 정적으로 할당 된 C 및 Fortran 배열을 사용할 수있는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7b95c269aef6e820286357345f289155493b43dd" translate="yes" xml:space="preserve">
          <source>The following example illustrates the assignment of integers and block tags to constructors:</source>
          <target state="translated">다음 예제는 생성자에 정수 및 블록 태그 할당을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="bb54e0eb9f74bd676ad11ff69ff7bddb5206be2e" translate="yes" xml:space="preserve">
          <source>The following example of file toto.ml shows where to place comments in a .ml file.</source>
          <target state="translated">toto.ml 파일의 다음 예제는 .ml 파일에서 주석을 배치 할 위치를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="fb214a3cbe4113b36d77da33d2aad1393c44f7c9" translate="yes" xml:space="preserve">
          <source>The following example shows the passing of a two-dimensional Bigarray to a C function and a Fortran function.</source>
          <target state="translated">다음 예제는 2 차원 Bigarray를 C 함수와 Fortran 함수에 전달하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="28d8c0cb68d2ae92275d2ecc53225fa520b47419" translate="yes" xml:space="preserve">
          <source>The following example uses a private type abbreviation to define a module of nonnegative integers:</source>
          <target state="translated">다음 예제에서는 전용 유형 약어를 사용하여 음이 아닌 정수 모듈을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d3ae00605da64b105662093b0c38586124245f33" translate="yes" xml:space="preserve">
          <source>The following example, known as the subject/observer pattern, is often presented in the literature as a difficult inheritance problem with inter-connected classes. The general pattern amounts to the definition a pair of two classes that recursively interact with one another.</source>
          <target state="translated">주제 / 관찰자 패턴으로 알려진 다음 예제는 종종 상호 연결된 클래스의 어려운 상속 문제로 문헌에서 제시됩니다. 일반적인 패턴은 서로 재귀 적으로 상호 작용하는 두 클래스 쌍의 정의에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="fe79f151ba4780648aa79dae8b08c42dcb70ffa0" translate="yes" xml:space="preserve">
          <source>The following functions are exposed to help write compatible C stubs. To use them, you need to include both &amp;lt;caml/misc.h&amp;gt; and &amp;lt;caml/osdeps.h&amp;gt;.</source>
          <target state="translated">다음 함수는 호환 가능한 C 스텁을 작성하는 데 도움이되도록 노출됩니다. 이를 사용하려면 &amp;lt;caml / misc.h&amp;gt; 및 &amp;lt;caml / osdeps.h&amp;gt;를 모두 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="832fc1be181c5700f255f7f5cd917c79991599e3" translate="yes" xml:space="preserve">
          <source>The following functions are slightly more efficient than caml_alloc, but also much more difficult to use.</source>
          <target state="translated">다음 함수는 caml_alloc보다 약간 더 효율적이지만 사용하기가 훨씬 더 어렵습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="e63d19b6970bf278c78ca3c011faa62ed74f62ae" translate="yes" xml:space="preserve">
          <source>The following functions can be called from the semantic actions of lexer definitions (the ML code enclosed in braces that computes the value returned by lexing functions). They give access to the character string matched by the regular expression associated with the semantic action. These functions must be applied to the argument &lt;code&gt;lexbuf&lt;/code&gt;, which, in the code generated by &lt;code&gt;ocamllex&lt;/code&gt;, is bound to the lexer buffer passed to the parsing function.</source>
          <target state="translated">다음 함수는 렉서 정의의 시맨틱 작업에서 호출 할 수 있습니다 (어 렉싱 함수에서 반환 된 값을 계산하는 중괄호로 묶인 ML 코드). 시맨틱 조치와 연관된 정규 표현식과 일치하는 문자열에 대한 액세스를 제공합니다. 이러한 함수는 &lt;code&gt;ocamllex&lt;/code&gt; 에 의해 생성 된 코드 에서 구문 분석 함수에 전달 된 렉서 버퍼에 바인딩 되는 &lt;code&gt;lexbuf&lt;/code&gt; 인수에 적용되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="45f2a5408f593c266bc5b945e256185ab7faa225" translate="yes" xml:space="preserve">
          <source>The following functions implement the POSIX standard terminal interface. They provide control over asynchronous communication ports and pseudo-terminals. Refer to the &lt;code&gt;termios&lt;/code&gt; man page for a complete description.</source>
          <target state="translated">다음 함수는 POSIX 표준 터미널 인터페이스를 구현합니다. 비동기 통신 포트 및 의사 터미널에 대한 제어를 제공합니다. 자세한 설명 은 &lt;code&gt;termios&lt;/code&gt; 매뉴얼 페이지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04b159ad2babd8305b93430182e2074b26259f77" translate="yes" xml:space="preserve">
          <source>The following functions, defined in &amp;lt;caml/intext.h&amp;gt;, are provided to write and read back the contents of custom blocks in a portable way. Those functions handle endianness conversions when e.g. data is written on a little-endian machine and read back on a big-endian machine.</source>
          <target state="translated">&amp;lt;caml / intext.h&amp;gt;에 정의 된 다음 함수는 사용자 지정 블록의 내용을 이식 가능한 방식으로 쓰고 다시 읽을 수 있도록 제공됩니다. 이러한 함수는 데이터가 리틀 엔디안 머신에 기록되고 빅 엔디안 머신에서 다시 읽을 때 엔디안 변환을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="d4d76bd017aaace084c2fe4ba75e854a770052fa" translate="yes" xml:space="preserve">
          <source>The following idiom separates description and definition.</source>
          <target state="translated">다음 관용구는 설명과 정의를 분리합니다.</target>
        </trans-unit>
        <trans-unit id="abdd18dbed9ebbfffd9a3d53fecf519fa1b39456" translate="yes" xml:space="preserve">
          <source>The following invariant holds for any file name &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="translated">다음 불변은 파일 이름에 대한 보유 &lt;code&gt;s&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="da4c18672e8270bfb1a76f87b23a373991175930" translate="yes" xml:space="preserve">
          <source>The following language semantics apply specifically to constant float arrays. (By &amp;ldquo;constant float array&amp;rdquo; is meant an array consisting entirely of floating point numbers that are known at compile time. A common case is a literal such as [| 42.0; 43.0; |].</source>
          <target state="translated">다음 언어 의미 체계는 특히 상수 부동 소수점 배열에 적용됩니다. ( &quot;상수 부동 배열&quot;은 컴파일 시간에 알려진 부동 소수점 숫자로만 구성된 배열을 의미합니다. 일반적인 경우는 [| 42.0; 43.0; |]과 같은 리터럴입니다.</target>
        </trans-unit>
        <trans-unit id="2f8a143ee55050d3e9f8c912fc4c49000ef1b06a" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -dot option:</source>
          <target state="translated">다음 옵션은 -dot 옵션과 함께 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="166817d7c28936e2b423cdda7a6aa67512725a8e" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -html option:</source>
          <target state="translated">다음 옵션은 -html 옵션과 함께 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4ecf6b7625e3e537050eaf9dc3a7fa22f048e25b" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -latex option:</source>
          <target state="translated">다음 옵션은 -latex 옵션과 함께 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="cbc2ec126f36a5f0afa27f31d58d5bda45d9c06d" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -man option:</source>
          <target state="translated">다음 옵션은 -man 옵션과 함께 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="051fe64a5d38a370f62ad07eadfb825faac6621f" translate="yes" xml:space="preserve">
          <source>The following options apply in conjunction with the -texi option:</source>
          <target state="translated">다음 옵션은 -texi 옵션과 함께 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3d4dbac485d984712c71b7a64c65bc9a132b2436" translate="yes" xml:space="preserve">
          <source>The following options are recognized by ocamlprof:</source>
          <target state="translated">ocamlprof는 다음 옵션을 인식합니다.</target>
        </trans-unit>
        <trans-unit id="6a846492c1f0c6319e8b3788beab792307a98121" translate="yes" xml:space="preserve">
          <source>The following options determine the format for the generated documentation.</source>
          <target state="translated">다음 옵션은 생성 된 문서의 형식을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="8c2e53d36ec19399f7c32f9aac23861dbfe9cf9f" translate="yes" xml:space="preserve">
          <source>The following rules must be respected in order to avoid name clashes resulting in cross-reference errors:</source>
          <target state="translated">상호 참조 오류로 인한 이름 충돌을 방지하려면 다음 규칙을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="097e045769a0dca8fade64c26d195db8b9414337" translate="yes" xml:space="preserve">
          <source>The following sample interface file foo.mli illustrates the placement rules for comments in .mli files.</source>
          <target state="translated">다음 샘플 인터페이스 파일 foo.mli는 .mli 파일의 주석 배치 규칙을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ebfe702602d2495e52da52309ab1711b73354bb5" translate="yes" xml:space="preserve">
          <source>The following table gives the list of predefined @-tags, with their syntax and meaning.</source>
          <target state="translated">다음 표는 구문 및 의미와 함께 사전 정의 된 @-태그 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dd8a8320baafd30cfa4602768ee2151691b2708f" translate="yes" xml:space="preserve">
          <source>The following table lists the precedence level of all operator classes from the highest to the lowest precedence. A few other syntactic constructions are also listed as references.</source>
          <target state="translated">다음 표에는 가장 높은 우선 순위에서 가장 낮은 우선 순위까지 ​​모든 연산자 클래스의 우선 순위 수준이 나열되어 있습니다. 몇 가지 다른 구문 구조도 참조로 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="9e256f5eaf5d8b81e4043192160908c1bd8faea3" translate="yes" xml:space="preserve">
          <source>The following table summarize what OCaml types can be unboxed, and what C types should be used in correspondence:</source>
          <target state="translated">다음 표는 언 박싱 할 수있는 OCaml 유형과 대응에 사용해야하는 C 유형을 요약 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="ef06aa8040c0f03b521f5cef891b934434387cc7" translate="yes" xml:space="preserve">
          <source>The following terminology is used in this chapter of the manual.</source>
          <target state="translated">이 장에서는 다음 용어가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1699520402e7ac3828d5b8bcc342d6a427931baa" translate="yes" xml:space="preserve">
          <source>The following two functions are deprecated. Use module &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">다음 두 기능은 더 이상 사용되지 않습니다. 대신 모듈 &lt;a href=&quot;marshal&quot;&gt; &lt;code&gt;Marshal&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b87aaa89310b1024b8a1a7a3d739748757473aea" translate="yes" xml:space="preserve">
          <source>The form exception&lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; generates a new exception, distinct from all other exceptions in the system. The form exception&lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt;=&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; gives an alternate name to an existing exception.</source>
          <target state="translated">예외 &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; 양식 은 시스템의 다른 모든 예외와 구별되는 새로운 예외를 생성합니다. 예외 &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt; = &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; 양식 은 기존 예외에 대체 이름을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b37d1605c59154ddd022186be0bfed3eb3e2b35d" translate="yes" xml:space="preserve">
          <source>The form external&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt; is similar, except that it requires in addition the name to be implemented as the external function specified in &lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt; (see chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;).</source>
          <target state="translated">폼 외부 &lt;a href=&quot;names#value-name&quot;&gt;값 이름&lt;/a&gt; : &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; = &lt;a href=&quot;intfc#external-declaration&quot;&gt;외부 선언&lt;/a&gt; 이 외에도 지정된 외부 함수로서 구현 될 수있는 이름을 필요로하는 것을 제외하고 유사하다 &lt;a href=&quot;intfc#external-declaration&quot;&gt;외부 선언&lt;/a&gt; (제 볼 &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;(20)&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3184fd8520491af729727e8e58dedc4128114b17" translate="yes" xml:space="preserve">
          <source>The format of decimal floating-point numbers is &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;dd.ddd&amp;nbsp;(e|E)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt;, where &lt;code&gt;d&lt;/code&gt; stands for a decimal digit.</source>
          <target state="translated">10 진수 부동 소수점 숫자의 형식은 &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;dd.ddd&amp;nbsp;(e|E)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt; . 여기서 &lt;code&gt;d&lt;/code&gt; 는 10 진수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7828f8d5d5c611bdddc6c78b6ef04afbcd5d417e" translate="yes" xml:space="preserve">
          <source>The format of hexadecimal floating-point numbers is &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;0(x|X)&amp;nbsp;hh.hhh&amp;nbsp;(p|P)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt;, where &lt;code&gt;h&lt;/code&gt; stands for an hexadecimal digit and &lt;code&gt;d&lt;/code&gt; for a decimal digit.</source>
          <target state="translated">16 진수 부동 소수점 숫자의 형식은 &lt;code&gt;&amp;nbsp;[-]&amp;nbsp;0(x|X)&amp;nbsp;hh.hhh&amp;nbsp;(p|P)&amp;nbsp;[+|-]&amp;nbsp;dd&amp;nbsp;&lt;/code&gt; . 여기서 &lt;code&gt;h&lt;/code&gt; 는 16 진수를 나타내고 &lt;code&gt;d&lt;/code&gt; 는 10 진수를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="812ca11444f87b91a5c1a4d58c74d93fafa141dc" translate="yes" xml:space="preserve">
          <source>The format of lexer definitions is as follows:</source>
          <target state="translated">어휘 분석기 정의의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="127323cd14f10ff976ce82741602642432da7e75" translate="yes" xml:space="preserve">
          <source>The format string &lt;code&gt;fmt&lt;/code&gt; is a character string which contains three types of objects: plain characters and conversion specifications as specified in the &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt; module, and pretty-printing indications specific to the &lt;code&gt;Format&lt;/code&gt; module.</source>
          <target state="translated">형식 문자열 &lt;code&gt;fmt&lt;/code&gt; 는 &lt;a href=&quot;printf&quot;&gt; &lt;code&gt;Printf&lt;/code&gt; &lt;/a&gt; 모듈에 지정된 일반 문자 및 변환 사양과 &lt;code&gt;Format&lt;/code&gt; 모듈에 특정한 예쁘게 인쇄되는 표시의 세 가지 유형의 개체를 포함하는 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="98fb30c95542494775f06815271fe47f1e740e5d" translate="yes" xml:space="preserve">
          <source>The format string is a character string which contains three types of objects:</source>
          <target state="translated">형식 문자열은 세 가지 유형의 객체를 포함하는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="66553eccbf80219caa1c3c646bc08b8b25b163d4" translate="yes" xml:space="preserve">
          <source>The format string is a character string which contains two types of objects: plain characters, which are simply copied to the output channel, and conversion specifications, each of which causes conversion and printing of arguments.</source>
          <target state="translated">형식 문자열은 두 가지 유형의 객체를 포함하는 문자열입니다. 출력 채널에 간단히 복사되는 일반 문자와 변환 사양으로 각각 인수를 변환하고 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="9fd14a172518628e19f32be0e91f3d86d102d1cd" translate="yes" xml:space="preserve">
          <source>The formatted input functions can read from any kind of input, including strings, files, or anything that can return characters. The more general source of characters is named a &lt;em&gt;formatted input channel&lt;/em&gt; (or &lt;em&gt; scanning buffer&lt;/em&gt;) and has type &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt;. The more general formatted input function reads from any scanning buffer and is named &lt;code&gt;bscanf&lt;/code&gt;.</source>
          <target state="translated">형식화 된 입력 함수는 문자열, 파일 또는 문자를 반환 할 수있는 모든 것을 포함하여 모든 종류의 입력에서 읽을 수 있습니다. 보다 일반적인 문자 소스는 &lt;em&gt;형식화 된 입력 채널&lt;/em&gt; (또는 &lt;em&gt;스캐닝 버퍼&lt;/em&gt; ) 로 명명되며 유형은 &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt; &lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt; &lt;/a&gt; 입니다. 보다 일반적인 형식의 입력 함수는 모든 스캔 버퍼에서 읽고 이름은 &lt;code&gt;bscanf&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e23bc34a1d5333a784d920ce0ee827fd82d18c4c" translate="yes" xml:space="preserve">
          <source>The former alternative is more convenient for the final users of the library, however.</source>
          <target state="translated">그러나 전자의 대안은 라이브러리의 최종 사용자에게 더 편리합니다.</target>
        </trans-unit>
        <trans-unit id="cf9a1462b05ebbf56fca1e287e7b7e2870abd6cd" translate="yes" xml:space="preserve">
          <source>The former operator will sometimes fail to coerce an expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; from a type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to a type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; even if type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a subtype of type &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;: in the current implementation it only expands two levels of type abbreviations containing objects and/or polymorphic variants, keeping only recursion when it is explicit in the class type (for objects). As an exception to the above algorithm, if both the inferred type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt; are ground (&lt;em&gt;i.e.&lt;/em&gt; do not contain type variables), the former operator behaves as the latter one, taking the inferred type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; as &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. In case of failure with the former operator, the latter one should be used.</source>
          <target state="translated">전 운영자는 때때로 발현 억압 실패 &lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt; 형태에서이 &lt;a href=&quot;types#typexpr&quot;&gt;통상 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 종류에 &lt;a href=&quot;types#typexpr&quot;&gt;통상 &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 타입하더라도 &lt;a href=&quot;types#typexpr&quot;&gt;일반 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 타입의 서브 타입 인 &lt;a href=&quot;types#typexpr&quot;&gt;일반 &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; : 현재 구현에서 단지 목적 및 함유 타입 약어의 두 단계 팽창 / 또는 다형성 변형, 클래스 유형 (객체의 경우)에서 명시적일 때만 재귀를 유지합니다. 추정 된 타입의 두 경우에, 상기 알고리즘에 대한 예외로서 &lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt; 및 &lt;a href=&quot;types#typexpr&quot;&gt;일반은&lt;/a&gt; 분쇄 ( &lt;em&gt;즉&lt;/em&gt; 유추 형 복용, 후자와 전자의 조작 동작합니다 입력 변수를 포함하지 않음) &lt;a href=&quot;#expr&quot;&gt;을 expr&lt;/a&gt;같은 &lt;a href=&quot;types#typexpr&quot;&gt;일반 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; . 전자 오퍼레이터에 장애가 발생한 경우 후자를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e62ce70c70537475c1b181d579e82b479775978d" translate="yes" xml:space="preserve">
          <source>The fprintf function is like printf except that it takes an output channel as the first argument. The %a specifier can be useful to define custom printer (for custom types). For instance, we can create a printing template that converts an integer argument to signed decimal:</source>
          <target state="translated">fprintf 함수는 출력 채널을 첫 번째 인수로 사용한다는 점을 제외하면 printf와 같습니다. % a 지정자는 사용자 지정 프린터 (사용자 지정 유형의 경우)를 정의하는 데 유용 할 수 있습니다. 예를 들어 정수 인수를 부호있는 십진수로 변환하는 인쇄 템플릿을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d13a291c5fa3db94f06d27016206ff693957ed08" translate="yes" xml:space="preserve">
          <source>The front-end is a part of compiler-libs library. Programs that use the compiler-libs library should be built as follows:</source>
          <target state="translated">프런트 엔드는 compiler-libs 라이브러리의 일부입니다. compiler-libs 라이브러리를 사용하는 프로그램은 다음과 같이 빌드해야합니다.</target>
        </trans-unit>
        <trans-unit id="4658f7d95c6ccb485b665c4a8fd77d14df445b99" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;caml_process_pending_actions&lt;/code&gt; from &amp;lt;caml/signals.h&amp;gt; executes any pending signal handlers and finalisers, Memprof callbacks, and requested minor and major garbage collections. In particular, it can raise asynchronous exceptions. It is recommended to call it regularly at safe points inside long-running non-blocking C code.</source>
          <target state="translated">&amp;lt;caml / signals.h&amp;gt;의 &lt;code&gt;caml_process_pending_actions&lt;/code&gt; 함수는 보류중인 신호 처리기 및 종료 자, Memprof 콜백 및 요청 된 부 및 주 가비지 수집을 실행합니다. 특히 비동기 예외가 발생할 수 있습니다. 장기간 실행되는 비 차단 C 코드 내의 안전한 지점에서 정기적으로 호출하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0830c833940b33a13600b2fc8f3c6ec9ed72ba39" translate="yes" xml:space="preserve">
          <source>The function's output is specified by the following invariants:</source>
          <target state="translated">함수의 출력은 다음 불변으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="b16f05a4538c91ac60ba6969c4d9b5e686f1d91a" translate="yes" xml:space="preserve">
          <source>The functions from module &lt;a href=&quot;random.state&quot;&gt;&lt;code&gt;Random.State&lt;/code&gt;&lt;/a&gt; manipulate the current state of the random generator explicitly. This allows using one or several deterministic PRNGs, even in a multi-threaded program, without interference from other parts of the program.</source>
          <target state="translated">&lt;a href=&quot;random.state&quot;&gt; &lt;code&gt;Random.State&lt;/code&gt; &lt;/a&gt; 모듈의 함수 는 랜덤 생성기의 현재 상태를 명시 적으로 조작합니다. 이를 통해 프로그램의 다른 부분의 간섭없이 다중 스레드 프로그램에서도 하나 또는 여러 개의 결정적 PRNG를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbce52b776ac08f2366078197c98e1659ba43ad5" translate="yes" xml:space="preserve">
          <source>The functions in this module are thread safe.</source>
          <target state="translated">이 모듈의 함수는 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="511113955645abe47f0e74cfd8701cd531b7acf8" translate="yes" xml:space="preserve">
          <source>The functions in this section append binary encodings of integers to buffers.</source>
          <target state="translated">이 섹션의 함수는 정수의 이진 인코딩을 버퍼에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="735840deef678499261950948d63f843f78e8b4b" translate="yes" xml:space="preserve">
          <source>The functions in this section binary encode and decode integers to and from byte sequences.</source>
          <target state="translated">이 섹션의 함수는 바이트 시퀀스간에 정수를 인코딩하고 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="692df968d9b76de8295f62a1cc39eca74e7c54e9" translate="yes" xml:space="preserve">
          <source>The functor Client may also be redefined when some new features of the account can be given to the client.</source>
          <target state="translated">펑터 클라이언트는 계정의 일부 새로운 기능이 클라이언트에게 제공 될 수있을 때 재정의 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="23eb5fdacb362f1e019b7a5da5dbe8a3fbb9da5e" translate="yes" xml:space="preserve">
          <source>The functorial interface allows the use of specific comparison and hash functions, either for performance/security concerns, or because keys are not hashable/comparable with the polymorphic builtins.</source>
          <target state="translated">functorial 인터페이스는 성능 / 보안 문제를 위해 또는 키가 다형성 내장과 해시 / 비교할 수 없기 때문에 특정 비교 및 ​​해시 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9842cecf834f807f4e52659d4bb05e758d2b67ff" translate="yes" xml:space="preserve">
          <source>The general formatted input function</source>
          <target state="translated">일반적인 형식의 입력 함수</target>
        </trans-unit>
        <trans-unit id="39ea5439ffc8a37ae7dfd624fd6123810662e231" translate="yes" xml:space="preserve">
          <source>The generated module defines one parsing function per entry point in the grammar. These functions have the same names as the entry points. Parsing functions take as arguments a lexical analyzer (a function from lexer buffers to tokens) and a lexer buffer, and return the semantic attribute of the corresponding entry point. Lexical analyzer functions are usually generated from a lexer specification by the ocamllex program. Lexer buffers are an abstract data type implemented in the standard library module Lexing. Tokens are values from the concrete type token, defined in the interface file grammar.mli produced by ocamlyacc.</source>
          <target state="translated">생성 된 모듈은 문법의 진입 점당 하나의 구문 분석 함수를 정의합니다. 이러한 함수는 진입 점과 동일한 이름을 갖습니다. 구문 분석 함수는 어휘 분석기 (어휘 분석기에서 토큰으로의 함수)와 어휘 분석기 버퍼를 인수로 취하고 해당 진입 점의 의미 속성을 반환합니다. 어휘 분석기 함수는 일반적으로 ocamllex 프로그램에 의해 어휘 분석기 사양에서 생성됩니다. Lexer 버퍼는 표준 라이브러리 모듈 Lexing에서 구현 된 추상 데이터 유형입니다. 토큰은 ocamlyacc에서 생성 한 인터페이스 파일 grammar.mli에 정의 된 구체적인 유형 토큰의 값입니다.</target>
        </trans-unit>
        <trans-unit id="a2263e6287694d2f2d32e4219ff36b6fad805902" translate="yes" xml:space="preserve">
          <source>The generated trace files are stored using the &lt;em&gt;Common Trace Format&lt;/em&gt;, which is a general purpose binary tracing format. A complete trace consists of:</source>
          <target state="translated">생성 된 추적 파일은 범용 2 진 추적 형식 인 &lt;em&gt;Common Trace Format을&lt;/em&gt; 사용하여 저장 됩니다. 완전한 추적은 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="05828d489f6ac2387f6a65167157fb9f23021c22" translate="yes" xml:space="preserve">
          <source>The greatest representable 32-bit integer, 2&lt;sup&gt;31&lt;/sup&gt; - 1.</source>
          <target state="translated">최대 표현 가능한 32 비트 정수 2 &lt;sup&gt;31&lt;/sup&gt; - 1 사이입니다.</target>
        </trans-unit>
        <trans-unit id="a404ad0913817fcb80ea923a9800ed75493e4170" translate="yes" xml:space="preserve">
          <source>The greatest representable 64-bit integer, 2&lt;sup&gt;63&lt;/sup&gt; - 1.</source>
          <target state="translated">표현할 수있는 가장 큰 64 비트 정수, 2 &lt;sup&gt;63-1&lt;/sup&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4f471d57c7b55d66ee6fb3224ba15693e2e1e916" translate="yes" xml:space="preserve">
          <source>The greatest representable integer.</source>
          <target state="translated">표현 가능한 가장 큰 정수입니다.</target>
        </trans-unit>
        <trans-unit id="83953d60191eeb31cc3f9a4dc8dba81bf1560d9f" translate="yes" xml:space="preserve">
          <source>The greatest representable native integer, either 2&lt;sup&gt;31&lt;/sup&gt; - 1 on a 32-bit platform, or 2&lt;sup&gt;63&lt;/sup&gt; - 1 on a 64-bit platform.</source>
          <target state="translated">최대 표현 가능한 고유의 정수이고, 2 중 &lt;sup&gt;31&lt;/sup&gt; - 32 비트 플랫폼에 1 또는 2 &lt;sup&gt;63&lt;/sup&gt; - 1 64 비트 플랫폼.</target>
        </trans-unit>
        <trans-unit id="e04fd04f5b90806f4bde8e56f9e1f7c424d03265" translate="yes" xml:space="preserve">
          <source>The hash field can be set to custom_hash_default, in which case the custom block is ignored during hash computation.</source>
          <target state="translated">해시 필드는 custom_hash_default로 설정할 수 있으며,이 경우 해시 계산 중에 사용자 정의 블록이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d1bdc212a7c36c7cbf75250ae2e9cd081ccee7eb" translate="yes" xml:space="preserve">
          <source>The hash field contains a pointer to a C function that is called whenever OCaml&amp;rsquo;s generic hash operator (see module &lt;a href=&quot;libref/hashtbl&quot;&gt;Hashtbl&lt;/a&gt;) is applied to a custom block. The C function can return an arbitrary integer representing the hash value of the data contained in the given custom block. The hash value must be compatible with the compare function, in the sense that two structurally equal data (that is, two custom blocks for which compare returns 0) must have the same hash value.</source>
          <target state="translated">해시 필드는 OCaml의 일반 해시 연산자 (모듈 &lt;a href=&quot;libref/hashtbl&quot;&gt;Hashtbl&lt;/a&gt; 참조 )가 사용자 정의 블록에 적용될 때마다 호출되는 C 함수에 대한 포인터를 포함합니다 . C 함수는 주어진 사용자 지정 블록에 포함 된 데이터의 해시 값을 나타내는 임의의 정수를 반환 할 수 있습니다. 해시 값은 구조적으로 동일한 두 데이터 (즉, 비교가 0을 반환하는 두 개의 사용자 지정 블록)가 동일한 해시 값을 가져야한다는 점에서 비교 함수와 호환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3784686c2bcba80c99df973ccfa187b6dc78d6d0" translate="yes" xml:space="preserve">
          <source>The hash function for floating-point numbers.</source>
          <target state="translated">부동 소수점 숫자에 대한 해시 함수입니다.</target>
        </trans-unit>
        <trans-unit id="afd0450a8b37538d5ad7af752cb7dc24545ce1f7" translate="yes" xml:space="preserve">
          <source>The header and the trailer sections are OCaml code that is copied as is into file grammar.ml. Both sections are optional. The header goes at the beginning of the output file; it usually contains open directives and auxiliary functions required by the semantic actions of the rules. The trailer goes at the end of the output file.</source>
          <target state="translated">헤더 및 트레일러 섹션은 grammar.ml 파일에 그대로 복사되는 OCaml 코드입니다. 두 섹션 모두 선택 사항입니다. 헤더는 출력 파일의 시작 부분에 있습니다. 일반적으로 규칙의 의미 적 동작에 필요한 개방형 지시문 및 보조 기능을 포함합니다. 트레일러는 출력 파일의 끝에갑니다.</target>
        </trans-unit>
        <trans-unit id="7a49035078d6028cf4719edc4791d70f6385a46e" translate="yes" xml:space="preserve">
          <source>The header and trailer sections are arbitrary OCaml text enclosed in curly braces. Either or both can be omitted. If present, the header text is copied as is at the beginning of the output file and the trailer text at the end. Typically, the header section contains the open directives required by the actions, and possibly some auxiliary functions used in the actions.</source>
          <target state="translated">헤더 및 트레일러 섹션은 중괄호로 묶인 임의의 OCaml 텍스트입니다. 둘 중 하나 또는 둘 다 생략 할 수 있습니다. 존재하는 경우 헤더 텍스트는 출력 파일의 시작 부분에있는 그대로 복사되고 끝 부분에는 트레일러 텍스트가 복사됩니다. 일반적으로 헤더 섹션에는 작업에 필요한 개방 지시문과 작업에 사용되는 일부 보조 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="65fb09bbdabd2dfcd32a5c38a54fcbcdf3587281" translate="yes" xml:space="preserve">
          <source>The identifiers below are reserved as keywords, and cannot be employed otherwise:</source>
          <target state="translated">아래 식별자는 키워드로 예약되어 있으며 다른 방법으로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a3cdbac9abe023e77c0d5c1367f0671359c68a73" translate="yes" xml:space="preserve">
          <source>The implementation allows efficient sharing of large numerical arrays between OCaml code and C or Fortran numerical libraries.</source>
          <target state="translated">이 구현을 통해 OCaml 코드와 C 또는 Fortran 숫자 라이브러리간에 큰 숫자 배열을 효율적으로 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37db43ed15e53d861a8a0109f7b167f500eef59c" translate="yes" xml:space="preserve">
          <source>The implementation is checked against the interface file x.mli (if it exists) as described in the manual for ocamlc (chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;).</source>
          <target state="translated">구현은 ocamlc 매뉴얼 ( &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; 장)에 설명 된대로 인터페이스 파일 x.mli (존재하는 경우)에 대해 확인됩니다 .</target>
        </trans-unit>
        <trans-unit id="f0e6ef3c775c3e80317b4caf9ce4c73cd303a6bf" translate="yes" xml:space="preserve">
          <source>The include file &amp;lt;caml/bigarray.h&amp;gt; must be included in the C stub file. It declares the functions, constants and macros discussed below.</source>
          <target state="translated">포함 파일 &amp;lt;caml / bigarray.h&amp;gt;는 C 스텁 파일에 포함되어야합니다. 아래에서 설명하는 함수, 상수 및 매크로를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="535f73d31ed740bfcbb9fa46992a794cf0b8e833" translate="yes" xml:space="preserve">
          <source>The information returned by the &lt;a href=&quot;unix#VALstat&quot;&gt;&lt;code&gt;Unix.stat&lt;/code&gt;&lt;/a&gt; calls.</source>
          <target state="translated">&lt;a href=&quot;unix#VALstat&quot;&gt; &lt;code&gt;Unix.stat&lt;/code&gt; &lt;/a&gt; 호출에 의해 반환 된 정보 입니다.</target>
        </trans-unit>
        <trans-unit id="0dab77f7c802e91039a17f7a96119c9dc7d99b16" translate="yes" xml:space="preserve">
          <source>The information returned by the &lt;a href=&quot;unixlabels#VALstat&quot;&gt;&lt;code&gt;UnixLabels.stat&lt;/code&gt;&lt;/a&gt; calls.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALstat&quot;&gt; &lt;code&gt;UnixLabels.stat&lt;/code&gt; &lt;/a&gt; 호출에 의해 반환 된 정보 입니다.</target>
        </trans-unit>
        <trans-unit id="432250b262611d097e3c2e7a360d5606d16533ba" translate="yes" xml:space="preserve">
          <source>The inheritance construct inherit&lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt; provides for inclusion of methods and instance variables from other class types. The instance variable and method types from &lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt; are added into the current class type.</source>
          <target state="translated">상속 구조 상속 &lt;a href=&quot;#class-body-type&quot;&gt;클래스 본문 유형&lt;/a&gt; 은 다른 클래스 유형의 메서드 및 인스턴스 변수를 포함하도록 제공합니다. &lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt; 의 인스턴스 변수 및 메서드 유형 이 현재 클래스 유형에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="0a6f2342a82527fef9c1f1e57a822b49fe405407" translate="yes" xml:space="preserve">
          <source>The inheritance construct inherit&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; allows reusing methods and instance variables from other classes. The class expression &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; must evaluate to a class body. The instance variables, methods and initializers from this class body are added into the current class. The addition of a method will override any previously defined method of the same name.</source>
          <target state="translated">상속 구조는 &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; 상속을 통해 다른 클래스의 메서드와 인스턴스 변수를 재사용 할 수 있습니다. 클래스 표현식 &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; 은 클래스 본문으로 평가되어야합니다. 이 클래스 본문의 인스턴스 변수, 메서드 및 이니셜 라이저가 현재 클래스에 추가됩니다. 메서드를 추가하면 이전에 정의 된 동일한 이름의 메서드가 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e6a4c6ce7609b4fdb581947deed89b2c406dd7c0" translate="yes" xml:space="preserve">
          <source>The initial benefit value is then scaled by a factor that attempts to compensate for the fact that the current point in the code, if under some number of conditional branches, may be cold. (Flambda does not currently compute hot and cold paths.) The factor&amp;mdash;the estimated probability that the inliner really is on a &lt;em&gt;hot&lt;/em&gt; path&amp;mdash;is calculated as 1/(1 + f)&lt;sup&gt;d&lt;/sup&gt;, where f is set by -inline-branch-factor and d is the nesting depth of branches at the current point. As the inliner descends into more deeply-nested branches, the benefit of inlining thus lessens.</source>
          <target state="translated">초기 이익 값은 코드의 현재 지점이 일부 조건부 분기 아래에있는 경우 콜드 상태 일 수 있다는 사실을 보상하려고 시도하는 요인에 의해 조정됩니다. (Flambda는 현재 hot 및 cold 경로를 계산하지 않습니다.) 인자 (인라이너가 실제로 &lt;em&gt;핫&lt;/em&gt; 경로 에있을 것으로 예상되는 확률) 는 1 / (1 + f) &lt;sup&gt;d&lt;/sup&gt; 로 계산됩니다 . 여기서 f는 -inline-branch-에 의해 설정됩니다. factor와 d는 현재 지점에서 분기의 중첩 깊이입니다. 인라이너가 더 깊게 중첩 된 분기로 내려 가면 인라이닝의 이점이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="605d70d1e078307745dd48e9410e6df59a2d38ed" translate="yes" xml:space="preserve">
          <source>The initial size of the major heap (in words).</source>
          <target state="translated">주요 힙의 초기 크기 (단어)입니다.</target>
        </trans-unit>
        <trans-unit id="d19155151a59efc551f6b49f7c9952f00e4278ab" translate="yes" xml:space="preserve">
          <source>The inliner is directed using attributes. For non-recursive functions (and one-step unrolling of recursive functions, although @unroll is more clear for this purpose) the following are supported:</source>
          <target state="translated">인라이너는 속성을 사용하여 지시됩니다. 비 재귀 함수 (및 @unroll이이 목적을 위해 더 명확하지만 재귀 함수의 한 단계 풀기)의 경우 다음이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ec62c15f868750119abec49b24817b3f70272bf1" translate="yes" xml:space="preserve">
          <source>The inliner may discover a call site to a recursive function where something is known about the arguments: for example, they may be equal to some other variables currently in scope. In this situation it may be beneficial to &lt;em&gt;specialise&lt;/em&gt; the function to those arguments. This is done by copying the declaration of the function (and any others involved in any same mutually-recursive declaration) and noting the extra information about the arguments. The arguments augmented by this information are known as &lt;em&gt;specialised arguments&lt;/em&gt;. In order to try to ensure that specialisation is not performed uselessly, arguments are only specialised if it can be shown that they are &lt;em&gt;invariant&lt;/em&gt;: in other words, during the execution of the recursive function(s) themselves, the arguments never change.</source>
          <target state="translated">인라이너는 인수에 대해 알고있는 재귀 함수에 대한 호출 사이트를 발견 할 수 있습니다. 예를 들어 현재 범위에있는 다른 변수와 같을 수 있습니다. 이 상황에서는 해당 인수에 대한 기능을 &lt;em&gt;전문화&lt;/em&gt; 하는 것이 도움이 될 수 있습니다 . 이것은 함수의 선언 (및 동일한 상호 재귀 선언에 관련된 다른 모든 선언)을 복사하고 인수에 대한 추가 정보를 기록하여 수행됩니다. 이 정보로 보강 된 인수를 &lt;em&gt;특수 인수라고&lt;/em&gt; 합니다. 전문화가 불필요하게 수행되지 않도록하기 위해 인수는 &lt;em&gt;변하지&lt;/em&gt; 않음을 보여줄 수있는 경우에만 전문화됩니다.&lt;em&gt;&lt;/em&gt;: 즉, 재귀 함수 자체를 실행하는 동안 인수는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0c51b8b56bbf10eb40d95b1f8d06cf0bb2a8da17" translate="yes" xml:space="preserve">
          <source>The inliner will be able to consider inlining a call to a function in a first class module if it knows which particular function is going to be called. The presence of the first-class module record that wraps the set of functions in the module does not per se inhibit inlining.</source>
          <target state="translated">인라이너는 호출 될 특정 함수를 알고있는 경우 첫 번째 클래스 모듈의 함수 호출을 인라인하는 것을 고려할 수 있습니다. 모듈의 함수 집합을 래핑하는 일류 모듈 레코드가 존재한다고해서 인라인이 금지되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f97af2287565035553d926928c75a2ecba69b6f2" translate="yes" xml:space="preserve">
          <source>The inlining depth starts at zero and is increased by one every time the inliner descends into another function. It is then decreased by one every time the inliner leaves such function. If the depth exceeds the value set by -inline-max-depth then speculation stops. This parameter is intended as a general backstop for situations where the inlining threshold does not control the search sufficiently.</source>
          <target state="translated">인라이닝 깊이는 0에서 시작하여 인라이너가 다른 기능으로 내려갈 때마다 1 씩 증가합니다. 그런 다음 인라이너가 이러한 기능을 떠날 때마다 하나씩 감소합니다. 깊이가 -inline-max-depth에 의해 설정된 값을 초과하면 추측이 중지됩니다. 이 매개 변수는 인라인 임계 값이 검색을 충분히 제어하지 못하는 상황에 대한 일반적인 백스톱으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1fef85946e0fcf5a71d076de458a459e1642b8d5" translate="yes" xml:space="preserve">
          <source>The input signature of the functor &lt;a href=&quot;hashtbl.make&quot;&gt;&lt;code&gt;Hashtbl.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">펑터 &lt;a href=&quot;hashtbl.make&quot;&gt; &lt;code&gt;Hashtbl.Make&lt;/code&gt; &lt;/a&gt; 의 입력 서명 .</target>
        </trans-unit>
        <trans-unit id="06d18381a5748615e440710ac855b1a56b9c2889" translate="yes" xml:space="preserve">
          <source>The input signature of the functor &lt;a href=&quot;hashtbl.makeseeded&quot;&gt;&lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">펑터 &lt;a href=&quot;hashtbl.makeseeded&quot;&gt; &lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt; &lt;/a&gt; 의 입력 서명 .</target>
        </trans-unit>
        <trans-unit id="95c572128ac8d5e1df8128cf0a673f5f91f32169" translate="yes" xml:space="preserve">
          <source>The inside of documentation comments (**&amp;hellip;*) consists of free-form text with optional formatting annotations, followed by optional &lt;em&gt;tags&lt;/em&gt; giving more specific information about parameters, version, authors, &amp;hellip; The tags are distinguished by a leading @ character. Thus, a documentation comment has the following shape:</source>
          <target state="translated">내부 문서 주석 (**&amp;hellip; *)은 선택적 서식 주석이있는 자유 형식 텍스트와 매개 변수, 버전, 작성자에 대한보다 구체적인 정보를 제공 하는 선택적 &lt;em&gt;태그&lt;/em&gt; 로 구성됩니다 . 태그는 선행 @ 문자로 구분됩니다. 따라서 문서 주석은 다음과 같은 형태를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="148efbe2c3192ef6b3c2f5ce513345372f5ff8d7" translate="yes" xml:space="preserve">
          <source>The instance variables of a class are visible only in the body of the methods defined in the same class or a class that inherits from the class defining the instance variables. The expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; evaluates to the value of the given instance variable. The expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; assigns the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; to the instance variable &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;, which must be mutable. The whole expression &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;&amp;lt;-&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates to ().</source>
          <target state="translated">클래스의 인스턴스 변수는 동일한 클래스 또는 인스턴스 변수를 정의하는 클래스에서 상속 된 클래스에 정의 된 메서드의 본문에서만 볼 수 있습니다. &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; 표현식 은 주어진 인스턴스 변수의 값으로 평가됩니다. 발현 &lt;a href=&quot;names#inst-var-name&quot;&gt;이달-VAR-이름은&lt;/a&gt; &amp;lt;- &lt;a href=&quot;#expr&quot;&gt;EXPR의&lt;/a&gt; 양수인의 값 &lt;a href=&quot;#expr&quot;&gt;EXPR을&lt;/a&gt; 인스턴스 변수에 &lt;a href=&quot;names#inst-var-name&quot;&gt;INST-VAR-이름&lt;/a&gt; 변경 가능합니다. 전체 표현식 &lt;a href=&quot;names#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; &amp;lt; &lt;a href=&quot;#expr&quot;&gt;-expr&lt;/a&gt; 은 ()로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="1983ba3b3cbd666c6b286b10b7424eaa8d46d8e4" translate="yes" xml:space="preserve">
          <source>The instrumentation that afl-fuzz requires is not generated by default, and must be explicitly enabled, by passing the -afl-instrument option to ocamlopt.</source>
          <target state="translated">afl-fuzz에 필요한 계측은 기본적으로 생성되지 않으며 -afl-instrument 옵션을 ocamlopt에 전달하여 명시 적으로 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c38a45a391c534fde7023ac64ba050bd0bfc352" translate="yes" xml:space="preserve">
          <source>The instrumented runtime aims to provide insight into the runtime&amp;rsquo;s execution while maintaining a low overhead. However, this overhead may become more noticeable depending on how a program executes. The instrumented runtime currently puts a strong emphasis on tracing &lt;em&gt;garbage collection&lt;/em&gt; events. This means that programs with heavy garbage collection activity may be more susceptible to tracing induced performance penalties.</source>
          <target state="translated">계측 된 런타임은 낮은 오버 헤드를 유지하면서 런타임 실행에 대한 통찰력을 제공하는 것을 목표로합니다. 그러나이 오버 헤드는 프로그램 실행 방법에 따라 더 눈에 띄게 될 수 있습니다. 계측 된 런타임은 현재 &lt;em&gt;가비지 수집&lt;/em&gt; 이벤트 추적에 중점을 둡니다 . 이는 가비지 콜렉션 활동이 많은 프로그램이 성능 저하로 인한 추적에 더 취약 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c752c8999051d42387c90e33a51fa248e92151ee" translate="yes" xml:space="preserve">
          <source>The instrumented runtime can also be used with the OCaml bytecode interpreter. This can be done by either using the -runtime-variant=i flag when linking the program with ocamlc, or by running the generated bytecode through ocamlruni:</source>
          <target state="translated">계측 된 런타임은 OCaml 바이트 코드 인터프리터와 함께 사용할 수도 있습니다. 프로그램을 ocamlc와 링크 할 때 -runtime-variant = i 플래그를 사용하거나 ocamlruni를 통해 생성 된 바이트 코드를 실행하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdd8c2054ca56fa61b478da767e7a87b2d4b4462" translate="yes" xml:space="preserve">
          <source>The instrumented runtime does not support the fork system call. A child process forked from an instrumented program will not be traced.</source>
          <target state="translated">계측 된 런타임은 포크 시스템 호출을 지원하지 않습니다. 계측 된 프로그램에서 분기 된 자식 프로세스는 추적되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83cc8fe30284169270dc9bfd2599a1edfd3403c6" translate="yes" xml:space="preserve">
          <source>The integer in a &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;precision&lt;/code&gt; can also be specified as &lt;code&gt;*&lt;/code&gt;, in which case an extra integer argument is taken to specify the corresponding &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;precision&lt;/code&gt;. This integer argument precedes immediately the argument to print. For instance, &lt;code&gt;%.*f&lt;/code&gt; prints a &lt;code&gt;float&lt;/code&gt; with as many fractional digits as the value of the argument given before the float.</source>
          <target state="translated">&lt;code&gt;width&lt;/code&gt; 또는 &lt;code&gt;precision&lt;/code&gt; 의 정수는 &lt;code&gt;*&lt;/code&gt; 로 지정할 수도 있습니다 .이 경우 추가 정수 인수를 사용하여 해당 &lt;code&gt;width&lt;/code&gt; 또는 &lt;code&gt;precision&lt;/code&gt; 를 지정합니다 . 이 정수 인수는 인쇄 할 인수 바로 앞에옵니다. 예를 들어, &lt;code&gt;%.*f&lt;/code&gt; 는 &lt;code&gt;float&lt;/code&gt; 앞에 주어진 인수 값만큼 소수 자릿수 가있는 float 를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="0b15dd3f5ba2129587d0969abe183388bad06fc4" translate="yes" xml:space="preserve">
          <source>The interface of a class can also be specified in a module signature, and used to restrict the inferred signature of a module.</source>
          <target state="translated">클래스의 인터페이스는 모듈 서명에 지정 될 수 있으며 모듈의 유추 된 서명을 제한하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="105395de5f7d644b47550655e63b2ed02fcd3fdf" translate="yes" xml:space="preserve">
          <source>The keys and data of an ephemeron are said to be full if they point to a value, or empty if the value has never been set, has been unset, or was erased by the GC. In the function that accesses the keys or data these two states are represented by the &lt;code&gt;option&lt;/code&gt; type.</source>
          <target state="translated">ephemeron의 키와 데이터는 값을 가리키면 가득 차거나 값이 설정되지 않았거나 설정되지 않았거나 GC에 의해 지워진 경우 비어 있다고합니다. 키 또는 데이터에 액세스하는 기능에서이 두 상태는 &lt;code&gt;option&lt;/code&gt; 유형으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="6634b8f0a482d759792ec8ca2ac4ce6773a03e6f" translate="yes" xml:space="preserve">
          <source>The keyword as in that type binds the type variable 'a to the object type &amp;lt; .. &amp;gt;. Therefore, Oo.copy takes an object with any methods (represented by the ellipsis), and returns an object of the same type. The type of Oo.copy is different from type &amp;lt; .. &amp;gt; -&amp;gt; &amp;lt; .. &amp;gt; as each ellipsis represents a different set of methods. Ellipsis actually behaves as a type variable.</source>
          <target state="translated">해당 유형의 키워드는 유형 변수 'a를 객체 유형 &amp;lt;..&amp;gt;에 바인딩합니다. 따라서 Oo.copy는 모든 메서드 (줄임표로 표시됨)가있는 개체를 가져와 동일한 유형의 개체를 반환합니다. Oo.copy의 유형은 각 줄임표가 다른 메소드 세트를 나타내므로 &amp;lt;..&amp;gt;-&amp;gt; &amp;lt;..&amp;gt; 유형과 다릅니다. 줄임표는 실제로 유형 변수로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="26d04af0b9de3d4d2a72eb74f835f5f6f6e937e3" translate="yes" xml:space="preserve">
          <source>The keywords - and -. can appear both as infix and prefix operators. When they appear as prefix operators, they are interpreted respectively as the functions (~-) and (~-.).</source>
          <target state="translated">키워드-및-. 중위 및 접두사 연산자로 모두 나타날 수 있습니다. 접두사 연산자로 표시되면 각각 함수 (~-) 및 (~-.)로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="63ad31bd653530cc49e2890ef110e7033521237a" translate="yes" xml:space="preserve">
          <source>The kind of array elements is one of the following constants:</source>
          <target state="translated">배열 요소의 종류는 다음 상수 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="ad467b38d8db4456aa825c50933b9ea245ee8d05" translate="yes" xml:space="preserve">
          <source>The language accepts external declarations with one or two flag strings in addition to the C function&amp;rsquo;s name. These flags are reserved for the implementation of the standard library.</source>
          <target state="translated">언어는 C 함수의 이름 외에 하나 또는 두 개의 플래그 문자열이있는 외부 선언을 허용합니다. 이러한 플래그는 표준 라이브러리 구현을 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8cdc3190f510239fa37ad383f7499bbcfcecc73" translate="yes" xml:space="preserve">
          <source>The largest positive finite value of type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 유형의 가장 큰 양의 유한 값입니다 .</target>
        </trans-unit>
        <trans-unit id="9b02fd4b3ae9e22d2aa52705a920bd39b960133e" translate="yes" xml:space="preserve">
          <source>The last two entries are valid for any n &amp;gt; 3.</source>
          <target state="translated">마지막 두 항목은 n&amp;gt; 3에 대해 유효합니다.</target>
        </trans-unit>
        <trans-unit id="411f2ed0253bd263770b7a506015d3b73acb28b7" translate="yes" xml:space="preserve">
          <source>The latter is slightly more efficient, as it allows clients of the module to call directly the C function instead of going through the corresponding OCaml function. On the other hand, it should not be used in library modules if they have side-effects at toplevel, as this direct call interferes with the linker&amp;rsquo;s algorithm for removing unused modules from libraries at link-time.</source>
          <target state="translated">후자는 모듈의 클라이언트가 해당 OCaml 함수를 거치지 않고 C 함수를 직접 호출 할 수 있도록하므로 약간 더 효율적입니다. 반면에 최상위 수준에서 부작용이있는 경우 라이브러리 모듈에서 사용해서는 안됩니다.이 직접 호출은 링크 타임에 라이브러리에서 사용하지 않는 모듈을 제거하는 링커의 알고리즘을 방해하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e0d5230f60bcbec268122dc0a17e6710399bb6df" translate="yes" xml:space="preserve">
          <source>The lazy expression lazy_expr is forced only if the lazy_guard value yields true once computed. Indeed, a simple wildcard pattern (not lazy) never forces the lazy expression&amp;rsquo;s evaluation. However, a pattern with keyword lazy, even if it is wildcard, always forces the evaluation of the deferred computation.</source>
          <target state="translated">lazy 표현식 lazy_expr은 lazy_guard 값이 계산 된 후 true를 산출하는 경우에만 강제됩니다. 사실, 단순한 와일드 카드 패턴 (지연이 아님)은 결코 게으른 식의 평가를 강제하지 않습니다. 그러나 lazy 키워드가있는 패턴은 와일드 카드 인 경우에도 항상 지연된 계산을 강제로 평가합니다.</target>
        </trans-unit>
        <trans-unit id="cfa4f4b740be36ff7f795509d500d37f7af78f8b" translate="yes" xml:space="preserve">
          <source>The legacy bigarray library bundled with the compiler is a compatibility library with exactly the same interface as before, i.e. with map_file included.</source>
          <target state="translated">컴파일러와 함께 번들로 제공되는 레거시 bigarray 라이브러리는 이전과 정확히 동일한 인터페이스, 즉 map_file이 포함 된 호환성 라이브러리입니다.</target>
        </trans-unit>
        <trans-unit id="3c3cccf18cbaa6ce05baa77a874dea7a1d1ade41" translate="yes" xml:space="preserve">
          <source>The let and let rec constructs bind value names locally, as for the core language expressions.</source>
          <target state="translated">let 및 let rec는 핵심 언어 표현식과 같이 로컬로 값 이름을 바인드합니다.</target>
        </trans-unit>
        <trans-unit id="a230275b7985703b310f49dd04772a11ba7b81ae" translate="yes" xml:space="preserve">
          <source>The let and letrec constructs bind value names locally. The construct</source>
          <target state="translated">let 및 letrec는 값 이름을 로컬로 바인딩합니다. 구조</target>
        </trans-unit>
        <trans-unit id="4a7c897adf765ad531b54431abd748cbea11f170" translate="yes" xml:space="preserve">
          <source>The list is not empty.</source>
          <target state="translated">목록이 비어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e80da8bc0045d539fc55b1771c12707e1366c643" translate="yes" xml:space="preserve">
          <source>The list of options, each followed by the corresponding &lt;code&gt;doc&lt;/code&gt; string. Beware: options that have an empty &lt;code&gt;doc&lt;/code&gt; string will not be included in the list.</source>
          <target state="translated">옵션 목록. 각각 뒤에 해당하는 &lt;code&gt;doc&lt;/code&gt; 문자열 이옵니다 . 주의 : 빈 &lt;code&gt;doc&lt;/code&gt; 문자열이 있는 옵션 은 목록에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37a09eb76bbb9dc4b8871dbc8586b6f3b99c21f6" translate="yes" xml:space="preserve">
          <source>The list of possible syntactic class is as follows:</source>
          <target state="translated">가능한 구문 클래스 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7119efad1f349c18d670dab6d20261e060049541" translate="yes" xml:space="preserve">
          <source>The loadingmode variable controls how the program is executed.</source>
          <target state="translated">loadingmode 변수는 프로그램 실행 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="15f3b2280a23c9730e0ae9df7fd26ba354827556" translate="yes" xml:space="preserve">
          <source>The macros CAMLlocal1 to CAMLlocal5 declare and initialize one to five local variables of type value. The variable names are given as arguments to the macros. CAMLlocalN(x, n) declares and initializes a local variable of type value [n]. You can use several calls to these macros if you have more than 5 local variables.</source>
          <target state="translated">CAMLlocal1 ~ CAMLlocal5 매크로는 값 유형의 1 ~ 5 개의 지역 변수를 선언하고 초기화합니다. 변수 이름은 매크로에 대한 인수로 제공됩니다. CAMLlocalN (x, n)은 값 [n] 유형의 지역 변수를 선언하고 초기화합니다. 5 개 이상의 지역 변수가있는 경우 이러한 매크로에 대한 여러 호출을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1aaef768b1af4841714c0865edff6a7e10553a66" translate="yes" xml:space="preserve">
          <source>The macros CAMLreturn, CAMLreturn0, and CAMLreturnT are used to replace the C keyword return. Every occurrence of return x must be replaced by CAMLreturn (x) if x has type value, or CAMLreturnT (t, x) (where t is the type of x); every occurrence of return without argument must be replaced by CAMLreturn0. If your C function is a procedure (i.e. if it returns void), you must insert CAMLreturn0 at the end (to replace C&amp;rsquo;s implicit return).</source>
          <target state="translated">CAMLreturn, CAMLreturn0 및 CAMLreturnT 매크로는 C 키워드 return을 대체하는 데 사용됩니다. return x의 모든 항목은 x에 유형 값이있는 경우 CAMLreturn (x) 또는 CAMLreturnT (t, x) (여기서 t는 x 유형)로 대체되어야합니다. 인수없이 반환되는 모든 항목은 CAMLreturn0으로 대체되어야합니다. C 함수가 프로 시저이면 (즉, void를 반환하는 경우) 끝에 CAMLreturn0을 삽입해야합니다 (C의 암시 적 반환을 대체하기 위해).</target>
        </trans-unit>
        <trans-unit id="885b3218ec0a809028025c650e9f6b490326927a" translate="yes" xml:space="preserve">
          <source>The main advantage of dynamic linking is that it preserves the platform-independence of bytecode executables. That is, the bytecode executable contains no machine code, and can therefore be compiled on platform A and executed on other platforms B, C, &amp;hellip;, as long as the required shared libraries are available on all these platforms. In contrast, executables generated by ocamlc -custom run only on the platform on which they were created, because they embark a custom-tailored runtime system specific to that platform. In addition, dynamic linking results in smaller executables.</source>
          <target state="translated">동적 연결의 주요 장점은 바이트 코드 실행 파일의 플랫폼 독립성을 유지한다는 것입니다. 즉, 바이트 코드 실행 파일에는 기계 코드가 포함되어 있지 않으므로 이러한 모든 플랫폼에서 필요한 공유 라이브러리를 사용할 수있는 한 플랫폼 A에서 컴파일하고 다른 플랫폼 B, C,&amp;hellip;에서 실행할 수 있습니다. 반대로, ocamlc -custom에 의해 생성 된 실행 파일은 해당 플랫폼에 특정한 맞춤형 런타임 시스템을 시작하기 때문에 생성 된 플랫폼에서만 실행됩니다. 또한 동적 연결로 인해 실행 파일이 작아집니다.</target>
        </trans-unit>
        <trans-unit id="31c9f9893f98dd3b2cb21409e3d29c4b1dc69b68" translate="yes" xml:space="preserve">
          <source>The main differences between 'Bigarrays' and standard OCaml arrays are as follows:</source>
          <target state="translated">'Bigarrays'와 표준 OCaml 배열의 주요 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6fcf71e83dbbe5bf7b82af138897c5021410d4ef" translate="yes" xml:space="preserve">
          <source>The major GC speed is computed from this parameter. This is the memory that will be &quot;wasted&quot; because the GC does not immediately collect unreachable blocks. It is expressed as a percentage of the memory used for live data. The GC will work more (use more CPU time and collect blocks more eagerly) if &lt;code&gt;space_overhead&lt;/code&gt; is smaller. Default: 80.</source>
          <target state="translated">주요 GC 속도는이 매개 변수에서 계산됩니다. 이것은 GC가 도달 할 수없는 블록을 즉시 수집하지 않기 때문에 &quot;낭비&quot;될 메모리입니다. 라이브 데이터에 사용되는 메모리의 백분율로 표시됩니다. GC는 &lt;code&gt;space_overhead&lt;/code&gt; 가 작 으면 더 많이 작동합니다 (더 많은 CPU 시간을 사용하고 블록을 더 열심히 수집) . 기본값 : 80.</target>
        </trans-unit>
        <trans-unit id="30da6783cb2d914f60ad876ac28283601a269030" translate="yes" xml:space="preserve">
          <source>The maximum depth of any speculative inlining search. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;.</source>
          <target state="translated">추측 인라인 검색의 최대 깊이입니다. 섹션 &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="14b6f2abfdc332a11cef59acff883ca20f69b025" translate="yes" xml:space="preserve">
          <source>The maximum depth of any unrolling of recursive functions during any speculative inlining search. See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;.</source>
          <target state="translated">추측 인라인 검색 중 재귀 함수 풀기의 최대 깊이입니다. 섹션 &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6537d7fb4312afbfc14faa7b11bce9479277bccc" translate="yes" xml:space="preserve">
          <source>The maximum formatting depth is the maximum number of pretty-printing boxes simultaneously open.</source>
          <target state="translated">최대 서식 깊이는 동시에 열리는 예쁜 인쇄 상자의 최대 수입니다.</target>
        </trans-unit>
        <trans-unit id="fa16112992d556366d6be6ead64cb5e2ddc5d021" translate="yes" xml:space="preserve">
          <source>The maximum size of the stack (in words). This is only relevant to the byte-code runtime, as the native code runtime uses the operating system's stack. Default: 1024k.</source>
          <target state="translated">스택의 최대 크기 (단어)입니다. 네이티브 코드 런타임은 운영 체제의 스택을 사용하므로 이는 바이트 코드 런타임에만 관련됩니다. 기본값 : 1024k.</target>
        </trans-unit>
        <trans-unit id="3dcda863ccacea505bd2a294ce1ed4f2df1932a4" translate="yes" xml:space="preserve">
          <source>The meaning of format string type parameters is as follows:</source>
          <target state="translated">형식 문자열 유형 매개 변수의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="290889214c915b5911f3b92719bce41512c0c609" translate="yes" xml:space="preserve">
          <source>The memory layout of Bigarrays is entirely compatible with that of arrays in C and Fortran, allowing large arrays to be passed back and forth between OCaml code and C / Fortran code with no data copying at all.</source>
          <target state="translated">Bigarrays의 메모리 레이아웃은 C 및 Fortran의 배열과 완전히 호환되므로 데이터 복사없이 OCaml 코드와 C / Fortran 코드간에 큰 배열을 앞뒤로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db529abafebd1568315a8328ddaf314170689aa7" translate="yes" xml:space="preserve">
          <source>The memory management counters are returned in a &lt;code&gt;stat&lt;/code&gt; record.</source>
          <target state="translated">메모리 관리 카운터는 &lt;code&gt;stat&lt;/code&gt; 레코드 로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="c4a3b03ef777eb26c6ae028dd5d106d607d702a8" translate="yes" xml:space="preserve">
          <source>The metadata file is available in the OCaml installation. Its location can be obtained using the following command:</source>
          <target state="translated">메타 데이터 파일은 OCaml 설치에서 사용할 수 있습니다. 다음 명령을 사용하여 해당 위치를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e072a2bbaafe77d3313822b37614800d154b59ef" translate="yes" xml:space="preserve">
          <source>The module &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; provides formatted input functions or &lt;em&gt;scanners&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt; 모듈 은 형식화 된 입력 함수 또는 &lt;em&gt;스캐너를&lt;/em&gt; 제공 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="98dc8a81338816e727b183ae8835ac70814be748" translate="yes" xml:space="preserve">
          <source>The module type expression functor(&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;)-&amp;gt;&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is the type of functors (functions from modules to modules) that take as argument a module of type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and return as result a module of type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. The module type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; can use the name &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; to refer to type components of the actual argument of the functor. If the type &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; does not depend on type components of &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;, the module type expression can be simplified with the alternative short syntax &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; . No restrictions are placed on the type of the functor argument; in particular, a functor may take another functor as argument (&amp;ldquo;higher-order&amp;rdquo; functor).</source>
          <target state="translated">모듈 유형 표현식 functor ( &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; : &lt;a href=&quot;#module-type&quot;&gt;module-type &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; )-&amp;gt; &lt;a href=&quot;#module-type&quot;&gt;module-type &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 는 &lt;a href=&quot;#module-type&quot;&gt;module-type &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 유형의 모듈을 인수로 취하고 결과로 반환 하는 펑터 (모듈에서 모듈로의 함수) 유형입니다 . module &lt;a href=&quot;#module-type&quot;&gt;-type &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 유형의 모듈 . 모듈 유형 &lt;a href=&quot;#module-type&quot;&gt;module-type &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 는 펑터의 실제 인수의 유형 구성 요소를 참조하기 위해 이름 &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; 을 사용할 수 있습니다 . 형태의 경우 &lt;a href=&quot;#module-type&quot;&gt;모듈 형 &lt;/a&gt;&lt;sub&gt;(2)&lt;/sub&gt; 의 입력 요소에 의존하지 않는 &lt;a href=&quot;names#module-name&quot;&gt;모듈 이름&lt;/a&gt; , 모듈 형 발현 대체 짧은 구문으로 단순화 될 수있다&lt;a href=&quot;#module-type&quot;&gt;모듈 유형 &lt;/a&gt;&lt;sub&gt;1-&lt;/sub&gt; &amp;gt; &lt;a href=&quot;#module-type&quot;&gt;모듈 유형 &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; . functor 인수의 유형에는 제한이 없습니다. 특히, 펑 터는 다른 펑터를 인수로 취할 수 있습니다 ( &quot;고차&quot;펑터).</target>
        </trans-unit>
        <trans-unit id="19e87897038acb2ea0b22d40eb32fcf01d0bb4bf" translate="yes" xml:space="preserve">
          <source>The most common usage of variant types is to describe recursive data structures. Consider for example the type of binary trees:</source>
          <target state="translated">변형 유형의 가장 일반적인 용도는 재귀 데이터 구조를 설명하는 것입니다. 예를 들어 이진 트리 유형을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="969c39463cdd83094435d7ff5442eba358f5bbab" translate="yes" xml:space="preserve">
          <source>The most user-friendly way to use the debugger is to run it under Emacs. See the file emacs/README in the distribution for information on how to load the Emacs Lisp files for OCaml support.</source>
          <target state="translated">디버거를 사용하는 가장 사용자 친화적 인 방법은 Emacs에서 실행하는 것입니다. OCaml 지원을 위해 Emacs Lisp 파일을로드하는 방법에 대한 정보는 배포판의 emacs / README 파일을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="78aad986fb7a4eb2c56f1239f1a0ea9f7c757987" translate="yes" xml:space="preserve">
          <source>The motivation is that, by letting &amp;lsquo;ocamlopt&amp;lsquo; deal with boxing, it can often decide to suppress it entirely.</source>
          <target state="translated">동기 부여는 'ocamlopt'가 권투를 처리하도록함으로써 종종 그것을 완전히 억제하기로 결정할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e080b5bf8fc37b589b95288dd439c400c34b427b" translate="yes" xml:space="preserve">
          <source>The multiplier is k, M, or G, for multiplication by 2&lt;sup&gt;10&lt;/sup&gt;, 2&lt;sup&gt;20&lt;/sup&gt;, and 2&lt;sup&gt;30&lt;/sup&gt; respectively.</source>
          <target state="translated">곱셈기는 각각 2 &lt;sup&gt;10&lt;/sup&gt; , 2 &lt;sup&gt;20&lt;/sup&gt; , 2 &lt;sup&gt;30&lt;/sup&gt; 곱하기 k, M 또는 G 입니다.</target>
        </trans-unit>
        <trans-unit id="e5001d83b2b93aa689b354ed2086458f2935a047" translate="yes" xml:space="preserve">
          <source>The name of the file containing the executable currently running.</source>
          <target state="translated">현재 실행중인 실행 파일이 포함 된 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="59eca0c39d17cb0f2108d6d77b193b119b04559b" translate="yes" xml:space="preserve">
          <source>The name of the file containing the executable currently running. This name may be absolute or relative to the current directory, depending on the platform and whether the program was compiled to bytecode or a native executable.</source>
          <target state="translated">현재 실행중인 실행 파일이 포함 된 파일의 이름입니다. 이 이름은 플랫폼 및 프로그램이 바이트 코드 또는 원시 실행 파일로 컴파일되었는지 여부에 따라 현재 디렉토리에 대해 절대적이거나 상대적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf0030b90670a18e3de17304172d5e4c928be425" translate="yes" xml:space="preserve">
          <source>The name of the initial temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set.</source>
          <target state="translated">초기 임시 디렉토리의 이름 : Unix에서 &lt;code&gt;TMPDIR&lt;/code&gt; 환경 변수 의 값 또는 변수가 설정되지 않은 경우 &quot;/ tmp&quot;.</target>
        </trans-unit>
        <trans-unit id="7c8b8d9700396ab187abf8b0e62dcd1c6f319473" translate="yes" xml:space="preserve">
          <source>The name of the initial temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set. Under Windows, the value of the &lt;code&gt;TEMP&lt;/code&gt; environment variable, or &quot;.&quot; if the variable is not set.</source>
          <target state="translated">초기 임시 디렉토리의 이름 : Unix에서 &lt;code&gt;TMPDIR&lt;/code&gt; 환경 변수 의 값 또는 변수가 설정되지 않은 경우 &quot;/ tmp&quot;. Windows에서 &lt;code&gt;TEMP&lt;/code&gt; 환경 변수 의 값 또는 &quot;.&quot; 변수가 설정되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="3c9a52823f32936b8fa5faaa814adee980e5c3ce" translate="yes" xml:space="preserve">
          <source>The name of the temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set.</source>
          <target state="translated">임시 디렉토리의 이름 : Unix에서 &lt;code&gt;TMPDIR&lt;/code&gt; 환경 변수 의 값 또는 변수가 설정되지 않은 경우 &quot;/ tmp&quot;.</target>
        </trans-unit>
        <trans-unit id="bd4c9b92bb5cafc665608d7e7c71ee74b72bd3e4" translate="yes" xml:space="preserve">
          <source>The name of the temporary directory: Under Unix, the value of the &lt;code&gt;TMPDIR&lt;/code&gt; environment variable, or &quot;/tmp&quot; if the variable is not set. Under Windows, the value of the &lt;code&gt;TEMP&lt;/code&gt; environment variable, or &quot;.&quot; if the variable is not set. The temporary directory can be changed with &lt;a href=&quot;filename#VALset_temp_dir_name&quot;&gt;&lt;code&gt;Filename.set_temp_dir_name&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">임시 디렉토리의 이름 : Unix에서 &lt;code&gt;TMPDIR&lt;/code&gt; 환경 변수 의 값 또는 변수가 설정되지 않은 경우 &quot;/ tmp&quot;. Windows에서 &lt;code&gt;TEMP&lt;/code&gt; 환경 변수 의 값 또는 &quot;.&quot; 변수가 설정되지 않은 경우. 임시 디렉토리는 &lt;a href=&quot;filename#VALset_temp_dir_name&quot;&gt; &lt;code&gt;Filename.set_temp_dir_name&lt;/code&gt; &lt;/a&gt; 으로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80a92c6fec8ac40ba4e0c4025b59dde0b751953a" translate="yes" xml:space="preserve">
          <source>The named file could not be found in the current directory, nor in the directories of the search path.</source>
          <target state="translated">이름이 지정된 파일을 현재 디렉토리 나 검색 경로의 디렉토리에서 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="952b3090c265f73e61fb891aab443a8262a5704d" translate="yes" xml:space="preserve">
          <source>The named file could not be found in the current directory, nor in the directories of the search path. The filename is either a compiled interface file (.cmi file), or a compiled bytecode file (.cmo file). If filename has the format mod.cmi, this means you are trying to compile a file that references identifiers from module mod, but you have not yet compiled an interface for module mod. Fix: compile mod.mli or mod.ml first, to create the compiled interface mod.cmi.</source>
          <target state="translated">이름이 지정된 파일을 현재 디렉토리 나 검색 경로의 디렉토리에서 찾을 수 없습니다. 파일 이름은 컴파일 된 인터페이스 파일 (.cmi 파일) 또는 컴파일 된 바이트 코드 파일 (.cmo 파일)입니다. filename의 형식이 mod.cmi 인 경우 이는 모듈 mod의 식별자를 참조하는 파일을 컴파일하려고하지만 모듈 mod에 대한 인터페이스를 아직 컴파일하지 않았 음을 의미합니다. 수정 : mod.mli 또는 mod.ml을 먼저 컴파일하여 컴파일 된 인터페이스 mod.cmi를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a2f02d60d1e116f8243f8229b3fd568a95c8a809" translate="yes" xml:space="preserve">
          <source>The names of the entry points must be valid identifiers for OCaml values (starting with a lowercase letter). Similarly, the arguments arg&lt;sub&gt;1&lt;/sub&gt;&amp;hellip; arg&lt;sub&gt;n&lt;/sub&gt; must be valid identifiers for OCaml. Each entry point becomes an OCaml function that takes n+1 arguments, the extra implicit last argument being of type Lexing.lexbuf. Characters are read from the Lexing.lexbuf argument and matched against the regular expressions provided in the rule, until a prefix of the input matches one of the rule. The corresponding action is then evaluated and returned as the result of the function.</source>
          <target state="translated">진입 점의 이름은 OCaml 값에 대한 유효한 식별자 여야합니다 (소문자로 시작). 마찬가지로 인수 arg &lt;sub&gt;1&lt;/sub&gt; &amp;hellip; arg &lt;sub&gt;n&lt;/sub&gt; 은 OCaml에 대한 유효한 식별자 여야합니다. 각 진입 점은 n + 1 인수를받는 OCaml 함수가되며 추가 암시 적 마지막 인수는 Lexing.lexbuf 유형입니다. Lexing.lexbuf 인수에서 문자를 읽어 입력 접두사가 규칙 중 하나와 일치 할 때까지 규칙에 제공된 정규식과 일치합니다. 그런 다음 해당 작업이 평가되고 함수의 결과로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a5ca4780e331ea88692f3bab8f908b1e857d3545" translate="yes" xml:space="preserve">
          <source>The names of the two C functions must be given in the primitive declaration, as follows:</source>
          <target state="translated">두 C 함수의 이름은 다음과 같이 기본 선언에 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2af38c50738eb4e1ac67f27fb83521c12f9da713" translate="yes" xml:space="preserve">
          <source>The native C character type under Windows is WCHAR, two bytes wide, while under Unix it is char, one byte wide. A type char_os is defined in &amp;lt;caml/misc.h&amp;gt; that stands for the concrete C character type of each platform. Strings in the platform encoding are of type char_os *.</source>
          <target state="translated">Windows에서 기본 C 문자 유형은 WCHAR (2 바이트 너비)이고 Unix에서는 char (1 바이트 너비)입니다. char_os 유형은 각 플랫폼의 구체적인 C 문자 유형을 나타내는 &amp;lt;caml / misc.h&amp;gt;에 정의되어 있습니다. 플랫폼 인코딩의 문자열은 char_os * 유형입니다.</target>
        </trans-unit>
        <trans-unit id="376053bbccd9cdcd8890b3fbdf88ead49637bae1" translate="yes" xml:space="preserve">
          <source>The native integer -1.</source>
          <target state="translated">기본 정수 -1입니다.</target>
        </trans-unit>
        <trans-unit id="9ee1fc5518ff6fbf2992ed7e1ec40186e53f6653" translate="yes" xml:space="preserve">
          <source>The native integer 0.</source>
          <target state="translated">기본 정수 0입니다.</target>
        </trans-unit>
        <trans-unit id="4bcc40875771e327d2f0e7c0fa203d846f93e6b4" translate="yes" xml:space="preserve">
          <source>The native integer 1.</source>
          <target state="translated">기본 정수 1입니다.</target>
        </trans-unit>
        <trans-unit id="5c20da3e1fe2cd472edcbc03735391872edbfb80" translate="yes" xml:space="preserve">
          <source>The native-code compiler is only available on certain platforms. It produces code that runs faster than the bytecode produced by ocamlc, at the cost of increased compilation time and executable code size. Compatibility with the bytecode compiler is extremely high: the same source code should run identically when compiled with ocamlc and ocamlopt.</source>
          <target state="translated">네이티브 코드 컴파일러는 특정 플랫폼에서만 사용할 수 있습니다. 컴파일 시간과 실행 코드 크기가 늘어나는 대신 ocamlc가 생성 한 바이트 코드보다 빠르게 실행되는 코드를 생성합니다. 바이트 코드 컴파일러와의 호환성은 매우 높습니다. ocamlc 및 ocamlopt로 컴파일 할 때 동일한 소스 코드가 동일하게 실행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5e5e7155dfdf15208a1cbe9f526ab06c992a1a3c" translate="yes" xml:space="preserve">
          <source>The native-code compiler ocamlopt also supports the -output-obj option, causing it to output a C object file or a shared library containing the native code for all OCaml modules on the command-line, as well as the OCaml startup code. Initialization is performed by calling caml_startup (or caml_startup_exn) as in the case of the bytecode compiler.</source>
          <target state="translated">네이티브 코드 컴파일러 ocamlopt는 또한 -output-obj 옵션을 지원하여 C 개체 파일 또는 명령 줄의 모든 OCaml 모듈에 대한 네이티브 코드와 OCaml 시작 코드를 포함하는 공유 라이브러리를 출력합니다. 초기화는 바이트 코드 컴파일러의 경우와 같이 caml_startup (또는 caml_startup_exn)을 호출하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="36be14bc239e78c132c193d0ff0e16beb22b0661" translate="yes" xml:space="preserve">
          <source>The native-code compiler performs a number of optimizations that the bytecode compiler does not perform, especially when the Flambda optimizer is active. In particular, the native-code compiler identifies and eliminates &amp;ldquo;dead code&amp;rdquo;, i.e. computations that do not contribute to the results of the program. For example,</source>
          <target state="translated">네이티브 코드 컴파일러는 특히 Flambda 최적화 프로그램이 활성화 된 경우 바이트 코드 컴파일러가 수행하지 않는 여러 최적화를 수행합니다. 특히, 네이티브 코드 컴파일러는 &quot;데드 코드&quot;, 즉 프로그램 결과에 기여하지 않는 계산을 식별하고 제거합니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="f90676a471e21697a3a109feb2073705f4c086a3" translate="yes" xml:space="preserve">
          <source>The next allocation can trigger a garbage collection. The garbage collector assumes that all structured blocks contain well-formed values. Newly created blocks contain random data, which generally do not represent well-formed values.</source>
          <target state="translated">다음 할당은 가비지 수집을 트리거 할 수 있습니다. 가비지 수집기는 모든 구조화 된 블록에 올바른 형식의 값이 포함되어 있다고 가정합니다. 새로 생성 된 블록에는 일반적으로 올바른 형식의 값을 나타내지 않는 임의의 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="33f94342d426b6ca7b5a6cd5848192a5418df90c" translate="yes" xml:space="preserve">
          <source>The next step is to compile and link the program with the instrumented runtime. This can be done by using the -runtime-variant flag:</source>
          <target state="translated">다음 단계는 프로그램을 컴파일하고 인스트루먼트 된 런타임과 연결하는 것입니다. -runtime-variant 플래그를 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbe1c650255dd39febc517d8d6e9ecf4a27a4e50" translate="yes" xml:space="preserve">
          <source>The notion of input channel for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module: those channels provide all the machinery necessary to read from any source of characters, including a &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt;&lt;code&gt;in_channel&lt;/code&gt;&lt;/a&gt; value.</source>
          <target state="translated">&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt; 모듈 의 입력 채널 개념 : 이러한 채널은 &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt; &lt;code&gt;in_channel&lt;/code&gt; &lt;/a&gt; 값을 포함하여 모든 문자 소스에서 읽는 데 필요한 모든 기계를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="16542651eb8af79575740dab6d97e5baeedd8889" translate="yes" xml:space="preserve">
          <source>The notion of input channel for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module: those channels provide all the machinery necessary to read from any source of characters, including a &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt;&lt;code&gt;in_channel&lt;/code&gt;&lt;/a&gt; value. A Scanf.Scanning.in_channel value is also called a</source>
          <target state="translated">&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt; 모듈 의 입력 채널 개념 : 이러한 채널은 &lt;a href=&quot;stdlib#TYPEin_channel&quot;&gt; &lt;code&gt;in_channel&lt;/code&gt; &lt;/a&gt; 값을 포함하여 모든 문자 소스에서 읽는 데 필요한 모든 기계를 제공합니다 . Scanf.Scanning.in_channel 값은</target>
        </trans-unit>
        <trans-unit id="dc0369bec5d64b7e5ca44539b36eca9c14402a44" translate="yes" xml:space="preserve">
          <source>The num library implements integer arithmetic and rational arithmetic in arbitrary precision. It was split off the core OCaml distribution starting with the 4.06.0 release, and can now be found at &lt;a href=&quot;https://github.com/ocaml/num&quot;&gt;https://github.com/ocaml/num&lt;/a&gt;.</source>
          <target state="translated">num 라이브러리는 정수 산술 및 유리 산술을 임의 정밀도로 구현합니다. 4.06.0 릴리스부터 핵심 OCaml 배포판에서 분리되었으며 이제 &lt;a href=&quot;https://github.com/ocaml/num&quot;&gt;https://github.com/ocaml/num&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0976e8b95aee4f6b6b94a903578443416a16fd1d" translate="yes" xml:space="preserve">
          <source>The number of samples in this block (&amp;gt;= 1).</source>
          <target state="translated">이 블록의 샘플 수 (&amp;gt; = 1).</target>
        </trans-unit>
        <trans-unit id="80c5921664757a5de49c34516dd5a9044bf527fa" translate="yes" xml:space="preserve">
          <source>The object type c0 is an abbreviation for &amp;lt;m : 'a; n : int&amp;gt; as 'a. Consider now the type declaration:</source>
          <target state="translated">객체 유형 c0은 &amp;lt;m : 'a; n : int&amp;gt; as 'a. 이제 유형 선언을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c4798644a1b3b83b3464a016d6b7ad72bf5f4632" translate="yes" xml:space="preserve">
          <source>The object type c1 is an abbreviation for the type &amp;lt;m : 'a&amp;gt; as 'a. The coercion from an object of type c0 to an object of type c1 is correct:</source>
          <target state="translated">객체 유형 c1은 'a'와 같은 유형 &amp;lt;m : 'a&amp;gt;의 약어입니다. c0 유형의 객체에서 c1 유형의 객체로의 강제 변환이 올 바릅니다.</target>
        </trans-unit>
        <trans-unit id="4e56b5bcc7c0be28d1a5ad641e4581f9a06b6925" translate="yes" xml:space="preserve">
          <source>The ocaml.alert or alert attribute serves two purposes: (i) to mark component with an alert to be triggered when the component is referenced, and (ii) to control which alert names are enabled. In the first form, the attribute takes an identifier possibly followed by a message. Here is an example of a value declaration marked with an alert:</source>
          <target state="translated">ocaml.alert 또는 alert 속성은 (i) 구성 요소가 참조 될 때 트리거 될 경고로 구성 요소를 표시하고 (ii) 활성화되는 경고 이름을 제어하는 ​​두 가지 용도로 사용됩니다. 첫 번째 형식에서 속성은 식별자 뒤에 메시지가 올 수 있습니다. 다음은 경고로 표시된 값 선언의 예입니다.</target>
        </trans-unit>
        <trans-unit id="663c4b2feb0ff61316e473a7d7058b8a8ac77602" translate="yes" xml:space="preserve">
          <source>The ocamlc command has a command-line interface similar to the one of most C compilers. It accepts several types of arguments and processes them sequentially, after all options have been processed:</source>
          <target state="translated">ocamlc 명령에는 대부분의 C 컴파일러 중 하나와 유사한 명령 줄 인터페이스가 있습니다. 여러 유형의 인수를 허용하고 모든 옵션이 처리 된 후 순차적으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8ccd15521b1aa9660fdf126df14cf7897ed7444c" translate="yes" xml:space="preserve">
          <source>The ocamlcp and ocamloptp commands also accept all the options of the corresponding ocamlc or ocamlopt compiler, except the -pp (preprocessing) option.</source>
          <target state="translated">ocamlcp 및 ocamloptp 명령은 -pp (전처리) 옵션을 제외하고 해당 ocamlc 또는 ocamlopt 컴파일러의 모든 옵션도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="fa91a0c172cde52b6822b93be7514538cd75d072" translate="yes" xml:space="preserve">
          <source>The ocamldep command scans a set of OCaml source files (.ml and .mli files) for references to external compilation units, and outputs dependency lines in a format suitable for the make utility. This ensures that make will compile the source files in the correct order, and recompile those files that need to when a source file is modified.</source>
          <target state="translated">ocamldep 명령은 외부 컴파일 단위에 대한 참조를 위해 OCaml 소스 파일 (.ml 및 .mli 파일) 세트를 스캔하고 make 유틸리티에 적합한 형식으로 종속성 행을 출력합니다. 이렇게하면 make가 소스 파일을 올바른 순서로 컴파일하고 소스 파일이 수정 될 때 필요한 파일을 다시 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="5bc0cf38a6832c2cb08c4085b324377b241b03c6" translate="yes" xml:space="preserve">
          <source>The ocamllex command produces a lexical analyzer from a set of regular expressions with attached semantic actions, in the style of lex. Assuming the input file is lexer.mll, executing</source>
          <target state="translated">ocamllex 명령은 lex 스타일의 시맨틱 조치가 첨부 된 정규 표현식 세트에서 어휘 분석기를 생성합니다. 입력 파일이 lexer.mll이라고 가정하고 다음을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="785a09dfb0b7bb6413c4e50f2cabd1b69c63c6b4" translate="yes" xml:space="preserve">
          <source>The ocamlmklib command facilitates the construction of libraries containing both OCaml code and C code, and usable both in static linking and dynamic linking modes. This command is available under Windows since Objective Caml 3.11 and under other operating systems since Objective Caml 3.03.</source>
          <target state="translated">ocamlmklib 명령은 OCaml 코드와 C 코드를 모두 포함하는 라이브러리의 구성을 용이하게하며 정적 링크 및 동적 링크 모드 모두에서 사용할 수 있습니다. 이 명령은 Objective Caml 3.11 이후의 Windows 및 Objective Caml 3.03 이후의 다른 운영 체제에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37782ee3b2232fe93bbe77ca370d4160e2021dd2" translate="yes" xml:space="preserve">
          <source>The ocamlmklib command takes three kinds of arguments:</source>
          <target state="translated">ocamlmklib 명령은 세 가지 종류의 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="68dd5d1772fdc70b18042e2faf73bb6d263b83ef" translate="yes" xml:space="preserve">
          <source>The ocamlmktop command builds OCaml toplevels that contain user code preloaded at start-up.</source>
          <target state="translated">ocamlmktop 명령은 시작시 미리로드 된 사용자 코드를 포함하는 OCaml 최상위 레벨을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="6831997e14580584458639904bb3e8b4303221cf" translate="yes" xml:space="preserve">
          <source>The ocamlmktop command takes as argument a set of .cmo and .cma files, and links them with the object files that implement the OCaml toplevel. The typical use is:</source>
          <target state="translated">ocamlmktop 명령은 .cmo 및 .cma 파일 집합을 인수로 사용하여 OCaml 최상위 수준을 구현하는 개체 파일과 연결합니다. 일반적인 용도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab3cce8e0848dae6978b901dc63aa4ea6c79e945" translate="yes" xml:space="preserve">
          <source>The ocamlopt command has a command-line interface very close to that of ocamlc. It accepts the same types of arguments, and processes them sequentially, after all options have been processed:</source>
          <target state="translated">ocamlopt 명령에는 ocamlc와 매우 유사한 명령 줄 인터페이스가 있습니다. 동일한 유형의 인수를 허용하고 모든 옵션이 처리 된 후 순차적으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="9f43adb44cad300b255a2ab339a13959b026d322" translate="yes" xml:space="preserve">
          <source>The ocamlprof command produces a source listing of the program modules where execution counts have been inserted as comments. For instance,</source>
          <target state="translated">ocamlprof 명령은 실행 횟수가 주석으로 삽입 된 프로그램 모듈의 소스 목록을 생성합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="b7ea8af81e418a1edb4e459f8a9a2eab6da15605" translate="yes" xml:space="preserve">
          <source>The ocamlrun command comprises three main parts: the bytecode interpreter, that actually executes bytecode files; the memory allocator and garbage collector; and a set of C functions that implement primitive operations such as input/output.</source>
          <target state="translated">ocamlrun 명령은 세 가지 주요 부분으로 구성됩니다. 실제로 바이트 코드 파일을 실행하는 바이트 코드 인터프리터; 메모리 할당 자 및 가비지 수집기; 및 입력 / 출력과 같은 기본 연산을 구현하는 C 함수 세트.</target>
        </trans-unit>
        <trans-unit id="ba3256951b99c851dcb6d71a9ee49e018d24d2bb" translate="yes" xml:space="preserve">
          <source>The ocamlrun command executes bytecode files produced by the linking phase of the ocamlc command.</source>
          <target state="translated">ocamlrun 명령은 ocamlc 명령의 연결 단계에서 생성 된 바이트 코드 파일을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="9e1235caedb5ccfed4248d72a0e38e7bda7a4c82" translate="yes" xml:space="preserve">
          <source>The ocamlrun command searches shared libraries in the following directories, in the order indicated:</source>
          <target state="translated">ocamlrun 명령은 표시된 순서대로 다음 디렉토리에서 공유 라이브러리를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="45cf460ec88bc5d152326aaf5ae83eb8df678857" translate="yes" xml:space="preserve">
          <source>The ocamlyacc command produces a parser from a context-free grammar specification with attached semantic actions, in the style of yacc. Assuming the input file is grammar.mly, executing</source>
          <target state="translated">ocamlyacc 명령은 yacc 스타일의 의미 적 동작이 첨부 된 컨텍스트 프리 문법 사양에서 구문 분석기를 생성합니다. 입력 파일이 grammar.mly라고 가정하고 다음을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="028fe9d310df119de0ec84424c8896799e9e2f82" translate="yes" xml:space="preserve">
          <source>The ocamlyacc command recognizes the following options:</source>
          <target state="translated">ocamlyacc 명령은 다음 옵션을 인식합니다.</target>
        </trans-unit>
        <trans-unit id="2c12a611ec5444a4dcbe094626c7878666edcceb" translate="yes" xml:space="preserve">
          <source>The only case we have reasonable confidence is safe is if the produced &lt;code&gt;bytes&lt;/code&gt; is shared -- used as an immutable byte sequence. This is possibly useful for incremental migration of low-level programs that manipulate immutable sequences of bytes (for example &lt;a href=&quot;marshal#VALfrom_bytes&quot;&gt;&lt;code&gt;Marshal.from_bytes&lt;/code&gt;&lt;/a&gt;) and previously used the &lt;code&gt;string&lt;/code&gt; type for this purpose.</source>
          <target state="translated">우리가 합리적인 확신을 가지고있는 유일한 경우는 생성 된 &lt;code&gt;bytes&lt;/code&gt; 가 변경되지 않는 바이트 시퀀스로 사용되는 공유 되는 경우 입니다. 이는 변경 불가능한 바이트 시퀀스 (예 : &lt;a href=&quot;marshal#VALfrom_bytes&quot;&gt; &lt;code&gt;Marshal.from_bytes&lt;/code&gt; &lt;/a&gt; ) 를 조작 하고 이전 에이 목적으로 &lt;code&gt;string&lt;/code&gt; 유형을 사용하는 저수준 프로그램의 증분 마이그레이션에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9599505a809ca09e4fab73b6902744c16bc81fdd" translate="yes" xml:space="preserve">
          <source>The only case where that transformation is not possible is if a given function call may raise distinct exceptions with the same constructor but different string values. In this case, you will have to check for specific string values. This is dangerous API design and it should be discouraged: it&amp;rsquo;s better to define more precise exception constructors than store useful information in strings.</source>
          <target state="translated">변환이 불가능한 유일한 경우는 주어진 함수 호출이 동일한 생성자이지만 다른 문자열 값을 사용하여 별개의 예외를 발생시킬 수있는 경우입니다. 이 경우 특정 문자열 값을 확인해야합니다. 이것은 위험한 API 디자인이므로 권장하지 않습니다. 유용한 정보를 문자열에 저장하는 것보다 더 정확한 예외 생성자를 정의하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2cedfa4c8d920a307290831222d9cbd51790caf6" translate="yes" xml:space="preserve">
          <source>The only difference with the let construct described above is that the bindings of names to values performed by the pattern-matching are considered already performed when the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are evaluated. That is, the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; can reference identifiers that are bound by one of the patterns &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, and expect them to have the same value as in &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, the body of the letrec construct.</source>
          <target state="translated">위에서 설명한 let 구성과의 유일한 차이점은 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ~ &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 표현식 이 평가 될 때 패턴 일치에 의해 수행 된 값에 대한 이름의 바인딩이 이미 수행 된 것으로 간주 된다는 것입니다. 즉, &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ~ &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 표현식 은 패턴 &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip;, &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 중 하나에 의해 바인딩 된 식별자를 참조 할 수 있으며 letrec 구문의 본문 인 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 과 동일한 값을 가질 것으로 예상 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="774d89b5de623ddb891076997b98ef614701dff8" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;flags&lt;/code&gt; are:</source>
          <target state="translated">선택적 &lt;code&gt;flags&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e89406e3e1bdda8e82d077bce710e73570e29fe" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;precision&lt;/code&gt; is a dot &lt;code&gt;.&lt;/code&gt; followed by an integer indicating how many digits follow the decimal point in the &lt;code&gt;%f&lt;/code&gt;, &lt;code&gt;%e&lt;/code&gt;, &lt;code&gt;%E&lt;/code&gt;, &lt;code&gt;%h&lt;/code&gt;, and &lt;code&gt;%H&lt;/code&gt; conversions or the maximum number of significant digits to appear for the &lt;code&gt;%F&lt;/code&gt;, &lt;code&gt;%g&lt;/code&gt; and &lt;code&gt;%G&lt;/code&gt; conversions. For instance, &lt;code&gt;%.4f&lt;/code&gt; prints a &lt;code&gt;float&lt;/code&gt; with 4 fractional digits.</source>
          <target state="translated">선택적 &lt;code&gt;precision&lt;/code&gt; 는 점 &lt;code&gt;.&lt;/code&gt; &lt;code&gt;%f&lt;/code&gt; , &lt;code&gt;%e&lt;/code&gt; , &lt;code&gt;%E&lt;/code&gt; , &lt;code&gt;%h&lt;/code&gt; 및 &lt;code&gt;%H&lt;/code&gt; 변환 에서 소수점 뒤에 오는 자릿수 또는 &lt;code&gt;%F&lt;/code&gt; , &lt;code&gt;%g&lt;/code&gt; 및 &lt;code&gt;%G&lt;/code&gt; 변환에 대해 나타날 최대 유효 자릿수를 나타내는 정수가 뒤 따릅니다. . 예를 들어, &lt;code&gt;%.4f&lt;/code&gt; 는 4 개의 소수 자릿수 로 &lt;code&gt;float&lt;/code&gt; 을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="5468298bc781912cae47e80a93f5f848cf36f0ca" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;random&lt;/code&gt; parameter (a boolean) controls whether the internal organization of the hash table is randomized at each execution of &lt;code&gt;Hashtbl.create&lt;/code&gt; or deterministic over all executions.</source>
          <target state="translated">선택적 &lt;code&gt;random&lt;/code&gt; 매개 변수 (부울)는 &lt;code&gt;Hashtbl.create&lt;/code&gt; 가 실행될 때마다 해시 테이블의 내부 구성이 무작위 화 되는지 또는 모든 실행에 대해 결정적인지를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="af162af26700a86b364c7a2731480ce8c43ff2a7" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;width&lt;/code&gt; is an integer indicating the minimal width of the result. For instance, &lt;code&gt;%6d&lt;/code&gt; prints an integer, prefixing it with spaces to fill at least 6 characters.</source>
          <target state="translated">선택적 &lt;code&gt;width&lt;/code&gt; 는 결과의 최소 너비를 나타내는 정수입니다. 예를 들어, &lt;code&gt;%6d&lt;/code&gt; 는 정수를 인쇄하고 앞에 공백을 추가하여 최소 6자를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="a984b2d5c22765574cbc75b87562636eb520c87c" translate="yes" xml:space="preserve">
          <source>The optional arguments &lt;code&gt;?stdin&lt;/code&gt; and &lt;code&gt;?stdout&lt;/code&gt; and &lt;code&gt;?stderr&lt;/code&gt; are file names used to redirect the standard input, the standard output, or the standard error of the command. If &lt;code&gt;~stdin:f&lt;/code&gt; is given, a redirection &lt;code&gt;&amp;lt;&amp;nbsp;f&lt;/code&gt; is performed and the standard input of the command reads from file &lt;code&gt;f&lt;/code&gt;. If &lt;code&gt;~stdout:f&lt;/code&gt; is given, a redirection &lt;code&gt;&amp;gt;&amp;nbsp;f&lt;/code&gt; is performed and the standard output of the command is written to file &lt;code&gt;f&lt;/code&gt;. If &lt;code&gt;~stderr:f&lt;/code&gt; is given, a redirection &lt;code&gt;2&amp;gt;&amp;nbsp;f&lt;/code&gt; is performed and the standard error of the command is written to file &lt;code&gt;f&lt;/code&gt;. If both &lt;code&gt;~stdout:f&lt;/code&gt; and &lt;code&gt;~stderr:f&lt;/code&gt; are given, with the exact same file name &lt;code&gt;f&lt;/code&gt;, a &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; redirection is performed so that the standard output and the standard error of the command are interleaved and redirected to the same file &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;code&gt;?stdin&lt;/code&gt; 및 &lt;code&gt;?stdout&lt;/code&gt; 및 &lt;code&gt;?stderr&lt;/code&gt; 은 표준 입력, 표준 출력 또는 명령의 표준 오류를 리디렉션하는 데 사용되는 파일 이름입니다. 경우 &lt;code&gt;~stdin:f&lt;/code&gt; 주어진다, 리디렉션 &lt;code&gt;&amp;lt;&amp;nbsp;f&lt;/code&gt; 수행하고, 명령의 표준 입력 파일로부터 판독 &lt;code&gt;f&lt;/code&gt; . 경우 &lt;code&gt;~stdout:f&lt;/code&gt; 주어집니다, 리디렉션은 &lt;code&gt;&amp;gt;&amp;nbsp;f&lt;/code&gt; 수행하고 명령의 표준 출력은 파일에 기록됩니다 &lt;code&gt;f&lt;/code&gt; . 경우 &lt;code&gt;~stderr:f&lt;/code&gt; 주어집니다, 리디렉션 &lt;code&gt;2&amp;gt;&amp;nbsp;f&lt;/code&gt; 수행하고 명령의 표준 오차는 파일에 기록됩니다 &lt;code&gt;f&lt;/code&gt; . 둘 다 &lt;code&gt;~stdout:f&lt;/code&gt; 및 &lt;code&gt;~stderr:f&lt;/code&gt; 동일한 파일명으로 부여 &lt;code&gt;f&lt;/code&gt; 하는 &lt;code&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; 리디렉션 표준 출력과 명령의 표준 오차는 인터리빙과 같은 파일로 재 지정되도록 수행한다 &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e256823745bc0b0bb3e5fba44ec11d079e0f250" translate="yes" xml:space="preserve">
          <source>The optional type equation =&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; makes the defined type equivalent to the type expression &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;: one can be substituted for the other during typing. If no type equation is given, a new type is generated: the defined type is incompatible with any other type.</source>
          <target state="translated">선택적 유형 방정식 = &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; 은 정의 된 유형을 유형 표현식 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; 과 동일하게 만듭니다 . 하나는 입력 중에 다른 하나를 대체 할 수 있습니다. 유형 방정식이 제공되지 않으면 새 유형이 생성됩니다. 정의 된 유형은 다른 유형과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4236d000dcf5d91e24113385c5dda11fb81d860b" translate="yes" xml:space="preserve">
          <source>The optional type parameters are either one type variable '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;, for type constructors with one parameter, or a list of type variables ('&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;,&amp;hellip;,'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;), for type constructors with several parameters. Each type parameter may be prefixed by a variance constraint + (resp. -) indicating that the parameter is covariant (resp. contravariant). These type parameters can appear in the type expressions of the right-hand side of the definition, optionally restricted by a variance constraint ; &lt;em&gt;i.e.&lt;/em&gt; a covariant parameter may only appear on the right side of a functional arrow (more precisely, follow the left branch of an even number of arrows), and a contravariant parameter only the left side (left branch of an odd number of arrows). If the type has a representation or an equation, and the parameter is free (&lt;em&gt;i.e.&lt;/em&gt; not bound via a type constraint to a constructed type), its variance constraint is checked but subtyping &lt;em&gt;etc.&lt;/em&gt; will use the inferred variance of the parameter, which may be less restrictive; otherwise (&lt;em&gt;i.e.&lt;/em&gt; for abstract types or non-free parameters), the variance must be given explicitly, and the parameter is invariant if no variance is given.</source>
          <target state="translated">선택적 유형 매개 변수는 하나의 매개 변수가있는 유형 생성자의 경우 하나의 유형 변수 ' &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; 이거나 여러 매개 변수가있는 유형 생성자의 경우 유형 변수 목록 (' &lt;a href=&quot;lex#ident&quot;&gt;ident &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip;, ' &lt;a href=&quot;lex#ident&quot;&gt;ident &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; )입니다. 각 유형 매개 변수는 매개 변수가 공변 (대변 반변)임을 나타내는 분산 제약 + (각각-) 접두사를 붙일 수 있습니다. 이러한 유형 매개 변수는 정의 오른쪽의 유형 표현식에 나타날 수 있으며 선택적으로 분산 제약 조건에 의해 제한됩니다. &lt;em&gt;즉&lt;/em&gt;공변 매개 변수는 기능적 화살표의 오른쪽에만 나타날 수 있으며 (보다 정확하게는 짝수 화살표의 왼쪽 분기를 따름), 반 변성 매개 변수는 왼쪽 (홀수 화살표의 왼쪽 분기)에만 나타날 수 있습니다. 유형에 표현이나 방정식이 있고 매개 변수가 자유롭다면 ( &lt;em&gt;즉&lt;/em&gt; , 생성 된 유형에 유형 제약을 통해 바인딩되지 않은 경우) 분산 제약이 검사되지만 하위 유형 &lt;em&gt;등&lt;/em&gt; 은 매개 변수의 유추 된 분산을 사용합니다. 덜 제한적입니다. 그렇지 않은 경우 ( &lt;em&gt;즉&lt;/em&gt; , 추상 유형 또는 비 자유 매개 변수의 경우) 분산을 명시 적으로 제공해야하며 분산이 제공되지 않으면 매개 변수는 불변입니다.</target>
        </trans-unit>
        <trans-unit id="dca346bd513d4a4a22688d0f639db0a9deec76c9" translate="yes" xml:space="preserve">
          <source>The optional type representation describes the data structure representing the defined type, by giving the list of associated constructors (if it is a variant type) or associated fields (if it is a record type). If no type representation is given, nothing is assumed on the structure of the type besides what is stated in the optional type equation.</source>
          <target state="translated">선택적 유형 표현은 연관된 생성자 (변형 유형 인 경우) 또는 연관된 필드 (레코드 유형 인 경우) 목록을 제공하여 정의 된 유형을 나타내는 데이터 구조를 설명합니다. 유형 표현이 제공되지 않으면 선택적 유형 방정식에 명시된 것 외에 유형의 구조에 대해 아무 것도 가정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c913082fd743d89983385840500d287f715d0b40" translate="yes" xml:space="preserve">
          <source>The order in which the .cmo files are given to ocamlc during the linking phase determines the order in which the module definitions occur. Hence, in the example above, Aux appears first and Main can refer to it, but Aux cannot refer to Main.</source>
          <target state="translated">연결 단계에서 .cmo 파일이 ocamlc에 제공되는 순서에 따라 모듈 정의가 발생하는 순서가 결정됩니다. 따라서 위의 예에서 Aux가 먼저 나타나고 Main은이를 참조 할 수 있지만 Aux는 Main을 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9875c6ba3859a4c01a0b128c6fb6274d60da0369" translate="yes" xml:space="preserve">
          <source>The order in which the bindings are passed to &lt;code&gt;f&lt;/code&gt; is unspecified. However, if the table contains several bindings for the same key, they are passed to &lt;code&gt;f&lt;/code&gt; in reverse order of introduction, that is, the most recent binding is passed first.</source>
          <target state="translated">바인딩이 &lt;code&gt;f&lt;/code&gt; 에 전달되는 순서 는 지정되지 않습니다. 그러나 테이블에 동일한 키에 대한 여러 바인딩이 포함 된 경우 도입의 역순 으로 &lt;code&gt;f&lt;/code&gt; 에 전달됩니다 . 즉, 가장 최근의 바인딩이 먼저 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0038d1e71d2d22bcc5fc3fc7481009a2bb18e7e5" translate="yes" xml:space="preserve">
          <source>The order in which the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#argument&quot;&gt;argument&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are evaluated is not specified.</source>
          <target state="translated">표현식 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; , &lt;a href=&quot;#argument&quot;&gt;인수 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip;, &lt;a href=&quot;#argument&quot;&gt;인수 &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 이 평가되는 순서는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63c6c1451d4aeaf3a047e06c6ffd102113e24f2b" translate="yes" xml:space="preserve">
          <source>The other caveat is that by default symbolic links are a privileged operation. Administrators will always need to be running elevated (or with UAC disabled) and by default normal user accounts need to be granted the SeCreateSymbolicLinkPrivilege via Local Security Policy (secpol.msc) or via Active Directory.</source>
          <target state="translated">다른주의 사항은 기본적으로 심볼릭 링크가 권한이있는 작업이라는 것입니다. 관리자는 항상 상승 된 상태로 (또는 UAC가 비활성화 된 상태에서) 실행되어야하며 기본적으로 일반 사용자 계정은 로컬 보안 정책 (secpol.msc) 또는 Active Directory를 통해 SeCreateSymbolicLinkPrivilege를 부여 받아야합니다.</target>
        </trans-unit>
        <trans-unit id="69042c37de15f706ea13e0d0d27fbaa418b8568a" translate="yes" xml:space="preserve">
          <source>The other form of function definition is introduced by the keyword fun:</source>
          <target state="translated">다른 형태의 함수 정의는 fun 키워드로 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="9ef7b523167e57b31abccd875bb07306286ad08a" translate="yes" xml:space="preserve">
          <source>The output buffer of a symbolic pretty-printer.</source>
          <target state="translated">상징적 인 프리티 프린터의 출력 버퍼.</target>
        </trans-unit>
        <trans-unit id="197edf84eebbfd7ce0d59bc84a2b213982ad8e53" translate="yes" xml:space="preserve">
          <source>The output of the linking phase is a file containing compiled bytecode that can be executed by the OCaml bytecode interpreter: the command named ocamlrun. If a.out is the name of the file produced by the linking phase, the command</source>
          <target state="translated">연결 단계의 출력은 OCaml 바이트 코드 인터프리터가 실행할 수있는 컴파일 된 바이트 코드를 포함하는 파일입니다. 명령은 ocamlrun입니다. a.out이 링크 단계에서 생성 된 파일의 이름 인 경우 다음 명령은</target>
        </trans-unit>
        <trans-unit id="f86bd69d544011aefe916eee4af7cd635e073e0c" translate="yes" xml:space="preserve">
          <source>The output of the linking phase is a regular Unix or Windows executable file. It does not need ocamlrun to run.</source>
          <target state="translated">연결 단계의 출력은 일반 Unix 또는 Windows 실행 파일입니다. 실행하는 데 ocamlrun이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ce0fa21bd7ce51645890738324e05068fce2adc" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;ephemeron.k1.make&quot;&gt;&lt;code&gt;Ephemeron.K1.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ephemeron.k2.make&quot;&gt;&lt;code&gt;Ephemeron.K2.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">functor &lt;a href=&quot;ephemeron.k1.make&quot;&gt; &lt;code&gt;Ephemeron.K1.Make&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;ephemeron.k2.make&quot;&gt; &lt;code&gt;Ephemeron.K2.Make&lt;/code&gt; &lt;/a&gt; 의 출력 서명입니다 .</target>
        </trans-unit>
        <trans-unit id="5b888b9c1ae97afb61ed88f6dcc91b6356987780" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;ephemeron.k1.make&quot;&gt;&lt;code&gt;Ephemeron.K1.Make&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ephemeron.k2.make&quot;&gt;&lt;code&gt;Ephemeron.K2.Make&lt;/code&gt;&lt;/a&gt;. These hash tables are weak in the keys. If all the keys of a binding are alive the binding is kept, but if one of the keys of the binding is dead then the binding is removed.</source>
          <target state="translated">functor &lt;a href=&quot;ephemeron.k1.make&quot;&gt; &lt;code&gt;Ephemeron.K1.Make&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;ephemeron.k2.make&quot;&gt; &lt;code&gt;Ephemeron.K2.Make&lt;/code&gt; &lt;/a&gt; 의 출력 서명입니다 . 이러한 해시 테이블은 키가 약합니다. 바인딩의 모든 키가 활성 상태이면 바인딩이 유지되지만 바인딩의 키 중 하나가 작동하지 않으면 바인딩이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="6df4d9df08fab00830fd043eb96f7af5ace9c32e" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;ephemeron.k1.makeseeded&quot;&gt;&lt;code&gt;Ephemeron.K1.MakeSeeded&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;ephemeron.k2.makeseeded&quot;&gt;&lt;code&gt;Ephemeron.K2.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">functor &lt;a href=&quot;ephemeron.k1.makeseeded&quot;&gt; &lt;code&gt;Ephemeron.K1.MakeSeeded&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;ephemeron.k2.makeseeded&quot;&gt; &lt;code&gt;Ephemeron.K2.MakeSeeded&lt;/code&gt; &lt;/a&gt; 의 출력 서명 .</target>
        </trans-unit>
        <trans-unit id="ebc4f49be3b37069506238985b68b76a704e8a12" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;hashtbl.make&quot;&gt;&lt;code&gt;Hashtbl.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">펑터 &lt;a href=&quot;hashtbl.make&quot;&gt; &lt;code&gt;Hashtbl.Make&lt;/code&gt; &lt;/a&gt; 의 출력 서명 .</target>
        </trans-unit>
        <trans-unit id="acd77c5116baf2558a8ee6e7372f7c8f987c6831" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;hashtbl.makeseeded&quot;&gt;&lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">펑터 &lt;a href=&quot;hashtbl.makeseeded&quot;&gt; &lt;code&gt;Hashtbl.MakeSeeded&lt;/code&gt; &lt;/a&gt; 의 출력 서명 .</target>
        </trans-unit>
        <trans-unit id="ffa1e6deb7c02cb5fb60673b1d37d74545f296d4" translate="yes" xml:space="preserve">
          <source>The output signature of the functor &lt;a href=&quot;weak.make&quot;&gt;&lt;code&gt;Weak.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">펑터 &lt;a href=&quot;weak.make&quot;&gt; &lt;code&gt;Weak.Make&lt;/code&gt; &lt;/a&gt; 의 출력 서명입니다 .</target>
        </trans-unit>
        <trans-unit id="235dcfaccc10009cd349c37e2f6b3ea0f93a7b42" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;callstack_size&lt;/code&gt; is the length of the callstack recorded at every sample. Its default is &lt;code&gt;max_int&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;callstack_size&lt;/code&gt; 는 모든 샘플에 기록 된 콜 스택의 길이입니다. 기본값은 &lt;code&gt;max_int&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2e070830e786df33101debf41e042d4603dc7e8c" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;sampling_rate&lt;/code&gt; is the sampling rate in samples per word (including headers). Usually, with cheap callbacks, a rate of 1e-4 has no visible effect on performance, and 1e-3 causes the program to run a few percent slower</source>
          <target state="translated">파라미터 &lt;code&gt;sampling_rate&lt;/code&gt; 의가 (헤더 포함) 워드 당 샘플의 샘플링 속도이다. 일반적으로 저렴한 콜백의 경우 1e-4의 속도는 성능에 눈에 띄는 영향을 미치지 않으며 1e-3은 프로그램이 몇 퍼센트 느리게 실행되도록합니다.</target>
        </trans-unit>
        <trans-unit id="49970203f15065fd920f5133460488f7c2c20b5b" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;tracker&lt;/code&gt; determines how to track sampled blocks over their lifetime in the minor and major heap.</source>
          <target state="translated">매개 변수 &lt;code&gt;tracker&lt;/code&gt; 는 마이너 및 메이저 힙에서 수명 동안 샘플링 된 블록을 추적하는 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="09fbb96897f07cf55eb54e9bcb8824b504ac0830" translate="yes" xml:space="preserve">
          <source>The parameter patterns ~&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; and ~(&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;]) are shorthands for respectively ~&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt;:&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; and ~&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt;:(&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;]), and similarly for their optional counterparts.</source>
          <target state="translated">매개 변수 패턴 ~ &lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; 및 ~ ( &lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; [: &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt; ])는 각각 ~ &lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; : &lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; 및 ~ &lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; :( &lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt; [: &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt; ])에 대한 약칭이며 선택적인 대응 항목에 대해서도 유사합니다.</target>
        </trans-unit>
        <trans-unit id="1e5974a12a7d51f44c9175604dd69a6dc4db175f" translate="yes" xml:space="preserve">
          <source>The parameter x_init is, of course, visible in the whole body of the definition, including methods. For instance, the method get_offset in the class below returns the position of the object relative to its initial position.</source>
          <target state="translated">x_init 매개 변수는 물론 메서드를 포함한 전체 정의 본문에서 볼 수 있습니다. 예를 들어, 아래 클래스의 get_offset 메소드는 초기 위치를 기준으로 객체의 위치를 ​​반환합니다.</target>
        </trans-unit>
        <trans-unit id="e95fd7cf7f4ba7d41d47acfb96f75946ad23cd79" translate="yes" xml:space="preserve">
          <source>The parser also enters error recovery mode if one of the grammar actions raises the Parsing.Parse_error exception.</source>
          <target state="translated">구문 분석기는 문법 조치 중 하나가 Parsing.Parse_error 예외를 발생시키는 경우에도 오류 복구 모드로 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="34d65af266245e845378220e5a545186f7764e3e" translate="yes" xml:space="preserve">
          <source>The pass analyses functions to determine which arguments are unused. Removal is effected by creating a wrapper function, which will be inlined at every direct call site, that accepts the original arguments and then discards the unused ones before calling the original function. As a consequence, this transformation may be detrimental if the original function is usually indirectly called, since such calls will now bounce through the wrapper. (The technique of &lt;em&gt;direct call surrogates&lt;/em&gt; used to reduce this penalty during unboxing of closure variables (see above) does not yet apply to the pass that removes unused arguments.)</source>
          <target state="translated">이 패스는 함수를 분석하여 사용되지 않는 인수를 결정합니다. 제거는 모든 직접 호출 사이트에서 인라인 될 래퍼 함수를 ​​생성하여 수행되며, 원래 인수를 수락 한 다음 원래 함수를 호출하기 전에 사용되지 않은 인수를 버립니다. 결과적으로이 변환은 원래 함수가 일반적으로 간접적으로 호출되는 경우 해로울 수 있습니다. 이러한 호출은 이제 래퍼를 통해 바운스되기 때문입니다. ( 클로저 변수를 언 박싱하는 동안 (위 참조)이 패널티를 줄이기 위해 사용 된 &lt;em&gt;직접 호출 대리&lt;/em&gt; 기법 은 사용되지 않는 인수를 제거하는 패스에는 아직 적용되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="ddb1f22a5bac6d00f359ad560b86fb3d4abcbdd7" translate="yes" xml:space="preserve">
          <source>The pattern 'c'..'d' is a shorthand for the pattern</source>
          <target state="translated">패턴 'c'.. 'd'는 패턴의 속기입니다.</target>
        </trans-unit>
        <trans-unit id="78a9eb434825f2c323017a519a3d60fa9f698c76" translate="yes" xml:space="preserve">
          <source>The pattern (&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;) matches the same values as &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. A type constraint can appear in a parenthesized pattern, as in (&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;). This constraint forces the type of &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to be compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="translated">패턴 ( &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; )과 동일한 값이 일치하는 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; . 유형 제약은 ( &lt;a href=&quot;#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; : &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; ) 에서와 같이 괄호로 묶인 패턴으로 나타날 수 있습니다 . 이 제약 조건은 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 의 유형이 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; 과 호환 되도록 합니다.</target>
        </trans-unit>
        <trans-unit id="16ae7f98de1b36c58b45270ed0fb02b7e9c6764a" translate="yes" xml:space="preserve">
          <source>The pattern (module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt;) matches a package with type &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; and binds it to &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;. It is not allowed in toplevel let bindings. Again &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; can be omitted if it can be inferred from the enclosing pattern.</source>
          <target state="translated">패턴 (module &lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; : &lt;a href=&quot;#package-type&quot;&gt;package-type&lt;/a&gt; )은 유형이 &lt;a href=&quot;#package-type&quot;&gt;package-type 인&lt;/a&gt; 패키지와 일치하고 &lt;a href=&quot;names#module-name&quot;&gt;module-name에&lt;/a&gt; 바인딩합니다 . 최상위 let 바인딩에서는 허용되지 않습니다. 다시 &lt;a href=&quot;#package-type&quot;&gt;패키지 유형&lt;/a&gt; 은 둘러싸는 패턴에서 유추 할 수있는 경우 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f60d5e8c331afa9fe8e1e6db86c21aacdc85acef" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; matches n-tuples whose components match the patterns &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; through &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. That is, the pattern matches the tuple values (v&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, v&lt;sub&gt;n&lt;/sub&gt;) such that &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; matches v&lt;sub&gt;i&lt;/sub&gt; for i = 1,&amp;hellip; , n.</source>
          <target state="translated">패턴 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip;, &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 은 구성 요소가 패턴 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ~ &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 과 일치하는 n- 튜플과 일치합니다 . 즉, 상기 패턴은 튜플 값 (V 일치 인 &lt;sub&gt;1&lt;/sub&gt; , ..., V의 &lt;sub&gt;N&lt;/sub&gt; 하도록) &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;난&lt;/sub&gt; V 일치 &lt;sub&gt;I&lt;/sub&gt; 난 = 1, ..., N을.</target>
        </trans-unit>
        <trans-unit id="f6da6c23d8212831014d6c0f7d9fd644913b7199" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;::&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; matches non-empty lists whose heads match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, and whose tails match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="translated">패턴 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; :: &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 는 머리가 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 과 일치하고 꼬리가 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 와 일치하는 비어 있지 않은 목록 과 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="41348db0bf142801b4dc26e958764633a28f85d6" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;as&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; matches the same values as &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. If the matching against &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is successful, the name &lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; is bound to the matched value, in addition to the bindings performed by the matching against &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.</source>
          <target state="translated">패턴 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 과 같은 &lt;a href=&quot;names#value-name&quot;&gt;값 이름은&lt;/a&gt; 동일한 값을 일치 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; . &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 에 대한 일치 가 성공하면 이름 &lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; 이 일치하는 값에 바인드되고 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 에 대한 일치에 의해 수행 된 바인딩에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="9299c9cb5135cc2b4bedfa03f575390c8ead0e50" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; represents the logical &amp;ldquo;or&amp;rdquo; of the two patterns &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. A value matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; if it matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; or &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;. The two sub-patterns &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; must bind exactly the same identifiers to values having the same types. Matching is performed from left to right. More precisely, in case some value v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;, the bindings performed are those of &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; when v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;. Otherwise, value v matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; whose bindings are performed.</source>
          <target state="translated">패턴 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; | &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 는 두 패턴 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 및 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 의 논리적 &quot;또는&quot;을 나타냅니다 . 값이 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 과 일치 | &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;이&lt;/sub&gt; 일치하는 경우 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 또는 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; . 두 개의 하위 패턴 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 과 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 는 동일한 유형의 값에 정확히 동일한 식별자를 바인딩해야합니다. 일치는 왼쪽에서 오른쪽으로 수행됩니다. 보다 정확하게는 어떤 값 v가 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 과 일치하는 경우 | &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;에서 수행되는 바인딩은 v가 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 과 일치 할 때 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 의 바인딩 입니다. 그렇지 않으면 값 v 는 바인딩이 수행되는 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 와 일치 합니다.&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="00b0db5a51b1f1d5c7c59b426eaf70572b94fa7f" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;(&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;) matches all variants whose constructor is equal to &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;, and whose arguments match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. It is a type error if n is not the number of arguments expected by the constructor.</source>
          <target state="translated">패턴 &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; ( &lt;a href=&quot;#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip;, &lt;a href=&quot;#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; )은 생성자가 &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; 과 같고 인수가 &lt;a href=&quot;#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 과 일치하는 모든 변형과 일치합니다 . n이 생성자에서 예상하는 인수 수가 아니면 유형 오류입니다.</target>
        </trans-unit>
        <trans-unit id="d790d4519563bbe23e283cddeb381557179c1ed8" translate="yes" xml:space="preserve">
          <source>The pattern &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;_ matches all variants whose constructor is &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; _ 패턴 은 생성자가 &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; 인 모든 변형과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="3c4b162c77607f7f0c96e87989be66403257ce86" translate="yes" xml:space="preserve">
          <source>The pattern [&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] matches lists of length n whose elements match &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, respectively. This pattern behaves like &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:: &amp;hellip; ::&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;::[].</source>
          <target state="translated">패턴 [ &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;; &lt;a href=&quot;#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; ]은 요소가 각각 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 과 일치하는 길이 n의 목록과 일치합니다 . 이 패턴은 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ::&amp;hellip; :: &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; :: [] 처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="5be2296eeedc0ad28df110fb34fef15f60597b6f" translate="yes" xml:space="preserve">
          <source>The pattern [|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;|] matches arrays of length n such that the i-th array element matches the pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;, for i = 1,&amp;hellip; , n.</source>
          <target state="translated">패턴 [| &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;; &lt;a href=&quot;#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; |] 은 i = 1,&amp;hellip;, n에 대해 i 번째 배열 요소가 패턴 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; 와 일치하도록 길이 n의 배열과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="1788df79d59202a4d26aad006675bcfb219b3e5f" translate="yes" xml:space="preserve">
          <source>The pattern `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; matches all polymorphic variants whose tag is equal to &lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;, and whose argument matches &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;.</source>
          <target state="translated">패턴` &lt;a href=&quot;names#tag-name&quot;&gt;tag-name &lt;/a&gt;&lt;a href=&quot;#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 은 태그가 &lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; 과 같고 인수가 &lt;a href=&quot;#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 과 일치하는 모든 다형성 변형과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="d78189bca7a2a4a7c7d4b24d2ca0b9ace362515e" translate="yes" xml:space="preserve">
          <source>The pattern lazy&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; matches a value v of type Lazy.t, provided &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; matches the result of forcing v with Lazy.force. A successful match of a pattern containing lazy sub-patterns forces the corresponding parts of the value being matched, even those that imply no test such as lazy&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; or lazy_. Matching a value with a &lt;a href=&quot;expr#pattern-matching&quot;&gt;pattern-matching&lt;/a&gt; where some patterns contain lazy sub-patterns may imply forcing parts of the value, even when the pattern selected in the end has no lazy sub-pattern.</source>
          <target state="translated">패턴 지연 &lt;a href=&quot;#pattern&quot;&gt;패턴을&lt;/a&gt; 제공 Lazy.t 타입의 값 (V)과 일치하는 &lt;a href=&quot;#pattern&quot;&gt;패턴이&lt;/a&gt; Lazy.force V로 강제 결과 일치한다. lazy sub-patterns를 포함하는 패턴의 성공적인 일치는 lazy &lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt; 또는 lazy_ 와 같은 테스트를 의미하지 않는 경우에도 일치하는 값의 해당 부분을 강제합니다 . 일부 패턴에 게으른 하위 패턴이 포함 된 패턴 &lt;a href=&quot;expr#pattern-matching&quot;&gt;일치&lt;/a&gt; 와 값을 일치시키는 것은 마지막에 선택된 패턴에 게으른 하위 패턴이없는 경우에도 값의 일부를 강제하는 것을 의미 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16f7adce7fddea3b9b8f86106681f2bc5fc82ba6" translate="yes" xml:space="preserve">
          <source>The pattern {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;] ; &amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] } matches records that define at least the fields &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; through &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, and such that the value associated to &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; matches the pattern &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;, for i = 1,&amp;hellip; , n. A single identifier &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; , and a single qualified identifier &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; stands for &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;=&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; . The record value can define more fields than &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;; the values associated to these extra fields are not taken into account for matching. Optionally, a record pattern can be terminated by ;_ to convey the fact that not all fields of the record type are listed in the record pattern and that it is intentional. Optional type constraints can be added field by field with {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;;&amp;hellip; ;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;} to force the type of &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; to be compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;.</source>
          <target state="translated">패턴 { &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; [= &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ]; &amp;hellip;; &lt;a href=&quot;names#field&quot;&gt;field &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; [= &lt;a href=&quot;#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; ]}은 최소한 &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 부터 &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 까지 정의하는 레코드 와 일치하고, &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;i에&lt;/sub&gt; 연관된 값 이 i = 1,&amp;hellip;, n에 대해 패턴 &lt;a href=&quot;#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; 와 일치하도록합니다 . 단일 식별자 &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; 는 &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; = &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; 및 단일 정규화 된 식별자 &lt;a href=&quot;names#module-path&quot;&gt;module-path를 나타&lt;/a&gt; 냅니다. &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; 는&lt;a href=&quot;names#module-path&quot;&gt;모듈 경로&lt;/a&gt; . &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; = &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; . 레코드 값은 &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 보다 더 많은 필드를 정의 할 수 있습니다 . 이러한 추가 필드와 관련된 값은 일치에 고려되지 않습니다. 선택적으로 레코드 유형의 모든 필드가 레코드 패턴에 나열되지 않고 의도적이라는 사실을 전달하기 위해 레코드 패턴을; _로 종료 할 수 있습니다. 선택적 유형 제약은 { &lt;a href=&quot;names#field&quot;&gt;field &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; : &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;#pattern&quot;&gt;pattern &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ;&amp;hellip;; &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; : &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; = &lt;a href=&quot;#pattern&quot;&gt;패턴&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; } &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; 의 유형이 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; 와 호환 되도록 강제합니다 .</target>
        </trans-unit>
        <trans-unit id="28c11f2884ea2e751e90db06b713059bf8743ce8" translate="yes" xml:space="preserve">
          <source>The pointer returned by caml_named_value is constant and can safely be cached in a C variable to avoid repeated name lookups. The value pointed to cannot be changed from C. However, it might change during garbage collection, so must always be recomputed at the point of use. Here is a more efficient variant of call_caml_f above that calls caml_named_value only once:</source>
          <target state="translated">caml_named_value에 의해 반환 된 포인터는 일정하며 반복되는 이름 조회를 피하기 위해 C 변수에 안전하게 캐시 될 수 있습니다. 가리키는 값은 C에서 변경할 수 없습니다. 그러나 가비지 수집 중에 변경 될 수 있으므로 항상 사용 시점에서 다시 계산해야합니다. 다음은 caml_named_value를 한 번만 호출하는 위의 call_caml_f의보다 효율적인 변형입니다.</target>
        </trans-unit>
        <trans-unit id="32e4ea607d04ac6fcfc5da2a4f99be29eb749147" translate="yes" xml:space="preserve">
          <source>The policy used for allocating in the major heap. Possible values are 0, 1 and 2.</source>
          <target state="translated">주요 힙에 할당하는 데 사용되는 정책입니다. 가능한 값은 0, 1 및 2입니다.</target>
        </trans-unit>
        <trans-unit id="a0575e3a19290f6df5fdcaa47a106f8449112455" translate="yes" xml:space="preserve">
          <source>The polymorphic hash functions</source>
          <target state="translated">다형성 해시 함수</target>
        </trans-unit>
        <trans-unit id="10931e6e8e695da4d6f07c1443d2547e5cf128cc" translate="yes" xml:space="preserve">
          <source>The polymorphism may be left implicit in public method specifications: any type variable which is not bound to a class parameter and does not appear elsewhere inside the class specification will be assumed to be universal, and made polymorphic in the resulting method type. Writing an explicit polymorphic type will disable this behaviour.</source>
          <target state="translated">다형성은 공용 메서드 사양에 암시 적으로 남을 수 있습니다. 클래스 매개 변수에 바인딩되지 않고 클래스 사양 내부에 나타나지 않는 모든 유형 변수는 보편적 인 것으로 간주되고 결과 메서드 유형에서 다형성이됩니다. 명시 적 다형성 유형을 작성하면이 동작이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="46f55cdbce1c396ddb68caad025838e2c114c305" translate="yes" xml:space="preserve">
          <source>The precedence declarations are used in the following way to resolve reduce/reduce and shift/reduce conflicts:</source>
          <target state="translated">우선 순위 선언은 감소 / 감소 및 이동 / 감소 충돌을 해결하기 위해 다음과 같은 방식으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1442484d01949a40882f7fd1198334b88701ef0b" translate="yes" xml:space="preserve">
          <source>The pretty-printer must split the line at this point,</source>
          <target state="translated">프리티 프린터는이 시점에서 선을 쪼개 야합니다.</target>
        </trans-unit>
        <trans-unit id="e659673f1b18fb1d82b63a1c55173f87e4ba3218" translate="yes" xml:space="preserve">
          <source>The pretty-printing engine uses the concepts of pretty-printing box and break hint to drive indentation and line splitting behavior of the pretty-printer.</source>
          <target state="translated">pretty-printing 엔진은 pretty-printer의 들여 쓰기 및 줄 분할 동작을 유도하기 위해 pretty-printing box 및 break hint의 개념을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a53dbcb487f74a0958c713e69a144733631dbfe2" translate="yes" xml:space="preserve">
          <source>The pretty-printing functions output material that is delayed in the pretty-printer queue and stacks in order to compute proper line splitting. In contrast, basic I/O output functions write directly in their output device. As a consequence, the output of a basic I/O function may appear before the output of a pretty-printing function that has been called before. For instance, &lt;code&gt;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Stdlib.print_string&amp;nbsp;&quot;&amp;lt;&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Format.print_string&amp;nbsp;&quot;PRETTY&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Stdlib.print_string&amp;nbsp;&quot;&amp;gt;&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Format.print_string&amp;nbsp;&quot;TEXT&quot;;&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt; leads to output &lt;code&gt;&amp;lt;&amp;gt;PRETTYTEXT&lt;/code&gt;.</source>
          <target state="translated">pretty-printing 함수는 pretty-printer 대기열에서 지연되는 자료를 출력하고 적절한 라인 분할을 계산하기 위해 스택합니다. 반대로 기본 I / O 출력 함수는 출력 장치에 직접 기록합니다. 결과적으로 기본 I / O 함수의 출력은 이전에 호출 된 예쁜 인쇄 함수의 출력 전에 나타날 수 있습니다. 예를 들어, &lt;code&gt;&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Stdlib.print_string&amp;nbsp;&quot;&amp;lt;&quot;;&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Format.print_string&amp;nbsp;&quot;PRETTY&quot;;&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Stdlib.print_string&amp;nbsp;&quot;&amp;gt;&quot;;&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Format.print_string&amp;nbsp;&quot;TEXT&quot;;&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;gt;PRETTYTEXT&lt;/code&gt; 출력으로 이어집니다 .</target>
        </trans-unit>
        <trans-unit id="f51978ff177538bd6acc10bb07871f9792c046ef" translate="yes" xml:space="preserve">
          <source>The pretty-printing indication characters are introduced by a &lt;code&gt;@&lt;/code&gt; character, and their meanings are:</source>
          <target state="translated">예쁜 인쇄 표시 문자는 &lt;code&gt;@&lt;/code&gt; 문자 로 소개되며 그 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="433dda59f28a1c16b7f6ad751b61d21f14015c15" translate="yes" xml:space="preserve">
          <source>The previous coercion problem can often be avoided by first defining the abbreviation, using a class type:</source>
          <target state="translated">클래스 유형을 사용하여 먼저 약어를 정의하면 이전 강제 문제를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb0dbd05eb51d23e1a522b80e905369b8eb83ac6" translate="yes" xml:space="preserve">
          <source>The printing function printer-name should have type Format.formatter-&amp;gt;t-&amp;gt;unit, where t is the type for the values to be printed, and should output its textual representation for the value of type t on the given formatter, using the functions provided by the Format library. For backward compatibility, printer-name can also have type t-&amp;gt;unit and should then output on the standard formatter, but this usage is deprecated.</source>
          <target state="translated">인쇄 기능 printer-name은 Format.formatter-&amp;gt; t-&amp;gt; unit 유형을 가져야합니다. 여기서 t는 인쇄 할 값의 유형이며, 다음을 사용하여 지정된 포맷터의 t 유형 값에 대한 텍스트 표현을 출력해야합니다. 형식 라이브러리에서 제공하는 함수. 이전 버전과의 호환성을 위해 printer-name은 유형 t-&amp;gt; unit을 가질 수도 있으며 표준 포맷터에서 출력해야하지만이 사용법은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8883bf4f143303eb37a391cfe05fa314bafceca6" translate="yes" xml:space="preserve">
          <source>The problem here is that SET specifies the type element abstractly, so that the type equality between element in the result of the functor and t in its argument is forgotten. Consequently, WrongStringSet.element is not the same type as string, and the operations of WrongStringSet cannot be applied to strings. As demonstrated above, it is important that the type element in the signature SET be declared equal to Elt.t; unfortunately, this is impossible above since SET is defined in a context where Elt does not exist. To overcome this difficulty, OCaml provides a with type construct over signatures that allows enriching a signature with extra type equalities:</source>
          <target state="translated">여기서 문제는 SET가 유형 요소를 추상적으로 지정하므로 펑터 결과의 요소와 인수의 t 사이의 유형 동일성이 잊혀진다는 것입니다. 따라서 WrongStringSet.element는 문자열과 동일한 유형이 아니며 WrongStringSet의 작업을 문자열에 적용 할 수 없습니다. 위에서 설명한 것처럼 서명 SET의 유형 요소가 Elt.t와 동일하게 선언되어야합니다. 안타깝게도 SET는 Elt가 존재하지 않는 컨텍스트에서 정의되기 때문에 위의 경우 불가능합니다. 이러한 어려움을 극복하기 위해 OCaml은 추가 유형 동등성을 사용하여 서명을 강화할 수있는 서명에 대한 with 유형 구성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="79d5207edef86d719b23b481fee7c2e0aa2b94e6" translate="yes" xml:space="preserve">
          <source>The problem here is that quantification was wrongly located: it is not the class we want to be polymorphic, but the fold method. This can be achieved by giving an explicitly polymorphic type in the method definition.</source>
          <target state="translated">여기서 문제는 정량화의 위치가 잘못되었다는 것입니다. 다형성이 되고자하는 클래스가 아니라 fold 메서드입니다. 이것은 메서드 정의에 명시 적으로 다형성 유형을 제공하여 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d28eba679c98023f0747aaf9581f0f01fc941cfe" translate="yes" xml:space="preserve">
          <source>The process terminated normally by &lt;code&gt;exit&lt;/code&gt;; the argument is the return code.</source>
          <target state="translated">프로세스는 종료에 의해 정상적으로 &lt;code&gt;exit&lt;/code&gt; . 인수는 리턴 코드입니다.</target>
        </trans-unit>
        <trans-unit id="168ecaee8748c10e62b8f47e3dcea6c8cbd65579" translate="yes" xml:space="preserve">
          <source>The process was killed by a signal; the argument is the signal number.</source>
          <target state="translated">프로세스는 신호에 의해 종료되었습니다. 인수는 신호 번호입니다.</target>
        </trans-unit>
        <trans-unit id="34eaa6addd6d491cf217fc8965c116ada2b0beed" translate="yes" xml:space="preserve">
          <source>The process was stopped by a signal; the argument is the signal number.</source>
          <target state="translated">프로세스가 신호에 의해 중지되었습니다. 인수는 신호 번호입니다.</target>
        </trans-unit>
        <trans-unit id="c048c9cffeb4593d3904a5383fdb63616e02e942" translate="yes" xml:space="preserve">
          <source>The produced file has the executable bit set, and it manages to launch the bytecode interpreter by itself.</source>
          <target state="translated">생성 된 파일에는 실행 가능한 비트 세트가 있으며 자체적으로 바이트 코드 인터프리터를 시작하도록 관리합니다.</target>
        </trans-unit>
        <trans-unit id="5147f68b7fbbbd5f93868579353c15f80510e07f" translate="yes" xml:space="preserve">
          <source>The program behaves exactly as if the following phrases were entered at top-level:</source>
          <target state="translated">프로그램은 최상위 수준에서 다음 구문을 입력 한 것처럼 정확하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f484a5296a71c426225e4ed54accc59929e24d8b" translate="yes" xml:space="preserve">
          <source>The program being executed contains a &amp;ldquo;stray&amp;rdquo; exception. That is, it raises an exception at some point, and this exception is never caught. This causes immediate termination of the program. The name of the exception is printed, along with its string, byte sequence, and integer arguments (arguments of more complex types are not correctly printed). To locate the context of the uncaught exception, compile the program with the -g option and either run it again under the ocamldebug debugger (see chapter &lt;a href=&quot;debugger#c%3Adebugger&quot;&gt;17&lt;/a&gt;), or run it with ocamlrun -b or with the OCAMLRUNPARAM environment variable set to b=1.</source>
          <target state="translated">실행중인 프로그램에 &quot;stray&quot;예외가 있습니다. 즉, 어느 시점에서 예외가 발생하고이 예외는 포착되지 않습니다. 이로 인해 프로그램이 즉시 종료됩니다. 예외의 이름이 문자열, 바이트 시퀀스 및 정수 인수와 함께 인쇄됩니다 (더 복잡한 유형의 인수는 올바르게 인쇄되지 않음). 포착되지 않은 예외의 컨텍스트를 찾으려면 -g 옵션을 사용하여 프로그램을 컴파일하고 ocamldebug 디버거에서 다시 실행하거나 ( &lt;a href=&quot;debugger#c%3Adebugger&quot;&gt;17&lt;/a&gt; 장 참조 ) ocamlrun -b 또는 OCAMLRUNPARAM 환경 변수를 b = 1로 설정하여 실행합니다. .</target>
        </trans-unit>
        <trans-unit id="b266af3c49a1ad66480fec482895593ef57dff7e" translate="yes" xml:space="preserve">
          <source>The program being executed requires more memory than available. Either the program builds excessively large data structures; or the program contains too many nested function calls, and the stack overflows. In some cases, your program is perfectly correct, it just requires more memory than your machine provides. In other cases, the &amp;ldquo;out of memory&amp;rdquo; message reveals an error in your program: non-terminating recursive function, allocation of an excessively large array, string or byte sequence, attempts to build an infinite list or other data structure, &amp;hellip;</source>
          <target state="translated">실행중인 프로그램에 사용 가능한 것보다 더 많은 메모리가 필요합니다. 프로그램이 지나치게 큰 데이터 구조를 구축합니다. 또는 프로그램에 중첩 된 함수 호출이 너무 많이 포함되어 스택 오버플로가 발생합니다. 어떤 경우에는 프로그램이 완벽하게 정확하며 컴퓨터가 제공하는 것보다 더 많은 메모리 만 필요합니다. 다른 경우에 &quot;메모리 부족&quot;메시지는 프로그램의 오류를 나타냅니다. 종료되지 않는 재귀 함수, 지나치게 큰 배열 할당, 문자열 또는 바이트 시퀀스, 무한 목록 또는 기타 데이터 구조 구축 시도,&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="a503f7e4a9e093239bc1734598a0ac0302624fc9" translate="yes" xml:space="preserve">
          <source>The program being profiled must exit normally or be caused to exit using the SIGINT signal (e.g. by pressing Ctrl+C). When the program exits files will be written in the directory that was the working directory when the program was started. One Spacetime file will be written for each process that was involved, indexed by process ID; there will normally only be one such. The Spacetime files may be substantial. The directory to which they are written may be overridden by setting the OCAML_SPACETIME_SNAPSHOT_DIR environment variable before the program is started.</source>
          <target state="translated">프로파일 링중인 프로그램은 정상적으로 종료되거나 SIGINT 신호를 사용하여 종료되어야합니다 (예 : Ctrl + C 누르기). 프로그램이 종료되면 프로그램이 시작될 때 작업 디렉토리였던 디렉토리에 파일이 기록됩니다. 관련된 각 프로세스에 대해 하나의 Spacetime 파일이 작성되고 프로세스 ID별로 인덱싱됩니다. 일반적으로 그러한 것은 하나만있을 것입니다. Spacetime 파일은 상당 할 수 있습니다. 프로그램이 시작되기 전에 OCAML_SPACETIME_SNAPSHOT_DIR 환경 변수를 설정하여 기록 된 디렉토리를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cc4a8046bc314aed242125f697f2a900a2c88e8" translate="yes" xml:space="preserve">
          <source>The program is run directly by the debugger. This is the default mode.</source>
          <target state="translated">프로그램은 디버거에 의해 직접 실행됩니다. 이것이 기본 모드입니다.</target>
        </trans-unit>
        <trans-unit id="869eb5aeb2fdd87b2a28ba89f60a8c2af784a6d6" translate="yes" xml:space="preserve">
          <source>The program will have to start event collection explicitly. Starting and stopping event collection programmatically can be done by calling Gc.eventlog_resume and Gc.eventlog_pause) from within the program. Refer to the &lt;a href=&quot;libref/gc&quot;&gt;Gc&lt;/a&gt; module documentation for more information.</source>
          <target state="translated">프로그램은 이벤트 수집을 명시 적으로 시작해야합니다. 프로그램 내에서 Gc.eventlog_resume 및 Gc.eventlog_pause)를 호출하여 이벤트 수집을 프로그래밍 방식으로 시작 및 중지 할 수 있습니다. 자세한 정보 는 &lt;a href=&quot;libref/gc&quot;&gt;Gc&lt;/a&gt; 모듈 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="07c2399b10db28be424b9d95192597cf13943884" translate="yes" xml:space="preserve">
          <source>The projections from p may be replaced by uses of the variables x and y, potentially meaning that p becomes unused.</source>
          <target state="translated">p의 예측은 변수 x 및 y의 사용으로 대체 될 수 있으며 이는 잠재적으로 p가 사용되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0e07f245bb0c49e7a50bc84525e1cacf4689e631" translate="yes" xml:space="preserve">
          <source>The propagation can help to eliminate allocations in cases such as:</source>
          <target state="translated">전파는 다음과 같은 경우 할당을 제거하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f79e766e028d6e095da9d529d5a9dfbe0498d920" translate="yes" xml:space="preserve">
          <source>The propagation performed by the simplification pass is also important for discovering which functions flow to indirect call sites. This can enable the transformation of such call sites into direct call sites, which makes them eligible for an inlining transformation.</source>
          <target state="translated">단순화 단계에 의해 수행되는 전파는 간접 호출 사이트로 흐르는 함수를 발견하는데도 중요합니다. 이를 통해 이러한 호출 사이트를 직접 호출 사이트로 변환 할 수 있으므로 인라인 변환에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="94c9da3eb2e38629000eda75e07fe34fd5562fd6" translate="yes" xml:space="preserve">
          <source>The reason for the error: unknown option, invalid or missing argument, etc.</source>
          <target state="translated">오류의 원인 : 알 수없는 옵션, 유효하지 않거나 누락 된 인수 등</target>
        </trans-unit>
        <trans-unit id="a43dbd7b9edc2247945720db7869546aded72b86" translate="yes" xml:space="preserve">
          <source>The reason is that at least one of the methods has a polymorphic type (here, the type of the value stored in the reference cell), thus either the class should be parametric, or the method type should be constrained to a monomorphic type. A monomorphic instance of the class could be defined by:</source>
          <target state="translated">그 이유는 메서드 중 하나 이상이 다형성 유형 (여기서는 참조 셀에 저장된 값의 유형)을 가지고 있으므로 클래스가 매개 변수 여야하거나 메서드 유형이 단 형성 유형으로 제한되어야하기 때문입니다. 클래스의 모노 모픽 인스턴스는 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="072461fde3d0d8b6efbc5a6868695ccf66c6f021" translate="yes" xml:space="preserve">
          <source>The reason this is unsafe is because the simplification pass believes that fst a holds the value 42; and indeed it must, unless type soundness has been broken via unsafe operations.</source>
          <target state="translated">이것이 안전하지 않은 이유는 단순화 패스가 fst a가 42 값을 보유하고 있다고 믿기 때문입니다. 안전하지 않은 작업을 통해 유형 건전성이 깨지지 않는 한 실제로는 그래야합니다.</target>
        </trans-unit>
        <trans-unit id="c67a48b57781f36d335583c6c3fd5c675bbebd44" translate="yes" xml:space="preserve">
          <source>The recursive definition is guaranteed to behave as described above if the expressions &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are function definitions (fun &amp;hellip; or function &amp;hellip;), and the patterns &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; are just value names, as in:</source>
          <target state="translated">재귀 적 정의는 표현식 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ~ &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 이 함수 정의 (fun&amp;hellip; 또는 function&amp;hellip;)이고 패턴 &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 이 다음과 같이 값 이름 인 경우 위에서 설명한대로 작동하도록 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="be50e5ba6751e078d213ea17d81f37abaeae3a78" translate="yes" xml:space="preserve">
          <source>The registration causes the contents of the variable or memory location to be updated by the garbage collector whenever the value in such variable or location is moved within the OCaml heap. In the presence of threads care must be taken to ensure appropriate synchronisation with the OCaml runtime to avoid a race condition against the garbage collector when reading or writing the value. (See section &lt;a href=&quot;#ss%3Aparallel-execution-long-running-c-code&quot;&gt;20.12.2&lt;/a&gt;.)</source>
          <target state="translated">등록은 해당 변수 또는 위치의 값이 OCaml 힙 내에서 이동할 때마다 가비지 수집기에 의해 변수 또는 메모리 위치의 내용이 업데이트되도록합니다. 스레드가있는 경우 값을 읽거나 쓸 때 가비지 수집기에 대한 경쟁 조건을 피하기 위해 OCaml 런타임과의 적절한 동기화를 보장하기 위해주의를 기울여야합니다. (섹션 &lt;a href=&quot;#ss%3Aparallel-execution-long-running-c-code&quot;&gt;20.12.2&lt;/a&gt; 참조 .)</target>
        </trans-unit>
        <trans-unit id="e498792eb5a8e5a1f7711c5d76148d563e2627fe" translate="yes" xml:space="preserve">
          <source>The registration mechanism described above can also be used to communicate exception identifiers from OCaml to C. The OCaml code registers the exception by evaluating Callback.register_exceptionn exn, where n is an arbitrary name and exn is an exception value of the exception to register. For example:</source>
          <target state="translated">위에서 설명한 등록 메커니즘을 사용하여 OCaml에서 C로 예외 식별자를 전달할 수도 있습니다. OCaml 코드는 Callback.register_exceptionn exn을 평가하여 예외를 등록합니다. 여기서 n은 임의의 이름이고 exn은 등록 할 예외의 예외 값입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="7e412ad57efe185f94f3f66dee663594387b73ec" translate="yes" xml:space="preserve">
          <source>The regular expressions are in the style of lex, with a more OCaml-like syntax.</source>
          <target state="translated">정규 표현식은 더 OCaml과 유사한 구문을 사용하는 lex 스타일입니다.</target>
        </trans-unit>
        <trans-unit id="ca763eb3bdb448bf22bb32fc59cd71ec5db35a9f" translate="yes" xml:space="preserve">
          <source>The representation is chosen according to the following, in decreasing order of priority:</source>
          <target state="translated">표현은 우선 순위 내림차순으로 다음에 따라 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="6cb9b87429c5694aec26392deb0ded32f7bf6b82" translate="yes" xml:space="preserve">
          <source>The representation of marshaled values is not human-readable, and uses bytes that are not printable characters. Therefore, input and output channels used in conjunction with &lt;code&gt;Marshal.to_channel&lt;/code&gt; and &lt;code&gt;Marshal.from_channel&lt;/code&gt; must be opened in binary mode, using e.g. &lt;code&gt;open_out_bin&lt;/code&gt; or &lt;code&gt;open_in_bin&lt;/code&gt;; channels opened in text mode will cause unmarshaling errors on platforms where text channels behave differently than binary channels, e.g. Windows.</source>
          <target state="translated">마샬링 된 값의 표현은 사람이 읽을 수 없으며 인쇄 가능한 문자가 아닌 바이트를 사용합니다. 따라서 &lt;code&gt;Marshal.to_channel&lt;/code&gt; 및 &lt;code&gt;Marshal.from_channel&lt;/code&gt; 과 함께 사용되는 입력 및 출력 채널 은 예를 들어 &lt;code&gt;open_out_bin&lt;/code&gt; 또는 &lt;code&gt;open_in_bin&lt;/code&gt; 을 사용하여 바이너리 모드로 열어야합니다 . 텍스트 모드에서 열린 채널은 텍스트 채널이 이진 채널과 다르게 동작하는 플랫폼 (예 : Windows)에서 비 정렬 화 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b30fdf8a2c0fb75299c4dafd61caaf7a19cc1857" translate="yes" xml:space="preserve">
          <source>The rest of the binding is the same for both platforms:</source>
          <target state="translated">나머지 바인딩은 두 플랫폼에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="44c9e601546b4f760808bdd19852d33ad5355c07" translate="yes" xml:space="preserve">
          <source>The restriction can also be performed during the definition of the structure, as in</source>
          <target state="translated">제한은 다음과 같이 구조를 정의하는 동안 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc0357393d60a0f1fa7baa5274ba71a46d90f408" translate="yes" xml:space="preserve">
          <source>The resulting P.cmx object file has sub-modules P.Q, P.Q.A and P.B.</source>
          <target state="translated">결과 P.cmx 개체 파일에는 하위 모듈 PQ, PQA 및 PB가 있습니다.</target>
        </trans-unit>
        <trans-unit id="540f70e6d81a40f7974a7c5702a14ef36eff5dc8" translate="yes" xml:space="preserve">
          <source>The resulting benefit value is known as the &lt;em&gt;estimated benefit&lt;/em&gt;.</source>
          <target state="translated">결과적인 이익 가치는 &lt;em&gt;추정 이익으로&lt;/em&gt; 알려져 &lt;em&gt;있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f24d01c073b212c7b11b8ff5380c3e1f163e921d" translate="yes" xml:space="preserve">
          <source>The resulting program can then be traced by running it with the environment variable OCAML_EVENTLOG_ENABLED:</source>
          <target state="translated">결과 프로그램은 환경 변수 OCAML_EVENTLOG_ENABLED로 실행하여 추적 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0936bfa6fa4fa6c80130298ea1d5af175d858507" translate="yes" xml:space="preserve">
          <source>The resulting trace contains only one event payload, namely a &lt;em&gt;flush&lt;/em&gt; event, indicating how much time was spent flushing the trace file to disk.</source>
          <target state="translated">결과 추적에는 추적 파일을 디스크로 플러시하는 데 소요 된 시간을 나타내는 &lt;em&gt;플러시&lt;/em&gt; 이벤트 라는 하나의 이벤트 페이로드 만 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ed3a555a7ebebf96c3208ad39f845704f68067a" translate="yes" xml:space="preserve">
          <source>The resulting trace will contain all events encountered during the program&amp;rsquo;s execution:</source>
          <target state="translated">결과 추적에는 프로그램 실행 중에 발생한 모든 이벤트가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="76a2e5fedee04aeb14150359846ceeb930560151" translate="yes" xml:space="preserve">
          <source>The results of calling &lt;a href=&quot;string#VALmake&quot;&gt;&lt;code&gt;String.make&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes#VALmake&quot;&gt;&lt;code&gt;Bytes.make&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes#VALcreate&quot;&gt;&lt;code&gt;Bytes.create&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#VALmake&quot;&gt;&lt;code&gt;Array.make&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;stdlib#VALref&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; are guaranteed to be heap-allocated and non-constant except when the length argument is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;string#VALmake&quot;&gt; &lt;code&gt;String.make&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;bytes#VALmake&quot;&gt; &lt;code&gt;Bytes.make&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;bytes#VALcreate&quot;&gt; &lt;code&gt;Bytes.create&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;array#VALmake&quot;&gt; &lt;code&gt;Array.make&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stdlib#VALref&quot;&gt; &lt;code&gt;ref&lt;/code&gt; &lt;/a&gt; 를 호출 한 결과 는 길이 인수가 &lt;code&gt;0&lt;/code&gt; 인 경우를 제외하고는 힙 할당 및 비 상수가 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="dab88c1cb3eef6aab0ce452f5d3a24ee29766571" translate="yes" xml:space="preserve">
          <source>The right way to solve this problem for optional parameters is to add a type annotation to the argument bump.</source>
          <target state="translated">선택적 매개 변수에 대해이 문제를 해결하는 올바른 방법은 인수 범프에 유형 주석을 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="021484aa4f766fbe935de88999e6cb6d7bb47d1e" translate="yes" xml:space="preserve">
          <source>The rules may contain the special symbol error to indicate resynchronization points, as in yacc.</source>
          <target state="translated">규칙에는 yacc에서와 같이 재 동기화 지점을 나타내는 특수 기호 오류가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2425e4fb8fd4780c2506baebfe7345c64646daa" translate="yes" xml:space="preserve">
          <source>The run-time library for lexers generated by &lt;code&gt;ocamllex&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ocamllex&lt;/code&gt; 에 의해 생성 된 렉서 용 런타임 라이브러리 .</target>
        </trans-unit>
        <trans-unit id="2d4e630606c50faf5f2e5b24a4b0bf1a04b6c5db" translate="yes" xml:space="preserve">
          <source>The run-time library for parsers generated by &lt;code&gt;ocamlyacc&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ocamlyacc&lt;/code&gt; 에 의해 생성 된 파서 용 런타임 라이브러리입니다 .</target>
        </trans-unit>
        <trans-unit id="b06b765c6160900806a7c7c50af837787bf9890a" translate="yes" xml:space="preserve">
          <source>The runtime overhead imposed by Spacetime varies considerably depending on the particular program being profiled. The overhead may be as low as ten percent&amp;mdash;but more usually programs should be expected to run at perhaps a third or quarter of their normal speed. It is expected that this overhead will be reduced in future versions of the compiler.</source>
          <target state="translated">Spacetime에 의해 부과되는 런타임 오버 헤드는 프로파일 링되는 특정 프로그램에 따라 상당히 다릅니다. 오버 헤드는 10 %까지 낮을 수 있지만 일반적으로 프로그램은 정상 속도의 3 분의 1 또는 4 분의 1로 실행될 것으로 예상됩니다. 이 오버 헤드는 향후 버전의 컴파일러에서 줄어들 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="7ef99f2b64955164c9593d8e632198f04c1ea43d" translate="yes" xml:space="preserve">
          <source>The runtime representation of a function. This includes pointers to the code of the function together with the values of any variables that are used in the body of the function but actually defined outside of the function, in the enclosing scope. The values of such variables, collectively known as the &lt;em&gt;environment&lt;/em&gt;, are required because the function may be invoked from a place where the original bindings of such variables are no longer in scope. A group of possibly mutually-recursive functions defined using &lt;em&gt;let rec&lt;/em&gt; all share a single closure. (Note to developers: in the Flambda source code a &lt;em&gt;closure&lt;/em&gt; always corresponds to a single function; a &lt;em&gt;set of closures&lt;/em&gt; refers to a group of such.)</source>
          <target state="translated">함수의 런타임 표현입니다. 여기에는 함수 본문에 사용되지만 실제로 함수 외부에서 둘러싸는 범위에 정의 된 변수 값과 함께 함수 코드에 대한 포인터가 포함됩니다. 이러한 변수 의 원래 바인딩이 더 이상 범위에 포함되지 않는 위치에서 함수가 호출 될 수 있으므로 이러한 변수의 값 (통칭하여 &lt;em&gt;환경&lt;/em&gt; )이 필요합니다. &lt;em&gt;let rec를&lt;/em&gt; 사용하여 정의 된 상호 재귀 함수 그룹은 모두 단일 클로저를 공유합니다. (개발자 참고 사항 : Flambda 소스 코드에서 &lt;em&gt;클로저는&lt;/em&gt; 항상 단일 함수에 해당합니다. &lt;em&gt;클로저 세트&lt;/em&gt; 는 그러한 그룹을 나타냅니다.)</target>
        </trans-unit>
        <trans-unit id="09e0b17c8f9005f5c598030be2554c687ccaa24d" translate="yes" xml:space="preserve">
          <source>The same feature is provided for method definitions.</source>
          <target state="translated">메서드 정의에 대해 동일한 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f69459bd2efc915e393510bd7d020112db264859" translate="yes" xml:space="preserve">
          <source>The same goes for &lt;code&gt;set_double_field&lt;/code&gt; and &lt;code&gt;set_tag&lt;/code&gt;. However, for &lt;code&gt;set_tag&lt;/code&gt;, in the case of immutable blocks where the middle-end optimizers never see code that discriminates on their tag (for example records), the operation should be safe. Such uses are nonetheless discouraged.</source>
          <target state="translated">동일은 간다 &lt;code&gt;set_double_field&lt;/code&gt; 및 &lt;code&gt;set_tag&lt;/code&gt; . 그러나 &lt;code&gt;set_tag&lt;/code&gt; 의 경우 중간 엔드 옵티마이 저가 태그 (예 : 레코드)를 식별하는 코드를 보지 못하는 불변 블록의 경우 작업이 안전해야합니다. 그럼에도 불구하고 이러한 사용은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c251a3b5f6c58244053faab7ecc98ddabddcb4f0" translate="yes" xml:space="preserve">
          <source>The same ownership discipline that makes &lt;code&gt;unsafe_to_string&lt;/code&gt; correct applies to &lt;code&gt;unsafe_of_string&lt;/code&gt;: you may use it if you were the owner of the &lt;code&gt;string&lt;/code&gt; value, and you will own the return &lt;code&gt;bytes&lt;/code&gt; in the same mode.</source>
          <target state="translated">만드는 동일한 소유권 분야 &lt;code&gt;unsafe_to_string&lt;/code&gt; 가 올바른 정보는 다음의 제품에 적용 &lt;code&gt;unsafe_of_string&lt;/code&gt; : 당신의 소유자 인 경우에 당신은 그것을 사용할 수 있습니다 &lt;code&gt;string&lt;/code&gt; 값, 당신은 반환이 소유 할 &lt;code&gt;bytes&lt;/code&gt; 같은 모드.</target>
        </trans-unit>
        <trans-unit id="1ac338637d2a5fce3a9f3793f3f8813dc5e79b82" translate="yes" xml:space="preserve">
          <source>The same shortcut is available for enumerated lists, using &amp;rsquo;+&amp;rsquo; instead of &amp;rsquo;-&amp;rsquo;. Note that only one list can be defined by this shortcut in nested lists.</source>
          <target state="translated">'-'대신 '+'를 사용하여 열거 된 목록에 동일한 바로 가기를 사용할 수 있습니다. 중첩 된 목록에서이 바로 가기로 하나의 목록 만 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a96000f19b19300268f15d1d76e944ef3a1ebf04" translate="yes" xml:space="preserve">
          <source>The same syntactic form is also used to attach attributes to labels and constructors in type declarations:</source>
          <target state="translated">동일한 구문 형식이 유형 선언의 레이블 및 생성자에 속성을 첨부하는데도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c56f9cdc02f4eaf0671121f748c04b2b039e6299" translate="yes" xml:space="preserve">
          <source>The scanning indications introduce slight differences in the syntax of &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; format strings, compared to those used for the &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt; module. However, the scanning indications are similar to those used in the &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; module; hence, when producing formatted text to be scanned by &lt;a href=&quot;scanf#VALbscanf&quot;&gt;&lt;code&gt;Scanf.bscanf&lt;/code&gt;&lt;/a&gt;, it is wise to use printing functions from the &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; module (or, if you need to use functions from &lt;a href=&quot;printf&quot;&gt;&lt;code&gt;Printf&lt;/code&gt;&lt;/a&gt;, banish or carefully double check the format strings that contain &lt;code&gt;'@'&lt;/code&gt; characters).</source>
          <target state="translated">스캔 표시 는 &lt;a href=&quot;printf&quot;&gt; &lt;code&gt;Printf&lt;/code&gt; &lt;/a&gt; 모듈에 사용 된 것과 비교하여 &lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt; 형식 문자열 의 구문에 약간의 차이를 제공합니다 . 그러나 스캐닝 ​​표시는 &lt;a href=&quot;format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt; 모듈 에서 사용되는 것과 유사 합니다. 따라서 &lt;a href=&quot;scanf#VALbscanf&quot;&gt; &lt;code&gt;Scanf.bscanf&lt;/code&gt; &lt;/a&gt; 로 스캔 할 서식있는 텍스트를 생성 할 때 &lt;a href=&quot;format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt; 모듈의 인쇄 기능을 사용하는 것이 좋습니다 (또는 &lt;a href=&quot;printf&quot;&gt; &lt;code&gt;Printf&lt;/code&gt; 의&lt;/a&gt; 함수를 사용해야 하는 경우 &lt;code&gt;'@'&lt;/code&gt; 이 포함 된 형식 문자열을 삭제하거나 신중하게 다시 확인하십시오. 문자).</target>
        </trans-unit>
        <trans-unit id="d497c2d6e07b975e5682bc991cd842d916c5c070" translate="yes" xml:space="preserve">
          <source>The second case is an open variant type, describing a polymorphic variant value: it gives the list of all tags the value could take, with their associated types. This type is still compatible with a variant type containing more tags. A special case is the unknown type, which does not define any tag, and is compatible with any variant type.</source>
          <target state="translated">두 번째 경우는 다형성 변형 값을 설명하는 개방형 변형 유형입니다. 이는 값이 취할 수있는 모든 태그 목록을 관련 유형과 함께 제공합니다. 이 유형은 더 많은 태그를 포함하는 변형 유형과 여전히 호환됩니다. 특별한 경우는 태그를 정의하지 않고 모든 변형 유형과 호환되는 알 수없는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f4cd062edd42fc49d3c066f95872cdcd6b75a514" translate="yes" xml:space="preserve">
          <source>The second drawback of dynamic linking is that it complicates the construction of the library. The C compiler and linker flags to compile to position-independent code and build a shared library vary wildly between different Unix systems. Also, dynamic linking is not supported on all Unix systems, requiring a fall-back case to static linking in the Makefile for the library. The ocamlmklib command (see section &lt;a href=&quot;#s%3Aocamlmklib&quot;&gt;20.14&lt;/a&gt;) tries to hide some of these system dependencies.</source>
          <target state="translated">동적 연결의 두 번째 단점은 라이브러리 구성이 복잡하다는 것입니다. 위치 독립적 코드로 컴파일하고 공유 라이브러리를 빌드하는 C 컴파일러 및 링커 플래그는 Unix 시스템마다 크게 다릅니다. 또한 동적 링크는 모든 Unix 시스템에서 지원되지 않으므로 라이브러리에 대한 Makefile의 정적 링크에 대한 폴백 케이스가 필요합니다. ocamlmklib 명령 (섹션 &lt;a href=&quot;#s%3Aocamlmklib&quot;&gt;20.14&lt;/a&gt; 참조 )은 이러한 시스템 종속성 중 일부를 숨기려고합니다.</target>
        </trans-unit>
        <trans-unit id="f1cce543693960e06654a40bc08d8813b14f9075" translate="yes" xml:space="preserve">
          <source>The second example is more subtle: while we intended the argument bump to be of type ?step:int -&amp;gt; int -&amp;gt; int, it is inferred as step:int -&amp;gt; int -&amp;gt; 'a. These two types being incompatible (internally normal and optional arguments are different), a type error occurs when applying bump_it to the real bump.</source>
          <target state="translated">두 번째 예제는 더 미묘합니다. 우리가 인수 bump를? step : int-&amp;gt; int-&amp;gt; int 유형으로 의도했지만 step : int-&amp;gt; int-&amp;gt; 'a로 추론됩니다. 이 두 유형은 호환되지 않으며 (내부적으로 정상인 인수와 선택적 인수가 다름) 실제 bump에 bump_it를 적용 할 때 유형 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9d4ee921aaa1ec3723cdbada30294d66c801a5b5" translate="yes" xml:space="preserve">
          <source>The second form of attributes are attached to &amp;ldquo;blocks&amp;rdquo; such as type declarations, class fields, etc:</source>
          <target state="translated">두 번째 형식의 속성은 유형 선언, 클래스 필드 등과 같은 &quot;블록&quot;에 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="4bcf7cdc991e4c97ac21aa1c7ae7ff5801e85d37" translate="yes" xml:space="preserve">
          <source>The second major class of non-genericity is directly related to the problem of type inference for polymorphic functions. In some circumstances, the type inferred by OCaml might be not general enough to allow the definition of some recursive functions, in particular for recursive function acting on non-regular algebraic data type.</source>
          <target state="translated">비 제네릭의 두 번째 주요 클래스는 다형성 함수에 대한 유형 추론 문제와 직접 관련이 있습니다. 어떤 상황에서는 OCaml에 의해 추론 된 유형이 일부 재귀 함수, 특히 비정규 대수 데이터 유형에 작용하는 재귀 함수의 정의를 허용하기에 충분히 일반적이지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddae56c7d78a1170cc9452541524e5c04728b654" translate="yes" xml:space="preserve">
          <source>The semantic tag handling functions specific to a formatter: &lt;code&gt;mark&lt;/code&gt; versions are the 'tag-marking' functions that associate a string marker to a tag in order for the pretty-printing engine to write those markers as 0 length tokens in the output device of the formatter.</source>
          <target state="translated">포맷터에 특정한 의미 태그 처리 기능 : &lt;code&gt;mark&lt;/code&gt; 버전은 프리티 프린팅 엔진이 해당 마커를 출력 장치의 길이가 0 인 토큰으로 작성하기 위해 문자열 마커를 태그에 연결하는 '태그 표시'함수입니다. 포맷터.</target>
        </trans-unit>
        <trans-unit id="bff7da471def393c1b371feaa59a0379272afe47" translate="yes" xml:space="preserve">
          <source>The semantic tag handling functions specific to a formatter: &lt;code&gt;mark&lt;/code&gt; versions are the 'tag-marking' functions that associate a string marker to a tag in order for the pretty-printing engine to write those markers as 0 length tokens in the output device of the formatter. &lt;code&gt;print&lt;/code&gt; versions are the 'tag-printing' functions that can perform regular printing when a tag is closed or opened.</source>
          <target state="translated">포맷터에 특정한 의미 태그 처리 기능 : &lt;code&gt;mark&lt;/code&gt; 버전은 프리티 프린팅 엔진이 해당 마커를 출력 장치의 길이가 0 인 토큰으로 작성하기 위해 문자열 마커를 태그에 연결하는 '태그 표시'함수입니다. 포맷터. &lt;code&gt;print&lt;/code&gt; 버전은 태그가 닫히거나 열릴 때 일반 인쇄를 수행 할 수있는 '태그 인쇄'기능입니다.</target>
        </trans-unit>
        <trans-unit id="2bcc6c39a05b6e4644ddb92b4ebfbec3f0bd5823" translate="yes" xml:space="preserve">
          <source>The semantics is clear: match the scrutinee against the pattern, if it matches, test the guard, and if the guard passes, take the branch. In particular, consider the input (Consta, Constb), where a fails the test is_neutrala, while b passes the test is_neutralb. With the left-to-right semantics, the clause above is &lt;em&gt;not&lt;/em&gt; taken by its input: matching (Consta, Constb) against the or-pattern succeeds in the left branch, it returns the environment x-&amp;gt;a, and then the guard is_neutrala is tested and fails, the branch is not taken.</source>
          <target state="translated">의미는 명확합니다. 스크 루틴을 패턴과 일치시키고 일치하면 가드를 테스트하고 가드가 통과하면 분기를 가져옵니다. 특히, 입력 (Consta, Constb)을 고려하십시오. 여기서 a는 테스트를 통과하지 못하면 is_neutrala이고 b는 테스트를 통과합니다. is_neutralb. 왼쪽에서 오른쪽으로 의미 체계를 사용하면 위의 절 은 입력으로 취하지 &lt;em&gt;않습니다&lt;/em&gt; . or 패턴에 대한 일치 (Consta, Constb)가 왼쪽 분기에서 성공하고 x-&amp;gt; a 환경을 반환 한 다음 가드가 is_neutrala 테스트되고 실패하면 분기가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a1ca7a03baad7716212210f3fc88fe09e15dd50" translate="yes" xml:space="preserve">
          <source>The semantics of or-patterns in OCaml is specified with a left-to-right bias: a value v matches the pattern p|q if it matches p or q, but if it matches both, the environment captured by the match is the environment captured by p, never the one captured by q.</source>
          <target state="translated">OCaml에서 or- 패턴의 의미는 왼쪽에서 오른쪽으로 편향되어 지정됩니다. 값 v는 p 또는 q와 일치하면 p | q 패턴과 일치하지만 둘 다 일치하면 일치에 의해 캡처 된 환경이 환경입니다. p에 의해 캡처되고 q에 의해 캡처 된 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="33bae5ab3c39edb36e6026c0e18053f2831c7697" translate="yes" xml:space="preserve">
          <source>The serialize field can be set to custom_serialize_default, in which case the Failure exception is raised when attempting to serialize the custom block.</source>
          <target state="translated">serialize 필드는 custom_serialize_default로 설정할 수 있습니다.이 경우 사용자 지정 블록을 직렬화하려고 할 때 실패 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d40ce64ff61f966dff5d5f82bc2dc3bb7256bb8b" translate="yes" xml:space="preserve">
          <source>The serialize field contains a pointer to a C function that is called whenever the custom block needs to be serialized (marshaled) using the OCaml functions output_value or Marshal.to_.... For a custom block, those functions first write the identifier of the block (as given by the identifier field) to the output stream, then call the user-provided serialize function. That function is responsible for writing the data contained in the custom block, using the serialize_... functions defined in &amp;lt;caml/intext.h&amp;gt; and listed below. The user-provided serialize function must then store in its bsize_32 and bsize_64 parameters the sizes in bytes of the data part of the custom block on a 32-bit architecture and on a 64-bit architecture, respectively.</source>
          <target state="translated">직렬화 필드에는 OCaml 함수 output_value 또는 Marshal.to _....를 사용하여 사용자 정의 블록을 직렬화 (마샬링)해야 할 때마다 호출되는 C 함수에 대한 포인터가 포함되어 있습니다. 블록 (식별자 필드에 의해 제공됨)을 출력 스트림에 추가 한 다음 사용자가 제공 한 직렬화 함수를 호출합니다. 이 함수는 &amp;lt;caml / intext.h&amp;gt;에 정의되고 아래에 나열된 serialize _... 함수를 사용하여 사용자 정의 블록에 포함 된 데이터를 작성합니다. 사용자가 제공 한 직렬화 함수는 32 비트 아키텍처와 64 비트 아키텍처에서 각각 사용자 정의 블록의 데이터 부분 크기를 bsize_32 및 bsize_64 매개 변수에 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="d2942136b250ae1097e80c746ad490f52ed3542e" translate="yes" xml:space="preserve">
          <source>The set of command line flags relating to optimisation should typically be specified to be the same across an entire project. Flambda does not currently record the requested flags in the .cmx files. As such, inlining of functions from previously-compiled units will subject their code to the optimisation parameters of the unit currently being compiled, rather than those specified when they were previously compiled. It is hoped to rectify this deficiency in the future.</source>
          <target state="translated">최적화와 관련된 명령 줄 플래그 집합은 일반적으로 전체 프로젝트에서 동일하게 지정되어야합니다. Flambda는 현재 요청 된 플래그를 .cmx 파일에 기록하지 않습니다. 따라서 이전에 컴파일 된 유닛에서 함수를 인라인하면 이전에 컴파일되었을 때 지정된 것이 아니라 현재 컴파일중인 유닛의 최적화 매개 변수에 해당 코드가 적용됩니다. 향후 이러한 결함을 바로 잡을 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="75f7516c7000daca4e41898b962a62fb90ba554f" translate="yes" xml:space="preserve">
          <source>The set of output functions specific to a formatter:</source>
          <target state="translated">포맷터에 특정한 출력 함수 세트 :</target>
        </trans-unit>
        <trans-unit id="58f5c99c8953630f7d0eb9e43e64f07f7389a46f" translate="yes" xml:space="preserve">
          <source>The set of output functions specific to a formatter: the &lt;code&gt;out_string&lt;/code&gt; function performs all the pretty-printer string output. It is called with a string &lt;code&gt;s&lt;/code&gt;, a start position &lt;code&gt;p&lt;/code&gt;, and a number of characters &lt;code&gt;n&lt;/code&gt;; it is supposed to output characters &lt;code&gt;p&lt;/code&gt; to &lt;code&gt;p&amp;nbsp;+&amp;nbsp;n&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; of &lt;code&gt;s&lt;/code&gt;., the &lt;code&gt;out_flush&lt;/code&gt; function flushes the pretty-printer output device., &lt;code&gt;out_newline&lt;/code&gt; is called to open a new line when the pretty-printer splits the line., the &lt;code&gt;out_spaces&lt;/code&gt; function outputs spaces when a break hint leads to spaces instead of a line split. It is called with the number of spaces to output., the &lt;code&gt;out_indent&lt;/code&gt; function performs new line indentation when the pretty-printer splits the line. It is called with the indentation value of the new line. By default: fields &lt;code&gt;out_string&lt;/code&gt; and &lt;code&gt;out_flush&lt;/code&gt; are output device specific; (e.g. &lt;a href=&quot;stdlib#VALoutput_string&quot;&gt;&lt;code&gt;output_string&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdlib#VALflush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;stdlib#TYPEout_channel&quot;&gt;&lt;code&gt;out_channel&lt;/code&gt;&lt;/a&gt; device, or &lt;code&gt;Buffer.add_substring&lt;/code&gt; and &lt;a href=&quot;stdlib#VALignore&quot;&gt;&lt;code&gt;ignore&lt;/code&gt;&lt;/a&gt; for a &lt;code&gt;Buffer.t&lt;/code&gt; output device),, field &lt;code&gt;out_newline&lt;/code&gt; is equivalent to &lt;code&gt;out_string&amp;nbsp;&quot;\n&quot;&amp;nbsp;0&amp;nbsp;1&lt;/code&gt;;, fields &lt;code&gt;out_spaces&lt;/code&gt; and &lt;code&gt;out_indent&lt;/code&gt; are equivalent to &lt;code&gt;out_string&amp;nbsp;(String.make&amp;nbsp;n&amp;nbsp;'&amp;nbsp;')&amp;nbsp;0&amp;nbsp;n&lt;/code&gt;.</source>
          <target state="translated">포맷터에 특정한 출력 함수 세트 : &lt;code&gt;out_string&lt;/code&gt; 함수는 모든 예쁜 프린터 문자열 출력을 수행합니다. 문자열 &lt;code&gt;s&lt;/code&gt; , 시작 위치 &lt;code&gt;p&lt;/code&gt; 및 여러 문자 &lt;code&gt;n&lt;/code&gt; 으로 호출됩니다 . 이 출력 문자로되어 &lt;code&gt;p&lt;/code&gt; 행 &lt;code&gt;p&amp;nbsp;+&amp;nbsp;n&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; 의 &lt;code&gt;s&lt;/code&gt; . 상기 &lt;code&gt;out_flush&lt;/code&gt; 의 기능은 매우-프린터 출력 장치를 플러시. &lt;code&gt;out_newline&lt;/code&gt; 가 꽤 인쇄기 선을 분할 할 때 새로운 줄을 열이라고는. &lt;code&gt;out_spaces&lt;/code&gt; 의 함수 구분 힌트가 줄 분할 대신 공백으로 이어질 때 공백을 출력합니다. 출력 할 공백 수와 함께 호출됩니다., &lt;code&gt;out_indent&lt;/code&gt; 함수는 pretty-printer가 줄을 분할 할 때 새 줄 들여 쓰기를 수행합니다. 새 줄의 들여 쓰기 값으로 호출됩니다. 기본적으로 : &lt;code&gt;out_string&lt;/code&gt; 및 &lt;code&gt;out_flush&lt;/code&gt; 필드 는 출력 장치에 따라 다릅니다. (예 &lt;a href=&quot;stdlib#VALoutput_string&quot;&gt; &lt;code&gt;output_string&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stdlib#VALflush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; A의 &lt;a href=&quot;stdlib#TYPEout_channel&quot;&gt; &lt;code&gt;out_channel&lt;/code&gt; 의&lt;/a&gt; 장치 또는 &lt;code&gt;Buffer.add_substring&lt;/code&gt; 및 &lt;a href=&quot;stdlib#VALignore&quot;&gt; &lt;code&gt;ignore&lt;/code&gt; &lt;/a&gt; A의 &lt;code&gt;Buffer.t&lt;/code&gt; 의 출력 장치) ,, 필드 &lt;code&gt;out_newline&lt;/code&gt; 가 동등 &lt;code&gt;out_string&amp;nbsp;&quot;\n&quot;&amp;nbsp;0&amp;nbsp;1&lt;/code&gt; ], 필드 &lt;code&gt;out_spaces&lt;/code&gt; 및 &lt;code&gt;out_indent&lt;/code&gt; 은 동등 &lt;code&gt;out_string&amp;nbsp;(String.make&amp;nbsp;n&amp;nbsp;'&amp;nbsp;')&amp;nbsp;0&amp;nbsp;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fe430d7f65b9a4115dd36213fde72e2766eb905" translate="yes" xml:space="preserve">
          <source>The short expressions are translated into calls to functions of the Bigarray module as described in the following table.</source>
          <target state="translated">짧은 표현식은 다음 표에 설명 된대로 Bigarray 모듈의 함수에 대한 호출로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="3ec3650bd7c2cf484db50a370f6c089d2295064a" translate="yes" xml:space="preserve">
          <source>The signature MYHASH then contains all the fields of the signature of the module Hashtbl (with strengthened type definitions), plus the new field replace. An implementation of this signature can be obtained easily by using the include construct again, but this time at the structure level:</source>
          <target state="translated">그런 다음 서명 MYHASH에는 모듈 Hashtbl (강화 된 유형 정의 포함) 서명의 모든 필드와 새 필드 교체가 포함됩니다. 이 서명의 구현은 include 구문을 다시 사용하여 쉽게 얻을 수 있지만 이번에는 구조 수준에서 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70846c98b1e5f76d1a8eeae9357dba832f61e830" translate="yes" xml:space="preserve">
          <source>The simplification pass removes unused let bindings so long as their corresponding defining expressions have &amp;ldquo;no effects&amp;rdquo;. See the section &amp;ldquo;Treatment of effects&amp;rdquo; below for the precise definition of this term.</source>
          <target state="translated">단순화 단계는 해당 정의 표현식이 &quot;효과가없는&quot;경우 사용되지 않는 let 바인딩을 제거합니다. 이 용어의 정확한 정의는 아래의 &quot;효과 처리&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0fef5e19c04ebce13dc54db7219bcb47397db9b0" translate="yes" xml:space="preserve">
          <source>The singleton sequence containing only the given element.</source>
          <target state="translated">주어진 요소 만 포함하는 싱글 톤 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="c4bcd7d574236ad63f44f94fc9e518268676361d" translate="yes" xml:space="preserve">
          <source>The size (in words) of the minor heap. Changing this parameter will trigger a minor collection. Default: 256k.</source>
          <target state="translated">부 힙의 크기 (단어)입니다. 이 매개 변수를 변경하면 부 수집이 트리거됩니다. 기본값 : 256k.</target>
        </trans-unit>
        <trans-unit id="a7507f679adbb7afe1b145bc75e44b72811c4382" translate="yes" xml:space="preserve">
          <source>The size in bits of a native integer.</source>
          <target state="translated">원시 정수의 비트 크기입니다.</target>
        </trans-unit>
        <trans-unit id="85cc984ceaff2d2d3db71a0f154333bd58e0401c" translate="yes" xml:space="preserve">
          <source>The size in bits of a native integer. This is equal to &lt;code&gt;32&lt;/code&gt; on a 32-bit platform and to &lt;code&gt;64&lt;/code&gt; on a 64-bit platform.</source>
          <target state="translated">원시 정수의 비트 크기입니다. 이 같은지 &lt;code&gt;32&lt;/code&gt; 32 비트 플랫폼하고 &lt;code&gt;64&lt;/code&gt; 에서 64 비트 플랫폼.</target>
        </trans-unit>
        <trans-unit id="64bd44d9e49c2e76cdcec87737e9935d12ee6bdc" translate="yes" xml:space="preserve">
          <source>The size of the block, in words, excluding the header.</source>
          <target state="translated">헤더를 제외한 블록의 크기 (단어)입니다.</target>
        </trans-unit>
        <trans-unit id="e6050e441d76daaaf25b47ad3fafeab9c8db6155" translate="yes" xml:space="preserve">
          <source>The size of the window used by the major GC for smoothing out variations in its workload. This is an integer between 1 and 50. Default: 1.</source>
          <target state="translated">워크로드의 변동을 완화하기 위해 주요 GC에서 사용하는 창 크기입니다. 1에서 50 사이의 정수입니다. 기본값 : 1</target>
        </trans-unit>
        <trans-unit id="e707fef1fa0d611c38a23a134e978234bf5dd431" translate="yes" xml:space="preserve">
          <source>The smallest positive, non-zero, non-denormalized value of type &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;float&lt;/code&gt; 유형의 비정규 화되지 않은 0이 아닌 양수 중 가장 작은 값입니다 .</target>
        </trans-unit>
        <trans-unit id="a3b9782a5db6a027afd3f2671f6d34f2dca120c7" translate="yes" xml:space="preserve">
          <source>The smallest representable 32-bit integer, -2&lt;sup&gt;31&lt;/sup&gt;.</source>
          <target state="translated">표현 가능한 가장 작은 32 비트 정수 -2 &lt;sup&gt;31&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="1bcd225542d9f92f6251d4bb2d635ef483db75e2" translate="yes" xml:space="preserve">
          <source>The smallest representable 64-bit integer, -2&lt;sup&gt;63&lt;/sup&gt;.</source>
          <target state="translated">표현 가능한 가장 작은 64 비트 정수, -2 &lt;sup&gt;63&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="e75cf5a86c7fa5d080ac26a1f47b98cef3adf163" translate="yes" xml:space="preserve">
          <source>The smallest representable integer.</source>
          <target state="translated">표현 가능한 가장 작은 정수입니다.</target>
        </trans-unit>
        <trans-unit id="b7ad80500b883d3470a8546d7763368d6a139abd" translate="yes" xml:space="preserve">
          <source>The smallest representable native integer, either -2&lt;sup&gt;31&lt;/sup&gt; on a 32-bit platform, or -2&lt;sup&gt;63&lt;/sup&gt; on a 64-bit platform.</source>
          <target state="translated">표현 가능한 가장 작은 기본 정수로, 32 비트 플랫폼에서는 -2 &lt;sup&gt;31&lt;/sup&gt; , 64 비트 플랫폼에서는 -2 &lt;sup&gt;63&lt;/sup&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="16618ca96c698ad7bfc1856d7b38af8d4e0524d6" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt&quot;&gt;&lt;code&gt;Unix.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt&quot;&gt;&lt;code&gt;Unix.setsockopt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자문을 할 수있는 소켓 옵션 &lt;a href=&quot;unix#VALgetsockopt&quot;&gt; &lt;code&gt;Unix.getsockopt&lt;/code&gt; &lt;/a&gt; 와 함께 수정 &lt;a href=&quot;unix#VALsetsockopt&quot;&gt; &lt;code&gt;Unix.setsockopt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="67e810815e754c36f51190792dabe6b7f6d39fc1" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt&quot;&gt;&lt;code&gt;Unix.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt&quot;&gt;&lt;code&gt;Unix.setsockopt&lt;/code&gt;&lt;/a&gt;. These options have a boolean (&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;) value.</source>
          <target state="translated">자문을 할 수있는 소켓 옵션 &lt;a href=&quot;unix#VALgetsockopt&quot;&gt; &lt;code&gt;Unix.getsockopt&lt;/code&gt; &lt;/a&gt; 와 함께 수정 &lt;a href=&quot;unix#VALsetsockopt&quot;&gt; &lt;code&gt;Unix.setsockopt&lt;/code&gt; &lt;/a&gt; . 이러한 옵션에는 부울 ( &lt;code&gt;true&lt;/code&gt; / &lt;code&gt;false&lt;/code&gt; ) 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6598491cb35302bb16af6b6c7a9e151f8e63d9b8" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_float&quot;&gt;&lt;code&gt;Unix.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_float&quot;&gt;&lt;code&gt;Unix.setsockopt_float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자문을 할 수있는 소켓 옵션 &lt;a href=&quot;unix#VALgetsockopt_float&quot;&gt; &lt;code&gt;Unix.getsockopt_float&lt;/code&gt; &lt;/a&gt; 와 함께 수정 &lt;a href=&quot;unix#VALsetsockopt_float&quot;&gt; &lt;code&gt;Unix.setsockopt_float&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2019ae655a591c32fb8f40c0b2ba647816b414ae" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_float&quot;&gt;&lt;code&gt;Unix.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_float&quot;&gt;&lt;code&gt;Unix.setsockopt_float&lt;/code&gt;&lt;/a&gt;. These options have a floating-point value representing a time in seconds. The value 0 means infinite timeout.</source>
          <target state="translated">자문을 할 수있는 소켓 옵션 &lt;a href=&quot;unix#VALgetsockopt_float&quot;&gt; &lt;code&gt;Unix.getsockopt_float&lt;/code&gt; &lt;/a&gt; 와 함께 수정 &lt;a href=&quot;unix#VALsetsockopt_float&quot;&gt; &lt;code&gt;Unix.setsockopt_float&lt;/code&gt; &lt;/a&gt; . 이러한 옵션에는 시간을 초 단위로 나타내는 부동 소수점 값이 있습니다. 값 0은 무한 시간 초과를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2e1595d080e9d78ca9f7ddffc0fd77da50d67b0c" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_int&quot;&gt;&lt;code&gt;Unix.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_int&quot;&gt;&lt;code&gt;Unix.setsockopt_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자문을 할 수있는 소켓 옵션 &lt;a href=&quot;unix#VALgetsockopt_int&quot;&gt; &lt;code&gt;Unix.getsockopt_int&lt;/code&gt; &lt;/a&gt; 와 함께 수정 &lt;a href=&quot;unix#VALsetsockopt_int&quot;&gt; &lt;code&gt;Unix.setsockopt_int&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6570006f88037fbe57d746e9ffa8ebe2113c3daa" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_int&quot;&gt;&lt;code&gt;Unix.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_int&quot;&gt;&lt;code&gt;Unix.setsockopt_int&lt;/code&gt;&lt;/a&gt;. These options have an integer value.</source>
          <target state="translated">자문을 할 수있는 소켓 옵션 &lt;a href=&quot;unix#VALgetsockopt_int&quot;&gt; &lt;code&gt;Unix.getsockopt_int&lt;/code&gt; &lt;/a&gt; 와 함께 수정 &lt;a href=&quot;unix#VALsetsockopt_int&quot;&gt; &lt;code&gt;Unix.setsockopt_int&lt;/code&gt; &lt;/a&gt; . 이러한 옵션에는 정수 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="67cb053530374f0ae91755129be399861c2e62b8" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_optint&quot;&gt;&lt;code&gt;Unix.getsockopt_optint&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_optint&quot;&gt;&lt;code&gt;Unix.setsockopt_optint&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자문을 할 수있는 소켓 옵션 &lt;a href=&quot;unix#VALgetsockopt_optint&quot;&gt; &lt;code&gt;Unix.getsockopt_optint&lt;/code&gt; &lt;/a&gt; 와 함께 수정 &lt;a href=&quot;unix#VALsetsockopt_optint&quot;&gt; &lt;code&gt;Unix.setsockopt_optint&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b02d9606ae3049641c3c0b7a49b93173582ba252" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unix#VALgetsockopt_optint&quot;&gt;&lt;code&gt;Unix.getsockopt_optint&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unix#VALsetsockopt_optint&quot;&gt;&lt;code&gt;Unix.setsockopt_optint&lt;/code&gt;&lt;/a&gt;. These options have a value of type &lt;code&gt;int&amp;nbsp;option&lt;/code&gt;, with &lt;code&gt;None&lt;/code&gt; meaning ``disabled''.</source>
          <target state="translated">자문을 할 수있는 소켓 옵션 &lt;a href=&quot;unix#VALgetsockopt_optint&quot;&gt; &lt;code&gt;Unix.getsockopt_optint&lt;/code&gt; &lt;/a&gt; 와 함께 수정 &lt;a href=&quot;unix#VALsetsockopt_optint&quot;&gt; &lt;code&gt;Unix.setsockopt_optint&lt;/code&gt; &lt;/a&gt; . 이 옵션은 형의 값이 &lt;code&gt;int&amp;nbsp;option&lt;/code&gt; 함께 &lt;code&gt;None&lt;/code&gt; 의미 '' ''장애인.</target>
        </trans-unit>
        <trans-unit id="773642dab704b446e24c880397ae53bf6b4f36e8" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt&quot;&gt;&lt;code&gt;UnixLabels.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt&quot;&gt;&lt;code&gt;UnixLabels.setsockopt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자문을 할 수있는 소켓 옵션 &lt;a href=&quot;unixlabels#VALgetsockopt&quot;&gt; &lt;code&gt;UnixLabels.getsockopt&lt;/code&gt; &lt;/a&gt; 와 함께 수정 &lt;a href=&quot;unixlabels#VALsetsockopt&quot;&gt; &lt;code&gt;UnixLabels.setsockopt&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="127c95d87113564ad21001801dba75443274ac20" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt&quot;&gt;&lt;code&gt;UnixLabels.getsockopt&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt&quot;&gt;&lt;code&gt;UnixLabels.setsockopt&lt;/code&gt;&lt;/a&gt;. These options have a boolean (&lt;code&gt;true&lt;/code&gt;/&lt;code&gt;false&lt;/code&gt;) value.</source>
          <target state="translated">자문을 할 수있는 소켓 옵션 &lt;a href=&quot;unixlabels#VALgetsockopt&quot;&gt; &lt;code&gt;UnixLabels.getsockopt&lt;/code&gt; &lt;/a&gt; 와 함께 수정 &lt;a href=&quot;unixlabels#VALsetsockopt&quot;&gt; &lt;code&gt;UnixLabels.setsockopt&lt;/code&gt; &lt;/a&gt; . 이러한 옵션에는 부울 ( &lt;code&gt;true&lt;/code&gt; / &lt;code&gt;false&lt;/code&gt; ) 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d121887ffb4d5fad74076fcd7a6ddb33c6b3f62" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자문을 할 수있는 소켓 옵션 &lt;a href=&quot;unixlabels#VALgetsockopt_float&quot;&gt; &lt;code&gt;UnixLabels.getsockopt_float&lt;/code&gt; &lt;/a&gt; 와 함께 수정 &lt;a href=&quot;unixlabels#VALsetsockopt_float&quot;&gt; &lt;code&gt;UnixLabels.setsockopt_float&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03fad790fcf2b775879fa18d8ded24985ac1495f" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_float&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_float&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_float&lt;/code&gt;&lt;/a&gt;. These options have a floating-point value representing a time in seconds. The value 0 means infinite timeout.</source>
          <target state="translated">자문을 할 수있는 소켓 옵션 &lt;a href=&quot;unixlabels#VALgetsockopt_float&quot;&gt; &lt;code&gt;UnixLabels.getsockopt_float&lt;/code&gt; &lt;/a&gt; 와 함께 수정 &lt;a href=&quot;unixlabels#VALsetsockopt_float&quot;&gt; &lt;code&gt;UnixLabels.setsockopt_float&lt;/code&gt; &lt;/a&gt; . 이러한 옵션에는 시간을 초 단위로 나타내는 부동 소수점 값이 있습니다. 값 0은 무한 시간 초과를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4cd8b0a441c72f8156f95e88c710953c3fa2ced0" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자문을 할 수있는 소켓 옵션 &lt;a href=&quot;unixlabels#VALgetsockopt_int&quot;&gt; &lt;code&gt;UnixLabels.getsockopt_int&lt;/code&gt; &lt;/a&gt; 와 함께 수정 &lt;a href=&quot;unixlabels#VALsetsockopt_int&quot;&gt; &lt;code&gt;UnixLabels.setsockopt_int&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af5931adebaf9a357ecb0df8a73e7c072f718e8d" translate="yes" xml:space="preserve">
          <source>The socket options that can be consulted with &lt;a href=&quot;unixlabels#VALgetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.getsockopt_int&lt;/code&gt;&lt;/a&gt; and modified with &lt;a href=&quot;unixlabels#VALsetsockopt_int&quot;&gt;&lt;code&gt;UnixLabels.setsockopt_int&lt;/code&gt;&lt;/a&gt;. These options have an integer value.</source>
          <target state="translated">자문을 할 수있는 소켓 옵션 &lt;a href=&quot;unixlabels#VALgetsockopt_int&quot;&gt; &lt;code&gt;UnixLabels.getsockopt_int&lt;/code&gt; &lt;/a&gt; 와 함께 수정 &lt;a href=&quot;unixlabels#VALsetsockopt_int&quot;&gt; &lt;code&gt;UnixLabels.setsockopt_int&lt;/code&gt; &lt;/a&gt; . 이러한 옵션에는 정수 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="55d3d9fad514eda7c3e614c6496c099599e1e6e6" translate="yes" xml:space="preserve">
          <source>The solution of this conundrum is to use an explicitly polymorphic type annotation for the type 'a:</source>
          <target state="translated">이 수수께끼의 해결책은 'a :'유형에 대해 명시 적으로 다형성 유형 주석을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ca3eb9c8c5023c43f9da6f2e55f310ac29817523" translate="yes" xml:space="preserve">
          <source>The sort function above does not modify its input list: it builds and returns a new list containing the same elements as the input list, in ascending order. There is actually no way in OCaml to modify a list in-place once it is built: we say that lists are &lt;em&gt;immutable&lt;/em&gt; data structures. Most OCaml data structures are immutable, but a few (most notably arrays) are &lt;em&gt;mutable&lt;/em&gt;, meaning that they can be modified in-place at any time.</source>
          <target state="translated">위의 정렬 함수는 입력 목록을 수정하지 않습니다. 입력 목록과 동일한 요소를 포함하는 새 목록을 오름차순으로 빌드하고 반환합니다. 실제로 OCaml에서는 목록이 만들어지면 제자리에서 수정할 수있는 방법이 &lt;em&gt;없습니다&lt;/em&gt; . 목록은 &lt;em&gt;변경 불가능한&lt;/em&gt; 데이터 구조 라고 말합니다 . 대부분의 OCaml 데이터 구조는 변경 불가능하지만 일부 (특히 배열)는 &lt;em&gt;변경 가능합니다&lt;/em&gt; . 즉, 언제든지 제자리에서 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3aef2817764bb52ac263b2fae2a148fec94730b6" translate="yes" xml:space="preserve">
          <source>The space character in format strings</source>
          <target state="translated">형식 문자열의 공백 문자</target>
        </trans-unit>
        <trans-unit id="c0c0e1ff4d5efd916e94aa7b9b072f20bb6cc011" translate="yes" xml:space="preserve">
          <source>The special comment (**/**) tells OCamldoc to discard elements placed after this comment, up to the end of the current class, class type, module or module type, or up to the next stop comment. For instance:</source>
          <target state="translated">특수 주석 (** / **)은 현재 클래스, 클래스 유형, 모듈 또는 모듈 유형의 ​​끝 또는 다음 중지 주석까지이 주석 뒤에 배치 된 요소를 버리도록 OCamldoc에 지시합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="cebcc58b51afa7136699d267676f15d0e280a3f4" translate="yes" xml:space="preserve">
          <source>The special comment is not already associated to the previous element.</source>
          <target state="translated">특수 주석은 이전 요소와 아직 연결되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5435aaea40f8385771bfff6ba0d166cd3c0eeccb" translate="yes" xml:space="preserve">
          <source>The special comment is not the first one of a toplevel module.</source>
          <target state="translated">특별한 주석은 최상위 모듈의 첫 번째 주석이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="06de91b2368326e2f06fbc6d38cdade544c2bc74" translate="yes" xml:space="preserve">
          <source>The specification exception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; in a signature requires the matching structure to provide an exception with the name and arguments specified in the definition, and makes the exception available to all users of the structure.</source>
          <target state="translated">서명 의 사양 예외 &lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; 은 정의에 지정된 이름과 인수로 예외를 제공하고 구조의 모든 사용자가 예외를 사용할 수 있도록하기 위해 일치하는 구조가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fc96b351853386bb44b989f2d36255658c8e97cf" translate="yes" xml:space="preserve">
          <source>The specification of a method is written method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;, where &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; is the name of the method and &lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt; its expected type, possibly polymorphic. The flag private indicates that the method cannot be accessed from outside the object.</source>
          <target state="translated">메쏘드의 명세는 쓰여진 method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; : &lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr입니다&lt;/a&gt; . 여기서 &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; 은 메쏘드의 이름 이고 &lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt; 은 예상되는 유형입니다. private 플래그는 객체 외부에서 메서드에 액세스 할 수 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="816c127c5b84f64b52fb9fd685c1cb4ac8a4ea85" translate="yes" xml:space="preserve">
          <source>The standard error output for the process.</source>
          <target state="translated">프로세스에 대한 표준 오류 출력입니다.</target>
        </trans-unit>
        <trans-unit id="db78c9295b1256ee8e8a6b6086c5f3651f2fa1cd" translate="yes" xml:space="preserve">
          <source>The standard formatter to write to standard output.</source>
          <target state="translated">표준 출력에 쓸 표준 포맷터입니다.</target>
        </trans-unit>
        <trans-unit id="ba48c9ea4ac16d1bd2010fb99db24330d34c33b1" translate="yes" xml:space="preserve">
          <source>The standard input for the process.</source>
          <target state="translated">프로세스에 대한 표준 입력입니다.</target>
        </trans-unit>
        <trans-unit id="375db9af8a0d4dc3c0ba86650eeff121048506df" translate="yes" xml:space="preserve">
          <source>The standard input notion for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt; 모듈 의 표준 입력 개념입니다 .</target>
        </trans-unit>
        <trans-unit id="464e4c58fe500861730075b12f1fb6435b04534f" translate="yes" xml:space="preserve">
          <source>The standard input notion for the &lt;a href=&quot;scanf&quot;&gt;&lt;code&gt;Scanf&lt;/code&gt;&lt;/a&gt; module. &lt;code&gt;Scanning.stdin&lt;/code&gt; is the &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt; formatted input channel attached to &lt;a href=&quot;stdlib#VALstdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;scanf&quot;&gt; &lt;code&gt;Scanf&lt;/code&gt; &lt;/a&gt; 모듈 의 표준 입력 개념입니다 . &lt;code&gt;Scanning.stdin&lt;/code&gt; 은 &lt;a href=&quot;stdlib#VALstdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; 에&lt;/a&gt; 연결된 &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt; &lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt; &lt;/a&gt; 형식의 입력 채널 입니다.</target>
        </trans-unit>
        <trans-unit id="aecb465e5714800c091e84c331cee9577b92a018" translate="yes" xml:space="preserve">
          <source>The standard library directory.</source>
          <target state="translated">표준 라이브러리 디렉토리.</target>
        </trans-unit>
        <trans-unit id="defad1b44801f55e161dc009fb41cef1fe3ba956" translate="yes" xml:space="preserve">
          <source>The standard output for the process.</source>
          <target state="translated">프로세스의 표준 출력입니다.</target>
        </trans-unit>
        <trans-unit id="f1326096be35fcaff4666a9f746f76c98f98925e" translate="yes" xml:space="preserve">
          <source>The str library provides high-level string processing functions, some based on regular expressions. It is intended to support the kind of file processing that is usually performed with scripting languages such as awk, perl or sed.</source>
          <target state="translated">str 라이브러리는 일부 정규 표현식을 기반으로하는 고급 문자열 처리 함수를 제공합니다. 일반적으로 awk, perl 또는 sed와 같은 스크립팅 언어로 수행되는 종류의 파일 처리를 지원하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6d5110986ab904812febd54df3e70e3cfe974039" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;cmd&lt;/code&gt; is the command to call. The list &lt;code&gt;args&lt;/code&gt; is the list of arguments to pass to this command. It can be empty.</source>
          <target state="translated">&lt;code&gt;cmd&lt;/code&gt; 문자열 은 호출 할 명령입니다. list &lt;code&gt;args&lt;/code&gt; 는이 명령에 전달할 인수 목록입니다. 비어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ea036aba8bc423b44bed368aa0538f1848ee618" translate="yes" xml:space="preserve">
          <source>The string buffer in which &lt;code&gt;str_formatter&lt;/code&gt; writes.</source>
          <target state="translated">&lt;code&gt;str_formatter&lt;/code&gt; 가 쓰는 문자열 버퍼입니다 .</target>
        </trans-unit>
        <trans-unit id="7a78fd29209652bbda7cca4022b56527d5c814fe" translate="yes" xml:space="preserve">
          <source>The struct custom_operations is defined in &amp;lt;caml/custom.h&amp;gt; and contains the following fields:</source>
          <target state="translated">custom_operations 구조체는 &amp;lt;caml / custom.h&amp;gt;에 정의되어 있으며 다음 필드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="a298a05448f3ad20cfa9581c95c5d1288fc8e676" translate="yes" xml:space="preserve">
          <source>The syntactic class of constants comprises literals from the four base types (integers, floating-point numbers, characters, character strings), the integer variants, and constant constructors from both normal and polymorphic variants, as well as the special constants false, true, (), [], and [||], which behave like constant constructors, and beginend, which is equivalent to ().</source>
          <target state="translated">상수의 구문 클래스는 네 가지 기본 유형 (정수, 부동 소수점 숫자, 문자, 문자열)의 리터럴, 정수 변형, 일반 및 다형성 변형의 상수 생성자뿐만 아니라 특수 상수 false, true, 상수 생성자처럼 동작하는 (), [] 및 [||] 및 ()와 동일한 beginend.</target>
        </trans-unit>
        <trans-unit id="a830f98dedde0a3c31b9928e1164ca27920971ea" translate="yes" xml:space="preserve">
          <source>The syntax for rules is as usual:</source>
          <target state="translated">규칙의 구문은 평소와 같습니다.</target>
        </trans-unit>
        <trans-unit id="11b8e75b70b6bcdf9c144d7d28884193fb2da070" translate="yes" xml:space="preserve">
          <source>The syntax is exactly the same as for class expressions, but the result is a single object rather than a class. All the constructs described in the rest of this section also apply to immediate objects.</source>
          <target state="translated">구문은 클래스 표현식과 정확히 동일하지만 결과는 클래스가 아닌 단일 객체입니다. 이 섹션의 나머지 부분에서 설명하는 모든 구성은 즉각적인 개체에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f75ce09e5843f380505e811b0272a865314bf4e9" translate="yes" xml:space="preserve">
          <source>The syntax of the language is given in BNF-like notation. Terminal symbols are set in typewriter font (likethis). Non-terminal symbols are set in italic font (likethat). Square brackets [&amp;hellip;] denote optional components. Curly brackets {&amp;hellip;} denotes zero, one or several repetitions of the enclosed components. Curly brackets with a trailing plus sign {&amp;hellip;}&lt;sup&gt;+&lt;/sup&gt; denote one or several repetitions of the enclosed components. Parentheses (&amp;hellip;) denote grouping.</source>
          <target state="translated">언어의 구문은 BNF와 유사한 표기법으로 제공됩니다. 터미널 기호는 타자기 글꼴로 설정됩니다 (이와 같이). 터미널이 아닌 기호는 이탤릭체로 설정됩니다. 대괄호 [&amp;hellip;]는 선택적 구성 요소를 나타냅니다. 중괄호 {&amp;hellip;}는 포함 된 구성 요소가 0 개, 1 개 또는 여러 번 반복됨을 나타냅니다. 후행 더하기 기호 {&amp;hellip;} &lt;sup&gt;+&lt;/sup&gt; 가있는 중괄호 는 포함 된 구성 요소가 하나 또는 여러 번 반복됨을 나타냅니다. 괄호 (&amp;hellip;)는 그룹화를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="aa08323f8802e6d50ccec78b682ef7b93d7f7d1e" translate="yes" xml:space="preserve">
          <source>The table below lists the symbols defined in the initial environment and their initial meaning. (See the description of the core library module Stdlib in chapter &lt;a href=&quot;core#c%3Acorelib&quot;&gt;25&lt;/a&gt; for more details). Their meaning may be changed at any time using let(&lt;a href=&quot;names#infix-op&quot;&gt;infix-op&lt;/a&gt;)name&lt;sub&gt;1&lt;/sub&gt;name&lt;sub&gt;2&lt;/sub&gt;= &amp;hellip;</source>
          <target state="translated">아래 표에는 초기 환경에서 정의 된 기호와 그 초기 의미가 나열되어 있습니다. (자세한 내용은 &lt;a href=&quot;core#c%3Acorelib&quot;&gt;25&lt;/a&gt; 장의 핵심 라이브러리 모듈 Stdlib에 대한 설명을 참조하십시오). 그 의미는 let ( &lt;a href=&quot;names#infix-op&quot;&gt;infix-op&lt;/a&gt; ) name &lt;sub&gt;1&lt;/sub&gt; name &lt;sub&gt;2&lt;/sub&gt; =&amp;hellip;를 사용하여 언제든지 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4265c38e98429479cc2782e5d12f7b2b292f3497" translate="yes" xml:space="preserve">
          <source>The table below shows the relative precedences and associativity of operators and non-closed constructions. The constructions with higher precedence come first. For infix and prefix symbols, we write &amp;ldquo;*&amp;hellip;&amp;rdquo; to mean &amp;ldquo;any symbol starting with *&amp;rdquo;.</source>
          <target state="translated">아래 표는 연산자와 닫히지 않은 구성의 상대적 우선 순위와 연관성을 보여줍니다. 우선 순위가 더 높은 구성이 먼저옵니다. 중위 및 접두사 기호의 경우 &quot;*로 시작하는 모든 기호&quot;를 의미하는 &quot;*&amp;hellip;&quot;라고 씁니다.</target>
        </trans-unit>
        <trans-unit id="1ca02ca74768b06f8e3e1c2b6d1dd2805e4d9dc1" translate="yes" xml:space="preserve">
          <source>The table below shows the relative precedences and associativity of operators and non-closed pattern constructions. The constructions with higher precedences come first.</source>
          <target state="translated">아래 표는 연산자와 닫히지 않은 패턴 구성의 상대적 우선 순위와 연관성을 보여줍니다. 우선 순위가 더 높은 구성이 먼저옵니다.</target>
        </trans-unit>
        <trans-unit id="2aaedd4906bf37d963daebc10f3ce2cae137d335" translate="yes" xml:space="preserve">
          <source>The table below shows the relative precedences and associativity of operators and non-closed type constructions. The constructions with higher precedences come first.</source>
          <target state="translated">아래 표는 연산자와 닫히지 않은 유형 구성의 상대적 우선 순위와 연관성을 보여줍니다. 우선 순위가 더 높은 구성이 먼저옵니다.</target>
        </trans-unit>
        <trans-unit id="873780c573d904e6823105d70079b69ff6aa2a60" translate="yes" xml:space="preserve">
          <source>The tag-marking operation is the simpler tag specific operation: it simply writes a tag specific string into the output device of the formatter. Tag-marking does not interfere with line-splitting computation.</source>
          <target state="translated">태그 표시 작업은보다 간단한 태그 별 작업입니다. 단순히 태그 별 문자열을 포맷터의 출력 장치에 씁니다. 태그 표시는 줄 분할 계산을 방해하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e9b336647566103c9dc222eca78097e8e36a10d" translate="yes" xml:space="preserve">
          <source>The tag-printing operation is the more involved tag specific operation: it can print arbitrary material to the formatter. Tag-printing is tightly linked to the current pretty-printer operations.</source>
          <target state="translated">태그 인쇄 작업은 태그 별 작업이 더 복잡합니다. 임의의 자료를 포맷터에 인쇄 할 수 있습니다. 태그 인쇄는 현재 프리티 프린터 작업과 밀접하게 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc0467c82797c179e1082f88331fe596f582254d" translate="yes" xml:space="preserve">
          <source>The term type we have defined above is an &lt;em&gt;indexed&lt;/em&gt; type, where a type parameter reflects a property of the value contents. Another use of GADTs is &lt;em&gt;singleton&lt;/em&gt; types, where a GADT value represents exactly one type. This value can be used as runtime representation for this type, and a function receiving it can have a polytypic behavior.</source>
          <target state="translated">위에서 정의한 용어 유형 은 유형 매개 변수가 값 콘텐츠의 속성을 반영 하는 &lt;em&gt;인덱싱 된&lt;/em&gt; 유형입니다. GADT의 또 다른 용도는 GADT 값이 정확히 하나의 유형을 나타내는 &lt;em&gt;싱글 톤&lt;/em&gt; 유형입니다. 이 값은이 유형에 대한 런타임 표현으로 사용할 수 있으며이를 수신하는 함수는 다형 동작을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bff74d740aa663829cf4f77edbb8806d1bc466d0" translate="yes" xml:space="preserve">
          <source>The termination status of a process.</source>
          <target state="translated">프로세스의 종료 상태입니다.</target>
        </trans-unit>
        <trans-unit id="e0c71035b432f40f8ce6567e0659d0f94303a4bb" translate="yes" xml:space="preserve">
          <source>The termination status of a process. See module &lt;a href=&quot;sys&quot;&gt;&lt;code&gt;Sys&lt;/code&gt;&lt;/a&gt; for the definitions of the standard signal numbers. Note that they are not the numbers used by the OS.</source>
          <target state="translated">프로세스의 종료 상태입니다. 표준 신호 번호의 정의는 &lt;a href=&quot;sys&quot;&gt; &lt;code&gt;Sys&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 . OS에서 사용하는 번호가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b998179643d8f25a6de4e2f828c6ab63197c25fd" translate="yes" xml:space="preserve">
          <source>The third case is a closed variant type. It gives information about all the possible tags and their associated types, and which tags are known to potentially appear in values. The exact variant type (first case) is just an abbreviation for a closed variant type where all possible tags are also potentially present.</source>
          <target state="translated">세 번째 경우는 폐쇄 형 변형 유형입니다. 가능한 모든 태그 및 관련 유형 및 값에 잠재적으로 나타나는 것으로 알려진 태그에 대한 정보를 제공합니다. 정확한 변형 유형 (첫 번째 경우)은 가능한 모든 태그가 잠재적으로 존재할 수있는 닫힌 변형 유형의 약어 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="72c73fe652e0c0e0cf068757abf72958b2266b30" translate="yes" xml:space="preserve">
          <source>The threads library allows concurrent programming in OCaml. It provides multiple threads of control (also called lightweight processes) that execute concurrently in the same memory space. Threads communicate by in-place modification of shared data structures, or by sending and receiving data on communication channels.</source>
          <target state="translated">스레드 라이브러리는 OCaml에서 동시 프로그래밍을 허용합니다. 동일한 메모리 공간에서 동시에 실행되는 여러 제어 스레드 (경량 프로세스라고도 함)를 제공합니다. 스레드는 공유 데이터 구조의 내부 수정 또는 통신 채널에서 데이터를 송수신하여 통신합니다.</target>
        </trans-unit>
        <trans-unit id="ee8a007db9b67f061741b11b1f8ef10fd7dfa6a8" translate="yes" xml:space="preserve">
          <source>The threads library is implemented by time-sharing on a single processor. It will not take advantage of multi-processor machines. Using this library will therefore never make programs run faster. However, many programs are easier to write when structured as several communicating processes.</source>
          <target state="translated">스레드 라이브러리는 단일 프로세서에서 시간 공유로 구현됩니다. 다중 프로세서 시스템을 사용하지 않습니다. 따라서이 라이브러리를 사용하면 프로그램이 더 빨리 실행되지 않습니다. 그러나 많은 프로그램은 여러 통신 프로세스로 구성 될 때 작성하기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="d5a20efffaf644d1427994b098f56c7f31e6be5e" translate="yes" xml:space="preserve">
          <source>The three kinds of interval timers.</source>
          <target state="translated">세 종류의 인터벌 타이머.</target>
        </trans-unit>
        <trans-unit id="4b1f416d7e4aa2468aa653df39f4953c40bbd756" translate="yes" xml:space="preserve">
          <source>The three type parameters to &lt;code&gt;Genarray.t&lt;/code&gt; identify the array element kind and layout, as follows:</source>
          <target state="translated">&lt;code&gt;Genarray.t&lt;/code&gt; 에 대한 세 가지 유형 매개 변수 는 다음과 같이 배열 요소 종류와 레이아웃을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="27a8084722c0c59b716ab80edd05f2b005dea978" translate="yes" xml:space="preserve">
          <source>The toplevel system does not perform line editing, but it can easily be used in conjunction with an external line editor such as ledit, or rlwrap. An improved toplevel, utop, is also available. Another option is to use ocaml under Gnu Emacs, which gives the full editing power of Emacs (command run-caml from library inf-caml).</source>
          <target state="translated">최상위 시스템은 라인 편집을 수행하지 않지만 ledit 또는 rlwrap과 같은 외부 라인 편집기와 함께 쉽게 사용할 수 있습니다. 개선 된 최상위 utop도 사용할 수 있습니다. 또 다른 옵션은 Gnu Emacs에서 ocaml을 사용하는 것인데, 이는 Emacs의 완전한 편집 능력을 제공합니다 (inf-caml 라이브러리에서 run-caml 명령).</target>
        </trans-unit>
        <trans-unit id="0efc25c223657f44333e6ed3dee74d2f834fa753" translate="yes" xml:space="preserve">
          <source>The total amount of memory allocated by the program since it was started is (in words) &lt;code&gt;minor_words&amp;nbsp;+&amp;nbsp;major_words&amp;nbsp;-&amp;nbsp;promoted_words&lt;/code&gt;. Multiply by the word size (4 on a 32-bit machine, 8 on a 64-bit machine) to get the number of bytes.</source>
          <target state="translated">프로그램이 시작된 이후 할당 된 총 메모리 양은 &lt;code&gt;minor_words&amp;nbsp;+&amp;nbsp;major_words&amp;nbsp;-&amp;nbsp;promoted_words&lt;/code&gt; 입니다. 바이트 수를 얻으려면 워드 크기 (32 비트 컴퓨터에서는 4, 64 비트 컴퓨터에서는 8)를 곱하십시오.</target>
        </trans-unit>
        <trans-unit id="f4eb40ef4dc24c3e0ad0bdb73cac37d303dc7aee" translate="yes" xml:space="preserve">
          <source>The transformation is implemented by adding a new wrapper function in the manner of that used when unboxing specialised arguments. The closure variables are still free in the wrapper, but the intention is that when the wrapper is inlined at direct call sites, the relevant values are passed directly to the main function via the new specialised arguments.</source>
          <target state="translated">변환은 특수 인수를 개봉 할 때 사용되는 방식으로 새 래퍼 함수를 ​​추가하여 구현됩니다. 클로저 변수는 래퍼에서 여전히 무료이지만 래퍼가 직접 호출 사이트에서 인라인 될 때 ​​관련 값이 새로운 특수 인수를 통해 주 함수로 직접 전달되는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2e984d305346aebd0ab69a424dfacb7e6aa1b981" translate="yes" xml:space="preserve">
          <source>The transformation is implemented by creating a wrapper function that accepts the original arguments. Meanwhile, the original function is renamed and extra arguments are added corresponding to the unboxed specialised arguments; this new function is called from the wrapper. The wrapper will then be inlined at direct call sites. Indeed, all call sites will be direct unless -unbox-closures is being used, since they will have been generated by the compiler when originally specialising the function. (In the case of -unbox-closures other functions may appear with specialised arguments; in this case there may be indirect calls and these will incur a small penalty owing to having to bounce through the wrapper. The technique of &lt;em&gt;direct call surrogates&lt;/em&gt; used for -unbox-closures is not used by the transformation to unbox specialised arguments.)</source>
          <target state="translated">변환은 원래 인수를 허용하는 래퍼 함수를 ​​생성하여 구현됩니다. 한편, 원래 함수의 이름이 바뀌고 상자가없는 특수 인수에 해당하는 추가 인수가 추가됩니다. 이 새로운 함수는 래퍼에서 호출됩니다. 래퍼는 직접 호출 사이트에서 인라인됩니다. 실제로 모든 호출 사이트는 -unbox-closures를 사용하지 않는 한 직접적입니다. 원래 함수를 전문화 할 때 컴파일러에 의해 생성 되었기 때문입니다. (-unbox-closures의 경우 다른 함수가 특수 인수와 함께 나타날 수 있습니다.이 경우 간접 호출이있을 수 있으며 래퍼를 통해 바운스해야하므로 약간의 패널티가 발생합니다. &lt;em&gt;직접 호출 대리&lt;/em&gt; 기법은&lt;em&gt;&lt;/em&gt; -unbox-closures에 사용됨은 특수 인수를 unbox로 변환하는 데 사용되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="8198b57a18523f699b5f95a3eca2418108615522" translate="yes" xml:space="preserve">
          <source>The transformation replaces closure variables by specialised arguments. The aim is to cause more closures to become closed. It is particularly applicable, as a means of reducing allocation, where the function concerned cannot be inlined or specialised. For example, some non-recursive function might be too large to inline; or some recursive function might offer no opportunities for specialisation perhaps because its only argument is one of type unit.</source>
          <target state="translated">변환은 클로저 변수를 특수 인수로 대체합니다. 목표는 더 많은 폐쇄를 폐쇄하는 것입니다. 관련 기능이 인라인되거나 전문화 될 수없는 경우 할당을 줄이는 수단으로 특히 적용 가능합니다. 예를 들어, 일부 비 재귀 함수는 너무 커서 인라인 할 수 없습니다. 또는 일부 재귀 함수는 유일한 인수가 유형 단위 중 하나이기 때문에 전문화에 대한 기회를 제공하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ec534b61d911e890ad6935004cee0e7049d17f2" translate="yes" xml:space="preserve">
          <source>The transformation to unbox specialised arguments never introduces extra allocation.</source>
          <target state="translated">unbox 특수 인수로의 변환은 추가 할당을 도입하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e701b3559c3cd620429a438a8bb4dcb9c99e51c" translate="yes" xml:space="preserve">
          <source>The transformation will not unbox arguments if it would result in the original function having sufficiently many arguments so as to inhibit tail-call optimisation.</source>
          <target state="translated">변환은 꼬리 호출 최적화를 억제하기 위해 충분히 많은 인수를 갖는 원래 함수가되는 경우 인수를 unbox하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3231a8b466d35dcee0deec7b0a92803db2aeb3cd" translate="yes" xml:space="preserve">
          <source>The transformations in this section relate to the splitting apart of &lt;em&gt;boxed&lt;/em&gt; (that is to say, non-immediate) values. They are largely intended to reduce allocation, which tends to result in a runtime performance profile with lower variance and smaller tails.</source>
          <target state="translated">이 섹션의 변환은 &lt;em&gt;박스형&lt;/em&gt; (즉, 비 즉시 적) 값 의 분할과 관련 됩니다. 주로 할당을 줄이기위한 것으로, 분산이 적고 꼬리가 더 작은 런타임 성능 프로필이 생성되는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eb73189e94327227c50de51480db7a0a57ff2cd" translate="yes" xml:space="preserve">
          <source>The two arguments used and max give the GC an idea of how much out-of-heap resources are consumed by the finalized block being allocated: you give the amount of resources allocated to this object as parameter used, and the maximum amount that you want to see in floating garbage as parameter max. The units are arbitrary: the GC cares only about the ratio used / max.</source>
          <target state="translated">사용 된 두 개의 인수와 max는 할당되는 최종 블록이 사용하는 힙 외 리소스의 양에 대한 아이디어를 GC에 제공합니다.이 개체에 할당 된 리소스의 양을 사용 된 매개 변수로 제공하고 원하는 최대 양을 제공합니다. 최대 매개 변수로 떠 다니는 쓰레기에서 볼 수 있습니다. 단위는 임의적입니다. GC는 사용 / 최대 비율에만 신경을 씁니다.</target>
        </trans-unit>
        <trans-unit id="de645ad92a5669480afb7be4dd3aef35389b655e" translate="yes" xml:space="preserve">
          <source>The two components of a type definition, the optional equation and the optional representation, can be combined independently, giving rise to four typical situations:</source>
          <target state="translated">유형 정의의 두 가지 구성 요소 인 선택적 방정식과 선택적 표현은 독립적으로 결합되어 다음과 같은 네 가지 일반적인 상황이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ed0d501a57672abb475f57d2ac37627ee51ce36b" translate="yes" xml:space="preserve">
          <source>The two parameters used and max are used to control the speed of garbage collection when the finalized object contains pointers to out-of-heap resources. Generally speaking, the OCaml incremental major collector adjusts its speed relative to the allocation rate of the program. The faster the program allocates, the harder the GC works in order to reclaim quickly unreachable blocks and avoid having large amount of &amp;ldquo;floating garbage&amp;rdquo; (unreferenced objects that the GC has not yet collected).</source>
          <target state="translated">사용 된 두 매개 변수와 max는 종료 된 개체에 힙이 부족한 리소스에 대한 포인터가 포함 된 경우 가비지 수집 속도를 제어하는 ​​데 사용됩니다. 일반적으로 OCaml 증분 주 수집기는 프로그램 할당 속도에 따라 속도를 조정합니다. 프로그램이 더 빨리 할당할수록 GC는 빠르게 도달 할 수없는 블록을 회수하고 많은 양의 &quot;부동 쓰레기&quot;(GC가 아직 수집하지 않은 참조되지 않은 객체)를 피하도록 더 열심히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1b4b8bfbffcea6080868e73fa6fa91ada3a5aee9" translate="yes" xml:space="preserve">
          <source>The type #&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; is a special kind of abbreviation. This abbreviation unifies with the type of any object belonging to a subclass of the class type &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;. It is handled in a special way as it usually hides a type variable (an ellipsis, representing the methods that may be added in a subclass). In particular, it vanishes when the ellipsis gets instantiated. Each type expression #&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; defines a new type variable, so type #&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;-&amp;gt;#&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; is usually not the same as type (#&lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;as'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;) -&amp;gt;'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;.</source>
          <target state="translated">유형 # &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; 는 특별한 종류의 약어입니다. 이 약어는 &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; 클래스 유형의 하위 클래스에 속하는 모든 객체 유형과 통합됩니다 . 일반적으로 유형 변수 (하위 클래스에 추가 될 수있는 메서드를 나타내는 줄임표)를 숨기므로 특수한 방식으로 처리됩니다. 특히 줄임표가 인스턴스화되면 사라집니다. 각 유형 표현식 # &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; 는 새로운 유형 변수를 정의하므로 유형 # &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path-&lt;/a&gt; &amp;gt; # &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; 는 일반적으로 유형 (# &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt; as ' &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; )-&amp;gt;' &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; 와 동일하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2098df733b38a624b57b6a1ed22bd572f1e7f4fb" translate="yes" xml:space="preserve">
          <source>The type &amp;lt; m : int &amp;gt; we see here is just the expansion of c, due to the use of a reference; we have succeeded in getting back an object of type c.</source>
          <target state="translated">여기서 볼 수있는 유형 &amp;lt;m : int&amp;gt;는 참조 사용으로 인한 c의 확장 일뿐입니다. 우리는 c 유형의 객체를 되 찾는 데 성공했습니다.</target>
        </trans-unit>
        <trans-unit id="2cb5a55287de7cc9d410124fb3cd96a5d5e22f24" translate="yes" xml:space="preserve">
          <source>The type &amp;lt; {&lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt;;} ..&amp;gt; is the type of an object whose method names and types are described by &lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;, and possibly some other methods represented by the ellipsis. This ellipsis actually is a special kind of type variable (called &lt;em&gt;row variable&lt;/em&gt; in the literature) that stands for any number of extra method types.</source>
          <target state="translated">&amp;lt;{ &lt;a href=&quot;#method-type&quot;&gt;method-type&lt;/a&gt; ;} ..&amp;gt; 유형은 메소드 이름과 유형이 &lt;a href=&quot;#method-type&quot;&gt;method-type &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip;, &lt;a href=&quot;#method-type&quot;&gt;method-type &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 및 줄임표로 표시되는 다른 메소드 로 설명되는 객체 유형입니다 . 이 줄임표는 실제로 임의의 수의 추가 메서드 유형을 나타내는 특수한 종류의 유형 변수 ( 문헌에서 &lt;em&gt;행 변수&lt;/em&gt; 라고 함 )입니다.</target>
        </trans-unit>
        <trans-unit id="ea78845a66a3de51237a6160ba5250e692cfe066" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;'a&amp;nbsp;t&lt;/code&gt; is a &lt;b&gt;delayed list&lt;/b&gt;, i.e. a list where some evaluation is needed to access the next element. This makes it possible to build infinite sequences, to build sequences as we traverse them, and to transform them in a lazy fashion rather than upfront.</source>
          <target state="translated">&lt;code&gt;'a&amp;nbsp;t&lt;/code&gt; 유형 은 &lt;b&gt;지연된 목록입니다&lt;/b&gt; . 즉, 다음 요소에 액세스하기 위해 평가가 필요한 목록입니다. 이것은 무한한 시퀀스를 구축하고, 우리가 순회하면서 시퀀스를 구축하고, 선불 방식이 아닌 게으른 방식으로 변환 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="3e093dd6adec72b6cbeb6815ff6a81bdec059a25" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Genarray.t&lt;/code&gt; is the type of Bigarrays with variable numbers of dimensions.</source>
          <target state="translated">유형 &lt;code&gt;Genarray.t&lt;/code&gt; 은 차원 변수 번호 Bigarrays의 유형이다.</target>
        </trans-unit>
        <trans-unit id="c17aafa409f735e2a7fb7b2d3ed8979e96c9a297" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Genarray.t&lt;/code&gt; is the type of Bigarrays with variable numbers of dimensions. Any number of dimensions between 0 and 16 is supported.</source>
          <target state="translated">유형 &lt;code&gt;Genarray.t&lt;/code&gt; 은 차원 변수 번호 Bigarrays의 유형이다. 0에서 16 사이의 모든 차원이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="444bb838dc88582dbd178720dcfda52e51470b21" translate="yes" xml:space="preserve">
          <source>The type N.t is incompatible with int, ensuring that nonnegative integers and regular integers are not confused. However, if x has type N.t, the coercion (x :&amp;gt; int) is legal and returns the underlying integer, just like N.to_int x. Deep coercions are also supported: if l has type N.t list, the coercion (l :&amp;gt; int list) returns the list of underlying integers, like List.map N.to_int l but without copying the list l.</source>
          <target state="translated">Nt 유형은 int와 호환되지 않으므로 음이 아닌 정수와 일반 정수가 혼동되지 않습니다. 그러나 x의 유형이 Nt 인 경우 강제 변환 (x :&amp;gt; int)은 합법적이며 N.to_int x와 마찬가지로 기본 정수를 반환합니다. 깊은 강제 변환도 지원됩니다. l 유형이 Nt 목록 인 경우 강제 변환 (l :&amp;gt; int 목록)은 List.map N.to_int l과 같이 기본 정수 목록을 반환하지만 목록 l을 복사하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa132651b99c1854c25fdf68be9f2ebc9e6e4a11" translate="yes" xml:space="preserve">
          <source>The type describing the status of an interval timer</source>
          <target state="translated">간격 타이머의 상태를 설명하는 유형</target>
        </trans-unit>
        <trans-unit id="25486382c0973b8dd5baf2bfa2b12dda90d4ed79" translate="yes" xml:space="preserve">
          <source>The type error here comes from the fact that during the definition of depth, the type checker first assigns to depth the type 'a -&amp;gt; 'b . When typing the pattern matching, 'a -&amp;gt; 'b becomes 'a nested -&amp;gt; 'b, then 'a nested -&amp;gt; int once the List branch is typed. However, when typing the application depth n in the Nested branch, the type checker encounters a problem: depth n is applied to 'a list nested, it must therefore have the type 'a list nested -&amp;gt; 'b. Unifying this constraint with the previous one leads to the impossible constraint 'a list nested = 'a nested. In other words, within its definition, the recursive function depth is applied to values of type 'a t with different types 'a due to the non-regularity of the type constructor nested. This creates a problem because the type checker had introduced a new type variable 'a only at the &lt;em&gt;definition&lt;/em&gt; of the function depth whereas, here, we need a different type variable for every &lt;em&gt;application&lt;/em&gt; of the function depth.</source>
          <target state="translated">여기서 유형 오류는 깊이를 정의하는 동안 유형 검사기가 먼저 깊이에 'a-&amp;gt;'b 유형을 할당한다는 사실에서 비롯됩니다. 패턴 매칭을 입력 할 때 'a-&amp;gt;'b는 'a nested-&amp;gt;'b가되고 List 브랜치가 입력되면 'a nested-&amp;gt; int'가됩니다. 그러나 Nested 분기에 응용 프로그램 깊이 n을 입력하면 유형 검사기에 문제가 발생합니다. 깊이 n이 '중첩 된 목록에 적용되므로'a 목록 중첩-&amp;gt; 'b 유형을 가져야합니다. 이 제약 조건을 이전 제약 조건과 통합하면 불가능한 제약 조건 'a list nested ='a nested. 즉, 정의 내에서 중첩 된 유형 생성자의 비정규 성으로 인해 'a 유형이 다른'at ​​유형의 값에 재귀 함수 깊이가 적용됩니다.이것은 유형 검사기가 새로운 유형 변수 'a&lt;em&gt;정의&lt;/em&gt; 함수 깊이는 반면, 여기, 우리는 모든에 대해 다른 유형의 변수를 필요로 &lt;em&gt;응용 프로그램&lt;/em&gt; 기능 깊이.</target>
        </trans-unit>
        <trans-unit id="1fa9c8aa5ef431c67c6adbd4b206fd03f62c7ba9" translate="yes" xml:space="preserve">
          <source>The type expression '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; stands for the type variable named &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;. The type expression _ stands for either an anonymous type variable or anonymous type parameters. In data type definitions, type variables are names for the data type parameters. In type constraints, they represent unspecified types that can be instantiated by any type to satisfy the type constraint. In general the scope of a named type variable is the whole top-level phrase where it appears, and it can only be generalized when leaving this scope. Anonymous variables have no such restriction. In the following cases, the scope of named type variables is restricted to the type expression where they appear: 1) for universal (explicitly polymorphic) type variables; 2) for type variables that only appear in public method specifications (as those variables will be made universal, as described in section &lt;a href=&quot;classes#sss%3Aclty-meth&quot;&gt;7.9.1&lt;/a&gt;); 3) for variables used as aliases, when the type they are aliased to would be invalid in the scope of the enclosing definition (i.e. when it contains free universal type variables, or locally defined types.)</source>
          <target state="translated">유형 표현식 ' &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; 는 &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; 라는 유형 변수를 나타냅니다.. 유형 표현식 _은 익명 유형 변수 또는 익명 유형 매개 변수를 나타냅니다. 데이터 유형 정의에서 유형 변수는 데이터 유형 매개 변수의 이름입니다. 형식 제약 조건에서는 형식 제약 조건을 충족하기 위해 모든 형식으로 인스턴스화 할 수있는 지정되지 않은 형식을 나타냅니다. 일반적으로 명명 된 유형 변수의 범위는 나타나는 전체 최상위 구문이며이 범위를 벗어날 때만 일반화 할 수 있습니다. 익명 변수에는 이러한 제한이 없습니다. 다음과 같은 경우 명명 된 형식 변수의 범위는 나타나는 형식 식으로 제한됩니다. 1) 범용 (명시 적으로 다형성) 형식 변수의 경우; 2) 공용 메서드 사양에만 나타나는 유형 변수의 경우 (섹션 &lt;a href=&quot;classes#sss%3Aclty-meth&quot;&gt;7.9.1에&lt;/a&gt; 설명 된대로 해당 변수가 범용으로 만들어 질 것이므로)); 3) 별칭으로 사용되는 변수의 경우 별칭이 지정된 유형이 둘러싸는 정의의 범위에서 유효하지 않을 때 (즉, 자유 범용 유형 변수 또는 로컬로 정의 된 유형을 포함하는 경우).</target>
        </trans-unit>
        <trans-unit id="b361863db6506eaaf72bc73833dd7a710012beed" translate="yes" xml:space="preserve">
          <source>The type expression (&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;) denotes the same type as &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="translated">유형 발현 ( &lt;a href=&quot;#typexpr&quot;&gt;typexpr가&lt;/a&gt; )와 같은 형태이다 &lt;a href=&quot;#typexpr&quot;&gt;typexpr를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="caf716551ec1bcc30d2653d9a50db98a601e3996" translate="yes" xml:space="preserve">
          <source>The type expression (&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;,&amp;hellip;, &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;) &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;, where &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; is a type constructor with n parameters, denotes the application of the n-ary type constructor &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; to the types &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; through &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.</source>
          <target state="translated">유형 표현식 ( &lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip;, &lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; ) &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; , 여기서 &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; 은 n 매개 변수가있는 유형 생성자이며 &lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ~ &lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 유형 에 대한 n 항 유형 생성자 &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; 의 적용을 나타냅니다 .&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="6b1267fea7ae64838d1130ee8c9de538451b3845" translate="yes" xml:space="preserve">
          <source>The type expression &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;, where &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; is a type constructor with one parameter, denotes the application of the unary type constructor &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; to the type &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="translated">타입 식 &lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; , &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr는&lt;/a&gt; 하나 개의 파라미터 타입 생성자는 단항 형 생성자의 응용이다 &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; 유형에 &lt;a href=&quot;#typexpr&quot;&gt;typexpr를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="134280a727f04e70e93aab40360430e6a4a2edfe" translate="yes" xml:space="preserve">
          <source>The type expression &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;* &amp;hellip; *&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; denotes the type of tuples whose elements belong to types &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; respectively.</source>
          <target state="translated">유형 표현식 &lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; *&amp;hellip; * &lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 은 요소가 각각 &lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip; &lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 유형에 속하는 튜플 유형을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="fd49bc22f7c62d9c4ae3e943e6b56abafe95d35b" translate="yes" xml:space="preserve">
          <source>The type expression &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; denotes the type of functions mapping arguments of type &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to results of type &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="translated">타입 식 &lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; -&amp;gt; &lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 유형의 인자 매핑 함수이고 유형 &lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 유형의 결과 &lt;a href=&quot;#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; .</target>
        </trans-unit>
        <trans-unit id="48f68ff9fb1de19b9947374a080e92592e2bffa5" translate="yes" xml:space="preserve">
          <source>The type expression &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;as'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; denotes the same type as &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;, and also binds the type variable &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; to type &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; both in &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; and in other types. In general the scope of an alias is the same as for a named type variable, and covers the whole enclosing definition. If the type variable &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; actually occurs in &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;, a recursive type is created. Recursive types for which there exists a recursive path that does not contain an object or polymorphic variant type constructor are rejected, except when the -rectypes mode is selected.</source>
          <target state="translated">유형 표현식 &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; as ' &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; 는 &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; 과 동일한 유형을 나타내며 &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; 및 다른 유형 모두에서 유형 변수 &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; 를 &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; 유형에 바인딩합니다 . 일반적으로 별칭의 범위는 명명 된 유형 변수의 범위와 동일하며 전체 둘러싸는 정의를 포함합니다. 유형 변수 &lt;a href=&quot;lex#ident&quot;&gt;ident가&lt;/a&gt; 실제로 &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; 에서 발생 하면 재귀 유형이 생성됩니다. -rectypes 모드가 선택된 경우를 제외하고는 객체 또는 다형성 변형 유형 생성자를 포함하지 않는 재귀 경로가있는 재귀 유형은 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="c6801841411231abefa49731a3af05dc93c2d6bf" translate="yes" xml:space="preserve">
          <source>The type for Unicode characters.</source>
          <target state="translated">유니 코드 문자의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="7710723d784526bfd14ff8684cd4f3768c3a88c0" translate="yes" xml:space="preserve">
          <source>The type for integer values.</source>
          <target state="translated">정수 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9382d7daf14dbc0dd9ad2ac68253c35ad1396cc7" translate="yes" xml:space="preserve">
          <source>The type for option values.</source>
          <target state="translated">옵션 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f5d8396849b8d6781e4d124b104e7abf0c738fb9" translate="yes" xml:space="preserve">
          <source>The type for option values. Either &lt;code&gt;None&lt;/code&gt; or a value &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt;.</source>
          <target state="translated">옵션 값의 유형입니다. 어느 &lt;code&gt;None&lt;/code&gt; 또는 값 &lt;code&gt;Some&amp;nbsp;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d6a4f1c52488e6ba5ba76a0aea28a22e82a6300" translate="yes" xml:space="preserve">
          <source>The type for result values.</source>
          <target state="translated">결과 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="93ce0c547a2cc6ec0a54327ae4897e498aad029d" translate="yes" xml:space="preserve">
          <source>The type for result values. Either a value &lt;code&gt;Ok&amp;nbsp;v&lt;/code&gt; or an error &lt;code&gt;Error&amp;nbsp;e&lt;/code&gt;.</source>
          <target state="translated">결과 값의 유형입니다. 값 &lt;code&gt;Ok&amp;nbsp;v&lt;/code&gt; 또는 오류 &lt;code&gt;Error&amp;nbsp;e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c0b6a8e9537b83d5facebd9c46c52d219d5b39a" translate="yes" xml:space="preserve">
          <source>The type inferred for sort, 'a list -&amp;gt; 'a list, means that sort can actually apply to lists of any type, and returns a list of the same type. The type 'a is a &lt;em&gt;type variable&lt;/em&gt;, and stands for any given type. The reason why sort can apply to lists of any type is that the comparisons (=, &amp;lt;=, etc.) are &lt;em&gt;polymorphic&lt;/em&gt; in OCaml: they operate between any two values of the same type. This makes sort itself polymorphic over all list types.</source>
          <target state="translated">정렬을 위해 유추 된 유형 'a list-&amp;gt;'a list는 정렬이 실제로 모든 유형의 목록에 적용될 수 있음을 의미하며 동일한 유형의 목록을 반환합니다. 유형 'a는 &lt;em&gt;유형 변수&lt;/em&gt; 이며 주어진 유형을 나타냅니다. 정렬이 모든 유형의 목록에 적용될 수있는 이유는 비교 (=, &amp;lt;= 등)가 OCaml에서 &lt;em&gt;다형성&lt;/em&gt; 이기 때문입니다. 동일한 유형의 두 값 사이에서 작동합니다. 이것은 정렬 자체를 모든 목록 유형에 대해 다형성으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9c08084fecb7e84be89d27f0d722611fa9cc32c8" translate="yes" xml:space="preserve">
          <source>The type name must be implemented by a type compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;. All users of the structure know that the type name is compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="translated">유형 이름은 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; 과 호환되는 유형으로 구현되어야합니다 . 구조의 모든 사용자는 유형 이름이 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; 과 호환된다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ebe16a502ab193556c30fa1d8f9ab51fb2a92a2" translate="yes" xml:space="preserve">
          <source>The type name must be implemented by a variant type or record type with exactly the constructors or fields specified. All users of the structure have access to the constructors or fields, and can use them to create or inspect values of that type. However, users of the structure consider that type as incompatible with any other type: a fresh type has been generated.</source>
          <target state="translated">유형 이름은 지정된 생성자 또는 필드와 함께 변형 유형 또는 레코드 유형으로 구현되어야합니다. 구조의 모든 사용자는 생성자 또는 필드에 액세스 할 수 있으며이를 사용하여 해당 유형의 값을 생성하거나 검사 할 수 있습니다. 그러나 구조 사용자는 해당 유형을 다른 유형과 호환되지 않는 것으로 간주합니다. 새로운 유형이 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="95162088ecc49c178a74b8a108f2f06d181cf540" translate="yes" xml:space="preserve">
          <source>The type of (read-only) character strings.</source>
          <target state="translated">(읽기 전용) 문자열의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="0cb54904d6ce772d0ceeac1ee805267485217e2e" translate="yes" xml:space="preserve">
          <source>The type of (writable) byte sequences.</source>
          <target state="translated">(쓰기 가능한) 바이트 시퀀스의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="175f1511e76274de17f3f982e04261ad9ff87edf" translate="yes" xml:space="preserve">
          <source>The type of Oo.copy is the following:</source>
          <target state="translated">Oo.copy의 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ed9cbb3bbfa2f749813e7746851407d1f9f2830e" translate="yes" xml:space="preserve">
          <source>The type of PRNG states.</source>
          <target state="translated">PRNG 상태의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="31f3bef48e012323310e56008b546bd70a23ee79" translate="yes" xml:space="preserve">
          <source>The type of a generator module depends on the kind of generated documentation. Here is the list of generator module types, with the name of the generator class in the module :</source>
          <target state="translated">생성기 모듈의 유형은 생성 된 문서의 종류에 따라 다릅니다. 다음은 모듈의 생성기 클래스 이름과 함께 생성기 모듈 유형 목록입니다.</target>
        </trans-unit>
        <trans-unit id="474468ccde94e04dc6d84d6aa522d6290591ae8e" translate="yes" xml:space="preserve">
          <source>The type of arrays of weak pointers (weak arrays).</source>
          <target state="translated">약한 포인터의 배열 유형 (약한 배열).</target>
        </trans-unit>
        <trans-unit id="49335a2fa0da36592772610d625d9e7862131665" translate="yes" xml:space="preserve">
          <source>The type of arrays of weak pointers (weak arrays). A weak pointer is a value that the garbage collector may erase whenever the value is not used any more (through normal pointers) by the program. Note that finalisation functions are run before the weak pointers are erased, because the finalisation functions can make values alive again (before 4.03 the finalisation functions were run after).</source>
          <target state="translated">약한 포인터의 배열 유형 (약한 배열). 약한 포인터는 프로그램에서 값이 더 이상 (일반 포인터를 통해) 사용되지 않을 때마다 가비지 수집기가 지울 수있는 값입니다. 종료 함수는 종료 함수가 값을 다시 살릴 수 있기 때문에 약한 포인터가 삭제되기 전에 실행됩니다 (4.03 이전에는 종료 함수가 이후에 실행 됨).</target>
        </trans-unit>
        <trans-unit id="b2b210af5769dfe8a33b57a953fcf512009f49e6" translate="yes" xml:space="preserve">
          <source>The type of arrays whose elements have type 'a.</source>
          <target state="translated">요소 유형이 'a.</target>
        </trans-unit>
        <trans-unit id="0595a4cfa984f250f4abe368aae01bbd26bbe40a" translate="yes" xml:space="preserve">
          <source>The type of booleans (truth values).</source>
          <target state="translated">부울 유형 (진실 값).</target>
        </trans-unit>
        <trans-unit id="57f43364adb027e8e1ba3b2312688a97e5a4bfee" translate="yes" xml:space="preserve">
          <source>The type of characters.</source>
          <target state="translated">문자 유형입니다.</target>
        </trans-unit>
        <trans-unit id="8faa31d4f6bd583eef19e62cfd7cf4d795b85cb0" translate="yes" xml:space="preserve">
          <source>The type of commands for &lt;code&gt;shutdown&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shutdown&lt;/code&gt; 명령 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="3b3f99b8924ec20003595b05b507f3dd92f84242" translate="yes" xml:space="preserve">
          <source>The type of communication channels carrying values of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'a&lt;/code&gt; 유형 의 값을 전달하는 통신 채널 유형 .</target>
        </trans-unit>
        <trans-unit id="e4bee64553824e660fa6229cc5c7107b80d346c9" translate="yes" xml:space="preserve">
          <source>The type of communication events returning a result of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'a&lt;/code&gt; 유형의 결과를 반환하는 통신 이벤트 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="4694bbb21fec365f7f23def5ef3c32491f195566" translate="yes" xml:space="preserve">
          <source>The type of compiled regular expressions.</source>
          <target state="translated">컴파일 된 정규식의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="cf94d66ebaa6a6bac9b3992799eba28dae304024" translate="yes" xml:space="preserve">
          <source>The type of complex numbers.</source>
          <target state="translated">복소수의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9493cdeccb2ee09d3bbc2192a85ea88bdc22d219" translate="yes" xml:space="preserve">
          <source>The type of complex numbers. &lt;code&gt;re&lt;/code&gt; is the real part and &lt;code&gt;im&lt;/code&gt; the imaginary part.</source>
          <target state="translated">복소수의 유형입니다. &lt;code&gt;re&lt;/code&gt; 는 실제 부분이고 &lt;code&gt;im&lt;/code&gt; 은 가상 부분입니다.</target>
        </trans-unit>
        <trans-unit id="a919227d85c7433279106182e9342eaf933551d4" translate="yes" xml:space="preserve">
          <source>The type of condition variables.</source>
          <target state="translated">조건 변수의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="2948f756f59cbab66ed838f1fd09d9a51206608c" translate="yes" xml:space="preserve">
          <source>The type of delayed lists containing elements of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'a&lt;/code&gt; 유형 의 요소를 포함하는 지연된 목록 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="19b1cace17bd70c1c864fc3ccf8d84d6aeafa3b9" translate="yes" xml:space="preserve">
          <source>The type of delayed lists containing elements of type &lt;code&gt;'a&lt;/code&gt;. Note that the concrete list node &lt;code&gt;'a&amp;nbsp;node&lt;/code&gt; is delayed under a closure, not a &lt;code&gt;lazy&lt;/code&gt; block, which means it might be recomputed every time we access it.</source>
          <target state="translated">&lt;code&gt;'a&lt;/code&gt; 유형 의 요소를 포함하는 지연된 목록 유형입니다 . 콘크리트 목록 노드주의 &lt;code&gt;'a&amp;nbsp;node&lt;/code&gt; , 폐쇄에서가 아니라 지연 &lt;code&gt;lazy&lt;/code&gt; 우리가 그것을 액세스 할 때마다 다시 계산 될 수 즉, 블록.</target>
        </trans-unit>
        <trans-unit id="528bf9052fce3ac6805ffa892e89bbfb27784ec6" translate="yes" xml:space="preserve">
          <source>The type of descriptors over opened directories.</source>
          <target state="translated">열린 디렉토리에 대한 설명 자의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="416a1434458aaedb356cff26edc4284a6edf9ec7" translate="yes" xml:space="preserve">
          <source>The type of digests: 16-character strings.</source>
          <target state="translated">다이제스트 유형 : 16 자 문자열.</target>
        </trans-unit>
        <trans-unit id="ed7f6fa3fdb11f6e5f157b97ab1334e5206abde6" translate="yes" xml:space="preserve">
          <source>The type of error codes.</source>
          <target state="translated">오류 코드의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="374429438a468e5405acbf7c3ebd3a8090be7716" translate="yes" xml:space="preserve">
          <source>The type of error codes. Errors defined in the POSIX standard and additional errors from UNIX98 and BSD. All other errors are mapped to EUNKNOWNERR.</source>
          <target state="translated">오류 코드의 유형입니다. POSIX 표준에 정의 된 오류와 UNIX98 및 BSD의 추가 오류. 다른 모든 오류는 EUNKNOWNERR에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="90aa20107e0953510225d3286a9c720778df2ae3" translate="yes" xml:space="preserve">
          <source>The type of exception values.</source>
          <target state="translated">예외 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6d9a06fd1a883a7ff59af6a47cff3a54b165e238" translate="yes" xml:space="preserve">
          <source>The type of file access rights, e.g.</source>
          <target state="translated">파일 액세스 권한 유형, 예 :</target>
        </trans-unit>
        <trans-unit id="c7a1b61ab121d17826ae99852665f41b9088bb6f" translate="yes" xml:space="preserve">
          <source>The type of file access rights, e.g. &lt;code&gt;0o640&lt;/code&gt; is read and write for user, read for group, none for others</source>
          <target state="translated">파일 액세스 권한 유형 (예 : &lt;code&gt;0o640&lt;/code&gt; 은 사용자에 대해 읽기 및 쓰기, 그룹에 대해 읽기, 기타에 대해 없음)입니다.</target>
        </trans-unit>
        <trans-unit id="dd46f8d4353ac7fec53695a7079f8ba6a127a094" translate="yes" xml:space="preserve">
          <source>The type of float arrays with packed representation.</source>
          <target state="translated">패킹 된 표현이있는 float 배열의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1ae512fb6e68d577ece237ab0b35021285c8a32b" translate="yes" xml:space="preserve">
          <source>The type of floating-point numbers.</source>
          <target state="translated">부동 소수점 숫자의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="882f6167872619af22e623d191dbe06d50c3e5c8" translate="yes" xml:space="preserve">
          <source>The type of format strings. 'a is the type of the parameters of the format, 'f is the result type for the printf-style functions, 'b is the type of the first argument given to %a and %t printing functions (see module &lt;a href=&quot;libref/printf&quot;&gt;Printf&lt;/a&gt;), 'c is the result type of these functions, and also the type of the argument transmitted to the first argument of kprintf-style functions, 'd is the result type for the scanf-style functions (see module &lt;a href=&quot;libref/scanf&quot;&gt;Scanf&lt;/a&gt;), and 'e is the type of the receiver function for the scanf-style functions.</source>
          <target state="translated">형식 문자열의 유형입니다. 'a는 형식의 매개 변수 유형,'f는 printf 스타일 함수의 결과 유형, 'b는 % a 및 % t 인쇄 함수에 제공된 첫 번째 인수의 유형입니다 ( &lt;a href=&quot;libref/printf&quot;&gt;Printf&lt;/a&gt; 모듈 참조 ),' c는 이러한 함수의 결과 유형이며 kprintf 스타일 함수의 첫 번째 인수로 전송되는 인수의 유형이며 'd는 scanf 스타일 함수의 결과 유형이며 (모듈 &lt;a href=&quot;libref/scanf&quot;&gt;Scanf&lt;/a&gt; 참조 )'e는 scanf 스타일 함수에 대한 수신기 함수 유형.</target>
        </trans-unit>
        <trans-unit id="19c398a9ad6d40134bc9da4aab8cb49e3ed44b56" translate="yes" xml:space="preserve">
          <source>The type of formatted input scanners: &lt;code&gt;('a,&amp;nbsp;'b,&amp;nbsp;'c,&amp;nbsp;'d)&amp;nbsp;scanner&lt;/code&gt; is the type of a formatted input function that reads from some formatted input channel according to some format string; more precisely, if &lt;code&gt;scan&lt;/code&gt; is some formatted input function, then &lt;code&gt;scan&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ic&amp;nbsp;fmt&amp;nbsp;f&lt;/code&gt; applies &lt;code&gt;f&lt;/code&gt; to all the arguments specified by format string &lt;code&gt;fmt&lt;/code&gt;, when &lt;code&gt;scan&lt;/code&gt; has read those arguments from the &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt;&lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt;&lt;/a&gt; formatted input channel &lt;code&gt;ic&lt;/code&gt;.</source>
          <target state="translated">형식화 된 입력 스캐너의 유형 : &lt;code&gt;('a,&amp;nbsp;'b,&amp;nbsp;'c,&amp;nbsp;'d)&amp;nbsp;scanner&lt;/code&gt; 는 형식 문자열에 따라 형식이 지정된 일부 입력 채널에서 읽는 형식화 된 입력 함수의 유형입니다. 보다 정확하게 는 &lt;code&gt;scan&lt;/code&gt; 이 형식화 된 입력 함수 인 경우 &lt;code&gt;scan&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;ic&amp;nbsp;fmt&amp;nbsp;f&lt;/code&gt; 는 &lt;code&gt;scan&lt;/code&gt; 이 &lt;a href=&quot;scanf.scanning#TYPEin_channel&quot;&gt; &lt;code&gt;Scanf.Scanning.in_channel&lt;/code&gt; &lt;/a&gt; 형식의 입력 채널 &lt;code&gt;ic&lt;/code&gt; 에서 해당 인수를 읽을 때 형식 문자열 &lt;code&gt;fmt&lt;/code&gt; 로 지정된 모든 인수에 &lt;code&gt;f&lt;/code&gt; 를 적용 합니다 .</target>
        </trans-unit>
        <trans-unit id="aea5a1b18ac88613e37414b6827c2703455101bb" translate="yes" xml:space="preserve">
          <source>The type of hash tables from type &lt;code&gt;'a&lt;/code&gt; to type &lt;code&gt;'b&lt;/code&gt;.</source>
          <target state="translated">형에서 해시 테이블의 종류 &lt;code&gt;'a&lt;/code&gt; 유형 &lt;code&gt;'b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="696255785a919ef1978b95f3b810845f1d5f24f3" translate="yes" xml:space="preserve">
          <source>The type of input channel.</source>
          <target state="translated">입력 채널의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="2733bfc9210840c12ac529e5664090014cfaed19" translate="yes" xml:space="preserve">
          <source>The type of integer numbers.</source>
          <target state="translated">정수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="12a16543916e281f6e705178f7068ae7b81eabd0" translate="yes" xml:space="preserve">
          <source>The type of lexer buffers.</source>
          <target state="translated">렉서 버퍼의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="9e6ff741c03d54a16b116276f6d1b7c29c419556" translate="yes" xml:space="preserve">
          <source>The type of lexer buffers. A lexer buffer is the argument passed to the scanning functions defined by the generated scanners. The lexer buffer holds the current state of the scanner, plus a function to refill the buffer from the input.</source>
          <target state="translated">렉서 버퍼의 유형입니다. 렉서 버퍼는 생성 된 스캐너에 의해 정의 된 스캐닝 함수에 전달되는 인수입니다. 렉서 버퍼는 스캐너의 현재 상태와 입력에서 버퍼를 다시 채우는 기능을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="6b78930ebe1ff9598f2ce1e960c8d2f960ca9edd" translate="yes" xml:space="preserve">
          <source>The type of lists whose elements have type 'a.</source>
          <target state="translated">요소 유형이 'a.</target>
        </trans-unit>
        <trans-unit id="0f4c8fdad1b3bd84e4c3cca78b35e83c55b502de" translate="yes" xml:space="preserve">
          <source>The type of location information found in backtraces.</source>
          <target state="translated">역 추적에서 찾은 위치 정보의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="498bd9a851a6cfafcb8f5766233f38fdc36ca792" translate="yes" xml:space="preserve">
          <source>The type of location information found in backtraces. &lt;code&gt;start_char&lt;/code&gt; and &lt;code&gt;end_char&lt;/code&gt; are positions relative to the beginning of the line.</source>
          <target state="translated">역 추적에서 찾은 위치 정보의 유형입니다. &lt;code&gt;start_char&lt;/code&gt; 및 &lt;code&gt;end_char&lt;/code&gt; 는 줄의 시작에 상대적인 위치입니다.</target>
        </trans-unit>
        <trans-unit id="ed706b6a75175b21f33900096f47f5ce25dcd56f" translate="yes" xml:space="preserve">
          <source>The type of maps from type &lt;code&gt;key&lt;/code&gt; to type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">유형 &lt;code&gt;key&lt;/code&gt; 에서 &lt;code&gt;'a&lt;/code&gt; 유형으로의 맵핑 유형 .</target>
        </trans-unit>
        <trans-unit id="5234180ce852e2c9add54e2a43fe30af56ce71bf" translate="yes" xml:space="preserve">
          <source>The type of metadata associated with allocations.</source>
          <target state="translated">할당과 관련된 메타 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="2a7ce6248520399ff389ae062f84b764cade9171" translate="yes" xml:space="preserve">
          <source>The type of metadata associated with allocations. This is the type of records passed to the callback triggered by the sampling of an allocation.</source>
          <target state="translated">할당과 관련된 메타 데이터 유형입니다. 할당 샘플링에 의해 트리거 된 콜백에 전달되는 레코드 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c1e287e9bbc376eb420f29d58e9d26ead8ee6aa7" translate="yes" xml:space="preserve">
          <source>The type of mutexes.</source>
          <target state="translated">뮤텍스의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="74a3a571763275675b862ae9f296a04facfd9dc7" translate="yes" xml:space="preserve">
          <source>The type of one-dimensional Bigarrays whose elements have OCaml type &lt;code&gt;'a&lt;/code&gt;, representation kind &lt;code&gt;'b&lt;/code&gt;, and memory layout &lt;code&gt;'c&lt;/code&gt;.</source>
          <target state="translated">요소가 OCaml 유형 &lt;code&gt;'a&lt;/code&gt; , 표현 유형 &lt;code&gt;'b&lt;/code&gt; 및 메모리 레이아웃 &lt;code&gt;'c&lt;/code&gt; 를 갖는 1 차원 Bigarray 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="427b82aee3c183b2b5534df6717057b224234245" translate="yes" xml:space="preserve">
          <source>The type of optional values of type 'a.</source>
          <target state="translated">유형 'a.</target>
        </trans-unit>
        <trans-unit id="a247986af85700af0514a9a8547e14b281ce0624" translate="yes" xml:space="preserve">
          <source>The type of output channel.</source>
          <target state="translated">출력 채널의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="bb4593e8016738b30531d3a2d698c5003680100a" translate="yes" xml:space="preserve">
          <source>The type of queues containing elements of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'a&lt;/code&gt; 유형 의 요소를 포함하는 큐 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="2ed3d947a75f974c4a636eeee9cca0bdcea8439d" translate="yes" xml:space="preserve">
          <source>The type of references (mutable indirection cells) containing a value of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'a&lt;/code&gt; 유형 의 값을 포함하는 참조 유형 (변경 가능한 간접 셀) 입니다.</target>
        </trans-unit>
        <trans-unit id="0c47f9a8e4ac2d5a708feb705e0eb216916eb90e" translate="yes" xml:space="preserve">
          <source>The type of scanning buffers.</source>
          <target state="translated">스캔 버퍼의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="641cb810f5f62717bfd7cda0a11b14f8777c6464" translate="yes" xml:space="preserve">
          <source>The type of scanning buffers. A scanning buffer is the source from which a formatted input function gets characters. The scanning buffer holds the current state of the scan, plus a function to get the next char from the input, and a token buffer to store the string matched so far.</source>
          <target state="translated">스캔 버퍼의 유형입니다. 스캐닝 버퍼는 형식화 된 입력 함수가 문자를 가져 오는 소스입니다. 스캐닝 버퍼는 스캔의 현재 상태와 입력에서 다음 문자를 가져 오는 함수와 지금까지 일치하는 문자열을 저장하는 토큰 버퍼를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="2da9a74d002d27ad159cff07bde988e8e266d179" translate="yes" xml:space="preserve">
          <source>The type of sets.</source>
          <target state="translated">세트 유형입니다.</target>
        </trans-unit>
        <trans-unit id="00e670e3a2a21e4cdf70bf2240d4a5a94082c733" translate="yes" xml:space="preserve">
          <source>The type of signed 32-bit integers. Literals for 32-bit integers are suffixed by l. See the &lt;a href=&quot;libref/int32&quot;&gt;Int32&lt;/a&gt; module.</source>
          <target state="translated">부호있는 32 비트 정수 유형입니다. 32 비트 정수에 대한 리터럴에는 l이 접미사로 붙습니다. &lt;a href=&quot;libref/int32&quot;&gt;Int32&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="049aa2f5e1bceacd2dc3e7900753d299e293a211" translate="yes" xml:space="preserve">
          <source>The type of signed 64-bit integers. Literals for 64-bit integers are suffixed by L. See the &lt;a href=&quot;libref/int64&quot;&gt;Int64&lt;/a&gt; module.</source>
          <target state="translated">부호있는 64 비트 정수 유형입니다. 64 비트 정수에 대한 리터럴은 L이 접미사로 붙습니다. &lt;a href=&quot;libref/int64&quot;&gt;Int64&lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="14572b24035765d23bfc1ab5989635cd85be76c9" translate="yes" xml:space="preserve">
          <source>The type of signed, platform-native integers (32 bits on 32-bit processors, 64 bits on 64-bit processors). Literals for native integers are suffixed by n. See the &lt;a href=&quot;libref/nativeint&quot;&gt;Nativeint&lt;/a&gt; module.</source>
          <target state="translated">부호있는 플랫폼 고유 정수의 유형입니다 (32 비트 프로세서에서는 32 비트, 64 비트 프로세서에서는 64 비트). 네이티브 정수에 대한 리터럴은 n이 접미사로 붙습니다. &lt;a href=&quot;libref/nativeint&quot;&gt;Nativeint&lt;/a&gt; 모듈을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="de5b2958f6bf6b0150e2e607a78d659c4f79eb05" translate="yes" xml:space="preserve">
          <source>The type of socket addresses.</source>
          <target state="translated">소켓 주소의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="db586c580808d7d4b0a9c2a68894ac1deac9713a" translate="yes" xml:space="preserve">
          <source>The type of socket addresses. &lt;code&gt;ADDR_UNIX&amp;nbsp;name&lt;/code&gt; is a socket address in the Unix domain; &lt;code&gt;name&lt;/code&gt; is a file name in the file system. &lt;code&gt;ADDR_INET(addr,port)&lt;/code&gt; is a socket address in the Internet domain; &lt;code&gt;addr&lt;/code&gt; is the Internet address of the machine, and &lt;code&gt;port&lt;/code&gt; is the port number.</source>
          <target state="translated">소켓 주소의 유형입니다. &lt;code&gt;ADDR_UNIX&amp;nbsp;name&lt;/code&gt; 은 Unix 도메인의 소켓 주소입니다. &lt;code&gt;name&lt;/code&gt; 은 파일 시스템의 파일 이름입니다. &lt;code&gt;ADDR_INET(addr,port)&lt;/code&gt; 는 인터넷 도메인의 소켓 주소입니다. &lt;code&gt;addr&lt;/code&gt; 은 시스템의 인터넷 주소이고 &lt;code&gt;port&lt;/code&gt; 는 포트 번호입니다.</target>
        </trans-unit>
        <trans-unit id="608407eaec3033fe97cbe414b0ad430f843c8db2" translate="yes" xml:space="preserve">
          <source>The type of socket domains.</source>
          <target state="translated">소켓 도메인의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="57d14d79c33e13c0f239ad5001df98545855ce4a" translate="yes" xml:space="preserve">
          <source>The type of socket domains. Not all platforms support IPv6 sockets (type &lt;code&gt;PF_INET6&lt;/code&gt;).</source>
          <target state="translated">소켓 도메인의 유형입니다. 모든 플랫폼이 IPv6 소켓을 지원하는 것은 아닙니다 (유형 &lt;code&gt;PF_INET6&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5b519e0b22d95beab7899e8dfff601ea38a0a80e" translate="yes" xml:space="preserve">
          <source>The type of socket domains. Not all platforms support IPv6 sockets (type &lt;code&gt;PF_INET6&lt;/code&gt;). Windows does not support &lt;code&gt;PF_UNIX&lt;/code&gt;.</source>
          <target state="translated">소켓 도메인의 유형입니다. 모든 플랫폼이 IPv6 소켓을 지원하는 것은 아닙니다 (유형 &lt;code&gt;PF_INET6&lt;/code&gt; ). Windows는 &lt;code&gt;PF_UNIX&lt;/code&gt; 를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2727d81576dab1fb5a38c8713ea564ef66856040" translate="yes" xml:space="preserve">
          <source>The type of socket kinds, specifying the semantics of communications.</source>
          <target state="translated">통신의 의미를 지정하는 소켓 종류의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1b3007fcdc44e3284ad3118e0dffc7d71aaf743c" translate="yes" xml:space="preserve">
          <source>The type of socket kinds, specifying the semantics of communications. &lt;code&gt;SOCK_SEQPACKET&lt;/code&gt; is included for completeness, but is rarely supported by the OS, and needs system calls that are not available in this library.</source>
          <target state="translated">통신의 의미를 지정하는 소켓 종류의 유형입니다. &lt;code&gt;SOCK_SEQPACKET&lt;/code&gt; 은 완전성을 위해 포함되지만 OS에서 거의 지원되지 않으며이 라이브러리에서 사용할 수없는 시스템 호출이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="156e03b4fa592223c0c98868c0491cee08f03432" translate="yes" xml:space="preserve">
          <source>The type of stacks containing elements of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'a&lt;/code&gt; 유형 의 요소를 포함하는 스택 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="3f65d04f78e3ceb4ae3eccd621111d1fffe7fea7" translate="yes" xml:space="preserve">
          <source>The type of streams holding values of type &lt;code&gt;'a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'a&lt;/code&gt; 유형 의 값을 보유하는 스트림 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="6765ffbd6cdd35348726a7b361a85542a02c62ba" translate="yes" xml:space="preserve">
          <source>The type of tables that contain elements of type &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 유형의 요소를 포함하는 테이블 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="d36f05d8ed34a2aeecd6a307e47d3388f2f3349d" translate="yes" xml:space="preserve">
          <source>The type of tables that contain elements of type &lt;code&gt;data&lt;/code&gt;. Note that weak hash sets cannot be marshaled using &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt; or the functions of the &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 유형의 요소를 포함하는 테이블 유형입니다 . 약한 해시 세트는 &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt; &lt;code&gt;output_value&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;marshal&quot;&gt; &lt;code&gt;Marshal&lt;/code&gt; &lt;/a&gt; 모듈 의 함수를 사용하여 마샬링 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="376291c83380bfe855667ba5075e67da3fc440d1" translate="yes" xml:space="preserve">
          <source>The type of the elements stored in the table.</source>
          <target state="translated">테이블에 저장된 요소의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="27a01f06c2807810d54d563bff488d148e91f692" translate="yes" xml:space="preserve">
          <source>The type of the hashtable keys.</source>
          <target state="translated">해시 테이블 키의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="419849ba8c429fc85eb7b7159392b7645493c383" translate="yes" xml:space="preserve">
          <source>The type of the map keys.</source>
          <target state="translated">맵 키의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="07c0446d50346f3a3a5ced32244b2b1d6aa72fb4" translate="yes" xml:space="preserve">
          <source>The type of the set elements.</source>
          <target state="translated">집합 요소의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="5f9b34617afb59cca236cf1ed744d053aeba331d" translate="yes" xml:space="preserve">
          <source>The type of the unit value.</source>
          <target state="translated">단위 값의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="558f0da7756d6b8a5e6fa053bc9e88665bde8e00" translate="yes" xml:space="preserve">
          <source>The type of this expression, t, contains type variables that cannot be generalized</source>
          <target state="translated">이 표현식의 유형 인 t는 일반화 할 수없는 유형 변수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="f38374ae48a76fc267fc266e7d1fb3adac8f8923" translate="yes" xml:space="preserve">
          <source>The type of thread handles.</source>
          <target state="translated">스레드 핸들 유형입니다.</target>
        </trans-unit>
        <trans-unit id="911e648755e2ce01883554d3b0a3d8fbef08dfa3" translate="yes" xml:space="preserve">
          <source>The type of three-dimensional Bigarrays whose elements have OCaml type &lt;code&gt;'a&lt;/code&gt;, representation kind &lt;code&gt;'b&lt;/code&gt;, and memory layout &lt;code&gt;'c&lt;/code&gt;.</source>
          <target state="translated">요소가 OCaml 유형 &lt;code&gt;'a&lt;/code&gt; , 표현 유형 &lt;code&gt;'b&lt;/code&gt; , 메모리 레이아웃 &lt;code&gt;'c&lt;/code&gt; 를 갖는 3 차원 Bigarray 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="a93d7af7669a780db37d7a6a35b93628bedc91cc" translate="yes" xml:space="preserve">
          <source>The type of tokens.</source>
          <target state="translated">토큰 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a2fe884e37cec8d7d8dffba0f78cacab0927a183" translate="yes" xml:space="preserve">
          <source>The type of tokens. The lexical classes are: &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Float&lt;/code&gt; for integer and floating-point numbers; &lt;code&gt;String&lt;/code&gt; for string literals, enclosed in double quotes; &lt;code&gt;Char&lt;/code&gt; for character literals, enclosed in single quotes; &lt;code&gt;Ident&lt;/code&gt; for identifiers (either sequences of letters, digits, underscores and quotes, or sequences of 'operator characters' such as &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, etc); and &lt;code&gt;Kwd&lt;/code&gt; for keywords (either identifiers or single 'special characters' such as &lt;code&gt;(&lt;/code&gt;, &lt;code&gt;}&lt;/code&gt;, etc).</source>
          <target state="translated">토큰 유형입니다. 어휘 클래스는 다음 과 같습니다. 정수 및 부동 소수점 숫자의 경우 &lt;code&gt;Int&lt;/code&gt; 및 &lt;code&gt;Float&lt;/code&gt; ; 큰 따옴표로 묶인 문자열 리터럴의 &lt;code&gt;String&lt;/code&gt; 입니다. 문자 리터럴의 경우 작은 따옴표로 묶인 &lt;code&gt;Char&lt;/code&gt; 입니다. &lt;code&gt;Ident&lt;/code&gt; 식별자 (하나의 문자, 숫자, 밑줄 시세, 또는 시퀀스의 순서와 같은 '운영자 캐릭터 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 등); 및 키워드에 대한 &lt;code&gt;Kwd&lt;/code&gt; (식별자 또는 &lt;code&gt;(&lt;/code&gt; , &lt;code&gt;}&lt;/code&gt; 등의 단일 '특수 문자' ).</target>
        </trans-unit>
        <trans-unit id="a131ee154ce5805d4743ddd4e7ac6f8f0a846600" translate="yes" xml:space="preserve">
          <source>The type of two-dimensional Bigarrays whose elements have OCaml type &lt;code&gt;'a&lt;/code&gt;, representation kind &lt;code&gt;'b&lt;/code&gt;, and memory layout &lt;code&gt;'c&lt;/code&gt;.</source>
          <target state="translated">요소가 OCaml 유형 &lt;code&gt;'a&lt;/code&gt; , 표현 유형 &lt;code&gt;'b&lt;/code&gt; 및 메모리 레이아웃 &lt;code&gt;'c&lt;/code&gt; 를 갖는 2 차원 Bigarray 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="fb1acfc22850de31c2fb5225a9fc570f7727191c" translate="yes" xml:space="preserve">
          <source>The type of zero-dimensional Bigarrays whose elements have OCaml type &lt;code&gt;'a&lt;/code&gt;, representation kind &lt;code&gt;'b&lt;/code&gt;, and memory layout &lt;code&gt;'c&lt;/code&gt;.</source>
          <target state="translated">요소가 OCaml 유형 &lt;code&gt;'a&lt;/code&gt; , 표현 유형 &lt;code&gt;'b&lt;/code&gt; 및 메모리 레이아웃 &lt;code&gt;'c&lt;/code&gt; 를 갖는 0 차원 Bigarray 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="6c3babab89ffd173e9518cc78562c29d921585ef" translate="yes" xml:space="preserve">
          <source>The type parameter in the declaration may actually be constrained in the body of the class definition. In the class type, the actual value of the type parameter is displayed in the constraint clause.</source>
          <target state="translated">선언의 형식 매개 변수는 실제로 클래스 정의 본문에서 제한 될 수 있습니다. 클래스 유형에서 유형 매개 변수의 실제 값은 제약 절에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5037564652e82350a92a754ff0cf691d4922b52e" translate="yes" xml:space="preserve">
          <source>The type representation = [|] &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; { |&lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; } describes a variant type. The constructor declarations &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; describe the constructors associated to this variant type. The constructor declaration &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;* &amp;hellip; *&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; declares the name &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt; as a non-constant constructor, whose arguments have types &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. The constructor declaration &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt; declares the name &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt; as a constant constructor. Constructor names must be capitalized.</source>
          <target state="translated">유형 표현 = [|] &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; {| &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt; }은 변형 유형을 설명합니다. 생성자 선언 &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip;, &lt;a href=&quot;#constr-decl&quot;&gt;constr-decl &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 은이 변형 유형과 관련된 생성자를 설명합니다. &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; *&amp;hellip; * &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 의 생성자 선언 &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt; 은 인수가 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;n을&lt;/sub&gt; 갖는 상수가 아닌 생성자로 이름 &lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt; 을 선언합니다 . 생성자 선언 &lt;a href=&quot;names#constr-name&quot;&gt;은 constr-name은&lt;/a&gt; 이름 선언 &lt;a href=&quot;names#constr-name&quot;&gt;은 constr 이름을&lt;/a&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;&lt;sub&gt;&lt;/sub&gt;상수 생성자로. 생성자 이름은 대문자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="6bb673b534c3fd2e98456972d5696bd025fa4d55" translate="yes" xml:space="preserve">
          <source>The type representation ={&lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt; { ;&lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt; } [;] } describes a record type. The field declarations &lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;, &lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; describe the fields associated to this record type. The field declaration &lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt; declares &lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt; as a field whose argument has type &lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;. The field declaration mutable&lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;  behaves similarly; in addition, it allows physical modification of this field. Immutable fields are covariant, mutable fields are non-variant. Both mutable and immutable fields may have explicitly polymorphic types. The polymorphism of the contents is statically checked whenever a record value is created or modified. Extracted values may have their types instantiated.</source>
          <target state="translated">유형 표현 = { &lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt; {; &lt;a href=&quot;#field-decl&quot;&gt;field-decl&lt;/a&gt; } [;]}은 레코드 유형을 설명합니다. &lt;a href=&quot;#field-decl&quot;&gt;field-decl &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip;, &lt;a href=&quot;#field-decl&quot;&gt;field-decl &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 필드 선언 은이 레코드 유형과 연관된 필드를 설명합니다. 필드 선언 &lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt; : &lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt; 은 &lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt; 을 인수 유형이 &lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt; 인 필드로 선언 합니다 . 필드 선언 가변 &lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt; : &lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;유사하게 행동합니다. 또한이 필드를 물리적으로 수정할 수 있습니다. 변경 불가능한 필드는 공변이고 변경 가능한 필드는 변하지 않습니다. 변경 가능한 필드와 변경 불가능한 필드는 모두 명시 적으로 다형성 유형을 가질 수 있습니다. 내용의 다형성은 레코드 값이 생성되거나 수정 될 때마다 정적으로 확인됩니다. 추출 된 값은 유형이 인스턴스화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cc55907fc102b663d0673eb99112e552f4a435a" translate="yes" xml:space="preserve">
          <source>The type representing wallclock time and calendar date.</source>
          <target state="translated">wallclock 시간과 달력 날짜를 나타내는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="719afb56f810f882e663e05949b4c0135dc8e565" translate="yes" xml:space="preserve">
          <source>The type variables appearing as type parameters can optionally be prefixed by + or - to indicate that the type constructor is covariant or contravariant with respect to this parameter. This variance information is used to decide subtyping relations when checking the validity of :&amp;gt; coercions (see section &lt;a href=&quot;expr#ss%3Aexpr-coercions&quot;&gt;7.7.7&lt;/a&gt;).</source>
          <target state="translated">유형 매개 변수로 나타나는 유형 변수는 유형 생성자가이 매개 변수와 관련하여 공변 또는 반 변성을 나타 내기 위해 선택적으로 + 또는-접두사를 붙일 수 있습니다. 이 분산 정보는 :&amp;gt; 강제의 유효성을 확인할 때 하위 유형 관계를 결정하는 데 사용됩니다 (섹션 &lt;a href=&quot;expr#ss%3Aexpr-coercions&quot;&gt;7.7.7&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="da4bb1f94026133ed9e6ee3397f9022a4a5493c7" translate="yes" xml:space="preserve">
          <source>The types and their meanings are:</source>
          <target state="translated">유형과 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cf539767254769cb84eb0b1abbb2be61f0f57486" translate="yes" xml:space="preserve">
          <source>The typical usage is:</source>
          <target state="translated">일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e2cdbd104780129e6eb6af11e6842e3411789d0" translate="yes" xml:space="preserve">
          <source>The typical use of private types is in the export signature of a module, to ensure that construction of values of the private type always go through the functions provided by the module, while still allowing pattern-matching outside the defining module. For example:</source>
          <target state="translated">private 유형의 일반적인 사용은 모듈의 내보내기 서명에서 사용되며, private 유형의 값 구성은 항상 모듈에서 제공하는 함수를 통과하면서 정의 모듈 외부에서 패턴 일치를 허용합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="76fc86bc826ecd117df214c518ef9dca7c54b653" translate="yes" xml:space="preserve">
          <source>The typing of immediate objects is slightly different from explicitly defining a class in two respects. First, the inferred object type may contain free type variables. Second, since the class body of an immediate object will never be extended, its self type can be unified with a closed object type.</source>
          <target state="translated">즉각적인 객체의 유형은 두 가지 측면에서 클래스를 명시 적으로 정의하는 것과 약간 다릅니다. 첫째, 유추 된 객체 유형은 자유 유형 변수를 포함 할 수 있습니다. 둘째, 직접 객체의 클래스 본문은 확장되지 않으므로 자체 유형은 닫힌 객체 유형으로 통합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="379766838ae430347d582312c2b9bd97e93485b9" translate="yes" xml:space="preserve">
          <source>The typing of pattern matching in presence of GADT can generate many existential types. When necessary, error messages refer to these existential types using compiler-generated names. Currently, the compiler generates these names according to the following nomenclature:</source>
          <target state="translated">GADT가있는 상태에서 패턴 일치를 입력하면 많은 실존 유형이 생성 될 수 있습니다. 필요한 경우 오류 메시지는 컴파일러 생성 이름을 사용하여 이러한 존재 유형을 참조합니다. 현재 컴파일러는 다음 명명법에 따라 이러한 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b139709c938696abfe6558bd71c73b15692ae467" translate="yes" xml:space="preserve">
          <source>The unit type</source>
          <target state="translated">단위 유형</target>
        </trans-unit>
        <trans-unit id="f157a3529b6639761d0fe3370101d0cd58a51217" translate="yes" xml:space="preserve">
          <source>The unit type.</source>
          <target state="translated">단위 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6b7a079da5bd24c487f37916205b8998acfd3262" translate="yes" xml:space="preserve">
          <source>The unix library makes many Unix system calls and system-related library functions available to OCaml programs. This chapter describes briefly the functions provided. Refer to sections 2 and 3 of the Unix manual for more details on the behavior of these functions.</source>
          <target state="translated">유닉스 라이브러리는 OCaml 프로그램에서 많은 유닉스 시스템 호출과 시스템 관련 라이브러리 함수를 사용할 수 있도록합니다. 이 장에서는 제공되는 기능에 대해 간략하게 설명합니다. 이러한 기능의 동작에 대한 자세한 내용은 Unix 매뉴얼의 섹션 2와 3을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="61f8335838db8a8ae9ab9030edc50991b021708a" translate="yes" xml:space="preserve">
          <source>The unrolling depth applies to calls within the same mutually-recursive group of functions. Each time an inlining of such a call is performed the depth is incremented by one when examining the resulting body. If the depth reaches the limit set by -inline-max-unroll then speculation stops.</source>
          <target state="translated">언 롤링 깊이는 동일한 상호 재귀 함수 그룹 내의 호출에 적용됩니다. 이러한 호출의 인라인이 수행 될 때마다 결과 바디를 검사 할 때 깊이가 1 씩 증가합니다. 깊이가 -inline-max-unroll에 의해 설정된 한계에 도달하면 추측이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="ef46466283aedcffa1e3418737dde034112c7cb9" translate="yes" xml:space="preserve">
          <source>The unused specialised argument f may now be removed, leaving:</source>
          <target state="translated">사용되지 않는 특수 인수 f는 이제 제거되어 다음과 같이 남습니다.</target>
        </trans-unit>
        <trans-unit id="f25fc5451b4b7e9e596e2f95c2648b7f2f987a8b" translate="yes" xml:space="preserve">
          <source>The usage for ocamlrun is:</source>
          <target state="translated">ocamlrun의 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fdf174ec233170184c634afe9d8c6e98683f2f9c" translate="yes" xml:space="preserve">
          <source>The user must make sure that the parameter &lt;code&gt;s&lt;/code&gt; is the same string that was passed to the matching or searching function.</source>
          <target state="translated">사용자는 매개 변수 &lt;code&gt;s&lt;/code&gt; 가 일치 또는 검색 기능에 전달 된 동일한 문자열 인지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9cc30db23fbb2629fd5d6a40fb9f9a4aa615d10c" translate="yes" xml:space="preserve">
          <source>The user starts manually the program, when asked by the debugger. Allows remote debugging (see section &lt;a href=&quot;#ss%3Adebugger-communication&quot;&gt;17.8.8&lt;/a&gt;).</source>
          <target state="translated">디버거에서 요청하면 사용자가 프로그램을 수동으로 시작합니다. 원격 디버깅을 허용합니다 (섹션 &lt;a href=&quot;#ss%3Adebugger-communication&quot;&gt;17.8.8&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="642aefa1c3276d4815d6372b5c2ba0e28849644d" translate="yes" xml:space="preserve">
          <source>The value of lazy_two is displayed as &amp;lt;lazy&amp;gt;, which means the expression has not been evaluated yet, and its final value is unknown.</source>
          <target state="translated">lazy_two의 값은 &amp;lt;lazy&amp;gt;로 표시됩니다. 이는 표현식이 아직 평가되지 않았으며 최종 값을 알 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e44eeca632e1ee708a87c7d08ac7f919078da583" translate="yes" xml:space="preserve">
          <source>The value path printer-name must refer to one of the functions defined by the object files loaded using load_printer. It cannot reference the functions of the program being debugged.</source>
          <target state="translated">값 경로 printer-name은 load_printer를 사용하여로드 된 오브젝트 파일에 정의 된 함수 중 하나를 참조해야합니다. 디버깅중인 프로그램의 기능을 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="213346982c2b5edd8a2868f6648a75de11f3a7a1" translate="yes" xml:space="preserve">
          <source>The value restriction combined with this generalization for covariant type parameters is called the relaxed value restriction.</source>
          <target state="translated">공변 유형 매개 변수에 대한이 일반화와 결합 된 값 제한을 완화 된 값 제한이라고합니다.</target>
        </trans-unit>
        <trans-unit id="3e457e086f638356c025d7f98eea16073334d087" translate="yes" xml:space="preserve">
          <source>The variance indicated by the + and - annotations on parameters is enforced only for abstract and private types, or when there are type constraints. Otherwise, for abbreviations, variant and record types without type constraints, the variance properties of the type constructor are inferred from its definition, and the variance annotations are only checked for conformance with the definition.</source>
          <target state="translated">매개 변수의 + 및-주석으로 표시되는 분산은 추상 및 개인 유형에 대해서만 적용되거나 유형 제약이있는 경우에만 적용됩니다. 그렇지 않으면 유형 제약이없는 약어, 변형 및 레코드 유형의 경우 유형 생성자의 분산 속성이 정의에서 유추되고 분산 주석은 정의와의 일치 여부 만 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a2c84e520b4d58847b9a0936e0ff6718cecdfce8" translate="yes" xml:space="preserve">
          <source>The variant &lt;code&gt;caml_process_pending_actions_exn&lt;/code&gt; is provided, that returns the exception instead of raising it directly into OCaml code. Its result must be tested using Is_exception_result, and followed by Extract_exception if appropriate. It is typically used for clean up before re-raising:</source>
          <target state="translated">예외를 OCaml 코드로 직접 발생시키는 대신 반환하는 변형 &lt;code&gt;caml_process_pending_actions_exn&lt;/code&gt; 이 제공됩니다. 결과는 Is_exception_result를 사용하여 테스트해야하며 적절한 경우 Extract_exception이 뒤 따릅니다. 일반적으로 다시 올리기 전에 정리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4d3e8b9825c91e7d1c1de2e5964ef9a6faa3a9d6" translate="yes" xml:space="preserve">
          <source>The variant value `VConstr is represented by hash_variant(&quot;VConstr&quot;). The variant value `VConstr(v) is represented by a block of size 2 and tag 0, with field number 0 containing hash_variant(&quot;VConstr&quot;) and field number 1 containing v.</source>
          <target state="translated">변형 값`VConstr은 hash_variant ( &quot;VConstr&quot;)로 표시됩니다. 변형 값`VConstr (v)는 크기 2와 태그 0의 블록으로 표시되며 필드 번호 0에는 hash_variant ( &quot;VConstr&quot;)가 포함되고 필드 번호 1에는 v가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fe7a7371cf1264e74123560fc9eaab0ccf8deadd" translate="yes" xml:space="preserve">
          <source>The version number for the element.</source>
          <target state="translated">요소의 버전 번호입니다.</target>
        </trans-unit>
        <trans-unit id="a12195f2bfc0b341eebc2706c0f898b85f60cd39" translate="yes" xml:space="preserve">
          <source>The warning-list argument is a sequence of warning specifiers, with no separators between them. A warning specifier is one of the following:</source>
          <target state="translated">warning-list 인수는 경고 지정자 시퀀스이며 그 사이에 구분 기호가 없습니다. 경고 지정자는 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="3155774bd8f5952cba7da2b05dd2d603a1c4e3ad" translate="yes" xml:space="preserve">
          <source>The with part does pattern matching on the exception value with the same syntax and behavior as match. Thus, several exceptions can be caught by one try&amp;hellip;with construct:</source>
          <target state="translated">with 부분은 일치와 동일한 구문 및 동작으로 예외 값에 대해 패턴 일치를 수행합니다. 따라서 한 번의 시도로 여러 예외를 포착 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bee62c92457d9c1edd0b95b70b38529cd1e173d" translate="yes" xml:space="preserve">
          <source>The workaround is easy: you should put a type constraint on the parameter.</source>
          <target state="translated">해결 방법은 간단합니다. 매개 변수에 유형 제약 조건을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e5abc2079ccb81595a85c637140e96ed3e00651" translate="yes" xml:space="preserve">
          <source>Then, the following command uses custom.cma as custom generator:</source>
          <target state="translated">그런 다음 다음 명령은 custom.cma를 사용자 지정 생성기로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7da202378d7326ed462fca4e0c21921b3c299f46" translate="yes" xml:space="preserve">
          <source>There are no type expressions describing (defined) variant types nor record types, since those are always named, i.e. defined before use and referred to by name. Type definitions are described in section &lt;a href=&quot;typedecl#ss%3Atypedefs&quot;&gt;7.8.1&lt;/a&gt;.</source>
          <target state="translated">(정의 된) 변형 유형이나 레코드 유형을 설명하는 유형 표현식은 없습니다. 그 이유는 항상 이름이 지정되기 때문입니다. 즉, 사용 전에 정의되고 이름으로 참조되기 때문입니다. 유형 정의는 섹션 &lt;a href=&quot;typedecl#ss%3Atypedefs&quot;&gt;7.8.1에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ed327f049e48284a0a623ce9851b6b43632572d" translate="yes" xml:space="preserve">
          <source>There are several restrictions on &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; 에는 몇 가지 제한 사항이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b5816a972e7e95d82645db243fd7e0a0acf5b5d4" translate="yes" xml:space="preserve">
          <source>There are six CAMLparam macros: CAMLparam0 to CAMLparam5, which take zero to five arguments respectively. If your function has no more than 5 parameters of type value, use the corresponding macros with these parameters as arguments. If your function has more than 5 parameters of type value, use CAMLparam5 with five of these parameters, and use one or more calls to the CAMLxparam macros for the remaining parameters (CAMLxparam1 to CAMLxparam5).</source>
          <target state="translated">6 개의 CAMLparam 매크로가 있습니다. CAMLparam0에서 CAMLparam5까지, 각각 0-5 개의 인수를 사용합니다. 함수에 값 유형의 매개 변수가 5 개 이하인 경우 이러한 매개 변수와 함께 해당 매크로를 인수로 사용합니다. 함수에 값 유형의 매개 변수가 5 개 이상있는 경우 이러한 매개 변수 중 5 개와 함께 CAMLparam5를 사용하고 나머지 매개 변수 (CAMLxparam1에서 CAMLxparam5)에 대해 CAMLxparam 매크로에 대한 호출을 하나 이상 사용합니다.</target>
        </trans-unit>
        <trans-unit id="66a70237d0ffb18913597dc8bc48a2788fdf2980" translate="yes" xml:space="preserve">
          <source>There are two drawbacks to dynamic linking. The first is that the resulting executable is not stand-alone: it requires the shared libraries, as well as ocamlrun, to be installed on the machine executing the code. If you wish to distribute a stand-alone executable, it is better to link it statically, using ocamlc -custom -ccopt -static or ocamlopt -ccopt -static. Dynamic linking also raises the &amp;ldquo;DLL hell&amp;rdquo; problem: some care must be taken to ensure that the right versions of the shared libraries are found at start-up time.</source>
          <target state="translated">동적 연결에는 두 가지 단점이 있습니다. 첫 번째는 결과 실행 파일이 독립형이 아니라는 것입니다. 코드를 실행하는 시스템에 공유 라이브러리와 ocamlrun을 설치해야합니다. 독립 실행 형 실행 파일을 배포하려면 ocamlc -custom -ccopt -static 또는 ocamlopt -ccopt -static을 사용하여 정적으로 링크하는 것이 좋습니다. 동적 연결은 또한 &quot;DLL 지옥&quot;문제를 일으 킵니다. 시작시 올바른 버전의 공유 라이브러리를 찾을 수 있도록주의를 기울여야합니다.</target>
        </trans-unit>
        <trans-unit id="b66d252bf6e5adb16a8a81b0a31bcc98e8083e8f" translate="yes" xml:space="preserve">
          <source>There are two exceptions: for constructors and record fields in type definitions, the associated comment can only be placed after the constructor or field definition, without blank lines or other comments between them. The special comment for a constructor with another constructor following must be placed before the &amp;rsquo;|&amp;rsquo; character separating the two constructors.</source>
          <target state="translated">두 가지 예외가 있습니다. 유형 정의의 생성자 및 레코드 필드의 경우 관련 주석은 생성자 또는 필드 정의 뒤에 만 배치 할 수 있으며 그 사이에 빈 줄이나 다른 주석이 없습니다. 다음의 다른 생성자가있는 생성자에 대한 특수 주석은 '|'앞에 배치되어야합니다. 두 생성자를 구분하는 문자.</target>
        </trans-unit>
        <trans-unit id="3eea4041f7bae7ed250a35d69c8993bc99a56a95" translate="yes" xml:space="preserve">
          <source>There are two valid use-cases that respect this ownership discipline:</source>
          <target state="translated">이 소유권 규율을 존중하는 두 가지 유효한 사용 사례가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f4c01af210fd3e27d304b7f41d713af6236e4a1" translate="yes" xml:space="preserve">
          <source>There are two ways to obtain OCaml function values (closures) to be passed to the callback functions described above. One way is to pass the OCaml function as an argument to a primitive function. For example, if the OCaml code contains the declaration</source>
          <target state="translated">위에서 설명한 콜백 함수에 전달할 OCaml 함수 값 (클로저)을 얻는 방법에는 두 가지가 있습니다. 한 가지 방법은 OCaml 함수를 기본 함수에 대한 인수로 전달하는 것입니다. 예를 들어 OCaml 코드에 다음 선언이 포함되어있는 경우</target>
        </trans-unit>
        <trans-unit id="f796d8197ff409294fcb0b2b9480a2ce5fecdc08" translate="yes" xml:space="preserve">
          <source>There is a printf function in the &lt;a href=&quot;libref/printf&quot;&gt;Printf&lt;/a&gt; module (see chapter &lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt;) that allows you to make formatted output more concisely. It follows the behavior of the printf function from the C standard library. The printf function takes a format string that describes the desired output as a text interspered with specifiers (for instance %d, %f). Next, the specifiers are substituted by the following arguments in their order of apparition in the format string:</source>
          <target state="translated">&lt;a href=&quot;libref/printf&quot;&gt;Printf&lt;/a&gt; 모듈 ( &lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt; 장 참조 )에는 형식화 된 출력을보다 간결하게 만들 수 있는 printf 함수 가 있습니다. C 표준 라이브러리의 printf 함수 동작을 따릅니다. printf 함수는 원하는 출력을 지정자가있는 텍스트 (예 : % d, % f)로 설명하는 형식 문자열을 사용합니다. 다음으로, 지정자는 형식 문자열의 출현 순서에 따라 다음 인수로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="0926f9a5aad069ce9f290befa2171e8e69385aeb" translate="yes" xml:space="preserve">
          <source>There is a single classification for coeffects:</source>
          <target state="translated">부작용에 대한 단일 분류가 있습니다.</target>
        </trans-unit>
        <trans-unit id="86860c4a3904e32a0066d40f9221fe10cbd4529f" translate="yes" xml:space="preserve">
          <source>There is a single input (the string &amp;ldquo;secret code&amp;rdquo;) which causes this program to crash, but finding it by blind random search is infeasible.</source>
          <target state="translated">이 프로그램을 충돌시키는 단일 입력 ( &quot;비밀 코드&quot;문자열)이 있지만 블라인드 임의 검색으로 찾기는 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="f530a5d8b189e6bec332a6ff74e1e85c4100c796" translate="yes" xml:space="preserve">
          <source>There is an additional lexical rule to escape the special characters &lt;code&gt;'%'&lt;/code&gt; and &lt;code&gt;'@'&lt;/code&gt; in format strings: if a special character follows a &lt;code&gt;'%'&lt;/code&gt; character, it is treated as a plain character. In other words, &lt;code&gt;&quot;%%&quot;&lt;/code&gt; is considered as a plain &lt;code&gt;'%'&lt;/code&gt; and &lt;code&gt;&quot;%@&quot;&lt;/code&gt; as a plain &lt;code&gt;'@'&lt;/code&gt;.</source>
          <target state="translated">특수 문자 탈출하기 위해 추가 어휘 규칙이 &lt;code&gt;'%'&lt;/code&gt; 와 &lt;code&gt;'@'&lt;/code&gt; 형식 문자열로는 : 특수 문자는 다음 경우에 &lt;code&gt;'%'&lt;/code&gt; 문자를, 그것은 일반 문자로 처리됩니다. 즉, &lt;code&gt;&quot;%%&quot;&lt;/code&gt; 는 일반 &lt;code&gt;'%'&lt;/code&gt; 로 , &lt;code&gt;&quot;%@&quot;&lt;/code&gt; 는 일반 &lt;code&gt;'@'&lt;/code&gt; 로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="89300e6e8eb5caa8716a6d136ca3ce59e33af664" translate="yes" xml:space="preserve">
          <source>There is another partial solution to the problem of unnecessary weak type, which is implemented directly within the type checker. Briefly, it is possible to prove that weak types that only appear as type parameters in covariant positions &amp;ndash;also called positive positions&amp;ndash; can be safely generalized to polymorphic types. For instance, the type 'a list is covariant in 'a:</source>
          <target state="translated">유형 검사기 내에서 직접 구현되는 불필요한 약한 유형 문제에 대한 또 다른 부분적인 해결책이 있습니다. 간단히 말해서, 공변 위치 (양수 위치라고도 함)에서 유형 매개 변수로만 나타나는 약한 유형이 다형 유형으로 안전하게 일반화 될 수 있음을 증명할 수 있습니다. 예를 들어 'a 목록은'a :</target>
        </trans-unit>
        <trans-unit id="4839904c7c8092d09c24e4a4ca03c2ca6d8ace01" translate="yes" xml:space="preserve">
          <source>There is another, more direct way to create an object: create it without going through a class.</source>
          <target state="translated">객체를 생성하는보다 직접적인 방법이 있습니다. 클래스를 거치지 않고 객체를 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6713ccaa14a77e18cc0d165c630249a7f39edf84" translate="yes" xml:space="preserve">
          <source>There is no blank line or another special comment between the special comment and the element. However, a regular comment can occur between the special comment and the element.</source>
          <target state="translated">특수 주석과 요소 사이에 빈 줄이나 다른 특수 주석이 없습니다. 그러나 특수 주석과 요소 사이에 일반 주석이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="420c7eecf9b88f0fd685ede8cd7d5594dccc6b10" translate="yes" xml:space="preserve">
          <source>There is no linearity restriction over as bound variables. When a variable is bound more than once, the previous rules are to be extended as follows:</source>
          <target state="translated">바운드 변수에 대한 선형성 제한은 없습니다. 변수가 두 번 이상 바인딩되면 이전 규칙이 다음과 같이 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="e2df4086644aefdc6d4fa1daff752de72504dccd" translate="yes" xml:space="preserve">
          <source>There is nothing particular about functors that inhibits inlining compared to normal functions. To the inliner, these both look the same, except that functors are marked as such.</source>
          <target state="translated">정상적인 기능에 비해 인라이닝을 억제하는 펑터에는 특별한 것이 없습니다. 인라이너에게는 펑터가 그렇게 표시되어 있다는 점을 제외하면 둘 다 동일하게 보입니다.</target>
        </trans-unit>
        <trans-unit id="6f7526b0137b40ba5befc330c948531d764b9b23" translate="yes" xml:space="preserve">
          <source>There is sometimes an alternative between using modules or classes for parametric data types. Indeed, there are situations when the two approaches are quite similar. For instance, a stack can be straightforwardly implemented as a class:</source>
          <target state="translated">때때로 파라 메트릭 데이터 유형에 대해 모듈 또는 클래스를 사용하는 것 사이에 대안이 있습니다. 실제로 두 가지 접근 방식이 매우 유사한 상황이 있습니다. 예를 들어 스택은 클래스로 간단하게 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f6f12e3992f209be063993c601fdba9acbc537c" translate="yes" xml:space="preserve">
          <source>Therefore, after placing an int in store, we cannot use it to store any value other than an int. More generally, weak types protect the program from undue mutation of values with a polymorphic type.</source>
          <target state="translated">따라서 int를 저장 한 후에는 int 이외의 값을 저장하는 데 사용할 수 없습니다. 보다 일반적으로 약한 유형은 다형성 유형을 사용하는 값의 과도한 변형으로부터 프로그램을 보호합니다.</target>
        </trans-unit>
        <trans-unit id="e9c813ad0d9ef31d493524a8ea85262d92050cce" translate="yes" xml:space="preserve">
          <source>These .cmt and .cmti files are typically useful for code inspection tools.</source>
          <target state="translated">이러한 .cmt 및 .cmti 파일은 일반적으로 코드 검사 도구에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="69311f08c70520540fee4cbe4bda7e98116c0238" translate="yes" xml:space="preserve">
          <source>These annotations explicitly require the defined value to be polymorphic, and allow one to use this polymorphism in recursive occurrences (when using letrec). Note however that this is a normal polymorphic type, unifiable with any instance of itself.</source>
          <target state="translated">이러한 주석은 정의 된 값이 다형성이되도록 명시 적으로 요구하며 재귀 발생 (letrec 사용시)에서이 다형성을 사용할 수 있도록합니다. 그러나 이것은 자신의 어떤 인스턴스와도 통합 할 수없는 일반적인 다형성 유형입니다.</target>
        </trans-unit>
        <trans-unit id="43e7d9c598d98633999ba13a3dcc444ba12214ad" translate="yes" xml:space="preserve">
          <source>These eleven name spaces are distinguished both by the context and by the capitalization of the identifier: whether the first letter of the identifier is in lowercase (written &lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt; below) or in uppercase (written &lt;a href=&quot;lex#capitalized-ident&quot;&gt;capitalized-ident&lt;/a&gt;). Underscore is considered a lowercase letter for this purpose.</source>
          <target state="translated">식별자의 첫 문자 (기록 소문자 여부 이러한 열한 이름 공간은 컨텍스트에 의해 상기 식별자의 대소에 의해 모두 구별되는 &lt;a href=&quot;lex#lowercase-ident&quot;&gt;소문자의 식별자&lt;/a&gt; 아래)에 또는 대문자 (기록 &lt;a href=&quot;lex#capitalized-ident&quot;&gt;대문자-식별자를&lt;/a&gt; ). 이를 위해 밑줄은 소문자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="870297f2b83ed8726b893d830c917d6f224b681b" translate="yes" xml:space="preserve">
          <source>These files reside in the caml/ subdirectory of the OCaml standard library directory, which is returned by the command ocamlc -where (usually /usr/local/lib/ocaml or /usr/lib/ocaml).</source>
          <target state="translated">이러한 파일은 OCaml 표준 라이브러리 디렉토리의 caml / 하위 디렉토리에 있으며, 이는 ocamlc -where (일반적으로 / usr / local / lib / ocaml 또는 / usr / lib / ocaml) 명령에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3be7b63190a743842c43dfb1591048d46124470c" translate="yes" xml:space="preserve">
          <source>These functions are the same as the basic functions, except that they use (and update) the given PRNG state instead of the default one.</source>
          <target state="translated">이러한 함수는 기본 함수 대신 지정된 PRNG 상태를 사용 (및 업데이트)한다는 점을 제외하면 기본 함수와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="239ea6a3f14d9dc171a9d56f5158d10f257a786d" translate="yes" xml:space="preserve">
          <source>These functions are used to traverse the slots of a raw backtrace and extract information from them in a programmer-friendly format.</source>
          <target state="translated">이러한 함수는 원시 역 추적 슬롯을 탐색하고 프로그래머에게 친숙한 형식으로 정보를 추출하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7cf57b7b10c266fa7ea278e39e177192d8ca0786" translate="yes" xml:space="preserve">
          <source>These functions poll for pending signals by calling asynchronous callbacks (section &lt;a href=&quot;#ss%3Ac-process-pending-actions&quot;&gt;20.5.3&lt;/a&gt;) before releasing and after acquiring the lock. They can therefore execute arbitrary OCaml code including raising an asynchronous exception.</source>
          <target state="translated">이러한 함수 는 잠금을 해제하기 전과 획득 한 후에 비동기 콜백 (섹션 &lt;a href=&quot;#ss%3Ac-process-pending-actions&quot;&gt;20.5.3&lt;/a&gt; ) 을 호출하여 보류중인 신호를 폴링합니다 . 따라서 비동기 예외 발생을 포함하여 임의의 OCaml 코드를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be1ff51841b268ac0bc83ac53b16b105790d419d" translate="yes" xml:space="preserve">
          <source>These functions return immediately &lt;code&gt;true&lt;/code&gt; in the Win32 implementation.</source>
          <target state="translated">이러한 함수 는 Win32 구현에서 즉시 &lt;code&gt;true&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7ce3216765c88e5c48af00b3c110ef4d63384284" translate="yes" xml:space="preserve">
          <source>These goals are often reached not just by inlining itself but also by other optimisations that the compiler is able to perform as a result of inlining.</source>
          <target state="translated">이러한 목표는 종종 자체 인라인뿐만 아니라 컴파일러가 인라인의 결과로 수행 할 수있는 다른 최적화를 통해서도 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="4386b22d00bf9e30129abfc3148f83106ab4fda2" translate="yes" xml:space="preserve">
          <source>These options are passed as is to ocamlc or ocamlopt. See the documentation of these commands.</source>
          <target state="translated">이러한 옵션은있는 그대로 ocamlc 또는 ocamlopt에 전달됩니다. 이 명령에 대한 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="484df2de1a8035aff891a6ad2ca2a206e2085ae8" translate="yes" xml:space="preserve">
          <source>These options are passed as is to the C compiler. Refer to the documentation of the C compiler.</source>
          <target state="translated">이러한 옵션은있는 그대로 C 컴파일러에 전달됩니다. C 컴파일러의 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4eeaa8b4b44d8ce0bdc7032fda14b43069cb254a" translate="yes" xml:space="preserve">
          <source>These options are useful when you have, for example, a type and a value with the same name. If you do not specify prefixes, L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X will complain about multiply defined labels.</source>
          <target state="translated">이러한 옵션은 예를 들어 동일한 이름을 가진 유형 및 값이있는 경우에 유용합니다. 접두사를 지정하지 않으면 L &lt;sup&gt;A&lt;/sup&gt; T &lt;sub&gt;E&lt;/sub&gt; X는 다중 정의 된 레이블에 대해 불만을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="bd109aa38e89265e3d535e5b8837cacc7cebe8b5" translate="yes" xml:space="preserve">
          <source>These parameters are ultimately bounded by the arguments provided to the corresponding command-line flags (or their default values):</source>
          <target state="translated">이러한 매개 변수는 궁극적으로 해당 명령 줄 플래그 (또는 기본값)에 제공된 인수로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="201eef9e30770a6e41dd8bf1c6f8c6e7106ea2b8" translate="yes" xml:space="preserve">
          <source>These program generators are very close to the well-known lex and yacc commands that can be found in most C programming environments. This chapter assumes a working knowledge of lex and yacc: while it describes the input syntax for ocamllex and ocamlyacc and the main differences with lex and yacc, it does not explain the basics of writing a lexer or parser description in lex and yacc. Readers unfamiliar with lex and yacc are referred to &amp;ldquo;Compilers: principles, techniques, and tools&amp;rdquo; by Aho, Sethi and Ullman (Addison-Wesley, 1986), or &amp;ldquo;Lex &amp;amp; Yacc&amp;rdquo;, by Levine, Mason and Brown (O&amp;rsquo;Reilly, 1992).</source>
          <target state="translated">이러한 프로그램 생성기는 대부분의 C 프로그래밍 환경에서 찾을 수있는 잘 알려진 lex 및 yacc 명령에 매우 가깝습니다. 이 장에서는 lex 및 yacc에 대한 실무 지식이 있다고 가정합니다. ocamllex 및 ocamlyacc의 입력 구문과 lex 및 yacc의 주요 차이점을 설명하지만 lex 및 yacc에서 렉서 또는 파서 설명을 작성하는 기본 사항은 설명하지 않습니다. lex 및 yacc에 익숙하지 않은 독자는 Aho, Sethi 및 Ullman (Addison-Wesley, 1986)의 &quot;컴파일러 : 원칙, 기술 및 도구&quot;또는 Levine, Mason 및 Brown (O'Reilly , 1992).</target>
        </trans-unit>
        <trans-unit id="a01d3add6122970dc3dbf24500aab00b1c8c4545" translate="yes" xml:space="preserve">
          <source>These text messages are usually not stable over time: call sites building these constructors may refine the message in a future version to make it more explicit, etc. Therefore, it is dangerous to match over the precise value of the message. For example, until OCaml 4.02, Array.iter2 would raise the exception</source>
          <target state="translated">이러한 텍스트 메시지는 일반적으로 시간이 지남에 따라 안정적이지 않습니다. 이러한 생성자를 구축하는 호출 사이트는 메시지를보다 명확하게 만들기 위해 향후 버전에서 메시지를 구체화 할 수 있습니다. 따라서 메시지의 정확한 값과 일치하는 것은 위험합니다. 예를 들어 OCaml 4.02까지 Array.iter2는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="056363d88c08f1781faea018bb808d8587eb9a45" translate="yes" xml:space="preserve">
          <source>These two files together define a structure named A as if the following definition was entered at top-level:</source>
          <target state="translated">이 두 파일은 다음 정의가 최상위 레벨에 입력 된 것처럼 A라는 구조를 함께 정의합니다.</target>
        </trans-unit>
        <trans-unit id="2c3373b0a618202574e74bfc05210cbd553b7e77" translate="yes" xml:space="preserve">
          <source>These weakened dependencies make possible to use module aliases in place of the -pack mechanism. Suppose that you have a library Mylib composed of modules A and B. Using -pack, one would issue the command line</source>
          <target state="translated">이러한 약화 된 종속성으로 인해 -pack 메커니즘 대신 모듈 별칭을 사용할 수 있습니다. 모듈 A와 B로 구성된 Mylib 라이브러리가 있다고 가정합니다. -pack을 사용하면 명령 줄을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5e847d2a87ac8165d8955c02fcafa07afd4fca2" translate="yes" xml:space="preserve">
          <source>They only differ by their labels. Detailed interfaces can be found in &lt;code&gt;arrayLabels.mli&lt;/code&gt;, &lt;code&gt;bytesLabels.mli&lt;/code&gt;, &lt;code&gt;listLabels.mli&lt;/code&gt; and &lt;code&gt;stringLabels.mli&lt;/code&gt;.</source>
          <target state="translated">레이블 만 다릅니다. 자세한 인터페이스는 &lt;code&gt;arrayLabels.mli&lt;/code&gt; , &lt;code&gt;bytesLabels.mli&lt;/code&gt; , &lt;code&gt;listLabels.mli&lt;/code&gt; 및 &lt;code&gt;stringLabels.mli&lt;/code&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b235c592e19c9ae8ea4fa2dac4a8048ec27fa43" translate="yes" xml:space="preserve">
          <source>They only differ by their labels. They are provided to help porting from previous versions of OCaml. The contents of this module are subject to change.</source>
          <target state="translated">레이블 만 다릅니다. 이전 버전의 OCaml에서 이식하는 데 도움이되도록 제공됩니다. 이 모듈의 내용은 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e865936f70f95a35530da646f08d349c8618ab8" translate="yes" xml:space="preserve">
          <source>This ability provides class constructors as can be found in other languages. Several constructors can be defined this way to build objects of the same class but with different initialization patterns; an alternative is to use initializers, as described below in section &lt;a href=&quot;#s%3Ainitializers&quot;&gt;3.4&lt;/a&gt;.</source>
          <target state="translated">이 기능은 다른 언어에서 찾을 수있는 클래스 생성자를 제공합니다. 이러한 방식으로 여러 생성자를 정의하여 동일한 클래스이지만 다른 초기화 패턴을 가진 객체를 빌드 할 수 있습니다. 대안은 아래 섹션 &lt;a href=&quot;#s%3Ainitializers&quot;&gt;3.4에&lt;/a&gt; 설명 된대로 이니셜 라이저를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="4e4da690687d8f30331d0881e81b870c14418b6d" translate="yes" xml:space="preserve">
          <source>This allows delaying the formatting of backtraces to when they are actually printed, which may be useful if you record more backtraces than you print.</source>
          <target state="translated">이렇게하면 역 추적 형식을 실제로 인쇄 할 때까지 지연시킬 수 있습니다. 이는 인쇄하는 것보다 더 많은 역 추적을 기록하는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cf2b05351c309723aa496873af8b5e1e89659d8" translate="yes" xml:space="preserve">
          <source>This allows the following idiom, keeping a list of all objects belonging to a class or its subclasses:</source>
          <target state="translated">이를 통해 클래스 또는 하위 클래스에 속하는 모든 객체 목록을 유지하면서 다음 관용구를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3f29de16e9f8798d1932dbc922db0d447425dac" translate="yes" xml:space="preserve">
          <source>This approach lets you access A and B directly inside the library, and as Mylib.A and Mylib.B from outside. It also has the advantage that Mylib is no longer monolithic: if you use Mylib.A, only Mylib__A will be linked in, not Mylib__B.</source>
          <target state="translated">이 접근 방식을 사용하면 라이브러리 내부에서 직접 A와 B에 액세스하고 외부에서 Mylib.A 및 Mylib.B로 액세스 할 수 있습니다. 또한 Mylib가 더 이상 모 놀리식이 아니라는 이점도 있습니다. Mylib.A를 사용하면 Mylib__B가 아닌 Mylib__A 만 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="1372a67563bf716e071b3b183d02ea2f598a4156" translate="yes" xml:space="preserve">
          <source>This attribute is attached to a function application and always takes an integer argument. Each time the inliner sees the attribute it behaves as follows:</source>
          <target state="translated">이 속성은 함수 애플리케이션에 연결되며 항상 정수 인수를 사용합니다. 인라이너가 속성을 볼 때마다 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="09b4b8d9fa337a2eb876a44b79cb348c9e5f0855" translate="yes" xml:space="preserve">
          <source>This box behaves as an horizontal box if it fits on a single line, otherwise it behaves as a vertical box.</source>
          <target state="translated">이 상자는 한 줄에 맞으면 가로 상자로 작동하고 그렇지 않으면 세로 상자로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b7625b4398585ec56f1ee579a0692c7819ab1dcb" translate="yes" xml:space="preserve">
          <source>This box features command &lt;code&gt;set_tab&lt;/code&gt; to define cell boundaries, and command &lt;code&gt;print_tab&lt;/code&gt; to move from cell to cell and split the line when there is no more cells to print on the line.</source>
          <target state="translated">이 상자에는 셀 경계를 정의하는 &lt;code&gt;set_tab&lt;/code&gt; 명령 과 줄에 인쇄 할 셀이 더 이상 없을 때 셀 &lt;code&gt;print_tab&lt;/code&gt; 이동하고 줄을 분할하는 print_tab 명령 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="00d886ace2f3bb025615806e435389e25f058b58" translate="yes" xml:space="preserve">
          <source>This box is the general purpose pretty-printing box.</source>
          <target state="translated">이 상자는 범용 예쁜 인쇄 상자입니다.</target>
        </trans-unit>
        <trans-unit id="4790a08c0b8ba22758a78bbaf58c7ad274884241" translate="yes" xml:space="preserve">
          <source>This box prints lines separated into cells of fixed width.</source>
          <target state="translated">이 상자는 고정 너비의 셀로 분리 된 선을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="9521c4e75869b633ff289e3509ef90a59f7e6d5f" translate="yes" xml:space="preserve">
          <source>This box prints material as much as possible on every line.</source>
          <target state="translated">이 상자는 모든 줄에 가능한 한 많은 자료를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="f4388d065629c7972988d67b92adade884cfc189" translate="yes" xml:space="preserve">
          <source>This box prints material on a single line.</source>
          <target state="translated">이 상자는 한 줄에 자료를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="0ed97b2eb7c12b24bf9da6774de6d18d44c03f8a" translate="yes" xml:space="preserve">
          <source>This box prints material on as many lines as break hints in the box.</source>
          <target state="translated">이 상자는 상자의 구분 힌트만큼 많은 줄에 재료를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="bac037b45f5205c0421d44bb0a7e2d59de5d5640" translate="yes" xml:space="preserve">
          <source>This builds a runtime system with the required primitives. The OCaml linker generates bytecode for this custom runtime system. The bytecode is appended to the end of the custom runtime system, so that it will be automatically executed when the output file (custom runtime + bytecode) is launched.</source>
          <target state="translated">이것은 필수 프리미티브로 런타임 시스템을 구축합니다. OCaml 링커는이 사용자 지정 런타임 시스템에 대한 바이트 코드를 생성합니다. 바이트 코드는 커스텀 런타임 시스템의 끝에 추가되므로 출력 파일 (커스텀 런타임 + 바이트 코드)이 시작될 때 자동으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b017452d5ed8ae35ceea59902e09d1ad45c8bde1" translate="yes" xml:space="preserve">
          <source>This can be used as a replacement for &lt;a href=&quot;format#VALasprintf&quot;&gt;&lt;code&gt;Format.asprintf&lt;/code&gt;&lt;/a&gt; to delay formatting decisions. Using the string returned by &lt;a href=&quot;format#VALasprintf&quot;&gt;&lt;code&gt;Format.asprintf&lt;/code&gt;&lt;/a&gt; in a formatting context forces formatting decisions to be taken in isolation, and the final string may be created prematurely. &lt;a href=&quot;format#VALdprintf&quot;&gt;&lt;code&gt;Format.dprintf&lt;/code&gt;&lt;/a&gt; allows delay of formatting decisions until the final formatting context is known. For example:</source>
          <target state="translated">이것은 &lt;a href=&quot;format#VALasprintf&quot;&gt; &lt;code&gt;Format.asprintf&lt;/code&gt; &lt;/a&gt; 의 대체물로 사용되어 형식화 결정을 지연 시킬 수 있습니다 . 서식 지정 컨텍스트에서 &lt;a href=&quot;format#VALasprintf&quot;&gt; &lt;code&gt;Format.asprintf&lt;/code&gt; &lt;/a&gt; 가 반환 한 문자열을 사용하면 서식 결정이 분리되어 강제로 수행되고 최종 문자열이 조기에 생성 될 수 있습니다. &lt;a href=&quot;format#VALdprintf&quot;&gt; &lt;code&gt;Format.dprintf&lt;/code&gt; 를&lt;/a&gt; 사용하면 최종 서식 컨텍스트가 알려질 때까지 서식 결정을 지연 할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="736b6a8d2382f934d9e36c672b75eae9562bc868" translate="yes" xml:space="preserve">
          <source>This case combines the previous two: the representation of the type is made visible to all users, and no fresh type is generated.</source>
          <target state="translated">이 경우는 이전 두 가지를 결합합니다. 유형의 표현이 모든 사용자에게 표시되고 새로운 유형이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b0b9d32c2c99f0a8a9065915f71e59738d0f44f" translate="yes" xml:space="preserve">
          <source>This chapter covers more advanced questions related to the limitations of polymorphic functions and types. There are some situations in OCaml where the type inferred by the type checker may be less generic than expected. Such non-genericity can stem either from interactions between side-effect and typing or the difficulties of implicit polymorphic recursion and higher-rank polymorphism.</source>
          <target state="translated">이 장에서는 다형성 함수 및 유형의 한계와 관련된 고급 질문을 다룹니다. OCaml에는 유형 검사기에 의해 유추 된 유형이 예상보다 덜 일반적 일 수있는 몇 가지 상황이 있습니다. 이러한 비 제네릭 성은 부작용과 타이핑 간의 상호 작용 또는 암시 적 다형성 재귀 및 상위 다형성의 어려움에서 비롯 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e99967e6f113e515abf96820acbd0c907f9ea256" translate="yes" xml:space="preserve">
          <source>This chapter describes OCamldoc, a tool that generates documentation from special comments embedded in source files. The comments used by OCamldoc are of the form (**&amp;hellip;*) and follow the format described in section &lt;a href=&quot;#s%3Aocamldoc-comments&quot;&gt;16.2&lt;/a&gt;.</source>
          <target state="translated">이 장에서는 소스 파일에 포함 된 특수 주석에서 문서를 생성하는 도구 인 OCamldoc에 대해 설명합니다. OCamldoc에서 사용하는 주석은 (**&amp;hellip; *) 형식이며 섹션 &lt;a href=&quot;#s%3Aocamldoc-comments&quot;&gt;16.2에&lt;/a&gt; 설명 된 형식을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="22979b22da128bdede671815a07fda413464a01f" translate="yes" xml:space="preserve">
          <source>This chapter describes how the execution of OCaml programs can be profiled, by recording how many times functions are called, branches of conditionals are taken, &amp;hellip;</source>
          <target state="translated">이 장에서는 함수가 호출 된 횟수, 조건 분기가 사용되는 횟수 등을 기록하여 OCaml 프로그램의 실행을 프로파일 링하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fc58c64bbca12c120e6be347ae738db5e914ab57" translate="yes" xml:space="preserve">
          <source>This chapter describes how user-defined primitives, written in C, can be linked with OCaml code and called from OCaml functions, and how these C functions can call back to OCaml code.</source>
          <target state="translated">이 장에서는 C로 작성된 사용자 정의 프리미티브를 OCaml 코드와 연결하고 OCaml 함수에서 호출하는 방법과 이러한 C 함수가 OCaml 코드를 다시 호출하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="084829076e627e4169c9229a38a24e09ad828c7b" translate="yes" xml:space="preserve">
          <source>This chapter describes language extensions and convenience features that are implemented in OCaml, but not described in the OCaml reference manual.</source>
          <target state="translated">이 장에서는 OCaml에서 구현 된 언어 확장 및 편의 기능에 대해 설명하지만 OCaml 참조 설명서에서는 설명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="995a07b1158b72f353eb1ac428ac4123f6853088" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml batch compiler ocamlc, which compiles OCaml source files to bytecode object files and links these object files to produce standalone bytecode executable files. These executable files are then run by the bytecode interpreter ocamlrun.</source>
          <target state="translated">이 장에서는 OCaml 소스 파일을 바이트 코드 개체 파일로 컴파일하고 이러한 개체 파일을 연결하여 독립 실행 형 바이트 코드 실행 파일을 생성하는 OCaml 배치 컴파일러 ocamlc에 대해 설명합니다. 이러한 실행 파일은 바이트 코드 인터프리터 ocamlrun에 의해 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="6b065bf42750f41d77bac34c5d6dddd1489b34a0" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml core library, which is composed of declarations for built-in types and exceptions, plus the module Stdlib that provides basic operations on these built-in types. The Stdlib module is special in two ways:</source>
          <target state="translated">이 장에서는 내장 유형 및 예외에 대한 선언과 이러한 내장 유형에 대한 기본 작업을 제공하는 모듈 Stdlib로 구성된 OCaml 코어 라이브러리에 대해 설명합니다. Stdlib 모듈은 두 가지면에서 특별합니다.</target>
        </trans-unit>
        <trans-unit id="36bc4b25a8de2e3c8b0cfa69654d56ac54e08f29" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml front-end, which declares the abstract syntax tree used by the compiler, provides a way to parse, print and pretty-print OCaml code, and ultimately allows one to write abstract syntax tree preprocessors invoked via the -ppx flag (see chapters &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; and &lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt;).</source>
          <target state="translated">이 장에서는 컴파일러가 사용하는 추상 구문 트리를 선언하고 OCaml 코드를 구문 분석, 인쇄 및 예쁘게 인쇄하는 방법을 제공하며 궁극적으로 -ppx 플래그를 통해 호출 된 추상 구문 트리 전처리기를 작성할 수있는 OCaml 프런트 엔드에 대해 설명합니다. ( &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; 장 과 &lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt; 장 참조 ).</target>
        </trans-unit>
        <trans-unit id="8c5ce841e2ff9db70cbc0f9643176a189658c748" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml high-performance native-code compiler ocamlopt, which compiles OCaml source files to native code object files and links these object files to produce standalone executables.</source>
          <target state="translated">이 장에서는 OCaml 소스 파일을 네이티브 코드 개체 파일로 컴파일하고 이러한 개체 파일을 연결하여 독립 실행 형 실행 파일을 생성하는 OCaml 고성능 네이티브 코드 컴파일러 ocamlopt에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="07729068091da08d36b2e49ba6d4e4d523bd49f5" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml instrumented runtime, a runtime variant allowing the collection of events and metrics.</source>
          <target state="translated">이 장에서는 이벤트 및 메트릭 수집을 허용하는 런타임 변형 인 OCaml 계측 런타임에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="69ddd94c98a17da2cbc644dd1e169145a2b86378" translate="yes" xml:space="preserve">
          <source>This chapter describes the OCaml source-level replay debugger ocamldebug.</source>
          <target state="translated">이 장에서는 OCaml 소스 수준 재생 디버거 ocamldebug에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1b3bef73d988061d29d6941712ad9747d92ad9a4" translate="yes" xml:space="preserve">
          <source>This chapter describes the functions provided by the OCaml standard library. The modules from the standard library are automatically linked with the user&amp;rsquo;s object code files by the ocamlc command. Hence, these modules can be used in standalone programs without having to add any .cmo file on the command line for the linking phase. Similarly, in interactive use, these globals can be used in toplevel phrases without having to load any .cmo file in memory.</source>
          <target state="translated">이 장에서는 OCaml 표준 라이브러리에서 제공하는 기능에 대해 설명합니다. 표준 라이브러리의 모듈은 ocamlc 명령에 의해 사용자의 개체 코드 파일과 자동으로 연결됩니다. 따라서 이러한 모듈은 연결 단계를 위해 명령 줄에 .cmo 파일을 추가하지 않고도 독립 실행 형 프로그램에서 사용할 수 있습니다. 마찬가지로 대화 형 사용에서 이러한 전역은 메모리에 .cmo 파일을로드하지 않고도 최상위 구문에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43ad0f253c7b2080f9dd53e8aa8d98648421148a" translate="yes" xml:space="preserve">
          <source>This chapter describes the toplevel system for OCaml, that permits interactive use of the OCaml system through a read-eval-print loop (REPL). In this mode, the system repeatedly reads OCaml phrases from the input, then typechecks, compile and evaluate them, then prints the inferred type and result value, if any. The system prints a # (sharp) prompt before reading each phrase.</source>
          <target state="translated">이 장에서는 REPL (read-eval-print loop)을 통해 OCaml 시스템의 대화식 사용을 허용하는 OCaml의 최상위 시스템에 대해 설명합니다. 이 모드에서 시스템은 입력에서 OCaml 구문을 반복적으로 읽고 유형 검사, 컴파일 및 평가 한 다음 유추 된 유형 및 결과 값 (있는 경우)을 인쇄합니다. 시스템은 각 구문을 읽기 전에 # (날카로운) 프롬프트를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="69c3d7e39acb1d5e622db5124a13613835b7634c" translate="yes" xml:space="preserve">
          <source>This chapter describes two program generators: ocamllex, that produces a lexical analyzer from a set of regular expressions with associated semantic actions, and ocamlyacc, that produces a parser from a grammar with associated semantic actions.</source>
          <target state="translated">이 장에서는 두 가지 프로그램 생성기에 대해 설명합니다. 관련된 의미 작업이있는 정규 표현식 집합에서 어휘 분석기를 생성하는 ocamllex와 관련된 의미 작업이있는 문법에서 구문 분석기를 생성하는 ocamlyacc입니다.</target>
        </trans-unit>
        <trans-unit id="210573b7ce8135e7e064f066b6ebcd12cb7b792a" translate="yes" xml:space="preserve">
          <source>This chapter details each of these situations and, if it is possible, how to recover genericity.</source>
          <target state="translated">이 장에서는 이러한 각 상황과 가능한 경우 일반성을 복구하는 방법에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="34e2681602b9187f866a2387ff78cec658492716" translate="yes" xml:space="preserve">
          <source>This chapter gives an overview of the new features in OCaml 3: labels, and polymorphic variants.</source>
          <target state="translated">이 장에서는 OCaml 3 : 레이블 및 다형성 변형의 새로운 기능에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3588c35304425734153b099a7cdbb31b7ab306d6" translate="yes" xml:space="preserve">
          <source>This chapter gives an overview of the object-oriented features of OCaml.</source>
          <target state="translated">이 장에서는 OCaml의 객체 지향 기능에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f743cd4aa8589a6f7ccb3236942f7a143fef8068" translate="yes" xml:space="preserve">
          <source>This chapter introduces the module system of OCaml.</source>
          <target state="translated">이 장에서는 OCaml의 모듈 시스템을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="641fe4386aeca969ab9cc8d868ad085c0c8ea3bb" translate="yes" xml:space="preserve">
          <source>This construction is useful because the type constructors it introduces can be used in places where a type variable is not allowed. For instance, one can use it to define an exception in a local module within a polymorphic function.</source>
          <target state="translated">이 생성은 그것이 도입하는 타입 생성자가 타입 변수가 허용되지 않는 곳에서 사용될 수 있기 때문에 유용합니다. 예를 들어 다형성 함수 내의 로컬 모듈에서 예외를 정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42d44fb398c8f2ad20178f128be9005c0c3a7520" translate="yes" xml:space="preserve">
          <source>This correspond to the commuting label mode of Objective Caml 3.00 through 3.02, with some additional flexibility on total applications. The so-called classic mode (-nolabels options) is now deprecated for normal use.</source>
          <target state="translated">이는 Objective Caml 3.00에서 3.02까지의 통근 라벨 모드에 해당하며 전체 애플리케이션에 대한 약간의 추가 유연성이 있습니다. 소위 클래식 모드 (-nolabels 옵션)는 이제 정상적인 사용을 위해 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0703f0be9e37d286e36c6f06a582f656747a10b9" translate="yes" xml:space="preserve">
          <source>This creates a new module &lt;code&gt;IntHashtbl&lt;/code&gt;, with a new type &lt;code&gt;'a&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;IntHashtbl.t&lt;/code&gt; of tables from &lt;code&gt;int&lt;/code&gt; to &lt;code&gt;'a&lt;/code&gt;. In this example, &lt;code&gt;h&lt;/code&gt; contains &lt;code&gt;string&lt;/code&gt; values so its type is &lt;code&gt;string&amp;nbsp;IntHashtbl.t&lt;/code&gt;.</source>
          <target state="translated">이렇게하면 새로운 유형의 &lt;code&gt;'a&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;IntHashtbl.t&lt;/code&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;intHashtbl.t 테이블의 &lt;code&gt;int&lt;/code&gt; 에서 &lt;code&gt;'a&lt;/code&gt; '로 새 모듈 &lt;code&gt;IntHashtbl&lt;/code&gt; 이 생성 됩니다. 이 예제에서 &lt;code&gt;h&lt;/code&gt; 는 &lt;code&gt;string&lt;/code&gt; 값을 포함 하므로 해당 유형은 &lt;code&gt;string&amp;nbsp;IntHashtbl.t&lt;/code&gt; 입니다.&lt;br/&gt;</target>
        </trans-unit>
        <trans-unit id="c2d68deb1edda584ae4e6e7569ccd1f525a47a80" translate="yes" xml:space="preserve">
          <source>This creates a new module &lt;code&gt;PairsMap&lt;/code&gt;, with a new type &lt;code&gt;'a&amp;nbsp;PairsMap.t&lt;/code&gt; of maps from &lt;code&gt;int&amp;nbsp;*&amp;nbsp;int&lt;/code&gt; to &lt;code&gt;'a&lt;/code&gt;. In this example, &lt;code&gt;m&lt;/code&gt; contains &lt;code&gt;string&lt;/code&gt; values so its type is &lt;code&gt;string&amp;nbsp;PairsMap.t&lt;/code&gt;.</source>
          <target state="translated">이 새로운 모듈 생성 &lt;code&gt;PairsMap&lt;/code&gt; 을 새로운 형태로, &lt;code&gt;'a&amp;nbsp;PairsMap.t&lt;/code&gt; 에서지도 &lt;code&gt;int&amp;nbsp;*&amp;nbsp;int&lt;/code&gt; 로 &lt;code&gt;'a&lt;/code&gt; . 이 예제에서 &lt;code&gt;m&lt;/code&gt; 은 &lt;code&gt;string&lt;/code&gt; 값을 포함 하므로 해당 유형은 &lt;code&gt;string&amp;nbsp;PairsMap.t&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="390961a477909cf3be486ca4a271404c23f7a126" translate="yes" xml:space="preserve">
          <source>This creates a new module &lt;code&gt;PairsSet&lt;/code&gt;, with a new type &lt;code&gt;PairsSet.t&lt;/code&gt; of sets of &lt;code&gt;int&amp;nbsp;*&amp;nbsp;int&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;int&amp;nbsp;*&amp;nbsp;int&lt;/code&gt; 세트의 새로운 유형 &lt;code&gt;PairsSet.t&lt;/code&gt; 를 가진 새로운 모듈 &lt;code&gt;PairsSet&lt;/code&gt; 을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="75cd13267b497efe97847c8300244e98191e876f" translate="yes" xml:space="preserve">
          <source>This creates the bytecode file mytoplevel, containing the OCaml toplevel system, plus the code from the three .cmo files. This toplevel is directly executable and is started by:</source>
          <target state="translated">그러면 OCaml 최상위 시스템과 3 개의 .cmo 파일의 코드가 포함 된 바이트 코드 파일 mytoplevel이 생성됩니다. 이 최상위 레벨은 직접 실행 가능하며 다음을 통해 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="f5b1409a54230dba201ee4c701c307570dc6eae6" translate="yes" xml:space="preserve">
          <source>This declaration does more than hiding the y method, it also makes the type c incompatible with any other closed object type, meaning that only o will be of type c. In that respect it behaves similarly to private record types. But private row types are more flexible with respect to incremental refinement. This feature can be used in combination with functors.</source>
          <target state="translated">이 선언은 y 메서드를 숨기는 것 이상을 수행합니다. 또한 c 유형을 다른 닫힌 객체 유형과 호환되지 않게 만듭니다. 즉, o 만 c 유형이됩니다. 그런 점에서 개인 레코드 유형과 유사하게 작동합니다. 그러나 개인 행 유형은 증분 세분화와 관련하여 더 유연합니다. 이 기능은 펑터와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62b4223715d06df11caf2304744d5adfa549ab4f" translate="yes" xml:space="preserve">
          <source>This declaration expresses that a value of type number is either an integer, a floating-point number, or the constant Error representing the result of an invalid operation (e.g. a division by zero).</source>
          <target state="translated">이 선언은 숫자 유형의 값이 정수, 부동 소수점 숫자 또는 유효하지 않은 연산 (예 : 0으로 나누기)의 결과를 나타내는 상수 오류임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="650dca8821c23c4d144204d01cac7fd4b83e068e" translate="yes" xml:space="preserve">
          <source>This defines name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt; as mutually recursive functions local to &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;.</source>
          <target state="translated">이것은 name &lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name &lt;sub&gt;n&lt;/sub&gt; 을 &lt;a href=&quot;#expr&quot;&gt;expr에&lt;/a&gt; 로컬 인 상호 재귀 함수로 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="ab9d147194e992eb8205321a938f103ca896c88b" translate="yes" xml:space="preserve">
          <source>This defines the type constructor as an abbreviation for the type expression on the right of the = sign.</source>
          <target state="translated">이것은 유형 생성자를 = 기호 오른쪽에있는 유형 표현식의 약어로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="749cd341985f67a650d96523cab212ab33c78584" translate="yes" xml:space="preserve">
          <source>This defines the value name name as a function with type type that executes by calling the given C function. For instance, here is how the int_of_string primitive is declared in the standard library module Stdlib:</source>
          <target state="translated">이것은 주어진 C 함수를 호출하여 실행되는 유형 유형의 함수로 값 이름 이름을 정의합니다. 예를 들어, 표준 라이브러리 모듈 Stdlib에서 int_of_string 프리미티브가 선언되는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d5ba8edf36d0fb0da29929bdb415469de948dad5" translate="yes" xml:space="preserve">
          <source>This definition reads as follows: a binary tree containing values of type 'a (an arbitrary type) is either empty, or is a node containing one value of type 'a and two subtrees also containing values of type 'a, that is, two 'a btree.</source>
          <target state="translated">이 정의는 다음과 같이 읽습니다. 'a (임의의 유형) 유형의 값을 포함하는 이진 트리는 비어 있거나'a 유형의 값 하나와 'a 유형의 값을 포함하는 두 개의 하위 트리, 즉 두 개의 하위 트리를 포함하는 노드입니다. 'btree.</target>
        </trans-unit>
        <trans-unit id="8d8e09fb17ca3bdcd19c8523134e3e779a73a386" translate="yes" xml:space="preserve">
          <source>This directive registers the function named printer-name (a value path) as a printer for values whose types match the argument type of the function. That is, the toplevel loop will call printer-name when it has such a value to print.</source>
          <target state="translated">이 지시문은 유형이 함수의 인수 유형과 일치하는 값에 대해 printer-name (값 경로)이라는 함수를 프린터로 등록합니다. 즉, 최상위 루프는 인쇄 할 값이있을 때 printer-name을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="2e68ea2c0517c1d20b6ed32dd8f6c253ddb6f201" translate="yes" xml:space="preserve">
          <source>This document is intended as a reference manual for the OCaml language. It lists the language constructs, and gives their precise syntax and informal semantics. It is by no means a tutorial introduction to the language: there is not a single example. A good working knowledge of OCaml is assumed.</source>
          <target state="translated">이 문서는 OCaml 언어에 대한 참조 설명서로 작성되었습니다. 언어 구조를 나열하고 정확한 구문과 비공식적 의미를 제공합니다. 이것은 언어에 대한 튜토리얼 소개가 아닙니다. 단 하나의 예도 없습니다. OCaml에 대한 좋은 실무 지식이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="74df0e696ad77b21b87792ac16ae61fcae218478" translate="yes" xml:space="preserve">
          <source>This engine makes it possible to implement a low-overhead memory profiler as an OCaml library.</source>
          <target state="translated">이 엔진을 사용하면 오버 헤드가 낮은 메모리 프로파일 러를 OCaml 라이브러리로 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3fa2a6f69f904187160e52f45b06e671158e7a1" translate="yes" xml:space="preserve">
          <source>This enters a regular toplevel loop, except that the code from foo.cmo, bar.cmo and gee.cmo is already loaded in memory, just as if you had typed:</source>
          <target state="translated">다음과 같이 foo.cmo, bar.cmo 및 gee.cmo의 코드가 이미 메모리에로드되어 있다는 점을 제외하면 일반 최상위 루프에 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="ac5c02e5a2be940db6035f15a82bb532610ff549" translate="yes" xml:space="preserve">
          <source>This error appears when trying to link an incomplete or incorrectly ordered set of files. Either you have forgotten to provide an implementation for the compilation unit named mod on the command line (typically, the file named mod.cmo, or a library containing that file). Fix: add the missing .ml or .cmo file to the command line. Or, you have provided an implementation for the module named mod, but it comes too late on the command line: the implementation of mod must come before all bytecode object files that reference mod. Fix: change the order of .ml and .cmo files on the command line.</source>
          <target state="translated">이 오류는 불완전하거나 잘못 정렬 된 파일 집합을 연결하려고 할 때 나타납니다. 명령 줄에서 mod라는 컴파일 단위 (일반적으로 mod.cmo라는 파일 또는 해당 파일을 포함하는 라이브러리)에 대한 구현을 제공하는 것을 잊었습니다. 수정 : 누락 된 .ml 또는 .cmo 파일을 명령 줄에 추가합니다. 또는 mod라는 모듈에 대한 구현을 제공했지만 명령 줄에서 너무 늦었습니다. mod의 구현은 mod를 참조하는 모든 바이트 코드 개체 파일보다 먼저 와야합니다. 수정 : 명령 줄에서 .ml 및 .cmo 파일의 순서를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="01feea14de8e0c629d6af124eee3f63c75a3e58e" translate="yes" xml:space="preserve">
          <source>This error appears when trying to link code that calls external functions written in C. As explained in chapter &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt;, such code must be linked with C libraries that implement the required f C function. If the C libraries in question are not shared libraries (DLLs), the code must be linked in &amp;ldquo;custom runtime&amp;rdquo; mode. Fix: add the required C libraries to the command line, and possibly the -custom option.</source>
          <target state="translated">이 오류는 C로 작성된 외부 함수를 호출하는 코드를 연결하려고 할 때 나타납니다. &lt;a href=&quot;intfc#c%3Aintf-c&quot;&gt;20&lt;/a&gt; 장에서 설명했듯이 이러한 코드는 필요한 f C 함수를 구현하는 C 라이브러리와 연결되어야합니다. 문제의 C 라이브러리가 공유 라이브러리 (DLL)가 아닌 경우 코드는 &quot;사용자 지정 런타임&quot;모드로 연결되어야합니다. 수정 : 필요한 C 라이브러리를 명령 줄에 추가하고 가능하면 -custom 옵션을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c3322e1b78b0d097c04a82c8abad2b9e17591c8f" translate="yes" xml:space="preserve">
          <source>This explicit overriding annotation also works for val and inherit:</source>
          <target state="translated">이 명시 적 재정의 주석은 val 및 inherit에도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1c31e1e38cacd668c448b1b245b9768d081710af" translate="yes" xml:space="preserve">
          <source>This expression evaluates to a functional value with one argument. When this function is applied to a value v, this value is matched against each pattern &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. If one of these matchings succeeds, that is, if the value v matches the pattern &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; for some i, then the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; associated to the selected pattern is evaluated, and its value becomes the value of the function application. The evaluation of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; takes place in an environment enriched by the bindings performed during the matching.</source>
          <target state="translated">이 표현식은 하나의 인수가있는 함수 값으로 평가됩니다. 이 함수 값 (V)을인가하면,이 값은 각 패턴에 대해 매칭되는 &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 에 &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; . 이러한 일치 중 하나가 성공하면, 즉 값 v가 일부 i에 대한 패턴 &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; 와 일치 하면 선택한 패턴과 연관된 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; 표현식 이 평가되고 그 값이 함수 애플리케이션의 값이됩니다. &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; 의 평가 는 일치하는 동안 수행 된 바인딩으로 강화 된 환경에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="15e34d384bc13e41a20958589d5dd84188cb9c53" translate="yes" xml:space="preserve">
          <source>This expression has type t&lt;sub&gt;1&lt;/sub&gt;, but is used with type t&lt;sub&gt;2&lt;/sub&gt;</source>
          <target state="translated">이 표현식의 유형은 t &lt;sub&gt;1&lt;/sub&gt; 이지만 유형 t &lt;sub&gt;2&lt;/sub&gt; 와 함께 사용됩니다.&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="c752faae770745f4efadec9ad9e3c86712116bf8" translate="yes" xml:space="preserve">
          <source>This expression is equivalent to:</source>
          <target state="translated">이 표현식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a8f6d05e23df51dd5500167d330c8fab6501e536" translate="yes" xml:space="preserve">
          <source>This extension allows user to define empty variants. Empty variant type can be eliminated by refutation case of pattern matching.</source>
          <target state="translated">이 확장을 통해 사용자는 빈 변형을 정의 할 수 있습니다. 빈 변형 유형은 패턴 일치의 반박 사례로 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c21aac0cfc0a526fe8feeb656d5151ae30a38c66" translate="yes" xml:space="preserve">
          <source>This extension is intended to provide a convenient syntax for working with monads and applicatives.</source>
          <target state="translated">이 확장은 모나드 및 응용 프로그램 작업을위한 편리한 구문을 제공하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="ba4fa874a00f72ae6a3e4ed02825e2050e5a7719" translate="yes" xml:space="preserve">
          <source>This extension makes it possible to open any module expression in module structures and expressions. A similar mechanism is also available inside module types, but only for extended module paths (e.g. F(X).G(Y)).</source>
          <target state="translated">이 확장을 사용하면 모듈 구조 및 표현식에서 모든 모듈 표현식을 열 수 있습니다. 모듈 유형 내에서도 유사한 메커니즘을 사용할 수 있지만 확장 모듈 경로 (예 : F (X) .G (Y))에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bded797c2b65154bcb84bdfa2fb5ae024b3d73a" translate="yes" xml:space="preserve">
          <source>This extension provides syntactic sugar for getting and setting elements for user-defined indexed types. For instance, we can define python-like dictionaries with</source>
          <target state="translated">이 확장은 사용자 정의 색인 유형에 대한 요소를 가져오고 설정하기위한 구문 설탕을 제공합니다. 예를 들어, 우리는 다음과 같이 파이썬과 같은 사전을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ced06d009b619786712d80c35d7e9694c054e2d" translate="yes" xml:space="preserve">
          <source>This extension provides syntactic sugar for getting and setting elements in the arrays provided by the &lt;a href=&quot;libref/bigarray&quot;&gt;Bigarray&lt;/a&gt; module.</source>
          <target state="translated">이 확장은 &lt;a href=&quot;libref/bigarray&quot;&gt;Bigarray&lt;/a&gt; 모듈에서 제공하는 배열의 요소를 가져오고 설정하기위한 구문 설탕을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="2b1d07b08e65aec904b4829d528dfb8d3dbc575e" translate="yes" xml:space="preserve">
          <source>This facility is currently available on all platforms supported by OCaml except Cygwin 64 bits.</source>
          <target state="translated">이 기능은 현재 Cygwin 64 비트를 제외하고 OCaml이 지원하는 모든 플랫폼에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8aaa2dee7862002847ec215725a07465e9cee221" translate="yes" xml:space="preserve">
          <source>This filename can also be specified using the OCAML_EVENTLOG_PREFIX environment variable. The given path will be suffixed with {.PID}.eventlog.</source>
          <target state="translated">이 파일 이름은 OCAML_EVENTLOG_PREFIX 환경 변수를 사용하여 지정할 수도 있습니다. 주어진 경로는 {.PID} .eventlog로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="d118477856b3c7c25f93002b3254e61bdd8c9a57" translate="yes" xml:space="preserve">
          <source>This form of attributes can also be inserted after the `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; in polymorphic variant type expressions (&lt;a href=&quot;types#tag-spec-first&quot;&gt;tag-spec-first&lt;/a&gt;, &lt;a href=&quot;types#tag-spec&quot;&gt;tag-spec&lt;/a&gt;, &lt;a href=&quot;types#tag-spec-full&quot;&gt;tag-spec-full&lt;/a&gt;) or after the &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; in &lt;a href=&quot;types#method-type&quot;&gt;method-type&lt;/a&gt;.</source>
          <target state="translated">속성이 형태는 또한`후에 삽입 될 수있는 &lt;a href=&quot;names#tag-name&quot;&gt;태그 이름&lt;/a&gt; 다형 변형 유형 식에서 ( &lt;a href=&quot;types#tag-spec-first&quot;&gt;태그 스펙 제&lt;/a&gt; , &lt;a href=&quot;types#tag-spec&quot;&gt;태그 - 스펙&lt;/a&gt; , &lt;a href=&quot;types#tag-spec-full&quot;&gt;태그 - 스펙 - 전체&lt;/a&gt; ) 또는 후에 &lt;a href=&quot;names#method-name&quot;&gt;있어서 이름&lt;/a&gt; 에 &lt;a href=&quot;types#method-type&quot;&gt;있어서 형&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ebb9471d9b8d494e18c82c68d8f753fc5a0fc194" translate="yes" xml:space="preserve">
          <source>This function can be applied to objects of type money or money2.</source>
          <target state="translated">이 함수는 money 또는 money2 유형의 개체에 적용 할 수 있습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="45f742d762c2f337f9316533c0c01063fbc47ef8" translate="yes" xml:space="preserve">
          <source>This function conforms to the specification of POSIX.1-2008 for the &lt;code&gt;basename&lt;/code&gt; utility.</source>
          <target state="translated">이 함수는 &lt;code&gt;basename&lt;/code&gt; 유틸리티에 대한 POSIX.1-2008 사양을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="6687a7963ca256cf05cde1098887f34f0c554208" translate="yes" xml:space="preserve">
          <source>This function does not allocate memory, but tries to run the postponed callbacks for already allocated memory blocks (of course, these callbacks may allocate).</source>
          <target state="translated">이 함수는 메모리를 할당하지 않지만 이미 할당 된 메모리 블록에 대해 연기 된 콜백을 실행하려고합니다 (물론 이러한 콜백이 할당 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="68449acffb76876acb29d71c9df112633cbec2b0" translate="yes" xml:space="preserve">
          <source>This function does nothing in this implementation.</source>
          <target state="translated">이 함수는이 구현에서 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b93512b013a1d7422171a6bb6941e6102fbeb0a" translate="yes" xml:space="preserve">
          <source>This function is safe because the byte sequence &lt;code&gt;s&lt;/code&gt; will never be accessed or mutated after &lt;code&gt;unsafe_to_string&lt;/code&gt; is called. The &lt;code&gt;string_init&lt;/code&gt; code gives up ownership of &lt;code&gt;s&lt;/code&gt;, and returns the ownership of the resulting string to its caller.</source>
          <target state="translated">이 함수는 &lt;code&gt;unsafe_to_string&lt;/code&gt; 이 호출 된 후에 바이트 시퀀스 &lt;code&gt;s&lt;/code&gt; 에 액세스하거나 변경하지 않기 때문에 안전합니다 . &lt;code&gt;string_init&lt;/code&gt; 의 코드의 소유권 포기 &lt;code&gt;s&lt;/code&gt; , 그 호출자에게 결과 문자열의 소유권을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1f9678c9920e8bd6fa3351bc87366633dae969b5" translate="yes" xml:space="preserve">
          <source>This function might be written like so:</source>
          <target state="translated">이 함수는 다음과 같이 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9cc7e820a82b580a34f0b2bb19198a32fb2d1dc" translate="yes" xml:space="preserve">
          <source>This function will erase non-string tag formatting functions.</source>
          <target state="translated">이 함수는 문자열이 아닌 태그 형식화 함수를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="2f8a6a2bcdafd5f49ba5cdcd976330cb7e69f76f" translate="yes" xml:space="preserve">
          <source>This functional, along with a number of other list and array functionals, is predefined because it is often useful, but there is nothing magic with it: it can easily be defined as follows.</source>
          <target state="translated">이 기능은 다른 여러 목록 및 배열 기능과 함께 미리 정의되어 있습니다. 종종 유용하기 때문에 미리 정의되어 있지만 마법은 없습니다. 다음과 같이 쉽게 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f98ed33477f247dffac90e7d27b65afcdf57df27" translate="yes" xml:space="preserve">
          <source>This generates a new type constructor and defines associated constructors or fields, through which values of that type can be directly built or inspected.</source>
          <target state="translated">이렇게하면 새 유형 생성자가 생성되고 해당 유형의 값을 직접 빌드하거나 검사 할 수있는 관련 생성자 또는 필드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="89ad557334e8e1d878c785f430b3e375436f8b96" translate="yes" xml:space="preserve">
          <source>This idiom can in turn be used to retrieve an object whose type has been weakened:</source>
          <target state="translated">이 관용구는 유형이 약화 된 객체를 검색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70991f0b7fe10b4796387e57d8f588f1325f5ec1" translate="yes" xml:space="preserve">
          <source>This idiom guarantees that Myset is compatible with Set, but allows it to represent sets internally in a different way.</source>
          <target state="translated">이 관용구는 Myset이 ​​Set과 호환됨을 보장하지만 내부적으로 다른 방식으로 집합을 나타낼 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="751a6509444b430d2b4388b31e1c9693d69713df" translate="yes" xml:space="preserve">
          <source>This is &lt;em&gt;not&lt;/em&gt; the semantics adopted by OCaml.</source>
          <target state="translated">이것은 OCaml에서 채택한 의미 가 &lt;em&gt;아닙니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="58da15a38848eb6e8733fd04e3d04f1485f3fce9" translate="yes" xml:space="preserve">
          <source>This is also available (since OCaml 4.06) for local opens in class expressions and class type expressions.</source>
          <target state="translated">이것은 클래스 표현식 및 클래스 유형 표현식의 로컬 열기에도 사용할 수 있습니다 (OCaml 4.06 이후).</target>
        </trans-unit>
        <trans-unit id="9768346232217703b79f946958f318884f387d78" translate="yes" xml:space="preserve">
          <source>This is an experimental extension of OCaml: the class of recursive definitions accepted, as well as its dynamic semantics are not final and subject to change in future releases.</source>
          <target state="translated">이것은 OCaml의 실험적 확장입니다. 허용되는 재귀 정의 클래스와 동적 의미는 최종적이지 않으며 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abf0eb306419907e3403ce9f96c3ef7450a9208f" translate="yes" xml:space="preserve">
          <source>This is another instance of friend functions as seen in section &lt;a href=&quot;objectexamples#s%3Afriends&quot;&gt;3.17&lt;/a&gt;. Indeed, this is the same mechanism used in the module Set in the absence of objects.</source>
          <target state="translated">이것은 섹션 &lt;a href=&quot;objectexamples#s%3Afriends&quot;&gt;3.17&lt;/a&gt; 에서 볼 수있는 친구 함수의 또 다른 인스턴스입니다 . 실제로 이것은 객체가 없을 때 모듈 Set에서 사용되는 것과 동일한 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="6c683f5551fbf795dd6f0010c7e2c94e3d36bfd7" translate="yes" xml:space="preserve">
          <source>This is because Lazy.force memoizes the result of the forced expression. In other words, every subsequent call of Lazy.force on that expression returns the result of the first computation without recomputing the lazy expression. Let us force lazy_two once again.</source>
          <target state="translated">이는 Lazy.force가 강제 표현의 결과를 기억하기 때문입니다. 즉, 해당 표현식에 대한 Lazy.force의 모든 후속 호출은 lazy 표현식을 다시 계산하지 않고 첫 번째 계산의 결과를 반환합니다. lazy_two를 다시 한 번 강제합니다.</target>
        </trans-unit>
        <trans-unit id="ad067981738b53b159d177a530e65b07049d0d76" translate="yes" xml:space="preserve">
          <source>This is by far the most common type error in programs. Type t&lt;sub&gt;1&lt;/sub&gt; is the type inferred for the expression (the part of the program that is displayed in the error message), by looking at the expression itself. Type t&lt;sub&gt;2&lt;/sub&gt; is the type expected by the context of the expression; it is deduced by looking at how the value of this expression is used in the rest of the program. If the two types t&lt;sub&gt;1&lt;/sub&gt; and t&lt;sub&gt;2&lt;/sub&gt; are not compatible, then the error above is produced.</source>
          <target state="translated">이것은 프로그램에서 가장 일반적인 유형 오류입니다. 유형 t &lt;sub&gt;1&lt;/sub&gt; 은 표현식 자체를보고 표현식 (오류 메시지에 표시되는 프로그램의 일부)에 대해 유추 된 유형입니다. 유형 t &lt;sub&gt;2&lt;/sub&gt; 는 표현식의 컨텍스트에서 예상되는 유형입니다. 이 표현식의 값이 나머지 프로그램에서 어떻게 사용되는지 살펴봄으로써 추론됩니다. 두 유형 t &lt;sub&gt;1&lt;/sub&gt; 및 t &lt;sub&gt;2&lt;/sub&gt; 가 호환되지 않으면 위의 오류가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f82fc074dee53936731175b8537edb3c787511a9" translate="yes" xml:space="preserve">
          <source>This is done by forming judgements on the &lt;em&gt;effects&lt;/em&gt; and the &lt;em&gt;coeffects&lt;/em&gt; that might be performed were the expression to be executed. Effects talk about how the expression might affect the world; coeffects talk about how the world might affect the expression.</source>
          <target state="translated">이것은 &lt;em&gt;효과&lt;/em&gt; 에 대한 판단을 형성함으로써 이루어지며 수행 될 수 있는 &lt;em&gt;공동 &lt;/em&gt;&lt;em&gt;효과&lt;/em&gt; 가 실행될 표현이었다. 효과는 표현이 세상에 어떤 영향을 미칠지에 대해 이야기합니다. coeffects는 세계가 표현에 어떤 영향을 미칠 수 있는지에 대해 이야기합니다.</target>
        </trans-unit>
        <trans-unit id="e1b690baac19cb0582baf96deb9492b21952c740" translate="yes" xml:space="preserve">
          <source>This is done using first class modules (see chapter &lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;8.5&lt;/a&gt;).</source>
          <target state="translated">이것은 일급 모듈을 사용하여 수행됩니다 ( &lt;a href=&quot;firstclassmodules#s%3Afirst-class-modules&quot;&gt;8.5&lt;/a&gt; 장 참조 ).</target>
        </trans-unit>
        <trans-unit id="14b965549f63ae8efc2b10799321a123949f32e2" translate="yes" xml:space="preserve">
          <source>This is in any case a good practice for such global mutable variables. Otherwise, they will pick out the type of first use. If there is a mistake at this point, this can result in confusing type errors when later, correct uses are flagged as errors.</source>
          <target state="translated">이것은 어떤 경우에도 그러한 전역 가변 변수에 대한 좋은 관행입니다. 그렇지 않으면 첫 번째 사용 유형을 선택합니다. 이 시점에서 실수가 있으면 나중에 올바른 사용이 오류로 플래그 지정 될 때 혼동 유형 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da8a97ff5473940dbd5590e2ac55f520f156f175" translate="yes" xml:space="preserve">
          <source>This is the counterpart in signatures of class definitions. A class specification matches a class definition if they have the same type parameters and their types match.</source>
          <target state="translated">이것은 클래스 정의 시그니처의 대응 부분입니다. 클래스 사양은 동일한 유형 매개 변수가 있고 유형이 일치하는 경우 클래스 정의와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="4a2f273ae05987b14e1f15ae11bcc910f3cc8e34" translate="yes" xml:space="preserve">
          <source>This manual documents the release 4.11 of the OCaml system. It is organized as follows.</source>
          <target state="translated">이 매뉴얼은 OCaml 시스템의 4.11 릴리스를 문서화합니다. 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="949db82cf2165881bb890405414754937b92c7a0" translate="yes" xml:space="preserve">
          <source>This manual is also available in &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman.pdf&quot;&gt;PDF&lt;/a&gt;. &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman.txt&quot;&gt;plain text&lt;/a&gt;, as a &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman-html.tar.gz&quot;&gt;bundle of HTML files&lt;/a&gt;, and as a &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman.info.tar.gz&quot;&gt;bundle of Emacs Info files&lt;/a&gt;.</source>
          <target state="translated">이 설명서는 &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman.pdf&quot;&gt;PDF&lt;/a&gt; 로도 제공됩니다 . &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman.txt&quot;&gt;일반 텍스트&lt;/a&gt; A와, &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman-html.tar.gz&quot;&gt;HTML 파일의 번들&lt;/a&gt; , 그리고 같은 &lt;a href=&quot;https://ocaml.org/releases/4.11/ocaml-4.11-refman.info.tar.gz&quot;&gt;이맥스 정보 파일의 번들&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6a463aa2621012fa84bb9173c52f8aacbca9587" translate="yes" xml:space="preserve">
          <source>This may require some care: if the scrutinee may return several different cases of the same pattern, or raise distinct instances of the same exception, you may need to modify your code to separate those several cases.</source>
          <target state="translated">이 경우 약간의주의가 필요할 수 있습니다. 스크 러틴이 동일한 패턴의 여러 다른 사례를 반환하거나 동일한 예외의 고유 한 인스턴스를 발생시킬 수있는 경우 이러한 여러 사례를 구분하도록 코드를 수정해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9e169cadd5567bf33a7c94a3b1845ac6d0d1577" translate="yes" xml:space="preserve">
          <source>This meta-module provides labelized version of the &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="translated">이 메타 모듈은 &lt;a href=&quot;array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;bytes&quot;&gt; &lt;code&gt;Bytes&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 모듈 의 레이블이 지정된 버전을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="1cda004ff3f73690b7705e7353fdb4ee3d731450" translate="yes" xml:space="preserve">
          <source>This meta-module provides labelized version of the &lt;a href=&quot;hashtbl&quot;&gt;&lt;code&gt;Hashtbl&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;map&quot;&gt;&lt;code&gt;Map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="translated">이 메타 모듈은 &lt;a href=&quot;hashtbl&quot;&gt; &lt;code&gt;Hashtbl&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;map&quot;&gt; &lt;code&gt;Map&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;set&quot;&gt; &lt;code&gt;Set&lt;/code&gt; &lt;/a&gt; 모듈 의 레이블이 지정된 버전을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="74b7b70a1b67a465fca03531e3e7ca988aa3c7a2" translate="yes" xml:space="preserve">
          <source>This method will be called with the list of analysed and possibly merged Odoc_info.t_module structures.</source>
          <target state="translated">이 메서드는 분석되고 병합 된 Odoc_info.t_module 구조 목록과 함께 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="17cfabd3ff7747a40d003c4e1ce49d8233fcae6d" translate="yes" xml:space="preserve">
          <source>This module allows OCaml values to be registered with the C runtime under a symbolic name, so that C code can later call back registered OCaml functions, or raise registered OCaml exceptions.</source>
          <target state="translated">이 모듈을 사용하면 기호 이름으로 C 런타임에 OCaml 값을 등록 할 수 있으므로 C 코드는 나중에 등록 된 OCaml 함수를 다시 호출하거나 등록 된 OCaml 예외를 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99f88a4ac39ab2683e26258770cfb0e2d8f5fd8c" translate="yes" xml:space="preserve">
          <source>This module allows to define a type &lt;code&gt;t&lt;/code&gt; with the &lt;code&gt;immediate64&lt;/code&gt; attribute. This attribute means that the type is immediate on 64 bit architectures. On other architectures, it might or might not be immediate.</source>
          <target state="translated">이 모듈은 입력 정의 할 수 &lt;code&gt;t&lt;/code&gt; 를 으로 &lt;code&gt;immediate64&lt;/code&gt; 의 속성. 이 속성은 유형이 64 비트 아키텍처에서 즉시 있음을 의미합니다. 다른 아키텍처에서는 즉각적 일 수도 있고 그렇지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e533b385e01821d7ad15e0945c07d70b1844d76" translate="yes" xml:space="preserve">
          <source>This module implements a pretty-printing facility to format values within &lt;a href=&quot;format#boxes&quot;&gt;'pretty-printing boxes'&lt;/a&gt; and &lt;a href=&quot;format#tags&quot;&gt;'semantic tags'&lt;/a&gt; combined with a set of &lt;a href=&quot;format#fpp&quot;&gt;printf-like functions&lt;/a&gt;. The pretty-printer splits lines at specified &lt;a href=&quot;format#breaks&quot;&gt;break hints&lt;/a&gt;, and indents lines according to the box structure. Similarly, &lt;a href=&quot;format#tags&quot;&gt;semantic tags&lt;/a&gt; can be used to decouple text presentation from its contents.</source>
          <target state="translated">이 모듈 은 &lt;a href=&quot;format#fpp&quot;&gt;printf와 유사한 함수&lt;/a&gt; 세트와 결합 된 &lt;a href=&quot;format#boxes&quot;&gt;'예쁜 인쇄 상자'&lt;/a&gt; 및 &lt;a href=&quot;format#tags&quot;&gt;'의미있는 태그'&lt;/a&gt; 내의 값을 형식화하는 예쁜 인쇄 기능을 구현 합니다 . pretty-printer는 지정된 &lt;a href=&quot;format#breaks&quot;&gt;구분 힌트&lt;/a&gt; 에서 줄을 분할 하고 상자 구조에 따라 줄을 들여 씁니다. 마찬가지로 &lt;a href=&quot;format#tags&quot;&gt;시맨틱 태그&lt;/a&gt; 를 사용하여 내용에서 텍스트 표시를 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="6fe9c1d1946f164dc7ea31e649282f17763c3950" translate="yes" xml:space="preserve">
          <source>This module implements a simple 'standard' lexical analyzer, presented as a function from character streams to token streams. It implements roughly the lexical conventions of OCaml, but is parameterized by the set of keywords of your language.</source>
          <target state="translated">이 모듈은 문자 스트림에서 토큰 스트림에 이르는 함수로 제공되는 간단한 '표준'어휘 분석기를 구현합니다. 대략 OCaml의 어휘 규약을 구현하지만 사용자 언어의 키워드 세트에 의해 매개 변수화됩니다.</target>
        </trans-unit>
        <trans-unit id="9e0125fd89be5c0e10d0ed6d49f7e1879412755c" translate="yes" xml:space="preserve">
          <source>This module implements applicative association tables, also known as finite maps or dictionaries, given a total ordering function over the keys. All operations over maps are purely applicative (no side-effects). The implementation uses balanced binary trees, and therefore searching and insertion take time logarithmic in the size of the map.</source>
          <target state="translated">이 모듈은 키에 대한 전체 순서 지정 기능이 주어지면 유한 맵 또는 사전이라고도하는 적용 가능한 연관 테이블을 구현합니다. 맵에 대한 모든 작업은 순전히 적용 가능합니다 (부작용 없음). 구현은 균형 잡힌 이진 트리를 사용하므로 검색 및 삽입은 맵 크기에서 로그 방식으로 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="ce89672c48fa1f9bec12d607d59af82b35753a53" translate="yes" xml:space="preserve">
          <source>This module implements buffers that automatically expand as necessary. It provides accumulative concatenation of strings in quasi-linear time (instead of quadratic time when strings are concatenated pairwise).</source>
          <target state="translated">이 모듈은 필요에 따라 자동으로 확장되는 버퍼를 구현합니다. 문자열이 쌍으로 연결되는 2 차 시간 대신 준 선형 시간에 문자열의 누적 연결을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="da30f332376f7747f380e4c823a1b7a155244e7c" translate="yes" xml:space="preserve">
          <source>This module implements multi-dimensional arrays of integers and floating-point numbers, thereafter referred to as 'Bigarrays', to distinguish them from the standard OCaml arrays described in &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; 에&lt;/a&gt; 설명 된 표준 OCaml 배열과 구별하기 위해 정수 및 부동 소수점 숫자의 다차원 배열 (이후 'Bigarrays'라고 함)을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="7c5803197dddf99e3ec90f036488d17a8b4740cf" translate="yes" xml:space="preserve">
          <source>This module implements queues (FIFOs), with in-place modification.</source>
          <target state="translated">이 모듈은 내부 수정으로 큐 (FIFO)를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="fd2b395d2566d5b178c77d76600076510ec457a8" translate="yes" xml:space="preserve">
          <source>This module implements stacks (LIFOs), with in-place modification.</source>
          <target state="translated">이 모듈은 내부 수정으로 스택 (LIFO)을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="b90dc1cefe04c048afd0453d62a3c51d515ce8d7" translate="yes" xml:space="preserve">
          <source>This module implements synchronous inter-thread communications over channels. As in John Reppy's Concurrent ML system, the communication events are first-class values: they can be built and combined independently before being offered for communication.</source>
          <target state="translated">이 모듈은 채널을 통한 동기 스레드 간 통신을 구현합니다. John Reppy의 Concurrent ML 시스템에서와 같이 커뮤니케이션 이벤트는 최고 수준의 가치입니다. 커뮤니케이션을 위해 제공되기 전에 독립적으로 구축하고 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3849f273edf21565de6b4e420886d0b2f60b00cd" translate="yes" xml:space="preserve">
          <source>This module implements the set data structure, given a total ordering function over the set elements. All operations over sets are purely applicative (no side-effects). The implementation uses balanced binary trees, and is therefore reasonably efficient: insertion and membership take time logarithmic in the size of the set, for instance.</source>
          <target state="translated">이 모듈은 집합 요소에 대한 총 주문 기능이 주어지면 집합 데이터 구조를 구현합니다. 집합에 대한 모든 작업은 순전히 적용 가능합니다 (부작용 없음). 구현은 균형 잡힌 이진 트리를 사용하므로 합리적으로 효율적입니다. 예를 들어 삽입 및 멤버십은 집합 크기에서 로그 방식으로 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="2729905361f7f59d504ab6ed9996768ff5460796" translate="yes" xml:space="preserve">
          <source>This module is automatically opened at the beginning of each compilation. All components of this module can therefore be referred by their short name, without prefixing them by &lt;code&gt;Stdlib&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 각 컴파일을 시작할 때 자동으로 열립니다. 따라서이 모듈의 모든 구성 요소는 &lt;code&gt;Stdlib&lt;/code&gt; 접두사없이 짧은 이름으로 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0333c95ed68f95f7342e2b757b9f08ce6a149992" translate="yes" xml:space="preserve">
          <source>This module is intended to be used through &lt;a href=&quot;stdlabels&quot;&gt;&lt;code&gt;StdLabels&lt;/code&gt;&lt;/a&gt; which replaces &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; with their labeled counterparts.</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;bytes&quot;&gt; &lt;code&gt;Bytes&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 을 레이블이 지정된 대응 &lt;a href=&quot;stdlabels&quot;&gt; &lt;code&gt;StdLabels&lt;/code&gt; &lt;/a&gt; 로 대체하는 StdLabels 를 통해 사용하도록되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0e122c356078f81e1beb90b2b6032029724c402" translate="yes" xml:space="preserve">
          <source>This module is intended to be used via &lt;a href=&quot;stdlabels&quot;&gt;&lt;code&gt;StdLabels&lt;/code&gt;&lt;/a&gt; which replaces &lt;a href=&quot;array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt; with their labeled counterparts</source>
          <target state="translated">이 모듈은 &lt;a href=&quot;array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;bytes&quot;&gt; &lt;code&gt;Bytes&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 을 레이블이 지정된 대응 &lt;a href=&quot;stdlabels&quot;&gt; &lt;code&gt;StdLabels&lt;/code&gt; &lt;/a&gt; 로 대체하는 StdLabels 를 통해 사용하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="64267a0e80b390a500ec96cdaa100f7adf548198" translate="yes" xml:space="preserve">
          <source>This module provides a general mechanism for extracting options and arguments from the command line to the program.</source>
          <target state="translated">이 모듈은 명령 줄에서 프로그램으로 옵션과 인수를 추출하는 일반적인 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b609722b91ba2b158610f696a1988788495b0d03" translate="yes" xml:space="preserve">
          <source>This module provides arithmetic operations on complex numbers. Complex numbers are represented by their real and imaginary parts (cartesian representation). Each part is represented by a double-precision floating-point number (type &lt;code&gt;float&lt;/code&gt;).</source>
          <target state="translated">이 모듈은 복소수에 대한 산술 연산을 제공합니다. 복소수는 실수 부와 허수 부 (직교 표현)로 표현됩니다. 각 부분은 배정 밀도 부동 소수점 숫자 ( &lt;code&gt;float&lt;/code&gt; 유형 )로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="19a26eb45fe7af4a376a6ae294864852d297cbea" translate="yes" xml:space="preserve">
          <source>This module provides functions to compute 128-bit 'digests' of arbitrary-length strings or files. The digests are of cryptographic quality: it is very hard, given a digest, to forge a string having that digest. The algorithm used is MD5. This module should not be used for secure and sensitive cryptographic applications. For these kind of applications more recent and stronger cryptographic primitives should be used instead.</source>
          <target state="translated">이 모듈은 임의 길이 문자열 또는 파일의 128 비트 '다이제스트'를 계산하는 함수를 제공합니다. 다이제스트는 암호화 품질입니다. 다이제스트가있는 문자열을 위조하는 것은 다이제스트가 주어지면 매우 어렵습니다. 사용 된 알고리즘은 MD5입니다. 이 모듈은 안전하고 민감한 암호화 애플리케이션에 사용해서는 안됩니다. 이러한 종류의 응용 프로그램의 경우보다 최신의 강력한 암호화 기본 형식을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fc7540f10133c093c21edec4564acef90adfe177" translate="yes" xml:space="preserve">
          <source>This module provides functions to encode arbitrary data structures as sequences of bytes, which can then be written on a file or sent over a pipe or network connection. The bytes can then be read back later, possibly in another process, and decoded back into a data structure. The format for the byte sequences is compatible across all machines for a given version of OCaml.</source>
          <target state="translated">이 모듈은 임의의 데이터 구조를 바이트 시퀀스로 인코딩하는 기능을 제공합니다. 그런 다음 파일에 기록하거나 파이프 또는 네트워크 연결을 통해 전송할 수 있습니다. 그런 다음 나중에 다른 프로세스에서 다시 읽은 다음 데이터 구조로 다시 디코딩 할 수 있습니다. 바이트 시퀀스의 형식은 지정된 버전의 OCaml에 대해 모든 시스템에서 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="8bbb035f066ee24f4ebaaacb2368ebd643cd2d0c" translate="yes" xml:space="preserve">
          <source>This module provides operations on the type &lt;code&gt;int32&lt;/code&gt; of signed 32-bit integers. Unlike the built-in &lt;code&gt;int&lt;/code&gt; type, the type &lt;code&gt;int32&lt;/code&gt; is guaranteed to be exactly 32-bit wide on all platforms. All arithmetic operations over &lt;code&gt;int32&lt;/code&gt; are taken modulo 2&lt;sup&gt;32&lt;/sup&gt;.</source>
          <target state="translated">이 모듈은 부호있는 32 비트 정수의 &lt;code&gt;int32&lt;/code&gt; 유형에 대한 작업을 제공합니다 . 내장 &lt;code&gt;int&lt;/code&gt; 유형 과 달리 &lt;code&gt;int32&lt;/code&gt; 유형 은 모든 플랫폼에서 정확히 32 비트 너비가 보장됩니다. &lt;code&gt;int32&lt;/code&gt; 에 대한 모든 산술 연산 은 모듈로 2 &lt;sup&gt;32&lt;/sup&gt; 취 합니다.</target>
        </trans-unit>
        <trans-unit id="d5e7fe24e618c6feb78fd56d32e5512c8633a081" translate="yes" xml:space="preserve">
          <source>This module provides operations on the type &lt;code&gt;int64&lt;/code&gt; of signed 64-bit integers. Unlike the built-in &lt;code&gt;int&lt;/code&gt; type, the type &lt;code&gt;int64&lt;/code&gt; is guaranteed to be exactly 64-bit wide on all platforms. All arithmetic operations over &lt;code&gt;int64&lt;/code&gt; are taken modulo 2&lt;sup&gt;64&lt;/sup&gt;</source>
          <target state="translated">이 모듈은 부호있는 64 비트 정수의 &lt;code&gt;int64&lt;/code&gt; 유형에 대한 작업을 제공합니다 . 기본 제공 &lt;code&gt;int&lt;/code&gt; 유형 과 달리 &lt;code&gt;int64&lt;/code&gt; 유형 은 모든 플랫폼에서 정확히 64 비트 너비가 보장됩니다. &lt;code&gt;int64&lt;/code&gt; 를 통한 모든 산술 연산 은 모듈로 2 &lt;sup&gt;64&lt;/sup&gt; 로 취합니다.&lt;sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="dd560eafa9bf44786fbe70e70e377b41d3ae81e2" translate="yes" xml:space="preserve">
          <source>This module provides operations on the type &lt;code&gt;nativeint&lt;/code&gt; of signed 32-bit integers (on 32-bit platforms) or signed 64-bit integers (on 64-bit platforms). This integer type has exactly the same width as that of a pointer type in the C compiler. All arithmetic operations over &lt;code&gt;nativeint&lt;/code&gt; are taken modulo 2&lt;sup&gt;32&lt;/sup&gt; or 2&lt;sup&gt;64&lt;/sup&gt; depending on the word size of the architecture.</source>
          <target state="translated">이 모듈은 부호있는 32 비트 정수 (32 비트 플랫폼) 또는 부호있는 64 비트 정수 (64 비트 플랫폼)의 &lt;code&gt;nativeint&lt;/code&gt; 유형에 대한 작업을 제공합니다 . 이 정수 유형은 C 컴파일러의 포인터 유형과 정확히 동일한 너비를 갖습니다. &lt;code&gt;nativeint&lt;/code&gt; 를 통한 모든 산술 연산 은 아키텍처의 단어 크기에 따라 모듈로 2 &lt;sup&gt;32&lt;/sup&gt; 또는 2 &lt;sup&gt;64&lt;/sup&gt; 로 간주 됩니다 .</target>
        </trans-unit>
        <trans-unit id="288a280c92d0e752f41d14eee812057e14d86d83" translate="yes" xml:space="preserve">
          <source>This option has no effect.</source>
          <target state="translated">이 옵션은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a0fa776a935837d0195b8b526844f025d4e6ce93" translate="yes" xml:space="preserve">
          <source>This part of the manual is a tutorial introduction to the OCaml language. A good familiarity with programming in a conventional languages (say, C or Java) is assumed, but no prior exposure to functional languages is required. The present chapter introduces the core language. Chapter &lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt; deals with the module system, chapter &lt;a href=&quot;objectexamples#c%3Aobjectexamples&quot;&gt;3&lt;/a&gt; with the object-oriented features, chapter &lt;a href=&quot;lablexamples#c%3Alabl-examples&quot;&gt;4&lt;/a&gt; with extensions to the core language (labeled arguments and polymorphic variants), and chapter &lt;a href=&quot;advexamples#c%3Aadvexamples&quot;&gt;6&lt;/a&gt; gives some advanced examples.</source>
          <target state="translated">매뉴얼의이 부분은 OCaml 언어에 대한 튜토리얼 소개입니다. 기존 언어 (예 : C 또는 Java)의 프로그래밍에 대해 잘 알고 있다고 가정하지만 기능 언어에 대한 사전 노출은 필요하지 않습니다. 이 장에서는 핵심 언어를 소개합니다. 제 &lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt; 모듈 시스템과 거래, 장 &lt;a href=&quot;objectexamples#c%3Aobjectexamples&quot;&gt;3&lt;/a&gt; 객체 지향 기능은 장 &lt;a href=&quot;lablexamples#c%3Alabl-examples&quot;&gt;4&lt;/a&gt; 핵심 언어 확장 (표시된 인수 및 다형성 변종), 그리고 장과 &lt;a href=&quot;advexamples#c%3Aadvexamples&quot;&gt;6은&lt;/a&gt; 일부 고급 예제를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dbc86cc4d49f38cd528229f18473c5150da317ea" translate="yes" xml:space="preserve">
          <source>This pretty-printing facility is implemented as an overlay on top of abstract &lt;a href=&quot;format#formatter&quot;&gt;formatters&lt;/a&gt; which provide basic output functions. Some formatters are predefined, notably:</source>
          <target state="translated">이 예쁜 인쇄 기능은 기본 출력 기능을 제공하는 추상 &lt;a href=&quot;format#formatter&quot;&gt;포맷터&lt;/a&gt; 위에 오버레이로 구현됩니다 . 특히 다음과 같은 일부 포맷터가 미리 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a85ed63830f1cbd46d61e59847fbdc4998afedf8" translate="yes" xml:space="preserve">
          <source>This principle also applies to functions of several arguments whose return type is a type variable, as long as the role of each argument is not ambiguous. Labeling such functions may lead to awkward error messages when one attempts to omit labels in an application, as we have seen with ListLabels.fold_left.</source>
          <target state="translated">이 원칙은 각 인수의 역할이 모호하지 않는 한 반환 유형이 유형 변수 인 여러 인수의 함수에도 적용됩니다. 이러한 함수에 레이블을 지정하면 ListLabels.fold_left에서 보았 듯이 응용 프로그램에서 레이블을 생략하려고 할 때 어색한 오류 메시지가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="672f5a8d2001e1947d29714c5e2ccca5133a964a" translate="yes" xml:space="preserve">
          <source>This provides a convenient way to introduce local names for types and modules when defining a signature:</source>
          <target state="translated">이는 서명을 정의 할 때 유형 및 모듈에 대한 로컬 이름을 도입하는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="93a45b4f1b855894d7e36f97483d0e12e2929c42" translate="yes" xml:space="preserve">
          <source>This reference is initially set to &lt;code&gt;false&lt;/code&gt; in standalone programs and to &lt;code&gt;true&lt;/code&gt; if the code is being executed under the interactive toplevel system &lt;code&gt;ocaml&lt;/code&gt;.</source>
          <target state="translated">이 참조는 처음에는 독립 실행 형 프로그램에서 &lt;code&gt;false&lt;/code&gt; 로 설정 되고 코드가 대화 형 최상위 시스템 &lt;code&gt;ocaml&lt;/code&gt; 에서 실행되는 경우 &lt;code&gt;true&lt;/code&gt; 로 설정 됩니다 .</target>
        </trans-unit>
        <trans-unit id="5eb60a37765a751859069418a148aa8f84ee1892" translate="yes" xml:space="preserve">
          <source>This requires that programs to be tested are instrumented to communicate with afl-fuzz. The native-code compiler &amp;ldquo;ocamlopt&amp;rdquo; can generate such instrumentation, allowing afl-fuzz to be used against programs written in OCaml.</source>
          <target state="translated">이를 위해서는 테스트 할 프로그램이 afl-fuzz와 통신하도록 계측되어야합니다. 네이티브 코드 컴파일러 &quot;ocamlopt&quot;는 이러한 계측을 생성하여 OCaml로 작성된 프로그램에 대해 afl-fuzz를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52dcd9a1729658eb0c6b106d0c414385be78c303" translate="yes" xml:space="preserve">
          <source>This result in the error message &amp;ldquo;expression C of type foo cannot be used with type foo&amp;rdquo;.</source>
          <target state="translated">이로 인해 &quot;foo 유형의 표현식 C는 유형 foo와 함께 사용할 수 없습니다&quot;라는 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c3a02fce90d5e7f7129963fee4236b9d584135a5" translate="yes" xml:space="preserve">
          <source>This script expect to receive as an argument the directory containing the trace file. It will then copy the &lt;em&gt;CTF&lt;/em&gt; metadata file to the trace&amp;rsquo;s directory, and then decode the trace, printing each event in the process.</source>
          <target state="translated">이 스크립트는 추적 파일이 포함 된 디렉토리를 인수로받을 것으로 예상합니다. 그런 다음 &lt;em&gt;CTF&lt;/em&gt; 메타 데이터 파일을 추적의 디렉터리에 복사 한 다음 추적을 디코딩하여 프로세스의 각 이벤트를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="ef9456a3c165c2c5114ee21374f6504d86e6983b" translate="yes" xml:space="preserve">
          <source>This second form also works for patterns:</source>
          <target state="translated">이 두 번째 형식은 패턴에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5fc3c124b4479b68cbf25dba521d9a1e132177df" translate="yes" xml:space="preserve">
          <source>This section contains some general guidelines for writing C stubs that use Windows Unicode APIs.</source>
          <target state="translated">이 섹션에는 Windows 유니 코드 API를 사용하는 C 스텁을 작성하기위한 몇 가지 일반적인 지침이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f394592ed3600793f95e1254fcf350cda70b82c" translate="yes" xml:space="preserve">
          <source>This section describe how to make calling C functions cheaper.</source>
          <target state="translated">이 섹션에서는 C 함수를 더 저렴하게 호출하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d5d9e3857acf6ed9216da0ef8ec0aa252128e3aa" translate="yes" xml:space="preserve">
          <source>This section describes a tool that is not yet officially supported but may be found useful.</source>
          <target state="translated">이 섹션에서는 아직 공식적으로 지원되지는 않지만 유용 할 수있는 도구에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="08aafc15cda9ee7ff87051d799ffe599afa951de" translate="yes" xml:space="preserve">
          <source>This section describes and explains in detail some warnings:</source>
          <target state="translated">이 섹션에서는 몇 가지 경고에 대해 자세히 설명하고 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ffca379ae7271c0783a4ac241e377936af555ed8" translate="yes" xml:space="preserve">
          <source>This section describes and explains the most frequently encountered error messages.</source>
          <target state="translated">이 섹션에서는 가장 자주 발생하는 오류 메시지를 설명하고 설명합니다.</target>
        </trans-unit>
        <trans-unit id="31ad7ee467b01f5649ddd8facce322cfb81ef3ae" translate="yes" xml:space="preserve">
          <source>This section describes how OCaml data types are encoded in the value type.</source>
          <target state="translated">이 섹션에서는 OCaml 데이터 유형이 값 유형으로 인코딩되는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="01693577ebb54a11b677d93676f308db58f638a4" translate="yes" xml:space="preserve">
          <source>This section describes the kinds of values that are manipulated by OCaml programs.</source>
          <target state="translated">이 섹션에서는 OCaml 프로그램에 의해 조작되는 값의 종류에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b36e7060d9bec0558c1823961541205abf1df8d6" translate="yes" xml:space="preserve">
          <source>This section describes unsafe, low-level conversion functions between &lt;code&gt;bytes&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt;. They do not copy the internal data; used improperly, they can break the immutability invariant on strings provided by the &lt;code&gt;-safe-string&lt;/code&gt; option. They are available for expert library authors, but for most purposes you should use the always-correct &lt;a href=&quot;bytes#VALto_string&quot;&gt;&lt;code&gt;Bytes.to_string&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;bytes#VALof_string&quot;&gt;&lt;code&gt;Bytes.of_string&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 섹션에서는 &lt;code&gt;bytes&lt;/code&gt; 와 &lt;code&gt;string&lt;/code&gt; 간의 안전하지 않은 저수준 변환 함수에 대해 설명 합니다 . 내부 데이터는 복사하지 않습니다. 부적절하게 사용하면 &lt;code&gt;-safe-string&lt;/code&gt; 옵션 에서 제공하는 문자열의 불변성 불변성을 깨뜨릴 수 있습니다 . 전문 라이브러리 작성자가 사용할 수 있지만 대부분의 경우 항상 올바른 &lt;a href=&quot;bytes#VALto_string&quot;&gt; &lt;code&gt;Bytes.to_string&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;bytes#VALof_string&quot;&gt; &lt;code&gt;Bytes.of_string&lt;/code&gt; 을 사용해야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0a9f87ec885f096da88cc6ca28abd5b60c7d67fe" translate="yes" xml:space="preserve">
          <source>This section explains how C stub code that interfaces C or Fortran code with OCaml code can use Bigarrays.</source>
          <target state="translated">이 섹션에서는 C 또는 Fortran 코드를 OCaml 코드와 인터페이스하는 C 스텁 코드가 Bigarray를 사용하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="71cdd8bac2c7a5aeee310523309d1c53e8523783" translate="yes" xml:space="preserve">
          <source>This section illustrates the callback facilities described in section &lt;a href=&quot;#s%3Ac-callback&quot;&gt;20.7&lt;/a&gt;. We are going to package some OCaml functions in such a way that they can be linked with C code and called from C just like any C functions. The OCaml functions are defined in the following mod.ml OCaml source:</source>
          <target state="translated">이 섹션은 섹션 &lt;a href=&quot;#s%3Ac-callback&quot;&gt;20.7에&lt;/a&gt; 설명 된 콜백 기능을 설명 합니다. 우리는 어떤 C 함수와 마찬가지로 C 코드와 연결되고 C에서 호출 될 수있는 방식으로 일부 OCaml 함수를 패키징 할 것입니다. OCaml 함수는 다음 mod.ml OCaml 소스에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="903aefdf9956fc71e923a3df9d4dd16dd0134747" translate="yes" xml:space="preserve">
          <source>This section lists the known incompatibilities between the bytecode compiler and the native-code compiler. Except on those points, the two compilers should generate code that behave identically.</source>
          <target state="translated">이 섹션에서는 바이트 코드 컴파일러와 네이티브 코드 컴파일러 간의 알려진 비 호환성에 대해 설명합니다. 이러한 점을 제외하고 두 컴파일러는 동일하게 작동하는 코드를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="18b5904aff3b237cf95bcb17d1df036bc4ab134c" translate="yes" xml:space="preserve">
          <source>This section outlines how the functions from the Unix curses library can be made available to OCaml programs. First of all, here is the interface curses.ml that declares the curses primitives and data types:</source>
          <target state="translated">이 섹션에서는 Unix curses 라이브러리의 함수를 OCaml 프로그램에서 사용할 수있는 방법에 대해 설명합니다. 먼저 curses 프리미티브 및 데이터 유형을 선언하는 curses.ml 인터페이스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="254ed70371607b2c3851b67568dd926316b5ceae" translate="yes" xml:space="preserve">
          <source>This short notation for fields also works when constructing records:</source>
          <target state="translated">필드에 대한이 짧은 표기법은 레코드를 구성 할 때도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b8e400965e58bbfd6200a8deb63c3134ffb7098b" translate="yes" xml:space="preserve">
          <source>This short section is intended to clarify the relationship between the names of the modules corresponding to compilation units and the names of the files that contain their compiled interface and compiled implementation.</source>
          <target state="translated">이 짧은 섹션은 컴파일 단위에 해당하는 모듈 이름과 컴파일 된 인터페이스 및 컴파일 된 구현을 포함하는 파일 이름 간의 관계를 명확히하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="24aa0094a26c8735b882dd7c464be2f2468ee6f8" translate="yes" xml:space="preserve">
          <source>This shows the use of modules to group several class definitions that can in fact be thought of as a single unit. This unit would be provided by a bank for both internal and external uses. This is implemented as a functor that abstracts over the currency so that the same code can be used to provide accounts in different currencies.</source>
          <target state="translated">이것은 실제로 단일 단위로 생각할 수있는 여러 클래스 정의를 그룹화하기 위해 모듈을 사용하는 것을 보여줍니다. 이 장치는 내부 및 외부 사용을 위해 은행에서 제공합니다. 이것은 동일한 코드를 사용하여 다른 통화로 계정을 제공 할 수 있도록 통화를 추상화하는 펑터로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="48666abb0d053a2e67948abc2515711d3c441749" translate="yes" xml:space="preserve">
          <source>This simplifies to:</source>
          <target state="translated">이것은 다음을 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="ddd8a59e7fc768a0f67909566216bc17b9fded83" translate="yes" xml:space="preserve">
          <source>This syntax can be very useful when defining recursive functions involving GADTs, see the section &lt;a href=&quot;gadts#s%3Agadts&quot;&gt;8.10&lt;/a&gt; for a more detailed explanation.</source>
          <target state="translated">이 구문은 GADT와 관련된 재귀 함수를 정의 할 때 매우 유용 할 수 있습니다 . 자세한 설명 은 섹션 &lt;a href=&quot;gadts#s%3Agadts&quot;&gt;8.10&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="606749beda23122ec62e2057e7b85c14c94a4118" translate="yes" xml:space="preserve">
          <source>This transformation discovers closure variables that are known to be equal to specialised arguments. Such closure variables are replaced by the specialised arguments; the closure variables may then be removed by the &amp;ldquo;removal of unused closure variables&amp;rdquo; pass (see below).</source>
          <target state="translated">이 변환은 특수 인수와 동일한 것으로 알려진 클로저 변수를 발견합니다. 이러한 클로저 변수는 특수 인수로 대체됩니다. 그런 다음 &quot;사용하지 않는 클로저 변수 제거&quot;패스를 통해 클로저 변수를 제거 할 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="a3ca52136f921dd3470ad0eec8da036065e73e98" translate="yes" xml:space="preserve">
          <source>This transformation does not operate if it would cause the closure to contain more than twice as many closure variables as it did beforehand.</source>
          <target state="translated">이 변환은 클로저가 이전에했던 것보다 두 배 이상의 클로저 변수를 포함하게하는 경우 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a28d09c6743f0d934bbb9ee805f4686f7ff260e" translate="yes" xml:space="preserve">
          <source>This transformation is &lt;em&gt;not&lt;/em&gt; enabled by default. It may be enabled using the -unbox-closures flag.</source>
          <target state="translated">이 변환은 기본적으로 활성화되어 &lt;em&gt;있지 않습니다&lt;/em&gt; . -unbox-closures 플래그를 사용하여 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4085b150ab05ea3b51f91b2bd36f0e92e0492fbb" translate="yes" xml:space="preserve">
          <source>This transformation is analogous to the removal of let-expressions whose defining expressions have no effects. It operates instead on symbol bindings, removing those that have no effects.</source>
          <target state="translated">이 변환은 정의 표현식이 효과가없는 let-expression을 제거하는 것과 유사합니다. 대신 심볼 바인딩에서 작동하여 효과가없는 바인딩을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="98eeafe0734234bf6e061a4b30996bb7f31b9996" translate="yes" xml:space="preserve">
          <source>This transformation is coherent with the intended semantics, including side-effects. That is, if the application of optional parameters shall produce side-effects, these are delayed until the received function is really applied to an argument.</source>
          <target state="translated">이 변환은 부작용을 포함하여 의도 된 의미와 일관됩니다. 즉, 선택적 매개 변수의 적용으로 인해 부작용이 발생하면 수신 된 함수가 실제로 인수에 적용될 때까지 지연됩니다.</target>
        </trans-unit>
        <trans-unit id="97f7301c5b5d5afefc26a2bd6bf09c3b5a77941d" translate="yes" xml:space="preserve">
          <source>This transformation is enabled unless -no-unbox-free-vars-of-closures is provided.</source>
          <target state="translated">이 변환은 -no-unbox-free-vars-of-closures가 제공되지 않는 한 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="107da9a0de966e43ce271c3dfca90682878bece5" translate="yes" xml:space="preserve">
          <source>This transformation is enabled unless -no-unbox-specialised-args is provided.</source>
          <target state="translated">이 변환은 -no-unbox-specialised-args가 제공되지 않는 한 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="95f81958a03cd80819ec888b7dadbd9b19a9762f" translate="yes" xml:space="preserve">
          <source>This transformation is only enabled by default for specialised arguments. It may be enabled for all arguments using the -remove-unused-arguments flag.</source>
          <target state="translated">이 변환은 기본적으로 특수 인수에 대해서만 활성화됩니다. -remove-unused-arguments 플래그를 사용하여 모든 인수에 대해 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3540291a552cb80b3485979aeb16719df0b1d80" translate="yes" xml:space="preserve">
          <source>This transformation performs an analysis across the whole compilation unit to determine whether there exist closure variables that are never used. Such closure variables are then eliminated. (Note that this has to be a whole-unit analysis because a projection of a closure variable from some particular closure may have propagated to an arbitrary location within the code due to inlining.)</source>
          <target state="translated">이 변환은 전체 컴파일 단위에 대한 분석을 수행하여 사용되지 않은 클로저 변수가 있는지 여부를 확인합니다. 그런 다음 이러한 클로저 변수는 제거됩니다. (일부 특정 클로저에서 클로저 변수의 투영이 인라인으로 인해 코드 내의 임의의 위치로 전파되었을 수 있기 때문에 이것은 전체 단위 분석이어야합니다.)</target>
        </trans-unit>
        <trans-unit id="1e83b36cd0eeacff2b0fcd7e5886d6aedf97ee77" translate="yes" xml:space="preserve">
          <source>This type allows direct access to raw backtrace slots, without any conversion in an OCaml-usable data-structure.</source>
          <target state="translated">이 유형을 사용하면 OCaml에서 사용할 수있는 데이터 구조의 변환없이 원시 역 추적 슬롯에 직접 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="130aa34f2abb76bf60b32cca15d066255d4d8d30" translate="yes" xml:space="preserve">
          <source>This type allows direct access to raw backtrace slots, without any conversion in an OCaml-usable data-structure. Being process-specific, they must absolutely not be marshalled, and are unsafe to use for this reason (marshalling them may not fail, but un-marshalling and using the result will result in undefined behavior).</source>
          <target state="translated">이 유형을 사용하면 OCaml에서 사용할 수있는 데이터 구조의 변환없이 원시 역 추적 슬롯에 직접 액세스 할 수 있습니다. 프로세스별로 다르기 때문에 절대적으로 마샬링되지 않아야하며 이러한 이유로 사용하기에 안전하지 않습니다 (마샬링은 실패하지 않을 수 있지만 마샬링을 해제하고 결과를 사용하면 정의되지 않은 동작이 발생합니다).</target>
        </trans-unit>
        <trans-unit id="a5f42130deca30ae8346b504b0eec48ca9c2365c" translate="yes" xml:space="preserve">
          <source>This type is particularly useful when defining function that can fail in common situations, for instance</source>
          <target state="translated">이 유형은 예를 들어 일반적인 상황에서 실패 할 수있는 기능을 정의 할 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="37b107ea9cfcc09f2b2be2c72335ef153d3c3763" translate="yes" xml:space="preserve">
          <source>This type is used to implement the &lt;a href=&quot;libref/lazy&quot;&gt;Lazy&lt;/a&gt; module. It should not be used directly.</source>
          <target state="translated">이 유형은 &lt;a href=&quot;libref/lazy&quot;&gt;Lazy&lt;/a&gt; 모듈 을 구현하는 데 사용됩니다 . 직접 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f2322d3b9d09a7e2ff55273a1e7e1bf51ca59dec" translate="yes" xml:space="preserve">
          <source>This value controls the GC messages on standard error output. It is a sum of some of the following flags, to print messages on the corresponding events:</source>
          <target state="translated">이 값은 표준 오류 출력에서 ​​GC 메시지를 제어합니다. 해당 이벤트에 메시지를 인쇄하는 것은 다음 플래그 중 일부의 합계입니다.</target>
        </trans-unit>
        <trans-unit id="191b0eb7c35686bcb189014265a40f332069ddbd" translate="yes" xml:space="preserve">
          <source>This way, you can change the meaning of indentation (which can be something else than just printing space characters) and the meaning of new lines opening (which can be connected to any other action needed by the application at hand).</source>
          <target state="translated">이런 식으로 들여 쓰기의 의미 (공백 문자를 인쇄하는 것 이외의 다른 의미 일 수 있음)와 새 줄 열기의 의미 (현재 응용 프로그램에 필요한 다른 작업에 연결할 수 있음)를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee3e48f0f7c49da9ec952c4fe9ffee5be36732e2" translate="yes" xml:space="preserve">
          <source>Those annotations are introduced in the format strings using the &lt;code&gt;@&lt;/code&gt; character. For instance, &lt;code&gt;@&amp;nbsp;&lt;/code&gt; means a space break, &lt;code&gt;@,&lt;/code&gt; means a cut, &lt;code&gt;@[&lt;/code&gt; opens a new box, and &lt;code&gt;@]&lt;/code&gt; closes the last open box.</source>
          <target state="translated">이러한 주석은 &lt;code&gt;@&lt;/code&gt; 문자를 사용하여 형식 문자열에 도입됩니다 . 예를 들어, &lt;code&gt;@&amp;nbsp;&lt;/code&gt; 는 공백 나누기를 의미하고 &lt;code&gt;@,&lt;/code&gt; 는 잘라내기를 의미하고 &lt;code&gt;@[&lt;/code&gt; 는 새 상자를 열고 &lt;code&gt;@]&lt;/code&gt; 는 마지막 열린 상자를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="f0183ff3f98f4e87c7d8f00f861fde047cea5266" translate="yes" xml:space="preserve">
          <source>Those explicit type annotations can in fact be used anywhere. Most of the time they are unnecessary, but they are useful to guide disambiguation, to debug unexpected type errors, or combined with some of the more advanced features of OCaml described in later chapters.</source>
          <target state="translated">이러한 명시 적 유형 주석은 실제로 어디에서나 사용할 수 있습니다. 대부분의 경우 불필요하지만 명확성을 안내하거나 예기치 않은 유형 오류를 디버그하거나 이후 장에서 설명하는 OCaml의 고급 기능 중 일부와 결합하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="19021df6f2a2bbcef0c8a622652f87dbf2d6eed1" translate="yes" xml:space="preserve">
          <source>Though all examples so far were written in purely applicative style, OCaml is also equipped with full imperative features. This includes the usual while and for loops, as well as mutable data structures such as arrays. Arrays are either created by listing semicolon-separated element values between [| and |] brackets, or allocated and initialized with the Array.make function, then filled up later by assignments. For instance, the function below sums two vectors (represented as float arrays) componentwise.</source>
          <target state="translated">지금까지의 모든 예제는 순전히 적용 가능한 스타일로 작성되었지만 OCaml은 완전한 명령형 기능도 갖추고 있습니다. 여기에는 일반적인 while 및 for 루프는 물론 배열과 같은 변경 가능한 데이터 구조가 포함됩니다. 배열은 [| 및 |] 대괄호 또는 Array.make 함수로 할당 및 초기화 된 다음 나중에 할당으로 채워집니다. 예를 들어 아래 함수는 구성 요소별로 두 벡터 (부동 배열로 표시됨)를 더합니다.</target>
        </trans-unit>
        <trans-unit id="7863f7503e5377891a3b7452c7d6cc377d443fe7" translate="yes" xml:space="preserve">
          <source>Thread</source>
          <target state="translated">Thread</target>
        </trans-unit>
        <trans-unit id="442734960d3874aabb05e4c0f886a1d056b06211" translate="yes" xml:space="preserve">
          <source>Thread creation and termination</source>
          <target state="translated">스레드 생성 및 종료</target>
        </trans-unit>
        <trans-unit id="12f5360fcdde9c0092d8683e0065551e707bd34e" translate="yes" xml:space="preserve">
          <source>Thread-compatible system calls.</source>
          <target state="translated">스레드 호환 시스템 호출.</target>
        </trans-unit>
        <trans-unit id="2045ffa4a6ae2e8ac2ea21859b137e4ac2c45ee5" translate="yes" xml:space="preserve">
          <source>ThreadUnix</source>
          <target state="translated">ThreadUnix</target>
        </trans-unit>
        <trans-unit id="013b2a2d89313d1cae51597fa10d83179b049eb7" translate="yes" xml:space="preserve">
          <source>Three-dimensional arrays</source>
          <target state="translated">3 차원 배열</target>
        </trans-unit>
        <trans-unit id="eade1edda0a702cf28e0ef4fd84c23f49efcdfd9" translate="yes" xml:space="preserve">
          <source>Three-dimensional arrays.</source>
          <target state="translated">3 차원 배열.</target>
        </trans-unit>
        <trans-unit id="d763c9a3cec94432c50184761fc6f2428e98860e" translate="yes" xml:space="preserve">
          <source>Three-dimensional arrays. The &lt;code&gt;Array3&lt;/code&gt; structure provides operations similar to those of &lt;a href=&quot;bigarray.genarray&quot;&gt;&lt;code&gt;Bigarray.Genarray&lt;/code&gt;&lt;/a&gt;, but specialized to the case of three-dimensional arrays.</source>
          <target state="translated">3 차원 배열. &lt;code&gt;Array3&lt;/code&gt; 의 구조와 유사한 동작 제공 &lt;a href=&quot;bigarray.genarray&quot;&gt; &lt;code&gt;Bigarray.Genarray&lt;/code&gt; 을&lt;/a&gt; 하지만, 입체 배열의 경우에 전문화.</target>
        </trans-unit>
        <trans-unit id="0398dff7b2f64839c1ab8aac932358f9c7ab5983" translate="yes" xml:space="preserve">
          <source>Thus, semantic tag handling is in some sense transparent to pretty-printing and does not interfere with usual indentation. Hence, a single pretty-printing routine can output both simple 'verbatim' material or richer decorated output depending on the treatment of tags. By default, tags are not active, hence the output is not decorated with tag information. Once &lt;code&gt;set_tags&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the pretty-printer engine honors tags and decorates the output accordingly.</source>
          <target state="translated">따라서 의미 론적 태그 처리는 어떤 의미에서는 pretty-printing에 투명하며 일반적인 들여 쓰기를 방해하지 않습니다. 따라서 단일 예쁜 인쇄 루틴은 태그 처리에 따라 단순한 'verbatim'자료 또는 더 풍부한 데코 레이팅 된 출력을 모두 출력 할 수 있습니다. 기본적으로 태그는 활성화되지 않으므로 출력에 태그 정보가 표시되지 않습니다. &lt;code&gt;set_tags&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 pretty-printer 엔진이 태그를 인식하고 그에 따라 출력을 장식합니다.</target>
        </trans-unit>
        <trans-unit id="6c82e6dd86807ee3db07e3c82bec1ae1ce00b08b" translate="yes" xml:space="preserve">
          <source>Time</source>
          <target state="translated">Time</target>
        </trans-unit>
        <trans-unit id="a6a4546fd81b122915404e74cff9ee54a97e6c89" translate="yes" xml:space="preserve">
          <source>Time functions</source>
          <target state="translated">시간 함수</target>
        </trans-unit>
        <trans-unit id="d4c45de0fe64ac43c72a798c67faaadadfaa1b90" translate="yes" xml:space="preserve">
          <source>Timeout</source>
          <target state="translated">Timeout</target>
        </trans-unit>
        <trans-unit id="41bea1307711e3db755e8948c9ec2940bd8e5a31" translate="yes" xml:space="preserve">
          <source>Timeout for input operations</source>
          <target state="translated">입력 작업 시간 초과</target>
        </trans-unit>
        <trans-unit id="14a1cbb733d9363c6f97fb603ebe07c1187f0c4b" translate="yes" xml:space="preserve">
          <source>Timeout for output operations</source>
          <target state="translated">출력 작업 시간 초과</target>
        </trans-unit>
        <trans-unit id="79fb3076dc75c83c83101f40598cc392db271b82" translate="yes" xml:space="preserve">
          <source>Timeout in cpu time</source>
          <target state="translated">CPU 시간의 제한 시간</target>
        </trans-unit>
        <trans-unit id="bab4ed36a26f207c2e296f6a9bb7588c6211437f" translate="yes" xml:space="preserve">
          <source>Timeout in virtual time</source>
          <target state="translated">가상 시간의 제한 시간</target>
        </trans-unit>
        <trans-unit id="088594bde4f110fe47b51096bee5193b9d4cffe2" translate="yes" xml:space="preserve">
          <source>To adjust automatically the dimensions of the Bigarray to the actual size of the file, the major dimension (that is, the first dimension for an array with C layout, and the last dimension for an array with Fortran layout) can be given as &lt;code&gt;-1&lt;/code&gt;. &lt;code&gt;Genarray.map_file&lt;/code&gt; then determines the major dimension from the size of the file. The file must contain an integral number of sub-arrays as determined by the non-major dimensions, otherwise &lt;code&gt;Failure&lt;/code&gt; is raised.</source>
          <target state="translated">Bigarray의 크기를 파일의 실제 크기로 자동 조정하기 위해 주요 차원 (즉, C 레이아웃이있는 배열의 첫 번째 차원 및 Fortran 레이아웃이있는 배열의 마지막 차원)을 &lt;code&gt;-1&lt;/code&gt; 로 지정할 수 있습니다. . &lt;code&gt;Genarray.map_file&lt;/code&gt; 다음 Genarray.map_file 은 파일 크기에서 주요 치수를 결정합니다. 파일에는 비 주요 차원에 의해 결정된 정수 하위 배열이 포함되어야합니다 . 그렇지 않으면 &lt;code&gt;Failure&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a0661a33ab380eb57561703bce19cb91f7cdd834" translate="yes" xml:space="preserve">
          <source>To allow splitting long string literals across lines, the sequence \newlinespaces-or-tabs (a backslash at the end of a line followed by any number of spaces and horizontal tabulations at the beginning of the next line) is ignored inside string literals.</source>
          <target state="translated">긴 문자열 리터럴을 여러 줄로 분할 할 수 있도록 문자열 리터럴 내에서 \ newlinespaces-or-tabs 시퀀스 (줄 끝의 백 슬래시 뒤에 다음 줄의 시작 부분에 임의의 수의 공백 및 가로 표)가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="307acf24c4315e13fca20cd97aee6950796edc41" translate="yes" xml:space="preserve">
          <source>To avoid ambiguities, naming labels in expressions cannot just be defined syntactically as the sequence of the three tokens ~, &lt;a href=&quot;#ident&quot;&gt;ident&lt;/a&gt; and :, and have to be defined at the lexical level.</source>
          <target state="translated">모호함을 피하기 위해 표현식의 이름 지정 레이블은 ~, &lt;a href=&quot;#ident&quot;&gt;ident&lt;/a&gt; 및 : 세 개의 토큰 시퀀스로 구문 적으로 정의 할 수 없으며 어휘 수준에서 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e6b4ed52355b5293c6127fa5925601acaeaf11e" translate="yes" xml:space="preserve">
          <source>To build the whole program, just invoke the C compiler as follows:</source>
          <target state="translated">전체 프로그램을 빌드하려면 다음과 같이 C 컴파일러를 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="c7c213abd6a15163ea6d392abe4c8d900d2d422d" translate="yes" xml:space="preserve">
          <source>To circumvent these dual difficulties, the type checker considers that any value returned by a function might rely on persistent mutable states behind the scene and should be given a weak type. This restriction on the type of mutable values and the results of function application is called the value restriction. Note that this value restriction is conservative: there are situations where the value restriction is too cautious and gives a weak type to a value that could be safely generalized to a polymorphic type:</source>
          <target state="translated">이러한 이중 문제를 피하기 위해 유형 검사기는 함수가 반환하는 모든 값이 씬 뒤에서 지속적으로 변경 가능한 상태에 의존 할 수 있으며 약한 유형을 제공해야한다고 간주합니다. 변경 가능한 값의 유형과 함수 적용 결과에 대한 이러한 제한을 값 제한이라고합니다. 이 값 제한은 보수적입니다. 값 제한이 너무 조심스럽고 다형성 유형으로 안전하게 일반화 될 수있는 값에 약한 유형을 제공하는 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dfd9516db0a5f37b1ad909f49077e73f5c3d083" translate="yes" xml:space="preserve">
          <source>To compile and link this program, run:</source>
          <target state="translated">이 프로그램을 컴파일하고 링크하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="bde604309077235c564ef6bb992b73c29478ef2a" translate="yes" xml:space="preserve">
          <source>To compile everything, execute:</source>
          <target state="translated">모든 것을 컴파일하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="463481e8191305706647c8346e602fd42723a3d3" translate="yes" xml:space="preserve">
          <source>To compile this interface:</source>
          <target state="translated">이 인터페이스를 컴파일하려면 :</target>
        </trans-unit>
        <trans-unit id="32b3ccadf9cce9fa5117bc1b3bfac7cb3a873f7e" translate="yes" xml:space="preserve">
          <source>To define arithmetic operations for the number type, we use pattern-matching on the two numbers involved:</source>
          <target state="translated">숫자 유형에 대한 산술 연산을 정의하기 위해 관련된 두 숫자에 대해 패턴 일치를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="327cad239718bab706e248d624ccb7ecb21c15f6" translate="yes" xml:space="preserve">
          <source>To dynamically link C code with OCaml code, the C code must first be compiled into a shared library (under Unix) or DLL (under Windows). This involves 1- compiling the C files with appropriate C compiler flags for producing position-independent code (when required by the operating system), and 2- building a shared library from the resulting object files. The resulting shared library or DLL file must be installed in a place where ocamlrun can find it later at program start-up time (see section &lt;a href=&quot;runtime#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt;). Finally (step 3), execute the ocamlc command with</source>
          <target state="translated">C 코드를 OCaml 코드와 동적으로 연결하려면 먼저 C 코드를 공유 라이브러리 (Unix에서) 또는 DLL (Windows에서)로 컴파일해야합니다. 여기에는 1- 위치 독립적 코드를 생성하기위한 적절한 C 컴파일러 플래그로 C 파일 컴파일 (운영 체제에서 요구하는 경우) 및 2- 결과 개체 파일에서 공유 라이브러리 빌드가 포함됩니다. 결과 공유 라이브러리 또는 DLL 파일은 ocamlrun이 나중에 프로그램 시작시 찾을 수있는 위치에 설치해야합니다 (섹션 &lt;a href=&quot;runtime#s%3Aocamlrun-dllpath&quot;&gt;11.3&lt;/a&gt; 참조 ). 마지막으로 (3 단계) 다음을 사용하여 ocamlc 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="fb4a49b6e92a580be3d1ce7213ac6573529cfb93" translate="yes" xml:space="preserve">
          <source>To each element kind is associated an OCaml type, which is the type of OCaml values that can be stored in the Bigarray or read back from it.</source>
          <target state="translated">각 요소 종류는 Bigarray에 저장하거나 다시 읽을 수있는 OCaml 값의 유형 인 OCaml 유형과 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="a7902cf653d3b6806a962d736420aac3556c0af2" translate="yes" xml:space="preserve">
          <source>To each element kind is associated an OCaml type, which is the type of OCaml values that can be stored in the Bigarray or read back from it. This type is not necessarily the same as the type of the array elements proper: for instance, a Bigarray whose elements are of kind &lt;code&gt;float32_elt&lt;/code&gt; contains 32-bit single precision floats, but reading or writing one of its elements from OCaml uses the OCaml type &lt;code&gt;float&lt;/code&gt;, which is 64-bit double precision floats.</source>
          <target state="translated">각 요소 종류는 Bigarray에 저장하거나 다시 읽을 수있는 OCaml 값의 유형 인 OCaml 유형과 연관됩니다. 이 유형은 반드시 적절한 배열의 요소의 형태와 동일하지 않다 : 예를 들어, 요소가 종으로되는 Bigarray &lt;code&gt;float32_elt&lt;/code&gt; 32- 비트 단일 정밀도 수레를 포함하지만, 판독 또는 OCaml의 행의 요소 중 하나를 기입하면 OCaml의 타입 사용 &lt;code&gt;float&lt;/code&gt; , 64 비트 배정 밀도 부동 소수점입니다.</target>
        </trans-unit>
        <trans-unit id="ec8d6d0f0d08a9fa9eb4faaf97e838ad337fba45" translate="yes" xml:space="preserve">
          <source>To facilitate interoperability with existing C and Fortran code, this library supports two different memory layouts for Bigarrays, one compatible with the C conventions, the other compatible with the Fortran conventions.</source>
          <target state="translated">기존 C 및 Fortran 코드와의 상호 운용성을 용이하게하기 위해이 라이브러리는 Bigarray에 대해 두 가지 다른 메모리 레이아웃을 지원합니다. 하나는 C 규칙과 호환되고 다른 하나는 Fortran 규칙과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="d9440719805fd4d3883c45311f6d371026f97469" translate="yes" xml:space="preserve">
          <source>To fuzz a large system without modifying build tools, OCaml&amp;rsquo;s configure script also accepts the afl-instrument option. If OCaml is configured with afl-instrument, then all programs compiled by ocamlopt will be instrumented.</source>
          <target state="translated">빌드 도구를 수정하지 않고 대규모 시스템을 퍼징하기 위해 OCaml의 구성 스크립트는 afl-instrument 옵션도 허용합니다. OCaml이 afl-instrument로 구성된 경우 ocamlopt에 의해 컴파일 된 모든 프로그램이 계측됩니다.</target>
        </trans-unit>
        <trans-unit id="d49cf83522e4dd02edaed17398bc3794092a3e6c" translate="yes" xml:space="preserve">
          <source>To generate a bytecode executable that runs on this runtime system, do:</source>
          <target state="translated">이 런타임 시스템에서 실행되는 바이트 코드 실행 파일을 생성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a7d984b677b59e1ba119d9e288d010f2047bf07c" translate="yes" xml:space="preserve">
          <source>To handle custom tags, you need to define a custom generator, as explained in section &lt;a href=&quot;#ss%3Aocamldoc-handling-custom-tags&quot;&gt;16.3.2&lt;/a&gt;.</source>
          <target state="translated">사용자 지정 태그를 처리하려면 섹션 &lt;a href=&quot;#ss%3Aocamldoc-handling-custom-tags&quot;&gt;16.3.2에&lt;/a&gt; 설명 된대로 사용자 지정 생성기를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a226b13d5aac9e91dcb364c97e1b727eb95a790b" translate="yes" xml:space="preserve">
          <source>To help you diagnose this error, run your program with the -v option to ocamlrun, or with the OCAMLRUNPARAM environment variable set to v=63. If it displays lots of &amp;ldquo;Growing stack&amp;hellip;&amp;rdquo; messages, this is probably a looping recursive function. If it displays lots of &amp;ldquo;Growing heap&amp;hellip;&amp;rdquo; messages, with the heap size growing slowly, this is probably an attempt to construct a data structure with too many (infinitely many?) cells. If it displays few &amp;ldquo;Growing heap&amp;hellip;&amp;rdquo; messages, but with a huge increment in the heap size, this is probably an attempt to build an excessively large array, string or byte sequence.</source>
          <target state="translated">이 오류를 진단하려면 ocamlrun에 -v 옵션을 사용하거나 OCAMLRUNPARAM 환경 변수를 v = 63으로 설정하여 프로그램을 실행하십시오. &quot;Growing stack&amp;hellip;&quot;메시지가 많이 표시되는 경우 이는 반복되는 재귀 함수일 수 있습니다. &quot;Growing heap&amp;hellip;&quot;메시지가 많이 표시되고 힙 크기가 느리게 증가하면 셀이 너무 많은 (무한대로 많은?) 데이터 구조를 구성하려는 시도 일 수 있습니다. &quot;Growing heap&amp;hellip;&quot;메시지가 거의 표시되지 않지만 힙 크기가 크게 증가하는 경우 이는 지나치게 큰 배열, 문자열 또는 바이트 시퀀스를 빌드하려는 시도 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2372771b07a4d167928768e2a883bc383b6e0f5" translate="yes" xml:space="preserve">
          <source>To illustrate the rules above, here is a C function that builds and returns a list containing the two integers given as parameters. First, we write it using the simplified allocation functions:</source>
          <target state="translated">위의 규칙을 설명하기 위해 다음은 매개 변수로 제공된 두 정수를 포함하는 목록을 작성하고 리턴하는 C 함수입니다. 먼저 단순화 된 할당 함수를 사용하여 작성합니다.</target>
        </trans-unit>
        <trans-unit id="f9316bbb60ea8ce0b1c90bf6112d6e8ade80ba7a" translate="yes" xml:space="preserve">
          <source>To implement these functions, we just have to provide the stub code; the core functions are already implemented in the curses library. The stub code file, curses_stubs.c, looks like this:</source>
          <target state="translated">이러한 기능을 구현하려면 스텁 코드 만 제공하면됩니다. 핵심 기능은 이미 curses 라이브러리에 구현되어 있습니다. 스텁 코드 파일 인 curses_stubs.c는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b952e965e16326f8fe35cdcad00515932cf1d1ca" translate="yes" xml:space="preserve">
          <source>To keep the generated automata small, rewrite those definitions with only one general &amp;ldquo;identifier&amp;rdquo; rule, followed by a hashtable lookup to separate keywords from identifiers:</source>
          <target state="translated">생성 된 자동 장치를 작게 유지하려면 일반 &quot;식별자&quot;규칙을 하나만 사용하여 해당 정의를 다시 작성하고 해시 테이블 조회를 통해 식별자에서 키워드를 분리합니다.</target>
        </trans-unit>
        <trans-unit id="a23cb4ea2cf58c9454eccc5177ac6f043e990101" translate="yes" xml:space="preserve">
          <source>To keep the relaxed value restriction, we need to declare the abstract type 'a COLLECTION.t as covariant in 'a:</source>
          <target state="translated">완화 된 값 제한을 유지하려면 추상 유형 'a COLLECTION.t를'a : '의 공변으로 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="b5d11a9162bbc283c3d1d5bcb248f5b1b6ede824" translate="yes" xml:space="preserve">
          <source>To keep track of operations, we extend the class with a mutable field history and a private method trace to add an operation in the log. Then each method to be traced is redefined.</source>
          <target state="translated">작업을 추적하기 위해 변경 가능한 필드 기록 및 개인 메서드 추적을 사용하여 클래스를 확장하여 로그에 작업을 추가합니다. 그런 다음 추적 할 각 방법이 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="48e8a007425ee0f5fee02a060cc2a2384efe46e2" translate="yes" xml:space="preserve">
          <source>To know which methods to override and/or which methods are available, have a look at the different base implementations, depending on the kind of generator you are extending :</source>
          <target state="translated">재정의 할 메서드 및 / 또는 사용 가능한 메서드를 확인하려면 확장하는 생성기의 종류에 따라 다른 기본 구현을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="bff8eee99072881c7dd4af3c5fa1af20b5deb63a" translate="yes" xml:space="preserve">
          <source>To link in &amp;ldquo;custom runtime&amp;rdquo; mode, execute the ocamlc command with:</source>
          <target state="translated">&quot;사용자 지정 런타임&quot;모드에서 연결하려면 다음을 사용하여 ocamlc 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="2dc12bb0039399b2211b5edf87b77c3207cbfd57" translate="yes" xml:space="preserve">
          <source>To make sure your programs can be compiled in profiling mode, avoid using any identifier that begins with __ocaml_prof.</source>
          <target state="translated">프로그램이 프로파일 링 모드에서 컴파일 될 수 있도록하려면 __ocaml_prof로 시작하는 식별자를 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1c8e4b280c7f58e4764b54d8abccf82639d2ae14" translate="yes" xml:space="preserve">
          <source>To make this even more comfortable, you may use type definitions as abbreviations for or-patterns. That is, if you have defined type myvariant = [`Tag1 of int | `Tag2 of bool], then the pattern #myvariant is equivalent to writing (`Tag1(_ : int) | `Tag2(_ : bool)).</source>
          <target state="translated">이를 더욱 편안하게하기 위해 or- 패턴의 약어로 유형 정의를 사용할 수 있습니다. 즉, type myvariant = [`Tag1 of int | `Tag2 of bool]이면 #myvariant 패턴은 (`Tag1 (_ : int) |`Tag2 (_ : bool))을 쓰는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a622ca9104700efc8eba27769d5e6eccf540e9b" translate="yes" xml:space="preserve">
          <source>To read the byte representation of a marshaled value into a byte sequence, the program needs to read first &lt;a href=&quot;marshal#VALheader_size&quot;&gt;&lt;code&gt;Marshal.header_size&lt;/code&gt;&lt;/a&gt; bytes into the sequence, then determine the length of the remainder of the representation using &lt;a href=&quot;marshal#VALdata_size&quot;&gt;&lt;code&gt;Marshal.data_size&lt;/code&gt;&lt;/a&gt;, make sure the sequence is large enough to hold the remaining data, then read it, and finally call &lt;a href=&quot;marshal#VALfrom_bytes&quot;&gt;&lt;code&gt;Marshal.from_bytes&lt;/code&gt;&lt;/a&gt; to unmarshal the value.</source>
          <target state="translated">마샬링 된 값의 바이트 표현을 바이트 시퀀스로 읽으려면 프로그램이 먼저 &lt;a href=&quot;marshal#VALheader_size&quot;&gt; &lt;code&gt;Marshal.header_size&lt;/code&gt; &lt;/a&gt; 바이트를 시퀀스로 읽어 들인 다음 &lt;a href=&quot;marshal#VALdata_size&quot;&gt; &lt;code&gt;Marshal.data_size&lt;/code&gt; &lt;/a&gt; 를 사용하여 표현의 나머지 길이를 결정 하고 시퀀스가 ​​충분히 큰지 확인해야합니다. 나머지 데이터를 보유하고 읽은 다음 마지막으로 &lt;a href=&quot;marshal#VALfrom_bytes&quot;&gt; &lt;code&gt;Marshal.from_bytes&lt;/code&gt; &lt;/a&gt; 를 호출 하여 값을 비 정렬 화합니다.</target>
        </trans-unit>
        <trans-unit id="c72d4392ca2173a1c9eef1f69d8ad84c58d851ec" translate="yes" xml:space="preserve">
          <source>To reason about the use of &lt;code&gt;unsafe_to_string&lt;/code&gt;, it is convenient to consider an &quot;ownership&quot; discipline. A piece of code that manipulates some data &quot;owns&quot; it; there are several disjoint ownership modes, including:</source>
          <target state="translated">&lt;code&gt;unsafe_to_string&lt;/code&gt; 사용에 대해 추론하려면 &quot;소유권&quot;규율을 고려하는 것이 편리합니다. 일부 데이터를 조작하는 코드는이를 &quot;소유&quot;합니다. 다음을 포함하여 몇 가지 분리 된 소유권 모드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a7157f5deddeacc7b51617138d7fd940b256e41" translate="yes" xml:space="preserve">
          <source>To solve our problem, we can therefore use either the record solution:</source>
          <target state="translated">따라서 문제를 해결하기 위해 레코드 솔루션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4019cbcbaea339fe27aab76ebea9127bab9094f" translate="yes" xml:space="preserve">
          <source>To solve this error, it is enough to add an explicit type annotation to specify the type at declaration time:</source>
          <target state="translated">이 오류를 해결하려면 명시 적 유형 주석을 추가하여 선언시 유형을 지정하는 것으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="f25f95dc627a388c949e54ad1e4876e37a5fdec0" translate="yes" xml:space="preserve">
          <source>To speak in an &amp;ldquo;object-oriented&amp;rdquo; way, one can consider that each function has a main argument, its &lt;em&gt;object&lt;/em&gt;, and other arguments related with its action, the &lt;em&gt;parameters&lt;/em&gt;. To permit the combination of functions through functionals in commuting label mode, the object will not be labeled. Its role is clear from the function itself. The parameters are labeled with names reminding of their nature or their role. The best labels combine nature and role. When this is not possible the role is to be preferred, since the nature will often be given by the type itself. Obscure abbreviations should be avoided.</source>
          <target state="translated">&quot;객체 지향&quot;방식으로 말하려면 각 함수에 주요 인수, &lt;em&gt;객체&lt;/em&gt; 및 동작과 관련된 기타 인수 인 &lt;em&gt;매개 변수&lt;/em&gt; 가 있다고 생각할 수 있습니다 . 통근 레이블 모드에서 기능을 통한 기능 조합을 허용하기 위해 개체에 레이블이 지정되지 않습니다. 그 역할은 기능 자체에서 분명합니다. 매개 변수는 그 특성이나 역할을 상기시키는 이름으로 레이블이 지정됩니다. 최고의 레이블은 자연과 역할을 결합합니다. 이것이 가능하지 않은 경우, 성격은 종종 유형 자체에 의해 주어지기 때문에 역할이 선호됩니다. 모호한 약어는 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="387ff33570962c3e8b5dedb0a388bccd5c1fb297" translate="yes" xml:space="preserve">
          <source>To use Spacetime it is necessary to use an OCaml compiler that was configured with the -spacetime option. It is not possible to select Spacetime on a per-source-file basis or for a subset of files in a project; all files involved in the executable being profiled must be built with the Spacetime compiler. Only native code compilation is supported (not bytecode).</source>
          <target state="translated">Spacetime을 사용하려면 -spacetime 옵션으로 구성된 OCaml 컴파일러를 사용해야합니다. 소스 파일별로 또는 프로젝트의 파일 하위 집합에 대해 Spacetime을 선택할 수 없습니다. 프로파일 링되는 실행 파일과 관련된 모든 파일은 Spacetime 컴파일러로 빌드해야합니다. 네이티브 코드 컴파일 만 지원됩니다 (바이트 코드 아님).</target>
        </trans-unit>
        <trans-unit id="ed32f07860215af085ff436b7b7306a6815a9b78" translate="yes" xml:space="preserve">
          <source>To use the Flambda optimisers it is necessary to pass the -flambda option to the OCaml configure script. (There is no support for a single compiler that can operate in both Flambda and non-Flambda modes.) Code compiled with Flambda cannot be linked into the same program as code compiled without Flambda. Attempting to do this will result in a compiler error.</source>
          <target state="translated">Flambda 옵티 마이저를 사용하려면 -flambda 옵션을 OCaml 구성 스크립트에 전달해야합니다. (Flambda 및 비 Flambda 모드 모두에서 작동 할 수있는 단일 컴파일러는 지원되지 않습니다.) Flambda로 컴파일 된 코드는 Flambda없이 컴파일 된 코드와 동일한 프로그램에 링크 될 수 없습니다. 이렇게하면 컴파일러 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="25cebac05e12b33d1c5325eeaabd74f6b15cffcb" translate="yes" xml:space="preserve">
          <source>To use the functions in this module you must:</source>
          <target state="translated">이 모듈의 기능을 사용하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a3b40c35ac9b4dbb1547ab6397d847d576919f6" translate="yes" xml:space="preserve">
          <source>To use this function, one can wrap the Set.Make functor:</source>
          <target state="translated">이 함수를 사용하려면 Set.Make 펑터를 래핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e279465e252c0b80c2d1a6c8e50d696d2db937f5" translate="yes" xml:space="preserve">
          <source>To write C code that operates on OCaml values, the following include files are provided:</source>
          <target state="translated">OCaml 값에서 작동하는 C 코드를 작성하기 위해 다음 포함 파일이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="659d8a056102ffd377f0cdfc671961480711f61a" translate="yes" xml:space="preserve">
          <source>Together, the relaxed value restriction and type parameter covariance help to avoid eta-expansion in many situations.</source>
          <target state="translated">완화 된 값 제한 및 유형 매개 변수 공분산을 함께 사용하면 많은 상황에서 eta 확장을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56dbc78473450158f36bd54d125933d056ecd869" translate="yes" xml:space="preserve">
          <source>Tokens and rules have precedences. By default, the precedence of a rule is the precedence of its rightmost terminal. You can override this default by using the %prec directive in the rule.</source>
          <target state="translated">토큰과 규칙에는 우선 순위가 있습니다. 기본적으로 규칙의 우선 순위는 가장 오른쪽 터미널의 우선 순위입니다. 규칙에서 % prec 지시문을 사용하여이 기본값을 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e0d2eef3cc8719301cd02a8aeecb9e956e88cf1" translate="yes" xml:space="preserve">
          <source>Too many levels of symbolic links</source>
          <target state="translated">너무 많은 수준의 심볼릭 링크</target>
        </trans-unit>
        <trans-unit id="4113b4c9ebd053469430304ab17dc16ea1d01df9" translate="yes" xml:space="preserve">
          <source>Too many links</source>
          <target state="translated">너무 많은 링크</target>
        </trans-unit>
        <trans-unit id="5736e6c11ff6d9830fab68fdeb2e9c96cdae31d6" translate="yes" xml:space="preserve">
          <source>Too many open files by the process</source>
          <target state="translated">프로세스에서 열린 파일이 너무 많습니다.</target>
        </trans-unit>
        <trans-unit id="529311e8fdf6ab2db0e809d7fbb676ae1d82a50d" translate="yes" xml:space="preserve">
          <source>Too many open files in the system</source>
          <target state="translated">시스템에 열려있는 파일이 너무 많습니다.</target>
        </trans-unit>
        <trans-unit id="282e2b703da2ac14021b09f04b30fd7f814e033a" translate="yes" xml:space="preserve">
          <source>Too many references: can't splice</source>
          <target state="translated">너무 많은 참조 : 연결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="15521e66130383b230f739bb2fc49edfc0a24250" translate="yes" xml:space="preserve">
          <source>Toplevel</source>
          <target state="translated">Toplevel</target>
        </trans-unit>
        <trans-unit id="52271cb5a0a7ab67a42426df16b8f5309e544d7d" translate="yes" xml:space="preserve">
          <source>Toplevel let-expressions may be lifted to symbol bindings to ensure that the corresponding bound variables are not captured by closures. If the defining expression of a given binding is found to be constant, it is bound as such (the technical term is a &lt;em&gt;let-symbol&lt;/em&gt; binding).</source>
          <target state="translated">최상위 let-expression은 해당 바인딩 된 변수가 클로저에 의해 캡처되지 않도록하기 위해 심볼 바인딩으로 들어 올릴 수 있습니다. 지정된 바인딩의 정의 표현이 상수 인 것으로 확인되면 그대로 바인딩됩니다 (기술 용어는 &lt;em&gt;let-symbol&lt;/em&gt; 바인딩).</target>
        </trans-unit>
        <trans-unit id="a44cf452ae377637373f10a091314197af5f0b33" translate="yes" xml:space="preserve">
          <source>Toplevel phrases can refer to identifiers defined in compilation units with the same mechanisms as for separately compiled units: either by using qualified names (Modulename.localname), or by using the open construct and unqualified names (see section &lt;a href=&quot;names#s%3Anames&quot;&gt;7.3&lt;/a&gt;).</source>
          <target state="translated">최상위 구문은 정규화 된 이름 (Modulename.localname)을 사용하거나 개방형 구조와 정규화되지 않은 이름을 사용하여 (섹션 &lt;a href=&quot;names#s%3Anames&quot;&gt;7.3&lt;/a&gt; 참조) 별도로 컴파일 된 단위와 동일한 메커니즘을 사용하여 컴파일 단위에 정의 된 식별자를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06d983275acca4ebd956f4ca99271a34f2702b6e" translate="yes" xml:space="preserve">
          <source>Total ordering between maps.</source>
          <target state="translated">지도 간의 총 주문.</target>
        </trans-unit>
        <trans-unit id="0d503224bdd1f64388674e9ce0a963f9f4e37ff2" translate="yes" xml:space="preserve">
          <source>Total ordering between maps. The first argument is a total ordering used to compare data associated with equal keys in the two maps.</source>
          <target state="translated">지도 간의 총 주문. 첫 번째 인수는 두 맵에서 동일한 키와 관련된 데이터를 비교하는 데 사용되는 총 순서입니다.</target>
        </trans-unit>
        <trans-unit id="b2d7c3d7b4f4e20c4b6494fc8ea71a5bcb4f2aaf" translate="yes" xml:space="preserve">
          <source>Total ordering between sets.</source>
          <target state="translated">세트 간 총 주문.</target>
        </trans-unit>
        <trans-unit id="4f44baf07265ef300d210f7ea6b516756e51c1c5" translate="yes" xml:space="preserve">
          <source>Total ordering between sets. Can be used as the ordering function for doing sets of sets.</source>
          <target state="translated">세트 간 총 주문. 세트 세트를 수행하기위한 주문 기능으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34336f2b5f5540478a6b0046d27bf02690c7c02c" translate="yes" xml:space="preserve">
          <source>Total size of the major heap, in words.</source>
          <target state="translated">주요 힙의 총 크기 (단어)입니다.</target>
        </trans-unit>
        <trans-unit id="75ce6b1a588e98221c2bce1023520067bc5af6c3" translate="yes" xml:space="preserve">
          <source>Trace/breakpoint trap</source>
          <target state="translated">추적 / 중단 점 트랩</target>
        </trans-unit>
        <trans-unit id="24d86e87d3b5c7cc8eaa531c471cc6fe6401e236" translate="yes" xml:space="preserve">
          <source>Traces generated by the instrumented runtime can be analyzed with tooling available outside of the OCaml distribution.</source>
          <target state="translated">계측 된 런타임에 의해 생성 된 추적은 OCaml 배포 외부에서 사용할 수있는 도구를 사용하여 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68c508431455ff22684105af9cb2ecc131f7e321" translate="yes" xml:space="preserve">
          <source>Tracing</source>
          <target state="translated">Tracing</target>
        </trans-unit>
        <trans-unit id="8a199b624500a34255a39172a77785f3c1196171" translate="yes" xml:space="preserve">
          <source>Transform a list of pairs into a pair of lists: &lt;code&gt;split&amp;nbsp;[(a1,b1);&amp;nbsp;...;&amp;nbsp;(an,bn)]&lt;/code&gt; is &lt;code&gt;([a1;&amp;nbsp;...;&amp;nbsp;an],&amp;nbsp;[b1;&amp;nbsp;...;&amp;nbsp;bn])&lt;/code&gt;.</source>
          <target state="translated">쌍 목록을 목록 쌍으로 변환합니다. &lt;code&gt;split&amp;nbsp;[(a1,b1);&amp;nbsp;...;&amp;nbsp;(an,bn)]&lt;/code&gt; 은 &lt;code&gt;([a1;&amp;nbsp;...;&amp;nbsp;an],&amp;nbsp;[b1;&amp;nbsp;...;&amp;nbsp;bn])&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="32401d5fba7510cc4407d77e41ee1d2a4fb4a675" translate="yes" xml:space="preserve">
          <source>Transform a list of pairs into a pair of lists: &lt;code&gt;split&amp;nbsp;[(a1,b1);&amp;nbsp;...;&amp;nbsp;(an,bn)]&lt;/code&gt; is &lt;code&gt;([a1;&amp;nbsp;...;&amp;nbsp;an],&amp;nbsp;[b1;&amp;nbsp;...;&amp;nbsp;bn])&lt;/code&gt;. Not tail-recursive.</source>
          <target state="translated">쌍 목록을 목록 쌍으로 변환합니다. &lt;code&gt;split&amp;nbsp;[(a1,b1);&amp;nbsp;...;&amp;nbsp;(an,bn)]&lt;/code&gt; 은 &lt;code&gt;([a1;&amp;nbsp;...;&amp;nbsp;an],&amp;nbsp;[b1;&amp;nbsp;...;&amp;nbsp;bn])&lt;/code&gt; 입니다. 꼬리 재귀가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="49a801d0a362583e8d49cf49a6efc625d6c92a83" translate="yes" xml:space="preserve">
          <source>Transform a pair of lists into a list of pairs: &lt;code&gt;combine&amp;nbsp;[a1;&amp;nbsp;...;&amp;nbsp;an]&amp;nbsp;[b1;&amp;nbsp;...;&amp;nbsp;bn]&lt;/code&gt; is &lt;code&gt;[(a1,b1);&amp;nbsp;...;&amp;nbsp;(an,bn)]&lt;/code&gt;.</source>
          <target state="translated">목록 쌍을 쌍 목록으로 변환 : &lt;code&gt;combine&amp;nbsp;[a1;&amp;nbsp;...;&amp;nbsp;an]&amp;nbsp;[b1;&amp;nbsp;...;&amp;nbsp;bn]&lt;/code&gt; 은 &lt;code&gt;[(a1,b1);&amp;nbsp;...;&amp;nbsp;(an,bn)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50dd5a15a0cecf0dd0826019c37ba6dc26f6bc64" translate="yes" xml:space="preserve">
          <source>Traverse the sequence from left to right, combining each element with the accumulator using the given function.</source>
          <target state="translated">주어진 함수를 사용하여 각 요소를 누산기와 결합하여 시퀀스를 왼쪽에서 오른쪽으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="4688d50f3f86cb62a80baee37bcad030269d2b74" translate="yes" xml:space="preserve">
          <source>Traverse the sequence from left to right, combining each element with the accumulator using the given function. The traversal happens immediately and will not terminate on infinite sequences.</source>
          <target state="translated">주어진 함수를 사용하여 각 요소를 누산기와 결합하여 시퀀스를 왼쪽에서 오른쪽으로 이동합니다. 순회는 즉시 발생하며 무한 시퀀스에서 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5951a92d20e1af5270ceec7e9317847694484ddf" translate="yes" xml:space="preserve">
          <source>Treat Ocamldoc warnings as errors.</source>
          <target state="translated">Ocamldoc 경고를 오류로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="417c217dcd227caf02540a67a10ab8cd2a50b328" translate="yes" xml:space="preserve">
          <source>Treat as errors the warnings enabled by the argument and as normal warnings the warnings disabled by the argument.</source>
          <target state="translated">인수에 의해 활성화 된 경고는 오류로 처리되고 인수에 의해 비활성화 된 경고는 일반 경고로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="66debbd01f97db729dc454195e358bf429f9ece9" translate="yes" xml:space="preserve">
          <source>Trigger a minor collection.</source>
          <target state="translated">마이너 컬렉션을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="09b695cc0fd391daf36faf1963153e5b6cb4a3b9" translate="yes" xml:space="preserve">
          <source>Triggering finalization of allocated custom blocks (see section &lt;a href=&quot;#s%3Ac-custom&quot;&gt;20.9&lt;/a&gt;). For example, Stdlib.in_channel and Stdlib.out_channel are represented by custom blocks that enclose file descriptors, which are to be released.</source>
          <target state="translated">할당 된 사용자 지정 블록의 종료를 트리거합니다 (섹션 &lt;a href=&quot;#s%3Ac-custom&quot;&gt;20.9&lt;/a&gt; 참조 ). 예를 들어, Stdlib.in_channel 및 Stdlib.out_channel은 릴리스 될 파일 설명자를 포함하는 사용자 정의 블록으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e6e79023b8ee1b35da3de1efb771fce6d418e7dd" translate="yes" xml:space="preserve">
          <source>Triple the default</source>
          <target state="translated">기본값의 3 배</target>
        </trans-unit>
        <trans-unit id="ed552aedd0ce3f370d321354a40788014425b26f" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;Sys.os_type&amp;nbsp;=&amp;nbsp;&quot;Cygwin&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Sys.os_type&amp;nbsp;=&amp;nbsp;&quot;Cygwin&quot;&lt;/code&gt; 경우 참 입니다.</target>
        </trans-unit>
        <trans-unit id="d2e10371a9b7e6b5bec4cec1afb346e6fcf56c47" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;Sys.os_type&amp;nbsp;=&amp;nbsp;&quot;Unix&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Sys.os_type&amp;nbsp;=&amp;nbsp;&quot;Unix&quot;&lt;/code&gt; 이면 참 입니다.</target>
        </trans-unit>
        <trans-unit id="2c18358e3f16eb9b759e71c30fca9e2c6ee55d3a" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;Sys.os_type&amp;nbsp;=&amp;nbsp;&quot;Win32&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Sys.os_type&amp;nbsp;=&amp;nbsp;&quot;Win32&quot;&lt;/code&gt; 이면 참 입니다.</target>
        </trans-unit>
        <trans-unit id="532fe6ed68fa8e3a71fd02229c84119658bc5ab3" translate="yes" xml:space="preserve">
          <source>Truncate the given floating-point number to an integer.</source>
          <target state="translated">주어진 부동 소수점 숫자를 정수로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="3a10351d651cbeb488e200041e184f6200f9b609" translate="yes" xml:space="preserve">
          <source>Truncate the given floating-point number to an integer. The result is unspecified if the argument is &lt;code&gt;nan&lt;/code&gt; or falls outside the range of representable integers.</source>
          <target state="translated">주어진 부동 소수점 숫자를 정수로 자릅니다. 인수가 &lt;code&gt;nan&lt;/code&gt; 이거나 표현 가능한 정수 범위를 벗어나 면 결과는 지정되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="93981b89548137dc81009ceab881823b9341006a" translate="yes" xml:space="preserve">
          <source>Truncate to 0 length if existing</source>
          <target state="translated">존재하는 경우 길이를 0으로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="7fed15abd46a43c683f271305b8f42f5b17141ef" translate="yes" xml:space="preserve">
          <source>Truncated bytecode file</source>
          <target state="translated">잘린 바이트 코드 파일</target>
        </trans-unit>
        <trans-unit id="5002c1234c7b95d88482d1369e0f6d0a4591c59b" translate="yes" xml:space="preserve">
          <source>Truncates the file corresponding to the given descriptor to the given size.</source>
          <target state="translated">주어진 설명자에 해당하는 파일을 주어진 크기로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="e0347bdb2507eb59f16d15ec102ff4098f3d5b35" translate="yes" xml:space="preserve">
          <source>Truncates the named file to the given size.</source>
          <target state="translated">명명 된 파일을 주어진 크기로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="35c43375c1d65c34fdff7dac4166175da7ec333a" translate="yes" xml:space="preserve">
          <source>Tuples are represented by pointers to blocks, with tag 0.</source>
          <target state="translated">튜플은 태그 0과 함께 블록에 대한 포인터로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4fb08f9372966ada62d75d5d7d46f41e9ec29633" translate="yes" xml:space="preserve">
          <source>Tuples of values are written (v&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip;,v&lt;sub&gt;n&lt;/sub&gt;), standing for the n-tuple of values v&lt;sub&gt;1&lt;/sub&gt; to v&lt;sub&gt;n&lt;/sub&gt;. The current implementation supports tuple of up to 2&lt;sup&gt;22&lt;/sup&gt; &amp;minus; 1 elements (4194303 elements).</source>
          <target state="translated">값의 튜플이 기록되어 (v &lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip;, v &lt;sub&gt;n&lt;/sub&gt; ), 값 v &lt;sub&gt;1&lt;/sub&gt; 에서 v &lt;sub&gt;n의 n-&lt;/sub&gt; 튜플을 나타 냅니다. 현재 구현 된 지지체는 최대 2 터플 &lt;sup&gt;22&lt;/sup&gt; 1 개 요소 (요소 4,194,303) -.</target>
        </trans-unit>
        <trans-unit id="ec1382e4b69cd24377b95330f6e9bb58114f7bac" translate="yes" xml:space="preserve">
          <source>Turn bound checking off for array and string accesses (the v.(i) and s.[i] constructs). Programs compiled with -unsafe are therefore faster, but unsafe: anything can happen if the program accesses an array or string outside of its bounds.</source>
          <target state="translated">배열 및 문자열 액세스 (v. (i) 및 s. [i] 구문)에 대한 경계 검사를 해제합니다. 따라서 -unsafe로 컴파일 된 프로그램은 더 빠르지 만 안전하지 않습니다. 프로그램이 범위를 벗어난 배열이나 문자열에 액세스하면 모든 일이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2a661500df8d1ec062b5d1e38538b3068fc8971" translate="yes" xml:space="preserve">
          <source>Turn bound checking off for array and string accesses (the v.(i) and s.[i] constructs). Programs compiled with -unsafe are therefore faster, but unsafe: anything can happen if the program accesses an array or string outside of its bounds. Additionally, turn off the check for zero divisor in integer division and modulus operations. With -unsafe, an integer division (or modulus) by zero can halt the program or continue with an unspecified result instead of raising a Division_by_zero exception.</source>
          <target state="translated">배열 및 문자열 액세스 (v. (i) 및 s. [i] 구문)에 대한 경계 검사를 해제합니다. 따라서 -unsafe로 컴파일 된 프로그램은 더 빠르지 만 안전하지 않습니다. 프로그램이 범위를 벗어난 배열이나 문자열에 액세스하면 모든 일이 발생할 수 있습니다. 또한 정수 나누기 및 모듈러스 연산에서 제로 제수 검사를 해제합니다. -unsafe를 사용하면 0으로 정수 나누기 (또는 모듈러스)가 프로그램을 중지하거나 Division_by_zero 예외를 발생시키는 대신 지정되지 않은 결과를 계속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9976aabbd5a9c1ab1aeea83f7f9166b0d664e3c3" translate="yes" xml:space="preserve">
          <source>Turn bound checking off for array and string accesses (the v.(i) and s.[i] constructs). Programs compiled with -unsafe are therefore slightly faster, but unsafe: anything can happen if the program accesses an array or string outside of its bounds. Additionally, turn off the check for zero divisor in integer division and modulus operations. With -unsafe, an integer division (or modulus) by zero can halt the program or continue with an unspecified result instead of raising a Division_by_zero exception.</source>
          <target state="translated">배열 및 문자열 액세스 (v. (i) 및 s. [i] 구문)에 대한 경계 검사를 해제합니다. 따라서 -unsafe로 컴파일 된 프로그램은 약간 빠르지 만 안전하지 않습니다. 프로그램이 범위를 벗어난 배열이나 문자열에 액세스하면 모든 일이 발생할 수 있습니다. 또한 정수 나누기 및 모듈러스 연산에서 제로 제수 검사를 해제합니다. -unsafe를 사용하면 0으로 정수 나누기 (또는 모듈러스)가 프로그램을 중지하거나 Division_by_zero 예외를 발생시키는 대신 지정되지 않은 결과를 계속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="711678e3efb5338f51272a8b5178317c676c89f3" translate="yes" xml:space="preserve">
          <source>Two class type definitions match if they have the same type parameters and they expand to matching types.</source>
          <target state="translated">동일한 유형 매개 변수가 있고 일치하는 유형으로 확장되는 경우 두 개의 클래스 유형 정의가 일치합니다.</target>
        </trans-unit>
        <trans-unit id="aa4a19d22a2815840c01d0e4fbe627ac1ec3b2ca" translate="yes" xml:space="preserve">
          <source>Two functions are provided to raise two standard exceptions:</source>
          <target state="translated">두 가지 표준 예외를 발생시키기 위해 두 가지 함수가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="1661242be978210d8d5a1f77691405122d60e821" translate="yes" xml:space="preserve">
          <source>Two implementations of the threads library are available, depending on the capabilities of the operating system:</source>
          <target state="translated">운영 체제의 기능에 따라 스레드 라이브러리의 두 가지 구현을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8cefc13e3d298c2bb25661b6f6aa2482f697297" translate="yes" xml:space="preserve">
          <source>Two labels or constructors of the same name are defined in two mutually recursive types.</source>
          <target state="translated">동일한 이름의 두 레이블 또는 생성자가 두 개의 상호 재귀 유형으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="48d9c23b1cb7383bf898c8101cacf467f4231973" translate="yes" xml:space="preserve">
          <source>Two parameters &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; are said to designate a valid range of &lt;code&gt;s&lt;/code&gt; if &lt;code&gt;len&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;start+len&lt;/code&gt; are valid positions in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">두 개의 매개 변수 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;len&lt;/code&gt; 은 &lt;code&gt;len&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; 이고 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;start+len&lt;/code&gt; 이 &lt;code&gt;s&lt;/code&gt; 에서 유효한 위치 인 경우 &lt;code&gt;s&lt;/code&gt; 의 유효한 범위를 지정한다고합니다 .</target>
        </trans-unit>
        <trans-unit id="d67b45c324770bcbf92f640297940d5a30dc1257" translate="yes" xml:space="preserve">
          <source>Two parameters &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; are said to designate a valid substring of &lt;code&gt;s&lt;/code&gt; if &lt;code&gt;len&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; and &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;start+len&lt;/code&gt; are valid positions in &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">두 개의 매개 변수 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;len&lt;/code&gt; 은 &lt;code&gt;len&amp;nbsp;&amp;gt;=&amp;nbsp;0&lt;/code&gt; 이고 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;start+len&lt;/code&gt; 이 &lt;code&gt;s&lt;/code&gt; 에서 유효한 위치 인 경우 &lt;code&gt;s&lt;/code&gt; 의 유효한 부분 문자열을 지정한다고합니다 .</target>
        </trans-unit>
        <trans-unit id="a1ad4c7ee77f98430fd3a05a3935346ecc6ed421" translate="yes" xml:space="preserve">
          <source>Two syntactic forms are provided to define functions. The first form is introduced by the keyword function:</source>
          <target state="translated">함수를 정의하기 위해 두 가지 구문 형식이 제공됩니다. 첫 번째 형식은 키워드 함수에 의해 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="019322ca2a87bdfa6e229ab6eaabec2277045691" translate="yes" xml:space="preserve">
          <source>Two-dimensional arrays</source>
          <target state="translated">2 차원 배열</target>
        </trans-unit>
        <trans-unit id="6efde7c3ec175b7e2cd302f767b8885955c43c8f" translate="yes" xml:space="preserve">
          <source>Two-dimensional arrays.</source>
          <target state="translated">2 차원 배열.</target>
        </trans-unit>
        <trans-unit id="ea97efc84b08c1dfa5507328a9a5eb75811c2159" translate="yes" xml:space="preserve">
          <source>Two-dimensional arrays. The &lt;code&gt;Array2&lt;/code&gt; structure provides operations similar to those of &lt;a href=&quot;bigarray.genarray&quot;&gt;&lt;code&gt;Bigarray.Genarray&lt;/code&gt;&lt;/a&gt;, but specialized to the case of two-dimensional arrays.</source>
          <target state="translated">2 차원 배열. &lt;code&gt;Array2&lt;/code&gt; 구조와 마찬가지의 동작 제공 &lt;a href=&quot;bigarray.genarray&quot;&gt; &lt;code&gt;Bigarray.Genarray&lt;/code&gt; 을&lt;/a&gt; 하지만, 2 차원 배열의 경우와 전문.</target>
        </trans-unit>
        <trans-unit id="44a966b34064ea2bde71d174110a293dd3641eb6" translate="yes" xml:space="preserve">
          <source>Type abbreviation: an equation =&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;, no representation.</source>
          <target state="translated">유형 약어 : 방정식 = &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; , 표현 없음.</target>
        </trans-unit>
        <trans-unit id="e9c2db94655456061e2fda2d94f1456bf5e6dcae" translate="yes" xml:space="preserve">
          <source>Type abbreviation: an equation, no representation.</source>
          <target state="translated">유형 약어 : 방정식, 표현 없음.</target>
        </trans-unit>
        <trans-unit id="dbd26433f35fa9fba1fb5a1c64fd536c78f13267" translate="yes" xml:space="preserve">
          <source>Type abbreviations are not expanded when determining the arity of a primitive. For instance,</source>
          <target state="translated">프리미티브의 배열을 판별 할 때 유형 약어가 확장되지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6ce1ff79a0b7e3f45e08e886eab851d95ab4453e" translate="yes" xml:space="preserve">
          <source>Type argument &lt;code&gt;'b&lt;/code&gt; is also the type of the first argument given to user's defined printing functions for &lt;code&gt;%a&lt;/code&gt; and &lt;code&gt;%t&lt;/code&gt; conversions, and user's defined reading functions for &lt;code&gt;%r&lt;/code&gt; conversion.</source>
          <target state="translated">유형 인수 &lt;code&gt;'b&lt;/code&gt; 는 또한 &lt;code&gt;%a&lt;/code&gt; 및 &lt;code&gt;%t&lt;/code&gt; 변환에 대해 사용자가 정의한 인쇄 함수에 제공되는 첫 번째 인수의 유형이며 &lt;code&gt;%r&lt;/code&gt; 변환에 대해 사용자가 정의한 읽기 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="ebbbc6fe5700486ef983078c89b775200e1dfb7c" translate="yes" xml:space="preserve">
          <source>Type constraint on GADT type declaration.</source>
          <target state="translated">GADT 유형 선언에 대한 유형 제약.</target>
        </trans-unit>
        <trans-unit id="d901f4220b65f3d70d012f9e484a31bb0b370e19" translate="yes" xml:space="preserve">
          <source>Type constructor application</source>
          <target state="translated">유형 생성자 응용 프로그램</target>
        </trans-unit>
        <trans-unit id="644e74ab904e55997d610fce5e77162948201c5e" translate="yes" xml:space="preserve">
          <source>Type constructors</source>
          <target state="translated">유형 생성자</target>
        </trans-unit>
        <trans-unit id="008b7ad7f73c68a43133ccff9ec196e28074c36f" translate="yes" xml:space="preserve">
          <source>Type constructors with no parameter, as in &lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt;, are type expressions.</source>
          <target state="translated">&lt;a href=&quot;names#typeconstr&quot;&gt;typeconstr&lt;/a&gt; 에서와 같이 매개 변수가없는 유형 생성자 는 유형 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="41e19918330a4b7e92b3dee85f135d9b90408d4a" translate="yes" xml:space="preserve">
          <source>Type declaration defining a new &amp;rsquo;()&amp;rsquo; constructor.</source>
          <target state="translated">새로운 '()'생성자를 정의하는 타입 선언.</target>
        </trans-unit>
        <trans-unit id="383e22354516abb8dd98b4675030118fe6e23fbe" translate="yes" xml:space="preserve">
          <source>Type definitions are introduced by the type keyword, and consist in one or several simple definitions, possibly mutually recursive, separated by the and keyword. Each simple definition defines one type constructor.</source>
          <target state="translated">유형 정의는 유형 키워드에 의해 도입되며 하나 또는 여러 개의 단순 정의로 구성되며, 상호 재귀적일 수 있으며 및 키워드로 구분됩니다. 각 단순 정의는 하나의 유형 생성자를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="80012d2e3c018c87cbaf804ec7fb6ccc51f86ae0" translate="yes" xml:space="preserve">
          <source>Type definitions bind type constructors to data types: either variant types, record types, type abbreviations, or abstract data types. They also bind the value constructors and record fields associated with the definition.</source>
          <target state="translated">유형 정의는 유형 생성자를 데이터 유형 (변형 유형, 레코드 유형, 유형 약어 또는 추상 데이터 유형)에 바인딩합니다. 또한 정의와 관련된 값 생성자 및 레코드 필드를 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="7cad2e5ed527706c404fda008c0fbc43d1739bde" translate="yes" xml:space="preserve">
          <source>Type expressions denote types in definitions of data types as well as in type constraints over patterns and expressions.</source>
          <target state="translated">유형 표현식은 패턴 및 표현식에 대한 유형 제약뿐만 아니라 데이터 유형 정의의 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7f54858a82ae6c361b165ee97f22098dea3856f8" translate="yes" xml:space="preserve">
          <source>Type inference for GADTs is notoriously hard. This is due to the fact some types may become ambiguous when escaping from a branch. For instance, in the Int case above, n could have either type int or a, and they are not equivalent outside of that branch. As a first approximation, type inference will always work if a pattern-matching is annotated with types containing no free type variables (both on the scrutinee and the return type). This is the case in the above example, thanks to the type annotation containing only locally abstract types.</source>
          <target state="translated">GADT에 대한 유형 추론은 매우 어렵습니다. 이는 분기에서 이스케이프 할 때 일부 유형이 모호해질 수 있기 때문입니다. 예를 들어, 위의 Int 사례에서 n은 int 또는 a 유형을 가질 수 있으며 해당 분기 외부에서는 동일하지 않습니다. 첫 번째 근사치로, 패턴 일치에 자유 유형 변수 (스크 루틴 및 반환 유형 모두)를 포함하지 않는 유형으로 주석이 추가 된 경우 유형 추론이 항상 작동합니다. 이것은 로컬 추상 유형 만 포함하는 유형 어노테이션 덕분에 위 예제의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="1c41d15644bc0e4699a63b1fcbb73b5b965f20ee" translate="yes" xml:space="preserve">
          <source>Type of formatted input functions</source>
          <target state="translated">형식화 된 입력 함수 유형</target>
        </trans-unit>
        <trans-unit id="1cf6e53f9d2885b8ecaefaa805ee9c2e406ebfb7" translate="yes" xml:space="preserve">
          <source>Type representing a file that will hold a series of heap snapshots together with additional information required to interpret those snapshots.</source>
          <target state="translated">이러한 스냅 샷을 해석하는 데 필요한 추가 정보와 함께 일련의 힙 스냅 샷을 보유 할 파일을 나타내는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6a1fb7e38670879b0890b7b24f14acf10d4a824d" translate="yes" xml:space="preserve">
          <source>Type variables ('a, 'b, &amp;hellip;) in a type t can be in either of two states: generalized (which means that the type t is valid for all possible instantiations of the variables) and not generalized (which means that the type t is valid only for one instantiation of the variables). In a let binding let name = expr, the type-checker normally generalizes as many type variables as possible in the type of expr. However, this leads to unsoundness (a well-typed program can crash) in conjunction with polymorphic mutable data structures. To avoid this, generalization is performed at let bindings only if the bound expression expr belongs to the class of &amp;ldquo;syntactic values&amp;rdquo;, which includes constants, identifiers, functions, tuples of syntactic values, etc. In all other cases (for instance, expr is a function application), a polymorphic mutable could have been created and generalization is therefore turned off for all variables occurring in contravariant or non-variant branches of the type. For instance, if the type of a non-value is 'a list the variable is generalizable (list is a covariant type constructor), but not in 'a list -&amp;gt; 'a list (the left branch of -&amp;gt; is contravariant) or 'a ref (ref is non-variant).</source>
          <target state="translated">유형 t의 유형 변수 ( 'a,'b,&amp;hellip;)는 일반화 (유형 t가 변수의 모든 가능한 인스턴스화에 유효 함을 의미 함)와 일반화되지 않음 (유형이 t는 변수의 하나의 인스턴스화에만 유효합니다.) let 바인딩 let name = expr에서 유형 검사기는 일반적으로 expr 유형에서 가능한 한 많은 유형 변수를 일반화합니다. 그러나 이로 인해 다형성 가변 데이터 구조와 관련하여 불건전 함 (잘 형식화 된 프로그램이 충돌 할 수 있음)이 발생합니다. 이를 방지하기 위해 바인딩 된 표현식 expr이 상수, 식별자, 함수, 구문 값의 튜플 등을 포함하는 &quot;구문 값&quot;의 클래스에 속하는 경우에만 let 바인딩에서 일반화가 수행됩니다. 다른 모든 경우 (예 : expr 기능 응용 프로그램),다형성 가변이 생성되었을 수 있으며 따라서 해당 유형의 반 변성 또는 비 변형 분기에서 발생하는 모든 변수에 대해 일반화가 해제됩니다. 예를 들어, 값이 아닌 유형이 '목록'인 경우 변수는 일반화 가능하지만 (목록은 공변 유형 생성자) '목록-&amp;gt;'목록 (-&amp;gt;의 왼쪽 분기는 반 변성) 또는 'ref (ref는 비 변형).</target>
        </trans-unit>
        <trans-unit id="6e3aef53774c7f5b428263ee8017835db5f94f3b" translate="yes" xml:space="preserve">
          <source>Type without principality.</source>
          <target state="translated">공국없이 입력합니다.</target>
        </trans-unit>
        <trans-unit id="7abe567be65d268f3a2696a5729946c3839700c3" translate="yes" xml:space="preserve">
          <source>Type-checking polymorphic variants is a subtle thing, and some expressions may result in more complex type information.</source>
          <target state="translated">유형 검사 다형성 변형은 미묘한 일이며 일부 표현식은 더 복잡한 유형 정보를 생성 할 수 있습니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="dd209f835b431620f2f7a16a1700ed3f687e554d" translate="yes" xml:space="preserve">
          <source>Type-level module aliases are used when checking module path equalities. That is, in a context where module name N is known to be an alias for P, not only these two module paths check as equal, but F (N) and F (P) are also recognized as equal. In the default compilation mode, this is the only difference with the previous approach of module aliases having just the same module type as the module they reference.</source>
          <target state="translated">유형 수준 모듈 별칭은 모듈 경로가 같음을 확인할 때 사용됩니다. 즉, 모듈 이름 N이 P의 별칭으로 알려진 컨텍스트에서이 두 모듈 경로가 동일한 것으로 확인 될뿐만 아니라 F (N) 및 F (P)도 동일한 것으로 인식됩니다. 기본 컴파일 모드에서 이것은 참조하는 모듈과 동일한 모듈 유형을 갖는 이전 모듈 별칭 접근 방식과의 유일한 차이점입니다.</target>
        </trans-unit>
        <trans-unit id="482b5d3e58f932060fa84ae1f7437ed62a8c84a5" translate="yes" xml:space="preserve">
          <source>Typing an interrupt character (usually ctrl-C) will not exit the debugger, but will terminate the action of any debugger command that is in progress and return to the debugger command level.</source>
          <target state="translated">인터럽트 문자 (일반적으로 ctrl-C)를 입력하면 디버거가 종료되지 않지만 진행중인 모든 디버거 명령의 작업이 종료되고 디버거 명령 수준으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="c285dbae8ad75c11cf03e8d284872209563d4ef3" translate="yes" xml:space="preserve">
          <source>Uchar</source>
          <target state="translated">Uchar</target>
        </trans-unit>
        <trans-unit id="b677e5fef1be6d058b58bf6826880d3b971e64ab" translate="yes" xml:space="preserve">
          <source>Unary addition.</source>
          <target state="translated">단항 덧셈.</target>
        </trans-unit>
        <trans-unit id="f695fa2b2a0f97bac964e65828d440f3804af708" translate="yes" xml:space="preserve">
          <source>Unary addition. You can also write &lt;code&gt;+&amp;nbsp;e&lt;/code&gt; instead of &lt;code&gt;~+&amp;nbsp;e&lt;/code&gt;. Unary operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">단항 덧셈. &lt;code&gt;~+&amp;nbsp;e&lt;/code&gt; 대신 &lt;code&gt;+&amp;nbsp;e&lt;/code&gt; 를 쓸 수도 있습니다 . 단항 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="5f4484029bc001a1c51bfcd0596481e4db8652c6" translate="yes" xml:space="preserve">
          <source>Unary addition. You can also write &lt;code&gt;+.&amp;nbsp;e&lt;/code&gt; instead of &lt;code&gt;~+.&amp;nbsp;e&lt;/code&gt;. Unary operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">단항 덧셈. &lt;code&gt;+.&amp;nbsp;e&lt;/code&gt; 를 쓸 수도 있습니다 . &lt;code&gt;~+.&amp;nbsp;e&lt;/code&gt; 대신 e . e . 단항 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="63b13d71007c4da2df4ac38a9e58dea596e4161f" translate="yes" xml:space="preserve">
          <source>Unary negation.</source>
          <target state="translated">단항 부정.</target>
        </trans-unit>
        <trans-unit id="95141f64f4298daa6ecac13e37d4f744cc2fc09d" translate="yes" xml:space="preserve">
          <source>Unary negation. You can also write &lt;code&gt;-&amp;nbsp;e&lt;/code&gt; instead of &lt;code&gt;~-&amp;nbsp;e&lt;/code&gt;. Unary operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">단항 부정. &lt;code&gt;~-&amp;nbsp;e&lt;/code&gt; &lt;code&gt;-&amp;nbsp;e&lt;/code&gt; 대신 -e 를 쓸 수도 있습니다 . 단항 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="7a731455f59ced6b1f05e17234de09ab409ca508" translate="yes" xml:space="preserve">
          <source>Unary negation. You can also write &lt;code&gt;-.&amp;nbsp;e&lt;/code&gt; instead of &lt;code&gt;~-.&amp;nbsp;e&lt;/code&gt;. Unary operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">단항 부정. 당신은 또한 쓸 수 있습니다 &lt;code&gt;-.&amp;nbsp;e&lt;/code&gt; &lt;code&gt;~-.&amp;nbsp;e&lt;/code&gt; 대신 e . e . 단항 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="65bc523ce5f481e4e4e3e37f7a2972ec888003bf" translate="yes" xml:space="preserve">
          <source>Unboxable type in primitive declaration.</source>
          <target state="translated">기본 선언의 Unboxable 유형입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
