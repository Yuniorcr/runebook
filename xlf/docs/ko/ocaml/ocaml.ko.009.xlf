<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="8b5246ec3fd3ea63c509be27737c36d3be01173e" translate="yes" xml:space="preserve">
          <source>Load in the debugger the indicated .cmo or .cma object file. The file is loaded in an environment consisting only of the OCaml standard library plus the definitions provided by object files previously loaded using load_printer. If this file depends on other object files not yet loaded, the debugger automatically loads them if it is able to find them in the search path. The loaded file does not have direct access to the modules of the program being debugged.</source>
          <target state="translated">디버거에서 표시된 .cmo 또는 .cma 개체 파일을로드합니다. 파일은 OCaml 표준 라이브러리와 이전에 load_printer를 사용하여로드 된 개체 파일에서 제공 한 정의로만 구성된 환경에서로드됩니다. 이 파일이 아직로드되지 않은 다른 개체 파일에 의존하는 경우 디버거는 검색 경로에서 해당 파일을 찾을 수 있으면 자동으로로드합니다. 로드 된 파일은 디버깅중인 프로그램의 모듈에 직접 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9554426e849ebccce273355d09330acd0af5f810" translate="yes" xml:space="preserve">
          <source>Load information from file, which has been produced by ocamldoc -dump. Several -load options can be given.</source>
          <target state="translated">ocamldoc -dump에 의해 생성 된 파일에서 정보를로드합니다. 여러 -load 옵션이 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1468bdc0578724ddc204f4a8076fd367c4f00ada" translate="yes" xml:space="preserve">
          <source>Load the given file instead of the default initialization file. The default file is .ocamlinit in the current directory if it exists, otherwise XDG_CONFIG_HOME/ocaml/init.ml or .ocamlinit in the user&amp;rsquo;s home directory.</source>
          <target state="translated">기본 초기화 파일 대신 주어진 파일을로드합니다. 기본 파일은 현재 디렉토리에있는 경우 .ocamlinit이고, 그렇지 않으면 사용자의 홈 디렉토리에있는 XDG_CONFIG_HOME / ocaml / init.ml 또는 .ocamlinit입니다.</target>
        </trans-unit>
        <trans-unit id="22c136cf2e9c1518388c865d582646bebe003932" translate="yes" xml:space="preserve">
          <source>Load the program and execute it until the given time. Useful when you already know approximately at what time the problem appears. Also useful to set breakpoints on function values that have not been computed at time 0 (see section &lt;a href=&quot;#s%3Abreakpoints&quot;&gt;17.5&lt;/a&gt;).</source>
          <target state="translated">프로그램을로드하고 주어진 시간까지 실행하십시오. 문제가 나타나는 대략적인 시간을 이미 알고있을 때 유용합니다. 또한 시간 0에서 계산되지 않은 함수 값에 중단 점을 설정하는 데 유용합니다 (섹션 &lt;a href=&quot;#s%3Abreakpoints&quot;&gt;17.5&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3e63214a47f4377c1d66c127f747b02a52318db2" translate="yes" xml:space="preserve">
          <source>Load the program and stop on the first event.</source>
          <target state="translated">프로그램을로드하고 첫 번째 이벤트에서 중지합니다.</target>
        </trans-unit>
        <trans-unit id="06d5cb576439af064f31b513f860fdcf129f485b" translate="yes" xml:space="preserve">
          <source>Loading codes</source>
          <target state="translated">로드 코드</target>
        </trans-unit>
        <trans-unit id="f75d20b246e4621320b31b1c098e452853a4ac67" translate="yes" xml:space="preserve">
          <source>Local opens are supported in class expressions since OCaml 4.06.</source>
          <target state="translated">로컬 열기는 OCaml 4.06부터 클래스 표현식에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="570b10f925c51b325fdc93e2d97c8848252648e2" translate="yes" xml:space="preserve">
          <source>Local opens are supported in class types since OCaml 4.06.</source>
          <target state="translated">로컬 열기는 OCaml 4.06 이후 클래스 유형에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7a006a52c95463d27833642d291aafafbbe657d6" translate="yes" xml:space="preserve">
          <source>Local substitutions behave like destructive substitutions (with ... := ...) but instead of being applied to a whole signature after the fact, they are introduced during the specification of the signature, and will apply to all the items that follow.</source>
          <target state="translated">로컬 대체는 파괴적 대체 (... : = ... 포함)처럼 작동하지만 사실 이후 전체 서명에 적용되는 대신 서명 사양 중에 도입되며 이후의 모든 항목에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a3b9f4a56a716ca3242cf294551816b0edc61b5d" translate="yes" xml:space="preserve">
          <source>Lock a region for reading, and block if already locked</source>
          <target state="translated">읽기를 위해 영역을 잠그고 이미 잠긴 경우 차단</target>
        </trans-unit>
        <trans-unit id="46f366a2b18c94da3f95550dd69540c8a030c1d1" translate="yes" xml:space="preserve">
          <source>Lock a region for reading, or fail if already locked</source>
          <target state="translated">읽기를 위해 영역을 잠 그거나 이미 잠긴 경우 실패합니다.</target>
        </trans-unit>
        <trans-unit id="7b934b756e8fc53911807eb32d2b56437692262d" translate="yes" xml:space="preserve">
          <source>Lock a region for writing, and block if already locked</source>
          <target state="translated">쓰기를 위해 영역을 잠그고 이미 잠긴 경우 차단</target>
        </trans-unit>
        <trans-unit id="c93a16a3ed8e2fb19e43651da0d9564d29f64855" translate="yes" xml:space="preserve">
          <source>Lock a region for writing, or fail if already locked</source>
          <target state="translated">쓰기를 위해 영역을 잠 그거나 이미 잠긴 경우 실패합니다.</target>
        </trans-unit>
        <trans-unit id="4c7af655541e99448e1ec9e27d57b823c87c4cdc" translate="yes" xml:space="preserve">
          <source>Lock the given mutex.</source>
          <target state="translated">주어진 뮤텍스를 잠급니다.</target>
        </trans-unit>
        <trans-unit id="ef84af5a92860b1f205389a08e46e19c1d0376bf" translate="yes" xml:space="preserve">
          <source>Lock the given mutex. Only one thread can have the mutex locked at any time. A thread that attempts to lock a mutex already locked by another thread will suspend until the other thread unlocks the mutex.</source>
          <target state="translated">주어진 뮤텍스를 잠급니다. 언제든지 하나의 스레드 만 뮤텍스를 잠글 수 있습니다. 다른 스레드가 이미 잠근 뮤텍스를 잠그려고 시도하는 스레드는 다른 스레드가 뮤텍스를 잠금 해제 할 때까지 일시 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="d1d6079f6b5f44c82f4e240cfc0156faa4fc5b60" translate="yes" xml:space="preserve">
          <source>Locking</source>
          <target state="translated">Locking</target>
        </trans-unit>
        <trans-unit id="d744573647f56d06b5b86078a49e94460efb4548" translate="yes" xml:space="preserve">
          <source>Locks for mutual exclusion.</source>
          <target state="translated">상호 배제를위한 잠금.</target>
        </trans-unit>
        <trans-unit id="2911f8b42aa989ed16139a00c9d592e0e4e835c2" translate="yes" xml:space="preserve">
          <source>Long_val(v) returns the long int encoded in value v.</source>
          <target state="translated">Long_val (v)는 v 값으로 인코딩 된 long int를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="911e3c5ea58f72e14fe5b81b5acd435c6c333d4f" translate="yes" xml:space="preserve">
          <source>Low-level functions</source>
          <target state="translated">저수준 기능</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="c934410bd452bcb5e709691c6c967b3dbcd37b50" translate="yes" xml:space="preserve">
          <source>MD5 message digest.</source>
          <target state="translated">MD5 메시지 다이제스트.</target>
        </trans-unit>
        <trans-unit id="c6426140160e26a1863b2e621495d7c29a1605e0" translate="yes" xml:space="preserve">
          <source>Make inlining decisions at the point of definition of a function rather than at the call site(s). This mirrors the behaviour of OCaml compilers not using Flambda. Compared to compilation using the new Flambda inlining heuristics (for example at -O2) it produces smaller .cmx files, shorter compilation times and code that probably runs rather slower. When using -Oclassic, only the following options described in this section are relevant: -inlining-report and -inline. If any other of the options described in this section are used, the behaviour is undefined and may cause an error in future versions of the compiler.</source>
          <target state="translated">호출 사이트가 아닌 함수 정의 시점에서 인라인 결정을 내립니다. 이것은 Flambda를 사용하지 않는 OCaml 컴파일러의 동작을 반영합니다. 새로운 Flambda 인라인 휴리스틱 (예 : -O2)을 사용하는 컴파일과 비교하면 더 작은 .cmx 파일, 더 짧은 컴파일 시간 및 다소 느리게 실행되는 코드가 생성됩니다. -Oclassic을 사용하는 경우이 섹션에 설명 된 다음 옵션 만 관련됩니다. -inlining-report 및 -inline. 이 섹션에 설명 된 다른 옵션을 사용하는 경우 동작이 정의되지 않으며 이후 버전의 컴파일러에서 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be8c42ef87bb8b55a6444a52383572cda55e1591" translate="yes" xml:space="preserve">
          <source>Making a custom generator handle custom tags (see &lt;a href=&quot;#sss%3Aocamldoc-custom-tags&quot;&gt;16.2.5&lt;/a&gt;) is very simple.</source>
          <target state="translated">사용자 정의 생성기를 사용자 정의 태그 ( &lt;a href=&quot;#sss%3Aocamldoc-custom-tags&quot;&gt;16.2.5&lt;/a&gt; 참조 )를 처리하도록 만드는 것은 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="fee138b412931aab18dbc01608d4cef40bddbdba" translate="yes" xml:space="preserve">
          <source>Management of signals</source>
          <target state="translated">신호 관리</target>
        </trans-unit>
        <trans-unit id="e8766772088c50c0ea69ddcc9e68cc232fadded3" translate="yes" xml:space="preserve">
          <source>Manipulation of backtrace information</source>
          <target state="translated">역 추적 정보 조작</target>
        </trans-unit>
        <trans-unit id="ab478f3efc840eebab919dff1b9512286f70c10c" translate="yes" xml:space="preserve">
          <source>Map</source>
          <target state="translated">Map</target>
        </trans-unit>
        <trans-unit id="c43329032df3d96e24d72c385d12a422e571b619" translate="yes" xml:space="preserve">
          <source>Map CR to NL on input.</source>
          <target state="translated">입력시 CR을 NL에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="62b1ed02cf5951695363e86b8efaae11f6285d79" translate="yes" xml:space="preserve">
          <source>Map NL to CR on input.</source>
          <target state="translated">입력시 NL을 CR에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="face92f1c006ac531f226f881711266fcb0854d2" translate="yes" xml:space="preserve">
          <source>Map each element to a subsequence, then return each element of this sub-sequence in turn.</source>
          <target state="translated">각 요소를 하위 시퀀스에 매핑 한 다음이 하위 시퀀스의 각 요소를 차례로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9d1e9a2774804659a435bcd137155a2fc9950a33" translate="yes" xml:space="preserve">
          <source>Map each element to a subsequence, then return each element of this sub-sequence in turn. This transformation is lazy, it only applies when the result is traversed.</source>
          <target state="translated">각 요소를 하위 시퀀스에 매핑 한 다음이 하위 시퀀스의 각 요소를 차례로 반환합니다. 이 변환은 게으 르며 결과가 순회 될 때만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="874e0cf467c242a8715d382d0113f4ffe8e8b9dc" translate="yes" xml:space="preserve">
          <source>Mapping files into memory</source>
          <target state="translated">메모리에 파일 매핑</target>
        </trans-unit>
        <trans-unit id="792fe4aaafb220da5ab17388e5844c93f1d95290" translate="yes" xml:space="preserve">
          <source>Margin</source>
          <target state="translated">Margin</target>
        </trans-unit>
        <trans-unit id="4e68d70db4cb0c9f7b47b7e8261347a139a40f40" translate="yes" xml:space="preserve">
          <source>Mark as fatal the warnings specified in the argument warning-list. The compiler will stop with an error when one of these warnings is emitted. The warning-list has the same meaning as for the -w option: a + sign (or an uppercase letter) marks the corresponding warnings as fatal, a - sign (or a lowercase letter) turns them back into non-fatal warnings, and a @ sign both enables and marks as fatal the corresponding warnings.</source>
          <target state="translated">경고 목록 인수에 지정된 경고를 치명적인 것으로 표시하십시오. 이러한 경고 중 하나가 발생하면 컴파일러가 오류와 함께 중지됩니다. 경고 목록은 -w 옵션과 동일한 의미를 갖습니다. + 기호 (또는 대문자)는 해당 경고를 치명적 경고로 표시하고-기호 (또는 소문자)는 치명적이지 않은 경고로 다시 바꿉니다. @ 기호는 해당 경고를 활성화하고 치명적인 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9651ed6afe7f40f844d844247a351f306f618725" translate="yes" xml:space="preserve">
          <source>Mark parity errors.</source>
          <target state="translated">패리티 오류를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="9cdfbcba7d735bd862886d7bc92cdad6e808e063" translate="yes" xml:space="preserve">
          <source>Marshal</source>
          <target state="translated">Marshal</target>
        </trans-unit>
        <trans-unit id="facd64ea9fa3010a0e9705a9b4261b78f3ecb660" translate="yes" xml:space="preserve">
          <source>Marshaling of data structures.</source>
          <target state="translated">데이터 구조 마샬링.</target>
        </trans-unit>
        <trans-unit id="dad9eec833cc64e444f260559ec864ea918d9fe7" translate="yes" xml:space="preserve">
          <source>Match any single character belonging to the given character set. Valid character sets are: single character constants 'c'; ranges of characters 'c&lt;sub&gt;1&lt;/sub&gt;'-'c&lt;sub&gt;2&lt;/sub&gt;' (all characters between c&lt;sub&gt;1&lt;/sub&gt; and c&lt;sub&gt;2&lt;/sub&gt;, inclusive); and the union of two or more character sets, denoted by concatenation.</source>
          <target state="translated">주어진 문자 세트에 속하는 단일 문자와 일치합니다. 유효한 문자 세트는 다음과 같습니다. 단일 문자 상수 'c'; 문자 범위 'c &lt;sub&gt;1&lt;/sub&gt; '- 'c &lt;sub&gt;2&lt;/sub&gt; '(c &lt;sub&gt;1&lt;/sub&gt; 과 c &lt;sub&gt;2&lt;/sub&gt; 사이의 모든 문자 , 포함) 두 개 이상의 문자 집합의 결합 (연결로 표시됨).</target>
        </trans-unit>
        <trans-unit id="9ff233319bdf1bc966fa073a62017cfcf28311ec" translate="yes" xml:space="preserve">
          <source>Match any single character not belonging to the given character set.</source>
          <target state="translated">주어진 문자 집합에 속하지 않는 단일 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f7ad8e08bddf311e1561c76915c116ddac2c9064" translate="yes" xml:space="preserve">
          <source>Match the end of the lexer input.</source>
          <target state="translated">렉서 입력의 끝을 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="624939b9202c5d64193aa77b5ed57d3e219078ff" translate="yes" xml:space="preserve">
          <source>Match the same strings as &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt; 와 동일한 문자열을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="6d643dda70d07a9bff87dc40b34a36dca7c58f10" translate="yes" xml:space="preserve">
          <source>Matching &lt;em&gt;any&lt;/em&gt; amount of whitespace, a space in the format string also matches no amount of whitespace at all; hence, the call &lt;code&gt;bscanf&amp;nbsp;ib&lt;br/&gt;
&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;Price&amp;nbsp;=&amp;nbsp;%d&amp;nbsp;$&quot;&amp;nbsp;(fun&amp;nbsp;p&amp;nbsp;-&amp;gt;&amp;nbsp;p)&lt;/code&gt; succeeds and returns &lt;code&gt;1&lt;/code&gt; when reading an input with various whitespace in it, such as &lt;code&gt;Price&amp;nbsp;=&amp;nbsp;1&amp;nbsp;$&lt;/code&gt;, &lt;code&gt;Price&amp;nbsp;&amp;nbsp;=&amp;nbsp;&amp;nbsp;1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$&lt;/code&gt;, or even &lt;code&gt;Price=1$&lt;/code&gt;.</source>
          <target state="translated">일치하는 &lt;em&gt;어떤&lt;/em&gt; 공백의 양을 형식 문자열에 공백도 전혀 공백 아무리 일치하지 않습니다; 따라서, 호출은 &lt;code&gt;bscanf&amp;nbsp;ib&lt;br/&gt; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;Price&amp;nbsp;=&amp;nbsp;%d&amp;nbsp;$&quot;&amp;nbsp;(fun&amp;nbsp;p&amp;nbsp;-&amp;gt;&amp;nbsp;p)&lt;/code&gt; 성공 반환 &lt;code&gt;1&lt;/code&gt; 등이 다양한 공백와 입력 읽을 때 &lt;code&gt;Price&amp;nbsp;=&amp;nbsp;1&amp;nbsp;$&lt;/code&gt; , &lt;code&gt;Price&amp;nbsp;&amp;nbsp;=&amp;nbsp;&amp;nbsp;1&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$&lt;/code&gt; , 또는 &lt;code&gt;Price=1$&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9ba4e48291cd2cf0b811e179ed03624617f0f18" translate="yes" xml:space="preserve">
          <source>Matching proceeds as described before, except that if the value matches some pattern &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; which has a guard cond&lt;sub&gt;i&lt;/sub&gt;, then the expression cond&lt;sub&gt;i&lt;/sub&gt; is evaluated (in an environment enriched by the bindings performed during matching). If cond&lt;sub&gt;i&lt;/sub&gt; evaluates to true, then &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; is evaluated and its value returned as the result of the matching, as usual. But if cond&lt;sub&gt;i&lt;/sub&gt; evaluates to false, the matching is resumed against the patterns following &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;.</source>
          <target state="translated">값이 어떤 패턴과 일치하는 경우 것 이외에는, 전술 한 바와 같이 진행한다 매칭 &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;I&lt;/sub&gt; 가드를 갖는다 COND &lt;sub&gt;I를&lt;/sub&gt; , 다음 식을 COND &lt;sub&gt;난&lt;/sub&gt; (바인딩으로 풍부한 환경에서 매칭 동안 수행) 평가된다. cond &lt;sub&gt;i&lt;/sub&gt; 가 true로 평가 되면 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; 가 평가되고 평소와 같이 일치의 결과로 해당 값이 반환됩니다. 그러나 cond &lt;sub&gt;i&lt;/sub&gt; 가 false로 평가 되면 &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; 다음의 패턴 에 대해 일치가 재개 됩니다.</target>
        </trans-unit>
        <trans-unit id="b4fe7526fed514734906dd56f0808fdf64d5c5e7" translate="yes" xml:space="preserve">
          <source>Material inside boxes nested deeper is printed as an ellipsis (more precisely as the text returned by &lt;a href=&quot;format#VALget_ellipsis_text&quot;&gt;&lt;code&gt;Format.get_ellipsis_text&lt;/code&gt;&lt;/a&gt;&lt;code&gt;()&lt;/code&gt;).</source>
          <target state="translated">더 깊게 중첩 된 상자 내부의 재질은 줄임표로 인쇄됩니다 (더 정확하게는 &lt;a href=&quot;format#VALget_ellipsis_text&quot;&gt; &lt;code&gt;Format.get_ellipsis_text&lt;/code&gt; &lt;/a&gt; &lt;code&gt;()&lt;/code&gt; 에서 반환 된 텍스트 ).</target>
        </trans-unit>
        <trans-unit id="8c775e0b631e27aa872cba9538a7ad38db0e8382" translate="yes" xml:space="preserve">
          <source>Maximal number of bindings per bucket.</source>
          <target state="translated">버킷 당 최대 바인딩 수.</target>
        </trans-unit>
        <trans-unit id="de4aecc225c29a9b00684b7a91e8d4a7c0c4fcf7" translate="yes" xml:space="preserve">
          <source>Maximum amount of out-of-heap memory for each custom value allocated in the minor heap. When a custom value is allocated on the minor heap and holds more than this many bytes, only this value is counted against &lt;code&gt;custom_minor_ratio&lt;/code&gt; and the rest is directly counted against &lt;code&gt;custom_major_ratio&lt;/code&gt;. Note: this only applies to values allocated with &lt;code&gt;caml_alloc_custom_mem&lt;/code&gt; (e.g. bigarrays). Default: 8192 bytes.</source>
          <target state="translated">부 힙에 할당 된 각 사용자 정의 값에 대한 힙 부족 메모리의 최대 양입니다. 사용자 지정 값이 부 힙에 할당되고 이보다 많은 바이트를 보유하는 경우이 값만 &lt;code&gt;custom_minor_ratio&lt;/code&gt; 에 대해 계산 되고 나머지는 &lt;code&gt;custom_major_ratio&lt;/code&gt; 에 대해 직접 계산됩니다 . 참고 : 이것은 &lt;code&gt;caml_alloc_custom_mem&lt;/code&gt; (예 : bigarrays)으로 할당 된 값에만 적용됩니다 . 기본값 : 8192 바이트.</target>
        </trans-unit>
        <trans-unit id="3a4b693ac7f8f148df9e57169d08a10429066cdc" translate="yes" xml:space="preserve">
          <source>Maximum formatting depth</source>
          <target state="translated">최대 서식 깊이</target>
        </trans-unit>
        <trans-unit id="43e8208d3223642a44e274b068fe9167dea74624" translate="yes" xml:space="preserve">
          <source>Maximum indentation limit</source>
          <target state="translated">최대 들여 쓰기 제한</target>
        </trans-unit>
        <trans-unit id="57d9251c94f60be5c0a454afa29832266764bb87" translate="yes" xml:space="preserve">
          <source>Maximum length of a floatarray.</source>
          <target state="translated">floatarray의 최대 길이.</target>
        </trans-unit>
        <trans-unit id="0a82d8640ca6e8be934710976326d9e3d41c21e3" translate="yes" xml:space="preserve">
          <source>Maximum length of a floatarray. This is also the maximum length of a &lt;code&gt;float&amp;nbsp;array&lt;/code&gt; when OCaml is configured with &lt;code&gt;--enable-flat-float-array&lt;/code&gt;.</source>
          <target state="translated">floatarray의 최대 길이. 이것은 또한 OCaml이 &lt;code&gt;--enable-flat-float-array&lt;/code&gt; 로 구성된 경우 &lt;code&gt;float&amp;nbsp;array&lt;/code&gt; 의 최대 길이입니다 .</target>
        </trans-unit>
        <trans-unit id="75f830d8170e15a87cf9b64f314629724f342359" translate="yes" xml:space="preserve">
          <source>Maximum length of a normal array (i.e.</source>
          <target state="translated">일반 배열의 최대 길이 (예 :</target>
        </trans-unit>
        <trans-unit id="9e07a269e552f76233aa4f04ad4c80b7015574f5" translate="yes" xml:space="preserve">
          <source>Maximum length of a normal array (i.e. any array whose elements are not of type &lt;code&gt;float&lt;/code&gt;). The maximum length of a &lt;code&gt;float&amp;nbsp;array&lt;/code&gt; is &lt;code&gt;max_floatarray_length&lt;/code&gt; if OCaml was configured with &lt;code&gt;--enable-flat-float-array&lt;/code&gt; and &lt;code&gt;max_array_length&lt;/code&gt; if configured with &lt;code&gt;--disable-flat-float-array&lt;/code&gt;.</source>
          <target state="translated">일반 배열의 최대 길이 (즉, 요소가 &lt;code&gt;float&lt;/code&gt; 유형이 아닌 모든 배열 ). (A)의 최대 길이 &lt;code&gt;float&amp;nbsp;array&lt;/code&gt; 이다 &lt;code&gt;max_floatarray_length&lt;/code&gt; OCaml의이 구성되었는지 &lt;code&gt;--enable-flat-float-array&lt;/code&gt; 와 &lt;code&gt;max_array_length&lt;/code&gt; 구성된 경우 &lt;code&gt;--disable-flat-float-array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4de1705370b8992fe2eac57ca9e570d5b6fdbf4" translate="yes" xml:space="preserve">
          <source>Maximum length of an ephemeron, ie the maximum number of keys an ephemeron could contain</source>
          <target state="translated">ephemeron의 최대 길이, 즉 ephemeron에 포함될 수있는 최대 키 수</target>
        </trans-unit>
        <trans-unit id="c8d2ea9cbf5aa25afab320da73d2cb8746b9c6ea" translate="yes" xml:space="preserve">
          <source>Maximum length of strings and byte sequences.</source>
          <target state="translated">문자열 및 바이트 시퀀스의 최대 길이.</target>
        </trans-unit>
        <trans-unit id="111798f4ee1440503f39a9ca5e215b57ed0edd0d" translate="yes" xml:space="preserve">
          <source>Maximum read wait (in 0.1s units).</source>
          <target state="translated">최대 읽기 대기 (0.1 초 단위).</target>
        </trans-unit>
        <trans-unit id="421dda9f026ffda8002440f413ce7dac542281cc" translate="yes" xml:space="preserve">
          <source>Maximum size reached by the major heap, in words.</source>
          <target state="translated">주요 힙이 도달 한 최대 크기 (단어)입니다.</target>
        </trans-unit>
        <trans-unit id="0867fadb65552799103f1e2c59b6996e3bca055e" translate="yes" xml:space="preserve">
          <source>Maybe the most frequent examples of non-genericity derive from the interactions between polymorphic types and mutation. A simple example appears when typing the following expression</source>
          <target state="translated">비 제네릭 성의 가장 빈번한 예는 다형성 유형과 돌연변이 간의 상호 작용에서 비롯된 것일 수 있습니다. 다음 표현식을 입력하면 간단한 예가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="58b588830d79aaa6edd4ede9d25c9ec5e38ae494" translate="yes" xml:space="preserve">
          <source>Mechanisms are available to control event collection at runtime.</source>
          <target state="translated">런타임시 이벤트 콜렉션을 제어하는 ​​메커니즘을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5747d498a7435bd2232d8a279011040168fdf61" translate="yes" xml:space="preserve">
          <source>Memory management control and statistics; finalised values.</source>
          <target state="translated">메모리 관리 제어 및 통계 최종 값.</target>
        </trans-unit>
        <trans-unit id="e1d5fee5c92276c92276efd0e44640e46a30110a" translate="yes" xml:space="preserve">
          <source>Memory mapping of a file as a Bigarray.</source>
          <target state="translated">Bigarray로 파일의 메모리 매핑.</target>
        </trans-unit>
        <trans-unit id="d453e5fd051d62abb4952e6dce9f9a70c5c2e73f" translate="yes" xml:space="preserve">
          <source>Memory mapping of a file as a Bigarray. &lt;code&gt;map_file&amp;nbsp;fd&amp;nbsp;kind&amp;nbsp;layout&amp;nbsp;shared&amp;nbsp;dims&lt;/code&gt; returns a Bigarray of kind &lt;code&gt;kind&lt;/code&gt;, layout &lt;code&gt;layout&lt;/code&gt;, and dimensions as specified in &lt;code&gt;dims&lt;/code&gt;. The data contained in this Bigarray are the contents of the file referred to by the file descriptor &lt;code&gt;fd&lt;/code&gt; (as opened previously with &lt;code&gt;Unix.openfile&lt;/code&gt;, for example). The optional &lt;code&gt;pos&lt;/code&gt; parameter is the byte offset in the file of the data being mapped; it defaults to 0 (map from the beginning of the file).</source>
          <target state="translated">Bigarray로 파일의 메모리 매핑. &lt;code&gt;map_file&amp;nbsp;fd&amp;nbsp;kind&amp;nbsp;layout&amp;nbsp;shared&amp;nbsp;dims&lt;/code&gt; 는 종류 &lt;code&gt;kind&lt;/code&gt; , 레이아웃 &lt;code&gt;layout&lt;/code&gt; 및 &lt;code&gt;dims&lt;/code&gt; 에 지정된 차원 의 Bigarray를 반환합니다 . 이 Bigarray에 포함 된 데이터는 파일 설명자 &lt;code&gt;fd&lt;/code&gt; 가 참조하는 파일의 내용입니다 ( 예를 들어, 이전에 &lt;code&gt;Unix.openfile&lt;/code&gt; 로 열림 ). 선택적 &lt;code&gt;pos&lt;/code&gt; 매개 변수는 매핑되는 데이터 파일의 바이트 오프셋입니다. 기본값은 0 (파일 시작부터 매핑)입니다.</target>
        </trans-unit>
        <trans-unit id="880d9fe17162cdc8dbe19eec2a7dab314180b634" translate="yes" xml:space="preserve">
          <source>Merge two lists: Assuming that &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; are sorted according to the comparison function &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;merge&amp;nbsp;cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; will return a sorted list containing all the elements of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt;.</source>
          <target state="translated">두리스트를 병합된다고 가정하면 &lt;code&gt;l1&lt;/code&gt; 하고 &lt;code&gt;l2&lt;/code&gt; 비교 기능에 따라 분류되어 &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;merge&amp;nbsp;cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; 의 모든 요소를 포함하는 정렬 된 목록을 반환 &lt;code&gt;l1&lt;/code&gt; 및 &lt;code&gt;l2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f82c912801fa2f38788ef8f80f6481aca333a281" translate="yes" xml:space="preserve">
          <source>Merge two lists: Assuming that &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; are sorted according to the comparison function &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;merge&amp;nbsp;cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; will return a sorted list containing all the elements of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt;. If several elements compare equal, the elements of &lt;code&gt;l1&lt;/code&gt; will be before the elements of &lt;code&gt;l2&lt;/code&gt;. Not tail-recursive (sum of the lengths of the arguments).</source>
          <target state="translated">두리스트를 병합된다고 가정하면 &lt;code&gt;l1&lt;/code&gt; 하고 &lt;code&gt;l2&lt;/code&gt; 비교 기능에 따라 분류되어 &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;merge&amp;nbsp;cmp&amp;nbsp;l1&amp;nbsp;l2&lt;/code&gt; 의 모든 요소를 포함하는 정렬 된 목록을 반환 &lt;code&gt;l1&lt;/code&gt; 및 &lt;code&gt;l2&lt;/code&gt; . 여러 요소가 동일하게 비교되는 경우 &lt;code&gt;l1&lt;/code&gt; 의 요소는 &lt;code&gt;l2&lt;/code&gt; 의 요소보다 앞에 있습니다 . 꼬리 재귀가 아닙니다 (인수 길이의 합).</target>
        </trans-unit>
        <trans-unit id="6bf991e7854ed942e57f7a8ae958526d710e4851" translate="yes" xml:space="preserve">
          <source>Message too long</source>
          <target state="translated">메시지가 너무 깁니다.</target>
        </trans-unit>
        <trans-unit id="fe901f98d707d8893028273fbe15a247b6dc752f" translate="yes" xml:space="preserve">
          <source>Method calls to objects are not at present inlined by Flambda.</source>
          <target state="translated">객체에 대한 메서드 호출은 현재 Flambda에 의해 인라인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="725d48f23a2318240368857da2dd4a836394a9b1" translate="yes" xml:space="preserve">
          <source>Method overridden.</source>
          <target state="translated">메서드가 재정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="73d77f95747bb6c235ba5d9d8dd5594481b601b7" translate="yes" xml:space="preserve">
          <source>Methods may have an explicitly polymorphic type, allowing them to be used polymorphically in programs (even for the same object). The explicit declaration may be done in one of three ways: (1) by giving an explicit polymorphic type in the method definition, immediately after the method name, &lt;em&gt;i.e.&lt;/em&gt;method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;: {'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;}&lt;sup&gt;+&lt;/sup&gt;.&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;; (2) by a forward declaration of the explicit polymorphic type through a virtual method definition; (3) by importing such a declaration through inheritance and/or constraining the type of &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="translated">메서드는 명시 적으로 다형성 유형을 가질 수 있으므로 프로그램에서 다형성으로 사용할 수 있습니다 (동일한 객체에 대해서도). 명시 적 선언은 다음 세 가지 방법 중 하나로 수행 될 수 있습니다. (1) 메서드 이름 바로 뒤에 메서드 정의에 명시 적 다형성 유형을 제공함으로써, &lt;em&gt;즉&lt;/em&gt; method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; : { ' &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; } &lt;sup&gt;+&lt;/sup&gt; . &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; = &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; ; (2) 가상 메소드 정의를 통한 명시 적 다형성 유형의 전방 선언에 의해; (3) 상속을 통해 이러한 선언을 가져 오거나 &lt;em&gt;self&lt;/em&gt; 유형을 제한합니다 .</target>
        </trans-unit>
        <trans-unit id="977a75b1b527cafb43a310b768323025de5a89bf" translate="yes" xml:space="preserve">
          <source>Methods need not be declared previously, as shown by the example:</source>
          <target state="translated">예제에 표시된 것처럼 메서드를 이전에 선언 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="48a374e74161047aa235fbb3100763be5b812693" translate="yes" xml:space="preserve">
          <source>Middle mouse button</source>
          <target state="translated">마우스 가운데 버튼</target>
        </trans-unit>
        <trans-unit id="0d193e7dfe2ad2529b4896dcc5d46972be46e952" translate="yes" xml:space="preserve">
          <source>Minimum number of bytes to process for input operations</source>
          <target state="translated">입력 작업을 위해 처리 할 최소 바이트 수</target>
        </trans-unit>
        <trans-unit id="d481070b2cfb403e278c0dca62449244848cbded" translate="yes" xml:space="preserve">
          <source>Minimum number of bytes to process for output operations</source>
          <target state="translated">출력 작업을 위해 처리 할 최소 바이트 수</target>
        </trans-unit>
        <trans-unit id="d5be9f6d96fb9719bc05c3c57eba753a99104553" translate="yes" xml:space="preserve">
          <source>Minimum number of characters to read before the read request is satisfied.</source>
          <target state="translated">읽기 요청이 충족되기 전에 읽을 최소 문자 수입니다.</target>
        </trans-unit>
        <trans-unit id="1858c250815195a7d6f8064ba7ae2ae308e2c946" translate="yes" xml:space="preserve">
          <source>Minor collection and major GC slice.</source>
          <target state="translated">마이너 컬렉션 및 메이저 GC 슬라이스.</target>
        </trans-unit>
        <trans-unit id="ba7f64b06da5b1e4fcb3453af263375fd663c205" translate="yes" xml:space="preserve">
          <source>Minutes 0..59</source>
          <target state="translated">0..59 분</target>
        </trans-unit>
        <trans-unit id="314bb4fc83d55b365225efaa4fc333e95057e960" translate="yes" xml:space="preserve">
          <source>Miscellaneous functions</source>
          <target state="translated">기타 기능</target>
        </trans-unit>
        <trans-unit id="39b08ec421dc1322ebeee3c79275c01cc8b3d8fe" translate="yes" xml:space="preserve">
          <source>Missing cmx file.</source>
          <target state="translated">cmx 파일이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d081333d4e9bb27d1f44459f14c2d45dd9f81b1c" translate="yes" xml:space="preserve">
          <source>Missing fields in a record pattern.</source>
          <target state="translated">레코드 패턴에서 누락 된 필드입니다.</target>
        </trans-unit>
        <trans-unit id="37f242d312b71edb3517a2032fd66710ec76680c" translate="yes" xml:space="preserve">
          <source>Module &lt;code&gt;Format&lt;/code&gt; provides a complete set of &lt;code&gt;printf&lt;/code&gt; like functions for pretty-printing using format string specifications.</source>
          <target state="translated">모듈 &lt;code&gt;Format&lt;/code&gt; 은 형식 문자열 사양을 사용하여 예쁘게 인쇄하기위한 완전한 &lt;code&gt;printf&lt;/code&gt; 유사 함수 세트를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="bad989c3e6325882d6507e66e3602a4dd7dd1950" translate="yes" xml:space="preserve">
          <source>Module Arg</source>
          <target state="translated">모듈 Arg</target>
        </trans-unit>
        <trans-unit id="6abf3bb1d160573e61d46e6b5f81e5508ae82e88" translate="yes" xml:space="preserve">
          <source>Module Arg: parsing of command line arguments</source>
          <target state="translated">모듈 인수 : 명령 줄 인수 구문 분석</target>
        </trans-unit>
        <trans-unit id="a56fcb800d5771af9f080dd53abe44c449867565" translate="yes" xml:space="preserve">
          <source>Module Array</source>
          <target state="translated">모듈 어레이</target>
        </trans-unit>
        <trans-unit id="dc2ddb4a440e52c266e257d745c23b9dadfa5b3d" translate="yes" xml:space="preserve">
          <source>Module Array: array operations</source>
          <target state="translated">모듈 어레이 : 어레이 작업</target>
        </trans-unit>
        <trans-unit id="0d18ab309cc5cd2e46cd375092084b640f8135f4" translate="yes" xml:space="preserve">
          <source>Module ArrayLabels</source>
          <target state="translated">모듈 어레이 라벨</target>
        </trans-unit>
        <trans-unit id="cc6ff72196a05305dab9e2db994ea05cd60e104b" translate="yes" xml:space="preserve">
          <source>Module ArrayLabels: array operations (with labels)</source>
          <target state="translated">Module ArrayLabels : 배열 작업 (레이블 포함)</target>
        </trans-unit>
        <trans-unit id="f93c03acf357c6454b6e5285450c3f3f3f30bb2c" translate="yes" xml:space="preserve">
          <source>Module Ast_helper: helper functions for AST construction</source>
          <target state="translated">모듈 Ast_helper : AST 구성을위한 도우미 함수</target>
        </trans-unit>
        <trans-unit id="4f633b64e1901b821e83c2d2917c9c7dfe7b2811" translate="yes" xml:space="preserve">
          <source>Module Ast_mapper: -ppx rewriter interface</source>
          <target state="translated">모듈 Ast_mapper : -ppx rewriter 인터페이스</target>
        </trans-unit>
        <trans-unit id="523d5c8f5c6bb7605890429c1f11b8c345bdf0a9" translate="yes" xml:space="preserve">
          <source>Module Asttypes: auxiliary types used by Parsetree</source>
          <target state="translated">모듈 Asttypes : Parsetree에서 사용하는 보조 유형</target>
        </trans-unit>
        <trans-unit id="cc643dfec1e07f16e63a2f5d40439c635b5a0da0" translate="yes" xml:space="preserve">
          <source>Module Bigarray</source>
          <target state="translated">모듈 Bigarray</target>
        </trans-unit>
        <trans-unit id="8b457fad35d3c5733311bed4d1abc1928bb9ab28" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Array0</source>
          <target state="translated">모듈 Bigarray.Array0</target>
        </trans-unit>
        <trans-unit id="0606447c86667b05a149e8ca96cc9d366dcdc45f" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Array1</source>
          <target state="translated">모듈 Bigarray.Array1</target>
        </trans-unit>
        <trans-unit id="4e9d1f71e428cb53a57134b56fbd980b03c94e2c" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Array2</source>
          <target state="translated">모듈 Bigarray.Array2</target>
        </trans-unit>
        <trans-unit id="27d48e9da9c33900ca44d6ecad351863f7bdaf5c" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Array3</source>
          <target state="translated">모듈 Bigarray.Array3</target>
        </trans-unit>
        <trans-unit id="d4d26b36f6d58ffaea1f504565e46f4f60567d67" translate="yes" xml:space="preserve">
          <source>Module Bigarray.Genarray</source>
          <target state="translated">모듈 Bigarray.Genarray</target>
        </trans-unit>
        <trans-unit id="f3762282f9caa555d54286fbb90a1e96b4c7c432" translate="yes" xml:space="preserve">
          <source>Module Bigarray: large, multi-dimensional, numerical arrays</source>
          <target state="translated">모듈 Bigarray : 대형, 다차원, 숫자 배열</target>
        </trans-unit>
        <trans-unit id="8ecd3446e16a821dd5e1adff2cc82cb3a5130a89" translate="yes" xml:space="preserve">
          <source>Module Bool</source>
          <target state="translated">모듈 부울</target>
        </trans-unit>
        <trans-unit id="6c3e715d33fc29b958efa37ae69668a59a1706ff" translate="yes" xml:space="preserve">
          <source>Module Bool: boolean values</source>
          <target state="translated">모듈 부울 : 부울 값</target>
        </trans-unit>
        <trans-unit id="bddc2144c4c529dd8430235937580a143554e16c" translate="yes" xml:space="preserve">
          <source>Module Buffer</source>
          <target state="translated">모듈 버퍼</target>
        </trans-unit>
        <trans-unit id="43c2c38aaa41d7ed5d989a9cc184b3794181c9f7" translate="yes" xml:space="preserve">
          <source>Module Buffer: extensible buffers</source>
          <target state="translated">모듈 버퍼 : 확장 가능한 버퍼</target>
        </trans-unit>
        <trans-unit id="72216591b14162977cfdb1c07def7995da644395" translate="yes" xml:space="preserve">
          <source>Module Bytes</source>
          <target state="translated">모듈 바이트</target>
        </trans-unit>
        <trans-unit id="9c11fb2e91c5b00fbb9701a94d4424a17d04a49c" translate="yes" xml:space="preserve">
          <source>Module Bytes: byte sequences</source>
          <target state="translated">모듈 바이트 : 바이트 시퀀스</target>
        </trans-unit>
        <trans-unit id="a85f0c0beeed2c6b8ad5ef29ccdfab63a21b9d52" translate="yes" xml:space="preserve">
          <source>Module BytesLabels</source>
          <target state="translated">모듈 바이트 레이블</target>
        </trans-unit>
        <trans-unit id="f6cf68f0aad404a1f34cfeef9f8dc2bc6273085e" translate="yes" xml:space="preserve">
          <source>Module BytesLabels: byte sequences (with labels)</source>
          <target state="translated">Module BytesLabels : 바이트 시퀀스 (레이블 포함)</target>
        </trans-unit>
        <trans-unit id="f99b095fc3c2466d64fae5588a546e997e1e5f16" translate="yes" xml:space="preserve">
          <source>Module Callback</source>
          <target state="translated">모듈 콜백</target>
        </trans-unit>
        <trans-unit id="559eafeaa053a08996c324cd386ae9221fc17b97" translate="yes" xml:space="preserve">
          <source>Module Callback: registering OCaml values with the C runtime</source>
          <target state="translated">모듈 콜백 ​​: C 런타임에 OCaml 값 등록</target>
        </trans-unit>
        <trans-unit id="d1355614e6d5e948afbb68e8c6119679a9a45955" translate="yes" xml:space="preserve">
          <source>Module CamlinternalFormat</source>
          <target state="translated">모듈 CamlinternalFormat</target>
        </trans-unit>
        <trans-unit id="b4d1db84ed7881aa6f76ae9db16693820f6725ae" translate="yes" xml:space="preserve">
          <source>Module CamlinternalFormatBasics</source>
          <target state="translated">모듈 CamlinternalFormatBasics</target>
        </trans-unit>
        <trans-unit id="93e7f0366b4e8dbdb121c6899472d74fc9e300ed" translate="yes" xml:space="preserve">
          <source>Module CamlinternalLazy</source>
          <target state="translated">모듈 CamlinternalLazy</target>
        </trans-unit>
        <trans-unit id="030e686bde89aa913f3dbe8fe375396e5953e5e6" translate="yes" xml:space="preserve">
          <source>Module CamlinternalMod</source>
          <target state="translated">모듈 CamlinternalMod</target>
        </trans-unit>
        <trans-unit id="dd6ad5c3473f26f582d139567a98ea0e9d3d3b4e" translate="yes" xml:space="preserve">
          <source>Module CamlinternalOO</source>
          <target state="translated">모듈 CamlinternalOO</target>
        </trans-unit>
        <trans-unit id="79e77ccf8fe8cad52d93078cb896ef207ae08837" translate="yes" xml:space="preserve">
          <source>Module Char</source>
          <target state="translated">모듈 문자</target>
        </trans-unit>
        <trans-unit id="eb75d51c88cc6b02cf6aca6015384b8720d875a9" translate="yes" xml:space="preserve">
          <source>Module Char: character operations</source>
          <target state="translated">모듈 문자 : 문자 연산</target>
        </trans-unit>
        <trans-unit id="5548e02ff9068a8bd2671e455dd9adf27f571d77" translate="yes" xml:space="preserve">
          <source>Module Complex</source>
          <target state="translated">모듈 콤플렉스</target>
        </trans-unit>
        <trans-unit id="142a8ecd6426e808bdec26ab206584b15b18b324" translate="yes" xml:space="preserve">
          <source>Module Complex: Complex numbers</source>
          <target state="translated">모듈 컴플렉스 : 복소수</target>
        </trans-unit>
        <trans-unit id="bf0d5f1ae3231eea0973a205c212df89a0b65712" translate="yes" xml:space="preserve">
          <source>Module Condition</source>
          <target state="translated">모듈 조건</target>
        </trans-unit>
        <trans-unit id="a6a62a2154dc372d92c88ec0dfbedc61b73cd367" translate="yes" xml:space="preserve">
          <source>Module Condition: condition variables to synchronize between threads</source>
          <target state="translated">모듈 조건 : 스레드간에 동기화 할 조건 변수</target>
        </trans-unit>
        <trans-unit id="c923312ef4200761b1302981bacdcb52bccc44f9" translate="yes" xml:space="preserve">
          <source>Module Digest</source>
          <target state="translated">모듈 다이제스트</target>
        </trans-unit>
        <trans-unit id="8bbfa8ae15ecab1209610ac5a66a651f78875a78" translate="yes" xml:space="preserve">
          <source>Module Digest: MD5 message digest</source>
          <target state="translated">모듈 다이제스트 : MD5 메시지 다이제스트</target>
        </trans-unit>
        <trans-unit id="02c49caa12242dda259d7307d31dd98fda25b90d" translate="yes" xml:space="preserve">
          <source>Module Dynlink</source>
          <target state="translated">모듈 Dynlink</target>
        </trans-unit>
        <trans-unit id="17df668e4cee0361dd61ce759ea047d4ccf6ce2f" translate="yes" xml:space="preserve">
          <source>Module Dynlink: dynamic loading of bytecode object files</source>
          <target state="translated">모듈 Dynlink : 바이트 코드 객체 파일의 동적 로딩</target>
        </trans-unit>
        <trans-unit id="9c62be44cefe5016fcac970fcb981646c02e96b6" translate="yes" xml:space="preserve">
          <source>Module Ephemeron</source>
          <target state="translated">모듈 Ephemeron</target>
        </trans-unit>
        <trans-unit id="306ceb414fe45593e76183fffc1c6e8063a97af7" translate="yes" xml:space="preserve">
          <source>Module Ephemeron.GenHashTable</source>
          <target state="translated">모듈 Ephemeron.GenHashTable</target>
        </trans-unit>
        <trans-unit id="3c0d413a4c6a68f4547228b7fbcd4303cea78dd7" translate="yes" xml:space="preserve">
          <source>Module Ephemeron.K1</source>
          <target state="translated">모듈 Ephemeron.K1</target>
        </trans-unit>
        <trans-unit id="cc37a3b6fff03344d782218dfc93f84de56f0454" translate="yes" xml:space="preserve">
          <source>Module Ephemeron.K2</source>
          <target state="translated">모듈 Ephemeron.K2</target>
        </trans-unit>
        <trans-unit id="4dbed2786938f2a0e76b0e83d9e7aee1f6ba1c21" translate="yes" xml:space="preserve">
          <source>Module Ephemeron.Kn</source>
          <target state="translated">모듈 Ephemeron.Kn</target>
        </trans-unit>
        <trans-unit id="9bc16c26307d248abe81e5774136cc291bdc2f67" translate="yes" xml:space="preserve">
          <source>Module Ephemeron: Ephemerons and weak hash table</source>
          <target state="translated">모듈 Ephemeron : Ephemerons 및 약한 해시 테이블</target>
        </trans-unit>
        <trans-unit id="965c3d92c5cef899a73c03e9b00b354453a07c58" translate="yes" xml:space="preserve">
          <source>Module Event</source>
          <target state="translated">모듈 이벤트</target>
        </trans-unit>
        <trans-unit id="f6dd977ad9cdd9e33bfa766d7ff4615d50d92bac" translate="yes" xml:space="preserve">
          <source>Module Event: first-class synchronous communication</source>
          <target state="translated">모듈 이벤트 : 일류 동기식 통신</target>
        </trans-unit>
        <trans-unit id="95908861b116393327d9f6360c9aa8ce9f3fc3d9" translate="yes" xml:space="preserve">
          <source>Module Filename</source>
          <target state="translated">모듈 파일 이름</target>
        </trans-unit>
        <trans-unit id="2a2de638ce58f0d0a702b4d4f313c4f37216533f" translate="yes" xml:space="preserve">
          <source>Module Filename: operations on file names</source>
          <target state="translated">모듈 파일 이름 : 파일 이름에 대한 작업</target>
        </trans-unit>
        <trans-unit id="dbf4558ebef769a096f39fa6c0312334a381fec2" translate="yes" xml:space="preserve">
          <source>Module Float</source>
          <target state="translated">모듈 플로트</target>
        </trans-unit>
        <trans-unit id="c0ebb1cca64e0c8f91ce7a3e1f3ba4030ed3b8f4" translate="yes" xml:space="preserve">
          <source>Module Float.Array</source>
          <target state="translated">모듈 Float.Array</target>
        </trans-unit>
        <trans-unit id="445a0b0a1771a9581127d17829402c08430bebed" translate="yes" xml:space="preserve">
          <source>Module Float.ArrayLabels</source>
          <target state="translated">모듈 Float.ArrayLabels</target>
        </trans-unit>
        <trans-unit id="a3600f92b6696937343502269bc8090397c0e51e" translate="yes" xml:space="preserve">
          <source>Module Float: Floating-point numbers</source>
          <target state="translated">모듈 부동 : 부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="f2cecfe8e0ae9b3a901adc050a10fa4ea0c7797d" translate="yes" xml:space="preserve">
          <source>Module Format</source>
          <target state="translated">모듈 형식</target>
        </trans-unit>
        <trans-unit id="12bb5435b16c5c8b6ab86cf0323be7dcc9f30566" translate="yes" xml:space="preserve">
          <source>Module Format: pretty printing</source>
          <target state="translated">모듈 형식 : 예쁜 인쇄</target>
        </trans-unit>
        <trans-unit id="acb444a56b618a584c9cdb2f01ce73257415d59a" translate="yes" xml:space="preserve">
          <source>Module Fun</source>
          <target state="translated">모듈 재미</target>
        </trans-unit>
        <trans-unit id="40b410ee83d227d662e6b02df5f6cd601cb1762f" translate="yes" xml:space="preserve">
          <source>Module Fun: function values</source>
          <target state="translated">모듈 재미 : 함수 값</target>
        </trans-unit>
        <trans-unit id="d07aebf1d4ebd5c2e42b08423a93172511323b0f" translate="yes" xml:space="preserve">
          <source>Module Gc</source>
          <target state="translated">모듈 Gc</target>
        </trans-unit>
        <trans-unit id="ac86c6af7ac7bc4fc4841fea39b50ce532e9eae3" translate="yes" xml:space="preserve">
          <source>Module Gc.Memprof</source>
          <target state="translated">모듈 Gc. Memprof</target>
        </trans-unit>
        <trans-unit id="017db642bb8f1e27af62b289d7afc0311dfb9b9d" translate="yes" xml:space="preserve">
          <source>Module Gc: memory management control and statistics; finalized values</source>
          <target state="translated">모듈 Gc : 메모리 관리 제어 및 통계; 최종 값</target>
        </trans-unit>
        <trans-unit id="13184731a834066fef8c861de2b8b904d78a2c40" translate="yes" xml:space="preserve">
          <source>Module Genlex</source>
          <target state="translated">모듈 Genlex</target>
        </trans-unit>
        <trans-unit id="4ee3df3538f22bd946cb81aed2d740d6af4e43d7" translate="yes" xml:space="preserve">
          <source>Module Genlex: a generic lexical analyzer</source>
          <target state="translated">Module Genlex : 일반 어휘 분석기</target>
        </trans-unit>
        <trans-unit id="6d8fffbaf37dc886f091f1fcec194d70a8a56139" translate="yes" xml:space="preserve">
          <source>Module Hashtbl</source>
          <target state="translated">모듈 Hashtbl</target>
        </trans-unit>
        <trans-unit id="45ea31d5ad955fa4490b30ef1a1270d2c6392bda" translate="yes" xml:space="preserve">
          <source>Module Hashtbl: hash tables and hash functions</source>
          <target state="translated">모듈 Hashtbl : 해시 테이블 및 해시 함수</target>
        </trans-unit>
        <trans-unit id="49f5fed72bf1186b3606fcd64d3620ad4b5e6d3f" translate="yes" xml:space="preserve">
          <source>Module Int</source>
          <target state="translated">모듈 Int</target>
        </trans-unit>
        <trans-unit id="acab9c65663172b6b3cf63cdb91db7c853666939" translate="yes" xml:space="preserve">
          <source>Module Int32</source>
          <target state="translated">모듈 Int32</target>
        </trans-unit>
        <trans-unit id="59af84ad710fb152c38038123bed434bcda5ee5d" translate="yes" xml:space="preserve">
          <source>Module Int32: 32-bit integers</source>
          <target state="translated">모듈 Int32 : 32 비트 정수</target>
        </trans-unit>
        <trans-unit id="afb57e65a2c5001e2ebbf893ab00402f586e67a7" translate="yes" xml:space="preserve">
          <source>Module Int64</source>
          <target state="translated">모듈 Int64</target>
        </trans-unit>
        <trans-unit id="b5dcbf9b29416b9da9d5777bc0cbfff746fd3bff" translate="yes" xml:space="preserve">
          <source>Module Int64: 64-bit integers</source>
          <target state="translated">모듈 Int64 : 64 비트 정수</target>
        </trans-unit>
        <trans-unit id="c67951c6b0d56d43a8d0b9f4a75238e26b84e176" translate="yes" xml:space="preserve">
          <source>Module Int: integers</source>
          <target state="translated">Module Int : 정수</target>
        </trans-unit>
        <trans-unit id="6cbdc748b0a834da10d99ca83f0f783ca0b5c0b5" translate="yes" xml:space="preserve">
          <source>Module Lazy</source>
          <target state="translated">지연된 모듈</target>
        </trans-unit>
        <trans-unit id="6ed3c69956723eb0ea9cccf3b3f808a1e740d7bd" translate="yes" xml:space="preserve">
          <source>Module Lazy: deferred computations</source>
          <target state="translated">지연된 모듈 : 지연된 계산</target>
        </trans-unit>
        <trans-unit id="9d9af75cdf4a76dd0ace806f7dd01595ce9a4e7f" translate="yes" xml:space="preserve">
          <source>Module Lexing</source>
          <target state="translated">모듈 렉싱</target>
        </trans-unit>
        <trans-unit id="cda606f5e00de0f84675796ae085f4bffba696d6" translate="yes" xml:space="preserve">
          <source>Module Lexing: the run-time library for lexers generated by ocamllex</source>
          <target state="translated">Module Lexing : ocamllex에 의해 생성 된 렉서 용 런타임 라이브러리</target>
        </trans-unit>
        <trans-unit id="0ba47168d0ea302d6485e2bceea2a3d5ea07497a" translate="yes" xml:space="preserve">
          <source>Module List</source>
          <target state="translated">모듈 목록</target>
        </trans-unit>
        <trans-unit id="d95ac15be64ca43f1623a9f9232b997c5bf2c1d4" translate="yes" xml:space="preserve">
          <source>Module List: list operations</source>
          <target state="translated">모듈 목록 : 목록 작업</target>
        </trans-unit>
        <trans-unit id="daeda2f1f3fc9215afe3219e87ce40a8a991bc71" translate="yes" xml:space="preserve">
          <source>Module ListLabels</source>
          <target state="translated">모듈 목록 라벨</target>
        </trans-unit>
        <trans-unit id="9abd62669e68c48ade8c878e63da864a392f2017" translate="yes" xml:space="preserve">
          <source>Module ListLabels: list operations (with labels)</source>
          <target state="translated">모듈 ListLabels : 목록 작업 (레이블 포함)</target>
        </trans-unit>
        <trans-unit id="41eb27b154c8a0a9fe8b6fcd4251fc8ecd2542f7" translate="yes" xml:space="preserve">
          <source>Module Location: source code locations</source>
          <target state="translated">모듈 위치 : 소스 코드 위치</target>
        </trans-unit>
        <trans-unit id="09ea5f0fd44fa46552a5f30cbf18b1bf609af0ea" translate="yes" xml:space="preserve">
          <source>Module Longident: long identifiers</source>
          <target state="translated">모듈 Longident : 긴 식별자</target>
        </trans-unit>
        <trans-unit id="10b6935577db632331cb02bf7fee39599c44a34e" translate="yes" xml:space="preserve">
          <source>Module Map</source>
          <target state="translated">모듈 맵</target>
        </trans-unit>
        <trans-unit id="723c875a6e9814d580d5129ea7f70d98fe17170f" translate="yes" xml:space="preserve">
          <source>Module Map: association tables over ordered types</source>
          <target state="translated">모듈 맵 : 정렬 된 유형에 대한 연관 테이블</target>
        </trans-unit>
        <trans-unit id="996a073e0bd0499fc31006fad291c31374a4ad0a" translate="yes" xml:space="preserve">
          <source>Module Marshal</source>
          <target state="translated">모듈 마샬</target>
        </trans-unit>
        <trans-unit id="937c5df760edcb5aeb3c943766622a05d26ea688" translate="yes" xml:space="preserve">
          <source>Module Marshal: marshaling of data structures</source>
          <target state="translated">모듈 마샬 : 데이터 구조 마샬링</target>
        </trans-unit>
        <trans-unit id="2d7a3c934043e76f7e6aa5bab83a410c8b18ba72" translate="yes" xml:space="preserve">
          <source>Module MoreLabels</source>
          <target state="translated">모듈 More 라벨</target>
        </trans-unit>
        <trans-unit id="4b77f1b995f3d850723fe2d5f0d94f538cb8bc90" translate="yes" xml:space="preserve">
          <source>Module MoreLabels.Hashtbl</source>
          <target state="translated">모듈 MoreLabels.Hashtbl</target>
        </trans-unit>
        <trans-unit id="760a84c4680b6780dd84d385973bbf20f33f4210" translate="yes" xml:space="preserve">
          <source>Module MoreLabels.Map</source>
          <target state="translated">모듈 MoreLabels.Map</target>
        </trans-unit>
        <trans-unit id="25069e19c5b1b2db1e702799063dde780224c560" translate="yes" xml:space="preserve">
          <source>Module MoreLabels.Set</source>
          <target state="translated">모듈 MoreLabels.Set</target>
        </trans-unit>
        <trans-unit id="1b19605374bddf60dcda0218ce57f2d6c6393746" translate="yes" xml:space="preserve">
          <source>Module MoreLabels: Include modules Hashtbl, Map and Set with labels</source>
          <target state="translated">모듈 MoreLabels : 레이블이있는 Hashtbl, Map 및 Set 모듈 포함</target>
        </trans-unit>
        <trans-unit id="699fda78007ab6ee795d1ec46cb5ba0fadbcd152" translate="yes" xml:space="preserve">
          <source>Module Mutex</source>
          <target state="translated">모듈 뮤텍스</target>
        </trans-unit>
        <trans-unit id="9441c63e9620994d64788047f899a67dff634072" translate="yes" xml:space="preserve">
          <source>Module Mutex: locks for mutual exclusion</source>
          <target state="translated">모듈 뮤텍스 : 상호 배제를위한 잠금</target>
        </trans-unit>
        <trans-unit id="1838869d8ec86c1a2d37dff5dc780f83b0fec1d6" translate="yes" xml:space="preserve">
          <source>Module Nativeint</source>
          <target state="translated">모듈 Nativeint</target>
        </trans-unit>
        <trans-unit id="cc1d1c0c97415413ce2342a3f6f55d45834011c5" translate="yes" xml:space="preserve">
          <source>Module Nativeint: processor-native integers</source>
          <target state="translated">Module Nativeint : 프로세서 네이티브 정수</target>
        </trans-unit>
        <trans-unit id="7b4ea02830398a7975c1360e1989452b5c984a6e" translate="yes" xml:space="preserve">
          <source>Module Obj</source>
          <target state="translated">모듈 Obj</target>
        </trans-unit>
        <trans-unit id="272ea9eeccbd009ebb96e6b41a649184070812a9" translate="yes" xml:space="preserve">
          <source>Module Obj.Ephemeron</source>
          <target state="translated">모듈 Obj.Ephemeron</target>
        </trans-unit>
        <trans-unit id="85d7d19a5339d91797722162ab420ee924fd4061" translate="yes" xml:space="preserve">
          <source>Module Obj.Extension_constructor</source>
          <target state="translated">모듈 Obj.Extension_constructor</target>
        </trans-unit>
        <trans-unit id="5fe9ce284b5e4679d29a8e61897d87de3d56edfa" translate="yes" xml:space="preserve">
          <source>Module Oo</source>
          <target state="translated">모듈 Oo</target>
        </trans-unit>
        <trans-unit id="5ab66589e35c123c9f9433f57b4d129d3e642f10" translate="yes" xml:space="preserve">
          <source>Module Oo: object-oriented extension</source>
          <target state="translated">모듈 Oo : 객체 지향 확장</target>
        </trans-unit>
        <trans-unit id="552e8a4259199d9b2043147a832aca29c2875d9a" translate="yes" xml:space="preserve">
          <source>Module Option</source>
          <target state="translated">모듈 옵션</target>
        </trans-unit>
        <trans-unit id="aa8d3db6fe714bb3b01fd318b7f50f3a7d37c609" translate="yes" xml:space="preserve">
          <source>Module Option: option values</source>
          <target state="translated">모듈 옵션 : 옵션 값</target>
        </trans-unit>
        <trans-unit id="ee462040d70476901068cb4b27d7246c72808b85" translate="yes" xml:space="preserve">
          <source>Module Parse: OCaml syntax parsing</source>
          <target state="translated">모듈 구문 분석 : OCaml 구문 구문 분석</target>
        </trans-unit>
        <trans-unit id="caf367dbe7aff2e9ccc52d81e33ebb4ebae22ff7" translate="yes" xml:space="preserve">
          <source>Module Parsetree: OCaml syntax tree</source>
          <target state="translated">모듈 Parsetree : OCaml 구문 트리</target>
        </trans-unit>
        <trans-unit id="7614cdd9f0ec33aa4685f6bd34afeb038456c5ae" translate="yes" xml:space="preserve">
          <source>Module Parsing</source>
          <target state="translated">모듈 구문 분석</target>
        </trans-unit>
        <trans-unit id="674971f0c437aab44e4076ee335788a7f95f2d06" translate="yes" xml:space="preserve">
          <source>Module Parsing: the run-time library for parsers generated by ocamlyacc</source>
          <target state="translated">모듈 구문 분석 : ocamlyacc에 의해 생성 된 구문 분석기를위한 런타임 라이브러리</target>
        </trans-unit>
        <trans-unit id="c5588d487861f64669575fcb69cb5b074b4f41fb" translate="yes" xml:space="preserve">
          <source>Module Pervasives: deprecated alias for Stdlib</source>
          <target state="translated">Module Pervasives : Stdlib의 더 이상 사용되지 않는 별칭</target>
        </trans-unit>
        <trans-unit id="1a1dc73aec1ccbac02b8e8f43ee58892b59b0745" translate="yes" xml:space="preserve">
          <source>Module Pprintast: OCaml syntax printing</source>
          <target state="translated">모듈 Pprintast : OCaml 구문 인쇄</target>
        </trans-unit>
        <trans-unit id="b5e430425b7a707621c40fc5db568b1422825347" translate="yes" xml:space="preserve">
          <source>Module Printexc</source>
          <target state="translated">모듈 Printexc</target>
        </trans-unit>
        <trans-unit id="c879b5b58ad9c94051bbfc78df7ae8670b40859d" translate="yes" xml:space="preserve">
          <source>Module Printexc.Slot</source>
          <target state="translated">모듈 Printexc. 슬롯</target>
        </trans-unit>
        <trans-unit id="72f9916225d741d402336a087d22708a6a08547d" translate="yes" xml:space="preserve">
          <source>Module Printexc: facilities for printing exceptions</source>
          <target state="translated">모듈 Printexc : 예외 인쇄 기능</target>
        </trans-unit>
        <trans-unit id="8ef8e2302f5298816f3c9a62eb7ff84ee4558dc9" translate="yes" xml:space="preserve">
          <source>Module Printf</source>
          <target state="translated">모듈 Printf</target>
        </trans-unit>
        <trans-unit id="0f2f2beac76b39281ec8d02c364037eaeb98cbcb" translate="yes" xml:space="preserve">
          <source>Module Printf: formatting printing functions</source>
          <target state="translated">Module Printf : 인쇄 기능 서식 지정</target>
        </trans-unit>
        <trans-unit id="e12960179cefb13cef1a39ceeab8802831a8d8f8" translate="yes" xml:space="preserve">
          <source>Module Queue</source>
          <target state="translated">모듈 대기열</target>
        </trans-unit>
        <trans-unit id="053310d8755ceed37f1727f1d1a1abcfeefaea2f" translate="yes" xml:space="preserve">
          <source>Module Queue: first-in first-out queues</source>
          <target state="translated">모듈 대기열 : 선입 선출 대기열</target>
        </trans-unit>
        <trans-unit id="ef161e448a0a073f4c747dde06ec44412c5ae309" translate="yes" xml:space="preserve">
          <source>Module Random</source>
          <target state="translated">모듈 랜덤</target>
        </trans-unit>
        <trans-unit id="1b8723087c253ef44125a63809350dd54cc9e5e8" translate="yes" xml:space="preserve">
          <source>Module Random.State</source>
          <target state="translated">모듈 Random.State</target>
        </trans-unit>
        <trans-unit id="0dfee50267f747d0f1636dd29878bc9fbb3994b9" translate="yes" xml:space="preserve">
          <source>Module Random: pseudo-random number generator (PRNG)</source>
          <target state="translated">모듈 랜덤 : 의사 난수 생성기 (PRNG)</target>
        </trans-unit>
        <trans-unit id="14e0c591450e8a2f60ddb8562b4eb14af09e5b51" translate="yes" xml:space="preserve">
          <source>Module Result</source>
          <target state="translated">모듈 결과</target>
        </trans-unit>
        <trans-unit id="5eafde20b375d72096c25a3285f206655630e2ae" translate="yes" xml:space="preserve">
          <source>Module Result: result values</source>
          <target state="translated">모듈 결과 : 결과 값</target>
        </trans-unit>
        <trans-unit id="49dde4ae279ace1dea00b588ae3d4054f614e24e" translate="yes" xml:space="preserve">
          <source>Module Scanf</source>
          <target state="translated">모듈 스캔</target>
        </trans-unit>
        <trans-unit id="9aa3fa82fa6bc6d8e6dabdd6356bda9b0137aefa" translate="yes" xml:space="preserve">
          <source>Module Scanf.Scanning</source>
          <target state="translated">모듈 스캔 f. 스캔</target>
        </trans-unit>
        <trans-unit id="93459bcb89eeedf8df411de000f7c2b7c9780503" translate="yes" xml:space="preserve">
          <source>Module Scanf: formatted input functions</source>
          <target state="translated">Module Scanf : 형식화 된 입력 함수</target>
        </trans-unit>
        <trans-unit id="f5360c938c49ae1cd63d56a4fc35fd3890f06a01" translate="yes" xml:space="preserve">
          <source>Module Seq</source>
          <target state="translated">모듈 시퀀스</target>
        </trans-unit>
        <trans-unit id="745c27dde866b15642e25a8b7002225f218d5efe" translate="yes" xml:space="preserve">
          <source>Module Seq: functional iterators</source>
          <target state="translated">모듈 시퀀스 : 기능 반복자</target>
        </trans-unit>
        <trans-unit id="2e0b5bb25d996e8a2a59e644edb186eb56df4a38" translate="yes" xml:space="preserve">
          <source>Module Set</source>
          <target state="translated">모듈 세트</target>
        </trans-unit>
        <trans-unit id="67541933874b03516f40829e2167ebbae9f49f77" translate="yes" xml:space="preserve">
          <source>Module Set: sets over ordered types</source>
          <target state="translated">모듈 세트 : 주문 된 유형에 대한 세트</target>
        </trans-unit>
        <trans-unit id="eb15bed9d67a6d8605a1857d27cc2f85878fa8b5" translate="yes" xml:space="preserve">
          <source>Module Spacetime</source>
          <target state="translated">모듈 시공간</target>
        </trans-unit>
        <trans-unit id="34b13666199abdbce5a1c2329aac36b498b7e871" translate="yes" xml:space="preserve">
          <source>Module Spacetime.Series</source>
          <target state="translated">모듈 Spacetime.Series</target>
        </trans-unit>
        <trans-unit id="4ed586d95f752bc00d8837393fbda372cb0681cb" translate="yes" xml:space="preserve">
          <source>Module Spacetime.Snapshot</source>
          <target state="translated">모듈 Spacetime.Snapshot</target>
        </trans-unit>
        <trans-unit id="c3ff8e88da485589309cef464360394198823612" translate="yes" xml:space="preserve">
          <source>Module Spacetime: memory profiler</source>
          <target state="translated">모듈 시공간 : 메모리 프로파일 러</target>
        </trans-unit>
        <trans-unit id="49d4f336aa17896a5ff3ff9448ea7a4608c970ea" translate="yes" xml:space="preserve">
          <source>Module Stack</source>
          <target state="translated">모듈 스택</target>
        </trans-unit>
        <trans-unit id="ecef102202227813e5a4bf6e1e72dfe223f093c2" translate="yes" xml:space="preserve">
          <source>Module Stack: last-in first-out stacks</source>
          <target state="translated">모듈 스택 : 후입 선출 스택</target>
        </trans-unit>
        <trans-unit id="958de5433af391dd3de782eaa1308532356d8dda" translate="yes" xml:space="preserve">
          <source>Module StdLabels</source>
          <target state="translated">모듈 StdLabels</target>
        </trans-unit>
        <trans-unit id="5c6cfb9453daaec927ca632937f9ea620e55191b" translate="yes" xml:space="preserve">
          <source>Module StdLabels.Array</source>
          <target state="translated">모듈 StdLabels.Array</target>
        </trans-unit>
        <trans-unit id="18fabd24c30510aa2b8a03d1edb5b5d1ecd2653b" translate="yes" xml:space="preserve">
          <source>Module StdLabels.Bytes</source>
          <target state="translated">모듈 StdLabels.Bytes</target>
        </trans-unit>
        <trans-unit id="6d01f040c78ef0b845f05e2b484d4280c974e590" translate="yes" xml:space="preserve">
          <source>Module StdLabels.List</source>
          <target state="translated">모듈 StdLabels.List</target>
        </trans-unit>
        <trans-unit id="1cd5288d0fdc22e9eb53ef8ba091154cc4f412a2" translate="yes" xml:space="preserve">
          <source>Module StdLabels.String</source>
          <target state="translated">모듈 StdLabels.String</target>
        </trans-unit>
        <trans-unit id="6319cdcea700dd1fcd120036bbd03d1e43944c48" translate="yes" xml:space="preserve">
          <source>Module StdLabels: Include modules Array, List and String with labels</source>
          <target state="translated">모듈 StdLabels : 레이블이있는 모듈 배열, 목록 및 문자열 포함</target>
        </trans-unit>
        <trans-unit id="ec7ff76184d2e7ae3e758550a03699c6d8049bc7" translate="yes" xml:space="preserve">
          <source>Module Stdlib</source>
          <target state="translated">모듈 Stdlib</target>
        </trans-unit>
        <trans-unit id="2c4a0131cb2ed42ae1c9005e8a590e1a54091746" translate="yes" xml:space="preserve">
          <source>Module Stdlib: the initially opened module</source>
          <target state="translated">모듈 Stdlib : 처음에 열린 모듈</target>
        </trans-unit>
        <trans-unit id="c5e94b392b5c848b46e6e013f4fd8019d3c00a4e" translate="yes" xml:space="preserve">
          <source>Module Str</source>
          <target state="translated">모듈 Str</target>
        </trans-unit>
        <trans-unit id="7a5614285483e72abcf9faabc441c693739ffb77" translate="yes" xml:space="preserve">
          <source>Module Str: regular expressions and string processing</source>
          <target state="translated">모듈 Str : 정규식 및 문자열 처리</target>
        </trans-unit>
        <trans-unit id="7f7138e5bba47e7b41c63652637ee7a8b037bea0" translate="yes" xml:space="preserve">
          <source>Module Stream</source>
          <target state="translated">모듈 스트림</target>
        </trans-unit>
        <trans-unit id="a10278f414b080e077e13858c56aa56fde51bd41" translate="yes" xml:space="preserve">
          <source>Module Stream: streams and parsers</source>
          <target state="translated">모듈 스트림 : 스트림 및 파서</target>
        </trans-unit>
        <trans-unit id="14ab9c78a29a26ab6d1cdf26aea5144a4e15f83e" translate="yes" xml:space="preserve">
          <source>Module String</source>
          <target state="translated">모듈 문자열</target>
        </trans-unit>
        <trans-unit id="70d219088316f00d44e6354f32e38b06be5fe6f8" translate="yes" xml:space="preserve">
          <source>Module String: string operations</source>
          <target state="translated">모듈 문자열 : 문자열 작업</target>
        </trans-unit>
        <trans-unit id="cc3e85713ed5e07464558eda70637c5642cbf379" translate="yes" xml:space="preserve">
          <source>Module StringLabels</source>
          <target state="translated">모듈 StringLabels</target>
        </trans-unit>
        <trans-unit id="ac95abe374ec440091969c5ee120b8542ebb8f77" translate="yes" xml:space="preserve">
          <source>Module StringLabels: string operations (with labels)</source>
          <target state="translated">모듈 StringLabels : 문자열 연산 (레이블 포함)</target>
        </trans-unit>
        <trans-unit id="6d5b8544f315aab96f8817d79bb089eae9451184" translate="yes" xml:space="preserve">
          <source>Module Sys</source>
          <target state="translated">모듈 시스템</target>
        </trans-unit>
        <trans-unit id="958984972bc48fce8fefbe326a85479ad724c6a0" translate="yes" xml:space="preserve">
          <source>Module Sys.Immediate64</source>
          <target state="translated">모듈 Sys.Immediate64</target>
        </trans-unit>
        <trans-unit id="629ea4ee2faa04c5bb6a3adf93e15571e0d8394e" translate="yes" xml:space="preserve">
          <source>Module Sys: system interface</source>
          <target state="translated">모듈 시스템 : 시스템 인터페이스</target>
        </trans-unit>
        <trans-unit id="48051dde4d899f8ff82f4d3479ec93c3c7647b0f" translate="yes" xml:space="preserve">
          <source>Module Thread</source>
          <target state="translated">모듈 스레드</target>
        </trans-unit>
        <trans-unit id="a862836a470588219a4249125bd8f10755fd16b0" translate="yes" xml:space="preserve">
          <source>Module Thread: lightweight threads</source>
          <target state="translated">모듈 스레드 : 경량 스레드</target>
        </trans-unit>
        <trans-unit id="9156d38a7fa11dbaedc16f3d0706294aac2ebee0" translate="yes" xml:space="preserve">
          <source>Module ThreadUnix</source>
          <target state="translated">모듈 ThreadUnix</target>
        </trans-unit>
        <trans-unit id="a6798276f98df7d87c62baea2b0202dd5654a1c0" translate="yes" xml:space="preserve">
          <source>Module ThreadUnix: thread-compatible system calls</source>
          <target state="translated">Module ThreadUnix : 스레드 호환 시스템 호출</target>
        </trans-unit>
        <trans-unit id="dd9e553dcec01d6ecdaeef8c6bce2f1ed535807c" translate="yes" xml:space="preserve">
          <source>Module Uchar</source>
          <target state="translated">모듈 Uchar</target>
        </trans-unit>
        <trans-unit id="61e8da370a37852b69424f5d308f6e8b6a190cbb" translate="yes" xml:space="preserve">
          <source>Module Uchar: Unicode characters</source>
          <target state="translated">모듈 Uchar : 유니 코드 문자</target>
        </trans-unit>
        <trans-unit id="16ecb69a288aecc5495371b2c1779751b68e31b4" translate="yes" xml:space="preserve">
          <source>Module Unit</source>
          <target state="translated">모듈 단위</target>
        </trans-unit>
        <trans-unit id="2ba1b1b3ef272d41eba2286920064169778f337d" translate="yes" xml:space="preserve">
          <source>Module Unit: unit values</source>
          <target state="translated">모듈 단위 : 단위 값</target>
        </trans-unit>
        <trans-unit id="1792b1adb6606ac02ca5a4965131d6116d82599a" translate="yes" xml:space="preserve">
          <source>Module Unix</source>
          <target state="translated">모듈 유닉스</target>
        </trans-unit>
        <trans-unit id="68685cf371d09d0be037c8891fdbb041a6955bb4" translate="yes" xml:space="preserve">
          <source>Module Unix.LargeFile</source>
          <target state="translated">모듈 Unix.LargeFile</target>
        </trans-unit>
        <trans-unit id="c09a1e52642105e9e7b0b8457efac3458d40b0f0" translate="yes" xml:space="preserve">
          <source>Module Unix: Unix system calls</source>
          <target state="translated">모듈 유닉스 : 유닉스 시스템 호출</target>
        </trans-unit>
        <trans-unit id="e446500e934433078817abf2e14140a9f2567531" translate="yes" xml:space="preserve">
          <source>Module UnixLabels</source>
          <target state="translated">모듈 UnixLabels</target>
        </trans-unit>
        <trans-unit id="29d97bc7771ac286b2f7fa8d869eb8a2a0f2e806" translate="yes" xml:space="preserve">
          <source>Module UnixLabels.LargeFile</source>
          <target state="translated">모듈 UnixLabels.LargeFile</target>
        </trans-unit>
        <trans-unit id="bbc3a336379a1ab64349969278912adaf93249f4" translate="yes" xml:space="preserve">
          <source>Module UnixLabels: Labeled Unix system calls</source>
          <target state="translated">모듈 UnixLabels : 레이블이있는 Unix 시스템 호출</target>
        </trans-unit>
        <trans-unit id="d87aa68b013503ed8844fab06b1f94a6cf80b676" translate="yes" xml:space="preserve">
          <source>Module Weak</source>
          <target state="translated">약한 모듈</target>
        </trans-unit>
        <trans-unit id="c0fbea6de11552e58adf74acc30f65573ee8b35b" translate="yes" xml:space="preserve">
          <source>Module Weak: arrays of weak pointers</source>
          <target state="translated">약한 모듈 : 약한 포인터 배열</target>
        </trans-unit>
        <trans-unit id="331d2760734f7e482dfad8fe98cac289cb021696" translate="yes" xml:space="preserve">
          <source>Module expressions are the module-level equivalent of value expressions: they evaluate to modules, thus providing implementations for the specifications expressed in module types.</source>
          <target state="translated">모듈 표현식은 값 표현식에 해당하는 모듈 수준입니다. 모듈로 평가되어 모듈 유형으로 표현 된 사양에 대한 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bbd0d4a8e429ad9704ed8561d8b8ccf363cf691b" translate="yes" xml:space="preserve">
          <source>Module type Ephemeron.S</source>
          <target state="translated">모듈 유형 Ephemeron.S</target>
        </trans-unit>
        <trans-unit id="5ba5bbb64dc581113ae02747f71e2e95524ad670" translate="yes" xml:space="preserve">
          <source>Module type Ephemeron.SeededS</source>
          <target state="translated">모듈 유형 Ephemeron. SeededS</target>
        </trans-unit>
        <trans-unit id="e7fc3d9e09cfcef4e28717f43e53f614492c4a07" translate="yes" xml:space="preserve">
          <source>Module type Hashtbl.HashedType</source>
          <target state="translated">모듈 유형 Hashtbl.HashedType</target>
        </trans-unit>
        <trans-unit id="553e3c5393f8ee87abd320792f53df0480a89437" translate="yes" xml:space="preserve">
          <source>Module type Hashtbl.S</source>
          <target state="translated">모듈 유형 Hashtbl.S</target>
        </trans-unit>
        <trans-unit id="d4f4885e8e252ac679a71b98e38ae6b36bec3794" translate="yes" xml:space="preserve">
          <source>Module type Hashtbl.SeededHashedType</source>
          <target state="translated">모듈 유형 Hashtbl.SeededHashedType</target>
        </trans-unit>
        <trans-unit id="19a7fd61f14defb9b6e4cfd12105dcf424fb68dc" translate="yes" xml:space="preserve">
          <source>Module type Hashtbl.SeededS</source>
          <target state="translated">모듈 유형 Hashtbl. SeededS</target>
        </trans-unit>
        <trans-unit id="c3a914203d81a68cd8f34d38dd3525c65fb9c5ba" translate="yes" xml:space="preserve">
          <source>Module type Map.OrderedType</source>
          <target state="translated">모듈 유형 Map.OrderedType</target>
        </trans-unit>
        <trans-unit id="d326bc02f7f0598bde27deba9a371a4e51379f13" translate="yes" xml:space="preserve">
          <source>Module type Map.S</source>
          <target state="translated">모듈 유형 Map.S</target>
        </trans-unit>
        <trans-unit id="d9f4fc879c6159477aa40865bb89618115962c18" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Hashtbl.HashedType</source>
          <target state="translated">모듈 유형 MoreLabels.Hashtbl.HashedType</target>
        </trans-unit>
        <trans-unit id="fac1d1343fd73a7f1801158d9ea0bc13f5f2438e" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Hashtbl.S</source>
          <target state="translated">모듈 유형 MoreLabels.Hashtbl.S</target>
        </trans-unit>
        <trans-unit id="227008c4795726cb8535f817b67718075184d4b4" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Hashtbl.SeededHashedType</source>
          <target state="translated">모듈 유형 MoreLabels.Hashtbl.SeededHashedType</target>
        </trans-unit>
        <trans-unit id="378116ae1fbf467ddaea54a32b51349c6761a1c1" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Hashtbl.SeededS</source>
          <target state="translated">모듈 유형 MoreLabels.Hashtbl.SeededS</target>
        </trans-unit>
        <trans-unit id="3ae291b8f1ed6643e66aaa62f2bc341a327d4675" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Map.OrderedType</source>
          <target state="translated">모듈 유형 MoreLabels.Map.OrderedType</target>
        </trans-unit>
        <trans-unit id="7154f17264fbac973b9fa0370b2c6d6369cde11d" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Map.S</source>
          <target state="translated">모듈 유형 MoreLabels.Map.S</target>
        </trans-unit>
        <trans-unit id="a999b8bf8010daee6d4715724a5de3c63e349192" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Set.OrderedType</source>
          <target state="translated">모듈 유형 MoreLabels.Set.OrderedType</target>
        </trans-unit>
        <trans-unit id="10f02d0b490b6bd1c3b28accd09985393baabab9" translate="yes" xml:space="preserve">
          <source>Module type MoreLabels.Set.S</source>
          <target state="translated">모듈 유형 MoreLabels.Set.S</target>
        </trans-unit>
        <trans-unit id="05df05949b4417b3b5d633c96eec842e5cc5a73c" translate="yes" xml:space="preserve">
          <source>Module type Set.OrderedType</source>
          <target state="translated">모듈 유형 Set.OrderedType</target>
        </trans-unit>
        <trans-unit id="0540217cacc40a66bb6b0dcbe128de08a49bb684" translate="yes" xml:space="preserve">
          <source>Module type Set.S</source>
          <target state="translated">모듈 유형 Set.S</target>
        </trans-unit>
        <trans-unit id="6682efa59e414919e3f347ffa12dbd5a9ef7d4b0" translate="yes" xml:space="preserve">
          <source>Module type Sys.Immediate64.Immediate</source>
          <target state="translated">모듈 유형 Sys.Immediate64.Immediate</target>
        </trans-unit>
        <trans-unit id="c6a12e0efd39177b624b9104a3d6be80c5fdf8d7" translate="yes" xml:space="preserve">
          <source>Module type Sys.Immediate64.Non_immediate</source>
          <target state="translated">모듈 유형 Sys.Immediate64.Non_immediate</target>
        </trans-unit>
        <trans-unit id="4946361a74879d2b9ef81babbb5a11b0fd75747a" translate="yes" xml:space="preserve">
          <source>Module type Weak.S</source>
          <target state="translated">모듈 유형 Weak.S</target>
        </trans-unit>
        <trans-unit id="e18ca9fec937a1c5383f1670e1007cb899397310" translate="yes" xml:space="preserve">
          <source>Module types</source>
          <target state="translated">모듈 유형</target>
        </trans-unit>
        <trans-unit id="c5882558195a629df9610d22ab7a2bb696dfa08e" translate="yes" xml:space="preserve">
          <source>Module types are the module-level equivalent of type expressions: they specify the general shape and type properties of modules.</source>
          <target state="translated">모듈 유형은 유형 표현식에 해당하는 모듈 수준입니다. 모듈의 일반적인 모양과 유형 속성을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="1bdeaa58662002456132d5e4df075bf678e694ae" translate="yes" xml:space="preserve">
          <source>Modules are typically thought of as static components. This extension makes it possible to pack a module as a first-class value, which can later be dynamically unpacked into a module.</source>
          <target state="translated">모듈은 일반적으로 정적 구성 요소로 간주됩니다. 이 확장을 사용하면 모듈을 일급 값으로 압축 할 수 있으며 나중에 모듈로 동적으로 압축을 풀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb3f2d6730fda28eebf828a1b5d994ee25cda13c" translate="yes" xml:space="preserve">
          <source>Month of year 0..11</source>
          <target state="translated">0..11 년의 달</target>
        </trans-unit>
        <trans-unit id="7368e316821f8931f19a457402e063b7f5ee9a7c" translate="yes" xml:space="preserve">
          <source>More character operations are provided in module &lt;a href=&quot;char&quot;&gt;&lt;code&gt;Char&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 많은 문자 연산이 &lt;a href=&quot;char&quot;&gt; &lt;code&gt;Char&lt;/code&gt; &lt;/a&gt; 모듈에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="98c4048d66ba3c4b91263b34fa74fb272d60a783" translate="yes" xml:space="preserve">
          <source>More complex standalone OCaml programs are typically composed of multiple source files, and can link with precompiled libraries. Chapters &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; and &lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt; explain how to use the batch compilers ocamlc and ocamlopt. Recompilation of multi-file OCaml projects can be automated using third-party build systems, such as the &lt;a href=&quot;https://github.com/ocaml/ocamlbuild/&quot;&gt;ocamlbuild&lt;/a&gt; compilation manager.</source>
          <target state="translated">더 복잡한 독립형 OCaml 프로그램은 일반적으로 여러 소스 파일로 구성되며 미리 컴파일 된 라이브러리와 연결할 수 있습니다. &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; 장 과 &lt;a href=&quot;native#c%3Anativecomp&quot;&gt;12&lt;/a&gt; 장 에서는 배치 컴파일러 ocamlc 및 ocamlopt를 사용하는 방법을 설명합니다. &lt;a href=&quot;https://github.com/ocaml/ocamlbuild/&quot;&gt;ocamlbuild&lt;/a&gt; 컴파일 관리자 와 같은 타사 빌드 시스템을 사용하여 다중 파일 OCaml 프로젝트의 재 컴파일을 자동화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="561b0023eb18eba22354cdb393742a8b59c73c03" translate="yes" xml:space="preserve">
          <source>More examples of binary methods can be found in sections &lt;a href=&quot;advexamples#ss%3Astring-as-class&quot;&gt;6.2.1&lt;/a&gt; and &lt;a href=&quot;advexamples#ss%3Aset-as-class&quot;&gt;6.2.3&lt;/a&gt;.</source>
          <target state="translated">이진 방법의 더 많은 예는 섹션 &lt;a href=&quot;advexamples#ss%3Astring-as-class&quot;&gt;6.2.1&lt;/a&gt; 및 &lt;a href=&quot;advexamples#ss%3Aset-as-class&quot;&gt;6.2.3&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51d19b2b2f97ccba7609ee2b5ad377c0b117b048" translate="yes" xml:space="preserve">
          <source>More formatters can be created with &lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt;&lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;format#VALformatter_of_buffer&quot;&gt;&lt;code&gt;Format.formatter_of_buffer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;format#VALformatter_of_symbolic_output_buffer&quot;&gt;&lt;code&gt;Format.formatter_of_symbolic_output_buffer&lt;/code&gt;&lt;/a&gt; or using &lt;a href=&quot;format#formatter&quot;&gt;custom formatters&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;format#VALformatter_of_out_channel&quot;&gt; &lt;code&gt;Format.formatter_of_out_channel&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;format#VALformatter_of_buffer&quot;&gt; &lt;code&gt;Format.formatter_of_buffer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;format#VALformatter_of_symbolic_output_buffer&quot;&gt; &lt;code&gt;Format.formatter_of_symbolic_output_buffer&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;format#formatter&quot;&gt;사용자 지정 포맷터를&lt;/a&gt; 사용하여 더 많은 포맷터를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6948d057e07078f31d8b94099955db506d318be0" translate="yes" xml:space="preserve">
          <source>More generally, as soon as a type variable appears in a position describing mutable state it becomes invariant. As a corollary, covariant variables will never denote mutable locations and can be safely generalized. For a better description, interested readers can consult the original article by Jacques Garrigue on &lt;a href=&quot;http://www.math.nagoya-u.ac.jp/~garrigue/papers/morepoly-long.pdf&quot;&gt;http://www.math.nagoya-u.ac.jp/~garrigue/papers/morepoly-long.pdf&lt;/a&gt;</source>
          <target state="translated">보다 일반적으로, 유형 변수가 가변 상태를 설명하는 위치에 나타나 자마자 불변이됩니다. 결과적으로 공변 변수는 변경 가능한 위치를 나타내지 않으며 안전하게 일반화 될 수 있습니다. 더 나은 설명을 위해 관심있는 독자는 &lt;a href=&quot;http://www.math.nagoya-u.ac.jp/~garrigue/papers/morepoly-long.pdf&quot;&gt;http://www.math.nagoya-u.ac.jp/~garrigue/papers/morepoly-long.pdf에서&lt;/a&gt; Jacques Garrigue의 원본 기사를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c805dcb67ff19c680fa8d577587f09aa3b1df1b0" translate="yes" xml:space="preserve">
          <source>More important is the fact that polymorphic variants, while being type-safe, result in a weaker type discipline. That is, core language variants do actually much more than ensuring type-safety, they also check that you use only declared constructors, that all constructors present in a data-structure are compatible, and they enforce typing constraints to their parameters.</source>
          <target state="translated">더 중요한 것은 다형성 변형이 형식에 안전하지만 형식 규율이 약하다는 사실입니다. 즉, 핵심 언어 변형은 실제로 형식 안전성을 보장하는 것 이상을 수행하고 선언 된 생성자 만 사용하는지, 데이터 구조에있는 모든 생성자가 호환되는지, 매개 변수에 대한 입력 제약 조건을 적용하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e832f6beb4577f420972cdf48bcfee3bb6d20aec" translate="yes" xml:space="preserve">
          <source>More list operations are provided in module &lt;a href=&quot;list&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 많은 목록 작업은 모듈 &lt;a href=&quot;list&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="e0c233b3a7dba4306b68b837cdcd9f763220099a" translate="yes" xml:space="preserve">
          <source>More precisely, consider the expression:</source>
          <target state="translated">더 정확하게는 다음 표현을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2403a8574f06c5e570469506e110ecacf6fc95f8" translate="yes" xml:space="preserve">
          <source>More precisely: when a semantic tag is opened or closed then both and successive 'tag-printing' and 'tag-marking' operations occur:</source>
          <target state="translated">보다 정확하게 : 의미 론적 태그가 열리거나 닫히면 연속적인 '태그 인쇄'및 '태그 표시'작업이 모두 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f9eabc59e9a2d75ca1154fdc14a5cb14b6f18138" translate="yes" xml:space="preserve">
          <source>More string operations are provided in module &lt;a href=&quot;string&quot;&gt;&lt;code&gt;String&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">더 많은 문자열 연산이 &lt;a href=&quot;string&quot;&gt; &lt;code&gt;String&lt;/code&gt; &lt;/a&gt; 모듈에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="20302dcfb13e0aacdfb918a9998d06e11ec681a9" translate="yes" xml:space="preserve">
          <source>MoreLabels</source>
          <target state="translated">MoreLabels</target>
        </trans-unit>
        <trans-unit id="f2d9c7352bab5b013f1b4948abc890b999a592c8" translate="yes" xml:space="preserve">
          <source>Moreover, being the last defined type is a quite unstable position that may change surreptitiously after adding or moving around a type definition, or after opening a module (see chapter &lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt;). Consequently, adding explicit type annotations to guide disambiguation is more robust than relying on the last defined type disambiguation.</source>
          <target state="translated">더욱이, 마지막으로 정의 된 유형이되는 것은 유형 정의를 추가하거나 이동 한 후 또는 모듈을 연 후에 은밀하게 변경 될 수있는 매우 불안정한 위치입니다 ( &lt;a href=&quot;moduleexamples#c%3Amoduleexamples&quot;&gt;2&lt;/a&gt; 장 참조 ). 결과적으로 명확성을 안내하기 위해 명시 적 유형 주석을 추가하는 것이 마지막으로 정의 된 유형 명확화에 의존하는 것보다 더 강력합니다.</target>
        </trans-unit>
        <trans-unit id="b575cbbaf8906b9c5a5ee4c9f1a89643a318a7a5" translate="yes" xml:space="preserve">
          <source>Moreover, opening a box after the &lt;a href=&quot;format#maxindent&quot;&gt;maximum indentation limit&lt;/a&gt; splits the line whether or not the box would end up fitting on the line.</source>
          <target state="translated">더욱이, &lt;a href=&quot;format#maxindent&quot;&gt;최대 들여 쓰기 한도&lt;/a&gt; 이후에 상자를 열면 상자 가 라인에 맞춰 지는지 여부에 관계없이 라인이 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="4bacee78a2fc3a758d3d73b2a613831022d03403" translate="yes" xml:space="preserve">
          <source>Moreover, the table shouldn't be modified during a call to &lt;code&gt;iter&lt;/code&gt;. Use &lt;code&gt;filter_map_inplace&lt;/code&gt; in this case.</source>
          <target state="translated">또한 &lt;code&gt;iter&lt;/code&gt; 를 호출하는 동안 테이블을 수정해서는 안됩니다 . 이 경우 &lt;code&gt;filter_map_inplace&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="938a8c4d2e6fe32d5784eafdd62df55fa7c40576" translate="yes" xml:space="preserve">
          <source>Moreover, weak types cannot appear in the signature of toplevel modules: types must be known at compilation time. Otherwise, different compilation units could replace the weak type with different and incompatible types. For this reason, compiling the following small piece of code</source>
          <target state="translated">또한 약한 유형은 최상위 모듈의 시그니처에 나타날 수 없습니다. 유형은 컴파일 타임에 알려야합니다. 그렇지 않으면 다른 컴파일 단위가 약한 유형을 다른 호환되지 않는 유형으로 대체 할 수 있습니다. 이러한 이유로 다음과 같은 작은 코드를 컴파일하면</target>
        </trans-unit>
        <trans-unit id="3770beeb0150f7b961905b2a3287d7d10a959428" translate="yes" xml:space="preserve">
          <source>Moreover, when the type definitions are exposed, the type checker is able to infer variance information on its own and one can benefit from the relaxed value restriction even unknowingly. However, this is not the case anymore when defining new abstract types. As an illustration, we can define a module type collection as:</source>
          <target state="translated">또한 유형 정의가 노출되면 유형 검사기가 자체적으로 분산 정보를 추론 할 수 있으며 무의식적으로도 완화 된 값 제한의 이점을 누릴 수 있습니다. 그러나 새로운 추상 유형을 정의 할 때는 더 이상 그렇지 않습니다. 예를 들어, 모듈 유형 컬렉션을 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce25d2287fa6866cf43b250692213d18a00fc939" translate="yes" xml:space="preserve">
          <source>Most functions in the &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt; module come in two variants: a short version that operates on &lt;a href=&quot;format#VALstd_formatter&quot;&gt;&lt;code&gt;Format.std_formatter&lt;/code&gt;&lt;/a&gt; and the generic version prefixed by &lt;code&gt;pp_&lt;/code&gt; that takes a formatter as its first argument.</source>
          <target state="translated">&lt;a href=&quot;format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt; 모듈의 대부분의 함수는 &lt;a href=&quot;format#VALstd_formatter&quot;&gt; &lt;code&gt;Format.std_formatter&lt;/code&gt; &lt;/a&gt; 에서 작동하는 짧은 버전 과 첫 번째 인수로 포맷터를 사용하는 &lt;code&gt;pp_&lt;/code&gt; 접두사가 붙은 일반 버전의 두 가지 변형으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="60ca906dcdb56968f58923bddaabb17961cb58f1" translate="yes" xml:space="preserve">
          <source>Multi-index are also supported through a second variant of indexing operators</source>
          <target state="translated">다중 색인은 색인 연산자의 두 번째 변형을 통해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="ac17c3be367cdf7b78ca9f7d7c50f262d3737c1d" translate="yes" xml:space="preserve">
          <source>Multiple inheritance is allowed. Only the last definition of a method is kept: the redefinition in a subclass of a method that was visible in the parent class overrides the definition in the parent class. Previous definitions of a method can be reused by binding the related ancestor. Below, super is bound to the ancestor printable_point. The name super is a pseudo value identifier that can only be used to invoke a super-class method, as in super#print.</source>
          <target state="translated">다중 상속이 허용됩니다. 메서드의 마지막 정의 만 유지됩니다. 부모 클래스에서 볼 수있는 메서드의 하위 클래스에서 재정의하면 부모 클래스의 정의가 재정의됩니다. 메서드의 이전 정의는 관련 조상을 바인딩하여 재사용 할 수 있습니다. 아래에서 super는 조상 printable_point에 바인딩됩니다. super라는 이름은 super # print에서와 같이 수퍼 클래스 메서드를 호출하는 데만 사용할 수있는 의사 값 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="de3d99d65d2f00ba5445685c943974a51e9484a3" translate="yes" xml:space="preserve">
          <source>Multiple levels of packing can be achieved by combining -pack with -for-pack. Consider the following example:</source>
          <target state="translated">-pack과 -for-pack을 결합하여 여러 수준의 패킹을 수행 할 수 있습니다. 다음 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2b9ee6e2b5fcdbd970e8f069acf17877e49e0441" translate="yes" xml:space="preserve">
          <source>Multiplication</source>
          <target state="translated">Multiplication</target>
        </trans-unit>
        <trans-unit id="549313c817d85e3b3f930b86928b72bbc44715d8" translate="yes" xml:space="preserve">
          <source>Multiplication.</source>
          <target state="translated">Multiplication.</target>
        </trans-unit>
        <trans-unit id="0d9a3f742b2bc9ffe56449aed4b901aa2ce9a0f4" translate="yes" xml:space="preserve">
          <source>Multiplicative inverse (&lt;code&gt;1/z&lt;/code&gt;).</source>
          <target state="translated">곱셈 역 ( &lt;code&gt;1/z&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bd2b0f087b02e413546a53c4f93f4cdf1581cc30" translate="yes" xml:space="preserve">
          <source>Mutex</source>
          <target state="translated">Mutex</target>
        </trans-unit>
        <trans-unit id="ff8d388bea0cae09717df1b41a4b4c493e6970fa" translate="yes" xml:space="preserve">
          <source>Mutexes (mutual-exclusion locks) are used to implement critical sections and protect shared mutable data structures against concurrent accesses. The typical use is (if &lt;code&gt;m&lt;/code&gt; is the mutex associated with the data structure &lt;code&gt;D&lt;/code&gt;):</source>
          <target state="translated">뮤텍스 (상호 배제 잠금)는 중요한 섹션을 구현하고 동시 액세스로부터 공유 변경 가능한 데이터 구조를 보호하는 데 사용됩니다. 일반적인 용도는 다음과 같습니다 ( &lt;code&gt;m&lt;/code&gt; 이 데이터 구조 &lt;code&gt;D&lt;/code&gt; 와 관련된 뮤텍스 인 경우 ).</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="e353e4d6aad1380c87ec233564134a4a344dffe7" translate="yes" xml:space="preserve">
          <source>Name of service or port number</source>
          <target state="translated">서비스 이름 또는 포트 번호</target>
        </trans-unit>
        <trans-unit id="ae264d14a11c34ace5fbb1bb8a6dd75bfdb17d89" translate="yes" xml:space="preserve">
          <source>Name or IP address of host</source>
          <target state="translated">호스트의 이름 또는 IP 주소</target>
        </trans-unit>
        <trans-unit id="549333ca0fbff4a493ab5e0bc0f95428f0fc7de0" translate="yes" xml:space="preserve">
          <source>Name space</source>
          <target state="translated">네임 스페이스</target>
        </trans-unit>
        <trans-unit id="756b76addd8adeb70cb127b2a93c3fa37d752c2d" translate="yes" xml:space="preserve">
          <source>Name the output files prefix.ml, prefix.mli, prefix.output, instead of the default naming convention.</source>
          <target state="translated">기본 명명 규칙 대신 출력 파일의 이름을 prefix.ml, prefix.mli, prefix.output으로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="8c095b2219367daec6dcc1e5087ff4061bfc41c9" translate="yes" xml:space="preserve">
          <source>Named pipe</source>
          <target state="translated">명명 된 파이프</target>
        </trans-unit>
        <trans-unit id="296294d67daa5c2f7bd477f7158b245e13beb631" translate="yes" xml:space="preserve">
          <source>Namely, the inferred remaining case is Some _, which is split into Some (Int, _) and Some (Bool, _), which are both untypable because deep expects a non-existing char t as the first element of the tuple. Note that the refutation case could be omitted here, because it is automatically added when there is only one case in the pattern matching.</source>
          <target state="translated">즉, 유추 된 나머지 케이스는 Some _로 Some (Int, _)과 Some (Bool, _)으로 나뉘며, deep은 존재하지 않는 char t를 튜플의 첫 번째 요소로 예상하기 때문에 모두 형형이 불가능합니다. 반박 케이스는 패턴 매칭에 케이스가 하나만있을 때 자동으로 추가되기 때문에 여기서 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e162aabfb0fa43d82b67a374234c4cb74d9be965" translate="yes" xml:space="preserve">
          <source>Names that are defined as abstract types in a signature can be implemented in a matching structure by any kind of type definition (provided it has the same number of type parameters). The exact implementation of the type will be hidden to the users of the structure. In particular, if the type is implemented as a variant type or record type, the associated constructors and fields will not be accessible to the users; if the type is implemented as an abbreviation, the type equality between the type name and the right-hand side of the abbreviation will be hidden from the users of the structure. Users of the structure consider that type as incompatible with any other type: a fresh type has been generated.</source>
          <target state="translated">서명에서 추상 유형으로 정의 된 이름은 모든 유형의 정의에 의해 일치하는 구조로 구현 될 수 있습니다 (동일한 수의 유형 매개 변수가있는 경우). 유형의 정확한 구현은 구조 사용자에게 숨겨집니다. 특히 유형이 변형 유형 또는 레코드 유형으로 구현되는 경우 사용자는 연관된 생성자 및 필드에 액세스 할 수 없습니다. 유형이 약어로 구현 된 경우 유형 이름과 약어의 오른쪽 사이의 유형 동등성은 구조 사용자에게 숨겨집니다. 구조 사용자는 해당 유형을 다른 유형과 호환되지 않는 것으로 간주합니다. 새로운 유형이 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="9e848993d9abd7bcd0da1a886c50f6a34ca40770" translate="yes" xml:space="preserve">
          <source>Naming labels come in two flavours: &lt;a href=&quot;#label&quot;&gt;label&lt;/a&gt; for normal arguments and &lt;a href=&quot;#optlabel&quot;&gt;optlabel&lt;/a&gt; for optional ones. They are simply distinguished by their first character, either ~ or ?.</source>
          <target state="translated">이름 지정 레이블은 일반 인수에 대한 &lt;a href=&quot;#label&quot;&gt;레이블&lt;/a&gt; 과 선택적 인수에 대한 &lt;a href=&quot;#optlabel&quot;&gt;optlabel의&lt;/a&gt; 두 가지 유형 으로 제공됩니다. 첫 번째 문자 인 ~ 또는?로 간단히 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="be64c74e17dde72651549865ed8544a38961913d" translate="yes" xml:space="preserve">
          <source>Nativeint</source>
          <target state="translated">Nativeint</target>
        </trans-unit>
        <trans-unit id="6121887e44c8bb72f2cd96f891df9010238c7905" translate="yes" xml:space="preserve">
          <source>Nativeint_val(v) returns the long integer contained in the nativeintv.</source>
          <target state="translated">Nativeint_val (v)은 nativeintv에 포함 된 long 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fe99dc11adcd3f4c5eeceb4413e82bcd56b5ef61" translate="yes" xml:space="preserve">
          <source>Natural logarithm (in base &lt;code&gt;e&lt;/code&gt;).</source>
          <target state="translated">자연 로그 (밑이 &lt;code&gt;e&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="2f187f5dc4cb75173c53a77254bdd4b7078911c3" translate="yes" xml:space="preserve">
          <source>Natural logarithm.</source>
          <target state="translated">자연 로그.</target>
        </trans-unit>
        <trans-unit id="b710ee6a1b2df5b06e260b4de6bc7921f957917e" translate="yes" xml:space="preserve">
          <source>Negation of &lt;a href=&quot;stdlib#VAL(=)&quot;&gt;&lt;code&gt;(=)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VAL(=)&quot;&gt; &lt;code&gt;(=)&lt;/code&gt; 의&lt;/a&gt; 부정 .</target>
        </trans-unit>
        <trans-unit id="8919121a4837a7384f394582f637a0af70744796" translate="yes" xml:space="preserve">
          <source>Negation of &lt;a href=&quot;stdlib#VAL(=)&quot;&gt;&lt;code&gt;(=)&lt;/code&gt;&lt;/a&gt;. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VAL(=)&quot;&gt; &lt;code&gt;(=)&lt;/code&gt; 의&lt;/a&gt; 부정 . 왼쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="9befaab36628d9f7863760f1639c08f6661eaa9f" translate="yes" xml:space="preserve">
          <source>Negation of &lt;a href=&quot;stdlib#VAL(==)&quot;&gt;&lt;code&gt;(==)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VAL(==)&quot;&gt; &lt;code&gt;(==)&lt;/code&gt; 의&lt;/a&gt; 부정 .</target>
        </trans-unit>
        <trans-unit id="f4f78c719756b0216b5efd59f9661b9e8b62f6c6" translate="yes" xml:space="preserve">
          <source>Negation of &lt;a href=&quot;stdlib#VAL(==)&quot;&gt;&lt;code&gt;(==)&lt;/code&gt;&lt;/a&gt;. Left-associative operator, see &lt;a href=&quot;ocaml_operators&quot;&gt;&lt;code&gt;Ocaml_operators&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VAL(==)&quot;&gt; &lt;code&gt;(==)&lt;/code&gt; 의&lt;/a&gt; 부정 . 왼쪽 연관 연산자, 자세한 내용 은 &lt;a href=&quot;ocaml_operators&quot;&gt; &lt;code&gt;Ocaml_operators&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="77f939047f0ba0a97a64071a5a435763eb58f7bd" translate="yes" xml:space="preserve">
          <source>Negative infinity.</source>
          <target state="translated">음의 무한대.</target>
        </trans-unit>
        <trans-unit id="8ba9abe745a8f0e4e877cc69abc52cdee83e48b7" translate="yes" xml:space="preserve">
          <source>Network dropped connection on reset</source>
          <target state="translated">재설정시 네트워크 연결이 끊어졌습니다.</target>
        </trans-unit>
        <trans-unit id="ea849e260b8735345217e4f53f113c9fcde5b394" translate="yes" xml:space="preserve">
          <source>Network is down</source>
          <target state="translated">네트워크가 다운되었습니다</target>
        </trans-unit>
        <trans-unit id="d34a1412dd6535ceabe7960d72728113a96b875c" translate="yes" xml:space="preserve">
          <source>Network is unreachable</source>
          <target state="translated">네트워크에 연결할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="c006cf01dc92514d04743559daf156d417fe5f82" translate="yes" xml:space="preserve">
          <source>New applications that need arbitrary-precision arithmetic should use the Zarith library (&lt;a href=&quot;https://github.com/ocaml/Zarith&quot;&gt;https://github.com/ocaml/Zarith&lt;/a&gt;) instead of the Num library, and older applications that already use Num are encouraged to switch to Zarith. Zarith delivers much better performance than Num and has a nicer API.</source>
          <target state="translated">임의 정밀도 산술이 필요한 새 애플리케이션 은 Num 라이브러리 대신 Zarith 라이브러리 ( &lt;a href=&quot;https://github.com/ocaml/Zarith&quot;&gt;https://github.com/ocaml/Zarith&lt;/a&gt; )를 사용해야하며 , 이미 Num을 사용하는 이전 애플리케이션은 Zarith로 전환하는 것이 좋습니다. Zarith는 Num보다 훨씬 더 나은 성능을 제공하고 더 좋은 API를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="280be44a9152ebadb2bdb39840c63ece14ec70f7" translate="yes" xml:space="preserve">
          <source>New variant type or record type: no equation, a representation.</source>
          <target state="translated">새로운 변형 유형 또는 레코드 유형 : 방정식 없음, 표현.</target>
        </trans-unit>
        <trans-unit id="7e1039fc69f9291b60d0860a59005e4bab261192" translate="yes" xml:space="preserve">
          <source>Next, we run the program under afl-fuzz:</source>
          <target state="translated">다음으로 afl-fuzz에서 프로그램을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="2981f6fc6fe648e38aa58e8e417c3c2d93457ab6" translate="yes" xml:space="preserve">
          <source>No attempt has been made at mathematical rigor: words are employed with their intuitive meaning, without further definition. As a consequence, the typing rules have been left out, by lack of the mathematical framework required to express them, while they are definitely part of a full formal definition of the language.</source>
          <target state="translated">수학적 엄격함을 시도하지 않았습니다. 단어는 더 이상의 정의없이 직관적 인 의미로 사용됩니다. 결과적으로 타이핑 규칙은 표현하는 데 필요한 수학적 프레임 워크가 부족하여 빠졌지 만 언어의 완전한 공식 정의의 일부입니다.</target>
        </trans-unit>
        <trans-unit id="e792e65ee8a80fd8989ad1b66325f180ccd8b365" translate="yes" xml:space="preserve">
          <source>No buffer space available</source>
          <target state="translated">사용 가능한 버퍼 공간이 없습니다.</target>
        </trans-unit>
        <trans-unit id="aa02cb7a520e805604b436b26d2e3b0230ac3573" translate="yes" xml:space="preserve">
          <source>No child process</source>
          <target state="translated">자식 프로세스 없음</target>
        </trans-unit>
        <trans-unit id="4b716f8eaa691d689900e51bfb7cf3470f97f3d4" translate="yes" xml:space="preserve">
          <source>No coeffects:</source>
          <target state="translated">부작용 없음 :</target>
        </trans-unit>
        <trans-unit id="4e0b86ee8d4ae90b6347fb23a23aee01ef7d1ad2" translate="yes" xml:space="preserve">
          <source>No effects:</source>
          <target state="translated">효과 없음 :</target>
        </trans-unit>
        <trans-unit id="ac84bf2f78b29d7fcdb0dbd9e9503065301a53a2" translate="yes" xml:space="preserve">
          <source>No locks available</source>
          <target state="translated">사용 가능한 잠금 없음</target>
        </trans-unit>
        <trans-unit id="62c6526007299ca03f778b5b7ce0d726354cae0d" translate="yes" xml:space="preserve">
          <source>No route to host</source>
          <target state="translated">접속 대상으로가는 길이 없음</target>
        </trans-unit>
        <trans-unit id="5c0580667d6055e92a026b8c67fa943060b2c89d" translate="yes" xml:space="preserve">
          <source>No space left on device</source>
          <target state="translated">기기에 남은 공간이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7e7d314f83d9dd80d3f3a1d2cf49d2c2861bf468" translate="yes" xml:space="preserve">
          <source>No string in the result contains the &lt;code&gt;sep&lt;/code&gt; character.</source>
          <target state="translated">결과에 &lt;code&gt;sep&lt;/code&gt; 문자 가 포함 된 문자열이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e5feee0204f5532e0cb04d5be298f4c467c05e6f" translate="yes" xml:space="preserve">
          <source>No such device</source>
          <target state="translated">그런 장치 없음</target>
        </trans-unit>
        <trans-unit id="112765ee706d5c7ea20d7309d6bf892b8a5aa7eb" translate="yes" xml:space="preserve">
          <source>No such device or address</source>
          <target state="translated">그러한 장치 또는 주소가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a6cb568f806ffae868a77b519003a5df95ec0c3" translate="yes" xml:space="preserve">
          <source>No such file or directory</source>
          <target state="translated">그러한 파일 또는 디렉토리 없음</target>
        </trans-unit>
        <trans-unit id="0cf4a772e5ca24befae7ddee66e425eeaa8130aa" translate="yes" xml:space="preserve">
          <source>No such process</source>
          <target state="translated">그러한 과정이 없습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="db516bd236f8b19cb9f7f134b81fc52a48b48cab" translate="yes" xml:space="preserve">
          <source>Non-Flambda versions of the compiler cannot inline functions that contain a definition of another function. However -Oclassic does permit this. Further, non-Flambda versions also cannot inline functions that are only themselves exposed as a result of a previous pass of inlining, but again this is permitted by -Oclassic. For example:</source>
          <target state="translated">비 Flambda 버전의 컴파일러는 다른 함수의 정의를 포함하는 함수를 인라인 할 수 없습니다. 그러나 -Oclassic은 이것을 허용합니다. 또한, 비 Flambda 버전은 이전 인라인 패스의 결과로 자신 만 노출 된 함수를 인라인 할 수 없지만 다시 -Oclassic에 의해 허용됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="5a7fec4c0093183b651e94da8602d12888a9798d" translate="yes" xml:space="preserve">
          <source>Non-blocking version of &lt;a href=&quot;event#VALsync&quot;&gt;&lt;code&gt;Event.sync&lt;/code&gt;&lt;/a&gt;: offer all the communication possibilities specified in the event to the outside world, and if one can take place immediately, perform it and return &lt;code&gt;Some&amp;nbsp;r&lt;/code&gt; where &lt;code&gt;r&lt;/code&gt; is the result value of that communication.</source>
          <target state="translated">Non-blocking 버전의 &lt;a href=&quot;event#VALsync&quot;&gt; &lt;code&gt;Event.sync&lt;/code&gt; &lt;/a&gt; : 이벤트에 지정된 모든 통신 가능성을 외부 세계에 제공하고, 즉시 발생할 수 있으면 수행하고 &lt;code&gt;Some&amp;nbsp;r&lt;/code&gt; 반환합니다. 여기서 &lt;code&gt;r&lt;/code&gt; 은 해당 통신의 결과 값입니다.</target>
        </trans-unit>
        <trans-unit id="e1c495fe7e42478c735910f07114d91295ddc81f" translate="yes" xml:space="preserve">
          <source>Non-blocking version of &lt;a href=&quot;event#VALsync&quot;&gt;&lt;code&gt;Event.sync&lt;/code&gt;&lt;/a&gt;: offer all the communication possibilities specified in the event to the outside world, and if one can take place immediately, perform it and return &lt;code&gt;Some&amp;nbsp;r&lt;/code&gt; where &lt;code&gt;r&lt;/code&gt; is the result value of that communication. Otherwise, return &lt;code&gt;None&lt;/code&gt; without blocking.</source>
          <target state="translated">Non-blocking 버전의 &lt;a href=&quot;event#VALsync&quot;&gt; &lt;code&gt;Event.sync&lt;/code&gt; &lt;/a&gt; : 이벤트에 지정된 모든 통신 가능성을 외부 세계에 제공하고, 즉시 발생할 수 있으면 수행하고 &lt;code&gt;Some&amp;nbsp;r&lt;/code&gt; 반환합니다. 여기서 &lt;code&gt;r&lt;/code&gt; 은 해당 통신의 결과 값입니다. 그렇지 않으면 차단하지 않고 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="f7955c5f7147285808f393b0a2f015ae8bfdf418" translate="yes" xml:space="preserve">
          <source>Non-generalized type variables in a type cause no difficulties inside a given structure or compilation unit (the contents of a .ml file, or an interactive session), but they cannot be allowed inside signatures nor in compiled interfaces (.cmi file), because they could be used inconsistently later. Therefore, the compiler flags an error when a structure or compilation unit defines a value name whose type contains non-generalized type variables. There are two ways to fix this error:</source>
          <target state="translated">유형의 일반화되지 않은 유형 변수는 지정된 구조 또는 컴파일 단위 (.ml 파일 또는 대화 형 세션의 내용) 내에서 문제를 일으키지 않지만 서명이나 컴파일 된 인터페이스 (.cmi 파일)에서는 허용되지 않습니다. 나중에 일관되지 않게 사용될 수 있기 때문입니다. 따라서 구조 또는 컴파일 단위가 형식에 일반화되지 않은 형식 변수가 포함 된 값 이름을 정의하면 컴파일러에서 오류를 표시합니다. 이 오류를 수정하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="74b76795e362f5a2898817253827ed1f46066a45" translate="yes" xml:space="preserve">
          <source>Non-principal type.</source>
          <target state="translated">비 주요 유형.</target>
        </trans-unit>
        <trans-unit id="552623d2d3482ef2ceb23ffcc0f0d612c140eb4c" translate="yes" xml:space="preserve">
          <source>Non-regular recursive algebraic data types correspond to polymorphic algebraic data types whose parameter types vary between the left and right side of the type definition. For instance, it might be interesting to define a datatype that ensures that all lists are nested at the same depth:</source>
          <target state="translated">비정규 재귀 대수 데이터 유형은 매개 변수 유형이 유형 정의의 왼쪽과 오른쪽 사이에서 다른 다형성 대수 데이터 유형에 해당합니다. 예를 들어 모든 목록이 동일한 깊이로 중첩되도록하는 데이터 유형을 정의하는 것이 흥미로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4722a32b4738403c181ac5e3a12ee6eb896bca7c" translate="yes" xml:space="preserve">
          <source>Non-returning statement.</source>
          <target state="translated">반환되지 않는 진술.</target>
        </trans-unit>
        <trans-unit id="187ac81e9effe553285ccadbb88b811d43fd0c04" translate="yes" xml:space="preserve">
          <source>Nonoptional label applied as optional.</source>
          <target state="translated">선택 사항으로 적용된 비 선택적 레이블.</target>
        </trans-unit>
        <trans-unit id="af7065271027eca5c68630d7333cfc9de2dd8678" translate="yes" xml:space="preserve">
          <source>Nonterminal symbols are like regular OCaml symbols, except that they cannot end with ' (single quote).</source>
          <target state="translated">비 터미널 기호는 '(작은 따옴표)로 끝날 수 없다는 점을 제외하면 일반 OCaml 기호와 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c779683d49742e5580a38345a8dbcc07ab2e152" translate="yes" xml:space="preserve">
          <source>Norm squared: given &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt;, returns &lt;code&gt;x^2&amp;nbsp;+&amp;nbsp;y^2&lt;/code&gt;.</source>
          <target state="translated">노름 제곱 : 주어진 &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt; 는 &lt;code&gt;x^2&amp;nbsp;+&amp;nbsp;y^2&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ddc420b7c8d61b9e4310ab8493f4d729522accc5" translate="yes" xml:space="preserve">
          <source>Norm: given &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt;, returns &lt;code&gt;sqrt(x^2&amp;nbsp;+&amp;nbsp;y^2)&lt;/code&gt;.</source>
          <target state="translated">Norm : 주어진 &lt;code&gt;x&amp;nbsp;+&amp;nbsp;i.y&lt;/code&gt; 는 &lt;code&gt;sqrt(x^2&amp;nbsp;+&amp;nbsp;y^2)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="517d7530daae5b9c5977ddf4fbfb276d8be8264d" translate="yes" xml:space="preserve">
          <source>Normal number, none of the below</source>
          <target state="translated">일반 번호, 아래 항목 없음</target>
        </trans-unit>
        <trans-unit id="36fb1748b422ce3ad94d8a06d8205b349c379068" translate="yes" xml:space="preserve">
          <source>Normally the compiler generates a type error if you attempt to pass to a function a parameter whose type is different from the expected one. However, in the specific case where the expected type is a non-labeled function type, and the argument is a function expecting optional parameters, the compiler will attempt to transform the argument to have it match the expected type, by passing None for all optional parameters.</source>
          <target state="translated">일반적으로 컴파일러는 유형이 예상과 다른 매개 변수를 함수에 전달하려고하면 유형 오류를 생성합니다. 그러나 예상 유형이 레이블이 지정되지 않은 함수 유형이고 인수가 선택적 매개 변수를 예상하는 함수 인 경우 컴파일러는 모든 선택적에 대해 None을 전달하여 예상 유형과 일치하도록 인수를 변환하려고 시도합니다. 매개 변수.</target>
        </trans-unit>
        <trans-unit id="c792fa3c18a06a015ea04948e5b4604135e35115" translate="yes" xml:space="preserve">
          <source>Normally, the allocation rate is measured by counting the in-heap size of allocated blocks. However, it often happens that finalized objects contain pointers to out-of-heap memory blocks and other resources (such as file descriptors, X Windows bitmaps, etc.). For those blocks, the in-heap size of blocks is not a good measure of the quantity of resources allocated by the program.</source>
          <target state="translated">일반적으로 할당 비율은 할당 된 블록의 힙 크기를 계산하여 측정됩니다. 그러나 최종 객체에는 힙이 부족한 메모리 블록 및 기타 리소스 (예 : 파일 설명자, X Windows 비트 맵 등)에 대한 포인터가 포함되는 경우가 많습니다. 이러한 블록의 경우 블록의 힙 크기는 프로그램에 의해 할당 된 리소스 양의 좋은 척도가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1ff9300a83f8a35da371237256262716296f049b" translate="yes" xml:space="preserve">
          <source>Normally, the debugger takes checkpoints of the program state from time to time. That is, it makes a copy of the current state of the program (using the Unix system call fork). If the variable checkpoints is set to off, the debugger will not take any checkpoints.</source>
          <target state="translated">일반적으로 디버거는 프로그램 상태의 체크 포인트를 수시로 가져옵니다. 즉, 프로그램의 현재 상태를 복사합니다 (유닉스 시스템 호출 포크 사용). 변수 checkpoints가 off로 설정된 경우 디버거는 어떤 체크 포인트도 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="338469a733ebda5aa0e30bb1db80e0e157e51892" translate="yes" xml:space="preserve">
          <source>Not a directory</source>
          <target state="translated">디렉토리 아님</target>
        </trans-unit>
        <trans-unit id="9faeba3fc7b5c9d7e01764096168b9e8e374411d" translate="yes" xml:space="preserve">
          <source>Not a number: result of an undefined operation</source>
          <target state="translated">숫자가 아님 : 정의되지 않은 작업의 결과</target>
        </trans-unit>
        <trans-unit id="4c8ae112a2e8df4e520ecf91813337acb821264b" translate="yes" xml:space="preserve">
          <source>Not all functions are provided by all Unix variants. If some functions are not available, they will raise Invalid_arg when called.</source>
          <target state="translated">모든 기능이 모든 Unix 변형에서 제공되는 것은 아닙니다. 일부 함수를 사용할 수없는 경우 호출시 Invalid_arg가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a251fde2cab1783fbc45a17d3491954f07532d2e" translate="yes" xml:space="preserve">
          <source>Not all header available in the caml/ directory were described in previous sections. All those unmentioned headers are part of the internal runtime API, for which there is &lt;em&gt;no&lt;/em&gt; stability guarantee. If you really need access to this internal runtime API, this section provides some guidelines that may help you to write code that might not break on every new version of OCaml.</source>
          <target state="translated">caml / 디렉토리에서 사용 가능한 모든 헤더가 이전 섹션에서 설명 된 것은 아닙니다. 언급되지 않은 모든 헤더는 안정성 보장 이 &lt;em&gt;없는&lt;/em&gt; 내부 런타임 API의 일부입니다 . 이 내부 런타임 API에 실제로 액세스해야하는 경우이 섹션에서는 OCaml의 모든 새 버전에서 중단되지 않을 수있는 코드를 작성하는 데 도움이 될 수있는 몇 가지 지침을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a9199f21841e17aae508bebd4889b3a7dc1d36c6" translate="yes" xml:space="preserve">
          <source>Not an executable file</source>
          <target state="translated">실행 파일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="facd4c2d5bdce52a545593e87469a809ac0e1231" translate="yes" xml:space="preserve">
          <source>Not enough memory</source>
          <target state="translated">메모리 부족</target>
        </trans-unit>
        <trans-unit id="cf34be1f750ab01dd0f009456dd21934f44155fb" translate="yes" xml:space="preserve">
          <source>Not for the casual user.</source>
          <target state="translated">일반 사용자에게는 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4152727c8d99325fa09c8beae5e73e4b8bd46f0c" translate="yes" xml:space="preserve">
          <source>Not the normal way of pretty-printing, since imperative line splitting may interfere with current line counters and box size calculation. Using break hints within an enclosing vertical box is a better alternative.</source>
          <target state="translated">명령형 라인 분할은 현재 라인 카운터 및 상자 크기 계산을 방해 할 수 있기 때문에 일반적인 예쁜 인쇄 방법이 아닙니다. 둘러싸는 세로 상자 내에서 나누기 힌트를 사용하는 것이 더 나은 대안입니다.</target>
        </trans-unit>
        <trans-unit id="a819c9b54780bf0db302a106d8d765a494007de9" translate="yes" xml:space="preserve">
          <source>Note as well that parent directories in the given path will not be created when opening the trace. The runtime assumes the path is accessible for creating and writing the trace. The program will fail to start if this requirement isn&amp;rsquo;t met.</source>
          <target state="translated">또한 지정된 경로의 상위 디렉토리는 추적을 열 때 생성되지 않습니다. 런타임은 추적을 만들고 쓰기 위해 경로에 액세스 할 수 있다고 가정합니다. 이 요구 사항이 충족되지 않으면 프로그램이 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="037c57d3261561d20c1db3424456e04def230f71" translate="yes" xml:space="preserve">
          <source>Note here the (self : int #iterator) idiom, which ensures that this object implements the interface iterator.</source>
          <target state="translated">이 객체가 인터페이스 반복기를 구현하도록 보장하는 (self : int #iterator) 관용구에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="c3ce8074b0d7cbaefabb1e3d3e4d3c74808df3a8" translate="yes" xml:space="preserve">
          <source>Note here the special syntax (#point0 as 'a) we have to use to quantify the extensible part of #point0. As for the variable binder, it can be omitted in class specifications. If you want polymorphism inside object field it must be quantified independently.</source>
          <target state="translated">여기에서 # point0의 확장 가능한 부분을 정량화하기 위해 사용해야하는 특수 구문 (# point0을 'a로 사용)에 유의하십시오. 가변 바인더의 경우 클래스 사양에서 생략 할 수 있습니다. 객체 필드 내에서 다형성을 원하면 독립적으로 정량화해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab69a65854dd6fec6962d0e2d5e4784cf692204e" translate="yes" xml:space="preserve">
          <source>Note in particular that -inline does not have the meaning that it has in the previous compiler or in -Oclassic mode. In both of those situations -inline was effectively some kind of basic assessment of inlining benefit. However in Flambda inlining mode it corresponds to a constraint on the search; the assessment of benefit is independent, as described above.</source>
          <target state="translated">특히 -inline은 이전 컴파일러 또는 -Oclassic 모드에서와 같은 의미를 갖지 않습니다. 이 두 가지 상황에서 -inline은 사실상 인라인 이익에 대한 일종의 기본 평가였습니다. 그러나 Flambda 인라인 모드에서는 검색에 대한 제약 조건에 해당합니다. 위에서 설명한 바와 같이 혜택 평가는 독립적입니다.</target>
        </trans-unit>
        <trans-unit id="90e7c8c1273c2167af15e26d1e579c38f8f99528" translate="yes" xml:space="preserve">
          <source>Note on polymorphic variant tags: the current implementation accepts lowercase variant tags in addition to capitalized variant tags, but we suggest you avoid lowercase variant tags for portability and compatibility with future OCaml versions.</source>
          <target state="translated">다형성 변형 태그에 대한 참고 사항 : 현재 구현에서는 대문자 변형 태그와 함께 소문자 변형 태그를 허용하지만 이식성과 향후 OCaml 버전과의 호환성을 위해 소문자 변형 태그를 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8abc6d55c7e6502cb76253097a56d727be818505" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;dynlink#VALloadfile&quot;&gt;&lt;code&gt;Dynlink.loadfile&lt;/code&gt;&lt;/a&gt; changes the allowed-units list.</source>
          <target state="translated">참고 &lt;a href=&quot;dynlink#VALloadfile&quot;&gt; &lt;code&gt;Dynlink.loadfile&lt;/code&gt; 이&lt;/a&gt; 허용-단위 목록을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="08d26a6dbdf7cb76c9e11d80524e91dc7d0ef610" translate="yes" xml:space="preserve">
          <source>Note that entering open Mod merely accesses the compiled interface (.cmi file) for Mod, but does not load the implementation of Mod, and does not cause any error if no implementation of Mod has been loaded. The error &amp;ldquo;reference to undefined global Mod&amp;rdquo; will occur only when executing a value or module definition that refers to Mod.</source>
          <target state="translated">open Mod를 입력하면 Mod에 대한 컴파일 된 인터페이스 (.cmi 파일)에 액세스 할뿐 Mod 구현을로드하지 않으며 Mod 구현이로드되지 않은 경우 오류가 발생하지 않습니다. Mod를 참조하는 값 또는 모듈 정의를 실행할 때만 &quot;정의되지 않은 전역 Mod에 대한 참조&quot;오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2165fbecefe21675865f5a8f169aa75121b7dd25" translate="yes" xml:space="preserve">
          <source>Note that for clarity&amp;rsquo;s sake, the method print is explicitly marked as overriding another definition by annotating the method keyword with an exclamation mark !. If the method print were not overriding the print method of printable_point, the compiler would raise an error:</source>
          <target state="translated">명확성을 위해 print 메소드는 느낌표!로 메소드 키워드에 주석을 달아 다른 정의를 대체하는 것으로 명시 적으로 표시됩니다. print 메서드가 printable_point의 print 메서드를 재정의하지 않으면 컴파일러에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0c8b0cd07d8b3eb1cb5c73f85a9b93dce5e210f3" translate="yes" xml:space="preserve">
          <source>Note that in this case you should not compute dependencies for mylib.mli together with the other files, hence the need to pass explicitly the list of files to process. If mylib.mli itself has dependencies, you should compute them using -as-map.</source>
          <target state="translated">이 경우 mylib.mli에 대한 종속성을 다른 파일과 함께 계산해서는 안되므로 처리 할 파일 목록을 명시 적으로 전달해야합니다. mylib.mli 자체에 종속성이있는 경우 -as-map을 사용하여 계산해야합니다.</target>
        </trans-unit>
        <trans-unit id="63274ceec059ea43f06cf7d5143c9d0f279449fe" translate="yes" xml:space="preserve">
          <source>Note that it would be unsafe if &lt;code&gt;s&lt;/code&gt; was passed as an additional parameter to the function &lt;code&gt;f&lt;/code&gt; as it could escape this way and be mutated in the future -- &lt;code&gt;string_init&lt;/code&gt; would give up ownership of &lt;code&gt;s&lt;/code&gt; to pass it to &lt;code&gt;f&lt;/code&gt;, and could not call &lt;code&gt;unsafe_to_string&lt;/code&gt; safely.</source>
          <target state="translated">참고 경우는 안전하지 않을 것이라는 점을 &lt;code&gt;s&lt;/code&gt; 함수에 추가 매개 변수로 전달 된 &lt;code&gt;f&lt;/code&gt; 가이 길을 벗어날 수 있고 미래에 돌연변이로 - &lt;code&gt;string_init&lt;/code&gt; 가 소유권 포기 &lt;code&gt;s&lt;/code&gt; 에 전달하는 &lt;code&gt;f&lt;/code&gt; , 및 호출 할 수 &lt;code&gt;unsafe_to_string&lt;/code&gt; 안전하게.</target>
        </trans-unit>
        <trans-unit id="b4753a1c807609006c1cb1222f68e354a9ec0d33" translate="yes" xml:space="preserve">
          <source>Note that label comments take precedence over item comments, so:</source>
          <target state="translated">레이블 주석은 항목 주석보다 우선하므로 다음을 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="a919535701ff97d2e364548f37fa537e17d9cc03" translate="yes" xml:space="preserve">
          <source>Note that lazy_two has type int lazy_t. However, the type 'a lazy_t is an internal type name, so the type 'a Lazy.t should be preferred when possible.</source>
          <target state="translated">lazy_two의 유형은 int lazy_t입니다. 그러나 'a lazy_t'유형은 내부 유형 이름이므로 가능하면 'a Lazy.t 유형을 선호해야합니다.</target>
        </trans-unit>
        <trans-unit id="bdbd6ed5e065f79a1664cc5e3d9e396319783be3" translate="yes" xml:space="preserve">
          <source>Note that line splitting policy is box specific: the policy of a box does not rule the policy of inner boxes. For instance, if a vertical box is nested in an horizontal box, all break hints within the vertical box will split the line.</source>
          <target state="translated">라인 분할 정책은 상자별로 다릅니다. 상자의 정책은 내부 상자의 정책을 지배하지 않습니다. 예를 들어, 세로 상자가 가로 상자에 중첩 된 경우 세로 상자 내의 모든 나누기 힌트가 선을 분할합니다.</target>
        </trans-unit>
        <trans-unit id="0ce52db53f4883581f49385acd3aa04301c1b07b" translate="yes" xml:space="preserve">
          <source>Note that no information is propagated about the contents of strings, even in safe-string mode, because it cannot yet be guaranteed that they are immutable throughout a given program.</source>
          <target state="translated">안전 문자열 모드에서도 문자열 내용에 대한 정보는 전달되지 않는다는 점에 유의하십시오. 주어진 프로그램 전체에서 변경 불가능하다는 것을 아직 보장 할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="9ecfaba3e31b928fe62c543cf4b58b08adf9f38d" translate="yes" xml:space="preserve">
          <source>Note that once &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; was called, there is no way to revert to the non-randomized default behavior of &lt;a href=&quot;hashtbl#VALcreate&quot;&gt;&lt;code&gt;Hashtbl.create&lt;/code&gt;&lt;/a&gt;. This is intentional. Non-randomized hash tables can still be created using &lt;code&gt;Hashtbl.create&amp;nbsp;~random:false&lt;/code&gt;.</source>
          <target state="translated">일단 참고 &lt;code&gt;Hashtbl.randomize()&lt;/code&gt; 호출 된이의 비 무작위 기본 동작으로 되돌릴 수있는 방법은 없습니다 &lt;a href=&quot;hashtbl#VALcreate&quot;&gt; &lt;code&gt;Hashtbl.create&lt;/code&gt; &lt;/a&gt; . 이것은 의도적 인 것입니다. 무작위 화되지 않은 해시 테이블은 여전히 &lt;code&gt;Hashtbl.create&amp;nbsp;~random:false&lt;/code&gt; 사용하여 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3eb4400a3041e1bc0872d4c6fadfee7b45a0533" translate="yes" xml:space="preserve">
          <source>Note that only top-level structures can be mapped to separately-compiled files, but neither functors nor module types. However, all module-class objects can appear as components of a structure, so the solution is to put the functor or module type inside a structure, which can then be mapped to a file.</source>
          <target state="translated">최상위 구조 만 개별적으로 컴파일 된 파일에 매핑 될 수 있지만 펑 터나 모듈 유형은 아닙니다. 그러나 모든 모듈 클래스 객체는 구조의 구성 요소로 나타날 수 있으므로 솔루션은 펑터 또는 모듈 유형을 구조 안에 넣은 다음 파일에 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45d50cbdd93bc0057831e01783483dc11563f7c4" translate="yes" xml:space="preserve">
          <source>Note that since immediate objects do not define a class type, they have no such restriction.</source>
          <target state="translated">즉각적인 개체는 클래스 유형을 정의하지 않으므로 이러한 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2bd433ffb5b0bba6a711c0ea5bb3b1c7a88c90b0" translate="yes" xml:space="preserve">
          <source>Note that the callback can be postponed slightly after the actual event. The callstack passed to the callback is always accurate, but the program state may have evolved.</source>
          <target state="translated">콜백은 실제 이벤트 이후 약간 연기 될 수 있습니다. 콜백에 전달 된 호출 스택은 항상 정확하지만 프로그램 상태가 발전했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2ef9b9d1aff860780f332e0b33c8e88450455d7" translate="yes" xml:space="preserve">
          <source>Note that the coercion (&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;:&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;) is actually an abbreviated form, and will only work in presence of private abbreviations if neither the type of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; nor &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; contain any type variables. If they do, you must use the full form (&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;) where &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is the expected type of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;. Concretely, this would be (x : N.t :&amp;gt; int) and (l : N.t list :&amp;gt; int list) for the above examples.</source>
          <target state="translated">강제 ( &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; :&amp;gt; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; )는 실제로 축약 된 형식이며 &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; 유형 과 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; 유형에 유형 변수가 포함되어 있지 않은 경우에만 비공개 약어가있는 경우에만 작동 합니다. 그렇다면 전체 형식 ( &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; : &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; :&amp;gt; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; )을 &lt;a href=&quot;types#typexpr&quot;&gt;사용해야합니다.&lt;/a&gt; 여기서 typexpr &lt;sub&gt;1&lt;/sub&gt; 은 예상되는 &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; 유형입니다 . 구체적으로 위의 예에서는 (x : Nt :&amp;gt; int) 및 (l : Nt list :&amp;gt; int list)가됩니다.</target>
        </trans-unit>
        <trans-unit id="50817e39131d67a96275cac53949dd6c7173b3db" translate="yes" xml:space="preserve">
          <source>Note that the following identifiers are keywords of the Camlp4 extensions and should be avoided for compatibility reasons.</source>
          <target state="translated">다음 식별자는 Camlp4 확장의 키워드이며 호환성을 위해 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="6d6f602690ce2c063c471eee010ebbe59f6bbddc" translate="yes" xml:space="preserve">
          <source>Note that the instrumented runtime is an alternative runtime for OCaml programs. It is only referenced during the linking stage of the final executable. This means that the compilation stage does not need to be altered to enable instrumentation.</source>
          <target state="translated">인스트루먼트 된 런타임은 OCaml 프로그램의 대체 런타임입니다. 최종 실행 파일의 연결 단계에서만 참조됩니다. 즉, 계측을 활성화하기 위해 컴파일 단계를 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5971f9da22f0faace6bfec873b81d408ac540d78" translate="yes" xml:space="preserve">
          <source>Note that the new type &lt;code&gt;'a&amp;nbsp;IntHashtbl.t&lt;/code&gt; is not compatible with the type &lt;code&gt;('a,'b)&amp;nbsp;Hashtbl.t&lt;/code&gt; of the generic interface. For example, &lt;code&gt;Hashtbl.length&amp;nbsp;h&lt;/code&gt; would not type-check, you must use &lt;code&gt;IntHashtbl.length&lt;/code&gt;.</source>
          <target state="translated">새 유형 &lt;code&gt;'a&amp;nbsp;IntHashtbl.t&lt;/code&gt; 는 제네릭 인터페이스 의 유형 &lt;code&gt;('a,'b)&amp;nbsp;Hashtbl.t&lt;/code&gt; 와 호환되지 않습니다 . 예를 들어, &lt;code&gt;Hashtbl.length&amp;nbsp;h&lt;/code&gt; 는 유형 검사를하지 않으므로 &lt;code&gt;IntHashtbl.length&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f01438030239e56aa11911507a85c74b4e412af5" translate="yes" xml:space="preserve">
          <source>Note that the relationship between object, class and type in OCaml is different than in mainstream object-oriented languages such as Java and C++, so you shouldn&amp;rsquo;t assume that similar keywords mean the same thing. Object-oriented features are used much less frequently in OCaml than in those languages. OCaml has alternatives that are often more appropriate, such as modules and functors. Indeed, many OCaml programs do not use objects at all.</source>
          <target state="translated">OCaml의 객체, 클래스 및 유형 간의 관계는 Java 및 C ++와 같은 주류 객체 지향 언어에서와 다르므로 유사한 키워드가 동일한 의미를 갖는다 고 가정해서는 안됩니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 객체 지향 기능은 해당 언어보다 OCaml에서 훨씬 덜 자주 사용됩니다. OCaml에는 모듈 및 펑터와 같이 종종 더 적절한 대안이 있습니다. 실제로 많은 OCaml 프로그램은 객체를 전혀 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c7b8526d94d8c27ed35f7c7cec40a0edae7df3f" translate="yes" xml:space="preserve">
          <source>Note that the two types AbstractStringSet.set and NoCaseStringSet.set are not compatible, and values of these two types do not match. This is the correct behavior: even though both set types contain elements of the same type (strings), they are built upon different orderings of that type, and different invariants need to be maintained by the operations (being strictly increasing for the standard ordering and for the case-insensitive ordering). Applying operations from AbstractStringSet to values of type NoCaseStringSet.set could give incorrect results, or build lists that violate the invariants of NoCaseStringSet.</source>
          <target state="translated">두 가지 유형의 AbstractStringSet.set 및 NoCaseStringSet.set은 호환되지 않으며이 두 유형의 값은 일치하지 않습니다. 이것은 올바른 동작입니다. 두 세트 유형 모두 동일한 유형 (문자열)의 요소를 포함하더라도 해당 유형의 다른 순서를 기반으로 빌드되며 작업에 의해 다른 불변성이 유지되어야합니다 (표준 순서 및 대소 문자를 구분하지 않는 순서). AbstractStringSet의 작업을 NoCaseStringSet.set 유형의 값에 적용하면 잘못된 결과가 발생하거나 NoCaseStringSet의 불변성을 위반하는 목록이 빌드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3e9f41fd86b1c950c9ef81d22b068692eccf75f" translate="yes" xml:space="preserve">
          <source>Note that the type constructor regular_nested always appears as 'a regular_nested in the definition above, with the same parameter 'a. Equipped with this type, one can compute a maximal depth with a classic recursive function</source>
          <target state="translated">유형 생성자 regular_nested는 항상 동일한 매개 변수 'a를 사용하여 위의 정의에서'a regular_nested '로 나타납니다. 이 유형을 장착하면 고전적인 재귀 함수로 최대 깊이를 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f894cfb3f87405bfa359dfc278dfe88f62a0e6bb" translate="yes" xml:space="preserve">
          <source>Note that the type money is not a subtype of type comparable, as the self type appears in contravariant position in the type of method leq. Indeed, an object m of class money has a method leq that expects an argument of type money since it accesses its value method. Considering m of type comparable would allow a call to method leq on m with an argument that does not have a method value, which would be an error.</source>
          <target state="translated">self 유형이 메소드 leq 유형에서 반 변성 위치에 나타나기 때문에 money 유형은 비교 가능한 유형의 하위 유형이 아닙니다. 실제로 money 클래스의 객체 m에는 value 메소드에 액세스하기 때문에 money 유형의 인수를 예상하는 leq 메소드가 있습니다. m 유형의 비교 가능을 고려하면 메소드 값이없는 인수를 사용하여 m에서 leq 메소드를 호출 할 수 있으며 이는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="95b3888a7e3a6dd69b6635ff1d23f6223d9986c2" translate="yes" xml:space="preserve">
          <source>Note that the type of p is point. This is an abbreviation automatically defined by the class definition above. It stands for the object type &amp;lt;get_x : int; move : int -&amp;gt; unit&amp;gt;, listing the methods of class point along with their types.</source>
          <target state="translated">p의 유형은 점입니다. 이것은 위의 클래스 정의에 의해 자동으로 정의 된 약어입니다. 객체 유형을 나타냅니다. &amp;lt;get_x : int; move : int-&amp;gt; unit&amp;gt;, 해당 유형과 함께 클래스 포인트의 메소드를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="66b9f6fff51ab2e45034f690441bdecd68df53d9" translate="yes" xml:space="preserve">
          <source>Note that the word-delimited form, for example {sql|...|sql}, should not be used for signaling that an extension is in use. Indeed, the user cannot see from the code whether this string literal has different semantics than they expect. Moreover, giving semantics to a specific delimiter limits the freedom to change the delimiter to avoid escaping issues.</source>
          <target state="translated">단어로 구분 된 형식 (예 : {sql | ... | sql})은 확장 프로그램이 사용 중임을 알리는 데 사용해서는 안됩니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 실제로 사용자는이 문자열 리터럴이 예상과 다른 의미를 갖는지 코드에서 볼 수 없습니다. 또한 특정 구분 기호에 의미를 부여하면 문제를 피하기 위해 구분 기호를 변경할 수있는 자유가 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="5daea91835e86ffb05aea9cef4296c3068906517" translate="yes" xml:space="preserve">
          <source>Note that this construction is only useful if the exception is raised between match&amp;hellip;with. Exception patterns can be combined with ordinary patterns at the toplevel,</source>
          <target state="translated">이 구성은 match&amp;hellip; with 사이에 예외가 발생하는 경우에만 유용합니다. 예외 패턴은 최상위에서 일반 패턴과 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c35684e12f57c72020fa856c51c0081aec8613e" translate="yes" xml:space="preserve">
          <source>Note that this is not the same thing as private and protected methods in Java or C++, which can be called from other objects of the same class. This is a direct consequence of the independence between types and classes in OCaml: two unrelated classes may produce objects of the same type, and there is no way at the type level to ensure that an object comes from a specific class. However a possible encoding of friend methods is given in section &lt;a href=&quot;#s%3Afriends&quot;&gt;3.17&lt;/a&gt;.</source>
          <target state="translated">이것은 동일한 클래스의 다른 객체에서 호출 할 수있는 Java 또는 C ++의 private 및 protected 메서드와는 다릅니다. 이것은 OCaml의 유형과 클래스 간의 독립성의 직접적인 결과입니다. 두 개의 관련되지 않은 클래스가 동일한 유형의 객체를 생성 할 수 있으며 유형 수준에서 객체가 특정 클래스에서 오는지 확인할 방법이 없습니다. 그러나 friend 메소드의 가능한 인코딩은 섹션 &lt;a href=&quot;#s%3Afriends&quot;&gt;3.17에 나와&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="5301e9ce9eaee70b52bc0e30c461f8dc4f50979b" translate="yes" xml:space="preserve">
          <source>Note that this syntax is not valid within OCaml: average has an universally quantified type 'a inside the type of one of its argument whereas for polymorphic recursion the universally quantified type was introduced before the rest of the type. This position of the universally quantified type means that average is a second-rank polymorphic function. This kind of higher-rank functions is not directly supported by OCaml: type inference for second-rank polymorphic function and beyond is undecidable; therefore using this kind of higher-rank functions requires to handle manually these universally quantified types.</source>
          <target state="translated">이 구문은 OCaml 내에서 유효하지 않습니다. 평균은 인수 중 하나의 유형 내에 보편적으로 정량화 된 유형 'a가있는 반면 다형성 재귀의 경우 보편적으로 정량화 된 유형이 나머지 유형보다 먼저 도입되었습니다. 보편적으로 정량화 된 유형의이 위치는 평균이 2 순위 다형성 함수임을 의미합니다. 이러한 종류의 상위 함수는 OCaml에서 직접 지원하지 않습니다. 2 순위 다형성 함수 이상에 대한 유형 추론은 결정할 수 없습니다. 따라서 이러한 종류의 더 높은 순위 함수를 사용하려면 이러한 보편적으로 정량화 된 유형을 수동으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="0537a61ab3006dae26fac6b5f19a889d7c194bae" translate="yes" xml:space="preserve">
          <source>Note that this will only affect the prefix of the trace file, there is no option to specify the full effective file name. This restriction is in place to make room for future improvements to the instrumented runtime, where the single trace file per session design may be replaced.</source>
          <target state="translated">이는 추적 파일의 접두사에만 영향을 미치며 전체 유효 파일 이름을 지정하는 옵션은 없습니다. 이 제한은 세션 설계 당 단일 추적 파일을 대체 할 수있는 계측 된 런타임의 향후 개선을위한 공간을 마련하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="e53f78797414436c28938372fd25e7a220604184" translate="yes" xml:space="preserve">
          <source>Note that we can rewrite the type of f and f' as</source>
          <target state="translated">f와 f '의 유형을 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9855ac639cc02bb505afbab05f1ffccd97cf7fa0" translate="yes" xml:space="preserve">
          <source>Note that when &lt;code&gt;fn&lt;/code&gt; is called all the functions registered with &lt;a href=&quot;stdlib#VALat_exit&quot;&gt;&lt;code&gt;at_exit&lt;/code&gt;&lt;/a&gt; have already been called. Because of this you must make sure any output channel &lt;code&gt;fn&lt;/code&gt; writes on is flushed.</source>
          <target state="translated">&lt;code&gt;fn&lt;/code&gt; 이 호출 되면 &lt;a href=&quot;stdlib#VALat_exit&quot;&gt; &lt;code&gt;at_exit&lt;/code&gt; 에&lt;/a&gt; 등록 된 모든 함수 가 이미 호출되었습니다. 이 때문에 &lt;code&gt;fn&lt;/code&gt; 이 쓰는 모든 출력 채널 이 플러시 되는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5902b468c9420c576a1090e7ba4580b19535ba05" translate="yes" xml:space="preserve">
          <source>Note that when you don&amp;rsquo;t need an argument, you can still use a wildcard pattern, but you must prefix it with the label.</source>
          <target state="translated">인수가 필요하지 않은 경우에도 와일드 카드 패턴을 사용할 수 있지만 레이블을 접두사로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="42951dc6e5e061dd8581c9cd3e18ab7ff1122703" translate="yes" xml:space="preserve">
          <source>Note that you can also remove manifest types, by substituting with the same type.</source>
          <target state="translated">동일한 유형으로 대체하여 매니페스트 유형을 제거 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d24bd50ee40c13de42decb018fafac2cc30412b" translate="yes" xml:space="preserve">
          <source>Note that, if a comment appears immediately next to multiple items, as in:</source>
          <target state="translated">다음과 같이 댓글이 여러 항목 바로 옆에 표시되는 경우 :</target>
        </trans-unit>
        <trans-unit id="579e1ef453daed542dee9b6448ed260939315131" translate="yes" xml:space="preserve">
          <source>Note that, in the &lt;a href=&quot;modtypes#specification&quot;&gt;specification&lt;/a&gt; case, the &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;s must be parenthesized if they use the with&lt;a href=&quot;modtypes#mod-constraint&quot;&gt;mod-constraint&lt;/a&gt; construct.</source>
          <target state="translated">에, 그 주 &lt;a href=&quot;modtypes#specification&quot;&gt;사양의&lt;/a&gt; 경우는 &lt;a href=&quot;modtypes#module-type&quot;&gt;모듈 형&lt;/a&gt; 들이 함께 사용하는 경우들 괄호해야 &lt;a href=&quot;modtypes#mod-constraint&quot;&gt;모드 - 제약&lt;/a&gt; 구축합니다.</target>
        </trans-unit>
        <trans-unit id="9ecccd058b8859c03de2fd449f57787fc6750b3c" translate="yes" xml:space="preserve">
          <source>Note that, unlike type declarations, type substitution declarations are not recursive, so substitutions like the following are rejected:</source>
          <target state="translated">유형 선언과 달리 유형 대체 선언은 재귀 적이 지 않으므로 다음과 같은 대체는 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="78d522de17989d9555a8bbce2b8df8ef04eb9f91" translate="yes" xml:space="preserve">
          <source>Note the difference between these two coercions: in the case of to_c2, the type #c2 = &amp;lt; m : 'a; .. &amp;gt; as 'a is polymorphically recursive (according to the explicit recursion in the class type of c2); hence the success of applying this coercion to an object of class c0. On the other hand, in the first case, c1 was only expanded and unrolled twice to obtain &amp;lt; m : &amp;lt; m : c1; .. &amp;gt;; .. &amp;gt; (remember #c1 = &amp;lt; m : c1; .. &amp;gt;), without introducing recursion. You may also note that the type of to_c2 is #c2 -&amp;gt; c2 while the type of to_c1 is more general than #c1 -&amp;gt; c1. This is not always true, since there are class types for which some instances of #c are not subtypes of c, as explained in section &lt;a href=&quot;#s%3Abinary-methods&quot;&gt;3.16&lt;/a&gt;. Yet, for parameterless classes the coercion (_ :&amp;gt; c) is always more general than (_ : #c :&amp;gt; c).</source>
          <target state="translated">이 두 강제 변환의 차이점에 유의하십시오. to_c2의 경우 유형 # c2 = &amp;lt;m : 'a; ..&amp;gt; as 'a는 다형성 재귀 적입니다 (c2 클래스 유형의 명시 적 재귀에 따라). 따라서이 강제를 c0 클래스의 객체에 적용하는 데 성공했습니다. 반면에 첫 번째 경우 c1은 &amp;lt;m : &amp;lt;m : c1을 얻기 위해 두 번만 확장되고 펼쳐졌습니다. ..&amp;gt;; ..&amp;gt; (기억 # c1 = &amp;lt;m : c1; ..&amp;gt;), 재귀를 도입하지 않습니다. to_c2의 유형은 # c2-&amp;gt; c2이고 to_c1의 유형은 # c1-&amp;gt; c1보다 더 일반적입니다. 섹션 &lt;a href=&quot;#s%3Abinary-methods&quot;&gt;3.16에&lt;/a&gt; 설명 된 것처럼 #c의 일부 인스턴스가 c의 하위 유형이 아닌 클래스 유형이 있기 때문에 항상 그런 것은 아닙니다 . 그러나 매개 변수가없는 클래스의 경우 강제 (_ :&amp;gt; c)는 항상 (_ : #c :&amp;gt;보다 더 일반적입니다.씨).</target>
        </trans-unit>
        <trans-unit id="75c5273bc385a2bc73dec61088cee3a19dd057d4" translate="yes" xml:space="preserve">
          <source>Note the use of double underscores in Mylib__A and Mylib__B. These were chosen on purpose; the compiler uses the following heuristic when printing paths: given a path Lib__fooBar, if Lib.FooBar exists and is an alias for Lib__fooBar, then the compiler will always display Lib.FooBar instead of Lib__fooBar. This way the long Mylib__ names stay hidden and all the user sees is the nicer dot names. This is how the OCaml standard library is compiled.</source>
          <target state="translated">Mylib__A 및 Mylib__B에서 이중 밑줄 사용에 유의하십시오. 이들은 의도적으로 선택되었습니다. 컴파일러는 경로를 인쇄 할 때 다음 휴리스틱을 사용합니다. 경로 Lib__fooBar가 주어지고 Lib.FooBar가 존재하고 Lib__fooBar의 별칭이면 컴파일러는 항상 Lib__fooBar 대신 Lib.FooBar를 표시합니다. 이렇게하면 긴 Mylib__ 이름이 숨겨진 상태로 유지되고 사용자가 보는 모든 점이 더 멋진 점 이름입니다. 이것이 OCaml 표준 라이브러리가 컴파일되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="dd1d07e0d8f7923bb8cef98de8decf201a2336ee" translate="yes" xml:space="preserve">
          <source>Note the use of override for method times. Writing new money2 (k *. repr) instead of {&amp;lt; repr = k *. repr &amp;gt;} would not behave well with inheritance: in a subclass money3 of money2 the times method would return an object of class money2 but not of class money3 as would be expected.</source>
          <target state="translated">메서드 시간에 대한 재정의 사용에 유의하십시오. {&amp;lt;repr = k * 대신 새 money2 (k *. repr)를 작성합니다. repr&amp;gt;}은 상속으로 잘 작동하지 않습니다. money2의 하위 클래스 money3에서 times 메소드는 예상대로 money2 클래스의 객체를 반환하지만 money3 클래스의 객체는 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="a7c6195c71846fafbab4e4cc00dfd41c54465d1b" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;Lazy.force&lt;/code&gt; is not thread-safe. If you use this module in a multi-threaded program, you will need to add some locks.</source>
          <target state="translated">참고 : &lt;code&gt;Lazy.force&lt;/code&gt; 는 스레드로부터 안전하지 않습니다. 다중 스레드 프로그램에서이 모듈을 사용하는 경우 몇 가지 잠금을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="6ee1f0993f734f3d32255902fa4253dbe8464720" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;lazy_t&lt;/code&gt; is the built-in type constructor used by the compiler for the &lt;code&gt;lazy&lt;/code&gt; keyword. You should not use it directly. Always use &lt;code&gt;Lazy.t&lt;/code&gt; instead.</source>
          <target state="translated">참고 : &lt;code&gt;lazy_t&lt;/code&gt; 는 &lt;code&gt;lazy&lt;/code&gt; 키워드 에 대해 컴파일러에서 사용하는 내장 유형 생성자 입니다. 직접 사용해서는 안됩니다. 대신 항상 &lt;code&gt;Lazy.t&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c65beeb77bdc7dc7ee42cc9da173d89eac9e501e" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;open_in&lt;/code&gt; returns a formatted input channel that efficiently reads characters in large chunks; in contrast, &lt;code&gt;from_channel&lt;/code&gt; below returns formatted input channels that must read one character at a time, leading to a much slower scanning rate.</source>
          <target state="translated">참고 : &lt;code&gt;open_in&lt;/code&gt; 은 큰 청크의 문자를 효율적으로 읽는 형식화 된 입력 채널을 반환합니다. 대조적으로 아래의 &lt;code&gt;from_channel&lt;/code&gt; 은 한 번에 한 문자 씩 읽어야하는 형식화 된 입력 채널을 반환 하므로 스캔 속도가 훨씬 느려집니다.</target>
        </trans-unit>
        <trans-unit id="fbb80132052a566980a3f39541caf9bc002b1c90" translate="yes" xml:space="preserve">
          <source>Note: Existing command line options can be redefined using this function.</source>
          <target state="translated">참고 : 기존 명령 줄 옵션은이 기능을 사용하여 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8f6141fe67a802e7e2bf4927ccb64d0289512ae" translate="yes" xml:space="preserve">
          <source>Note: For maximum backwards compatibility in Unicode mode, if the argument is not a valid UTF-8 string, this function will fall back to assuming that it is encoded in the current code page.</source>
          <target state="translated">참고 : 유니 코드 모드에서 이전 버전과의 호환성을 극대화하기 위해 인수가 유효한 UTF-8 문자열이 아닌 경우이 함수는 현재 코드 페이지에서 인코딩 된 것으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="2ae74bcb6937d84acfff2f5cc371f0df0a9df245" translate="yes" xml:space="preserve">
          <source>Note: If lazy patterns appear in multiple cases in a pattern-matching, lazy expressions may be forced even outside of the case ultimately selected by the pattern matching. In the example above, the suspension &lt;code&gt;x&lt;/code&gt; is always computed.</source>
          <target state="translated">참고 : 패턴 일치에서 지연 패턴이 여러 경우에 나타나는 경우 패턴 일치에 의해 궁극적으로 선택되는 케이스 외부에서도 지연식이 강제로 적용될 수 있습니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 위의 예에서 서스펜션 &lt;code&gt;x&lt;/code&gt; 는 항상 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="2d7d69b5a35fb8fdd2ec3a14decb5554cdfa109f" translate="yes" xml:space="preserve">
          <source>Note: Including the header files without first defining CAML_NAME_SPACE introduces in scope short names for most functions. Those short names are deprecated, and may be removed in the future because they usually produce clashes with names defined by other C libraries.</source>
          <target state="translated">참고 : CAML_NAME_SPACE를 먼저 정의하지 않고 헤더 파일을 포함하면 대부분의 함수에 대해 범위 짧은 이름이 도입됩니다. 이러한 짧은 이름은 더 이상 사용되지 않으며 일반적으로 다른 C 라이브러리에서 정의한 이름과 충돌을 일으키기 때문에 향후 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51519ebae7f9975b891bddfc046ca788658aed4d" translate="yes" xml:space="preserve">
          <source>Note: It is a &lt;em&gt;programming error&lt;/em&gt; if other kinds of exceptions are raised by &lt;code&gt;finally&lt;/code&gt;, as any exception raised in &lt;code&gt;work&amp;nbsp;()&lt;/code&gt; will be lost in the event of a &lt;a href=&quot;fun#EXCEPTIONFinally_raised&quot;&gt;&lt;code&gt;Fun.Finally_raised&lt;/code&gt;&lt;/a&gt; exception. Therefore, one should make sure to handle those inside the finally.</source>
          <target state="translated">참고 : &lt;a href=&quot;fun#EXCEPTIONFinally_raised&quot;&gt; &lt;code&gt;Fun.Finally_raised&lt;/code&gt; &lt;/a&gt; 예외가 발생 하면 &lt;code&gt;work&amp;nbsp;()&lt;/code&gt; 에서 발생한 모든 예외 가 손실 되므로 &lt;code&gt;finally&lt;/code&gt; 에 의해 다른 종류의 예외가 발생하면 &lt;em&gt;프로그래밍 오류&lt;/em&gt; 입니다. 따라서 최종적으로 내부를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="bedbf1279049e8ebd79ce828d1966e381406da84" translate="yes" xml:space="preserve">
          <source>Note: OCaml strings used to be modifiable in place, for instance via the &lt;a href=&quot;string#VALset&quot;&gt;&lt;code&gt;String.set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string#VALblit&quot;&gt;&lt;code&gt;String.blit&lt;/code&gt;&lt;/a&gt; functions described below. This usage is only possible when the compiler is put in &quot;unsafe-string&quot; mode by giving the &lt;code&gt;-unsafe-string&lt;/code&gt; command-line option. This compatibility mode makes the types &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;bytes&lt;/code&gt; (see module &lt;a href=&quot;bytes&quot;&gt;&lt;code&gt;Bytes&lt;/code&gt;&lt;/a&gt;) interchangeable so that functions expecting byte sequences can also accept strings as arguments and modify them.</source>
          <target state="translated">참고 : OCaml 문자열은 예를 들어 아래에 설명 된 &lt;a href=&quot;string#VALset&quot;&gt; &lt;code&gt;String.set&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;string#VALblit&quot;&gt; &lt;code&gt;String.blit&lt;/code&gt; &lt;/a&gt; 함수 를 통해 제자리에서 수정할 수있었습니다 . 이 사용법은 &lt;code&gt;-unsafe-string&lt;/code&gt; 명령 줄 옵션 을 제공하여 컴파일러가 &quot;unsafe-string&quot;모드로 전환 된 경우에만 가능합니다 . 이 호환성 모드는 유형 &lt;code&gt;string&lt;/code&gt; 과 &lt;code&gt;bytes&lt;/code&gt; (모듈 &lt;a href=&quot;bytes&quot;&gt; &lt;code&gt;Bytes&lt;/code&gt; &lt;/a&gt; 참조 )를 상호 교환 가능하게 만들어 바이트 시퀀스를 예상하는 함수도 문자열을 인수로 받아 수정할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="c72b40ee4e5477e5f7d6e7553ca34de54319049d" translate="yes" xml:space="preserve">
          <source>Note: On some systems, with interactive input, an end-of-file may be followed by more characters. However, ocamllex will not correctly handle regular expressions that contain eof followed by something else.</source>
          <target state="translated">참고 : 대화식 입력을 사용하는 일부 시스템에서는 파일 끝 뒤에 더 많은 문자가 올 수 있습니다. 그러나 ocamllex는 eof 다음에 다른 것을 포함하는 정규식을 올바르게 처리하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="01558340b88b057d42608e1a6ec3ca0cfdf079a7" translate="yes" xml:space="preserve">
          <source>Note: The strings returned by caml_stat_strdup_to_os and caml_stat_strdup_of_os are allocated using caml_stat_alloc, so they need to be deallocated using caml_stat_free when they are no longer needed.</source>
          <target state="translated">참고 : caml_stat_strdup_to_os 및 caml_stat_strdup_of_os에서 반환 된 문자열은 caml_stat_alloc을 사용하여 할당되므로 더 이상 필요하지 않은 경우 caml_stat_free를 사용하여 할당을 취소해야합니다.</target>
        </trans-unit>
        <trans-unit id="7848f4c2eb8f564919b210b8bbfed2cdf5ec566d" translate="yes" xml:space="preserve">
          <source>Note: This example is on a Unix system. The exact command lines may be different on other systems.</source>
          <target state="translated">참고 :이 예제는 Unix 시스템에 있습니다. 다른 시스템에서는 정확한 명령 줄이 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84be470836b2d22c5aa15438ce95fd6f0d863631" translate="yes" xml:space="preserve">
          <source>Note: This is an experimental feature of OCaml: the set of APIs below, as well as their exact semantics are not final and subject to change in future releases.</source>
          <target state="translated">참고 : 이것은 OCaml의 실험적 기능입니다. 아래의 API 세트와 정확한 의미는 최종적인 것이 아니며 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="823ecd73e96dee992922fa24d09d174fea0a6e57" translate="yes" xml:space="preserve">
          <source>Note: To prevent the interpretation of a &lt;code&gt;@&lt;/code&gt; character as a pretty-printing indication, escape it with a &lt;code&gt;%&lt;/code&gt; character. Old quotation mode &lt;code&gt;@@&lt;/code&gt; is deprecated since it is not compatible with formatted input interpretation of character &lt;code&gt;'@'&lt;/code&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;@&lt;/code&gt; 문자가 예쁘게 인쇄되는 표시로 해석되지 않도록하려면 &lt;code&gt;%&lt;/code&gt; 문자로 이스케이프하십시오 . 이전 인용 모드 &lt;code&gt;@@&lt;/code&gt; 는 문자 &lt;code&gt;'@'&lt;/code&gt; 의 형식화 된 입력 해석과 호환되지 않으므로 더 이상 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6d9bd6a881cbdf7f9df1e298990c77110c41a774" translate="yes" xml:space="preserve">
          <source>Note: When changing to a low-fragmentation policy, you may need to augment the &lt;code&gt;space_overhead&lt;/code&gt; setting, for example using &lt;code&gt;100&lt;/code&gt; instead of the default &lt;code&gt;80&lt;/code&gt; which is tuned for next-fit. Indeed, the difference in fragmentation behavior means that different policies will have different proportion of &quot;wasted space&quot; for a given program. Less fragmentation means a smaller heap so, for the same amount of wasted space, a higher proportion of wasted space. This makes the GC work harder, unless you relax it by increasing &lt;code&gt;space_overhead&lt;/code&gt;.</source>
          <target state="translated">참고 : 낮은 조각화 정책으로 변경할 때 &lt;code&gt;space_overhead&lt;/code&gt; 설정을 늘려야 할 수 있습니다. 예를 들어 다음 맞춤을 위해 조정 된 기본값 &lt;code&gt;80&lt;/code&gt; 대신 &lt;code&gt;100&lt;/code&gt; 을 사용합니다 . 실제로 단편화 동작의 차이는 정책마다 주어진 프로그램에 대해 &quot;낭비 된 공간&quot;의 비율이 다르다는 것을 의미합니다. 단편화가 적다는 것은 힙이 더 작다는 것을 의미하므로 낭비되는 공간의 양이 같으면 낭비되는 공간의 비율이 높아집니다. 이렇게하면 &lt;code&gt;space_overhead&lt;/code&gt; 를 늘려 긴장을 풀지 않는 한 GC가 더 열심히 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="e1c53f545ae2f49916857c5dbc74afbbb3f17b01" translate="yes" xml:space="preserve">
          <source>Note: a scanning action may often require to examine one character in advance; when this 'lookahead' character does not belong to the token read, it is stored back in the scanning buffer and becomes the next character yet to be read.</source>
          <target state="translated">참고 : 스캔 작업은 종종 한 문자를 미리 검사해야 할 수 있습니다. 이 '미리보기'문자가 읽은 토큰에 속하지 않으면 스캔 버퍼에 다시 저장되고 아직 읽을 다음 문자가됩니다.</target>
        </trans-unit>
        <trans-unit id="1704bf03b020589de313c230890a2e46b48b94e8" translate="yes" xml:space="preserve">
          <source>Note: all directives start with a # (sharp) symbol. This # must be typed before the directive, and must not be confused with the # prompt displayed by the interactive loop. For instance, typing #quit;; will exit the toplevel loop, but typing quit;; will result in an &amp;ldquo;unbound value quit&amp;rdquo; error.</source>
          <target state="translated">참고 : 모든 지시문은 # (날카로운) 기호로 시작합니다. 이 #는 지시문 앞에 입력해야하며 대화 형 루프에 의해 표시되는 # 프롬프트와 혼동되어서는 안됩니다. 예를 들어 #quit ;; 최상위 루프를 종료하지만 quit ;; &quot;unbound value quit&quot;오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="661bb9a4a4fadd61ccae3d7f4cea4d69fb6a3c2a" translate="yes" xml:space="preserve">
          <source>Note: all input/output functions can raise &lt;code&gt;Sys_error&lt;/code&gt; when the system calls they invoke fail.</source>
          <target state="translated">참고 : 모든 입력 / 출력 함수는 호출하는 시스템 호출이 실패 할 때 &lt;code&gt;Sys_error&lt;/code&gt; 를 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f409c4273c4016899888e40b1686a702c39d6ff" translate="yes" xml:space="preserve">
          <source>Note: all the functions of this module (except &lt;a href=&quot;unix#VALerror_message&quot;&gt;&lt;code&gt;Unix.error_message&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;unix#VALhandle_unix_error&quot;&gt;&lt;code&gt;Unix.handle_unix_error&lt;/code&gt;&lt;/a&gt;) are liable to raise the &lt;a href=&quot;unix#EXCEPTIONUnix_error&quot;&gt;&lt;code&gt;Unix.Unix_error&lt;/code&gt;&lt;/a&gt; exception whenever the underlying system call signals an error.</source>
          <target state="translated">참고 :이 모듈의 모든 기능 ( &lt;a href=&quot;unix#VALerror_message&quot;&gt; &lt;code&gt;Unix.error_message&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;unix#VALhandle_unix_error&quot;&gt; &lt;code&gt;Unix.handle_unix_error&lt;/code&gt; &lt;/a&gt; 제외 )은 기본 시스템 호출이 오류를 신호 할 때마다 &lt;a href=&quot;unix#EXCEPTIONUnix_error&quot;&gt; &lt;code&gt;Unix.Unix_error&lt;/code&gt; &lt;/a&gt; 예외를 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9881244812e43ce519dbdb2a33d7a86a78dc2b73" translate="yes" xml:space="preserve">
          <source>Note: changing the allocation policy at run-time forces a heap compaction, which is a lengthy operation unless the heap is small (e.g. at the start of the program).</source>
          <target state="translated">참고 : 런타임에 할당 정책을 변경하면 힙 압축이 강제 실행됩니다. 힙이 작지 않은 경우 (예 : 프로그램 시작시) 긴 작업입니다.</target>
        </trans-unit>
        <trans-unit id="8e740cc9128b3de503776a812fd3bb3f85d80f59" translate="yes" xml:space="preserve">
          <source>Note: do not use the C int type in correspondence with (int [@untagged]). This is because they often differ in size.</source>
          <target state="translated">참고 : (int [@untagged])와 대응하여 C int 유형을 사용하지 마십시오. 이것은 종종 크기가 다르기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="32f28c1f397eec585fd0b2e1caaaf11772a9b784" translate="yes" xml:space="preserve">
          <source>Note: if the program is compiled with the &lt;code&gt;-rectypes&lt;/code&gt; option, ill-founded recursive definitions of the form &lt;code&gt;let&amp;nbsp;rec&amp;nbsp;x&amp;nbsp;=&amp;nbsp;lazy&amp;nbsp;x&lt;/code&gt; or &lt;code&gt;let&amp;nbsp;rec&amp;nbsp;x&amp;nbsp;=&amp;nbsp;lazy(lazy(...(lazy&amp;nbsp;x)))&lt;/code&gt; are accepted by the type-checker and lead, when forced, to ill-formed values that trigger infinite loops in the garbage collector and other parts of the run-time system. Without the &lt;code&gt;-rectypes&lt;/code&gt; option, such ill-founded recursive definitions are rejected by the type-checker.</source>
          <target state="translated">참고 : 프로그램이 &lt;code&gt;-rectypes&lt;/code&gt; 옵션으로 컴파일 된 경우 &lt;code&gt;let&amp;nbsp;rec&amp;nbsp;x&amp;nbsp;=&amp;nbsp;lazy&amp;nbsp;x&lt;/code&gt; 또는 &lt;code&gt;let&amp;nbsp;rec&amp;nbsp;x&amp;nbsp;=&amp;nbsp;lazy(lazy(...(lazy&amp;nbsp;x)))&lt;/code&gt; 형식의 잘못된 재귀 정의가 형식에 의해 허용됩니다. -checker 및 강제 될 때 가비지 수집기 및 런타임 시스템의 다른 부분에서 무한 루프를 트리거하는 잘못된 형식의 값으로 유도합니다. &lt;code&gt;-rectypes&lt;/code&gt; 옵션이 없으면 이러한 잘못된 재귀 정의는 유형 검사기에 의해 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="ebef76f46f02ed8c6dbb4a7a51649415bd9b78c4" translate="yes" xml:space="preserve">
          <source>Note: in order to insure that the dynamically-loaded modules have access to all the libraries that are visible to the main program (and not just to the parts of those libraries that are actually used in the main program), programs using the dynlink library should be linked with -linkall.</source>
          <target state="translated">참고 : 동적으로로드 된 모듈이 기본 프로그램에서 볼 수있는 모든 라이브러리에 액세스 할 수 있도록하기 위해 (기본 프로그램에서 실제로 사용되는 라이브러리 부분뿐만 아니라) dynlink 라이브러리를 사용하는 프로그램 -linkall과 연결되어야합니다.</target>
        </trans-unit>
        <trans-unit id="38ff267a2f14d6dd07cded0766c39d2aeb6bc63e" translate="yes" xml:space="preserve">
          <source>Note: in the case of &lt;code&gt;global_substitute&lt;/code&gt; and &lt;code&gt;substitute_first&lt;/code&gt;, a call to &lt;code&gt;matched_string&lt;/code&gt; is only valid within the &lt;code&gt;subst&lt;/code&gt; argument, not after &lt;code&gt;global_substitute&lt;/code&gt; or &lt;code&gt;substitute_first&lt;/code&gt; returns.</source>
          <target state="translated">참고 :의 경우 &lt;code&gt;global_substitute&lt;/code&gt; 및 &lt;code&gt;substitute_first&lt;/code&gt; 에 전화 &lt;code&gt;matched_string&lt;/code&gt; 가 내에서만 유효 &lt;code&gt;subst&lt;/code&gt; 후가 아니라 인수 &lt;code&gt;global_substitute&lt;/code&gt; 또는 &lt;code&gt;substitute_first&lt;/code&gt; 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="922b543ff896ef77cd9d8044969360c9a53c3cbf" translate="yes" xml:space="preserve">
          <source>Note: in the interactive system, when input is read from &lt;a href=&quot;stdlib#VALstdin&quot;&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/a&gt;, the newline character that triggers evaluation is part of the input; thus, the scanning specifications must properly skip this additional newline character (for instance, simply add a &lt;code&gt;'\n'&lt;/code&gt; as the last character of the format string).</source>
          <target state="translated">참고 : 대화 형 시스템에서 &lt;a href=&quot;stdlib#VALstdin&quot;&gt; &lt;code&gt;stdin&lt;/code&gt; &lt;/a&gt; 에서 입력을 읽을 때 평가를 트리거하는 개행 문자가 입력의 일부입니다. 따라서 스캔 사양은이 추가 개행 문자를 올바르게 건너 뛰어야합니다 (예 : 형식 문자열의 마지막 문자로 &lt;code&gt;'\n'&lt;/code&gt; 을 추가하기 만하면 됩니다).</target>
        </trans-unit>
        <trans-unit id="145e7cd4d750ab522e65fe8e15a2f8018a1e2e0d" translate="yes" xml:space="preserve">
          <source>Note: installation of signal handlers is performed via the functions &lt;a href=&quot;sys#VALsignal&quot;&gt;&lt;code&gt;Sys.signal&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sys#VALset_signal&quot;&gt;&lt;code&gt;Sys.set_signal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 : 신호 처리기 설치는 &lt;a href=&quot;sys#VALsignal&quot;&gt; &lt;code&gt;Sys.signal&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;sys#VALset_signal&quot;&gt; &lt;code&gt;Sys.set_signal&lt;/code&gt; &lt;/a&gt; 함수를 통해 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="629c5048579fb0ed4f8a77f6a5cbc67a5d0b3404" translate="yes" xml:space="preserve">
          <source>Note: it is not recommended to use warning sets (i.e. letters) as arguments to -warn-error in production code, because this can break your build when future versions of OCaml add some new warnings.</source>
          <target state="translated">참고 : 프로덕션 코드에서 경고 세트 (예 : 문자)를 -warn-error에 대한 인수로 사용하지 않는 것이 좋습니다. OCaml의 향후 버전에서 새로운 경고가 추가 될 때 빌드가 손상 될 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="443e1ada797e5067adc60f24f10b243b6714e1e3" translate="yes" xml:space="preserve">
          <source>Note: never use &lt;code&gt;print_flush&lt;/code&gt; in the normal course of a pretty-printing routine, since the pretty-printer uses a complex buffering machinery to properly indent the output; manually flushing those buffers at random would conflict with the pretty-printer strategy and result to poor rendering.</source>
          <target state="translated">참고 : pretty-printer는 출력을 적절하게 들여 쓰기 위해 복잡한 버퍼링 기계를 사용하기 때문에 pretty-printing 루틴의 정상적인 과정 에서는 &lt;code&gt;print_flush&lt;/code&gt; 를 사용하지 마십시오 . 이러한 버퍼를 무작위로 수동으로 플러시하면 프리티 프린터 전략과 충돌하여 렌더링이 제대로되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9341c4536efd6e856d0cfcbf40db0f74c45c131a" translate="yes" xml:space="preserve">
          <source>Note: printing within tabulation box is line directed, so arbitrary line splitting inside a tabulation box leads to poor rendering. Yet, controlled use of tabulation boxes allows simple printing of columns within module &lt;a href=&quot;format&quot;&gt;&lt;code&gt;Format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 : 표 상자 내에서 인쇄는 선 방향으로 이루어 지므로 표 상자 내에서 임의의 선이 분할되면 렌더링이 제대로되지 않습니다. 그러나 테이블 상자의 제어 된 사용을 통해 &lt;a href=&quot;format&quot;&gt; &lt;code&gt;Format&lt;/code&gt; &lt;/a&gt; 모듈 내에서 열을 간단하게 인쇄 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9834335cf6fe5fc53b95c18382af756506e19d5" translate="yes" xml:space="preserve">
          <source>Note: the acquire and release functions described above were introduced in OCaml 3.12. Older code uses the following historical names, declared in &amp;lt;caml/signals.h&amp;gt;:</source>
          <target state="translated">참고 : 위에서 설명한 획득 및 해제 기능은 OCaml 3.12에서 도입되었습니다. 이전 코드는 &amp;lt;caml / signals.h&amp;gt;에 선언 된 다음과 같은 기록 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2177e9bf34eb19b28eb32c96470882b643de2040" translate="yes" xml:space="preserve">
          <source>Note: the argument to &lt;code&gt;regexp&lt;/code&gt; is usually a string literal. In this case, any backslash character in the regular expression must be doubled to make it past the OCaml string parser. For example, the following expression:</source>
          <target state="translated">참고 : &lt;code&gt;regexp&lt;/code&gt; 에 대한 인수 는 일반적으로 문자열 리터럴입니다. 이 경우 정규식의 백 슬래시 문자는 OCaml 문자열 구문 분석기를지나도록 두 배로 늘려야합니다. 예를 들어, 다음 표현식 :</target>
        </trans-unit>
        <trans-unit id="ffd47f5e6d4b6f57e31724916a1771922f810447" translate="yes" xml:space="preserve">
          <source>Note: the finalize, compare, hash, serialize and deserialize functions attached to custom block descriptors must never trigger a garbage collection. Within these functions, do not call any of the OCaml allocation functions, and do not perform a callback into OCaml code. Do not use CAMLparam to register the parameters to these functions, and do not use CAMLreturn to return the result.</source>
          <target state="translated">참고 : 사용자 지정 블록 설명자에 연결된 finalize, compare, hash, serialize 및 deserialize 함수는 가비지 수집을 트리거하지 않아야합니다. 이러한 함수 내에서 OCaml 할당 함수를 호출하지 말고 OCaml 코드에 대한 콜백을 수행하지 마십시오. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ CAMLparam을 사용하여 이러한 함수에 매개 변수를 등록하지 말고 CAMLreturn을 사용하여 결과를 반환하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2fa124181f0ab52f95d5aba93b0fc5a2ffbf20f4" translate="yes" xml:space="preserve">
          <source>Note: the notions of space and line splitting are abstract for the pretty-printing engine, since those notions can be completely redefined by the programmer. However, in the pretty-printer default setting, ``output a space'' simply means printing a space character (ASCII code 32) and ``split the line'' means printing a newline character (ASCII code 10).</source>
          <target state="translated">참고 : 공간 및 줄 분할 개념은 프로그래머가 완전히 재정의 할 수 있기 때문에 예쁜 인쇄 엔진의 경우 추상적 인 개념입니다. 그러나 pretty-printer 기본 설정에서``공백 출력 ''은 단순히 공백 문자 (ASCII 코드 32)를 인쇄하는 것을 의미하고``줄 분할 ''은 개행 문자 (ASCII 코드 10)를 인쇄하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8057d5d098672ea84c975196f3af91fed42a2aa5" translate="yes" xml:space="preserve">
          <source>Note: the operators &amp;amp;&amp;amp;, ||, and ~- are handled specially and it is not advisable to change their meaning.</source>
          <target state="translated">참고 : 연산자 &amp;amp;&amp;amp;, || 및 ~-는 특별히 처리되며 그 의미를 변경하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7efcff7406c86de78d66a3b54bdcef50f38f8039" translate="yes" xml:space="preserve">
          <source>Note: this API is EXPERIMENTAL. It may change without prior notice.</source>
          <target state="translated">참고 :이 API는 실험적입니다. 예고없이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6965dbae3f43f8571341ee41d021ab34917b0487" translate="yes" xml:space="preserve">
          <source>Note: this is not the normal way to output a new line; the preferred method is using break hints within a vertical pretty-printing box.</source>
          <target state="translated">참고 : 이것은 새 줄을 출력하는 일반적인 방법이 아닙니다. 선호되는 방법은 세로로 예쁜 인쇄 상자 내에서 브레이크 힌트를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c7ebc2b8878898c4c60d71b3c20e680a573cda23" translate="yes" xml:space="preserve">
          <source>Note: this only applies to the native compiler. So whenever you use any of these methods, you have to provide an alternative byte-code stub that ignores all the special annotations.</source>
          <target state="translated">참고 : 이는 네이티브 컴파일러에만 적용됩니다. 따라서 이러한 방법 중 하나를 사용할 때마다 모든 특수 주석을 무시하는 대체 바이트 코드 스텁을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="87c9f2b925633b8f6e73b9bf63c5cdc7777edeca" translate="yes" xml:space="preserve">
          <source>Note: this possibility is offered only for backward compatibility with older versions of OCaml and will be removed in a future version. New code should use byte sequences and the Bytes.set function.</source>
          <target state="translated">참고 :이 가능성은 이전 버전의 OCaml과의 하위 호환성을 위해서만 제공되며 향후 버전에서 제거됩니다. 새 코드는 바이트 시퀀스와 Bytes.set 함수를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d8d829c25ab6089d7e4980f899718094fb71afc" translate="yes" xml:space="preserve">
          <source>Note: when a label declaration is followed by a semi-colon, attributes can also be put after the semi-colon (in which case they are merged to those specified before).</source>
          <target state="translated">참고 : 레이블 선언 뒤에 세미콜론이 오면 세미콜론 뒤에 속성을 넣을 수도 있습니다 (이 경우 속성은 이전에 지정된 속성에 병합됩니다).</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="d5e45a48a978d6899712bd076f72479aeea810fa" translate="yes" xml:space="preserve">
          <source>Nothing happens if &lt;code&gt;d&lt;/code&gt; is smaller than 2.</source>
          <target state="translated">&lt;code&gt;d&lt;/code&gt; 가 2보다 작 으면 아무 일도 일어나지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="39fb7c03e6cb136de7fbdb71a619368064c85b64" translate="yes" xml:space="preserve">
          <source>Nothing happens if &lt;code&gt;max&lt;/code&gt; is smaller than 2.</source>
          <target state="translated">&lt;code&gt;max&lt;/code&gt; 이 2보다 작 으면 아무 일도 일어나지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="dc088a60c877ce62f962886fe65bf44f1be80800" translate="yes" xml:space="preserve">
          <source>Notice that it is not possible to pass options to ocamlrun when invoking a.out directly.</source>
          <target state="translated">a.out을 직접 호출 할 때 ocamlrun에 옵션을 전달할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="74aaf1392791cdacd5b251b350a4fa759d0daf50" translate="yes" xml:space="preserve">
          <source>Notice that our function call above prints &amp;ldquo;lazy_two evaluation&amp;rdquo; and then returns the plain value of the computation.</source>
          <target state="translated">위의 함수 호출은 &quot;lazy_two evaluation&quot;을 출력 한 다음 계산의 일반 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4c42130e4cbfad9b1ab31f04d64c0912792bf5e1" translate="yes" xml:space="preserve">
          <source>Notice that the bytecode libraries unix.cma and threads.cma must be given twice: when building the runtime system (so that ocamlc knows which C primitives are required) and also when building the bytecode executable (so that the bytecode from unix.cma and threads.cma is actually linked in).</source>
          <target state="translated">바이트 코드 라이브러리 unix.cma 및 threads.cma는 런타임 시스템을 빌드 할 때 (ocamlc가 어떤 C 프리미티브가 필요한지 알 수 있도록)와 바이트 코드 실행 파일을 빌드 할 때 (unix.cma 및 threads.cma는 실제로 링크되어 있습니다).</target>
        </trans-unit>
        <trans-unit id="6f0646640caf022897bba768e601eae5583de16c" translate="yes" xml:space="preserve">
          <source>Now for a real symbolic processing, we define the derivative of an expression with respect to a variable dv:</source>
          <target state="translated">이제 실제 기호 처리를 위해 변수 dv와 관련하여 표현식의 미분을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d31c772d9b3d93fe10a1d16923ec1381b4e0e40a" translate="yes" xml:space="preserve">
          <source>Now if we annotate the arguments and result with [@unboxed], the native-code compiler will be able to avoid all these allocations:</source>
          <target state="translated">이제 인수와 결과에 [@unboxed] 주석을 달면 네이티브 코드 컴파일러는 이러한 모든 할당을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c9da36ea65d19919b99ea34d11ca3b1c7c4a4a7" translate="yes" xml:space="preserve">
          <source>Now if we look at the value of lazy_two, we see that it is not displayed as &amp;lt;lazy&amp;gt; anymore but as lazy 2.</source>
          <target state="translated">이제 lazy_two의 값을 살펴보면 더 이상 &amp;lt;lazy&amp;gt;로 표시되지 않고 lazy 2로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e70cad05eff4f060c1122a9df879ce632eabd808" translate="yes" xml:space="preserve">
          <source>Now, here is a sample OCaml program prog.ml that uses the curses module:</source>
          <target state="translated">이제 curses 모듈을 사용하는 샘플 OCaml 프로그램 prog.ml이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb1a9455d741ea437460b8735fa1fd8568d51cbd" translate="yes" xml:space="preserve">
          <source>Now, we can use the two functions fib and format_result in any C program, just like regular C functions. Just remember to call caml_startup (or caml_startup_exn) once before.</source>
          <target state="translated">이제 일반 C 함수와 마찬가지로 모든 C 프로그램에서 fib 및 format_result 두 함수를 사용할 수 있습니다. 전에 한 번 caml_startup (또는 caml_startup_exn)을 호출하는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3138d7df51fb63c0581ea81498fd68c3e05c37c6" translate="yes" xml:space="preserve">
          <source>Number is 0.0 or -0.0</source>
          <target state="translated">숫자는 0.0 또는 -0.0입니다.</target>
        </trans-unit>
        <trans-unit id="599fcc81bb79a4df28a99bc27dc454bdb406e359" translate="yes" xml:space="preserve">
          <source>Number is positive or negative infinity</source>
          <target state="translated">숫자는 양수 또는 음수 무한대입니다.</target>
        </trans-unit>
        <trans-unit id="dd6a12894e1886f16551dce8aa6a476046e0e378" translate="yes" xml:space="preserve">
          <source>Number of bindings present in the table. Same value as returned by &lt;a href=&quot;hashtbl#VALlength&quot;&gt;&lt;code&gt;Hashtbl.length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">테이블에있는 바인딩 수입니다. &lt;a href=&quot;hashtbl#VALlength&quot;&gt; &lt;code&gt;Hashtbl.length&lt;/code&gt; 가&lt;/a&gt; 반환 한 것과 동일한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="6c993eaebae88d7a870c6aedb7b2959b80e3c4ac" translate="yes" xml:space="preserve">
          <source>Number of bits per character (5-8).</source>
          <target state="translated">문자 당 비트 수 (5-8).</target>
        </trans-unit>
        <trans-unit id="556c7d37711ec6f2f70fe3dcea838b8ca1371010" translate="yes" xml:space="preserve">
          <source>Number of blocks in the free list.</source>
          <target state="translated">사용 가능 목록의 블록 수입니다.</target>
        </trans-unit>
        <trans-unit id="b30e61fc6036da5db3f139d2340ea9277079b7a3" translate="yes" xml:space="preserve">
          <source>Number of buckets in the table.</source>
          <target state="translated">테이블의 버킷 수입니다.</target>
        </trans-unit>
        <trans-unit id="fd43d1f40b17a39ffbd688d74199162e00feb899" translate="yes" xml:space="preserve">
          <source>Number of contiguous pieces of memory that make up the major heap.</source>
          <target state="translated">주요 힙을 구성하는 연속적인 메모리 조각의 수입니다.</target>
        </trans-unit>
        <trans-unit id="22bfd01520799f6fb0b893646db43e4eff4024a4" translate="yes" xml:space="preserve">
          <source>Number of heap compactions since the program was started.</source>
          <target state="translated">프로그램이 시작된 이후의 힙 압축 수입니다.</target>
        </trans-unit>
        <trans-unit id="a3275a16ef5f550e3a9777e377a1e501bfdab390" translate="yes" xml:space="preserve">
          <source>Number of links</source>
          <target state="translated">링크 수</target>
        </trans-unit>
        <trans-unit id="ea1a2280ac441cab2cdb5c0495373425c8df6602" translate="yes" xml:space="preserve">
          <source>Number of live blocks in the major heap.</source>
          <target state="translated">주요 힙의 라이브 블록 수입니다.</target>
        </trans-unit>
        <trans-unit id="f456114fcb5877ccbceb91eb404b219b9ce44ade" translate="yes" xml:space="preserve">
          <source>Number of major collection cycles completed since the program was started.</source>
          <target state="translated">프로그램이 시작된 이후 완료된 주요 수집주기의 수입니다.</target>
        </trans-unit>
        <trans-unit id="9386df61202e08b36cb678baacc9b23f2a02d67b" translate="yes" xml:space="preserve">
          <source>Number of minor collections since the program was started.</source>
          <target state="translated">프로그램이 시작된 이후의 부 컬렉션 수입니다.</target>
        </trans-unit>
        <trans-unit id="809a46ad96dee431d9a0e29595d29eae99894471" translate="yes" xml:space="preserve">
          <source>Number of stop bits (1-2).</source>
          <target state="translated">정지 비트 수 (1-2).</target>
        </trans-unit>
        <trans-unit id="68d3ddb5d0c96281ae43ec9c22a0b4e3422e79bf" translate="yes" xml:space="preserve">
          <source>Number of wasted words due to fragmentation. These are 1-words free blocks placed between two live blocks. They are not available for allocation.</source>
          <target state="translated">조각화로 인해 낭비되는 단어 수입니다. 이들은 두 개의 라이브 블록 사이에 배치 된 1 워드 자유 블록입니다. 할당 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ce81b5c3bd146557576eb8ed07acd1dffea0dab3" translate="yes" xml:space="preserve">
          <source>Number of words allocated in the major heap, including the promoted words, since the program was started.</source>
          <target state="translated">프로그램이 시작된 이후 승격 된 단어를 포함하여 메이저 힙에 할당 된 단어 수입니다.</target>
        </trans-unit>
        <trans-unit id="d5ca08671f1b43ba25ac654a59ea877d2a2b67a5" translate="yes" xml:space="preserve">
          <source>Number of words allocated in the minor heap since the program was started.</source>
          <target state="translated">프로그램이 시작된 이후 부 힙에 할당 된 단어 수입니다.</target>
        </trans-unit>
        <trans-unit id="2252886aac21fa9ff4a9c573d75468a53aea2f8b" translate="yes" xml:space="preserve">
          <source>Number of words allocated in the minor heap since the program was started. This number is accurate in byte-code programs, but only an approximation in programs compiled to native code.</source>
          <target state="translated">프로그램이 시작된 이후 부 힙에 할당 된 단어 수입니다. 이 숫자는 바이트 코드 프로그램에서는 정확하지만 원시 코드로 컴파일 된 프로그램에서는 근사치 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="f7984519fd15afeac8c64ab5080cc953cb9c00a2" translate="yes" xml:space="preserve">
          <source>Number of words allocated in the minor heap that survived a minor collection and were moved to the major heap since the program was started.</source>
          <target state="translated">프로그램이 시작된 이후에 마이너 콜렉션에서 살아남고 메이저 힙으로 이동 된 마이너 힙에 할당 된 단어 수입니다.</target>
        </trans-unit>
        <trans-unit id="c8f31dc5c12c1a7f06ec7bd177c5b77d43639c8d" translate="yes" xml:space="preserve">
          <source>Number of words in the free list.</source>
          <target state="translated">무료 목록의 단어 수입니다.</target>
        </trans-unit>
        <trans-unit id="89158a98cc97e9ec991a351e0adf4b876875a73a" translate="yes" xml:space="preserve">
          <source>Number of words of live data in the major heap, including the header words.</source>
          <target state="translated">헤더 단어를 포함하여 주요 힙에있는 라이브 데이터의 단어 수입니다.</target>
        </trans-unit>
        <trans-unit id="4497ca18a980559e81799d511efa2fbf2cfc2a06" translate="yes" xml:space="preserve">
          <source>Number very close to 0.0, has reduced precision</source>
          <target state="translated">0.0에 매우 가까운 숫자, 정밀도가 떨어짐</target>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="7a33aed24260554ed4044e957096dba2b5814942" translate="yes" xml:space="preserve">
          <source>OCAMLLIB</source>
          <target state="translated">OCAMLLIB</target>
        </trans-unit>
        <trans-unit id="18f162a99ff8d53ff64a6b4e151cb31d5e551861" translate="yes" xml:space="preserve">
          <source>OCAMLPARAM (environment variable)</source>
          <target state="translated">OCAMLPARAM (환경 변수)</target>
        </trans-unit>
        <trans-unit id="63bde53850374ed2ceaca560296ca5ae4288cfc9" translate="yes" xml:space="preserve">
          <source>OCAMLRUNPARAM</source>
          <target state="translated">OCAMLRUNPARAM</target>
        </trans-unit>
        <trans-unit id="5a645a796dc3a615a92ec7a9d69a83018587cfd3" translate="yes" xml:space="preserve">
          <source>OCAMLTOP_INCLUDE_PATH</source>
          <target state="translated">OCAMLTOP_INCLUDE_PATH</target>
        </trans-unit>
        <trans-unit id="8d2f44eaaa8da1e94f7c788d8bdd29ded4da06e4" translate="yes" xml:space="preserve">
          <source>OCAMLTOP_UTF_8</source>
          <target state="translated">OCAMLTOP_UTF_8</target>
        </trans-unit>
        <trans-unit id="ad1263844890ea6d4fa757c36f64dd4aa02ae452" translate="yes" xml:space="preserve">
          <source>OCAML_EVENTLOG_ENABLED can be set to the p flag in order to start the program with event collection paused.</source>
          <target state="translated">OCAML_EVENTLOG_ENABLED는 이벤트 수집이 일시 중지 된 상태에서 프로그램을 시작하기 위해 p 플래그로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5452f25317c588b2d021a1ead667fb17370d1d55" translate="yes" xml:space="preserve">
          <source>OCAML_FLEXLINK</source>
          <target state="translated">OCAML_FLEXLINK</target>
        </trans-unit>
        <trans-unit id="180089a275079837ea5e6f4afd0b87d27e4469c6" translate="yes" xml:space="preserve">
          <source>OCAML_FLEXLINK (environment variable)</source>
          <target state="translated">OCAML_FLEXLINK (환경 변수)</target>
        </trans-unit>
        <trans-unit id="0cdddb7074ce2b9a9f470e52afd10a9b95816171" translate="yes" xml:space="preserve">
          <source>OCaml allows us to defer some computation until later when we need the result of that computation.</source>
          <target state="translated">OCaml을 사용하면 계산 결과가 필요할 때까지 계산을 연기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40aa7560087d20b8f8199f53d34735d850d308b1" translate="yes" xml:space="preserve">
          <source>OCaml code executing in the traditional toplevel system uses the bytecode interpreter. When increased performance is required, or for testing programs that will only execute correctly when compiled to native code, the &lt;em&gt;native toplevel&lt;/em&gt; may be used instead.</source>
          <target state="translated">전통적인 최상위 시스템에서 실행되는 OCaml 코드는 바이트 코드 인터프리터를 사용합니다. 성능 향상이 필요하거나 네이티브 코드로 컴파일 될 때만 올바르게 실행되는 프로그램을 테스트하기 위해 &lt;em&gt;네이티브 최상위 수준을&lt;/em&gt; 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="267c01d6c4260bac5e8f28a01de2593eca32db2c" translate="yes" xml:space="preserve">
          <source>OCaml has no built-in notion of variable &amp;ndash; identifiers whose current value can be changed by assignment. (The let binding is not an assignment, it introduces a new identifier with a new scope.) However, the standard library provides references, which are mutable indirection cells, with operators ! to fetch the current contents of the reference and := to assign the contents. Variables can then be emulated by let-binding a reference. For instance, here is an in-place insertion sort over arrays:</source>
          <target state="translated">OCaml에는 기본 제공 변수 개념이 없습니다. 할당에 의해 현재 값이 변경 될 수있는 식별자입니다. (let 바인딩은 할당이 아니며 새 범위의 새 식별자를 도입합니다.) 그러나 표준 라이브러리는 연산자!와 함께 변경 가능한 간접 셀인 참조를 제공합니다. 참조의 현재 내용을 가져오고 : = 내용을 할당합니다. 그런 다음 참조를 let-binding하여 변수를 에뮬레이션 할 수 있습니다. 예를 들어 다음은 배열에 대한 내부 삽입 정렬입니다.</target>
        </trans-unit>
        <trans-unit id="5cb3adc8841417401cbe5cbf1dccabafc62d9c42" translate="yes" xml:space="preserve">
          <source>OCaml integers (signed, 31 bits on 32-bit architectures, 63 bits on 64-bit architectures) (&lt;a href=&quot;bigarray#TYPEint_elt&quot;&gt;&lt;code&gt;Bigarray.int_elt&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">OCaml 정수 (부호 있음, 32 비트 아키텍처에서 31 비트, 64 비트 아키텍처에서 63 비트) ( &lt;a href=&quot;bigarray#TYPEint_elt&quot;&gt; &lt;code&gt;Bigarray.int_elt&lt;/code&gt; &lt;/a&gt; ),</target>
        </trans-unit>
        <trans-unit id="64a9ccb34887b4bee6ea9726429d33718de72371" translate="yes" xml:space="preserve">
          <source>OCaml is a functional language: functions in the full mathematical sense are supported and can be passed around freely just as any other piece of data. For instance, here is a deriv function that takes any float function as argument and returns an approximation of its derivative function:</source>
          <target state="translated">OCaml은 기능적 언어입니다. 완전한 수학적 의미의 함수가 지원되며 다른 데이터와 마찬가지로 자유롭게 전달할 수 있습니다. 예를 들어, 다음은 float 함수를 인수로 취하고 파생 함수의 근사값을 반환하는 파생 함수입니다.</target>
        </trans-unit>
        <trans-unit id="3ef8c1d2377beafebd9185056587e4432d10a17d" translate="yes" xml:space="preserve">
          <source>OCaml provides exceptions for signalling and handling exceptional conditions. Exceptions can also be used as a general-purpose non-local control structure, although this should not be overused since it can make the code harder to understand. Exceptions are declared with the exception construct, and signalled with the raise operator. For instance, the function below for taking the head of a list uses an exception to signal the case where an empty list is given.</source>
          <target state="translated">OCaml은 예외적 인 조건을 신호하고 처리하기위한 예외를 제공합니다. 예외는 범용 비 로컬 제어 구조로도 사용될 수 있지만 코드를 이해하기 어렵게 만들 수 있기 때문에 과도하게 사용해서는 안됩니다. 예외는 예외 구조로 선언되고 raise 연산자로 신호를받습니다. 예를 들어, 목록의 선두를 차지하는 아래 함수는 예외를 사용하여 빈 목록이 제공된 경우를 알립니다.</target>
        </trans-unit>
        <trans-unit id="5bb9dff10bdb65bfb239e824ad6d8af0b7cc9004" translate="yes" xml:space="preserve">
          <source>OCaml runs on several operating systems. The parts of this manual that are specific to one operating system are presented as shown below:</source>
          <target state="translated">OCaml은 여러 운영 체제에서 실행됩니다. 이 설명서의 특정 운영 체제에 해당하는 부분은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1726ed3129ec43182a952dcd0e32f27c1495a2bf" translate="yes" xml:space="preserve">
          <source>OCaml source files and object files (.cmo, .cmx, .ml) comprising the OCaml part of the library;</source>
          <target state="translated">라이브러리의 OCaml 부분을 구성하는 OCaml 소스 파일 및 개체 파일 (.cmo, .cmx, .ml)</target>
        </trans-unit>
        <trans-unit id="f9b33a87ea85672b2f3dc3cc175ebdefe40c9d34" translate="yes" xml:space="preserve">
          <source>OCaml supports the assert construct to check debugging assertions. The expression assert&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; and returns () if &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; evaluates to true. If it evaluates to false the exception Assert_failure is raised with the source file name and the location of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; as arguments. Assertion checking can be turned off with the -noassert compiler option. In this case, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is not evaluated at all.</source>
          <target state="translated">OCaml은 디버깅 주장을 확인하기 위해 assert 구조를 지원합니다. assert &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 표현식은 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 표현식을 평가하고 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 이 true로 평가 되면 ()를 반환 합니다. false로 평가되면 소스 파일 이름과 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 의 위치 를 인수로 사용하여 Assert_failure 예외가 발생합니다 . -noassert 컴파일러 옵션을 사용하여 어설 션 검사를 끌 수 있습니다. 이 경우 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 은 전혀 평가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c85e2232603a9909d0b7ff1b3926fe7e6d893e4" translate="yes" xml:space="preserve">
          <source>OCaml type</source>
          <target state="translated">OCaml 유형</target>
        </trans-unit>
        <trans-unit id="62d72b1edf8e07e587e3d50ac25c27ae51c1a8cd" translate="yes" xml:space="preserve">
          <source>OCaml's floating-point numbers follow the IEEE 754 standard, using double precision (64 bits) numbers. Floating-point operations never raise an exception on overflow, underflow, division by zero, etc. Instead, special IEEE numbers are returned as appropriate, such as &lt;code&gt;infinity&lt;/code&gt; for &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;, &lt;code&gt;neg_infinity&lt;/code&gt; for &lt;code&gt;-1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;, and &lt;code&gt;nan&lt;/code&gt; ('not a number') for &lt;code&gt;0.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt;. These special numbers then propagate through floating-point computations as expected: for instance, &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;infinity&lt;/code&gt; is &lt;code&gt;0.0&lt;/code&gt;, and any arithmetic operation with &lt;code&gt;nan&lt;/code&gt; as argument returns &lt;code&gt;nan&lt;/code&gt; as result.</source>
          <target state="translated">OCaml의 부동 소수점 숫자는 배정 밀도 (64 비트) 숫자를 사용하여 IEEE 754 표준을 따릅니다. 부동 소수점 연산과 같은, 대신 특별한 IEEE 번호가 적절하게 반환 등 0으로 오버플로, 언더 플로 부문에 예외를 발생하지 &lt;code&gt;infinity&lt;/code&gt; 에 대한 &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt; , &lt;code&gt;-1.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt; 대한 &lt;code&gt;neg_infinity&lt;/code&gt; . 0.0 및 &lt;code&gt;0.0&amp;nbsp;/.&amp;nbsp;0.0&lt;/code&gt; &lt;code&gt;nan&lt;/code&gt; ( '숫자가 아님') . 0.0 . 이러한 특수 숫자는 예상대로 부동 소수점 계산을 통해 전파됩니다 (예 : &lt;code&gt;1.0&amp;nbsp;/.&amp;nbsp;infinity&lt;/code&gt; 는 &lt;code&gt;0.0&lt;/code&gt; 이고 &lt;code&gt;nan&lt;/code&gt; 을 인수로 사용하는 산술 연산 은 결과 로 &lt;code&gt;nan&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bd9ec7fcee833e36e4b14ae69e1e560823d2194a" translate="yes" xml:space="preserve">
          <source>OCamldoc calls the OCaml type-checker to obtain type information. The following options impact the type-checking phase. They have the same meaning as for the ocamlc and ocamlopt commands.</source>
          <target state="translated">OCamldoc은 OCaml 유형 검사기를 호출하여 유형 정보를 얻습니다. 다음 옵션은 유형 검사 단계에 영향을줍니다. ocamlc 및 ocamlopt 명령과 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="e9fd7b104be92b2bbccb12043665773616dd39a8" translate="yes" xml:space="preserve">
          <source>OCamldoc can associate comments to some elements of the language encountered in the source files. The association is made according to the locations of comments with respect to the language elements. The locations of comments in .mli and .ml files are different.</source>
          <target state="translated">OCamldoc은 소스 파일에서 발견 된 언어의 일부 요소에 주석을 연결할 수 있습니다. 연결은 언어 요소와 관련된 주석 위치에 따라 만들어집니다. .mli 및 .ml 파일의 주석 위치가 다릅니다.</target>
        </trans-unit>
        <trans-unit id="faec01ad8468873527336baad11c51145d082115" translate="yes" xml:space="preserve">
          <source>OCamldoc can produce documentation in various formats: HTML, L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X, TeXinfo, Unix man pages, and dot dependency graphs. Moreover, users can add their own custom generators, as explained in section &lt;a href=&quot;#s%3Aocamldoc-custom-generators&quot;&gt;16.3&lt;/a&gt;.</source>
          <target state="translated">HTML, L : OCamldoc는 다양한 형식으로 문서를 생성 할 수 있습니다 T &lt;sub&gt;E&lt;/sub&gt; X,는 TeXinfo, 유닉스 매뉴얼 페이지를, 의존성 그래프를 점. 또한 사용자는 섹션 &lt;a href=&quot;#s%3Aocamldoc-custom-generators&quot;&gt;16.3에&lt;/a&gt; 설명 된대로 고유 한 사용자 지정 생성기를 추가 할 수 있습니다 .&lt;sup&gt;&lt;/sup&gt;&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="4a97a33abb490cfa006083e0758a66c65ccefd2d" translate="yes" xml:space="preserve">
          <source>OCamldoc is invoked via the command ocamldoc, as follows:</source>
          <target state="translated">OCamldoc은 다음과 같이 ocamldoc 명령을 통해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4a9e742b8c79265cdf1d7a881feb63c658daf697" translate="yes" xml:space="preserve">
          <source>OCamldoc operates in two steps:</source>
          <target state="translated">OCamldoc은 두 단계로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="62d31081ef8855113f2a0517703c8269e167e955" translate="yes" xml:space="preserve">
          <source>OPAM switches will be provided for Spacetime-configured compilers.</source>
          <target state="translated">OPAM 스위치는 Spacetime 구성 컴파일러에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="cdb8f90af03d5b6035972034e7db2381c61fb84c" translate="yes" xml:space="preserve">
          <source>Obj</source>
          <target state="translated">Obj</target>
        </trans-unit>
        <trans-unit id="72a83add2c5ede877c10d23f302d3e17accbadab" translate="yes" xml:space="preserve">
          <source>Objects</source>
          <target state="translated">Objects</target>
        </trans-unit>
        <trans-unit id="7a7417369b52b8eb7878a369c0569d594dbf4af1" translate="yes" xml:space="preserve">
          <source>Objects are composed of a hidden internal state which is a record of instance variables, and a set of methods for accessing and modifying these variables. The structure of an object is described by the toplevel class that created it.</source>
          <target state="translated">객체는 인스턴스 변수의 기록 인 숨겨진 내부 상태와 이러한 변수에 액세스하고 수정하기위한 일련의 메소드로 구성됩니다. 객체의 구조는 객체를 생성 한 최상위 클래스에 의해 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="7d201edcc8c7a34735ba42eb0dde4de7ae96dbd1" translate="yes" xml:space="preserve">
          <source>Objects are represented as blocks with tag Object_tag. The first field of the block refers to the object&amp;rsquo;s class and associated method suite, in a format that cannot easily be exploited from C. The second field contains a unique object ID, used for comparisons. The remaining fields of the object contain the values of the instance variables of the object. It is unsafe to access directly instance variables, as the type system provides no guarantee about the instance variables contained by an object.</source>
          <target state="translated">객체는 Object_tag 태그가있는 블록으로 표시됩니다. 블록의 첫 번째 필드는 C에서 쉽게 악용 할 수없는 형식으로 개체의 클래스 및 관련 메서드 모음을 참조합니다. 두 번째 필드에는 비교에 사용되는 고유 한 개체 ID가 포함되어 있습니다. 개체의 나머지 필드에는 개체의 인스턴스 변수 값이 포함됩니다. 유형 시스템이 객체에 포함 된 인스턴스 변수에 대한 보장을 제공하지 않기 때문에 인스턴스 변수에 직접 액세스하는 것은 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4792dc04542c4957b7299aef2bdc36a1978fd6e" translate="yes" xml:space="preserve">
          <source>Objects can also be cloned, whether they are functional or imperative. The library function Oo.copy makes a shallow copy of an object. That is, it returns a new object that has the same methods and instance variables as its argument. The instance variables are copied but their contents are shared. Assigning a new value to an instance variable of the copy (using a method call) will not affect instance variables of the original, and conversely. A deeper assignment (for example if the instance variable is a reference cell) will of course affect both the original and the copy.</source>
          <target state="translated">기능적이든 필수이든 개체를 복제 할 수도 있습니다. 라이브러리 함수 Oo.copy는 객체의 얕은 복사본을 만듭니다. 즉, 인수와 동일한 메서드 및 인스턴스 변수를 가진 새 개체를 반환합니다. 인스턴스 변수는 복사되지만 그 내용은 공유됩니다. 메서드 호출을 사용하여 복사본의 인스턴스 변수에 새 값을 할당해도 원본의 인스턴스 변수에는 영향을주지 않으며 그 반대도 마찬가지입니다. 더 깊은 할당 (예 : 인스턴스 변수가 참조 셀인 경우)은 물론 원본과 사본 모두에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="f6212b229fd84e14b8e1bd78d95275e70aab5b8c" translate="yes" xml:space="preserve">
          <source>Objects can be compared using the generic comparison functions = and &amp;lt;&amp;gt;. Two objects are equal if and only if they are physically equal. In particular, an object and its copy are not equal.</source>
          <target state="translated">일반 비교 함수 = 및 &amp;lt;&amp;gt;를 사용하여 개체를 비교할 수 있습니다. 두 개체는 물리적으로 동일한 경우에만 동일합니다. 특히, 객체와 그 사본은 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70e562beb45bc84c915a01804d2101ba51908f44" translate="yes" xml:space="preserve">
          <source>Ocaml_operators</source>
          <target state="translated">Ocaml_operators</target>
        </trans-unit>
        <trans-unit id="ee3ae917b76500c4d6f5198aee13dfba5343c14b" translate="yes" xml:space="preserve">
          <source>Of course the constraint may also be an explicit method type. Only occurrences of quantified variables are required.</source>
          <target state="translated">물론 제약 조건은 명시적인 메서드 유형일 수도 있습니다. 수량화 된 변수의 발생 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="390a64456209ce68498258cb6922119e7dbf8e07" translate="yes" xml:space="preserve">
          <source>Of course, not all abstract types can be refined, as this would contradict the exhaustiveness check. Namely, builtin types (those defined by the compiler itself, such as int or array), and abstract types defined by the local module, are non-instantiable, and as such cause a type error rather than introduce an equation.</source>
          <target state="translated">물론 모든 추상 유형을 다듬을 수있는 것은 아닙니다. 이것이 완전성 검사와 모순되기 때문입니다. 즉, 내장 유형 (int 또는 배열과 같이 컴파일러 자체에 의해 정의 된 유형) 및 로컬 모듈에 의해 정의 된 추상 유형은 인스턴스화 할 수 없으므로 방정식을 도입하는 대신 유형 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="fcd38f73712f3f921494c6d0ba6b9d46d4b7cbdf" translate="yes" xml:space="preserve">
          <source>Of course, private methods can also be virtual. Then, the keywords must appear in this order method private virtual.</source>
          <target state="translated">물론 개인 메서드는 가상 일 수도 있습니다. 그런 다음 키워드는이 순서 방법 private virtual로 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="61f10114972b3e32658bfd9f3e9aeeb732ce426d" translate="yes" xml:space="preserve">
          <source>Of course, this applies to all sorts of accounts.</source>
          <target state="translated">물론 이것은 모든 종류의 계정에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ce8d8c0b88abbfc440d3dc4b57a2cf0a75a3a5f" translate="yes" xml:space="preserve">
          <source>Of course, you will always encounter this error if you have mutually recursive functions across modules. That is, function Mod1.f calls function Mod2.g, and function Mod2.g calls function Mod1.f. In this case, no matter what permutations you perform on the command line, the program will be rejected at link-time. Fixes:</source>
          <target state="translated">물론 모듈간에 상호 재귀 함수가있는 경우 항상이 오류가 발생합니다. 즉, Mod1.f 함수는 Mod2.g 함수를 호출하고 Mod2.g 함수는 Mod1.f 함수를 호출합니다. 이 경우 명령 줄에서 수행하는 순열에 관계없이 프로그램은 링크 타임에 거부됩니다. 수정 사항 :</target>
        </trans-unit>
        <trans-unit id="3abc8fb824d1ca26c79cf75a199925a3994ef82b" translate="yes" xml:space="preserve">
          <source>On ARM and PowerPC processors (32 and 64 bits), fused multiply-add (FMA) instructions can be generated for a floating-point multiplication followed by a floating-point addition or subtraction, as in x *. y +. z. The FMA instruction avoids rounding the intermediate result x *. y, which is generally beneficial, but produces floating-point results that differ slightly from those produced by the bytecode interpreter.</source>
          <target state="translated">ARM 및 PowerPC 프로세서 (32 비트 및 64 비트)에서 x *에서와 같이 부동 소수점 곱셈에 이어 부동 소수점 더하기 또는 빼기에 대해 FMA (퓨즈 드 곱하기 더하기) 명령어를 생성 할 수 있습니다. y +. 지. FMA 명령어는 중간 결과 x *를 반올림하지 않습니다. y는 일반적으로 유용하지만 바이트 코드 인터프리터에서 생성 한 것과 약간 다른 부동 소수점 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7e4743b988a9d2c98b0f15c07522d89801266295" translate="yes" xml:space="preserve">
          <source>On IA32 processors only (Intel and AMD x86 processors in 32-bit mode), some intermediate results in floating-point computations are kept in extended precision rather than being rounded to double precision like the bytecode compiler always does. Floating-point results can therefore differ slightly between bytecode and native code.</source>
          <target state="translated">IA32 프로세서에서만 (32 비트 모드의 Intel 및 AMD x86 프로세서) 부동 소수점 계산의 일부 중간 결과는 바이트 코드 컴파일러가 항상 수행하는 것처럼 배정 밀도로 반올림되지 않고 확장 된 정밀도로 유지됩니다. 따라서 부동 소수점 결과는 바이트 코드와 네이티브 코드간에 약간 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dbf10944f284d7a264460f6a902cd99abf3e37d" translate="yes" xml:space="preserve">
          <source>On Windows, it is not implemented. Use threads.</source>
          <target state="translated">Windows에서는 구현되지 않습니다. 스레드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dade53b6a22945b59c406518b5b7ced4711e03de" translate="yes" xml:space="preserve">
          <source>On Windows, not implemented.</source>
          <target state="translated">Windows에서는 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8906e1dc157f50b42f72e0cd4030336afb142f2b" translate="yes" xml:space="preserve">
          <source>On Windows, this function can only wait for a given PID, not any child process.</source>
          <target state="translated">Windows에서이 함수는 자식 프로세스가 아닌 지정된 PID 만 기다릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8acef991e8908183d9940b463de2698612bbf4fe" translate="yes" xml:space="preserve">
          <source>On Windows: Not implemented, use &lt;a href=&quot;unix#VALwaitpid&quot;&gt;&lt;code&gt;Unix.waitpid&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows : 구현되지 않은 경우 &lt;a href=&quot;unix#VALwaitpid&quot;&gt; &lt;code&gt;Unix.waitpid&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b247888acfd86ad89effa228bc273bc912c169cc" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented (no inter-process signals on Windows).</source>
          <target state="translated">Windows : 구현되지 않음 (Windows에서 프로세스 간 신호 없음).</target>
        </trans-unit>
        <trans-unit id="5b7ecaf2e67d2e221d004d06c969e40c1f3fa6b9" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented, use &lt;a href=&quot;unix#VALcreate_process&quot;&gt;&lt;code&gt;Unix.create_process&lt;/code&gt;&lt;/a&gt; or threads.</source>
          <target state="translated">Windows : 구현되지 않은 경우 &lt;a href=&quot;unix#VALcreate_process&quot;&gt; &lt;code&gt;Unix.create_process&lt;/code&gt; &lt;/a&gt; 또는 스레드를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="275242bb70c12d899890264c377bf0698c3fd50b" translate="yes" xml:space="preserve">
          <source>On Windows: not implemented.</source>
          <target state="translated">Windows : 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="29d73771d5997e1e56b96cce84c556b6aa2f143d" translate="yes" xml:space="preserve">
          <source>On each case of a pattern-matching definition (function, match&amp;hellip;with construct, try&amp;hellip;with construct):</source>
          <target state="translated">패턴 일치 정의의 각 경우 (함수, 일치&amp;hellip; 구성과 일치, 시도&amp;hellip; 구성과) :</target>
        </trans-unit>
        <trans-unit id="8e88170bb615e04bffb73dc9ab941d16c68ec80f" translate="yes" xml:space="preserve">
          <source>On entrance to a function:</source>
          <target state="translated">기능 시작시 :</target>
        </trans-unit>
        <trans-unit id="e06905e7e7cd277c45d37ec140ed32c4c8da539c" translate="yes" xml:space="preserve">
          <source>On most systems, the file produced by the linking phase can be run directly, as in:</source>
          <target state="translated">대부분의 시스템에서 연결 단계에서 생성 된 파일은 다음과 같이 직접 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f81f9f71a735722a72705b16087220b85ed634fb" translate="yes" xml:space="preserve">
          <source>On native Windows, the following environment variable is also consulted:</source>
          <target state="translated">기본 Windows에서는 다음 환경 변수도 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="8007c691da700e3ae4175b6d76c73c8fb4dfce47" translate="yes" xml:space="preserve">
          <source>On one example that was known to be bad for next-fit and first-fit, next-fit takes 28s using 855Mio of memory, first-fit takes 47s using 566Mio of memory, best-fit takes 27s using 545Mio of memory.</source>
          <target state="translated">next-fit 및 first-fit에 좋지 않은 것으로 알려진 한 예에서 next-fit은 855Mio의 메모리를 사용하여 28 초, first-fit는 566Mio의 메모리를 사용하여 47 초, best-fit는 545Mio의 메모리를 사용하여 27 초가 걸립니다.</target>
        </trans-unit>
        <trans-unit id="be6baf20c0bc95c4d024106e11bc89c9ce694fe9" translate="yes" xml:space="preserve">
          <source>On platforms that support dynamic loading, ocamlrun can link dynamically with C shared libraries (DLLs) providing additional C primitives beyond those provided by the standard runtime system. The names for these libraries are provided at link time as described in section &lt;a href=&quot;intfc#ss%3Adynlink-c-code&quot;&gt;20.1.4&lt;/a&gt;), and recorded in the bytecode executable file; ocamlrun, then, locates these libraries and resolves references to their primitives when the bytecode executable program starts.</source>
          <target state="translated">동적 로딩을 지원하는 플랫폼에서 ocamlrun은 표준 런타임 시스템에서 제공하는 것 이상의 추가 C 프리미티브를 제공하는 C 공유 라이브러리 (DLL)와 동적으로 링크 할 수 있습니다. 이러한 라이브러리의 이름은 섹션 &lt;a href=&quot;intfc#ss%3Adynlink-c-code&quot;&gt;20.1.4에&lt;/a&gt; 설명 된대로 링크 타임에 제공되며 바이트 코드 실행 파일에 기록됩니다. 그런 다음 ocamlrun은 이러한 라이브러리를 찾고 바이트 코드 실행 프로그램이 시작될 때 해당 기본 요소에 대한 참조를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="2f23214a8cc0b25426327d7520ebefaf7e3dc98b" translate="yes" xml:space="preserve">
          <source>On some ports, special options are required on the final linking phase that links together the object file produced by the -output-obj option and the remainder of the program. Those options are shown in the configuration file Makefile.config generated during compilation of OCaml, as the variable OC_LDFLAGS.</source>
          <target state="translated">일부 포트에서는 -output-obj 옵션과 나머지 프로그램에 의해 생성 된 개체 파일을 함께 연결하는 최종 연결 단계에서 특수 옵션이 필요합니다. 이러한 옵션은 OCaml 컴파일 중에 생성 된 구성 파일 Makefile.config에 OC_LDFLAGS 변수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cd1d4e4f1b5f80e398835cf87ca32c2f6861e659" translate="yes" xml:space="preserve">
          <source>On start-up (before the first phrase is read), if the file .ocamlinit exists in the current directory, its contents are read as a sequence of OCaml phrases and executed as per the #use directive described in section &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2&lt;/a&gt;. The evaluation outcode for each phrase are not displayed. If the current directory does not contain an .ocamlinit file, the file XDG_CONFIG_HOME/ocaml/init.ml is looked up according to the XDG base directory specification and used instead (on Windows this is skipped). If that file doesn&amp;rsquo;t exist then an [.ocamlinit] file in the users&amp;rsquo; home directory (determined via environment variable HOME) is used if existing.</source>
          <target state="translated">시작할 때 (첫 번째 구문을 읽기 전), .ocamlinit 파일이 현재 디렉토리에 있으면 그 내용을 OCaml 구문의 시퀀스로 읽고 섹션 &lt;a href=&quot;#s%3Atoplevel-directives&quot;&gt;10.2에&lt;/a&gt; 설명 된 #use 지시문에 따라 실행 합니다. 각 구문에 대한 평가 아웃 코드는 표시되지 않습니다. 현재 디렉토리에 .ocamlinit 파일이 포함되어 있지 않으면 XDG_CONFIG_HOME / ocaml / init.ml 파일이 XDG 기본 디렉토리 사양에 따라 조회되고 대신 사용됩니다 (Windows에서는 생략 됨). 해당 파일이 없으면 사용자의 홈 디렉토리에있는 [.ocamlinit] 파일 (환경 변수 HOME을 통해 결정됨)이 존재하는 경우 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="06b84befbd60a3041accf5742277784b546af6a5" translate="yes" xml:space="preserve">
          <source>On start-up, the debugger will read commands from an initialization file before giving control to the user. The default file is .ocamldebug in the current directory if it exists, otherwise .ocamldebug in the user&amp;rsquo;s home directory.</source>
          <target state="translated">시작시 디버거는 사용자에게 제어 권한을 부여하기 전에 초기화 파일에서 명령을 읽습니다. 기본 파일은 현재 디렉토리에있는 경우 .ocamldebug이고, 그렇지 않으면 사용자의 홈 디렉토리에있는 .ocamldebug입니다.</target>
        </trans-unit>
        <trans-unit id="4cd11bf07751e14f362666e5c1bd69ee93954cd1" translate="yes" xml:space="preserve">
          <source>On the C side, a pointer to the value registered under name n is obtained by calling caml_named_value(n). The returned pointer must then be dereferenced to recover the actual OCaml value. If no value is registered under the name n, the null pointer is returned. For example, here is a C wrapper that calls the OCaml function f above:</source>
          <target state="translated">C 측에서는 caml_named_value (n)을 호출하여 이름 n으로 등록 된 값에 대한 포인터를 얻습니다. 반환 된 포인터는 실제 OCaml 값을 복구하기 위해 역 참조되어야합니다. n 이름으로 등록 된 값이 없으면 널 포인터가 리턴됩니다. 예를 들어, 다음은 위의 OCaml 함수 f를 호출하는 C 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="064af06a1d91392c727df0b16b39810d1213c9db" translate="yes" xml:space="preserve">
          <source>On the OCaml side, registration is performed by evaluating Callback.registern v. Here, n is the global name (an arbitrary string) and v the OCaml value. For instance:</source>
          <target state="translated">OCaml 측에서는 Callback.registern v를 평가하여 등록을 수행합니다. 여기서 n은 전역 이름 (임의의 문자열)이고 v는 OCaml 값입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="5de3701f349d27c7db926bd7951f46017d144e8d" translate="yes" xml:space="preserve">
          <source>On the debugged program side, the socket name is passed through the CAML_DEBUG_SOCKET environment variable.</source>
          <target state="translated">디버깅 된 프로그램 측에서 소켓 이름은 CAML_DEBUG_SOCKET 환경 변수를 통해 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8c3a47d696ce0714f9f1c41b24081abcae43afd6" translate="yes" xml:space="preserve">
          <source>On the other hand, a class for polymorphic references must explicitly list the type parameters in its declaration. Class type parameters are listed between [ and ]. The type parameters must also be bound somewhere in the class body by a type constraint.</source>
          <target state="translated">반면에 다형성 참조를위한 클래스는 선언에 형식 매개 변수를 명시 적으로 나열해야합니다. 클래스 유형 매개 변수는 [와] 사이에 나열됩니다. 형식 매개 변수는 형식 제약 조건에 의해 클래스 본문의 어딘가에 바인딩되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fde94d852235534ebe9a07117621ba74b29f99ae" translate="yes" xml:space="preserve">
          <source>Once a runtime is unloaded, it cannot be started up again without reloading the shared library and reinitializing its static data. Therefore, at the moment, the facility is only useful for building reloadable shared libraries.</source>
          <target state="translated">런타임이 언로드되면 공유 라이브러리를 다시로드하고 정적 데이터를 다시 초기화하지 않고는 다시 시작할 수 없습니다. 따라서 현재이 기능은 다시로드 할 수있는 공유 라이브러리를 빌드하는 데만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="91fcb0d46bf0fa0b289db31330eb16f274c3b00f" translate="yes" xml:space="preserve">
          <source>Once compiled and linked with the instrumented runtime, any OCaml program can generate &lt;em&gt;trace files&lt;/em&gt; that can then be read and analyzed by users in order to understand specific runtime behaviors.</source>
          <target state="translated">인스트루먼트 된 런타임으로 컴파일되고 연결되면 모든 OCaml 프로그램은 특정 런타임 동작을 이해하기 위해 사용자가 읽고 분석 할 수있는 &lt;em&gt;추적 파일&lt;/em&gt; 을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1d1a0a00f7b028b377134ebb6383b1db4d55c3d" translate="yes" xml:space="preserve">
          <source>Once the appropriate compiler has been selected the program should be built as normal (ensuring that all files are built with the Spacetime compiler&amp;mdash;there is currently no protection to ensure this is the case, but it is essential). For many uses it will not be necessary to change the code of the program to use the profiler.</source>
          <target state="translated">적절한 컴파일러가 선택되면 프로그램을 정상적으로 빌드해야합니다 (모든 파일이 Spacetime 컴파일러로 빌드되었는지 확인합니다. 현재이를 보장 할 수있는 보호 조치는 없지만 필수입니다). 대부분의 경우 프로파일 러를 사용하기 위해 프로그램 코드를 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="40c6b2bb41ee454dbfaccf9b93d05b18a714000d" translate="yes" xml:space="preserve">
          <source>One can also use this to completely remove a field:</source>
          <target state="translated">이를 사용하여 필드를 완전히 제거 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0de9b9cc70a42dc4f700bcc1de9462f06fdcb0c2" translate="yes" xml:space="preserve">
          <source>One can write</source>
          <target state="translated">하나 쓸 수 있습니다</target>
        </trans-unit>
        <trans-unit id="e15e35f605f634d4dc006143de05c9a72bf8ebe2" translate="yes" xml:space="preserve">
          <source>One could think of defining the type abbreviation directly:</source>
          <target state="translated">유형 약어를 직접 정의하는 것을 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75c4aedb3397880f828378b13f6f7ae32fd18ccd" translate="yes" xml:space="preserve">
          <source>One could think that a private method should remain private in a subclass. However, since the method is visible in a subclass, it is always possible to pick its code and define a method of the same name that runs that code, so yet another (heavier) solution would be:</source>
          <target state="translated">개인 메서드는 하위 클래스에서 개인용으로 유지되어야한다고 생각할 수 있습니다. 그러나 메서드가 하위 클래스에 표시되기 때문에 항상 해당 코드를 선택하고 해당 코드를 실행하는 동일한 이름의 메서드를 정의 할 수 있으므로 또 다른 (무거운) 솔루션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="99f1bbfebca36b804f1d02940b9fe648bbeb9dc0" translate="yes" xml:space="preserve">
          <source>One important restriction is that types introduced by openstruct ... end cannot appear in the signature of the enclosing structure, unless they are defined equal to some non-local type. So:</source>
          <target state="translated">한 가지 중요한 제한 사항은 openstruct ... end에 의해 도입 된 유형이 일부 비 로컬 유형과 동일하게 정의되지 않는 한 둘러싸는 구조의 시그니처에 나타날 수 없다는 것입니다. 그래서:</target>
        </trans-unit>
        <trans-unit id="dae76e80271c4a94dd62fcba165e22dd596cb51b" translate="yes" xml:space="preserve">
          <source>One may extract a public method from an object using the C function caml_get_public_method (declared in &amp;lt;caml/mlvalues.h&amp;gt;.) Since public method tags are hashed in the same way as variant tags, and methods are functions taking self as first argument, if you want to do the method call foo#bar from the C side, you should call:</source>
          <target state="translated">C 함수 caml_get_public_method (&amp;lt;caml / mlvalues.h&amp;gt;에 선언 됨)를 사용하여 객체에서 공용 메서드를 추출 할 수 있습니다. 공용 메서드 태그는 변형 태그와 동일한 방식으로 해시되고 메서드는 self를 첫 번째 인수로 취하는 함수이므로, C 쪽에서 foo # bar 메서드를 호출하려면 다음을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="e8c0b5251da945468988a280889faaa02e2f8010" translate="yes" xml:space="preserve">
          <source>One may wish to open an account and simultaneously deposit some initial amount. Although the initial implementation did not address this requirement, it can be achieved by using an initializer.</source>
          <target state="translated">계좌를 개설하고 동시에 초기 금액을 입금 할 수 있습니다. 초기 구현에서는이 요구 사항을 해결하지 못했지만 이니셜 라이저를 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac45b2b8f5570a34d56bdec8e442987bb58c7b07" translate="yes" xml:space="preserve">
          <source>One may wonder whether it is possible to treat primitive types such as integers and strings as objects. Although this is usually uninteresting for integers or strings, there may be some situations where this is desirable. The class money above is such an example. We show here how to do it for strings.</source>
          <target state="translated">정수 및 문자열과 같은 원시 유형을 객체로 취급 할 수 있는지 궁금 할 수 있습니다. 이것은 일반적으로 정수 나 문자열에는 흥미롭지 않지만 이것이 바람직한 상황이있을 수 있습니다. 위의 학급 돈이 그러한 예입니다. 여기에서는 문자열에 대해 수행하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b3a6da4a2194d9a62f8ff334748a426441e352b3" translate="yes" xml:space="preserve">
          <source>One should notice that the use of the &lt;code&gt;parser&lt;/code&gt; keyword and associated notation for streams are only available through camlp4 extensions. This means that one has to preprocess its sources</source>
          <target state="translated">하나는 사용 통지해야한다 &lt;code&gt;parser&lt;/code&gt; 스트림에 대한 키워드 및 관련 표기가 camlp4 확장을 통해에서만 사용할 수 있습니다. 이것은 소스를 사전 처리해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0c4137e328694d44e01b837a396be545fdedd151" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays</source>
          <target state="translated">1 차원 배열</target>
        </trans-unit>
        <trans-unit id="6073cf4225ea4cf9fd99b377fa082aad9eea6d61" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays.</source>
          <target state="translated">1 차원 배열.</target>
        </trans-unit>
        <trans-unit id="19597e0daea38469940aa2541294449599b19f03" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays. The &lt;code&gt;Array1&lt;/code&gt; structure provides operations similar to those of &lt;a href=&quot;bigarray.genarray&quot;&gt;&lt;code&gt;Bigarray.Genarray&lt;/code&gt;&lt;/a&gt;, but specialized to the case of one-dimensional arrays. (The &lt;a href=&quot;bigarray.array2&quot;&gt;&lt;code&gt;Bigarray.Array2&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;bigarray.array3&quot;&gt;&lt;code&gt;Bigarray.Array3&lt;/code&gt;&lt;/a&gt; structures below provide operations specialized for two- and three-dimensional arrays.) Statically knowing the number of dimensions of the array allows faster operations, and more precise static type-checking.</source>
          <target state="translated">1 차원 배열. &lt;code&gt;Array1&lt;/code&gt; 구조와 유사한 동작 제공 &lt;a href=&quot;bigarray.genarray&quot;&gt; &lt;code&gt;Bigarray.Genarray&lt;/code&gt; 을&lt;/a&gt; 하지만, 하나의 차원 배열의 경우와 전문. ( 아래 의 &lt;a href=&quot;bigarray.array2&quot;&gt; &lt;code&gt;Bigarray.Array2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;bigarray.array3&quot;&gt; &lt;code&gt;Bigarray.Array3&lt;/code&gt; &lt;/a&gt; 구조는 2 차원 및 3 차원 배열에 특화된 작업을 제공합니다.) 배열의 차원 수를 정적으로 알면 더 빠른 작업과보다 정확한 정적 유형 검사가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5e57737797ac7cce48fd7410f424583fc8513250" translate="yes" xml:space="preserve">
          <source>Only consider using &lt;code&gt;print_flush&lt;/code&gt; when displaying all pending material is mandatory (for instance in case of interactive use when you want the user to read some text) and when resetting the pretty-printer state will not disturb further pretty-printing.</source>
          <target state="translated">보류중인 모든 자료를 표시 &lt;code&gt;print_flush&lt;/code&gt; 경우 에만 print_flush를 사용하는 것이 좋습니다 (예 : 사용자가 텍스트를 읽을 수 있도록 대화 형 사용의 경우). pretty-printer 상태를 재설정해도 더 이상 pretty-printing을 방해하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57c1f2f7c1cbc3df8fd97de870c8cc67eed2b309" translate="yes" xml:space="preserve">
          <source>Only elements (values, types, classes, ...) declared in the .mli file are kept. In other terms, definitions from the .ml file that are not exported in the .mli file are not documented.</source>
          <target state="translated">.mli 파일에 선언 된 요소 (값, 유형, 클래스, ...) 만 유지됩니다. 즉, .mli 파일로 내 보내지 않은 .ml 파일의 정의는 문서화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b33e1f6fc9c9ddf7561ddbbf58ce1315c78aa84" translate="yes" xml:space="preserve">
          <source>Only generative effects:</source>
          <target state="translated">생성 효과 만 :</target>
        </trans-unit>
        <trans-unit id="5fd27083a589b2ea8c548b530eaf11c8f07666db" translate="yes" xml:space="preserve">
          <source>Only the override can be used to actually override fields, and only the Oo.copy primitive can be used externally.</source>
          <target state="translated">오버라이드 만 사용하여 필드를 실제로 오버라이드 할 수 있으며 Oo.copy 프리미티브 만 외부에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39d7997d1c51094c34071c019aa4016ceac60919" translate="yes" xml:space="preserve">
          <source>Oo</source>
          <target state="translated">Oo</target>
        </trans-unit>
        <trans-unit id="879894b2b7b07e597e8cd61a26bfd25635e3e7b3" translate="yes" xml:space="preserve">
          <source>Open a descriptor on a directory</source>
          <target state="translated">디렉토리에서 설명자 열기</target>
        </trans-unit>
        <trans-unit id="42cdbc4aac5165559359ac8e455a8abf3fb22ee2" translate="yes" xml:space="preserve">
          <source>Open for append</source>
          <target state="translated">추가를 위해 열기</target>
        </trans-unit>
        <trans-unit id="f22f60235dedec7386d0bead1c3c094a8425cdd5" translate="yes" xml:space="preserve">
          <source>Open for reading</source>
          <target state="translated">읽기 위해 열기</target>
        </trans-unit>
        <trans-unit id="9fe9ee1f7787491ffb2ce2a09f2e3a1c47b49760" translate="yes" xml:space="preserve">
          <source>Open for reading and writing</source>
          <target state="translated">읽기 및 쓰기 용으로 개방</target>
        </trans-unit>
        <trans-unit id="e02c2958f8bca2d69a22cec109cddef10f1b7f6a" translate="yes" xml:space="preserve">
          <source>Open for writing</source>
          <target state="translated">쓰기 위해 열기</target>
        </trans-unit>
        <trans-unit id="0c50ee9bdb83bc2966178eb9517aa2ed3bb705c2" translate="yes" xml:space="preserve">
          <source>Open in non-blocking mode</source>
          <target state="translated">비 차단 모드로 열기</target>
        </trans-unit>
        <trans-unit id="be813666b3c7520ae92cd0a1c6783279f682b877" translate="yes" xml:space="preserve">
          <source>Open statement shadows an already defined identifier.</source>
          <target state="translated">Open 문은 이미 정의 된 식별자를 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="50ebdf1219ecd6520cbac717e097eb9be6c3aaca" translate="yes" xml:space="preserve">
          <source>Open statement shadows an already defined label or constructor.</source>
          <target state="translated">Open 문은 이미 정의 된 레이블 또는 생성자를 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="12f7d6bffbe087ced7c1077d53f97324fb2738f7" translate="yes" xml:space="preserve">
          <source>Open the named file for reading, and return a new input channel on that file, positioned at the beginning of the file.</source>
          <target state="translated">읽기 위해 명명 된 파일을 열고 해당 파일의 시작 부분에있는 새 입력 채널을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6cca06bc653ed2aa9b9ca617abff820d8ae7223d" translate="yes" xml:space="preserve">
          <source>Open the named file for writing, and return a new output channel on that file, positioned at the beginning of the file.</source>
          <target state="translated">쓰기 위해 명명 된 파일을 열고 해당 파일의 시작 부분에있는 새 출력 채널을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ff1c4e694cef020d3159f32a866f2a047386814" translate="yes" xml:space="preserve">
          <source>Open the named file for writing, and return a new output channel on that file, positioned at the beginning of the file. The file is truncated to zero length if it already exists. It is created if it does not already exists.</source>
          <target state="translated">쓰기 위해 명명 된 파일을 열고 해당 파일의 시작 부분에있는 새 출력 채널을 반환합니다. 파일이 이미있는 경우 길이가 0으로 잘립니다. 아직 존재하지 않는 경우 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="855fccd9cd030742446f7fcafaafb5b0c12184d8" translate="yes" xml:space="preserve">
          <source>Open the named file with the given flags.</source>
          <target state="translated">주어진 플래그로 명명 된 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="df722ec03c209e9326d618d229491b24151a9084" translate="yes" xml:space="preserve">
          <source>Open the named file with the given flags. Third argument is the permissions to give to the file if it is created (see &lt;a href=&quot;unix#VALumask&quot;&gt;&lt;code&gt;Unix.umask&lt;/code&gt;&lt;/a&gt;). Return a file descriptor on the named file.</source>
          <target state="translated">주어진 플래그로 명명 된 파일을 엽니 다. 세 번째 인수는 파일이 생성 된 경우 파일에 부여 할 권한입니다 ( &lt;a href=&quot;unix#VALumask&quot;&gt; &lt;code&gt;Unix.umask&lt;/code&gt; &lt;/a&gt; 참조 ). 명명 된 파일에 대한 파일 설명자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f49f1f535c925238e318a33c608a939bf58bc5fe" translate="yes" xml:space="preserve">
          <source>Open the named file with the given flags. Third argument is the permissions to give to the file if it is created. Return a file descriptor on the named file.</source>
          <target state="translated">주어진 플래그로 명명 된 파일을 엽니 다. 세 번째 인수는 파일이 생성 된 경우 파일에 부여 할 권한입니다. 명명 된 파일에 대한 파일 설명자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="83c183b6c4d6c2979639b113137c57ec0de409f0" translate="yes" xml:space="preserve">
          <source>Opening a module enables lighter access to its components, at the cost of making it harder to identify in which module a identifier has been defined. In particular, opened modules can shadow identifiers present in the current scope, potentially leading to confusing errors:</source>
          <target state="translated">모듈을 열면 식별자가 정의 된 모듈을 식별하기 어렵게 만드는 대신 해당 구성 요소에 대한 액세스가 더 쉬워집니다. 특히, 열린 모듈은 현재 범위에있는 식별자를 섀도 잉하여 잠재적으로 혼란스러운 오류를 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5209b9452f8161599a2a771725ad2ccd16a6bec" translate="yes" xml:space="preserve">
          <source>Opening modes for &lt;a href=&quot;stdlib#VALopen_out_gen&quot;&gt;&lt;code&gt;open_out_gen&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdlib#VALopen_in_gen&quot;&gt;&lt;code&gt;open_in_gen&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALopen_out_gen&quot;&gt; &lt;code&gt;open_out_gen&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stdlib#VALopen_in_gen&quot;&gt; &lt;code&gt;open_in_gen&lt;/code&gt; 의&lt;/a&gt; 열기 모드 .</target>
        </trans-unit>
        <trans-unit id="f9f27f60f5932e4abb4b4ed37257f5c7c5328157" translate="yes" xml:space="preserve">
          <source>Opens the given module before processing the interface or implementation files. If several -open options are given, they are processed in order, just as if the statements open!Module1;;...open!ModuleN;; were added at the top of each file.</source>
          <target state="translated">인터페이스 또는 구현 파일을 처리하기 전에 지정된 모듈을 엽니 다. 여러 개의 -open 옵션이 제공되면 명령문이 open! Module1 ;; ... open! ModuleN ;; 각 파일의 상단에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="785a4531dce5036578aea8e49ed353d58a926529" translate="yes" xml:space="preserve">
          <source>Operating system currently executing the OCaml program.</source>
          <target state="translated">현재 OCaml 프로그램을 실행중인 운영 체제입니다.</target>
        </trans-unit>
        <trans-unit id="21abc6dbd0063cb952c1cc150a7203c29ccc476d" translate="yes" xml:space="preserve">
          <source>Operating system currently executing the OCaml program. One of</source>
          <target state="translated">현재 OCaml 프로그램을 실행중인 운영 체제입니다. 다음 중 하나</target>
        </trans-unit>
        <trans-unit id="0fc51a5c314382c855158eda38ff5409a7e69535" translate="yes" xml:space="preserve">
          <source>Operation already in progress</source>
          <target state="translated">이미 진행중인 작업</target>
        </trans-unit>
        <trans-unit id="25ef925607b43bca64c3829868d9989b76540d3a" translate="yes" xml:space="preserve">
          <source>Operation not permitted</source>
          <target state="translated">작동이 허용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="c49e2a256113761881fb1a1fa41d066e27d70d15" translate="yes" xml:space="preserve">
          <source>Operation not supported on socket</source>
          <target state="translated">소켓에서 지원되지 않는 작업</target>
        </trans-unit>
        <trans-unit id="8fdc938d87d0b18a567701392c335d0c883fa4b7" translate="yes" xml:space="preserve">
          <source>Operation now in progress</source>
          <target state="translated">현재 진행중인 작업</target>
        </trans-unit>
        <trans-unit id="db648ff618df972b87b0f378a6996fcda48575ee" translate="yes" xml:space="preserve">
          <source>Operation would block</source>
          <target state="translated">작업이 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="66d4b9b2ab0289179c7507e1de79db969d3d4674" translate="yes" xml:space="preserve">
          <source>Operations on binary trees are naturally expressed as recursive functions following the same structure as the type definition itself. For instance, here are functions performing lookup and insertion in ordered binary trees (elements increase from left to right):</source>
          <target state="translated">이진 트리에 대한 연산은 형식 정의 자체와 동일한 구조를 따르는 재귀 함수로 자연스럽게 표현됩니다. 예를 들어, 다음은 정렬 된 이진 트리에서 조회 및 삽입을 수행하는 함수입니다 (요소가 왼쪽에서 오른쪽으로 증가 함).</target>
        </trans-unit>
        <trans-unit id="46ba0f6e1bd0b179a386572eb306814fd822f312" translate="yes" xml:space="preserve">
          <source>Operations on file descriptors</source>
          <target state="translated">파일 설명자에 대한 작업</target>
        </trans-unit>
        <trans-unit id="d8dd6735ea7932a85dd5996051b8e28bae8e00af" translate="yes" xml:space="preserve">
          <source>Operations on file names</source>
          <target state="translated">파일 이름에 대한 작업</target>
        </trans-unit>
        <trans-unit id="cb3fabd6bce5c3e474e507106204018aa930b99e" translate="yes" xml:space="preserve">
          <source>Operations on file names.</source>
          <target state="translated">파일 이름에 대한 작업.</target>
        </trans-unit>
        <trans-unit id="d0e7fd3b17cf5a9396bca0fcd458a4b1c3357462" translate="yes" xml:space="preserve">
          <source>Operations on format strings</source>
          <target state="translated">형식 문자열에 대한 작업</target>
        </trans-unit>
        <trans-unit id="62d745537237adfa18d0a04a59f915fbeb6922d1" translate="yes" xml:space="preserve">
          <source>Operations on internal representations of values.</source>
          <target state="translated">가치의 내부 표현에 대한 작업.</target>
        </trans-unit>
        <trans-unit id="ef05a420fdb91696847263f07548f0822231b601" translate="yes" xml:space="preserve">
          <source>Operations on large files</source>
          <target state="translated">대용량 파일에 대한 작업</target>
        </trans-unit>
        <trans-unit id="884b46ea59004fc7b9feee6503d70fe0de517a3c" translate="yes" xml:space="preserve">
          <source>Operations on large files.</source>
          <target state="translated">대용량 파일에 대한 작업.</target>
        </trans-unit>
        <trans-unit id="392a9d3b032591e4ff18dd78bdf784b52dd45f89" translate="yes" xml:space="preserve">
          <source>Operations on objects</source>
          <target state="translated">개체에 대한 작업</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="c4083b8c5eac166a2a2acd9a240e21f33de8bf2b" translate="yes" xml:space="preserve">
          <source>Operator class</source>
          <target state="translated">연산자 클래스</target>
        </trans-unit>
        <trans-unit id="2866cf078fa7e1a2f2d0a2ea0ea2b67ee507cc6b" translate="yes" xml:space="preserve">
          <source>Operator names starting with a # character and containing more than one # character are reserved for extensions.</source>
          <target state="translated"># 문자로 시작하고 둘 이상의 # 문자를 포함하는 연산자 이름은 확장을 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="45483f2ad274c0501b5ffbf4bf59ee7cd50884a0" translate="yes" xml:space="preserve">
          <source>Optimisation with Flambda is not currently supported when generating bytecode.</source>
          <target state="translated">Flambda를 사용한 최적화는 현재 바이트 코드를 생성 할 때 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fdf5e093149fa15365c797b12b39a00d5ec3a138" translate="yes" xml:space="preserve">
          <source>Optimization</source>
          <target state="translated">Optimization</target>
        </trans-unit>
        <trans-unit id="9d029eff2b929a5ac0d4af743cee64e78c8571a4" translate="yes" xml:space="preserve">
          <source>Optimize the produced code for space rather than for time. This results in slightly smaller but slightly slower programs. The default is to optimize for speed.</source>
          <target state="translated">생성 된 코드를 시간이 아닌 공간에 맞게 최적화하십시오. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 이로 인해 프로그램이 약간 작아 지지만 약간 느려집니다. 기본값은 속도 최적화입니다.</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="b4461387353942c5c9a36536dba32b4583899a32" translate="yes" xml:space="preserve">
          <source>Option values explicitly indicate the presence or absence of a value.</source>
          <target state="translated">옵션 값은 값의 존재 여부를 명시 적으로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="eed9d5149119da92f8108cc447b5c8a63bc1983d" translate="yes" xml:space="preserve">
          <source>Option values.</source>
          <target state="translated">옵션 값.</target>
        </trans-unit>
        <trans-unit id="b72c0a2e7190e2eb7aaa162394774f42f8444781" translate="yes" xml:space="preserve">
          <source>Optional arguments are actually implemented as option types. If you do not give a default value, you have access to their internal representation, type 'a option = None | Some of 'a. You can then provide different behaviors when an argument is present or not.</source>
          <target state="translated">선택적 인수는 실제로 옵션 유형으로 구현됩니다. 기본값을 제공하지 않으면 내부 표현에 액세스 할 수 있습니다. 'a option = None | 'a. 그런 다음 인수가 있거나 없을 때 다른 동작을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57beea4dfffda43497b4bb0d9bd857b0df0104e1" translate="yes" xml:space="preserve">
          <source>Optional parameters may also commute with non-optional or unlabeled ones, as long as they are applied simultaneously. By nature, optional arguments do not commute with unlabeled arguments applied independently.</source>
          <target state="translated">선택적 매개 변수는 동시에 적용되는 한 선택 사항이 아니거나 레이블이없는 매개 변수와도 통근 할 수 있습니다. 본질적으로 선택적 인수는 레이블이 지정되지 않은 인수가 독립적으로 적용된 상태로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="659fd3897d334a8024280ea2db630f05a96e06e0" translate="yes" xml:space="preserve">
          <source>Optionally, missing fields can be made explicit by ending the list of fields with a trailing wildcard _::</source>
          <target state="translated">선택적으로 필드 목록을 후행 와일드 카드 _ :로 종료하여 누락 된 필드를 명시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="de973f948db8258d8d749bfe279d72496cf0c025" translate="yes" xml:space="preserve">
          <source>Options selecting a built-in generator to ocamldoc, such as -html, have no effect if a custom generator of the same kind is provided using -g. If the kinds do not match, the selected built-in generator is used and the custom one is ignored.</source>
          <target state="translated">ocamldoc에 내장 된 생성기를 선택하는 옵션 (예 : -html)은 -g를 사용하여 동일한 종류의 사용자 정의 생성기를 제공하는 경우 효과가 없습니다. 종류가 일치하지 않으면 선택한 내장 생성기가 사용되고 사용자 정의 생성기는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ecfdbe107bba41b0abba570531e3c3d244ee7166" translate="yes" xml:space="preserve">
          <source>Options to &lt;a href=&quot;unix#VALgetaddrinfo&quot;&gt;&lt;code&gt;Unix.getaddrinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALgetaddrinfo&quot;&gt; &lt;code&gt;Unix.getaddrinfo&lt;/code&gt; &lt;/a&gt; 옵션 .</target>
        </trans-unit>
        <trans-unit id="acbc13cd4094c5e7aa7a8e52fa68629dbf0813f9" translate="yes" xml:space="preserve">
          <source>Options to &lt;a href=&quot;unix#VALgetnameinfo&quot;&gt;&lt;code&gt;Unix.getnameinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALgetnameinfo&quot;&gt; &lt;code&gt;Unix.getnameinfo&lt;/code&gt; &lt;/a&gt; 옵션 .</target>
        </trans-unit>
        <trans-unit id="cabf18c33657daede436c9425e69c4a2df9c4ba4" translate="yes" xml:space="preserve">
          <source>Or, equivalently:</source>
          <target state="translated">또는 동등하게 :</target>
        </trans-unit>
        <trans-unit id="1c2251dba4688a589e898c162858a821fdb5b816" translate="yes" xml:space="preserve">
          <source>Other comments for &lt;a href=&quot;hashtbl#VALiter&quot;&gt;&lt;code&gt;Hashtbl.iter&lt;/code&gt;&lt;/a&gt; apply as well.</source>
          <target state="translated">&lt;a href=&quot;hashtbl#VALiter&quot;&gt; &lt;code&gt;Hashtbl.iter&lt;/code&gt; 에&lt;/a&gt; 대한 다른 주석도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f72667213aa60e61b77943168bfb7d9b47ab1a35" translate="yes" xml:space="preserve">
          <source>Other generic comparisons such as (&amp;lt;, &amp;lt;=, ...) can also be used on objects. The relation &amp;lt; defines an unspecified but strict ordering on objects. The ordering relationship between two objects is fixed once for all after the two objects have been created and it is not affected by mutation of fields.</source>
          <target state="translated">(&amp;lt;, &amp;lt;=, ...)와 같은 다른 일반 비교도 객체에 사용할 수 있습니다. 관계 &amp;lt;는 지정되지 않았지만 객체에 대한 엄격한 순서를 정의합니다. 두 객체 사이의 순서 관계는 두 객체가 생성 된 후 모두 한 번 고정되며 필드 변형의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d3a931554b88e85d13e345dd0998e69549806d3" translate="yes" xml:space="preserve">
          <source>Other types do not introduce new subtyping, but they may propagate the subtyping of their arguments. For instance, &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;*&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt;*&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt; when &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; are respectively subtypes of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt;. For function types, the relation is more subtle: &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt; if &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; is a supertype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt; and &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; is a subtype of &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;2&lt;/sub&gt;. For this reason, function types are covariant in their second argument (like tuples), but contravariant in their first argument. Mutable types, like array or ref are neither covariant nor contravariant, they are nonvariant, that is they do not propagate subtyping.</source>
          <target state="translated">다른 유형은 새로운 하위 유형을 도입하지 않지만 인수의 하위 유형을 전파 할 수 있습니다. 예를 들어, &lt;a href=&quot;types#typexpr&quot;&gt;일반 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; * &lt;a href=&quot;types#typexpr&quot;&gt;일반 &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 의 하위 유형 &lt;a href=&quot;types#typexpr&quot;&gt;일반&lt;/a&gt; ' &lt;sub&gt;1&lt;/sub&gt; * &lt;a href=&quot;types#typexpr&quot;&gt;일반&lt;/a&gt; ' &lt;sub&gt;2&lt;/sub&gt; 시 &lt;a href=&quot;types#typexpr&quot;&gt;일반 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 과 &lt;a href=&quot;types#typexpr&quot;&gt;일반 &lt;/a&gt;&lt;sub&gt;(2)&lt;/sub&gt; 각각의 서브 타입이다 &lt;a href=&quot;types#typexpr&quot;&gt;일반&lt;/a&gt; ' &lt;sub&gt;(1)&lt;/sub&gt; 및 &lt;a href=&quot;types#typexpr&quot;&gt;일반&lt;/a&gt; ' &lt;sub&gt;2&lt;/sub&gt; . 함수 유형의 경우 관계가 더 미묘합니다. &lt;a href=&quot;types#typexpr&quot;&gt;typ &lt;/a&gt;&lt;sub&gt;1-&lt;/sub&gt; &amp;gt; &lt;a href=&quot;types#typexpr&quot;&gt;typ &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 는 &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt; &amp;prime; &lt;sub&gt;1-&lt;/sub&gt; &amp;gt; &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt; &amp;prime; &lt;sub&gt;2&lt;/sub&gt; 의 하위 유형입니다.&lt;sub&gt;&lt;/sub&gt;만약 &lt;a href=&quot;types#typexpr&quot;&gt;일반 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 의 슈퍼 인 &lt;a href=&quot;types#typexpr&quot;&gt;일반&lt;/a&gt; ' &lt;sub&gt;(1)&lt;/sub&gt; 및 &lt;a href=&quot;types#typexpr&quot;&gt;일반 &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; 의 하위 유형 &lt;a href=&quot;types#typexpr&quot;&gt;일반&lt;/a&gt; ' &lt;sub&gt;2&lt;/sub&gt; . 이러한 이유로 함수 유형은 두 번째 인수 (튜플과 같이)에서는 공변이지만 첫 번째 인수에서는 반 변성입니다. array 또는 ref와 같은 변경 가능한 유형은 공변도 반변도도 아니며 비 변형입니다. 즉, 하위 유형을 전파하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="88cb471cac1651f6cd901864ed749958654b7d77" translate="yes" xml:space="preserve">
          <source>Otherwise the function being called is substituted at the call site with its body having been rewritten such that any recursive calls to that function &lt;em&gt;or any others in the same mutually-recursive group&lt;/em&gt; are annotated with the attribute unrolled(n &amp;minus; 1). Inlining may continue on that body.</source>
          <target state="translated">그렇지 않으면 호출되는 함수는 호출 사이트에서 본문이 다시 작성되어 해당 함수 &lt;em&gt;또는 동일한 상호 순환 그룹의 다른&lt;/em&gt; 모든 재귀 호출이 unrolled (n-1) 속성으로 주석 처리되도록 대체됩니다 . 인라이닝은 해당 바디에서 계속 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cf7d27ce868f52e567b02e4ec391690c62f134e" translate="yes" xml:space="preserve">
          <source>Otherwise, nothing happens.</source>
          <target state="translated">그렇지 않으면 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c86b00df30e667ed3c1e54e980a320c6bfb8e87" translate="yes" xml:space="preserve">
          <source>Otherwise, the initialising array is lifted out and subject to the normal constant sharing procedure; creation of the array consists of bulk copying the initialising array into a fresh value on the OCaml heap.</source>
          <target state="translated">그렇지 않으면 초기화 어레이가 해제되고 정상적인 지속적인 공유 절차가 적용됩니다. 배열 생성은 초기화 배열을 OCaml 힙의 새로운 값으로 대량 복사하는 것으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="aafa7eee672f6b85c088cd2cb345b72adf66f904" translate="yes" xml:space="preserve">
          <source>Otherwise, the symbol is bound to a (statically-allocated) &lt;em&gt;preallocated block&lt;/em&gt; containing one field. At runtime, the defining expression will be evaluated and the first field of the block filled with the resulting value. This &lt;em&gt;initialise-symbol&lt;/em&gt; binding causes one extra indirection but ensures, by virtue of the symbol&amp;rsquo;s address being known at compile time, that uses of the value are not captured by closures.</source>
          <target state="translated">그렇지 않으면 심볼은 하나의 필드를 포함 하는 (정적으로 할당 된) &lt;em&gt;사전 할당 된 블록에&lt;/em&gt; 바인딩됩니다 . 런타임시 정의 표현식이 평가되고 블록의 첫 번째 필드가 결과 값으로 채워집니다. 이 &lt;em&gt;초기화 기호&lt;/em&gt; 바인딩은 하나의 추가 간접을 유발하지만 컴파일 시간에 알려진 기호의 주소로 인해 값의 사용이 클로저에 의해 캡처되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="1e89ee3a810516da1f61deb1e918aa6f94233ccf" translate="yes" xml:space="preserve">
          <source>Our iterator works, as shows its first use for summation. However, since objects themselves are not polymorphic (only their constructors are), using the fold method fixes its type for this individual object. Our next attempt to use it as a string iterator fails.</source>
          <target state="translated">우리의 반복자는 합산에 대한 첫 번째 사용을 보여 주듯이 작동합니다. 그러나 객체 자체는 다형성이 아니기 때문에 (생성자 만 해당) fold 메서드를 사용하면이 개별 객체의 유형이 수정됩니다. 이것을 문자열 반복자로 사용하려는 다음 시도는 실패합니다.</target>
        </trans-unit>
        <trans-unit id="0be297b561141a6a2d82a7108dddc36e1cc22dba" translate="yes" xml:space="preserve">
          <source>Out of memory</source>
          <target state="translated">메모리 부족</target>
        </trans-unit>
        <trans-unit id="6e02b9b7b5116b9cf2721c4e3f0f7bdbc58079e4" translate="yes" xml:space="preserve">
          <source>Output GC statistics at program exit.</source>
          <target state="translated">프로그램 종료시 GC 통계를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="7671f0341e3d098b8c9393d0300f5e4d7f5c6621" translate="yes" xml:space="preserve">
          <source>Output baud rate (0 means close connection).</source>
          <target state="translated">출력 전송 속도 (0은 가까운 연결을 의미).</target>
        </trans-unit>
        <trans-unit id="0c09cf6b42600a87ca03143becccdcb8b33419e1" translate="yes" xml:space="preserve">
          <source>Output code that does not use OCaml&amp;rsquo;s built-in automata interpreter. Instead, the automaton is encoded by OCaml functions. This option improves performance when using the native compiler, but decreases it when using the bytecode compiler.</source>
          <target state="translated">OCaml의 내장 오토마타 인터프리터를 사용하지 않는 출력 코드. 대신 오토 마톤은 OCaml 함수로 인코딩됩니다. 이 옵션은 네이티브 컴파일러를 사용할 때 성능을 향상 시키지만 바이트 코드 컴파일러를 사용할 때는 성능을 저하시킵니다.</target>
        </trans-unit>
        <trans-unit id="743a4b6a0ace04e22a3f7d73badb17283ccbd3bc" translate="yes" xml:space="preserve">
          <source>Output dot code describing the type dependency graph instead of the module dependency graph.</source>
          <target state="translated">모듈 종속성 그래프 대신 유형 종속성 그래프를 설명하는 도트 코드를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="2da5f56773c68337139a5eca245caeacb63ae861" translate="yes" xml:space="preserve">
          <source>Output functions on standard error</source>
          <target state="translated">표준 오류에 대한 출력 기능</target>
        </trans-unit>
        <trans-unit id="99ab5418296d95f226bfcd5834dc0e99eb65877d" translate="yes" xml:space="preserve">
          <source>Output functions on standard output</source>
          <target state="translated">표준 출력의 출력 기능</target>
        </trans-unit>
        <trans-unit id="2900df23d8753bef8ba40bb95924b811a8a31a30" translate="yes" xml:space="preserve">
          <source>Output one line per file, regardless of the length.</source>
          <target state="translated">길이에 관계없이 파일 당 한 줄을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="052a1c1bf420fd7d12e0f3d0ea009ebee9739c3a" translate="yes" xml:space="preserve">
          <source>Output raw dependencies of the form</source>
          <target state="translated">양식의 원시 종속성 출력</target>
        </trans-unit>
        <trans-unit id="49bd2e99d5d5374f1bd9969053ecf288c36f827f" translate="yes" xml:space="preserve">
          <source>Output signature of the functor &lt;a href=&quot;map.make&quot;&gt;&lt;code&gt;Map.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">펑터 &lt;a href=&quot;map.make&quot;&gt; &lt;code&gt;Map.Make&lt;/code&gt; &lt;/a&gt; 의 출력 서명 .</target>
        </trans-unit>
        <trans-unit id="5145c8c79a32654b4778e9f93670595bbd8d1719" translate="yes" xml:space="preserve">
          <source>Output signature of the functor &lt;a href=&quot;set.make&quot;&gt;&lt;code&gt;Set.Make&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">펑터 &lt;a href=&quot;set.make&quot;&gt; &lt;code&gt;Set.Make&lt;/code&gt; &lt;/a&gt; 의 출력 서명 .</target>
        </trans-unit>
        <trans-unit id="d31f223f57817b5e1d76b337263e2c889f885c49" translate="yes" xml:space="preserve">
          <source>Output the generated documentation to file instead of ocamldoc.out. This option is meaningful only in conjunction with the -latex, -texi, or -dot options.</source>
          <target state="translated">생성 된 문서를 ocamldoc.out 대신 파일로 출력하십시오. 이 옵션은 -latex, -texi 또는 -dot 옵션과 함께 사용하는 경우에만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="95791b995af7b93d84b0104e38a8bf231ca37bde" translate="yes" xml:space="preserve">
          <source>Outside of this domain, &lt;code&gt;pp_set_geometry&lt;/code&gt; raises an invalid argument exception whereas &lt;code&gt;pp_safe_set_geometry&lt;/code&gt; does nothing.</source>
          <target state="translated">이 도메인 외부에서 &lt;code&gt;pp_set_geometry&lt;/code&gt; 는 잘못된 인수 예외를 발생시키는 반면 &lt;code&gt;pp_safe_set_geometry&lt;/code&gt; 는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6d1264bc905918faeda24a1a224e8b90ab0b9d7" translate="yes" xml:space="preserve">
          <source>Outside the structure, its components can be referred to using the &amp;ldquo;dot notation&amp;rdquo;, that is, identifiers qualified by a structure name. For instance, PrioQueue.insert is the function insert defined inside the structure PrioQueue and PrioQueue.queue is the type queue defined in PrioQueue.</source>
          <target state="translated">구조 외부에서 구성 요소는 &quot;점 표기법&quot;, 즉 구조 이름으로 한정된 식별자를 사용하여 참조 할 수 있습니다. 예를 들어 PrioQueue.insert는 PrioQueue 구조 내에 정의 된 함수 삽입이고 PrioQueue.queue는 PrioQueue에 정의 된 유형 대기열입니다.</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="09bd6a353a7bb8a33e37cfee71ada9fc9ce37d89" translate="yes" xml:space="preserve">
          <source>PATH</source>
          <target state="translated">PATH</target>
        </trans-unit>
        <trans-unit id="da18ad2a8cc0702f3ea2d5253be6cbd4ca251be5" translate="yes" xml:space="preserve">
          <source>PF_INET is fully supported; PF_INET6 is fully supported (since 4.01.0); PF_UNIX is not supported</source>
          <target state="translated">PF_INET은 완전히 지원됩니다. PF_INET6은 완전히 지원됩니다 (4.01.0부터). PF_UNIX는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4dc6925c70ec89b041de02dd5e2ee478c8a2fff1" translate="yes" xml:space="preserve">
          <source>Pair operations</source>
          <target state="translated">페어링 작업</target>
        </trans-unit>
        <trans-unit id="f699f295e5ae4ac633cfa18437fed38d028b3fdb" translate="yes" xml:space="preserve">
          <source>Parameter</source>
          <target state="translated">Parameter</target>
        </trans-unit>
        <trans-unit id="06f18dad25a25477df3046f706b5e47ba6a1cff9" translate="yes" xml:space="preserve">
          <source>Parameterize one function by the other. That is, instead of having</source>
          <target state="translated">한 기능을 다른 기능으로 매개 변수화합니다. 즉,</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="da3863839aefaac9ffd796e91309941e5a0aabf4" translate="yes" xml:space="preserve">
          <source>Parenthesized expressions can also contain coercions (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;] :&amp;gt;&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;) (see subsection &lt;a href=&quot;#ss%3Aexpr-coercions&quot;&gt;7.7.7&lt;/a&gt; below).</source>
          <target state="translated">괄호로 &lt;a href=&quot;types#typexpr&quot;&gt;묶인&lt;/a&gt; 표현식은 강제 변환 ( &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; [: typexpr ] :&amp;gt; &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; ) 도 포함 할 수 있습니다 ( 아래 &lt;a href=&quot;#ss%3Aexpr-coercions&quot;&gt;7.7.7&lt;/a&gt; 절 참조).</target>
        </trans-unit>
        <trans-unit id="78e82529fec7a054cadaa05482779b54cccd0e7d" translate="yes" xml:space="preserve">
          <source>Parenthesized expressions can contain a type constraint, as in (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;). This constraint forces the type of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; to be compatible with &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;.</source>
          <target state="translated">괄호로 &lt;a href=&quot;types#typexpr&quot;&gt;묶인&lt;/a&gt; 표현식에는 ( &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; : typexpr ) 과 같이 유형 제약 조건이 포함될 수 있습니다 . 이 제약 조건은 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 유형이 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; 과 호환되도록 강제 합니다.</target>
        </trans-unit>
        <trans-unit id="7294d33710169103141018bfcb0ee5ad3daa81e2" translate="yes" xml:space="preserve">
          <source>Parsing</source>
          <target state="translated">Parsing</target>
        </trans-unit>
        <trans-unit id="b2eda9d52f18e0568a63bc181bcaa6ee3a98404e" translate="yes" xml:space="preserve">
          <source>Parsing of command line arguments.</source>
          <target state="translated">명령 줄 인수 구문 분석.</target>
        </trans-unit>
        <trans-unit id="6c9e17bd7715006188f45f1708aaf0fea52ec4f8" translate="yes" xml:space="preserve">
          <source>Part &lt;a href=&quot;index#p%3Acommands&quot;&gt;III&lt;/a&gt;, &amp;ldquo;The OCaml tools&amp;rdquo;, documents the compilers, toplevel system, and programming utilities.</source>
          <target state="translated">파트 &lt;a href=&quot;index#p%3Acommands&quot;&gt;III&lt;/a&gt; ,&amp;ldquo;OCaml 도구&amp;rdquo;는 컴파일러, 최상위 시스템 및 프로그래밍 유틸리티에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="18c889dcbcc02d29f2665be2a7454d8a1987503b" translate="yes" xml:space="preserve">
          <source>Part &lt;a href=&quot;index#p%3Alibrary&quot;&gt;IV&lt;/a&gt;, &amp;ldquo;The OCaml library&amp;rdquo;, describes the modules provided in the standard library.</source>
          <target state="translated">Part &lt;a href=&quot;index#p%3Alibrary&quot;&gt;IV&lt;/a&gt; ,&amp;ldquo;The OCaml 라이브러리&amp;rdquo;는 표준 라이브러리에서 제공되는 모듈을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2f0668847ca907120f5188c16ff537453a2eafe0" translate="yes" xml:space="preserve">
          <source>Part &lt;a href=&quot;index#p%3Arefman&quot;&gt;II&lt;/a&gt;, &amp;ldquo;The OCaml language&amp;rdquo;, is the reference description of the language.</source>
          <target state="translated">파트 &lt;a href=&quot;index#p%3Arefman&quot;&gt;II&lt;/a&gt; ,&amp;ldquo;OCaml 언어&amp;rdquo;는 언어에 대한 참조 설명입니다.</target>
        </trans-unit>
        <trans-unit id="903f9019ed78ac57cfad4f904e7657f4fe68eff9" translate="yes" xml:space="preserve">
          <source>Part &lt;a href=&quot;index#p%3Atutorials&quot;&gt;I&lt;/a&gt;, &amp;ldquo;An introduction to OCaml&amp;rdquo;, gives an overview of the language.</source>
          <target state="translated">Part &lt;a href=&quot;index#p%3Atutorials&quot;&gt;I&lt;/a&gt; ,&amp;ldquo;An Introduction to OCaml&amp;rdquo;은 언어에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b1a2c5985aa86cde57c2ecbbc6cbc8380d79481d" translate="yes" xml:space="preserve">
          <source>Part I An introduction to OCaml</source>
          <target state="translated">Part I OCaml 소개</target>
        </trans-unit>
        <trans-unit id="a62eaed854d7e70fe37691fb3a427228618bcb89" translate="yes" xml:space="preserve">
          <source>Part II The OCaml language</source>
          <target state="translated">파트 II OCaml 언어</target>
        </trans-unit>
        <trans-unit id="6b5891d0deb20c4e4a3137af20b7932727b436b5" translate="yes" xml:space="preserve">
          <source>Part III The OCaml tools</source>
          <target state="translated">파트 III OCaml 도구</target>
        </trans-unit>
        <trans-unit id="a29da75cd43003faab118a1eb6915f585144a3e6" translate="yes" xml:space="preserve">
          <source>Part IV The OCaml library</source>
          <target state="translated">파트 IV OCaml 라이브러리</target>
        </trans-unit>
        <trans-unit id="952bed16abbd7542df79c253d7d2a383bf3f6501" translate="yes" xml:space="preserve">
          <source>Part V Appendix</source>
          <target state="translated">파트 V 부록</target>
        </trans-unit>
        <trans-unit id="259899217f837489155c6afc61bda7baa0892067" translate="yes" xml:space="preserve">
          <source>Partial match: missing cases in pattern-matching.</source>
          <target state="translated">부분 일치 : 패턴 일치에서 케이스가 누락되었습니다.</target>
        </trans-unit>
        <trans-unit id="ae3a92949ce10ed0b574a754bc455be19981923a" translate="yes" xml:space="preserve">
          <source>Partially applied function: expression whose result has function type and is ignored.</source>
          <target state="translated">부분적으로 적용된 함수 : 결과에 함수 유형이 있고 무시되는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="122dc2b1a442a4492301d7cfaae94e0455545b63" translate="yes" xml:space="preserve">
          <source>Pass free variables via specialised arguments rather than closures (an optimisation for reducing allocation). See section &lt;a href=&quot;#ss%3Aflambda-unbox-closures&quot;&gt;21.9.3&lt;/a&gt;. This may have a small performance penalty.</source>
          <target state="translated">클로저가 아닌 특수 인수를 통해 자유 변수를 전달합니다 (할당을 줄이기위한 최적화). 섹션 &lt;a href=&quot;#ss%3Aflambda-unbox-closures&quot;&gt;21.9.3을&lt;/a&gt; 참조하십시오 . 이것은 약간의 성능 저하가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8139f1329d56ecac27be1fc05605291efd738915" translate="yes" xml:space="preserve">
          <source>Pass the -llibname option to the C linker when linking in &amp;ldquo;custom runtime&amp;rdquo; mode (see the -custom option). This causes the given C library to be linked with the program.</source>
          <target state="translated">&quot;사용자 지정 런타임&quot;모드에서 연결할 때 -llibname 옵션을 C 링커에 전달합니다 (-custom 옵션 참조). 이로 인해 주어진 C 라이브러리가 프로그램과 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="df106032363559c3f40628cbdd6ff4a26fa7fd35" translate="yes" xml:space="preserve">
          <source>Pass the -llibname option to the C linker when linking in &amp;ldquo;custom runtime&amp;rdquo; mode. See the corresponding option for ocamlc, in chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;.</source>
          <target state="translated">&quot;사용자 지정 런타임&quot;모드로 연결할 때 -llibname 옵션을 C 링커에 전달합니다. &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; 장의 ocamlc에 대한 해당 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ceed386065448933a097ec35067876966e85d14f" translate="yes" xml:space="preserve">
          <source>Pass the -llibname option to the linker . This causes the given C library to be linked with the program.</source>
          <target state="translated">-llibname 옵션을 링커에 전달합니다. 이로 인해 주어진 C 라이브러리가 프로그램과 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="a59af1bc11afda37b34f10079d3a9dec8ef0d8df" translate="yes" xml:space="preserve">
          <source>Pass the given option to the C compiler and linker, when linking in &amp;ldquo;custom runtime&amp;rdquo; mode. See the corresponding option for ocamlc, in chapter &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt;.</source>
          <target state="translated">&quot;사용자 지정 런타임&quot;모드에서 링크 할 때 주어진 옵션을 C 컴파일러 및 링커에 전달합니다. &lt;a href=&quot;comp#c%3Acamlc&quot;&gt;9&lt;/a&gt; 장의 ocamlc에 대한 해당 옵션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b35478fccd7fbafbf25aff91256c23a1c032cf84" translate="yes" xml:space="preserve">
          <source>Pass the given option to the C compiler and linker. For instance,-ccopt -Ldir causes the C linker to search for C libraries in directory dir.</source>
          <target state="translated">주어진 옵션을 C 컴파일러와 링커에 전달합니다. 예를 들어, -ccopt -Ldir은 C 링커가 dir 디렉토리에서 C 라이브러리를 검색하도록합니다.</target>
        </trans-unit>
        <trans-unit id="273a7a00d3bf42c46d56c858df14b11822928560" translate="yes" xml:space="preserve">
          <source>Pass the given option to the C compiler and linker. When linking in &amp;ldquo;custom runtime&amp;rdquo; mode, for instance-ccopt -Ldir causes the C linker to search for C libraries in directory dir.(See the -custom option.)</source>
          <target state="translated">주어진 옵션을 C 컴파일러와 링커에 전달합니다. &quot;사용자 정의 런타임&quot;모드에서 링크 할 때 instance-ccopt -Ldir을 사용하면 C 링커가 디렉토리 dir에서 C 라이브러리를 검색합니다 (-custom 옵션 참조).</target>
        </trans-unit>
        <trans-unit id="72dfe02cbb8cc21321b311387b88011ec8835c71" translate="yes" xml:space="preserve">
          <source>Pattern matching on an extensible variant type requires a default case to handle unknown variant constructors:</source>
          <target state="translated">확장 가능한 변형 유형에 대한 패턴 일치에는 알 수없는 변형 생성자를 처리하기위한 기본 케이스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="93c3d48bb09ccd90e9aae3bcf8d34d9478c3b2ab" translate="yes" xml:space="preserve">
          <source>Patterns are &lt;em&gt;linear&lt;/em&gt;: a variable cannot be bound several times by a given pattern. In particular, there is no way to test for equality between two parts of a data structure using only a pattern (but when guards can be used for this purpose).</source>
          <target state="translated">패턴은 &lt;em&gt;선형 적입니다&lt;/em&gt; . 변수는 주어진 패턴으로 여러 번 바인딩 될 수 없습니다. 특히, 패턴만을 사용하여 데이터 구조의 두 부분 사이의 동등성을 테스트 할 수있는 방법이 없습니다 (그러나 가드를이 목적으로 사용할 수있는 경우).</target>
        </trans-unit>
        <trans-unit id="e3abd39dc618aa8814823785a44aa53f573df633" translate="yes" xml:space="preserve">
          <source>Patterns are templates that allow selecting data structures of a given shape, and binding identifiers to components of the data structure. This selection operation is called pattern matching; its outcome is either &amp;ldquo;this value does not match this pattern&amp;rdquo;, or &amp;ldquo;this value matches this pattern, resulting in the following bindings of names to values&amp;rdquo;.</source>
          <target state="translated">패턴은 주어진 형태의 데이터 구조를 선택하고 식별자를 데이터 구조의 구성 요소에 바인딩 할 수있는 템플릿입니다. 이 선택 작업을 패턴 일치라고합니다. 결과는 &quot;이 값이이 패턴과 일치하지 않음&quot;또는 &quot;이 값이이 패턴과 일치하여 값에 대한 다음과 같은 이름 바인딩&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="7c689af30d05364792d515c0faaa88a9ab2da162" translate="yes" xml:space="preserve">
          <source>Perform a full major collection and compact the heap.</source>
          <target state="translated">전체 주요 수집을 수행하고 힙을 압축합니다.</target>
        </trans-unit>
        <trans-unit id="d3d568817e2f7ecd125459c14fd92de23c2c2e40" translate="yes" xml:space="preserve">
          <source>Perform a full major collection and compact the heap. Note that heap compaction is a lengthy operation.</source>
          <target state="translated">전체 주요 수집을 수행하고 힙을 압축합니다. 힙 압축은 긴 작업입니다.</target>
        </trans-unit>
        <trans-unit id="055dbe4520a583e58ae39a293f647d64d4770ec6" translate="yes" xml:space="preserve">
          <source>Perform a transitive reduction of the dependency graph before outputting the dot code. This can be useful if there are a lot of transitive dependencies that clutter the graph.</source>
          <target state="translated">도트 코드를 출력하기 전에 종속성 그래프의 전 이적 감소를 수행하십시오. 이는 그래프를 복잡하게 만드는 전 이적 종속성이 많은 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7a67fe1a67339dfb0ee43e9f1cd0038c969bd66" translate="yes" xml:space="preserve">
          <source>Perform even more optimisation than usual, possibly including unrolling of recursive functions. Compilation times may be significantly lengthened.</source>
          <target state="translated">재귀 함수 풀기를 포함하여 평소보다 훨씬 더 많은 최적화를 수행합니다. 컴파일 시간이 상당히 길어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b87d065999353ac9c7a4517b1177b42e5b1d7054" translate="yes" xml:space="preserve">
          <source>Perform more optimisation than usual. Compilation times may be lengthened. (This flag is an abbreviation for a certain set of parameters described in section &lt;a href=&quot;#s%3Aflambda-defaults&quot;&gt;21.5&lt;/a&gt;.)</source>
          <target state="translated">평소보다 더 많은 최적화를 수행하십시오. 컴파일 시간이 길어질 수 있습니다. (이 플래그는 섹션 &lt;a href=&quot;#s%3Aflambda-defaults&quot;&gt;21.5에&lt;/a&gt; 설명 된 특정 매개 변수 집합의 약어입니다 .)</target>
        </trans-unit>
        <trans-unit id="22610c9aaccb16a1bee9b7cee9dfb32918779ba0" translate="yes" xml:space="preserve">
          <source>Performance notice: values of type &lt;code&gt;int32&lt;/code&gt; occupy more memory space than values of type &lt;code&gt;int&lt;/code&gt;, and arithmetic operations on &lt;code&gt;int32&lt;/code&gt; are generally slower than those on &lt;code&gt;int&lt;/code&gt;. Use &lt;code&gt;int32&lt;/code&gt; only when the application requires exact 32-bit arithmetic.</source>
          <target state="translated">실적주의 사항 : 타입의 값 &lt;code&gt;int32&lt;/code&gt; 형의 값보다 더 많은 메모리 공간을 차지 &lt;code&gt;int&lt;/code&gt; 및 산술 연산 &lt;code&gt;int32&lt;/code&gt; 일반적으로 느린에 그보다 &lt;code&gt;int&lt;/code&gt; . 응용 프로그램에 정확한 32 비트 산술이 필요한 경우에만 &lt;code&gt;int32&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="662740b47a420ed740a0039a0fb0aa90dd4e339b" translate="yes" xml:space="preserve">
          <source>Performance notice: values of type &lt;code&gt;int64&lt;/code&gt; occupy more memory space than values of type &lt;code&gt;int&lt;/code&gt;, and arithmetic operations on &lt;code&gt;int64&lt;/code&gt; are generally slower than those on &lt;code&gt;int&lt;/code&gt;. Use &lt;code&gt;int64&lt;/code&gt; only when the application requires exact 64-bit arithmetic.</source>
          <target state="translated">실적주의 사항 : 타입의 값 &lt;code&gt;int64&lt;/code&gt; 형의 값보다 더 많은 메모리 공간을 차지 &lt;code&gt;int&lt;/code&gt; 및 산술 연산 &lt;code&gt;int64&lt;/code&gt; 일반적으로 느린에 그보다 &lt;code&gt;int&lt;/code&gt; . 응용 프로그램에 정확한 64 비트 산술이 필요한 경우에만 &lt;code&gt;int64&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9583bec530f000172f8c0f05a57970fabee45e7c" translate="yes" xml:space="preserve">
          <source>Performance notice: values of type &lt;code&gt;nativeint&lt;/code&gt; occupy more memory space than values of type &lt;code&gt;int&lt;/code&gt;, and arithmetic operations on &lt;code&gt;nativeint&lt;/code&gt; are generally slower than those on &lt;code&gt;int&lt;/code&gt;. Use &lt;code&gt;nativeint&lt;/code&gt; only when the application requires the extra bit of precision over the &lt;code&gt;int&lt;/code&gt; type.</source>
          <target state="translated">실적주의 사항 : 형의 값 &lt;code&gt;nativeint&lt;/code&gt; 로이 유형의 값보다 더 많은 메모리 공간을 차지 &lt;code&gt;int&lt;/code&gt; 및 산술 연산 &lt;code&gt;nativeint&lt;/code&gt; 로는 일반적으로 느린에 그보다 &lt;code&gt;int&lt;/code&gt; . 응용 프로그램에서 &lt;code&gt;int&lt;/code&gt; 유형에 대한 추가 정밀도가 필요한 경우에만 &lt;code&gt;nativeint&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="170a28a9db6d27d7212fc6dc249434a57517e7bc" translate="yes" xml:space="preserve">
          <source>Period</source>
          <target state="translated">Period</target>
        </trans-unit>
        <trans-unit id="d016004473e0e58d7682856755147e33256bb813" translate="yes" xml:space="preserve">
          <source>Permission denied</source>
          <target state="translated">권한이 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="ca053ed9d5deaad2a727eb5b9ce7480cd5b49c87" translate="yes" xml:space="preserve">
          <source>Permit sending of broadcast messages</source>
          <target state="translated">브로드 캐스트 메시지 전송 허용</target>
        </trans-unit>
        <trans-unit id="29e98f8d6c9356b9f9b3cb0dd0fac5d3d678c8e6" translate="yes" xml:space="preserve">
          <source>Physical equality test.</source>
          <target state="translated">물리적 평등 테스트.</target>
        </trans-unit>
        <trans-unit id="764dcc2a562c9da7446795d50aa77b7dbdc6bc96" translate="yes" xml:space="preserve">
          <source>Physical inequality test.</source>
          <target state="translated">물리적 불평등 테스트.</target>
        </trans-unit>
        <trans-unit id="9077104dc61ea39ed76dd5e6b7f00ad4f53b057c" translate="yes" xml:space="preserve">
          <source>Pipe abstract syntax trees through preprocessor command.</source>
          <target state="translated">전 처리기 명령을 통해 추상 구문 트리를 파이프합니다.</target>
        </trans-unit>
        <trans-unit id="258a386ac1d80ecc73cf9133d40fece735aa3f44" translate="yes" xml:space="preserve">
          <source>Pipe sources through preprocessor command.</source>
          <target state="translated">전 처리기 명령을 통해 소스를 파이프합니다.</target>
        </trans-unit>
        <trans-unit id="8c0094bdf1788f2095a6baf0ac9fd3dc283b5db4" translate="yes" xml:space="preserve">
          <source>Pipes and redirections</source>
          <target state="translated">파이프 및 리디렉션</target>
        </trans-unit>
        <trans-unit id="48afc6d396ff51a5ed35b5868fabdc57f1c9fb87" translate="yes" xml:space="preserve">
          <source>Pollable event</source>
          <target state="translated">Pollable 이벤트</target>
        </trans-unit>
        <trans-unit id="4044893229fcfc93927dd395fda2603f25cbf9b0" translate="yes" xml:space="preserve">
          <source>Polling</source>
          <target state="translated">Polling</target>
        </trans-unit>
        <trans-unit id="b87c82743d31a59fa081b4b5917f7e5fb9a91553" translate="yes" xml:space="preserve">
          <source>Polymorphic methods are called in exactly the same way as normal methods, but you should be aware of some limitations of type inference. Namely, a polymorphic method can only be called if its type is known at the call site. Otherwise, the method will be assumed to be monomorphic, and given an incompatible type.</source>
          <target state="translated">다형성 메서드는 일반 메서드와 똑같은 방식으로 호출되지만 유형 추론의 몇 가지 제한 사항을 알고 있어야합니다. 즉, 다형성 메서드는 호출 사이트에서 해당 유형을 알고있는 경우에만 호출 할 수 있습니다. 그렇지 않으면 메서드가 단형으로 간주되고 호환되지 않는 유형이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9825069b45f85b17a181b73e838bf2e21e0bf759" translate="yes" xml:space="preserve">
          <source>Polymorphic type annotations in let-definitions behave in a way similar to polymorphic methods:</source>
          <target state="translated">let-definitions의 다형성 유형 주석은 다형성 메서드와 유사한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="213691ff9b4dc02fdb3bf4a27f4eb612ef11f926" translate="yes" xml:space="preserve">
          <source>Polymorphic variant tags</source>
          <target state="translated">다형성 변형 태그</target>
        </trans-unit>
        <trans-unit id="22aa46a8a43e1108e30e6c20c787a6de9123751d" translate="yes" xml:space="preserve">
          <source>Polymorphic variant types describe the values a polymorphic variant may take.</source>
          <target state="translated">다형성 변형 유형은 다형성 변형이 취할 수있는 값을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2029098a5b14173ba88c69574469d4e0ce8f59cd" translate="yes" xml:space="preserve">
          <source>Polymorphic variants are an alternate form of variant values, not belonging explicitly to a predefined variant type, and following specific typing rules. They can be either constant, written `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;, or non-constant, written `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;(v).</source>
          <target state="translated">다형성 변형은 사전 정의 된 변형 유형에 명시 적으로 속하지 않고 특정 입력 규칙을 따르는 변형 값의 대체 형식입니다. 그것들은 상수, 쓰여진` &lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; , 또는 비상 수, 쓰여진` &lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; (v) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2610209437f25d35cbd42b41c775ccdcaf3af336" translate="yes" xml:space="preserve">
          <source>Position (in &lt;a href=&quot;sys#VALargv&quot;&gt;&lt;code&gt;Sys.argv&lt;/code&gt;&lt;/a&gt;) of the argument being processed.</source>
          <target state="translated">처리중인 인수의 위치 ( &lt;a href=&quot;sys#VALargv&quot;&gt; &lt;code&gt;Sys.argv&lt;/code&gt; &lt;/a&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="45f6ef1f36c845706de35765267136890ed1fd7c" translate="yes" xml:space="preserve">
          <source>Position (in &lt;a href=&quot;sys#VALargv&quot;&gt;&lt;code&gt;Sys.argv&lt;/code&gt;&lt;/a&gt;) of the argument being processed. You can change this value, e.g. to force &lt;a href=&quot;arg#VALparse&quot;&gt;&lt;code&gt;Arg.parse&lt;/code&gt;&lt;/a&gt; to skip some arguments. &lt;a href=&quot;arg#VALparse&quot;&gt;&lt;code&gt;Arg.parse&lt;/code&gt;&lt;/a&gt; uses the initial value of &lt;a href=&quot;arg#VALcurrent&quot;&gt;&lt;code&gt;Arg.current&lt;/code&gt;&lt;/a&gt; as the index of argument 0 (the program name) and starts parsing arguments at the next element.</source>
          <target state="translated">처리중인 인수의 위치 ( &lt;a href=&quot;sys#VALargv&quot;&gt; &lt;code&gt;Sys.argv&lt;/code&gt; &lt;/a&gt; )입니다. 이 값을 변경할 수 있습니다. 예를 들어 &lt;a href=&quot;arg#VALparse&quot;&gt; &lt;code&gt;Arg.parse&lt;/code&gt; &lt;/a&gt; 가 일부 인수를 건너 뛰 도록 할 수 있습니다 . &lt;a href=&quot;arg#VALparse&quot;&gt; &lt;code&gt;Arg.parse&lt;/code&gt; 는&lt;/a&gt; 의 초기 값을 사용 &lt;a href=&quot;arg#VALcurrent&quot;&gt; &lt;code&gt;Arg.current&lt;/code&gt; &lt;/a&gt; 인수 0 (프로그램 명) 및 다음 요소에 인자를 분석 개시의 지표로한다.</target>
        </trans-unit>
        <trans-unit id="48fd514253c1577755278adb384c498032582797" translate="yes" xml:space="preserve">
          <source>Position tracking mode works as follows. At each token, the lexing engine will copy &lt;code&gt;lex_curr_p&lt;/code&gt; to &lt;code&gt;lex_start_p&lt;/code&gt;, then change the &lt;code&gt;pos_cnum&lt;/code&gt; field of &lt;code&gt;lex_curr_p&lt;/code&gt; by updating it with the number of characters read since the start of the &lt;code&gt;lexbuf&lt;/code&gt;. The other fields are left unchanged by the lexing engine. In order to keep them accurate, they must be initialised before the first use of the lexbuf, and updated by the relevant lexer actions (i.e. at each end of line -- see also &lt;code&gt;new_line&lt;/code&gt;).</source>
          <target state="translated">위치 추적 모드는 다음과 같이 작동합니다. 각 토큰에, 렉싱 엔진은 복사합니다 &lt;code&gt;lex_curr_p&lt;/code&gt; 에 &lt;code&gt;lex_start_p&lt;/code&gt; 다음, 변경 &lt;code&gt;pos_cnum&lt;/code&gt; 의 분야 &lt;code&gt;lex_curr_p&lt;/code&gt; 을 의 시작부터 읽을 문자의 수를 업데이트하여 &lt;code&gt;lexbuf&lt;/code&gt; . 다른 필드는 렉싱 엔진에 의해 변경되지 않습니다. 정확하게 유지하려면 lexbuf를 처음 사용하기 전에 초기화해야하며 관련 렉서 액션으로 업데이트해야합니다 (즉, 줄의 각 끝에서 &lt;code&gt;new_line&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="d2013d98249e5e8bcfd7d895cc29b28e763b3a92" translate="yes" xml:space="preserve">
          <source>Positioning modes for &lt;a href=&quot;unix#VALlseek&quot;&gt;&lt;code&gt;Unix.lseek&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALlseek&quot;&gt; &lt;code&gt;Unix.lseek&lt;/code&gt; 의&lt;/a&gt; 위치 지정 모드 .</target>
        </trans-unit>
        <trans-unit id="22c07ff7a6172b892fe2ca9c53ec2061c8855ce1" translate="yes" xml:space="preserve">
          <source>Positioning modes for &lt;a href=&quot;unixlabels#VALlseek&quot;&gt;&lt;code&gt;UnixLabels.lseek&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALlseek&quot;&gt; &lt;code&gt;UnixLabels.lseek&lt;/code&gt; 의&lt;/a&gt; 위치 지정 모드 .</target>
        </trans-unit>
        <trans-unit id="cd4683fadf7005eca07e4d6267ddbb19ebcb91fa" translate="yes" xml:space="preserve">
          <source>Positions</source>
          <target state="translated">Positions</target>
        </trans-unit>
        <trans-unit id="653a3645251575bf9279abc23fa56dfc34058739" translate="yes" xml:space="preserve">
          <source>Positive infinity.</source>
          <target state="translated">양의 무한대.</target>
        </trans-unit>
        <trans-unit id="f86a729c53a1915ca3654adc8aae51c101d917df" translate="yes" xml:space="preserve">
          <source>Power function.</source>
          <target state="translated">파워 함수.</target>
        </trans-unit>
        <trans-unit id="8fbbe41e74c44588da3a875aa227d393b9e7e864" translate="yes" xml:space="preserve">
          <source>Power function. &lt;code&gt;pow&amp;nbsp;z1&amp;nbsp;z2&lt;/code&gt; returns &lt;code&gt;z1&lt;/code&gt; to the &lt;code&gt;z2&lt;/code&gt; power.</source>
          <target state="translated">파워 함수. &lt;code&gt;pow&amp;nbsp;z1&amp;nbsp;z2&lt;/code&gt; 는 &lt;code&gt;z1&lt;/code&gt; 의 &lt;code&gt;z2&lt;/code&gt; 거듭 제곱 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5789da79b475d584d15053c8dde659f5c24e3de1" translate="yes" xml:space="preserve">
          <source>Precedence level and associativity of operators</source>
          <target state="translated">연산자의 우선 순위 및 연관성</target>
        </trans-unit>
        <trans-unit id="ef8a0e66b4c1574357482510c167de122caee2aa" translate="yes" xml:space="preserve">
          <source>Predecessor.</source>
          <target state="translated">Predecessor.</target>
        </trans-unit>
        <trans-unit id="b3d4df1b4fc8bba29600c89de44c71635c187145" translate="yes" xml:space="preserve">
          <source>Predecessor. &lt;code&gt;Int32.pred&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Int32.sub&amp;nbsp;x&amp;nbsp;Int32.one&lt;/code&gt;.</source>
          <target state="translated">전임자. &lt;code&gt;Int32.pred&amp;nbsp;x&lt;/code&gt; 는 &lt;code&gt;Int32.sub&amp;nbsp;x&amp;nbsp;Int32.one&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a365fc68958b3868521e16be1f99a37de6553c7a" translate="yes" xml:space="preserve">
          <source>Predecessor. &lt;code&gt;Int64.pred&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Int64.sub&amp;nbsp;x&amp;nbsp;Int64.one&lt;/code&gt;.</source>
          <target state="translated">전임자. &lt;code&gt;Int64.pred&amp;nbsp;x&lt;/code&gt; 는 &lt;code&gt;Int64.sub&amp;nbsp;x&amp;nbsp;Int64.one&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3760cb7859c8cbaa586b1b23829a81faa04f5005" translate="yes" xml:space="preserve">
          <source>Predecessor. &lt;code&gt;Nativeint.pred&amp;nbsp;x&lt;/code&gt; is &lt;code&gt;Nativeint.sub&amp;nbsp;x&amp;nbsp;Nativeint.one&lt;/code&gt;.</source>
          <target state="translated">전임자. &lt;code&gt;Nativeint.pred&amp;nbsp;x&lt;/code&gt; 는 &lt;code&gt;Nativeint.sub&amp;nbsp;x&amp;nbsp;Nativeint.one&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a72b78329d76d9323072a7e5e631c531e356e518" translate="yes" xml:space="preserve">
          <source>Predefined data structures include tuples, arrays, and lists. There are also general mechanisms for defining your own data structures, such as records and variants, which will be covered in more detail later; for now, we concentrate on lists. Lists are either given in extension as a bracketed list of semicolon-separated elements, or built from the empty list [] (pronounce &amp;ldquo;nil&amp;rdquo;) by adding elements in front using the :: (&amp;ldquo;cons&amp;rdquo;) operator.</source>
          <target state="translated">미리 정의 된 데이터 구조에는 튜플, 배열 및 목록이 포함됩니다. 레코드 및 변형과 같은 고유 한 데이터 구조를 정의하는 일반적인 메커니즘도 있습니다. 이에 대해서는 나중에 자세히 설명합니다. 지금은 목록에 집중합니다. 목록은 세미콜론으로 구분 된 요소의 대괄호 목록으로 확장에 제공되거나 : :( &quot;cons&quot;) 연산자를 사용하여 앞에 요소를 추가하여 빈 목록 [] ( &quot;nil&quot;로 발음)에서 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="2d1410f8fbd254f890a3355e9bcb2305c86175f5" translate="yes" xml:space="preserve">
          <source>Predefined parsers</source>
          <target state="translated">사전 정의 된 파서</target>
        </trans-unit>
        <trans-unit id="1f3e08e9e6eb753141109ff66d4be4a3ea38babd" translate="yes" xml:space="preserve">
          <source>Predicates and comparisons</source>
          <target state="translated">술어와 비교</target>
        </trans-unit>
        <trans-unit id="90eceb016c51a762f15c7287008c113f6f37296c" translate="yes" xml:space="preserve">
          <source>Prefix</source>
          <target state="translated">Prefix</target>
        </trans-unit>
        <trans-unit id="a46adfa85b9e12a0f2b4120e9bc73717dcfc0bd1" translate="yes" xml:space="preserve">
          <source>Preprocessor warning.</source>
          <target state="translated">전 처리기 경고.</target>
        </trans-unit>
        <trans-unit id="9d8c2216bf58d48c75b9b44385be2473949e9115" translate="yes" xml:space="preserve">
          <source>Preprocessors that generate OCaml source code can insert line number directives in their output so that error messages produced by the compiler contain line numbers and file names referring to the source file before preprocessing, instead of after preprocessing. A line number directive is composed of a # (sharp sign), followed by a positive integer (the source line number), optionally followed by a character string (the source file name). Line number directives are treated as blanks during lexical analysis.</source>
          <target state="translated">OCaml 소스 코드를 생성하는 전처리 기는 출력에 줄 번호 지시문을 삽입 할 수 있으므로 컴파일러에서 생성 한 오류 메시지에는 전처리 후가 아니라 전처리 전에 소스 파일을 참조하는 줄 번호와 파일 이름이 포함됩니다. 행 번호 지시문은 # (날카로운 기호), 양의 정수 (소스 행 번호), 선택적으로 뒤에 문자열 (소스 파일 이름)으로 구성됩니다. 줄 번호 지시문은 어휘 분석 중에 공백으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="bace76147e38ae19d3a0c11609fc9d38e774f7e8" translate="yes" xml:space="preserve">
          <source>Pretty-printing</source>
          <target state="translated">Pretty-printing</target>
        </trans-unit>
        <trans-unit id="1cccabcdd6a358d979939998cc033a04308c5cf5" translate="yes" xml:space="preserve">
          <source>Pretty-printing boxes</source>
          <target state="translated">예쁜 인쇄 상자</target>
        </trans-unit>
        <trans-unit id="b2a4462f39466982126a74de486bca0779a059f3" translate="yes" xml:space="preserve">
          <source>Pretty-printing termination</source>
          <target state="translated">예쁜 인쇄 종료</target>
        </trans-unit>
        <trans-unit id="fb3bd5a8a477c68713e4b63b07bf86de7633d445" translate="yes" xml:space="preserve">
          <source>Pretty-printing.</source>
          <target state="translated">Pretty-printing.</target>
        </trans-unit>
        <trans-unit id="8dc354dacf2179400fda256bb8b5273768f4fa0d" translate="yes" xml:space="preserve">
          <source>Primitives with several arguments are always curried. The C function does not necessarily have the same name as the ML function.</source>
          <target state="translated">몇 가지 인수가있는 프리미티브는 항상 카레 처리됩니다. C 함수는 반드시 ML 함수와 이름이 같을 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4927a230a7393e58f700f3b895b9a8e2141e1502" translate="yes" xml:space="preserve">
          <source>Print a boolean in the current pretty-printing box.</source>
          <target state="translated">현재 예쁜 인쇄 상자에 부울을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="429be0de1bf187c6aed029fd0f262066cde03fe6" translate="yes" xml:space="preserve">
          <source>Print a byte sequence on standard error.</source>
          <target state="translated">표준 오류에 대한 바이트 시퀀스를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="c9b40235213e3b9b233db12ee353ee4db3cf9b5e" translate="yes" xml:space="preserve">
          <source>Print a byte sequence on standard output.</source>
          <target state="translated">표준 출력에 바이트 시퀀스를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="a6c581c84ffe95bc9ceacf3ea66bdfc3a0500bac" translate="yes" xml:space="preserve">
          <source>Print a character in the current pretty-printing box.</source>
          <target state="translated">현재 예쁜 인쇄 상자에 문자를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="af319c36a4f3c8916104f4d0b89b33a561567553" translate="yes" xml:space="preserve">
          <source>Print a character on standard error.</source>
          <target state="translated">표준 오류에 문자를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="26d52b245107b56716114cb4df780a3991c94880" translate="yes" xml:space="preserve">
          <source>Print a character on standard output.</source>
          <target state="translated">표준 출력에 문자를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="3800dc392ff64d7282401e28ec9718d894a98136" translate="yes" xml:space="preserve">
          <source>Print a floating point number in the current pretty-printing box.</source>
          <target state="translated">현재 예쁜 인쇄 상자에 부동 소수점 숫자를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="d1d3361cbb609b643a25135cfa13aaa39fdd8216" translate="yes" xml:space="preserve">
          <source>Print a floating-point number, in decimal, on standard error.</source>
          <target state="translated">표준 오류에 부동 소수점 숫자를 10 진수로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="1f593ed3a39b6bcdd833537c6e2868f7d6bbca3c" translate="yes" xml:space="preserve">
          <source>Print a floating-point number, in decimal, on standard output.</source>
          <target state="translated">표준 출력에 부동 소수점 숫자를 10 진수로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="d6af9922bfeade8a893e020a9b67b642c05b2584" translate="yes" xml:space="preserve">
          <source>Print a list of checkpoints.</source>
          <target state="translated">체크 포인트 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="87b79eb900647a5ec2eb44f25634fcf150fb96e4" translate="yes" xml:space="preserve">
          <source>Print a newline character on standard error, and flush standard error.</source>
          <target state="translated">표준 오류에 개행 문자를 인쇄하고 표준 오류를 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="d02b6c71fe25d1c006f404421e4a18e508b909cb" translate="yes" xml:space="preserve">
          <source>Print a newline character on standard output, and flush standard output.</source>
          <target state="translated">표준 출력에 개행 문자를 인쇄하고 표준 출력을 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="51802e08b4337c0255ed47927f1d410b8ef886cb" translate="yes" xml:space="preserve">
          <source>Print a newline character on standard output, and flush standard output. This can be used to simulate line buffering of standard output.</source>
          <target state="translated">표준 출력에 개행 문자를 인쇄하고 표준 출력을 플러시합니다. 이것은 표준 출력의 라인 버퍼링을 시뮬레이션하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57b23be15f00e2b2a766ad074fcad3032022f804" translate="yes" xml:space="preserve">
          <source>Print a raw backtrace in the same format &lt;code&gt;Printexc.print_backtrace&lt;/code&gt; uses.</source>
          <target state="translated">&lt;code&gt;Printexc.print_backtrace&lt;/code&gt; 가 사용 하는 것과 동일한 형식으로 원시 역 추적을 인쇄 합니다.</target>
        </trans-unit>
        <trans-unit id="c59315f70ac13c50e613039426e9b1da6c2b46f5" translate="yes" xml:space="preserve">
          <source>Print a string on standard error.</source>
          <target state="translated">표준 오류에 문자열을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="81468c7ebab1c5a01e13d71f20b9d3f79ab019c7" translate="yes" xml:space="preserve">
          <source>Print a string on standard output.</source>
          <target state="translated">표준 출력에 문자열을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="239e667539d760b95fb67e7af2b14556bf1672e4" translate="yes" xml:space="preserve">
          <source>Print a string, followed by a newline character on standard error and flush standard error.</source>
          <target state="translated">문자열을 인쇄 한 다음 표준 오류에 대한 개행 문자를 인쇄하고 표준 오류를 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="b8454715c8134bb32c9d0b6d5fbc4e1e14a1d87c" translate="yes" xml:space="preserve">
          <source>Print a string, followed by a newline character, on standard output and flush standard output.</source>
          <target state="translated">표준 출력에 문자열과 개행 문자를 인쇄하고 표준 출력을 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="aea61c3ac5c7b0566ed5cae1ecfdd4c2c861ba39" translate="yes" xml:space="preserve">
          <source>Print all external commands before they are executed, Useful to debug C library problems.</source>
          <target state="translated">실행하기 전에 모든 외부 명령을 인쇄합니다. C 라이브러리 문제를 디버그하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7a899efa55e1195ca5fc1dec39f5ecdae93ca337" translate="yes" xml:space="preserve">
          <source>Print all external commands before they are executed, in particular invocations of the C compiler and linker in -custom mode. Useful to debug C library problems.</source>
          <target state="translated">실행하기 전에 모든 외부 명령, 특히 -custom 모드의 C 컴파일러 및 링커 호출을 인쇄합니다. C 라이브러리 문제를 디버그하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ba058a59bfe6821df26150e86333708758eaa075" translate="yes" xml:space="preserve">
          <source>Print all external commands before they are executed, in particular invocations of the assembler, C compiler, and linker. Useful to debug C library problems.</source>
          <target state="translated">특히 어셈블러, C 컴파일러 및 링커 호출과 같이 실행되기 전에 모든 외부 명령을 인쇄하십시오. C 라이브러리 문제를 디버그하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b5f2c30cc981864c89d951572dd7385b78870825" translate="yes" xml:space="preserve">
          <source>Print an integer in the current pretty-printing box.</source>
          <target state="translated">현재 예쁜 인쇄 상자에 정수를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="7301d26fde81fa8ebca08848cc545bc293615fb7" translate="yes" xml:space="preserve">
          <source>Print an integer, in decimal, on standard error.</source>
          <target state="translated">표준 오류에 10 진수로 정수를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="a65bdad25891620217c526a1bfe2956ce94697a0" translate="yes" xml:space="preserve">
          <source>Print an integer, in decimal, on standard output.</source>
          <target state="translated">표준 출력에 10 진수로 정수를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="9fd336c14b87ef3c0b1b68245b3a09479680e247" translate="yes" xml:space="preserve">
          <source>Print short version number and exit.</source>
          <target state="translated">짧은 버전 번호를 인쇄하고 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="a0d0598affdc572bce9de228afda6b8df92c487b" translate="yes" xml:space="preserve">
          <source>Print the call stack. This is useful to see which sequence of function calls led to the currently executing frame. With a positive argument, print only the innermost count frames. With a negative argument, print only the outermost -count frames.</source>
          <target state="translated">호출 스택을 인쇄합니다. 이것은 현재 실행중인 프레임으로 이어진 함수 호출 시퀀스를 확인하는 데 유용합니다. 양수 인수를 사용하면 가장 안쪽에있는 카운트 프레임 만 인쇄합니다. 음수 인수를 사용하면 가장 바깥쪽에있는 -count 프레임 만 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="ebc9d9bde218642565c4a6b872c662229c0a649a" translate="yes" xml:space="preserve">
          <source>Print the current values of the memory management counters (in human-readable form) into the channel argument.</source>
          <target state="translated">메모리 관리 카운터의 현재 값 (사람이 읽을 수있는 형식)을 채널 인수에 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="dc013ee29b9caea327ae49687d5fe8992469fe80" translate="yes" xml:space="preserve">
          <source>Print the list of all breakpoints.</source>
          <target state="translated">모든 중단 점 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="1d6309cbc48bcf93fb84c3b2d1628070ff67c985" translate="yes" xml:space="preserve">
          <source>Print the list of commands.</source>
          <target state="translated">명령 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="605058b80e7766b1d24469032cba6edad61bd169" translate="yes" xml:space="preserve">
          <source>Print the list of events in the given module (the current module, by default).</source>
          <target state="translated">주어진 모듈 (기본적으로 현재 모듈)의 이벤트 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="d77e8c1c85630588cf87f0de278c43bd22bba915" translate="yes" xml:space="preserve">
          <source>Print the location of the standard library, then exit.</source>
          <target state="translated">표준 라이브러리의 위치를 ​​인쇄 한 다음 종료합니다.</target>
        </trans-unit>
        <trans-unit id="7a63cdf9922cb9019770831699ca2ec88440cd9f" translate="yes" xml:space="preserve">
          <source>Print the magic number expected by this version of the runtime and exit.</source>
          <target state="translated">이 버전의 런타임에서 예상하는 매직 넘버를 인쇄하고 종료합니다.</target>
        </trans-unit>
        <trans-unit id="2e3ef87917612025838d457d0180249b2e9da839" translate="yes" xml:space="preserve">
          <source>Print the magic number of the bytecode executable given as argument and exit.</source>
          <target state="translated">인수로 주어진 실행 파일 바이트 코드의 매직 넘버를 인쇄하고 종료합니다.</target>
        </trans-unit>
        <trans-unit id="c72d9d8cbad237171877aaaf4f221e80c28b652a" translate="yes" xml:space="preserve">
          <source>Print the names of the primitives known to this version of ocamlrun and exit.</source>
          <target state="translated">이 버전의 ocamlrun에 알려진 기본 형식의 이름을 인쇄하고 종료합니다.</target>
        </trans-unit>
        <trans-unit id="451ad6ffbbc59e311404fa1ba33469fe44332e2f" translate="yes" xml:space="preserve">
          <source>Print the signature of the corresponding component.</source>
          <target state="translated">해당 구성 요소의 서명을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="ac80a952e8e6f2080883594473fea6bc18893d21" translate="yes" xml:space="preserve">
          <source>Print the signatures of components with name ident in all the above categories.</source>
          <target state="translated">위의 모든 범주에서 이름이 ident 인 구성 요소의 서명을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="d5306c346b09fa982bbe727b7d468447dd3c8b02" translate="yes" xml:space="preserve">
          <source>Print the value of a specific configuration variable from the -config output, then exit. If the variable does not exist, the exit code is non-zero. This option is only available since OCaml 4.08, so script authors should have a fallback for older versions.</source>
          <target state="translated">-config 출력에서 ​​특정 구성 변수의 값을 인쇄 한 다음 종료합니다. 변수가 없으면 종료 코드는 0이 아닙니다. 이 옵션은 OCaml 4.08 이후에만 사용할 수 있으므로 스크립트 작성자는 이전 버전에 대한 대체를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="e07a93c8767c3a47dc5d7c8df32e7ea1d844894b" translate="yes" xml:space="preserve">
          <source>Print the value of the debugger variable variable.</source>
          <target state="translated">디버거 변수 변수의 값을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="c95223754157223c4209b46470cc23e01254d61f" translate="yes" xml:space="preserve">
          <source>Print the values of the given variables. print can be abbreviated as p.</source>
          <target state="translated">주어진 변수의 값을 인쇄합니다. print는 p로 축약 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eeec5e23ff4ea21114a2bb9f163e9c3c32699c18" translate="yes" xml:space="preserve">
          <source>Print the version number of ocamlc and a detailed summary of its configuration, then exit.</source>
          <target state="translated">ocamlc의 버전 번호와 구성에 대한 자세한 요약을 인쇄 한 다음 종료합니다.</target>
        </trans-unit>
        <trans-unit id="f991152ef21a1e26c709ecfc065e65ac98aa7ae9" translate="yes" xml:space="preserve">
          <source>Print the version number of ocamlopt and a detailed summary of its configuration, then exit.</source>
          <target state="translated">ocamlopt의 버전 번호와 구성에 대한 자세한 요약을 인쇄 한 다음 종료합니다.</target>
        </trans-unit>
        <trans-unit id="debb51048032a6428ea36a4a0ee08b746d4a77db" translate="yes" xml:space="preserve">
          <source>Print the version number of the compiler and the location of the standard library directory, then exit.</source>
          <target state="translated">컴파일러의 버전 번호와 표준 라이브러리 디렉토리의 위치를 ​​인쇄 한 다음 종료합니다.</target>
        </trans-unit>
        <trans-unit id="2fe4aaf2f5e45563655a656455ed20e66a1462f4" translate="yes" xml:space="preserve">
          <source>Print the version number of the compiler in short form (e.g. 3.11.0), then exit.</source>
          <target state="translated">컴파일러의 버전 번호를 짧은 형식 (예 : 3.11.0)으로 인쇄 한 다음 종료합니다.</target>
        </trans-unit>
        <trans-unit id="6f76b94e10000b8d214946bc7f1bda961d7f3c84" translate="yes" xml:space="preserve">
          <source>Print the working directory for ocamldebug.</source>
          <target state="translated">ocamldebug의 작업 디렉토리를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="d9213c853b1c42118f3c94b86c97afa5e9fd9869" translate="yes" xml:space="preserve">
          <source>Print version string and exit.</source>
          <target state="translated">버전 문자열을 인쇄하고 종료합니다.</target>
        </trans-unit>
        <trans-unit id="4e959478171465cf9e996cbfb9a74d21f6548b19" translate="yes" xml:space="preserve">
          <source>Printexc</source>
          <target state="translated">Printexc</target>
        </trans-unit>
        <trans-unit id="49c6710eb43a270c0d99f60d369594f6b1f09d42" translate="yes" xml:space="preserve">
          <source>Printf</source>
          <target state="translated">Printf</target>
        </trans-unit>
        <trans-unit id="2d9a110ab864d8027d59b85870bd7507b21f2b32" translate="yes" xml:space="preserve">
          <source>Prints a list of all available directives, with corresponding argument type if appropriate.</source>
          <target state="translated">해당하는 경우 해당 인수 유형과 함께 사용 가능한 모든 지시문 목록을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="3d0169f16c8bbedbeb3705f057d992b36bb4c783" translate="yes" xml:space="preserve">
          <source>Prior to OCaml 4.06, there were a number of restrictions: one could only remove types and modules at the outermost level (not inside submodules), and in the case of with type the definition had to be another type constructor with the same type parameters.</source>
          <target state="translated">OCaml 4.06 이전에는 몇 가지 제한 사항이있었습니다. 하나는 가장 바깥 쪽 수준 (하위 모듈 내부가 아님)에서만 유형과 모듈을 제거 할 수 있었으며 유형이있는 경우 정의는 동일한 유형 매개 변수를 가진 다른 유형 생성자 여야했습니다.</target>
        </trans-unit>
        <trans-unit id="994eb8f645a2e271bf1f8673e4483c670cc953a0" translate="yes" xml:space="preserve">
          <source>Private method made public implicitly.</source>
          <target state="translated">암시 적으로 공개 된 Private 메서드.</target>
        </trans-unit>
        <trans-unit id="165156bef8f5f2f887c0fff1c8cc018aec48829d" translate="yes" xml:space="preserve">
          <source>Private methods are inherited (they are by default visible in subclasses), unless they are hidden by signature matching, as described below.</source>
          <target state="translated">아래에 설명 된대로 서명 일치에 의해 숨겨지지 않는 한 개인 메서드는 상속됩니다 (기본적으로 하위 클래스에서 표시됨).</target>
        </trans-unit>
        <trans-unit id="6e9361563af3076dde9f52a56836232ccfd3da4f" translate="yes" xml:space="preserve">
          <source>Private methods are methods that do not appear in object interfaces. They can only be invoked from other methods of the same object.</source>
          <target state="translated">전용 메서드는 개체 인터페이스에 나타나지 않는 메서드입니다. 동일한 개체의 다른 메서드에서만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5e7b644834b86be6fc64d7be1a52e0d85f180ab" translate="yes" xml:space="preserve">
          <source>Private methods can be made public in a subclass.</source>
          <target state="translated">개인 메서드는 하위 클래스에서 공용으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c59d88954e8cc2ecd75753618fa9214f76b159d" translate="yes" xml:space="preserve">
          <source>Private row types are type abbreviations where part of the structure of the type is left abstract. Concretely &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; in the above should denote either an object type or a polymorphic variant type, with some possibility of refinement left. If the private declaration is used in an interface, the corresponding implementation may either provide a ground instance, or a refined private type.</source>
          <target state="translated">개인용 행 유형은 유형 구조의 일부가 추상적 인 유형 약어입니다. 구체적으로 위의 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; 은 개체 유형 또는 다형성 변형 유형을 나타내야하며 약간의 개선 가능성이 남아 있습니다. 인터페이스에서 private 선언이 사용되는 경우 해당 구현은 접지 인스턴스 또는 정제 된 개인 유형을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb686dcfd0b69cd31f6a449daa606192aede292e" translate="yes" xml:space="preserve">
          <source>Private type declarations in module signatures, of the form type t = private ..., enable libraries to reveal some, but not all aspects of the implementation of a type to clients of the library. In this respect, they strike a middle ground between abstract type declarations, where no information is revealed on the type implementation, and data type definitions and type abbreviations, where all aspects of the type implementation are publicized. Private type declarations come in three flavors: for variant and record types (section &lt;a href=&quot;#ss%3Aprivate-types-variant&quot;&gt;8.3.1&lt;/a&gt;), for type abbreviations (section &lt;a href=&quot;#ss%3Aprivate-types-abbrev&quot;&gt;8.3.2&lt;/a&gt;), and for row types (section &lt;a href=&quot;#ss%3Aprivate-rows&quot;&gt;8.3.3&lt;/a&gt;).</source>
          <target state="translated">유형 t = private ... 형식의 모듈 시그니처에있는 개인 유형 선언을 사용하면 라이브러리가 유형 구현의 일부 측면을 표시 할 수 있지만 모든 측면을 라이브러리 클라이언트에 표시 할 수 있습니다. 이 점에서, 그들은 유형 구현에 대한 정보가 공개되지 않는 추상 유형 선언과 유형 구현의 모든 측면이 공개되는 데이터 유형 정의 및 유형 약어 사이의 중간 지점을 차지합니다. 개인 유형 선언은 변형 및 레코드 유형 (섹션 &lt;a href=&quot;#ss%3Aprivate-types-variant&quot;&gt;8.3.1&lt;/a&gt; ), 유형 약어 (섹션 &lt;a href=&quot;#ss%3Aprivate-types-abbrev&quot;&gt;8.3.2&lt;/a&gt; ) 및 행 유형 (섹션 &lt;a href=&quot;#ss%3Aprivate-rows&quot;&gt;8.3.3&lt;/a&gt; )의 세 가지 유형으로 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="59b94c84bf3c7510e8be0728f720ae8fe7ce120f" translate="yes" xml:space="preserve">
          <source>Process file as a .ml file.</source>
          <target state="translated">파일을 .ml 파일로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="2522d3db6f5a48e899f57863a3c7250dfc54b325" translate="yes" xml:space="preserve">
          <source>Process file as a .mli file.</source>
          <target state="translated">파일을 .mli 파일로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="473f55eac53bc8ce93f412c1c946aa28996d5086" translate="yes" xml:space="preserve">
          <source>Process file as a file name, even if it starts with a dash (-) character.</source>
          <target state="translated">대시 (-) 문자로 시작하는 경우에도 파일을 파일 이름으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="fd5dbcb4f5b812065ae1369a8e3dde027c4b2109" translate="yes" xml:space="preserve">
          <source>Process file as the grammar specification, even if its name starts with a dash (-) character. This option must be the last on the command line.</source>
          <target state="translated">파일 이름이 대시 (-) 문자로 시작하는 경우에도 파일을 문법 사양으로 처리합니다. 이 옵션은 명령 줄에서 마지막 옵션이어야합니다.</target>
        </trans-unit>
        <trans-unit id="0588b71974aef4ab5b2e1fdf75767f0460174967" translate="yes" xml:space="preserve">
          <source>Process handling</source>
          <target state="translated">프로세스 처리</target>
        </trans-unit>
        <trans-unit id="f7450c7a1b38c58c319dbbe91b6f643f07f53490" translate="yes" xml:space="preserve">
          <source>Process the file filename as a text file, even if its extension is not .txt.</source>
          <target state="translated">확장자가 .txt가 아니더라도 파일 이름을 텍스트 파일로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="15640d84a678dcf20fe0f7b4064e40aca256536e" translate="yes" xml:space="preserve">
          <source>Process the file filename as an implementation file, even if its extension is not .ml.</source>
          <target state="translated">확장자가 .ml이 아니더라도 파일 filename을 구현 파일로 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="34a335c98c4d1d8038830a8a0365142ca983d65b" translate="yes" xml:space="preserve">
          <source>Process the file filename as an interface file, even if its extension is not .mli.</source>
          <target state="translated">확장자가 .mli가 아니더라도 파일 이름을 인터페이스 파일로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="968e872ce419fcfe72f51852dada13fcf08024c1" translate="yes" xml:space="preserve">
          <source>Processor-native integers.</source>
          <target state="translated">프로세서 고유 정수.</target>
        </trans-unit>
        <trans-unit id="b4186ada56824b293fd62da84a86d8573ac62f45" translate="yes" xml:space="preserve">
          <source>Profiling interrupt</source>
          <target state="translated">인터럽트 프로파일 링</target>
        </trans-unit>
        <trans-unit id="a6ea8abb2d5aee6b3ffd36cd9d01f1bea2305efb" translate="yes" xml:space="preserve">
          <source>Profiling of a program's space behaviour over time.</source>
          <target state="translated">시간 경과에 따른 프로그램의 공간 동작 프로파일 링.</target>
        </trans-unit>
        <trans-unit id="6ef3f3bc4c4c8078545ca3c591413a9d5b343787" translate="yes" xml:space="preserve">
          <source>Profiling of a program's space behaviour over time. Currently only supported on x86-64 platforms running 64-bit code.</source>
          <target state="translated">시간 경과에 따른 프로그램의 공간 동작 프로파일 링. 현재 64 비트 코드를 실행하는 x86-64 플랫폼에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="723b0e2b1580f96f4e037bd5029db086fd9ab217" translate="yes" xml:space="preserve">
          <source>Profiling with ocamlprof only records execution counts, not the actual time spent within each function. There is currently no way to perform time profiling on bytecode programs generated by ocamlc. For time profiling of native code, users are recommended to use standard tools such as perf (on Linux), Instruments (on macOS) and DTrace. Profiling with gprof is no longer supported.</source>
          <target state="translated">ocamlprof를 사용한 프로파일 링은 각 함수 내에서 소요 된 실제 시간이 아닌 실행 횟수 만 기록합니다. 현재 ocamlc에 의해 생성 된 바이트 코드 프로그램에서 시간 프로파일 링을 수행 할 수있는 방법이 없습니다. 네이티브 코드의 시간 프로파일 링을 위해 사용자는 perf (Linux), Instruments (macOS) 및 DTrace와 같은 표준 도구를 사용하는 것이 좋습니다. gprof를 사용한 프로파일 링은 더 이상 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d68007b0763cb230f9034ec96f52b39d03ad630" translate="yes" xml:space="preserve">
          <source>Program</source>
          <target state="translated">Program</target>
        </trans-unit>
        <trans-unit id="bd74641b834d4b980ea6b99d6f71d4205f5d04af" translate="yes" xml:space="preserve">
          <source>Program termination</source>
          <target state="translated">프로그램 종료</target>
        </trans-unit>
        <trans-unit id="6b2d4e1f190973fd4686a60486cb7a38ca6a26aa" translate="yes" xml:space="preserve">
          <source>Programmers which come to rely on the internal API for a use-case which they find realistic and useful are encouraged to open a request for improvement on the bug tracker.</source>
          <target state="translated">현실적이고 유용하다고 판단되는 사용 사례에 대해 내부 API에 의존하게 된 프로그래머는 버그 추적기에 대한 개선 요청을 열도록 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="3b712ae7d0703efbf3d9ee4609e41b3f3cd65989" translate="yes" xml:space="preserve">
          <source>Programs built with Spacetime instrumentation have a dependency on the libunwind library unless that was unavailable at configure time or the -disable-libunwind option was specified (see section &lt;a href=&quot;#s%3Aspacetime-runtimeoverhead&quot;&gt;22.3&lt;/a&gt;).</source>
          <target state="translated">Spacetime 인스 트루먼 테이션으로 빌드 된 프로그램은 구성시 사용할 수 없거나 -disable-libunwind 옵션이 지정되지 않는 한 libunwind 라이브러리에 종속됩니다 (섹션 &lt;a href=&quot;#s%3Aspacetime-runtimeoverhead&quot;&gt;22.3&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0fa08ed45d5cab3757f6b4a975eb9165de6f9e78" translate="yes" xml:space="preserve">
          <source>Programs running with Spacetime instrumentation consume significantly more memory than their non-instrumented counterparts. It is expected that this memory overhead will also be reduced in the future.</source>
          <target state="translated">Spacetime 계측으로 실행되는 프로그램은 계측되지 않은 프로그램보다 훨씬 더 많은 메모리를 사용합니다. 이 메모리 오버 헤드도 향후 감소 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="63eb6a78b9751a02e1fca63835a2dcf55273437c" translate="yes" xml:space="preserve">
          <source>Programs that use system threads must be linked as follows:</source>
          <target state="translated">시스템 스레드를 사용하는 프로그램은 다음과 같이 링크되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0718dd6f86f5aa1f5dc9d3d0b3619bb6a1c50300" translate="yes" xml:space="preserve">
          <source>Programs that use the dynlink library simply need to link dynlink.cma or dynlink.cmxa with their object files and other libraries.</source>
          <target state="translated">dynlink 라이브러리를 사용하는 프로그램은 dynlink.cma 또는 dynlink.cmxa를 개체 파일 및 기타 라이브러리와 연결하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="0463620b1afee3e694aec11b31b76a4b1f96ef6a" translate="yes" xml:space="preserve">
          <source>Programs that use the str library must be linked as follows:</source>
          <target state="translated">str 라이브러리를 사용하는 프로그램은 다음과 같이 링크되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7a42d2cc2a8eda80048327543bb9aaaac9921c36" translate="yes" xml:space="preserve">
          <source>Programs that use the unix library must be linked as follows:</source>
          <target state="translated">유닉스 라이브러리를 사용하는 프로그램은 다음과 같이 링크되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9639408739caea934aae30d0b4689565093312fd" translate="yes" xml:space="preserve">
          <source>Propose the same interface as usual hash table. However since the bindings are weak, even if &lt;code&gt;mem&amp;nbsp;h&amp;nbsp;k&lt;/code&gt; is true, a subsequent &lt;code&gt;find&amp;nbsp;h&amp;nbsp;k&lt;/code&gt; may raise &lt;code&gt;Not_found&lt;/code&gt; because the garbage collector can run between the two.</source>
          <target state="translated">일반적인 해시 테이블과 동일한 인터페이스를 제안하십시오. 그러나 바인딩이 약하기 때문에 &lt;code&gt;mem&amp;nbsp;h&amp;nbsp;k&lt;/code&gt; 가 참 &lt;code&gt;Not_found&lt;/code&gt; 가비지 수집기가 둘 사이에서 실행될 수 있기 때문에 후속 &lt;code&gt;find&amp;nbsp;h&amp;nbsp;k&lt;/code&gt; 가 Not_found를 발생 시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="677789471bfc26b9baa2dcb7bdc1e90f13c9beac" translate="yes" xml:space="preserve">
          <source>Protocol family not supported</source>
          <target state="translated">지원되지 않는 프로토콜 제품군</target>
        </trans-unit>
        <trans-unit id="59bb2975367cf35f9a618efe163f6de98389a1c2" translate="yes" xml:space="preserve">
          <source>Protocol not available</source>
          <target state="translated">프로토콜을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="05ba63ff22fffa946a6c1e3e8b9d184a5a911e55" translate="yes" xml:space="preserve">
          <source>Protocol not supported</source>
          <target state="translated">지원되지 않는 프로토콜</target>
        </trans-unit>
        <trans-unit id="3ff5f085a157b60cb28dba0860f39cd3e12b11e1" translate="yes" xml:space="preserve">
          <source>Protocol wrong type for socket</source>
          <target state="translated">소켓에 대한 프로토콜 잘못된 유형</target>
        </trans-unit>
        <trans-unit id="c4d4ebfdd03b691f619d61cbe366c6ce68fc905a" translate="yes" xml:space="preserve">
          <source>Provides</source>
          <target state="translated">Provides</target>
        </trans-unit>
        <trans-unit id="2c6c2f6ed5db6aa314135e5ee7ea36dd719021ca" translate="yes" xml:space="preserve">
          <source>Pseudo-random number generators (PRNG).</source>
          <target state="translated">의사 난수 생성기 (PRNG).</target>
        </trans-unit>
        <trans-unit id="1b0ee00b6267b2378862d1f872c21158ec230b1a" translate="yes" xml:space="preserve">
          <source>Put f and g in the same module.</source>
          <target state="translated">f와 g를 같은 모듈에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="938d4423167ad6f26c3a678405b921c5056207ce" translate="yes" xml:space="preserve">
          <source>Put the calling process in a new session and detach it from its controlling terminal.</source>
          <target state="translated">호출 프로세스를 새 세션에 넣고 제어 터미널에서 분리합니다.</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="d325fcd919384f395c02751e03d2cd0288b98cca" translate="yes" xml:space="preserve">
          <source>Queue</source>
          <target state="translated">Queue</target>
        </trans-unit>
        <trans-unit id="caf4b4627b80a9efca6390b0b35ddb954aa1057f" translate="yes" xml:space="preserve">
          <source>Quiet mode. ocamllex normally outputs informational messages to standard output. They are suppressed if option -q is used.</source>
          <target state="translated">저소음 모드. ocamllex는 일반적으로 정보 메시지를 표준 출력으로 출력합니다. -q 옵션이 사용되면 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="34ac50a5c5471cd48d6cd7a69a966ff47405312e" translate="yes" xml:space="preserve">
          <source>Quit character (usually ctrl-\).</source>
          <target state="translated">문자를 종료합니다 (일반적으로 ctrl- \).</target>
        </trans-unit>
        <trans-unit id="eb98a3a6f1365300e275eadb0e82fb6a60fe00cb" translate="yes" xml:space="preserve">
          <source>Quite often, this happens when defining function using higher order function. To avoid this problem, a solution is to add an explicit argument to the function:</source>
          <target state="translated">종종 이것은 고차 함수를 사용하여 함수를 정의 할 때 발생합니다. 이 문제를 방지하기위한 해결책은 함수에 명시 적 인수를 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c053941a8974103fdf9adc10b4e10c54a97ef236" translate="yes" xml:space="preserve">
          <source>Quoted string literals provide an alternative lexical syntax for string literals. They are useful to represent strings of arbitrary content without escaping. Quoted strings are delimited by a matching pair of {&lt;a href=&quot;#quoted-string-id&quot;&gt;quoted-string-id&lt;/a&gt;| and |&lt;a href=&quot;#quoted-string-id&quot;&gt;quoted-string-id&lt;/a&gt;} with the same &lt;a href=&quot;#quoted-string-id&quot;&gt;quoted-string-id&lt;/a&gt; on both sides. Quoted strings do not interpret any character in a special way but requires that the sequence |&lt;a href=&quot;#quoted-string-id&quot;&gt;quoted-string-id&lt;/a&gt;} does not occur in the string itself. The identifier &lt;a href=&quot;#quoted-string-id&quot;&gt;quoted-string-id&lt;/a&gt; is a (possibly empty) sequence of lowercase letters and underscores that can be freely chosen to avoid such issue (e.g. {|hello|}, {ext|hello {|world|}|ext}, ...).</source>
          <target state="translated">인용 된 문자열 리터럴은 문자열 리터럴에 대한 대체 어휘 구문을 제공합니다. 이스케이프하지 않고 임의의 콘텐츠 문자열을 나타내는 데 유용합니다. 인용 된 문자열은 { &lt;a href=&quot;#quoted-string-id&quot;&gt;quoted-string-id&lt;/a&gt; | 및 | &lt;a href=&quot;#quoted-string-id&quot;&gt;quoted-string-id&lt;/a&gt; } 양쪽에 동일한 &lt;a href=&quot;#quoted-string-id&quot;&gt;quoted-string-id&lt;/a&gt; 가 있습니다. 인용 된 문자열은 특수한 방식으로 문자를 해석하지 않지만 시퀀스 | &lt;a href=&quot;#quoted-string-id&quot;&gt;quoted-string-id&lt;/a&gt; }는 문자열 자체에서 발생하지 않습니다. 식별자 &lt;a href=&quot;#quoted-string-id&quot;&gt;인용 문자열-ID는&lt;/a&gt; (자유롭게 이러한 문제를 방지하기 위해 선택 될 수있다 소문자 문자와 밑줄 (아마도 빈) 순서입니다 예를 들어 {| 안녕하세요 |}, {내선 | 안녕하세요 {| 세계 |} | 내선}. ..).</target>
        </trans-unit>
        <trans-unit id="06576556d1ad802f247cad11ae748be47b70cd9c" translate="yes" xml:space="preserve">
          <source>R</source>
          <target state="translated">R</target>
        </trans-unit>
        <trans-unit id="e2bea001712992baa23e8c78c49863e0902c0ce2" translate="yes" xml:space="preserve">
          <source>Radix</source>
          <target state="translated">Radix</target>
        </trans-unit>
        <trans-unit id="7f36ea5d3de965c70c84ceca6f79a298f9099835" translate="yes" xml:space="preserve">
          <source>Raise &lt;a href=&quot;scanf#EXCEPTIONScan_failure&quot;&gt;&lt;code&gt;Scanf.Scan_failure&lt;/code&gt;&lt;/a&gt; if the input does not match the format.</source>
          <target state="translated">올리 &lt;a href=&quot;scanf#EXCEPTIONScan_failure&quot;&gt; &lt;code&gt;Scanf.Scan_failure&lt;/code&gt; 를&lt;/a&gt; 입력이 형식과 일치하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="36954e0616fd4ab6826cea4b2073a23dd8a2d4f9" translate="yes" xml:space="preserve">
          <source>Raise &lt;code&gt;End_of_file&lt;/code&gt; if the end of input is encountered while some more characters are needed to read the current conversion specification.</source>
          <target state="translated">올리 &lt;code&gt;End_of_file&lt;/code&gt; 을 좀 더 문자가 현재의 변환 사양을 읽는 데 필요한 동안 입력의 끝이 발생했을 경우.</target>
        </trans-unit>
        <trans-unit id="95b72d1aa196f806e25d927281ae1551701421c8" translate="yes" xml:space="preserve">
          <source>Raise &lt;code&gt;Failure&lt;/code&gt; if a conversion to a number is not possible.</source>
          <target state="translated">올리 &lt;code&gt;Failure&lt;/code&gt; 숫자로 변환이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="4636335a7fccd892fe73a73b7c56c21ea55d250f" translate="yes" xml:space="preserve">
          <source>Raise &lt;code&gt;Invalid_argument&lt;/code&gt; if the format string is invalid.</source>
          <target state="translated">올리 &lt;code&gt;Invalid_argument&lt;/code&gt; 을 형식 문자열이 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="216738342707122846d4fd6eb0c45706f7b73de1" translate="yes" xml:space="preserve">
          <source>Raise exception &lt;code&gt;Failure&lt;/code&gt; with the given string.</source>
          <target state="translated">주어진 문자열로 예외 &lt;code&gt;Failure&lt;/code&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="491cba7a17e27d1b41d46ea369641a1550e51813" translate="yes" xml:space="preserve">
          <source>Raise exception &lt;code&gt;Invalid_argument&lt;/code&gt; with the given string.</source>
          <target state="translated">주어진 문자열로 &lt;code&gt;Invalid_argument&lt;/code&gt; 예외를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="501ee443ddbcf53091ea1067a9ae3f57f6ebfd33" translate="yes" xml:space="preserve">
          <source>Raise the given exception value</source>
          <target state="translated">주어진 예외 값을 올리십시오.</target>
        </trans-unit>
        <trans-unit id="d60f8969db97c2bb35b2563ab6ed6e4f03404bad" translate="yes" xml:space="preserve">
          <source>Raised by &lt;code&gt;Arg.parse_argv&lt;/code&gt; when the user asks for help.</source>
          <target state="translated">사용자가 도움을 요청할 때 &lt;code&gt;Arg.parse_argv&lt;/code&gt; 에 의해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="27f983f5e162cd924b236f06287a0bff869f30db" translate="yes" xml:space="preserve">
          <source>Raised by parsers when none of the first components of the stream patterns is accepted.</source>
          <target state="translated">스트림 패턴의 첫 번째 구성 요소가 허용되지 않을 때 파서에 의해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="952a898b7a6fd8d0bc9671d84982b32bf6b9fe77" translate="yes" xml:space="preserve">
          <source>Raised by parsers when the first component of a stream pattern is accepted, but one of the following components is rejected.</source>
          <target state="translated">스트림 패턴의 첫 번째 구성 요소가 허용되지만 다음 구성 요소 중 하나가 거부 될 때 파서에 의해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="60fda7c1c7cec524ae01e28e6f47d5fde4832cac" translate="yes" xml:space="preserve">
          <source>Raised by the system calls below when an error is encountered.</source>
          <target state="translated">오류가 발생하면 아래 시스템 호출에 의해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a87f07092a3a001bf1b834aa708db58b4b2fc5a9" translate="yes" xml:space="preserve">
          <source>Raised by the system calls below when an error is encountered. The first component is the error code; the second component is the function name; the third component is the string parameter to the function, if it has one, or the empty string otherwise.</source>
          <target state="translated">오류가 발생하면 아래 시스템 호출에 의해 발생합니다. 첫 번째 구성 요소는 오류 코드입니다. 두 번째 구성 요소는 함수 이름입니다. 세 번째 구성 요소는 함수에 대한 문자열 매개 변수 (있는 경우)이고 그렇지 않은 경우 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="194b55d81062da090b368377d76b9a43588fb263" translate="yes" xml:space="preserve">
          <source>Raised when &lt;a href=&quot;queue#VALtake&quot;&gt;&lt;code&gt;Queue.take&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;queue#VALpeek&quot;&gt;&lt;code&gt;Queue.peek&lt;/code&gt;&lt;/a&gt; is applied to an empty queue.</source>
          <target state="translated">&lt;a href=&quot;queue#VALtake&quot;&gt; &lt;code&gt;Queue.take&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;queue#VALpeek&quot;&gt; &lt;code&gt;Queue.peek&lt;/code&gt; &lt;/a&gt; 이 빈 대기열에 적용될 때 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="70c7459e6d2df687f73674d472326ed2008cb773" translate="yes" xml:space="preserve">
          <source>Raised when &lt;a href=&quot;stack#VALpop&quot;&gt;&lt;code&gt;Stack.pop&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stack#VALtop&quot;&gt;&lt;code&gt;Stack.top&lt;/code&gt;&lt;/a&gt; is applied to an empty stack.</source>
          <target state="translated">&lt;a href=&quot;stack#VALpop&quot;&gt; &lt;code&gt;Stack.pop&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stack#VALtop&quot;&gt; &lt;code&gt;Stack.top&lt;/code&gt; &lt;/a&gt; 이 빈 스택에 적용될 때 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="23d24598ec09335bef9be1ec042a3cc6569685ca" translate="yes" xml:space="preserve">
          <source>Raised when a parser encounters a syntax error.</source>
          <target state="translated">구문 분석기에 구문 오류가 발생하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f202fef5cc0e634106d4608a58d1831f7472ff13" translate="yes" xml:space="preserve">
          <source>Raised when a parser encounters a syntax error. Can also be raised from the action part of a grammar rule, to initiate error recovery.</source>
          <target state="translated">구문 분석기에 구문 오류가 발생하면 발생합니다. 문법 규칙의 작업 부분에서 발생하여 오류 복구를 시작할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ae11633db0e7da3516b2e0225f22dfb074f61b7" translate="yes" xml:space="preserve">
          <source>Raises an invalid argument exception if the returned geometry does not satisfy &lt;a href=&quot;format#VALcheck_geometry&quot;&gt;&lt;code&gt;Format.check_geometry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 도형이 &lt;a href=&quot;format#VALcheck_geometry&quot;&gt; &lt;code&gt;Format.check_geometry&lt;/code&gt; 를&lt;/a&gt; 충족하지 않는 경우 잘못된 인수 예외를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="e41f4a95b91b1b7d3f518258afac3a6e567857f5" translate="yes" xml:space="preserve">
          <source>Raising arbitrary exceptions from C is more delicate: the exception identifier is dynamically allocated by the OCaml program, and therefore must be communicated to the C function using the registration facility described below in section &lt;a href=&quot;#ss%3Ac-register-exn&quot;&gt;20.7.3&lt;/a&gt;. Once the exception identifier is recovered in C, the following functions actually raise the exception:</source>
          <target state="translated">C에서 임의의 예외를 발생시키는 것은 더 섬세합니다. 예외 식별자는 OCaml 프로그램에 의해 동적으로 할당되므로 아래 섹션 &lt;a href=&quot;#ss%3Ac-register-exn&quot;&gt;20.7.3에&lt;/a&gt; 설명 된 등록 기능을 사용하여 C 함수에 전달되어야합니다 . C에서 예외 식별자가 복구되면 다음 함수가 실제로 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="58d888c08aa561f370e38cee976121532a883d71" translate="yes" xml:space="preserve">
          <source>Random</source>
          <target state="translated">Random</target>
        </trans-unit>
        <trans-unit id="d00e5de923d2fb499cc63830a172dced4874a46e" translate="yes" xml:space="preserve">
          <source>Raw backtrace slots</source>
          <target state="translated">원시 역 추적 슬롯</target>
        </trans-unit>
        <trans-unit id="e4ce60b8828e956013eeab15d66339b705f8bbb9" translate="yes" xml:space="preserve">
          <source>Raw backtraces</source>
          <target state="translated">원시 역 추적</target>
        </trans-unit>
        <trans-unit id="b5b8cb76a84d201ebabeaff1f6e3a3a5860bdc27" translate="yes" xml:space="preserve">
          <source>Raw backtraces cannot be marshalled. If you need marshalling, you should use the array returned by the &lt;code&gt;backtrace_slots&lt;/code&gt; function of the next section.</source>
          <target state="translated">원시 역 추적은 마샬링 할 수 없습니다. 마샬링이 필요한 경우 다음 섹션 의 &lt;code&gt;backtrace_slots&lt;/code&gt; 함수에서 반환 한 배열을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a377c099adff515091e70dcb22c7db7203b2316a" translate="yes" xml:space="preserve">
          <source>Raw socket</source>
          <target state="translated">원시 소켓</target>
        </trans-unit>
        <trans-unit id="4cb7c0865348e2999ad6f51a8b71faa68d7a22f8" translate="yes" xml:space="preserve">
          <source>Re-exported variant type or record type: an equation, a representation.</source>
          <target state="translated">다시 내 보낸 변형 유형 또는 레코드 유형 : 방정식, 표현.</target>
        </trans-unit>
        <trans-unit id="64dfcf3ac85b42a4d5f54acc3201c4eef3261f89" translate="yes" xml:space="preserve">
          <source>Re-schedule the calling thread without suspending it.</source>
          <target state="translated">호출 스레드를 일시 중단하지 않고 다시 예약합니다.</target>
        </trans-unit>
        <trans-unit id="f2512ca26766e71583adc6edd50373f5839822c3" translate="yes" xml:space="preserve">
          <source>Re-schedule the calling thread without suspending it. This function can be used to give scheduling hints, telling the scheduler that now is a good time to switch to other threads.</source>
          <target state="translated">호출 스레드를 일시 중단하지 않고 다시 예약합니다. 이 기능은 스케줄러에게 지금이 다른 스레드로 전환하기에 좋은시기임을 알리는 힌트를 제공하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38b32003b07368691f1f80f28b6e5008499f9ee7" translate="yes" xml:space="preserve">
          <source>Re-shaping Bigarrays</source>
          <target state="translated">Bigarray 재구성</target>
        </trans-unit>
        <trans-unit id="ccc014cfb02135583355873ad00c0361f061abe4" translate="yes" xml:space="preserve">
          <source>Read a 4-byte float</source>
          <target state="translated">4 바이트 부동 읽기</target>
        </trans-unit>
        <trans-unit id="6ce591d11020ba17c35a7b7213eb3d8a7f2e7397" translate="yes" xml:space="preserve">
          <source>Read a digest from the given input channel.</source>
          <target state="translated">주어진 입력 채널에서 다이제스트를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="6abf4e7e7c125c3e76e1801fe87fa4883e72f6b5" translate="yes" xml:space="preserve">
          <source>Read a signed 1-byte integer</source>
          <target state="translated">부호있는 1 바이트 정수 읽기</target>
        </trans-unit>
        <trans-unit id="71fe81b04c2829d569497cb34072d498c20d57df" translate="yes" xml:space="preserve">
          <source>Read a signed 2-byte integer</source>
          <target state="translated">부호있는 2 바이트 정수 읽기</target>
        </trans-unit>
        <trans-unit id="b16c938fdffeee8bd1dbcd5043af23124f4907c3" translate="yes" xml:space="preserve">
          <source>Read a signed 4-byte integer</source>
          <target state="translated">부호있는 4 바이트 정수 읽기</target>
        </trans-unit>
        <trans-unit id="ded1b67059cacac26764983c31cbd02b0e0cac19" translate="yes" xml:space="preserve">
          <source>Read a signed 8-byte integer</source>
          <target state="translated">부호있는 8 바이트 정수 읽기</target>
        </trans-unit>
        <trans-unit id="d30e01e9ef051947cd7c2401618bc8954386d497" translate="yes" xml:space="preserve">
          <source>Read additional newline-terminated command line arguments from filename.</source>
          <target state="translated">파일 이름에서 추가 줄 바꿈으로 끝나는 명령 줄 인수를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="d60d751c7d878040cce554ef4627185c7b2d3920" translate="yes" xml:space="preserve">
          <source>Read additional newline-terminated command line arguments from filename. It is not possible to pass a scriptfile via file to the toplevel.</source>
          <target state="translated">파일 이름에서 추가 줄 바꿈으로 끝나는 명령 줄 인수를 읽습니다. 파일을 통해 최상위 수준으로 스크립트 파일을 전달할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="76835ba4a31ac07483f46f43fa6c985ae1bff9b6" translate="yes" xml:space="preserve">
          <source>Read additional null character terminated command line arguments from filename.</source>
          <target state="translated">파일 이름에서 추가 널 문자로 끝나는 명령 줄 인수를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="2122d0c469288519c91629a369aa2bba0ff43acd" translate="yes" xml:space="preserve">
          <source>Read additional null character terminated command line arguments from filename. It is not possible to pass a scriptfile via file to the toplevel.</source>
          <target state="translated">파일 이름에서 추가 널 문자로 끝나는 명령 줄 인수를 읽습니다. 파일을 통해 최상위 수준으로 스크립트 파일을 전달할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a26fe31a2c0a8c7224fa3039d8cfb00b78512e3" translate="yes" xml:space="preserve">
          <source>Read an 8-byte float</source>
          <target state="translated">8 바이트 부동 읽기</target>
        </trans-unit>
        <trans-unit id="f0d6329ef4b06a86875dd2b3a89bd475040195a4" translate="yes" xml:space="preserve">
          <source>Read an array of 1-byte quantities</source>
          <target state="translated">1 바이트 수량의 배열 읽기</target>
        </trans-unit>
        <trans-unit id="31f8cf88f9bcfee42eab62d3bcc4e91f216fbcbe" translate="yes" xml:space="preserve">
          <source>Read an array of 2-byte quantities</source>
          <target state="translated">2 바이트 수량의 배열 읽기</target>
        </trans-unit>
        <trans-unit id="629ec05ac2ba9fa5ed43a7da5945c4794a87ff25" translate="yes" xml:space="preserve">
          <source>Read an array of 4-byte quantities</source>
          <target state="translated">4 바이트 수량의 배열 읽기</target>
        </trans-unit>
        <trans-unit id="4271deb4d0b3a7e8812b99d0449d3e1b0240445d" translate="yes" xml:space="preserve">
          <source>Read an array of 8-byte quantities</source>
          <target state="translated">8 바이트 수량의 배열 읽기</target>
        </trans-unit>
        <trans-unit id="ac825a1f3b1937d32ea50c327b0ba22a748ffda1" translate="yes" xml:space="preserve">
          <source>Read an element of a generic Bigarray.</source>
          <target state="translated">일반 Bigarray의 요소를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="9c41d1ccd2cf647c34256b9f1a313fa0d3f1bcd9" translate="yes" xml:space="preserve">
          <source>Read an element of a generic Bigarray. &lt;code&gt;Genarray.get&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; returns the element of &lt;code&gt;a&lt;/code&gt; whose coordinates are &lt;code&gt;i1&lt;/code&gt; in the first dimension, &lt;code&gt;i2&lt;/code&gt; in the second dimension, ..., &lt;code&gt;iN&lt;/code&gt; in the &lt;code&gt;N&lt;/code&gt;-th dimension.</source>
          <target state="translated">일반 Bigarray의 요소를 읽습니다. &lt;code&gt;Genarray.get&amp;nbsp;a&amp;nbsp;[|i1;&amp;nbsp;...;&amp;nbsp;iN|]&lt;/code&gt; 은 좌표가 첫 번째 차원에서 &lt;code&gt;i1&lt;/code&gt; , 두 번째 차원에서 &lt;code&gt;i2&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; 번째 차원 에서 ..., &lt;code&gt;iN&lt;/code&gt; 인 &lt;code&gt;a&lt;/code&gt; 의 요소를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="67349a86f7563898607682268ae95a1f61056dc9" translate="yes" xml:space="preserve">
          <source>Read an integer encoded in binary format (4 bytes, big-endian) from the given input channel.</source>
          <target state="translated">주어진 입력 채널에서 이진 형식 (4 바이트, 빅 엔디안)으로 인코딩 된 정수를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="33e9c74f4180396e136f31afbdcec851f5f66b00" translate="yes" xml:space="preserve">
          <source>Read an integer encoded in binary format (4 bytes, big-endian) from the given input channel. See &lt;a href=&quot;stdlib#VALoutput_binary_int&quot;&gt;&lt;code&gt;output_binary_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 입력 채널에서 이진 형식 (4 바이트, 빅 엔디안)으로 인코딩 된 정수를 읽습니다. &lt;a href=&quot;stdlib#VALoutput_binary_int&quot;&gt; &lt;code&gt;output_binary_int&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ac938561144649bc1155f569e56036f2fdfd2c7" translate="yes" xml:space="preserve">
          <source>Read an propagate the delayed dependencies for module aliases in file, so that the following files will depend on the exported aliased modules if they use them. See the example below.</source>
          <target state="translated">파일에서 모듈 별칭에 대한 지연된 종속성 전파를 읽어 다음 파일이 내 보낸 별칭 모듈을 사용하는 경우 종속되도록합니다. 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="886ea27c8bec585df975149a00402cd79c637ee6" translate="yes" xml:space="preserve">
          <source>Read an unsigned 1-byte integer</source>
          <target state="translated">부호없는 1 바이트 정수 읽기</target>
        </trans-unit>
        <trans-unit id="a0c70c66a803617f07522cf4c684939542a5fba7" translate="yes" xml:space="preserve">
          <source>Read an unsigned 2-byte integer</source>
          <target state="translated">부호없는 2 바이트 정수 읽기</target>
        </trans-unit>
        <trans-unit id="50bbf9a0280a7ce2b8bbbe0030193ddd1a363831" translate="yes" xml:space="preserve">
          <source>Read an unsigned 4-byte integer</source>
          <target state="translated">부호없는 4 바이트 정수 읽기</target>
        </trans-unit>
        <trans-unit id="316d26280ca41288433d99fb399411a2cc1faadb" translate="yes" xml:space="preserve">
          <source>Read an unsigned 8-byte integer</source>
          <target state="translated">부호없는 8 바이트 정수 읽기</target>
        </trans-unit>
        <trans-unit id="e86508915a0d56a2f11022c831d9f04464b83ca9" translate="yes" xml:space="preserve">
          <source>Read characters from the given input channel, until a newline character is encountered.</source>
          <target state="translated">개행 문자를 만날 때까지 주어진 입력 채널에서 문자를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="73846446201ce3c7e60e58af2642dc5ece7a008d" translate="yes" xml:space="preserve">
          <source>Read characters from the given input channel, until a newline character is encountered. Return the string of all characters read, without the newline character at the end.</source>
          <target state="translated">개행 문자를 만날 때까지 주어진 입력 채널에서 문자를 읽습니다. 끝에 개행 문자없이 읽은 모든 문자의 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f8f467b17b835e6d668da3cfd0cd0dff2106036b" translate="yes" xml:space="preserve">
          <source>Read debugger commands from the script filename.</source>
          <target state="translated">스크립트 파일 이름에서 디버거 명령을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="9f666d340bc1a11b2f16b993b989b8d17ce60207" translate="yes" xml:space="preserve">
          <source>Read one character from the given input channel.</source>
          <target state="translated">주어진 입력 채널에서 한 문자를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="9131dce42813e8ec41b39beb9e3ff10f19dc602b" translate="yes" xml:space="preserve">
          <source>Read permission</source>
          <target state="translated">읽기 권한</target>
        </trans-unit>
        <trans-unit id="5e0313b5eab47220b914011434d8a7cc69c1dfa7" translate="yes" xml:space="preserve">
          <source>Read the contents of a link.</source>
          <target state="translated">링크의 내용을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="1101c25e2994338c1c2eb973a4f3f47e5e391381" translate="yes" xml:space="preserve">
          <source>Read the contents of a symbolic link.</source>
          <target state="translated">심볼릭 링크의 내용을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="31a359da53b69b3ea6b092a55c310d55d6ebea95" translate="yes" xml:space="preserve">
          <source>Read the grammar specification from standard input. The default output file names are stdin.ml and stdin.mli.</source>
          <target state="translated">표준 입력에서 문법 사양을 읽으십시오. 기본 출력 파일 이름은 stdin.ml 및 stdin.mli입니다.</target>
        </trans-unit>
        <trans-unit id="18b8434ffb8be92faae1a806cd108694f763b2b0" translate="yes" xml:space="preserve">
          <source>Read the representation of a structured value, as produced by &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt;, and return the corresponding value.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALoutput_value&quot;&gt; &lt;code&gt;output_value&lt;/code&gt; &lt;/a&gt; 에 의해 생성 된 구조화 된 값의 표현을 읽고 해당 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1b341d52843a5bf78cfe433947040df998396cbe" translate="yes" xml:space="preserve">
          <source>Read the representation of a structured value, as produced by &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt;, and return the corresponding value. This function is identical to &lt;a href=&quot;marshal#VALfrom_channel&quot;&gt;&lt;code&gt;Marshal.from_channel&lt;/code&gt;&lt;/a&gt;; see the description of module &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; for more information, in particular concerning the lack of type safety.</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALoutput_value&quot;&gt; &lt;code&gt;output_value&lt;/code&gt; &lt;/a&gt; 에 의해 생성 된 구조화 된 값의 표현을 읽고 해당 값을 반환합니다. 이 함수는 &lt;a href=&quot;marshal#VALfrom_channel&quot;&gt; &lt;code&gt;Marshal.from_channel&lt;/code&gt; &lt;/a&gt; 과 동일합니다 . 특히 유형 안전성 부족에 관한 자세한 정보 는 모듈 &lt;a href=&quot;marshal&quot;&gt; &lt;code&gt;Marshal&lt;/code&gt; &lt;/a&gt; 의 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9627fd30596032c688ad807a751d4e103b2c13d" translate="yes" xml:space="preserve">
          <source>Read the standard input as a script file rather than starting an interactive session.</source>
          <target state="translated">대화식 세션을 시작하는 대신 표준 입력을 스크립트 파일로 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="c0827111eae7b98567c87474f4b43f73cf9df084" translate="yes" xml:space="preserve">
          <source>Read, compile and execute source phrases from the given file. This is textual inclusion: phrases are processed just as if they were typed on standard input. The reading of the file stops at the first error encountered.</source>
          <target state="translated">주어진 파일에서 소스 구문을 읽고 컴파일하고 실행합니다. 이것은 텍스트 포함입니다. 구문은 표준 입력에 입력 된 것처럼 처리됩니다. 첫 번째 오류가 발생하면 파일 읽기가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="fd7967994dfc943a9d75a158de2c9b6edcab50b2" translate="yes" xml:space="preserve">
          <source>Read-only file system</source>
          <target state="translated">읽기 전용 파일 시스템</target>
        </trans-unit>
        <trans-unit id="e251a56e473195fc043435e63c0bd44f25861fa8" translate="yes" xml:space="preserve">
          <source>Reading format strings from input</source>
          <target state="translated">입력에서 형식 문자열 읽기</target>
        </trans-unit>
        <trans-unit id="5f40594d4332209f624490fba4a21a0d8f2420fc" translate="yes" xml:space="preserve">
          <source>Reads complete as writes (depending on O_SYNC/O_DSYNC)</source>
          <target state="translated">쓰기 완료로 읽기 (O_SYNC / O_DSYNC에 따라 다름)</target>
        </trans-unit>
        <trans-unit id="06d761e12b94d1da8094c742a6a4c7e7ebc3906f" translate="yes" xml:space="preserve">
          <source>Reasonable defaults for functions &lt;code&gt;out_spaces&lt;/code&gt; and &lt;code&gt;out_newline&lt;/code&gt; are respectively &lt;code&gt;out_funs.out_string&amp;nbsp;(String.make&amp;nbsp;n&amp;nbsp;'&amp;nbsp;')&amp;nbsp;0&amp;nbsp;n&lt;/code&gt; and &lt;code&gt;out_funs.out_string&amp;nbsp;&quot;\n&quot;&amp;nbsp;0&amp;nbsp;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;out_spaces&lt;/code&gt; 및 &lt;code&gt;out_newline&lt;/code&gt; 함수에 대한 합리적인 기본값 은 각각 &lt;code&gt;out_funs.out_string&amp;nbsp;(String.make&amp;nbsp;n&amp;nbsp;'&amp;nbsp;')&amp;nbsp;0&amp;nbsp;n&lt;/code&gt; 및 &lt;code&gt;out_funs.out_string&amp;nbsp;&quot;\n&quot;&amp;nbsp;0&amp;nbsp;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9b3342b2d0538c1531ee9aae57b07f20c9dab43f" translate="yes" xml:space="preserve">
          <source>Receive data from a connected socket.</source>
          <target state="translated">연결된 소켓에서 데이터를받습니다.</target>
        </trans-unit>
        <trans-unit id="495d38b61f84619813658e11cf80eb64bc551bc0" translate="yes" xml:space="preserve">
          <source>Receive data from an unconnected socket.</source>
          <target state="translated">연결되지 않은 소켓에서 데이터를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="1a799052460df4566a7952caba304831fe0a14ce" translate="yes" xml:space="preserve">
          <source>Reception is enabled.</source>
          <target state="translated">수신이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="95acc15fad87944379696aedcca3bee2d5c818f5" translate="yes" xml:space="preserve">
          <source>Recognize XON/XOFF characters on input.</source>
          <target state="translated">입력시 XON / XOFF 문자를 인식합니다.</target>
        </trans-unit>
        <trans-unit id="61eee862a5e72ab7ea8fe95e4746a73711431897" translate="yes" xml:space="preserve">
          <source>Recognize file names ending with string as interface files (instead of the default .mli).</source>
          <target state="translated">문자열로 끝나는 파일 이름을 인터페이스 파일로 인식합니다 (기본 .mli 대신).</target>
        </trans-unit>
        <trans-unit id="347a8e34dcdfe0c261bbae1b232251ad673cf4a9" translate="yes" xml:space="preserve">
          <source>Record debugging information</source>
          <target state="translated">디버깅 정보 기록</target>
        </trans-unit>
        <trans-unit id="910f4030ea52bda376b5aa3aca46c5ba6aa007f1" translate="yes" xml:space="preserve">
          <source>Record fields</source>
          <target state="translated">레코드 필드</target>
        </trans-unit>
        <trans-unit id="ab31373329ebda7a9ecee39f6fc1d37f1ce7c824" translate="yes" xml:space="preserve">
          <source>Record fields can also be accessed through pattern-matching:</source>
          <target state="translated">패턴 일치를 통해 레코드 필드에 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1cf7c53e7cf560426af957246ab1c5b36c8505f" translate="yes" xml:space="preserve">
          <source>Record fields can also be modified by assignment, provided they are declared mutable in the definition of the record type:</source>
          <target state="translated">레코드 필드는 레코드 유형의 정의에서 변경 가능하다고 선언 된 경우 할당을 통해 수정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="26b2a5b6fdc37fc99da7b0607b037ff3a884f246" translate="yes" xml:space="preserve">
          <source>Record values are labeled tuples of values. The record value written {&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=v&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip;;&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=v&lt;sub&gt;n&lt;/sub&gt;} associates the value v&lt;sub&gt;i&lt;/sub&gt; to the record field &lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt;, for i = 1 &amp;hellip; n. The current implementation supports records with up to 2&lt;sup&gt;22&lt;/sup&gt; &amp;minus; 1 fields (4194303 fields).</source>
          <target state="translated">레코드 값은 값의 튜플로 레이블이 지정됩니다. 기록 된 레코드 값 { &lt;a href=&quot;names#field&quot;&gt;field &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; = v &lt;sub&gt;1&lt;/sub&gt; ; &amp;hellip;; &lt;a href=&quot;names#field&quot;&gt;field &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; = v &lt;sub&gt;n&lt;/sub&gt; } 은 i = 1&amp;hellip; n에 대해 값 v &lt;sub&gt;i&lt;/sub&gt; 를 레코드 필드 &lt;a href=&quot;names#field&quot;&gt;필드 &lt;/a&gt;&lt;sub&gt;i에&lt;/sub&gt; 연관시킵니다 . 최대 2와 현재 구현 지원 레코드 &lt;sup&gt;(22)&lt;/sup&gt; 1 개 필드 (필드 4,194,303) -.</target>
        </trans-unit>
        <trans-unit id="a02fbaf92ab6f668ba8c58db00c88fa0b033da16" translate="yes" xml:space="preserve">
          <source>Records are also represented by zero-tagged blocks. The ordering of labels in the record type declaration determines the layout of the record fields: the value associated to the label declared first is stored in field 0 of the block, the value associated to the second label goes in field 1, and so on.</source>
          <target state="translated">레코드는 태그가없는 블록으로도 표시됩니다. 레코드 유형 선언에서 레이블의 순서는 레코드 필드의 레이아웃을 결정합니다. 첫 번째로 선언 된 레이블에 연결된 값은 블록의 필드 0에 저장되고 두 번째 레이블에 연결된 값은 필드 1에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="50a39f91dc419f213f3f430557f69794fa4719cc" translate="yes" xml:space="preserve">
          <source>Recursive classes can be used to define objects whose types are mutually recursive.</source>
          <target state="translated">재귀 클래스는 유형이 상호 재귀적인 객체를 정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57f808596bec53448916381d4754315ccc18b74d" translate="yes" xml:space="preserve">
          <source>Recursive definitions of names are introduced by letrec:</source>
          <target state="translated">이름의 재귀 적 정의는 letrec에 의해 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="a4779850ffe8cff34ad7d948ec38d13e841f8164" translate="yes" xml:space="preserve">
          <source>Recursive functions are defined with the let rec binding:</source>
          <target state="translated">재귀 함수는 let rec 바인딩으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="1d353d1981023ac46b358959ff73a6f6b4d85dd9" translate="yes" xml:space="preserve">
          <source>Recursive module definitions, introduced by the module rec &amp;hellip;and &amp;hellip; construction, generalize regular module definitions module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;=&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; and module specifications module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; by allowing the defining &lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; and the &lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; to refer recursively to the module identifiers being defined. A typical example of a recursive module definition is:</source>
          <target state="translated">모듈 REC ... 그리고 ... 건설 도입 재귀 모듈의 정의는, 일반 모듈 정의 모듈 일반화 &lt;a href=&quot;names#module-name&quot;&gt;모듈 이름&lt;/a&gt; = &lt;a href=&quot;modules#module-expr&quot;&gt;모듈 EXPR&lt;/a&gt; 과 모듈 명세 모듈 &lt;a href=&quot;names#module-name&quot;&gt;모듈 이름&lt;/a&gt; : &lt;a href=&quot;modtypes#module-type&quot;&gt;모듈 유형을&lt;/a&gt; 정의하는시킴으로써 &lt;a href=&quot;modules#module-expr&quot;&gt;모듈 EXPR&lt;/a&gt; 및 &lt;a href=&quot;modtypes#module-type&quot;&gt;모듈 형&lt;/a&gt; 행을 정의중인 모듈 식별자를 반복적으로 참조합니다. 재귀 모듈 정의의 일반적인 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb8e04bf713983ca46edb8008396708aa79152e5" translate="yes" xml:space="preserve">
          <source>Redefining formatter output</source>
          <target state="translated">포맷터 출력 재정의</target>
        </trans-unit>
        <trans-unit id="1e482b78115537fa1c38984758e5cd15f5753d32" translate="yes" xml:space="preserve">
          <source>Redefining output functions</source>
          <target state="translated">출력 기능 재정의</target>
        </trans-unit>
        <trans-unit id="1a791fb89307dba01bce8608462fad99f40b16f5" translate="yes" xml:space="preserve">
          <source>Redefining semantic tag operations</source>
          <target state="translated">의미 론적 태그 작업 재정의</target>
        </trans-unit>
        <trans-unit id="ff0501a0bef34fc88116df27f2efa64b96b25ae6" translate="yes" xml:space="preserve">
          <source>Redirect the standard pretty-printer output to the given channel.</source>
          <target state="translated">표준 pretty-printer 출력을 지정된 채널로 리디렉션합니다.</target>
        </trans-unit>
        <trans-unit id="c1f536bf9044d5654bf01fe4a0d29f6dd1268674" translate="yes" xml:space="preserve">
          <source>Redirect the standard pretty-printer output to the given channel. (All the output functions of the standard formatter are set to the default output functions printing to the given channel.)</source>
          <target state="translated">표준 pretty-printer 출력을 지정된 채널로 리디렉션합니다. (표준 포맷터의 모든 출력 기능은 주어진 채널에 인쇄되는 기본 출력 기능으로 설정됩니다.)</target>
        </trans-unit>
        <trans-unit id="bc5c411817f17db821dafb6a6686007ee18c9713" translate="yes" xml:space="preserve">
          <source>Redirecting the standard formatter output</source>
          <target state="translated">표준 포맷터 출력 리디렉션</target>
        </trans-unit>
        <trans-unit id="16f6909a6a6e1cc00213c91c99a81a703a9ee676" translate="yes" xml:space="preserve">
          <source>Redundant case in a pattern matching (unused match case).</source>
          <target state="translated">패턴 일치의 중복 대소 문자 (사용하지 않는 대소 문자 일치).</target>
        </trans-unit>
        <trans-unit id="238fe5d52f17b0fe9911a63bfec331920e535cc6" translate="yes" xml:space="preserve">
          <source>Redundant sub-pattern in a pattern-matching.</source>
          <target state="translated">패턴 일치의 중복 하위 패턴.</target>
        </trans-unit>
        <trans-unit id="37aba70e342850096daafd45baa804ba09bbd307" translate="yes" xml:space="preserve">
          <source>Refer to documentation on yacc for more details and guidance in how to use error recovery.</source>
          <target state="translated">오류 복구 사용 방법에 대한 자세한 내용과 지침은 yacc에 대한 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="49711308b42a4846bba12eba8a7e15f9e53d5624" translate="yes" xml:space="preserve">
          <source>Reference assignment (update the reference given as first argument with the value of the second argument).</source>
          <target state="translated">참조 할당 (첫 번째 인수로 제공된 참조를 두 번째 인수의 값으로 업데이트).</target>
        </trans-unit>
        <trans-unit id="122a8c607714911f9c55a95520ba352930d18102" translate="yes" xml:space="preserve">
          <source>Reference cells can be implemented as objects. The naive definition fails to typecheck:</source>
          <target state="translated">참조 셀은 개체로 구현할 수 있습니다. 순진한 정의는 typecheck에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="9de79c805af623bf5ca8641671f754beff12d79f" translate="yes" xml:space="preserve">
          <source>Reference the regular expression bound to &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; by an earlier let&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;=&lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt; definition.</source>
          <target state="translated">이전 let &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; = &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt; 정의에 의해 &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; 에 바인딩 된 정규식을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a091fe7db1bf4411fef339d55d431e81767afbcb" translate="yes" xml:space="preserve">
          <source>Reference to undefined global mod</source>
          <target state="translated">정의되지 않은 전역 모드에 대한 참조</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="4694bd4be677ce4663069cbb84ca82da59029a24" translate="yes" xml:space="preserve">
          <source>References are also useful to write functions that maintain a current state between two calls to the function. For instance, the following pseudo-random number generator keeps the last returned number in a reference:</source>
          <target state="translated">참조는 함수에 대한 두 호출 사이에 현재 상태를 유지하는 함수를 작성하는데도 유용합니다. 예를 들어 다음 의사 난수 생성기는 마지막으로 반환 된 숫자를 참조에 유지합니다.</target>
        </trans-unit>
        <trans-unit id="cf1a98eb8bda259c5e6b53f5f44a52d8c3f772c6" translate="yes" xml:space="preserve">
          <source>Refill handlers are a recent (optional) feature introduced in 4.02, documented below in subsection &lt;a href=&quot;#ss%3Arefill-handlers&quot;&gt;13.2.7&lt;/a&gt;.</source>
          <target state="translated">리필 핸들러는 4.02에 도입 된 최근 (선택적) 기능으로, 하위 섹션 &lt;a href=&quot;#ss%3Arefill-handlers&quot;&gt;13.2.7에&lt;/a&gt; 문서화되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f6e9c6e085af786bdc00af692163b916a0cfeee" translate="yes" xml:space="preserve">
          <source>Regarding the atomicity guarantees given by &lt;code&gt;~cloexec:true&lt;/code&gt; or by the use of the &lt;code&gt;O_CLOEXEC&lt;/code&gt; flag: on all platforms it is guaranteed that a concurrently-executing Caml thread cannot leak the descriptor by starting a new process. On Linux, this guarantee extends to concurrently-executing C threads. As of Feb 2017, other operating systems lack the necessary system calls and still expose a window of vulnerability during which a C thread can see the newly-created file descriptor in ``keep-on-exec'' mode.</source>
          <target state="translated">&lt;code&gt;~cloexec:true&lt;/code&gt; 또는 &lt;code&gt;O_CLOEXEC&lt;/code&gt; 플래그 사용에 의해 제공되는 원 자성 보장과 관련하여 : 모든 플랫폼에서 동시에 실행되는 Caml 스레드가 새 프로세스를 시작하여 설명자를 누출 할 수 없음을 보장합니다. Linux에서이 보장은 동시에 실행되는 C 스레드로 확장됩니다. 2017 년 2 월 현재 다른 운영 체제에는 필요한 시스템 호출이없고 C 스레드가``keep-on-exec ''모드에서 새로 생성 된 파일 설명자를 볼 수있는 취약점이 여전히 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="77d7183b5b67f0148ca5d09be4416ccc6e902609" translate="yes" xml:space="preserve">
          <source>Register the function named printer-name (a value path) as a printer for objects whose types match the argument type of the function. That is, the debugger will call printer-name when it has such an object to print. The printing function printer-name must use the Format library module to produce its output, otherwise its output will not be correctly located in the values printed by the toplevel loop.</source>
          <target state="translated">유형이 함수의 인수 유형과 일치하는 객체에 대해 printer-name (값 경로)이라는 함수를 프린터로 등록합니다. 즉, 디버거는 인쇄 할 개체가있을 때 printer-name을 호출합니다. 인쇄 기능 printer-name은 출력을 생성하기 위해 Format 라이브러리 모듈을 사용해야합니다. 그렇지 않으면 출력이 최상위 루프에 의해 인쇄 된 값에 올바르게 위치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d7abeab29a5ab9bb4cd5dff7b62e29222042952f" translate="yes" xml:space="preserve">
          <source>Register the given function to be called at program termination time.</source>
          <target state="translated">프로그램 종료시 호출 할 함수를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="46539f816e7562760cc9adc223f7359c10aad574" translate="yes" xml:space="preserve">
          <source>Register the given function to be called at program termination time. The functions registered with &lt;code&gt;at_exit&lt;/code&gt; will be called when the program does any of the following:</source>
          <target state="translated">프로그램 종료시 호출 할 함수를 등록합니다. &lt;code&gt;at_exit&lt;/code&gt; 에 등록 된 함수 는 프로그램이 다음 중 하나를 수행 할 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ca874b55b0f92111a93cd652711639493fdbfb06" translate="yes" xml:space="preserve">
          <source>Registering OCaml values with the C runtime.</source>
          <target state="translated">C 런타임에 OCaml 값 등록.</target>
        </trans-unit>
        <trans-unit id="ee478efa11b298959e74cf6618239180535fbb82" translate="yes" xml:space="preserve">
          <source>Registration of a global variable v is achieved by calling caml_register_global_root(&amp;amp;v) just before or just after a valid value is stored in v for the first time; likewise, registration of an arbitrary location p is achieved by calling caml_register_global_root(p).</source>
          <target state="translated">전역 변수 v의 등록은 유효한 값이 v에 처음으로 저장되기 직전 또는 직후에 caml_register_global_root (&amp;amp; v)를 호출하여 수행됩니다. 마찬가지로 임의 위치 p의 등록은 caml_register_global_root (p)를 호출하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="3172c4ae8fee97c04bb506eac2e6f47443f5a679" translate="yes" xml:space="preserve">
          <source>Regular expressions</source>
          <target state="translated">정규식</target>
        </trans-unit>
        <trans-unit id="5c96cb6f219058eabf8872d9c4a4d120512db91e" translate="yes" xml:space="preserve">
          <source>Regular expressions and high-level string processing</source>
          <target state="translated">정규식 및 고급 문자열 처리</target>
        </trans-unit>
        <trans-unit id="c8a073b89aebe0e05ff91f4dd2316f67e5c58000" translate="yes" xml:space="preserve">
          <source>Regular file</source>
          <target state="translated">일반 파일</target>
        </trans-unit>
        <trans-unit id="09f7c403fe69451818e2b0ac1a8669a89a95d11b" translate="yes" xml:space="preserve">
          <source>Reject invalid formats that were accepted in legacy format implementations. You should use this flag to detect and fix such invalid formats, as they will be rejected by future OCaml versions.</source>
          <target state="translated">레거시 형식 구현에서 허용 된 잘못된 형식을 거부합니다. 이러한 잘못된 형식은 향후 OCaml 버전에서 거부되므로이 플래그를 사용하여 이러한 잘못된 형식을 감지하고 수정해야합니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="75d017d689a1b5a76f0fc05ac1a94a6933ae9c60" translate="yes" xml:space="preserve">
          <source>Remark that the type inferred for empty is 'a list and not '_weak5 list that should have occurred with the value restriction since f () is a function application.</source>
          <target state="translated">비어있는 것으로 추론 된 유형은 f ()가 함수 응용 프로그램이므로 값 제한으로 발생해야하는 '_weak5 목록이 아니라'목록 '입니다.</target>
        </trans-unit>
        <trans-unit id="7230db168d899f594b95cb697d95bc8534a0e07f" translate="yes" xml:space="preserve">
          <source>Remove all elements from the table.</source>
          <target state="translated">테이블에서 모든 요소를 ​​제거하십시오.</target>
        </trans-unit>
        <trans-unit id="f662b3f3ba722f6f477ef995251656740bd0a589" translate="yes" xml:space="preserve">
          <source>Remove an empty directory.</source>
          <target state="translated">빈 디렉토리를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="c2426d9587ba25986a9d9a8464f4cf28f49b4e2a" translate="yes" xml:space="preserve">
          <source>Remove blank characters until the first asterisk (&amp;rsquo;*&amp;rsquo;) in each line of comments.</source>
          <target state="translated">각 주석 행에서 첫 번째 별표 ( '*')까지 공백 문자를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="1a90aad5043757c8a9c09d20150830c67e086bfe" translate="yes" xml:space="preserve">
          <source>Remove from the sequence the elements that do not satisfy the given predicate.</source>
          <target state="translated">주어진 술어를 만족하지 않는 요소를 시퀀스에서 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="246687551a774323a453e92a24c7aeb3ca4bfd55" translate="yes" xml:space="preserve">
          <source>Remove from the sequence the elements that do not satisfy the given predicate. This transformation is lazy, it only applies when the result is traversed.</source>
          <target state="translated">주어진 술어를 만족하지 않는 요소를 시퀀스에서 제거하십시오. 이 변환은 게으 르며 결과가 순회 될 때만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="154733fd338d63aa2d2c057d675c182891618bf4" translate="yes" xml:space="preserve">
          <source>Remove the first element of the stream, possibly unfreezing it before.</source>
          <target state="translated">스트림의 첫 번째 요소를 제거하고 이전에 고정 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7086cf1b363660ebe16e430065ac77061a13da5" translate="yes" xml:space="preserve">
          <source>Remove the given directory from the list of directories searched for source and compiled files. Do nothing if the list does not contain the given directory.</source>
          <target state="translated">소스 및 컴파일 된 파일을 검색 한 디렉토리 목록에서 주어진 디렉토리를 제거하십시오. 목록에 주어진 디렉토리가 없으면 아무 작업도하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d75cdb70394e3076742148661a4f0d138cc86e65" translate="yes" xml:space="preserve">
          <source>Remove the given file name from the file system.</source>
          <target state="translated">파일 시스템에서 주어진 파일 이름을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="262409bb33e2295bb03d4481acb2bd31bdd6a400" translate="yes" xml:space="preserve">
          <source>Remove the named function from the table of toplevel printers.</source>
          <target state="translated">최상위 프린터 테이블에서 명명 된 함수를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="b422e6336e9a1f5c8e7676d4cec59ce1f3784507" translate="yes" xml:space="preserve">
          <source>Remove the named function from the table of value printers.</source>
          <target state="translated">값 프린터 테이블에서 명명 된 함수를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="4ee176e699b353c43f07d0d5894fb3b5591faa05" translate="yes" xml:space="preserve">
          <source>Remove unused function arguments even when the argument is not specialised. This may have a small performance penalty. See section &lt;a href=&quot;#ss%3Aflambda-remove-unused-args&quot;&gt;21.10.3&lt;/a&gt;.</source>
          <target state="translated">인수가 특수화되지 않은 경우에도 사용하지 않는 함수 인수를 제거하십시오. 이것은 약간의 성능 저하가있을 수 있습니다. 섹션 &lt;a href=&quot;#ss%3Aflambda-remove-unused-args&quot;&gt;21.10.3을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="65afa3a5b7a241b9b346985f5c59de2a52cab400" translate="yes" xml:space="preserve">
          <source>Removes the named file</source>
          <target state="translated">명명 된 파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="604bf9f212cb4c463abdb6d2939a2df34df83931" translate="yes" xml:space="preserve">
          <source>Removes the named file.</source>
          <target state="translated">명명 된 파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="de8b3ff4a64a143b656296bc695d5afd78e79aa5" translate="yes" xml:space="preserve">
          <source>Rename a file.</source>
          <target state="translated">파일 이름을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="7720bbeaac7a5506aba04ac2c6b2a56b722aedef" translate="yes" xml:space="preserve">
          <source>Rename a file. &lt;code&gt;rename&amp;nbsp;oldpath&amp;nbsp;newpath&lt;/code&gt; renames the file called &lt;code&gt;oldpath&lt;/code&gt;, giving it &lt;code&gt;newpath&lt;/code&gt; as its new name, moving it between directories if needed. If &lt;code&gt;newpath&lt;/code&gt; already exists, its contents will be replaced with those of &lt;code&gt;oldpath&lt;/code&gt;. Depending on the operating system, the metadata (permissions, owner, etc) of &lt;code&gt;newpath&lt;/code&gt; can either be preserved or be replaced by those of &lt;code&gt;oldpath&lt;/code&gt;.</source>
          <target state="translated">파일 이름을 바꿉니다. &lt;code&gt;rename&amp;nbsp;oldpath&amp;nbsp;newpath&lt;/code&gt; 라는 파일 이름을 변경 &lt;code&gt;oldpath&lt;/code&gt; 는을 이주는 &lt;code&gt;newpath&lt;/code&gt; 가 필요한 경우 디렉토리 사이를 이동, 새로운 이름으로. 경우 &lt;code&gt;newpath&lt;/code&gt; 를가 이미 존재, 그 내용들로 대체됩니다 &lt;code&gt;oldpath&lt;/code&gt; 는 . 운영 체제에 따라 &lt;code&gt;newpath&lt;/code&gt; 의 메타 데이터 (권한, 소유자 등)는 보존되거나 &lt;code&gt;oldpath&lt;/code&gt; 의 메타 데이터 로 대체 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc5cc2bb555df30d0e6eb7d5f83b5d27a1ab09a6" translate="yes" xml:space="preserve">
          <source>Rename the files containing A and B to Mylib__A and Mylib__B.</source>
          <target state="translated">A와 B가 포함 된 파일의 이름을 Mylib__A 및 Mylib__B로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="c385e347b2af0a4d67c9b1c9902c4b0b140d1abd" translate="yes" xml:space="preserve">
          <source>Replacement</source>
          <target state="translated">Replacement</target>
        </trans-unit>
        <trans-unit id="4af5403b14a97b367235b42df07a20480e0e8dc8" translate="yes" xml:space="preserve">
          <source>Report also the children that receive stop signals.</source>
          <target state="translated">정지 신호를받은 어린이도보고하십시오.</target>
        </trans-unit>
        <trans-unit id="31955c1eb0a065ad822d3b3d4ad5258e4de34617" translate="yes" xml:space="preserve">
          <source>Report the socket type</source>
          <target state="translated">소켓 유형보고</target>
        </trans-unit>
        <trans-unit id="b995b5804e4a58ffb2ca58aa3da67303300eebb1" translate="yes" xml:space="preserve">
          <source>Report whether socket listening is enabled</source>
          <target state="translated">소켓 수신 활성화 여부보고</target>
        </trans-unit>
        <trans-unit id="74f3137f7768beda858520d1ea23501430d993b1" translate="yes" xml:space="preserve">
          <source>Reposition the descriptor to the beginning of the directory</source>
          <target state="translated">설명자를 디렉토리의 시작으로 재배치합니다.</target>
        </trans-unit>
        <trans-unit id="360bc539904b3901915f57b0aead8cb40373f0de" translate="yes" xml:space="preserve">
          <source>Representation</source>
          <target state="translated">Representation</target>
        </trans-unit>
        <trans-unit id="355b1015abcd18678f55cad9402d887e0ca4b33c" translate="yes" xml:space="preserve">
          <source>Reraise the exception using the given raw_backtrace for the origin of the exception</source>
          <target state="translated">예외의 원인에 대해 지정된 raw_backtrace를 사용하여 예외를 다시 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="296dc2dc7b2de91362fa32e69066f2f832ae36c7" translate="yes" xml:space="preserve">
          <source>Reset the search path. This requires confirmation.</source>
          <target state="translated">검색 경로를 재설정하십시오. 확인이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="295d138411ff2d3558e23677e76f1c926ca63f6d" translate="yes" xml:space="preserve">
          <source>Resizing of stacks and memory manager tables.</source>
          <target state="translated">스택 및 메모리 관리자 테이블 크기 조정.</target>
        </trans-unit>
        <trans-unit id="4d2b9449646a0ee5d5e77b1f7dfdbd7898f4fbf0" translate="yes" xml:space="preserve">
          <source>Resource deadlock would occur</source>
          <target state="translated">리소스 교착 상태가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="449bb9231a38851e27ffef4f8fb9c50338c502b0" translate="yes" xml:space="preserve">
          <source>Resource temporarily unavailable; try again</source>
          <target state="translated">리소스를 일시적으로 사용할 수 없습니다. 다시 시도하십시오</target>
        </trans-unit>
        <trans-unit id="ec49ae807f32a58e971b5d6d176e30540b9c5004" translate="yes" xml:space="preserve">
          <source>Resource unavailable</source>
          <target state="translated">리소스를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="29e3e7a7da9b9395cec89d34d65a1a1b2f7fa2d8" translate="yes" xml:space="preserve">
          <source>Restricting the PrioQueue structure by this signature results in another view of the PrioQueue structure where the remove_top function is not accessible and the actual representation of priority queues is hidden:</source>
          <target state="translated">이 서명으로 PrioQueue 구조를 제한하면 remove_top 함수에 액세스 할 수없고 우선 순위 큐의 실제 표현이 숨겨지는 PrioQueue 구조의 또 다른보기가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5faa59d4bc3756040b8ce9e673c09f929e6ee9ba" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">Result</target>
        </trans-unit>
        <trans-unit id="299a15e6a23badee14ff1ded59c353807a27199b" translate="yes" xml:space="preserve">
          <source>Result too large</source>
          <target state="translated">결과가 너무 큽니다.</target>
        </trans-unit>
        <trans-unit id="3209d576f81c84414e8e8f7fb17ec71753c4c605" translate="yes" xml:space="preserve">
          <source>Result type</source>
          <target state="translated">결과 유형</target>
        </trans-unit>
        <trans-unit id="eff426904f949a5bd0420c1f1a0fa5c365e9b7cf" translate="yes" xml:space="preserve">
          <source>Result values handle computation results and errors in an explicit and declarative manner without resorting to exceptions.</source>
          <target state="translated">결과 값은 예외에 의존하지 않고 명시적이고 선언적인 방식으로 계산 결과 및 오류를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="e5e52a78448e1694bad44e829c624deb768c1a7b" translate="yes" xml:space="preserve">
          <source>Result values.</source>
          <target state="translated">결과 값.</target>
        </trans-unit>
        <trans-unit id="612e12d29278b5519294bc25cdaddffec6d0f1c6" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="translated">Results</target>
        </trans-unit>
        <trans-unit id="d79bd092e077fc09c2c60f3a10064d1ff431ce29" translate="yes" xml:space="preserve">
          <source>Return 30 random bits in a nonnegative integer.</source>
          <target state="translated">음이 아닌 정수로 30 개의 임의 비트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1fa095160436e3371f86a43a981b3849b81bf640" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;()&lt;/code&gt; if the stream is empty, else raise &lt;a href=&quot;stream#EXCEPTIONFailure&quot;&gt;&lt;code&gt;Stream.Failure&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 &lt;code&gt;()&lt;/code&gt; 스트림이, 다른 인상 비어있는 경우 &lt;a href=&quot;stream#EXCEPTIONFailure&quot;&gt; &lt;code&gt;Stream.Failure&lt;/code&gt; 가&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="593f7c342701e8ec458be23245e66f430d3e4385" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;(minor_words,&amp;nbsp;promoted_words,&amp;nbsp;major_words)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(minor_words,&amp;nbsp;promoted_words,&amp;nbsp;major_words)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="550faf169ef998eb1fa031a11f506f86d397328c" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;(minor_words,&amp;nbsp;promoted_words,&amp;nbsp;major_words)&lt;/code&gt;. This function is as fast as &lt;code&gt;quick_stat&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(minor_words,&amp;nbsp;promoted_words,&amp;nbsp;major_words)&lt;/code&gt; 반환합니다 . 이 함수는 &lt;code&gt;quick_stat&lt;/code&gt; 만큼 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="9f0b04958e3d5768c711ed65e736e75e41370385" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;None&lt;/code&gt; if the given string is not a valid representation of a float.</source>
          <target state="translated">돌아 오지 &lt;code&gt;None&lt;/code&gt; 주어진 문자열이 부동의 유효한 표현이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="c545d6d7e7201b009d3907cdeef8a3094f6baaaf" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;None&lt;/code&gt; if the given string is not a valid representation of an integer, or if the integer represented exceeds the range of integers representable in type &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;None&lt;/code&gt; 지정된 문자열은 정수의 올바른 표현하지 않거나 나타내지 정수 넘으면 정수 범위는 타입에서 표현할 수있는 경우 &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da7031cc3ae71e32dda9f527b40a39b784155601" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;None&lt;/code&gt; if the line read is not a valid representation of a floating-point number.</source>
          <target state="translated">돌아 오지 &lt;code&gt;None&lt;/code&gt; 라인 읽기 부동 소수점 숫자의 유효한 표현이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="eb750c7d172d1acc02da983e44f7470133e58fa7" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;None&lt;/code&gt; if the line read is not a valid representation of an integer.</source>
          <target state="translated">읽은 행이 정수의 유효한 표현이 아닌 경우 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4c08ab7d1ba46fbe58475fb0109d0a5d45d82a5b" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;None&lt;/code&gt; if the string is not &lt;code&gt;&quot;true&quot;&lt;/code&gt; or &lt;code&gt;&quot;false&quot;&lt;/code&gt;.</source>
          <target state="translated">반환 &lt;code&gt;None&lt;/code&gt; 문자열이 아닌 경우 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 로 또는 &lt;code&gt;&quot;false&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a9bf0c2b04774eefa1cb998fa96e21caf677aa9" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;Some&lt;/code&gt; of &quot;the first element&quot; of the stream, or &lt;code&gt;None&lt;/code&gt; if the stream is empty.</source>
          <target state="translated">스트림의 &quot;첫 번째 요소&quot; &lt;code&gt;Some&lt;/code&gt; 를 반환 하거나 스트림이 비어있는 경우 &lt;code&gt;None&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e5292c8ae26a2eae7733924ca1310706bedf5f1b" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;true&lt;/code&gt; if the file name is relative and does not start with an explicit reference to the current directory (&lt;code&gt;./&lt;/code&gt; or &lt;code&gt;../&lt;/code&gt; in Unix), &lt;code&gt;false&lt;/code&gt; if it starts with an explicit reference to the root directory or the current directory.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 파일 이름이 상대적이며 (현재 디렉토리를 명시 적으로 참조하여 시작되지 않는 경우 &lt;code&gt;./&lt;/code&gt; 또는 &lt;code&gt;../&lt;/code&gt; , 유닉스에서) &lt;code&gt;false&lt;/code&gt; 이 루트 디렉토리 또는 현재 디렉토리를 명시 적으로 참조하여 시작합니다.</target>
        </trans-unit>
        <trans-unit id="030a8f8301c3d1e7373bffe5d869f33138c7c3d8" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;true&lt;/code&gt; if the file name is relative to the current directory, &lt;code&gt;false&lt;/code&gt; if it is absolute (i.e.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 파일 이름이 현재 디렉토리를 기준으로하면, &lt;code&gt;false&lt;/code&gt; 가 절대 인 경우 (즉,</target>
        </trans-unit>
        <trans-unit id="4b0417d3670b3192288bd57b2b9590c65ba93693" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;true&lt;/code&gt; if the file name is relative to the current directory, &lt;code&gt;false&lt;/code&gt; if it is absolute (i.e. in Unix, starts with &lt;code&gt;/&lt;/code&gt;).</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 파일 이름이 현재 디렉토리를 기준으로하면, &lt;code&gt;false&lt;/code&gt; 가 절대 인 경우 (시작으로, 유닉스 즉, &lt;code&gt;/&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a015b737ab1e9eb668c2cceaf398634872781ae2" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;true&lt;/code&gt; if the given file descriptor refers to a terminal or console window, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 주어진 파일 기술자가 터미널 또는 콘솔 창을 참조하는 경우 &lt;code&gt;false&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="63f3b056b45d4d28af4aaf0cff1c1765dbae49af" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;true&lt;/code&gt; if the given queue is empty, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; , 지정된 큐가 비어있는 경우 &lt;code&gt;false&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="3d192ae098f93a15f44ef685976f769d2b43da8a" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;true&lt;/code&gt; if the given stack is empty, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">반환 &lt;code&gt;true&lt;/code&gt; 주어진 스택이 하늘 인 경우 &lt;code&gt;false&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="45f1622b98a145c2db6db8c2f9d7a5e025a1042e" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with all lowercase letters translated to uppercase, including accented letters of the ISO Latin-1 (8859-1) character set.</source>
          <target state="translated">ISO Latin-1 (8859-1) 문자 집합의 악센트 부호가있는 문자를 포함하여 모든 소문자가 대문자로 번역 된 인수의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="127b47230d0d9b183fb460c794103afb437a3f74" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with all lowercase letters translated to uppercase, using the US-ASCII character set.</source>
          <target state="translated">US-ASCII 문자 집합을 사용하여 모든 소문자가 대문자로 번역 된 인수의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="44df7d1f4660ce15440564ef6140d488f89e8817" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with all uppercase letters translated to lowercase, including accented letters of the ISO Latin-1 (8859-1) character set.</source>
          <target state="translated">ISO Latin-1 (8859-1) 문자 집합의 악센트 부호가있는 문자를 포함하여 모든 대문자가 소문자로 번역 된 인수의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="003998c9bfbb3770499527204f4346a8d1868e5a" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with all uppercase letters translated to lowercase, using the US-ASCII character set.</source>
          <target state="translated">US-ASCII 문자 집합을 사용하여 모든 대문자가 소문자로 번역 된 인수의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5a3d642112c3a92152f04255363b1ba2fa9a2589" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml.</source>
          <target state="translated">OCaml의 어휘 규칙에 따라 이스케이프 시퀀스로 표시되는 특수 문자와 함께 인수의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1a4a332a5b94aa334390f511abb510b3ddb62618" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml. All characters outside the ASCII printable range (32..126) are escaped, as well as backslash and double-quote.</source>
          <target state="translated">OCaml의 어휘 규칙에 따라 이스케이프 시퀀스로 표시되는 특수 문자와 함께 인수의 복사본을 반환합니다. ASCII 인쇄 가능 범위 (32..126)를 벗어난 모든 문자는 물론 백 슬래시 및 큰 따옴표도 이스케이프됩니다.</target>
        </trans-unit>
        <trans-unit id="03f41a484dc0ff3d58c57c1442a5f726ce61570b" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml. If there is no special character in the argument, return the original string itself, not a copy. Its inverse function is Scanf.unescaped.</source>
          <target state="translated">OCaml의 어휘 규칙에 따라 이스케이프 시퀀스로 표시되는 특수 문자와 함께 인수의 복사본을 반환합니다. 인수에 특수 문자가 없으면 복사본이 아닌 원래 문자열 자체를 반환합니다. 역함수는 Scanf.unescaped입니다.</target>
        </trans-unit>
        <trans-unit id="69572fdafff64426a35c582a448aa44913d1d625" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with the first character set to lowercase, using the ISO Latin-1 (8859-1) character set..</source>
          <target state="translated">ISO Latin-1 (8859-1) 문자 집합을 사용하여 첫 번째 문자가 소문자로 설정된 인수의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fd2d2d82cb94ada562d6a342e526b209b60b887f" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with the first character set to lowercase, using the US-ASCII character set.</source>
          <target state="translated">US-ASCII 문자 집합을 사용하여 첫 번째 문자가 소문자로 설정된 인수의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7bdec61eece118da7a683a1371f3a01fee398774" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with the first character set to uppercase, using the ISO Latin-1 (8859-1) character set..</source>
          <target state="translated">ISO Latin-1 (8859-1) 문자 집합을 사용하여 첫 번째 문자가 대문자로 설정된 인수의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="864a8ca7c0f4e575f15013bf4127c071a3cb479f" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, with the first character set to uppercase, using the US-ASCII character set.</source>
          <target state="translated">US-ASCII 문자 집합을 사용하여 첫 번째 문자가 대문자로 설정된 인수의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="36b16f76788b251356e4d1d6761232482d9e6cfe" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, without leading and trailing whitespace.</source>
          <target state="translated">선행 및 후행 공백없이 인수의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b23827dffec2b473204f6248d962a6ed70248d91" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, without leading and trailing whitespace. The bytes regarded as whitespace are the ASCII characters &lt;code&gt;'&amp;nbsp;'&lt;/code&gt;, &lt;code&gt;'\012'&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;'\r'&lt;/code&gt;, and &lt;code&gt;'\t'&lt;/code&gt;.</source>
          <target state="translated">선행 및 후행 공백없이 인수의 복사본을 반환합니다. 공백으로 간주되는 바이트는 ASCII 문자 &lt;code&gt;'&amp;nbsp;'&lt;/code&gt; , &lt;code&gt;'\012'&lt;/code&gt; , &lt;code&gt;'\n'&lt;/code&gt; , &lt;code&gt;'\r'&lt;/code&gt; 및 &lt;code&gt;'\t'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="60901456f742a0ed9dbc830f83569b7759f1d0ef" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, without leading and trailing whitespace. The characters regarded as whitespace are: &lt;code&gt;'&amp;nbsp;'&lt;/code&gt;, &lt;code&gt;'\012'&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;'\r'&lt;/code&gt;, and &lt;code&gt;'\t'&lt;/code&gt;. If there is neither leading nor trailing whitespace character in the argument, return the original string itself, not a copy.</source>
          <target state="translated">선행 및 후행 공백없이 인수의 복사본을 반환합니다. 공백으로 간주되는 문자는 &lt;code&gt;'&amp;nbsp;'&lt;/code&gt; , &lt;code&gt;'\012'&lt;/code&gt; , &lt;code&gt;'\n'&lt;/code&gt; , &lt;code&gt;'\r'&lt;/code&gt; 및 &lt;code&gt;'\t'&lt;/code&gt; 입니다. 인수에 선행 또는 후행 공백 문자가 없으면 복사본이 아닌 원래 문자열 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d4f5b339b958187225951bea4339edf97319b51f" translate="yes" xml:space="preserve">
          <source>Return a copy of the argument, without leading and trailing whitespace. The characters regarded as whitespace are: &lt;code&gt;'&amp;nbsp;'&lt;/code&gt;, &lt;code&gt;'\012'&lt;/code&gt;, &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;'\r'&lt;/code&gt;, and &lt;code&gt;'\t'&lt;/code&gt;. If there is no leading nor trailing whitespace character in the argument, return the original string itself, not a copy.</source>
          <target state="translated">선행 및 후행 공백없이 인수의 복사본을 반환합니다. 공백으로 간주되는 문자는 &lt;code&gt;'&amp;nbsp;'&lt;/code&gt; , &lt;code&gt;'\012'&lt;/code&gt; , &lt;code&gt;'\n'&lt;/code&gt; , &lt;code&gt;'\r'&lt;/code&gt; 및 &lt;code&gt;'\t'&lt;/code&gt; 입니다. 인수에 선행 또는 후행 공백 문자가 없으면 복사본이 아닌 원래 문자열 자체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1f0d1f1cd1efa4cd387335c99c184eb54c9a2799" translate="yes" xml:space="preserve">
          <source>Return a copy of the current contents of the buffer.</source>
          <target state="translated">버퍼의 현재 내용의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fbd80ca31570862a4af03aabff797ab0adc0d40f" translate="yes" xml:space="preserve">
          <source>Return a copy of the current contents of the buffer. The buffer itself is unchanged.</source>
          <target state="translated">버퍼의 현재 내용의 복사본을 반환합니다. 버퍼 자체는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e2c49b318ff8a7310eff42bce315e30f2c05660" translate="yes" xml:space="preserve">
          <source>Return a copy of the given hashtable.</source>
          <target state="translated">주어진 해시 테이블의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7fb9371aa6a43be6ab72a21320b2f310a5cd11cb" translate="yes" xml:space="preserve">
          <source>Return a copy of the given queue.</source>
          <target state="translated">주어진 큐의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="88e995de1b77c7933088c28dae39cec90133db31" translate="yes" xml:space="preserve">
          <source>Return a copy of the given stack.</source>
          <target state="translated">주어진 스택의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="93bf205a4b71edb1af1ca3b4635ed7d07eb9abaa" translate="yes" xml:space="preserve">
          <source>Return a copy of the given state.</source>
          <target state="translated">주어진 상태의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5db994c18b13ca47f2460850e0609a5cda1c1ad0" translate="yes" xml:space="preserve">
          <source>Return a copy of the given string.</source>
          <target state="translated">주어진 문자열의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9eb890add67386c423d7d9d793c6fd6e71086858" translate="yes" xml:space="preserve">
          <source>Return a fresh reference containing the given value.</source>
          <target state="translated">주어진 값을 포함하는 새로운 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7f6e164b350620b04bdde9dfe7361263308ce8c1" translate="yes" xml:space="preserve">
          <source>Return a new byte sequence that contains the same bytes as the argument.</source>
          <target state="translated">인수와 동일한 바이트를 포함하는 새 바이트 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3288df26f3728e4af6621ea5a70e0e92d0691d62" translate="yes" xml:space="preserve">
          <source>Return a new byte sequence that contains the same bytes as the given string.</source>
          <target state="translated">주어진 문자열과 동일한 바이트를 포함하는 새 바이트 시퀀스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e35d88ad5aec4e0bee772d3ccb669d6e610bda6f" translate="yes" xml:space="preserve">
          <source>Return a new channel.</source>
          <target state="translated">새 채널을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4fc8680a0f4820443679c4ca33bffc768d3a4af2" translate="yes" xml:space="preserve">
          <source>Return a new condition variable.</source>
          <target state="translated">새로운 조건 변수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f73e3fd5045de7f968d83b57ce77ff2e244d6d94" translate="yes" xml:space="preserve">
          <source>Return a new file descriptor referencing the same file as the given descriptor.</source>
          <target state="translated">주어진 설명자와 동일한 파일을 참조하는 새 파일 설명자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="022bd62ac3f4fef8b66c421752d380647a257c3e" translate="yes" xml:space="preserve">
          <source>Return a new file descriptor referencing the same file as the given descriptor. See &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt;&lt;code&gt;Unix.set_close_on_exec&lt;/code&gt;&lt;/a&gt; for documentation on the &lt;code&gt;cloexec&lt;/code&gt; optional argument.</source>
          <target state="translated">주어진 설명자와 동일한 파일을 참조하는 새 파일 설명자를 반환합니다. &lt;code&gt;cloexec&lt;/code&gt; 선택적 인수 에 대한 문서는 &lt;a href=&quot;unix#VALset_close_on_exec&quot;&gt; &lt;code&gt;Unix.set_close_on_exec&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bbc741461c44e92671a1d3e08ce17aef58d13652" translate="yes" xml:space="preserve">
          <source>Return a new mutex.</source>
          <target state="translated">새로운 뮤텍스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a250463867298e9eaf9678c8350c6716043386cc" translate="yes" xml:space="preserve">
          <source>Return a new queue, initially empty.</source>
          <target state="translated">처음에는 비어있는 새 대기열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="29293bb0256d01cced68ba9adcdef7067e73cc71" translate="yes" xml:space="preserve">
          <source>Return a new stack, initially empty.</source>
          <target state="translated">처음에는 비어있는 새 스택을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b632b9591eab85fbc96a1c3fd08f92e29ab6f5bc" translate="yes" xml:space="preserve">
          <source>Return a new string that contains the same bytes as the given byte sequence.</source>
          <target state="translated">주어진 바이트 시퀀스와 동일한 바이트를 포함하는 새 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eaa2ddecfab0e29c2e8e9bbf8c5bc2d1ac627095" translate="yes" xml:space="preserve">
          <source>Return a quoted version of a file name, suitable for use as one argument in a command line, escaping all meta-characters.</source>
          <target state="translated">모든 메타 문자를 이스케이프하고 명령 줄에서 하나의 인수로 사용하기에 적합한 파일 이름의 인용 된 버전을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eb33ef2fdd22ebcc2818d5a53e55762ccaf36484" translate="yes" xml:space="preserve">
          <source>Return a quoted version of a file name, suitable for use as one argument in a command line, escaping all meta-characters. Warning: under Windows, the output is only suitable for use with programs that follow the standard Windows quoting conventions.</source>
          <target state="translated">모든 메타 문자를 이스케이프하고 명령 줄에서 하나의 인수로 사용하기에 적합한 파일 이름의 인용 된 버전을 반환합니다. 경고 : Windows에서 출력은 표준 Windows 인용 규칙을 따르는 프로그램에서만 사용하기에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="008c82eb7a3488f2068808aaf085122455ce86c2" translate="yes" xml:space="preserve">
          <source>Return a string describing the given error code.</source>
          <target state="translated">주어진 오류 코드를 설명하는 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6308615f291e3990cb87826cb856a820e487ae9b" translate="yes" xml:space="preserve">
          <source>Return a string from a raw backtrace, in the same format &lt;code&gt;Printexc.get_backtrace&lt;/code&gt; uses.</source>
          <target state="translated">&lt;code&gt;Printexc.get_backtrace&lt;/code&gt; 가 사용 하는 것과 동일한 형식으로 원시 역 추적에서 문자열을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="12151c7c9dff07c2f242a2cf5034d277c5760738" translate="yes" xml:space="preserve">
          <source>Return a string representing the given character, with special characters escaped following the lexical conventions of OCaml.</source>
          <target state="translated">OCaml의 어휘 규칙에 따라 이스케이프 된 특수 문자와 함께 주어진 문자를 나타내는 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ae4c08f96ad04052340d504c28314a0c07f4294" translate="yes" xml:space="preserve">
          <source>Return a string representing the given character, with special characters escaped following the lexical conventions of OCaml. All characters outside the ASCII printable range (32..126) are escaped, as well as backslash, double-quote, and single-quote.</source>
          <target state="translated">OCaml의 어휘 규칙에 따라 이스케이프 된 특수 문자와 함께 주어진 문자를 나타내는 문자열을 반환합니다. ASCII 인쇄 가능 범위 (32..126)를 벗어난 모든 문자는 물론 백 슬래시, 큰 따옴표 및 작은 따옴표도 이스케이프됩니다.</target>
        </trans-unit>
        <trans-unit id="3e8e3e80004732f400a60500d80e26ba6bb55cfe" translate="yes" xml:space="preserve">
          <source>Return an OCaml Bigarray wrapping the data pointed to by p. kind is the kind of array elements (one of the CAML_BA_ kind constants above). layout is CAML_BA_C_LAYOUT for an array with C layout and CAML_BA_FORTRAN_LAYOUT for an array with Fortran layout. numdims is the number of dimensions in the array. dims is an array of numdims long integers, giving the sizes of the array in each dimension.</source>
          <target state="translated">p가 가리키는 데이터를 래핑하는 OCaml Bigarray를 반환합니다. kind는 배열 요소의 종류입니다 (위의 CAML_BA_ 종류 상수 중 하나). layout은 C 레이아웃이있는 배열의 경우 CAML_BA_C_LAYOUT이고 Fortran 레이아웃이있는 배열의 경우 CAML_BA_FORTRAN_LAYOUT입니다. numdims는 배열의 차원 수입니다. dims는 각 차원의 배열 크기를 제공하는 numdims long 정수의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="0c740844be0e075a677fcb6369986cf1020d7188" translate="yes" xml:space="preserve">
          <source>Return an integer identifying this object, unique for the current execution of the program.</source>
          <target state="translated">현재 프로그램 실행에 고유 한이 객체를 식별하는 정수를 반환합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
