<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="aef308ac0940e6d74a453eb280aef926fedc4674" translate="yes" xml:space="preserve">
          <source>Unboxed integer values (ASCII code).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6736fe7df2039684117bc316d99716a708ed0a5f" translate="yes" xml:space="preserve">
          <source>Unboxed integer values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e121c34de9aeb900b4b306f512b07e8a250bb6" translate="yes" xml:space="preserve">
          <source>Unboxing of the closure causes the value for x inside g to be passed as an argument to g rather than through its closure. This means that the closure of g becomes constant and may be lifted to toplevel, eliminating the runtime allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a0f02f56bad3e9e2035809eac95fd20eaae739" translate="yes" xml:space="preserve">
          <source>Uncaught exception</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd6e9bbc140db8671611ddd7fc62a9229a86b7b8" translate="yes" xml:space="preserve">
          <source>Uncaught exceptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbda3791626315021f610d03deb27c5845679a10" translate="yes" xml:space="preserve">
          <source>Undeclared virtual method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff4417ab4221f5d44f5639177b205205ee72e6ec" translate="yes" xml:space="preserve">
          <source>Under Unix and Cygwin, the command, the arguments, and the redirections if any are quoted using &lt;a href=&quot;filename#VALquote&quot;&gt;&lt;code&gt;Filename.quote&lt;/code&gt;&lt;/a&gt;, then concatenated. Under Win32, additional quoting is performed as required by the &lt;code&gt;cmd.exe&lt;/code&gt; shell that is called by &lt;a href=&quot;sys#VALcommand&quot;&gt;&lt;code&gt;Sys.command&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73ae8ab7df9ff2bd31ec5aefbc5d4b384fca6a0c" translate="yes" xml:space="preserve">
          <source>Under Windows ports (including Cygwin), comparison is case-insensitive, relying on &lt;code&gt;String.lowercase_ascii&lt;/code&gt;. Note that this does not match exactly the interpretation of case-insensitive filename equivalence from Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c30b17bfee8b41cae9acaf0fd4f36055ec37a0" translate="yes" xml:space="preserve">
          <source>Under Windows, use a forward slash (/) as the path separator instead of the usual backward slash (\). Under Unix, this option does nothing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2a98cf876c70e2d8f2c5c551aa28d19bc9e9f0b" translate="yes" xml:space="preserve">
          <source>Under the interactive system, the user types OCaml phrases terminated by ;; in response to the # prompt, and the system compiles them on the fly, executes them, and prints the outcome of evaluation. Phrases are either simple expressions, or let definitions of identifiers (either values or functions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9b219af612756cb93e821fb5ae6c25750a8208b" translate="yes" xml:space="preserve">
          <source>Undocumented functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f972e21664aacd3d93f9c25c031fdd4f9b63cac" translate="yes" xml:space="preserve">
          <source>Unerasable optional argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="855db78e2b7ecfbfa45751560055e580b1f0426b" translate="yes" xml:space="preserve">
          <source>Unescaped end-of-line in a string constant (non-portable code).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="430e184cd12c9c60b3c1f834e3311ddc5fd18ef3" translate="yes" xml:space="preserve">
          <source>Unexpected documentation comment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c26d585a4a4c58b3670977403cc6faff38857d45" translate="yes" xml:space="preserve">
          <source>Unicode characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a06870dcfd727858fe36ec3a78338d13e1109e1" translate="yes" xml:space="preserve">
          <source>Unicode mode: All path names, environment variables, command line arguments, etc. on the OCaml side are assumed to be encoded using UTF-8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b2a3b5d1d14ff610dc48ac49c4fe2d90f085c55" translate="yes" xml:space="preserve">
          <source>Unique ownership is linear: passing the data to another piece of code means giving up ownership (we cannot write the data again). A unique owner may decide to make the data shared (giving up mutation rights on it), but shared data may not become uniquely-owned again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="718811898739c2de10551b3e57d44b08120ca419" translate="yes" xml:space="preserve">
          <source>Unique ownership: the data may be accessed and mutated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6b935ab337145efdeadda28cae18aa89a845e36" translate="yes" xml:space="preserve">
          <source>Unit</source>
          <target state="translated">Unit</target>
        </trans-unit>
        <trans-unit id="913f68f196b9229e63375dbfc548fa272e1c3652" translate="yes" xml:space="preserve">
          <source>Unit operations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f17d2a7a76cbbf26af7818ae32de850d9448591" translate="yes" xml:space="preserve">
          <source>Unit values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cecc0d8500754b34f5bd7f11dfabb25c3a770aaf" translate="yes" xml:space="preserve">
          <source>Unix</source>
          <target state="translated">Unix</target>
        </trans-unit>
        <trans-unit id="9e87341cccc0656f2e5b6f6b5247bbf87754da13" translate="yes" xml:space="preserve">
          <source>Unix domain</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="142fc83cd03cb48dcec9f0e42a287de6093e6ef6" translate="yes" xml:space="preserve">
          <source>Unix: Never use the strip command on executables produced by ocamlc -custom, this would remove the bytecode part of the executable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4828c0275236c958b5d9f93626a6a151b8a88209" translate="yes" xml:space="preserve">
          <source>Unix: Security warning: never set the &amp;ldquo;setuid&amp;rdquo; or &amp;ldquo;setgid&amp;rdquo; bits on executables produced by ocamlc -custom, this would make them vulnerable to attacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8628c58b8b0ed243ff4d2c25335007aa2662e49" translate="yes" xml:space="preserve">
          <source>Unix: The debugger is available on Unix systems that provide BSD sockets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad2d5a3a8eb281aff095c532257d99f6e760b2f3" translate="yes" xml:space="preserve">
          <source>Unix: The following environment variables are also consulted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64ef177b89fca776de0c9cae01ff751ad7998744" translate="yes" xml:space="preserve">
          <source>Unix: The toplevel system is started by the command ocaml, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b888195998eac2b4be7e68badf7f6b41f579a285" translate="yes" xml:space="preserve">
          <source>Unix: This is material specific to the Unix family of operating systems, including Linux and macOS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361cde79cb6eba9a80e1a3a1b776b3f1a76b9944" translate="yes" xml:space="preserve">
          <source>UnixLabels</source>
          <target state="translated">UnixLabels</target>
        </trans-unit>
        <trans-unit id="e5fd9aa24c9417e7332e6f25936ae2a6ec8f1524" translate="yes" xml:space="preserve">
          <source>Unknown error</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afd278add8fd7700e1517d25235a824bc141942f" translate="yes" xml:space="preserve">
          <source>Unless overridden by an attribute (see below), specialisation of a function will not be attempted if:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c39064849c793d38854fa83e22673292ca5cc1ab" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;unix#VALgetenv&quot;&gt;&lt;code&gt;Unix.getenv&lt;/code&gt;&lt;/a&gt;, this function returns the value even if the process has special privileges. It is considered unsafe because the programmer of a setuid or setgid program must be careful to avoid using maliciously crafted environment variables in the search path for executables, the locations for temporary files or logs, and the like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="170fdfcfd23bafa2fc167cc8615430aab46288f6" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;unixlabels#VALgetenv&quot;&gt;&lt;code&gt;UnixLabels.getenv&lt;/code&gt;&lt;/a&gt;, this function returns the value even if the process has special privileges. It is considered unsafe because the programmer of a setuid or setgid program must be careful to avoid using maliciously crafted environment variables in the search path for executables, the locations for temporary files or logs, and the like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb26dc7c0f8b5f19a49a3bac89490729e6e63f3" translate="yes" xml:space="preserve">
          <source>Unlike &lt;em&gt;eventlog-tools&lt;/em&gt;, which possesses a specific knowledge of OCaml&amp;rsquo;s &lt;em&gt;Common Trace Format&lt;/em&gt; schema, it is required to provide the OCaml &lt;em&gt;metadata&lt;/em&gt; file to &lt;em&gt;babeltrace&lt;/em&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a10e065515b33488b54ddec47d446cd640967c7" translate="yes" xml:space="preserve">
          <source>Unlike a regular type abbreviation, a private type abbreviation declares a type that is distinct from its implementation type &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;. However, coercions from the type to &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; are permitted. Moreover, the compiler &amp;ldquo;knows&amp;rdquo; the implementation type and can take advantage of this knowledge to perform type-directed optimizations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80af5ea86d75496571d4eb5e961951632ea1c005" translate="yes" xml:space="preserve">
          <source>Unlike classes, which cannot be defined inside an expression, immediate objects can appear anywhere, using variables from their environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65e450d4c92511601f39760b7d537c5cc9300ca0" translate="yes" xml:space="preserve">
          <source>Unlike constructed values, polymorphic variant values taking several arguments are not flattened. That is, `VConstr(v, w) is represented by a block of size 2, whose field number 1 contains the representation of the pair (v, w), rather than a block of size 3 containing v and w in fields 1 and 2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf410a070338968c622e20408d5e4cb4a9c9cbd" translate="yes" xml:space="preserve">
          <source>Unlike most fuzzers, afl-fuzz observes the internal behaviour of the program being tested, and adjusts the test cases it generates to trigger unexplored execution paths. As a result, test cases generated by afl-fuzz cover more of the possible behaviours of the tested program than other fuzzers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80b8debcdfd0af497e33fd32ebd0c329ed223c51" translate="yes" xml:space="preserve">
          <source>Unlike the core Stdlib module, submodules are not automatically &amp;ldquo;opened&amp;rdquo; when compilation starts, or when the toplevel system is launched. Hence it is necessary to use qualified identifiers to refer to the functions provided by these modules, or to add open directives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df0adb297358d6f84eb38585235f761f2474eba0" translate="yes" xml:space="preserve">
          <source>Unloading the dependent shared libraries that were loaded by the runtime, including dynlink plugins.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e221fd771f76ac0c08ade26044bd31aad8410e11" translate="yes" xml:space="preserve">
          <source>Unlock a region</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbee51b6938b8833f6c9c14a960c32fc98b15cca" translate="yes" xml:space="preserve">
          <source>Unlock the given mutex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b3fedb6918f76a1d2843a6217fb0459806116b" translate="yes" xml:space="preserve">
          <source>Unlock the given mutex. Other threads suspended trying to lock the mutex will restart.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae4d55156aa4689306af92e67c36608ab8808bc" translate="yes" xml:space="preserve">
          <source>Unneeded fields can be omitted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85b0ad26af0b561093ef0ed3dfa3894398e55ee4" translate="yes" xml:space="preserve">
          <source>Unreachable case in a pattern-matching (based on type information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05779c93acf03e53c5e3dff1098251cef41b56c" translate="yes" xml:space="preserve">
          <source>Unsafe conversions (for advanced users)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2b13f45b65846cb19caeb60345a2df74e3c0fec" translate="yes" xml:space="preserve">
          <source>Unsafely convert a byte sequence into a string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="184711f70420afa3bb8971f5272f0cc7e5d58bbc" translate="yes" xml:space="preserve">
          <source>Unsafely convert a shared string to a byte sequence that should not be mutated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b10f1dd8565cd1c52a800f50a4b69101c9d0316d" translate="yes" xml:space="preserve">
          <source>Unused ancestor variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2135e52f312e0c6e0e48ccbe7c4300233af3147" translate="yes" xml:space="preserve">
          <source>Unused blocks in the heap are automatically reclaimed by the garbage collector. This requires some cooperation from C code that manipulates heap-allocated blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9d2bee7f4c5a8e21793774f016b9445cb2491e9" translate="yes" xml:space="preserve">
          <source>Unused constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8932307b60e4ea07a13fdca33701b5b386e6782" translate="yes" xml:space="preserve">
          <source>Unused extension constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bce80385d6d0c6ec6ed8b2418d97b11a8b08e5a1" translate="yes" xml:space="preserve">
          <source>Unused for-loop index.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd69a014e402f61b2816913ac1b533fe2cf4484" translate="yes" xml:space="preserve">
          <source>Unused function argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e88849e413a3426f34b869856edcd5da6f68428" translate="yes" xml:space="preserve">
          <source>Unused functor parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d908fc34cd65922d5192f731073878254bc325" translate="yes" xml:space="preserve">
          <source>Unused module declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1ca9a5d74e69edb9e1f7c3d3fe760448d92b5d0" translate="yes" xml:space="preserve">
          <source>Unused open statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368828ea89de7758a83ef5a2303643e5169a7dc6" translate="yes" xml:space="preserve">
          <source>Unused open! statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fd45978a6cade82e52fdd41f1ab2e9eff81f96c" translate="yes" xml:space="preserve">
          <source>Unused rec flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9f8d493131a0a65a3df35bc380544a58e71361a" translate="yes" xml:space="preserve">
          <source>Unused type declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9d36a6d7c0770d8a403ea5d31dd91ea42c0b008" translate="yes" xml:space="preserve">
          <source>Unused value declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb036b86a60318fcf6bf365ea7870fc31e350c6" translate="yes" xml:space="preserve">
          <source>Update the &lt;code&gt;lex_curr_p&lt;/code&gt; field of the lexbuf to reflect the start of a new line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed514447bdac477fcc7368e5493b6028c29815ca" translate="yes" xml:space="preserve">
          <source>Update the &lt;code&gt;lex_curr_p&lt;/code&gt; field of the lexbuf to reflect the start of a new line. You can call this function in the semantic action of the rule that matches the end-of-line character. The function does nothing when position tracking is disabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="537666d1dbd2fa0db7069f8d3cd01ec60272e5dd" translate="yes" xml:space="preserve">
          <source>Urgent condition on socket</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a643b76ebf1d85ac82c0fea6de291116e76f169" translate="yes" xml:space="preserve">
          <source>Use a reference to hold one of the two functions, as in :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="739d4f5d5767f58211e673bb1ebe35dad451e751" translate="yes" xml:space="preserve">
          <source>Use a short form to display functors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="151fed5b01cf4fdfa0cf96e7df2ca528006f940d" translate="yes" xml:space="preserve">
          <source>Use ccomp as the C linker called to build the final executable and as the C compiler for compiling .c source files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e95d994a10737b249b1b6ca223f5268903a19eac" translate="yes" xml:space="preserve">
          <source>Use ccomp as the C linker when linking in &amp;ldquo;custom runtime&amp;rdquo; mode (see the -custom option) and as the C compiler for compiling .c source files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7e56fe87118003db21cc87b9faea5b04603884d" translate="yes" xml:space="preserve">
          <source>Use cmd instead of ocamlc to call the bytecode compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5aa8bdfb4a918e9e6c8a6c9078f5bcb7fa49544" translate="yes" xml:space="preserve">
          <source>Use cmd instead of ocamlopt to call the native-code compiler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a54deab044fad1c4ebb1e877ef8d4262ad6c2d" translate="yes" xml:space="preserve">
          <source>Use content of file as ocamldoc text to use as introduction (HTML, L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X and TeXinfo only). For HTML, the file is used to create the whole index.html file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3bfae018cf53a781671cacffec6bc019506b2de" translate="yes" xml:space="preserve">
          <source>Use file as a script file name, even when it starts with a hyphen (-).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e89af95620878921a365ac66230e7c38ab048bbd" translate="yes" xml:space="preserve">
          <source>Use filename as the Cascading Style Sheet file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e78e4a0a07f4466e6a27ea7a18bff19f7ffd2bae" translate="yes" xml:space="preserve">
          <source>Use linear scan register allocation. Compiling with this allocator is faster than with the usual graph coloring allocator, sometimes quite drastically so for long functions and modules. On the other hand, the generated code can be a bit slower.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30651d527d291118e5c81ec20804fa7f8152da5e" translate="yes" xml:space="preserve">
          <source>Use of #-types to abbreviate polymorphic variant types is deprecated. If t is an exact variant type then #t translates to [&amp;lt;t], and #t[&amp;gt;`&lt;a href=&quot;names#tag-name&quot;&gt;tag&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;`&lt;a href=&quot;names#tag-name&quot;&gt;tag&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;] translates to [&amp;lt;t&amp;gt;`&lt;a href=&quot;names#tag-name&quot;&gt;tag&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;`&lt;a href=&quot;names#tag-name&quot;&gt;tag&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="179cb603754bb4c16dcadb3f0efdb9ceb776af51" translate="yes" xml:space="preserve">
          <source>Use of the ocamlfind utility is recommended. However, if this is not possible, an alternative method may be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="486b3ac03120a2b0d6cf25a7ef30edee35307954" translate="yes" xml:space="preserve">
          <source>Use socket for communicating with the debugged program. See the description of the command set socket (section &lt;a href=&quot;#ss%3Adebugger-communication&quot;&gt;17.8.8&lt;/a&gt;) for the format of socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="babde098406fd068128680f9d2260458e1e9bfbb" translate="yes" xml:space="preserve">
          <source>Use socket for communication with the program. socket can be either a file name, or an Internet port specification host:port, where host is a host name or an Internet address in dot notation, and port is a port number on the host.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c69190456e3d3b4a9937b9b8bc1a23ac4bcaa77e" translate="yes" xml:space="preserve">
          <source>Use symbolic formatter &lt;code&gt;ppf&lt;/code&gt; as usual, and retrieve symbolic items at end of pretty-printing by flushing symbolic output buffer &lt;code&gt;sob&lt;/code&gt; with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cd5648874a47a9e1c6b2f8873e0f3b1a2133aed" translate="yes" xml:space="preserve">
          <source>Use the IA32 instructions to compute trigonometric and exponential functions, instead of calling the corresponding library routines. The functions affected are: atan, atan2, cos, log, log10, sin, sqrt and tan. The resulting code runs faster, but the range of supported arguments and the precision of the result can be reduced. In particular, trigonometric operations cos, sin, tan have their range reduced to [&amp;minus;2&lt;sup&gt;64&lt;/sup&gt;, 2&lt;sup&gt;64&lt;/sup&gt;].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b4c58de40c5fb0e653f6415a4f1b48952e39fb" translate="yes" xml:space="preserve">
          <source>Use this function when your custom block holds only out-of-heap memory (memory allocated with malloc or caml_stat_alloc) and no other resources. used should be the number of bytes of out-of-heap memory that are held by your custom block. This function works like caml_alloc_custom except that the max parameter is under the control of the user (via the custom_major_ratio, custom_minor_ratio, and custom_minor_max_size parameters) and proportional to the heap sizes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7941ff55d3e49988c4c70473e63a19eae903c125" translate="yes" xml:space="preserve">
          <source>Use title as the title for the generated documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33cc8398531eeec1655e1c8fcddb6c0c6fd1f30b" translate="yes" xml:space="preserve">
          <source>Useful functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f394ba35c69f78febcb28d6e3e5d50c70e2e7b0" translate="yes" xml:space="preserve">
          <source>Useless record with clause.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7150f5b0ccc9ad0053128f11ad4305cc1edea658" translate="yes" xml:space="preserve">
          <source>User id of the owner</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="565cf3c85ae326fd320b914df7dffad6039c9e02" translate="yes" xml:space="preserve">
          <source>User id, group id</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21634717ab2d5493ce99d9e10587084f2fb636f2" translate="yes" xml:space="preserve">
          <source>User primitives are declared in an implementation file or struct&amp;hellip;end module expression using the external keyword:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e76bea74573cfe0bfd448177f94e560637c3a0b7" translate="yes" xml:space="preserve">
          <source>User primitives with arity greater than 5 should be implemented by two C functions. The first function, to be used in conjunction with the bytecode compiler ocamlc, receives two arguments: a pointer to an array of OCaml values (the values for the arguments), and an integer which is the number of arguments provided. The other function, to be used in conjunction with the native-code compiler ocamlopt, takes its arguments directly. For instance, here are the two C functions for the 7-argument primitive Nat.add_nat:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e2f5922d423f16a794e9dc47293889f985312b" translate="yes" xml:space="preserve">
          <source>User primitives with arity n &amp;le; 5 are implemented by C functions that take n arguments of type value, and return a result of type value. The type value is the type of the representations for OCaml values. It encodes objects of several base types (integers, floating-point numbers, strings, &amp;hellip;) as well as OCaml data structures. The type value and the associated conversion functions and macros are described in detail below. For instance, here is the declaration for the C function implementing the input primitive:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc8df31d28f8bef488b448a18127e1554e1ec5c" translate="yes" xml:space="preserve">
          <source>User time for the children processes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51ce85f72da94ad3e8baaae0981a64012711679" translate="yes" xml:space="preserve">
          <source>User time for the process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269caf30a531474b7d8f62fd8bc5f4d312f503d7" translate="yes" xml:space="preserve">
          <source>User-defined data structures include records and variants. Both are defined with the type declaration. Here, we declare a record type to represent rational numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b7a9c1cda7f0b25021511c2cba9fad3dba682c" translate="yes" xml:space="preserve">
          <source>Users can also define &lt;em&gt;and operators&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523c481222828c351b48f48cedb77b983332c9ab" translate="yes" xml:space="preserve">
          <source>Users can define &lt;em&gt;let operators&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a7515319d18e38efa130281795ff468d3f181f0" translate="yes" xml:space="preserve">
          <source>Users can provide their own documentation generator to be used during step 2 instead of the default generators. All the information retrieved during the analysis step is available through the Odoc_info module, which gives access to all the types and functions representing the elements found in the given modules, with their associated description.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="686d35a1878d43f899780e120d4e310d31a7e4fc" translate="yes" xml:space="preserve">
          <source>Users of this module are encouraged to do &lt;code&gt;open&amp;nbsp;Bigarray&lt;/code&gt; in their source, then refer to array types and operations via short dot notation, e.g. &lt;code&gt;Array1.t&lt;/code&gt; or &lt;code&gt;Array2.sub&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9aafe7611fe4c80acc31f514470ed26f519ac41" translate="yes" xml:space="preserve">
          <source>Using a generalized algebraic datatype (GADT) here allows writing well-typed polymorphic functions whose return type depend on the argument type, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186f5c930a2da2f4b139e25273ca52659b37d980" translate="yes" xml:space="preserve">
          <source>Using multiple threads (shared-memory concurrency) in a mixed OCaml/C application requires special precautions, which are described in this section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4185b233b0e25ce53061fd3b5464cb0d929bdaf3" translate="yes" xml:space="preserve">
          <source>Using these attributes, it is possible to call C library functions with no indirection. For instance many math functions are defined this way in the OCaml standard library:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3a2ba33297635a5a100442a81946ae55e5b4d04" translate="yes" xml:space="preserve">
          <source>Using this mechanism, users of the library mylib.cma do not need to known that it references C code, nor whether this C code must be statically linked (using -custom) or dynamically linked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d41532f24be37374e2392e03dcd432e4f024ed57" translate="yes" xml:space="preserve">
          <source>Using this option may degrade the quality of generated code, but it reduces compilation time, both on clean and incremental builds. Indeed, with the native compiler, when the implementation of a compilation unit changes, all the units that depend on it may need to be recompiled &amp;ndash; because the cross-module information may have changed. If the compilation unit whose implementation changed was compiled with -opaque, no such recompilation needs to occur. This option can thus be used, for example, to get faster edit-compile-test feedback loops.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="203e1ca511488e35dc039744252193ca885d3db1" translate="yes" xml:space="preserve">
          <source>Usually, the exhaustiveness check only tries to check whether the cases omitted from the pattern matching are typable or not. However, you can force it to try harder by adding &lt;em&gt;refutation cases&lt;/em&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="04aa2275978eeaf5c333af7b59fe2e0c90f69a4c" translate="yes" xml:space="preserve">
          <source>VM-level threads. This implementation performs time-sharing and context switching at the level of the OCaml virtual machine (bytecode interpreter). It is available on Unix systems, and supports only bytecode programs. It cannot be used with native-code programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37e1b4eac2153fa2f4795d760b79561db8627b99" translate="yes" xml:space="preserve">
          <source>Val_bool(x) returns the OCaml boolean representing the truth value of the C integer x.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e94cddb0996c3086e6aa59a514ec82cb5af2aeb" translate="yes" xml:space="preserve">
          <source>Val_int(0)</source>
          <target state="translated">Val_int(0)</target>
        </trans-unit>
        <trans-unit id="25e40da040a0c12ef6b4bb1d7758cf251f928ccd" translate="yes" xml:space="preserve">
          <source>Val_int(1)</source>
          <target state="translated">Val_int(1)</target>
        </trans-unit>
        <trans-unit id="e9cca6677134db576d9f41823ff8015b091892b7" translate="yes" xml:space="preserve">
          <source>Val_int(i) returns the value encoding the inti.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc663e78a10eafc288ec1404183ecc1e722e99b3" translate="yes" xml:space="preserve">
          <source>Val_long(l) returns the value encoding the long intl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b89d186e5113422a8e6919d7df38f2c830163252" translate="yes" xml:space="preserve">
          <source>Val_true, Val_false represent the OCaml booleans true and false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="7b7c38fd2846399c3a4f294beacb165b7989b2b7" translate="yes" xml:space="preserve">
          <source>Values defined in tuple, as in let (x,y,z) = (1,2,3) are not kept by OCamldoc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0df0d057295bc592ab1965b6c77fca52e9a8d6d8" translate="yes" xml:space="preserve">
          <source>Values of a variant or record type declared private can be de-structured normally in pattern-matching or via the &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; notation for record accesses. However, values of these types cannot be constructed directly by constructor application or record construction. Moreover, assignment on a mutable field of a private record type is not allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae1f9e546555b26d722af8ae1f8856ce883ea81b" translate="yes" xml:space="preserve">
          <source>Values of extensible variant types, for example exceptions (of extensible type &lt;code&gt;exn&lt;/code&gt;), returned by the unmarshaller should not be pattern-matched over through &lt;code&gt;match&amp;nbsp;...&amp;nbsp;with&lt;/code&gt; or &lt;code&gt;try&amp;nbsp;...&amp;nbsp;with&lt;/code&gt;, because unmarshalling does not preserve the information required for matching their constructors. Structural equalities with other extensible variant values does not work either. Most other uses such as Printexc.to_string, will still work as expected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="a9ead228ce4b44ff6fa9fa633fd85106fce88469" translate="yes" xml:space="preserve">
          <source>Variables that appear in closure environments may themselves be boxed values. As such, they may be split into further closure variables, each of which corresponds to some projection from the original closure variable(s). This transformation is called &lt;em&gt;unboxing of closure variables&lt;/em&gt; or &lt;em&gt;unboxing of free variables of closures&lt;/em&gt;. It is only applied when there is reasonable certainty that there are no uses of the boxed free variable itself within the corresponding function bodies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94544efd875ca197c0357ce5be422f10d559a990" translate="yes" xml:space="preserve">
          <source>Variance describes how type constructors behave with respect to subtyping. Consider for instance a pair of type x and xy with x a subtype of xy, denoted x :&amp;gt; xy:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7740708293bab268b6cdccd3b2b3105d72d56eb2" translate="yes" xml:space="preserve">
          <source>Variant values are either a constant constructor, or a non-constant constructor applied to a number of values. The former case is written &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;; the latter case is written &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;(v&lt;sub&gt;1&lt;/sub&gt;, ... ,v&lt;sub&gt;n&lt;/sub&gt;), where the v&lt;sub&gt;i&lt;/sub&gt; are said to be the arguments of the non-constant constructor &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;. The parentheses may be omitted if there is only one argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b6fcc906c8b94204e9f80540ccb736117039b60" translate="yes" xml:space="preserve">
          <source>Variants as presented in section &lt;a href=&quot;coreexamples#s%3Atut-recvariants&quot;&gt;1.4&lt;/a&gt; are a powerful tool to build data structures and algorithms. However they sometimes lack flexibility when used in modular programming. This is due to the fact that every constructor is assigned to a unique type when defined and used. Even if the same name appears in the definition of multiple types, the constructor itself belongs to only one type. Therefore, one cannot decide that a given constructor belongs to multiple types, or consider a value of some type to belong to some other type with more constructors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="defd91e4cb9da478b0d364b538e338f44780605a" translate="yes" xml:space="preserve">
          <source>Various characteristics of the OCaml Bigarray can be consulted from C as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1791879f0afda21c77fcdf13351b18a10a048118" translate="yes" xml:space="preserve">
          <source>Verbose mode. Display progress information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc93f5ac175e4f599a14011e6580fc7cd4bf97ed" translate="yes" xml:space="preserve">
          <source>Virtual instance variables were added in version 3.10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="94f10d72f2176232cbf33b9b9b14740de63cf0c9" translate="yes" xml:space="preserve">
          <source>Wait until a non-ignored, non-blocked signal is delivered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e26e29aec6b9e363507c3295d1d357f540da00" translate="yes" xml:space="preserve">
          <source>Wait until one of the children processes die, and return its pid and termination status.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b53c4cd88232ecfc4592008efce859b27539051c" translate="yes" xml:space="preserve">
          <source>Wait until some input/output operations become possible on some channels.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c964679793a15053f9bc60ab25124e1cd8f63b1e" translate="yes" xml:space="preserve">
          <source>Wait until some input/output operations become possible on some channels. The three list arguments are, respectively, a set of descriptors to check for reading (first argument), for writing (second argument), or for exceptional conditions (third argument). The fourth argument is the maximal timeout, in seconds; a negative fourth argument means no timeout (unbounded wait). The result is composed of three sets of descriptors: those ready for reading (first component), ready for writing (second component), and over which an exceptional condition is pending (third component).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccdc343f664af6bf455c146e4304ebf776d509a8" translate="yes" xml:space="preserve">
          <source>Waits until all output written on the given file descriptor has been transmitted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c66db7dd8fa9eda0d7fae5d4287c1b028a58fac" translate="yes" xml:space="preserve">
          <source>Warning 52 is there to prevent users from writing such fragile code in the first place. It does not occur on every matching on a literal string, but only in the case in which library authors expressed their intent to possibly change the constructor parameter value in the future, by using the attribute ocaml.warn_on_literal_pattern (see the manual section on builtin attributes in &lt;a href=&quot;attributes#ss%3Abuiltin-attributes&quot;&gt;8.12.1&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43338ae908e060e4a2fe4ebd54468c1f5df5e18f" translate="yes" xml:space="preserve">
          <source>Warning 57 is dedicated to these confusing cases where the specified left-to-right semantics is not equivalent to a non-deterministic semantics (any branch can be taken) relatively to a specific guard. More precisely, it warns when guard uses &amp;ldquo;ambiguous&amp;rdquo; variables, that are bound to different parts of the scrutinees by different sides of a or-pattern.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6d46ffdf8d66bd8653cdefc4711e1d4925aba59" translate="yes" xml:space="preserve">
          <source>Warning numbers and letters which are out of the range of warnings that are currently defined are ignored. The warnings are as follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206f2d99f775f6c0030d57f5df574102132f9a4e" translate="yes" xml:space="preserve">
          <source>Warning on non-tail calls if @tailcall present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e4fe3d506423f2f303c88f30c63f1455f72684d" translate="yes" xml:space="preserve">
          <source>Warning: If the output device of the pretty-printer is an output channel, repeated calls to &lt;code&gt;print_flush&lt;/code&gt; means repeated calls to &lt;a href=&quot;stdlib#VALflush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; to flush the out channel; these explicit flush calls could foil the buffering strategy of output channels and could dramatically impact efficiency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eeed1a9ddc8faa9785366b5b56daaeea8f4bc85c" translate="yes" xml:space="preserve">
          <source>Warning: marshaling is currently not type-safe. The type of marshaled data is not transmitted along the value of the data, making it impossible to check that the data read back possesses the type expected by the context. In particular, the result type of the &lt;code&gt;Marshal.from_*&lt;/code&gt; functions is given as &lt;code&gt;'a&lt;/code&gt;, but this is misleading: the returned OCaml value does not possess type &lt;code&gt;'a&lt;/code&gt; for all &lt;code&gt;'a&lt;/code&gt;; it has one, unique type which cannot be determined at compile-time. The programmer should explicitly give the expected type of the returned value, using the following syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f9837b70f002281732297feca2ee92ad79deed" translate="yes" xml:space="preserve">
          <source>Warning: mixing calls to pretty-printing functions of this module with calls to &lt;a href=&quot;stdlib&quot;&gt;&lt;code&gt;Stdlib&lt;/code&gt;&lt;/a&gt; low level output functions is error prone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be10b5fa87bfc72a683d87e69c9836c5eec8355c" translate="yes" xml:space="preserve">
          <source>Warning: the threads library is deprecated since version 4.08.0 of OCaml. Please switch to system threads, which have the same API. Lightweight threads with VM-level scheduling are provided by third-party libraries such as Lwt, but with a different API.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="461b5545b551a43d233140f163cd94622ad71616" translate="yes" xml:space="preserve">
          <source>We added print_endline &quot;lazy_two evaluation&quot; to see when the lazy expression is being evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4f9b808c4ebc7ca886731051c46d1e0b955626c" translate="yes" xml:space="preserve">
          <source>We can also create a different kind of observer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d499139bd909cecce12873700b39b7d51639e5" translate="yes" xml:space="preserve">
          <source>We can also use lazy patterns in pattern matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92cc615171f55d614bb69c4999244e87a3b2a6d1" translate="yes" xml:space="preserve">
          <source>We can apply this function to our store</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a5f0a9709c52081ad4dfc756d77211d606cc3d" translate="yes" xml:space="preserve">
          <source>We can define a variant of backup that retains all copies. (We also add a method clear to manually erase all copies.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c79a613f0ce3961382adb27ff85c38372c8feaa" translate="yes" xml:space="preserve">
          <source>We can then select one implementation based on command-line arguments, for instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d9fa09b79dd633060d36b6bddacc91dc3a48e89" translate="yes" xml:space="preserve">
          <source>We explain here the rules we applied when labeling OCaml libraries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99916877f63c0d92e57f380f6669743174a88f7e" translate="yes" xml:space="preserve">
          <source>We finish this introduction with a more complete example representative of the use of OCaml for symbolic processing: formal manipulations of arithmetic expressions containing variables. The following variant type describes the expressions we shall manipulate:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2bbe18b1f9a0ed2104dd3cee9b61a7eda1cf15b" translate="yes" xml:space="preserve">
          <source>We first consider the case of linear patterns, that is the case when all as bound variables are distinct. In &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;as&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;, the type of &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; normally is string (or string option) except when &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt; is a character constant, an underscore, a string constant of length one, a character set specification, or an alternation of those. Then, the type of &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; is char (or char option). Option types are introduced when overall rule matching does not imply matching of the bound sub-pattern. This is in particular the case of (&lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;as&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;)? and of &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|(&lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;as&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6822c23ba1ad8f02365bf80190a034387ff3d1" translate="yes" xml:space="preserve">
          <source>We first define a function to evaluate an expression given an environment that maps variable names to their values. For simplicity, the environment is represented as an association list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c893fa720bf9f99af9ed941bc43778057b94fe9" translate="yes" xml:space="preserve">
          <source>We have provided the &lt;a href=&quot;string#VALinit&quot;&gt;&lt;code&gt;String.init&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;string#VALmap&quot;&gt;&lt;code&gt;String.map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string#VALmapi&quot;&gt;&lt;code&gt;String.mapi&lt;/code&gt;&lt;/a&gt; functions to cover most cases of building new strings. You should prefer those over &lt;code&gt;to_string&lt;/code&gt; or &lt;code&gt;unsafe_to_string&lt;/code&gt; whenever applicable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e997e614ce5467b0beba9472c3d7cf645ca20baa" translate="yes" xml:space="preserve">
          <source>We have seen that points and colored points have incompatible types. For instance, they cannot be mixed in the same list. However, a colored point can be coerced to a point, hiding its color method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5d1884271f9999c046392d72f34e432867570e1" translate="yes" xml:space="preserve">
          <source>We illustrate inheritance by defining a class of colored points that inherits from the class of points. This class has all instance variables and all methods of class point, plus a new instance variable c and a new method color.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe9224c2732ce4c4c3d2e63c6afc04c8cd8c8d9" translate="yes" xml:space="preserve">
          <source>We make the method interest private, since clearly it should not be called freely from the outside. Here, it is only made accessible to subclasses that will manage monthly or yearly updates of the account.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a05df682a1f6f5e46b800692bc9a4a9b824c3c16" translate="yes" xml:space="preserve">
          <source>We now compile the OCaml code to a C object file and put it in a C library along with the stub code in modwrap.c and the OCaml runtime system:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b0a8c86c819bd589244b573a951c5018c66dc0" translate="yes" xml:space="preserve">
          <source>We now create a new point p, instance of the point class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9e72dd84f2e2a1bac4efce2a171cca7af32b7f" translate="yes" xml:space="preserve">
          <source>We now give the GC rules corresponding to the low-level allocation functions caml_alloc_small and caml_alloc_shr. You can ignore those rules if you stick to the simplified allocation function caml_alloc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dde80a3e10aa85c712afe16ab7e2341a6c678052" translate="yes" xml:space="preserve">
          <source>We now invoke some methods of p:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eddf36c907f6ba061639dec7abaa73a666215441" translate="yes" xml:space="preserve">
          <source>We now refine this definition with a method to compute interest.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f74647a14e3ed593ca08170fabed6ef0ef7ebd98" translate="yes" xml:space="preserve">
          <source>We said earlier that all OCaml objects are represented by the C type value, and one has to use macros such as Int_val to decode data from the value type. It is however possible to tell the OCaml native-code compiler to do this for us and pass arguments unboxed to the C function. Similarly it is possible to tell OCaml to expect the result unboxed and box it for us.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bca3f24bc60b155d0819792bfa9331ce581c464f" translate="yes" xml:space="preserve">
          <source>We should soon fix a bug in the current definition: the deposit method can be used for withdrawing money by depositing negative amounts. We can fix this directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a0580da590e6d18812e52fcb9d241d72eb30f8" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you port your code to use the standard library version instead, as the changes required are minimal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b76922aca83aea453c196313c75e6f82cdc85b43" translate="yes" xml:space="preserve">
          <source>We then define a subclass money of comparable. The class money simply wraps floats as comparable objects. We will extend it below with more operations. We have to use a type constraint on the class parameter x because the primitive &amp;lt;= is a polymorphic function in OCaml. The inherit clause ensures that the type of objects of this class is an instance of #comparable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a09f642369ffeb1d47d15e3a190a4aa7660841b9" translate="yes" xml:space="preserve">
          <source>We then recover polymorphism:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df96e9f187249271f3cc2c30ce856d1def153907" translate="yes" xml:space="preserve">
          <source>We use lazy (expr) to delay the evaluation of some expression expr. For example, we can defer the computation of 1+1 until we need the result of that expression, 2. Let us see how we initialize a lazy expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8138516fe760085bbe99cc7f9cac0b5a490449c" translate="yes" xml:space="preserve">
          <source>We want to bind the function getenv in a way that works both under Unix and Windows. Under Unix this function has the prototype:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d6d8214460953d9bf3607daeaf4f2e1dcf6dfd" translate="yes" xml:space="preserve">
          <source>We will not try here to explain in detail how type inference works. One must just understand that there is not enough information in the above program to deduce the correct type of g or bump. That is, there is no way to know whether an argument is optional or not, or which is the correct order, by looking only at how a function is applied. The strategy used by the compiler is to assume that there are no optional arguments, and that applications are done in the right order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bfada821419f7b1c35da6470b04b8c1b0c72d91" translate="yes" xml:space="preserve">
          <source>Weak</source>
          <target state="translated">Weak</target>
        </trans-unit>
        <trans-unit id="d22283d948c9488ada65248c6645510b567f8a49" translate="yes" xml:space="preserve">
          <source>Weak arrays cannot be marshaled using &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt; nor the functions of the &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72045a1c4a2a8b8f303cdae651cfaef5a76eca1e" translate="yes" xml:space="preserve">
          <source>Weak hash sets</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e14058b3fbf260f23ab0c6884c945aa8da01d1a" translate="yes" xml:space="preserve">
          <source>What happens when a process tries to lock a region of a file that is already locked by the same process depends on the OS. On POSIX-compliant systems, the second lock operation succeeds and may &quot;promote&quot; the older lock from read lock to write lock. On Windows, the second lock operation will block or fail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0988be2bfd0c6854f41080dea8b6f91bf9a1370d" translate="yes" xml:space="preserve">
          <source>What to do when receiving a signal:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c21717a7fc138d58564167fcb6dd12bbcbe404" translate="yes" xml:space="preserve">
          <source>What to do when receiving a signal: &lt;code&gt;Signal_default&lt;/code&gt;: take the default behavior (usually: abort the program), &lt;code&gt;Signal_ignore&lt;/code&gt;: ignore the signal, &lt;code&gt;Signal_handle&amp;nbsp;f&lt;/code&gt;: call function &lt;code&gt;f&lt;/code&gt;, giving it the signal number as argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e013f727f75893e8217087a1af3c906ca342fa52" translate="yes" xml:space="preserve">
          <source>When -O2 is specified two rounds of optimisation are performed. The first round uses the default parameters (see above). The second uses the following parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcf8e597524e8aee8c13ef1751d22f48ce086204" translate="yes" xml:space="preserve">
          <source>When -O3 is specified three rounds of optimisation are performed. The first two rounds are as for -O2. The third round uses the following parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a51e2474b26cb6aa186686913f31b780794afaba" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to a class body, new&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to a new object containing the instance variables and methods of this class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b82cf9cee86acdbc64dbbf0fb149429ecccc72a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to a class function, new&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to a function expecting the same number of arguments and returning a new object of this class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ac323c3ecca6b336d0c993fce513966e3c8814" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;1&amp;nbsp;&amp;lt;&amp;nbsp;max_indent&amp;nbsp;&amp;lt;&amp;nbsp;margin&lt;/code&gt;, &lt;code&gt;pp_set_geometry&amp;nbsp;ppf&amp;nbsp;~max_indent&amp;nbsp;~margin&lt;/code&gt; is equivalent to &lt;code&gt;pp_set_margin&amp;nbsp;ppf&amp;nbsp;margin;&amp;nbsp;pp_set_max_indent&amp;nbsp;ppf&amp;nbsp;max_indent&lt;/code&gt;; and avoids the subtly incorrect &lt;code&gt;pp_set_max_indent&amp;nbsp;ppf&amp;nbsp;max_indent;&amp;nbsp;pp_set_margin&amp;nbsp;ppf&amp;nbsp;margin&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e28129a04e7cd0c48e2322610116e87d33bc4f9d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Array.sort&lt;/code&gt; returns, &lt;code&gt;a&lt;/code&gt; contains the same elements as before, reordered in such a way that for all i and j valid indices of &lt;code&gt;a&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56bdfe21627fc64c618784351aca6192eaa2423d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;sort&lt;/code&gt; returns, &lt;code&gt;a&lt;/code&gt; contains the same elements as before, reordered in such a way that for all i and j valid indices of &lt;code&gt;a&lt;/code&gt; :</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a1feca9d22707497e3af035ccb842d458f8e939" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;with_positions&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, lexer actions should not modify position fields. Doing it nevertheless could re-enable the &lt;code&gt;with_position&lt;/code&gt; mode and degrade performances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e1130d10406644bd2995a03b20217aafac1d7c0" translate="yes" xml:space="preserve">
          <source>When OCaml bytecode produced by ocamlc -g is embedded in a C program, no debugging information is included, and therefore it is impossible to print stack backtraces on uncaught exceptions. This is not the case when native code produced by ocamlopt -g is embedded in a C program: stack backtrace information is available, but the backtrace mechanism needs to be turned on programmatically. This can be achieved from the OCaml side by calling Printexc.record_backtrace true in the initialization of one of the OCaml modules. This can also be achieved from the C side by calling caml_record_backtrace(Val_int(1)); in the OCaml-C glue code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34f78824091c7508d92682b1802b558ea0fa5f7" translate="yes" xml:space="preserve">
          <source>When OCaml calls the C code implementing a primitive, the master lock is held, therefore the C code has full access to the facilities of the run-time system. However, no other thread can execute OCaml code concurrently with the C code of the primitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="731df544ab2a9ec7204d741cd8c2456b1fe24993" translate="yes" xml:space="preserve">
          <source>When a function is passed as an argument to a higher-order function, labels must match in both types. Neither adding nor removing labels are allowed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dec26d8a7e9ea065435190bd81832097f83991b" translate="yes" xml:space="preserve">
          <source>When a recursive call to a function (within the definition of that function or another in the same mutually-recursive group) is inlined, the procedure is also known as &lt;em&gt;unrolling&lt;/em&gt;. This is somewhat akin to loop peeling. For example, given the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8c166cb381f772c894053718af4cc540b7764c1" translate="yes" xml:space="preserve">
          <source>When a shift/reduce conflict cannot be resolved using the above method, then ocamlyacc will output a warning and the parser will always shift.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27c9efd30cc98ee4407de08fe91f7e2b81b5c1a5" translate="yes" xml:space="preserve">
          <source>When a type is unboxable (i.e. a record with a single argument or a concrete datatype with a single constructor of one argument) it will be unboxed unless annotated with [@@ocaml.boxed].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="683b509729033268c58f4450cd64b5d3d02b55b7" translate="yes" xml:space="preserve">
          <source>When a type is unboxable it will be boxed unless annotated with [@@ocaml.unboxed]. This is the default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="326b5be3859c652fd4f119fc5dd900a23ee51ed0" translate="yes" xml:space="preserve">
          <source>When a type is visible under several module-paths, use the shortest one when printing the type&amp;rsquo;s name in inferred interfaces and error and warning messages. Identifier names starting with an underscore _ or containing double underscores __ incur a penalty of +10 when computing their length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c41d0dc17088def45b04aa6a11a3b3a215c0e87e" translate="yes" xml:space="preserve">
          <source>When an or-pattern composed of variant tags is wrapped inside an alias-pattern, the alias is given a type containing only the tags enumerated in the or-pattern. This allows for many useful idioms, like incremental definition of functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92b38d80c97fd5053b560c8766f83a7af6d7bbf2" translate="yes" xml:space="preserve">
          <source>When appearing in a module signature, this definition specifies nothing on the type constructor, besides its number of parameters: its representation is hidden and it is assumed incompatible with any other type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690e2c95aca5c0bc8bb37466d7f1bfe8a47ce028" translate="yes" xml:space="preserve">
          <source>When both sides of the = sign are the same, it is possible to avoid repeating the field name by eliding the =field part:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9a1d592aa8045ca5f8c840dfe01b1a0d44dcfb" translate="yes" xml:space="preserve">
          <source>When converting an exception into a string, the printers will be invoked in the reverse order of their registrations, until a printer returns a &lt;code&gt;Some&amp;nbsp;s&lt;/code&gt; value (if no such printer exists, the runtime will use a generic printer).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="034158012eb7ccfe68c6898fd0ac8e5a62c3f38e" translate="yes" xml:space="preserve">
          <source>When exceptions are used as a control structure, it can be useful to make them as local as possible by using a locally defined exception. For instance, with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1077be7d93082bb39e5870bf19a2eea51954852c" translate="yes" xml:space="preserve">
          <source>When in -Oclassic mode, -inline behaves as in previous versions of the compiler: it is the maximum size of function to be considered for inlining. See section &lt;a href=&quot;#ss%3Aflambda-classic&quot;&gt;21.3.1&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="492ff2355909728e85c6f2a21a225e71b2f44177" translate="yes" xml:space="preserve">
          <source>When linking .cmalibraries, ignore -custom, -cclib and -ccopt options potentially contained in the libraries (if these options were given when building the libraries). This can be useful if a library contains incorrect specifications of C libraries or C options; in this case, during linking, set -noautolink and pass the correct C libraries and options on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b9d6d9ab3ba56bf035a511bd9d449eca44727f4" translate="yes" xml:space="preserve">
          <source>When linking .cmxalibraries, ignore -cclib and -ccopt options potentially contained in the libraries (if these options were given when building the libraries). This can be useful if a library contains incorrect specifications of C libraries or C options; in this case, during linking, set -noautolink and pass the correct C libraries and options on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b73d8b95c745a7e82f1c332d3753eddb94d728d" translate="yes" xml:space="preserve">
          <source>When not in -Oclassic mode, -inline limits the total size of functions considered for inlining during any speculative inlining search. (See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;.) Note that this parameter does not control the assessment as to whether any particular function may be inlined. Raising it to excessive amounts will not necessarily cause more functions to be inlined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f386ef166191d4de341a91dd5a815dc5eed34230" translate="yes" xml:space="preserve">
          <source>When opening a semantic tag with name &lt;code&gt;t&lt;/code&gt;, the string &lt;code&gt;t&lt;/code&gt; is passed to the opening tag-marking function (the &lt;code&gt;mark_open_stag&lt;/code&gt; field of the record &lt;code&gt;tag_funs&lt;/code&gt;), that must return the opening tag marker for that name. When the next call to &lt;code&gt;close_stag&amp;nbsp;()&lt;/code&gt; happens, the semantic tag name &lt;code&gt;t&lt;/code&gt; is sent back to the closing tag-marking function (the &lt;code&gt;mark_close_stag&lt;/code&gt; field of record &lt;code&gt;tag_funs&lt;/code&gt;), that must return a closing tag marker for that name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6a70f9cbe6b81b3df98290d76833a41a28f8d6" translate="yes" xml:space="preserve">
          <source>When pattern matching on records, it can be useful to match only few fields of a record. Eliding fields can be done either implicitly or explicitly by ending the record pattern with ; _. However, implicit field elision is at odd with pattern matching exhaustiveness checks. Enabling warning 9 prioritizes exhaustiveness checks over the convenience of implicit field elision and will warn on implicit field elision in record patterns. In particular, this warning can help to spot exhaustive record pattern that may need to be updated after the addition of new fields to a record type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76609a8a49e03dd9fd02fa1bebd9c6296cdf2d26" translate="yes" xml:space="preserve">
          <source>When printing a complex expression, a name of the form $integer is automatically assigned to its value. Such names are also assigned to parts of the value that cannot be printed because the maximal printing depth is exceeded. Named values can be printed later on with the commands p $integer or d $integer. Named values are valid only as long as the program is stopped. They are forgotten as soon as the program resumes execution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d31cc3eb55d7e0d6628001e85e93e466eecc068" translate="yes" xml:space="preserve">
          <source>When printing error messages, the toplevel system attempts to underline visually the location of the error. It consults the TERM variable to determines the type of output terminal and look up its capabilities in the terminal database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90d7dd40d4664a834488e3a90e05acacdcd71cbb" translate="yes" xml:space="preserve">
          <source>When printing string values, non-ascii bytes ( &amp;gt; \0x7E ) are printed as decimal escape sequence if OCAMLTOP_UTF_8 is set to false. Otherwise, they are printed unescaped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c3624360ff971981bc315fd47d2593c900214b5" translate="yes" xml:space="preserve">
          <source>When scanning needs one more character, the given function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="513b6eef346373892dc63825b86c73cd321a24ef" translate="yes" xml:space="preserve">
          <source>When speculation starts the inlining threshold starts at the value set by -inline (or -inline-toplevel if appropriate, see above). Upon making a speculative inlining decision the threshold is reduced by the code size of the function being inlined. If the threshold becomes exhausted, at or below zero, no further speculation will be performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d2861d14369b79117e494b17a13e3c456dfe6e4" translate="yes" xml:space="preserve">
          <source>When symbolic links are created to existing targets, this distinction doesn't matter and &lt;code&gt;symlink&lt;/code&gt; will automatically create the correct kind of symbolic link. The distinction matters when a symbolic link is created to a non-existent target.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c6a9ec1d0aaddbdc02b4a3efa6219fe94407366" translate="yes" xml:space="preserve">
          <source>When the body of a local open expression is delimited by [], [||], or {}, the parentheses can be omitted. For expression, parentheses can also be omitted for {&amp;lt;&amp;gt;}. For example, &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.[&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;] is equivalent to &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.([&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;]), and &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.[|&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;|] is equivalent to &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.([|&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;|]).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="060d48655d567b2d042c60f8b5fbed496d586590" translate="yes" xml:space="preserve">
          <source>When the body of a local open pattern is delimited by [], [||], or {}, the parentheses can be omitted. For example, &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.[&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;] is equivalent to &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.([&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;]), and &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.[|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;|] is equivalent to &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.([|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;|]).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29adbac74a25822a7bfb536a7de8866290251fde" translate="yes" xml:space="preserve">
          <source>When the compiler encounters a reference to a free module identifier Mod, it looks in the search path for a file named Mod.cmi or mod.cmi and loads the compiled interface contained in that file. As a consequence, renaming .cmi files is not advised: the name of a .cmi file must always correspond to the name of the compilation unit it implements. It is admissible to move them to another directory, if their base name is preserved, and the correct -I options are given to the compiler. The compiler will flag an error if it loads a .cmi file that has been renamed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="504fc87ac9efbf21d3ea36072e2cab3a4f1c5a34" translate="yes" xml:space="preserve">
          <source>When the compiler flag -no-alias-deps is enabled, type-level module aliases are also exploited to avoid introducing dependencies between compilation units. Namely, a module alias referring to a module inside another compilation unit does not introduce a link-time dependency on that compilation unit, as long as it is not dereferenced; it still introduces a compile-time dependency if the interface needs to be read, &lt;em&gt;i.e.&lt;/em&gt; if the module is a submodule of the compilation unit, or if some type components are referred to. Additionally, accessing a module alias introduces a link-time dependency on the compilation unit containing the module referenced by the alias, rather than the compilation unit containing the alias. Note that these differences in link-time behavior may be incompatible with the previous behavior, as some compilation units might not be extracted from libraries, and their side-effects ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3aad510e70a7c27301bea92f55e2778f037e8a3" translate="yes" xml:space="preserve">
          <source>When the function has no more character to provide, it &lt;em&gt;must&lt;/em&gt; signal an end-of-input condition by raising the exception &lt;code&gt;End_of_file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93016f799b9860f1f90e3e6d4310d2cea8085d23" translate="yes" xml:space="preserve">
          <source>When the input can not be read according to the format string specification, formatted input functions typically raise exception &lt;code&gt;Scan_failure&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f218c5e044857f4d05b8d252e8b08d203dafa61d" translate="yes" xml:space="preserve">
          <source>When the native compiler compiles an implementation, by default it produces a .cmx file containing information for cross-module optimization. It also expects .cmx files to be present for the dependencies of the currently compiled source, and uses them for optimization. Since OCaml 4.03, the compiler will emit a warning if it is unable to locate the .cmx file of one of those dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04821ef004e6a266283080b3e608b0f7733de10e" translate="yes" xml:space="preserve">
          <source>When the primitive function is applied in an OCaml program, the C function is called with the values of the expressions to which the primitive is applied as arguments. The value returned by the function is passed back to the OCaml program as the result of the function application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d6cf0de3a117389ad73da14031486bc78be69b6" translate="yes" xml:space="preserve">
          <source>When the program aborts due to an uncaught exception, print a detailed &amp;ldquo;back trace&amp;rdquo; of the execution, showing where the exception was raised and which function calls were outstanding at this point. The back trace is printed only if the bytecode executable contains debugging information, i.e. was compiled and linked with the -g option to ocamlc set. This is equivalent to setting the b flag in the OCAMLRUNPARAM environment variable (see below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ce0660bb7b30ee2fd54ec7cc295742eecbaf44e" translate="yes" xml:space="preserve">
          <source>When the program issues a call to fork, the debugger can either follow the child or the parent. By default, the debugger follows the parent process. The variable follow_fork_mode controls this behavior:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b792e8e2e3970fdf3425d9b17c7de05d84adfbe" translate="yes" xml:space="preserve">
          <source>When the program stops, the debugger automatically selects the currently executing frame and describes it briefly as the frame command does.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760b4f611d27d0bba924332cb9173f6280707de0" translate="yes" xml:space="preserve">
          <source>When the systhreads version of the &lt;code&gt;Thread&lt;/code&gt; module is loaded, this function redirects to &lt;code&gt;Thread.sigmask&lt;/code&gt;. I.e., &lt;code&gt;sigprocmask&lt;/code&gt; only changes the mask of the current thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6709b785b4a5aea7c7211a96d782993cfbb1a1c" translate="yes" xml:space="preserve">
          <source>When there are several objects of same nature and role, they are all left unlabeled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abd94383fdf162fa4f337cc16327bc78a72fa7eb" translate="yes" xml:space="preserve">
          <source>When there is no preferable object, all arguments are labeled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8788e9cfbdfd7cb22b01576e3dae5fe0c90b56db" translate="yes" xml:space="preserve">
          <source>When this form is used together with the infix syntax for attributes, the attributes are considered to apply to the payload:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb287ff6ca578030aeae7bf2e7df239b02ae43f0" translate="yes" xml:space="preserve">
          <source>When used in conjunction with a parser generated by ocamlyacc, the semantic actions compute a value belonging to the type token defined by the generated parsing module. (See the description of ocamlyacc below.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f283aeb0bc8ab5225f11e88785f10ccc2fe8775" translate="yes" xml:space="preserve">
          <source>When using a symbolic formatter, all regular pretty-printing activities occur but output material is symbolic and stored in a buffer of output items. At the end of pretty-printing, flushing the output buffer allows post-processing of symbolic output before performing low level output operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aa6f4fe7d77e2f540e510a58951685232221d1f" translate="yes" xml:space="preserve">
          <source>When using flambda:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23308a4fe88a862b61f8a4b2bfdb65916c66b9f8" translate="yes" xml:space="preserve">
          <source>When using the &lt;em&gt;dune&lt;/em&gt; build system, this compiler invocation can be replicated using the flagsstanza when building an executable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55ed891e71155c65d68d420f137010fab4ba7b75" translate="yes" xml:space="preserve">
          <source>When using the automatic snapshot mode the profiling output is written to a file called &quot;spacetime-&amp;lt;pid&amp;gt;&quot; where &amp;lt;pid&amp;gt; is the process ID of the program. (If the program forks and continues executing then multiple files may be produced with different pid numbers.) The profiling output is by default written to the current working directory when the program starts. This may be customised by setting the OCAML_SPACETIME_SNAPSHOT_DIR environment variable to the name of the desired directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff46176bb17d161a544e001f6343d1c85b5b2dc6" translate="yes" xml:space="preserve">
          <source>When using this mechanism, one should be aware that an exception backtrace is attached to the thread that saw it raised, rather than to the exception itself. Practically, it means that the code related to &lt;code&gt;fn&lt;/code&gt; should not use the backtrace if it has itself raised an exception before.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e6d6f6aef357dd76b888573f6bf7222fe68aed" translate="yes" xml:space="preserve">
          <source>When we finally need the result of a lazy expression, we can call Lazy.force on that expression to force its evaluation. The function force comes from standard-library module &lt;a href=&quot;libref/lazy&quot;&gt;Lazy&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e379a737e559586d930adc6d411789e8e1ca7925" translate="yes" xml:space="preserve">
          <source>When writing stubs that need to be compiled under both Windows and Unix, the stubs need to be written in a way that allow the necessary conversions under Windows but that also work under Unix, where typically nothing particular needs to be done to support Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27eea22179b14eb02869c4ff4d62cac522860c71" translate="yes" xml:space="preserve">
          <source>When you want to use distinct names for the variable and the label appearing in the type, you can use a naming label of the form ~name:. This also applies when the argument is not a variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41972dadb8c6dd136819857ca5e83412d7f72bdd" translate="yes" xml:space="preserve">
          <source>Whenever the search path is modified, the debugger will clear any information it may have cached about the files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e406d63a5b51f65514b45dd47778c4144e8d39" translate="yes" xml:space="preserve">
          <source>Whether or not a particular ocamlopt uses Flambda may be determined by invoking it with the -config option and looking for any line starting with &amp;ldquo;flambda:&amp;rdquo;. If such a line is present and says &amp;ldquo;true&amp;rdquo;, then Flambda is supported, otherwise it is not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="198cc493c18a84d95fe966d8c299f76f1fc4db83" translate="yes" xml:space="preserve">
          <source>Whether the block comes from unmarshalling.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef49626fec86141035673c16c5b533b286ee1a42" translate="yes" xml:space="preserve">
          <source>Whether the machine currently executing the Caml program is big-endian.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1a38a7988745c99aff596e8d4cb4566b84631f5" translate="yes" xml:space="preserve">
          <source>Whether to linger on closed connections that have data present, and for how long (in seconds)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aaf1897a76792493551caf9cb7b76e9ccab26c4" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; are handled by &lt;code&gt;formatter_out_functions.out_indent&lt;/code&gt;, the strings will be handled by &lt;code&gt;formatter_out_functions.out_string&lt;/code&gt;. This allows for a custom formatter that handles indentation distinctly, for example, outputs &lt;code&gt;&amp;lt;br/&amp;gt;&lt;/code&gt; tags or &lt;code&gt;&amp;amp;nbsp;&lt;/code&gt; entities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a07082aff84d3d6c58c93479955b2b92cb4da2e5" translate="yes" xml:space="preserve">
          <source>While class types c1 and c2 are different, both object types c1 and c2 expand to the same object type (same method names and types). Yet, when the domain of a coercion is left implicit and its co-domain is an abbreviation of a known class type, then the class type, rather than the object type, is used to derive the coercion function. This allows leaving the domain implicit in most cases when coercing form a subclass to its superclass. The type of a coercion can always be seen as below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6158ac4d7d9e28767d8869ab18311d19f991dae7" translate="yes" xml:space="preserve">
          <source>While objects of either class will behave the same, objects of their subclasses will be different. In a subclass of bad_functional_point, the method move will keep returning an object of the parent class. On the contrary, in a subclass of functional_point, the method move will return an object of the subclass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1327d963e242926568cdcda69b6c7938e8212df6" translate="yes" xml:space="preserve">
          <source>While parameterized classes may be polymorphic in their contents, they are not enough to allow polymorphism of method use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="537e22dedd240b673c1f40fc0ae35d5719dbfcd0" translate="yes" xml:space="preserve">
          <source>While providing an accurate estimate of potential performance loss is difficult, test on various OCaml programs showed a total running time increase ranging from 1% to 8%.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2bae5cd8894f914083548969308228cab1140a" translate="yes" xml:space="preserve">
          <source>While the Unicode version under Windows has the prototype:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="133a040a06d4d9ee4fa55f4d12f1b1b3a635c70e" translate="yes" xml:space="preserve">
          <source>While they provide an increased comfort for writing function applications, labels and optional arguments have the pitfall that they cannot be inferred as completely as the rest of the language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a933a1213833424b3c999c684da426e0bacb55cf" translate="yes" xml:space="preserve">
          <source>While this property is generally intuitive, there is at least one specific case where a different semantics might be expected. Consider a pattern followed by a when-guard: |pwheng-&amp;gt;e, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efd40bf9067e6d85c2521942cd5aea37e0ec3683" translate="yes" xml:space="preserve">
          <source>Whole-backtrace printing functions also skip some uninformative slots; in that case, &lt;code&gt;format&amp;nbsp;pos&amp;nbsp;slot&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ffaa03b305fc0126ea578346ae1d6b55f3dcbe" translate="yes" xml:space="preserve">
          <source>Wildcard pattern given as argument to a constant constructor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5bb2ce358da3362d349dc7dffbbc028b2897662" translate="yes" xml:space="preserve">
          <source>Windows only: allow the file to be deleted while still open</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c2d346eb667eea590c331ddf31fccbcc4d6b831" translate="yes" xml:space="preserve">
          <source>Windows symbolic links are available in Windows Vista onwards. There are some important differences between Windows symlinks and their POSIX counterparts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbe946cc38b1b8f9f48fa7c868b06c619142edd3" translate="yes" xml:space="preserve">
          <source>Windows symbolic links come in two flavours: directory and regular, which designate whether the symbolic link points to a directory or a file. The type must be correct - a directory symlink which actually points to a file cannot be selected with chdir and a file symlink which actually points to a directory cannot be read or written (note that Cygwin's emulation layer ignores this distinction).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="447eabd50cdaa0e176b6a5e8a5c67d40d79f8b6f" translate="yes" xml:space="preserve">
          <source>Windows with the MSVC compiler: the object file produced by OCaml have been compiled with the /MD flag, and therefore all other object files linked with it should also be compiled with /MD.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b5ddaa1ca629f6f8bdd33966c0453bae3a01fc" translate="yes" xml:space="preserve">
          <source>Windows: A fairly complete emulation of the Unix system calls is provided in the Windows version of OCaml. The end of this chapter gives more information on the functions that are not supported under Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e77e2d4c781ed2ce4243a9db7811f83b915be1f7" translate="yes" xml:space="preserve">
          <source>Windows: The Cygwin port of OCaml fully implements all functions from the Unix module. The native Win32 ports implement a subset of them. Below is a list of the functions that are not implemented, or only partially implemented, by the Win32 ports. Functions not mentioned are fully implemented and behave as described previously in this chapter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1778d9d388d1318f9dac928bdbd83df7f0e1159a" translate="yes" xml:space="preserve">
          <source>Windows: The debugger is available under the Cygwin port of OCaml, but not under the native Win32 ports.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9513167feb53aba08956064362d9c1f15e80c9" translate="yes" xml:space="preserve">
          <source>Windows: This is material specific to Microsoft Windows (XP, Vista, 7, 8, 10).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59e24d63c516a909f266896c2e9ddb1141ca9e7" translate="yes" xml:space="preserve">
          <source>Windows: Under several versions of Windows, bytecode executable files are self-executable only if their name ends in .exe. It is recommended to always give .exe names to bytecode executables, e.g. compile with ocamlc -o myprog.exe ... rather than ocamlc -o myprog ....</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2edb2340a5c0f0e98f5830d04cf40b983609fdf" translate="yes" xml:space="preserve">
          <source>With a regular polymorphic algebraic data type, the type parameters of the type constructor are constant within the definition of the type. For instance, we can look at arbitrarily nested list defined as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793a0b884a8cef1f81c2be80c8c54572694c3562" translate="yes" xml:space="preserve">
          <source>With explicit polymorphic annotations, it becomes possible to implement any recursive function that depends only on the structure of the nested lists and not on the type of the elements. For instance, a more complex example would be to compute the total number of elements of the nested lists:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aaeec849cd83352f9371c6d87cc72eeb181cde0" translate="yes" xml:space="preserve">
          <source>With first-class modules, it is possible to parametrize some code over the implementation of a module without using a functor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e369349c1d2c6f7f1e4a71739bc82fddb2fe1cc" translate="yes" xml:space="preserve">
          <source>With ocamlopt, you should do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="780b3948c4b7fbdb7b79edddbe07b3956efd1b1f" translate="yes" xml:space="preserve">
          <source>With polymorphic variants, this original assumption is removed. That is, a variant tag does not belong to any type in particular, the type system will just check that it is an admissible value according to its use. You need not define a type before using a variant tag. A variant type will be inferred independently for each of its uses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b78139198d9c10d6168a26db0f9a8f08c4bf0df4" translate="yes" xml:space="preserve">
          <source>With respect to the variance of their parameters, private types are handled like abstract types. That is, if a private type has parameters, their variance is the one explicitly given by prefixing the parameter by a &amp;lsquo;+&amp;rsquo; or a &amp;lsquo;-&amp;rsquo;, it is invariant otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6641a1c12f08009ac05530d30c3227fe41a7d60" translate="yes" xml:space="preserve">
          <source>With this argument, id_again is seen as a function definition by the type checker and can therefore be generalized. This kind of manipulation is called eta-expansion in lambda calculus and is sometimes referred under this name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="419106f5e3d58ced85f242c86baeb4dedb2d9727" translate="yes" xml:space="preserve">
          <source>With this functional update notation, the record on the left-hand side of with is copied except for the fields on the right-hand side which are updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b229f3dc4b42a2159ecd907f5544fdc40dedc449" translate="yes" xml:space="preserve">
          <source>Within this box, the pretty-printer emphasizes the box structure: if a structural box does not fit fully on a simple line, a break hint also splits the line if the splitting ``moves to the left'' (i.e. the new line gets an indentation smaller than the one of the current line).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c02ea2020d35ee95ea72c4ffc4631170ac6fef86" translate="yes" xml:space="preserve">
          <source>Within this box, the pretty-printer prints as much as possible material on every line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0e073b44d4d068d7117f272b8038adbf1bf5ea" translate="yes" xml:space="preserve">
          <source>Wosize_val(v) returns the size of the block v, in words, excluding the header.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63d9a524a7c3c6c486a85947f3196b96b6b69775" translate="yes" xml:space="preserve">
          <source>Write a 1-byte integer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e0f6125bd34169b0d388120ea7dd10db632157" translate="yes" xml:space="preserve">
          <source>Write a 2-byte integer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3640b1f7b9b33fc7967e17559e1e2a50f0a96852" translate="yes" xml:space="preserve">
          <source>Write a 4-byte float</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfbd154bff247d5a942dd8e5515ed553c1a7390b" translate="yes" xml:space="preserve">
          <source>Write a 4-byte integer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="715165742f4e141b3ddb7a279940fc6b55c0ca2e" translate="yes" xml:space="preserve">
          <source>Write a 8-byte float</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2facaf6686edb20cf3e9091a815ffb2e2b89b1ac" translate="yes" xml:space="preserve">
          <source>Write a 8-byte integer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e82c9510edfabc9175be85bb68c20dc9b6e99492" translate="yes" xml:space="preserve">
          <source>Write a digest on the given output channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08d1fa4a93435c8cbbf3ca7eea7b612c499a6c10" translate="yes" xml:space="preserve">
          <source>Write an array of 1-byte quantities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c977d44c3cd5560e8b2da234f19e0a15bea610a7" translate="yes" xml:space="preserve">
          <source>Write an array of 2-byte quantities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c403b19464f207843f099b264ced8a01ca18f0" translate="yes" xml:space="preserve">
          <source>Write an array of 4-byte quantities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53373896e51a6637bb7fe916341a7d92236445d" translate="yes" xml:space="preserve">
          <source>Write an array of 8-byte quantities</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0f7f0f906de0511a7edb65c46d9427e81dab512" translate="yes" xml:space="preserve">
          <source>Write one 8-bit integer (as the single character with that code) on the given output channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ba782992ef61637de9988b9893ce1faa4dcb5a1" translate="yes" xml:space="preserve">
          <source>Write one 8-bit integer (as the single character with that code) on the given output channel. The given integer is taken modulo 256.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71c0bd41c52ac23c0adc744eacbe4d241a2b2ad3" translate="yes" xml:space="preserve">
          <source>Write one integer in binary format (4 bytes, big-endian) on the given output channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34aceab15eda014863baa6a1c5355e0e7be3b34c" translate="yes" xml:space="preserve">
          <source>Write one integer in binary format (4 bytes, big-endian) on the given output channel. The given integer is taken modulo 2&lt;sup&gt;32&lt;/sup&gt;. The only reliable way to read it back is through the &lt;a href=&quot;stdlib#VALinput_binary_int&quot;&gt;&lt;code&gt;input_binary_int&lt;/code&gt;&lt;/a&gt; function. The format is compatible across all machines for a given version of OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e9567ae72bdfa38f1bb204519eda84c455c31af" translate="yes" xml:space="preserve">
          <source>Write permission</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cdc89f50c7c2a8bac5ec4a97b5d467ab66c6f1d" translate="yes" xml:space="preserve">
          <source>Write the byte sequence on the given output channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c61c80c2e96a62e362a46979a59bd049103d97c" translate="yes" xml:space="preserve">
          <source>Write the character on the given output channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d95495287973862b47913b4cbd3b67affb139553" translate="yes" xml:space="preserve">
          <source>Write the representation of a structured value of any type to a channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52bac5ed5d8e6829ddf07dd242543be1e64e07c8" translate="yes" xml:space="preserve">
          <source>Write the representation of a structured value of any type to a channel. Circularities and sharing inside the value are detected and preserved. The object can be read back, by the function &lt;a href=&quot;stdlib#VALinput_value&quot;&gt;&lt;code&gt;input_value&lt;/code&gt;&lt;/a&gt;. See the description of module &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; for more information. &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt; is equivalent to &lt;a href=&quot;marshal#VALto_channel&quot;&gt;&lt;code&gt;Marshal.to_channel&lt;/code&gt;&lt;/a&gt; with an empty list of flags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0101de444dbaca2559f24fe3f82d42b10b30dff5" translate="yes" xml:space="preserve">
          <source>Write the string on the given output channel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a1114690fa6f09d76b5358d5f1efe1b0b6f056" translate="yes" xml:space="preserve">
          <source>Writes complete as `Synchronised I/O data integrity completion'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94c9f295e008153f31321c142fb1d08220a8d6c0" translate="yes" xml:space="preserve">
          <source>Writes complete as `Synchronised I/O file integrity completion'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="2e597738f972d389ca423a6fd654d10536c9fa46" translate="yes" xml:space="preserve">
          <source>XDG_CONFIG_HOME, HOME</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74d29c2695b2ef20f173bccc3cde5734c046270e" translate="yes" xml:space="preserve">
          <source>Xavier Leroy,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="3691ae14052440bcf4e7fcb1a5a144ad4c587994" translate="yes" xml:space="preserve">
          <source>Year - 1900</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0083fa1822201a52d16c81cc73e7189d19db00a" translate="yes" xml:space="preserve">
          <source>You can act the same way for other kinds of generators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661bf01810306e132b3e8ac6dd4b7a3ec66d1b02" translate="yes" xml:space="preserve">
          <source>You can avoid such risks by annotating the definition itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cc3edf7fc664fefdda41a9a96260f03ffd5b4e8" translate="yes" xml:space="preserve">
          <source>You can do this as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28971cf504f1ddc3ef622da769c247b303992256" translate="yes" xml:space="preserve">
          <source>You can ignore the first two lines of the error message. What matters is the last one: putting self into an external reference would make it impossible to extend it through inheritance. We will see in section &lt;a href=&quot;#s%3Ausing-coercions&quot;&gt;3.12&lt;/a&gt; a workaround to this problem. Note however that, since immediate objects are not extensible, the problem does not occur with them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf876e27628653e073122db73ce91332f1ff4bd" translate="yes" xml:space="preserve">
          <source>You can jump directly to a given time, without stopping on breakpoints, using the goto command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1517e86749fa6650d7e132b11082d485c41230a" translate="yes" xml:space="preserve">
          <source>You can see it in the following two examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97764d97435c3bd71f977265f2ea46ca12fa1c01" translate="yes" xml:space="preserve">
          <source>You can use custom tags in the documentation comments, but they will have no effect if the generator used does not handle them. To use a custom tag, for example foo, just put @foo with some text in your comment, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80b472c524eb05921f02c45d9ced45aad041cf07" translate="yes" xml:space="preserve">
          <source>You have neglected to load in memory an implementation for a module with #load. See section &lt;a href=&quot;#s%3Atoplevel-modules&quot;&gt;10.3&lt;/a&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4220d4e276f5f289cffdd8a85915703d07a3b840" translate="yes" xml:space="preserve">
          <source>You may also selectively coerce values through pattern matching.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf234cd629ada47a347b6e57492abc4f3fdf6533" translate="yes" xml:space="preserve">
          <source>You may also use the explicit pretty-printing box management and printing functions provided by this module. This style is more basic but more verbose than the concise &lt;code&gt;fprintf&lt;/code&gt; format strings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cfde5a7f39920505c89726af4b9f5350dc3b7e2" translate="yes" xml:space="preserve">
          <source>You may consider this module as providing an extension to the &lt;code&gt;printf&lt;/code&gt; facility to provide automatic line splitting. The addition of pretty-printing annotations to your regular &lt;code&gt;printf&lt;/code&gt; format strings gives you fancy indentation and line breaks. Pretty-printing annotations are described below in the documentation of the function &lt;a href=&quot;format#VALfprintf&quot;&gt;&lt;code&gt;Format.fprintf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78c55f2f29b4cce66bf9146a0c9abe5ac5838e51" translate="yes" xml:space="preserve">
          <source>You must not call any of the OCaml runtime functions or macros between registering and storing the value. Neither must you store anything in the variable v (likewise, the location p) that is not a valid value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a96720e5c70f0c8e2f8ccaf81279ef4c128c7988" translate="yes" xml:space="preserve">
          <source>You need to explicitly close all channels created with this function. Closing the channel also closes the underlying file descriptor (unless it was already closed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0596316547d32d2417575f8e486406afcba8d4b6" translate="yes" xml:space="preserve">
          <source>You need to explicitly close all channels created with this function. Closing the channel flushes the data and closes the underlying file descriptor (unless it has already been closed, in which case the buffered data is lost).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="909f99a779adb66a76fc53ab56c7dd1caf35d0fd" translate="yes" xml:space="preserve">
          <source>Z</source>
          <target state="translated">Z</target>
        </trans-unit>
        <trans-unit id="8d53a00e5e95994b8c03087aae9edf99059c5fad" translate="yes" xml:space="preserve">
          <source>Zero-dimensional arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdada8324810d78c81310e77d05c5f3da0c92d67" translate="yes" xml:space="preserve">
          <source>Zero-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68cb4683ebb48572f956e05c0df868074c28605" translate="yes" xml:space="preserve">
          <source>Zero-dimensional arrays. The &lt;code&gt;Array0&lt;/code&gt; structure provides operations similar to those of &lt;a href=&quot;bigarray.genarray&quot;&gt;&lt;code&gt;Bigarray.Genarray&lt;/code&gt;&lt;/a&gt;, but specialized to the case of zero-dimensional arrays that only contain a single scalar value. Statically knowing the number of dimensions of the array allows faster operations, and more precise static type-checking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79bef1c4de4a640570f94b254d7bfb2f7421b7ab" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt;. ] &lt;a href=&quot;#class-name&quot;&gt;class-name&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4dbf8ee7b1d74aefca48d3a61e9ed381afdeb89" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt;. ] &lt;a href=&quot;#modtype-name&quot;&gt;modtype-name&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b7c489fe99a39ef8cdcb8fb3b8664a53ec84ff" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt;. ] &lt;a href=&quot;#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a5cbe1467b65f8d9900519467617a8e9a29e7a" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#module-path&quot;&gt;module-path&lt;/a&gt;. ] &lt;a href=&quot;#class-name&quot;&gt;class-name&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="845419fd360a1d51826ed64f653c49eddf9d1058" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#module-path&quot;&gt;module-path&lt;/a&gt;. ] &lt;a href=&quot;#constr-name&quot;&gt;constr-name&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d2503669881fa83efc7ff33724be786ec3d3cae" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#module-path&quot;&gt;module-path&lt;/a&gt;. ] &lt;a href=&quot;#field-name&quot;&gt;field-name&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3883afd3da5e8553f5497e863411b042b05c61" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#module-path&quot;&gt;module-path&lt;/a&gt;. ] &lt;a href=&quot;#value-name&quot;&gt;value-name&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3c4bcaa3c0479eac0d8fb95567a1abb3c68695" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; ] |&lt;a href=&quot;#tag-spec&quot;&gt;tag-spec&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c9edeebdd153fabd8c188de80c045c7c47a2803" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;modules#module-items&quot;&gt;module-items&lt;/a&gt; ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dcfe0a951210d687a08d6058977844f3198309a" translate="yes" xml:space="preserve">
          <source>[ | ] &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; [when&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;] -&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; { |&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; [when&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;] -&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9a69e212d262bdf5b8dceb1fc60d112e0cfb471" translate="yes" xml:space="preserve">
          <source>[%%&lt;a href=&quot;attributes#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;attributes#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</source>
          <target state="translated">[%%&lt;a href=&quot;attributes#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;attributes#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="324489a2771b36bc101aa148e24a3e655d9fbefd" translate="yes" xml:space="preserve">
          <source>[%&lt;a href=&quot;attributes#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;attributes#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</source>
          <target state="translated">[%&lt;a href=&quot;attributes#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;attributes#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="aa724c53356d3b4dd10ec752edff87fe8fc39d8d" translate="yes" xml:space="preserve">
          <source>[&amp;gt; [ &lt;a href=&quot;#tag-spec&quot;&gt;tag-spec&lt;/a&gt; ] { |&lt;a href=&quot;#tag-spec&quot;&gt;tag-spec&lt;/a&gt; } ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10f94b240e531c8610f1704309aff71882f6eef1" translate="yes" xml:space="preserve">
          <source>[&amp;gt;`Off|`On] list means that to match this list, you should at least be able to match `Off and `On, without argument. [&amp;lt;`On|`Off|`Number of int] means that f may be applied to `Off, `On (both without argument), or `Numbern where n is an integer. The &amp;gt; and &amp;lt; inside the variant types show that they may still be refined, either by defining more tags or by allowing less. As such, they contain an implicit type variable. Because each of the variant types appears only once in the whole type, their implicit type variables are not shown.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad6903b1e8f6d74baf8ed15aaa7c98dec0bfe16" translate="yes" xml:space="preserve">
          <source>[&amp;lt; [|] &lt;a href=&quot;#tag-spec-full&quot;&gt;tag-spec-full&lt;/a&gt; { |&lt;a href=&quot;#tag-spec-full&quot;&gt;tag-spec-full&lt;/a&gt; } [ &amp;gt; { `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; }&lt;sup&gt;+&lt;/sup&gt; ] ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91eb9225aeaaf5af7e440003eeb19a446fe1d920" translate="yes" xml:space="preserve">
          <source>[(&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;] )] { &lt;a href=&quot;#class-field&quot;&gt;class-field&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d332459a8ba97fd50bbeae640304bc22182f343f" translate="yes" xml:space="preserve">
          <source>[-] (0&amp;hellip;9) { 0&amp;hellip;9 ∣ _ }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="473bd68ac267366051f84c875ad4ace6aebe4cae" translate="yes" xml:space="preserve">
          <source>[-] (0&amp;hellip;9) { 0&amp;hellip;9 ∣ _ }[g&amp;hellip;z∣ G&amp;hellip;Z]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cb7650e47eb2575d7ca0470858a5635efb70add" translate="yes" xml:space="preserve">
          <source>[-] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ } [. { 0&amp;hellip;9∣ _ }] [(e∣ E) [+∣ -] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ }]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c7b19cb3116ea384d28dd687eadb2b073f38b7b" translate="yes" xml:space="preserve">
          <source>[-] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ } [. { 0&amp;hellip;9∣ _ }] [(e∣ E) [+∣ -] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ }] [g&amp;hellip;z∣ G&amp;hellip;Z]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61094b365d5af7b66e564ec21f930d790211eec" translate="yes" xml:space="preserve">
          <source>[-] (0b∣ 0B) (0&amp;hellip;1) { 0&amp;hellip;1∣ _ }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e83c9c47ab710c338712ade1bc4a393a41751ad2" translate="yes" xml:space="preserve">
          <source>[-] (0b∣ 0B) (0&amp;hellip;1) { 0&amp;hellip;1∣ _ } [g&amp;hellip;z∣ G&amp;hellip;Z]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bacf6a0cec197455f287a5adce559a8f020b3e02" translate="yes" xml:space="preserve">
          <source>[-] (0o∣ 0O) (0&amp;hellip;7) { 0&amp;hellip;7∣ _ }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc29186baa94b0abab18a9f475047bb35e1fc9a2" translate="yes" xml:space="preserve">
          <source>[-] (0o∣ 0O) (0&amp;hellip;7) { 0&amp;hellip;7∣ _ } [g&amp;hellip;z∣ G&amp;hellip;Z]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe40a287c598706fca1aade30b36d274123cdd57" translate="yes" xml:space="preserve">
          <source>[-] (0x∣ 0X) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62ffbd17c903f06a785acfdcfb392df90e8cf1e8" translate="yes" xml:space="preserve">
          <source>[-] (0x∣ 0X) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ } [. { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ }] [(p∣ P) [+∣ -] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ }]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="422ae3d0903630a4c50138d05c0e8a498cb95069" translate="yes" xml:space="preserve">
          <source>[-] (0x∣ 0X) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ } [. { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ }] [(p∣ P) [+∣ -] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ }] [g&amp;hellip;z∣ G&amp;hellip;Z]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fca2e3a71d147da84be67f0e560ab01b47292baf" translate="yes" xml:space="preserve">
          <source>[-] (0x∣ 0X) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ } [g&amp;hellip;z∣ G&amp;hellip;Z]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d527c5d16c2e5a5291a799a508cda294dc70460a" translate="yes" xml:space="preserve">
          <source>[;;] ( &lt;a href=&quot;modules#definition&quot;&gt;definition&lt;/a&gt; ∣ &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; } ) { [;;] &lt;a href=&quot;modules#definition&quot;&gt;definition&lt;/a&gt; ∣ ;;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; } } [;;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7163edf1f91d0eebff5427eae672e4d9cf5843d3" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; { ;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; } [;] ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d179c5500c82803598c1678e833f6bbaec0ee57" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; { ;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; } [ ; ] ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fdc6cfd24896e6dc6cc850526aa2efc82121c21" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;#tag-spec-first&quot;&gt;tag-spec-first&lt;/a&gt; { |&lt;a href=&quot;#tag-spec&quot;&gt;tag-spec&lt;/a&gt; } ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae5c7c192768c8fe819028167bfdf1f70539395" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;#type-equation&quot;&gt;type-equation&lt;/a&gt;] [&lt;a href=&quot;#type-representation&quot;&gt;type-representation&lt;/a&gt;] { &lt;a href=&quot;#type-constraint&quot;&gt;type-constraint&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb557ec36f883c7b8a8a2afb3047a4bc1856325e" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;#type-params&quot;&gt;type-params&lt;/a&gt;] &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;&lt;a href=&quot;#type-information&quot;&gt;type-information&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6809e04c28f4434af2ef4e79379f732d256a70a" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;#variance&quot;&gt;variance&lt;/a&gt;] '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd52a26acaa62bbd70ddc4c699130c536a848817" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;typedecl#type-params&quot;&gt;type-params&lt;/a&gt;] &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;:=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; { &lt;a href=&quot;typedecl#type-constraint&quot;&gt;type-constraint&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c164a669568d725674f36078be81d4f3c7961a9" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;typedecl#variance&quot;&gt;variance&lt;/a&gt;] _</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="599aa502a5589fb3a6adecc0003ea60cd7943675" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; {,&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;} ]&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7becd2f7108116acae7b49a97d7c92f66bc838c4" translate="yes" xml:space="preserve">
          <source>[@&lt;a href=&quot;#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</source>
          <target state="translated">[@&lt;a href=&quot;#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="a97816c7ac1508516fe749441f17b541f6dcf1ee" translate="yes" xml:space="preserve">
          <source>[@@&lt;a href=&quot;#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</source>
          <target state="translated">[@@&lt;a href=&quot;#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="fd2a6aca4a2be8058771e31cb975908901937c52" translate="yes" xml:space="preserve">
          <source>[@@@&lt;a href=&quot;#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</source>
          <target state="translated">[@@@&lt;a href=&quot;#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="60d4d5c4116c206bd450f81da29e892eb2cfc4cc" translate="yes" xml:space="preserve">
          <source>[[&amp;gt;] `&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt;| &amp;hellip; |`&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;n&lt;/sub&gt;|`&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;n+1&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;n+1&lt;/sub&gt;| &amp;hellip; |`&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;n+m&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;n+m&lt;/sub&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b806d0e4f77e2e0284e335435cebcd99e7a7ce8" translate="yes" xml:space="preserve">
          <source>[[&amp;lt;] `&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;| &amp;hellip; |`&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="281ba5c5173bc37bf1a7dd71c6bf39e34b706f2e" translate="yes" xml:space="preserve">
          <source>[[&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; {,&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;} ]] &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3edaf48cc7b2a7dd234e24dfdfd72e38b7085745" translate="yes" xml:space="preserve">
          <source>[[?]&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;:] &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;-&amp;gt;&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fdb79a53e34b6dece67887c1bdac5d4037750d1" translate="yes" xml:space="preserve">
          <source>[[?]&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;:] &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;-&amp;gt;&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37d9466df26d58df397c13d44c392690fb44a7e1" translate="yes" xml:space="preserve">
          <source>[^character-set]</source>
          <target state="translated">[^character-set]</target>
        </trans-unit>
        <trans-unit id="7e9127ed709ebc3b2ec8ae101c18c49d92bb9145" translate="yes" xml:space="preserve">
          <source>[character-set]</source>
          <target state="translated">[character-set]</target>
        </trans-unit>
        <trans-unit id="6ed3105102954a4c5db0c3f02bc020ebe496dcb6" translate="yes" xml:space="preserve">
          <source>[mutable] &lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3a4b15b9df9538ce82dd3ac08074b0490cbc30" translate="yes" xml:space="preserve">
          <source>[mutable] &lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt; {&lt;a href=&quot;#attribute&quot;&gt;attribute&lt;/a&gt;}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06443cf549c345bc7626b16c688d241250965c11" translate="yes" xml:space="preserve">
          <source>[string]</source>
          <target state="translated">[string]</target>
        </trans-unit>
        <trans-unit id="2d934f0af3ee8393994f2178a9aaf1dfde4cfb36" translate="yes" xml:space="preserve">
          <source>[virtual] [[&lt;a href=&quot;#type-parameters&quot;&gt;type-parameters&lt;/a&gt;]] &lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt; {&lt;a href=&quot;expr#parameter&quot;&gt;parameter&lt;/a&gt;} [:&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;] =&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad86b23e23597d8ca554d7819990cc4c9fc9bec1" translate="yes" xml:space="preserve">
          <source>[virtual] [[&lt;a href=&quot;#type-parameters&quot;&gt;type-parameters&lt;/a&gt;]] &lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt;:&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="069e56de2f322b59836b7247c8a473377b4491fe" translate="yes" xml:space="preserve">
          <source>[virtual] [[&lt;a href=&quot;#type-parameters&quot;&gt;type-parameters&lt;/a&gt;]] &lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt;=&lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="779656c2e21df39bbf7b04df8d51a67fffe27328" translate="yes" xml:space="preserve">
          <source>[|&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; { ;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; } [;] |]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d28304d85650beb4b7ca0b1cd85ad4393d19fef0" translate="yes" xml:space="preserve">
          <source>[|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; { ;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; } [ ; ] |]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab6705cd22604179bf5ed99551e23a447c9c18d9" translate="yes" xml:space="preserve">
          <source>[|&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt;|]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebcf6c5142718c920ce70ae1f57d451f361dfc5c" translate="yes" xml:space="preserve">
          <source>[||]</source>
          <target state="translated">[||]</target>
        </trans-unit>
        <trans-unit id="d83bdb55caec3e2da5eb3c08a6d885915882f6a2" translate="yes" xml:space="preserve">
          <source>\ ( \ ∣ &quot; ∣ ' ∣ n ∣ t ∣ b ∣ r ∣ space )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4231f0670f5f242554b99dbd1517d52ef7e1f81" translate="yes" xml:space="preserve">
          <source>\ (0&amp;hellip;9) (0&amp;hellip;9) (0&amp;hellip;9)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab006bb8aacdf6e68299bc1dffccc9bcc8ac3eaf" translate="yes" xml:space="preserve">
          <source>\&quot;</source>
          <target state="translated">\&quot;</target>
        </trans-unit>
        <trans-unit id="9ca863000c0131ce2b74e96a2de49fddf5ae1e10" translate="yes" xml:space="preserve">
          <source>\'</source>
          <target state="translated">\'</target>
        </trans-unit>
        <trans-unit id="9e94758983980504af303ef297fd2bf9d9cea063" translate="yes" xml:space="preserve">
          <source>\\</source>
          <target state="translated">\\</target>
        </trans-unit>
        <trans-unit id="4629ca1b60e263bdc4326334b23323e0434717a5" translate="yes" xml:space="preserve">
          <source>\b</source>
          <target state="translated">\b</target>
        </trans-unit>
        <trans-unit id="3c0a62cb2906cc36c4a919715511fc14bd0b1cfd" translate="yes" xml:space="preserve">
          <source>\ddd</source>
          <target state="translated">\ddd</target>
        </trans-unit>
        <trans-unit id="ef7e6794ca9c6a06b54b66f279237fb8daaaeea8" translate="yes" xml:space="preserve">
          <source>\n</source>
          <target state="translated">\n</target>
        </trans-unit>
        <trans-unit id="1dcf1062839b7f3fa08ae441ebac44ab82ff2e68" translate="yes" xml:space="preserve">
          <source>\newline { space ∣ tab }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f694a8c8e5720726fe11abb727991dbfce0136de" translate="yes" xml:space="preserve">
          <source>\o (0&amp;hellip;3) (0&amp;hellip;7) (0&amp;hellip;7)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af2d76adab6d6c193d82eb1139d9e333cf65dd47" translate="yes" xml:space="preserve">
          <source>\oooo</source>
          <target state="translated">\oooo</target>
        </trans-unit>
        <trans-unit id="f12c84902108895980702c88db900ceea2d2ec01" translate="yes" xml:space="preserve">
          <source>\r</source>
          <target state="translated">\r</target>
        </trans-unit>
        <trans-unit id="16f8ba5a70c8e28946b3f0c93ffa5aa96ba95209" translate="yes" xml:space="preserve">
          <source>\space</source>
          <target state="translated">\space</target>
        </trans-unit>
        <trans-unit id="8bf81043e29dfc96a6fe1f30f7116f552de6e7d7" translate="yes" xml:space="preserve">
          <source>\t</source>
          <target state="translated">\t</target>
        </trans-unit>
        <trans-unit id="3ba84b441afbba0b1e2988ce22de81d518262043" translate="yes" xml:space="preserve">
          <source>\u{ { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f }&lt;sup&gt;+&lt;/sup&gt;}</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b81fd78bdbb47b0a5ab4c46880e42421325e8df" translate="yes" xml:space="preserve">
          <source>\x (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c44b0007f5fd55a953e09798658cb34da7bff02a" translate="yes" xml:space="preserve">
          <source>\xhh</source>
          <target state="translated">\xhh</target>
        </trans-unit>
        <trans-unit id="1288030afca6d49c1dce35c928f3a45658b3416e" translate="yes" xml:space="preserve">
          <source>`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;</source>
          <target state="translated">`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5aa8a0d688e811d242601925f92373e777ce4cef" translate="yes" xml:space="preserve">
          <source>`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; [ of [&amp;amp;] &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; { &amp;amp;&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; } ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be1dc47e3d6863a7150f87ad565a12a951c55d0d" translate="yes" xml:space="preserve">
          <source>`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; [ of&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7e267804f3a59e590fa4fca005068eefe79eac" translate="yes" xml:space="preserve">
          <source>`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;(&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af146e2e56d33085b35edb85f563497a0b676506" translate="yes" xml:space="preserve">
          <source>`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="589c478ac1da3277879e28e45c6d0d868a9a6ad6" translate="yes" xml:space="preserve">
          <source>`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;</source>
          <target state="translated">`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d701b7ecdfa0b9cb1d420b43c29ef0f3936f8e4" translate="yes" xml:space="preserve">
          <source>``Shut down'' a connection established with &lt;a href=&quot;unix#VALopen_connection&quot;&gt;&lt;code&gt;Unix.open_connection&lt;/code&gt;&lt;/a&gt;; that is, transmit an end-of-file condition to the server reading on the other side of the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97864d59da3aa41f746baaafd3463b784bc5abc" translate="yes" xml:space="preserve">
          <source>``Shut down'' a connection established with &lt;a href=&quot;unix#VALopen_connection&quot;&gt;&lt;code&gt;Unix.open_connection&lt;/code&gt;&lt;/a&gt;; that is, transmit an end-of-file condition to the server reading on the other side of the connection. This does not fully close the file descriptor associated with the channel, which you must remember to free via &lt;a href=&quot;stdlib#VALclose_in&quot;&gt;&lt;code&gt;close_in&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716971f89f753fc7aad67107c265548c7d9791d3" translate="yes" xml:space="preserve">
          <source>``Shut down'' a connection established with &lt;a href=&quot;unixlabels#VALopen_connection&quot;&gt;&lt;code&gt;UnixLabels.open_connection&lt;/code&gt;&lt;/a&gt;; that is, transmit an end-of-file condition to the server reading on the other side of the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="ea5d250a9bdc29bd5f4b1349eff20396c9d6398a" translate="yes" xml:space="preserve">
          <source>a &lt;em&gt;metadata file&lt;/em&gt;, part of the OCaml distribution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3627b94701cbc5c760ad13bdc0b33a3b8054c03e" translate="yes" xml:space="preserve">
          <source>a byte sequence or string used as buffer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410ad4856c009112cb4466316bac03d480442255" translate="yes" xml:space="preserve">
          <source>a comparison function, e.g.Stdlib.compare</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ffd5a6bca2d01c99caa3fbbfd548e1dd1dc49fc" translate="yes" xml:space="preserve">
          <source>a function to be applied</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f0ee58df51bd23faa083dba2ed61cb6a7c8e44a" translate="yes" xml:space="preserve">
          <source>a length</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7df0657a72d73073160443670ebf5cfedadba059" translate="yes" xml:space="preserve">
          <source>a library that provides the bytecode interpreter, the memory manager, and the standard primitives;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a66798daedccc860fc63fdf1ae2b663c64b1042" translate="yes" xml:space="preserve">
          <source>a non empty sequence of alphanumeric or &lt;code&gt;_&lt;/code&gt; characters,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb4562ef2047fcddffcf8799aaa36e3a820d8e26" translate="yes" xml:space="preserve">
          <source>a position in a string, array or byte sequence</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3597e8b38da36ab0c1d981d56037dc661f5feac2" translate="yes" xml:space="preserve">
          <source>a scanning indication (see scanning &lt;a href=&quot;scanf#indication&quot;&gt;&lt;i&gt;Scanning indications in format strings&lt;/i&gt;&lt;/a&gt;) has been encountered,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c98cfe033b7435d226fa7c4e0c163564903b703" translate="yes" xml:space="preserve">
          <source>a whitespace has been found (see &lt;a href=&quot;scanf#space&quot;&gt;&lt;i&gt;The space character in format strings&lt;/i&gt;&lt;/a&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f12541afcce175fb34bb05a79c95b76e765488b" translate="yes" xml:space="preserve">
          <source>access</source>
          <target state="translated">access</target>
        </trans-unit>
        <trans-unit id="73468898c9988e2f9e409b93e8bff16eaa79c0ba" translate="yes" xml:space="preserve">
          <source>alarm</source>
          <target state="translated">alarm</target>
        </trans-unit>
        <trans-unit id="ddb7aa66cca7d817b1bc050ddff1df3a3d3313a2" translate="yes" xml:space="preserve">
          <source>alias for &lt;a href=&quot;obj#TYPEt&quot;&gt;&lt;code&gt;Obj.t&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f245e454c594b6a6e02040aa04d0a87b60ce23e" translate="yes" xml:space="preserve">
          <source>all options</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90ec074822453e3c07fb7ab40474dcc71b73158" translate="yes" xml:space="preserve">
          <source>all warnings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="161d19cec4448cddf6f1df51bee30d4aee2ae72c" translate="yes" xml:space="preserve">
          <source>allocation functions (to create structured OCaml objects)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6656018ac96d0295d887ff2893ba9af66ae16af2" translate="yes" xml:space="preserve">
          <source>always</source>
          <target state="translated">always</target>
        </trans-unit>
        <trans-unit id="c048122841cd0af39592cb281c9fb203718804c1" translate="yes" xml:space="preserve">
          <source>always raise Not_found</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1ecbcd070942bfb49c0a12b9a7ec1efd9ba5ea" translate="yes" xml:space="preserve">
          <source>always return 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c8e94591336deee254ea0cc7c2b84a3db46c0a" translate="yes" xml:space="preserve">
          <source>always returns [|1|] (since 2.00)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a99e3d4f923f05ce72c18387d14c99c8d94a725" translate="yes" xml:space="preserve">
          <source>an arbitrary sequence of characters enclosed by a pair of matching parentheses or curly brackets. An escaped &lt;code&gt;$&lt;/code&gt; character is a &lt;code&gt;$&lt;/code&gt; that immediately follows a backslash character; it then stands for a plain &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f561344ac08966f1d833c5f80ae36885b0ccc2db" translate="yes" xml:space="preserve">
          <source>an ephemeron cf &lt;a href=&quot;ephemeron&quot;&gt;&lt;code&gt;Ephemeron&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e268d2a4a07f3246144968e6813834db67163851" translate="yes" xml:space="preserve">
          <source>an ephemeron with an arbitrary number of keys of the same type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6cd3ac13cb54892b26741dbb166711f8f8454ec" translate="yes" xml:space="preserve">
          <source>an ephemeron with one key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5370fc85d98d86b50c6ae717df05ae2178d72709" translate="yes" xml:space="preserve">
          <source>an ephemeron with two keys</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17cd4ed7af141353dc06d425f19ec6f0174f1e40" translate="yes" xml:space="preserve">
          <source>an operation mode or a flag list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e68bf7052e323752495fd36eb5da81f37ffaa4" translate="yes" xml:space="preserve">
          <source>an unboxed integer;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7685d508f910a53eb29bb82f0913de7a8437fc" translate="yes" xml:space="preserve">
          <source>analysis of the source files;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="d0949396bb159e985c5c968ec72002296c91a20c" translate="yes" xml:space="preserve">
          <source>and ( &amp;hellip; ) for the other grouping situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e243fd1598527c063c99e3c63851d61bb6bfc77" translate="yes" xml:space="preserve">
          <source>and (&lt;a href=&quot;lex#core-operator-char&quot;&gt;core-operator-char&lt;/a&gt; ∣ &amp;lt;) { &lt;a href=&quot;indexops#dot-operator-char&quot;&gt;dot-operator-char&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9922f3e883eaa547f62f38fc740e5bebdd032962" translate="yes" xml:space="preserve">
          <source>and S with module M = N denotes the signature</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7135f68d2f2ba0ad3e5c9525d8a98fd85e8d326a" translate="yes" xml:space="preserve">
          <source>and a &lt;em&gt;trace file&lt;/em&gt;, generated by the runtime in the program being traced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae5f607273fb6b8801476b6d4cb87cc1e985618" translate="yes" xml:space="preserve">
          <source>and as a result obtain a Mylib compilation unit, containing physically A and B as submodules, and with no dependencies on their respective compilation units. Here is a concrete example of a possible alternative approach:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e29eacfd66e6128d91b4e2e0d0efc56f09f7ab0" translate="yes" xml:space="preserve">
          <source>and attach several observers to the same object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04afbc59ec07d5cd168b50a57fcdba7a2dc031d7" translate="yes" xml:space="preserve">
          <source>and even use the alternative syntax for declaring functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6469a87a5b418647e9fa1d15ae7d5a10f99bdded" translate="yes" xml:space="preserve">
          <source>and link mod1.cmo before mod2.cmo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3522d8409fab2c8bd7a9a935e5958b1545b923" translate="yes" xml:space="preserve">
          <source>and not</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccb7579c980b6977ec641cb0d678c02d8d41f49d" translate="yes" xml:space="preserve">
          <source>and one on the result</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4c66020d5a4a796b432d2d3f2eb08a6fbfd7761" translate="yes" xml:space="preserve">
          <source>and structured input-output (the functions from the &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; module, as well as &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdlib#VALinput_value&quot;&gt;&lt;code&gt;input_value&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="144cf0ff7c73bffecc1589a4d490aabaa5c658aa" translate="yes" xml:space="preserve">
          <source>and the compiler will emit warning 50.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9890a7a2830cc4814f3a238d40f7dd8ee611982a" translate="yes" xml:space="preserve">
          <source>and the system will automatically add the -custom and -cclib -lmylib options, achieving the same effect as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b1c85b81e1502a02da4141f1ac7368f38fd4b9b" translate="yes" xml:space="preserve">
          <source>and the system will automatically add the -dllib -lmylib option, achieving the same effect as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6c1e93df972fdb89a4efdabb2e6a30ae642fd5" translate="yes" xml:space="preserve">
          <source>and then apply them using this convenient syntax:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be865b252a2a8e9c53f840f52c864386e874af8b" translate="yes" xml:space="preserve">
          <source>and then ask users to provide the -custom and -cclib -lmylib options themselves at link-time:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="478c17c32f1bc3336788616eaad90d7da7f5fbd4" translate="yes" xml:space="preserve">
          <source>and then:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d22cfbed814dcb099f0e8e67505f5a70d8eb06c" translate="yes" xml:space="preserve">
          <source>and universally quantified object methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5f3c67631f2732767dad5f715563cd89ad668cf" translate="yes" xml:space="preserve">
          <source>and used like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c96e234c3b1fd505f14ec96a363efd96eb569033" translate="yes" xml:space="preserve">
          <source>and, &lt;a href=&quot;expr#hevea_manual.kwd21&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;typedecl#hevea_manual.kwd93&quot;&gt;7.8.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd122&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd144&quot;&gt;7.9.3&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd146&quot;&gt;7.9.4&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd149&quot;&gt;7.9.5&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd154&quot;&gt;7.10&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd183&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;manual024#hevea_manual.kwd207&quot;&gt;8.2&lt;/a&gt;, &lt;a href=&quot;firstclassmodules#hevea_manual.kwd215&quot;&gt;8.5&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c78a0dbec27997c1afa661cc0130d0ef25877671" translate="yes" xml:space="preserve">
          <source>and-operator</source>
          <target state="translated">and-operator</target>
        </trans-unit>
        <trans-unit id="c5fe0200d1c7a5139bd18fd22268c4ca8bf45e90" translate="yes" xml:space="preserve">
          <source>any</source>
          <target state="translated">any</target>
        </trans-unit>
        <trans-unit id="97aa373d2868b633a71970cbafb44ac0d10e9bd5" translate="yes" xml:space="preserve">
          <source>arg1_type -&amp;gt; arg2_type -&amp;gt; ... -&amp;gt; return_type. For example, the type inferred for insert, 'a -&amp;gt; 'a list -&amp;gt; 'a list, means that insert takes two arguments, an element of any type 'a and a list with elements of the same type 'a and returns a list of the same type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f3802314d747bbc5016897875185c3a9fae57bf" translate="yes" xml:space="preserve">
          <source>argument</source>
          <target state="translated">argument</target>
        </trans-unit>
        <trans-unit id="df211ccdd94a63e0bcb9e6ae427a249484a49d60" translate="yes" xml:space="preserve">
          <source>as</source>
          <target state="translated">as</target>
        </trans-unit>
        <trans-unit id="be976c9e3ea651e90f3e19650398efe5d38b4ca1" translate="yes" xml:space="preserve">
          <source>as a consequence, scanning a &lt;code&gt;%s&lt;/code&gt; conversion never raises exception &lt;code&gt;End_of_file&lt;/code&gt;: if the end of input is reached the conversion succeeds and simply returns the characters read so far, or &lt;code&gt;&quot;&quot;&lt;/code&gt; if none were ever read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b953d2a9813da51eff31ce5c0d74db5b4435257" translate="yes" xml:space="preserve">
          <source>as mentioned above, a &lt;code&gt;%s&lt;/code&gt; conversion always succeeds, even if there is nothing to read in the input: in this case, it simply returns &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06307b62a784724a222e8111cfba9c75dd2eeba4" translate="yes" xml:space="preserve">
          <source>as, &lt;a href=&quot;types#hevea_manual.kwd7&quot;&gt;7.4&lt;/a&gt;, &lt;a href=&quot;types#hevea_manual.kwd8&quot;&gt;7.4&lt;/a&gt;, &lt;a href=&quot;types#hevea_manual.kwd9&quot;&gt;7.4&lt;/a&gt;, &lt;a href=&quot;patterns#hevea_manual.kwd15&quot;&gt;7.6&lt;/a&gt;, &lt;a href=&quot;patterns#hevea_manual.kwd16&quot;&gt;7.6&lt;/a&gt;, &lt;a href=&quot;patterns#hevea_manual.kwd17&quot;&gt;7.6&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd124&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd132&quot;&gt;7.9.2&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1294692e88bc3cf578b0cf93126b82e453a3a24f" translate="yes" xml:space="preserve">
          <source>asr</source>
          <target state="translated">asr</target>
        </trans-unit>
        <trans-unit id="173bd3aa4f99ba650649627effe8f47f679d7eb5" translate="yes" xml:space="preserve">
          <source>asr, &lt;a href=&quot;names#hevea_manual.kwd6&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd57&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd76&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd83&quot;&gt;7.7.5&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e6234fdd662a3db73c32822887385e189a0e4c" translate="yes" xml:space="preserve">
          <source>assert, &lt;a href=&quot;expr#hevea_manual.kwd86&quot;&gt;7.7.8&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="635740097092e2b68a7644b5822ee2b10f283f3e" translate="yes" xml:space="preserve">
          <source>assert&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">assert&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ad025fd42fe9ff686831aa8d53087f4ec6eef49" translate="yes" xml:space="preserve">
          <source>at the end of pretty-printing, flush the pretty-printer to display all the remaining material, e.g. evaluate &lt;code&gt;print_newline&amp;nbsp;()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68c8b4d7fc1eb33ed288e6ff174b420fcadbab4" translate="yes" xml:space="preserve">
          <source>attr-id</source>
          <target state="translated">attr-id</target>
        </trans-unit>
        <trans-unit id="8d6f70260aa9cdd6cb0e7d628096d35d26e1ecb9" translate="yes" xml:space="preserve">
          <source>attr-payload</source>
          <target state="translated">attr-payload</target>
        </trans-unit>
        <trans-unit id="2c317cd0735d9046d7675c475fa1c6dce647953f" translate="yes" xml:space="preserve">
          <source>attribute</source>
          <target state="translated">attribute</target>
        </trans-unit>
        <trans-unit id="132060a9542263d8600782a359c79ea7e4420a18" translate="yes" xml:space="preserve">
          <source>attribute:</source>
          <target state="translated">attribute:</target>
        </trans-unit>
        <trans-unit id="0d612c12d2ac33625bf3e0351b6f5e4f73829fa8" translate="yes" xml:space="preserve">
          <source>auto</source>
          <target state="translated">auto</target>
        </trans-unit>
        <trans-unit id="e8a88cd5f1730052658100ac7c480655d9bb0697" translate="yes" xml:space="preserve">
          <source>avoids the rejection to the left of the inner boxes and print respectively &lt;code&gt;&quot;123456789&quot;&lt;/code&gt; and &lt;code&gt;&quot;123456789A&quot;&lt;/code&gt; . Note also that vertical boxes never fit on a line whereas horizontal boxes always fully fit on the current line. Opening a box may split a line whereas the contents may have fit. If this behavior is problematic, it can be curtailed by setting the maximum indentation limit to &lt;code&gt;margin&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;. Note that setting the maximum indentation limit to &lt;code&gt;margin&lt;/code&gt; is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9d71f5ee7c92d6dc9e92ffdad17b8bd49418f98" translate="yes" xml:space="preserve">
          <source>b</source>
          <target state="translated">b</target>
        </trans-unit>
        <trans-unit id="9b6f52b23ca4f9826b4afac22ef26467ec6a903d" translate="yes" xml:space="preserve">
          <source>backslash (\)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df93ce81475de263e8c9cd99e6db886626f778cb" translate="yes" xml:space="preserve">
          <source>backspace (BS)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d129197ad7bbf1516510a57dad2884265f6481" translate="yes" xml:space="preserve">
          <source>backstep [count]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba5efbbeae5af04794d9bfdfa1b67fbd6b2a754b" translate="yes" xml:space="preserve">
          <source>backtrace [count], bt [count]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c1c164d98ab04d2e7526e178c2bb0898d0e2c48" translate="yes" xml:space="preserve">
          <source>because the nested box &lt;code&gt;&quot;@[7@]&quot;&lt;/code&gt; is opened after the maximum indentation limit (&lt;code&gt;7&amp;gt;5&lt;/code&gt;) and its parent box does not fit on the current line. Either decreasing the length of the parent box to make it fit on a line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e58ac78738f8185ee5c7c2c3d83aca0198db529" translate="yes" xml:space="preserve">
          <source>becomes</source>
          <target state="translated">becomes</target>
        </trans-unit>
        <trans-unit id="a8b34082638e0ab7e5f1583cfeb4eaae1d137611" translate="yes" xml:space="preserve">
          <source>begin, &lt;a href=&quot;const#hevea_manual.kwd13&quot;&gt;7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd38&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd58&quot;&gt;7.7.2&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbbaa8525df456049f378ce5f890b00b21d15f96" translate="yes" xml:space="preserve">
          <source>begin&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;end</source>
          <target state="translated">begin&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;end</target>
        </trans-unit>
        <trans-unit id="d1dc25355bd9b369668d0373cf8c41939c1455bb" translate="yes" xml:space="preserve">
          <source>beginend</source>
          <target state="translated">beginend</target>
        </trans-unit>
        <trans-unit id="3fe6381046bb4b68161f33c5c83f32615ed528b6" translate="yes" xml:space="preserve">
          <source>binary (radix 2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad022478fc3c13fcde899deb3d9a5f6c35ad6ff0" translate="yes" xml:space="preserve">
          <source>blank-line</source>
          <target state="translated">blank-line</target>
        </trans-unit>
        <trans-unit id="80a25bf9e5d787c109376c0b79d204a87d3b2159" translate="yes" xml:space="preserve">
          <source>booleans</source>
          <target state="translated">booleans</target>
        </trans-unit>
        <trans-unit id="4f9cac8dbc4c67a388b8379dcc126c90c7c5e72a" translate="yes" xml:space="preserve">
          <source>break</source>
          <target state="translated">break</target>
        </trans-unit>
        <trans-unit id="8d6f2c43bf7d14f05fb406a9d11b58c27f57ccfa" translate="yes" xml:space="preserve">
          <source>break @ [module] #character</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20fb4da1603f2165312382ba6b7e3d575d006be2" translate="yes" xml:space="preserve">
          <source>break @ [module] line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d8bb500e6542711de79a9522950a0ad8d09ecb" translate="yes" xml:space="preserve">
          <source>break @ [module] line column</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c887c2526d97de3130955f38f51b2710ab19ca84" translate="yes" xml:space="preserve">
          <source>break frag:pc, break pc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="440c5d3712c1ce9be8754b77591e60e9d7572762" translate="yes" xml:space="preserve">
          <source>break function</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f71bf9164126dca1c327bcca37fd7ec31c7b94e2" translate="yes" xml:space="preserve">
          <source>buf:</source>
          <target state="translated">buf:</target>
        </trans-unit>
        <trans-unit id="885b44d5eac8ca9716435d7d2f0b938495af5313" translate="yes" xml:space="preserve">
          <source>build a list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c96e9b2af6622992b34c617e57c81324a1b22b0e" translate="yes" xml:space="preserve">
          <source>build an enumerated list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bb7ca68f1d3edf023c22979b31f0f08c02a05b7" translate="yes" xml:space="preserve">
          <source>builds the C libraries dllzip.so and libzip.a. Notice that the support libraries (-lz) and the corresponding options (-L/usr/local/zlib) must be given on all three invocations of ocamlmklib, because they are needed at different times depending on whether shared libraries are supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="511cde4c103875c617ba39c165112bd2d73e4def" translate="yes" xml:space="preserve">
          <source>builds the bytecode library zip.cma, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88bcc7f8344e049ea476cc39db2cb837f4351dfe" translate="yes" xml:space="preserve">
          <source>builds the native-code library zip.cmxa, and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6ab8be307405fed6a651c74d6a5644f4ff84d65" translate="yes" xml:space="preserve">
          <source>but they cannot be nested inside other patterns. For instance, the pattern Some (exception A) is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c56b6970aa26b3b1dcd7e2c05df93eb8064f9bd3" translate="yes" xml:space="preserve">
          <source>but this means that any code of the form</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c415733b56482edd139e3f7e0964c8f096b31d0" translate="yes" xml:space="preserve">
          <source>by using the &lt;code&gt;&quot;-pp&quot;&lt;/code&gt; command-line switch of the compilers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="daf529a73101c2be626b99fc6938163e7a27620b" translate="yes" xml:space="preserve">
          <source>bytes</source>
          <target state="translated">bytes</target>
        </trans-unit>
        <trans-unit id="84a516841ba77a5b4648de2cd0dfcb30ea46dbb4" translate="yes" xml:space="preserve">
          <source>c</source>
          <target state="translated">c</target>
        </trans-unit>
        <trans-unit id="03c15bf05ba15e346da77ead7dab8af27ed6c2f8" translate="yes" xml:space="preserve">
          <source>callback from C to OCaml (see section &lt;a href=&quot;#s%3Ac-callback&quot;&gt;20.7&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b71b4b35cc8fe63833d6e0e8185d7156c69e349" translate="yes" xml:space="preserve">
          <source>caml/alloc.h</source>
          <target state="translated">caml/alloc.h</target>
        </trans-unit>
        <trans-unit id="4471df25a307ba67e7aad2a84935b80ee087ba56" translate="yes" xml:space="preserve">
          <source>caml/callback.h</source>
          <target state="translated">caml/callback.h</target>
        </trans-unit>
        <trans-unit id="592c7ccf3ba8d4279c07377701d1330a620a0465" translate="yes" xml:space="preserve">
          <source>caml/custom.h</source>
          <target state="translated">caml/custom.h</target>
        </trans-unit>
        <trans-unit id="8792decdf7bf2bb976bd1e40904954d928525a86" translate="yes" xml:space="preserve">
          <source>caml/fail.h</source>
          <target state="translated">caml/fail.h</target>
        </trans-unit>
        <trans-unit id="f8667dfad754b997816f201603db4fba194f86fe" translate="yes" xml:space="preserve">
          <source>caml/intext.h</source>
          <target state="translated">caml/intext.h</target>
        </trans-unit>
        <trans-unit id="890fcb00d9fbe640855da092f035fa0325fa9d4d" translate="yes" xml:space="preserve">
          <source>caml/memory.h</source>
          <target state="translated">caml/memory.h</target>
        </trans-unit>
        <trans-unit id="3b9e73982305334ad406a6817eb43383bc9250f7" translate="yes" xml:space="preserve">
          <source>caml/mlvalues.h</source>
          <target state="translated">caml/mlvalues.h</target>
        </trans-unit>
        <trans-unit id="dffc05b944c1dae59e693eb0c0be9a909cd07363" translate="yes" xml:space="preserve">
          <source>caml/threads.h</source>
          <target state="translated">caml/threads.h</target>
        </trans-unit>
        <trans-unit id="81196066a86588828627518df7ffe94d080e24a7" translate="yes" xml:space="preserve">
          <source>caml_acquire_runtime_system() The calling thread re-acquires the master lock and other OCaml resources. It may block until no other thread uses the OCaml run-time system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a70c78f5895738a81bb9b00b34be9a45176c32b" translate="yes" xml:space="preserve">
          <source>caml_alloc(n, t) returns a fresh block of size n with tag t. If t is less than No_scan_tag, then the fields of the block are initialized with a valid value in order to satisfy the GC constraints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="217c9f33ff108e05317aa80431b9421dd0778d61" translate="yes" xml:space="preserve">
          <source>caml_alloc_array(f, a) allocates an array of values, calling function f over each element of the input array a to transform it into a value. The array a is an array of pointers terminated by the null pointer. The function f receives each pointer as argument, and returns a value. The zero-tagged block returned by alloc_array(f, a) is filled with the values returned by the successive calls to f. (This function must not be used to build an array of floating-point numbers.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b412c2fbef85869c951a4a1fef5484672e0be067" translate="yes" xml:space="preserve">
          <source>caml_alloc_boxed(v) allocates and returns a value (of any boxed type) whose field is the value v.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="665ee1b8b9002fba0f1725868331ec66b56f0143" translate="yes" xml:space="preserve">
          <source>caml_alloc_custom(ops, size, used, max)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bf94616c15dadf23974ee9a2d762495d67bb2c7" translate="yes" xml:space="preserve">
          <source>caml_alloc_custom_mem(ops, size, used)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3323e558e84f1a7378e11e2db8ff7ed4082f12bc" translate="yes" xml:space="preserve">
          <source>caml_alloc_float_array(n) allocates an array of floating point numbers of size n. The array initially contains uninitialized values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67e1c90ce20519fd8513d36af40857d4148bcf51" translate="yes" xml:space="preserve">
          <source>caml_alloc_initialized_string(n, p) returns a byte sequence (or string) value of length n bytes. The value is initialized from the n bytes starting at address p.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a46d60ca815b5fab7ffdb9b9cd4c97ff680a32a" translate="yes" xml:space="preserve">
          <source>caml_alloc_shr(n, t) returns a fresh block of size n, with tag t. The size of the block can be greater than &lt;code&gt;Max_young_wosize&lt;/code&gt;. (It can also be smaller, but in this case it is more efficient to call caml_alloc_small instead of caml_alloc_shr.) If this block is a structured block (i.e. if t &amp;lt; No_scan_tag), then the fields of the block (initially containing garbage) must be initialized with legal values (using the caml_initialize function described below) before the next allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9efca592b4526beda7a63fdc5fede30105d6950" translate="yes" xml:space="preserve">
          <source>caml_alloc_small(n, t) returns a fresh small block of size n &amp;le; Max_young_wosize words, with tag t. If this block is a structured block (i.e. if t &amp;lt; No_scan_tag), then the fields of the block (initially containing garbage) must be initialized with legal values (using direct assignment to the fields of the block) before the next allocation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7cfd3343e5e4c212d14c75252c0e1b517c5e6d4" translate="yes" xml:space="preserve">
          <source>caml_alloc_string(n) returns a byte sequence (or string) value of length n bytes. The sequence initially contains uninitialized bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f56f10eda49d4944e86ff916fd101e6b5dcaeec7" translate="yes" xml:space="preserve">
          <source>caml_alloc_tuple(n) returns a fresh block of size n words, with tag 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69c404c865e60cbf5daaf2f85055a9b0b490a426" translate="yes" xml:space="preserve">
          <source>caml_alloc_unboxable(v) calls either caml_alloc_unboxed or caml_alloc_boxed according to the default representation of unboxable types in the current version of OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cd673395971a1edb0e66a2e4c106d4bbdb61e94" translate="yes" xml:space="preserve">
          <source>caml_alloc_unboxed(v) returns the value (of any unboxed type) whose field is the value v.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d35e29583ecb00b187c8009920908fc57e9ae396" translate="yes" xml:space="preserve">
          <source>caml_ba_alloc(kind|layout, numdims, p, dims)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43a32453f66eadc5fcb7099b797e72909cbf1082" translate="yes" xml:space="preserve">
          <source>caml_ba_alloc_dims(kind|layout, numdims, p, (long) dim&lt;sub&gt;1&lt;/sub&gt;, (long) dim&lt;sub&gt;2&lt;/sub&gt;, &amp;hellip;, (long) dim&lt;sub&gt;numdims&lt;/sub&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9a2d346413d8e0258d8e23db6f2ecb7f1515a8d" translate="yes" xml:space="preserve">
          <source>caml_c_thread_register() registers the calling thread with the OCaml run-time system. Returns 1 on success, 0 on error. Registering an already-registered thread does nothing and returns 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f5eeb608e25a7e56c4a9a10180e60be6106887" translate="yes" xml:space="preserve">
          <source>caml_c_thread_unregister() must be called before the thread terminates, to unregister it from the OCaml run-time system. Returns 1 on success, 0 on error. If the calling thread was not previously registered, does nothing and returns 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05a88f8527c729e1b9db0097f427661299ac3aaf" translate="yes" xml:space="preserve">
          <source>caml_callback(f, a) applies the functional value f to the value a and returns the value returned by f.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="820e3ded86f605764643a7eed336c5000064f192" translate="yes" xml:space="preserve">
          <source>caml_callback2(f, a, b) applies the functional value f (which is assumed to be a curried OCaml function with two arguments) to a and b.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe5c03d3316677716a3d2a00f8d2ee24d6f972a1" translate="yes" xml:space="preserve">
          <source>caml_callback3(f, a, b, c) applies the functional value f (a curried OCaml function with three arguments) to a, b and c.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0233fd6bd1e96cfb8d2974ba591ba865db2ae1a0" translate="yes" xml:space="preserve">
          <source>caml_callbackN(f, n, args) applies the functional value f to the n arguments contained in the array of values args.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf354aacfc7103b94817ae65879f1489304072e" translate="yes" xml:space="preserve">
          <source>caml_copy_double(d) returns a floating-point value initialized with the doubled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec539f275c2dff88912942f70a765beb82287158" translate="yes" xml:space="preserve">
          <source>caml_copy_int32(i), caml_copy_int64(i) and caml_copy_nativeint(i) return a value of OCaml type int32, int64 and nativeint, respectively, initialized with the integer i.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2471864cc31009e8a1e62e42528d1575ed25f539" translate="yes" xml:space="preserve">
          <source>caml_copy_string(s) returns a string or byte sequence value containing a copy of the null-terminated C string s (a char *).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74f9c7eaafeaaa2a5ea3107d6472ba41f837ffb2" translate="yes" xml:space="preserve">
          <source>caml_copy_string_array(p) allocates an array of strings or byte sequences, copied from the pointer to a string array p (a char **). p must be NULL-terminated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="918cf518214782b1cc0e33fd17a49ac9aeacaa93" translate="yes" xml:space="preserve">
          <source>caml_deserialize_block_1</source>
          <target state="translated">caml_deserialize_block_1</target>
        </trans-unit>
        <trans-unit id="dac44adcc649f794a823bc613a4f99f79375c99d" translate="yes" xml:space="preserve">
          <source>caml_deserialize_block_2</source>
          <target state="translated">caml_deserialize_block_2</target>
        </trans-unit>
        <trans-unit id="35407d685d291cd8f9a87c8097d5cc11738aac8e" translate="yes" xml:space="preserve">
          <source>caml_deserialize_block_4</source>
          <target state="translated">caml_deserialize_block_4</target>
        </trans-unit>
        <trans-unit id="e33c938fab61721b51eed15194e2d30eb87000a0" translate="yes" xml:space="preserve">
          <source>caml_deserialize_block_8</source>
          <target state="translated">caml_deserialize_block_8</target>
        </trans-unit>
        <trans-unit id="01d9f69b15f4f41d9244f9c3804c975a64b6158a" translate="yes" xml:space="preserve">
          <source>caml_deserialize_error</source>
          <target state="translated">caml_deserialize_error</target>
        </trans-unit>
        <trans-unit id="1f492cf546e5c7087c942020ba6d5961ccc348b9" translate="yes" xml:space="preserve">
          <source>caml_deserialize_float_4</source>
          <target state="translated">caml_deserialize_float_4</target>
        </trans-unit>
        <trans-unit id="0b6e78572b4ac229628c458e0ecaa2fb7295151c" translate="yes" xml:space="preserve">
          <source>caml_deserialize_float_8</source>
          <target state="translated">caml_deserialize_float_8</target>
        </trans-unit>
        <trans-unit id="8a9cf39c1b25ec605de44f1545bee50da0e5401a" translate="yes" xml:space="preserve">
          <source>caml_deserialize_sint_1</source>
          <target state="translated">caml_deserialize_sint_1</target>
        </trans-unit>
        <trans-unit id="7136f8685a8e7a942bf14dcdcde72910b80d0e77" translate="yes" xml:space="preserve">
          <source>caml_deserialize_sint_2</source>
          <target state="translated">caml_deserialize_sint_2</target>
        </trans-unit>
        <trans-unit id="476465cf53e5d050cfacddced1f8c3835ba60d4a" translate="yes" xml:space="preserve">
          <source>caml_deserialize_sint_4</source>
          <target state="translated">caml_deserialize_sint_4</target>
        </trans-unit>
        <trans-unit id="3a0dc876c85eec7de4289c833125ae2cacd8a3aa" translate="yes" xml:space="preserve">
          <source>caml_deserialize_sint_8</source>
          <target state="translated">caml_deserialize_sint_8</target>
        </trans-unit>
        <trans-unit id="da233c41683a76e16c83d1a9ab274d83e246577a" translate="yes" xml:space="preserve">
          <source>caml_deserialize_uint_1</source>
          <target state="translated">caml_deserialize_uint_1</target>
        </trans-unit>
        <trans-unit id="c7e3e69e51156b2134966606c7ec2dc3f2e9ad44" translate="yes" xml:space="preserve">
          <source>caml_deserialize_uint_2</source>
          <target state="translated">caml_deserialize_uint_2</target>
        </trans-unit>
        <trans-unit id="f28316e19f353ff58baba442c8c6cd6d7884d9a9" translate="yes" xml:space="preserve">
          <source>caml_deserialize_uint_4</source>
          <target state="translated">caml_deserialize_uint_4</target>
        </trans-unit>
        <trans-unit id="aede7b6eb7681bcf0c5ebd81e6fceae87718bafa" translate="yes" xml:space="preserve">
          <source>caml_deserialize_uint_8</source>
          <target state="translated">caml_deserialize_uint_8</target>
        </trans-unit>
        <trans-unit id="416e7610539057f60428828cf59eb4906d8ddee0" translate="yes" xml:space="preserve">
          <source>caml_enter_blocking_section as an alias for caml_release_runtime_system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14a7ce9f3a6006e7f1c8fad15bbf4d6a0f804631" translate="yes" xml:space="preserve">
          <source>caml_failwith(s), where s is a null-terminated C string (with type &lt;code&gt;char *&lt;/code&gt;), raises exception Failure with argument s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d27d8138c2cbd7e1f6803c0423040e3884da98e" translate="yes" xml:space="preserve">
          <source>caml_field_boxed(v) returns the value of the field of a value v of any boxed type (record or concrete data type).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb81ee26ea7b5ed3a3714239c218e0aa5d478b7" translate="yes" xml:space="preserve">
          <source>caml_field_unboxable(v) calls either caml_field_unboxed or caml_field_boxed according to the default representation of unboxable types in the current version of OCaml.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f31cce61ed462e58bd73936dd1de28e076cf6ae6" translate="yes" xml:space="preserve">
          <source>caml_field_unboxed(v) returns the value of the field of a value v of any unboxed type (record or concrete data type).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fabe664c7f517d5d094066c161e25ead36a65f60" translate="yes" xml:space="preserve">
          <source>caml_invalid_argument(s), where s is a null-terminated C string (with type &lt;code&gt;char *&lt;/code&gt;), raises exception Invalid_argument with argument s.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02bae75839fb1bf56fa1ec0b6cd98dfa5e4295f5" translate="yes" xml:space="preserve">
          <source>caml_leave_blocking_section as an alias for caml_acquire_runtime_system</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="356ae13a054640e5af072dd6bcc0d2834d37f10c" translate="yes" xml:space="preserve">
          <source>caml_raise_constant(id) raises the exception id with no argument;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="858fd18e0bc5a5829c8ac6e60bb9d8283b082858" translate="yes" xml:space="preserve">
          <source>caml_raise_with_arg(id, v) raises the exception id with the OCaml value v as argument;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d64e10fe5ed3863f7d0bb0fe72f1513e8a8f2b" translate="yes" xml:space="preserve">
          <source>caml_raise_with_args(id, n, v) raises the exception id with the OCaml values v[0], &amp;hellip;, v[n-1] as arguments;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c0c66567ef1c96c698ce066439e5f630905c3a9" translate="yes" xml:space="preserve">
          <source>caml_raise_with_string(id, s), where s is a null-terminated C string, raises the exception id with a copy of the C string s as argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287a35972bf162ebc29d2aa934cbd84dae2c36c2" translate="yes" xml:space="preserve">
          <source>caml_release_runtime_system() The calling thread releases the master lock and other OCaml resources, enabling other threads to run OCaml code in parallel with the execution of the calling thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae63c20bf1c4bb6a020f7324ec24e730e1502926" translate="yes" xml:space="preserve">
          <source>caml_serialize_block_1</source>
          <target state="translated">caml_serialize_block_1</target>
        </trans-unit>
        <trans-unit id="1f88a94e85c7f6efd8c4040e372002762ddd5ce1" translate="yes" xml:space="preserve">
          <source>caml_serialize_block_2</source>
          <target state="translated">caml_serialize_block_2</target>
        </trans-unit>
        <trans-unit id="7f65027df7939a869ab29fbc0899535001b0c56f" translate="yes" xml:space="preserve">
          <source>caml_serialize_block_4</source>
          <target state="translated">caml_serialize_block_4</target>
        </trans-unit>
        <trans-unit id="fdfab415c6d00981ab8eb822efb29e78a99a1d98" translate="yes" xml:space="preserve">
          <source>caml_serialize_block_8</source>
          <target state="translated">caml_serialize_block_8</target>
        </trans-unit>
        <trans-unit id="36a3049b031f4083e92b7d4b9711c0de54316b78" translate="yes" xml:space="preserve">
          <source>caml_serialize_float_4</source>
          <target state="translated">caml_serialize_float_4</target>
        </trans-unit>
        <trans-unit id="f743618d0b25010412d98c92620a0c84e87fff70" translate="yes" xml:space="preserve">
          <source>caml_serialize_float_8</source>
          <target state="translated">caml_serialize_float_8</target>
        </trans-unit>
        <trans-unit id="23603973b40d624874498ff401f6b6f1e7c4db00" translate="yes" xml:space="preserve">
          <source>caml_serialize_int_1</source>
          <target state="translated">caml_serialize_int_1</target>
        </trans-unit>
        <trans-unit id="e1ce658bb59ae754affc221a0fc0f480ede7017a" translate="yes" xml:space="preserve">
          <source>caml_serialize_int_2</source>
          <target state="translated">caml_serialize_int_2</target>
        </trans-unit>
        <trans-unit id="66dd30967cf335aca785df52b55e84a69dbbdc79" translate="yes" xml:space="preserve">
          <source>caml_serialize_int_4</source>
          <target state="translated">caml_serialize_int_4</target>
        </trans-unit>
        <trans-unit id="e8140ea757da273e868ac4101e99d59e556d53b4" translate="yes" xml:space="preserve">
          <source>caml_serialize_int_8</source>
          <target state="translated">caml_serialize_int_8</target>
        </trans-unit>
        <trans-unit id="4b456eebdecfa8b8e1aa7110502a15dfda1f3606" translate="yes" xml:space="preserve">
          <source>caml_string_length(v) returns the length (number of bytes) of the string or byte sequence v.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9351fe8845b904696063fb13e86c9bc94efe9685" translate="yes" xml:space="preserve">
          <source>can be refined in two ways. A definition [u] may add new field to [t], and the declaration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad1e766cc8178e6f6ad74e38ff2897d6a38ad799" translate="yes" xml:space="preserve">
          <source>can only wait for a given PID, not any child process</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5df64e3c8e78211b701b9d8971c1063ca8f2e1b6" translate="yes" xml:space="preserve">
          <source>capitalized-ident</source>
          <target state="translated">capitalized-ident</target>
        </trans-unit>
        <trans-unit id="28e01c21872f76a357676cc09019dabc3abd13de" translate="yes" xml:space="preserve">
          <source>carriage return (CR)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="338daab440e97efde55f37074a6c9d0cfceff0a2" translate="yes" xml:space="preserve">
          <source>cddirectory</source>
          <target state="translated">cddirectory</target>
        </trans-unit>
        <trans-unit id="4f5b1a054e184cc853d48ac01253e6ac5a470d9a" translate="yes" xml:space="preserve">
          <source>center &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71fafc4e2fc1e47e234762a96b80512b6b5534c2" translate="yes" xml:space="preserve">
          <source>char</source>
          <target state="translated">char</target>
        </trans-unit>
        <trans-unit id="7dbf01c25b781fe0b168381bf3b25fb375fb567f" translate="yes" xml:space="preserve">
          <source>char *identifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d521d46e1370c48f989e9725c1abd207ee1d3a44" translate="yes" xml:space="preserve">
          <source>char* caml_stat_strdup_of_os(const char_os *) copies the argument while translating from the platform encoding to the OCaml encoding. It is the inverse of caml_stat_strdup_to_os. This function is typically used to convert a string obtained from the operating system before passing it on to OCaml code. Under Unix, it is equivalent to caml_stat_strdup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c841c7d2b2460cf8b4fae3611f52dff8e7413b4" translate="yes" xml:space="preserve">
          <source>char-literal</source>
          <target state="translated">char-literal</target>
        </trans-unit>
        <trans-unit id="0658481307f1c9bf812b837154f546a05ee9b13d" translate="yes" xml:space="preserve">
          <source>char_os* caml_stat_strdup_to_os(const char *) copies the argument while translating from OCaml encoding to the platform encoding. This function is typically used to convert the char * underlying an OCaml string before passing it to an operating system API that takes a Unicode argument. Under Unix, it is equivalent to caml_stat_strdup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa908a40ba515918f9d5edbdcad8ebc1fe5c2b42" translate="yes" xml:space="preserve">
          <source>characters</source>
          <target state="translated">characters</target>
        </trans-unit>
        <trans-unit id="0e2b31b5675ecfcea28e1bc6ea61266b418c839f" translate="yes" xml:space="preserve">
          <source>chown, fchown</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d767bf5b72373d12f0efd4406677e9ed076f592" translate="yes" xml:space="preserve">
          <source>class</source>
          <target state="translated">class</target>
        </trans-unit>
        <trans-unit id="d52a33eead97a71117a46cf4e95a8a4ce30467f3" translate="yes" xml:space="preserve">
          <source>class method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb8b29ba2c361968b2542a776a9c3dfff4a1f277" translate="yes" xml:space="preserve">
          <source>class names (&lt;a href=&quot;#class-name&quot;&gt;class-name&lt;/a&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbf274f2daef387a23dffa13382373a5bcc2c55b" translate="yes" xml:space="preserve">
          <source>class type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3e7be6c69d88342536203b1571fd7d8bfb2a3df" translate="yes" xml:space="preserve">
          <source>class, &lt;a href=&quot;classes#hevea_manual.kwd143&quot;&gt;7.9.3&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd145&quot;&gt;7.9.4&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd147&quot;&gt;7.9.5&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd159&quot;&gt;7.10&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd169&quot;&gt;7.10.2&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd170&quot;&gt;7.10.2&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd187&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd197&quot;&gt;7.11.2&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd198&quot;&gt;7.11.2&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71bcf10511fad568b629d28c56ff7feff1ef22f7" translate="yes" xml:space="preserve">
          <source>class-binding</source>
          <target state="translated">class-binding</target>
        </trans-unit>
        <trans-unit id="0dfa40de86f0d8af7138c27b80cfce36b3e092c6" translate="yes" xml:space="preserve">
          <source>class-body</source>
          <target state="translated">class-body</target>
        </trans-unit>
        <trans-unit id="e3baf4e73ca120ee7eaaeeed64f1dc7bbc328d9e" translate="yes" xml:space="preserve">
          <source>class-body-type</source>
          <target state="translated">class-body-type</target>
        </trans-unit>
        <trans-unit id="b8003ad6cd8fb711d7fb1d099487681287d8df0d" translate="yes" xml:space="preserve">
          <source>class-definition</source>
          <target state="translated">class-definition</target>
        </trans-unit>
        <trans-unit id="9215a2ca4557897b343427716abc124d47fa6558" translate="yes" xml:space="preserve">
          <source>class-expr</source>
          <target state="translated">class-expr</target>
        </trans-unit>
        <trans-unit id="a3845894896b3c7333fdff3aa49c932e3bffd95e" translate="yes" xml:space="preserve">
          <source>class-field</source>
          <target state="translated">class-field</target>
        </trans-unit>
        <trans-unit id="b080298e07289b6ef306ac5023ced1575edeac2d" translate="yes" xml:space="preserve">
          <source>class-field-spec</source>
          <target state="translated">class-field-spec</target>
        </trans-unit>
        <trans-unit id="21af04aa3b5af0ea90010d0c0914efac38e9ea5a" translate="yes" xml:space="preserve">
          <source>class-name</source>
          <target state="translated">class-name</target>
        </trans-unit>
        <trans-unit id="d4c74f244ee67cc96905b30b781591e6acf2753f" translate="yes" xml:space="preserve">
          <source>class-path</source>
          <target state="translated">class-path</target>
        </trans-unit>
        <trans-unit id="06c5a4fb1e6da1b8f0f1f913fe3fafb4f95b0582" translate="yes" xml:space="preserve">
          <source>class-spec</source>
          <target state="translated">class-spec</target>
        </trans-unit>
        <trans-unit id="d9f224575fb0d8b3c6c3d80f66cef25947fff065" translate="yes" xml:space="preserve">
          <source>class-specification</source>
          <target state="translated">class-specification</target>
        </trans-unit>
        <trans-unit id="eda43ef03abd77f6ca03a3bb4e37dd8ba826fff5" translate="yes" xml:space="preserve">
          <source>class-type</source>
          <target state="translated">class-type</target>
        </trans-unit>
        <trans-unit id="ef958ab46a4f3085af1d4d4f55658cb4444ca230" translate="yes" xml:space="preserve">
          <source>class:</source>
          <target state="translated">class:</target>
        </trans-unit>
        <trans-unit id="400e5d81583e055c53bd38f8d5544fa644ba2712" translate="yes" xml:space="preserve">
          <source>class&lt;a href=&quot;#class-binding&quot;&gt;class-binding&lt;/a&gt; { and&lt;a href=&quot;#class-binding&quot;&gt;class-binding&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dadb31ea72fd62d213f58fa6711bc7b519a2ca1" translate="yes" xml:space="preserve">
          <source>class&lt;a href=&quot;#class-spec&quot;&gt;class-spec&lt;/a&gt; { and&lt;a href=&quot;#class-spec&quot;&gt;class-spec&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab6ab98b836d6d64d4b9f3146b49cbcf9bee6717" translate="yes" xml:space="preserve">
          <source>classtype-def</source>
          <target state="translated">classtype-def</target>
        </trans-unit>
        <trans-unit id="d92dac5dc34da28e49df894b68924460d949a415" translate="yes" xml:space="preserve">
          <source>classtype-definition</source>
          <target state="translated">classtype-definition</target>
        </trans-unit>
        <trans-unit id="285d92bdbee34465a7fdf92fb82c39749f0f039e" translate="yes" xml:space="preserve">
          <source>classtype-path</source>
          <target state="translated">classtype-path</target>
        </trans-unit>
        <trans-unit id="4c04636c06981fe9f6d61d92d9456af7b3de3e8a" translate="yes" xml:space="preserve">
          <source>classtype:</source>
          <target state="translated">classtype:</target>
        </trans-unit>
        <trans-unit id="869829acd738c5dac3bc8510eb02c66e1ad5db8e" translate="yes" xml:space="preserve">
          <source>classtype&lt;a href=&quot;#classtype-def&quot;&gt;classtype-def&lt;/a&gt; { and&lt;a href=&quot;#classtype-def&quot;&gt;classtype-def&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68279b7a5c5dbc171919343dde1977e500869832" translate="yes" xml:space="preserve">
          <source>cmp:</source>
          <target state="translated">cmp:</target>
        </trans-unit>
        <trans-unit id="553768b3bee6925c1b6dd1539addb6cb588d0c7b" translate="yes" xml:space="preserve">
          <source>command subcommand &lt;code&gt;options&lt;/code&gt; where the list of options depends on the value of the subcommand argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="428a468feca925744523643cf7e53ce50f474323" translate="yes" xml:space="preserve">
          <source>comparisons (&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, etc, as well as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92feb91459c458aa6b1f76052516855e022d15d8" translate="yes" xml:space="preserve">
          <source>compile to native code. Without these conditions being satisfied the functions in this module will have no effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1877bd461ec69e59e632c38c04de5ad31c85ef37" translate="yes" xml:space="preserve">
          <source>configure the compiler with &quot;-spacetime&quot;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e084f18133250f2e634eae29d9045ab677b4937" translate="yes" xml:space="preserve">
          <source>const struct custom_fixed_length* fixed_length</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdc40c00b134ba2e17aaa12820a0f9d7af1fb7c5" translate="yes" xml:space="preserve">
          <source>const:</source>
          <target state="translated">const:</target>
        </trans-unit>
        <trans-unit id="d810ca965a236c6f46a932efff918a4b3a191918" translate="yes" xml:space="preserve">
          <source>constant</source>
          <target state="translated">constant</target>
        </trans-unit>
        <trans-unit id="d99aa54a7aa7e291a189a778f95a6a8b54eadd02" translate="yes" xml:space="preserve">
          <source>constr</source>
          <target state="translated">constr</target>
        </trans-unit>
        <trans-unit id="7c2459502a99827d118c6620780fd83c34d7c818" translate="yes" xml:space="preserve">
          <source>constr-args</source>
          <target state="translated">constr-args</target>
        </trans-unit>
        <trans-unit id="6aaf7dc052404a0def924d13cb7fefd2c5d46800" translate="yes" xml:space="preserve">
          <source>constr-decl</source>
          <target state="translated">constr-decl</target>
        </trans-unit>
        <trans-unit id="f14414ed569b076ce031ad6d07e8e61ed758ca68" translate="yes" xml:space="preserve">
          <source>constr-def</source>
          <target state="translated">constr-def</target>
        </trans-unit>
        <trans-unit id="26ced0ba99c41fdb04e52808108512ce54059fb1" translate="yes" xml:space="preserve">
          <source>constr-name</source>
          <target state="translated">constr-name</target>
        </trans-unit>
        <trans-unit id="07822dfb3ad950224ca5f923721fae3aaa4b28c5" translate="yes" xml:space="preserve">
          <source>constraint'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;</source>
          <target state="translated">constraint'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="33a4124293eb998e782195710e0d6c1e376e9593" translate="yes" xml:space="preserve">
          <source>constraint, &lt;a href=&quot;typedecl#hevea_manual.kwd97&quot;&gt;7.8.1&lt;/a&gt;, &lt;a href=&quot;typedecl#hevea_manual.kwd99&quot;&gt;7.8.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd109&quot;&gt;7.9.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd117&quot;&gt;7.9.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd129&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd141&quot;&gt;7.9.2&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f12e05c5db5e00db727da146959722b2d63e6127" translate="yes" xml:space="preserve">
          <source>constraint&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;</source>
          <target state="translated">constraint&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05d2609d4b6af181eb59c550508ff23be347961d" translate="yes" xml:space="preserve">
          <source>contains a reference to compilation unit M when compiled to bytecode. This reference forces M to be linked and its initialization code to be executed. The native-code compiler eliminates the reference to M, hence the compilation unit M may not be linked and executed. A workaround is to compile M with the -linkall flag so that it will always be linked and executed, even if not referenced. See also the Sys.opaque_identity function from the Sys standard library module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226d200456eb3bfd352f53e040b453787b46cc24" translate="yes" xml:space="preserve">
          <source>contextual</source>
          <target state="translated">contextual</target>
        </trans-unit>
        <trans-unit id="d32f507e70819a8b5872a31e2e7880f8f11db8fa" translate="yes" xml:space="preserve">
          <source>conversion specifications, each of which causes reading and conversion of one argument for the function &lt;code&gt;f&lt;/code&gt; (see &lt;a href=&quot;scanf#conversion&quot;&gt;&lt;i&gt;Conversion specifications in format strings&lt;/i&gt;&lt;/a&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333d8a7c2bd7fd4cefaebb4cc6271338502485c6" translate="yes" xml:space="preserve">
          <source>core-operator-char</source>
          <target state="translated">core-operator-char</target>
        </trans-unit>
        <trans-unit id="8a808c90d9a84d21576ddf0beed9d69f191be593" translate="yes" xml:space="preserve">
          <source>corresponds to private variant types. One cannot create a value of the private type [v], except using the constructors that are explicitly listed as present, (`A n) in this example; yet, when patter-matching on a [v], one should assume that any of the constructors of [t] could be present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7013e4aaa88a7fafd5559318a944cd9c6ec28404" translate="yes" xml:space="preserve">
          <source>create the file if it does not exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c363836cf4e16666669a25da280a1865c2d2874" translate="yes" xml:space="preserve">
          <source>d</source>
          <target state="translated">d</target>
        </trans-unit>
        <trans-unit id="e19492b548515ffbe34cf17cbd1ef522ab1414dc" translate="yes" xml:space="preserve">
          <source>decrements in process virtual time, and sends &lt;code&gt;SIGVTALRM&lt;/code&gt; when expired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef778d13de8cafc01808a69b9932094f49798fdd" translate="yes" xml:space="preserve">
          <source>decrements in real time, and sends the signal &lt;code&gt;SIGALRM&lt;/code&gt; when expired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22c6a976d9866fd964b6e5a20af7db6ea2ab552" translate="yes" xml:space="preserve">
          <source>define</source>
          <target state="translated">define</target>
        </trans-unit>
        <trans-unit id="03a76339fa4d42bfdc8e8baceab3440cef624007" translate="yes" xml:space="preserve">
          <source>defining the module B as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3f1dd33eb2a8b380b64a830e5fd90eab77d9ff3" translate="yes" xml:space="preserve">
          <source>definition</source>
          <target state="translated">definition</target>
        </trans-unit>
        <trans-unit id="3e327c241738fea022a517d9eecee46776680496" translate="yes" xml:space="preserve">
          <source>definition of the value type, and conversion macros</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed58bf3be1d2a5949990ba23d28e1f05c882f8a3" translate="yes" xml:space="preserve">
          <source>delete [breakpoint-numbers]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0179ecbcdaafefd6b259581d27637a1a01473312" translate="yes" xml:space="preserve">
          <source>directive-argument</source>
          <target state="translated">directive-argument</target>
        </trans-unit>
        <trans-unit id="8d392f56d616a516ceabb82ed8906418bce4647d" translate="yes" xml:space="preserve">
          <source>directory</source>
          <target state="translated">directory</target>
        </trans-unit>
        <trans-unit id="28dc9d3b1bb1b104a7917c77a1d97552e99c49a2" translate="yes" xml:space="preserve">
          <source>directorydirectorynames</source>
          <target state="translated">directorydirectorynames</target>
        </trans-unit>
        <trans-unit id="9b0115d2d38b2bf10f676e8332fc03cddd564a00" translate="yes" xml:space="preserve">
          <source>directorydirectorynamesformodulename</source>
          <target state="translated">directorydirectorynamesformodulename</target>
        </trans-unit>
        <trans-unit id="53c975b51fbabf80b49198bf9458a9e1d290fcf9" translate="yes" xml:space="preserve">
          <source>disable color output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0ea05e5435bb0df5d81d6e78b6d0af265162e9" translate="yes" xml:space="preserve">
          <source>display variables</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5c0f9710c0d52c78a4d013cd66763d60d97bcb7" translate="yes" xml:space="preserve">
          <source>do not block if no child has died yet, but immediately return with a pid equal to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833c8b98d0224690df2f190dea1efcb42f344fbb" translate="yes" xml:space="preserve">
          <source>do, see while, for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d84288230cbd24a8cc378cfb3d714310728faf29" translate="yes" xml:space="preserve">
          <source>does not need to be evaluated at all; and/or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38fd56990cf282add706144ed22e70a66191320c" translate="yes" xml:space="preserve">
          <source>done, see while, for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07eb0e52b368fc215197e9dccccc06b07fad2958" translate="yes" xml:space="preserve">
          <source>dot-ext</source>
          <target state="translated">dot-ext</target>
        </trans-unit>
        <trans-unit id="453a36a657365591af7b5c95c20406ec99ef8b24" translate="yes" xml:space="preserve">
          <source>dot-operator-char</source>
          <target state="translated">dot-operator-char</target>
        </trans-unit>
        <trans-unit id="bdb36bb22deb169275b3094ba9005a29eeddd195" translate="yes" xml:space="preserve">
          <source>double</source>
          <target state="translated">double</target>
        </trans-unit>
        <trans-unit id="bfbe0565f9808b4fb0e1b18327fbb6c2ea967077" translate="yes" xml:space="preserve">
          <source>double quote (&quot;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f65fab5c0d7d9bcd8d721da02004fedaedb68be" translate="yes" xml:space="preserve">
          <source>down [count]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799e0a3b5afe04c89326401016fc0c66d4458b42" translate="yes" xml:space="preserve">
          <source>downto, see for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e407d8cdd0f285d5c62e80663efb9cc02851303c" translate="yes" xml:space="preserve">
          <source>drops all bindings of &lt;code&gt;m&lt;/code&gt; whose value is an empty list, and pops the first element of each value that is non-empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a6a677a43d8f38a109cb03dec2a64920269ab9" translate="yes" xml:space="preserve">
          <source>dst:</source>
          <target state="translated">dst:</target>
        </trans-unit>
        <trans-unit id="58e6b3a414a1e090dfc6029add0f3555ccba127f" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">e</target>
        </trans-unit>
        <trans-unit id="757397c6e0613e4417358197d53f7db2c37b4724" translate="yes" xml:space="preserve">
          <source>e has no free occurrence of any of name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51fe7f7274e0449b5ed33b2fcaa9170dab3b3628" translate="yes" xml:space="preserve">
          <source>e has one of the following forms, where each one of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt; is statically constructive with respect to name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt;, and &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt; is statically constructive with respect to name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt;, xname&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; xname&lt;sub&gt;m&lt;/sub&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcf7c2ddc6f44c64ae6b993a53f6e3ea4c518399" translate="yes" xml:space="preserve">
          <source>e has the form &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt; where &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt; is immediately linked to name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df2817894d7dee8de8758ce8f735537aea0b6367" translate="yes" xml:space="preserve">
          <source>e has the form fun &amp;hellip; -&amp;gt; &amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd8e665d7df99e337c22b1c4be2c513409b5eaa9" translate="yes" xml:space="preserve">
          <source>e has the form function &amp;hellip; -&amp;gt; &amp;hellip;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99ac9ada8c9fe80980d92b1caa59645274bb0a33" translate="yes" xml:space="preserve">
          <source>e has the form lazy( &amp;hellip; )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4de602197c0cd9ccd7c6607098ee6083dc9167b" translate="yes" xml:space="preserve">
          <source>e has the form let [rec] xname&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;and &amp;hellip; andxname&lt;sub&gt;m&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt; where &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt; is immediately linked to name or to one of the xname&lt;sub&gt;i&lt;/sub&gt; such that &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; is immediately linked to name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0656ec9ffb0b7921a052be24cfb4ae15f4ee4e3" translate="yes" xml:space="preserve">
          <source>e is a variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26a1d03b4fa9567db0939f772ff344bebbfe891b" translate="yes" xml:space="preserve">
          <source>e is name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2da461a9fb84c0ad13f2efac393ac2ead59815a2" translate="yes" xml:space="preserve">
          <source>e. g.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c318f6c6008d67b9664c3c45b78e7730ca703d" translate="yes" xml:space="preserve">
          <source>else, see if</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2d24c4d91f1728ade8f4dd643d87531b3263243" translate="yes" xml:space="preserve">
          <source>emphasize &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cedcf2a1a6ef9de21d881662e38b02d6d3f8384b" translate="yes" xml:space="preserve">
          <source>empty the file if it already exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b17ec36e9379c05dc57269321d86b686f2333096" translate="yes" xml:space="preserve">
          <source>enable colors unconditionally;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aef0b24e7008d716738f718268f4d8c0207432a1" translate="yes" xml:space="preserve">
          <source>end, &lt;a href=&quot;const#hevea_manual.kwd14&quot;&gt;7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd39&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd59&quot;&gt;7.7.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd102&quot;&gt;7.9.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd119&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd151&quot;&gt;7.10&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd164&quot;&gt;7.10.2&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd180&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd192&quot;&gt;7.11.2&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711175fbdbe24885e9f9f679df119dc29c631f8b" translate="yes" xml:space="preserve">
          <source>entrypoint [exp&lt;sub&gt;1&lt;/sub&gt;&amp;hellip; exp&lt;sub&gt;n&lt;/sub&gt;] lexbuf</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a365f95cb8551a2062717881f7d71e5306abd5" translate="yes" xml:space="preserve">
          <source>eof</source>
          <target state="translated">eof</target>
        </trans-unit>
        <trans-unit id="3d049c928df32d101c29c26b373821a507099452" translate="yes" xml:space="preserve">
          <source>escape-sequence</source>
          <target state="translated">escape-sequence</target>
        </trans-unit>
        <trans-unit id="8d2bca9a432a39e18786835ac3975c3b23f451e6" translate="yes" xml:space="preserve">
          <source>escaped-string</source>
          <target state="translated">escaped-string</target>
        </trans-unit>
        <trans-unit id="9766db168aaf6a914bfb8cbba6191943d675fe12" translate="yes" xml:space="preserve">
          <source>establish_server</source>
          <target state="translated">establish_server</target>
        </trans-unit>
        <trans-unit id="d8d42401720c70b1ce0ae3ec57d8973f649448c8" translate="yes" xml:space="preserve">
          <source>evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; in some unspecified order and matches their values against the patterns &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. If the matchings succeed, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is evaluated in the environment enriched by the bindings performed during matching, and the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is returned as the value of the whole let expression. If one of the matchings fails, the exception Match_failure is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b7de6ac0851edd15ea66f92bc8e0791529d96f" translate="yes" xml:space="preserve">
          <source>evaluates the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; and returns its value if the evaluation of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; does not raise any exception. If the evaluation of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; raises an exception, the exception value is matched against the patterns &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. If the matching against &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; succeeds, the associated expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; is evaluated, and its value becomes the value of the whole try expression. The evaluation of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; takes place in an environment enriched by the bindings performed during matching. If several patterns match the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, the one that occurs first in the try expression is selected. If none of the patterns matches the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, the exception value is raised again, thereby transparently &amp;ldquo;passing through&amp;rdquo; the try construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d42ad1769f229c76031f30a404b4f7863d68de0" translate="yes" xml:space="preserve">
          <source>exception</source>
          <target state="translated">exception</target>
        </trans-unit>
        <trans-unit id="0ef70e6a0aa89b4ca352814bdbb1a646404b65f4" translate="yes" xml:space="preserve">
          <source>exception, &lt;a href=&quot;typedecl#hevea_manual.kwd100&quot;&gt;7.8.2&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd158&quot;&gt;7.10&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd168&quot;&gt;7.10.2&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd186&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd196&quot;&gt;7.11.2&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4c059f88a3ed4105696537b7858f2b73b79d996" translate="yes" xml:space="preserve">
          <source>exception-definition</source>
          <target state="translated">exception-definition</target>
        </trans-unit>
        <trans-unit id="aafc45f113e4ee4827753cfa5ddd32f6b9b8e7dd" translate="yes" xml:space="preserve">
          <source>exception:</source>
          <target state="translated">exception:</target>
        </trans-unit>
        <trans-unit id="2194fd1cdf62726bf2b756afa4c471797a6ff1e0" translate="yes" xml:space="preserve">
          <source>exception&lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt;</source>
          <target state="translated">exception&lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56f0b21b284fbbc9f75a6e2a8846ecee8d477c99" translate="yes" xml:space="preserve">
          <source>exception&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;</source>
          <target state="translated">exception&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ff60ca6f137fe92c59a4b2a5d3687066ffd89487" translate="yes" xml:space="preserve">
          <source>exception&lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt;=&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;</source>
          <target state="translated">exception&lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt;=&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3f3369e0544e158e7e2b5b8651c3d09044a1d1f" translate="yes" xml:space="preserve">
          <source>exception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt;</source>
          <target state="translated">exception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="70e23345fd17464f3946c94c84e3a27f3d6f3324" translate="yes" xml:space="preserve">
          <source>exception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f940a5e2a0f28f13e77c8c0235ca963b9da6f81" translate="yes" xml:space="preserve">
          <source>execute permission X_OK cannot be tested, it just tests for read permission instead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eea892eb403b39624a315f2ae9716d10340d45a" translate="yes" xml:space="preserve">
          <source>executes &lt;a href=&quot;stdlib#VALexit&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2233dde714bc31bfef2d11ab471a8613d760dcd" translate="yes" xml:space="preserve">
          <source>executes the C function &lt;code&gt;caml_shutdown&lt;/code&gt;. The functions are called in 'last in, first out' order: the function most recently added with &lt;code&gt;at_exit&lt;/code&gt; is called first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ac8da6660c112411ac5323ea656dc8387da47f8" translate="yes" xml:space="preserve">
          <source>executes the compiled code contained in a.out, passing it as arguments the character strings arg&lt;sub&gt;1&lt;/sub&gt; to arg&lt;sub&gt;n&lt;/sub&gt;. (See chapter &lt;a href=&quot;runtime#c%3Aruntime&quot;&gt;11&lt;/a&gt; for more details.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd1860204d6cee43392972817e66792ee702b89" translate="yes" xml:space="preserve">
          <source>expr</source>
          <target state="translated">expr</target>
        </trans-unit>
        <trans-unit id="40cd9d83462196d0446a104d1314917b241cd28a" translate="yes" xml:space="preserve">
          <source>expr&lt;sub&gt;1&lt;/sub&gt;</source>
          <target state="translated">expr&lt;sub&gt;1&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="75da4f81011bd9c9811b000d0be9a8105fc49a58" translate="yes" xml:space="preserve">
          <source>expr&lt;sub&gt;n&lt;/sub&gt;</source>
          <target state="translated">expr&lt;sub&gt;n&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="ec9814396ba26fa02dc3261046ba55a3b4bb32a6" translate="yes" xml:space="preserve">
          <source>expression</source>
          <target state="translated">expression</target>
        </trans-unit>
        <trans-unit id="ee9a5aff545773ac86403c5b3af14f29f43d0129" translate="yes" xml:space="preserve">
          <source>extended-module-name</source>
          <target state="translated">extended-module-name</target>
        </trans-unit>
        <trans-unit id="ca9b5a6728207cebac5f5a39be588ec15635879b" translate="yes" xml:space="preserve">
          <source>extended-module-path</source>
          <target state="translated">extended-module-path</target>
        </trans-unit>
        <trans-unit id="f98961015a0ac393630f4eda3749d644a716da64" translate="yes" xml:space="preserve">
          <source>extension</source>
          <target state="translated">extension</target>
        </trans-unit>
        <trans-unit id="2a57aaf39e1e3d7e8b157188c31ea9d76afdf843" translate="yes" xml:space="preserve">
          <source>external, &lt;a href=&quot;modtypes#hevea_manual.kwd156&quot;&gt;7.10&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd166&quot;&gt;7.10.2&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd184&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd194&quot;&gt;7.11.2&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72f5dd6f61fb1f9bd3186ffb0b38b27e93e3825c" translate="yes" xml:space="preserve">
          <source>external-declaration</source>
          <target state="translated">external-declaration</target>
        </trans-unit>
        <trans-unit id="6ef49b996063dfbc19c08dd60476f57839f65e86" translate="yes" xml:space="preserve">
          <source>external&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;#external-declaration&quot;&gt;external-declaration&lt;/a&gt;</source>
          <target state="translated">external&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;#external-declaration&quot;&gt;external-declaration&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95b6b9caa85c2f979fcb31c62d74121e5c5b6937" translate="yes" xml:space="preserve">
          <source>external&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt;</source>
          <target state="translated">external&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="87ead56e0f36bc7f70901dac6db8f05625d47c9d" translate="yes" xml:space="preserve">
          <source>external&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a0a19218e082a343a1b17e5333409af9d98f0f5" translate="yes" xml:space="preserve">
          <source>f</source>
          <target state="translated">f</target>
        </trans-unit>
        <trans-unit id="ea13d66a0d95450ede3525ba60b4eefa6dfd4db7" translate="yes" xml:space="preserve">
          <source>f has arity 1, but g has arity 2. This allows a primitive to return a functional value (as in the f example above): just remember to name the functional return type in a type abbreviation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8345c0c004d7bcb51022387c853c3313838f4d4b" translate="yes" xml:space="preserve">
          <source>f:</source>
          <target state="translated">f:</target>
        </trans-unit>
        <trans-unit id="5101c030405d6eb4625b82ddb234a24b78cc7fd8" translate="yes" xml:space="preserve">
          <source>fail if Open_creat and the file already exists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cb6efb98ba5972a9b5090dc2e517fe14d12cb04" translate="yes" xml:space="preserve">
          <source>false</source>
          <target state="translated">false</target>
        </trans-unit>
        <trans-unit id="dec9612177c91c75a84643a56634d8c023453c45" translate="yes" xml:space="preserve">
          <source>false, &lt;a href=&quot;const#hevea_manual.kwd11&quot;&gt;7.5&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c99f0449b3ef1911061f6af48400d4f04a19034" translate="yes" xml:space="preserve">
          <source>fchmod</source>
          <target state="translated">fchmod</target>
        </trans-unit>
        <trans-unit id="2da0b68df8841752bb747a76780679bcd87c6215" translate="yes" xml:space="preserve">
          <source>field</source>
          <target state="translated">field</target>
        </trans-unit>
        <trans-unit id="501eee544c59dbac7271620c3b08ebf55c9d1e77" translate="yes" xml:space="preserve">
          <source>field &lt;code&gt;out_newline&lt;/code&gt; is equivalent to &lt;code&gt;out_string&amp;nbsp;&quot;\n&quot;&amp;nbsp;0&amp;nbsp;1&lt;/code&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f224b13da528327f36a0121f5d0030835cd2c673" translate="yes" xml:space="preserve">
          <source>field-decl</source>
          <target state="translated">field-decl</target>
        </trans-unit>
        <trans-unit id="ef34b6d49ac1b32c1828d0bcc806827363330301" translate="yes" xml:space="preserve">
          <source>field-name</source>
          <target state="translated">field-name</target>
        </trans-unit>
        <trans-unit id="0532f2b99db3b8d747dcdff72f0a33002abcd374" translate="yes" xml:space="preserve">
          <source>fields &lt;code&gt;out_spaces&lt;/code&gt; and &lt;code&gt;out_indent&lt;/code&gt; are equivalent to &lt;code&gt;out_string&amp;nbsp;(String.make&amp;nbsp;n&amp;nbsp;'&amp;nbsp;')&amp;nbsp;0&amp;nbsp;n&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5693614f3e4fce5f121c7d2adbc136f1eb188a69" translate="yes" xml:space="preserve">
          <source>fields &lt;code&gt;out_string&lt;/code&gt; and &lt;code&gt;out_flush&lt;/code&gt; are output device specific; (e.g. &lt;a href=&quot;stdlib#VALoutput_string&quot;&gt;&lt;code&gt;output_string&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdlib#VALflush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;stdlib#TYPEout_channel&quot;&gt;&lt;code&gt;out_channel&lt;/code&gt;&lt;/a&gt; device, or &lt;code&gt;Buffer.add_substring&lt;/code&gt; and &lt;a href=&quot;stdlib#VALignore&quot;&gt;&lt;code&gt;ignore&lt;/code&gt;&lt;/a&gt; for a &lt;code&gt;Buffer.t&lt;/code&gt; output device),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40c623613cc9bdaaab8b62fd9a9afb5e42754862" translate="yes" xml:space="preserve">
          <source>filename: no such file or directory</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cce4a92f41fe3d55a72c27b922c093bdd0a4267" translate="yes" xml:space="preserve">
          <source>finish</source>
          <target state="translated">finish</target>
        </trans-unit>
        <trans-unit id="685e80366130387cb75c055248326976d16fdf8d" translate="yes" xml:space="preserve">
          <source>float</source>
          <target state="translated">float</target>
        </trans-unit>
        <trans-unit id="152c24c58170f9f64b90bef69fb4df49a1344c48" translate="yes" xml:space="preserve">
          <source>float-literal</source>
          <target state="translated">float-literal</target>
        </trans-unit>
        <trans-unit id="56dd3d388832df06eeeca9911121590de20974cf" translate="yes" xml:space="preserve">
          <source>floating-attribute</source>
          <target state="translated">floating-attribute</target>
        </trans-unit>
        <trans-unit id="18978fed6c3afed1f7e9f12a99cb9fbaa75646cf" translate="yes" xml:space="preserve">
          <source>for HTML : &lt;a href=&quot;https://github.com/ocaml/ocaml/blob/4.11/ocamldoc/odoc_html.ml&quot;&gt;odoc_html.ml&lt;/a&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d106b43161cd02fd67405ae6ea93f44eec0d64c" translate="yes" xml:space="preserve">
          <source>for HTML : Odoc_html.Html_generator (class html),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5ec24787e3e07187530822bbc9bbcb6f4080e61" translate="yes" xml:space="preserve">
          <source>for L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X : &lt;a href=&quot;https://github.com/ocaml/ocaml/blob/4.11/ocamldoc/odoc_latex.ml&quot;&gt;odoc_latex.ml&lt;/a&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="455dcbf553a3168bdbb6ede4dacf5924d575aa75" translate="yes" xml:space="preserve">
          <source>for L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X : Odoc_latex.Latex_generator (class latex),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ef59934b5a2ed93691a76d31e92b245a003718f" translate="yes" xml:space="preserve">
          <source>for TeXinfo : &lt;a href=&quot;https://github.com/ocaml/ocaml/blob/4.11/ocamldoc/odoc_texi.ml&quot;&gt;odoc_texi.ml&lt;/a&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13d546518fdef082969985cb4a5d48964086187b" translate="yes" xml:space="preserve">
          <source>for TeXinfo : Odoc_texi.Texi_generator (class texi),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1086589c1e78e6e44f8a60b8a4e701ed49b09056" translate="yes" xml:space="preserve">
          <source>for graphviz (dot) : &lt;a href=&quot;https://github.com/ocaml/ocaml/blob/4.11/ocamldoc/odoc_dot.ml&quot;&gt;odoc_dot.ml&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b32c5544cf8a3bfcffa5e636e9eb153ea191e2" translate="yes" xml:space="preserve">
          <source>for graphviz (dot) : Odoc_dot.Dot_generator (class dot),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a488e61ff6307d3aef44c40487ae194a336a6d10" translate="yes" xml:space="preserve">
          <source>for man pages : &lt;a href=&quot;https://github.com/ocaml/ocaml/blob/4.11/ocamldoc/odoc_man.ml&quot;&gt;odoc_man.ml&lt;/a&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9ef4d6ca06969b8a3fa544528c52c6647d2520" translate="yes" xml:space="preserve">
          <source>for man pages : Odoc_man.Man_generator (class man),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ecd5c5082f846d0c3ea7bfaaee77f196e9ebc5e" translate="yes" xml:space="preserve">
          <source>for other kinds : Odoc_gen.Base (class generator).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192f048bf417e6a6d6f514420d0bd3eee9c0a580" translate="yes" xml:space="preserve">
          <source>for, &lt;a href=&quot;expr#hevea_manual.kwd32&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd68&quot;&gt;7.7.3&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd727fdabede5ec0c811e0017d5a3f4219885c72" translate="yes" xml:space="preserve">
          <source>for&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; ( to ∣ downto ) &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;do&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;done</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e69b30d6b1c590a88aa5c625c56998bf14254a4" translate="yes" xml:space="preserve">
          <source>force a new line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f673f2a8e0aacb6d0fa4504233f4f284e4a1b4c" translate="yes" xml:space="preserve">
          <source>fork</source>
          <target state="translated">fork</target>
        </trans-unit>
        <trans-unit id="bcc569a02cf33e8b74924ed5a4e4e1da66dbe5e7" translate="yes" xml:space="preserve">
          <source>format &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt; as a section header; the integer following { indicates the sectioning level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="672f98e8704dee74fb33a9148bab315ac642331d" translate="yes" xml:space="preserve">
          <source>formatted input channel</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d88b573c35d2ff144e946255bd2194366a771f" translate="yes" xml:space="preserve">
          <source>frame</source>
          <target state="translated">frame</target>
        </trans-unit>
        <trans-unit id="3fc0a723c391767190bc47a90f7e16854954d80b" translate="yes" xml:space="preserve">
          <source>frameframe-number</source>
          <target state="translated">frameframe-number</target>
        </trans-unit>
        <trans-unit id="85023e071af1165c925db5758ebc1e1b71dad0ac" translate="yes" xml:space="preserve">
          <source>fun [&lt;a href=&quot;lex#label&quot;&gt;label&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;] &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt; &amp;hellip; fun [&lt;a href=&quot;lex#label&quot;&gt;label&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebcc2e338fd6f883611a4c1124a3332b19505bbd" translate="yes" xml:space="preserve">
          <source>fun { &lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt; }&lt;sup&gt;+&lt;/sup&gt; [ :&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; ] -&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a3a30cbc449e60d5eea6ce58e52209e32d4dd2" translate="yes" xml:space="preserve">
          <source>fun {&lt;a href=&quot;expr#parameter&quot;&gt;parameter&lt;/a&gt;}&lt;sup&gt;+&lt;/sup&gt;-&amp;gt;&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cf7851db220b0ea5a996eba1089d7505fdbefd5" translate="yes" xml:space="preserve">
          <source>fun, &lt;a href=&quot;expr#hevea_manual.kwd26&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd46&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd61&quot;&gt;7.7.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd120&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;locallyabstract#hevea_manual.kwd211&quot;&gt;8.4&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65b9b437a514a3e5ea1ea5491d21b80bdbae4bad" translate="yes" xml:space="preserve">
          <source>fun&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; (&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9269c0d955dc0d421de5199eac99141b1a96687" translate="yes" xml:space="preserve">
          <source>fun&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0239578aea3e4d87835c83b4662dc338046b96ad" translate="yes" xml:space="preserve">
          <source>fun&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd0c99260cc10a58b6dc0630ee3174d14d0aa1d9" translate="yes" xml:space="preserve">
          <source>fun&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt; &amp;hellip; fun&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;-&amp;gt; (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; )</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="840d7d5ed51ee8834a3ec7619f2285969a89a001" translate="yes" xml:space="preserve">
          <source>fun&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt; &amp;hellip; fun&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4733b6d32d7233706102a87ab6db3fc6a85167c9" translate="yes" xml:space="preserve">
          <source>fun&lt;a href=&quot;expr#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;expr#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8114885059afc292abf363c94d278f6d64ac92aa" translate="yes" xml:space="preserve">
          <source>fun&lt;a href=&quot;expr#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt; &amp;hellip; fun&lt;a href=&quot;expr#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9314ac9c1204837ab3797003476b3ca7266314" translate="yes" xml:space="preserve">
          <source>fun?&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt;:&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;-&amp;gt;let&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;=match&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;withSome&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;-&amp;gt;&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;|None-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">fun?&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt;:&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;-&amp;gt;let&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;=match&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;withSome&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;-&amp;gt;&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;|None-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c218e39efa2e1aae69f39d2054528369ce1e1f46" translate="yes" xml:space="preserve">
          <source>function</source>
          <target state="translated">function</target>
        </trans-unit>
        <trans-unit id="8659e2b8073fc29425b0677a5b6c19e2e76348c8" translate="yes" xml:space="preserve">
          <source>function application, constructor application, tag application, assert, lazy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36c4cd5b5726bc3667eac8f4ac101fe25a1ae130" translate="yes" xml:space="preserve">
          <source>function calls : a count point is set at the beginning of each function body</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7a895abdf5399146a6baaa6269ab56bdbbb4a8" translate="yes" xml:space="preserve">
          <source>function, &lt;a href=&quot;expr#hevea_manual.kwd25&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd47&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd60&quot;&gt;7.7.2&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbcef6bcb3d11e46effa16ee8ef49f89e47ce86e" translate="yes" xml:space="preserve">
          <source>function&lt;a href=&quot;#pattern-matching&quot;&gt;pattern-matching&lt;/a&gt;</source>
          <target state="translated">function&lt;a href=&quot;#pattern-matching&quot;&gt;pattern-matching&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3006f44001837a909b4840c5a7879a322570c712" translate="yes" xml:space="preserve">
          <source>function&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt; &amp;hellip; function&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5010927b2d6f54abfba53f9c6a4ff170122c1126" translate="yes" xml:space="preserve">
          <source>functions for raising exceptions (see section &lt;a href=&quot;#ss%3Ac-exceptions&quot;&gt;20.4.5&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a849b6b86a86f4a93285c056a690e4c3987619b8" translate="yes" xml:space="preserve">
          <source>functor()-&amp;gt;&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;</source>
          <target state="translated">functor()-&amp;gt;&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2844c175a443bbc8f0547152ba8237ba4ecece4e" translate="yes" xml:space="preserve">
          <source>functor()-&amp;gt;&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;</source>
          <target state="translated">functor()-&amp;gt;&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e03f2859207c0e9433b4a2ecae4605a9e1b95b9" translate="yes" xml:space="preserve">
          <source>functor(&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;</source>
          <target state="translated">functor(&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a07f902d52bb9068d86a6477af50805473264aa" translate="yes" xml:space="preserve">
          <source>functor(&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;</source>
          <target state="translated">functor(&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="68ab0059d66e906941e8678e513dd3f767afc42e" translate="yes" xml:space="preserve">
          <source>functor, &lt;a href=&quot;modtypes#hevea_manual.kwd152&quot;&gt;7.10&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd177&quot;&gt;7.10.3&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd181&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd205&quot;&gt;7.11.3&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="034836e093abd26b76f58a37505acd3b47fde33b" translate="yes" xml:space="preserve">
          <source>generates compiled files P.cmx, P.o and P.cmi describing a compilation unit having three sub-modules A, B and C, corresponding to the contents of the object files A.cmx, B.cmx and C.cmx. These contents can be referenced as P.A, P.B and P.C in the remainder of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2d52daff09686e1418f2d39aa82517fedd484e4" translate="yes" xml:space="preserve">
          <source>generates compiled files p.cmo and p.cmi describing a compilation unit having three sub-modules A, B and C, corresponding to the contents of the object files a.cmo, b.cmo and c.cmo. These contents can be referenced as P.A, P.B and P.C in the remainder of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1bf2f768c998ce78f3881b1180914edc1e4be20" translate="yes" xml:space="preserve">
          <source>generation of documentation, through a documentation generator, which is an object of class Odoc_args.class_generator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="772355cea5ae74c202b3d91b1248e88961bb5c5f" translate="yes" xml:space="preserve">
          <source>getgrnam, getgrgid</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e32675c123cd727f0309c3cb6c71464bb9f334c" translate="yes" xml:space="preserve">
          <source>getgroups</source>
          <target state="translated">getgroups</target>
        </trans-unit>
        <trans-unit id="e55f588522f530bcde02486503fd5ed646e768ba" translate="yes" xml:space="preserve">
          <source>getitimer, setitimer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="760896bcddb7ce1b15ca782f91ef889393abaa62" translate="yes" xml:space="preserve">
          <source>getppid</source>
          <target state="translated">getppid</target>
        </trans-unit>
        <trans-unit id="334ebc7bbe07b5c7bb6cdde510912ea2d8e86671" translate="yes" xml:space="preserve">
          <source>getpwnam, getpwuid</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d83a311450d17a3faaf0c6a09453bd5d7c4351cd" translate="yes" xml:space="preserve">
          <source>getuid, geteuid, getgid, getegid</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4731a0517aaa711cf010c5a678f6ef36ae7459" translate="yes" xml:space="preserve">
          <source>goto 0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2279f19b3d2652baf02cc127be0db400bd45a5cd" translate="yes" xml:space="preserve">
          <source>goto time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27d5482eebd075de44389774fce28c69f45c8a75" translate="yes" xml:space="preserve">
          <source>h</source>
          <target state="translated">h</target>
        </trans-unit>
        <trans-unit id="07db9dbabeac878d804109af5f1e65ed057d71af" translate="yes" xml:space="preserve">
          <source>h::t</source>
          <target state="translated">h::t</target>
        </trans-unit>
        <trans-unit id="b0adddb4abfab0acb067c3a02f47aa9f4c79e9ec" translate="yes" xml:space="preserve">
          <source>has arity 1, and the input2 C function receives one argument (which is a quadruple of OCaml values).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0e61164ea46b16117879c920d874090355b1361" translate="yes" xml:space="preserve">
          <source>has type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74a776c7d9b6a35b3352f96d1f8480eb2c595160" translate="yes" xml:space="preserve">
          <source>hashing (module &lt;code&gt;Hash&lt;/code&gt;);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92005ecf3788faea8346a7919fba0232188561ab" translate="yes" xml:space="preserve">
          <source>help</source>
          <target state="translated">help</target>
        </trans-unit>
        <trans-unit id="e4c1caea51cdee6abdfd423fa8b032afd9287b64" translate="yes" xml:space="preserve">
          <source>help command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7474a41cb68769c8ffe8911c26576fcd5fc9a56" translate="yes" xml:space="preserve">
          <source>help info topic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b47fa7a5cd01887bd5c7edbb8d4489b33b798d72" translate="yes" xml:space="preserve">
          <source>help set variable, help show variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b369c7d8443ed75e8ee8664670a6b742e802dc9" translate="yes" xml:space="preserve">
          <source>hexadecimal (radix 16)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1216290c328643cb59675cb9c9de402377586669" translate="yes" xml:space="preserve">
          <source>horizontal tabulation (TAB)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042dc4512fa3d391c5170cf3aa61e6a638f84342" translate="yes" xml:space="preserve">
          <source>i</source>
          <target state="translated">i</target>
        </trans-unit>
        <trans-unit id="99600d7006d6b0a21d7833d055370ceeed1f8dad" translate="yes" xml:space="preserve">
          <source>i-th dimension</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0efee61c10bc322d0b636ba3dd5c3a2656badd1f" translate="yes" xml:space="preserve">
          <source>ident</source>
          <target state="translated">ident</target>
        </trans-unit>
        <trans-unit id="958f57f57d72a30f329ee5538f21b0257a49a46e" translate="yes" xml:space="preserve">
          <source>if</source>
          <target state="translated">if</target>
        </trans-unit>
        <trans-unit id="62043fa493a7596b85a66a9829c21feeca0c4fdd" translate="yes" xml:space="preserve">
          <source>if &amp;hellip;then &amp;hellip;else &amp;hellip; : count points are set in both then branch and else branch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e87305e9cd23ad8be0325131e843361ec7f085" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;cmp&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; &amp;gt;= 0 and &lt;code&gt;cmp&amp;nbsp;y&amp;nbsp;z&lt;/code&gt; &amp;gt;= 0 then &lt;code&gt;cmp&amp;nbsp;x&amp;nbsp;z&lt;/code&gt; &amp;gt;= 0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a1e6217624587a482735c03d4f13ef4800b403" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;f&amp;nbsp;k&amp;nbsp;v&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; then &lt;code&gt;k&lt;/code&gt; is not in the result,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7962703df78171c0f6d9ead79f64d4c7e8be50" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;f&amp;nbsp;k&amp;nbsp;v&lt;/code&gt; is &lt;code&gt;Some&amp;nbsp;v'&lt;/code&gt; then the binding &lt;code&gt;(k,&amp;nbsp;v')&lt;/code&gt; is in the output map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7691fd964f62c6c29778c4b5bb61b07497e4d81" translate="yes" xml:space="preserve">
          <source>if we define the receiver &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;let&amp;nbsp;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;x&amp;nbsp;+&amp;nbsp;1&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d331b7cd9454df4e8c8b3e1d683f06da8756571" translate="yes" xml:space="preserve">
          <source>if we use &lt;code&gt;stdin&lt;/code&gt; as the source of characters (&lt;a href=&quot;scanf.scanning#VALstdin&quot;&gt;&lt;code&gt;Scanf.Scanning.stdin&lt;/code&gt;&lt;/a&gt; is the predefined formatted input channel that reads from standard input),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f55fb127a497d1332b99a942053ffd4ac476c7f2" translate="yes" xml:space="preserve">
          <source>if your function is a primitive with more than 5 arguments for use with the byte-code runtime, its arguments are not values and must not be declared (they have types value * and int).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="296e7f1f31d4668a2b2bb325f806d14637720d38" translate="yes" xml:space="preserve">
          <source>if, &lt;a href=&quot;expr#hevea_manual.kwd35&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd45&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd64&quot;&gt;7.7.3&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="171d50ad38cb8f575e802fca0b686221a4433fb9" translate="yes" xml:space="preserve">
          <source>if&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;then&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;elsefalse.</source>
          <target state="translated">if&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;then&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;elsefalse.</target>
        </trans-unit>
        <trans-unit id="5e235627b05b242764981acad185ad5869323de1" translate="yes" xml:space="preserve">
          <source>if&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;thentrueelse&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="translated">if&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;thentrueelse&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</target>
        </trans-unit>
        <trans-unit id="d2251fa912bc54f4d77afad5862d8faf8fa2e9e7" translate="yes" xml:space="preserve">
          <source>if&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;then&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; [ else&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc04e85d3eaff1e4754370552b234e7099970281" translate="yes" xml:space="preserve">
          <source>immutable character strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cde41be3ab9cf0b6ab971fbd9b886d94b0b4b958" translate="yes" xml:space="preserve">
          <source>implemented (since 3.02)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3030d0f8c1da9ff83ec620251f17a22db9a8f430" translate="yes" xml:space="preserve">
          <source>implemented (since 4.03.0)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c40c8c34a8bcd9afa7703ca4c2956eaa74a4dfa5" translate="yes" xml:space="preserve">
          <source>in a let expression, one may instead write</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1be4be48925b21377455741cb700dde1c9a583d9" translate="yes" xml:space="preserve">
          <source>in addition to the relevant digits, &lt;code&gt;'_'&lt;/code&gt; characters may appear inside numbers (this is reminiscent to the usual OCaml lexical conventions). If stricter scanning is desired, use the range conversion facility instead of the number conversions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36883d27fefa117c39f72ce3daaa5fc2f419b53b" translate="yes" xml:space="preserve">
          <source>in, see let</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcdd45c309dcba1d9d4b79f586b3a50297b8ee1c" translate="yes" xml:space="preserve">
          <source>include, &lt;a href=&quot;modtypes#hevea_manual.kwd162&quot;&gt;7.10&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd176&quot;&gt;7.10.2&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd190&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd204&quot;&gt;7.11.2&lt;/a&gt;, &lt;a href=&quot;moduletypeof#hevea_manual.kwd219&quot;&gt;8.6&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d5dde4ba62bff53b44acb3b42aff51ef7c5d8e" translate="yes" xml:space="preserve">
          <source>include&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;</source>
          <target state="translated">include&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f5c5afca60ad64d401873a558c35fd6bff585f7" translate="yes" xml:space="preserve">
          <source>include&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;</source>
          <target state="translated">include&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8e3b5bde77f3da26ea678f77a329bb416842c919" translate="yes" xml:space="preserve">
          <source>include&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f68cbdcde9321debc33dec929526538b84347f10" translate="yes" xml:space="preserve">
          <source>include&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="775ff372a1335c3b0c06bc8b0c85a6b6498ebe97" translate="yes" xml:space="preserve">
          <source>indicates positions relative to the beginning of the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27f2d3b01cfed33f2bec50a5a60c1cdac631f09" translate="yes" xml:space="preserve">
          <source>indicates positions relative to the current position</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efefe62ae6f51dcd0084f0f6719b3ae855eee713" translate="yes" xml:space="preserve">
          <source>indicates positions relative to the end of the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba84477b5b149f0c5490450bb80212dfa7bd5fd6" translate="yes" xml:space="preserve">
          <source>infix-op</source>
          <target state="translated">infix-op</target>
        </trans-unit>
        <trans-unit id="58d4778f3bf63e407d21101262292af7d3db6d3f" translate="yes" xml:space="preserve">
          <source>infix-symbol</source>
          <target state="translated">infix-symbol</target>
        </trans-unit>
        <trans-unit id="a01cf621a5b126ce5a4f57cd0d75a3b74e2b9743" translate="yes" xml:space="preserve">
          <source>info breakpoints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb662cc5b49179ba761a0ea47d1981ef3cfdc12e" translate="yes" xml:space="preserve">
          <source>info checkpoints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1bd61066b3bdb2c60ecfab85e68f0363c0d3272" translate="yes" xml:space="preserve">
          <source>info events [module]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8baf2d9793c89398da706061b12c589ae0a3f294" translate="yes" xml:space="preserve">
          <source>info subject</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d6a7dde203dfd472b7a4e7f5e5a584e6339416" translate="yes" xml:space="preserve">
          <source>inherit!&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; [as&lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c13e5a8b4fe5a08b064bc16d80a3977d513efdba" translate="yes" xml:space="preserve">
          <source>inherit, &lt;a href=&quot;classes#hevea_manual.kwd103&quot;&gt;7.9.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd110&quot;&gt;7.9.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd123&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd131&quot;&gt;7.9.2&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35815a10f1288205de110bb61161fa1264dbb6b2" translate="yes" xml:space="preserve">
          <source>inherit&lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt;</source>
          <target state="translated">inherit&lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d48c1446f94ecec3497c6872375f55ad7ec6ca55" translate="yes" xml:space="preserve">
          <source>inherit&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; [as&lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt;]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="036d153e88ab680b671bdbedf7e1444f04c908b1" translate="yes" xml:space="preserve">
          <source>init:</source>
          <target state="translated">init:</target>
        </trans-unit>
        <trans-unit id="e86dc2769b8ae8fee363c2cb582840598378992e" translate="yes" xml:space="preserve">
          <source>initializer, &lt;a href=&quot;classes#hevea_manual.kwd130&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd142&quot;&gt;7.9.2&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaaa3b243e4649228bff320dc5c3acc9fdfa09ba" translate="yes" xml:space="preserve">
          <source>initializer&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">initializer&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cf798a52d2dc37e7dfb868809e58d253376af19a" translate="yes" xml:space="preserve">
          <source>insert a cross-reference to an element (see section &lt;a href=&quot;#sss%3Aocamldoc-crossref&quot;&gt;16.2.4.2&lt;/a&gt; for the syntax of cross-references).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e5ec8da0746562b7551764d2784b5dbed8e42b2" translate="yes" xml:space="preserve">
          <source>insert a table of links to the various indexes (types, values, modules, ...). Used in HTML only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eab95a58d831871b14532f1578fb7bcc8746581" translate="yes" xml:space="preserve">
          <source>insert an index table for the given module names. Used in HTML only.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48d3dc40acbee4c1cf049070f6e8e150169f78c5" translate="yes" xml:space="preserve">
          <source>inside a recursive module definition, M&lt;sub&gt;0&lt;/sub&gt; should not be one of the recursively defined modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8334416331188dc0834e0db7b1963e39705cb291" translate="yes" xml:space="preserve">
          <source>inside the body of a functor, M&lt;sub&gt;0&lt;/sub&gt; should not be one of the functor parameters;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="016beb33a553ebe6cbafd2cf0d337d5272037130" translate="yes" xml:space="preserve">
          <source>inst-var-name</source>
          <target state="translated">inst-var-name</target>
        </trans-unit>
        <trans-unit id="87473fe55615f431e83a208ff1e59784e06d318b" translate="yes" xml:space="preserve">
          <source>install_printer printer-name</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6fb9f5c27ade72d14f775d79238f3d3209715b8" translate="yes" xml:space="preserve">
          <source>instance variable names (&lt;a href=&quot;#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb82821f5443620916128c66c024a61d87b0565d" translate="yes" xml:space="preserve">
          <source>instead of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46f8ab7c0cff9df7cd124852e26022a6bf89e315" translate="yes" xml:space="preserve">
          <source>int</source>
          <target state="translated">int</target>
        </trans-unit>
        <trans-unit id="0ea590de0e2e1b0df5fabb92365ebfab2f515ee8" translate="yes" xml:space="preserve">
          <source>int (*compare)(value v1, value v2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68d3df1568019e0870189f8da1f503280238e07e" translate="yes" xml:space="preserve">
          <source>int (*compare_ext)(value v1, value v2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="320385ec0fbe6caa8b0b25269b069277f1d38959" translate="yes" xml:space="preserve">
          <source>int-literal</source>
          <target state="translated">int-literal</target>
        </trans-unit>
        <trans-unit id="d71739707a7eafbe926fe99f6312cc8634db005d" translate="yes" xml:space="preserve">
          <source>int32</source>
          <target state="translated">int32</target>
        </trans-unit>
        <trans-unit id="2d64d759ca34d47626889c287e575a64014e2611" translate="yes" xml:space="preserve">
          <source>int32-literal</source>
          <target state="translated">int32-literal</target>
        </trans-unit>
        <trans-unit id="8fcdcefeb8f1bbab3f3ff2567ecad9be78779217" translate="yes" xml:space="preserve">
          <source>int32_t</source>
          <target state="translated">int32_t</target>
        </trans-unit>
        <trans-unit id="3cf12f96228a3fa41a25040bdcc6eac3659e7844" translate="yes" xml:space="preserve">
          <source>int64</source>
          <target state="translated">int64</target>
        </trans-unit>
        <trans-unit id="a923917a4e8eff6007e98cf48d9156e9201a6b1b" translate="yes" xml:space="preserve">
          <source>int64-literal</source>
          <target state="translated">int64-literal</target>
        </trans-unit>
        <trans-unit id="f6311168933725d3149f768d180f96c9c216469f" translate="yes" xml:space="preserve">
          <source>int64_t</source>
          <target state="translated">int64_t</target>
        </trans-unit>
        <trans-unit id="01d0f81732577c9d24286ec4b5fb58d07e8ba766" translate="yes" xml:space="preserve">
          <source>integer-literal</source>
          <target state="translated">integer-literal</target>
        </trans-unit>
        <trans-unit id="e3e8ca21b3622c7ea8e9a869ffaa9cd96adcf19a" translate="yes" xml:space="preserve">
          <source>intnat</source>
          <target state="translated">intnat</target>
        </trans-unit>
        <trans-unit id="02122843af179f141e2c4a6904e5c9acf2767015" translate="yes" xml:space="preserve">
          <source>intnat (*hash)(value v)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee0a5c5c4c9be20b6830a469d62cd720e8cfc4a" translate="yes" xml:space="preserve">
          <source>is OK, but:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b574aa1f43197443eefcba8124d2dbfad978f23" translate="yes" xml:space="preserve">
          <source>is a short form for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9282601755d874f407044836ef141f061913a4b7" translate="yes" xml:space="preserve">
          <source>is a supertype of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2184c194395f85161b07451378b5380bd671a30" translate="yes" xml:space="preserve">
          <source>is automatically expanded into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6084689797742b0df510436433eaf2024a8e9db" translate="yes" xml:space="preserve">
          <source>is displayed as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b38e4c6cec12428e5871d2d1ce176a532d59c8d8" translate="yes" xml:space="preserve">
          <source>is easy to remember,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ec285792f84b2006557cfe7a76ef03e4dffbd46" translate="yes" xml:space="preserve">
          <source>is equivalent to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540dd9c65d0f35bb6866948231ccf0ff06d8f61f" translate="yes" xml:space="preserve">
          <source>is equivalent to defining it as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d88f97f2587677395d348b83f07d9407ee2ea83c" translate="yes" xml:space="preserve">
          <source>is not because x cannot be given any type other than t, which only exists locally. Although the above would be OK if x too was local:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c40660ad1062790f8a4059a197e03035fd5b1b62" translate="yes" xml:space="preserve">
          <source>is now broken and may suffer from uncaught exceptions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b08ccf539cb48fc49109709c82df2f55d74672" translate="yes" xml:space="preserve">
          <source>is the set of halves of the even elements of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ecc5e62f71fc1008ed4659593b5f4900693d3b6" translate="yes" xml:space="preserve">
          <source>it can also handle values of type x:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2d89f7a06da14551b799622c9fa3b84961b60c5" translate="yes" xml:space="preserve">
          <source>it is a root value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c49bc6901670ed54a5b0fcf425e311786a688356" translate="yes" xml:space="preserve">
          <source>it is reachable from alive value by usual pointers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c7a4ba74bb307d677a2b4269826d5907405a002" translate="yes" xml:space="preserve">
          <source>it is the data of an alive ephemeron with all its full keys alive</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d41b1d151ee2007d39bf9d3c182989341851535" translate="yes" xml:space="preserve">
          <source>it should be of the form M&lt;sub&gt;0&lt;/sub&gt;.M&lt;sub&gt;1&lt;/sub&gt;...M&lt;sub&gt;n&lt;/sub&gt; (&lt;em&gt;i.e.&lt;/em&gt; without functor applications);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0ae9bb4b5a17414771d9e01942cf521816e0f1e" translate="yes" xml:space="preserve">
          <source>it would be observed that inlining of f would remove:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cca7dd474781a6c615acad892d75948bf8064f9c" translate="yes" xml:space="preserve">
          <source>item-attribute</source>
          <target state="translated">item-attribute</target>
        </trans-unit>
        <trans-unit id="e7b0f2a22247c128455d40504270be579f19f9d2" translate="yes" xml:space="preserve">
          <source>item-extension</source>
          <target state="translated">item-extension</target>
        </trans-unit>
        <trans-unit id="c80f5bc166cd6739ba9ba6d94acabc0aa01494da" translate="yes" xml:space="preserve">
          <source>kill</source>
          <target state="translated">kill</target>
        </trans-unit>
        <trans-unit id="44e83b02b2e3da220aaeff4d32148c7927f0e049" translate="yes" xml:space="preserve">
          <source>kind of array elements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07c342be6e560e7f43842e2e21b774e61d85f047" translate="yes" xml:space="preserve">
          <source>l</source>
          <target state="translated">l</target>
        </trans-unit>
        <trans-unit id="64c65374dbab6fe3762748196d9d3a9610e2e5a9" translate="yes" xml:space="preserve">
          <source>label</source>
          <target state="translated">label</target>
        </trans-unit>
        <trans-unit id="ee222cf94d64e861d2744d3254da532946d05acb" translate="yes" xml:space="preserve">
          <source>label-name</source>
          <target state="translated">label-name</target>
        </trans-unit>
        <trans-unit id="8912d04d878e1b8ffa02572c532d88496f969d38" translate="yes" xml:space="preserve">
          <source>labels (&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;, defined in section &lt;a href=&quot;lex#sss%3Alabelname&quot;&gt;7.1&lt;/a&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d3b60b2c381f8873f294894ef8428319a3b8546" translate="yes" xml:space="preserve">
          <source>land</source>
          <target state="translated">land</target>
        </trans-unit>
        <trans-unit id="28f670b865f6fca2de3f470253d67b5c4465f5a3" translate="yes" xml:space="preserve">
          <source>land, &lt;a href=&quot;names#hevea_manual.kwd1&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd52&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd71&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd78&quot;&gt;7.7.5&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1320419400c075abf070279ee1a9106491c3e9c" translate="yes" xml:space="preserve">
          <source>last [count]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07017c0924f3c0e74472c74b841e4df5732e971d" translate="yes" xml:space="preserve">
          <source>lazy (see section &lt;a href=&quot;#sss%3Apat-lazy&quot;&gt;7.6&lt;/a&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a89127a029d917cfd54f0e731cd8a9aa6b71457d" translate="yes" xml:space="preserve">
          <source>lazy, &lt;a href=&quot;patterns#hevea_manual.kwd18&quot;&gt;7.6&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd43&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd87&quot;&gt;7.7.8&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55928783428cdda332c1be8b1d7555ae280204b2" translate="yes" xml:space="preserve">
          <source>lazy&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">lazy&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f1ee4c791de79ce5ffb892161d36b89f33683dec" translate="yes" xml:space="preserve">
          <source>lazy&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;</source>
          <target state="translated">lazy&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12c0f1fbadc4046b5f2bb9e063b227ef8750d9d6" translate="yes" xml:space="preserve">
          <source>left</source>
          <target state="translated">left</target>
        </trans-unit>
        <trans-unit id="07785b23ac256aee37df3d7fcfaf27d25e175350" translate="yes" xml:space="preserve">
          <source>left align &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c8c7ff93d6fe3f68a4d62ed2606920684027919" translate="yes" xml:space="preserve">
          <source>legacy mode: All path names, environment variables, command line arguments, etc. on the OCaml side are assumed to be encoded using the current 8-bit code page of the system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc0db465e09e54ce3393bf47c61f2ee7c97c2b5e" translate="yes" xml:space="preserve">
          <source>len:</source>
          <target state="translated">len:</target>
        </trans-unit>
        <trans-unit id="9e98136581c24c2d792e14300fde374673aac562" translate="yes" xml:space="preserve">
          <source>let (&lt;a href=&quot;lex#core-operator-char&quot;&gt;core-operator-char&lt;/a&gt; ∣ &amp;lt;) { &lt;a href=&quot;indexops#dot-operator-char&quot;&gt;dot-operator-char&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df58b9c3f5fe2b95daf952eae7061b425235eb7e" translate="yes" xml:space="preserve">
          <source>let [rec] &lt;a href=&quot;#let-binding&quot;&gt;let-binding&lt;/a&gt; { and&lt;a href=&quot;#let-binding&quot;&gt;let-binding&lt;/a&gt; } in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1f39fe94b7fc1579703d33495402522ef33a2e" translate="yes" xml:space="preserve">
          <source>let [rec] &lt;a href=&quot;expr#let-binding&quot;&gt;let-binding&lt;/a&gt; { and&lt;a href=&quot;expr#let-binding&quot;&gt;let-binding&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8297b94132999eefacc15aae5b2caf50958960c" translate="yes" xml:space="preserve">
          <source>let [rec] &lt;a href=&quot;expr#let-binding&quot;&gt;let-binding&lt;/a&gt; {and&lt;a href=&quot;expr#let-binding&quot;&gt;let-binding&lt;/a&gt;} in&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e86db291ae252519fd411c0cbfa4701b2d69ce0" translate="yes" xml:space="preserve">
          <source>let [rec] xname&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;and &amp;hellip; andxname&lt;sub&gt;m&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b719aded420f0b5d273d6d8702365a345f524e06" translate="yes" xml:space="preserve">
          <source>let match fun function try</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22bf11b6308b221037d374e48cd470b0a5818594" translate="yes" xml:space="preserve">
          <source>let, &lt;a href=&quot;expr#hevea_manual.kwd23&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd50&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd63&quot;&gt;7.7.2&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd88&quot;&gt;7.7.8&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd90&quot;&gt;7.7.8&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd121&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd182&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd193&quot;&gt;7.11.2&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7901b57fcded468298de5ef006d54071437eb06" translate="yes" xml:space="preserve">
          <source>let-binding</source>
          <target state="translated">let-binding</target>
        </trans-unit>
        <trans-unit id="6088f290e02a7e2e06566bc7aab735a0992cd484" translate="yes" xml:space="preserve">
          <source>let-operator</source>
          <target state="translated">let-operator</target>
        </trans-unit>
        <trans-unit id="d9007e043d228a48400a566a231975c63cd6d03b" translate="yes" xml:space="preserve">
          <source>let&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6f3793c4518968e3a11110a80f9c48b7d45b5c" translate="yes" xml:space="preserve">
          <source>let&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;=fun&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="045f0f4ea787a29a1bbe9d700d7fe0c4f428ab22" translate="yes" xml:space="preserve">
          <source>let&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.typeexpr=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1932d364e34d9a4c1df147d9280d5b6c2c34f16" translate="yes" xml:space="preserve">
          <source>let&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;and &amp;hellip; and&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42eb3728a0a95a8f7cc668516e38099d5ab80194" translate="yes" xml:space="preserve">
          <source>letexception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">letexception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56562fa39251b89546ee1424e158b35667fa9b24" translate="yes" xml:space="preserve">
          <source>letmodule &amp;hellip; in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfc36b154414e2417f92dcd686143b2dc6c21baf" translate="yes" xml:space="preserve">
          <source>letmodule&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; { (&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) } [ :&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; ] =&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70b92dbebf0b22df03683c261ba8c5b36dd336e6" translate="yes" xml:space="preserve">
          <source>letopen!&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">letopen!&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11014a97c66d7c6e7339ec3ba6da475633773c5c" translate="yes" xml:space="preserve">
          <source>letopen!&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;classes#class-body-type&quot;&gt;class-body-type&lt;/a&gt;</source>
          <target state="translated">letopen!&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;classes#class-body-type&quot;&gt;class-body-type&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b876ef201f4cf012020480cd1dfab1222f592001" translate="yes" xml:space="preserve">
          <source>letopen!&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;classes#class-expr&quot;&gt;class-expr&lt;/a&gt;</source>
          <target state="translated">letopen!&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;classes#class-expr&quot;&gt;class-expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92c929125a772fac69ddc25d63f7f08e4ec4f241" translate="yes" xml:space="preserve">
          <source>letopen!&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">letopen!&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="641e0ba875b175ea7e480a5c1cf6c3a34d65b084" translate="yes" xml:space="preserve">
          <source>letopen&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">letopen&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0ab7577eb770be85dacb087541fc5e1733d1f3d8" translate="yes" xml:space="preserve">
          <source>letopen&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt;</source>
          <target state="translated">letopen&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c6d98bf520d0a44be48bea2d7acc9524c23493e" translate="yes" xml:space="preserve">
          <source>letopen&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;</source>
          <target state="translated">letopen&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52af1a8150b03cb2249048aa49b9307760ec15be" translate="yes" xml:space="preserve">
          <source>letopen&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">letopen&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="310a5aa1b3381740d0c18cf6104a61696db10b40" translate="yes" xml:space="preserve">
          <source>letrec&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;and &amp;hellip; and&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4adcbb2abeb4b992c60a4bc707cf9a0d2bff2ce8" translate="yes" xml:space="preserve">
          <source>letrecname&lt;sub&gt;1&lt;/sub&gt;=1::name&lt;sub&gt;2&lt;/sub&gt;andname&lt;sub&gt;2&lt;/sub&gt;=2::name&lt;sub&gt;1&lt;/sub&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">letrecname&lt;sub&gt;1&lt;/sub&gt;=1::name&lt;sub&gt;2&lt;/sub&gt;andname&lt;sub&gt;2&lt;/sub&gt;=2::name&lt;sub&gt;1&lt;/sub&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d2c3797b2547d8c84ae51b691a195de7f5ec187" translate="yes" xml:space="preserve">
          <source>letrecname&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;and &amp;hellip; andname&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea11c1fc7e46b9818b97453eacaaf9d5b35189c7" translate="yes" xml:space="preserve">
          <source>letrecname&lt;sub&gt;1&lt;/sub&gt;=fun &amp;hellip; and &amp;hellip; andname&lt;sub&gt;n&lt;/sub&gt;=fun &amp;hellip; in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18cc852c9ac803da9cde67a9fd74b4edd9bf98a9" translate="yes" xml:space="preserve">
          <source>letter</source>
          <target state="translated">letter</target>
        </trans-unit>
        <trans-unit id="f6dd55e8290282faf186f89026340988bbeaf29b" translate="yes" xml:space="preserve">
          <source>libraries and object code files (.o files) mentioned on the command line for the OCaml linker, that provide implementations for the user&amp;rsquo;s primitives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c2b40a5fa876226908ddc3170c8d71c443dd5a0" translate="yes" xml:space="preserve">
          <source>like short, but also display the source code snippet corresponding to the location of the error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d43892f7ad1be0ef7d80e52ad4ee97884503efac" translate="yes" xml:space="preserve">
          <source>linefeed (LF)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538d5662b399dfa89388522bb51895493a521422" translate="yes" xml:space="preserve">
          <source>linenum-directive</source>
          <target state="translated">linenum-directive</target>
        </trans-unit>
        <trans-unit id="4f0aa52d656a3d75867f784b7e9c5d23bf1321c0" translate="yes" xml:space="preserve">
          <source>link</source>
          <target state="translated">link</target>
        </trans-unit>
        <trans-unit id="38b62be4bddaa5661c7d6b8e36e28159314df5c7" translate="yes" xml:space="preserve">
          <source>list</source>
          <target state="translated">list</target>
        </trans-unit>
        <trans-unit id="2126efbc35f0f38125d2dcb645d7dbb11147e4d1" translate="yes" xml:space="preserve">
          <source>list [module] [beginning] [end]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6ceaab00ab5f5571e9e76ed80536af01290222" translate="yes" xml:space="preserve">
          <source>load_printer &quot;file-name&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eef2c8c3538b5a80c5bed215aae8bd4f2193498" translate="yes" xml:space="preserve">
          <source>local-open</source>
          <target state="translated">local-open</target>
        </trans-unit>
        <trans-unit id="813bee93ab6fa289818ebeaebca612fefc3730cc" translate="yes" xml:space="preserve">
          <source>lor</source>
          <target state="translated">lor</target>
        </trans-unit>
        <trans-unit id="ddea6f9c04724c4c12a5f5ce62bbed894736fbe9" translate="yes" xml:space="preserve">
          <source>lor, &lt;a href=&quot;names#hevea_manual.kwd2&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd53&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd72&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd79&quot;&gt;7.7.5&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="171c1e65f95a4d4992c129151e673f844920649a" translate="yes" xml:space="preserve">
          <source>lowercase</source>
          <target state="translated">lowercase</target>
        </trans-unit>
        <trans-unit id="b3d7bc6dec9d4a5736f54335407387cb52cd9990" translate="yes" xml:space="preserve">
          <source>lowercase-ident</source>
          <target state="translated">lowercase-ident</target>
        </trans-unit>
        <trans-unit id="f7f2eb6bbc15d0ded786bf7b3f340e5c4e5db6a8" translate="yes" xml:space="preserve">
          <source>lowercase-letter</source>
          <target state="translated">lowercase-letter</target>
        </trans-unit>
        <trans-unit id="0c752315a1966211d0e696c3b3a70c6cab9bdcc3" translate="yes" xml:space="preserve">
          <source>lsl</source>
          <target state="translated">lsl</target>
        </trans-unit>
        <trans-unit id="4940e1d34c73989113408f4871b8a43b9211675d" translate="yes" xml:space="preserve">
          <source>lsl, &lt;a href=&quot;names#hevea_manual.kwd4&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd55&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd74&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd81&quot;&gt;7.7.5&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="291e20479a95bc25eca3f8a8ea285c5067de7d92" translate="yes" xml:space="preserve">
          <source>lsr</source>
          <target state="translated">lsr</target>
        </trans-unit>
        <trans-unit id="72f143b0c5a3e9618ed0a2276e7d0a2f9f7f8ba5" translate="yes" xml:space="preserve">
          <source>lsr, &lt;a href=&quot;names#hevea_manual.kwd5&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd56&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd75&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd82&quot;&gt;7.7.5&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18b316c879567a0ce0fc85005e0756822a16e896" translate="yes" xml:space="preserve">
          <source>lxor</source>
          <target state="translated">lxor</target>
        </trans-unit>
        <trans-unit id="6cfed45bd572474c709444aea7bce2673d33ac9a" translate="yes" xml:space="preserve">
          <source>lxor, &lt;a href=&quot;names#hevea_manual.kwd3&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd54&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd73&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd80&quot;&gt;7.7.5&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0d31c0d563223024da45691584643ac78c96e8" translate="yes" xml:space="preserve">
          <source>m</source>
          <target state="translated">m</target>
        </trans-unit>
        <trans-unit id="386a0e08ae576045599a5bc72e69d77c43a6601f" translate="yes" xml:space="preserve">
          <source>makes programs more readable,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef5c844eab88bcaca779bd2f3ad67b573bbbbfca" translate="yes" xml:space="preserve">
          <source>match</source>
          <target state="translated">match</target>
        </trans-unit>
        <trans-unit id="0b9b87661089dba83f207c00443e59cd0732c797" translate="yes" xml:space="preserve">
          <source>match branches: a count point is set at the beginning of the body of each branch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1c4e3594bfff0b597bb338d0192b0ed145c4a9" translate="yes" xml:space="preserve">
          <source>match, &lt;a href=&quot;expr#hevea_manual.kwd37&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd48&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd65&quot;&gt;7.7.3&lt;/a&gt;, &lt;a href=&quot;gadts#hevea_manual.kwd226&quot;&gt;8.10&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5a47fbf471b30182c1c596bf642e7f451eae0c1" translate="yes" xml:space="preserve">
          <source>match&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;with&lt;a href=&quot;#pattern-matching&quot;&gt;pattern-matching&lt;/a&gt;</source>
          <target state="translated">match&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;with&lt;a href=&quot;#pattern-matching&quot;&gt;pattern-matching&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ab2f7945dcc0079f3d02ec3fae0eebfa2f5b92b" translate="yes" xml:space="preserve">
          <source>matches the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; against the patterns &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. If the matching against &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; succeeds, the associated expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; is evaluated, and its value becomes the value of the whole match expression. The evaluation of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; takes place in an environment enriched by the bindings performed during matching. If several patterns match the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, the one that occurs first in the match expression is selected. If none of the patterns match the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, the exception Match_failure is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca29d521ef6f186e6e2d15f55cbe7e024ec6a84" translate="yes" xml:space="preserve">
          <source>matching-case</source>
          <target state="translated">matching-case</target>
        </trans-unit>
        <trans-unit id="7c73604104e94ed36100e6d479105b2b83f7b01f" translate="yes" xml:space="preserve">
          <source>may be duplicated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3a80232d91ddcfb50da954cfc4b07afb601a27e" translate="yes" xml:space="preserve">
          <source>merge @author</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e74efa98c09b4ca89b5a183f94ff4536cc94af" translate="yes" xml:space="preserve">
          <source>merge @before</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13b4f1a61e2feec40f97a21336727e1c3eaca7e3" translate="yes" xml:space="preserve">
          <source>merge @deprecated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="287e8cb68be7c090edf1807937932f2139847c64" translate="yes" xml:space="preserve">
          <source>merge @param</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8be922b4f91d4ddf8d1c54fdebb3bab166e17cc7" translate="yes" xml:space="preserve">
          <source>merge @raise</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c201dab801a62713c218da8e02e6c3a08882ec" translate="yes" xml:space="preserve">
          <source>merge @return</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d94394a5a243f3c0a5d73dac018a4602e03c9219" translate="yes" xml:space="preserve">
          <source>merge @see</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02e0b3b936c0c662ebcfdf810d2149281cf5964e" translate="yes" xml:space="preserve">
          <source>merge @since</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="114d10054574c18342d8601a610ff500d4699c6f" translate="yes" xml:space="preserve">
          <source>merge @version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf3d63d0de7339512c7c20877b3493c69d4b391" translate="yes" xml:space="preserve">
          <source>merge description</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="081bf3eedfad8141702fa4a674de79254e0bba8d" translate="yes" xml:space="preserve">
          <source>merge everything</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a2028205cfa2d777778b9c1917c1f319ccdc056" translate="yes" xml:space="preserve">
          <source>method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; {&lt;a href=&quot;expr#parameter&quot;&gt;parameter&lt;/a&gt;} [:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;] =&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97a4d248969085dc90c6ba25671be9eb3e3a66e9" translate="yes" xml:space="preserve">
          <source>method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="004b8055d31dce5d4e913167b004b3141837a0d3" translate="yes" xml:space="preserve">
          <source>method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:type { &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt; }&lt;sup&gt;+&lt;/sup&gt;.&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4d4eee113689a169ac1f1621aa0617f21c99c15" translate="yes" xml:space="preserve">
          <source>method [private] [virtual] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ce6bced41cd8c05830dddc0882debf66ac3928" translate="yes" xml:space="preserve">
          <source>method [private] virtual&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a342a3b18641ab1a9d1a21182afb977dbb6aa77" translate="yes" xml:space="preserve">
          <source>method names (&lt;a href=&quot;#method-name&quot;&gt;method-name&lt;/a&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="491ac61e8bf68487cd27e9b71f1b4310a54c3b00" translate="yes" xml:space="preserve">
          <source>method! [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; {&lt;a href=&quot;expr#parameter&quot;&gt;parameter&lt;/a&gt;} [:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;] =&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4f952509013443c536c201db74e15a8cbd892da" translate="yes" xml:space="preserve">
          <source>method! [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70c4031b37141b9d489ed7a1a3e3ade74cc42dd" translate="yes" xml:space="preserve">
          <source>method! [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:type { &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt; }&lt;sup&gt;+&lt;/sup&gt;.&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72d34da1d32cc0d6e3501e59432f8b5e192bd725" translate="yes" xml:space="preserve">
          <source>method, &lt;a href=&quot;classes#hevea_manual.kwd106&quot;&gt;7.9.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd113&quot;&gt;7.9.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd115&quot;&gt;7.9.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd127&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd137&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd139&quot;&gt;7.9.2&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fd20118ee7a7faac798544db735f202b14acf41" translate="yes" xml:space="preserve">
          <source>method-name</source>
          <target state="translated">method-name</target>
        </trans-unit>
        <trans-unit id="57d32765a281ea1c0a529b8ce8847eb1cd520e63" translate="yes" xml:space="preserve">
          <source>method-type</source>
          <target state="translated">method-type</target>
        </trans-unit>
        <trans-unit id="01a46fb52f0c14f92da476120be7afe1ef1ec52d" translate="yes" xml:space="preserve">
          <source>method:</source>
          <target state="translated">method:</target>
        </trans-unit>
        <trans-unit id="8334677a4eea51376469f929869216e0ab4616fd" translate="yes" xml:space="preserve">
          <source>methodvirtualprivate&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;</source>
          <target state="translated">methodvirtualprivate&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="614383124112900fb6142b3695d7dfbf394c6335" translate="yes" xml:space="preserve">
          <source>miscellaneous memory-related functions and macros (for GC interface, in-place modification of structures, etc).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5efca0a1c6b9e23ddc653fc69324668576ca551d" translate="yes" xml:space="preserve">
          <source>mkfifo</source>
          <target state="translated">mkfifo</target>
        </trans-unit>
        <trans-unit id="7dd30f0a95d522bfc058be4e75847f8b6df9f76b" translate="yes" xml:space="preserve">
          <source>mod</source>
          <target state="translated">mod</target>
        </trans-unit>
        <trans-unit id="06c208939b2262778ef29013e5908ca82e6e3245" translate="yes" xml:space="preserve">
          <source>mod ∣ land ∣ lor ∣ lxor ∣ lsl ∣ lsr ∣ asr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63ab5a4895e2bc2ade8b04e93895b8fc37dd8e04" translate="yes" xml:space="preserve">
          <source>mod, &lt;a href=&quot;names#hevea_manual.kwd0&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd51&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd70&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd77&quot;&gt;7.7.5&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d636f16bc4bdded1e9603e3215629abedd36a6b" translate="yes" xml:space="preserve">
          <source>mod-constraint</source>
          <target state="translated">mod-constraint</target>
        </trans-unit>
        <trans-unit id="3dae3b4efe9ff863260fe60d05952948b42579e8" translate="yes" xml:space="preserve">
          <source>mode:</source>
          <target state="translated">mode:</target>
        </trans-unit>
        <trans-unit id="008f58e566745159bf275b503f47ccc404114628" translate="yes" xml:space="preserve">
          <source>modtype-name</source>
          <target state="translated">modtype-name</target>
        </trans-unit>
        <trans-unit id="8f625b907f6d84171d5c22e1036e9fce19990a18" translate="yes" xml:space="preserve">
          <source>modtype-path</source>
          <target state="translated">modtype-path</target>
        </trans-unit>
        <trans-unit id="2078d9b7571dfde4914b5ce804793816f94bf991" translate="yes" xml:space="preserve">
          <source>modtype:</source>
          <target state="translated">modtype:</target>
        </trans-unit>
        <trans-unit id="fbd34a2b6e6a9fe8161f97dc435642609ac0bc29" translate="yes" xml:space="preserve">
          <source>module</source>
          <target state="translated">module</target>
        </trans-unit>
        <trans-unit id="7441763e8eadca2fc8f46b1c8e352dca85e44ef4" translate="yes" xml:space="preserve">
          <source>module names (&lt;a href=&quot;#module-name&quot;&gt;module-name&lt;/a&gt;),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8006ab4be9c917928e0ca82ba074953be1e5ab4" translate="yes" xml:space="preserve">
          <source>module type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff018ec921edc32afa3f9da1561f4efc690c0da0" translate="yes" xml:space="preserve">
          <source>module type names (&lt;a href=&quot;#modtype-name&quot;&gt;modtype-name&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66ccaea6e2ca71b1b1450f0caf5262350d7e8783" translate="yes" xml:space="preserve">
          <source>module, &lt;a href=&quot;expr#hevea_manual.kwd89&quot;&gt;7.7.8&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd160&quot;&gt;7.10&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd172&quot;&gt;7.10.2&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd174&quot;&gt;7.10.2&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd188&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd200&quot;&gt;7.11.2&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd202&quot;&gt;7.11.2&lt;/a&gt;, &lt;a href=&quot;manual024#hevea_manual.kwd206&quot;&gt;8.2&lt;/a&gt;, &lt;a href=&quot;firstclassmodules#hevea_manual.kwd212&quot;&gt;8.5&lt;/a&gt;, &lt;a href=&quot;moduletypeof#hevea_manual.kwd216&quot;&gt;8.6&lt;/a&gt;, &lt;a href=&quot;signaturesubstitution#hevea_manual.kwd221&quot;&gt;8.7&lt;/a&gt;, &lt;a href=&quot;modulealias#hevea_manual.kwd223&quot;&gt;8.8&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cd15a4ce8a913b20909f69ed51f94dbccccc68f" translate="yes" xml:space="preserve">
          <source>module-expr</source>
          <target state="translated">module-expr</target>
        </trans-unit>
        <trans-unit id="4e3c9a4fceacf3d192e656bfc0847f9da785fa74" translate="yes" xml:space="preserve">
          <source>module-items</source>
          <target state="translated">module-items</target>
        </trans-unit>
        <trans-unit id="8ee15acbd165acaa3fef478e3d7ce0417164f411" translate="yes" xml:space="preserve">
          <source>module-name</source>
          <target state="translated">module-name</target>
        </trans-unit>
        <trans-unit id="1809db2c8ca3cd86dd0fdcf7aadd3f15ca27ad7e" translate="yes" xml:space="preserve">
          <source>module-path</source>
          <target state="translated">module-path</target>
        </trans-unit>
        <trans-unit id="29544219138b467872756c6b67b20584c7e6f25e" translate="yes" xml:space="preserve">
          <source>module-type</source>
          <target state="translated">module-type</target>
        </trans-unit>
        <trans-unit id="d1bf2e17e7158e60062b4c38d952e84b30ef30c3" translate="yes" xml:space="preserve">
          <source>module:</source>
          <target state="translated">module:</target>
        </trans-unit>
        <trans-unit id="99933645f3edbe7c64fff338a2636a8d018ffe92" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; { (&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;) } :&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd25d37a9a6ec100221b48f42e245756859b23ab" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; { (&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) } :&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdadf480c8065207bb758b98366a71b036929433" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; { (&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) } [ :&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; ] =&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa34c20a9c7d986a37d6eddddd05986ad9258f5c" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; { (&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) } [ :&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; ] =&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1effb736fd5f5334d101acbb2561cc9bfd106725" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; { (&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) ∣ () } :&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4983318ce2c3564851abf76d595b1d25621f08b7" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; { (&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) ∣ () } [ :&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; ] =&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8467d40414b615a8d8b9b013ae16bc58757f7d3f" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;(name&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;) &amp;hellip; (name&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;):&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="937c777204afe4c1bc132190a3d30d967a32788c" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;(name&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;) &amp;hellip; (name&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;)=&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d038178fa9ade448767894d13aa64c21d48f6e0a" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;</source>
          <target state="translated">module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf3cf4d234053495820f28e041e9f40be3b34f64" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1390692de1de4cfcb57f9a157fc2b42b55f29f0" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;=&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;</source>
          <target state="translated">module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;=&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e00f00c98b176075f013ab125f5a6e633ed2b73" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:=&lt;a href=&quot;names#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt;</source>
          <target state="translated">module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:=&lt;a href=&quot;names#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="893c581556967dd03a0cd4ae837413e1977ae685" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:functor(name&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;)-&amp;gt; &amp;hellip; -&amp;gt;&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8282410bc5bb37ea017816d776939482bd821c09" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;=(&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;).</source>
          <target state="translated">module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;=(&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
