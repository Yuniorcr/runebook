<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="ocaml">
    <body>
      <group id="ocaml">
        <trans-unit id="aef308ac0940e6d74a453eb280aef926fedc4674" translate="yes" xml:space="preserve">
          <source>Unboxed integer values (ASCII code).</source>
          <target state="translated">박싱되지 않은 정수 값 (ASCII 코드).</target>
        </trans-unit>
        <trans-unit id="6736fe7df2039684117bc316d99716a708ed0a5f" translate="yes" xml:space="preserve">
          <source>Unboxed integer values.</source>
          <target state="translated">박싱되지 않은 정수 값.</target>
        </trans-unit>
        <trans-unit id="64e121c34de9aeb900b4b306f512b07e8a250bb6" translate="yes" xml:space="preserve">
          <source>Unboxing of the closure causes the value for x inside g to be passed as an argument to g rather than through its closure. This means that the closure of g becomes constant and may be lifted to toplevel, eliminating the runtime allocation.</source>
          <target state="translated">클로저를 풀면 g 내부의 x 값이 클로저를 통하지 않고 g에 대한 인수로 전달됩니다. 즉, g의 클로저가 일정 해지고 최상위 수준으로 올라가 런타임 할당이 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9a0f02f56bad3e9e2035809eac95fd20eaae739" translate="yes" xml:space="preserve">
          <source>Uncaught exception</source>
          <target state="translated">포착되지 않은 예외</target>
        </trans-unit>
        <trans-unit id="bd6e9bbc140db8671611ddd7fc62a9229a86b7b8" translate="yes" xml:space="preserve">
          <source>Uncaught exceptions</source>
          <target state="translated">포착되지 않은 예외</target>
        </trans-unit>
        <trans-unit id="fbda3791626315021f610d03deb27c5845679a10" translate="yes" xml:space="preserve">
          <source>Undeclared virtual method.</source>
          <target state="translated">선언되지 않은 가상 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="ff4417ab4221f5d44f5639177b205205ee72e6ec" translate="yes" xml:space="preserve">
          <source>Under Unix and Cygwin, the command, the arguments, and the redirections if any are quoted using &lt;a href=&quot;filename#VALquote&quot;&gt;&lt;code&gt;Filename.quote&lt;/code&gt;&lt;/a&gt;, then concatenated. Under Win32, additional quoting is performed as required by the &lt;code&gt;cmd.exe&lt;/code&gt; shell that is called by &lt;a href=&quot;sys#VALcommand&quot;&gt;&lt;code&gt;Sys.command&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Unix 및 Cygwin에서 명령, 인수 및 리디렉션 (있는 경우)은 &lt;a href=&quot;filename#VALquote&quot;&gt; &lt;code&gt;Filename.quote&lt;/code&gt; 를&lt;/a&gt; 사용하여 인용 된 다음 연결됩니다. Win32에서는 &lt;a href=&quot;sys#VALcommand&quot;&gt; &lt;code&gt;Sys.command&lt;/code&gt; 에서&lt;/a&gt; 호출 하는 &lt;code&gt;cmd.exe&lt;/code&gt; 셸에서 요구하는대로 추가 인용이 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="73ae8ab7df9ff2bd31ec5aefbc5d4b384fca6a0c" translate="yes" xml:space="preserve">
          <source>Under Windows ports (including Cygwin), comparison is case-insensitive, relying on &lt;code&gt;String.lowercase_ascii&lt;/code&gt;. Note that this does not match exactly the interpretation of case-insensitive filename equivalence from Windows.</source>
          <target state="translated">Windows 포트 (Cygwin 포함)에서 비교는 &lt;code&gt;String.lowercase_ascii&lt;/code&gt; 에 따라 대소 문자를 구분하지 않습니다 . 이것은 Windows에서 대소 문자를 구분하지 않는 파일 이름 등가의 해석과 정확히 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7c30b17bfee8b41cae9acaf0fd4f36055ec37a0" translate="yes" xml:space="preserve">
          <source>Under Windows, use a forward slash (/) as the path separator instead of the usual backward slash (\). Under Unix, this option does nothing.</source>
          <target state="translated">Windows에서는 일반적인 백 슬래시 (\) 대신 슬래시 (/)를 경로 구분 기호로 사용하십시오. Unix에서이 옵션은 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2a98cf876c70e2d8f2c5c551aa28d19bc9e9f0b" translate="yes" xml:space="preserve">
          <source>Under the interactive system, the user types OCaml phrases terminated by ;; in response to the # prompt, and the system compiles them on the fly, executes them, and prints the outcome of evaluation. Phrases are either simple expressions, or let definitions of identifiers (either values or functions).</source>
          <target state="translated">대화 형 시스템에서 사용자는 ;;로 끝나는 OCaml 구문을 입력합니다. # 프롬프트에 대한 응답으로 시스템은 즉시 컴파일하고 실행하고 평가 결과를 인쇄합니다. 구문은 간단한 표현식이거나 식별자 (값 또는 함수)의 정의입니다.</target>
        </trans-unit>
        <trans-unit id="f9b219af612756cb93e821fb5ae6c25750a8208b" translate="yes" xml:space="preserve">
          <source>Undocumented functions</source>
          <target state="translated">문서화되지 않은 기능</target>
        </trans-unit>
        <trans-unit id="7f972e21664aacd3d93f9c25c031fdd4f9b63cac" translate="yes" xml:space="preserve">
          <source>Unerasable optional argument.</source>
          <target state="translated">지울 수없는 선택적 인수입니다.</target>
        </trans-unit>
        <trans-unit id="855db78e2b7ecfbfa45751560055e580b1f0426b" translate="yes" xml:space="preserve">
          <source>Unescaped end-of-line in a string constant (non-portable code).</source>
          <target state="translated">문자열 상수의 이스케이프 처리되지 않은 줄 끝 (이식 불가능한 코드).</target>
        </trans-unit>
        <trans-unit id="430e184cd12c9c60b3c1f834e3311ddc5fd18ef3" translate="yes" xml:space="preserve">
          <source>Unexpected documentation comment.</source>
          <target state="translated">예기치 않은 문서 주석입니다.</target>
        </trans-unit>
        <trans-unit id="c26d585a4a4c58b3670977403cc6faff38857d45" translate="yes" xml:space="preserve">
          <source>Unicode characters.</source>
          <target state="translated">유니 코드 문자.</target>
        </trans-unit>
        <trans-unit id="1a06870dcfd727858fe36ec3a78338d13e1109e1" translate="yes" xml:space="preserve">
          <source>Unicode mode: All path names, environment variables, command line arguments, etc. on the OCaml side are assumed to be encoded using UTF-8.</source>
          <target state="translated">유니 코드 모드 : OCaml 측의 모든 경로 이름, 환경 변수, 명령 줄 인수 등은 UTF-8을 사용하여 인코딩 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6b2a3b5d1d14ff610dc48ac49c4fe2d90f085c55" translate="yes" xml:space="preserve">
          <source>Unique ownership is linear: passing the data to another piece of code means giving up ownership (we cannot write the data again). A unique owner may decide to make the data shared (giving up mutation rights on it), but shared data may not become uniquely-owned again.</source>
          <target state="translated">고유 한 소유권은 선형 적입니다. 데이터를 다른 코드로 전달하는 것은 소유권을 포기하는 것을 의미합니다 (데이터를 다시 쓸 수 없음). 고유 한 소유자는 데이터를 공유하도록 결정할 수 있지만 (변형 권한을 포기) 공유 데이터는 다시 고유하게 소유되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="718811898739c2de10551b3e57d44b08120ca419" translate="yes" xml:space="preserve">
          <source>Unique ownership: the data may be accessed and mutated</source>
          <target state="translated">고유 한 소유권 : 데이터에 액세스하고 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6b935ab337145efdeadda28cae18aa89a845e36" translate="yes" xml:space="preserve">
          <source>Unit</source>
          <target state="translated">Unit</target>
        </trans-unit>
        <trans-unit id="913f68f196b9229e63375dbfc548fa272e1c3652" translate="yes" xml:space="preserve">
          <source>Unit operations</source>
          <target state="translated">단위 작업</target>
        </trans-unit>
        <trans-unit id="5f17d2a7a76cbbf26af7818ae32de850d9448591" translate="yes" xml:space="preserve">
          <source>Unit values.</source>
          <target state="translated">단위 값.</target>
        </trans-unit>
        <trans-unit id="cecc0d8500754b34f5bd7f11dfabb25c3a770aaf" translate="yes" xml:space="preserve">
          <source>Unix</source>
          <target state="translated">Unix</target>
        </trans-unit>
        <trans-unit id="9e87341cccc0656f2e5b6f6b5247bbf87754da13" translate="yes" xml:space="preserve">
          <source>Unix domain</source>
          <target state="translated">유닉스 도메인</target>
        </trans-unit>
        <trans-unit id="142fc83cd03cb48dcec9f0e42a287de6093e6ef6" translate="yes" xml:space="preserve">
          <source>Unix: Never use the strip command on executables produced by ocamlc -custom, this would remove the bytecode part of the executable.</source>
          <target state="translated">Unix : ocamlc -custom에 의해 생성 된 실행 파일에 대해 strip 명령을 사용하지 마십시오. 그러면 실행 파일의 바이트 코드 부분이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="4828c0275236c958b5d9f93626a6a151b8a88209" translate="yes" xml:space="preserve">
          <source>Unix: Security warning: never set the &amp;ldquo;setuid&amp;rdquo; or &amp;ldquo;setgid&amp;rdquo; bits on executables produced by ocamlc -custom, this would make them vulnerable to attacks.</source>
          <target state="translated">Unix : 보안 경고 : ocamlc -custom에 의해 생성 된 실행 파일에 &quot;setuid&quot;또는 &quot;setgid&quot;비트를 설정하지 마십시오. 그러면 공격에 취약해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8628c58b8b0ed243ff4d2c25335007aa2662e49" translate="yes" xml:space="preserve">
          <source>Unix: The debugger is available on Unix systems that provide BSD sockets.</source>
          <target state="translated">Unix : 디버거는 BSD 소켓을 제공하는 Unix 시스템에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad2d5a3a8eb281aff095c532257d99f6e760b2f3" translate="yes" xml:space="preserve">
          <source>Unix: The following environment variables are also consulted:</source>
          <target state="translated">Unix : 다음 환경 변수도 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="64ef177b89fca776de0c9cae01ff751ad7998744" translate="yes" xml:space="preserve">
          <source>Unix: The toplevel system is started by the command ocaml, as follows:</source>
          <target state="translated">Unix : 최상위 시스템은 다음과 같이 ocaml 명령으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="b888195998eac2b4be7e68badf7f6b41f579a285" translate="yes" xml:space="preserve">
          <source>Unix: This is material specific to the Unix family of operating systems, including Linux and macOS.</source>
          <target state="translated">Unix : Linux 및 macOS를 포함한 Unix 운영 체제 제품군에 특정한 자료입니다.</target>
        </trans-unit>
        <trans-unit id="361cde79cb6eba9a80e1a3a1b776b3f1a76b9944" translate="yes" xml:space="preserve">
          <source>UnixLabels</source>
          <target state="translated">UnixLabels</target>
        </trans-unit>
        <trans-unit id="e5fd9aa24c9417e7332e6f25936ae2a6ec8f1524" translate="yes" xml:space="preserve">
          <source>Unknown error</source>
          <target state="translated">알수없는 오류</target>
        </trans-unit>
        <trans-unit id="afd278add8fd7700e1517d25235a824bc141942f" translate="yes" xml:space="preserve">
          <source>Unless overridden by an attribute (see below), specialisation of a function will not be attempted if:</source>
          <target state="translated">속성 (아래 참조)에 의해 재정의되지 않는 한 다음과 같은 경우 함수의 특수화가 시도되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c39064849c793d38854fa83e22673292ca5cc1ab" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;unix#VALgetenv&quot;&gt;&lt;code&gt;Unix.getenv&lt;/code&gt;&lt;/a&gt;, this function returns the value even if the process has special privileges. It is considered unsafe because the programmer of a setuid or setgid program must be careful to avoid using maliciously crafted environment variables in the search path for executables, the locations for temporary files or logs, and the like.</source>
          <target state="translated">&lt;a href=&quot;unix#VALgetenv&quot;&gt; &lt;code&gt;Unix.getenv&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 프로세스에 특별한 권한이 있어도 값을 반환합니다. setuid 또는 setgid 프로그램의 프로그래머는 실행 파일의 검색 경로, 임시 파일 또는 로그 위치 등에서 악의적으로 제작 된 환경 변수를 사용하지 않도록주의해야하므로 안전하지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="170fdfcfd23bafa2fc167cc8615430aab46288f6" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;unixlabels#VALgetenv&quot;&gt;&lt;code&gt;UnixLabels.getenv&lt;/code&gt;&lt;/a&gt;, this function returns the value even if the process has special privileges. It is considered unsafe because the programmer of a setuid or setgid program must be careful to avoid using maliciously crafted environment variables in the search path for executables, the locations for temporary files or logs, and the like.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALgetenv&quot;&gt; &lt;code&gt;UnixLabels.getenv&lt;/code&gt; &lt;/a&gt; 와 달리이 함수는 프로세스에 특별한 권한이 있어도 값을 반환합니다. setuid 또는 setgid 프로그램의 프로그래머는 실행 파일의 검색 경로, 임시 파일 또는 로그 위치 등에서 악의적으로 제작 된 환경 변수를 사용하지 않도록주의해야하므로 안전하지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="bcb26dc7c0f8b5f19a49a3bac89490729e6e63f3" translate="yes" xml:space="preserve">
          <source>Unlike &lt;em&gt;eventlog-tools&lt;/em&gt;, which possesses a specific knowledge of OCaml&amp;rsquo;s &lt;em&gt;Common Trace Format&lt;/em&gt; schema, it is required to provide the OCaml &lt;em&gt;metadata&lt;/em&gt; file to &lt;em&gt;babeltrace&lt;/em&gt;.</source>
          <target state="translated">OCaml의 &lt;em&gt;Common Trace Format&lt;/em&gt; 스키마에 대한 특정 지식을 보유한 &lt;em&gt;eventlog-tools&lt;/em&gt; 와 달리 &lt;em&gt;babeltrace에&lt;/em&gt; OCaml &lt;em&gt;메타 데이터&lt;/em&gt; 파일을 제공해야합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9a10e065515b33488b54ddec47d446cd640967c7" translate="yes" xml:space="preserve">
          <source>Unlike a regular type abbreviation, a private type abbreviation declares a type that is distinct from its implementation type &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;. However, coercions from the type to &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; are permitted. Moreover, the compiler &amp;ldquo;knows&amp;rdquo; the implementation type and can take advantage of this knowledge to perform type-directed optimizations.</source>
          <target state="translated">일반 유형 약어와 달리 개인 유형 약어는 구현 유형 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr과&lt;/a&gt; 구별되는 유형을 선언합니다 . 그러나 유형에서 &lt;a href=&quot;types#typexpr&quot;&gt;typexpr 로의&lt;/a&gt; 강제 변환 은 허용됩니다. 또한 컴파일러는 구현 유형을 &quot;알고&quot;이 지식을 활용하여 유형 지향 최적화를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80af5ea86d75496571d4eb5e961951632ea1c005" translate="yes" xml:space="preserve">
          <source>Unlike classes, which cannot be defined inside an expression, immediate objects can appear anywhere, using variables from their environment.</source>
          <target state="translated">식 내에서 정의 할 수없는 클래스와 달리 즉시 개체는 환경의 변수를 사용하여 어디에나 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65e450d4c92511601f39760b7d537c5cc9300ca0" translate="yes" xml:space="preserve">
          <source>Unlike constructed values, polymorphic variant values taking several arguments are not flattened. That is, `VConstr(v, w) is represented by a block of size 2, whose field number 1 contains the representation of the pair (v, w), rather than a block of size 3 containing v and w in fields 1 and 2.</source>
          <target state="translated">생성 된 값과 달리 여러 인수를 사용하는 다형성 변형 값은 평면화되지 않습니다. 즉,`VConstr (v, w)는 필드 1과 필드에 v와 w를 포함하는 크기 3 블록이 아니라 필드 번호 1에 쌍 (v, w)의 표현이 포함 된 크기 2 블록으로 표시됩니다. 2.</target>
        </trans-unit>
        <trans-unit id="daf410a070338968c622e20408d5e4cb4a9c9cbd" translate="yes" xml:space="preserve">
          <source>Unlike most fuzzers, afl-fuzz observes the internal behaviour of the program being tested, and adjusts the test cases it generates to trigger unexplored execution paths. As a result, test cases generated by afl-fuzz cover more of the possible behaviours of the tested program than other fuzzers.</source>
          <target state="translated">대부분의 퍼저와 달리 afl-fuzz는 테스트중인 프로그램의 내부 동작을 관찰하고 생성 된 테스트 케이스를 조정하여 탐색되지 않은 실행 경로를 트리거합니다. 결과적으로 afl-fuzz에 의해 생성 된 테스트 케이스는 다른 fuzzer보다 테스트 된 프로그램의 가능한 동작을 더 많이 포함합니다.</target>
        </trans-unit>
        <trans-unit id="80b8debcdfd0af497e33fd32ebd0c329ed223c51" translate="yes" xml:space="preserve">
          <source>Unlike the core Stdlib module, submodules are not automatically &amp;ldquo;opened&amp;rdquo; when compilation starts, or when the toplevel system is launched. Hence it is necessary to use qualified identifiers to refer to the functions provided by these modules, or to add open directives.</source>
          <target state="translated">핵심 Stdlib 모듈과 달리 하위 모듈은 컴파일이 시작되거나 최상위 시스템이 시작될 때 자동으로 &quot;열리지&quot;않습니다. 따라서 이러한 모듈에서 제공하는 함수를 참조하거나 개방형 지시문을 추가하려면 정규화 된 식별자를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="df0adb297358d6f84eb38585235f761f2474eba0" translate="yes" xml:space="preserve">
          <source>Unloading the dependent shared libraries that were loaded by the runtime, including dynlink plugins.</source>
          <target state="translated">dynlink 플러그인을 포함하여 런타임에 의해로드 된 종속 공유 라이브러리를 언로드합니다.</target>
        </trans-unit>
        <trans-unit id="e221fd771f76ac0c08ade26044bd31aad8410e11" translate="yes" xml:space="preserve">
          <source>Unlock a region</source>
          <target state="translated">지역 잠금 해제</target>
        </trans-unit>
        <trans-unit id="cbee51b6938b8833f6c9c14a960c32fc98b15cca" translate="yes" xml:space="preserve">
          <source>Unlock the given mutex.</source>
          <target state="translated">주어진 뮤텍스를 잠금 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="40b3fedb6918f76a1d2843a6217fb0459806116b" translate="yes" xml:space="preserve">
          <source>Unlock the given mutex. Other threads suspended trying to lock the mutex will restart.</source>
          <target state="translated">주어진 뮤텍스를 잠금 해제하십시오. 뮤텍스를 잠그려고 일시 중단 된 다른 스레드가 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="4ae4d55156aa4689306af92e67c36608ab8808bc" translate="yes" xml:space="preserve">
          <source>Unneeded fields can be omitted:</source>
          <target state="translated">불필요한 필드는 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85b0ad26af0b561093ef0ed3dfa3894398e55ee4" translate="yes" xml:space="preserve">
          <source>Unreachable case in a pattern-matching (based on type information).</source>
          <target state="translated">패턴 일치에서 도달 할 수없는 케이스 (유형 정보 기반).</target>
        </trans-unit>
        <trans-unit id="f05779c93acf03e53c5e3dff1098251cef41b56c" translate="yes" xml:space="preserve">
          <source>Unsafe conversions (for advanced users)</source>
          <target state="translated">안전하지 않은 변환 (고급 사용자 용)</target>
        </trans-unit>
        <trans-unit id="a2b13f45b65846cb19caeb60345a2df74e3c0fec" translate="yes" xml:space="preserve">
          <source>Unsafely convert a byte sequence into a string.</source>
          <target state="translated">바이트 시퀀스를 문자열로 안전하지 않게 변환합니다.</target>
        </trans-unit>
        <trans-unit id="184711f70420afa3bb8971f5272f0cc7e5d58bbc" translate="yes" xml:space="preserve">
          <source>Unsafely convert a shared string to a byte sequence that should not be mutated.</source>
          <target state="translated">공유 문자열을 변경해서는 안되는 바이트 시퀀스로 안전하지 않게 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b10f1dd8565cd1c52a800f50a4b69101c9d0316d" translate="yes" xml:space="preserve">
          <source>Unused ancestor variable.</source>
          <target state="translated">사용하지 않은 조상 변수입니다.</target>
        </trans-unit>
        <trans-unit id="f2135e52f312e0c6e0e48ccbe7c4300233af3147" translate="yes" xml:space="preserve">
          <source>Unused blocks in the heap are automatically reclaimed by the garbage collector. This requires some cooperation from C code that manipulates heap-allocated blocks.</source>
          <target state="translated">힙에서 사용되지 않은 블록은 가비지 수집기에 의해 자동으로 회수됩니다. 이를 위해서는 힙 할당 블록을 조작하는 C 코드의 협력이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d9d2bee7f4c5a8e21793774f016b9445cb2491e9" translate="yes" xml:space="preserve">
          <source>Unused constructor.</source>
          <target state="translated">사용하지 않는 생성자.</target>
        </trans-unit>
        <trans-unit id="e8932307b60e4ea07a13fdca33701b5b386e6782" translate="yes" xml:space="preserve">
          <source>Unused extension constructor.</source>
          <target state="translated">사용하지 않는 확장 생성자.</target>
        </trans-unit>
        <trans-unit id="bce80385d6d0c6ec6ed8b2418d97b11a8b08e5a1" translate="yes" xml:space="preserve">
          <source>Unused for-loop index.</source>
          <target state="translated">사용되지 않은 for 루프 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="acd69a014e402f61b2816913ac1b533fe2cf4484" translate="yes" xml:space="preserve">
          <source>Unused function argument.</source>
          <target state="translated">사용하지 않는 함수 인수입니다.</target>
        </trans-unit>
        <trans-unit id="5e88849e413a3426f34b869856edcd5da6f68428" translate="yes" xml:space="preserve">
          <source>Unused functor parameter.</source>
          <target state="translated">사용하지 않은 펑터 매개 변수.</target>
        </trans-unit>
        <trans-unit id="58d908fc34cd65922d5192f731073878254bc325" translate="yes" xml:space="preserve">
          <source>Unused module declaration.</source>
          <target state="translated">사용하지 않는 모듈 선언.</target>
        </trans-unit>
        <trans-unit id="c1ca9a5d74e69edb9e1f7c3d3fe760448d92b5d0" translate="yes" xml:space="preserve">
          <source>Unused open statement.</source>
          <target state="translated">사용하지 않은 오픈 진술.</target>
        </trans-unit>
        <trans-unit id="368828ea89de7758a83ef5a2303643e5169a7dc6" translate="yes" xml:space="preserve">
          <source>Unused open! statement.</source>
          <target state="translated">미사용 오픈! 성명서.</target>
        </trans-unit>
        <trans-unit id="2fd45978a6cade82e52fdd41f1ab2e9eff81f96c" translate="yes" xml:space="preserve">
          <source>Unused rec flag.</source>
          <target state="translated">사용하지 않은 rec 플래그.</target>
        </trans-unit>
        <trans-unit id="c9f8d493131a0a65a3df35bc380544a58e71361a" translate="yes" xml:space="preserve">
          <source>Unused type declaration.</source>
          <target state="translated">사용하지 않는 유형 선언.</target>
        </trans-unit>
        <trans-unit id="f9d36a6d7c0770d8a403ea5d31dd91ea42c0b008" translate="yes" xml:space="preserve">
          <source>Unused value declaration.</source>
          <target state="translated">미사용 값 선언.</target>
        </trans-unit>
        <trans-unit id="0bb036b86a60318fcf6bf365ea7870fc31e350c6" translate="yes" xml:space="preserve">
          <source>Update the &lt;code&gt;lex_curr_p&lt;/code&gt; field of the lexbuf to reflect the start of a new line.</source>
          <target state="translated">새 줄의 시작을 반영하도록 lexbuf 의 &lt;code&gt;lex_curr_p&lt;/code&gt; 필드를 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="ed514447bdac477fcc7368e5493b6028c29815ca" translate="yes" xml:space="preserve">
          <source>Update the &lt;code&gt;lex_curr_p&lt;/code&gt; field of the lexbuf to reflect the start of a new line. You can call this function in the semantic action of the rule that matches the end-of-line character. The function does nothing when position tracking is disabled.</source>
          <target state="translated">새 줄의 시작을 반영하도록 lexbuf 의 &lt;code&gt;lex_curr_p&lt;/code&gt; 필드를 업데이트합니다 . 줄 끝 문자와 일치하는 규칙의 의미 동작에서이 함수를 호출 할 수 있습니다. 위치 추적이 비활성화되면이 기능은 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="537666d1dbd2fa0db7069f8d3cd01ec60272e5dd" translate="yes" xml:space="preserve">
          <source>Urgent condition on socket</source>
          <target state="translated">소켓의 긴급 상황</target>
        </trans-unit>
        <trans-unit id="0a643b76ebf1d85ac82c0fea6de291116e76f169" translate="yes" xml:space="preserve">
          <source>Use a reference to hold one of the two functions, as in :</source>
          <target state="translated">참조를 사용하여 다음과 같이 두 기능 중 하나를 보유하십시오.</target>
        </trans-unit>
        <trans-unit id="739d4f5d5767f58211e673bb1ebe35dad451e751" translate="yes" xml:space="preserve">
          <source>Use a short form to display functors:</source>
          <target state="translated">짧은 형식을 사용하여 펑터를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="151fed5b01cf4fdfa0cf96e7df2ca528006f940d" translate="yes" xml:space="preserve">
          <source>Use ccomp as the C linker called to build the final executable and as the C compiler for compiling .c source files.</source>
          <target state="translated">최종 실행 파일을 빌드하기 위해 호출되는 C 링커로 ccomp를 사용하고 .c 소스 파일을 컴파일하기 위해 C 컴파일러로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e95d994a10737b249b1b6ca223f5268903a19eac" translate="yes" xml:space="preserve">
          <source>Use ccomp as the C linker when linking in &amp;ldquo;custom runtime&amp;rdquo; mode (see the -custom option) and as the C compiler for compiling .c source files.</source>
          <target state="translated">&quot;사용자 정의 런타임&quot;모드 (-custom 옵션 참조)에서 링크 할 때 C 링커로 ccomp를 사용하고 .c 소스 파일을 컴파일하기위한 C 컴파일러로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c7e56fe87118003db21cc87b9faea5b04603884d" translate="yes" xml:space="preserve">
          <source>Use cmd instead of ocamlc to call the bytecode compiler.</source>
          <target state="translated">ocamlc 대신 cmd를 사용하여 바이트 코드 컴파일러를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="f5aa8bdfb4a918e9e6c8a6c9078f5bcb7fa49544" translate="yes" xml:space="preserve">
          <source>Use cmd instead of ocamlopt to call the native-code compiler.</source>
          <target state="translated">ocamlopt 대신 cmd를 사용하여 네이티브 코드 컴파일러를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="25a54deab044fad1c4ebb1e877ef8d4262ad6c2d" translate="yes" xml:space="preserve">
          <source>Use content of file as ocamldoc text to use as introduction (HTML, L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X and TeXinfo only). For HTML, the file is used to create the whole index.html file.</source>
          <target state="translated">ocamldoc 텍스트로 파일의 사용 내용 소개 (HTML, L으로 사용할 T &lt;sub&gt;E&lt;/sub&gt; X와는 TeXinfo 만 해당). HTML의 경우 파일은 전체 index.html 파일을 만드는 데 사용됩니다.&lt;sup&gt;&lt;/sup&gt;&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="f3bfae018cf53a781671cacffec6bc019506b2de" translate="yes" xml:space="preserve">
          <source>Use file as a script file name, even when it starts with a hyphen (-).</source>
          <target state="translated">하이픈 (-)으로 시작하는 경우에도 파일을 스크립트 파일 이름으로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e89af95620878921a365ac66230e7c38ab048bbd" translate="yes" xml:space="preserve">
          <source>Use filename as the Cascading Style Sheet file.</source>
          <target state="translated">파일 이름을 Cascading Style Sheet 파일로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e78e4a0a07f4466e6a27ea7a18bff19f7ffd2bae" translate="yes" xml:space="preserve">
          <source>Use linear scan register allocation. Compiling with this allocator is faster than with the usual graph coloring allocator, sometimes quite drastically so for long functions and modules. On the other hand, the generated code can be a bit slower.</source>
          <target state="translated">선형 스캔 레지스터 할당을 사용합니다. 이 할당 자로 컴파일하는 것은 일반적인 그래프 색상 할당 자보다 빠르며 때로는 긴 함수와 모듈의 경우 상당히 과감합니다. 반면에 생성 된 코드는 약간 느릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30651d527d291118e5c81ec20804fa7f8152da5e" translate="yes" xml:space="preserve">
          <source>Use of #-types to abbreviate polymorphic variant types is deprecated. If t is an exact variant type then #t translates to [&amp;lt;t], and #t[&amp;gt;`&lt;a href=&quot;names#tag-name&quot;&gt;tag&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;`&lt;a href=&quot;names#tag-name&quot;&gt;tag&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;] translates to [&amp;lt;t&amp;gt;`&lt;a href=&quot;names#tag-name&quot;&gt;tag&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;`&lt;a href=&quot;names#tag-name&quot;&gt;tag&lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt;]</source>
          <target state="translated">다형성 변형 유형을 축약하기 위해 # 유형을 사용하는 것은 더 이상 사용되지 않습니다. t가 정확한 변형 유형이면 #t는 [&amp;lt;t]로 변환되고 #t [&amp;gt;` &lt;a href=&quot;names#tag-name&quot;&gt;tag &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;` &lt;a href=&quot;names#tag-name&quot;&gt;tag &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; ]는 [&amp;lt;t&amp;gt;` &lt;a href=&quot;names#tag-name&quot;&gt;tag &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip;` &lt;a href=&quot;names#tag-name&quot;&gt;tag &lt;/a&gt;&lt;sub&gt;k&lt;/sub&gt; ]로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="179cb603754bb4c16dcadb3f0efdb9ceb776af51" translate="yes" xml:space="preserve">
          <source>Use of the ocamlfind utility is recommended. However, if this is not possible, an alternative method may be used:</source>
          <target state="translated">ocamlfind 유틸리티를 사용하는 것이 좋습니다. 그러나 이것이 가능하지 않은 경우 다른 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="486b3ac03120a2b0d6cf25a7ef30edee35307954" translate="yes" xml:space="preserve">
          <source>Use socket for communicating with the debugged program. See the description of the command set socket (section &lt;a href=&quot;#ss%3Adebugger-communication&quot;&gt;17.8.8&lt;/a&gt;) for the format of socket.</source>
          <target state="translated">디버깅 된 프로그램과 통신하려면 소켓을 사용하십시오. 소켓 형식에 대해서는 명령 세트 소켓 (섹션 &lt;a href=&quot;#ss%3Adebugger-communication&quot;&gt;17.8.8&lt;/a&gt; )에 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="babde098406fd068128680f9d2260458e1e9bfbb" translate="yes" xml:space="preserve">
          <source>Use socket for communication with the program. socket can be either a file name, or an Internet port specification host:port, where host is a host name or an Internet address in dot notation, and port is a port number on the host.</source>
          <target state="translated">프로그램과의 통신을 위해 소켓을 사용하십시오. socket은 파일 이름 또는 인터넷 포트 사양 host : port 일 수 있습니다. 여기서 host는 호스트 이름 또는 점 표기법의 인터넷 주소이고 port는 호스트의 포트 번호입니다.</target>
        </trans-unit>
        <trans-unit id="c69190456e3d3b4a9937b9b8bc1a23ac4bcaa77e" translate="yes" xml:space="preserve">
          <source>Use symbolic formatter &lt;code&gt;ppf&lt;/code&gt; as usual, and retrieve symbolic items at end of pretty-printing by flushing symbolic output buffer &lt;code&gt;sob&lt;/code&gt; with:</source>
          <target state="translated">평소와 같이 기호 형식 기 &lt;code&gt;ppf&lt;/code&gt; 를 사용하고 다음을 사용 하여 기호 출력 버퍼 &lt;code&gt;sob&lt;/code&gt; 를 플러시하여 예쁜 인쇄가 끝날 때 기호 항목을 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="2cd5648874a47a9e1c6b2f8873e0f3b1a2133aed" translate="yes" xml:space="preserve">
          <source>Use the IA32 instructions to compute trigonometric and exponential functions, instead of calling the corresponding library routines. The functions affected are: atan, atan2, cos, log, log10, sin, sqrt and tan. The resulting code runs faster, but the range of supported arguments and the precision of the result can be reduced. In particular, trigonometric operations cos, sin, tan have their range reduced to [&amp;minus;2&lt;sup&gt;64&lt;/sup&gt;, 2&lt;sup&gt;64&lt;/sup&gt;].</source>
          <target state="translated">해당 라이브러리 루틴을 호출하는 대신 IA32 명령어를 사용하여 삼각 함수 및 지수 함수를 계산합니다. 영향을받는 함수는 atan, atan2, cos, log, log10, sin, sqrt 및 tan입니다. 결과 코드는 더 빠르게 실행되지만 지원되는 인수의 범위와 결과의 정밀도는 줄어들 수 있습니다. 특히 삼각 연산 cos, sin, tan의 범위는 [&amp;minus;2 &lt;sup&gt;64&lt;/sup&gt; , 2 &lt;sup&gt;64&lt;/sup&gt; ]로 축소됩니다 .</target>
        </trans-unit>
        <trans-unit id="75b4c58de40c5fb0e653f6415a4f1b48952e39fb" translate="yes" xml:space="preserve">
          <source>Use this function when your custom block holds only out-of-heap memory (memory allocated with malloc or caml_stat_alloc) and no other resources. used should be the number of bytes of out-of-heap memory that are held by your custom block. This function works like caml_alloc_custom except that the max parameter is under the control of the user (via the custom_major_ratio, custom_minor_ratio, and custom_minor_max_size parameters) and proportional to the heap sizes.</source>
          <target state="translated">사용자 정의 블록이 힙 부족 메모리 (malloc 또는 caml_stat_alloc로 할당 된 메모리) 만 보유하고 다른 리소스는 보유하지 않는 경우이 함수를 사용하십시오. used는 사용자 정의 블록이 보유하는 힙 부족 메모리의 바이트 수 여야합니다. 이 함수는 max 매개 변수가 사용자의 제어를 받고 (custom_major_ratio, custom_minor_ratio 및 custom_minor_max_size 매개 변수를 통해) 힙 크기에 비례한다는 점을 제외하고 caml_alloc_custom과 유사하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7941ff55d3e49988c4c70473e63a19eae903c125" translate="yes" xml:space="preserve">
          <source>Use title as the title for the generated documentation.</source>
          <target state="translated">생성 된 문서의 제목으로 title을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="33cc8398531eeec1655e1c8fcddb6c0c6fd1f30b" translate="yes" xml:space="preserve">
          <source>Useful functions</source>
          <target state="translated">유용한 기능</target>
        </trans-unit>
        <trans-unit id="0f394ba35c69f78febcb28d6e3e5d50c70e2e7b0" translate="yes" xml:space="preserve">
          <source>Useless record with clause.</source>
          <target state="translated">절이있는 쓸모없는 기록.</target>
        </trans-unit>
        <trans-unit id="7150f5b0ccc9ad0053128f11ad4305cc1edea658" translate="yes" xml:space="preserve">
          <source>User id of the owner</source>
          <target state="translated">소유자의 사용자 ID</target>
        </trans-unit>
        <trans-unit id="565cf3c85ae326fd320b914df7dffad6039c9e02" translate="yes" xml:space="preserve">
          <source>User id, group id</source>
          <target state="translated">사용자 ID, 그룹 ID</target>
        </trans-unit>
        <trans-unit id="21634717ab2d5493ce99d9e10587084f2fb636f2" translate="yes" xml:space="preserve">
          <source>User primitives are declared in an implementation file or struct&amp;hellip;end module expression using the external keyword:</source>
          <target state="translated">사용자 프리미티브는 외부 키워드를 사용하여 구현 파일 또는 struct&amp;hellip; end 모듈 표현식에서 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="e76bea74573cfe0bfd448177f94e560637c3a0b7" translate="yes" xml:space="preserve">
          <source>User primitives with arity greater than 5 should be implemented by two C functions. The first function, to be used in conjunction with the bytecode compiler ocamlc, receives two arguments: a pointer to an array of OCaml values (the values for the arguments), and an integer which is the number of arguments provided. The other function, to be used in conjunction with the native-code compiler ocamlopt, takes its arguments directly. For instance, here are the two C functions for the 7-argument primitive Nat.add_nat:</source>
          <target state="translated">arity가 5보다 큰 사용자 프리미티브는 두 개의 C 함수로 구현해야합니다. 바이트 코드 컴파일러 ocamlc와 함께 사용되는 첫 번째 함수는 OCaml 값 배열에 대한 포인터 (인수 값)와 제공된 인수 수인 정수라는 두 개의 인수를받습니다. 네이티브 코드 컴파일러 ocamlopt와 함께 사용되는 다른 함수는 인수를 직접받습니다. 예를 들어, 다음은 7 인수 기본형 Nat.add_nat에 대한 두 개의 C 함수입니다.</target>
        </trans-unit>
        <trans-unit id="b2e2f5922d423f16a794e9dc47293889f985312b" translate="yes" xml:space="preserve">
          <source>User primitives with arity n &amp;le; 5 are implemented by C functions that take n arguments of type value, and return a result of type value. The type value is the type of the representations for OCaml values. It encodes objects of several base types (integers, floating-point numbers, strings, &amp;hellip;) as well as OCaml data structures. The type value and the associated conversion functions and macros are described in detail below. For instance, here is the declaration for the C function implementing the input primitive:</source>
          <target state="translated">arity n &amp;le; 5 인 사용자 프리미티브는 값 유형의 n 인수를 취하고 값 유형의 결과를 리턴하는 C 함수에 의해 구현됩니다. 유형 값은 OCaml 값에 대한 표현 유형입니다. 여러 기본 유형 (정수, 부동 소수점 숫자, 문자열 등)의 개체와 OCaml 데이터 구조를 인코딩합니다. 유형 값과 관련 변환 함수 및 매크로는 아래에 자세히 설명되어 있습니다. 예를 들어, 다음은 입력 프리미티브를 구현하는 C 함수에 대한 선언입니다.</target>
        </trans-unit>
        <trans-unit id="fdc8df31d28f8bef488b448a18127e1554e1ec5c" translate="yes" xml:space="preserve">
          <source>User time for the children processes</source>
          <target state="translated">하위 프로세스에 대한 사용자 시간</target>
        </trans-unit>
        <trans-unit id="a51ce85f72da94ad3e8baaae0981a64012711679" translate="yes" xml:space="preserve">
          <source>User time for the process</source>
          <target state="translated">프로세스에 대한 사용자 시간</target>
        </trans-unit>
        <trans-unit id="269caf30a531474b7d8f62fd8bc5f4d312f503d7" translate="yes" xml:space="preserve">
          <source>User-defined data structures include records and variants. Both are defined with the type declaration. Here, we declare a record type to represent rational numbers.</source>
          <target state="translated">사용자 정의 데이터 구조에는 레코드와 변형이 포함됩니다. 둘 다 유형 선언으로 정의됩니다. 여기서 유리수를 나타내는 레코드 유형을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="99b7a9c1cda7f0b25021511c2cba9fad3dba682c" translate="yes" xml:space="preserve">
          <source>Users can also define &lt;em&gt;and operators&lt;/em&gt;:</source>
          <target state="translated">사용자는 &lt;em&gt;및 연산자를&lt;/em&gt; 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="523c481222828c351b48f48cedb77b983332c9ab" translate="yes" xml:space="preserve">
          <source>Users can define &lt;em&gt;let operators&lt;/em&gt;:</source>
          <target state="translated">사용자는 &lt;em&gt;let 연산자&lt;/em&gt; 를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a7515319d18e38efa130281795ff468d3f181f0" translate="yes" xml:space="preserve">
          <source>Users can provide their own documentation generator to be used during step 2 instead of the default generators. All the information retrieved during the analysis step is available through the Odoc_info module, which gives access to all the types and functions representing the elements found in the given modules, with their associated description.</source>
          <target state="translated">사용자는 기본 생성기 대신 2 단계에서 사용할 자체 문서 생성기를 제공 할 수 있습니다. 분석 단계에서 검색된 모든 정보는 Odoc_info 모듈을 통해 사용할 수 있으며, 이는 관련 설명과 함께 지정된 모듈에서 발견 된 요소를 나타내는 모든 유형 및 함수에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="686d35a1878d43f899780e120d4e310d31a7e4fc" translate="yes" xml:space="preserve">
          <source>Users of this module are encouraged to do &lt;code&gt;open&amp;nbsp;Bigarray&lt;/code&gt; in their source, then refer to array types and operations via short dot notation, e.g. &lt;code&gt;Array1.t&lt;/code&gt; or &lt;code&gt;Array2.sub&lt;/code&gt;.</source>
          <target state="translated">이 모듈의 사용자는 소스에서 &lt;code&gt;open&amp;nbsp;Bigarray&lt;/code&gt; 를 열고 짧은 점 표기법 (예 : &lt;code&gt;Array1.t&lt;/code&gt; 또는 &lt;code&gt;Array2.sub&lt;/code&gt; )을 통해 배열 유형 및 작업을 참조하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a9aafe7611fe4c80acc31f514470ed26f519ac41" translate="yes" xml:space="preserve">
          <source>Using a generalized algebraic datatype (GADT) here allows writing well-typed polymorphic functions whose return type depend on the argument type, such as:</source>
          <target state="translated">여기서 일반화 된 대수 데이터 유형 (GADT)을 사용하면 다음과 같이 반환 유형이 인수 유형에 따라 달라지는 잘 유형의 다형성 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="186f5c930a2da2f4b139e25273ca52659b37d980" translate="yes" xml:space="preserve">
          <source>Using multiple threads (shared-memory concurrency) in a mixed OCaml/C application requires special precautions, which are described in this section.</source>
          <target state="translated">혼합 된 OCaml / C 애플리케이션에서 여러 스레드 (공유 메모리 동시성)를 사용하려면이 섹션에서 설명하는 특별한 예방 조치가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4185b233b0e25ce53061fd3b5464cb0d929bdaf3" translate="yes" xml:space="preserve">
          <source>Using these attributes, it is possible to call C library functions with no indirection. For instance many math functions are defined this way in the OCaml standard library:</source>
          <target state="translated">이러한 속성을 사용하면 간접없이 C 라이브러리 함수를 호출 할 수 있습니다. 예를 들어 많은 수학 함수는 OCaml 표준 라이브러리에서 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c3a2ba33297635a5a100442a81946ae55e5b4d04" translate="yes" xml:space="preserve">
          <source>Using this mechanism, users of the library mylib.cma do not need to known that it references C code, nor whether this C code must be statically linked (using -custom) or dynamically linked.</source>
          <target state="translated">이 메커니즘을 사용하면 mylib.cma 라이브러리의 사용자는 C 코드를 참조하는지,이 C 코드가 정적으로 링크되어야하는지 (-custom 사용) 또는 동적으로 링크되어야하는지 알 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="d41532f24be37374e2392e03dcd432e4f024ed57" translate="yes" xml:space="preserve">
          <source>Using this option may degrade the quality of generated code, but it reduces compilation time, both on clean and incremental builds. Indeed, with the native compiler, when the implementation of a compilation unit changes, all the units that depend on it may need to be recompiled &amp;ndash; because the cross-module information may have changed. If the compilation unit whose implementation changed was compiled with -opaque, no such recompilation needs to occur. This option can thus be used, for example, to get faster edit-compile-test feedback loops.</source>
          <target state="translated">이 옵션을 사용하면 생성 된 코드의 품질이 저하 될 수 있지만 클린 빌드와 증분 빌드 모두에서 컴파일 시간이 줄어 듭니다. 실제로 네이티브 컴파일러를 사용하면 컴파일 단위의 구현이 변경되면 이에 종속 된 모든 단위를 다시 컴파일해야 할 수 있습니다. 교차 모듈 정보가 변경되었을 수 있기 때문입니다. 구현이 변경된 컴파일 단위가 -opaque로 컴파일 된 경우 이러한 재 컴파일이 발생할 필요가 없습니다. 따라서이 옵션은 예를 들어 더 빠른 편집-컴파일-테스트 피드백 루프를 얻기 위해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="203e1ca511488e35dc039744252193ca885d3db1" translate="yes" xml:space="preserve">
          <source>Usually, the exhaustiveness check only tries to check whether the cases omitted from the pattern matching are typable or not. However, you can force it to try harder by adding &lt;em&gt;refutation cases&lt;/em&gt;:</source>
          <target state="translated">일반적으로 완전성 검사는 패턴 일치에서 생략 된 케이스가 입력 가능한지 여부 만 확인합니다. 그러나 &lt;em&gt;반박 사례&lt;/em&gt; 를 추가하여 더 열심히 시도 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="04aa2275978eeaf5c333af7b59fe2e0c90f69a4c" translate="yes" xml:space="preserve">
          <source>VM-level threads. This implementation performs time-sharing and context switching at the level of the OCaml virtual machine (bytecode interpreter). It is available on Unix systems, and supports only bytecode programs. It cannot be used with native-code programs.</source>
          <target state="translated">VM 수준 스레드. 이 구현은 OCaml 가상 머신 (바이트 코드 인터프리터) 수준에서 시간 공유 및 컨텍스트 전환을 수행합니다. Unix 시스템에서 사용할 수 있으며 바이트 코드 프로그램 만 지원합니다. 원시 코드 프로그램과 함께 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="37e1b4eac2153fa2f4795d760b79561db8627b99" translate="yes" xml:space="preserve">
          <source>Val_bool(x) returns the OCaml boolean representing the truth value of the C integer x.</source>
          <target state="translated">Val_bool (x)는 C 정수 x의 진리 값을 나타내는 OCaml 부울을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7e94cddb0996c3086e6aa59a514ec82cb5af2aeb" translate="yes" xml:space="preserve">
          <source>Val_int(0)</source>
          <target state="translated">Val_int(0)</target>
        </trans-unit>
        <trans-unit id="25e40da040a0c12ef6b4bb1d7758cf251f928ccd" translate="yes" xml:space="preserve">
          <source>Val_int(1)</source>
          <target state="translated">Val_int(1)</target>
        </trans-unit>
        <trans-unit id="e9cca6677134db576d9f41823ff8015b091892b7" translate="yes" xml:space="preserve">
          <source>Val_int(i) returns the value encoding the inti.</source>
          <target state="translated">Val_int (i)는 inti를 인코딩하는 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc663e78a10eafc288ec1404183ecc1e722e99b3" translate="yes" xml:space="preserve">
          <source>Val_long(l) returns the value encoding the long intl.</source>
          <target state="translated">Val_long (l)은 long intl을 인코딩하는 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b89d186e5113422a8e6919d7df38f2c830163252" translate="yes" xml:space="preserve">
          <source>Val_true, Val_false represent the OCaml booleans true and false.</source>
          <target state="translated">Val_true, Val_false는 OCaml 부울 true 및 false를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="7b7c38fd2846399c3a4f294beacb165b7989b2b7" translate="yes" xml:space="preserve">
          <source>Values defined in tuple, as in let (x,y,z) = (1,2,3) are not kept by OCamldoc.</source>
          <target state="translated">let (x, y, z) = (1,2,3)에서와 같이 튜플에 정의 된 값은 OCamldoc에 의해 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0df0d057295bc592ab1965b6c77fca52e9a8d6d8" translate="yes" xml:space="preserve">
          <source>Values of a variant or record type declared private can be de-structured normally in pattern-matching or via the &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;.&lt;a href=&quot;names#field&quot;&gt;field&lt;/a&gt; notation for record accesses. However, values of these types cannot be constructed directly by constructor application or record construction. Moreover, assignment on a mutable field of a private record type is not allowed.</source>
          <target state="translated">private로 선언 된 변형 또는 레코드 유형의 값은 일반적으로 패턴 일치에서 또는 &lt;a href=&quot;expr#expr&quot;&gt;expr을&lt;/a&gt; 통해 구조를 해제 할 수 있습니다 . 레코드 액세스를위한 &lt;a href=&quot;names#field&quot;&gt;필드&lt;/a&gt; 표기법. 그러나 이러한 유형의 값은 생성자 응용 프로그램이나 레코드 생성에 의해 직접 생성 될 수 없습니다. 또한 개인 레코드 유형의 변경 가능한 필드에 대한 할당은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae1f9e546555b26d722af8ae1f8856ce883ea81b" translate="yes" xml:space="preserve">
          <source>Values of extensible variant types, for example exceptions (of extensible type &lt;code&gt;exn&lt;/code&gt;), returned by the unmarshaller should not be pattern-matched over through &lt;code&gt;match&amp;nbsp;...&amp;nbsp;with&lt;/code&gt; or &lt;code&gt;try&amp;nbsp;...&amp;nbsp;with&lt;/code&gt;, because unmarshalling does not preserve the information required for matching their constructors. Structural equalities with other extensible variant values does not work either. Most other uses such as Printexc.to_string, will still work as expected.</source>
          <target state="translated">비 정렬 화는 일치에 필요한 정보를 보존하지 않기 때문에 언 마샬 러가 반환 한 확장 가능한 변형 유형의 값 (예 : 확장 가능 유형의 &lt;code&gt;exn&lt;/code&gt; )은 &lt;code&gt;match&amp;nbsp;...&amp;nbsp;with&lt;/code&gt; 또는 &lt;code&gt;try&amp;nbsp;...&amp;nbsp;with&lt;/code&gt; 를 통해 패턴 일치 하지 않아야합니다. 생성자. 다른 확장 가능한 변형 값과의 구조적 동일성은 작동하지 않습니다. Printexc.to_string과 같은 대부분의 다른 용도는 여전히 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="a9ead228ce4b44ff6fa9fa633fd85106fce88469" translate="yes" xml:space="preserve">
          <source>Variables that appear in closure environments may themselves be boxed values. As such, they may be split into further closure variables, each of which corresponds to some projection from the original closure variable(s). This transformation is called &lt;em&gt;unboxing of closure variables&lt;/em&gt; or &lt;em&gt;unboxing of free variables of closures&lt;/em&gt;. It is only applied when there is reasonable certainty that there are no uses of the boxed free variable itself within the corresponding function bodies.</source>
          <target state="translated">클로저 환경에 나타나는 변수 자체가 박스형 값일 수 있습니다. 따라서 이들은 추가 클로저 변수로 분할 될 수 있으며, 각 변수는 원래 클로저 변수 (들)의 일부 투영에 해당합니다. 이 변환 &lt;em&gt;을 클로저 변수의 &lt;/em&gt;&lt;em&gt;unboxing&lt;/em&gt; 또는 &lt;em&gt;클로저 &lt;/em&gt;&lt;em&gt;의 자유 변수의 unboxing&lt;/em&gt; 이라고 합니다. 해당 함수 본문 내에서 boxed free 변수 자체를 사용하지 않는다는 합리적인 확신이있을 때만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="94544efd875ca197c0357ce5be422f10d559a990" translate="yes" xml:space="preserve">
          <source>Variance describes how type constructors behave with respect to subtyping. Consider for instance a pair of type x and xy with x a subtype of xy, denoted x :&amp;gt; xy:</source>
          <target state="translated">Variance는 유형 생성자가 하위 유형과 관련하여 작동하는 방식을 설명합니다. 예를 들어 x :&amp;gt; xy로 표시되는 xa 하위 유형이 xy 인 유형 x 및 xy 쌍을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7740708293bab268b6cdccd3b2b3105d72d56eb2" translate="yes" xml:space="preserve">
          <source>Variant values are either a constant constructor, or a non-constant constructor applied to a number of values. The former case is written &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;; the latter case is written &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;(v&lt;sub&gt;1&lt;/sub&gt;, ... ,v&lt;sub&gt;n&lt;/sub&gt;), where the v&lt;sub&gt;i&lt;/sub&gt; are said to be the arguments of the non-constant constructor &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;. The parentheses may be omitted if there is only one argument.</source>
          <target state="translated">변형 값은 상수 생성자이거나 여러 값에 적용되는 상수가 아닌 생성자입니다. 전자의 경우는 &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; 로 작성됩니다 . 후자의 경우는 &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; (v &lt;sub&gt;1&lt;/sub&gt; , ..., v &lt;sub&gt;n&lt;/sub&gt; )로 작성되며, 여기서 v &lt;sub&gt;i&lt;/sub&gt; 는 상수가 아닌 생성자 &lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt; 의 인수라고합니다 . 인수가 하나만있는 경우 괄호를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b6fcc906c8b94204e9f80540ccb736117039b60" translate="yes" xml:space="preserve">
          <source>Variants as presented in section &lt;a href=&quot;coreexamples#s%3Atut-recvariants&quot;&gt;1.4&lt;/a&gt; are a powerful tool to build data structures and algorithms. However they sometimes lack flexibility when used in modular programming. This is due to the fact that every constructor is assigned to a unique type when defined and used. Even if the same name appears in the definition of multiple types, the constructor itself belongs to only one type. Therefore, one cannot decide that a given constructor belongs to multiple types, or consider a value of some type to belong to some other type with more constructors.</source>
          <target state="translated">섹션 &lt;a href=&quot;coreexamples#s%3Atut-recvariants&quot;&gt;1.4에&lt;/a&gt; 제시된 변형은 데이터 구조와 알고리즘을 구축하는 강력한 도구입니다. 그러나 모듈 식 프로그래밍에서 사용할 때 유연성이 부족한 경우가 있습니다. 이는 모든 생성자가 정의되고 사용될 때 고유 한 유형에 할당된다는 사실 때문입니다. 여러 유형의 정의에 동일한 이름이 표시 되더라도 생성자 자체는 하나의 유형에만 속합니다. 따라서 주어진 생성자가 여러 유형에 속한다고 결정하거나 어떤 유형의 값이 더 많은 생성자가있는 다른 유형에 속하는 것으로 간주 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="defd91e4cb9da478b0d364b538e338f44780605a" translate="yes" xml:space="preserve">
          <source>Various characteristics of the OCaml Bigarray can be consulted from C as follows:</source>
          <target state="translated">OCaml Bigarray의 다양한 특성은 다음과 같이 C에서 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1791879f0afda21c77fcdf13351b18a10a048118" translate="yes" xml:space="preserve">
          <source>Verbose mode. Display progress information.</source>
          <target state="translated">상세 모드. 진행 정보를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="fc93f5ac175e4f599a14011e6580fc7cd4bf97ed" translate="yes" xml:space="preserve">
          <source>Virtual instance variables were added in version 3.10.</source>
          <target state="translated">가상 인스턴스 변수는 버전 3.10에서 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="94f10d72f2176232cbf33b9b9b14740de63cf0c9" translate="yes" xml:space="preserve">
          <source>Wait until a non-ignored, non-blocked signal is delivered.</source>
          <target state="translated">무시되지 않고 차단되지 않은 신호가 전달 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="59e26e29aec6b9e363507c3295d1d357f540da00" translate="yes" xml:space="preserve">
          <source>Wait until one of the children processes die, and return its pid and termination status.</source>
          <target state="translated">자식 프로세스 중 하나가 죽을 때까지 기다렸다가 pid 및 종료 상태를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b53c4cd88232ecfc4592008efce859b27539051c" translate="yes" xml:space="preserve">
          <source>Wait until some input/output operations become possible on some channels.</source>
          <target state="translated">일부 채널에서 일부 입력 / 출력 작업이 가능해질 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="c964679793a15053f9bc60ab25124e1cd8f63b1e" translate="yes" xml:space="preserve">
          <source>Wait until some input/output operations become possible on some channels. The three list arguments are, respectively, a set of descriptors to check for reading (first argument), for writing (second argument), or for exceptional conditions (third argument). The fourth argument is the maximal timeout, in seconds; a negative fourth argument means no timeout (unbounded wait). The result is composed of three sets of descriptors: those ready for reading (first component), ready for writing (second component), and over which an exceptional condition is pending (third component).</source>
          <target state="translated">일부 채널에서 일부 입력 / 출력 작업이 가능해질 때까지 기다리십시오. 세 개의 목록 인수는 각각 읽기 (첫 번째 인수), 쓰기 (두 번째 인수) 또는 예외 조건 (세 번째 인수)을 검사 할 설명자 세트입니다. 네 번째 인수는 최대 시간 제한 (초)입니다. 음의 네 번째 인수는 제한 시간이 없음을 의미합니다 (무제한 대기). 결과는 읽기 준비 (첫 번째 구성 요소), 쓰기 준비 (두 번째 구성 요소), 예외 조건이 보류중인 (세 번째 구성 요소)의 세 가지 설명자 세트로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="ccdc343f664af6bf455c146e4304ebf776d509a8" translate="yes" xml:space="preserve">
          <source>Waits until all output written on the given file descriptor has been transmitted.</source>
          <target state="translated">주어진 파일 설명자에 기록 된 모든 출력이 전송 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="9c66db7dd8fa9eda0d7fae5d4287c1b028a58fac" translate="yes" xml:space="preserve">
          <source>Warning 52 is there to prevent users from writing such fragile code in the first place. It does not occur on every matching on a literal string, but only in the case in which library authors expressed their intent to possibly change the constructor parameter value in the future, by using the attribute ocaml.warn_on_literal_pattern (see the manual section on builtin attributes in &lt;a href=&quot;attributes#ss%3Abuiltin-attributes&quot;&gt;8.12.1&lt;/a&gt;):</source>
          <target state="translated">경고 52는 사용자가 애초에 이러한 취약한 코드를 작성하는 것을 방지하기위한 것입니다. 리터럴 문자열의 모든 일치에서 발생하지는 않지만 라이브러리 작성자가 ocaml.warn_on_literal_pattern 속성을 사용하여 향후 생성자 매개 변수 값을 변경하려는 의도를 표현한 경우에만 발생합니다 (내장 속성에 대한 매뉴얼 섹션 참조). 에서 &lt;a href=&quot;attributes#ss%3Abuiltin-attributes&quot;&gt;8.12.1&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="43338ae908e060e4a2fe4ebd54468c1f5df5e18f" translate="yes" xml:space="preserve">
          <source>Warning 57 is dedicated to these confusing cases where the specified left-to-right semantics is not equivalent to a non-deterministic semantics (any branch can be taken) relatively to a specific guard. More precisely, it warns when guard uses &amp;ldquo;ambiguous&amp;rdquo; variables, that are bound to different parts of the scrutinees by different sides of a or-pattern.</source>
          <target state="translated">경고 57은 지정된 왼쪽에서 오른쪽 의미 체계가 특정 가드에 비해 비 결정적 의미 체계 (모든 분기를 사용할 수 있음)와 동일하지 않은 이러한 혼란스러운 경우에 전념합니다. 보다 정확하게는 가드가 or 패턴의 다른면에 의해 스크 루틴의 다른 부분에 바인딩 된 &quot;모호한&quot;변수를 사용할 때 경고합니다.</target>
        </trans-unit>
        <trans-unit id="c6d46ffdf8d66bd8653cdefc4711e1d4925aba59" translate="yes" xml:space="preserve">
          <source>Warning numbers and letters which are out of the range of warnings that are currently defined are ignored. The warnings are as follows.</source>
          <target state="translated">현재 정의 된 경고 범위를 벗어난 경고 번호와 문자는 무시됩니다. 경고는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="206f2d99f775f6c0030d57f5df574102132f9a4e" translate="yes" xml:space="preserve">
          <source>Warning on non-tail calls if @tailcall present.</source>
          <target state="translated">@tailcall이있는 경우 비 꼬리 호출에 대한 경고입니다.</target>
        </trans-unit>
        <trans-unit id="9e4fe3d506423f2f303c88f30c63f1455f72684d" translate="yes" xml:space="preserve">
          <source>Warning: If the output device of the pretty-printer is an output channel, repeated calls to &lt;code&gt;print_flush&lt;/code&gt; means repeated calls to &lt;a href=&quot;stdlib#VALflush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; to flush the out channel; these explicit flush calls could foil the buffering strategy of output channels and could dramatically impact efficiency.</source>
          <target state="translated">경고 : pretty-printer의 출력 장치가 출력 채널 인 경우 &lt;code&gt;print_flush&lt;/code&gt; 에 대한 반복 호출은 출력 채널 을 &lt;a href=&quot;stdlib#VALflush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; 하기 위해 플러시 하는 반복 호출을 의미 합니다. 이러한 명시적인 플러시 호출은 출력 채널의 버퍼링 전략을 방해하고 효율성에 큰 영향을 미칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eeed1a9ddc8faa9785366b5b56daaeea8f4bc85c" translate="yes" xml:space="preserve">
          <source>Warning: marshaling is currently not type-safe. The type of marshaled data is not transmitted along the value of the data, making it impossible to check that the data read back possesses the type expected by the context. In particular, the result type of the &lt;code&gt;Marshal.from_*&lt;/code&gt; functions is given as &lt;code&gt;'a&lt;/code&gt;, but this is misleading: the returned OCaml value does not possess type &lt;code&gt;'a&lt;/code&gt; for all &lt;code&gt;'a&lt;/code&gt;; it has one, unique type which cannot be determined at compile-time. The programmer should explicitly give the expected type of the returned value, using the following syntax:</source>
          <target state="translated">경고 : 마샬링은 현재 형식이 안전하지 않습니다. 마샬링 된 데이터 유형은 데이터 값을 따라 전송되지 않으므로 다시 읽은 데이터가 컨텍스트에서 예상하는 유형을 소유하고 있는지 확인할 수 없습니다. 특히 &lt;code&gt;Marshal.from_*&lt;/code&gt; 함수 의 결과 유형은 &lt;code&gt;'a&lt;/code&gt; '로 제공 되지만 이는 오해의 소지가 있습니다. 반환 된 OCaml 값은 &lt;code&gt;'a&lt;/code&gt; 모두에 대해 &lt;code&gt;'a&lt;/code&gt; ' 유형을 소유하지 않습니다 . 컴파일 타임에 확인할 수없는 하나의 고유 한 유형이 있습니다. 프로그래머는 다음 구문을 사용하여 반환 된 값의 예상 유형을 명시 적으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="10f9837b70f002281732297feca2ee92ad79deed" translate="yes" xml:space="preserve">
          <source>Warning: mixing calls to pretty-printing functions of this module with calls to &lt;a href=&quot;stdlib&quot;&gt;&lt;code&gt;Stdlib&lt;/code&gt;&lt;/a&gt; low level output functions is error prone.</source>
          <target state="translated">경고 :이 모듈의 예쁜 인쇄 기능에 대한 호출과 &lt;a href=&quot;stdlib&quot;&gt; &lt;code&gt;Stdlib&lt;/code&gt; &lt;/a&gt; 저수준 출력 기능에 대한 호출을 혼합 하면 오류가 발생하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="be10b5fa87bfc72a683d87e69c9836c5eec8355c" translate="yes" xml:space="preserve">
          <source>Warning: the threads library is deprecated since version 4.08.0 of OCaml. Please switch to system threads, which have the same API. Lightweight threads with VM-level scheduling are provided by third-party libraries such as Lwt, but with a different API.</source>
          <target state="translated">경고 : 스레드 라이브러리는 OCaml 4.08.0 버전부터 더 이상 사용되지 않습니다. 동일한 API를 가진 시스템 스레드로 전환하십시오. VM 수준 일정을 사용하는 경량 스레드는 Lwt와 같은 타사 라이브러리에서 제공하지만 API는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="461b5545b551a43d233140f163cd94622ad71616" translate="yes" xml:space="preserve">
          <source>We added print_endline &quot;lazy_two evaluation&quot; to see when the lazy expression is being evaluated.</source>
          <target state="translated">lazy 표현식이 평가되는시기를보기 위해 print_endline &quot;lazy_two evaluation&quot;을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="c4f9b808c4ebc7ca886731051c46d1e0b955626c" translate="yes" xml:space="preserve">
          <source>We can also create a different kind of observer:</source>
          <target state="translated">다른 종류의 관찰자를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="19d499139bd909cecce12873700b39b7d51639e5" translate="yes" xml:space="preserve">
          <source>We can also use lazy patterns in pattern matching.</source>
          <target state="translated">패턴 매칭에 게으른 패턴을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="92cc615171f55d614bb69c4999244e87a3b2a6d1" translate="yes" xml:space="preserve">
          <source>We can apply this function to our store</source>
          <target state="translated">이 기능을 우리 가게에 적용 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="66a5f0a9709c52081ad4dfc756d77211d606cc3d" translate="yes" xml:space="preserve">
          <source>We can define a variant of backup that retains all copies. (We also add a method clear to manually erase all copies.)</source>
          <target state="translated">모든 복사본을 유지하는 백업 변형을 정의 할 수 있습니다. (또한 모든 사본을 수동으로 지우는 방법을 추가합니다.)</target>
        </trans-unit>
        <trans-unit id="0c79a613f0ce3961382adb27ff85c38372c8feaa" translate="yes" xml:space="preserve">
          <source>We can then select one implementation based on command-line arguments, for instance:</source>
          <target state="translated">그런 다음 명령 줄 인수를 기반으로 하나의 구현을 선택할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d9fa09b79dd633060d36b6bddacc91dc3a48e89" translate="yes" xml:space="preserve">
          <source>We explain here the rules we applied when labeling OCaml libraries.</source>
          <target state="translated">여기에서는 OCaml 라이브러리에 레이블을 지정할 때 적용한 규칙을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="99916877f63c0d92e57f380f6669743174a88f7e" translate="yes" xml:space="preserve">
          <source>We finish this introduction with a more complete example representative of the use of OCaml for symbolic processing: formal manipulations of arithmetic expressions containing variables. The following variant type describes the expressions we shall manipulate:</source>
          <target state="translated">이 소개는 기호 처리를위한 OCaml 사용을 나타내는보다 완전한 예제로 마무리합니다. 변수를 포함하는 산술 표현식의 형식적인 조작입니다. 다음 변형 유형은 우리가 조작 할 표현식을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d2bbe18b1f9a0ed2104dd3cee9b61a7eda1cf15b" translate="yes" xml:space="preserve">
          <source>We first consider the case of linear patterns, that is the case when all as bound variables are distinct. In &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;as&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;, the type of &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; normally is string (or string option) except when &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt; is a character constant, an underscore, a string constant of length one, a character set specification, or an alternation of those. Then, the type of &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; is char (or char option). Option types are introduced when overall rule matching does not imply matching of the bound sub-pattern. This is in particular the case of (&lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;as&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;)? and of &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;|(&lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;as&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;).</source>
          <target state="translated">먼저 선형 패턴의 경우, 즉 모든 as bound 변수가 구별되는 경우를 고려합니다. 에서는 &lt;a href=&quot;#regexp&quot;&gt;정규식&lt;/a&gt; 같은 &lt;a href=&quot;lex#ident&quot;&gt;식별자&lt;/a&gt; 의 유형 &lt;a href=&quot;lex#ident&quot;&gt;식별자는&lt;/a&gt; 보통 때를 제외 문자열 (또는 문자열 옵션)은 &lt;a href=&quot;#regexp&quot;&gt;정규 표현식은&lt;/a&gt; 문자 상수 밑줄 길이 한 문자 세트 사양, 또는 이들의 교번의 문자열 상수이다. 그런 다음 &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; 유형 은 char (또는 char 옵션)입니다. 전체 규칙 일치가 바인딩 된 하위 패턴의 일치를 의미하지 않는 경우 옵션 유형이 도입됩니다. 이것은 특히 ( &lt;a href=&quot;#regexp&quot;&gt;regexp&lt;/a&gt; as &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; )? 및 &lt;a href=&quot;#regexp&quot;&gt;regexp &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; | ( &lt;a href=&quot;#regexp&quot;&gt;regexp &lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt; as &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="bf6822c23ba1ad8f02365bf80190a034387ff3d1" translate="yes" xml:space="preserve">
          <source>We first define a function to evaluate an expression given an environment that maps variable names to their values. For simplicity, the environment is represented as an association list.</source>
          <target state="translated">먼저 변수 이름을 값에 매핑하는 환경에서 표현식을 평가하는 함수를 정의합니다. 단순화를 위해 환경은 연관 목록으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2c893fa720bf9f99af9ed941bc43778057b94fe9" translate="yes" xml:space="preserve">
          <source>We have provided the &lt;a href=&quot;string#VALinit&quot;&gt;&lt;code&gt;String.init&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;string#VALmap&quot;&gt;&lt;code&gt;String.map&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;string#VALmapi&quot;&gt;&lt;code&gt;String.mapi&lt;/code&gt;&lt;/a&gt; functions to cover most cases of building new strings. You should prefer those over &lt;code&gt;to_string&lt;/code&gt; or &lt;code&gt;unsafe_to_string&lt;/code&gt; whenever applicable.</source>
          <target state="translated">우리는 새 문자열을 만드는 대부분의 경우를 다루기 위해 &lt;a href=&quot;string#VALinit&quot;&gt; &lt;code&gt;String.init&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;string#VALmap&quot;&gt; &lt;code&gt;String.map&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;string#VALmapi&quot;&gt; &lt;code&gt;String.mapi&lt;/code&gt; &lt;/a&gt; 함수를 제공했습니다 . 해당되는 경우 &lt;code&gt;to_string&lt;/code&gt; 또는 &lt;code&gt;unsafe_to_string&lt;/code&gt; 보다 선호해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e997e614ce5467b0beba9472c3d7cf645ca20baa" translate="yes" xml:space="preserve">
          <source>We have seen that points and colored points have incompatible types. For instance, they cannot be mixed in the same list. However, a colored point can be coerced to a point, hiding its color method:</source>
          <target state="translated">포인트와 컬러 포인트에 호환되지 않는 유형이 있음을 확인했습니다. 예를 들어, 동일한 목록에서 혼합 될 수 없습니다. 그러나 컬러 포인트는 포인트로 강제 변환되어 컬러 방법을 숨길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5d1884271f9999c046392d72f34e432867570e1" translate="yes" xml:space="preserve">
          <source>We illustrate inheritance by defining a class of colored points that inherits from the class of points. This class has all instance variables and all methods of class point, plus a new instance variable c and a new method color.</source>
          <target state="translated">포인트 클래스에서 상속되는 컬러 포인트 클래스를 정의하여 상속을 설명합니다. 이 클래스에는 모든 인스턴스 변수와 클래스 포인트의 모든 메서드, 새 인스턴스 변수 c 및 새 메서드 색상이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fe9224c2732ce4c4c3d2e63c6afc04c8cd8c8d9" translate="yes" xml:space="preserve">
          <source>We make the method interest private, since clearly it should not be called freely from the outside. Here, it is only made accessible to subclasses that will manage monthly or yearly updates of the account.</source>
          <target state="translated">우리는이 메서드를 사적인 것으로 만듭니다. 외부에서 자유롭게 호출해서는 안되기 때문입니다. 여기에서는 계정의 월별 또는 연간 업데이트를 관리 할 하위 클래스 만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a05df682a1f6f5e46b800692bc9a4a9b824c3c16" translate="yes" xml:space="preserve">
          <source>We now compile the OCaml code to a C object file and put it in a C library along with the stub code in modwrap.c and the OCaml runtime system:</source>
          <target state="translated">이제 OCaml 코드를 C 객체 파일로 컴파일하고 modwrap.c 및 OCaml 런타임 시스템의 스텁 코드와 함께 C 라이브러리에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="55b0a8c86c819bd589244b573a951c5018c66dc0" translate="yes" xml:space="preserve">
          <source>We now create a new point p, instance of the point class.</source>
          <target state="translated">이제 포인트 클래스의 인스턴스 인 새로운 포인트 p를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0a9e72dd84f2e2a1bac4efce2a171cca7af32b7f" translate="yes" xml:space="preserve">
          <source>We now give the GC rules corresponding to the low-level allocation functions caml_alloc_small and caml_alloc_shr. You can ignore those rules if you stick to the simplified allocation function caml_alloc.</source>
          <target state="translated">이제 하위 수준 할당 함수 인 caml_alloc_small 및 caml_alloc_shr에 해당하는 GC 규칙을 제공합니다. 단순화 된 할당 함수 caml_alloc을 고수하면 이러한 규칙을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dde80a3e10aa85c712afe16ab7e2341a6c678052" translate="yes" xml:space="preserve">
          <source>We now invoke some methods of p:</source>
          <target state="translated">이제 p의 몇 가지 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="eddf36c907f6ba061639dec7abaa73a666215441" translate="yes" xml:space="preserve">
          <source>We now refine this definition with a method to compute interest.</source>
          <target state="translated">이제 우리는이자를 계산하는 방법으로이 정의를 구체화합니다.</target>
        </trans-unit>
        <trans-unit id="f74647a14e3ed593ca08170fabed6ef0ef7ebd98" translate="yes" xml:space="preserve">
          <source>We said earlier that all OCaml objects are represented by the C type value, and one has to use macros such as Int_val to decode data from the value type. It is however possible to tell the OCaml native-code compiler to do this for us and pass arguments unboxed to the C function. Similarly it is possible to tell OCaml to expect the result unboxed and box it for us.</source>
          <target state="translated">우리는 모든 OCaml 객체가 C 유형 값으로 표현되고 Int_val과 같은 매크로를 사용하여 값 유형에서 데이터를 디코딩해야한다고 이전에 말했습니다. 그러나 OCaml 네이티브 코드 컴파일러에게이 작업을 수행하도록 지시하고 C 함수에 unboxed 인수를 전달할 수 있습니다. 마찬가지로 OCaml에게 결과를 unboxed라고 예상하고 boxing하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bca3f24bc60b155d0819792bfa9331ce581c464f" translate="yes" xml:space="preserve">
          <source>We should soon fix a bug in the current definition: the deposit method can be used for withdrawing money by depositing negative amounts. We can fix this directly:</source>
          <target state="translated">곧 현재 정의의 버그를 수정해야합니다. 예치 방법은 마이너스 금액을 입금하여 돈을 인출하는 데 사용할 수 있습니다. 이 문제를 직접 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18a0580da590e6d18812e52fcb9d241d72eb30f8" translate="yes" xml:space="preserve">
          <source>We strongly recommend that you port your code to use the standard library version instead, as the changes required are minimal.</source>
          <target state="translated">필요한 변경 사항이 최소화되므로 표준 라이브러리 버전을 대신 사용하도록 코드를 이식하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b76922aca83aea453c196313c75e6f82cdc85b43" translate="yes" xml:space="preserve">
          <source>We then define a subclass money of comparable. The class money simply wraps floats as comparable objects. We will extend it below with more operations. We have to use a type constraint on the class parameter x because the primitive &amp;lt;= is a polymorphic function in OCaml. The inherit clause ensures that the type of objects of this class is an instance of #comparable.</source>
          <target state="translated">그런 다음 비교 가능한 하위 클래스 돈을 정의합니다. 클래스 돈은 단순히 수레를 비슷한 물건으로 감싼다. 더 많은 작업을 통해 아래에서 확장 할 것입니다. 프리미티브 &amp;lt;=는 OCaml의 다형성 함수이기 때문에 클래스 매개 변수 x에 유형 제약 조건을 사용해야합니다. inherit 절은이 클래스의 객체 유형이 #comparable의 인스턴스인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="a09f642369ffeb1d47d15e3a190a4aa7660841b9" translate="yes" xml:space="preserve">
          <source>We then recover polymorphism:</source>
          <target state="translated">그런 다음 다형성을 복구합니다.</target>
        </trans-unit>
        <trans-unit id="df96e9f187249271f3cc2c30ce856d1def153907" translate="yes" xml:space="preserve">
          <source>We use lazy (expr) to delay the evaluation of some expression expr. For example, we can defer the computation of 1+1 until we need the result of that expression, 2. Let us see how we initialize a lazy expression.</source>
          <target state="translated">lazy (expr)를 사용하여 일부 표현식 expr의 평가를 지연합니다. 예를 들어, 그 표현식 2의 결과가 필요할 때까지 1 + 1의 계산을 연기 할 수 있습니다. 지연 표현식을 초기화하는 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="b8138516fe760085bbe99cc7f9cac0b5a490449c" translate="yes" xml:space="preserve">
          <source>We want to bind the function getenv in a way that works both under Unix and Windows. Under Unix this function has the prototype:</source>
          <target state="translated">우리는 Unix와 Windows 모두에서 작동하는 방식으로 getenv 함수를 바인딩하려고합니다. Unix에서이 함수에는 프로토 타입이 있습니다.</target>
        </trans-unit>
        <trans-unit id="54d6d8214460953d9bf3607daeaf4f2e1dcf6dfd" translate="yes" xml:space="preserve">
          <source>We will not try here to explain in detail how type inference works. One must just understand that there is not enough information in the above program to deduce the correct type of g or bump. That is, there is no way to know whether an argument is optional or not, or which is the correct order, by looking only at how a function is applied. The strategy used by the compiler is to assume that there are no optional arguments, and that applications are done in the right order.</source>
          <target state="translated">여기서는 타입 추론이 어떻게 작동하는지 자세히 설명하지 않을 것입니다. 위의 프로그램에는 올바른 유형의 g 또는 범프를 추론하기에 충분한 정보가 없다는 것을 이해해야합니다. 즉, 함수가 적용되는 방식 만보고 인수가 선택 사항인지 아닌지 또는 올바른 순서인지 알 수있는 방법이 없습니다. 컴파일러에서 사용하는 전략은 선택적 인수가없고 응용 프로그램이 올바른 순서로 수행된다고 가정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8bfada821419f7b1c35da6470b04b8c1b0c72d91" translate="yes" xml:space="preserve">
          <source>Weak</source>
          <target state="translated">Weak</target>
        </trans-unit>
        <trans-unit id="d22283d948c9488ada65248c6645510b567f8a49" translate="yes" xml:space="preserve">
          <source>Weak arrays cannot be marshaled using &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt; nor the functions of the &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">약한 배열은 &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt; &lt;code&gt;output_value&lt;/code&gt; &lt;/a&gt; 나 &lt;a href=&quot;marshal&quot;&gt; &lt;code&gt;Marshal&lt;/code&gt; &lt;/a&gt; 모듈 의 함수를 사용하여 마샬링 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="72045a1c4a2a8b8f303cdae651cfaef5a76eca1e" translate="yes" xml:space="preserve">
          <source>Weak hash sets</source>
          <target state="translated">약한 해시 세트</target>
        </trans-unit>
        <trans-unit id="2e14058b3fbf260f23ab0c6884c945aa8da01d1a" translate="yes" xml:space="preserve">
          <source>What happens when a process tries to lock a region of a file that is already locked by the same process depends on the OS. On POSIX-compliant systems, the second lock operation succeeds and may &quot;promote&quot; the older lock from read lock to write lock. On Windows, the second lock operation will block or fail.</source>
          <target state="translated">프로세스가 동일한 프로세스에 의해 이미 잠긴 파일 영역을 잠그려고 할 때 발생하는 일은 OS에 따라 다릅니다. POSIX 호환 시스템에서 두 번째 잠금 작업이 성공하고 읽기 잠금에서 쓰기 잠금으로 이전 잠금을 &quot;승격&quot;할 수 있습니다. Windows에서는 두 번째 잠금 작업이 차단되거나 실패합니다.</target>
        </trans-unit>
        <trans-unit id="0988be2bfd0c6854f41080dea8b6f91bf9a1370d" translate="yes" xml:space="preserve">
          <source>What to do when receiving a signal:</source>
          <target state="translated">신호 수신시해야 할 일 :</target>
        </trans-unit>
        <trans-unit id="26c21717a7fc138d58564167fcb6dd12bbcbe404" translate="yes" xml:space="preserve">
          <source>What to do when receiving a signal: &lt;code&gt;Signal_default&lt;/code&gt;: take the default behavior (usually: abort the program), &lt;code&gt;Signal_ignore&lt;/code&gt;: ignore the signal, &lt;code&gt;Signal_handle&amp;nbsp;f&lt;/code&gt;: call function &lt;code&gt;f&lt;/code&gt;, giving it the signal number as argument.</source>
          <target state="translated">신호 수신시해야 할 일 : &lt;code&gt;Signal_default&lt;/code&gt; : 기본 동작 (보통 : 프로그램 중단), &lt;code&gt;Signal_ignore&lt;/code&gt; : 신호 무시, &lt;code&gt;Signal_handle&amp;nbsp;f&lt;/code&gt; : 함수 &lt;code&gt;f&lt;/code&gt; 호출 , 신호 번호를 인수로 제공.</target>
        </trans-unit>
        <trans-unit id="e013f727f75893e8217087a1af3c906ca342fa52" translate="yes" xml:space="preserve">
          <source>When -O2 is specified two rounds of optimisation are performed. The first round uses the default parameters (see above). The second uses the following parameters.</source>
          <target state="translated">-O2가 지정되면 두 번의 최적화가 수행됩니다. 첫 번째 라운드는 기본 매개 변수를 사용합니다 (위 참조). 두 번째는 다음 매개 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bcf8e597524e8aee8c13ef1751d22f48ce086204" translate="yes" xml:space="preserve">
          <source>When -O3 is specified three rounds of optimisation are performed. The first two rounds are as for -O2. The third round uses the following parameters.</source>
          <target state="translated">-O3이 지정되면 세 번의 최적화가 수행됩니다. 처음 두 라운드는 -O2와 같습니다. 세 번째 라운드는 다음 매개 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a51e2474b26cb6aa186686913f31b780794afaba" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to a class body, new&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to a new object containing the instance variables and methods of this class.</source>
          <target state="translated">&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; 가 클래스 본문으로 평가 될 때 새 &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; 는이 클래스의 인스턴스 변수 및 메서드를 포함하는 새 개체 로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="6b82cf9cee86acdbc64dbbf0fb149429ecccc72a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to a class function, new&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; evaluates to a function expecting the same number of arguments and returning a new object of this class.</source>
          <target state="translated">&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; 가 클래스 함수 로 평가 될 때 , new &lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt; 는 동일한 수의 인수를 예상하고이 클래스의 새 객체를 반환하는 함수 로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="b7ac323c3ecca6b336d0c993fce513966e3c8814" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;1&amp;nbsp;&amp;lt;&amp;nbsp;max_indent&amp;nbsp;&amp;lt;&amp;nbsp;margin&lt;/code&gt;, &lt;code&gt;pp_set_geometry&amp;nbsp;ppf&amp;nbsp;~max_indent&amp;nbsp;~margin&lt;/code&gt; is equivalent to &lt;code&gt;pp_set_margin&amp;nbsp;ppf&amp;nbsp;margin;&amp;nbsp;pp_set_max_indent&amp;nbsp;ppf&amp;nbsp;max_indent&lt;/code&gt;; and avoids the subtly incorrect &lt;code&gt;pp_set_max_indent&amp;nbsp;ppf&amp;nbsp;max_indent;&amp;nbsp;pp_set_margin&amp;nbsp;ppf&amp;nbsp;margin&lt;/code&gt;;</source>
          <target state="translated">경우 &lt;code&gt;1&amp;nbsp;&amp;lt;&amp;nbsp;max_indent&amp;nbsp;&amp;lt;&amp;nbsp;margin&lt;/code&gt; , &lt;code&gt;pp_set_geometry&amp;nbsp;ppf&amp;nbsp;~max_indent&amp;nbsp;~margin&lt;/code&gt; 에 상당 &lt;code&gt;pp_set_margin&amp;nbsp;ppf&amp;nbsp;margin;&amp;nbsp;pp_set_max_indent&amp;nbsp;ppf&amp;nbsp;max_indent&lt;/code&gt; ; 미묘하게 잘못된 &lt;code&gt;pp_set_max_indent&amp;nbsp;ppf&amp;nbsp;max_indent;&amp;nbsp;pp_set_margin&amp;nbsp;ppf&amp;nbsp;margin&lt;/code&gt; 피합니다 . pp_set_margin ppf 여백 ;</target>
        </trans-unit>
        <trans-unit id="e28129a04e7cd0c48e2322610116e87d33bc4f9d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Array.sort&lt;/code&gt; returns, &lt;code&gt;a&lt;/code&gt; contains the same elements as before, reordered in such a way that for all i and j valid indices of &lt;code&gt;a&lt;/code&gt; :</source>
          <target state="translated">경우 &lt;code&gt;Array.sort&lt;/code&gt; 복귀, &lt;code&gt;a&lt;/code&gt; 이전과 동일한 요소를 포함하는 이러한 방식으로 재정렬이 모든 i와 j 유효 인덱스 용 : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="56bdfe21627fc64c618784351aca6192eaa2423d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;sort&lt;/code&gt; returns, &lt;code&gt;a&lt;/code&gt; contains the same elements as before, reordered in such a way that for all i and j valid indices of &lt;code&gt;a&lt;/code&gt; :</source>
          <target state="translated">때 &lt;code&gt;sort&lt;/code&gt; 반환, &lt;code&gt;a&lt;/code&gt; 이전과 같은 요소를 포함, 같은 방식으로 다시 정렬이 모든 i와 j 유효한 인덱스에 대한 : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4a1feca9d22707497e3af035ccb842d458f8e939" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;with_positions&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, lexer actions should not modify position fields. Doing it nevertheless could re-enable the &lt;code&gt;with_position&lt;/code&gt; mode and degrade performances.</source>
          <target state="translated">때 &lt;code&gt;with_positions&lt;/code&gt; 이 있습니다 &lt;code&gt;false&lt;/code&gt; , 렉서 작업 위치 필드를 수정해서는 안됩니다. 그럼에도 불구하고이를 수행하면 &lt;code&gt;with_position&lt;/code&gt; 모드 가 다시 활성화되고 성능이 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e1130d10406644bd2995a03b20217aafac1d7c0" translate="yes" xml:space="preserve">
          <source>When OCaml bytecode produced by ocamlc -g is embedded in a C program, no debugging information is included, and therefore it is impossible to print stack backtraces on uncaught exceptions. This is not the case when native code produced by ocamlopt -g is embedded in a C program: stack backtrace information is available, but the backtrace mechanism needs to be turned on programmatically. This can be achieved from the OCaml side by calling Printexc.record_backtrace true in the initialization of one of the OCaml modules. This can also be achieved from the C side by calling caml_record_backtrace(Val_int(1)); in the OCaml-C glue code.</source>
          <target state="translated">ocamlc -g에 의해 생성 된 OCaml 바이트 코드가 C 프로그램에 포함되면 디버깅 정보가 포함되지 않으므로 포착되지 않은 예외에 대한 스택 역 추적을 인쇄 할 수 없습니다. 이것은 ocamlopt -g에 의해 생성 된 네이티브 코드가 C 프로그램에 포함 된 경우가 아닙니다. 스택 역 추적 정보를 사용할 수 있지만 역 추적 메커니즘을 프로그래밍 방식으로 켜야합니다. OCaml 모듈 중 하나의 초기화에서 Printexc.record_backtrace true를 호출하여 OCaml 측에서이를 수행 할 수 있습니다. 이것은 caml_record_backtrace (Val_int (1))를 호출하여 C 측에서 수행 할 수도 있습니다. OCaml-C 글루 코드에서.</target>
        </trans-unit>
        <trans-unit id="a34f78824091c7508d92682b1802b558ea0fa5f7" translate="yes" xml:space="preserve">
          <source>When OCaml calls the C code implementing a primitive, the master lock is held, therefore the C code has full access to the facilities of the run-time system. However, no other thread can execute OCaml code concurrently with the C code of the primitive.</source>
          <target state="translated">OCaml이 프리미티브를 구현하는 C 코드를 호출하면 마스터 잠금이 유지되므로 C 코드는 런타임 시스템의 기능에 대한 전체 액세스 권한을 갖습니다. 그러나 다른 스레드는 프리미티브의 C 코드와 동시에 OCaml 코드를 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="731df544ab2a9ec7204d741cd8c2456b1fe24993" translate="yes" xml:space="preserve">
          <source>When a function is passed as an argument to a higher-order function, labels must match in both types. Neither adding nor removing labels are allowed.</source>
          <target state="translated">함수가 고차 함수에 인수로 전달되면 레이블이 두 유형 모두에서 일치해야합니다. 라벨을 추가하거나 제거 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8dec26d8a7e9ea065435190bd81832097f83991b" translate="yes" xml:space="preserve">
          <source>When a recursive call to a function (within the definition of that function or another in the same mutually-recursive group) is inlined, the procedure is also known as &lt;em&gt;unrolling&lt;/em&gt;. This is somewhat akin to loop peeling. For example, given the following code:</source>
          <target state="translated">함수에 대한 재귀 호출 (해당 함수 또는 동일한 상호 재귀 그룹의 다른 정의 내에서)이 인라인되면 프로 시저를 &lt;em&gt;unrolling&lt;/em&gt; 이라고도합니다 . 이것은 루프 필링과 다소 유사합니다. 예를 들어, 다음 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8c166cb381f772c894053718af4cc540b7764c1" translate="yes" xml:space="preserve">
          <source>When a shift/reduce conflict cannot be resolved using the above method, then ocamlyacc will output a warning and the parser will always shift.</source>
          <target state="translated">위의 방법을 사용하여 시프트 / 리 듀스 충돌을 해결할 수없는 경우 ocamlyacc는 경고를 출력하고 파서는 항상 시프트합니다.</target>
        </trans-unit>
        <trans-unit id="27c9efd30cc98ee4407de08fe91f7e2b81b5c1a5" translate="yes" xml:space="preserve">
          <source>When a type is unboxable (i.e. a record with a single argument or a concrete datatype with a single constructor of one argument) it will be unboxed unless annotated with [@@ocaml.boxed].</source>
          <target state="translated">유형이 unboxable 인 경우 (즉, 단일 인수가있는 레코드 또는 단일 생성자가 하나의 인수를 가진 구체적인 데이터 유형) [@@ ocaml.boxed]로 주석을 달지 않는 한 unboxed됩니다.</target>
        </trans-unit>
        <trans-unit id="683b509729033268c58f4450cd64b5d3d02b55b7" translate="yes" xml:space="preserve">
          <source>When a type is unboxable it will be boxed unless annotated with [@@ocaml.unboxed]. This is the default.</source>
          <target state="translated">유형이 unboxable 인 경우 [@@ ocaml.unboxed]로 주석을 달지 않는 한 boxing됩니다. 이것이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="326b5be3859c652fd4f119fc5dd900a23ee51ed0" translate="yes" xml:space="preserve">
          <source>When a type is visible under several module-paths, use the shortest one when printing the type&amp;rsquo;s name in inferred interfaces and error and warning messages. Identifier names starting with an underscore _ or containing double underscores __ incur a penalty of +10 when computing their length.</source>
          <target state="translated">유형이 여러 모듈 경로 아래에 표시되면 추론 된 인터페이스와 오류 및 경고 메시지에 유형 이름을 인쇄 할 때 가장 짧은 것을 사용하십시오. 밑줄 _로 시작하거나 이중 밑줄 __을 포함하는 식별자 이름은 길이를 계산할 때 +10의 패널티를받습니다.</target>
        </trans-unit>
        <trans-unit id="c41d0dc17088def45b04aa6a11a3b3a215c0e87e" translate="yes" xml:space="preserve">
          <source>When an or-pattern composed of variant tags is wrapped inside an alias-pattern, the alias is given a type containing only the tags enumerated in the or-pattern. This allows for many useful idioms, like incremental definition of functions.</source>
          <target state="translated">변형 태그로 구성된 or 패턴이 alias-pattern 안에 래핑되면 별칭에는 or- 패턴에 열거 된 태그 만 포함 된 유형이 지정됩니다. 이것은 함수의 점진적 정의와 같은 많은 유용한 관용구를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="92b38d80c97fd5053b560c8766f83a7af6d7bbf2" translate="yes" xml:space="preserve">
          <source>When appearing in a module signature, this definition specifies nothing on the type constructor, besides its number of parameters: its representation is hidden and it is assumed incompatible with any other type.</source>
          <target state="translated">모듈 서명에 나타날 때이 정의는 매개 변수 수 외에 형식 생성자에 아무것도 지정하지 않습니다. 해당 표현은 숨겨져 있으며 다른 형식과 호환되지 않는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="690e2c95aca5c0bc8bb37466d7f1bfe8a47ce028" translate="yes" xml:space="preserve">
          <source>When both sides of the = sign are the same, it is possible to avoid repeating the field name by eliding the =field part:</source>
          <target state="translated">= 기호의 양쪽이 동일하면 = field 부분을 제거하여 필드 이름이 반복되는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce9a1d592aa8045ca5f8c840dfe01b1a0d44dcfb" translate="yes" xml:space="preserve">
          <source>When converting an exception into a string, the printers will be invoked in the reverse order of their registrations, until a printer returns a &lt;code&gt;Some&amp;nbsp;s&lt;/code&gt; value (if no such printer exists, the runtime will use a generic printer).</source>
          <target state="translated">예외를 문자열로 변환 할 때 프린터가 &lt;code&gt;Some&amp;nbsp;s&lt;/code&gt; 값을 반환 할 때까지 등록의 역순으로 프린터가 호출됩니다 (해당 프린터가없는 경우 런타임은 일반 프린터를 사용합니다).</target>
        </trans-unit>
        <trans-unit id="034158012eb7ccfe68c6898fd0ac8e5a62c3f38e" translate="yes" xml:space="preserve">
          <source>When exceptions are used as a control structure, it can be useful to make them as local as possible by using a locally defined exception. For instance, with</source>
          <target state="translated">예외가 제어 구조로 사용되는 경우 로컬로 정의 된 예외를 사용하여 가능한 한 로컬로 만드는 것이 유용 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="1077be7d93082bb39e5870bf19a2eea51954852c" translate="yes" xml:space="preserve">
          <source>When in -Oclassic mode, -inline behaves as in previous versions of the compiler: it is the maximum size of function to be considered for inlining. See section &lt;a href=&quot;#ss%3Aflambda-classic&quot;&gt;21.3.1&lt;/a&gt;.</source>
          <target state="translated">-Oclassic 모드에서 -inline은 컴파일러의 이전 버전에서와 같이 작동합니다. 인라인을 위해 고려할 함수의 최대 크기입니다. 섹션 &lt;a href=&quot;#ss%3Aflambda-classic&quot;&gt;21.3.1을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="492ff2355909728e85c6f2a21a225e71b2f44177" translate="yes" xml:space="preserve">
          <source>When linking .cmalibraries, ignore -custom, -cclib and -ccopt options potentially contained in the libraries (if these options were given when building the libraries). This can be useful if a library contains incorrect specifications of C libraries or C options; in this case, during linking, set -noautolink and pass the correct C libraries and options on the command line.</source>
          <target state="translated">.cmalibraries를 링크 할 때 잠재적으로 라이브러리에 포함 된 -custom, -cclib 및 -ccopt 옵션을 무시하십시오 (라이브러리를 빌드 할 때 이러한 옵션이 제공된 경우). 이는 라이브러리에 C 라이브러리 또는 C 옵션의 잘못된 사양이 포함 된 경우 유용 할 수 있습니다. 이 경우 링크하는 동안 -noautolink를 설정하고 명령 줄에서 올바른 C 라이브러리와 옵션을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="7b9d6d9ab3ba56bf035a511bd9d449eca44727f4" translate="yes" xml:space="preserve">
          <source>When linking .cmxalibraries, ignore -cclib and -ccopt options potentially contained in the libraries (if these options were given when building the libraries). This can be useful if a library contains incorrect specifications of C libraries or C options; in this case, during linking, set -noautolink and pass the correct C libraries and options on the command line.</source>
          <target state="translated">.cmxalibraries를 링크 할 때 잠재적으로 라이브러리에 포함 된 -cclib 및 -ccopt 옵션을 무시하십시오 (라이브러리를 빌드 할 때 이러한 옵션이 제공된 경우). 이는 라이브러리에 C 라이브러리 또는 C 옵션의 잘못된 사양이 포함 된 경우 유용 할 수 있습니다. 이 경우 링크하는 동안 -noautolink를 설정하고 명령 줄에서 올바른 C 라이브러리와 옵션을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="2b73d8b95c745a7e82f1c332d3753eddb94d728d" translate="yes" xml:space="preserve">
          <source>When not in -Oclassic mode, -inline limits the total size of functions considered for inlining during any speculative inlining search. (See section &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt;.) Note that this parameter does not control the assessment as to whether any particular function may be inlined. Raising it to excessive amounts will not necessarily cause more functions to be inlined.</source>
          <target state="translated">-Oclassic 모드가 아닌 경우 -inline은 예측 인라인 검색 중에 인라인을 위해 고려되는 함수의 총 크기를 제한합니다. (섹션 &lt;a href=&quot;#ss%3Aflambda-speculation&quot;&gt;21.3.6&lt;/a&gt; 참조 )이 매개 변수는 특정 기능이 인라인 될 수 있는지 여부에 대한 평가를 제어하지 않습니다. 과도한 양으로 늘리면 반드시 더 많은 함수가 인라인되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f386ef166191d4de341a91dd5a815dc5eed34230" translate="yes" xml:space="preserve">
          <source>When opening a semantic tag with name &lt;code&gt;t&lt;/code&gt;, the string &lt;code&gt;t&lt;/code&gt; is passed to the opening tag-marking function (the &lt;code&gt;mark_open_stag&lt;/code&gt; field of the record &lt;code&gt;tag_funs&lt;/code&gt;), that must return the opening tag marker for that name. When the next call to &lt;code&gt;close_stag&amp;nbsp;()&lt;/code&gt; happens, the semantic tag name &lt;code&gt;t&lt;/code&gt; is sent back to the closing tag-marking function (the &lt;code&gt;mark_close_stag&lt;/code&gt; field of record &lt;code&gt;tag_funs&lt;/code&gt;), that must return a closing tag marker for that name.</source>
          <target state="translated">이름으로 의미 론적 태그를 열면 &lt;code&gt;t&lt;/code&gt; , 문자열 &lt;code&gt;t&lt;/code&gt; 는 시작 태그 마킹 기능 (받는 전달 &lt;code&gt;mark_open_stag&lt;/code&gt; 의 기록 필드 &lt;code&gt;tag_funs&lt;/code&gt; ), 즉 해당 이름을 시작 태그 마커를 반환해야한다. 에 대한 다음 호출 할 때 &lt;code&gt;close_stag&amp;nbsp;()&lt;/code&gt; 발생, 의미 론적 태그 이름의 &lt;code&gt;t&lt;/code&gt; 가 다시 닫는 태그 표시 기능 (받는 전송 &lt;code&gt;mark_close_stag&lt;/code&gt; 의 기록 필드 &lt;code&gt;tag_funs&lt;/code&gt; ), 그 해당 이름을 닫는 태그 마커를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="5f6a70f9cbe6b81b3df98290d76833a41a28f8d6" translate="yes" xml:space="preserve">
          <source>When pattern matching on records, it can be useful to match only few fields of a record. Eliding fields can be done either implicitly or explicitly by ending the record pattern with ; _. However, implicit field elision is at odd with pattern matching exhaustiveness checks. Enabling warning 9 prioritizes exhaustiveness checks over the convenience of implicit field elision and will warn on implicit field elision in record patterns. In particular, this warning can help to spot exhaustive record pattern that may need to be updated after the addition of new fields to a record type.</source>
          <target state="translated">레코드에서 패턴 일치를 수행 할 때 레코드의 일부 필드 만 일치시키는 것이 유용 할 수 있습니다. 필드 생략은 레코드 패턴을;로 종료하여 내재적으로 또는 명시 적으로 수행 할 수 있습니다. _. 그러나 암시 적 필드 제거는 완전성 검사와 일치하는 패턴과 일치하지 않습니다. 경고 9를 활성화하면 암시 적 필드 제거의 편의성보다 철저한 검사에 우선 순위를두고 레코드 패턴에서 암시 적 필드 제거에 대해 경고합니다. 특히이 경고는 레코드 유형에 새 필드를 추가 한 후 업데이트해야 할 수있는 철저한 레코드 패턴을 찾는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76609a8a49e03dd9fd02fa1bebd9c6296cdf2d26" translate="yes" xml:space="preserve">
          <source>When printing a complex expression, a name of the form $integer is automatically assigned to its value. Such names are also assigned to parts of the value that cannot be printed because the maximal printing depth is exceeded. Named values can be printed later on with the commands p $integer or d $integer. Named values are valid only as long as the program is stopped. They are forgotten as soon as the program resumes execution.</source>
          <target state="translated">복잡한 표현식을 인쇄 할 때 $ integer 형식의 이름이 해당 값에 자동으로 할당됩니다. 이러한 이름은 최대 인쇄 깊이를 초과하여 인쇄 할 수없는 값의 부분에도 지정됩니다. 명명 된 값은 나중에 p $ integer 또는 d $ integer 명령을 사용하여 인쇄 할 수 있습니다. 명명 된 값은 프로그램이 중지 된 동안에 만 유효합니다. 프로그램이 실행을 재개하자마자 잊혀집니다.</target>
        </trans-unit>
        <trans-unit id="3d31cc3eb55d7e0d6628001e85e93e466eecc068" translate="yes" xml:space="preserve">
          <source>When printing error messages, the toplevel system attempts to underline visually the location of the error. It consults the TERM variable to determines the type of output terminal and look up its capabilities in the terminal database.</source>
          <target state="translated">오류 메시지를 인쇄 할 때 최상위 시스템은 오류 위치에 시각적으로 밑줄을 긋습니다. TERM 변수를 참조하여 출력 터미널의 유형을 결정하고 터미널 데이터베이스에서 해당 기능을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="90d7dd40d4664a834488e3a90e05acacdcd71cbb" translate="yes" xml:space="preserve">
          <source>When printing string values, non-ascii bytes ( &amp;gt; \0x7E ) are printed as decimal escape sequence if OCAMLTOP_UTF_8 is set to false. Otherwise, they are printed unescaped.</source>
          <target state="translated">문자열 값을 인쇄 할 때 OCAMLTOP_UTF_8이 false로 설정된 경우 ASCII가 아닌 바이트 (&amp;gt; \ 0x7E)가 10 진수 이스케이프 시퀀스로 인쇄됩니다. 그렇지 않으면 이스케이프 처리되지 않은 상태로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="3c3624360ff971981bc315fd47d2593c900214b5" translate="yes" xml:space="preserve">
          <source>When scanning needs one more character, the given function is called.</source>
          <target state="translated">스캔에 문자가 하나 더 필요하면 주어진 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="513b6eef346373892dc63825b86c73cd321a24ef" translate="yes" xml:space="preserve">
          <source>When speculation starts the inlining threshold starts at the value set by -inline (or -inline-toplevel if appropriate, see above). Upon making a speculative inlining decision the threshold is reduced by the code size of the function being inlined. If the threshold becomes exhausted, at or below zero, no further speculation will be performed.</source>
          <target state="translated">추측이 시작되면 인라인 임계 값은 -inline (또는 해당되는 경우 -inline-toplevel, 위 참조)에 의해 설정된 값에서 시작됩니다. 추측적인 인라인 결정을 내리면 인라인되는 함수의 코드 크기에 따라 임계 값이 감소합니다. 임계 값이 소진되면 0 또는 그 이하로 추론되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d2861d14369b79117e494b17a13e3c456dfe6e4" translate="yes" xml:space="preserve">
          <source>When symbolic links are created to existing targets, this distinction doesn't matter and &lt;code&gt;symlink&lt;/code&gt; will automatically create the correct kind of symbolic link. The distinction matters when a symbolic link is created to a non-existent target.</source>
          <target state="translated">심볼릭 링크가 기존 타겟에 생성되면이 구분은 중요하지 않으며 &lt;code&gt;symlink&lt;/code&gt; 는 자동으로 올바른 종류의 심볼릭 링크를 생성합니다. 존재하지 않는 대상에 대한 심볼릭 링크가 생성 될 때 구별이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="6c6a9ec1d0aaddbdc02b4a3efa6219fe94407366" translate="yes" xml:space="preserve">
          <source>When the body of a local open expression is delimited by [], [||], or {}, the parentheses can be omitted. For expression, parentheses can also be omitted for {&amp;lt;&amp;gt;}. For example, &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.[&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;] is equivalent to &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.([&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;]), and &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.[|&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;|] is equivalent to &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.([|&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;|]).</source>
          <target state="translated">로컬 열기 표현식의 본문이 [], [||] 또는 {}로 구분되는 경우 괄호를 생략 할 수 있습니다. 표현식의 경우 {&amp;lt;&amp;gt;}에 대해 괄호를 생략 할 수도 있습니다. 예를 들어, &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; . [ &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; ]은 &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; . ([ &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; ]) 및 &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; . [| &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; |]은 &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; . ([| &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; |])와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="060d48655d567b2d042c60f8b5fbed496d586590" translate="yes" xml:space="preserve">
          <source>When the body of a local open pattern is delimited by [], [||], or {}, the parentheses can be omitted. For example, &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.[&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;] is equivalent to &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.([&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;]), and &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.[|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;|] is equivalent to &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;.([|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;|]).</source>
          <target state="translated">로컬 열기 패턴의 본문이 [], [||] 또는 {}로 구분되는 경우 괄호를 생략 할 수 있습니다. 예를 들어, &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; . [ &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; ]은 &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; . ([ &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; ]) 및 &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; . [| &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; |]은 &lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt; . ([| &lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; |])와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="29adbac74a25822a7bfb536a7de8866290251fde" translate="yes" xml:space="preserve">
          <source>When the compiler encounters a reference to a free module identifier Mod, it looks in the search path for a file named Mod.cmi or mod.cmi and loads the compiled interface contained in that file. As a consequence, renaming .cmi files is not advised: the name of a .cmi file must always correspond to the name of the compilation unit it implements. It is admissible to move them to another directory, if their base name is preserved, and the correct -I options are given to the compiler. The compiler will flag an error if it loads a .cmi file that has been renamed.</source>
          <target state="translated">컴파일러가 사용 가능한 모듈 식별자 Mod에 대한 참조를 발견하면 Mod.cmi 또는 mod.cmi라는 파일의 검색 경로를 찾고 해당 파일에 포함 된 컴파일 된 인터페이스를로드합니다. 따라서 .cmi 파일의 이름을 바꾸는 것은 권장되지 않습니다. .cmi 파일의 이름은 항상 구현하는 컴파일 단위의 이름과 일치해야합니다. 기본 이름이 유지되고 올바른 -I 옵션이 컴파일러에 제공되면 다른 디렉토리로 이동할 수 있습니다. 컴파일러는 이름이 변경된 .cmi 파일을로드하는 경우 오류 플래그를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="504fc87ac9efbf21d3ea36072e2cab3a4f1c5a34" translate="yes" xml:space="preserve">
          <source>When the compiler flag -no-alias-deps is enabled, type-level module aliases are also exploited to avoid introducing dependencies between compilation units. Namely, a module alias referring to a module inside another compilation unit does not introduce a link-time dependency on that compilation unit, as long as it is not dereferenced; it still introduces a compile-time dependency if the interface needs to be read, &lt;em&gt;i.e.&lt;/em&gt; if the module is a submodule of the compilation unit, or if some type components are referred to. Additionally, accessing a module alias introduces a link-time dependency on the compilation unit containing the module referenced by the alias, rather than the compilation unit containing the alias. Note that these differences in link-time behavior may be incompatible with the previous behavior, as some compilation units might not be extracted from libraries, and their side-effects ignored.</source>
          <target state="translated">컴파일러 플래그 -no-alias-deps가 활성화되면 컴파일 단위간에 종속성이 도입되는 것을 방지하기 위해 유형 수준 모듈 별칭도 악용됩니다. 즉, 다른 컴파일 단위 내부의 모듈을 참조하는 모듈 별칭은 역 참조되지 않는 한 해당 컴파일 단위에 대한 링크 시간 종속성을 도입하지 않습니다. 인터페이스의 요구가 읽을 수 있다면 그것은 여전히 컴파일 시간 의존성을 소개 &lt;em&gt;예를&lt;/em&gt;모듈이 컴파일 단위의 하위 모듈이거나 일부 유형 구성 요소가 참조되는 경우. 또한 모듈 별칭에 액세스하면 별칭이 포함 된 컴파일 단위가 아니라 별칭이 참조하는 모듈을 포함하는 컴파일 단위에 대한 링크 시간 종속성이 발생합니다. 링크 타임 동작의 이러한 차이점은 일부 컴파일 단위가 라이브러리에서 추출되지 않고 부작용이 무시 될 수 있으므로 이전 동작과 호환되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3aad510e70a7c27301bea92f55e2778f037e8a3" translate="yes" xml:space="preserve">
          <source>When the function has no more character to provide, it &lt;em&gt;must&lt;/em&gt; signal an end-of-input condition by raising the exception &lt;code&gt;End_of_file&lt;/code&gt;.</source>
          <target state="translated">함수에 더 이상 제공 할 문자가 없으면 &lt;code&gt;End_of_file&lt;/code&gt; 예외를 발생시켜 입력 종료 조건을 신호 &lt;em&gt;해야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="93016f799b9860f1f90e3e6d4310d2cea8085d23" translate="yes" xml:space="preserve">
          <source>When the input can not be read according to the format string specification, formatted input functions typically raise exception &lt;code&gt;Scan_failure&lt;/code&gt;.</source>
          <target state="translated">형식 문자열 사양에 따라 입력을 읽을 수없는 경우 형식이 지정된 입력 함수는 일반적으로 예외 &lt;code&gt;Scan_failure&lt;/code&gt; 를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f218c5e044857f4d05b8d252e8b08d203dafa61d" translate="yes" xml:space="preserve">
          <source>When the native compiler compiles an implementation, by default it produces a .cmx file containing information for cross-module optimization. It also expects .cmx files to be present for the dependencies of the currently compiled source, and uses them for optimization. Since OCaml 4.03, the compiler will emit a warning if it is unable to locate the .cmx file of one of those dependencies.</source>
          <target state="translated">네이티브 컴파일러가 구현을 컴파일 할 때 기본적으로 모듈 간 최적화를위한 정보가 포함 된 .cmx 파일을 생성합니다. 또한 현재 컴파일 된 소스의 종속성에 대해 .cmx 파일이있을 것으로 예상하고이를 최적화에 사용합니다. OCaml 4.03부터 컴파일러는 이러한 종속성 중 하나의 .cmx 파일을 찾을 수없는 경우 경고를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="04821ef004e6a266283080b3e608b0f7733de10e" translate="yes" xml:space="preserve">
          <source>When the primitive function is applied in an OCaml program, the C function is called with the values of the expressions to which the primitive is applied as arguments. The value returned by the function is passed back to the OCaml program as the result of the function application.</source>
          <target state="translated">프리미티브 함수가 OCaml 프로그램에 적용될 때, 프리미티브가 인수로 적용되는 표현식의 값으로 C 함수가 호출됩니다. 함수에서 반환 된 값은 함수 응용 프로그램의 결과로 OCaml 프로그램에 다시 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="9d6cf0de3a117389ad73da14031486bc78be69b6" translate="yes" xml:space="preserve">
          <source>When the program aborts due to an uncaught exception, print a detailed &amp;ldquo;back trace&amp;rdquo; of the execution, showing where the exception was raised and which function calls were outstanding at this point. The back trace is printed only if the bytecode executable contains debugging information, i.e. was compiled and linked with the -g option to ocamlc set. This is equivalent to setting the b flag in the OCAMLRUNPARAM environment variable (see below).</source>
          <target state="translated">포착되지 않은 예외로 인해 프로그램이 중단되면 예외가 발생한 위치와이 시점에서 처리되지 않은 함수 호출을 보여주는 자세한 실행 &quot;역 추적&quot;을 인쇄합니다. 역 추적은 바이트 코드 실행 파일에 디버깅 정보가 포함 된 경우에만 인쇄됩니다. 즉, ocamlc 세트에 -g 옵션을 사용하여 컴파일 및 링크되었습니다. 이것은 OCAMLRUNPARAM 환경 변수에서 b 플래그를 설정하는 것과 같습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="9ce0660bb7b30ee2fd54ec7cc295742eecbaf44e" translate="yes" xml:space="preserve">
          <source>When the program issues a call to fork, the debugger can either follow the child or the parent. By default, the debugger follows the parent process. The variable follow_fork_mode controls this behavior:</source>
          <target state="translated">프로그램이 fork 호출을 발행하면 디버거는 자식 또는 부모를 따를 수 있습니다. 기본적으로 디버거는 상위 프로세스를 따릅니다. follow_fork_mode 변수는이 동작을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="3b792e8e2e3970fdf3425d9b17c7de05d84adfbe" translate="yes" xml:space="preserve">
          <source>When the program stops, the debugger automatically selects the currently executing frame and describes it briefly as the frame command does.</source>
          <target state="translated">프로그램이 중지되면 디버거는 현재 실행중인 프레임을 자동으로 선택하고 프레임 명령이 수행하는 것처럼 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="760b4f611d27d0bba924332cb9173f6280707de0" translate="yes" xml:space="preserve">
          <source>When the systhreads version of the &lt;code&gt;Thread&lt;/code&gt; module is loaded, this function redirects to &lt;code&gt;Thread.sigmask&lt;/code&gt;. I.e., &lt;code&gt;sigprocmask&lt;/code&gt; only changes the mask of the current thread.</source>
          <target state="translated">&lt;code&gt;Thread&lt;/code&gt; 모듈 의 systhreads 버전 이로드되면이 함수는 &lt;code&gt;Thread.sigmask&lt;/code&gt; 로 리디렉션됩니다 . 즉, &lt;code&gt;sigprocmask&lt;/code&gt; 는 현재 스레드의 마스크 만 변경합니다.</target>
        </trans-unit>
        <trans-unit id="c6709b785b4a5aea7c7211a96d782993cfbb1a1c" translate="yes" xml:space="preserve">
          <source>When there are several objects of same nature and role, they are all left unlabeled.</source>
          <target state="translated">동일한 특성과 역할을 가진 여러 개체가있는 경우 모두 레이블이 지정되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="abd94383fdf162fa4f337cc16327bc78a72fa7eb" translate="yes" xml:space="preserve">
          <source>When there is no preferable object, all arguments are labeled.</source>
          <target state="translated">선호하는 객체가 없으면 모든 인수에 레이블이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="8788e9cfbdfd7cb22b01576e3dae5fe0c90b56db" translate="yes" xml:space="preserve">
          <source>When this form is used together with the infix syntax for attributes, the attributes are considered to apply to the payload:</source>
          <target state="translated">이 양식을 속성에 대한 중위 구문과 함께 사용하면 속성이 페이로드에 적용되는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="bb287ff6ca578030aeae7bf2e7df239b02ae43f0" translate="yes" xml:space="preserve">
          <source>When used in conjunction with a parser generated by ocamlyacc, the semantic actions compute a value belonging to the type token defined by the generated parsing module. (See the description of ocamlyacc below.)</source>
          <target state="translated">ocamlyacc에 의해 생성 된 파서와 함께 사용되는 경우 시맨틱 동작은 생성 된 파싱 모듈에 의해 정의 된 유형 토큰에 속하는 값을 계산합니다. (아래의 ocamlyacc에 대한 설명을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="2f283aeb0bc8ab5225f11e88785f10ccc2fe8775" translate="yes" xml:space="preserve">
          <source>When using a symbolic formatter, all regular pretty-printing activities occur but output material is symbolic and stored in a buffer of output items. At the end of pretty-printing, flushing the output buffer allows post-processing of symbolic output before performing low level output operations.</source>
          <target state="translated">심볼릭 포맷터를 사용할 때 모든 일반적인 예쁜 인쇄 활동이 발생하지만 출력 자료는 심볼릭이며 출력 항목의 버퍼에 저장됩니다. pretty-printing이 끝날 때 출력 버퍼를 플러시하면 낮은 수준의 출력 작업을 수행하기 전에 기호 출력을 사후 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="5aa6f4fe7d77e2f540e510a58951685232221d1f" translate="yes" xml:space="preserve">
          <source>When using flambda:</source>
          <target state="translated">flambda를 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="23308a4fe88a862b61f8a4b2bfdb65916c66b9f8" translate="yes" xml:space="preserve">
          <source>When using the &lt;em&gt;dune&lt;/em&gt; build system, this compiler invocation can be replicated using the flagsstanza when building an executable.</source>
          <target state="translated">사용하는 경우 &lt;em&gt;모래 언덕&lt;/em&gt; 빌드 시스템을,이 컴파일러 호출은 실행 파일을 만들 때 flagsstanza를 사용하여 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55ed891e71155c65d68d420f137010fab4ba7b75" translate="yes" xml:space="preserve">
          <source>When using the automatic snapshot mode the profiling output is written to a file called &quot;spacetime-&amp;lt;pid&amp;gt;&quot; where &amp;lt;pid&amp;gt; is the process ID of the program. (If the program forks and continues executing then multiple files may be produced with different pid numbers.) The profiling output is by default written to the current working directory when the program starts. This may be customised by setting the OCAML_SPACETIME_SNAPSHOT_DIR environment variable to the name of the desired directory.</source>
          <target state="translated">자동 스냅 샷 모드를 사용할 때 프로파일 링 출력은 &quot;spacetime- &amp;lt;pid&amp;gt;&quot;라는 파일에 기록됩니다. 여기서 &amp;lt;pid&amp;gt;는 프로그램의 프로세스 ID입니다. (프로그램이 분기되어 계속 실행되면 여러 파일이 다른 pid 번호로 생성 될 수 있습니다.) 프로파일 링 출력은 기본적으로 프로그램이 시작될 때 현재 작업 디렉토리에 기록됩니다. OCAML_SPACETIME_SNAPSHOT_DIR 환경 변수를 원하는 디렉토리의 이름으로 설정하여 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff46176bb17d161a544e001f6343d1c85b5b2dc6" translate="yes" xml:space="preserve">
          <source>When using this mechanism, one should be aware that an exception backtrace is attached to the thread that saw it raised, rather than to the exception itself. Practically, it means that the code related to &lt;code&gt;fn&lt;/code&gt; should not use the backtrace if it has itself raised an exception before.</source>
          <target state="translated">이 메커니즘을 사용할 때 예외 역 추적은 예외 자체가 아니라 발생한 스레드에 연결된다는 점을 알아야합니다. 실제로는 &lt;code&gt;fn&lt;/code&gt; 관련 코드 가 이전에 자체적으로 예외가 발생한 경우 역 추적을 사용하지 않아야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="f1e6d6f6aef357dd76b888573f6bf7222fe68aed" translate="yes" xml:space="preserve">
          <source>When we finally need the result of a lazy expression, we can call Lazy.force on that expression to force its evaluation. The function force comes from standard-library module &lt;a href=&quot;libref/lazy&quot;&gt;Lazy&lt;/a&gt;.</source>
          <target state="translated">마지막으로 lazy 표현식의 결과가 필요하면 해당 표현식에 대해 Lazy.force를 호출하여 평가를 강제 할 수 있습니다. 기능적 힘은 표준 라이브러리 모듈 &lt;a href=&quot;libref/lazy&quot;&gt;Lazy&lt;/a&gt; 에서 비롯됩니다 .</target>
        </trans-unit>
        <trans-unit id="e379a737e559586d930adc6d411789e8e1ca7925" translate="yes" xml:space="preserve">
          <source>When writing stubs that need to be compiled under both Windows and Unix, the stubs need to be written in a way that allow the necessary conversions under Windows but that also work under Unix, where typically nothing particular needs to be done to support Unicode.</source>
          <target state="translated">Windows와 Unix 모두에서 컴파일해야하는 스텁을 작성할 때는 Windows에서 필요한 변환을 허용하지만 일반적으로 유니 코드를 지원하기 위해 특별히 수행 할 필요가없는 Unix에서도 작동하는 방식으로 스텁을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="27eea22179b14eb02869c4ff4d62cac522860c71" translate="yes" xml:space="preserve">
          <source>When you want to use distinct names for the variable and the label appearing in the type, you can use a naming label of the form ~name:. This also applies when the argument is not a variable.</source>
          <target state="translated">변수 및 유형에 나타나는 레이블에 대해 고유 한 이름을 사용하려는 경우 ~ name : 형식의 이름 지정 레이블을 사용할 수 있습니다. 이는 인수가 변수가 아닌 경우에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="41972dadb8c6dd136819857ca5e83412d7f72bdd" translate="yes" xml:space="preserve">
          <source>Whenever the search path is modified, the debugger will clear any information it may have cached about the files.</source>
          <target state="translated">검색 경로가 수정 될 때마다 디버거는 파일에 대해 캐시 된 모든 정보를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="b1e406d63a5b51f65514b45dd47778c4144e8d39" translate="yes" xml:space="preserve">
          <source>Whether or not a particular ocamlopt uses Flambda may be determined by invoking it with the -config option and looking for any line starting with &amp;ldquo;flambda:&amp;rdquo;. If such a line is present and says &amp;ldquo;true&amp;rdquo;, then Flambda is supported, otherwise it is not.</source>
          <target state="translated">특정 ocamlopt가 Flambda를 사용하는지 여부는 -config 옵션으로 호출하고 &quot;flambda :&quot;로 시작하는 줄을 찾아서 결정할 수 있습니다. 이러한 줄이 있고 &quot;true&quot;라고 표시되면 Flambda가 지원되고 그렇지 않으면 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="198cc493c18a84d95fe966d8c299f76f1fc4db83" translate="yes" xml:space="preserve">
          <source>Whether the block comes from unmarshalling.</source>
          <target state="translated">블록이 비 정렬 화에서 오는지 여부.</target>
        </trans-unit>
        <trans-unit id="ef49626fec86141035673c16c5b533b286ee1a42" translate="yes" xml:space="preserve">
          <source>Whether the machine currently executing the Caml program is big-endian.</source>
          <target state="translated">현재 Caml 프로그램을 실행중인 머신이 빅 엔디안인지 여부.</target>
        </trans-unit>
        <trans-unit id="d1a38a7988745c99aff596e8d4cb4566b84631f5" translate="yes" xml:space="preserve">
          <source>Whether to linger on closed connections that have data present, and for how long (in seconds)</source>
          <target state="translated">데이터가있는 닫힌 연결에 머무를 지 여부 및 시간 (초)</target>
        </trans-unit>
        <trans-unit id="7aaf1897a76792493551caf9cb7b76e9ccab26c4" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;m&lt;/code&gt; are handled by &lt;code&gt;formatter_out_functions.out_indent&lt;/code&gt;, the strings will be handled by &lt;code&gt;formatter_out_functions.out_string&lt;/code&gt;. This allows for a custom formatter that handles indentation distinctly, for example, outputs &lt;code&gt;&amp;lt;br/&amp;gt;&lt;/code&gt; tags or &lt;code&gt;&amp;amp;nbsp;&lt;/code&gt; entities.</source>
          <target state="translated">반면 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;m&lt;/code&gt; 하는 것은 처리되는 &lt;code&gt;formatter_out_functions.out_indent&lt;/code&gt; 상기 문자열에 의해 처리 될 &lt;code&gt;formatter_out_functions.out_string&lt;/code&gt; . 이렇게하면 &lt;code&gt;&amp;lt;br/&amp;gt;&lt;/code&gt; 태그 또는 &lt;code&gt;&amp;amp;nbsp;&lt;/code&gt; 출력하는 것과 같이 들여 쓰기를 명확하게 처리하는 사용자 지정 포맷터를 사용할 수 있습니다 . 엔티티.</target>
        </trans-unit>
        <trans-unit id="a07082aff84d3d6c58c93479955b2b92cb4da2e5" translate="yes" xml:space="preserve">
          <source>While class types c1 and c2 are different, both object types c1 and c2 expand to the same object type (same method names and types). Yet, when the domain of a coercion is left implicit and its co-domain is an abbreviation of a known class type, then the class type, rather than the object type, is used to derive the coercion function. This allows leaving the domain implicit in most cases when coercing form a subclass to its superclass. The type of a coercion can always be seen as below:</source>
          <target state="translated">클래스 유형 c1 및 c2는 다르지만 두 객체 유형 c1 및 c2는 모두 동일한 객체 유형 (동일한 메서드 이름 및 유형)으로 확장됩니다. 그러나 강제 도메인이 암시 적으로 남아 있고 공동 도메인이 알려진 클래스 유형의 약어 인 경우에는 객체 유형이 아닌 클래스 유형을 사용하여 강제 함수를 유도합니다. 이렇게하면 서브 클래스를 수퍼 클래스로 강제 형성 할 때 대부분의 경우 도메인을 암시 적으로 남겨 둘 수 있습니다. 강제 유형은 항상 아래와 같이 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6158ac4d7d9e28767d8869ab18311d19f991dae7" translate="yes" xml:space="preserve">
          <source>While objects of either class will behave the same, objects of their subclasses will be different. In a subclass of bad_functional_point, the method move will keep returning an object of the parent class. On the contrary, in a subclass of functional_point, the method move will return an object of the subclass.</source>
          <target state="translated">두 클래스의 객체는 동일하게 작동하지만 하위 클래스의 객체는 다릅니다. bad_functional_point의 하위 클래스에서 move 메서드는 상위 클래스의 개체를 계속 반환합니다. 반대로 functional_point의 하위 클래스에서 move 메서드는 하위 클래스의 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1327d963e242926568cdcda69b6c7938e8212df6" translate="yes" xml:space="preserve">
          <source>While parameterized classes may be polymorphic in their contents, they are not enough to allow polymorphism of method use.</source>
          <target state="translated">매개 변수화 된 클래스는 내용에서 다형성 일 수 있지만 메서드 사용의 다형성을 허용하기에는 충분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="537e22dedd240b673c1f40fc0ae35d5719dbfcd0" translate="yes" xml:space="preserve">
          <source>While providing an accurate estimate of potential performance loss is difficult, test on various OCaml programs showed a total running time increase ranging from 1% to 8%.</source>
          <target state="translated">잠재적 인 성능 손실을 정확하게 추정하는 것은 어렵지만 다양한 OCaml 프로그램에서 테스트 한 결과 총 실행 시간이 1 %에서 8 %까지 증가했습니다.</target>
        </trans-unit>
        <trans-unit id="ff2bae5cd8894f914083548969308228cab1140a" translate="yes" xml:space="preserve">
          <source>While the Unicode version under Windows has the prototype:</source>
          <target state="translated">Windows의 유니 코드 버전에는 프로토 타입이 있습니다.</target>
        </trans-unit>
        <trans-unit id="133a040a06d4d9ee4fa55f4d12f1b1b3a635c70e" translate="yes" xml:space="preserve">
          <source>While they provide an increased comfort for writing function applications, labels and optional arguments have the pitfall that they cannot be inferred as completely as the rest of the language.</source>
          <target state="translated">함수 응용 프로그램을 작성하는 데 더 많은 편의를 제공하지만 레이블과 선택적 인수는 나머지 언어만큼 완벽하게 추론 할 수 없다는 함정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a933a1213833424b3c999c684da426e0bacb55cf" translate="yes" xml:space="preserve">
          <source>While this property is generally intuitive, there is at least one specific case where a different semantics might be expected. Consider a pattern followed by a when-guard: |pwheng-&amp;gt;e, for example:</source>
          <target state="translated">이 속성은 일반적으로 직관적이지만 다른 의미 체계가 예상되는 특정 경우가 하나 이상 있습니다. 다음과 같이 when-guard : | pwheng-&amp;gt; e가 오는 패턴을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="efd40bf9067e6d85c2521942cd5aea37e0ec3683" translate="yes" xml:space="preserve">
          <source>Whole-backtrace printing functions also skip some uninformative slots; in that case, &lt;code&gt;format&amp;nbsp;pos&amp;nbsp;slot&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">전체 역 추적 인쇄 기능은 또한 일부 정보가없는 슬롯을 건너 뜁니다. 이 경우 &lt;code&gt;format&amp;nbsp;pos&amp;nbsp;slot&lt;/code&gt; 은 &lt;code&gt;None&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="28ffaa03b305fc0126ea578346ae1d6b55f3dcbe" translate="yes" xml:space="preserve">
          <source>Wildcard pattern given as argument to a constant constructor.</source>
          <target state="translated">상수 생성자에 대한 인수로 제공된 와일드 카드 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="a5bb2ce358da3362d349dc7dffbbc028b2897662" translate="yes" xml:space="preserve">
          <source>Windows only: allow the file to be deleted while still open</source>
          <target state="translated">Windows 전용 : 열려있는 동안 파일 삭제 허용</target>
        </trans-unit>
        <trans-unit id="7c2d346eb667eea590c331ddf31fccbcc4d6b831" translate="yes" xml:space="preserve">
          <source>Windows symbolic links are available in Windows Vista onwards. There are some important differences between Windows symlinks and their POSIX counterparts.</source>
          <target state="translated">Windows 기호 링크는 Windows Vista 이상에서 사용할 수 있습니다. Windows 심볼릭 링크와 해당 POSIX 항목 간에는 몇 가지 중요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbe946cc38b1b8f9f48fa7c868b06c619142edd3" translate="yes" xml:space="preserve">
          <source>Windows symbolic links come in two flavours: directory and regular, which designate whether the symbolic link points to a directory or a file. The type must be correct - a directory symlink which actually points to a file cannot be selected with chdir and a file symlink which actually points to a directory cannot be read or written (note that Cygwin's emulation layer ignores this distinction).</source>
          <target state="translated">Windows 심볼릭 링크는 디렉터리와 일반의 두 가지 형태로 제공되며 심볼릭 링크가 디렉터리 또는 파일을 가리키는 지 여부를 지정합니다. 유형은 정확해야합니다. 실제로 파일을 가리키는 디렉토리 심볼릭 링크는 chdir로 선택할 수 없으며 실제로 디렉토리를 가리키는 파일 심볼릭 링크는 읽거나 쓸 수 없습니다 (Cygwin의 에뮬레이션 레이어는이 구분을 무시합니다).</target>
        </trans-unit>
        <trans-unit id="447eabd50cdaa0e176b6a5e8a5c67d40d79f8b6f" translate="yes" xml:space="preserve">
          <source>Windows with the MSVC compiler: the object file produced by OCaml have been compiled with the /MD flag, and therefore all other object files linked with it should also be compiled with /MD.</source>
          <target state="translated">MSVC 컴파일러가있는 Windows : OCaml에서 생성 된 개체 파일은 / MD 플래그로 컴파일되었으므로 이와 연결된 다른 모든 개체 파일도 / MD로 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7b5ddaa1ca629f6f8bdd33966c0453bae3a01fc" translate="yes" xml:space="preserve">
          <source>Windows: A fairly complete emulation of the Unix system calls is provided in the Windows version of OCaml. The end of this chapter gives more information on the functions that are not supported under Windows.</source>
          <target state="translated">Windows : Windows 버전의 OCaml에는 Unix 시스템 호출의 상당히 완전한 에뮬레이션이 제공됩니다. 이 장의 끝에서는 Windows에서 지원되지 않는 기능에 대한 자세한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e77e2d4c781ed2ce4243a9db7811f83b915be1f7" translate="yes" xml:space="preserve">
          <source>Windows: The Cygwin port of OCaml fully implements all functions from the Unix module. The native Win32 ports implement a subset of them. Below is a list of the functions that are not implemented, or only partially implemented, by the Win32 ports. Functions not mentioned are fully implemented and behave as described previously in this chapter.</source>
          <target state="translated">Windows : OCaml의 Cygwin 포트는 Unix 모듈의 모든 기능을 완벽하게 구현합니다. 네이티브 Win32 포트는 이들의 하위 집합을 구현합니다. 아래는 Win32 포트에 의해 구현되지 않거나 부분적으로 만 구현 된 기능의 목록입니다. 언급되지 않은 기능은이 장의 앞부분에서 설명한대로 완전히 구현되고 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1778d9d388d1318f9dac928bdbd83df7f0e1159a" translate="yes" xml:space="preserve">
          <source>Windows: The debugger is available under the Cygwin port of OCaml, but not under the native Win32 ports.</source>
          <target state="translated">Windows : 디버거는 OCaml의 Cygwin 포트에서 사용할 수 있지만 기본 Win32 포트에서는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6b9513167feb53aba08956064362d9c1f15e80c9" translate="yes" xml:space="preserve">
          <source>Windows: This is material specific to Microsoft Windows (XP, Vista, 7, 8, 10).</source>
          <target state="translated">Windows : Microsoft Windows (XP, Vista, 7, 8, 10)에만 해당하는 자료입니다.</target>
        </trans-unit>
        <trans-unit id="d59e24d63c516a909f266896c2e9ddb1141ca9e7" translate="yes" xml:space="preserve">
          <source>Windows: Under several versions of Windows, bytecode executable files are self-executable only if their name ends in .exe. It is recommended to always give .exe names to bytecode executables, e.g. compile with ocamlc -o myprog.exe ... rather than ocamlc -o myprog ....</source>
          <target state="translated">Windows : 여러 버전의 Windows에서 바이트 코드 실행 파일은 이름이 .exe로 끝나는 경우에만 자체 실행 가능합니다. 바이트 코드 실행 파일에 항상 .exe 이름을 지정하는 것이 좋습니다. 예를 들어 ocamlc -o myprog ... 대신 ocamlc -o myprog.exe ...로 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="d2edb2340a5c0f0e98f5830d04cf40b983609fdf" translate="yes" xml:space="preserve">
          <source>With a regular polymorphic algebraic data type, the type parameters of the type constructor are constant within the definition of the type. For instance, we can look at arbitrarily nested list defined as:</source>
          <target state="translated">일반 다형성 대수 데이터 유형을 사용하면 유형 생성자의 유형 매개 변수가 유형 정의 내에서 일정합니다. 예를 들어, 다음과 같이 정의 된 임의로 중첩 된 목록을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="793a0b884a8cef1f81c2be80c8c54572694c3562" translate="yes" xml:space="preserve">
          <source>With explicit polymorphic annotations, it becomes possible to implement any recursive function that depends only on the structure of the nested lists and not on the type of the elements. For instance, a more complex example would be to compute the total number of elements of the nested lists:</source>
          <target state="translated">명시 적 다형성 주석을 사용하면 요소 유형이 아닌 중첩 된 목록의 구조에만 의존하는 모든 재귀 함수를 구현할 수 있습니다. 예를 들어 더 복잡한 예는 중첩 된 목록의 총 요소 수를 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9aaeec849cd83352f9371c6d87cc72eeb181cde0" translate="yes" xml:space="preserve">
          <source>With first-class modules, it is possible to parametrize some code over the implementation of a module without using a functor.</source>
          <target state="translated">일류 모듈을 사용하면 펑터를 사용하지 않고도 모듈 구현에 대해 일부 코드를 매개 변수화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e369349c1d2c6f7f1e4a71739bc82fddb2fe1cc" translate="yes" xml:space="preserve">
          <source>With ocamlopt, you should do:</source>
          <target state="translated">ocamlopt를 사용하면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="780b3948c4b7fbdb7b79edddbe07b3956efd1b1f" translate="yes" xml:space="preserve">
          <source>With polymorphic variants, this original assumption is removed. That is, a variant tag does not belong to any type in particular, the type system will just check that it is an admissible value according to its use. You need not define a type before using a variant tag. A variant type will be inferred independently for each of its uses.</source>
          <target state="translated">다형성 변형을 사용하면이 원래 가정이 제거됩니다. 즉, 변형 태그는 특별히 어떤 유형에도 속하지 않으며, 유형 시스템은 용도에 따라 허용 가능한 값인지 확인합니다. 변형 태그를 사용하기 전에 유형을 정의 할 필요가 없습니다. 변형 유형은 각 용도에 대해 독립적으로 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="b78139198d9c10d6168a26db0f9a8f08c4bf0df4" translate="yes" xml:space="preserve">
          <source>With respect to the variance of their parameters, private types are handled like abstract types. That is, if a private type has parameters, their variance is the one explicitly given by prefixing the parameter by a &amp;lsquo;+&amp;rsquo; or a &amp;lsquo;-&amp;rsquo;, it is invariant otherwise.</source>
          <target state="translated">매개 변수의 분산과 관련하여 private 유형은 추상 유형처럼 처리됩니다. 즉, 개인 유형에 매개 변수가있는 경우 해당 분산은 매개 변수 앞에 '+'또는 '-'를 추가하여 명시 적으로 제공 한 것이며 그렇지 않으면 불변입니다.</target>
        </trans-unit>
        <trans-unit id="f6641a1c12f08009ac05530d30c3227fe41a7d60" translate="yes" xml:space="preserve">
          <source>With this argument, id_again is seen as a function definition by the type checker and can therefore be generalized. This kind of manipulation is called eta-expansion in lambda calculus and is sometimes referred under this name.</source>
          <target state="translated">이 인수를 사용하면 id_again은 유형 검사기에 의해 함수 정의로 간주되므로 일반화 할 수 있습니다. 이러한 종류의 조작을 람다 미적분학에서 eta-expansion이라고하며 때때로이 이름으로 참조됩니다.</target>
        </trans-unit>
        <trans-unit id="419106f5e3d58ced85f242c86baeb4dedb2d9727" translate="yes" xml:space="preserve">
          <source>With this functional update notation, the record on the left-hand side of with is copied except for the fields on the right-hand side which are updated.</source>
          <target state="translated">이 기능 업데이트 표기법을 사용하면 업데이트되는 오른쪽의 필드를 제외하고 with의 왼쪽에있는 레코드가 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="b229f3dc4b42a2159ecd907f5544fdc40dedc449" translate="yes" xml:space="preserve">
          <source>Within this box, the pretty-printer emphasizes the box structure: if a structural box does not fit fully on a simple line, a break hint also splits the line if the splitting ``moves to the left'' (i.e. the new line gets an indentation smaller than the one of the current line).</source>
          <target state="translated">이 상자 내에서 pretty-printer는 상자 구조를 강조합니다. 구조 상자가 단순한 선에 완전히 맞지 않으면 분할이``왼쪽으로 이동 ''하면 (즉, 새 줄이 현재 줄보다 작은 들여 쓰기).</target>
        </trans-unit>
        <trans-unit id="c02ea2020d35ee95ea72c4ffc4631170ac6fef86" translate="yes" xml:space="preserve">
          <source>Within this box, the pretty-printer prints as much as possible material on every line.</source>
          <target state="translated">이 상자 내에서 pretty-printer는 모든 라인에 가능한 한 많은 자료를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2e0e073b44d4d068d7117f272b8038adbf1bf5ea" translate="yes" xml:space="preserve">
          <source>Wosize_val(v) returns the size of the block v, in words, excluding the header.</source>
          <target state="translated">Wosize_val (v)는 헤더를 제외한 블록 v의 크기를 단어로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="63d9a524a7c3c6c486a85947f3196b96b6b69775" translate="yes" xml:space="preserve">
          <source>Write a 1-byte integer</source>
          <target state="translated">1 바이트 정수 쓰기</target>
        </trans-unit>
        <trans-unit id="64e0f6125bd34169b0d388120ea7dd10db632157" translate="yes" xml:space="preserve">
          <source>Write a 2-byte integer</source>
          <target state="translated">2 바이트 정수 쓰기</target>
        </trans-unit>
        <trans-unit id="3640b1f7b9b33fc7967e17559e1e2a50f0a96852" translate="yes" xml:space="preserve">
          <source>Write a 4-byte float</source>
          <target state="translated">4 바이트 부동 소수점 작성</target>
        </trans-unit>
        <trans-unit id="cfbd154bff247d5a942dd8e5515ed553c1a7390b" translate="yes" xml:space="preserve">
          <source>Write a 4-byte integer</source>
          <target state="translated">4 바이트 정수 쓰기</target>
        </trans-unit>
        <trans-unit id="715165742f4e141b3ddb7a279940fc6b55c0ca2e" translate="yes" xml:space="preserve">
          <source>Write a 8-byte float</source>
          <target state="translated">8 바이트 부동 소수점 작성</target>
        </trans-unit>
        <trans-unit id="2facaf6686edb20cf3e9091a815ffb2e2b89b1ac" translate="yes" xml:space="preserve">
          <source>Write a 8-byte integer</source>
          <target state="translated">8 바이트 정수 쓰기</target>
        </trans-unit>
        <trans-unit id="e82c9510edfabc9175be85bb68c20dc9b6e99492" translate="yes" xml:space="preserve">
          <source>Write a digest on the given output channel.</source>
          <target state="translated">주어진 출력 채널에 다이제스트를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="08d1fa4a93435c8cbbf3ca7eea7b612c499a6c10" translate="yes" xml:space="preserve">
          <source>Write an array of 1-byte quantities</source>
          <target state="translated">1 바이트 수량의 배열 작성</target>
        </trans-unit>
        <trans-unit id="c977d44c3cd5560e8b2da234f19e0a15bea610a7" translate="yes" xml:space="preserve">
          <source>Write an array of 2-byte quantities</source>
          <target state="translated">2 바이트 수량의 배열 작성</target>
        </trans-unit>
        <trans-unit id="e6c403b19464f207843f099b264ced8a01ca18f0" translate="yes" xml:space="preserve">
          <source>Write an array of 4-byte quantities</source>
          <target state="translated">4 바이트 수량의 배열 작성</target>
        </trans-unit>
        <trans-unit id="f53373896e51a6637bb7fe916341a7d92236445d" translate="yes" xml:space="preserve">
          <source>Write an array of 8-byte quantities</source>
          <target state="translated">8 바이트 수량의 배열 작성</target>
        </trans-unit>
        <trans-unit id="e0f7f0f906de0511a7edb65c46d9427e81dab512" translate="yes" xml:space="preserve">
          <source>Write one 8-bit integer (as the single character with that code) on the given output channel.</source>
          <target state="translated">주어진 출력 채널에 하나의 8 비트 정수 (해당 코드가있는 단일 문자로)를 씁니다.</target>
        </trans-unit>
        <trans-unit id="3ba782992ef61637de9988b9893ce1faa4dcb5a1" translate="yes" xml:space="preserve">
          <source>Write one 8-bit integer (as the single character with that code) on the given output channel. The given integer is taken modulo 256.</source>
          <target state="translated">주어진 출력 채널에 하나의 8 비트 정수 (해당 코드가있는 단일 문자로)를 씁니다. 주어진 정수는 모듈로 256을 취합니다.</target>
        </trans-unit>
        <trans-unit id="71c0bd41c52ac23c0adc744eacbe4d241a2b2ad3" translate="yes" xml:space="preserve">
          <source>Write one integer in binary format (4 bytes, big-endian) on the given output channel.</source>
          <target state="translated">주어진 출력 채널에 이진 형식 (4 바이트, 빅 엔디안)으로 하나의 정수를 씁니다.</target>
        </trans-unit>
        <trans-unit id="34aceab15eda014863baa6a1c5355e0e7be3b34c" translate="yes" xml:space="preserve">
          <source>Write one integer in binary format (4 bytes, big-endian) on the given output channel. The given integer is taken modulo 2&lt;sup&gt;32&lt;/sup&gt;. The only reliable way to read it back is through the &lt;a href=&quot;stdlib#VALinput_binary_int&quot;&gt;&lt;code&gt;input_binary_int&lt;/code&gt;&lt;/a&gt; function. The format is compatible across all machines for a given version of OCaml.</source>
          <target state="translated">주어진 출력 채널에 이진 형식 (4 바이트, 빅 엔디안)으로 하나의 정수를 씁니다. 주어진 정수는 모듈로 2 &lt;sup&gt;32&lt;/sup&gt; 취 합니다. 다시 읽을 수있는 유일한 방법은 &lt;a href=&quot;stdlib#VALinput_binary_int&quot;&gt; &lt;code&gt;input_binary_int&lt;/code&gt; &lt;/a&gt; 함수를 사용하는 것입니다. 이 형식은 특정 버전의 OCaml에 대해 모든 컴퓨터에서 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="8e9567ae72bdfa38f1bb204519eda84c455c31af" translate="yes" xml:space="preserve">
          <source>Write permission</source>
          <target state="translated">쓰기 권한</target>
        </trans-unit>
        <trans-unit id="2cdc89f50c7c2a8bac5ec4a97b5d467ab66c6f1d" translate="yes" xml:space="preserve">
          <source>Write the byte sequence on the given output channel.</source>
          <target state="translated">주어진 출력 채널에 바이트 시퀀스를 씁니다.</target>
        </trans-unit>
        <trans-unit id="8c61c80c2e96a62e362a46979a59bd049103d97c" translate="yes" xml:space="preserve">
          <source>Write the character on the given output channel.</source>
          <target state="translated">주어진 출력 채널에 문자를 씁니다.</target>
        </trans-unit>
        <trans-unit id="d95495287973862b47913b4cbd3b67affb139553" translate="yes" xml:space="preserve">
          <source>Write the representation of a structured value of any type to a channel.</source>
          <target state="translated">모든 유형의 구조화 된 값 표현을 채널에 씁니다.</target>
        </trans-unit>
        <trans-unit id="52bac5ed5d8e6829ddf07dd242543be1e64e07c8" translate="yes" xml:space="preserve">
          <source>Write the representation of a structured value of any type to a channel. Circularities and sharing inside the value are detected and preserved. The object can be read back, by the function &lt;a href=&quot;stdlib#VALinput_value&quot;&gt;&lt;code&gt;input_value&lt;/code&gt;&lt;/a&gt;. See the description of module &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; for more information. &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt; is equivalent to &lt;a href=&quot;marshal#VALto_channel&quot;&gt;&lt;code&gt;Marshal.to_channel&lt;/code&gt;&lt;/a&gt; with an empty list of flags.</source>
          <target state="translated">모든 유형의 구조화 된 값 표현을 채널에 씁니다. 가치 내에서 순환 성과 공유가 감지되고 보존됩니다. 객체는 &lt;a href=&quot;stdlib#VALinput_value&quot;&gt; &lt;code&gt;input_value&lt;/code&gt; &lt;/a&gt; 함수로 다시 읽을 수 있습니다 . 자세한 내용은 모듈 &lt;a href=&quot;marshal&quot;&gt; &lt;code&gt;Marshal&lt;/code&gt; 에&lt;/a&gt; 대한 설명 을 참조하십시오. &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt; &lt;code&gt;output_value&lt;/code&gt; &lt;/a&gt; 는 플래그 목록이 비어있는 &lt;a href=&quot;marshal#VALto_channel&quot;&gt; &lt;code&gt;Marshal.to_channel&lt;/code&gt; &lt;/a&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="0101de444dbaca2559f24fe3f82d42b10b30dff5" translate="yes" xml:space="preserve">
          <source>Write the string on the given output channel.</source>
          <target state="translated">주어진 출력 채널에 문자열을 씁니다.</target>
        </trans-unit>
        <trans-unit id="64a1114690fa6f09d76b5358d5f1efe1b0b6f056" translate="yes" xml:space="preserve">
          <source>Writes complete as `Synchronised I/O data integrity completion'</source>
          <target state="translated">'동기화 된 I / O 데이터 무결성 완료'로 쓰기 완료</target>
        </trans-unit>
        <trans-unit id="94c9f295e008153f31321c142fb1d08220a8d6c0" translate="yes" xml:space="preserve">
          <source>Writes complete as `Synchronised I/O file integrity completion'</source>
          <target state="translated">'동기화 된 I / O 파일 무결성 완료'로 쓰기 완료</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="2e597738f972d389ca423a6fd654d10536c9fa46" translate="yes" xml:space="preserve">
          <source>XDG_CONFIG_HOME, HOME</source>
          <target state="translated">XDG_CONFIG_HOME, 홈</target>
        </trans-unit>
        <trans-unit id="74d29c2695b2ef20f173bccc3cde5734c046270e" translate="yes" xml:space="preserve">
          <source>Xavier Leroy,</source>
          <target state="translated">자비에 르로이,</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="3691ae14052440bcf4e7fcb1a5a144ad4c587994" translate="yes" xml:space="preserve">
          <source>Year - 1900</source>
          <target state="translated">연도-1900</target>
        </trans-unit>
        <trans-unit id="f0083fa1822201a52d16c81cc73e7189d19db00a" translate="yes" xml:space="preserve">
          <source>You can act the same way for other kinds of generators.</source>
          <target state="translated">다른 종류의 생성기에 대해서도 동일한 방식으로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="661bf01810306e132b3e8ac6dd4b7a3ec66d1b02" translate="yes" xml:space="preserve">
          <source>You can avoid such risks by annotating the definition itself.</source>
          <target state="translated">정의 자체에 주석을 달면 이러한 위험을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cc3edf7fc664fefdda41a9a96260f03ffd5b4e8" translate="yes" xml:space="preserve">
          <source>You can do this as follows:</source>
          <target state="translated">다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28971cf504f1ddc3ef622da769c247b303992256" translate="yes" xml:space="preserve">
          <source>You can ignore the first two lines of the error message. What matters is the last one: putting self into an external reference would make it impossible to extend it through inheritance. We will see in section &lt;a href=&quot;#s%3Ausing-coercions&quot;&gt;3.12&lt;/a&gt; a workaround to this problem. Note however that, since immediate objects are not extensible, the problem does not occur with them.</source>
          <target state="translated">오류 메시지의 처음 두 줄은 무시할 수 있습니다. 중요한 것은 마지막 것입니다. self를 외부 참조에 넣으면 상속을 통해 확장 할 수 없게됩니다. 섹션 &lt;a href=&quot;#s%3Ausing-coercions&quot;&gt;3.12&lt;/a&gt; 에서이 문제에 대한 해결 방법을 살펴 보겠습니다 . 그러나 즉각적인 개체는 확장 할 수 없기 때문에 문제가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fcf876e27628653e073122db73ce91332f1ff4bd" translate="yes" xml:space="preserve">
          <source>You can jump directly to a given time, without stopping on breakpoints, using the goto command.</source>
          <target state="translated">goto 명령을 사용하면 중단 점에서 멈추지 않고 주어진 시간으로 바로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1517e86749fa6650d7e132b11082d485c41230a" translate="yes" xml:space="preserve">
          <source>You can see it in the following two examples.</source>
          <target state="translated">다음 두 가지 예에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97764d97435c3bd71f977265f2ea46ca12fa1c01" translate="yes" xml:space="preserve">
          <source>You can use custom tags in the documentation comments, but they will have no effect if the generator used does not handle them. To use a custom tag, for example foo, just put @foo with some text in your comment, as in:</source>
          <target state="translated">문서 주석에 사용자 정의 태그를 사용할 수 있지만 사용 된 생성기가이를 처리하지 않으면 효과가 없습니다. 사용자 정의 태그 (예 : foo)를 사용하려면 다음과 같이 주석에 일부 텍스트와 함께 @foo를 입력하면됩니다.</target>
        </trans-unit>
        <trans-unit id="80b472c524eb05921f02c45d9ced45aad041cf07" translate="yes" xml:space="preserve">
          <source>You have neglected to load in memory an implementation for a module with #load. See section &lt;a href=&quot;#s%3Atoplevel-modules&quot;&gt;10.3&lt;/a&gt; above.</source>
          <target state="translated">#load를 사용하여 모듈에 대한 구현을 메모리에로드하는 것을 무시했습니다. 위의 섹션 &lt;a href=&quot;#s%3Atoplevel-modules&quot;&gt;10.3을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4220d4e276f5f289cffdd8a85915703d07a3b840" translate="yes" xml:space="preserve">
          <source>You may also selectively coerce values through pattern matching.</source>
          <target state="translated">패턴 일치를 통해 선택적으로 값을 강제 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf234cd629ada47a347b6e57492abc4f3fdf6533" translate="yes" xml:space="preserve">
          <source>You may also use the explicit pretty-printing box management and printing functions provided by this module. This style is more basic but more verbose than the concise &lt;code&gt;fprintf&lt;/code&gt; format strings.</source>
          <target state="translated">이 모듈에서 제공하는 명시적인 예쁜 인쇄 상자 관리 및 인쇄 기능을 사용할 수도 있습니다. 이 스타일은 간결한 &lt;code&gt;fprintf&lt;/code&gt; 형식 문자열 보다 더 기본적이지만 더 장황 합니다.</target>
        </trans-unit>
        <trans-unit id="6cfde5a7f39920505c89726af4b9f5350dc3b7e2" translate="yes" xml:space="preserve">
          <source>You may consider this module as providing an extension to the &lt;code&gt;printf&lt;/code&gt; facility to provide automatic line splitting. The addition of pretty-printing annotations to your regular &lt;code&gt;printf&lt;/code&gt; format strings gives you fancy indentation and line breaks. Pretty-printing annotations are described below in the documentation of the function &lt;a href=&quot;format#VALfprintf&quot;&gt;&lt;code&gt;Format.fprintf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈 은 자동 줄 분할을 제공하기 위해 &lt;code&gt;printf&lt;/code&gt; 기능에 대한 확장을 제공하는 것으로 간주 할 수 있습니다 . 일반 &lt;code&gt;printf&lt;/code&gt; 형식 문자열 에 예쁜 인쇄 주석을 추가 하면 멋진 들여 쓰기와 줄 바꿈이 제공됩니다. 예쁘게 인쇄되는 주석은 &lt;a href=&quot;format#VALfprintf&quot;&gt; &lt;code&gt;Format.fprintf&lt;/code&gt; &lt;/a&gt; 함수의 문서 아래에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78c55f2f29b4cce66bf9146a0c9abe5ac5838e51" translate="yes" xml:space="preserve">
          <source>You must not call any of the OCaml runtime functions or macros between registering and storing the value. Neither must you store anything in the variable v (likewise, the location p) that is not a valid value.</source>
          <target state="translated">값을 등록하고 저장하는 사이에 OCaml 런타임 함수 또는 매크로를 호출해서는 안됩니다. 유효한 값이 아닌 변수 v (마찬가지로 위치 p)에 어떤 것도 저장해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="a96720e5c70f0c8e2f8ccaf81279ef4c128c7988" translate="yes" xml:space="preserve">
          <source>You need to explicitly close all channels created with this function. Closing the channel also closes the underlying file descriptor (unless it was already closed).</source>
          <target state="translated">이 함수로 만든 모든 채널을 명시 적으로 닫아야합니다. 채널을 닫으면 기본 파일 설명 자도 닫힙니다 (이미 닫혀 있지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="0596316547d32d2417575f8e486406afcba8d4b6" translate="yes" xml:space="preserve">
          <source>You need to explicitly close all channels created with this function. Closing the channel flushes the data and closes the underlying file descriptor (unless it has already been closed, in which case the buffered data is lost).</source>
          <target state="translated">이 함수로 만든 모든 채널을 명시 적으로 닫아야합니다. 채널을 닫으면 데이터가 플러시되고 기본 파일 설명자가 닫힙니다 (이미 닫혀있는 경우 버퍼링 된 데이터가 손실되지 않는 한).</target>
        </trans-unit>
        <trans-unit id="909f99a779adb66a76fc53ab56c7dd1caf35d0fd" translate="yes" xml:space="preserve">
          <source>Z</source>
          <target state="translated">Z</target>
        </trans-unit>
        <trans-unit id="8d53a00e5e95994b8c03087aae9edf99059c5fad" translate="yes" xml:space="preserve">
          <source>Zero-dimensional arrays</source>
          <target state="translated">0 차원 배열</target>
        </trans-unit>
        <trans-unit id="fdada8324810d78c81310e77d05c5f3da0c92d67" translate="yes" xml:space="preserve">
          <source>Zero-dimensional arrays.</source>
          <target state="translated">0 차원 배열.</target>
        </trans-unit>
        <trans-unit id="d68cb4683ebb48572f956e05c0df868074c28605" translate="yes" xml:space="preserve">
          <source>Zero-dimensional arrays. The &lt;code&gt;Array0&lt;/code&gt; structure provides operations similar to those of &lt;a href=&quot;bigarray.genarray&quot;&gt;&lt;code&gt;Bigarray.Genarray&lt;/code&gt;&lt;/a&gt;, but specialized to the case of zero-dimensional arrays that only contain a single scalar value. Statically knowing the number of dimensions of the array allows faster operations, and more precise static type-checking.</source>
          <target state="translated">0 차원 배열. &lt;code&gt;Array0&lt;/code&gt; 의 구조와 유사한 동작 제공 &lt;a href=&quot;bigarray.genarray&quot;&gt; &lt;code&gt;Bigarray.Genarray&lt;/code&gt; &lt;/a&gt; 하지만, 단지 하나의 스칼라 값을 포함 제로 차원 배열의 경우에 전문화. 배열의 차원 수를 정적으로 알면 더 빠른 작업과 더 정확한 정적 유형 검사가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="79bef1c4de4a640570f94b254d7bfb2f7421b7ab" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt;. ] &lt;a href=&quot;#class-name&quot;&gt;class-name&lt;/a&gt;</source>
          <target state="translated">[ &lt;a href=&quot;#extended-module-path&quot;&gt;확장 모듈 경로&lt;/a&gt; . ] &lt;a href=&quot;#class-name&quot;&gt;클래스 이름&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4dbf8ee7b1d74aefca48d3a61e9ed381afdeb89" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt;. ] &lt;a href=&quot;#modtype-name&quot;&gt;modtype-name&lt;/a&gt;</source>
          <target state="translated">[ &lt;a href=&quot;#extended-module-path&quot;&gt;확장 모듈 경로&lt;/a&gt; . ] &lt;a href=&quot;#modtype-name&quot;&gt;modtype-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="46b7c489fe99a39ef8cdcb8fb3b8664a53ec84ff" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt;. ] &lt;a href=&quot;#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;</source>
          <target state="translated">[ &lt;a href=&quot;#extended-module-path&quot;&gt;확장 모듈 경로&lt;/a&gt; . ] &lt;a href=&quot;#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e8a5cbe1467b65f8d9900519467617a8e9a29e7a" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#module-path&quot;&gt;module-path&lt;/a&gt;. ] &lt;a href=&quot;#class-name&quot;&gt;class-name&lt;/a&gt;</source>
          <target state="translated">[ &lt;a href=&quot;#module-path&quot;&gt;모듈 경로&lt;/a&gt; . ] &lt;a href=&quot;#class-name&quot;&gt;클래스 이름&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="845419fd360a1d51826ed64f653c49eddf9d1058" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#module-path&quot;&gt;module-path&lt;/a&gt;. ] &lt;a href=&quot;#constr-name&quot;&gt;constr-name&lt;/a&gt;</source>
          <target state="translated">[ &lt;a href=&quot;#module-path&quot;&gt;모듈 경로&lt;/a&gt; . ] &lt;a href=&quot;#constr-name&quot;&gt;constr- 이름&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d2503669881fa83efc7ff33724be786ec3d3cae" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#module-path&quot;&gt;module-path&lt;/a&gt;. ] &lt;a href=&quot;#field-name&quot;&gt;field-name&lt;/a&gt;</source>
          <target state="translated">[ &lt;a href=&quot;#module-path&quot;&gt;모듈 경로&lt;/a&gt; . ] &lt;a href=&quot;#field-name&quot;&gt;필드 이름&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d3883afd3da5e8553f5497e863411b042b05c61" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#module-path&quot;&gt;module-path&lt;/a&gt;. ] &lt;a href=&quot;#value-name&quot;&gt;value-name&lt;/a&gt;</source>
          <target state="translated">[ &lt;a href=&quot;#module-path&quot;&gt;모듈 경로&lt;/a&gt; . ] &lt;a href=&quot;#value-name&quot;&gt;값 이름&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d3c4bcaa3c0479eac0d8fb95567a1abb3c68695" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; ] |&lt;a href=&quot;#tag-spec&quot;&gt;tag-spec&lt;/a&gt;</source>
          <target state="translated">[ &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; ] | &lt;a href=&quot;#tag-spec&quot;&gt;태그 사양&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c9edeebdd153fabd8c188de80c045c7c47a2803" translate="yes" xml:space="preserve">
          <source>[ &lt;a href=&quot;modules#module-items&quot;&gt;module-items&lt;/a&gt; ]</source>
          <target state="translated">[ &lt;a href=&quot;modules#module-items&quot;&gt;모듈 항목&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="1dcfe0a951210d687a08d6058977844f3198309a" translate="yes" xml:space="preserve">
          <source>[ | ] &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; [when&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;] -&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; { |&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; [when&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;] -&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; }</source>
          <target state="translated">[| ] &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; [when &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; ]-&amp;gt; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; {| &lt;a href=&quot;patterns#pattern&quot;&gt;패턴&lt;/a&gt; [when &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; ]-&amp;gt; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="b9a69e212d262bdf5b8dceb1fc60d112e0cfb471" translate="yes" xml:space="preserve">
          <source>[%%&lt;a href=&quot;attributes#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;attributes#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</source>
          <target state="translated">[%%&lt;a href=&quot;attributes#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;attributes#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="324489a2771b36bc101aa148e24a3e655d9fbefd" translate="yes" xml:space="preserve">
          <source>[%&lt;a href=&quot;attributes#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;attributes#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</source>
          <target state="translated">[%&lt;a href=&quot;attributes#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;attributes#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="aa724c53356d3b4dd10ec752edff87fe8fc39d8d" translate="yes" xml:space="preserve">
          <source>[&amp;gt; [ &lt;a href=&quot;#tag-spec&quot;&gt;tag-spec&lt;/a&gt; ] { |&lt;a href=&quot;#tag-spec&quot;&gt;tag-spec&lt;/a&gt; } ]</source>
          <target state="translated">[&amp;gt; [ &lt;a href=&quot;#tag-spec&quot;&gt;태그 사양&lt;/a&gt; ] {| &lt;a href=&quot;#tag-spec&quot;&gt;태그 사양&lt;/a&gt; }]</target>
        </trans-unit>
        <trans-unit id="10f94b240e531c8610f1704309aff71882f6eef1" translate="yes" xml:space="preserve">
          <source>[&amp;gt;`Off|`On] list means that to match this list, you should at least be able to match `Off and `On, without argument. [&amp;lt;`On|`Off|`Number of int] means that f may be applied to `Off, `On (both without argument), or `Numbern where n is an integer. The &amp;gt; and &amp;lt; inside the variant types show that they may still be refined, either by defining more tags or by allowing less. As such, they contain an implicit type variable. Because each of the variant types appears only once in the whole type, their implicit type variables are not shown.</source>
          <target state="translated">[&amp;gt;`Off |`On] 목록은이 목록과 일치하려면 최소한 인수없이`Off 및`On과 일치 할 수 있어야합니다. [&amp;lt;`On |`Off |`Number of int]는 f가`Off,`On (둘 다 인수없이) 또는`Numbern (n은 정수)에 적용될 수 있음을 의미합니다. 변형 유형 내부의&amp;gt; 및 &amp;lt;는 더 많은 태그를 정의하거나 더 적게 허용하여 여전히 세분화 될 수 있음을 보여줍니다. 따라서 암시 적 유형 변수를 포함합니다. 각 변형 유형은 전체 유형에서 한 번만 나타나기 때문에 암시 적 유형 변수는 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dad6903b1e8f6d74baf8ed15aaa7c98dec0bfe16" translate="yes" xml:space="preserve">
          <source>[&amp;lt; [|] &lt;a href=&quot;#tag-spec-full&quot;&gt;tag-spec-full&lt;/a&gt; { |&lt;a href=&quot;#tag-spec-full&quot;&gt;tag-spec-full&lt;/a&gt; } [ &amp;gt; { `&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; }&lt;sup&gt;+&lt;/sup&gt; ] ]</source>
          <target state="translated">[&amp;lt;[|] &lt;a href=&quot;#tag-spec-full&quot;&gt;태그 사양 전체&lt;/a&gt; {| &lt;a href=&quot;#tag-spec-full&quot;&gt;태그 사양 전체&lt;/a&gt; } [&amp;gt; {` &lt;a href=&quot;names#tag-name&quot;&gt;태그 이름&lt;/a&gt; } &lt;sup&gt;+&lt;/sup&gt; ]]</target>
        </trans-unit>
        <trans-unit id="91eb9225aeaaf5af7e440003eeb19a446fe1d920" translate="yes" xml:space="preserve">
          <source>[(&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt; [:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;] )] { &lt;a href=&quot;#class-field&quot;&gt;class-field&lt;/a&gt; }</source>
          <target state="translated">[( &lt;a href=&quot;patterns#pattern&quot;&gt;패턴&lt;/a&gt; [: &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; ])] { &lt;a href=&quot;#class-field&quot;&gt;클래스 필드&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="d332459a8ba97fd50bbeae640304bc22182f343f" translate="yes" xml:space="preserve">
          <source>[-] (0&amp;hellip;9) { 0&amp;hellip;9 ∣ _ }</source>
          <target state="translated">[-] (0&amp;hellip;9) { 0&amp;hellip;9 ∣ _ }</target>
        </trans-unit>
        <trans-unit id="473bd68ac267366051f84c875ad4ace6aebe4cae" translate="yes" xml:space="preserve">
          <source>[-] (0&amp;hellip;9) { 0&amp;hellip;9 ∣ _ }[g&amp;hellip;z∣ G&amp;hellip;Z]</source>
          <target state="translated">[-] (0&amp;hellip;9) { 0&amp;hellip;9 ∣ _ }[g&amp;hellip;z∣ G&amp;hellip;Z]</target>
        </trans-unit>
        <trans-unit id="6cb7650e47eb2575d7ca0470858a5635efb70add" translate="yes" xml:space="preserve">
          <source>[-] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ } [. { 0&amp;hellip;9∣ _ }] [(e∣ E) [+∣ -] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ }]</source>
          <target state="translated">[-] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ } [. { 0&amp;hellip;9∣ _ }] [(e∣ E) [+∣ -] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ }]</target>
        </trans-unit>
        <trans-unit id="2c7b19cb3116ea384d28dd687eadb2b073f38b7b" translate="yes" xml:space="preserve">
          <source>[-] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ } [. { 0&amp;hellip;9∣ _ }] [(e∣ E) [+∣ -] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ }] [g&amp;hellip;z∣ G&amp;hellip;Z]</source>
          <target state="translated">[-] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ } [. { 0&amp;hellip;9∣ _ }] [(e∣ E) [+∣ -] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ }] [g&amp;hellip;z∣ G&amp;hellip;Z]</target>
        </trans-unit>
        <trans-unit id="a61094b365d5af7b66e564ec21f930d790211eec" translate="yes" xml:space="preserve">
          <source>[-] (0b∣ 0B) (0&amp;hellip;1) { 0&amp;hellip;1∣ _ }</source>
          <target state="translated">[-] (0b∣ 0B) (0&amp;hellip;1) { 0&amp;hellip;1∣ _ }</target>
        </trans-unit>
        <trans-unit id="e83c9c47ab710c338712ade1bc4a393a41751ad2" translate="yes" xml:space="preserve">
          <source>[-] (0b∣ 0B) (0&amp;hellip;1) { 0&amp;hellip;1∣ _ } [g&amp;hellip;z∣ G&amp;hellip;Z]</source>
          <target state="translated">[-] (0b∣ 0B) (0&amp;hellip;1) { 0&amp;hellip;1∣ _ } [g&amp;hellip;z∣ G&amp;hellip;Z]</target>
        </trans-unit>
        <trans-unit id="bacf6a0cec197455f287a5adce559a8f020b3e02" translate="yes" xml:space="preserve">
          <source>[-] (0o∣ 0O) (0&amp;hellip;7) { 0&amp;hellip;7∣ _ }</source>
          <target state="translated">[-] (0o∣ 0O) (0&amp;hellip;7) { 0&amp;hellip;7∣ _ }</target>
        </trans-unit>
        <trans-unit id="cc29186baa94b0abab18a9f475047bb35e1fc9a2" translate="yes" xml:space="preserve">
          <source>[-] (0o∣ 0O) (0&amp;hellip;7) { 0&amp;hellip;7∣ _ } [g&amp;hellip;z∣ G&amp;hellip;Z]</source>
          <target state="translated">[-] (0o∣ 0O) (0&amp;hellip;7) { 0&amp;hellip;7∣ _ } [g&amp;hellip;z∣ G&amp;hellip;Z]</target>
        </trans-unit>
        <trans-unit id="fe40a287c598706fca1aade30b36d274123cdd57" translate="yes" xml:space="preserve">
          <source>[-] (0x∣ 0X) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ }</source>
          <target state="translated">[-] (0x∣ 0X) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ }</target>
        </trans-unit>
        <trans-unit id="62ffbd17c903f06a785acfdcfb392df90e8cf1e8" translate="yes" xml:space="preserve">
          <source>[-] (0x∣ 0X) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ } [. { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ }] [(p∣ P) [+∣ -] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ }]</source>
          <target state="translated">[-] (0x∣ 0X) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ } [. { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ }] [(p∣ P) [+∣ -] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ }]</target>
        </trans-unit>
        <trans-unit id="422ae3d0903630a4c50138d05c0e8a498cb95069" translate="yes" xml:space="preserve">
          <source>[-] (0x∣ 0X) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ } [. { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ }] [(p∣ P) [+∣ -] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ }] [g&amp;hellip;z∣ G&amp;hellip;Z]</source>
          <target state="translated">[-] (0x∣ 0X) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ } [. { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ }] [(p∣ P) [+∣ -] (0&amp;hellip;9) { 0&amp;hellip;9∣ _ }] [g&amp;hellip;z∣ G&amp;hellip;Z]</target>
        </trans-unit>
        <trans-unit id="fca2e3a71d147da84be67f0e560ab01b47292baf" translate="yes" xml:space="preserve">
          <source>[-] (0x∣ 0X) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ } [g&amp;hellip;z∣ G&amp;hellip;Z]</source>
          <target state="translated">[-] (0x∣ 0X) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f∣ _ } [g&amp;hellip;z∣ G&amp;hellip;Z]</target>
        </trans-unit>
        <trans-unit id="d527c5d16c2e5a5291a799a508cda294dc70460a" translate="yes" xml:space="preserve">
          <source>[;;] ( &lt;a href=&quot;modules#definition&quot;&gt;definition&lt;/a&gt; ∣ &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; } ) { [;;] &lt;a href=&quot;modules#definition&quot;&gt;definition&lt;/a&gt; ∣ ;;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; } } [;;]</source>
          <target state="translated">[;;] ( &lt;a href=&quot;modules#definition&quot;&gt;정의&lt;/a&gt; ∣ &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;항목 속성&lt;/a&gt; }) {[;;] &lt;a href=&quot;modules#definition&quot;&gt;정의&lt;/a&gt; ∣ ;; &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;항목 속성&lt;/a&gt; }} [;;]</target>
        </trans-unit>
        <trans-unit id="7163edf1f91d0eebff5427eae672e4d9cf5843d3" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; { ;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; } [;] ]</source>
          <target state="translated">[&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; { ;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; } [;] ]</target>
        </trans-unit>
        <trans-unit id="4d179c5500c82803598c1678e833f6bbaec0ee57" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; { ;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; } [ ; ] ]</source>
          <target state="translated">[ &lt;a href=&quot;#pattern&quot;&gt;패턴&lt;/a&gt; {; &lt;a href=&quot;#pattern&quot;&gt;패턴&lt;/a&gt; } [; ]]</target>
        </trans-unit>
        <trans-unit id="4fdc6cfd24896e6dc6cc850526aa2efc82121c21" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;#tag-spec-first&quot;&gt;tag-spec-first&lt;/a&gt; { |&lt;a href=&quot;#tag-spec&quot;&gt;tag-spec&lt;/a&gt; } ]</source>
          <target state="translated">[ &lt;a href=&quot;#tag-spec-first&quot;&gt;tag-spec-first&lt;/a&gt; {| &lt;a href=&quot;#tag-spec&quot;&gt;태그 사양&lt;/a&gt; }]</target>
        </trans-unit>
        <trans-unit id="7ae5c7c192768c8fe819028167bfdf1f70539395" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;#type-equation&quot;&gt;type-equation&lt;/a&gt;] [&lt;a href=&quot;#type-representation&quot;&gt;type-representation&lt;/a&gt;] { &lt;a href=&quot;#type-constraint&quot;&gt;type-constraint&lt;/a&gt; }</source>
          <target state="translated">[ &lt;a href=&quot;#type-equation&quot;&gt;유형 방정식&lt;/a&gt; ] [ &lt;a href=&quot;#type-representation&quot;&gt;유형 표현&lt;/a&gt; ] { &lt;a href=&quot;#type-constraint&quot;&gt;유형 제약&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="eb557ec36f883c7b8a8a2afb3047a4bc1856325e" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;#type-params&quot;&gt;type-params&lt;/a&gt;] &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;&lt;a href=&quot;#type-information&quot;&gt;type-information&lt;/a&gt;</source>
          <target state="translated">[ &lt;a href=&quot;#type-params&quot;&gt;type-params&lt;/a&gt; ] &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name &lt;/a&gt;&lt;a href=&quot;#type-information&quot;&gt;유형 정보&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6809e04c28f4434af2ef4e79379f732d256a70a" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;#variance&quot;&gt;variance&lt;/a&gt;] '&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;</source>
          <target state="translated">[ &lt;a href=&quot;#variance&quot;&gt;분산&lt;/a&gt; ] ' &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd52a26acaa62bbd70ddc4c699130c536a848817" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;typedecl#type-params&quot;&gt;type-params&lt;/a&gt;] &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;:=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; { &lt;a href=&quot;typedecl#type-constraint&quot;&gt;type-constraint&lt;/a&gt; }</source>
          <target state="translated">[&lt;a href=&quot;typedecl#type-params&quot;&gt;type-params&lt;/a&gt;] &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt;:=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; { &lt;a href=&quot;typedecl#type-constraint&quot;&gt;type-constraint&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="4c164a669568d725674f36078be81d4f3c7961a9" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;typedecl#variance&quot;&gt;variance&lt;/a&gt;] _</source>
          <target state="translated">[ &lt;a href=&quot;typedecl#variance&quot;&gt;분산&lt;/a&gt; ] _</target>
        </trans-unit>
        <trans-unit id="599aa502a5589fb3a6adecc0003ea60cd7943675" translate="yes" xml:space="preserve">
          <source>[&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; {,&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;} ]&lt;a href=&quot;names#class-path&quot;&gt;class-path&lt;/a&gt;</source>
          <target state="translated">[ &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; {, &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; }] &lt;a href=&quot;names#class-path&quot;&gt;클래스 경로&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7becd2f7108116acae7b49a97d7c92f66bc838c4" translate="yes" xml:space="preserve">
          <source>[@&lt;a href=&quot;#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</source>
          <target state="translated">[@&lt;a href=&quot;#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="a97816c7ac1508516fe749441f17b541f6dcf1ee" translate="yes" xml:space="preserve">
          <source>[@@&lt;a href=&quot;#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</source>
          <target state="translated">[@@&lt;a href=&quot;#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="fd2a6aca4a2be8058771e31cb975908901937c52" translate="yes" xml:space="preserve">
          <source>[@@@&lt;a href=&quot;#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</source>
          <target state="translated">[@@@&lt;a href=&quot;#attr-id&quot;&gt;attr-id&lt;/a&gt;&lt;a href=&quot;#attr-payload&quot;&gt;attr-payload&lt;/a&gt;]</target>
        </trans-unit>
        <trans-unit id="60d4d5c4116c206bd450f81da29e892eb2cfc4cc" translate="yes" xml:space="preserve">
          <source>[[&amp;gt;] `&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt;| &amp;hellip; |`&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;n&lt;/sub&gt;|`&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;n+1&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;n+1&lt;/sub&gt;| &amp;hellip; |`&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;n+m&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;n+m&lt;/sub&gt;]</source>
          <target state="translated">[[&amp;gt;] `&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;1&lt;/sub&gt;| &amp;hellip; |`&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;n&lt;/sub&gt;|`&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;n+1&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;n+1&lt;/sub&gt;| &amp;hellip; |`&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;n+m&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&amp;prime;&lt;sub&gt;n+m&lt;/sub&gt;]</target>
        </trans-unit>
        <trans-unit id="7b806d0e4f77e2e0284e335435cebcd99e7a7ce8" translate="yes" xml:space="preserve">
          <source>[[&amp;lt;] `&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;| &amp;hellip; |`&lt;a href=&quot;names#constr-name&quot;&gt;C&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;of&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;]</source>
          <target state="translated">[&amp;lt;] ' &lt;a href=&quot;names#constr-name&quot;&gt;C &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 의 &lt;a href=&quot;types#typexpr&quot;&gt;일반 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; | &amp;hellip; |` &lt;a href=&quot;names#constr-name&quot;&gt;C &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; of &lt;a href=&quot;types#typexpr&quot;&gt;typ &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; ]</target>
        </trans-unit>
        <trans-unit id="281ba5c5173bc37bf1a7dd71c6bf39e34b706f2e" translate="yes" xml:space="preserve">
          <source>[[&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; {,&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;} ]] &lt;a href=&quot;names#classtype-path&quot;&gt;classtype-path&lt;/a&gt;</source>
          <target state="translated">[[ &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; {, &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; }]] 클래스 유형 &lt;a href=&quot;names#classtype-path&quot;&gt;-경로&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3edaf48cc7b2a7dd234e24dfdfd72e38b7085745" translate="yes" xml:space="preserve">
          <source>[[?]&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;:] &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;-&amp;gt;&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;</source>
          <target state="translated">[[?] &lt;a href=&quot;lex#label-name&quot;&gt;레이블 이름&lt;/a&gt; :] &lt;a href=&quot;#typexpr&quot;&gt;typexpr-&lt;/a&gt; &amp;gt; &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1fdb79a53e34b6dece67887c1bdac5d4037750d1" translate="yes" xml:space="preserve">
          <source>[[?]&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;:] &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;-&amp;gt;&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;</source>
          <target state="translated">[[?] &lt;a href=&quot;lex#label-name&quot;&gt;레이블 이름&lt;/a&gt; :] &lt;a href=&quot;types#typexpr&quot;&gt;typexpr-&lt;/a&gt; &amp;gt; &lt;a href=&quot;#class-type&quot;&gt;클래스 유형&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="37d9466df26d58df397c13d44c392690fb44a7e1" translate="yes" xml:space="preserve">
          <source>[^character-set]</source>
          <target state="translated">[^character-set]</target>
        </trans-unit>
        <trans-unit id="7e9127ed709ebc3b2ec8ae101c18c49d92bb9145" translate="yes" xml:space="preserve">
          <source>[character-set]</source>
          <target state="translated">[character-set]</target>
        </trans-unit>
        <trans-unit id="6ed3105102954a4c5db0c3f02bc020ebe496dcb6" translate="yes" xml:space="preserve">
          <source>[mutable] &lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;</source>
          <target state="translated">[변경 가능] &lt;a href=&quot;names#field-name&quot;&gt;필드 이름&lt;/a&gt; : &lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb3a4b15b9df9538ce82dd3ac08074b0490cbc30" translate="yes" xml:space="preserve">
          <source>[mutable] &lt;a href=&quot;names#field-name&quot;&gt;field-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt; {&lt;a href=&quot;#attribute&quot;&gt;attribute&lt;/a&gt;}</source>
          <target state="translated">[변경 가능] &lt;a href=&quot;names#field-name&quot;&gt;필드 이름&lt;/a&gt; : &lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt; { &lt;a href=&quot;#attribute&quot;&gt;속성&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="06443cf549c345bc7626b16c688d241250965c11" translate="yes" xml:space="preserve">
          <source>[string]</source>
          <target state="translated">[string]</target>
        </trans-unit>
        <trans-unit id="2d934f0af3ee8393994f2178a9aaf1dfde4cfb36" translate="yes" xml:space="preserve">
          <source>[virtual] [[&lt;a href=&quot;#type-parameters&quot;&gt;type-parameters&lt;/a&gt;]] &lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt; {&lt;a href=&quot;expr#parameter&quot;&gt;parameter&lt;/a&gt;} [:&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;] =&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;</source>
          <target state="translated">[가상] ​​[[ &lt;a href=&quot;#type-parameters&quot;&gt;유형 매개 변수&lt;/a&gt; ]] &lt;a href=&quot;names#class-name&quot;&gt;클래스 이름&lt;/a&gt; { &lt;a href=&quot;expr#parameter&quot;&gt;매개 변수&lt;/a&gt; } [: &lt;a href=&quot;#class-type&quot;&gt;클래스 유형&lt;/a&gt; ] = &lt;a href=&quot;#class-expr&quot;&gt;클래스 표현식&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad86b23e23597d8ca554d7819990cc4c9fc9bec1" translate="yes" xml:space="preserve">
          <source>[virtual] [[&lt;a href=&quot;#type-parameters&quot;&gt;type-parameters&lt;/a&gt;]] &lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt;:&lt;a href=&quot;#class-type&quot;&gt;class-type&lt;/a&gt;</source>
          <target state="translated">[가상] ​​[[ &lt;a href=&quot;#type-parameters&quot;&gt;유형 매개 변수&lt;/a&gt; ]] &lt;a href=&quot;names#class-name&quot;&gt;클래스 이름&lt;/a&gt; : &lt;a href=&quot;#class-type&quot;&gt;클래스 유형&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="069e56de2f322b59836b7247c8a473377b4491fe" translate="yes" xml:space="preserve">
          <source>[virtual] [[&lt;a href=&quot;#type-parameters&quot;&gt;type-parameters&lt;/a&gt;]] &lt;a href=&quot;names#class-name&quot;&gt;class-name&lt;/a&gt;=&lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt;</source>
          <target state="translated">[가상] ​​[[ &lt;a href=&quot;#type-parameters&quot;&gt;유형 매개 변수&lt;/a&gt; ]] &lt;a href=&quot;names#class-name&quot;&gt;클래스 이름&lt;/a&gt; = &lt;a href=&quot;#class-body-type&quot;&gt;클래스 본문 유형&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="779656c2e21df39bbf7b04df8d51a67fffe27328" translate="yes" xml:space="preserve">
          <source>[|&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; { ;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; } [;] |]</source>
          <target state="translated">[|&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; { ;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; } [;] |]</target>
        </trans-unit>
        <trans-unit id="d28304d85650beb4b7ca0b1cd85ad4393d19fef0" translate="yes" xml:space="preserve">
          <source>[|&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; { ;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt; } [ ; ] |]</source>
          <target state="translated">[| &lt;a href=&quot;#pattern&quot;&gt;패턴&lt;/a&gt; {; &lt;a href=&quot;#pattern&quot;&gt;패턴&lt;/a&gt; } [; ] |]</target>
        </trans-unit>
        <trans-unit id="ab6705cd22604179bf5ed99551e23a447c9c18d9" translate="yes" xml:space="preserve">
          <source>[|&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt;|]</source>
          <target state="translated">[|&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt;|]</target>
        </trans-unit>
        <trans-unit id="ebcf6c5142718c920ce70ae1f57d451f361dfc5c" translate="yes" xml:space="preserve">
          <source>[||]</source>
          <target state="translated">[||]</target>
        </trans-unit>
        <trans-unit id="d83bdb55caec3e2da5eb3c08a6d885915882f6a2" translate="yes" xml:space="preserve">
          <source>\ ( \ ∣ &quot; ∣ ' ∣ n ∣ t ∣ b ∣ r ∣ space )</source>
          <target state="translated">\ (\ ∣ &quot;∣ '∣ n ∣ t ∣ b ∣ r ∣ 공백)</target>
        </trans-unit>
        <trans-unit id="b4231f0670f5f242554b99dbd1517d52ef7e1f81" translate="yes" xml:space="preserve">
          <source>\ (0&amp;hellip;9) (0&amp;hellip;9) (0&amp;hellip;9)</source>
          <target state="translated">\ (0&amp;hellip;9) (0&amp;hellip;9) (0&amp;hellip;9)</target>
        </trans-unit>
        <trans-unit id="ab006bb8aacdf6e68299bc1dffccc9bcc8ac3eaf" translate="yes" xml:space="preserve">
          <source>\&quot;</source>
          <target state="translated">\&quot;</target>
        </trans-unit>
        <trans-unit id="9ca863000c0131ce2b74e96a2de49fddf5ae1e10" translate="yes" xml:space="preserve">
          <source>\'</source>
          <target state="translated">\'</target>
        </trans-unit>
        <trans-unit id="9e94758983980504af303ef297fd2bf9d9cea063" translate="yes" xml:space="preserve">
          <source>\\</source>
          <target state="translated">\\</target>
        </trans-unit>
        <trans-unit id="4629ca1b60e263bdc4326334b23323e0434717a5" translate="yes" xml:space="preserve">
          <source>\b</source>
          <target state="translated">\b</target>
        </trans-unit>
        <trans-unit id="3c0a62cb2906cc36c4a919715511fc14bd0b1cfd" translate="yes" xml:space="preserve">
          <source>\ddd</source>
          <target state="translated">\ddd</target>
        </trans-unit>
        <trans-unit id="ef7e6794ca9c6a06b54b66f279237fb8daaaeea8" translate="yes" xml:space="preserve">
          <source>\n</source>
          <target state="translated">\n</target>
        </trans-unit>
        <trans-unit id="1dcf1062839b7f3fa08ae441ebac44ab82ff2e68" translate="yes" xml:space="preserve">
          <source>\newline { space ∣ tab }</source>
          <target state="translated">\ newline {공백 ∣ 탭}</target>
        </trans-unit>
        <trans-unit id="f694a8c8e5720726fe11abb727991dbfce0136de" translate="yes" xml:space="preserve">
          <source>\o (0&amp;hellip;3) (0&amp;hellip;7) (0&amp;hellip;7)</source>
          <target state="translated">\o (0&amp;hellip;3) (0&amp;hellip;7) (0&amp;hellip;7)</target>
        </trans-unit>
        <trans-unit id="af2d76adab6d6c193d82eb1139d9e333cf65dd47" translate="yes" xml:space="preserve">
          <source>\oooo</source>
          <target state="translated">\oooo</target>
        </trans-unit>
        <trans-unit id="f12c84902108895980702c88db900ceea2d2ec01" translate="yes" xml:space="preserve">
          <source>\r</source>
          <target state="translated">\r</target>
        </trans-unit>
        <trans-unit id="16f8ba5a70c8e28946b3f0c93ffa5aa96ba95209" translate="yes" xml:space="preserve">
          <source>\space</source>
          <target state="translated">\space</target>
        </trans-unit>
        <trans-unit id="8bf81043e29dfc96a6fe1f30f7116f552de6e7d7" translate="yes" xml:space="preserve">
          <source>\t</source>
          <target state="translated">\t</target>
        </trans-unit>
        <trans-unit id="3ba84b441afbba0b1e2988ce22de81d518262043" translate="yes" xml:space="preserve">
          <source>\u{ { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f }&lt;sup&gt;+&lt;/sup&gt;}</source>
          <target state="translated">\u{ { 0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f }&lt;sup&gt;+&lt;/sup&gt;}</target>
        </trans-unit>
        <trans-unit id="2b81fd78bdbb47b0a5ab4c46880e42421325e8df" translate="yes" xml:space="preserve">
          <source>\x (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f)</source>
          <target state="translated">\x (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f) (0&amp;hellip;9∣ A&amp;hellip;F∣ a&amp;hellip;f)</target>
        </trans-unit>
        <trans-unit id="c44b0007f5fd55a953e09798658cb34da7bff02a" translate="yes" xml:space="preserve">
          <source>\xhh</source>
          <target state="translated">\xhh</target>
        </trans-unit>
        <trans-unit id="1288030afca6d49c1dce35c928f3a45658b3416e" translate="yes" xml:space="preserve">
          <source>`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;</source>
          <target state="translated">`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5aa8a0d688e811d242601925f92373e777ce4cef" translate="yes" xml:space="preserve">
          <source>`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; [ of [&amp;amp;] &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; { &amp;amp;&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; } ]</source>
          <target state="translated">` &lt;a href=&quot;names#tag-name&quot;&gt;태그 이름&lt;/a&gt; [of [&amp;amp;] &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; {&amp;amp; &lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; }]</target>
        </trans-unit>
        <trans-unit id="be1dc47e3d6863a7150f87ad565a12a951c55d0d" translate="yes" xml:space="preserve">
          <source>`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; [ of&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; ]</source>
          <target state="translated">`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt; [ of&lt;a href=&quot;#typexpr&quot;&gt;typexpr&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="0d7e267804f3a59e590fa4fca005068eefe79eac" translate="yes" xml:space="preserve">
          <source>`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;(&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;, &amp;hellip; ,&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt;)</source>
          <target state="translated">` &lt;a href=&quot;names#tag-name&quot;&gt;태그 이름&lt;/a&gt; ( &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ,&amp;hellip;, &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt; )</target>
        </trans-unit>
        <trans-unit id="af146e2e56d33085b35edb85f563497a0b676506" translate="yes" xml:space="preserve">
          <source>`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="589c478ac1da3277879e28e45c6d0d868a9a6ad6" translate="yes" xml:space="preserve">
          <source>`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;</source>
          <target state="translated">`&lt;a href=&quot;names#tag-name&quot;&gt;tag-name&lt;/a&gt;&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d701b7ecdfa0b9cb1d420b43c29ef0f3936f8e4" translate="yes" xml:space="preserve">
          <source>``Shut down'' a connection established with &lt;a href=&quot;unix#VALopen_connection&quot;&gt;&lt;code&gt;Unix.open_connection&lt;/code&gt;&lt;/a&gt;; that is, transmit an end-of-file condition to the server reading on the other side of the connection.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_connection&quot;&gt; &lt;code&gt;Unix.open_connection&lt;/code&gt; 으로&lt;/a&gt; 설정된 연결을``종료 ''합니다 . 즉, 연결의 다른 쪽에서 읽는 서버에 파일 끝 조건을 전송합니다.</target>
        </trans-unit>
        <trans-unit id="d97864d59da3aa41f746baaafd3463b784bc5abc" translate="yes" xml:space="preserve">
          <source>``Shut down'' a connection established with &lt;a href=&quot;unix#VALopen_connection&quot;&gt;&lt;code&gt;Unix.open_connection&lt;/code&gt;&lt;/a&gt;; that is, transmit an end-of-file condition to the server reading on the other side of the connection. This does not fully close the file descriptor associated with the channel, which you must remember to free via &lt;a href=&quot;stdlib#VALclose_in&quot;&gt;&lt;code&gt;close_in&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unix#VALopen_connection&quot;&gt; &lt;code&gt;Unix.open_connection&lt;/code&gt; 으로&lt;/a&gt; 설정된 연결을``종료 ''합니다 . 즉, 연결의 다른 쪽에서 읽는 서버에 파일 끝 조건을 전송합니다. 이것은 채널과 관련된 파일 설명자를 완전히 닫지 않으므로 &lt;a href=&quot;stdlib#VALclose_in&quot;&gt; &lt;code&gt;close_in&lt;/code&gt; 을&lt;/a&gt; 통해 해제 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="716971f89f753fc7aad67107c265548c7d9791d3" translate="yes" xml:space="preserve">
          <source>``Shut down'' a connection established with &lt;a href=&quot;unixlabels#VALopen_connection&quot;&gt;&lt;code&gt;UnixLabels.open_connection&lt;/code&gt;&lt;/a&gt;; that is, transmit an end-of-file condition to the server reading on the other side of the connection.</source>
          <target state="translated">&lt;a href=&quot;unixlabels#VALopen_connection&quot;&gt; &lt;code&gt;UnixLabels.open_connection&lt;/code&gt; 으로&lt;/a&gt; 설정된 연결을``종료 ''합니다 . 즉, 연결의 다른 쪽에서 읽는 서버에 파일 끝 조건을 전송합니다.</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="ea5d250a9bdc29bd5f4b1349eff20396c9d6398a" translate="yes" xml:space="preserve">
          <source>a &lt;em&gt;metadata file&lt;/em&gt;, part of the OCaml distribution</source>
          <target state="translated">&lt;em&gt;메타 데이터 파일&lt;/em&gt; 은 OCaml의 분포의 일부</target>
        </trans-unit>
        <trans-unit id="3627b94701cbc5c760ad13bdc0b33a3b8054c03e" translate="yes" xml:space="preserve">
          <source>a byte sequence or string used as buffer</source>
          <target state="translated">버퍼로 사용되는 바이트 시퀀스 또는 문자열</target>
        </trans-unit>
        <trans-unit id="410ad4856c009112cb4466316bac03d480442255" translate="yes" xml:space="preserve">
          <source>a comparison function, e.g.Stdlib.compare</source>
          <target state="translated">비교 함수, egStdlib.compare</target>
        </trans-unit>
        <trans-unit id="6ffd5a6bca2d01c99caa3fbbfd548e1dd1dc49fc" translate="yes" xml:space="preserve">
          <source>a function to be applied</source>
          <target state="translated">적용 할 기능</target>
        </trans-unit>
        <trans-unit id="0f0ee58df51bd23faa083dba2ed61cb6a7c8e44a" translate="yes" xml:space="preserve">
          <source>a length</source>
          <target state="translated">길이</target>
        </trans-unit>
        <trans-unit id="7df0657a72d73073160443670ebf5cfedadba059" translate="yes" xml:space="preserve">
          <source>a library that provides the bytecode interpreter, the memory manager, and the standard primitives;</source>
          <target state="translated">바이트 코드 인터프리터, 메모리 관리자 및 표준 프리미티브를 제공하는 라이브러리;</target>
        </trans-unit>
        <trans-unit id="8a66798daedccc860fc63fdf1ae2b663c64b1042" translate="yes" xml:space="preserve">
          <source>a non empty sequence of alphanumeric or &lt;code&gt;_&lt;/code&gt; characters,</source>
          <target state="translated">비어 있지 않은 영숫자 또는 &lt;code&gt;_&lt;/code&gt; 문자 시퀀스</target>
        </trans-unit>
        <trans-unit id="bb4562ef2047fcddffcf8799aaa36e3a820d8e26" translate="yes" xml:space="preserve">
          <source>a position in a string, array or byte sequence</source>
          <target state="translated">문자열, 배열 또는 바이트 시퀀스의 위치</target>
        </trans-unit>
        <trans-unit id="3597e8b38da36ab0c1d981d56037dc661f5feac2" translate="yes" xml:space="preserve">
          <source>a scanning indication (see scanning &lt;a href=&quot;scanf#indication&quot;&gt;&lt;i&gt;Scanning indications in format strings&lt;/i&gt;&lt;/a&gt;) has been encountered,</source>
          <target state="translated">스캐닝 표시 (스캐닝 &lt;a href=&quot;scanf#indication&quot;&gt;&lt;i&gt;문자열 형식의 스캐닝 표시&lt;/i&gt;&lt;/a&gt; 참조 )가 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="6c98cfe033b7435d226fa7c4e0c163564903b703" translate="yes" xml:space="preserve">
          <source>a whitespace has been found (see &lt;a href=&quot;scanf#space&quot;&gt;&lt;i&gt;The space character in format strings&lt;/i&gt;&lt;/a&gt;),</source>
          <target state="translated">공백이 발견되었습니다 ( &lt;a href=&quot;scanf#space&quot;&gt;&lt;i&gt;문자열 형식의 공백 문자&lt;/i&gt;&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="0f12541afcce175fb34bb05a79c95b76e765488b" translate="yes" xml:space="preserve">
          <source>access</source>
          <target state="translated">access</target>
        </trans-unit>
        <trans-unit id="73468898c9988e2f9e409b93e8bff16eaa79c0ba" translate="yes" xml:space="preserve">
          <source>alarm</source>
          <target state="translated">alarm</target>
        </trans-unit>
        <trans-unit id="ddb7aa66cca7d817b1bc050ddff1df3a3d3313a2" translate="yes" xml:space="preserve">
          <source>alias for &lt;a href=&quot;obj#TYPEt&quot;&gt;&lt;code&gt;Obj.t&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;obj#TYPEt&quot;&gt; &lt;code&gt;Obj.t&lt;/code&gt; 의&lt;/a&gt; 별칭</target>
        </trans-unit>
        <trans-unit id="7f245e454c594b6a6e02040aa04d0a87b60ce23e" translate="yes" xml:space="preserve">
          <source>all options</source>
          <target state="translated">모든 옵션</target>
        </trans-unit>
        <trans-unit id="d90ec074822453e3c07fb7ab40474dcc71b73158" translate="yes" xml:space="preserve">
          <source>all warnings</source>
          <target state="translated">모든 경고</target>
        </trans-unit>
        <trans-unit id="161d19cec4448cddf6f1df51bee30d4aee2ae72c" translate="yes" xml:space="preserve">
          <source>allocation functions (to create structured OCaml objects)</source>
          <target state="translated">할당 함수 (구조화 된 OCaml 객체 생성)</target>
        </trans-unit>
        <trans-unit id="6656018ac96d0295d887ff2893ba9af66ae16af2" translate="yes" xml:space="preserve">
          <source>always</source>
          <target state="translated">always</target>
        </trans-unit>
        <trans-unit id="c048122841cd0af39592cb281c9fb203718804c1" translate="yes" xml:space="preserve">
          <source>always raise Not_found</source>
          <target state="translated">항상 Not_found를 올리십시오.</target>
        </trans-unit>
        <trans-unit id="af1ecbcd070942bfb49c0a12b9a7ec1efd9ba5ea" translate="yes" xml:space="preserve">
          <source>always return 1</source>
          <target state="translated">항상 1을 반환</target>
        </trans-unit>
        <trans-unit id="21c8e94591336deee254ea0cc7c2b84a3db46c0a" translate="yes" xml:space="preserve">
          <source>always returns [|1|] (since 2.00)</source>
          <target state="translated">항상 [| 1 |]을 반환합니다 (2.00 이후).</target>
        </trans-unit>
        <trans-unit id="1a99e3d4f923f05ce72c18387d14c99c8d94a725" translate="yes" xml:space="preserve">
          <source>an arbitrary sequence of characters enclosed by a pair of matching parentheses or curly brackets. An escaped &lt;code&gt;$&lt;/code&gt; character is a &lt;code&gt;$&lt;/code&gt; that immediately follows a backslash character; it then stands for a plain &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="translated">일치하는 괄호 또는 중괄호 쌍으로 묶인 임의의 문자 시퀀스. 이스케이프 된 &lt;code&gt;$&lt;/code&gt; 문자는 백 슬래시 문자 바로 뒤에 오는 &lt;code&gt;$&lt;/code&gt; 입니다. 그런 다음 일반 &lt;code&gt;$&lt;/code&gt; 를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="f561344ac08966f1d833c5f80ae36885b0ccc2db" translate="yes" xml:space="preserve">
          <source>an ephemeron cf &lt;a href=&quot;ephemeron&quot;&gt;&lt;code&gt;Ephemeron&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">에페 메론 cf &lt;a href=&quot;ephemeron&quot;&gt; &lt;code&gt;Ephemeron&lt;/code&gt; &lt;/a&gt; 메론</target>
        </trans-unit>
        <trans-unit id="e268d2a4a07f3246144968e6813834db67163851" translate="yes" xml:space="preserve">
          <source>an ephemeron with an arbitrary number of keys of the same type</source>
          <target state="translated">동일한 유형의 임의 개수의 키가있는 천체력</target>
        </trans-unit>
        <trans-unit id="d6cd3ac13cb54892b26741dbb166711f8f8454ec" translate="yes" xml:space="preserve">
          <source>an ephemeron with one key</source>
          <target state="translated">하나의 키를 가진 천체력</target>
        </trans-unit>
        <trans-unit id="5370fc85d98d86b50c6ae717df05ae2178d72709" translate="yes" xml:space="preserve">
          <source>an ephemeron with two keys</source>
          <target state="translated">두 개의 키가있는 천체력</target>
        </trans-unit>
        <trans-unit id="17cd4ed7af141353dc06d425f19ec6f0174f1e40" translate="yes" xml:space="preserve">
          <source>an operation mode or a flag list</source>
          <target state="translated">작동 모드 또는 플래그 목록</target>
        </trans-unit>
        <trans-unit id="56e68bf7052e323752495fd36eb5da81f37ffaa4" translate="yes" xml:space="preserve">
          <source>an unboxed integer;</source>
          <target state="translated">박싱되지 않은 정수;</target>
        </trans-unit>
        <trans-unit id="7d7685d508f910a53eb29bb82f0913de7a8437fc" translate="yes" xml:space="preserve">
          <source>analysis of the source files;</source>
          <target state="translated">소스 파일 분석;</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="d0949396bb159e985c5c968ec72002296c91a20c" translate="yes" xml:space="preserve">
          <source>and ( &amp;hellip; ) for the other grouping situations.</source>
          <target state="translated">다른 그룹화 상황에 대해서는 (&amp;hellip;).</target>
        </trans-unit>
        <trans-unit id="3e243fd1598527c063c99e3c63851d61bb6bfc77" translate="yes" xml:space="preserve">
          <source>and (&lt;a href=&quot;lex#core-operator-char&quot;&gt;core-operator-char&lt;/a&gt; ∣ &amp;lt;) { &lt;a href=&quot;indexops#dot-operator-char&quot;&gt;dot-operator-char&lt;/a&gt; }</source>
          <target state="translated">및 ( &lt;a href=&quot;lex#core-operator-char&quot;&gt;core-operator-char&lt;/a&gt; ∣ &amp;lt;) { &lt;a href=&quot;indexops#dot-operator-char&quot;&gt;dot-operator-char&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="9922f3e883eaa547f62f38fc740e5bebdd032962" translate="yes" xml:space="preserve">
          <source>and S with module M = N denotes the signature</source>
          <target state="translated">모듈 M = N 인 S는 서명을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7135f68d2f2ba0ad3e5c9525d8a98fd85e8d326a" translate="yes" xml:space="preserve">
          <source>and a &lt;em&gt;trace file&lt;/em&gt;, generated by the runtime in the program being traced.</source>
          <target state="translated">및 &lt;em&gt;추적&lt;/em&gt; 중인 프로그램에서 런타임에 의해 생성 된 &lt;em&gt;추적 파일&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="aae5f607273fb6b8801476b6d4cb87cc1e985618" translate="yes" xml:space="preserve">
          <source>and as a result obtain a Mylib compilation unit, containing physically A and B as submodules, and with no dependencies on their respective compilation units. Here is a concrete example of a possible alternative approach:</source>
          <target state="translated">그 결과 물리적으로 A와 B를 하위 모듈로 포함하고 각각의 컴파일 단위에 대한 종속성이없는 Mylib 컴파일 단위를 얻습니다. 가능한 대안 접근법의 구체적인 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e29eacfd66e6128d91b4e2e0d0efc56f09f7ab0" translate="yes" xml:space="preserve">
          <source>and attach several observers to the same object:</source>
          <target state="translated">동일한 개체에 여러 관찰자를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="04afbc59ec07d5cd168b50a57fcdba7a2dc031d7" translate="yes" xml:space="preserve">
          <source>and even use the alternative syntax for declaring functions:</source>
          <target state="translated">함수를 선언하기 위해 대체 구문을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6469a87a5b418647e9fa1d15ae7d5a10f99bdded" translate="yes" xml:space="preserve">
          <source>and link mod1.cmo before mod2.cmo.</source>
          <target state="translated">mod2.cmo 전에 mod1.cmo를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="2f3522d8409fab2c8bd7a9a935e5958b1545b923" translate="yes" xml:space="preserve">
          <source>and not</source>
          <target state="translated">그리고 아닙니다</target>
        </trans-unit>
        <trans-unit id="ccb7579c980b6977ec641cb0d678c02d8d41f49d" translate="yes" xml:space="preserve">
          <source>and one on the result</source>
          <target state="translated">그리고 결과에 하나</target>
        </trans-unit>
        <trans-unit id="d4c66020d5a4a796b432d2d3f2eb08a6fbfd7761" translate="yes" xml:space="preserve">
          <source>and structured input-output (the functions from the &lt;a href=&quot;marshal&quot;&gt;&lt;code&gt;Marshal&lt;/code&gt;&lt;/a&gt; module, as well as &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt;&lt;code&gt;output_value&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdlib#VALinput_value&quot;&gt;&lt;code&gt;input_value&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">구조화 된 입력 - 출력 (로부터 기능 &lt;a href=&quot;marshal&quot;&gt; &lt;code&gt;Marshal&lt;/code&gt; &lt;/a&gt; 모듈뿐만 아니라 &lt;a href=&quot;stdlib#VALoutput_value&quot;&gt; &lt;code&gt;output_value&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stdlib#VALinput_value&quot;&gt; &lt;code&gt;input_value&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="144cf0ff7c73bffecc1589a4d490aabaa5c658aa" translate="yes" xml:space="preserve">
          <source>and the compiler will emit warning 50.</source>
          <target state="translated">컴파일러는 경고 50을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="9890a7a2830cc4814f3a238d40f7dd8ee611982a" translate="yes" xml:space="preserve">
          <source>and the system will automatically add the -custom and -cclib -lmylib options, achieving the same effect as</source>
          <target state="translated">시스템은 자동으로 -custom 및 -cclib -lmylib 옵션을 추가하여 다음과 같은 효과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="4b1c85b81e1502a02da4141f1ac7368f38fd4b9b" translate="yes" xml:space="preserve">
          <source>and the system will automatically add the -dllib -lmylib option, achieving the same effect as</source>
          <target state="translated">시스템은 -dllib -lmylib 옵션을 자동으로 추가하여 다음과 같은 효과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="7e6c1e93df972fdb89a4efdabb2e6a30ae642fd5" translate="yes" xml:space="preserve">
          <source>and then apply them using this convenient syntax:</source>
          <target state="translated">다음 편리한 구문을 사용하여 적용합니다.</target>
        </trans-unit>
        <trans-unit id="be865b252a2a8e9c53f840f52c864386e874af8b" translate="yes" xml:space="preserve">
          <source>and then ask users to provide the -custom and -cclib -lmylib options themselves at link-time:</source>
          <target state="translated">그런 다음 사용자에게 링크 타임에 -custom 및 -cclib -lmylib 옵션을 직접 제공하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="478c17c32f1bc3336788616eaad90d7da7f5fbd4" translate="yes" xml:space="preserve">
          <source>and then:</source>
          <target state="translated">그리고:</target>
        </trans-unit>
        <trans-unit id="1d22cfbed814dcb099f0e8e67505f5a70d8eb06c" translate="yes" xml:space="preserve">
          <source>and universally quantified object methods:</source>
          <target state="translated">보편적으로 정량화 된 객체 방법 :</target>
        </trans-unit>
        <trans-unit id="f5f3c67631f2732767dad5f715563cd89ad668cf" translate="yes" xml:space="preserve">
          <source>and used like this:</source>
          <target state="translated">다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c96e234c3b1fd505f14ec96a363efd96eb569033" translate="yes" xml:space="preserve">
          <source>and, &lt;a href=&quot;expr#hevea_manual.kwd21&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;typedecl#hevea_manual.kwd93&quot;&gt;7.8.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd122&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd144&quot;&gt;7.9.3&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd146&quot;&gt;7.9.4&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd149&quot;&gt;7.9.5&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd154&quot;&gt;7.10&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd183&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;manual024#hevea_manual.kwd207&quot;&gt;8.2&lt;/a&gt;, &lt;a href=&quot;firstclassmodules#hevea_manual.kwd215&quot;&gt;8.5&lt;/a&gt;</source>
          <target state="translated">및 &lt;a href=&quot;expr#hevea_manual.kwd21&quot;&gt;7.7&lt;/a&gt; , &lt;a href=&quot;typedecl#hevea_manual.kwd93&quot;&gt;7.8.1&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd122&quot;&gt;7.9.2&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd144&quot;&gt;7.9.3&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd146&quot;&gt;7.9.4&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd149&quot;&gt;7.9.5&lt;/a&gt; , &lt;a href=&quot;modtypes#hevea_manual.kwd154&quot;&gt;7.10&lt;/a&gt; , &lt;a href=&quot;modules#hevea_manual.kwd183&quot;&gt;7.11&lt;/a&gt; , &lt;a href=&quot;manual024#hevea_manual.kwd207&quot;&gt;8.2&lt;/a&gt; , &lt;a href=&quot;firstclassmodules#hevea_manual.kwd215&quot;&gt;8.5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c78a0dbec27997c1afa661cc0130d0ef25877671" translate="yes" xml:space="preserve">
          <source>and-operator</source>
          <target state="translated">and-operator</target>
        </trans-unit>
        <trans-unit id="c5fe0200d1c7a5139bd18fd22268c4ca8bf45e90" translate="yes" xml:space="preserve">
          <source>any</source>
          <target state="translated">any</target>
        </trans-unit>
        <trans-unit id="97aa373d2868b633a71970cbafb44ac0d10e9bd5" translate="yes" xml:space="preserve">
          <source>arg1_type -&amp;gt; arg2_type -&amp;gt; ... -&amp;gt; return_type. For example, the type inferred for insert, 'a -&amp;gt; 'a list -&amp;gt; 'a list, means that insert takes two arguments, an element of any type 'a and a list with elements of the same type 'a and returns a list of the same type.</source>
          <target state="translated">arg1_type-&amp;gt; arg2_type-&amp;gt; ...-&amp;gt; return_type. 예를 들어, 삽입에 대해 유추 된 유형 'a-&amp;gt;'a list-&amp;gt; 'a list는 삽입이 두 개의 인수 (모든 유형'a의 요소와 동일한 유형 'a의 요소가있는 목록)를 취하고 a를 반환 함을 의미합니다. 동일한 유형의 목록.</target>
        </trans-unit>
        <trans-unit id="0f3802314d747bbc5016897875185c3a9fae57bf" translate="yes" xml:space="preserve">
          <source>argument</source>
          <target state="translated">argument</target>
        </trans-unit>
        <trans-unit id="df211ccdd94a63e0bcb9e6ae427a249484a49d60" translate="yes" xml:space="preserve">
          <source>as</source>
          <target state="translated">as</target>
        </trans-unit>
        <trans-unit id="be976c9e3ea651e90f3e19650398efe5d38b4ca1" translate="yes" xml:space="preserve">
          <source>as a consequence, scanning a &lt;code&gt;%s&lt;/code&gt; conversion never raises exception &lt;code&gt;End_of_file&lt;/code&gt;: if the end of input is reached the conversion succeeds and simply returns the characters read so far, or &lt;code&gt;&quot;&quot;&lt;/code&gt; if none were ever read.</source>
          <target state="translated">결과적으로 &lt;code&gt;%s&lt;/code&gt; 변환을 스캔하면 &lt;code&gt;End_of_file&lt;/code&gt; 예외가 발생하지 않습니다 . 입력 끝에 도달하면 변환이 성공하고 지금까지 읽은 문자를 반환하거나 읽지 않은 경우 &lt;code&gt;&quot;&quot;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="2b953d2a9813da51eff31ce5c0d74db5b4435257" translate="yes" xml:space="preserve">
          <source>as mentioned above, a &lt;code&gt;%s&lt;/code&gt; conversion always succeeds, even if there is nothing to read in the input: in this case, it simply returns &lt;code&gt;&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">위에서 언급했듯이 &lt;code&gt;%s&lt;/code&gt; 변환은 입력에서 읽을 내용이 없더라도 항상 성공합니다.이 경우 단순히 &lt;code&gt;&quot;&quot;&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="06307b62a784724a222e8111cfba9c75dd2eeba4" translate="yes" xml:space="preserve">
          <source>as, &lt;a href=&quot;types#hevea_manual.kwd7&quot;&gt;7.4&lt;/a&gt;, &lt;a href=&quot;types#hevea_manual.kwd8&quot;&gt;7.4&lt;/a&gt;, &lt;a href=&quot;types#hevea_manual.kwd9&quot;&gt;7.4&lt;/a&gt;, &lt;a href=&quot;patterns#hevea_manual.kwd15&quot;&gt;7.6&lt;/a&gt;, &lt;a href=&quot;patterns#hevea_manual.kwd16&quot;&gt;7.6&lt;/a&gt;, &lt;a href=&quot;patterns#hevea_manual.kwd17&quot;&gt;7.6&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd124&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd132&quot;&gt;7.9.2&lt;/a&gt;</source>
          <target state="translated">예 : &lt;a href=&quot;types#hevea_manual.kwd7&quot;&gt;7.4&lt;/a&gt; , &lt;a href=&quot;types#hevea_manual.kwd8&quot;&gt;7.4&lt;/a&gt; , &lt;a href=&quot;types#hevea_manual.kwd9&quot;&gt;7.4&lt;/a&gt; , &lt;a href=&quot;patterns#hevea_manual.kwd15&quot;&gt;7.6&lt;/a&gt; , &lt;a href=&quot;patterns#hevea_manual.kwd16&quot;&gt;7.6&lt;/a&gt; , &lt;a href=&quot;patterns#hevea_manual.kwd17&quot;&gt;7.6&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd124&quot;&gt;7.9.2&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd132&quot;&gt;7.9.2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1294692e88bc3cf578b0cf93126b82e453a3a24f" translate="yes" xml:space="preserve">
          <source>asr</source>
          <target state="translated">asr</target>
        </trans-unit>
        <trans-unit id="173bd3aa4f99ba650649627effe8f47f679d7eb5" translate="yes" xml:space="preserve">
          <source>asr, &lt;a href=&quot;names#hevea_manual.kwd6&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd57&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd76&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd83&quot;&gt;7.7.5&lt;/a&gt;</source>
          <target state="translated">asr, &lt;a href=&quot;names#hevea_manual.kwd6&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd57&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd76&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd83&quot;&gt;7.7.5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9e6234fdd662a3db73c32822887385e189a0e4c" translate="yes" xml:space="preserve">
          <source>assert, &lt;a href=&quot;expr#hevea_manual.kwd86&quot;&gt;7.7.8&lt;/a&gt;</source>
          <target state="translated">주장, &lt;a href=&quot;expr#hevea_manual.kwd86&quot;&gt;7.7.8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="635740097092e2b68a7644b5822ee2b10f283f3e" translate="yes" xml:space="preserve">
          <source>assert&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">assert&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ad025fd42fe9ff686831aa8d53087f4ec6eef49" translate="yes" xml:space="preserve">
          <source>at the end of pretty-printing, flush the pretty-printer to display all the remaining material, e.g. evaluate &lt;code&gt;print_newline&amp;nbsp;()&lt;/code&gt;.</source>
          <target state="translated">pretty-printing이 끝나면 pretty-printer를 플러시하여 남아있는 모든 자료를 표시합니다. 예를 들어, &lt;code&gt;print_newline&amp;nbsp;()&lt;/code&gt; 평가 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a68c8b4d7fc1eb33ed288e6ff174b420fcadbab4" translate="yes" xml:space="preserve">
          <source>attr-id</source>
          <target state="translated">attr-id</target>
        </trans-unit>
        <trans-unit id="8d6f70260aa9cdd6cb0e7d628096d35d26e1ecb9" translate="yes" xml:space="preserve">
          <source>attr-payload</source>
          <target state="translated">attr-payload</target>
        </trans-unit>
        <trans-unit id="2c317cd0735d9046d7675c475fa1c6dce647953f" translate="yes" xml:space="preserve">
          <source>attribute</source>
          <target state="translated">attribute</target>
        </trans-unit>
        <trans-unit id="132060a9542263d8600782a359c79ea7e4420a18" translate="yes" xml:space="preserve">
          <source>attribute:</source>
          <target state="translated">attribute:</target>
        </trans-unit>
        <trans-unit id="0d612c12d2ac33625bf3e0351b6f5e4f73829fa8" translate="yes" xml:space="preserve">
          <source>auto</source>
          <target state="translated">auto</target>
        </trans-unit>
        <trans-unit id="e8a88cd5f1730052658100ac7c480655d9bb0697" translate="yes" xml:space="preserve">
          <source>avoids the rejection to the left of the inner boxes and print respectively &lt;code&gt;&quot;123456789&quot;&lt;/code&gt; and &lt;code&gt;&quot;123456789A&quot;&lt;/code&gt; . Note also that vertical boxes never fit on a line whereas horizontal boxes always fully fit on the current line. Opening a box may split a line whereas the contents may have fit. If this behavior is problematic, it can be curtailed by setting the maximum indentation limit to &lt;code&gt;margin&amp;nbsp;-&amp;nbsp;1&lt;/code&gt;. Note that setting the maximum indentation limit to &lt;code&gt;margin&lt;/code&gt; is invalid.</source>
          <target state="translated">내부 상자 왼쪽의 거부를 방지하고 각각 &lt;code&gt;&quot;123456789&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;123456789A&quot;&lt;/code&gt; 를 인쇄 합니다. 또한 세로 상자는 선에 맞지 않는 반면 가로 상자는 항상 현재 선에 완전히 맞습니다. 상자를 열면 내용이 맞을 수 있지만 줄이 나눌 수 있습니다. 이 동작이 문제가되는 경우 최대 들여 쓰기 제한을 &lt;code&gt;margin&amp;nbsp;-&amp;nbsp;1&lt;/code&gt; 로 설정하여 줄일 수 있습니다 . 최대 들여 쓰기 제한을 &lt;code&gt;margin&lt;/code&gt; 설정하는 것은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9d71f5ee7c92d6dc9e92ffdad17b8bd49418f98" translate="yes" xml:space="preserve">
          <source>b</source>
          <target state="translated">b</target>
        </trans-unit>
        <trans-unit id="9b6f52b23ca4f9826b4afac22ef26467ec6a903d" translate="yes" xml:space="preserve">
          <source>backslash (\)</source>
          <target state="translated">백 슬래시 (\)</target>
        </trans-unit>
        <trans-unit id="df93ce81475de263e8c9cd99e6db886626f778cb" translate="yes" xml:space="preserve">
          <source>backspace (BS)</source>
          <target state="translated">백 스페이스 (BS)</target>
        </trans-unit>
        <trans-unit id="67d129197ad7bbf1516510a57dad2884265f6481" translate="yes" xml:space="preserve">
          <source>backstep [count]</source>
          <target state="translated">백스텝 [수]</target>
        </trans-unit>
        <trans-unit id="ba5efbbeae5af04794d9bfdfa1b67fbd6b2a754b" translate="yes" xml:space="preserve">
          <source>backtrace [count], bt [count]</source>
          <target state="translated">역 추적 [개수], bt [개수]</target>
        </trans-unit>
        <trans-unit id="6c1c164d98ab04d2e7526e178c2bb0898d0e2c48" translate="yes" xml:space="preserve">
          <source>because the nested box &lt;code&gt;&quot;@[7@]&quot;&lt;/code&gt; is opened after the maximum indentation limit (&lt;code&gt;7&amp;gt;5&lt;/code&gt;) and its parent box does not fit on the current line. Either decreasing the length of the parent box to make it fit on a line:</source>
          <target state="translated">최대 들여 쓰기 제한 ( &lt;code&gt;7&amp;gt;5&lt;/code&gt; ) 이후에 중첩 된 상자 &lt;code&gt;&quot;@[7@]&quot;&lt;/code&gt; 이 열리고 부모 상자가 현재 줄에 맞지 않기 때문입니다. 선에 맞도록 상위 상자의 길이를 줄이십시오.</target>
        </trans-unit>
        <trans-unit id="4e58ac78738f8185ee5c7c2c3d83aca0198db529" translate="yes" xml:space="preserve">
          <source>becomes</source>
          <target state="translated">becomes</target>
        </trans-unit>
        <trans-unit id="a8b34082638e0ab7e5f1583cfeb4eaae1d137611" translate="yes" xml:space="preserve">
          <source>begin, &lt;a href=&quot;const#hevea_manual.kwd13&quot;&gt;7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd38&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd58&quot;&gt;7.7.2&lt;/a&gt;</source>
          <target state="translated">시작, &lt;a href=&quot;const#hevea_manual.kwd13&quot;&gt;7.5&lt;/a&gt; , &lt;a href=&quot;expr#hevea_manual.kwd38&quot;&gt;7.7&lt;/a&gt; , &lt;a href=&quot;expr#hevea_manual.kwd58&quot;&gt;7.7.2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fbbaa8525df456049f378ce5f890b00b21d15f96" translate="yes" xml:space="preserve">
          <source>begin&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;end</source>
          <target state="translated">begin&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;end</target>
        </trans-unit>
        <trans-unit id="d1dc25355bd9b369668d0373cf8c41939c1455bb" translate="yes" xml:space="preserve">
          <source>beginend</source>
          <target state="translated">beginend</target>
        </trans-unit>
        <trans-unit id="3fe6381046bb4b68161f33c5c83f32615ed528b6" translate="yes" xml:space="preserve">
          <source>binary (radix 2)</source>
          <target state="translated">이진 (기수 2)</target>
        </trans-unit>
        <trans-unit id="ad022478fc3c13fcde899deb3d9a5f6c35ad6ff0" translate="yes" xml:space="preserve">
          <source>blank-line</source>
          <target state="translated">blank-line</target>
        </trans-unit>
        <trans-unit id="80a25bf9e5d787c109376c0b79d204a87d3b2159" translate="yes" xml:space="preserve">
          <source>booleans</source>
          <target state="translated">booleans</target>
        </trans-unit>
        <trans-unit id="4f9cac8dbc4c67a388b8379dcc126c90c7c5e72a" translate="yes" xml:space="preserve">
          <source>break</source>
          <target state="translated">break</target>
        </trans-unit>
        <trans-unit id="8d6f2c43bf7d14f05fb406a9d11b58c27f57ccfa" translate="yes" xml:space="preserve">
          <source>break @ [module] #character</source>
          <target state="translated">break @ [모듈] # 문자</target>
        </trans-unit>
        <trans-unit id="20fb4da1603f2165312382ba6b7e3d575d006be2" translate="yes" xml:space="preserve">
          <source>break @ [module] line</source>
          <target state="translated">@ [모듈] 줄 끊기</target>
        </trans-unit>
        <trans-unit id="22d8bb500e6542711de79a9522950a0ad8d09ecb" translate="yes" xml:space="preserve">
          <source>break @ [module] line column</source>
          <target state="translated">@ [모듈] 줄 열 끊기</target>
        </trans-unit>
        <trans-unit id="c887c2526d97de3130955f38f51b2710ab19ca84" translate="yes" xml:space="preserve">
          <source>break frag:pc, break pc</source>
          <target state="translated">조각 나누기 : pc, pc 끊기</target>
        </trans-unit>
        <trans-unit id="440c5d3712c1ce9be8754b77591e60e9d7572762" translate="yes" xml:space="preserve">
          <source>break function</source>
          <target state="translated">휴식 기능</target>
        </trans-unit>
        <trans-unit id="f71bf9164126dca1c327bcca37fd7ec31c7b94e2" translate="yes" xml:space="preserve">
          <source>buf:</source>
          <target state="translated">buf:</target>
        </trans-unit>
        <trans-unit id="885b44d5eac8ca9716435d7d2f0b938495af5313" translate="yes" xml:space="preserve">
          <source>build a list.</source>
          <target state="translated">목록을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c96e9b2af6622992b34c617e57c81324a1b22b0e" translate="yes" xml:space="preserve">
          <source>build an enumerated list.</source>
          <target state="translated">열거 된 목록을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="0bb7ca68f1d3edf023c22979b31f0f08c02a05b7" translate="yes" xml:space="preserve">
          <source>builds the C libraries dllzip.so and libzip.a. Notice that the support libraries (-lz) and the corresponding options (-L/usr/local/zlib) must be given on all three invocations of ocamlmklib, because they are needed at different times depending on whether shared libraries are supported.</source>
          <target state="translated">C 라이브러리 dllzip.so 및 libzip.a를 빌드합니다. 지원 라이브러리 (-lz) 및 해당 옵션 (-L / usr / local / zlib)은 공유 라이브러리 지원 여부에 따라 서로 다른 시간에 필요하므로 ocamlmklib의 세 가지 호출 모두에 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="511cde4c103875c617ba39c165112bd2d73e4def" translate="yes" xml:space="preserve">
          <source>builds the bytecode library zip.cma, and</source>
          <target state="translated">바이트 코드 라이브러리 zip.cma를 빌드하고</target>
        </trans-unit>
        <trans-unit id="88bcc7f8344e049ea476cc39db2cb837f4351dfe" translate="yes" xml:space="preserve">
          <source>builds the native-code library zip.cmxa, and</source>
          <target state="translated">네이티브 코드 라이브러리 zip.cmxa를 빌드하고</target>
        </trans-unit>
        <trans-unit id="e6ab8be307405fed6a651c74d6a5644f4ff84d65" translate="yes" xml:space="preserve">
          <source>but they cannot be nested inside other patterns. For instance, the pattern Some (exception A) is invalid.</source>
          <target state="translated">그러나 다른 패턴 안에 중첩 될 수 없습니다. 예를 들어, Some 패턴 (예외 A)은 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c56b6970aa26b3b1dcd7e2c05df93eb8064f9bd3" translate="yes" xml:space="preserve">
          <source>but this means that any code of the form</source>
          <target state="translated">그러나 이것은 형식의 모든 코드가</target>
        </trans-unit>
        <trans-unit id="5c415733b56482edd139e3f7e0964c8f096b31d0" translate="yes" xml:space="preserve">
          <source>by using the &lt;code&gt;&quot;-pp&quot;&lt;/code&gt; command-line switch of the compilers.</source>
          <target state="translated">컴파일러 의 &lt;code&gt;&quot;-pp&quot;&lt;/code&gt; 명령 줄 스위치를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="daf529a73101c2be626b99fc6938163e7a27620b" translate="yes" xml:space="preserve">
          <source>bytes</source>
          <target state="translated">bytes</target>
        </trans-unit>
        <trans-unit id="84a516841ba77a5b4648de2cd0dfcb30ea46dbb4" translate="yes" xml:space="preserve">
          <source>c</source>
          <target state="translated">c</target>
        </trans-unit>
        <trans-unit id="03c15bf05ba15e346da77ead7dab8af27ed6c2f8" translate="yes" xml:space="preserve">
          <source>callback from C to OCaml (see section &lt;a href=&quot;#s%3Ac-callback&quot;&gt;20.7&lt;/a&gt;).</source>
          <target state="translated">C에서 OCaml 로의 콜백 (섹션 &lt;a href=&quot;#s%3Ac-callback&quot;&gt;20.7&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="1b71b4b35cc8fe63833d6e0e8185d7156c69e349" translate="yes" xml:space="preserve">
          <source>caml/alloc.h</source>
          <target state="translated">caml/alloc.h</target>
        </trans-unit>
        <trans-unit id="4471df25a307ba67e7aad2a84935b80ee087ba56" translate="yes" xml:space="preserve">
          <source>caml/callback.h</source>
          <target state="translated">caml/callback.h</target>
        </trans-unit>
        <trans-unit id="592c7ccf3ba8d4279c07377701d1330a620a0465" translate="yes" xml:space="preserve">
          <source>caml/custom.h</source>
          <target state="translated">caml/custom.h</target>
        </trans-unit>
        <trans-unit id="8792decdf7bf2bb976bd1e40904954d928525a86" translate="yes" xml:space="preserve">
          <source>caml/fail.h</source>
          <target state="translated">caml/fail.h</target>
        </trans-unit>
        <trans-unit id="f8667dfad754b997816f201603db4fba194f86fe" translate="yes" xml:space="preserve">
          <source>caml/intext.h</source>
          <target state="translated">caml/intext.h</target>
        </trans-unit>
        <trans-unit id="890fcb00d9fbe640855da092f035fa0325fa9d4d" translate="yes" xml:space="preserve">
          <source>caml/memory.h</source>
          <target state="translated">caml/memory.h</target>
        </trans-unit>
        <trans-unit id="3b9e73982305334ad406a6817eb43383bc9250f7" translate="yes" xml:space="preserve">
          <source>caml/mlvalues.h</source>
          <target state="translated">caml/mlvalues.h</target>
        </trans-unit>
        <trans-unit id="dffc05b944c1dae59e693eb0c0be9a909cd07363" translate="yes" xml:space="preserve">
          <source>caml/threads.h</source>
          <target state="translated">caml/threads.h</target>
        </trans-unit>
        <trans-unit id="81196066a86588828627518df7ffe94d080e24a7" translate="yes" xml:space="preserve">
          <source>caml_acquire_runtime_system() The calling thread re-acquires the master lock and other OCaml resources. It may block until no other thread uses the OCaml run-time system.</source>
          <target state="translated">caml_acquire_runtime_system () 호출 스레드는 마스터 잠금 및 기타 OCaml 자원을 다시 획득합니다. 다른 스레드가 OCaml 런타임 시스템을 사용하지 않을 때까지 차단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a70c78f5895738a81bb9b00b34be9a45176c32b" translate="yes" xml:space="preserve">
          <source>caml_alloc(n, t) returns a fresh block of size n with tag t. If t is less than No_scan_tag, then the fields of the block are initialized with a valid value in order to satisfy the GC constraints.</source>
          <target state="translated">caml_alloc (n, t)는 태그 t와 함께 크기 n의 새 블록을 반환합니다. t가 No_scan_tag보다 작 으면 GC 제약 조건을 충족하기 위해 블록의 필드가 유효한 값으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="217c9f33ff108e05317aa80431b9421dd0778d61" translate="yes" xml:space="preserve">
          <source>caml_alloc_array(f, a) allocates an array of values, calling function f over each element of the input array a to transform it into a value. The array a is an array of pointers terminated by the null pointer. The function f receives each pointer as argument, and returns a value. The zero-tagged block returned by alloc_array(f, a) is filled with the values returned by the successive calls to f. (This function must not be used to build an array of floating-point numbers.)</source>
          <target state="translated">caml_alloc_array (f, a)는 입력 배열 a의 각 요소에 대해 함수 f를 호출하여 값으로 변환하는 값 배열을 할당합니다. 배열 a는 널 포인터로 종료되는 포인터의 배열입니다. 함수 f는 각 포인터를 인수로 받고 값을 반환합니다. alloc_array (f, a)에 의해 반환 된 태그가없는 블록은 f에 대한 연속 호출에서 반환 된 값으로 채워집니다. (이 함수는 부동 소수점 숫자의 배열을 만드는 데 사용해서는 안됩니다.)</target>
        </trans-unit>
        <trans-unit id="b412c2fbef85869c951a4a1fef5484672e0be067" translate="yes" xml:space="preserve">
          <source>caml_alloc_boxed(v) allocates and returns a value (of any boxed type) whose field is the value v.</source>
          <target state="translated">caml_alloc_boxed (v)는 필드가 v 인 값 (모든 박스형 유형)을 할당하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="665ee1b8b9002fba0f1725868331ec66b56f0143" translate="yes" xml:space="preserve">
          <source>caml_alloc_custom(ops, size, used, max)</source>
          <target state="translated">caml_alloc_custom(ops, size, used, max)</target>
        </trans-unit>
        <trans-unit id="4bf94616c15dadf23974ee9a2d762495d67bb2c7" translate="yes" xml:space="preserve">
          <source>caml_alloc_custom_mem(ops, size, used)</source>
          <target state="translated">caml_alloc_custom_mem(ops, size, used)</target>
        </trans-unit>
        <trans-unit id="3323e558e84f1a7378e11e2db8ff7ed4082f12bc" translate="yes" xml:space="preserve">
          <source>caml_alloc_float_array(n) allocates an array of floating point numbers of size n. The array initially contains uninitialized values.</source>
          <target state="translated">caml_alloc_float_array (n)은 크기 n의 부동 소수점 수 배열을 할당합니다. 배열은 초기에 초기화되지 않은 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="67e1c90ce20519fd8513d36af40857d4148bcf51" translate="yes" xml:space="preserve">
          <source>caml_alloc_initialized_string(n, p) returns a byte sequence (or string) value of length n bytes. The value is initialized from the n bytes starting at address p.</source>
          <target state="translated">caml_alloc_initialized_string (n, p)는 길이가 n 바이트 인 바이트 시퀀스 (또는 문자열) 값을 반환합니다. 값은 주소 p에서 시작하는 n 바이트에서 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="5a46d60ca815b5fab7ffdb9b9cd4c97ff680a32a" translate="yes" xml:space="preserve">
          <source>caml_alloc_shr(n, t) returns a fresh block of size n, with tag t. The size of the block can be greater than &lt;code&gt;Max_young_wosize&lt;/code&gt;. (It can also be smaller, but in this case it is more efficient to call caml_alloc_small instead of caml_alloc_shr.) If this block is a structured block (i.e. if t &amp;lt; No_scan_tag), then the fields of the block (initially containing garbage) must be initialized with legal values (using the caml_initialize function described below) before the next allocation.</source>
          <target state="translated">caml_alloc_shr (n, t)는 태그 t와 함께 크기 n의 새 블록을 반환합니다. 블록의 크기는 &lt;code&gt;Max_young_wosize&lt;/code&gt; 보다 클 수 있습니다 . (작을 수도 있지만이 경우에는 caml_alloc_shr 대신 caml_alloc_small을 호출하는 것이 더 효율적입니다.)이 블록이 구조화 된 블록 인 경우 (즉, t &amp;lt;No_scan_tag 인 경우) 블록의 필드 (처음에는 가비지 포함)가 있어야합니다. 다음 할당 전에 유효한 값 (아래 설명 된 caml_initialize 함수 사용)으로 초기화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="c9efca592b4526beda7a63fdc5fede30105d6950" translate="yes" xml:space="preserve">
          <source>caml_alloc_small(n, t) returns a fresh small block of size n &amp;le; Max_young_wosize words, with tag t. If this block is a structured block (i.e. if t &amp;lt; No_scan_tag), then the fields of the block (initially containing garbage) must be initialized with legal values (using direct assignment to the fields of the block) before the next allocation.</source>
          <target state="translated">caml_alloc_small (n, t)는 태그 t와 함께 크기 n &amp;le; Max_young_wosize 단어의 새로운 작은 블록을 반환합니다. 이 블록이 구조화 된 블록 인 경우 (즉, t &amp;lt;No_scan_tag 인 경우) 다음 할당 전에 블록의 필드 (처음에 가비지 포함)를 유효한 값으로 초기화해야합니다 (블록의 필드에 직접 할당 사용).</target>
        </trans-unit>
        <trans-unit id="e7cfd3343e5e4c212d14c75252c0e1b517c5e6d4" translate="yes" xml:space="preserve">
          <source>caml_alloc_string(n) returns a byte sequence (or string) value of length n bytes. The sequence initially contains uninitialized bytes.</source>
          <target state="translated">caml_alloc_string (n)은 길이가 n 바이트 인 바이트 시퀀스 (또는 문자열) 값을 반환합니다. 시퀀스는 초기에 초기화되지 않은 바이트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="f56f10eda49d4944e86ff916fd101e6b5dcaeec7" translate="yes" xml:space="preserve">
          <source>caml_alloc_tuple(n) returns a fresh block of size n words, with tag 0.</source>
          <target state="translated">caml_alloc_tuple (n)은 태그가 0 인 n 단어 크기의 새 블록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="69c404c865e60cbf5daaf2f85055a9b0b490a426" translate="yes" xml:space="preserve">
          <source>caml_alloc_unboxable(v) calls either caml_alloc_unboxed or caml_alloc_boxed according to the default representation of unboxable types in the current version of OCaml.</source>
          <target state="translated">caml_alloc_unboxable (v)은 현재 버전의 OCaml에서 unboxable 유형의 기본 표현에 따라 caml_alloc_unboxed 또는 caml_alloc_boxed를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="7cd673395971a1edb0e66a2e4c106d4bbdb61e94" translate="yes" xml:space="preserve">
          <source>caml_alloc_unboxed(v) returns the value (of any unboxed type) whose field is the value v.</source>
          <target state="translated">caml_alloc_unboxed (v)는 필드가 v 인 값 (모든 unboxed 유형)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d35e29583ecb00b187c8009920908fc57e9ae396" translate="yes" xml:space="preserve">
          <source>caml_ba_alloc(kind|layout, numdims, p, dims)</source>
          <target state="translated">caml_ba_alloc (종류 | 레이아웃, numdims, p, dims)</target>
        </trans-unit>
        <trans-unit id="43a32453f66eadc5fcb7099b797e72909cbf1082" translate="yes" xml:space="preserve">
          <source>caml_ba_alloc_dims(kind|layout, numdims, p, (long) dim&lt;sub&gt;1&lt;/sub&gt;, (long) dim&lt;sub&gt;2&lt;/sub&gt;, &amp;hellip;, (long) dim&lt;sub&gt;numdims&lt;/sub&gt;)</source>
          <target state="translated">caml_ba_alloc_dims(kind|layout, numdims, p, (long) dim&lt;sub&gt;1&lt;/sub&gt;, (long) dim&lt;sub&gt;2&lt;/sub&gt;, &amp;hellip;, (long) dim&lt;sub&gt;numdims&lt;/sub&gt;)</target>
        </trans-unit>
        <trans-unit id="f9a2d346413d8e0258d8e23db6f2ecb7f1515a8d" translate="yes" xml:space="preserve">
          <source>caml_c_thread_register() registers the calling thread with the OCaml run-time system. Returns 1 on success, 0 on error. Registering an already-registered thread does nothing and returns 0.</source>
          <target state="translated">caml_c_thread_register ()는 OCaml 런타임 시스템에 호출 스레드를 등록합니다. 성공하면 1을, 오류가 있으면 0을 반환합니다. 이미 등록 된 스레드를 등록하면 아무 작업도 수행되지 않고 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="76f5eeb608e25a7e56c4a9a10180e60be6106887" translate="yes" xml:space="preserve">
          <source>caml_c_thread_unregister() must be called before the thread terminates, to unregister it from the OCaml run-time system. Returns 1 on success, 0 on error. If the calling thread was not previously registered, does nothing and returns 0.</source>
          <target state="translated">OCaml 런타임 시스템에서 등록을 해제하려면 스레드가 종료되기 전에 caml_c_thread_unregister ()를 호출해야합니다. 성공하면 1을, 오류가 있으면 0을 반환합니다. 호출 스레드가 이전에 등록되지 않은 경우 아무 작업도 수행하지 않고 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="05a88f8527c729e1b9db0097f427661299ac3aaf" translate="yes" xml:space="preserve">
          <source>caml_callback(f, a) applies the functional value f to the value a and returns the value returned by f.</source>
          <target state="translated">caml_callback (f, a)는 함수 값 f를 값 a에 적용하고 f가 반환 한 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="820e3ded86f605764643a7eed336c5000064f192" translate="yes" xml:space="preserve">
          <source>caml_callback2(f, a, b) applies the functional value f (which is assumed to be a curried OCaml function with two arguments) to a and b.</source>
          <target state="translated">caml_callback2 (f, a, b)는 함수 값 f (두 개의 인수가있는 카레 OCaml 함수로 가정 됨)를 a와 b에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="fe5c03d3316677716a3d2a00f8d2ee24d6f972a1" translate="yes" xml:space="preserve">
          <source>caml_callback3(f, a, b, c) applies the functional value f (a curried OCaml function with three arguments) to a, b and c.</source>
          <target state="translated">caml_callback3 (f, a, b, c)는 함수 값 f (3 개의 인수가있는 카레 OCaml 함수)를 a, b 및 c에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="0233fd6bd1e96cfb8d2974ba591ba865db2ae1a0" translate="yes" xml:space="preserve">
          <source>caml_callbackN(f, n, args) applies the functional value f to the n arguments contained in the array of values args.</source>
          <target state="translated">caml_callbackN (f, n, args)는 함수 값 f를 값 args의 배열에 포함 된 n 개의 인수에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="2cf354aacfc7103b94817ae65879f1489304072e" translate="yes" xml:space="preserve">
          <source>caml_copy_double(d) returns a floating-point value initialized with the doubled.</source>
          <target state="translated">caml_copy_double (d)는 doubled로 초기화 된 부동 소수점 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ec539f275c2dff88912942f70a765beb82287158" translate="yes" xml:space="preserve">
          <source>caml_copy_int32(i), caml_copy_int64(i) and caml_copy_nativeint(i) return a value of OCaml type int32, int64 and nativeint, respectively, initialized with the integer i.</source>
          <target state="translated">caml_copy_int32 (i), caml_copy_int64 (i) 및 caml_copy_nativeint (i)는 각각 정수 i로 초기화 된 OCaml 유형 int32, int64 및 nativeint의 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2471864cc31009e8a1e62e42528d1575ed25f539" translate="yes" xml:space="preserve">
          <source>caml_copy_string(s) returns a string or byte sequence value containing a copy of the null-terminated C string s (a char *).</source>
          <target state="translated">caml_copy_string (s)은 null로 끝나는 C 문자열 s (문자 *)의 복사본을 포함하는 문자열 또는 바이트 시퀀스 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="74f9c7eaafeaaa2a5ea3107d6472ba41f837ffb2" translate="yes" xml:space="preserve">
          <source>caml_copy_string_array(p) allocates an array of strings or byte sequences, copied from the pointer to a string array p (a char **). p must be NULL-terminated.</source>
          <target state="translated">caml_copy_string_array (p)는 포인터에서 문자열 배열 p (문자 **)로 복사 된 문자열 또는 바이트 시퀀스의 배열을 할당합니다. p는 NULL로 끝나야합니다.</target>
        </trans-unit>
        <trans-unit id="918cf518214782b1cc0e33fd17a49ac9aeacaa93" translate="yes" xml:space="preserve">
          <source>caml_deserialize_block_1</source>
          <target state="translated">caml_deserialize_block_1</target>
        </trans-unit>
        <trans-unit id="dac44adcc649f794a823bc613a4f99f79375c99d" translate="yes" xml:space="preserve">
          <source>caml_deserialize_block_2</source>
          <target state="translated">caml_deserialize_block_2</target>
        </trans-unit>
        <trans-unit id="35407d685d291cd8f9a87c8097d5cc11738aac8e" translate="yes" xml:space="preserve">
          <source>caml_deserialize_block_4</source>
          <target state="translated">caml_deserialize_block_4</target>
        </trans-unit>
        <trans-unit id="e33c938fab61721b51eed15194e2d30eb87000a0" translate="yes" xml:space="preserve">
          <source>caml_deserialize_block_8</source>
          <target state="translated">caml_deserialize_block_8</target>
        </trans-unit>
        <trans-unit id="01d9f69b15f4f41d9244f9c3804c975a64b6158a" translate="yes" xml:space="preserve">
          <source>caml_deserialize_error</source>
          <target state="translated">caml_deserialize_error</target>
        </trans-unit>
        <trans-unit id="1f492cf546e5c7087c942020ba6d5961ccc348b9" translate="yes" xml:space="preserve">
          <source>caml_deserialize_float_4</source>
          <target state="translated">caml_deserialize_float_4</target>
        </trans-unit>
        <trans-unit id="0b6e78572b4ac229628c458e0ecaa2fb7295151c" translate="yes" xml:space="preserve">
          <source>caml_deserialize_float_8</source>
          <target state="translated">caml_deserialize_float_8</target>
        </trans-unit>
        <trans-unit id="8a9cf39c1b25ec605de44f1545bee50da0e5401a" translate="yes" xml:space="preserve">
          <source>caml_deserialize_sint_1</source>
          <target state="translated">caml_deserialize_sint_1</target>
        </trans-unit>
        <trans-unit id="7136f8685a8e7a942bf14dcdcde72910b80d0e77" translate="yes" xml:space="preserve">
          <source>caml_deserialize_sint_2</source>
          <target state="translated">caml_deserialize_sint_2</target>
        </trans-unit>
        <trans-unit id="476465cf53e5d050cfacddced1f8c3835ba60d4a" translate="yes" xml:space="preserve">
          <source>caml_deserialize_sint_4</source>
          <target state="translated">caml_deserialize_sint_4</target>
        </trans-unit>
        <trans-unit id="3a0dc876c85eec7de4289c833125ae2cacd8a3aa" translate="yes" xml:space="preserve">
          <source>caml_deserialize_sint_8</source>
          <target state="translated">caml_deserialize_sint_8</target>
        </trans-unit>
        <trans-unit id="da233c41683a76e16c83d1a9ab274d83e246577a" translate="yes" xml:space="preserve">
          <source>caml_deserialize_uint_1</source>
          <target state="translated">caml_deserialize_uint_1</target>
        </trans-unit>
        <trans-unit id="c7e3e69e51156b2134966606c7ec2dc3f2e9ad44" translate="yes" xml:space="preserve">
          <source>caml_deserialize_uint_2</source>
          <target state="translated">caml_deserialize_uint_2</target>
        </trans-unit>
        <trans-unit id="f28316e19f353ff58baba442c8c6cd6d7884d9a9" translate="yes" xml:space="preserve">
          <source>caml_deserialize_uint_4</source>
          <target state="translated">caml_deserialize_uint_4</target>
        </trans-unit>
        <trans-unit id="aede7b6eb7681bcf0c5ebd81e6fceae87718bafa" translate="yes" xml:space="preserve">
          <source>caml_deserialize_uint_8</source>
          <target state="translated">caml_deserialize_uint_8</target>
        </trans-unit>
        <trans-unit id="416e7610539057f60428828cf59eb4906d8ddee0" translate="yes" xml:space="preserve">
          <source>caml_enter_blocking_section as an alias for caml_release_runtime_system</source>
          <target state="translated">caml_release_runtime_system의 별칭으로 caml_enter_blocking_section</target>
        </trans-unit>
        <trans-unit id="14a7ce9f3a6006e7f1c8fad15bbf4d6a0f804631" translate="yes" xml:space="preserve">
          <source>caml_failwith(s), where s is a null-terminated C string (with type &lt;code&gt;char *&lt;/code&gt;), raises exception Failure with argument s.</source>
          <target state="translated">caml_failwith (s), 여기서 s는 null로 끝나는 C 문자열 ( &lt;code&gt;char *&lt;/code&gt; 형식 ), 인수 s를 사용하여 예외 실패를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="7d27d8138c2cbd7e1f6803c0423040e3884da98e" translate="yes" xml:space="preserve">
          <source>caml_field_boxed(v) returns the value of the field of a value v of any boxed type (record or concrete data type).</source>
          <target state="translated">caml_field_boxed (v)는 박스형 유형 (레코드 또는 구체적인 데이터 유형)의 값 v 필드 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5eb81ee26ea7b5ed3a3714239c218e0aa5d478b7" translate="yes" xml:space="preserve">
          <source>caml_field_unboxable(v) calls either caml_field_unboxed or caml_field_boxed according to the default representation of unboxable types in the current version of OCaml.</source>
          <target state="translated">caml_field_unboxable (v)은 현재 버전의 OCaml에서 unboxable 유형의 기본 표현에 따라 caml_field_unboxed 또는 caml_field_boxed를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="f31cce61ed462e58bd73936dd1de28e076cf6ae6" translate="yes" xml:space="preserve">
          <source>caml_field_unboxed(v) returns the value of the field of a value v of any unboxed type (record or concrete data type).</source>
          <target state="translated">caml_field_unboxed (v)는 unboxed 유형 (레코드 또는 구체적인 데이터 유형)의 값 v 필드 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fabe664c7f517d5d094066c161e25ead36a65f60" translate="yes" xml:space="preserve">
          <source>caml_invalid_argument(s), where s is a null-terminated C string (with type &lt;code&gt;char *&lt;/code&gt;), raises exception Invalid_argument with argument s.</source>
          <target state="translated">caml_invalid_argument (s), 여기서 s는 null로 끝나는 C 문자열 ( &lt;code&gt;char *&lt;/code&gt; 유형 ), 인수 s와 함께 Invalid_argument 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="02bae75839fb1bf56fa1ec0b6cd98dfa5e4295f5" translate="yes" xml:space="preserve">
          <source>caml_leave_blocking_section as an alias for caml_acquire_runtime_system</source>
          <target state="translated">caml_acquire_runtime_system의 별칭으로 caml_leave_blocking_section</target>
        </trans-unit>
        <trans-unit id="356ae13a054640e5af072dd6bcc0d2834d37f10c" translate="yes" xml:space="preserve">
          <source>caml_raise_constant(id) raises the exception id with no argument;</source>
          <target state="translated">caml_raise_constant (id)는 인수없이 예외 ID를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="858fd18e0bc5a5829c8ac6e60bb9d8283b082858" translate="yes" xml:space="preserve">
          <source>caml_raise_with_arg(id, v) raises the exception id with the OCaml value v as argument;</source>
          <target state="translated">caml_raise_with_arg (id, v)는 OCaml 값 v를 인수로 사용하여 예외 ID를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="19d64e10fe5ed3863f7d0bb0fe72f1513e8a8f2b" translate="yes" xml:space="preserve">
          <source>caml_raise_with_args(id, n, v) raises the exception id with the OCaml values v[0], &amp;hellip;, v[n-1] as arguments;</source>
          <target state="translated">caml_raise_with_args (id, n, v)는 OCaml 값 v [0],&amp;hellip;, v [n-1]을 인수로 사용하여 예외 ID를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="9c0c66567ef1c96c698ce066439e5f630905c3a9" translate="yes" xml:space="preserve">
          <source>caml_raise_with_string(id, s), where s is a null-terminated C string, raises the exception id with a copy of the C string s as argument.</source>
          <target state="translated">caml_raise_with_string (id, s), 여기서 s는 null로 끝나는 C 문자열이며 C 문자열 s의 복사본을 인수로 사용하여 예외 ID를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="287a35972bf162ebc29d2aa934cbd84dae2c36c2" translate="yes" xml:space="preserve">
          <source>caml_release_runtime_system() The calling thread releases the master lock and other OCaml resources, enabling other threads to run OCaml code in parallel with the execution of the calling thread.</source>
          <target state="translated">caml_release_runtime_system () 호출 스레드는 마스터 잠금 및 기타 OCaml 리소스를 해제하여 다른 스레드가 호출 스레드의 실행과 동시에 OCaml 코드를 실행할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="ae63c20bf1c4bb6a020f7324ec24e730e1502926" translate="yes" xml:space="preserve">
          <source>caml_serialize_block_1</source>
          <target state="translated">caml_serialize_block_1</target>
        </trans-unit>
        <trans-unit id="1f88a94e85c7f6efd8c4040e372002762ddd5ce1" translate="yes" xml:space="preserve">
          <source>caml_serialize_block_2</source>
          <target state="translated">caml_serialize_block_2</target>
        </trans-unit>
        <trans-unit id="7f65027df7939a869ab29fbc0899535001b0c56f" translate="yes" xml:space="preserve">
          <source>caml_serialize_block_4</source>
          <target state="translated">caml_serialize_block_4</target>
        </trans-unit>
        <trans-unit id="fdfab415c6d00981ab8eb822efb29e78a99a1d98" translate="yes" xml:space="preserve">
          <source>caml_serialize_block_8</source>
          <target state="translated">caml_serialize_block_8</target>
        </trans-unit>
        <trans-unit id="36a3049b031f4083e92b7d4b9711c0de54316b78" translate="yes" xml:space="preserve">
          <source>caml_serialize_float_4</source>
          <target state="translated">caml_serialize_float_4</target>
        </trans-unit>
        <trans-unit id="f743618d0b25010412d98c92620a0c84e87fff70" translate="yes" xml:space="preserve">
          <source>caml_serialize_float_8</source>
          <target state="translated">caml_serialize_float_8</target>
        </trans-unit>
        <trans-unit id="23603973b40d624874498ff401f6b6f1e7c4db00" translate="yes" xml:space="preserve">
          <source>caml_serialize_int_1</source>
          <target state="translated">caml_serialize_int_1</target>
        </trans-unit>
        <trans-unit id="e1ce658bb59ae754affc221a0fc0f480ede7017a" translate="yes" xml:space="preserve">
          <source>caml_serialize_int_2</source>
          <target state="translated">caml_serialize_int_2</target>
        </trans-unit>
        <trans-unit id="66dd30967cf335aca785df52b55e84a69dbbdc79" translate="yes" xml:space="preserve">
          <source>caml_serialize_int_4</source>
          <target state="translated">caml_serialize_int_4</target>
        </trans-unit>
        <trans-unit id="e8140ea757da273e868ac4101e99d59e556d53b4" translate="yes" xml:space="preserve">
          <source>caml_serialize_int_8</source>
          <target state="translated">caml_serialize_int_8</target>
        </trans-unit>
        <trans-unit id="4b456eebdecfa8b8e1aa7110502a15dfda1f3606" translate="yes" xml:space="preserve">
          <source>caml_string_length(v) returns the length (number of bytes) of the string or byte sequence v.</source>
          <target state="translated">caml_string_length (v)는 문자열 또는 바이트 시퀀스 v의 길이 (바이트 수)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9351fe8845b904696063fb13e86c9bc94efe9685" translate="yes" xml:space="preserve">
          <source>can be refined in two ways. A definition [u] may add new field to [t], and the declaration</source>
          <target state="translated">두 가지 방법으로 다듬을 수 있습니다. 정의 [u]는 [t]에 새 필드를 추가 할 수 있으며 선언</target>
        </trans-unit>
        <trans-unit id="ad1e766cc8178e6f6ad74e38ff2897d6a38ad799" translate="yes" xml:space="preserve">
          <source>can only wait for a given PID, not any child process</source>
          <target state="translated">하위 프로세스가 아닌 지정된 PID 만 기다릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5df64e3c8e78211b701b9d8971c1063ca8f2e1b6" translate="yes" xml:space="preserve">
          <source>capitalized-ident</source>
          <target state="translated">capitalized-ident</target>
        </trans-unit>
        <trans-unit id="28e01c21872f76a357676cc09019dabc3abd13de" translate="yes" xml:space="preserve">
          <source>carriage return (CR)</source>
          <target state="translated">캐리지 리턴 (CR)</target>
        </trans-unit>
        <trans-unit id="338daab440e97efde55f37074a6c9d0cfceff0a2" translate="yes" xml:space="preserve">
          <source>cddirectory</source>
          <target state="translated">cddirectory</target>
        </trans-unit>
        <trans-unit id="4f5b1a054e184cc853d48ac01253e6ac5a470d9a" translate="yes" xml:space="preserve">
          <source>center &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;.</source>
          <target state="translated">가운데 &lt;a href=&quot;#text&quot;&gt;텍스트&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="71fafc4e2fc1e47e234762a96b80512b6b5534c2" translate="yes" xml:space="preserve">
          <source>char</source>
          <target state="translated">char</target>
        </trans-unit>
        <trans-unit id="7dbf01c25b781fe0b168381bf3b25fb375fb567f" translate="yes" xml:space="preserve">
          <source>char *identifier</source>
          <target state="translated">char * 식별자</target>
        </trans-unit>
        <trans-unit id="d521d46e1370c48f989e9725c1abd207ee1d3a44" translate="yes" xml:space="preserve">
          <source>char* caml_stat_strdup_of_os(const char_os *) copies the argument while translating from the platform encoding to the OCaml encoding. It is the inverse of caml_stat_strdup_to_os. This function is typically used to convert a string obtained from the operating system before passing it on to OCaml code. Under Unix, it is equivalent to caml_stat_strdup.</source>
          <target state="translated">char * caml_stat_strdup_of_os (const char_os *)는 플랫폼 인코딩에서 OCaml 인코딩으로 변환하는 동안 인수를 복사합니다. caml_stat_strdup_to_os의 반대입니다. 이 함수는 일반적으로 운영 체제에서 얻은 문자열을 OCaml 코드로 전달하기 전에 변환하는 데 사용됩니다. Unix에서는 caml_stat_strdup과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3c841c7d2b2460cf8b4fae3611f52dff8e7413b4" translate="yes" xml:space="preserve">
          <source>char-literal</source>
          <target state="translated">char-literal</target>
        </trans-unit>
        <trans-unit id="0658481307f1c9bf812b837154f546a05ee9b13d" translate="yes" xml:space="preserve">
          <source>char_os* caml_stat_strdup_to_os(const char *) copies the argument while translating from OCaml encoding to the platform encoding. This function is typically used to convert the char * underlying an OCaml string before passing it to an operating system API that takes a Unicode argument. Under Unix, it is equivalent to caml_stat_strdup.</source>
          <target state="translated">char_os * caml_stat_strdup_to_os (const char *)는 OCaml 인코딩에서 플랫폼 인코딩으로 변환하는 동안 인수를 복사합니다. 이 함수는 일반적으로 유니 코드 인수를 사용하는 운영 체제 API에 전달하기 전에 OCaml 문자열의 기본이되는 char *를 변환하는 데 사용됩니다. Unix에서는 caml_stat_strdup과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="aa908a40ba515918f9d5edbdcad8ebc1fe5c2b42" translate="yes" xml:space="preserve">
          <source>characters</source>
          <target state="translated">characters</target>
        </trans-unit>
        <trans-unit id="0e2b31b5675ecfcea28e1bc6ea61266b418c839f" translate="yes" xml:space="preserve">
          <source>chown, fchown</source>
          <target state="translated">chown, fchown</target>
        </trans-unit>
        <trans-unit id="8d767bf5b72373d12f0efd4406677e9ed076f592" translate="yes" xml:space="preserve">
          <source>class</source>
          <target state="translated">class</target>
        </trans-unit>
        <trans-unit id="d52a33eead97a71117a46cf4e95a8a4ce30467f3" translate="yes" xml:space="preserve">
          <source>class method</source>
          <target state="translated">수업 방법</target>
        </trans-unit>
        <trans-unit id="bb8b29ba2c361968b2542a776a9c3dfff4a1f277" translate="yes" xml:space="preserve">
          <source>class names (&lt;a href=&quot;#class-name&quot;&gt;class-name&lt;/a&gt;),</source>
          <target state="translated">클래스 이름 ( &lt;a href=&quot;#class-name&quot;&gt;class-name&lt;/a&gt; ),</target>
        </trans-unit>
        <trans-unit id="fbf274f2daef387a23dffa13382373a5bcc2c55b" translate="yes" xml:space="preserve">
          <source>class type</source>
          <target state="translated">클래스 유형</target>
        </trans-unit>
        <trans-unit id="a3e7be6c69d88342536203b1571fd7d8bfb2a3df" translate="yes" xml:space="preserve">
          <source>class, &lt;a href=&quot;classes#hevea_manual.kwd143&quot;&gt;7.9.3&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd145&quot;&gt;7.9.4&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd147&quot;&gt;7.9.5&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd159&quot;&gt;7.10&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd169&quot;&gt;7.10.2&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd170&quot;&gt;7.10.2&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd187&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd197&quot;&gt;7.11.2&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd198&quot;&gt;7.11.2&lt;/a&gt;</source>
          <target state="translated">클래스, &lt;a href=&quot;classes#hevea_manual.kwd143&quot;&gt;7.9.3&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd145&quot;&gt;7.9.4&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd147&quot;&gt;7.9.5&lt;/a&gt; , &lt;a href=&quot;modtypes#hevea_manual.kwd159&quot;&gt;7.10&lt;/a&gt; , &lt;a href=&quot;modtypes#hevea_manual.kwd169&quot;&gt;7.10.2&lt;/a&gt; , &lt;a href=&quot;modtypes#hevea_manual.kwd170&quot;&gt;7.10.2&lt;/a&gt; , &lt;a href=&quot;modules#hevea_manual.kwd187&quot;&gt;7.11&lt;/a&gt; , &lt;a href=&quot;modules#hevea_manual.kwd197&quot;&gt;7.11.2&lt;/a&gt; , &lt;a href=&quot;modules#hevea_manual.kwd198&quot;&gt;7.11.2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="71bcf10511fad568b629d28c56ff7feff1ef22f7" translate="yes" xml:space="preserve">
          <source>class-binding</source>
          <target state="translated">class-binding</target>
        </trans-unit>
        <trans-unit id="0dfa40de86f0d8af7138c27b80cfce36b3e092c6" translate="yes" xml:space="preserve">
          <source>class-body</source>
          <target state="translated">class-body</target>
        </trans-unit>
        <trans-unit id="e3baf4e73ca120ee7eaaeeed64f1dc7bbc328d9e" translate="yes" xml:space="preserve">
          <source>class-body-type</source>
          <target state="translated">class-body-type</target>
        </trans-unit>
        <trans-unit id="b8003ad6cd8fb711d7fb1d099487681287d8df0d" translate="yes" xml:space="preserve">
          <source>class-definition</source>
          <target state="translated">class-definition</target>
        </trans-unit>
        <trans-unit id="9215a2ca4557897b343427716abc124d47fa6558" translate="yes" xml:space="preserve">
          <source>class-expr</source>
          <target state="translated">class-expr</target>
        </trans-unit>
        <trans-unit id="a3845894896b3c7333fdff3aa49c932e3bffd95e" translate="yes" xml:space="preserve">
          <source>class-field</source>
          <target state="translated">class-field</target>
        </trans-unit>
        <trans-unit id="b080298e07289b6ef306ac5023ced1575edeac2d" translate="yes" xml:space="preserve">
          <source>class-field-spec</source>
          <target state="translated">class-field-spec</target>
        </trans-unit>
        <trans-unit id="21af04aa3b5af0ea90010d0c0914efac38e9ea5a" translate="yes" xml:space="preserve">
          <source>class-name</source>
          <target state="translated">class-name</target>
        </trans-unit>
        <trans-unit id="d4c74f244ee67cc96905b30b781591e6acf2753f" translate="yes" xml:space="preserve">
          <source>class-path</source>
          <target state="translated">class-path</target>
        </trans-unit>
        <trans-unit id="06c5a4fb1e6da1b8f0f1f913fe3fafb4f95b0582" translate="yes" xml:space="preserve">
          <source>class-spec</source>
          <target state="translated">class-spec</target>
        </trans-unit>
        <trans-unit id="d9f224575fb0d8b3c6c3d80f66cef25947fff065" translate="yes" xml:space="preserve">
          <source>class-specification</source>
          <target state="translated">class-specification</target>
        </trans-unit>
        <trans-unit id="eda43ef03abd77f6ca03a3bb4e37dd8ba826fff5" translate="yes" xml:space="preserve">
          <source>class-type</source>
          <target state="translated">class-type</target>
        </trans-unit>
        <trans-unit id="ef958ab46a4f3085af1d4d4f55658cb4444ca230" translate="yes" xml:space="preserve">
          <source>class:</source>
          <target state="translated">class:</target>
        </trans-unit>
        <trans-unit id="400e5d81583e055c53bd38f8d5544fa644ba2712" translate="yes" xml:space="preserve">
          <source>class&lt;a href=&quot;#class-binding&quot;&gt;class-binding&lt;/a&gt; { and&lt;a href=&quot;#class-binding&quot;&gt;class-binding&lt;/a&gt; }</source>
          <target state="translated">클래스 &lt;a href=&quot;#class-binding&quot;&gt;클래스 바인딩&lt;/a&gt; {및 &lt;a href=&quot;#class-binding&quot;&gt;클래스 바인딩&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="1dadb31ea72fd62d213f58fa6711bc7b519a2ca1" translate="yes" xml:space="preserve">
          <source>class&lt;a href=&quot;#class-spec&quot;&gt;class-spec&lt;/a&gt; { and&lt;a href=&quot;#class-spec&quot;&gt;class-spec&lt;/a&gt; }</source>
          <target state="translated">class &lt;a href=&quot;#class-spec&quot;&gt;class-spec&lt;/a&gt; {및 &lt;a href=&quot;#class-spec&quot;&gt;class-spec&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="ab6ab98b836d6d64d4b9f3146b49cbcf9bee6717" translate="yes" xml:space="preserve">
          <source>classtype-def</source>
          <target state="translated">classtype-def</target>
        </trans-unit>
        <trans-unit id="d92dac5dc34da28e49df894b68924460d949a415" translate="yes" xml:space="preserve">
          <source>classtype-definition</source>
          <target state="translated">classtype-definition</target>
        </trans-unit>
        <trans-unit id="285d92bdbee34465a7fdf92fb82c39749f0f039e" translate="yes" xml:space="preserve">
          <source>classtype-path</source>
          <target state="translated">classtype-path</target>
        </trans-unit>
        <trans-unit id="4c04636c06981fe9f6d61d92d9456af7b3de3e8a" translate="yes" xml:space="preserve">
          <source>classtype:</source>
          <target state="translated">classtype:</target>
        </trans-unit>
        <trans-unit id="869829acd738c5dac3bc8510eb02c66e1ad5db8e" translate="yes" xml:space="preserve">
          <source>classtype&lt;a href=&quot;#classtype-def&quot;&gt;classtype-def&lt;/a&gt; { and&lt;a href=&quot;#classtype-def&quot;&gt;classtype-def&lt;/a&gt; }</source>
          <target state="translated">classtype &lt;a href=&quot;#classtype-def&quot;&gt;classtype-def&lt;/a&gt; {및 &lt;a href=&quot;#classtype-def&quot;&gt;classtype-def&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="68279b7a5c5dbc171919343dde1977e500869832" translate="yes" xml:space="preserve">
          <source>cmp:</source>
          <target state="translated">cmp:</target>
        </trans-unit>
        <trans-unit id="553768b3bee6925c1b6dd1539addb6cb588d0c7b" translate="yes" xml:space="preserve">
          <source>command subcommand &lt;code&gt;options&lt;/code&gt; where the list of options depends on the value of the subcommand argument.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 목록이 하위 명령 인수의 값에 따라 달라지는 명령 하위 명령 옵션 .</target>
        </trans-unit>
        <trans-unit id="428a468feca925744523643cf7e53ce50f474323" translate="yes" xml:space="preserve">
          <source>comparisons (&lt;code&gt;=&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, etc, as well as &lt;a href=&quot;stdlib#VALcompare&quot;&gt;&lt;code&gt;compare&lt;/code&gt;&lt;/a&gt;);</source>
          <target state="translated">비교 ( &lt;code&gt;=&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; 등 및 &lt;a href=&quot;stdlib#VALcompare&quot;&gt; &lt;code&gt;compare&lt;/code&gt; &lt;/a&gt; );</target>
        </trans-unit>
        <trans-unit id="92feb91459c458aa6b1f76052516855e022d15d8" translate="yes" xml:space="preserve">
          <source>compile to native code. Without these conditions being satisfied the functions in this module will have no effect.</source>
          <target state="translated">네이티브 코드로 컴파일합니다. 이러한 조건이 충족되지 않으면이 모듈의 기능은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1877bd461ec69e59e632c38c04de5ad31c85ef37" translate="yes" xml:space="preserve">
          <source>configure the compiler with &quot;-spacetime&quot;;</source>
          <target state="translated">&quot;-spacetime&quot;으로 컴파일러를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="6e084f18133250f2e634eae29d9045ab677b4937" translate="yes" xml:space="preserve">
          <source>const struct custom_fixed_length* fixed_length</source>
          <target state="translated">const 구조체 custom_fixed_length * fixed_length</target>
        </trans-unit>
        <trans-unit id="bdc40c00b134ba2e17aaa12820a0f9d7af1fb7c5" translate="yes" xml:space="preserve">
          <source>const:</source>
          <target state="translated">const:</target>
        </trans-unit>
        <trans-unit id="d810ca965a236c6f46a932efff918a4b3a191918" translate="yes" xml:space="preserve">
          <source>constant</source>
          <target state="translated">constant</target>
        </trans-unit>
        <trans-unit id="d99aa54a7aa7e291a189a778f95a6a8b54eadd02" translate="yes" xml:space="preserve">
          <source>constr</source>
          <target state="translated">constr</target>
        </trans-unit>
        <trans-unit id="7c2459502a99827d118c6620780fd83c34d7c818" translate="yes" xml:space="preserve">
          <source>constr-args</source>
          <target state="translated">constr-args</target>
        </trans-unit>
        <trans-unit id="6aaf7dc052404a0def924d13cb7fefd2c5d46800" translate="yes" xml:space="preserve">
          <source>constr-decl</source>
          <target state="translated">constr-decl</target>
        </trans-unit>
        <trans-unit id="f14414ed569b076ce031ad6d07e8e61ed758ca68" translate="yes" xml:space="preserve">
          <source>constr-def</source>
          <target state="translated">constr-def</target>
        </trans-unit>
        <trans-unit id="26ced0ba99c41fdb04e52808108512ce54059fb1" translate="yes" xml:space="preserve">
          <source>constr-name</source>
          <target state="translated">constr-name</target>
        </trans-unit>
        <trans-unit id="07822dfb3ad950224ca5f923721fae3aaa4b28c5" translate="yes" xml:space="preserve">
          <source>constraint'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;</source>
          <target state="translated">constraint'&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="33a4124293eb998e782195710e0d6c1e376e9593" translate="yes" xml:space="preserve">
          <source>constraint, &lt;a href=&quot;typedecl#hevea_manual.kwd97&quot;&gt;7.8.1&lt;/a&gt;, &lt;a href=&quot;typedecl#hevea_manual.kwd99&quot;&gt;7.8.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd109&quot;&gt;7.9.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd117&quot;&gt;7.9.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd129&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd141&quot;&gt;7.9.2&lt;/a&gt;</source>
          <target state="translated">제약, &lt;a href=&quot;typedecl#hevea_manual.kwd97&quot;&gt;7.8.1&lt;/a&gt; , &lt;a href=&quot;typedecl#hevea_manual.kwd99&quot;&gt;7.8.1&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd109&quot;&gt;7.9.1&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd117&quot;&gt;7.9.1&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd129&quot;&gt;7.9.2&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd141&quot;&gt;7.9.2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f12e05c5db5e00db727da146959722b2d63e6127" translate="yes" xml:space="preserve">
          <source>constraint&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;</source>
          <target state="translated">constraint&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05d2609d4b6af181eb59c550508ff23be347961d" translate="yes" xml:space="preserve">
          <source>contains a reference to compilation unit M when compiled to bytecode. This reference forces M to be linked and its initialization code to be executed. The native-code compiler eliminates the reference to M, hence the compilation unit M may not be linked and executed. A workaround is to compile M with the -linkall flag so that it will always be linked and executed, even if not referenced. See also the Sys.opaque_identity function from the Sys standard library module.</source>
          <target state="translated">바이트 코드로 컴파일 할 때 컴파일 단위 M에 대한 참조를 포함합니다. 이 참조는 M이 링크되고 초기화 코드가 실행되도록합니다. 네이티브 코드 컴파일러는 M에 대한 참조를 제거하므로 컴파일 단위 M이 연결 및 실행되지 않을 수 있습니다. 해결 방법은 -linkall 플래그를 사용하여 M을 컴파일하여 참조되지 않더라도 항상 링크되고 실행되도록하는 것입니다. Sys 표준 라이브러리 모듈의 Sys.opaque_identity 함수도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="226d200456eb3bfd352f53e040b453787b46cc24" translate="yes" xml:space="preserve">
          <source>contextual</source>
          <target state="translated">contextual</target>
        </trans-unit>
        <trans-unit id="d32f507e70819a8b5872a31e2e7880f8f11db8fa" translate="yes" xml:space="preserve">
          <source>conversion specifications, each of which causes reading and conversion of one argument for the function &lt;code&gt;f&lt;/code&gt; (see &lt;a href=&quot;scanf#conversion&quot;&gt;&lt;i&gt;Conversion specifications in format strings&lt;/i&gt;&lt;/a&gt;),</source>
          <target state="translated">변환 스펙, 각각은 함수 &lt;code&gt;f&lt;/code&gt; 에 대한 하나의 인수를 읽고 변환하도록합니다 ( &lt;a href=&quot;scanf#conversion&quot;&gt;&lt;i&gt;형식 문자열의 변환 스펙&lt;/i&gt;&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="333d8a7c2bd7fd4cefaebb4cc6271338502485c6" translate="yes" xml:space="preserve">
          <source>core-operator-char</source>
          <target state="translated">core-operator-char</target>
        </trans-unit>
        <trans-unit id="8a808c90d9a84d21576ddf0beed9d69f191be593" translate="yes" xml:space="preserve">
          <source>corresponds to private variant types. One cannot create a value of the private type [v], except using the constructors that are explicitly listed as present, (`A n) in this example; yet, when patter-matching on a [v], one should assume that any of the constructors of [t] could be present.</source>
          <target state="translated">비공개 변형 유형에 해당합니다. 이 예에서 명시 적으로 존재하는 것으로 나열된 생성자 (`A n)를 사용하는 경우를 제외하고는 개인 유형 [v]의 값을 만들 수 없습니다. 그러나 [v]에 대한 패턴 일치를 수행 할 때 [t]의 생성자가 존재할 수 있다고 가정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7013e4aaa88a7fafd5559318a944cd9c6ec28404" translate="yes" xml:space="preserve">
          <source>create the file if it does not exist.</source>
          <target state="translated">파일이 없으면 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="3c363836cf4e16666669a25da280a1865c2d2874" translate="yes" xml:space="preserve">
          <source>d</source>
          <target state="translated">d</target>
        </trans-unit>
        <trans-unit id="e19492b548515ffbe34cf17cbd1ef522ab1414dc" translate="yes" xml:space="preserve">
          <source>decrements in process virtual time, and sends &lt;code&gt;SIGVTALRM&lt;/code&gt; when expired.</source>
          <target state="translated">프로세스 가상 시간이 감소하고 만료되면 &lt;code&gt;SIGVTALRM&lt;/code&gt; 을 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="ef778d13de8cafc01808a69b9932094f49798fdd" translate="yes" xml:space="preserve">
          <source>decrements in real time, and sends the signal &lt;code&gt;SIGALRM&lt;/code&gt; when expired.</source>
          <target state="translated">실시간으로 감소하고 만료되면 &lt;code&gt;SIGALRM&lt;/code&gt; 신호를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="a22c6a976d9866fd964b6e5a20af7db6ea2ab552" translate="yes" xml:space="preserve">
          <source>define</source>
          <target state="translated">define</target>
        </trans-unit>
        <trans-unit id="03a76339fa4d42bfdc8e8baceab3440cef624007" translate="yes" xml:space="preserve">
          <source>defining the module B as</source>
          <target state="translated">모듈 B를 다음과 같이 정의</target>
        </trans-unit>
        <trans-unit id="f3f1dd33eb2a8b380b64a830e5fd90eab77d9ff3" translate="yes" xml:space="preserve">
          <source>definition</source>
          <target state="translated">definition</target>
        </trans-unit>
        <trans-unit id="3e327c241738fea022a517d9eecee46776680496" translate="yes" xml:space="preserve">
          <source>definition of the value type, and conversion macros</source>
          <target state="translated">값 유형 및 전환 매크로 정의</target>
        </trans-unit>
        <trans-unit id="ed58bf3be1d2a5949990ba23d28e1f05c882f8a3" translate="yes" xml:space="preserve">
          <source>delete [breakpoint-numbers]</source>
          <target state="translated">[중단 점 번호] 삭제</target>
        </trans-unit>
        <trans-unit id="0179ecbcdaafefd6b259581d27637a1a01473312" translate="yes" xml:space="preserve">
          <source>directive-argument</source>
          <target state="translated">directive-argument</target>
        </trans-unit>
        <trans-unit id="8d392f56d616a516ceabb82ed8906418bce4647d" translate="yes" xml:space="preserve">
          <source>directory</source>
          <target state="translated">directory</target>
        </trans-unit>
        <trans-unit id="28dc9d3b1bb1b104a7917c77a1d97552e99c49a2" translate="yes" xml:space="preserve">
          <source>directorydirectorynames</source>
          <target state="translated">directorydirectorynames</target>
        </trans-unit>
        <trans-unit id="9b0115d2d38b2bf10f676e8332fc03cddd564a00" translate="yes" xml:space="preserve">
          <source>directorydirectorynamesformodulename</source>
          <target state="translated">directorydirectorynamesformodulename</target>
        </trans-unit>
        <trans-unit id="53c975b51fbabf80b49198bf9458a9e1d290fcf9" translate="yes" xml:space="preserve">
          <source>disable color output.</source>
          <target state="translated">컬러 출력을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="bb0ea05e5435bb0df5d81d6e78b6d0af265162e9" translate="yes" xml:space="preserve">
          <source>display variables</source>
          <target state="translated">디스플레이 변수</target>
        </trans-unit>
        <trans-unit id="e5c0f9710c0d52c78a4d013cd66763d60d97bcb7" translate="yes" xml:space="preserve">
          <source>do not block if no child has died yet, but immediately return with a pid equal to 0.</source>
          <target state="translated">아직 자식이 죽지 않았다면 차단하지 말고 즉시 0과 같은 pid를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="833c8b98d0224690df2f190dea1efcb42f344fbb" translate="yes" xml:space="preserve">
          <source>do, see while, for</source>
          <target state="translated">~을 위해, 잠시 동안, ~을 보라. ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</target>
        </trans-unit>
        <trans-unit id="d84288230cbd24a8cc378cfb3d714310728faf29" translate="yes" xml:space="preserve">
          <source>does not need to be evaluated at all; and/or</source>
          <target state="translated">전혀 평가할 필요가 없습니다. 및 / 또는</target>
        </trans-unit>
        <trans-unit id="38fd56990cf282add706144ed22e70a66191320c" translate="yes" xml:space="preserve">
          <source>done, see while, for</source>
          <target state="translated">완료, 잠시 동안</target>
        </trans-unit>
        <trans-unit id="07eb0e52b368fc215197e9dccccc06b07fad2958" translate="yes" xml:space="preserve">
          <source>dot-ext</source>
          <target state="translated">dot-ext</target>
        </trans-unit>
        <trans-unit id="453a36a657365591af7b5c95c20406ec99ef8b24" translate="yes" xml:space="preserve">
          <source>dot-operator-char</source>
          <target state="translated">dot-operator-char</target>
        </trans-unit>
        <trans-unit id="bdb36bb22deb169275b3094ba9005a29eeddd195" translate="yes" xml:space="preserve">
          <source>double</source>
          <target state="translated">double</target>
        </trans-unit>
        <trans-unit id="bfbe0565f9808b4fb0e1b18327fbb6c2ea967077" translate="yes" xml:space="preserve">
          <source>double quote (&quot;)</source>
          <target state="translated">큰 따옴표 ( &quot;)</target>
        </trans-unit>
        <trans-unit id="1f65fab5c0d7d9bcd8d721da02004fedaedb68be" translate="yes" xml:space="preserve">
          <source>down [count]</source>
          <target state="translated">아래로 [개수]</target>
        </trans-unit>
        <trans-unit id="799e0a3b5afe04c89326401016fc0c66d4458b42" translate="yes" xml:space="preserve">
          <source>downto, see for</source>
          <target state="translated">downto, 참조</target>
        </trans-unit>
        <trans-unit id="e407d8cdd0f285d5c62e80663efb9cc02851303c" translate="yes" xml:space="preserve">
          <source>drops all bindings of &lt;code&gt;m&lt;/code&gt; whose value is an empty list, and pops the first element of each value that is non-empty.</source>
          <target state="translated">값이 빈 목록 인 &lt;code&gt;m&lt;/code&gt; 의 모든 바인딩을 삭제 하고 비어 있지 않은 각 값의 첫 번째 요소를 팝합니다.</target>
        </trans-unit>
        <trans-unit id="31a6a677a43d8f38a109cb03dec2a64920269ab9" translate="yes" xml:space="preserve">
          <source>dst:</source>
          <target state="translated">dst:</target>
        </trans-unit>
        <trans-unit id="58e6b3a414a1e090dfc6029add0f3555ccba127f" translate="yes" xml:space="preserve">
          <source>e</source>
          <target state="translated">e</target>
        </trans-unit>
        <trans-unit id="757397c6e0613e4417358197d53f7db2c37b4724" translate="yes" xml:space="preserve">
          <source>e has no free occurrence of any of name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt;</source>
          <target state="translated">e에는 이름 &lt;sub&gt;1&lt;/sub&gt; &amp;hellip; 이름 &lt;sub&gt;n&lt;/sub&gt; 의 빈 발생이 없습니다.&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="51fe7f7274e0449b5ed33b2fcaa9170dab3b3628" translate="yes" xml:space="preserve">
          <source>e has one of the following forms, where each one of &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt; is statically constructive with respect to name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt;, and &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt; is statically constructive with respect to name&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name&lt;sub&gt;n&lt;/sub&gt;, xname&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; xname&lt;sub&gt;m&lt;/sub&gt;:</source>
          <target state="translated">e는 다음 형식 중 하나입니다. 여기서 &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;m 각각&lt;/sub&gt; 은 이름 &lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name &lt;sub&gt;n&lt;/sub&gt; 에 대해 정적으로 구성 적 이며 &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt; 은 이름 &lt;sub&gt;1&lt;/sub&gt; &amp;hellip; name &lt;sub&gt;n&lt;/sub&gt; , xname &lt;sub&gt;1&lt;/sub&gt; &amp;hellip; xname &lt;sub&gt;m에&lt;/sub&gt; 대해 정적으로 구성 적입니다 .</target>
        </trans-unit>
        <trans-unit id="fcf7c2ddc6f44c64ae6b993a53f6e3ea4c518399" translate="yes" xml:space="preserve">
          <source>e has the form &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;; &amp;hellip; ;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt; where &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt; is immediately linked to name</source>
          <target state="translated">e의 형식은 &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 이고; &amp;hellip;; &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt; 여기서 &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt; 은 이름에 즉시 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="df2817894d7dee8de8758ce8f735537aea0b6367" translate="yes" xml:space="preserve">
          <source>e has the form fun &amp;hellip; -&amp;gt; &amp;hellip;</source>
          <target state="translated">e의 형식은 fun&amp;hellip;-&amp;gt;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="dd8e665d7df99e337c22b1c4be2c513409b5eaa9" translate="yes" xml:space="preserve">
          <source>e has the form function &amp;hellip; -&amp;gt; &amp;hellip;</source>
          <target state="translated">e는 형식 기능을가집니다.&amp;hellip;-&amp;gt;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="99ac9ada8c9fe80980d92b1caa59645274bb0a33" translate="yes" xml:space="preserve">
          <source>e has the form lazy( &amp;hellip; )</source>
          <target state="translated">e는 lazy (&amp;hellip;) 형식입니다.</target>
        </trans-unit>
        <trans-unit id="f4de602197c0cd9ccd7c6607098ee6083dc9167b" translate="yes" xml:space="preserve">
          <source>e has the form let [rec] xname&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;and &amp;hellip; andxname&lt;sub&gt;m&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt; where &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt; is immediately linked to name or to one of the xname&lt;sub&gt;i&lt;/sub&gt; such that &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; is immediately linked to name.</source>
          <target state="translated">E는 폼하자 [촬영] XName이 갖는 &lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;expr#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 및 ... andxname &lt;sub&gt;m&lt;/sub&gt; = &lt;a href=&quot;expr#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt; 에 &lt;a href=&quot;expr#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;0 &lt;/sub&gt;&lt;a href=&quot;expr#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt; 즉시 이름 또는 XName이 중 하나에 연결된 &lt;sub&gt;I&lt;/sub&gt; 등 &lt;a href=&quot;expr#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;제가&lt;/sub&gt; 즉시 이름에 연결된다.</target>
        </trans-unit>
        <trans-unit id="c0656ec9ffb0b7921a052be24cfb4ae15f4ee4e3" translate="yes" xml:space="preserve">
          <source>e is a variable</source>
          <target state="translated">e는 변수</target>
        </trans-unit>
        <trans-unit id="26a1d03b4fa9567db0939f772ff344bebbfe891b" translate="yes" xml:space="preserve">
          <source>e is name</source>
          <target state="translated">e는 이름이다</target>
        </trans-unit>
        <trans-unit id="2da461a9fb84c0ad13f2efac393ac2ead59815a2" translate="yes" xml:space="preserve">
          <source>e. g.</source>
          <target state="translated">예 :</target>
        </trans-unit>
        <trans-unit id="97c318f6c6008d67b9664c3c45b78e7730ca703d" translate="yes" xml:space="preserve">
          <source>else, see if</source>
          <target state="translated">그렇지 않으면</target>
        </trans-unit>
        <trans-unit id="b2d24c4d91f1728ade8f4dd643d87531b3263243" translate="yes" xml:space="preserve">
          <source>emphasize &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#text&quot;&gt;텍스트를&lt;/a&gt; 강조 합니다 .</target>
        </trans-unit>
        <trans-unit id="cedcf2a1a6ef9de21d881662e38b02d6d3f8384b" translate="yes" xml:space="preserve">
          <source>empty the file if it already exists.</source>
          <target state="translated">이미 존재하는 경우 파일을 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="b17ec36e9379c05dc57269321d86b686f2333096" translate="yes" xml:space="preserve">
          <source>enable colors unconditionally;</source>
          <target state="translated">무조건 색상을 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="aef0b24e7008d716738f718268f4d8c0207432a1" translate="yes" xml:space="preserve">
          <source>end, &lt;a href=&quot;const#hevea_manual.kwd14&quot;&gt;7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd39&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd59&quot;&gt;7.7.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd102&quot;&gt;7.9.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd119&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd151&quot;&gt;7.10&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd164&quot;&gt;7.10.2&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd180&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd192&quot;&gt;7.11.2&lt;/a&gt;</source>
          <target state="translated">끝, &lt;a href=&quot;const#hevea_manual.kwd14&quot;&gt;7.5&lt;/a&gt; , &lt;a href=&quot;expr#hevea_manual.kwd39&quot;&gt;7.7&lt;/a&gt; , &lt;a href=&quot;expr#hevea_manual.kwd59&quot;&gt;7.7.2&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd102&quot;&gt;7.9.1&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd119&quot;&gt;7.9.2&lt;/a&gt; , &lt;a href=&quot;modtypes#hevea_manual.kwd151&quot;&gt;7.10&lt;/a&gt; , &lt;a href=&quot;modtypes#hevea_manual.kwd164&quot;&gt;7.10.2&lt;/a&gt; , &lt;a href=&quot;modules#hevea_manual.kwd180&quot;&gt;7.11&lt;/a&gt; , &lt;a href=&quot;modules#hevea_manual.kwd192&quot;&gt;7.11.2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="711175fbdbe24885e9f9f679df119dc29c631f8b" translate="yes" xml:space="preserve">
          <source>entrypoint [exp&lt;sub&gt;1&lt;/sub&gt;&amp;hellip; exp&lt;sub&gt;n&lt;/sub&gt;] lexbuf</source>
          <target state="translated">진입 점 [exp &lt;sub&gt;1&lt;/sub&gt; &amp;hellip; exp &lt;sub&gt;n&lt;/sub&gt; ] lexbuf</target>
        </trans-unit>
        <trans-unit id="e8a365f95cb8551a2062717881f7d71e5306abd5" translate="yes" xml:space="preserve">
          <source>eof</source>
          <target state="translated">eof</target>
        </trans-unit>
        <trans-unit id="3d049c928df32d101c29c26b373821a507099452" translate="yes" xml:space="preserve">
          <source>escape-sequence</source>
          <target state="translated">escape-sequence</target>
        </trans-unit>
        <trans-unit id="8d2bca9a432a39e18786835ac3975c3b23f451e6" translate="yes" xml:space="preserve">
          <source>escaped-string</source>
          <target state="translated">escaped-string</target>
        </trans-unit>
        <trans-unit id="9766db168aaf6a914bfb8cbba6191943d675fe12" translate="yes" xml:space="preserve">
          <source>establish_server</source>
          <target state="translated">establish_server</target>
        </trans-unit>
        <trans-unit id="d8d42401720c70b1ce0ae3ec57d8973f649448c8" translate="yes" xml:space="preserve">
          <source>evaluates &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; in some unspecified order and matches their values against the patterns &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. If the matchings succeed, &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is evaluated in the environment enriched by the bindings performed during matching, and the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; is returned as the value of the whole let expression. If one of the matchings fails, the exception Match_failure is raised.</source>
          <target state="translated">평가하여 &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ... &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; 정해지지 않은 순서로 상기 패턴에 대해 그 값과 일치하는 &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ... &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; . 일치가 성공하면 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 은 일치하는 동안 수행 된 바인딩으로 강화 된 환경에서 평가되고 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 의 값은 전체 let 식의 값으로 반환됩니다. 일치 중 하나가 실패하면 Match_failure 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="40b7de6ac0851edd15ea66f92bc8e0791529d96f" translate="yes" xml:space="preserve">
          <source>evaluates the expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; and returns its value if the evaluation of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; does not raise any exception. If the evaluation of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; raises an exception, the exception value is matched against the patterns &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. If the matching against &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; succeeds, the associated expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; is evaluated, and its value becomes the value of the whole try expression. The evaluation of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; takes place in an environment enriched by the bindings performed during matching. If several patterns match the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, the one that occurs first in the try expression is selected. If none of the patterns matches the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, the exception value is raised again, thereby transparently &amp;ldquo;passing through&amp;rdquo; the try construct.</source>
          <target state="translated">식 평가 &lt;a href=&quot;#expr&quot;&gt;EXPR을&lt;/a&gt; 하고 평가하면 그 값을 반환 &lt;a href=&quot;#expr&quot;&gt;expr이&lt;/a&gt; 예외를 발생시키지 않습니다. &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 평가 에서 예외가 발생하면 예외 값이 패턴 &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 에서 &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 에 대해 일치 됩니다. &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; 에 대한 일치 가 성공하면 연관된 표현식 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; 가 평가되고 그 값이 전체 try 표현식의 값이됩니다. &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; 의 평가는 일치하는 동안 수행 된 바인딩으로 강화 된 환경에서 발생합니다. 여러 패턴이 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 의 값과 일치하는 경우, try 식에서 가장 먼저 발생하는 항목이 선택됩니다. &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 값과 일치하는 패턴이 없으면 예외 값이 다시 발생하여 try 구문을 투명하게 &quot;통과&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="5d42ad1769f229c76031f30a404b4f7863d68de0" translate="yes" xml:space="preserve">
          <source>exception</source>
          <target state="translated">exception</target>
        </trans-unit>
        <trans-unit id="0ef70e6a0aa89b4ca352814bdbb1a646404b65f4" translate="yes" xml:space="preserve">
          <source>exception, &lt;a href=&quot;typedecl#hevea_manual.kwd100&quot;&gt;7.8.2&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd158&quot;&gt;7.10&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd168&quot;&gt;7.10.2&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd186&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd196&quot;&gt;7.11.2&lt;/a&gt;</source>
          <target state="translated">예외, &lt;a href=&quot;typedecl#hevea_manual.kwd100&quot;&gt;7.8.2&lt;/a&gt; , &lt;a href=&quot;modtypes#hevea_manual.kwd158&quot;&gt;7.10&lt;/a&gt; , &lt;a href=&quot;modtypes#hevea_manual.kwd168&quot;&gt;7.10.2&lt;/a&gt; , &lt;a href=&quot;modules#hevea_manual.kwd186&quot;&gt;7.11&lt;/a&gt; , &lt;a href=&quot;modules#hevea_manual.kwd196&quot;&gt;7.11.2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4c059f88a3ed4105696537b7858f2b73b79d996" translate="yes" xml:space="preserve">
          <source>exception-definition</source>
          <target state="translated">exception-definition</target>
        </trans-unit>
        <trans-unit id="aafc45f113e4ee4827753cfa5ddd32f6b9b8e7dd" translate="yes" xml:space="preserve">
          <source>exception:</source>
          <target state="translated">exception:</target>
        </trans-unit>
        <trans-unit id="2194fd1cdf62726bf2b756afa4c471797a6ff1e0" translate="yes" xml:space="preserve">
          <source>exception&lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt;</source>
          <target state="translated">exception&lt;a href=&quot;#constr-decl&quot;&gt;constr-decl&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56f0b21b284fbbc9f75a6e2a8846ecee8d477c99" translate="yes" xml:space="preserve">
          <source>exception&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;</source>
          <target state="translated">exception&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ff60ca6f137fe92c59a4b2a5d3687066ffd89487" translate="yes" xml:space="preserve">
          <source>exception&lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt;=&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;</source>
          <target state="translated">exception&lt;a href=&quot;names#constr-name&quot;&gt;constr-name&lt;/a&gt;=&lt;a href=&quot;names#constr&quot;&gt;constr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3f3369e0544e158e7e2b5b8651c3d09044a1d1f" translate="yes" xml:space="preserve">
          <source>exception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt;</source>
          <target state="translated">exception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="70e23345fd17464f3946c94c84e3a27f3d6f3324" translate="yes" xml:space="preserve">
          <source>exception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; }</source>
          <target state="translated">예외 &lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;항목 속성&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="4f940a5e2a0f28f13e77c8c0235ca963b9da6f81" translate="yes" xml:space="preserve">
          <source>execute permission X_OK cannot be tested, it just tests for read permission instead</source>
          <target state="translated">실행 권한 X_OK는 테스트 할 수 없습니다. 대신 읽기 권한 만 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="7eea892eb403b39624a315f2ae9716d10340d45a" translate="yes" xml:space="preserve">
          <source>executes &lt;a href=&quot;stdlib#VALexit&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;stdlib#VALexit&quot;&gt; &lt;code&gt;exit&lt;/code&gt; &lt;/a&gt; 실행합니다.</target>
        </trans-unit>
        <trans-unit id="b2233dde714bc31bfef2d11ab471a8613d760dcd" translate="yes" xml:space="preserve">
          <source>executes the C function &lt;code&gt;caml_shutdown&lt;/code&gt;. The functions are called in 'last in, first out' order: the function most recently added with &lt;code&gt;at_exit&lt;/code&gt; is called first.</source>
          <target state="translated">C 함수 &lt;code&gt;caml_shutdown&lt;/code&gt; 을 실행합니다 . 함수는 'last in, first out'순서 로 호출됩니다. &lt;code&gt;at_exit&lt;/code&gt; 로 가장 최근에 추가 된 함수 가 먼저 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7ac8da6660c112411ac5323ea656dc8387da47f8" translate="yes" xml:space="preserve">
          <source>executes the compiled code contained in a.out, passing it as arguments the character strings arg&lt;sub&gt;1&lt;/sub&gt; to arg&lt;sub&gt;n&lt;/sub&gt;. (See chapter &lt;a href=&quot;runtime#c%3Aruntime&quot;&gt;11&lt;/a&gt; for more details.)</source>
          <target state="translated">a.out에 포함 된 컴파일 된 코드를 실행하여 arg &lt;sub&gt;1&lt;/sub&gt; ~ arg &lt;sub&gt;n&lt;/sub&gt; 문자열을 인수로 전달합니다 . (자세한 내용은 &lt;a href=&quot;runtime#c%3Aruntime&quot;&gt;11&lt;/a&gt; 장 을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="0fd1860204d6cee43392972817e66792ee702b89" translate="yes" xml:space="preserve">
          <source>expr</source>
          <target state="translated">expr</target>
        </trans-unit>
        <trans-unit id="40cd9d83462196d0446a104d1314917b241cd28a" translate="yes" xml:space="preserve">
          <source>expr&lt;sub&gt;1&lt;/sub&gt;</source>
          <target state="translated">expr&lt;sub&gt;1&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="75da4f81011bd9c9811b000d0be9a8105fc49a58" translate="yes" xml:space="preserve">
          <source>expr&lt;sub&gt;n&lt;/sub&gt;</source>
          <target state="translated">expr&lt;sub&gt;n&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="ec9814396ba26fa02dc3261046ba55a3b4bb32a6" translate="yes" xml:space="preserve">
          <source>expression</source>
          <target state="translated">expression</target>
        </trans-unit>
        <trans-unit id="ee9a5aff545773ac86403c5b3af14f29f43d0129" translate="yes" xml:space="preserve">
          <source>extended-module-name</source>
          <target state="translated">extended-module-name</target>
        </trans-unit>
        <trans-unit id="ca9b5a6728207cebac5f5a39be588ec15635879b" translate="yes" xml:space="preserve">
          <source>extended-module-path</source>
          <target state="translated">extended-module-path</target>
        </trans-unit>
        <trans-unit id="f98961015a0ac393630f4eda3749d644a716da64" translate="yes" xml:space="preserve">
          <source>extension</source>
          <target state="translated">extension</target>
        </trans-unit>
        <trans-unit id="2a57aaf39e1e3d7e8b157188c31ea9d76afdf843" translate="yes" xml:space="preserve">
          <source>external, &lt;a href=&quot;modtypes#hevea_manual.kwd156&quot;&gt;7.10&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd166&quot;&gt;7.10.2&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd184&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd194&quot;&gt;7.11.2&lt;/a&gt;</source>
          <target state="translated">외부, &lt;a href=&quot;modtypes#hevea_manual.kwd156&quot;&gt;7.10&lt;/a&gt; , &lt;a href=&quot;modtypes#hevea_manual.kwd166&quot;&gt;7.10.2&lt;/a&gt; , &lt;a href=&quot;modules#hevea_manual.kwd184&quot;&gt;7.11&lt;/a&gt; , &lt;a href=&quot;modules#hevea_manual.kwd194&quot;&gt;7.11.2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="72f5dd6f61fb1f9bd3186ffb0b38b27e93e3825c" translate="yes" xml:space="preserve">
          <source>external-declaration</source>
          <target state="translated">external-declaration</target>
        </trans-unit>
        <trans-unit id="6ef49b996063dfbc19c08dd60476f57839f65e86" translate="yes" xml:space="preserve">
          <source>external&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;#external-declaration&quot;&gt;external-declaration&lt;/a&gt;</source>
          <target state="translated">external&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;#external-declaration&quot;&gt;external-declaration&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95b6b9caa85c2f979fcb31c62d74121e5c5b6937" translate="yes" xml:space="preserve">
          <source>external&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt;</source>
          <target state="translated">external&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="87ead56e0f36bc7f70901dac6db8f05625d47c9d" translate="yes" xml:space="preserve">
          <source>external&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;intfc#external-declaration&quot;&gt;external-declaration&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; }</source>
          <target state="translated">외부 &lt;a href=&quot;names#value-name&quot;&gt;값 이름&lt;/a&gt; : &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; = &lt;a href=&quot;intfc#external-declaration&quot;&gt;외부 선언&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;항목 속성&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="4a0a19218e082a343a1b17e5333409af9d98f0f5" translate="yes" xml:space="preserve">
          <source>f</source>
          <target state="translated">f</target>
        </trans-unit>
        <trans-unit id="ea13d66a0d95450ede3525ba60b4eefa6dfd4db7" translate="yes" xml:space="preserve">
          <source>f has arity 1, but g has arity 2. This allows a primitive to return a functional value (as in the f example above): just remember to name the functional return type in a type abbreviation.</source>
          <target state="translated">f에는 arity 1이 있지만 g에는 arity 2가 있습니다. 이렇게하면 프리미티브가 함수 값을 반환 할 수 있습니다 (위의 f 예제에서와 같이). 형식 약어로 함수 반환 유형의 이름을 지정하는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8345c0c004d7bcb51022387c853c3313838f4d4b" translate="yes" xml:space="preserve">
          <source>f:</source>
          <target state="translated">f:</target>
        </trans-unit>
        <trans-unit id="5101c030405d6eb4625b82ddb234a24b78cc7fd8" translate="yes" xml:space="preserve">
          <source>fail if Open_creat and the file already exists.</source>
          <target state="translated">Open_creat 및 파일이 이미 있으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="7cb6efb98ba5972a9b5090dc2e517fe14d12cb04" translate="yes" xml:space="preserve">
          <source>false</source>
          <target state="translated">false</target>
        </trans-unit>
        <trans-unit id="dec9612177c91c75a84643a56634d8c023453c45" translate="yes" xml:space="preserve">
          <source>false, &lt;a href=&quot;const#hevea_manual.kwd11&quot;&gt;7.5&lt;/a&gt;</source>
          <target state="translated">거짓, &lt;a href=&quot;const#hevea_manual.kwd11&quot;&gt;7.5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c99f0449b3ef1911061f6af48400d4f04a19034" translate="yes" xml:space="preserve">
          <source>fchmod</source>
          <target state="translated">fchmod</target>
        </trans-unit>
        <trans-unit id="2da0b68df8841752bb747a76780679bcd87c6215" translate="yes" xml:space="preserve">
          <source>field</source>
          <target state="translated">field</target>
        </trans-unit>
        <trans-unit id="501eee544c59dbac7271620c3b08ebf55c9d1e77" translate="yes" xml:space="preserve">
          <source>field &lt;code&gt;out_newline&lt;/code&gt; is equivalent to &lt;code&gt;out_string&amp;nbsp;&quot;\n&quot;&amp;nbsp;0&amp;nbsp;1&lt;/code&gt;;</source>
          <target state="translated">&lt;code&gt;out_newline&lt;/code&gt; 필드 는 &lt;code&gt;out_string&amp;nbsp;&quot;\n&quot;&amp;nbsp;0&amp;nbsp;1&lt;/code&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="f224b13da528327f36a0121f5d0030835cd2c673" translate="yes" xml:space="preserve">
          <source>field-decl</source>
          <target state="translated">field-decl</target>
        </trans-unit>
        <trans-unit id="ef34b6d49ac1b32c1828d0bcc806827363330301" translate="yes" xml:space="preserve">
          <source>field-name</source>
          <target state="translated">field-name</target>
        </trans-unit>
        <trans-unit id="0532f2b99db3b8d747dcdff72f0a33002abcd374" translate="yes" xml:space="preserve">
          <source>fields &lt;code&gt;out_spaces&lt;/code&gt; and &lt;code&gt;out_indent&lt;/code&gt; are equivalent to &lt;code&gt;out_string&amp;nbsp;(String.make&amp;nbsp;n&amp;nbsp;'&amp;nbsp;')&amp;nbsp;0&amp;nbsp;n&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;out_spaces&lt;/code&gt; 및 &lt;code&gt;out_indent&lt;/code&gt; 필드 는 &lt;code&gt;out_string&amp;nbsp;(String.make&amp;nbsp;n&amp;nbsp;'&amp;nbsp;')&amp;nbsp;0&amp;nbsp;n&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="5693614f3e4fce5f121c7d2adbc136f1eb188a69" translate="yes" xml:space="preserve">
          <source>fields &lt;code&gt;out_string&lt;/code&gt; and &lt;code&gt;out_flush&lt;/code&gt; are output device specific; (e.g. &lt;a href=&quot;stdlib#VALoutput_string&quot;&gt;&lt;code&gt;output_string&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdlib#VALflush&quot;&gt;&lt;code&gt;flush&lt;/code&gt;&lt;/a&gt; for a &lt;a href=&quot;stdlib#TYPEout_channel&quot;&gt;&lt;code&gt;out_channel&lt;/code&gt;&lt;/a&gt; device, or &lt;code&gt;Buffer.add_substring&lt;/code&gt; and &lt;a href=&quot;stdlib#VALignore&quot;&gt;&lt;code&gt;ignore&lt;/code&gt;&lt;/a&gt; for a &lt;code&gt;Buffer.t&lt;/code&gt; output device),</source>
          <target state="translated">&lt;code&gt;out_string&lt;/code&gt; 및 &lt;code&gt;out_flush&lt;/code&gt; 필드 는 출력 장치에 따라 다릅니다. (예 &lt;a href=&quot;stdlib#VALoutput_string&quot;&gt; &lt;code&gt;output_string&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stdlib#VALflush&quot;&gt; &lt;code&gt;flush&lt;/code&gt; &lt;/a&gt; A의 &lt;a href=&quot;stdlib#TYPEout_channel&quot;&gt; &lt;code&gt;out_channel&lt;/code&gt; 의&lt;/a&gt; 장치 또는 &lt;code&gt;Buffer.add_substring&lt;/code&gt; 및 &lt;a href=&quot;stdlib#VALignore&quot;&gt; &lt;code&gt;ignore&lt;/code&gt; &lt;/a&gt; A의 &lt;code&gt;Buffer.t&lt;/code&gt; 의 출력 장치)</target>
        </trans-unit>
        <trans-unit id="40c623613cc9bdaaab8b62fd9a9afb5e42754862" translate="yes" xml:space="preserve">
          <source>filename: no such file or directory</source>
          <target state="translated">파일 이름 : 해당 파일 또는 디렉토리 없음</target>
        </trans-unit>
        <trans-unit id="2cce4a92f41fe3d55a72c27b922c093bdd0a4267" translate="yes" xml:space="preserve">
          <source>finish</source>
          <target state="translated">finish</target>
        </trans-unit>
        <trans-unit id="685e80366130387cb75c055248326976d16fdf8d" translate="yes" xml:space="preserve">
          <source>float</source>
          <target state="translated">float</target>
        </trans-unit>
        <trans-unit id="152c24c58170f9f64b90bef69fb4df49a1344c48" translate="yes" xml:space="preserve">
          <source>float-literal</source>
          <target state="translated">float-literal</target>
        </trans-unit>
        <trans-unit id="56dd3d388832df06eeeca9911121590de20974cf" translate="yes" xml:space="preserve">
          <source>floating-attribute</source>
          <target state="translated">floating-attribute</target>
        </trans-unit>
        <trans-unit id="18978fed6c3afed1f7e9f12a99cb9fbaa75646cf" translate="yes" xml:space="preserve">
          <source>for HTML : &lt;a href=&quot;https://github.com/ocaml/ocaml/blob/4.11/ocamldoc/odoc_html.ml&quot;&gt;odoc_html.ml&lt;/a&gt;,</source>
          <target state="translated">HTML의 경우 : &lt;a href=&quot;https://github.com/ocaml/ocaml/blob/4.11/ocamldoc/odoc_html.ml&quot;&gt;odoc_html.ml&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="7d106b43161cd02fd67405ae6ea93f44eec0d64c" translate="yes" xml:space="preserve">
          <source>for HTML : Odoc_html.Html_generator (class html),</source>
          <target state="translated">HTML의 경우 : Odoc_html.Html_generator (클래스 html),</target>
        </trans-unit>
        <trans-unit id="a5ec24787e3e07187530822bbc9bbcb6f4080e61" translate="yes" xml:space="preserve">
          <source>for L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X : &lt;a href=&quot;https://github.com/ocaml/ocaml/blob/4.11/ocamldoc/odoc_latex.ml&quot;&gt;odoc_latex.ml&lt;/a&gt;,</source>
          <target state="translated">L에 대한 T &lt;sub&gt;E&lt;/sub&gt; X : &lt;a href=&quot;https://github.com/ocaml/ocaml/blob/4.11/ocamldoc/odoc_latex.ml&quot;&gt;odoc_latex.ml&lt;/a&gt; ,&lt;sup&gt;&lt;/sup&gt;&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="455dcbf553a3168bdbb6ede4dacf5924d575aa75" translate="yes" xml:space="preserve">
          <source>for L&lt;sup&gt;A&lt;/sup&gt;T&lt;sub&gt;E&lt;/sub&gt;X : Odoc_latex.Latex_generator (class latex),</source>
          <target state="translated">L에 대한 T &lt;sub&gt;E&lt;/sub&gt; X : Odoc_latex.Latex_generator (클래스 라텍스)&lt;sup&gt;&lt;/sup&gt;&lt;sub&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="9ef59934b5a2ed93691a76d31e92b245a003718f" translate="yes" xml:space="preserve">
          <source>for TeXinfo : &lt;a href=&quot;https://github.com/ocaml/ocaml/blob/4.11/ocamldoc/odoc_texi.ml&quot;&gt;odoc_texi.ml&lt;/a&gt;,</source>
          <target state="translated">TeXinfo : &lt;a href=&quot;https://github.com/ocaml/ocaml/blob/4.11/ocamldoc/odoc_texi.ml&quot;&gt;odoc_texi.ml&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="13d546518fdef082969985cb4a5d48964086187b" translate="yes" xml:space="preserve">
          <source>for TeXinfo : Odoc_texi.Texi_generator (class texi),</source>
          <target state="translated">TeXinfo : Odoc_texi.Texi_generator (클래스 texi),</target>
        </trans-unit>
        <trans-unit id="1086589c1e78e6e44f8a60b8a4e701ed49b09056" translate="yes" xml:space="preserve">
          <source>for graphviz (dot) : &lt;a href=&quot;https://github.com/ocaml/ocaml/blob/4.11/ocamldoc/odoc_dot.ml&quot;&gt;odoc_dot.ml&lt;/a&gt;.</source>
          <target state="translated">graphviz (점)의 경우 : &lt;a href=&quot;https://github.com/ocaml/ocaml/blob/4.11/ocamldoc/odoc_dot.ml&quot;&gt;odoc_dot.ml&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04b32c5544cf8a3bfcffa5e636e9eb153ea191e2" translate="yes" xml:space="preserve">
          <source>for graphviz (dot) : Odoc_dot.Dot_generator (class dot),</source>
          <target state="translated">graphviz (점)의 경우 : Odoc_dot.Dot_generator (클래스 점),</target>
        </trans-unit>
        <trans-unit id="a488e61ff6307d3aef44c40487ae194a336a6d10" translate="yes" xml:space="preserve">
          <source>for man pages : &lt;a href=&quot;https://github.com/ocaml/ocaml/blob/4.11/ocamldoc/odoc_man.ml&quot;&gt;odoc_man.ml&lt;/a&gt;,</source>
          <target state="translated">man 페이지의 경우 : &lt;a href=&quot;https://github.com/ocaml/ocaml/blob/4.11/ocamldoc/odoc_man.ml&quot;&gt;odoc_man.ml&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="2c9ef4d6ca06969b8a3fa544528c52c6647d2520" translate="yes" xml:space="preserve">
          <source>for man pages : Odoc_man.Man_generator (class man),</source>
          <target state="translated">man 페이지의 경우 : Odoc_man.Man_generator (클래스 man),</target>
        </trans-unit>
        <trans-unit id="3ecd5c5082f846d0c3ea7bfaaee77f196e9ebc5e" translate="yes" xml:space="preserve">
          <source>for other kinds : Odoc_gen.Base (class generator).</source>
          <target state="translated">다른 종류의 경우 : Odoc_gen.Base (클래스 생성기).</target>
        </trans-unit>
        <trans-unit id="192f048bf417e6a6d6f514420d0bd3eee9c0a580" translate="yes" xml:space="preserve">
          <source>for, &lt;a href=&quot;expr#hevea_manual.kwd32&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd68&quot;&gt;7.7.3&lt;/a&gt;</source>
          <target state="translated">for, &lt;a href=&quot;expr#hevea_manual.kwd32&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd68&quot;&gt;7.7.3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd727fdabede5ec0c811e0017d5a3f4219885c72" translate="yes" xml:space="preserve">
          <source>for&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; ( to ∣ downto ) &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;do&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;done</source>
          <target state="translated">for&lt;a href=&quot;names#value-name&quot;&gt;value-name&lt;/a&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; ( to ∣ downto ) &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;do&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;done</target>
        </trans-unit>
        <trans-unit id="6e69b30d6b1c590a88aa5c625c56998bf14254a4" translate="yes" xml:space="preserve">
          <source>force a new line.</source>
          <target state="translated">새 줄을 강제합니다.</target>
        </trans-unit>
        <trans-unit id="3f673f2a8e0aacb6d0fa4504233f4f284e4a1b4c" translate="yes" xml:space="preserve">
          <source>fork</source>
          <target state="translated">fork</target>
        </trans-unit>
        <trans-unit id="bcc569a02cf33e8b74924ed5a4e4e1da66dbe5e7" translate="yes" xml:space="preserve">
          <source>format &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt; as a section header; the integer following { indicates the sectioning level.</source>
          <target state="translated">포맷 &lt;a href=&quot;#text&quot;&gt;텍스트&lt;/a&gt; 섹션 헤더 등을; {뒤에 오는 정수는 섹션 레벨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="672f98e8704dee74fb33a9148bab315ac642331d" translate="yes" xml:space="preserve">
          <source>formatted input channel</source>
          <target state="translated">형식화 된 입력 채널</target>
        </trans-unit>
        <trans-unit id="39d88b573c35d2ff144e946255bd2194366a771f" translate="yes" xml:space="preserve">
          <source>frame</source>
          <target state="translated">frame</target>
        </trans-unit>
        <trans-unit id="3fc0a723c391767190bc47a90f7e16854954d80b" translate="yes" xml:space="preserve">
          <source>frameframe-number</source>
          <target state="translated">frameframe-number</target>
        </trans-unit>
        <trans-unit id="85023e071af1165c925db5758ebc1e1b71dad0ac" translate="yes" xml:space="preserve">
          <source>fun [&lt;a href=&quot;lex#label&quot;&gt;label&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;] &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt; &amp;hellip; fun [&lt;a href=&quot;lex#label&quot;&gt;label&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;] &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">fun [ &lt;a href=&quot;lex#label&quot;&gt;레이블 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; ] &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1-&lt;/sub&gt; &amp;gt;&amp;hellip; fun [ &lt;a href=&quot;lex#label&quot;&gt;레이블 &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; ] &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;n-&lt;/sub&gt; &amp;gt; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ebcc2e338fd6f883611a4c1124a3332b19505bbd" translate="yes" xml:space="preserve">
          <source>fun { &lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt; }&lt;sup&gt;+&lt;/sup&gt; [ :&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; ] -&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">fun { &lt;a href=&quot;#parameter&quot;&gt;매개 변수&lt;/a&gt; } &lt;sup&gt;+&lt;/sup&gt; [: &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; ]-&amp;gt; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b1a3a30cbc449e60d5eea6ce58e52209e32d4dd2" translate="yes" xml:space="preserve">
          <source>fun {&lt;a href=&quot;expr#parameter&quot;&gt;parameter&lt;/a&gt;}&lt;sup&gt;+&lt;/sup&gt;-&amp;gt;&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;</source>
          <target state="translated">fun {&lt;a href=&quot;expr#parameter&quot;&gt;parameter&lt;/a&gt;}&lt;sup&gt;+&lt;/sup&gt;-&amp;gt;&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4cf7851db220b0ea5a996eba1089d7505fdbefd5" translate="yes" xml:space="preserve">
          <source>fun, &lt;a href=&quot;expr#hevea_manual.kwd26&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd46&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd61&quot;&gt;7.7.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd120&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;locallyabstract#hevea_manual.kwd211&quot;&gt;8.4&lt;/a&gt;</source>
          <target state="translated">재미, &lt;a href=&quot;expr#hevea_manual.kwd26&quot;&gt;7.7&lt;/a&gt; , &lt;a href=&quot;expr#hevea_manual.kwd46&quot;&gt;7.7.1&lt;/a&gt; , &lt;a href=&quot;expr#hevea_manual.kwd61&quot;&gt;7.7.2&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd120&quot;&gt;7.9.2&lt;/a&gt; , &lt;a href=&quot;locallyabstract#hevea_manual.kwd211&quot;&gt;8.4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="65b9b437a514a3e5ea1ea5491d21b80bdbae4bad" translate="yes" xml:space="preserve">
          <source>fun&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; (&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">fun&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; (&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9269c0d955dc0d421de5199eac99141b1a96687" translate="yes" xml:space="preserve">
          <source>fun&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">재미있는 &lt;a href=&quot;#parameter&quot;&gt;매개 변수 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#parameter&quot;&gt;매개 변수 &lt;/a&gt;&lt;sub&gt;n-&lt;/sub&gt; &amp;gt; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0239578aea3e4d87835c83b4662dc338046b96ad" translate="yes" xml:space="preserve">
          <source>fun&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">재미있는 &lt;a href=&quot;#parameter&quot;&gt;매개 변수 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#parameter&quot;&gt;매개 변수 &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; : &lt;a href=&quot;types#typexpr&quot;&gt;typexpr-&lt;/a&gt; &amp;gt; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd0c99260cc10a58b6dc0630ee3174d14d0aa1d9" translate="yes" xml:space="preserve">
          <source>fun&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt; &amp;hellip; fun&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;-&amp;gt; (&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; )</source>
          <target state="translated">재미있는 &lt;a href=&quot;#parameter&quot;&gt;매개 변수 &lt;/a&gt;&lt;sub&gt;1-&lt;/sub&gt; &amp;gt;&amp;hellip; 재미있는 &lt;a href=&quot;#parameter&quot;&gt;매개 변수 &lt;/a&gt;&lt;sub&gt;n-&lt;/sub&gt; &amp;gt; ( &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; : &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="840d7d5ed51ee8834a3ec7619f2285969a89a001" translate="yes" xml:space="preserve">
          <source>fun&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt; &amp;hellip; fun&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">재미있는 &lt;a href=&quot;#parameter&quot;&gt;매개 변수 &lt;/a&gt;&lt;sub&gt;1-&lt;/sub&gt; &amp;gt;&amp;hellip; 재미있는 &lt;a href=&quot;#parameter&quot;&gt;매개 변수 &lt;/a&gt;&lt;sub&gt;n-&lt;/sub&gt; &amp;gt; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4733b6d32d7233706102a87ab6db3fc6a85167c9" translate="yes" xml:space="preserve">
          <source>fun&lt;a href=&quot;expr#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;expr#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;</source>
          <target state="translated">재미있는 &lt;a href=&quot;expr#parameter&quot;&gt;매개 변수 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;expr#parameter&quot;&gt;매개 변수 &lt;/a&gt;&lt;sub&gt;n-&lt;/sub&gt; &amp;gt; &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8114885059afc292abf363c94d278f6d64ac92aa" translate="yes" xml:space="preserve">
          <source>fun&lt;a href=&quot;expr#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt; &amp;hellip; fun&lt;a href=&quot;expr#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">재미있는 &lt;a href=&quot;expr#parameter&quot;&gt;매개 변수 &lt;/a&gt;&lt;sub&gt;1-&lt;/sub&gt; &amp;gt;&amp;hellip; 재미있는 &lt;a href=&quot;expr#parameter&quot;&gt;매개 변수 &lt;/a&gt;&lt;sub&gt;n-&lt;/sub&gt; &amp;gt; &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a9314ac9c1204837ab3797003476b3ca7266314" translate="yes" xml:space="preserve">
          <source>fun?&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt;:&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;-&amp;gt;let&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;=match&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;withSome&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;-&amp;gt;&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;|None-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">fun?&lt;a href=&quot;lex#label-name&quot;&gt;lab&lt;/a&gt;:&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;-&amp;gt;let&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;=match&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;withSome&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;-&amp;gt;&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;|None-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c218e39efa2e1aae69f39d2054528369ce1e1f46" translate="yes" xml:space="preserve">
          <source>function</source>
          <target state="translated">function</target>
        </trans-unit>
        <trans-unit id="8659e2b8073fc29425b0677a5b6c19e2e76348c8" translate="yes" xml:space="preserve">
          <source>function application, constructor application, tag application, assert, lazy</source>
          <target state="translated">함수 애플리케이션, 생성자 애플리케이션, 태그 애플리케이션, assert, lazy</target>
        </trans-unit>
        <trans-unit id="36c4cd5b5726bc3667eac8f4ac101fe25a1ae130" translate="yes" xml:space="preserve">
          <source>function calls : a count point is set at the beginning of each function body</source>
          <target state="translated">함수 호출 : 각 함수 본문의 시작 부분에 카운트 포인트가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2b7a895abdf5399146a6baaa6269ab56bdbbb4a8" translate="yes" xml:space="preserve">
          <source>function, &lt;a href=&quot;expr#hevea_manual.kwd25&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd47&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd60&quot;&gt;7.7.2&lt;/a&gt;</source>
          <target state="translated">함수, &lt;a href=&quot;expr#hevea_manual.kwd25&quot;&gt;7.7&lt;/a&gt; , &lt;a href=&quot;expr#hevea_manual.kwd47&quot;&gt;7.7.1&lt;/a&gt; , &lt;a href=&quot;expr#hevea_manual.kwd60&quot;&gt;7.7.2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fbcef6bcb3d11e46effa16ee8ef49f89e47ce86e" translate="yes" xml:space="preserve">
          <source>function&lt;a href=&quot;#pattern-matching&quot;&gt;pattern-matching&lt;/a&gt;</source>
          <target state="translated">function&lt;a href=&quot;#pattern-matching&quot;&gt;pattern-matching&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3006f44001837a909b4840c5a7879a322570c712" translate="yes" xml:space="preserve">
          <source>function&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;-&amp;gt; &amp;hellip; function&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">기능 &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1-&lt;/sub&gt; &amp;gt;&amp;hellip; 기능 &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;n-&lt;/sub&gt; &amp;gt; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5010927b2d6f54abfba53f9c6a4ff170122c1126" translate="yes" xml:space="preserve">
          <source>functions for raising exceptions (see section &lt;a href=&quot;#ss%3Ac-exceptions&quot;&gt;20.4.5&lt;/a&gt;)</source>
          <target state="translated">예외를 발생시키는 함수 (섹션 &lt;a href=&quot;#ss%3Ac-exceptions&quot;&gt;20.4.5&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="a849b6b86a86f4a93285c056a690e4c3987619b8" translate="yes" xml:space="preserve">
          <source>functor()-&amp;gt;&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;</source>
          <target state="translated">functor()-&amp;gt;&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2844c175a443bbc8f0547152ba8237ba4ecece4e" translate="yes" xml:space="preserve">
          <source>functor()-&amp;gt;&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;</source>
          <target state="translated">functor()-&amp;gt;&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e03f2859207c0e9433b4a2ecae4605a9e1b95b9" translate="yes" xml:space="preserve">
          <source>functor(&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;</source>
          <target state="translated">functor(&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a07f902d52bb9068d86a6477af50805473264aa" translate="yes" xml:space="preserve">
          <source>functor(&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;</source>
          <target state="translated">functor(&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;)-&amp;gt;&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="68ab0059d66e906941e8678e513dd3f767afc42e" translate="yes" xml:space="preserve">
          <source>functor, &lt;a href=&quot;modtypes#hevea_manual.kwd152&quot;&gt;7.10&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd177&quot;&gt;7.10.3&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd181&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd205&quot;&gt;7.11.3&lt;/a&gt;</source>
          <target state="translated">펑터, &lt;a href=&quot;modtypes#hevea_manual.kwd152&quot;&gt;7.10&lt;/a&gt; , &lt;a href=&quot;modtypes#hevea_manual.kwd177&quot;&gt;7.10.3&lt;/a&gt; , &lt;a href=&quot;modules#hevea_manual.kwd181&quot;&gt;7.11&lt;/a&gt; , &lt;a href=&quot;modules#hevea_manual.kwd205&quot;&gt;7.11.3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="034836e093abd26b76f58a37505acd3b47fde33b" translate="yes" xml:space="preserve">
          <source>generates compiled files P.cmx, P.o and P.cmi describing a compilation unit having three sub-modules A, B and C, corresponding to the contents of the object files A.cmx, B.cmx and C.cmx. These contents can be referenced as P.A, P.B and P.C in the remainder of the program.</source>
          <target state="translated">객체 파일 A.cmx, B.cmx 및 C.cmx의 내용에 해당하는 세 개의 하위 모듈 A, B 및 C가있는 컴파일 단위를 설명하는 컴파일 된 파일 P.cmx, Po 및 P.cmi를 생성합니다. 이러한 내용은 프로그램의 나머지 부분에서 PA, PB 및 PC로 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2d52daff09686e1418f2d39aa82517fedd484e4" translate="yes" xml:space="preserve">
          <source>generates compiled files p.cmo and p.cmi describing a compilation unit having three sub-modules A, B and C, corresponding to the contents of the object files a.cmo, b.cmo and c.cmo. These contents can be referenced as P.A, P.B and P.C in the remainder of the program.</source>
          <target state="translated">객체 파일 a.cmo, b.cmo 및 c.cmo의 내용에 해당하는 세 개의 하위 모듈 A, B 및 C를 갖는 컴파일 단위를 설명하는 컴파일 된 파일 p.cmo 및 p.cmi를 생성합니다. 이러한 내용은 프로그램의 나머지 부분에서 PA, PB 및 PC로 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1bf2f768c998ce78f3881b1180914edc1e4be20" translate="yes" xml:space="preserve">
          <source>generation of documentation, through a documentation generator, which is an object of class Odoc_args.class_generator.</source>
          <target state="translated">Odoc_args.class_generator 클래스의 객체 인 문서 생성기를 통한 문서 생성.</target>
        </trans-unit>
        <trans-unit id="772355cea5ae74c202b3d91b1248e88961bb5c5f" translate="yes" xml:space="preserve">
          <source>getgrnam, getgrgid</source>
          <target state="translated">getgrnam, getgrgid</target>
        </trans-unit>
        <trans-unit id="3e32675c123cd727f0309c3cb6c71464bb9f334c" translate="yes" xml:space="preserve">
          <source>getgroups</source>
          <target state="translated">getgroups</target>
        </trans-unit>
        <trans-unit id="e55f588522f530bcde02486503fd5ed646e768ba" translate="yes" xml:space="preserve">
          <source>getitimer, setitimer</source>
          <target state="translated">getitimer, setitimer</target>
        </trans-unit>
        <trans-unit id="760896bcddb7ce1b15ca782f91ef889393abaa62" translate="yes" xml:space="preserve">
          <source>getppid</source>
          <target state="translated">getppid</target>
        </trans-unit>
        <trans-unit id="334ebc7bbe07b5c7bb6cdde510912ea2d8e86671" translate="yes" xml:space="preserve">
          <source>getpwnam, getpwuid</source>
          <target state="translated">getpwnam, getpwuid</target>
        </trans-unit>
        <trans-unit id="d83a311450d17a3faaf0c6a09453bd5d7c4351cd" translate="yes" xml:space="preserve">
          <source>getuid, geteuid, getgid, getegid</source>
          <target state="translated">getuid, geteuid, getgid, getegid</target>
        </trans-unit>
        <trans-unit id="6f4731a0517aaa711cf010c5a678f6ef36ae7459" translate="yes" xml:space="preserve">
          <source>goto 0</source>
          <target state="translated">0으로 이동</target>
        </trans-unit>
        <trans-unit id="2279f19b3d2652baf02cc127be0db400bd45a5cd" translate="yes" xml:space="preserve">
          <source>goto time</source>
          <target state="translated">시간 이동</target>
        </trans-unit>
        <trans-unit id="27d5482eebd075de44389774fce28c69f45c8a75" translate="yes" xml:space="preserve">
          <source>h</source>
          <target state="translated">h</target>
        </trans-unit>
        <trans-unit id="07db9dbabeac878d804109af5f1e65ed057d71af" translate="yes" xml:space="preserve">
          <source>h::t</source>
          <target state="translated">h::t</target>
        </trans-unit>
        <trans-unit id="b0adddb4abfab0acb067c3a02f47aa9f4c79e9ec" translate="yes" xml:space="preserve">
          <source>has arity 1, and the input2 C function receives one argument (which is a quadruple of OCaml values).</source>
          <target state="translated">인수가 1이고 input2 C 함수는 하나의 인수 (OCaml 값의 4 배)를받습니다.</target>
        </trans-unit>
        <trans-unit id="e0e61164ea46b16117879c920d874090355b1361" translate="yes" xml:space="preserve">
          <source>has type</source>
          <target state="translated">유형이 있습니다</target>
        </trans-unit>
        <trans-unit id="74a776c7d9b6a35b3352f96d1f8480eb2c595160" translate="yes" xml:space="preserve">
          <source>hashing (module &lt;code&gt;Hash&lt;/code&gt;);</source>
          <target state="translated">해싱 (모듈 &lt;code&gt;Hash&lt;/code&gt; );</target>
        </trans-unit>
        <trans-unit id="92005ecf3788faea8346a7919fba0232188561ab" translate="yes" xml:space="preserve">
          <source>help</source>
          <target state="translated">help</target>
        </trans-unit>
        <trans-unit id="e4c1caea51cdee6abdfd423fa8b032afd9287b64" translate="yes" xml:space="preserve">
          <source>help command</source>
          <target state="translated">도움말 명령</target>
        </trans-unit>
        <trans-unit id="c7474a41cb68769c8ffe8911c26576fcd5fc9a56" translate="yes" xml:space="preserve">
          <source>help info topic</source>
          <target state="translated">도움말 정보 주제</target>
        </trans-unit>
        <trans-unit id="b47fa7a5cd01887bd5c7edbb8d4489b33b798d72" translate="yes" xml:space="preserve">
          <source>help set variable, help show variable</source>
          <target state="translated">변수 설정 도움말, 변수 표시 도움말</target>
        </trans-unit>
        <trans-unit id="9b369c7d8443ed75e8ee8664670a6b742e802dc9" translate="yes" xml:space="preserve">
          <source>hexadecimal (radix 16)</source>
          <target state="translated">16 진수 (기수 16)</target>
        </trans-unit>
        <trans-unit id="1216290c328643cb59675cb9c9de402377586669" translate="yes" xml:space="preserve">
          <source>horizontal tabulation (TAB)</source>
          <target state="translated">수평 표 (TAB)</target>
        </trans-unit>
        <trans-unit id="042dc4512fa3d391c5170cf3aa61e6a638f84342" translate="yes" xml:space="preserve">
          <source>i</source>
          <target state="translated">i</target>
        </trans-unit>
        <trans-unit id="99600d7006d6b0a21d7833d055370ceeed1f8dad" translate="yes" xml:space="preserve">
          <source>i-th dimension</source>
          <target state="translated">i- 차원</target>
        </trans-unit>
        <trans-unit id="0efee61c10bc322d0b636ba3dd5c3a2656badd1f" translate="yes" xml:space="preserve">
          <source>ident</source>
          <target state="translated">ident</target>
        </trans-unit>
        <trans-unit id="958f57f57d72a30f329ee5538f21b0257a49a46e" translate="yes" xml:space="preserve">
          <source>if</source>
          <target state="translated">if</target>
        </trans-unit>
        <trans-unit id="62043fa493a7596b85a66a9829c21feeca0c4fdd" translate="yes" xml:space="preserve">
          <source>if &amp;hellip;then &amp;hellip;else &amp;hellip; : count points are set in both then branch and else branch</source>
          <target state="translated">if&amp;hellip; then&amp;hellip; else&amp;hellip; : 카운트 포인트가 분기 및 else 분기 모두에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="72e87305e9cd23ad8be0325131e843361ec7f085" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;cmp&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; &amp;gt;= 0 and &lt;code&gt;cmp&amp;nbsp;y&amp;nbsp;z&lt;/code&gt; &amp;gt;= 0 then &lt;code&gt;cmp&amp;nbsp;x&amp;nbsp;z&lt;/code&gt; &amp;gt;= 0</source>
          <target state="translated">만약 &lt;code&gt;cmp&amp;nbsp;x&amp;nbsp;y&lt;/code&gt; &amp;gt; = 0 &lt;code&gt;cmp&amp;nbsp;y&amp;nbsp;z&lt;/code&gt; &amp;gt; = 0 다음 &lt;code&gt;cmp&amp;nbsp;x&amp;nbsp;z&lt;/code&gt; &amp;gt; = 0</target>
        </trans-unit>
        <trans-unit id="75a1e6217624587a482735c03d4f13ef4800b403" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;f&amp;nbsp;k&amp;nbsp;v&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; then &lt;code&gt;k&lt;/code&gt; is not in the result,</source>
          <target state="translated">만약 &lt;code&gt;f&amp;nbsp;k&amp;nbsp;v&lt;/code&gt; 없는 &lt;code&gt;None&lt;/code&gt; 다음 &lt;code&gt;k&lt;/code&gt; 는 상기 결과에 있지</target>
        </trans-unit>
        <trans-unit id="2a7962703df78171c0f6d9ead79f64d4c7e8be50" translate="yes" xml:space="preserve">
          <source>if &lt;code&gt;f&amp;nbsp;k&amp;nbsp;v&lt;/code&gt; is &lt;code&gt;Some&amp;nbsp;v'&lt;/code&gt; then the binding &lt;code&gt;(k,&amp;nbsp;v')&lt;/code&gt; is in the output map.</source>
          <target state="translated">만약 &lt;code&gt;f&amp;nbsp;k&amp;nbsp;v&lt;/code&gt; 있다 &lt;code&gt;Some&amp;nbsp;v'&lt;/code&gt; 다음 바인딩 &lt;code&gt;(k,&amp;nbsp;v')&lt;/code&gt; 의 출력 맵이다.</target>
        </trans-unit>
        <trans-unit id="d7691fd964f62c6c29778c4b5bb61b07497e4d81" translate="yes" xml:space="preserve">
          <source>if we define the receiver &lt;code&gt;f&lt;/code&gt; as &lt;code&gt;let&amp;nbsp;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;x&amp;nbsp;+&amp;nbsp;1&lt;/code&gt;,</source>
          <target state="translated">수신자 &lt;code&gt;f&lt;/code&gt; 를 &lt;code&gt;let&amp;nbsp;f&amp;nbsp;x&amp;nbsp;=&amp;nbsp;x&amp;nbsp;+&amp;nbsp;1&lt;/code&gt; 로 정의하면 ,</target>
        </trans-unit>
        <trans-unit id="9d331b7cd9454df4e8c8b3e1d683f06da8756571" translate="yes" xml:space="preserve">
          <source>if we use &lt;code&gt;stdin&lt;/code&gt; as the source of characters (&lt;a href=&quot;scanf.scanning#VALstdin&quot;&gt;&lt;code&gt;Scanf.Scanning.stdin&lt;/code&gt;&lt;/a&gt; is the predefined formatted input channel that reads from standard input),</source>
          <target state="translated">&lt;code&gt;stdin&lt;/code&gt; 을 문자 소스로 사용하는 경우 ( &lt;a href=&quot;scanf.scanning#VALstdin&quot;&gt; &lt;code&gt;Scanf.Scanning.stdin&lt;/code&gt; &lt;/a&gt; 은 표준 입력에서 읽는 미리 정의 된 형식의 입력 채널입니다),</target>
        </trans-unit>
        <trans-unit id="f55fb127a497d1332b99a942053ffd4ac476c7f2" translate="yes" xml:space="preserve">
          <source>if your function is a primitive with more than 5 arguments for use with the byte-code runtime, its arguments are not values and must not be declared (they have types value * and int).</source>
          <target state="translated">함수가 바이트 코드 런타임과 함께 사용하기위한 5 개 이상의 인수가있는 기본 요소 인 경우 해당 인수는 값이 아니므로 선언되어서는 안됩니다 (값 * 및 int 유형이 있음).</target>
        </trans-unit>
        <trans-unit id="296e7f1f31d4668a2b2bb325f806d14637720d38" translate="yes" xml:space="preserve">
          <source>if, &lt;a href=&quot;expr#hevea_manual.kwd35&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd45&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd64&quot;&gt;7.7.3&lt;/a&gt;</source>
          <target state="translated">if, &lt;a href=&quot;expr#hevea_manual.kwd35&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd45&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd64&quot;&gt;7.7.3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="171d50ad38cb8f575e802fca0b686221a4433fb9" translate="yes" xml:space="preserve">
          <source>if&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;then&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;elsefalse.</source>
          <target state="translated">if&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;then&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;elsefalse.</target>
        </trans-unit>
        <trans-unit id="5e235627b05b242764981acad185ad5869323de1" translate="yes" xml:space="preserve">
          <source>if&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;thentrueelse&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</source>
          <target state="translated">if&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;thentrueelse&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;2&lt;/sub&gt;.</target>
        </trans-unit>
        <trans-unit id="d2251fa912bc54f4d77afad5862d8faf8fa2e9e7" translate="yes" xml:space="preserve">
          <source>if&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;then&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; [ else&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; ]</source>
          <target state="translated">만약 &lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt; 다음 &lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt; [다른 &lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="bc04e85d3eaff1e4754370552b234e7099970281" translate="yes" xml:space="preserve">
          <source>immutable character strings</source>
          <target state="translated">불변 문자열</target>
        </trans-unit>
        <trans-unit id="cde41be3ab9cf0b6ab971fbd9b886d94b0b4b958" translate="yes" xml:space="preserve">
          <source>implemented (since 3.02)</source>
          <target state="translated">구현 됨 (3.02 이후)</target>
        </trans-unit>
        <trans-unit id="3030d0f8c1da9ff83ec620251f17a22db9a8f430" translate="yes" xml:space="preserve">
          <source>implemented (since 4.03.0)</source>
          <target state="translated">구현 됨 (4.03.0 이후)</target>
        </trans-unit>
        <trans-unit id="c40c8c34a8bcd9afa7703ca4c2956eaa74a4dfa5" translate="yes" xml:space="preserve">
          <source>in a let expression, one may instead write</source>
          <target state="translated">let 표현식에서 대신 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1be4be48925b21377455741cb700dde1c9a583d9" translate="yes" xml:space="preserve">
          <source>in addition to the relevant digits, &lt;code&gt;'_'&lt;/code&gt; characters may appear inside numbers (this is reminiscent to the usual OCaml lexical conventions). If stricter scanning is desired, use the range conversion facility instead of the number conversions.</source>
          <target state="translated">관련 숫자 외에도 &lt;code&gt;'_'&lt;/code&gt; 문자가 숫자 안에 나타날 수 있습니다 (이것은 일반적인 OCaml 어휘 규칙을 연상시킵니다). 더 엄격한 스캔이 필요한 경우 숫자 변환 대신 범위 변환 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="36883d27fefa117c39f72ce3daaa5fc2f419b53b" translate="yes" xml:space="preserve">
          <source>in, see let</source>
          <target state="translated">에서, 보자</target>
        </trans-unit>
        <trans-unit id="fcdd45c309dcba1d9d4b79f586b3a50297b8ee1c" translate="yes" xml:space="preserve">
          <source>include, &lt;a href=&quot;modtypes#hevea_manual.kwd162&quot;&gt;7.10&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd176&quot;&gt;7.10.2&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd190&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd204&quot;&gt;7.11.2&lt;/a&gt;, &lt;a href=&quot;moduletypeof#hevea_manual.kwd219&quot;&gt;8.6&lt;/a&gt;</source>
          <target state="translated">포함, &lt;a href=&quot;modtypes#hevea_manual.kwd162&quot;&gt;7.10&lt;/a&gt; , &lt;a href=&quot;modtypes#hevea_manual.kwd176&quot;&gt;7.10.2&lt;/a&gt; , &lt;a href=&quot;modules#hevea_manual.kwd190&quot;&gt;7.11&lt;/a&gt; , &lt;a href=&quot;modules#hevea_manual.kwd204&quot;&gt;7.11.2&lt;/a&gt; , &lt;a href=&quot;moduletypeof#hevea_manual.kwd219&quot;&gt;8.6&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79d5dde4ba62bff53b44acb3b42aff51ef7c5d8e" translate="yes" xml:space="preserve">
          <source>include&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;</source>
          <target state="translated">include&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f5c5afca60ad64d401873a558c35fd6bff585f7" translate="yes" xml:space="preserve">
          <source>include&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;</source>
          <target state="translated">include&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8e3b5bde77f3da26ea678f77a329bb416842c919" translate="yes" xml:space="preserve">
          <source>include&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; }</source>
          <target state="translated">포함 &lt;a href=&quot;modtypes#module-type&quot;&gt;모듈 유형&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;항목 속성&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="f68cbdcde9321debc33dec929526538b84347f10" translate="yes" xml:space="preserve">
          <source>include&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; }</source>
          <target state="translated">포함 &lt;a href=&quot;modules#module-expr&quot;&gt;모듈 EXPR&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;아이템 속성을&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="775ff372a1335c3b0c06bc8b0c85a6b6498ebe97" translate="yes" xml:space="preserve">
          <source>indicates positions relative to the beginning of the file</source>
          <target state="translated">파일의 시작을 기준으로 한 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b27f2d3b01cfed33f2bec50a5a60c1cdac631f09" translate="yes" xml:space="preserve">
          <source>indicates positions relative to the current position</source>
          <target state="translated">현재 위치를 기준으로 한 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="efefe62ae6f51dcd0084f0f6719b3ae855eee713" translate="yes" xml:space="preserve">
          <source>indicates positions relative to the end of the file</source>
          <target state="translated">파일 끝을 기준으로 한 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ba84477b5b149f0c5490450bb80212dfa7bd5fd6" translate="yes" xml:space="preserve">
          <source>infix-op</source>
          <target state="translated">infix-op</target>
        </trans-unit>
        <trans-unit id="58d4778f3bf63e407d21101262292af7d3db6d3f" translate="yes" xml:space="preserve">
          <source>infix-symbol</source>
          <target state="translated">infix-symbol</target>
        </trans-unit>
        <trans-unit id="a01cf621a5b126ce5a4f57cd0d75a3b74e2b9743" translate="yes" xml:space="preserve">
          <source>info breakpoints</source>
          <target state="translated">정보 중단 점</target>
        </trans-unit>
        <trans-unit id="cb662cc5b49179ba761a0ea47d1981ef3cfdc12e" translate="yes" xml:space="preserve">
          <source>info checkpoints</source>
          <target state="translated">정보 체크 포인트</target>
        </trans-unit>
        <trans-unit id="c1bd61066b3bdb2c60ecfab85e68f0363c0d3272" translate="yes" xml:space="preserve">
          <source>info events [module]</source>
          <target state="translated">정보 이벤트 [모듈]</target>
        </trans-unit>
        <trans-unit id="8baf2d9793c89398da706061b12c589ae0a3f294" translate="yes" xml:space="preserve">
          <source>info subject</source>
          <target state="translated">정보 주제</target>
        </trans-unit>
        <trans-unit id="64d6a7dde203dfd472b7a4e7f5e5a584e6339416" translate="yes" xml:space="preserve">
          <source>inherit!&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; [as&lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt;]</source>
          <target state="translated">상속! &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; [ &lt;a href=&quot;lex#lowercase-ident&quot;&gt;소문자 -ident로&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="c13e5a8b4fe5a08b064bc16d80a3977d513efdba" translate="yes" xml:space="preserve">
          <source>inherit, &lt;a href=&quot;classes#hevea_manual.kwd103&quot;&gt;7.9.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd110&quot;&gt;7.9.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd123&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd131&quot;&gt;7.9.2&lt;/a&gt;</source>
          <target state="translated">상속, &lt;a href=&quot;classes#hevea_manual.kwd103&quot;&gt;7.9.1&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd110&quot;&gt;7.9.1&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd123&quot;&gt;7.9.2&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd131&quot;&gt;7.9.2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35815a10f1288205de110bb61161fa1264dbb6b2" translate="yes" xml:space="preserve">
          <source>inherit&lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt;</source>
          <target state="translated">inherit&lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d48c1446f94ecec3497c6872375f55ad7ec6ca55" translate="yes" xml:space="preserve">
          <source>inherit&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; [as&lt;a href=&quot;lex#lowercase-ident&quot;&gt;lowercase-ident&lt;/a&gt;]</source>
          <target state="translated">&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt; [ &lt;a href=&quot;lex#lowercase-ident&quot;&gt;소문자 -ident로&lt;/a&gt; ] 상속</target>
        </trans-unit>
        <trans-unit id="036d153e88ab680b671bdbedf7e1444f04c908b1" translate="yes" xml:space="preserve">
          <source>init:</source>
          <target state="translated">init:</target>
        </trans-unit>
        <trans-unit id="e86dc2769b8ae8fee363c2cb582840598378992e" translate="yes" xml:space="preserve">
          <source>initializer, &lt;a href=&quot;classes#hevea_manual.kwd130&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd142&quot;&gt;7.9.2&lt;/a&gt;</source>
          <target state="translated">이니셜 라이저, &lt;a href=&quot;classes#hevea_manual.kwd130&quot;&gt;7.9.2&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd142&quot;&gt;7.9.2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aaaa3b243e4649228bff320dc5c3acc9fdfa09ba" translate="yes" xml:space="preserve">
          <source>initializer&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">initializer&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cf798a52d2dc37e7dfb868809e58d253376af19a" translate="yes" xml:space="preserve">
          <source>insert a cross-reference to an element (see section &lt;a href=&quot;#sss%3Aocamldoc-crossref&quot;&gt;16.2.4.2&lt;/a&gt; for the syntax of cross-references).</source>
          <target state="translated">요소에 대한 상호 참조를 삽입합니다 (상호 참조 의 구문에 대해서는 섹션 &lt;a href=&quot;#sss%3Aocamldoc-crossref&quot;&gt;16.2.4.2&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="3e5ec8da0746562b7551764d2784b5dbed8e42b2" translate="yes" xml:space="preserve">
          <source>insert a table of links to the various indexes (types, values, modules, ...). Used in HTML only.</source>
          <target state="translated">다양한 인덱스 (유형, 값, 모듈 등)에 대한 링크 테이블을 삽입합니다. HTML에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6eab95a58d831871b14532f1578fb7bcc8746581" translate="yes" xml:space="preserve">
          <source>insert an index table for the given module names. Used in HTML only.</source>
          <target state="translated">주어진 모듈 이름에 대한 색인 테이블을 삽입하십시오. HTML에서만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="48d3dc40acbee4c1cf049070f6e8e150169f78c5" translate="yes" xml:space="preserve">
          <source>inside a recursive module definition, M&lt;sub&gt;0&lt;/sub&gt; should not be one of the recursively defined modules.</source>
          <target state="translated">재귀 모듈 정의 내에서 M &lt;sub&gt;0&lt;/sub&gt; 은 재귀 적으로 정의 된 모듈 중 하나가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="8334416331188dc0834e0db7b1963e39705cb291" translate="yes" xml:space="preserve">
          <source>inside the body of a functor, M&lt;sub&gt;0&lt;/sub&gt; should not be one of the functor parameters;</source>
          <target state="translated">펑터 본체 내부에서 M &lt;sub&gt;0&lt;/sub&gt; 은 펑터 매개 변수 중 하나가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="016beb33a553ebe6cbafd2cf0d337d5272037130" translate="yes" xml:space="preserve">
          <source>inst-var-name</source>
          <target state="translated">inst-var-name</target>
        </trans-unit>
        <trans-unit id="87473fe55615f431e83a208ff1e59784e06d318b" translate="yes" xml:space="preserve">
          <source>install_printer printer-name</source>
          <target state="translated">install_printer 프린터 이름</target>
        </trans-unit>
        <trans-unit id="b6fb9f5c27ade72d14f775d79238f3d3209715b8" translate="yes" xml:space="preserve">
          <source>instance variable names (&lt;a href=&quot;#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt;),</source>
          <target state="translated">인스턴스 변수 이름 ( &lt;a href=&quot;#inst-var-name&quot;&gt;inst-var-name&lt;/a&gt; ),</target>
        </trans-unit>
        <trans-unit id="cb82821f5443620916128c66c024a61d87b0565d" translate="yes" xml:space="preserve">
          <source>instead of</source>
          <target state="translated">대신에</target>
        </trans-unit>
        <trans-unit id="46f8ab7c0cff9df7cd124852e26022a6bf89e315" translate="yes" xml:space="preserve">
          <source>int</source>
          <target state="translated">int</target>
        </trans-unit>
        <trans-unit id="0ea590de0e2e1b0df5fabb92365ebfab2f515ee8" translate="yes" xml:space="preserve">
          <source>int (*compare)(value v1, value v2)</source>
          <target state="translated">int (* compare) (v1 값, v2 값)</target>
        </trans-unit>
        <trans-unit id="68d3df1568019e0870189f8da1f503280238e07e" translate="yes" xml:space="preserve">
          <source>int (*compare_ext)(value v1, value v2)</source>
          <target state="translated">int (* compare_ext) (v1 값, v2 값)</target>
        </trans-unit>
        <trans-unit id="320385ec0fbe6caa8b0b25269b069277f1d38959" translate="yes" xml:space="preserve">
          <source>int-literal</source>
          <target state="translated">int-literal</target>
        </trans-unit>
        <trans-unit id="d71739707a7eafbe926fe99f6312cc8634db005d" translate="yes" xml:space="preserve">
          <source>int32</source>
          <target state="translated">int32</target>
        </trans-unit>
        <trans-unit id="2d64d759ca34d47626889c287e575a64014e2611" translate="yes" xml:space="preserve">
          <source>int32-literal</source>
          <target state="translated">int32-literal</target>
        </trans-unit>
        <trans-unit id="8fcdcefeb8f1bbab3f3ff2567ecad9be78779217" translate="yes" xml:space="preserve">
          <source>int32_t</source>
          <target state="translated">int32_t</target>
        </trans-unit>
        <trans-unit id="3cf12f96228a3fa41a25040bdcc6eac3659e7844" translate="yes" xml:space="preserve">
          <source>int64</source>
          <target state="translated">int64</target>
        </trans-unit>
        <trans-unit id="a923917a4e8eff6007e98cf48d9156e9201a6b1b" translate="yes" xml:space="preserve">
          <source>int64-literal</source>
          <target state="translated">int64-literal</target>
        </trans-unit>
        <trans-unit id="f6311168933725d3149f768d180f96c9c216469f" translate="yes" xml:space="preserve">
          <source>int64_t</source>
          <target state="translated">int64_t</target>
        </trans-unit>
        <trans-unit id="01d0f81732577c9d24286ec4b5fb58d07e8ba766" translate="yes" xml:space="preserve">
          <source>integer-literal</source>
          <target state="translated">integer-literal</target>
        </trans-unit>
        <trans-unit id="e3e8ca21b3622c7ea8e9a869ffaa9cd96adcf19a" translate="yes" xml:space="preserve">
          <source>intnat</source>
          <target state="translated">intnat</target>
        </trans-unit>
        <trans-unit id="02122843af179f141e2c4a6904e5c9acf2767015" translate="yes" xml:space="preserve">
          <source>intnat (*hash)(value v)</source>
          <target state="translated">intnat (* hash) (값 v)</target>
        </trans-unit>
        <trans-unit id="cee0a5c5c4c9be20b6830a469d62cd720e8cfc4a" translate="yes" xml:space="preserve">
          <source>is OK, but:</source>
          <target state="translated">괜찮지 만 :</target>
        </trans-unit>
        <trans-unit id="3b574aa1f43197443eefcba8124d2dbfad978f23" translate="yes" xml:space="preserve">
          <source>is a short form for</source>
          <target state="translated">에 대한 약식입니다.</target>
        </trans-unit>
        <trans-unit id="9282601755d874f407044836ef141f061913a4b7" translate="yes" xml:space="preserve">
          <source>is a supertype of</source>
          <target state="translated">의 상위 유형입니다</target>
        </trans-unit>
        <trans-unit id="e2184c194395f85161b07451378b5380bd671a30" translate="yes" xml:space="preserve">
          <source>is automatically expanded into</source>
          <target state="translated">자동으로 확장됩니다</target>
        </trans-unit>
        <trans-unit id="c6084689797742b0df510436433eaf2024a8e9db" translate="yes" xml:space="preserve">
          <source>is displayed as:</source>
          <target state="translated">다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b38e4c6cec12428e5871d2d1ce176a532d59c8d8" translate="yes" xml:space="preserve">
          <source>is easy to remember,</source>
          <target state="translated">기억하기 쉽고</target>
        </trans-unit>
        <trans-unit id="1ec285792f84b2006557cfe7a76ef03e4dffbd46" translate="yes" xml:space="preserve">
          <source>is equivalent to</source>
          <target state="translated">다음과 같다</target>
        </trans-unit>
        <trans-unit id="540dd9c65d0f35bb6866948231ccf0ff06d8f61f" translate="yes" xml:space="preserve">
          <source>is equivalent to defining it as</source>
          <target state="translated">다음과 같이 정의하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="18ab6ac7001b131bc4dc74bd619c612205dff372" translate="yes" xml:space="preserve">
          <source>is equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d88f97f2587677395d348b83f07d9407ee2ea83c" translate="yes" xml:space="preserve">
          <source>is not because x cannot be given any type other than t, which only exists locally. Although the above would be OK if x too was local:</source>
          <target state="translated">x는 로컬에만 존재하는 t 이외의 유형을 지정할 수 없기 때문이 아닙니다. x도 로컬이면 위의 내용은 괜찮을 것입니다.</target>
        </trans-unit>
        <trans-unit id="c40660ad1062790f8a4059a197e03035fd5b1b62" translate="yes" xml:space="preserve">
          <source>is now broken and may suffer from uncaught exceptions.</source>
          <target state="translated">이제 손상되었으며 잡히지 않은 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16b08ccf539cb48fc49109709c82df2f55d74672" translate="yes" xml:space="preserve">
          <source>is the set of halves of the even elements of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 의 짝수 요소의 반쪽 집합입니다 .</target>
        </trans-unit>
        <trans-unit id="0ecc5e62f71fc1008ed4659593b5f4900693d3b6" translate="yes" xml:space="preserve">
          <source>it can also handle values of type x:</source>
          <target state="translated">또한 x 유형의 값을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="b2d89f7a06da14551b799622c9fa3b84961b60c5" translate="yes" xml:space="preserve">
          <source>it is a root value</source>
          <target state="translated">그것은 루트 값입니다</target>
        </trans-unit>
        <trans-unit id="c49bc6901670ed54a5b0fcf425e311786a688356" translate="yes" xml:space="preserve">
          <source>it is reachable from alive value by usual pointers</source>
          <target state="translated">일반적인 포인터로 살아있는 값에서 도달 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c7a4ba74bb307d677a2b4269826d5907405a002" translate="yes" xml:space="preserve">
          <source>it is the data of an alive ephemeron with all its full keys alive</source>
          <target state="translated">모든 키가 살아있는 살아있는 천체력의 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="1d41b1d151ee2007d39bf9d3c182989341851535" translate="yes" xml:space="preserve">
          <source>it should be of the form M&lt;sub&gt;0&lt;/sub&gt;.M&lt;sub&gt;1&lt;/sub&gt;...M&lt;sub&gt;n&lt;/sub&gt; (&lt;em&gt;i.e.&lt;/em&gt; without functor applications);</source>
          <target state="translated">이 형태 M이어야 &lt;sub&gt;0&lt;/sub&gt; 하는 .m &lt;sub&gt;1&lt;/sub&gt; ... M &lt;sub&gt;N&lt;/sub&gt; ( &lt;em&gt;즉&lt;/em&gt; 펑 어플리케이션 없음);</target>
        </trans-unit>
        <trans-unit id="f0ae9bb4b5a17414771d9e01942cf521816e0f1e" translate="yes" xml:space="preserve">
          <source>it would be observed that inlining of f would remove:</source>
          <target state="translated">f의 인라인은 다음을 제거하는 것으로 관찰됩니다.</target>
        </trans-unit>
        <trans-unit id="cca7dd474781a6c615acad892d75948bf8064f9c" translate="yes" xml:space="preserve">
          <source>item-attribute</source>
          <target state="translated">item-attribute</target>
        </trans-unit>
        <trans-unit id="e7b0f2a22247c128455d40504270be579f19f9d2" translate="yes" xml:space="preserve">
          <source>item-extension</source>
          <target state="translated">item-extension</target>
        </trans-unit>
        <trans-unit id="c80f5bc166cd6739ba9ba6d94acabc0aa01494da" translate="yes" xml:space="preserve">
          <source>kill</source>
          <target state="translated">kill</target>
        </trans-unit>
        <trans-unit id="44e83b02b2e3da220aaeff4d32148c7927f0e049" translate="yes" xml:space="preserve">
          <source>kind of array elements</source>
          <target state="translated">배열 요소의 종류</target>
        </trans-unit>
        <trans-unit id="07c342be6e560e7f43842e2e21b774e61d85f047" translate="yes" xml:space="preserve">
          <source>l</source>
          <target state="translated">l</target>
        </trans-unit>
        <trans-unit id="64c65374dbab6fe3762748196d9d3a9610e2e5a9" translate="yes" xml:space="preserve">
          <source>label</source>
          <target state="translated">label</target>
        </trans-unit>
        <trans-unit id="ee222cf94d64e861d2744d3254da532946d05acb" translate="yes" xml:space="preserve">
          <source>label-name</source>
          <target state="translated">label-name</target>
        </trans-unit>
        <trans-unit id="8912d04d878e1b8ffa02572c532d88496f969d38" translate="yes" xml:space="preserve">
          <source>labels (&lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt;, defined in section &lt;a href=&quot;lex#sss%3Alabelname&quot;&gt;7.1&lt;/a&gt;),</source>
          <target state="translated">레이블 ( &lt;a href=&quot;lex#sss%3Alabelname&quot;&gt;7.1&lt;/a&gt; 절에 정의 된 &lt;a href=&quot;lex#label-name&quot;&gt;label-name&lt;/a&gt; ),</target>
        </trans-unit>
        <trans-unit id="3d3b60b2c381f8873f294894ef8428319a3b8546" translate="yes" xml:space="preserve">
          <source>land</source>
          <target state="translated">land</target>
        </trans-unit>
        <trans-unit id="28f670b865f6fca2de3f470253d67b5c4465f5a3" translate="yes" xml:space="preserve">
          <source>land, &lt;a href=&quot;names#hevea_manual.kwd1&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd52&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd71&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd78&quot;&gt;7.7.5&lt;/a&gt;</source>
          <target state="translated">토지, &lt;a href=&quot;names#hevea_manual.kwd1&quot;&gt;7.3&lt;/a&gt; , &lt;a href=&quot;expr#hevea_manual.kwd52&quot;&gt;7.7.1&lt;/a&gt; , &lt;a href=&quot;expr#hevea_manual.kwd71&quot;&gt;7.7.5&lt;/a&gt; , &lt;a href=&quot;expr#hevea_manual.kwd78&quot;&gt;7.7.5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e1320419400c075abf070279ee1a9106491c3e9c" translate="yes" xml:space="preserve">
          <source>last [count]</source>
          <target state="translated">마지막 [개수]</target>
        </trans-unit>
        <trans-unit id="07017c0924f3c0e74472c74b841e4df5732e971d" translate="yes" xml:space="preserve">
          <source>lazy (see section &lt;a href=&quot;#sss%3Apat-lazy&quot;&gt;7.6&lt;/a&gt;)</source>
          <target state="translated">게으른 (섹션 &lt;a href=&quot;#sss%3Apat-lazy&quot;&gt;7.6&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="a89127a029d917cfd54f0e731cd8a9aa6b71457d" translate="yes" xml:space="preserve">
          <source>lazy, &lt;a href=&quot;patterns#hevea_manual.kwd18&quot;&gt;7.6&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd43&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd87&quot;&gt;7.7.8&lt;/a&gt;</source>
          <target state="translated">게으른, &lt;a href=&quot;patterns#hevea_manual.kwd18&quot;&gt;7.6&lt;/a&gt; , &lt;a href=&quot;expr#hevea_manual.kwd43&quot;&gt;7.7&lt;/a&gt; , &lt;a href=&quot;expr#hevea_manual.kwd87&quot;&gt;7.7.8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="55928783428cdda332c1be8b1d7555ae280204b2" translate="yes" xml:space="preserve">
          <source>lazy&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">lazy&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f1ee4c791de79ce5ffb892161d36b89f33683dec" translate="yes" xml:space="preserve">
          <source>lazy&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;</source>
          <target state="translated">lazy&lt;a href=&quot;#pattern&quot;&gt;pattern&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12c0f1fbadc4046b5f2bb9e063b227ef8750d9d6" translate="yes" xml:space="preserve">
          <source>left</source>
          <target state="translated">left</target>
        </trans-unit>
        <trans-unit id="07785b23ac256aee37df3d7fcfaf27d25e175350" translate="yes" xml:space="preserve">
          <source>left align &lt;a href=&quot;#text&quot;&gt;text&lt;/a&gt;.</source>
          <target state="translated">왼쪽 맞춤 &lt;a href=&quot;#text&quot;&gt;텍스트&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c8c7ff93d6fe3f68a4d62ed2606920684027919" translate="yes" xml:space="preserve">
          <source>legacy mode: All path names, environment variables, command line arguments, etc. on the OCaml side are assumed to be encoded using the current 8-bit code page of the system.</source>
          <target state="translated">레거시 모드 : OCaml 측의 모든 경로 이름, 환경 변수, 명령 줄 인수 등은 시스템의 현재 8 비트 코드 페이지를 사용하여 인코딩 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="cc0db465e09e54ce3393bf47c61f2ee7c97c2b5e" translate="yes" xml:space="preserve">
          <source>len:</source>
          <target state="translated">len:</target>
        </trans-unit>
        <trans-unit id="9e98136581c24c2d792e14300fde374673aac562" translate="yes" xml:space="preserve">
          <source>let (&lt;a href=&quot;lex#core-operator-char&quot;&gt;core-operator-char&lt;/a&gt; ∣ &amp;lt;) { &lt;a href=&quot;indexops#dot-operator-char&quot;&gt;dot-operator-char&lt;/a&gt; }</source>
          <target state="translated">let (&lt;a href=&quot;lex#core-operator-char&quot;&gt;core-operator-char&lt;/a&gt; ∣ &amp;lt;) { &lt;a href=&quot;indexops#dot-operator-char&quot;&gt;dot-operator-char&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="df58b9c3f5fe2b95daf952eae7061b425235eb7e" translate="yes" xml:space="preserve">
          <source>let [rec] &lt;a href=&quot;#let-binding&quot;&gt;let-binding&lt;/a&gt; { and&lt;a href=&quot;#let-binding&quot;&gt;let-binding&lt;/a&gt; } in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">let [rec] &lt;a href=&quot;#let-binding&quot;&gt;let-binding&lt;/a&gt; { and&lt;a href=&quot;#let-binding&quot;&gt;let-binding&lt;/a&gt; } in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1e1f39fe94b7fc1579703d33495402522ef33a2e" translate="yes" xml:space="preserve">
          <source>let [rec] &lt;a href=&quot;expr#let-binding&quot;&gt;let-binding&lt;/a&gt; { and&lt;a href=&quot;expr#let-binding&quot;&gt;let-binding&lt;/a&gt; }</source>
          <target state="translated">let [rec] &lt;a href=&quot;expr#let-binding&quot;&gt;let-binding&lt;/a&gt; {및 &lt;a href=&quot;expr#let-binding&quot;&gt;let-binding&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="a8297b94132999eefacc15aae5b2caf50958960c" translate="yes" xml:space="preserve">
          <source>let [rec] &lt;a href=&quot;expr#let-binding&quot;&gt;let-binding&lt;/a&gt; {and&lt;a href=&quot;expr#let-binding&quot;&gt;let-binding&lt;/a&gt;} in&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;</source>
          <target state="translated">let [rec] &lt;a href=&quot;expr#let-binding&quot;&gt;let-binding&lt;/a&gt; {및 &lt;a href=&quot;expr#let-binding&quot;&gt;let-binding&lt;/a&gt; } in &lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0e86db291ae252519fd411c0cbfa4701b2d69ce0" translate="yes" xml:space="preserve">
          <source>let [rec] xname&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;and &amp;hellip; andxname&lt;sub&gt;m&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;</source>
          <target state="translated">let [rec] xname &lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 및&amp;hellip; andxname &lt;sub&gt;m&lt;/sub&gt; = &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt; in &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;0&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="b719aded420f0b5d273d6d8702365a345f524e06" translate="yes" xml:space="preserve">
          <source>let match fun function try</source>
          <target state="translated">재미있는 기능을 시도해 보자</target>
        </trans-unit>
        <trans-unit id="22bf11b6308b221037d374e48cd470b0a5818594" translate="yes" xml:space="preserve">
          <source>let, &lt;a href=&quot;expr#hevea_manual.kwd23&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd50&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd63&quot;&gt;7.7.2&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd88&quot;&gt;7.7.8&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd90&quot;&gt;7.7.8&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd121&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd182&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd193&quot;&gt;7.11.2&lt;/a&gt;</source>
          <target state="translated">let, &lt;a href=&quot;expr#hevea_manual.kwd23&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd50&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd63&quot;&gt;7.7.2&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd88&quot;&gt;7.7.8&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd90&quot;&gt;7.7.8&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd121&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd182&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd193&quot;&gt;7.11.2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c7901b57fcded468298de5ef006d54071437eb06" translate="yes" xml:space="preserve">
          <source>let-binding</source>
          <target state="translated">let-binding</target>
        </trans-unit>
        <trans-unit id="6088f290e02a7e2e06566bc7aab735a0992cd484" translate="yes" xml:space="preserve">
          <source>let-operator</source>
          <target state="translated">let-operator</target>
        </trans-unit>
        <trans-unit id="d9007e043d228a48400a566a231975c63cd6d03b" translate="yes" xml:space="preserve">
          <source>let&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">let &lt;a href=&quot;lex#ident&quot;&gt;ident &lt;/a&gt;&lt;a href=&quot;#parameter&quot;&gt;매개 변수 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#parameter&quot;&gt;매개 변수 &lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt; = &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec6f3793c4518968e3a11110a80f9c48b7d45b5c" translate="yes" xml:space="preserve">
          <source>let&lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt;=fun&lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#parameter&quot;&gt;parameter&lt;/a&gt;&lt;sub&gt;m&lt;/sub&gt;-&amp;gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">let &lt;a href=&quot;lex#ident&quot;&gt;ident&lt;/a&gt; = fun &lt;a href=&quot;#parameter&quot;&gt;매개 변수 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;#parameter&quot;&gt;매개 변수 &lt;/a&gt;&lt;sub&gt;m-&lt;/sub&gt; &amp;gt; &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="045f0f4ea787a29a1bbe9d700d7fe0c4f428ab22" translate="yes" xml:space="preserve">
          <source>let&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.typeexpr=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">let&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; &amp;hellip; &lt;a href=&quot;types#typexpr&quot;&gt;typ&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;.typeexpr=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1932d364e34d9a4c1df147d9280d5b6c2c34f16" translate="yes" xml:space="preserve">
          <source>let&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;and &amp;hellip; and&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">수 있도록 &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;#expr&quot;&gt;expr에 &lt;/a&gt;&lt;sub&gt;한&lt;/sub&gt; 하고 ... 그리고 &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; = &lt;a href=&quot;#expr&quot;&gt;expr에 &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; 에서 &lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42eb3728a0a95a8f7cc668516e38099d5ab80194" translate="yes" xml:space="preserve">
          <source>letexception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">letexception&lt;a href=&quot;typedecl#constr-decl&quot;&gt;constr-decl&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56562fa39251b89546ee1424e158b35667fa9b24" translate="yes" xml:space="preserve">
          <source>letmodule &amp;hellip; in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;</source>
          <target state="translated">letmodule&amp;hellip; &lt;a href=&quot;expr#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;1에서&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="cfc36b154414e2417f92dcd686143b2dc6c21baf" translate="yes" xml:space="preserve">
          <source>letmodule&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; { (&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) } [ :&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; ] =&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">letmodule &lt;a href=&quot;names#module-name&quot;&gt;모듈 이름&lt;/a&gt; {( &lt;a href=&quot;names#module-name&quot;&gt;모듈 이름&lt;/a&gt; : &lt;a href=&quot;modtypes#module-type&quot;&gt;모듈 형&lt;/a&gt; )} : &lt;a href=&quot;modtypes#module-type&quot;&gt;모듈 형&lt;/a&gt; = &lt;a href=&quot;modules#module-expr&quot;&gt;모듈 EXPR&lt;/a&gt; 에 &lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="70b92dbebf0b22df03683c261ba8c5b36dd336e6" translate="yes" xml:space="preserve">
          <source>letopen!&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">letopen!&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11014a97c66d7c6e7339ec3ba6da475633773c5c" translate="yes" xml:space="preserve">
          <source>letopen!&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;classes#class-body-type&quot;&gt;class-body-type&lt;/a&gt;</source>
          <target state="translated">letopen!&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;classes#class-body-type&quot;&gt;class-body-type&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b876ef201f4cf012020480cd1dfab1222f592001" translate="yes" xml:space="preserve">
          <source>letopen!&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;classes#class-expr&quot;&gt;class-expr&lt;/a&gt;</source>
          <target state="translated">letopen!&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;classes#class-expr&quot;&gt;class-expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92c929125a772fac69ddc25d63f7f08e4ec4f241" translate="yes" xml:space="preserve">
          <source>letopen!&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">letopen!&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="641e0ba875b175ea7e480a5c1cf6c3a34d65b084" translate="yes" xml:space="preserve">
          <source>letopen&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">letopen&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0ab7577eb770be85dacb087541fc5e1733d1f3d8" translate="yes" xml:space="preserve">
          <source>letopen&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt;</source>
          <target state="translated">letopen&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;#class-body-type&quot;&gt;class-body-type&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c6d98bf520d0a44be48bea2d7acc9524c23493e" translate="yes" xml:space="preserve">
          <source>letopen&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;</source>
          <target state="translated">letopen&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;#class-expr&quot;&gt;class-expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52af1a8150b03cb2249048aa49b9307760ec15be" translate="yes" xml:space="preserve">
          <source>letopen&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">letopen&lt;a href=&quot;names#module-path&quot;&gt;module-path&lt;/a&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="310a5aa1b3381740d0c18cf6104a61696db10b40" translate="yes" xml:space="preserve">
          <source>letrec&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;and &amp;hellip; and&lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">letrec &lt;a href=&quot;patterns#pattern&quot;&gt;무늬 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; = &lt;a href=&quot;#expr&quot;&gt;EXPR &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; 및 ... 및 &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; = &lt;a href=&quot;#expr&quot;&gt;expr에 &lt;/a&gt;&lt;sub&gt;N&lt;/sub&gt; 에서 &lt;a href=&quot;#expr&quot;&gt;EXPR&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4adcbb2abeb4b992c60a4bc707cf9a0d2bff2ce8" translate="yes" xml:space="preserve">
          <source>letrecname&lt;sub&gt;1&lt;/sub&gt;=1::name&lt;sub&gt;2&lt;/sub&gt;andname&lt;sub&gt;2&lt;/sub&gt;=2::name&lt;sub&gt;1&lt;/sub&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">letrecname&lt;sub&gt;1&lt;/sub&gt;=1::name&lt;sub&gt;2&lt;/sub&gt;andname&lt;sub&gt;2&lt;/sub&gt;=2::name&lt;sub&gt;1&lt;/sub&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d2c3797b2547d8c84ae51b691a195de7f5ec187" translate="yes" xml:space="preserve">
          <source>letrecname&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;and &amp;hellip; andname&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">letrecname&lt;sub&gt;1&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;and &amp;hellip; andname&lt;sub&gt;n&lt;/sub&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;in&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ea11c1fc7e46b9818b97453eacaaf9d5b35189c7" translate="yes" xml:space="preserve">
          <source>letrecname&lt;sub&gt;1&lt;/sub&gt;=fun &amp;hellip; and &amp;hellip; andname&lt;sub&gt;n&lt;/sub&gt;=fun &amp;hellip; in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">letrecname&lt;sub&gt;1&lt;/sub&gt;=fun &amp;hellip; and &amp;hellip; andname&lt;sub&gt;n&lt;/sub&gt;=fun &amp;hellip; in&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="18cc852c9ac803da9cde67a9fd74b4edd9bf98a9" translate="yes" xml:space="preserve">
          <source>letter</source>
          <target state="translated">letter</target>
        </trans-unit>
        <trans-unit id="f6dd55e8290282faf186f89026340988bbeaf29b" translate="yes" xml:space="preserve">
          <source>libraries and object code files (.o files) mentioned on the command line for the OCaml linker, that provide implementations for the user&amp;rsquo;s primitives.</source>
          <target state="translated">사용자의 기본 요소에 대한 구현을 제공하는 OCaml 링커의 명령 줄에 언급 된 라이브러리 및 개체 코드 파일 (.o 파일).</target>
        </trans-unit>
        <trans-unit id="7c2b40a5fa876226908ddc3170c8d71c443dd5a0" translate="yes" xml:space="preserve">
          <source>like short, but also display the source code snippet corresponding to the location of the error.</source>
          <target state="translated">짧지 만 오류 위치에 해당하는 소스 코드 스 니펫도 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d43892f7ad1be0ef7d80e52ad4ee97884503efac" translate="yes" xml:space="preserve">
          <source>linefeed (LF)</source>
          <target state="translated">줄 바꿈 (LF)</target>
        </trans-unit>
        <trans-unit id="538d5662b399dfa89388522bb51895493a521422" translate="yes" xml:space="preserve">
          <source>linenum-directive</source>
          <target state="translated">linenum-directive</target>
        </trans-unit>
        <trans-unit id="4f0aa52d656a3d75867f784b7e9c5d23bf1321c0" translate="yes" xml:space="preserve">
          <source>link</source>
          <target state="translated">link</target>
        </trans-unit>
        <trans-unit id="38b62be4bddaa5661c7d6b8e36e28159314df5c7" translate="yes" xml:space="preserve">
          <source>list</source>
          <target state="translated">list</target>
        </trans-unit>
        <trans-unit id="2126efbc35f0f38125d2dcb645d7dbb11147e4d1" translate="yes" xml:space="preserve">
          <source>list [module] [beginning] [end]</source>
          <target state="translated">목록 [모듈] [시작] [끝]</target>
        </trans-unit>
        <trans-unit id="1f6ceaab00ab5f5571e9e76ed80536af01290222" translate="yes" xml:space="preserve">
          <source>load_printer &quot;file-name&quot;</source>
          <target state="translated">load_printer &quot;파일 이름&quot;</target>
        </trans-unit>
        <trans-unit id="4eef2c8c3538b5a80c5bed215aae8bd4f2193498" translate="yes" xml:space="preserve">
          <source>local-open</source>
          <target state="translated">local-open</target>
        </trans-unit>
        <trans-unit id="813bee93ab6fa289818ebeaebca612fefc3730cc" translate="yes" xml:space="preserve">
          <source>lor</source>
          <target state="translated">lor</target>
        </trans-unit>
        <trans-unit id="ddea6f9c04724c4c12a5f5ce62bbed894736fbe9" translate="yes" xml:space="preserve">
          <source>lor, &lt;a href=&quot;names#hevea_manual.kwd2&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd53&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd72&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd79&quot;&gt;7.7.5&lt;/a&gt;</source>
          <target state="translated">lor, &lt;a href=&quot;names#hevea_manual.kwd2&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd53&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd72&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd79&quot;&gt;7.7.5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="171c1e65f95a4d4992c129151e673f844920649a" translate="yes" xml:space="preserve">
          <source>lowercase</source>
          <target state="translated">lowercase</target>
        </trans-unit>
        <trans-unit id="b3d7bc6dec9d4a5736f54335407387cb52cd9990" translate="yes" xml:space="preserve">
          <source>lowercase-ident</source>
          <target state="translated">lowercase-ident</target>
        </trans-unit>
        <trans-unit id="f7f2eb6bbc15d0ded786bf7b3f340e5c4e5db6a8" translate="yes" xml:space="preserve">
          <source>lowercase-letter</source>
          <target state="translated">lowercase-letter</target>
        </trans-unit>
        <trans-unit id="0c752315a1966211d0e696c3b3a70c6cab9bdcc3" translate="yes" xml:space="preserve">
          <source>lsl</source>
          <target state="translated">lsl</target>
        </trans-unit>
        <trans-unit id="4940e1d34c73989113408f4871b8a43b9211675d" translate="yes" xml:space="preserve">
          <source>lsl, &lt;a href=&quot;names#hevea_manual.kwd4&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd55&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd74&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd81&quot;&gt;7.7.5&lt;/a&gt;</source>
          <target state="translated">lsl, &lt;a href=&quot;names#hevea_manual.kwd4&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd55&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd74&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd81&quot;&gt;7.7.5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="291e20479a95bc25eca3f8a8ea285c5067de7d92" translate="yes" xml:space="preserve">
          <source>lsr</source>
          <target state="translated">lsr</target>
        </trans-unit>
        <trans-unit id="72f143b0c5a3e9618ed0a2276e7d0a2f9f7f8ba5" translate="yes" xml:space="preserve">
          <source>lsr, &lt;a href=&quot;names#hevea_manual.kwd5&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd56&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd75&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd82&quot;&gt;7.7.5&lt;/a&gt;</source>
          <target state="translated">lsr, &lt;a href=&quot;names#hevea_manual.kwd5&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd56&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd75&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd82&quot;&gt;7.7.5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="18b316c879567a0ce0fc85005e0756822a16e896" translate="yes" xml:space="preserve">
          <source>lxor</source>
          <target state="translated">lxor</target>
        </trans-unit>
        <trans-unit id="6cfed45bd572474c709444aea7bce2673d33ac9a" translate="yes" xml:space="preserve">
          <source>lxor, &lt;a href=&quot;names#hevea_manual.kwd3&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd54&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd73&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd80&quot;&gt;7.7.5&lt;/a&gt;</source>
          <target state="translated">lxor, &lt;a href=&quot;names#hevea_manual.kwd3&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd54&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd73&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd80&quot;&gt;7.7.5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6b0d31c0d563223024da45691584643ac78c96e8" translate="yes" xml:space="preserve">
          <source>m</source>
          <target state="translated">m</target>
        </trans-unit>
        <trans-unit id="386a0e08ae576045599a5bc72e69d77c43a6601f" translate="yes" xml:space="preserve">
          <source>makes programs more readable,</source>
          <target state="translated">프로그램을 더 읽기 쉽게 만들고</target>
        </trans-unit>
        <trans-unit id="ef5c844eab88bcaca779bd2f3ad67b573bbbbfca" translate="yes" xml:space="preserve">
          <source>match</source>
          <target state="translated">match</target>
        </trans-unit>
        <trans-unit id="0b9b87661089dba83f207c00443e59cd0732c797" translate="yes" xml:space="preserve">
          <source>match branches: a count point is set at the beginning of the body of each branch</source>
          <target state="translated">지점 일치 : 각 지점의 본문 시작 부분에 카운트 포인트가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1e1c4e3594bfff0b597bb338d0192b0ed145c4a9" translate="yes" xml:space="preserve">
          <source>match, &lt;a href=&quot;expr#hevea_manual.kwd37&quot;&gt;7.7&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd48&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd65&quot;&gt;7.7.3&lt;/a&gt;, &lt;a href=&quot;gadts#hevea_manual.kwd226&quot;&gt;8.10&lt;/a&gt;</source>
          <target state="translated">일치, &lt;a href=&quot;expr#hevea_manual.kwd37&quot;&gt;7.7&lt;/a&gt; , &lt;a href=&quot;expr#hevea_manual.kwd48&quot;&gt;7.7.1&lt;/a&gt; , &lt;a href=&quot;expr#hevea_manual.kwd65&quot;&gt;7.7.3&lt;/a&gt; , &lt;a href=&quot;gadts#hevea_manual.kwd226&quot;&gt;8.10&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f5a47fbf471b30182c1c596bf642e7f451eae0c1" translate="yes" xml:space="preserve">
          <source>match&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;with&lt;a href=&quot;#pattern-matching&quot;&gt;pattern-matching&lt;/a&gt;</source>
          <target state="translated">match&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;with&lt;a href=&quot;#pattern-matching&quot;&gt;pattern-matching&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ab2f7945dcc0079f3d02ec3fae0eebfa2f5b92b" translate="yes" xml:space="preserve">
          <source>matches the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; against the patterns &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; to &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;. If the matching against &lt;a href=&quot;patterns#pattern&quot;&gt;pattern&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; succeeds, the associated expression &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; is evaluated, and its value becomes the value of the whole match expression. The evaluation of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; takes place in an environment enriched by the bindings performed during matching. If several patterns match the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, the one that occurs first in the match expression is selected. If none of the patterns match the value of &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;, the exception Match_failure is raised.</source>
          <target state="translated">&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 의 값을 패턴 &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;1에&lt;/sub&gt; 대해 &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; 에 일치시킵니다 . &lt;a href=&quot;patterns#pattern&quot;&gt;패턴 &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; 에 대한 일치 가 성공하면 연관된 표현식 &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; 가 평가되고 해당 값이 전체 일치 표현식의 값이됩니다. &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;sub&gt;i&lt;/sub&gt; 의 평가는 일치하는 동안 수행 된 바인딩으로 강화 된 환경에서 발생합니다. 여러 패턴이 &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 의 값과 일치하는 경우 일치 표현식에서 가장 먼저 발생하는 패턴 이 선택됩니다. &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt; 값과 일치하는 패턴이 없으면 Match_failure 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4ca29d521ef6f186e6e2d15f55cbe7e024ec6a84" translate="yes" xml:space="preserve">
          <source>matching-case</source>
          <target state="translated">matching-case</target>
        </trans-unit>
        <trans-unit id="7c73604104e94ed36100e6d479105b2b83f7b01f" translate="yes" xml:space="preserve">
          <source>may be duplicated.</source>
          <target state="translated">중복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3a80232d91ddcfb50da954cfc4b07afb601a27e" translate="yes" xml:space="preserve">
          <source>merge @author</source>
          <target state="translated">@author 병합</target>
        </trans-unit>
        <trans-unit id="88e74efa98c09b4ca89b5a183f94ff4536cc94af" translate="yes" xml:space="preserve">
          <source>merge @before</source>
          <target state="translated">@before 병합</target>
        </trans-unit>
        <trans-unit id="13b4f1a61e2feec40f97a21336727e1c3eaca7e3" translate="yes" xml:space="preserve">
          <source>merge @deprecated</source>
          <target state="translated">@deprecated 병합</target>
        </trans-unit>
        <trans-unit id="287e8cb68be7c090edf1807937932f2139847c64" translate="yes" xml:space="preserve">
          <source>merge @param</source>
          <target state="translated">@param 병합</target>
        </trans-unit>
        <trans-unit id="8be922b4f91d4ddf8d1c54fdebb3bab166e17cc7" translate="yes" xml:space="preserve">
          <source>merge @raise</source>
          <target state="translated">@raise 병합</target>
        </trans-unit>
        <trans-unit id="a7c201dab801a62713c218da8e02e6c3a08882ec" translate="yes" xml:space="preserve">
          <source>merge @return</source>
          <target state="translated">@return 병합</target>
        </trans-unit>
        <trans-unit id="d94394a5a243f3c0a5d73dac018a4602e03c9219" translate="yes" xml:space="preserve">
          <source>merge @see</source>
          <target state="translated">@see 병합</target>
        </trans-unit>
        <trans-unit id="02e0b3b936c0c662ebcfdf810d2149281cf5964e" translate="yes" xml:space="preserve">
          <source>merge @since</source>
          <target state="translated">@since 병합</target>
        </trans-unit>
        <trans-unit id="114d10054574c18342d8601a610ff500d4699c6f" translate="yes" xml:space="preserve">
          <source>merge @version</source>
          <target state="translated">@version 병합</target>
        </trans-unit>
        <trans-unit id="3cf3d63d0de7339512c7c20877b3493c69d4b391" translate="yes" xml:space="preserve">
          <source>merge description</source>
          <target state="translated">설명 병합</target>
        </trans-unit>
        <trans-unit id="081bf3eedfad8141702fa4a674de79254e0bba8d" translate="yes" xml:space="preserve">
          <source>merge everything</source>
          <target state="translated">모든 것을 병합</target>
        </trans-unit>
        <trans-unit id="8a2028205cfa2d777778b9c1917c1f319ccdc056" translate="yes" xml:space="preserve">
          <source>method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; {&lt;a href=&quot;expr#parameter&quot;&gt;parameter&lt;/a&gt;} [:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;] =&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; {&lt;a href=&quot;expr#parameter&quot;&gt;parameter&lt;/a&gt;} [:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;] =&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="97a4d248969085dc90c6ba25671be9eb3e3a66e9" translate="yes" xml:space="preserve">
          <source>method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="004b8055d31dce5d4e913167b004b3141837a0d3" translate="yes" xml:space="preserve">
          <source>method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:type { &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt; }&lt;sup&gt;+&lt;/sup&gt;.&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">method [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:type { &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt; }&lt;sup&gt;+&lt;/sup&gt;.&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4d4eee113689a169ac1f1621aa0617f21c99c15" translate="yes" xml:space="preserve">
          <source>method [private] [virtual] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;</source>
          <target state="translated">method [private] [virtual] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d9ce6bced41cd8c05830dddc0882debf66ac3928" translate="yes" xml:space="preserve">
          <source>method [private] virtual&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;</source>
          <target state="translated">방법 [비공개] 가상 &lt;a href=&quot;names#method-name&quot;&gt;방법 이름&lt;/a&gt; : &lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5a342a3b18641ab1a9d1a21182afb977dbb6aa77" translate="yes" xml:space="preserve">
          <source>method names (&lt;a href=&quot;#method-name&quot;&gt;method-name&lt;/a&gt;),</source>
          <target state="translated">메소드 이름 ( &lt;a href=&quot;#method-name&quot;&gt;method-name&lt;/a&gt; ),</target>
        </trans-unit>
        <trans-unit id="491ac61e8bf68487cd27e9b71f1b4310a54c3b00" translate="yes" xml:space="preserve">
          <source>method! [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; {&lt;a href=&quot;expr#parameter&quot;&gt;parameter&lt;/a&gt;} [:&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;] =&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">방법! [비공개] &lt;a href=&quot;names#method-name&quot;&gt;메소드 이름&lt;/a&gt; { &lt;a href=&quot;expr#parameter&quot;&gt;매개 변수&lt;/a&gt; } [: &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; ] = &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c4f952509013443c536c201db74e15a8cbd892da" translate="yes" xml:space="preserve">
          <source>method! [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">방법! [비공개] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; : &lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt; = &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d70c4031b37141b9d489ed7a1a3e3ade74cc42dd" translate="yes" xml:space="preserve">
          <source>method! [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:type { &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt; }&lt;sup&gt;+&lt;/sup&gt;.&lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt;=&lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">방법! [private] &lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt; : type { &lt;a href=&quot;names#typeconstr-name&quot;&gt;typeconstr-name&lt;/a&gt; } &lt;sup&gt;+&lt;/sup&gt; . &lt;a href=&quot;types#typexpr&quot;&gt;typexpr&lt;/a&gt; = &lt;a href=&quot;expr#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="72d34da1d32cc0d6e3501e59432f8b5e192bd725" translate="yes" xml:space="preserve">
          <source>method, &lt;a href=&quot;classes#hevea_manual.kwd106&quot;&gt;7.9.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd113&quot;&gt;7.9.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd115&quot;&gt;7.9.1&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd127&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd137&quot;&gt;7.9.2&lt;/a&gt;, &lt;a href=&quot;classes#hevea_manual.kwd139&quot;&gt;7.9.2&lt;/a&gt;</source>
          <target state="translated">방법, &lt;a href=&quot;classes#hevea_manual.kwd106&quot;&gt;7.9.1&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd113&quot;&gt;7.9.1&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd115&quot;&gt;7.9.1&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd127&quot;&gt;7.9.2&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd137&quot;&gt;7.9.2&lt;/a&gt; , &lt;a href=&quot;classes#hevea_manual.kwd139&quot;&gt;7.9.2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8fd20118ee7a7faac798544db735f202b14acf41" translate="yes" xml:space="preserve">
          <source>method-name</source>
          <target state="translated">method-name</target>
        </trans-unit>
        <trans-unit id="57d32765a281ea1c0a529b8ce8847eb1cd520e63" translate="yes" xml:space="preserve">
          <source>method-type</source>
          <target state="translated">method-type</target>
        </trans-unit>
        <trans-unit id="01a46fb52f0c14f92da476120be7afe1ef1ec52d" translate="yes" xml:space="preserve">
          <source>method:</source>
          <target state="translated">method:</target>
        </trans-unit>
        <trans-unit id="8334677a4eea51376469f929869216e0ab4616fd" translate="yes" xml:space="preserve">
          <source>methodvirtualprivate&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;</source>
          <target state="translated">methodvirtualprivate&lt;a href=&quot;names#method-name&quot;&gt;method-name&lt;/a&gt;:&lt;a href=&quot;types#poly-typexpr&quot;&gt;poly-typexpr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="614383124112900fb6142b3695d7dfbf394c6335" translate="yes" xml:space="preserve">
          <source>miscellaneous memory-related functions and macros (for GC interface, in-place modification of structures, etc).</source>
          <target state="translated">기타 메모리 관련 함수 및 매크로 (GC 인터페이스, 구조의 내부 수정 등)</target>
        </trans-unit>
        <trans-unit id="5efca0a1c6b9e23ddc653fc69324668576ca551d" translate="yes" xml:space="preserve">
          <source>mkfifo</source>
          <target state="translated">mkfifo</target>
        </trans-unit>
        <trans-unit id="7dd30f0a95d522bfc058be4e75847f8b6df9f76b" translate="yes" xml:space="preserve">
          <source>mod</source>
          <target state="translated">mod</target>
        </trans-unit>
        <trans-unit id="06c208939b2262778ef29013e5908ca82e6e3245" translate="yes" xml:space="preserve">
          <source>mod ∣ land ∣ lor ∣ lxor ∣ lsl ∣ lsr ∣ asr</source>
          <target state="translated">mod ∣ land ∣ lor ∣ lxor ∣ lsl ∣ lsr ∣ asr</target>
        </trans-unit>
        <trans-unit id="63ab5a4895e2bc2ade8b04e93895b8fc37dd8e04" translate="yes" xml:space="preserve">
          <source>mod, &lt;a href=&quot;names#hevea_manual.kwd0&quot;&gt;7.3&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd51&quot;&gt;7.7.1&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd70&quot;&gt;7.7.5&lt;/a&gt;, &lt;a href=&quot;expr#hevea_manual.kwd77&quot;&gt;7.7.5&lt;/a&gt;</source>
          <target state="translated">모드, &lt;a href=&quot;names#hevea_manual.kwd0&quot;&gt;7.3&lt;/a&gt; , &lt;a href=&quot;expr#hevea_manual.kwd51&quot;&gt;7.7.1&lt;/a&gt; , &lt;a href=&quot;expr#hevea_manual.kwd70&quot;&gt;7.7.5&lt;/a&gt; , &lt;a href=&quot;expr#hevea_manual.kwd77&quot;&gt;7.7.5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6d636f16bc4bdded1e9603e3215629abedd36a6b" translate="yes" xml:space="preserve">
          <source>mod-constraint</source>
          <target state="translated">mod-constraint</target>
        </trans-unit>
        <trans-unit id="3dae3b4efe9ff863260fe60d05952948b42579e8" translate="yes" xml:space="preserve">
          <source>mode:</source>
          <target state="translated">mode:</target>
        </trans-unit>
        <trans-unit id="008f58e566745159bf275b503f47ccc404114628" translate="yes" xml:space="preserve">
          <source>modtype-name</source>
          <target state="translated">modtype-name</target>
        </trans-unit>
        <trans-unit id="8f625b907f6d84171d5c22e1036e9fce19990a18" translate="yes" xml:space="preserve">
          <source>modtype-path</source>
          <target state="translated">modtype-path</target>
        </trans-unit>
        <trans-unit id="2078d9b7571dfde4914b5ce804793816f94bf991" translate="yes" xml:space="preserve">
          <source>modtype:</source>
          <target state="translated">modtype:</target>
        </trans-unit>
        <trans-unit id="fbd34a2b6e6a9fe8161f97dc435642609ac0bc29" translate="yes" xml:space="preserve">
          <source>module</source>
          <target state="translated">module</target>
        </trans-unit>
        <trans-unit id="7441763e8eadca2fc8f46b1c8e352dca85e44ef4" translate="yes" xml:space="preserve">
          <source>module names (&lt;a href=&quot;#module-name&quot;&gt;module-name&lt;/a&gt;),</source>
          <target state="translated">모듈 이름 ( &lt;a href=&quot;#module-name&quot;&gt;module-name&lt;/a&gt; ),</target>
        </trans-unit>
        <trans-unit id="a8006ab4be9c917928e0ca82ba074953be1e5ab4" translate="yes" xml:space="preserve">
          <source>module type</source>
          <target state="translated">모듈 유형</target>
        </trans-unit>
        <trans-unit id="ff018ec921edc32afa3f9da1561f4efc690c0da0" translate="yes" xml:space="preserve">
          <source>module type names (&lt;a href=&quot;#modtype-name&quot;&gt;modtype-name&lt;/a&gt;).</source>
          <target state="translated">모듈 유형 이름 ( &lt;a href=&quot;#modtype-name&quot;&gt;modtype-name&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="66ccaea6e2ca71b1b1450f0caf5262350d7e8783" translate="yes" xml:space="preserve">
          <source>module, &lt;a href=&quot;expr#hevea_manual.kwd89&quot;&gt;7.7.8&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd160&quot;&gt;7.10&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd172&quot;&gt;7.10.2&lt;/a&gt;, &lt;a href=&quot;modtypes#hevea_manual.kwd174&quot;&gt;7.10.2&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd188&quot;&gt;7.11&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd200&quot;&gt;7.11.2&lt;/a&gt;, &lt;a href=&quot;modules#hevea_manual.kwd202&quot;&gt;7.11.2&lt;/a&gt;, &lt;a href=&quot;manual024#hevea_manual.kwd206&quot;&gt;8.2&lt;/a&gt;, &lt;a href=&quot;firstclassmodules#hevea_manual.kwd212&quot;&gt;8.5&lt;/a&gt;, &lt;a href=&quot;moduletypeof#hevea_manual.kwd216&quot;&gt;8.6&lt;/a&gt;, &lt;a href=&quot;signaturesubstitution#hevea_manual.kwd221&quot;&gt;8.7&lt;/a&gt;, &lt;a href=&quot;modulealias#hevea_manual.kwd223&quot;&gt;8.8&lt;/a&gt;</source>
          <target state="translated">모듈, &lt;a href=&quot;expr#hevea_manual.kwd89&quot;&gt;7.7.8&lt;/a&gt; , &lt;a href=&quot;modtypes#hevea_manual.kwd160&quot;&gt;7.10&lt;/a&gt; , &lt;a href=&quot;modtypes#hevea_manual.kwd172&quot;&gt;7.10.2&lt;/a&gt; , &lt;a href=&quot;modtypes#hevea_manual.kwd174&quot;&gt;7.10.2&lt;/a&gt; , &lt;a href=&quot;modules#hevea_manual.kwd188&quot;&gt;7.11&lt;/a&gt; , &lt;a href=&quot;modules#hevea_manual.kwd200&quot;&gt;7.11.2&lt;/a&gt; , &lt;a href=&quot;modules#hevea_manual.kwd202&quot;&gt;7.11.2&lt;/a&gt; , &lt;a href=&quot;manual024#hevea_manual.kwd206&quot;&gt;8.2&lt;/a&gt; , &lt;a href=&quot;firstclassmodules#hevea_manual.kwd212&quot;&gt;8.5&lt;/a&gt; , &lt;a href=&quot;moduletypeof#hevea_manual.kwd216&quot;&gt;8.6&lt;/a&gt; , &lt;a href=&quot;signaturesubstitution#hevea_manual.kwd221&quot;&gt;8.7&lt;/a&gt; , &lt;a href=&quot;modulealias#hevea_manual.kwd223&quot;&gt;8.8&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4cd15a4ce8a913b20909f69ed51f94dbccccc68f" translate="yes" xml:space="preserve">
          <source>module-expr</source>
          <target state="translated">module-expr</target>
        </trans-unit>
        <trans-unit id="4e3c9a4fceacf3d192e656bfc0847f9da785fa74" translate="yes" xml:space="preserve">
          <source>module-items</source>
          <target state="translated">module-items</target>
        </trans-unit>
        <trans-unit id="8ee15acbd165acaa3fef478e3d7ce0417164f411" translate="yes" xml:space="preserve">
          <source>module-name</source>
          <target state="translated">module-name</target>
        </trans-unit>
        <trans-unit id="1809db2c8ca3cd86dd0fdcf7aadd3f15ca27ad7e" translate="yes" xml:space="preserve">
          <source>module-path</source>
          <target state="translated">module-path</target>
        </trans-unit>
        <trans-unit id="29544219138b467872756c6b67b20584c7e6f25e" translate="yes" xml:space="preserve">
          <source>module-type</source>
          <target state="translated">module-type</target>
        </trans-unit>
        <trans-unit id="d1bf2e17e7158e60062b4c38d952e84b30ef30c3" translate="yes" xml:space="preserve">
          <source>module:</source>
          <target state="translated">module:</target>
        </trans-unit>
        <trans-unit id="99933645f3edbe7c64fff338a2636a8d018ffe92" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; { (&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;) } :&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;</source>
          <target state="translated">모듈 &lt;a href=&quot;names#module-name&quot;&gt;모듈 이름&lt;/a&gt; {( &lt;a href=&quot;names#module-name&quot;&gt;모듈 이름&lt;/a&gt; : &lt;a href=&quot;#module-type&quot;&gt;모듈 유형&lt;/a&gt; )} : &lt;a href=&quot;#module-type&quot;&gt;모듈 유형&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd25d37a9a6ec100221b48f42e245756859b23ab" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; { (&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) } :&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; }</source>
          <target state="translated">모듈 &lt;a href=&quot;names#module-name&quot;&gt;모듈 이름&lt;/a&gt; {( &lt;a href=&quot;names#module-name&quot;&gt;모듈 이름&lt;/a&gt; : &lt;a href=&quot;modtypes#module-type&quot;&gt;모듈 유형&lt;/a&gt; )} : &lt;a href=&quot;modtypes#module-type&quot;&gt;모듈 유형&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;항목 속성&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="bdadf480c8065207bb758b98366a71b036929433" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; { (&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) } [ :&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; ] =&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;</source>
          <target state="translated">module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; { (&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) } [ :&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; ] =&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa34c20a9c7d986a37d6eddddd05986ad9258f5c" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; { (&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) } [ :&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; ] =&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; }</source>
          <target state="translated">module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; { (&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) } [ :&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; ] =&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="1effb736fd5f5334d101acbb2561cc9bfd106725" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; { (&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) ∣ () } :&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;</source>
          <target state="translated">모듈 &lt;a href=&quot;names#module-name&quot;&gt;모듈 이름&lt;/a&gt; {( &lt;a href=&quot;names#module-name&quot;&gt;모듈 이름&lt;/a&gt; : &lt;a href=&quot;modtypes#module-type&quot;&gt;모듈 유형&lt;/a&gt; ) ∣ ()} : &lt;a href=&quot;modtypes#module-type&quot;&gt;모듈 유형&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4983318ce2c3564851abf76d595b1d25621f08b7" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; { (&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) ∣ () } [ :&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; ] =&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;</source>
          <target state="translated">module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt; { (&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;) ∣ () } [ :&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; ] =&lt;a href=&quot;modules#module-expr&quot;&gt;module-expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8467d40414b615a8d8b9b013ae16bc58757f7d3f" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;(name&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;) &amp;hellip; (name&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;):&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;</source>
          <target state="translated">module &lt;a href=&quot;names#module-name&quot;&gt;-name&lt;/a&gt; (name &lt;sub&gt;1&lt;/sub&gt; : &lt;a href=&quot;#module-type&quot;&gt;module-type &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; )&amp;hellip; (name &lt;sub&gt;n&lt;/sub&gt; : &lt;a href=&quot;#module-type&quot;&gt;module-type &lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt; ) : &lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="937c777204afe4c1bc132190a3d30d967a32788c" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;(name&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;) &amp;hellip; (name&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;)=&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;</source>
          <target state="translated">module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;(name&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;) &amp;hellip; (name&lt;sub&gt;n&lt;/sub&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;n&lt;/sub&gt;)=&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d038178fa9ade448767894d13aa64c21d48f6e0a" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;</source>
          <target state="translated">module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf3cf4d234053495820f28e041e9f40be3b34f64" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;item-attribute&lt;/a&gt; }</source>
          <target state="translated">모듈 &lt;a href=&quot;names#module-name&quot;&gt;모듈 이름&lt;/a&gt; : &lt;a href=&quot;modtypes#module-type&quot;&gt;모듈 유형&lt;/a&gt; { &lt;a href=&quot;#item-attribute&quot;&gt;항목 속성&lt;/a&gt; }</target>
        </trans-unit>
        <trans-unit id="a1390692de1de4cfcb57f9a157fc2b42b55f29f0" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;=&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;</source>
          <target state="translated">module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;=&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e00f00c98b176075f013ab125f5a6e633ed2b73" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:=&lt;a href=&quot;names#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt;</source>
          <target state="translated">module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:=&lt;a href=&quot;names#extended-module-path&quot;&gt;extended-module-path&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="893c581556967dd03a0cd4ae837413e1977ae685" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;:functor(name&lt;sub&gt;1&lt;/sub&gt;:&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt;)-&amp;gt; &amp;hellip; -&amp;gt;&lt;a href=&quot;#module-type&quot;&gt;module-type&lt;/a&gt;</source>
          <target state="translated">모듈 &lt;a href=&quot;names#module-name&quot;&gt;모듈 이름&lt;/a&gt; : functor (이름 &lt;sub&gt;1&lt;/sub&gt; : &lt;a href=&quot;#module-type&quot;&gt;모듈 유형 &lt;/a&gt;&lt;sub&gt;1&lt;/sub&gt; )-&amp;gt;&amp;hellip;-&amp;gt; &lt;a href=&quot;#module-type&quot;&gt;모듈 유형&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8282410bc5bb37ea017816d776939482bd821c09" translate="yes" xml:space="preserve">
          <source>module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;=(&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;).</source>
          <target state="translated">module&lt;a href=&quot;names#module-name&quot;&gt;module-name&lt;/a&gt;=(&lt;a href=&quot;#module-expr&quot;&gt;module-expr&lt;/a&gt;:&lt;a href=&quot;modtypes#module-type&quot;&gt;module-type&lt;/a&gt;).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
