<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="knockout">
    <body>
      <group id="knockout">
        <trans-unit id="55f7a75bfb6b682f736e46b92c2f236aae124e0e" translate="yes" xml:space="preserve">
          <source>&quot;afterkeydown&quot; - updates your view model as soon as the user begins typing a character. This works by catching the browser&amp;rsquo;s keydown event and handling the event asynchronously. This does not work in some mobile browsers.</source>
          <target state="translated">&quot;afterkeydown&quot;-사용자가 문자 입력을 시작하자마자 뷰 모델을 업데이트합니다. 이것은 브라우저의 키 다운 이벤트를 포착하고 이벤트를 비동기 적으로 처리하여 작동합니다. 일부 모바일 브라우저에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bf88a9f967d7e0a2ecb9a2c3cb373e62550ca35" translate="yes" xml:space="preserve">
          <source>&quot;input&quot; - updates your view model when the value of an &amp;lt;input&amp;gt; or &amp;lt;textarea&amp;gt; element changes. Note that this event is only raised by reasonably modern browsers (e.g., IE 9+).</source>
          <target state="translated">&quot;input&quot;-&amp;lt;input&amp;gt; 또는 &amp;lt;textarea&amp;gt; 요소의 값이 변경 될 때 뷰 모델을 업데이트합니다. 이 이벤트는 합리적으로 최신 브라우저 (예 : IE 9+)에서만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="43249745c4adbf35a9cb9922652997d87dbe4042" translate="yes" xml:space="preserve">
          <source>&quot;keypress&quot; - updates your view model when the user has typed a key. Unlike keyup, this updates repeatedly while the user holds a key down</source>
          <target state="translated">&quot;keypress&quot;-사용자가 키를 입력하면 뷰 모델이 업데이트됩니다. 키 업과 달리이 키는 사용자가 키를 누른 상태에서 반복적으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="754a19ddfd1580a60ebdb60a67460f4ed1868828" translate="yes" xml:space="preserve">
          <source>&quot;keyup&quot; - updates your view model when the user releases a key</source>
          <target state="translated">&quot;키업&quot;-사용자가 키를 놓을 때 뷰 모델을 업데이트합니다</target>
        </trans-unit>
        <trans-unit id="b023c5f7752f43d6081c327d978bba7f21cae65e" translate="yes" xml:space="preserve">
          <source>&quot;notifyAtFixedRate&quot; &amp;mdash; &lt;strong&gt;Default value if not otherwise specified&lt;/strong&gt;. The notification happens after the specified period of time from the first change to the observable (either initially or since the previous notification).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09a76466185a7fa8b0e097018e39dd0d76592070" translate="yes" xml:space="preserve">
          <source>&quot;notifyWhenChangesStop&quot; &amp;mdash; The notification happens after no changes have occured to the observable for the specified period of time. Each time the observable changes, that timer is reset, so notifications cannot happen if the observable continuously changes more frequently than the timeout period.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e067625ca975ca350ad14ef24cf6b1eeeb932ab7" translate="yes" xml:space="preserve">
          <source>$component</source>
          <target state="translated">$component</target>
        </trans-unit>
        <trans-unit id="f27c0d6823b43be383afbf56a525fa3e7b5bca08" translate="yes" xml:space="preserve">
          <source>$componentTemplateNodes</source>
          <target state="translated">$componentTemplateNodes</target>
        </trans-unit>
        <trans-unit id="b4aa877f2150e2e324627c78466629fcce97867e" translate="yes" xml:space="preserve">
          <source>$context</source>
          <target state="translated">$context</target>
        </trans-unit>
        <trans-unit id="461e9bac5c124e13e943d74294b5b3c23e91e59a" translate="yes" xml:space="preserve">
          <source>$data</source>
          <target state="translated">$data</target>
        </trans-unit>
        <trans-unit id="8d42409e40e4019fe1ad3970dab02ce54792984f" translate="yes" xml:space="preserve">
          <source>$element</source>
          <target state="translated">$element</target>
        </trans-unit>
        <trans-unit id="a7455dbeff981624c8fd90602ba9b39d8a3236fe" translate="yes" xml:space="preserve">
          <source>$index (only available within foreach bindings)</source>
          <target state="translated">$ index (foreach 바인딩 내에서만 사용 가능)</target>
        </trans-unit>
        <trans-unit id="45e7737b5f1d96d16a40213881d84a2a492be556" translate="yes" xml:space="preserve">
          <source>$parent</source>
          <target state="translated">$parent</target>
        </trans-unit>
        <trans-unit id="95e2237aee892666510550fbfab5413dc3d3c57a" translate="yes" xml:space="preserve">
          <source>$parentContext</source>
          <target state="translated">$parentContext</target>
        </trans-unit>
        <trans-unit id="551e29188e6f391357b84d891bae6ddf016d5ab0" translate="yes" xml:space="preserve">
          <source>$parents</source>
          <target state="translated">$parents</target>
        </trans-unit>
        <trans-unit id="f68b486675e88b186e3e5d97a647fbca76132e19" translate="yes" xml:space="preserve">
          <source>$parents[0] is the view model from the parent context (i.e., it&amp;rsquo;s the same as $parent)</source>
          <target state="translated">$ parents [0]은 부모 컨텍스트의 뷰 모델입니다 (예 : $ parent와 동일).</target>
        </trans-unit>
        <trans-unit id="65c4ecaa451b9f437d3935b91802b54bbb000546" translate="yes" xml:space="preserve">
          <source>$parents[1] is the view model from the grandparent context</source>
          <target state="translated">$ parents [1]은 조부모 컨텍스트의 뷰 모델입니다.</target>
        </trans-unit>
        <trans-unit id="3cdd4ec57af42ab07ce806176c82747601207768" translate="yes" xml:space="preserve">
          <source>$parents[2] is the view model from the great-grandparent context</source>
          <target state="translated">$ parents [2]는 조부모님의 견해입니다</target>
        </trans-unit>
        <trans-unit id="7efb9bde8c0dcb7c458231902442f2ac06b5d48e" translate="yes" xml:space="preserve">
          <source>$rawData</source>
          <target state="translated">$rawData</target>
        </trans-unit>
        <trans-unit id="b764ba81776db6e2c0d3c795e5f0fb4f7b3b3158" translate="yes" xml:space="preserve">
          <source>$root</source>
          <target state="translated">$root</target>
        </trans-unit>
        <trans-unit id="281a6ce7dc200bc3ee6a1f7a74996c60f02fadb8" translate="yes" xml:space="preserve">
          <source>&amp;copy; Steven Sanderson, the Knockout.js team, and other contributors</source>
          <target state="translated">&amp;copy; Steven Sanderson, Knockout.js 팀 및 기타 기고자</target>
        </trans-unit>
        <trans-unit id="a48ee17c964423bf4cc960d5d152f164fe712d06" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and IE 6 renders no whitespace before the words to our web site, you can avoid the problem by putting any text into the &amp;lt;span&amp;gt;, e.g.:</source>
          <target state="translated">&amp;hellip; IE 6은 웹 사이트에 나오는 단어 앞에 공백을 표시하지 않습니다. &amp;lt;span&amp;gt;에 텍스트를 넣어서 문제를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e27c42ca2533fdefaeb58cc1b7eb45a5f42080eb" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and define a corresponding function on your view model (i.e., the object that contains myData):</source>
          <target state="translated">&amp;hellip; 뷰 모델 (예 : myData를 포함하는 객체)에서 해당 기능을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="cd11f3ee80ccedd0afebd460c00d949f65c71240" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and define a corresponding function on your view model:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e4a9ac6cd86f6006efcb5074a7cfc4a95acc99" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and so on.</source>
          <target state="translated">&amp;hellip; 등등.</target>
        </trans-unit>
        <trans-unit id="5a844d0606e2cebac6157c81cc9a6f5ca56660d6" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and the following custom loader will take care of loading viewmodels configured with a viaLoader value:</source>
          <target state="translated">&amp;hellip; 및 다음 사용자 정의 로더는 viaLoader 값으로 구성된 뷰 모델로드를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="2392c33f696700587811efee0b525c35b66a8113" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and the template markup is in the file path/my-component.html, then you have these benefits:</source>
          <target state="translated">&amp;hellip; 템플릿 마크 업은 파일 경로 /my-component.html에 있으며 다음과 같은 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="306ad3adf4c6d524c866e2da9e33f77bb76e411e" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and then you can use it on any number of DOM elements:</source>
          <target state="translated">&amp;hellip; 그리고 여러 DOM 요소에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d1269190ed98d387c971daefbe0a562031c6ac7" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and they will be updated whenever firstName or lastName changes (your evaluator function will be called once each time any of its dependencies change, and whatever value you return will be passed on to the observers such as UI elements or other computed observables).</source>
          <target state="translated">&amp;hellip; firstName 또는 lastName이 변경 될 때마다 업데이트됩니다 (종속성이 변경 될 때마다 평가 기 함수가 호출되며 반환 한 값이 UI 요소 또는 기타 계산 된 관찰 가능 항목과 같은 관찰자에게 전달됨).</target>
        </trans-unit>
        <trans-unit id="f0e6d69780be5a001171b8e0891626e76815b8cb" translate="yes" xml:space="preserve">
          <source>&amp;hellip; and you can do so using custom loaders.</source>
          <target state="translated">&amp;hellip; 사용자 정의 로더를 사용하여 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c678b47361f53960d600a49f5e2a49ab33bf1efb" translate="yes" xml:space="preserve">
          <source>&amp;hellip; assuming that someProperty is &lt;em&gt;observable&lt;/em&gt; and hence you need to invoke it as a function to obtain the current value.</source>
          <target state="translated">&amp;hellip; someProperty가 &lt;em&gt;관찰 가능&lt;/em&gt; 하므로 현재 값을 얻기위한 함수로 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="436bfbadf0d7e3d2acd161b36e9fa6c0aee1ca68" translate="yes" xml:space="preserve">
          <source>&amp;hellip; because data-something isn&amp;rsquo;t a legal identifier name at that point. The solution is simple: just wrap the identifier name in quotes so that it becomes a string literal, which is legal in a JavaScript object literal. For example,</source>
          <target state="translated">&amp;hellip; 데이터는 그 시점에서 유효한 식별자 이름이 아니기 때문입니다. 해결책은 간단합니다. 식별자 이름을 따옴표로 묶어 문자열 리터럴이되도록하여 JavaScript 객체 리터럴에서 유효합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="d96ec87b990d2a5f05fcb8d21bf32f55812f3e19" translate="yes" xml:space="preserve">
          <source>&amp;hellip; because my-class isn&amp;rsquo;t a legal identifier name at that point. The solution is simple: just wrap the identifier name in quotes so that it becomes a string literal, which is legal in a JavaScript object literal. For example,</source>
          <target state="translated">&amp;hellip; 내 클래스는 그 시점에서 유효한 식별자 이름이 아니기 때문입니다. 해결책은 간단합니다. 식별자 이름을 따옴표로 묶어 문자열 리터럴이되도록하여 JavaScript 객체 리터럴에서 유효합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="e308fd02d63129d37593963615074a07790d41e5" translate="yes" xml:space="preserve">
          <source>&amp;hellip; but you don&amp;rsquo;t have to, because firstName will be evaluated within the context of $data by default anyway.</source>
          <target state="translated">&amp;hellip; firstName은 기본적으로 $ data 컨텍스트 내에서 기본적으로 평가되므로 반드시 필요한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="675271334f75433b76e0d2ca2daa2caedcb7aa93" translate="yes" xml:space="preserve">
          <source>&amp;hellip; but you don&amp;rsquo;t have to, because firstName will be evaluated within the context of $data by default anyway. If the items in the array are observables, $data will refer to the value of each observable. To refer to the observable itself, use $rawData.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dd0331bbbc30c917af2ce818fb5586d7cecd6f7" translate="yes" xml:space="preserve">
          <source>&amp;hellip; can be injected with:</source>
          <target state="translated">&amp;hellip; 다음을 주사 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7f3a7cb698f6c8ba821554005a2fe7438261aff6" translate="yes" xml:space="preserve">
          <source>&amp;hellip; can be used as the template for a component by specifying its ID:</source>
          <target state="translated">&amp;hellip; ID를 지정하여 구성 요소의 템플리트로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ddd2ca25a0f65763e8a310b7c6de249963ba2b7" translate="yes" xml:space="preserve">
          <source>&amp;hellip; is equivalent to the following:</source>
          <target state="translated">&amp;hellip; 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fd4393ed67ac1cfb24dad9cf459b5a8aa896d33c" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or a createViewModel function, e.g.:</source>
          <target state="translated">&amp;hellip; 또는 createViewModel 함수 (예 :</target>
        </trans-unit>
        <trans-unit id="4445358862216b92eb56a5a61275070dfed5150b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or a shared object instance, e.g.:</source>
          <target state="translated">&amp;hellip; 또는 공유 객체 인스턴스 (예 :</target>
        </trans-unit>
        <trans-unit id="9f9f2be5a24b6d2be93f0a540aa1c45603b7e12d" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or any of the other forms described here, though it would be unusual for the others to be useful when fetching templates via AMD.</source>
          <target state="translated">&amp;hellip; 또는 여기에 설명 된 다른 형식이 있지만 AMD를 통해 템플릿을 가져올 때 다른 형식이 유용하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="dfd09f5a0fc940760751819d925befbc4f3884f0" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or even, though it&amp;rsquo;s unlikely you&amp;rsquo;d want to do this, a reference to a different AMD module, e.g.:</source>
          <target state="translated">&amp;hellip; 또는 심지어이 작업을 수행하고 싶지는 않지만 다른 AMD 모듈에 대한 참조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="76deaf0467a8d01ce5fda8253ca2bf94e5c1d09f" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or passing parameters:</source>
          <target state="translated">&amp;hellip; 또는 전달 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="c8dde18842940735246b96ebc2b6801af0bff816" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or you can send data to the server:</source>
          <target state="translated">&amp;hellip; 또는 서버로 데이터를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83dd09db0bbbaf75986c9f14324dd51a6c7b3c2b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; or, more conveniently, as a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;:</source>
          <target state="translated">또는보다 편리하게 &lt;a href=&quot;component-custom-elements&quot;&gt;사용자 정의 요소로 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a0cac50f6e17cb0207d461cfe3eadb4c1cb5b0b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; the component viewmodel&amp;rsquo;s params parameter will contain three values:</source>
          <target state="translated">&amp;hellip; 컴포넌트 뷰 모델의 params 매개 변수는 다음 세 가지 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="d03a96e5ee2c9a78e87d9468f59e17ba046629a1" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then see &lt;a href=&quot;custom-bindings-for-virtual-elements&quot;&gt;the documentation for virtual elements&lt;/a&gt;.</source>
          <target state="translated">&amp;hellip; 그런 다음 &lt;a href=&quot;custom-bindings-for-virtual-elements&quot;&gt;가상 요소에 대한 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8eb4b5f8187f3ef64e228acdde18a278aa6c4f55" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then upperCaseName will be recomputed immediately, before your next line of code runs. But if you instead define name using rateLimit as follows:</source>
          <target state="translated">&amp;hellip; 다음 코드 행이 실행되기 전에 upperCaseName이 즉시 다시 계산됩니다. 그러나 대신 다음과 같이 rateLimit을 사용하여 이름을 정의하는 경우 :</target>
        </trans-unit>
        <trans-unit id="d6d1fbc554c515663655cf7715837ed5aa4d192b" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then upperCaseName will not be recomputed immediately when name changes&amp;mdash;instead, name will wait for 500 milliseconds (half a second) before notifying its new value to upperCaseName, which will then recompute its value. No matter how many times name is changed during those 500 ms, upperCaseName will only be updated once with the most recent value.</source>
          <target state="translated">&amp;hellip; 그러면 이름이 변경 될 때 upperCaseName이 즉시 다시 계산되지 않습니다. 대신 이름은 새로운 값을 upperCaseName에 알리기 전에 500 밀리 초 (1 초) 동안 대기 한 다음 값을 다시 계산합니다. 500ms 동안 이름이 몇 번이나 변경 되더라도 upperCaseName은 가장 최근 값으로 한 번만 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="6b92e76aa3ffd11c41f69f8adf6378acda520d0e" translate="yes" xml:space="preserve">
          <source>&amp;hellip; then you&amp;rsquo;ll get the error The binding 'randomOrder' cannot be used with virtual elements. Let&amp;rsquo;s fix this. To make randomOrder usable with virtual elements, start by telling Knockout to allow it. Add the following:</source>
          <target state="translated">&amp;hellip; 그러면 'randomOrder'바인딩을 가상 요소와 함께 사용할 수 없다는 오류가 발생합니다. 이 문제를 해결합시다. randomOrder를 가상 요소와 함께 사용하려면 Knockout에이를 허용하도록 지시하십시오. 다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="80d023722c8262c22ad3fc675542d06cee7a10d4" translate="yes" xml:space="preserve">
          <source>&amp;hellip; this would &lt;em&gt;not&lt;/em&gt; render as italic text, but would render as literal text with visible angle brackets.</source>
          <target state="translated">&amp;hellip; 이것은 이탤릭체 텍스트로 렌더링 &lt;em&gt;되지&lt;/em&gt; 않지만 꺾쇠 괄호가있는 리터럴 텍스트로 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="4fe8ec038bc4329e9e45b5dfe41cee9f2fe195b1" translate="yes" xml:space="preserve">
          <source>&amp;hellip; you can write:</source>
          <target state="translated">&amp;hellip; 당신은 쓸 수 있습니다:</target>
        </trans-unit>
        <trans-unit id="b66a8f7dc087cc3fe583564359f2ab71878995ff" translate="yes" xml:space="preserve">
          <source>&amp;hellip; you could add a computed observable to return the full name:</source>
          <target state="translated">&amp;hellip; 계산 된 관찰 가능 항목을 추가하여 전체 이름을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71d7c773808d5efbd7cce431ad808079c3272374" translate="yes" xml:space="preserve">
          <source>&amp;hellip;all Knockout does is call require(['some/module/name'], callback) and require(['text!some-template.html'], callback), and uses the asynchronously-returned objects as the viewmodel and template definitions. So,</source>
          <target state="translated">&amp;hellip; 모든 녹아웃은 호출 require ([ 'some / module / name'], 콜백) 및 require ([ 'text! some-template.html'], 콜백)이며, 비동기 적으로 반환 된 객체를 뷰 모델 및 템플릿으로 사용합니다. 정의. 그래서,</target>
        </trans-unit>
        <trans-unit id="38ee4fba456bf575e89e5da4159e11ef4ef51e69" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can be composed together (nested) or inherited from other components</source>
          <target state="translated">&amp;hellip; 함께 구성 (중첩)되거나 다른 구성 요소로부터 상속 될 수 있음</target>
        </trans-unit>
        <trans-unit id="162d2e6a27442e0aa5ac2c677764866d6758b55a" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can easily be packaged for reuse across projects</source>
          <target state="translated">&amp;hellip; 프로젝트 간 재사용을 위해 쉽게 패키지화 가능</target>
        </trans-unit>
        <trans-unit id="bcba4513804170c2cfb012b6c5f4e034f8b93be4" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can either be preloaded, or loaded asynchronously (on demand) via AMD or other module systems</source>
          <target state="translated">&amp;hellip; AMD 또는 기타 모듈 시스템을 통해 사전로드되거나 비동기식으로 (요청시)로드 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7734991d30f834e7dc1591e178e0cd0b0d5521fb" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can receive parameters, and optionally write back changes to them or invoke callbacks</source>
          <target state="translated">&amp;hellip; 매개 변수를 수신하고 선택적으로 변경 사항을 기록하거나 콜백을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37c9fb1cbc39cb59f3625da14f6e4805d7b6d501" translate="yes" xml:space="preserve">
          <source>&amp;hellip;can represent individual controls/widgets, or entire sections of your application</source>
          <target state="translated">&amp;hellip; 개별 컨트롤 / 위젯 또는 애플리케이션의 전체 섹션을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c2182731546dc53e24b1c9569feb025fd6bb517" translate="yes" xml:space="preserve">
          <source>&amp;hellip;contain their own view, and usually (but optionally) their own viewmodel</source>
          <target state="translated">&amp;hellip; 자신의 견해와 일반적으로 (선택적으로) 자신의 견해를 포함</target>
        </trans-unit>
        <trans-unit id="62feedff48dd72e9502546eae6f60f51588cac08" translate="yes" xml:space="preserve">
          <source>&amp;hellip;let you define your own conventions/logic for configuration and loading</source>
          <target state="translated">&amp;hellip; 구성 및로드에 대한 고유 한 규칙 / 논리를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d6d88d1123b98cbd0f1f5e62ff9ab2b24498c00" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;class&amp;rdquo; binding example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad39df7089dc71921905acab8fd21922898ed00" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;class&amp;rdquo; parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb3c78ce58dd06a6d43eb3b9ff55c63d6083256" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;css&amp;rdquo; binding example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c61fd8db0084748a81447c5ac602f14593ede76" translate="yes" xml:space="preserve">
          <source>&amp;ldquo;css&amp;rdquo; parameters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab9a2f7e913b123d1b2147b6fcea7fc3b56f2226" translate="yes" xml:space="preserve">
          <source>&amp;lt;div data-bind=&quot;style: { color: currentProfit() &amp;lt; 0 ? 'red' : 'black', 'font-weight': isSevere() ? 'bold' : '' }&quot;&amp;gt;...&amp;lt;/div&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e5c19398840fdde1cad04e87976626ec9752a56" translate="yes" xml:space="preserve">
          <source>&amp;lt;div data-bind=&quot;style: { color: currentProfit() &amp;lt; 0 ? 'red' : 'black', fontWeight: isSevere() ? 'bold' : '' }&quot;&amp;gt;...&amp;lt;/div&amp;gt;</source>
          <target state="translated">&amp;lt;div data-bind = &quot;style : {color : currentProfit () &amp;lt;0? 'red': 'black', fontWeight : isSevere ()? 'bold': ''}&quot;&amp;gt; ... &amp;lt;/ div&amp;gt;</target>
        </trans-unit>
        <trans-unit id="38e9d45ee1eed004e555cb8df16e05183c19f62c" translate="yes" xml:space="preserve">
          <source>&amp;lt;select data-bind='options: myOptions, optionsCaption: &quot;Select an item...&quot;, value: myChosenValue'&amp;gt;&amp;lt;/select&amp;gt;</source>
          <target state="translated">&amp;lt;select data-bind = '옵션 : myOptions, optionsCaption : &quot;항목 선택 ...&quot;, 값 : myChosenValue'&amp;gt; &amp;lt;/ select&amp;gt;</target>
        </trans-unit>
        <trans-unit id="db710280a1f20bb61913609f07dc49291fe0ba4f" translate="yes" xml:space="preserve">
          <source>&amp;lt;select data-bind='options: myOptions, optionsIncludeDestroyed: true'&amp;gt;&amp;lt;/select&amp;gt;</source>
          <target state="translated">&amp;lt;select data-bind = '옵션 : myOptions, optionsIncludeDestroyed : true'&amp;gt; &amp;lt;/ select&amp;gt;</target>
        </trans-unit>
        <trans-unit id="eb1429e4a9ace15f00ed398e300f2d1e6d8acde7" translate="yes" xml:space="preserve">
          <source>(Note: If you don&amp;rsquo;t want to apply a CSS class but instead want to assign a style attribute value directly, see &lt;a href=&quot;style-binding&quot;&gt;the style binding&lt;/a&gt;.)</source>
          <target state="translated">(참고 : CSS 클래스를 적용하지 않고 스타일 속성 값을 직접 지정 &lt;a href=&quot;style-binding&quot;&gt;하려면 스타일 바인딩을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="15891bb9e3faad48e1edd4725ace6108a9566b87" translate="yes" xml:space="preserve">
          <source>(Note: If you don&amp;rsquo;t want to apply an explicit style value but instead want to assign a CSS class, see &lt;a href=&quot;css-binding&quot;&gt;the class or css binding&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a142a8a08360ecb44da2e404e6e9702082412cb" translate="yes" xml:space="preserve">
          <source>(Note: If you don&amp;rsquo;t want to apply an explicit style value but instead want to assign a CSS class, see &lt;a href=&quot;css-binding&quot;&gt;the css binding&lt;/a&gt;.)</source>
          <target state="translated">(참고 : 명시적인 스타일 값을 적용하지 않고 CSS 클래스를 할당 &lt;a href=&quot;css-binding&quot;&gt;하려면 css 바인딩을&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="fd7f1dbd9b0a6243440f34f5f4c46eeb6f3829a1" translate="yes" xml:space="preserve">
          <source>(The awake event also applies to normal computed observables created with the deferEvaluation option.)</source>
          <target state="translated">(각성 이벤트는 deferEvaluation 옵션으로 생성 된 일반 계산 된 관찰 가능 항목에도 적용됩니다.)</target>
        </trans-unit>
        <trans-unit id="8626117b5c558a6896256b03c3366c11dc83bf9f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; is a popular library for referencing JavaScript libraries with a Node-style synchronous require syntax. It&amp;rsquo;s often considered as an alternative to an AMD loader such as require.js. However Browserify solves a rather different problem: synchronous build-time reference resolution, rather than asynchronous runtime reference resolution as handled by AMD.</source>
          <target state="translated">&lt;a href=&quot;http://browserify.org/&quot;&gt;Browserify&lt;/a&gt; 는 노드 스타일 동기 요구 구문으로 JavaScript 라이브러리를 참조하는 데 널리 사용되는 라이브러리입니다. require.js와 같은 AMD 로더의 대안으로 종종 간주됩니다. 그러나 Browserify는 AMD가 처리하는 비동기 런타임 참조 해상도가 아닌 동기 빌드 시간 참조 해상도와는 다소 다른 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="b39766fa59a9837dc3c0076b5c0edc9947c018b2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ratelimit-observable&quot;&gt;rate-limited&lt;/a&gt; and &lt;a href=&quot;http://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;throttled&lt;/a&gt; computeds</source>
          <target state="translated">&lt;a href=&quot;ratelimit-observable&quot;&gt;속도 제한&lt;/a&gt; 및 &lt;a href=&quot;http://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;스로틀&lt;/a&gt; 계산</target>
        </trans-unit>
        <trans-unit id="1b4bb06f8e720378aa0ea6e2adc0ff799010ff99" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;ratelimit-observable&quot;&gt;rate-limited&lt;/a&gt; and &lt;a href=&quot;https://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;throttled&lt;/a&gt; computeds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799efd7655ba3b9889f9740fd0862be90bc93730" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to supply configurations programmatically based on names, e.g., to implement a naming convention.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;&lt;/strong&gt;예를 들어 이름 지정 규칙을 구현하기 위해 이름을 기반으로 프로그래밍 방식으로 구성을 제공하려는 &lt;strong&gt;경우이를 정의하십시오&lt;/strong&gt; .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a6212d983fffffd9e6209c49fa2c090cd3246f96" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to take control over how component configurations are interpreted, e.g., if you do not want to use the standard viewModel/template pair format.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;&lt;/strong&gt;예를 들어 표준 viewModel / template 쌍 형식을 사용하지 않으려는 경우 구성 요소 구성이 해석되는 방식을 제어하려는 &lt;strong&gt;경우이를 정의하십시오&lt;/strong&gt; .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a555c705767297e9a26aa2786f606e4bddfbdc4a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to use custom logic to supply DOM nodes for a given template configuration (e.g., using an ajax request to fetch a template by URL).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;&lt;/strong&gt;사용자 정의 로직을 사용하여 주어진 템플리트 구성에 대한 DOM 노드를 제공하려는 &lt;strong&gt;경우&lt;/strong&gt; (예 : URL로 템플리트를 페치하기 위해 ajax 요청 사용).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="42c134db8841f2566f885e08b68c5c8d619f2908" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Define this if:&lt;/strong&gt; you want to use custom logic to supply a viewmodel factory for a given viewmodel configuration (e.g., integrating with a third-party module loader or dependency injection system).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;&lt;/strong&gt;사용자 정의 로직을 사용하여 주어진 뷰 모델 구성에 대한 뷰 모델 팩토리를 제공하려는 &lt;strong&gt;경우&lt;/strong&gt; (예 : 타사 모듈 로더 또는 종속성 주입 시스템과 통합).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="951a4f2777566b4db649df1913890afa95d9199f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Beginners don&amp;rsquo;t need to know about this, but more advanced developers will want to know why we keep making all these claims about KO automatically tracking dependencies and updating the right parts of the UI&amp;hellip;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;초보자는 이것에 대해 알 필요는 없지만 고급 개발자는 KO에 대한 이러한 모든 주장을 자동으로 종속성을 추적하고 UI의 올바른 부분을 업데이트하는 이유를 알고 싶어합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fa952fc0ed2f794d316a68b12bbe7feaad64baf2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Beginners may wish to skip this section - writable computed observables are fairly advanced and are not necessary in most situations&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;초보자는이 섹션을 건너 뛰고 싶을 수도 있습니다. 쓰기 가능한 계산 된 관측 가능 개체는 상당히 발전되어 있으며 대부분의 상황에서 필요하지 않습니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b05d71845457c0f57f5c46e823954aa6b0676cbf" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Deferred&lt;/em&gt; &amp;ndash; Notifications happen asynchronously, immediately after the current task and generally before any UI redraws.</source>
          <target state="translated">&lt;em&gt;지연&lt;/em&gt; &amp;ndash; 알림은 현재 작업 직후 및 일반적으로 UI 다시 그리기 전에 비동기식으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1a3eb4911a7639fdbf44236533a918c6726b8746" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Model-View-View Model (MVVM)&lt;/em&gt; is a design pattern for building user interfaces. It describes how you can keep a potentially sophisticated UI simple by splitting it into three parts:</source>
          <target state="translated">&lt;em&gt;MVVM (Model-View-View Model)&lt;/em&gt; 은 사용자 인터페이스를 구축하기위한 디자인 패턴입니다. 잠재적으로 정교한 UI를 세 부분으로 나누어 단순하게 유지하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8d5d07f2734b6af11f85414b793aa7ddf201eb11" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Native templating&lt;/em&gt; is the mechanism that underpins foreach, if, with, and other control flow bindings. Internally, those control flow bindings capture the HTML markup contained in your element, and use it as a template to render against an arbitrary data item. This feature is built into Knockout and doesn&amp;rsquo;t require any external library.</source>
          <target state="translated">&lt;em&gt;기본 템플릿&lt;/em&gt; 은 foreach, if, with 및 기타 제어 흐름 바인딩을 지원하는 메커니즘입니다. 내부적으로 이러한 제어 흐름 바인딩은 요소에 포함 된 HTML 태그를 캡처하고이를 임의의 데이터 항목에 대해 렌더링하기위한 템플릿으로 사용합니다. 이 기능은 녹아웃에 내장되어 있으며 외부 라이브러리가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62995f07b684cd1e442b8e8983d90777e3520707" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: As an alternative, it&amp;rsquo;s possible to implement a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt; that fetches components by your own conventions instead of explicit configuration.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : 대안 으로 명시 적 구성 대신 사용자 고유의 규칙에 따라 컴포넌트를 가져 오는 &lt;a href=&quot;component-loaders&quot;&gt;사용자 정의 컴포넌트 로더&lt;/a&gt; 를 구현할 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d338d1a1dd37312fe044a380c3ea1d735e815b63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This documentation applies to Knockout 3.4.0 and later. For previous versions, the &lt;a href=&quot;https://github.com/mbest/knockout-deferred-updates&quot;&gt;Deferred Updates&lt;/a&gt; plugin provides similar support.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 :이 설명서는 Knockout 3.4.0 이상에 적용됩니다. 이전 버전의 경우 &lt;a href=&quot;https://github.com/mbest/knockout-deferred-updates&quot;&gt;Deferred Updates&lt;/a&gt; 플러그인은 유사한 지원을 제공합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62498b02454097b103305de14b9e278671df1dae" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This documentation applies to Knockout 3.4.0 and later.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 :이 설명서는 Knockout 3.4.0 이상에 적용됩니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e8a670cb7b1ce7328b8161c795abd85a6da3f03b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This feature, introduced in Knockout 3.5.0, is experimental, and may change in future versions.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a452d27c97bc5cb3c05b0a492913c856dfecc7e2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This is an advanced technique, typically used only when creating libraries of reusable bindings or extended syntaxes. It&amp;rsquo;s not something you&amp;rsquo;ll normally need to do when building applications with Knockout.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : 이것은 고급 기술이며 일반적으로 재사용 가능한 바인딩 또는 확장 구문의 라이브러리를 작성할 때만 사용됩니다. Knockout으로 애플리케이션을 빌드 할 때 일반적으로해야 할 일은 아닙니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d10f8fcc7959551d54bb29ecb4d9c7d6381a396c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This is an advanced technique, typically used only when creating libraries of reusable bindings. It&amp;rsquo;s not something you&amp;rsquo;ll normally need to do when building applications with Knockout.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : 이것은 고급 기술이며 일반적으로 재사용 가능한 바인딩 라이브러리를 작성할 때만 사용됩니다. Knockout으로 애플리케이션을 빌드 할 때 일반적으로해야 할 일은 아닙니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="13a617cb2c3f39c989433be077da2528155d2c63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This rate-limit API was added in Knockout 3.1.0. For previous versions, the &lt;a href=&quot;http://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;throttle extender&lt;/a&gt; provides similar functionality.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 :이 속도 제한 API는 Knockout 3.1.0에서 추가되었습니다. 이전 버전의 경우 &lt;a href=&quot;http://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;스로틀 익스텐더&lt;/a&gt; 는 유사한 기능을 제공합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9f07301b891a79e640658b5d5f6382bfcb281196" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: This rate-limit API was added in Knockout 3.1.0. For previous versions, the &lt;a href=&quot;https://knockoutjs.com/documentation/throttle-extender.html&quot;&gt;throttle extender&lt;/a&gt; provides similar functionality.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68ff05c21394b3c8fde74181447625b3f4a3c9c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Pure&lt;/em&gt; computed observables</source>
          <target state="translated">&lt;em&gt;순수한&lt;/em&gt; 계산 된 관측 가능</target>
        </trans-unit>
        <trans-unit id="a8a339e267cfb8f1a5acc964a91f6bddd68f8c55" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Pure&lt;/em&gt; computed observables work slightly differently. For more details, see the documentation for &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed observables&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;순수한&lt;/em&gt; 계산 된 관측 가능 항목은 약간 다르게 작동합니다. 자세한 내용은 &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;순수&lt;/em&gt; 계산 된 관찰 가능&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d78dec7911bd8203863417e869cad05a283e2aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Pure&lt;/em&gt; computed observables, introduced in Knockout 3.2.0, provide performance and memory benefits over regular computed observables for most applications. This is because a &lt;em&gt;pure&lt;/em&gt; computed observable doesn&amp;rsquo;t maintain subscriptions to its dependencies when it has no subscribers itself. This feature:</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;Knockout 3.2.0에 도입 된 &lt;em&gt;순수&lt;/em&gt; 계산 옵저버 블은 대부분의 응용 프로그램에서 일반 계산 옵저버 블에 비해 성능 및 메모리 이점을 제공합니다. &lt;em&gt;순수한&lt;/em&gt; 계산 된 Observable은 구독자가없는 경우 해당 종속성에 대한 구독을 유지하지 않기 때문 입니다. 이 기능 :</target>
        </trans-unit>
        <trans-unit id="874de401496e2450d62370c0489d8134a4680445" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Rate-limited&lt;/em&gt; &amp;ndash; Notifications happen after the specified period of time (a minimum of 2-10 ms depending on the browser).</source>
          <target state="translated">&lt;em&gt;속도 제한&lt;/em&gt; &amp;ndash; 지정된 기간이 지나면 알림이 발생합니다 (브라우저에 따라 최소 2-10ms).</target>
        </trans-unit>
        <trans-unit id="e9fb2be0abb789016ac0a5f7e66231b360cba479" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Standard&lt;/em&gt; &amp;ndash; Notifications happen immediately and synchronously. Dependencies are often notified of intermediate values.</source>
          <target state="translated">&lt;em&gt;표준&lt;/em&gt; &amp;ndash; 알림이 즉시 및 동 기적으로 발생합니다. 의존성에는 종종 중간 값이 통보됩니다.</target>
        </trans-unit>
        <trans-unit id="a530af1836dfa7520cbd67286036f07b4d5db232" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;String-based templating&lt;/em&gt; is a way to connect Knockout to a third-party template engine. Knockout will pass your model values to the external template engine and inject the resulting markup string into your document. See below for examples that use the &lt;em&gt;jquery.tmpl&lt;/em&gt; and &lt;em&gt;Underscore&lt;/em&gt; template engines.</source>
          <target state="translated">&lt;em&gt;문자열 기반 템플릿&lt;/em&gt; 은 녹아웃을 타사 템플릿 엔진에 연결하는 방법입니다. 녹아웃은 모델 값을 외부 템플릿 엔진으로 전달하고 결과 마크 업 문자열을 문서에 삽입합니다. &lt;em&gt;jquery.tmpl&lt;/em&gt; 및 &lt;em&gt;Underscore&lt;/em&gt; 템플릿 엔진 을 사용하는 예는 아래를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="95d18c945a954e5590e42b342e105bd6d20d1a6e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This advanced technique for working with observables was added in Knockout 3.5.&lt;/em&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89db5d2a0f4af59a6f45fb25a27d621ea08d0a1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Writes&lt;/em&gt; to observables are not delayed; the observable&amp;rsquo;s value is updated right away. For writable computed observables, this means that the write function is always run right away.</source>
          <target state="translated">&lt;em&gt;&lt;/em&gt;관찰 가능 항목에 대한 &lt;em&gt;쓰기&lt;/em&gt; 는 지연되지 않습니다. 관찰 가능 값이 즉시 업데이트됩니다. 쓰기 가능한 계산 된 관측 가능 개체의 경우 쓰기 기능이 항상 즉시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="976802e52d04d57e933efed69813c57bdea15efe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;You won&amp;rsquo;t normally need to set up subscriptions manually, so beginners should skip this section.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;일반적으로 구독을 수동으로 설정할 필요가 없으므로 초보자는이 섹션을 건너 뛰어야합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d6f4cea10f713ca2c89ae228e3ad371071a148e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/SteveSanderson/knockout.mapping/tree/master/build/output&quot;&gt;Version 2.0&lt;/a&gt;&lt;/strong&gt; (8.6kb minified)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/SteveSanderson/knockout.mapping/tree/master/build/output&quot;&gt;버전 2.0&lt;/a&gt;&lt;/strong&gt; (8.6kb 축소)</target>
        </trans-unit>
        <trans-unit id="9fc9b0f2bd6f8643b58e34e7531e60e824fddf5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/strong&gt; It&amp;rsquo;s best to use this extensibility point only for custom functions that are truly applicable in a wide range of scenarios. You don&amp;rsquo;t need to add a custom function to these namespaces if you&amp;rsquo;re only planning to use it once.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;참고 :&lt;/em&gt;&lt;/strong&gt; 이 확장 점은 광범위한 시나리오에 실제로 적용 할 수있는 사용자 정의 기능에 대해서만 사용하는 것이 가장 좋습니다. 한 번만 사용하려는 경우 이러한 네임 스페이스에 사용자 지정 함수를 추가 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="af169da745a1392a07e007770b35a87197553011" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Browser event quirks handling&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;브라우저 이벤트 문제 처리&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4642b89f0bf9cae05827d33f0e6b50627671416f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Can be added on top of your existing web application&lt;/strong&gt; without requiring major architectural changes</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;주요 아키텍처 변경없이 &lt;strong&gt;기존 웹 애플리케이션 위에 추가 가능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3f22e14067daefd1c483604455b05ad6c16fab03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Compact&lt;/strong&gt; - around 13kb after gzipping</source>
          <target state="translated">&lt;strong&gt;소형&lt;/strong&gt; -gzipping 후 약 13kb</target>
        </trans-unit>
        <trans-unit id="21be6783f2642d52a3544838078409e490d219d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Components&lt;/strong&gt; are a powerful, clean way of organizing your UI code into self-contained, reusable chunks. They:</source>
          <target state="translated">&lt;strong&gt;컴포넌트&lt;/strong&gt; 는 UI 코드를 독립적이고 재사용 가능한 덩어리로 구성하는 강력하고 깔끔한 방법입니다. 그들:</target>
        </trans-unit>
        <trans-unit id="67202d2d955236aa4dfeac5729c2f6c4ab70604a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Comprehensive suite of specifications&lt;/strong&gt; (developed BDD-style) means its correct functioning can easily be verified on new browsers and platforms</source>
          <target state="translated">&lt;strong&gt;포괄적 인 사양 세트&lt;/strong&gt; (개발 된 BDD 스타일)는 새로운 브라우저 및 플랫폼에서 올바른 기능을 쉽게 확인할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="fe040890c716ea22696a8f2b6f9be7582d520286" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Custom elements&lt;/strong&gt; are an optional but convenient syntax for consuming components. Instead of needing placeholder &amp;lt;div&amp;gt;s into which components are injected with bindings, you can use more self-descriptive markup with custom element names (e.g., &amp;lt;voting-button&amp;gt; or &amp;lt;product-editor&amp;gt;). Knockout takes care to ensure compatibility even with old browsers such as IE 6.</source>
          <target state="translated">&lt;strong&gt;사용자 정의 요소&lt;/strong&gt; 는 선택 사항이지만 구성 요소 소비를위한 편리한 구문입니다. 구성 요소에 바인딩이 삽입 된 자리 표시 자 &amp;lt;div&amp;gt;가 필요하지 않고 사용자 지정 요소 이름 (예 : &amp;lt;voting-button&amp;gt; 또는 &amp;lt;product-editor&amp;gt;)을 사용하여보다 자기 표현적인 마크 업을 사용할 수 있습니다. Knockout은 IE 6과 같은 오래된 브라우저와도 호환되도록주의합니다.</target>
        </trans-unit>
        <trans-unit id="14acee7d825a2fe41e8bcf0a2ee1b89a69b3b6a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Declarative bindings&lt;/strong&gt; - a simple and obvious way to connect parts of your UI to your data model. You can construct a complex dynamic UIs easily using arbitrarily nested binding contexts.</source>
          <target state="translated">&lt;strong&gt;선언적 바인딩&lt;/strong&gt; -UI의 일부를 데이터 모델에 연결하는 간단하고 확실한 방법입니다. 임의로 중첩 된 바인딩 컨텍스트를 사용하여 복잡한 동적 UI를 쉽게 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="990b12697bf051a85eebd23ba9e0305e64003986" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Elegant dependency tracking&lt;/strong&gt; - automatically updates the right parts of your UI whenever your data model changes.</source>
          <target state="translated">&lt;strong&gt;우아한 종속성 추적&lt;/strong&gt; -데이터 모델이 변경 될 때마다 UI의 올바른 부분을 자동으로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="2c47af57f11ec324216f4b036c02f4d8a8dd1885" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Full syntax&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;전체 구문&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd14d38224fd44da0d36469b3026a46c9a2a53c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If the component has a viewmodel, it is instantiated&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;구성 요소에 뷰 모델이 있으면 인스턴스화됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="853557afd32cc4840ee8b113330eee7c54353605" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Immediate updates&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;즉각적인 업데이트&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="005d93bacec0cddafeed676ed8ea8668552bc146" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Internet Explorer 6 to 8&lt;/strong&gt; also supports custom elements, &lt;em&gt;but only if they are registered before the HTML parser encounters any of those elements&lt;/em&gt;.</source>
          <target state="translated">&lt;strong&gt;Internet Explorer 6 ~ 8&lt;/strong&gt; 도 사용자 지정 요소를 지원 &lt;em&gt;하지만 HTML 파서가 해당 요소를 만나기 전에 등록 된 경우에만 가능합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="dd066585f0b991d7b67e9c322cf8b29f5934ed43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Knockout does not interpret the module name&lt;/strong&gt; in any way - it merely passes it through to require(). So of course Knockout does not know or care about where your module files are loaded from. That&amp;rsquo;s up to your AMD loader and how you&amp;rsquo;ve configured it.</source>
          <target state="translated">&lt;strong&gt;녹아웃은&lt;/strong&gt; 어떤 식 으로든 &lt;strong&gt;모듈 이름&lt;/strong&gt; 을 &lt;strong&gt;해석하지 않습니다.&lt;/strong&gt; 단지 &lt;strong&gt;모듈 이름&lt;/strong&gt; 을 require ()로 전달합니다. 물론 Knockout은 모듈 파일이 어디서로드되는지 알지 못합니다. 그것은 AMD 로더와 구성 방법에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="b14afc719747032408502f996f8253babcf10125" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Knockout doesn&amp;rsquo;t know or care whether your AMD modules are anonymous or not&lt;/strong&gt;. Typically we find it&amp;rsquo;s most convenient for components to be defined as anonymous modules, but that concern is entirely separate from KO.</source>
          <target state="translated">&lt;strong&gt;Knockout은 AMD 모듈이 익명인지 여부를 알거나 신경 쓰지 않습니다&lt;/strong&gt; . 일반적으로 구성 요소를 익명 모듈로 정의하는 것이 가장 편리하지만이 문제는 KO와 완전히 별개입니다.</target>
        </trans-unit>
        <trans-unit id="7623301b20fba50846d11ffcff0175e2f950b534" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Native templating&lt;/strong&gt; does not require any library other than Knockout itself</source>
          <target state="translated">&lt;strong&gt;기본 템플릿&lt;/strong&gt; 에는 녹아웃 이외의 라이브러리가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cce7f1297a779b792b0890892033a0603eadd234" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Normally, you&amp;rsquo;d load the view model and template from external files&lt;/strong&gt; instead of declaring them inline like this. We&amp;rsquo;ll get to that later.</source>
          <target state="translated">&lt;strong&gt;일반적으로 뷰 파일과 템플릿을&lt;/strong&gt; 인라인으로 선언하는 대신 &lt;strong&gt;외부 파일에서로드합니다&lt;/strong&gt; . 나중에 다시 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="9547e2cb901643dbdb78d8aee63e0abb0b96ab2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For such trivial requirements as validating that an input is numeric, this technique is overkill. It would be far easier just to use jQuery Validation and its number class on the &amp;lt;input&amp;gt; element. Knockout and jQuery Validation work together nicely, as demonstrated on the &lt;a href=&quot;http://knockoutjs.com/examples/gridEditor.html&quot;&gt;grid editor&lt;/a&gt; example. However, the preceding example demonstrates a more general mechanism for filtering and validating with custom logic to control what kind of user feedback appears, which may be of use if your scenario is more complex than jQuery Validation handles natively.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 입력이 숫자인지 확인하는 것과 같은 간단한 요구 사항의 경우이 기술은 과도합니다. &amp;lt;input&amp;gt; 요소에서 jQuery Validation과 해당 숫자 클래스를 사용하는 것이 훨씬 쉬울 것입니다. Knockout과 jQuery Validation은 &lt;a href=&quot;http://knockoutjs.com/examples/gridEditor.html&quot;&gt;그리드 편집기&lt;/a&gt; 예제 에서 설명한 것처럼 훌륭하게 작동합니다 . 그러나 앞의 예제는 사용자 정의 로직으로 필터링하고 유효성을 검사하여 어떤 종류의 사용자 피드백이 나타나는지 제어하는보다 일반적인 메커니즘을 보여줍니다.이 시나리오는 jQuery 유효성 검사가 기본적으로 처리하는 것보다 복잡한 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b19719b50b1d1146b5c1b9e976c239dc581c1e36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For such trivial requirements as validating that an input is numeric, this technique is overkill. It would be far easier just to use jQuery Validation and its number class on the &amp;lt;input&amp;gt; element. Knockout and jQuery Validation work together nicely, as demonstrated on the &lt;a href=&quot;https://knockoutjs.com/examples/gridEditor.html&quot;&gt;grid editor&lt;/a&gt; example. However, the preceding example demonstrates a more general mechanism for filtering and validating with custom logic to control what kind of user feedback appears, which may be of use if your scenario is more complex than jQuery Validation handles natively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2c1d2bdf3c7252f3d741539a13c27876814e6d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; These callbacks are &lt;em&gt;only&lt;/em&gt; intended for triggering animations related to changes in a list. If your goal is actually to attach other behaviors to new DOM elements when they have been added (e.g., event handlers, or to activate third-party UI controls), then your work will be much easier if you implement that new behavior as a &lt;a href=&quot;custom-bindings&quot;&gt;custom binding&lt;/a&gt; instead, because then you can use that behavior anywhere, independently of the foreach binding.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 콜백이되는 &lt;em&gt;경우에만&lt;/em&gt; 목록의 변경에 관한 애니메이션을 트리거위한 것. 목표가 실제로 추가 될 때 다른 동작을 새로운 DOM 요소 (예 : 이벤트 처리기 또는 타사 UI 컨트롤 활성화)에 연결하려는 경우, 새로운 동작을 &lt;a href=&quot;custom-bindings&quot;&gt;사용자 지정&lt;/a&gt; 으로 구현하면 작업이 훨씬 쉬워집니다 바인딩 다음 독립적으로 바인딩의 foreach의 어디 그 동작을 사용할 수 있기 때문에, 대신.</target>
        </trans-unit>
        <trans-unit id="8cf6a6684f50f3ea7a170aa3398f4403873e6036" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Parameters:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Parameters:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="96f242a46391269bfbcea22f170fb9153b44f393" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Prevents memory leaks&lt;/strong&gt; from computed observables that are no longer referenced in an application but whose dependencies still exist.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;더 이상 응용 프로그램에서 참조되지 않지만 종속성이 여전히 존재하는 계산 된 관찰 가능 &lt;strong&gt;개체의 메모리 누수&lt;/strong&gt; 를 &lt;strong&gt;방지&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="5af02e14314a6af73700df96c09743c910918af4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pure JavaScript library&lt;/strong&gt; - works with any server or client-side technology</source>
          <target state="translated">&lt;strong&gt;순수 JavaScript 라이브러리&lt;/strong&gt; -모든 서버 또는 클라이언트 측 기술과 호환</target>
        </trans-unit>
        <trans-unit id="65b27346b30be7b0a4f38908addd9e6f4370dbcc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Reduces computation overhead&lt;/strong&gt; by not re-calculating computed observables whose value isn&amp;rsquo;t being observed.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;값이 관찰되지 않는 계산 된 관측 가능 객체를 다시 계산하지 않음으로써 &lt;strong&gt;계산 오버 헤드&lt;/strong&gt; 를 &lt;strong&gt;줄&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="36974a86b9014bdc65e78c9d0ffe9aae3425befe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Requirements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Requirements&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="38b847315206d412de961c02dd15d22a61454dd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Return value&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;반환 값&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="538d30d06518081cbff7ad599fc04c913bb63f0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Shorthand syntax&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;속기 구문&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c03113c1df32711c668bb01816e62caf66f8cf31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;String-based templating&lt;/strong&gt; works only once you&amp;rsquo;ve referenced a suitable template engine, such as jQuery.tmpl or the Underscore template engine.</source>
          <target state="translated">&lt;strong&gt;문자열 기반 템플릿&lt;/strong&gt; 은 jQuery.tmpl 또는 Underscore 템플릿 엔진과 같은 적합한 템플릿 엔진을 참조한 후에 만 ​​작동합니다.</target>
        </trans-unit>
        <trans-unit id="01f4687a04e08868399938b56a400b5cef0e8132" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Subscriptions&lt;/strong&gt; to observables continue to fire until explicitly disposed.</source>
          <target state="translated">&lt;strong&gt;옵저버&lt;/strong&gt; 블 &lt;strong&gt;구독&lt;/strong&gt; 은 명시 적으로 폐기 될 때까지 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="32f777cc20c7769740052cd86dadccf8d489dfd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The component is active&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;구성 요소가 활성화되었습니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7395eabba8d626f204fa038e96ea461092ce9a5e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The component is torn down, and the viewmodel is disposed&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;구성 요소가 분해되고 뷰 모델이 배치됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b6f57d0a651bb6db8d366391beeb0328a19e7be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The component template is cloned and injected into the container element&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;구성 요소 템플릿이 복제되어 컨테이너 요소에 주입됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="82e6e92787d7eb666a8b10c3b0f889e56b7acf80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The viewmodel is bound to the view&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;뷰 모델이 뷰에 바인딩됩니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6460afbcbb4cbdec561841a248ba1e6424d666a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This does not take a strict dependency on &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;&lt;/strong&gt; or any other particular module loader. &lt;em&gt;Any&lt;/em&gt; module loader that provides an AMD-style require API will do. If you want to integrate with a module loader whose API is different, you can implement a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;&lt;/strong&gt; 또는 다른 특정 모듈 로더 &lt;strong&gt;에 대한 엄격한 종속성을 갖지 않습니다&lt;/strong&gt; . AMD 스타일의 요구 API를 제공하는 &lt;em&gt;모든&lt;/em&gt; 모듈 로더가 수행합니다. API가 다른 모듈 로더와 통합하려는 경우 &lt;a href=&quot;component-loaders&quot;&gt;사용자 정의 컴포넌트 로더를&lt;/a&gt; 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c04dcd21b22096736da7955495e67376657beed6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Trivially extensible&lt;/strong&gt; - implement custom behaviors as new declarative bindings for easy reuse in just a few lines of code.</source>
          <target state="translated">&lt;strong&gt;간단하게 확장 가능&lt;/strong&gt; -몇 줄의 코드에서 쉽게 재사용 할 수 있도록 사용자 지정 동작을 새로운 선언적 바인딩으로 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f0992ab4728f88b2a84a0b8caa835c1cf39986f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using the component&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;구성 요소 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32cbc5d0a2b4f65ca0027e1ba199cc25d7d8a11a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why is component loading normally forced to be asynchronous?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;컴포넌트 로딩이 보통 비동기식으로 강제되는 이유는 무엇입니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="efa66cf89ab1790c16c3bd2f001aebe35bb73112" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why would you ever enable synchronous loading?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;동기식 로딩을 활성화 한 이유는 무엇입니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e6f570eaf052941ca34607e3a4699d3fedd619ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Works on any mainstream browser&lt;/strong&gt; (IE 6+, Firefox 2+, Chrome, Safari, Edge, others)</source>
          <target state="translated">&lt;strong&gt;모든 주류 브라우저&lt;/strong&gt; (IE 6+, Firefox 2+, Chrome, Safari, Edge 등)에서 작동</target>
        </trans-unit>
        <trans-unit id="b78c43aa7b941a0cf5c09e85ba15c220598279bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Your component loaders are asked to supply the viewmodel factory and template&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;컴포넌트 로더는 뷰 모델 팩토리 및 템플리트를 제공하도록 요청받습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="96c74267b4a56b3e028b9afdd40d0fafdfcfdcb9" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;binding context&lt;/em&gt; is an object that holds data that you can reference from your bindings. While applying bindings, Knockout automatically creates and manages a hierarchy of binding contexts. The root level of the hierarchy refers to the viewModel parameter you supplied to ko.applyBindings(viewModel). Then, each time you use a control flow binding such as &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; or &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;, that creates a child binding context that refers to the nested view model data.</source>
          <target state="translated">&lt;em&gt;바인딩 컨텍스트는&lt;/em&gt; 당신이 당신의 바인딩에서 참조 할 수있는 데이터를 보유하는 객체입니다. 바인딩을 적용하는 동안 Knockout은 바인딩 컨텍스트의 계층 구조를 자동으로 생성하고 관리합니다. 계층의 루트 수준은 ko.applyBindings (viewModel)에 제공 한 viewModel 매개 변수를 나타냅니다. 그런 다음 &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; 또는 &lt;a href=&quot;foreach-binding&quot;&gt;foreach &lt;/a&gt;와 같은 제어 플로우 바인딩을 사용할 때마다 중첩 된 뷰 모델 데이터를 참조하는 하위 바인딩 컨텍스트가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="f4a248fb269bbbb88f6088e277f3883569cefc2a" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;model&lt;/em&gt;: your application&amp;rsquo;s stored data. This data represents objects and operations in your business domain (e.g., bank accounts that can perform money transfers) and is independent of any UI. When using KO, you will usually make Ajax calls to some server-side code to read and write this stored model data.</source>
          <target state="translated">&lt;em&gt;모델&lt;/em&gt; : 응용 프로그램의 저장된 데이터. 이 데이터는 비즈니스 도메인의 개체 및 작업 (예 : 송금을 수행 할 수있는 은행 계좌)을 나타내며 UI와 무관합니다. KO를 사용할 때는 일반적으로이 저장된 모델 데이터를 읽고 쓰기 위해 일부 서버 측 코드를 Ajax 호출합니다.</target>
        </trans-unit>
        <trans-unit id="672cec499a5e1f1cee87a332d86b3b33abc231fe" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;pure&lt;/em&gt; computed observable automatically switches between two states based on whether it has change subscribers.</source>
          <target state="translated">&lt;em&gt;순수한&lt;/em&gt; 계산 관찰은 자동으로 변경 가입자가 있는지 여부에 기초하여 두 상태 사이에서 전환한다.</target>
        </trans-unit>
        <trans-unit id="59bc15f49d66eaa773779760f79faa3fa9423729" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;view model&lt;/em&gt;: a pure-code representation of the data and operations on a UI. For example, if you&amp;rsquo;re implementing a list editor, your view model would be an object holding a list of items, and exposing methods to add and remove items.</source>
          <target state="translated">&lt;em&gt;보기 모델&lt;/em&gt; : 사용자 인터페이스의 데이터 및 운영의 순수한 코드 표현입니다. 예를 들어 목록 편집기를 구현하는 경우보기 모델은 항목 목록을 보유하고 항목을 추가 및 제거하는 메소드를 노출하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="eace4ec15816838615483a0f9f07130cd593dae7" translate="yes" xml:space="preserve">
          <source>A &lt;em&gt;view&lt;/em&gt;: a visible, interactive UI representing the state of the view model. It displays information from the view model, sends commands to the view model (e.g., when the user clicks buttons), and updates whenever the state of the view model changes.</source>
          <target state="translated">&lt;em&gt;보기&lt;/em&gt; : 뷰 모델의 상태를 나타내는 표시, 대화 형 UI. 뷰 모델의 정보를 표시하고 뷰 모델로 명령을 전송하고 (예 : 사용자가 버튼을 클릭 할 때) 뷰 모델의 상태가 변경 될 때마다 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="ca93da47b0c5a3da43e52690cd086f2e1a2ebd77" translate="yes" xml:space="preserve">
          <source>A DOM node being added to the document</source>
          <target state="translated">문서에 추가되는 DOM 노드</target>
        </trans-unit>
        <trans-unit id="d551d8332829826ecacd9fb849d14363184a926a" translate="yes" xml:space="preserve">
          <source>A DOM node that may be about to move</source>
          <target state="translated">움직일 수있는 DOM 노드</target>
        </trans-unit>
        <trans-unit id="6331cd6f9ebb43fddcf15dfc9b7fb432c2f730af" translate="yes" xml:space="preserve">
          <source>A DOM node that may have moved</source>
          <target state="translated">움직일 수있는 DOM 노드</target>
        </trans-unit>
        <trans-unit id="9a3f7e5611e70df33d8f227c6f7b7360a7dd399e" translate="yes" xml:space="preserve">
          <source>A DOM node that you should remove</source>
          <target state="translated">제거해야하는 DOM 노드</target>
        </trans-unit>
        <trans-unit id="73d257d4d5c6be661a1e19a48818fd69414e6730" translate="yes" xml:space="preserve">
          <source>A JavaScript object whose properties will be copied to the binding context for descendant elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fa9b23eb6c3fecb0a19eee9723a2f762712f465" translate="yes" xml:space="preserve">
          <source>A binding consists of two items, the binding &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt;, separated by a colon. Here is an example of a single, simple binding:</source>
          <target state="translated">바인딩은 바인딩 &lt;em&gt;이름&lt;/em&gt; 과 &lt;em&gt;값&lt;/em&gt; 의 두 항목으로 구성되며 콜론으로 구분됩니다. 다음은 단일 간단한 바인딩의 예입니다.</target>
        </trans-unit>
        <trans-unit id="b97f27c6008d5459bdb04cdb810c301f0271f67b" translate="yes" xml:space="preserve">
          <source>A computed observable can be constructed using one of the following forms:</source>
          <target state="translated">계산 된 관측 가능 객체는 다음 형식 중 하나를 사용하여 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b3c42d55504f21b1b9ff8c6dc937021d9e0fbbb" translate="yes" xml:space="preserve">
          <source>A computed observable provides the following functions:</source>
          <target state="translated">계산 된 관측 가능 기능은 다음 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ee2ee99b4fbef7f88d22ec53a5ac2485da3ddb43" translate="yes" xml:space="preserve">
          <source>A constructor function</source>
          <target state="translated">생성자 함수</target>
        </trans-unit>
        <trans-unit id="d421b1fb0fc49225f6485c171df52e5c3cf18816" translate="yes" xml:space="preserve">
          <source>A createViewModel factory function</source>
          <target state="translated">createViewModel 팩토리 함수</target>
        </trans-unit>
        <trans-unit id="3140686e93078602a724ffd63d00b2000a63120a" translate="yes" xml:space="preserve">
          <source>A custom component loader is simply an object whose properties are &lt;strong&gt;any combination&lt;/strong&gt; of the following functions:</source>
          <target state="translated">커스텀 컴포넌트 로더는 속성이 다음 함수의 &lt;strong&gt;조합&lt;/strong&gt; 인 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="875be908e85823e41220d8f215eb69acb7523ecf" translate="yes" xml:space="preserve">
          <source>A custom element can have a regular data-bind attribute (in addition to any params attribute) if needed. For example,</source>
          <target state="translated">사용자 정의 요소는 필요한 경우 일반 데이터 바인딩 속성 (params 속성 외에)을 가질 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="ed4ac8818951d35d2d4f2644dd9eaf887a755c40" translate="yes" xml:space="preserve">
          <source>A custom function that will handle the scheduling of notifications. For example, you could use Underscore&amp;rsquo;s throttle method: myObservable.extend({ rateLimit: { timeout: 500, method: _.throttle } }); For more details, see the section below on custom rate-limit methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbce704022becdf28532ea1454acbf19683d7755" translate="yes" xml:space="preserve">
          <source>A document fragment</source>
          <target state="translated">문서 조각</target>
        </trans-unit>
        <trans-unit id="a84827e1e80c6d853c30bc27f2185443890c1904" translate="yes" xml:space="preserve">
          <source>A popular convention that simplifies things</source>
          <target state="translated">일을 단순화하는 인기있는 규칙</target>
        </trans-unit>
        <trans-unit id="0fb40af78bc85a323dc4a804096a956f6e13aef0" translate="yes" xml:space="preserve">
          <source>A pure computed observable notifies an awake event (using its current value) whenever it enters the &lt;em&gt;listening&lt;/em&gt; state and notifies an asleep event (using an undefined value) whevener it enter the &lt;em&gt;sleeping&lt;/em&gt; state. You won&amp;rsquo;t normally need to know about the internal state of your computed observables. But since the internal state can correspond to whether the computed observable is bound to the view or not, you might use that information to do some view-model initialization or cleanup.</source>
          <target state="translated">그것은 입사마다 (현재 값을 사용하여) 계산 순수한 관찰 통지 웨이크 이벤트 &lt;em&gt;청취&lt;/em&gt; 가 입력 whevener 상태를 통지한다 (정의되지 않은 값을 사용하여)을 잠 사건 &lt;em&gt;수면&lt;/em&gt; 상태. 일반적으로 계산 된 관찰 가능 항목의 내부 상태에 대해 알 필요가 없습니다. 그러나 내부 상태는 계산 된 옵저버 블이 뷰에 바인딩되어 있는지 여부에 해당 할 수 있으므로 해당 정보를 사용하여 일부 뷰 모델 초기화 또는 정리를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d17d0e20bbc6723a6f53f7095e5b9e515f8490db" translate="yes" xml:space="preserve">
          <source>A pure computed observable notifies some events that allow you to respond to changes to the state of the observable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="219abd734eaa39b3e5af5d4aae85aae74f210ba7" translate="yes" xml:space="preserve">
          <source>A recommended AMD module pattern</source>
          <target state="translated">권장되는 AMD 모듈 패턴</target>
        </trans-unit>
        <trans-unit id="96a16d06ab9525707f973555c03a9a069b2890ef" translate="yes" xml:space="preserve">
          <source>A shared object instance</source>
          <target state="translated">공유 객체 인스턴스</target>
        </trans-unit>
        <trans-unit id="f05cd21e831a202875a8dffd0d37c25b82bec9e6" translate="yes" xml:space="preserve">
          <source>A simpler and more elegant option, however, is to use as to declare a name for your iteration variables. For example:</source>
          <target state="translated">그러나 더 단순하고 우아한 옵션은 반복 변수의 이름을 선언하는 데 as를 사용하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7c8841f5e8f9c936c29327e4d6733bdab3c12e1" translate="yes" xml:space="preserve">
          <source>A string of markup</source>
          <target state="translated">마크 업 문자열</target>
        </trans-unit>
        <trans-unit id="41a59868d9ef75167ce556f0565eb922f6cc31f5" translate="yes" xml:space="preserve">
          <source>A value that controls whether or not the associated DOM element should be enabled.</source>
          <target state="translated">연관된 DOM 요소의 사용 가능 여부를 제어하는 ​​값입니다.</target>
        </trans-unit>
        <trans-unit id="1629231a910c1a9903f050df95a79a00ff663fe9" translate="yes" xml:space="preserve">
          <source>AMD modules are loaded only on demand</source>
          <target state="translated">AMD 모듈은 요청시에만로드됩니다</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="dba104dad21c672e8d177c331e1988224ee9c40f" translate="yes" xml:space="preserve">
          <source>Activating Knockout</source>
          <target state="translated">녹아웃 활성화</target>
        </trans-unit>
        <trans-unit id="9e50bbf06486aad9ed5858d61f790ecc35cf4bdb" translate="yes" xml:space="preserve">
          <source>Adding custom functions using &quot;fn&quot;</source>
          <target state="translated">&quot;fn&quot;을 사용하여 사용자 정의 기능 추가</target>
        </trans-unit>
        <trans-unit id="5f55b709f75ff470666d48ed8e0dd3202f9462b3" translate="yes" xml:space="preserve">
          <source>Additional benefits:</source>
          <target state="translated">추가 혜택:</target>
        </trans-unit>
        <trans-unit id="d9ca1471a1c5c73c1eaf333a7d893c103077a28a" translate="yes" xml:space="preserve">
          <source>Additional parameters</source>
          <target state="translated">추가 매개 변수</target>
        </trans-unit>
        <trans-unit id="2eecc85d283c6cfc2c01cf8cf19d07776798fd03" translate="yes" xml:space="preserve">
          <source>Additionally, Knockout provides similar functions that can operate on observables and computed observables:</source>
          <target state="translated">또한 녹아웃은 관찰 가능 및 계산 된 관찰 가능 기능에서 작동 할 수있는 유사한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="69d691f44445960d684f25080c894d46d0ef6515" translate="yes" xml:space="preserve">
          <source>Advanced queue control</source>
          <target state="translated">고급 대기열 제어</target>
        </trans-unit>
        <trans-unit id="5126940d744a6dff391a643edf858b06f00785ed" translate="yes" xml:space="preserve">
          <source>Advanced usage</source>
          <target state="translated">고급 사용법</target>
        </trans-unit>
        <trans-unit id="bdafa12daa294233db606dc624e7cfa8736c4318" translate="yes" xml:space="preserve">
          <source>Advanced: Accessing $raw parameters</source>
          <target state="translated">고급 : $ raw 매개 변수에 액세스</target>
        </trans-unit>
        <trans-unit id="acb27fde407851516098c690ede0080b631c0f01" translate="yes" xml:space="preserve">
          <source>Advanced: Custom component loaders</source>
          <target state="translated">고급 : 사용자 컴포넌트 로더</target>
        </trans-unit>
        <trans-unit id="6b68add7c4ef423265bf6c36f75e07b61ca328f2" translate="yes" xml:space="preserve">
          <source>After you have defined the module update the input element from the HTML example above to be:</source>
          <target state="translated">모듈을 정의한 후 위 HTML 예제에서 입력 요소를 다음과 같이 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="329df29582c6ec3024bef034171a5a78bd9cbb39" translate="yes" xml:space="preserve">
          <source>Again, only the nodes &lt;em&gt;inside&lt;/em&gt; the specified element will be cloned for use as the component&amp;rsquo;s template.</source>
          <target state="translated">다시 말하지만 지정된 요소 &lt;em&gt;내의&lt;/em&gt; 노드 만 구성 요소의 템플릿으로 사용하기 위해 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="a9180eedfdd61587618067116c1c45385c35cb38" translate="yes" xml:space="preserve">
          <source>All change notifications are delayed, including when calling valueHasMutated manually. This means you can&amp;rsquo;t use valueHasMutated to force a rate-limited observable to notify an un-changed value.</source>
          <target state="translated">valueHasMutated를 수동으로 호출 할 때를 포함하여 모든 변경 알림이 지연됩니다. 즉, valueHasMutated를 사용하여 속도 제한 옵저버 블이 변경되지 않은 값을 알리도록 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1faff78215a2b42eb91a45b8356b4f79235b938d" translate="yes" xml:space="preserve">
          <source>All of these functions are equivalent to running the native JavaScript array functions on the underlying array, and then notifying listeners about the change:</source>
          <target state="translated">이러한 함수는 모두 기본 배열에서 기본 JavaScript 배열 함수를 실행 한 다음 변경 사항을 리스너에게 알리는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c9de1c05e289fb463cf3a1c26f4670e737ed411" translate="yes" xml:space="preserve">
          <source>All properties of an object are converted into an observable. If an update would change the value, it will update the observable.</source>
          <target state="translated">객체의 모든 속성은 관찰 가능 객체로 변환됩니다. 업데이트가 값을 변경하면 관찰 가능 항목을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="38c026ebda36ef4388e796344b3abce466922b2b" translate="yes" xml:space="preserve">
          <source>Also, randomOrder will still work with regular DOM elements, because all of the ko.virtualElements APIs are backwardly compatible with regular DOM elements.</source>
          <target state="translated">또한 모든 ko.virtualElements API는 이전 버전의 DOM 요소와 호환되므로 randomOrder는 여전히 일반 DOM 요소와 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8fda4896a6cfabf38010923d25545054759b05e1" translate="yes" xml:space="preserve">
          <source>Also, since ko.components.defaultLoader is a component loader, it implements the following standard component loader functions. You can invoke these directly, e.g., as part of your implementation of a custom loader:</source>
          <target state="translated">또한 ko.components.defaultLoader는 구성 요소 로더이므로 다음과 같은 표준 구성 요소 로더 기능을 구현합니다. 예를 들어, 사용자 정의 로더 구현의 일부로 직접 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4edfae09ecfcc29756a62316c12a008c591612f8" translate="yes" xml:space="preserve">
          <source>Also, you need to have referenced a suitable module loader library (such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;) or implemented a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt; that knows how to grab your files.</source>
          <target state="translated">또한 적합한 모듈 로더 라이브러리 (예 : &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt; )를 참조하거나 파일을 가져 오는 방법을 알고 있는 &lt;a href=&quot;component-loaders&quot;&gt;사용자 정의 컴포넌트 로더&lt;/a&gt; 를 구현 해야합니다.</target>
        </trans-unit>
        <trans-unit id="db4db8b9b399a9292d2681e94db2f56cc50be27a" translate="yes" xml:space="preserve">
          <source>Alternatively, components also support a direct method to receive a descendantsComplete notification. If your component view model has a koDescendantsComplete function, Knockout will call it with the component&amp;rsquo;s node once all descendants are bound. For example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b5cc861eaf7ac508de6b2b58d1ed770fee1e988" translate="yes" xml:space="preserve">
          <source>Alternatively, if you prefer to avoid the function literal in your view, you can use the &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;bind&lt;/a&gt; function, which attaches specific parameter values to a function reference:</source>
          <target state="translated">또는 뷰에서 함수 리터럴을 피하려면 &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Function/bind&quot;&gt;bind&lt;/a&gt; 매개 변수를 사용하여 특정 매개 변수 값을 함수 참조에 첨부 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa6e7ea09a57e761a9110c8a9df4784c24443111" translate="yes" xml:space="preserve">
          <source>Alternatively, pass a JavaScript object literal with a property called data which is the array you wish to iterate over. The object literal may also have other properties, such as afterAdd or includeDestroyed &amp;mdash; see below for details of these extra options and examples of their use.</source>
          <target state="translated">또는 반복하려는 배열 인 data라는 속성으로 JavaScript 객체 리터럴을 전달하십시오. 객체 리터럴에는 afterAdd 또는 includeDestroyed와 같은 다른 속성도있을 수 있습니다. 이러한 추가 옵션에 대한 자세한 내용과 사용 예는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b7dfbc21d336e304b1aefd8da00433e7d002f8f1" translate="yes" xml:space="preserve">
          <source>Alternatively, you can &lt;a href=&quot;#controlling-custom-element-tag-names&quot;&gt;override getComponentNameForNode&lt;/a&gt; to control dynamically which elements map to which component names, independently of preregistration.</source>
          <target state="translated">또는 &lt;a href=&quot;#controlling-custom-element-tag-names&quot;&gt;getComponentNameForNode&lt;/a&gt; 를 재정 의하여 사전 등록과 독립적으로 어떤 요소가 어떤 구성 요소 이름에 맵핑되는지 동적으로 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ae14a33d0421d469795c28cb8d6c7b5a300d1437" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use the pure option with ko.computed:</source>
          <target state="translated">또는 ko.computed와 함께 pure 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6881ab5fe1c9360a98b31b040fcb030610e5b9a" translate="yes" xml:space="preserve">
          <source>Alternatively, you don&amp;rsquo;t need to create a computed observable if you&amp;rsquo;re doing something simple like this. You can pass an arbitrary JavaScript expression to the text binding. For example,</source>
          <target state="translated">또는 이와 같은 간단한 작업을 수행하는 경우 계산 된 관찰 가능 객체를 만들 필요가 없습니다. 텍스트 바인딩에 임의의 JavaScript 표현식을 전달할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="467b199c0d9c0c472351991602cecc7ed24eedcf" translate="yes" xml:space="preserve">
          <source>Although deferred, asynchronous notifications are generally better because of fewer UI updates, it can be a problem if you need to update the UI immediately. Sometimes, for proper functionality, you need an intermediate value pushed to the UI. You can accomplish this using the &lt;a href=&quot;microtasks#advanced-queue-control&quot;&gt;ko.tasks.runEarly method&lt;/a&gt;. For example:</source>
          <target state="translated">지연된 알림이지만 일반적으로 UI 업데이트가 적기 때문에 비동기 알림이 더 낫지 만 UI를 즉시 업데이트해야하는 경우 문제가 될 수 있습니다. 때로는 올바른 기능을 위해 중간 값을 UI로 푸시해야합니다. &lt;a href=&quot;microtasks#advanced-queue-control&quot;&gt;ko.tasks.runEarly 메소드를&lt;/a&gt; 사용하여이를 수행 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cccda6b76e9fe36a78cbb8b19672fab53b808ae3" translate="yes" xml:space="preserve">
          <source>Although the &lt;a href=&quot;value-binding&quot;&gt;value binding&lt;/a&gt; can also perform two-way binding between text boxes and viewmodel properties, you should prefer textInput whenever you want immediate live updates. The main differences are:</source>
          <target state="translated">&lt;a href=&quot;value-binding&quot;&gt;값 바인딩&lt;/a&gt; 은 텍스트 상자와 뷰 모델 속성간에 양방향 바인딩을 수행 할 수 있지만 즉시 실시간 업데이트를 원할 때마다 textInput을 선호해야합니다. 주요 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="54e9247f8574a1aa66c8291b2a6f5cecfef75b1e" translate="yes" xml:space="preserve">
          <source>Although the DOM nodes in this element will be stripped out and not bound by default, they are not lost. Instead, they are supplied to the component (in this case, my-special-list), which can include them in its output however it wishes.</source>
          <target state="translated">이 요소의 DOM 노드는 기본적으로 제거되고 바인딩되지 않지만 손실되지는 않습니다. 대신, 컴포넌트 (이 경우에는 my-special-list)에 제공되며 원하는대로 출력에 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="065f5f46184d6f9b66cb0337f9c8985d191e4c55" translate="yes" xml:space="preserve">
          <source>Although you can subscribe to and access an observableArray just like any other observable, Knockout also provides a super-fast method to find out how an observable array has changed (i.e., which items were just added, deleted, or moved). You subscribe to array changes as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c64e2a25f4ecdbf890fa878004386d735536f164" translate="yes" xml:space="preserve">
          <source>An AMD module whose value describes a template</source>
          <target state="translated">템플릿을 설명하는 값을 가진 AMD 모듈</target>
        </trans-unit>
        <trans-unit id="e68eb6e1b6701b3c386d6f393c8c2332fcca13e2" translate="yes" xml:space="preserve">
          <source>An AMD module whose value describes a viewmodel</source>
          <target state="translated">뷰 모델을 설명하는 AMD 모듈</target>
        </trans-unit>
        <trans-unit id="242417090831cde58cc194cc22ae4eab474f143d" translate="yes" xml:space="preserve">
          <source>An array of DOM nodes</source>
          <target state="translated">DOM 노드의 배열</target>
        </trans-unit>
        <trans-unit id="968a4f61a70888dd1fa2a0eb32b82dc937a8263d" translate="yes" xml:space="preserve">
          <source>An array of the inserted DOM elements</source>
          <target state="translated">삽입 된 DOM 요소의 배열</target>
        </trans-unit>
        <trans-unit id="677bc5c11af17aad4286438791881da11106a6b3" translate="yes" xml:space="preserve">
          <source>An element can include multiple bindings (related or unrelated), with each binding separated by a comma. Here are some examples:</source>
          <target state="translated">요소에는 여러 바인딩 (관련 또는 관련되지 않음)이 포함될 수 있으며 각 바인딩은 쉼표로 구분됩니다. 여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="4d626c0f133638f459d4ffb6d3a56ba114d6d9ce" translate="yes" xml:space="preserve">
          <source>An existing element ID</source>
          <target state="translated">기존 요소 ID</target>
        </trans-unit>
        <trans-unit id="e36639c5e653a711057a5a79fa2fd56cc32a4737" translate="yes" xml:space="preserve">
          <source>An existing element instance</source>
          <target state="translated">기존 요소 인스턴스</target>
        </trans-unit>
        <trans-unit id="f48281418a421e56b65e2f335f96fc8ee14c0591" translate="yes" xml:space="preserve">
          <source>An object whose keys determine which bindings are usable with virtual elements. Set ko.virtualElements.allowedBindings.mySuperBinding = true to allow mySuperBinding to be used with virtual elements.</source>
          <target state="translated">키가 가상 요소에 사용할 수있는 바인딩을 결정하는 오브젝트입니다. mySuperBinding을 가상 요소와 함께 사용할 수 있도록 ko.virtualElements.allowedBindings.mySuperBinding = true로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="dd15fd1ba5ddf1cc618917899b23e48ea396d2d4" translate="yes" xml:space="preserve">
          <source>An observableArray has array tracking enabled at construction, but you can extend any other subscribable (i.e. ko.observable and ko.computed) as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="750e1b4a97e09ed466c53a7a581f325eb74fda90" translate="yes" xml:space="preserve">
          <source>And name would have changed as expected. However, in the children array, the child (Alicw) would have been completely removed and a new one (Alice) added. This is not completely what you would have expected. Instead, you would have expected that only the name property of the child was updated from Alicw to Alice, not that the entire child was replaced!</source>
          <target state="translated">그리고 예상대로 이름이 변경되었을 것입니다. 그러나 children 배열에서 자식 (Alicw)이 완전히 제거되고 새 항목 (Alice)이 추가되었습니다. 이것은 당신이 기대했던 것이 아닙니다. 대신, 자식의 이름 속성 만 Alicw에서 Alice로 업데이트되고 전체 자식이 교체되지는 않았을 것입니다.</target>
        </trans-unit>
        <trans-unit id="e9ca86081be1235e5d657f4784b8eda45576a203" translate="yes" xml:space="preserve">
          <source>Any existing content is removed and discarded.</source>
          <target state="translated">기존 내용이 모두 제거되고 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="4f4f05405754c54fdd9676fba604372b29335c05" translate="yes" xml:space="preserve">
          <source>Apart from the fact that they work with JSON strings instead of JS objects these functions are completely identical to their *JS counterparts.</source>
          <target state="translated">JS 객체 대신 JSON 문자열로 작업한다는 사실 외에도 이러한 기능은 * JS 대응 기능과 완전히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7f1ccfc969139d4ee723e3cd26a3b87a5f4bd6fb" translate="yes" xml:space="preserve">
          <source>Applications can reference this trivially, i.e., ko.components.register('my-component', { require: 'path/my-component' });</source>
          <target state="translated">응용 프로그램은 이것을 사소하게 참조 할 수 있습니다. 즉 ko.components.register ( 'my-component', {require : 'path / my-component'});</target>
        </trans-unit>
        <trans-unit id="c1c42fc46dfc0ee9be1215927e31c8ac247229ec" translate="yes" xml:space="preserve">
          <source>Applying multiple extenders</source>
          <target state="translated">여러 익스텐더 적용</target>
        </trans-unit>
        <trans-unit id="bb775857f1edfb66da986af1438cdd40f990f61d" translate="yes" xml:space="preserve">
          <source>Applying the rateLimit extender</source>
          <target state="translated">rateLimit 익스텐더 적용</target>
        </trans-unit>
        <trans-unit id="a30bfe9fb3fdb4e5e2bd1e24672ab720fe7f064f" translate="yes" xml:space="preserve">
          <source>Arrays are converted into &lt;a href=&quot;observablearrays&quot;&gt;observable arrays&lt;/a&gt;. If an update would change the number of items, it will perform the appropriate add/remove actions. It will also try to keep the order the same as the original JavaScript array.</source>
          <target state="translated">배열은 &lt;a href=&quot;observablearrays&quot;&gt;관찰 가능한 배열&lt;/a&gt; 로 변환됩니다 . 업데이트가 항목 수를 변경하면 적절한 추가 / 제거 작업이 수행됩니다. 또한 순서를 원래 JavaScript 배열과 동일하게 유지하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="64e6eb4e5415e08468cb571b630e6982ce45a64e" translate="yes" xml:space="preserve">
          <source>As an alternative, Knockout provides two helper functions that allow you to identify the data associated with a DOM element:</source>
          <target state="translated">대안으로 Knockout은 DOM 요소와 관련된 데이터를 식별 할 수있는 두 가지 도우미 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="18bd9d7dc396ea105d8584c5d8a67ce95140998c" translate="yes" xml:space="preserve">
          <source>As an array, $componentTemplateNodes, available to any binding expression in the component&amp;rsquo;s template (i.e., as a &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; property). Usually this is the most convenient way to use the supplied markup. See the example below.</source>
          <target state="translated">구성 요소 템플릿의 모든 바인딩 표현식에 사용할 수있는 $ componentTemplateNodes 배열 (즉, &lt;a href=&quot;binding-context&quot;&gt;바인딩 컨텍스트&lt;/a&gt; 속성). 일반적으로 제공된 마크 업을 사용하는 가장 편리한 방법입니다. 아래 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bdc42cbe041397354fa48d36ba2fff1663ff9d0f" translate="yes" xml:space="preserve">
          <source>As an array, componentInfo.templateNodes, passed to its &lt;a href=&quot;component-registration#a-createviewmodel-factory-function&quot;&gt;createViewModel function&lt;/a&gt;</source>
          <target state="translated">componentInfo.templateNodes 배열로 &lt;a href=&quot;component-registration#a-createviewmodel-factory-function&quot;&gt;createViewModel 함수에&lt;/a&gt; 전달</target>
        </trans-unit>
        <trans-unit id="8ab4f1ab556f0024f4505366ba60640abe3aa3a6" translate="yes" xml:space="preserve">
          <source>As described in Note 1, you can refer to each array entry using the $data &lt;a href=&quot;binding-context&quot;&gt;context variable&lt;/a&gt;. In some cases though, it may be useful to give the current item a more descriptive name using the as option like:</source>
          <target state="translated">참고 1에서 설명한대로 $ data &lt;a href=&quot;binding-context&quot;&gt;컨텍스트 변수를&lt;/a&gt; 사용하여 각 배열 항목을 참조 할 수 있습니다 . 그러나 경우에 따라 as 옵션을 사용하여 현재 항목에 더 설명적인 이름을 지정하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9e6cce525faa11e83082f916934eb369ee22979" translate="yes" xml:space="preserve">
          <source>As illustrated in this example, KO passes the form element as a parameter to your submit handler function. You can ignore that parameter if you want, or there are various ways you might want to use it, for example:</source>
          <target state="translated">이 예에서 설명 된 것처럼 KO는 양식 요소를 제출 핸들러 함수에 매개 변수로 전달합니다. 원하는 경우 해당 매개 변수를 무시하거나 다양한 방법으로 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5900cfc0e230ba6370b7536d4e0bc93369597873" translate="yes" xml:space="preserve">
          <source>As long as they reference different CSS class names, you can include both class and css bindings on the same element. Thus you can have some classes that are set based on a true/false value and others that are calculated dynamically. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb01af05163d90a3c9bcdc7eb32c655738d0ff1e" translate="yes" xml:space="preserve">
          <source>As shown above, the changes are reported as a list of &lt;em&gt;added&lt;/em&gt; and &lt;em&gt;deleted&lt;/em&gt; values. The indexes for &lt;em&gt;deleted&lt;/em&gt; items refer to the original array, and the indexes for &lt;em&gt;added&lt;/em&gt; items refer to the new array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40531ab2533e66fef97d544b345056144f69e728" translate="yes" xml:space="preserve">
          <source>As shown in the above examples, bindings within the foreach block can refer to properties on the array entries. For example, &lt;a href=&quot;#example-1-iterating-over-an-array&quot;&gt;Example 1&lt;/a&gt; referenced the firstName and lastName properties on each array entry.</source>
          <target state="translated">위의 예에서와 같이 foreach 블록 내의 바인딩은 배열 항목의 속성을 참조 할 수 있습니다. 예를 들어, &lt;a href=&quot;#example-1-iterating-over-an-array&quot;&gt;예제 1&lt;/a&gt; 은 각 배열 항목의 firstName 및 lastName 속성을 참조했습니다.</target>
        </trans-unit>
        <trans-unit id="03dd56f30baeedf6f43ffeb0f96b6c0c125970f3" translate="yes" xml:space="preserve">
          <source>As soon as your UI gets nontrivial and has a few overlapping behaviors, things can get tricky and expensive to maintain if you only use jQuery. Consider an example: you&amp;rsquo;re displaying a list of items, stating the number of items in that list, and want to enable an &amp;lsquo;Add&amp;rsquo; button only when there are fewer than 5 items. jQuery doesn&amp;rsquo;t have a concept of an underlying data model, so to get the number of items you have to infer it from the number of TRs in a table or the number of DIVs with a certain CSS class. Maybe the number of items is displayed in some SPAN, and you have to remember to update that SPAN&amp;rsquo;s text when the user adds an item. You also must remember to disable the &amp;lsquo;Add&amp;rsquo; button when the number of TRs is 5. Later, you&amp;rsquo;re asked also to implement a &amp;lsquo;Delete&amp;rsquo; button and you have to figure out which DOM elements to change whenever it&amp;rsquo;s clicked.</source>
          <target state="translated">UI가 중요하지 않고 몇 가지 겹치는 동작이 생기면 jQuery 만 사용하면 유지 관리가 까다로워지고 비용이 많이들 수 있습니다. 예를 들어, 항목 목록을 표시하고 해당 목록의 항목 수를 표시하고 항목이 5 개 미만인 경우에만 '추가'단추를 사용하려고합니다. jQuery에는 기본 데이터 모델 개념이 없으므로 테이블의 TR 수 또는 특정 CSS 클래스의 DIV 수에서 추론해야하는 항목 수를 가져옵니다. 일부 SPAN에 항목 수가 표시 될 수 있으며 사용자가 항목을 추가 할 때 해당 SPAN 텍스트를 업데이트해야합니다. 또한 TR의 수가 5 일 때 '추가'버튼을 비활성화해야한다는 것을 기억해야합니다. 나중에 '삭제'버튼을 구현하라는 메시지가 표시 될 때마다 클릭 할 때마다 변경할 DOM 요소를 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="3824481999af1a08c2a42310b9623d970b4c8e60" translate="yes" xml:space="preserve">
          <source>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. KO will evaluate them and use the resulting values to detemine the style values to apply.</source>
          <target state="translated">평소와 같이 임의의 JavaScript 표현식 또는 함수를 매개 변수 값으로 사용할 수 있습니다. KO는이를 평가하고 결과 값을 사용하여 적용 할 스타일 값을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="ce18070a48ec4dcf3c21d8c773695eaa7e43f60a" translate="yes" xml:space="preserve">
          <source>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. KO will evaluate them and use the resulting values to determine the appropriate CSS classes to add or remove.</source>
          <target state="translated">평소와 같이 임의의 JavaScript 표현식 또는 함수를 매개 변수 값으로 사용할 수 있습니다. KO는이를 평가하고 결과 값을 사용하여 추가하거나 제거 할 적절한 CSS 클래스를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="be219c6df3733113cae67ffbcbc8620e153c2b9c" translate="yes" xml:space="preserve">
          <source>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. Knockout will evaluate them and use the resulting value to determine the appropriate CSS classes to add or remove.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4da197852de89fac4dcfd406e4865e31c17c79" translate="yes" xml:space="preserve">
          <source>As usual, you can use arbitrary JavaScript expressions or functions as parameter values. Knockout will evaluate them and use the resulting values to detemine the style values to apply.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57fd897b08c686dca588676f977987af4cbc17de" translate="yes" xml:space="preserve">
          <source>As well as (or instead of) template and viewModel, your component configuration object can have arbitrary other properties. This configuration object is made available to any &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt; you may be using.</source>
          <target state="translated">템플릿 및 viewModel뿐만 아니라 구성 요소 구성 객체는 임의의 다른 속성을 가질 수 있습니다. 이 구성 개체는 사용중인 모든 &lt;a href=&quot;component-loaders&quot;&gt;사용자 지정 구성 요소 로더에서&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="271643e4723e546ecfd37518fb0f1e341e319028" translate="yes" xml:space="preserve">
          <source>As you can see from Example 2 above, it&amp;rsquo;s possible to use $index to refer to the zero-based index of the current array item. $index is an observable and is updated whenever the index of the item changes (e.g., if items are added to or removed from the array).</source>
          <target state="translated">위의 예제 2에서 볼 수 있듯이 $ index를 사용하여 현재 배열 항목의 0부터 시작하는 인덱스를 참조 할 수 있습니다. $ index는 관찰 가능하며 항목의 색인이 변경 될 때마다 (예를 들어, 항목이 배열에 추가되거나 배열에서 제거되는 경우) 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="cabec4e28a1cc149d5844e47658d55240bebd319" translate="yes" xml:space="preserve">
          <source>As you can see, binding contexts have an extend function that produces a clone with extra properties. The extend function accepts either an object with the properties to copy or a function that returns such an object. The function syntax is preferred so that future changes in the binding value are always updated in the binding context. This process doesn&amp;rsquo;t affect the original binding context, so there is no danger of affecting sibling-level elements - it will only affect descendants.</source>
          <target state="translated">보시다시피 바인딩 컨텍스트에는 추가 속성을 가진 복제본을 생성하는 확장 기능이 있습니다. extend 함수는 복사 할 속성이있는 객체 또는 이러한 객체를 반환하는 함수를받습니다. 바인딩 값의 향후 변경 사항이 항상 바인딩 컨텍스트에서 업데이트되도록 함수 구문이 선호됩니다. 이 프로세스는 원래 바인딩 컨텍스트에 영향을 미치지 않으므로 형제 수준 요소에 영향을 줄 위험이 없으며 하위 항목에만 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="9ea6690b6b5207f9ef37a626e0bbe8a12a55cab9" translate="yes" xml:space="preserve">
          <source>As you have seen in the examples above, you can use a params attribute to supply parameters to the component viewmodel. The contents of the params attribute are interpreted like a JavaScript object literal (just like a data-bind attribute), so you can pass arbitrary values of any type. Example:</source>
          <target state="translated">위의 예에서 보았 듯이 params 속성을 사용하여 구성 요소 뷰 모델에 매개 변수를 제공 할 수 있습니다. params 속성의 내용은 JavaScript 객체 리터럴 (데이터 바인딩 속성과 동일)처럼 해석되므로 모든 유형의 임의 값을 전달할 수 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="e34c40ba0f5fa3fb6eb13d61c372271984f13555" translate="yes" xml:space="preserve">
          <source>Assuming your array is an &lt;a href=&quot;observablearrays&quot;&gt;observable array&lt;/a&gt;, whenever you later add, remove, or re-order array entries, the binding will efficiently update the UI to match - inserting or removing more copies of the markup, or re-ordering existing DOM elements, without affecting any other DOM elements. This is far faster than regenerating the entire foreach output after each array change.</source>
          <target state="translated">배열이 &lt;a href=&quot;observablearrays&quot;&gt;관찰 가능한 배열&lt;/a&gt; 이라고 가정하면 나중에 배열 항목을 추가, 제거 또는 재정렬 할 때마다 바인딩은 UI를 효율적으로 업데이트하여 마크 업의 더 많은 사본을 삽입 또는 제거하거나 기존 DOM 요소를 재정렬합니다. 다른 DOM 요소에 영향을줍니다. 이는 각 어레이가 변경된 후 전체 foreach 출력을 재생성하는 것보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="0a29a876f6fee0ab06e8d6374c2a1f8b7410a520" translate="yes" xml:space="preserve">
          <source>Asynchronous Module Definition (AMD) With RequireJs</source>
          <target state="translated">RequireJ가있는 비동기 모듈 정의 (AMD)</target>
        </trans-unit>
        <trans-unit id="f15ea1e1d443f1c22a341a9e0edeca34b288d76c" translate="yes" xml:space="preserve">
          <source>Asynchronous error handling</source>
          <target state="translated">비동기 오류 처리</target>
        </trans-unit>
        <trans-unit id="f8b6cc5cdc6b8261c411bf780fb442ecccc793b5" translate="yes" xml:space="preserve">
          <source>Asynchronous module definition (AMD) with requireJs</source>
          <target state="translated">requireJ가있는 비동기 모듈 정의 (AMD)</target>
        </trans-unit>
        <trans-unit id="4669c785b85f8d268aedb9a3b7494a7c8313488f" translate="yes" xml:space="preserve">
          <source>Because of inheritance, if you attach a function to ko.subscribable, it will be available on all the others too. If you attach a function to ko.observable, it will be inherited by ko.observableArray but not by ko.computed.</source>
          <target state="translated">상속으로 인해 ko.subscribable에 함수를 첨부하면 다른 모든 함수에서도 사용할 수 있습니다. ko.observable에 함수를 연결하면 ko.computed가 아니라 ko.observableArray에 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="3aa536687687d7362ee99aa5d4ec974df63a5c14" translate="yes" xml:space="preserve">
          <source>Because self is captured in the function&amp;rsquo;s closure, it remains available and consistent in any nested functions, such as the computed observable&amp;rsquo;s evaluator. This convention is even more useful when it comes to event handlers, as you&amp;rsquo;ll see in many of the &lt;a href=&quot;http://knockoutjs.com/examples/&quot;&gt;live examples&lt;/a&gt;.</source>
          <target state="translated">self는 함수의 클로저에서 캡처되므로 계산 된 관찰 가능 평가 기와 같은 중첩 된 함수에서 사용 가능하고 일관성이 유지됩니다. 이 규칙은 많은 &lt;a href=&quot;http://knockoutjs.com/examples/&quot;&gt;실제 예제&lt;/a&gt; 에서 볼 수 있듯이 이벤트 핸들러와 관련하여 훨씬 더 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="dd834cbc10e441f97b7b77e9db5957d9221be9db" translate="yes" xml:space="preserve">
          <source>Because self is captured in the function&amp;rsquo;s closure, it remains available and consistent in any nested functions, such as the computed observable&amp;rsquo;s evaluator. This convention is even more useful when it comes to event handlers, as you&amp;rsquo;ll see in many of the &lt;a href=&quot;https://knockoutjs.com/examples/&quot;&gt;live examples&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="550907ac1f6696f0600c8c1a60187b368d514a83" translate="yes" xml:space="preserve">
          <source>Because the computed observable evaluates both pageIndex and pageSize, it becomes dependent on both of them. So, this code will use jQuery&amp;rsquo;s &lt;a href=&quot;http://api.jquery.com/jQuery.getJSON/&quot;&gt;$.getJSON function&lt;/a&gt; to reload currentPageData when a GridViewModel is first instantiated &lt;em&gt;and&lt;/em&gt; whenever the pageIndex or pageSize properties are later changed.</source>
          <target state="translated">계산 된 관찰 가능 객체는 pageIndex와 pageSize를 모두 평가하므로 둘 다에 종속됩니다. 따라서이 코드는 jQuery의 &lt;a href=&quot;http://api.jquery.com/jQuery.getJSON/&quot;&gt;$ .getJSON 함수&lt;/a&gt; 를 사용 하여 GridViewModel이 처음 인스턴스화 &lt;em&gt;되고&lt;/em&gt; 나중에 pageIndex 또는 pageSize 속성이 변경 될 때마다 currentPageData를 다시로드 합니다.</target>
        </trans-unit>
        <trans-unit id="0c00e991fcf301ea36ef0431f7266e3845d6942f" translate="yes" xml:space="preserve">
          <source>Because the hasFocus binding works in both directions (setting the associated value focuses or unfocuses the element; focusing or unfocusing the element sets the associated value), it&amp;rsquo;s a convenient way to toggle an &amp;ldquo;edit&amp;rdquo; mode. In this example, the UI displays either a &amp;lt;span&amp;gt; or an &amp;lt;input&amp;gt; element depending on the model&amp;rsquo;s editing property. Unfocusing the &amp;lt;input&amp;gt; element sets editing to false, so the UI switches out of &amp;ldquo;edit&amp;rdquo; mode.</source>
          <target state="translated">hasFocus 바인딩은 양방향으로 작동하기 때문에 (관련 값을 설정하면 요소에 초점을 맞추거나 초점을 맞추지 않고, 요소에 초점을 맞추거나 초점을 맞추지 않으면 관련 값을 설정합니다)&amp;ldquo;편집&amp;rdquo;모드를 전환하는 편리한 방법입니다. 이 예에서 UI는 모델의 편집 속성에 따라 &amp;lt;span&amp;gt; 또는 &amp;lt;input&amp;gt; 요소를 표시합니다. &amp;lt;input&amp;gt; 요소의 초점을 해제하면 편집이 false로 설정되어 UI가 &quot;편집&quot;모드에서 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="bd8beb104f73636a98fcd6cda7c1acde17a32e28" translate="yes" xml:space="preserve">
          <source>Behind the scenes, an observableArray is actually an &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; whose value is an array (plus, observableArray adds some additional features described below). So, you can get the underlying JavaScript array by invoking the observableArray as a function with no parameters, just like any other observable. Then you can read information from that underlying array. For example,</source>
          <target state="translated">이면에서 observableArray는 실제로 값이 배열 인 &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; 입니다 (또한 observableArray는 아래에 설명 된 몇 가지 추가 기능을 추가 함). 따라서 다른 옵저버 블과 마찬가지로 매개 변수가없는 함수로 observableArray를 호출하여 기본 JavaScript 배열을 얻을 수 있습니다. 그런 다음 해당 기본 배열에서 정보를 읽을 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="9cd4c935e79a15a4f2de856a72f11306af77e87c" translate="yes" xml:space="preserve">
          <source>Better yet, this techinique could be used to support event delegation. jQuery&amp;rsquo;s live/delegate/on functions are an easy way to make this happen:</source>
          <target state="translated">또한이 기술은 이벤트 위임을 지원하는 데 사용될 수 있습니다. jQuery의 live / delegate / on 함수는이를 쉽게 수행 할 수있는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7f0043e684cc2e548822e45bee14ea4c4673e262" translate="yes" xml:space="preserve">
          <source>Binding</source>
          <target state="translated">Binding</target>
        </trans-unit>
        <trans-unit id="3a81a526cb1140d2e424d0180bf85d9cd3d1c460" translate="yes" xml:space="preserve">
          <source>Binding context</source>
          <target state="translated">바인딩 컨텍스트</target>
        </trans-unit>
        <trans-unit id="93d552de279f9f9e13483b79acf3dd9808266d2b" translate="yes" xml:space="preserve">
          <source>Binding lifecycle events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65f722c7a7e44d3deb47b141e7f82c81b0815261" translate="yes" xml:space="preserve">
          <source>Binding preprocessor reference</source>
          <target state="translated">바인딩 전 처리기 참조</target>
        </trans-unit>
        <trans-unit id="7bd59c5a7fe5f05639190e405278fb2261e77836" translate="yes" xml:space="preserve">
          <source>Binding syntax</source>
          <target state="translated">바인딩 구문</target>
        </trans-unit>
        <trans-unit id="a9b9212b6073a73407ac32ba882e6a4bcaeeaed2" translate="yes" xml:space="preserve">
          <source>Binding values</source>
          <target state="translated">바인딩 값</target>
        </trans-unit>
        <trans-unit id="967382f86044b6efc91dfee8f4e2b4ed941211cd" translate="yes" xml:space="preserve">
          <source>Bindings</source>
          <target state="translated">Bindings</target>
        </trans-unit>
        <trans-unit id="89aea1a967b670a09ecb14ffdbd5170d33e77df9" translate="yes" xml:space="preserve">
          <source>Bindings can include JavaScript-style comments (//... and /*...*/). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b0f9a9f1a5ef31bad0fa03e077b16e18f5a9b5" translate="yes" xml:space="preserve">
          <source>Bindings can include any amount of &lt;em&gt;whitespace&lt;/em&gt; (spaces, tab, and newlines), so you&amp;rsquo;re free to use it to arrange your bindings as you like. The following examples are all equivalent:</source>
          <target state="translated">바인딩에는 임의의 양의 &lt;em&gt;공백&lt;/em&gt; (공백, 탭 및 줄 바꿈) 이 포함될 수 있으므로 원하는대로 바인딩을 정렬하는 데 자유롭게 사용할 수 있습니다. 다음 예제는 모두 동일합니다.</target>
        </trans-unit>
        <trans-unit id="92f78f786d943b799c2c8bf4c4f8c9a36f323743" translate="yes" xml:space="preserve">
          <source>Bindings contexts offer the following special properties that you can reference in any binding:</source>
          <target state="translated">바인딩 컨텍스트는 바인딩에서 참조 할 수있는 다음과 같은 특수 속성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f7dfee65d89e215d7fc623cc4674a60289e7c1ce" translate="yes" xml:space="preserve">
          <source>Bindings such as &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; create extra levels in the binding context hierarchy. This means that their descendants can access data at outer levels by using $parent, $parents, $root, or $parentContext.</source>
          <target state="translated">&lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; 및 &lt;a href=&quot;foreach-binding&quot;&gt;foreach &lt;/a&gt;와 같은 바인딩 은 바인딩 컨텍스트 계층에서 추가 수준을 만듭니다. 이는 하위 항목이 $ parent, $ parents, $ root 또는 $ parentContext를 사용하여 외부 수준의 데이터에 액세스 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6acc9a939f24c837662878de4c3d39eeade8294a" translate="yes" xml:space="preserve">
          <source>Both result and result2 will be:</source>
          <target state="translated">result와 result2는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0b375916d78848c4b0ac042003d5c4e6a2e1607f" translate="yes" xml:space="preserve">
          <source>Browsers are highly inconsistent in the events that fire in response to unusual text entry mechanisms such as cutting, dragging, or accepting autocomplete suggestions. The value binding, even with extra options such as valueUpdate: afterkeydown to get updates on particular events, does not cover all text entry scenarios on all browsers.</source>
          <target state="translated">잘라 내기, 끌기 또는 자동 완성 제안 수락과 같은 비정상적인 텍스트 입력 메커니즘에 대한 응답으로 발생하는 이벤트에서 브라우저는 일관성이 없습니다. 특정 이벤트에 대한 업데이트를 얻기 위해 valueUpdate : afterkeydown과 같은 추가 옵션을 사용하더라도 값 바인딩은 모든 브라우저에서 모든 텍스트 입력 시나리오를 다루지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="82dc9108de5adbfed209f29bd45aca2f7129d561" translate="yes" xml:space="preserve">
          <source>But what if you want to refer to the array entry itself (not just one of its properties)? In that case, you can use the &lt;a href=&quot;binding-context&quot;&gt;special context property&lt;/a&gt; $data. Within a foreach block, it means &amp;ldquo;the current item&amp;rdquo;. For example,</source>
          <target state="translated">그러나 배열 항목 자체 (단 하나의 속성이 아닌)를 참조하려면 어떻게해야합니까? 이 경우 &lt;a href=&quot;binding-context&quot;&gt;특수 컨텍스트 속성&lt;/a&gt; $ data를 사용할 수 있습니다 . foreach 블록 내에서&amp;ldquo;현재 항목&amp;rdquo;을 의미합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="eec18f7623a3b7b58d6302099822dbf86dd41114" translate="yes" xml:space="preserve">
          <source>By default, Knockout assumes that your custom element tag names correspond exactly to the names of components registered using ko.components.register. This convention-over-configuration strategy is ideal for most applications.</source>
          <target state="translated">기본적으로 Knockout은 사용자 정의 요소 태그 이름이 ko.components.register를 사용하여 등록 된 구성 요소 이름과 정확히 일치한다고 가정합니다. 이 컨벤션 오버 컨벤션 전략은 대부분의 애플리케이션에 이상적입니다.</target>
        </trans-unit>
        <trans-unit id="dfd4b509346f65fb32adf29e6062d88da4847b7c" translate="yes" xml:space="preserve">
          <source>By default, Knockout comes with support for &lt;a href=&quot;https://github.com/BorisMoore/jquery-tmpl&quot;&gt;jquery.tmpl&lt;/a&gt;. To use it, you need to reference the following libraries, in this order:</source>
          <target state="translated">기본적으로 Knockout은 &lt;a href=&quot;https://github.com/BorisMoore/jquery-tmpl&quot;&gt;jquery.tmpl&lt;/a&gt; 을 지원합니다 . 이를 사용하려면 다음 라이브러리를이 순서대로 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="a6a1b05bbc994e6ce05943724747faea53070d14" translate="yes" xml:space="preserve">
          <source>By default, Knockout will allow the click event to continue to bubble up to any higher level event handlers. For example, if your element and a parent of that element are both handling the click event, then the click handler for both elements will be triggered. If necessary, you can prevent the event from bubbling by including an additional binding that is named clickBubble and passing false to it, as in this example:</source>
          <target state="translated">기본적으로 녹아웃은 클릭 이벤트가 상위 이벤트 핸들러로 계속 버블 링되도록합니다. 예를 들어, 요소와 해당 요소의 부모가 모두 click 이벤트를 처리하는 경우 두 요소 모두에 대한 클릭 핸들러가 트리거됩니다. 필요한 경우 다음 예제와 같이 clickBubble이라는 추가 바인딩을 포함하고 false를 전달하여 이벤트 버블 링을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f653a59193ad26cd8f474a7f1ec0369bc69dd3cf" translate="yes" xml:space="preserve">
          <source>By default, Knockout will allow the event to continue to bubble up to any higher level event handlers. For example, if your element is handling a mouseover event and a parent of the element also handles that same event, then the event handler for both elements will be triggered. If necessary, you can prevent the event from bubbling by including an additional binding that is named youreventBubble and passing false to it, as in this example:</source>
          <target state="translated">기본적으로, 녹아웃은 이벤트가 상위 레벨 이벤트 핸들러로 계속 버블 링되도록합니다. 예를 들어, 요소가 마우스 오버 이벤트를 처리하고 있고 요소의 상위 요소도 동일한 이벤트를 처리하는 경우 두 요소의 이벤트 핸들러가 트리거됩니다. 필요한 경우 다음 예제와 같이 youreventBubble이라는 추가 바인딩을 포함하고 false를 전달하여 이벤트 버블 링을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0213c08b2e3987a7bcfe88f7f8be8cd23b5038ae" translate="yes" xml:space="preserve">
          <source>By default, Knockout will prevent the click event from taking any default action. This means that if you use the click binding on an a tag (a link), for example, the browser will only call your handler function and will &lt;em&gt;not&lt;/em&gt; navigate to the link&amp;rsquo;s href. This is a useful default because when you use the click binding, it&amp;rsquo;s normally because you&amp;rsquo;re using the link as part of a UI that manipulates your view model, not as a regular hyperlink to another web page.</source>
          <target state="translated">기본적으로 녹아웃은 클릭 이벤트가 기본 작업을 수행하지 못하게합니다. 예를 들어, 태그 (링크)에서 클릭 바인딩을 사용하는 경우 브라우저는 처리기 함수 만 호출 하고 링크의 href로 이동 &lt;em&gt;하지 않습니다&lt;/em&gt; . 클릭 바인딩을 사용할 때 일반적으로 다른 웹 페이지에 대한 일반 하이퍼 링크가 아닌보기 모델을 조작하는 UI의 일부로 링크를 사용하기 때문에 이는 유용한 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="25eb83de5d5b73340ff952e4e80755f80b025215" translate="yes" xml:space="preserve">
          <source>By default, Knockout will prevent the event from taking any default action. For example if you use the event binding to capture the keypress event of an input tag, the browser will only call your handler function and will &lt;em&gt;not&lt;/em&gt; add the value of the key to the input element&amp;rsquo;s value. A more common example is using &lt;a href=&quot;click-binding&quot;&gt;the click binding&lt;/a&gt;, which internally uses this binding, where your handler function will be called, but the browser will &lt;em&gt;not&lt;/em&gt; navigate to the link&amp;rsquo;s href. This is a useful default because when you use the click binding, it&amp;rsquo;s normally because you&amp;rsquo;re using the link as part of a UI that manipulates your view model, not as a regular hyperlink to another web page.</source>
          <target state="translated">기본적으로 녹아웃은 이벤트가 기본 조치를 수행하지 못하게합니다. 예를 들어, 이벤트 바인딩을 사용하여 입력 태그의 키 누르기 이벤트를 캡처하는 경우 브라우저는 핸들러 함수 만 호출 하고 키 값을 입력 요소 값에 추가 &lt;em&gt;하지 않습니다&lt;/em&gt; . 보다 일반적인 예는 &lt;a href=&quot;click-binding&quot;&gt;클릭 바인딩을&lt;/a&gt; 사용하는 것입니다.이 바인딩은 내부적으로이 바인딩을 사용하는데, 여기서 핸들러 함수가 호출되지만 브라우저는 링크의 href로 이동 &lt;em&gt;하지 않습니다&lt;/em&gt; . 클릭 바인딩을 사용할 때 일반적으로 다른 웹 페이지에 대한 일반 하이퍼 링크가 아닌보기 모델을 조작하는 UI의 일부로 링크를 사용하기 때문에 이는 유용한 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="68e7b48de47c13e7d29cf450260662702544cfb2" translate="yes" xml:space="preserve">
          <source>By default, bindings only affect the element to which they are applied. But what if you want to affect all descendant elements too? This is possible. Your binding can tell Knockout &lt;em&gt;not&lt;/em&gt; to bind descendants at all, and then your custom binding can do whatever it likes to bind them in a different way.</source>
          <target state="translated">기본적으로 바인딩은 적용되는 요소에만 영향을줍니다. 그러나 모든 자손 요소에도 영향을 미치려면 어떻게해야합니까? 이것은 가능하다. 바인딩은 Knockout에 자손을 전혀 바인딩 &lt;em&gt;하지 말라고&lt;/em&gt; 지시 할 수 있으며 사용자 정의 바인딩은 다른 방법으로 바인딩하기 위해 원하는 것을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c243a6737db34c7b0eeac830e3f8771116e5e45" translate="yes" xml:space="preserve">
          <source>By default, the DOM nodes inside &amp;lt;my-special-list&amp;gt; will be stripped out (without being bound to any viewmodel) and replaced by the component&amp;rsquo;s output. However, those DOM nodes aren&amp;rsquo;t lost: they are remembered, and are supplied to the component in two ways:</source>
          <target state="translated">기본적으로 &amp;lt;my-special-list&amp;gt; 내부의 DOM 노드는 (뷰 모델에 바인딩되지 않은) 제거되고 구성 요소의 출력으로 대체됩니다. 그러나 이러한 DOM 노드는 손실되지 않습니다. 기억되고 두 가지 방법으로 컴포넌트에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="e8fbd98fd6d39033349a1b00ea69a73c915cbf4b" translate="yes" xml:space="preserve">
          <source>By default, the foreach binding will show all array entries, even those that are marked as destroyed. If you want to hide destroyed entries, set the includeDestroyed option to false. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c47fdcb3268ade367b3d412d238b7c1e97b37a3" translate="yes" xml:space="preserve">
          <source>By default, the foreach binding will skip over (i.e., hide) any array entries that are marked as destroyed. If you want to show destroyed entries, use the includeDestroyed option. For example,</source>
          <target state="translated">기본적으로 foreach 바인딩은 파괴 된 것으로 표시된 배열 항목을 건너 뜁니다 (즉, 숨기기). 손상된 항목을 표시하려면 includeDestroyed 옵션을 사용하십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="8d966b6b812aaffebe3e1b225c111fc8166fe9bd" translate="yes" xml:space="preserve">
          <source>By default, the options binding will skip over (i.e., hide) any array entries that are marked as destroyed. If you want to show destroyed entries, then specify this additional parameter like:</source>
          <target state="translated">기본적으로 옵션 바인딩은 삭제 된 것으로 표시된 배열 항목을 건너 뜁니다 (즉, 숨기기). 손상된 항목을 표시하려면 다음과 같이이 추가 매개 변수를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="dd4b73242b19586f5ded1578826470337eec450d" translate="yes" xml:space="preserve">
          <source>By modifying binding contexts and controlling descendant bindings, you have a powerful and advanced tool to create custom binding mechanisms of your own.</source>
          <target state="translated">바인딩 컨텍스트를 수정하고 하위 바인딩을 제어하면 사용자 정의 바인딩 메커니즘을 직접 만들 수있는 강력하고 고급 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ffe9da1a370013ec59a35300a7401d42fae6091" translate="yes" xml:space="preserve">
          <source>Calls each of the registered loaders&amp;rsquo; getConfig functions in turn, until the first one supplies a non-null componentConfig.</source>
          <target state="translated">첫 번째 함수가 널이 아닌 componentConfig를 제공 할 때까지 등록 된 각 로더의 getConfig 함수를 차례로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="ce90863a4388baecfe3dc5e7b6c6832eca44d46f" translate="yes" xml:space="preserve">
          <source>Calls each of the registered loaders&amp;rsquo; loadTemplate functions in turn, until the first one supplies a non-null DOM array.</source>
          <target state="translated">첫 번째 함수가 널이 아닌 DOM 배열을 제공 할 때까지 등록 된 각 로더의 loadTemplate 함수를 차례로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="cd542f36c0ad03db70cea2aa6e54148b04219c1b" translate="yes" xml:space="preserve">
          <source>Calls each of the registered loaders&amp;rsquo; loadViewModel functions in turn, until the first one supplies a non-null createViewModel function.</source>
          <target state="translated">첫 번째 함수가 널이 아닌 createViewModel 함수를 제공 할 때까지 등록 된 각 로더의 loadViewModel 함수를 차례로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="5ff3b8319fac2d8b7d9acad81d7aa35a5ad48a52" translate="yes" xml:space="preserve">
          <source>Changes to items or selectedIndexes will ripple through the chain of computed observables, which in turn will update any UI elements bound to them.</source>
          <target state="translated">항목 또는 selectedIndexes에 대한 변경 사항은 계산 된 관찰 가능 항목 체인을 통해 리플되며, 이에 따라 바인딩 된 UI 요소가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="0c1d4b0b47058f82dd1b216d04be28f56938456f" translate="yes" xml:space="preserve">
          <source>Combining multiple changes into a single update</source>
          <target state="translated">여러 변경 사항을 단일 업데이트로 결합</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="49288181e14cf83b9352f7e2e0537da14cdcb5e8" translate="yes" xml:space="preserve">
          <source>Communication between parent and child components</source>
          <target state="translated">부모와 자식 구성 요소 간의 통신</target>
        </trans-unit>
        <trans-unit id="c97e23b3c4d2518efc7bf5b1e60ef2c00b9c85c1" translate="yes" xml:space="preserve">
          <source>Comparison with deferred updates</source>
          <target state="translated">지연된 업데이트와 비교</target>
        </trans-unit>
        <trans-unit id="fb8c2f5e94bd4d3fa6518057575ef05920fde751" translate="yes" xml:space="preserve">
          <source>Comparison with the throttle extender</source>
          <target state="translated">스로틀 익스텐더와 비교</target>
        </trans-unit>
        <trans-unit id="c92c529e0731c57efd7550480196484040b33c3e" translate="yes" xml:space="preserve">
          <source>Component</source>
          <target state="translated">Component</target>
        </trans-unit>
        <trans-unit id="4a87edfaece4a4e94d877c76e134bc7cf6471a21" translate="yes" xml:space="preserve">
          <source>Component lifecycle</source>
          <target state="translated">구성 요소 수명주기</target>
        </trans-unit>
        <trans-unit id="2ffddfd282dff2b14a0ea7fa7125f3df71357ad8" translate="yes" xml:space="preserve">
          <source>Component loader utility functions</source>
          <target state="translated">컴포넌트 로더 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="761842342f7602addd473021216f52faa86cae83" translate="yes" xml:space="preserve">
          <source>Component loaders</source>
          <target state="translated">구성품 로더</target>
        </trans-unit>
        <trans-unit id="f452457ae4b51fa02b1e173b4b0f6a1052bd7c42" translate="yes" xml:space="preserve">
          <source>Component registration</source>
          <target state="translated">구성 요소 등록</target>
        </trans-unit>
        <trans-unit id="9289473eeedaee09d76c8cf1b6994d8550debf46" translate="yes" xml:space="preserve">
          <source>Components</source>
          <target state="translated">Components</target>
        </trans-unit>
        <trans-unit id="eed91a528f2fc4fa5bc0cc953effda03077582c3" translate="yes" xml:space="preserve">
          <source>Components and Custom Elements - Overview</source>
          <target state="translated">구성 요소 및 사용자 정의 요소-개요</target>
        </trans-unit>
        <trans-unit id="659136f125703fbf239b6fdcbf9807af68bdd3ca" translate="yes" xml:space="preserve">
          <source>Components usually have viewmodels, but they don&amp;rsquo;t necessarily have to. A component can specify just a template.</source>
          <target state="translated">컴포넌트에는 일반적으로 뷰 모델이 있지만 반드시 그럴 필요는 없습니다. 구성 요소는 템플릿 만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02608739ad96779f6714a96facc9a51c046de4d6" translate="yes" xml:space="preserve">
          <source>Computed Observable Reference</source>
          <target state="translated">계산 된 관찰 가능한 참조</target>
        </trans-unit>
        <trans-unit id="cac67370227943652edb1bf32470cb7ededf3cd3" translate="yes" xml:space="preserve">
          <source>Computed Observables</source>
          <target state="translated">계산 된 관측 값</target>
        </trans-unit>
        <trans-unit id="d98b156baebd0cc88075e455bd6e7b1bb0e76a4b" translate="yes" xml:space="preserve">
          <source>Computed observable reference</source>
          <target state="translated">계산 된 관측 가능한 참조</target>
        </trans-unit>
        <trans-unit id="d2ec0435fbe18656377dae8b79915d57ab98a0b9" translate="yes" xml:space="preserve">
          <source>Computed observables</source>
          <target state="translated">계산 된 관측 가능</target>
        </trans-unit>
        <trans-unit id="5be6efbe0cdf63c1654669d988fd6948bafd8cb6" translate="yes" xml:space="preserve">
          <source>Computed observables are supposed to map a set of observable inputs into a single observable output. As such, it doesn&amp;rsquo;t make sense to include cycles in your dependency chains. Cycles would &lt;em&gt;not&lt;/em&gt; be analogous to recursion; they would be analogous to having two spreadsheet cells that are computed as functions of each other. It would lead to an infinite evaluation loop.</source>
          <target state="translated">계산 된 관측 가능 항목은 일련의 관측 가능 입력을 단일 관측 가능 출력에 매핑해야합니다. 따라서 종속성 체인에주기를 포함시키는 것은 의미가 없습니다. 순환은 재귀와 유사 &lt;em&gt;하지 않습니다&lt;/em&gt; . 그것들은 서로의 함수로 계산되는 두 개의 스프레드 시트 셀을 갖는 것과 유사합니다. 그것은 무한한 평가 루프로 이어질 것입니다.</target>
        </trans-unit>
        <trans-unit id="2947b370ef1780b5ce5f7b757f8fbc6949d5aa95" translate="yes" xml:space="preserve">
          <source>Consider a special list component that can be invoked as follows:</source>
          <target state="translated">다음과 같이 호출 할 수있는 특수 목록 구성 요소를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="cdc5c7e600b4462cb7a47184c49b5743744e2362" translate="yes" xml:space="preserve">
          <source>Consider the following unusual case, in which useObservable1, observable1, and observable2 are all observables:</source>
          <target state="translated">useObservable1, observable1 및 observable2가 모두 관찰 가능한 다음과 같은 비정상적인 경우를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2013a8ac11dfd30a4371b3a3b80a3e57ac8e78e1" translate="yes" xml:space="preserve">
          <source>Consider the observables in the following code:</source>
          <target state="translated">다음 코드에서 관찰 가능 항목을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1117c8b3e83be86f1626d72435beb4550b6b1224" translate="yes" xml:space="preserve">
          <source>Constructing a computed observable</source>
          <target state="translated">계산 된 관찰 가능 객체 생성</target>
        </trans-unit>
        <trans-unit id="4221e67369d1a203bdb0ecf119eb9ef7949b278f" translate="yes" xml:space="preserve">
          <source>Consults each registered loader in turn (by default, that&amp;rsquo;s just the default loader), to find the first one that supplies a viewmodel/template definition for the named component, then invokes callback to return than viewmodel/template declaration. Invokes callback(null) if none of the registered loaders know about this component.</source>
          <target state="translated">등록 된 각 로더를 차례로 참조 (기본적으로 기본 로더 임)하여 명명 된 구성 요소에 대한 뷰 모델 / 템플릿 정의를 제공하는 첫 번째 것을 찾은 다음 viewmodel / template 선언보다 리턴하도록 콜백을 호출합니다. 등록 된 로더 중이 컴포넌트에 대해 아는 사람이 없으면 콜백 (null)을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="edea616075e1b992e2a1f7d2acc1cdd1bdf21fbc" translate="yes" xml:space="preserve">
          <source>Continuing the previous example, you might want slideVisible to set the element to be instantly visible or invisible when the page first appears (without any animated slide), so that the animation only runs when the user changes the model state. You could do that as follows:</source>
          <target state="translated">이전 예제를 계속하면 페이지가 처음 나타날 때 (애니메이션 슬라이드없이) slideVisible에서 요소를 즉시 표시하거나 숨기도록 설정하여 사용자가 모델 상태를 변경할 때만 애니메이션이 실행되도록 할 수 있습니다. 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce832f145332955eb3265a8ede075cf6b1348107" translate="yes" xml:space="preserve">
          <source>Controlling custom element tag names</source>
          <target state="translated">사용자 정의 요소 태그 이름 제어</target>
        </trans-unit>
        <trans-unit id="b8f133feb465932694ab2a98e1eb7747d66f64e3" translate="yes" xml:space="preserve">
          <source>Controlling dependencies using peek</source>
          <target state="translated">엿보기를 사용하여 종속성 제어</target>
        </trans-unit>
        <trans-unit id="dc6504831105dad1f130ff746a8aac74129f3308" translate="yes" xml:space="preserve">
          <source>Controlling or modifying the binding context in custom bindings</source>
          <target state="translated">사용자 정의 바인딩에서 바인딩 컨텍스트 제어 또는 수정</target>
        </trans-unit>
        <trans-unit id="7001c43b6b88f7e449641661e4b5f14d9fd1e3c4" translate="yes" xml:space="preserve">
          <source>Controlling precedence</source>
          <target state="translated">우선 순위 제어</target>
        </trans-unit>
        <trans-unit id="5a2bc032092b4e94355ac6de4992fb4188dcfb12" translate="yes" xml:space="preserve">
          <source>Controlling synchronous/asynchronous loading</source>
          <target state="translated">동기식 / 비동기식 로딩 ​​제어</target>
        </trans-unit>
        <trans-unit id="1c7def4489979402bef239f8ce6c91bfba309a07" translate="yes" xml:space="preserve">
          <source>Converting View Model Data to Plain JSON</source>
          <target state="translated">뷰 모델 데이터를 일반 JSON으로 변환</target>
        </trans-unit>
        <trans-unit id="6db93df4caeca527834703cd00425530177a63ba" translate="yes" xml:space="preserve">
          <source>Copying certain properties using &amp;ldquo;copy&amp;rdquo;</source>
          <target state="translated">&quot;복사&quot;를 사용하여 특정 속성 복사</target>
        </trans-unit>
        <trans-unit id="2203e5a230379d565a0c899ed4adc6b93e7f6dea" translate="yes" xml:space="preserve">
          <source>Creating an extender involves adding a function to the ko.extenders object. The function takes in the observable itself as the first argument and any options in the second argument. It can then either return the observable or return something new like a computed observable that uses the original observable in some way.</source>
          <target state="translated">익스텐더를 만들려면 ko.extenders 객체에 함수를 추가해야합니다. 이 함수는 Observable 자체를 첫 번째 인수로 사용하고 두 번째 인수의 옵션을 사용합니다. 그런 다음 관찰 가능 항목을 반환하거나 원래 관찰 가능 항목을 사용하는 계산 된 관찰 가능 항목과 같은 새로운 방법을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4039add3326a9c3c1c76f899ffeb9a382a6a0bbb" translate="yes" xml:space="preserve">
          <source>Creating custom bindings</source>
          <target state="translated">사용자 정의 바인딩 작성</target>
        </trans-unit>
        <trans-unit id="ffb9756189a28d9adfb06e166fd3288595e0d920" translate="yes" xml:space="preserve">
          <source>Creating custom bindings that control descendant bindings</source>
          <target state="translated">하위 바인딩을 제어하는 ​​사용자 정의 바인딩 작성</target>
        </trans-unit>
        <trans-unit id="f643fe053a4c78aac0aa1cb4ee160c7166f2853b" translate="yes" xml:space="preserve">
          <source>Creating custom bindings that support virtual elements</source>
          <target state="translated">가상 요소를 지원하는 사용자 정의 바인딩 작성</target>
        </trans-unit>
        <trans-unit id="bb539e2cde83f162d3671d028d8f300a026106c8" translate="yes" xml:space="preserve">
          <source>Custom bindings</source>
          <target state="translated">커스텀 바인딩</target>
        </trans-unit>
        <trans-unit id="33671f984027a68370db04ee2850cad72a30b9b1" translate="yes" xml:space="preserve">
          <source>Custom bindings can work with virtual elements too, but to enable this, you must explicitly tell Knockout that your binding understands virtual elements, by using the ko.virtualElements.allowedBindings API.</source>
          <target state="translated">사용자 정의 바인딩은 가상 요소와도 작동 할 수 있지만이를 활성화하려면 ko.virtualElements.allowedBindings API를 사용하여 바인딩이 가상 요소를 이해한다고 명시 적으로 Knockout에 알려야합니다.</target>
        </trans-unit>
        <trans-unit id="b02f7ac0bddff91f51122a7841af16420a2282a7" translate="yes" xml:space="preserve">
          <source>Custom disposal logic</source>
          <target state="translated">맞춤형 폐기 로직</target>
        </trans-unit>
        <trans-unit id="6789075eb722c50f4da3df82b6df6ba9f8fa1b61" translate="yes" xml:space="preserve">
          <source>Custom elements</source>
          <target state="translated">맞춤 요소</target>
        </trans-unit>
        <trans-unit id="3ac9f87f42e53076f0f3bc01bdfc33cd3a3330a1" translate="yes" xml:space="preserve">
          <source>Custom elements are a syntactical alternative to the &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; (and in fact, custom elements make use of a component binding behind the scenes).</source>
          <target state="translated">커스텀 요소는 &lt;a href=&quot;component-binding&quot;&gt;컴포넌트 바인딩에&lt;/a&gt; 대한 구문 대안입니다 (실제로 커스텀 요소는 장면 뒤에서 컴포넌트 바인딩을 사용합니다).</target>
        </trans-unit>
        <trans-unit id="8bdeeedc365799bc2628a672569777dea3cd4f5b" translate="yes" xml:space="preserve">
          <source>Custom elements provide a convenient way of injecting &lt;a href=&quot;component-overview&quot;&gt;components&lt;/a&gt; into your views.</source>
          <target state="translated">사용자 요소는 뷰에 &lt;a href=&quot;component-overview&quot;&gt;구성 요소&lt;/a&gt; 를 주입하는 편리한 방법을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="253deb0b4c3f25b5d0a8ab69ab15a0a5e8a1bbf9" translate="yes" xml:space="preserve">
          <source>Custom functions</source>
          <target state="translated">맞춤형 기능</target>
        </trans-unit>
        <trans-unit id="20edd160b708193b8cd0d39f58c10bc666a47f89" translate="yes" xml:space="preserve">
          <source>Custom loaders can plug into any part of this process, so you can take control over supplying configurations, interpreting configurations, supplying DOM nodes, or supplying viewmodel factory functions. By putting custom loaders into a chosen order inside ko.components.loaders, you can control the priority order of different loading strategies.</source>
          <target state="translated">사용자 정의 로더는이 프로세스의 어느 부분 에나 연결할 수 있으므로 구성 제공, 구성 해석, DOM 노드 제공 또는 뷰 모델 팩토리 기능 제공을 제어 할 수 있습니다. ko.components.loaders 내에서 사용자 정의 로더를 선택한 순서대로 배치하면 다양한로드 전략의 우선 순위를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a613a57094a36803b28114f2b5a1abcb9176c942" translate="yes" xml:space="preserve">
          <source>Custom rate-limit methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1cea07f3d8dcbe1745bc7ec0339edf9dd8a1c9" translate="yes" xml:space="preserve">
          <source>Customizing object construction using &amp;ldquo;create&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;create&amp;rdquo;를 사용하여 객체 구성 사용자 정의</target>
        </trans-unit>
        <trans-unit id="c50ee97e0e3e0b6e26cae536ab969b9b4086cfdd" translate="yes" xml:space="preserve">
          <source>Customizing object updating using &amp;ldquo;update&amp;rdquo;</source>
          <target state="translated">&amp;ldquo;update&amp;rdquo;를 사용하여 객체 업데이트 사용자 정의</target>
        </trans-unit>
        <trans-unit id="a2e01b2c84eeb85c92c0c227a329d46faf0286ed" translate="yes" xml:space="preserve">
          <source>Declarative bindings</source>
          <target state="translated">선언적 바인딩</target>
        </trans-unit>
        <trans-unit id="602e3ca9311ed01ea1f90901d68acf0154edb840" translate="yes" xml:space="preserve">
          <source>Deferred updates</source>
          <target state="translated">지연된 업데이트</target>
        </trans-unit>
        <trans-unit id="d33bdc7c7c750f5687e4acfbfe0dbcbd94980b54" translate="yes" xml:space="preserve">
          <source>Deferred updates are turned off by default to provide compatibility with existing applications. To use deferred updates for your application, you must enable it before initializing your viewmodels by setting the following option:</source>
          <target state="translated">기존 응용 프로그램과의 호환성을 제공하기 위해 지연된 업데이트는 기본적으로 해제되어 있습니다. 응용 프로그램에 지연 업데이트를 사용하려면 다음 옵션을 설정하여 뷰 모델을 초기화하기 전에 업데이트를 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="222e63650134f06185ff4eba850a6bbc59f05df7" translate="yes" xml:space="preserve">
          <source>Defining and registering components</source>
          <target state="translated">구성 요소 정의 및 등록</target>
        </trans-unit>
        <trans-unit id="82561171b4e8eed7831575a3bd0fd837f8a82416" translate="yes" xml:space="preserve">
          <source>Delaying and/or suppressing change notifications</source>
          <target state="translated">변경 알림 지연 및 / 또는 억제</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="a811f27fa09ba74dbb3e42867afbb878bcbad3e6" translate="yes" xml:space="preserve">
          <source>Dependency chains just work</source>
          <target state="translated">의존성 체인은 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7c363ed6db02f3ea32be85600b21f30d4c97ea44" translate="yes" xml:space="preserve">
          <source>Descendant bindings</source>
          <target state="translated">후손 바인딩</target>
        </trans-unit>
        <trans-unit id="59380b44a10043c9034706c8bb58c001df92a319" translate="yes" xml:space="preserve">
          <source>Determining if a property is a computed observable</source>
          <target state="translated">속성이 계산 가능한 관측 가능한지 확인</target>
        </trans-unit>
        <trans-unit id="7d7568009623a301a6c07b4b81d08e0e95375454" translate="yes" xml:space="preserve">
          <source>Determining if a property is a pure computed observable</source>
          <target state="translated">속성이 순수한 계산 된 관찰 가능한지 결정</target>
        </trans-unit>
        <trans-unit id="f8ade81c4c64f53543f1c485af47d756a3b07816" translate="yes" xml:space="preserve">
          <source>Determining if a property is an observableArray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8177b5ed57d02388907afbbf9df075dc986c6b4a" translate="yes" xml:space="preserve">
          <source>Determining the observable type</source>
          <target state="translated">관찰 가능한 유형 결정</target>
        </trans-unit>
        <trans-unit id="2ff2f116ddb0dad37555150f401b3a0c8dbb95b1" translate="yes" xml:space="preserve">
          <source>Developers familiar with Ruby on Rails, ASP.NET MVC, or other MV* technologies may see MVVM as a real-time form of MVC with declarative syntax. In another sense, you can think of KO as a general way to make UIs for editing JSON data&amp;hellip; whatever works for you :)</source>
          <target state="translated">Ruby on Rails, ASP.NET MVC 또는 기타 MV * 기술에 익숙한 개발자는 MVVM을 선언적 구문을 사용하는 MVC의 실시간 형식으로 볼 수 있습니다. 다른 의미에서, KO를 JSON 데이터 편집을위한 UI를 만드는 일반적인 방법으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="853ee1f12570f18e3388b47c2a0f03eb555b5bbd" translate="yes" xml:space="preserve">
          <source>Disposal and memory management</source>
          <target state="translated">폐기 및 메모리 관리</target>
        </trans-unit>
        <trans-unit id="1b44b6295dded1bbfd5d400fc72e1bf24012f125" translate="yes" xml:space="preserve">
          <source>Documentation on Binding Handlers in general can be found &lt;a href=&quot;custom-bindings&quot;&gt;here&lt;/a&gt;. This section is meant to demonstrate the power that AMD modules provide in maintaining your custom handlers. We will take the example of the ko.bindingHandlers.hasFocus example from the binding handlers documentation. By wrapping that handler in it&amp;rsquo;s own module you can restrict it&amp;rsquo;s use only to the pages that need it. The wrapped module becomes:</source>
          <target state="translated">바인딩 핸들러에 대한 일반적인 문서는 &lt;a href=&quot;custom-bindings&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 . 이 섹션은 사용자 지정 처리기를 유지 관리 할 때 AMD 모듈이 제공하는 성능을 보여주기위한 것입니다. 바인딩 핸들러 문서에서 ko.bindingHandlers.hasFocus 예제를 예로 들어 보겠습니다. 해당 핸들러를 자체 모듈로 랩하여 필요한 페이지로만 사용을 제한 할 수 있습니다. 랩핑 된 모듈은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="63aac2ff7f975838de0c8c949cea93205b344a59" translate="yes" xml:space="preserve">
          <source>Documentation on Binding Handlers in general can be found &lt;a href=&quot;http://knockoutjs.com/documentation/custom-bindings.html&quot;&gt;here&lt;/a&gt;. This section is meant to demonstrate the power that AMD modules provide in maintaining your custom handlers. We will take the example of the ko.bindingHandlers.hasFocus example from the binding handlers documentation. By wrapping that handler in it&amp;rsquo;s own module you can restrict it&amp;rsquo;s use only to the pages that need it. The wrapped module becomes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e71968601f25cc8d728fb672b3c6eef4f524e2" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t return non-string values. That wouldn&amp;rsquo;t make sense, because markup is always a string.</source>
          <target state="translated">문자열이 아닌 값을 반환하지 마십시오. 마크 업은 항상 문자열이기 때문에 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3c7559a433a9d713a940341db539ff9c4b28ea8a" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t try to use the value and textInput bindings together on the same element, as that won&amp;rsquo;t achieve anything useful.</source>
          <target state="translated">같은 요소에서 value 및 textInput 바인딩을 함께 사용하지 마십시오. 유용한 요소는 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f44f2279c8cf4e05783eedaa0f0f9909bcb3b91" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t write {font-weight:someValue}; do write {fontWeight:someValue}</source>
          <target state="translated">{font-weight : someValue};를 쓰지 마십시오. {fontWeight : someValue} 작성</target>
        </trans-unit>
        <trans-unit id="6be7c5667ed6550d41ae6c0658c6f47b62d579f4" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t write {text-decoration:someValue}; do write {textDecoration:someValue}</source>
          <target state="translated">{text-decoration : someValue};를 쓰지 마십시오. {textDecoration : someValue} 작성</target>
        </trans-unit>
        <trans-unit id="a479c9c34e878d07b4d67a73a48f432ad7dc53c8" translate="yes" xml:space="preserve">
          <source>Download</source>
          <target state="translated">Download</target>
        </trans-unit>
        <trans-unit id="f9ae8a63307356d3207b70880fd5b3983d9bf72f" translate="yes" xml:space="preserve">
          <source>Drilling down into arrays/objects works but copy and observe can conflict:</source>
          <target state="translated">배열 / 객체로 드릴 다운해도 작동하지만 복사 및 관찰이 충돌 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b14f1acd92dd2af3e3a0d2d48a5aca685f3a348f" translate="yes" xml:space="preserve">
          <source>During the execution of a computed observable&amp;rsquo;s evaluator function, you can access ko.computedContext to get information about the current computed property. It provides the following functions:</source>
          <target state="translated">계산 된 관찰 가능 평가 기 함수를 실행하는 동안 ko.computedContext에 액세스하여 현재 계산 된 속성에 대한 정보를 얻을 수 있습니다. 다음과 같은 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cb51b2c1c5469acfdd11fbdd71a5689e012cc63b" translate="yes" xml:space="preserve">
          <source>Each time you click the button, this will invoke incrementClickCounter() on the view model, which in turn changes the view model state, which causes the UI to update.</source>
          <target state="translated">버튼을 클릭 할 때마다 뷰 모델에서 incrementalClickCounter ()가 호출되어 뷰 모델 상태가 변경되어 UI가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="0cec7a4fc80a79a8517827ff50614001f95e25f2" translate="yes" xml:space="preserve">
          <source>Either { 'font-weight': someValue } or { fontWeight: someValue }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ea802701347963a7c6d7d1af9b4192766647022" translate="yes" xml:space="preserve">
          <source>Either { 'text-decoration': someValue } or { textDecoration: someValue }</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fa9b2101da6336d889f8e0edd362bebf4c734ee" translate="yes" xml:space="preserve">
          <source>Enabling deferred updates</source>
          <target state="translated">지연된 업데이트 사용</target>
        </trans-unit>
        <trans-unit id="15ae64a2d0e5091397c73f3a4af82d2c60920a8a" translate="yes" xml:space="preserve">
          <source>Ensure you call ko.components.register('your-component') &lt;em&gt;before&lt;/em&gt; the HTML parser sees any &amp;lt;your-component&amp;gt; elements</source>
          <target state="translated">HTML 파서가 &amp;lt;your-component&amp;gt; 요소를보기 &lt;em&gt;전에&lt;/em&gt; ko.components.register ( 'your-component')를 호출 &lt;em&gt;해야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="1dad2cf157eb99bbacb6f803399efe19332b4be1" translate="yes" xml:space="preserve">
          <source>Evaluating the computed observable should not cause any side effects.</source>
          <target state="translated">계산 된 관측 가능 항목을 평가해도 부작용이 발생하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="bb63aeafbc8fa85c1955b6434579c431172024e1" translate="yes" xml:space="preserve">
          <source>Evaluation of a rate-limited computed observable isn&amp;rsquo;t rate-limited; it will re-evaluate if you read its value.</source>
          <target state="translated">속도 제한 계산 옵저버 블의 평가는 속도 제한이 없습니다. 값을 읽으면 다시 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="9a4dd6b0c34a91a968005c6fdb0958613d790b68" translate="yes" xml:space="preserve">
          <source>Even if you don&amp;rsquo;t enable deferred updates for your whole application, you can still benefit from this feature by specifically making certain observables deferred. This is done using the deferred extender:</source>
          <target state="translated">전체 애플리케이션에 대해 지연된 업데이트를 사용하지 않더라도 특정 관찰 가능 항목을 특별히 지연시켜이 기능의 이점을 얻을 수 있습니다. 이는 지연 익스텐더를 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="eabc790d00812b33da77b202701e348d39479228" translate="yes" xml:space="preserve">
          <source>Event handling</source>
          <target state="translated">이벤트 처리</target>
        </trans-unit>
        <trans-unit id="ecaca2e0dae16fbf4a4ad04e56b1d2b31b12e57f" translate="yes" xml:space="preserve">
          <source>Everyone loves jQuery! It&amp;rsquo;s an outstanding replacement for the clunky, inconsistent DOM API we had to put up with in the past. jQuery is an excellent low-level way to manipulate elements and event handlers in a web page. KO solves a different problem.</source>
          <target state="translated">모두 jQuery를 좋아합니다! 과거에 다루어야했던 어색하고 일관되지 않은 DOM API를 대체 한 것입니다. jQuery는 웹 페이지에서 요소 및 이벤트 핸들러를 조작하는 탁월한 저수준 방법입니다. KO는 다른 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="6dcd3f46d09547b62bf07ba9b2943c95d53ddae3" translate="yes" xml:space="preserve">
          <source>Example 1</source>
          <target state="translated">실시 예 1</target>
        </trans-unit>
        <trans-unit id="77ef6015f49d42a91349a37284f0d10ce58dfca6" translate="yes" xml:space="preserve">
          <source>Example 1 showed how a writable computed observable can effectively &lt;em&gt;filter&lt;/em&gt; its incoming data by choosing not to write certain values back to the underlying observables if they don&amp;rsquo;t meet some criteria. It ignored full name values that didn&amp;rsquo;t include a space.</source>
          <target state="translated">예제 1에서는 쓰기 가능한 계산 된 Observable이 특정 기준을 충족하지 않는 경우 특정 값을 기본 Observable에 다시 쓰지 않도록 선택하여 들어오는 데이터를 효과적으로 &lt;em&gt;필터링&lt;/em&gt; 하는 방법을 보여줍니다 . 공백을 포함하지 않은 전체 이름 값은 무시했습니다.</target>
        </trans-unit>
        <trans-unit id="4c47207b8b7ae8ab2d635eb01fc483f744594a47" translate="yes" xml:space="preserve">
          <source>Example 1: A component loader that sets up naming conventions</source>
          <target state="translated">예 1 : 이름 지정 규칙을 설정하는 컴포넌트 로더</target>
        </trans-unit>
        <trans-unit id="25518d7fb94487e753554d645c6334d7a18971ef" translate="yes" xml:space="preserve">
          <source>Example 1: Decomposing user input</source>
          <target state="translated">예 1 : 사용자 입력 분해</target>
        </trans-unit>
        <trans-unit id="4ea51a4ffde5737f46b31ecbe0d2ce38e03e5c87" translate="yes" xml:space="preserve">
          <source>Example 1: Drop-down list</source>
          <target state="translated">예 1 : 드롭 다운리스트</target>
        </trans-unit>
        <trans-unit id="0d4cfa89e17777c37aa14362706fd9828f313abe" translate="yes" xml:space="preserve">
          <source>Example 1: Iterating over an array</source>
          <target state="translated">예 1 : 배열을 반복</target>
        </trans-unit>
        <trans-unit id="cde8db0303a6ef26ab001c13fc6ef4c4a5867277" translate="yes" xml:space="preserve">
          <source>Example 1: Setting a default value for a binding</source>
          <target state="translated">예 1 : 바인딩의 기본값 설정</target>
        </trans-unit>
        <trans-unit id="0b080011a40c4eb15898518a2e3a11c9a40dc6a7" translate="yes" xml:space="preserve">
          <source>Example 1: The basics</source>
          <target state="translated">예 1 : 기본</target>
        </trans-unit>
        <trans-unit id="1c56ea49918b9baed94cf4bc0ee9f324efc8841a" translate="yes" xml:space="preserve">
          <source>Example 2</source>
          <target state="translated">실시 예 2</target>
        </trans-unit>
        <trans-unit id="de3d10fd223ba2f62435c7e02579b9cdc45e4ca2" translate="yes" xml:space="preserve">
          <source>Example 2: A component loader that loads external files using custom code</source>
          <target state="translated">예 2 : 사용자 정의 코드를 사용하여 외부 파일을로드하는 구성 요소 로더</target>
        </trans-unit>
        <trans-unit id="152baefa2649a3e481777e4febefb3f62efbbff0" translate="yes" xml:space="preserve">
          <source>Example 2: Binding expressions to events</source>
          <target state="translated">예 2 : 표현식을 이벤트에 바인딩</target>
        </trans-unit>
        <trans-unit id="d9d8b537de776eff6af7ceab0dd013a34c60123d" translate="yes" xml:space="preserve">
          <source>Example 2: Click-to-edit</source>
          <target state="translated">예 2 : 클릭 투 편집</target>
        </trans-unit>
        <trans-unit id="d220784caedb8582e4b56dcacda886e7debebcbd" translate="yes" xml:space="preserve">
          <source>Example 2: Doing something when the user stops typing</source>
          <target state="translated">예 2 : 사용자가 입력을 멈출 때 무언가 수행</target>
        </trans-unit>
        <trans-unit id="68cfd4d2225424d953c697fb7607585a091cb604" translate="yes" xml:space="preserve">
          <source>Example 2: Live example with add/remove</source>
          <target state="translated">예 2 : 추가 / 제거가 포함 된 라이브 예</target>
        </trans-unit>
        <trans-unit id="cc3711f3c0d99468999474edf36f69743a26180f" translate="yes" xml:space="preserve">
          <source>Example 2: Multi-select list</source>
          <target state="translated">예 2 : 다중 선택 목록</target>
        </trans-unit>
        <trans-unit id="46b269bb32dd9e2791dd2abef3477feb53abf1d7" translate="yes" xml:space="preserve">
          <source>Example 2: Selecting/deselecting all items</source>
          <target state="translated">예 2 : 모든 항목 선택 / 선택 해제</target>
        </trans-unit>
        <trans-unit id="50e87750a3521296001652d5e8e5eb52d3e10882" translate="yes" xml:space="preserve">
          <source>Example 3: A value converter</source>
          <target state="translated">예 3 : 값 변환기</target>
        </trans-unit>
        <trans-unit id="1ae049f41b4bef03f225ee3aa4c5f8f8e6b59956" translate="yes" xml:space="preserve">
          <source>Example 3: Drop-down list representing arbitrary JavaScript objects, not just strings</source>
          <target state="translated">예제 3 : 문자열뿐만 아니라 임의의 JavaScript 객체를 나타내는 드롭 다운 목록</target>
        </trans-unit>
        <trans-unit id="65ad7a42106a9c349f796f4927c5d9dd3e154f38" translate="yes" xml:space="preserve">
          <source>Example 3: Virtual template elements</source>
          <target state="translated">예 3 : 가상 템플릿 요소</target>
        </trans-unit>
        <trans-unit id="2c6ee2315f1fbb9f42c5ff7683886da7013cc130" translate="yes" xml:space="preserve">
          <source>Example 4: Drop-down list representing arbitrary JavaScript objects, with displayed text computed as a function of the represented item</source>
          <target state="translated">예제 4 : 표시되는 텍스트를 표시된 항목의 함수로 계산하여 임의의 JavaScript 객체를 나타내는 드롭 다운 목록</target>
        </trans-unit>
        <trans-unit id="113b6fb251c660444fac91367247b19ef5ceb219" translate="yes" xml:space="preserve">
          <source>Example 4: Filtering and validating user input</source>
          <target state="translated">예 4 : 사용자 입력 필터링 및 유효성 검사</target>
        </trans-unit>
        <trans-unit id="b5a7dec77db39f767aebc5bdc16bef64364a4359" translate="yes" xml:space="preserve">
          <source>Example adding checkboxes bound to an array</source>
          <target state="translated">배열에 바인딩 된 확인란을 추가하는 예</target>
        </trans-unit>
        <trans-unit id="50416933cd6d1c51d0982199bf3a9959f145560c" translate="yes" xml:space="preserve">
          <source>Example adding radio buttons</source>
          <target state="translated">라디오 버튼 추가 예</target>
        </trans-unit>
        <trans-unit id="0c0fb6e0f3233e0276bdc610ce75b2efce4645ad" translate="yes" xml:space="preserve">
          <source>Example with checkbox</source>
          <target state="translated">확인란이있는 예</target>
        </trans-unit>
        <trans-unit id="3d8ebdde40a810f8bcecb22744e7b919dc5edb75" translate="yes" xml:space="preserve">
          <source>Example with dynamic classes</source>
          <target state="translated">동적 클래스가있는 예</target>
        </trans-unit>
        <trans-unit id="6433628dbf98786e98c232e686cdd5f6a5f19fc7" translate="yes" xml:space="preserve">
          <source>Example with static classes</source>
          <target state="translated">정적 클래스가있는 예</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="32d559acc95c5e2026c88355b2fc6dbb56610729" translate="yes" xml:space="preserve">
          <source>Example: A filtered view of an observable array</source>
          <target state="translated">예 : 관찰 가능한 배열의 필터링 된보기</target>
        </trans-unit>
        <trans-unit id="48ca56b48fa467d7cffa5a1ad762033d25d9baf5" translate="yes" xml:space="preserve">
          <source>Example: A like/dislike widget</source>
          <target state="translated">예 : 좋아요 / 싫어요 위젯</target>
        </trans-unit>
        <trans-unit id="550a2ef513bd2e9716cf255edf159d7eac98e6ab" translate="yes" xml:space="preserve">
          <source>Example: Adding extra levels in the binding context hierarchy</source>
          <target state="translated">예 : 바인딩 컨텍스트 계층에서 추가 레벨 추가</target>
        </trans-unit>
        <trans-unit id="530246441e8d386c7708bd3e341f39543a901741" translate="yes" xml:space="preserve">
          <source>Example: Avoiding multiple Ajax requests</source>
          <target state="translated">예 : 여러 Ajax 요청 방지</target>
        </trans-unit>
        <trans-unit id="ed1408f9ac2794bd9571def8f7b6df4057a59a28" translate="yes" xml:space="preserve">
          <source>Example: Avoiding multiple UI updates</source>
          <target state="translated">예 : 여러 UI 업데이트 방지</target>
        </trans-unit>
        <trans-unit id="c2642b17305d614b451304cd70c56ebaa48362c4" translate="yes" xml:space="preserve">
          <source>Example: Controlling whether or not descendant bindings are applied</source>
          <target state="translated">예 : 하위 바인딩의 적용 여부 제어</target>
        </trans-unit>
        <trans-unit id="5c3289a0b0b51a0be2ba51f5bf9c959f825caa0c" translate="yes" xml:space="preserve">
          <source>Example: Loading the like/dislike widget from external files, on demand</source>
          <target state="translated">예 : 필요에 따라 외부 파일에서 좋아요 / 싫음 위젯로드</target>
        </trans-unit>
        <trans-unit id="6597b4b37cee763a15316f6ba15516f4f3baf020" translate="yes" xml:space="preserve">
          <source>Example: Manual mapping without the ko.mapping plugin</source>
          <target state="translated">예 : ko.mapping 플러그인이없는 수동 매핑</target>
        </trans-unit>
        <trans-unit id="c298c6fe3398c7d0b1e666fec016b7d667c91616" translate="yes" xml:space="preserve">
          <source>Example: Supplying additional values to descendant bindings</source>
          <target state="translated">예 : 하위 바인딩에 추가 값 제공</target>
        </trans-unit>
        <trans-unit id="30054173d63a971c583a297024b8430fbad005a6" translate="yes" xml:space="preserve">
          <source>Example: Using ko.mapping</source>
          <target state="translated">예 : ko.mapping 사용</target>
        </trans-unit>
        <trans-unit id="5b10251ba9ffb2c86c7da769237457e995ac6fa9" translate="yes" xml:space="preserve">
          <source>Excerpt From &lt;a href=&quot;http://addyosmani.com/writing-modular-js/&quot;&gt;Writing Modular JavaScript With AMD, CommonJs &amp;amp; ES Harmony&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://addyosmani.com/writing-modular-js/&quot;&gt;AMD, CommonJs 및 ES Harmony로 모듈 식 JavaScript 작성&lt;/a&gt; 에서 발췌 :</target>
        </trans-unit>
        <trans-unit id="5bdedba4c5ce2948fd4206f7e11d5e6799420d42" translate="yes" xml:space="preserve">
          <source>Explicitly subscribing to observables</source>
          <target state="translated">Observable을 명시 적으로 구독</target>
        </trans-unit>
        <trans-unit id="1208c99ef5025c09bf368869c5593ca302f58dd8" translate="yes" xml:space="preserve">
          <source>Extending Knockout's binding syntax using preprocessing</source>
          <target state="translated">전처리를 사용하여 녹아웃의 바인딩 구문 확장</target>
        </trans-unit>
        <trans-unit id="477b9ac7b2012a7c4ef01dab5b6738e39bfd0290" translate="yes" xml:space="preserve">
          <source>Extending observables</source>
          <target state="translated">옵저버 블 확장</target>
        </trans-unit>
        <trans-unit id="6d075b19378326b1dd5562c4110427dc1221e6d9" translate="yes" xml:space="preserve">
          <source>Extracting additional data or state from the form elements</source>
          <target state="translated">양식 요소에서 추가 데이터 또는 상태 추출</target>
        </trans-unit>
        <trans-unit id="aa46347e225c51cf57a22ad6da0baa8c26e37d15" translate="yes" xml:space="preserve">
          <source>Finally, to update your view model using this data (without using the mapping plugin), you would write:</source>
          <target state="translated">마지막으로, 매핑 플러그인을 사용하지 않고이 데이터를 사용하여 뷰 모델을 업데이트하려면 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="95a70ce88e1373d7443eeddd31cb4fdbb0259963" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;checkboxes&lt;/strong&gt;, KO will set the element to be &lt;em&gt;checked&lt;/em&gt; when the parameter value is true, and &lt;em&gt;unchecked&lt;/em&gt; when it is false. If you give a value that isn&amp;rsquo;t actually boolean, it will be interpreted loosely. This means that nonzero numbers and non-null objects and non-empty strings will all be interpreted as true, whereas zero, null, undefined, and empty strings will be interpreted as false.</source>
          <target state="translated">들어 &lt;strong&gt;체크 박스&lt;/strong&gt; , KO가 될 수있는 요소를 설정합니다 &lt;em&gt;확인&lt;/em&gt; 매개 변수 값이 true, 그리고 때 &lt;em&gt;선택하지 않은&lt;/em&gt; 경우는 false 인 경우. 실제로 부울이 아닌 값을 제공하면 느슨하게 해석됩니다. 이는 0이 아닌 숫자와 널이 아닌 객체 및 비어 있지 않은 문자열은 모두 참으로 해석되는 반면 0, null, 정의되지 않은 빈 문자열은 거짓으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="1972d38c80951a9e678c4ff687d7462b49456982" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;checkboxes&lt;/strong&gt;, Knockout will set the element to be &lt;em&gt;checked&lt;/em&gt; when the parameter value is true, and &lt;em&gt;unchecked&lt;/em&gt; when it is false. If you give a value that isn&amp;rsquo;t actually boolean, it will be interpreted loosely. This means that nonzero numbers and non-null objects and non-empty strings will all be interpreted as true, whereas zero, null, undefined, and empty strings will be interpreted as false. When the user checks or unchecks the checkbox, Knockout will set your model property to true or false accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a28d41ab8ba0a18cc5a9b626ab01db87a9b2b8cd" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;radio buttons&lt;/strong&gt;, KO will set the element to be &lt;em&gt;checked&lt;/em&gt; if and only if the parameter value equals the radio button node&amp;rsquo;s value attribute or the value specified by the checkedValue parameter. In the previous example, the radio button with value=&quot;almond&quot; was checked only when the view model&amp;rsquo;s spamFlavor property was equal to &quot;almond&quot;.</source>
          <target state="translated">들면 &lt;strong&gt;라디오 버튼&lt;/strong&gt; , KO는 요소가되도록 설정한다 &lt;em&gt;체크&lt;/em&gt; 및 매개 변수 값이 라디오 버튼 노드의 값의 특성 또는 checkedValue 파라미터에 의해 지정된 값에 해당하는 경우에만. 이전 예에서, 뷰 모델의 spamFlavor 속성이 &quot;almond&quot;와 동일한 경우에만 value = &quot;almond&quot;라디오 버튼을 확인했습니다.</target>
        </trans-unit>
        <trans-unit id="cc3c89585ed643a35bcd1fe16e2cc01737ccbce0" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;radio buttons&lt;/strong&gt;, Knockout will set the element to be &lt;em&gt;checked&lt;/em&gt; when the parameter value equals the radio button element&amp;rsquo;s value attribute or the value specified by the checkedValue parameter. In the previous example, the radio button with value=&quot;almond&quot; was checked only when the view model&amp;rsquo;s spamFlavor property was equal to &quot;almond&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d85206a98cfdd4a13c8db149c728546b8ffb8cf" translate="yes" xml:space="preserve">
          <source>For Knockout to be able to load and instantiate your components, you must register them using ko.components.register, providing a configuration as described here.</source>
          <target state="translated">Knockout에서 구성 요소를로드하고 인스턴스화 할 수 있으려면 ko.components.register를 사용하여 등록해야하며 여기에 설명 된대로 구성을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="fb653bd6fda509ae69de2f3c411ab3f9ecc16aff" translate="yes" xml:space="preserve">
          <source>For a computed observable, the rate-limit timer is triggered when one of the computed observable&amp;rsquo;s dependencies change instead of when its value changes. The computed observable is not re-evaluated until its value is actually needed&amp;mdash;after the timeout period when the change notification should happen, or when the computed observable value is accessed directly. If you need to access the value of the computed&amp;rsquo;s most recent evaluation, you can do so with the peek method.</source>
          <target state="translated">계산 된 관찰 가능 개체의 경우 속도 제한 타이머는 계산 된 관찰 가능 장치의 종속성 중 하나가 값이 변경 될 때가 아니라 변경 될 때 트리거됩니다. 변경 알림이 발생해야하는 시간 초과 기간이 지난 후 또는 계산 된 관찰 가능 값에 직접 액세스 할 때 계산 된 관찰 가능 값은 실제로 값이 필요할 때까지 재평가되지 않습니다. 계산 된 최신 평가 값에 액세스해야하는 경우 peek 방법으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6a669cb32d714a0fa05339382fe1c38249fefbd" translate="yes" xml:space="preserve">
          <source>For a multi-select list, you can read and write the selection state using selectedOptions. Technically this is a separate binding, so it has &lt;a href=&quot;selectedoptions-binding&quot;&gt;its own documentation&lt;/a&gt;.</source>
          <target state="translated">다중 선택 목록의 경우 selectedOptions를 사용하여 선택 상태를 읽고 쓸 수 있습니다. 기술적으로 이것은 별도의 바인딩이므로 &lt;a href=&quot;selectedoptions-binding&quot;&gt;자체 문서가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebd598195e6041713fa3eb6fa2ec0c343db66800" translate="yes" xml:space="preserve">
          <source>For a very simple example, here&amp;rsquo;s a custom binding called allowBindings that allows descendant bindings to be applied only if its value is true. If the value is false, then allowBindings tells Knockout that it is responsible for descendant bindings so they won&amp;rsquo;t be bound as usual.</source>
          <target state="translated">매우 간단한 예를 들어, 값이 true 인 경우에만 하위 바인딩을 적용 할 수있는 allowBindings라는 사용자 정의 바인딩이 있습니다. 값이 false 인 경우 allowBindings는 Knockout에 하위 바인딩을 담당하므로 평상시처럼 바인딩되지 않음을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="f738301a087259c2cb88d3ee079875129c0660ae" translate="yes" xml:space="preserve">
          <source>For advanced users, if you want to register your own subscriptions to be notified of changes to observables, you can call their subscribe function. For example:</source>
          <target state="translated">고급 사용자의 경우 옵저버 블에 대한 변경 사항을 알리기 위해 자체 구독을 등록하려는 경우 해당 구독 기능을 호출 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f758951954c6cb5686e9de3f4ea46d08e3e6c56" translate="yes" xml:space="preserve">
          <source>For backward compatibility, you can also use the css binding with a string value like the class binding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc285857d05b5c21a59d307e884dc555d9c7a77" translate="yes" xml:space="preserve">
          <source>For complete syntax, see the &lt;a href=&quot;computed-reference&quot;&gt;computed observable reference&lt;/a&gt;.</source>
          <target state="translated">완전한 구문은 &lt;a href=&quot;computed-reference&quot;&gt;계산 된 관찰 가능 참조를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f8598317b25a1d69826eb855f00f8318431cdf0" translate="yes" xml:space="preserve">
          <source>For documentation on these standard component loader functions, see &lt;a href=&quot;#custom-component-loader&quot;&gt;implementing a custom component loader&lt;/a&gt;.</source>
          <target state="translated">이러한 표준 구성 요소 로더 기능에 대한 문서 &lt;a href=&quot;#custom-component-loader&quot;&gt;는 사용자 정의 구성 요소 로더 구현을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="75d6aa97d869ac1df9beec0c8c0cbb559a4d3a8d" translate="yes" xml:space="preserve">
          <source>For even better encapsulation, you can package a component into a single self-describing AMD module. Then you can reference a component as simply as:</source>
          <target state="translated">더 나은 캡슐화를 위해 구성 요소를 하나의 자체 설명 AMD 모듈로 패키지 할 수 있습니다. 그러면 다음과 같이 간단하게 구성 요소를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="7f3364ff4802481e63e46cadfbc8760e3675bb8b" translate="yes" xml:space="preserve">
          <source>For example, a componentConfig like { template: 'someElementId', viewModel: { require: 'myModule' } } can be understood and instantiated by the default loader.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6431474d550826b851e8376cf48298a6011540b" translate="yes" xml:space="preserve">
          <source>For example, a componentConfig like {template:'someElementId',viewModel:{require:'myModule'}} can be understood and instantiated by the default loader.</source>
          <target state="translated">예를 들어 {template : 'someElementId', viewModel : {require : 'myModule'}}과 같은 componentConfig를 기본 로더에서 이해하고 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63125df5cb160d3708cafec1f0e9b2f0547ee516" translate="yes" xml:space="preserve">
          <source>For example, define a view model as follows:</source>
          <target state="translated">예를 들어, 다음과 같이 뷰 모델을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="36572a6a5e79cde64bef7c1785b1f36c362c494f" translate="yes" xml:space="preserve">
          <source>For example, given the following view model class,</source>
          <target state="translated">예를 들어 다음과 같은 뷰 모델 클래스가 주어지면</target>
        </trans-unit>
        <trans-unit id="8c8a073a43cbbbf266ce41b059e8d1e1736f0261" translate="yes" xml:space="preserve">
          <source>For example, if the following is in a file at path/my-component.js,</source>
          <target state="translated">예를 들어, 다음이 path / my-component.js의 파일에있는 경우,</target>
        </trans-unit>
        <trans-unit id="389a8f18d6ec0043db2935b9cac1d05b35c584a6" translate="yes" xml:space="preserve">
          <source>For example, if you return 'value + &quot;.toUpperCase()&quot;' as a string, then yourBinding: &quot;Bert&quot; would be interpreted as if the markup contained yourBinding: &quot;Bert&quot;.toUpperCase(). Knockout will parse the returned value in the normal way, so it has to be a legal JavaScript expression.</source>
          <target state="translated">예를 들어 'value + &quot;.toUpperCase ()&quot;'를 문자열로 반환하면 yourBinding : &quot;Bert&quot;는 태그에 yourBinding : &quot;Bert&quot;.toUpperCase ()가 포함 된 것처럼 해석됩니다. 녹아웃은 반환 된 값을 일반적인 방식으로 구문 분석하므로 올바른 JavaScript 표현식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="631d5ff146ac1b7e8d91b5960cafd4e8fdada71b" translate="yes" xml:space="preserve">
          <source>For example, if you return value + &quot;.toUpperCase()&quot; as a string, then yourBinding: &quot;Bert&quot; would be interpreted as if the markup contained yourBinding: &quot;Bert&quot;.toUpperCase(). Knockout will parse the returned value in the normal way, so it has to be a legal JavaScript expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1345d943ae097566d0a2d604bb67d731cf352713" translate="yes" xml:space="preserve">
          <source>For example, if you structure your page like this, then everything will be OK:</source>
          <target state="translated">예를 들어 다음과 같이 페이지를 구성하면 모든 것이 정상입니다.</target>
        </trans-unit>
        <trans-unit id="a37e35428471e05739a74959c92c8f8eda5e555f" translate="yes" xml:space="preserve">
          <source>For example, if your component is inside some other element with an &lt;a href=&quot;if-binding&quot;&gt;if binding&lt;/a&gt; (or another control flow binding), then it will not cause the AMD module to be loaded until the if condition is true. Of course, if the AMD module was already loaded (e.g., in a preloaded bundle) then the require call will not trigger any additional HTTP requests, so you can control what is preloaded and what is loaded on demand.</source>
          <target state="translated">예를 들어, 구성 요소가 &lt;a href=&quot;if-binding&quot;&gt;if 바인딩&lt;/a&gt; (또는 다른 제어 흐름 바인딩) 이있는 다른 요소 내에 있는 경우 if 조건이 true가 될 때까지 AMD 모듈이로드되지 않습니다. 물론, AMD 모듈이 이미로드 된 경우 (예를 들어, 사전로드 된 번들에서) 요청 호출은 추가 HTTP 요청을 트리거하지 않으므로 사전로드 된 항목과 요청시로드되는 항목을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e99ffdec1cc7a8a75e2b94b719091deff0a98942" translate="yes" xml:space="preserve">
          <source>For example, instead of writing this:</source>
          <target state="translated">예를 들어 이것을 쓰는 대신 :</target>
        </trans-unit>
        <trans-unit id="9a23df25508d72cfc8abcacad7f0ed1d5ab1eb72" translate="yes" xml:space="preserve">
          <source>For example, rewrite the preceding view model object as follows:</source>
          <target state="translated">예를 들어 다음과 같이 이전 뷰 모델 객체를 다시 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="abacb1facc5d8e8adbbbcedeb1ae28fe320f9867" translate="yes" xml:space="preserve">
          <source>For example, the following element:</source>
          <target state="translated">예를 들어 다음 요소는</target>
        </trans-unit>
        <trans-unit id="64c9c667af6bb9f6172083bac994162a1c1b7a9a" translate="yes" xml:space="preserve">
          <source>For example, the my-special-list component&amp;rsquo;s template can reference $componentTemplateNodes so that its output includes the supplied markup. Here&amp;rsquo;s the complete working example:</source>
          <target state="translated">예를 들어, my-special-list 컴포넌트의 템플리트는 $ componentTemplateNodes를 참조하여 출력에 제공된 마크 업이 포함되도록 할 수 있습니다. 완전한 작업 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b6ff54598ebe3588255d709e9a0c9f753a2b35d" translate="yes" xml:space="preserve">
          <source>For example, you can create interactive components like grids, tabsets, and so on, in the form of custom bindings (see the &lt;a href=&quot;http://knockoutjs.com/examples/grid.html&quot;&gt;grid example&lt;/a&gt;).</source>
          <target state="translated">예를 들어, 그리드, 탭셋 등과 같은 대화식 구성 요소를 사용자 정의 바인딩 형식으로 작성할 수 있습니다 ( &lt;a href=&quot;http://knockoutjs.com/examples/grid.html&quot;&gt;그리드 예제&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="259dc2bfcba22b9dd8b551f2db8f17cbb974e01e" translate="yes" xml:space="preserve">
          <source>For example, you can create interactive components like grids, tabsets, and so on, in the form of custom bindings (see the &lt;a href=&quot;https://knockoutjs.com/examples/grid.html&quot;&gt;grid example&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1a7c228afe4cc9a5c128478008d3b1f5884e84" translate="yes" xml:space="preserve">
          <source>For example, you might have been controlling an element&amp;rsquo;s visibility using the visible binding, but now you want to go a step further and animate the transition. You want elements to slide into and out of existence according to the value of an observable. You can do this by writing a custom binding that calls jQuery&amp;rsquo;s slideUp/slideDown functions:</source>
          <target state="translated">예를 들어, 가시적 바인딩을 사용하여 요소의 가시성을 제어하고 있었지만 이제 한 단계 더 나아가 전환에 애니메이션을 적용하려고합니다. 관찰 가능 값에 따라 요소가 존재하거나 존재하지 않게하려고합니다. jQuery의 slideUp / slideDown 함수를 호출하는 사용자 정의 바인딩을 작성하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0af413f30c072cb2f86c4d5c9c43068f2afe457" translate="yes" xml:space="preserve">
          <source>For example, you might want to enable configuration formats like the following:</source>
          <target state="translated">예를 들어 다음과 같은 구성 형식을 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f678f7a6798df2a555b214e68d162f307fd8e326" translate="yes" xml:space="preserve">
          <source>For examples of afterAdd and beforeRemove see &lt;a href=&quot;http://knockoutjs.com/examples/animatedTransitions.html&quot;&gt;animated transitions&lt;/a&gt;.</source>
          <target state="translated">afterAdd 및 beforeRemove의 예는 &lt;a href=&quot;http://knockoutjs.com/examples/animatedTransitions.html&quot;&gt;애니메이션 전환을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="05e3b099a296c9a13aa7e5074fa8572b152dae60" translate="yes" xml:space="preserve">
          <source>For examples of afterAdd and beforeRemove see &lt;a href=&quot;https://knockoutjs.com/examples/animatedTransitions.html&quot;&gt;animated transitions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eebaa938c7aaf194d0d6134712c9458bdd1e31e" translate="yes" xml:space="preserve">
          <source>For functions that modify the contents of the array, such as push and splice, KO&amp;rsquo;s methods automatically trigger the dependency tracking mechanism so that all registered listeners are notified of the change, and your UI is automatically updated which means there is a significant difference between using KO&amp;rsquo;s methods (i.e., observableArray.push(...) ) and JavaScript native array methods (i.e., observableArray().push(...)) as the latter don&amp;rsquo;t send any notification to the array&amp;rsquo;s subscribers that its content has changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74fee50827f83055c14d664c8ae49efc9b3ea847" translate="yes" xml:space="preserve">
          <source>For functions that modify the contents of the array, such as push and splice, KO&amp;rsquo;s methods automatically trigger the dependency tracking mechanism so that all registered listeners are notified of the change, and your UI is automatically updated.</source>
          <target state="translated">푸시 및 스플 라이스와 같이 배열의 내용을 수정하는 함수의 경우 KO의 메소드는 종속성 추적 메커니즘을 자동으로 트리거하여 등록 된 모든 리스너에게 변경 사항을 알리고 UI가 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="76a00e59b8c3067b079a7bc20c769830ca1ae02b" translate="yes" xml:space="preserve">
          <source>For information about how to pass additional parameters to your submit handler function, or how to control the this handle when invoking functions that aren&amp;rsquo;t on your view model, see the notes relating to the &lt;a href=&quot;click-binding&quot;&gt;click binding&lt;/a&gt;. All the notes on that page apply to submit handlers too.</source>
          <target state="translated">제출 핸들러 함수에 추가 매개 변수를 전달하는 방법 또는보기 모델에없는 함수를 호출 할 때이 핸들을 제어하는 ​​방법에 대한 정보는 &lt;a href=&quot;click-binding&quot;&gt;클릭 바인딩&lt;/a&gt; 과 관련된 참고 사항을 참조하십시오 . 해당 페이지의 모든 노트는 제출 핸들러에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c7f48a902247b730ada79fe82babfb437d3afca3" translate="yes" xml:space="preserve">
          <source>For loading, update your view model using data that you&amp;rsquo;ve received using one of the above techniques</source>
          <target state="translated">로드하려면 위의 기술 중 하나를 사용하여받은 데이터를 사용하여 뷰 모델을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="7adb7866a71f6f46b996a32c046194acab2ca099" translate="yes" xml:space="preserve">
          <source>For more control, pass a JavaScript object with some combination of the following properties:</source>
          <target state="translated">더 많은 제어를 위해 다음 속성을 조합하여 JavaScript 객체를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="ad4b6504c8a1b8acae6adc1c35890de1f949db77" translate="yes" xml:space="preserve">
          <source>For more details about these observableArray functions, see the equivalent documentation of the &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array#Methods_2&quot;&gt;standard JavaScript array functions&lt;/a&gt;.</source>
          <target state="translated">이러한 observableArray 함수에 대한 자세한 내용은 &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array#Methods_2&quot;&gt;표준 JavaScript 배열 함수&lt;/a&gt; 의 해당 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="33ebce62a68ac66ad4bdebcd712e571477e40bce" translate="yes" xml:space="preserve">
          <source>For more information about $index and other context properties such as $parent, see documentation for &lt;a href=&quot;binding-context&quot;&gt;binding context properties&lt;/a&gt;.</source>
          <target state="translated">$ index 및 $ parent와 같은 기타 컨텍스트 속성에 대한 자세한 내용은 컨텍스트 속성 &lt;a href=&quot;binding-context&quot;&gt;바인딩에&lt;/a&gt; 대한 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d002e63ef2bdfe307b7dc6dd93d11d5d0f3420e" translate="yes" xml:space="preserve">
          <source>For saving, get your view model data into a simple JSON format so you can send it using one of the above techniques</source>
          <target state="translated">저장하려면 뷰 모델 데이터를 간단한 JSON 형식으로 가져 오면 위의 기술 중 하나를 사용하여 전송할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ed6deeffb9be7ad51042e1a135e3e9e951b890d" translate="yes" xml:space="preserve">
          <source>For the using binding, although you can use this option, it would generally be more efficient and descriptive to use the &lt;a href=&quot;let-binding&quot;&gt;let binding&lt;/a&gt; instead. Rather than using: currentPerson, as: 'person', noChildContext: true, you&amp;rsquo;d use let: { person: currentPerson }.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e09e1e68bd9f09528070843f84d40f2039aa8c2" translate="yes" xml:space="preserve">
          <source>For the using binding, descendant elements will remain in the document and their bindings re-evaluated with the new context value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96f20975442dd142df3dfc2e9186957414d588e0" translate="yes" xml:space="preserve">
          <source>For the using binding, it is generally incorrect to supply a null or undefined value since it will try to use that value as the context for descendant elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d299f2d31774daca6f4077fc8efaadbf7175a173" translate="yes" xml:space="preserve">
          <source>For the with binding, descendant elements will &lt;em&gt;not&lt;/em&gt; be bound at all, but will instead be removed from the document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d1234d03268a26c263a165b8d5a4f87d33c04e4" translate="yes" xml:space="preserve">
          <source>For the with binding, descendant elements will be cleared out, and &lt;strong&gt;a new copy of the markup&lt;/strong&gt; will be added to your document and bound in the context of the new value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22b50f0de3d7cac900daaf7c9e5b4041689cd2f" translate="yes" xml:space="preserve">
          <source>For this to work, the files &lt;a href=&quot;files/component-like-widget.js&quot;&gt;files/component-like-widget.js&lt;/a&gt; and &lt;a href=&quot;files/component-like-widget&quot;&gt;files/component-like-widget.html&lt;/a&gt; need to exist. Check them out (and &lt;em&gt;view source&lt;/em&gt; on the .html one) - as you&amp;rsquo;ll see, this is cleaner and more convenient that including the code inline in the definition.</source>
          <target state="translated">이것이 작동하려면 files &lt;a href=&quot;files/component-like-widget.js&quot;&gt;/ component-like-widget.js &lt;/a&gt;&lt;a href=&quot;files/component-like-widget&quot;&gt;파일&lt;/a&gt; 과 files / component-like-widget.html 파일 이 존재해야합니다. 그것들을 확인하십시오 (그리고 .html &lt;em&gt;소스&lt;/em&gt; 를보십시오). 보시다시피, 정의에 코드 인라인을 포함하는 것이 더 깨끗하고 편리합니다.</target>
        </trans-unit>
        <trans-unit id="5b3f6e3b0f1ca1f18fefa1a37d9ba45e25616b20" translate="yes" xml:space="preserve">
          <source>Forcing computed observables to always notify subscribers</source>
          <target state="translated">계산 된 관측 가능 항목을 항상 구독자에게 알리도록 강제</target>
        </trans-unit>
        <trans-unit id="84662a42c470dcc749e4f555eafc404bee27a93f" translate="yes" xml:space="preserve">
          <source>Forcing deferred notifications to happen early</source>
          <target state="translated">지연된 알림이 일찍 발생하도록 강제</target>
        </trans-unit>
        <trans-unit id="5f499a5d8b4de8fa658740f93586939f3677a5ae" translate="yes" xml:space="preserve">
          <source>Forcing deferred observables to always notify subscribers</source>
          <target state="translated">지연된 관찰 가능 항목이 항상 구독자에게 통지하도록 강요</target>
        </trans-unit>
        <trans-unit id="98d0c19699f7a2e290891f5a4e98f8719c1258d5" translate="yes" xml:space="preserve">
          <source>Forcing observables to always notify subscribers</source>
          <target state="translated">관찰자에게 항상 가입자에게 알리도록 강요</target>
        </trans-unit>
        <trans-unit id="f54bb0060ff337df25025c131396a49f22403fe7" translate="yes" xml:space="preserve">
          <source>Forcing rate-limited observables to always notify subscribers</source>
          <target state="translated">속도 제한 옵저버 블이 항상 가입자에게 알리도록 강요</target>
        </trans-unit>
        <trans-unit id="6e02a1c244564b921ceb8e82920afc310566e328" translate="yes" xml:space="preserve">
          <source>Full details:</source>
          <target state="translated">자세한 내용 :</target>
        </trans-unit>
        <trans-unit id="2c93794a5d7ef6cb3e1c45af5db6db00afa54472" translate="yes" xml:space="preserve">
          <source>Functions on your view model are slightly special because you can reference them by name, i.e., you can write submit: doSomething and &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; have to write submit: viewModel.doSomething (though technically that&amp;rsquo;s also valid).</source>
          <target state="translated">뷰 모델의 함수는 이름으로 참조 할 수 있기 때문에 약간 특별합니다. 즉, submit : doSomething을 작성할 수 있고 submit : viewModel.doSomething을 작성할 &lt;em&gt;필요는 없습니다&lt;/em&gt; (기술적으로도 유효합니다).</target>
        </trans-unit>
        <trans-unit id="45c386b929cd8059a6ebbcf8d5cf6632dffb76e7" translate="yes" xml:space="preserve">
          <source>Functions you can implement</source>
          <target state="translated">구현할 수있는 기능</target>
        </trans-unit>
        <trans-unit id="5b8ebd236050a24d7ee285b263736dd0ada77452" translate="yes" xml:space="preserve">
          <source>Generally, the best way to perform such post-processing on DOM elements is to write a &lt;a href=&quot;custom-bindings&quot;&gt;custom binding&lt;/a&gt;, but if you really just want to access the raw DOM elements emitted by a template, you can use afterRender.</source>
          <target state="translated">일반적으로 DOM 요소에서 이러한 사후 처리를 수행하는 가장 좋은 방법은 &lt;a href=&quot;custom-bindings&quot;&gt;사용자 정의 바인딩&lt;/a&gt; 을 작성하는 것이지만 실제로 템플릿에서 생성 된 원시 DOM 요소에 액세스하려는 경우 afterRender를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74b46ff2fa2d37b0a8e7636b52d4e4152c5f19f8" translate="yes" xml:space="preserve">
          <source>Generally, there would be little reason to subscribe to the childrenComplete event in such a binding since it would be the same as just running your post-processing code after ko.applyBindingsToDescendants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc53371ed103fecb3625d6b54a824260aab0b6d" translate="yes" xml:space="preserve">
          <source>Going back to the classic &amp;ldquo;first name + last name = full name&amp;rdquo; example, you can turn things back-to-front: make the fullName computed observable writable, so that the user can directly edit the full name, and their supplied value will be parsed and mapped back to the underlying firstName and lastName observables. In this example, the write callback handles incoming values by splitting the incoming text into &amp;ldquo;firstName&amp;rdquo; and &amp;ldquo;lastName&amp;rdquo; components, and writing those values back to the underlying observables.</source>
          <target state="translated">고전적인&amp;ldquo;이름 + 성 = 성명&amp;rdquo;예로 돌아가서, 항목을 다시 앞뒤로 돌릴 수 있습니다. fullName을 계산 가능한 관측 가능하게 작성하여 사용자가 성명을 직접 편집 할 수 있도록하고 제공된 값은 구문 분석되어 기본 firstName 및 lastName 관찰 가능 항목으로 다시 매핑됩니다. 이 예제에서 쓰기 콜백은 들어오는 텍스트를 &quot;firstName&quot;및 &quot;lastName&quot;구성 요소로 나누고 해당 값을 기본 관찰 가능 항목에 다시 써서 들어오는 값을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="e790fc9db2ebd2516f36edd273ef2c230b8019be" translate="yes" xml:space="preserve">
          <source>HTML5-era browsers, which includes &lt;strong&gt;Internet Explorer 9&lt;/strong&gt; and later, automatically allow for custom elements with no difficulties.</source>
          <target state="translated">&lt;strong&gt;Internet Explorer 9 이상&lt;/strong&gt; 이 포함 된 HTML5 시대의 브라우저는 자동으로 사용자 지정 요소를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="db3faaddbfebaf215e63526cf28c5c5fa9f0ccf7" translate="yes" xml:space="preserve">
          <source>Headline features:</source>
          <target state="translated">헤드 라인 기능 :</target>
        </trans-unit>
        <trans-unit id="4e7751af05ac722a6fb5ef531e8dadad667d4de0" translate="yes" xml:space="preserve">
          <source>Here a few situations in which you might want to use these mapping options.</source>
          <target state="translated">다음은 이러한 매핑 옵션을 사용하려는 몇 가지 상황입니다.</target>
        </trans-unit>
        <trans-unit id="6ec4c1a3ba1febd520b968b83993af24bd3d1248" translate="yes" xml:space="preserve">
          <source>Here are examples of how the changes are reported:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc2db2d3dd09d2d25123ee5014cb4e846965eaa" translate="yes" xml:space="preserve">
          <source>Here is a basic example of setting values using let that are then available in all descendant elements, regardless of context changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6e69de42d839b42bf754d25ca92cab286df4be6" translate="yes" xml:space="preserve">
          <source>Here is a very basic example of switching the binding context to a child object. Notice that in the data-bind attributes, it is &lt;em&gt;not&lt;/em&gt; necessary to prefix latitude or longitude with coords., because the binding context is switched to coords.</source>
          <target state="translated">다음은 바인딩 컨텍스트를 자식 개체로 전환하는 매우 기본적인 예입니다. 데이터 바인딩 특성 에서 바인딩 컨텍스트가 좌표로 전환되므로 위도 또는 경도 앞에 좌표를 추가 할 필요 가 &lt;em&gt;없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b82739780a396a71434b267de5bea3a454dbbe20" translate="yes" xml:space="preserve">
          <source>Here is an example of a configuration that will add some text to the incoming data before updating:</source>
          <target state="translated">다음은 업데이트하기 전에 수신 데이터에 텍스트를 추가하는 구성의 예입니다.</target>
        </trans-unit>
        <trans-unit id="3280dba535f19f2febc60673f89c1a84ba00d47d" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s &lt;a href=&quot;http://jsfiddle.net/rniemeyer/NW5Vn/&quot;&gt;a simple implementation of integrating Underscore templates with Knockout&lt;/a&gt;. The integration code is just 16 lines long, but it&amp;rsquo;s enough to support Knockout data-bind attributes (and hence nested templates) and Knockout &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; variables ($parent, $root, etc.).</source>
          <target state="translated">&lt;a href=&quot;http://jsfiddle.net/rniemeyer/NW5Vn/&quot;&gt;Underscore 템플릿과 Knockout 통합의 간단한 구현은&lt;/a&gt; 다음과 같습니다 . 통합 코드의 길이는 16 줄에 불과하지만 녹아웃 데이터 바인딩 속성 (및 중첩 템플릿)과 녹아웃 &lt;a href=&quot;binding-context&quot;&gt;바인딩 컨텍스트&lt;/a&gt; 변수 ($ parent, $ root 등) 를 지원하기에 충분합니다 .</target>
        </trans-unit>
        <trans-unit id="84443bf9a128caa94205efa8ada501ff154e881b" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a trivial example that uses afterAdd to apply the classic &amp;ldquo;yellow fade&amp;rdquo; effect to newly-added items. It requires the &lt;a href=&quot;https://github.com/jquery/jquery-color&quot;&gt;jQuery Color plugin&lt;/a&gt; to enable animation of background colors.</source>
          <target state="translated">다음은 afterAdd를 사용하여 클래식 한&amp;ldquo;노란색 페이드&amp;rdquo;효과를 새로 추가 한 항목에 적용하는 간단한 예입니다. &lt;a href=&quot;https://github.com/jquery/jquery-color&quot;&gt;배경색&lt;/a&gt; 애니메이션을 사용 하려면 jQuery Color 플러그인 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="37cf14e229e69417a43a02c23085e0aa99c73561" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s a way to define a filterByProperty function that will become available on all subsequently-created ko.observableArray instances:</source>
          <target state="translated">다음에 생성 된 모든 ko.observableArray 인스턴스에서 사용할 수있는 filterByProperty 함수를 정의하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8fb66c98e55cbff21c223380e9a5374ec4c0a1ef" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example configuration:</source>
          <target state="translated">구성 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b05ce77e66ba4c65f03af6e3ab19e65b03d68454" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example of using the above custom binding:</source>
          <target state="translated">위의 사용자 정의 바인딩을 사용하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66b583251e6c4a39e879523f6accea2dbf4b4259" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s an example that uses optionsAfterRender to add a disable binding to each option.</source>
          <target state="translated">다음은 optionsAfterRender를 사용하여 각 옵션에 비활성화 바인딩을 추가하는 예제입니다.</target>
        </trans-unit>
        <trans-unit id="30b31c34d144c1947d36ca331230826869c8a16e" translate="yes" xml:space="preserve">
          <source>How Knockout loads components via AMD</source>
          <target state="translated">녹아웃이 AMD를 통해 구성 요소를로드하는 방법</target>
        </trans-unit>
        <trans-unit id="7e306597890108bc7fc111d560e6054689ac6ebc" translate="yes" xml:space="preserve">
          <source>How dependency tracking works</source>
          <target state="translated">의존성 추적 작동 방식</target>
        </trans-unit>
        <trans-unit id="93fddf00520975913c2fecc46ee1c69334b1426a" translate="yes" xml:space="preserve">
          <source>How is Knockout different?</source>
          <target state="translated">녹아웃은 어떻게 다릅니 까?</target>
        </trans-unit>
        <trans-unit id="47ba114c765ebcdb727f9bec12dc3ebaf5886692" translate="yes" xml:space="preserve">
          <source>How things are mapped</source>
          <target state="translated">사물이 매핑되는 방법</target>
        </trans-unit>
        <trans-unit id="361fb2674c6c2b62b9aae1a7ce5281fcff2e1a0b" translate="yes" xml:space="preserve">
          <source>How to create an extender</source>
          <target state="translated">익스텐더를 만드는 방법</target>
        </trans-unit>
        <trans-unit id="ae005b5e0ed8d5109a9c1e98c6cbd19a088774bc" translate="yes" xml:space="preserve">
          <source>However, if you &lt;em&gt;do&lt;/em&gt; want to let the default action proceed, just return true from your event handler function.</source>
          <target state="translated">당신이 그러나 &lt;em&gt;할&lt;/em&gt; 기본 작업을 진행하게 할, 당신의 이벤트 핸들러 함수에서 true를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="64ce42b8e7f69d107832250d68dbd01a878deeb2" translate="yes" xml:space="preserve">
          <source>However, if you &lt;em&gt;do&lt;/em&gt; want to let the default click action proceed, just return true from your click handler function.</source>
          <target state="translated">당신은 그러나 &lt;em&gt;않는&lt;/em&gt; 기본 클릭 작업을 진행하게 할, 당신의 클릭 핸들러 함수에서 true를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="a6e2915dc92ca412b52398579f1e49c3c8348959" translate="yes" xml:space="preserve">
          <source>However, if you use value to link a form element to a &lt;em&gt;non&lt;/em&gt;-observable property (e.g., a plain old string, or an arbitrary JavaScript expression), KO will do the following:</source>
          <target state="translated">그러나 value를 사용하여 양식 요소를 관찰 할 수 &lt;em&gt;없는&lt;/em&gt; 속성 (예 : 일반 오래된 문자열 또는 임의의 JavaScript 식)에 연결하면 KO는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8c30fbacefa412111122658b9f8bc072a603ddd1" translate="yes" xml:space="preserve">
          <source>However, it does &lt;em&gt;not&lt;/em&gt; work with virtual elements. If you try the following:</source>
          <target state="translated">그러나 가상 요소 &lt;em&gt;에서는&lt;/em&gt; 작동 하지 &lt;em&gt;않습니다&lt;/em&gt; . 다음을 시도하면</target>
        </trans-unit>
        <trans-unit id="8531b5d91c66d42745ea8deb05f270abe4564d92" translate="yes" xml:space="preserve">
          <source>However, it does not make sense to use bindings that would modify the element&amp;rsquo;s contents, such as the &lt;a href=&quot;text-binding&quot;&gt;text&lt;/a&gt; or &lt;a href=&quot;template-binding&quot;&gt;template&lt;/a&gt; bindings, since they would overwrite the template injected by your component.</source>
          <target state="translated">그러나 &lt;a href=&quot;text-binding&quot;&gt;텍스트&lt;/a&gt; 또는 &lt;a href=&quot;template-binding&quot;&gt;템플릿&lt;/a&gt; 바인딩 과 같이 요소의 내용을 수정하는 바인딩은 구성 요소에서 삽입 한 템플릿을 덮어 쓰므로 바인딩을 사용하는 것이 적합하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8b2c1d7baa87a948e36706143a1b3bd56c309bf4" translate="yes" xml:space="preserve">
          <source>However, many developers prefer to use a more conventions-based approach to updating their view models using incoming data without manually writing a line of code for every property to be updated. This can be beneficial if your view models have many properties, or deeply nested data structures, because it can greatly reduce the amount of manual mapping code you need to write. For more details about this technique, see &lt;a href=&quot;plugins-mapping&quot;&gt;the knockout.mapping plugin&lt;/a&gt;.</source>
          <target state="translated">그러나 많은 개발자는 업데이트 할 모든 속성에 대한 코드 줄을 수동으로 작성하지 않고 들어오는 데이터를 사용하여 뷰 모델을 업데이트하기 위해 더 많은 규칙 기반 접근 방식을 선호합니다. 이는 뷰 모델에 많은 속성 또는 중첩 된 데이터 구조가있는 경우 작성해야하는 수동 매핑 코드의 양을 크게 줄일 수 있으므로 유용합니다. 이 기술에 대한 자세한 내용은 &lt;a href=&quot;plugins-mapping&quot;&gt;knockout.mapping 플러그인을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="df78c9be1d978ee24c637cf614f8f43143a6b702" translate="yes" xml:space="preserve">
          <source>However, sometimes you might not want that behavior. If instead you want Knockout to allow your model observable to take values that have no corresponding entry in the &amp;lt;select&amp;gt;, then specify valueAllowUnset: true. In this case, whenever your model value cannot be represented in the &amp;lt;select&amp;gt;, then the &amp;lt;select&amp;gt; simply has no selected value at that time, which is visually represented by it being blank. When the user later selects an entry from the dropdown, this will be written to your model as usual. For example:</source>
          <target state="translated">그러나 때로는 해당 동작을 원하지 않을 수도 있습니다. 대신 Knockout에서 모델 옵저버 블이 &amp;lt;select&amp;gt;에 해당 항목이없는 값을 가져 오도록하려면 valueAllowUnset : true를 지정하십시오. 이 경우 &amp;lt;select&amp;gt;에 모델 값을 표시 할 수 없을 때마다 &amp;lt;select&amp;gt;에는 해당 시간에 선택된 값이 없으므로 시각적으로 공백으로 표시됩니다. 사용자가 나중에 드롭 다운에서 항목을 선택하면 평소대로 모델에 기록됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0df1b7294fed0a051d101c1ced30ea172ab4baf7" translate="yes" xml:space="preserve">
          <source>However, the value of the computed property is itself an observable. This would seem to lead to an awkward scenario, where reading its current value would involve double-unwrapping (i.e., params.myExpr()(), where the first parentheses give the value of the expression, and the second give the value of the resulting observable instance).</source>
          <target state="translated">그러나 계산 된 속성의 값 자체는 관찰 가능합니다. 이는 현재 값을 읽는 데 이중 언 래핑 (즉, params.myExpr () ())이 수반되는 어색한 시나리오로 이어질 수 있습니다. 여기서 첫 번째 괄호는 표현식의 값을 제공하고 두 번째는 결과 관찰 가능 인스턴스).</target>
        </trans-unit>
        <trans-unit id="be4ce8e4d8bb3b24ee5b708a10a1169afa34a1e3" translate="yes" xml:space="preserve">
          <source>IE 6 does not allow radio buttons to be checked if they don&amp;rsquo;t have a name attribute. Most of the time this is irrelevant because your radio button elements &lt;em&gt;will&lt;/em&gt; have name attributes to put them into mutually-exclusive groups. However, just in case you didn&amp;rsquo;t add a name attribute because it&amp;rsquo;s unnecessary in your case, KO will internally use uniqueName on those elements to ensure they can be checked.</source>
          <target state="translated">IE 6에서는 이름 속성이없는 라디오 버튼을 확인할 수 없습니다. 라디오 버튼 요소가 있기 때문에이 관계가 대부분의 시간을 &lt;em&gt;것이다&lt;/em&gt; 상호 배타적 그룹으로 넣어 이름 속성이 있습니다. 그러나 귀하의 경우 불필요하기 때문에 이름 속성을 추가하지 않은 경우 KO는 내부적으로 해당 요소에 uniqueName을 사용하여 확인할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="2fcefc92a53613238743a06738a1a958455ef2e0" translate="yes" xml:space="preserve">
          <source>IE 6 has a strange quirk whereby it sometimes ignores whitespace that immediately follows an empty span. This has nothing directly to do with Knockout, but in case you do want to write:</source>
          <target state="translated">IE 6에는 이상한 스 쿼크가있어 빈 스팬 바로 뒤에 오는 공백을 무시합니다. 이것은 Knockout과 직접 관련이 없지만 다음과 같이 작성하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="91559d59670bd974a48fef061e5a488f693ecb19" translate="yes" xml:space="preserve">
          <source>IE 6-8&amp;rsquo;s HTML parser will discard any unrecognized elements. To ensure it doesn&amp;rsquo;t throw out your custom elements, you must do one of the following:</source>
          <target state="translated">IE 6-8의 HTML 파서는 인식 할 수없는 요소를 버립니다. 사용자 지정 요소가 삭제되지 않도록하려면 다음 중 하나를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d16b47ea598c9827309c0d43dee7b26141e40d5" translate="yes" xml:space="preserve">
          <source>If a binding includes a manual subscription, this can be set to dispose automatically by calling its disposeWhenNodeIsRemoved method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fa5f5e45ca2c0ef94cde806f22f9193ea7e171a" translate="yes" xml:space="preserve">
          <source>If a dependency is on an external object, then be sure to use .dispose() on the computed property, otherwise it (and possibly also your viewmodel) will be held in memory. Alternatively, consider using a &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;pure&lt;/em&gt; computed&lt;/a&gt; to avoid the need for manual disposal.</source>
          <target state="translated">종속성이 외부 객체에있는 경우 계산 된 속성에 .dispose ()를 사용해야합니다. 그렇지 않으면 해당 속성 (및 뷰 모델)이 메모리에 유지됩니다. 또는 수동으로 처리 할 필요가 없도록 &lt;a href=&quot;computed-pure&quot;&gt;&lt;em&gt;순수한&lt;/em&gt; 계산&lt;/a&gt; 을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d97a8252f992217661b3da8e9168c34da29b4082" translate="yes" xml:space="preserve">
          <source>If a parameter&amp;rsquo;s evaluation &lt;strong&gt;does not&lt;/strong&gt; involve evaluating an observable/computed, it is passed literally.</source>
          <target state="translated">매개 변수의 평가 에 관찰 가능 / 계산 된 평가 &lt;strong&gt;가&lt;/strong&gt; 포함 &lt;strong&gt;되지 않으면&lt;/strong&gt; 문자 그대로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="85bdcb92d8fed08ef07c5a9167f6303fb9542783" translate="yes" xml:space="preserve">
          <source>If a parameter&amp;rsquo;s evaluation &lt;strong&gt;does&lt;/strong&gt; involve evaluating one or more observables/computeds, it is passed as a computed property so that you can react to changes in the parameter value.</source>
          <target state="translated">매개 변수의 평가에 하나 이상의 관찰 가능 / 계산 된 평가 &lt;strong&gt;가&lt;/strong&gt; 포함되는 경우 매개 변수 값의 변경에 반응 할 수 있도록 계산 된 속성으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="1f49d13df2276280d49d2672aa1b68bc3513435f" translate="yes" xml:space="preserve">
          <source>If a task throws an exception, it will not interrupt the task queue, which will continue until it is empty. The exception will instead be postponed to a later event and can be handled using &lt;a href=&quot;asynchronous-error-handling&quot;&gt;ko.onError&lt;/a&gt; or window.onerror.</source>
          <target state="translated">작업에서 예외가 발생하면 작업 대기열이 중단되지 않고 비어있을 때까지 계속됩니다. 대신 예외는 이후 이벤트로 연기되며 &lt;a href=&quot;asynchronous-error-handling&quot;&gt;ko.onError&lt;/a&gt; 또는 window.onerror를 사용하여 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0e58b3f0b1346e29b75ea079a4a3af7f374c623" translate="yes" xml:space="preserve">
          <source>If any of the parameters passed to the component is observable, then the component can of course observe any changes, or even write back modified values. This is how it can communicate cleanly with its parent, without tightly coupling the component code to any parent that uses it.</source>
          <target state="translated">구성 요소에 전달 된 매개 변수가 관찰 가능한 경우 구성 요소는 물론 모든 변경 사항을 관찰하거나 수정 된 값을 다시 쓸 수 있습니다. 이것은 컴포넌트 코드를 사용하는 상위 코드와 구성 요소 코드를 밀접하게 연결하지 않고도 상위와 깨끗하게 통신 할 수있는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d2042df6fe8e9a541f83353153b54cf9ca0fb63e" translate="yes" xml:space="preserve">
          <source>If declared, Knockout will call this function to convert a componentConfig object into a viewmodel/template pair.</source>
          <target state="translated">선언되면 Knockout은 componentConfig 객체를 뷰 모델 / 서식 파일 쌍으로 변환하기 위해이 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="399dea5a85a9f6316a3592794fb48cd5d6a619e0" translate="yes" xml:space="preserve">
          <source>If declared, Knockout will call this function to obtain a configuration object for each component being instantiated.</source>
          <target state="translated">선언되면 Knockout은이 함수를 호출하여 인스턴스화되는 각 구성 요소에 대한 구성 객체를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="be4cb475157b09548b6d107ebd37c013b2c16886" translate="yes" xml:space="preserve">
          <source>If defined, this function will be called for each &amp;lt;name&amp;gt; binding before the binding is evaluated.</source>
          <target state="translated">정의 된 경우 바인딩이 평가되기 전에 각 &amp;lt;name&amp;gt; 바인딩에 대해이 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6a046840fb4cbdaaea31db2bea0e71b5d3908b95" translate="yes" xml:space="preserve">
          <source>If defined, this function will be called for each DOM node before bindings are processed. The function can modify, remove, or replace node. Any new nodes must be inserted immediately before node, and if any nodes were added or node was removed, the function must return an array of the new nodes that are now in the document in place of node.</source>
          <target state="translated">정의 된 경우 바인딩이 처리되기 전에 각 DOM 노드에 대해이 함수가 호출됩니다. 이 기능은 노드를 수정, 제거 또는 교체 할 수 있습니다. 노드 바로 앞에 새 노드를 삽입해야하며, 노드가 추가되었거나 노드가 제거 된 경우이 함수는 노드 대신 문서에있는 새 노드의 배열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="8a2cb3b57840c0deef2eb7e49e7b4db257ff08df" translate="yes" xml:space="preserve">
          <source>If no viewmodel is given, the component is treated as a simple block of HTML that will be bound to any parameters passed to the component.</source>
          <target state="translated">뷰 모델이 제공되지 않으면 구성 요소는 구성 요소에 전달 된 모든 매개 변수에 바인딩되는 간단한 HTML 블록으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="6caa6867d855ce7ca277ec137fe7e6b2092a7de4" translate="yes" xml:space="preserve">
          <source>If required, you can remove ko.components.defaultLoader from the loaders array altogether.</source>
          <target state="translated">필요한 경우 로더 배열에서 ko.components.defaultLoader를 모두 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03317c5ba9cb772a076d1cd9742af2eaadf6c3ea" translate="yes" xml:space="preserve">
          <source>If the array you supply is observable, the foreach binding will respond to any future changes in the array&amp;rsquo;s contents by adding or removing corresponding sections of markup in the DOM.</source>
          <target state="translated">제공하는 배열이 관찰 가능한 경우 foreach 바인딩은 DOM에서 마크 업의 해당 섹션을 추가하거나 제거하여 배열 내용의 향후 변경에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="612f5263f91277945f3c298ba4abc465bd6747bb" translate="yes" xml:space="preserve">
          <source>If the checkedValue parameter is set, that value is used instead of true to represent a &lt;em&gt;checked&lt;/em&gt; status, and an &lt;em&gt;unchecked&lt;/em&gt; status is represented with a value of undefined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b72ef00d24a33559e687f508a59c22e7850ec79c" translate="yes" xml:space="preserve">
          <source>If the component binding&amp;rsquo;s name value changes observably, or if an enclosing control-flow binding causes the container element to be removed, then any dispose function on the viewmodel is called just before the container element is removed from the DOM. See also: &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;disposal and memory management&lt;/a&gt;.</source>
          <target state="translated">구성 요소 바인딩의 이름 값이 눈에 띄게 변경되거나 둘러싸는 제어 흐름 바인딩으로 인해 컨테이너 요소가 제거되면 컨테이너 요소가 DOM에서 제거되기 직전에 뷰 모델의 모든 폐기 함수가 호출됩니다. &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;처리 및 메모리 관리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1da622aea8b5c8a482d41ae46dd18ebd2d3a51d5" translate="yes" xml:space="preserve">
          <source>If the expression you provide to the let binding unwraps any observables, each descendant binding will include an additional dependency on the let binding. This is true whether or not the binding references any of the custom context properties. If you want to make an observable value available through let, it is generally better to set the observable itself rather than unwrap it and set the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354afd97c35f636203d9262ca360ec893a10aa03" translate="yes" xml:space="preserve">
          <source>If the expression you supply evaluates to null or undefined, descendant elements will &lt;em&gt;not&lt;/em&gt; be bound at all, but will instead be removed from the document.</source>
          <target state="translated">제공 한 표현식이 널 또는 정의되지 않은 것으로 평가되면 하위 요소는 &lt;em&gt;전혀&lt;/em&gt; 바인드 &lt;em&gt;되지&lt;/em&gt; 않고 대신 문서에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="348434b438cb1d0346b5c2336a1b0270a699841f" translate="yes" xml:space="preserve">
          <source>If the expression you supply involves any observable values, the expression will be re-evaluated whenever any of those observables change. Then, descendant elements will be cleared out, and &lt;strong&gt;a new copy of the markup&lt;/strong&gt; will be added to your document and bound in the context of the new evaluation result.</source>
          <target state="translated">제공하는 식에 관측 가능한 값이 포함 된 경우 해당 관측 가능 항목이 변경 될 때마다식이 다시 평가됩니다. 그런 다음 하위 요소가 지워지고 &lt;strong&gt;새 마크 업 사본이&lt;/strong&gt; 문서에 추가되고 새 평가 결과와 관련하여 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="3f2e0923cee18f9719776d03929fd49911724f4b" translate="yes" xml:space="preserve">
          <source>If the expression you supply involves any observable values, the expression will be re-evaluated whenever any of those observables change. These bindings differ in how they react when the bound value changes:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623412eb267c55f2826cce3e4419e3b4cba4388f" translate="yes" xml:space="preserve">
          <source>If the expression you supply unwraps any observable values, the expression will be re-evaluated whenever any of those observables change. Additionally, the bindings for all descendant elements will be re-evaluated as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a61935dcf249e331edbcc8210b8ebbb2409b5384" translate="yes" xml:space="preserve">
          <source>If the firstName observable&amp;rsquo;s value was changed to Ted, then the console would show first name: Ted.</source>
          <target state="translated">firstName observable의 값이 Ted로 변경된 경우 콘솔에 이름이 Ted로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="90ee5b54e158b99edb3b0d00a6d84366ceb29486" translate="yes" xml:space="preserve">
          <source>If the user manually focuses or unfocuses the associated element, the viewmodel property will be set to true or false accordingly.</source>
          <target state="translated">사용자가 관련 요소에 수동으로 초점을 맞추거나 초점을 맞추지 않으면 viewmodel 속성이 그에 따라 true 또는 false로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="bbaee0a673e126908759d4192388e02a5778a34a" translate="yes" xml:space="preserve">
          <source>If the value you supply is observable, the hasFocus binding will update the element&amp;rsquo;s focus state whenever that observable value changes.</source>
          <target state="translated">제공 한 값을 관찰 할 수있는 경우 hasFocus 바인딩은 관찰 가능한 값이 변경 될 때마다 요소의 포커스 상태를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="b5c5acd515e8ae2158bb6854344b82731dca4d6c" translate="yes" xml:space="preserve">
          <source>If the viewmodel is given as a constructor function, this means Knockout calls new YourViewModel(params).</source>
          <target state="translated">뷰 모델이 생성자 함수로 제공되는 경우, 녹아웃은 새로운 YourViewModel (params)을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="73a19cfa23e05247f726bb0c3e3e11110deb972d" translate="yes" xml:space="preserve">
          <source>If the viewmodel is given as a createViewModel factory function, Knockout calls createViewModel(params, componentInfo), where componentInfo.element is the element into which the not-yet-bound template has already been injected.</source>
          <target state="translated">viewmodel이 createViewModel 팩토리 함수로 제공되는 경우, Knockout은 createViewModel (params, componentInfo)을 호출합니다. 여기서 componentInfo.element는 아직 바인딩되지 않은 템플리트가 이미 삽입 된 요소입니다.</target>
        </trans-unit>
        <trans-unit id="105d045e38636fe798ecdb5a45a203d90df04fff" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s available options whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s available options once and will not update them again later.</source>
          <target state="translated">이 매개 변수가 관찰 가능한 값이면 바인딩은 값이 변경 될 때마다 요소의 사용 가능한 옵션을 업데이트합니다. 매개 변수를 관찰 할 수없는 경우 요소의 사용 가능한 옵션을 한 번만 설정하고 나중에 다시 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb1eb730b6d4db61f330d71ef6135d8fac903258" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s content whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s content once and will not update it again later.</source>
          <target state="translated">이 매개 변수가 관찰 가능한 값이면 바인딩은 값이 변경 될 때마다 요소의 내용을 업데이트합니다. 매개 변수를 관찰 할 수 없으면 요소의 컨텐츠를 한 번만 설정하고 나중에 다시 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d54c813843091459c90fd11e7297fc0446687938" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s text whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s text once and will not update it again later.</source>
          <target state="translated">이 매개 변수가 관찰 가능한 값이면 바인딩은 값이 변경 될 때마다 요소의 텍스트를 업데이트합니다. 매개 변수를 관찰 할 수없는 경우 요소의 텍스트를 한 번만 설정하고 나중에 다시 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a744e971b96b18141128533922f19a87beb8881" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s value whenever the observable value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s value once and will not update it again later.</source>
          <target state="translated">이 매개 변수가 관찰 가능 값이면 바인딩은 관찰 가능 값이 변경 될 때마다 요소의 값을 업데이트합니다. 매개 변수를 관찰 할 수 없으면 요소 값을 한 번만 설정하고 나중에 다시 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47eda63e6c27e664a420f7aabc543742f5f58f16" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s value whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s value once and will not update it again later.</source>
          <target state="translated">이 매개 변수가 관찰 가능한 값이면 바인딩은 값이 변경 될 때마다 요소의 값을 업데이트합니다. 매개 변수를 관찰 할 수 없으면 요소 값을 한 번만 설정하고 나중에 다시 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="697682d3cadcd44d9c1d1305da3a61036fdfa605" translate="yes" xml:space="preserve">
          <source>If this parameter is an observable value, the binding will update the element&amp;rsquo;s visibility whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s visibility once and will not update it again later.</source>
          <target state="translated">이 매개 변수가 관찰 가능한 값이면 바인딩은 값이 변경 될 때마다 요소의 가시성을 업데이트합니다. 매개 변수를 관찰 할 수 없으면 요소의 가시성을 한 번만 설정하고 나중에 다시 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f45c52f51bf20ce24a7e4b608d15ab347ed9c290" translate="yes" xml:space="preserve">
          <source>If valueAllowUnset had not been enabled, then Knockout would have overwritten selectedCountry with undefined, so that it would match the value of the 'Choose one...' caption entry.</source>
          <target state="translated">valueAllowUnset이 활성화되지 않은 경우 녹아웃은 selectedCountry를 undefined로 덮어 써서 'Choose one ...'캡션 항목의 값과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a24740e5d492d0bcabc30118270e3e7eae827804" translate="yes" xml:space="preserve">
          <source>If you apply a simple numeric value to a style that requires a unit, Knockout will append px to the value before setting the style. For example, style: { width: 100 } will set the width to 100px.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3ea4a49bfcd03916cd06d69dac827b155984b2" translate="yes" xml:space="preserve">
          <source>If you are trying to bind an &amp;lt;input type=&quot;text&quot; /&amp;gt; or &amp;lt;textarea&amp;gt; to get instant updates to your viewmodel, use the &lt;a href=&quot;textinput-binding&quot;&gt;the textInput binding&lt;/a&gt;. It has better support for browser edge cases than any combination of valueUpdate options.</source>
          <target state="translated">&amp;lt;input type = &quot;text&quot;/&amp;gt; 또는 &amp;lt;textarea&amp;gt;를 &lt;a href=&quot;textinput-binding&quot;&gt;바인딩&lt;/a&gt; 하여 뷰 모델을 즉시 업데이트하려는 경우 textInput 바인딩을 사용하십시오 . valueUpdate 옵션의 조합보다 브라우저 엣지 케이스를 더 잘 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1a7f396d14387545628545aeb2802baaa004a716" translate="yes" xml:space="preserve">
          <source>If you are using a component loader to fetch components by a naming convention, and are &lt;em&gt;not&lt;/em&gt; registering your components using ko.components.register, then those components will not automatically be usable as custom elements (because you haven&amp;rsquo;t told Knockout that they even exist).</source>
          <target state="translated">구성 요소 로더를 사용하여 명명 규칙에 따라 구성 요소를 가져오고 ko.components.register를 사용하여 구성 요소를 등록 &lt;em&gt;하지 않으면&lt;/em&gt; 해당 구성 요소를 자동으로 사용자 지정 요소로 사용할 수 없습니다. 있다).</target>
        </trans-unit>
        <trans-unit id="57acecaab300936e5fb81a00ce2ade1592a7db93" translate="yes" xml:space="preserve">
          <source>If you are using foreach and only want to be notified about elements that are specifically being added or are being removed, you can use afterAdd and beforeRemove instead. For details, see documentation for the &lt;a href=&quot;foreach-binding&quot;&gt;foreach binding&lt;/a&gt;.</source>
          <target state="translated">foreach를 사용 중이고 특별히 추가되거나 제거되는 요소에 대해서만 알림을 받으려면 afterAdd 및 beforeRemove를 대신 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;foreach-binding&quot;&gt;foreach 바인딩&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce083543ff1be7a981205d49b50c12c2d35aab21" translate="yes" xml:space="preserve">
          <source>If you are using static CSS class names, then you can pass a JavaScript object in which the property names are your CSS classes, and their values evaluate to true or false according to whether the class should currently be applied.</source>
          <target state="translated">정적 CSS 클래스 이름을 사용하는 경우 속성 이름이 CSS 클래스 인 JavaScript 객체를 전달할 수 있으며 해당 클래스의 현재 적용 여부에 따라 해당 값이 true 또는 false로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="b409ece9cd23f86abee691f7b17d7b89e59dbba4" translate="yes" xml:space="preserve">
          <source>If you are using the default component loader, and hence are registering your components using ko.components.register, then there is nothing extra you need to do. Components registered this way are immediately available for use as custom elements.</source>
          <target state="translated">기본 구성 요소 로더를 사용 중이고 ko.components.register를 사용하여 구성 요소를 등록하는 경우 추가로 수행 할 작업이 없습니다. 이 방법으로 등록 된 구성 요소는 즉시 사용자 지정 요소로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ddcd80cbca13d044050f160b5fe2da2f4edef8d" translate="yes" xml:space="preserve">
          <source>If you commonly include template content using virtual elements, the normal syntax can feel a bit verbose. Using preprocessing, you can add a new template format that uses a single comment:</source>
          <target state="translated">가상 요소를 사용하여 템플릿 컨텐츠를 일반적으로 포함하는 경우 일반 구문이 약간 장황하게 느껴질 수 있습니다. 전처리를 사용하여 단일 주석을 사용하는 새 템플릿 형식을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1d7cd0691a5cabd2961f5bde8eb238a8f9e084c" translate="yes" xml:space="preserve">
          <source>If you create a computed observable in a custom binding, rather than using a custom disposal callback, you can set the computed to dispose automatically when the node is removed. When constructing the computed observable, provide the node using the disposeWhenNodeIsRemoved option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39dac748b82ce1d7e9df2f75a51a1b265e4aee88" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a configuration for the named component, then call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="translated">로더가 명명 된 구성 요소에 대한 구성을 제공하지 못하게하려면 callback (null)을 호출하십시오. 그런 다음 녹아웃은 널이 아닌 값을 제공 할 때까지 등록 된 다른 로더를 순서대로 참조합니다.</target>
        </trans-unit>
        <trans-unit id="a803a11622a50576c908d4836ed761b181f5ff65" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a createViewModel function for the given parameters (e.g., because it does not recognize the configuration format), call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="translated">로더가 주어진 매개 변수에 대해 createViewModel 함수를 제공하지 못하게하려면 (예 : 구성 형식을 인식하지 못하기 때문에) callback (null)을 호출하십시오. 그런 다음 녹아웃은 널이 아닌 값을 제공 할 때까지 등록 된 다른 로더를 순서대로 참조합니다.</target>
        </trans-unit>
        <trans-unit id="88a98aefdcf31a903e5d480df483166240bfba37" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a template for the given parameters (e.g., because it does not recognize the configuration format), call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="translated">로더가 주어진 매개 변수에 대한 템플리트를 제공하지 않게하려면 (예 : 구성 형식을 인식하지 못하기 때문에) callback (null)을 호출하십시오. 그런 다음 녹아웃은 널이 아닌 값을 제공 할 때까지 등록 된 다른 로더를 순서대로 참조합니다.</target>
        </trans-unit>
        <trans-unit id="96bd57dfc5e8e227d695eb9cc1de257c99d1c474" translate="yes" xml:space="preserve">
          <source>If you do not want your loader to supply a viewmodel/template pair for the given parameters, then call callback(null). Knockout will then consult any other registered loaders in sequence, until one supplies a non-null value.</source>
          <target state="translated">로더가 주어진 매개 변수에 대해 뷰 모델 / 템플릿 쌍을 제공하지 못하게하려면 callback (null)을 호출하십시오. 그런 다음 녹아웃은 널이 아닌 값을 제공 할 때까지 등록 된 다른 로더를 순서대로 참조합니다.</target>
        </trans-unit>
        <trans-unit id="c512ba9128c02d4d1a3f480875fdee4dc35677d7" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want to display just a simple property value as the text for each item in the dropdown, you can pass a JavaScript function for the optionsText option and supply your own arbitrary logic for computing the displayed text in terms of the represented object. See Example 4 above, which shows how you could generate the displayed text by concatenating together multiple property values.</source>
          <target state="translated">드롭 다운의 각 항목에 대한 텍스트로 간단한 속성 값만 표시하지 않으려면 optionsText 옵션에 JavaScript 함수를 전달하고 표시된 객체를 기준으로 표시된 텍스트를 계산하기위한 고유 한 임의의 논리를 제공 할 수 있습니다 . 여러 속성 값을 함께 연결하여 표시된 텍스트를 생성하는 방법을 보여주는 위의 예 4를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4830a1b281a9a9be8b4899be04ed0ad714a44701" translate="yes" xml:space="preserve">
          <source>If you have a reference to a DOM element in your code, you can use it as a container for template markup:</source>
          <target state="translated">코드에 DOM 요소에 대한 참조가있는 경우이를 템플릿 마크 업의 컨테이너로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fc07db8d07ca18d202ff7e05a94198b45413180" translate="yes" xml:space="preserve">
          <source>If you have an AMD loader (such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;) already in your page, then you can use it to fetch a template. For more details about how this works, see &lt;a href=&quot;#how-knockout-loads-components-via-amd&quot;&gt;how Knockout loads components via AMD&lt;/a&gt; below. Example:</source>
          <target state="translated">페이지에 AMD 로더 (예 : &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt; )가 이미 있으면이를 사용하여 템플릿을 가져올 수 있습니다. 작동 방식에 대한 자세한 내용은 아래에서 &lt;a href=&quot;#how-knockout-loads-components-via-amd&quot;&gt;Knockout이 AMD를 통해 구성 요소를로드하는 방법을&lt;/a&gt; 참조하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="9a69d18b622bb3cca3c70f1710dff19c9f5aca93" translate="yes" xml:space="preserve">
          <source>If you have an AMD loader (such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;) already in your page, then you can use it to fetch a viewmodel. For more details about how this works, see &lt;a href=&quot;#how-knockout-loads-components-via-amd&quot;&gt;how Knockout loads components via AMD&lt;/a&gt; below. Example:</source>
          <target state="translated">페이지에 AMD 로더 (예 : &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt; )가 이미있는 경우이를 사용하여 뷰 모델을 가져올 수 있습니다. 작동 방식에 대한 자세한 내용은 아래에서 &lt;a href=&quot;#how-knockout-loads-components-via-amd&quot;&gt;Knockout이 AMD를 통해 구성 요소를로드하는 방법을&lt;/a&gt; 참조하십시오 . 예:</target>
        </trans-unit>
        <trans-unit id="8d613332487fc8236cb7e6d5e6bc539bf312e263" translate="yes" xml:space="preserve">
          <source>If you have implemented a &lt;a href=&quot;component-loaders&quot;&gt;custom component loader&lt;/a&gt;, and are not using ko.components.register, then you need to tell Knockout about any element names you wish to use as custom elements. To do this, simply call ko.components.register - you don&amp;rsquo;t need to specify any configuration, since your custom component loader won&amp;rsquo;t be using the configuration anyway. For example,</source>
          <target state="translated">&lt;a href=&quot;component-loaders&quot;&gt;사용자 정의 컴포넌트 로더를&lt;/a&gt; 구현했으며 ko.components.register를 사용하지 않는 경우 사용자 정의 요소로 사용하려는 요소 이름에 대해 Knockout에 알려야합니다. 이렇게하려면 ko.components.register를 호출하기 만하면됩니다. 사용자 정의 구성 요소 로더는 구성을 사용하지 않으므로 구성을 지정할 필요가 없습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="c6dc783c88a9a55d059f753b19bf7c4b10f1293f" translate="yes" xml:space="preserve">
          <source>If you have multiple named templates, you can pass an observable for the name option. As the observable&amp;rsquo;s value is updated, the element&amp;rsquo;s contents will be re-rendered using the appropriate template. Alternatively, you can pass a callback function to determine which template to use. If you are using the foreach template mode, Knockout will evaluate the function for each item in your array, passing that item&amp;rsquo;s value as the only argument. Otherwise, the function will be given the data option&amp;rsquo;s value or fall back to providing your whole current model object.</source>
          <target state="translated">명명 된 템플릿이 여러 개인 경우 이름 옵션에 대한 관찰 가능 항목을 전달할 수 있습니다. 관찰 가능 값이 업데이트되면 적절한 템플릿을 사용하여 요소의 내용이 다시 렌더링됩니다. 또는 콜백 함수를 전달하여 사용할 템플릿을 결정할 수 있습니다. foreach 템플릿 모드를 사용하는 경우 녹아웃은 배열의 각 항목에 대한 함수를 평가하여 해당 항목의 값을 유일한 인수로 전달합니다. 그렇지 않으면 함수에 데이터 옵션 값이 제공되거나 전체 현재 모델 객체를 제공하는 것으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="f9fde0bfc8d899331beb6d9ec952dcb2dab1b640" translate="yes" xml:space="preserve">
          <source>If you have subscribed to an external observable, be sure to use .dispose() on the subscription, otherwise the callback (and possibly also your viewmodel) will be held in memory.</source>
          <target state="translated">외부 Observable을 구독 한 경우 구독에서 .dispose ()를 사용해야합니다. 그렇지 않으면 콜백 (및 가능하면 뷰 모델)이 메모리에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="3c4d57bb828a71531ceeb4aa49b28a3c60f87e52" translate="yes" xml:space="preserve">
          <source>If you leave off the value of a binding, it&amp;rsquo;s bound to undefined by default. If you want to have a different default value for a binding, you can do so with a preprocessor. For example, you can allow uniqueName to be bound without a value by making its default value true:</source>
          <target state="translated">바인딩 값을 제외하면 기본적으로 undefined로 바인딩됩니다. 바인딩에 다른 기본값을 설정하려면 전처리기를 사용하면됩니다. 예를 들어, 기본값을 true로 설정하여 uniqueName이 값없이 바인드되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df6baaff79cb69e31e568c59ade70f1456f1c34c" translate="yes" xml:space="preserve">
          <source>If you need to pass more parameters, one way to do it is by wrapping your handler in a function literal that takes in a parameter, as in this example:</source>
          <target state="translated">더 많은 매개 변수를 전달해야하는 경우 처리 방법은 다음 예제와 같이 매개 변수를 사용하는 함수 리터럴로 처리기를 래핑하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="395b1c02e2a6fd4dd3478f8ed3123de446425e64" translate="yes" xml:space="preserve">
          <source>If you need to run some further custom logic on the generated DOM elements, you can use any of the afterRender/afterAdd/beforeRemove/beforeMove/afterMove callbacks described below.</source>
          <target state="translated">생성 된 DOM 요소에 대해 추가 사용자 정의 로직을 실행해야하는 경우 아래 설명 된 afterRender / afterAdd / beforeRemove / beforeMove / afterMove 콜백을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e172b40bc2aac406378c1826a63899ef1e1c8897" translate="yes" xml:space="preserve">
          <source>If you need to run some further custom logic on the generated option elements, you can use the optionsAfterRender callback. See Note 2 below.</source>
          <target state="translated">생성 된 옵션 요소에서 추가 사용자 정의 로직을 실행해야하는 경우 optionsAfterRender 콜백을 사용할 수 있습니다. 아래 참고 2를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e0946163467362f9f0453888bade424cd2a18cd9" translate="yes" xml:space="preserve">
          <source>If you need to run some further custom logic on the generated option elements, you can use the optionsAfterRender callback. The callback function is invoked each time an option element is inserted into the list, with the following parameters:</source>
          <target state="translated">생성 된 옵션 요소에서 추가 사용자 정의 로직을 실행해야하는 경우 optionsAfterRender 콜백을 사용할 수 있습니다. 콜백 함수는 옵션 요소가 목록에 다음 매개 변수와 함께 삽입 될 때마다 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7add5138afadba9db94cdfc48e15c94798748a29" translate="yes" xml:space="preserve">
          <source>If you need to set HTML content in this manner, see &lt;a href=&quot;html-binding&quot;&gt;the html binding&lt;/a&gt;.</source>
          <target state="translated">이러한 방식으로 HTML 컨텐츠를 설정해야하는 경우 &lt;a href=&quot;html-binding&quot;&gt;html 바인딩을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e813a05b4d4fc8d95d220cb80a0c91d23fba7f44" translate="yes" xml:space="preserve">
          <source>If you only need to combine updates without adding a delay, &lt;a href=&quot;deferred-updates&quot;&gt;deferred updates&lt;/a&gt; provides a more efficient method.</source>
          <target state="translated">지연을 추가하지 않고 업데이트 만 결합해야하는 경우 &lt;a href=&quot;deferred-updates&quot;&gt;지연된 업데이트&lt;/a&gt; 가보다 효율적인 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5e7be95f226e675b640699b19295d6d29cb25a1d" translate="yes" xml:space="preserve">
          <source>If you only need to use the compound full name in the UI you could declare it as:</source>
          <target state="translated">UI에서 복합 이름 만 사용해야하는 경우 다음과 같이 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd19412014a27de66dbd7f90139a256b3d51da33" translate="yes" xml:space="preserve">
          <source>If you open your browser developer tools&amp;rsquo; &lt;strong&gt;Network&lt;/strong&gt; inspector before your first click on &lt;em&gt;Add product&lt;/em&gt;, you&amp;rsquo;ll see that the component&amp;rsquo;s .js/.html files are fetched on demand when first required, and thereafter retained for reuse.</source>
          <target state="translated">&lt;em&gt;제품 추가를&lt;/em&gt; 처음 클릭하기 전에 브라우저 개발자 도구의 &lt;strong&gt;네트워크&lt;/strong&gt; 관리자 를 열면 처음 필요할 때 구성 요소의 .js / .html 파일을 가져 와서 다시 사용할 수 있도록 유지됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7e3531ed2ee3130336ffaac70ea47406b8f9ad62" translate="yes" xml:space="preserve">
          <source>If you pass just a string, it is interpreted as a component name. The named component is then injected without supplying any parameters to it. Example:</source>
          <target state="translated">문자열 만 전달하면 구성 요소 이름으로 해석됩니다. 그런 다음 명명 된 구성 요소는 매개 변수를 제공하지 않고 주입됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="d8655e03ea768a2840f2c814ce3e4612e25b0a0e" translate="yes" xml:space="preserve">
          <source>If you prefer, you could combine templateFromUrlLoader and viewModelCustomLoader into a single loader by putting the loadTemplate and loadViewModel functions on a single object. However it&amp;rsquo;s quite nice to separate out these concerns, since their implementations are quite independent.</source>
          <target state="translated">원하는 경우 loadTemplate 및 loadViewModel 함수를 단일 오브젝트에 배치하여 templateFromUrlLoader 및 viewModelCustomLoader를 단일 로더로 결합 할 수 있습니다. 그러나 구현이 독립적이기 때문에 이러한 우려를 분리하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7d9099195cbde906f499c9495d5f5fd785651e50" translate="yes" xml:space="preserve">
          <source>If you refer to model properties in a params attribute, then you are of course referring to the properties on the viewmodel outside the component (the &amp;lsquo;parent&amp;rsquo; or &amp;lsquo;host&amp;rsquo; viewmodel), since the component itself is not instantiated yet. In the above example, myModelValue would be a property on the parent viewmodel, and would be received by the child component viewmodel&amp;rsquo;s constructor as params.someModelProperty.</source>
          <target state="translated">params 속성에서 모델 속성을 참조하는 경우 구성 요소 자체가 아직 인스턴스화되지 않았으므로 구성 요소 외부의 뷰 모델 ( '부모'또는 '호스트'뷰 모델)의 속성을 참조하는 것입니다. 위의 예제에서 myModelValue는 상위 뷰 모델의 속성이며 하위 구성 요소 뷰 모델의 생성자에 의해 params.someModelProperty로 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="7b53a3732a6bc04d508eda25f801b0bef1ad6dfd" translate="yes" xml:space="preserve">
          <source>If you reference a &lt;em&gt;simple property&lt;/em&gt;, i.e., it is just a regular property on your view model, KO will set the form element&amp;rsquo;s initial state to the property value, and when the form element is edited, KO will write the changes back to your property. It cannot detect when the property changes (because it isn&amp;rsquo;t observable), so this is only a 1-way binding.</source>
          <target state="translated">&lt;em&gt;간단한 속성&lt;/em&gt; 을 참조하는 경우 ( 예 : 뷰 모델에서 일반 속성), KO는 양식 요소의 초기 상태를 속성 값으로 설정하고, 양식 요소를 편집하면 KO가 변경 사항을 속성에 다시 씁니다. . 관찰 할 수 없기 때문에 속성이 변경되는시기를 감지 할 수 없으므로 이는 단방향 바인딩입니다.</target>
        </trans-unit>
        <trans-unit id="7d891ed8be741967c449e958da98ffc8cc566217" translate="yes" xml:space="preserve">
          <source>If you reference something that is &lt;em&gt;not&lt;/em&gt; a simple property, e.g., the result of a function call or comparison operation, KO will set the form element&amp;rsquo;s initial state to that value, but it will not be able to write any changes back when the user edits the form element. In this case it&amp;rsquo;s a one-time-only value setter, not an ongoing binding that reacts to changes.</source>
          <target state="translated">함수 호출 또는 비교 작업의 결과와 같이 단순한 속성 이 &lt;em&gt;아닌&lt;/em&gt; 것을 참조하는 경우 KO는 양식 요소의 초기 상태를 해당 값으로 설정하지만 사용자가 편집 할 때 변경 사항을 다시 쓸 수는 없습니다. 양식 요소. 이 경우 변경 사항에 반응하는 지속적인 바인딩이 아니라 일회성 값 설정 기입니다.</target>
        </trans-unit>
        <trans-unit id="4136055364963301ac3a0672768006e0b60b4010" translate="yes" xml:space="preserve">
          <source>If you set the viewmodel property to true or false, the associated element will become focused or unfocused.</source>
          <target state="translated">viewmodel 속성을 true 또는 false로 설정하면 관련 요소가 초점을 맞추거나 초점이 맞지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="b04308191c20dd0438d23903c6a2d68567c5dfe6" translate="yes" xml:space="preserve">
          <source>If you specify bindings without a value, Knockout will give the binding an undefined value. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea10c506e67e02d37f3ff59d06b553132c889a0" translate="yes" xml:space="preserve">
          <source>If you supply something other than a number or a string (e.g., you pass an object or an array), the displayed text will be equivalent to yourParameter.toString()</source>
          <target state="translated">숫자 나 문자열 이외의 것을 제공하는 경우 (예 : 객체 나 배열을 전달하는 경우) 표시되는 텍스트는 yourParameter.toString ()과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f936a4cf3802ef50c0aec5ecfef503f372a0ded" translate="yes" xml:space="preserve">
          <source>If you supply something other than a number or a string (e.g., you pass an object or an array), the displayed text will be equivalent to yourParameter.toString() (that&amp;rsquo;s usually not very useful, so it&amp;rsquo;s best to supply string or numeric values).</source>
          <target state="translated">숫자 나 문자열 이외의 것을 제공하는 경우 (예를 들어, 객체 나 배열을 전달하는 경우) 표시되는 텍스트는 yourParameter.toString ()과 동일합니다 (일반적으로 유용하지 않으므로 문자열 또는 숫자를 제공하는 것이 가장 좋습니다) 값).</target>
        </trans-unit>
        <trans-unit id="33531730aa65cc0aed58be0f106c04649fd218ba" translate="yes" xml:space="preserve">
          <source>If you supply something other than a number or a string (e.g., you pass an object or an array), the innerHTML will be equivalent to yourParameter.toString()</source>
          <target state="translated">숫자 나 문자열 이외의 것을 제공하는 경우 (예 : 객체 나 배열을 전달하는 경우) innerHTML은 yourParameter.toString ()과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d0c67876e2d6e6a962ee02ea3bfd2bc8d147be3f" translate="yes" xml:space="preserve">
          <source>If you tend to filter observable arrays a lot, adding a filterByProperty globally to all observable arrays might make your code tidier. But if you only need to filter occasionally, you could instead choose &lt;em&gt;not&lt;/em&gt; to attach to ko.observableArray.fn, and instead just construct doneTasks by hand as follows:</source>
          <target state="translated">관찰 가능 배열을 많이 필터링하려는 경우 모든 관찰 가능 배열에 전역 적으로 filterByProperty를 추가하면 코드가 더 깔끔해질 수 있습니다. 그러나 가끔 만 필터링해야하는 경우 ko.observableArray.fn에 첨부 &lt;em&gt;하지&lt;/em&gt; 않고 다음과 같이 doneTasks를 수동으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e10e3c94b35fd8632dab2ca5d675651a6b4f0bb0" translate="yes" xml:space="preserve">
          <source>If you use value to link a form element to an observable property, KO is able to set up a 2-way binding so that changes to either affect the other.</source>
          <target state="translated">값을 사용하여 양식 요소를 관찰 가능한 속성에 연결하는 경우 KO는 양방향 바인딩을 설정하여 변경 사항이 다른쪽에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e93054a2d66f23c13f6c50afc30a17cac10665b4" translate="yes" xml:space="preserve">
          <source>If you want Knockout to allow your model property to take values that have no corresponding entry in your &amp;lt;select&amp;gt; element (and display this by making the &amp;lt;select&amp;gt; element blank), then see &lt;a href=&quot;value-binding#using-valueallowunset-with-select-elements&quot;&gt;documentation for valueAllowUnset&lt;/a&gt;.</source>
          <target state="translated">Knockout에서 모델 속성이 &amp;lt;select&amp;gt; 요소에 해당하는 항목이없는 값을 가져 &lt;a href=&quot;value-binding#using-valueallowunset-with-select-elements&quot;&gt;오도록&lt;/a&gt; 하려면 (&amp;lt;select&amp;gt; 요소 를 비워서 표시) valueAllowUnset에 대한 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a89bcaf9d5696bd11fb99d2d58e919ab34e4a21" translate="yes" xml:space="preserve">
          <source>If you want a custom binding to be usable with Knockout&amp;rsquo;s &lt;em&gt;virtual elements&lt;/em&gt; syntax, e.g.:</source>
          <target state="translated">Knockout의 &lt;em&gt;가상 요소&lt;/em&gt; 구문 으로 사용자 정의 바인딩을 사용하려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="12de6cba1d2b34cbb4e79120d38a72eb8f87f4f5" translate="yes" xml:space="preserve">
          <source>If you want all instances of your component to share the same viewmodel object instance (which is not usually desirable):</source>
          <target state="translated">구성 요소의 모든 인스턴스가 동일한 뷰 모델 객체 인스턴스를 공유하도록하려면 (보통 바람직하지 않음) :</target>
        </trans-unit>
        <trans-unit id="2f370654b97f0f29acfaf8c9f3cbd1053b47dfd4" translate="yes" xml:space="preserve">
          <source>If you want the equivalent of a foreach binding, but using a named template, you can do so in the natural way:</source>
          <target state="translated">foreach 바인딩과 동일하지만 이름이 지정된 템플릿을 사용하려는 경우 자연스럽게 그렇게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0687bb9af427b875127182534a1eca56e0d6596" translate="yes" xml:space="preserve">
          <source>If you want the mapping plugin to ignore some properties of your JS object (i.e. to not map them), you can specify an array of propertynames to ignore:</source>
          <target state="translated">매핑 플러그인이 JS 객체의 일부 속성을 무시하도록하려면 (즉, 매핑하지 않기 위해) 무시할 속성 이름 배열을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48877e0877c23be66516c571a7f2f9808b04bbbc" translate="yes" xml:space="preserve">
          <source>If you want the mapping plugin to only create observables of some properties of your JS object and copy the rest, you can specify an array of propertynames to observe:</source>
          <target state="translated">맵핑 플러그인이 JS 오브젝트의 일부 특성에 대한 관찰 가능 항목 만 작성하고 나머지를 복사하도록하려면 관찰 할 특성 이름 배열을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a610cb362a9cb355f038caa3483260b1682b467" translate="yes" xml:space="preserve">
          <source>If you want to access data/functions from parent binding contexts, you can use &lt;a href=&quot;binding-context&quot;&gt;special context properties such as $parent and $root&lt;/a&gt;.</source>
          <target state="translated">부모 바인딩 컨텍스트에서 데이터 / 함수에 액세스하려면 &lt;a href=&quot;binding-context&quot;&gt;$ parent 및 $ root와 같은 특수 컨텍스트 속성을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5e8a9598e8913d6b161a0231caddfc4c3d6385d" translate="yes" xml:space="preserve">
          <source>If you want to apply a font-weight or text-decoration style, or any other style whose name isn&amp;rsquo;t a legal JavaScript identifier (e.g., because it contains a hyphen), you must use the &lt;em&gt;JavaScript name&lt;/em&gt; for that style. For example,</source>
          <target state="translated">글꼴 가중치 또는 텍스트 장식 스타일 또는 이름이 유효한 JavaScript 식별자가 아닌 다른 스타일 (예 : 하이픈 포함)을 적용하려면 해당 스타일 의 &lt;em&gt;JavaScript 이름&lt;/em&gt; 을 사용해야합니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="42a04b9a7a064c9209637e25fdea69c9c72b38f4" translate="yes" xml:space="preserve">
          <source>If you want to apply a style whose name isn&amp;rsquo;t a legal JavaScript identifier (e.g., because it contains a hyphen), you can either put it in quotes or use the JavaScript name for that style. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1a7840c3566eba919210c187885f629cdea7e6" translate="yes" xml:space="preserve">
          <source>If you want to apply the CSS class my-class, you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; write this:</source>
          <target state="translated">CSS 클래스 my-class를 적용하려면 다음을 작성할 &lt;em&gt;수 없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="400ea2089a975a1be517a84a31ee89203ffb5ce6" translate="yes" xml:space="preserve">
          <source>If you want to apply the attribute data-something, you &lt;em&gt;can&amp;rsquo;t&lt;/em&gt; write this:</source>
          <target state="translated">data-something 속성을 적용하려면 다음과 같이 쓸 &lt;em&gt;수 없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="926dd1aabde3cc388fd5f78c44f8b0dc656ffe88" translate="yes" xml:space="preserve">
          <source>If you want to be notified of the value of an observable before it is about to be changed, you can subscribe to the beforeChange event. For example:</source>
          <target state="translated">Observable의 값을 변경하기 전에 알림을 받으려면 beforeChange 이벤트를 구독 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4dc22f6555d4554142d875304efe0f5c3fb52625" translate="yes" xml:space="preserve">
          <source>If you want to change the policy for a particular component, you can specify synchronous: true on that component&amp;rsquo;s configuration. Then it might load asynchronously on first use, followed by synchronously on all subsequent uses. If you do this, then you need to account for this changeable behavior in any code that waits for components to load. However, if your component can always be loaded and initialized synchronously, then enabling this option will ensure consistently synchronous behavior. This might be important if you&amp;rsquo;re using a component within a foreach binding and want to use the afterAdd or afterRender options to do post-processing.</source>
          <target state="translated">특정 구성 요소에 대한 정책을 변경하려는 경우 해당 구성 요소 구성에서 동기 : true를 지정할 수 있습니다. 그런 다음 처음 사용할 때 비동기 적으로로드 된 후 모든 후속 용도에서 동 기적으로로드 될 수 있습니다. 이렇게하면 구성 요소가로드 될 때까지 기다리는 코드에서이 변경 가능한 동작을 고려해야합니다. 그러나 구성 요소를 항상 동기식으로로드 및 초기화 할 수있는 경우이 옵션을 사용하면 지속적으로 동기식으로 작동합니다. foreach 바인딩 내에서 구성 요소를 사용하고 afterAdd 또는 afterRender 옵션을 사용하여 사후 처리를 수행하려는 경우에 중요 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d46531ca9799ade7ca26f1bed17707b4876bd54" translate="yes" xml:space="preserve">
          <source>If you want to convert your mapped object back to a regular JS object, use:</source>
          <target state="translated">매핑 된 객체를 다시 일반 JS 객체로 변환하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="20972324a8ac6446023da390397678c0423402dd" translate="yes" xml:space="preserve">
          <source>If you want to detect and respond to changes on one object, you&amp;rsquo;d use &lt;a href=&quot;observables&quot;&gt;observables&lt;/a&gt;. If you want to detect and respond to changes of a &lt;em&gt;collection of things&lt;/em&gt;, use an observableArray. This is useful in many scenarios where you&amp;rsquo;re displaying or editing multiple values and need repeated sections of UI to appear and disappear as items are added and removed.</source>
          <target state="translated">한 객체의 변경 사항을 감지하고 이에 응답하려면 &lt;a href=&quot;observables&quot;&gt;Observables를&lt;/a&gt; 사용 합니다. &lt;em&gt;사물 컬렉션의&lt;/em&gt; 변경 사항을 감지하고 응답하려면 observableArray를 사용하십시오. 이 방법은 여러 값을 표시하거나 편집하고 항목을 추가하거나 제거 할 때 UI의 반복 된 섹션이 나타나거나 사라지는 많은 시나리오에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5dbe5851856488928c88861ca66a429c2a8a54c3" translate="yes" xml:space="preserve">
          <source>If you want to detemine text programmatically, one option is to create a &lt;a href=&quot;computedobservables&quot;&gt;computed observable&lt;/a&gt;, and use its evaluator function as a place for your code that works out what text to display.</source>
          <target state="translated">프로그래밍 방식으로 텍스트를 판별하려면 &lt;a href=&quot;computedobservables&quot;&gt;계산 된 Observable&lt;/a&gt; 을 만들고 평가 기 기능을 코드에 표시 할 텍스트를 생성하는 장소로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a0e5d4f6f665f1af91a7e87e9210302dace1de3d" translate="yes" xml:space="preserve">
          <source>If you want to do this in custom bindings, then instead of using bindingContext.extend(), use bindingContext.createChildContext(someData). This returns a new binding context whose viewmodel is someData and whose $parentContext is bindingContext. If you want, you can then extend the child context with extra properties using ko.utils.extend. For example,</source>
          <target state="translated">사용자 정의 바인딩에서이를 수행하려면 bindingContext.extend ()를 사용하는 대신 bindingContext.createChildContext (someData)를 사용하십시오. 뷰 모델이 someData이고 $ parentContext가 bindingContext 인 새 바인딩 컨텍스트를 리턴합니다. 원하는 경우 ko.utils.extend를 사용하여 추가 속성으로 하위 컨텍스트를 확장 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="87af9ca294d83f6fba572d78050da057a49b8c89" translate="yes" xml:space="preserve">
          <source>If you want to ensure that the subscribers are always notified of an update, even if the value is the same, you would use the notify extender in addition to rateLimit:</source>
          <target state="translated">값이 동일한 경우에도 구독자에게 항상 업데이트 알림을 표시하려면 rateLimit 외에도 알림 익스텐더를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="44cdfd3b6064088d2c5aa5fc20d93a5155c03685" translate="yes" xml:space="preserve">
          <source>If you want to handle a part of the mapping yourself, you can also provide a create callback. If this callback is present, the mapping plugin will allow you to do this part of the mapping yourself.</source>
          <target state="translated">매핑의 일부를 직접 처리하려면 생성 콜백을 제공 할 수도 있습니다. 이 콜백이 있으면 매핑 플러그인을 사용하여 매핑의이 부분을 직접 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72b1f64bd3585abcdb719c6af16ba28b06cb4a0c" translate="yes" xml:space="preserve">
          <source>If you want to have different custom element tag names, you can override getComponentNameForNode to control this. For example,</source>
          <target state="translated">다른 사용자 정의 요소 태그 이름을 가지려면 getComponentNameForNode를 대체하여이를 제어 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="f48f247482677e3d298eb9f8794c7720f2d28823" translate="yes" xml:space="preserve">
          <source>If you want to map the children array yourself, you can specify that like this:</source>
          <target state="translated">자식 배열을 직접 매핑하려면 다음과 같이 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1351e5f77b9081488d46eb8f548df93a34b7ae41" translate="yes" xml:space="preserve">
          <source>If you want to run any setup logic on the associated element before it is bound to the viewmodel, or use arbitrary logic to decide which viewmodel class to instantiate:</source>
          <target state="translated">뷰 모델에 바인딩되기 전에 관련 요소에서 설정 로직을 실행하거나 임의 로직을 사용하여 인스턴스화 할 뷰 모델 클래스를 결정하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c66df88a215f6f7b24bd3deee59aec7e6d2e2f59" translate="yes" xml:space="preserve">
          <source>If you want to use dynamic CSS class names, then you can pass a string that corresponds to the CSS class or classes that you want to add to the element. If the parameter references an observable value, then the binding will remove any previously added classes and add the class or classes corresponding to the observable&amp;rsquo;s new value.</source>
          <target state="translated">동적 CSS 클래스 이름을 사용하려는 경우 요소에 추가하려는 CSS 클래스에 해당하는 문자열을 전달할 수 있습니다. 매개 변수가 관찰 가능 값을 참조하는 경우 바인딩은 이전에 추가 된 클래스를 제거하고 관찰 가능 값의 새 값에 해당하는 클래스를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6d39bf93c568ed46321d7833a330f6569b221b30" translate="yes" xml:space="preserve">
          <source>If you want your custom loader to take precedence over the default loader (so it gets the first opportunity to supply configuration/values), then add it to the &lt;em&gt;beginning&lt;/em&gt; of the array. If you want the default loader to take precedence (so your custom loader is only called for components not explicitly registered), then add it to the &lt;em&gt;end&lt;/em&gt; of the array.</source>
          <target state="translated">사용자 정의 로더가 기본 로더보다 우선하도록하려면 (구성 / 값을 제공 할 첫 번째 기회를 얻음) 배열 의 &lt;em&gt;시작 부분&lt;/em&gt; 에 추가하십시오 . 기본 로더가 우선하도록하려면 (명시 적으로 등록되지 않은 구성 요소에 대해서만 사용자 정의 로더가 호출 됨) 배열 &lt;em&gt;끝에&lt;/em&gt; 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ceafe6c0f244a6b62bf46e8591b041a309c0459" translate="yes" xml:space="preserve">
          <source>If you want your observable array &lt;strong&gt;not&lt;/strong&gt; to start empty, but to contain some initial items, pass those items as an array to the constructor. For example,</source>
          <target state="translated">관찰 가능한 배열 을 비우지 &lt;strong&gt;않고&lt;/strong&gt; 초기 항목을 포함하려면 해당 항목을 배열로 생성자에 전달하십시오. 예를 들어</target>
        </trans-unit>
        <trans-unit id="e61100d48bd38e328d61f92193723be823f648bd" translate="yes" xml:space="preserve">
          <source>If you wanted, you could use $data as a prefix when referencing properties on each entry. For example, you could rewrite part of &lt;a href=&quot;#example-1-iterating-over-an-array&quot;&gt;Example 1&lt;/a&gt; as follows:</source>
          <target state="translated">원하는 경우 각 항목의 속성을 참조 할 때 $ data를 접두사로 사용할 수 있습니다. 예를 들어 다음과 같이 &lt;a href=&quot;#example-1-iterating-over-an-array&quot;&gt;예 1의&lt;/a&gt; 일부를 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d0c200b210145556f08539e16369c8ae1101651" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to be able to bind expressions to click events (rather than a function reference as Knockout expects), you can set up a preprocessor for the click handler to support this syntax:</source>
          <target state="translated">Knockout이 예상하는 함수 참조가 아닌 클릭 이벤트에 표현식을 바인딩하려면 다음 구문을 지원하도록 클릭 핸들러에 대한 전처리기를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="907374589d9e730eb5f8d2c95837b3f35a14d2f1" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;d like to migrate code from using the deprecated throttle extender, you should note the following ways that the rateLimit extender is different from the throttle extender.</source>
          <target state="translated">더 이상 사용되지 않는 스로틀 익스텐더를 사용하여 코드를 마이그레이션하려는 경우 rateLimit 익스텐더가 스로틀 익스텐더와 다른 다음 방법에 유의해야합니다.</target>
        </trans-unit>
        <trans-unit id="82cf070f85ee99e13abeb8d98714402eb45540b9" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building configurations programmatically and you have a DocumentFragment object, you can use it as a component template:</source>
          <target state="translated">프로그래밍 방식으로 구성을 작성하고 DocumentFragment 객체가있는 경우 구성 요소 템플릿으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="362388121008c8da14509414fa3107e12b516595" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re building configurations programmatically and you have an array of DOM nodes, you can use them as a component template:</source>
          <target state="translated">프로그래밍 방식으로 구성을 구축하고 DOM 노드 배열이있는 경우 구성 요소 템플릿으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5fbe4f70abc50527b7288b53aa01cad2d4a9fe8" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re inside a nested &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;, for example if you&amp;rsquo;re inside a foreach or a with block, but your handler function is on the root viewmodel or some other parent context, you&amp;rsquo;ll need to use a prefix such as $parent or $root to locate the handler function.</source>
          <target state="translated">예를 들어 foreach 또는 with 블록 내에 있지만 처리기 함수가 루트 뷰 모델 또는 다른 부모 컨텍스트에있는 경우 중첩 &lt;a href=&quot;binding-context&quot;&gt;바인딩 컨텍스트&lt;/a&gt; 내에있는 경우 $와 같은 접두사를 사용해야합니다. 핸들러 함수를 찾으려면 parent 또는 $ root.</target>
        </trans-unit>
        <trans-unit id="b30aa6dd1b7b726ed22a1386408193b3ed07cc63" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re not a fan of the &amp;lt;%= ... %&amp;gt; delimiters, you can configure the Underscore template engine to use any other delimiter characters of your choice.</source>
          <target state="translated">&amp;lt;% = ... %&amp;gt; 구분 기호의 팬이 아닌 경우 선택한 다른 구분 문자를 사용하도록 Underscore 템플릿 엔진을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="128a03e2b47df3a4720a787432ce69b6c26af34a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re within the context of a particular &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt; template, then $component refers to the viewmodel for that component. It&amp;rsquo;s the component-specific equivalent to $root. In the case of nested components, $component refers to the viewmodel for the closest component.</source>
          <target state="translated">특정 &lt;a href=&quot;component-overview&quot;&gt;구성 요소&lt;/a&gt; 템플릿 의 컨텍스트 내에있는 경우 $ component는 해당 구성 요소의 뷰 모델을 나타냅니다. $ root와 동등한 구성 요소입니다. 중첩 된 컴포넌트의 경우 $ component는 가장 가까운 컴포넌트의 뷰 모델을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8207088fe6ea022be6846a6dde93cdfdbb4659e7" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re within the context of a particular &lt;a href=&quot;component-overview&quot;&gt;component&lt;/a&gt; template, then $componentTemplateNodes is an array containing any DOM nodes that were passed to that component. This makes it easy to build components that receive templates, for example a grid component that accepts a template to define its output rows. For a complete example, see &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;passing markup into components&lt;/a&gt;.</source>
          <target state="translated">특정 &lt;a href=&quot;component-overview&quot;&gt;컴포넌트&lt;/a&gt; 템플릿 의 컨텍스트 내에있는 경우 $ componentTemplateNodes는 해당 컴포넌트로 전달 된 DOM 노드를 포함하는 배열입니다. 따라서 템플릿을받는 구성 요소 (예 : 템플릿을 수락하여 출력 행을 정의하는 그리드 구성 요소)를 쉽게 작성할 수 있습니다. 완전한 예는 &lt;a href=&quot;component-custom-elements#passing-markup-into-components&quot;&gt;구성 요소에 태그 전달을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="50cd6a8b962993f971b8353a9f4567faa0ee548a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re working with AMD, then you might prefer a structure like this:</source>
          <target state="translated">AMD로 작업하는 경우 다음과 같은 구조를 선호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d7b9ced2efd23f656198e4a25fb4db243307f5a" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;ve loaded some data from the server and want to use it to update your view model, the most straightforward way is to do it yourself. For example,</source>
          <target state="translated">서버에서 일부 데이터를로드하고이를 사용하여보기 모델을 업데이트하려는 경우 가장 간단한 방법은 직접 수행하는 것입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="bf20ec3aaef79dcc3c3e98b605cfa93d5c521bb6" translate="yes" xml:space="preserve">
          <source>If your Ajax call returns a JSON string (and does not deserialize it into a JavaScript object), then you can use the function ko.mapping.fromJSON to create and update your view model instead. To unmap, you can use ko.mapping.toJSON.</source>
          <target state="translated">Ajax 호출이 JSON 문자열을 리턴하고 (JavaScript 오브젝트로 직렬화 해제하지 않는 경우) ko.mapping.fromJSON 함수를 사용하여 대신 뷰 모델을 작성하고 업데이트 할 수 있습니다. 매핑을 해제하려면 ko.mapping.toJSON을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b44f19840a62453340adc3a1ccb826f912401798" translate="yes" xml:space="preserve">
          <source>If your binding also includes a parameter called valueUpdate, this defines additional browser events KO should use to detect changes besides the change event. The following string values are the most commonly useful choices:</source>
          <target state="translated">바인딩에 valueUpdate라는 매개 변수가 포함 된 경우 KO가 변경 이벤트 외에 변경을 감지하는 데 사용해야하는 추가 브라우저 이벤트를 정의합니다. 다음 문자열 값이 가장 일반적으로 유용한 선택입니다.</target>
        </trans-unit>
        <trans-unit id="d155bf9b29c1f0a2a9418e2feadc2ccfa15452dc" translate="yes" xml:space="preserve">
          <source>If your binding also includes checkedValue, this defines the value used by the checked binding instead of the element&amp;rsquo;s value attribute. This is useful if you want the value to be something other than a string (such as an integer or object), or you want the value set dynamically.</source>
          <target state="translated">바인딩에 checkedValue도 포함되어 있으면 요소의 value 속성 대신 확인 된 바인딩이 사용하는 값을 정의합니다. 이는 값이 문자열 (예 : 정수 또는 객체) 이외의 값이되거나 값을 동적으로 설정하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b3ab84e69e9a2c18e82003929561e37ee4fbb1d3" translate="yes" xml:space="preserve">
          <source>If your binding also includes checkedValue, this defines the value used by the checked binding instead of the element&amp;rsquo;s value attribute. This is useful if you want the value to be something other than a string (such as an integer or object), or you want the value set dynamically. For normally boolean checkboxes, this value is used instead of true to represent the &lt;em&gt;checked&lt;/em&gt; state, with undefined used for the &lt;em&gt;unchecked&lt;/em&gt; state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d14bdc74a8da6a89453d8ef51d2e2cc6ebf79fa" translate="yes" xml:space="preserve">
          <source>If your binding uses a preprocess function but should still have undefined as a default value, the function should return the string &quot;undefined&quot; rather than an undefined value. Returning undefined will remove the binding instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="588138852c7a0d26f567881e0157a12d1880b4b0" translate="yes" xml:space="preserve">
          <source>If your checkedValue parameter is an observable value, whenever the value changes and the element is currently checked, the binding will update the checked model property. For checkboxes bound to an array, it will remove the previous value from the array and add the new value. Otherwise, it will just update the model value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10fa5bcf76b5721cd82848b0bb414540b34d62f" translate="yes" xml:space="preserve">
          <source>If your checkedValue parameter is an observable value, whenever the value changes and the element is currently checked, the binding will update the checked model property. For checkboxes, it will remove the old value from the array and add the new value. For radio buttons, it will just update the model value.</source>
          <target state="translated">checkedValue 매개 변수가 관찰 가능한 값인 경우 값이 변경되고 요소가 현재 점검 될 때마다 바인딩은 점검 된 모델 특성을 업데이트합니다. 확인란의 경우 배열에서 이전 값을 제거하고 새 값을 추가합니다. 라디오 버튼의 경우 모델 값만 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="1dbc2f2301ffac98a49b2e6297ccb2fb1e2c8d49" translate="yes" xml:space="preserve">
          <source>If your component configuration has a boolean synchronous property, Knockout uses this to determine whether the component is allowed to be loaded and injected synchronously. The default is false (i.e., forced to be asynchronous). For example,</source>
          <target state="translated">구성 요소 구성에 부울 동기 특성이있는 경우 녹아웃은이를 사용하여 구성 요소를 동기식으로로드 및 주입 할 수 있는지 여부를 판별합니다. 기본값은 false입니다 (즉, 비동기식이어야 함). 예를 들어</target>
        </trans-unit>
        <trans-unit id="b9854050320055febc419828d11cb1650e59a3b0" translate="yes" xml:space="preserve">
          <source>If your computed observable simply calculates and returns a value based on some observable dependencies, then it&amp;rsquo;s better to declare it as a ko.pureComputed instead of a ko.computed. For example:</source>
          <target state="translated">계산 된 관찰 가능 개체가 관찰 가능한 일부 종속성을 기반으로 값을 계산하고 반환하는 경우 ko.computed 대신 ko.pureComputed로 선언하는 것이 좋습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f07feff737da55640367588cd5b8867853add3d9" translate="yes" xml:space="preserve">
          <source>If your custom loader implements loadTemplate and/or loadViewModel, then you can plug in custom code to the loading process. You can also use these functions to interpret custom configuration formats.</source>
          <target state="translated">사용자 정의 로더가 loadTemplate 및 / 또는 loadViewModel을 구현하는 경우 사용자 정의 코드를로드 프로세스에 플러그인 할 수 있습니다. 이 기능을 사용하여 사용자 정의 구성 형식을 해석 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9e85383888aee26e47a33473edbdb8e84955e5a" translate="yes" xml:space="preserve">
          <source>If your expression involves any observable values, the expression will be re-evaluated whenever any of them change. Correspondingly, the markup within your if block can be added or removed dynamically as the result of the expression changes. data-bind attributes will be applied to &lt;strong&gt;a new copy of the contained markup&lt;/strong&gt; whenever it is re-added.</source>
          <target state="translated">식에 관찰 가능한 값이 포함 된 경우식이 변경 될 때마다식이 다시 평가됩니다. 이에 따라 표현식의 결과에 따라 if 블록 내의 마크 업을 동적으로 추가하거나 제거 할 수 있습니다. 데이터 바인드 속성 은 다시 추가 될 때마다 &lt;strong&gt;포함 된 마크 업의 새 사본에&lt;/strong&gt; 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="8e661a6c7ed635e0bf691bba88868184d5c21e24" translate="yes" xml:space="preserve">
          <source>If your expression involves any observable values, the expression will be re-evaluated whenever any of them change. Correspondingly, the markup within your if or ifnot block can be added or removed dynamically as the result of the expression changes. data-bind attributes will be applied to &lt;strong&gt;a new copy of the contained markup&lt;/strong&gt; whenever it is re-added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226676b80f71bd0aee4405b7dbac5960cfd4e3e7" translate="yes" xml:space="preserve">
          <source>If your function accepts a second parameter, then it will receive the entire &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;. You can then access $parent or any other &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt; variable when dynamically choosing a template. For example, you could amend the preceding code snippet as follows:</source>
          <target state="translated">함수가 두 번째 매개 변수를 허용하면 전체 &lt;a href=&quot;binding-context&quot;&gt;바인딩 컨텍스트를&lt;/a&gt; 받습니다 . 그런 다음 템플릿을 동적으로 선택할 때 $ parent 또는 다른 &lt;a href=&quot;binding-context&quot;&gt;바인딩 컨텍스트&lt;/a&gt; 변수에 액세스 할 수 있습니다 . 예를 들어, 앞의 코드 스 니펫을 다음과 같이 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b4eec9f8db27a16ed532421672ba7179cce19f2" translate="yes" xml:space="preserve">
          <source>If your function references observable values, then the binding will update whenever any of those values change. This will cause the data to be re-rendered using the appropriate template.</source>
          <target state="translated">함수가 관찰 가능한 값을 참조하면 해당 값이 변경 될 때마다 바인딩이 업데이트됩니다. 적절한 템플릿을 사용하여 데이터가 다시 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="6374db41fb1a34f6794e3a7a263b2a5d8f3d6ae6" translate="yes" xml:space="preserve">
          <source>If your parameter is an observable array, the binding will update the element&amp;rsquo;s selection whenever the array changes (e.g., via push, pop or &lt;a href=&quot;observablearrays&quot;&gt;other observable array methods&lt;/a&gt;). If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s selection state once and will not update it again later.</source>
          <target state="translated">매개 변수가 관찰 가능한 배열 인 경우 바인딩은 배열이 변경 될 때마다 (예 : 푸시, 팝 또는 &lt;a href=&quot;observablearrays&quot;&gt;기타 관찰 가능한 배열 방법을&lt;/a&gt; 통해) 요소의 선택을 업데이트합니다 . 매개 변수를 관찰 할 수없는 경우 요소의 선택 상태를 한 번만 설정하고 나중에 다시 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ddb383dfae6006d12773bd8bc5511d587b2ccb9" translate="yes" xml:space="preserve">
          <source>If your parameter is an observable value, the binding will update the element&amp;rsquo;s checked state whenever the value changes. If the parameter isn&amp;rsquo;t observable, it will only set the element&amp;rsquo;s checked state once and will not update it again later.</source>
          <target state="translated">매개 변수가 관찰 가능한 값이면 바인딩은 값이 변경 될 때마다 요소의 확인 된 상태를 업데이트합니다. 매개 변수를 관찰 할 수 없으면 요소의 점검 된 상태 만 한 번만 설정하고 나중에 다시 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1fff36bdc6055d9bb8992e0fdfb26a189710fb02" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will add or remove the CSS class whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only add or remove the class once and will not do so again later.</source>
          <target state="translated">매개 변수가 관찰 가능 값을 참조하는 경우 바인딩 가능 관찰 가능 값이 변경 될 때마다 바인딩에서 CSS 클래스를 추가하거나 제거합니다. 매개 변수가 관찰 가능한 값을 참조하지 않으면 클래스를 한 번만 추가 또는 제거하고 나중에 다시 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa6f113eec157fdb2ab367ee2fd9cbd80ddb0996" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will update the attribute whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only set the attribute once and will not update it later.</source>
          <target state="translated">매개 변수가 관찰 가능 값을 참조하면 관찰 가능 값이 변경 될 때마다 바인딩이 속성을 업데이트합니다. 매개 변수가 관찰 가능한 값을 참조하지 않으면 속성을 한 번만 설정하고 나중에 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="633f858df401ebd55c78f8496da63fdb61af5458" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will update the enabled/disabled state whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only set the state once and will not do so again later.</source>
          <target state="translated">매개 변수가 관찰 가능한 값을 참조하는 경우 바인딩은 관찰 가능한 값이 변경 될 때마다 활성화 / 비활성화 상태를 업데이트합니다. 매개 변수가 관찰 가능한 값을 참조하지 않으면 상태를 한 번만 설정하고 나중에 다시 설정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d3819bd4ed3fd60e94476b444ece0ada882cf49" translate="yes" xml:space="preserve">
          <source>If your parameter references an observable value, the binding will update the styles whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only set the styles once and will not update them later.</source>
          <target state="translated">매개 변수가 관찰 가능 값을 참조하면 관찰 가능 값이 변경 될 때마다 바인딩이 스타일을 업데이트합니다. 매개 변수가 관찰 가능한 값을 참조하지 않으면 스타일을 한 번만 설정하고 나중에 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9c0408c9bf4c4a37030fc7cdecf2361bd78f581" translate="yes" xml:space="preserve">
          <source>If your parameter&amp;rsquo;s value is an array of strings, you don&amp;rsquo;t need to give any other parameters. The &amp;lt;select&amp;gt; element will display an option for each string value. However, if you want to let the user choose from an array of &lt;em&gt;arbitrary JavaScript objects&lt;/em&gt; (not merely strings), then see the optionsText and optionsValue parameters below.</source>
          <target state="translated">매개 변수 값이 문자열 배열 인 경우 다른 매개 변수를 제공 할 필요가 없습니다. &amp;lt;select&amp;gt; 요소는 각 문자열 값에 대한 옵션을 표시합니다. 그러나 사용자가 문자열이 아닌 &lt;em&gt;임의의 JavaScript 객체&lt;/em&gt; 배열에서 선택할 수있게하려면 아래의 optionsText 및 optionsValue 매개 변수를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a69077a26824bf6bf1d9998d4bf4a08fe6a1767d" translate="yes" xml:space="preserve">
          <source>If, like in the example above, you are performing the mapping inside of a class, you would like to have this as the target of your mapping operation. The third parameter to ko.mapping.fromJS indicates the target. For example,</source>
          <target state="translated">위의 예와 같이 클래스 내부에서 매핑을 수행하는 경우이를 매핑 작업의 대상으로 사용하려고합니다. ko.mapping.fromJS의 세 번째 매개 변수는 대상을 나타냅니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="9ee772074f2af1d7a8aaad138b9ed8cf1f46dbbc" translate="yes" xml:space="preserve">
          <source>Ignoring certain properties using &amp;ldquo;ignore&amp;rdquo;</source>
          <target state="translated">&quot;무시&quot;를 사용하여 특정 속성 무시</target>
        </trans-unit>
        <trans-unit id="862cab77807ae3aed03ab6e5350848a0245d7862" translate="yes" xml:space="preserve">
          <source>Ignoring dependencies within a computed</source>
          <target state="translated">계산 된 내에서 종속성 무시</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="e98d0b401da7a27f72e4030036db78a4058a43b6" translate="yes" xml:space="preserve">
          <source>Implementing a custom component loader</source>
          <target state="translated">커스텀 컴포넌트 로더 구현</target>
        </trans-unit>
        <trans-unit id="9e1f2cc17fbee96463fbddbcea3b554850c3baa9" translate="yes" xml:space="preserve">
          <source>In a binding&amp;rsquo;s init function, using a computed observable to update the bound element.</source>
          <target state="translated">바인딩의 init 함수에서 계산 된 observable을 사용하여 바인딩 된 요소를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="a6abb210083356c831fde074a2c122126ad2030b" translate="yes" xml:space="preserve">
          <source>In a typical Knockout application, DOM elements are dynamically added and removed, for example using the &lt;a href=&quot;template-binding&quot;&gt;template&lt;/a&gt; binding or via control-flow bindings (&lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt;, &lt;a href=&quot;ifnot-binding&quot;&gt;ifnot&lt;/a&gt;, &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt;, and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;). When creating a custom binding, it is often desirable to add clean-up logic that runs when an element associated with your custom binding is removed by Knockout.</source>
          <target state="translated">일반적인 녹아웃 응용 프로그램에서 &lt;a href=&quot;template-binding&quot;&gt;템플릿&lt;/a&gt; 바인딩 또는 제어 흐름 바인딩 ( &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; , &lt;a href=&quot;ifnot-binding&quot;&gt;ifnot&lt;/a&gt; , &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; 및 &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; )을 사용하여 DOM 요소가 동적으로 추가 및 제거됩니다 . 사용자 정의 바인딩을 작성할 때 사용자 정의 바인딩과 연관된 요소가 Knockout에 의해 제거 될 때 실행되는 정리 논리를 추가하는 것이 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="141b57414e301727c0b0d54cb5649b30de0602c3" translate="yes" xml:space="preserve">
          <source>In case you&amp;rsquo;re wondering what the parameters to ko.applyBindings do,</source>
          <target state="translated">ko.applyBindings의 매개 변수가 무엇인지 궁금한 경우,</target>
        </trans-unit>
        <trans-unit id="934ed4b9942e197c4b326248bae145be6b363266" translate="yes" xml:space="preserve">
          <source>In complex applications, with multiple, intertwined dependencies, updating a single &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; might trigger a cascade of &lt;a href=&quot;computedobservables&quot;&gt;computed observables&lt;/a&gt;, manual subscriptions, and UI binding updates. These updates can be expensive and inefficient if unnecessary intermediate values are pushed to the view or result in extra computed observable evaluations. Even in a simple application, updating related observables or a single observable multiple times (such as filling an &lt;a href=&quot;observablearrays&quot;&gt;observable array&lt;/a&gt;) can have a similar effect.</source>
          <target state="translated">여러 개의 서로 종속 된 종속성이있는 복잡한 응용 프로그램에서 단일 &lt;a href=&quot;observables&quot;&gt;Observable을&lt;/a&gt; 업데이트 하면 일련의 &lt;a href=&quot;computedobservables&quot;&gt;계산 된 Observable&lt;/a&gt; , 수동 구독 및 UI 바인딩 업데이트 가 트리거 될 수 있습니다 . 이러한 업데이트는 불필요한 중간 값이 뷰에 푸시되거나 추가로 계산 가능한 관찰 가능한 평가가 발생하는 경우 비싸고 비효율적 일 수 있습니다. 간단한 응용 프로그램에서도 관련 관찰 가능 항목 또는 단일 관찰 가능 항목을 여러 번 업데이트하는 경우 (예 : &lt;a href=&quot;observablearrays&quot;&gt;관찰 가능 배열&lt;/a&gt; 채우기 ) 비슷한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="298a4f1f3d69231f90369b88842f87a3f201c02d" translate="yes" xml:space="preserve">
          <source>In general, if a parameter&amp;rsquo;s evaluation does not involve evaluating an observable (in this case, the observable was simply passed without evaluating it), then the value is passed literally.</source>
          <target state="translated">일반적으로 매개 변수의 평가에 관찰 가능 항목을 평가하지 않는 경우 (이 경우에는 관찰 가능하지 않고 관찰 가능하게 전달됨) 값이 그대로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="9fea9cada35fecd5a76c1bf34c364291fb1dfeb5" translate="yes" xml:space="preserve">
          <source>In general, if a parameter&amp;rsquo;s evaluation does not involve evaluating an observable (in this case, the value did not involve observables at all), then the value is passed literally. If the value was an object, then the child component could mutate it, but since it&amp;rsquo;s not observable the parent would not know the child had done so.</source>
          <target state="translated">일반적으로 매개 변수의 평가에 관찰 가능 평가 (이 경우에는 값에 관찰 가능 평가가 전혀 포함되지 않음)가 포함되지 않으면 값이 그대로 전달됩니다. 값이 객체 인 경우 자식 구성 요소가이를 변경시킬 수는 있지만 관찰 할 수 없으므로 부모는 자식이 그렇게했는지 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9408b29fab575c1d6a718e0d164b10b2342550d4" translate="yes" xml:space="preserve">
          <source>In general, with custom elements, if a parameter&amp;rsquo;s evaluation involves evaluating an observable, then Knockout automatically constructs a ko.computed value to give the expression&amp;rsquo;s result, and supplies that to the component.</source>
          <target state="translated">일반적으로 사용자 지정 요소를 사용하여 매개 변수의 평가에 관찰 가능 항목을 평가하면 Knockout은 자동으로 ko.computed 값을 생성하여 식의 결과를 제공하고이를 구성 요소에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dada114537b3d8ec4d940c1f848a0b4d17e427dd" translate="yes" xml:space="preserve">
          <source>In many scenarios, this direct approach is the simplest and most flexible solution. Of course, as you update the properties on your view model, Knockout will take care of updating the visible UI to match it.</source>
          <target state="translated">많은 시나리오에서이 직접 접근 방식은 가장 단순하고 가장 유연한 솔루션입니다. 물론 뷰 모델의 속성을 업데이트 할 때 Knockout은 표시되는 UI를 일치하도록 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="1336d55dbbe8a14101718dce289bfc08355c43e3" translate="yes" xml:space="preserve">
          <source>In most applications, you&amp;rsquo;ll want to keep component view models and templates in external files. If you configure Knockout to fetch them via an AMD module loader such as &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt;, then they can either be preloaded (possibly bundled/minified), or incrementally loaded as needed.</source>
          <target state="translated">대부분의 응용 프로그램에서는 구성 요소 뷰 모델 및 템플릿을 외부 파일로 유지하려고합니다. &lt;a href=&quot;http://requirejs.org/&quot;&gt;require.js&lt;/a&gt; 와 같은 AMD 모듈 로더를 통해 가져 오도록 Knockout을 구성하는 경우 사전로드되거나 번들로 제공 / 축소되거나 필요에 따라 증분로드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9393d5a40d776a6854af0f2c50bfec273ef93bff" translate="yes" xml:space="preserve">
          <source>In most cases, data-bind attributes provide a clean and succinct way to bind to a view model. However, event handling is one area that can often result in verbose data-bind attributes, as anonymous functions were typically the recommended techinique to pass arguments. For example:</source>
          <target state="translated">대부분의 경우 데이터 바인딩 특성은 뷰 모델에 바인딩하는 깔끔하고 간결한 방법을 제공합니다. 그러나 익명 함수는 일반적으로 인수를 전달하는 데 권장되는 기술이므로 이벤트 처리는 종종 상세한 데이터 바인딩 속성을 초래할 수있는 영역 중 하나입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e51abc57c35dadaabfdce19179eb0debbebbeaf7" translate="yes" xml:space="preserve">
          <source>In older browsers (ie8 and below) using reserved javascript words as attribute names causes an error. You can get around this by quoting them like this:</source>
          <target state="translated">예약 된 자바 스크립트 단어를 속성 이름으로 사용하는 이전 브라우저 (예 : 8 이하)에서는 오류가 발생합니다. 다음과 같이 인용하면이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78c97a2a9b619f6af8e28ca3d1b212c9106b36d9" translate="yes" xml:space="preserve">
          <source>In some cases, you might want to duplicate a section of markup, but you don&amp;rsquo;t have any container element on which to put a foreach binding. For example, you might want to generate the following:</source>
          <target state="translated">경우에 따라 마크 업 섹션을 복제 할 수도 있지만 foreach 바인딩을 넣을 컨테이너 요소가 없습니다. 예를 들어 다음을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24cb80dcb3e226fb881227f4a0ccddef514b98a4" translate="yes" xml:space="preserve">
          <source>In some scenarios, it is useful to programmatically determine if you are dealing with a computed observable. Knockout provides a utility function, ko.isComputed to help with this situation. For example, you might want to exclude computed observables from data that you are sending back to the server.</source>
          <target state="translated">일부 시나리오에서는 계산 된 관측 가능 개체를 처리하는지 프로그래밍 방식으로 결정하는 것이 유용합니다. 녹아웃은 이러한 상황에 도움이되는 유틸리티 기능 ko.isComputed를 제공합니다. 예를 들어 서버로 다시 전송하는 데이터에서 계산 된 관측 가능 개체를 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e3b5296e5cf5300764dcbb83ced0ab56bb3f938" translate="yes" xml:space="preserve">
          <source>In some scenarios, it is useful to programmatically determine if you are dealing with a pure computed observable. Knockout provides a utility function, ko.isPureComputed to help with this situation. For example, you might want to exclude non-pure computed observables from data that you are sending back to the server.</source>
          <target state="translated">일부 시나리오에서는 순수 계산 옵저버 블을 처리하는지 프로그래밍 방식으로 결정하는 것이 유용합니다. 녹아웃은 이러한 상황에 도움이되는 유틸리티 기능 ko.isPureComputed를 제공합니다. 예를 들어, 서버로 다시 전송하는 데이터에서 순수하지 않은 계산 가능 관측치를 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f78cb94e8b3d800b2ea0fcaad4990a5f1a56de28" translate="yes" xml:space="preserve">
          <source>In some scenarios, it is useful to programmatically determine if you are dealing with an observableArray. Knockout provides a utility function, ko.isObservableArray to help with this situation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642b0b573c69ea5aac246a77f09332e0af893398" translate="yes" xml:space="preserve">
          <source>In some scenarios, you may need to access the DOM event object associated with your click event. Knockout will pass the event as the second parameter to your function, as in this example:</source>
          <target state="translated">일부 시나리오에서는 클릭 이벤트와 관련된 DOM 이벤트 객체에 액세스해야 할 수도 있습니다. 녹아웃은 다음 예와 같이 이벤트를 함수에 두 번째 매개 변수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="89a035bdd8bde1fc808e15cc5a03eb180ed46c10" translate="yes" xml:space="preserve">
          <source>In some scenarios, you may need to access the DOM event object associated with your event. Knockout will pass the event as the second parameter to your function, as in this example:</source>
          <target state="translated">일부 시나리오에서는 이벤트와 연관된 DOM 이벤트 오브젝트에 액세스해야 할 수도 있습니다. 녹아웃은 다음 예와 같이 이벤트를 함수에 두 번째 매개 변수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="8a7c3e36457e6b3964cbe1d0bb7c4a44fc9b6097" translate="yes" xml:space="preserve">
          <source>In summary, the general rule is:</source>
          <target state="translated">요약하면 일반적인 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7abd619b7fce5ea9d7c5cd5e72650986e1b05fc5" translate="yes" xml:space="preserve">
          <source>In the above example, selectedCountry will retain the value 'Latvia', and the dropdown will be blank, because there is no corresponding option.</source>
          <target state="translated">위의 예에서 selectedCountry는 'Latvia'값을 유지하고 해당 옵션이 없으므로 드롭 다운이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a079557bbe2fc66148c2ddbfa0077e907128f7e8" translate="yes" xml:space="preserve">
          <source>In the example below, a computed observable is used to reload an observable named currentPageData using Ajax with data from two other observable properties. The computed observable will update whenever pageIndex changes, but it ignores changes to selectedItem because it is accessed using peek. In this case, the user might want to use the current value of selectedItem only for tracking purposes when a new set of data is loaded.</source>
          <target state="translated">아래 예에서, 계산 된 관찰 가능 객체는 Ajax를 사용하여 관찰 가능한 두 개의 다른 관찰 가능 속성의 데이터를 사용하여 관찰 가능한 이름 인 currentPageData를 다시로드하는 데 사용됩니다. 계산 된 옵저버 블은 pageIndex가 변경 될 때마다 업데이트되지만 peek을 사용하여 액세스하기 때문에 selectedItem의 변경 사항은 무시합니다. 이 경우 사용자는 새 데이터 세트가로드 될 때 추적 목적으로 만 selectedItem의 현재 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="257966647233e2e113fd6e59387bdb2e8ee4f13b" translate="yes" xml:space="preserve">
          <source>In the example code above, the user can choose from an array of string values. You&amp;rsquo;re &lt;em&gt;not&lt;/em&gt; limited to providing strings - your options array can contain arbitrary JavaScript objects if you wish. See &lt;a href=&quot;options-binding&quot;&gt;the options binding&lt;/a&gt; for details on how to control how arbitrary objects should be displayed in the list.</source>
          <target state="translated">위의 예제 코드에서 사용자는 문자열 값 배열에서 선택할 수 있습니다. 문자열 제공에만 국한 &lt;em&gt;되지&lt;/em&gt; 는 &lt;em&gt;않습니다&lt;/em&gt; . 원하는 경우 옵션 배열에 임의의 JavaScript 객체가 포함될 수 있습니다. 목록에 임의의 객체를 표시하는 방법을 제어하는 ​​방법에 대한 자세한 내용 &lt;a href=&quot;options-binding&quot;&gt;은 옵션 바인딩&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7f1eec557c11682dd0041b7ee985e305de5b96b1" translate="yes" xml:space="preserve">
          <source>In the following example of a simple wizard interface, the fullName &lt;em&gt;pure&lt;/em&gt; computed is only bound to the view during the final step and so is only updated when that step is active.</source>
          <target state="translated">간단한 마법사 인터페이스의 다음 예제에서, 계산 된 fullName &lt;em&gt;pure&lt;/em&gt; 는 최종 단계 중보 기에만 바인드되므로 해당 단계가 활성화 된 경우에만 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="0f00c733671a04000a05bf717e25acf161719f5a" translate="yes" xml:space="preserve">
          <source>In the following example,</source>
          <target state="translated">다음 예에서</target>
        </trans-unit>
        <trans-unit id="e6b59bdb65eb1fb7ea8933f16ea767b69ee4a3eb" translate="yes" xml:space="preserve">
          <source>In the following example, the &amp;lt;div&amp;gt; element will be empty for &amp;ldquo;Mercury&amp;rdquo;, but populated for &amp;ldquo;Earth&amp;rdquo;. That&amp;rsquo;s because Earth has a non-null capital property, whereas &amp;ldquo;Mercury&amp;rdquo; has null for that property.</source>
          <target state="translated">다음 예에서 &amp;lt;div&amp;gt; 요소는&amp;ldquo;Mercury&amp;rdquo;의 경우 비어 있지만&amp;ldquo;Earth&amp;rdquo;의 경우 채워집니다. 그것은 지구가 null이 아닌 자본 재산을 가지고있는 반면,&amp;ldquo;Mercury&amp;rdquo;는 그 재산에 대해 null을 가지고 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ea4ef6f441e7c614e804c04b6a2e41d53a3f525d" translate="yes" xml:space="preserve">
          <source>In the following example, the item objects themselves (not their itemName strings) will be included in the chosenItems array when their corresponding checkboxes are checked:</source>
          <target state="translated">다음 예제에서 해당 확인란을 선택하면 항목 객체 자체 (항목 이름 문자열이 아님)가 selectedItems 배열에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fd533036ba8a852bee55ce9ff27ce0f5cbea1320" translate="yes" xml:space="preserve">
          <source>In the unlikely event that you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; want the automatic unwrapping, because you want to access the observable1/observable2 instances directly, you can read values from params.$raw. For example,</source>
          <target state="translated">드문 경우에 당신은 것을 &lt;em&gt;하지 않는&lt;/em&gt; 직접 observable1 / observable2 인스턴스에 액세스하기를 원하기 때문에, 당신은 PARAMS에서 값을 읽을 수 있습니다, 자동 랩 해제를 할 수 있습니다. 원시 $입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="82f26ef92fcf3d919b5692d621d24247e24ffdf3" translate="yes" xml:space="preserve">
          <source>In the vast majority of cases, Knockout&amp;rsquo;s native templating and the foreach, if, with and other control flow bindings will be all you need to construct an arbitrarily sophisticated UI. But in case you wish to integrate with an external templating library, such as the &lt;a href=&quot;http://documentcloud.github.com/underscore/#template&quot;&gt;Underscore template engine&lt;/a&gt; or &lt;a href=&quot;http://api.jquery.com/jquery.tmpl/&quot;&gt;jquery.tmpl&lt;/a&gt;, Knockout offers a way to do it.</source>
          <target state="translated">대부분의 경우 Knockout의 기본 템플릿 및 foreach, if, with 및 기타 제어 흐름 바인딩이 임의로 정교한 UI를 구성하는 데 필요한 모든 것입니다. 그러나 &lt;a href=&quot;http://documentcloud.github.com/underscore/#template&quot;&gt;Underscore 템플릿 엔진&lt;/a&gt; 또는 &lt;a href=&quot;http://api.jquery.com/jquery.tmpl/&quot;&gt;jquery.tmpl&lt;/a&gt; 과 같은 외부 템플릿 라이브러리와 통합하려는 경우 Knockout 이이 를 수행 할 수있는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6089b197798e2998b901eb8dbbf1b20e0c170048" translate="yes" xml:space="preserve">
          <source>In this case, all the specified nodes (and their descendants) will be cloned and concatenated into each copy of the component that gets instantiated.</source>
          <target state="translated">이 경우 지정된 모든 노드 (및 해당 하위 항목)가 복제되어 인스턴스화되는 구성 요소의 각 복사본에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="a348c38b4b02b07c8665149add553a1e8b9d5d0e" translate="yes" xml:space="preserve">
          <source>In this case, both the required and logChange extenders would be executed against our observable.</source>
          <target state="translated">이 경우 필수 및 logChange 익스텐더는 모두 관찰 가능 항목에 대해 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a699872accd4a004c8e32410cc63d8c1833fccde" translate="yes" xml:space="preserve">
          <source>In this case, the object to which the component&amp;rsquo;s view is bound is the params object that you passed to the component binding. Example:</source>
          <target state="translated">이 경우 구성 요소의 뷰가 바인딩 된 개체는 구성 요소 바인딩에 전달한 params 개체입니다. 예:</target>
        </trans-unit>
        <trans-unit id="c17fd19412152ec3913a0a1d358a54a8292c9681" translate="yes" xml:space="preserve">
          <source>In this case, you can&amp;rsquo;t put if on the &amp;lt;ul&amp;gt; (because then it would affect the first &amp;lt;li&amp;gt; too), and you can&amp;rsquo;t put any other container around the second &amp;lt;li&amp;gt; (because HTML doesn&amp;rsquo;t allow extra containers within &amp;lt;ul&amp;gt;s).</source>
          <target state="translated">이 경우 &amp;lt;ul&amp;gt;에 있으면 (첫 번째 &amp;lt;li&amp;gt;에도 영향을 미치기 때문에) 넣을 수 없으며 두 번째 &amp;lt;li&amp;gt; 주위에 다른 컨테이너를 넣을 수 없습니다 (HTML이 아니기 때문에 &amp;lt;ul&amp;gt; s 내에 추가 컨테이너 허용)</target>
        </trans-unit>
        <trans-unit id="4bd55725b74476a658ad8c3ddffc52240205843b" translate="yes" xml:space="preserve">
          <source>In this example, the &amp;ldquo;Your cellphone number&amp;rdquo; text box will initially be disabled. It will be enabled only when the user checks the box labelled &amp;ldquo;I have a cellphone&amp;rdquo;.</source>
          <target state="translated">이 예에서 &quot;휴대폰 번호&quot;텍스트 상자는 처음에 비활성화됩니다. 사용자가 &quot;휴대 전화가 있습니다&quot;라고 표시된 상자를 선택한 경우에만 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="23b1af26f17b9406ba47b28c79e10c531b381108" translate="yes" xml:space="preserve">
          <source>In this example, the component both displays and edits an observable property called userRating on the Product view model class.</source>
          <target state="translated">이 예에서 구성 요소는 제품보기 모델 클래스에서 userRating이라는 관찰 가능 속성을 표시하고 편집합니다.</target>
        </trans-unit>
        <trans-unit id="b578fdc737cd1643dadd8aea539b4c2f16e439d0" translate="yes" xml:space="preserve">
          <source>In this example, the person-template markup is used twice: once for buyer, and once for seller. Notice that the template markup is wrapped in a &amp;lt;script type=&quot;text/html&quot;&amp;gt; &amp;mdash; the dummy type attribute is necessary to ensure that the markup is not executed as JavaScript, and Knockout does not attempt to apply bindings to that markup except when it is being used as a template.</source>
          <target state="translated">이 예에서는 개인 템플릿 마크 업이 구매자에 대해 한 번, 판매자에 대해 한 번 두 번 사용됩니다. 템플릿 마크 업이 &amp;lt;script type = &quot;text / html&quot;&amp;gt;에 래핑 됨 &amp;mdash; 마크 업이 JavaScript로 실행되지 않도록하기 위해 더미 유형 속성이 필요하며 Knockout은 다음과 같은 경우를 제외하고 해당 마크 업에 바인딩을 적용하지 않습니다. 템플릿으로 사용 중입니다.</target>
        </trans-unit>
        <trans-unit id="4923e8cd2117852530d9802d4bbf382ff3afc82c" translate="yes" xml:space="preserve">
          <source>In this example, there isn&amp;rsquo;t anywhere to put a normal foreach binding. You can&amp;rsquo;t put it on the &amp;lt;ul&amp;gt; (because then you&amp;rsquo;d be duplicating the header item), nor can you put a further container inside the &amp;lt;ul&amp;gt; (because only &amp;lt;li&amp;gt; elements are allowed inside &amp;lt;ul&amp;gt;s).</source>
          <target state="translated">이 예제에서는 일반적인 foreach 바인딩을 넣을 곳이 없습니다. &amp;lt;ul&amp;gt;에 넣을 수 없으며 (헤더 항목을 복제하기 때문에) &amp;lt;ul&amp;gt; 안에 추가 컨테이너를 넣을 수 없습니다 (&amp;lt;ul&amp;gt; s 안에는 &amp;lt;li&amp;gt; 요소 만 허용되므로) ).</target>
        </trans-unit>
        <trans-unit id="fb736901afba0868e604845ea5c5136b0ef06755" translate="yes" xml:space="preserve">
          <source>In this live example, there&amp;rsquo;s an instantaneousValue observable that reacts immediately when you press a key. This is then wrapped inside a delayedValue computed observable that&amp;rsquo;s configured to notify only when changes stop for at least 400 milliseconds, using the notifyWhenChangesStop rate-limit method.</source>
          <target state="translated">이 라이브 예제에는 키를 누를 때 즉시 반응하는 instantaneousValue 옵저버 블이 있습니다. 그런 다음 notifyWhenChangesStop rate-limit 메소드를 사용하여 변경이 400 밀리 초 이상 중지 될 때만 알리도록 구성된 delayedValue 계산 옵저버 블에 래핑됩니다.</target>
        </trans-unit>
        <trans-unit id="697eb6430df1ff767ba12b86170aabf874197762" translate="yes" xml:space="preserve">
          <source>In this scenario, the values you can read and write using selectedOptions are those objects themselves, &lt;em&gt;not&lt;/em&gt; their textual representations. This leads to much cleaner and more elegant code in most cases. Your view model can imagine that the user chooses from an array of arbitrary objects, without having to care how those objects are mapped to an on-screen representation.</source>
          <target state="translated">이 시나리오에서 selectedOptions를 사용하여 읽고 쓸 수있는 값 은 텍스트 표현이 &lt;em&gt;아니라&lt;/em&gt; 해당 객체 자체 입니다. 이것은 대부분의 경우 훨씬 더 깨끗하고 우아한 코드로 이어집니다. 뷰 모델은 사용자가 객체가 화면 상 표현에 매핑되는 방식을 신경 쓰지 않고 임의의 객체 배열에서 선택한다고 상상할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="899b5b3c843785e5bdf5e9462999644c6d640741" translate="yes" xml:space="preserve">
          <source>In your viewmodel, it&amp;rsquo;s often useful to declare self (or some other variable) as an alias for this. Doing so avoids any problems with this being redefined to mean something else in event handlers or Ajax request callbacks.</source>
          <target state="translated">뷰 모델에서 자체 (또는 다른 변수)를 별칭으로 선언하는 것이 종종 유용합니다. 이렇게하면 이벤트 처리기 또는 Ajax 요청 콜백에서 다른 의미로 재정의되는 문제를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01d3f9dd3adc47ab7ac1b64ead3455b5e2967b39" translate="yes" xml:space="preserve">
          <source>Include the module in the list of dependencies for your view model:</source>
          <target state="translated">뷰 모델의 종속성 목록에 모듈을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="a540fcc7f8debd81035e2aedabe7eca5ef988f87" translate="yes" xml:space="preserve">
          <source>Including certain properties using &amp;ldquo;include&amp;rdquo;</source>
          <target state="translated">&quot;include&quot;를 사용하여 특정 속성 포함</target>
        </trans-unit>
        <trans-unit id="51f5cfb3bf91b525954d3382e4520457debfab20" translate="yes" xml:space="preserve">
          <source>Indicating that a control-flow binding &amp;ldquo;completes&amp;rdquo; asynchronously</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12cbb6e3feed90f14fa1eaeab9ddfc2be5402137" translate="yes" xml:space="preserve">
          <source>Inserts nodeToInsert as a child of the real or virtual element containerElem, positioned immediately after insertAfter (where insertAfter must be a child of containerElem).</source>
          <target state="translated">insertAfter 바로 뒤에 위치한 실제 또는 가상 요소 containerElem의 자식으로 nodeToInsert를 삽입합니다 (여기서 insertAfter는 containerElem의 자식이어야 함).</target>
        </trans-unit>
        <trans-unit id="5226f3c318b899bef48bc2eb6b90732ff9e7c110" translate="yes" xml:space="preserve">
          <source>Inserts nodeToPrepend as the first child of the real or virtual element containerElem.</source>
          <target state="translated">nodeToPrepend를 실제 또는 가상 요소 containerElem의 첫 번째 하위로 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="0c6bbabe746e549a40b0c4c9d91c41eb15b7c78a" translate="yes" xml:space="preserve">
          <source>Instead of using submit on the form, you &lt;em&gt;could&lt;/em&gt; use click on the submit button. However, submit has the advantage that it also captures alternative ways to submit the form, such as pressing the &lt;em&gt;enter&lt;/em&gt; key while typing into a text box.</source>
          <target state="translated">양식에서 제출을 사용하는 대신 제출 버튼을 클릭하여 사용할 &lt;em&gt;수&lt;/em&gt; 있습니다. 그러나 제출은 텍스트 상자에 입력하는 동안 &lt;em&gt;Enter&lt;/em&gt; 키를 누르는 등 양식을 제출하는 대체 방법을 캡처한다는 이점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83dd21419fd3a38dcc7db394fe1758f026c592be" translate="yes" xml:space="preserve">
          <source>Instead, developers at present are left to fall back on variations of the module or object literal patterns. With many of these, module scripts are strung together in the DOM with namespaces being described by a single global object where it&amp;rsquo;s still possible to incur naming collisions in your architecture. There&amp;rsquo;s also no clean way to handle dependency management without some manual effort or third party tools.</source>
          <target state="translated">대신에, 현재 개발자들은 모듈이나 객체 리터럴 패턴의 변형에 의존합니다. 이 중 다수를 통해 모듈 스크립트는 DOM에서 함께 묶여 있으며 네임 스페이스는 단일 전역 객체로 설명되며 아키텍처에서 이름 충돌이 여전히 발생할 수 있습니다. 수동 작업이나 타사 도구 없이도 종속성 관리를 처리 할 수있는 확실한 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="0ed5597c3a7b69dedb6a6d299a96c9f0d4cdda78" translate="yes" xml:space="preserve">
          <source>Is KO intended to compete with jQuery (or Prototype, etc.) or work with it?</source>
          <target state="translated">KO는 jQuery (또는 프로토 타입 등)와 경쟁하거나 협력하기위한 것입니까?</target>
        </trans-unit>
        <trans-unit id="65da43a24216ab5b6b86fc60da5f46e3f4aeba18" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t strictly necessary to dispose computeds and subscriptions that only depend on properties of the same viewmodel object, since this creates only a circular reference which JavaScript garbage collectors know how to release. However, to avoid having to remember which things need disposal, you may prefer to use pureComputed wherever possible, and explicitly dispose all other computeds/subscriptions whether technically necessary or not.</source>
          <target state="translated">JavaScript 가비지 수집기에서 해제 방법을 알고있는 순환 참조 만 생성하므로 동일한 뷰 모델 객체의 속성에만 의존하는 계산 및 구독을 폐기 할 필요는 없습니다. 그러나 어떤 것을 폐기해야하는지 기억하지 않으려면 가능하면 pureComputed를 사용하고 기술적으로 필요한지 여부에 관계없이 다른 모든 계산 / 구독을 명시 적으로 폐기하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2c8d88dcd3513a54272253518c0497355ab086ef" translate="yes" xml:space="preserve">
          <source>It will first check if the key is already present and will throw an exception if it is. Next, it will invoke the create and update callbacks, if any, to create the new object. Finally, it will add this object to the array and return it.</source>
          <target state="translated">먼저 키가 이미 있는지 확인하고 키가 있으면 예외를 발생시킵니다. 다음으로, 생성 및 업데이트 콜백을 호출하여 새 객체를 생성합니다. 마지막으로이 객체를 배열에 추가하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d79526c06b498ef03e22fd6acf22e655f708bfbf" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s actually very simple and rather lovely. The tracking algorithm goes like this:</source>
          <target state="translated">실제로는 매우 단순하고 사랑 스럽습니다. 추적 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="878cb611fac9777800e6495d4a84b9db45ca03ab" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s important to understand that the if binding really is vital to make this code work properly. Without it, there would be an error when trying to evaluate capital.cityName in the context of &amp;ldquo;Mercury&amp;rdquo; where capital is null. In JavaScript, you&amp;rsquo;re not allowed to evaluate subproperties of null or undefined values.</source>
          <target state="translated">이 코드가 제대로 작동하려면 if 바인딩이 정말 중요하다는 것을 이해하는 것이 중요합니다. 이것이 없으면, 자본이 null 인&amp;ldquo;Mercury&amp;rdquo;의 맥락에서 capital.cityName을 평가하려고 할 때 오류가 발생합니다. 자바 스크립트에서는 null 또는 undefined 값의 하위 속성을 평가할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e3874fb9afc15bfa8481f8f5826ec25b83ba6641" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s much easier with KO. It lets you scale up in complexity without fear of introducing inconsistencies. Just represent your items as a JavaScript array, and then use a foreach binding to transform this array into a TABLE or set of DIVs. Whenever the array changes, the UI changes to match (you don&amp;rsquo;t have to figure out how to inject new TRs or where to inject them). The rest of the UI stays in sync. For example, you can declaratively bind a SPAN to display the number of items as follows:</source>
          <target state="translated">KO를 사용하면 훨씬 쉽습니다. 불일치가 발생할 염려없이 복잡성을 확장 할 수 있습니다. 항목을 JavaScript 배열로 표시 한 다음 foreach 바인딩을 사용하여이 배열을 TABLE 또는 DIV 세트로 변환하십시오. 배열이 변경 될 때마다 UI가 일치하도록 변경됩니다 (새 TR을 주입하는 방법 또는 주입 위치를 알 필요가 없습니다). 나머지 UI는 동기화 상태를 유지합니다. 예를 들어 SPAN을 선언적으로 바인딩하여 다음과 같이 항목 수를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="006519a934952c4254be41efd04fdc8f35b9bbc1" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not mandatory</source>
          <target state="translated">필수는 아닙니다</target>
        </trans-unit>
        <trans-unit id="0b7ff8fbd1e3390894e542bb222f79b8c9ed9a17" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s not very often that you&amp;rsquo;ll need to use named templates, but on occasion it can help to minimise duplication of markup.</source>
          <target state="translated">명명 된 템플릿을 사용해야하는 경우는 많지 않지만 때로는 마크 업 중복을 최소화하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f7ea21297f054ffd0625db94299b6ba1fe8aaa4" translate="yes" xml:space="preserve">
          <source>JSON data</source>
          <target state="translated">JSON 데이터</target>
        </trans-unit>
        <trans-unit id="c63fa2ce723842121580c849293751dfa2071897" translate="yes" xml:space="preserve">
          <source>Just like other control flow bindings such as &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;, you can use with and using without any container element to host it. This is useful if you need to use these bindings in a place where it would not be legal to introduce a new container element just to hold the binding. See the documentation for &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; or &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd56018c5b9bb46e0b7d9532486fd48da666983d" translate="yes" xml:space="preserve">
          <source>Just like other control flow bindings, you can use let without any container element to host it. See the documentation for &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; or &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34fcbc8242b1e3ebc93c1cfe4363423f333e167a" translate="yes" xml:space="preserve">
          <source>Just like other control flow elements such as &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;, you can use with without any container element to host it. This is useful if you need to use with in a place where it would not be legal to introduce a new container element just to hold the with binding. See the documentation for &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; or &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; 및 &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; 와 같은 다른 제어 흐름 요소와 마찬가지로 컨테이너 요소없이 사용할 수 있습니다. with 바인딩을 유지하기 위해 새 컨테이너 요소를 도입하는 것이 합법적이지 않은 장소에서 with를 사용해야하는 경우 유용합니다. 자세한 내용은 &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; 또는 &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f64bb981f55e85e97b341a43c767424d5619a17b" translate="yes" xml:space="preserve">
          <source>Just like the built-in bindings &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;, custom bindings can change the binding context for their descendant elements, or provide special properties by extending the binding context object. This is described in detail under &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;creating custom bindings that control descendant bindings&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; 및 &lt;a href=&quot;foreach-binding&quot;&gt;witheach&lt;/a&gt; 에 내장 된 바인딩 과 마찬가지로 사용자 정의 바인딩은 하위 요소의 바인딩 컨텍스트를 변경하거나 바인딩 컨텍스트 객체를 확장하여 특수 속성을 제공 할 수 있습니다. 이에 대해서는 &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;하위 바인딩을 제어하는 ​​사용자 정의 바인딩 작성&lt;/a&gt; 에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f10396afd953909c4df70ba9023b9185a81cc60" translate="yes" xml:space="preserve">
          <source>KO clears the previous content and then sets the element&amp;rsquo;s content to your parameter value using jQuery&amp;rsquo;s html function or by parsing the string into HTML nodes and appending each node as a child of the element, if jQuery is not available.</source>
          <target state="translated">KO는 이전 컨텐츠를 지운 다음 jQuery의 html 함수를 사용하거나 jQuery를 사용할 수없는 경우 문자열을 HTML 노드로 구문 분석하고 각 노드를 요소의 하위로 추가하여 요소의 컨텐츠를 매개 변수 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="69fa041d6384a6c679e26d44e244d5f32beebb78" translate="yes" xml:space="preserve">
          <source>KO notifies any subscribers about the new value of your computed observable.</source>
          <target state="translated">KO는 구독자에게 계산 된 관찰 가능 값의 새로운 가치를 알립니다.</target>
        </trans-unit>
        <trans-unit id="71fb9b79738717eee4554654ca119320338369c1" translate="yes" xml:space="preserve">
          <source>KO sets the element&amp;rsquo;s checked state to match your parameter value. Any previous checked state will be overwritten. The way your parameter is interpreted depends on what type of element you&amp;rsquo;re binding to:</source>
          <target state="translated">KO는 요소의 검사 상태를 매개 변수 값과 일치하도록 설정합니다. 이전에 확인 된 상태를 덮어 씁니다. 매개 변수가 해석되는 방식은 바인딩 할 요소 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8a3df96598c4036511dc238d5a88ee9394c86f50" translate="yes" xml:space="preserve">
          <source>KO sets the element&amp;rsquo;s text content to your parameter value. Any previous value will be overwritten.</source>
          <target state="translated">KO는 요소의 텍스트 내용을 매개 변수 값으로 설정합니다. 이전 값을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="e1f9d65da5ea43666bdeb72a28f9a6b37496e064" translate="yes" xml:space="preserve">
          <source>KO sets the element&amp;rsquo;s value property to your parameter value. Any previous value will be overwritten.</source>
          <target state="translated">KO는 요소의 값 속성을 매개 변수 값으로 설정합니다. 이전 값을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="3bde7388020d016b48b1ca2b6ab57e2975906b8d" translate="yes" xml:space="preserve">
          <source>KO will pass exactly the same set of parameters that it passes to &lt;a href=&quot;#the-update-callback&quot;&gt;the update callback&lt;/a&gt;.</source>
          <target state="translated">KO는 &lt;a href=&quot;#the-update-callback&quot;&gt;업데이트 콜백에&lt;/a&gt; 전달하는 것과 정확히 동일한 매개 변수 세트를 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="c7ac751a44f21c39e46010fe72a276f9173a2c15" translate="yes" xml:space="preserve">
          <source>KO will prefix the list of items with one that displays the text &amp;ldquo;Select an item&amp;hellip;&amp;rdquo; and has the value undefined. So, if myChosenValue holds the value undefined (which observables do by default), then the dummy option will be selected. If the optionsCaption parameter is an observable, then the text of the initial item will update as the observable&amp;rsquo;s value changes.</source>
          <target state="translated">KO는 항목 목록 앞에&amp;ldquo;항목 선택&amp;hellip;&amp;rdquo;이라는 텍스트를 표시하고 값이 정의되지 않은 항목을 붙입니다. 따라서 myChosenValue에 정의되지 않은 값 (기본적으로 관찰 가능 값)이 있으면 더미 옵션이 선택됩니다. optionsCaption 매개 변수가 관찰 가능 항목 인 경우 관찰 가능 값이 변경되면 초기 항목의 텍스트가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="aa70ea5fbce8c2f9ed5def8836b676cb1d01b105" translate="yes" xml:space="preserve">
          <source>Key point: An observableArray tracks which objects are &lt;em&gt;in&lt;/em&gt; the array, &lt;em&gt;not&lt;/em&gt; the state of those objects</source>
          <target state="translated">요점 : observableArray는 객체 의 상태가 &lt;em&gt;아니라&lt;/em&gt; 어레이 &lt;em&gt;에&lt;/em&gt; 있는 객체를 추적 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="65b8802912f36c09e8cad961f5924ed6360633cb" translate="yes" xml:space="preserve">
          <source>Knockout 3.5 introduced the ability to specify a custom rate-limit method by passing a function to the rateLimit extender rather than just a string. The function is called with three parameters (function, timeout, options) and must return a new, rate-limited function. Whenever the observable has a possibly new value to notify, it will call the returned function, which should then call the original function after some delay based on the rules of the custom method. For example, here is a function that implements &lt;em&gt;debounce&lt;/em&gt; but also immediately notifies the initial value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20cd00a0b3dad001fec0c192cbc11b089833bdc7" translate="yes" xml:space="preserve">
          <source>Knockout allows you to implement sophisticated client-side interactivity, but almost all web applications also need to exchange data with the server, or at least to serialize the data for local storage. The most convenient way to exchange or store data is in &lt;a href=&quot;http://json.org/&quot;&gt;JSON format&lt;/a&gt; - the format that the majority of Ajax applications use today.</source>
          <target state="translated">Knockout을 사용하면 정교한 클라이언트 측 상호 작용 기능을 구현할 수 있지만 거의 모든 웹 응용 프로그램은 서버와 데이터를 교환하거나 최소한 로컬 스토리지 용 데이터를 직렬화해야합니다. 데이터를 교환하거나 저장하는 가장 편리한 방법은 오늘날 대부분의 Ajax 애플리케이션이 사용하는 형식 인 &lt;a href=&quot;http://json.org/&quot;&gt;JSON 형식&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f229f6596fbe329e6bb64b5dce17d58c2ffbdd68" translate="yes" xml:space="preserve">
          <source>Knockout allows you to use multiple component loaders simultaneously. This is useful so that, for example, you can plug in loaders that implement different mechanisms (e.g., one might fetch templates from a backend server according to a naming convention; another might set up viewmodels using a dependency injection system) and have them work together.</source>
          <target state="translated">녹아웃을 사용하면 여러 구성 요소 로더를 동시에 사용할 수 있습니다. 예를 들어, 다른 메커니즘을 구현하는 로더를 플러그인 할 수 있습니다 (예 : 명명 규칙에 따라 백엔드 서버에서 템플릿을 가져올 수 있고 종속성 주입 시스템을 사용하여 뷰 모델을 설정할 수 있음). 함께.</target>
        </trans-unit>
        <trans-unit id="b60fb8fc7684ef97c17d8ccca6eefd233019acb9" translate="yes" xml:space="preserve">
          <source>Knockout does not call require([moduleName], ...) until your component is being instantiated. This is how components get loaded on demand, not up front.</source>
          <target state="translated">녹아웃은 컴포넌트가 인스턴스화 될 때까지 require ([moduleName], ...)를 호출하지 않습니다. 이것이 구성 요소가 선행이 아닌 필요에 따라로드되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="6bdbad01c03ad4f569a7ab9c513b131c9c780424" translate="yes" xml:space="preserve">
          <source>Knockout doesn&amp;rsquo;t force you to use any one particular technique to load or save data. You can use whatever mechanism is a convenient fit for your chosen server-side technology. The most commonly-used mechanism is jQuery&amp;rsquo;s Ajax helper methods, such as &lt;a href=&quot;http://api.jquery.com/jQuery.getJSON/&quot;&gt;getJSON&lt;/a&gt;, &lt;a href=&quot;http://api.jquery.com/jQuery.post/&quot;&gt;post&lt;/a&gt;, and &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;ajax&lt;/a&gt;. You can fetch data from the server:</source>
          <target state="translated">녹아웃은 특정 기술을 사용하여 데이터를로드하거나 저장하도록 강요하지 않습니다. 선택한 서버 측 기술에 편리한 메커니즘을 사용할 수 있습니다. 가장 일반적으로 사용되는 메커니즘은 &lt;a href=&quot;http://api.jquery.com/jQuery.getJSON/&quot;&gt;getJSON&lt;/a&gt; , &lt;a href=&quot;http://api.jquery.com/jQuery.post/&quot;&gt;post&lt;/a&gt; 및 &lt;a href=&quot;http://api.jquery.com/jQuery.ajax/&quot;&gt;ajax&lt;/a&gt; 와 같은 jQuery의 Ajax 도우미 메소드 입니다. 서버에서 데이터를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5aed4a079474df37e1a8e5472e53d73006c662b" translate="yes" xml:space="preserve">
          <source>Knockout has special support for drop-down lists (i.e., &amp;lt;select&amp;gt; elements). The value binding works in conjunction with the options binding to let you read and write values that are arbitrary JavaScript objects, not just string values. This is very useful if you want to let the user select from a set of model objects. For examples of this, see &lt;a href=&quot;options-binding&quot;&gt;the options binding&lt;/a&gt; or for handling multi-select lists, see the documentation for &lt;a href=&quot;selectedoptions-binding&quot;&gt;the selectedOptions binding&lt;/a&gt;.</source>
          <target state="translated">녹아웃은 드롭 다운 목록 (예 : &amp;lt;select&amp;gt; 요소)을 특별히 지원합니다. 값 바인딩은 옵션 바인딩과 함께 작동하여 문자열 값뿐만 아니라 임의의 JavaScript 객체 인 값을 읽고 쓸 수 있습니다. 사용자가 모델 객체 세트에서 선택할 수 있도록하려는 경우 매우 유용합니다. 이에 대한 예는 &lt;a href=&quot;options-binding&quot;&gt;옵션 바인딩&lt;/a&gt; 또는 다중 선택 목록 처리를 참조하십시오 . &lt;a href=&quot;selectedoptions-binding&quot;&gt;selectedOptions 바인딩에&lt;/a&gt; 대한 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfbfbf7e76555709a0e8ee8ab3da25adea41602f" translate="yes" xml:space="preserve">
          <source>Knockout is a JavaScript library that helps you to create rich, responsive display and editor user interfaces with a clean underlying data model. Any time you have sections of UI that update dynamically (e.g., changing depending on the user&amp;rsquo;s actions or when an external data source changes), KO can help you implement it more simply and maintainably.</source>
          <target state="translated">Knockout은 깔끔한 기본 데이터 모델을 사용하여 풍부하고 응답 성이 뛰어난 디스플레이 및 편집기 사용자 인터페이스를 만들 수있는 JavaScript 라이브러리입니다. 동적으로 업데이트되는 UI 섹션이있을 때마다 (예 : 사용자의 작업에 따라 변경되거나 외부 데이터 소스가 변경되는 경우) KO를 사용하면보다 간단하고 유지 관리가 용이하도록 UI를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce1aa9a9160bc65a886f29f47c527a318a8927af" translate="yes" xml:space="preserve">
          <source>Knockout is built around three core features:</source>
          <target state="translated">녹아웃은 다음과 같은 세 가지 핵심 기능으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="09a2d95410f39ed2247b45c19059e92620c5572c" translate="yes" xml:space="preserve">
          <source>Knockout is designed to allow you to use arbitrary JavaScript objects as view models. As long as some of your view model&amp;rsquo;s properties are &lt;a href=&quot;observables&quot;&gt;observables&lt;/a&gt;, you can use KO to bind to them to your UI, and the UI will be updated automatically whenever the observable properties change.</source>
          <target state="translated">녹아웃은 임의의 JavaScript 객체를 뷰 모델로 사용할 수 있도록 설계되었습니다. 뷰 모델의 속성 중 일부가 &lt;a href=&quot;observables&quot;&gt;관찰 가능&lt;/a&gt; 하면 KO를 사용하여 UI에 바인딩 할 수 있으며 관찰 가능한 속성이 변경 될 때마다 UI가 자동으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="0332512be6d6db18462a0af0288d09889035cb5f" translate="yes" xml:space="preserve">
          <source>Knockout observables provide the basic features necessary to support reading/writing values and notifying subscribers when that value changes. In some cases, though, you may wish to add additional functionality to an observable. This might include adding additional properties to the observable or intercepting writes by placing a writable computed observable in front of the observable. Knockout extenders provide an easy and flexible way to do this type of augmentation to an observable.</source>
          <target state="translated">녹아웃 옵저버 블은 값 읽기 / 쓰기를 지원하고 값이 변경 될 때 가입자에게 알리는 데 필요한 기본 기능을 제공합니다. 그러나 경우에 따라 옵저버 블에 추가 기능을 추가 할 수도 있습니다. 여기에는 쓰기 가능한 계산 된 관찰 가능 개체를 관찰 가능 요소 앞에 배치하여 관찰 가능 또는 인터셉트 쓰기에 추가 속성을 추가하는 것이 포함될 수 있습니다. 녹아웃 익스텐더는 이러한 유형의 증강을 관찰 가능하게하는 쉽고 유연한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="aad0f3305d675fb1b797b9228f57e9108d17c6a8" translate="yes" xml:space="preserve">
          <source>Knockout provides some advanced methods to control when the microtask queue is processed. These are useful if you want to integrate Knockout&amp;rsquo;s microtask system with another library or add support for additional environments.</source>
          <target state="translated">녹아웃은 마이크로 태스크 큐가 처리되는시기를 제어하는 ​​몇 가지 고급 방법을 제공합니다. 이는 Knockout의 마이크로 태스크 시스템을 다른 라이브러리와 통합하거나 추가 환경에 대한 지원을 추가하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ca6abd5738b63edcd68975dfacaf86d8c1192d78" translate="yes" xml:space="preserve">
          <source>Knockout provides the following functions for working with virtual elements.</source>
          <target state="translated">녹아웃은 가상 요소 작업을위한 다음 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2ed4d7a56d6f5a6d67ea07b3132d5ff007844b64" translate="yes" xml:space="preserve">
          <source>Knockout provides two similar events that you can use to be notified when the contents of a node have been bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef914aa2073c907e472f6d2527feb737ec2b058e" translate="yes" xml:space="preserve">
          <source>Knockout sets the element&amp;rsquo;s checked state to match your parameter value. Any previous checked state will be overwritten. The way your parameter is interpreted depends on what type of element you&amp;rsquo;re binding to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c0091a1df891fb4dfb8dfd62f26c34e55f8c10" translate="yes" xml:space="preserve">
          <source>Knockout sets the element&amp;rsquo;s content to a text node with your parameter value. Any previous content will be overwritten.</source>
          <target state="translated">녹아웃은 요소의 내용을 매개 변수 값이있는 텍스트 노드로 설정합니다. 모든 이전 내용을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="f4be7114f1815cac446415c10a81311effa02c36" translate="yes" xml:space="preserve">
          <source>Knockout tries hard to spare developers the pain of dealing with cross-browser compatiblity issues, especially those relating to older browsers! Even though custom elements provide a very modern style of web development, they still work on all commonly-encountered browsers:</source>
          <target state="translated">녹아웃은 브라우저 간 호환성 문제, 특히 오래된 브라우저와 관련된 문제를 처리하는 데 어려움을 겪지 않도록 개발자에게 노력합니다. 사용자 정의 요소는 매우 현대적인 웹 개발 스타일을 제공하지만 일반적으로 발생하는 모든 브라우저에서 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3614b4e93dd3cdeb6c24be3fd21755de5f630cec" translate="yes" xml:space="preserve">
          <source>Knockout version 3.4.0 added support for &lt;a href=&quot;deferred-updates&quot;&gt;&lt;em&gt;deferred updates&lt;/em&gt;&lt;/a&gt;, which works similarly to rate-limiting by making notifications and updates asynchronous. But instead of using a timed delay, deferred updates are processed as soon as possible after the current task, before yielding for I/O, reflow, or redrawing. If you are upgrading to 3.4.0 and have code that uses a short rate-limit timeout (e.g., 0 milliseconds), you could modify it to use deferred updates instead:</source>
          <target state="translated">Knockout 버전 3.4.0은 &lt;a href=&quot;deferred-updates&quot;&gt;&lt;em&gt;지연된 업데이트에&lt;/em&gt;&lt;/a&gt; 대한 지원을 추가했습니다 .이 업데이트는 알림 및 업데이트를 비 동기화하여 속도 제한과 유사하게 작동합니다. 그러나 시간 지연을 사용하는 대신 지연된 업데이트는 I / O, 리플 로우 또는 다시 그리기를 생성하기 전에 현재 작업 후 가능한 빨리 처리됩니다. 3.4.0으로 업그레이드하고 짧은 속도 제한 시간 초과 (예 : 0 밀리 초)를 사용하는 코드가있는 경우 지연 업데이트를 대신 사용하도록 코드를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf00d058136f6ed851cf257f843756b9fbf0a3dc" translate="yes" xml:space="preserve">
          <source>Knockout will call the update callback initially when the binding is applied to an element and track any dependencies (observables/computeds) that you access. When any of these dependencies change, the update callback will be called once again. The following parameters are passed to it:</source>
          <target state="translated">녹아웃은 바인딩이 요소에 적용될 때 처음에 업데이트 콜백을 호출하고 액세스하는 모든 종속성 (관찰 가능 / 계산)을 추적합니다. 이러한 종속성 중 하나가 변경되면 업데이트 콜백이 다시 한 번 호출됩니다. 다음과 같은 매개 변수가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="2eae698b690b8c1bcce8105ecab4ab66625edf99" translate="yes" xml:space="preserve">
          <source>Knockout will call your init function once for each DOM element that you use the binding on. There are two main uses for init:</source>
          <target state="translated">녹아웃은 바인딩을 사용하는 각 DOM 요소에 대해 init 함수를 한 번 호출합니다. init에는 두 가지 주요 용도가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a23739891b1f51e8af9e998ec7eca300dc988110" translate="yes" xml:space="preserve">
          <source>Knockout will create a computed observable internally in order to detect what observables the expression depends on, and will automatically dispose it when the associated element is later removed.</source>
          <target state="translated">녹아웃은 표현식이 의존하는 관측 값을 감지하기 위해 계산 된 관측 값을 내부적으로 생성하고 관련 요소가 나중에 제거 될 때 자동으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="8ab974d067e98d55b933807ee21cdb58029eeed8" translate="yes" xml:space="preserve">
          <source>Knockout will invoke your constructor once for each instance of the component, producing a separate viewmodel object for each. Properties on the resulting object or its prototype chain (e.g., someProperty and doSomething in the example above) are available for binding in the component&amp;rsquo;s view.</source>
          <target state="translated">녹아웃은 구성 요소의 각 인스턴스에 대해 생성자를 한 번 호출하여 각각에 대해 별도의 뷰 모델 객체를 생성합니다. 결과 객체 또는 프로토 타입 체인의 속성 (예 : 위 예제의 someProperty 및 doSomething)을 구성 요소의보기에서 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48c5db285f5258d37819571d4c74273c14dd139e" translate="yes" xml:space="preserve">
          <source>Knockout will prevent the use of any bindings that use &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;controlsDescendantBindings&lt;/a&gt;, because this also would clash with the component when trying to bind its viewmodel to the injected template. Therefore if you want to use a control flow binding such as if or foreach, then you must wrap it around your custom element rather than using it directly on the custom element, e.g.,:</source>
          <target state="translated">녹아웃은 &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;controlsDescendantBindings&lt;/a&gt; 를 사용하는 바인딩의 사용을 막습니다 . 이는 뷰 모델을 삽입 된 템플릿에 바인딩하려고 할 때 컴포넌트와 충돌하기 때문입니다. 따라서 if 또는 foreach와 같은 제어 흐름 바인딩을 사용하려면 사용자 지정 요소에서 직접 사용하지 않고 사용자 지정 요소를 감싸 야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="ce5685352c45a8ccb78cdea5682fde3ead2b6d04" translate="yes" xml:space="preserve">
          <source>Knockout will use jQuery&amp;rsquo;s &lt;a href=&quot;http://api.jquery.com/css/&quot;&gt;css&lt;/a&gt; function to set the styles, if available. This lets you take advantage of the extra compatibility features of jQuery, such as setting browser-specific prefixes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="409698893159f365e2fba812abf15b879db2dd76" translate="yes" xml:space="preserve">
          <source>Knockout will use jQuery, if it is present, for handling UI events such as change. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling ko.applyBindings:</source>
          <target state="translated">녹아웃은 jQuery (있는 경우)를 사용하여 변경과 같은 UI 이벤트를 처리합니다. 이 동작을 비활성화하고 Knockout이 항상 기본 이벤트 처리를 사용하도록 지시하려면 ko.applyBindings를 호출하기 전에 코드에서 다음 옵션을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="628ae63ef225d2591f558c7eb5f9fe4b46e164f9" translate="yes" xml:space="preserve">
          <source>Knockout will use jQuery, if it is present, for handling UI events such as click. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling ko.applyBindings:</source>
          <target state="translated">녹아웃은 jQuery (있는 경우)를 사용하여 클릭과 같은 UI 이벤트를 처리합니다. 이 동작을 비활성화하고 Knockout이 항상 기본 이벤트 처리를 사용하도록 지시하려면 ko.applyBindings를 호출하기 전에 코드에서 다음 옵션을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d77ef2ccc75214842d9b2c0a3d534e87e201ecce" translate="yes" xml:space="preserve">
          <source>Knockout will use jQuery, if it is present, for handling UI events. To disable this behavior and instruct Knockout to always use native event handling, you can set the following option in your code before calling ko.applyBindings:</source>
          <target state="translated">녹아웃은 UI 이벤트를 처리하기 위해 jQuery가있는 경우이를 사용합니다. 이 동작을 비활성화하고 Knockout이 항상 기본 이벤트 처리를 사용하도록 지시하려면 ko.applyBindings를 호출하기 전에 코드에서 다음 옵션을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a463ee652f33a4ecb8721a1952f7992b0096faf" translate="yes" xml:space="preserve">
          <source>Knockout wraps internal asynchronous calls and looks for an optional ko.onError callback to execute, if an exception is encountered, before throwing the original error. This gives you the opportunity to run custom logic, such as passing the error to a logging module. Additionally, since the original call is wrapped in a try/catch, the error passed to ko.onError contains a stack property, which is not true in many browsers when handling errors using window.onerror.</source>
          <target state="translated">녹아웃은 내부 비동기 호출을 래핑하고 예외가 발생하면 원래 오류를 발생시키기 전에 실행 가능한 선택적 ko.onError 콜백을 찾습니다. 이를 통해 오류를 로깅 모듈에 전달하는 것과 같은 사용자 지정 논리를 실행할 수 있습니다. 또한 원래 호출은 try / catch로 래핑되므로 ko.onError에 전달 된 오류에는 stack 속성이 포함되어 있습니다. 이는 window.onerror를 사용하여 오류를 처리 할 때 많은 브라우저에서 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="eaba5f2372fd360661055282561600552507d4f4" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s &lt;em&gt;control flow bindings&lt;/em&gt; (e.g., &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;) can be applied not only to regular DOM elements, but also to &amp;ldquo;virtual&amp;rdquo; DOM elements defined by a special comment-based syntax. For example:</source>
          <target state="translated">Knockout의 &lt;em&gt;제어 흐름 바인딩&lt;/em&gt; (예 : &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; 및 &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; )은 일반 DOM 요소뿐만 아니라 특수 주석 기반 구문으로 정의 된 &quot;가상&quot;DOM 요소에도 적용될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10dcefe7d15993a636613b17dda7a5e5e9fcae8a" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s automatic dependency tracking normally does exactly what you want. But you might sometimes need to control which observables will update your computed observable, especially if the computed observable performs some sort of action, such as making an Ajax request. The peek function lets you access an observable or computed observable without creating a dependency.</source>
          <target state="translated">Knockout의 자동 종속성 추적은 일반적으로 원하는 것을 정확하게 수행합니다. 그러나 계산 된 관찰 가능 항목이 Ajax 요청과 같은 일종의 작업을 수행하는 경우 계산 된 관찰 가능 항목을 업데이트 할 관찰 가능 항목을 제어해야 할 수도 있습니다. 엿보기 기능을 사용하면 종속성을 만들지 않고도 관찰 가능 또는 계산 된 관찰 가능에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd482bdf1441531cfa78b4dbd9241b7e06ebb86c" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s declarative binding system provides a concise and powerful way to link data to the UI. It&amp;rsquo;s generally easy and obvious to bind to simple data properties or to use a single binding. For more complex bindings, it helps to better understand the behavior and syntax of Knockout&amp;rsquo;s binding system.</source>
          <target state="translated">Knockout의 선언적 바인딩 시스템은 데이터를 UI에 연결하는 간결하고 강력한 방법을 제공합니다. 간단한 데이터 속성에 바인딩하거나 단일 바인딩을 사용하는 것이 일반적으로 쉽고 명확합니다. 보다 복잡한 바인딩의 경우 Knockout 바인딩 시스템의 동작 및 구문을 더 잘 이해하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="7691338ff4b6fbe0156716cb2ed66851f5e37135" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s microtask queue</source>
          <target state="translated">녹아웃의 마이크로 태스크 대기열</target>
        </trans-unit>
        <trans-unit id="29bf809f39e83f00213a2579389145bb353bc904" translate="yes" xml:space="preserve">
          <source>Knockout&amp;rsquo;s microtask queue supports scheduling tasks to run as soon as possible while still being asynchronous, striving to schedule them to occur before yielding for I/O, reflow, or redrawing. It is used internally for &lt;a href=&quot;component-overview&quot;&gt;Knockout components&lt;/a&gt; to maintain asynchronous behavior, and for scheduling &lt;a href=&quot;deferred-updates&quot;&gt;deferred updates&lt;/a&gt; for observables.</source>
          <target state="translated">Knockout의 마이크로 태스크 대기열은 비동기식을 유지하면서 가능한 빨리 실행되도록 스케줄링 작업을 지원하여 I / O, 리플 로우 또는 다시 그리기에 앞서 작업이 발생하도록 예약하려고합니다. 내부적으로 &lt;a href=&quot;component-overview&quot;&gt;Knockout 구성 요소&lt;/a&gt; 가 비동기 동작을 유지 하고 관찰 가능 항목에 대한 &lt;a href=&quot;deferred-updates&quot;&gt;지연 업데이트&lt;/a&gt; 를 예약 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="eca702ffcf354707c6d7e704262cbeb2920d80d3" translate="yes" xml:space="preserve">
          <source>Knockout.js</source>
          <target state="translated">Knockout.js</target>
        </trans-unit>
        <trans-unit id="8c7dca686f307018a9b4d98dff3ae5fb4bbceb4a" translate="yes" xml:space="preserve">
          <source>Later, when you&amp;rsquo;re asked to implement the &amp;lsquo;Delete&amp;rsquo; functionality, you don&amp;rsquo;t have to figure out what bits of the UI it has to interact with; you just make it alter the underlying data model.</source>
          <target state="translated">나중에 '삭제'기능을 구현하라는 메시지가 표시 될 때 UI의 어떤 비트와 상호 작용해야하는지 알 필요가 없습니다. 기본 데이터 모델을 변경하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="824d76b124e6289f372e2ff6bcba91e8939343bd" translate="yes" xml:space="preserve">
          <source>Learn more</source>
          <target state="translated">더 알아보기</target>
        </trans-unit>
        <trans-unit id="1f2e2bde04a28d8be8e4af5907acc2fba80505c0" translate="yes" xml:space="preserve">
          <source>Learn more about configuring and registering components with the default loader</source>
          <target state="translated">기본 로더를 사용하여 구성 요소 구성 및 등록에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="6be1bb6cdfa52ff974724e62faceb68b7d67cb10" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have a JavaScript object that looks like this:</source>
          <target state="translated">다음과 같은 JavaScript 객체가 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="94f3d8639201581d19e8cd3a9912e85ca0fa345a" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s update the code for randomOrder, this time using KO&amp;rsquo;s virtual element APIs:</source>
          <target state="translated">KO의 가상 요소 API를 사용하여 randomOrder의 코드를 업데이트하겠습니다.</target>
        </trans-unit>
        <trans-unit id="58fd3b1b83cc7fc933d72fe934bdb6e534441281" translate="yes" xml:space="preserve">
          <source>Licensed under the MIT License.</source>
          <target state="translated">MIT 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="7d96c306a2bdbcd8c8b74b52fb7d8e32e3c7d783" translate="yes" xml:space="preserve">
          <source>Like components, &lt;a href=&quot;custom-bindings-controlling-descendant-bindings&quot;&gt;custom bindings that control descendant bindings&lt;/a&gt; can use ko.bindingEvent.subscribe to run post-processing logic. However, in order to subscribe to the descendantsComplete event, you also need to tell Knockout that your binding is involved in asynchronous notifications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a22c0dccba3224320a8069043f5f6f3d98d749d5" translate="yes" xml:space="preserve">
          <source>Live Example 1: Forcing input to be numeric</source>
          <target state="translated">라이브 예 1 : 입력을 숫자로 강제 적용</target>
        </trans-unit>
        <trans-unit id="a999d211200204fb1d5f89b2e98b09601e4ab925" translate="yes" xml:space="preserve">
          <source>Live Example 2: Adding validation to an observable</source>
          <target state="translated">라이브 예 2 : 옵저버 블에 유효성 검사 추가</target>
        </trans-unit>
        <trans-unit id="f19646932df2821a76d070d391a81a56f5b95215" translate="yes" xml:space="preserve">
          <source>Live example</source>
          <target state="translated">라이브 예</target>
        </trans-unit>
        <trans-unit id="c96856283b27b5efa4c99dbc46c686a71954647b" translate="yes" xml:space="preserve">
          <source>Live example: nested children</source>
          <target state="translated">라이브 예 : 중첩 된 자식</target>
        </trans-unit>
        <trans-unit id="ce4efabbd5fd9902131eac73e8e59cb786288b4a" translate="yes" xml:space="preserve">
          <source>Live examples are not available on DevDocs, sorry.</source>
          <target state="translated">DevDocs에서는 라이브 예제를 사용할 수 없습니다. 죄송합니다.</target>
        </trans-unit>
        <trans-unit id="e8179062abf1c808535e17f3bba054486e091bd3" translate="yes" xml:space="preserve">
          <source>Loading Knockout.js and a ViewModel class via RequireJs</source>
          <target state="translated">RequireJs를 통해 Knockout.js 및 ViewModel 클래스로드</target>
        </trans-unit>
        <trans-unit id="7a1275f750d43f39de53842ed4dbab527886627e" translate="yes" xml:space="preserve">
          <source>Loading Knockout.js, a Binding Handler, and a ViewModel class via RequireJs</source>
          <target state="translated">RequireJs를 통해 Knockout.js, 바인딩 핸들러 및 ViewModel 클래스로드</target>
        </trans-unit>
        <trans-unit id="a6971a11e0a52091a5c953372bb00569922b2df7" translate="yes" xml:space="preserve">
          <source>Loading and Saving JSON data</source>
          <target state="translated">JSON 데이터로드 및 저장</target>
        </trans-unit>
        <trans-unit id="28f44d40c76afc7d7591cf58f327b1bbe21530d4" translate="yes" xml:space="preserve">
          <source>Loading or Saving Data</source>
          <target state="translated">데이터로드 또는 저장</target>
        </trans-unit>
        <trans-unit id="902d451cfddbf1a7bd9bf785b56f8ce391deaaca" translate="yes" xml:space="preserve">
          <source>Logically, 'major highlight': isSevere is equivalent to major: isSevere, highlight: isSevere. It&amp;rsquo;s merely a shortcut syntax if you want two or more CSS classes to be set and unset together.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac600279c0db054ae2804d05146b63ba0414ceea" translate="yes" xml:space="preserve">
          <source>MVVM and View Models</source>
          <target state="translated">MVVM 및 뷰 모델</target>
        </trans-unit>
        <trans-unit id="d0132e7037dde4a1569f3f0cf422fc539613ba46" translate="yes" xml:space="preserve">
          <source>Main Parameter</source>
          <target state="translated">주요 매개 변수</target>
        </trans-unit>
        <trans-unit id="1b773120102a6c1a24da236928541cb48a5ec94c" translate="yes" xml:space="preserve">
          <source>Main parameter</source>
          <target state="translated">주요 매개 변수</target>
        </trans-unit>
        <trans-unit id="042abe727f60c8d9932534243bb81872b7416c98" translate="yes" xml:space="preserve">
          <source>Making things respond after a certain delay</source>
          <target state="translated">일정 지연 후 상황에 대응</target>
        </trans-unit>
        <trans-unit id="c8a5870106ccf1eddcdec83e7b076fb5c8b992dd" translate="yes" xml:space="preserve">
          <source>Managing &amp;lsquo;this&amp;rsquo;</source>
          <target state="translated">'this'관리</target>
        </trans-unit>
        <trans-unit id="8f860a27c927a94a2081dcaffc79957c81d02b57" translate="yes" xml:space="preserve">
          <source>Manipulating an observableArray</source>
          <target state="translated">ObservableArray 조작</target>
        </trans-unit>
        <trans-unit id="f22316e0ceeda20484d97d991e8da0112dd866d9" translate="yes" xml:space="preserve">
          <source>Manually-created &lt;strong&gt;event handlers&lt;/strong&gt; on external DOM elements, if created inside a createViewModel function (or even inside a regular component viewmodel, although to fit the MVVM pattern you shouldn&amp;rsquo;t) must be removed.</source>
          <target state="translated">createViewModel 함수 내에서 (또는 MVVM 패턴에 맞지 않아도 일반 컴포넌트 뷰 모델 내에서) 작성된 경우 외부 DOM 요소에서 수동으로 작성된 &lt;strong&gt;이벤트 핸들러&lt;/strong&gt; 를 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="588de813ea47b650faf54523ad98714b629c740e" translate="yes" xml:space="preserve">
          <source>Mapped observable array</source>
          <target state="translated">매핑 된 관측 가능 배열</target>
        </trans-unit>
        <trans-unit id="def2eba59562958fa4a005f8070d692ef8502312" translate="yes" xml:space="preserve">
          <source>Mapping</source>
          <target state="translated">Mapping</target>
        </trans-unit>
        <trans-unit id="996b905af8ff85c85478f1f8432f440056372995" translate="yes" xml:space="preserve">
          <source>Mapping from multiple sources</source>
          <target state="translated">여러 소스에서 매핑</target>
        </trans-unit>
        <trans-unit id="7e632657a4c6244bb198de62ec1571b6dfbf8396" translate="yes" xml:space="preserve">
          <source>Mapping options that you specify in each call will be merged.</source>
          <target state="translated">각 통화에서 지정하는 매핑 옵션이 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="0c19d4dee164eb75d3ed611fe2afd01eccf8b645" translate="yes" xml:space="preserve">
          <source>Microtasks</source>
          <target state="translated">Microtasks</target>
        </trans-unit>
        <trans-unit id="1ee20630e0871cafa9aed0bf7aa0013db967c5b0" translate="yes" xml:space="preserve">
          <source>Microtasks can be canceled using the &lt;em&gt;handle&lt;/em&gt; value returned from ko.tasks.schedule. If the task has already run or was previously canceled, cancel does nothing.</source>
          <target state="translated">ko.tasks.schedule에서 리턴 된 &lt;em&gt;핸들&lt;/em&gt; 값을 사용하여 마이크로 태스크를 취소 할 수 있습니다 . 작업이 이미 실행되었거나 이전에 취소 된 경우 cancel은 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="53e411847528d541c26c3c00ed9603e00cf5d49c" translate="yes" xml:space="preserve">
          <source>Modifying observables after DOM events</source>
          <target state="translated">DOM 이벤트 후 옵저버 블 수정</target>
        </trans-unit>
        <trans-unit id="148523423d67830c8f1a8a3e23b0aa52da24e903" translate="yes" xml:space="preserve">
          <source>More more detailed information, see:</source>
          <target state="translated">더 자세한 정보는 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="03e0bcfaabb4306e0ad24ddb4448860d09263fb3" translate="yes" xml:space="preserve">
          <source>More than one extender can be applied in a single call to the .extend method of an observable.</source>
          <target state="translated">Observable의 .extend 메소드에 대한 단일 호출로 둘 이상의 익스텐더를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a842f6a98c04fd60847152441adf06e65c2bcdb" translate="yes" xml:space="preserve">
          <source>Most applications need to fetch data from a backend server. Since the server doesn&amp;rsquo;t have any concept of observables, it will just supply a plain JavaScript object (usually serialized as JSON). The mapping plugin gives you a straightforward way to map that plain JavaScript object into a view model with the appropriate observables. This is an alternative to manually writing your own JavaScript code that constructs a view model based on some data you&amp;rsquo;ve fetched from the server.</source>
          <target state="translated">대부분의 응용 프로그램은 백엔드 서버에서 데이터를 가져와야합니다. 서버에는 관찰 가능한 개념이 없으므로 일반 JavaScript 객체 (일반적으로 JSON으로 직렬화 됨) 만 제공합니다. 매핑 플러그인을 사용하면 해당 일반 JavaScript 객체를 적절한 옵저버 블이있는 뷰 모델에 매핑 할 수 있습니다. 이는 서버에서 가져온 일부 데이터를 기반으로 뷰 모델을 구성하는 고유 한 JavaScript 코드를 수동으로 작성하는 대안입니다.</target>
        </trans-unit>
        <trans-unit id="e4d448139b3552f2ce58ee18a84ae6283ba5f3bb" translate="yes" xml:space="preserve">
          <source>Multiple component loaders may be consulted, until the first one recognises the component name and supplies a viewmodel/template. This process only takes place &lt;strong&gt;once per component type&lt;/strong&gt;, since Knockout caches the resulting definitions in memory.</source>
          <target state="translated">첫 번째 컴포넌트가 컴포넌트 이름을 인식하고 뷰 모델 / 템플릿을 제공 할 때까지 여러 컴포넌트 로더를 참조 할 수 있습니다. 녹아웃은 결과 정의를 메모리에 캐시하므로이 프로세스 &lt;strong&gt;는 구성 요소 유형 당 한 번만&lt;/strong&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6a6cd3eea908b0b2a5c411ea2342c43a36c3d759" translate="yes" xml:space="preserve">
          <source>Next, you want to fetch the latest data from the server. Every 5 seconds you might issue an Ajax request (e.g., using jQuery&amp;rsquo;s $.getJSON or $.ajax functions):</source>
          <target state="translated">다음으로 서버에서 최신 데이터를 가져 오려고합니다. 5 초마다 Ajax 요청을 발행 할 수 있습니다 (예 : jQuery의 $ .getJSON 또는 $ .ajax 함수 사용) :</target>
        </trans-unit>
        <trans-unit id="5f490764c270257caa7816a634ad9ceb0029f602" translate="yes" xml:space="preserve">
          <source>No matter how nested the links become, the handler is always able to identify and operate on the appropriate data. Using this techinique, we can avoid the overhead of attaching handlers to each individual link and can keep the markup clean and concise.</source>
          <target state="translated">링크가 아무리 중첩 되더라도 핸들러는 항상 적절한 데이터를 식별하고 조작 할 수 있습니다. 이 기술을 사용하면 각 개별 링크에 처리기를 연결하는 오버 헤드를 피하고 마크 업을 깨끗하고 간결하게 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afa1839782d1d70ed8698b21df5705b582780b4b" translate="yes" xml:space="preserve">
          <source>Non-boolean values are interpreted loosely as boolean. For example, 0 and null are treated as false, whereas 21 and non-null objects are treated as true.</source>
          <target state="translated">부울이 아닌 값은 느슨하게 부울로 해석됩니다. 예를 들어, 0과 null은 false로 취급되는 반면, 21과 null이 아닌 객체는 true로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="065695e32c88230ab4bdf412903d650d890a874e" translate="yes" xml:space="preserve">
          <source>Non-boolean values are interpreted loosely as boolean. For example, 0 and null are treated as false, whereas 21 and non-null objects are treated as true. If your parameter references an observable value, the binding will add or remove the CSS class whenever the observable value changes. If the parameter doesn&amp;rsquo;t reference an observable value, it will only add or remove the class once and will not do so again later. As usual, you can use arbitrary JavaScript expressions or functions as parameter values. Knockout will evaluate them and use the resulting values to determine the appropriate CSS classes to add or remove.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="b7e6ebe0a5573c6fa19a2a0f36cfae8a5b91c39f" translate="yes" xml:space="preserve">
          <source>None, other than the core Knockout library.</source>
          <target state="translated">핵심 녹아웃 라이브러리 외에는 없습니다.</target>
        </trans-unit>
        <trans-unit id="db09b0691b02a98f1c82dcb9d3a19d0909373cf6" translate="yes" xml:space="preserve">
          <source>Normally, Knockout consults the loaders &lt;em&gt;once per component name&lt;/em&gt;, then caches the resulting definition. This ensures that large numbers of components may be instantiated very quickly. If you want to clear the cache entry for a given component, call this, and then the loaders will be consulted again the next time that component is needed.</source>
          <target state="translated">일반적으로 Knockout &lt;em&gt;은 구성 요소 이름 당 한 번&lt;/em&gt; 로더 를 참조한 다음 결과 정의를 캐시합니다. 이를 통해 많은 수의 구성 요소를 매우 빠르게 인스턴스화 할 수 있습니다. 주어진 구성 요소에 대한 캐시 항목을 지우려면이를 호출하면 다음에 해당 구성 요소가 필요할 때 로더에 대해 다시 문의합니다.</target>
        </trans-unit>
        <trans-unit id="eeec499c3f627d57c3576dc1e65df40411bba37d" translate="yes" xml:space="preserve">
          <source>Normally, Knockout ensures that component loading, and hence component injection, always completes asynchronously, because &lt;em&gt;sometimes it has no choice but to be asynchronous&lt;/em&gt; (e.g., because it involves a request to the server). It does this even if a particular component instance could be injected synchronously (e.g., because the component definition was already loaded). This always-asynchronous policy is a matter of consistency, and is a well-established convention inherited from other modern asynchronous JavaScript technologies, such as AMD. The convention is a safe default &amp;mdash; it mitigates potential bugs where a developer might not account for the possibility of a typically-asynchronous process sometimes completing synchronously or vice-versa.</source>
          <target state="translated">일반적으로, Knockout은 구성 요소 로딩 및 구성 요소 주입이 항상 비동기식으로 완료되도록 보장합니다. &lt;em&gt;때로는 비동기식 이외의 선택이 없기&lt;/em&gt; 때문입니다 (예 : 서버에 대한 요청이 포함되기 때문). 특정 구성 요소 인스턴스가 동기식으로 주입 될 수있는 경우에도 (예 : 구성 요소 정의가 이미로드되어 있기 때문에)이를 수행합니다. 이 비동기식 정책은 일관성의 문제이며 AMD와 같은 다른 최신 비동기 JavaScript 기술에서 상속 된 잘 확립 된 규칙입니다. 이 규칙은 안전한 기본값입니다. 이는 개발자가 일반적으로 비동기 프로세스가 때때로 동 기적으로 또는 그 반대로 완료 될 가능성을 설명하지 않을 수있는 잠재적 버그를 완화합니다.</target>
        </trans-unit>
        <trans-unit id="6524854e62e38125ced06867534d8b38f18ad484" translate="yes" xml:space="preserve">
          <source>Normally, a computed observable updates and notifies its subscribers immediately, as soon as its dependencies change. But if a computed observable has many dependencies or involves expensive updates, you may get better performance by limiting or delaying the computed observable&amp;rsquo;s updates and notifications. This is accomplished using the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt; like this:</source>
          <target state="translated">일반적으로 계산 가능한 관찰 가능 항목은 종속성이 변경되는 즉시 구독자에게 즉시 알림을 보냅니다. 그러나 계산 된 관찰 가능 항목에 많은 종속성이 있거나 값 비싼 업데이트가 필요한 경우 계산 된 관찰 가능 항목의 업데이트 및 알림을 제한하거나 지연시켜 성능을 향상시킬 수 있습니다. 이것은 다음 과 같이 &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit 익스텐더를&lt;/a&gt; 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="de8510f955a76aae57a6decf3b1d448a2721eab0" translate="yes" xml:space="preserve">
          <source>Normally, an &lt;a href=&quot;observables&quot;&gt;observable&lt;/a&gt; that is changed notifies its subscribers immediately, so that any computed observables or bindings that depend on the observable are updated synchronously. The rateLimit extender, however, causes an observable to suppress and delay change notifications for a specified period of time. A rate-limited observable therefore updates dependencies asynchronously.</source>
          <target state="translated">일반적으로 변경 되는 &lt;a href=&quot;observables&quot;&gt;Observable&lt;/a&gt; 은 구독자에게 즉시 알리므로 Observable에 의존하는 계산 된 Observable 또는 바인딩이 동 기적으로 업데이트됩니다. 그러나 rateLimit 익스텐더는 Observable이 지정된 기간 동안 변경 알림을 억제하고 지연 시키도록합니다. 따라서 속도 제한 옵저버 블은 종속성을 비동기 적으로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="85e4e3194fb98ff27c2137c8428ce2e4d1b258a4" translate="yes" xml:space="preserve">
          <source>Normally, an observable notifies its subscribers immediately, as soon as it&amp;rsquo;s changed. But if an observable is changed repeatedly or triggers expensive updates, you may get better performance by limiting or delaying the observable&amp;rsquo;s change notifications. This is accomplished using the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt; like this:</source>
          <target state="translated">일반적으로 Observable은 변경되는 즉시 구독자에게 즉시 알립니다. 그러나 Observable이 반복적으로 변경되거나 고가의 업데이트가 트리거되는 경우 Observable의 변경 알림을 제한하거나 지연시켜 성능을 향상시킬 수 있습니다. 이것은 다음 과 같이 &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit 익스텐더를&lt;/a&gt; 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="971d310ac30608c092a71563e91ea63dc1528f2c" translate="yes" xml:space="preserve">
          <source>Normally, an observableArray notifies its subscribers immediately, as soon as it&amp;rsquo;s changed. But if an observableArray is changed repeatedly or triggers expensive updates, you may get better performance by limiting or delaying change notifications. This is accomplished using the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt; like this:</source>
          <target state="translated">일반적으로 observableArray는 변경되는 즉시 구독자에게 즉시 알립니다. 그러나 observableArray가 반복적으로 변경되거나 고가의 업데이트를 트리거하는 경우 변경 알림을 제한하거나 지연시켜 성능을 향상시킬 수 있습니다. 이것은 다음 과 같이 &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit 익스텐더를&lt;/a&gt; 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="a43fe63b87c4cb41558a04d9c42885616a56c55a" translate="yes" xml:space="preserve">
          <source>Normally, bindings that use controlsDescendantBindings will also call ko.applyBindingsToDescendants(someBindingContext, element) to apply the descendant bindings against some modified &lt;a href=&quot;binding-context&quot;&gt;binding context&lt;/a&gt;. For example, you could have a binding called withProperties that attaches some extra properties to the binding context that will then be available to all descendant bindings:</source>
          <target state="translated">일반적으로 controlsDescendantBindings를 사용하는 바인딩은 ko.applyBindingsToDescendants (someBindingContext, element)를 호출하여 일부 수정 된 &lt;a href=&quot;binding-context&quot;&gt;바인딩 컨텍스트&lt;/a&gt; 에 대해 하위 바인딩을 적용합니다 . 예를 들어 withProperties라는 바인딩을 사용하여 바인딩 컨텍스트에 일부 추가 속성을 첨부 한 다음 모든 하위 바인딩에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b15e1efcc6bbdd05b9bb899a299cf912de21af36" translate="yes" xml:space="preserve">
          <source>Normally, computed observables have a value that is computed from other observables and are therefore &lt;em&gt;read-only&lt;/em&gt;. What may seem surprising, then, is that it is possible to make computed observables &lt;em&gt;writable&lt;/em&gt;. You just need to supply your own callback function that does something sensible with written values.</source>
          <target state="translated">일반적으로 계산 된 관찰 가능 값은 다른 관찰 가능 값에서 계산 된 값을 가지므로 &lt;em&gt;읽기 전용&lt;/em&gt; 입니다. 그러므로 놀랍게 보일 수있는 것은 계산 된 관측 &lt;em&gt;가능&lt;/em&gt; 객체를 &lt;em&gt;쓰기&lt;/em&gt; 가능하게 만드는 것 입니다. 필기 값으로 합리적인 기능을 수행하는 고유 한 콜백 함수를 제공하면됩니다.</target>
        </trans-unit>
        <trans-unit id="d425a57c002e80bcb922861fb6ad11cb4606ddb8" translate="yes" xml:space="preserve">
          <source>Normally, if you change name as follows:</source>
          <target state="translated">일반적으로 다음과 같이 이름을 변경하면</target>
        </trans-unit>
        <trans-unit id="ea5e697b7346a3eeff279e706b4abc4448a43fae" translate="yes" xml:space="preserve">
          <source>Normally, in this case myButtonHandler would be called first, then the click event would bubble up to myDivHandler. However, the clickBubble binding that we added with a value of false prevents the event from making it past myButtonHandler.</source>
          <target state="translated">일반적으로이 경우 myButtonHandler가 먼저 호출 된 다음 click 이벤트가 myDivHandler로 버블 링됩니다. 그러나 false 값으로 추가 한 clickBubble 바인딩은 이벤트가 myButtonHandler를 지나서 이벤트를 작성하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="fc7808246a4e59ebea4927b73d56662e9805e699" translate="yes" xml:space="preserve">
          <source>Normally, in this case myButtonHandler would be called first, then the event would bubble up to myDivHandler. However, the mouseoverBubble binding that we added with a value of false prevents the event from making it past myButtonHandler.</source>
          <target state="translated">일반적으로이 경우 myButtonHandler가 먼저 호출 된 다음 이벤트가 myDivHandler로 버블 링됩니다. 그러나 false 값으로 추가 한 mouseoverBubble 바인딩은 이벤트가 myButtonHandler를 지나서 이벤트를 작성하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="a70aaac2826c5ee7760b4f9bcd2d5cf62e31d0b4" translate="yes" xml:space="preserve">
          <source>Normally, the &lt;a href=&quot;with-binding&quot;&gt;with&lt;/a&gt; and &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; bindings notify &amp;ldquo;completeness&amp;rdquo; even if they are bound to a null or false value and therefore clear the node&amp;rsquo;s contents instead of binding them. But if you use such a control-flow binding to delay binding until part of your viewmodel is finished initializing, it may be more appropriate to also delay the binding notifications. This could be important to delay an outer node&amp;rsquo;s descendantsComplete event. To do so, include the completeOn: &quot;render&quot; option with the binding. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f00011c53827e97e83b74eeaeeb5176dcdd95e89" translate="yes" xml:space="preserve">
          <source>Normally, this is an &lt;em&gt;asynchronous&lt;/em&gt; process. It may involve requests to the server. For API consistency, Knockout by default ensures that the loading process completes as an asynchronous callback even if the component is already loaded and cached in memory. For more about this, and how to allow synchronous loading, see &lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;Controlling synchronous/asynchronous loading&lt;/a&gt;.</source>
          <target state="translated">일반적으로 이것은 &lt;em&gt;비동기&lt;/em&gt; 프로세스입니다. 서버에 대한 요청이 포함될 수 있습니다. API 일관성을 위해 기본적으로 Knockout은 구성 요소가 메모리에 이미로드되어 캐시되어 있어도로드 프로세스가 비동기 콜백으로 완료되도록합니다. 이에 대한 자세한 내용 및 동기로드를 허용하는 방법은 &lt;a href=&quot;component-registration#controlling-synchronousasynchronous-loading&quot;&gt;동기 / 비동기로드 제어를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5928082628ac47958f2a49985793c5a9cfe7a4ac" translate="yes" xml:space="preserve">
          <source>Normally, when you use the value binding on a &amp;lt;select&amp;gt; element, it means that you want the associated model value to describe which item in the &amp;lt;select&amp;gt; is selected. But what happens if you set the model value to something that has no corresponding entry in the list? The default behavior is for Knockout to overwrite your model value to reset it to whatever is already selected in the dropdown, thereby preventing the model and UI from getting out of sync.</source>
          <target state="translated">일반적으로 &amp;lt;select&amp;gt; 요소에 값 바인딩을 사용하는 경우 &amp;lt;select&amp;gt;의 어떤 항목이 선택되었는지 설명하는 연관된 모델 값을 원한다는 의미입니다. 그러나 모델 값을 목록에 해당 항목이없는 것으로 설정하면 어떻게됩니까? 기본 동작은 Knockout이 모델 값을 덮어 써서 드롭 다운에서 이미 선택한 값으로 재설정하여 모델과 UI가 동기화되지 않도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b0d7a6b36856238f1888ea77959ac6db008365ad" translate="yes" xml:space="preserve">
          <source>Normally, when you&amp;rsquo;re using control flow bindings (foreach, with, if, etc.), there&amp;rsquo;s no need to give names to your templates: they are defined implicitly and anonymously by the markup inside your DOM element. But if you want to, you can factor out templates into a separate element and then reference them by name:</source>
          <target state="translated">일반적으로 제어 흐름 바인딩 (예 : with, if 등)을 사용하는 경우 템플릿에 이름을 지정할 필요가 없습니다. 템플릿은 DOM 요소 내부의 태그에 의해 암시 적으로 익명으로 정의됩니다. 그러나 원하는 경우 템플릿을 별도의 요소로 분리 한 다음 이름으로 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="892c7a538c26d5912a114ef4c5b4dd9cb750dea3" translate="yes" xml:space="preserve">
          <source>Not all browsers support JavaScript getters and setters (* cough * IE * cough *), so for compatibility, ko.observable objects are actually &lt;em&gt;functions&lt;/em&gt;.</source>
          <target state="translated">모든 브라우저가 JavaScript getter 및 setter (* cough * IE * cough *)를 지원하는 것은 아니므로 호환성을 위해 ko.observable 객체는 실제로 &lt;em&gt;함수&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5a2a88914badea0501ca78d4a26a3df5411beb0f" translate="yes" xml:space="preserve">
          <source>Note 1: Applying styles whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="312a5f5143031f243bb9a60c2b68ea23336cd99f" translate="yes" xml:space="preserve">
          <source>Note 1: Getting value updates instantly from inputs</source>
          <target state="translated">참고 1 : 입력에서 즉시 값 업데이트 받기</target>
        </trans-unit>
        <trans-unit id="5fab9187a677e6b78569955d9666c1ccb6694140" translate="yes" xml:space="preserve">
          <source>Note 1: Passing a &amp;ldquo;current item&amp;rdquo; as a parameter to your handler function</source>
          <target state="translated">참고 1 : 핸들러 함수에 매개 변수로 &quot;현재 항목&quot;전달</target>
        </trans-unit>
        <trans-unit id="3a814cb6ad3dec3e35271de124fcb52fc7ea8a30" translate="yes" xml:space="preserve">
          <source>Note 1: Referring to each array entry using $data</source>
          <target state="translated">참고 1 : $ data를 사용하여 각 배열 항목 참조</target>
        </trans-unit>
        <trans-unit id="ca9ba60cb79484ae10cbb526fdec0d6b22f6191b" translate="yes" xml:space="preserve">
          <source>Note 1: Rendering a named template</source>
          <target state="translated">참고 1 : 명명 된 템플릿 렌더링</target>
        </trans-unit>
        <trans-unit id="8cb27abf41be27c85ca84a090a734e919e5e138f" translate="yes" xml:space="preserve">
          <source>Note 1: Selection is preserved when setting/changing options</source>
          <target state="translated">참고 1 : 옵션 설정 / 변경시 선택 사항이 유지됩니다</target>
        </trans-unit>
        <trans-unit id="8cab987f23a9bac56add3eebe707607f36a2ea67" translate="yes" xml:space="preserve">
          <source>Note 1: Using &amp;ldquo;let&amp;rdquo; without a container element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ebaabfbfb4ad642b58d8dfcc7e5c4ff9d66877" translate="yes" xml:space="preserve">
          <source>Note 1: Using &amp;ldquo;with&amp;rdquo; or &amp;ldquo;using&amp;rdquo; without a container element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ce25db4800747a44dd7be30e5487498ca714b8" translate="yes" xml:space="preserve">
          <source>Note 1: Using &amp;ldquo;with&amp;rdquo; without a container element</source>
          <target state="translated">참고 1 : 컨테이너 요소없이 &quot;with&quot;사용</target>
        </trans-unit>
        <trans-unit id="42e4b385f89381daa4e0c5e3ef0819aa9d2954e1" translate="yes" xml:space="preserve">
          <source>Note 1: Using functions and expressions to detemine text values</source>
          <target state="translated">참고 1 : 함수 및 표현식을 사용하여 텍스트 값 판별</target>
        </trans-unit>
        <trans-unit id="a1e70856ca0bef317ab669b291a07dba08a49ed6" translate="yes" xml:space="preserve">
          <source>Note 1: textInput vs value binding</source>
          <target state="translated">참고 1 : 텍스트 입력과 값 바인딩</target>
        </trans-unit>
        <trans-unit id="890064c263ea4cdf85ec4df05608a767470d9dee" translate="yes" xml:space="preserve">
          <source>Note 2: About HTML encoding</source>
          <target state="translated">참고 2 : HTML 인코딩 정보</target>
        </trans-unit>
        <trans-unit id="44d94bff3e26ecd38bca324673da6818a6524a66" translate="yes" xml:space="preserve">
          <source>Note 2: Accessing the event object, or passing more parameters</source>
          <target state="translated">참고 2 : 이벤트 오브젝트에 액세스하거나 더 많은 매개 변수 전달</target>
        </trans-unit>
        <trans-unit id="bc192205bb6999807250e198d100299a2633603b" translate="yes" xml:space="preserve">
          <source>Note 2: Performance considerations when using &amp;ldquo;let&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fa0d7caea5eed0f78bbea6e5338469a3a2dc28c" translate="yes" xml:space="preserve">
          <source>Note 2: Post-processing the generated options</source>
          <target state="translated">참고 2 : 생성 된 옵션 후 처리</target>
        </trans-unit>
        <trans-unit id="61e119aef6a09c668ea64e8f185afb7cb5e1a1c1" translate="yes" xml:space="preserve">
          <source>Note 2: Setting styles which require a unit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba1677efb75559f0bfd41b60da29baf1f864a1f9" translate="yes" xml:space="preserve">
          <source>Note 2: Using $index, $parent, and other context properties</source>
          <target state="translated">참고 2 : $ index, $ parent 및 기타 컨텍스트 속성 사용</target>
        </trans-unit>
        <trans-unit id="8999863783c665a40bdd09bd691a298f8f656468" translate="yes" xml:space="preserve">
          <source>Note 2: Using the &amp;ldquo;foreach&amp;rdquo; option with a named template</source>
          <target state="translated">참고 2 : 이름이 지정된 템플릿에 &quot;foreach&quot;옵션 사용</target>
        </trans-unit>
        <trans-unit id="7026de456ff3382a0e236d7fac1891af4a1a5c1c" translate="yes" xml:space="preserve">
          <source>Note 2: Why are there two similar bindings?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da2d8c3723f8725ce919b58379e9c2909628d4ef" translate="yes" xml:space="preserve">
          <source>Note 2: Working with drop-down lists (i.e., &amp;lt;select&amp;gt; elements)</source>
          <target state="translated">참고 2 : 드롭 다운 목록 작업 (예 : &amp;lt;select&amp;gt; 요소)</target>
        </trans-unit>
        <trans-unit id="a2c468fee63b93cfdf8f4899d1272df0051f3f42" translate="yes" xml:space="preserve">
          <source>Note 3: Allowing the default action</source>
          <target state="translated">참고 3 : 기본 작업 허용</target>
        </trans-unit>
        <trans-unit id="961ff8e09bdf3aa8b1b204afa8f0a5e5a818618c" translate="yes" xml:space="preserve">
          <source>Note 3: Allowing the default click action</source>
          <target state="translated">참고 3 : 기본 클릭 동작 허용</target>
        </trans-unit>
        <trans-unit id="0fc1a8ea173efa6a26682559149d35b58c72587a" translate="yes" xml:space="preserve">
          <source>Note 3: Enhanced functionality when jQuery is present</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71e882f5d136c5c9ff8d8962c222ce417eb151f4" translate="yes" xml:space="preserve">
          <source>Note 3: Updating observable and non-observable property values</source>
          <target state="translated">참고 3 : 관찰 가능 및 관찰 불가능 속성 값 업데이트</target>
        </trans-unit>
        <trans-unit id="7588edf8b51bfb005ba96690f74a34daa01047a1" translate="yes" xml:space="preserve">
          <source>Note 3: Using &amp;ldquo;as&amp;rdquo; to give an alias to &amp;ldquo;foreach&amp;rdquo; items</source>
          <target state="translated">참고 3 : &quot;as&quot;를 사용하여 &quot;foreach&quot;항목에 대한 별칭 제공</target>
        </trans-unit>
        <trans-unit id="f42f724af26e21363687b0dda2ed01310ea7ab5a" translate="yes" xml:space="preserve">
          <source>Note 3: Using &amp;ldquo;text&amp;rdquo; without a container element</source>
          <target state="translated">참고 3 : 컨테이너 요소없이 &quot;텍스트&quot;사용</target>
        </trans-unit>
        <trans-unit id="a3a20f1b394f93301d92f03c60d60e1549f40c99" translate="yes" xml:space="preserve">
          <source>Note 4: About an IE 6 whitespace quirk</source>
          <target state="translated">참고 4 : IE 6 공백 문제</target>
        </trans-unit>
        <trans-unit id="23419d68201af3e1cc15bff11daeeb0f79f2c99c" translate="yes" xml:space="preserve">
          <source>Note 4: Preventing the event from bubbling</source>
          <target state="translated">참고 4 : 이벤트 버블 링 방지</target>
        </trans-unit>
        <trans-unit id="3e526ff19533fbdea78f0e87c923669d66b13daf" translate="yes" xml:space="preserve">
          <source>Note 4: Using &amp;ldquo;afterRender&amp;rdquo;, &amp;ldquo;afterAdd&amp;rdquo;, and &amp;ldquo;beforeRemove&amp;rdquo;</source>
          <target state="translated">참고 4 : &quot;afterRender&quot;, &quot;afterAdd&quot;및 &quot;beforeRemove&quot;사용</target>
        </trans-unit>
        <trans-unit id="2163a402155b39d7e2c760112b0647ef85484e62" translate="yes" xml:space="preserve">
          <source>Note 4: Using foreach without a container element</source>
          <target state="translated">참고 4 : 컨테이너 요소없이 foreach 사용</target>
        </trans-unit>
        <trans-unit id="c786ee828c774288377fdaba163a22ff298763be" translate="yes" xml:space="preserve">
          <source>Note 4: Using the value binding with the checked binding</source>
          <target state="translated">참고 4 : 확인 된 바인딩과 함께 값 바인딩 사용</target>
        </trans-unit>
        <trans-unit id="ea9b887209a1ac7ee930f38b5412044c510f0f34" translate="yes" xml:space="preserve">
          <source>Note 5: Dynamically choosing which template is used</source>
          <target state="translated">참고 5 : 사용할 템플릿을 동적으로 선택</target>
        </trans-unit>
        <trans-unit id="3bff1a14c09530d5378f91032bbee6d975eeab75" translate="yes" xml:space="preserve">
          <source>Note 5: How array changes are detected and handled</source>
          <target state="translated">참고 5 : 배열 변경을 감지하고 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="34f5c157ce0b3313df132dd29f97171e41483cf0" translate="yes" xml:space="preserve">
          <source>Note 5: Interaction with jQuery</source>
          <target state="translated">참고 5 : jQuery와의 상호 작용</target>
        </trans-unit>
        <trans-unit id="7bdb9fca3db83a1d3859d688638577c6ee88ba7f" translate="yes" xml:space="preserve">
          <source>Note 6: Destroyed entries are hidden by default</source>
          <target state="translated">참고 6 : 파괴 된 항목은 기본적으로 숨겨져 있습니다.</target>
        </trans-unit>
        <trans-unit id="644fea2c743dda120843a65ecaaaaf53c3e37f54" translate="yes" xml:space="preserve">
          <source>Note 6: Hiding destroyed entries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a357c555f225c8e2949ce0c275baf99efa923731" translate="yes" xml:space="preserve">
          <source>Note 6: Using jQuery.tmpl, an external string-based template engine</source>
          <target state="translated">참고 6 : 외부 문자열 기반 템플릿 엔진 인 jQuery.tmpl 사용</target>
        </trans-unit>
        <trans-unit id="3b8b656336f81c4a99e466d9c14848a3f391c670" translate="yes" xml:space="preserve">
          <source>Note 7: Post-processing or animating the generated DOM elements</source>
          <target state="translated">참고 7 : 생성 된 DOM 요소 후 처리 또는 애니메이션</target>
        </trans-unit>
        <trans-unit id="d7bcd8dcb7fb8e81342016d8da6a4aa51bb7c3a9" translate="yes" xml:space="preserve">
          <source>Note 7: Using the Underscore.js template engine</source>
          <target state="translated">참고 7 : Underscore.js 템플릿 엔진 사용</target>
        </trans-unit>
        <trans-unit id="cf25c2749f90cc1bc6823eee106a1d44e331c5bf" translate="yes" xml:space="preserve">
          <source>Note that any display style you&amp;rsquo;ve configured using your CSS rules will then apply (so CSS rules like x { display:table-row } work fine in conjunction with this binding).</source>
          <target state="translated">CSS 규칙을 사용하여 구성한 모든 표시 스타일이 적용됩니다 (따라서 x {display : table-row}와 같은 CSS 규칙은이 바인딩과 함께 작동합니다).</target>
        </trans-unit>
        <trans-unit id="ab6b8705ccd46f28afca1a82cfbc0f5e3ac0c980" translate="yes" xml:space="preserve">
          <source>Note that for this to automatically erase rejected values from the UI, it&amp;rsquo;s necessary to use .extend({ notify: 'always' }) on the computed observable. Without this, it&amp;rsquo;s possible for the user to enter an invalid newValue that when rounded gives an unchanged valueToWrite. Then, since the model value would not be changing, there would be no notification to update the textbox in the UI. Using { notify: 'always' } causes the textbox to refresh (erasing rejected values) even if the computed property has not changed value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6f64d633bf252e83e6a30775ca9bae85c7feffc" translate="yes" xml:space="preserve">
          <source>Note that for this to automatically erase rejected values from the UI, it&amp;rsquo;s necessary to use .extend({ notify: 'always' }) on the computed observable. Without this, it&amp;rsquo;s possible for the user to enter an invalid newValue that when rounded gives an unchanged valueToWrite. Then, since the model value would not be changing, there would be no notification to update the textbox in the UI. Using {notify:'always'} causes the textbox to refresh (erasing rejected values) even if the computed property has not changed value.</source>
          <target state="translated">UI에서 거부 된 값을 자동으로 지우려면 계산 된 관찰 가능 객체에 .extend ({notify : 'always'})를 사용해야합니다. 이것이 없으면, 사용자가 반올림 할 때 변경되지 않은 valueToWrite를 제공하는 유효하지 않은 newValue를 입력 할 수 있습니다. 그러면 모델 값이 변경되지 않으므로 UI에서 텍스트 상자를 업데이트하라는 알림이 없습니다. 계산 된 속성 값이 변경되지 않은 경우에도 {notify : 'always'}를 사용하면 텍스트 상자가 새로 고쳐집니다 (거부 된 값 지우기).</target>
        </trans-unit>
        <trans-unit id="3928cd9c277ba72dbf69e81590702f90731185e0" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s necessary to specify viewModel: { instance: object }, and not just viewModel: object. This differentiates from the other cases below.</source>
          <target state="translated">viewModel : 객체뿐만 아니라 viewModel : {instance : object}를 지정해야합니다. 이것은 아래의 다른 경우와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="fc236e1ebc6928f0c511903c41b30d3206eee445" translate="yes" xml:space="preserve">
          <source>Note that ko.toJSON accepts the same arguments as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt;. For example, it can be useful to have a &amp;ldquo;live&amp;rdquo; representation of your view model data when debugging a Knockout application. To generate a nicely formatted display for this purpose, you can pass the &lt;em&gt;spaces&lt;/em&gt; argument into ko.toJSON and bind against your view model like:</source>
          <target state="translated">ko.toJSON은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify&quot;&gt;JSON.stringify&lt;/a&gt; 와 동일한 인수를 허용합니다 . 예를 들어, Knockout 애플리케이션을 디버깅 할 때 뷰 모델 데이터를 &quot;실시간&quot;으로 표시하는 것이 유용 할 수 있습니다. 이러한 목적으로 멋진 형식의 디스플레이를 생성하려면 &lt;em&gt;공백&lt;/em&gt; 인수를 ko.toJSON에 전달하고 다음과 같이 뷰 모델에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ed17d0a4365c067e0d0cca185b3a02627fee026" translate="yes" xml:space="preserve">
          <source>Note that only the nodes &lt;em&gt;inside&lt;/em&gt; the specified element will be cloned into each instance of the component. The container element (in this example, the &amp;lt;template&amp;gt; element), will &lt;em&gt;not&lt;/em&gt; be treated as part of the component template.</source>
          <target state="translated">지정된 요소 &lt;em&gt;내부&lt;/em&gt; 의 노드 만 구성 요소의 각 인스턴스에 복제됩니다. 컨테이너 요소 (이 예에서는 &amp;lt;template&amp;gt; 요소) 는 구성 요소 템플릿의 일부로 취급 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5fd98c45b76cfffda7fb29aabbcc4105f3cac578" translate="yes" xml:space="preserve">
          <source>Note that reordering detection is not guaranteed: to ensure the algorithm completes quickly, it is optimized to detect &amp;ldquo;simple&amp;rdquo; movements of small numbers of array entries. If the algorithm detects too many simultaneous reorderings combined with unrelated insertions and deletions, then for speed it can choose to regard a reordering as an &amp;ldquo;delete&amp;rdquo; plus an &amp;ldquo;add&amp;rdquo; instead of a single &amp;ldquo;move&amp;rdquo;, and in that case the corresponding DOM elements will be torn down and recreated. Most developers won&amp;rsquo;t encounter this edge case, and even if you do, the end-user experience will usually be identical.</source>
          <target state="translated">재정렬 감지는 보장되지 않습니다. 알고리즘이 빠르게 완료되도록하기 위해 적은 수의 배열 항목의 &quot;간단한&quot;움직임을 감지하도록 최적화되어 있습니다. 알고리즘이 관련없는 삽입 및 삭제와 결합 된 동시 재주문을 너무 많이 감지하면 속도를 위해 재주문을 단일 &quot;이동&quot;대신 &quot;삭제&quot;와 &quot;추가&quot;로 간주하고 해당하는 경우 DOM을 선택할 수 있습니다. 요소가 찢어지고 재생성됩니다. 대부분의 개발자는 이러한 최첨단 사례를 경험하지 않으며, 그렇게해도 최종 사용자 경험은 일반적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8d4451b80b2ea7a6435a9b74cfdb3ee7699047bf" translate="yes" xml:space="preserve">
          <source>Note that the custom binding handler module does not inject anything into our ViewModel module, that is because it does not return anything. It just appends additional behavior to the knockout module.</source>
          <target state="translated">사용자 정의 바인딩 핸들러 모듈은 ViewModel 모듈에 아무것도 삽입하지 않습니다. 즉, 아무것도 반환하지 않기 때문입니다. 녹아웃 모듈에 추가 동작을 추가하기 만합니다.</target>
        </trans-unit>
        <trans-unit id="f85932fb55d2aff93e968e51c4da2dd6a4165c51" translate="yes" xml:space="preserve">
          <source>Note that the only difference between examples 3 and 4 is the optionsText value.</source>
          <target state="translated">예제 3과 4의 유일한 차이점은 optionsText 값입니다.</target>
        </trans-unit>
        <trans-unit id="7c7ebe43d20e5eae9b1b095f73abef9b56607824" translate="yes" xml:space="preserve">
          <source>Note that this is not the UI itself: it doesn&amp;rsquo;t have any concept of buttons or display styles. It&amp;rsquo;s not the persisted data model either - it holds the unsaved data the user is working with. When using KO, your view models are pure JavaScript objects that hold no knowledge of HTML. Keeping the view model abstract in this way lets it stay simple, so you can manage more sophisticated behaviors without getting lost.</source>
          <target state="translated">이것은 UI 자체가 아니라 버튼이나 디스플레이 스타일에 대한 개념이 없습니다. 지속 데이터 모델도 아닙니다. 사용자가 작업중인 저장되지 않은 데이터를 보유합니다. KO를 사용할 때 뷰 모델은 HTML에 대한 지식이없는 순수한 JavaScript 객체입니다. 이러한 방식으로 뷰 모델을 추상적으로 유지하면 간단하게 유지되므로보다 정교한 동작을 잃지 않고 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="e87df4d38ae4cd5ed452a5004cb65d4e1e2d6c9d" translate="yes" xml:space="preserve">
          <source>Note that when KO renders a foreach binding, it automatically hides any objects marked with _destroy equal to true. So, you can have some kind of &amp;ldquo;delete&amp;rdquo; button that invokes the destroy(someItem) method on the array, and this will immediately cause the specified item to vanish from the visible UI. Later, when you submit the JSON object graph to Rails, that item will also be deleted from the database (while the other array items will be inserted or updated as usual).</source>
          <target state="translated">KO가 foreach 바인딩을 렌더링하면 _destroy로 표시된 모든 객체가 true로 자동 숨겨집니다. 따라서 배열에서 destroy (someItem) 메소드를 호출하는 일종의 &quot;삭제&quot;버튼이있을 수 있으며 이로 인해 지정된 항목이 표시되는 UI에서 즉시 사라집니다. 나중에 JSON 객체 그래프를 Rails에 제출하면 해당 항목도 데이터베이스에서 삭제됩니다 (다른 배열 항목은 평소처럼 삽입 또는 업데이트 됨).</target>
        </trans-unit>
        <trans-unit id="e450c418845800c7f4318df4ef7374c24e1e9cb3" translate="yes" xml:space="preserve">
          <source>Note that whenever a component is removed (either because the name observable changed, or because an enclosing control-flow binding removed the entire element), the removed component is &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;disposed&lt;/a&gt;</source>
          <target state="translated">컴포넌트는 (관측 가능한 이름을 변경하거나, 클로징 제어 흐름은 전체 요소를 제거하기 때문에 어느 바인딩 때문에)가 제거 될 때마다, 제거 된 요소가 있음을 유의 &lt;a href=&quot;#disposal-and-memory-management&quot;&gt;배치&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="65025960631541c741b459bf73aacbde8d728d8d" translate="yes" xml:space="preserve">
          <source>Note that, typically, it&amp;rsquo;s best to perform direct DOM manipulation only through &lt;a href=&quot;custom-bindings&quot;&gt;custom bindings&lt;/a&gt; rather than acting on componentInfo.element from inside createViewModel. This leads to more modular, reusable code.</source>
          <target state="translated">일반적으로 createViewModel 내부에서 componentInfo.element에 대한 조치보다는 &lt;a href=&quot;custom-bindings&quot;&gt;사용자 정의 바인딩을&lt;/a&gt; 통해서만 직접 DOM 조작을 수행하는 것이 가장 좋습니다 . 이를 통해 더 모듈 식의 재사용 가능한 코드가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2ab69f1d78a98533c1ec94379b4b6361aa3fd348" translate="yes" xml:space="preserve">
          <source>Note: &amp;ldquo;ifnot&amp;rdquo; is the same as a negated &amp;ldquo;if&amp;rdquo;</source>
          <target state="translated">참고 : &quot;ifnot&quot;은 부정 &quot;if&quot;와 같습니다.</target>
        </trans-unit>
        <trans-unit id="4d936c2871be1bf2c84824c58d0b50a0046f059e" translate="yes" xml:space="preserve">
          <source>Note: About HTML encoding</source>
          <target state="translated">참고 : HTML 인코딩 정보</target>
        </trans-unit>
        <trans-unit id="b3bd5be04d2a77b8fbb42b423e270ca8d27974f7" translate="yes" xml:space="preserve">
          <source>Note: Applying CSS classes whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="translated">참고 : 이름이 잘못된 JavaScript 변수 이름 인 CSS 클래스 적용</target>
        </trans-unit>
        <trans-unit id="36e59391e4012e916e2efca315ab8a0ac9019825" translate="yes" xml:space="preserve">
          <source>Note: Applying attributes whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="translated">참고 : 이름이 유효한 JavaScript 변수 이름이 아닌 속성 적용</target>
        </trans-unit>
        <trans-unit id="40dbc8e3fecd759b1343c0ec1a8b8e04691b65e3" translate="yes" xml:space="preserve">
          <source>Note: Applying styles whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="translated">참고 : 이름이 유효한 JavaScript 변수 이름이 아닌 스타일 적용</target>
        </trans-unit>
        <trans-unit id="e4f74718bbd2f9c628b5720909d7d35fb25664a8" translate="yes" xml:space="preserve">
          <source>Note: Combining custom elements with regular bindings</source>
          <target state="translated">참고 : 사용자 정의 요소를 일반 바인딩과 결합</target>
        </trans-unit>
        <trans-unit id="9e0ba81f0e79b9ea41b49ea9879be53189f0c81a" translate="yes" xml:space="preserve">
          <source>Note: Custom component loaders and custom elements</source>
          <target state="translated">참고 : 사용자 정의 컴포넌트 로더 및 사용자 정의 요소</target>
        </trans-unit>
        <trans-unit id="097a1159163b98735917888cc1f3edd2f432ff4d" translate="yes" xml:space="preserve">
          <source>Note: Custom elements and Internet Explorer 6 to 8</source>
          <target state="translated">참고 : 사용자 지정 요소 및 Internet Explorer 6 ~ 8</target>
        </trans-unit>
        <trans-unit id="3452f7b8dfc0078e81c174fd19ab87bdb730cee7" translate="yes" xml:space="preserve">
          <source>Note: Custom elements cannot be self-closing</source>
          <target state="translated">참고 : 맞춤 요소는 자체 마감일 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="15b14d285bce9dc6c5d35d744705210b61bb5f03" translate="yes" xml:space="preserve">
          <source>Note: For a multi-select list, to set which of the options are selected, or to read which of the options are selected, use &lt;a href=&quot;selectedoptions-binding&quot;&gt;the selectedOptions binding&lt;/a&gt;. For a single-select list, you can also read and write the selected option using &lt;a href=&quot;value-binding&quot;&gt;the value binding&lt;/a&gt;.</source>
          <target state="translated">참고 : 다중 선택 목록의 경우 선택한 옵션을 설정하거나 선택한 옵션을 읽으 &lt;a href=&quot;selectedoptions-binding&quot;&gt;려면 selectedOptions 바인딩을&lt;/a&gt; 사용 하십시오 . 단일 선택 목록의 &lt;a href=&quot;value-binding&quot;&gt;경우 값 바인딩을&lt;/a&gt; 사용하여 선택한 옵션을 읽고 쓸 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ea83c2531ea63cd46a3690a3c5a207b81e6a5f4" translate="yes" xml:space="preserve">
          <source>Note: For text boxes, drop-down lists, and all non-checkable form controls, use &lt;a href=&quot;value-binding&quot;&gt;the value binding&lt;/a&gt; to read and write the element&amp;rsquo;s value, not the checked binding.</source>
          <target state="translated">참고 : 텍스트 상자, 드롭 다운 목록 및 확인할 수없는 모든 양식 컨트롤의 &lt;a href=&quot;value-binding&quot;&gt;경우 값 바인딩&lt;/a&gt; 을 사용 하여 확인 된 바인딩이 아닌 요소의 값을 읽고 씁니다.</target>
        </trans-unit>
        <trans-unit id="5d17b383b870bd49e9fdcd437b821085b1249406" translate="yes" xml:space="preserve">
          <source>Note: If the user navigates to an entirely different web page, browsers do this without asking any code running in the page to clean up. So in this case no dispose functions will be invoked. This is OK because the browser will automatically release the memory used by all objects that were in use.</source>
          <target state="translated">참고 : 사용자가 완전히 다른 웹 페이지를 탐색하는 경우 브라우저는 페이지에서 실행중인 코드를 정리하지 않고이 작업을 수행합니다. 따라서이 경우 처리 기능이 호출되지 않습니다. 브라우저가 사용중인 모든 개체에서 사용하는 메모리를 자동으로 해제하기 때문에 이는 정상입니다.</target>
        </trans-unit>
        <trans-unit id="07830fa525672973fcad872d9479a00d3f0aae0b" translate="yes" xml:space="preserve">
          <source>Note: If you just want to prevent a computed observable from updating too often, see the &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit extender&lt;/a&gt;.</source>
          <target state="translated">참고 : 계산 된 관찰 가능 항목이 너무 자주 업데이트되지 않도록하려면 &lt;a href=&quot;ratelimit-observable&quot;&gt;rateLimit 익스텐더를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a9907430c3d424ba976757e1f30ff936d301ef5" translate="yes" xml:space="preserve">
          <source>Note: If you&amp;rsquo;re working with checkboxes or radio buttons, use &lt;a href=&quot;checked-binding&quot;&gt;the checked binding&lt;/a&gt; to read and write your element&amp;rsquo;s checked state, not the value binding.</source>
          <target state="translated">참고 : 확인란 또는 단일 선택 단추로 작업중인 경우 , 값 바인딩이 아닌 &lt;a href=&quot;checked-binding&quot;&gt;선택된 바인딩&lt;/a&gt; 을 사용 하여 요소의 확인 된 상태를 읽고 쓰십시오.</target>
        </trans-unit>
        <trans-unit id="4013149ccb3f87d8ccbd0084efe996d0838d6311" translate="yes" xml:space="preserve">
          <source>Note: In more realistic cases, you would typically load component viewmodels and templates from external files, instead of hardcoding them into the registration. See &lt;a href=&quot;component-overview#example-loading-the-likedislike-widget-from-external-files-on-demand&quot;&gt;an example&lt;/a&gt; and &lt;a href=&quot;component-registration&quot;&gt;registration documentation&lt;/a&gt;.</source>
          <target state="translated">참고 :보다 현실적인 경우에는 일반적으로 구성 요소 뷰 모델 및 템플릿을 등록에 하드 코딩하는 대신 외부 파일에서로드합니다. &lt;a href=&quot;component-overview#example-loading-the-likedislike-widget-from-external-files-on-demand&quot;&gt;예제&lt;/a&gt; 및 &lt;a href=&quot;component-registration&quot;&gt;등록 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="32f182a0b9cb163063cf0210deaf0ef0bfd93fe2" translate="yes" xml:space="preserve">
          <source>Note: Integrating with browserify</source>
          <target state="translated">참고 : browserify와 통합</target>
        </trans-unit>
        <trans-unit id="f5847643b33a4979437c074b1772f4baa9785665" translate="yes" xml:space="preserve">
          <source>Note: Knockout does not guarantee that the beforeChange and change events will occur in pairs, since other parts of your code might raise either event individually. If you need to track the previous value of an observable, it&amp;rsquo;s up to you to use a subscription to capture and track it.</source>
          <target state="translated">참고 : 녹아웃은 코드의 다른 부분이 개별적으로 이벤트를 발생시킬 수 있으므로 beforeChange 및 change 이벤트가 쌍으로 발생한다고 보장하지 않습니다. Observable의 이전 값을 추적해야하는 경우 구독을 사용하여이를 관찰하고 추적하는 것은 사용자의 몫입니다.</target>
        </trans-unit>
        <trans-unit id="129196d92bb0c541677b616e7f9a98c3cc7e94cf" translate="yes" xml:space="preserve">
          <source>Note: Letting the user select from arbitrary JavaScript objects</source>
          <target state="translated">참고 : 사용자가 임의의 JavaScript 객체에서 선택하도록 허용</target>
        </trans-unit>
        <trans-unit id="140ebf77e1d231f3e690deb8c6320dc6a123f7b1" translate="yes" xml:space="preserve">
          <source>Note: Passing markup to components</source>
          <target state="translated">참고 : 구성 요소에 마크 업 전달</target>
        </trans-unit>
        <trans-unit id="23a3c1f00b1235c3c83812b480d0211ea6db2687" translate="yes" xml:space="preserve">
          <source>Note: Setting attributes whose names aren&amp;rsquo;t legal JavaScript variable names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f30af1206ec552873ed1d054e17b9fad1512a18" translate="yes" xml:space="preserve">
          <source>Note: Setting attributes with a namespace</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60bd54c6d3ace6bef5b8658344fb90ff9e01f394" translate="yes" xml:space="preserve">
          <source>Note: Since the r.js optimizer is very flexible, it has a lot of options and can take some time to set up. You may want to start from a ready-made example of Knockout components being optimized through r.js, in which case see &lt;a href=&quot;http://yeoman.io/&quot;&gt;Yeoman&lt;/a&gt; and the &lt;a href=&quot;https://www.npmjs.org/package/generator-ko&quot;&gt;generator-ko&lt;/a&gt; generator. Blog post coming soon.</source>
          <target state="translated">참고 : r.js 최적화 프로그램은 매우 유연하므로 많은 옵션이 있으며 설정하는 데 시간이 걸릴 수 있습니다. r.js를 통해 최적화되는 Knockout 구성 요소의 기성품 예제부터 시작할 수 있습니다.이 경우 &lt;a href=&quot;http://yeoman.io/&quot;&gt;Yeoman&lt;/a&gt; 및 &lt;a href=&quot;https://www.npmjs.org/package/generator-ko&quot;&gt;generator-ko&lt;/a&gt; 생성기를 참조하십시오 . 블로그 게시물이 곧 올 것입니다.</target>
        </trans-unit>
        <trans-unit id="54b8295547dbd8dd296d604963578e9c5ba48c73" translate="yes" xml:space="preserve">
          <source>Note: Supporting virtual elements</source>
          <target state="translated">참고 : 가상 요소 지원</target>
        </trans-unit>
        <trans-unit id="dd0ab8e16c1919532cc43e7aa1a6b879552640b4" translate="yes" xml:space="preserve">
          <source>Note: Template-only components</source>
          <target state="translated">참고 : 템플릿 전용 구성 요소</target>
        </trans-unit>
        <trans-unit id="b05caaa87623573294cec899219e7deabd2359f2" translate="yes" xml:space="preserve">
          <source>Note: To control which element in a single-select drop-down list is selected, you can use &lt;a href=&quot;value-binding&quot;&gt;the value binding&lt;/a&gt; instead.</source>
          <target state="translated">참고 : 단일 선택 드롭 다운 목록에서 어떤 요소가 선택되는지 제어하려면 &lt;a href=&quot;value-binding&quot;&gt;값 바인딩을&lt;/a&gt; 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c337589312cb228d7babfb1d2ebfd714455f588c" translate="yes" xml:space="preserve">
          <source>Note: Using &amp;ldquo;if&amp;rdquo; and &amp;ldquo;ifnot&amp;rdquo; without a container element</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ccfb58e2925ffb0818561abbfa7a1e8de927a56" translate="yes" xml:space="preserve">
          <source>Note: Using &amp;ldquo;if&amp;rdquo; without a container element</source>
          <target state="translated">참고 : 컨테이너 요소없이 &quot;if&quot;사용</target>
        </trans-unit>
        <trans-unit id="71884929340b18d767f7c056cf2d3ecb21755e40" translate="yes" xml:space="preserve">
          <source>Note: Using arbitrary JavaScript expressions</source>
          <target state="translated">참고 : 임의의 JavaScript 표현식 사용</target>
        </trans-unit>
        <trans-unit id="4403ac4eff9ff864673188e035a34bcf003869af" translate="yes" xml:space="preserve">
          <source>Note: Using component without a container element</source>
          <target state="translated">참고 : 컨테이너 요소없이 컴포넌트 사용</target>
        </trans-unit>
        <trans-unit id="1d0bc144231da12d70fed9c1daabfaf618fbc1bf" translate="yes" xml:space="preserve">
          <source>Note: Using functions and expressions to control element visibility</source>
          <target state="translated">참고 : 함수 및 표현식을 사용하여 요소 가시성 제어</target>
        </trans-unit>
        <trans-unit id="e11057c5759e08cd6106a99f6b95d00bd0ed796b" translate="yes" xml:space="preserve">
          <source>Note: Using reserved words as attribute names in older browsers</source>
          <target state="translated">참고 : 이전 브라우저에서 예약어를 속성 이름으로 사용</target>
        </trans-unit>
        <trans-unit id="b01856c6cdf3d733f8df97b227257f8bdea3947d" translate="yes" xml:space="preserve">
          <source>Note: Using the &amp;ldquo;class&amp;rdquo; and &amp;ldquo;css&amp;rdquo; bindings at the same time</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f815e27b345ec1efada4bea3643d51e789c47670" translate="yes" xml:space="preserve">
          <source>Note: Why circular dependencies aren&amp;rsquo;t meaningful</source>
          <target state="translated">참고 : 순환 종속성이 의미가없는 이유</target>
        </trans-unit>
        <trans-unit id="c8a2ea7aa039e3cc85d86b844a0aed9f68c466c1" translate="yes" xml:space="preserve">
          <source>Note: ko.computedContext.getDependenciesCount() is equivalent to calling getDependenciesCount() on the computed observable itself. The reason that it also exists on ko.computedContext is to provide a way of counting the dependencies during the first ever evaluation, before the computed observable has even finished being constructed.</source>
          <target state="translated">참고 : ko.computedContext.getDependenciesCount ()는 계산 된 관찰 가능 자체에서 getDependenciesCount ()를 호출하는 것과 같습니다. ko.computedContext에도 존재하는 이유는 계산 된 관찰 가능 구성이 완료되기 전에 최초의 평가 중에 종속성을 계산하는 방법을 제공하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="102fb6d0d403a0d599dae72a7da85eadcf53fd8f" translate="yes" xml:space="preserve">
          <source>Note: you don&amp;rsquo;t actually have to provide both init &lt;em&gt;and&lt;/em&gt; update callbacks &amp;mdash; you can just provide one or the other if that&amp;rsquo;s all you need.</source>
          <target state="translated">참고 : 실제로 초기화 콜백 &lt;em&gt;과&lt;/em&gt; 업데이트 콜백을 모두 제공 할 필요는 없습니다. 필요한 경우 둘 중 하나만 제공하면됩니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="e652fe47c807dd0369ac321e0b23b49fe4d6ad4e" translate="yes" xml:space="preserve">
          <source>Notice how, instead of using APIs like domElement.firstChild, we&amp;rsquo;re now using ko.virtualElements.firstChild(domOrVirtualElement). The randomOrder binding will now correctly work with virtual elements, e.g., &amp;lt;!-- ko randomOrder: true --&amp;gt;...&amp;lt;!-- /ko --&amp;gt;.</source>
          <target state="translated">domElement.firstChild와 같은 API를 사용하는 대신 ko.virtualElements.firstChild (domOrVirtualElement)를 사용하는 방법에 주목하십시오. randomOrder 바인딩은 이제 가상 요소에서 올바르게 작동합니다 (예 : &amp;lt;!-ko randomOrder : true-&amp;gt; ... &amp;lt;!-/ ko-&amp;gt;).</target>
        </trans-unit>
        <trans-unit id="881524b74eec619b61fa6cd558f217630d0d2032" translate="yes" xml:space="preserve">
          <source>Notice that no viewmodel/template pair is specified. The AMD module itself can provide a viewmodel/template pair, using any of the definition formats listed above. For example, the file some/module.js could be declared as:</source>
          <target state="translated">뷰 모델 / 서식 파일 쌍이 지정되지 않았습니다. AMD 모듈 자체는 위에 나열된 정의 형식 중 하나를 사용하여 뷰 모델 / 템플릿 쌍을 제공 할 수 있습니다. 예를 들어, some / module.js 파일은 다음과 같이 선언 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ffaab6a02fcd20ec4acba9eb285ffb74bb339fc" translate="yes" xml:space="preserve">
          <source>Notice that this is &lt;em&gt;not&lt;/em&gt; intended to be a complete replacement to the full set of regular DOM APIs. Knockout provides only a minimal set of virtual element APIs to make it possible to perform the kinds of transformations needed when implementing control flow bindings.</source>
          <target state="translated">이것은 일반 DOM API 전체를 완전히 대체하기위한 것이 &lt;em&gt;아닙니다&lt;/em&gt; . 녹아웃은 제어 흐름 바인딩을 구현할 때 필요한 종류의 변환을 수행 할 수 있도록 최소한의 가상 요소 API 세트 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d64ee77ed37778a54c73db4a866a3e17bd92900f" translate="yes" xml:space="preserve">
          <source>Notice the string value 'employee' associated with as. Now anywhere inside this foreach loop, bindings in your child templates will be able to refer to employee to access the employee object being rendered.</source>
          <target state="translated">as와 연관된 문자열 값 'employee'를 확인하십시오. 이제이 foreach 루프 내 어디에서나 자식 템플릿의 바인딩을 통해 직원을 참조하여 렌더링중인 직원 개체에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3a7345017a99ea270b44a59fd49d8ee6f486954" translate="yes" xml:space="preserve">
          <source>Now any descendant binding will be able to refer to person to access this context object. This can be especially useful in scenarios where you have nested contexts and you need to refer to something declared at a higher level in the hierarchy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="839a7efc6c32176be9d0069eb8544d9601b7d394" translate="yes" xml:space="preserve">
          <source>Now anywhere inside this foreach loop, bindings will be able to refer to person to access the current array item that is being rendered from the people array. This can be especially useful in scenarios where you have nested foreach blocks and you need to refer to an item declared at a higher level in the hierarchy. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ac7108123b5f245ef9f5df9d943f636924637d" translate="yes" xml:space="preserve">
          <source>Now anywhere inside this foreach loop, bindings will be able to refer to person to access the current array item, from the people array, that is being rendered. This can be especially useful in scenarios where you have nested foreach blocks and you need to refer to an item declared at a higher level in the hierarchy. For example:</source>
          <target state="translated">이제이 foreach 루프 내 어디에서나 바인딩은 사람 배열을 참조하여 렌더링되고있는 사람 배열에서 현재 배열 항목에 액세스 할 수 있습니다. 이는 foreach 블록이 중첩되어 있고 계층에서 상위 수준으로 선언 된 항목을 참조해야하는 시나리오에서 특히 유용 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5673fdafd7626621793c97c3c05163e839f06fa8" translate="yes" xml:space="preserve">
          <source>Now like-or-dislike can be consumed in the same way as before, using either a &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; or a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;:</source>
          <target state="translated">이제 &lt;a href=&quot;component-binding&quot;&gt;컴포넌트 바인딩&lt;/a&gt; 또는 &lt;a href=&quot;component-custom-elements&quot;&gt;커스텀 요소를&lt;/a&gt; 사용하여 이전과 같은 방식으로 like-or-dislike를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6480651531660c84a55576d27e9ed7d8351ebcd4" translate="yes" xml:space="preserve">
          <source>Now the component is operating, and can remain on-screen for as long as needed.</source>
          <target state="translated">이제 구성 요소가 작동 중이며 필요한만큼 화면에 남아있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ee0ffaf853c8407a424f11a481c7a0f71be59bc" translate="yes" xml:space="preserve">
          <source>Now there won&amp;rsquo;t be an error. However, it still won&amp;rsquo;t work properly, because our randomOrder binding is coded using normal DOM API calls (firstChild, appendChild, etc.) which don&amp;rsquo;t understand virtual elements. This is the reason why KO requires you to explicitly opt in to virtual element support: unless your custom binding is coded using virtual element APIs, it&amp;rsquo;s not going to work properly!</source>
          <target state="translated">이제 오류가 없습니다. 그러나 randomOrder 바인딩은 가상 요소를 이해하지 못하는 일반적인 DOM API 호출 (firstChild, appendChild 등)을 사용하여 코딩되기 때문에 여전히 제대로 작동하지 않습니다. 이것이 KO가 가상 요소 지원을 명시 적으로 선택하도록 요구하는 이유입니다. 사용자 지정 바인딩이 가상 요소 API를 사용하여 코딩되지 않으면 제대로 작동하지 않습니다!</target>
        </trans-unit>
        <trans-unit id="f68b7fa0902e29163231a8e1b14bcdcd84f1f8c2" translate="yes" xml:space="preserve">
          <source>Now this is registered, you can reference components with any name (without preregistering them), e.g.:</source>
          <target state="translated">이제 등록되었습니다. 예를 들어 다음과 같은 이름을 가진 구성 요소를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9abe577afb6560e727b712ab6c0be7874d881af" translate="yes" xml:space="preserve">
          <source>Now we can push a bunch of items into the data array without worrying about causing excessive UI or computed updates. The deferred extender can be applied to any type of observable, including observable arrays and computed observables.</source>
          <target state="translated">이제 과도한 UI 또는 계산 된 업데이트를 걱정할 필요없이 여러 항목을 데이터 배열로 푸시 할 수 있습니다. 지연 익스텐더는 관찰 가능 배열 및 계산 된 관찰 가능 항목을 포함하여 모든 유형의 관찰 가능 항목에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fda568a2d060f080b79888ad65ca98b3f5cb075b" translate="yes" xml:space="preserve">
          <source>Now you can bind click like this:</source>
          <target state="translated">이제 다음과 같이 클릭을 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3482f1f45804606e4ae189fe1f25ad32491bef16" translate="yes" xml:space="preserve">
          <source>Now you can bind it like this:</source>
          <target state="translated">이제 다음과 같이 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40d230de5c1460b029face137aa50f89cfff29a6" translate="yes" xml:space="preserve">
          <source>Now you can both read and write the &amp;ldquo;focusedness&amp;rdquo; of an element by binding it to an observable:</source>
          <target state="translated">이제 요소를 observable에 바인딩하여 요소의 &quot;초점&quot;을 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6de72398a9643fb68b8c419f88d72e0cc3455cae" translate="yes" xml:space="preserve">
          <source>Now you can change pageIndex and pageSize as many times as you like, and the Ajax call will only happen once after you release your thread back to the JavaScript runtime.</source>
          <target state="translated">이제 pageIndex 및 pageSize를 원하는만큼 변경할 수 있으며 Ajax 호출은 스레드를 JavaScript 런타임으로 다시 해제 한 후에 한 번만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="18f2aeef65d906e4473cfba8e914455277450ce1" translate="yes" xml:space="preserve">
          <source>Now you can include a template in your view like this:</source>
          <target state="translated">이제 다음과 같이보기에 템플릿을 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdd6cfad8e975c0657b6d67e96fe52c3a48e9aa8" translate="yes" xml:space="preserve">
          <source>Now you can use this binding as follows:</source>
          <target state="translated">이제이 바인딩을 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c9b28edefdb5a8470622ecf317b145edc4837c3" translate="yes" xml:space="preserve">
          <source>Now you could bind UI elements to it, e.g.:</source>
          <target state="translated">이제 UI 요소를 바인딩 할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="02d8cd1aeb019148b74c77705355b7163631d297" translate="yes" xml:space="preserve">
          <source>Now your binding in UI elements becomes a method call, e.g.:</source>
          <target state="translated">이제 UI 요소의 바인딩이 메소드 호출이됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="f030ce6c537ab6ebb0bf1ffd14b3a4657684bade" translate="yes" xml:space="preserve">
          <source>Now, KO will pass the data and event objects to your function literal, which are then available to be passed to your handler.</source>
          <target state="translated">이제 KO는 데이터 및 이벤트 객체를 함수 리터럴로 전달한 다음 핸들러로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd13b366a6bf0e481a78cb8415ed4850572371a6" translate="yes" xml:space="preserve">
          <source>Now, KO will pass the event to your function literal, which is then available to be passed to your handler.</source>
          <target state="translated">이제 KO는 이벤트를 함수 리터럴로 전달한 다음 처리기로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75b3699fea4994e40b27cf8acdc9dbd74ac8d3b7" translate="yes" xml:space="preserve">
          <source>Now, a single event handler is attached at a higher level and handles clicks against any links with the remove class. This method has the added benefit of automatically handling additional links that are dynamically added to the document (perhaps as the result of an item being added to an observableArray).</source>
          <target state="translated">이제 단일 이벤트 핸들러가 상위 레벨에 연결되고 remove 클래스가있는 링크에 대한 클릭을 처리합니다. 이 방법은 문서에 동적으로 추가 된 추가 링크를 자동으로 처리 할 수있는 이점이 있습니다 (아마도 observableArray에 항목이 추가 된 결과 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="bd680cea0a442ee897310989fbae69d04e84c88d" translate="yes" xml:space="preserve">
          <source>Now, acceptedNumericValue will only ever contain numeric values, and any other values entered will trigger the appearance of a validation message instead of updating acceptedNumericValue.</source>
          <target state="translated">이제 acceptNumericValue에는 숫자 값만 포함되며 입력 된 다른 값은 acceptNumericValue를 업데이트하는 대신 유효성 검사 메시지의 모양을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="e0f38308579b18f9d4a6971e8cbcbf8290d174a2" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s say the data is updated to be without any typos:</source>
          <target state="translated">이제 데이터가 오타없이 업데이트되었다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="540f67e29415bf23f1b5c0759292b5c41747e4c8" translate="yes" xml:space="preserve">
          <source>Now, moving your mouse pointer on or off of the first element will invoke methods on the view model to toggle the detailsEnabled observable. The second element reacts to changes to the value of detailsEnabled by either showing or hiding itself.</source>
          <target state="translated">이제 마우스 포인터를 첫 번째 요소에서 켜거나 끄면 뷰 모델에서 메서드를 호출하여 detailsEnabled 옵저버 블을 토글합니다. 두 번째 요소는 자신을 표시하거나 숨겨서 detailsEnabled 값의 변경에 반응합니다.</target>
        </trans-unit>
        <trans-unit id="3736efca9ddde7db65691710604802d1a6d9f093" translate="yes" xml:space="preserve">
          <source>Now, the text will switch between &amp;ldquo;expensive&amp;rdquo; and &amp;ldquo;affordable&amp;rdquo; as needed whenever price changes.</source>
          <target state="translated">이제 가격이 바뀔 때마다 필요에 따라 텍스트가 &quot;고가&quot;와 &quot;저렴한&quot;사이로 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="088a5e50ba0e6a14fe36eaa6f26ee4c53c1aeffe" translate="yes" xml:space="preserve">
          <source>Now, to use this component, you can reference it from any other view in your application, either using the &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; or using a &lt;a href=&quot;component-custom-elements&quot;&gt;custom element&lt;/a&gt;. Here&amp;rsquo;s a live example that uses it as a custom element:</source>
          <target state="translated">이제이 컴포넌트를 사용하려면 &lt;a href=&quot;component-binding&quot;&gt;컴포넌트 바인딩&lt;/a&gt; 또는 &lt;a href=&quot;component-custom-elements&quot;&gt;사용자 정의 요소를&lt;/a&gt; 사용 하여 애플리케이션의 다른보기에서 참조 할 수 있습니다 . 다음은 맞춤 요소로 사용하는 실제 예입니다.</target>
        </trans-unit>
        <trans-unit id="4245c3b686b0a2dc1aff4f4de7c87fcd1a33a5a7" translate="yes" xml:space="preserve">
          <source>Now, whenever the user enters a new price, the text box immediately updates to show it formatted with the currency symbol and two decimal places, no matter what format they entered the value in. This gives a great user experience, because the user sees how the software has understood their data entry as a price. They know they can&amp;rsquo;t enter more than two decimal places, because if they try to, the additional decimal places are immediately removed. Similarly, they can&amp;rsquo;t enter negative values, because the write callback strips off any minus sign.</source>
          <target state="translated">이제 사용자가 새로운 가격을 입력 할 때마다 텍스트 상자가 즉시 업데이트되어 값을 입력 한 형식에 관계없이 통화 기호와 소수점 두 자리로 서식이 표시됩니다. 소프트웨어는 데이터 입력을 가격으로 이해했습니다. 그들은 소수점 이하 두 자리를 입력 할 수 없다는 것을 알고 있습니다. 왜냐하면 소수점을 입력하면 추가 소수점 자리가 즉시 제거되기 때문입니다. 마찬가지로 쓰기 콜백은 빼기 부호를 제거하기 때문에 음수 값을 입력 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2f11f252395402a0b2ef2d05d00513a9da6f819b" translate="yes" xml:space="preserve">
          <source>Now, whenever the user enters a new price, the text box updates to show it formatted with the currency symbol and two decimal places, no matter what format they entered the value in. This gives a great user experience, because the user sees how the software has understood their data entry as a price. They know they can&amp;rsquo;t enter more than two decimal places, because if they try to, the additional decimal places are removed. Similarly, they can&amp;rsquo;t enter negative values, because the write callback strips off any minus sign.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ac3b49a89e1b1842cca9897c548ac837711b286" translate="yes" xml:space="preserve">
          <source>OK, how do you use it?</source>
          <target state="translated">좋아, 어떻게 사용하니?</target>
        </trans-unit>
        <trans-unit id="42801dc107e69330fc6f28652e42c67848f2e3d3" translate="yes" xml:space="preserve">
          <source>OK, you&amp;rsquo;ve seen how to create a basic view model and how to display one of its properties using a binding. But one of the key benefits of KO is that it updates your UI automatically when the view model changes. How can KO know when parts of your view model change? Answer: you need to declare your model properties as &lt;em&gt;observables&lt;/em&gt;, because these are special JavaScript objects that can notify subscribers about changes, and can automatically detect dependencies.</source>
          <target state="translated">기본 뷰 모델을 만드는 방법과 바인딩을 사용하여 해당 속성 중 하나를 표시하는 방법을 보았습니다. 그러나 KO의 주요 이점 중 하나는 뷰 모델이 변경 될 때 UI가 자동으로 업데이트된다는 것입니다. 뷰 모델의 일부가 언제 변경되는지 KO는 어떻게 알 수 있습니까? 답변 : 모델 속성을 &lt;em&gt;관찰 가능&lt;/em&gt; 으로 선언해야합니다.이 속성은 가입자에게 변경 사항을 알리고 종속성을 자동으로 감지 할 수있는 특수 JavaScript 객체이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="49ef41d692a31c86e07e70c90965e70e376a7d17" translate="yes" xml:space="preserve">
          <source>Observable Arrays</source>
          <target state="translated">관찰 가능한 배열</target>
        </trans-unit>
        <trans-unit id="46996089e8555e78352bfb82f74492b629adadd3" translate="yes" xml:space="preserve">
          <source>Observable arrays</source>
          <target state="translated">관찰 가능한 배열</target>
        </trans-unit>
        <trans-unit id="ae2926058ff9077b5ef1fa67cef194213c7bb29a" translate="yes" xml:space="preserve">
          <source>Observable arrays that are generated by the mapping plugin are augmented with a few functions that can make use of the keys mapping:</source>
          <target state="translated">매핑 플러그인에 의해 생성 된 관찰 가능한 배열은 키 매핑을 사용할 수있는 몇 가지 기능으로 보강됩니다.</target>
        </trans-unit>
        <trans-unit id="8136b5b444e74956953de6d7e21de45a7208ed8b" translate="yes" xml:space="preserve">
          <source>Observables</source>
          <target state="translated">Observables</target>
        </trans-unit>
        <trans-unit id="b11d034f48ad50b05bcdbc51fb2bc638d49916bb" translate="yes" xml:space="preserve">
          <source>Observables and dependency tracking</source>
          <target state="translated">관찰 가능 및 종속성 추적</target>
        </trans-unit>
        <trans-unit id="621445c3740dea16b530b18f93e077809839e366" translate="yes" xml:space="preserve">
          <source>Observing only certain properties using &amp;ldquo;observe&amp;rdquo;</source>
          <target state="translated">&quot;관찰&quot;을 사용하여 특정 속성 만 관찰</target>
        </trans-unit>
        <trans-unit id="5820d44b10477929b579ab80e1dfa0b99895aa33" translate="yes" xml:space="preserve">
          <source>Occasionally, you may find opportunities to streamline your code by attaching new functionality to Knockout&amp;rsquo;s core value types. You can define custom functions on any of the following types:</source>
          <target state="translated">때때로 Knockout의 핵심 가치 유형에 새로운 기능을 추가하여 코드를 간소화 할 수있는 기회를 찾을 수 있습니다. 다음 유형 중 하나에서 사용자 정의 기능을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31449567d7f21edc1facbf4447d941d2b4798e0a" translate="yes" xml:space="preserve">
          <source>Of course, inside the create callback you can do another call to ko.mapping.fromJS if you wish. A typical use-case might be if you want to augment the original JavaScript object with some additional &lt;a href=&quot;computedobservables&quot;&gt;computed observables&lt;/a&gt;:</source>
          <target state="translated">물론, create callback 안에서 원한다면 ko.mapping.fromJS를 다시 호출 할 수 있습니다. 일반적인 사용 사례는 &lt;a href=&quot;computedobservables&quot;&gt;계산 된&lt;/a&gt; 추가 옵저버 블을 사용하여 원본 JavaScript 객체를 보강하려는 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="0ab11f1d7ae1b763bfdbe3807e0dd9ad83af6511" translate="yes" xml:space="preserve">
          <source>Of course, this is a lot of code at first glance, but once you&amp;rsquo;ve created your custom bindings they can very easily be reused in many places.</source>
          <target state="translated">물론 이것은 언뜻보기에 많은 코드이지만, 일단 커스텀 바인딩을 만든 후에는 여러 곳에서 쉽게 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="078756006ae7a0012d20c159834f8a64afd1f3de" translate="yes" xml:space="preserve">
          <source>Of course, this is most useful when you have multiple radio button elements bound to a single model property. To ensure that only &lt;em&gt;one&lt;/em&gt; of those radio buttons can be checked at any one time, you should set all of their name attributes to an arbitrary common value (e.g., the value flavorGroup in the preceding example) &amp;ndash; doing this puts them into a group where only one can be selected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49f700094b19d2adf8500f72e2a84b3d54353191" translate="yes" xml:space="preserve">
          <source>Of course, this is most useful when you have multiple radio button elements bound to a single model property. To ensure that only &lt;em&gt;one&lt;/em&gt; of those radio buttons can be checked at any one time, you should set all of their name attributes to an arbitrary common value (e.g., the value flavorGroup in the preceding example) - doing this puts them into a group where only one can be selected.</source>
          <target state="translated">물론 이것은 단일 모델 속성에 여러 라디오 버튼 요소가 바인딩되어있을 때 가장 유용합니다. 해당 라디오 버튼 &lt;em&gt;중&lt;/em&gt; 하나만 &lt;em&gt;한 번&lt;/em&gt; 에 확인할 수 있도록하려면 모든 이름 속성을 임의의 공통 값 (예 : 앞의 예에서 flavorGroup 값)으로 설정해야합니다. 이렇게하면 그룹에 그룹이 배치됩니다. 하나만 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c68f1c87405be42eacbbbce0c48e9cb553450844" translate="yes" xml:space="preserve">
          <source>Of course, x.y.z should be replaced with the version number of the Knockout script you are loading (e.g., knockout-3.1.0).</source>
          <target state="translated">물론, xyz는로드중인 녹아웃 스크립트의 버전 번호 (예 : 녹아웃 -3.1.0)로 바꿔야합니다.</target>
        </trans-unit>
        <trans-unit id="a449e9eab7822a64523bbf6509430f2bd5f4edd2" translate="yes" xml:space="preserve">
          <source>Of course, x.y.z should be replaced with the version number of the Knockout script you are loading (e.g., knockout-3.5.1).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8aa33e822518a764cd6aa37dbe83b7633c72e02d" translate="yes" xml:space="preserve">
          <source>Of course, you can arbitrarily nest any number of foreach bindings along with other control-flow bindings such as if and with.</source>
          <target state="translated">물론 if 및 with와 같은 다른 제어 흐름 바인딩과 함께 여러 foreach 바인딩을 임의로 중첩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a81c8bc825594ecd549001af937392796036a625" translate="yes" xml:space="preserve">
          <source>Of course, you can arbitrarily nest with and using bindings along with the other control-flow bindings such as &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23f4b8ea9e954eebaa70e0a9c65d26766627d86b" translate="yes" xml:space="preserve">
          <source>Of course, you can arbitrarily nest with bindings along with the other control-flow bindings such as &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; and &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt;.</source>
          <target state="translated">물론 &lt;a href=&quot;if-binding&quot;&gt;if&lt;/a&gt; 및 &lt;a href=&quot;foreach-binding&quot;&gt;foreach&lt;/a&gt; 와 같은 다른 제어 흐름 바인딩과 함께 바인딩으로 임의로 중첩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f3aa665242655dd6d40a7753ba8a1bef582d3cc" translate="yes" xml:space="preserve">
          <source>Of course, you can create whole chains of computed observables if you wish. For example, you might have:</source>
          <target state="translated">물론 원하는 경우 계산 된 관측 가능 체인 전체를 만들 수 있습니다. 예를 들어 다음이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b3b30a86f9e0ac4c5bc2f098d8abb20f874f834" translate="yes" xml:space="preserve">
          <source>Of course, you don&amp;rsquo;t have to worry about releasing any event handlers created by standard Knockout bindings in your view, as KO automatically unregisters them when the elements are removed.</source>
          <target state="translated">물론 요소가 제거 될 때 KO가 자동으로 등록을 해제하므로 뷰에서 표준 녹아웃 바인딩으로 생성 된 이벤트 핸들러를 해제 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b7bdef4ca5fa385742d68cfa6579c30b6c61548d" translate="yes" xml:space="preserve">
          <source>On this page, you&amp;rsquo;ll learn about the first of these three. But before that, let&amp;rsquo;s examine the MVVM pattern and the concept of a &lt;em&gt;view model&lt;/em&gt;.</source>
          <target state="translated">이 페이지에서는이 세 가지 중 첫 번째에 대해 배웁니다. 그러나 그 전에 MVVM 패턴과 &lt;em&gt;뷰 모델&lt;/em&gt; 의 개념을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="e1bc6631468dfada790b80fb194db5f58e531526" translate="yes" xml:space="preserve">
          <source>Optionally, you can pass a second parameter to define which part of the document you want to search for data-bind attributes. For example, ko.applyBindings(myViewModel, document.getElementById('someElementId')). This restricts the activation to the element with ID someElementId and its descendants, which is useful if you want to have multiple view models and associate each with a different region of the page.</source>
          <target state="translated">선택적으로 두 번째 매개 변수를 전달하여 데이터 바인딩 특성을 검색하려는 문서 부분을 정의 할 수 있습니다. 예를 들어 ko.applyBindings (myViewModel, document.getElementById ( 'someElementId'))입니다. 이는 ID someElementId 및 해당 하위 항목이있는 요소로 활성화를 제한합니다. 이는 여러보기 모델을 갖고 각각을 페이지의 다른 영역과 연관시키려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1765a06342825b17a9e403b215e90bde7a3b1c92" translate="yes" xml:space="preserve">
          <source>Optionally, your viewmodel class may have a dispose function. If implemented, Knockout will call this whenever the component is being torn down and removed from the DOM (e.g., because the corresponding item was removed from a foreach, or an if binding has become false).</source>
          <target state="translated">선택적으로, viewmodel 클래스에는 dispose 함수가있을 수 있습니다. 구현 된 경우, Knockout은 컴포넌트가 종료되고 DOM에서 제거 될 때마다 (예 : 해당 항목이 foreach에서 제거되었거나 if 바인딩이 false가 되었기 때문에)이를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a4e4c99b9180d995ef38e38e86d46c2c354b0131" translate="yes" xml:space="preserve">
          <source>Or if you really don&amp;rsquo;t like the hackiness of the document.createElement call, then you could use a &lt;a href=&quot;component-binding&quot;&gt;component binding&lt;/a&gt; for your top-level component instead of a custom element. As long as all other components are registered before your ko.applyBindings call, they can be used as custom elements on IE6-8 without futher trouble:</source>
          <target state="translated">또는 document.createElement 호출의 해킹이 마음에 들지 않으면 사용자 지정 요소 대신 최상위 구성 요소에 대한 &lt;a href=&quot;component-binding&quot;&gt;구성 요소 바인딩&lt;/a&gt; 을 사용할 수 있습니다 . 다른 모든 구성 요소가 ko.applyBindings 호출 전에 등록되어 있으면 IE6-8에서 추가 문제없이 사용자 정의 요소로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c54970fdc4cfe5ce955d0d99cddf7a056c2d8f2" translate="yes" xml:space="preserve">
          <source>Or, at least call document.createElement('your-component') &lt;em&gt;before&lt;/em&gt; the HTML parser sees any &amp;lt;your-component&amp;gt; elements. You can ignore the result of the createElement call &amp;mdash; all that matters is that you have called it.</source>
          <target state="translated">또는 HTML 파서가 &amp;lt;your-component&amp;gt; 요소를보기 &lt;em&gt;전에&lt;/em&gt; 최소한 document.createElement ( 'your-component') &lt;em&gt;를&lt;/em&gt; 호출 하십시오. createElement 호출의 결과를 무시할 수 있습니다. 중요한 것은 호출 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="888fa89b9dae94f674ec75254af5184f71fd7fb9" translate="yes" xml:space="preserve">
          <source>Or, if the component has no viewmodel, then the view is bound to any params you&amp;rsquo;ve supplied to the component binding.</source>
          <target state="translated">또는 구성 요소에 뷰 모델이 없으면 뷰는 구성 요소 바인딩에 제공 한 모든 매개 변수에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="4ba0856e67eb87e7f52493db1a23ca2ca82c78f6" translate="yes" xml:space="preserve">
          <source>Or, if you don&amp;rsquo;t want to use jQuery, you can use any other mechanism for loading or saving JSON data. So, all Knockout needs to help you do is:</source>
          <target state="translated">또는 jQuery를 사용하지 않으려는 경우 JSON 데이터를로드하거나 저장하기 위해 다른 메커니즘을 사용할 수 있습니다. 따라서 모든 녹아웃은 다음과 같이 도와야합니다.</target>
        </trans-unit>
        <trans-unit id="f699ec4a263d96ea6e8330f504cbc76acb04a6da" translate="yes" xml:space="preserve">
          <source>Or, if you just want the plain JavaScript object graph &lt;em&gt;before&lt;/em&gt; serialization, use ko.toJS as follows:</source>
          <target state="translated">또는 직렬화 &lt;em&gt;전에&lt;/em&gt; 일반 JavaScript 객체 그래프 &lt;em&gt;를&lt;/em&gt; 원할 경우 다음과 같이 ko.toJS를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0f545ea154ca17421845c1c4d49c0c277020bb7c" translate="yes" xml:space="preserve">
          <source>Other browsers, and newer versions of IE, don&amp;rsquo;t have this quirk.</source>
          <target state="translated">다른 브라우저와 최신 버전의 IE에는 이러한 특징이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a7d69219a1d86b1de7eaa38435a5ef6a295349c2" translate="yes" xml:space="preserve">
          <source>Other technologies may depend on the assumption that certain elements have names, even though names might be irrelevant when you&amp;rsquo;re using KO. For example, &lt;a href=&quot;http://jqueryvalidation.org/&quot;&gt;jQuery Validation&lt;/a&gt; currently will only validate elements that have names. To use this with a Knockout UI, it&amp;rsquo;s sometimes necessary to apply the uniqueName binding to avoid confusing jQuery Validation. See &lt;a href=&quot;http://knockoutjs.com/examples/gridEditor.html&quot;&gt;an example of using jQuery Validation with KO&lt;/a&gt;.</source>
          <target state="translated">다른 기술은 KO를 사용할 때 이름이 관련이 없을 수 있지만 특정 요소에 이름이 있다는 가정에 따라 달라질 수 있습니다. 예를 들어, &lt;a href=&quot;http://jqueryvalidation.org/&quot;&gt;jQuery 유효성 검사는&lt;/a&gt; 현재 이름이있는 요소 만 유효성 검사합니다. Knockout UI와 함께 사용하려면 jQuery 유효성 검사를 혼동하지 않도록 uniqueName 바인딩을 적용해야하는 경우가 있습니다. &lt;a href=&quot;http://knockoutjs.com/examples/gridEditor.html&quot;&gt;KO와 함께 jQuery Validation을 사용하는 예를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a1efa09ae2cb2e40a26065664566609723294929" translate="yes" xml:space="preserve">
          <source>Other technologies may depend on the assumption that certain elements have names, even though names might be irrelevant when you&amp;rsquo;re using KO. For example, &lt;a href=&quot;http://jqueryvalidation.org/&quot;&gt;jQuery Validation&lt;/a&gt; currently will only validate elements that have names. To use this with a Knockout UI, it&amp;rsquo;s sometimes necessary to apply the uniqueName binding to avoid confusing jQuery Validation. See &lt;a href=&quot;https://knockoutjs.com/examples/gridEditor.html&quot;&gt;an example of using jQuery Validation with KO&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b76426a4b4527523a89c8447c24b37b42bba21f" translate="yes" xml:space="preserve">
          <source>Overriding the clean-up of external data</source>
          <target state="translated">외부 데이터 정리 재정의</target>
        </trans-unit>
        <trans-unit id="9c6c53d0c3ba99a8159d80012914470bb2bd02f8" translate="yes" xml:space="preserve">
          <source>Overview of AMD</source>
          <target state="translated">AMD 개요</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="ee9bc64679c883d8315ef21591e760cbc38b8e61" translate="yes" xml:space="preserve">
          <source>Pass a function reference (either a function literal, or give the name of a function on your view model), and Knockout will invoke it immediately after rendering or re-rendering your template. If you&amp;rsquo;re using foreach, Knockout will invoke your afterRender callback for each item added to your observable array. For example,</source>
          <target state="translated">함수 참조 (함수 리터럴 또는 뷰 모델에서 함수 이름 제공)를 전달하면 녹아웃은 템플릿을 렌더링하거나 다시 렌더링 한 후 즉시 호출합니다. foreach를 사용하는 경우 Knockout은 관찰 가능 배열에 추가 된 각 항목에 대해 afterRender 콜백을 호출합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="2a4fc664fb015dd2b90366bae7b7c6166a290c0f" translate="yes" xml:space="preserve">
          <source>Pass the array that you wish to iterate over. The binding will output a section of markup for each entry.</source>
          <target state="translated">반복하려는 배열을 전달하십시오. 바인딩은 각 항목에 대한 마크 업 섹션을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="ac917217788ea4daf427e3524d9e686c7fae6951" translate="yes" xml:space="preserve">
          <source>Pass true (or some value that evaluates as true) to enable the uniqueName binding, as in the preceding example.</source>
          <target state="translated">앞의 예제에서와 같이 uniqueName 바인딩을 사용하려면 true (또는 true로 평가되는 일부 값)를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="48fbf79eab4d275311cd306a9da00e04a2da8f50" translate="yes" xml:space="preserve">
          <source>Pass true (or some value that evaluates as true) to focus the associated element. Otherwise, the associated element will be unfocused.</source>
          <target state="translated">연관된 요소에 초점을 맞추려면 true (또는 true로 평가되는 일부 값)를 전달하십시오. 그렇지 않으면 관련 요소의 초점이 흐려집니다.</target>
        </trans-unit>
        <trans-unit id="b9cfb6f55eaea0baeb940c302cc0775a2e4e29f0" translate="yes" xml:space="preserve">
          <source>Passing markup into components</source>
          <target state="translated">구성 요소에 마크 업 전달</target>
        </trans-unit>
        <trans-unit id="7b31412042fa68bceb2962653f184dcb45a1c94c" translate="yes" xml:space="preserve">
          <source>Passing observable expressions</source>
          <target state="translated">관찰 가능한 표현 전달</target>
        </trans-unit>
        <trans-unit id="3157744f3e6488a569fb33f59900039dd87730b5" translate="yes" xml:space="preserve">
          <source>Passing parameters</source>
          <target state="translated">전달 매개 변수</target>
        </trans-unit>
        <trans-unit id="52fe29993c9eadbd173dbd6bdcce3efe7de4a21e" translate="yes" xml:space="preserve">
          <source>Performance is O(1) in most cases, i.e., there&amp;rsquo;s basically no performance implication at all, because for straightforward operations, (push, splice, etc.) Knockout supplies the change log without running any difference algorithm. Knockout only falls back on an algorithm if you&amp;rsquo;ve made an arbitrary change without using a typical array mutation function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c30396c874cdc27bd19277aa1a80c77188378ef" translate="yes" xml:space="preserve">
          <source>Please note that, as of December 2011, jQuery.tmpl is no longer under active development. We recommend the use of Knockout&amp;rsquo;s native DOM-based templating (i.e., the foreach, if, with, etc. bindings) instead of jQuery.tmpl or any other string-based template engine.</source>
          <target state="translated">2011 년 12 월 현재 jQuery.tmpl은 더 이상 개발 중이 아닙니다. jQuery.tmpl 또는 기타 문자열 기반 템플릿 엔진 대신 Knockout의 기본 DOM 기반 템플릿 (예 : foreach, if, with 등 바인딩)을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ab2e26dd8b8868a3969cb3321e0c983c0d9d67d4" translate="yes" xml:space="preserve">
          <source>Plugins</source>
          <target state="translated">Plugins</target>
        </trans-unit>
        <trans-unit id="24a0be8dab4fe687c8ad437ae1be347c7c275ab3" translate="yes" xml:space="preserve">
          <source>Prepopulating an observableArray</source>
          <target state="translated">observableArray 미리 채우기</target>
        </trans-unit>
        <trans-unit id="30d1738d650def938c652b581eb2ab8e9e23bac2" translate="yes" xml:space="preserve">
          <source>Preprocessing DOM nodes</source>
          <target state="translated">전처리 DOM 노드</target>
        </trans-unit>
        <trans-unit id="3bd28988e0d739a767c1940c87323328cfd0452d" translate="yes" xml:space="preserve">
          <source>Preprocessing Reference</source>
          <target state="translated">전처리 참조</target>
        </trans-unit>
        <trans-unit id="47b4f8689a05bc9cca63e4c44017f14efdaadb92" translate="yes" xml:space="preserve">
          <source>Preprocessing binding strings</source>
          <target state="translated">전처리 바인딩 문자열</target>
        </trans-unit>
        <trans-unit id="72734b1cb5286fcdc2e795102ddabad4a96ba527" translate="yes" xml:space="preserve">
          <source>Pretty simple, really.</source>
          <target state="translated">정말 간단합니다.</target>
        </trans-unit>
        <trans-unit id="02097511df2d0e39c9337e94983004dd3194c3a0" translate="yes" xml:space="preserve">
          <source>Prior to Knockout 3.4.0, you might need to use synchronous loading to prevent multiple DOM reflows when including many components simultaneously (such as with the foreach binding). With Knockout 3.4.0, components use Knockout&amp;rsquo;s &lt;a href=&quot;microtasks&quot;&gt;microtasks&lt;/a&gt; to ensure asynchronicity, and so will generally perform as well as synchronous loading.</source>
          <target state="translated">Knockout 3.4.0 이전에는 여러 구성 요소를 동시에 포함 할 때 (foreach 바인딩과 같이) 여러 DOM 리플 로우를 방지하기 위해 동기식로드를 사용해야합니다. Knockout 3.4.0에서 컴포넌트는 Knockout의 &lt;a href=&quot;microtasks&quot;&gt;마이크로 태스크&lt;/a&gt; 를 사용하여 비동기 성 을 보장하므로 일반적으로 동기식 로딩뿐만 아니라 성능도 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ea02aeead6e71fc6cbe55e718e12cf9185abfa29" translate="yes" xml:space="preserve">
          <source>Prior to Knockout 3.5.0, the default behavior was to hide destroyed items. To use this behavior as the default in newer versions, you can set a global option: ko.options.foreachHidesDestroyed = true. Then, if you want to show destroyed items for a specific foreach binding, you would set includeDestroyed: true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d2145824730e5c1b8fb6fa87d2dd101b9cb427" translate="yes" xml:space="preserve">
          <source>Pure computed observables</source>
          <target state="translated">순수한 계산 된 관측 가능</target>
        </trans-unit>
        <trans-unit id="b4ce509d140c0943b0fb6b3aa19d560a50d452fc" translate="yes" xml:space="preserve">
          <source>Pure computeds were introduced in Knockout 3.2.0. See also: &lt;a href=&quot;computed-pure&quot;&gt;more about pure computed observables&lt;/a&gt;.</source>
          <target state="translated">Knockout 3.2.0에 순수한 계산이 도입되었습니다. &lt;a href=&quot;computed-pure&quot;&gt;순수 계산 옵저버 블에 대한 추가 정보&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="57f47271f3869d1768dcebd5706b5e412a9e5dd1" translate="yes" xml:space="preserve">
          <source>Rate-limiting observable notifications</source>
          <target state="translated">속도 제한 관찰 가능 알림</target>
        </trans-unit>
        <trans-unit id="fe99aebaa6323f9c1f185c4c64c2f1a0b751fa1b" translate="yes" xml:space="preserve">
          <source>Reacting to a specific observable event with &amp;ldquo;ko.when&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="109ca37b53291d60621572a50045d0cd051c1b2b" translate="yes" xml:space="preserve">
          <source>Reading and writing observables</source>
          <target state="translated">관측 값 읽기 및 쓰기</target>
        </trans-unit>
        <trans-unit id="0a460971e455292dd35a366b845f6510cca16999" translate="yes" xml:space="preserve">
          <source>Reading information from an observableArray</source>
          <target state="translated">ObservableArray에서 정보 읽기</target>
        </trans-unit>
        <trans-unit id="10a415b94b161f38c600daa4d4bb513ecf982216" translate="yes" xml:space="preserve">
          <source>Recursive task limit</source>
          <target state="translated">재귀 작업 제한</target>
        </trans-unit>
        <trans-unit id="43f5384571767bbaaa6fd7375d219904895bb1b7" translate="yes" xml:space="preserve">
          <source>Registering a callback on the disposal of an element</source>
          <target state="translated">요소 처리시 콜백 등록</target>
        </trans-unit>
        <trans-unit id="9a480de52dbedb53c2cf2350afee5ac13630029e" translate="yes" xml:space="preserve">
          <source>Registering components as a single AMD module</source>
          <target state="translated">단일 AMD 모듈로 구성 요소 등록</target>
        </trans-unit>
        <trans-unit id="35b2eb936781d5e3694cfbb0f326c5c7048ea539" translate="yes" xml:space="preserve">
          <source>Registering components as a viewmodel/template pair</source>
          <target state="translated">컴포넌트를 뷰 모델 / 템플릿 쌍으로 등록</target>
        </trans-unit>
        <trans-unit id="dbdca1da5454335dd25004eb3b50c8f66e895af6" translate="yes" xml:space="preserve">
          <source>Registering custom component loaders</source>
          <target state="translated">사용자 컴포넌트 로더 등록</target>
        </trans-unit>
        <trans-unit id="bbd0999bf6bb00d22dc5e82c04cc79930c05379a" translate="yes" xml:space="preserve">
          <source>Registering custom elements</source>
          <target state="translated">맞춤 요소 등록</target>
        </trans-unit>
        <trans-unit id="1532215d29dce0afe9ba8e71d6fd4a5554bf38e2" translate="yes" xml:space="preserve">
          <source>Registering your binding</source>
          <target state="translated">바인딩 등록</target>
        </trans-unit>
        <trans-unit id="30a362d04fc57f7bc49c1be4cc35fc032c5bc523" translate="yes" xml:space="preserve">
          <source>Registers a component. See: &lt;a href=&quot;component-registration&quot;&gt;full documentation&lt;/a&gt;.</source>
          <target state="translated">컴포넌트를 등록합니다. &lt;a href=&quot;component-registration&quot;&gt;전체 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e806ea593f70ec532713b2e31cb54e34ae2fbb61" translate="yes" xml:space="preserve">
          <source>Removes all child nodes from the real or virtual element containerElem (cleaning away any data associated with them to avoid memory leaks).</source>
          <target state="translated">실제 또는 가상 요소 containerElem에서 모든 하위 노드를 제거합니다 (메모리 누수를 피하기 위해 연관된 모든 데이터를 정리).</target>
        </trans-unit>
        <trans-unit id="55eb1f75a4466755cbf9da8ee93eb912dc9b1c70" translate="yes" xml:space="preserve">
          <source>Removes all child nodes from the real or virtual element containerElem (in the process, cleaning away any data associated with them to avoid memory leaks), and then inserts all of the nodes from arrayOfNodes as its new children.</source>
          <target state="translated">실제 또는 가상 요소 containerElem에서 모든 자식 노드를 제거하고 (프로세스에서 메모리 누수를 피하기 위해 관련된 모든 데이터를 정리), arrayOfNodes의 모든 노드를 새 자식으로 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="aa97aaf82420ccf3d840fd847ac4d33d6adbd799" translate="yes" xml:space="preserve">
          <source>Removes the named component from the registry. Or if no such component was registered, does nothing.</source>
          <target state="translated">명명 된 구성 요소를 레지스트리에서 제거합니다. 또는 등록 된 구성 요소가 없으면 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0890f779408fa8ac76a438a26ba53f60dda91ecf" translate="yes" xml:space="preserve">
          <source>RequireJs Download</source>
          <target state="translated">RequireJs 다운로드</target>
        </trans-unit>
        <trans-unit id="00f09c861f9b24affecf1566366551a836249bc6" translate="yes" xml:space="preserve">
          <source>RequireJs can be downloaded from &lt;a href=&quot;http://requirejs.org/docs/download.html&quot;&gt;http://requirejs.org/docs/download.html&lt;/a&gt;.</source>
          <target state="translated">RequireJ는 &lt;a href=&quot;http://requirejs.org/docs/download.html&quot;&gt;http://requirejs.org/docs/download.html&lt;/a&gt; 에서 다운로드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="353d8d344e6b162e4c17b4210bea67369e7ef3b0" translate="yes" xml:space="preserve">
          <source>Returns the first child of the real or virtual element containerElem, or null if there are no children.</source>
          <target state="translated">실제 또는 가상 요소 containerElem의 첫 번째 자식을 반환하거나 자식이없는 경우 null을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f44b98d7f68f260183d81c591bdaf943f8bbc926" translate="yes" xml:space="preserve">
          <source>Returns the sibling node that follows node in its real or virtual parent element, or null if there is no following sibling.</source>
          <target state="translated">실제 또는 가상 상위 요소에서 노드를 따르는 형제 노드를 리턴하거나 다음 형제가없는 경우 널을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4bb189a069efd2411fee0be779b73d0bb87f5573" translate="yes" xml:space="preserve">
          <source>Returns true if a component with the specified name is already registered; false otherwise.</source>
          <target state="translated">지정된 이름을 가진 컴포넌트가 이미 등록 된 경우 true를 리턴합니다. 그렇지 않으면 거짓.</target>
        </trans-unit>
        <trans-unit id="4e0da6a7855830c066dbda602feb809af4d79023" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#using-valueallowunset-with-select-elements&quot;&gt;Note 2&lt;/a&gt; below. Note that valueAllowUnset is only applicable when using value to control selection on a &amp;lt;select&amp;gt; element. On other elements it has no effect.</source>
          <target state="translated">아래 &lt;a href=&quot;#using-valueallowunset-with-select-elements&quot;&gt;참고 2를&lt;/a&gt; 참조하십시오 . valueAllowUnset은 값을 사용하여 &amp;lt;select&amp;gt; 요소의 선택을 제어 할 때만 적용 할 수 있습니다. 다른 요소에서는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a4086bf02e9470ff9beaf89243d77e8723e08b3" translate="yes" xml:space="preserve">
          <source>See Example 3 above to see how you can bind options to an array of arbitrary JavaScript object - not just strings. In this case, you need to choose which of the objects&amp;rsquo; properties should be displayed as the text in the drop-down list or multi-select list. Example 3 shows how you can specify that property name by passing an additional parameter called optionsText.</source>
          <target state="translated">문자열뿐만 아니라 임의의 JavaScript 객체 배열에 옵션을 바인딩하는 방법을 보려면 위의 예제 3을 참조하십시오. 이 경우 드롭 다운 목록 또는 다중 선택 목록에서 텍스트로 표시 할 개체 속성을 선택해야합니다. 예제 3은 optionsText라는 추가 매개 변수를 전달하여 해당 특성 이름을 지정하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="627ede17723b7a1dcb26a936f7757623f8efd898" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;http://www.comptechdoc.org/independent/web/cgi/javamanual/javastyle.html&quot;&gt;a longer list of style names and their JavaScript equivalents&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;http://www.comptechdoc.org/independent/web/cgi/javamanual/javastyle.html&quot;&gt;스타일 이름과 자바 스크립트 등가물의 긴 목록을&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60845dd06d2f273308891baec64862cb1ed3b782" translate="yes" xml:space="preserve">
          <source>See later on this page for an API reference.</source>
          <target state="translated">API 참조에 대해서는이 페이지의 뒷부분을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bf68dcb1970e76f58db5ceb232524856770b8e5d" translate="yes" xml:space="preserve">
          <source>See: &lt;a href=&quot;component-custom-elements#registering-custom-elements&quot;&gt;How to enable custom elements with names that don&amp;rsquo;t correspond to explicitly registered components&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;component-custom-elements#registering-custom-elements&quot;&gt;명시 적으로 등록 된 구성 요소에 해당하지 않는 이름으로 사용자 정의 요소를 사용하는 방법&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95713d3429a1266b03118a0b69f2eaedb23716fe" translate="yes" xml:space="preserve">
          <source>Sequence of calls</source>
          <target state="translated">통화 순서</target>
        </trans-unit>
        <trans-unit id="f85944bee806bc0827acaf6829524bc912923c28" translate="yes" xml:space="preserve">
          <source>Setting computed observables or manual subscriptions to dispose automatically</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a58a31297954712265cfbf6c89f922aec8df4a41" translate="yes" xml:space="preserve">
          <source>Shorthand syntax: If you just supply a string value, KO will interpret this as the ID of a template to render. The data it supplies to the template will be your current model object.</source>
          <target state="translated">간단한 구문 : 문자열 값만 제공하면 KO는이를 렌더링 할 템플릿의 ID로 해석합니다. 템플릿에 제공하는 데이터는 현재 모델 객체가됩니다.</target>
        </trans-unit>
        <trans-unit id="f9b9f5929894997ad56cc3c83383ff218a8e4e68" translate="yes" xml:space="preserve">
          <source>Side effects</source>
          <target state="translated">부작용</target>
        </trans-unit>
        <trans-unit id="e6ea4fd88d422a61726a7ab7fbe12390130c4662" translate="yes" xml:space="preserve">
          <source>Similar to optionsText, you can also pass an additional parameter called optionsValue to specify which of the objects&amp;rsquo; properties should be used to set the value attribute on the &amp;lt;option&amp;gt; elements that KO generates. You can also specify a JavaScript function to determine this value. This function will receive the selected item as its only argument and should return a string to use for the &amp;lt;option&amp;gt; element&amp;rsquo;s value attribute.</source>
          <target state="translated">optionsText와 유사하게 optionsValue라는 추가 매개 변수를 전달하여 KO가 생성하는 &amp;lt;option&amp;gt; 요소의 값 속성을 설정하는 데 사용할 오브젝트 특성을 지정할 수 있습니다. 이 값을 결정하기 위해 JavaScript 함수를 지정할 수도 있습니다. 이 함수는 선택된 항목을 유일한 인수로 받고 &amp;lt;option&amp;gt; 요소의 value 속성에 사용할 문자열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a3bedd0f29a85642c5a7d68ff7d9693c61a907d" translate="yes" xml:space="preserve">
          <source>Similarly, you can use $parent to refer to data from outside the foreach, e.g.:</source>
          <target state="translated">마찬가지로 $ parent를 사용하여 foreach 외부의 데이터를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="650503158b05d9103c9329aa587f1f1317a8e97b" translate="yes" xml:space="preserve">
          <source>Simply putting an object into an observableArray doesn&amp;rsquo;t make all of that object&amp;rsquo;s properties themselves observable. Of course, you can make those properties observable if you wish, but that&amp;rsquo;s an independent choice. An observableArray just tracks which objects it holds, and notifies listeners when objects are added or removed.</source>
          <target state="translated">객체를 observableArray에 넣는 것만으로는 해당 객체의 모든 속성 자체를 관찰 할 수있는 것은 아닙니다. 물론 원하는 경우 이러한 속성을 관찰 가능하게 만들 수 있지만 이는 독립적 인 선택입니다. observableArray는 보유하고있는 객체를 추적하고 객체를 추가하거나 제거 할 때 리스너에게 알립니다.</target>
        </trans-unit>
        <trans-unit id="abf2e06137216103f9b100bf2bc6e09236071fb4" translate="yes" xml:space="preserve">
          <source>Since Browserify is a build-time tool, it doesn&amp;rsquo;t really need any special integration with KO components, and there&amp;rsquo;s no need to implement any kind of custom component loader to work with it. You can simply use Browserify&amp;rsquo;s require statements to grab instances of your component viewmodels, then explicitly register them, e.g.:</source>
          <target state="translated">Browserify는 빌드 타임 도구이므로 실제로 KO 구성 요소와 특별한 통합이 필요하지 않으며 작동하기 위해 모든 종류의 사용자 정의 구성 요소 로더를 구현할 필요가 없습니다. Browserify의 require 문을 사용하여 컴포넌트 뷰 모델의 인스턴스를 가져 와서 명시 적으로 등록 할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="010c57fd25ed1704f31800fad07288ef30d11c0d" translate="yes" xml:space="preserve">
          <source>Since Knockout processes the microtask queue until it is empty, without yielding to external events, numerous or lengthy tasks could cause the browser page to become unresponsive. Knockout prevents infinite recursion by canceling all remaining tasks if it detects a high level of recursion. For example, the following will eventually stop and throw an error:</source>
          <target state="translated">Knockout은 외부 이벤트를 발생시키지 않고 마이크로 태스크 큐가 비워 질 때까지 마이크로 태스킹 큐를 처리하므로 많은 또는 긴 태스크로 인해 브라우저 페이지가 응답하지 않을 수 있습니다. 녹아웃은 높은 수준의 재귀를 감지하면 나머지 모든 작업을 취소하여 무한 재귀를 방지합니다. 예를 들어, 다음은 결국 중지하고 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e12616501c65e2d78b083723430a1a67a2a4941a" translate="yes" xml:space="preserve">
          <source>Since document fragments can have multiple top-level nodes, the &lt;em&gt;entire&lt;/em&gt; document fragment (not just descendants of top-level nodes) is treated as the component template.</source>
          <target state="translated">문서 조각에는 여러 최상위 노드가있을 수 있으므로 &lt;em&gt;전체&lt;/em&gt; 문서 조각 (최상위 노드의 하위 항목이 아닌)은 구성 요소 템플릿으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="bd18b758f5b6eba86bebba7b461201774c396857" translate="yes" xml:space="preserve">
          <source>Since evaluating myExpr involves reading an observable (useObservable1), KO will supply the parameter to the component as a computed property.</source>
          <target state="translated">myExpr 평가에는 관찰 가능 (useObservable1) 읽기가 포함되므로 KO는 매개 변수를 계산 된 특성으로 컴포넌트에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="03be85be12c780e8cd251d6eb6bc1adf4b6ad284" translate="yes" xml:space="preserve">
          <source>Since the dependency on the template is explicitly stated in the define call, this automatically works with the &lt;a href=&quot;http://requirejs.org/docs/optimization.html&quot;&gt;r.js optimizer&lt;/a&gt; or similar bundling tools. The entire component - viewmodel plus template - can therefore trivially be included in a bundle file during a build step.</source>
          <target state="translated">템플릿에 대한 종속성은 define 호출에 명시 적으로 명시되어 있으므로 &lt;a href=&quot;http://requirejs.org/docs/optimization.html&quot;&gt;r.js 옵티 마이저&lt;/a&gt; 또는 유사한 번들링 도구 와 함께 자동으로 작동 합니다. 따라서 전체 구성 요소 (viewmodel plus template)는 빌드 단계에서 번들 파일에 간단하게 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="224aadfbf82f9551d1965c5a2c5ff4d289869d3f" translate="yes" xml:space="preserve">
          <source>Since the view model properties are observable, KO will automatically update the HTML elements whenever those properties change.</source>
          <target state="translated">뷰 모델 속성은 관찰 가능하므로 KO는 속성이 변경 될 때마다 HTML 요소를 자동으로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="b6b795bc25ad13bca901cb739b9e575d5ba5241f" translate="yes" xml:space="preserve">
          <source>Since this binding sets your element&amp;rsquo;s content using innerHTML, you should be careful not to use it with untrusted model values, because that might open the possibility of a script injection attack. If you cannot guarantee that the content is safe to display (for example, if it is based on a different user&amp;rsquo;s input that was stored in your database), then you can use &lt;a href=&quot;text-binding&quot;&gt;the text binding&lt;/a&gt;, which will set the element&amp;rsquo;s text value instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61ad2a3557f290cc16325b7dad71154f1a20332d" translate="yes" xml:space="preserve">
          <source>Since this binding sets your element&amp;rsquo;s content using innerHTML, you should be careful not to use it with untrusted model values, because that might open the possibility of a script injection attack. If you cannot guarantee that the content is safe to display (for example, if it is based on a different user&amp;rsquo;s input that was stored in your database), then you can use &lt;a href=&quot;text-binding&quot;&gt;the text binding&lt;/a&gt;, which will set the element&amp;rsquo;s text value using innerText or textContent instead.</source>
          <target state="translated">이 바인딩은 innerHTML을 사용하여 요소의 내용을 설정하므로 신뢰할 수없는 모델 값과 함께 사용하지 않도록주의해야합니다. 스크립트 삽입 공격이 발생할 가능성이 있기 때문입니다. 내용이 안전하게 표시되도록 보장 할 수없는 경우 (예 : 데이터베이스에 저장된 다른 사용자 입력을 기반으로하는 경우) &lt;a href=&quot;text-binding&quot;&gt;텍스트 바인딩을&lt;/a&gt; 사용하면 innerText 또는 대신 textContent.</target>
        </trans-unit>
        <trans-unit id="bd93df4e4321804a588bbd3af3830ed05cdb095f" translate="yes" xml:space="preserve">
          <source>Since this binding sets your text value using a text node, it&amp;rsquo;s safe to set any string value without risking HTML or script injection. For example, if you wrote:</source>
          <target state="translated">이 바인딩은 텍스트 노드를 사용하여 텍스트 값을 설정하므로 HTML 또는 스크립트 삽입의 위험없이 문자열 값을 설정하는 것이 안전합니다. 예를 들어, 다음과 같이 쓴 경우 :</target>
        </trans-unit>
        <trans-unit id="3ef8a4666dd8f23e26196f0af5791e8341741188" translate="yes" xml:space="preserve">
          <source>Since this computed is declared to be &lt;em&gt;pure&lt;/em&gt; (i.e., its evaluator does not directly modify other objects or state), Knockout can more efficiently manage its re-evaluation and memory use. Knockout will automatically suspend or release it if no other code has an active dependency on it.</source>
          <target state="translated">이 계산은 &lt;em&gt;순수&lt;/em&gt; 하다고 선언되므로 (즉, 평가자가 다른 객체 나 상태를 직접 수정하지 않음) 녹아웃은 재평가 및 메모리 사용을보다 효율적으로 관리 할 수 ​​있습니다. 다른 코드에 대한 의존성이없는 경우 녹아웃은 자동으로 일시 중단 또는 해제합니다.</target>
        </trans-unit>
        <trans-unit id="eec92e863ead404e06db453854298b7f7aeeb964" translate="yes" xml:space="preserve">
          <source>Skipping the binding value</source>
          <target state="translated">바인딩 값 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="5a0401febcbb91e5467f60a83d13d63f45dbb325" translate="yes" xml:space="preserve">
          <source>So what does Knockout do if you have a cycle in your dependency graph? It avoids infinite loops by enforcing the following rule: &lt;strong&gt;Knockout will not restart evaluation of a computed while it is already evaluating&lt;/strong&gt;. This is very unlikely to affect your code. It&amp;rsquo;s relevant in two situations: when two computed observables are dependent on each other (possible only if one or both use the deferEvaluation option), or when a computed observable writes to another observable on which it has a dependency (either directly or via a dependency chain). If you need to use one of these patterns and want to entirely avoid the circular dependency, you can use the peek function described above.</source>
          <target state="translated">의존성 그래프에주기가 있다면 녹아웃은 무엇을 하는가? 다음 규칙을 적용하여 무한 루프를 방지합니다. &lt;strong&gt;Knockout은 이미 평가하는 동안 계산 된 평가를 다시 시작하지 않습니다&lt;/strong&gt; . 이것은 코드에 영향을 미치지 않을 것입니다. 두 가지 계산 된 관측 가능 항목이 서로 종속적 일 때 (하나 또는 둘 다 deferEvaluation 옵션을 사용하는 경우에만 가능) 또는 계산 된 관찰 가능 항목이 종속성이있는 다른 관찰 가능 항목에 직접 또는 종속성을 통해 쓰는 경우 체인). 이러한 패턴 중 하나를 사용해야하고 순환 종속성을 완전히 피하려면 위에서 설명한 엿보기 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6f08edfde52faf5dc68f34cf119dab791fd12c1" translate="yes" xml:space="preserve">
          <source>So, Knockout doesn&amp;rsquo;t just detect dependencies the first time the evaluator runs - it redetects them every time. This means, for example, that the dependencies can vary dynamically: dependency A could determine whether the computed observable also depend on B or C. Then, it will only be re-evaluated when either A or your current choice of B or C changes. You don&amp;rsquo;t have to declare dependencies: they&amp;rsquo;re determined at runtime from the code&amp;rsquo;s execution.</source>
          <target state="translated">따라서 Knockout은 평가자가 처음 실행될 때 종속성을 감지하는 것이 아니라 매번 다시 감지합니다. 이는 예를 들어 종속성이 동적으로 변할 수 있음을 의미합니다. 종속성 A는 계산 된 관찰 가능 항목이 B 또는 C에 의존하는지 여부를 결정할 수 있습니다. 그런 다음 A 또는 현재 B 또는 C 선택이 변경 될 때만 다시 평가됩니다. 종속성을 선언 할 필요는 없습니다. 런타임시 코드 실행에서 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="a1add6969e68c367f948e300f5de00d8ce1226a9" translate="yes" xml:space="preserve">
          <source>So, Knockout doesn&amp;rsquo;t just detect dependencies the first time the evaluator runs - it redetects them every time. This means, for example, that the dependencies can vary dynamically: dependency A could determine whether the computed observable also depend on B or C. Then, it will only be re-evaluated when either A or your current choice of B or C changes. You don&amp;rsquo;t have to declare dependencies: they&amp;rsquo;re determined at runtime from the code&amp;rsquo;s execution. If the evaluator doesn&amp;rsquo;t access any obsevables, the computed observable will have no dependencies and won&amp;rsquo;t ever need to call the evaluator function again. In that case, to save resources, the computed observable will be automatically &amp;ldquo;disposed.&amp;rdquo;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6039155cfd6e7342a4bb866968884c937aafd1" translate="yes" xml:space="preserve">
          <source>So, if you would like to map a JavaScript object to this, you can pass this as the third argument:</source>
          <target state="translated">따라서 JavaScript 객체를 이것에 매핑하려면 이것을 세 번째 인수로 전달하면됩니다.</target>
        </trans-unit>
        <trans-unit id="3c47887016b47f8753b43bbda895cb4a52d3627b" translate="yes" xml:space="preserve">
          <source>So, ko.components.loaders is an array containing all the loaders currently enabled. By default, this array contains just one item: ko.components.defaultLoader. To add additional loaders, simply insert them into the ko.components.loaders array.</source>
          <target state="translated">따라서 ko.components.loaders는 현재 활성화 된 모든 로더를 포함하는 배열입니다. 기본적으로이 배열에는 ko.components.defaultLoader 항목이 하나만 포함됩니다. 로더를 추가하려면 ko.components.loaders 배열에 로더를 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="bcadd6a9a819e98e876d51538df845e3924045c1" translate="yes" xml:space="preserve">
          <source>So, what&amp;rsquo;s this _destroy thing all about? It&amp;rsquo;s only really interesting to Rails developers. The convention in Rails is that, when you pass into an action a JSON object graph, the framework can automatically convert it to an ActiveRecord object graph and then save it to your database. It knows which of the objects are already in your database, and issues the correct INSERT or UPDATE statements. To tell the framework to DELETE a record, you just mark it with _destroy set to true.</source>
          <target state="translated">그래서이 _destroy는 무엇입니까? Rails 개발자들에게는 정말 흥미 롭습니다. Rails의 규칙은 JSON 객체 그래프를 액션에 전달할 때 프레임 워크가이를 자동으로 ActiveRecord 객체 그래프로 변환 한 다음 데이터베이스에 저장할 수 있다는 것입니다. 이미 데이터베이스에있는 오브젝트를 알고 올바른 INSERT 또는 UPDATE 문을 발행합니다. 프레임 워크에 레코드를 삭제하도록 지시하려면 _destroy를 true로 설정하여 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="0cc17b6b6ff109ca3571a9c612acc5269c5e86c5" translate="yes" xml:space="preserve">
          <source>Sometimes it may be necessary to have more control over how the mapping is performed. This is accomplished using &lt;em&gt;mapping options&lt;/em&gt;. They can be specified during the ko.mapping.fromJS call. In subsequent calls you don&amp;rsquo;t need to specify them again.</source>
          <target state="translated">때때로 매핑이 수행되는 방식을 더 세밀하게 제어해야 할 수도 있습니다. 이것은 &lt;em&gt;매핑 옵션을&lt;/em&gt; 사용하여 수행됩니다 . ko.mapping.fromJS 호출 중에 지정할 수 있습니다. 후속 통화에서는 다시 지정할 필요가 없습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
