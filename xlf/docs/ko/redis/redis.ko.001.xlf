<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="redis">
    <body>
      <group id="redis">
        <trans-unit id="6cbbabd0de1af9aa5bea8c5c86e71564ff432533" translate="yes" xml:space="preserve">
          <source>&quot;All-time&quot; means the maximum latency since the Redis instance was started, or the time that events were reset &lt;a href=&quot;latency-reset&quot;&gt;LATENCY RESET&lt;/a&gt;.</source>
          <target state="translated">'전체'는 Redis 인스턴스가 시작된 이후의 최대 지연 시간 또는 이벤트가 재설정 된 시간 &lt;a href=&quot;latency-reset&quot;&gt;LATENCY RESET을 의미&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d090ece0f6a013c7b127d821779608185c9bdd43" translate="yes" xml:space="preserve">
          <source>&quot;master&quot;</source>
          <target state="translated">&quot;master&quot;</target>
        </trans-unit>
        <trans-unit id="6d0ace2f2b4d75b2aa62e7e81cf28ea7b27257b2" translate="yes" xml:space="preserve">
          <source>&quot;sentinel&quot;</source>
          <target state="translated">&quot;sentinel&quot;</target>
        </trans-unit>
        <trans-unit id="b7b37b37a23f19943025621e89ffee17065c89ed" translate="yes" xml:space="preserve">
          <source>&quot;slave&quot;</source>
          <target state="translated">&quot;slave&quot;</target>
        </trans-unit>
        <trans-unit id="d66b9359c4d9858484686c0c6a5bcc4c1dcb97a8" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2009&amp;ndash;2018 Salvatore Sanfilippo</source>
          <target state="translated">&amp;copy; 2009&amp;ndash;2018 살바토레 산 필리포</target>
        </trans-unit>
        <trans-unit id="2d2e44552c5ed4f201c3443b31409c829c18d8f0" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2009&amp;ndash;2020 Salvatore Sanfilippo</source>
          <target state="translated">&amp;copy; 2009&amp;ndash;2020 Salvatore Sanfilippo</target>
        </trans-unit>
        <trans-unit id="61ecfe6c066ed9ce69b42cf0699ab184e502a6d4" translate="yes" xml:space="preserve">
          <source>...continues until all replicas for this master are returned.</source>
          <target state="translated">...이 마스터의 모든 복제본이 반환 될 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="cf13bcbd4a73014086e21ab38322f863e7ab7f8b" translate="yes" xml:space="preserve">
          <source>1 if at least 1 HyperLogLog internal register was altered. 0 otherwise.</source>
          <target state="translated">하나 이상의 HyperLogLog 내부 레지스터가 변경된 경우 1입니다. 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="9de169c009b09b9b41734a83174207038fcfc8bf" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt; -- Authenticate with the given password to the remote instance.</source>
          <target state="translated">&lt;a href=&quot;auth&quot;&gt;AUTH-&lt;/a&gt; 지정된 암호로 원격 인스턴스에 인증합니다.</target>
        </trans-unit>
        <trans-unit id="298f6459896a7afbc1f87466fa10327589bc889f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;bitfield&quot;&gt;BITFIELD&lt;/a&gt; is able to operate with multiple bit fields in the same command call. It takes a list of operations to perform, and returns an array of replies, where each array matches the corresponding operation in the list of arguments.</source>
          <target state="translated">&lt;a href=&quot;bitfield&quot;&gt;BITFIELD&lt;/a&gt; 는 동일한 명령 호출에서 여러 비트 필드로 작동 할 수 있습니다. 수행 할 연산 목록을 가져오고 응답 배열을 반환합니다. 여기서 각 배열은 인수 목록의 해당 연산과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1b7f3cd466d7da037528d2882227b821b5a2e2df" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; is a good complement to the pattern documented in the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; command documentation. Different bitmaps can be combined in order to obtain a target bitmap where the population counting operation is performed.</source>
          <target state="translated">&lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; 은 &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; 명령 문서에 문서화 된 패턴을 보완합니다 . 모집단 카운팅 연산이 수행되는 타겟 비트 맵을 얻기 위해 다른 비트 맵을 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ed9a216d74a14f4f5eef018eff2a38b5eb83d9b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; is a potentially slow command as it runs in O(N) time. Care should be taken when running it against long input strings.</source>
          <target state="translated">&lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; 은 O (N) 시간에 실행될 때 잠재적으로 느린 명령입니다. 긴 입력 문자열에 대해 실행할 때는주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="fcb39fa9adcb41d2b221be77d629ae144e570322" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;blmove&quot;&gt;BLMOVE&lt;/a&gt; is the blocking variant of &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt;. When &lt;code&gt;source&lt;/code&gt; contains elements, this command behaves exactly like &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt;. When used inside a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt;/&lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block, this command behaves exactly like &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt;. When &lt;code&gt;source&lt;/code&gt; is empty, Redis will block the connection until another client pushes to it or until &lt;code&gt;timeout&lt;/code&gt; is reached. A &lt;code&gt;timeout&lt;/code&gt; of zero can be used to block indefinitely.</source>
          <target state="translated">&lt;a href=&quot;blmove&quot;&gt;BLMOVE&lt;/a&gt; 는 &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; 의 차단 변형입니다 . 때 &lt;code&gt;source&lt;/code&gt; 요소를 포함,이 명령은 정확히처럼 동작 &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; . &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; 블록 내에서 사용될 때이 명령은 &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; 와 똑같이 작동합니다 . 때 &lt;code&gt;source&lt;/code&gt; 비어있는 다른 클라이언트가 그것을 밀어 때까지 또는 때까지, 레디 스 연결을 차단합니다 &lt;code&gt;timeout&lt;/code&gt; 에 도달 할 때. &lt;code&gt;timeout&lt;/code&gt; 제로 무기한 차단하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="47e5c8f772fa453430f8e2dfda323c8ba56c1212" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; can be used with pipelining (sending multiple commands and reading the replies in batch), however this setup makes sense almost solely when it is the last command of the pipeline.</source>
          <target state="translated">&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; 는 파이프 라이닝과 함께 사용할 수 있지만 (여러 명령을 보내고 일괄로 답장을 읽는) 파이프 라인의 마지막 명령 인 경우에만이 설정이 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2319353e1b072b97b15af4a1beffb4e2e32498aa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; guarantees to return an element from the list stored at &lt;code&gt;list2&lt;/code&gt; (since it is the first non empty list when checking &lt;code&gt;list1&lt;/code&gt;, &lt;code&gt;list2&lt;/code&gt; and &lt;code&gt;list3&lt;/code&gt; in that order).</source>
          <target state="translated">&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; 는 &lt;code&gt;list2&lt;/code&gt; 에 저장된 목록에서 요소를 리턴합니다 ( &lt;code&gt;list1&lt;/code&gt; , &lt;code&gt;list2&lt;/code&gt; 및 &lt;code&gt;list3&lt;/code&gt; 을 순서대로 점검 할 때 비어 있지 않은 첫 번째 목록 이므로 ).</target>
        </trans-unit>
        <trans-unit id="9f9dd7463402ad47ace1ee92bce2eb9098a0cd4c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; is a blocking list pop primitive. It is the blocking version of &lt;a href=&quot;lpop&quot;&gt;LPOP&lt;/a&gt; because it blocks the connection when there are no elements to pop from any of the given lists. An element is popped from the head of the first list that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; 은 차단 목록 팝 프리미티브입니다. 주어진 목록에서 팝업 할 요소가 없을 때 연결을 차단하기 때문에 &lt;a href=&quot;lpop&quot;&gt;LPOP&lt;/a&gt; 의 차단 버전입니다 . 비어 있지 않은 첫 번째 목록의 헤드에서 요소가 팝업되고 주어진 키는 주어진 순서대로 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="1b5186ef40193c51e3a6132e8e6cee5cf1ac30d2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; is a blocking list pop primitive. It is the blocking version of &lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt; because it blocks the connection when there are no elements to pop from any of the given lists. An element is popped from the tail of the first list that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">&lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; 는 차단 목록 팝 프리미티브입니다. 주어진 목록에서 팝업 할 요소가 없을 때 연결을 차단하기 때문에 &lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt; 의 차단 버전입니다 . 비어 있지 않은 첫 번째 목록의 꼬리에서 요소가 팝업되고 주어진 키는 주어진 순서대로 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="f82e1fe35cdb39003f0819a756148b419f89ffdd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; is the blocking variant of &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;. When &lt;code&gt;source&lt;/code&gt; contains elements, this command behaves exactly like &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;. When used inside a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt;/&lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block, this command behaves exactly like &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;. When &lt;code&gt;source&lt;/code&gt; is empty, Redis will block the connection until another client pushes to it or until &lt;code&gt;timeout&lt;/code&gt; is reached. A &lt;code&gt;timeout&lt;/code&gt; of zero can be used to block indefinitely.</source>
          <target state="translated">&lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH은&lt;/a&gt; 의 차단 변종이다 &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; . 때 &lt;code&gt;source&lt;/code&gt; 요소를 포함,이 명령은 정확히처럼 동작 &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; . &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; 블록 내에서 사용되는 경우이 명령은 &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; 와 똑같이 동작합니다 . 때 &lt;code&gt;source&lt;/code&gt; 비어있는 다른 클라이언트가 그것을 밀어 때까지 또는 때까지, 레디 스 연결을 차단합니다 &lt;code&gt;timeout&lt;/code&gt; 에 도달 할 때. &lt;code&gt;timeout&lt;/code&gt; 제로 무기한 차단하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="57d1c58be2dfe8693b8c49b117f3415d9a5dcc26" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt; is the blocking variant of the sorted set &lt;a href=&quot;zpopmax&quot;&gt;ZPOPMAX&lt;/a&gt; primitive.</source>
          <target state="translated">&lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt; 는 정렬 된 세트 &lt;a href=&quot;zpopmax&quot;&gt;ZPOPMAX&lt;/a&gt; 프리미티브 의 차단 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="89f44ec462a3787eaa4a4b4bb72b8ffb30247ee1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; is the blocking variant of the sorted set &lt;a href=&quot;zpopmin&quot;&gt;ZPOPMIN&lt;/a&gt; primitive.</source>
          <target state="translated">&lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; 은 정렬 된 세트 &lt;a href=&quot;zpopmin&quot;&gt;ZPOPMIN&lt;/a&gt; 프리미티브 의 차단 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="5b5fc75fc0e41fd8f7844da4c69a1874efe94876" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; is a connections control command able to suspend all the Redis clients for the specified amount of time (in milliseconds).</source>
          <target state="translated">&lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; 는 모든 Redis 클라이언트를 지정된 시간 (밀리 초) 동안 일시 중단 할 수있는 연결 제어 명령입니다.</target>
        </trans-unit>
        <trans-unit id="5820f212e9cdbffad80c4b3ec9e06f08a87839b9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;cluster-failover&quot;&gt;CLUSTER FAILOVER&lt;/a&gt;, unless the &lt;strong&gt;TAKEOVER&lt;/strong&gt; option is specified, does not execute a failover synchronously, it only &lt;em&gt;schedules&lt;/em&gt; a manual failover, bypassing the failure detection stage, so to check if the failover actually happened, &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; or other means should be used in order to verify that the state of the cluster changes after some time the command was sent.</source>
          <target state="translated">&lt;a href=&quot;cluster-failover&quot;&gt;&lt;/a&gt;&lt;strong&gt;TAKEOVER&lt;/strong&gt; 옵션이 지정 되지 않은 경우 CLUSTER FAILOVER 는 동 기적으로 장애 조치를 실행하지 않으며 장애 감지 단계를 우회하여 수동 장애 조치 만 &lt;em&gt;예약&lt;/em&gt; 하므로 장애 조치가 실제로 발생했는지 확인하려면 &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; 또는 기타 수단을 사용해야합니다. 명령이 전송 된 후 클러스터 상태가 변경되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6df93f3c2cb3628be7571750bc31c359721a8a9c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;cluster-info&quot;&gt;CLUSTER INFO&lt;/a&gt; provides &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; style information about Redis Cluster vital parameters. The following is a sample output, followed by the description of each field reported.</source>
          <target state="translated">&lt;a href=&quot;cluster-info&quot;&gt;CLUSTER INFO&lt;/a&gt; 는 Redis Cluster 필수 매개 변수에 대한 &lt;a href=&quot;info&quot;&gt;정보&lt;/a&gt; 스타일 정보를 제공합니다 . 다음은 샘플 출력이며보고 된 각 필드에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="05ab0833266a0e2d56f9bd65726d840ddd9f6d84" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; is used in order to connect different Redis nodes with cluster support enabled, into a working cluster.</source>
          <target state="translated">&lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; 은 클러스터 지원이 활성화 된 다른 Redis 노드를 작업 클러스터에 연결하기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2be70c2d8fbab0d9533c8651810517def1e38f87" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; provides all this information, that is, the current cluster configuration of the node we are contacting, in a serialization format which happens to be exactly the same as the one used by Redis Cluster itself in order to store on disk the cluster state (however the on disk cluster state has a few additional info appended at the end).</source>
          <target state="translated">&lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; 는 디스크에 클러스터 상태를 저장하기 위해 Redis Cluster 자체에서 사용 된 것과 정확히 동일한 직렬화 형식으로이 모든 정보, 즉 현재 접속중인 노드의 현재 클러스터 구성을 제공합니다 ( 그러나 온 디스크 클러스터 상태에는 끝에 몇 가지 추가 정보가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5a7b2b87d6fc55591b930de028a9b09209730fd9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; is responsible of changing the state of a hash slot in the receiving node in different ways. It can, depending on the subcommand used:</source>
          <target state="translated">&lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; 은 수신 노드의 해시 슬롯 상태를 다른 방식으로 변경합니다. 사용 된 부속 명령에 따라 다음이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="080c815556a18dd5b20cfbbccaeb8a1a935316bb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt; returns details about which cluster slots map to which Redis instances. The command is suitable to be used by Redis Cluster client libraries implementations in order to retrieve (or update when a redirection is received) the map associating cluster &lt;em&gt;hash slots&lt;/em&gt; with actual nodes network coordinates (composed of an IP address and a TCP port), so that when a command is received, it can be sent to what is likely the right instance for the keys specified in the command.</source>
          <target state="translated">&lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt; 는 어떤 클러스터 슬롯이 어떤 Redis 인스턴스에 매핑되는지에 대한 세부 정보를 반환합니다. 이 명령은 Redis Cluster 클라이언트 라이브러리 구현에서 클러스터 &lt;em&gt;해시 슬롯&lt;/em&gt; 과 실제 노드 네트워크 좌표 (IP 주소 및 TCP 포트로 구성된)를 연결하는 맵을 검색 (또는 리디렉션 수신시 업데이트)하기 위해 사용하기에 적합합니다. 명령이 수신되면 명령에 지정된 키에 적합한 인스턴스로 전송 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eea3660efa2741840d4e14948a3daf43aa7906c8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;command&quot;&gt;COMMAND&lt;/a&gt; shows some commands as having movablekeys meaning the entire command must be parsed to discover storage or retrieval keys. You can use &lt;a href=&quot;command-getkeys&quot;&gt;COMMAND GETKEYS&lt;/a&gt; to discover key positions directly from how Redis parses the commands.</source>
          <target state="translated">&lt;a href=&quot;command&quot;&gt;COMMAND&lt;/a&gt; 는 일부 명령이 움직일 수있는 키를 가지고 있음을 나타내며, 이는 스토리지 또는 검색 키를 발견하기 위해 전체 명령을 구문 분석해야 함을 의미합니다. &lt;a href=&quot;command-getkeys&quot;&gt;명령 GETKEYS&lt;/a&gt; 를 사용 하여 Redis가 명령을 구문 분석하는 방법에서 직접 키 위치를 발견 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="489bd986cf60a756e680223a682de091c3116fb2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;command-getkeys&quot;&gt;COMMAND GETKEYS&lt;/a&gt; is a helper command to let you find the keys from a full Redis command.</source>
          <target state="translated">&lt;a href=&quot;command-getkeys&quot;&gt;COMMAND GETKEYS&lt;/a&gt; 는 전체 Redis 명령에서 키를 찾을 수있는 도우미 명령입니다.</target>
        </trans-unit>
        <trans-unit id="681416ad79c51f0113f1b0bbdfdbc89c2034be1b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; takes a single argument, which is a glob-style pattern. All the configuration parameters matching this parameter are reported as a list of key-value pairs. Example:</source>
          <target state="translated">&lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; 은 glob-style 패턴 인 단일 인수를 취합니다. 이 매개 변수와 일치하는 모든 구성 매개 변수는 키-값 쌍의 목록으로보고됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="7877824c1da22443476012437fd7bd5ad0fce7d9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;copy&quot;&gt;COPY&lt;/a&gt; -- Do not remove the key from the local instance.</source>
          <target state="translated">&lt;a href=&quot;copy&quot;&gt;COPY-&lt;/a&gt; 로컬 인스턴스에서 키를 제거하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8b942248ff5e8e632605cf7a19322b0ffb3e9835" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;debug-object&quot;&gt;DEBUG OBJECT&lt;/a&gt; is a debugging command that should not be used by clients. Check the &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command instead.</source>
          <target state="translated">&lt;a href=&quot;debug-object&quot;&gt;DEBUG OBJECT&lt;/a&gt; 는 클라이언트가 사용해서는 안되는 디버깅 명령입니다. 대신 &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; 명령을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="4b0f626c24491b9a0ccd5da6245ddfb0a8879f1a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;debug-segfault&quot;&gt;DEBUG SEGFAULT&lt;/a&gt; performs an invalid memory access that crashes Redis. It is used to simulate bugs during the development.</source>
          <target state="translated">&lt;a href=&quot;debug-segfault&quot;&gt;DEBUG SEGFAULT&lt;/a&gt; 는 Redis와 충돌하는 잘못된 메모리 액세스를 수행합니다. 개발 중 버그를 시뮬레이션하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c25cdfe60b47993881a3589eb4168954e3c90ccd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; - keys stop after &lt;code&gt;numkeys&lt;/code&gt; count arguments</source>
          <target state="translated">&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; - &lt;code&gt;numkeys&lt;/code&gt; 가 인수를 세면 키가 멈춤</target>
        </trans-unit>
        <trans-unit id="32d306a1a945899d65731db124247cb2119ca3b4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; and &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; are used to evaluate scripts using the Lua interpreter built into Redis starting from version 2.6.0.</source>
          <target state="translated">&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 및 &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; 는 버전 2.6.0부터 Redis에 내장 된 Lua 인터프리터를 사용하여 스크립트를 평가하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="76dd713830729401bdb73704c6477a3b6aee8c2f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; - keys stop after &lt;code&gt;numkeys&lt;/code&gt; count arguments</source>
          <target state="translated">&lt;a href=&quot;evalsha&quot;&gt;EVALSHA-숫자&lt;/a&gt; 키가 인수를 계산 한 후 키가 &lt;code&gt;numkeys&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f93b232f51da9eb1b0852dab05bb4e62e22f401f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; works exactly like &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;, but instead of having a script as the first argument it has the SHA1 digest of a script. The behavior is the following:</source>
          <target state="translated">&lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; 는 &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 과 똑같이 작동 하지만 스크립트를 첫 번째 인수로 사용하는 대신 스크립트의 SHA1 다이제스트가 있습니다. 동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6cfd0087ee88c2ae24709966db61c0e7ac6c4b5d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; would return 0 and not alter the timeout for a key with a timeout set.</source>
          <target state="translated">&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; 는 0을 반환하고 시간 초과가 설정된 키의 시간 초과를 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1705d38419159cca69bb08cf5dadf8c85b8a1f53" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt; has the same effect and semantic as &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;, but instead of specifying the number of seconds representing the TTL (time to live), it takes an absolute &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix timestamp&lt;/a&gt; (seconds since January 1, 1970). A timestamp in the past will delete the key immediately.</source>
          <target state="translated">&lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt; 는 &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; 와 효과 및 의미가 동일 하지만 TTL (Time to Live)을 나타내는 초 수를 지정하는 대신 절대 &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix 타임 스탬프&lt;/a&gt; (1970 년 1 월 1 일 이후의 초)를 사용합니다. 과거의 타임 스탬프는 키를 즉시 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="c00a508fcaefc4b21a2a57ab333e66a1842a7ec0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt; was introduced in order to convert relative timeouts to absolute timeouts for the AOF persistence mode. Of course, it can be used directly to specify that a given key should expire at a given time in the future.</source>
          <target state="translated">&lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt; 는 AOF 지속성 모드에서 상대 시간 초과를 절대 시간 초과로 변환하기 위해 도입되었습니다. 물론, 주어진 키가 미래에 주어진 시간에 만료되도록 지정하는 데 직접 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63424360a225a4ccb8fe41847e8110707c572538" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; -- Return the old value stored at key, or nil when key did not exist.</source>
          <target state="translated">&lt;a href=&quot;get&quot;&gt;GET-&lt;/a&gt; 키에 저장된 이전 값을 반환하거나 키가 없으면 nil을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0256948e937135d52eae78e100f423a41272e11e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; arity is 2 since the command only accepts one argument and always has the format &lt;code&gt;GET _key_&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;get&quot;&gt;&lt;/a&gt;명령은 하나의 인수 만 허용하며 항상 &lt;code&gt;GET _key_&lt;/code&gt; 형식을 갖기 때문에 GET arity는 2 입니다.</target>
        </trans-unit>
        <trans-unit id="862f58acc6739ebcc65838489eb263ecdd265462" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; allows for random access of elements. If our time series have associated time information we can easily implement a binary search to get range combining &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; with the Lua scripting engine available in Redis 2.6.</source>
          <target state="translated">&lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; 는 요소에 무작위로 액세스 할 수 있습니다. 시계열에 시간 정보가 연결되어 있으면 &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; 와 Redis 2.6의 Lua 스크립팅 엔진을 결합한 범위를 얻기 위해 이진 검색을 쉽게 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea9de69ea3ff19d06a0fe287a311dbf94bb30a68" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; can be used together with &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; for counting with atomic reset. For example: a process may call &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; against the key &lt;code&gt;mycounter&lt;/code&gt; every time some event occurs, but from time to time we need to get the value of the counter and reset it to zero atomically. This can be done using &lt;code&gt;GETSET mycounter &quot;0&quot;&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; 은 원자 재설정으로 계산하기 위해 &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; 과 함께 사용할 수 있습니다 . 예를 들어 , 어떤 이벤트가 발생할 때마다 프로세스가 키 &lt;code&gt;mycounter&lt;/code&gt; 에 대해 &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; 을 호출 할 수 있지만 때때로 카운터 값을 얻어 원자 적으로 0으로 재설정해야합니다. &lt;code&gt;GETSET mycounter &quot;0&quot;&lt;/code&gt; 을 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a5cb3451bd35392828ae029ba52d4629724de6e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; array of elements contain two elements, a field and a value, for every returned element of the Hash.</source>
          <target state="translated">&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; 요소 배열에는 해시의 모든 반환 요소에 대해 필드와 값의 두 가지 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="01babade069e95b8d557b3e99aa3e3618353028b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; iterates fields of Hash types and their associated values.</source>
          <target state="translated">&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; 은 해시 유형의 필드와 관련 값을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="80a0ce1ddcb6cc2a005d75a343289ea68fbda569" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; The command returns an array of integers that correspond to the specified SHA1 digest arguments. For every corresponding SHA1 digest of a script that actually exists in the script cache, an 1 is returned, otherwise 0 is returned.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; 명령은 지정된 SHA1 다이제스트 인수에 해당하는 정수 배열을 반환합니다. 스크립트 캐시에 실제로 존재하는 스크립트의 모든 해당 SHA1 다이제스트에 대해 1이 리턴되고 그렇지 않으면 0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="486ba6315bca74f915f1d94b39f49b62d9fd7125" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;, specifically:</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;&lt;/a&gt;구체적으로 배열 응답 :</target>
        </trans-unit>
        <trans-unit id="a87373c78b3d488d21433e0636b5d549779ab143" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: From 0 to &lt;em&gt;count&lt;/em&gt; key names in a Redis array reply.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 0부터 Redis 배열 응답의 키 이름 을 &lt;em&gt;계산&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2cd100b3945e68b445209aaf2777f69f908fe02e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: a list of ACL categories or a list of commands inside a given category. The command may return an error if an invalid category name is given as argument.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : ACL 범주 목록 또는 주어진 범주 내의 명령 목록. 잘못된 범주 이름이 인수로 제공되면 명령이 오류를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e072b42a4e105e7e9a3adfdf30f4ebb2f1a7a85" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: a list of ACL rule definitions for the user.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 사용자에 대한 ACL 규칙 정의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="15910fe88d88893204377b71be2fd6fe3ca99c1e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: a list of ACL security events.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : ACL 보안 이벤트 목록입니다.</target>
        </trans-unit>
        <trans-unit id="7c52429c4d95e074b8db21a25b8a8357d1a3b806" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: a list of active channels, optionally matching the specified pattern.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; : 지정된 패턴과 선택적으로 일치하는 활성 채널 목록.</target>
        </trans-unit>
        <trans-unit id="3018dbf10bce392168033eb0d2ea6d0a4a1f46cd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: a list of channels and number of subscribers for every channel. The format is channel, count, channel, count, ..., so the list is flat. The order in which the channels are listed is the same as the order of the channels specified in the command call.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 모든 채널의 채널 목록 및 가입자 수. 형식은 channel, count, channel, count, ...이므로 목록은 단순합니다. 채널이 나열되는 순서는 명령 호출에 지정된 채널의 순서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f6152475682db758d2e7a96ad710b4e60c520e30" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: a list of server properties. The reply is a map instead of an array when RESP3 is selected. The command returns an error if the protocol requested does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 서버 속성 목록입니다. 응답은 RESP3이 선택 될 때 배열이 아닌 맵입니다. 이 명령은 요청 된 프로토콜이 존재하지 않는 경우 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="63975dbc5ab6e11639a6a1c05d5503519f5e2e82" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: a list of subcommands and their descriptions</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 부속 명령 및 설명 목록</target>
        </trans-unit>
        <trans-unit id="bde76633eb70f22567a63440df550e9e77183491" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: a list of tracking information sections and their respective values, specifically:</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 추적 정보 섹션 및 해당 값 목록, 특히 :</target>
        </trans-unit>
        <trans-unit id="d268864554befa38e947a1034b4c1845060a6854" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: all elements of the set.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 세트의 모든 요소.</target>
        </trans-unit>
        <trans-unit id="055fe2adb91d8fcd05f658cfb380ba41915fd3ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: each element being the reply to each of the commands in the atomic transaction.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 각 요소는 원자 트랜잭션의 각 명령에 대한 응답입니다.</target>
        </trans-unit>
        <trans-unit id="ee5ade4e24c570073b995a53e9ece62b6f69b7e5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of elements in the specified range (optionally with their scores).</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 지정된 범위의 요소 목록 (선택적으로 점수가 있음).</target>
        </trans-unit>
        <trans-unit id="c1eed33826c722815ff11475933335e0c3b1e741" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of elements in the specified range (optionally with their scores, in case the &lt;code&gt;WITHSCORES&lt;/code&gt; option is given).</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 지정된 범위의 요소 목록 (선택적으로 &lt;code&gt;WITHSCORES&lt;/code&gt; 옵션이 지정된 경우 점수와 함께 ).</target>
        </trans-unit>
        <trans-unit id="bdc2ce41640e157fc2c6bd8b769566856e8c384e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of elements in the specified range.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 지정된 범위의 요소 목록.</target>
        </trans-unit>
        <trans-unit id="65037bdac60d86ed70fd9dd0699a49b8ac55e271" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of elements in the specified score range (optionally with their scores).</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 지정된 점수 범위의 요소 목록 (선택적으로 점수 포함).</target>
        </trans-unit>
        <trans-unit id="08afc65db9b918c7e1911260eaa2c288c7ffbe41" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of elements in the specified score range.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 지정된 점수 범위의 요소 목록.</target>
        </trans-unit>
        <trans-unit id="759a296030fa2eac4a37ddf409f6484f614a8176" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of fields and their values stored in the hash, or an empty list when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 해시에 저장된 필드 및 값 목록 또는 &lt;code&gt;key&lt;/code&gt; 가없는 경우 빈 목록 .</target>
        </trans-unit>
        <trans-unit id="e0db2f5dd09c16dd491b0eb27aab616d26ccd184" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of fields in the hash, or an empty list when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 해시의 필드 목록 또는 &lt;code&gt;key&lt;/code&gt; 가없는 경우 빈 목록 입니다.</target>
        </trans-unit>
        <trans-unit id="38f13012834a024afeeae0e85666ed89c21d7edd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of keys from your command.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 명령의 키 목록.</target>
        </trans-unit>
        <trans-unit id="1bba25387d3ba730e4c4ccc6c9d34566d5f80b2e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of keys matching &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : &lt;code&gt;pattern&lt;/code&gt; 과 일치하는 키 목록 .</target>
        </trans-unit>
        <trans-unit id="4447e9d8f9b59b604c597c6ffc372b768b3d845a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of loaded modules. Each element in the list represents a module, and is in itself a list of property names and their values. The following properties is reported for each loaded module:</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; :로드 된 모듈 목록입니다. 목록의 각 요소는 모듈을 나타내며 그 자체로 속성 이름과 해당 값의 목록입니다. 로드 된 각 모듈에 대해 다음 속성이보고됩니다.</target>
        </trans-unit>
        <trans-unit id="7008901b9444e395b10b1891e0691aeed355ef1b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of popped elements and scores.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 팝된 요소 및 점수 목록.</target>
        </trans-unit>
        <trans-unit id="d7a9f384247f42b2ea4d443657c9b82821dfed4b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of scores or &lt;code&gt;nil&lt;/code&gt; associated with the specified &lt;code&gt;member&lt;/code&gt; values (a double precision floating point number), represented as strings.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 문자열로 표시되는 지정된 &lt;code&gt;member&lt;/code&gt; 값 (배정 밀도 부동 소수점 숫자) 과 연관된 점수 또는 &lt;code&gt;nil&lt;/code&gt; 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="768b79d5a771e0adb62f779546145aa9ec061e9f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of values associated with the given fields, in the same order as they are requested.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 요청 된 순서와 동일한 순서로 주어진 필드와 연관된 값의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="edba5817ff98e74e87ffd89dbc0e584b1c4a0ea8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of values at the specified keys.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 지정된 키의 값 목록.</target>
        </trans-unit>
        <trans-unit id="5bef410dcd9605ff27afaf5970e7a6644a6e394c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list of values in the hash, or an empty list when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 해시의 값 목록 또는 &lt;code&gt;key&lt;/code&gt; 가없는 경우 빈 목록 입니다.</target>
        </trans-unit>
        <trans-unit id="b29b511b6a80ca57921b5542f271d7db4e4c8012" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list representing the membership of the given elements, in the same order as they are requested.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 요청 된 순서와 동일한 순서로 주어진 요소의 구성원을 나타내는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="1d69c2de28454376870835b9ae6eb87c2b3c65ac" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: list with members of the resulting set.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 결과 집합의 멤버와 함께 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="f9718b402d94b04938fde9706fc952dcdcad2c30" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: nested list of command details.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 명령 세부 사항의 중첩 된 목록.</target>
        </trans-unit>
        <trans-unit id="4051935ff27edd1281b2e57032213c3ff26e7915" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: nested list of command details. Commands are returned in random order.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 명령 세부 사항의 중첩 된 목록. 명령은 임의의 순서로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="80226d2ffff944a8545c6bcef5b4ec0df2c13b6e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: nested list of memory usage metrics and their values</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 중첩 된 메모리 사용 메트릭 목록 및 해당 값</target>
        </trans-unit>
        <trans-unit id="99d3dfaa299e9d77033d819c520407d435f3828c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: nested list of slot ranges with IP/Port mappings.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : IP / 포트 매핑이있는 중첩 된 슬롯 범위 목록.</target>
        </trans-unit>
        <trans-unit id="6c33d239309c3bcbd4633a726b256c771934af60" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: specifically:</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 구체적으로 :</target>
        </trans-unit>
        <trans-unit id="d590fc1c21dcc4e3339601855092a650609ee293" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: the removed members, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 제거 된 구성원 또는 &lt;code&gt;key&lt;/code&gt; 가 존재하지 않는 경우 &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cac49343a76b7d7f49ec588c88df33b8470033ea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: the result of intersection (optionally with their scores, in case the &lt;code&gt;WITHSCORES&lt;/code&gt; option is given).</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 교차 결과 (선택적으로 &lt;code&gt;WITHSCORES&lt;/code&gt; 옵션이 제공 되는 경우 점수 포함 ).</target>
        </trans-unit>
        <trans-unit id="07d675c3632f31097196516c1c9de75c8b6dd10c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: the result of the difference (optionally with their scores, in case the &lt;code&gt;WITHSCORES&lt;/code&gt; option is given).</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 차이의 결과 (선택적으로 &lt;code&gt;WITHSCORES&lt;/code&gt; 옵션이 제공 되는 경우 점수 포함 ).</target>
        </trans-unit>
        <trans-unit id="8b4a4c18a58c75d77be58bc486629fce05810c92" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: the result of union (optionally with their scores, in case the &lt;code&gt;WITHSCORES&lt;/code&gt; option is given).</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 합집합의 결과 (선택적으로 &lt;code&gt;WITHSCORES&lt;/code&gt; 옵션이 제공 되는 경우 점수 포함 ).</target>
        </trans-unit>
        <trans-unit id="0d4edc707802ff17b22d7943be32d8fd5478cf38" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: the values of the first elements, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 첫 번째 요소의 값, 또는 &lt;code&gt;nil&lt;/code&gt; 때 &lt;code&gt;key&lt;/code&gt; 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70c5bc4b9bbfccce8d8106181933c5e8bcc80d78" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: the values of the last elements, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 마지막 요소의 값, 또는 &lt;code&gt;nil&lt;/code&gt; 때 &lt;code&gt;key&lt;/code&gt; 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd962df66dd0c06c471f01d57ba98c740e6db002" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: where the first element is one of &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;slave&lt;/code&gt;, &lt;code&gt;sentinel&lt;/code&gt; and the additional elements are role-specific as illustrated above.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 여기서 첫 번째 요소는 &lt;code&gt;master&lt;/code&gt; , &lt;code&gt;slave&lt;/code&gt; , &lt;code&gt;sentinel&lt;/code&gt; 중 하나이며 추가 요소는 위에서 설명한대로 역할에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8f9fd296564d45c8fb370985d4f39602e3fe46f2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: without passing the &lt;code&gt;store&lt;/code&gt; option the command returns a list of sorted elements. &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: when the &lt;code&gt;store&lt;/code&gt; option is specified the command returns the number of sorted elements in the destination list.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : &lt;code&gt;store&lt;/code&gt; 옵션 을 전달하지 않고 명령은 정렬 된 요소 목록을 반환합니다. &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : &lt;code&gt;store&lt;/code&gt; 옵션이 지정되면 명령은 대상 목록에서 정렬 된 요소 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="eb3267da4386d6eee86012ec1f53599537ae1e6f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt; (or verbatim reply when using the RESP3 protocol): the string containing the generative computer art, and a text with the Redis version.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; (또는 RESP3 프로토콜을 사용하는 경우 축약 적 응답) : 생성 컴퓨터 아트를 포함하는 문자열 및 Redis 버전의 텍스트.</target>
        </trans-unit>
        <trans-unit id="0060692d109c5852aa6b03fa7716b694d65526b7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt; This command returns the SHA1 digest of the script added into the script cache.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; 이 명령은 스크립트 캐시에 추가 된 스크립트의 SHA1 다이제스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="845a3428e17cdef2c02c9f357ff17ea5bbaad601" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;, specifically:</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 회신&lt;/a&gt; , 특히 :</target>
        </trans-unit>
        <trans-unit id="5e7fc817ca969a4aa43419d826f7c1c4eb7dd749" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: A map between named fields and values in the form of &lt;code&gt;&amp;lt;field&amp;gt;:&amp;lt;value&amp;gt;&lt;/code&gt; lines separated by newlines composed by the two bytes &lt;code&gt;CRLF&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 이름이 지정된 필드와 &lt;code&gt;&amp;lt;field&amp;gt;:&amp;lt;value&amp;gt;&lt;/code&gt; 행 형식의 값 사이의 맵 ( 2 바이트 &lt;code&gt;CRLF&lt;/code&gt; 로 구성된 줄 바꿈으로 구분) .</target>
        </trans-unit>
        <trans-unit id="a4a5567225398e5bc0068ba239e91b02d4ee7cb2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: The connection name, or a null bulk reply if no name is set.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 회신&lt;/a&gt; : 연결 이름 또는 이름이 설정되지 않은 경우 null 대량 회신.</target>
        </trans-unit>
        <trans-unit id="b057bb332a67214e2a4a458e18172042e7cd632b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: The node id.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 노드 ID입니다.</target>
        </trans-unit>
        <trans-unit id="25762762c8c2667fa1ae9d38c2200fef10a8714b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: The serialized cluster configuration.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 직렬화 된 클러스터 구성.</target>
        </trans-unit>
        <trans-unit id="f5ba04d6a962501f6dbc4d2d9c2152d5b80a6dd0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: a unique string, as described at the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; page, for the current client.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt; : &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; 페이지에 설명 된대로 현재 클라이언트에 대한 고유 한 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="8291a50a03c48c7923ec73608ce7fc3f57608065" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: a unique string, formatted as follows:</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 다음과 같이 형식이 지정된 고유 한 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="86beafc65ba97e040d2555747da1b5b85fdfd2ed" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: as a collection of text lines.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 텍스트 줄 모음.</target>
        </trans-unit>
        <trans-unit id="4aea6b25841ddff2e06e954e3a51101fa16d948a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: by default 64 bytes string representing 256 bits of pseudorandom data. Otherwise if an argument if needed, the output string length is the number of specified bits (rounded to the next multiple of 4) divided by 4.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 기본적으로 256 비트 의사 난수 데이터를 나타내는 64 바이트 문자열입니다. 그렇지 않고 필요한 경우 인수 인 경우 출력 문자열 길이는 지정된 비트 수 (다음 4의 배수로 반올림)를 4로 나눈 값입니다.</target>
        </trans-unit>
        <trans-unit id="42797546d8faff4f9aa92f89bfd2c70972447f29" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the element being popped and pushed.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 팝업되고 푸시되는 요소입니다.</target>
        </trans-unit>
        <trans-unit id="d38053c5f4c5f80f17f4a7624581a88ff834bfbc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the element being popped from &lt;code&gt;source&lt;/code&gt; and pushed to &lt;code&gt;destination&lt;/code&gt;. If &lt;code&gt;timeout&lt;/code&gt; is reached, a &lt;a href=&quot;https://redis.io/topics/protocol#nil-reply&quot;&gt;Null reply&lt;/a&gt; is returned.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : &lt;code&gt;source&lt;/code&gt; 에서 팝 되어 &lt;code&gt;destination&lt;/code&gt; 푸시 되는 요소 입니다 . 경우 &lt;code&gt;timeout&lt;/code&gt; 에 도달하는 &lt;a href=&quot;https://redis.io/topics/protocol#nil-reply&quot;&gt;널 응답이&lt;/a&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="285123c9cbd50d725c88fbd823aac7aec8938410" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the memory allocator's internal statistics report</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 메모리 할당 자의 내부 통계 보고서</target>
        </trans-unit>
        <trans-unit id="15bbcaaf54deaa53f0973715aba543e9bb36e555" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the new score of &lt;code&gt;member&lt;/code&gt; (a double precision floating point number), represented as string.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 문자열 로 표시되는 &lt;code&gt;member&lt;/code&gt; 의 새로운 점수 (배정 밀도 부동 소수점 숫자)입니다.</target>
        </trans-unit>
        <trans-unit id="85742ae57c7f81e07ca0c455995ba2f2910fc525" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the old value stored at &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; did not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 이전에 저장된 값 &lt;code&gt;key&lt;/code&gt; , 또는 &lt;code&gt;nil&lt;/code&gt; 때 &lt;code&gt;key&lt;/code&gt; 존재하지 않았다.</target>
        </trans-unit>
        <trans-unit id="dd8b37400f2e5614a532885ebdf5ff7e1383af0f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the random key, or &lt;code&gt;nil&lt;/code&gt; when the database is empty.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 임의의 키 또는 데이터베이스가 비어 있으면 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="55a29455c2a78416742f62adb4ee460239fd3430" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the removed element, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 제거 된 요소 또는 &lt;code&gt;nil&lt;/code&gt; 때 &lt;code&gt;key&lt;/code&gt; 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa5f1109c9374907cd359659bbf9f94905464578" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the removed member, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 제거 된 멤버 또는 &lt;code&gt;key&lt;/code&gt; 가없는 경우 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="947373c7837eae7cf3063950a2f1e02de9ee212d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the requested element, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;index&lt;/code&gt; is out of range.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 요청 된 요소 또는 &lt;code&gt;index&lt;/code&gt; 이 범위를 벗어난 경우 &lt;code&gt;nil&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa9f8462ea5a93855e928b9e454ce50c6c8b015e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the score of &lt;code&gt;member&lt;/code&gt; (a double precision floating point number), represented as string.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 문자열 로 표시되는 &lt;code&gt;member&lt;/code&gt; 의 점수 (배정 밀도 부동 소수점 숫자)입니다.</target>
        </trans-unit>
        <trans-unit id="b125e358844dd5fc431b939a805af62c0e066976" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the serialized value.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 직렬화 된 값.</target>
        </trans-unit>
        <trans-unit id="58978233fe7cee3376f9020992b67c0daf047c20" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the username of the current connection.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 현재 연결의 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4f284406d16a47480c00ff3f29a794af6559d4da" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the value associated with &lt;code&gt;field&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;field&lt;/code&gt; is not present in the hash or &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : &lt;code&gt;field&lt;/code&gt; 와 연관된 값 또는 &lt;code&gt;field&lt;/code&gt; 가 해시 또는 &lt;code&gt;key&lt;/code&gt; 존재하지 않는 경우 &lt;code&gt;nil&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bb82d61357603bd2a57bf74faf2351a70c08ed9a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the value of &lt;code&gt;field&lt;/code&gt; after the increment.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 증분 후 &lt;code&gt;field&lt;/code&gt; 의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="9b57a44119bf18997e493deb5aa780c7768245d0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the value of &lt;code&gt;key&lt;/code&gt; after the increment.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 증분 후 &lt;code&gt;key&lt;/code&gt; 값입니다 .</target>
        </trans-unit>
        <trans-unit id="af3638610829bd57d70e0e136ec5e9fe594466c6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the value of &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 값 &lt;code&gt;key&lt;/code&gt; , 또는 &lt;code&gt;nil&lt;/code&gt; 때 &lt;code&gt;key&lt;/code&gt; 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1524e15569af4c178d682ededb3b0454707b7e4e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the value of the first element, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 첫 번째 요소의 값, 또는 &lt;code&gt;nil&lt;/code&gt; 때 &lt;code&gt;key&lt;/code&gt; 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4532d2c49323033ff7d2dfb3655ebbf78d2007b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: the value of the last element, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 마지막 요소의 값, 또는 &lt;code&gt;nil&lt;/code&gt; 때 &lt;code&gt;key&lt;/code&gt; 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83c9d8c5c93abdca6de856ff75ca817401493f50" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: without the additional &lt;code&gt;count&lt;/code&gt; argument the command returns a Bulk Reply with the randomly selected element, or &lt;code&gt;nil&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist. &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;: when the additional &lt;code&gt;count&lt;/code&gt; argument is passed the command returns an array of elements, or an empty array when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; : 추가없이 &lt;code&gt;count&lt;/code&gt; 명령이 무작위로 선택된 요소 또는과 대량 답글 반환 인수 &lt;code&gt;nil&lt;/code&gt; &lt;code&gt;key&lt;/code&gt; 존재하지 않습니다. &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; : 추가 &lt;code&gt;count&lt;/code&gt; 인수가 전달되면 명령은 요소의 배열을 반환하거나 &lt;code&gt;key&lt;/code&gt; 가 없으면 빈 배열을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="07759ce56341d0818583a0fb86981afc6b981c29" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;, specifically:</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 회신&lt;/a&gt; , 특히 :</target>
        </trans-unit>
        <trans-unit id="a77fb095c0e3bb3c72b865d23eb9fa66e6d28120" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: TTL in milliseconds, or a negative value in order to signal an error (see the description above).</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 오류를 알리기 위해 TTL (밀리 초) 또는 음수 값 (위 설명 참조).</target>
        </trans-unit>
        <trans-unit id="25c5224ccb98830f9bc39a9c0aceb209659822f3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: TTL in seconds, or a negative value in order to signal an error (see the description above).</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 오류를 알리기 위해 초 단위의 TTL 또는 음수 값 (위의 설명 참조).</target>
        </trans-unit>
        <trans-unit id="df46ee2db01a6626432daf13698e6f8ce41173c3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: The command returns the number of replicas reached by all the writes performed in the context of the current connection.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; :이 명령은 현재 연결 컨텍스트에서 수행 된 모든 쓰기에 도달 한 복제본 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aab4d4752a553c3968b6c9e98a5396808be0ccff" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: The hash slot number.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 해시 슬롯 번호.</target>
        </trans-unit>
        <trans-unit id="0503adf8c6abc2ce3ece257f521a52b790426666" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: The number of fields that were added.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 추가 된 필드 수입니다.</target>
        </trans-unit>
        <trans-unit id="89319e35389a0b857d36cb542ef3abb9f6061b45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: The number of keys in the specified hash slot, or an error if the hash slot is invalid.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 지정된 해시 슬롯의 키 수 또는 해시 슬롯이 유효하지 않은 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="946db5d1c363df4ffc29f1f9a1aabf122be9528f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: The number of keys that were removed.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 제거 된 키 수.</target>
        </trans-unit>
        <trans-unit id="cb035e5b6ce558134bf90c1ede2bd5b83f632811" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: The number of keys that were touched.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 터치 한 키 수.</target>
        </trans-unit>
        <trans-unit id="165a89aa6025991290c5b64bbc86bd67d32cbb50" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: The number of keys that were unlinked.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 연결 해제 된 키 수.</target>
        </trans-unit>
        <trans-unit id="ef2105f0d65369d9bdab9c96e694f2b29c3a8cbc" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: The number of users that were deleted. This number will not always match the number of arguments since certain users may not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 삭제 된 사용자 수입니다. 특정 사용자가 존재하지 않을 수 있으므로이 숫자는 인수의 수와 항상 일치하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="031ec027acdadc31294febc67ac2fa44cfd616b1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: an UNIX time stamp.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : UNIX 타임 스탬프.</target>
        </trans-unit>
        <trans-unit id="a7fb20c3110dc33173cdfb855cc68302e434729d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: number of commands returned by &lt;a href=&quot;command&quot;&gt;COMMAND&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : &lt;a href=&quot;command&quot;&gt;COMMAND가&lt;/a&gt; 리턴 한 명령 수</target>
        </trans-unit>
        <trans-unit id="d3985645ea6533c8ff22bd0bf4c6aaa0494190e0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: number of fields in the hash, or &lt;code&gt;0&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 해시의 필드 수 또는 &lt;code&gt;key&lt;/code&gt; 가없는 경우 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d8a11a13b75c8454450e9f6607be3eaca099e120" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the ID of the client we are redirecting the notifications to. The command returns &lt;code&gt;-1&lt;/code&gt; if client tracking is not enabled, or &lt;code&gt;0&lt;/code&gt; if client tracking is enabled but we are not redirecting the notifications to any client.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt; : 알림을 리디렉션하는 클라이언트의 ID입니다. 이 명령은 클라이언트 추적이 활성화되지 않은 경우 &lt;code&gt;-1&lt;/code&gt; 을 반환 하고 클라이언트 추적이 활성화되어 있지만 알림을 클라이언트로 리디렉션하지 않는 경우 &lt;code&gt;0&lt;/code&gt; 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e5320679eebca502eaa82896b5c272af8082c5d4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the bit value stored at &lt;em&gt;offset&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : &lt;em&gt;오프셋에&lt;/em&gt; 저장된 비트 값 .</target>
        </trans-unit>
        <trans-unit id="730ee3041b75e97424b63378eaa1ccca403b0299" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the cardinality (number of elements) of the set, or &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 세트의 카디널리티 (요소 수) 또는 &lt;code&gt;key&lt;/code&gt; 가없는 경우 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9df01f443c8d7ccdeca31cbfe67e7d6710102a58" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the cardinality (number of elements) of the sorted set, or &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 정렬 된 세트의 카디널리티 (요소 수) 또는 &lt;code&gt;key&lt;/code&gt; 가없는 경우 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d33f609110f9a248f5b18cee48af07aaadfe1e0d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the length of the list after the insert operation, or &lt;code&gt;-1&lt;/code&gt; when the value &lt;code&gt;pivot&lt;/code&gt; was not found.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 삽입 조작 후 목록의 길이 또는 값 &lt;code&gt;pivot&lt;/code&gt; 을 찾을 수없는 경우 &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="24ce1afd1e33220091d8cb4d0b2c52498ebf5cb8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the length of the list after the push operation.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 푸시 조작 후 목록의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="aa44d6a2e061a425b99d1f822db98d1c24616fb0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the length of the list after the push operations.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 푸시 조작 후 목록의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="df9eab7d23111f94bd3556cf17f936ecd2fd185d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the length of the list at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : &lt;code&gt;key&lt;/code&gt; 의 목록 길이 .</target>
        </trans-unit>
        <trans-unit id="e16d810965780b280923c3ccacb26c6db64ae821" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the length of the string after it was modified by the command.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 명령에 의해 수정 된 후의 문자열 길이.</target>
        </trans-unit>
        <trans-unit id="baebf23f1e7de2e112b0ad0540d84398daeef7c8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the length of the string after the append operation.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 추가 작업 후 문자열의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="13e194e430e7a65b50120ada22b947b03158b183" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the length of the string at &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;0&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : &lt;code&gt;key&lt;/code&gt; 의 문자열 길이 또는 &lt;code&gt;key&lt;/code&gt; 가없는 경우 &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d9698660c2db7d2df47dc712d9ebf3205e55376" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the memory usage in bytes</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 바이트 단위의 메모리 사용량</target>
        </trans-unit>
        <trans-unit id="9a56db16d5291b4e17cbdaeb8bab2796997fd8a8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of active failure reports for the node.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 노드에 대한 활성 실패 보고서 수.</target>
        </trans-unit>
        <trans-unit id="32c313e17b555e77e1a9266257601f4939b7a7b8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of clients killed.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 종료 된 클라이언트 수.</target>
        </trans-unit>
        <trans-unit id="0470450d5ab6cebc374249338ed2370944378fbd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of clients that received the message.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 메시지를받은 클라이언트 수입니다.</target>
        </trans-unit>
        <trans-unit id="6c7a01d231383c2c599ee1d953e9f8a58ee44d3c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of clients that received the message. Note that in a Redis Cluster, only clients that are connected to the same node as the publishing client are included in the count.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt; : 메시지를 수신 한 클라이언트 수. Redis 클러스터에서는 게시 클라이언트와 동일한 노드에 연결된 클라이언트 만 카운트에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="efbb0ebf86774003b900e8e13dd8994e8d673ce5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of elements in the resulting set.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 결과 집합의 요소 수</target>
        </trans-unit>
        <trans-unit id="cc80dd9c7a9c03dd83f05317737b8db6a47aab7b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of elements in the resulting sorted set at &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 결과 정렬 된 &lt;code&gt;destination&lt;/code&gt; 의 요소 수입니다 .</target>
        </trans-unit>
        <trans-unit id="4c46a6c318ca1eba536aba936805b81c6b86ed3f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of elements in the specified score range.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 지정된 점수 범위의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="6102c95e14a38b64a5b11caea6bec8853932e3ad" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of elements removed.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 제거 된 요소 수</target>
        </trans-unit>
        <trans-unit id="cbe1f1b179e296fbeb060c666b659a22da90872e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of elements that were added to the set, not including all the elements already present into the set.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 세트에 이미 존재하는 모든 요소를 ​​포함하지 않고 세트에 추가 된 요소 수.</target>
        </trans-unit>
        <trans-unit id="b5efc093745110558a0550df857be66582177f45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of entries actually deleted.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 실제로 삭제 된 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="e832fcf5757b94516db65bacd8cd26a441400850" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of entries of the stream at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : &lt;code&gt;key&lt;/code&gt; 에서 스트림의 항목 수입니다 .</target>
        </trans-unit>
        <trans-unit id="334e3e05c796cc1a3764e2446a0324552ac609d0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of event time series that were reset.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 재설정 된 이벤트 시계열 수입니다.</target>
        </trans-unit>
        <trans-unit id="291ab5dcd91e6798ef4d9a5a65a7dd018e6d3e39" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of fields that were removed from the hash, not including specified but non existing fields.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 지정된 필드를 제외하고 해시에서 제거 된 필드 수입니다.</target>
        </trans-unit>
        <trans-unit id="77f7e40a02041e5db76ae97820715d75d974f786" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of members that were removed from the set, not including non existing members.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 기존 멤버가 아닌 멤버를 제외하고 세트에서 제거 된 멤버 수입니다.</target>
        </trans-unit>
        <trans-unit id="ccd33e07b2c0561dcbd7abe58b97456e0b1ace2c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of patterns all the clients are subscribed to.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 모든 클라이언트가 구독 한 패턴의 수입니다.</target>
        </trans-unit>
        <trans-unit id="77d9eb64ec3170f986f37c742d2c0fc099b6dd8e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the number of removed elements.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 제거 된 요소 수</target>
        </trans-unit>
        <trans-unit id="bbdda2e39d4da814cc4e6c4b8d01710f540cc4f3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the original bit value stored at &lt;em&gt;offset&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : &lt;em&gt;오프셋에&lt;/em&gt; 저장된 원래 비트 값 .</target>
        </trans-unit>
        <trans-unit id="3ee2fed3ff2c167a200a10b83c93876ff8b10114" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the string length of the value associated with &lt;code&gt;field&lt;/code&gt;, or zero when &lt;code&gt;field&lt;/code&gt; is not present in the hash or &lt;code&gt;key&lt;/code&gt; does not exist at all.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : &lt;code&gt;field&lt;/code&gt; 와 연관된 값의 문자열 길이 또는 &lt;code&gt;field&lt;/code&gt; 가 해시에 없거나 &lt;code&gt;key&lt;/code&gt; 가 전혀 없는 경우 0 입니다.</target>
        </trans-unit>
        <trans-unit id="7488f83f7eab55654f7fe9268c9aabe045a7b18e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the value at &lt;code&gt;field&lt;/code&gt; after the increment operation.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : 증가 조작 후 &lt;code&gt;field&lt;/code&gt; 의 값 .</target>
        </trans-unit>
        <trans-unit id="1027bb3558c2b4ba14df5ea41d0b10ef4e2fdd02" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the value of &lt;code&gt;key&lt;/code&gt; after the decrement</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 회신&lt;/a&gt; : 감소 후 &lt;code&gt;key&lt;/code&gt; 값</target>
        </trans-unit>
        <trans-unit id="d6bd149493b8c911e4525285ffd34585893bdc1f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the value of &lt;code&gt;key&lt;/code&gt; after the increment</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 회신&lt;/a&gt; : 증분 후 &lt;code&gt;key&lt;/code&gt; 값</target>
        </trans-unit>
        <trans-unit id="7cc7de27c999708bcbeb570ac8adac852c5d672b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt; on error. On success nothing is returned since the server quits and the connection is closed.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;&lt;/a&gt;오류시 간단한 문자열 응답 . 성공하면 서버가 종료되고 연결이 종료 된 후 아무것도 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21bf305d3c19ddbfa50aa73a23fe7d2e88372fea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt; or an error if the password, or username/password pair, is invalid.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;&lt;/a&gt;비밀번호 또는 사용자 이름 / 비밀번호 쌍이 유효하지 않은 경우 간단한 문자열 응답 또는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="3d80b08e53d5f9ba47ec97437edf0c4df077d9b5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;BUMPED&lt;/code&gt; if the epoch was incremented, or &lt;code&gt;STILL&lt;/code&gt; if the node already has the greatest config epoch in the cluster.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt; : epoch가 증가한 경우 &lt;code&gt;BUMPED&lt;/code&gt; , 클러스터에서 이미 가장 큰 config epoch가 노드에있는 경우 &lt;code&gt;STILL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26a4006fcc50c5a98c791a609cf4cd33d2525570" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;Background saving started&lt;/code&gt; if &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; started correctly or &lt;code&gt;Background saving scheduled&lt;/code&gt; when used with the &lt;code&gt;SCHEDULE&lt;/code&gt; subcommand.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; 가 올바르게 &lt;code&gt;Background saving started&lt;/code&gt; 경우 백그라운드 저장이 시작 되거나 &lt;code&gt;SCHEDULE&lt;/code&gt; 하위 명령 과 함께 사용되는 경우 &lt;code&gt;Background saving scheduled&lt;/code&gt; 됩니다 .</target>
        </trans-unit>
        <trans-unit id="6f816386b73353e833eec40ca190644f53fced61" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt;</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;간단한 문자열 답장&lt;/a&gt; : &lt;code&gt;OK&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0783bd35592e36785e21f2c6ba9edb12cb11d70" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; was executed correctly. &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: when &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; option is set, the old value stored at key, or nil when key did not exist. &lt;a href=&quot;https://redis.io/topics/protocol#nil-reply&quot;&gt;Null reply&lt;/a&gt;: a Null Bulk Reply is returned if the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; operation was not performed because the user specified the &lt;code&gt;NX&lt;/code&gt; or &lt;code&gt;XX&lt;/code&gt; option but the condition was not met or if user specified the &lt;code&gt;NX&lt;/code&gt; and &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; options that do not met.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : &lt;code&gt;OK&lt;/code&gt; 경우 &lt;a href=&quot;set&quot;&gt;SET가&lt;/a&gt; 제대로 실행되었다. &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt; : &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; 옵션 설정시 키에 저장된 이전 값, 키가 존재하지 않을 경우 nil. &lt;a href=&quot;https://redis.io/topics/protocol#nil-reply&quot;&gt;Null 응답&lt;/a&gt; : 사용자가 &lt;code&gt;NX&lt;/code&gt; 또는 &lt;code&gt;XX&lt;/code&gt; 옵션을 지정 했지만 조건이 충족 되지 않아 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 작업이 수행 되지 않았거나 사용자 가 만족하지 않는 &lt;code&gt;NX&lt;/code&gt; 및 &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; 옵션을 지정한 경우 Null 대량 응답이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="c9137421435e7031e78d30846bad61e19e503d47" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; was executed correctly. &lt;a href=&quot;https://redis.io/topics/protocol#nil-reply&quot;&gt;Null reply&lt;/a&gt;: a Null Bulk Reply is returned if the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; operation was not performed because the user specified the &lt;code&gt;NX&lt;/code&gt; or &lt;code&gt;XX&lt;/code&gt; option but the condition was not met.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : &lt;code&gt;OK&lt;/code&gt; 경우 &lt;a href=&quot;set&quot;&gt;SET가&lt;/a&gt; 제대로 실행되었다. &lt;a href=&quot;https://redis.io/topics/protocol#nil-reply&quot;&gt;널 응답&lt;/a&gt; : 사용자가 &lt;code&gt;NX&lt;/code&gt; 또는 &lt;code&gt;XX&lt;/code&gt; 옵션을 지정 했지만 조건이 충족 되지 않아 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 조작이 수행되지 않은 경우 널 대량 응답이 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="9233d17c9787c672ad4f7e3e80293e0e12d1a72f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; was executed correctly.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : &lt;code&gt;OK&lt;/code&gt; 경우 &lt;a href=&quot;swapdb&quot;&gt;SWAPDB이&lt;/a&gt; 제대로 실행되었다.</target>
        </trans-unit>
        <trans-unit id="1c4f5580fb235cd00e31a46cb1c3620661396952" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if module was loaded.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;간단한 문자열 응답&lt;/a&gt; : 모듈이로드 된 경우 &lt;code&gt;OK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8803af464aafc399022f190d0b084424c2277c4b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if module was unloaded.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 모듈이 언로드 된 경우 &lt;code&gt;OK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c01fcbe216d0b2f0ff716f18544ddbcd2fc94031" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if the command was accepted and a manual failover is going to be attempted. An error if the operation cannot be executed, for example if we are talking with a node which is already a master.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : &lt;code&gt;OK&lt;/code&gt; 명령이 받아 들여졌다 및 수동 장애 조치를 시도 할 것입니다 경우. 예를 들어 이미 마스터 인 노드와 통신중인 경우 작업을 실행할 수없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="297f4fab43e0ec2423c9dfc4730472f21ff7866d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if the command was executed successfully, otherwise an error is returned.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 명령이 성공적으로 실행되면 &lt;code&gt;OK&lt;/code&gt; , 그렇지 않으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fea202f1970ef825dd4f2ad4d5812072c693d198" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if the command was successful. If the address or port specified are invalid an error is returned.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 명령이 성공하면 &lt;code&gt;OK&lt;/code&gt; . 지정된 주소 또는 포트가 유효하지 않은 경우 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c0b3a472f0028565f48745273ffdfa0dcf15fef7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if the command was successful. Otherwise an error is returned.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 명령이 성공하면 &lt;code&gt;OK&lt;/code&gt; . 그렇지 않으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="22b87078fd7c99cce816e1ce9a1ebcc7178714aa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if the connection exists and has been closed</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;간단한 문자열 응답&lt;/a&gt; : 연결이 존재하고 닫혀 있으면 &lt;code&gt;OK&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="caa068a24e4ab09fe1a9ae4419ab37a33fc39835" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if the connection name was successfully set.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 연결 이름이 성공적으로 설정되면 &lt;code&gt;OK&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3b1c28a71ec28cf5153538cceaa7522beb6dafad" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if the connection was successfully put in tracking mode or if the tracking mode was successfully disabled. Otherwise an error is returned.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 연결이 성공적으로 추적 모드에 들어갔거나 추적 모드가 성공적으로 비활성화 된 경우 &lt;code&gt;OK&lt;/code&gt; . 그렇지 않으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d1a5b725450b5d0f58fcd0701fc2ff091afc81c0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; if the security log was cleared.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 회신&lt;/a&gt; : 보안 로그가 지워지면 &lt;code&gt;OK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84b95fe0a35042125178f062fee4fdce51ef67ae" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; on success.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;간단한 문자열 응답&lt;/a&gt; : 성공하면 &lt;code&gt;OK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52284d19728639ec81c3c8e6288420afde7ec5de" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; or an error if the argument is not yes or no.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 인수가 예 또는 아니오가 아닌 경우 &lt;code&gt;OK&lt;/code&gt; 또는 오류입니다.</target>
        </trans-unit>
        <trans-unit id="b089a3050550664e92f327d65ddfe93413662e79" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; or an error if the operation fails.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : &lt;code&gt;OK&lt;/code&gt; 또는 작업이 실패하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f299cd2d528956185fa095b9e4a4352d7cf04a01" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; when the configuration was rewritten properly. Otherwise an error is returned.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : &lt;code&gt;OK&lt;/code&gt; 구성이 제대로 다시 작성했다. 그렇지 않으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="71e5863d8fc524b70c5ad7a6bb8d8819f38867d5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt; when the configuration was set properly. Otherwise an error is returned.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;간단한 문자열 응답&lt;/a&gt; : 구성이 올바르게 설정되면 &lt;code&gt;OK&lt;/code&gt; . 그렇지 않으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0f05c4a622a6872881aea9067061d16e81d37284" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: &lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;간단한 문자열 응답&lt;/a&gt; : &lt;code&gt;OK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="274f5a935602845e5384d5ae7f75c017c7a5496d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: A simple string reply indicating that the rewriting started or is about to start ASAP, when the call is executed with success.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 호출이 성공적으로 실행되면 재 작성이 시작되었거나 최대한 빨리 시작될 예정임을 나타내는 단순 문자열 응답입니다.</target>
        </trans-unit>
        <trans-unit id="ddbb0da6f2fcf04271523471ba1c71d314a0d241" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: All the subcommands return &lt;code&gt;OK&lt;/code&gt; if the command was successful. Otherwise an error is returned.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 명령이 성공하면 모든 부속 명령이 &lt;code&gt;OK&lt;/code&gt; 를 리턴 합니다. 그렇지 않으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e951489739af40c53bd8764f1a993d7edbf2e3c9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: The command just returns &lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 명령은 &lt;code&gt;OK&lt;/code&gt; 만 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3203f8adedbb1ca9d14d522445cfecd10e90ec4f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: The command returns OK on success, or &lt;code&gt;NOKEY&lt;/code&gt; if no keys were found in the source instance.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 명령은 성공하면 OK를 반환 하고 소스 인스턴스에 키가 없으면 &lt;code&gt;NOKEY&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="21baca8a75a2e37d445a9975cd6749634079640d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: The command returns OK on success.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 명령이 성공하면 OK를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e52b1b5063c0ac53b0ca6553e2990dc53de1b81f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: The command returns OK or an error if the timeout is invalid.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 시간 종료가 유효하지 않은 경우 명령은 OK 또는 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="701e711fa186a01d4b7899ec3383951b3c08d778" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: The commands returns OK on success.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 명령이 성공하면 OK를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4ab5321b7ab4610970bf380f5c99a11fa94dd26d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: always &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;간단한 문자열 응답&lt;/a&gt; : 항상 &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="18c4bbe7b1465236f074db82dbbd64ee2984a0f8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: always &lt;code&gt;OK&lt;/code&gt; since &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; can't fail.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : 항상 &lt;code&gt;OK&lt;/code&gt; 이후 &lt;a href=&quot;mset&quot;&gt;MSET이&lt;/a&gt; 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c987e3cf6216c6d351ff4515581a641f35117ef3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: always &lt;code&gt;OK&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;간단한 문자열 응답&lt;/a&gt; : 항상 &lt;code&gt;OK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="165b0e096dabb4ed30920d49027f0c9ff291c3ce" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: always OK.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;간단한 문자열 응답&lt;/a&gt; : 항상 OK.</target>
        </trans-unit>
        <trans-unit id="79014d2c1babae62d3575c928fe5a9f54b57bf86" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;Simple string reply&lt;/a&gt;: type of &lt;code&gt;key&lt;/code&gt;, or &lt;code&gt;none&lt;/code&gt; when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/protocol#simple-string-reply&quot;&gt;단순 문자열 응답&lt;/a&gt; : &lt;code&gt;key&lt;/code&gt; 유형 또는 &lt;code&gt;key&lt;/code&gt; 가 존재하지 않는 경우 &lt;code&gt;none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d2cb4c98790cb25c9fb170d76ecc215497e7546" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; -- If the key argument is an empty string, the command will instead migrate all the keys that follow the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; option (see the above section for more info).</source>
          <target state="translated">&lt;a href=&quot;keys&quot;&gt;KEYS-&lt;/a&gt; 키 인수가 빈 문자열 인 경우 명령은 대신 &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; 옵션 뒤에 오는 모든 키를 마이그레이션합니다 (자세한 내용은 위 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="7d9389fca085b1a7b5e73eb5d9c032624983e1b6" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;latency-graph&quot;&gt;LATENCY GRAPH&lt;/a&gt; lets you intuitively understand the latency trend of an &lt;code&gt;event&lt;/code&gt; via state-of-the-art visualization. It can be used for quickly grasping the situation before resorting to means such parsing the raw data from &lt;a href=&quot;latency-history&quot;&gt;LATENCY HISTORY&lt;/a&gt; or external tooling.</source>
          <target state="translated">&lt;a href=&quot;latency-graph&quot;&gt;LATENCY GRAPH를&lt;/a&gt; 사용하면 최신 시각화를 통해 &lt;code&gt;event&lt;/code&gt; 의 지연 추세를 직관적으로 이해할 수 있습니다 . &lt;a href=&quot;latency-history&quot;&gt;LATENCY HISTORY&lt;/a&gt; 또는 외부 도구 에서 원시 데이터를 구문 분석하기 전에 상황을 빠르게 파악하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60632bf207016cc8f1e0b02fff4881f8cf083c3e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; (or &lt;a href=&quot;blmove&quot;&gt;BLMOVE&lt;/a&gt; for the blocking variant) offers a way to avoid this problem: the consumer fetches the message and at the same time pushes it into a &lt;em&gt;processing&lt;/em&gt; list. It will use the &lt;a href=&quot;lrem&quot;&gt;LREM&lt;/a&gt; command in order to remove the message from the &lt;em&gt;processing&lt;/em&gt; list once the message has been processed.</source>
          <target state="translated">&lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; (또는 차단 변형의 경우 &lt;a href=&quot;blmove&quot;&gt;BLMOVE&lt;/a&gt; )는이 문제를 피할 수있는 방법을 제공합니다. 소비자가 메시지를 가져 오는 동시에 &lt;em&gt;처리&lt;/em&gt; 목록에 푸시 합니다. 메시지가 &lt;em&gt;처리&lt;/em&gt; 되면 &lt;em&gt;처리&lt;/em&gt; 목록 에서 메시지를 제거하기 위해 &lt;a href=&quot;lrem&quot;&gt;LREM&lt;/a&gt; 명령을 사용합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8146b28b81f62433a2d744f49d9906200e53444e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; arity is -2 since the command accepts at a minimum one argument, but up to an unlimited number: &lt;code&gt;MGET _key1_ [key2] [key3] ...&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; arity는 명령이 최소 하나의 인수를 허용하지만 최대 개수 인 &lt;code&gt;MGET _key1_ [key2] [key3] ...&lt;/code&gt; 이기 때문에 -2 입니다.</target>
        </trans-unit>
        <trans-unit id="b74d551dd48487b353459439c5810b8fa324a72f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; needs to perform I/O operations and to honor the specified timeout. When there is an I/O error during the transfer or if the timeout is reached the operation is aborted and the special error - &lt;code&gt;IOERR&lt;/code&gt; returned. When this happens the following two cases are possible:</source>
          <target state="translated">&lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; 는 I / O 작업을 수행하고 지정된 시간 초과를 준수 해야합니다. 전송 중에 I / O 오류가 있거나 시간 초과에 도달하면 작업이 중단되고 특수 오류 &lt;code&gt;IOERR&lt;/code&gt; 반환됩니다. 이 경우 다음 두 가지 경우가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="73d6ea01d80dd40464bdbf6f46f154e17ea759e7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; is a debugging command that streams back every command processed by the Redis server. It can help in understanding what is happening to the database. This command can both be used via &lt;code&gt;redis-cli&lt;/code&gt; and via &lt;code&gt;telnet&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 는 Redis 서버에서 처리 한 모든 명령을 다시 스트리밍하는 디버깅 명령입니다. 데이터베이스에 무슨 일이 일어나고 있는지 이해하는 데 도움이 될 수 있습니다. 이 명령은 &lt;code&gt;redis-cli&lt;/code&gt; 및 &lt;code&gt;telnet&lt;/code&gt; 을 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1817595e9bbb68cbb8aaf36ed867b47ba3126fa3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; is atomic, so all given keys are set at once. It is not possible for clients to see that some of the keys were updated while others are unchanged.</source>
          <target state="translated">&lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; 은 원자 적이므로 지정된 모든 키가 한 번에 설정됩니다. 클라이언트는 일부 키가 업데이트되었지만 다른 키는 변경되지 않았 음을 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb35a7c5ec5b28a9e0afc29b6bf7c84dc2dcf622" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; is atomic, so all given keys are set at once. It is not possible for clients to see that some of the keys were updated while others are unchanged.</source>
          <target state="translated">&lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; 는 원 자성이므로 지정된 모든 키가 한 번에 설정됩니다. 클라이언트는 일부 키가 업데이트되었지만 다른 키는 변경되지 않았 음을 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c1941a08d38c3d75df1a1db22011b076092cc7ec" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt; has the same effect and semantic as &lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt;, but the Unix time at which the key will expire is specified in milliseconds instead of seconds.</source>
          <target state="translated">&lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt; 는 EXPIREAT 와 동일한 효과 및 의미를 &lt;a href=&quot;expireat&quot;&gt;갖지만&lt;/a&gt; 키가 만료되는 Unix 시간은 초가 아닌 밀리 초로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="4c76a182dfa7f50418514e82401ec4d30522238a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt; works exactly like &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt; with the sole difference that the expire time is specified in milliseconds instead of seconds.</source>
          <target state="translated">&lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt; 는 만료 시간이 초가 아닌 밀리 초로 지정된다는 유일한 차이점을 &lt;a href=&quot;setex&quot;&gt;제외&lt;/a&gt; 하고는 SETEX 와 동일 하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="74b3bd512460d9379b27d49d692678508b5e36e8" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; tells a Redis Cluster replica node that the client is willing to read possibly stale data and is not interested in running write queries.</source>
          <target state="translated">&lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; 는 클라이언트가 오래된 데이터를 기꺼이 읽고 쓰기 쿼리 실행에 관심이 없음을 Redis 클러스터 복제본 노드에 알립니다.</target>
        </trans-unit>
        <trans-unit id="7ec5b99fb632cc347aa4c2c994ed4f7b70583c00" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; checks the RDB version and data checksum. If they don't match an error is returned.</source>
          <target state="translated">&lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; 는 RDB 버전 및 데이터 체크섬을 확인합니다. 일치하지 않으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="978b3891d3cbcd2e75b7d11250ec6e96a2651a96" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; will return a &quot;Target key name is busy&quot; error when &lt;code&gt;key&lt;/code&gt; already exists unless you use the &lt;code&gt;REPLACE&lt;/code&gt; modifier (Redis 3.0 or greater).</source>
          <target state="translated">&lt;a href=&quot;restore&quot;&gt;&lt;/a&gt; &lt;code&gt;REPLACE&lt;/code&gt; 수정 자 (Redis 3.0 이상) 를 사용하지 않으면 &lt;code&gt;key&lt;/code&gt; 이미 존재 하면 RESTORE 에서 &quot;대상 키 이름이 사용 중입니다&quot;오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="607867386bd28ac7647c1164afd60ba4bbf1ee27" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; (or &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; for the blocking variant) offers a way to avoid this problem: the consumer fetches the message and at the same time pushes it into a &lt;em&gt;processing&lt;/em&gt; list. It will use the &lt;a href=&quot;lrem&quot;&gt;LREM&lt;/a&gt; command in order to remove the message from the &lt;em&gt;processing&lt;/em&gt; list once the message has been processed.</source>
          <target state="translated">&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; (또는 블로킹 변형의 경우 &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; )는이 문제를 피하는 방법을 제공합니다. 소비자는 메시지를 가져오고 동시에 &lt;em&gt;처리&lt;/em&gt; 목록 으로 보냅니다 . 메시지가 &lt;em&gt;처리&lt;/em&gt; 되면 &lt;em&gt;처리&lt;/em&gt; 목록 에서 메시지를 제거하기 위해 &lt;a href=&quot;lrem&quot;&gt;LREM&lt;/a&gt; 명령을 사용합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8e85077550aa1c37d3c9aad2ca4d607b1411203e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; array of elements is a list of keys.</source>
          <target state="translated">&lt;a href=&quot;scan&quot;&gt;&lt;/a&gt;요소의 SCAN 배열은 키 목록입니다.</target>
        </trans-unit>
        <trans-unit id="0cdb46ca445a00b57f65dc1297a89c15d2487ed2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family functions do not guarantee that the number of elements returned per call are in a given range. The commands are also allowed to return zero elements, and the client should not consider the iteration complete as long as the returned cursor is not zero.</source>
          <target state="translated">&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 제품군 기능은 호출 당 반환되는 요소 수가 지정된 범위 내에 있음을 보증하지 않습니다. 명령은 또한 제로 요소를 리턴 할 수 있으며, 클라이언트는 리턴 된 커서가 0이 아닌 한 반복 완료를 고려해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="b5a0c19030600e5f0f42b3ad5aa1361dfd0233da" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; iterates the set of keys in the currently selected Redis database.</source>
          <target state="translated">&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 은 현재 선택된 Redis 데이터베이스에서 키 세트를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="97aa992fd62d3a4c2a98aa824313a37db5dcc019" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;, &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; return a two elements multi-bulk reply, where the first element is a string representing an unsigned 64 bit number (the cursor), and the second element is a multi-bulk with an array of elements.</source>
          <target state="translated">&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; , &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; , &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; 및 &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; 은 두 요소의 다중 벌크 응답을 반환합니다. 첫 번째 요소는 부호없는 64 비트 숫자 (커서)를 나타내는 문자열이고 두 번째 요소는 요소 배열이있는 다중 전구입니다.</target>
        </trans-unit>
        <trans-unit id="9cf84bb49b4cb754f22b3d9e765cdd491fb29676" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; excels at setting single bits, and can be called several times when multiple bits need to be set. To optimize this operation you can replace multiple &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; calls with a single call to the variadic &lt;a href=&quot;bitfield&quot;&gt;BITFIELD&lt;/a&gt; command and the use of fields of type &lt;code&gt;u1&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; 는 단일 비트 설정에 탁월하며 여러 비트를 설정해야 할 때 여러 번 호출 할 수 있습니다. 이 작업을 최적화하기 위해 여러 &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; 호출을 가변 &lt;a href=&quot;bitfield&quot;&gt;BITFIELD&lt;/a&gt; 명령에 대한 단일 호출 과 &lt;code&gt;u1&lt;/code&gt; 유형의 필드 사용으로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e1cc429647f3d3a6ed8373af387a43592fc0d84b" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt; is atomic, and can be reproduced by using the previous two commands inside an &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block. It is provided as a faster alternative to the given sequence of operations, because this operation is very common when Redis is used as a cache.</source>
          <target state="translated">&lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt; 는 원자 적이며 &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; 블록 내부의 이전 두 명령을 사용하여 재현 할 수 있습니다 . Redis가 캐시로 사용될 때이 작업은 매우 일반적이기 때문에 주어진 작업 순서에 대한 빠른 대안으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="02287c67ea11a6ca17f48473021815844fa305b7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; can be used to overwrite an existing time series.</source>
          <target state="translated">&lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; 를 사용하여 기존 시계열을 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab683100370a7f48dded6ed5a04bf67278378c30" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; - optional &lt;code&gt;STORE&lt;/code&gt; key, optional &lt;code&gt;BY&lt;/code&gt; weights, optional &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; keys</source>
          <target state="translated">&lt;a href=&quot;sort&quot;&gt;SORT-&lt;/a&gt; 옵션 &lt;code&gt;STORE&lt;/code&gt; 키, 옵션 &lt;code&gt;BY&lt;/code&gt; 중량, 옵션 &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; 키</target>
        </trans-unit>
        <trans-unit id="db52b28a5e89641f8e27484d33e354f10edf1b33" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; array of elements is a list of Set members.</source>
          <target state="translated">&lt;a href=&quot;sscan&quot;&gt;&lt;/a&gt;요소의 SSCAN 배열은 세트 멤버의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6a0f82e61b67b9691a5093ef110457f991bde8be" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; iterates elements of Sets types.</source>
          <target state="translated">&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; 은 세트 유형의 요소를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="5d4e6a6b49a52d866feae91c3794f3e18086c5bd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;strlen&quot;&gt;STRLEN&lt;/a&gt; can be used in order to obtain the number of samples.</source>
          <target state="translated">&lt;a href=&quot;strlen&quot;&gt;&lt;/a&gt;샘플 수를 얻기 위해 STRLEN을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b796eba8fd69116b937293d7d2d4e660bd7b1e77" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;sync&quot;&gt;SYNC&lt;/a&gt;. Enable blocking synchronous debugging of Lua scripts (saves changes to data).</source>
          <target state="translated">&lt;a href=&quot;sync&quot;&gt;SYNC&lt;/a&gt; . Lua 스크립트의 동기화 디버깅 차단 (데이터 변경 사항 저장)을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c8528d8f751b6eb35cec6632b6943289a674f9f5" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; is the &lt;em&gt;only Redis command&lt;/em&gt; that can add data to a stream, but there are other commands, such as &lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt; and &lt;a href=&quot;xtrim&quot;&gt;XTRIM&lt;/a&gt;, that are able to remove data from a stream.</source>
          <target state="translated">&lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; 는 스트림에 데이터를 추가 할 수 있는 &lt;em&gt;유일한 Redis 명령&lt;/em&gt; 이지만 스트림에서 데이터를 제거 할 수 있는 다른 명령 (예 : &lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt; 및 &lt;a href=&quot;xtrim&quot;&gt;XTRIM&lt;/a&gt; )이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc9cadabd9309016680c77975a8ed7b6faffec47" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;xtrim&quot;&gt;XTRIM&lt;/a&gt; trims the stream to a given number of items, evicting older items (items with lower IDs) if needed. The command is conceived to accept multiple trimming strategies, however currently only a single one is implemented, which is &lt;code&gt;MAXLEN&lt;/code&gt;, and works exactly as the &lt;code&gt;MAXLEN&lt;/code&gt; option in &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;xtrim&quot;&gt;XTRIM&lt;/a&gt; 은 스트림을 지정된 수의 항목으로 자르고 필요한 경우 오래된 항목 (ID가 낮은 항목)을 제거합니다. 이 명령은 여러 트리밍 전략을 수용하기 위해 고안되었지만 현재는 &lt;code&gt;MAXLEN&lt;/code&gt; 인 단일 전략 만 구현 되며 &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; 의 &lt;code&gt;MAXLEN&lt;/code&gt; 옵션 과 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="4b49a493a94294aa0802c279d2824c75a402544c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;zdiff&quot;&gt;ZDIFF&lt;/a&gt; - keys stop after &lt;code&gt;numkeys&lt;/code&gt; count arguments</source>
          <target state="translated">&lt;a href=&quot;zdiff&quot;&gt;ZDIFF&lt;/a&gt; - &lt;code&gt;numkeys&lt;/code&gt; 개수 인수 후 키 중지</target>
        </trans-unit>
        <trans-unit id="6bb97de4e13e1361a5806301bcfdbda867363de9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;zdiffstore&quot;&gt;ZDIFFSTORE&lt;/a&gt; - keys stop after &lt;code&gt;numkeys&lt;/code&gt; count arguments</source>
          <target state="translated">&lt;a href=&quot;zdiffstore&quot;&gt;ZDIFFSTORE&lt;/a&gt; - &lt;code&gt;numkeys&lt;/code&gt; 개수 인수 후 키 중지</target>
        </trans-unit>
        <trans-unit id="6e51a0a1a293b7ce94094c6efe1a74e0279a0a2d" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;zinter&quot;&gt;ZINTER&lt;/a&gt; - keys stop when &lt;code&gt;WEIGHT&lt;/code&gt; or &lt;code&gt;AGGREGATE&lt;/code&gt; starts</source>
          <target state="translated">&lt;a href=&quot;zinter&quot;&gt;ZINTER&lt;/a&gt; - &lt;code&gt;WEIGHT&lt;/code&gt; 또는 &lt;code&gt;AGGREGATE&lt;/code&gt; 가 시작 되면 키가 중지 됩니다.</target>
        </trans-unit>
        <trans-unit id="cc2b34b71894079f3a4247bae9140accbfa7bd62" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;zinterstore&quot;&gt;ZINTERSTORE&lt;/a&gt; - keys stop when &lt;code&gt;WEIGHT&lt;/code&gt; or &lt;code&gt;AGGREGATE&lt;/code&gt; starts</source>
          <target state="translated">&lt;a href=&quot;zinterstore&quot;&gt;ZINTERSTORE&lt;/a&gt; - &lt;code&gt;WEIGHT&lt;/code&gt; 또는 &lt;code&gt;AGGREGATE&lt;/code&gt; 가 시작 되면 키가 중지 됩니다</target>
        </trans-unit>
        <trans-unit id="ac5676feae443e91e34d888dd2a02b5b7cec1f17" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; array of elements contain two elements, a member and its associated score, for every returned element of the sorted set.</source>
          <target state="translated">&lt;a href=&quot;zscan&quot;&gt;&lt;/a&gt;요소의 ZSCAN 배열에는 정렬 된 집합의 반환 된 모든 요소에 대해 두 개의 요소 (멤버와 관련 점수)가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="867ef6f9439bd439c0289c0f4680f9547800d607" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; iterates elements of Sorted Set types and their associated scores.</source>
          <target state="translated">&lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; 은 정렬 된 세트 유형의 요소와 관련 점수를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="2d43d96fb06af73df54968ce4c53b8f01ae94f40" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;zunion&quot;&gt;ZUNION&lt;/a&gt; - keys stop when &lt;code&gt;WEIGHT&lt;/code&gt; or &lt;code&gt;AGGREGATE&lt;/code&gt; starts</source>
          <target state="translated">&lt;a href=&quot;zunion&quot;&gt;ZUNION&lt;/a&gt; - &lt;code&gt;WEIGHT&lt;/code&gt; 또는 &lt;code&gt;AGGREGATE&lt;/code&gt; 가 시작 되면 키가 중지 됩니다.</target>
        </trans-unit>
        <trans-unit id="e6ac10c909d551bbb985cb6f990ce82f84e1591a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt; - keys stop when &lt;code&gt;WEIGHT&lt;/code&gt; or &lt;code&gt;AGGREGATE&lt;/code&gt; starts</source>
          <target state="translated">&lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt; - &lt;code&gt;WEIGHT&lt;/code&gt; 또는 &lt;code&gt;AGGREGATE&lt;/code&gt; 가 시작 되면 키가 중지 됩니다</target>
        </trans-unit>
        <trans-unit id="569711c63fe9cc258fbae71ad2b1717eb25ac2f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;!&amp;lt;hashedpassword&amp;gt;&lt;/code&gt;: Like &lt;code&gt;#&amp;lt;hashedpassword&amp;gt;&lt;/code&gt; but removes the password instead of adding it.</source>
          <target state="translated">&lt;code&gt;!&amp;lt;hashedpassword&amp;gt;&lt;/code&gt; : &lt;code&gt;#&amp;lt;hashedpassword&amp;gt;&lt;/code&gt; 와 비슷하지만 암호를 추가하는 대신 제거합니다.</target>
        </trans-unit>
        <trans-unit id="332fe64b4ba3f15b2a3cb0e2784ed0e6ae7243a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#&amp;lt;hashedpassword&amp;gt;&lt;/code&gt;: Add the specified hashed password to the list of user passwords. A Redis hashed password is hashed with SHA256 and translated into a hexadecimal string. Example: &lt;code&gt;#c3ab8ff13720e8ad9047dd39466b3c8974e592c2fa383d4a3960714caef0c4f2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;#&amp;lt;hashedpassword&amp;gt;&lt;/code&gt; : 사용자 비밀번호 목록에 지정된 해시 비밀번호를 추가합니다. Redis 해시 된 암호는 SHA256으로 해시되고 16 진수 문자열로 변환됩니다. 예 : &lt;code&gt;#c3ab8ff13720e8ad9047dd39466b3c8974e592c2fa383d4a3960714caef0c4f2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8640dd4bf16306e76fc10f269c4d26da9f4dab05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;amp;&amp;lt;pattern&amp;gt;&lt;/code&gt;: add the specified glob style pattern to the list of Pub/Sub channel patterns accessible by the user. You can add multiple channel patterns to the same user. Example: &lt;code&gt;&amp;amp;chatroom:*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;lt;pattern&amp;gt;&lt;/code&gt; : 사용자가 액세스 할 수있는 Pub / Sub 채널 패턴 목록에 지정된 glob 스타일 패턴을 추가합니다. 동일한 사용자에게 여러 채널 패턴을 추가 할 수 있습니다. 예 : &lt;code&gt;&amp;amp;chatroom:*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ec34b944a1a531efc5d6a70281547dd46fc46b77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt;: Accepts multiple &lt;code&gt;element&lt;/code&gt; arguments. In Redis versions older than 2.4 it was possible to push a single value per command.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt; : 여러 &lt;code&gt;element&lt;/code&gt; 인수를 허용합니다 . 2.4 이전의 Redis 버전에서는 명령 당 단일 값을 푸시 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="d152642caa36eab07b6d0f1d23a030be20ac3dec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt;: Accepts multiple &lt;code&gt;field&lt;/code&gt; arguments. Redis versions older than 2.4 can only remove a field per call.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt; : 여러 &lt;code&gt;field&lt;/code&gt; 인수를 허용 합니다 . 2.4 이전의 Redis 버전은 통화 당 필드 만 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fbd658f48bf6962eab3d8b19eba6deaf712ae92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt;: Accepts multiple &lt;code&gt;member&lt;/code&gt; arguments. Redis versions before 2.4 are only able to add a single member per call.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt; : 여러 &lt;code&gt;member&lt;/code&gt; 인수를 허용합니다 . 2.4 이전의 Redis 버전은 통화 당 하나의 멤버 만 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14a2f58a705560c76d64b68f467a11da623ed852" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt;: Accepts multiple &lt;code&gt;member&lt;/code&gt; arguments. Redis versions older than 2.4 can only remove a set member per call.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt; : 여러 &lt;code&gt;member&lt;/code&gt; 인수를 허용합니다 . 2.4 이전의 Redis 버전은 통화 당 설정된 멤버 만 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b5a2fa9b3bf571b1535ff4a8ce7dd03406f55c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt;: Accepts multiple &lt;code&gt;value&lt;/code&gt; arguments. In Redis versions older than 2.4 it was possible to push a single value per command.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt; : 여러 &lt;code&gt;value&lt;/code&gt; 인수를 허용 합니다 . 2.4 이전의 Redis 버전에서는 명령 당 단일 값을 푸시 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="0a29c540f40c0d75c4bc54e4bfbd92975038350c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt;: Accepts multiple elements. In Redis versions older than 2.4 it was possible to add or update a single member per call.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt; : 여러 요소를 허용합니다. 2.4 이전의 Redis 버전에서는 통화 당 단일 멤버를 추가하거나 업데이트 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="b67f606f8a6a351cad41342c72792edc0e89e8ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt;: Accepts multiple elements. In Redis versions older than 2.4 it was possible to remove a single member per call.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 2.4&lt;/code&gt; : 여러 요소를 허용합니다. 2.4 이전의 Redis 버전에서는 통화 당 단일 멤버를 제거 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="83a71524c9706106fb9eb052fdcb51e544db835a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 2.6.12&lt;/code&gt;: Added the &lt;code&gt;EX&lt;/code&gt;, &lt;code&gt;PX&lt;/code&gt;, &lt;code&gt;NX&lt;/code&gt; and &lt;code&gt;XX&lt;/code&gt; options.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 2.6.12&lt;/code&gt; : &lt;code&gt;EX&lt;/code&gt; , &lt;code&gt;PX&lt;/code&gt; , &lt;code&gt;NX&lt;/code&gt; 및 &lt;code&gt;XX&lt;/code&gt; 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4901af6b504f674527d7aafc65e07383610e6747" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 3.0.0&lt;/code&gt;: Added the &lt;a href=&quot;copy&quot;&gt;COPY&lt;/a&gt; and &lt;code&gt;REPLACE&lt;/code&gt; options.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 3.0.0&lt;/code&gt; : &lt;a href=&quot;copy&quot;&gt;COPY&lt;/a&gt; 및 &lt;code&gt;REPLACE&lt;/code&gt; 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="98398956d40bb196e7619d8acc034be9d44cc0f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 3.0.2&lt;/code&gt;: Added the &lt;code&gt;XX&lt;/code&gt;, &lt;code&gt;NX&lt;/code&gt;, &lt;code&gt;CH&lt;/code&gt; and &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; options.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 3.0.2&lt;/code&gt; : &lt;code&gt;XX&lt;/code&gt; , &lt;code&gt;NX&lt;/code&gt; , &lt;code&gt;CH&lt;/code&gt; 및 &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2bea5b4de3db98a2a15eb984285a0fee982b0280" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 3.0.6&lt;/code&gt;: Added the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; option.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 3.0.6&lt;/code&gt; : &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; 옵션 추가 .</target>
        </trans-unit>
        <trans-unit id="40aba7a03dbfa089c6aed1328024c7117e29b74a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 3.2.2&lt;/code&gt;: Added the &lt;code&gt;SCHEDULE&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 3.2.2&lt;/code&gt; : &lt;code&gt;SCHEDULE&lt;/code&gt; 옵션 추가 .</target>
        </trans-unit>
        <trans-unit id="a7a30150b3885ca3019925b58e4bfaab88614e62" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 3.2&lt;/code&gt;: Added the &lt;code&gt;count&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 3.2&lt;/code&gt; : &lt;code&gt;count&lt;/code&gt; 인수가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e2ea9f36d3059b4775f75d77e03a660fad36bf90" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 4.0.7&lt;/code&gt;: Added the &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt; option.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 4.0.7&lt;/code&gt; : &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt; 옵션 추가 .</target>
        </trans-unit>
        <trans-unit id="3ee43e07d0b4b176ae91d9e26f62a182f77684ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 4.0&lt;/code&gt;: Accepts multiple &lt;code&gt;element&lt;/code&gt; arguments. In Redis versions older than 4.0 it was possible to push a single value per command.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 4.0&lt;/code&gt; : 여러 &lt;code&gt;element&lt;/code&gt; 인수를 허용합니다 . 4.0 이전의 Redis 버전에서는 명령 당 단일 값을 푸시 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="9f742473237dabd90ca797cdb25ef760905e85a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 6.0.0&lt;/code&gt;: Added ACL style (username and password).</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 6.0.0&lt;/code&gt; : ACL 스타일 추가 (사용자 이름 및 비밀번호).</target>
        </trans-unit>
        <trans-unit id="285c15b24d50f9f3e48ed6a2c1a1d448a2caf95d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 6.0.0&lt;/code&gt;: Added the &lt;code&gt;AUTH2&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 6.0.0&lt;/code&gt; : &lt;code&gt;AUTH2&lt;/code&gt; 옵션 추가 .</target>
        </trans-unit>
        <trans-unit id="e7ceb02b92efdb21741cf63fa3d22015022b2274" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 6.0.0&lt;/code&gt;: Added the &lt;code&gt;FULL&lt;/code&gt; option to &lt;code&gt;XINFO STREAM&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 6.0.0&lt;/code&gt; : &lt;code&gt;XINFO STREAM&lt;/code&gt; 에 &lt;code&gt;FULL&lt;/code&gt; 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4af1549a1f3069267544622dbebc69bf01104c19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 6.0&lt;/code&gt;: &lt;code&gt;timeout&lt;/code&gt; is interpreted as a double instead of an integer.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 6.0&lt;/code&gt; : &lt;code&gt;timeout&lt;/code&gt; 는 정수 대신 double로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="83a1cf52ae47e116a981e6ff4206d8b721834958" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 6.0&lt;/code&gt;: Added the &lt;code&gt;KEEPTTL&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 6.0&lt;/code&gt; : &lt;code&gt;KEEPTTL&lt;/code&gt; 옵션 추가 .</target>
        </trans-unit>
        <trans-unit id="fbba973e8dfca03cd5ec41e4bdcb4b3e54ff20a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 6.0&lt;/code&gt;: Supports the &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; subcommand.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 6.0&lt;/code&gt; : &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; 하위 명령을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="941a1188610db2faeb638b8c15985f0d524a8dba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 6.2.0&lt;/code&gt;: Added the &lt;code&gt;IDLE&lt;/code&gt; option and exclusive range intervals.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 6.2.0&lt;/code&gt; : &lt;code&gt;IDLE&lt;/code&gt; 옵션 및 배타적 범위 간격 추가.</target>
        </trans-unit>
        <trans-unit id="6bee5ff6ddaeb10d7c9268ffb8c5e2f5d6a6aa77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 6.2.0&lt;/code&gt;: Supports the &lt;code&gt;CREATECONSUMER&lt;/code&gt; subcommand.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 6.2.0&lt;/code&gt; : &lt;code&gt;CREATECONSUMER&lt;/code&gt; 하위 명령을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="a11fed7b45e661ed607d2bcc6a94ecc1d4d1377f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 6.2&lt;/code&gt; Added exclusive ranges.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 6.2&lt;/code&gt; 독점 범위가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="1f590db2b97fea13d3ab4b184d1fc585bed0a493" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 6.2&lt;/code&gt;: Added Pub/Sub channel patterns.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 6.2&lt;/code&gt; : Pub / Sub 채널 패턴이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="2bc582c62fddb4d98b7f1f5b2bb9a37ea165377e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 6.2&lt;/code&gt;: Added the &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; option.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 6.2&lt;/code&gt; : &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; 옵션 추가 .</target>
        </trans-unit>
        <trans-unit id="37936786fb314f252043ccc8ea194a9bc3e19ec7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 6.2&lt;/code&gt;: Added the &lt;code&gt;NOMKSTREAM&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 6.2&lt;/code&gt; : &lt;code&gt;NOMKSTREAM&lt;/code&gt; 옵션 추가 .</target>
        </trans-unit>
        <trans-unit id="c13c2057c3929dea40075ab800a2eee9e309857b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;= 6.2&lt;/code&gt;: Added the &lt;code&gt;count&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;&amp;gt;= 6.2&lt;/code&gt; : &lt;code&gt;count&lt;/code&gt; 인수가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a8cc79dae1191957c2d6bb4d0fc21ae91bdc856b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;=2.8.12&lt;/code&gt;: &lt;code&gt;ID&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;&amp;gt;=2.8.12&lt;/code&gt; : &lt;code&gt;ID&lt;/code&gt; 옵션.</target>
        </trans-unit>
        <trans-unit id="025114393bca1775c38e0037eed391d3a4acedc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;=2.8.12&lt;/code&gt;: Added new filter format.</source>
          <target state="translated">&lt;code&gt;&amp;gt;=2.8.12&lt;/code&gt; : 새 필터 형식이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="053f3e43d942653dcca6e33a1de3268d6fc52f16" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;=2.8.12&lt;/code&gt;: Added unique client &lt;code&gt;id&lt;/code&gt; field.</source>
          <target state="translated">&lt;code&gt;&amp;gt;=2.8.12&lt;/code&gt; : 고유 한 클라이언트 &lt;code&gt;id&lt;/code&gt; 필드가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4f05fc7c67e88ef21ca69149ea213c2d9da4e381" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;=3.2&lt;/code&gt;: Added &lt;code&gt;master&lt;/code&gt; type in for &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; option.</source>
          <target state="translated">&lt;code&gt;&amp;gt;=3.2&lt;/code&gt; : &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; 옵션 에 대한 &lt;code&gt;master&lt;/code&gt; 유형 추가 .</target>
        </trans-unit>
        <trans-unit id="cd66e14be9c4326dab6b817580b7c8c6dc5dc15d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;=5.0&lt;/code&gt;: Added optional &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; filter.</source>
          <target state="translated">&lt;code&gt;&amp;gt;=5.0&lt;/code&gt; : 선택적 &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; 필터가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ae5e8aedfb1df587089d638fc0eadba6ba331870" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;=5&lt;/code&gt;: Replaced &lt;code&gt;slave&lt;/code&gt;&lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; with &lt;code&gt;replica&lt;/code&gt;. &lt;code&gt;slave&lt;/code&gt; still supported for backward compatibility.</source>
          <target state="translated">&lt;code&gt;&amp;gt;=5&lt;/code&gt; : &lt;code&gt;slave&lt;/code&gt; &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; 을 &lt;code&gt;replica&lt;/code&gt; 대체했습니다 . 이전 버전과의 호환성을 위해 &lt;code&gt;slave&lt;/code&gt; 계속 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d1141d99bccc2b2d85f9ca2cefb8c73025329be8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;=6.0&lt;/code&gt;: &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt; excluded from the command's output.</source>
          <target state="translated">&lt;code&gt;&amp;gt;=6.0&lt;/code&gt; : 명령 출력에서 &lt;a href=&quot;auth&quot;&gt;AUTH가&lt;/a&gt; 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="1218bc6a016b1c022e1fccd9fb356a89e9ee5b44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;=6.2&lt;/code&gt;: &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; can be called to exit monitor mode.</source>
          <target state="translated">&lt;code&gt;&amp;gt;=6.2&lt;/code&gt; : &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; 을 호출하여 모니터 모드를 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44eefc74ec3373606d57a5ed94d056621157ef88" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;=6.2&lt;/code&gt;: &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; can be called to exit subscribed state.</source>
          <target state="translated">&lt;code&gt;&amp;gt;=6.2&lt;/code&gt; : 구독 상태를 종료하기 위해 &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; 을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f1d046fb8f1f3658596ba0159c572bd6543afe7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;=6.2&lt;/code&gt;: &lt;code&gt;LADDR&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;&amp;gt;=6.2&lt;/code&gt; : &lt;code&gt;LADDR&lt;/code&gt; 옵션.</target>
        </trans-unit>
        <trans-unit id="34add57edf900025fe772362753c4eb8ec79828b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;=6.2&lt;/code&gt;: Added &lt;code&gt;laddr&lt;/code&gt; field and the optional &lt;code&gt;ID&lt;/code&gt; filter.</source>
          <target state="translated">&lt;code&gt;&amp;gt;=6.2&lt;/code&gt; : &lt;code&gt;laddr&lt;/code&gt; 필드 및 선택적 &lt;code&gt;ID&lt;/code&gt; 필터가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="04a673e1856b6d7640429daf0c5e203b54cd5b0d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;=6.2&lt;/code&gt;: Added the &lt;code&gt;GT&lt;/code&gt; and &lt;code&gt;LT&lt;/code&gt; options.</source>
          <target state="translated">&lt;code&gt;&amp;gt;=6.2&lt;/code&gt; : &lt;code&gt;GT&lt;/code&gt; 및 &lt;code&gt;LT&lt;/code&gt; 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="080406b2f8e7fa35d9b9272a2a5fe7cbfb00c193" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;gt;password&lt;/code&gt;: Add the specified clear text password as an hashed password in the list of the users passwords. Every user can have many active passwords, so that password rotation will be simpler. The specified password is not stored as clear text inside the server. Example: &lt;code&gt;&amp;gt;mypassword&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;gt;password&lt;/code&gt; : 사용자 비밀번호 목록에 지정된 일반 텍스트 비밀번호를 해시 된 비밀번호로 추가합니다. 모든 사용자는 많은 활성 암호를 가질 수 있으므로 암호 교체가 더 간단 해집니다. 지정된 암호는 서버 내부에 일반 텍스트로 저장되지 않습니다. 예 : &lt;code&gt;&amp;gt;mypassword&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee41dc050003d78fdddf70aef5db0bb9bf42427e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;= 3.2.0&lt;/code&gt;: Before Redis 3.2.0, an error is returned if source and destination names are the same.</source>
          <target state="translated">&lt;code&gt;&amp;lt;= 3.2.0&lt;/code&gt; : Redis 3.2.0 이전에는 소스와 대상 이름이 동일하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="efbdbb3fc6dd3be1efaae2643f1523e35adeb35e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;password&lt;/code&gt;: Like &lt;code&gt;&amp;gt;password&lt;/code&gt; but removes the password instead of adding it.</source>
          <target state="translated">&lt;code&gt;&amp;lt;password&lt;/code&gt; : &lt;code&gt;&amp;gt;password&lt;/code&gt; 와 비슷하지만 추가하는 대신 암호를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="a553dd659e8f61302ef140faaa0cb627da6061d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&amp;lt;command&amp;gt;&lt;/code&gt;: add this command to the list of the commands the user can call. Example: &lt;code&gt;+zadd&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;+&amp;lt;command&amp;gt;&lt;/code&gt; : 사용자가 호출 할 수있는 명령 목록에이 명령을 추가합니다. 예 : &lt;code&gt;+zadd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="366c735b421e331d6dd9cfdaeb07340a3779b46b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+&amp;lt;command&amp;gt;|&amp;lt;subcommand&amp;gt;&lt;/code&gt;: add the specified command to the list of the commands the user can execute, but only for the specified subcommand. Example: &lt;code&gt;+config|get&lt;/code&gt;. Generates an error if the specified command is already allowed in its full version for the specified user. Note: there is no symmetrical command to remove subcommands, you need to remove the whole command and re-add the subcommands you want to allow. This is much safer than removing subcommands, in the future Redis may add new dangerous subcommands, so configuring by subtraction is not good.</source>
          <target state="translated">&lt;code&gt;+&amp;lt;command&amp;gt;|&amp;lt;subcommand&amp;gt;&lt;/code&gt; : 사용자가 실행할 수있는 명령 목록에 지정된 명령을 추가하지만 지정된 하위 명령에 대해서만 추가합니다. 예 : &lt;code&gt;+config|get&lt;/code&gt; . 지정된 명령이 지정된 사용자의 전체 버전에서 이미 허용 된 경우 오류를 생성합니다. 참고 : 하위 명령을 제거하는 대칭 명령이 없으므로 전체 명령을 제거하고 허용 할 하위 명령을 다시 추가해야합니다. 이것은 하위 명령을 제거하는 것보다 훨씬 안전합니다. 앞으로 Redis는 새로운 위험한 하위 명령을 추가 할 수 있으므로 빼기로 구성하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c58bb5712b69a986cedce93a7363000108c338b2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;+@&amp;lt;category&amp;gt;&lt;/code&gt;: add all the commands in the specified category to the list of commands the user is able to execute. Example: &lt;code&gt;+@string&lt;/code&gt; (adds all the string commands). For a list of categories check the &lt;a href=&quot;acl-cat&quot;&gt;ACL CAT&lt;/a&gt; command.</source>
          <target state="translated">&lt;code&gt;+@&amp;lt;category&amp;gt;&lt;/code&gt; : 지정된 범주의 모든 명령을 사용자가 실행할 수있는 명령 목록에 추가합니다. 예 : &lt;code&gt;+@string&lt;/code&gt; (모든 문자열 명령 추가). 범주 목록은 &lt;a href=&quot;acl-cat&quot;&gt;ACL CAT&lt;/a&gt; 명령을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae54e4c2c501f18d293664a0d015906848ed315b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-&amp;lt;command&amp;gt;&lt;/code&gt;. Like &lt;code&gt;+&amp;lt;command&amp;gt;&lt;/code&gt; but removes the command instead of adding it.</source>
          <target state="translated">&lt;code&gt;-&amp;lt;command&amp;gt;&lt;/code&gt; . 마찬가지로 &lt;code&gt;+&amp;lt;command&amp;gt;&lt;/code&gt; 하지만 그것을 추가하는 대신 명령을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="68b30ed3ef6cc225df5d9dc21b287aea4db630d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; special IDs</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 및 &lt;code&gt;+&lt;/code&gt; 특수 ID</target>
        </trans-unit>
        <trans-unit id="6cdf57a670cfc51e7d6fc718c299a405669305d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-@&amp;lt;category&amp;gt;&lt;/code&gt;: Like &lt;code&gt;+@&amp;lt;category&amp;gt;&lt;/code&gt; but removes all the commands in the category instead of adding them.</source>
          <target state="translated">&lt;code&gt;-@&amp;lt;category&amp;gt;&lt;/code&gt; : &lt;code&gt;+@&amp;lt;category&amp;gt;&lt;/code&gt; 비슷하지만 추가하는 대신 범주의 모든 명령을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="6c68c96a64ce023b34b6c30c041efc57221fd313" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if &lt;code&gt;field&lt;/code&gt; already exists in the hash and no operation was performed.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; &lt;code&gt;field&lt;/code&gt; 이미 해시에 존재하고 조작이 수행되지 않은 경우 0 입니다.</target>
        </trans-unit>
        <trans-unit id="3191f65635efa576cd2bc89fae56e4d1efec7123" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if &lt;code&gt;field&lt;/code&gt; already exists in the hash and the value was updated.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; &lt;code&gt;field&lt;/code&gt; 이미 해시에 존재하고 값이 업데이트 된 경우 0 입니다.</target>
        </trans-unit>
        <trans-unit id="f60d54a05f28427b7c458dfeea13aed8c56289b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; does not exist or does not have an associated timeout.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; &lt;code&gt;key&lt;/code&gt; 가 없거나 관련 시간 초과가없는 경우 0 입니다.</target>
        </trans-unit>
        <trans-unit id="0e90c08d49825baab6c37e159792566e7fe213b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="725cc7114dc7226e3481e48740555b2efda8bbe2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was not moved.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; &lt;code&gt;key&lt;/code&gt; 가 이동되지 않은 경우 0</target>
        </trans-unit>
        <trans-unit id="d6992634edf02774fe46f2df3da515a7dcb33bc9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if &lt;code&gt;newkey&lt;/code&gt; already exists.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 경우 &lt;code&gt;newkey&lt;/code&gt; 는 이미 존재합니다.</target>
        </trans-unit>
        <trans-unit id="07c9d718cdc5414bdeb8cbdf03823f20945c303a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if &lt;code&gt;source&lt;/code&gt; was not copied.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; &lt;code&gt;source&lt;/code&gt; 가 복사되지 않은 경우 0 입니다.</target>
        </trans-unit>
        <trans-unit id="14262ac0700869ff357af1a9263d20742a687fd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if no key was set (at least one key already existed).</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 키가 설정되지 않은 경우 0 이상 (이미 하나 이상의 키가 이미 존재)</target>
        </trans-unit>
        <trans-unit id="2eca0d1ae191d0b5c68da8c00a9a39343593d08c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if the client wasn't unblocked.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 클라이언트가 차단 해제되지 않은 경우 0 입니다.</target>
        </trans-unit>
        <trans-unit id="c2861cd3b06dcac8af5ba597b6aaf182b6746c07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if the element is not a member of &lt;code&gt;source&lt;/code&gt; and no operation was performed.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 요소가 &lt;code&gt;source&lt;/code&gt; 의 구성원이 아니고 조작이 수행 되지 않은 경우 0 입니다.</target>
        </trans-unit>
        <trans-unit id="501932831346881f94c70b73cf0328c70169646f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if the element is not a member of the set, or if &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 요소가 세트의 멤버가 아니거나 &lt;code&gt;key&lt;/code&gt; 가없는 경우 0 입니다.</target>
        </trans-unit>
        <trans-unit id="6407eb5e9c5935f4ed492dcb89e94f023ccdf9ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if the hash does not contain &lt;code&gt;field&lt;/code&gt;, or &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 해시에 &lt;code&gt;field&lt;/code&gt; 가 없거나 &lt;code&gt;key&lt;/code&gt; 가없는 경우 0 입니다.</target>
        </trans-unit>
        <trans-unit id="a38cf5b0f740f8566febdf0cbf54b8a6348e5ee7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if the key does not exist.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 키가 없으면 0 입니다.</target>
        </trans-unit>
        <trans-unit id="4d32094a29f0ac2ad9de4aac6bfd6bb719d8b12a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;0&lt;/code&gt; if the key was not set</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 키가 설정되지 않은 경우 0</target>
        </trans-unit>
        <trans-unit id="9112bae35f4e833d9c58ae1e088d7112f88532b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if &lt;code&gt;field&lt;/code&gt; is a new field in the hash and &lt;code&gt;value&lt;/code&gt; was set.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 만약 &lt;code&gt;field&lt;/code&gt; 해시와 새로운 필드되는 &lt;code&gt;value&lt;/code&gt; 으로 설정 하였다.</target>
        </trans-unit>
        <trans-unit id="ad304a107eee2d23e48e6c8d1661cf1988b486aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was moved.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; &lt;code&gt;key&lt;/code&gt; 가 이동 된 경우 1</target>
        </trans-unit>
        <trans-unit id="ddcb872ed9ff94749e13ac136d245a411771aa0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; was renamed to &lt;code&gt;newkey&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 만약 &lt;code&gt;key&lt;/code&gt; 이름이 바뀌 었습니다 &lt;code&gt;newkey&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef10e3a8edd7061c899c9b9392d8d243fe7bb7bd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if &lt;code&gt;source&lt;/code&gt; was copied.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; &lt;code&gt;source&lt;/code&gt; 가 복사 된 경우 1 입니다.</target>
        </trans-unit>
        <trans-unit id="341d2d89bf2d4bfb6d516bebefd62ffd165f4ec3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if the all the keys were set.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 모든 키가 설정된 경우 1 입니다.</target>
        </trans-unit>
        <trans-unit id="f1b24187c3820176d0992932ec90c3699cbc27cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if the client was unblocked successfully.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 클라이언트가 성공적으로 차단 해제 된 경우 1 입니다.</target>
        </trans-unit>
        <trans-unit id="bcdd51deb57a70d0ba07630a412d7d995a6f5301" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if the element is a member of the set.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 요소가 세트의 멤버 인 경우 1 입니다.</target>
        </trans-unit>
        <trans-unit id="8012d2a9e6de3d4f6aa995d8b0eb71b27ecab804" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if the element is moved.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 요소가 이동 된 경우 1 입니다.</target>
        </trans-unit>
        <trans-unit id="0d1478b0e1e73b8b91c455906d3e90df5c5e2ca6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if the hash contains &lt;code&gt;field&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 해시에 &lt;code&gt;field&lt;/code&gt; 가 포함되어 있으면 1 입니다 .</target>
        </trans-unit>
        <trans-unit id="4964a69975cd68bffbd62012c286e3806522a2a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if the key exists.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 키가 존재하면 1 입니다.</target>
        </trans-unit>
        <trans-unit id="5ba5ae48b6694671ffa81ecdf4e1a12b5bc46b52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if the key was set</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 키가 설정된 경우 1</target>
        </trans-unit>
        <trans-unit id="3506c8ce49c5ce58781eb39cc319b37e03f3f3b1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if the timeout was removed.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 시간 초과가 제거 된 경우 1 입니다.</target>
        </trans-unit>
        <trans-unit id="39ccd17679d67dc4ecbd128f3c112d2bf236a020" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;1&lt;/code&gt; if the timeout was set.</source>
          <target state="translated">&lt;code&gt;1&lt;/code&gt; 시간 초과가 설정된 경우 1 입니다.</target>
        </trans-unit>
        <trans-unit id="dbbf79b9bf3b6f87c5d713fb0e1055cb163dd947" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ASC&lt;/code&gt;: Sort returned items from the nearest to the farthest, relative to the center.</source>
          <target state="translated">&lt;code&gt;ASC&lt;/code&gt; : 반품을 기준으로 가장 가까운 것부터 가장 먼 것까지 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="7ddc285586bf7c22ddf294a2870a01fa101bb68b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AUTH &amp;lt;username&amp;gt; &amp;lt;password&amp;gt;&lt;/code&gt;: directly authenticate the connection other than switching to the specified protocol. In this way there is no need to call &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt; before &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; when setting up new connections. Note that the username can be set to &quot;default&quot; in order to authenticate against a server that does not use ACLs, but the simpler &lt;code&gt;requirepass&lt;/code&gt; mechanism of Redis before version 6.</source>
          <target state="translated">&lt;code&gt;AUTH &amp;lt;username&amp;gt; &amp;lt;password&amp;gt;&lt;/code&gt; : 지정된 프로토콜로 전환하지 않고 직접 연결을 인증합니다. 이렇게하면 새 연결을 설정할 때 &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; 전에 &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt; 를 호출 할 필요가 없습니다 . ACL을 사용하지 않는 서버에 대해 인증하기 위해 사용자 이름을 &quot;default&quot;로 설정할 수 있지만 버전 6 이전의 Redis 의 더 간단한 &lt;code&gt;requirepass&lt;/code&gt; 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="5acb7c8b068cc49301cd33e4cd2d6d38317af659" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;AUTH2&lt;/code&gt; -- Authenticate with the given username and password pair (Redis 6 or greater ACL auth style).</source>
          <target state="translated">&lt;code&gt;AUTH2&lt;/code&gt; - 주어진 사용자 이름 및 암호 쌍 (Redis 6 이상 ACL 인증 스타일)으로 인증합니다.</target>
        </trans-unit>
        <trans-unit id="699f4a1057411debdcb2f7f3d871232bdbab98ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BCAST&lt;/code&gt;: enable tracking in broadcasting mode. In this mode invalidation messages are reported for all the prefixes specified, regardless of the keys requested by the connection. Instead when the broadcasting mode is not enabled, Redis will track which keys are fetched using read-only commands, and will report invalidation messages only for such keys.</source>
          <target state="translated">&lt;code&gt;BCAST&lt;/code&gt; : 방송 모드에서 추적을 활성화합니다. 이 모드에서는 연결에서 요청한 키에 관계없이 지정된 모든 접두사에 대해 무효화 메시지가보고됩니다. 대신 브로드 캐스팅 모드가 활성화되지 않은 경우 Redis는 읽기 전용 명령을 사용하여 가져온 키를 추적하고 이러한 키에 대해서만 무효화 메시지를보고합니다.</target>
        </trans-unit>
        <trans-unit id="eb836fd89c30980649b496a65a6cd12d77d066b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BLPOP&lt;/code&gt; inside a &lt;code&gt;MULTI&lt;/code&gt; / &lt;code&gt;EXEC&lt;/code&gt; transaction</source>
          <target state="translated">&lt;code&gt;BLPOP&lt;/code&gt; &lt;code&gt;MULTI&lt;/code&gt; / &lt;code&gt;EXEC&lt;/code&gt; 트랜잭션 내부의 BLPOP</target>
        </trans-unit>
        <trans-unit id="8260b4add06d1395315a310037f5329fadd6c1b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BYBOX&lt;/code&gt;: Search inside an axis-aligned rectangle, determined by &lt;code&gt;&amp;lt;height&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BYBOX&lt;/code&gt; : &lt;code&gt;&amp;lt;height&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;width&amp;gt;&lt;/code&gt; 로 결정되는 축 정렬 사각형 내부를 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="0d65c7083e1c9bc6e58d2a82145fa36d7711ea76" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;BYRADIUS&lt;/code&gt;: Similar to &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt;, search inside circular area according to given &lt;code&gt;&amp;lt;radius&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BYRADIUS&lt;/code&gt; : 유사 &lt;a href=&quot;georadius&quot;&gt;GEORADIUS는&lt;/a&gt; , 주어진 영역에 따른 원형 내부 검색 &lt;code&gt;&amp;lt;radius&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5f1a178f5cdd8cdf5152e93b36fdb7a83b660dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CLIENT KILL ADDR ip:port&lt;/code&gt;. This is exactly the same as the old three-arguments behavior.</source>
          <target state="translated">&lt;code&gt;CLIENT KILL ADDR ip:port&lt;/code&gt; . 이것은 이전 세 인수 동작과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="602320634fef925cb5009f27adc89c96fad31e12" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CLIENT KILL ID client-id&lt;/code&gt;. Allows to kill a client by its unique &lt;code&gt;ID&lt;/code&gt; field, which was introduced in the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; command starting from Redis 2.8.12.</source>
          <target state="translated">&lt;code&gt;CLIENT KILL ID client-id&lt;/code&gt; . Redis 2.8.12부터 &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; 명령 에 도입 된 고유 &lt;code&gt;ID&lt;/code&gt; 필드로 클라이언트를 강제 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8189d2f913ff843bb80f1a51af5338f680cff38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CLIENT KILL ID client-id&lt;/code&gt;. Allows to kill a client by its unique &lt;code&gt;ID&lt;/code&gt; field. Client &lt;code&gt;ID&lt;/code&gt;'s are retrieved using the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; command.</source>
          <target state="translated">&lt;code&gt;CLIENT KILL ID client-id&lt;/code&gt; . 고유 &lt;code&gt;ID&lt;/code&gt; 필드 로 클라이언트를 죽일 수 있습니다. 클라이언트 &lt;code&gt;ID&lt;/code&gt; 는 &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; 명령을 사용하여 검색됩니다 .</target>
        </trans-unit>
        <trans-unit id="cdc9d941fea7fd1dcb5cca5e4eb05de354a9aa09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CLIENT KILL LADDR ip:port&lt;/code&gt;. Kill all clients connected to specified local (bind) address.</source>
          <target state="translated">&lt;code&gt;CLIENT KILL LADDR ip:port&lt;/code&gt; . 지정된 로컬 (바인드) 주소에 연결된 모든 클라이언트를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="55aa9e9d040d810292c5cbe0fb9ec86006c8c89e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CLIENT KILL SKIPME yes/no&lt;/code&gt;. By default this option is set to &lt;code&gt;yes&lt;/code&gt;, that is, the client calling the command will not get killed, however setting this option to &lt;code&gt;no&lt;/code&gt; will have the effect of also killing the client calling the command.</source>
          <target state="translated">&lt;code&gt;CLIENT KILL SKIPME yes/no&lt;/code&gt; . 기본적으로이 옵션은 &lt;code&gt;yes&lt;/code&gt; 로 설정됩니다 . 즉, 명령을 호출하는 클라이언트는 종료되지 않지만이 옵션을 &lt;code&gt;no&lt;/code&gt; 로 설정 하면 명령을 호출하는 클라이언트도 종료하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="badcef26ac69c8575bee09d042bb365553b77d45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CLIENT KILL TYPE type&lt;/code&gt;, where &lt;em&gt;type&lt;/em&gt; is one of &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;replica&lt;/code&gt; and &lt;code&gt;pubsub&lt;/code&gt;. This closes the connections of &lt;strong&gt;all the clients&lt;/strong&gt; in the specified class. Note that clients blocked into the &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; command are considered to belong to the &lt;code&gt;normal&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;CLIENT KILL TYPE type&lt;/code&gt; . 여기서 &lt;em&gt;type&lt;/em&gt; 은 &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;master&lt;/code&gt; , &lt;code&gt;replica&lt;/code&gt; 및 &lt;code&gt;pubsub&lt;/code&gt; 중 하나입니다 . 이렇게 하면 지정된 클래스에있는 &lt;strong&gt;모든 클라이언트&lt;/strong&gt; 의 연결이 닫힙니다 . &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 명령 으로 차단 된 클라이언트 는 &lt;code&gt;normal&lt;/code&gt; 클래스 에 속하는 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="11752fd7703f3053fd849cf8479195d68449607c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CLIENT KILL TYPE type&lt;/code&gt;, where &lt;em&gt;type&lt;/em&gt; is one of &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;slave&lt;/code&gt; and &lt;code&gt;pubsub&lt;/code&gt; (the &lt;code&gt;master&lt;/code&gt; type is available from v3.2). This closes the connections of &lt;strong&gt;all the clients&lt;/strong&gt; in the specified class. Note that clients blocked into the &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; command are considered to belong to the &lt;code&gt;normal&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;CLIENT KILL TYPE type&lt;/code&gt; , 여기서 &lt;em&gt;type&lt;/em&gt; 은 &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;master&lt;/code&gt; , &lt;code&gt;slave&lt;/code&gt; 및 &lt;code&gt;pubsub&lt;/code&gt; 중 하나입니다 ( &lt;code&gt;master&lt;/code&gt; 유형은 v3.2에서 사용 가능함). 지정된 클래스 의 &lt;strong&gt;모든 클라이언트&lt;/strong&gt; 연결이 닫힙니다 . &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 명령 으로 차단 된 클라이언트 는 &lt;code&gt;normal&lt;/code&gt; 클래스 에 속하는 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e64a9e04cb696d74aa291a8da3de8594229ab57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CLIENT KILL USER username&lt;/code&gt;. Closes all the connections that are authenticated with the specified &lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;ACL&lt;/a&gt; username, however it returns an error if the username does not map to an existing ACL user.</source>
          <target state="translated">&lt;code&gt;CLIENT KILL USER username&lt;/code&gt; . 지정된 &lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;ACL&lt;/a&gt; 사용자 이름으로 인증 된 모든 연결을 닫지 만 사용자 이름이 기존 ACL 사용자에 매핑되지 않으면 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fef0710bd872cf9a625ed7b0d01b954d4f4b4278" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COPY&lt;/code&gt; -- Do not remove the key from the local instance.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; -로컬 인스턴스에서 키를 제거하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="828b06065edba3099f79eed73ccd5e091eb0282f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COPY&lt;/code&gt; and &lt;code&gt;REPLACE&lt;/code&gt; are available only in 3.0 and above. &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; is available starting with Redis 3.0.6.</source>
          <target state="translated">&lt;code&gt;COPY&lt;/code&gt; 와 &lt;code&gt;REPLACE&lt;/code&gt; 는 3.0 이상에서만 사용할 수 있습니다. &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; 는 Redis 3.0.6부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f62ca2831b2ba2e4a09d54fcced7c7ad2005546" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;DESC&lt;/code&gt;: Sort returned items from the farthest to the nearest, relative to the center.</source>
          <target state="translated">&lt;code&gt;DESC&lt;/code&gt; : 중심을 기준으로 가장 먼 곳에서 가장 가까운 곳으로 반품 된 항목을 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="2d6218812bbcf1c765cc87c431fb22bb0bce1f6e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;EX&lt;/code&gt;&lt;em&gt;seconds&lt;/em&gt; -- Set the specified expire time, in seconds.</source>
          <target state="translated">&lt;code&gt;EX&lt;/code&gt; &lt;em&gt;초&lt;/em&gt; -지정된 만료 시간을 초 단위로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b3d494972651313811f4ea2e6bc9a01e6a48e42f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FLUSHALL ASYNC&lt;/code&gt; (Redis 4.0.0 or greater)</source>
          <target state="translated">&lt;code&gt;FLUSHALL ASYNC&lt;/code&gt; (Redis 4.0.0 이상)</target>
        </trans-unit>
        <trans-unit id="399e38e4824210c8cdff06a324d4018a9eecea21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FLUSHDB ASYNC&lt;/code&gt; (Redis 4.0.0 or greater)</source>
          <target state="translated">&lt;code&gt;FLUSHDB ASYNC&lt;/code&gt; (Redis 4.0.0 이상)</target>
        </trans-unit>
        <trans-unit id="f9d2f7dec2da389f490ae42cc555c3ae4e347930" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FORCE&lt;/code&gt;: Creates the pending message entry in the PEL even if certain specified IDs are not already in the PEL assigned to a different client. However the message must be exist in the stream, otherwise the IDs of non existing messages are ignored.</source>
          <target state="translated">&lt;code&gt;FORCE&lt;/code&gt; : 지정된 특정 ID가 다른 클라이언트에 지정된 PEL에없는 경우에도 PEL에 보류중인 메시지 항목을 작성합니다. 그러나 메시지가 스트림에 존재해야합니다. 그렇지 않으면 기존 메시지가 아닌 메시지의 ID는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2e23863487a6f1e1378cb2786068b97f8360c522" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FROMLONLAT&lt;/code&gt;: Use the given &lt;code&gt;&amp;lt;longitude&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;latitude&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FROMLONLAT&lt;/code&gt; : 주어진 &lt;code&gt;&amp;lt;longitude&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;latitude&amp;gt;&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="0baa22a11a03f50b1ca5c9a732209609aba63e36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;FROMMEMBER&lt;/code&gt;: Use the position of the given existing &lt;code&gt;&amp;lt;member&amp;gt;&lt;/code&gt; in the sorted set.</source>
          <target state="translated">&lt;code&gt;FROMMEMBER&lt;/code&gt; : 정렬 된 집합에서 주어진 기존 &lt;code&gt;&amp;lt;member&amp;gt;&lt;/code&gt; 의 위치를 ​​사용합니다 .</target>
        </trans-unit>
        <trans-unit id="fef98736f61e1a786364eb654ce1fb11f47f4232" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IDLE &amp;lt;ms&amp;gt;&lt;/code&gt;: Set the idle time (last time it was delivered) of the message. If IDLE is not specified, an IDLE of 0 is assumed, that is, the time count is reset because the message has now a new owner trying to process it.</source>
          <target state="translated">&lt;code&gt;IDLE &amp;lt;ms&amp;gt;&lt;/code&gt; : 메시지의 유휴 시간 (마지막으로 배달 된 시간)을 설정합니다. IDLE을 지정하지 않으면 IDLE이 0으로 가정됩니다. 즉, 메시지를 처리하려고하는 새 소유자가 있으므로 시간 계수가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f02fe3441db92a399bf47bc889f6610d203389df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;IMPORTING&lt;/code&gt; subcommand: Set a hash slot in &lt;em&gt;importing&lt;/em&gt; state.</source>
          <target state="translated">&lt;code&gt;IMPORTING&lt;/code&gt; 부속 명령 : &lt;em&gt;가져 오기&lt;/em&gt; 상태 에서 해시 슬롯을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e12dd8507767dd78f37c7b15b7c53df7e1f55fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JUSTID&lt;/code&gt;: Return just an array of IDs of messages successfully claimed, without returning the actual message.</source>
          <target state="translated">&lt;code&gt;JUSTID&lt;/code&gt; : 실제 메시지를 반환하지 않고 성공적으로 청구 된 메시지의 ID 배열 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a620f0dc88712199e17b250a803b97a96125f1da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JUSTID&lt;/code&gt;: Return just an array of IDs of messages successfully claimed, without returning the actual message. Using this option means the retry counter is not incremented.</source>
          <target state="translated">&lt;code&gt;JUSTID&lt;/code&gt; : 실제 메시지를 반환하지 않고 성공적으로 요청 된 메시지의 ID 배열 만 반환합니다. 이 옵션을 사용하면 재시도 카운터가 증가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="703497b810844d3d5410af3e2c8faf26cae512df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;KEEPTTL&lt;/code&gt; -- Retain the time to live associated with the key.</source>
          <target state="translated">&lt;code&gt;KEEPTTL&lt;/code&gt; - 키와 관련된 수명을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="5417b35857fc0642ff95207d9855306db80441f5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MIGRATING&lt;/code&gt; subcommand: Set a hash slot in &lt;em&gt;migrating&lt;/em&gt; state.</source>
          <target state="translated">&lt;code&gt;MIGRATING&lt;/code&gt; 부속 명령 : 해시 슬롯을 &lt;em&gt;이주&lt;/em&gt; 상태로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="70764755b0a2c7ba46c7bf3843b05fe37082a3f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NO&lt;/code&gt;. Disables scripts debug mode.</source>
          <target state="translated">&lt;code&gt;NO&lt;/code&gt; . 스크립트 디버그 모드를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="514412efa136bf26067924d8e9e64aeaa793f898" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NODE&lt;/code&gt; subcommand: Bind the hash slot to a different node.</source>
          <target state="translated">&lt;code&gt;NODE&lt;/code&gt; 부속 명령 : 해시 슬롯을 다른 노드에 바인드하십시오.</target>
        </trans-unit>
        <trans-unit id="22139c723dca8a13892a3a0499960532b97c2112" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NOLOOP&lt;/code&gt;: don't send notifications about keys modified by this connection itself.</source>
          <target state="translated">&lt;code&gt;NOLOOP&lt;/code&gt; :이 연결 자체에 의해 수정 된 키에 대한 알림을 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd0e3ba7650821204046fdf9c4755dd7ba904ffc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;NX&lt;/code&gt; -- Only set the key if it does not already exist.</source>
          <target state="translated">&lt;code&gt;NX&lt;/code&gt; - 키가없는 경우에만 키를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="99882af89cf8e3e05714f50d2c0743b952d2d3c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OBJECT ENCODING &amp;lt;key&amp;gt;&lt;/code&gt; returns the kind of internal representation used in order to store the value associated with a key.</source>
          <target state="translated">&lt;code&gt;OBJECT ENCODING &amp;lt;key&amp;gt;&lt;/code&gt; 는 키와 관련된 값을 저장하는 데 사용되는 내부 표현 종류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ed8a8556a6d1374927ff1ce94213046f672ffd9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OBJECT FREQ &amp;lt;key&amp;gt;&lt;/code&gt; returns the logarithmic access frequency counter of the object stored at the specified key. This subcommand is available when &lt;code&gt;maxmemory-policy&lt;/code&gt; is set to an LFU policy.</source>
          <target state="translated">&lt;code&gt;OBJECT FREQ &amp;lt;key&amp;gt;&lt;/code&gt; 는 지정된 키에 저장된 객체의 로그 액세스 빈도 카운터를 반환합니다. &lt;code&gt;maxmemory-policy&lt;/code&gt; 가 LFU 정책으로 설정된 경우이 하위 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6c92d5715cc621ca2953155b63f6d1040b3820c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OBJECT HELP&lt;/code&gt; returns a succinct help text.</source>
          <target state="translated">&lt;code&gt;OBJECT HELP&lt;/code&gt; 는 간결한 도움말 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f3480c780052d6d5327144f1f0dc8cf03ca4c9a8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OBJECT HELP&lt;/code&gt; returns a succint help text.</source>
          <target state="translated">&lt;code&gt;OBJECT HELP&lt;/code&gt; 는 간결한 도움말 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2ebd6183929f50ff80b9af0e280a3646321f3699" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OBJECT IDLETIME &amp;lt;key&amp;gt;&lt;/code&gt; returns the number of seconds since the object stored at the specified key is idle (not requested by read or write operations). While the value is returned in seconds the actual resolution of this timer is 10 seconds, but may vary in future implementations. This subcommand is available when &lt;code&gt;maxmemory-policy&lt;/code&gt; is set to an LRU policy or &lt;code&gt;noeviction&lt;/code&gt; and &lt;code&gt;maxmemory&lt;/code&gt; is set.</source>
          <target state="translated">&lt;code&gt;OBJECT IDLETIME &amp;lt;key&amp;gt;&lt;/code&gt; 는 지정된 키에 저장된 개체가 유휴 상태 (읽기 또는 쓰기 작업에서 요청되지 않음) 이후의 시간 (초)을 반환합니다. 값은 초 단위로 반환되지만이 타이머의 실제 해상도는 10 초이지만 향후 구현에서는 달라질 수 있습니다. 때 하위 명령을 사용할 수 있습니다 &lt;code&gt;maxmemory-policy&lt;/code&gt; LRU 정책이나 설정되어 &lt;code&gt;noeviction&lt;/code&gt; 및 &lt;code&gt;maxmemory&lt;/code&gt; 이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="888f9bddf5ef83f498988c713f090f957d312a9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OBJECT IDLETIME &amp;lt;key&amp;gt;&lt;/code&gt; returns the number of seconds since the object stored at the specified key is idle (not requested by read or write operations). While the value is returned in seconds the actual resolution of this timer is 10 seconds, but may vary in future implementations. This subcommand is available when &lt;code&gt;maxmemory-policy&lt;/code&gt; is set to an LRU policy or &lt;code&gt;noeviction&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;OBJECT IDLETIME &amp;lt;key&amp;gt;&lt;/code&gt; 는 지정된 키에 저장된 객체가 유휴 상태 (초기 또는 쓰기 작업에 의해 요청되지 않음)이므로 초 수를 반환합니다. 값이 초 단위로 반환되는 동안이 타이머의 실제 해상도는 10 초이지만 향후 구현에 따라 다를 수 있습니다. &lt;code&gt;maxmemory-policy&lt;/code&gt; 가 LRU 정책 또는 &lt;code&gt;noeviction&lt;/code&gt; 으로 설정된 경우이 하위 명령을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc2fb84c1222faa39f7ea74dcd933f7cc2ace4ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OBJECT REFCOUNT &amp;lt;key&amp;gt;&lt;/code&gt; returns the number of references of the value associated with the specified key. This command is mainly useful for debugging.</source>
          <target state="translated">&lt;code&gt;OBJECT REFCOUNT &amp;lt;key&amp;gt;&lt;/code&gt; 는 지정된 키와 관련된 값의 참조 수를 반환합니다. 이 명령은 주로 디버깅에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a2453b4fb0091e83c1695ab282efa77025e36e17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OFF&lt;/code&gt;. In this mode the server will not reply to client commands.</source>
          <target state="translated">&lt;code&gt;OFF&lt;/code&gt; . 이 모드에서 서버는 클라이언트 명령에 응답하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee0e7c54a09f4affa491d8d7021f3854e2d54006" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ON&lt;/code&gt;. This is the default mode in which the server returns a reply to every command.</source>
          <target state="translated">&lt;code&gt;ON&lt;/code&gt; . 서버가 모든 명령에 대한 응답을 반환하는 기본 모드입니다.</target>
        </trans-unit>
        <trans-unit id="93d22bb36d8682b6c2e087826455c7270214d890" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OPTIN&lt;/code&gt;: when broadcasting is NOT active, normally don't track keys in read only commands, unless they are called immediately after a &lt;code&gt;CLIENT CACHING yes&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;OPTIN&lt;/code&gt; : 브로드 캐스팅이 활성화되지 않은 경우 일반적으로 &lt;code&gt;CLIENT CACHING yes&lt;/code&gt; 명령 직후에 호출되지 않는 한 읽기 전용 명령의 키를 추적하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="fe9812bf6fc63dca07899dad7daac170c6a78e22" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;OPTOUT&lt;/code&gt;: when broadcasting is NOT active, normally track keys in read only commands, unless they are called immediately after a &lt;code&gt;CLIENT CACHING no&lt;/code&gt; command.</source>
          <target state="translated">&lt;code&gt;OPTOUT&lt;/code&gt; : 브로드 캐스팅이 활성화되지 않은 경우 &lt;code&gt;CLIENT CACHING no&lt;/code&gt; 명령 직후에 호출되지 않는 한 일반적으로 읽기 전용 명령의 키를 추적합니다 .</target>
        </trans-unit>
        <trans-unit id="3dbbf2c08733248217445e964a4b0ceae7718aae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PREFIX &amp;lt;prefix&amp;gt;&lt;/code&gt;: for broadcasting, register a given key prefix, so that notifications will be provided only for keys starting with this string. This option can be given multiple times to register multiple prefixes. If broadcasting is enabled without this option, Redis will send notifications for every key.</source>
          <target state="translated">&lt;code&gt;PREFIX &amp;lt;prefix&amp;gt;&lt;/code&gt; : 브로드 캐스팅을 위해 주어진 키 접두사를 등록하여이 문자열로 시작하는 키에 대해서만 알림이 제공되도록합니다. 이 옵션은 여러 접두사를 등록하기 위해 여러 번 제공 될 수 있습니다. 이 옵션없이 브로드 캐스팅이 활성화 된 경우 Redis는 모든 키에 대해 알림을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a6629a2a7ab460a79b8e2163eeb985a87da0ddcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PX&lt;/code&gt;&lt;em&gt;milliseconds&lt;/em&gt; -- Set the specified expire time, in milliseconds.</source>
          <target state="translated">&lt;code&gt;PX&lt;/code&gt; &lt;em&gt;밀리 초&lt;/em&gt; -지정된 만료 시간을 밀리 초로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f0c43ea2a6c896f466d45f24e414d0e99761206b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REDIRECT &amp;lt;id&amp;gt;&lt;/code&gt;: send redirection messages to the connection with the specified ID. The connection must exist, you can get the ID of such connection using &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt;. If the connection we are redirecting to is terminated, when in RESP3 mode the connection with tracking enabled will receive &lt;code&gt;tracking-redir-broken&lt;/code&gt; push messages in order to signal the condition.</source>
          <target state="translated">&lt;code&gt;REDIRECT &amp;lt;id&amp;gt;&lt;/code&gt; : 지정된 ID의 연결로 리디렉션 메시지를 보냅니다. 연결이 존재해야하며 &lt;a href=&quot;client-id&quot;&gt;CLIENT ID를&lt;/a&gt; 사용하여 해당 연결의 ID를 얻을 수 있습니다 . 리디렉션하는 연결이 종료되면 RESP3 모드에서 추적이 활성화 된 연결은 상태를 알리기 위해 &lt;code&gt;tracking-redir-broken&lt;/code&gt; 재 디르 중단 푸시 메시지를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="80297e99327c2c150c0093cfc256780a8b53c387" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;REPLACE&lt;/code&gt; -- Replace existing key on the remote instance.</source>
          <target state="translated">&lt;code&gt;REPLACE&lt;/code&gt; - 원격 인스턴스에서 기존 키를 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="cc6115b3d47b177464bb118184086a7cc3fac61b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RETRYCOUNT &amp;lt;count&amp;gt;&lt;/code&gt;: Set the retry counter to the specified value. This counter is incremented every time a message is delivered again. Normally &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; does not alter this counter, which is just served to clients when the XPENDING command is called: this way clients can detect anomalies, like messages that are never processed for some reason after a big number of delivery attempts.</source>
          <target state="translated">&lt;code&gt;RETRYCOUNT &amp;lt;count&amp;gt;&lt;/code&gt; : 재시도 카운터를 지정된 값으로 설정하십시오. 이 카운터는 메시지가 다시 배달 될 때마다 증가합니다. 일반적으로 &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; 은 XPENDING 명령이 호출 될 때 클라이언트에게만 제공되는이 카운터를 변경하지 않습니다.이 방법으로 클라이언트는 많은 수의 배달 시도 후 어떤 이유로 처리되지 않은 메시지와 같은 예외를 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13ea1d19798d3a862a8b4db4f5e7da4813672d6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SETNAME &amp;lt;clientname&amp;gt;&lt;/code&gt;: this is equivalent to also call &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;SETNAME &amp;lt;clientname&amp;gt;&lt;/code&gt; : &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME을&lt;/a&gt; 호출하는 것과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="4ffbe13e1233b7e9c1174988bffadee0a3b98857" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SKIP&lt;/code&gt;. This mode skips the reply of command immediately after it.</source>
          <target state="translated">&lt;code&gt;SKIP&lt;/code&gt; . 이 모드는 명령 직후에 응답을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="f1ff247a0db526f7a11f6f1afcd40dcb67292ccf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;STABLE&lt;/code&gt; subcommand: Clear any importing / migrating state from hash slot.</source>
          <target state="translated">&lt;code&gt;STABLE&lt;/code&gt; 부속 명령 : 해시 슬롯에서 가져 오기 / 마이그레이션 상태를 지우십시오.</target>
        </trans-unit>
        <trans-unit id="22c4aa93098e2f4e9012509dce54747bfaf40373" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;STORE&lt;/code&gt;: Store the items in a sorted set populated with their geospatial information.</source>
          <target state="translated">&lt;code&gt;STORE&lt;/code&gt; : 지리 공간 정보로 채워진 정렬 된 세트에 항목을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="6dd2a610ee73ee9b633d0ee8607cd95468e5e519" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;STOREDIST&lt;/code&gt;: Store the items in a sorted set populated with their distance from the center as a floating point number, in the same unit specified in the radius.</source>
          <target state="translated">&lt;code&gt;STOREDIST&lt;/code&gt; : 반경에 지정된 동일한 단위로 중심으로부터의 거리가 부동 소수점 숫자로 채워진 정렬 된 집합에 항목을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="3368cd450f9f6cc2baea198c405095f6d0a009a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;TIME &amp;lt;ms-unix-time&amp;gt;&lt;/code&gt;: This is the same as IDLE but instead of a relative amount of milliseconds, it sets the idle time to a specific Unix time (in milliseconds). This is useful in order to rewrite the AOF file generating &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; commands.</source>
          <target state="translated">&lt;code&gt;TIME &amp;lt;ms-unix-time&amp;gt;&lt;/code&gt; : IDLE과 동일하지만 상대적인 밀리 초 대신 유휴 시간을 특정 유닉스 시간 (밀리 초)으로 설정합니다. &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; 명령을 생성하는 AOF 파일을 다시 작성하는 데 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="02d0547e91cdcd2f25342f4d6bb7cf4157a2111c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WITHCOORD&lt;/code&gt;: Also return the longitude and latitude of the matching items.</source>
          <target state="translated">&lt;code&gt;WITHCOORD&lt;/code&gt; : 일치하는 항목의 경도와 위도도 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f68fc34e1d6f2a26a1a2c15ca15742080415f576" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WITHCOORD&lt;/code&gt;: Also return the longitude,latitude coordinates of the matching items.</source>
          <target state="translated">&lt;code&gt;WITHCOORD&lt;/code&gt; : 일치하는 항목의 경도, 위도 좌표를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f946903450488324f8831b407ef63f52beb38d66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WITHDIST&lt;/code&gt;: Also return the distance of the returned items from the specified center. The distance is returned in the same unit as specified for the radius or height and width arguments.</source>
          <target state="translated">&lt;code&gt;WITHDIST&lt;/code&gt; : 지정된 중심에서 반환 된 항목까지의 거리도 반환합니다. 거리는 반경 또는 높이 및 너비 인수에 지정된 것과 동일한 단위로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="72e1da1bf7742af54c060cdc9d133362fecb89c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WITHDIST&lt;/code&gt;: Also return the distance of the returned items from the specified center. The distance is returned in the same unit as the unit specified as the radius argument of the command.</source>
          <target state="translated">&lt;code&gt;WITHDIST&lt;/code&gt; : 반환 된 품목의 거리를 지정된 중심에서 반환합니다. 거리는 명령의 반경 인수로 지정된 단위와 동일한 단위로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="33ca4bb6415c9fb0f6b1095fd636200907df4c73" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;WITHHASH&lt;/code&gt;: Also return the raw geohash-encoded sorted set score of the item, in the form of a 52 bit unsigned integer. This is only useful for low level hacks or debugging and is otherwise of little interest for the general user.</source>
          <target state="translated">&lt;code&gt;WITHHASH&lt;/code&gt; : 또한 항목의 원시 지오 해시 인코딩 정렬 집합 점수를 부호없는 52 비트 정수 형식으로 반환합니다. 이것은 낮은 수준의 해킹이나 디버깅에만 유용하며 일반 사용자에게는 거의 관심이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a83721d6bd94ce6aaf576b5f05c13b2637597325" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;XX&lt;/code&gt; -- Only set the key if it already exist.</source>
          <target state="translated">&lt;code&gt;XX&lt;/code&gt; - 키가 이미있는 경우에만 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="e079471709a901605c3eb58f108833d504b6b11e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;YES&lt;/code&gt;. Enable non-blocking asynchronous debugging of Lua scripts (changes are discarded).</source>
          <target state="translated">&lt;code&gt;YES&lt;/code&gt; . Lua 스크립트의 비 차단 비동기 디버깅을 활성화합니다 (변경 사항은 무시 됨).</target>
        </trans-unit>
        <trans-unit id="a22f353861e10e014106fd90471171473f27d38b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;active_defrag_hits&lt;/code&gt;: Number of value reallocations performed by active the defragmentation process</source>
          <target state="translated">&lt;code&gt;active_defrag_hits&lt;/code&gt; : 조각 모음 프로세스를 활성화하여 수행 한 값 재 할당 수</target>
        </trans-unit>
        <trans-unit id="7fdfcb3c13a7acba7f324056f0c4b7810d7f027b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;active_defrag_key_hits&lt;/code&gt;: Number of keys that were actively defragmented</source>
          <target state="translated">&lt;code&gt;active_defrag_key_hits&lt;/code&gt; : 적극적으로 조각 모음 된 키 수</target>
        </trans-unit>
        <trans-unit id="f86b40e0f88f935634beee0a4d5b5a33fef34db9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;active_defrag_key_misses&lt;/code&gt;: Number of keys that were skipped by the active defragmentation process</source>
          <target state="translated">&lt;code&gt;active_defrag_key_misses&lt;/code&gt; : 활성 조각 모음 프로세스에서 건너 뛴 키 수</target>
        </trans-unit>
        <trans-unit id="10ba93594ceb8bd562cba3fffdd70835558dc8af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;active_defrag_misses&lt;/code&gt;: Number of aborted value reallocations started by the active defragmentation process</source>
          <target state="translated">&lt;code&gt;active_defrag_misses&lt;/code&gt; : 활성 조각 모음 프로세스에 의해 시작된 중단 된 값 재 할당 수</target>
        </trans-unit>
        <trans-unit id="4f522f6f70a7ce761d1960901b0078ee984f4d7a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;active_defrag_running&lt;/code&gt;: Flag indicating if active defragmentation is active</source>
          <target state="translated">&lt;code&gt;active_defrag_running&lt;/code&gt; : 활성 조각 모음이 활성화되어 있는지를 나타내는 플래그</target>
        </trans-unit>
        <trans-unit id="32a776559f2ca409db7316c86f8021c0bd6163b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;addr&lt;/code&gt;: address/port of the client</source>
          <target state="translated">&lt;code&gt;addr&lt;/code&gt; : 클라이언트의 주소 / 포트</target>
        </trans-unit>
        <trans-unit id="0b418934c029a0535c7714965414f4d0cd7d9794" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;age&lt;/code&gt;: total duration of the connection in seconds</source>
          <target state="translated">&lt;code&gt;age&lt;/code&gt; : 연결의 총 지속 시간 (초)</target>
        </trans-unit>
        <trans-unit id="cd018df00bb4d052d465c766526aefcac8623f09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;all&lt;/code&gt;: Return all sections</source>
          <target state="translated">&lt;code&gt;all&lt;/code&gt; : 모든 섹션을 반환</target>
        </trans-unit>
        <trans-unit id="aa9ab796500ad0d3b0ba45503930390c147335b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;all&lt;/code&gt;: Return all sections (excluding module generated ones)</source>
          <target state="translated">&lt;code&gt;all&lt;/code&gt; : 모든 섹션을 반환합니다 (모듈 생성 섹션 제외).</target>
        </trans-unit>
        <trans-unit id="2c90da4abd839ecb47d97be4f5c0afab42b83242" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;allchannels&lt;/code&gt;: alias for &lt;code&gt;&amp;amp;*&lt;/code&gt;, it allows the user to access all Pub/Sub channels.</source>
          <target state="translated">&lt;code&gt;allchannels&lt;/code&gt; : 별칭 &lt;code&gt;&amp;amp;*&lt;/code&gt; , 사용자가 모든 Pub / Sub 채널에 액세스 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="6f6fd3b59ba484d4661d5ed4441f5e33e41f5630" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;allcommands&lt;/code&gt;: alias of &lt;code&gt;+@all&lt;/code&gt;. Adds all the commands there are in the server, including &lt;em&gt;future commands&lt;/em&gt; loaded via module, to be executed by this user.</source>
          <target state="translated">&lt;code&gt;allcommands&lt;/code&gt; : 별칭 &lt;code&gt;+@all&lt;/code&gt; . 이 사용자가 실행할 모듈을 통해로드 된 &lt;em&gt;향후 명령을&lt;/em&gt; 포함하여 서버에있는 모든 명령을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="e3ec1b8e0e3dadefc8c35aa0424a28712bf48508" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;allkeys&lt;/code&gt;: alias for &lt;code&gt;~*&lt;/code&gt;, it allows the user to access all the keys.</source>
          <target state="translated">&lt;code&gt;allkeys&lt;/code&gt; : &lt;code&gt;~*&lt;/code&gt; 별칭 , 사용자가 모든 키에 액세스 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="edddb993a22213f8ae5d530d19608128b3d90819" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof.buffer&lt;/code&gt;: The summed size in bytes of the current and rewrite AOF buffers (see &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;'s &lt;code&gt;aof_buffer_length&lt;/code&gt; and &lt;code&gt;aof_rewrite_buffer_length&lt;/code&gt;, respectively)</source>
          <target state="translated">&lt;code&gt;aof.buffer&lt;/code&gt; : 현재 및 재 작성 AOF 버퍼의 합계 크기 (바이트) ( 각각 &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 의 &lt;code&gt;aof_buffer_length&lt;/code&gt; 및 &lt;code&gt;aof_rewrite_buffer_length&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="1ff4db2d3af80e789a0995ce723660c4de7d6f05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_base_size&lt;/code&gt;: AOF file size on latest startup or rewrite</source>
          <target state="translated">&lt;code&gt;aof_base_size&lt;/code&gt; : 최신 시작 또는 다시 쓰기시 AOF 파일 크기</target>
        </trans-unit>
        <trans-unit id="8632791e26fdcef3f4a9f344241b92f2afc74dd7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_buffer_length&lt;/code&gt;: Size of the AOF buffer</source>
          <target state="translated">&lt;code&gt;aof_buffer_length&lt;/code&gt; : AOF 버퍼의 크기</target>
        </trans-unit>
        <trans-unit id="97014e76a8ce9b991e26a3100de786bbc394c893" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_current_rewrite_time_sec&lt;/code&gt;: Duration of the on-going AOF rewrite operation if any</source>
          <target state="translated">&lt;code&gt;aof_current_rewrite_time_sec&lt;/code&gt; : 진행중인 AOF 다시 쓰기 작업이있는 경우 지속 기간</target>
        </trans-unit>
        <trans-unit id="ac32c8b2ccb90d460c7b5861f1d179abec9ee8da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_current_size&lt;/code&gt;: AOF current file size</source>
          <target state="translated">&lt;code&gt;aof_current_size&lt;/code&gt; : AOF 현재 파일 크기</target>
        </trans-unit>
        <trans-unit id="021a62752235de2b7c632ebf2af7a48fa5178011" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_delayed_fsync&lt;/code&gt;: Delayed fsync counter</source>
          <target state="translated">&lt;code&gt;aof_delayed_fsync&lt;/code&gt; : 지연된 fsync 카운터</target>
        </trans-unit>
        <trans-unit id="24fd6a9ea8f45fb36a9eeb7c56056061cbe44e14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_enabled&lt;/code&gt;: Flag indicating AOF logging is activated</source>
          <target state="translated">&lt;code&gt;aof_enabled&lt;/code&gt; : AOF 로깅이 활성화되었음을 나타내는 플래그</target>
        </trans-unit>
        <trans-unit id="1e6a012770c4c4c182917c7ed5289c5f531614fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_last_bgrewrite_status&lt;/code&gt;: Status of the last AOF rewrite operation</source>
          <target state="translated">&lt;code&gt;aof_last_bgrewrite_status&lt;/code&gt; : 마지막 AOF 다시 쓰기 작업의 상태</target>
        </trans-unit>
        <trans-unit id="fb606e1eef2327d509f09e01f9add96e415822d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_last_cow_size&lt;/code&gt;: The size in bytes of copy-on-write allocations during the last AOF rewrite operation</source>
          <target state="translated">&lt;code&gt;aof_last_cow_size&lt;/code&gt; : 마지막 AOF 다시 쓰기 작업 중 쓰기시 복사 할당의 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="a5d5e6a33c8ed12d83cca0b06fbee5244ee6ba41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_last_rewrite_time_sec&lt;/code&gt;: Duration of the last AOF rewrite operation in seconds</source>
          <target state="translated">&lt;code&gt;aof_last_rewrite_time_sec&lt;/code&gt; : 마지막 AOF 다시 쓰기 작업의 지속 시간 (초)</target>
        </trans-unit>
        <trans-unit id="c1db165470a23cb6ec719da8932a40f4ea09ab81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_last_write_status&lt;/code&gt;: Status of the last write operation to the AOF</source>
          <target state="translated">&lt;code&gt;aof_last_write_status&lt;/code&gt; : AOF에 대한 마지막 쓰기 작업의 상태</target>
        </trans-unit>
        <trans-unit id="cba340ede5eb173bc4558c50d221e3ab3a1765c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_pending_bio_fsync&lt;/code&gt;: Number of fsync pending jobs in background I/O queue</source>
          <target state="translated">&lt;code&gt;aof_pending_bio_fsync&lt;/code&gt; : 백그라운드 I / O 대기열에있는 fsync 보류 작업 수</target>
        </trans-unit>
        <trans-unit id="49f338748e7ef39a92b2e18297472c8ebf2461ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_pending_rewrite&lt;/code&gt;: Flag indicating an AOF rewrite operation will be scheduled once the on-going RDB save is complete.</source>
          <target state="translated">&lt;code&gt;aof_pending_rewrite&lt;/code&gt; : 진행중인 RDB 저장이 완료되면 AOF 다시 쓰기 작업을 나타내는 플래그가 예약됩니다.</target>
        </trans-unit>
        <trans-unit id="4b10e1836e92feeff66d3326e4c2d7f1bf8909b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_rewrite_buffer_length&lt;/code&gt;: Size of the AOF rewrite buffer</source>
          <target state="translated">&lt;code&gt;aof_rewrite_buffer_length&lt;/code&gt; : AOF 다시 쓰기 버퍼의 크기</target>
        </trans-unit>
        <trans-unit id="90ad968000b75b18f076c4d369ff364d5516d20d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_rewrite_in_progress&lt;/code&gt;: Flag indicating a AOF rewrite operation is on-going</source>
          <target state="translated">&lt;code&gt;aof_rewrite_in_progress&lt;/code&gt; : AOF 다시 쓰기 작업이 진행 중임을 나타내는 플래그</target>
        </trans-unit>
        <trans-unit id="860eb37aa85d675719b691b7665a36bac01eb96f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;aof_rewrite_scheduled&lt;/code&gt;: Flag indicating an AOF rewrite operation will be scheduled once the on-going RDB save is complete.</source>
          <target state="translated">&lt;code&gt;aof_rewrite_scheduled&lt;/code&gt; : 진행중인 RDB 저장이 완료되면 AOF 다시 쓰기 작업을 나타내는 플래그가 예약됩니다.</target>
        </trans-unit>
        <trans-unit id="8b6b438717bec11dfc97f6d4213c363347e98d05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;arch_bits&lt;/code&gt;: Architecture (32 or 64 bits)</source>
          <target state="translated">&lt;code&gt;arch_bits&lt;/code&gt; : 아키텍처 (32 또는 64 비트)</target>
        </trans-unit>
        <trans-unit id="de61b3dd6c6c85f4d89184c6aceeac1115fe7e82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;argv-mem&lt;/code&gt;: incomplete arguments for the next command (already extracted from query buffer)</source>
          <target state="translated">&lt;code&gt;argv-mem&lt;/code&gt; : 다음 명령에 대한 불완전한 인수 (이미 쿼리 버퍼에서 추출 됨)</target>
        </trans-unit>
        <trans-unit id="9c55751797332d8d9b526a675ac4969063b50b6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;atomicvar_api&lt;/code&gt;: Atomicvar API used by Redis</source>
          <target state="translated">&lt;code&gt;atomicvar_api&lt;/code&gt; : Redis에서 사용하는 Atomicvar API</target>
        </trans-unit>
        <trans-unit id="b0f927aba00ccf6192ec1758a98f6c0004f29e02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;base&lt;/code&gt; lib.</source>
          <target state="translated">&lt;code&gt;base&lt;/code&gt; lib.</target>
        </trans-unit>
        <trans-unit id="666a2695cf4298e987e3316285fbfcc244e56848" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bcast&lt;/code&gt;: The client uses broadcasting mode.</source>
          <target state="translated">&lt;code&gt;bcast&lt;/code&gt; : 클라이언트가 브로드 캐스팅 모드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e0921bad9f229a9389c2e38e52f6a7f7b765b5aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;bitop&lt;/code&gt; lib.</source>
          <target state="translated">&lt;code&gt;bitop&lt;/code&gt; lib.</target>
        </trans-unit>
        <trans-unit id="63296e3f0c1fbb23ccca811926c200a7dd0df548" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;blocked_clients&lt;/code&gt;: Number of clients pending on a blocking call (&lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt;, &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt;, &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;, &lt;a href=&quot;blmove&quot;&gt;BLMOVE&lt;/a&gt;, &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt;, &lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;blocked_clients&lt;/code&gt; : 차단 호출에 보류중인 클라이언트 수 ( &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; , &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; , &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; , &lt;a href=&quot;blmove&quot;&gt;BLMOVE&lt;/a&gt; , &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; , &lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="0a1dd8d1355938beb39d0e1c2d0f73196261de7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;blocked_clients&lt;/code&gt;: Number of clients pending on a blocking call (BLPOP, BRPOP, BRPOPLPUSH)</source>
          <target state="translated">&lt;code&gt;blocked_clients&lt;/code&gt; : 차단 호출을 보류중인 클라이언트 수 (BLPOP, BRPOP, BRPOPLPUSH)</target>
        </trans-unit>
        <trans-unit id="bcb07e2a295cc75aa5a4558a7b7dac249c9be34c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;broken_redirect&lt;/code&gt;: The client ID used for redirection isn't valid anymore.</source>
          <target state="translated">&lt;code&gt;broken_redirect&lt;/code&gt; : 리디렉션에 사용 된 클라이언트 ID가 더 이상 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0568e8e24ee465f3defc197d2909c4cd2a3fe3d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;caching-no&lt;/code&gt;: The next command won't cache keys (exists only together with &lt;code&gt;optout&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;caching-no&lt;/code&gt; : 다음 명령은 키를 캐시하지 않습니다 ( &lt;code&gt;optout&lt;/code&gt; 과 함께 만 존재 함 ).</target>
        </trans-unit>
        <trans-unit id="b75f04c9bf76d4288aa6e6868f6bdeb65e670518" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;caching-yes&lt;/code&gt;: The next command will cache keys (exists only together with &lt;code&gt;optin&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;caching-yes&lt;/code&gt; : 다음 명령은 키를 캐시합니다 ( &lt;code&gt;optin&lt;/code&gt; 과 함께 만 존재 함 ).</target>
        </trans-unit>
        <trans-unit id="24c0bfc56b5937facd337558991cae6163c0423d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;changes_since_last_save&lt;/code&gt; refers to the number of operations that produced some kind of changes in the dataset since the last time either &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; or &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; was called.</source>
          <target state="translated">&lt;code&gt;changes_since_last_save&lt;/code&gt; 는 마지막으로 &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; 또는 &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; 가 호출 된 이후 데이터 집합에서 어떤 종류의 변경을 생성 한 작업 수를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="eaf245ee0eff16f73b8a1a316441d2b1ea91df09" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cjson&lt;/code&gt; lib.</source>
          <target state="translated">&lt;code&gt;cjson&lt;/code&gt; lib.</target>
        </trans-unit>
        <trans-unit id="f9f056eda18d9bc00dbfc7310df95503a7425a2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;client_biggest_input_buf&lt;/code&gt;: Biggest input buffer among current client connections</source>
          <target state="translated">&lt;code&gt;client_biggest_input_buf&lt;/code&gt; : 현재 클라이언트 연결 중 가장 큰 입력 버퍼</target>
        </trans-unit>
        <trans-unit id="c2392a37aedbf270d6b854bc28fc404b287a29ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;client_biggest_input_buf&lt;/code&gt;: biggest input buffer among current client connections</source>
          <target state="translated">&lt;code&gt;client_biggest_input_buf&lt;/code&gt; : 현재 클라이언트 연결 중 가장 큰 입력 버퍼</target>
        </trans-unit>
        <trans-unit id="f0665e8241ec2d142520c43c49fa010d1acc9c9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;client_longest_output_list&lt;/code&gt;: Longest output list among current client connections</source>
          <target state="translated">&lt;code&gt;client_longest_output_list&lt;/code&gt; : 현재 클라이언트 연결 중 가장 긴 출력 목록</target>
        </trans-unit>
        <trans-unit id="9fb7b84362378176af7de8594d03749190b46118" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;client_longest_output_list&lt;/code&gt;: longest output list among current client connections</source>
          <target state="translated">&lt;code&gt;client_longest_output_list&lt;/code&gt; : 현재 클라이언트 연결 중 가장 긴 출력 목록</target>
        </trans-unit>
        <trans-unit id="ee177459def1e80b39c47454b8c28a9d42a4106c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clients.normal&lt;/code&gt;: The total size in bytes of all clients overheads (output and query buffers, connection contexts)</source>
          <target state="translated">&lt;code&gt;clients.normal&lt;/code&gt; : 모든 클라이언트 오버 헤드 (출력 및 쿼리 버퍼, 연결 컨텍스트)의 총 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="7500227d42c34ddbac3bf8fe32d560635e9a67a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clients.slaves&lt;/code&gt;: The total size in bytes of all replicas overheads (output and query buffers, connection contexts)</source>
          <target state="translated">&lt;code&gt;clients.slaves&lt;/code&gt; : 모든 복제본 오버 헤드 (출력 및 쿼리 버퍼, 연결 컨텍스트)의 총 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="fc0bb101210ccd0cc4d7b0798c1678cd18cb6bc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clients&lt;/code&gt;: Client connections section</source>
          <target state="translated">&lt;code&gt;clients&lt;/code&gt; : 클라이언트 연결 섹션</target>
        </trans-unit>
        <trans-unit id="7e7817b93be1b11027d13683fa34fc6efffb668d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;clients_in_timeout_table&lt;/code&gt;: Number of clients in the clients timeout table</source>
          <target state="translated">&lt;code&gt;clients_in_timeout_table&lt;/code&gt; : 클라이언트 제한 시간 테이블의 클라이언트 수</target>
        </trans-unit>
        <trans-unit id="4cb155c6866c785f784b7fdb3af57862475d4bb2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster&lt;/code&gt;: Redis Cluster section</source>
          <target state="translated">&lt;code&gt;cluster&lt;/code&gt; : Redis 클러스터 섹션</target>
        </trans-unit>
        <trans-unit id="8378293297e29944fc372120efa594accf2315ae" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_connections&lt;/code&gt;: An approximation of the number of sockets used by the cluster's bus</source>
          <target state="translated">&lt;code&gt;cluster_connections&lt;/code&gt; : 클러스터의 버스가 사용하는 소켓 수의 근사치</target>
        </trans-unit>
        <trans-unit id="3d26c683ca3ca4ce60da0b69dd830079349a61d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_current_epoch&lt;/code&gt;: The local &lt;code&gt;Current Epoch&lt;/code&gt; variable. This is used in order to create unique increasing version numbers during fail overs.</source>
          <target state="translated">&lt;code&gt;cluster_current_epoch&lt;/code&gt; : 로컬 &lt;code&gt;Current Epoch&lt;/code&gt; 변수. 장애 조치 동안 고유 한 증가 버전 번호를 작성하기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="70851ccf8dd13c98bda748f4a9d9fbe7bd0bd627" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_enabled&lt;/code&gt;: Indicate Redis cluster is enabled</source>
          <target state="translated">&lt;code&gt;cluster_enabled&lt;/code&gt; : Redis 클러스터가 활성화되었음을 나타냅니다</target>
        </trans-unit>
        <trans-unit id="7c146d936ab811cc708f993ded474e0edc533322" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_known_nodes&lt;/code&gt;: The total number of known nodes in the cluster, including nodes in &lt;code&gt;HANDSHAKE&lt;/code&gt; state that may not currently be proper members of the cluster.</source>
          <target state="translated">&lt;code&gt;cluster_known_nodes&lt;/code&gt; : 현재 클러스터의 적절한 구성원이 아닐 수 있는 &lt;code&gt;HANDSHAKE&lt;/code&gt; 상태의 노드를 포함하여 클러스터에 알려진 총 노드 수입니다 .</target>
        </trans-unit>
        <trans-unit id="5874cd9f6f0e68dfeae4ccb58cfe7c53dd1c21ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_my_epoch&lt;/code&gt;: The &lt;code&gt;Config Epoch&lt;/code&gt; of the node we are talking with. This is the current configuration version assigned to this node.</source>
          <target state="translated">&lt;code&gt;cluster_my_epoch&lt;/code&gt; : 우리가 대화하고있는 노드 의 &lt;code&gt;Config Epoch&lt;/code&gt; . 이 노드에 지정된 현재 구성 버전입니다.</target>
        </trans-unit>
        <trans-unit id="52095d5a5d032e4fa63b850e6af56cbcfc64296f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_size&lt;/code&gt;: The number of master nodes serving at least one hash slot in the cluster.</source>
          <target state="translated">&lt;code&gt;cluster_size&lt;/code&gt; : 클러스터에서 하나 이상의 해시 슬롯을 제공하는 마스터 노드 수입니다.</target>
        </trans-unit>
        <trans-unit id="29695410813fb33d64aa2bf6c11ffbee6c1a2a97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_slots_assigned&lt;/code&gt;: Number of slots which are associated to some node (not unbound). This number should be 16384 for the node to work properly, which means that each hash slot should be mapped to a node.</source>
          <target state="translated">&lt;code&gt;cluster_slots_assigned&lt;/code&gt; : 일부 노드와 연관된 슬롯 수입니다 (바인드되지 않음). 노드가 올바르게 작동하려면이 숫자는 16384 여야합니다. 즉, 각 해시 슬롯이 노드에 맵핑되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6d0d7b50bc4f71b67fdfc41ee1614343e3c04545" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_slots_fail&lt;/code&gt;: Number of hash slots mapping to a node in &lt;code&gt;FAIL&lt;/code&gt; state. If this number is not zero the node is not able to serve queries unless &lt;code&gt;cluster-require-full-coverage&lt;/code&gt; is set to &lt;code&gt;no&lt;/code&gt; in the configuration.</source>
          <target state="translated">&lt;code&gt;cluster_slots_fail&lt;/code&gt; : &lt;code&gt;FAIL&lt;/code&gt; 상태 의 노드에 매핑되는 해시 슬롯 수입니다 . 이 숫자가 0이 아니면 구성에서 &lt;code&gt;cluster-require-full-coverage&lt;/code&gt; 가 &lt;code&gt;no&lt;/code&gt; 로 설정되어 있지 않으면 노드가 쿼리를 제공 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="15f48639dc5fdfa9a8fdcaacb4a0ed8c20c6a278" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_slots_ok&lt;/code&gt;: Number of hash slots mapping to a node not in &lt;code&gt;FAIL&lt;/code&gt; or &lt;code&gt;PFAIL&lt;/code&gt; state.</source>
          <target state="translated">&lt;code&gt;cluster_slots_ok&lt;/code&gt; : &lt;code&gt;FAIL&lt;/code&gt; 또는 &lt;code&gt;PFAIL&lt;/code&gt; 상태가 아닌 노드에 매핑되는 해시 슬롯 수입니다 .</target>
        </trans-unit>
        <trans-unit id="544cc9f0a6d42991bcd32498d341a3f39d2598e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_slots_pfail&lt;/code&gt;: Number of hash slots mapping to a node in &lt;code&gt;PFAIL&lt;/code&gt; state. Note that those hash slots still work correctly, as long as the &lt;code&gt;PFAIL&lt;/code&gt; state is not promoted to &lt;code&gt;FAIL&lt;/code&gt; by the failure detection algorithm. &lt;code&gt;PFAIL&lt;/code&gt; only means that we are currently not able to talk with the node, but may be just a transient error.</source>
          <target state="translated">&lt;code&gt;cluster_slots_pfail&lt;/code&gt; : &lt;code&gt;PFAIL&lt;/code&gt; 상태 의 노드에 매핑되는 해시 슬롯 수입니다 . &lt;code&gt;PFAIL&lt;/code&gt; 상태가 실패 감지 알고리즘에 의해 &lt;code&gt;FAIL&lt;/code&gt; 로 승격되지 않는 한 이러한 해시 슬롯은 여전히 ​​올바르게 작동합니다 . &lt;code&gt;PFAIL&lt;/code&gt; 은 현재 노드와 통신 할 수 없지만 일시적인 오류 일 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="81a4d3335de82f0227443fdb6b88a83036adf46b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_state&lt;/code&gt;: State is &lt;code&gt;ok&lt;/code&gt; if the node is able to receive queries. &lt;code&gt;fail&lt;/code&gt; if there is at least one hash slot which is unbound (no node associated), in error state (node serving it is flagged with FAIL flag), or if the majority of masters can't be reached by this node.</source>
          <target state="translated">&lt;code&gt;cluster_state&lt;/code&gt; : 노드가 쿼리를 수신 할 수있는 경우 상태는 &lt;code&gt;ok&lt;/code&gt; 입니다. &lt;code&gt;fail&lt;/code&gt; (노드는 FAIL 플래그 네요 서빙) 오류 상태 (어떤 노드가 관련 없음) 비 결합을 갖는 적어도 하나 개의 해시 슬롯이있는 경우, 또는 마스터의 대부분이 노드가 도달 할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="9d84e9f158cef927bb08b9136f31b0e94588ce30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_stats_messages_received&lt;/code&gt;: Number of messages received via the cluster node-to-node binary bus.</source>
          <target state="translated">&lt;code&gt;cluster_stats_messages_received&lt;/code&gt; : 클러스터 노드 간 이진 버스를 통해 수신 된 메시지 수.</target>
        </trans-unit>
        <trans-unit id="1d71cc79a3ac3f1f764845f93c6328f871b79130" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cluster_stats_messages_sent&lt;/code&gt;: Number of messages sent via the cluster node-to-node binary bus.</source>
          <target state="translated">&lt;code&gt;cluster_stats_messages_sent&lt;/code&gt; : 클러스터 노드 간 이진 버스를 통해 전송 된 메시지 수.</target>
        </trans-unit>
        <trans-unit id="ee24d8988678d8582b8f6dab777e971152f05558" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmd&lt;/code&gt;: last command played</source>
          <target state="translated">&lt;code&gt;cmd&lt;/code&gt; : 마지막 명령</target>
        </trans-unit>
        <trans-unit id="a709f985301e19713f2f08223d89f4f8eea4b37a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmdstat_XXX&lt;/code&gt;: &lt;code&gt;calls=XXX,usec=XXX,usec_per_call=XXX&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;cmdstat_XXX&lt;/code&gt; : &lt;code&gt;calls=XXX,usec=XXX,usec_per_call=XXX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="07111613af5fe8282dd6060ded0e6a723e3b5d02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cmsgpack&lt;/code&gt; lib.</source>
          <target state="translated">&lt;code&gt;cmsgpack&lt;/code&gt; lib.</target>
        </trans-unit>
        <trans-unit id="ae19fbcc7be38e64198a2ac984cfc96421cd38f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;commandstats&lt;/code&gt;: Redis command statistics</source>
          <target state="translated">&lt;code&gt;commandstats&lt;/code&gt; : Redis 명령 통계</target>
        </trans-unit>
        <trans-unit id="2e2aec4f159efd5319b9ac9e46f9366aa72ebdb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config-epoch&lt;/code&gt;: The configuration epoch (or version) of the current node (or of the current master if the node is a replica). Each time there is a failover, a new, unique, monotonically increasing configuration epoch is created. If multiple nodes claim to serve the same hash slots, the one with higher configuration epoch wins.</source>
          <target state="translated">&lt;code&gt;config-epoch&lt;/code&gt; : 현재 노드 (또는 노드가 복제 본인 경우 현재 마스터)의 구성 에포크 (또는 버전)입니다. 장애 조치가있을 때마다 단조 증가하는 새롭고 독창적 인 구성 에포크가 생성됩니다. 여러 노드가 동일한 해시 슬롯을 제공한다고 주장하면 구성 시대가 더 높은 노드가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="d6cf11fe66e5db4592e7887d282a6081f905f74a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;config_file&lt;/code&gt;: The path to the config file</source>
          <target state="translated">&lt;code&gt;config_file&lt;/code&gt; : 구성 파일의 경로</target>
        </trans-unit>
        <trans-unit id="ab3873ea41080a2e04cdaeb106aa6229bc655a31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configured_hz&lt;/code&gt;: The server's configured frequency setting</source>
          <target state="translated">&lt;code&gt;configured_hz&lt;/code&gt; : 서버의 구성된 주파수 설정</target>
        </trans-unit>
        <trans-unit id="5bd1609e184b7224682e9575d08c34e0207cdcfc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connected_clients&lt;/code&gt;: Number of client connections (excluding connections from replicas)</source>
          <target state="translated">&lt;code&gt;connected_clients&lt;/code&gt; : 클라이언트 연결 수 (복제본에서 연결 제외)</target>
        </trans-unit>
        <trans-unit id="7141ff50a3ecae86240ef375bf2a477b7bc9fc9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connected_slaves&lt;/code&gt;: Number of connected replicas</source>
          <target state="translated">&lt;code&gt;connected_slaves&lt;/code&gt; : 연결된 복제본 수</target>
        </trans-unit>
        <trans-unit id="f0c7bb8d57eab8c3c5d0e48cc57c3f859bd8790b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count &amp;gt; 0&lt;/code&gt;: Remove elements equal to &lt;code&gt;element&lt;/code&gt; moving from head to tail.</source>
          <target state="translated">&lt;code&gt;count &amp;gt; 0&lt;/code&gt; : 제거 요소는 동일한 &lt;code&gt;element&lt;/code&gt; 선두로부터 말미의 이동.</target>
        </trans-unit>
        <trans-unit id="3b1ff8869c8e738a4466372a8c8bf1e9bf4283a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count &amp;gt; 0&lt;/code&gt;: Remove elements equal to &lt;code&gt;value&lt;/code&gt; moving from head to tail.</source>
          <target state="translated">&lt;code&gt;count &amp;gt; 0&lt;/code&gt; : 머리에서 꼬리로 이동 하는 &lt;code&gt;value&lt;/code&gt; 과 같은 요소를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="49ed95d45eb2dc13b9ae1282ce5ebdc9d3906990" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count &amp;lt; 0&lt;/code&gt;: Remove elements equal to &lt;code&gt;element&lt;/code&gt; moving from tail to head.</source>
          <target state="translated">&lt;code&gt;count &amp;lt; 0&lt;/code&gt; : 제거 요소는 동일한 &lt;code&gt;element&lt;/code&gt; 헤드 꼬리 이동.</target>
        </trans-unit>
        <trans-unit id="ba40b8d7058909d83882c013f4bc1e77afd98c42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count &amp;lt; 0&lt;/code&gt;: Remove elements equal to &lt;code&gt;value&lt;/code&gt; moving from tail to head.</source>
          <target state="translated">&lt;code&gt;count &amp;lt; 0&lt;/code&gt; : 꼬리에서 머리로 이동 하는 &lt;code&gt;value&lt;/code&gt; 과 같은 요소를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="a1c07ae420021783795b0c2dd33cb72eeef5c79c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count = 0&lt;/code&gt;: Remove all elements equal to &lt;code&gt;element&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;count = 0&lt;/code&gt; : 모든 요소를 동일한 분리 &lt;code&gt;element&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c040b7d8a01d8456ce09165ab044d0015f9d0f28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;count = 0&lt;/code&gt;: Remove all elements equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;count = 0&lt;/code&gt; : &lt;code&gt;value&lt;/code&gt; 와 동일한 모든 요소를 ​​제거합니다 .</target>
        </trans-unit>
        <trans-unit id="fffb19a64d186de16d9f02ae1ed78be02aa565a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cpu&lt;/code&gt;: CPU consumption statistics</source>
          <target state="translated">&lt;code&gt;cpu&lt;/code&gt; : CPU 소비 통계</target>
        </trans-unit>
        <trans-unit id="28e89f6000c505dd15ff4ee6498a8a5c7cf10f46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dataset.bytes&lt;/code&gt;: The size in bytes of the dataset, i.e. &lt;code&gt;overhead.total&lt;/code&gt; subtracted from &lt;code&gt;total.allocated&lt;/code&gt; (see &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;'s &lt;code&gt;used_memory_dataset&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;dataset.bytes&lt;/code&gt; : 데이터 세트의 크기 (바이트)는, 즉 &lt;code&gt;overhead.total&lt;/code&gt; 공제에서 &lt;code&gt;total.allocated&lt;/code&gt; (참조 &lt;a href=&quot;info&quot;&gt;정보&lt;/a&gt; 의 &lt;code&gt;used_memory_dataset&lt;/code&gt; 를 )</target>
        </trans-unit>
        <trans-unit id="b1c9f5d1580b06150ed54d844305fc482f4608a0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dataset.percentage&lt;/code&gt;: The percentage of &lt;code&gt;dataset.bytes&lt;/code&gt; out of the net memory usage</source>
          <target state="translated">&lt;code&gt;dataset.percentage&lt;/code&gt; : 순 메모리 사용량 중 &lt;code&gt;dataset.bytes&lt;/code&gt; 의 백분율</target>
        </trans-unit>
        <trans-unit id="bac92558837e2cc0d2fca2ad2bf12fdb7afe3879" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;db&lt;/code&gt;: current database ID</source>
          <target state="translated">&lt;code&gt;db&lt;/code&gt; : 현재 데이터베이스 ID</target>
        </trans-unit>
        <trans-unit id="02ada849167913c73ba9e71998348d80cbf63a02" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dbXXX&lt;/code&gt;: &lt;code&gt;keys=XXX,expires=XXX&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;dbXXX&lt;/code&gt; : &lt;code&gt;keys=XXX,expires=XXX&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e70830fd3214e8c50b4d6c6ffa87dea222cf1a85" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;dbXXX&lt;/code&gt;: For each of the server's databases, the overheads of the main and expiry dictionaries (&lt;code&gt;overhead.hashtable.main&lt;/code&gt; and &lt;code&gt;overhead.hashtable.expires&lt;/code&gt;, respectively) are reported in bytes</source>
          <target state="translated">&lt;code&gt;dbXXX&lt;/code&gt; : 각 서버의 데이터베이스에 대해 기본 및 만료 사전의 &lt;code&gt;overhead.hashtable.main&lt;/code&gt; &lt;code&gt;overhead.hashtable.expires&lt;/code&gt; (각각 overhead.hashtable.main 및 overhead.hashtable.expires )가 바이트 단위로보고됩니다</target>
        </trans-unit>
        <trans-unit id="219313b81a2634eda6addfea706a4c7e8ee55c8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;default&lt;/code&gt;: Return only the default set of sections</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; : 기본 섹션 세트 만 반환</target>
        </trans-unit>
        <trans-unit id="a5a4f58751c4847a68fa58ac194036166b7d5435" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;events&lt;/code&gt;: file descriptor events (see below)</source>
          <target state="translated">&lt;code&gt;events&lt;/code&gt; : 파일 디스크립터 이벤트 (아래 참조)</target>
        </trans-unit>
        <trans-unit id="bc0ac6c91120d3c5b5a98bb410f8df776c3d63ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;everything&lt;/code&gt;: Includes &lt;code&gt;all&lt;/code&gt; and &lt;code&gt;modules&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;everything&lt;/code&gt; : &lt;code&gt;all&lt;/code&gt; 및 &lt;code&gt;modules&lt;/code&gt; 포함</target>
        </trans-unit>
        <trans-unit id="8566e0b3d3d91487347cb7d465fc1c5fc2616626" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;evicted_keys&lt;/code&gt;: Number of evicted keys due to &lt;code&gt;maxmemory&lt;/code&gt; limit</source>
          <target state="translated">&lt;code&gt;evicted_keys&lt;/code&gt; : 최대 &lt;code&gt;maxmemory&lt;/code&gt; 제한 으로 인한 제거 된 키 수</target>
        </trans-unit>
        <trans-unit id="3e721e3bc63db39fa41eef44ba732db22b942d1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;executable&lt;/code&gt;: The path to the server's executable</source>
          <target state="translated">&lt;code&gt;executable&lt;/code&gt; : 서버의 실행 파일 경로</target>
        </trans-unit>
        <trans-unit id="1445bea46e8c6f8839bf45a414eef179da6b43b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expire_cycle_cpu_milliseconds&lt;/code&gt;: The cumulative amount of time spend on active expiry cycles</source>
          <target state="translated">&lt;code&gt;expire_cycle_cpu_milliseconds&lt;/code&gt; : 활성 만료주기에 소요 된 누적 시간</target>
        </trans-unit>
        <trans-unit id="fddae6b7c1346bcee795c85b7caa0a8eb0c07bf4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expired_keys&lt;/code&gt;: Total number of key expiration events</source>
          <target state="translated">&lt;code&gt;expired_keys&lt;/code&gt; : 총 키 만료 이벤트 수</target>
        </trans-unit>
        <trans-unit id="f378daf38690d735e99c4533cddb27e3de9da98a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expired_stale_perc&lt;/code&gt;: The percentage of keys probably expired</source>
          <target state="translated">&lt;code&gt;expired_stale_perc&lt;/code&gt; : 만료되었을 가능성이있는 키 비율</target>
        </trans-unit>
        <trans-unit id="4959e2adfed6d630b2108dc7a006ae59cc0aec41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expired_time_cap_reached_count&lt;/code&gt;: The count of times that active expiry cycles have stopped early</source>
          <target state="translated">&lt;code&gt;expired_time_cap_reached_count&lt;/code&gt; : 활성 만료주기가 일찍 중지 된 횟수</target>
        </trans-unit>
        <trans-unit id="92de7381dc01164610e1cda0033a7229af5660db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fail&lt;/code&gt;: Node is in &lt;code&gt;FAIL&lt;/code&gt; state. It was not reachable for multiple nodes that promoted the &lt;code&gt;PFAIL&lt;/code&gt; state to &lt;code&gt;FAIL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;fail&lt;/code&gt; : 노드가 &lt;code&gt;FAIL&lt;/code&gt; 상태입니다. &lt;code&gt;PFAIL&lt;/code&gt; 상태를 &lt;code&gt;FAIL&lt;/code&gt; 로 승격시킨 여러 노드에 도달 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c35b7b08fa3b308e4d8f1822389f662520bb59fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fail?&lt;/code&gt;: Node is in &lt;code&gt;PFAIL&lt;/code&gt; state. Not reachable for the node you are contacting, but still logically reachable (not in &lt;code&gt;FAIL&lt;/code&gt; state).</source>
          <target state="translated">&lt;code&gt;fail?&lt;/code&gt; : 노드가 &lt;code&gt;PFAIL&lt;/code&gt; 상태입니다. 접속중인 노드에 도달 할 수 없지만 논리적으로 도달 할 수 있습니다 ( &lt;code&gt;FAIL&lt;/code&gt; 상태가 아님).</target>
        </trans-unit>
        <trans-unit id="49776705e06dd4e253f073b1e1df4558b84d2624" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fd&lt;/code&gt;: file descriptor corresponding to the socket</source>
          <target state="translated">&lt;code&gt;fd&lt;/code&gt; : 소켓에 해당하는 파일 디스크립터</target>
        </trans-unit>
        <trans-unit id="e4839b8d9abefec89230daa71bb34e7d4624d2a2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: A list of comma separated flags: &lt;code&gt;myself&lt;/code&gt;, &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;slave&lt;/code&gt;, &lt;code&gt;fail?&lt;/code&gt;, &lt;code&gt;fail&lt;/code&gt;, &lt;code&gt;handshake&lt;/code&gt;, &lt;code&gt;noaddr&lt;/code&gt;, &lt;code&gt;noflags&lt;/code&gt;. Flags are explained in detail in the next section.</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; : 쉼표로 구분 된 플래그 목록 : &lt;code&gt;myself&lt;/code&gt; , &lt;code&gt;master&lt;/code&gt; , &lt;code&gt;slave&lt;/code&gt; , &lt;code&gt;fail?&lt;/code&gt; , &lt;code&gt;fail&lt;/code&gt; , &lt;code&gt;handshake&lt;/code&gt; , &lt;code&gt;noaddr&lt;/code&gt; , &lt;code&gt;noflags&lt;/code&gt; . 플래그는 다음 섹션에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f3cd416356c95d4051d973688aae7ac6eba88b4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;flags&lt;/code&gt;: client flags (see below)</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; : 클라이언트 플래그 (아래 참조)</target>
        </trans-unit>
        <trans-unit id="df062b203c243b317d77329f74ef9fbc95ad37d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fragmentation&lt;/code&gt;: See &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;'s &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;fragmentation&lt;/code&gt; : &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 의 &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt; 참조</target>
        </trans-unit>
        <trans-unit id="6029bff55fe0c7d9bb3ddb3ebd0310dacaf55ff4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;gcc_version&lt;/code&gt;: Version of the GCC compiler used to compile the Redis server</source>
          <target state="translated">&lt;code&gt;gcc_version&lt;/code&gt; : Redis 서버를 컴파일하는 데 사용되는 GCC 컴파일러 버전</target>
        </trans-unit>
        <trans-unit id="23a072a24cfac677fc8764a1a8c0fe1f00743a04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h*llo&lt;/code&gt; matches &lt;code&gt;hllo&lt;/code&gt; and &lt;code&gt;heeeello&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;h*llo&lt;/code&gt; &lt;code&gt;hllo&lt;/code&gt; 는 hllo 및 &lt;code&gt;heeeello&lt;/code&gt; 와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a1845d4d0e238b7e6dc45ebcbe2292b346139d65" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h*llo&lt;/code&gt; subscribes to &lt;code&gt;hllo&lt;/code&gt; and &lt;code&gt;heeeello&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;h*llo&lt;/code&gt; &lt;code&gt;hllo&lt;/code&gt; 와 &lt;code&gt;heeeello&lt;/code&gt; 를 구독합니다</target>
        </trans-unit>
        <trans-unit id="ade12d9137392f4c2bf48b6994c54aaa368233a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h?llo&lt;/code&gt; matches &lt;code&gt;hello&lt;/code&gt;, &lt;code&gt;hallo&lt;/code&gt; and &lt;code&gt;hxllo&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;h?llo&lt;/code&gt; &lt;code&gt;hxllo&lt;/code&gt; 는 &lt;code&gt;hello&lt;/code&gt; , &lt;code&gt;hallo&lt;/code&gt; 및 hxllo 와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="cd6496b33d0f1569be1935849893a999435152ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h?llo&lt;/code&gt; subscribes to &lt;code&gt;hello&lt;/code&gt;, &lt;code&gt;hallo&lt;/code&gt; and &lt;code&gt;hxllo&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;h?llo&lt;/code&gt; &lt;code&gt;hxllo&lt;/code&gt; &lt;code&gt;hello&lt;/code&gt; , &lt;code&gt;hallo&lt;/code&gt; 및 hxllo를 구독합니다.</target>
        </trans-unit>
        <trans-unit id="dcfac43bef479b2c536e4ae578bf2a90ec0c4fab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h[^e]llo&lt;/code&gt; matches &lt;code&gt;hallo&lt;/code&gt;, &lt;code&gt;hbllo&lt;/code&gt;, ... but not &lt;code&gt;hello&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;h[^e]llo&lt;/code&gt; &lt;code&gt;hbllo&lt;/code&gt; 는 &lt;code&gt;hallo&lt;/code&gt; , hbllo , ... 와 일치 하지만 &lt;code&gt;hello&lt;/code&gt; 는 아닙니다</target>
        </trans-unit>
        <trans-unit id="fadd16f48704cc1c7091cdf7ff15838506d015cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h[a-b]llo&lt;/code&gt; matches &lt;code&gt;hallo&lt;/code&gt; and &lt;code&gt;hbllo&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;h[a-b]llo&lt;/code&gt; &lt;code&gt;hbllo&lt;/code&gt; 는 &lt;code&gt;hallo&lt;/code&gt; 및 hbllo 와 일치</target>
        </trans-unit>
        <trans-unit id="bb5381a854a2cdc7b997de02f71efdd1649da762" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h[ae]llo&lt;/code&gt; matches &lt;code&gt;hello&lt;/code&gt; and &lt;code&gt;hallo,&lt;/code&gt; but not &lt;code&gt;hillo&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;h[ae]llo&lt;/code&gt; 는 &lt;code&gt;hello&lt;/code&gt; 및 &lt;code&gt;hallo,&lt;/code&gt; 와 일치 하지만 &lt;code&gt;hillo&lt;/code&gt; 와는 일치 하지 않습니다</target>
        </trans-unit>
        <trans-unit id="a5e1fb9a42de209210d73ecbdbce60f787f2d93c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;h[ae]llo&lt;/code&gt; subscribes to &lt;code&gt;hello&lt;/code&gt; and &lt;code&gt;hallo,&lt;/code&gt; but not &lt;code&gt;hillo&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;h[ae]llo&lt;/code&gt; 는 &lt;code&gt;hello&lt;/code&gt; 와 &lt;code&gt;hallo,&lt;/code&gt; 구독 하지만 &lt;code&gt;hillo&lt;/code&gt; 는 구독 하지 않습니다</target>
        </trans-unit>
        <trans-unit id="772949aad53f3e2d516cf0b962fffee5490a4d57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;handshake&lt;/code&gt;: Untrusted node, we are handshaking.</source>
          <target state="translated">&lt;code&gt;handshake&lt;/code&gt; : 신뢰할 수없는 노드, 핸드 셰이 킹 중입니다.</target>
        </trans-unit>
        <trans-unit id="d0689cf551fb2b0d08b1961735f71c6e9b2bb410" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hz&lt;/code&gt;: The server's current frequency setting</source>
          <target state="translated">&lt;code&gt;hz&lt;/code&gt; : 서버의 현재 주파수 설정</target>
        </trans-unit>
        <trans-unit id="814fd3f9ef97f0a61158c442ebf3374319e7d6c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;hz&lt;/code&gt;: The server's frequency setting</source>
          <target state="translated">&lt;code&gt;hz&lt;/code&gt; : 서버의 주파수 설정</target>
        </trans-unit>
        <trans-unit id="1022ccb50a72baa656186ea51d6417dd09b347e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt;: The node ID, a 40 characters random string generated when a node is created and never changed again (unless &lt;code&gt;CLUSTER RESET HARD&lt;/code&gt; is used).</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; : 노드를 생성하고 다시 변경하지 않을 때 생성되는 40 자 무작위 문자열 인 노드 ID ( &lt;code&gt;CLUSTER RESET HARD&lt;/code&gt; 를 사용 하지 않는 한 ).</target>
        </trans-unit>
        <trans-unit id="6e4cf9fe6a9736c25c012bac49c2f87bfbbd0a81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt;: an unique 64-bit client ID (introduced in Redis 2.8.12).</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; : 고유 한 64 비트 클라이언트 ID (Redis 2.8.12에서 도입)</target>
        </trans-unit>
        <trans-unit id="bc766ec484f27e4cc3d20ab79a21e4ce04397109" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;id&lt;/code&gt;: an unique 64-bit client ID.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; : 고유 한 64 비트 클라이언트 ID입니다.</target>
        </trans-unit>
        <trans-unit id="b1bda4eb1cacc58fcc5d8afc9929ac1d35eed0e6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;idle&lt;/code&gt;: idle time of the connection in seconds</source>
          <target state="translated">&lt;code&gt;idle&lt;/code&gt; : 초 단위의 유휴 연결 시간</target>
        </trans-unit>
        <trans-unit id="dc37fb4e2cc65425cd389de9487907efef683281" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instantaneous_input_kbps&lt;/code&gt;: The network's read rate per second in KB/sec</source>
          <target state="translated">&lt;code&gt;instantaneous_input_kbps&lt;/code&gt; : 초당 네트워크의 읽기 속도 (KB / 초)</target>
        </trans-unit>
        <trans-unit id="c2bbc7260a608ea757aeacf6cecda5f317d1b4fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instantaneous_ops_per_sec&lt;/code&gt;: Number of commands processed per second</source>
          <target state="translated">&lt;code&gt;instantaneous_ops_per_sec&lt;/code&gt; : 초당 처리되는 명령 수</target>
        </trans-unit>
        <trans-unit id="95b684cc83a0cda570839cd2a346dc1d8416b8fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;instantaneous_output_kbps&lt;/code&gt;: The network's write rate per second in KB/sec</source>
          <target state="translated">&lt;code&gt;instantaneous_output_kbps&lt;/code&gt; : 초당 네트워크 쓰기 속도 (KB / 초)</target>
        </trans-unit>
        <trans-unit id="f7216fccf4b8cf6baabaf30be836f2eb2f1c2c63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io_threaded_reads_processed&lt;/code&gt;: Number of read events processed by the main and I/O threads</source>
          <target state="translated">&lt;code&gt;io_threaded_reads_processed&lt;/code&gt; : 기본 및 I / O 스레드에서 처리 한 읽기 이벤트 수</target>
        </trans-unit>
        <trans-unit id="8129ddc83f2b3c72b62eba59bdb942f9513b1817" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io_threaded_writes_processed&lt;/code&gt;: Number of write events processed by the main and I/O threads</source>
          <target state="translated">&lt;code&gt;io_threaded_writes_processed&lt;/code&gt; : 기본 및 I / O 스레드에서 처리 한 쓰기 이벤트 수</target>
        </trans-unit>
        <trans-unit id="6c9ec3aa6422a854628188f9808209b697641f41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;io_threads_active&lt;/code&gt;: Flag indicating if I/O threads are active</source>
          <target state="translated">&lt;code&gt;io_threads_active&lt;/code&gt; : I / O 스레드가 활성 상태인지 여부를 나타내는 플래그</target>
        </trans-unit>
        <trans-unit id="1e23ab4305826d0584db18380ae54f96cfe85a06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ip:port&lt;/code&gt;: The node address where clients should contact the node to run queries.</source>
          <target state="translated">&lt;code&gt;ip:port&lt;/code&gt; : 클라이언트가 노드를 연결하여 쿼리를 실행해야하는 노드 주소입니다.</target>
        </trans-unit>
        <trans-unit id="270a88a258c3a16f513203e7b558ec2c78da586a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ip:port@cport&lt;/code&gt;: The node address where clients should contact the node to run queries.</source>
          <target state="translated">&lt;code&gt;ip:port@cport&lt;/code&gt; : 클라이언트가 쿼리를 실행하기 위해 노드에 접속해야하는 노드 주소입니다.</target>
        </trans-unit>
        <trans-unit id="291f0af420cf08324f52bee6ac610301d0a211a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keys.bytes-per-key&lt;/code&gt;: The ratio between &lt;strong&gt;net memory usage&lt;/strong&gt; (&lt;code&gt;total.allocated&lt;/code&gt; minus &lt;code&gt;startup.allocated&lt;/code&gt;) and &lt;code&gt;keys.count&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;keys.bytes-per-key&lt;/code&gt; : &lt;strong&gt;순 메모리 사용량&lt;/strong&gt; ( &lt;code&gt;total.allocated&lt;/code&gt; -minus &lt;code&gt;startup.allocated&lt;/code&gt; )과 &lt;code&gt;keys.count&lt;/code&gt; 의 비율</target>
        </trans-unit>
        <trans-unit id="43dcaebeef203950604817bffeb6c8b12d81080b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keys.count&lt;/code&gt;: The total number of keys stored across all databases in the server</source>
          <target state="translated">&lt;code&gt;keys.count&lt;/code&gt; : 서버의 모든 데이터베이스에 저장된 총 키 수</target>
        </trans-unit>
        <trans-unit id="95824ce321d4cc94f4954a02b73345e7751f8263" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyspace&lt;/code&gt;: Database related statistics</source>
          <target state="translated">&lt;code&gt;keyspace&lt;/code&gt; : 데이터베이스 관련 통계</target>
        </trans-unit>
        <trans-unit id="938849ce8e866deafc434a8c0bbab85368d34ec7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyspace_hits&lt;/code&gt;: Number of successful lookup of keys in the main dictionary</source>
          <target state="translated">&lt;code&gt;keyspace_hits&lt;/code&gt; : 기본 사전에서 키를 성공적으로 조회 한 횟수</target>
        </trans-unit>
        <trans-unit id="5934dcbf3cf4745664c870f4876772114b7ebcad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;keyspace_misses&lt;/code&gt;: Number of failed lookup of keys in the main dictionary</source>
          <target state="translated">&lt;code&gt;keyspace_misses&lt;/code&gt; : 기본 사전에서 실패한 키 조회 수</target>
        </trans-unit>
        <trans-unit id="5f8a41bd61bedded590e35fd39e3c92d238bb0b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;laddr&lt;/code&gt;: address/port of local address client connected to (bind address)</source>
          <target state="translated">&lt;code&gt;laddr&lt;/code&gt; : 연결된 로컬 주소 클라이언트의 주소 / 포트 (바인드 주소)</target>
        </trans-unit>
        <trans-unit id="b8248fad4d6ffdc71b385b094bafe2abbfbc52b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;latest_fork_usec&lt;/code&gt;: Duration of the latest fork operation in microseconds</source>
          <target state="translated">&lt;code&gt;latest_fork_usec&lt;/code&gt; : 마이크로 초 단위의 최신 포크 작동 기간</target>
        </trans-unit>
        <trans-unit id="21cc38e61fdb4dd462416a21e8e9e6648d07e3af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lazyfree_pending_objects&lt;/code&gt;: The number of objects waiting to be freed (as a result of calling &lt;a href=&quot;unlink&quot;&gt;UNLINK&lt;/a&gt;, or &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; and &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; with the &lt;strong&gt;ASYNC&lt;/strong&gt; option)</source>
          <target state="translated">&lt;code&gt;lazyfree_pending_objects&lt;/code&gt; : 해제 대기중인 객체 수 ( &lt;strong&gt;ASYNC&lt;/strong&gt; 옵션을 사용하여 &lt;a href=&quot;unlink&quot;&gt;UNLINK&lt;/a&gt; 또는 &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; 및 &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; 을 호출 한 결과 )&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="59ecbcb471bd0b1ba5e063f491468fad5e3173d2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;link-state&lt;/code&gt;: The state of the link used for the node-to-node cluster bus. We use this link to communicate with the node. Can be &lt;code&gt;connected&lt;/code&gt; or &lt;code&gt;disconnected&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;link-state&lt;/code&gt; : 노드 간 클러스터 버스에 사용 된 링크의 상태입니다. 이 링크를 사용하여 노드와 통신합니다. &lt;code&gt;connected&lt;/code&gt; 하거나 &lt;code&gt;disconnected&lt;/code&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe7bdbcf85b37b69d3e6e4d866b6ad86cc562465" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loading&lt;/code&gt;: Flag indicating if the load of a dump file is on-going</source>
          <target state="translated">&lt;code&gt;loading&lt;/code&gt; : 덤프 파일의로드가 진행 중인지를 나타내는 플래그</target>
        </trans-unit>
        <trans-unit id="b641e737c4c65b61073674e1872dba9aa112ba11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loading_eta_seconds&lt;/code&gt;: ETA in seconds for the load to be complete</source>
          <target state="translated">&lt;code&gt;loading_eta_seconds&lt;/code&gt; :로드가 완료되기까지의 ETA (초)</target>
        </trans-unit>
        <trans-unit id="905f0c0d04e1edb114d6944e2c3fc5d7d748d4df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loading_loaded_bytes&lt;/code&gt;: Number of bytes already loaded</source>
          <target state="translated">&lt;code&gt;loading_loaded_bytes&lt;/code&gt; : 이미로드 된 바이트 수</target>
        </trans-unit>
        <trans-unit id="95d85b85e583f65530a4c519f38195c7d0bf9d9b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loading_loaded_perc&lt;/code&gt;: Same value expressed as a percentage</source>
          <target state="translated">&lt;code&gt;loading_loaded_perc&lt;/code&gt; : 백분율로 표시되는 동일한 값</target>
        </trans-unit>
        <trans-unit id="1a24643a4ec60a4cdfdf69f48f4893ff213957f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loading_rdb_used_mem&lt;/code&gt;: The memory usage of the server that had generated the RDB file at the time of the file's creation</source>
          <target state="translated">&lt;code&gt;loading_rdb_used_mem&lt;/code&gt; : 파일 생성시 RDB 파일을 생성 한 서버의 메모리 사용량</target>
        </trans-unit>
        <trans-unit id="54bc84cb5d647f7d245611a75b0f4e6a47881c15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loading_start_time&lt;/code&gt;: Epoch-based timestamp of the start of the load operation</source>
          <target state="translated">&lt;code&gt;loading_start_time&lt;/code&gt; :로드 조작 시작의 Epoch 기반 시간 소인</target>
        </trans-unit>
        <trans-unit id="a2b99d44dac13ed28eaefad23e3acd32e473cff7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loading_total_bytes&lt;/code&gt;: Total file size</source>
          <target state="translated">&lt;code&gt;loading_total_bytes&lt;/code&gt; : 총 파일 크기</target>
        </trans-unit>
        <trans-unit id="3f4e8e370b36fff04729036f4d5f3c0e5b332d07" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loglevel&lt;/code&gt; is one of:</source>
          <target state="translated">&lt;code&gt;loglevel&lt;/code&gt; 은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="1f16338d15e120aaa052f8fdb78dab343eef6dd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lru_clock&lt;/code&gt;: Clock incrementing every minute, for LRU management</source>
          <target state="translated">&lt;code&gt;lru_clock&lt;/code&gt; : LRU 관리를 위해 1 분마다 증가하는 클록</target>
        </trans-unit>
        <trans-unit id="5c3f6070e6ac871d998395858ad30edba81f25dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lua.caches&lt;/code&gt;: the summed size in bytes of the overheads of the Lua scripts' caches</source>
          <target state="translated">&lt;code&gt;lua.caches&lt;/code&gt; : Lua 스크립트 캐시 오버 헤드의 합계 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="a6ed881ede82d74c70a2a4663adcf6972b5df79d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master&lt;/code&gt;: If the node is a replica, and the master is known, the master node ID, otherwise the &quot;-&quot; character.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; : 노드가 복제본이고 마스터가 알려진 경우 마스터 노드 ID, 그렇지 않으면 &quot;-&quot;문자</target>
        </trans-unit>
        <trans-unit id="4cc7689c421b56db103b063a107acf3446d1e601" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master&lt;/code&gt;: Node is a master.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; : 노드는 마스터입니다.</target>
        </trans-unit>
        <trans-unit id="291a8ad8ba75d794172ecb8cdc800fac2e8bea69" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_host&lt;/code&gt;: Host or IP address of the master</source>
          <target state="translated">&lt;code&gt;master_host&lt;/code&gt; : 마스터의 호스트 또는 IP 주소</target>
        </trans-unit>
        <trans-unit id="c7b919c2a8e9e5c48b32193b06915825f05d23ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_last_io_seconds_ago&lt;/code&gt;: Number of seconds since the last interaction with master</source>
          <target state="translated">&lt;code&gt;master_last_io_seconds_ago&lt;/code&gt; : 마스터와의 마지막 상호 작용 이후의 시간 (초)</target>
        </trans-unit>
        <trans-unit id="f0f3eb8f4200646143873fd144790f03d854f7af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_link_down_since_seconds&lt;/code&gt;: Number of seconds since the link is down</source>
          <target state="translated">&lt;code&gt;master_link_down_since_seconds&lt;/code&gt; : 링크가 다운 된 이후의 시간 (초)</target>
        </trans-unit>
        <trans-unit id="90bf7bf132f33bf3b3e67cdd40fdcc917c464460" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_link_status&lt;/code&gt;: Status of the link (up/down)</source>
          <target state="translated">&lt;code&gt;master_link_status&lt;/code&gt; : 링크 상태 (위 / 아래)</target>
        </trans-unit>
        <trans-unit id="e58722ccd1793143cb927377948a3a1635236b9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_port&lt;/code&gt;: Master listening TCP port</source>
          <target state="translated">&lt;code&gt;master_port&lt;/code&gt; : 마스터 수신 TCP 포트</target>
        </trans-unit>
        <trans-unit id="38536dd76b51abea55679752e904120abd772b27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_repl_offset&lt;/code&gt;: The server's current replication offset</source>
          <target state="translated">&lt;code&gt;master_repl_offset&lt;/code&gt; : 서버의 현재 복제 오프셋</target>
        </trans-unit>
        <trans-unit id="17b1b7079ccf083e09938191385ff09c723f9080" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_replid2&lt;/code&gt;: The secondary replication ID, used for PSYNC after a failover.</source>
          <target state="translated">&lt;code&gt;master_replid2&lt;/code&gt; : 장애 조치 후 PSYNC에 사용되는 보조 복제 ID입니다.</target>
        </trans-unit>
        <trans-unit id="506e20f228c9d2c1dcc44dcf716be0a8e0f527df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_replid&lt;/code&gt;: The replication ID of the Redis server.</source>
          <target state="translated">&lt;code&gt;master_replid&lt;/code&gt; : Redis 서버의 복제 ID입니다.</target>
        </trans-unit>
        <trans-unit id="c4bc68c43bde0af6497f05baba945f1c620a90ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_sync_in_progress&lt;/code&gt;: Indicate the master is syncing to the replica</source>
          <target state="translated">&lt;code&gt;master_sync_in_progress&lt;/code&gt; : 마스터가 복제본과 동기화 중임을 나타냅니다</target>
        </trans-unit>
        <trans-unit id="b4b673ca5ed8610fe7fa1e1ffbaedb57ca7ca77b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_sync_last_io_seconds_ago&lt;/code&gt;: Number of seconds since last transfer I/O during a SYNC operation</source>
          <target state="translated">&lt;code&gt;master_sync_last_io_seconds_ago&lt;/code&gt; : SYNC 작업 중 마지막 전송 I / O 이후의 시간 (초)</target>
        </trans-unit>
        <trans-unit id="0cdd4c8cc8c79eeab8100d928843441a0c312ab7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_sync_left_bytes&lt;/code&gt;: Number of bytes left before syncing is complete</source>
          <target state="translated">&lt;code&gt;master_sync_left_bytes&lt;/code&gt; : 동기화가 완료되기 전에 남은 바이트 수</target>
        </trans-unit>
        <trans-unit id="5680ee8ed92983ea22d11b8ce00e30f766f93a11" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_sync_left_bytes&lt;/code&gt;: Number of bytes left before syncing is complete (may be negative when &lt;code&gt;master_sync_total_bytes&lt;/code&gt; is 0)</source>
          <target state="translated">&lt;code&gt;master_sync_left_bytes&lt;/code&gt; : 동기화가 완료되기 전까지 남은 바이트 수 ( &lt;code&gt;master_sync_total_bytes&lt;/code&gt; 가 0이면 음수 일 수 있음 )</target>
        </trans-unit>
        <trans-unit id="8716ac374614f070bd6e3e58fca4cd1c5eaee16e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_sync_perc&lt;/code&gt;: The percentage &lt;code&gt;master_sync_read_bytes&lt;/code&gt; from &lt;code&gt;master_sync_total_bytes&lt;/code&gt;, or an approximation that uses &lt;code&gt;loading_rdb_used_mem&lt;/code&gt; when &lt;code&gt;master_sync_total_bytes&lt;/code&gt; is 0</source>
          <target state="translated">&lt;code&gt;master_sync_perc&lt;/code&gt; : 백분율 &lt;code&gt;master_sync_read_bytes&lt;/code&gt; 에서 &lt;code&gt;master_sync_total_bytes&lt;/code&gt; 또는 용도가 근사 &lt;code&gt;loading_rdb_used_mem&lt;/code&gt; 때 &lt;code&gt;master_sync_total_bytes&lt;/code&gt; 가 0</target>
        </trans-unit>
        <trans-unit id="2bfd156e1559140e96dbd04f463bcedd805cd572" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_sync_read_bytes&lt;/code&gt;: Number of bytes already transferred</source>
          <target state="translated">&lt;code&gt;master_sync_read_bytes&lt;/code&gt; : 이미 전송 된 바이트 수</target>
        </trans-unit>
        <trans-unit id="2bd088fb4298efcf15162f466d0c93b7aeaae1d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master_sync_total_bytes&lt;/code&gt;: Total number of bytes that need to be transferred. this may be 0 when the size is unknown (for example, when the &lt;code&gt;repl-diskless-sync&lt;/code&gt; configuration directive is used)</source>
          <target state="translated">&lt;code&gt;master_sync_total_bytes&lt;/code&gt; : 전송해야하는 총 바이트 수. 크기를 알 수없는 경우 (예 : &lt;code&gt;repl-diskless-sync&lt;/code&gt; 구성 지시문이 사용되는 경우) 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc21fdd1146fa4c4bba4073b469b7424702f89f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;math&lt;/code&gt; lib.</source>
          <target state="translated">&lt;code&gt;math&lt;/code&gt; 라이브러리.</target>
        </trans-unit>
        <trans-unit id="0764a52a4b87ecc5b58c0b283ff413d29c1885fe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxclients&lt;/code&gt;: The value of the &lt;code&gt;maxclients&lt;/code&gt; configuration directive. This is the upper limit for the sum of &lt;code&gt;connected_clients&lt;/code&gt;, &lt;code&gt;connected_slaves&lt;/code&gt; and &lt;code&gt;cluster_connections&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;maxclients&lt;/code&gt; : &lt;code&gt;maxclients&lt;/code&gt; 구성 지시문 의 값입니다 . 이는 &lt;code&gt;connected_clients&lt;/code&gt; , &lt;code&gt;connected_slaves&lt;/code&gt; 및 &lt;code&gt;cluster_connections&lt;/code&gt; 합계의 상한입니다 .</target>
        </trans-unit>
        <trans-unit id="264ff63840f1fd88caa997a7ac62b59d2937b34e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxmemory&lt;/code&gt;: The value of the &lt;code&gt;maxmemory&lt;/code&gt; configuration directive</source>
          <target state="translated">&lt;code&gt;maxmemory&lt;/code&gt; : &lt;code&gt;maxmemory&lt;/code&gt; 구성 지시문 의 값</target>
        </trans-unit>
        <trans-unit id="817ccce83e74c3626cb40339fef4aa9b5544ef46" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxmemory_human&lt;/code&gt;: Human readable representation of previous value</source>
          <target state="translated">&lt;code&gt;maxmemory_human&lt;/code&gt; : 인간이 읽을 수있는 이전 값 표현</target>
        </trans-unit>
        <trans-unit id="b922c9f2d429df108e0acf7ffcf5d134393c6d70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxmemory_policy&lt;/code&gt;: The value of the &lt;code&gt;maxmemory-policy&lt;/code&gt; configuration directive</source>
          <target state="translated">&lt;code&gt;maxmemory_policy&lt;/code&gt; : &lt;code&gt;maxmemory-policy&lt;/code&gt; 구성 지시문 의 값</target>
        </trans-unit>
        <trans-unit id="fad03613c207944468a711f3fbb7847b71f15d75" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mem_allocator&lt;/code&gt;: Memory allocator, chosen at compile time</source>
          <target state="translated">&lt;code&gt;mem_allocator&lt;/code&gt; : 컴파일시에 선택된 메모리 할당 자</target>
        </trans-unit>
        <trans-unit id="8ab1c581e26ff6762ae29f013f6d0b6a17cf2cb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mem_fragmentation_ratio&lt;/code&gt;: Ratio between &lt;code&gt;used_memory_rss&lt;/code&gt; and &lt;code&gt;used_memory&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mem_fragmentation_ratio&lt;/code&gt; : &lt;code&gt;used_memory_rss&lt;/code&gt; 와 &lt;code&gt;used_memory&lt;/code&gt; 의 비율</target>
        </trans-unit>
        <trans-unit id="3edb25127130c1e1537a5ef7e8480bc9ec92b78d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;memory&lt;/code&gt;: Memory consumption related information</source>
          <target state="translated">&lt;code&gt;memory&lt;/code&gt; : 메모리 소비 관련 정보</target>
        </trans-unit>
        <trans-unit id="2d5cca8132678950ab84bf42425da3ca0507e576" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;migrate_cached_sockets&lt;/code&gt;: The number of sockets open for &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; purposes</source>
          <target state="translated">&lt;code&gt;migrate_cached_sockets&lt;/code&gt; : &lt;a href=&quot;migrate&quot;&gt;마이그레이션&lt;/a&gt; 목적으로 열린 소켓 수</target>
        </trans-unit>
        <trans-unit id="3927030e50503d7ca36313f099ded40f9e7fd2a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; can be &lt;code&gt;-inf&lt;/code&gt; and &lt;code&gt;+inf&lt;/code&gt;, so that you are not required to know the highest or lowest score in the sorted set to get all elements from or up to a certain score.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;max&lt;/code&gt; 는 &lt;code&gt;-inf&lt;/code&gt; 및 &lt;code&gt;+inf&lt;/code&gt; 일 수 있으므로 정렬 된 세트에서 최고 또는 최저 점수를 알 필요가 없으므로 모든 요소를 ​​특정 점수에서 또는 최대로 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d1bf92a441476dd2b1a033b8bda44cfa256eb59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_slaves_good_slaves&lt;/code&gt;: Number of replicas currently considered good</source>
          <target state="translated">&lt;code&gt;min_slaves_good_slaves&lt;/code&gt; : 현재 양호하다고 간주되는 복제본 수</target>
        </trans-unit>
        <trans-unit id="acd242d033ab51e8924a653a8f75d3dfafbfc9e9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module_fork_in_progress&lt;/code&gt;: Flag indicating a module fork is on-going</source>
          <target state="translated">&lt;code&gt;module_fork_in_progress&lt;/code&gt; : 모듈 포크가 진행 중임을 나타내는 플래그</target>
        </trans-unit>
        <trans-unit id="58320459c64e0ed996c72236d4b5a5df86ee37a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;module_fork_last_cow_size&lt;/code&gt;: The size in bytes of copy-on-write allocations during the last module fork operation</source>
          <target state="translated">&lt;code&gt;module_fork_last_cow_size&lt;/code&gt; : 마지막 모듈 포크 작업 동안의 copy-on-write 할당 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="4a1c104aad8f4d4ca9cc5e8c29bf1aa0162bdc19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modules&lt;/code&gt;: Module related sections</source>
          <target state="translated">&lt;code&gt;modules&lt;/code&gt; : 모듈 관련 섹션</target>
        </trans-unit>
        <trans-unit id="6a769def0c3b342307b6da05fd504fd6eadb8475" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;modules&lt;/code&gt;: Modules section</source>
          <target state="translated">&lt;code&gt;modules&lt;/code&gt; : 모듈 섹션</target>
        </trans-unit>
        <trans-unit id="8401d9f1390c809813bc32bd3d1271ab733ce35d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multi&lt;/code&gt;: number of commands in a MULTI/EXEC context</source>
          <target state="translated">&lt;code&gt;multi&lt;/code&gt; : MULTI / EXEC 컨텍스트의 명령 수</target>
        </trans-unit>
        <trans-unit id="2c8fa772aec46a276fd4408dcd12322cad2da9a6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;multiplexing_api&lt;/code&gt;: Event loop mechanism used by Redis</source>
          <target state="translated">&lt;code&gt;multiplexing_api&lt;/code&gt; : Redis에서 사용하는 이벤트 루프 메커니즘</target>
        </trans-unit>
        <trans-unit id="e0c9182e4b40c08e961e899a6e20a5633a6ee0f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;myself&lt;/code&gt;: The node you are contacting.</source>
          <target state="translated">&lt;code&gt;myself&lt;/code&gt; : 연락하는 노드.</target>
        </trans-unit>
        <trans-unit id="673f1ad7800ab1ee3a2bb4c7a04456ddf63dfbc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: Name of the module</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; : 모듈 이름</target>
        </trans-unit>
        <trans-unit id="6a436bf2963c1a3b8c958af7c5e07240e0e482f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;name&lt;/code&gt;: the name set by the client with &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; : 클라이언트가 &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME으로&lt;/a&gt; 설정 한 이름</target>
        </trans-unit>
        <trans-unit id="eb42588cab8a6e41d3563bac3bf5a966ddc7f241" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noaddr&lt;/code&gt;: No address known for this node.</source>
          <target state="translated">&lt;code&gt;noaddr&lt;/code&gt; :이 노드에 알려진 주소가 없습니다.</target>
        </trans-unit>
        <trans-unit id="147657303a81d5e12d6d7c7a341010358290596f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nocommands&lt;/code&gt;: alias for &lt;code&gt;-@all&lt;/code&gt;. Removes all the commands, the user will no longer be able to execute anything.</source>
          <target state="translated">&lt;code&gt;nocommands&lt;/code&gt; : &lt;code&gt;-@all&lt;/code&gt; 별칭 . 모든 명령을 제거하면 사용자는 더 이상 아무것도 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="588a72abc4c95194bec0e3569653d6a66d738e01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noflags&lt;/code&gt;: No flags at all.</source>
          <target state="translated">&lt;code&gt;noflags&lt;/code&gt; : 플래그가 전혀 없습니다.</target>
        </trans-unit>
        <trans-unit id="ee7ee7abe8646a7328a6876e3d63c60a61097955" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;noloop&lt;/code&gt;: The client isn't notified about keys modified by itself.</source>
          <target state="translated">&lt;code&gt;noloop&lt;/code&gt; : 클라이언트가 자체적으로 수정 한 키에 대한 알림을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2295a8f57a2ad718fc8a101a75683ddf9b1fe6f3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;nopass&lt;/code&gt;: the user is set as a &quot;no password&quot; user. It means that it will be possible to authenticate as such user with any password. By default, the &lt;code&gt;default&lt;/code&gt; special user is set as &quot;nopass&quot;. The &lt;code&gt;nopass&lt;/code&gt; rule will also reset all the configured passwords for the user.</source>
          <target state="translated">&lt;code&gt;nopass&lt;/code&gt; : 사용자가 &quot;암호 없음&quot;사용자로 설정됩니다. 이는 어떤 암호로도 해당 사용자로 인증 할 수 있음을 의미합니다. 기본적으로 &lt;code&gt;default&lt;/code&gt; 특수 사용자는 &quot;nopass&quot;로 설정됩니다. &lt;code&gt;nopass&lt;/code&gt; 의 규칙은 사용자의 모든 구성 암호를 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="f08264cef3e182cc26690ed1532909b6767c5de5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;obl&lt;/code&gt;: output buffer length</source>
          <target state="translated">&lt;code&gt;obl&lt;/code&gt; : 출력 버퍼 길이</target>
        </trans-unit>
        <trans-unit id="6dc4e4e7860139f767e29a51e1813dfe7dbdb2fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;off&lt;/code&gt;: The connection isn't using server assisted client side caching.</source>
          <target state="translated">&lt;code&gt;off&lt;/code&gt; : 연결이 서버 지원 클라이언트 측 캐싱을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="456c5347e83e30f11360f83463f2e87569342036" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;off&lt;/code&gt;: set user as not active, it will be impossible to log as this user. Please note that if a user gets disabled (set to off) after there are connections already authenticated with such a user, the connections will continue to work as expected. To also kill the old connections you can use &lt;a href=&quot;client-kill&quot;&gt;CLIENT KILL&lt;/a&gt; with the user option. An alternative is to delete the user with &lt;a href=&quot;acl-deluser&quot;&gt;ACL DELUSER&lt;/a&gt;, that will result in all the connections authenticated as the deleted user to be disconnected.</source>
          <target state="translated">&lt;code&gt;off&lt;/code&gt; : 사용자를 비활성 상태로 설정하면이 사용자로 로그인 할 수 없습니다. 해당 사용자에 대해 이미 인증 된 연결이있는 후 사용자가 비활성화 (off로 설정)되면 연결이 예상대로 계속 작동합니다. 또한 이전 연결을 종료 하려면 사용자 옵션과 함께 &lt;a href=&quot;client-kill&quot;&gt;CLIENT KILL&lt;/a&gt; 을 사용할 수 있습니다 . 대안은 &lt;a href=&quot;acl-deluser&quot;&gt;ACL DELUSER로&lt;/a&gt; 사용자를 삭제 하는 것입니다. 그러면 삭제 된 사용자로 인증 된 모든 연결이 끊어집니다.</target>
        </trans-unit>
        <trans-unit id="bbbcb3aaca80773967cf9f09226457a784353779" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;oll&lt;/code&gt;: output list length (replies are queued in this list when the buffer is full)</source>
          <target state="translated">&lt;code&gt;oll&lt;/code&gt; : 출력 목록 길이 (버퍼가 가득 차면이 목록에 회신이 대기 함)</target>
        </trans-unit>
        <trans-unit id="ba0b94233ec83c276ed7965e425a12874a6f0609" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;omem&lt;/code&gt;: output buffer memory usage</source>
          <target state="translated">&lt;code&gt;omem&lt;/code&gt; : 출력 버퍼 메모리 사용량</target>
        </trans-unit>
        <trans-unit id="f669ed89b0e5ee48624303cd659c30f39f6863c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;on&lt;/code&gt;: Server assisted client side caching is enabled for the connection.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; : 서버 지원 클라이언트 측 캐싱이 연결에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d1bf83f472040956ff3f279a1824de989115564e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;on&lt;/code&gt;: set the user as active, it will be possible to authenticate as this user using &lt;code&gt;AUTH &amp;lt;username&amp;gt; &amp;lt;password&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; : 사용자를 활성으로 설정하면 &lt;code&gt;AUTH &amp;lt;username&amp;gt; &amp;lt;password&amp;gt;&lt;/code&gt; 사용하여이 사용자로 인증 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c1338239ac70a183c1202eac1382ef73b386842" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optin&lt;/code&gt;: The client does not cache keys by default.</source>
          <target state="translated">&lt;code&gt;optin&lt;/code&gt; : 클라이언트는 기본적으로 키를 캐시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e0b2e7b657a790b5f539550f069ab5fd4514a37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optout&lt;/code&gt;: The client caches keys by default.</source>
          <target state="translated">&lt;code&gt;optout&lt;/code&gt; : 클라이언트는 기본적으로 키를 캐시합니다.</target>
        </trans-unit>
        <trans-unit id="13338a0bc1218b82c9be0432fdb97dd49851c228" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;os&lt;/code&gt;: Operating system hosting the Redis server</source>
          <target state="translated">&lt;code&gt;os&lt;/code&gt; : Redis 서버를 호스팅하는 운영 체제</target>
        </trans-unit>
        <trans-unit id="b921821db9903f46a7da2d8e5fa5fbaa99f469d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;overhead.total&lt;/code&gt;: The sum of all overheads, i.e. &lt;code&gt;startup.allocated&lt;/code&gt;, &lt;code&gt;replication.backlog&lt;/code&gt;, &lt;code&gt;clients.slaves&lt;/code&gt;, &lt;code&gt;clients.normal&lt;/code&gt;, &lt;code&gt;aof.buffer&lt;/code&gt; and those of the internal data structures that are used in managing the Redis keyspace (see &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;'s &lt;code&gt;used_memory_overhead&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;overhead.total&lt;/code&gt; : 모든 오버 헤드, 즉 &lt;code&gt;startup.allocated&lt;/code&gt; , &lt;code&gt;replication.backlog&lt;/code&gt; , &lt;code&gt;clients.slaves&lt;/code&gt; , &lt;code&gt;clients.normal&lt;/code&gt; , &lt;code&gt;aof.buffer&lt;/code&gt; 및 Redis 키 공간 관리에 사용되는 내부 데이터 구조의 합계 ( &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 's 참조) &lt;code&gt;used_memory_overhead&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b66f0f12b2e6c5406228c20ed2d84087eb7179ba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;peak.allocated&lt;/code&gt;: Peak memory consumed by Redis in bytes (see &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;'s &lt;code&gt;used_memory&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;peak.allocated&lt;/code&gt; : Redis가 소비 한 최대 메모리 (바이트) ( &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 의 &lt;code&gt;used_memory&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="09bf3c6a90b5c55437b2fe4763be03aa49b2d8b3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;peak.allocated&lt;/code&gt;: Peak memory consumed by Redis in bytes (see &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;'s &lt;code&gt;used_memory_peak&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;peak.allocated&lt;/code&gt; : Redis가 사용하는 최대 메모리 (바이트) ( &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 의 &lt;code&gt;used_memory_peak&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="9104c5033ce661c1a0960c0256c747a7e1462163" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;peak.percentage&lt;/code&gt;: The percentage of &lt;code&gt;peak.allocated&lt;/code&gt; out of &lt;code&gt;total.allocated&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;peak.percentage&lt;/code&gt; :의 비율 &lt;code&gt;peak.allocated&lt;/code&gt; 밖으로 &lt;code&gt;total.allocated&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ee46e3f9df2301d2c9d9f49311b2a6be9a794102" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;persistence&lt;/code&gt;: RDB and AOF related information</source>
          <target state="translated">&lt;code&gt;persistence&lt;/code&gt; : RDB 및 AOF 관련 정보</target>
        </trans-unit>
        <trans-unit id="340ca7ffebd56548b44ad85ca71ded648b8a9fe0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ping-sent&lt;/code&gt;: Milliseconds unix time at which the currently active ping was sent, or zero if there are no pending pings.</source>
          <target state="translated">&lt;code&gt;ping-sent&lt;/code&gt; : 현재 활성 핑이 전송 된 유닉스 시간 (밀리 초), 보류중인 핑이없는 경우 0</target>
        </trans-unit>
        <trans-unit id="2ce7201393232bb0529b46b4ad49ad2d100d7a0e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pong-recv&lt;/code&gt;: Milliseconds unix time the last pong was received.</source>
          <target state="translated">&lt;code&gt;pong-recv&lt;/code&gt; : 마지막 pong을받은 시간 (밀리 초)</target>
        </trans-unit>
        <trans-unit id="bf141066fc22e3fcd741fa0973e91924088de0cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;process_id&lt;/code&gt;: PID of the server process</source>
          <target state="translated">&lt;code&gt;process_id&lt;/code&gt; : 서버 프로세스의 PID</target>
        </trans-unit>
        <trans-unit id="01197709a5335bdf7b938279bba3370a78eaa4e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;psub&lt;/code&gt;: number of pattern matching subscriptions</source>
          <target state="translated">&lt;code&gt;psub&lt;/code&gt; : 패턴 일치 구독 수</target>
        </trans-unit>
        <trans-unit id="5d9782c719f3108a6648d4a697460354d47034e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pubsub_channels&lt;/code&gt;: Global number of pub/sub channels with client subscriptions</source>
          <target state="translated">&lt;code&gt;pubsub_channels&lt;/code&gt; : 클라이언트 구독이있는 글로벌 pub / sub 채널 수</target>
        </trans-unit>
        <trans-unit id="d18b3633027d3c201e4b17aacba16c5886fee7ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pubsub_patterns&lt;/code&gt;: Global number of pub/sub pattern with client subscriptions</source>
          <target state="translated">&lt;code&gt;pubsub_patterns&lt;/code&gt; : 클라이언트 구독이있는 글로벌 발행 / 구독 패턴 수</target>
        </trans-unit>
        <trans-unit id="09a490885df7985f548424c575c27793c1e801cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qbuf-free&lt;/code&gt;: free space of the query buffer (0 means the buffer is full)</source>
          <target state="translated">&lt;code&gt;qbuf-free&lt;/code&gt; : 쿼리 버퍼의 여유 공간 (0은 버퍼가 가득 찼음을 의미)</target>
        </trans-unit>
        <trans-unit id="e1eb072bfc64b27b4e211a82d13ebb8cf4b88ffd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;qbuf&lt;/code&gt;: query buffer length (0 means no query pending)</source>
          <target state="translated">&lt;code&gt;qbuf&lt;/code&gt; : 쿼리 버퍼 길이 (0은 쿼리 보류가 없음을 의미)</target>
        </trans-unit>
        <trans-unit id="49c7f37dd4cd7c1eef2f06a26ec6a39e6f1f9af7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rdb_bgsave_in_progress&lt;/code&gt;: Flag indicating a RDB save is on-going</source>
          <target state="translated">&lt;code&gt;rdb_bgsave_in_progress&lt;/code&gt; : RDB 저장이 진행 중임을 나타내는 플래그</target>
        </trans-unit>
        <trans-unit id="92fe7954c975428c9f5ce862a86e9e6d556669a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rdb_changes_since_last_save&lt;/code&gt; refers to the number of operations that produced some kind of changes in the dataset since the last time either &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; or &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; was called.</source>
          <target state="translated">&lt;code&gt;rdb_changes_since_last_save&lt;/code&gt; 는 &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; 또는 &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; 가 마지막 으로 호출 된 이후 데이터 집합에서 일종의 변경 사항을 생성 한 작업 수를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="0e1b0e631149e31b0f9b8d6bac185af69540b23d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rdb_changes_since_last_save&lt;/code&gt;: Number of changes since the last dump</source>
          <target state="translated">&lt;code&gt;rdb_changes_since_last_save&lt;/code&gt; : 마지막 덤프 이후의 변경 수</target>
        </trans-unit>
        <trans-unit id="5e167b550eaa7334a4af54871fb995b0b3d14833" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rdb_current_bgsave_time_sec&lt;/code&gt;: Duration of the on-going RDB save operation if any</source>
          <target state="translated">&lt;code&gt;rdb_current_bgsave_time_sec&lt;/code&gt; : 진행중인 RDB 저장 작업의 지속 기간</target>
        </trans-unit>
        <trans-unit id="846322c9f133b635731fc1ad09c1e21e41814e1e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rdb_last_bgsave_status&lt;/code&gt;: Status of the last RDB save operation</source>
          <target state="translated">&lt;code&gt;rdb_last_bgsave_status&lt;/code&gt; : 마지막 RDB 저장 작업의 상태</target>
        </trans-unit>
        <trans-unit id="4ec4734db22843dfa1c0c6421831771884151288" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rdb_last_bgsave_time_sec&lt;/code&gt;: Duration of the last RDB save operation in seconds</source>
          <target state="translated">&lt;code&gt;rdb_last_bgsave_time_sec&lt;/code&gt; : 마지막 RDB 저장 작업 지속 시간 (초)</target>
        </trans-unit>
        <trans-unit id="be124bd94d7dd238582a9b91439d97057cfe5476" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rdb_last_cow_size&lt;/code&gt;: The size in bytes of copy-on-write allocations during the last RBD save operation</source>
          <target state="translated">&lt;code&gt;rdb_last_cow_size&lt;/code&gt; : 마지막 RBD 저장 작업 중 기록 중 복사 할당의 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="9fa69d32fbd56417be035fb08ca5eca0195fb799" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rdb_last_cow_size&lt;/code&gt;: The size in bytes of copy-on-write allocations during the last RDB save operation</source>
          <target state="translated">&lt;code&gt;rdb_last_cow_size&lt;/code&gt; : 마지막 RDB 저장 작업 동안의 copy-on-write 할당 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="31ec0a2188669177796fd5ed7732b24095c34872" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rdb_last_save_time&lt;/code&gt;: Epoch-based timestamp of last successful RDB save</source>
          <target state="translated">&lt;code&gt;rdb_last_save_time&lt;/code&gt; : 마지막으로 성공한 RDB 저장의 Epoch 기반 타임 스탬프</target>
        </trans-unit>
        <trans-unit id="357e259918283daebf12b43ef58e7238eb19408c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redir&lt;/code&gt;: client id of current client tracking redirection</source>
          <target state="translated">&lt;code&gt;redir&lt;/code&gt; : 현재 클라이언트 추적 리디렉션의 클라이언트 ID</target>
        </trans-unit>
        <trans-unit id="5830999758618fbec95f0cb84ec74b9013df9939" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis.breakpoint and redis.debug&lt;/code&gt; function in the context of the &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Redis Lua debugger&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;redis.breakpoint and redis.debug&lt;/code&gt; 컨텍스트에 함수 &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;레디 스 루아 디버거&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6cfa5a17847f90f659a75435f90fdf87414f735" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis.call()&lt;/code&gt; is similar to &lt;code&gt;redis.pcall()&lt;/code&gt;, the only difference is that if a Redis command call will result in an error, &lt;code&gt;redis.call()&lt;/code&gt; will raise a Lua error that in turn will force &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; to return an error to the command caller, while &lt;code&gt;redis.pcall&lt;/code&gt; will trap the error and return a Lua table representing the error.</source>
          <target state="translated">&lt;code&gt;redis.call()&lt;/code&gt; 유사하다 &lt;code&gt;redis.pcall()&lt;/code&gt; 유일한 차이점은 레디 스 명령 호출 오류가 발생한다면,이다 &lt;code&gt;redis.call()&lt;/code&gt; 차례로 강제하는 루아 에러 올릴 &lt;a href=&quot;eval&quot;&gt;EVAL를&lt;/a&gt; 오류를 반환을 명령 호출자에게, 동안 &lt;code&gt;redis.pcall&lt;/code&gt; 의 의지 트랩 오류 및 오류를 나타내는 루아 테이블을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cc1c903bdb48793f0e4f48c01b73479cb762bb36" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis.error_reply(error_string)&lt;/code&gt; returns an error reply. This function simply returns a single field table with the &lt;code&gt;err&lt;/code&gt; field set to the specified string for you.</source>
          <target state="translated">&lt;code&gt;redis.error_reply(error_string)&lt;/code&gt; 는 오류 응답을 반환합니다. 이 함수는 단순히 &lt;code&gt;err&lt;/code&gt; 필드가 지정된 문자열로 설정된 단일 필드 테이블을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="ae82951de9075482aaf5f1ae88227fb45a6550f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis.sha1hex&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;redis.sha1hex&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="9242be04d881f15c4a713681eb55c02628ce5b41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis.status_reply(status_string)&lt;/code&gt; returns a status reply. This function simply returns a single field table with the &lt;code&gt;ok&lt;/code&gt; field set to the specified string for you.</source>
          <target state="translated">&lt;code&gt;redis.status_reply(status_string)&lt;/code&gt; 은 상태 응답을 반환합니다. 이 함수는 &lt;code&gt;ok&lt;/code&gt; 필드가 지정된 문자열로 설정된 단일 필드 테이블을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="95dffb65f94cfa6e4df78dc1f8106938d0a2b8e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis_build_id&lt;/code&gt;: The build id</source>
          <target state="translated">&lt;code&gt;redis_build_id&lt;/code&gt; : 빌드 ID</target>
        </trans-unit>
        <trans-unit id="4a5d613bfeccb609043a3093f50079862794e426" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis_git_dirty&lt;/code&gt;: Git dirty flag</source>
          <target state="translated">&lt;code&gt;redis_git_dirty&lt;/code&gt; : 힘내 더러운 플래그</target>
        </trans-unit>
        <trans-unit id="be06e01599e134053f70a0365a7a6ffe0b546351" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis_git_sha1&lt;/code&gt;: Git SHA1</source>
          <target state="translated">&lt;code&gt;redis_git_sha1&lt;/code&gt; : 힘내 SHA1</target>
        </trans-unit>
        <trans-unit id="f4a6779415fbc51c11e3f399963af6fe485e8883" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis_mode&lt;/code&gt;: The server's mode (&quot;standalone&quot;, &quot;sentinel&quot; or &quot;cluster&quot;)</source>
          <target state="translated">&lt;code&gt;redis_mode&lt;/code&gt; : 서버 모드 ( &quot;독립형&quot;, &quot;센티넬&quot;또는 &quot;클러스터&quot;)</target>
        </trans-unit>
        <trans-unit id="6d0cc6894f88d6a671c3cf47afe1c3a49b400f41" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;redis_version&lt;/code&gt;: Version of the Redis server</source>
          <target state="translated">&lt;code&gt;redis_version&lt;/code&gt; : Redis 서버의 버전</target>
        </trans-unit>
        <trans-unit id="9d5b407137e452587ef4b30cbb1dffa17cb34b01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rejected_connections&lt;/code&gt;: Number of connections rejected because of &lt;code&gt;maxclients&lt;/code&gt; limit</source>
          <target state="translated">&lt;code&gt;rejected_connections&lt;/code&gt; : &lt;code&gt;maxclients&lt;/code&gt; 제한으로 인해 거부 된 연결 수</target>
        </trans-unit>
        <trans-unit id="9261b493db72e9a8f282354e217ba34c5ad53405" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repl_backlog_active&lt;/code&gt;: Flag indicating replication backlog is active</source>
          <target state="translated">&lt;code&gt;repl_backlog_active&lt;/code&gt; : 복제 백 로그가 활성화되었음을 나타내는 플래그</target>
        </trans-unit>
        <trans-unit id="f65d25f6479576d1d8b26887d1fb13af0342f5d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repl_backlog_first_byte_offset&lt;/code&gt;: The master offset of the replication backlog buffer</source>
          <target state="translated">&lt;code&gt;repl_backlog_first_byte_offset&lt;/code&gt; : 복제 백 로그 버퍼의 마스터 오프셋</target>
        </trans-unit>
        <trans-unit id="bd97e1abe8b7a64c9bd426b10a483c5470f1c33c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repl_backlog_histlen&lt;/code&gt;: Size in bytes of the data in the replication backlog buffer</source>
          <target state="translated">&lt;code&gt;repl_backlog_histlen&lt;/code&gt; : 복제 백 로그 버퍼에있는 데이터의 바이트 크기</target>
        </trans-unit>
        <trans-unit id="557cd508a8f74f5840ee1e5bbbf75af8aaba9343" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;repl_backlog_size&lt;/code&gt;: Total size in bytes of the replication backlog buffer</source>
          <target state="translated">&lt;code&gt;repl_backlog_size&lt;/code&gt; : 복제 백 로그 버퍼의 총 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="6a9727ee6cf769f12aba8b2c3ca8d9de1e46e53d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replication.backlog&lt;/code&gt;: Size in bytes of the replication backlog (see &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;'s &lt;code&gt;repl_backlog_active&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;replication.backlog&lt;/code&gt; : 복제 백 로그의 크기 (바이트) ( &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 의 &lt;code&gt;repl_backlog_active&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="a057f81f3ebf543b442081cf23f0e823d88e17de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replication.backlog&lt;/code&gt;: Size in bytes of the replication backlog (see &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;'s &lt;code&gt;repl_backlog_size&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;replication.backlog&lt;/code&gt; : 복제 백 로그의 크기 (바이트) ( &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 의 &lt;code&gt;repl_backlog_size&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="f1c655643163a917b01bdcd322f040536467b197" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;replication&lt;/code&gt;: Master/replica replication information</source>
          <target state="translated">&lt;code&gt;replication&lt;/code&gt; : 마스터 / 복제본 복제 정보</target>
        </trans-unit>
        <trans-unit id="65df5fcdcc1925305889fd5c54411266ece07136" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resetchannels&lt;/code&gt;: removes all channel patterns from the list of Pub/Sub channel patterns the user can access.</source>
          <target state="translated">&lt;code&gt;resetchannels&lt;/code&gt; : 사용자가 액세스 할 수있는 Pub / Sub 채널 패턴 목록에서 모든 채널 패턴을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="5ee2315dc5d95730b9ebcdd7878d602513446e70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;resetkeys&lt;/code&gt;: removes all the key patterns from the list of key patterns the user can access.</source>
          <target state="translated">&lt;code&gt;resetkeys&lt;/code&gt; : 사용자가 액세스 할 수있는 키 패턴 목록에서 모든 키 패턴을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="d4fda8cca4271f45584288721b06d5666e8e23f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;role&lt;/code&gt;: Value is &quot;master&quot; if the instance is replica of no one, or &quot;slave&quot; if the instance is a replica of some master instance. Note that a replica can be master of another replica (chained replication).</source>
          <target state="translated">&lt;code&gt;role&lt;/code&gt; : 인스턴스가 아무도의 복제본이 아닌 경우 값은 &quot;master&quot;이고 인스턴스가 일부 마스터 인스턴스의 복제 본인 경우 &quot;slave&quot;입니다. 복제본은 다른 복제본 (체인 복제)의 마스터가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fcb9fab53582ec8f7fcfeae342be7427032711d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run_id&lt;/code&gt;: Random value identifying the Redis server (to be used by Sentinel and Cluster)</source>
          <target state="translated">&lt;code&gt;run_id&lt;/code&gt; : Redis 서버를 식별하는 임의의 값 (Sentinel 및 Cluster에서 사용)</target>
        </trans-unit>
        <trans-unit id="2fc99f4ec57868b8f80a7e424052d862184fb904" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;second_repl_offset&lt;/code&gt;: The offset up to which replication IDs are accepted</source>
          <target state="translated">&lt;code&gt;second_repl_offset&lt;/code&gt; : 복제 ID가 허용되는 오프셋</target>
        </trans-unit>
        <trans-unit id="b919add2279ee146a4b3e724e618e5340f0c5330" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server&lt;/code&gt;: General information about the Redis server</source>
          <target state="translated">&lt;code&gt;server&lt;/code&gt; : Redis 서버에 대한 일반 정보</target>
        </trans-unit>
        <trans-unit id="89e5096ab88aceffb8212aef7189959a6955637b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;server_time_in_usec&lt;/code&gt;: Epoch-based system time with microsecond precision</source>
          <target state="translated">&lt;code&gt;server_time_in_usec&lt;/code&gt; : 마이크로 초 정밀도의 Epoch 기반 시스템 시간</target>
        </trans-unit>
        <trans-unit id="1c3e299e02d66f7763bd03b36050606a98337677" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slave&lt;/code&gt;: Node is a replica.</source>
          <target state="translated">&lt;code&gt;slave&lt;/code&gt; : 노드가 복제본입니다.</target>
        </trans-unit>
        <trans-unit id="66ad5502d3be0f9a00c02cbbbce0c3d7f5b53b2f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slaveXXX&lt;/code&gt;: id, IP address, port, state, offset, lag</source>
          <target state="translated">&lt;code&gt;slaveXXX&lt;/code&gt; : 아이디, IP 주소, 포트, 상태, 오프셋, 지연</target>
        </trans-unit>
        <trans-unit id="8590a5d28341df0626cb29b0328299f2bd613561" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slave_expires_tracked_keys&lt;/code&gt;: The number of keys tracked for expiry purposes (applicable only to writable replicas)</source>
          <target state="translated">&lt;code&gt;slave_expires_tracked_keys&lt;/code&gt; : 만료 목적으로 추적 된 키 수 (쓰기 가능한 복제본에만 적용 가능)</target>
        </trans-unit>
        <trans-unit id="b5d40a447d20543abadb672f27493ec5954585cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slave_priority&lt;/code&gt;: The priority of the instance as a candidate for failover</source>
          <target state="translated">&lt;code&gt;slave_priority&lt;/code&gt; : 장애 조치의 후보 인 인스턴스의 우선 순위</target>
        </trans-unit>
        <trans-unit id="12b3222be64789eded1e9e2d87b7eebc6d362e1c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slave_read_only&lt;/code&gt;: Flag indicating if the replica is read-only</source>
          <target state="translated">&lt;code&gt;slave_read_only&lt;/code&gt; : 복제본이 읽기 전용인지를 나타내는 플래그</target>
        </trans-unit>
        <trans-unit id="f78e6ef30c26728d64ec819ef78cee2c7eeecb35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slave_repl_offset&lt;/code&gt;: The replication offset of the replica instance</source>
          <target state="translated">&lt;code&gt;slave_repl_offset&lt;/code&gt; : 복제본 인스턴스의 복제 오프셋</target>
        </trans-unit>
        <trans-unit id="0dc07283433da9c75fa880f47921ded317a31db7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slot&lt;/code&gt;: A hash slot number or range. Starting from argument number 9, but there may be up to 16384 entries in total (limit never reached). This is the list of hash slots served by this node. If the entry is just a number, is parsed as such. If it is a range, it is in the form &lt;code&gt;start-end&lt;/code&gt;, and means that the node is responsible for all the hash slots from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;end&lt;/code&gt; including the start and end values.</source>
          <target state="translated">&lt;code&gt;slot&lt;/code&gt; : 해시 슬롯 번호 또는 범위. 인수 번호 9부터 시작하지만 총 16384 개의 항목이있을 수 있습니다 (제한에 도달하지 않음). 이 노드가 제공하는 해시 슬롯 목록입니다. 항목이 숫자 인 경우 구문 분석됩니다. 이 범위 인 경우,이 형태에 &lt;code&gt;start-end&lt;/code&gt; 및 노드로부터의 모든 해시 슬롯 담당하는 수단을 &lt;code&gt;start&lt;/code&gt; 하는 &lt;code&gt;end&lt;/code&gt; 시작과 끝 값을 포함.</target>
        </trans-unit>
        <trans-unit id="2ad93ec63621004e682aca5fc8cc051cc1f4308d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; can also be negative numbers indicating offsets from the end of the list, where &lt;code&gt;-1&lt;/code&gt; is the last element of the list, &lt;code&gt;-2&lt;/code&gt; the penultimate element and so on.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 는 목록의 끝에서 오프셋을 나타내는 음수 일 수도 있습니다. 여기서 &lt;code&gt;-1&lt;/code&gt; 은 목록 의 마지막 요소이고, &lt;code&gt;-2&lt;/code&gt; 는 두 번째 요소입니다.</target>
        </trans-unit>
        <trans-unit id="07ea2259c89c349346cf2cd869db8cb79d5f74c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are &lt;strong&gt;inclusive ranges&lt;/strong&gt;, so for example &lt;code&gt;ZRANGE myzset 0 1&lt;/code&gt; will return both the first and the second element of the sorted set.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 은 &lt;strong&gt;포괄적 인 범위&lt;/strong&gt; 이므로 예를 들어 &lt;code&gt;ZRANGE myzset 0 1&lt;/code&gt; 은 정렬 된 집합의 첫 번째 요소와 두 번째 요소를 모두 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0ae7b1554f80d3f51903f1dff8325a408a1c655f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;startup.allocated&lt;/code&gt;: Initial amount of memory consumed by Redis at startup in bytes (see &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;'s &lt;code&gt;used_memory_startup&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;startup.allocated&lt;/code&gt; : Redis가 시작할 때 소비 한 초기 메모리 양 (바이트) ( &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 의 &lt;code&gt;used_memory_startup&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="aac658ac592bbf9956f86b4bac69afd3027558df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stats&lt;/code&gt;: General statistics</source>
          <target state="translated">&lt;code&gt;stats&lt;/code&gt; : 일반 통계</target>
        </trans-unit>
        <trans-unit id="dc6e6dc03a40ad7a9125f38b3e026a8f3556d050" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; lib.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; lib.</target>
        </trans-unit>
        <trans-unit id="0aa667ebb47bb2b0fe1c8159a627ad9405def74b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;struct&lt;/code&gt; lib.</source>
          <target state="translated">&lt;code&gt;struct&lt;/code&gt; lib.</target>
        </trans-unit>
        <trans-unit id="cf417ec8379e7520d81488517f3183736a01c2a4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sub&lt;/code&gt;: number of channel subscriptions</source>
          <target state="translated">&lt;code&gt;sub&lt;/code&gt; : 채널 구독 수</target>
        </trans-unit>
        <trans-unit id="15d05077570de6f81b3d6da791243510608db5c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sync_full&lt;/code&gt;: The number of full resyncs with replicas</source>
          <target state="translated">&lt;code&gt;sync_full&lt;/code&gt; : 복제본과의 전체 재 동기화 수</target>
        </trans-unit>
        <trans-unit id="4ee5a998d34ab5cad1998f3ebf567719bea12098" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sync_partial_err&lt;/code&gt;: The number of denied partial resync requests</source>
          <target state="translated">&lt;code&gt;sync_partial_err&lt;/code&gt; : 거부 된 부분 재 동기화 요청 수</target>
        </trans-unit>
        <trans-unit id="d56fb4657b9d596dc7d0384ee7df8b86b275cd39" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sync_partial_ok&lt;/code&gt;: The number of accepted partial resync requests</source>
          <target state="translated">&lt;code&gt;sync_partial_ok&lt;/code&gt; : 승인 된 부분 재 동기화 요청 수</target>
        </trans-unit>
        <trans-unit id="8b77b42cf8709c944a161998b16919cbde5e9bf8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;table&lt;/code&gt; lib.</source>
          <target state="translated">&lt;code&gt;table&lt;/code&gt; lib.</target>
        </trans-unit>
        <trans-unit id="5f4c32aa62999ab55968bad6e6e4efa2abf72e32" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tcp_port&lt;/code&gt;: TCP/IP listen port</source>
          <target state="translated">&lt;code&gt;tcp_port&lt;/code&gt; : TCP / IP 청취 포트</target>
        </trans-unit>
        <trans-unit id="904fe5f1ac4e4db4dda479f37fe4605aa72fcf2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tot-mem&lt;/code&gt;: total memory consumed by this client in its various buffers</source>
          <target state="translated">&lt;code&gt;tot-mem&lt;/code&gt; : 다양한 버퍼에서이 클라이언트가 사용하는 총 메모리</target>
        </trans-unit>
        <trans-unit id="7a498bccca27f60dfda24f1e659686e8d0e830dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total.allocated&lt;/code&gt;: Total number of bytes allocated by Redis using its allocator (see &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt;'s &lt;code&gt;used_memory&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;total.allocated&lt;/code&gt; : Redis가 할당자를 사용하여 할당 한 총 바이트 수 ( &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 의 &lt;code&gt;used_memory&lt;/code&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="8732c8368635afc5fa8927a34d3dccabbdb65191" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total_commands_processed&lt;/code&gt;: Total number of commands processed by the server</source>
          <target state="translated">&lt;code&gt;total_commands_processed&lt;/code&gt; : 서버에서 처리 한 총 명령 수</target>
        </trans-unit>
        <trans-unit id="bba102c4ab9c62037cd444acc6a549a4b9e8ad63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total_connections_received&lt;/code&gt;: Total number of connections accepted by the server</source>
          <target state="translated">&lt;code&gt;total_connections_received&lt;/code&gt; : 서버가 승인 한 총 연결 수</target>
        </trans-unit>
        <trans-unit id="d83068e206f7307d94a9bc1022cb8ab9b5f64256" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total_forks&lt;/code&gt;: Total number of fork operations since the server start</source>
          <target state="translated">&lt;code&gt;total_forks&lt;/code&gt; : 서버 시작 이후 총 포크 작업 수</target>
        </trans-unit>
        <trans-unit id="ddb9178a813478a27e4593a26fff3a0f64d21fbd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total_net_input_bytes&lt;/code&gt;: The total number of bytes read from the network</source>
          <target state="translated">&lt;code&gt;total_net_input_bytes&lt;/code&gt; : 네트워크에서 읽은 총 바이트 수</target>
        </trans-unit>
        <trans-unit id="f2acfa27965fd73d49ec07d748f9b3cb6e09fbe6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total_net_output_bytes&lt;/code&gt;: The total number of bytes written to the network</source>
          <target state="translated">&lt;code&gt;total_net_output_bytes&lt;/code&gt; : 네트워크에 쓴 총 바이트 수</target>
        </trans-unit>
        <trans-unit id="b8ae6397172f63245706d6e00f0a769d888f263b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total_reads_processed&lt;/code&gt;: Total number of read events processed</source>
          <target state="translated">&lt;code&gt;total_reads_processed&lt;/code&gt; : 처리 된 총 읽기 이벤트 수</target>
        </trans-unit>
        <trans-unit id="ffbec4c806f626a60a4cfe6af281d77a37b8bc37" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total_system_memory&lt;/code&gt;: The total amount of memory that the Redis host has</source>
          <target state="translated">&lt;code&gt;total_system_memory&lt;/code&gt; : Redis 호스트가 보유한 총 메모리 양</target>
        </trans-unit>
        <trans-unit id="31873b8d2809ee8ad0f6783fbe886c044ac76c6b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total_system_memory_human&lt;/code&gt;: Human readable representation of previous value</source>
          <target state="translated">&lt;code&gt;total_system_memory_human&lt;/code&gt; : 인간이 읽을 수있는 이전 값 표현</target>
        </trans-unit>
        <trans-unit id="fb7948dcbe177ae1b024b855cc9dfbe5390aef57" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total_writes_processed&lt;/code&gt;: Total number of write events processed</source>
          <target state="translated">&lt;code&gt;total_writes_processed&lt;/code&gt; : 처리 된 총 쓰기 이벤트 수</target>
        </trans-unit>
        <trans-unit id="381792f4c3048d356d56009554576a2abeb871de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tracking_clients&lt;/code&gt;: Number of clients being tracked (&lt;a href=&quot;client-tracking&quot;&gt;CLIENT TRACKING&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;tracking_clients&lt;/code&gt; : 추적 중인 클라이언트 수 ( &lt;a href=&quot;client-tracking&quot;&gt;CLIENT TRACKING&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="21568a3bfb8f0f36758dc6083f7d615df21139ca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tracking_total_items&lt;/code&gt;: Number of items, that is the sum of clients number for each key, that are being tracked</source>
          <target state="translated">&lt;code&gt;tracking_total_items&lt;/code&gt; : 추적 중인 각 키에 대한 클라이언트 수의 합계 인 항목 수</target>
        </trans-unit>
        <trans-unit id="4b4583ea3b802ba8a2a781314e306b345c0d006c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tracking_total_keys&lt;/code&gt;: Number of keys being tracked by the server</source>
          <target state="translated">&lt;code&gt;tracking_total_keys&lt;/code&gt; : 서버에서 추적중인 키 수</target>
        </trans-unit>
        <trans-unit id="e748a1f26d4e4ced34d3b01cc7fdb07e64e66073" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tracking_total_prefixes&lt;/code&gt;: Number of tracked prefixes in server's prefix table (only applicable for broadcast mode)</source>
          <target state="translated">&lt;code&gt;tracking_total_prefixes&lt;/code&gt; : 서버의 접두사 테이블에서 추적 된 접두사 수 (브로드 캐스트 모드에만 적용 가능)</target>
        </trans-unit>
        <trans-unit id="b118b4757401e1598e87eb7b6c3f8f276db134ff" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unexpected_error_replies&lt;/code&gt;: Number of unexpected error replies, that are types of errors from an AOF load or replication</source>
          <target state="translated">&lt;code&gt;unexpected_error_replies&lt;/code&gt; : AOF로드 또는 복제의 오류 유형 인 예기치 않은 오류 응답 수</target>
        </trans-unit>
        <trans-unit id="db781a30ee27c1d77274c222dc88bb433b11afbc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uptime_in_days&lt;/code&gt;: Same value expressed in days</source>
          <target state="translated">&lt;code&gt;uptime_in_days&lt;/code&gt; : 일 단위로 표시되는 동일한 값</target>
        </trans-unit>
        <trans-unit id="1d3efd1a0fc42457b2846dac85051e5e87a22e7f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uptime_in_seconds&lt;/code&gt;: Number of seconds since Redis server start</source>
          <target state="translated">&lt;code&gt;uptime_in_seconds&lt;/code&gt; : Redis 서버 시작 이후의 시간 (초)</target>
        </trans-unit>
        <trans-unit id="bb5cc56d21b4b399bf28e2d4ced848cedc2a3139" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_cpu_sys&lt;/code&gt;: System CPU consumed by the Redis server</source>
          <target state="translated">&lt;code&gt;used_cpu_sys&lt;/code&gt; : Redis 서버가 사용하는 시스템 CPU</target>
        </trans-unit>
        <trans-unit id="6d569724d89cfda91003844b75e183bdd906bc5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_cpu_sys&lt;/code&gt;: System CPU consumed by the Redis server, which is the sum of system CPU consumed by all threads of the server process (main thread and background threads)</source>
          <target state="translated">&lt;code&gt;used_cpu_sys&lt;/code&gt; : Redis 서버가 사용하는 시스템 CPU, 서버 프로세스의 모든 스레드 (주 스레드 및 백그라운드 스레드)가 사용하는 시스템 CPU의 합계입니다.</target>
        </trans-unit>
        <trans-unit id="1b287b02ee3142edf7304f38f36d07536453e874" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_cpu_sys_children&lt;/code&gt;: System CPU consumed by the background processes</source>
          <target state="translated">&lt;code&gt;used_cpu_sys_children&lt;/code&gt; : 백그라운드 프로세스가 사용하는 시스템 CPU</target>
        </trans-unit>
        <trans-unit id="21f11ba65a2773ebe0c8ef659d6a1ffa1fd42d2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_cpu_sys_main_thread&lt;/code&gt;: System CPU consumed by the Redis server main thread</source>
          <target state="translated">&lt;code&gt;used_cpu_sys_main_thread&lt;/code&gt; : Redis 서버 메인 스레드가 사용하는 시스템 CPU</target>
        </trans-unit>
        <trans-unit id="e3e58d3a9e668c76dc2ab457a7ac3e52ec38676e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_cpu_user&lt;/code&gt;: User CPU consumed by the Redis server, which is the sum of user CPU consumed by all threads of the server process (main thread and background threads)</source>
          <target state="translated">&lt;code&gt;used_cpu_user&lt;/code&gt; : Redis 서버가 사용하는 사용자 CPU, 서버 프로세스의 모든 스레드 (주 스레드 및 백그라운드 스레드)가 사용하는 사용자 CPU의 합계입니다.</target>
        </trans-unit>
        <trans-unit id="0fac00be35e10304849ab0c04bb8d430ec4729f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_cpu_user&lt;/code&gt;:User CPU consumed by the Redis server</source>
          <target state="translated">&lt;code&gt;used_cpu_user&lt;/code&gt; : Redis 서버가 소비 한 사용자 CPU</target>
        </trans-unit>
        <trans-unit id="32e2bdff3caa89cf5c85a6fc4f65e29f75d7cb82" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_cpu_user_children&lt;/code&gt;: User CPU consumed by the background processes</source>
          <target state="translated">&lt;code&gt;used_cpu_user_children&lt;/code&gt; : 백그라운드 프로세스가 소비 한 사용자 CPU</target>
        </trans-unit>
        <trans-unit id="4cc4736c16fc254bddd47233986c61235a9faf5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_cpu_user_main_thread&lt;/code&gt;: User CPU consumed by the Redis server main thread</source>
          <target state="translated">&lt;code&gt;used_cpu_user_main_thread&lt;/code&gt; : Redis 서버 메인 스레드에서 사용하는 사용자 CPU</target>
        </trans-unit>
        <trans-unit id="77ca1a3d5b20d2fe23c4fa22849f242d4c267b4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory&lt;/code&gt;: Total number of bytes allocated by Redis using its allocator (either standard &lt;strong&gt;libc&lt;/strong&gt;, &lt;strong&gt;jemalloc&lt;/strong&gt;, or an alternative allocator such as &lt;a href=&quot;http://code.google.com/p/google-perftools/&quot;&gt;&lt;strong&gt;tcmalloc&lt;/strong&gt;&lt;/a&gt;)</source>
          <target state="translated">&lt;code&gt;used_memory&lt;/code&gt; : Redis가 할당자를 사용하여 할당 한 총 바이트 수 (표준 &lt;strong&gt;libc&lt;/strong&gt; , &lt;strong&gt;jemalloc&lt;/strong&gt; 또는 &lt;a href=&quot;http://code.google.com/p/google-perftools/&quot;&gt;&lt;strong&gt;tcmalloc&lt;/strong&gt;&lt;/a&gt; 와 같은 대체 할당 자 )</target>
        </trans-unit>
        <trans-unit id="e5edb87c5fcdf155299748be8ed3a1d847dc6cf8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_dataset&lt;/code&gt;: The size in bytes of the dataset (&lt;code&gt;used_memory_overhead&lt;/code&gt; subtracted from &lt;code&gt;used_memory&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;used_memory_dataset&lt;/code&gt; : 데이터 세트의 크기 (바이트) ( &lt;code&gt;used_memory_overhead&lt;/code&gt; 에서 &lt;code&gt;used_memory&lt;/code&gt; _overhead 빼기 )</target>
        </trans-unit>
        <trans-unit id="99463f967dca2170b9430687aa7dbdadaaa6e185" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_dataset_perc&lt;/code&gt;: The percentage of &lt;code&gt;used_memory_dataset&lt;/code&gt; out of the net memory usage (&lt;code&gt;used_memory&lt;/code&gt; minus &lt;code&gt;used_memory_startup&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;used_memory_dataset_perc&lt;/code&gt; : 순 메모리 사용량 중 &lt;code&gt;used_memory_dataset&lt;/code&gt; 의 백분율 ( &lt;code&gt;used_memory&lt;/code&gt; 빼기 &lt;code&gt;used_memory_startup&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="7a873e6bb787aea94d53809b33b1786346d9947a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_human&lt;/code&gt;: Human readable representation of previous value</source>
          <target state="translated">&lt;code&gt;used_memory_human&lt;/code&gt; : 인간이 읽을 수있는 이전 값 표현</target>
        </trans-unit>
        <trans-unit id="fca7c10926c6d6ae012fbedbc1f22b125c98a72d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_lua&lt;/code&gt;: Number of bytes used by the Lua engine</source>
          <target state="translated">&lt;code&gt;used_memory_lua&lt;/code&gt; : Lua 엔진이 사용하는 바이트 수</target>
        </trans-unit>
        <trans-unit id="7d073a6daf2616a502a610857a51fabf502e5a35" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_lua_human&lt;/code&gt;: Human readable representation of previous value</source>
          <target state="translated">&lt;code&gt;used_memory_lua_human&lt;/code&gt; : 인간이 읽을 수있는 이전 값 표현</target>
        </trans-unit>
        <trans-unit id="efb76ba4512345b95521d24d896546b1f24843e0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_overhead&lt;/code&gt;: The sum in bytes of all overheads that the server allocated for managing its internal data structures</source>
          <target state="translated">&lt;code&gt;used_memory_overhead&lt;/code&gt; : 서버가 내부 데이터 구조를 관리하기 위해 할당 한 모든 오버 헤드의 바이트 단위 합계</target>
        </trans-unit>
        <trans-unit id="03d2893cfc679a9464da447794034819fd2c6f44" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_peak&lt;/code&gt;: Peak memory consumed by Redis (in bytes)</source>
          <target state="translated">&lt;code&gt;used_memory_peak&lt;/code&gt; : Redis가 소비 한 최대 메모리 (바이트)</target>
        </trans-unit>
        <trans-unit id="d6ccf6b76d558573e3c0fabfcc033f5c54af17d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_peak_human&lt;/code&gt;: Human readable representation of previous value</source>
          <target state="translated">&lt;code&gt;used_memory_peak_human&lt;/code&gt; : 인간이 읽을 수있는 이전 값 표현</target>
        </trans-unit>
        <trans-unit id="95c64fa74f4f378fb6165e87d12311fdb312106a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_peak_perc&lt;/code&gt;: The percentage of &lt;code&gt;used_memory_peak&lt;/code&gt; out of &lt;code&gt;used_memory&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;used_memory_peak_perc&lt;/code&gt; :의 비율 &lt;code&gt;used_memory_peak&lt;/code&gt; 중 &lt;code&gt;used_memory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f221dda83245c669bda1e05655bd3ac2e0ab5f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_rss&lt;/code&gt;: Number of bytes that Redis allocated as seen by the operating system (a.k.a resident set size). This is the number reported by tools such as &lt;code&gt;top(1)&lt;/code&gt; and &lt;code&gt;ps(1)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;used_memory_rss&lt;/code&gt; : 운영 체제에서 볼 수 있듯이 Redis가 할당 한 바이트 수 (일명 상주 세트 크기). 이것은 &lt;code&gt;top(1)&lt;/code&gt; 및 &lt;code&gt;ps(1)&lt;/code&gt; 과 같은 도구로보고 된 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="56f70f47101fda30eddf5ba143e549084227ebe8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_rss_human&lt;/code&gt;: Human readable representation of previous value</source>
          <target state="translated">&lt;code&gt;used_memory_rss_human&lt;/code&gt; : 인간이 읽을 수있는 이전 값 표현</target>
        </trans-unit>
        <trans-unit id="a4a8ca1c1e26697d33b86803c2cdfbdf68e1dfc1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_scripts&lt;/code&gt;: Number of bytes used by cached Lua scripts</source>
          <target state="translated">&lt;code&gt;used_memory_scripts&lt;/code&gt; : 캐시 된 Lua 스크립트가 사용하는 바이트 수</target>
        </trans-unit>
        <trans-unit id="aae09b8c68830c081ead70e0e60de486862382bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_scripts_human&lt;/code&gt;: Human readable representation of previous value</source>
          <target state="translated">&lt;code&gt;used_memory_scripts_human&lt;/code&gt; : 사람이 읽을 수있는 이전 값 표현</target>
        </trans-unit>
        <trans-unit id="b409b28ae2a01206af36cb38e85fd023946f81d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;used_memory_startup&lt;/code&gt;: Initial amount of memory consumed by Redis at startup in bytes</source>
          <target state="translated">&lt;code&gt;used_memory_startup&lt;/code&gt; : 시작할 때 Redis가 소비 한 초기 메모리 양 (바이트)</target>
        </trans-unit>
        <trans-unit id="d702afbca51bb1f1c0b264975ec9e9ca2a5cb291" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;user&lt;/code&gt;: the authenticated username of the client</source>
          <target state="translated">&lt;code&gt;user&lt;/code&gt; : 클라이언트의 인증 된 사용자 이름</target>
        </trans-unit>
        <trans-unit id="e7666b28ecf1aaa403c4c9fe8c4cadb678a1f039" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ver&lt;/code&gt;: Version of the module</source>
          <target state="translated">&lt;code&gt;ver&lt;/code&gt; : 모듈 버전</target>
        </trans-unit>
        <trans-unit id="874c4d59a169c2d53f7c3ae429f5959f57146193" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&amp;lt;pattern&amp;gt;&lt;/code&gt;: add the specified key pattern (glob style pattern, like in the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; command), to the list of key patterns accessible by the user. You can add multiple key patterns to the same user. Example: &lt;code&gt;~objects:*&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;~&amp;lt;pattern&amp;gt;&lt;/code&gt; : 사용자가 액세스 할 수있는 키 패턴 목록에 지정된 키 패턴 ( &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; 명령 과 같은 glob 스타일 패턴 )을 추가합니다. 동일한 사용자에게 여러 키 패턴을 추가 할 수 있습니다. 예 : &lt;code&gt;~objects:*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0779adce6efc8480503ae1ee70342fbc671c005f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: starting with Redis 5, scripts are always replicated as effects and not sending the script verbatim. So the following section is mostly applicable to Redis version 4 or older.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : Redis 5부터 스크립트는 항상 효과로 복제되며 스크립트를 그대로 보내지 않습니다. 따라서 다음 섹션은 대부분 Redis 버전 4 이상에 적용됩니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e19535a094281f66a7c86327ed5e3682df604f43" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note: starting with Redis 5, the replication method described in this section (scripts effects replication) is the default and does not need to be explicitly enabled.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;참고 : Redis 5부터이 섹션에 설명 된 복제 방법 (스크립트 효과 복제)이 기본값이며 명시 적으로 활성화 할 필요는 없습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e13dca6da1f5cb034512c6f89e682ac5a816871f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;admin&lt;/em&gt; - server admin command</source>
          <target state="translated">&lt;em&gt;admin-&lt;/em&gt; 서버 관리 명령</target>
        </trans-unit>
        <trans-unit id="10c2f31b9cb95d52492cefe272ee0ce7e7e96172" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;asking&lt;/em&gt; - cluster related - accept even if importing</source>
          <target state="translated">&lt;em&gt;묻기&lt;/em&gt; -클러스터 관련-가져 오기를해도 승인</target>
        </trans-unit>
        <trans-unit id="fd143e082b45bd6d7de12217c454560c80ccbc41" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;denyoom&lt;/em&gt; - reject command if currently OOM</source>
          <target state="translated">&lt;em&gt;denyoom-&lt;/em&gt; 현재 OOM 인 경우 명령 거부</target>
        </trans-unit>
        <trans-unit id="22208566ecb85a6f473d3a0c82c02cca1f6156aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;denyoom&lt;/em&gt; - reject command if currently out of memory</source>
          <target state="translated">&lt;em&gt;denyoom-&lt;/em&gt; 현재 메모리가 부족하면 명령을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="8cc88faeccf37dd9abce525d1e16c903b5653be7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;fast&lt;/em&gt; - command operates in constant or log(N) time. Used for latency monitoring.</source>
          <target state="translated">&lt;em&gt;fast-&lt;/em&gt; 명령은 상수 또는 log (N) 시간에 작동합니다. 대기 시간 모니터링에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d7a26816637799c11c50ca22e1c31e62cfdc3324" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;loading&lt;/em&gt; - allow command while database is loading</source>
          <target state="translated">&lt;em&gt;loading-&lt;/em&gt; 데이터베이스가 로딩되는 동안 명령 허용</target>
        </trans-unit>
        <trans-unit id="35e295b11abb30e261e118848506ada08e20c863" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;movablekeys&lt;/em&gt; - keys have no pre-determined position. You must discover keys yourself.</source>
          <target state="translated">&lt;em&gt;움직일 수있는&lt;/em&gt; 키-키에는 미리 결정된 위치가 없습니다. 키를 직접 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="10bef8487cc510b84ad65623659536dca2bd88e2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;noscript&lt;/em&gt; - deny this command from scripts</source>
          <target state="translated">&lt;em&gt;noscript-&lt;/em&gt; 스크립트에서이 명령을 거부</target>
        </trans-unit>
        <trans-unit id="22ad5604ab4408792b4dbb6841391c73eb5bcd3e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;pubsub&lt;/em&gt; - pubsub-related command</source>
          <target state="translated">&lt;em&gt;pubsub&lt;/em&gt; -pubsub 관련 명령</target>
        </trans-unit>
        <trans-unit id="4657f2c9a9b6147be79ff8861078f0a1c0f21dc9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;random&lt;/em&gt; - command has random results, dangerous for scripts</source>
          <target state="translated">&lt;em&gt;random-&lt;/em&gt; 명령에 임의의 결과가 발생하여 스크립트에 위험</target>
        </trans-unit>
        <trans-unit id="3952a7346643d82eda1f83fc8f67bd7841254782" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;readonly&lt;/em&gt; - command will never modify keys</source>
          <target state="translated">&lt;em&gt;readonly-&lt;/em&gt; 명령은 키를 수정하지 않습니다</target>
        </trans-unit>
        <trans-unit id="e5695fb2252476f28d156ffb338071b2a1d167d9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;skip_monitor&lt;/em&gt; - do not show this command in MONITOR</source>
          <target state="translated">&lt;em&gt;skip_monitor&lt;/em&gt; -MONITOR에서이 명령을 표시하지 않습니다</target>
        </trans-unit>
        <trans-unit id="6e820b39ec4b2576d4194864a5c8cd2ba6855b08" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;sort_for_script&lt;/em&gt; - if called from script, sort output</source>
          <target state="translated">&lt;em&gt;sort_for_script-&lt;/em&gt; 스크립트에서 호출 된 경우 출력 정렬</target>
        </trans-unit>
        <trans-unit id="afaa4774ab65f2ceeccfa3570797867883f640b5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;stale&lt;/em&gt; - allow command while replica has stale data</source>
          <target state="translated">&lt;em&gt;부실&lt;/em&gt; -복제본에 부실 데이터가있는 동안 명령 허용</target>
        </trans-unit>
        <trans-unit id="a314df10a9c4582edc32c3810d68e266cd2ff50f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;write&lt;/em&gt; - command may result in modifications</source>
          <target state="translated">&lt;em&gt;쓰기&lt;/em&gt; -명령이 수정 될 수 있음</target>
        </trans-unit>
        <trans-unit id="42d17eeb4be4227b8e5ddf2b0e335361a9442b96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A note about the word slave used in this man page and command name&lt;/strong&gt;: Starting with Redis 5 this command: starting with Redis version 5, if not for backward compatibility, the Redis project no longer uses the word slave. Please use the new command &lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS&lt;/a&gt;. The command &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; will continue to work for backward compatibility.</source>
          <target state="translated">&lt;strong&gt;이 매뉴얼 페이지에서 사용되는 단어 슬레이브 및 명령 이름에 대한 참고 사항&lt;/strong&gt; : Redis 5로 시작이 명령 : 이전 버전과의 호환성을 위해 Redis 버전 5로 시작하면 Redis 프로젝트는 더 이상 슬레이브라는 단어를 사용하지 않습니다. 새로운 명령 &lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS를&lt;/a&gt; 사용하십시오 . &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; 명령 은 이전 버전과의 호환성을 위해 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="22b987b44b7a5dd2e47b2e3eea2dfc49f06df3d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A note about the word slave used in this man page and command name&lt;/strong&gt;: Starting with Redis 5 this command: starting with Redis version 5, if not for backward compatibility, the Redis project no longer uses the word slave. Please use the new command &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt;. The command &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; will continue to work for backward compatibility.</source>
          <target state="translated">&lt;strong&gt;이 매뉴얼 페이지에서 사용되는 단어 슬레이브 및 명령 이름에 대한 참고 사항&lt;/strong&gt; : Redis 5로 시작이 명령 : 이전 버전과의 호환성을 위해 Redis 버전 5로 시작하면 Redis 프로젝트는 더 이상 슬레이브라는 단어를 사용하지 않습니다. 새 명령 &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF를&lt;/a&gt; 사용하십시오 . &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; 명령 은 이전 버전과의 호환성을 위해 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c99b58d7712fa94ddcaaec3a2960300b8a561396" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A note about the word slave used in this man page and command name&lt;/strong&gt;: Starting with Redis 5, if not for backward compatibility, the Redis project no longer uses the word slave. Unfortunately in this command the word slave is part of the protocol, so we'll be able to remove such occurrences only when this API will be naturally deprecated.</source>
          <target state="translated">&lt;strong&gt;이 매뉴얼 페이지에서 사용되는 단어 슬레이브 및 명령 이름에 대한 참고 사항&lt;/strong&gt; : Redis 5부터는 하위 호환성을 위해 Redis 프로젝트에서 더 이상 단어 슬레이브를 사용하지 않습니다. 불행하게도이 명령에서 slave라는 단어는 프로토콜의 일부이므로이 API가 자연스럽게 사용되지 않을 때만 그러한 발생을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b440152e5e3583cee378a3b1e711d099bafed4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A note about the word slave used in this man page&lt;/strong&gt;: Starting with Redis 5, if not for backward compatibility, the Redis project no longer uses the word slave. Unfortunately in this command the word slave is part of the protocol, so we'll be able to remove such occurrences only when this API will be naturally deprecated.</source>
          <target state="translated">&lt;strong&gt;이 매뉴얼 페이지에서 사용 된 단어 슬레이브에 대한 참고 사항&lt;/strong&gt; : Redis 5부터는 하위 호환성을 위해 Redis 프로젝트에서 더 이상 단어 슬레이브를 사용하지 않습니다. 불행하게도이 명령에서 slave라는 단어는 프로토콜의 일부이므로이 API가 자연스럽게 사용되지 않을 때만 그러한 발생을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66dc6dfb23eee314b12cd2731c54cf1fcc6f78b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 1.0.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.0.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bafcacc0e3c7960ad2cb8f503d72f30f78ca254b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 1.0.1.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.0.1부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="42ef041208b3c7f6b84ee588b6d7090649da3cde" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 1.0.5.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.0.5부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2979205dcc40ec82cc62cbda6a41df44b1490b3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 1.2.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.2.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="28e1ed9a5b6011c62e872df0b23f6461d63b067c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.0.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.0.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2856d7513ee771916c2aaae5a59c9760f4c9ee69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.2.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.2.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="97df2e6716f64385365f3793fe17b2b2b8c49250" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.2.12.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.2.12부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2af9ad13d1bc44db9e41a723957913e50bb83c15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.2.3.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.2.3부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2604a994ca379d977a81045288fcf1fb1a12b6eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.4.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.4.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b3e52d68eec5b69a8580d7244b4cdd30126edfc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.6.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.6.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad155abecba93e556fc2964349d42546bbd57c37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.6.9.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.6.9부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="433a172e52c0f75503c2591c44f351278b8a2f1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.8.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.8.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="32a14135298102cba37c7a031f64183e68e7a403" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.8.12.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.8.12부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="070bc5f809a6dcd424c69365545356941c2c87e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.8.13.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.8.13부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eeef4c5b6e8d514cf3970118cf5eecd9fc93d806" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.8.7.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.8.7부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a139b314b3eeac41f2cb4b52b420d048c12b572d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.8.9.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.8.9부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="110407b93d6631c2f87c8bcf0b09b41e5dd1585a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 2.9.50.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.9.50부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="947745c28030ed2d02d2d6bf7ae0327d4548b7d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 3.0.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.0.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="000c6853ef4da627b8791fda02e7112106e57268" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 3.2.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.2.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="248abe6dbbd5bde7dfe7a190fa8676bdabbee407" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 3.2.1.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.2.1부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7787594e7b7fa02a64ea0ac1f47edf5c68240aa7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 3.2.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.2부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="76c11f357d1203d366fa5e186202643c7f75fe3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 4.0.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4.0.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fb77e7f9038cd769ce8cf62ccaacda589c6f003f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 5.0.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5.0.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4f5fc2f2faeb9db58eaba5c6db1620e3f4d51b2c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 6.0.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;6.0.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="349e55c27c4a1f4de3a52296d6579958bfa5b15c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 6.0.6.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;6.0.6부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f864e439fc87160a12122e5c8bf4d53ad092c0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 6.2.0.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;6.2.0부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="53e7321eb80df80fcb4156061a619f522a8236c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Available since 6.2.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;6.2부터 사용 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37ad352b4b8a994d3447d680cfa6aac8d4baddae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CH&lt;/strong&gt;: Modify the return value from the number of new elements added, to the total number of elements changed (CH is an abbreviation of &lt;em&gt;changed&lt;/em&gt;). Changed elements are &lt;strong&gt;new elements added&lt;/strong&gt; and elements already existing for which &lt;strong&gt;the score was updated&lt;/strong&gt;. So elements specified in the command line having the same score as they had in the past are not counted. Note: normally the return value of &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; only counts the number of new elements added.</source>
          <target state="translated">&lt;strong&gt;CH&lt;/strong&gt; : 추가 된 새 요소 수에서 변경된 총 요소 수로 리턴 값을 수정하십시오 (CH는 &lt;em&gt;changed&lt;/em&gt; 의 약어 임 ). 변경된 요소는 &lt;strong&gt;점수가 업데이트 된 &lt;/strong&gt;&lt;strong&gt;새로운 요소&lt;/strong&gt; 와 이미 존재하는 요소 입니다. 따라서 명령 줄에 지정된 요소가 과거와 동일한 점수를 갖는 것은 계산되지 않습니다. 참고 : 일반적으로 &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; 의 반환 값은 추가 된 새 요소의 수만 계산합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="df8c1ee6b8ea782dadcbe9b7a6f6ee7e14cd37c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ERROR&lt;/strong&gt;: both C1 and C2 acquired the lock because of the race condition.</source>
          <target state="translated">&lt;strong&gt;오류&lt;/strong&gt; : 경쟁 조건으로 인해 C1과 C2가 잠금을 획득했습니다.</target>
        </trans-unit>
        <trans-unit id="a87aecd8a98bb8da49b78363fdf6ad6d0ad4ad9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;FAIL&lt;/strong&gt;: in this mode no operation is performed on overflows or underflows detected. The corresponding return value is set to NULL to signal the condition to the caller.</source>
          <target state="translated">&lt;strong&gt;FAIL&lt;/strong&gt; :이 모드에서는 오버플로 또는 언더 플로가 감지되면 아무런 작업도 수행되지 않습니다. 해당 리턴 값은 조건을 호출자에게 알리기 위해 NULL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2f2e999f961e4cb70747a82c7afe1e1ac4d14dd0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;GET&lt;/strong&gt;&lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;offset&amp;gt;&lt;/code&gt; -- Returns the specified bit field.</source>
          <target state="translated">&lt;strong&gt;GET &lt;/strong&gt; &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;offset&amp;gt;&lt;/code&gt; -지정된 비트 필드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8af4667a1aad5a84d9ec8a060984b3b9f1bdf87f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;GT&lt;/strong&gt;: Only update existing elements if the new score is &lt;strong&gt;greater than&lt;/strong&gt; the current score. This flag doesn't prevent adding new elements.</source>
          <target state="translated">&lt;strong&gt;GT&lt;/strong&gt; : 새 점수가 현재 점수 &lt;strong&gt;보다 큰&lt;/strong&gt; 경우에만 기존 요소를 업데이트 합니다. 이 플래그는 새 요소 추가를 방지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a95ec0f36765c66b1ab2481704998d8a28483766" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hard reset only&lt;/strong&gt;: &lt;code&gt;currentEpoch&lt;/code&gt; and &lt;code&gt;configEpoch&lt;/code&gt; vars are set to 0.</source>
          <target state="translated">&lt;strong&gt;하드 리셋 만&lt;/strong&gt; : &lt;code&gt;currentEpoch&lt;/code&gt; 및 &lt;code&gt;configEpoch&lt;/code&gt; 변수는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a3dd45a98f533d02befd41f941271bbba011d7a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Hard reset only&lt;/strong&gt;: a new Node ID is generated.</source>
          <target state="translated">&lt;strong&gt;하드 리셋 만&lt;/strong&gt; : 새로운 노드 ID가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="55df25f32f77293934878d2a89f464b77726ab0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;INCR&lt;/strong&gt;: When this option is specified &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; acts like &lt;a href=&quot;zincrby&quot;&gt;ZINCRBY&lt;/a&gt;. Only one score-element pair can be specified in this mode.</source>
          <target state="translated">&lt;strong&gt;INCR&lt;/strong&gt; :이 옵션이 지정 &lt;a href=&quot;zadd&quot;&gt;되면 ZADD&lt;/a&gt; 는 ZINCRBY 와 같은 &lt;a href=&quot;zincrby&quot;&gt;역할을&lt;/a&gt; 합니다. 이 모드에서는 하나의 점수 요소 쌍만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07a043543d639e8331184b587a20bbea7427d520" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;INCRBY&lt;/strong&gt;&lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;offset&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;increment&amp;gt;&lt;/code&gt; -- Increments or decrements (if a negative increment is given) the specified bit field and returns the new value.</source>
          <target state="translated">&lt;strong&gt;INCRBY &lt;/strong&gt; &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;offset&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;increment&amp;gt;&lt;/code&gt; -지정된 비트 필드를 증가 또는 감소 (음수 증분이 주어지면)하고 새 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e46a2f0474829b059fcc7d34e4ee9e4caec81736" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important note:&lt;/strong&gt; avoid debugging Lua scripts using your Redis production server. Use a development server instead.</source>
          <target state="translated">&lt;strong&gt;중요 사항 :&lt;/strong&gt; Redis 프로덕션 서버를 사용하여 Lua 스크립트를 디버깅하지 마십시오. 대신 개발 서버를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2ce5ee9654c6340e1e4eb82e8c83ddf58293784d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Importing slot:&lt;/strong&gt;&lt;code&gt;[slot_number-&amp;lt;-importing_from_node_id]&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;가져 오기 슬롯 : &lt;/strong&gt; &lt;code&gt;[slot_number-&amp;lt;-importing_from_node_id]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3012a85d56005df4704a75489bb8df125742014e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Importing&lt;/strong&gt; slots are yet not part of the nodes hash slot, there is a migration in progress. The node will accept queries about these slots only if the &lt;code&gt;ASK&lt;/code&gt; command is used.</source>
          <target state="translated">&lt;strong&gt;가져 오기&lt;/strong&gt; 슬롯이 아직 노드 해시 슬롯의 일부가 아니므로 마이그레이션이 진행 중입니다. 노드는 &lt;code&gt;ASK&lt;/code&gt; 명령이 사용되는 경우에만이 슬롯에 대한 쿼리를 수락합니다 .</target>
        </trans-unit>
        <trans-unit id="6c6c8886e8352c3a3901fd75105c549ff1c8badd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In the above code there is a race condition&lt;/strong&gt;. If for some reason the client performs the &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; command but does not perform the &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; the key will be leaked until we'll see the same IP address again.</source>
          <target state="translated">&lt;strong&gt;위의 코드에는 경쟁 조건이&lt;/strong&gt; 있습니다. 어떤 이유로 클라이언트가 &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; 명령을 수행 하지만 &lt;a href=&quot;expire&quot;&gt;EXPIRE를&lt;/a&gt; 수행하지 않으면 동일한 IP 주소가 다시 표시 될 때까지 키가 유출됩니다.</target>
        </trans-unit>
        <trans-unit id="b92dd4e0a23e32e06b39907323e24eca3f233f14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;LT&lt;/strong&gt;: Only update existing elements if the new score is &lt;strong&gt;less than&lt;/strong&gt; the current score. This flag doesn't prevent adding new elements.</source>
          <target state="translated">&lt;strong&gt;LT&lt;/strong&gt; : 새 점수가 현재 점수 &lt;strong&gt;보다 낮은&lt;/strong&gt; 경우에만 기존 요소를 업데이트 합니다. 이 플래그는 새 요소 추가를 방지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="94c28e3e21fc5ed1f5a96b1b64379cfe1c35f660" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lua to Redis&lt;/strong&gt; conversion table specific for RESP3.</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;RESP3 전용 &lt;strong&gt;Lua에서 Redis&lt;/strong&gt; 로의 변환 표.</target>
        </trans-unit>
        <trans-unit id="080ca67a419bf57eb4ca474c2ead958e0b17c394" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lua to Redis&lt;/strong&gt; conversion table.</source>
          <target state="translated">&lt;strong&gt;루아에서 레디로&lt;/strong&gt; 변환 표.</target>
        </trans-unit>
        <trans-unit id="594305ca901fa3745571fd4ea2d83b7d124a9536" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Migrating slot:&lt;/strong&gt;&lt;code&gt;[slot_number-&amp;gt;-migrating_to_node_id]&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;마이그레이션 슬롯 : &lt;/strong&gt; &lt;code&gt;[slot_number-&amp;gt;-migrating_to_node_id]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85d815f21360631a4d040aed811d832f36975a50" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Migrating&lt;/strong&gt; slots are assigned to the node, but are being migrated to some other node. The node will accept queries if all the keys in the command exist already, otherwise it will emit what is called an &lt;strong&gt;ASK redirection&lt;/strong&gt;, to force new keys creation directly in the importing node.</source>
          <target state="translated">&lt;strong&gt;마이그레이션&lt;/strong&gt; 슬롯이 노드에 할당되었지만 다른 노드로 마이그레이션되고 있습니다. 노드는 명령의 모든 키가 이미 존재하는 경우 쿼리를 수락합니다. 그렇지 않으면 가져 오기 노드에서 직접 새 키를 작성하기 위해 &lt;strong&gt;ASK 리디렉션&lt;/strong&gt; 을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="eae47eb67b82e2b9fc26c6a9ac32ec815c2935e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Modules generated sections&lt;/strong&gt;: Starting with Redis 6, modules can inject their info into the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command, these are excluded by default even when the &lt;code&gt;all&lt;/code&gt; argument is provided (it will include a list of loaded modules but not their generated info fields). To get these you must use either the &lt;code&gt;modules&lt;/code&gt; argument or &lt;code&gt;everything&lt;/code&gt;.,</source>
          <target state="translated">&lt;strong&gt;모듈 생성 섹션&lt;/strong&gt; : Redis 6부터 모듈은 &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 명령에 정보를 삽입 할 수 있으며 , &lt;code&gt;all&lt;/code&gt; 인수가 제공되는 경우에도 기본적으로 제외 됩니다 (로드 된 모듈 목록은 포함되지만 생성 된 정보 필드는 포함되지 않음). 이를 얻으려면 &lt;code&gt;modules&lt;/code&gt; 인수 또는 &lt;code&gt;everything&lt;/code&gt; 사용해야합니다 .,</target>
        </trans-unit>
        <trans-unit id="4542730e02f1444f396e1eecd3fb084c50899588" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NX&lt;/strong&gt;: Don't update already existing elements. Always add new elements.</source>
          <target state="translated">&lt;strong&gt;NX&lt;/strong&gt; : 기존 요소를 업데이트하지 않습니다. 항상 새로운 요소를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="aa921920147c16c1008783f3ee79ad9ef35d5949" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non standard return value&lt;/strong&gt;, a bulk transfer of the data followed by &lt;a href=&quot;ping&quot;&gt;PING&lt;/a&gt; and write requests from the master.</source>
          <target state="translated">&lt;strong&gt;비표준 반환 값&lt;/strong&gt; , 데이터의 대량 전송에 이어 마스터의 &lt;a href=&quot;ping&quot;&gt;PING&lt;/a&gt; 및 쓰기 요청.</target>
        </trans-unit>
        <trans-unit id="c0e14174973d3f14160192d3ec335ea216ce5838" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Non standard return value&lt;/strong&gt;, just dumps the received commands in an infinite flow.</source>
          <target state="translated">&lt;strong&gt;비표준 반환 값&lt;/strong&gt; 은 수신 된 명령을 무한 흐름으로 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="4d1b440d6bea75ebf4fddb300ea88cb48bb7d506" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that you should not rely on the fields exact position&lt;/strong&gt;, nor on the number of fields, new fields may be added in the future. So a well behaving client should fetch the whole list, and report it to the user, for example, as a dictionary data structure. Low level clients such as C clients where the items will likely be reported back in a linear array should document that the order is undefined.</source>
          <target state="translated">&lt;strong&gt;필드의 정확한 위치&lt;/strong&gt; 나 &lt;strong&gt;필드 수에 의존해서는 안되며&lt;/strong&gt; 나중에 새 필드가 추가 될 수 있습니다. 따라서 잘 동작하는 클라이언트는 전체 목록을 가져 와서이를 사전 데이터 구조와 같이 사용자에게보고해야합니다. 항목이 선형 배열로 다시보고 될 가능성이 높은 C 클라이언트와 같은 하위 레벨 클라이언트는 주문이 정의되지 않았 음을 문서화해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf38dc5f18a7403e0505cd57203e709ee2e82876" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: starting with Redis 5 the project is no longer using the slave word. You can use &lt;code&gt;TYPE replica&lt;/code&gt; instead, however the old form is still supported for backward compatibility.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : Redis 5부터는 프로젝트에서 더 이상 종속 어를 사용하지 않습니다. 대신 &lt;code&gt;TYPE replica&lt;/code&gt; 사용할 수 있지만 이전 형식은 여전히 ​​이전 버전과의 호환성을 위해 지원됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="169026e4cfeed9baf12881fcf75891516330178a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Before Redis 3.2.0, an error is returned if source and destination names are the same.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Redis 3.2.0 이전에는 소스 및 대상 이름이 동일한 경우 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="48b058dcb40890f2ca5c1f12103c9113b5379791" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The following pattern is discouraged in favor of &lt;a href=&quot;http://redis.io/topics/distlock&quot;&gt;the Redlock algorithm&lt;/a&gt; which is only a bit more complex to implement, but offers better guarantees and is fault tolerant.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 다음 패턴은 구현하기가 조금 더 복잡하지만 더 나은 보증을 제공하고 내결함성 이 &lt;a href=&quot;http://redis.io/topics/distlock&quot;&gt;있는 Redlock 알고리즘&lt;/a&gt; 을 사용 하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4ab4a67631aaba6fc476ea51d4c52e84df19e3e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The following pattern is discouraged in favor of &lt;a href=&quot;https://redis.io/topics/distlock&quot;&gt;the Redlock algorithm&lt;/a&gt; which is only a bit more complex to implement, but offers better guarantees and is fault tolerant.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 다음 패턴은 구현하기가 조금 더 복잡하지만 더 나은 보증을 제공하고 내결함성을 제공 &lt;a href=&quot;https://redis.io/topics/distlock&quot;&gt;하는 Redlock 알고리즘&lt;/a&gt; 을 선호하는 경우 권장되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e7f24abd7c8c85b89a11f7b735d84e40f293c0e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; config epoch management is performed internally by the cluster, and relies on obtaining a consensus of nodes. The &lt;a href=&quot;cluster-bumpepoch&quot;&gt;CLUSTER BUMPEPOCH&lt;/a&gt; attempts to increment the config epoch &lt;strong&gt;WITHOUT&lt;/strong&gt; getting the consensus, so using it may violate the &quot;last failover wins&quot; rule. Use it with caution.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 구성 시대 관리는 클러스터에서 내부적으로 수행되며 노드 합의 획득에 의존합니다. &lt;a href=&quot;cluster-bumpepoch&quot;&gt;CLUSTER BUMPEPOCH의&lt;/a&gt; 시도는 설정의 시대를 증가 &lt;strong&gt;없이&lt;/strong&gt; 그래서 &quot;마지막 장애 조치 승리&quot;규칙을 위반하여, 합의를 받고. 주의해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5f681aa7bf2619cd8d4bc82a09fca69b97fed67c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; the doctor has erratic psychological behaviors, so we recommend interacting with it carefully.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 의사는 불규칙한 심리적 행동을 보이므로 신중하게 상호 작용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0f902a881b716cf0d2a0b81af7f8e227f35550c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; the implementation for getting a range of bit offsets from a bitmap is left as an exercise to the reader.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 비트 맵에서 비트 오프셋 범위를 가져 오는 구현은 독자의 연습으로 남겨집니다.</target>
        </trans-unit>
        <trans-unit id="480b1ec2a7ba19faaf34095bd31fd8c13e719460" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; there is no &lt;strong&gt;GEODEL&lt;/strong&gt; command because you can use &lt;a href=&quot;zrem&quot;&gt;ZREM&lt;/a&gt; in order to remove elements. The Geo index structure is just a sorted set.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 더 없다 &lt;strong&gt;GEODEL를&lt;/strong&gt; 사용할 수 있기 때문에 명령 &lt;a href=&quot;zrem&quot;&gt;ZREM을&lt;/a&gt; 제거 요소를 위해. Geo 인덱스 구조는 정렬 된 집합입니다.</target>
        </trans-unit>
        <trans-unit id="66410825f423db9b4d7ddad345a43a6851da1c99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: because of the high performance nature of Redis, it is possible to try a lot of passwords in parallel in very short time, so make sure to generate a strong and very long password so that this attack is infeasible.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Redis의 고성능 특성으로 인해 짧은 시간에 많은 암호를 동시에 시도 할 수 있으므로 강력하고 매우 긴 암호를 생성하여이 공격을 실행할 수 없도록하십시오.</target>
        </trans-unit>
        <trans-unit id="3fb677f73a8d550c5cfe4a23e805eeca4c57f6d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: modules can also be loaded at server startup with &lt;code&gt;loadmodule&lt;/code&gt; configuration directive in &lt;code&gt;redis.conf&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 모듈도와 서버 시작시로드 할 수 &lt;code&gt;loadmodule&lt;/code&gt; 에서 설정 지시어 &lt;code&gt;redis.conf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e7b910f0576d349936d98bea109218640bde9ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: this is a string operation because Redis does not have a dedicated integer type. The string stored at the key is interpreted as a base-10 &lt;strong&gt;64 bit signed integer&lt;/strong&gt; to execute the operation.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : Redis에는 전용 정수 유형이 없으므로 문자열 작업입니다. 키에 저장된 문자열은 기본 10 &lt;strong&gt;64 비트 부호있는 정수&lt;/strong&gt; 로 해석되어 작업을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="7154ee5b1cdc329d8b78fa7fc770d684c0e65dcb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OVERFLOW&lt;/strong&gt;&lt;code&gt;[WRAP|SAT|FAIL]&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;OVERFLOW&lt;/strong&gt;&lt;code&gt;[WRAP|SAT|FAIL]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e175dad8e0390b7908b5360d2ccd15b75eeca63a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note that:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;점에 유의하시기 바랍니다:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="244fc08d3602d62e84927c3c5d301c8034317f18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;RESP3 mode conversion rules&lt;/strong&gt;: note that the Lua engine can work in RESP3 mode using the new Redis 6 protocol. In this case there are additional conversion rules, and certain conversions are also modified compared to the RESP2 mode. Please refer to the RESP3 section of this document for more information.</source>
          <target state="translated">&lt;strong&gt;RESP3 모드 변환 규칙&lt;/strong&gt; : Lua 엔진은 새로운 Redis 6 프로토콜을 사용하여 RESP3 모드에서 작동 할 수 있습니다. 이 경우 추가 변환 규칙이 있으며 특정 변환도 RESP2 모드와 비교하여 수정됩니다. 자세한 내용은이 문서의 RESP3 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9e0adc4a9b1d2414f03da39a1ef041847c8b49b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Redis to Lua&lt;/strong&gt; conversion table specific to RESP3:</source>
          <target state="translated">&lt;strong&gt;&lt;/strong&gt;RESP3에 특정한 &lt;strong&gt;Redis에서 Lua&lt;/strong&gt; 로의 변환 표 :</target>
        </trans-unit>
        <trans-unit id="6f3ee1f33563f6776e77dae5878a039952e3dce8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Redis to Lua&lt;/strong&gt; conversion table.</source>
          <target state="translated">&lt;strong&gt;Redis에서 Lua로&lt;/strong&gt; 변환 표.</target>
        </trans-unit>
        <trans-unit id="dfe05bbd1f39f62442e2cbf4bde38def83156b1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SAT&lt;/strong&gt;: uses saturation arithmetic, that is, on underflows the value is set to the minimum integer value, and on overflows to the maximum integer value. For example incrementing an &lt;code&gt;i8&lt;/code&gt; integer starting from value 120 with an increment of 10, will result into the value 127, and further increments will always keep the value at 127. The same happens on underflows, but towards the value is blocked at the most negative value.</source>
          <target state="translated">&lt;strong&gt;SAT&lt;/strong&gt; : 포화 산술을 사용합니다. 즉, 언더 플로에서 값이 최소 정수 값으로 설정되고 오버플로에서 최대 정수 값으로 오버플로됩니다. 예를 들어 , 값 120에서 시작하여 10 씩 증가하는 &lt;code&gt;i8&lt;/code&gt; 정수를 증가 시키면 값은 127이되고, 추가 증가는 항상 값을 127로 유지합니다. 언더 플로우에서도 동일하게 발생하지만 값에 대한 값은 가장 음수로 차단됩니다. 값.</target>
        </trans-unit>
        <trans-unit id="1408628eac488c273fe94ce3069837b4615f952e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SET&lt;/strong&gt;&lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;offset&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; -- Set the specified bit field and returns its old value.</source>
          <target state="translated">&lt;strong&gt;SET &lt;/strong&gt; &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;offset&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; -지정된 비트 필드를 설정하고 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="154c3e795e5c1982b62afd2e5d5d6ba3b9edff78" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SHUTDOWN NOSAVE&lt;/strong&gt; will prevent a DB saving operation even if one or more save points are configured. (You can think of this variant as an hypothetical &lt;strong&gt;ABORT&lt;/strong&gt; command that just stops the server).</source>
          <target state="translated">&lt;strong&gt;SHUTDOWN NOSAVE&lt;/strong&gt; 는 하나 이상의 저장 지점이 구성되어 있어도 DB 저장 작업을 방지합니다. 이 변형을 서버를 중지 시키는 가상 &lt;strong&gt;ABORT&lt;/strong&gt; 명령 으로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e5c55a7d3de34798b279180cf9d3cd081c884b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;SHUTDOWN SAVE&lt;/strong&gt; will force a DB saving operation even if no save points are configured.</source>
          <target state="translated">&lt;strong&gt;SHUTDOWN SAVE&lt;/strong&gt; 는 저장 지점이 구성되지 않은 경우에도 DB 저장 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="556107b8e9768c921f3dec9b00b1054a332802e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The timeout argument is interpreted as a double value specifying the maximum number of seconds to block&lt;/strong&gt;. A timeout of zero can be used to block indefinitely.</source>
          <target state="translated">&lt;strong&gt;timeout 인수는 차단할 최대 시간 (초)을 지정하는 double 값으로 해석됩니다&lt;/strong&gt; . 제한 시간 0을 사용하여 무기한 차단할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4908775239d52b8a249c687e49f93d0788e39894" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The timeout argument is interpreted as an integer value specifying the maximum number of seconds to block&lt;/strong&gt;. A timeout of zero can be used to block indefinitely.</source>
          <target state="translated">&lt;strong&gt;시간 초과 인수는 차단할 최대 시간 (초)을 지정하는 정수 값으로 해석됩니다&lt;/strong&gt; . 시간 종료 0은 무기한 차단하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18c64c5033a261ea8682fefd1c4d266d085bb5af" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; Depends on the script that is executed.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 실행되는 스크립트에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="65286337fbd95f12b6dbd7609bce419657c61278" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; For LCS O(strlen(s1)*strlen(s2))</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; LCS O (strlen (s1) * strlen (s2))의 경우</target>
        </trans-unit>
        <trans-unit id="4c297bf650da1f0e475df73b56cf1ac69d632e5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; For each stream mentioned: O(M) with M being the number of elements returned. If M is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1). On the other side when XREADGROUP blocks, XADD will pay the O(N) time in order to serve the N clients blocked on the stream getting new data.</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; 언급 된 각 스트림에 대해 : O (M), M은 반환 된 요소 수입니다. M이 일정하면 (예 : 항상 COUNT로 처음 10 개의 요소를 요구하는 경우) O (1)로 간주 할 수 있습니다. 반면에 XREADGROUP이 차단되면 XADD는 새로운 데이터를받는 스트림에서 차단 된 N 개의 클라이언트에게 서비스를 제공하기 위해 O (N) 시간을 지불합니다.</target>
        </trans-unit>
        <trans-unit id="2a32c28191aa7b2da0b44dcbfa9f224c42c1f256" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; For each stream mentioned: O(N) with N being the number of elements being returned, it means that XREAD-ing with a fixed COUNT is O(1). Note that when the BLOCK option is used, XADD will pay O(M) time in order to serve the M clients blocked on the stream getting new data.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 언급 된 각 스트림에 대해 : O (N) (N이 반환되는 요소 수)는 고정 COUNT를 사용하는 XREAD-ing이 O (1)임을 의미합니다. BLOCK 옵션을 사용하면 XADD는 새 데이터를 가져 오는 스트림에서 차단 된 M 클라이언트에게 서비스를 제공하기 위해 O (M) 시간을 지불합니다.</target>
        </trans-unit>
        <trans-unit id="bd8b5ee7f2421c47e339ced1729fc4553418147c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; For each stream mentioned: O(N) with N being the number of elements being returned, it menas that XREAD-ing with a fixed COUNT is O(1). Note that when the BLOCK option is used, XADD will pay O(M) time in order to serve the M clients blocked on the stream getting new data.</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; 언급 된 각 스트림에 대해 : N이 반환되는 요소 수인 O (N), 고정 COUNT의 XREAD-ing은 O (1)입니다. BLOCK 옵션을 사용하면 XADD는 새 데이터를 가져 오는 스트림에서 차단 된 M 클라이언트에게 서비스를 제공하기 위해 O (M) 시간을 지불합니다.</target>
        </trans-unit>
        <trans-unit id="d1fd412d03fc2b530c2b27d7b45b0385a31cf6e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1)</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (1)</target>
        </trans-unit>
        <trans-unit id="f9f66fd7aff4a34cf1299e1361ec8ace3be42cd6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) amortized time considering the typical user.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (1) 일반 사용자를 고려한 분할 시간.</target>
        </trans-unit>
        <trans-unit id="55633d506fbeea6161b511b8a54465821794f5cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for all the currently implemented subcommands.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 현재 구현 된 모든 하위 명령에 대한 O (1)</target>
        </trans-unit>
        <trans-unit id="b44242f4720bce6423a8ffc796b452d96e431af2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for all the subcommands, with the exception of the DESTROY subcommand which takes an additional O(M) time in order to delete the M entries inside the consumer group pending entries list (PEL).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 소비자 그룹 보류 항목 목록 (PEL) 내의 M 항목을 삭제하기 위해 추가 O (M) 시간이 걸리는 DESTROY 하위 명령을 제외한 모든 하위 명령의 O (1).</target>
        </trans-unit>
        <trans-unit id="520d8e26a668641abf11a642c0f43432b1535181" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for each element added, so O(N) to add N elements when the command is called with multiple arguments.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 추가 된 각 요소에 대한 O (1)이므로 명령이 여러 인수와 함께 호출 될 때 O (N)은 N 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="11406908c7956944d717e43c7d0204f76e70c476" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for each field/value pair added, so O(N) to add N field/value pairs when the command is called with multiple field/value pairs.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 추가 된 각 필드 / 값 쌍에 대해 O (1), 따라서 명령이 여러 필드 / 값 쌍으로 호출 될 때 N 필드 / 값 쌍을 추가하려면 O (N).</target>
        </trans-unit>
        <trans-unit id="8eb838dfbc1d23415a7fe8a01586a99b88c8b560" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for each key removed regardless of its size. Then the command does O(N) work in a different thread in order to reclaim memory, where N is the number of allocations the deleted objects where composed of.</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; 크기에 관계없이 각 키의 O (1)가 제거되었습니다. 그런 다음 명령은 메모리를 회수하기 위해 다른 스레드에서 O (N)을 수행합니다. 여기서 N은 삭제 된 오브젝트가 구성된 위치의 수입니다.</target>
        </trans-unit>
        <trans-unit id="0ee729ae062b27a778521924a23715d1f5a2f8c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for each message ID processed.</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; 처리 된 각 메시지 ID에 대한 O (1)</target>
        </trans-unit>
        <trans-unit id="1b4eeec474e03615439c6b07161a4a898251fa48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for each single item to delete in the stream, regardless of the stream size.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 스트림 크기에 관계없이 스트림에서 삭제할 각 단일 항목에 대한 O (1).</target>
        </trans-unit>
        <trans-unit id="3713a469f5558b38e0174355b7bd91512dde4739" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for each subcommand specified</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 지정된 각 하위 명령에 대한 O (1)</target>
        </trans-unit>
        <trans-unit id="e32e66d8d957b6ef84d7d5e82b7e3681ca99b974" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 모든 통화에 대한 O (1). 커서가 0으로 되돌아 갈 수 있도록 충분한 명령 호출을 포함하여 전체 반복에 대한 O (N). N은 콜렉션 내부의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="bd0e3bce04476c33f576529cb977579b2c937bb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for every call. O(N) for a complete iteration, including enough command calls for the cursor to return back to 0. N is the number of elements inside the collection..</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 모든 통화에 대한 O (1). 커서가 0으로 되돌아 갈 수 있도록 충분한 명령 호출을 포함하여 완전한 반복을위한 O (N). N은 콜렉션 내부의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="8bb7886d25c8e4f04cefc6d407e66e3510ca7843" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) for every key.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 모든 키에 대한 O (1).</target>
        </trans-unit>
        <trans-unit id="8224beb67608f863bcc99e832bf3c09931c63e59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) since the categories and commands are a fixed set.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 범주와 명령이 고정 된 집합이므로 O (1).</target>
        </trans-unit>
        <trans-unit id="1f894f0417f03c09ee9b529c74b588869f634d1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) to access the key and additional O(N*M) to serialize it, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1).</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; 키에 액세스하려면 O (1), 직렬화하려면 추가 O (N * M)를 사용합니다. 여기서 N은 값을 구성하는 Redis 개체의 수이고 M은 평균 크기입니다. 따라서 작은 문자열 값의 경우 시간 복잡도는 O (1) + O (1 * M)입니다. 여기서 M은 작으므로 간단히 O (1)입니다.</target>
        </trans-unit>
        <trans-unit id="e91064b0a93173883f68e80de9b9109a1b47c2be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) to access the key and additional O(N*M) to serialized it, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1).</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; 키에 액세스하기위한 O (1) 및 직렬화를위한 추가 O (N * M). 여기서 N은 값을 구성하는 Redis 객체의 수이고 M은 평균 크기입니다. 작은 문자열 값의 경우 시간 복잡도는 O (1) + O (1 * M)이며 여기서 M은 작으므로 간단히 O (1)입니다.</target>
        </trans-unit>
        <trans-unit id="eb869fdd06f1e9c7503112a8348a9c6a6c3c32da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) to add every element.</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; 모든 요소를 ​​추가하는 O (1)</target>
        </trans-unit>
        <trans-unit id="000e7bfc4f0d59a7eca161f93d84ccfe59e93fba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) to create the new key and additional O(N*M) to reconstruct the serialized value, where N is the number of Redis objects composing the value and M their average size. For small string values the time complexity is thus O(1)+O(1*M) where M is small, so simply O(1). However for sorted set values the complexity is O(N*M*log(N)) because inserting values into sorted sets is O(log(N)).</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; O (1) &lt;strong&gt;:&lt;/strong&gt; 새 키를 만들고 추가 O (N * M)을 사용하여 직렬화 된 값을 재구성합니다. 여기서 N은 값을 구성하는 Redis 개체의 수이고 M은 평균 크기입니다. 작은 문자열 값의 경우 시간 복잡도는 O (1) + O (1 * M)이며 여기서 M은 작으므로 간단히 O (1)입니다. 그러나 정렬 된 세트 값의 경우 정렬 된 세트에 값을 삽입하는 것이 O (log (N))이므로 복잡도는 O (N * M * log (N))입니다.</target>
        </trans-unit>
        <trans-unit id="b9a90a5fd9bab0ece6d137f9d36c393b3e901d97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1) with a very small average constant time when called with a single key. O(N) with N being the number of keys, and much bigger constant times, when called with multiple keys.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 단일 키로 호출 할 때 평균 상수 시간이 매우 작은 O (1). 여러 키로 호출 될 때 N은 키 수이며 훨씬 더 큰 상수 시간을 갖는 O (N).</target>
        </trans-unit>
        <trans-unit id="c45e1943b751714517205357e597c388c0f665c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1), not counting the time taken to copy the new string in place. Usually, this string is very small so the amortized complexity is O(1). Otherwise, complexity is O(M) with M being the length of the value argument.</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; O (1), 새 문자열을 복사하는 데 걸린 시간을 계산하지 않습니다. 일반적으로이 문자열은 매우 작으므로 상각 복잡도는 O (1)입니다. 그렇지 않으면 복잡도는 O (M)이며 M은 값 인수의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="c4b651952550615d9e490f3dbbf7dc5130247335" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(1). The amortized time complexity is O(1) assuming the appended value is small and the already present value is of any size, since the dynamic string library used by Redis will double the free space available on every reallocation.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (1). 추가 된 값이 작고 Redis에서 사용하는 동적 문자열 라이브러리가 모든 재 할당에서 사용 가능한 여유 공간을 두 배로 늘리기 때문에 추가 된 값이 작고 이미 존재하는 값의 크기를 가정하면 상각 시간 복잡도는 O (1)입니다.</target>
        </trans-unit>
        <trans-unit id="bf3b7f496a65e5522b9dc1b7e669443ace377ffa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(L + (N-K)log(N)) worst case where L is the total number of elements in all the sets, N is the size of the first set, and K is the size of the result set.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (L + (NK) log (N)) 최악의 경우 L은 모든 집합의 총 요소 수, N은 첫 번째 집합의 크기, K는 결과 집합의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="0395357e538314afbb36cc7212c8f51962579675" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(M*log(N)) with N being the number of elements in the sorted set and M the number of elements to be removed.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (M * log (N)) : N은 정렬 된 세트의 요소 수이고 M은 제거 할 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="9067f60dde5b44b871a9347672e48a72cd2cb2ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N)</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N)</target>
        </trans-unit>
        <trans-unit id="04a38332e56a66ff430f83f4bbdae1e73532033c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) for the CHANNELS subcommand, where N is the number of active channels, and assuming constant time pattern matching (relatively short channels and patterns). O(N) for the NUMSUB subcommand, where N is the number of requested channels. O(1) for the NUMPAT subcommand.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; CHANNELS 하위 명령의 경우 O (N). 여기서 N은 활성 채널 수이며 일정한 시간 패턴 일치 (상대적으로 짧은 채널 및 패턴)를 가정합니다. NUMSUB 부속 명령의 경우 O (N). 여기서 N은 요청 된 채널 수입니다. NUMPAT 부속 명령의 경우 O (1).</target>
        </trans-unit>
        <trans-unit id="0a446809019f44c824a87ec9581f040ffb0e32cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) to merge N HyperLogLogs, but with high constant times.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; N HyperLogLog를 병합하기위한 O (N)이지만 높은 상수 시간.</target>
        </trans-unit>
        <trans-unit id="b8fbb556b46eccd9ee90a7247a1e35f67f98fd2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) when N is number of commands to look up</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; N이 조회 할 명령 수인 경우 O (N)</target>
        </trans-unit>
        <trans-unit id="7959df06155f35b6ddc9b6d1feda06302841d77a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the length of the list.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 목록의 길이입니다.</target>
        </trans-unit>
        <trans-unit id="72642eae05e7dab533b332c5cc7043121b4eb448" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the length of the list. Setting either the first or the last element of the list is O(1).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 목록의 길이입니다. 목록의 첫 번째 또는 마지막 요소를 설정하는 것은 O (1)입니다.</target>
        </trans-unit>
        <trans-unit id="54b950ebac0582811758a19da3a9877ce7ade111" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the length of the returned string. The complexity is ultimately determined by the returned length, but because creating a substring from an existing string is very cheap, it can be considered O(1) for small strings.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 반환 된 문자열의 길이입니다. 복잡성은 궁극적으로 반환 된 길이에 의해 결정되지만 기존 문자열에서 하위 문자열을 만드는 것이 매우 저렴하므로 작은 문자열의 경우 O (1)로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="164650944548afb8bc10f6f390aa97a27b1dd4ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of arguments to the command</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 명령에 대한 인수의 개수입니다.</target>
        </trans-unit>
        <trans-unit id="35c9a29ad1b88311937abb15a8aa02d7b6b2071f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of bytes in the key</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 키의 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="9b705627d72f2e3b0a12c1259b2f056906d3a9f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of channels to subscribe to.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 구독 할 채널 수입니다.</target>
        </trans-unit>
        <trans-unit id="2f83e12fae75f45cf5ac83c347c3bbc7ddee079d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of client connections</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 클라이언트 연결 수입니다.</target>
        </trans-unit>
        <trans-unit id="705360038b21dac13659c6816299b035d79d167b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of clients already subscribed to a channel.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 이미 채널에 가입 한 클라이언트 수입니다.</target>
        </trans-unit>
        <trans-unit id="c8e85a4ca3be5f0915c51a03733ebbc7a372c660" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of elements being checked for membership</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 구성원 자격을 확인하는 요소의 수입니다.</target>
        </trans-unit>
        <trans-unit id="05df09af2b3ccd9ebe0dace8258bd85ca953d5f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of elements in the list, for the average case. When searching for elements near the head or the tail of the list, or when the MAXLEN option is provided, the command may run in constant time.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 평균 케이스에 대한 목록의 요소 수입니다. 목록의 머리 또는 꼬리 근처에있는 요소를 검색 할 때 또는 MAXLEN 옵션이 제공되면 명령이 일정한 시간에 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be1754ab1e11a40303837cf8c6d9e5080c8b4d4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of elements returned</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 반환 된 요소의 수입니다.</target>
        </trans-unit>
        <trans-unit id="b2d78dda8ec936c399d001d400dd7443b9ee0c51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of elements to be removed by the operation.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 작업으로 제거 할 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="0c40ac5f4e7734966548a6b28cf6b09392f66af6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of elements to traverse before seeing the value pivot. This means that inserting somewhere on the left end on the list (head) can be considered O(1) and inserting somewhere on the right end (tail) is O(N).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 값 피벗을보기 전에 순회 할 요소의 수입니다. 이것은 목록 (헤드)의 왼쪽 끝에 어딘가에 삽입하는 것은 O (1)로 간주 될 수 있고 오른쪽 끝에 어딘가에 삽입하는 것은 O (N)입니다.</target>
        </trans-unit>
        <trans-unit id="dbcd7d04c52b03234566b6cffd32fc24d56f81e6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of elements to traverse to get to the element at index. This makes asking for the first or the last element of the list O(1).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 인덱스에서 요소에 도달하기 위해 순회 할 요소의 수입니다. 이것은리스트 O (1)의 첫 번째 또는 마지막 요소를 요구합니다.</target>
        </trans-unit>
        <trans-unit id="42c9869d291d0c82ca12d37bfb296709124a2c13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of failure reports</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 실패 보고서 수</target>
        </trans-unit>
        <trans-unit id="1725653c90b57cbd60fa6e80c674ffbcb0e5a30e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of fields being requested.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 요청되는 필드 수입니다.</target>
        </trans-unit>
        <trans-unit id="29cd5bade215dc7c3978dfc57c99ee8f499e6f6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of fields being set.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 설정되는 필드 수입니다.</target>
        </trans-unit>
        <trans-unit id="ac2510981dfbc42572f4253d3ef88c1e9b86a518" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of fields to be removed.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 제거 할 필드 수입니다.</target>
        </trans-unit>
        <trans-unit id="c4ed0ee74b36a8a8a6b25ad9938bab2af27ed2f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of keys that will be removed. When a key to remove holds a value other than a string, the individual complexity for this key is O(M) where M is the number of elements in the list, set, sorted set or hash. Removing a single key that holds a string value is O(1).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 제거 할 키 수입니다. 제거 할 키에 문자열 이외의 값이있는 경우이 키의 개별 복잡도는 O (M)입니다. 여기서 M은 목록, 세트, ​​정렬 된 세트 또는 해시의 요소 수입니다. 문자열 값을 보유하는 단일 키를 제거하는 것은 O (1)입니다.</target>
        </trans-unit>
        <trans-unit id="bbd1ae90e162108290b25dbded69c117180e0d98" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of keys that will be touched.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 터치 할 키 수입니다.</target>
        </trans-unit>
        <trans-unit id="fdbd2fc9b2e398ad773c3eec1b76264cf5a60db4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of keys to retrieve.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 검색 할 키 수입니다.</target>
        </trans-unit>
        <trans-unit id="a706ce590717441a0ad18f33b5fc106e514382b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of keys to set.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 설정할 키 수입니다.</target>
        </trans-unit>
        <trans-unit id="8ccf4d49a4b3207dc0caa665856d880472789cd4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of known nodes. The command may execute a FLUSHALL as a side effect.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 알려진 노드의 수입니다. 이 명령은 FLUSHALL을 부작용으로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="234fbf7057a39690aac3e744557088f824f18eb9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of loaded modules.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은로드 된 모듈의 수입니다.</target>
        </trans-unit>
        <trans-unit id="9eb7a9409bf0369b64fc75645b3e9c14e653d7ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of members being requested.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 요청되는 구성원 수입니다.</target>
        </trans-unit>
        <trans-unit id="b3fe05d26b4346f8090d8c22849f30a16797b0db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of members to be removed.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 제거 할 멤버 수입니다.</target>
        </trans-unit>
        <trans-unit id="19a9d92a5f1801bdae13f9bb5335a5eee87a12d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of patterns the client is already subscribed to.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 클라이언트가 이미 가입 한 패턴의 수입니다.</target>
        </trans-unit>
        <trans-unit id="03c2b3882ec00e832d7bf4bd77cbcd9fdcace961" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the number of samples.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 샘플 수입니다.</target>
        </trans-unit>
        <trans-unit id="88531e925e2a262fc6e01dce7370ffcc8ffe2aa6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the set cardinality.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 설정된 카디널리티입니다.</target>
        </trans-unit>
        <trans-unit id="109fedc3e56bcb827556611a78c19db5912e0c01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the size of the hash.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 해시 크기입니다.</target>
        </trans-unit>
        <trans-unit id="baf0055deddfa2f324ba5f8192d8bc7ae7177c81" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the total number of Cluster nodes</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 총 클러스터 노드 수입니다.</target>
        </trans-unit>
        <trans-unit id="fbc1d10e31ece6bfe12f1012df99c1c058c772dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the total number of Redis commands</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 총 Redis 명령 수입니다.</target>
        </trans-unit>
        <trans-unit id="383099b00063b0f99b6c3494f9ebddcefbd84c6f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the total number of elements in all given sets.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 지정된 모든 집합의 총 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="1c69bede051d8ce4bce449d586cb3cccf85a3b93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) where N is the total number of hash slot arguments</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) 여기서 N은 총 해시 슬롯 인수 수입니다.</target>
        </trans-unit>
        <trans-unit id="94b9de6b87d525f4593b39b91d061f1cfc031edb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) with N being the length in bytes of the script body.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N), N은 스크립트 본문의 길이 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="fbd178cb887e9efcf3828efc845699fd78801bc2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) with N being the number of elements being returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N), N은 반환되는 요소 수입니다. N이 일정하면 (예 : 항상 COUNT로 처음 10 개의 요소를 요구하는 경우) O (1)로 간주 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a4fbf27d75b5b5db8cc54e6e838410633f408ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) with N being the number of elements returned, so asking for a small fixed number of entries per call is O(1). O(M), where M is the total number of entries scanned when used with the IDLE filter. When the command returns just the summary and the list of consumers is small, it runs in O(1) time; otherwise, an additional O(N) time for iterating every consumer.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) (N은 반환 된 요소의 수)이므로 호출 당 고정 된 적은 수의 항목을 요청하는 것은 O (1)입니다. O (M), 여기서 M은 IDLE 필터와 함께 사용될 때 스캔 된 총 항목 수입니다. 명령이 요약 만 반환하고 소비자 목록이 작 으면 O (1) 시간에 실행됩니다. 그렇지 않으면 모든 소비자를 반복하기위한 추가 O (N) 시간입니다.</target>
        </trans-unit>
        <trans-unit id="ef329378762b4fc8582540e6f4f372d96643c0a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) with N being the number of elements returned, so asking for a small fixed number of entries per call is O(1). When the command returns just the summary it runs in O(1) time assuming the list of consumers is small, otherwise there is additional O(N) time needed to iterate every consumer.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N), N은 반환 된 요소 수이므로 호출 당 고정 된 수의 항목을 요구하는 것은 O (1)입니다. 명령이 요약 만 반환하면 소비자 목록이 작다고 가정하면 O (1) 시간에 실행됩니다. 그렇지 않으면 모든 소비자를 반복하는 데 추가 O (N) 시간이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="218df20463938b64222d151783fb6950614cef84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) with N being the number of elements returned. If N is constant (e.g. always asking for the first 10 elements with COUNT), you can consider it O(1).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N), N은 반환 된 요소 수입니다. N이 일정하면 (예 : 항상 COUNT로 처음 10 개의 요소를 요구하는 경우) O (1)로 간주 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b769f2671bdcb91c429c85ba7049bb785fd4c85d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) with N being the number of entries shown.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N), N은 표시된 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="59133b1321947fe750ca1f0a99b2da85624821b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) with N being the number of keys in the database, under the assumption that the key names in the database and the given pattern have limited length.</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; 데이터베이스의 키 이름과 주어진 패턴의 길이가 제한되어 있다는 가정하에 N은 데이터베이스의 키 수인 N (N)입니다.</target>
        </trans-unit>
        <trans-unit id="e812a95d6dc88a78e988d85e0cb241d393f6a9fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) with N being the number of returned items for the subcommands CONSUMERS and GROUPS. The STREAM subcommand is O(log N) with N being the number of items in the stream.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N), N은 부속 명령 CONSUMERS 및 GROUPS에 대해 리턴 된 항목 수입니다. STREAM 부속 명령은 O (log N)이며 N은 스트림의 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="0811266035ec21c353438938266dc4d45fea8c09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) with N being the number of scripts in cache</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N), N은 캐시의 스크립트 수</target>
        </trans-unit>
        <trans-unit id="e5c63104f4af7f67dd0af60830b19ca65f07dc0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) with N being the number of scripts to check (so checking a single script is an O(1) operation).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N), N은 확인할 스크립트 수입니다 (따라서 단일 스크립트를 확인하는 것은 O (1) 작업 임).</target>
        </trans-unit>
        <trans-unit id="889ce28aded8be26ce965daeccff0e7ab6d4f60c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N) worst case for collections, where N is the number of nested items. O(1) for string values.</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; O (N) 컬렉션의 최악의 경우, 여기서 N은 중첩 된 항목의 수입니다. 문자열 값의 경우 O (1).</target>
        </trans-unit>
        <trans-unit id="1c61928ca7fc032cf39eb98cafcca19529e956ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N)+O(M log(M)) with N being the sum of the sizes of the input sorted sets, and M being the number of elements in the resulting sorted set.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) + O (M log (M)) : N은 입력 정렬 집합의 크기의 합이며 M은 결과 정렬 집합의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="5968318f2f90c1bfac421db9f175d780f07bf2f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N)+O(M*log(M)) with N being the sum of the sizes of the input sorted sets, and M being the number of elements in the resulting sorted set.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N) + O (M * log (M)) (N은 입력 정렬 된 집합 크기의 합계이고 M은 정렬 된 결과 집합의 요소 수)입니다.</target>
        </trans-unit>
        <trans-unit id="cb8a0bd08cfdfeed7510f4650479d4f57d5c0b6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N), with N being the number of evicted entries. Constant times are very small however, since entries are organized in macro nodes containing multiple entries that can be released with a single deallocation.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N). N은 제거 된 항목 수입니다. 그러나 항목이 단일 할당 해제로 해제 될 수있는 여러 항목을 포함하는 매크로 노드로 구성되므로 상수 시간은 매우 작습니다.</target>
        </trans-unit>
        <trans-unit id="81239567ddd1d1735121c38772afebeabf96f377" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N). Where N is the number of configured users.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N). 여기서 N은 구성된 사용자의 수입니다.</target>
        </trans-unit>
        <trans-unit id="911b4fa9a8329807caa0415ac3d7022ccc3d4ce9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N). Where N is the number of password, command and pattern rules that the user has.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N). 여기서 N은 사용자가 보유한 암호, 명령 및 패턴 규칙의 수입니다.</target>
        </trans-unit>
        <trans-unit id="6e59bdd3196eb6852e3eaef33a3252a3b7a0272e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N). Where N is the number of rules provided.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N). 여기서 N은 제공된 규칙의 수입니다.</target>
        </trans-unit>
        <trans-unit id="bdc1b429e79e5573e78c3286268eb194772e69ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N*K)+O(M*log(M)) worst case with N being the smallest input sorted set, K being the number of input sorted sets and M being the number of elements in the resulting sorted set.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N * K) + O (M * log (M)) 최악의 경우 N이 가장 작은 입력 정렬 집합, K가 입력 정렬 집합 수, M이 결과 정렬 집합의 요소 수 .</target>
        </trans-unit>
        <trans-unit id="9c1deeffbcb58501a80a1b33d7e0d5e93a0d8cb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N * M) 최악의 경우 N은 가장 작은 집합의 카디널리티이고 M은 집합 수입니다.</target>
        </trans-unit>
        <trans-unit id="ffa0e56b07d12c63b932eed91b324ef8dd20295d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N+M) where N is the length of the list and M is the number of elements removed.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N + M) 여기서 N은 목록의 길이이고 M은 제거 된 요소의 수입니다.</target>
        </trans-unit>
        <trans-unit id="95a8b0c4cc096c7df1535211118cb125332a33c1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N+M) where N is the number of clients subscribed to the receiving channel and M is the total number of subscribed patterns (by any client).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N + M) 여기서 N은 수신 채널에 가입 한 클라이언트 수이고 M은 (모든 클라이언트에 의한) 가입 된 패턴의 총 수입니다.</target>
        </trans-unit>
        <trans-unit id="da631a41fc16e91a37f4f1640efce1d728beecf3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N+M) where N is the number of patterns the client is already subscribed and M is the number of total patterns subscribed in the system (by any client).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N + M) 여기서 N은 클라이언트가 이미 가입 한 패턴의 수이고 M은 시스템에서 (모든 클라이언트가) 가입 한 총 패턴의 수입니다.</target>
        </trans-unit>
        <trans-unit id="1545563eee39efef7fdeb146aeb9455c2e173035" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N+M*log(M)) where N is the number of elements in the list or set to sort, and M the number of returned elements. When the elements are not sorted, complexity is currently O(N) as there is a copy step that will be avoided in next releases.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N + M * log (M)) 여기서 N은 목록에 있거나 정렬하도록 설정된 요소 수이며 M은 반환 된 요소 수입니다. 요소가 정렬되지 않은 경우 다음 릴리스에서는 피할 복사 단계가 있으므로 복잡성이 현재 O (N)입니다.</target>
        </trans-unit>
        <trans-unit id="c66a53cba15cd2af0a1695247c3a0aa36e2adc99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N+log(M)) where N is the number of elements in the grid-aligned bounding box area around the shape provided as the filter and M is the number of items inside the shape</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N + log (M)) 여기서 N은 필터로 제공된 모양 주변의 격자 정렬 경계 상자 영역에있는 요소의 수이고 M은 모양 내부의 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="e20974426ea75cce3c73bf120e5bd4311bbf1748" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(N+log(M)) where N is the number of elements inside the bounding box of the circular area delimited by center and radius and M is the number of items inside the index.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (N + log (M)) 여기서 N은 중심과 반지름으로 구분 된 원형 영역의 경계 상자 내부에있는 요소 수이고 M은 인덱스 내부의 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="0b1043d56167b21d4e14680e3c1b432e7de9950b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(S+N) where S is the distance of start offset from HEAD for small lists, from nearest end (HEAD or TAIL) for large lists; and N is the number of elements in the specified range.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (S + N) 여기서 S는 작은 목록의 경우 HEAD에서 시작 오프셋의 거리, 큰 목록의 경우 가장 가까운 끝 (HEAD 또는 TAIL)에서 시작 거리입니다. N은 지정된 범위의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="61d4a476ee392abe69dfb6f735b32eff60ec2a6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log N) where N is the number of client connections</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log N) 여기서 N은 클라이언트 연결 수입니다.</target>
        </trans-unit>
        <trans-unit id="0ba9000410dc73a0148976d8f1ca327c62a7ecf4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log N) with N being the number of messages in the PEL of the consumer group.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log N), N은 소비자 그룹의 PEL에있는 메시지 수입니다.</target>
        </trans-unit>
        <trans-unit id="cf252527ef63c0a8016e53161f0802202a141a2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N))</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log (N))</target>
        </trans-unit>
        <trans-unit id="3617beac7c8f278492f8ebb0822d7866ef5b53bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N)) for each item added, where N is the number of elements in the sorted set.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 추가 된 각 항목에 대한 O (log (N)). 여기서 N은 정렬 된 집합의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="1e9100580063c1e1be14b5cd61da6a708da5cacb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N)) for each member requested, where N is the number of elements in the sorted set.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 요청 된 각 멤버에 대한 O (log (N)). 여기서 N은 정렬 된 세트의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="c3d989bc3d0022508b657a626add9ede9b35fe13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N)) where N is the number of elements in the sorted set.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log (N)) 여기서 N은 정렬 된 집합의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="a01464fde23d7922cd3181b2d140cdc060c292b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N)) where N is the number of requested keys</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log (N)) 여기서 N은 요청 된 키 수입니다.</target>
        </trans-unit>
        <trans-unit id="0b83bd68ddbd557fa31d160256ac1ba5c07dca9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N)) with N being the number of elements in the sorted set.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log (N)) : N은 정렬 된 집합의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="b0ee3fe339d708213eb2152cfd0edecd6a23722f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N)*M) with N being the number of elements in the sorted set, and M being the number of elements popped.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log (N) * M) : N은 정렬 된 집합의 요소 수이고 M은 팝된 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="c8bc61ab47c6f2e5c838fde185e75f06eaede6dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements being returned. If M is constant (e.g. always asking for the first 10 elements with LIMIT), you can consider it O(log(N)).</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log (N) + M) : N은 정렬 된 집합의 요소 수이고 M은 반환되는 요소 수입니다. M이 일정하면 (예 : 항상 LIMIT를 사용하여 처음 10 개 요소를 요구하는 경우) O (log (N))로 간주 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b6424d2e3291317641637c912123d28b25281c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements removed by the operation.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log (N) + M) : N은 정렬 된 집합의 요소 수이고 M은 연산에 의해 제거 된 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="09fbbe6797234161ea410530c85be0b791fc864e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; O(log(N)+M) with N being the number of elements in the sorted set and M the number of elements returned.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; O (log (N) + M) : N은 정렬 된 집합의 요소 수이고 M은 반환 된 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="6959b6340adf97e5fa73bcc0f671fd9f65774e91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; This command actually executes a DUMP+DEL in the source instance, and a RESTORE in the target instance. See the pages of these commands for time complexity. Also an O(N) data transfer between the two instances is performed.</source>
          <target state="translated">&lt;strong&gt;시간 복잡성 :&lt;/strong&gt; 이 명령은 실제로 소스 인스턴스에서 DUMP + DEL을 실행하고 대상 인스턴스에서 RESTORE를 실행합니다. 시간 복잡성에 대해서는이 명령의 페이지를 참조하십시오. 또한 두 인스턴스 간의 O (N) 데이터 전송이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7dcb22d963fb6fc6a195b9cae66b88a740647add" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Time complexity:&lt;/strong&gt; Without the count argument O(1), otherwise O(N) where N is the absolute value of the passed count.</source>
          <target state="translated">&lt;strong&gt;시간 복잡도 :&lt;/strong&gt; 카운트 인수 O (1)이 없으면 O (N). 여기서 N은 전달 된 카운트의 절대 값입니다.</target>
        </trans-unit>
        <trans-unit id="147dce46528f2f7b067e233aa55436c61d0c2c06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WRAP&lt;/strong&gt;: wrap around, both with signed and unsigned integers. In the case of unsigned integers, wrapping is like performing the operation modulo the maximum value the integer can contain (the C standard behavior). With signed integers instead wrapping means that overflows restart towards the most negative value and underflows towards the most positive ones, so for example if an &lt;code&gt;i8&lt;/code&gt; integer is set to the value 127, incrementing it by 1 will yield &lt;code&gt;-128&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;랩&lt;/strong&gt; : 부호있는 정수와 부호없는 정수로 랩 어라운드합니다. 부호없는 정수의 경우 래핑은 연산 모듈로를 수행하는 것과 같이 정수에 포함될 수있는 최대 값 (C 표준 동작)과 같습니다. 부호있는 정수 대신 래핑은 오버플로가 가장 음의 값으로 다시 시작하고 가장 양의 값으로 언더 플로우되는 것을 의미합니다. 예를 들어 &lt;code&gt;i8&lt;/code&gt; 정수가 값 127로 설정되면 1 씩 증가하면 &lt;code&gt;-128&lt;/code&gt; 이 됩니다.</target>
        </trans-unit>
        <trans-unit id="b2f3c6e6f77042ca5e13377abb0968d262d33999" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; Newer versions of Redis Cluster will output, for each Redis instance, not just the IP and port, but also the node ID as third element of the array. In future versions there could be more elements describing the node better. In general a client implementation should just rely on the fact that certain parameters are at fixed positions as specified, but more parameters may follow and should be ignored. Similarly a client library should try if possible to cope with the fact that older versions may just have the IP and port parameter.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; 각 Redis 인스턴스마다 최신 버전의 Redis Cluster가 IP 및 포트뿐만 아니라 어레이의 세 번째 요소 인 노드 ID도 출력합니다. 이후 버전에서는 노드를 더 잘 설명하는 더 많은 요소가있을 수 있습니다. 일반적으로 클라이언트 구현은 특정 매개 변수가 지정된대로 고정 된 위치에 있다는 사실에 의존해야하지만 더 많은 매개 변수가 따를 수 있으므로 무시해야합니다. 마찬가지로 클라이언트 라이브러리는 가능한 경우 이전 버전에 IP 및 포트 매개 변수 만있을 수 있다는 사실에 대처하기 위해 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="60988b111418a5e08cd285cd814fba43de4b4ca0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: When setting the last possible bit (&lt;em&gt;offset&lt;/em&gt; equal to 2&lt;sup&gt;32&lt;/sup&gt; -1) and the string value stored at &lt;em&gt;key&lt;/em&gt; does not yet hold a string value, or holds a small string value, Redis needs to allocate all intermediate memory which can block the server for some time. On a 2010 MacBook Pro, setting bit number 2&lt;sup&gt;32&lt;/sup&gt; -1 (512MB allocation) takes ~300ms, setting bit number 2&lt;sup&gt;30&lt;/sup&gt; -1 (128MB allocation) takes ~80ms, setting bit number 2&lt;sup&gt;28&lt;/sup&gt; -1 (32MB allocation) takes ~30ms and setting bit number 2&lt;sup&gt;26&lt;/sup&gt; -1 (8MB allocation) takes ~8ms. Note that once this first allocation is done, subsequent calls to &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; for the same &lt;em&gt;key&lt;/em&gt; will not have the allocation overhead.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 마지막 가능한 비트를 설정하고 ( &lt;em&gt;오프셋&lt;/em&gt; 2 &lt;sup&gt;32&lt;/sup&gt; -1) &lt;em&gt;키에&lt;/em&gt; 저장된 문자열 값이 문자열 값을 아직 보유하지 않거나 작은 문자열 값을 보유하는 경우 Redis는 모든 중간 메모리를 할당해야합니다. 한동안 서버. 에 2010 맥북 프로, 설정 비트 수를 2 &lt;sup&gt;32&lt;/sup&gt; -1 (512 메가 바이트 할당) ~ 300ms로는, 설정 비트 수를 2 소요 &lt;sup&gt;30&lt;/sup&gt; 평균 80ms가, 설정 비트 수를 2 ~ -1 (128 메가 바이트 할당)이 소요 &lt;sup&gt;(28)&lt;/sup&gt; -1 (32MB의 할당) 소요 ~ 30ms의를 및 설정 비트 수를 2 &lt;sup&gt;(26)&lt;/sup&gt; -1 (8메가바이트 할당) ~ 8ms의 걸린다. 이 첫 번째 할당이 완료되면 동일한 &lt;em&gt;키에&lt;/em&gt; 대한 후속 &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; 호출&lt;em&gt;&lt;/em&gt; 할당 오버 헤드가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1cc9feb2e460988167276c1d1f2c4a7519bea033" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: When setting the last possible byte and the string value stored at &lt;em&gt;key&lt;/em&gt; does not yet hold a string value, or holds a small string value, Redis needs to allocate all intermediate memory which can block the server for some time. On a 2010 MacBook Pro, setting byte number 536870911 (512MB allocation) takes ~300ms, setting byte number 134217728 (128MB allocation) takes ~80ms, setting bit number 33554432 (32MB allocation) takes ~30ms and setting bit number 8388608 (8MB allocation) takes ~8ms. Note that once this first allocation is done, subsequent calls to &lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; for the same &lt;em&gt;key&lt;/em&gt; will not have the allocation overhead.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : 마지막 가능한 바이트를 설정하고 &lt;em&gt;키에&lt;/em&gt; 저장된 문자열 값이 문자열 값을 아직 보유하지 않거나 작은 문자열 값을 보유하는 경우 Redis는 한동안 서버를 차단할 수있는 모든 중간 메모리를 할당해야합니다. 2010 MacBook Pro에서 바이트 번호 설정 536870911 (512MB 할당)은 ~ 300ms, 바이트 번호 설정 134217728 (128MB 할당)은 ~ 80ms, 설정 비트 번호 33554432 (32MB 할당)는 ~ 30ms, 설정 비트 번호 8388608 (8MB 할당) ~ 8ms 걸립니다. 이 첫 번째 할당이 완료되면 동일한 &lt;em&gt;키에&lt;/em&gt; 대한 &lt;a href=&quot;setrange&quot;&gt;SETRANGE에&lt;/a&gt; 대한 후속 호출 에는 할당 오버 헤드가 없습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc795566bfbbbe6af9c65583f2a47cdaddd23f92" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: consider &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; as a command that should only be used in production environments with extreme care. It may ruin performance when it is executed against large databases. This command is intended for debugging and special operations, such as changing your keyspace layout. Don't use &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; in your regular application code. If you're looking for a way to find keys in a subset of your keyspace, consider using &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; or &lt;a href=&quot;https://redis.io/topics/data-types#sets&quot;&gt;sets&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; : &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; 는 매우 신중하게 프로덕션 환경에서만 사용해야하는 명령으로 간주하십시오 . 큰 데이터베이스에 대해 실행될 때 성능이 저하 될 수 있습니다. 이 명령은 키 스페이스 레이아웃 변경과 같은 디버깅 및 특수 작업을위한 것입니다. 일반 응용 프로그램 코드에서 &lt;a href=&quot;keys&quot;&gt;키&lt;/a&gt; 를 사용하지 마십시오 . 키 공간의 하위 세트에서 키를 찾는 방법을 찾고 있다면 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 또는 &lt;a href=&quot;https://redis.io/topics/data-types#sets&quot;&gt;sets&lt;/a&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8bd7e5fae76f9719ccdb7cd784632dfb7da420a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: this command was renamed to &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt;, it is called &lt;code&gt;SUBSTR&lt;/code&gt; in Redis versions &lt;code&gt;&amp;lt;= 2.0&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; :이 명령은 &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; 로 이름이 바뀌 었으며 Redis 버전 &lt;code&gt;&amp;lt;= 2.0&lt;/code&gt; 에서는 &lt;code&gt;SUBSTR&lt;/code&gt; 이라고 합니다.</target>
        </trans-unit>
        <trans-unit id="56894dc250c01689ce8089e2e0329a40fd8dd202" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;XX&lt;/strong&gt;: Only update elements that already exist. Never add elements.</source>
          <target state="translated">&lt;strong&gt;XX&lt;/strong&gt; : 이미 존재하는 요소 만 업데이트합니다. 요소를 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="79f2215b8211f0266085dd38bf62ef277714a037" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;flags&lt;/strong&gt;: A list of tracking flags used by the connection. The flags and their meanings are as follows:</source>
          <target state="translated">&lt;strong&gt;flags&lt;/strong&gt; : 연결에 사용되는 추적 플래그 목록입니다. 플래그와 그 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8bff7d4c72f517ddfeda551b647e8e7d1217bc74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ft&lt;/strong&gt; for feet.</source>
          <target state="translated">&lt;strong&gt;피트&lt;/strong&gt; 피트.</target>
        </trans-unit>
        <trans-unit id="8f7d99307167d9151fd26962853701edfbb5519b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;km&lt;/strong&gt; for kilometers.</source>
          <target state="translated">&lt;strong&gt;km&lt;/strong&gt; 킬로미터.</target>
        </trans-unit>
        <trans-unit id="39044bc6a455c022d39a0d72ae45f195d8b8c1b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;m&lt;/strong&gt; for meters.</source>
          <target state="translated">&lt;strong&gt;미터의&lt;/strong&gt; 경우 m입니다.</target>
        </trans-unit>
        <trans-unit id="38968a64d0a0bdede6ba3cbc6aaa2f8a596ba38b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mi&lt;/strong&gt; for miles.</source>
          <target state="translated">&lt;strong&gt;마일&lt;/strong&gt; 마일.</target>
        </trans-unit>
        <trans-unit id="f65ab91ff705eaf146385fb92e3f79cd354cc871" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;prefixes&lt;/strong&gt;: A list of key prefixes for which notifications are sent to the client.</source>
          <target state="translated">&lt;strong&gt;prefixes&lt;/strong&gt; : 알림이 클라이언트로 전송되는 키 접두사 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d5d5889b4f35b20aa026439c189327fda685cba3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;redirect&lt;/strong&gt;: The client ID used for notifications redirection, or -1 when none.</source>
          <target state="translated">&lt;strong&gt;redirect&lt;/strong&gt; : 알림 리디렉션에 사용되는 클라이언트 ID 또는없는 경우 -1입니다.</target>
        </trans-unit>
        <trans-unit id="f1d42ce2c0a6643ac20a613b522833d936ce6141" translate="yes" xml:space="preserve">
          <source>@example:</source>
          <target state="translated">@example:</target>
        </trans-unit>
        <trans-unit id="fe6b32ebf673080ac2625dc05bc8a2f62d943f4e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;nil&lt;/code&gt; multi-bulk when no element could be popped and the timeout expired.</source>
          <target state="translated">&lt;code&gt;nil&lt;/code&gt; 멀티 대부분은 어떤 요소가 튀어없고 시간 제한이 만료 될 수있을 때.</target>
        </trans-unit>
        <trans-unit id="f954a25307e91dd61c331fb6ced8f1d1b49d2dc9" translate="yes" xml:space="preserve">
          <source>A client can acquire the lock if the above command returns &lt;code&gt;OK&lt;/code&gt; (or retry after some time if the command returns Nil), and remove the lock just using &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;.</source>
          <target state="translated">클라이언트는 위의 명령이 &lt;code&gt;OK&lt;/code&gt; 를 리턴하면 잠금을 획득하고 (또는 명령이 Nil을 리턴하면 잠시 후 다시 시도) &lt;a href=&quot;del&quot;&gt;DEL을&lt;/a&gt; 사용하여 잠금을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e66fa09299df120a7f69c64e83980359faba0b3" translate="yes" xml:space="preserve">
          <source>A client may be able to check if the operation succeeded using the &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; command.</source>
          <target state="translated">클라이언트는 &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; 명령을 사용하여 작업이 성공했는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1557c0a8f4b2cceda8fceff02fc1420f6f4eff1c" translate="yes" xml:space="preserve">
          <source>A client may use GETSET in order to atomically get the current counter value and reset it to zero.</source>
          <target state="translated">클라이언트는 현재 카운터 값을 원자 적으로 가져 와서 0으로 재설정하기 위해 GETSET을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68a796147e39e14a8a80bf764ddfd90ce6919a38" translate="yes" xml:space="preserve">
          <source>A common pattern is to call &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; to load all the scripts that will appear in a pipeline, then use &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; directly inside the pipeline without any need to check for errors resulting from the script hash not being recognized.</source>
          <target state="translated">일반적인 패턴은 &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; 를 호출 하여 파이프 라인에 나타날 모든 스크립트를로드 한 다음 스크립트 해시가 인식되지 않아 발생하는 오류를 확인할 필요없이 파이프 라인 내에서 직접 &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="476c40353d34c43082faec86bb0fe02b5da4c638" translate="yes" xml:space="preserve">
          <source>A common use of &lt;a href=&quot;ltrim&quot;&gt;LTRIM&lt;/a&gt; is together with &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; / &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;ltrim&quot;&gt;LTRIM&lt;/a&gt; 의 일반적인 사용은 &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; / &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; 와 함께 사용 됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ffc2830e7247029a8f3dd963d6dc9ccb6bc1e19" translate="yes" xml:space="preserve">
          <source>A consumer can be destroyed completely by using the following form:</source>
          <target state="translated">다음 형식을 사용하여 소비자를 완전히 파기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f4f5def69a34383d0c0ba099fdc329e197223e5" translate="yes" xml:space="preserve">
          <source>A consumer group can be destroyed completely by using the following form:</source>
          <target state="translated">소비자 그룹은 다음 형식을 사용하여 완전히 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39aaf38b13fe32608e93e62cb065f0bce6d7d689" translate="yes" xml:space="preserve">
          <source>A does no longer known node D (see step 3), so it starts an handshake with D.</source>
          <target state="translated">A는 더 이상 노드 D를 알지 못하므로 (3 단계 참조) D와의 핸드 셰이크를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="1ff437bc625fc822edf5fa54a7c14c51cb9019e8" translate="yes" xml:space="preserve">
          <source>A few more details:</source>
          <target state="translated">몇 가지 세부 사항 :</target>
        </trans-unit>
        <trans-unit id="e03e2d0aaad7167505a0638399e7a4066ed67ed8" translate="yes" xml:space="preserve">
          <source>A few remarks:</source>
          <target state="translated">몇 가지 말 :</target>
        </trans-unit>
        <trans-unit id="d21e3dd0e34aa1b90513d361d662f4d66565fe3b" translate="yes" xml:space="preserve">
          <source>A full iteration always retrieves all the elements that were present in the collection from the start to the end of a full iteration. This means that if a given element is inside the collection when an iteration is started, and is still there when an iteration terminates, then at some point &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; returned it to the user.</source>
          <target state="translated">전체 반복은 항상 전체 반복의 시작부터 끝까지 콜렉션에 존재하는 모든 요소를 ​​검색합니다. 이는 반복이 시작될 때 주어진 요소가 콜렉션 내에 있고 반복이 종료 될 때 여전히 존재하는 경우, 어느 시점에서 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 이 사용자에게이를 리턴 했음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="5ea8259e546c110ba56b58d1a577aee64262f6ae" translate="yes" xml:space="preserve">
          <source>A full iteration never returns any element that was NOT present in the collection from the start to the end of a full iteration. So if an element was removed before the start of an iteration, and is never added back to the collection for all the time an iteration lasts, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; ensures that this element will never be returned.</source>
          <target state="translated">전체 반복은 전체 반복의 시작부터 끝까지 컬렉션에없는 요소를 반환하지 않습니다. 따라서 반복이 시작되기 전에 요소가 제거되고 반복이 지속될 때까지 컬렉션에 다시 추가되지 않는 경우 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 은이 요소가 반환되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="c74bd09914eb3c14414c0bb5129eab13261f0d53" translate="yes" xml:space="preserve">
          <source>A given element may be returned multiple times. It is up to the application to handle the case of duplicated elements, for example only using the returned elements in order to perform operations that are safe when re-applied multiple times.</source>
          <target state="translated">주어진 요소는 여러 번 반환 될 수 있습니다. 여러 번 다시 적용 할 때 안전한 작업을 수행하기 위해 반환 된 요소 만 사용하는 등 복제 된 요소의 경우를 처리하는 것은 응용 프로그램의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="32f5993390055907ef7db78baaadce5c67d04be3" translate="yes" xml:space="preserve">
          <source>A key is passively expired simply when some client tries to access it, and the key is found to be timed out.</source>
          <target state="translated">키는 일부 클라이언트가 액세스하려고 할 때 수동적으로 만료되며 키가 시간 초과 된 것으로 확인되었습니다.</target>
        </trans-unit>
        <trans-unit id="3e57f13b09da6c6eb207460804c98b55825c2f9d" translate="yes" xml:space="preserve">
          <source>A manual failover is a special kind of failover that is usually executed when there are no actual failures, but we wish to swap the current master with one of its replicas (which is the node we send the command to), in a safe way, without any window for data loss. It works in the following way:</source>
          <target state="translated">수동 장애 조치는 일반적으로 실제 장애가 없을 때 실행되는 특수한 종류의 장애 조치이지만 현재 마스터를 복제본 (명령을 보내는 노드) 중 하나와 안전하게 교환하려고합니다. 데이터 손실에 대한 창이 없습니다. 다음과 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5eb7eb4b7c9af1e8cd4b04308f1be845c7ce2454" translate="yes" xml:space="preserve">
          <source>A multi bulk reply containing two elements:</source>
          <target state="translated">두 가지 요소를 포함하는 다중 대량 응답 :</target>
        </trans-unit>
        <trans-unit id="95185c923ff66d3971c363a0323cd29e0c25489f" translate="yes" xml:space="preserve">
          <source>A node flags another node with &lt;code&gt;PFAIL&lt;/code&gt; when the node is not reachable for a time greater than the configured &lt;em&gt;node timeout&lt;/em&gt;, which is a fundamental configuration parameter of a Redis Cluster.</source>
          <target state="translated">Redis 클러스터의 기본 구성 매개 변수 인 구성된 &lt;em&gt;노드 시간 초과&lt;/em&gt; 보다 큰 시간 동안 노드에 도달 할 수없는 경우 노드는 다른 노드에 &lt;code&gt;PFAIL&lt;/code&gt; 을 표시합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8c45c3a601d1105d05600d28edf7cbc3726d0fee" translate="yes" xml:space="preserve">
          <source>A replica will always accept the command, assuming that:</source>
          <target state="translated">다음을 가정하면 복제본은 항상 명령을 수락합니다.</target>
        </trans-unit>
        <trans-unit id="fa3bae76123b4add6aeab64ce12d553400e1ce76" translate="yes" xml:space="preserve">
          <source>A replica with AOF enabled, reconnected with its master, performed a full resynchronization, and restarted the AOF file, triggering the initial AOF creation process. In this case not completing the AOF rewrite is dangerous because the latest dataset received from the master would be lost. The new master can actually be even a different instance (if the &lt;strong&gt;REPLICAOF&lt;/strong&gt; or &lt;strong&gt;SLAVEOF&lt;/strong&gt; command was used in order to reconfigure the replica), so it is important to finish the AOF rewrite and start with the correct data set representing the data set in memory when the server was terminated.</source>
          <target state="translated">AOF를 활성화하고 마스터와 다시 연결 한 복제본은 전체 재 동기화를 수행하고 AOF 파일을 다시 시작하여 초기 AOF 작성 프로세스를 트리거합니다. 이 경우 AOF 다시 쓰기를 완료하지 않으면 마스터에서받은 최신 데이터 세트가 손실되므로 위험합니다. 새 마스터는 실제로 다른 인스턴스 일 수도 있습니다 ( 복제본을 재구성하기 위해 &lt;strong&gt;REPLICAOF&lt;/strong&gt; 또는 &lt;strong&gt;SLAVEOF&lt;/strong&gt; 명령이 사용 된 경우). AOF 다시 쓰기를 마치고 메모리의 데이터 세트를 나타내는 올바른 데이터 세트로 시작하는 것이 중요합니다. 서버가 종료되었습니다.</target>
        </trans-unit>
        <trans-unit id="34774babccc209638e8661b505cce11cc8900748" translate="yes" xml:space="preserve">
          <source>A similar pattern where user IDs are used instead of days is described in the article called &quot;&lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;Fast easy realtime metrics using Redis bitmaps&lt;/a&gt;&quot;.</source>
          <target state="translated">사용자 ID가 며칠 대신 사용되는 유사한 패턴은 &quot; &lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;Redis 비트 맵을 사용하는 빠르고 쉬운 실시간 메트릭&lt;/a&gt; &quot;이라는 기사에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3892260963af39063ee4c79a4c6f5fc7f079e501" translate="yes" xml:space="preserve">
          <source>A simple example follows:</source>
          <target state="translated">간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ddef64b774f3cd5fc1e62ed561def95b846b563" translate="yes" xml:space="preserve">
          <source>A stream entry ID identifies a given entry inside a stream. The &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; command will auto-generate a unique ID for you if the ID argument specified is the &lt;code&gt;*&lt;/code&gt; character (asterisk ASCII character). However, while useful only in very rare cases, it is possible to specify a well-formed ID, so that the new entry will be added exactly with the specified ID.</source>
          <target state="translated">스트림 항목 ID는 스트림 내에서 지정된 항목을 식별합니다. &lt;a href=&quot;xadd&quot;&gt;XADD에&lt;/a&gt; 지정된 ID 인수가 있다면 명령 의지는 당신을위한 고유 ID를 자동 생성 &lt;code&gt;*&lt;/code&gt; 문자 (별표 ASCII 문자). 그러나 매우 드문 경우에만 유용하지만 올바르게 구성된 ID를 지정하여 새 항목이 지정된 ID로 정확하게 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="479cfb48bf8e24ebd7be595311042ddf37b14add" translate="yes" xml:space="preserve">
          <source>A symmetrical pattern applies to iterating the stream with &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt;. The only difference is that the client needs to decrement the ID for the subsequent calls. When decrementing an ID with a sequence part of 0, the timestamp needs to be decremented by 1 and the sequence set to 18446744073709551615.</source>
          <target state="translated">대칭 패턴은 &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE를 사용&lt;/a&gt; 하여 스트림을 반복하는 데 적용됩니다 . 유일한 차이점은 클라이언트가 후속 호출을 위해 ID를 줄여야한다는 것입니다. 시퀀스 부분이 0 인 ID를 감소시킬 때 타임 스탬프를 1만큼 감소시키고 시퀀스를 18446744073709551615로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="79fd7f6eb47e05e442bf21424b70a285e07cd4c7" translate="yes" xml:space="preserve">
          <source>A three-element multi-bulk with the first element being the name of the key where a member was popped, the second element being the score of the popped member, and the third element being the popped member itself.</source>
          <target state="translated">첫 번째 요소가 멤버가 팝된 키의 이름이고, 두 번째 요소가 팝된 멤버의 점수이며, 세 번째 요소가 팝된 멤버 자체 인 3 요소 다중 벌크입니다.</target>
        </trans-unit>
        <trans-unit id="dd483a4936cc58e47c6e0c862b9b256fd5f40d67" translate="yes" xml:space="preserve">
          <source>A three-element multi-bulk with the first element being the name of the key where a member was popped, the second element is the popped member itself, and the third element is the score of the popped element.</source>
          <target state="translated">첫 번째 요소는 멤버가 팝된 키의 이름이고 두 번째 요소는 팝된 멤버 자체이며 세 번째 요소는 팝된 요소의 점수 인 3 요소 다중 벌크입니다.</target>
        </trans-unit>
        <trans-unit id="30306183666392fcaecc22c35fce7e7cb3af8d67" translate="yes" xml:space="preserve">
          <source>A timeout of 0 means to block forever.</source>
          <target state="translated">시간 초과가 0이면 영원히 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="a17d8e24b3173ee841bfca950e5b33f8d2311769" translate="yes" xml:space="preserve">
          <source>A two-element multi-bulk with the first element being the name of the key where an element was popped and the second element being the value of the popped element.</source>
          <target state="translated">첫 번째 요소가 요소가 팝된 키의 이름이고 두 번째 요소가 팝된 요소의 값인 2 요소 다중 벌크입니다.</target>
        </trans-unit>
        <trans-unit id="316a7d352276951a851baa176c56bd0646785b6b" translate="yes" xml:space="preserve">
          <source>A unique progressive identifier for every slow log entry.</source>
          <target state="translated">느린 로그 항목마다 고유 한 점진적 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="15e5288f998531a56ed6ca49f3cc22bfec1a3be1" translate="yes" xml:space="preserve">
          <source>A very important part of scripting is writing scripts that are pure functions. Scripts executed in a Redis instance are, by default, propagated to replicas and to the AOF file by sending the script itself -- not the resulting commands.</source>
          <target state="translated">스크립팅의 매우 중요한 부분은 순수한 기능인 스크립트를 작성하는 것입니다. Redis 인스턴스에서 실행되는 스크립트는 기본적으로 결과 명령이 아닌 스크립트 자체를 전송하여 복제본 및 AOF 파일로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="3f08cc0b30779a95143aa2ad65f0531b4ad12960" translate="yes" xml:space="preserve">
          <source>ACL</source>
          <target state="translated">ACL</target>
        </trans-unit>
        <trans-unit id="bc430f327a0dfce882c15dba5919c945f0c506c4" translate="yes" xml:space="preserve">
          <source>ACL CAT  [categoryname]   List the ACL categories or the commands inside a category</source>
          <target state="translated">ACL CAT [categoryname] ACL 범주 또는 범주 내의 명령을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="7a99f2ae2af74997dec699c3ee26e8588c57d631" translate="yes" xml:space="preserve">
          <source>ACL DELUSER  username [username ...]   Remove the specified ACL users and the associated rules</source>
          <target state="translated">ACL DELUSER 사용자 이름 [사용자 이름 ...] 지정된 ACL 사용자 및 관련 규칙을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="d663a64f02d722e9b6dea0bd46e9eca64230b913" translate="yes" xml:space="preserve">
          <source>ACL GENPASS  [bits]   Generate a pseudorandom secure password to use for ACL users</source>
          <target state="translated">ACL GENPASS [비트] ACL 사용자를 위해 사용할 의사 난수 보안 암호를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ccd5643086b968b1f31b01ef02819987f26c5b3f" translate="yes" xml:space="preserve">
          <source>ACL GETUSER  username   Get the rules for a specific ACL user</source>
          <target state="translated">ACL GETUSER username 특정 ACL 사용자에 대한 규칙을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d619439d71c4f34f055718e677b13c4a9f275fe6" translate="yes" xml:space="preserve">
          <source>ACL HELP   Show helpful text about the different subcommands</source>
          <target state="translated">ACL HELP 여러 하위 명령에 대한 유용한 텍스트를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="31850beea1f3f69071e6c33928156ade6e00ab45" translate="yes" xml:space="preserve">
          <source>ACL LIST   List the current ACL rules in ACL config file format</source>
          <target state="translated">ACL LIST 현재 ACL 규칙을 ACL 구성 파일 형식으로 나열합니다.</target>
        </trans-unit>
        <trans-unit id="35e0627557d51800ee03c74a4ab45c1e764447ec" translate="yes" xml:space="preserve">
          <source>ACL LOAD   Reload the ACLs from the configured ACL file</source>
          <target state="translated">ACL LOAD 구성된 ACL 파일에서 ACL을 다시로드합니다.</target>
        </trans-unit>
        <trans-unit id="f7757a7da13bd653d8ee430ba3397119594c5d47" translate="yes" xml:space="preserve">
          <source>ACL LOG  [count or RESET]   List latest events denied because of ACLs in place</source>
          <target state="translated">ACL LOG [count or RESET] ACL로 인해 거부 된 최신 이벤트를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="5cb5c1414dee386d2b8fa30e2bbdd0a6a97cfc28" translate="yes" xml:space="preserve">
          <source>ACL SAVE   Save the current ACL rules in the configured ACL file</source>
          <target state="translated">ACL SAVE 구성된 ACL 파일에 현재 ACL 규칙을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="0386be79c39f606185e4b53f1222d64719e174a0" translate="yes" xml:space="preserve">
          <source>ACL SETUSER  username [rule [rule ...]]   Modify or create the rules for a specific ACL user</source>
          <target state="translated">ACL SETUSER 사용자 이름 [규칙 [규칙 ...]] 특정 ACL 사용자에 대한 규칙 수정 또는 생성</target>
        </trans-unit>
        <trans-unit id="27bb308c77e1daac95122fff219a2c6daae7b052" translate="yes" xml:space="preserve">
          <source>ACL USERS   List the username of all the configured ACL rules</source>
          <target state="translated">ACL USERS 구성된 모든 ACL 규칙의 사용자 이름을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="2b429eef7f087085b63c833ef1bc25427befe100" translate="yes" xml:space="preserve">
          <source>ACL WHOAMI   Return the name of the user associated to the current connection</source>
          <target state="translated">ACL WHOAMI 현재 연결에 연결된 사용자의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="de304c50ff9bb5fdd452722c0dd161577af28608" translate="yes" xml:space="preserve">
          <source>ACL categories are very useful in order to create ACL rules that include or exclude a large set of commands at once, without specifying every single command. For instance, the following rule will let the user &lt;code&gt;karin&lt;/code&gt; perform everything but the most dangerous operations that may affect the server stability:</source>
          <target state="translated">ACL 범주는 모든 단일 명령을 지정하지 않고 한 번에 많은 명령 집합을 포함하거나 제외하는 ACL 규칙을 만드는 데 매우 유용합니다. 예를 들어 다음 규칙은 사용자 &lt;code&gt;karin&lt;/code&gt; 이 서버 안정성에 영향을 미칠 수있는 가장 위험한 작업을 제외한 모든 작업을 수행 하도록 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="8cd4194a6879685c31702a0f68b0e7134e8b8f11" translate="yes" xml:space="preserve">
          <source>ACL rules are either words like &quot;on&quot;, &quot;off&quot;, &quot;reset&quot;, &quot;allkeys&quot;, or are special rules that start with a special character, and are followed by another string (without any space in between), like &quot;+SET&quot;.</source>
          <target state="translated">ACL 규칙은 &quot;on&quot;, &quot;off&quot;, &quot;reset&quot;, &quot;allkeys&quot;와 같은 단어이거나 특수 문자로 시작하고 뒤에 &quot;+와 같은 다른 문자열 (사이에 공백 없음)이 오는 특수 규칙입니다. 세트&quot;.</target>
        </trans-unit>
        <trans-unit id="46b7d0e52e6b348d0ca3dd5bb91a67c4c26f9bb9" translate="yes" xml:space="preserve">
          <source>ACL users need a solid password in order to authenticate to the server without security risks. Such password does not need to be remembered by humans, but only by computers, so it can be very long and strong (unguessable by an external attacker). The &lt;a href=&quot;acl-genpass&quot;&gt;ACL GENPASS&lt;/a&gt; command generates a password starting from /dev/urandom if available, otherwise (in systems without /dev/urandom) it uses a weaker system that is likely still better than picking a weak password by hand.</source>
          <target state="translated">ACL 사용자는 보안 위험없이 서버에 인증하기 위해 견고한 암호가 필요합니다. 이러한 암호는 사람이 기억할 필요가없고 컴퓨터 만 기억할 필요가 있으므로 매우 길고 강력 할 수 있습니다 (외부 공격자가 추측 할 수 없음). &lt;a href=&quot;acl-genpass&quot;&gt;ACL GENPASS의&lt;/a&gt; 명령 (없이 시스템은 / dev / urandom가)는 / dev / urandom을 사용할 수있는 경우, 그렇지 않으면에서 시작하는 암호를 생성 여전히 가능성이 더 나은 손으로 약한 암호를 따기보다 약한 시스템을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="025e07020e93e25579c1a9621d736dca0c1f26de" translate="yes" xml:space="preserve">
          <source>APPEND</source>
          <target state="translated">APPEND</target>
        </trans-unit>
        <trans-unit id="909ab7e7d0327d1bb12d101958258d2a08b6daae" translate="yes" xml:space="preserve">
          <source>APPEND  key value   Append a value to a key</source>
          <target state="translated">APPEND 키 값 키에 값 추가</target>
        </trans-unit>
        <trans-unit id="4a79bd00448baad864aa37f5d6d5b74bace69207" translate="yes" xml:space="preserve">
          <source>AUTH</source>
          <target state="translated">AUTH</target>
        </trans-unit>
        <trans-unit id="8a19c3946c86f4dea93819cfedf078d402be1b45" translate="yes" xml:space="preserve">
          <source>AUTH  [username] password   Authenticate to the server</source>
          <target state="translated">AUTH [사용자 이름] 암호 서버에 인증</target>
        </trans-unit>
        <trans-unit id="ffc2673c91de7fcb166409594eaaaec1f96c75c1" translate="yes" xml:space="preserve">
          <source>AUTH  password   Authenticate to the server</source>
          <target state="translated">AUTH 비밀번호 서버에 인증</target>
        </trans-unit>
        <trans-unit id="043bd74983959c0554262d35de5c14a4ec21d462" translate="yes" xml:space="preserve">
          <source>Accessing a &lt;em&gt;non existing&lt;/em&gt; global variable generates a similar error.</source>
          <target state="translated">&lt;em&gt;존재하지 않는&lt;/em&gt; 전역 변수에 액세스하면 비슷한 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7aba5231117223c71bfb7ad628b907a035c73c59" translate="yes" xml:space="preserve">
          <source>Accessing individual elements in the time series is not hard:</source>
          <target state="translated">시계열의 개별 요소에 액세스하는 것은 어렵지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8496994d3923ed6948840c095615350a859b9bf8" translate="yes" xml:space="preserve">
          <source>Accumulate all the commands to send into the pipeline, then check for &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; commands and use the &lt;a href=&quot;script-exists&quot;&gt;SCRIPT EXISTS&lt;/a&gt; command to check if all the scripts are already defined. If not, add &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; commands on top of the pipeline as required, and use &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; for all the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; calls.</source>
          <target state="translated">파이프 라인으로 보낼 모든 명령을 누적 한 다음 &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 명령 을 확인 하고 &lt;a href=&quot;script-exists&quot;&gt;SCRIPT EXISTS&lt;/a&gt; 명령을 사용하여 모든 스크립트가 이미 정의되어 있는지 확인하십시오. 그렇지 않은 경우 필요에 따라 파이프 라인 위에 &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; 명령을 추가 하고 모든 &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 호출에 &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="331fbf87d679488dd37eba43acb4cb291a720fed" translate="yes" xml:space="preserve">
          <source>Add the specified members to the set stored at &lt;code&gt;key&lt;/code&gt;. Specified members that are already a member of this set are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, a new set is created before adding the specified members.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 세트에 지정된 멤버를 추가하십시오 . 이미이 세트의 멤버 인 지정된 멤버는 무시됩니다. 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 새로운 세트가 지정된 멤버를 추가하기 전에 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6ea5ef09a89f93581e248dcc20539555e85c3a48" translate="yes" xml:space="preserve">
          <source>Additional examples</source>
          <target state="translated">추가 예</target>
        </trans-unit>
        <trans-unit id="d82c2de775c1d427f5a69cd870df943898595234" translate="yes" xml:space="preserve">
          <source>Additional information about streams</source>
          <target state="translated">스트림에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="63f2e4028cc4ac44d53adec5078f20b4aa655ee5" translate="yes" xml:space="preserve">
          <source>Additional introspective information about the server's memory can be obtained by referring to the &lt;a href=&quot;memory-stats&quot;&gt;MEMORY STATS&lt;/a&gt; command and the &lt;a href=&quot;memory-doctor&quot;&gt;MEMORY DOCTOR&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;memory-stats&quot;&gt;MEMORY STATS&lt;/a&gt; 명령 및 &lt;a href=&quot;memory-doctor&quot;&gt;MEMORY DOCTOR&lt;/a&gt; 를 참조하여 서버 메모리에 대한 추가 내성적 인 정보를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c068579fdb28b0028f94bb0b4e4013c53766748" translate="yes" xml:space="preserve">
          <source>Addressing with &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; bits outside the current string length (including the case the key does not exist at all), results in the operation to be performed like the missing part all consists of bits set to 0.</source>
          <target state="translated">현재 문자열 길이를 벗어난 &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; 비트로 주소를 지정 하면 (키가 전혀 존재하지 않는 경우 포함) 누락 된 부분이 모두 0으로 설정된 비트로 구성된 것처럼 작업이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="049c8196ab72e0b22baf65855e45482a2e4f33a5" translate="yes" xml:space="preserve">
          <source>Addressing with &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; or &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; bits outside the current string length will enlarge the string, zero-padding it, as needed, for the minimal length needed, according to the most far bit touched.</source>
          <target state="translated">현재 문자열 길이를 벗어난 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 또는 &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; 비트로 주소를 지정 하면 가장 많이 터치 한 비트에 따라 필요한 최소 길이 동안 문자열이 0으로 채워지고 필요에 따라 채워집니다.</target>
        </trans-unit>
        <trans-unit id="46ebddce5151e5408360a67a147fb399e9415717" translate="yes" xml:space="preserve">
          <source>Adds all the element arguments to the HyperLogLog data structure stored at the variable name specified as first argument.</source>
          <target state="translated">첫 번째 인수로 지정된 변수 이름에 저장된 HyperLogLog 데이터 구조에 모든 요소 인수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0d4e52a890415189fc8fbc4fe75cf4354f3f9990" translate="yes" xml:space="preserve">
          <source>Adds all the specified members with the specified scores to the sorted set stored at &lt;code&gt;key&lt;/code&gt;. It is possible to specify multiple score / member pairs. If a specified member is already a member of the sorted set, the score is updated and the element reinserted at the right position to ensure the correct ordering.</source>
          <target state="translated">지정된 점수를 가진 지정된 모든 멤버를 &lt;code&gt;key&lt;/code&gt; 에 저장된 정렬 된 세트에 추가합니다 . 여러 점수 / 멤버 쌍을 지정할 수 있습니다. 지정된 멤버가 이미 정렬 된 세트의 멤버 인 경우, 올바른 순서를 보장하기 위해 점수가 업데이트되고 요소가 올바른 위치에 다시 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="9ab250d73059710f6ef408c991e35ff53cf7dd2c" translate="yes" xml:space="preserve">
          <source>Adds the specified geospatial items (latitude, longitude, name) to the specified key. Data is stored into the key as a sorted set, in a way that makes it possible to later retrieve items using a query by radius with the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; or &lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER&lt;/a&gt; commands.</source>
          <target state="translated">지정된 지리 공간 항목 (위도, 경도, 이름)을 지정된 키에 추가합니다. 데이터는 나중에 &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; 또는 &lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER&lt;/a&gt; 명령 으로 반경별로 쿼리를 사용하여 항목을 검색 할 수 있도록 정렬 된 세트로 키에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="a55c334e8c8de33a282dd83cae30a6fa98652879" translate="yes" xml:space="preserve">
          <source>Advanced Pattern: accessing bitmap ranges</source>
          <target state="translated">고급 패턴 : 비트 맵 범위 액세스</target>
        </trans-unit>
        <trans-unit id="7de859f0d7f7123c628115946a45405250e8beb6" translate="yes" xml:space="preserve">
          <source>Advances the cluster config epoch.</source>
          <target state="translated">클러스터 구성 시대를 진행합니다.</target>
        </trans-unit>
        <trans-unit id="610e6e414b98337a7416af1551f4bb3d49943eed" translate="yes" xml:space="preserve">
          <source>After an &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; of a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; block with multiple push operations against the same list.</source>
          <target state="translated">동일한 목록에 대해 여러 푸시 조작 이있는 &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; 블록 의 &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; 후 .</target>
        </trans-unit>
        <trans-unit id="09dd535abc4afd038e1eb1f87d89a6d8d915ae74" translate="yes" xml:space="preserve">
          <source>After resetting an user, it returns back to the status it has when it was just created: non active (off rule), can't execute any command, can't access any key:</source>
          <target state="translated">사용자를 재설정 한 후 방금 생성되었을 때의 상태로 돌아갑니다. 비활성 (규칙 해제), 명령을 실행할 수 없음, 키에 액세스 할 수 없음 :</target>
        </trans-unit>
        <trans-unit id="10dc2d316de1e1727affb701a924e28e6d1b2437" translate="yes" xml:space="preserve">
          <source>After running the above script, the result is that only keys A and C will be created on replicas and AOF.</source>
          <target state="translated">위의 스크립트를 실행하면 복제본 및 AOF에 키 A와 C 만 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="a9cef2c443353094dddf50e5f724e3879e4f3f90" translate="yes" xml:space="preserve">
          <source>All Redis commands must be analyzed before execution to determine which keys the command will operate on. In order for this to be true for &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;, keys must be passed explicitly. This is useful in many ways, but especially to make sure Redis Cluster can forward your request to the appropriate cluster node.</source>
          <target state="translated">명령을 실행할 키를 결정하려면 실행 전에 모든 Redis 명령을 분석해야합니다. &lt;a href=&quot;eval&quot;&gt;EVAL에&lt;/a&gt; 대해 이것이 참이 되려면 키를 명시 적으로 전달해야합니다. 이는 여러 가지면에서 유용하지만 특히 Redis 클러스터가 요청을 적절한 클러스터 노드로 전달할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="835b666dd0cc3c5f8fd53a30a792d6ad8b5f1dff" translate="yes" xml:space="preserve">
          <source>All the RESP2 old conversions still apply unless specified above.</source>
          <target state="translated">위에 지정하지 않는 한 모든 RESP2 이전 변환은 계속 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0d589c0f60d25b33b78193aa17f49c88dffd73e4" translate="yes" xml:space="preserve">
          <source>All the RESP2 old conversions still apply.</source>
          <target state="translated">모든 RESP2 이전 변환은 계속 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="05778e5c96e8e267630af37ad51cc812ea0ac83f" translate="yes" xml:space="preserve">
          <source>All the additional arguments should not represent key names and can be accessed by Lua using the &lt;code&gt;ARGV&lt;/code&gt; global variable, very similarly to what happens with keys (so &lt;code&gt;ARGV[1]&lt;/code&gt;, &lt;code&gt;ARGV[2]&lt;/code&gt;, ...).</source>
          <target state="translated">모든 추가 인수는 키 이름을 &lt;code&gt;ARGV&lt;/code&gt; 는 안되며 ARGV 전역 변수를 사용하여 Lua 가 키에서 발생하는 것과 매우 유사하게 액세스 할 수 있습니다 (따라서 &lt;code&gt;ARGV[1]&lt;/code&gt; , &lt;code&gt;ARGV[2]&lt;/code&gt; , ...).</target>
        </trans-unit>
        <trans-unit id="b7c6bcbd8231e947ac1e852709cd03e1c6629d93" translate="yes" xml:space="preserve">
          <source>All the assigned / open slots are reset, so the slots-to-nodes mapping is totally cleared.</source>
          <target state="translated">할당 된 / 열린 슬롯이 모두 재설정되므로 슬롯-노드 매핑이 완전히 지워집니다.</target>
        </trans-unit>
        <trans-unit id="6ccf3242033b3edb2e3d3c30395b126ac379491e" translate="yes" xml:space="preserve">
          <source>All the configuration parameters set using &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; are immediately loaded by Redis and will take effect starting with the next command executed.</source>
          <target state="translated">&lt;a href=&quot;config-set&quot;&gt;CONFIG SET을&lt;/a&gt; 사용하여 설정 한 모든 구성 매개 변수 는 Redis에 의해 즉시로드되며 다음에 실행 된 명령부터 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b280d4fef57685ade0a8c1183128b72be0fff2a4" translate="yes" xml:space="preserve">
          <source>All the other nodes in the cluster are forgotten.</source>
          <target state="translated">클러스터의 다른 모든 노드는 잊어 버렸습니다.</target>
        </trans-unit>
        <trans-unit id="1ec77394fcab0f40f98a08ccf1bd1a099ab3feef" translate="yes" xml:space="preserve">
          <source>All the specially encoded types are automatically converted to the general type once you perform an operation that makes it impossible for Redis to retain the space saving encoding.</source>
          <target state="translated">Redis가 공간 절약형 인코딩을 유지할 수없는 작업을 수행하면 특수하게 인코딩 된 모든 유형이 자동으로 일반 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="df39da0c50311c81c2b61ebabbda96914a971969" translate="yes" xml:space="preserve">
          <source>All the supported parameters have the same meaning of the equivalent configuration parameter used in the &lt;a href=&quot;http://github.com/antirez/redis/raw/2.8/redis.conf&quot;&gt;redis.conf&lt;/a&gt; file, with the following important differences:</source>
          <target state="translated">지원되는 모든 매개 변수는 &lt;a href=&quot;http://github.com/antirez/redis/raw/2.8/redis.conf&quot;&gt;redis.conf&lt;/a&gt; 파일에 사용 된 동등한 구성 매개 변수와 동일한 의미를 가지며 다음과 같은 중요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="88c113a9d8aff1bf4ece5a62c19847909b0afbe4" translate="yes" xml:space="preserve">
          <source>All the supported parameters have the same meaning of the equivalent configuration parameter used in the &lt;a href=&quot;http://github.com/redis/redis/raw/2.8/redis.conf&quot;&gt;redis.conf&lt;/a&gt; file, with the following important differences:</source>
          <target state="translated">지원되는 모든 매개 변수는 &lt;a href=&quot;http://github.com/redis/redis/raw/2.8/redis.conf&quot;&gt;redis.conf&lt;/a&gt; 파일 에서 사용되는 동등한 구성 매개 변수와 동일한 의미를 갖지만 다음과 같은 중요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1452ac410057b8e4338bbb1b4de1f53561ba2ea" translate="yes" xml:space="preserve">
          <source>All the supported parameters have the same meaning of the equivalent configuration parameter used in the &lt;a href=&quot;http://github.com/redis/redis/raw/6.0/redis.conf&quot;&gt;redis.conf&lt;/a&gt; file, with the following important differences:</source>
          <target state="translated">지원되는 모든 매개 변수는 &lt;a href=&quot;http://github.com/redis/redis/raw/6.0/redis.conf&quot;&gt;redis.conf&lt;/a&gt; 파일 에서 사용되는 동등한 구성 매개 변수와 동일한 의미를 갖지만 다음과 같은 중요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="07d70aafc96c2b50e35694bacc42e5a300e72264" translate="yes" xml:space="preserve">
          <source>All-time maximum latency for this event.</source>
          <target state="translated">이 이벤트에 대한 사상 최대 지연 시간입니다.</target>
        </trans-unit>
        <trans-unit id="59c4ef360d3e661521770b94f8bee5b5b98d0b61" translate="yes" xml:space="preserve">
          <source>Almost all modifiers can be used together. The following example will return the first 5 elements, lexicographically sorted in descending order:</source>
          <target state="translated">거의 모든 수정자를 함께 사용할 수 있습니다. 다음 예제는 처음 5 개의 요소를 사전 순으로 내림차순으로 정렬하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="91f2b1b9e9bccb6b3010f3f9f6fb64637d594f59" translate="yes" xml:space="preserve">
          <source>Also note that this behavior is specific of &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt;. &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; itself never shows this behavior because the key space is always represented by hash tables.</source>
          <target state="translated">또한이 동작은 &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; , &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; 및 &lt;a href=&quot;zscan&quot;&gt;ZSCAN에만 해당&lt;/a&gt; 됩니다. 키 공간은 항상 해시 테이블로 표시되므로 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 자체는이 동작을 보여주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80f59bf42799c4d062d02c6eed9565bd78400383" translate="yes" xml:space="preserve">
          <source>Also note with &lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt;, the -1 value for &quot;last key position&quot; means the list of keys may have unlimited length.</source>
          <target state="translated">또한 &lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; 에서 &quot;마지막 키 위치&quot;의 -1 값은 키 목록의 길이가 무제한임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5157f46144d13fb21a63005bb60f24f4ce105e11" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;command-getkeys&quot;&gt;COMMAND GETKEYS&lt;/a&gt; for getting your Redis server tell you where keys are in any given command.</source>
          <target state="translated">또한 참조 &lt;a href=&quot;command-getkeys&quot;&gt;COMMAND GETKEYS을&lt;/a&gt; 키는 주어진 명령에 어디 레디 스 서버가 당신에게 얻기를 위해.</target>
        </trans-unit>
        <trans-unit id="04eefa213e7d217c0e7123cc1dc6c27083f06f1b" translate="yes" xml:space="preserve">
          <source>Also there are two important rules to note:</source>
          <target state="translated">또한 두 가지 중요한 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="253a3794bb6046fd04b2899f39397ddc5b7914e5" translate="yes" xml:space="preserve">
          <source>Also, as already mentioned, restarting a Redis instance flushes the script cache, which is not persistent. However from the point of view of the client there are only two ways to make sure a Redis instance was not restarted between two different commands.</source>
          <target state="translated">또한 이미 언급했듯이 Redis 인스턴스를 다시 시작하면 스크립트 캐시가 플러시됩니다. 그러나 클라이언트의 관점에서 Redis 인스턴스가 서로 다른 두 명령 사이에서 다시 시작되지 않도록하는 방법은 두 가지뿐입니다.</target>
        </trans-unit>
        <trans-unit id="421244cf7620490324dcfc2250189d7eb0fa02a2" translate="yes" xml:space="preserve">
          <source>Also, note that once the sequence part of the last ID equals 18446744073709551615, you'll need to increment the timestamp and reset the sequence part to 0. For example, incrementing the ID &lt;code&gt;1526985685298-18446744073709551615&lt;/code&gt; should result in &lt;code&gt;1526985685299-0&lt;/code&gt;.</source>
          <target state="translated">또한 마지막 ID의 시퀀스 부분이 18446744073709551615와 같으면 타임 스탬프를 늘리고 시퀀스 부분을 0으로 재설정해야합니다. 예를 들어 ID &lt;code&gt;1526985685298-18446744073709551615&lt;/code&gt; 를 &lt;code&gt;1526985685299-0&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="ea8c51c6921844728fda67e56ae9ac9b762367f1" translate="yes" xml:space="preserve">
          <source>Alters the last access time of a key(s). A key is ignored if it does not exist.</source>
          <target state="translated">키의 마지막 액세스 시간을 변경합니다. 키가 없으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b199d3c5e6bdd12d3e1986a0a392afea94eaf2b8" translate="yes" xml:space="preserve">
          <source>Always use plain &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; when in the context of a pipeline.</source>
          <target state="translated">파이프 라인과 관련하여 항상 일반 &lt;a href=&quot;eval&quot;&gt;EVAL을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="31201176aa04df37b1e2ed06ec57bbbf2e617274" translate="yes" xml:space="preserve">
          <source>An RDB version is encoded inside the serialized value, so that different Redis versions with incompatible RDB formats will refuse to process the serialized value.</source>
          <target state="translated">RDB 버전은 직렬화 된 값 안에 인코딩되므로 호환되지 않는 RDB 형식을 가진 다른 Redis 버전은 직렬화 된 값 처리를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="1eea03e66681a82857dbef8c5c7533ecccb36fa9" translate="yes" xml:space="preserve">
          <source>An additional client may monitor the &lt;em&gt;processing&lt;/em&gt; list for items that remain there for too much time, and will push those timed out items into the queue again if needed.</source>
          <target state="translated">추가 클라이언트가 &lt;em&gt;처리&lt;/em&gt; 목록에 너무 많은 시간 동안 남아있는 항목을 모니터링하고 필요한 경우 시간 초과 된 항목을 다시 큐로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="07675d1e6396e649280fe8bed0df48043817bbfd" translate="yes" xml:space="preserve">
          <source>An already known node sends a list of nodes in the gossip section that we are not aware of. If the receiving node trusts the sending node as a known node, it will process the gossip section and send an handshake to the nodes that are still not known.</source>
          <target state="translated">이미 알려진 노드는 우리가 모르는 가십 섹션의 노드 목록을 보냅니다. 수신 노드가 송신 노드를 알려진 노드로 신뢰하는 경우 가십 섹션을 처리하고 여전히 알려지지 않은 노드로 핸드 셰이크를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a452bcfbd349eeb9ee037b3cbc2821a66bfa35e2" translate="yes" xml:space="preserve">
          <source>An alternative implementation uses a single counter, but is a bit more complex to get it right without race conditions. We'll examine different variants.</source>
          <target state="translated">대체 구현은 단일 카운터를 사용하지만 경쟁 조건없이 올바르게 처리하려면 약간 더 복잡합니다. 다양한 변형을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="bff9693e7f02bacc6bf60b4b05563fd05ce6a13a" translate="yes" xml:space="preserve">
          <source>An array composed of three elements array representing the connected replicas. Every sub-array contains the replica IP, port, and the last acknowledged replication offset.</source>
          <target state="translated">연결된 복제본을 나타내는 3 개의 요소 배열로 구성된 배열입니다. 모든 하위 배열에는 복제본 IP, 포트 및 마지막으로 확인 된 복제 오프셋이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a4850b5a22272049075215bf5ab0daed4f790d9d" translate="yes" xml:space="preserve">
          <source>An array of master names monitored by this Sentinel instance.</source>
          <target state="translated">이 Sentinel 인스턴스가 모니터링하는 마스터 이름 배열입니다.</target>
        </trans-unit>
        <trans-unit id="eb58ab5ebfb56d5e2bfd8b9296c584c2ccf48594" translate="yes" xml:space="preserve">
          <source>An array of strings.</source>
          <target state="translated">문자열 배열입니다.</target>
        </trans-unit>
        <trans-unit id="fb9ff52a245be210db03256bc0b542759913e5e2" translate="yes" xml:space="preserve">
          <source>An entry is composed of a set of field-value pairs, it is basically a small dictionary. The field-value pairs are stored in the same order they are given by the user, and commands to read the stream such as &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; or &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; are guaranteed to return the fields and values exactly in the same order they were added by &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;.</source>
          <target state="translated">항목은 필드-값 쌍 세트로 구성되며 기본적으로 작은 사전입니다. 필드 값 쌍들은 사용자에 의해 특정되는 것과 동일한 순서로 저장되고, 명령 등의 스트림을 읽어 &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 또는 &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; 들이 추가 된 순서대로 정확히 필드 및 값을 반환 보장 &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75d00cd00e1f2b13a890f0d28b95cf6fbe73de9c" translate="yes" xml:space="preserve">
          <source>An error is returned for out of range indexes.</source>
          <target state="translated">범위를 벗어난 인덱스에 대해서는 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e1e52880ba8cd5516094695a791c7cb25bb9cf75" translate="yes" xml:space="preserve">
          <source>An error is returned if &lt;code&gt;source&lt;/code&gt; or &lt;code&gt;destination&lt;/code&gt; does not hold a set value.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 또는 &lt;code&gt;destination&lt;/code&gt; 이 설정 값을 보유하지 않으면 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="c6dddcbd9570408a2bf9a7b091594de5d13db0b1" translate="yes" xml:space="preserve">
          <source>An error is returned if there is already a background save running or if there is another non-background-save process running, specifically an in-progress AOF rewrite.</source>
          <target state="translated">이미 백그라운드 저장이 실행 중이거나 다른 비 백그라운드 저장 프로세스가 실행 중이면, 특히 진행중인 AOF 재 작성이있는 경우 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f347bee22b5d2cb10d2901659685fcd72a034c77" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;key&lt;/code&gt; exists and does not hold a sorted set.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 있고 정렬 된 세트를 보유하지 않으면 오류가 리턴됩니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
