<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="redis">
    <body>
      <group id="redis">
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="5a4574a1a3d9728a0a89d6b1668d9c8dc4ec0634" translate="yes" xml:space="preserve">
          <source>Notes on published config epochs</source>
          <target state="translated">게시 된 구성 에포크에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="20be3b7a30a9bb9f7caa52a82e339d86765a7b3b" translate="yes" xml:space="preserve">
          <source>Number of commands processed</source>
          <target state="translated">처리 된 명령 수</target>
        </trans-unit>
        <trans-unit id="6567d67fead3b983bf0dd26e46b199bad4736caf" translate="yes" xml:space="preserve">
          <source>Number of connections received</source>
          <target state="translated">수신 된 연결 수</target>
        </trans-unit>
        <trans-unit id="c0e73dd590dc420faea4c4ac9906ba30e0259e37" translate="yes" xml:space="preserve">
          <source>Number of elements returned at every SCAN call</source>
          <target state="translated">모든 SCAN 호출에서 반환되는 요소 수</target>
        </trans-unit>
        <trans-unit id="f4702f3357a94e0b51c79789087a3eb454b1e296" translate="yes" xml:space="preserve">
          <source>Number of expired keys</source>
          <target state="translated">만료 된 키 수</target>
        </trans-unit>
        <trans-unit id="8e0e833a8bbaf63a540fadb74be8461319161578" translate="yes" xml:space="preserve">
          <source>Number of rejected connections</source>
          <target state="translated">거부 된 연결 수</target>
        </trans-unit>
        <trans-unit id="828f2a22520c1086f191a7adfcf910b96f4fe93b" translate="yes" xml:space="preserve">
          <source>OBJECT</source>
          <target state="translated">OBJECT</target>
        </trans-unit>
        <trans-unit id="9d8ec388e13faad9823f64e9acce4e1451d4eabf" translate="yes" xml:space="preserve">
          <source>OBJECT  subcommand [arguments [arguments ...]]   Inspect the internals of Redis objects</source>
          <target state="translated">OBJECT 하위 명령 [arguments [arguments ...]] Redis 객체의 내부 검사</target>
        </trans-unit>
        <trans-unit id="77ba3ba2dc482ece5e336da9db6f45f553748e64" translate="yes" xml:space="preserve">
          <source>Objects can be encoded in different ways:</source>
          <target state="translated">객체는 다른 방식으로 인코딩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="179e9e8b9188e3e0f2e120735c4089249f586f43" translate="yes" xml:space="preserve">
          <source>Obtaining the current length of the slow log</source>
          <target state="translated">느린 로그의 현재 길이 얻기</target>
        </trans-unit>
        <trans-unit id="5f6babf24c9404230c05a01781cf0ff83f2a099c" translate="yes" xml:space="preserve">
          <source>Of course it is also possible to use any other valid ID. If the specified consumer group already exists, the command returns a &lt;code&gt;-BUSYGROUP&lt;/code&gt; error. Otherwise the operation is performed and OK is returned. There are no hard limits to the number of consumer groups you can associate to a given stream.</source>
          <target state="translated">물론 다른 유효한 ID를 사용하는 것도 가능합니다. 지정된 이용자 그룹이 이미 존재하면 명령은 &lt;code&gt;-BUSYGROUP&lt;/code&gt; 오류를 리턴합니다 . 그렇지 않으면 작업이 수행되고 OK가 반환됩니다. 주어진 스트림에 연결할 수있는 소비자 그룹 수에는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="fdc97913b5ee5e2b94550a726affb680e5e4737b" translate="yes" xml:space="preserve">
          <source>Of course the &quot;5&quot; above is an example. Each LOLWUT version takes a different set of arguments in order to change the output. The user is encouraged to play with it to discover how the output changes adding more numerical arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff1bb1ff7a105fafca313a10f02e72dc891fbcf4" translate="yes" xml:space="preserve">
          <source>Of course this is not enough as there are expired keys that will never be accessed again. These keys should be expired anyway, so periodically Redis tests a few keys at random among keys with an expire set. All the keys that are already expired are deleted from the keyspace.</source>
          <target state="translated">물론 이것은 다시 액세스 할 수없는 만료 된 키가 있으므로 충분하지 않습니다. 이 키는 어쨌든 만료되어야하므로 정기적으로 Redis는 만료가 설정된 키 중에서 무작위로 몇 개의 키를 테스트합니다. 이미 만료 된 모든 키가 키 공간에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="e1291438828df902dd44c789d43575a9bce5c968" translate="yes" xml:space="preserve">
          <source>On the other hand, defining commands using a special command or via &lt;code&gt;redis.conf&lt;/code&gt; would be a problem for a few reasons:</source>
          <target state="translated">반면 특수 명령을 사용하거나 &lt;code&gt;redis.conf&lt;/code&gt; 를 통해 명령을 정의하는 것은 몇 가지 이유로 문제가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bcf11babeeb88215faca3f25a089c7e21ce30f5" translate="yes" xml:space="preserve">
          <source>Once a consumer &lt;em&gt;succesfully&lt;/em&gt; processes a message, it should call &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; so that such message does not get processed again, and as a side effect, the PEL entry about this message is also purged, releasing memory from the Redis server.</source>
          <target state="translated">소비자 가 메시지를 &lt;em&gt;성공적으로&lt;/em&gt; 처리하면 &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; 를 호출 하여 해당 메시지가 다시 처리되지 않도록하고 부작용으로이 메시지에 대한 PEL 항목도 제거되어 Redis 서버에서 메모리가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="b17fd51767d49ce5f7f1a0550bff325504d720d8" translate="yes" xml:space="preserve">
          <source>Once a consumer &lt;em&gt;successfully&lt;/em&gt; processes a message, it should call &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; so that such message does not get processed again, and as a side effect, the PEL entry about this message is also purged, releasing memory from the Redis server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="452b455cbf1a2a31d7d4b5005050bf4551fb3def" translate="yes" xml:space="preserve">
          <source>Once a node is turned into the replica of another master node, there is no need to inform the other cluster nodes about the change: heartbeat packets exchanged between nodes will propagate the new configuration automatically.</source>
          <target state="translated">노드가 다른 마스터 노드의 복제본으로 바뀌면 다른 클러스터 노드에 변경 사항을 알리지 않아도됩니다. 노드간에 교환 된 하트 비트 패킷은 새 구성을 자동으로 전파합니다.</target>
        </trans-unit>
        <trans-unit id="24b95a3638ec064976a3c5a5f6794040d2c4ed0b" translate="yes" xml:space="preserve">
          <source>Once new data is present on one of the lists, the client returns with the name of the key unblocking it and the popped value.</source>
          <target state="translated">목록 중 하나에 새 데이터가 있으면 클라이언트는 키를 차단 해제 한 키 이름과 팝된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dd41998567cd1f4f810cbadee2b74617b57a32fa" translate="yes" xml:space="preserve">
          <source>Once the client enters the subscribed state it is not supposed to issue any other commands, except for additional &lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt; and &lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt; commands.</source>
          <target state="translated">클라이언트가 가입 된 상태가되면 추가 &lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt; , &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt; , &lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt; 및 &lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt; 명령을 제외한 다른 명령을 실행하지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="7a78727304122280256c3edfc937460559a439ea" translate="yes" xml:space="preserve">
          <source>Once the client enters the subscribed state it is not supposed to issue any other commands, except for additional &lt;a href=&quot;subscribe&quot;&gt;SUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;unsubscribe&quot;&gt;UNSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;punsubscribe&quot;&gt;PUNSUBSCRIBE&lt;/a&gt;, &lt;a href=&quot;ping&quot;&gt;PING&lt;/a&gt;, &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; and &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4b215656d61ce9a1a4991539bbd4f84ece9f512" translate="yes" xml:space="preserve">
          <source>Once we get some replies, the next call will be something like:</source>
          <target state="translated">답변을 받으면 다음 전화는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9de09a5350a4d4653c094b67b0dba8689a762e24" translate="yes" xml:space="preserve">
          <source>One client connection per line (separated by LF)</source>
          <target state="translated">회선 당 하나의 클라이언트 연결 (LF로 구분)</target>
        </trans-unit>
        <trans-unit id="81d95091e8731132a88b7f9f02a3169be5e6b187" translate="yes" xml:space="preserve">
          <source>One of the guarantees of consumer groups is that a given consumer can only see the history of messages that were delivered to it, so a message has just a single owner. However there is a special feature called &lt;em&gt;message claiming&lt;/em&gt; that allows other consumers to claim messages in case there is a non recoverable failure of some consumer. In order to implement such semantics, consumer groups require explicit acknowledgement of the messages successfully processed by the consumer, via the &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command. This is needed because the stream will track, for each consumer group, who is processing what message.</source>
          <target state="translated">소비자 그룹의 보장 중 하나는 지정된 소비자가 자신에게 배달 된 메시지의 기록 만 볼 수 있으므로 메시지에는 단일 소유자 만 있다는 것입니다. 그러나 일부 소비자가 복구 할 수없는 장애가있는 경우 다른 소비자가 &lt;em&gt;메시지를 청구&lt;/em&gt; 할 수 있도록하는 &lt;em&gt;메시지 청구&lt;/em&gt; 라는 특수 기능 이 있습니다. 이러한 의미를 구현하기 위해 소비자 그룹은 &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; 명령을 통해 소비자가 성공적으로 처리 한 메시지를 명시 적으로 승인해야합니다 . 스트림은 각 메시지 그룹에서 어떤 메시지를 처리 ​​중인지 추적하기 때문에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="19ce1ec3b2311a2d98754806626a6daf14da6b47" translate="yes" xml:space="preserve">
          <source>One of the guarantees of consumer groups is that a given consumer can only see the history of messages that were delivered to it, so a message has just a single owner. However there is a special feature called &lt;em&gt;message claiming&lt;/em&gt; that allows other consumers to claim messages in case there is a non recoverable failure of some consumer. In order to implement such semantics, consumer groups require explicit acknowledgment of the messages successfully processed by the consumer, via the &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command. This is needed because the stream will track, for each consumer group, who is processing what message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf5da9c080bee3a8142586c412aa39971137eee" translate="yes" xml:space="preserve">
          <source>Options</source>
          <target state="translated">Options</target>
        </trans-unit>
        <trans-unit id="daa479a36fbba3ff638d59ae19308e8976bd5ac3" translate="yes" xml:space="preserve">
          <source>Orders of bits</source>
          <target state="translated">비트 순서</target>
        </trans-unit>
        <trans-unit id="dcfd7c36726b3d9723cbd1a8981b89247967a629" translate="yes" xml:space="preserve">
          <source>Other consumers may inspect the list of pending messages, that are stale for quite some time, using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command. In order to continue processing such messages, they use &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; to acquire the ownership of the message and continue.</source>
          <target state="translated">다른 소비자는 &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; 명령을 사용하여 보류 된 메시지 목록을 검사 할 수 있습니다 . 이러한 메시지를 계속 처리하기 위해 &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; 을 사용 하여 메시지의 소유권을 획득하고 계속합니다.</target>
        </trans-unit>
        <trans-unit id="3c2a27c636dc79870e309393531406e960ec4e18" translate="yes" xml:space="preserve">
          <source>Our previous example returns just the sorted IDs. In some cases, it is more useful to get the actual objects instead of their IDs (&lt;code&gt;object_1&lt;/code&gt;, &lt;code&gt;object_2&lt;/code&gt; and &lt;code&gt;object_3&lt;/code&gt;). Retrieving external keys based on the elements in a list, set or sorted set can be done with the following command:</source>
          <target state="translated">이전 예는 정렬 된 ID 만 반환합니다. 경우에 따라 ID 대신 실제 객체 ( &lt;code&gt;object_1&lt;/code&gt; , &lt;code&gt;object_2&lt;/code&gt; 및 &lt;code&gt;object_3&lt;/code&gt; ) 를 얻는 것이 더 유용합니다 . 목록, 세트 또는 정렬 세트의 요소를 기반으로 외부 키 검색은 다음 명령으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9c8427bc7498ec3380d38f116037bdd3bcddf6e" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error. If &lt;code&gt;start&lt;/code&gt; is larger than the end of the list, an empty list is returned. If &lt;code&gt;stop&lt;/code&gt; is larger than the actual end of the list, Redis will treat it like the last element of the list.</source>
          <target state="translated">범위를 벗어난 인덱스는 오류를 생성하지 않습니다. 경우 &lt;code&gt;start&lt;/code&gt; 리스트의 말미보다 큰, 빈 목록이 반환됩니다. 경우 &lt;code&gt;stop&lt;/code&gt; 목록의 실제 끝보다 큰, 레디 스리스트의 마지막 요소처럼 취급합니다.</target>
        </trans-unit>
        <trans-unit id="c0a3cb19e89ec7bd7c87e53355299d0f62cc91cc" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error. If &lt;code&gt;start&lt;/code&gt; is larger than the largest index in the sorted set, or &lt;code&gt;start &amp;gt;
stop&lt;/code&gt;, an empty list is returned. If &lt;code&gt;stop&lt;/code&gt; is larger than the end of the sorted set Redis will treat it like it is the last element of the sorted set.</source>
          <target state="translated">범위를 벗어난 인덱스는 오류를 생성하지 않습니다. 경우 &lt;code&gt;start&lt;/code&gt; 가장 큰 정렬 된 세트의 인덱스, 또는보다 큰 &lt;code&gt;start &amp;gt; stop&lt;/code&gt; , 빈 목록이 반환됩니다. 경우 &lt;code&gt;stop&lt;/code&gt; 정렬 된 세트의 끝보다 큰는 소트 세트의 마지막 요소처럼 레디 스 그것을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="3dc054b880cd4ad0a83857995e10c362ec4b2504" translate="yes" xml:space="preserve">
          <source>Out of range indexes will not produce an error: if &lt;code&gt;start&lt;/code&gt; is larger than the end of the list, or &lt;code&gt;start &amp;gt; end&lt;/code&gt;, the result will be an empty list (which causes &lt;code&gt;key&lt;/code&gt; to be removed). If &lt;code&gt;end&lt;/code&gt; is larger than the end of the list, Redis will treat it like the last element of the list.</source>
          <target state="translated">범위를 벗어난 인덱스는 오류를 생성하지 않습니다. &lt;code&gt;start&lt;/code&gt; 가 목록의 끝보다 크거나 &lt;code&gt;start &amp;gt; end&lt;/code&gt; 인 경우 결과는 빈 목록이되어 &lt;code&gt;key&lt;/code&gt; 가 제거됩니다. 경우 &lt;code&gt;end&lt;/code&gt; 리스트의 말미보다 큰, 레디 스리스트의 마지막 요소처럼 취급합니다.</target>
        </trans-unit>
        <trans-unit id="c4e6b6c77c67abd27de260eb5ce674860a95ad42" translate="yes" xml:space="preserve">
          <source>Out-of-range indexes</source>
          <target state="translated">범위를 벗어난 인덱스</target>
        </trans-unit>
        <trans-unit id="c03f08a8f205e4568e916e3cfaa50c6a48749706" translate="yes" xml:space="preserve">
          <source>Output format</source>
          <target state="translated">출력 형식</target>
        </trans-unit>
        <trans-unit id="275395efd6e79fdbe55cb36a4ebb4892dbdd5c40" translate="yes" xml:space="preserve">
          <source>Output of the command on replicas</source>
          <target state="translated">복제본에 대한 명령 출력</target>
        </trans-unit>
        <trans-unit id="5ea9a43450142f5e1cfd51ca7b6956f8a9dbb82d" translate="yes" xml:space="preserve">
          <source>Overflow control</source>
          <target state="translated">오버 플로우 제어</target>
        </trans-unit>
        <trans-unit id="36fd64a953472994b938bbb13337305e87d9a9eb" translate="yes" xml:space="preserve">
          <source>Overwrites part of the string stored at &lt;em&gt;key&lt;/em&gt;, starting at the specified offset, for the entire length of &lt;em&gt;value&lt;/em&gt;. If the offset is larger than the current length of the string at &lt;em&gt;key&lt;/em&gt;, the string is padded with zero-bytes to make &lt;em&gt;offset&lt;/em&gt; fit. Non-existing keys are considered as empty strings, so this command will make sure it holds a string large enough to be able to set &lt;em&gt;value&lt;/em&gt; at &lt;em&gt;offset&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;value&lt;/em&gt; 의 전체 길이에 대해 지정된 오프셋에서 시작 하여 &lt;em&gt;key에&lt;/em&gt; 저장된 문자열의 일부를 덮어 씁니다 . 오프셋이 &lt;em&gt;key&lt;/em&gt; 에서 문자열의 현재 길이보다 큰 경우 &lt;em&gt;오프셋에&lt;/em&gt; 맞도록 문자열에 0 바이트가 채워집니다 . 존재하지 않는 키는 빈 문자열로 간주되므로이 명령은 &lt;em&gt;오프셋&lt;/em&gt; 에서 &lt;em&gt;값&lt;/em&gt; 을 설정할 수있을 정도로 큰 문자열을 보유하도록합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34512fba1d256a361565532a3535096429399084" translate="yes" xml:space="preserve">
          <source>PERSIST</source>
          <target state="translated">PERSIST</target>
        </trans-unit>
        <trans-unit id="ae51373f050f6d2b0e0edfdd08e69fc1968bdf20" translate="yes" xml:space="preserve">
          <source>PERSIST  key   Remove the expiration from a key</source>
          <target state="translated">PERSIST 키 키에서 만료를 제거합니다</target>
        </trans-unit>
        <trans-unit id="7fa59fa06dcb2c9dc1b2b2bd46df7f33912c57b3" translate="yes" xml:space="preserve">
          <source>PEXPIRE</source>
          <target state="translated">PEXPIRE</target>
        </trans-unit>
        <trans-unit id="77a946764b4ffdf95c5ae217ca7f9cec5340bdc1" translate="yes" xml:space="preserve">
          <source>PEXPIRE  key milliseconds   Set a key's time to live in milliseconds</source>
          <target state="translated">PEXPIRE 키 밀리 초 키 시간을 밀리 초 단위로 설정</target>
        </trans-unit>
        <trans-unit id="e609e3af460df9737d7d964f8bfec75a3773bde7" translate="yes" xml:space="preserve">
          <source>PEXPIREAT</source>
          <target state="translated">PEXPIREAT</target>
        </trans-unit>
        <trans-unit id="12d0e8f2d7d7718d124f2a5d583dfa8315ee3c0c" translate="yes" xml:space="preserve">
          <source>PEXPIREAT  key milliseconds-timestamp   Set the expiration for a key as a UNIX timestamp specified in milliseconds</source>
          <target state="translated">PEXPIREAT 키 밀리 초 타임 스탬프 키 만료를 밀리 초 단위로 지정된 UNIX 타임 스탬프로 설정</target>
        </trans-unit>
        <trans-unit id="fc7a17907dc63d1312607f17460e9eb6e7871f9d" translate="yes" xml:space="preserve">
          <source>PFADD</source>
          <target state="translated">PFADD</target>
        </trans-unit>
        <trans-unit id="e4e9e83ebacf78fb8cf3124d42502528b53d06ca" translate="yes" xml:space="preserve">
          <source>PFADD  key element [element ...]   Adds the specified elements to the specified HyperLogLog.</source>
          <target state="translated">PFADD 키 요소 [element ...] 지정된 요소를 지정된 HyperLogLog에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="274e92a9d4138573a0f107d2e57b9d0b46e7ac01" translate="yes" xml:space="preserve">
          <source>PFCOUNT</source>
          <target state="translated">PFCOUNT</target>
        </trans-unit>
        <trans-unit id="f81913b01d976cbaac4ade6c06f6bf299ee86214" translate="yes" xml:space="preserve">
          <source>PFCOUNT  key [key ...]   Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).</source>
          <target state="translated">PFCOUNT 키 [키 ...] 키에서 HyperLogLog가 관찰 한 세트의 대략적인 카디널리티를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="62f6ef6fa6924abe295c8c766f2b3e89d6d074fc" translate="yes" xml:space="preserve">
          <source>PFMERGE</source>
          <target state="translated">PFMERGE</target>
        </trans-unit>
        <trans-unit id="2ad005659587e94338ccd67e31dbc3fac2cb1536" translate="yes" xml:space="preserve">
          <source>PFMERGE  destkey sourcekey [sourcekey ...]   Merge N different HyperLogLogs into a single one.</source>
          <target state="translated">PFMERGE destkey sourcekey [sourcekey ...] N 개의 서로 다른 HyperLogLog를 하나로 통합합니다.</target>
        </trans-unit>
        <trans-unit id="0b1786a083a9087f0db36b08c1ff81a58930fbc2" translate="yes" xml:space="preserve">
          <source>PING</source>
          <target state="translated">PING</target>
        </trans-unit>
        <trans-unit id="45dae0d4784e1c9ea33d8d88f448f7989ea29500" translate="yes" xml:space="preserve">
          <source>PING  [message]   Ping the server</source>
          <target state="translated">PING [메시지] 서버 Ping</target>
        </trans-unit>
        <trans-unit id="81efb783fc237efd685a1393fa9f947dd8abda5a" translate="yes" xml:space="preserve">
          <source>PSETEX</source>
          <target state="translated">PSETEX</target>
        </trans-unit>
        <trans-unit id="d7c40d1ee18ffeabe6099f89603c950454eb0276" translate="yes" xml:space="preserve">
          <source>PSETEX  key milliseconds value   Set the value and expiration in milliseconds of a key</source>
          <target state="translated">PSETEX 키 밀리 초 값 키의 값과 만료 시간을 밀리 초 단위로 설정합니다</target>
        </trans-unit>
        <trans-unit id="9e7e79c8d02bde08c4e705066bd533ffa7218538" translate="yes" xml:space="preserve">
          <source>PSUBSCRIBE</source>
          <target state="translated">PSUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="71ae64e5df443252e78a1d1f929289a8311a1ef4" translate="yes" xml:space="preserve">
          <source>PSUBSCRIBE  pattern [pattern ...]   Listen for messages published to channels matching the given patterns</source>
          <target state="translated">PSUBSCRIBE pattern [pattern ...] 주어진 패턴과 일치하는 채널에 발행 된 메시지를 청취</target>
        </trans-unit>
        <trans-unit id="2c633ee880363a76906d0e48643fc6fd3afe6539" translate="yes" xml:space="preserve">
          <source>PSYNC</source>
          <target state="translated">PSYNC</target>
        </trans-unit>
        <trans-unit id="5d448b1760960854b1253a3a2cad23abdcfdac61" translate="yes" xml:space="preserve">
          <source>PSYNC  replicationid offset   Internal command used for replication</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b8bdca458042e425d2902f59f800419aed5c8b1" translate="yes" xml:space="preserve">
          <source>PTTL</source>
          <target state="translated">PTTL</target>
        </trans-unit>
        <trans-unit id="05bf8ee07e7053cfaf8f62c038f0255fadf89afe" translate="yes" xml:space="preserve">
          <source>PTTL  key   Get the time to live for a key in milliseconds</source>
          <target state="translated">PTTL 키 밀리 초 단위로 키의 수명을 확보하십시오</target>
        </trans-unit>
        <trans-unit id="ff0fc30c743813f924dff4b751315af42d5ab08b" translate="yes" xml:space="preserve">
          <source>PUBLISH</source>
          <target state="translated">PUBLISH</target>
        </trans-unit>
        <trans-unit id="46e845a027f7bb36580703fc200d9108559fa747" translate="yes" xml:space="preserve">
          <source>PUBLISH  channel message   Post a message to a channel</source>
          <target state="translated">PUBLISH 채널 메시지 채널에 메시지 게시</target>
        </trans-unit>
        <trans-unit id="9487f50e961af3141e0c7833372d9b2c28cfa2a4" translate="yes" xml:space="preserve">
          <source>PUBSUB</source>
          <target state="translated">PUBSUB</target>
        </trans-unit>
        <trans-unit id="acad4a3c05b50f5f04a99427d2a3cdbb983fb0b9" translate="yes" xml:space="preserve">
          <source>PUBSUB  subcommand [argument [argument ...]]   Inspect the state of the Pub/Sub subsystem</source>
          <target state="translated">PUBSUB 부속 명령 [argument [argument ...]] Pub / Sub 서브 시스템의 상태 점검</target>
        </trans-unit>
        <trans-unit id="ca024e3f958c6b7f4c7fa3671697866707cfa352" translate="yes" xml:space="preserve">
          <source>PUBSUB CHANNELS [pattern]</source>
          <target state="translated">PUBSUB 채널 [패턴]</target>
        </trans-unit>
        <trans-unit id="56e20f63e75d465369356d3ab7aa54f42d22cbb4" translate="yes" xml:space="preserve">
          <source>PUNSUBSCRIBE</source>
          <target state="translated">PUNSUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="e54d89cca768ad85f7527ac0169fa1af2910b1cf" translate="yes" xml:space="preserve">
          <source>PUNSUBSCRIBE  [pattern [pattern ...]]   Stop listening for messages posted to channels matching the given patterns</source>
          <target state="translated">PUNSUBSCRIBE [pattern [pattern ...]] 주어진 패턴과 일치하는 채널에 게시 된 메시지 청취를 중지합니다</target>
        </trans-unit>
        <trans-unit id="df3251b7546bede28dd0b0e82a26302f58157038" translate="yes" xml:space="preserve">
          <source>Passing keys and arguments as additional &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; arguments is also very useful in this context as the script string remains constant and can be efficiently cached by Redis.</source>
          <target state="translated">스크립트 문자열이 일정하게 유지되고 Redis가 효율적으로 캐시 할 수 있으므로 키와 인수를 추가 &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 인수로 전달하는 것도이 컨텍스트에서 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="19999dd613b36fb0786e599a84893b1e8a156a95" translate="yes" xml:space="preserve">
          <source>Pattern: Circular list</source>
          <target state="translated">패턴 : 원형 목록</target>
        </trans-unit>
        <trans-unit id="4d81f3aa2a2c95fc4a2b98f51dce59a3bb00d586" translate="yes" xml:space="preserve">
          <source>Pattern: Counter</source>
          <target state="translated">패턴 : 카운터</target>
        </trans-unit>
        <trans-unit id="73ea3bc6eae64663018b769f7c415b912584ee38" translate="yes" xml:space="preserve">
          <source>Pattern: Event notification</source>
          <target state="translated">패턴 : 이벤트 알림</target>
        </trans-unit>
        <trans-unit id="9ff13cc43cfbf608a403dd95aced2e1c0f9fa96b" translate="yes" xml:space="preserve">
          <source>Pattern: Navigation session</source>
          <target state="translated">패턴 : 탐색 세션</target>
        </trans-unit>
        <trans-unit id="a7fd682d147cfd39262ca78719007b5177407a15" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter</source>
          <target state="translated">패턴 : 속도 제한 기</target>
        </trans-unit>
        <trans-unit id="527a190ff3f82d3d4bdfebea8586b0d301a67e3d" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter 1</source>
          <target state="translated">패턴 : 속도 제한 기 1</target>
        </trans-unit>
        <trans-unit id="d037a3f2c416c91b7789e304c06bd5786301383d" translate="yes" xml:space="preserve">
          <source>Pattern: Rate limiter 2</source>
          <target state="translated">패턴 : 속도 제한 기 2</target>
        </trans-unit>
        <trans-unit id="18e48daae4954154a5de8c81ecf51283e080aacd" translate="yes" xml:space="preserve">
          <source>Pattern: Reliable queue</source>
          <target state="translated">패턴 : 안정적인 대기열</target>
        </trans-unit>
        <trans-unit id="bc4ebd36f01622a36d608ba3197fe5c6b53d07d7" translate="yes" xml:space="preserve">
          <source>Pattern: Time series</source>
          <target state="translated">패턴 : 시계열</target>
        </trans-unit>
        <trans-unit id="aaa32185c003a60c49d4fa1de6cdca30261f99bd" translate="yes" xml:space="preserve">
          <source>Pattern: accessing the entire bitmap</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6aa9774204b5b0358a99c12a75b97dace59e135d" translate="yes" xml:space="preserve">
          <source>Pattern: real time metrics using bitmaps</source>
          <target state="translated">패턴 : 비트 맵을 사용한 실시간 메트릭</target>
        </trans-unit>
        <trans-unit id="387aa2d6e23537ab60fac1801379d3a3550c02d6" translate="yes" xml:space="preserve">
          <source>Pattern: real-time metrics using bitmaps</source>
          <target state="translated">패턴 : 비트 맵을 사용한 실시간 메트릭</target>
        </trans-unit>
        <trans-unit id="4fd48af62eda73b71f46321f27a6f38fb4751056" translate="yes" xml:space="preserve">
          <source>Pattern: setting multiple bits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8f113cb1df36820baa76cc50b4089ad6af9aea4" translate="yes" xml:space="preserve">
          <source>Pattern: weighted random selection of an element</source>
          <target state="translated">패턴 : 요소의 가중치 무작위 선택</target>
        </trans-unit>
        <trans-unit id="4d34f7a2b0b3b6df62a051917d7e7ac2de8a38df" translate="yes" xml:space="preserve">
          <source>Patterns</source>
          <target state="translated">Patterns</target>
        </trans-unit>
        <trans-unit id="65bb2cda328eeb96caf6c6dce99ad10ccece742e" translate="yes" xml:space="preserve">
          <source>Pause the clients using &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE를&lt;/a&gt; 사용하여 클라이언트 일시 중지</target>
        </trans-unit>
        <trans-unit id="172162ae29287e5e829be8811d680119905ff86b" translate="yes" xml:space="preserve">
          <source>Perform a bitwise operation between multiple keys (containing string values) and store the result in the destination key.</source>
          <target state="translated">여러 키 (문자열 값 포함)간에 비트 단위 연산을 수행하고 결과를 대상 키에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="1627d1d0d50fdeb9a3dce196f5de79d8f43842c0" translate="yes" xml:space="preserve">
          <source>Perform a blocking SAVE if at least one &lt;strong&gt;save point&lt;/strong&gt; is configured.</source>
          <target state="translated">하나 이상의 &lt;strong&gt;저장 점이&lt;/strong&gt; 구성된 경우 차단 저장을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="c05e233359dba5b59b70fc0039c9fb4fdb4976d0" translate="yes" xml:space="preserve">
          <source>Perform a partial resynchronization after a disconnection.</source>
          <target state="translated">연결 해제 후 부분 재 동기화를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9d05c962f81bccc17939e7dff46bacb302dd37a2" translate="yes" xml:space="preserve">
          <source>Perform the SHA1 of the input string.</source>
          <target state="translated">입력 문자열의 SHA1을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="0cb883fc85b1fd84aaebb7319c682c586a065641" translate="yes" xml:space="preserve">
          <source>Performance considerations</source>
          <target state="translated">성능 고려 사항</target>
        </trans-unit>
        <trans-unit id="c5453c00c8e4c4429dffd7c57ff9e409df17e57a" translate="yes" xml:space="preserve">
          <source>Performances</source>
          <target state="translated">Performances</target>
        </trans-unit>
        <trans-unit id="98a191010a72a819b496571f1515f19fc5db230c" translate="yes" xml:space="preserve">
          <source>Please check the example below and the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; documentation for more information about the command and its options.</source>
          <target state="translated">명령 및 옵션에 대한 자세한 내용은 아래 예와 &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; 설명서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2adb7fe266cd87cc96a429b9dce43b2d62d33470" translate="yes" xml:space="preserve">
          <source>Please for the specific semantics of the command refer to the documentation of &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;.</source>
          <target state="translated">명령의 특정 의미에 대해서는 &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d37ebc2f4f2d1c9e1508f49167dd6105a3aa57b4" translate="yes" xml:space="preserve">
          <source>Please note depending on the version of Redis some of the fields have been added or removed. A robust client application should therefore parse the result of this command by skipping unknown properties, and gracefully handle missing fields.</source>
          <target state="translated">Redis 버전에 따라 일부 필드가 추가 또는 제거되었습니다. 따라서 강력한 클라이언트 응용 프로그램은 알 수없는 속성을 건너 뛰어이 명령의 결과를 구문 분석하고 누락 된 필드를 정상적으로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf36c5202e34a4a67ab38d9f9bd7222bda763dfd" translate="yes" xml:space="preserve">
          <source>Please note that before reading this page, if you are new to streams, we recommend to read &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;our introduction to Redis Streams&lt;/a&gt;.</source>
          <target state="translated">이 페이지를 읽기 전에 스트림을 &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;처음 사용하는 경우 Redis Streams 소개를&lt;/a&gt; 읽는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="95e0253f33057b2f70a061e11de2d3d4a685d9c7" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; documentation for detailed information about Redis Lua scripting.</source>
          <target state="translated">를 참조하십시오 &lt;a href=&quot;eval&quot;&gt;EVAL의&lt;/a&gt; 레디 스 루아 스크립트에 대한 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="67fc81a1bc0292fa12fdf63856d1ae3a69b0523a" translate="yes" xml:space="preserve">
          <source>Please refer to the &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;persistence documentation&lt;/a&gt; for detailed information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;지속성 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="13eff9f035082f1c14cd73067127e19e708dd746" translate="yes" xml:space="preserve">
          <source>Please see the pattern description in the &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a135ffdb71c43178f876e40f960bf45f1a29237" translate="yes" xml:space="preserve">
          <source>Please see the pattern description in the &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; 설명서 의 패턴 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aed6d393dd61d1ba31957e351636ff901b0e6fa8" translate="yes" xml:space="preserve">
          <source>Posts a message to the given channel.</source>
          <target state="translated">주어진 채널에 메시지를 게시합니다.</target>
        </trans-unit>
        <trans-unit id="f815dfb4f6f438e54dc2f0a16193e4c96d3c1109" translate="yes" xml:space="preserve">
          <source>Practically speaking, for the client it is much better to simply assume that in the context of a given connection, cached scripts are guaranteed to be there unless an administrator explicitly called the &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; command.</source>
          <target state="translated">실제로, 클라이언트의 경우 관리자가 명시 적으로 &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; 명령을 호출하지 않는 한 주어진 연결의 컨텍스트에서 캐시 된 스크립트가 존재한다고 가정하는 것이 훨씬 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="9d8c495de1a9098dd3bc4b934ccc859d56035029" translate="yes" xml:space="preserve">
          <source>Produces an ASCII-art style graph for the specified event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d21fc376a96084ebb73d4e8b35c0a4c4be845e0" translate="yes" xml:space="preserve">
          <source>Provide information on the role of a Redis instance in the context of replication, by returning if the instance is currently a &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;slave&lt;/code&gt;, or &lt;code&gt;sentinel&lt;/code&gt;. The command also returns additional information about the state of the replication (if the role is master or slave) or the list of monitored master names (if the role is sentinel).</source>
          <target state="translated">인스턴스가 현재 &lt;code&gt;master&lt;/code&gt; , &lt;code&gt;slave&lt;/code&gt; 또는 &lt;code&gt;sentinel&lt;/code&gt; 인지 반환하여 복제 컨텍스트에서 Redis 인스턴스의 역할에 대한 정보를 제공하십시오 . 이 명령은 또한 복제 상태 (역할이 마스터 또는 슬레이브 인 경우) 또는 모니터링 된 마스터 이름 목록 (역할이 전송 된 경우)에 대한 추가 정보를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7ca91750d60fd45e80636934b3d1f1da26ffd9f9" translate="yes" xml:space="preserve">
          <source>Pub/Sub</source>
          <target state="translated">Pub/Sub</target>
        </trans-unit>
        <trans-unit id="5860c8458788e44e7636fa364548e067049a0d7b" translate="yes" xml:space="preserve">
          <source>QUIT</source>
          <target state="translated">QUIT</target>
        </trans-unit>
        <trans-unit id="7471799996c7de46c4ffa444365596fb514b6f5a" translate="yes" xml:space="preserve">
          <source>QUIT   Close the connection</source>
          <target state="translated">종료 연결을 닫습니다</target>
        </trans-unit>
        <trans-unit id="baa5d3184c0cc0ce5e007af06198524a4d26548f" translate="yes" xml:space="preserve">
          <source>Quit the server.</source>
          <target state="translated">서버를 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="94386a96dc3f69665a14e74fb2942d92163c5d74" translate="yes" xml:space="preserve">
          <source>RANDOMKEY</source>
          <target state="translated">RANDOMKEY</target>
        </trans-unit>
        <trans-unit id="338552ba06825ef4f555f3d5ff79d40557c925de" translate="yes" xml:space="preserve">
          <source>RANDOMKEY   Return a random key from the keyspace</source>
          <target state="translated">RANDOMKEY 키 공간에서 임의의 키를 반환</target>
        </trans-unit>
        <trans-unit id="90a97e888676c2d0f3b14c8b4a5ca16d360880bc" translate="yes" xml:space="preserve">
          <source>READONLY</source>
          <target state="translated">READONLY</target>
        </trans-unit>
        <trans-unit id="21d1a8e094bd428debefea84e6dd96322d4c6011" translate="yes" xml:space="preserve">
          <source>READONLY   Enables read queries for a connection to a cluster replica node</source>
          <target state="translated">READONLY 클러스터 복제본 노드에 연결하기위한 읽기 쿼리를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="5305e8529d963d471cecc6faf967cedff2ea7494" translate="yes" xml:space="preserve">
          <source>READWRITE</source>
          <target state="translated">READWRITE</target>
        </trans-unit>
        <trans-unit id="2ae19352a72e6e879b7c82d353a544f20f6b355b" translate="yes" xml:space="preserve">
          <source>READWRITE   Disables read queries for a connection to a cluster replica node</source>
          <target state="translated">READWRITE 클러스터 복제본 노드 연결에 대한 읽기 쿼리를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="4756081595ff9366e8b59c094aebf3df53a8fc98" translate="yes" xml:space="preserve">
          <source>RENAME</source>
          <target state="translated">RENAME</target>
        </trans-unit>
        <trans-unit id="434016433de8ed51fc6a3df25c58d49e8397ca2e" translate="yes" xml:space="preserve">
          <source>RENAME  key newkey   Rename a key</source>
          <target state="translated">키 이름 바꾸기 키 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="eb9b6064a90c47e23a80adefc9b43f4215668dbe" translate="yes" xml:space="preserve">
          <source>RENAMENX</source>
          <target state="translated">RENAMENX</target>
        </trans-unit>
        <trans-unit id="e1288934ac4d4000f51ff88bf791420487a34758" translate="yes" xml:space="preserve">
          <source>RENAMENX  key newkey   Rename a key, only if the new key does not exist</source>
          <target state="translated">RENAMENX key newkey 새 키가없는 경우에만 키 이름을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="12c92fcd35c554e1970345d0c852363a2bfff485" translate="yes" xml:space="preserve">
          <source>REPLICAOF</source>
          <target state="translated">REPLICAOF</target>
        </trans-unit>
        <trans-unit id="81253c78d1304948f92fc2d7488335ba2280cd3f" translate="yes" xml:space="preserve">
          <source>REPLICAOF  host port   Make the server a replica of another instance, or promote it as master.</source>
          <target state="translated">REPLICAOF 호스트 포트 서버를 다른 인스턴스의 복제본으로 만들거나 마스터로 승격하십시오.</target>
        </trans-unit>
        <trans-unit id="995f2d9ddfbe7ab63a2a7ddd59856b61ae272710" translate="yes" xml:space="preserve">
          <source>RESET</source>
          <target state="translated">RESET</target>
        </trans-unit>
        <trans-unit id="1b3151a71b95e8cdeb31ff88835e69beefec4ac4" translate="yes" xml:space="preserve">
          <source>RESET   Reset the connection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8135bcdb582d28d5425eef52faf6ac80eefb26" translate="yes" xml:space="preserve">
          <source>RESTORE</source>
          <target state="translated">RESTORE</target>
        </trans-unit>
        <trans-unit id="693be3f2ba1e3d54a77f2bd81f59053740c9352a" translate="yes" xml:space="preserve">
          <source>RESTORE  key ttl serialized-value [REPLACE]   Create a key using the provided serialized value, previously obtained using DUMP.</source>
          <target state="translated">RESTORE key ttl serialized-value [REPLACE] DUMP를 사용하여 이전에 얻은 제공된 직렬화 된 값을 사용하여 키를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e604e0070c2d8dbd159ab393d370ee42dc12812f" translate="yes" xml:space="preserve">
          <source>RESTORE  key ttl serialized-value [REPLACE] [ABSTTL] [IDLETIME seconds] [FREQ frequency]   Create a key using the provided serialized value, previously obtained using DUMP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1631070e7f0b44982ae66b11640654e7ec5dc4bd" translate="yes" xml:space="preserve">
          <source>ROLE</source>
          <target state="translated">ROLE</target>
        </trans-unit>
        <trans-unit id="5b2e8afa66ad35a6843b32ab5ca521321ed80e09" translate="yes" xml:space="preserve">
          <source>ROLE   Return the role of the instance in the context of replication</source>
          <target state="translated">ROLE 복제 컨텍스트에서 인스턴스의 역할을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b7ce3009275f8c79b50c7f42dcb85f259fc1334f" translate="yes" xml:space="preserve">
          <source>RPOP</source>
          <target state="translated">RPOP</target>
        </trans-unit>
        <trans-unit id="daae95751cd7b3b0d6286ba595f17b95a4dbf14d" translate="yes" xml:space="preserve">
          <source>RPOP  key   Remove and get the last element in a list</source>
          <target state="translated">RPOP 키 목록에서 마지막 요소를 제거하고 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="153bcead99c65ede929618b160dd530ec6817223" translate="yes" xml:space="preserve">
          <source>RPOP  key [count]   Remove and get the last elements in a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fc91e22c7eda82f26217a9a276a557189795a83" translate="yes" xml:space="preserve">
          <source>RPOPLPUSH</source>
          <target state="translated">RPOPLPUSH</target>
        </trans-unit>
        <trans-unit id="9b4f14c63b639db09e2a8cbabb9aee76bf074fd7" translate="yes" xml:space="preserve">
          <source>RPOPLPUSH  source destination   Remove the last element in a list, prepend it to another list and return it</source>
          <target state="translated">RPOPLPUSH 소스 대상 목록에서 마지막 요소를 제거하고 다른 목록 앞에 추가 한 후 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="b9d73dc860be3da3eb63b95dc888be66d34c596b" translate="yes" xml:space="preserve">
          <source>RPUSH</source>
          <target state="translated">RPUSH</target>
        </trans-unit>
        <trans-unit id="3c855c64755366500528d84baa161e66c153eb2f" translate="yes" xml:space="preserve">
          <source>RPUSH  key element [element ...]   Append one or multiple elements to a list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc9293df01dd3379605fef72d334681379153757" translate="yes" xml:space="preserve">
          <source>RPUSH  key value [value ...]   Append one or multiple values to a list</source>
          <target state="translated">RPUSH 키 값 [값 ...] 하나 이상의 값을 목록에 추가</target>
        </trans-unit>
        <trans-unit id="a2fe5b491151e540de6422c6e85592df5f204dc3" translate="yes" xml:space="preserve">
          <source>RPUSHX</source>
          <target state="translated">RPUSHX</target>
        </trans-unit>
        <trans-unit id="9ca949029559acfa6521e4bf6649e713de5742b1" translate="yes" xml:space="preserve">
          <source>RPUSHX  key element [element ...]   Append an element to a list, only if the list exists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d6ff5cbc32d5fc0ed38bfb10b34d14916d1c00" translate="yes" xml:space="preserve">
          <source>RPUSHX  key value   Append a value to a list, only if the list exists</source>
          <target state="translated">RPUSHX 키 값 목록이 존재하는 경우에만 목록에 값을 추가</target>
        </trans-unit>
        <trans-unit id="a31a9b75b6318e8c48bf5d454b96698ee608da57" translate="yes" xml:space="preserve">
          <source>Range of integer scores that can be expressed precisely</source>
          <target state="translated">정확하게 표현할 수있는 정수 점수 범위</target>
        </trans-unit>
        <trans-unit id="df8903174eb3eac863f1253076caa8171702cb53" translate="yes" xml:space="preserve">
          <source>Range: 3900-4000</source>
          <target state="translated">사거리 : 3900-4000</target>
        </trans-unit>
        <trans-unit id="e1d33f7270a253d76d9b6fe1deb9155ecce0ca42" translate="yes" xml:space="preserve">
          <source>Read data from one or multiple streams, only returning entries with an ID greater than the last received ID reported by the caller. This command has an option to block if items are not available, in a similar fashion to &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; or &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; and others.</source>
          <target state="translated">하나 이상의 스트림에서 데이터를 읽고 호출자가보고 한 마지막 수신 ID보다 큰 ID를 가진 항목 만 반환합니다. 이 명령에는 &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; 또는 &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; 및 기타와 유사한 방식으로 항목을 사용할 수없는 경우 차단하는 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="58ccdcefd173a8269ea376346a634ff6e968e57b" translate="yes" xml:space="preserve">
          <source>Read only variants</source>
          <target state="translated">변형 만 읽기</target>
        </trans-unit>
        <trans-unit id="b8590ac877c85f2030d4921db5e93ead78595a0f" translate="yes" xml:space="preserve">
          <source>Read queries against a Redis Cluster slave node are disabled by default, but you can use the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command to change this behavior on a per- connection basis. The &lt;a href=&quot;readwrite&quot;&gt;READWRITE&lt;/a&gt; command resets the readonly mode flag of a connection back to readwrite.</source>
          <target state="translated">Redis Cluster 슬레이브 노드에 대한 읽기 쿼리는 기본적으로 비활성화되어 있지만 &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; 명령을 사용하여 연결 별로이 동작을 변경할 수 있습니다 . &lt;a href=&quot;readwrite&quot;&gt;READWRITE&lt;/a&gt; 명령은 READWRITE하는 연결 다시의 읽기 전용 모드 플래그를 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="9ec77fdefc87d676b3e9acb9a7b04ded405da8e4" translate="yes" xml:space="preserve">
          <source>Reading application code, the complete semantics might not be clear since the application calls commands defined server side.</source>
          <target state="translated">응용 프로그램 코드를 읽으면 응용 프로그램에서 정의 된 서버 쪽 명령을 호출하므로 전체 의미가 명확하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="116cec955773e978e0eecf1499a10199d4278c99" translate="yes" xml:space="preserve">
          <source>Reading the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redis Streams introduction&lt;/a&gt; is highly suggested in order to understand more about the streams overall behavior and semantics.</source>
          <target state="translated">스트림 전체 동작 및 의미에 대한 자세한 내용을 이해하기 위해 &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redis 스트림 소개를&lt;/a&gt; 읽는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="88951d0701502f598feecc55f4d3172c32a2db31" translate="yes" xml:space="preserve">
          <source>Reading the slow log</source>
          <target state="translated">느린 로그 읽기</target>
        </trans-unit>
        <trans-unit id="a87de541283ca3bc3c0a398706ee3346da0564e3" translate="yes" xml:space="preserve">
          <source>Recent versions of Redis Sentinel (Redis 2.8.12 or greater) use CLIENT KILL in order to kill clients when an instance is reconfigured, in order to force clients to perform the handshake with one Sentinel again and update its configuration.</source>
          <target state="translated">최신 버전의 Redis Sentinel (Redis 2.8.12 이상)은 CLIENT KILL을 사용하여 인스턴스가 재구성 될 때 클라이언트를 강제 종료하고 클라이언트가 Sentinel로 다시 핸드 셰이크를 수행하고 구성을 업데이트하도록합니다.</target>
        </trans-unit>
        <trans-unit id="68c1dff2ef06724a3eb5f0a503f24117784a62d1" translate="yes" xml:space="preserve">
          <source>Reconfigure clients to connect with the new master.</source>
          <target state="translated">새 마스터와 연결되도록 클라이언트를 재구성하십시오.</target>
        </trans-unit>
        <trans-unit id="24071b57a13027c01339027dcccb98218f052a8f" translate="yes" xml:space="preserve">
          <source>Redis</source>
          <target state="translated">Redis</target>
        </trans-unit>
        <trans-unit id="64fb7fd6108bc6be312c9ee1e4ae786b08c32a13" translate="yes" xml:space="preserve">
          <source>Redis 3.2 introduced an optional &lt;code&gt;count&lt;/code&gt; argument that can be passed to &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt; in order to retrieve multiple elements in a single call.</source>
          <target state="translated">Redis 3.2 는 단일 호출에서 여러 요소를 검색하기 위해 &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt; 에 전달할 수 있는 선택적 &lt;code&gt;count&lt;/code&gt; 인수를 도입했습니다 .</target>
        </trans-unit>
        <trans-unit id="ff9622e92b582b377cd9d107f3253f8a189b7cf9" translate="yes" xml:space="preserve">
          <source>Redis 6 connections starts in RESP2 mode, so clients implementing RESP2 do not need to change (nor there are short term plans to drop support for RESP2). Clients that want to handshake the RESP3 mode need to call the &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command, using &quot;3&quot; as first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09da59c00f13190142c29bd0fc09b7580fb99363" translate="yes" xml:space="preserve">
          <source>Redis Cluster live resharding explained</source>
          <target state="translated">Redis Cluster 라이브 리 샤딩 설명</target>
        </trans-unit>
        <trans-unit id="8be0343488efef207b0826c15486c08f81f5710d" translate="yes" xml:space="preserve">
          <source>Redis HyperLogLogs are represented using a double representation: the &lt;em&gt;sparse&lt;/em&gt; representation suitable for HLLs counting a small number of elements (resulting in a small number of registers set to non-zero value), and a &lt;em&gt;dense&lt;/em&gt; representation suitable for higher cardinalities. Redis automatically switches from the sparse to the dense representation when needed.</source>
          <target state="translated">Redis HyperLogLog는 이중 표현을 사용하여 표현됩니다. 적은 수의 요소를 계산하는 HLL에 적합한 &lt;em&gt;희소&lt;/em&gt; 표현 (0이 아닌 값으로 설정된 작은 수의 레지스터 결과)과 높은 카디널리티에 적합한 &lt;em&gt;조밀 한&lt;/em&gt; 표현입니다. Redis는 필요할 때 스파 스에서 밀도가 높은 표현으로 자동 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="2e645ecd73ea1ffa136575150e55a17bbdaf4a35" translate="yes" xml:space="preserve">
          <source>Redis Nil bulk reply and Nil multi bulk reply -&amp;gt; Lua false boolean type</source>
          <target state="translated">Redis Nil 대량 회신 및 Nil 다중 대량 회신-&amp;gt; Lua false 부울 유형</target>
        </trans-unit>
        <trans-unit id="12deb2b7b17fe48280b9acc8ac6e268a2fccdfc8" translate="yes" xml:space="preserve">
          <source>Redis bulk reply -&amp;gt; Lua string</source>
          <target state="translated">Redis 대량 회신-&amp;gt; 루아 문자열</target>
        </trans-unit>
        <trans-unit id="28c992585f8b92e96ef7862e17fbc69b72429ffe" translate="yes" xml:space="preserve">
          <source>Redis commands that may return elements in random order, like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; (because Redis Sets are &lt;em&gt;unordered&lt;/em&gt;) have a different behavior when called from Lua, and undergo a silent lexicographical sorting filter before returning data to Lua scripts. So &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; will always return the Set elements in the same order, while the same command invoked from normal clients may return different results even if the key contains exactly the same elements.</source>
          <target state="translated">&lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; 와 같이 임의 순서로 요소를 리턴 할 수있는 Redis 명령 ( Radis 세트가 &lt;em&gt;정렬되지&lt;/em&gt; 않았기 때문에 )은 Lua에서 호출 될 때 동작이 다르며 데이터를 Lua 스크립트로 리턴하기 전에 자동 사전 식 정렬 필터를 거칩니다. 따라서 &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; 은 항상 동일한 순서로 Set 요소를 반환하지만, 키가 정확히 같은 요소를 포함하더라도 일반 클라이언트에서 호출 된 동일한 명령은 다른 결과를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9030a22b56473e440d80783adf7755f42e3cd798" translate="yes" xml:space="preserve">
          <source>Redis commands usually accept one key, two keys, or an unlimited number of keys.</source>
          <target state="translated">Redis 명령은 일반적으로 하나의 키, 두 개의 키 또는 무제한의 키를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="4798309557a5e9b4d97ab42c59e238806f00fa04" translate="yes" xml:space="preserve">
          <source>Redis different selectable databases are a form of namespacing: all the databases are anyway persisted together in the same RDB / AOF file. However different databases can have keys having the same name, and there are commands available like &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;, &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; or &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; that work on specific databases.</source>
          <target state="translated">Redis의 선택 가능한 다른 데이터베이스는 네임 스페이스의 한 형태입니다. 모든 데이터베이스는 어쨌든 동일한 RDB / AOF 파일에 함께 유지됩니다. 그러나 다른 데이터베이스에는 동일한 이름의 키가있을 수 있으며 &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; , &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; 또는 &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; 와 같이 특정 데이터베이스에서 작동하는 명령이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e3076b9d3288c97597280422f53f06eb0450c13" translate="yes" xml:space="preserve">
          <source>Redis double reply -&amp;gt; Lua table with a single &lt;code&gt;score&lt;/code&gt; field containing a Lua number representing the double value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a48311c837dbe1e0c3cec8f3114d4df2e8c16385" translate="yes" xml:space="preserve">
          <source>Redis error reply -&amp;gt; Lua table with a single &lt;code&gt;err&lt;/code&gt; field containing the error</source>
          <target state="translated">Redis 오류 응답-&amp;gt; 오류가 포함 된 단일 &lt;code&gt;err&lt;/code&gt; 필드가있는 Lua 테이블</target>
        </trans-unit>
        <trans-unit id="26c2d6e6bcc8ce21554bdf0baf74815e6f8c13dd" translate="yes" xml:space="preserve">
          <source>Redis false reply -&amp;gt; Lua false boolean value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="562ad79eb5fcdcd97d8a0283855bce99c0023855" translate="yes" xml:space="preserve">
          <source>Redis integer reply -&amp;gt; Lua number</source>
          <target state="translated">Redis 정수 응답-&amp;gt; 루아 번호</target>
        </trans-unit>
        <trans-unit id="53c0959152bcf66e99f3ab4d98ebaba488b539de" translate="yes" xml:space="preserve">
          <source>Redis is UTF-8 aware, assuming you correctly set the &lt;code&gt;!LC_COLLATE&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code&gt;!LC_COLLATE&lt;/code&gt; 환경 변수 를 올바르게 설정했다고 가정하면 Redis는 UTF-8을 인식 합니다.</target>
        </trans-unit>
        <trans-unit id="ac11208b3186492fddcf23ffb985bed2f4b921dd" translate="yes" xml:space="preserve">
          <source>Redis is now able to delete keys in the background in a different thread without blocking the server. An &lt;code&gt;ASYNC&lt;/code&gt; option was added to &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; and &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; in order to let the entire dataset or a single database to be freed asynchronously.</source>
          <target state="translated">Redis는 이제 서버를 차단하지 않고 백그라운드에서 다른 스레드의 키를 삭제할 수 있습니다. &lt;code&gt;ASYNC&lt;/code&gt; 의 옵션이 추가되었습니다 &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; 및 &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; 전체 데이터 세트 또는 단일 데이터베이스를 비동기 적으로 해제 할 수 있도록하기 위해.</target>
        </trans-unit>
        <trans-unit id="f26191bd07f5d296d686b49ddf0fea28de008280" translate="yes" xml:space="preserve">
          <source>Redis is often used as a messaging server to implement processing of background jobs or other kinds of messaging tasks. A simple form of queue is often obtained pushing values into a list in the producer side, and waiting for this values in the consumer side using &lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt; (using polling), or &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; if the client is better served by a blocking operation.</source>
          <target state="translated">Redis는 백그라운드 작업 또는 다른 종류의 메시징 작업 처리를 구현하기 위해 메시징 서버로 자주 사용됩니다. 간단한 큐 형식은 종종 값을 생산자 측의 목록으로 푸시하고 &lt;a href=&quot;rpop&quot;&gt;RPOP&lt;/a&gt; (폴링 사용) 또는 클라이언트가 블로킹 조작으로 더 나은 서비스를 제공하는 경우 &lt;a href=&quot;brpop&quot;&gt;BRPOP를&lt;/a&gt; 사용 하여 소비자 측에서이 값을 기다 립니다 .</target>
        </trans-unit>
        <trans-unit id="42a27bac8c1f348420272658d3c655887b07c3ba" translate="yes" xml:space="preserve">
          <source>Redis keys are expired in two ways: a passive way, and an active way.</source>
          <target state="translated">Redis 키는 수동 방식과 능동 방식의 두 가지 방식으로 만료됩니다.</target>
        </trans-unit>
        <trans-unit id="ea38abb16e6fc53c1055d716b8dafffc97128c14" translate="yes" xml:space="preserve">
          <source>Redis logs that a script is running too long.</source>
          <target state="translated">Redis는 스크립트가 너무 오래 실행되고 있음을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="07c6c60386c8d0b1cb8c0291d6e6212cf17c794b" translate="yes" xml:space="preserve">
          <source>Redis map reply -&amp;gt; Lua table with a single &lt;code&gt;map&lt;/code&gt; field containing a Lua table representing the fields and values of the map.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ada15ccb812ae3dfe260cac4cea16ab388a5061" translate="yes" xml:space="preserve">
          <source>Redis multi bulk reply -&amp;gt; Lua table (may have other Redis data types nested)</source>
          <target state="translated">Redis 다중 대량 응답-&amp;gt; Lua 테이블 (다른 Redis 데이터 유형이 중첩 될 수 있음)</target>
        </trans-unit>
        <trans-unit id="6afefff72418c96bb7166299d904551e6e4c186a" translate="yes" xml:space="preserve">
          <source>Redis new RESP3 single null value -&amp;gt; Lua nil.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb910cc16645a1fbd760219098ebcbf7bc9f050c" translate="yes" xml:space="preserve">
          <source>Redis offers a SCRIPT command that can be used in order to control the scripting subsystem. SCRIPT currently accepts three different commands:</source>
          <target state="translated">Redis는 스크립팅 하위 시스템을 제어하는 ​​데 사용할 수있는 SCRIPT 명령을 제공합니다. SCRIPT는 현재 세 가지 명령을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="0ab17f17e02f188a1bdf8cac0d6180f82fee1717" translate="yes" xml:space="preserve">
          <source>Redis return values are converted into Lua data types when Lua calls a Redis command using &lt;code&gt;call()&lt;/code&gt; or &lt;code&gt;pcall()&lt;/code&gt;. Similarly, Lua data types are converted into the Redis protocol when calling a Redis command and when a Lua script returns a value, so that scripts can control what &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; will return to the client.</source>
          <target state="translated">Lua가 &lt;code&gt;call()&lt;/code&gt; 또는 &lt;code&gt;pcall()&lt;/code&gt; 사용하여 Redis 명령을 호출 하면 Redis 반환 값이 Lua 데이터 형식으로 변환됩니다 . 마찬가지로 Lua 데이터 유형은 Redis 명령을 호출 할 때와 Lua 스크립트가 값을 반환 할 때 Redis 프로토콜로 변환되므로 스크립트는 &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 이 클라이언트에 반환 할 항목을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fa967ae24b949a1700795759c8cdfe062988a8a" translate="yes" xml:space="preserve">
          <source>Redis scripts are not allowed to create global variables, in order to avoid leaking data into the Lua state. If a script needs to maintain state between calls (a pretty uncommon need) it should use Redis keys instead.</source>
          <target state="translated">Redis 스크립트는 Lua 상태로 데이터가 유출되는 것을 방지하기 위해 전역 변수를 만들 수 없습니다. 스크립트가 호출 사이에 상태를 유지해야하는 경우 (보통 드문 경우) Redis 키를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="62adbd77b4f8fad448a651b5f523abd0f146da57" translate="yes" xml:space="preserve">
          <source>Redis set reply -&amp;gt; Lua table with a single &lt;code&gt;set&lt;/code&gt; field containing a Lua table representing the elements of the set as fields, having as value just &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e62135b0922f82850c893085d4cd08cc6fd7ccb4" translate="yes" xml:space="preserve">
          <source>Redis slow log overview</source>
          <target state="translated">Redis 느린 로그 개요</target>
        </trans-unit>
        <trans-unit id="add967db3e0dd55b3522bf60d87afa3192a4838a" translate="yes" xml:space="preserve">
          <source>Redis sorted sets use a &lt;em&gt;double 64-bit floating point number&lt;/em&gt; to represent the score. In all the architectures we support, this is represented as an &lt;strong&gt;IEEE 754 floating point number&lt;/strong&gt;, that is able to represent precisely integer numbers between &lt;code&gt;-(2^53)&lt;/code&gt; and &lt;code&gt;+(2^53)&lt;/code&gt; included. In more practical terms, all the integers between -9007199254740992 and 9007199254740992 are perfectly representable. Larger integers, or fractions, are internally represented in exponential form, so it is possible that you get only an approximation of the decimal number, or of the very big integer, that you set as score.</source>
          <target state="translated">Redis 정렬 세트 는 점수를 나타 내기 위해 &lt;em&gt;이중 64 비트 부동 소수점 숫자&lt;/em&gt; 를 사용합니다. 우리가 지원하는 모든 아키텍처에서, 이것은 &lt;strong&gt;IEEE 754 부동 소수점 숫자&lt;/strong&gt; 로 표시되며, 포함 된 &lt;code&gt;-(2^53)&lt;/code&gt; 과 &lt;code&gt;+(2^53)&lt;/code&gt; 사이의 정수를 정확하게 나타낼 수 있습니다. 보다 실용적인 용어로, -9007199254740992와 9007199254740992 사이의 모든 정수는 완벽하게 표현할 수 있습니다. 더 큰 정수 또는 분수는 내부적으로 지수 형식으로 표시되므로 점수로 설정 한 10 진수 또는 매우 큰 정수의 근사값 만 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="738a4a620b4c28b97c15ca1b2edd5526cb23af29" translate="yes" xml:space="preserve">
          <source>Redis status reply -&amp;gt; Lua table with a single &lt;code&gt;ok&lt;/code&gt; field containing the status</source>
          <target state="translated">Redis 상태 응답-&amp;gt; 상태를 포함 하는 단일 &lt;code&gt;ok&lt;/code&gt; 필드가있는 Lua 테이블</target>
        </trans-unit>
        <trans-unit id="db935d0902ab47146d7cddc707ae23f8dbd30e13" translate="yes" xml:space="preserve">
          <source>Redis stores integers in their integer representation, so for string values that actually hold an integer, there is no overhead for storing the string representation of the integer.</source>
          <target state="translated">Redis는 정수를 정수 표현으로 저장하므로 실제로 정수를 보유하는 문자열 값의 경우 정수의 문자열 표현을 저장하기위한 오버 헤드가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b6955638f080137455ca2315a3e774bacb29e670" translate="yes" xml:space="preserve">
          <source>Redis streams are represented in a way that makes them memory efficient: a radix tree is used in order to index macro-nodes that pack linearly tens of stream entries. Normally what happens when you delete an entry from a stream is that the entry is not &lt;em&gt;really&lt;/em&gt; evicted, it just gets marked as deleted.</source>
          <target state="translated">Redis 스트림은 메모리를 효율적으로 만드는 방식으로 표시됩니다. 기수 트리는 수십 개의 스트림 항목을 선형으로 묶는 매크로 노드를 인덱싱하는 데 사용됩니다. 일반적으로 스트림에서 항목을 삭제하면 &lt;em&gt;실제로&lt;/em&gt; 항목이 제거되지 않고 삭제 된 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5d32a14fd1723b346b2a3b7e8ab15af43e61bb43" translate="yes" xml:space="preserve">
          <source>Redis true reply -&amp;gt; Lua true boolean value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa7af6984c788798f4aee1b72f3fb15136c972f4" translate="yes" xml:space="preserve">
          <source>Redis uses the same Lua interpreter to run all the commands. Also Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed. This semantic is similar to the one of &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;. From the point of view of all the other clients the effects of a script are either still not visible or already completed.</source>
          <target state="translated">Redis는 동일한 Lua 인터프리터를 사용하여 모든 명령을 실행합니다. 또한 Redis는 스크립트가 원자적인 방식으로 실행되도록 보장합니다. 스크립트가 실행되는 동안 다른 스크립트 나 Redis 명령은 실행되지 않습니다. 이 의미는 &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; 와 비슷합니다 . 다른 모든 클라이언트의 관점에서 스크립트의 효과는 여전히 보이지 않거나 이미 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="358fd429e373e6f088abb4b934d2faf8511ecbc9" translate="yes" xml:space="preserve">
          <source>Redis versions prior of Redis 6 were only able to understand the one argument version of the command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="315e6feef25876fa664b37d723e94c657b1c8f6a" translate="yes" xml:space="preserve">
          <source>Redis will block the script with an error if a script calls a Redis command able to alter the data set &lt;strong&gt;after&lt;/strong&gt; a Redis &lt;em&gt;random&lt;/em&gt; command like &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;, &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;, &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt;. This means that if a script is read-only and does not modify the data set it is free to call those commands. Note that a &lt;em&gt;random command&lt;/em&gt; does not necessarily mean a command that uses random numbers: any non-deterministic command is considered a random command (the best example in this regard is the &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; command).</source>
          <target state="translated">스크립트가 &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; , &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt; , &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; 과 같은 Redis &lt;em&gt;임의&lt;/em&gt; 명령 &lt;strong&gt;후&lt;/strong&gt; 데이터 세트를 변경할 수있는 Redis 명령을 호출하면 Redis는 오류로 스크립트를 차단합니다 . 즉, 스크립트가 읽기 전용이고 데이터 세트를 수정하지 않으면 해당 명령을 자유롭게 호출 할 수 있습니다. &amp;bull; 그래도 참고 &lt;em&gt;임의의 명령을&lt;/em&gt; 반드시 임의의 숫자를 사용하는 명령을 의미하지 않는다 : 비 결정적 명령은 임의의 명령 간주된다 (이 점에서 가장 좋은 예는 것입니다 &lt;a href=&quot;time&quot;&gt;시간의&lt;/a&gt; 명령).&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1d65bbb9c212a9d98ffb329def918b64ef3d8889" translate="yes" xml:space="preserve">
          <source>Refreshing expires</source>
          <target state="translated">새로 고침 만료</target>
        </trans-unit>
        <trans-unit id="26ca731c99535195e55e64ad25c62f00fdbd2a4c" translate="yes" xml:space="preserve">
          <source>Reliable queues</source>
          <target state="translated">안정적인 대기열</target>
        </trans-unit>
        <trans-unit id="ea59d67e277c60b336a409408ff4d775b8225584" translate="yes" xml:space="preserve">
          <source>Remove a specific consumer from a consumer group.</source>
          <target state="translated">소비자 그룹에서 특정 소비자를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="ce4d2a865a5a06124187f3a0d8a5354cd701d61f" translate="yes" xml:space="preserve">
          <source>Remove the existing timeout on &lt;code&gt;key&lt;/code&gt;, turning the key from &lt;em&gt;volatile&lt;/em&gt; (a key with an expire set) to &lt;em&gt;persistent&lt;/em&gt; (a key that will never expire as no timeout is associated).</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에서 기존 시간 초과를 제거하고 키를 &lt;em&gt;소멸성&lt;/em&gt; (만료 세트가 있는 키 )에서 &lt;em&gt;영구&lt;/em&gt; (시간 초과가 연결되지 않아 만료되지 않는 키)로 전환하십시오.</target>
        </trans-unit>
        <trans-unit id="c1d260f4e3da83fa28a692c23e66ed0cb15dd796" translate="yes" xml:space="preserve">
          <source>Remove the specified members from the set stored at &lt;code&gt;key&lt;/code&gt;. Specified members that are not a member of this set are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, it is treated as an empty set and this command returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 세트에서 지정된 멤버를 제거하십시오 . 이 세트의 멤버가 아닌 지정된 멤버는 무시됩니다. 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 그것은 빈 세트로 취급하고이 명령을 반환 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de0b8cb5dfcd4da1251a55ebacec477902ab7fa1" translate="yes" xml:space="preserve">
          <source>Removes all elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (inclusive).</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 저장된 정렬 된 세트의 모든 요소를 &lt;code&gt;min&lt;/code&gt; 와 &lt;code&gt;max&lt;/code&gt; (포함) 사이의 점수로 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="cbb3fc019bde7aa5a4f4696386c7635ab2172c17" translate="yes" xml:space="preserve">
          <source>Removes all elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt; with rank between &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. Both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are &lt;code&gt;0&lt;/code&gt; -based indexes with &lt;code&gt;0&lt;/code&gt; being the element with the lowest score. These indexes can be negative numbers, where they indicate offsets starting at the element with the highest score. For example: &lt;code&gt;-1&lt;/code&gt; is the element with the highest score, &lt;code&gt;-2&lt;/code&gt; the element with the second highest score and so forth.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 와 &lt;code&gt;stop&lt;/code&gt; 사이의 순위를 가진 &lt;code&gt;key&lt;/code&gt; 저장된 정렬 된 세트의 모든 요소를 ​​제거합니다 . 모두 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 되어 &lt;code&gt;0&lt;/code&gt; 과 기반 인덱스 &lt;code&gt;0&lt;/code&gt; 은 가장 낮은 점수를 가진 요소 인. 이 색인은 음수가 될 수 있으며, 여기서 가장 높은 점수를 가진 요소에서 시작하는 오프셋을 나타냅니다. 예를 들어, &lt;code&gt;-1&lt;/code&gt; 은 가장 높은 점수를 받은 요소 이고, &lt;code&gt;-2&lt;/code&gt; 는 두 번째로 높은 점수를 가진 요소 등입니다.</target>
        </trans-unit>
        <trans-unit id="da37c36034834387a9dd7fbda191a975ebb105b0" translate="yes" xml:space="preserve">
          <source>Removes and returns one or more random elements from the set value store at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 의 설정 값 저장소에서 하나 이상의 임의 요소를 제거하고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="cbdedbfa9e258d96431019af8d58bcfa65137941" translate="yes" xml:space="preserve">
          <source>Removes and returns one or more random members from the set value store at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="870ac46dca2c1a6689064e1cced801af5e158f69" translate="yes" xml:space="preserve">
          <source>Removes and returns the first element of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 목록의 첫 번째 요소를 제거하고 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="abb0c00334891c9a62b73bcc7669016da3f5a06d" translate="yes" xml:space="preserve">
          <source>Removes and returns the first elements of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec2ce52901cbc45793a1c6bb41b722b9057d2bc4" translate="yes" xml:space="preserve">
          <source>Removes and returns the last element of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 목록의 마지막 요소를 제거하고 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="068c1fcc92f924f323a2866cd513ee38912fea94" translate="yes" xml:space="preserve">
          <source>Removes and returns the last elements of the list stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52acb45013cdb2a41dc580913c01c50bd6ebca86" translate="yes" xml:space="preserve">
          <source>Removes and returns up to &lt;code&gt;count&lt;/code&gt; members with the highest scores in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 정렬 된 세트에서 가장 높은 점수를 가진 멤버 를 &lt;code&gt;count&lt;/code&gt; 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="ac48e8c652eae033a19d95a11cb8d9dbd5e35dab" translate="yes" xml:space="preserve">
          <source>Removes and returns up to &lt;code&gt;count&lt;/code&gt; members with the lowest scores in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 정렬 된 집합에서 가장 낮은 점수를 가진 멤버 를 &lt;code&gt;count&lt;/code&gt; 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="f36f141768a197b4276a61d3b54c8f396195cafb" translate="yes" xml:space="preserve">
          <source>Removes the first &lt;code&gt;count&lt;/code&gt; occurrences of elements equal to &lt;code&gt;element&lt;/code&gt; from the list stored at &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;count&lt;/code&gt; argument influences the operation in the following ways:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6ffaff6ffe08c9f43baab9718f030d2162d111" translate="yes" xml:space="preserve">
          <source>Removes the first &lt;code&gt;count&lt;/code&gt; occurrences of elements equal to &lt;code&gt;value&lt;/code&gt; from the list stored at &lt;code&gt;key&lt;/code&gt;. The &lt;code&gt;count&lt;/code&gt; argument influences the operation in the following ways:</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 목록에서 &lt;code&gt;value&lt;/code&gt; 와 동일한 요소 의 첫 번째 발생 &lt;code&gt;count&lt;/code&gt; 제거합니다 . &lt;code&gt;count&lt;/code&gt; 인수는 다음과 같은 방법으로 작업에 영향을 미친다 :</target>
        </trans-unit>
        <trans-unit id="494ca7e2faa6bd5b36a369eb7746bb78fb3e96bc" translate="yes" xml:space="preserve">
          <source>Removes the specified entries from a stream, and returns the number of entries deleted, that may be different from the number of IDs passed to the command in case certain IDs do not exist.</source>
          <target state="translated">스트림에서 지정된 항목을 제거하고 삭제 된 항목 수를 리턴합니다. 이는 특정 ID가 존재하지 않는 경우 명령에 전달 된 ID 수와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="594397839f7156989bc1b259c19072c5484f7bdc" translate="yes" xml:space="preserve">
          <source>Removes the specified fields from the hash stored at &lt;code&gt;key&lt;/code&gt;. Specified fields that do not exist within this hash are ignored. If &lt;code&gt;key&lt;/code&gt; does not exist, it is treated as an empty hash and this command returns &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시에서 지정된 필드를 제거합니다 . 이 해시 내에 존재하지 않는 지정된 필드는 무시됩니다. 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 그것은 하늘의 해시로 취급하고이 명령을 반환 &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="322e3109be94b3ac9ea4c2a44f232f96c6cd905a" translate="yes" xml:space="preserve">
          <source>Removes the specified keys. A key is ignored if it does not exist.</source>
          <target state="translated">지정된 키를 제거합니다. 키가 없으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="933e4f3eff042f249c190608a122f8e43bd494af" translate="yes" xml:space="preserve">
          <source>Removes the specified members from the sorted set stored at &lt;code&gt;key&lt;/code&gt;. Non existing members are ignored.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 정렬 된 세트에서 지정된 멤버를 제거합니다 . 기존 멤버가 아닌 멤버는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="17baa9fe7f8ed0143fa7df75975e104465db4e59" translate="yes" xml:space="preserve">
          <source>Renames &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;newkey&lt;/code&gt; if &lt;code&gt;newkey&lt;/code&gt; does not yet exist. It returns an error when &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">&lt;code&gt;newkey&lt;/code&gt; 가 아직 없으면 &lt;code&gt;key&lt;/code&gt; 를 &lt;code&gt;newkey&lt;/code&gt; 로 이름을 바꿉니다 . &lt;code&gt;key&lt;/code&gt; 가 없으면 오류를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0155259665636f6ceaaa0a0ebda67bb195d98a6d" translate="yes" xml:space="preserve">
          <source>Renames &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;newkey&lt;/code&gt;. It returns an error when &lt;code&gt;key&lt;/code&gt; does not exist. If &lt;code&gt;newkey&lt;/code&gt; already exists it is overwritten, when this happens &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; executes an implicit &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; operation, so if the deleted key contains a very big value it may cause high latency even if &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; itself is usually a constant-time operation.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 이름 을 &lt;code&gt;newkey&lt;/code&gt; 로 바꿉니다 . &lt;code&gt;key&lt;/code&gt; 가 없으면 오류를 반환 합니다. 경우 &lt;code&gt;newkey&lt;/code&gt; 는 이미 이러한 상황이 발생하는 경우는, 덮어 쓰기 &lt;a href=&quot;rename&quot;&gt;RENAME이&lt;/a&gt; 암시 실행 &lt;a href=&quot;del&quot;&gt;DEL의&lt;/a&gt; 삭제 된 키는 대기 시간이 긴 경우에도 발생할 수 있습니다 매우 큰 값이 포함되어 있으므로 경우, 작업을 &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; 자체가 일반적으로 일정 시간 작업입니다.</target>
        </trans-unit>
        <trans-unit id="351fb2e9d60cd91bf6510354de71fa6c06419ab4" translate="yes" xml:space="preserve">
          <source>Replicas broadcast their master's config epochs (in order to get an &lt;code&gt;UPDATE&lt;/code&gt; message if they are found to be stale), so the real config epoch of the replica (which is meaningless more or less, since they don't serve hash slots) can be only obtained checking the node flagged as &lt;code&gt;myself&lt;/code&gt;, which is the entry of the node we are asking to generate &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output. The other replicas epochs reflect what they publish in heartbeat packets, which is, the configuration epoch of the masters they are currently replicating.</source>
          <target state="translated">복제본은 마스터의 구성 에포크를 브로드 캐스트하여 ( 부실한 것으로 확인 된 경우 &lt;code&gt;UPDATE&lt;/code&gt; 메시지 를 받기 위해 ) 복제본의 실제 구성 에포크 (해시 슬롯을 제공하지 않기 때문에 의미가 없습니다) &lt;code&gt;myself&lt;/code&gt; 플래그가 지정된 노드 만 검사하여 &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; 출력 을 생성하도록 요청한 노드의 항목입니다 . 다른 복제본 에포크는 하트 비트 패킷으로 게시 된 내용, 즉 현재 복제중인 마스터의 구성 에포크를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="57ee014fca43ed90896705e17d43f35b06757596" translate="yes" xml:space="preserve">
          <source>Replicating commands instead of scripts</source>
          <target state="translated">스크립트 대신 명령 복제</target>
        </trans-unit>
        <trans-unit id="054fb8240ac6c1ab20550a9e5b79d9d4cd6d1345" translate="yes" xml:space="preserve">
          <source>Request for authentication in a password-protected Redis server. Redis can be instructed to require a password before allowing clients to execute commands. This is done using the &lt;code&gt;requirepass&lt;/code&gt; directive in the configuration file.</source>
          <target state="translated">비밀번호로 보호 된 Redis 서버에서 인증을 요청합니다. 클라이언트가 명령을 실행하기 전에 Redis에 암호를 요구하도록 지시 할 수 있습니다. 이것은 구성 파일에서 &lt;code&gt;requirepass&lt;/code&gt; 지시문을 사용하여 수행 됩니다.</target>
        </trans-unit>
        <trans-unit id="da1bb4a2fc17746f7a5baea5144086fae0563a1a" translate="yes" xml:space="preserve">
          <source>Reset a Redis Cluster node, in a more or less drastic way depending on the reset type, that can be &lt;strong&gt;hard&lt;/strong&gt; or &lt;strong&gt;soft&lt;/strong&gt;. Note that this command &lt;strong&gt;does not work for masters if they hold one or more keys&lt;/strong&gt;, in that case to completely reset a master node keys must be removed first, e.g. by using &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; first, and then &lt;a href=&quot;cluster-reset&quot;&gt;CLUSTER RESET&lt;/a&gt;.</source>
          <target state="translated">재설정 유형에 따라 Redis Cluster 노드를 다소 과감하게 재설정하십시오 . &lt;strong&gt;단단&lt;/strong&gt; 하거나 &lt;strong&gt;부드럽습니다&lt;/strong&gt; . &lt;strong&gt;마스터가 하나 이상의 키를 보유한&lt;/strong&gt; 경우이 명령 &lt;strong&gt;은 마스터에 대해 작동하지 않습니다&lt;/strong&gt; .이 경우 마스터 노드 키를 완전히 재설정하려면 먼저 &lt;a href=&quot;flushall&quot;&gt;FLUSHALL을&lt;/a&gt; 먼저 사용한 다음 &lt;a href=&quot;cluster-reset&quot;&gt;CLUSTER RESET&lt;/a&gt; 을 사용하여 마스터 노드 키를 먼저 제거해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5b45f167ccc9268d6db2b2030f5f33cd642304b9" translate="yes" xml:space="preserve">
          <source>Resets the statistics reported by Redis using the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 명령을 사용하여 Redis가보고 한 통계를 재설정합니다 .</target>
        </trans-unit>
        <trans-unit id="8b4926f937540a054f457674fa7da321fbd6a1f7" translate="yes" xml:space="preserve">
          <source>Resetting the slow log.</source>
          <target state="translated">느린 로그를 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="401feffc58d082a7dc99bf3cdbc90af756748e94" translate="yes" xml:space="preserve">
          <source>Reshard all the hash slots from D to nodes A, B, C.</source>
          <target state="translated">D에서 노드 A, B, C로 모든 해시 슬롯을 리 샤딩하십시오.</target>
        </trans-unit>
        <trans-unit id="d71f5749e9e28d5922b96f1c26e811052165fc71" translate="yes" xml:space="preserve">
          <source>Retrieving external keys</source>
          <target state="translated">외부 키 검색</target>
        </trans-unit>
        <trans-unit id="6fc93fde5d23bf392c79a9f984537ca96d065420" translate="yes" xml:space="preserve">
          <source>Return a random key from the currently selected database.</source>
          <target state="translated">현재 선택된 데이터베이스에서 임의의 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6fd47a35bf916d5d67439ea375fe4e2fb769d84c" translate="yes" xml:space="preserve">
          <source>Return the UNIX TIME of the last DB save executed with success. A client may check if a &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; command succeeded reading the &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; value, then issuing a &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; command and checking at regular intervals every N seconds if &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; changed.</source>
          <target state="translated">성공적으로 실행 된 마지막 DB 저장의 UNIX 시간을 반환합니다. 클라이언트는 &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; 명령이 &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; 값을 읽는 데 성공 했는지 확인한 다음 &lt;a href=&quot;bgsave&quot;&gt;BGSAVE&lt;/a&gt; 명령 을 발행하고 &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE가&lt;/a&gt; 변경된 경우 N 초마다 정기적으로 점검 합니다.</target>
        </trans-unit>
        <trans-unit id="7298f92c54146228ead6d1a31b40025056a03b02" translate="yes" xml:space="preserve">
          <source>Return the distance between two members in the geospatial index represented by the sorted set.</source>
          <target state="translated">정렬 된 세트로 표시되는 지리 공간 인덱스에서 두 멤버 사이의 거리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="da507356e98e4d51d3b0a5e69a99468bdb6da16d" translate="yes" xml:space="preserve">
          <source>Return the members of a sorted set populated with geospatial information using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;, which are within the borders of the area specified by a given shape. This command extends the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; command, so in addition to searching within circular areas, it supports searching within rectangular areas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb126873153beb4e986e8428f3f0a902f06d1bc" translate="yes" xml:space="preserve">
          <source>Return the members of a sorted set populated with geospatial information using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;, which are within the borders of the area specified with the center location and the maximum distance from the center (the radius).</source>
          <target state="translated">&lt;a href=&quot;geoadd&quot;&gt;GEOADD를&lt;/a&gt; 사용하여 지리 공간 정보로 채워진 정렬 된 세트의 멤버를 리턴하십시오. 이 위치는 중심 위치와 중심으로부터 최대 거리 (반경)로 지정된 영역의 경계 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7ff116fa994743f4fb0646cce53a6396e097c89" translate="yes" xml:space="preserve">
          <source>Return the number of keys in the currently-selected database.</source>
          <target state="translated">현재 선택된 데이터베이스의 키 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="06398ca22b9ef82a3c94cf8b1160f8f9c766b74a" translate="yes" xml:space="preserve">
          <source>Return the position of the first bit set to 1 or 0 in a string.</source>
          <target state="translated">문자열에서 첫 번째 비트의 위치를 ​​1 또는 0으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1d1482b5db471b056549fa1a5580198ec9701587" translate="yes" xml:space="preserve">
          <source>Return the positions (longitude,latitude) of all the specified members of the geospatial index represented by the sorted set at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;key로&lt;/em&gt; 정렬 된 세트로 표시되는 지리 공간 인덱스의 지정된 모든 멤버의 위치 (경도, 위도)를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="38c82e40bf5034793c00ae747edeb8cd30dfe3ef" translate="yes" xml:space="preserve">
          <source>Return the username the current connection is authenticated with. New connections are authenticated with the &quot;default&quot; user. They can change user using &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0492bdeb7afe890056ed3d150bcd3cc644b0be83" translate="yes" xml:space="preserve">
          <source>Return valid &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt; strings representing the position of one or more elements in a sorted set value representing a geospatial index (where elements were added using &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt;).</source>
          <target state="translated">지리 공간 인덱스 ( &lt;a href=&quot;geoadd&quot;&gt;GEOADD를&lt;/a&gt; 사용하여 요소가 추가 된 위치)를 나타내는 정렬 된 세트 값에서 하나 이상의 요소 위치를 나타내는 유효한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt; 문자열을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="232f3db04c4faa620bfbfc11fd3689a472ef9881" translate="yes" xml:space="preserve">
          <source>Return value</source>
          <target state="translated">반환 값</target>
        </trans-unit>
        <trans-unit id="864674bcd0783b3457690f475310b938e42a7db7" translate="yes" xml:space="preserve">
          <source>Returning a maximum number of entries</source>
          <target state="translated">최대 항목 수 반환</target>
        </trans-unit>
        <trans-unit id="8f278b9f0e4f851622b8ed184503714c9eb2b40b" translate="yes" xml:space="preserve">
          <source>Returning items in a specific time range. This is possible because Stream IDs are &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;related to time&lt;/a&gt;.</source>
          <target state="translated">특정 시간 범위 내 품목 반품 이것은 스트림 ID가 &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;시간과 관련되어&lt;/a&gt; 있기 때문에 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="6fecab38b77030a1f63f2810d6747aa68c069f23" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of details about all Redis commands.</source>
          <target state="translated">모든 Redis 명령에 대한 세부 사항의 &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="fc344310aece8efa4afcb637dd3fdf8dc24fa45b" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of details about multiple Redis commands.</source>
          <target state="translated">여러 Redis 명령에 대한 세부 정보의 &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4a134a2f3cf379373d004a605091cb6cf69dedcb" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; of keys from a full Redis command.</source>
          <target state="translated">전체 Redis 명령에서 키의 &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="bce4982fceed9f9a0c759decc9c92ecb37cc9be2" translate="yes" xml:space="preserve">
          <source>Returns &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt; of number of total commands in this Redis server.</source>
          <target state="translated">이 Redis 서버의 총 명령 수에 &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;대한 정수 응답&lt;/a&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="a915d042e7bc17cfcfeeccbd870dfc5af9c1ca16" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;PONG&lt;/code&gt; if no argument is provided, otherwise return a copy of the argument as a bulk. This command is often used to test if a connection is still alive, or to measure latency.</source>
          <target state="translated">반환 &lt;code&gt;PONG&lt;/code&gt; 에는 인수가 제공되지 않는 경우는 true, 그렇지 않은 경우는 대량으로 인수의 사본을 반환한다. 이 명령은 연결이 아직 활성 상태인지 테스트하거나 대기 시간을 측정하는 데 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dd1b58db010b114867573670782f464e9b034412" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;message&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="a8491e8a1858fe4a13538635b038fd1bb846df79" translate="yes" xml:space="preserve">
          <source>Returns all field names in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시의 모든 필드 이름을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="514836e0465ae87a7f738140eb4e2b3ae4475e1f" translate="yes" xml:space="preserve">
          <source>Returns all fields and values of the hash stored at &lt;code&gt;key&lt;/code&gt;. In the returned value, every field name is followed by its value, so the length of the reply is twice the size of the hash.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시의 모든 필드와 값을 반환합니다 . 리턴 된 값에서 모든 필드 이름 뒤에 값이 오므로 응답 길이는 해시 크기의 두 배입니다.</target>
        </trans-unit>
        <trans-unit id="e9924b464875fe91e2b89cf6f97649ff9ec1b5ce" translate="yes" xml:space="preserve">
          <source>Returns all keys matching &lt;code&gt;pattern&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 과 일치하는 모든 키를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1ceba3296cc87483f6becfe1cdae897e811a1b1e" translate="yes" xml:space="preserve">
          <source>Returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;max&lt;/code&gt; and &lt;code&gt;min&lt;/code&gt; (including elements with score equal to &lt;code&gt;max&lt;/code&gt; or &lt;code&gt;min&lt;/code&gt;). In contrary to the default ordering of sorted sets, for this command the elements are considered to be ordered from high to low scores.</source>
          <target state="translated">&lt;code&gt;max&lt;/code&gt; 에서 &lt;code&gt;min&lt;/code&gt; 사이의 점수를 가진 &lt;code&gt;key&lt;/code&gt; 에서 정렬 된 세트의 모든 요소를 ​​반환합니다 (점수가 &lt;code&gt;max&lt;/code&gt; 또는 &lt;code&gt;min&lt;/code&gt; 인 요소 포함 ). 정렬 된 세트의 기본 순서와 반대로이 명령의 경우 요소가 높은 점수에서 낮은 점수로 정렬 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6def9bec387c3e744963c6ac4b0bf7f4010504e6" translate="yes" xml:space="preserve">
          <source>Returns all the elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; (including elements with score equal to &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt;). The elements are considered to be ordered from low to high scores.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 과 &lt;code&gt;max&lt;/code&gt; 사이의 점수를 가진 &lt;code&gt;key&lt;/code&gt; 에서 정렬 된 세트의 모든 요소를 ​​반환합니다 (점수가 &lt;code&gt;min&lt;/code&gt; 또는 &lt;code&gt;max&lt;/code&gt; 와 같은 요소 포함 ). 요소는 낮은 점수에서 높은 점수로 정렬 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="1925ffaf420a57d589c1888eb5b09007e4f1d203" translate="yes" xml:space="preserve">
          <source>Returns all the members of the set value stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 설정 값의 모든 멤버를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c11f5fe0471c6d472d362d6dbbf041c048b49125" translate="yes" xml:space="preserve">
          <source>Returns all values in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시의 모든 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4792ce321c7a364f3dc2071cf137fcc522daf25d" translate="yes" xml:space="preserve">
          <source>Returns an integer identifying the hash slot the specified key hashes to. This command is mainly useful for debugging and testing, since it exposes via an API the underlying Redis implementation of the hashing algorithm. Example use cases for this command:</source>
          <target state="translated">지정된 키 해시가 해시 슬롯을 식별하는 정수를 반환합니다. 이 명령은 API를 통해 해시 알고리즘의 기본 Redis 구현을 노출하므로 디버깅 및 테스트에 주로 유용합니다. 이 명령의 사용 사례 예 :</target>
        </trans-unit>
        <trans-unit id="899ca03feedce83f7aa728b87a784b60bd95adf0" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;field&lt;/code&gt; is an existing field in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;field&lt;/code&gt; 가 &lt;code&gt;key&lt;/code&gt; 에 저장된 해시의 기존 필드 인지 여부를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5e13b7a867bbaf0e4121d5da403d54edbe4a8b1f" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;key&lt;/code&gt; exists.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 존재 하면 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="163373a24e8be296b7e7c88d0c4da2f59ceca677" translate="yes" xml:space="preserve">
          <source>Returns if &lt;code&gt;member&lt;/code&gt; is a member of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;member&lt;/code&gt; 가 &lt;code&gt;key&lt;/code&gt; 에 저장된 세트의 멤버 인지 여부를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="abd92cbd9d7d0b6e4392a36873fd8c21767b398a" translate="yes" xml:space="preserve">
          <source>Returns information about the existence of the scripts in the script cache.</source>
          <target state="translated">스크립트 캐시에 스크립트가 있는지에 대한 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="820ae40f339c061fc09ac87d928788d5e7ea006a" translate="yes" xml:space="preserve">
          <source>Returns information about the modules loaded to the server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13855077d7cb93a1fce1c3432c59e7e463ea29a6" translate="yes" xml:space="preserve">
          <source>Returns or stores the elements contained in the &lt;a href=&quot;https://redis.io/topics/data-types#lists&quot;&gt;list&lt;/a&gt;, &lt;a href=&quot;https://redis.io/topics/data-types#set&quot;&gt;set&lt;/a&gt; or &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;sorted set&lt;/a&gt; at &lt;code&gt;key&lt;/code&gt;. By default, sorting is numeric and elements are compared by their value interpreted as double precision floating point number. This is &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; in its simplest form:</source>
          <target state="translated">반환 또는 저장 요소가 포함 &lt;a href=&quot;https://redis.io/topics/data-types#lists&quot;&gt;목록&lt;/a&gt; , &lt;a href=&quot;https://redis.io/topics/data-types#set&quot;&gt;세트&lt;/a&gt; 또는 &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;소트 세트&lt;/a&gt; 에서 &lt;code&gt;key&lt;/code&gt; . 기본적으로 정렬은 숫자이고 요소는 배정 밀도 부동 소수점 숫자로 해석 된 값으로 비교됩니다. 이것은 가장 간단한 형태의 &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f68574957008d127438140f50ac56b278260cf09" translate="yes" xml:space="preserve">
          <source>Returns the bit value at &lt;em&gt;offset&lt;/em&gt; in the string value stored at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;key에&lt;/em&gt; 저장된 문자열 값에서 &lt;em&gt;오프셋&lt;/em&gt; 의 비트 값을 반환합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6d63c7c2388918da907438c78c891dff4a16999" translate="yes" xml:space="preserve">
          <source>Returns the element at index &lt;code&gt;index&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt;. The index is zero-based, so &lt;code&gt;0&lt;/code&gt; means the first element, &lt;code&gt;1&lt;/code&gt; the second element and so on. Negative indices can be used to designate elements starting at the tail of the list. Here, &lt;code&gt;-1&lt;/code&gt; means the last element, &lt;code&gt;-2&lt;/code&gt; means the penultimate and so forth.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 목록 에서 인덱스 &lt;code&gt;index&lt;/code&gt; 의 요소를 리턴합니다 . 인덱스는 0부터 시작하므로 &lt;code&gt;0&lt;/code&gt; 은 첫 번째 요소, &lt;code&gt;1&lt;/code&gt; 은 두 번째 요소 등을 의미합니다. 음수 색인을 사용하여 목록의 끝에서 시작하는 요소를 지정할 수 있습니다. 여기서 &lt;code&gt;-1&lt;/code&gt; 은 마지막 요소를, &lt;code&gt;-2&lt;/code&gt; 는 두 번째 등을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="669652a24b746680e968eb8d19e304712aaafbef" translate="yes" xml:space="preserve">
          <source>Returns the length of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is interpreted as an empty list and &lt;code&gt;0&lt;/code&gt; is returned. An error is returned when the value stored at &lt;code&gt;key&lt;/code&gt; is not a list.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 목록의 길이를 반환합니다 . 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 그것은 빈 목록으로 해석되고 &lt;code&gt;0&lt;/code&gt; 이 반환됩니다. &lt;code&gt;key&lt;/code&gt; 저장된 값 이 목록이 아닌 경우 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="b1b9de7b079dd5e1ad7bef3504c123ad01db9ecc" translate="yes" xml:space="preserve">
          <source>Returns the length of the string value stored at &lt;code&gt;key&lt;/code&gt;. An error is returned when &lt;code&gt;key&lt;/code&gt; holds a non-string value.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 문자열 값의 길이를 반환합니다 . &lt;code&gt;key&lt;/code&gt; 가 문자열이 아닌 값을 보유 하면 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="5ca8167d0a845062b5e1c8307dc022d4e1bbe99c" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the difference between the first set and all the successive sets.</source>
          <target state="translated">첫 번째 세트와 모든 후속 세트의 차이로 인해 세트의 멤버를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="65286cf35136f5258861b04a7983164ea5b463a3" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the intersection of all the given sets.</source>
          <target state="translated">주어진 모든 세트의 교집합에서 나온 세트의 멤버를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="473b41ab8be68badcb9ee743f59ebda61ccb6efd" translate="yes" xml:space="preserve">
          <source>Returns the members of the set resulting from the union of all the given sets.</source>
          <target state="translated">주어진 모든 집합의 합집합으로 인해 집합의 멤버를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5f50e5f3ee257d3917e04c66ed0f097e9a6cbcd0" translate="yes" xml:space="preserve">
          <source>Returns the node's id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae58574da7b69acb45d5608e905fbe416f5828a3" translate="yes" xml:space="preserve">
          <source>Returns the number of elements in the sorted set at &lt;code&gt;key&lt;/code&gt; with a score between &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에서 정렬 세트의 요소 수를 &lt;code&gt;min&lt;/code&gt; 과 &lt;code&gt;max&lt;/code&gt; 사이의 점수로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4ba5a6e2cdf681a72b81189fc73dab62a38a2630" translate="yes" xml:space="preserve">
          <source>Returns the number of entries inside a stream. If the specified key does not exist the command returns zero, as if the stream was empty. However note that unlike other Redis types, zero-length streams are possible, so you should call &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; or &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; in order to check if a key exists or not.</source>
          <target state="translated">스트림 내부의 항목 수를 반환합니다. 지정된 키가 없으면 스트림이 비어있는 것처럼 명령이 0을 리턴합니다. 그러나 다른 Redis 유형과 달리 길이가 0 인 스트림이 가능하므로 키가 있는지 여부를 확인하려면 &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; 또는 &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="05ec2c01f1e7966c86d566259fe9827a1ce5788e" translate="yes" xml:space="preserve">
          <source>Returns the number of fields contained in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시에 포함 된 필드 수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cba9b6e741951a2ea3575443214cf403c194bc0f" translate="yes" xml:space="preserve">
          <source>Returns the number of keys in the specified Redis Cluster hash slot. The command only queries the local data set, so contacting a node that is not serving the specified hash slot will always result in a count of zero being returned.</source>
          <target state="translated">지정된 Redis Cluster 해시 슬롯의 키 수를 반환합니다. 이 명령은 로컬 데이터 세트 만 쿼리하므로 지정된 해시 슬롯을 제공하지 않는 노드에 연결하면 항상 카운트 0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="567352a29cfaef33a8cd3fcbcac829c78575fb62" translate="yes" xml:space="preserve">
          <source>Returns the number of subscribers (not counting clients subscribed to patterns) for the specified channels.</source>
          <target state="translated">지정된 채널의 구독자 수 (패턴에 구독 한 클라이언트는 제외)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="56eb7af42eb7b4bb5b7efb363837228225fedb8e" translate="yes" xml:space="preserve">
          <source>Returns the number of subscriptions to patterns (that are performed using the &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt; command). Note that this is not just the count of clients subscribed to patterns but the total number of patterns all the clients are subscribed to.</source>
          <target state="translated">패턴에 대한 구독 수를 리턴합니다 ( &lt;a href=&quot;psubscribe&quot;&gt;PSUBSCRIBE&lt;/a&gt; 명령을 사용하여 수행됨 ). 이는 패턴을 구독 한 클라이언트의 수가 아니라 모든 클라이언트가 구독 한 총 패턴 수입니다.</target>
        </trans-unit>
        <trans-unit id="029e626a83e98d1ddd2b45f2a08391faf674382c" translate="yes" xml:space="preserve">
          <source>Returns the rank of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;, with the scores ordered from high to low. The rank (or index) is 0-based, which means that the member with the highest score has rank &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 저장된 정렬 된 세트에서 &lt;code&gt;member&lt;/code&gt; 의 순위 를 높은 순서에서 낮은 순서로 리턴합니다 . 순위 (또는 인덱스)는 0을 기준으로합니다. 즉, 가장 높은 점수를받은 멤버의 순위는 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="04ac6b8e04ac2d5fa91a42abbe270ab24969dcf8" translate="yes" xml:space="preserve">
          <source>Returns the rank of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;, with the scores ordered from low to high. The rank (or index) is 0-based, which means that the member with the lowest score has rank &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 저장된 정렬 된 세트에서 &lt;code&gt;member&lt;/code&gt; 의 순위 를 낮은 순서에서 높은 순서로 리턴합니다 . 순위 (또는 인덱스)는 0을 기준으로합니다. 즉, 점수가 가장 낮은 멤버의 순위는 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dac65708cc841972517b49f4a323aba557dd7743" translate="yes" xml:space="preserve">
          <source>Returns the remaining time to live of a key that has a timeout. This introspection capability allows a Redis client to check how many seconds a given key will continue to be part of the dataset.</source>
          <target state="translated">시간 초과가있는 키의 남은 시간을 반환합니다. 이 내부 검사 기능을 통해 Redis 클라이언트는 주어진 키가 데이터 세트의 일부로 몇 초 동안 계속 있는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdaf416765952fb3c543f080075ad7115471f130" translate="yes" xml:space="preserve">
          <source>Returns the score of &lt;code&gt;member&lt;/code&gt; in the sorted set at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에서 정렬 된 세트 의 &lt;code&gt;member&lt;/code&gt; 점수를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="4bb764cd364e3749541c7692eea4d198b1e88fce" translate="yes" xml:space="preserve">
          <source>Returns the scores associated with the specified &lt;code&gt;members&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0525192497ba351f01f7c69505a721186043f122" translate="yes" xml:space="preserve">
          <source>Returns the set cardinality (number of elements) of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 세트의 카디널리티 (요소 수)를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="538e8ccb043255bf1866a8c948a35b08642708eb" translate="yes" xml:space="preserve">
          <source>Returns the sorted set cardinality (number of elements) of the sorted set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 정렬 된 세트의 정렬 된 세트 카디널리티 (요소 수)를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="aed5ad61cf2dae51ecb526ffeb96e8ae6f66dd61" translate="yes" xml:space="preserve">
          <source>Returns the specified elements of the list stored at &lt;code&gt;key&lt;/code&gt;. The offsets &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are zero-based indexes, with &lt;code&gt;0&lt;/code&gt; being the first element of the list (the head of the list), &lt;code&gt;1&lt;/code&gt; being the next element and so on.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 목록의 지정된 요소를 반환합니다 . 오프셋 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 는 0 부터 시작 하는 인덱스이며 &lt;code&gt;0&lt;/code&gt; 은 목록의 첫 번째 요소 (목록의 헤드)이고 &lt;code&gt;1&lt;/code&gt; 은 다음 요소 등입니다.</target>
        </trans-unit>
        <trans-unit id="165e254b16f95c82b554bb625de96b2c2d45635e" translate="yes" xml:space="preserve">
          <source>Returns the specified range of elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt;. The elements are considered to be ordered from the highest to the lowest score. Descending lexicographical order is used for elements with equal score.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 정렬 된 세트에서 지정된 요소 범위를 리턴합니다 . 요소는 가장 높은 점수에서 가장 낮은 점수로 정렬 된 것으로 간주됩니다. 내림차순이 내림차순으로 점수가 같은 요소에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c5f3848ec567b8c9da3f19a86ff736fd69145ae8" translate="yes" xml:space="preserve">
          <source>Returns the specified range of elements in the sorted set stored at &lt;code&gt;key&lt;/code&gt;. The elements are considered to be ordered from the lowest to the highest score. Lexicographical order is used for elements with equal score.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 정렬 된 세트에서 지정된 요소 범위를 리턴합니다 . 요소는 가장 낮은 점수에서 가장 높은 점수로 정렬 된 것으로 간주됩니다. 사전 순서는 점수가 같은 요소에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d28b315a7a61b9bf04b21fccdd6ae5bd4f8eb130" translate="yes" xml:space="preserve">
          <source>Returns the string length of the value associated with &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;. If the &lt;code&gt;key&lt;/code&gt; or the &lt;code&gt;field&lt;/code&gt; do not exist, 0 is returned.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시의 &lt;code&gt;field&lt;/code&gt; 와 관련된 값의 문자열 길이를 반환합니다 . 는 IF &lt;code&gt;key&lt;/code&gt; 또는 &lt;code&gt;field&lt;/code&gt; 존재하지 않는, 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ffb4e3b3a6a5708cfdef83bd04363741160ed0a4" translate="yes" xml:space="preserve">
          <source>Returns the string representation of the type of the value stored at &lt;code&gt;key&lt;/code&gt;. The different types that can be returned are: &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;zset&lt;/code&gt; and &lt;code&gt;hash&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 값 유형의 문자열 표현을 리턴합니다 . 리턴 될 수있는 다른 유형은 &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;zset&lt;/code&gt; 및 &lt;code&gt;hash&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c9feb2d475967dd13f03c72121d597fd1520318c" translate="yes" xml:space="preserve">
          <source>Returns the string representation of the type of the value stored at &lt;code&gt;key&lt;/code&gt;. The different types that can be returned are: &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;zset&lt;/code&gt;, &lt;code&gt;hash&lt;/code&gt; and &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a246620818088ec9a16f70b9fb4ae809aad9ad2" translate="yes" xml:space="preserve">
          <source>Returns the substring of the string value stored at &lt;code&gt;key&lt;/code&gt;, determined by the offsets &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; (both are inclusive). Negative offsets can be used in order to provide an offset starting from the end of the string. So -1 means the last character, -2 the penultimate and so forth.</source>
          <target state="translated">오프셋 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 에 따라 &lt;code&gt;key&lt;/code&gt; 에 저장된 문자열 값의 하위 문자열을 반환합니다 (둘 다 포함). 문자열 끝에서 시작하여 오프셋을 제공하기 위해 음수 오프셋을 사용할 수 있습니다. 따라서 -1은 마지막 문자, -2는 두 번째 등을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ff8cb8f9712a465de8610b460278556869c01387" translate="yes" xml:space="preserve">
          <source>Returns the value associated with &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시의 &lt;code&gt;field&lt;/code&gt; 와 관련된 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="6e8fea73a6efe9b1e714890adedb119e477e5b94" translate="yes" xml:space="preserve">
          <source>Returns the values associated with the specified &lt;code&gt;fields&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시에서 지정된 &lt;code&gt;fields&lt;/code&gt; 와 연관된 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="2a3f6c24ab0b5bf50119e41442adccdd069520b2" translate="yes" xml:space="preserve">
          <source>Returns the values of all specified keys. For every key that does not hold a string value or does not exist, the special value &lt;code&gt;nil&lt;/code&gt; is returned. Because of this, the operation never fails.</source>
          <target state="translated">지정된 모든 키의 값을 돌려줍니다. 문자열 값을 보유하지 않거나 존재하지 않는 모든 키에 대해 특수 값 &lt;code&gt;nil&lt;/code&gt; 이 리턴됩니다. 이로 인해 작업이 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b14b8f8217819a1f6163396383d48d4cd2d94d9" translate="yes" xml:space="preserve">
          <source>Returns whether each &lt;code&gt;member&lt;/code&gt; is a member of the set stored at &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33fe03995fd835515d8b0c378391e0d80d6d96a2" translate="yes" xml:space="preserve">
          <source>Running the bitmap incrementally using the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt;&lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; optional parameters, accumulating the results client-side, and optionally caching the result into a key.</source>
          <target state="translated">&lt;a href=&quot;bitcount&quot;&gt;BITCOUNT &lt;/a&gt;&lt;em&gt;시작&lt;/em&gt; 및 &lt;em&gt;종료&lt;/em&gt; 선택적 매개 변수를 사용하여 비트 맵을 증분 실행하고 결과를 클라이언트 측에 누적하고 선택적으로 결과를 키에 캐싱합니다.</target>
        </trans-unit>
        <trans-unit id="afc896d0c818d9d81d1502addeeed94d978515cb" translate="yes" xml:space="preserve">
          <source>SADD</source>
          <target state="translated">SADD</target>
        </trans-unit>
        <trans-unit id="afe4d83e232611365cc3a02706eeee448267b671" translate="yes" xml:space="preserve">
          <source>SADD  key member [member ...]   Add one or more members to a set</source>
          <target state="translated">SADD 키 멤버 [member ...] 하나 이상의 멤버를 세트에 추가</target>
        </trans-unit>
        <trans-unit id="508156a39b09ccfe61cc81d984e9317e5e0d8eec" translate="yes" xml:space="preserve">
          <source>SAVE</source>
          <target state="translated">SAVE</target>
        </trans-unit>
        <trans-unit id="a806788f2be230df4e533ace9d23ff41f5ebd919" translate="yes" xml:space="preserve">
          <source>SAVE   Synchronously save the dataset to disk</source>
          <target state="translated">저장 데이터 세트를 디스크에 동기 저장</target>
        </trans-unit>
        <trans-unit id="65b4fd3a026ef6fa00d5747035f289ef54695f24" translate="yes" xml:space="preserve">
          <source>SAVE and NOSAVE modifiers</source>
          <target state="translated">저장 및 NOSAVE 수정 자</target>
        </trans-unit>
        <trans-unit id="c5a19955ea5dab3fd18ab68f367f98693df1b60b" translate="yes" xml:space="preserve">
          <source>SCAN</source>
          <target state="translated">SCAN</target>
        </trans-unit>
        <trans-unit id="f6a353aff0f0da25a0e7f7c1d96621ee0a75fe99" translate="yes" xml:space="preserve">
          <source>SCAN  cursor [MATCH pattern] [COUNT count]   Incrementally iterate the keys space</source>
          <target state="translated">SCAN 커서 [MATCH 패턴] [COUNT 수] 키 공간을 증분 반복</target>
        </trans-unit>
        <trans-unit id="72556acd6ec7fd4188e74406d411c51d45f1c442" translate="yes" xml:space="preserve">
          <source>SCAN  cursor [MATCH pattern] [COUNT count] [TYPE type]   Incrementally iterate the keys space</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f904e681db7d6de1d40ec70145524cd0367d1bf0" translate="yes" xml:space="preserve">
          <source>SCAN basic usage</source>
          <target state="translated">SCAN 기본 사용법</target>
        </trans-unit>
        <trans-unit id="aa3b23325236e95772d7cd2d8a5db2f2530e669f" translate="yes" xml:space="preserve">
          <source>SCAN is a cursor based iterator. This means that at every call of the command, the server returns an updated cursor that the user needs to use as the cursor argument in the next call.</source>
          <target state="translated">SCAN은 커서 기반 반복자입니다. 이는 명령이 호출 될 때마다 서버가 사용자가 다음 호출에서 커서 인수로 사용해야하는 업데이트 된 커서를 리턴 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0431790b7b638b530f089a6638b4b046bf245d05" translate="yes" xml:space="preserve">
          <source>SCARD</source>
          <target state="translated">SCARD</target>
        </trans-unit>
        <trans-unit id="45b0af77625a8e40fbd9c79a72bf85a01a682a2e" translate="yes" xml:space="preserve">
          <source>SCARD  key   Get the number of members in a set</source>
          <target state="translated">SCARD 키 세트의 멤버 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="46ab5a918078b88865c34d46d45763f78a5cc2a8" translate="yes" xml:space="preserve">
          <source>SCRIPT</source>
          <target state="translated">SCRIPT</target>
        </trans-unit>
        <trans-unit id="942ec0d4567f537a05d81b40e79ed670c8098df1" translate="yes" xml:space="preserve">
          <source>SCRIPT DEBUG  YES|SYNC|NO   Set the debug mode for executed scripts.</source>
          <target state="translated">SCRIPT DEBUG YES | SYNC | NO 실행 된 스크립트의 디버그 모드를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="d4f0300810cbd56a02078e94b26444e04a369df1" translate="yes" xml:space="preserve">
          <source>SCRIPT EXISTS  sha1 [sha1 ...]   Check existence of scripts in the script cache.</source>
          <target state="translated">SCRIPT EXISTS sha1 [sha1 ...] 스크립트 캐시에 스크립트가 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="155351693709972a944322985f623357a60203d8" translate="yes" xml:space="preserve">
          <source>SCRIPT FLUSH</source>
          <target state="translated">스크립트 FLUSH</target>
        </trans-unit>
        <trans-unit id="ff5ac14542c8a5c4ff717c937c92483157332c48" translate="yes" xml:space="preserve">
          <source>SCRIPT FLUSH   Remove all the scripts from the script cache.</source>
          <target state="translated">SCRIPT FLUSH 스크립트 캐시에서 모든 스크립트를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="5e2a68acdd358effce354e479fe828441291386c" translate="yes" xml:space="preserve">
          <source>SCRIPT KILL</source>
          <target state="translated">스크립트 처치</target>
        </trans-unit>
        <trans-unit id="898216faf82d0e8094a40fff1a1d11316572b3a1" translate="yes" xml:space="preserve">
          <source>SCRIPT KILL   Kill the script currently in execution.</source>
          <target state="translated">SCRIPT KILL 현재 실행중인 스크립트를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="bf00a0ed4afe21cec9ac5006aa471a2c75ce80dd" translate="yes" xml:space="preserve">
          <source>SCRIPT LOAD  script   Load the specified Lua script into the script cache.</source>
          <target state="translated">SCRIPT LOAD 스크립트 지정된 Lua 스크립트를 스크립트 캐시에로드합니다.</target>
        </trans-unit>
        <trans-unit id="605e7c9dd422426230eae60c02acc7d7a5705884" translate="yes" xml:space="preserve">
          <source>SDIFF</source>
          <target state="translated">SDIFF</target>
        </trans-unit>
        <trans-unit id="18d8e0e316b86cf9a259f83877f9d4536e919048" translate="yes" xml:space="preserve">
          <source>SDIFF  key [key ...]   Subtract multiple sets</source>
          <target state="translated">SDIFF 키 [키 ...] 여러 세트 빼기</target>
        </trans-unit>
        <trans-unit id="144b2bd3509fd63bb1b369b8c7665713eb587bd9" translate="yes" xml:space="preserve">
          <source>SDIFFSTORE</source>
          <target state="translated">SDIFFSTORE</target>
        </trans-unit>
        <trans-unit id="de1820fefd3db78a9062bc31ca0bace599879b7b" translate="yes" xml:space="preserve">
          <source>SDIFFSTORE  destination key [key ...]   Subtract multiple sets and store the resulting set in a key</source>
          <target state="translated">SDIFFSTORE 대상 키 [키 ...] 여러 세트를 빼고 결과 세트를 키에 저장</target>
        </trans-unit>
        <trans-unit id="a4942c26d0735947d8a22a2fbe2735a12e381808" translate="yes" xml:space="preserve">
          <source>SELECT</source>
          <target state="translated">SELECT</target>
        </trans-unit>
        <trans-unit id="f439068c5eb4482362ce42c7382665b32a13512a" translate="yes" xml:space="preserve">
          <source>SELECT  index   Change the selected database for the current connection</source>
          <target state="translated">SELECT 인덱스 현재 연결에 대해 선택된 데이터베이스를 변경합니다</target>
        </trans-unit>
        <trans-unit id="55c5d81017a30edf1e47ba1b78c377a5e5ebfd50" translate="yes" xml:space="preserve">
          <source>SET</source>
          <target state="translated">SET</target>
        </trans-unit>
        <trans-unit id="b2f1db45c77eaf2c94d566bc200555c564e53670" translate="yes" xml:space="preserve">
          <source>SET  key value [EX seconds|PX milliseconds|KEEPTTL] [NX|XX] [GET]   Set the string value of a key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a720b839d692fc7a7e17565ac1e4963650fe98" translate="yes" xml:space="preserve">
          <source>SET  key value [expiration EX seconds|PX milliseconds] [NX|XX]   Set the string value of a key</source>
          <target state="translated">SET 키 값 [만료 EX 초 | PX 밀리 초] [NX | XX] 키의 문자열 값 설정</target>
        </trans-unit>
        <trans-unit id="7df70cb863a3d3a5e4a199b5d8ef3c9851ce87bf" translate="yes" xml:space="preserve">
          <source>SETBIT</source>
          <target state="translated">SETBIT</target>
        </trans-unit>
        <trans-unit id="b66f69a03f672489d4ae1d69a757435c5b63bd51" translate="yes" xml:space="preserve">
          <source>SETBIT  key offset value   Sets or clears the bit at offset in the string value stored at key</source>
          <target state="translated">SETBIT 키 오프셋 값 키에 저장된 문자열 값에서 오프셋의 비트를 설정하거나 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="c92872db8021ac60dd456ca7447fb52919f32143" translate="yes" xml:space="preserve">
          <source>SETEX</source>
          <target state="translated">SETEX</target>
        </trans-unit>
        <trans-unit id="0b5df1d3ddffe0fdbb568accc5d3c3dac5121afc" translate="yes" xml:space="preserve">
          <source>SETEX  key seconds value   Set the value and expiration of a key</source>
          <target state="translated">SETEX 키 초 값 키의 값과 만료를 설정합니다</target>
        </trans-unit>
        <trans-unit id="1ace6531f1c27b916c1368f17e1a7ae87aa79f97" translate="yes" xml:space="preserve">
          <source>SETNX</source>
          <target state="translated">SETNX</target>
        </trans-unit>
        <trans-unit id="a50f293fa49f962b5d82c0bb86c82df413a498b7" translate="yes" xml:space="preserve">
          <source>SETNX  key value   Set the value of a key, only if the key does not exist</source>
          <target state="translated">SETNX 키 값 키가 존재하지 않는 경우에만 키 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c1d82383232438676e2182b69bf2797640b1fcd2" translate="yes" xml:space="preserve">
          <source>SETRANGE</source>
          <target state="translated">SETRANGE</target>
        </trans-unit>
        <trans-unit id="a2132f99e69e7919051651c2b4fc7de24734eba2" translate="yes" xml:space="preserve">
          <source>SETRANGE  key offset value   Overwrite part of a string at key starting at the specified offset</source>
          <target state="translated">SETRANGE 키 오프셋 값 지정된 오프셋에서 시작하는 키에서 문자열의 일부를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="ec493147ec1b78adab002626ee80cc23772aded8" translate="yes" xml:space="preserve">
          <source>SHUTDOWN</source>
          <target state="translated">SHUTDOWN</target>
        </trans-unit>
        <trans-unit id="606e1ec5d1ea13b283de4e59cd16289518254c6c" translate="yes" xml:space="preserve">
          <source>SHUTDOWN  [NOSAVE|SAVE]   Synchronously save the dataset to disk and then shut down the server</source>
          <target state="translated">SHUTDOWN [NOSAVE | SAVE] 데이터 세트를 디스크에 동기식으로 저장 한 다음 서버를 종료합니다</target>
        </trans-unit>
        <trans-unit id="c340be94a16bd060ccd24ece053ed10ff4cfb1a2" translate="yes" xml:space="preserve">
          <source>SINTER</source>
          <target state="translated">SINTER</target>
        </trans-unit>
        <trans-unit id="acc6f9a5a6867145ccd5835b170277c3127f8f60" translate="yes" xml:space="preserve">
          <source>SINTER  key [key ...]   Intersect multiple sets</source>
          <target state="translated">SINTER 키 [키 ...] 여러 세트와 교차</target>
        </trans-unit>
        <trans-unit id="ae286ac2efddc7ffc6de81fb4eef82083c5d0d0a" translate="yes" xml:space="preserve">
          <source>SINTERSTORE</source>
          <target state="translated">SINTERSTORE</target>
        </trans-unit>
        <trans-unit id="3cc889bdb24445318099b6bfa98a849204bc5321" translate="yes" xml:space="preserve">
          <source>SINTERSTORE  destination key [key ...]   Intersect multiple sets and store the resulting set in a key</source>
          <target state="translated">SINTERSTORE 대상 키 [key ...] 여러 세트를 교차시키고 결과 세트를 키에 저장</target>
        </trans-unit>
        <trans-unit id="8074903f43c428dec41033b139437bb9d7e46e61" translate="yes" xml:space="preserve">
          <source>SISMEMBER</source>
          <target state="translated">SISMEMBER</target>
        </trans-unit>
        <trans-unit id="2613d73d648b1f6845f55faac8664acb5e2e9af6" translate="yes" xml:space="preserve">
          <source>SISMEMBER  key member   Determine if a given value is a member of a set</source>
          <target state="translated">SISMEMBER 키 멤버 주어진 값이 세트의 멤버인지 판별</target>
        </trans-unit>
        <trans-unit id="bb3731aa645af4f77072e934700ff033a81e173b" translate="yes" xml:space="preserve">
          <source>SLAVEOF</source>
          <target state="translated">SLAVEOF</target>
        </trans-unit>
        <trans-unit id="9bb4401fd3b09a14ad63da1fc4e0ebcc9c0ee189" translate="yes" xml:space="preserve">
          <source>SLAVEOF  host port   Make the server a replica of another instance, or promote it as master. Deprecated starting with Redis 5. Use REPLICAOF instead.</source>
          <target state="translated">SLAVEOF 호스트 포트 서버를 다른 인스턴스의 복제본으로 만들거나 마스터로 승격하십시오. Redis 5부터는 더 이상 사용되지 않습니다. 대신 REPLICAOF를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4078b703021998b0c963d9636d85d96b1ddfa618" translate="yes" xml:space="preserve">
          <source>SLOWLOG</source>
          <target state="translated">SLOWLOG</target>
        </trans-unit>
        <trans-unit id="acfcd934ccfd2203f5ccc3e824371c24109642b8" translate="yes" xml:space="preserve">
          <source>SLOWLOG  subcommand [argument]   Manages the Redis slow queries log</source>
          <target state="translated">SLOWLOG 하위 명령 [argument] Redis 느린 쿼리 로그를 관리합니다</target>
        </trans-unit>
        <trans-unit id="e6687e28d8b75312f0ea51bc9520b394ec2a7a63" translate="yes" xml:space="preserve">
          <source>SMEMBERS</source>
          <target state="translated">SMEMBERS</target>
        </trans-unit>
        <trans-unit id="fe66421f332187f83010e275c4b51042858f5234" translate="yes" xml:space="preserve">
          <source>SMEMBERS  key   Get all the members in a set</source>
          <target state="translated">SMEMBERS 키 세트의 모든 멤버 가져 오기</target>
        </trans-unit>
        <trans-unit id="3a5a30822e064f7dd03cefac6d437e4654f3aca9" translate="yes" xml:space="preserve">
          <source>SMISMEMBER</source>
          <target state="translated">SMISMEMBER</target>
        </trans-unit>
        <trans-unit id="aaa0292e655dd3747fc97cd25825a806d4aa708b" translate="yes" xml:space="preserve">
          <source>SMISMEMBER  key member [member ...]   Returns the membership associated with the given elements for a set</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20f84dbd21a3d84899dade0a24ef5c6978f0403e" translate="yes" xml:space="preserve">
          <source>SMOVE</source>
          <target state="translated">SMOVE</target>
        </trans-unit>
        <trans-unit id="1f7888e464279456fc99ea1259b436e9ad0d4f64" translate="yes" xml:space="preserve">
          <source>SMOVE  source destination member   Move a member from one set to another</source>
          <target state="translated">SMOVE 소스 대상 멤버 한 세트에서 다른 세트로 멤버 이동</target>
        </trans-unit>
        <trans-unit id="2434fe1de87e4949f51786cc87dd6a83c095a422" translate="yes" xml:space="preserve">
          <source>SORT</source>
          <target state="translated">SORT</target>
        </trans-unit>
        <trans-unit id="8e248ec645f54a08b3eb01462adb200f94f15d79" translate="yes" xml:space="preserve">
          <source>SORT  key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination]   Sort the elements in a list, set or sorted set</source>
          <target state="translated">SORT 키 [BY 패턴] [LIMIT 오프셋 카운트] [GET 패턴 [GET 패턴 ...]] [ASC | DESC] [ALPHA] [저장 대상] 목록, 세트 또는 정렬 된 세트에서 요소 정렬</target>
        </trans-unit>
        <trans-unit id="757f5e1ed1192585c3e7deb4986d7e204a0c8613" translate="yes" xml:space="preserve">
          <source>SPOP</source>
          <target state="translated">SPOP</target>
        </trans-unit>
        <trans-unit id="a1bcd919a884989656266471e065ce0ed9f3b014" translate="yes" xml:space="preserve">
          <source>SPOP  key [count]   Remove and return one or multiple random members from a set</source>
          <target state="translated">SPOP 키 [count] 세트에서 하나 이상의 무작위 멤버를 제거하고 리턴</target>
        </trans-unit>
        <trans-unit id="fa889adf02f632d165c3f2d12d9b5ec8d781cbb2" translate="yes" xml:space="preserve">
          <source>SRANDMEMBER</source>
          <target state="translated">SRANDMEMBER</target>
        </trans-unit>
        <trans-unit id="a3aa05de6787d8cb6b5fb2eeb41ce24756a254c7" translate="yes" xml:space="preserve">
          <source>SRANDMEMBER  key [count]   Get one or multiple random members from a set</source>
          <target state="translated">SRANDMEMBER 키 [count] 세트에서 하나 이상의 무작위 멤버를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a25d27e5f9def5c1d9e1a790c413156760a00937" translate="yes" xml:space="preserve">
          <source>SREM</source>
          <target state="translated">SREM</target>
        </trans-unit>
        <trans-unit id="68363946a4081440ca501f29c43f5fbe4f7eefc4" translate="yes" xml:space="preserve">
          <source>SREM  key member [member ...]   Remove one or more members from a set</source>
          <target state="translated">SREM 키 멤버 [member ...] 세트에서 하나 이상의 멤버 제거</target>
        </trans-unit>
        <trans-unit id="39f084973b61a7bea28e4e94336a3c5a0bf9fee7" translate="yes" xml:space="preserve">
          <source>SSCAN</source>
          <target state="translated">SSCAN</target>
        </trans-unit>
        <trans-unit id="9c2bba696b7b86cd88c82a287899370d9f0e3bb5" translate="yes" xml:space="preserve">
          <source>SSCAN  key cursor [MATCH pattern] [COUNT count]   Incrementally iterate Set elements</source>
          <target state="translated">SSCAN 키 커서 [MATCH 패턴] [COUNT 수] 증분 반복 설정 요소</target>
        </trans-unit>
        <trans-unit id="746fc78a74ffba46a591afc21fe85ad08b00b6da" translate="yes" xml:space="preserve">
          <source>STRALGO</source>
          <target state="translated">STRALGO</target>
        </trans-unit>
        <trans-unit id="3faaaa804aaa356ec8a33bd42d375f1bc189c7e7" translate="yes" xml:space="preserve">
          <source>STRALGO  LCS algo-specific-argument [algo-specific-argument ...]   Run algorithms (currently LCS) against strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89c4cb21a1d403bb307b502f69a87f9e3b3a8ab" translate="yes" xml:space="preserve">
          <source>STRLEN</source>
          <target state="translated">STRLEN</target>
        </trans-unit>
        <trans-unit id="ba1403b52701f08d29eb084587b5d84ec8dde893" translate="yes" xml:space="preserve">
          <source>STRLEN  key   Get the length of the value stored in a key</source>
          <target state="translated">STRLEN 키 키에 저장된 값의 길이를 가져옵니다</target>
        </trans-unit>
        <trans-unit id="43a6e12318adbbee03f06872c109322b0f558e29" translate="yes" xml:space="preserve">
          <source>SUBSCRIBE</source>
          <target state="translated">SUBSCRIBE</target>
        </trans-unit>
        <trans-unit id="47236795c3b9acd1da0f66ecb88ffdd913189ac5" translate="yes" xml:space="preserve">
          <source>SUBSCRIBE  channel [channel ...]   Listen for messages published to the given channels</source>
          <target state="translated">SUBSCRIBE 채널 [채널 ...] 주어진 채널에 발행 된 메시지를 청취</target>
        </trans-unit>
        <trans-unit id="a9a4bd3707fb7f204fddf46673a38114093dbb82" translate="yes" xml:space="preserve">
          <source>SUNION</source>
          <target state="translated">SUNION</target>
        </trans-unit>
        <trans-unit id="5b757c33f2f9e74b674645b6ccda3d80138ff877" translate="yes" xml:space="preserve">
          <source>SUNION  key [key ...]   Add multiple sets</source>
          <target state="translated">SUNION 키 [키 ...] 여러 세트 추가</target>
        </trans-unit>
        <trans-unit id="48b1035f133322c326cae720a6ee6ad1108226dc" translate="yes" xml:space="preserve">
          <source>SUNIONSTORE</source>
          <target state="translated">SUNIONSTORE</target>
        </trans-unit>
        <trans-unit id="be4a84a92460ba7a99f970a1bd856700c5285869" translate="yes" xml:space="preserve">
          <source>SUNIONSTORE  destination key [key ...]   Add multiple sets and store the resulting set in a key</source>
          <target state="translated">SUNIONSTORE 대상 키 [키 ...] 여러 세트를 추가하고 결과 세트를 키에 저장</target>
        </trans-unit>
        <trans-unit id="52e8b5aa51a1b6c9b46c6f4abe8b613e777665e4" translate="yes" xml:space="preserve">
          <source>SWAPDB</source>
          <target state="translated">SWAPDB</target>
        </trans-unit>
        <trans-unit id="b86537c7b961d4302819caedcc63376c729b2e03" translate="yes" xml:space="preserve">
          <source>SWAPDB  index index   Swaps two Redis databases</source>
          <target state="translated">SWAPDB 인덱스 인덱스 두 Redis 데이터베이스를 교환</target>
        </trans-unit>
        <trans-unit id="77754660ca2a32513ded08ad488bd2a9af650258" translate="yes" xml:space="preserve">
          <source>SWAPDB  index1 index2   Swaps two Redis databases</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f8d236566d2393cd3a112e7190d8837c8004cc2" translate="yes" xml:space="preserve">
          <source>SYNC</source>
          <target state="translated">SYNC</target>
        </trans-unit>
        <trans-unit id="7dade54cfe46a1450fe32e252c2fe2557e402641" translate="yes" xml:space="preserve">
          <source>SYNC   Internal command used for replication</source>
          <target state="translated">복제에 사용되는 SYNC 내부 명령</target>
        </trans-unit>
        <trans-unit id="b54491fb2810da81b1ac818eeb380198be74decd" translate="yes" xml:space="preserve">
          <source>Same result format as &lt;a href=&quot;command&quot;&gt;COMMAND&lt;/a&gt; except you can specify which commands get returned.</source>
          <target state="translated">어떤 명령이 리턴되는지 지정할 수 있다는 점을 제외하고 &lt;a href=&quot;command&quot;&gt;명령&lt;/a&gt; 과 동일한 결과 형식 .</target>
        </trans-unit>
        <trans-unit id="1cc201c6f067fb6b6182b441f2b6dc0f4b71649b" translate="yes" xml:space="preserve">
          <source>Sample Output (new version, includes IDs)</source>
          <target state="translated">샘플 출력 (새 버전, ID 포함)</target>
        </trans-unit>
        <trans-unit id="fb0cb1b1aa0fcb98cea480e75b0d7dffc839cef1" translate="yes" xml:space="preserve">
          <source>Sample Output (old version)</source>
          <target state="translated">샘플 출력 (이전 버전)</target>
        </trans-unit>
        <trans-unit id="7a614be0679e1660abb7ab566a46118d4e5207f9" translate="yes" xml:space="preserve">
          <source>Sandbox and maximum execution time</source>
          <target state="translated">샌드 박스 및 최대 실행 시간</target>
        </trans-unit>
        <trans-unit id="c660854037806380c25fadc61428fa995d1aa015" translate="yes" xml:space="preserve">
          <source>Save the DB in background.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="444bd4af75b503112dd46c6982e0bae0a08cf7c2" translate="yes" xml:space="preserve">
          <source>Save the DB in background. The OK code is immediately returned. Redis forks, the parent continues to serve the clients, the child saves the DB on disk then exits. A client may be able to check if the operation succeeded using the &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; command.</source>
          <target state="translated">DB를 백그라운드로 저장하십시오. OK 코드가 즉시 반환됩니다. Redis 포크, 부모는 계속 클라이언트에게 서비스를 제공하고 자식은 DB를 디스크에 저장 한 다음 종료합니다. 클라이언트는 &lt;a href=&quot;lastsave&quot;&gt;LASTSAVE&lt;/a&gt; 명령을 사용하여 작업이 성공했는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e73e4e94939b275e189527f28b962ac1035dc5b" translate="yes" xml:space="preserve">
          <source>Scan guarantees</source>
          <target state="translated">스캔 보증</target>
        </trans-unit>
        <trans-unit id="983987071368a426b6b0e610cd5b5142cb273380" translate="yes" xml:space="preserve">
          <source>Script cache semantics</source>
          <target state="translated">스크립트 캐시 의미</target>
        </trans-unit>
        <trans-unit id="7522becbe814d8b8cbc378f8930c8ca68bb2b8b5" translate="yes" xml:space="preserve">
          <source>Scripting</source>
          <target state="translated">Scripting</target>
        </trans-unit>
        <trans-unit id="745fe7d4baa466214b942befb3f50f3311c89d23" translate="yes" xml:space="preserve">
          <source>Scripts are also subject to a maximum execution time (five seconds by default). This default timeout is huge since a script should usually run in under a millisecond. The limit is mostly to handle accidental infinite loops created during development.</source>
          <target state="translated">스크립트에는 최대 실행 시간 (기본적으로 5 초)이 적용됩니다. 스크립트가 일반적으로 밀리 초 이내에 실행되어야하므로이 기본 시간 초과는 엄청납니다. 한계는 대부분 개발 중에 생성 된 우발적 인 무한 루프를 처리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="aef3e907fc9586fb823b51b6f43074de8b409561" translate="yes" xml:space="preserve">
          <source>Scripts as pure functions</source>
          <target state="translated">순수한 함수로서의 스크립트</target>
        </trans-unit>
        <trans-unit id="18ec3225e4d3fe66e7449672a6973e4c283e8bfa" translate="yes" xml:space="preserve">
          <source>Scripts should never try to access the external system, like the file system or any other system call. A script should only operate on Redis data and passed arguments.</source>
          <target state="translated">스크립트는 파일 시스템이나 다른 시스템 호출과 같은 외부 시스템에 액세스하려고 시도해서는 안됩니다. 스크립트는 Redis 데이터 및 전달 된 인수에서만 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="96faa0a78d5b1890951d8f5b8b1cde571bd90423" translate="yes" xml:space="preserve">
          <source>Second replica</source>
          <target state="translated">두 번째 복제본</target>
        </trans-unit>
        <trans-unit id="3eb4e043552c7873cf099793db5b7d1e5db95809" translate="yes" xml:space="preserve">
          <source>Security notice</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5a6bb51bed42ec84477a8c64f567145dc6b3f5b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; for documentation.</source>
          <target state="translated">설명서는 &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="82b75cc42f6596f8de98cea0e684609b487d2473" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; for extra information on increment/decrement operations.</source>
          <target state="translated">증분 / 감소 작업에 대한 추가 정보는 &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b864667dcad5904883861ad9695e349acea56ad8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107b4f4ca6c2e49d71158688712e821a1f6afcf3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; for more information.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="54208184c8545cb10751d54f17912e96124fdcce" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; 설명서는 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7350f489b2f884299284e290b37d7bb050416da" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; 설명서는 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="23e07b46cb9a86395d17dec6e25da38c0a253bd8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; for &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; documentation.</source>
          <target state="translated">&lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; 설명서는 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf5419ddb7be58d105f864a1bb383d4d274d8979" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt; when you need the elements ordered from highest to lowest score (and descending lexicographical order for elements with equal score).</source>
          <target state="translated">가장 높은 점수에서 가장 낮은 점수로 정렬 된 요소가 필요할 때 &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE를&lt;/a&gt; 참조하십시오 (그리고 같은 점수를 가진 요소의 경우 내림차순 내림차순).</target>
        </trans-unit>
        <trans-unit id="a4157bb7f9bac5025b0c70053cd9e97522de9f5f" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; command that returns the same information with milliseconds resolution (Only available in Redis 2.6 or greater).</source>
          <target state="translated">밀리 초 해상도로 동일한 정보를 반환 하는 &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; 명령 도 참조하십시오 (Redis 2.6 이상에서만 사용 가능).</target>
        </trans-unit>
        <trans-unit id="3f65c6fd246f3e1cbd884a1abc8369fa9e3fec12" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;blpop&quot;&gt;BLPOP documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; is identical to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; with the only difference being that it pops elements from the tail of a list instead of popping from the head.</source>
          <target state="translated">참고 항목 &lt;a href=&quot;blpop&quot;&gt;BLPOP 문서를&lt;/a&gt; 하기 때문에, 정확한 의미에 대한 &lt;a href=&quot;brpop&quot;&gt;BRPOP이&lt;/a&gt; 동일 &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; 유일한 차이점은 대신 머리에서 터지는 목록의 꼬리에서 요소를 나올 것을 인 상태.</target>
        </trans-unit>
        <trans-unit id="98f2a156aa61e815ac476620027b033818a3853f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;blpop&quot;&gt;BLPOP documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; is identical to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; with the only difference being the data structure being popped from.</source>
          <target state="translated">투시 &lt;a href=&quot;blpop&quot;&gt;BLPOP 서를&lt;/a&gt; 때문에, 정확한 의미론위한 &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN가&lt;/a&gt; 동일 &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; 유일한 차이점에서 팝되는 데이터 구조 인 상태.</target>
        </trans-unit>
        <trans-unit id="682db2e97701526e3ecf1f9201b3297eab6f9ec7" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN documentation&lt;/a&gt; for the exact semantics, since &lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX&lt;/a&gt; is identical to &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; with the only difference being that it pops members with the highest scores instead of popping the ones with the lowest scores.</source>
          <target state="translated">참고 항목 &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN 문서를&lt;/a&gt; 하기 때문에, 정확한 의미에 대한 &lt;a href=&quot;bzpopmax&quot;&gt;BZPOPMAX이&lt;/a&gt; 동일 &lt;a href=&quot;bzpopmin&quot;&gt;BZPOPMIN&lt;/a&gt; 유일한 차이점은 대신 가장 낮은 점수를 가진 사람 터지는의 가장 높은 점수 회원 나올 것을 인 상태.</target>
        </trans-unit>
        <trans-unit id="58bc20fb0dd298ffb8cf41a50998826b6c62ee0f" translate="yes" xml:space="preserve">
          <source>See the article called &quot;&lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;Fast easy realtime metrics using Redis bitmaps&lt;/a&gt;&quot; for a interesting use cases.</source>
          <target state="translated">흥미로운 사용 사례는 &quot; &lt;a href=&quot;http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-bitmaps&quot;&gt;Redis 비트 맵을 사용하는 빠르고 쉬운 실시간 메트릭&lt;/a&gt; &quot;이라는 기사를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b55d9f15b0ea2d72611a684c74d755e0354f5c5" translate="yes" xml:space="preserve">
          <source>Select the Redis logical database having the specified zero-based numeric index. New connections always use the database 0.</source>
          <target state="translated">지정된 0부터 시작하는 숫자 인덱스가있는 Redis 논리 데이터베이스를 선택하십시오. 새 연결은 항상 데이터베이스 0을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5e585c2b51baeb7604c1d696f4c6be82b1e7c611" translate="yes" xml:space="preserve">
          <source>Selectable Redis databases are a form of namespacing: all databases are still persisted in the same RDB / AOF file. However different databases can have keys with the same name, and commands like &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt;, &lt;a href=&quot;swapdb&quot;&gt;SWAPDB&lt;/a&gt; or &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; work on specific databases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19899928b5f8951aa558a826d2465808d72a01a5" translate="yes" xml:space="preserve">
          <source>Selective replication of commands</source>
          <target state="translated">명령의 선택적 복제</target>
        </trans-unit>
        <trans-unit id="49cedc3ef8c6db0043eba553132d30f3fe261b2a" translate="yes" xml:space="preserve">
          <source>Sentinel output</source>
          <target state="translated">센티넬 출력</target>
        </trans-unit>
        <trans-unit id="23e75937982f844ac2efdda93d0cf6e15629e1a7" translate="yes" xml:space="preserve">
          <source>Serialization format</source>
          <target state="translated">직렬화 형식</target>
        </trans-unit>
        <trans-unit id="7af4afd659e0dc29f7d2d75a3f48646f5eb4ec0b" translate="yes" xml:space="preserve">
          <source>Serialize the value stored at key in a Redis-specific format and return it to the user. The returned value can be synthesized back into a Redis key using the &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command.</source>
          <target state="translated">키에 저장된 값을 Redis 특정 형식으로 직렬화하여 사용자에게 반환하십시오. 반환 된 값은 &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; 명령을 사용하여 Redis 키로 다시 합성 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb0cb170d106f8e8d5af1e05bbdbd3a96a7de197" translate="yes" xml:space="preserve">
          <source>Server</source>
          <target state="translated">Server</target>
        </trans-unit>
        <trans-unit id="c0ae85ee6d7ed57f6a577247b126ae67f64df433" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold string &lt;code&gt;value&lt;/code&gt; if &lt;code&gt;key&lt;/code&gt; does not exist. In that case, it is equal to &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. When &lt;code&gt;key&lt;/code&gt; already holds a value, no operation is performed. &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; is short for &quot;&lt;strong&gt;SET&lt;/strong&gt; if &lt;strong&gt;N&lt;/strong&gt;ot e&lt;strong&gt;X&lt;/strong&gt;ists&quot;.</source>
          <target state="translated">설정 &lt;code&gt;key&lt;/code&gt; 홀드 문자열에 &lt;code&gt;value&lt;/code&gt; 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않습니다. 이 경우 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 과 같습니다 . 때 &lt;code&gt;key&lt;/code&gt; 이미 값을 보유하고, 어떤 동작이 수행되지 않는다. &lt;a href=&quot;setnx&quot;&gt;SETNX는&lt;/a&gt; &quot;에 대한 짧은 &lt;strong&gt;SET&lt;/strong&gt; 경우 &lt;strong&gt;N&lt;/strong&gt; OT 전자 &lt;strong&gt;X&lt;/strong&gt; 주의자&quot;.</target>
        </trans-unit>
        <trans-unit id="68ffd036a56e1e5a5a24f70d86f4819eb308fad6" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold the string &lt;code&gt;value&lt;/code&gt; and set &lt;code&gt;key&lt;/code&gt; to timeout after a given number of seconds. This command is equivalent to executing the following commands:</source>
          <target state="translated">설정 &lt;code&gt;key&lt;/code&gt; 문자열 잡아 &lt;code&gt;value&lt;/code&gt; 및 설정 &lt;code&gt;key&lt;/code&gt; 지정된 시간 (초)이 경과하면 타임 아웃 시간을. 이 명령은 다음 명령을 실행하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e17569ffaef1d28acdfd66d09de8af3c0b06dd1a" translate="yes" xml:space="preserve">
          <source>Set &lt;code&gt;key&lt;/code&gt; to hold the string &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; already holds a value, it is overwritten, regardless of its type. Any previous time to live associated with the key is discarded on successful &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; operation.</source>
          <target state="translated">문자열 &lt;code&gt;value&lt;/code&gt; 을 보유하도록 &lt;code&gt;key&lt;/code&gt; 를 설정하십시오 . &lt;code&gt;key&lt;/code&gt; 이미 값이 있으면 유형에 관계없이 덮어 씁니다. 성공적인 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 조작시 키와 연관된 이전의 모든 시간은 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="1f4c1e8e25a5de08761510d1ae33392ed98c3afb" translate="yes" xml:space="preserve">
          <source>Set a timeout on &lt;code&gt;key&lt;/code&gt;. After the timeout has expired, the key will automatically be deleted. A key with an associated timeout is often said to be &lt;em&gt;volatile&lt;/em&gt; in Redis terminology.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 시간 제한을 설정하십시오 . 제한 시간이 만료되면 키가 자동으로 삭제됩니다. 관련 타임 아웃이있는 키는 종종 Redis 용어에서 &lt;em&gt;휘발성&lt;/em&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="eaec93cdacc6eb6c55472f85e73e6fb3ad082dbe" translate="yes" xml:space="preserve">
          <source>Set the consumer group &lt;em&gt;last delivered ID&lt;/em&gt; to something else.</source>
          <target state="translated">소비자 그룹 &lt;em&gt;마지막 전달 ID&lt;/em&gt; 를 다른 것으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d89ad31b7de012f12a03f34f4620f730e4db31a" translate="yes" xml:space="preserve">
          <source>Set the debug mode for subsequent scripts executed with &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;. Redis includes a complete Lua debugger, codename LDB, that can be used to make the task of writing complex scripts much simpler. In debug mode Redis acts as a remote debugging server and a client, such as &lt;code&gt;redis-cli&lt;/code&gt;, can execute scripts step by step, set breakpoints, inspect variables and more - for additional information about LDB refer to the &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Redis Lua debugger&lt;/a&gt; page.</source>
          <target state="translated">&lt;a href=&quot;eval&quot;&gt;EVAL로&lt;/a&gt; 실행되는 후속 스크립트에 대한 디버그 모드를 설정하십시오 . Redis에는 복잡한 스크립트를 작성하는 작업을 훨씬 간단하게 만드는 데 사용할 수있는 완전한 Lua 디버거 인 코드 명 LDB가 포함되어 있습니다. 디버그 모드에서 Redis는 원격 디버깅 서버 역할을하며 &lt;code&gt;redis-cli&lt;/code&gt; 와 같은 클라이언트는 단계별로 스크립트를 실행하고 중단 점을 설정하며 변수를 검사하는 등의 작업을 수행 할 수 있습니다. LDB에 대한 추가 정보는 &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Redis Lua 디버거&lt;/a&gt; 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6550b71f96cbf89e715fc6e575e8db9958a3525f" translate="yes" xml:space="preserve">
          <source>Set the destination node slot to &lt;em&gt;importing&lt;/em&gt; state using &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; IMPORTING &amp;lt;source-node-id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; IMPORTING &amp;lt;source-node-id&amp;gt;&lt;/code&gt; 사용하여 대상 노드 슬롯을 &lt;em&gt;가져 오기&lt;/em&gt; 상태로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="84c2dc8e1aa43a852766a49a5d96696d6e7e9329" translate="yes" xml:space="preserve">
          <source>Set the source node slot to &lt;em&gt;migrating&lt;/em&gt; state using &lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; MIGRATING &amp;lt;destination-node-id&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CLUSTER SETSLOT &amp;lt;slot&amp;gt; MIGRATING &amp;lt;destination-node-id&amp;gt;&lt;/code&gt; 사용하여 소스 노드 슬롯을 &lt;em&gt;마이그레이션&lt;/em&gt; 상태로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ab262f44dfc9e1ee8adf98c1aa64de34434fa83" translate="yes" xml:space="preserve">
          <source>Sets</source>
          <target state="translated">Sets</target>
        </trans-unit>
        <trans-unit id="d9264103cd2db8160e2072438f28377ce6a9fc7b" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;, only if &lt;code&gt;field&lt;/code&gt; does not yet exist. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; already exists, this operation has no effect.</source>
          <target state="translated">&lt;code&gt;field&lt;/code&gt; 가 아직없는 경우에만 &lt;code&gt;key&lt;/code&gt; 에 저장된 해시의 &lt;code&gt;field&lt;/code&gt; 를 &lt;code&gt;value&lt;/code&gt; 로 설정 합니다. 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 해시를 들고 새 키가 생성됩니다. 경우 &lt;code&gt;field&lt;/code&gt; 이미이 작업은 아무런 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4067fd3c70d6275dbeb4b012c5dce8cf613a429a" translate="yes" xml:space="preserve">
          <source>Sets &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; already exists in the hash, it is overwritten.</source>
          <target state="translated">설정 &lt;code&gt;field&lt;/code&gt; 에 저장된 해시 &lt;code&gt;key&lt;/code&gt; 에 대한 &lt;code&gt;value&lt;/code&gt; . 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 해시를 들고 새 키가 생성됩니다. 경우 &lt;code&gt;field&lt;/code&gt; 이미 해시에 존재, 그것은 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="e0c3c8b5846a6b7343db97e53a136456e18a31e2" translate="yes" xml:space="preserve">
          <source>Sets can be encoded as &lt;code&gt;intset&lt;/code&gt; or &lt;code&gt;hashtable&lt;/code&gt;. The &lt;code&gt;intset&lt;/code&gt; is a special encoding used for small sets composed solely of integers.</source>
          <target state="translated">세트는 &lt;code&gt;intset&lt;/code&gt; 또는 &lt;code&gt;hashtable&lt;/code&gt; 로 인코딩 할 수 있습니다 . &lt;code&gt;intset&lt;/code&gt; 은 전적으로 정수 구성된 작은 세트하기 위해 사용되는 특별한 인코딩된다.</target>
        </trans-unit>
        <trans-unit id="e2de8a522a3c6c1fa9f2cb3110ab55a427778354" translate="yes" xml:space="preserve">
          <source>Sets or clears the bit at &lt;em&gt;offset&lt;/em&gt; in the string value stored at &lt;em&gt;key&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;key에&lt;/em&gt; 저장된 문자열 값 에서 &lt;em&gt;오프셋&lt;/em&gt; 의 비트를 설정하거나 지 웁니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e97dcc6f663f896d57a6785f5e028d865ad0719f" translate="yes" xml:space="preserve">
          <source>Sets the given keys to their respective values. &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; replaces existing values with new values, just as regular &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. See &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; if you don't want to overwrite existing values.</source>
          <target state="translated">주어진 키를 각각의 값으로 설정합니다. &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; 은 일반 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 처럼 기존 값을 새 값으로 바꿉니다 . 기존 값을 덮어 쓰지 않으려면 &lt;a href=&quot;msetnx&quot;&gt;MSETNX를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5a2c8ceb3bc610f26a67627aba4acc8339a9ce7d" translate="yes" xml:space="preserve">
          <source>Sets the given keys to their respective values. &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; will not perform any operation at all even if just a single key already exists.</source>
          <target state="translated">주어진 키를 각각의 값으로 설정합니다. 단일 키만 이미 존재하더라도 &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; 는 아무런 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="97465787360d692779d220c22de863eac3b87265" translate="yes" xml:space="preserve">
          <source>Sets the list element at &lt;code&gt;index&lt;/code&gt; to &lt;code&gt;element&lt;/code&gt;. For more information on the &lt;code&gt;index&lt;/code&gt; argument, see &lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8750c7a418a307afb7502f752e1bd4c1264fa761" translate="yes" xml:space="preserve">
          <source>Sets the list element at &lt;code&gt;index&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt;. For more information on the &lt;code&gt;index&lt;/code&gt; argument, see &lt;a href=&quot;lindex&quot;&gt;LINDEX&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;index&lt;/code&gt; 의 list 요소 를 &lt;code&gt;value&lt;/code&gt; 로 설정합니다 . &lt;code&gt;index&lt;/code&gt; 인수 에 대한 자세한 정보는 &lt;a href=&quot;lindex&quot;&gt;LINDEX를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3acb8a6c67905faa893fe92726100c83a3b40b2e" translate="yes" xml:space="preserve">
          <source>Sets the specified fields to their respective values in the hash stored at &lt;code&gt;key&lt;/code&gt;. This command overwrites any specified fields already existing in the hash. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시에서 지정된 필드를 해당 값으로 설정합니다 . 이 명령은 해시에 이미 존재하는 지정된 필드를 덮어 씁니다. 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 해시를 들고 새 키가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="66e4a6395d06dd6c9ac9889a54defa5d69368f6e" translate="yes" xml:space="preserve">
          <source>Similarly to get just the last element added into the stream it is enough to send:</source>
          <target state="translated">마찬가지로 스트림에 마지막으로 추가 된 요소 만 가져 오려면 다음을 전송하기에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="e66ca1aceaf1d95b66f61ef999386ba4322050ac" translate="yes" xml:space="preserve">
          <source>Simple string reply</source>
          <target state="translated">간단한 문자열 회신</target>
        </trans-unit>
        <trans-unit id="d1d2334a81971315130c4fe2db94eeb5d843a482" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; and &lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER&lt;/a&gt; have a &lt;code&gt;STORE&lt;/code&gt; and &lt;code&gt;STOREDIST&lt;/code&gt; option they are technically flagged as writing commands in the Redis command table. For this reason read-only replicas will flag them, and Redis Cluster replicas will redirect them to the master instance even if the connection is in read only mode (See the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command of Redis Cluster).</source>
          <target state="translated">이후 &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; 및 &lt;a href=&quot;georadiusbymember&quot;&gt;GEORADIUSBYMEMBER이&lt;/a&gt; 이 &lt;code&gt;STORE&lt;/code&gt; 및 &lt;code&gt;STOREDIST&lt;/code&gt; 옵션을 그들은 기술적으로 레디 스 명령 테이블에 명령을 쓰는 것으로 표시된다. 이러한 이유로 읽기 전용 복제본은이를 복제하고 연결이 읽기 전용 모드 인 경우에도 Redis Cluster 복제본은이를 복제하여 마스터 인스턴스로 리디렉션합니다 ( Redis Cluster 의 &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; 명령 참조 ).</target>
        </trans-unit>
        <trans-unit id="97d9bd95aec04226ad20ff34e75e5087d27999bb" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; returns the number of replicas reached both in case of failure and success, the client should check that the returned value is equal or greater to the replication level it demanded.</source>
          <target state="translated">&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; 는 실패와 성공시 모두 도달 한 복제본 수를 반환 하므로 클라이언트는 반환 된 값이 필요한 복제 수준 이상인지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="d91e505ea765c9a82be96ae5534dfec641b36446" translate="yes" xml:space="preserve">
          <source>Since Redis 2.4 the AOF rewrite is automatically triggered by Redis, however the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; command can be used to trigger a rewrite at any time.</source>
          <target state="translated">Redis 2.4부터 AOF 다시 쓰기는 Redis에 의해 자동으로 트리거되지만 &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; 명령을 사용하여 언제든지 다시 쓰기를 트리거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fea1afb4200834342d36841c2047774edeed20c3" translate="yes" xml:space="preserve">
          <source>Since Redis 2.6 the expire error is from 0 to 1 milliseconds.</source>
          <target state="translated">Redis 2.6부터 만료 오류는 0에서 1 밀리 초입니다.</target>
        </trans-unit>
        <trans-unit id="c0dcf1f129fbdd5b581db58c1a230256a6836c37" translate="yes" xml:space="preserve">
          <source>Since Redis 3.0.3 it is possible to specify multiple keys instead of a single one. In such a case, it returns the total number of keys existing. Note that returning 1 or 0 for a single key is just a special case of the variadic usage, so the command is completely backward compatible.</source>
          <target state="translated">Redis 3.0.3부터 단일 키 대신 여러 키를 지정할 수 있습니다. 이 경우 기존의 총 키 수를 반환합니다. 단일 키에 대해 1 또는 0을 반환하는 것은 가변성 사용의 특수한 경우이므로 명령은 이전 버전과 완전히 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="f8bcf2ebedfce566d24835d3a2aba17bb7c2d1ca" translate="yes" xml:space="preserve">
          <source>Since Redis 3.0.3 the command accepts a variable number of keys and the return value is generalized:</source>
          <target state="translated">Redis 3.0.3부터 명령은 가변 개수의 키를 허용하며 리턴 값이 일반화됩니다.</target>
        </trans-unit>
        <trans-unit id="e151485b203362c942ed95e59fd38510a0f0ba0d" translate="yes" xml:space="preserve">
          <source>Since Redis 3.2.10 / 4.0.0, this command also prevents keys to be evicted or expired during the time clients are paused. This way the dataset is guaranteed to be static not just from the point of view of clients not being able to write, but also from the point of view of internal operations.</source>
          <target state="translated">Redis 3.2.10 / 4.0.0부터이 명령은 클라이언트가 일시 중지 된 시간 동안 키가 제거되거나 만료되는 것을 방지합니다. 이러한 방식으로 데이터 세트는 클라이언트가 쓸 수없는 관점뿐만 아니라 내부 작업 관점에서도 정적이되도록 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="b23d8947d72fa1ab05d11117a996f014677a635b" translate="yes" xml:space="preserve">
          <source>Since in the second call the returned cursor is 0, the server signaled to the caller that the iteration finished, and the collection was completely explored. Starting an iteration with a cursor value of 0, and calling &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; until the returned cursor is 0 again is called a &lt;strong&gt;full iteration&lt;/strong&gt;.</source>
          <target state="translated">두 번째 호출에서 리턴 된 커서는 0이므로 서버는 호출자에게 반복이 완료되었음을 알리고 콜렉션이 완전히 탐색되었음을 알 렸습니다. 커서 값이 0 인 반복을 시작 하고 리턴 된 커서가 다시 0이 될 때까지 &lt;a href=&quot;scan&quot;&gt;SCAN을&lt;/a&gt; 호출하는 것을 &lt;strong&gt;전체 반복&lt;/strong&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="5ff6f2c9633e20e1d4f2fc7a23a6109e8917c9ab" translate="yes" xml:space="preserve">
          <source>Since the &lt;code&gt;increment&lt;/code&gt; argument is signed, both increment and decrement operations can be performed:</source>
          <target state="translated">이후 &lt;code&gt;increment&lt;/code&gt; 인수 서명이 모두 증가 및 감소 조작을 수행 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="37a6aaafe1e5adca5e6fbd58e615c9ceed7c328a" translate="yes" xml:space="preserve">
          <source>Since the currently selected database is a property of the connection, clients should track the currently selected database and re-select it on reconnection. While there is no command in order to query the selected database in the current connection, the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; output shows, for each client, the currently selected database.</source>
          <target state="translated">현재 선택된 데이터베이스는 연결의 속성이므로 클라이언트는 현재 선택된 데이터베이스를 추적하고 다시 연결시 다시 선택해야합니다. 현재 연결에서 선택된 데이터베이스를 조회하기위한 명령이 없지만 &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; 출력은 각 클라이언트에 대해 현재 선택된 데이터베이스를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="52b5e60090730a6d250177de9e20295f9eac7ba4" translate="yes" xml:space="preserve">
          <source>Since the introduction of partial resynchronization with replicas (PSYNC feature) Redis replicas asynchronously ping their master with the offset they already processed in the replication stream. This is used in multiple ways:</source>
          <target state="translated">복제본과 부분 재 동기화 (PSYNC 기능)가 도입 된 이후 Redis 복제본은 복제 스트림에서 이미 처리 한 오프셋으로 마스터를 ping합니다. 이것은 여러 가지 방법으로 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="22f6371320dc02af91620e9a2e69ac86d721aec2" translate="yes" xml:space="preserve">
          <source>Since there is no state server side, but the full state is captured by the cursor, the caller is free to terminate an iteration half-way without signaling this to the server in any way. An infinite number of iterations can be started and never terminated without any issue.</source>
          <target state="translated">상태 서버 측은 없지만 커서가 전체 상태를 캡처하므로 호출자는 서버에 신호를 보내지 않고 중간에 반복을 자유롭게 종료 할 수 있습니다. 무한 반복을 시작할 수 있으며 아무런 문제없이 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="262e696e012026f3d4f6a8415b02d5a7c46227f9" translate="yes" xml:space="preserve">
          <source>Since these commands allow for incremental iteration, returning only a small number of elements per call, they can be used in production without the downside of commands like &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; or &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; that may block the server for a long time (even several seconds) when called against big collections of keys or elements.</source>
          <target state="translated">이러한 명령은 증분 반복을 허용하여 호출 당 적은 수의 요소 만 반환하므로 &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; 또는 &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; 와 같은 명령의 단점이 없어도 서버에서 오랜 시간 (몇 초) 동안 서버를 차단할 수 있습니다. 키 또는 요소의 큰 컬렉션.</target>
        </trans-unit>
        <trans-unit id="3c0c8d4b217b1b3c149a8290667da3e389e7ef26" translate="yes" xml:space="preserve">
          <source>Since this involves approximations, in order to avoid C is set to, like, 0.998 instead of 1, we just modify the above algorithm to make sure the last score is 1 (left as an exercise for the reader...).</source>
          <target state="translated">여기에는 근사치가 포함되므로 C가 1 대신 0.998과 같이 설정되는 것을 피하기 위해 위의 알고리즘을 수정하여 마지막 점수가 1이되도록하십시오 (독자의 연습으로 남겨 두십시오 ...).</target>
        </trans-unit>
        <trans-unit id="7872f5590df64a34d5d83302b83736d78de377e5" translate="yes" xml:space="preserve">
          <source>Since version 2.1.6, &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; can be exclusive, following the syntax of &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">버전 2.1.6부터 &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; 구문에 따라 &lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;max&lt;/code&gt; 가 배타적 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="62c6108c3b6b3ae8ea558c2fa3e4a664136371f3" translate="yes" xml:space="preserve">
          <source>Since version 6.2 it is possible to filter entries by their idle-time, given in milliseconds (useful for &lt;code&gt;XCLAIM&lt;/code&gt;ing entries that have not been processed for some time):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c1d2abc7675af0239fa910c466960e644589788" translate="yes" xml:space="preserve">
          <source>Single number: 3894</source>
          <target state="translated">단일 번호 : 3894</target>
        </trans-unit>
        <trans-unit id="f4a53209e61b36ab81faa5f943fba8e855032018" translate="yes" xml:space="preserve">
          <source>Skip sorting the elements</source>
          <target state="translated">요소 정렬 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="8eab09bbd450823e91103eb2aaa19c7c3697409f" translate="yes" xml:space="preserve">
          <source>So for example the command &lt;code&gt;GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST&lt;/code&gt; will return each item in the following way:</source>
          <target state="translated">예를 들어 &lt;code&gt;GEORADIUS Sicily 15 37 200 km WITHCOORD WITHDIST&lt;/code&gt; 명령 은 다음과 같은 방식으로 각 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="76d0f19de574ac1304a0b3b169f72caa92244d72" translate="yes" xml:space="preserve">
          <source>So for instance, to get all the elements from the higher ID to the lower ID one could use:</source>
          <target state="translated">예를 들어, 모든 요소를 ​​상위 ID에서 하위 ID로 가져 오려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="605cfa3fd340ae3e5e756672779740b80a689628" translate="yes" xml:space="preserve">
          <source>So in order for a given node to accept another one into the list of nodes composing a Redis Cluster, there are only two ways:</source>
          <target state="translated">따라서 특정 노드가 Redis 클러스터를 구성하는 노드 목록에 다른 노드를 허용하려면 두 가지 방법 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="2350b72b46e64aeb370c2cbfa4c601de95c3d620" translate="yes" xml:space="preserve">
          <source>So we start with a list of keys, and later continue with all the associated IDs, representing &lt;em&gt;the last ID we received for that stream&lt;/em&gt;, so that the call will serve us only greater IDs from the same stream.</source>
          <target state="translated">따라서 키 목록으로 시작한 다음 나중에 &lt;em&gt;해당 스트림에 대해 마지막으로 수신 한&lt;/em&gt; ID를 나타내는 모든 관련 ID를 계속 사용 하여 호출이 동일한 스트림의 더 큰 ID 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="46ddca2244f21f2b27c1eb6025f1e694d4b8bea0" translate="yes" xml:space="preserve">
          <source>So what the command really does is:</source>
          <target state="translated">따라서 명령이 실제로하는 일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f434d4f52b4b99882f1b83c63bcdd004df128d69" translate="yes" xml:space="preserve">
          <source>So, if we link node A with node B via &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt;, and B with C, A and C will find their ways to handshake and create a link.</source>
          <target state="translated">따라서 &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET을&lt;/a&gt; 통해 노드 A와 노드 B를 연결 하고 C와 B를 연결하면 A와 C는 핸드 셰이크하고 링크를 만드는 방법을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="60790236df4f5916ea98a7288f81aafe33a99ab5" translate="yes" xml:space="preserve">
          <source>So, using &lt;code&gt;CONFIG SET-CONFIG-EPOCH&lt;/code&gt;, when a new cluster is created, we can assign a different progressive configuration epoch to each node before joining the cluster together.</source>
          <target state="translated">따라서 &lt;code&gt;CONFIG SET-CONFIG-EPOCH&lt;/code&gt; 를 사용하여 새 클러스터를 만들 때 클러스터를 결합하기 전에 각 노드에 서로 다른 점진적 구성 에포크를 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4318ce82f602a680da3fd3d1f1b92cbeae45d01" translate="yes" xml:space="preserve">
          <source>So, we want to say, give me the first element starting from the tail of the list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="173217936882f8d5719c8defa86bf0d23eac51fe" translate="yes" xml:space="preserve">
          <source>Some Redis commands have no predetermined key locations. For those commands, flag &lt;code&gt;movablekeys&lt;/code&gt; is added to the command flags &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;. Your Redis Cluster client needs to parse commands marked &lt;code&gt;movablekeys&lt;/code&gt; to locate all relevant key positions.</source>
          <target state="translated">일부 Redis 명령에는 미리 정해진 키 위치가 없습니다. 해당 명령의 경우 플래그 이동 가능 &lt;code&gt;movablekeys&lt;/code&gt; 가 명령 플래그 &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply에&lt;/a&gt; 추가됩니다 . Redis Cluster 클라이언트는 모든 관련 키 위치를 찾으 &lt;code&gt;movablekeys&lt;/code&gt; 수있는 키로 표시된 명령을 구문 분석해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ddceed7fe40007b57317ba7df983076bcd185123" translate="yes" xml:space="preserve">
          <source>Some consumer A reads a message via &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; from a stream, in the context of that consumer group.</source>
          <target state="translated">일부 소비자 A 는 해당 소비자 그룹과 관련하여 스트림에서 &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; 을 통해 메시지를 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="28d440075fc880e5ff5b66c8a65009bc3be5acfb" translate="yes" xml:space="preserve">
          <source>Sometimes it can be useful for clients to completely disable replies from the Redis server. For example when the client sends fire and forget commands or performs a mass loading of data, or in caching contexts where new data is streamed constantly. In such contexts to use server time and bandwidth in order to send back replies to clients, which are going to be ignored, is considered wasteful.</source>
          <target state="translated">클라이언트가 Redis 서버의 응답을 완전히 비활성화하는 것이 유용한 경우도 있습니다. 예를 들어, 클라이언트가 fire 및 forget 명령을 보내거나 대량의 데이터로드를 수행하거나 새로운 데이터가 지속적으로 스트리밍되는 컨텍스트를 캐싱하는 경우를 예로들 수 있습니다. 이러한 맥락에서 서버 시간과 대역폭을 사용하여 응답을 클라이언트에게 다시 보내기 위해 무시하는 것은 낭비로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a1fbf7ca3941093b616976378d4450adc4f2adb7" translate="yes" xml:space="preserve">
          <source>Sometimes it may be useful to remove old consumers since they are no longer used. This form returns the number of pending messages that the consumer had before it was deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="295b7c77aec21f1ec78f8bb6debbc23501dae53f" translate="yes" xml:space="preserve">
          <source>Sometimes we need just the length of the match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a212e08b7709fdef0e43a6ae14d5840bfa05846" translate="yes" xml:space="preserve">
          <source>Sometimes we want to return not just the Nth matching element, but the position of all the first N matching elements. This can be achieved using the &lt;code&gt;COUNT&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43292f17e4e5fce7b6e4920a4500928789cc3b9d" translate="yes" xml:space="preserve">
          <source>Sometimes you want to sort elements using external keys as weights to compare instead of comparing the actual elements in the list, set or sorted set. Let's say the list &lt;code&gt;mylist&lt;/code&gt; contains the elements &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; representing unique IDs of objects stored in &lt;code&gt;object_1&lt;/code&gt;, &lt;code&gt;object_2&lt;/code&gt; and &lt;code&gt;object_3&lt;/code&gt;. When these objects have associated weights stored in &lt;code&gt;weight_1&lt;/code&gt;, &lt;code&gt;weight_2&lt;/code&gt; and &lt;code&gt;weight_3&lt;/code&gt;, &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; can be instructed to use these weights to sort &lt;code&gt;mylist&lt;/code&gt; with the following statement:</source>
          <target state="translated">때로는 목록, 세트 또는 정렬 세트의 실제 요소를 비교하는 대신 외부 키를 가중치로 사용하여 요소를 정렬 할 때가 있습니다. &lt;code&gt;mylist&lt;/code&gt; 목록 에 &lt;code&gt;object_1&lt;/code&gt; , &lt;code&gt;object_2&lt;/code&gt; 및 &lt;code&gt;object_3&lt;/code&gt; 에 저장된 객체의 고유 ID를 나타내는 요소 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 및 &lt;code&gt;3&lt;/code&gt; 이 포함되어 있다고 가정 합니다. 이러한 객체에 &lt;code&gt;weight_1&lt;/code&gt; , &lt;code&gt;weight_2&lt;/code&gt; 및 &lt;code&gt;weight_3&lt;/code&gt; 에 저장된 관련 가중치 가있는 경우 &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; 는 이러한 가중치를 사용 하여 다음 명령문으로 &lt;code&gt;mylist&lt;/code&gt; 를 정렬하도록 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2397d818d7562914c5b062b54f97e833db314f2" translate="yes" xml:space="preserve">
          <source>Sorted Sets</source>
          <target state="translated">정렬 된 세트</target>
        </trans-unit>
        <trans-unit id="25ab5e6a0d5f2c9c6bc25d348c156dc61d5c8552" translate="yes" xml:space="preserve">
          <source>Sorted Sets can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;skiplist&lt;/code&gt; format. As for the List type small sorted sets can be specially encoded using &lt;code&gt;ziplist&lt;/code&gt;, while the &lt;code&gt;skiplist&lt;/code&gt; encoding is the one that works with sorted sets of any size.</source>
          <target state="translated">정렬 된 세트는 &lt;code&gt;ziplist&lt;/code&gt; 또는 &lt;code&gt;skiplist&lt;/code&gt; 형식 으로 인코딩 될 수 있습니다 . 목록 유형의 경우 작은 정렬 세트는 &lt;code&gt;ziplist&lt;/code&gt; 를 사용하여 특별히 인코딩 할 수있는 반면, &lt;code&gt;skiplist&lt;/code&gt; 인코딩은 모든 크기의 정렬 된 세트와 작동하는 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="86e387fe2a33fb39f76cfff98ea344b952f84a62" translate="yes" xml:space="preserve">
          <source>Sorted sets 101</source>
          <target state="translated">분류 된 세트 101</target>
        </trans-unit>
        <trans-unit id="785f83ba9125723b72d2c573196ef8beabb345a8" translate="yes" xml:space="preserve">
          <source>Sorted sets are sorted by their score in an ascending way. The same element only exists a single time, no repeated elements are permitted. The score can be modified both by &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; that will update the element score, and as a side effect, its position on the sorted set, and by &lt;a href=&quot;zincrby&quot;&gt;ZINCRBY&lt;/a&gt; that can be used in order to update the score relatively to its previous value.</source>
          <target state="translated">정렬 된 세트는 점수에 따라 오름차순으로 정렬됩니다. 동일한 요소는 한 번만 존재하며 반복되는 요소는 허용되지 않습니다. 점수는 모두에 의해 변형 될 수 &lt;a href=&quot;zadd&quot;&gt;ZADD&lt;/a&gt; 소자 점수를 업데이트 할 것을, 및 부작용에, 및에 의해 정렬 된 세트의 위치 &lt;a href=&quot;zincrby&quot;&gt;ZINCRBY&lt;/a&gt; 위해 사용될 수있는 비교적 이전 값의 점수를 업데이트.</target>
        </trans-unit>
        <trans-unit id="2f2a07b6f7677455f1b32d657bbc8366bfa48bf3" translate="yes" xml:space="preserve">
          <source>Sorting by external keys</source>
          <target state="translated">외부 키를 기준으로 정렬</target>
        </trans-unit>
        <trans-unit id="614fb399b6728ae041f21780ab6202d98e11c79a" translate="yes" xml:space="preserve">
          <source>Special conditions not allowing the command execution</source>
          <target state="translated">명령 실행을 허용하지 않는 특수 조건</target>
        </trans-unit>
        <trans-unit id="0869a917cb9ab140bb00f5d52e7332ad6727fd9a" translate="yes" xml:space="preserve">
          <source>Special slot entries</source>
          <target state="translated">특수 슬롯 엔트리</target>
        </trans-unit>
        <trans-unit id="549c2b56d95e908566338d2fd5914a21fd08d936" translate="yes" xml:space="preserve">
          <source>Specifically if a given write is transferred to one or more replicas, it is more likely (but not guaranteed) that if the master fails, we'll be able to promote, during a failover, a replica that received the write: both Sentinel and Redis Cluster will do a best-effort attempt to promote the best replica among the set of available replicas.</source>
          <target state="translated">특히 지정된 쓰기가 하나 이상의 복제본으로 전송되는 경우 마스터가 실패하면 장애 조치 (failover) 중에 쓰기를받은 복제본 (Sentinel 및 Redis Cluster는 사용 가능한 복제 세트 중에서 최상의 복제를 촉진하기 위해 최선의 노력을 다할 것입니다.</target>
        </trans-unit>
        <trans-unit id="d526406a65071e1fec15bd4174751e7a5bc387d7" translate="yes" xml:space="preserve">
          <source>Specifically this is what Redis does 10 times per second:</source>
          <target state="translated">특히 이것은 Redis가 초당 10 회 수행하는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="2fa9940f1d66c2c57fbda5e1ef12bce097cf18d3" translate="yes" xml:space="preserve">
          <source>Specifically, it lists the user's ACL flags, password hashes and key name patterns. Note that command rules are returned as a string in the same format used with the &lt;a href=&quot;acl-setuser&quot;&gt;ACL SETUSER&lt;/a&gt; command. This description of command rules reflects the user's effective permissions, so while it may not be identical to the set of rules used to configure the user, it is still functionally identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9ff7d39e693899b2fb01c2af7e0b9aad8efd43b" translate="yes" xml:space="preserve">
          <source>Specifically:</source>
          <target state="translated">Specifically:</target>
        </trans-unit>
        <trans-unit id="37ec7d989573caff7ef9f45953dba8d022709000" translate="yes" xml:space="preserve">
          <source>Specification of the behavior when count is passed</source>
          <target state="translated">카운트가 통과 될 때의 동작 지정</target>
        </trans-unit>
        <trans-unit id="14c30af049c8842dbcbd1159d5db60d5f0981029" translate="yes" xml:space="preserve">
          <source>Specifying a Stream ID as an argument</source>
          <target state="translated">스트림 ID를 인수로 지정</target>
        </trans-unit>
        <trans-unit id="1544a5bc78a2aee56854818668d14afd235ec6c9" translate="yes" xml:space="preserve">
          <source>Start slot range</source>
          <target state="translated">시작 슬롯 범위</target>
        </trans-unit>
        <trans-unit id="ee455845986f290115764586b0c8b62db6794d99" translate="yes" xml:space="preserve">
          <source>Starting from Redis version 2.6, when called with the additional &lt;code&gt;count&lt;/code&gt; argument, return an array of &lt;code&gt;count&lt;/code&gt;&lt;strong&gt;distinct elements&lt;/strong&gt; if &lt;code&gt;count&lt;/code&gt; is positive. If called with a negative &lt;code&gt;count&lt;/code&gt; the behavior changes and the command is allowed to return the &lt;strong&gt;same element multiple times&lt;/strong&gt;. In this case the number of returned elements is the absolute value of the specified &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">추가로 호출 될 때 레디 스 버전 2.6부터 &lt;code&gt;count&lt;/code&gt; 인수의 어레이 반환 &lt;code&gt;count&lt;/code&gt; &lt;strong&gt;고유 요소&lt;/strong&gt; 만약 &lt;code&gt;count&lt;/code&gt; 긍정적이다. 부정적인 호출하면 &lt;code&gt;count&lt;/code&gt; 동작을 변경하고 명령이 반환 할 수있다 &lt;strong&gt;동일한 요소를 여러 번&lt;/strong&gt; . 이 경우 반환 된 요소의 수는 지정된 &lt;code&gt;count&lt;/code&gt; 의 절대 값입니다 .</target>
        </trans-unit>
        <trans-unit id="83f9c28598d952311fc09fa54e334ed57a68832b" translate="yes" xml:space="preserve">
          <source>Starting with Redis 2.6.12 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; supports a set of options that modify its behavior:</source>
          <target state="translated">Redis 2.6.12부터 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 은 동작을 수정하는 일련의 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f154b597ac1178d82fc4c50afc3e83d654688468" translate="yes" xml:space="preserve">
          <source>Starting with Redis 2.8 the return value in case of error changed:</source>
          <target state="translated">Redis 2.8부터 오류가 변경된 경우의 반환 값 :</target>
        </trans-unit>
        <trans-unit id="cb9c10a639cbbf2b71b38cd0e777ffb915ed4e8b" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.0.6 &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; supports a new bulk-migration mode that uses pipelining in order to migrate multiple keys between instances without incurring in the round trip time latency and other overheads that there are when moving each key with a single &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; call.</source>
          <target state="translated">Redis 3.0.6부터 &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; 는 파이프 라인을 사용하여 왕복 시간 지연이 발생하지 않고 인스턴스간에 여러 키를 마이그레이션하고 단일 &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; 호출 로 각 키를 이동할 때 발생하는 기타 오버 헤드를 마이그레이션하는 새로운 대량 마이그레이션 모드를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="6578980d36f8246047edd57af78a6f9934454cea" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.2, Redis has support for native Lua debugging. The Redis Lua debugger is a remote debugger consisting of a server, which is Redis itself, and a client, which is by default &lt;code&gt;redis-cli&lt;/code&gt;.</source>
          <target state="translated">Redis 3.2부터 Redis는 기본 Lua 디버깅을 지원합니다. Redis Lua 디버거는 Redis 자체 인 서버와 기본적으로 &lt;code&gt;redis-cli&lt;/code&gt; 인 클라이언트로 구성된 원격 디버거 입니다.</target>
        </trans-unit>
        <trans-unit id="5b01b9bd2a097f98e87d6033b411073bab6691f7" translate="yes" xml:space="preserve">
          <source>Starting with Redis 3.2, it is possible to select an alternative replication method. Instead of replication whole scripts, we can just replicate single write commands generated by the script. We call this &lt;strong&gt;script effects replication&lt;/strong&gt;.</source>
          <target state="translated">Redis 3.2부터는 대체 복제 방법을 선택할 수 있습니다. 전체 스크립트를 복제하는 대신 스크립트에서 생성 된 단일 쓰기 명령을 복제 할 수 있습니다. 우리는이 &lt;strong&gt;스크립트 효과를 복제&lt;/strong&gt; 라고 부릅니다 .</target>
        </trans-unit>
        <trans-unit id="2b5108a4d347209131d9cdaa00d48ad36bea64af" translate="yes" xml:space="preserve">
          <source>Starting with Redis version 6, the server supports two different protocols. One is called RESP2, and is the old protocol: all the new connections to the server start in this mode. However clients are able to negotiate the new protocol using the &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command: this way the connection is put in RESP3 mode. In this mode certain commands, like for instance &lt;a href=&quot;hgetall&quot;&gt;HGETALL&lt;/a&gt;, reply with a new data type (the Map data type in this specific case). The RESP3 protocol is semantically more powerful, however most scripts are OK with using just RESP2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ffd355623442762e32037427cffdb34a18e3984" translate="yes" xml:space="preserve">
          <source>Step 4 does not technically need to use &lt;code&gt;SETSLOT&lt;/code&gt; in the nodes not involved in the resharding, since the configuration will eventually propagate itself, however it is a good idea to do so in order to stop nodes from pointing to the wrong node for the hash slot moved as soon as possible, resulting in less redirections to find the right node.</source>
          <target state="translated">4 단계 는 구성이 결국 자체 전파되기 때문에 리 샤딩에 관련되지 않은 노드에서 기술적으로 &lt;code&gt;SETSLOT&lt;/code&gt; 을 사용할 필요 는 없지만, 노드가 해시 슬롯에 대해 잘못된 노드를 가리 키지 않도록하기 위해 그렇게하는 것이 좋습니다. 가능한 빨리 이동하여 올바른 노드를 찾기위한 리디렉션이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="f75b76768d708a29fc0fb9becaf181931853bd99" translate="yes" xml:space="preserve">
          <source>Step Count</source>
          <target state="translated">걸음 수</target>
        </trans-unit>
        <trans-unit id="f7fa846d5511789adfec64aa9b8751f7351a0ca5" translate="yes" xml:space="preserve">
          <source>Stop all the clients.</source>
          <target state="translated">모든 클라이언트를 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="6cb759f69a54fcb63d47af649e368c12075f71be" translate="yes" xml:space="preserve">
          <source>Storing the result of a SORT operation</source>
          <target state="translated">SORT 조작 결과 저장</target>
        </trans-unit>
        <trans-unit id="df063869e11d7a9aa132cd4a984f7b5eb870d656" translate="yes" xml:space="preserve">
          <source>Stream</source>
          <target state="translated">Stream</target>
        </trans-unit>
        <trans-unit id="61c2b2148d7f362f23210527dbc1bd6b0437b131" translate="yes" xml:space="preserve">
          <source>Stream IDs are composed of two parts, a Unix millisecond time stamp and a sequence number for entries inserted in the same millisecond. It is possible to use &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; specifying just the first part of the ID, the millisecond time, like in the following example:</source>
          <target state="translated">스트림 ID는 Unix 밀리 초 타임 스탬프와 동일한 밀리 초에 삽입 된 항목의 시퀀스 번호의 두 부분으로 구성됩니다. 다음 예제와 같이 ID의 첫 번째 부분 인 밀리 초 시간 만 지정 하여 &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e577b53fb1794580c0560fa9502cf28744dcd504" translate="yes" xml:space="preserve">
          <source>Stream entries are returned, including fields and values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7e700aeb9d8c3a456c6730300f1abde75268288" translate="yes" xml:space="preserve">
          <source>Streams are not auto-deleted once they have no entries inside (for instance after an &lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt; call), because the stream may have consumer groups associated with it.</source>
          <target state="translated">스트림에 소비자 그룹이있을 수 있으므로 스트림에 항목이 없으면 (예 : &lt;a href=&quot;xdel&quot;&gt;XDEL&lt;/a&gt; 호출 후) 스트림이 자동 삭제되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3816c4beac471c733eed1d91c213f8c2b6a29262" translate="yes" xml:space="preserve">
          <source>Strings</source>
          <target state="translated">Strings</target>
        </trans-unit>
        <trans-unit id="48c2711e04347f7b6d1ddd6b4a79296a8d2830ea" translate="yes" xml:space="preserve">
          <source>Strings are compared as binary array of bytes. Because of how the ASCII character set is specified, this means that usually this also have the effect of comparing normal ASCII characters in an obvious dictionary way. However this is not true if non plain ASCII strings are used (for example utf8 strings).</source>
          <target state="translated">문자열은 이진 바이트 배열로 비교됩니다. ASCII 문자 집합이 지정되는 방식으로 인해 이는 일반적으로 일반 ASCII 문자를 명확한 사전 방식으로 비교하는 효과도 있음을 의미합니다. 그러나 일반 ASCII 문자열이 아닌 문자열 (예 : utf8 문자열)을 사용하는 경우에는 해당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2593368d27635cc5293b7e53f7145a56dff05dd8" translate="yes" xml:space="preserve">
          <source>Strings can be encoded as &lt;code&gt;raw&lt;/code&gt; (normal string encoding) or &lt;code&gt;int&lt;/code&gt; (strings representing integers in a 64 bit signed interval are encoded in this way in order to save space).</source>
          <target state="translated">문자열은 &lt;code&gt;raw&lt;/code&gt; (일반 문자열 인코딩) 또는 &lt;code&gt;int&lt;/code&gt; 로 인코딩 될 수 있습니다 ( 64 비트 부호있는 간격으로 정수를 나타내는 문자열은 이러한 방식으로 공간을 절약하기 위해 인코딩 됨).</target>
        </trans-unit>
        <trans-unit id="d5294ece475c0dd1b0e5c4f6f621c1e0c0bf7039" translate="yes" xml:space="preserve">
          <source>Strings with a similar prefix are nearby, but the contrary is not true, it is possible that strings with different prefixes are nearby too.</source>
          <target state="translated">접두사가 비슷한 문자열이 근처에 있지만 그 반대가 사실이 아닙니다. 접두사가 다른 문자열도 근처에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f9d46e5fb83a7700b4c788a03b12a80a7e61e08" translate="yes" xml:space="preserve">
          <source>Subcommand &lt;code&gt;encoding&lt;/code&gt; returns a bulk reply.</source>
          <target state="translated">부속 명령 &lt;code&gt;encoding&lt;/code&gt; 은 대량 응답을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="03e52fefcd721e1070e1756817dc5fb3908630a4" translate="yes" xml:space="preserve">
          <source>Subcommands &lt;code&gt;refcount&lt;/code&gt; and &lt;code&gt;idletime&lt;/code&gt; return integers.</source>
          <target state="translated">부속 명령 &lt;code&gt;refcount&lt;/code&gt; 및 &lt;code&gt;idletime&lt;/code&gt; 은 정수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9cdf88a718c3f491225fa1cc2fd76602c7208ad1" translate="yes" xml:space="preserve">
          <source>Subscribes the client to the given patterns.</source>
          <target state="translated">주어진 패턴으로 클라이언트를 구독합니다.</target>
        </trans-unit>
        <trans-unit id="481c5cf231fde7f8730860922d6f3194fc5f2170" translate="yes" xml:space="preserve">
          <source>Subscribes the client to the specified channels.</source>
          <target state="translated">클라이언트를 지정된 채널에 가입시킵니다.</target>
        </trans-unit>
        <trans-unit id="4a47fd9934d349f948abbf361726590ff096c6b8" translate="yes" xml:space="preserve">
          <source>Summary form of XPENDING</source>
          <target state="translated">XPENDING의 요약 양식</target>
        </trans-unit>
        <trans-unit id="dfe7ee6f8d575326187ecdb8ea7e6fb7cbf4ec35" translate="yes" xml:space="preserve">
          <source>Supported glob-style patterns:</source>
          <target state="translated">지원되는 글로브 스타일 패턴 :</target>
        </trans-unit>
        <trans-unit id="ced890cac00d712740bdc4d39c1db48f7483c499" translate="yes" xml:space="preserve">
          <source>Supported subcommands and integer types</source>
          <target state="translated">지원되는 부속 명령 및 정수 유형</target>
        </trans-unit>
        <trans-unit id="108e22a5749de8f07b0272d8029eeb2811ea28dd" translate="yes" xml:space="preserve">
          <source>Switch the connection to a different protocol. Redis version 6 or greater are able to support two protocols, the old protocol, RESP2, and a new one introduced with Redis 6, RESP3. RESP3 has certain advantages since when the connection is in this mode, Redis is able to reply with more semantical replies: for instance &lt;a href=&quot;hgetall&quot;&gt;HGETALL&lt;/a&gt; will return a &lt;em&gt;map type&lt;/em&gt;, so a client library implementation no longer requires to know in advance to translate the array into a hash before returning it to the caller. For a full coverage of RESP3 please &lt;a href=&quot;https://github.com/antirez/resp3&quot;&gt;check this repository&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8398e47e81dab008569a234703960eb8bab2f11" translate="yes" xml:space="preserve">
          <source>TAKEOVER option: manual failover without cluster consensus</source>
          <target state="translated">인수 옵션 : 클러스터 합의없이 수동 장애 조치</target>
        </trans-unit>
        <trans-unit id="64269f9bd268bf28815bb69e82601cd7e806a37b" translate="yes" xml:space="preserve">
          <source>TIME</source>
          <target state="translated">TIME</target>
        </trans-unit>
        <trans-unit id="8696f7a4c64b4516c2d96434e8b7824957a37d2a" translate="yes" xml:space="preserve">
          <source>TIME   Return the current server time</source>
          <target state="translated">TIME 현재 서버 시간을 반환</target>
        </trans-unit>
        <trans-unit id="c701f5f92060225c236ac0e6b3051e03bb0ad061" translate="yes" xml:space="preserve">
          <source>TOUCH</source>
          <target state="translated">TOUCH</target>
        </trans-unit>
        <trans-unit id="ad5ae533c502772151a704d28a2bece0e0f4ca1b" translate="yes" xml:space="preserve">
          <source>TOUCH  key [key ...]   Alters the last access time of a key(s). Returns the number of existing keys specified.</source>
          <target state="translated">TOUCH 키 [key ...] 키의 마지막 액세스 시간을 변경합니다. 지정된 기존 키 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="878260dfb888c3312c119e6db2253c2aa207ae98" translate="yes" xml:space="preserve">
          <source>TTL</source>
          <target state="translated">TTL</target>
        </trans-unit>
        <trans-unit id="8ef7742bd419d3406904eb9723c6ce85d49c0f81" translate="yes" xml:space="preserve">
          <source>TTL  key   Get the time to live for a key</source>
          <target state="translated">TTL 키 키를위한 시간을 보내십시오</target>
        </trans-unit>
        <trans-unit id="6e9816a8e9d0388eecdb52866188c04e75e4b1b3" translate="yes" xml:space="preserve">
          <source>TYPE</source>
          <target state="translated">TYPE</target>
        </trans-unit>
        <trans-unit id="7d0cfb250d49bba162e019907ea71cfcab32d9f4" translate="yes" xml:space="preserve">
          <source>TYPE  key   Determine the type stored at key</source>
          <target state="translated">TYPE 키 키에 저장된 유형을 결정합니다</target>
        </trans-unit>
        <trans-unit id="5bbc08d2de04a7034dc9edbe2e20759367a5f82f" translate="yes" xml:space="preserve">
          <source>Taking a separated key that is incremented every time the bitmap is modified. This can be very efficient and atomic using a small Redis Lua script.</source>
          <target state="translated">비트 맵이 수정 될 때마다 증가하는 분리 된 키를 가져옵니다. 작은 Redis Lua 스크립트를 사용하면 매우 효율적이고 원자적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b5d4fb8b75675d300f4de7425675abc3149473f" translate="yes" xml:space="preserve">
          <source>Terminating iterations in the middle</source>
          <target state="translated">중간에서 반복 종료</target>
        </trans-unit>
        <trans-unit id="8a78f0cb0822107a63b906522f8970fb02d3906a" translate="yes" xml:space="preserve">
          <source>Test 20 random keys from the set of keys with an associated expire.</source>
          <target state="translated">관련 만료가있는 키 세트에서 임의의 키 20 개를 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="0c0c5f66ed89ad8b7f73f25128b137a4d67fcbb8" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; and the analogous &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; commands, you can use Redis strings as a linear array with O(1) random access. This is a very fast and efficient storage in many real world use cases.</source>
          <target state="translated">&lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; 및 유사한 &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; 명령 덕분에 Redis 문자열을 O (1) 랜덤 액세스를 사용하는 선형 배열로 사용할 수 있습니다. 이것은 많은 실제 사용 사례에서 매우 빠르고 효율적인 스토리지입니다.</target>
        </trans-unit>
        <trans-unit id="8026b8ed5921c819cac7c44288be64954a1b0af5" translate="yes" xml:space="preserve">
          <source>That is, the second occurrence of &quot;c&quot; is at position 6. A negative &quot;rank&quot; as the &lt;code&gt;RANK&lt;/code&gt; argument tells &lt;a href=&quot;lpos&quot;&gt;LPOS&lt;/a&gt; to invert the search direction, starting from the tail to the head.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733be8ce43bb740e68f58527c40732d288c9eb0b" translate="yes" xml:space="preserve">
          <source>That said, &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; can be used, and was historically used, as a locking primitive. For example, to acquire the lock of the key &lt;code&gt;foo&lt;/code&gt;, the client could try the following:</source>
          <target state="translated">즉, &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; 는 잠금 프리미티브로 사용할 수 있으며 역사적으로 사용되었습니다. 예를 들어, 키 &lt;code&gt;foo&lt;/code&gt; 의 잠금을 획득하기 위해 클라이언트는 다음을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0aa14a2afe89147b651f01c25f18c35b9adb8d8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;acl-help&quot;&gt;ACL HELP&lt;/a&gt; command returns a helpful text describing the different subcommands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77d6d135447dbf512e1ae2af8102405447c9f874" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; command can be used to create a very compact representation of a list of fixed-size samples, usually referred as &lt;em&gt;time series&lt;/em&gt;. Every time a new sample arrives we can store it using the command</source>
          <target state="translated">&lt;a href=&quot;append&quot;&gt;APPEND의&lt;/a&gt; 명령이 고정 크기 샘플에서 매우 컴팩트 표현을 생성하는 경우, 일반적으로 지칭 &lt;em&gt;시계열&lt;/em&gt; . 새로운 샘플이 도착할 때마다 다음 명령을 사용하여 저장할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="af3680004f1f3af89a74cfdd597524f1d5b57aa0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bitop&quot;&gt;BITOP&lt;/a&gt; command supports four bitwise operations: &lt;strong&gt;AND&lt;/strong&gt;, &lt;strong&gt;OR&lt;/strong&gt;, &lt;strong&gt;XOR&lt;/strong&gt; and &lt;strong&gt;NOT&lt;/strong&gt;, thus the valid forms to call the command are:</source>
          <target state="translated">&lt;a href=&quot;bitop&quot;&gt;BITOP의&lt;/a&gt; : 명령을 사 개 비트 연산을 지원 &lt;strong&gt;AND&lt;/strong&gt; , &lt;strong&gt;OR&lt;/strong&gt; , &lt;strong&gt;XOR을&lt;/strong&gt; 하고 &lt;strong&gt;NOT&lt;/strong&gt; 명령은 전화, 따라서 유효한 형태 :</target>
        </trans-unit>
        <trans-unit id="4dd66d959585425a19858f722e901be8748f987c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt; returns the name of the current connection as set by &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt;. Since every new connection starts without an associated name, if no name was assigned a null bulk reply is returned.</source>
          <target state="translated">&lt;a href=&quot;client-getname&quot;&gt;클라이언트 GETNAME는&lt;/a&gt; 에 의해 설정된 현재 연결의 이름을 반환 &lt;a href=&quot;client-setname&quot;&gt;클라이언트 SETNAME을&lt;/a&gt; . 모든 새 연결은 연관된 이름없이 시작되므로 이름이 지정되지 않은 경우 널 대량 응답이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1660d56ff9988d9b97b8e4b556121bfa1958f2dd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-kill&quot;&gt;CLIENT KILL&lt;/a&gt; command closes a given client connection. This command support two formats, the old format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77571e239b6c4924e5ae8625b133ece1b2fb165b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-kill&quot;&gt;CLIENT KILL&lt;/a&gt; command closes a given client connection. Up to Redis 2.8.11 it was possible to close a connection only by client address, using the following form:</source>
          <target state="translated">&lt;a href=&quot;client-kill&quot;&gt;클라이언트 KILL의&lt;/a&gt; 명령은 주어진 클라이언트 연결을 닫습니다. Redis 2.8.11까지는 다음 형식을 사용하여 클라이언트 주소로만 연결을 닫을 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="c0d7e72efd1901513aa26d76fc6efa880b0ffcd7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; command returns information and statistics about the client connections server in a mostly human readable format.</source>
          <target state="translated">&lt;a href=&quot;client-list&quot;&gt;클라이언트 목록&lt;/a&gt; 주로 사람이 읽을 수있는 형식으로 클라이언트 연결 서버에 대한 명령이 리턴 정보 및 통계.</target>
        </trans-unit>
        <trans-unit id="99ea497bab9ec2eb991df932e164aeadc0d98009" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-reply&quot;&gt;CLIENT REPLY&lt;/a&gt; command controls whether the server will reply the client's commands. The following modes are available:</source>
          <target state="translated">&lt;a href=&quot;client-reply&quot;&gt;클라이언트 REPLY의&lt;/a&gt; 명령 제어 서버는 클라이언트의 명령을 응답할지 여부를 지정합니다. 사용 가능한 모드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66ef05bc81ce96b58454a695580464830edc9445" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; command assigns a name to the current connection.</source>
          <target state="translated">&lt;a href=&quot;client-setname&quot;&gt;클라이언트 SETNAME의&lt;/a&gt; 명령은 현재 연결에 이름을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="43f3ab9bcc1ea0150ec08bf3548ed1a84c95f9e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-bumpepoch&quot;&gt;CLUSTER BUMPEPOCH&lt;/a&gt; command triggers an increment to the cluster's config epoch from the connected node. The epoch will be incremented if the node's config epoch is zero, or if it is less than the cluster's greatest epoch.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5540561e37398d0ed7b865d91ceff7a71f6377" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-flushslots&quot;&gt;CLUSTER FLUSHSLOTS&lt;/a&gt; deletes all information about slots from the connected node. It can only be called when the database is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ca5f595e917e610d79a666d6599f3f325569dcf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-myid&quot;&gt;CLUSTER MYID&lt;/a&gt; command returns the unique, auto-generated identifier that is associated with the connected cluster node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ca3ac0a9d2f6b99b3b3cfed122170d73c27a26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; command is an important piece used by Redis Cluster in order to migrate all the keys contained in one hash slot from one node to another. This is how the migration is orchestrated, with the help of other commands as well. We'll call the node that has the current ownership of the hash slot the &lt;code&gt;source&lt;/code&gt; node, and the node where we want to migrate the &lt;code&gt;destination&lt;/code&gt; node.</source>
          <target state="translated">&lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER의 SETSLOT의&lt;/a&gt; 명령은 하나 개의 노드에서 다른 하나 개의 해시 슬롯에 포함 된 모든 키를 마이그레이션하기 위해 레디 스 클러스터에서 사용되는 중요한 부분이다. 이것은 다른 명령의 도움으로 마이그레이션이 조정되는 방식입니다. 해시 슬롯의 현재 소유권이있는 노드를 &lt;code&gt;source&lt;/code&gt; 노드 및 &lt;code&gt;destination&lt;/code&gt; 노드 를 마이그레이션하려는 노드라고 합니다.</target>
        </trans-unit>
        <trans-unit id="9969254dbf9ad62d16ce54578a579c12bed90714" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; command is used to read the configuration parameters of a running Redis server. Not all the configuration parameters are supported in Redis 2.4, while Redis 2.6 can read the whole configuration of a server using this command.</source>
          <target state="translated">&lt;a href=&quot;config-get&quot;&gt;구성 GET의&lt;/a&gt; 명령은 실행 레디 스 서버의 구성 매개 변수를 읽는 데 사용됩니다. Redis 2.4에서는 모든 구성 매개 변수가 지원되는 것은 아니지만 Redis 2.6은이 명령을 사용하여 서버의 전체 구성을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b44e010365af8a822e0e64c895b3b9356396e69b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-rewrite&quot;&gt;CONFIG REWRITE&lt;/a&gt; command rewrites the &lt;code&gt;redis.conf&lt;/code&gt; file the server was started with, applying the minimal changes needed to make it reflect the configuration currently used by the server, which may be different compared to the original one because of the use of the &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;config-rewrite&quot;&gt;CONFIG 재 작성&lt;/a&gt; 명령은 재 작성 &lt;code&gt;redis.conf&lt;/code&gt; 의 때문에 사용의 원래에 비해 다를 수는 현재 서버에서 사용하는 구성을 반영하기 위해 필요한 최소한의 변경, 적용, 서버가 시작 된 파일을 &lt;a href=&quot;config-set&quot;&gt;CONFIG SET를&lt;/a&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="a94ff0d50f7b4db45f039a4dafafa3f4c9259a89" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command is used in order to reconfigure the server at run time without the need to restart Redis. You can change both trivial parameters or switch from one to another persistence option using this command.</source>
          <target state="translated">&lt;a href=&quot;config-set&quot;&gt;CONFIG SET의&lt;/a&gt; 명령은 레디 스를 재시작 할 필요없이 실행시에 서버를 다시 구성하기 위해 사용된다. 이 명령을 사용하여 사소한 매개 변수를 모두 변경하거나 하나에서 다른 지속성 옵션으로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="166c68e394d8ab06f1a3bb76f56f32a612a6683d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command forces you to send the script body again and again. Redis does not need to recompile the script every time as it uses an internal caching mechanism, however paying the cost of the additional bandwidth may not be optimal in many contexts.</source>
          <target state="translated">&lt;a href=&quot;eval&quot;&gt;EVAL의&lt;/a&gt; 명령을 강제로 다시 다시 스크립트 본문을 보낼 수 있습니다. Redis는 내부 캐싱 메커니즘을 사용할 때마다 스크립트를 다시 컴파일하지 않아도되지만 추가 대역폭 비용을 지불하는 것이 많은 상황에서 최적이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd6411fae08a91e9b321232ed876a3d9070cad9b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; family of commands is able to associate an expire to a given key, at the cost of some additional memory used by the key. When a key has an expire set, Redis will make sure to remove the key when the specified amount of time elapsed.</source>
          <target state="translated">&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; 명령의 가족은 키에 의해 사용되는 몇 가지 추가 메모리의 비용으로, 주어진 키에 만료에 연결할 수 있습니다. 키에 만료 설정이 있으면 Redis는 지정된 시간이 경과하면 키를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="9537af381c721635428a198bca98f65d00f50bfa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command has a useful reply that will state a number of facts about the server: the exact version, the set of modules loaded, the client ID, the replication role and so forth. Because of that, and given that the &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt; command also works with &quot;2&quot; as argument, both in order to downgrade the protocol back to version 2, or just to get the reply from the server without switching the protocol, client library authors may consider using this command instead of the canonical &lt;a href=&quot;ping&quot;&gt;PING&lt;/a&gt; when setting up the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae44c019fde6841c16a68c04d38047f2e0f60739" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command returns information and statistics about the server in a format that is simple to parse by computers and easy to read by humans.</source>
          <target state="translated">&lt;a href=&quot;info&quot;&gt;정보&lt;/a&gt; 컴퓨터에 의해 분석 간단하고 인간이 읽기 쉬운 형식으로 서버에 대한 명령이 리턴 정보 및 통계.</target>
        </trans-unit>
        <trans-unit id="a72bec6083e79854302b4e9ff14a0e8f3e859562" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-doctor&quot;&gt;LATENCY DOCTOR&lt;/a&gt; command reports about different latency-related issues and advises about possible remedies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1066b09a9b25b6b6ed879ca10e517428a219419a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-help&quot;&gt;LATENCY HELP&lt;/a&gt; command returns a helpful text describing the different subcommands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50807ff2bf2c847fd5988e426fdf8c05c9a36546" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-history&quot;&gt;LATENCY HISTORY&lt;/a&gt; command returns the raw data of the &lt;code&gt;event&lt;/code&gt;'s latency spikes time series.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52c78093ad61fe69ebb2499c714e0f2256697635" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-latest&quot;&gt;LATENCY LATEST&lt;/a&gt; command reports the latest latency events logged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147880a1d1ea91581373c0559cd3dfedfc864e5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;latency-reset&quot;&gt;LATENCY RESET&lt;/a&gt; command resets the latency spikes time series of all, or only some, events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c3a5fba12b1ed2508a72f81c29ed6c56b41d88" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-doctor&quot;&gt;MEMORY DOCTOR&lt;/a&gt; command reports about different memory-related issues that the Redis server experiences, and advises about possible remedies.</source>
          <target state="translated">&lt;a href=&quot;memory-doctor&quot;&gt;MEMORY 의사&lt;/a&gt; 서로 다른 메모리 관련 문제에 대한 명령 보고서는 레디 스 서버의 경험 및 가능한 해결 방법에 대해 조언 것이다.</target>
        </trans-unit>
        <trans-unit id="09f518db007c555b3fc51849cb715d5f37978149" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-help&quot;&gt;MEMORY HELP&lt;/a&gt; command returns a helpful text describing the different subcommands.</source>
          <target state="translated">&lt;a href=&quot;memory-help&quot;&gt;MEMORY 도움말&lt;/a&gt; 명령은 다른 부속 명령을 설명하는 유용한 텍스트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ff16e624359e33f1f97dfa1a1d20188c59460b7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-malloc-stats&quot;&gt;MEMORY MALLOC-STATS&lt;/a&gt; command provides an internal statistics report from the memory allocator.</source>
          <target state="translated">&lt;a href=&quot;memory-malloc-stats&quot;&gt;MEMORY MALLOC-통계&lt;/a&gt; 명령은 내부 통계는 메모리 할당에서보고 있습니다.</target>
        </trans-unit>
        <trans-unit id="abed28f03c444a07fa9a013ee06dd6217f071068" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-purge&quot;&gt;MEMORY PURGE&lt;/a&gt; command attempts to purge dirty pages so these can be reclaimed by the allocator.</source>
          <target state="translated">&lt;a href=&quot;memory-purge&quot;&gt;MEMORY 퍼지&lt;/a&gt; 이 너무 퍼지 더러운 페이지에 명령 시도는 할당 회수 할 수있다.</target>
        </trans-unit>
        <trans-unit id="6661981989e0edd2ff7e2bf5fdb3e79066d8b8f3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-stats&quot;&gt;MEMORY STATS&lt;/a&gt; command returns an &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; about the memory usage of the server.</source>
          <target state="translated">&lt;a href=&quot;memory-stats&quot;&gt;MEMORY 통계&lt;/a&gt; 명령은 반환 &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; 서버의 메모리 사용에 대한합니다.</target>
        </trans-unit>
        <trans-unit id="753fff2843cf4f675766fb16f94fa6b171989202" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;memory-usage&quot;&gt;MEMORY USAGE&lt;/a&gt; command reports the number of bytes that a key and its value require to be stored in RAM.</source>
          <target state="translated">&lt;a href=&quot;memory-usage&quot;&gt;메모리 사용&lt;/a&gt; 명령은 키와 값이 RAM에 저장 요구하는 바이트 수를보고합니다.</target>
        </trans-unit>
        <trans-unit id="2af70a6f2971f44c0c1aa28591f8b6524acbcca6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command allows to inspect the internals of Redis Objects associated with keys. It is useful for debugging or to understand if your keys are using the specially encoded data types to save space. Your application may also use the information reported by the &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command to implement application level key eviction policies when using Redis as a Cache.</source>
          <target state="translated">&lt;a href=&quot;object&quot;&gt;OBJECT의&lt;/a&gt; 명령은 키와 관련된 레디 스 개체의 내부를 검사 할 수 있습니다. 공간을 절약하기 위해 키가 특수하게 인코딩 된 데이터 형식을 사용하는지 디버깅하거나 이해하는 데 유용합니다. 애플리케이션은 Redis를 캐시로 사용할 때 &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; 명령이 보고 한 정보를 사용하여 애플리케이션 레벨 키 제거 정책을 구현할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eea48beebb7220fe5ecc2f8e71ddc8ce2e90d62c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; command supports multiple sub commands:</source>
          <target state="translated">&lt;a href=&quot;object&quot;&gt;OBJECT의&lt;/a&gt; 명령은 여러 하위 명령을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="ca3cc9ef5973b2b3ef21bdff9c9e13b41c03044f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;psync&quot;&gt;PSYNC&lt;/a&gt; command is called by Redis replicas for initiating a replication stream from the master.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bc73cb913e243c94705a7071cd05dd7f69ae35a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; command can change the replication settings of a replica on the fly.</source>
          <target state="translated">&lt;a href=&quot;replicaof&quot;&gt;REPLICAOF의&lt;/a&gt; 명령은 즉시 복제의 복제 설정을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ce9249bde2a45fd1e0f497151a2d69b16bbda13" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;rpushx&quot;&gt;RPUSHX&lt;/a&gt; command only pushes the element if the key already exists.</source>
          <target state="translated">&lt;a href=&quot;rpushx&quot;&gt;RPUSHX의&lt;/a&gt; 키가 이미 존재하는 경우 명령은 요소를 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="614a32f854070cdcbbba350287fb7c58ac067da4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; commands performs a &lt;strong&gt;synchronous&lt;/strong&gt; save of the dataset producing a &lt;em&gt;point in time&lt;/em&gt; snapshot of all the data inside the Redis instance, in the form of an RDB file.</source>
          <target state="translated">&lt;a href=&quot;save&quot;&gt;저장&lt;/a&gt; 행한다에게 명령 &lt;strong&gt;동기를&lt;/strong&gt; 제조 데이터 세트의 저장 &lt;em&gt;시간에 포인트&lt;/em&gt; RDB에 파일의 형태에서, 레디 스 인스턴스 내부 데이터 모두의 스냅 샷.</target>
        </trans-unit>
        <trans-unit id="67466c1875af0bcc544ed2934fa216ebaf0fb8ec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; algorithm is guaranteed to terminate only if the size of the iterated collection remains bounded to a given maximum size, otherwise iterating a collection that always grows may result into &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; to never terminate a full iteration.</source>
          <target state="translated">&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 알고리즘은 주어진 최대 크기로 경계은 반복되는 수집 유물의 크기, 그렇지 않으면 항상 성장이로 발생할 수있는 컬렉션을 반복하는 경우에만 종료 보장 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 전체 반복을 종료하지에 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b83fdceccccced73f803ea3fe0587ccedbc5d43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command and the closely related commands &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; are used in order to incrementally iterate over a collection of elements.</source>
          <target state="translated">&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 명령과 밀접한 관련 명령 &lt;a href=&quot;sscan&quot;&gt;sscan을&lt;/a&gt; , &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; 및 &lt;a href=&quot;zscan&quot;&gt;ZSCAN는&lt;/a&gt; 요소들의 집합을 통해 점진적으로 반복하기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="debbeaf11369c9e161ae3c316731408d752cc02f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command, and the other commands in the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family, are able to provide to the user a set of guarantees associated to full iterations.</source>
          <target state="translated">&lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 명령하고있는 다른 명령 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 제품군은 사용자에게 전체 반복에 관련된 보장의 집합을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1745a85b233cd9864512e1af6c727c0eb8686c05" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command supports a set of options that modify its behavior:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8bb1ffaa9cf08918dd7437412b9271325c4076a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; command can change the replication settings of a replica on the fly. If a Redis server is already acting as replica, the command &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE will turn off the replication, turning the Redis server into a MASTER. In the proper form &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname port will make the server a replica of another server listening at the specified hostname and port.</source>
          <target state="translated">&lt;a href=&quot;slaveof&quot;&gt;SLAVEOF의&lt;/a&gt; 명령은 즉시 복제의 복제 설정을 변경할 수 있습니다. Redis 서버가 이미 복제본으로 작동하는 경우 &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE 명령 은 복제를 끄고 Redis 서버를 MASTER로 전환합니다. 올바른 형식의 &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; 호스트 이름 포트는 서버를 지정된 호스트 이름 및 포트에서 수신 대기하는 다른 서버의 복제본으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0ff4cdfae050eccc9a56820c72e2716bcf7a7f22" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sync&quot;&gt;SYNC&lt;/a&gt; command is called by Redis replicas for initiating a replication stream from the master. It has been replaced in newer versions of Redis by &lt;a href=&quot;psync&quot;&gt;PSYNC&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd3e1b27429bbc884368294b8f7962375860257e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time&quot;&gt;TIME&lt;/a&gt; command returns the current server time as a two items lists: a Unix timestamp and the amount of microseconds already elapsed in the current second. Basically the interface is very similar to the one of the &lt;code&gt;gettimeofday&lt;/code&gt; system call.</source>
          <target state="translated">&lt;a href=&quot;time&quot;&gt;시간의&lt;/a&gt; 유닉스 타임 스탬프 이미 현재 초 경과 마이크로의 양 : 명령은 두 항목의 목록과 같은 현재의 서버 시간을 반환합니다. 기본적으로 인터페이스는 &lt;code&gt;gettimeofday&lt;/code&gt; 시스템 호출 중 하나와 매우 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="70be0ca493bf011ad2206bbde68c46ec552ad130" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command removes one or multiple messages from the &lt;em&gt;pending entries list&lt;/em&gt; (PEL) of a stream consumer group. A message is pending, and as such stored inside the PEL, when it was delivered to some consumer, normally as a side effect of calling &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;, or when a consumer took ownership of a message calling &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;. The pending message was delivered to some consumer but the server is yet not sure it was processed at least once. So new calls to &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; to grab the messages history for a consumer (for instance using an ID of 0), will return such message. Similarly the pending message will be listed by the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command, that inspects the PEL.</source>
          <target state="translated">&lt;a href=&quot;xack&quot;&gt;XACK의&lt;/a&gt; 명령은 하나 또는 여러 개의 메시지 삭제 &lt;em&gt;보류 항목 목록&lt;/em&gt; 스트림 소비자 그룹 (PEL)을. 메시지가 보류 중이며 PEL 내부에 저장되어 메시지가 일부 소비자에게 전달 될 때 (보통 &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; 호출의 부작용으로 ) 또는 소비자가 &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; 호출 메시지의 소유권을 가질 때 . 보류중인 메시지가 일부 소비자에게 전달되었지만 서버가 아직 한 번 이상 처리되었는지 확실하지 않습니다. 따라서 &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP에&lt;/a&gt; 대한 새로운 호출 은 소비자의 메시지 기록 (예 : ID 0)을 가져 와서 해당 메시지를 반환합니다. 마찬가지로 &lt;a href=&quot;xpending&quot;&gt;PEND&lt;/a&gt; 를 검사하는 XPENDING 명령으로 보류중인 메시지가 나열됩니다 .</target>
        </trans-unit>
        <trans-unit id="7dd37542831e217f80423791c1758b898b47cbcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command allows iterating over the pending entries just like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; and &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; allow for the stream's entries. You can do this by prefixing the ID of the last-read pending entry with the &lt;code&gt;(&lt;/code&gt; character that denotes an open (exclusive) range, and proving it to the subsequent call to the command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f919fa1bdb0a477435ee790e9628136dda8f63ea" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command is the interface to inspect the list of pending messages, and is as thus a very important command in order to observe and understand what is happening with a streams consumer groups: what clients are active, what messages are pending to be consumed, or to see if there are idle messages. Moreover this command, together with &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; is used in order to implement recovering of consumers that are failing for a long time, and as a result certain messages are not processed: a different consumer can claim the message and continue. This is better explained in the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;streams intro&lt;/a&gt; and in the &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; command page, and is not covered here.</source>
          <target state="translated">&lt;a href=&quot;xpending&quot;&gt;XPENDING의&lt;/a&gt; 명령은 보류중인 메시지의 목록을 검사 할 수있는 인터페이스이며, 관찰과 소비자 그룹을 스트림에 무슨 일이 일어나고 있는지 이해하기 위해, 따라서 매우 중요한 명령과 같습니다 어떤 메시지 것은 소비하는 대기중인 활성 어떤 클라이언트, 유휴 메시지가 있는지 확인하십시오. 또한 &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; 과 함께이 명령 은 오랫동안 실패한 소비자의 복구를 구현하기 위해 사용 되므로 특정 메시지가 처리되지 않습니다. 다른 소비자가 메시지를 청구하고 계속할 수 있습니다. 이것은 &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;스트림 소개&lt;/a&gt; 와 &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; 명령 페이지 에서 더 잘 설명되며 여기에서는 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be7aa14ec80fad3a57ca56d203c2ac6e1198edd2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; command has a number of applications:</source>
          <target state="translated">&lt;a href=&quot;xrange&quot;&gt;XRANGE의&lt;/a&gt; 명령은 응용 프로그램을 가지고 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1033731d720ba1e5c57d34f9f982462de081667c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command is a special version of the &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; command with support for consumer groups. Probably you will have to understand the &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; command before reading this page will makes sense.</source>
          <target state="translated">&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP의&lt;/a&gt; 명령은 특별한 버전입니다 &lt;a href=&quot;xread&quot;&gt;XREAD의&lt;/a&gt; 소비자 단체를 지원하는 명령. 이 페이지를 읽기 전에 &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; 명령 을 이해해야 할 것 입니다.</target>
        </trans-unit>
        <trans-unit id="7ac305f70170c901011610af97e0bc42f712f0a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&lt;/code&gt; ID is effectively just exactly as specifying &lt;code&gt;0-0&lt;/code&gt;, while &lt;code&gt;+&lt;/code&gt; is equivalent to &lt;code&gt;18446744073709551615-18446744073709551615&lt;/code&gt;, however they are nicer to type.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; ID는 정확하게 지정하는 것과 같은 효과입니다 &lt;code&gt;0-0&lt;/code&gt; 하면서, &lt;code&gt;+&lt;/code&gt; 는 동일합니다 &lt;code&gt;18446744073709551615-18446744073709551615&lt;/code&gt; 그러나 그들이 입력 할 좋네요.</target>
        </trans-unit>
        <trans-unit id="ad556b3da4050d845b9c3a874361828db5c442a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt; special IDs mean respectively the minimum ID possible and the maximum ID possible inside a stream, so the following command will just return every entry in the stream:</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 와 &lt;code&gt;+&lt;/code&gt; 다음 명령을 그냥 스트림의 모든 항목을 반환합니다 있도록 특별한 ID는 각각 가능한 최소의 ID와 스트림 내부 가능한 최대의 ID를 의미한다 :</target>
        </trans-unit>
        <trans-unit id="7b7c72e7ac11e971e25ca474ee3da37e97621a8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BY&lt;/code&gt; option can also take a non-existent key, which causes &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; to skip the sorting operation. This is useful if you want to retrieve external keys (see the &lt;code&gt;GET&lt;/code&gt; option below) without the overhead of sorting.</source>
          <target state="translated">&lt;code&gt;BY&lt;/code&gt; 의 옵션은 원인이 존재하지 않는 키를 취할 수 &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; 정렬 작업을 건너 뛸 수 있습니다. 정렬 오버 헤드없이 외부 키를 검색하려는 경우 (아래의 &lt;code&gt;GET&lt;/code&gt; 옵션 참조)에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="04d5c46b7c9e4c0432ac2f85c4c63dc2b3333abd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BY&lt;/code&gt; option takes a pattern (equal to &lt;code&gt;weight_*&lt;/code&gt; in this example) that is used to generate the keys that are used for sorting. These key names are obtained substituting the first occurrence of &lt;code&gt;*&lt;/code&gt; with the actual value of the element in the list (&lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; in this example).</source>
          <target state="translated">&lt;code&gt;BY&lt;/code&gt; 의 옵션 (동일한 패턴 얻어 &lt;code&gt;weight_*&lt;/code&gt; 정렬에 사용되는 키를 생성하는 데 사용되는이 예에서). 이 키 이름은 목록에서 요소의 실제 값 ( 이 예에서는 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 및 &lt;code&gt;3&lt;/code&gt; ) 으로 &lt;code&gt;*&lt;/code&gt; 의 첫 번째 항목을 대체하여 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="bd7cf93ba7657f4f2966769280d74bac3ba29a14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;COUNT&lt;/code&gt; option is used to limit the amount of stream/PEL entries that are returned (The first &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; entries are returned). The default &lt;code&gt;COUNT&lt;/code&gt; is 10 and a &lt;code&gt;COUNT&lt;/code&gt; of 0 means that all entries will be returned (Execution time may be long if the stream has a lot of entries)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7781d414a168c2c6071c960ca2a2f476d429921c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DELSLOTS&lt;/code&gt; command asks a particular Redis Cluster node to forget which master is serving the hash slots specified as arguments.</source>
          <target state="translated">&lt;code&gt;DELSLOTS&lt;/code&gt; 의 명령은 인수로 지정된 해시 슬롯을 제공하는 마스터 잊지 특정 레디 스 클러스터 노드를 요청합니다.</target>
        </trans-unit>
        <trans-unit id="f40cf7905426fe2efaf1d7bb82912ca46b5d481b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GET&lt;/code&gt; option can be used multiple times in order to get more keys for every element of the original list, set or sorted set.</source>
          <target state="translated">&lt;code&gt;GET&lt;/code&gt; 의 옵션은 원본 목록, 세트 또는 소트 세트의 모든 요소에 대한 더 많은 키를 얻기 위해 여러 번 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2200d7bc7ff4797c7f7c14add0d36376defba47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ID&lt;/code&gt; filter only returns entries for clients with IDs matching the &lt;code&gt;client-id&lt;/code&gt; arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="692cd27ca778c52fb164170863c312f93a4febd5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NOACK&lt;/code&gt; subcommand can be used to avoid adding the message to the PEL in cases where reliability is not a requirement and the occasional message loss is acceptable. This is equivalent to acknowledging the message when it is read.</source>
          <target state="translated">&lt;code&gt;NOACK&lt;/code&gt; 의 부속은 신뢰성이 요구되지 않고 가끔 메시지 손실이 허용되는 경우에 여기서 PEL에 메시지를 추가 회피 할 수있다. 이것은 메시지를 읽을 때 확인하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="70ae9c69379861ae43b186cc1aea347b195c9116" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NODE&lt;/code&gt; subcommand is the one with the most complex semantics. It associates the hash slot with the specified node, however the command works only in specific situations and has different side effects depending on the slot state. The following is the set of pre-conditions and side effects of the command:</source>
          <target state="translated">&lt;code&gt;NODE&lt;/code&gt; 의 부속 명령은 가장 복잡한 의미를 가진 하나입니다. 해시 슬롯을 지정된 노드와 연결하지만 명령은 특정 상황에서만 작동하며 슬롯 상태에 따라 다른 부작용이 있습니다. 다음은 명령의 사전 조건 및 부작용 세트입니다.</target>
        </trans-unit>
        <trans-unit id="f3353a302ef9a9215dfe9198dea9a7e8ef365e65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;aof_delayed_fsync&lt;/code&gt; counter</source>
          <target state="translated">&lt;code&gt;aof_delayed_fsync&lt;/code&gt; 카운터</target>
        </trans-unit>
        <trans-unit id="8b5f4a6fffad95a3f4be7e216981db9fcd1d6fe3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;count&lt;/code&gt; argument is available since version 3.2.</source>
          <target state="translated">&lt;code&gt;count&lt;/code&gt; 인수는 버전 3.2부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ce90da51cb5b392562f97eba72b463845c11c4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ip:port&lt;/code&gt; should match a line returned by the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; command (&lt;code&gt;addr&lt;/code&gt; field).</source>
          <target state="translated">&lt;code&gt;ip:port&lt;/code&gt; 에 의해 반환 된 라인과 일치해야 &lt;a href=&quot;client-list&quot;&gt;클라이언트 목록의&lt;/a&gt; 명령 ( &lt;code&gt;addr&lt;/code&gt; 필드).</target>
        </trans-unit>
        <trans-unit id="5777eb84fcb1170d8747af88e5c07f98feb04ee9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;message&lt;/code&gt; argument is simply a string. Example:</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; 인수는 단순히 문자열입니다. 예:</target>
        </trans-unit>
        <trans-unit id="9ea110d8be26fa3611a695ea1e98f388ddefd010" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; arguments have the same meaning as described for &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;max&lt;/code&gt; 인수에 대해 기재된 것과 동일한 의미를 가지고 &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="109dd07703928b5f87b169ad0c30d69a49fafa5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; arguments have the same semantic as described for &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;max&lt;/code&gt; 기술 한 바와 같이 인수는 동일한 의미를 가지고 &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07c405abf8ce41269def6794789e4d59831e2dc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;score&lt;/code&gt; value should be the string representation of a numeric value, and accepts double precision floating point numbers. It is possible to provide a negative value to decrement the score.</source>
          <target state="translated">&lt;code&gt;score&lt;/code&gt; 값은 숫자 값의 문자열 표현, 그리고 부동 소수점 숫자를 배정 밀도를 허용한다. 점수를 낮추기 위해 음수 값을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4192359597f0ce567f180b8ce4e1911ba0a4fee7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument is interpreted as a double value specifying the maximum number of seconds to block. A timeout of zero can be used to block indefinitely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7f5712887288aace7cb25c9ca1f98dbdf6c03f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument is interpreted as an double value specifying the maximum number of seconds to block. A timeout of zero can be used to block indefinitely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca4c3a5926b2e82699f6692683e7c60016ad3961" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument is interpreted as an integer value specifying the maximum number of seconds to block. A timeout of zero can be used to block indefinitely.</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 인수 차단하는 최대 시간 (초)을 나타내는 정수 값으로 해석된다. 시간 종료 0은 무기한 차단하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ad755fb1756745bfb0855cce9d6737683c771bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; argument is the same string name that the &lt;a href=&quot;type&quot;&gt;TYPE&lt;/a&gt; command returns. Note a quirk where some Redis types, such as GeoHashes, HyperLogLogs, Bitmaps, and Bitfields, may internally be implemented using other Redis types, such as a string or zset, so can't be distinguished from other keys of that same type by &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;. For example, a ZSET and GEOHASH:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b70e592aaa3d9e8f7df4a512dc479e926a2adbc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~&lt;/code&gt; argument between the &lt;strong&gt;MAXLEN&lt;/strong&gt; option and the actual count means that the user is not really requesting that the stream length is exactly 1000 items, but instead it could be a few tens of entries more, but never less than 1000 items. When this option modifier is used, the trimming is performed only when Redis is able to remove a whole macro node. This makes it much more efficient, and it is usually what you want.</source>
          <target state="translated">&lt;strong&gt;MAXLEN&lt;/strong&gt; 옵션과 실제 개수 사이 의 &lt;code&gt;~&lt;/code&gt; 인수 는 사용자가 실제로 스트림 길이가 정확히 1000 개 항목임을 요청하는 것이 아니라 수십 개 이상의 항목이 될 수 있지만 1000 개 이상의 항목이 될 수 있음을 의미합니다. 이 옵션 수정자를 사용하면 Redis가 전체 매크로 노드를 제거 할 수있는 경우에만 트리밍이 수행됩니다. 이것은 훨씬 더 효율적이며 일반적으로 원하는 것입니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ea8b5fbf2699e6884711237f84a50ed662e87dcb" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;STREAMS&lt;/strong&gt; option is mandatory and MUST be the final option because such option gets a variable length of argument in the following format:</source>
          <target state="translated">&lt;strong&gt;STREAMS의&lt;/strong&gt; 옵션은 필수이며 이러한 옵션은 다음과 같은 형식으로 인수의 변수 길이를 얻을 수 있기 때문에 마지막 옵션이어야한다 :</target>
        </trans-unit>
        <trans-unit id="f1467c9ba6d40cf52b5cdae46604d845510d3c66" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;TAKEOVER&lt;/strong&gt; option implies everything &lt;strong&gt;FORCE&lt;/strong&gt; implies, but also does not uses any cluster authorization in order to failover. A replica receiving &lt;code&gt;CLUSTER FAILOVER TAKEOVER&lt;/code&gt; will instead:</source>
          <target state="translated">&lt;strong&gt;인수&lt;/strong&gt; 옵션은 모든 것을 의미 &lt;strong&gt;FORCE는&lt;/strong&gt; 의미를,뿐만 아니라 장애 복구하기 위해 모든 클러스터 인증을 사용하지 않습니다. &lt;code&gt;CLUSTER FAILOVER TAKEOVER&lt;/code&gt; 를 수신하는 복제본 은 대신 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="706ee50ff413a981311879f38f0325b685e418ae" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;cluster&lt;/strong&gt; section currently only contains a unique field:</source>
          <target state="translated">&lt;strong&gt;클러스터&lt;/strong&gt; 섹션은 현재 고유 필드가 포함 :</target>
        </trans-unit>
        <trans-unit id="e18469751043e4051869a86bbcba03716b45e346" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;commandstats&lt;/strong&gt; section provides statistics based on the command type, including the number of calls, the total CPU time consumed by these commands, and the average CPU consumed per command execution.</source>
          <target state="translated">&lt;strong&gt;commandstats의&lt;/strong&gt; 섹션 호출 수,이 명령에 의해 소비되는 총 CPU 시간, 명령 실행에 따라 소비되는 평균 CPU를 포함하여 명령 유형에 따라 통계를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f90c39a55fa63248e76899e871ade6a1431c29d1" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;keyspace&lt;/strong&gt; section provides statistics on the main dictionary of each database. The statistics are the number of keys, and the number of keys with an expiration.</source>
          <target state="translated">&lt;strong&gt;키 스페이스의&lt;/strong&gt; 섹션은 각 데이터베이스의 기본 사전에 통계를 제공합니다. 통계는 키 수와 만료 된 키 수입니다.</target>
        </trans-unit>
        <trans-unit id="3a0202270041736b1216ba5baa1f54459be4f741" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;modules&lt;/strong&gt; section contains additional information about loaded modules if the modules provide it. The field part of properties lines in this section is always prefixed with the module's name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac8492c1e70ee526ecccc4abef734bddc537815" translate="yes" xml:space="preserve">
          <source>The AUTH command authenticates the current connection in two cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ff483a1ce1f770bdb2f62a76889e8f7ada78a73" translate="yes" xml:space="preserve">
          <source>The CJSON library provides extremely fast JSON manipulation within Lua.</source>
          <target state="translated">CJSON 라이브러리는 Lua 내에서 매우 빠른 JSON 조작을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7530389adb107898a8e0437c53cce50bad07ea36" translate="yes" xml:space="preserve">
          <source>The COUNT option</source>
          <target state="translated">COUNT 옵션</target>
        </trans-unit>
        <trans-unit id="e8dffa28f7261bfe8a1090fc2b6db1ae98bb313f" translate="yes" xml:space="preserve">
          <source>The HyperLogLog data structure can be used in order to count &lt;strong&gt;unique&lt;/strong&gt; elements in a set using just a small constant amount of memory, specifically 12k bytes for every HyperLogLog (plus a few bytes for the key itself).</source>
          <target state="translated">HyperLogLog 데이터 구조는 작은 일정한 양의 메모리, 특히 모든 HyperLogLog에 대해 12k 바이트 (키 자체의 경우 몇 바이트)를 사용하여 세트에서 &lt;strong&gt;고유 한&lt;/strong&gt; 요소 를 계산하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d5e9e7569c5ac826ef312fb92859c0deffb60e9" translate="yes" xml:space="preserve">
          <source>The HyperLogLog, being a Redis string, can be retrieved with &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; and restored with &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;. Calling &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;, &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; or &lt;a href=&quot;pfmerge&quot;&gt;PFMERGE&lt;/a&gt; commands with a corrupted HyperLogLog is never a problem, it may return random values but does not affect the stability of the server. Most of the times when corrupting a sparse representation, the server recognizes the corruption and returns an error.</source>
          <target state="translated">Redis 문자열 인 HyperLogLog는 &lt;a href=&quot;get&quot;&gt;GET을 사용&lt;/a&gt; 하여 검색 하고 &lt;a href=&quot;set&quot;&gt;SET을 사용&lt;/a&gt; 하여 복원 할 수 있습니다 . 손상된 HyperLogLog와 함께 &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; , &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; 또는 &lt;a href=&quot;pfmerge&quot;&gt;PFMERGE&lt;/a&gt; 명령을 호출 하는 것은 결코 문제가되지 않으며 임의의 값을 반환 할 수 있지만 서버의 안정성에는 영향을 미치지 않습니다. 스파 스 표현을 손상시킬 때 대부분의 경우 서버는 손상을 인식하고 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b9ffa717a680ea863704c9d4cbe178090dee5908" translate="yes" xml:space="preserve">
          <source>The ID is monotonically incremental. If the ID of a connection is greater than the ID of another connection, it is guaranteed that the second connection was established with the server at a later time.</source>
          <target state="translated">ID는 단조 증분입니다. 연결의 ID가 다른 연결의 ID보다 크면 나중에 서버와의 두 번째 연결이 설정되었음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="7f2d6cad55038bdb71cc5342903dad20539f48ed" translate="yes" xml:space="preserve">
          <source>The ID is never reset in the course of the Redis server execution, only a server restart will reset it.</source>
          <target state="translated">Redis 서버 실행 중에는 ID가 재설정되지 않으며 서버를 다시 시작하면 ID가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5028f5e06740630088beea552d56dbc9a9d96305" translate="yes" xml:space="preserve">
          <source>The ID of the last entry is &lt;code&gt;1526985685298-0&lt;/code&gt;, so we just add 1 to the sequence to obtain &lt;code&gt;1526985685298-1&lt;/code&gt;, and continue our iteration:</source>
          <target state="translated">마지막 항목의 ID는 &lt;code&gt;1526985685298-0&lt;/code&gt; 이므로 시퀀스에 1을 추가하여 &lt;code&gt;1526985685298-1&lt;/code&gt; 을 얻고 반복을 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="7eefbc13fad88639889dfca1eea5bd903a412b2f" translate="yes" xml:space="preserve">
          <source>The ID of the last entry is &lt;code&gt;1526985685298-0&lt;/code&gt;, so we just prefix it with a '(', and continue our iteration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfc0d85cea060a3580771bdafcea7e5bc90996bb" translate="yes" xml:space="preserve">
          <source>The ID of the message.</source>
          <target state="translated">메시지의 ID입니다.</target>
        </trans-unit>
        <trans-unit id="10ecce9f88d9ae56cb1bcd6efbec98fbc1a5f68e" translate="yes" xml:space="preserve">
          <source>The ID to specify in the &lt;strong&gt;STREAMS&lt;/strong&gt; option when using &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; can be one of the following two:</source>
          <target state="translated">&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP을&lt;/a&gt; 사용할 때 &lt;strong&gt;STREAMS&lt;/strong&gt; 옵션 에 지정할 ID 는 다음 두 가지 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5addd3dd6a1b78a37c68a12e4b0f086415a0b5b" translate="yes" xml:space="preserve">
          <source>The IP of the master.</source>
          <target state="translated">마스터의 IP</target>
        </trans-unit>
        <trans-unit id="5bcb92df23fdb05d8a0140fd9087b6b631c09793" translate="yes" xml:space="preserve">
          <source>The LCS subcommand implements the longest common subsequence algorithm. Note that this is different than the longest common string algorithm, since matching characters in the string does not need to be contiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e326a0ab79090e9945701455a9f67576780adbaf" translate="yes" xml:space="preserve">
          <source>The LOLWUT command displays the Redis version: however as a side effect of doing so, it also creates a piece of generative computer art that is different with each version of Redis. The command was introduced in Redis 5 and announced with this &lt;a href=&quot;http://antirez.com/news/123&quot;&gt;blog post&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f53ea350a50177374bcdd35f9332bb81e5298f0" translate="yes" xml:space="preserve">
          <source>The Lua Bit Operations Module adds bitwise operations on numbers. It is available for scripting in Redis since version 2.8.18.</source>
          <target state="translated">Lua 비트 연산 모듈은 숫자에 대한 비트 연산을 추가합니다. 버전 2.8.18부터 Redis에서 스크립팅에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1051d37718542a5598a286cc56e5f5aaafbf73d5" translate="yes" xml:space="preserve">
          <source>The Lua PRNG in this mode is seeded randomly at every call.</source>
          <target state="translated">이 모드의 Lua PRNG는 모든 통화에서 무작위로 시드됩니다.</target>
        </trans-unit>
        <trans-unit id="a8d85991ddfb0f169b9f806f86a3cc0413e31e4e" translate="yes" xml:space="preserve">
          <source>The Lua debugger is described in the &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Lua scripts debugging&lt;/a&gt; section of the Redis documentation.</source>
          <target state="translated">Lua 디버거는 Redis 설명서 의 &lt;a href=&quot;https://redis.io/topics/ldb&quot;&gt;Lua 스크립트 디버깅&lt;/a&gt; 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4515a3f12b04929b3987b1647823726616d895eb" translate="yes" xml:space="preserve">
          <source>The Lua engine always assumes to run in RESP2 mode when talking with Redis, so whatever the connection that is invoking the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; or &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; command is in RESP2 or RESP3 mode, Lua scripts will, by default, still see the same kind of replies they used to see in the past from Redis, when calling commands using the &lt;code&gt;redis.call()&lt;/code&gt; built-in function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a696a748eaeb904c163e6d11e4f1f007a0ef038" translate="yes" xml:space="preserve">
          <source>The MATCH option</source>
          <target state="translated">일치 옵션</target>
        </trans-unit>
        <trans-unit id="4eb0859176601ed31b0ed60fbf24deb7442f3423" translate="yes" xml:space="preserve">
          <source>The PUBSUB command is an introspection command that allows to inspect the state of the Pub/Sub subsystem. It is composed of subcommands that are documented separately. The general form is:</source>
          <target state="translated">PUBSUB 명령은 Pub / Sub 하위 시스템의 상태를 검사 할 수있는 내부 검사 명령입니다. 별도로 문서화 된 하위 명령으로 구성됩니다. 일반적인 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82e7a6dd485996953664282bec28fa4f1043afe7" translate="yes" xml:space="preserve">
          <source>The Redis Lua interpreter loads the following Lua libraries:</source>
          <target state="translated">Redis Lua 인터프리터는 다음 Lua 라이브러리를로드합니다.</target>
        </trans-unit>
        <trans-unit id="bb0c5eade03c486c5f8281c1da8633f26a4b714d" translate="yes" xml:space="preserve">
          <source>The Redis Slow Log is a system to log queries that exceeded a specified execution time. The execution time does not include I/O operations like talking with the client, sending the reply and so forth, but just the time needed to actually execute the command (this is the only stage of command execution where the thread is blocked and can not serve other requests in the meantime).</source>
          <target state="translated">Redis Slow Log는 지정된 실행 시간을 초과 한 쿼리를 기록하는 시스템입니다. 실행 시간에는 클라이언트와의 대화, 응답 전송 등과 같은 I / O 작업은 포함되지 않지만 실제로 명령을 실행하는 데 필요한 시간 만 포함됩니다 (스레드가 차단되어 실행할 수없는 유일한 명령 실행 단계 임) 그 동안 다른 요청을 처리하십시오).</target>
        </trans-unit>
        <trans-unit id="63b3dcb2e93d3c4b06fb3ccd03dd7de69fb04d43" translate="yes" xml:space="preserve">
          <source>The SCRIPT command</source>
          <target state="translated">SCRIPT 명령</target>
        </trans-unit>
        <trans-unit id="7b0199097175bc8f260d469794e2e96bed7dab06" translate="yes" xml:space="preserve">
          <source>The STRALGO implements complex algorithms that operate on strings. Right now the only algorithm implemented is the LCS algorithm (longest common substring). However new algorithms could be implemented in the future. The goal of this command is to provide to Redis users algorithms that need fast implementations and are normally not provided in the standard library of most programming languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a04ad115145f4340fd6a7e75d3c008104af8a7d2" translate="yes" xml:space="preserve">
          <source>The TYPE option</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f9be29f5758f4e3311e10dd99d11effd38e89f6" translate="yes" xml:space="preserve">
          <source>The ability to see all the requests processed by the server is useful in order to spot bugs in an application both when using Redis as a database and as a distributed caching system.</source>
          <target state="translated">Redis를 데이터베이스 및 분산 캐싱 시스템으로 사용할 때 서버에서 처리 된 모든 요청을 볼 수있는 기능은 애플리케이션에서 버그를 발견하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a9a4c4b85d74e390cf97f77d86569a9c392136a7" translate="yes" xml:space="preserve">
          <source>The above command will create a user called &lt;code&gt;virginia&lt;/code&gt; that is active (the on rule), can access any key (allkeys rule), and can call the set command (+set rule). Then another SETUSER call can modify the user rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f195a8757b1d8a55a19d37ee9ad3a22c5c0a4e17" translate="yes" xml:space="preserve">
          <source>The above makes it very simple to implement a system where a set of items must be processed by N workers continuously as fast as possible. An example is a monitoring system that must check that a set of web sites are reachable, with the smallest delay possible, using a number of parallel workers.</source>
          <target state="translated">위와 같이하면 N 작업자가 가능한 한 빠르게 일련의 항목을 처리해야하는 시스템을 구현하는 것이 매우 간단합니다. 예를 들어 모니터링 시스템은 여러 병렬 작업자를 사용하여 가능한 최소한의 지연으로 일련의 웹 사이트에 도달 할 수 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="75a3a44602ce55e23d207b895b5a485f6d4a2fc0" translate="yes" xml:space="preserve">
          <source>The above pattern works even if the following two conditions:</source>
          <target state="translated">위의 패턴은 다음 두 가지 조건에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="27a55611f4365743e826db0b0f9378c4a66a4f67" translate="yes" xml:space="preserve">
          <source>The above rule will not apply the new rule to the user virginia, so other than &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;, the user virginia will now be able to also use the &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; command.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d153745d60911da280f1df79b2e372158711e77" translate="yes" xml:space="preserve">
          <source>The above script sets the key &lt;code&gt;foo&lt;/code&gt; to the string &lt;code&gt;bar&lt;/code&gt;. However it violates the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command semantics as all the keys that the script uses should be passed using the &lt;code&gt;KEYS&lt;/code&gt; array:</source>
          <target state="translated">위의 스크립트는 &lt;code&gt;foo&lt;/code&gt; 키 를 문자열 &lt;code&gt;bar&lt;/code&gt; 로 설정합니다 . 그러나 스크립트가 사용하는 모든 키가 &lt;code&gt;KEYS&lt;/code&gt; 배열을 사용하여 전달되어야하기 때문에 &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 명령 시맨틱을 위반합니다 .</target>
        </trans-unit>
        <trans-unit id="0dd21e93f4a7ab544f682629858a1ca7196710f4" translate="yes" xml:space="preserve">
          <source>The additional elements of the array depends on the role.</source>
          <target state="translated">배열의 추가 요소는 역할에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b4c1764b30cb0625e6c253a27bb41e84ea603d9e" translate="yes" xml:space="preserve">
          <source>The algorithm used, that is implemented inside dict.c, samples the hash table buckets to find a non-empty one. Once a non empty bucket is found, since we use chaining in our hash table implementation, the number of elements inside the bucket is checked and a random element is selected.</source>
          <target state="translated">사용 된 알고리즘 (dict.c 내에 구현 됨)은 비어 있지 않은 것을 찾기 위해 해시 테이블 버킷을 샘플링합니다. 비어 있지 않은 버킷이 발견되면 해시 테이블 구현에서 체인을 사용하므로 버킷 내부의 요소 수를 확인하고 임의의 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6de2e476596fcaba51a4ddd43e2a8bd4d48c346f" translate="yes" xml:space="preserve">
          <source>The amount of data received from the replica so far in terms of master replication offset.</source>
          <target state="translated">마스터 복제 오프셋과 관련하여 지금까지 복제본에서 수신 한 데이터의 양입니다.</target>
        </trans-unit>
        <trans-unit id="5d8b8009ef4dd06c8c025f1eed58b5b1787f1f48" translate="yes" xml:space="preserve">
          <source>The amount of time needed for its execution, in microseconds.</source>
          <target state="translated">실행에 필요한 시간 (마이크로 초)</target>
        </trans-unit>
        <trans-unit id="e5407b8706df1e8319a7a989bf68d7ad75911c3a" translate="yes" xml:space="preserve">
          <source>The approximated number of unique elements observed via &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; 를 통해 관찰 된 고유 한 요소의 대략적인 수입니다 .</target>
        </trans-unit>
        <trans-unit id="5d3457f0c58f45dac774e34be45c19b72f462db2" translate="yes" xml:space="preserve">
          <source>The arguments of the &lt;code&gt;redis.call()&lt;/code&gt; and &lt;code&gt;redis.pcall()&lt;/code&gt; functions are all the arguments of a well formed Redis command:</source>
          <target state="translated">의 인수 &lt;code&gt;redis.call()&lt;/code&gt; 및 &lt;code&gt;redis.pcall()&lt;/code&gt; 함수는 모두 잘 형성 레디 스 명령의 인수입니다 :</target>
        </trans-unit>
        <trans-unit id="120865be87c8e6ca3cb347b65ffdefe018090581" translate="yes" xml:space="preserve">
          <source>The array composing the arguments of the command.</source>
          <target state="translated">명령의 인수를 구성하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="a010440d8c2596df424c379b3133bfd83782f2d9" translate="yes" xml:space="preserve">
          <source>The assigned name is displayed in the output of &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; so that it is possible to identify the client that performed a given connection.</source>
          <target state="translated">지정된 이름은 &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; 의 출력에 표시 되므로 지정된 연결을 수행 한 클라이언트를 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="885f9339188f139f7b1172052e203973f59a224e" translate="yes" xml:space="preserve">
          <source>The basic idea is that nodes by default don't trust each other, and are considered unknown, so that it is unlikely that different cluster nodes will mix into a single one because of system administration errors or network addresses modifications.</source>
          <target state="translated">기본 개념은 기본적으로 노드가 서로를 신뢰하지 않으며 알 수없는 것으로 간주되므로 시스템 관리 오류 또는 네트워크 주소 수정으로 인해 다른 클러스터 노드가 단일 노드로 혼합 될 가능성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="d3155ed9386ade27ef1929683ef41081fb15be86" translate="yes" xml:space="preserve">
          <source>The basic usage is the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da9c85f3c202fdd59f8f147e36c3ec1f770f703e" translate="yes" xml:space="preserve">
          <source>The behavior of Redis 2.4 creates a lot of problems when replicating or persisting data into the AOF file, so the much more generic and semantically simpler behavior was introduced into Redis 2.6 to prevent problems.</source>
          <target state="translated">Redis 2.4의 동작은 데이터를 AOF 파일로 복제하거나 유지할 때 많은 문제를 발생 시키므로 문제를 방지하기 위해 Redis 2.6에 훨씬 일반적이고 의미 적으로 간단한 동작이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="b344dc2bc04bb34933613eb7044804cab8c272df" translate="yes" xml:space="preserve">
          <source>The binary nature of the comparison allows to use sorted sets as a general purpose index, for example the first part of the element can be a 64 bit big endian number: since big endian numbers have the most significant bytes in the initial positions, the binary comparison will match the numerical comparison of the numbers. This can be used in order to implement range queries on 64 bit values. As in the example below, after the first 8 bytes we can store the value of the element we are actually indexing.</source>
          <target state="translated">비교의 이진 특성은 정렬 된 세트를 범용 인덱스로 사용할 수 있습니다. 예를 들어 요소의 첫 번째 부분은 64 비트 빅 엔디안 수일 수 있습니다. 빅 엔디안 번호는 초기 위치에서 가장 중요한 바이트를 가지므로 이진 비교는 숫자의 숫자 비교와 일치합니다. 64 비트 값에 대한 범위 쿼리를 구현하기 위해 사용할 수 있습니다. 아래 예에서와 같이 처음 8 바이트 후에 실제로 색인을 생성하는 요소의 값을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f19a05fbdb75f958bfa6f09541362b1de2c7798d" translate="yes" xml:space="preserve">
          <source>The bit is either set or cleared depending on &lt;em&gt;value&lt;/em&gt;, which can be either 0 or 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3282d877e14a9e1a4f618e1ae58563eb55cb394" translate="yes" xml:space="preserve">
          <source>The bit is either set or cleared depending on &lt;em&gt;value&lt;/em&gt;, which can be either 0 or 1. When &lt;em&gt;key&lt;/em&gt; does not exist, a new string value is created. The string is grown to make sure it can hold a bit at &lt;em&gt;offset&lt;/em&gt;. The &lt;em&gt;offset&lt;/em&gt; argument is required to be greater than or equal to 0, and smaller than 2&lt;sup&gt;32&lt;/sup&gt; (this limits bitmaps to 512MB). When the string at &lt;em&gt;key&lt;/em&gt; is grown, added bits are set to 0.</source>
          <target state="translated">&lt;em&gt;값&lt;/em&gt; 에 따라 비트가 설정 또는 해제 되며 0 또는 1 일 수 있습니다. &lt;em&gt;키&lt;/em&gt; 가 없으면 새 문자열 값이 작성됩니다. 문자열은 &lt;em&gt;오프셋&lt;/em&gt; 에서 비트를 유지할 수 있도록 확장 됩니다. &lt;em&gt;오프셋&lt;/em&gt; 인자는 0보다 크거나 동일해야하고,보다 작은 2 &lt;sup&gt;32&lt;/sup&gt; (제한이 비트 맵 512메가바이트)이다. &lt;em&gt;키&lt;/em&gt; 의 문자열 이 커지면 추가 된 비트가 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0b7af7df323735c0dce87d77fcd93c888e45e3a0" translate="yes" xml:space="preserve">
          <source>The client explicitly checks the &lt;code&gt;runid&lt;/code&gt; field in the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command in order to make sure the server was not restarted and is still the same process.</source>
          <target state="translated">클라이언트 는 서버가 다시 시작되지 않았으며 여전히 동일한 프로세스인지 확인하기 위해 &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 명령에서 &lt;code&gt;runid&lt;/code&gt; 필드를 명시 적으로 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="9350ca0340f5b792f129eec734a9c6029b8bad38" translate="yes" xml:space="preserve">
          <source>The client flags can be a combination of:</source>
          <target state="translated">클라이언트 플래그는 다음의 조합이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef7c4ea851346ff688f43804007664e07a0ee9aa" translate="yes" xml:space="preserve">
          <source>The client library implementation can always optimistically send &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; under the hood even when the client actually calls &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;, in the hope the script was already seen by the server. If the &lt;code&gt;NOSCRIPT&lt;/code&gt; error is returned &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; will be used instead.</source>
          <target state="translated">클라이언트 라이브러리 구현은 클라이언트가 실제로 &lt;a href=&quot;eval&quot;&gt;EVAL을&lt;/a&gt; 호출하더라도 서버에서 스크립트를 이미 보았 기 때문에 항상 &lt;a href=&quot;evalsha&quot;&gt;최적의&lt;/a&gt; 상태에서 EVALSHA를 최적 상태로 보낼 수 있습니다 . 는 IF &lt;code&gt;NOSCRIPT&lt;/code&gt; 의 오류가 반환됩니다 &lt;a href=&quot;eval&quot;&gt;EVAL이&lt;/a&gt; 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5dfcddce441b9e425d29945dfa151dd5838c9e0e" translate="yes" xml:space="preserve">
          <source>The client library implementation should take one of the following approaches:</source>
          <target state="translated">클라이언트 라이브러리 구현은 다음 방법 중 하나를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="cea5f73089ab49d55692f68c7533b954be4a4271" translate="yes" xml:space="preserve">
          <source>The client sent a command about hash slots never served by the master of this replica.</source>
          <target state="translated">클라이언트는이 복제본의 마스터가 제공하지 않은 해시 슬롯에 대한 명령을 보냈습니다.</target>
        </trans-unit>
        <trans-unit id="4f3cae0941780fdfb0d5aa096cbd40be72c4d373" translate="yes" xml:space="preserve">
          <source>The client will have to acknowledge the message processing using &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; in order for the pending entry to be removed from the PEL. The PEL can be inspected using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command.</source>
          <target state="translated">PEL에서 보류중인 항목을 제거하려면 클라이언트는 &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; 을 사용하여 메시지 처리를 승인해야합니다 . &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; 명령을 사용하여 PEL을 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82fd513f621c09ac0869a99d08b31390f0bc842b" translate="yes" xml:space="preserve">
          <source>The cluster was reconfigured (for example resharded) and the replica is no longer able to serve commands for a given hash slot.</source>
          <target state="translated">클러스터가 재구성 (예 : 리 샤딩)되었으며 복제본은 더 이상 지정된 해시 슬롯에 대한 명령을 제공 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9940f805fd9de379d7d0c58cd1b84f3338b5e58f" translate="yes" xml:space="preserve">
          <source>The cmsgpack library provides simple and fast MessagePack manipulation within Lua.</source>
          <target state="translated">cmsgpack 라이브러리는 Lua 내에서 간단하고 빠른 MessagePack 조작을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0b9bb30b2dbe12e3fa62af10a99007a2ae4848a9" translate="yes" xml:space="preserve">
          <source>The command &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; is also able to iterate the stream. The command &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; can iterate the stream reverse, from higher IDs (or times) to lower IDs (or times).</source>
          <target state="translated">&lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; 명령 은 스트림을 반복 할 수도 있습니다. &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; 명령 은 더 높은 ID (또는 시간)에서 더 낮은 ID (또는 시간)까지 스트림 역순을 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fbd17702a2c89af4ecc45167e7c6a7b02c943ed" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;SET resource-name anystring NX EX max-lock-time&lt;/code&gt; is a simple way to implement a locking system with Redis.</source>
          <target state="translated">명령 &lt;code&gt;SET resource-name anystring NX EX max-lock-time&lt;/code&gt; 레디 스에 잠금 시스템을 구현하는 간단한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="2dbda62e4a8fd31c5ca6fc1f4cddf22961ead108" translate="yes" xml:space="preserve">
          <source>The command &lt;strong&gt;will always return&lt;/strong&gt; the number of replicas that acknowledged the write commands sent before the &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; command, both in the case where the specified number of replicas are reached, or when the timeout is reached.</source>
          <target state="translated">명령 &lt;strong&gt;은&lt;/strong&gt; 지정된 수의 복제본에 도달 한 경우 또는 시간 종료에 도달 한 경우 &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; 명령 전에 전송 된 쓰기 명령을 승인 한 복제본 수를 &lt;strong&gt;항상 리턴&lt;/strong&gt; 합니다 .</target>
        </trans-unit>
        <trans-unit id="4a44b122481ff3652c96ef6533c739e783fe19c3" translate="yes" xml:space="preserve">
          <source>The command also has a reciprocal command returning items in the reverse order, called &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt;, which is otherwise identical.</source>
          <target state="translated">이 명령에는 또한 &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; 라고하는 역순으로 항목을 리턴하는 상호 명령이 있으며 , 그렇지 않으면 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b51d9780c5d61a87b53bd27d3ac5c24a4b0638d8" translate="yes" xml:space="preserve">
          <source>The command behavior can be modified by two options: &lt;strong&gt;FORCE&lt;/strong&gt; and &lt;strong&gt;TAKEOVER&lt;/strong&gt;.</source>
          <target state="translated">명령 동작은 &lt;strong&gt;FORCE&lt;/strong&gt; 및 &lt;strong&gt;TAKEOVER의&lt;/strong&gt; 두 가지 옵션으로 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e77b773bc1837b920cb41a24e1a0ef629792be6" translate="yes" xml:space="preserve">
          <source>The command behavior is the following:</source>
          <target state="translated">명령 동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="913ef9d1ec1890a263c7a3667b134a3de340bd38" translate="yes" xml:space="preserve">
          <source>The command can accept a variable number of arguments so it always returns an array of positions even when a single element is specified.</source>
          <target state="translated">이 명령은 가변 개수의 인수를 허용하므로 단일 요소가 지정된 경우에도 항상 위치 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b9a60a6fc9ab713863d0cdace7cfdb88da1428ea" translate="yes" xml:space="preserve">
          <source>The command can be called with four different arguments:</source>
          <target state="translated">이 명령은 4 가지 다른 인수로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2095dc05dd59018ca256f0a5fc566c35f0f4cc7" translate="yes" xml:space="preserve">
          <source>The command default is to return unsorted items. Two different sorting methods can be invoked using the following two options:</source>
          <target state="translated">명령 기본값은 정렬되지 않은 항목을 반환하는 것입니다. 다음 두 가지 옵션을 사용하여 서로 다른 두 가지 정렬 방법을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="958832c31d8e5542b245102310cbd53d9f34320f" translate="yes" xml:space="preserve">
          <source>The command does not succeed and returns an error in the following cases:</source>
          <target state="translated">다음과 같은 경우 명령이 실패하고 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="32a8711ea8a78a0226239432ccf720cba86e66af" translate="yes" xml:space="preserve">
          <source>The command fails if the same slot is specified multiple times.</source>
          <target state="translated">동일한 슬롯이 여러 번 지정된 경우 명령이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="b6f1f38c10e41d6cb188193c5859a8d2a04588ed" translate="yes" xml:space="preserve">
          <source>The command has multiple options, however most are mainly for internal use in order to transfer the effects of &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; or other commands to the AOF file and to propagate the same effects to the slaves, and are unlikely to be useful to normal users:</source>
          <target state="translated">이 명령에는 여러 옵션이 있지만 대부분 &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; 또는 기타 명령 의 효과를 AOF 파일 로 전송 하고 동일한 효과를 슬레이브에 전파 하기 위해 주로 내부 용으로 사용되며 일반 사용자에게는 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aff611203495e6eb730550d71c578dbd6ea9eaee" translate="yes" xml:space="preserve">
          <source>The command internally uses &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt; to generate the serialized version of the key value, and &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; in order to synthesize the key in the target instance. The source instance acts as a client for the target instance. If the target instance returns OK to the &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command, the source instance deletes the key using &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;.</source>
          <target state="translated">이 명령은 내부적으로 &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt; 를 사용 하여 키 값의 직렬화 된 버전을 생성 하고 대상 인스턴스에서 키를 합성하기 위해 &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; 를 사용합니다. 소스 인스턴스는 대상 인스턴스의 클라이언트 역할을합니다. 대상 인스턴스가 &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; 명령에 OK를 리턴 하면 소스 인스턴스는 &lt;a href=&quot;del&quot;&gt;DEL을&lt;/a&gt; 사용하여 키를 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="a8dc74da7f9aeeb2a318e48a6c60e1183a0da365" translate="yes" xml:space="preserve">
          <source>The command is always propagated in the replication link and the Append Only File as a &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; operation, so that differences in the underlying floating point math implementation will not be sources of inconsistency.</source>
          <target state="translated">명령은 항상 복제 링크 및 Append Only File에 &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; 작업 으로 전파 되므로 기본 부동 소수점 수학 구현의 차이가 불일치의 원인이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89297d1be1338bce5eaa89c5524f124377b2d8a5" translate="yes" xml:space="preserve">
          <source>The command is always propagated in the replication link and the Append Only File as a &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; operation, so that differences in the underlying floating point math implementation will not be sources of inconsistency.</source>
          <target state="translated">이 명령은 항상 복제 링크 및 Append Only File에 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 작업 으로 전파 되므로 기본 부동 소수점 수학 구현의 차이가 불일치의 원인이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a86933f06a2ba31db5ee212ee8cc903bc3c40f34" translate="yes" xml:space="preserve">
          <source>The command is atomic and blocks the two instances for the time required to transfer the key, at any given time the key will appear to exist in a given instance or in the other instance, unless a timeout error occurs. In 3.2 and above, multiple keys can be pipelined in a single call to &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; by passing the empty string (&quot;&quot;) as key and adding the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; clause.</source>
          <target state="translated">이 명령은 원 자성이며 ​​키를 전송하는 데 필요한 시간 동안 두 인스턴스를 차단합니다. 시간 초과 오류가 발생하지 않으면 주어진 시간에 키가 지정된 인스턴스 또는 다른 인스턴스에 존재하는 것처럼 보입니다. 3.2 이상에서는 빈 문자열 ( &quot;&quot;)을 키로 전달하고 &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; 절을 추가하여 &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; 에 대한 단일 호출에서 여러 키를 파이프 라인 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4335b586f31c83a0ae96d3ccf6ca0cfaf3a8429" translate="yes" xml:space="preserve">
          <source>The command is used in order to remove a node, specified via its node ID, from the set of &lt;em&gt;known nodes&lt;/em&gt; of the Redis Cluster node receiving the command. In other words the specified node is removed from the &lt;em&gt;nodes table&lt;/em&gt; of the node receiving the command.</source>
          <target state="translated">명령은 명령을 수신하는 Redis Cluster 노드 의 &lt;em&gt;알려진 노드&lt;/em&gt; 세트에서 노드 ID를 통해 지정된 노드를 제거하기 위해 사용됩니다 . 즉, 지정된 노드는 명령을 수신 한 노드 의 &lt;em&gt;노드 테이블&lt;/em&gt; 에서 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="9389c07b5be98086699ffdc71ab5655cfb6ab6aa" translate="yes" xml:space="preserve">
          <source>The command just returns the ID of the current connection. Every connection ID has certain guarantees:</source>
          <target state="translated">이 명령은 현재 연결의 ID를 반환합니다. 모든 연결 ID에는 다음과 같은 특정 보증이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e36a1bc65a56400c52d66e29f9ce1757bbf2e26" translate="yes" xml:space="preserve">
          <source>The command may fail with an error for several reasons: if the file cannot be written or if the server is not configured to use an external ACL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="344468f4b5f6d51949f0a2c14063fc0a3b852987" translate="yes" xml:space="preserve">
          <source>The command may fail with an error for several reasons: if the file is not readable, if there is an error inside the file, and in such case the error will be reported to the user in the error. Finally the command will fail if the server is not configured to use an external ACL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aa2b5549f1c670208cc851a7701050140450874" translate="yes" xml:space="preserve">
          <source>The command may reply with an error in certain cases, as documented above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0d0753b06a3754e2b6097d7df536fcb852c4ed" translate="yes" xml:space="preserve">
          <source>The command only works if all the specified slots are already associated with some node.</source>
          <target state="translated">지정된 모든 슬롯이 이미 일부 노드와 연관되어있는 경우에만 명령이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="43abdb47aec6d5ef3beb1e76ddc4c6370f0f6354" translate="yes" xml:space="preserve">
          <source>The command only works if all the specified slots are, from the point of view of the node receiving the command, currently not assigned. A node will refuse to take ownership for slots that already belong to some other node (including itself).</source>
          <target state="translated">명령은 지정된 모든 슬롯이 명령을 수신하는 노드의 관점에서 현재 지정되지 않은 경우에만 작동합니다. 노드는 이미 다른 노드 (자체 포함)에 속하는 슬롯에 대한 소유권을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="63f80c4f55dda4254e917500ebea54b888f88f18" translate="yes" xml:space="preserve">
          <source>The command optionally returns additional information using the following options:</source>
          <target state="translated">이 명령은 선택적으로 다음 옵션을 사용하여 추가 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94c796162b217920f7fda542eef1c135d9fe60f2" translate="yes" xml:space="preserve">
          <source>The command output is an hexadecimal representation of a binary string. By default it emits 256 bits (so 64 hex characters). The user can provide an argument in form of number of bits to emit from 1 to 1024 to change the output length. Note that the number of bits provided is always rounded to the next multiple of 4. So for instance asking for just 1 bit password will result in 4 bits to be emitted, in the form of a single hex character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11f65176db9808f7847abb3d37f52b1528a65ac2" translate="yes" xml:space="preserve">
          <source>The command performs the following actions:</source>
          <target state="translated">명령은 다음 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4778a65d0ba749aa47da2ae16d4895853e331c48" translate="yes" xml:space="preserve">
          <source>The command provides a list of replica nodes replicating from the specified master node. The list is provided in the same format used by &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; (please refer to its documentation for the specification of the format).</source>
          <target state="translated">이 명령은 지정된 마스터 노드에서 복제하는 복제본 노드 목록을 제공합니다. 이 목록은 &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES에서&lt;/a&gt; 사용하는 것과 동일한 형식으로 제공됩니다 (형식 사양은 해당 설명서를 참조하십시오).</target>
        </trans-unit>
        <trans-unit id="75946e7c075807ac0ec08889c9ae03a9a184e3d3" translate="yes" xml:space="preserve">
          <source>The command reconfigures a node as a replica of the specified master. If the node receiving the command is an &lt;em&gt;empty master&lt;/em&gt;, as a side effect of the command, the node role is changed from master to replica.</source>
          <target state="translated">이 명령은 노드를 지정된 마스터의 복제본으로 재구성합니다. 명령을 수신 한 노드가 &lt;em&gt;비어있는 마스터&lt;/em&gt; 인 경우 명령의 부작용으로 노드 역할이 마스터에서 복제본으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="4ebd54c736f27aa3986d5c357015059ce2df6b55" translate="yes" xml:space="preserve">
          <source>The command returns 11 characters Geohash strings, so no precision is loss compared to the Redis internal 52 bit representation. The returned Geohashes have the following properties:</source>
          <target state="translated">이 명령은 11 개의 Geohash 문자열을 반환하므로 Redis 내부 52 비트 표현에 비해 정밀도가 손실되지 않습니다. 반환 된 Geohash에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="68e0628c08bc7ef387bda65ff2fbb36117fe6040" translate="yes" xml:space="preserve">
          <source>The command returns &lt;code&gt;-1&lt;/code&gt; if the key exists but has no associated expire.</source>
          <target state="translated">키는 있지만 만료가없는 경우 명령은 &lt;code&gt;-1&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9900e726bbbfd1d7f718d4225bf8abc8e591a526" translate="yes" xml:space="preserve">
          <source>The command returns &lt;code&gt;-2&lt;/code&gt; if the key does not exist.</source>
          <target state="translated">키가 없으면 명령은 &lt;code&gt;-2&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="263f04bc6090861d15e393e44fe1a4d42bd2408e" translate="yes" xml:space="preserve">
          <source>The command returns a &lt;a href=&quot;https://redis.io/topics/protocol#nil-reply&quot;&gt;Null reply&lt;/a&gt; when used with the &lt;code&gt;NOMKSTREAM&lt;/code&gt; option and the key doesn't exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf3ff8b30b845ead44db4d82109c56f01457aed" translate="yes" xml:space="preserve">
          <source>The command returns all the messages successfully claimed, in the same format as &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;. However if the &lt;code&gt;JUSTID&lt;/code&gt; option was specified, only the message IDs are reported, without including the actual message.</source>
          <target state="translated">명령은 &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 와 동일한 형식으로 성공적으로 청구 된 모든 메시지를 리턴합니다 . 그러나 &lt;code&gt;JUSTID&lt;/code&gt; 옵션이 지정된 경우 실제 메시지를 포함하지 않고 메시지 ID 만보 고됩니다.</target>
        </trans-unit>
        <trans-unit id="d91929db6b639c8bbfadd32a8fc0bdbaccdfc27a" translate="yes" xml:space="preserve">
          <source>The command returns all the rules defined for an existing ACL user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a71cfae2a2b43a889c9e6bd259963281080b15" translate="yes" xml:space="preserve">
          <source>The command returns an array of elements. The first element is the role of the instance, as one of the following three strings:</source>
          <target state="translated">이 명령은 요소 배열을 반환합니다. 첫 번째 요소는 다음 세 문자열 중 하나 인 인스턴스의 역할입니다.</target>
        </trans-unit>
        <trans-unit id="aa91d91e133acc78d18bba2922ce5bd5a6f7f354" translate="yes" xml:space="preserve">
          <source>The command returns an array of keys names stored in the contacted node and hashing to the specified hash slot. The maximum number of keys to return is specified via the &lt;code&gt;count&lt;/code&gt; argument, so that it is possible for the user of this API to batch-processing keys.</source>
          <target state="translated">이 명령은 접속 된 노드에 저장된 키 이름 배열을 지정하고 지정된 해시 슬롯으로 해싱합니다. 리턴 할 최대 키 수는 &lt;code&gt;count&lt;/code&gt; 인수 를 통해 지정되므로이 API 사용자가 키를 일괄 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="e6bc3ec726a066c82649799db4b402b18c37620c" translate="yes" xml:space="preserve">
          <source>The command returns an array of results: each element of the returned array is an array composed of a two element containing the key name and the entries reported for that key. The entries reported are full stream entries, having IDs and the list of all the fields and values. Field and values are guaranteed to be reported in the same order they were added by &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt;.</source>
          <target state="translated">이 명령은 결과 배열을 반환합니다. 반환 된 배열의 각 요소는 키 이름과 해당 키에 대해보고 된 항목을 포함하는 두 요소로 구성된 배열입니다. 보고 된 항목은 전체 스트림 항목이며 ID와 모든 필드 및 값 목록이 있습니다. 필드와 값은 &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; 에서 추가 한 순서와 동일한 순서로보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="59dca4232b984a49106f20180ccd68dd85cde434" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is a four elements array representing the event's name, timestamp, latest and all-time latency measurements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59bdbda1d4276c59a205bc75690c8792da83930" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is a two elements array representing longitude and latitude (x,y) of each member name passed as argument to the command.</source>
          <target state="translated">명령은 각 요소가 명령에 인수로 전달 된 각 구성원 이름의 경도 및 위도 (x, y)를 나타내는 두 개의 요소 배열 인 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c2da6177dc0df5d03aa7780c4ae1b3e2b3b664b6" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is a two elements array representing the timestamp and the latency of the event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="299bd584711e094e5bb4f6fecbd5c79b634a792b" translate="yes" xml:space="preserve">
          <source>The command returns an array where each element is the Geohash corresponding to each member name passed as argument to the command.</source>
          <target state="translated">명령은 각 요소가 명령에 인수로 전달 된 각 멤버 이름에 해당하는 Geohash 인 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="63618225d498ac1d95054dac445c00eb7942b4b2" translate="yes" xml:space="preserve">
          <source>The command returns an array with each entry being the corresponding result of the sub command given at the same position. &lt;code&gt;OVERFLOW&lt;/code&gt; subcommands don't count as generating a reply.</source>
          <target state="translated">명령은 각 항목이 동일한 위치에 제공된 하위 명령의 해당 결과 인 배열을 반환합니다. &lt;code&gt;OVERFLOW&lt;/code&gt; 하위 명령은 응답 생성으로 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d3fdeb1c470e8f290735d9f570986e08dde9291" translate="yes" xml:space="preserve">
          <source>The command returns an error when the &lt;code&gt;destination&lt;/code&gt; key already exists. The &lt;code&gt;REPLACE&lt;/code&gt; option removes the &lt;code&gt;destination&lt;/code&gt; key before copying the value to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="599682f8e696ffcef9a41f128a35f008ec692b72" translate="yes" xml:space="preserve">
          <source>The command returns data in different format depending on the way it is called, as previously explained in this page. However the reply is always an array of items.</source>
          <target state="translated">이 명령은 이전에이 페이지에서 설명한대로 호출 방식에 따라 다른 형식으로 데이터를 반환합니다. 그러나 답장은 항상 항목의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="64555ea6ac3dd842f32e77db3528c6314f55ca4d" translate="yes" xml:space="preserve">
          <source>The command returns data in the same format as &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;.</source>
          <target state="translated">명령은 &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; 와 동일한 형식으로 데이터를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f11ff6c087b294c263c888936947fb519a703574" translate="yes" xml:space="preserve">
          <source>The command returns information about the current client connection's use of the &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;server assisted client side caching&lt;/a&gt; feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a84d7525c4b51e3bbe67ae31259831e14b15be40" translate="yes" xml:space="preserve">
          <source>The command returns information and statistics about the current client connection in a mostly human readable format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="854de1e7ab31a436fe3503c72376101ec2883922" translate="yes" xml:space="preserve">
          <source>The command returns the ID of the added entry. The ID is the one auto-generated if &lt;code&gt;*&lt;/code&gt; is passed as ID argument, otherwise the command just returns the same ID specified by the user during insertion.</source>
          <target state="translated">이 명령은 추가 된 항목의 ID를 반환합니다. ID가 &lt;code&gt;*&lt;/code&gt; 가 ID 인수로 전달되면 ID는 자동 생성 된 것입니다 . 그렇지 않으면 명령은 삽입 중에 사용자가 지정한 것과 동일한 ID를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7247b723aad05766caad65ebc7ede74ba6d1e1dd" translate="yes" xml:space="preserve">
          <source>The command returns the distance as a double (represented as a string) in the specified unit, or NULL if one or both the elements are missing.</source>
          <target state="translated">명령은 거리를 지정된 단위로 double (문자열로 표시)로 반환하거나 요소 중 하나 또는 둘 다가 없으면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a226a6dbee33f1a9bdf015f4eb2291dd60f7022b" translate="yes" xml:space="preserve">
          <source>The command returns the entries with IDs matching the specified range, from the higher ID to the lower ID matching. The returned entries are complete, that means that the ID and all the fields they are composed are returned. Moreover the entries are returned with their fields and values in the exact same order as &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; added them.</source>
          <target state="translated">이 명령은 더 높은 ID에서 더 낮은 ID 일치에 이르기까지 지정된 범위와 일치하는 ID를 가진 항목을 반환합니다. 리턴 된 항목이 완료되었으므로 ID 및 해당 항목이 구성된 모든 필드가 리턴됩니다. 또한 항목은 &lt;a href=&quot;xadd&quot;&gt;XADD가&lt;/a&gt; 추가 한 것과 동일한 순서로 필드 및 값과 함께 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="444f426015abc65778606f24926eb62888ddcfbe" translate="yes" xml:space="preserve">
          <source>The command returns the entries with IDs matching the specified range. The returned entries are complete, that means that the ID and all the fields they are composed are returned. Moreover, the entries are returned with their fields and values in the exact same order as &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; added them.</source>
          <target state="translated">이 명령은 지정된 범위와 일치하는 ID를 가진 항목을 반환합니다. 리턴 된 항목이 완료되었으므로 ID 및 해당 항목이 구성된 모든 필드가 리턴됩니다. 또한 항목은 &lt;a href=&quot;xadd&quot;&gt;XADD가&lt;/a&gt; 추가 한 것과 동일한 순서로 필드 및 값과 함께 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="62939248d8e32365e6957d42055f2de89814a292" translate="yes" xml:space="preserve">
          <source>The command returns the index of matching elements inside a Redis list. By default, when no options are given, it will scan the list from head to tail, looking for the first match of &quot;element&quot;. If the element is found, its index (the zero-based position in the list) is returned. Otherwise, if no match is found, NULL is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f216246f788da7553b72042887561f848de4e55c" translate="yes" xml:space="preserve">
          <source>The command returns the integer representing the matching element, or null if there is no match. However, if the &lt;code&gt;COUNT&lt;/code&gt; option is given the command returns an array (empty if there are no matches).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a3d21f3dbcaa198bbe343d23738bbd28a872e1" translate="yes" xml:space="preserve">
          <source>The command returns the number of &lt;em&gt;failure reports&lt;/em&gt; for the specified node. Failure reports are the way Redis Cluster uses in order to promote a &lt;code&gt;PFAIL&lt;/code&gt; state, that means a node is not reachable, to a &lt;code&gt;FAIL&lt;/code&gt; state, that means that the majority of masters in the cluster agreed within a window of time that the node is not reachable.</source>
          <target state="translated">명령은 지정된 노드에 대한 &lt;em&gt;실패 보고서&lt;/em&gt; 수를 리턴 합니다. 실패 보고서는 &lt;code&gt;PFAIL&lt;/code&gt; 상태 를 승격시키기 위해 Redis Cluster가 사용하는 방식 입니다. 즉, 노드에 도달 할 수 없음을, &lt;code&gt;FAIL&lt;/code&gt; 상태로, 즉 클러스터의 마스터가 노드가 아닌 시간 내에 동의 함을 의미합니다. 도달 할 수있는.</target>
        </trans-unit>
        <trans-unit id="11d6963d3c757dd171e4446f81aa6fbb2b4f3cbe" translate="yes" xml:space="preserve">
          <source>The command returns the number of entries deleted from the stream.</source>
          <target state="translated">명령은 스트림에서 삭제 된 항목 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="90a0913f53aff4fc9a2c5f477057692b16cb61c2" translate="yes" xml:space="preserve">
          <source>The command returns the number of messages successfully acknowledged. Certain message IDs may no longer be part of the PEL (for example because they have been already acknowledge), and XACK will not count them as successfully acknowledged.</source>
          <target state="translated">이 명령은 성공적으로 승인 된 메시지 수를 반환합니다. 특정 메시지 ID는 더 이상 PEL에 속하지 않을 수 있으며 (예 : 이미 확인 되었기 때문에) XACK은 성공적으로 승인 된 것으로 간주하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25862d0137651f4c50c642c84cec4c703a39cc67" translate="yes" xml:space="preserve">
          <source>The command returns the position of the first bit set to 1 or 0 according to the request.</source>
          <target state="translated">명령은 요청에 따라 첫 번째 비트의 위치를 ​​1 또는 0으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0f2fe335e56363e46ba8079d81809ab997be12eb" translate="yes" xml:space="preserve">
          <source>The command returns the stream entries matching a given range of IDs. The range is specified by a minimum and maximum ID. All the entires having an ID between the two specified or exactly one of the two IDs specified (closed interval) are returned.</source>
          <target state="translated">이 명령은 주어진 범위의 ID와 일치하는 스트림 항목을 반환합니다. 범위는 최소 및 최대 ID로 지정됩니다. 두 개의 지정된 ID 또는 지정된 두 개의 ID 중 정확히 하나 (닫힌 간격)가있는 모든 ID가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="383ccd477dc944e0c3ebd47dbea4b6b2017eb35b" translate="yes" xml:space="preserve">
          <source>The command returns the stream entries matching a given range of IDs. The range is specified by a minimum and maximum ID. All the entries having an ID between the two specified or exactly one of the two IDs specified (closed interval) are returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9be8f3674812a7bb5d9fb3101b17c38b3646405b" translate="yes" xml:space="preserve">
          <source>The command shows a list of all the usernames of the currently configured users in the Redis ACL system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13c06047a0b602e177d71981a4d9e29349f77a37" translate="yes" xml:space="preserve">
          <source>The command shows a list of recent ACL security events:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2382a9cd868ca3bdb3953efcef5f79ded0789a3c" translate="yes" xml:space="preserve">
          <source>The command shows the available ACL categories if called without arguments. If a category name is given, the command shows all the Redis commands in the specified category.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="724b74eeaa692174c50661ecd1cc035a30521473" translate="yes" xml:space="preserve">
          <source>The command shows the currently active ACL rules in the Redis server. Each line in the returned array defines a different user, and the format is the same used in the redis.conf file or the external ACL file, so you can cut and paste what is returned by the ACL LIST command directly inside a configuration file if you wish (but make sure to check &lt;a href=&quot;acl-save&quot;&gt;ACL SAVE&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26b22d366f18019ba16fe8b5883618685376f0fb" translate="yes" xml:space="preserve">
          <source>The command takes arguments in the standard format x,y so the longitude must be specified before the latitude. There are limits to the coordinates that can be indexed: areas very near to the poles are not indexable. The exact limits, as specified by EPSG:900913 / EPSG:3785 / OSGEO:41001 are the following:</source>
          <target state="translated">이 명령은 표준 형식 x, y의 인수를 사용하므로 위도 전에 경도를 지정해야합니다. 인덱싱 할 수있는 좌표에는 제한이 있습니다. 극에 매우 가까운 영역은 인덱싱 할 수 없습니다. EPSG : 900913 / EPSG : 3785 / OSGEO : 41001에 지정된 정확한 한계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="69e46f6ba0a5d03f8dc0e5aa7af7b003d2e71820" translate="yes" xml:space="preserve">
          <source>The command treats a Redis string as a array of bits, and is capable of addressing specific integer fields of varying bit widths and arbitrary non (necessary) aligned offset. In practical terms using this command you can set, for example, a signed 5 bits integer at bit offset 1234 to a specific value, retrieve a 31 bit unsigned integer from offset 4567. Similarly the command handles increments and decrements of the specified integers, providing guaranteed and well specified overflow and underflow behavior that the user can configure.</source>
          <target state="translated">이 명령은 Redis 문자열을 비트 배열로 취급하며 다양한 비트 폭과 임의의 (필수) 정렬 된 오프셋의 특정 정수 필드를 처리 할 수 ​​있습니다. 이 명령을 사용하는 실제 용어로 예를 들어 비트 오프셋 1234에서 부호있는 5 비트 정수를 특정 값으로 설정하고 오프셋 4567에서 31 비트 부호없는 정수를 검색 할 수 있습니다. 마찬가지로 명령은 지정된 정수의 증분 및 감소를 처리합니다. 사용자가 구성 할 수있는 보장되고 올바르게 지정된 오버 플로우 및 언더 플로우 동작.</target>
        </trans-unit>
        <trans-unit id="13c5fae6e8ea2d19068840627307808e57ed434f" translate="yes" xml:space="preserve">
          <source>The command will fail if the specified node is not known or if it is not a master according to the node table of the node receiving the command.</source>
          <target state="translated">지정된 노드를 모르거나 명령을 수신 한 노드의 노드 테이블에 따라 마스터가 아닌 경우 명령이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="83094ac4a33e4188f42d4a2c20d7dbf3f6620df3" translate="yes" xml:space="preserve">
          <source>The command will report an error when the user attempts to index coordinates outside the specified ranges.</source>
          <target state="translated">사용자가 지정된 범위를 벗어난 좌표를 색인화하려고 시도하면 명령이 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="c3184d09a508b5c6fdb922b8b826ae4f98d9a67a" translate="yes" xml:space="preserve">
          <source>The command will return up to 160 timestamp-latency pairs for the &lt;code&gt;event&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a427adc7c29c84562496f4e3dd746f3b4883cbf" translate="yes" xml:space="preserve">
          <source>The command with its set of subcommands is useful in order to start and end cluster live resharding operations, which are accomplished by setting a hash slot in migrating state in the source node, and importing state in the destination node.</source>
          <target state="translated">부속 명령 세트가있는 명령은 소스 노드에서 마이그레이션 상태로 해시 슬롯을 설정하고 대상 노드에서 상태를 가져 와서 클러스터 라이브 리 샤딩 조작을 시작하고 종료하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f34a45ceabab28f1008f0f9d2405fbba32c8e338" translate="yes" xml:space="preserve">
          <source>The command works in the same way even if the script was already present in the script cache.</source>
          <target state="translated">스크립트가 스크립트 캐시에 이미 존재하더라도 명령은 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="58212b0000147d5bba3264e4996ad46fd286b905" translate="yes" xml:space="preserve">
          <source>The common use case for this command is to retrieve geospatial items near a specified point not farther than a given amount of meters (or other units). This allows, for example, to suggest mobile users of an application nearby places.</source>
          <target state="translated">이 명령의 일반적인 사용 사례는 지정된 미터 (또는 다른 단위)보다 멀지 않은 지정된 지점 근처의 지형 공간 항목을 검색하는 것입니다. 이를 통해 예를 들어 주변의 애플리케이션을 모바일 사용자에게 제안 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83d84f2e6d0bc285dccf475994bf2dfe5a7034d1" translate="yes" xml:space="preserve">
          <source>The computed merged HyperLogLog is set to the destination variable, which is created if does not exist (defaulting to an empty HyperLogLog).</source>
          <target state="translated">계산 된 병합 된 HyperLogLog는 대상 변수로 설정되며 존재하지 않는 경우 작성됩니다 (기본값은 비어있는 HyperLogLog).</target>
        </trans-unit>
        <trans-unit id="892b6264b392f8ad48dfbfcfe6dff8a94a45c598" translate="yes" xml:space="preserve">
          <source>The configuration can be done by editing &lt;code&gt;redis.conf&lt;/code&gt; or while the server is running using the &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; and &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; commands.</source>
          <target state="translated">&lt;code&gt;redis.conf&lt;/code&gt; 를 편집 하거나 &lt;a href=&quot;config-get&quot;&gt;CONFIG GET&lt;/a&gt; 및 &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; 명령을 사용하여 서버를 실행하는 동안 구성을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9924fa1c31458da66b46121ed81593fd5a4fbad" translate="yes" xml:space="preserve">
          <source>The connection name can be inspected using &lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;client-getname&quot;&gt;CLIENT GETNAME을&lt;/a&gt; 사용하여 연결 이름을 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6da99886277806746e8e984d617153310b22b176" translate="yes" xml:space="preserve">
          <source>The connection we have with the server is persistent and was never closed so far.</source>
          <target state="translated">서버와의 연결은 영구적이며 지금까지 닫히지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="812045821e03fcc1f9ffc04b5ef35de3b612856e" translate="yes" xml:space="preserve">
          <source>The consumer group will be destroyed even if there are active consumers and pending messages, so make sure to call this command only when really needed.</source>
          <target state="translated">활성 소비자 및 보류중인 메시지가 있어도 소비자 그룹이 삭제되므로 실제로 필요한 경우에만이 명령을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="8d4c2cd743047005cdb993a3a9d7afc356bb6664" translate="yes" xml:space="preserve">
          <source>The consumer will do:</source>
          <target state="translated">소비자는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a09ada6e198e1cc27a58e1c5cd2063765d34a60e" translate="yes" xml:space="preserve">
          <source>The coordinates as a two items x,y array (longitude,latitude).</source>
          <target state="translated">두 항목 x, y 배열 (경도, 위도)로 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="d6f85adf1bad41bef7242defbfacbfdea663e0f0" translate="yes" xml:space="preserve">
          <source>The counter is created in a way that it only will survive one second, starting from the first request performed in the current second. If there are more than 10 requests in the same second the counter will reach a value greater than 10, otherwise it will expire and start again from 0.</source>
          <target state="translated">카운터는 현재 초에서 수행 된 첫 번째 요청부터 시작하여 1 초만 지속되는 방식으로 만들어집니다. 같은 초에 10 개가 넘는 요청이 있으면 카운터는 10보다 큰 값에 도달하고, 그렇지 않으면 0부터 다시 시작합니다.</target>
        </trans-unit>
        <trans-unit id="224e5c836dc00eb5744ec82792c094203a16fc27" translate="yes" xml:space="preserve">
          <source>The counter pattern is the most obvious thing you can do with Redis atomic increment operations. The idea is simply send an &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; command to Redis every time an operation occurs. For instance in a web application we may want to know how many page views this user did every day of the year.</source>
          <target state="translated">카운터 패턴은 Redis 원자 증분 작업으로 수행 할 수있는 가장 확실한 방법입니다. 아이디어는 단순히 작업이 발생할 때마다 &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; 명령을 Redis에 보내는 것입니다 . 예를 들어 웹 애플리케이션에서이 사용자가 매년 몇 페이지를 조회했는지 알고 싶어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b77e139112433671a542addfa1a32daf47ee322d" translate="yes" xml:space="preserve">
          <source>The crashed client C3 still holds it, so Redis will reply with &lt;code&gt;0&lt;/code&gt; to C4.</source>
          <target state="translated">충돌 한 클라이언트 C3은 여전히이를 보유하므로 Redis는 &lt;code&gt;0&lt;/code&gt; 에서 C4로 응답 합니다.</target>
        </trans-unit>
        <trans-unit id="8423b58d7e3aaab1a157d34537088cf7071837ad" translate="yes" xml:space="preserve">
          <source>The current field content or the specified increment are not parsable as a double precision floating point number.</source>
          <target state="translated">현재 필드 내용 또는 지정된 증분은 배정 밀도 부동 소수점 숫자로 구문 분석 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="838fa5216f1f1cdff3694527a8a6d1c1f9f94411" translate="yes" xml:space="preserve">
          <source>The current key content or the specified increment are not parsable as a double precision floating point number.</source>
          <target state="translated">현재 키 내용 또는 지정된 증분을 배정 밀도 부동 소수점 숫자로 구문 분석 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="931ea7e75c2dded718677c9f4a1676825fcb3baa" translate="yes" xml:space="preserve">
          <source>The current master replication offset, which is an offset that masters and replicas share to understand, in partial resynchronizations, the part of the replication stream the replicas needs to fetch to continue.</source>
          <target state="translated">현재 마스터 복제 오프셋 (마스터와 복제본이 부분 재 동기화에서 복제 스트림의 일부를 계속 이해하기 위해 가져와야하는 부분을 이해하기 위해 공유하는 오프셋)</target>
        </trans-unit>
        <trans-unit id="b7064688c0f4d788a94324f8ce3624a598ba7058" translate="yes" xml:space="preserve">
          <source>The current score of an element can be retrieved using the &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; command, that can also be used to verify if an element already exists or not.</source>
          <target state="translated">&lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; 명령을 사용하여 요소의 현재 점수를 검색 할 수 있으며 요소의 존재 여부를 확인하는 데에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30d1eb14ec245a20077a7d25213dc588a8512c5c" translate="yes" xml:space="preserve">
          <source>The cursor returned by the previous call to SCAN in order to continue the iteration.</source>
          <target state="translated">반복을 계속하기 위해 SCAN에 대한 이전 호출에 의해 리턴 된 커서.</target>
        </trans-unit>
        <trans-unit id="219c36e5291d2c3051ee7cf69aa75399bb2fc52c" translate="yes" xml:space="preserve">
          <source>The cursor value of 0 when starting an iteration.</source>
          <target state="translated">반복을 시작할 때 커서 값 0</target>
        </trans-unit>
        <trans-unit id="93cb8fd7598a4e9c87b91141380a4bde0e9f7ad1" translate="yes" xml:space="preserve">
          <source>The default COUNT value is 10.</source>
          <target state="translated">기본 COUNT 값은 10입니다.</target>
        </trans-unit>
        <trans-unit id="1472348f89b9c094e365f856bf74ca11dcb1cdde" translate="yes" xml:space="preserve">
          <source>The deliveries counter, that is the fourth element in the array, is incremented when some other consumer &lt;em&gt;claims&lt;/em&gt; the message with &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;, or when the message is delivered again via &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;, when accessing the history of a consumer in a consumer group (see the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; page for more info).</source>
          <target state="translated">배달 카운터 (배열의 네 번째 요소)는 다른 소비자 가 &lt;a href=&quot;xclaim&quot;&gt;XCLAIM으로&lt;/a&gt; 메시지를 &lt;em&gt;청구&lt;/em&gt; 하거나 소비자 그룹의 소비자 히스토리에 액세스 할 때 &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP을&lt;/a&gt; 통해 메시지가 다시 배달 될 때 &lt;a href=&quot;xreadgroup&quot;&gt;증가&lt;/a&gt; 합니다 ( XREADGROUP 참조). 자세한 내용은 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c29b8b8f823cca94ef6ad774fed42578a146e94a" translate="yes" xml:space="preserve">
          <source>The difference between this command and the vanilla &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; is that this one supports consumer groups.</source>
          <target state="translated">이 명령과 바닐라 &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; 의 차이점은이 명령 이 소비자 그룹을 지원한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3c1c5811c1d1a274026dcc95a504bdc2dd6d5a09" translate="yes" xml:space="preserve">
          <source>The distance from the center as a floating point number, in the same unit specified in the radius.</source>
          <target state="translated">반경에 지정된 것과 동일한 단위로 부동 소수점 숫자로 중심으로부터의 거리입니다.</target>
        </trans-unit>
        <trans-unit id="e1121b0e8297b7fecce16b935b4718ce15930933" translate="yes" xml:space="preserve">
          <source>The distance from the center as a floating point number, in the same unit specified in the shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3afe599a4181bcd5a732c0ec177cb011be65df41" translate="yes" xml:space="preserve">
          <source>The distance is computed assuming that the Earth is a perfect sphere, so errors up to 0.5% are possible in edge cases.</source>
          <target state="translated">거리는 지구가 완벽한 구를 가정하여 계산되므로 가장자리의 경우 최대 0.5 %의 오차가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8be9ff0b07a549071a611002c4a08732b5c80a8" translate="yes" xml:space="preserve">
          <source>The distribution of the returned elements is far from perfect when the number of elements in the set is small, this is due to the fact that we used an approximated random element function that does not really guarantees good distribution.</source>
          <target state="translated">집합의 요소 수가 적을 때 반환 된 요소의 분포는 완벽하지 않습니다. 이는 우리가 실제로 좋은 분포를 보장하지 않는 근사 임의 요소 함수를 사용했기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e2451d0313184cb7cb1bfd5f5707106d6b571329" translate="yes" xml:space="preserve">
          <source>The elements are considered to be ordered from lower to higher strings as compared byte-by-byte using the &lt;code&gt;memcmp()&lt;/code&gt; C function. Longer strings are considered greater than shorter strings if the common part is identical.</source>
          <target state="translated">요소는 &lt;code&gt;memcmp()&lt;/code&gt; C 함수를 사용하여 바이트 단위로 비교할 때 낮은 문자열에서 높은 문자열로 정렬 된 것으로 간주됩니다 . 공통 부분이 동일한 경우 긴 문자열은 짧은 문자열보다 큰 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7dd12a75b48ac332a2dfe23f1549d87b855bfd6d" translate="yes" xml:space="preserve">
          <source>The elements having the same score are returned in lexicographical order (this follows from a property of the sorted set implementation in Redis and does not involve further computation).</source>
          <target state="translated">동일한 점수를 가진 요소는 사전 식 순서로 반환됩니다 (이것은 Redis의 정렬 된 세트 구현의 속성에 따르며 추가 계산은 포함하지 않습니다).</target>
        </trans-unit>
        <trans-unit id="12d2f968d07516f9654dcc50b588d898c0361273" translate="yes" xml:space="preserve">
          <source>The elements having the same score are returned in reverse lexicographical order.</source>
          <target state="translated">동일한 점수를 가진 요소는 사전 사전 순으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8a7336e9649584aeb5dd7541a2422de663fa783e" translate="yes" xml:space="preserve">
          <source>The entry's unique ID can be used in order to avoid processing slow log entries multiple times (for instance you may have a script sending you an email alert for every new slow log entry).</source>
          <target state="translated">느린 로그 항목을 여러 번 처리하지 않도록 항목의 고유 ID를 사용할 수 있습니다 (예를 들어, 새로운 느린 로그 항목마다 전자 메일 경고를 보내는 스크립트가있을 수 있음).</target>
        </trans-unit>
        <trans-unit id="4c3c6b922261a4a3c02503cd2200bbc2e1969187" translate="yes" xml:space="preserve">
          <source>The exact behavior of this command is identical to the one of the &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; command, please refer to the documentation of &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; for further information.</source>
          <target state="translated">이 명령의 정확한 동작은 &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; 명령 의 것과 동일합니다 . 자세한 정보 는 &lt;a href=&quot;incrbyfloat&quot;&gt;INCRBYFLOAT&lt;/a&gt; 의 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="81ef5cb9ba6108b82ece4143c01d73481b4f607e" translate="yes" xml:space="preserve">
          <source>The fact that the user can count on Redis not removing scripts is semantically useful in the context of pipelining.</source>
          <target state="translated">사용자가 스크립트를 제거하지 않고 Redis를 신뢰할 수 있다는 것은 파이프 라이닝의 맥락에서 의미 적으로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a0c00c319cfd875c00a2280921682c92066dd97a" translate="yes" xml:space="preserve">
          <source>The feature will remain active in the current connection for all its life, unless tracking is turned on with &lt;code&gt;CLIENT TRACKING off&lt;/code&gt; at some point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccad1b83c48c6dc04cc17404f3912c32d936c720" translate="yes" xml:space="preserve">
          <source>The field contains a value of the wrong type (not a string).</source>
          <target state="translated">필드에 문자열이 아닌 잘못된 유형의 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6058628e04e98718045db43e11d253a6db12f594" translate="yes" xml:space="preserve">
          <source>The file descriptor events can be:</source>
          <target state="translated">파일 디스크립터 이벤트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d4261d3e5eb2c06f28ad9faa68309fdf262f21cb" translate="yes" xml:space="preserve">
          <source>The first argument of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is a Lua 5.1 script. The script does not need to define a Lua function (and should not). It is just a Lua program that will run in the context of the Redis server.</source>
          <target state="translated">&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 의 첫 번째 주장은 Lua 5.1 스크립트입니다. 스크립트는 Lua 함수를 정의 할 필요가 없습니다. Redis 서버의 컨텍스트에서 실행되는 Lua 프로그램 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="46870f99efa0c3b2959dcb93e1e13013212f023d" translate="yes" xml:space="preserve">
          <source>The first argument of the command selects the algorithm to use, right now the argument must be &quot;LCS&quot;, since this is the only implemented one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647fb34e5b11b941bb5e49ce5d7abfd78a858447" translate="yes" xml:space="preserve">
          <source>The first case will return the first 10 (or less) PEL entries of the entire group that are idle for over 9 seconds, whereas in the second case only those of &lt;code&gt;consumer-123&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cbda77e6bd32de6a17a5ed2d8395d40439856eb" translate="yes" xml:space="preserve">
          <source>The following are a few examples of importing and migrating slots:</source>
          <target state="translated">다음은 슬롯 가져 오기 및 마이그레이션의 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="6c3d5dc29a069636be48f90bb368850ce3fda788" translate="yes" xml:space="preserve">
          <source>The following are the list of options that modify the behavior of the command when enabling tracking:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b94aea73b4255f0bc659c9805b5380b0565b107" translate="yes" xml:space="preserve">
          <source>The following command removes the association for slots 5000 and 5001 from the node receiving the command:</source>
          <target state="translated">다음 명령은 명령을 수신 한 노드에서 슬롯 5000 및 5001에 대한 연결을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="784815ebd70c0fe925bcd60bddc497d55949fa3a" translate="yes" xml:space="preserve">
          <source>The following documentation is a reference manual about the capabilities of this command, however our &lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;ACL tutorial&lt;/a&gt; may be a more gentle introduction to how the ACL system works in general.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00075a28fdc9ff572c3eac87bcaf7c44d932e7da" translate="yes" xml:space="preserve">
          <source>The following example should clarify what stated above:</source>
          <target state="translated">다음 예제는 위에서 언급 한 내용을 명확히해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ec034b27145454749448bb4c66e40315aa13e2f" translate="yes" xml:space="preserve">
          <source>The following example using &lt;code&gt;WITHSCORES&lt;/code&gt; shows how the command returns always an array, but this time, populated with &lt;em&gt;element_1&lt;/em&gt;, &lt;em&gt;score_1&lt;/em&gt;, &lt;em&gt;element_2&lt;/em&gt;, &lt;em&gt;score_2&lt;/em&gt;, ..., &lt;em&gt;element_N&lt;/em&gt;, &lt;em&gt;score_N&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;WITHSCORES&lt;/code&gt; 를 사용하는 다음 예제 는 명령이 항상 배열을 리턴하는 방법을 보여 주지만 이번에 는 &lt;em&gt;element_1&lt;/em&gt; , &lt;em&gt;score_1&lt;/em&gt; , &lt;em&gt;element_2&lt;/em&gt; , &lt;em&gt;score_2&lt;/em&gt; , ..., &lt;em&gt;element_N&lt;/em&gt; , &lt;em&gt;score_N으로 채워집니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="69face26cb0b6283ed9eddef9110c599dd9ae6eb" translate="yes" xml:space="preserve">
          <source>The following field is always provided:</source>
          <target state="translated">다음 필드는 항상 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5fede26fc672e9d5137b89bc60a98de02e5d6528" translate="yes" xml:space="preserve">
          <source>The following is an example of &lt;code&gt;OVERFLOW FAIL&lt;/code&gt; returning NULL.</source>
          <target state="translated">다음은 &lt;code&gt;OVERFLOW FAIL&lt;/code&gt; 이 NULL을 반환 하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="f26894ffa2e5bfa52e8acebe022822e6a159ac5d" translate="yes" xml:space="preserve">
          <source>The following is the list of supported commands.</source>
          <target state="translated">다음은 지원되는 명령 목록입니다.</target>
        </trans-unit>
        <trans-unit id="487db5ff0187b77e2cfe37d8572892092c01e33a" translate="yes" xml:space="preserve">
          <source>The following pattern is discouraged in favor of &lt;a href=&quot;http://redis.io/topics/distlock&quot;&gt;the Redlock algorithm&lt;/a&gt; which is only a bit more complex to implement, but offers better guarantees and is fault tolerant.</source>
          <target state="translated">구현하기가 조금 더 복잡하지만 더 나은 보증을 제공하고 내결함성 이 &lt;a href=&quot;http://redis.io/topics/distlock&quot;&gt;있는 Redlock 알고리즘&lt;/a&gt; 을 선호하는 다음 패턴은 권장되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8e9fc798f24c122b5b0b23c06739d7c4c95610dd" translate="yes" xml:space="preserve">
          <source>The following pattern is discouraged in favor of &lt;a href=&quot;https://redis.io/topics/distlock&quot;&gt;the Redlock algorithm&lt;/a&gt; which is only a bit more complex to implement, but offers better guarantees and is fault tolerant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="685c86199b8431155924b73d00e71167faabb72e" translate="yes" xml:space="preserve">
          <source>The form &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE will stop replication, turning the server into a MASTER, but will not discard the replication. So, if the old master stops working, it is possible to turn the replica into a master and set the application to use this new master in read/write. Later when the other Redis server is fixed, it can be reconfigured to work as a replica.</source>
          <target state="translated">&lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE 형식 은 복제를 중지하고 서버를 MASTER로 전환하지만 복제는 버리지 않습니다. 따라서 이전 마스터의 작동이 중지되면 복제본을 마스터로 전환하고 응용 프로그램에서이 새 마스터를 읽기 / 쓰기로 사용하도록 설정할 수 있습니다. 나중에 다른 Redis 서버가 수정되면 복제본으로 작동하도록 재구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a758769f42fa16fd49a6c65e260a443efa58858" translate="yes" xml:space="preserve">
          <source>The form &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE will stop replication, turning the server into a MASTER, but will not discard the replication. So, if the old master stops working, it is possible to turn the replica into a master and set the application to use this new master in read/write. Later when the other Redis server is fixed, it can be reconfigured to work as a replica.</source>
          <target state="translated">&lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; NO ONE 형식 은 복제를 중지하고 서버를 MASTER로 전환하지만 복제는 버리지 않습니다. 따라서 이전 마스터의 작동이 중지되면 복제본을 마스터로 전환하고 응용 프로그램에서이 새 마스터를 읽기 / 쓰기로 사용하도록 설정할 수 있습니다. 나중에 다른 Redis 서버가 수정되면 복제본으로 작동하도록 재구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfb81787e75be423c5bbd1da337f47a738269c3b" translate="yes" xml:space="preserve">
          <source>The function handles out of range requests by limiting the resulting range to the actual length of the string.</source>
          <target state="translated">이 함수는 결과 범위를 문자열의 실제 길이로 제한하여 범위를 벗어난 요청을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="bae822e06654577340df39aec8c279a41923dbdf" translate="yes" xml:space="preserve">
          <source>The function returns true if the script effects replication was enabled, otherwise if the function was called after the script already called some write command, it returns false, and normal whole script replication is used.</source>
          <target state="translated">스크립트 효과 복제가 활성화 된 경우이 함수는 true를 반환하고, 그렇지 않으면 스크립트가 이미 일부 쓰기 명령을 호출 한 후 함수를 호출 한 경우 false를 반환하며 일반적인 전체 스크립트 복제가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e3d352c9158e45827d58fa0bb1daa62cb827202a" translate="yes" xml:space="preserve">
          <source>The geohash integer.</source>
          <target state="translated">지오 해시 정수.</target>
        </trans-unit>
        <trans-unit id="a74105f90399289d271dac87ebbc775e37f16a9d" translate="yes" xml:space="preserve">
          <source>The graph is normalized in the min-max scale so that the zero (the underscore in the lower row) is the minimum, and a # in the higher row is the maximum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1802968f15db7e03ec0c89118a7963b7fbc9d55a" translate="yes" xml:space="preserve">
          <source>The group name is just the name of a consumer group associated to the stream. The group is created using the &lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt; command. The consumer name is the string that is used by the client to identify itself inside the group. The consumer is auto created inside the consumer group the first time it is saw. Different clients should select a different consumer name.</source>
          <target state="translated">그룹 이름은 스트림과 관련된 소비자 그룹의 이름입니다. 그룹은 &lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt; 명령을 사용하여 작성됩니다 . 소비자 이름은 클라이언트가 그룹 내에서 자신을 식별하는 데 사용하는 문자열입니다. 소비자는 소비자 그룹을 처음 볼 때 자동으로 생성됩니다. 다른 클라이언트는 다른 소비자 이름을 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="9501214421f828fe1bcfe6cfb269ae7881da1706" translate="yes" xml:space="preserve">
          <source>The id of the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dfb24eb9709d7c83208076fd77b0d419da27db0" translate="yes" xml:space="preserve">
          <source>The information about memory usage is provided as metrics and their respective values. The following metrics are reported:</source>
          <target state="translated">메모리 사용량에 대한 정보는 메트릭과 해당 값으로 제공됩니다. 다음과 같은 메트릭이보고됩니다.</target>
        </trans-unit>
        <trans-unit id="34a2e40e15b32f6149b206a299f7840113d10818" translate="yes" xml:space="preserve">
          <source>The key contains a value of the wrong type (not a string).</source>
          <target state="translated">키에 문자열이 아닌 잘못된 유형의 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="09d97b8e7dc4c8276b96f5602bc74dea1d0e36c5" translate="yes" xml:space="preserve">
          <source>The key may be on both the instances.</source>
          <target state="translated">키는 두 인스턴스 모두에있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="317c7c0e8fc5ce228ab50cadfc186268268a73ba" translate="yes" xml:space="preserve">
          <source>The key may be only in the source instance.</source>
          <target state="translated">키는 소스 인스턴스에만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="770d7559e7b2fdc7128e6105d19ea9ca36a0376e" translate="yes" xml:space="preserve">
          <source>The key time to live can be updated or entirely removed using the &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; and &lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt; command (or other strictly related commands).</source>
          <target state="translated">&lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; 및 &lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt; 명령 (또는 기타 엄격하게 관련된 명령)을 사용하여 주요 지속 시간을 업데이트하거나 완전히 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="547c694280239130253479a419ced5c053003ea8" translate="yes" xml:space="preserve">
          <source>The last ID returned is &lt;code&gt;1526985712947-0&lt;/code&gt;, since the sequence number is already zero, the next ID I'll use instead of the &lt;code&gt;+&lt;/code&gt; special ID will be &lt;code&gt;1526985712946-18446744073709551615&lt;/code&gt;, or just &lt;code&gt;18446744073709551615&lt;/code&gt;:</source>
          <target state="translated">반환 된 마지막 ID는 &lt;code&gt;1526985712947-0&lt;/code&gt; 입니다 . 시퀀스 번호가 이미 0이므로 &lt;code&gt;+&lt;/code&gt; 특수 ID 대신 사용할 다음 ID는 &lt;code&gt;1526985712946-18446744073709551615&lt;/code&gt; 또는 &lt;code&gt;18446744073709551615&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="11471f50fbf81f6258a27201c930e977959ad0cd" translate="yes" xml:space="preserve">
          <source>The last argument is the ID of the last item in the stream to consider already delivered. In the above case we used the special ID '$' (that means: the ID of the last item in the stream). In this case the consumers fetching data from that consumer group will only see new elements arriving in the stream.</source>
          <target state="translated">마지막 인수는 스트림에서 이미 전달 된 것으로 간주되는 마지막 항목의 ID입니다. 위의 경우 특수 ID '$'(스트림에서 마지막 항목의 ID)를 사용했습니다. 이 경우 해당 소비자 그룹에서 데이터를 가져 오는 소비자는 스트림에 도착하는 새 요소 만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42e7923c299c01e54ed6170cd5e8fc34b5599898" translate="yes" xml:space="preserve">
          <source>The last example shows how it is possible to receive the exact return value of &lt;code&gt;redis.call()&lt;/code&gt; or &lt;code&gt;redis.pcall()&lt;/code&gt; from Lua that would be returned if the command was called directly.</source>
          <target state="translated">마지막 예는 명령이 직접 호출 된 경우 반환되는 Lua에서 &lt;code&gt;redis.call()&lt;/code&gt; 또는 &lt;code&gt;redis.pcall()&lt;/code&gt; 의 정확한 반환 값을받는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="898edad6fe267446764a3f01813e23c34e6a4dc9" translate="yes" xml:space="preserve">
          <source>The lexicographic ordering used is binary, it compares strings as array of bytes.</source>
          <target state="translated">사용 된 사전 식 순서는 이진이며 문자열을 바이트 배열로 비교합니다.</target>
        </trans-unit>
        <trans-unit id="e89335ad1d56e8f847f0e52f7c837e0cf165daeb" translate="yes" xml:space="preserve">
          <source>The limitation of this pattern is that we are forced into an append-only mode of operation, there is no way to cut the time series to a given size easily because Redis currently lacks a command able to trim string objects. However the space efficiency of time series stored in this way is remarkable.</source>
          <target state="translated">이 패턴의 한계는 우리가 추가 전용 작동 모드로 강요된다는 것입니다. Redis에는 현재 문자열 객체를자를 수있는 명령이 없기 때문에 시계열을 주어진 크기로 쉽게자를 수있는 방법이 없습니다. 그러나 이런 방식으로 저장된 시계열의 공간 효율성은 놀랍습니다.</target>
        </trans-unit>
        <trans-unit id="da33cd971f0747462e42ccd2282a1e6fb83aa7be" translate="yes" xml:space="preserve">
          <source>The list of configuration parameters supported by &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; can be obtained issuing a &lt;code&gt;CONFIG GET *&lt;/code&gt; command, that is the symmetrical command used to obtain information about the configuration of a running Redis instance.</source>
          <target state="translated">&lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; 가 지원하는 구성 매개 변수 목록은 &lt;code&gt;CONFIG GET *&lt;/code&gt; 명령을 실행하여 얻을 수 있습니다 . 이는 실행중인 Redis 인스턴스의 구성에 대한 정보를 얻는 데 사용되는 대칭 명령입니다.</target>
        </trans-unit>
        <trans-unit id="8095634a38168f2c281c9616bbb338721d7efd28" translate="yes" xml:space="preserve">
          <source>The lock will be auto-released after the expire time is reached.</source>
          <target state="translated">만료 시간에 도달하면 잠금이 자동 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="08a7894ad23c8503b151cc8bfa325bf87f080cfd" translate="yes" xml:space="preserve">
          <source>The main drawback with the &lt;em&gt;whole scripts replication&lt;/em&gt; approach is that scripts are required to have the following property:</source>
          <target state="translated">&lt;em&gt;전체 스크립트 복제&lt;/em&gt; 방법 의 주요 단점 은 스크립트에 다음 속성이 있어야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7e2e2adfa0c27b3c4fcd6715d167f77cf7aab615" translate="yes" xml:space="preserve">
          <source>The main usage of this command is during rehashing of cluster slots from one node to another. The way the rehashing is performed is exposed in the Redis Cluster specification, or in a more simple to digest form, as an appendix of the &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; command documentation.</source>
          <target state="translated">이 명령의 주요 사용법은 한 노드에서 다른 노드로 클러스터 슬롯을 다시 해싱하는 동안입니다. 재해시 수행 방식은 &lt;a href=&quot;cluster-setslot&quot;&gt;CLUSTER SETSLOT&lt;/a&gt; 명령 설명서 의 부록으로 Redis Cluster 사양 또는보다 간단한 요약 형식으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="51aa615de4288430f4f542dd741b0be9823a9984" translate="yes" xml:space="preserve">
          <source>The master output is composed of the following parts:</source>
          <target state="translated">마스터 출력은 다음과 같은 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="9294413196a1d66d0e89a267022407a00ed67b4f" translate="yes" xml:space="preserve">
          <source>The master replies to the replica with the current &lt;em&gt;replication offset&lt;/em&gt;.</source>
          <target state="translated">마스터는 현재 &lt;em&gt;복제 오프셋&lt;/em&gt; 을 사용하여 복제본에 응답합니다 .</target>
        </trans-unit>
        <trans-unit id="9aa0f4e849bf549de77dfa2bc7bf7ffcfaf99bf4" translate="yes" xml:space="preserve">
          <source>The meaning of &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; are the same of the &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; command. Similarly, this command actually returns the same elements that &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; would return if called with the same &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; arguments.</source>
          <target state="translated">&lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;max&lt;/code&gt; 의 의미 는 &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; 명령 과 동일합니다 . &lt;a href=&quot;zrangebylex&quot;&gt;마찬가지로이&lt;/a&gt; 명령은 ZRANGEBYLEX 가 동일한 &lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;max&lt;/code&gt; 인수로 호출 된 경우 반환하는 것과 동일한 요소를 실제로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9e23ac08d91ce30fa5d8f4e6bbb8d1a66fed8600" translate="yes" xml:space="preserve">
          <source>The meaning of each filed is the following:</source>
          <target state="translated">각 출원의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="69174101963d6daf8e0c498390ca52d478774c02" translate="yes" xml:space="preserve">
          <source>The meaning of the two states is explained in the Redis Specification, however the gist of the two states is the following:</source>
          <target state="translated">두 상태의 의미는 Redis 사양에 설명되어 있지만 두 상태의 요지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5fe7d63b1ebc573c80de8db8907af87f4669998b" translate="yes" xml:space="preserve">
          <source>The more simple and direct implementation of this pattern is the following:</source>
          <target state="translated">이 패턴의보다 단순하고 직접적인 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8eafae6da4cd26a48b49e41708a6136f1a6de4a6" translate="yes" xml:space="preserve">
          <source>The motivation for this command is that the ability to store many small integers as a single large bitmap (or segmented over a few keys to avoid having huge keys) is extremely memory efficient, and opens new use cases for Redis to be applied, especially in the field of real time analytics. This use cases are supported by the ability to specify the overflow in a controlled way.</source>
          <target state="translated">이 명령의 동기는 많은 작은 정수를 하나의 큰 비트 맵으로 저장하는 기능 (또는 큰 키를 피하기 위해 몇 개의 키로 분할)이 매우 메모리 효율적이며 특히 Redis에 적용 할 새로운 사용 사례를 여는 것입니다 실시간 분석 분야. 이 사용 사례는 제어 된 방식으로 오버 플로우를 지정하는 기능에 의해 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8a6f6dffc18be981185e9a84435cd70cbbe693b9" translate="yes" xml:space="preserve">
          <source>The name of the consumer that fetched the message and has still to acknowledge it. We call it the current &lt;em&gt;owner&lt;/em&gt; of the message.</source>
          <target state="translated">메시지를 가져 왔지만 여전히 확인해야하는 소비자의 이름입니다. 메시지 의 현재 &lt;em&gt;소유자&lt;/em&gt; 라고합니다.</target>
        </trans-unit>
        <trans-unit id="95a0cef10627d21f971cf58ca481b45ed9811331" translate="yes" xml:space="preserve">
          <source>The new configuration is persisted on disk in the node cluster configuration file.</source>
          <target state="translated">새 구성은 노드 클러스터 구성 파일의 디스크에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="ce3fd26b48bfdbc550ce60034f680213e04e3fa5" translate="yes" xml:space="preserve">
          <source>The new format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69cbd0fd1035f94debad3eb8086987173fc0e180" translate="yes" xml:space="preserve">
          <source>The new score of &lt;code&gt;member&lt;/code&gt; (a double precision floating point number) represented as string, or &lt;code&gt;nil&lt;/code&gt; if the operation was aborted (when called with either the &lt;code&gt;XX&lt;/code&gt; or the &lt;code&gt;NX&lt;/code&gt; option).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1512d4f9273a472bf5054bc09af80c7b583c9993" translate="yes" xml:space="preserve">
          <source>The node ID identifies the same node we are sending the command to.</source>
          <target state="translated">노드 ID는 명령을 보내는 것과 동일한 노드를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="4a94b0edb207a0f9aad4e9890ab6a41a4abc596d" translate="yes" xml:space="preserve">
          <source>The node ID of the removed node gets added to the ban-list, for 1 minute.</source>
          <target state="translated">제거 된 노드의 노드 ID가 1 분 동안 금지 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7282e91e365e1582b64fd77e649fb8fae6ff8480" translate="yes" xml:space="preserve">
          <source>The node current &lt;em&gt;config epoch&lt;/em&gt; is zero.</source>
          <target state="translated">노드 현재 &lt;em&gt;구성 시간&lt;/em&gt; 은 0입니다.</target>
        </trans-unit>
        <trans-unit id="96c472bb576e96ca78ba9e6916a3879a69d9af69" translate="yes" xml:space="preserve">
          <source>The node is empty, no keys are stored at all in the key space.</source>
          <target state="translated">노드가 비어 있으며 키 공간에 키가 전혀 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c909806a718de9cb07358d8ed9ed00c019748494" translate="yes" xml:space="preserve">
          <source>The node is not serving any hash slots.</source>
          <target state="translated">노드가 해시 슬롯을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce819a3025f8ff3393901c2c8e810e36e0f1c69b" translate="yes" xml:space="preserve">
          <source>The node receiving the command is a replica, and the specified node ID identifies its current master.</source>
          <target state="translated">명령을 수신 한 노드는 복제본이며 지정된 노드 ID는 현재 마스터를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="3debb3fa567694b78b44554108f738a7a81cf421" translate="yes" xml:space="preserve">
          <source>The node will skip all the node IDs listed in the ban-list when processing gossip sections received in heartbeat packets from other nodes.</source>
          <target state="translated">노드는 다른 노드로부터 하트 비트 패킷으로 수신 된 가십 섹션을 처리 할 때 금지 목록에 나열된 모든 노드 ID를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="a02415f9a093ecefd5c824168bfb43638285dd33" translate="yes" xml:space="preserve">
          <source>The nodes table of the node is empty.</source>
          <target state="translated">노드의 노드 테이블이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a21d4be2cd3c8386a5bd51f51d8e281923d2f322" translate="yes" xml:space="preserve">
          <source>The number of bits set to 1.</source>
          <target state="translated">1로 설정된 비트 수</target>
        </trans-unit>
        <trans-unit id="59385708853390f9ca74251fea5131270265eecd" translate="yes" xml:space="preserve">
          <source>The number of elements added to the sorted set, not including elements already existing for which the score was updated.</source>
          <target state="translated">점수가 업데이트 된 기존 요소는 포함하지 않고 정렬 된 세트에 추가 된 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="dc1eea05d5c0b5d2f315739abfba0f7deefc344d" translate="yes" xml:space="preserve">
          <source>The number of elements added to the sorted sets, not including elements already existing for which the score was updated.</source>
          <target state="translated">점수가 업데이트 된 기존 요소는 포함하지 않고 정렬 된 세트에 추가 된 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="e1784080520f069f819c069f9066d039833cf4fa" translate="yes" xml:space="preserve">
          <source>The number of keys existing among the ones specified as arguments. Keys mentioned multiple times and existing are counted multiple times.</source>
          <target state="translated">인수로 지정된 키 중 존재하는 키 수 여러 번 언급 된 키와 기존 키는 여러 번 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="3563b055f87d27dac0ac55fd291fab644c82615a" translate="yes" xml:space="preserve">
          <source>The number of members removed from the sorted set, not including non existing members.</source>
          <target state="translated">기존 멤버가 아닌 멤버를 제외하고 정렬 된 세트에서 제거 된 멤버 수입니다.</target>
        </trans-unit>
        <trans-unit id="2eae56d8105036d6f2b2f01b5669d022f7996c37" translate="yes" xml:space="preserve">
          <source>The number of milliseconds that elapsed since the last time this message was delivered to this consumer.</source>
          <target state="translated">이 메시지가이 소비자에게 마지막으로 배달 된 이후 경과 된 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="bbb45a4c926e88dd9593fe92bcaf35382576535c" translate="yes" xml:space="preserve">
          <source>The number of returned elements can be limited using the &lt;code&gt;LIMIT&lt;/code&gt; modifier. This modifier takes the &lt;code&gt;offset&lt;/code&gt; argument, specifying the number of elements to skip and the &lt;code&gt;count&lt;/code&gt; argument, specifying the number of elements to return from starting at &lt;code&gt;offset&lt;/code&gt;. The following example will return 10 elements of the sorted version of &lt;code&gt;mylist&lt;/code&gt;, starting at element 0 (&lt;code&gt;offset&lt;/code&gt; is zero-based):</source>
          <target state="translated">&lt;code&gt;LIMIT&lt;/code&gt; 수정자를 사용하여 리턴 된 요소 수를 제한 할 수 있습니다 . 이 수정은 얻어 &lt;code&gt;offset&lt;/code&gt; 이동하는 소자의 수와 지정 인수 &lt;code&gt;count&lt;/code&gt; 시작에서 복귀 소자의 수를 지정하는 인수를 &lt;code&gt;offset&lt;/code&gt; . 다음 예제는 요소 0에서 시작 하여 정렬 된 버전의 &lt;code&gt;mylist&lt;/code&gt; 의 10 개 요소를 리턴합니다 ( &lt;code&gt;offset&lt;/code&gt; 은 0 부터 시작 함 ).</target>
        </trans-unit>
        <trans-unit id="2eeaa2bda10c14131d8f8224aae3f44fbab1d33b" translate="yes" xml:space="preserve">
          <source>The number of times this message was delivered.</source>
          <target state="translated">이 메시지가 전달 된 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="4b95ac5bed75bd380b7e253506beeb45e5dcdf48" translate="yes" xml:space="preserve">
          <source>The old master receives the configuration update: unblocks its clients and starts replying with redirection messages so that they'll continue the chat with the new master.</source>
          <target state="translated">이전 마스터는 구성 업데이트를 수신합니다. 클라이언트를 차단 해제하고 리디렉션 메시지로 응답을 시작하여 새 마스터와 계속 대화합니다.</target>
        </trans-unit>
        <trans-unit id="1d689942edb764c6bd34cea24670f1e2f9a34fe2" translate="yes" xml:space="preserve">
          <source>The only valid cursors to use are:</source>
          <target state="translated">사용할 유효한 커서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="71d7b3a0d8bb44887a86cd184249f11ce4bd68cd" translate="yes" xml:space="preserve">
          <source>The only way to flush the script cache is by explicitly calling the &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; command, which will &lt;em&gt;completely flush&lt;/em&gt; the scripts cache removing all the scripts executed so far.</source>
          <target state="translated">스크립트 캐시를 플러시하는 유일한 방법은 &lt;a href=&quot;script-flush&quot;&gt;SCRIPT FLUSH&lt;/a&gt; 명령 을 명시 적으로 호출하는 것입니다. SCRIPT FLUSH 명령 은 스크립트 캐시를 &lt;em&gt;완전히 플러시&lt;/em&gt; 하여 지금까지 실행 된 모든 스크립트를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="851a4dff1ddadeea08eb160100034cb226114c6d" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;LIMIT&lt;/code&gt; argument can be used to only get a range of the matching elements (similar to &lt;em&gt;SELECT LIMIT offset, count&lt;/em&gt; in SQL). A negative &lt;code&gt;count&lt;/code&gt; returns all elements from the &lt;code&gt;offset&lt;/code&gt;. Keep in mind that if &lt;code&gt;offset&lt;/code&gt; is large, the sorted set needs to be traversed for &lt;code&gt;offset&lt;/code&gt; elements before getting to the elements to return, which can add up to O(N) time complexity.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b79325b395f9601a80868e44ee285b402fa0bfad" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;LIMIT&lt;/code&gt; argument can be used to only get a range of the matching elements (similar to &lt;em&gt;SELECT LIMIT offset, count&lt;/em&gt; in SQL). Keep in mind that if &lt;code&gt;offset&lt;/code&gt; is large, the sorted set needs to be traversed for &lt;code&gt;offset&lt;/code&gt; elements before getting to the elements to return, which can add up to O(N) time complexity.</source>
          <target state="translated">선택적 &lt;code&gt;LIMIT&lt;/code&gt; 인수는 일치하는 요소의 범위 만 가져 오는 데 사용할 수 있습니다 ( &lt;em&gt;SELECT LIMIT 오프셋&lt;/em&gt; 과 유사 &lt;em&gt;,&lt;/em&gt; SQL 수). 경우에 있다는 사실을 숙지 &lt;code&gt;offset&lt;/code&gt; 큰, 정렬 된 세트의 요구가 통과 할 &lt;code&gt;offset&lt;/code&gt; O (N) 시간 복잡도를 추가 할 수있는 반환 요소에 도착하기 전에 요소.</target>
        </trans-unit>
        <trans-unit id="500dba23b5e32b54cd518b60d5bf8b2bf6fe3ec8" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;WITHSCORES&lt;/code&gt; argument makes the command return both the element and its score, instead of the element alone. This option is available since Redis 2.0.</source>
          <target state="translated">선택적 &lt;code&gt;WITHSCORES&lt;/code&gt; 인수는 명령이 요소 만 대신 요소와 해당 점수를 모두 리턴하도록합니다. 이 옵션은 Redis 2.0부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f54b06c2148c9b6919787651cb0104f905c8131" translate="yes" xml:space="preserve">
          <source>The optional argument specifies how many entries to show. By default up to ten failures are returned. The special &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; argument clears the log. Entries are displayed starting from the most recent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50b302b8ebe5d4f766a30687aa495211b0a41cc8" translate="yes" xml:space="preserve">
          <source>The optional arguments and options can modify the command's behavior. The &lt;code&gt;RANK&lt;/code&gt; option specifies the &quot;rank&quot; of the first element to return, in case there are multiple matches. A rank of 1 means to return the first match, 2 to return the second match, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8aa34d3ef4ed317f6f4c66d1281cf452a3e134" translate="yes" xml:space="preserve">
          <source>The optional parameter can be used to select a specific section of information:</source>
          <target state="translated">선택적 매개 변수를 사용하여 특정 정보 섹션을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3f8920e23cd2f39487b2140b719e87054ae2b2b" translate="yes" xml:space="preserve">
          <source>The order of step 1 and 2 is important. We want the destination node to be ready to accept &lt;code&gt;ASK&lt;/code&gt; redirections when the source node is configured to redirect.</source>
          <target state="translated">1 단계와 2 단계의 순서가 중요합니다. 소스 노드가 경로 재 지정되도록 구성된 경우 대상 노드가 &lt;code&gt;ASK&lt;/code&gt; 경로 재 지정 을 승인 할 수 있기를 원합니다 .</target>
        </trans-unit>
        <trans-unit id="b62304b58ff7ffb9f9709c25da7f4765174f07a9" translate="yes" xml:space="preserve">
          <source>The output of the command is just a space-separated CSV string, where each line represents a node in the cluster. The following is an example of output:</source>
          <target state="translated">명령의 출력은 공백으로 구분 된 CSV 문자열이며 각 줄은 클러스터의 노드를 나타냅니다. 다음은 출력 예입니다.</target>
        </trans-unit>
        <trans-unit id="27eaed3275801016a87c11dc8a65ad526a22ea0c" translate="yes" xml:space="preserve">
          <source>The port number of the master.</source>
          <target state="translated">마스터의 포트 번호입니다.</target>
        </trans-unit>
        <trans-unit id="251a4c07dcd21d1710028ff045133e0223bd8086" translate="yes" xml:space="preserve">
          <source>The position is returned, thinking of the string as an array of bits from left to right, where the first byte's most significant bit is at position 0, the second byte's most significant bit is at position 8, and so forth.</source>
          <target state="translated">문자열을 왼쪽에서 오른쪽으로의 비트 배열로 생각하면 위치가 반환됩니다. 첫 번째 바이트의 최상위 비트는 위치 0에 있고 두 번째 바이트의 최상위 비트는 위치 8에 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf1bf81ee9d88a76e67d9f14175bdac96ea2eae6" translate="yes" xml:space="preserve">
          <source>The position of the specified member is used as the center of the query.</source>
          <target state="translated">지정된 멤버의 위치가 쿼리의 중심으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fe9f9e53a4720c0a3b3f8dd9ba6795a8d524ecc9" translate="yes" xml:space="preserve">
          <source>The precision of the output is fixed at 17 digits after the decimal point regardless of the actual internal precision of the computation.</source>
          <target state="translated">출력의 정밀도는 계산의 실제 내부 정밀도에 관계없이 소수점 뒤에 17 자리로 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="77e23fa703efecfb1c5bf352cb4f0529fa3a9d39" translate="yes" xml:space="preserve">
          <source>The query's center point is provided by one of these mandatory options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1e2a1f42bcb6a5e4c6e642aa88cfced9dff68d3" translate="yes" xml:space="preserve">
          <source>The query's shape is provided by one of these mandatory options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9079c728747b4e6051aebcc896878af23a86276" translate="yes" xml:space="preserve">
          <source>The radius is specified in one of the following units:</source>
          <target state="translated">반경은 다음 단위 중 하나로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="5d69c6f303471181769a8ce1e67050c18c180806" translate="yes" xml:space="preserve">
          <source>The range is close (inclusive) by default, meaning that the reply can include entries with IDs matching the query's start and end intervals. It is possible to specify an open interval (exclusive) by prefixing the ID with the character &lt;code&gt;(&lt;/code&gt;. This is useful for iterating the stream, as explained below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa101056c680bd6adea2c67580ad18683b432390" translate="yes" xml:space="preserve">
          <source>The range of values supported by &lt;a href=&quot;hincrby&quot;&gt;HINCRBY&lt;/a&gt; is limited to 64 bit signed integers.</source>
          <target state="translated">&lt;a href=&quot;hincrby&quot;&gt;HINCRBY&lt;/a&gt; 가 지원하는 값의 범위는 64 비트 부호있는 정수로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="33bdfca071502b90c1a8026acb1caf737da192b8" translate="yes" xml:space="preserve">
          <source>The rate limiter pattern is a special counter that is used to limit the rate at which an operation can be performed. The classical materialization of this pattern involves limiting the number of requests that can be performed against a public API.</source>
          <target state="translated">속도 제한 기 패턴은 작업 수행 속도를 제한하는 데 사용되는 특수 카운터입니다. 이 패턴의 고전적인 구체화에는 공개 API에 대해 수행 할 수있는 요청 수를 제한하는 것이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="602f859c103a55957a4cbd71395a1cae9a978824" translate="yes" xml:space="preserve">
          <source>The reason is that sending a script to another Redis instance is often much faster than sending the multiple commands the script generates, so if the client is sending many scripts to the master, converting the scripts into individual commands for the replica / AOF would result in too much bandwidth for the replication link or the Append Only File (and also too much CPU since dispatching a command received via network is a lot more work for Redis compared to dispatching a command invoked by Lua scripts).</source>
          <target state="translated">그 이유는 다른 Redis 인스턴스에 스크립트를 보내는 것이 스크립트가 생성하는 여러 명령을 보내는 것보다 훨씬 빠르기 때문에 클라이언트가 많은 스크립트를 마스터에 보내는 경우 스크립트를 복제본 / AOF에 대한 개별 명령으로 변환하면 복제 링크 또는 추가 전용 파일에 대해 너무 많은 대역폭 (또한 네트워크를 통해 수신 된 명령을 디스패치하는 것이 Lua 스크립트에 의해 호출 된 명령을 디스패치하는 것보다 훨씬 더 많은 작업을 수행하기 때문에 너무 많은 CPU)</target>
        </trans-unit>
        <trans-unit id="f4d6d43d2e03d821aeb88801c0d8fb884cbca911" translate="yes" xml:space="preserve">
          <source>The reason why scripts can be cached for long time is that it is unlikely for a well written application to have enough different scripts to cause memory problems. Every script is conceptually like the implementation of a new command, and even a large application will likely have just a few hundred of them. Even if the application is modified many times and scripts will change, the memory used is negligible.</source>
          <target state="translated">스크립트를 오랫동안 캐시 할 수있는 이유는 잘 작성된 응용 프로그램이 메모리 문제를 일으킬만큼 충분한 다른 스크립트를 가지고 있지 않기 때문입니다. 모든 스크립트는 개념적으로 새로운 명령을 구현하는 것과 비슷하며 대규모 응용 프로그램조차도 수백 개에 불과합니다. 응용 프로그램이 여러 번 수정되고 스크립트가 변경 되더라도 사용 된 메모리는 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e5533e8fee1cbd59ebef949c8411c0d7d01dc8e" translate="yes" xml:space="preserve">
          <source>The replica output is composed of the following parts:</source>
          <target state="translated">복제본 출력은 다음 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="d985304abe6bf0f8f4ea24090445b6bf55af90d3" translate="yes" xml:space="preserve">
          <source>The replica starts a failover, obtains a new configuration epoch from the majority of the masters, and broadcasts the new configuration.</source>
          <target state="translated">복제본은 장애 조치를 시작하고 대부분의 마스터로부터 새로운 구성 에포크를 가져 와서 새로운 구성을 브로드 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="7c096a5e647ff1a64af00045529cba5bd168f06b" translate="yes" xml:space="preserve">
          <source>The replica tells the master to stop processing queries from clients.</source>
          <target state="translated">복제본은 마스터에게 클라이언트의 쿼리 처리를 중지하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="e43729fea60babeefa0888b3097ef84a1143b1a0" translate="yes" xml:space="preserve">
          <source>The replica waits for the replication offset to match on its side, to make sure it processed all the data from the master before it continues.</source>
          <target state="translated">복제본은 복제 오프셋이 측면에서 일치 할 때까지 기다렸다가 계속하기 전에 마스터의 모든 데이터를 처리했는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="71f9285cf89c4539aedf2939b67fe3ee74695f78" translate="yes" xml:space="preserve">
          <source>The reply format is identical to that of &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt;, and the content consists only of information about the current client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c6d847d0bceaf13a4c9effd31564050074fa753" translate="yes" xml:space="preserve">
          <source>The reported information contains all of the fields reported by the simple form of &lt;code&gt;XINFO STREAM&lt;/code&gt;, with some additional information:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fb0e618b4e3d9e5fe2c17d1edb7fb80034a8b4f" translate="yes" xml:space="preserve">
          <source>The reported usage is the total of memory allocations for data and administrative overheads that a key its value require.</source>
          <target state="translated">보고 된 사용량은 해당 값에 필요한 주요 데이터 및 관리 오버 헤드에 대한 총 메모리 할당량입니다.</target>
        </trans-unit>
        <trans-unit id="79c8f80736bb00aecddcc76c1b8f02af94064a15" translate="yes" xml:space="preserve">
          <source>The representation is neutral from the point of view of the processor word size and endianness, so the same representation is used by 32 bit and 64 bit processor, big endian or little endian.</source>
          <target state="translated">표현은 프로세서 워드 크기 및 엔디안의 관점에서 중립적이므로 동일한 표현은 32 비트 및 64 비트 프로세서, 빅 엔디안 또는 리틀 엔디안에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d07c8ceb7018e1bcd908f1c44ebce957404cda02" translate="yes" xml:space="preserve">
          <source>The representation used by &lt;a href=&quot;bitfield&quot;&gt;BITFIELD&lt;/a&gt; considers the bitmap as having the bit number 0 to be the most significant bit of the first byte, and so forth, so for example setting a 5 bits unsigned integer to value 23 at offset 7 into a bitmap previously set to all zeroes, will produce the following representation:</source>
          <target state="translated">&lt;a href=&quot;bitfield&quot;&gt;BITFIELD가&lt;/a&gt; 사용하는 표현 은 비트 맵 0을 첫 번째 바이트의 최상위 비트로 간주하는 등 비트 맵을 고려하므로, 예를 들어 오프셋 7에서 5 비트 부호없는 정수를 23으로 설정하여 이전에 설정된 비트 맵으로 설정합니다. 모든 0은 다음 표현을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="69c89883952564695abb2bebcaf5f11f6b3d6f75" translate="yes" xml:space="preserve">
          <source>The result of the operation is always stored at &lt;code&gt;destkey&lt;/code&gt;.</source>
          <target state="translated">작업 결과는 항상 &lt;code&gt;destkey&lt;/code&gt; 에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="8563416a363c2cdbe31060c220e5e3844f6d8270" translate="yes" xml:space="preserve">
          <source>The return type of the command is a &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt;.</source>
          <target state="translated">명령의 리턴 유형은 &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열 응답&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="29bc7d6c144c9d4891cb5866b63897dea6e00bee" translate="yes" xml:space="preserve">
          <source>The returned cardinality of the observed set is not exact, but approximated with a standard error of 0.81%.</source>
          <target state="translated">관측 세트의 반환 된 카디널리티는 정확하지 않지만 표준 오류 0.81 %로 근사합니다.</target>
        </trans-unit>
        <trans-unit id="f485b5467a04f58f023ce0589b088bae79cd349e" translate="yes" xml:space="preserve">
          <source>The rewrite is performed in a very conservative way:</source>
          <target state="translated">재 작성은 매우 보수적 인 방식으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="3d4aef252f6710693b627be68f7b05c7734609ba" translate="yes" xml:space="preserve">
          <source>The rewrite will be only triggered by Redis if there is not already a background process doing persistence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95ba82b2fd87a033c00319b26e5a7be447966868" translate="yes" xml:space="preserve">
          <source>The rewrite will be only triggered by Redis if there is not already a background process doing persistence. Specifically:</source>
          <target state="translated">재 작성은 지속성을 수행하는 백그라운드 프로세스가없는 경우에만 Redis에 의해 트리거됩니다. 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="1f1d9ccb03a5f0171c2e12fc9e5717671728f51a" translate="yes" xml:space="preserve">
          <source>The same bit position convention is followed by &lt;a href=&quot;getbit&quot;&gt;GETBIT&lt;/a&gt; and &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt;.</source>
          <target state="translated">동일한 비트 위치 규칙 뒤에 &lt;a href=&quot;getbit&quot;&gt;GETBIT&lt;/a&gt; 및 &lt;a href=&quot;setbit&quot;&gt;SETBIT가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="2db5a15e45c348362ce43e64d992a94fa7834d6c" translate="yes" xml:space="preserve">
          <source>The same holds true for non-existent keys, that are considered as a stream of zero bytes up to the length of the longest string.</source>
          <target state="translated">존재하지 않는 키에 대해서도 마찬가지입니다.이 키는 가장 긴 문자열의 길이까지 0 바이트 스트림으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="459993ded23b09fc27e5d6a4bf1ae20c56fbcf0c" translate="yes" xml:space="preserve">
          <source>The save parameter is a single string of space-separated integers. Every pair of integers represent a seconds/modifications threshold.</source>
          <target state="translated">save 매개 변수는 공백으로 구분 된 정수의 단일 문자열입니다. 모든 정수 쌍은 초 / 수정 임계 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="19337abd9b3767724cccba46357082deb732a2c0" translate="yes" xml:space="preserve">
          <source>The score values should be the string representation of a double precision floating point number. &lt;code&gt;+inf&lt;/code&gt; and &lt;code&gt;-inf&lt;/code&gt; values are valid values as well.</source>
          <target state="translated">점수 값은 배정 밀도 부동 소수점 숫자의 문자열 표현이어야합니다. &lt;code&gt;+inf&lt;/code&gt; 및 &lt;code&gt;-inf&lt;/code&gt; 값도 유효한 값입니다.</target>
        </trans-unit>
        <trans-unit id="8704ce1cdf5da36cc8175add936925537e2b6762" translate="yes" xml:space="preserve">
          <source>The script is guaranteed to stay in the script cache forever (unless &lt;code&gt;SCRIPT
FLUSH&lt;/code&gt; is called).</source>
          <target state="translated">스크립트는 &lt;code&gt;SCRIPT FLUSH&lt;/code&gt; 가 호출 되지 않는 한 스크립트 캐시에 영구적으로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="84e6859345305305b03236c94f49ebcdfaf9f284" translate="yes" xml:space="preserve">
          <source>The script must always evaluates the same Redis &lt;em&gt;write&lt;/em&gt; commands with the same arguments given the same input data set. Operations performed by the script cannot depend on any hidden (non-explicit) information or state that may change as script execution proceeds or between different executions of the script, nor can it depend on any external input from I/O devices.</source>
          <target state="translated">스크립트는 항상 동일한 입력 데이터 세트에서 동일한 인수를 사용 하여 동일한 Redis &lt;em&gt;쓰기&lt;/em&gt; 명령을 평가해야합니다 . 스크립트가 수행하는 작업은 스크립트 실행이 진행됨에 따라 또는 다른 스크립트 실행간에 변경 될 수있는 숨겨진 (명시 적이 지 않은) 정보 또는 상태에 의존 할 수 없으며 I / O 장치의 외부 입력에 의존 할 수도 없습니다.</target>
        </trans-unit>
        <trans-unit id="f6f50abe88117410baf6ae78d63eac9d06193d38" translate="yes" xml:space="preserve">
          <source>The script should be called with &lt;code&gt;EVAL ...script... 1 resource-name token-value&lt;/code&gt;</source>
          <target state="translated">스크립트는 &lt;code&gt;EVAL ...script... 1 resource-name token-value&lt;/code&gt; 로 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="ae5f9a8c3637986eaac0c1b5c2a821ed62bfff96" translate="yes" xml:space="preserve">
          <source>The second argument of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is the number of arguments that follows the script (starting from the third argument) that represent Redis key names. The arguments can be accessed by Lua using the &lt;code&gt;KEYS&lt;/code&gt; global variable in the form of a one-based array (so &lt;code&gt;KEYS[1]&lt;/code&gt;, &lt;code&gt;KEYS[2]&lt;/code&gt;, ...).</source>
          <target state="translated">&lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 의 두 번째 인수 는 Redis 키 이름을 나타내는 스크립트 (세 번째 인수에서 시작) 뒤에 오는 인수의 수입니다. 인수는 1 기반 배열 형식의 &lt;code&gt;KEYS&lt;/code&gt; 전역 변수를 사용하여 Lua에서 액세스 할 수 있습니다 (따라서 &lt;code&gt;KEYS[1]&lt;/code&gt; , &lt;code&gt;KEYS[2]&lt;/code&gt; , ...).</target>
        </trans-unit>
        <trans-unit id="5e06049c7fb2a08a77ed966e80b1bd0de88bb6c2" translate="yes" xml:space="preserve">
          <source>The semantic change between patch level releases was needed since the old behavior was inherently incompatible with the Redis replication layer and was the cause of bugs.</source>
          <target state="translated">이전 동작은 본질적으로 Redis 복제 계층과 호환되지 않으며 버그의 원인이 되었기 때문에 패치 레벨 릴리스 간의 시맨틱 변경이 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="c86d0b330e63015ff6018ffba522da6d3c2c8fb8" translate="yes" xml:space="preserve">
          <source>The sentinel output is composed of the following parts:</source>
          <target state="translated">센티넬 출력은 다음과 같은 부분으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="295a39c211fe9b12478b873df477a317d327e2b4" translate="yes" xml:space="preserve">
          <source>The serialization format is opaque and non-standard, however it has a few semantic characteristics:</source>
          <target state="translated">직렬화 형식은 불투명하고 비표준이지만 몇 가지 시맨틱 특성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="06e5cb4e4d36f51aabfd49438bd236dcf9c4976a" translate="yes" xml:space="preserve">
          <source>The serialized value does NOT contain expire information. In order to capture the time to live of the current value the &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; command should be used.</source>
          <target state="translated">직렬화 된 값은 만료 정보를 포함하지 않습니다. 현재 값을 유지하기 위해 &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; 명령을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd5acc612a2b52a80de5b2a3e24e38f5ba00302b" translate="yes" xml:space="preserve">
          <source>The size of the string stored in the destination key, that is equal to the size of the longest input string.</source>
          <target state="translated">대상 키에 저장된 문자열의 크기로, 가장 긴 입력 문자열의 크기와 같습니다.</target>
        </trans-unit>
        <trans-unit id="1a0a5df2b74e73a15c2817e253d14a10935a2191" translate="yes" xml:space="preserve">
          <source>The slow log is accumulated in memory, so no file is written with information about the slow command executions. This makes the slow log remarkably fast at the point that you can enable the logging of all the commands (setting the &lt;em&gt;slowlog-log-slower-than&lt;/em&gt; config parameter to zero) with minor performance hit.</source>
          <target state="translated">느린 로그는 메모리에 누적되므로 느린 명령 실행에 대한 정보로 파일을 쓰지 않습니다. 이로 인해 약간의 성능 저하 로 모든 명령의 로깅을 활성화 할 수있는 지점 ( &lt;em&gt;slowlog-log-slower-than&lt;/em&gt; config 매개 변수를 0으로 설정)에서 느린 로그가 현저히 빨라 &lt;em&gt;집니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4eaa8de726819dc3e71079d7a6f328e12fd9ddc2" translate="yes" xml:space="preserve">
          <source>The sparse representation uses a run-length encoding optimized to store efficiently a big number of registers set to zero. The dense representation is a Redis string of 12288 bytes in order to store 16384 6-bit counters. The need for the double representation comes from the fact that using 12k (which is the dense representation memory requirement) to encode just a few registers for smaller cardinalities is extremely suboptimal.</source>
          <target state="translated">희소 표현은 0으로 설정된 많은 수의 레지스터를 효율적으로 저장하도록 최적화 된 실행 길이 인코딩을 사용합니다. 밀도가 높은 표현은 16384 개의 6 비트 카운터를 저장하기위한 12288 바이트의 Redis 문자열입니다. 더 작은 카디널리티에 대한 몇 개의 레지스터 만 인코딩하기 위해 12k (고밀도 표현 메모리 요구 사항)를 사용하는 것은 이중 표현이 필요하다는 사실에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="8eeebccfe9d0cfc87769de4a2c07747fec580fbc" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;$&lt;/code&gt; ID.</source>
          <target state="translated">특별한 &lt;code&gt;$&lt;/code&gt; ID.</target>
        </trans-unit>
        <trans-unit id="0f067eeaba3e5a87a3236774a27fada6161ea70f" translate="yes" xml:space="preserve">
          <source>The special &lt;code&gt;&amp;gt;&lt;/code&gt; ID, which means that the consumer want to receive only messages that were &lt;em&gt;never delivered to any other consumer&lt;/em&gt;. It just means, give me new messages.</source>
          <target state="translated">특수 &lt;code&gt;&amp;gt;&lt;/code&gt; ID는 소비자가 &lt;em&gt;다른 소비자에게 전달되지 않은&lt;/em&gt; 메시지 만 받기를 원한다는 것을 의미합니다 . 그것은 단지 새로운 메시지를 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="5029fc6d051bb809efc7fcb4a44af5a544f6b49f" translate="yes" xml:space="preserve">
          <source>The specified node ID does not identify the instance we are sending the command to.</source>
          <target state="translated">지정된 노드 ID는 명령을 보내는 인스턴스를 식별하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15f8e4eecac9b5616dbc97abb4f74fd51bce6356" translate="yes" xml:space="preserve">
          <source>The specified node ID exists in its nodes table.</source>
          <target state="translated">지정된 노드 ID가 해당 노드 테이블에 있습니다.</target>
        </trans-unit>
        <trans-unit id="07565949c7a13614b4cf396e3dee4474076dd98c" translate="yes" xml:space="preserve">
          <source>The specified node ID is a master.</source>
          <target state="translated">지정된 노드 ID가 마스터입니다.</target>
        </trans-unit>
        <trans-unit id="92c45a066b5df5b3300ad8d74734dc668cec5a44" translate="yes" xml:space="preserve">
          <source>The specified node ID is not found in the nodes table.</source>
          <target state="translated">지정된 노드 ID를 노드 테이블에서 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dadcfd8e793bf395f94eff22f99b0da2a7a715b6" translate="yes" xml:space="preserve">
          <source>The specified node gets removed from the nodes table.</source>
          <target state="translated">지정된 노드가 노드 테이블에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3be929a4c6ff231339b330125852213fb5229ce4" translate="yes" xml:space="preserve">
          <source>The state of the replication from the point of view of the master, that can be &lt;code&gt;connect&lt;/code&gt; (the instance needs to connect to its master), &lt;code&gt;connecting&lt;/code&gt; (the master-replica connection is in progress), &lt;code&gt;sync&lt;/code&gt; (the master and replica are trying to perform the synchronization), &lt;code&gt;connected&lt;/code&gt; (the replica is online).</source>
          <target state="translated">&lt;code&gt;connect&lt;/code&gt; 수있는 마스터 관점에서 복제 상태 (인스턴스를 마스터에 연결해야 함), &lt;code&gt;connecting&lt;/code&gt; (마스터-복제본 연결이 진행 중), &lt;code&gt;sync&lt;/code&gt; (마스터 및 복제본이 시도 중) 동기화), &lt;code&gt;connected&lt;/code&gt; (복제본이 온라인 상태 임).</target>
        </trans-unit>
        <trans-unit id="b8b0d67ec2d33e9415285fa0b1b04c01c7c00db9" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;-&amp;gt;&lt;/code&gt; is used to separate the key name from the hash field name. The key is substituted as documented above, and the hash stored at the resulting key is accessed to retrieve the specified hash field.</source>
          <target state="translated">문자열 &lt;code&gt;-&amp;gt;&lt;/code&gt; 는 키 이름을 해시 필드 이름과 구분하는 데 사용됩니다. 키는 위에서 설명한대로 대체되며 결과 키에 저장된 해시는 액세스하여 지정된 해시 필드를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="f708ccbae2afe95a0cd4653de56c8fb34c79374e" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;master&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;master&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2940a9d939b4548e348a547825fc4662aaec04e" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;sentinel&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;sentinel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d8519eae0e62aff504d921a1adc6159ed001fa3" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;slave&lt;/code&gt;, because of backward compatbility (see note at the end of this page).</source>
          <target state="translated">이전 버전과의 호환성으로 인해 문자열 &lt;code&gt;slave&lt;/code&gt; 입니다 (이 페이지 끝의 참고 참조).</target>
        </trans-unit>
        <trans-unit id="6831b1a65326ef3cc261059e475703f978f1b6bb" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;slave&lt;/code&gt;, because of backward compatibility (see note at the end of this page).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a409de83f682db65c898664c9dbb138b1160b8f1" translate="yes" xml:space="preserve">
          <source>The summary provides a good overview, but sometimes we are interested in the details. In order to see all the pending messages with more associated information we need to also pass a range of IDs, in a similar way we do it with &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;, and a non optional &lt;em&gt;count&lt;/em&gt; argument, to limit the number of messages returned per call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2cc70797e244120c92cdce0be9d797bbb5993d5" translate="yes" xml:space="preserve">
          <source>The supported types are up to 64 bits for signed integers, and up to 63 bits for unsigned integers. This limitation with unsigned integers is due to the fact that currently the Redis protocol is unable to return 64 bit unsigned integers as replies.</source>
          <target state="translated">지원되는 유형은 부호있는 정수의 경우 최대 64 비트이고 부호없는 정수의 경우 최대 63 비트입니다. 부호없는 정수에 대한이 제한은 현재 Redis 프로토콜이 64 비트 부호없는 정수를 응답으로 반환 할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="7a2d3466f691698508a75fad6644713be3c44a8f" translate="yes" xml:space="preserve">
          <source>The symmetric command used to alter the configuration at run time is &lt;code&gt;CONFIG
SET&lt;/code&gt;.</source>
          <target state="translated">런타임시 구성을 변경하는 데 사용되는 대칭 명령은 &lt;code&gt;CONFIG SET&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c4ef14ef5924effb0e2166473b48d643f3dd0b5a" translate="yes" xml:space="preserve">
          <source>The system administrator sends a &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; command to force a node to meet another one.</source>
          <target state="translated">시스템 관리자는 &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; 명령을 보내 노드가 다른 노드를 강제로 실행하도록합니다.</target>
        </trans-unit>
        <trans-unit id="f7dd65cc5a619424783dd395e5066f1952bf62a3" translate="yes" xml:space="preserve">
          <source>The third nested reply is guaranteed to be the IP/Port pair of the master instance for the slot range. All IP/Port pairs after the third nested reply are replicas of the master.</source>
          <target state="translated">세 번째로 중첩 된 응답은 슬롯 범위에 대한 마스터 인스턴스의 IP / 포트 쌍이어야합니다. 세 번째 중첩 응답 후의 모든 IP / 포트 쌍은 마스터의 복제본입니다.</target>
        </trans-unit>
        <trans-unit id="bc7c54ea663acc1cd16d645f286e49bdb17828f2" translate="yes" xml:space="preserve">
          <source>The time-complexity for this operation is O(N), N being the number of keys in all existing databases.</source>
          <target state="translated">이 작업의 시간 복잡성은 O (N)이며 N은 모든 기존 데이터베이스의 키 수입니다.</target>
        </trans-unit>
        <trans-unit id="5dd2a246bdbf984a712d84e324dfcd54e3e83cfb" translate="yes" xml:space="preserve">
          <source>The time-complexity for this operation is O(N), N being the number of keys in the database.</source>
          <target state="translated">이 연산의 시간 복잡도는 O (N)이며 N은 데이터베이스의 키 수입니다.</target>
        </trans-unit>
        <trans-unit id="33b9dc1580854319ae2c493dffcae592f1834dfc" translate="yes" xml:space="preserve">
          <source>The timeout can also be cleared, turning the key back into a persistent key, using the &lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;persist&quot;&gt;PERSIST&lt;/a&gt; 명령을 사용하여 키를 영구 키로 다시 전환하여 시간 초과를 지울 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a3cd5936158e61d7536637d6c3696dfb0161419" translate="yes" xml:space="preserve">
          <source>The timeout specifies the maximum idle time in any moment of the communication with the destination instance in milliseconds. This means that the operation does not need to be completed within the specified amount of milliseconds, but that the transfer should make progresses without blocking for more than the specified amount of milliseconds.</source>
          <target state="translated">시간 초과는 대상 인스턴스와 통신하는 순간의 최대 유휴 시간을 밀리 초 단위로 지정합니다. 즉, 지정된 밀리 초 이내에 작업을 완료 할 필요는 없지만 지정된 밀리 초 이상 동안 블로킹하지 않고 전송을 진행해야합니다.</target>
        </trans-unit>
        <trans-unit id="47a97f0f97c34f511b051b78756091a74729e20b" translate="yes" xml:space="preserve">
          <source>The timeout will only be cleared by commands that delete or overwrite the contents of the key, including &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;, &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt;, &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; and all the &lt;code&gt;*STORE&lt;/code&gt; commands. This means that all the operations that conceptually &lt;em&gt;alter&lt;/em&gt; the value stored at the key without replacing it with a new one will leave the timeout untouched. For instance, incrementing the value of a key with &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;, pushing a new value into a list with &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, or altering the field value of a hash with &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; are all operations that will leave the timeout untouched.</source>
          <target state="translated">제한 시간은 &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; , &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; , &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; 및 모든 &lt;code&gt;*STORE&lt;/code&gt; 명령을 포함하여 키의 내용을 삭제하거나 겹쳐 쓰는 명령으로 만 지워집니다 . 즉 , 키에 저장된 값을 새로운 값으로 &lt;em&gt;바꾸지&lt;/em&gt; 않고 개념적으로 &lt;em&gt;변경&lt;/em&gt; 하는 모든 작업 은 시간 초과를 그대로 유지합니다. 예를 가진 키의 값 증가를 위해 &lt;a href=&quot;incr&quot;&gt;INCR을&lt;/a&gt; 가진 목록에 새 값을 밀어 &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; , 또는와 해시의 필드 값 변경 &lt;a href=&quot;hset&quot;&gt;HSET을&lt;/a&gt; 제한 시간은 그대로두고 모든 작업입니다.</target>
        </trans-unit>
        <trans-unit id="b4902022e2711d4049af153f6960e9c07559e3db" translate="yes" xml:space="preserve">
          <source>The unit must be one of the following, and defaults to meters:</source>
          <target state="translated">단위는 다음 중 하나 여야하며 기본값은 미터입니다.</target>
        </trans-unit>
        <trans-unit id="a995cbd615ab3e6d82df762d54a3d2493e68cc0e" translate="yes" xml:space="preserve">
          <source>The unix timestamp at which the logged command was processed.</source>
          <target state="translated">기록 된 명령이 처리 된 유닉스 타임 스탬프입니다.</target>
        </trans-unit>
        <trans-unit id="a0310f88660618094c01bca5ea0d0463bbd02002" translate="yes" xml:space="preserve">
          <source>The user just turned on AOF, and the server triggered the first AOF rewrite in order to create the initial AOF file. In this context, stopping will result in losing the dataset at all: once restarted, the server will potentially have AOF enabled without having any AOF file at all.</source>
          <target state="translated">사용자가 방금 AOF를 켜고 서버가 초기 AOF 파일을 작성하기 위해 첫 번째 AOF 재 작성을 트리거했습니다. 이 컨텍스트에서 중지하면 데이터 집합이 전혀 손실됩니다. 다시 시작하면 서버에서 AOF 파일을 전혀 사용하지 않고도 AOF를 사용할 수있게됩니다.</target>
        </trans-unit>
        <trans-unit id="5f17b8b7fd14b72046eefe6ae0e142f682927503" translate="yes" xml:space="preserve">
          <source>The user should be aware that if the same existing key is mentioned in the arguments multiple times, it will be counted multiple times. So if &lt;code&gt;somekey&lt;/code&gt; exists, &lt;code&gt;EXISTS somekey somekey&lt;/code&gt; will return 2.</source>
          <target state="translated">사용자는 인수에 동일한 기존 키가 여러 번 언급되면 여러 번 계산됨을 알고 있어야합니다. 따라서 &lt;code&gt;somekey&lt;/code&gt; 가 있으면 존재하는 &lt;code&gt;EXISTS somekey somekey&lt;/code&gt; 는 2를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a2b1b03bb92333675d117bc7fc8c0c76fc472f63" translate="yes" xml:space="preserve">
          <source>The user should take in mind that single-key and multiple-keys executions of this command are semantically different and have different performances.</source>
          <target state="translated">사용자는이 명령의 단일 키 및 다중 키 실행이 의미 적으로 다르고 다른 성능을 가지고 있음을 명심해야합니다.</target>
        </trans-unit>
        <trans-unit id="aee2053c45b6ced184922e49824bb87ce4f26e87" translate="yes" xml:space="preserve">
          <source>The vertical labels under each graph column represent the amount of seconds, minutes, hours or days ago the event happened. For example &quot;15s&quot; means that the first graphed event happened 15 seconds ago.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0c79b31b353c9ce51c111498c89af1634cee6b" translate="yes" xml:space="preserve">
          <source>The way the sorted set is populated is using a technique called &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt;. Latitude and Longitude bits are interleaved in order to form an unique 52 bit integer. We know that a sorted set double score can represent a 52 bit integer without losing precision.</source>
          <target state="translated">정렬 된 세트가 채워지는 방식은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Geohash&lt;/a&gt; 라는 기술을 사용하는 것 입니다. 고유 한 52 비트 정수를 형성하기 위해 위도 및 경도 비트가 인터리브됩니다. 정렬 된 세트 더블 스코어는 정밀도를 잃지 않고 52 비트 정수를 나타낼 수 있음을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b31bb2e561758eaef35a12c00599f8b3a9ccbe4" translate="yes" xml:space="preserve">
          <source>Then instead of starting the iteration again from &lt;code&gt;-&lt;/code&gt;, as the start of the range we use the entry ID of the &lt;em&gt;last&lt;/em&gt; entry returned by the previous &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; call as an exclusive interval.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="473281da4300480447326ee40d8d889bb9d90481" translate="yes" xml:space="preserve">
          <source>Then instead of starting the iteration again from &lt;code&gt;-&lt;/code&gt;, as the start of the range we use the entry ID of the &lt;em&gt;last&lt;/em&gt; entry returned by the previous &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; call, adding the sequence part of the ID by one.</source>
          <target state="translated">그런 다음 &lt;code&gt;-&lt;/code&gt; 에서 반복을 다시 시작하는 대신 범위의 시작으로 이전 &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 호출에서 반환 된 &lt;em&gt;마지막&lt;/em&gt; 항목 의 항목 ID를 사용하고 ID의 시퀀스 부분을 하나씩 추가합니다.</target>
        </trans-unit>
        <trans-unit id="49d73108f34c912bc3dcd46d706878a2b1cfa83b" translate="yes" xml:space="preserve">
          <source>Then suddenly that consumer fails forever.</source>
          <target state="translated">그리고 갑자기 그 소비자는 영원히 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c54ead856d23cc39661d8102bdb6330ddb30ed3d" translate="yes" xml:space="preserve">
          <source>Then we may want to know what commands are part of a given category:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66921f715545a310ecff4dca64b25267fdd5efb" translate="yes" xml:space="preserve">
          <source>There are also optional fields emitted only by Redis 4.0 or greater:</source>
          <target state="translated">Redis 4.0 이상에서만 방출되는 선택적 필드도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a381e0a250a57263ea1da7d6465921f290bc2868" translate="yes" xml:space="preserve">
          <source>There are cases when you need to set all the bits of single bitmap at once, for example when initializing it to a default non-zero value. It is possible to do this with multiple calls to the &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; command, one for each bit that needs to be set. However, so as an optimization you can use a single &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command to set the entire bitmap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf4557f2ee4da2fe1ae76ce2cecd829e57c75d9" translate="yes" xml:space="preserve">
          <source>There are conditions when we want just to terminate a Redis instance ASAP, regardless of what its content is. In such a case, the right combination of commands is to send a &lt;strong&gt;CONFIG appendonly no&lt;/strong&gt; followed by a &lt;strong&gt;SHUTDOWN NOSAVE&lt;/strong&gt;. The first command will turn off the AOF if needed, and will terminate the AOF rewriting child if there is one active. The second command will not have any problem to execute since the AOF is no longer enabled.</source>
          <target state="translated">컨텐츠가 무엇이든 관계없이 Redis 인스턴스를 최대한 빨리 종료하려는 조건이 있습니다. 이러한 경우 명령의 올바른 조합은 &lt;strong&gt;CONFIG appendonly no&lt;/strong&gt; 다음에 &lt;strong&gt;SHUTDOWN NOSAVE를 보내는 것&lt;/strong&gt; 입니다. 첫 번째 명령은 필요한 경우 AOF를 끄고 활성화 된 AOF가 있으면 AOF 다시 쓰기 하위를 종료합니다. AOF가 더 이상 활성화되어 있지 않기 때문에 두 번째 명령에는 아무런 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="158a7d63bcc769d78e3493a2bc55c7a4ee6bce03" translate="yes" xml:space="preserve">
          <source>There are multiple clients rotating the list: they'll fetch different elements, until all the elements of the list are visited, and the process restarts.</source>
          <target state="translated">목록을 회전시키는 여러 클라이언트가 있습니다. 목록의 모든 요소가 방문 될 때까지 다른 요소를 가져오고 프로세스가 다시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="bdda3afdb8163e659ca9981491dbe7bcadb74afd" translate="yes" xml:space="preserve">
          <source>There are situations where this is not enough, and we want a replica to failover without any agreement with the rest of the cluster. A real world use case for this is to mass promote replicas in a different data center to masters in order to perform a data center switch, while all the masters are down or partitioned away.</source>
          <target state="translated">이것으로 충분하지 않은 상황이 있으며 나머지 클러스터와의 동의없이 복제본이 페일 오버되기를 원합니다. 이에 대한 실제 사용 사례는 모든 마스터가 다운되거나 분할 된 상태에서 데이터 센터 스위치를 수행하기 위해 다른 데이터 센터의 복제본을 마스터로 대량 승격하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6bd7c5396466fc74307415d5fb57447e1fc4a356" translate="yes" xml:space="preserve">
          <source>There are times when a list can receive multiple elements in the context of the same conceptual command:</source>
          <target state="translated">동일한 개념 명령의 컨텍스트에서 목록이 여러 요소를 수신 할 수있는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e2a3e6a950f5d8a609385be1af06951e77dc2ea" translate="yes" xml:space="preserve">
          <source>There are two helper functions to return Redis types from Lua.</source>
          <target state="translated">Lua에서 Redis 유형을 반환하는 두 가지 도우미 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="be8d4180a42a37a500975b93ef1e55ade0e6286d" translate="yes" xml:space="preserve">
          <source>There are two ways in order to specify offsets in the bitfield command. If a number without any prefix is specified, it is used just as a zero based bit offset inside the string.</source>
          <target state="translated">bitfield 명령에서 오프셋을 지정하는 방법에는 두 가지가 있습니다. 접두사가없는 숫자를 지정하면 문자열 내에서 0 기반 비트 오프셋으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d75f55602fddc93ba9011e7393a6bc36a64ba5a7" translate="yes" xml:space="preserve">
          <source>There is &lt;a href=&quot;http://www.lua.org/pil/19.1.html&quot;&gt;no simple way to have nils inside Lua arrays&lt;/a&gt;, this is a result of Lua table semantics, so when Redis converts a Lua array into Redis protocol the conversion is stopped if a nil is encountered.</source>
          <target state="translated">&lt;a href=&quot;http://www.lua.org/pil/19.1.html&quot;&gt;Lua 배열 내에&lt;/a&gt; nil 을 갖는 간단한 방법 은 없습니다 . 이것은 Lua 테이블 의미의 결과이므로 Redis가 Lua 배열을 Redis 프로토콜로 변환 할 때 nil이 발생하면 변환이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="1181df382608fdc99dac69533a65959f383591cd" translate="yes" xml:space="preserve">
          <source>There is a different way to fix this issue without using scripting, but using Redis lists instead of counters. The implementation is more complex and uses more advanced features but has the advantage of remembering the IP addresses of the clients currently performing an API call, that may be useful or not depending on the application.</source>
          <target state="translated">스크립팅을 사용하지 않고 카운터 대신 Redis 목록을 사용하여이 문제를 해결하는 다른 방법이 있습니다. 구현은 더 복잡하고 고급 기능을 사용하지만 현재 API 호출을 수행하는 클라이언트의 IP 주소를 기억할 수 있다는 이점이 있습니다. 이는 응용 프로그램에 따라 유용하거나 그렇지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2318fb4edc6b835e7f3009f7b1cfc0bceadc13e5" translate="yes" xml:space="preserve">
          <source>There is a stream with an associated consumer group.</source>
          <target state="translated">연관된 소비자 그룹이있는 스트림이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5813da89c7be6046d913f1f5df04a5cf2e30994" translate="yes" xml:space="preserve">
          <source>There is an additional Lua-to-Redis conversion rule that has no corresponding Redis to Lua conversion rule:</source>
          <target state="translated">해당 Redis에서 Lua 로의 변환 규칙이없는 추가 Lua-to-Redis 변환 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c2e8ff8c03c52243caafd83d9c21a0190459a1a" translate="yes" xml:space="preserve">
          <source>There is another subcommand that only changes the behavior of successive &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; subcommand calls by setting the overflow behavior:</source>
          <target state="translated">오버 플로우 동작을 설정하여 연속적인 &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; 부속 명령 호출 의 동작 만 변경하는 다른 부속 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad004d677ac8d1220049f68515cbe366e16611b0" translate="yes" xml:space="preserve">
          <source>There is no difference between using the helper functions or directly returning the table with the specified format, so the following two forms are equivalent:</source>
          <target state="translated">헬퍼 함수를 ​​사용하거나 지정된 형식으로 테이블을 직접 리턴하는 것에는 차이가 없으므로 다음 두 형식은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="688604faa0496cccdc56e5c3415b7e254e6c2086" translate="yes" xml:space="preserve">
          <source>There is no guarantee that it is actually the higher configuration epoch, since, for example, we can use the &lt;strong&gt;TAKEOVER&lt;/strong&gt; option within a minority, nor any message exchange is performed to generate the new configuration epoch.</source>
          <target state="translated">예를 들어, &lt;strong&gt;TAKEOVER&lt;/strong&gt; 옵션을 소수 내에서 사용할 수도 있고 , 새로운 구성 에포크를 생성하기 위해 메시지 교환을 수행하지 않기 때문에 실제로는 더 높은 구성 에포크라는 보장이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="f9d2324c27d0bdf5977e444923fed05e29f7f2d5" translate="yes" xml:space="preserve">
          <source>There is no limit to the length of the name that can be assigned if not the usual limits of the Redis string type (512 MB). However it is not possible to use spaces in the connection name as this would violate the format of the &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; reply.</source>
          <target state="translated">Redis 문자열 유형 (512MB)의 일반적인 제한이 아닌 경우 할당 할 수있는 이름의 길이에는 제한이 없습니다. 그러나 &lt;a href=&quot;client-list&quot;&gt;CLIENT LIST&lt;/a&gt; 응답 의 형식을 위반하므로 연결 이름에 공백을 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="939fac74be0ef5905e18fc0965563dbdb047a83f" translate="yes" xml:space="preserve">
          <source>There is one key thing to understand: in case Lua replies with RESP3 types, but the connection calling Lua is in RESP2 mode, Redis will automatically convert the RESP3 protocol to RESP2 compatible protocol, as it happens for normal commands. For instance returning a map type to a connection in RESP2 mode will have the effect of returning a flat array of fields and values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5147f1530dd4898c039cd6ac5ba9eae79430a62" translate="yes" xml:space="preserve">
          <source>These are the counters that are reset:</source>
          <target state="translated">재설정 된 카운터는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f9525d03220e878ebb457481ab1b1546ad897b4" translate="yes" xml:space="preserve">
          <source>These bytes are pure overhead at the moment as no actual data is stored, and are used for maintaining the internal data structures of the server. Longer keys and values show asymptotically linear usage.</source>
          <target state="translated">이러한 바이트는 실제 데이터가 저장되지 않은 순간 순수한 오버 헤드이며 서버의 내부 데이터 구조를 유지하는 데 사용됩니다. 긴 키와 값은 무증상 선형 사용법을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="0c0d7819e41ea841eca9c54ef01aab00acdd805e" translate="yes" xml:space="preserve">
          <source>These offsets can also be negative numbers indicating offsets starting at the end of the list. For example, &lt;code&gt;-1&lt;/code&gt; is the last element of the list, &lt;code&gt;-2&lt;/code&gt; the penultimate, and so on.</source>
          <target state="translated">이 오프셋은 목록 끝에서 시작하는 오프셋을 나타내는 음수 일 수도 있습니다. 예를 들어, &lt;code&gt;-1&lt;/code&gt; 은 목록의 마지막 요소이고, &lt;code&gt;-2&lt;/code&gt; 는 두 번째입니다.</target>
        </trans-unit>
        <trans-unit id="3327f4f330ea4245b93a5884cfe66d7c642a01a1" translate="yes" xml:space="preserve">
          <source>These prerequisites are needed since usually, manually altering the configuration epoch of a node is unsafe, we want to be sure that the node with the higher configuration epoch value (that is the last that failed over) wins over other nodes in claiming the hash slots ownership.</source>
          <target state="translated">이러한 전제 조건은 일반적으로 노드의 구성 기간을 수동으로 변경하는 것이 안전하지 않기 때문에 필요합니다. 더 높은 구성 시간 값을 가진 노드 (마지막으로 실패한 노드)가 해시 슬롯을 청구 할 때 다른 노드보다 우선합니다 소유권.</target>
        </trans-unit>
        <trans-unit id="74cdd9a11d855a7fe9706564ff82f50aed545b21" translate="yes" xml:space="preserve">
          <source>They can be shortened removing characters from the right. It will lose precision but will still point to the same area.</source>
          <target state="translated">오른쪽에서 문자를 제거하여 단축 할 수 있습니다. 정밀도는 떨어지지 만 여전히 같은 영역을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="de21a5f9f7664481a629fd440bf41584926e640e" translate="yes" xml:space="preserve">
          <source>They correspond directly to the normal Redis log levels. Only logs emitted by scripting using a log level that is equal or greater than the currently configured Redis instance log level will be emitted.</source>
          <target state="translated">이들은 일반적인 Redis 로그 수준에 직접 해당합니다. 현재 구성된 Redis 인스턴스 로그 수준보다 크거나 같은 로그 수준을 사용하여 스크립팅으로 생성 된 로그 만 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="1163c9f8d8e2d599dd815fa54afcf7fcd4819d93" translate="yes" xml:space="preserve">
          <source>Things like using the system time, calling Redis random commands like &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt;, or using Lua random number generator, could result into scripts that will not always evaluate in the same way.</source>
          <target state="translated">시스템 시간 사용, &lt;a href=&quot;randomkey&quot;&gt;RANDOMKEY&lt;/a&gt; 와 같은 Redis 임의 명령 호출 또는 Lua 난수 생성기 사용 과 같은 경우 항상 동일한 방식으로 평가되지 않는 스크립트가 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a6c24e6bcae98d8b374c6b8a2cb2e847242de7f" translate="yes" xml:space="preserve">
          <source>Think at a Lua script where we perform an intersection between two sets. Pick five random elements, and create a new set with this five random elements. Finally we delete the temporary key representing the intersection between the two original sets. What we want to replicate is only the creation of the new set with the five elements. It's not useful to also replicate the commands creating the temporary key.</source>
          <target state="translated">두 세트 사이의 교차점을 수행하는 Lua 스크립트를 생각해보십시오. 5 개의 랜덤 요소를 선택하고이 5 개의 랜덤 요소로 새로운 세트를 만듭니다. 마지막으로 두 원본 세트 간의 교차점을 나타내는 임시 키를 삭제합니다. 우리가 복제하고자하는 것은 5 가지 요소를 가진 새로운 세트를 만드는 것입니다. 임시 키를 생성하는 명령을 복제하는 것도 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d05a95556307e74d8c3d500f8eaf5b432fd6a284" translate="yes" xml:space="preserve">
          <source>This avoids that a client will try to release the lock after the expire time deleting the key created by another client that acquired the lock later.</source>
          <target state="translated">이렇게하면 나중에 잠금을 획득 한 다른 클라이언트가 만든 키를 삭제하는 만료 시간이 지나면 클라이언트가 잠금을 해제하려고하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e05975c8ace39fb16ed1689fdd42d78b56751af2" translate="yes" xml:space="preserve">
          <source>This can be a problem with some application where we want a more reliable messaging system. When this is the case, please check the &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; command, that is a variant of &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; that adds the returned element to a target list before returning it to the client.</source>
          <target state="translated">보다 안정적인 메시징 시스템을 원하는 일부 응용 프로그램에서는 문제가 될 수 있습니다. 이 경우, &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; 명령을 확인하십시오. 이는 리턴 된 요소를 클라이언트에 리턴하기 전에 리턴 된 요소를 대상 목록에 추가하는 &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="7d43703d663f6362b0a28ec9100f4db91d08a310" translate="yes" xml:space="preserve">
          <source>This can be fixed easily turning the &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; with optional &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; into a Lua script that is send using the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command (only available since Redis version 2.6).</source>
          <target state="translated">이는 선택적인 &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; 를 사용하여 &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; 을 &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 명령을 사용하여 전송되는 Lua 스크립트로 쉽게 전환 할 수 있습니다 (Redis 버전 2.6 이후에만 사용 가능).</target>
        </trans-unit>
        <trans-unit id="72b1b07f3e247301ca1521cd5c3a4e2df6db2967" translate="yes" xml:space="preserve">
          <source>This command accepts one or more SHA1 digests and returns a list of ones or zeros to signal if the scripts are already defined or not inside the script cache. This can be useful before a pipelining operation to ensure that scripts are loaded (and if not, to load them using &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt;) so that the pipelining operation can be performed solely using &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; instead of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; to save bandwidth.</source>
          <target state="translated">이 명령은 하나 이상의 SHA1 다이제스트를 승인하고 스크립트가 이미 정의되었거나 스크립트 캐시 내에없는 경우 신호를 보내기 위해 1 또는 0의 목록을 리턴합니다. 이는 파이프 라이닝 조작 전에 스크립트를로드하고 (그렇지 않은 경우 &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD를&lt;/a&gt; 사용하여 스크립트 를로드하도록 ) &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 대신 &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; 를 사용하여 파이프 라이닝 조작을 수행하여 대역폭을 절약 할 수 있도록하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dcfeceb3df3a9d1203f8df4602183697ddf7897a" translate="yes" xml:space="preserve">
          <source>This command accepts two non mandatory options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43467785cd12ce45437b2b4eecb4c3b0671ef615" translate="yes" xml:space="preserve">
          <source>This command blocks the current client until all the previous write commands are successfully transferred and acknowledged by at least the specified number of replicas. If the timeout, specified in milliseconds, is reached, the command returns even if the specified number of replicas were not yet reached.</source>
          <target state="translated">이 명령은 모든 이전 쓰기 명령이 지정된 수의 복제본에 의해 성공적으로 전송되고 승인 될 때까지 현재 클라이언트를 차단합니다. 밀리 초로 지정된 시간 초과에 도달하면 지정된 수의 복제본에 아직 도달하지 않은 경우에도 명령이 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7a62033f131f44c3fe86c2c4ab2196a020d7e337" translate="yes" xml:space="preserve">
          <source>This command can be called with multiple streams if we want to read at the same time from a number of keys. This is a key feature of &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; because especially when blocking with &lt;strong&gt;BLOCK&lt;/strong&gt;, to be able to listen with a single connection to multiple keys is a vital feature.</source>
          <target state="translated">여러 키에서 동시에 읽으려면이 명령을 여러 스트림으로 호출 할 수 있습니다. 이는 특히 &lt;strong&gt;BLOCK으로&lt;/strong&gt; 차단할 때 여러 키에 대한 단일 연결로 청취 할 수 있는 것이 중요한 기능이므로 &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; 의 주요 기능입니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ea63b36c2daa60b6b416fb9f70368e117feeda86" translate="yes" xml:space="preserve">
          <source>This command can unblock, from a different connection, a client blocked in a blocking operation, such as for instance &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; or &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; or &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;.</source>
          <target state="translated">이 명령은 다른 연결에서 &lt;a href=&quot;brpop&quot;&gt;BRPOP&lt;/a&gt; 또는 &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; 또는 &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; 와 같은 차단 작업에서 차단 된 클라이언트를 차단 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d6f9176a21b0c3f64b6d59331a54d4112960a8c" translate="yes" xml:space="preserve">
          <source>This command comes in place of the now deprecated &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;. Doing &lt;code&gt;BLMOVE RIGHT LEFT&lt;/code&gt; is equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae4b7969f891e0631e6b36c849a8182bdc4a8ebc" translate="yes" xml:space="preserve">
          <source>This command comes in place of the now deprecated &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt;. Doing &lt;code&gt;LMOVE RIGHT LEFT&lt;/code&gt; is equivalent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f02c76dc59dbdc13fe5dd0f4a1731c43a14ddd0" translate="yes" xml:space="preserve">
          <source>This command controls the tracking of the keys in the next command executed by the connection, when tracking is enabled in &lt;code&gt;OPTIN&lt;/code&gt; or &lt;code&gt;OPTOUT&lt;/code&gt; mode. Please check the &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;client side caching documentation&lt;/a&gt; for background information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2f8b881a98ea2d40bfed754bab550d934301142" translate="yes" xml:space="preserve">
          <source>This command copies the value stored at the &lt;code&gt;source&lt;/code&gt; key to the &lt;code&gt;destination&lt;/code&gt; key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cff095ce217da2e3523c4effed757c97e397dac6" translate="yes" xml:space="preserve">
          <source>This command enables the tracking feature of the Redis server, that is used for &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;server assisted client side caching&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66b31d1c2eb93e0473a8a5492fa02a9c8c2c2d69" translate="yes" xml:space="preserve">
          <source>This command is currently implemented only when using &lt;strong&gt;jemalloc&lt;/strong&gt; as an allocator, and evaluates to a benign NOOP for all others.</source>
          <target state="translated">이 명령은 현재 &lt;strong&gt;jemalloc&lt;/strong&gt; 을 할당 &lt;strong&gt;자로&lt;/strong&gt; 사용하는 경우에만 구현되며 다른 모든 사용자에 대해 양성 NOOP로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="932344d8190e35db9df40d94e5197fd7c1d13364" translate="yes" xml:space="preserve">
          <source>This command is equal to &lt;a href=&quot;sdiff&quot;&gt;SDIFF&lt;/a&gt;, but instead of returning the resulting set, it is stored in &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">이 명령은 &lt;a href=&quot;sdiff&quot;&gt;SDIFF&lt;/a&gt; 와 동일 하지만 결과 집합을 반환하는 대신 &lt;code&gt;destination&lt;/code&gt; 에 저장 됩니다 .</target>
        </trans-unit>
        <trans-unit id="507f9a2dec2a09af16c3fc0fe75de6b0370a3364" translate="yes" xml:space="preserve">
          <source>This command is equal to &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt;, but instead of returning the resulting set, it is stored in &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">이 명령은 &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt; 와 동일 하지만 결과 세트를 리턴하는 대신 &lt;code&gt;destination&lt;/code&gt; 에 저장 됩니다 .</target>
        </trans-unit>
        <trans-unit id="86af64e6b7731ea035f82e2694ba78f231528031" translate="yes" xml:space="preserve">
          <source>This command is equal to &lt;a href=&quot;sunion&quot;&gt;SUNION&lt;/a&gt;, but instead of returning the resulting set, it is stored in &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">이 명령은 &lt;a href=&quot;sunion&quot;&gt;SUNION&lt;/a&gt; 과 동일 하지만 결과 집합을 반환하는 대신 &lt;code&gt;destination&lt;/code&gt; 에 저장 됩니다 .</target>
        </trans-unit>
        <trans-unit id="5e32e7ca3fa8b824bc6b60a666e52d947d9640ed" translate="yes" xml:space="preserve">
          <source>This command is especially useful together with &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; which was introduced also in Redis 5 together with &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt;. Check the &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; command page for a pattern involving the two commands.</source>
          <target state="translated">이 명령은 특히 &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt; 와 함께 Redis 5에도 도입 된 &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; 과 함께 유용합니다 . 두 명령과 관련된 패턴 은 &lt;a href=&quot;client-unblock&quot;&gt;CLIENT UNBLOCK&lt;/a&gt; 명령 페이지를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="86526f15e70874597af78fb5a748e15addec9fd4" translate="yes" xml:space="preserve">
          <source>This command is exactly like &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; with the sole difference that instead of taking, as the center of the area to query, a longitude and latitude value, it takes the name of a member already existing inside the geospatial index represented by the sorted set.</source>
          <target state="translated">이 명령은 &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; 와 똑같 습니다. 단, 쿼리 할 영역의 중심으로 위도 및 경도 값을 가져 오는 대신 정렬 된 세트로 표시되는 지리 공간 인덱스 내에 이미 존재하는 멤버의 이름을 사용한다는 점만 다릅니다.</target>
        </trans-unit>
        <trans-unit id="20782308b0ebe308769b63e3df355d6efd05d3a3" translate="yes" xml:space="preserve">
          <source>This command is exactly like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;, but with the notable difference of returning the entries in reverse order, and also taking the start-end range in reverse order: in &lt;a href=&quot;xrevrange&quot;&gt;XREVRANGE&lt;/a&gt; you need to state the &lt;em&gt;end&lt;/em&gt; ID and later the &lt;em&gt;start&lt;/em&gt; ID, and the command will produce all the element between (or exactly like) the two IDs, starting from the &lt;em&gt;end&lt;/em&gt; side.</source>
          <target state="translated">이 명령은 &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 와 정확히 같지만 항목을 역순으로 리턴하고 시작-종료 범위를 역순으로 &lt;a href=&quot;xrevrange&quot;&gt;가져 오는 차이점이&lt;/a&gt; 있습니다 . XREVRANGE 에서는 &lt;em&gt;종료&lt;/em&gt; ID와 나중에 &lt;em&gt;시작&lt;/em&gt; ID 및 명령 을 명시해야합니다. &lt;em&gt;끝&lt;/em&gt; 에서 시작하여 두 ID 사이 (또는 정확히 같은)의 모든 요소를 ​​생성합니다 .</target>
        </trans-unit>
        <trans-unit id="076bd15f23123ea6b78baa94e15f792d2be93592" translate="yes" xml:space="preserve">
          <source>This command is like &lt;a href=&quot;geosearch&quot;&gt;GEOSEARCH&lt;/a&gt;, but stores the result in destination key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0909cd0cbb5b65dceb56a6821a06b32b029f0ae" translate="yes" xml:space="preserve">
          <source>This command is mainly used in the event a &lt;code&gt;nodes.conf&lt;/code&gt; node state file gets lost / deleted for some reason, and we want to generate it again from scratch. It can also be useful in case of mundane alterations of a node cluster configuration via the &lt;code&gt;CLUSTER&lt;/code&gt; command in order to ensure the new configuration is persisted on disk, however all the commands should normally be able to auto schedule to persist the configuration on disk when it is important to do so for the correctness of the system in the event of a restart.</source>
          <target state="translated">이 명령은 주로 &lt;code&gt;nodes.conf&lt;/code&gt; 노드 상태 파일이 어떤 이유로 손실 / 삭제되는 경우에 사용되며 처음부터 다시 생성하려고합니다. 디스크에 새로운 구성이 유지되도록하기 위해 &lt;code&gt;CLUSTER&lt;/code&gt; 명령을 통해 노드 클러스터 구성을 평범하게 변경 한 경우에도 유용 할 수 있지만 일반적으로 모든 명령은 구성이 디스크에있을 때 구성을 디스크에 유지하도록 자동 예약 할 수 있어야합니다 다시 시작하는 경우 시스템의 정확성을 위해 그렇게하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="b0d65e64e68abf2d5af87daf134cb637fc1df1f2" translate="yes" xml:space="preserve">
          <source>This command is mainly useful for debugging, when the failure detector of Redis Cluster is not operating as we believe it should.</source>
          <target state="translated">이 명령은 Redis Cluster의 고장 감지기가 예상대로 작동하지 않을 때 주로 디버깅에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="30fc3be6e9d8c6b14224168e93a2ce61a33ebf6a" translate="yes" xml:space="preserve">
          <source>This command is mainly useful to kill a script that is running for too much time(for instance because it entered an infinite loop because of a bug). The script will be killed and the client currently blocked into EVAL will see the command returning with an error.</source>
          <target state="translated">이 명령은 주로 너무 많은 시간 동안 실행중인 스크립트를 종료하는 데 유용합니다 (예 : 버그로 인해 무한 루프에 들어감). 스크립트가 종료되고 현재 EVAL로 차단 된 클라이언트는 명령이 오류와 함께 반환되는 것을 보게됩니다.</target>
        </trans-unit>
        <trans-unit id="37c2b15b0fd4a88889c5862b221daca96c7ea555" translate="yes" xml:space="preserve">
          <source>This command is mainly useful to re-provision a Redis Cluster node in order to be used in the context of a new, different cluster. The command is also extensively used by the Redis Cluster testing framework in order to reset the state of the cluster every time a new test unit is executed.</source>
          <target state="translated">이 명령은 주로 새롭고 다른 클러스터 환경에서 사용하기 위해 Redis 클러스터 노드를 다시 프로비저닝하는 데 유용합니다. Redis Cluster 테스트 프레임 워크에서는이 명령을 광범위하게 사용하여 새 테스트 단위가 실행될 때마다 클러스터의 상태를 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="fed8489efd023df6aa3b9c8828a92cf9cbe79777" translate="yes" xml:space="preserve">
          <source>This command is similar to &lt;a href=&quot;zdiffstore&quot;&gt;ZDIFFSTORE&lt;/a&gt;, but instead of storing the resulting sorted set, it is returned to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b570683c8482e1a6ba032781b807f8695533eb" translate="yes" xml:space="preserve">
          <source>This command is similar to &lt;a href=&quot;zinterstore&quot;&gt;ZINTERSTORE&lt;/a&gt;, but instead of storing the resulting sorted set, it is returned to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d880d1fb82050509f79c50bd6fb5ec73f51cf212" translate="yes" xml:space="preserve">
          <source>This command is similar to &lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt;, but instead of storing the resulting sorted set, it is returned to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9de9c0357b2f6bf5f5b30bfd602eff2f9c1cbcf1" translate="yes" xml:space="preserve">
          <source>This command is the most powerful analysis tool in the latency monitoring framework, and is able to provide additional statistical data like the average period between latency spikes, the median deviation, and a human-readable analysis of the event. For certain events, like &lt;code&gt;fork&lt;/code&gt;, additional information is provided, like the rate at which the system forks processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b9cd1ceade82d616f55d37288e27be4ecc550c1" translate="yes" xml:space="preserve">
          <source>This command is the only way to force Redis to flush the scripts cache. It is most useful in a cloud environment where the same instance can be reassigned to a different user. It is also useful for testing client libraries' implementations of the scripting feature.</source>
          <target state="translated">이 명령은 Redis가 스크립트 캐시를 플러시하도록하는 유일한 방법입니다. 동일한 인스턴스를 다른 사용자에게 재 할당 할 수있는 클라우드 환경에서 가장 유용합니다. 또한 클라이언트 라이브러리의 스크립팅 기능 구현을 테스트하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8562c28aa29c0aee65ed6fb4a3d690ee24e35388" translate="yes" xml:space="preserve">
          <source>This command is the only way to interrupt a long-running script that reaches the configured maximum execution time for scripts. The SCRIPT KILL command can only be used with scripts that did not modify the dataset during their execution (since stopping a read-only script does not violate the scripting engine's guaranteed atomicity). See the next sections for more information about long running scripts.</source>
          <target state="translated">이 명령은 스크립트에 대해 구성된 최대 실행 시간에 도달하는 장기 실행 스크립트를 중단 할 수있는 유일한 방법입니다. SCRIPT KILL 명령은 실행 중에 데이터 세트를 수정하지 않은 스크립트에만 사용할 수 있습니다 (읽기 전용 스크립트를 중지해도 스크립팅 엔진의 보장 된 원 자성을 위반하지 않기 때문). 장기 실행 스크립트에 대한 자세한 내용은 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="74540a3a51962d64e542e90991498fda99b11c4b" translate="yes" xml:space="preserve">
          <source>This command is used in order to manage the consumer groups associated with a stream data structure. Using &lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt; you can:</source>
          <target state="translated">이 명령은 스트림 데이터 구조와 연관된 소비자 그룹을 관리하기 위해 사용됩니다. &lt;a href=&quot;xgroup&quot;&gt;XGROUP&lt;/a&gt; 을 사용하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f3f38de2ae9dc1853425848b341ace4420d82e4" translate="yes" xml:space="preserve">
          <source>This command is used in order to read and reset the Redis slow queries log.</source>
          <target state="translated">이 명령은 Redis 느린 쿼리 로그를 읽고 재설정하기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4469a3906600e48388ff32654f41a170c058ed11" translate="yes" xml:space="preserve">
          <source>This command is useful as it makes able to switch clients from a Redis instance to another one in a controlled way. For example during an instance upgrade the system administrator could do the following:</source>
          <target state="translated">이 명령은 클라이언트를 제어 된 방식으로 Redis 인스턴스에서 다른 인스턴스로 전환 할 수 있으므로 유용합니다. 예를 들어 인스턴스 업그레이드 중 시스템 관리자는 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7716c05ccc0dd7cac30547152d82c808312925c0" translate="yes" xml:space="preserve">
          <source>This command is useful especially when we are monitoring many keys with a limited number of connections. For instance we may want to monitor multiple streams with &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; without using more than N connections. However at some point the consumer process is informed that there is one more stream key to monitor. In order to avoid using more connections, the best behavior would be to stop the blocking command from one of the connections in the pool, add the new key, and issue the blocking command again.</source>
          <target state="translated">이 명령은 제한된 수의 연결로 많은 키를 모니터링 할 때 특히 유용합니다. 예를 들어 N 개 이상의 연결을 사용하지 않고 &lt;a href=&quot;xread&quot;&gt;XREAD로&lt;/a&gt; 여러 스트림을 모니터링 할 수 있습니다 . 그러나 어떤 시점에서 소비자 프로세스는 모니터링 할 스트림 키가 하나 더 있다는 알림을받습니다. 더 많은 연결을 사용하지 않으려면 풀의 연결 중 하나에서 차단 명령을 중지하고 새 키를 추가 한 후 차단 명령을 다시 발행하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="59ff8c186eb229a2dac30dbd70e43e24baabed7c" translate="yes" xml:space="preserve">
          <source>This command is useful in order to modify a node's view of the cluster configuration. Specifically it assigns a set of hash slots to the node receiving the command. If the command is successful, the node will map the specified hash slots to itself, and will start broadcasting the new configuration.</source>
          <target state="translated">이 명령은 클러스터 구성의 노드보기를 수정하는 데 유용합니다. 특히 명령을 수신하는 노드에 해시 슬롯 세트를 지정합니다. 명령이 성공하면 노드는 지정된 해시 슬롯을 자신에게 매핑하고 새 구성을 브로드 캐스트하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="afcb99c36c15189824ecdc3091bf486391211187" translate="yes" xml:space="preserve">
          <source>This command is very similar to &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;: it removes the specified keys. Just like &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; a key is ignored if it does not exist. However the command performs the actual memory reclaiming in a different thread, so it is not blocking, while &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; is. This is where the command name comes from: the command just &lt;strong&gt;unlinks&lt;/strong&gt; the keys from the keyspace. The actual removal will happen later asynchronously.</source>
          <target state="translated">이 명령은 &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; 과 매우 유사 합니다. 지정된 키를 제거합니다. &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; 과 마찬가지로 키가 없으면 무시됩니다. 그러나이 명령은 다른 스레드에서 실제 메모리 회수를 수행하므로 &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; 이 실행 되는 동안 차단되지 않습니다 . 이것은 명령 이름이 나오는 곳입니다. 명령 은 키 공간에서 키를 연결 &lt;strong&gt;해제&lt;/strong&gt; 합니다. 실제 제거는 나중에 비동기 적으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8d70f66fb80485b6d531d7d9ab8ad149118bee56" translate="yes" xml:space="preserve">
          <source>This command loads and initializes the Redis module from the dynamic library specified by the &lt;code&gt;path&lt;/code&gt; argument. The &lt;code&gt;path&lt;/code&gt; should be the absolute path of the library, including the full filename. Any additional arguments are passed unmodified to the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e7d9161cbb27663ecc1a90a3f6bb05f23dbad84" translate="yes" xml:space="preserve">
          <source>This command only works in cluster mode and is useful in the following Redis Cluster operations:</source>
          <target state="translated">이 명령은 클러스터 모드에서만 작동하며 다음 Redis 클러스터 작업에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ae45a8ae2f8e5aecd7b6912a681c88c74a505274" translate="yes" xml:space="preserve">
          <source>This command only works in cluster mode and may be useful for debugging and in order to manually orchestrate a cluster configuration when a new cluster is created. It is currently not used by &lt;code&gt;redis-trib&lt;/code&gt;, and mainly exists for API completeness.</source>
          <target state="translated">이 명령은 클러스터 모드에서만 작동하며 디버깅에 유용하고 새 클러스터가 생성 될 때 클러스터 구성을 수동으로 조정하는 데 유용 할 수 있습니다. 현재 &lt;code&gt;redis-trib&lt;/code&gt; 에 의해 사용되지 않으며 주로 API 완성도를 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="b0562f793b35f58a57b7250775581e06cabbe124" translate="yes" xml:space="preserve">
          <source>This command performs a full reset of the connection's server-side context, mimicking the effect of disconnecting and reconnecting again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5304131d86dfa25555f9abe5b57dd4ad31bed60" translate="yes" xml:space="preserve">
          <source>This command registers the specified script in the Redis script cache. The command is useful in all the contexts where we want to make sure that &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; will not fail (for instance during a pipeline or MULTI/EXEC operation), without the need to actually execute the script.</source>
          <target state="translated">이 명령은 지정된 스크립트를 Redis 스크립트 캐시에 등록합니다. 이 명령은 실제로 스크립트를 실행할 필요없이 &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; 가 실패하지 않도록 (예 : 파이프 라인 또는 MULTI / EXEC 작업 중) 모든 컨텍스트에서 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="09806309aef17ea4d51d659e1cc3d714503d0680" translate="yes" xml:space="preserve">
          <source>This command returns the client ID we are redirecting our &lt;a href=&quot;https://redis.io/topics/client-side-caching&quot;&gt;tracking&lt;/a&gt; notifications to. We set a client to redirect to when using &lt;a href=&quot;client-tracking&quot;&gt;CLIENT TRACKING&lt;/a&gt; to enable tracking. However in order to avoid forcing client libraries implementations to remember the ID notifications are redirected to, this command exists in order to improve introspection and allow clients to check later if redirection is active and towards which client ID.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef7e7424bc09f286d32a4b812efe8253277e59f5" translate="yes" xml:space="preserve">
          <source>This command returns the number of failure reports for the current node which are currently not expired (so received within two times the &lt;em&gt;node timeout&lt;/em&gt; time). The count does not include what the node we are asking this count believes about the node ID we pass as argument, the count &lt;em&gt;only&lt;/em&gt; includes the failure reports the node received from other nodes.</source>
          <target state="translated">이 명령은 현재 만료되지 않은 (현재 &lt;em&gt;노드 시간 종료&lt;/em&gt; 시간의 두 배 내에 수신 된) 현재 노드에 대한 실패 보고서 수를 리턴합니다 . 이 카운트에는이 카운트를 요청하는 노드가 인수로 전달한 노드 ID에 대해 믿는 것이 포함되지 않으며, 다른 노드에서 노드가 수신 한 실패 보고서 &lt;em&gt;만&lt;/em&gt; 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="541223fddf4b501cc96317842ccc50859641cd10" translate="yes" xml:space="preserve">
          <source>This command sets a specific &lt;em&gt;config epoch&lt;/em&gt; in a fresh node. It only works when:</source>
          <target state="translated">이 명령은 새로운 노드에서 특정 &lt;em&gt;구성 에포크&lt;/em&gt; 를 &lt;em&gt;설정&lt;/em&gt; 합니다. 다음과 같은 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="18e23f892090be38939eafd00c77e503dab8c192" translate="yes" xml:space="preserve">
          <source>This command swaps two Redis databases, so that immediately all the clients connected to a given database will see the data of the other database, and the other way around. Example:</source>
          <target state="translated">이 명령은 두 Redis 데이터베이스를 교환하므로, 주어진 데이터베이스에 연결된 모든 클라이언트가 즉시 다른 데이터베이스의 데이터를 볼 수있게됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="75c1ca96e42909a085011b83f917c82db8bdd8f7" translate="yes" xml:space="preserve">
          <source>This command unloads the module specified by &lt;code&gt;name&lt;/code&gt;. Note that the module's name is reported by the &lt;a href=&quot;module-list&quot;&gt;MODULE LIST&lt;/a&gt; command, and may differ from the dynamic library's filename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6adc7a43ee507fff544bbc6adc515bc47ac97ad4" translate="yes" xml:space="preserve">
          <source>This command was introduced in the middle of a Redis stable release, specifically with Redis 2.8.12.</source>
          <target state="translated">이 명령은 Redis 2.8.12와 함께 Redis 안정 릴리스 중간에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="838bb242e39a256bd97fcf68121a5b0ba9ba6cad" translate="yes" xml:space="preserve">
          <source>This command works exactly like &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; but the time to live of the key is specified in milliseconds instead of seconds.</source>
          <target state="translated">이 명령은 &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; 와 똑같이 작동 하지만 키의 작동 시간은 초가 아닌 밀리 초로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="7341623725ef962c36ad811614642ab5632c4c2c" translate="yes" xml:space="preserve">
          <source>This command, that can only be sent to a Redis Cluster replica node, forces the replica to start a manual failover of its master instance.</source>
          <target state="translated">Redis 클러스터 복제본 노드로만 보낼 수있는이 명령은 복제본이 마스터 인스턴스의 수동 장애 조치를 시작하도록합니다.</target>
        </trans-unit>
        <trans-unit id="4da304a4683087def0d8d26eb2c481c6af27db0a" translate="yes" xml:space="preserve">
          <source>This conversion between data types is designed in a way that if a Redis type is converted into a Lua type, and then the result is converted back into a Redis type, the result is the same as the initial value.</source>
          <target state="translated">데이터 유형 간의 이러한 변환은 Redis 유형이 Lua 유형으로 변환 된 다음 결과가 다시 Redis 유형으로 변환되는 경우 결과가 초기 값과 동일하게 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="e18d68145955b4559f3ba803d90954ff94c0dac8" translate="yes" xml:space="preserve">
          <source>This dynamic is clearly explained in the &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Stream intro documentation&lt;/a&gt;.</source>
          <target state="translated">이 역학은 &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Stream intro documentation&lt;/a&gt; 에 명확하게 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19d5d3191e2445ef69de01881bb5939b9f401be6" translate="yes" xml:space="preserve">
          <source>This example shows the application in the context of Redis streams, however the pattern is a general one and can be applied to other cases.</source>
          <target state="translated">이 예는 Redis 스트림의 맥락에서 응용 프로그램을 보여 주지만 패턴은 일반적인 것이며 다른 경우에도 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b81b5550c835cb846e3da1e36e1dc058efa8bc9" translate="yes" xml:space="preserve">
          <source>This form just authenticates against the password set with &lt;code&gt;requirepass&lt;/code&gt;. In this configuration Redis will deny any command executed by the just connected clients, unless the connection gets authenticated via &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c30a4ad86f29101d3c1fcdfab12485ff0ca6c027" translate="yes" xml:space="preserve">
          <source>This format allows for radius querying by checking the 1+8 areas needed to cover the whole radius, and discarding elements outside the radius. The areas are checked by calculating the range of the box covered removing enough bits from the less significant part of the sorted set score, and computing the score range to query in the sorted set for each area.</source>
          <target state="translated">이 형식을 사용하면 전체 반지름을 덮는 데 필요한 1 + 8 영역을 확인하고 반지름 외부의 요소를 삭제하여 반지름 쿼리를 수행 할 수 있습니다. 영역은 정렬 된 세트 스코어의 덜 중요한 부분으로부터 충분한 비트를 제거하여 커버 된 박스의 범위를 계산하고, 각 영역에 대해 정렬 된 세트에서 질의하기위한 스코어 범위를 계산함으로써 점검된다.</target>
        </trans-unit>
        <trans-unit id="5f7d96d3049d4f76efb356668757ef71fbc55342" translate="yes" xml:space="preserve">
          <source>This has the same effect as running &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt; with one argument &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">이것은 하나의 인수 &lt;code&gt;key&lt;/code&gt; &lt;a href=&quot;sinter&quot;&gt;SINTER&lt;/a&gt; 를 실행하는 것과 동일한 효과를 갖 습니다 .</target>
        </trans-unit>
        <trans-unit id="5d0bfed0b5c7c513675b9c26b7ab5ed0c6f3d603" translate="yes" xml:space="preserve">
          <source>This is a good overview, but sometimes we are interested in the details. In order to see all the pending messages with more associated information we need to also pass a range of IDs, in a similar way we do it with &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;, and a non optional &lt;em&gt;count&lt;/em&gt; argument, to limit the number of messages returned per call:</source>
          <target state="translated">이것은 좋은 개요이지만 때로는 세부 사항에 관심이 있습니다. 더 많은 관련 정보가있는 보류중인 메시지를 모두 보려면 호출마다 반환되는 메시지 수를 제한하기 위해 &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 및 선택 사항이 아닌 &lt;em&gt;count&lt;/em&gt; 인수 를 사용하여 비슷한 방식으로 다양한 ID를 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="90aa8094613e02ff36a67a68b984d933a74e701a" translate="yes" xml:space="preserve">
          <source>This is a list of all the supported Redis ACL rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61b4d531c8516c33061d94d3a8959add03c42f29" translate="yes" xml:space="preserve">
          <source>This is a trivial probabilistic algorithm, basically the assumption is that our sample is representative of the whole key space, and we continue to expire until the percentage of keys that are likely to be expired is under 25%</source>
          <target state="translated">이것은 사소한 확률 론적 알고리즘으로, 기본적으로 샘플이 전체 키 공간을 대표한다고 가정하며, 만료 될 가능성이있는 키의 백분율이 25 % 미만이 될 때까지 계속 만료됩니다.</target>
        </trans-unit>
        <trans-unit id="c48adb8e8d877ae182110cc1e68d2e6bc1d83311" translate="yes" xml:space="preserve">
          <source>This is an example of blocking invocation, where the command later returns a null reply because the timeout has elapsed without new data arriving:</source>
          <target state="translated">다음은 새 데이터가 도착하지 않고 시간 초과가 경과되어 명령이 널 응답을 리턴하는 호출 차단의 예입니다.</target>
        </trans-unit>
        <trans-unit id="622bd341d8dc701d53c24284f457bffb1eb9df29" translate="yes" xml:space="preserve">
          <source>This is an example of iteration using &lt;strong&gt;MATCH&lt;/strong&gt;:</source>
          <target state="translated">다음은 &lt;strong&gt;MATCH를&lt;/strong&gt; 사용한 반복의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="4d789554ece00f72c77acd57e4f313f31c717e24" translate="yes" xml:space="preserve">
          <source>This is an introspection command used in order to retrieve different information about the streams and associated consumer groups. Three forms are possible:</source>
          <target state="translated">스트림 및 관련 소비자 그룹에 대한 다른 정보를 검색하기 위해 사용되는 내부 검사 명령입니다. 세 가지 형태가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="fa13476351797926204e99a9b54034d28b5780cc" translate="yes" xml:space="preserve">
          <source>This is easy to see intuitively: if the collection grows there is more and more work to do in order to visit all the possible elements, and the ability to terminate the iteration depends on the number of calls to &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; and its COUNT option value compared with the rate at which the collection grows.</source>
          <target state="translated">컬렉션이 커지면 가능한 모든 요소를 ​​방문하기 위해 더 많은 작업이 수행되고 반복을 종료하는 기능은 &lt;a href=&quot;scan&quot;&gt;SCAN에&lt;/a&gt; 대한 호출 수 와 COUNT 옵션 값에 따라 다릅니다. 수집이 증가하는 비율</target>
        </trans-unit>
        <trans-unit id="5ecf6a9694906630d3be8ffa19f791d25178c710" translate="yes" xml:space="preserve">
          <source>This is how a typical &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; call looks like in the first iteration of a consumer willing to consume only new entries:</source>
          <target state="translated">새로운 항목 만 소비하려는 소비자의 첫 번째 반복에서 일반적인 &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="720fb76cbe63b3ee37bb596512afa1691c9ba3f2" translate="yes" xml:space="preserve">
          <source>This is how to understand if you want to use a consumer group or not:</source>
          <target state="translated">소비자 그룹 사용 여부를 이해하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d94df873adfd43289accd82b71abdee4a8063f4" translate="yes" xml:space="preserve">
          <source>This is how we use this command in order to mount such an algorithm:</source>
          <target state="translated">이러한 알고리즘을 마운트하기 위해이 명령을 사용하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c0d3b602529b7dea150254bfa283c67fb2eed932" translate="yes" xml:space="preserve">
          <source>This is the output you should post in the Redis mailing list if you are looking for help about Latency related issues.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9658590fc318422333085d731b93a7035c7459f" translate="yes" xml:space="preserve">
          <source>This is useful in several ways depending on the use case:</source>
          <target state="translated">유스 케이스에 따라 여러 가지 방법으로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bcf3a4afdd1a41afed7a49db731a6c6ebfa0cc2a" translate="yes" xml:space="preserve">
          <source>This is useful to an application that wants to fetch raw data in order to perform monitoring, display graphs, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a58d44535039d5a20b0fa97b3b1ee43b1b6dd46" translate="yes" xml:space="preserve">
          <source>This is usually needed only when the instance is going to be instantiated for another customer or application in a cloud environment.</source>
          <target state="translated">이는 일반적으로 클라우드 환경에서 다른 고객 또는 애플리케이션에 대해 인스턴스를 인스턴스화 할 때만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bbfa8fbc11f623748d63d11e9bf5ee03c12ff234" translate="yes" xml:space="preserve">
          <source>This manual page also covers the &lt;code&gt;GEORADIUS_RO&lt;/code&gt; and &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; variants (see the section below for more information).</source>
          <target state="translated">이 매뉴얼 페이지에는 &lt;code&gt;GEORADIUS_RO&lt;/code&gt; 및 &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; 변형 도 포함되어 있습니다 (자세한 내용은 아래 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="d223d35db64e1d19fc9f2926f21b42e4ab2344a9" translate="yes" xml:space="preserve">
          <source>This means that at any given moment the maximum amount of keys already expired that are using memory is at max equal to max amount of write operations per second divided by 4.</source>
          <target state="translated">즉, 메모리를 사용하는 이미 만료 된 최대 키 양은 최대 초당 쓰기 작업 수를 4로 나눈 값과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aabcd9a95a39d430c629afa9fad1b539c022ac85" translate="yes" xml:space="preserve">
          <source>This means that if you have two non-empty buckets in the entire hash table, and one has three elements while one has just one, the element that is alone in its bucket will be returned with much higher probability.</source>
          <target state="translated">즉, 전체 해시 테이블에 비어 있지 않은 버킷이 두 개 있고 하나에 세 개의 요소가 있고 하나에 하나만있는 경우 버킷에있는 요소는 훨씬 높은 확률로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="249f94aa848de22f03290fa35dfb93a51fdb5d7d" translate="yes" xml:space="preserve">
          <source>This means that this command should be used with care only by applications orchestrating Redis Cluster, like &lt;code&gt;redis-trib&lt;/code&gt;, and the command if used out of the right context can leave the cluster in a wrong state or cause data loss.</source>
          <target state="translated">즉,이 명령은 &lt;code&gt;redis-trib&lt;/code&gt; 와 같이 Redis Cluster를 조정하는 응용 프로그램에서만주의해서 사용해야하며 올바른 컨텍스트에서 사용하지 않을 경우 명령이 클러스터를 잘못된 상태로 두거나 데이터 손실을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4b18f04b9acb83f71f24c60b244188e2d234cce" translate="yes" xml:space="preserve">
          <source>This means that you set:</source>
          <target state="translated">이는 다음을 설정했음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8a0b4cfa314b524daabda36aba34d428f894ef1e" translate="yes" xml:space="preserve">
          <source>This operation is similar to &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt;, that returns one or more random elements from a set but does not remove it.</source>
          <target state="translated">이 작업은 &lt;a href=&quot;srandmember&quot;&gt;SRANDMEMBER&lt;/a&gt; 와 유사합니다. SRANDMEMBER 는 집합에서 하나 이상의 임의의 요소를 반환하지만 제거하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="b82ae6d609ba5f4bff538ca99ae907087f8e8c97" translate="yes" xml:space="preserve">
          <source>This pair of commands will push a new element on the list, while making sure that the list will not grow larger than 100 elements. This is very useful when using Redis to store logs for example. It is important to note that when used in this way &lt;a href=&quot;ltrim&quot;&gt;LTRIM&lt;/a&gt; is an O(1) operation because in the average case just one element is removed from the tail of the list.</source>
          <target state="translated">이 명령 쌍은 목록에서 새 요소를 푸시하는 동시에 목록이 100 개보다 큰 요소가되지 않도록합니다. 예를 들어 Redis를 사용하여 로그를 저장할 때 매우 유용합니다. 이런 식으로 &lt;a href=&quot;ltrim&quot;&gt;LTRIM을&lt;/a&gt; 사용하는 경우 LTRIM 은 O (1) 연산입니다. 평균적으로 하나의 요소 만 목록의 꼬리 부분에서 제거되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="80b9715de053267e5fffa59b0b1112d991e9ba3f" translate="yes" xml:space="preserve">
          <source>This pattern is easily modified to use counters using &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; instead of lists using &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;.</source>
          <target state="translated">이 패턴은 &lt;a href=&quot;rpush&quot;&gt;RPUSH를&lt;/a&gt; 사용하는 목록 대신 &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; 을 사용하는 카운터를 사용하도록 쉽게 수정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d386987d572848d3712f1ff810e5567134c02087" translate="yes" xml:space="preserve">
          <source>This simple pattern can be extended in many ways:</source>
          <target state="translated">이 간단한 패턴은 여러 가지 방법으로 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92785c4b9f557c4d2558a4fa95a80f3ac27c63a5" translate="yes" xml:space="preserve">
          <source>This subcommand is the reverse of &lt;code&gt;MIGRATING&lt;/code&gt;, and prepares the destination node to import keys from the specified source node. The command only works if the node is not already owner of the specified hash slot.</source>
          <target state="translated">이 하위 명령은 &lt;code&gt;MIGRATING&lt;/code&gt; 과 반대이며 지정된 소스 노드에서 키를 가져올 대상 노드를 준비합니다. 노드가 지정된 해시 슬롯의 소유자가 아닌 경우에만 명령이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3af1b4ceac0630f2f07d73ce38551a82afebcee6" translate="yes" xml:space="preserve">
          <source>This subcommand just clears migrating / importing state from the slot. It is mainly used to fix a cluster stuck in a wrong state by &lt;code&gt;redis-trib fix&lt;/code&gt;. Normally the two states are cleared automatically at the end of the migration using the &lt;code&gt;SETSLOT ... NODE ...&lt;/code&gt; subcommand as explained in the next section.</source>
          <target state="translated">이 하위 명령은 슬롯에서 마이그레이션 / 가져 오기 상태 만 지 웁니다. 주로 &lt;code&gt;redis-trib fix&lt;/code&gt; 에 의해 잘못된 상태에 갇힌 클러스터를 수정하는 데 사용됩니다 . 일반적으로 다음 섹션에 설명 된대로 &lt;code&gt;SETSLOT ... NODE ...&lt;/code&gt; 하위 명령을 사용하여 마이그레이션이 끝날 때 두 상태가 자동으로 지워집니다 .</target>
        </trans-unit>
        <trans-unit id="9fe3e638e8830d97f18b8e18e7bb1f71a19b5a85" translate="yes" xml:space="preserve">
          <source>This subcommand sets a slot to &lt;em&gt;migrating&lt;/em&gt; state. In order to set a slot in this state, the node receiving the command must be the hash slot owner, otherwise an error is returned.</source>
          <target state="translated">이 하위 명령은 슬롯을 &lt;em&gt;마이그레이션&lt;/em&gt; 상태로 설정합니다 . 이 상태에서 슬롯을 설정하려면 명령을 수신하는 노드가 해시 슬롯 소유자 여야합니다. 그렇지 않으면 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="edb8d5f6aeacab24056a48e5cdeee519f5cf870a" translate="yes" xml:space="preserve">
          <source>This way clients are moved away from the old master to the new master atomically and only when the replica that is turning into the new master has processed all of the replication stream from the old master.</source>
          <target state="translated">이러한 방식으로 클라이언트는 이전 마스터에서 새 마스터로 원자 적으로 이동되며 새 마스터로 전환하는 복제본이 이전 마스터의 모든 복제 스트림을 처리 한 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="eabc7eeeb462a96b3b77723425f464bf9ccbef27" translate="yes" xml:space="preserve">
          <source>This way we have a 60 second window to inform all the nodes in the cluster that we want to remove a node.</source>
          <target state="translated">이 방법으로 클러스터의 모든 노드에 노드 제거를 알리는 60 초 창이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e40460902c1181221678071c434b045c404620fa" translate="yes" xml:space="preserve">
          <source>This will swap database 0 with database 1. All the clients connected with database 0 will immediately see the new data, exactly like all the clients connected with database 1 will see the data that was formerly of database 0.</source>
          <target state="translated">이렇게하면 데이터베이스 0이 데이터베이스 1로 바뀝니다. 데이터베이스 0에 연결된 모든 클라이언트는 데이터베이스 1에 연결된 모든 클라이언트가 이전에 데이터베이스 0의 데이터를 보는 것처럼 새 데이터를 즉시 보게됩니다.</target>
        </trans-unit>
        <trans-unit id="d5bfb565b7330daf67d56a70b8a026b02f7b8efa" translate="yes" xml:space="preserve">
          <source>Tip: setting names to connections is a good way to debug connection leaks due to bugs in the application using Redis.</source>
          <target state="translated">팁 : 이름을 연결로 설정하는 것은 Redis를 사용하는 응용 프로그램의 버그로 인해 연결 누수를 디버깅하는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ff53653923ebddab009510a619b44980ec4c2bad" translate="yes" xml:space="preserve">
          <source>To call the command without elements but just the variable name is valid, this will result into no operation performed if the variable already exists, or just the creation of the data structure if the key does not exist (in the latter case 1 is returned).</source>
          <target state="translated">요소없이 명령을 호출하지만 변수 이름 만 유효하면 변수가 이미 존재하는 경우 조작이 수행되지 않거나 키가 존재하지 않으면 데이터 구조가 작성됩니다 (후자의 경우 1이 리턴 됨) .</target>
        </trans-unit>
        <trans-unit id="480b89cfe665e37f5248f03df59af64d3763158a" translate="yes" xml:space="preserve">
          <source>To continue iterating the two streams I'll call:</source>
          <target state="translated">두 스트림을 계속 반복하려면 다음을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="0314c05fdc90b76eea71abe37038408de3a97e39" translate="yes" xml:space="preserve">
          <source>To create a new cluster ADDSLOTS is used in order to initially setup master nodes splitting the available hash slots among them.</source>
          <target state="translated">새로운 클러스터를 생성하기 위해 ADDSLOTS는 사용 가능한 해시 슬롯을 분할하는 마스터 노드를 초기에 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="44bff97be54184d5c7829a3927adcbbc623cd71d" translate="yes" xml:space="preserve">
          <source>To create a new consumer group, use the following form:</source>
          <target state="translated">새로운 소비자 그룹을 만들려면 다음 양식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="89c4cf93004db2e7ed530c2bd4661a6d909ed66e" translate="yes" xml:space="preserve">
          <source>To do so the web application may simply increment a key every time the user performs a page view, creating the key name concatenating the User ID and a string representing the current date.</source>
          <target state="translated">이를 위해 웹 응용 프로그램은 사용자가 페이지보기를 수행 할 때마다 키를 증분시켜 사용자 ID를 연결하는 키 이름과 현재 날짜를 나타내는 문자열을 만들 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
