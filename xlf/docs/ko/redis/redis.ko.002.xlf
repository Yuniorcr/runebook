<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="redis">
    <body>
      <group id="redis">
        <trans-unit id="e231fa35664a84f1e5009d81e7f6bba1d485eec3" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;key&lt;/code&gt; exists but does not hold a list value.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 있지만 목록 값을 보유하지 않으면 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="6bdfaaedacc744e822937a491c0aa265faa0a3c9" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;key&lt;/code&gt; exists but does not hold a sorted set.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 있지만 정렬 된 세트를 보유하지 않으면 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="cafd7db432cc1bfe0eb095227c59268bb7b93c9e" translate="yes" xml:space="preserve">
          <source>An error is returned when &lt;code&gt;seconds&lt;/code&gt; is invalid.</source>
          <target state="translated">&lt;code&gt;seconds&lt;/code&gt; 유효하지 않으면 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e9136354e1045681dd2f7a86b9527fc481d91cd" translate="yes" xml:space="preserve">
          <source>An error is returned when the value stored at &lt;code&gt;key&lt;/code&gt; is not a set.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 저장된 값 이 설정되지 않은 경우 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="b4eb1a0965c235064ac8aba79722ddaff3491eef" translate="yes" xml:space="preserve">
          <source>An example of Sentinel output:</source>
          <target state="translated">Sentinel 출력의 예 :</target>
        </trans-unit>
        <trans-unit id="e3a2b833146840fa4cd410d9b71d1f7b478f823c" translate="yes" xml:space="preserve">
          <source>An example of output when &lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt; is called in a master instance:</source>
          <target state="translated">마스터 인스턴스에서 &lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt; 이 호출 될 때의 출력 예 :</target>
        </trans-unit>
        <trans-unit id="579d469e7cac2523515437d9b8d6112fe3d93c9e" translate="yes" xml:space="preserve">
          <source>An example of output when &lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt; is called in a replica instance:</source>
          <target state="translated">복제본 인스턴스에서 &lt;a href=&quot;role&quot;&gt;ROLE&lt;/a&gt; 이 호출 될 때의 출력 예 :</target>
        </trans-unit>
        <trans-unit id="1d6f1c424d50ab94243fe38cbdfeabffd674d66c" translate="yes" xml:space="preserve">
          <source>An example of unlock script would be similar to the following:</source>
          <target state="translated">잠금 해제 스크립트의 예는 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="89fe7da248c22605a4e15750b1f9beb107181168" translate="yes" xml:space="preserve">
          <source>An example sampling the temperature of a sensor using fixed-size strings (using a binary format is better in real implementations).</source>
          <target state="translated">고정 크기 문자열을 사용하여 센서 온도를 샘플링하는 예 (이진 형식을 사용하는 것이 실제 구현에서 더 낫습니다).</target>
        </trans-unit>
        <trans-unit id="4eae947ad09e05cad458fca2075b30ae1b15869c" translate="yes" xml:space="preserve">
          <source>An interesting pattern using &lt;code&gt;SORT ... STORE&lt;/code&gt; consists in associating an &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; timeout to the resulting key so that in applications where the result of a &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; operation can be cached for some time. Other clients will use the cached list instead of calling &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; for every request. When the key will timeout, an updated version of the cache can be created by calling &lt;code&gt;SORT ... STORE&lt;/code&gt; again.</source>
          <target state="translated">&lt;code&gt;SORT ... STORE&lt;/code&gt; 사용하는 흥미로운 패턴 은 &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; 제한 시간을 결과 키 에 연관 시켜 &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; 조작 결과를 한동안 캐시 할 수있는 응용 프로그램에서 구성 됩니다. 다른 클라이언트는 모든 요청 에 대해 &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; 를 호출하는 대신 캐시 된 목록을 사용합니다 . 키가 시간 초과되면 &lt;code&gt;SORT ... STORE&lt;/code&gt; 다시 호출하여 업데이트 된 캐시 버전을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c296bdf9668142740fec726611d45d470138dafa" translate="yes" xml:space="preserve">
          <source>An iteration starts when the cursor is set to 0, and terminates when the cursor returned by the server is 0. The following is an example of SCAN iteration:</source>
          <target state="translated">커서가 0으로 설정되면 반복이 시작되고 서버가 리턴 한 커서가 0이면 종료가 수행됩니다. 다음은 SCAN 반복의 예입니다.</target>
        </trans-unit>
        <trans-unit id="060444849d7b2e77c482c80d4ddc007637e5e3e9" translate="yes" xml:space="preserve">
          <source>And so for until the iteration is complete and no result is returned. See the &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; page about iterating for more information.</source>
          <target state="translated">그리고 반복이 완료되고 결과가 반환되지 않을 때까지. 자세한 정보는 반복에 대한 &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="abbabebfac6efc7292e2eb1b2e18a22fb8f0b07b" translate="yes" xml:space="preserve">
          <source>And so forth.</source>
          <target state="translated">기타 등등.</target>
        </trans-unit>
        <trans-unit id="4c3a5cf2099eac6b70d3351f9f2b307f8576cbfe" translate="yes" xml:space="preserve">
          <source>And so forth. Eventually this will allow to visit all the entries in the stream. Obviously, we can start the iteration from any ID, or even from a specific time, by providing a given incomplete start ID. Moreover, we can limit the iteration to a given ID or time, by providing an end ID or incomplete ID instead of &lt;code&gt;+&lt;/code&gt;.</source>
          <target state="translated">기타 등등. 결국 이것은 스트림의 모든 항목을 방문 할 수있게합니다. 분명히, 우리는 주어진 불완전한 시작 ID를 제공함으로써 임의의 ID 또는 특정 시간에서 반복을 시작할 수 있습니다. 또한 &lt;code&gt;+&lt;/code&gt; 대신 종료 ID 또는 불완전한 ID를 제공하여 지정된 ID 또는 시간으로 반복을 제한 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd50a85c7e0471c36280c42d04f369b2283aaee5" translate="yes" xml:space="preserve">
          <source>And so forth. Eventually, the call will not return any item, but just an empty array, then we know that there is nothing more to fetch from our stream (and we would have to retry the operation, hence this command also supports a blocking mode).</source>
          <target state="translated">기타 등등. 결국 호출은 항목을 반환하지 않고 빈 배열 만 반환하므로 스트림에서 가져올 항목이 더 없다는 것을 알고 있습니다 (그리고 우리는 작업을 다시 시도해야 하므로이 명령은 차단 모드도 지원합니다).</target>
        </trans-unit>
        <trans-unit id="087d39ee1a0310d3323a4cfd02c6576b584cb468" translate="yes" xml:space="preserve">
          <source>Another example: if we imagine a cluster formed of the following four nodes called A, B, C and D, we may send just the following set of commands to A:</source>
          <target state="translated">또 다른 예 : A, B, C 및 D라는 다음 네 개의 노드로 구성된 클러스터를 상상하면 A에 다음 명령 세트 만 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="852a8d39c81588746b082fd9f4167b5bb251bb69" translate="yes" xml:space="preserve">
          <source>Any other ID, that is, 0 or any other valid ID or incomplete ID (just the millisecond time part), will have the effect of returning entries that are pending for the consumer sending the command with IDs greater than the one provided. So basically if the ID is not &lt;code&gt;&amp;gt;&lt;/code&gt;, then the command will just let the client access its pending entries: messages delivered to it, but not yet acknowledged. Note that in this case, both &lt;code&gt;BLOCK&lt;/code&gt; and &lt;code&gt;NOACK&lt;/code&gt; are ignored.</source>
          <target state="translated">다른 모든 ID, 즉 0 또는 다른 유효한 ID 또는 불완전한 ID (밀리 초 시간 부분 만 해당)는 제공된 것보다 큰 ID로 명령을 보내는 소비자에 대해 보류중인 항목을 반환하는 효과가 있습니다. 따라서 기본적으로 ID가 &lt;code&gt;&amp;gt;&lt;/code&gt; 가 아닌 경우 명령은 클라이언트가 보류중인 항목에 액세스 할 수 있도록합니다. 메시지는 전달되었지만 아직 확인되지 않았습니다. 이 경우 &lt;code&gt;BLOCK&lt;/code&gt; 및 &lt;code&gt;NOACK&lt;/code&gt; 모두 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ed0eff051adefea749add42d4d6cb2b879ab75ce" translate="yes" xml:space="preserve">
          <source>Any other ID, that is, 0 or any other valid ID or incomplete ID (just the millisecond time part), will have the effect of returning entries that are pending for the consumer sending the command. So basically if the ID is not &lt;code&gt;&amp;gt;&lt;/code&gt;, then the command will just let the client access its pending entries: delivered to it, but not yet acknowledged.</source>
          <target state="translated">다른 ID, 즉 0 또는 다른 유효한 ID 또는 불완전한 ID (밀리 초 단위)는 소비자가 명령을 보내는 동안 보류중인 항목을 반환하는 효과가 있습니다. 따라서 기본적으로 ID가 &lt;code&gt;&amp;gt;&lt;/code&gt; 가 아닌 경우 명령은 클라이언트가 보류중인 항목에 액세스하도록 허용합니다. 전달되었지만 아직 승인되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="bf48c58a252cd0f11f754a6235c3bf6580ab92b5" translate="yes" xml:space="preserve">
          <source>Anyway even assuming a single-instance locking primitive, starting with 2.6.12 it is possible to create a much simpler locking primitive, equivalent to the one discussed here, using the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command to acquire the lock, and a simple Lua script to release the lock. The pattern is documented in the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command page.</source>
          <target state="translated">어쨌든 2.6.12부터 단일 인스턴스 잠금 기본을 가정하더라도 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 명령을 사용 하여 잠금을 획득하고 간단한 Lua 스크립트를 사용하여 자물쇠. 패턴은 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 명령 페이지에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="274153f2cd2566cd42de1da9ffc1b6d3d2cf50ae" translate="yes" xml:space="preserve">
          <source>Apart from the reversed ordering, &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE&lt;/a&gt; is similar to &lt;a href=&quot;zrange&quot;&gt;ZRANGE&lt;/a&gt;.</source>
          <target state="translated">그렇다 반전 순서에서, &lt;a href=&quot;zrevrange&quot;&gt;ZREVRANGE은&lt;/a&gt; 비슷합니다 &lt;a href=&quot;zrange&quot;&gt;ZRANGE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dae9346322df90f8b168ba54317fbcb22d67c378" translate="yes" xml:space="preserve">
          <source>Apart from the reversed ordering, &lt;a href=&quot;zrevrangebylex&quot;&gt;ZREVRANGEBYLEX&lt;/a&gt; is similar to &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt;.</source>
          <target state="translated">반전 된 순서에서 떨어져, &lt;a href=&quot;zrevrangebylex&quot;&gt;ZREVRANGEBYLEX은&lt;/a&gt; 비슷합니다 &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5c43ee3f0eb54ffe03d2d092f2d6166614a936e" translate="yes" xml:space="preserve">
          <source>Apart from the reversed ordering, &lt;a href=&quot;zrevrangebyscore&quot;&gt;ZREVRANGEBYSCORE&lt;/a&gt; is similar to &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;.</source>
          <target state="translated">그렇다 반전 순서에서, &lt;a href=&quot;zrevrangebyscore&quot;&gt;ZREVRANGEBYSCORE은&lt;/a&gt; 비슷합니다 &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5abab69f4dc0a66b2f4a79cd40ada74327713efb" translate="yes" xml:space="preserve">
          <source>Appendix: Redis expires</source>
          <target state="translated">부록 : Redis 만료</target>
        </trans-unit>
        <trans-unit id="9ff199315ef371177323189f4cb9355c80a5471f" translate="yes" xml:space="preserve">
          <source>Appends the specified stream entry to the stream at the specified key. If the key does not exist, as a side effect of running this command the key is created with a stream value.</source>
          <target state="translated">지정된 스트림 항목을 지정된 키의 스트림에 추가합니다. 키가 존재하지 않으면이 명령을 실행하는 부작용으로 키가 스트림 값으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="32f650d6228cf15fb1f6755ed7de0b1329f744eb" translate="yes" xml:space="preserve">
          <source>Appends the specified stream entry to the stream at the specified key. If the key does not exist, as a side effect of running this command the key is created with a stream value. The creation of stream's key can be disabled with the &lt;code&gt;NOMKSTREAM&lt;/code&gt; option.</source>
          <target state="translated">지정된 키의 스트림에 지정된 스트림 항목을 추가합니다. 키가 없으면이 명령을 실행하는 부작용으로 스트림 값으로 키가 생성됩니다. &lt;code&gt;NOMKSTREAM&lt;/code&gt; 옵션 으로 스트림의 키 생성을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a442180dde4ebe00bdaaebef087550dde9ed275" translate="yes" xml:space="preserve">
          <source>As a side effect a pending message entry is created in the pending entries list (PEL) of the consumer group: it means the message was delivered to a given consumer, but it was not yet acknowledged via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;.</source>
          <target state="translated">부작용으로 보류중인 메시지 항목이 소비자 그룹의 보류중인 항목 목록 (PEL)에 작성됩니다. 이는 메시지가 지정된 소비자에게 전달되었지만 아직 &lt;a href=&quot;xack&quot;&gt;XACK을&lt;/a&gt; 통해 승인되지 않았 음을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="f8d3a747f6516b67780fd78990e06b49b5087892" translate="yes" xml:space="preserve">
          <source>As a side effect of &lt;code&gt;A&lt;/code&gt; knowing and being known by all the other nodes, it will send gossip sections in the heartbeat packets that will allow each other node to create a link with each other one, forming a full mesh in a matter of seconds, even if the cluster is large.</source>
          <target state="translated">다른 모든 노드에서 알고 알고 있는 &lt;code&gt;A&lt;/code&gt; 의 부작용 으로, 하트 비트 패킷으로 가십 섹션을 전송하여 서로의 노드가 서로 링크를 만들어 몇 초 만에 전체 메시를 형성 할 수 있습니다. 클러스터가 큰 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="90aa44b5c0b6d562f721575257b4845fb2c1994d" translate="yes" xml:space="preserve">
          <source>As a side effect of the command execution, if a slot among the ones specified as argument is set as &lt;code&gt;importing&lt;/code&gt;, this state gets cleared once the node assigns the (previously unbound) slot to itself.</source>
          <target state="translated">명령 실행의 부작용으로, argument로 지정된 슬롯 중 하나가 &lt;code&gt;importing&lt;/code&gt; 으로 설정된 경우, 노드가 (이전에는 언 바운드) 슬롯을 자신에게 할당하면이 상태가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="a31cef2ee08d5e8239d818737dfa96674f437698" translate="yes" xml:space="preserve">
          <source>As a side effect of the command execution, the node may go into &lt;em&gt;down&lt;/em&gt; state because not all hash slots are covered.</source>
          <target state="translated">명령 실행의 부작용으로 모든 해시 슬롯이 포함되지 않기 때문에 노드가 &lt;em&gt;다운&lt;/em&gt; 상태 가 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fdfda2f0f0a65c5c9350447421bdbd24d0c16cd7" translate="yes" xml:space="preserve">
          <source>As a side effect of this command the HyperLogLog internals may be updated to reflect a different estimation of the number of unique items added so far (the cardinality of the set).</source>
          <target state="translated">이 명령의 부작용으로 HyperLogLog 내부는 지금까지 추가 된 고유 항목 수 (세트의 카디널리티)의 다른 추정값을 반영하도록 업데이트 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3b0ef422a5105dd7a168f1bd22deb9e931a8ad3" translate="yes" xml:space="preserve">
          <source>As already stated, calls to &lt;code&gt;redis.call()&lt;/code&gt; resulting in a Redis command error will stop the execution of the script and return an error, in a way that makes it obvious that the error was generated by a script:</source>
          <target state="translated">이미 언급했듯이 &lt;code&gt;redis.call()&lt;/code&gt; 호출 하면 Redis 명령 오류가 발생하여 스크립트 실행이 중지되고 오류가 스크립트에 의해 생성되었음을 알 수있는 방식으로 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="09ac6956fbf7cebafd273a67f1e1e0cc18c9d7d7" translate="yes" xml:space="preserve">
          <source>As of Redis 4.0.0, HSET is variadic and allows for multiple &lt;code&gt;field&lt;/code&gt;/&lt;code&gt;value&lt;/code&gt; pairs.</source>
          <target state="translated">Redis 4.0.0부터 HSET은 가변적이며 여러 &lt;code&gt;field&lt;/code&gt; / &lt;code&gt;value&lt;/code&gt; 쌍을 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="824fabdff9eac7426b269cefa6ab8cb7c6a7fa7e" translate="yes" xml:space="preserve">
          <source>As of v5.0, the optional &lt;code&gt;TYPE type&lt;/code&gt; subcommand can be used to filter the list by clients' type, where &lt;em&gt;type&lt;/em&gt; is one of &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;master&lt;/code&gt;, &lt;code&gt;replica&lt;/code&gt; and &lt;code&gt;pubsub&lt;/code&gt;. Note that clients blocked into the &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; command are considered to belong to the &lt;code&gt;normal&lt;/code&gt; class.</source>
          <target state="translated">v5.0부터 선택적 &lt;code&gt;TYPE type&lt;/code&gt; 부속 명령을 사용하여 클라이언트 유형별로 목록을 필터링 할 수 있습니다. 여기서 &lt;em&gt;type&lt;/em&gt; 은 &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;master&lt;/code&gt; , &lt;code&gt;replica&lt;/code&gt; 및 &lt;code&gt;pubsub&lt;/code&gt; 중 하나입니다 . &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 명령 으로 차단 된 클라이언트 는 &lt;code&gt;normal&lt;/code&gt; 클래스 에 속하는 것으로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="f7fd0e1ced5f80a8c1942174a609b55088d136aa" translate="yes" xml:space="preserve">
          <source>As of version 6.0 you can use this option to ask &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; to only return objects that match a given &lt;code&gt;type&lt;/code&gt;, allowing you to iterate through the database looking for keys of a specific type. The &lt;strong&gt;TYPE&lt;/strong&gt; option is only available on the whole-database &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;, not &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; or &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; etc.</source>
          <target state="translated">버전 6.0 &lt;a href=&quot;scan&quot;&gt;부터는&lt;/a&gt; 이 옵션을 사용 하여 주어진 &lt;code&gt;type&lt;/code&gt; 과 일치하는 객체 만 반환 하도록 SCAN 에 요청할 수 있으므로 특정 유형의 키를 찾기 위해 데이터베이스를 반복 할 수 있습니다. &lt;strong&gt;TYPE의&lt;/strong&gt; 옵션은 전체 데이터베이스에서만 사용할 수 있습니다 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 하지 &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; 또는 &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; 등</target>
        </trans-unit>
        <trans-unit id="1f512cd2f467fc007a16339b78f3f8bd4aa4ddc3" translate="yes" xml:space="preserve">
          <source>As per Redis 4.0.0, HMSET is considered deprecated. Please use &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; in new code.</source>
          <target state="translated">Redis 4.0.0에 따라 HMSET은 더 이상 사용되지 않는 것으로 간주됩니다. 새 코드에서 &lt;a href=&quot;hset&quot;&gt;HSET&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="52e2ff1f75cd0a86ae75552c78ee5cbb2c5d2636" translate="yes" xml:space="preserve">
          <source>As per Redis 6.2, GETSET is considered deprecated. Please use &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; with &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; parameter in new code.</source>
          <target state="translated">Redis 6.2에 따라 GETSET은 더 이상 사용되지 않는 것으로 간주됩니다. 새 코드에서 &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; 매개 변수 와 함께 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="eca69203d6944d9aedfa83b1745a14df6f143d34" translate="yes" xml:space="preserve">
          <source>As per Redis 6.2.0, BRPOPLPUSH is considered deprecated. Please use &lt;a href=&quot;blmove&quot;&gt;BLMOVE&lt;/a&gt; in new code.</source>
          <target state="translated">Redis 6.2.0에 따라 BRPOPLPUSH는 더 이상 사용되지 않는 것으로 간주됩니다. 새 코드에서 &lt;a href=&quot;blmove&quot;&gt;BLMOVE&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="50625700b094276571780430ad92d3906e72fb6e" translate="yes" xml:space="preserve">
          <source>As per Redis 6.2.0, RPOPLPUSH is considered deprecated. Please use &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; in new code.</source>
          <target state="translated">Redis 6.2.0에 따라 RPOPLPUSH는 더 이상 사용되지 않는 것으로 간주됩니다. 새 코드에서 &lt;a href=&quot;lmove&quot;&gt;LMOVE&lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cf598b1b6e40341f8808136a0a46e1f4d5d8d97" translate="yes" xml:space="preserve">
          <source>As you can see 3.333 is converted into 3, &lt;em&gt;somekey&lt;/em&gt; is excluded, and the &lt;em&gt;bar&lt;/em&gt; string is never returned as there is a nil before.</source>
          <target state="translated">당신은 3.333 3로 변환 볼 수 있듯이, &lt;em&gt;somekey은&lt;/em&gt; 제외하고, &lt;em&gt;바&lt;/em&gt; 전에 전무가로 문자열이 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b20dcd69a8805b2228dfb60a21cf7d97acd5f67c" translate="yes" xml:space="preserve">
          <source>As you can see 3.333 is converted into 3, and the &lt;em&gt;bar&lt;/em&gt; string is never returned as there is a nil before.</source>
          <target state="translated">보시다시피 3.333은 3으로 변환되고 이전에 nil이 있으므로 &lt;em&gt;바&lt;/em&gt; 문자열은 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec8e8f706055fbdba6360cfb1b417dae6427300e" translate="yes" xml:space="preserve">
          <source>As you can see &lt;strong&gt;NOT&lt;/strong&gt; is special as it only takes an input key, because it performs inversion of bits so it only makes sense as an unary operator.</source>
          <target state="translated">보시다시피 &lt;strong&gt;NOT&lt;/strong&gt; 은 비트의 반전을 수행하므로 단항 연산자로만 이해되므로 입력 키만 사용하므로 특별합니다.</target>
        </trans-unit>
        <trans-unit id="a732d9b394f216e3ee5501e430e6cf1a3865a69a" translate="yes" xml:space="preserve">
          <source>As you can see in this way removing a node is fragile, we need to send &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; commands to all the nodes ASAP hoping there are no gossip sections processing in the meantime. Because of this problem the command implements a ban-list with an expire time for each entry.</source>
          <target state="translated">이 방법으로 노드 제거가 깨지기 쉬운 것처럼 알 수 있듯이 그 동안 가십 섹션이 처리되지 않기를 희망하면서 &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; 명령을 모든 노드 에 보내야 합니다. 이 문제로 인해 명령은 각 항목에 대해 만료 시간이있는 금지 목록을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="aeec0e9426a0a0a54fbf363e2b26ff697ce52419" translate="yes" xml:space="preserve">
          <source>As you can see most of the calls returned zero elements, but the last call where a COUNT of 1000 was used in order to force the command to do more scanning for that iteration.</source>
          <target state="translated">보시다시피 대부분의 호출은 0 개의 요소를 반환했지만 명령이 해당 반복에 대해 더 많은 스캔을 수행하도록하기 위해 COUNT의 1000이 사용 된 마지막 호출입니다.</target>
        </trans-unit>
        <trans-unit id="f1947772b8e632184927e0616393e7edcce03ca1" translate="yes" xml:space="preserve">
          <source>As you can see the &lt;strong&gt;SCAN return value&lt;/strong&gt; is an array of two values: the first value is the new cursor to use in the next call, the second value is an array of elements.</source>
          <target state="translated">보시다시피 &lt;strong&gt;SCAN 반환 값&lt;/strong&gt; 은 두 값의 배열입니다. 첫 번째 값은 다음 호출에서 사용할 새 커서이고 두 번째 값은 요소의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="53b31465005a9966a63fe8728e23f94c240abdb1" translate="yes" xml:space="preserve">
          <source>Ask the server to close the connection. The connection is closed as soon as all pending replies have been written to the client.</source>
          <target state="translated">서버에게 연결을 닫으라고 요청하십시오. 보류중인 모든 회신이 클라이언트에 기록 되 자마자 연결이 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="14070ea7474a205db9d3fb81cc4d13bc90f1f1d9" translate="yes" xml:space="preserve">
          <source>Assign itself all the hash slots of its master, and propagate the new configuration to every node which is reachable ASAP, and eventually to every other node.</source>
          <target state="translated">마스터의 모든 해시 슬롯을 자체적으로 할당하고 가능한 빨리 도달 가능한 모든 노드와 다른 모든 노드에 새 구성을 전파하십시오.</target>
        </trans-unit>
        <trans-unit id="dad88cac85a84619b71e6377f7daff4cceaf9449" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;mylist&lt;/code&gt; is a list of numbers, this command will return the same list with the elements sorted from small to large. In order to sort the numbers from large to small, use the &lt;code&gt;DESC&lt;/code&gt; modifier:</source>
          <target state="translated">&lt;code&gt;mylist&lt;/code&gt; 가 숫자 목록 이라고 가정하면 이 명령은 요소를 작은 것에서 큰 것으로 정렬하여 동일한 목록을 반환합니다. 숫자를 큰 숫자에서 작은 숫자로 정렬하려면 &lt;code&gt;DESC&lt;/code&gt; 수정자를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="010bc7ebc048785c84f0ef161a24878d38afdc74" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; and &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; commands only delete keys that were present at the time the command was invoked. Keys created during an asynchronous flush will be unaffected.</source>
          <target state="translated">비동기식 &lt;a href=&quot;flushall&quot;&gt;FLUSHALL&lt;/a&gt; 및 &lt;a href=&quot;flushdb&quot;&gt;FLUSHDB&lt;/a&gt; 명령은 명령이 호출 될 때 존재했던 키만 삭제합니다. 비동기 플러시 중에 생성 된 키는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="917fb2b280881b904605b028a37696fbc08e07d1" translate="yes" xml:space="preserve">
          <source>At this point the new conversions are available, specifically:</source>
          <target state="translated">이 시점에서 특히 다음과 같은 새로운 변환을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08f85fbfa8d38f4d4fc4368e61ca47c40b831995" translate="yes" xml:space="preserve">
          <source>At this point you add all the elements into a sorted set using this algorithm:</source>
          <target state="translated">이 시점에서이 알고리즘을 사용하여 모든 요소를 ​​정렬 된 세트에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7f922bf277a422b7aa1b3e6b1ecb1c33f7f356b4" translate="yes" xml:space="preserve">
          <source>At this point, each time you want to get a weighted random element, just compute a random number between 0 and 1 (which is like calling &lt;code&gt;rand()&lt;/code&gt; in most languages), so you can just do:</source>
          <target state="translated">이 시점에서 가중 무작위 요소를 얻으려면 0에서 1 사이의 임의의 숫자 &lt;code&gt;rand()&lt;/code&gt; 대부분의 언어에서 rand () 를 호출하는 것과 같은 ) 를 계산하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="eeda06eb4e4b735e9051a2d2f05c160b9b8289f8" translate="yes" xml:space="preserve">
          <source>Atomic rewrite process</source>
          <target state="translated">원자 재 작성 과정</target>
        </trans-unit>
        <trans-unit id="9081c20623d6921cb283f837b5ab328f068f4ee0" translate="yes" xml:space="preserve">
          <source>Atomically returns and removes the first/last element (head/tail depending on the &lt;code&gt;wherefrom&lt;/code&gt; argument) of the list stored at &lt;code&gt;source&lt;/code&gt;, and pushes the element at the first/last element (head/tail depending on the &lt;code&gt;whereto&lt;/code&gt; argument) of the list stored at &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">원자 반품 및 첫 번째 / 마지막 요소를합니다 (에 따라 헤드 / 테일 제거 &lt;code&gt;wherefrom&lt;/code&gt; 의 에 저장된 목록의 인수) &lt;code&gt;source&lt;/code&gt; 및합니다 (에 따라 헤드 / 테일 첫 번째 / 마지막 요소에있는 요소를 밀어 &lt;code&gt;whereto&lt;/code&gt; 저장 목록의 인수) 에서 &lt;code&gt;destination&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f74a4fa429114feaddb20d28202c0f4085635272" translate="yes" xml:space="preserve">
          <source>Atomically returns and removes the last element (tail) of the list stored at &lt;code&gt;source&lt;/code&gt;, and pushes the element at the first element (head) of the list stored at &lt;code&gt;destination&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 에 저장된 목록의 마지막 요소 (꼬리)를 원자 적으로 반환하고 제거하고 &lt;code&gt;destination&lt;/code&gt; 에 저장된 목록의 첫 번째 요소 (머리)에 요소를 푸시 합니다 .</target>
        </trans-unit>
        <trans-unit id="f6a41c1878a1c7a7b99d6378b8645723ed06556f" translate="yes" xml:space="preserve">
          <source>Atomically sets &lt;code&gt;key&lt;/code&gt; to &lt;code&gt;value&lt;/code&gt; and returns the old value stored at &lt;code&gt;key&lt;/code&gt;. Returns an error when &lt;code&gt;key&lt;/code&gt; exists but does not hold a string value.</source>
          <target state="translated">원자 설정 &lt;code&gt;key&lt;/code&gt; 에 &lt;code&gt;value&lt;/code&gt; 과에 저장된 이전 값 리턴 &lt;code&gt;key&lt;/code&gt; . &lt;code&gt;key&lt;/code&gt; 가 있지만 문자열 값을 보유하지 않은 경우 오류를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="8b11c68f40fb668f25d5ebde4e4f0d736514c197" translate="yes" xml:space="preserve">
          <source>Atomically transfer a key from a source Redis instance to a destination Redis instance. On success the key is deleted from the original instance and is guaranteed to exist in the target instance.</source>
          <target state="translated">소스 Redis 인스턴스에서 대상 Redis 인스턴스로 키를 원자 적으로 전송합니다. 성공하면 키가 원래 인스턴스에서 삭제되고 대상 인스턴스에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="120b36c4fdcd059217cbe9ce714cea19b13fd52a" translate="yes" xml:space="preserve">
          <source>Atomicity of scripts</source>
          <target state="translated">스크립트의 원 자성</target>
        </trans-unit>
        <trans-unit id="6a7f6b699ae2620127572c6b19a3962b68ea30ba" translate="yes" xml:space="preserve">
          <source>Available libraries</source>
          <target state="translated">사용 가능한 라이브러리</target>
        </trans-unit>
        <trans-unit id="fc1c7e083bc573df54c3a610bc7a64ef713879e0" translate="yes" xml:space="preserve">
          <source>B sends node A a heartbeat packet, where node D is listed.</source>
          <target state="translated">B는 노드 A에 하트 비트 패킷을 보내며, 여기서 노드 D가 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="7729f6e6ec6ba874a64709376383726e87372daa" translate="yes" xml:space="preserve">
          <source>BGREWRITEAOF</source>
          <target state="translated">BGREWRITEAOF</target>
        </trans-unit>
        <trans-unit id="458f7ff8a0210a97fe946685d4c3eaec2c4d3268" translate="yes" xml:space="preserve">
          <source>BGREWRITEAOF   Asynchronously rewrite the append-only file</source>
          <target state="translated">BGREWRITEAOF 추가 전용 파일을 비동기 적으로 다시 작성</target>
        </trans-unit>
        <trans-unit id="a27e9a0dccc378a573407c1d809762f71f913c63" translate="yes" xml:space="preserve">
          <source>BGSAVE</source>
          <target state="translated">BGSAVE</target>
        </trans-unit>
        <trans-unit id="7faf716555dfc6c9000f52854e242ef60d56665d" translate="yes" xml:space="preserve">
          <source>BGSAVE   Asynchronously save the dataset to disk</source>
          <target state="translated">BGSAVE 데이터 세트를 디스크에 비동기 적으로 저장</target>
        </trans-unit>
        <trans-unit id="ab695def32445abd5af69c89b4fc9a578a6be30c" translate="yes" xml:space="preserve">
          <source>BGSAVE  [SCHEDULE]   Asynchronously save the dataset to disk</source>
          <target state="translated">BGSAVE [SCHEDULE] 데이터 세트를 디스크에 비동기식으로 저장</target>
        </trans-unit>
        <trans-unit id="aa73037de86a35867f756331811a0b553f9a4512" translate="yes" xml:space="preserve">
          <source>BITCOUNT</source>
          <target state="translated">BITCOUNT</target>
        </trans-unit>
        <trans-unit id="558065aa2007c718ef4867af43bb99fd2d71d712" translate="yes" xml:space="preserve">
          <source>BITCOUNT  key [start end]   Count set bits in a string</source>
          <target state="translated">BITCOUNT 키 [시작 끝] 문자열의 카운트 세트 비트</target>
        </trans-unit>
        <trans-unit id="4648876b3aec23fc361c9cc8f6b361de8992e75b" translate="yes" xml:space="preserve">
          <source>BITFIELD</source>
          <target state="translated">BITFIELD</target>
        </trans-unit>
        <trans-unit id="4e856b858022af2e0acd6b68544eced1b0992122" translate="yes" xml:space="preserve">
          <source>BITFIELD  key [GET type offset] [SET type offset value] [INCRBY type offset increment] [OVERFLOW WRAP|SAT|FAIL]   Perform arbitrary bitfield integer operations on strings</source>
          <target state="translated">BITFIELD 키 [GET 유형 오프셋] [SET 유형 오프셋 값] [INCRBY 유형 오프셋 증분] [OVERFLOW WRAP | SAT | FAIL] 문자열에서 임의의 비트 필드 정수 연산 수행</target>
        </trans-unit>
        <trans-unit id="a5aaf403ca55d3d64f12bde81881e9c02072728a" translate="yes" xml:space="preserve">
          <source>BITOP</source>
          <target state="translated">BITOP</target>
        </trans-unit>
        <trans-unit id="fbf06b661d51c935ecb7a0e541d91fa350da1c52" translate="yes" xml:space="preserve">
          <source>BITOP  operation destkey key [key ...]   Perform bitwise operations between strings</source>
          <target state="translated">BITOP 작업 destkey 키 [key ...] 문자열 간 비트 연산 수행</target>
        </trans-unit>
        <trans-unit id="6429405be50a33193090d8d4c0a4575b80d167fc" translate="yes" xml:space="preserve">
          <source>BITPOS</source>
          <target state="translated">BITPOS</target>
        </trans-unit>
        <trans-unit id="3eedfee8a6aaf27b486a0a74ef694737767592c5" translate="yes" xml:space="preserve">
          <source>BITPOS  key bit [start] [end]   Find first bit set or clear in a string</source>
          <target state="translated">BITPOS 키 비트 [start] [end] 문자열에서 첫 번째 비트 세트 찾기 또는 지우기</target>
        </trans-unit>
        <trans-unit id="fc2dfb0c3d9a6c59a7ce67610ea5adaf29a615be" translate="yes" xml:space="preserve">
          <source>BLMOVE</source>
          <target state="translated">BLMOVE</target>
        </trans-unit>
        <trans-unit id="db9a7aeda5f34e5b6dc6bfc16ff9ad89a6ecbdee" translate="yes" xml:space="preserve">
          <source>BLMOVE  source destination LEFT|RIGHT LEFT|RIGHT timeout   Pop an element from a list, push it to another list and return it; or block until one is available</source>
          <target state="translated">BLMOVE 소스 대상 LEFT | RIGHT LEFT | RIGHT 시간 제한 목록에서 요소를 팝하고 다른 목록으로 푸시 한 다음 반환합니다. 또는 사용할 수있을 때까지 차단</target>
        </trans-unit>
        <trans-unit id="f05499a7141cb9854f00176880caa9ac423867f3" translate="yes" xml:space="preserve">
          <source>BLPOP</source>
          <target state="translated">BLPOP</target>
        </trans-unit>
        <trans-unit id="0412d709e7cedab62c94968e19cc0014d112f86b" translate="yes" xml:space="preserve">
          <source>BLPOP  key [key ...] timeout   Remove and get the first element in a list, or block until one is available</source>
          <target state="translated">BLPOP 키 [key ...] timeout 목록에서 첫 번째 요소를 제거하여 가져 오거나 사용할 수있을 때까지 차단</target>
        </trans-unit>
        <trans-unit id="5fa06c19410e8a659911506832eca92eaf0050d6" translate="yes" xml:space="preserve">
          <source>BRPOP</source>
          <target state="translated">BRPOP</target>
        </trans-unit>
        <trans-unit id="30c26bc19b012eb7d9f5f55b03c3f9d84b9cf9c5" translate="yes" xml:space="preserve">
          <source>BRPOP  key [key ...] timeout   Remove and get the last element in a list, or block until one is available</source>
          <target state="translated">BRPOP 키 [key ...] timeout 목록에서 마지막 요소를 제거하고 가져 오거나 사용할 수있을 때까지 차단</target>
        </trans-unit>
        <trans-unit id="c32cdb6143356d21802163582eddef7653863e06" translate="yes" xml:space="preserve">
          <source>BRPOPLPUSH</source>
          <target state="translated">BRPOPLPUSH</target>
        </trans-unit>
        <trans-unit id="74721eebf76b2ddc61de86b46cc0aec39763409c" translate="yes" xml:space="preserve">
          <source>BRPOPLPUSH  source destination timeout   Pop a value from a list, push it to another list and return it; or block until one is available</source>
          <target state="translated">BRPOPLPUSH 소스 대상 시간 종료 목록에서 값을 팝하여 다른 목록으로 푸시 한 후 리턴하십시오. 또는 하나를 사용할 수있을 때까지 차단</target>
        </trans-unit>
        <trans-unit id="06a6c1ed02823440cc121edde6eb065e5de27fb8" translate="yes" xml:space="preserve">
          <source>BRPOPLPUSH  source destination timeout   Pop an element from a list, push it to another list and return it; or block until one is available</source>
          <target state="translated">BRPOPLPUSH 소스 대상 시간 제한 목록에서 요소를 팝하고 다른 목록으로 푸시 한 다음 반환합니다. 또는 사용할 수있을 때까지 차단</target>
        </trans-unit>
        <trans-unit id="fe7a2ea791972d134e771e602c9bb77407df350d" translate="yes" xml:space="preserve">
          <source>BZPOPMAX</source>
          <target state="translated">BZPOPMAX</target>
        </trans-unit>
        <trans-unit id="b6758ab6d65fab9e15ff22d76094622028d82dec" translate="yes" xml:space="preserve">
          <source>BZPOPMAX  key [key ...] timeout   Remove and return the member with the highest score from one or more sorted sets, or block until one is available</source>
          <target state="translated">BZPOPMAX 키 [key ...] timeout 하나 이상의 정렬 된 세트에서 가장 높은 점수를 가진 멤버를 제거하고 리턴하거나 하나를 사용할 수있을 때까지 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="cc5c70cba5a0768ab8e3b521a15ca38c10af43e5" translate="yes" xml:space="preserve">
          <source>BZPOPMIN</source>
          <target state="translated">BZPOPMIN</target>
        </trans-unit>
        <trans-unit id="34934a39c9faa59399a1c05af5d02cc1bce19590" translate="yes" xml:space="preserve">
          <source>BZPOPMIN  key [key ...] timeout   Remove and return the member with the lowest score from one or more sorted sets, or block until one is available</source>
          <target state="translated">BZPOPMIN 키 [key ...] timeout 하나 이상의 정렬 된 세트에서 점수가 가장 낮은 멤버를 제거하고 반환하거나, 사용 가능한 세트가있을 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="baab43179123dd499c2cc2c83ab2bfdd9cbd1aec" translate="yes" xml:space="preserve">
          <source>Bandwidth and EVALSHA</source>
          <target state="translated">대역폭과 EVALSHA</target>
        </trans-unit>
        <trans-unit id="65f639d2a40570f68ed54fc56bf243ceac2035a0" translate="yes" xml:space="preserve">
          <source>Basic usage:</source>
          <target state="translated">기본 사용법 :</target>
        </trans-unit>
        <trans-unit id="7df3c519fe73f3ffe3f8fb928955ded445b7f85e" translate="yes" xml:space="preserve">
          <source>Basically the command sets a state in the connection, that is valid only for the next command execution, that will modify the behavior of client tracking.</source>
          <target state="translated">기본적으로 명령은 클라이언트 추적 동작을 수정하는 다음 명령 실행에만 유효한 연결 상태를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="12e09074a5a31051e466bb25ea4c7f7009a10585" translate="yes" xml:space="preserve">
          <source>Basically we have a counter for every IP, for every different second. But this counters are always incremented setting an expire of 10 seconds so that they'll be removed by Redis automatically when the current second is a different one.</source>
          <target state="translated">기본적으로 모든 IP, 매 초마다 카운터가 있습니다. 그러나이 카운터는 항상 10 초의 만료를 설정하여 증가하므로 현재 초가 다른 경우 Redis가 자동으로 제거합니다.</target>
        </trans-unit>
        <trans-unit id="3bc673f7ca5e59c74c138e173d60ace2cc7f15b0" translate="yes" xml:space="preserve">
          <source>Basically, the function considers the right of the string as padded with zeros if you look for clear bits and specify no range or the &lt;em&gt;start&lt;/em&gt; argument &lt;strong&gt;only&lt;/strong&gt;.</source>
          <target state="translated">기본적으로 함수는 명확한 비트를 찾고 범위를 지정하지 않거나 &lt;em&gt;시작&lt;/em&gt; 인수 &lt;strong&gt;만&lt;/strong&gt; 지정하면 문자열의 오른쪽을 0으로 채워진 것으로 간주합니다 .</target>
        </trans-unit>
        <trans-unit id="14b677b3a5e36da0c5dac8a200bd5400f84443e8" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; streams back &lt;strong&gt;all&lt;/strong&gt; commands, its use comes at a cost. The following (totally unscientific) benchmark numbers illustrate what the cost of running &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; can be.</source>
          <target state="translated">&lt;a href=&quot;monitor&quot;&gt;MONITOR는 &lt;/a&gt;&lt;strong&gt;모든&lt;/strong&gt; 명령을 다시 스트리밍 하기 때문에 비용이 많이 듭니다. 다음 (전체적으로 비과학적인) 벤치 마크 숫자는 &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 실행 비용이 얼마 인지 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="168e98970df56293fbc42baf15adc634cb88819b" translate="yes" xml:space="preserve">
          <source>Because Redis does not have control over how its allocations are mapped to memory pages, high &lt;code&gt;used_memory_rss&lt;/code&gt; is often the result of a spike in memory usage.</source>
          <target state="translated">Redis는 할당이 메모리 페이지에 매핑되는 방식을 제어 할 수 없으므로 높은 &lt;code&gt;used_memory_rss&lt;/code&gt; 는 종종 메모리 사용량이 급증한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="9157dfb92d6b10926d702b4d13ee089e71af6988" translate="yes" xml:space="preserve">
          <source>Because Redis' strings are binary-safe, a bitmap is trivially encoded as a bytes stream. The first byte of the string corresponds to offsets 0..7 of the bitmap, the second byte to the 8..15 range, and so forth.</source>
          <target state="translated">Redis의 문자열은 바이너리 안전하므로 비트 맵은 간단하게 바이트 스트림으로 인코딩됩니다. 문자열의 첫 번째 바이트는 비트 맵의 ​​오프셋 0..7에 해당하고 두 번째 바이트는 8..15 범위에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="ba14992feb507791cf455ac84d4bc0c1654fa142" translate="yes" xml:space="preserve">
          <source>Because of security concerns, all administrative commands are not logged by &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;'s output.</source>
          <target state="translated">보안 문제로 인해 모든 관리 명령은 &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 의 출력에 의해 기록되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="5c7ae78faec3383e9f506c3f0134610891480461" translate="yes" xml:space="preserve">
          <source>Because of the &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; semantic, C4 can check if the old value stored at &lt;code&gt;key&lt;/code&gt; is still an expired timestamp. If it is, the lock was acquired.</source>
          <target state="translated">&lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; 시맨틱으로 인해 C4는 &lt;code&gt;key&lt;/code&gt; 저장된 이전 값 이 여전히 만료 된 시간 소인 인지 확인할 수 있습니다 . 그렇다면 잠금을 획득 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="02e8504630183a9016b44fe68aa220f28cac8de4" translate="yes" xml:space="preserve">
          <source>Because of the first &lt;em&gt;normalized&lt;/em&gt; part in every element (before the colon character), we are forcing a given comparison, however after the range is queries using &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; the application can display to the user the second part of the string, after the colon.</source>
          <target state="translated">모든 요소에서 첫 번째 &lt;em&gt;정규화 된&lt;/em&gt; 부분 (콜론 문자 이전)으로 인해 주어진 비교를 수행하지만 범위가 &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX를&lt;/a&gt; 사용 하는 쿼리 후에 는 애플리케이션이 사용자에게 콜론 다음에 문자열의 두 번째 부분을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d59e94adcd8272e3572e2454feb728deea07f9f" translate="yes" xml:space="preserve">
          <source>Because of the high performance nature of Redis, it is possible to try a lot of passwords in parallel in very short time, so make sure to generate a strong and very long password so that this attack is infeasible. A good way to generate strong passwords is via the &lt;a href=&quot;acl-genpass&quot;&gt;ACL GENPASS&lt;/a&gt; command.</source>
          <target state="translated">Redis의 고성능 특성으로 인해 매우 짧은 시간에 많은 암호를 병렬로 시도 할 수 있으므로이 공격이 실행되지 않도록 강력하고 매우 긴 암호를 생성해야합니다. 강력한 암호를 생성하는 좋은 방법은 &lt;a href=&quot;acl-genpass&quot;&gt;ACL GENPASS&lt;/a&gt; 명령을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="05dcf4c78858f10b7a1c629d42f2c28c91d50489" translate="yes" xml:space="preserve">
          <source>Because of this semantic &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; can be used in order to set different keys representing different fields of an unique logic object in a way that ensures that either all the fields or none at all are set.</source>
          <target state="translated">이러한 의미 때문에 &lt;a href=&quot;msetnx&quot;&gt;MSETNX&lt;/a&gt; 를 사용하면 모든 필드를 설정하거나 전혀 설정하지 않는 방식으로 고유 논리 객체의 다른 필드를 나타내는 다른 키를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5743095da9632a185291117b22aab7a1ce272b02" translate="yes" xml:space="preserve">
          <source>Because of this the &lt;strong&gt;TAKEOVER&lt;/strong&gt; option should be used with care.</source>
          <target state="translated">이 때문에 &lt;strong&gt;TAKEOVER&lt;/strong&gt; 옵션은주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="409eae8dc6d494086fe4746042f7a180a489be81" translate="yes" xml:space="preserve">
          <source>Because when a given node is part of the cluster, all the other nodes participating in the cluster knows about it, in order for a node to be completely removed from a cluster, the &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; command must be sent to all the remaining nodes, regardless of the fact they are masters or replicas.</source>
          <target state="translated">지정된 노드가 클러스터의 일부인 경우 클러스터에 참여하는 다른 모든 노드가 클러스터에 대해 알고 있으므로 클러스터에서 노드를 완전히 제거하려면 &lt;a href=&quot;cluster-forget&quot;&gt;CLUSTER FORGET&lt;/a&gt; 명령을 나머지 모든 노드로 보내야합니다. 사실 그들은 마스터 또는 복제본입니다.</target>
        </trans-unit>
        <trans-unit id="b69310332fe10ffd788fd56a9c44b252e49e79dc" translate="yes" xml:space="preserve">
          <source>Behavior of &lt;code&gt;BLPOP&lt;/code&gt; when multiple elements are pushed inside a list.</source>
          <target state="translated">여러 요소가 목록 내에서 푸시 될 때 &lt;code&gt;BLPOP&lt;/code&gt; 의 동작</target>
        </trans-unit>
        <trans-unit id="ece0bd32123faa73ffba96af59789eb1a4470a5d" translate="yes" xml:space="preserve">
          <source>Benchmark result &lt;strong&gt;with&lt;/strong&gt;&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; running (&lt;code&gt;redis-cli monitor &amp;gt; /dev/null&lt;/code&gt;):</source>
          <target state="translated">벤치 마크 결과 &lt;strong&gt;와 &lt;/strong&gt;&lt;a href=&quot;monitor&quot;&gt;모니터&lt;/a&gt; 실행 ( &lt;code&gt;redis-cli monitor &amp;gt; /dev/null&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="e3f9de77c51bcc4c2a59cae3df6e39530202793d" translate="yes" xml:space="preserve">
          <source>Benchmark result &lt;strong&gt;without&lt;/strong&gt;&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; running:</source>
          <target state="translated">&lt;a href=&quot;monitor&quot;&gt;MONITOR를&lt;/a&gt; 실행 &lt;strong&gt;하지 않은&lt;/strong&gt; 벤치 마크 결과 :</target>
        </trans-unit>
        <trans-unit id="a0cee838302dd7dccb0ba96b0e4f12c473f5ce1f" translate="yes" xml:space="preserve">
          <source>Bitmaps are a very space-efficient representation of certain kinds of information. One example is a Web application that needs the history of user visits, so that for instance it is possible to determine what users are good targets of beta features.</source>
          <target state="translated">비트 맵은 특정 종류의 정보를 매우 공간 효율적으로 표현한 것입니다. 예를 들어 사용자 방문 기록이 필요한 웹 응용 프로그램이 있습니다. 예를 들어 베타 기능의 대상이되는 사용자를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="927448b58910f0636586793360308442afd14b22" translate="yes" xml:space="preserve">
          <source>Bitmaps are not an actual data type, but a set of bit-oriented operations defined on the String type (for more information refer to the &lt;a href=&quot;https://redis.io/topics/data-types-intro#bitmaps&quot;&gt;Bitmaps section of the Data Types Introduction page&lt;/a&gt;). This means that bitmaps can be used with string commands, and most importantly with &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; and &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt;.</source>
          <target state="translated">비트 맵은 실제 데이터 유형이 아니지만 문자열 유형에 정의 된 비트 지향 연산 집합입니다 (자세한 내용 &lt;a href=&quot;https://redis.io/topics/data-types-intro#bitmaps&quot;&gt;은 데이터 유형 소개 페이지&lt;/a&gt; 의 비트 맵 섹션 참조 ). 이는 비트 맵을 문자열 명령과 함께 사용할 수 있으며 가장 중요한 것은 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 및 &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; 과 함께 사용할 수 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="23c5f7ddc4fdd4c0470d5c822a63678ca6ac8364" translate="yes" xml:space="preserve">
          <source>Bits and positional offsets</source>
          <target state="translated">비트 및 위치 오프셋</target>
        </trans-unit>
        <trans-unit id="01b1462f91bf6adae4924e41a337cd3105d30fba" translate="yes" xml:space="preserve">
          <source>Blocking behavior</source>
          <target state="translated">행동 차단</target>
        </trans-unit>
        <trans-unit id="0138f8dd5046866e565b72d9550fe5224c0fb4c2" translate="yes" xml:space="preserve">
          <source>Blocking for data</source>
          <target state="translated">데이터 차단</target>
        </trans-unit>
        <trans-unit id="b9cbba32c11fb20d3cd9b4d8a8851ece3dbdac10" translate="yes" xml:space="preserve">
          <source>Blocking list operations on lists or sorted sets have a &lt;em&gt;pop&lt;/em&gt; behavior. Bascially, the element is removed from the list or sorted set in order to be returned to the client. In this scenario you want the items to be consumed in a fair way, depending on the moment clients blocked on a given key arrived. Normally Redis uses the FIFO semantics in this use cases.</source>
          <target state="translated">목록 또는 정렬 된 집합에 대한 차단 목록 작업에는 &lt;em&gt;팝&lt;/em&gt; 동작이 있습니다. 기본적으로 요소는 클라이언트에서 리턴되도록 목록 또는 정렬 된 세트에서 제거됩니다. 이 시나리오에서는 특정 키에서 클라이언트가 차단 된 순간에 따라 공정한 방식으로 품목을 소비하려고합니다. 일반적으로 Redis는이 사용 사례에서 FIFO 의미를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c7b48b477a47bc528502abd2750eaf8176a42526" translate="yes" xml:space="preserve">
          <source>Blocking list operations on lists or sorted sets have a &lt;em&gt;pop&lt;/em&gt; behavior. Basically, the element is removed from the list or sorted set in order to be returned to the client. In this scenario you want the items to be consumed in a fair way, depending on the moment clients blocked on a given key arrived. Normally Redis uses the FIFO semantics in this use cases.</source>
          <target state="translated">목록 또는 정렬 된 집합에 대한 차단 목록 작업에는 &lt;em&gt;팝&lt;/em&gt; 동작이 있습니다. 기본적으로 요소는 클라이언트에 반환하기 위해 목록에서 제거되거나 정렬 된 집합입니다. 이 시나리오에서는 주어진 키에서 차단 된 클라이언트가 도착한 순간에 따라 항목이 공정한 방식으로 소비되기를 원합니다. 일반적으로 Redis는이 사용 사례에서 FIFO 의미 체계를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="83af529ff0234ebb19ae9fc92954913ed20af976" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are zero-based indexes, where &lt;code&gt;0&lt;/code&gt; is the first element, &lt;code&gt;1&lt;/code&gt; is the next element and so on. They can also be negative numbers indicating offsets from the end of the sorted set, with &lt;code&gt;-1&lt;/code&gt; being the last element of the sorted set, &lt;code&gt;-2&lt;/code&gt; the penultimate element and so on.</source>
          <target state="translated">모두 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 위치를 0부터 인덱스입니다 &lt;code&gt;0&lt;/code&gt; , 첫 번째 요소입니다 &lt;code&gt;1&lt;/code&gt; 다음 요소 등이다. &lt;code&gt;-1&lt;/code&gt; 은 정렬 된 세트 의 마지막 요소, &lt;code&gt;-2&lt;/code&gt; 는 두 번째 요소 등과 같이 정렬 된 세트의 끝에서 오프셋을 나타내는 음수 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23a10624171d72fb4e9f07612b39ccbc04699493" translate="yes" xml:space="preserve">
          <source>Both commands were introduced in Redis 3.2.10 and Redis 4.0.0 respectively.</source>
          <target state="translated">두 명령은 각각 Redis 3.2.10 및 Redis 4.0.0에서 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="3146bb227c4234d6267f94725155f23545044b63" translate="yes" xml:space="preserve">
          <source>Both quantities are 64-bit numbers. When an ID is auto-generated, the first part is the Unix time in milliseconds of the Redis instance generating the ID. The second part is just a sequence number and is used in order to distinguish IDs generated in the same millisecond.</source>
          <target state="translated">두 수량 모두 64 비트 숫자입니다. ID가 자동 생성 될 때 첫 번째 부분은 ID를 생성하는 Redis 인스턴스의 Unix 시간 (밀리 초)입니다. 두 번째 부분은 시퀀스 번호 일 뿐이며 동일한 밀리 초 내에 생성 된 ID를 구별하기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4a1f2ae398c91bf9d6a2b34bf5c23ed87585d341" translate="yes" xml:space="preserve">
          <source>Both representations are prefixed with a 16 bytes header, that includes a magic, an encoding / version field, and the cached cardinality estimation computed, stored in little endian format (the most significant bit is 1 if the estimation is invalid since the HyperLogLog was updated since the cardinality was computed).</source>
          <target state="translated">두 표현 모두 16 바이트 헤더가 접두어로 붙습니다. 여기에는 마술, 인코딩 / 버전 필드 및 캐시 된 카디널리티 추정이 포함되어 리틀 엔디안 형식으로 저장됩니다 (HyperLogLog가 업데이트 된 이후 추정이 유효하지 않은 경우 가장 중요한 비트는 1 임) 카디널리티가 계산 된 이후).</target>
        </trans-unit>
        <trans-unit id="c7a36cc87678ec27033bceb0e99f2d1deac9e434" translate="yes" xml:space="preserve">
          <source>Both the value already contained in the string key and the increment argument can be optionally provided in exponential notation, however the value computed after the increment is stored consistently in the same format, that is, an integer number followed (if needed) by a dot, and a variable number of digits representing the decimal part of the number. Trailing zeroes are always removed.</source>
          <target state="translated">문자열 키에 이미 포함 된 값과 증가 인수는 선택적으로 지수 표기법으로 제공 될 수 있지만, 증가 후 계산 된 값은 동일한 형식, 즉 정수가 뒤에 오는 정수 (점수) 뒤에 일관되게 저장됩니다. 및 숫자의 소수 부분을 나타내는 가변 자릿수입니다. 후행 0은 항상 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="046892586ee04199d779966b3fd711b935a2c4ee" translate="yes" xml:space="preserve">
          <source>Breaking the compatibility with the past was considered but rejected, at least for Redis 4.0, so instead two read only variants of the commands were added. They are exactly like the original commands but refuse the &lt;code&gt;STORE&lt;/code&gt; and &lt;code&gt;STOREDIST&lt;/code&gt; options. The two variants are called &lt;code&gt;GEORADIUS_RO&lt;/code&gt; and &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt;, and can safely be used in replicas.</source>
          <target state="translated">적어도 Redis 4.0에서는 과거와의 호환성을 깨는 것이 고려되었지만 거부되었으므로 대신 두 가지 읽기 전용 명령이 추가되었습니다. 이들은 원래 명령과 동일하지만 &lt;code&gt;STORE&lt;/code&gt; 및 &lt;code&gt;STOREDIST&lt;/code&gt; 옵션을 거부합니다 . 두 가지 변형을 &lt;code&gt;GEORADIUS_RO&lt;/code&gt; 및 &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; 라고 하며 복제본에서 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11d2a59be0a7424e67e9c632e3f055f99238638f" translate="yes" xml:space="preserve">
          <source>Bulk string reply</source>
          <target state="translated">대량 문자열 회신</target>
        </trans-unit>
        <trans-unit id="3e53e1d484c0afdd9ee478c43d641e56563db80a" translate="yes" xml:space="preserve">
          <source>But in the above case the output would be the same, since we have pending messages only for a single consumer. However what is important to keep in mind is that this operation, filtering by a specific consumer, is not inefficient even when there are many pending messages from many consumers: we have a pending entries list data structure both globally, and for every consumer, so we can very efficiently show just messages pending for a single consumer.</source>
          <target state="translated">그러나 위의 경우 단일 소비자에 대해서만 보류중인 메시지가 있기 때문에 출력은 동일합니다. 그러나 명심해야 할 중요한 점은 특정 소비자에 의해 필터링되는이 작업은 많은 소비자로부터 보류중인 메시지가 많은 경우에도 비효율적이지 않다는 것입니다. 전 세계 및 모든 소비자에 대해 보류중인 항목 목록 데이터 구조가 있으므로 단일 소비자에게 보류중인 메시지 만 매우 효율적으로 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fb6518aff837e3fbb56cbdada4b700f62c1931e" translate="yes" xml:space="preserve">
          <source>By default (if /dev/urandom is available) the password is strong and can be used for other uses in the context of a Redis application, for instance in order to create unique session identifiers or other kind of unguessable and not colliding IDs. The password generation is also very cheap because we don't really ask /dev/urandom for bits at every execution. At startup Redis creates a seed using /dev/urandom, then it will use SHA256 in counter mode, with HMAC-SHA256(seed,counter) as primitive, in order to create more random bytes as needed. This means that the application developer should be feel free to abuse &lt;a href=&quot;acl-genpass&quot;&gt;ACL GENPASS&lt;/a&gt; to create as many secure pseudorandom strings as needed.</source>
          <target state="translated">기본적으로 (/ dev / urandom을 사용할 수있는 경우) 암호는 강력하며 고유 한 세션 식별자 또는 다른 종류의 추측 할 수없고 충돌하지 않는 ID를 생성하기 위해 Redis 애플리케이션 컨텍스트에서 다른 용도로 사용할 수 있습니다. 암호 생성은 또한 매우 저렴합니다. 우리는 매 실행마다 비트를 / dev / urandom에 묻지 않기 때문입니다. 시작할 때 Redis는 / dev / urandom을 사용하여 시드를 생성 한 다음 필요에 따라 더 많은 임의의 바이트를 생성하기 위해 HMAC-SHA256 (seed, counter)을 기본으로 사용하여 카운터 모드에서 SHA256을 사용합니다. 이는 애플리케이션 개발자가 &lt;a href=&quot;acl-genpass&quot;&gt;ACL GENPASS&lt;/a&gt; 를 악용 하여 필요한만큼의 보안 의사 난수 문자열을 생성 할 수 있다는 것을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="5c8217506d8ebbaa0e107de581511ee5f509b818" translate="yes" xml:space="preserve">
          <source>By default all the bytes contained in the string are examined. It is possible to specify the counting operation only in an interval passing the additional arguments &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt;.</source>
          <target state="translated">기본적으로 문자열에 포함 된 모든 바이트가 검사됩니다. 추가 인수 &lt;em&gt;start&lt;/em&gt; 및 &lt;em&gt;end를&lt;/em&gt; 전달하는 간격으로 만 계산 작업을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e9840a0fb9a28f465bc984e84fdef1e46818881" translate="yes" xml:space="preserve">
          <source>By default all the matching items are returned. It is possible to limit the results to the first N matching items by using the &lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt;&lt;/strong&gt; option. However note that internally the command needs to perform an effort proportional to the number of items matching the specified area, so to query very large areas with a very small &lt;code&gt;COUNT&lt;/code&gt; option may be slow even if just a few results are returned. On the other hand &lt;code&gt;COUNT&lt;/code&gt; can be a very effective way to reduce bandwidth usage if normally just the first results are used.</source>
          <target state="translated">기본적으로 모든 일치하는 항목이 반환됩니다. &lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; &lt;/strong&gt; 옵션 을 사용하여 결과를 첫 번째 N 개의 일치하는 항목으로 제한 할 &lt;strong&gt;수&lt;/strong&gt; 있습니다. 그러나 내부적으로 명령은 지정된 영역과 일치하는 항목 수에 비례하여 노력을 수행해야하므로 매우 적은 수의 &lt;code&gt;COUNT&lt;/code&gt; 옵션으로 매우 큰 영역을 쿼리 하면 몇 가지 결과 만 반환 되더라도 속도가 느려질 수 있습니다. 반면에 &lt;code&gt;COUNT&lt;/code&gt; 는 일반적으로 첫 번째 결과 만 사용되는 경우 대역폭 사용량을 줄이는 매우 효과적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="38a3d7ce77609a064a8c66435e5a2ddef01589e2" translate="yes" xml:space="preserve">
          <source>By default the &lt;a href=&quot;lolwut&quot;&gt;LOLWUT&lt;/a&gt; command will display the piece corresponding to the current Redis version, however it is possible to display a specific version using the following form:</source>
          <target state="translated">기본적으로 &lt;a href=&quot;lolwut&quot;&gt;LOLWUT&lt;/a&gt; 명령은 현재 Redis 버전에 해당하는 부분을 표시하지만 다음 형식을 사용하여 특정 버전을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f9b368afa2761dde4363a1630f17429f8bc58b2" translate="yes" xml:space="preserve">
          <source>By default the client is unblocked as if the timeout of the command was reached, however if an additional (and optional) argument is passed, it is possible to specify the unblocking behavior, that can be &lt;strong&gt;TIMEOUT&lt;/strong&gt; (the default) or &lt;strong&gt;ERROR&lt;/strong&gt;. If &lt;strong&gt;ERROR&lt;/strong&gt; is specified, the behavior is to unblock the client returning as error the fact that the client was force-unblocked. Specifically the client will receive the following error:</source>
          <target state="translated">기본적으로 클라이언트는 명령의 시간 종료에 도달 한 것처럼 차단이 해제되지만 추가 (및 선택적) 인수가 전달되면 차단 해제 동작을 지정할 수 있습니다. &lt;strong&gt;TIMEOUT&lt;/strong&gt; (기본값) 또는 &lt;strong&gt;ERROR 일 수&lt;/strong&gt; 있습니다. 경우 &lt;strong&gt;오류가&lt;/strong&gt; 지정되면, 동작 오류로 클라이언트가 강제 차단 해제 있다는 사실을 반환 클라이언트를 차단하는 것입니다. 특히 클라이언트는 다음 오류를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="876aa0f6c00a7c0060c29d93b8e069bbd151098c" translate="yes" xml:space="preserve">
          <source>By default the command returns the items to the client. It is possible to store the results with one of these options:</source>
          <target state="translated">기본적으로 명령은 항목을 클라이언트에 반환합니다. 다음 옵션 중 하나를 사용하여 결과를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91bf3b958012756b0a4a417df15abcf41ceea42c" translate="yes" xml:space="preserve">
          <source>By default the scripting engine is always set to &lt;code&gt;REPL_ALL&lt;/code&gt;. By calling this function the user can switch on/off AOF and or replicas propagation, and turn them back later at her/his wish.</source>
          <target state="translated">기본적으로 스크립팅 엔진은 항상 &lt;code&gt;REPL_ALL&lt;/code&gt; 로 설정됩니다 . 이 기능을 호출하면 사용자가 AOF 및 / 또는 복제본 전파를 켜거나 끄고 나중에 원하는대로 다시 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3714f33148cc538954cff3b58af732446c5cd76" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; returns the sorted elements to the client. With the &lt;code&gt;STORE&lt;/code&gt; option, the result will be stored as a list at the specified key instead of being returned to the client.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;sort&quot;&gt;SORT&lt;/a&gt; 는 정렬 된 요소를 클라이언트에 반환합니다. 으로 &lt;code&gt;STORE&lt;/code&gt; 옵션, 결과 대신 클라이언트로 반환되는 지정된 키에 목록으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="2ee8f070e37dc92ade46a57ac677a11708d8c9aa" translate="yes" xml:space="preserve">
          <source>By default, &lt;strong&gt;WRAP&lt;/strong&gt; is used if not otherwise specified.</source>
          <target state="translated">달리 지정되지 않은 경우 기본적으로 &lt;strong&gt;WRAP&lt;/strong&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f7b1d35e79bbf2da51d0b5f48b7d7d355bd0c2fd" translate="yes" xml:space="preserve">
          <source>By default, all the bytes contained in the string are examined. It is possible to look for bits only in a specified interval passing the additional arguments &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; (it is possible to just pass &lt;em&gt;start&lt;/em&gt;, the operation will assume that the end is the last byte of the string. However there are semantic differences as explained later). The range is interpreted as a range of bytes and not a range of bits, so &lt;code&gt;start=0&lt;/code&gt; and &lt;code&gt;end=2&lt;/code&gt; means to look at the first three bytes.</source>
          <target state="translated">기본적으로 문자열에 포함 된 모든 바이트가 검사됩니다. 추가 인수 &lt;em&gt;start&lt;/em&gt; 및 &lt;em&gt;end를&lt;/em&gt; 전달하는 지정된 간격에서만 비트를 찾을 수 있습니다 ( &lt;em&gt;start&lt;/em&gt; 만 전달하는 것이 가능 합니다. 조작은 end가 문자열의 마지막 바이트라고 가정하지만 설명에 따라 의미상의 차이가 있습니다. 나중). 범위는 비트 범위가 아닌 바이트 범위로 해석되므로 &lt;code&gt;start=0&lt;/code&gt; 및 &lt;code&gt;end=2&lt;/code&gt; 는 처음 3 바이트를 보는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ac56e3917c99c4ddfa64494c6e26b8240c053966" translate="yes" xml:space="preserve">
          <source>By default, all the matching items are returned. It is possible to limit the results to the first N matching items by using the &lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt;&lt;/strong&gt; option. However note that internally the command needs to perform an effort proportional to the number of items matching the specified area, so to query very large areas with a very small &lt;code&gt;COUNT&lt;/code&gt; option may be slow even if just a few results are returned. On the other hand &lt;code&gt;COUNT&lt;/code&gt; can be a very effective way to reduce bandwidth usage if normally just the first results are used.</source>
          <target state="translated">기본적으로 일치하는 모든 항목이 반환됩니다. &lt;strong&gt;COUNT &lt;code&gt;&amp;lt;count&amp;gt;&lt;/code&gt; &lt;/strong&gt; 옵션 을 사용하여 처음 N 개의 일치 항목으로 결과를 제한 할 &lt;strong&gt;수&lt;/strong&gt; 있습니다. 그러나 내부적으로 명령은 지정된 영역과 일치하는 항목 수에 비례하여 노력을 수행해야하므로 매우 작은 &lt;code&gt;COUNT&lt;/code&gt; 옵션으로 매우 큰 영역을 쿼리하는 것은 몇 개의 결과 만 반환 되더라도 속도가 느려질 수 있습니다. 반면에 &lt;code&gt;COUNT&lt;/code&gt; 는 일반적으로 첫 번째 결과 만 사용되는 경우 대역폭 사용량을 줄이는 매우 효과적인 방법이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f97c897415a76335a4f3d3db770776a7a0ccedc3" translate="yes" xml:space="preserve">
          <source>By default, it stores the results in the &lt;code&gt;destintion&lt;/code&gt; sorted set with their geospatial information.</source>
          <target state="translated">기본적으로 지형 공간 정보와 함께 정렬 된 &lt;code&gt;destintion&lt;/code&gt; 집합에 결과를 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="5bcfb1fa8d4e16c5703f601d9b874b8021ef089f" translate="yes" xml:space="preserve">
          <source>By default, or when provided with the optional &lt;code&gt;=&lt;/code&gt; argument, the command performs exact trimming. That means that the trimmed stream's length will be exactly the minimum between its original length and the specified maximum length.</source>
          <target state="translated">기본적으로 또는 선택적 &lt;code&gt;=&lt;/code&gt; 인수 와 함께 제공되는 경우 명령은 정확한 트리밍을 수행합니다. 즉, 트리밍 된 스트림의 길이는 원래 길이와 지정된 최대 길이 사이의 최소 길이가됩니다.</target>
        </trans-unit>
        <trans-unit id="3dfdd218a8c7dcfad82b579c16fc98a90e0423ca" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;destination&lt;/code&gt; key is created in the logical database used by the connection. The &lt;code&gt;DB&lt;/code&gt; option allows specifying an alternative logical database index for the destination key.</source>
          <target state="translated">기본적으로 &lt;code&gt;destination&lt;/code&gt; 키는 연결에 사용되는 논리 데이터베이스에 생성됩니다. &lt;code&gt;DB&lt;/code&gt; 의 옵션은 대상 키에 대한 대안 논리적 데이터베이스 인덱스를 지정 허용합니다.</target>
        </trans-unit>
        <trans-unit id="ecf8d58c1f5391dbccf4f7678d43b4f133487bae" translate="yes" xml:space="preserve">
          <source>By default, the command pops a single element from the beginning of the list. When provided with the optional &lt;code&gt;count&lt;/code&gt; argument, the reply will consist of up to &lt;code&gt;count&lt;/code&gt; elements, depending on the list's length.</source>
          <target state="translated">기본적으로 명령은 목록의 시작 부분에서 단일 요소를 팝합니다. 선택적 &lt;code&gt;count&lt;/code&gt; 인수가 제공되면 응답은 목록의 길이에 따라 최대 &lt;code&gt;count&lt;/code&gt; 요소 로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="6fecef221e5ae822414f939e112035853e985bf7" translate="yes" xml:space="preserve">
          <source>By default, the command pops a single element from the end of the list. When provided with the optional &lt;code&gt;count&lt;/code&gt; argument, the reply will consist of up to &lt;code&gt;count&lt;/code&gt; elements, depending on the list's length.</source>
          <target state="translated">기본적으로 명령은 목록 끝에서 단일 요소를 팝합니다. 선택적 &lt;code&gt;count&lt;/code&gt; 인수가 제공되면 응답은 목록의 길이에 따라 최대 &lt;code&gt;count&lt;/code&gt; 요소 로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="3b7bd3b6d4bf2d2679ef9988f3c531b70e60e21c" translate="yes" xml:space="preserve">
          <source>By default, the command pops a single member from the set. When provided with the optional &lt;code&gt;count&lt;/code&gt; argument, the reply will consist of up to &lt;code&gt;count&lt;/code&gt; members, depending on the set's cardinality.</source>
          <target state="translated">기본적으로 명령은 세트에서 단일 멤버를 팝합니다. 선택적 &lt;code&gt;count&lt;/code&gt; 인수가 제공되면 응답은 집합의 카디널리티에 따라 최대 &lt;code&gt;count&lt;/code&gt; 구성원 으로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="877bdcad724a6306efbd3a664f11efc0ec0b6fe6" translate="yes" xml:space="preserve">
          <source>By default, the command returns unsorted items. Two different sorting methods can be invoked using one of the following two options:</source>
          <target state="translated">기본적으로이 명령은 정렬되지 않은 항목을 반환합니다. 다음 두 옵션 중 하나를 사용하여 두 가지 다른 정렬 방법을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5529ebf0aa9355a448e5873d36ba97d16befd8bf" translate="yes" xml:space="preserve">
          <source>By default, the interval specified by &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt; is closed (inclusive). It is possible to specify an open interval (exclusive) by prefixing the score with the character &lt;code&gt;(&lt;/code&gt;. For example:</source>
          <target state="translated">기본적으로 &lt;code&gt;min&lt;/code&gt; 및 &lt;code&gt;max&lt;/code&gt; 로 지정된 간격 은 닫힙니다 (포함). 점수 앞에 문자 &lt;code&gt;(&lt;/code&gt; )를 붙여서 열린 간격 (제외)을 지정할 수 있습니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="b8a1843f4f52d23022ae70457e87a2bbc0c8ed29" translate="yes" xml:space="preserve">
          <source>By default, the resulting score of an element is the sum of its scores in the sorted sets where it exists.</source>
          <target state="translated">기본적으로 요소의 결과 점수는 해당 요소가있는 정렬 된 세트의 점수 합계입니다.</target>
        </trans-unit>
        <trans-unit id="4665873e5c58037455475bf4706b458811098286" translate="yes" xml:space="preserve">
          <source>By default, the resulting score of an element is the sum of its scores in the sorted sets where it exists. Because intersection requires an element to be a member of every given sorted set, this results in the score of every element in the resulting sorted set to be equal to the number of input sorted sets.</source>
          <target state="translated">기본적으로 요소의 결과 점수는 해당 요소가있는 정렬 된 세트의 점수 합계입니다. 교차는 요소가 주어진 모든 정렬 된 세트의 구성원이어야하므로 결과 정렬 된 세트의 모든 요소의 점수는 입력 정렬 된 세트의 수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="9bd72014f313a48aa376a2f9743fd29947ddbfa2" translate="yes" xml:space="preserve">
          <source>By getting the string representation of a bitmap, the client can then parse the response's bytes by extracting the bit values using native bit operations in its native programming language. Symmetrically, it is also possible to set an entire bitmap by performing the bits-to-bytes encoding in the client and calling &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; with the resultant string.</source>
          <target state="translated">비트 맵의 ​​문자열 표현을 가져옴으로써 클라이언트는 기본 프로그래밍 언어에서 기본 비트 연산을 사용하여 비트 값을 추출하여 응답의 바이트를 구문 분석 할 수 있습니다. 대칭 적으로 클라이언트에서 비트 단위 인코딩을 수행 하고 결과 문자열로 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 을 호출하여 전체 비트 맵을 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="855731f4a53411098556da94791141678c87de9e" translate="yes" xml:space="preserve">
          <source>C1 and C2 read &lt;code&gt;lock.foo&lt;/code&gt; to check the timestamp, because they both received &lt;code&gt;0&lt;/code&gt; after executing &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, as the lock is still held by C3 that crashed after holding the lock.</source>
          <target state="translated">C1 및 C2는 &lt;code&gt;lock.foo&lt;/code&gt; 를 읽고 시간 소인을 확인합니다. SETNX 를 실행 한 후 잠금을 유지 한 후에 C3에 의해 잠금이 여전히 유지되어 있기 때문에 둘 다 &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; 를 실행 한 후 &lt;code&gt;0&lt;/code&gt; 을 수신했기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="2d7ad86157ffa8a81154afc21adf4e9506f4075d" translate="yes" xml:space="preserve">
          <source>C1 sends &lt;code&gt;DEL lock.foo&lt;/code&gt;</source>
          <target state="translated">C1은 &lt;code&gt;DEL lock.foo&lt;/code&gt; 보냅니다 .foo</target>
        </trans-unit>
        <trans-unit id="59e76a6cffa5164edb0398cd905358d159247029" translate="yes" xml:space="preserve">
          <source>C1 sends &lt;code&gt;SETNX lock.foo&lt;/code&gt; and it succeeds</source>
          <target state="translated">C1이 &lt;code&gt;SETNX lock.foo&lt;/code&gt; 를 보내면 성공</target>
        </trans-unit>
        <trans-unit id="4f7c62ca261230ba7bd6b9233369caaf27e7f01d" translate="yes" xml:space="preserve">
          <source>C2 sends &lt;code&gt;DEL lock.foo&lt;/code&gt;</source>
          <target state="translated">C2는 &lt;code&gt;DEL lock.foo&lt;/code&gt; 를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="193179deba47ad9e120a60484e3cc95253ac5a6a" translate="yes" xml:space="preserve">
          <source>C2 sends &lt;code&gt;SETNX lock.foo&lt;/code&gt; and it succeeds</source>
          <target state="translated">C2가 &lt;code&gt;SETNX lock.foo&lt;/code&gt; 를 보내면 성공</target>
        </trans-unit>
        <trans-unit id="151ee6de467b9561ff1e9f5ec7724e1aafaaa74e" translate="yes" xml:space="preserve">
          <source>C4 sends &lt;code&gt;GET lock.foo&lt;/code&gt; to check if the lock expired. If it is not, it will sleep for some time and retry from the start.</source>
          <target state="translated">C4는 잠금이 만료되었는지 확인하기 위해 &lt;code&gt;GET lock.foo&lt;/code&gt; 를 보냅니다 . 그렇지 않으면 일정 시간 동안 잠을 자고 처음부터 다시 시도합니다.</target>
        </trans-unit>
        <trans-unit id="80d7499d35c9d242f43ac8ad8f3d435904ce4b07" translate="yes" xml:space="preserve">
          <source>C4 sends &lt;code&gt;SETNX lock.foo&lt;/code&gt; in order to acquire the lock</source>
          <target state="translated">C4는 잠금을 획득하기 위해 &lt;code&gt;SETNX lock.foo&lt;/code&gt; 를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="810aa98e90b76fd25ebaacd1fecaebbe5cca1fd8" translate="yes" xml:space="preserve">
          <source>CJSON</source>
          <target state="translated">CJSON</target>
        </trans-unit>
        <trans-unit id="289fd6dd86c78fc18484670bd5337ffc1457b23f" translate="yes" xml:space="preserve">
          <source>CLIENT</source>
          <target state="translated">CLIENT</target>
        </trans-unit>
        <trans-unit id="63a953234a4a4b23595b8f5c3d66ad8e228bb360" translate="yes" xml:space="preserve">
          <source>CLIENT CACHING  YES|NO   Instruct the server about tracking or not keys in the next request</source>
          <target state="translated">CLIENT CACHING YES | NO 다음 요청에서 키 추적 여부를 서버에 지시합니다.</target>
        </trans-unit>
        <trans-unit id="9a086feff67c072f67169a1a10544440c06a27bb" translate="yes" xml:space="preserve">
          <source>CLIENT GETNAME   Get the current connection name</source>
          <target state="translated">클라이언트 GETNAME 현재 연결 이름을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="4c39ac03d0deadf47c0778e94147170cfe5cc290" translate="yes" xml:space="preserve">
          <source>CLIENT GETREDIR   Get tracking notifications redirection client ID if any</source>
          <target state="translated">CLIENT GETREDIR 추적 알림 리디렉션 클라이언트 ID (있는 경우) 가져 오기</target>
        </trans-unit>
        <trans-unit id="1f043bd4293df18cf326994e345f63d6a607a715" translate="yes" xml:space="preserve">
          <source>CLIENT ID   Returns the client ID for the current connection</source>
          <target state="translated">CLIENT ID 현재 연결에 대한 클라이언트 ID를 반환합니다</target>
        </trans-unit>
        <trans-unit id="2cc6c98e277f7b4b6dd7682b2772443f1b2745eb" translate="yes" xml:space="preserve">
          <source>CLIENT INFO   Returns information about the current client connection.</source>
          <target state="translated">CLIENT INFO 현재 클라이언트 연결에 대한 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a606744e377765ead3bebe7af7be75bec984bac6" translate="yes" xml:space="preserve">
          <source>CLIENT KILL  [ip:port] [ID client-id] [TYPE normal|master|slave|pubsub] [ADDR ip:port] [SKIPME yes/no]   Kill the connection of a client</source>
          <target state="translated">클라이언트 킬 [ip : port] [ID client-id] [TYPE normal | master | slave | pubsub] [ADDR ip : port] [SKIPME yes / no] 클라이언트 연결 끊기</target>
        </trans-unit>
        <trans-unit id="0962c4ff7046d5e0349aa07792ed564b6ac58b3e" translate="yes" xml:space="preserve">
          <source>CLIENT KILL  [ip:port] [ID client-id] [TYPE normal|master|slave|pubsub] [USER username] [ADDR ip:port] [SKIPME yes/no]   Kill the connection of a client</source>
          <target state="translated">CLIENT KILL [ip : port] [ID client-id] [TYPE normal | master | slave | pubsub] [USER username] [ADDR ip : port] [SKIPME yes / no] 클라이언트 연결 종료</target>
        </trans-unit>
        <trans-unit id="40f78df8d4251b437ca6d0591e3d79df9db9a668" translate="yes" xml:space="preserve">
          <source>CLIENT KILL and Redis Sentinel</source>
          <target state="translated">클라이언트 킬과 Redis Sentinel</target>
        </trans-unit>
        <trans-unit id="5abdfb863c66ad1708626a5caaaa3f3ae356f31e" translate="yes" xml:space="preserve">
          <source>CLIENT LIST  [TYPE normal|master|replica|pubsub]   Get the list of client connections</source>
          <target state="translated">클라이언트 목록 [TYPE normal | master | replica | pubsub] 클라이언트 연결 목록 가져 오기</target>
        </trans-unit>
        <trans-unit id="0f9e74e993d542e852824191d195f334f18cdbad" translate="yes" xml:space="preserve">
          <source>CLIENT LIST  [TYPE normal|master|replica|pubsub] [ID client-id [client-id ...]]   Get the list of client connections</source>
          <target state="translated">CLIENT LIST [TYPE normal | master | replica | pubsub] [ID client-id [client-id ...]] 클라이언트 연결 목록 가져 오기</target>
        </trans-unit>
        <trans-unit id="cdde82d80a6c631c41a96bc80027350e01ff9d66" translate="yes" xml:space="preserve">
          <source>CLIENT PAUSE  timeout   Stop processing commands from clients for some time</source>
          <target state="translated">CLIENT PAUSE timeout 클라이언트에서 명령 처리를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="cdc920d32af4c13e5383224eaafad4a5e97a22e0" translate="yes" xml:space="preserve">
          <source>CLIENT REPLY  ON|OFF|SKIP   Instruct the server whether to reply to commands</source>
          <target state="translated">CLIP REPLY ON | OFF | SKIP 명령에 응답할지 서버에 지시합니다</target>
        </trans-unit>
        <trans-unit id="5de18cdee05387ac2edf2c59d640ef325da93c25" translate="yes" xml:space="preserve">
          <source>CLIENT SETNAME  connection-name   Set the current connection name</source>
          <target state="translated">CLIENT SETNAME connection-name 현재 연결 이름을 설정하십시오</target>
        </trans-unit>
        <trans-unit id="95279f3b4d86b3dc0268ddf4db1feb274847cc8c" translate="yes" xml:space="preserve">
          <source>CLIENT TRACKING  ON|OFF [REDIRECT client-id] [PREFIX prefix [PREFIX prefix ...]] [BCAST] [OPTIN] [OPTOUT] [NOLOOP]   Enable or disable server assisted client side caching support</source>
          <target state="translated">클라이언트 추적 ON | OFF [리디렉션 클라이언트 ID] [PREFIX 접두사 [PREFIX 접두사 ...]] [BCAST] [OPTIN] [OPTOUT] [NOLOOP] 서버 지원 클라이언트 측 캐싱 지원 활성화 또는 비활성화</target>
        </trans-unit>
        <trans-unit id="bd550a8d7b9512156ea1471fdd3b700157d0ab6e" translate="yes" xml:space="preserve">
          <source>CLIENT TRACKINGINFO   Return information about server assisted client side caching for the current connection</source>
          <target state="translated">CLIENT TRACKINGINFO 현재 연결에 대한 서버 지원 클라이언트 측 캐싱에 대한 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="326b6f4d4510070631ac4ab9eaf85a825c42c2a7" translate="yes" xml:space="preserve">
          <source>CLIENT UNBLOCK  client-id [TIMEOUT|ERROR]   Unblock a client blocked in a blocking command from a different connection</source>
          <target state="translated">클라이언트 클라이언트 차단 해제 클라이언트 ID [TIMEOUT | ERROR] 다른 연결에서 차단 명령으로 차단 된 클라이언트 차단 해제</target>
        </trans-unit>
        <trans-unit id="e3b9b52696ca51803a72a1787b8689b560877e3b" translate="yes" xml:space="preserve">
          <source>CLUSTER</source>
          <target state="translated">CLUSTER</target>
        </trans-unit>
        <trans-unit id="89c0d390cdc52475692a036944dfe3e1af10aa52" translate="yes" xml:space="preserve">
          <source>CLUSTER ADDSLOTS  slot [slot ...]   Assign new hash slots to receiving node</source>
          <target state="translated">CLUSTER ADDSLOTS slot [slot ...] 수신 노드에 새 해시 슬롯 할당</target>
        </trans-unit>
        <trans-unit id="00fb8c41d977c173c87d67428daf985f10049f97" translate="yes" xml:space="preserve">
          <source>CLUSTER BUMPEPOCH   Advance the cluster config epoch</source>
          <target state="translated">CLUSTER BUMPEPOCH 클러스터 구성 epoch 진행</target>
        </trans-unit>
        <trans-unit id="fc6a3f907637996a1389e46617de4c73581acb5f" translate="yes" xml:space="preserve">
          <source>CLUSTER COUNT-FAILURE-REPORTS  node-id   Return the number of failure reports active for a given node</source>
          <target state="translated">CLUSTER COUNT-FAILURE-REPORTS node-id 주어진 노드에 대해 활성화 된 실패 보고서 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8de0ad0623c7725bc7b50d19dfafe919652d9ddd" translate="yes" xml:space="preserve">
          <source>CLUSTER COUNTKEYSINSLOT  slot   Return the number of local keys in the specified hash slot</source>
          <target state="translated">CLUSTER COUNTKEYSINSLOT slot 지정된 해시 슬롯의 로컬 키 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a291825c5518befaa628dbca584ac74adfdd3dc0" translate="yes" xml:space="preserve">
          <source>CLUSTER DELSLOTS  slot [slot ...]   Set hash slots as unbound in receiving node</source>
          <target state="translated">CLUSTER DELSLOTS slot [slot ...] 수신 노드에서 해시 슬롯을 언 바운드로 설정</target>
        </trans-unit>
        <trans-unit id="9b2690b6fa91e96bd2f73d5972dcb19de160e151" translate="yes" xml:space="preserve">
          <source>CLUSTER FAILOVER  [FORCE|TAKEOVER]   Forces a replica to perform a manual failover of its master.</source>
          <target state="translated">CLUSTER FAILOVER [FORCE | TAKEOVER] 복제본이 마스터의 수동 장애 조치를 수행하도록합니다.</target>
        </trans-unit>
        <trans-unit id="94cefd9c3cfc8c0aca11125b97d7b0fd362d0d4a" translate="yes" xml:space="preserve">
          <source>CLUSTER FLUSHSLOTS   Delete a node's own slots information</source>
          <target state="translated">CLUSTER FLUSHSLOTS 노드의 자체 슬롯 정보를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="e739c9ee11fd419a688da991d447a266021c6ef0" translate="yes" xml:space="preserve">
          <source>CLUSTER FORGET  node-id   Remove a node from the nodes table</source>
          <target state="translated">CLUSTER FORGET node-id 노드 테이블에서 노드를 제거합니다</target>
        </trans-unit>
        <trans-unit id="63b393dc8cc3734128967f68eb934005c0c5a24f" translate="yes" xml:space="preserve">
          <source>CLUSTER GETKEYSINSLOT  slot count   Return local key names in the specified hash slot</source>
          <target state="translated">CLUSTER GETKEYSINSLOT 슬롯 수 지정된 해시 슬롯에서 로컬 키 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="96ff44fb1ff41b2047e38a9dd4b9b91ab3a48e50" translate="yes" xml:space="preserve">
          <source>CLUSTER INFO   Provides info about Redis Cluster node state</source>
          <target state="translated">CLUSTER INFO Redis 클러스터 노드 상태에 대한 정보를 제공합니다</target>
        </trans-unit>
        <trans-unit id="bceb7d0f89d15cad163cf00743841fee0d54ad57" translate="yes" xml:space="preserve">
          <source>CLUSTER KEYSLOT  key   Returns the hash slot of the specified key</source>
          <target state="translated">CLUSTER KEYSLOT 키 지정된 키의 해시 슬롯을 반환합니다</target>
        </trans-unit>
        <trans-unit id="db6dfe9195f872c1e24e77eca06229e51f545369" translate="yes" xml:space="preserve">
          <source>CLUSTER MEET  ip port   Force a node cluster to handshake with another node</source>
          <target state="translated">CLUSTER MEET ip port 노드 클러스터가 다른 노드와 핸드 셰이크하도록 강제합니다.</target>
        </trans-unit>
        <trans-unit id="4c0ca20cada3909d25d2d4e2035e56d2e9daba1b" translate="yes" xml:space="preserve">
          <source>CLUSTER MYID   Return the node id</source>
          <target state="translated">CLUSTER MYID 노드 ID 반환</target>
        </trans-unit>
        <trans-unit id="45bb4b8fb75be9f6506f8df1b5feecc8fcb42818" translate="yes" xml:space="preserve">
          <source>CLUSTER NODES   Get Cluster config for the node</source>
          <target state="translated">클러스터 노드 노드에 대한 클러스터 구성 가져 오기</target>
        </trans-unit>
        <trans-unit id="cb1b81c97abbdb844bd68109bd5c641a604ec477" translate="yes" xml:space="preserve">
          <source>CLUSTER REPLICAS  node-id   List replica nodes of the specified master node</source>
          <target state="translated">CLUSTER REPLICAS node-id 지정된 마스터 노드의 복제본 노드를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="0c1d4ab714df1ed96b53ecea55f9b15118926ddd" translate="yes" xml:space="preserve">
          <source>CLUSTER REPLICATE  node-id   Reconfigure a node as a replica of the specified master node</source>
          <target state="translated">CLUSTER REPLICATE node-id 노드를 지정된 마스터 노드의 복제본으로 재구성</target>
        </trans-unit>
        <trans-unit id="fdd669bf0a4695d61100d82b95672d6f0265fa98" translate="yes" xml:space="preserve">
          <source>CLUSTER RESET  [HARD|SOFT]   Reset a Redis Cluster node</source>
          <target state="translated">클러스터 재설정 [HARD | SOFT] Redis 클러스터 노드 재설정</target>
        </trans-unit>
        <trans-unit id="4452e5582d47e8dfe0990f92ac43fa0dcf4415d8" translate="yes" xml:space="preserve">
          <source>CLUSTER SAVECONFIG   Forces the node to save cluster state on disk</source>
          <target state="translated">CLUSTER SAVECONFIG 노드가 디스크에 클러스터 상태를 저장하게합니다.</target>
        </trans-unit>
        <trans-unit id="0352d198b3e3c3480eec41371b3ead5bc1188b13" translate="yes" xml:space="preserve">
          <source>CLUSTER SET-CONFIG-EPOCH  config-epoch   Set the configuration epoch in a new node</source>
          <target state="translated">CLUSTER SET-CONFIG-EPOCH config-epoch 새 노드에서 구성 에포크 설정</target>
        </trans-unit>
        <trans-unit id="717b30894068edcc566f30c183079158fcd2ebb3" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT  slot IMPORTING|MIGRATING|STABLE|NODE [node-id]   Bind a hash slot to a specific node</source>
          <target state="translated">CLUSTER SETSLOT 슬롯 가져 오기 | 마이 그레이팅 | 안정성 | 노드 [node-id] 특정 노드에 해시 슬롯 바인딩</target>
        </trans-unit>
        <trans-unit id="6998d43f245cd331b3038d9db49ce51e5fbe657b" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; IMPORTING &lt;code&gt;&amp;lt;source-node-id&amp;gt;&lt;/code&gt;</source>
          <target state="translated">클러스터 SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 가져 오기 &lt;code&gt;&amp;lt;source-node-id&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="df0cda76712dac386672dd77ffb08df9386d4ded" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; MIGRATING &lt;code&gt;&amp;lt;destination-node-id&amp;gt;&lt;/code&gt;</source>
          <target state="translated">클러스터 SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 마이그레이션 &lt;code&gt;&amp;lt;destination-node-id&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e87c55a08cdeb007d9466cda6f41bd3aa8b0b08f" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; NODE &lt;code&gt;&amp;lt;node-id&amp;gt;&lt;/code&gt;</source>
          <target state="translated">클러스터 SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 노드 &lt;code&gt;&amp;lt;node-id&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8050d05e7c830b724efadb1fb19908cbba0c3b12" translate="yes" xml:space="preserve">
          <source>CLUSTER SETSLOT &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; STABLE</source>
          <target state="translated">클러스터 셋 &lt;code&gt;&amp;lt;slot&amp;gt;&lt;/code&gt; 안정</target>
        </trans-unit>
        <trans-unit id="87d7c95e3334e2c65e594f6606b11d6fa033b8e3" translate="yes" xml:space="preserve">
          <source>CLUSTER SLAVES  node-id   List replica nodes of the specified master node</source>
          <target state="translated">CLUSTER SLAVES node-id 지정된 마스터 노드의 복제본 노드를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="0b83235580afb6dcdbb5aaae9069030836332846" translate="yes" xml:space="preserve">
          <source>CLUSTER SLOTS   Get array of Cluster slot to node mappings</source>
          <target state="translated">클러스터 슬롯 클러스터 슬롯의 노드 매핑을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2e4854d8dd31ab3a1bd0bbce1a9b8c73da88c413" translate="yes" xml:space="preserve">
          <source>COMMAND</source>
          <target state="translated">COMMAND</target>
        </trans-unit>
        <trans-unit id="5d475d3ae2a090a5dd4fb9bcb4834f2b0f5e8e36" translate="yes" xml:space="preserve">
          <source>COMMAND   Get array of Redis command details</source>
          <target state="translated">명령 Redis 명령 세부 사항 배열 가져 오기</target>
        </trans-unit>
        <trans-unit id="243f2ac950baaf718523fe42c2f35baa4d002daa" translate="yes" xml:space="preserve">
          <source>COMMAND COUNT   Get total number of Redis commands</source>
          <target state="translated">명령 수 총 Redis 명령 수 얻기</target>
        </trans-unit>
        <trans-unit id="b5c43f716c4692946b372734d13302625935ddef" translate="yes" xml:space="preserve">
          <source>COMMAND GETKEYS   Extract keys given a full Redis command</source>
          <target state="translated">명령 키 전체 Redis 명령이 제공된 키 추출</target>
        </trans-unit>
        <trans-unit id="e4f0ee016bdc14d304548515037906095d7beb51" translate="yes" xml:space="preserve">
          <source>COMMAND INFO  command-name [command-name ...]   Get array of specific Redis command details</source>
          <target state="translated">명령 정보 command-name [command-name ...] 특정 Redis 명령 세부 정보의 배열을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="2fb60054b43a25d7a958d3d19bdb1aa7809577a8" translate="yes" xml:space="preserve">
          <source>CONFIG</source>
          <target state="translated">CONFIG</target>
        </trans-unit>
        <trans-unit id="d3f495884e312ef94089cef1025f98afac649a7f" translate="yes" xml:space="preserve">
          <source>CONFIG GET  parameter   Get the value of a configuration parameter</source>
          <target state="translated">CONFIG GET 매개 변수 구성 매개 변수의 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d6c004f361be600273602c08f69569c9b929d35b" translate="yes" xml:space="preserve">
          <source>CONFIG RESETSTAT   Reset the stats returned by INFO</source>
          <target state="translated">CONFIG RESETSTAT INFO에 의해 반환 된 통계를 재설정합니다</target>
        </trans-unit>
        <trans-unit id="07fd8b85f66f97280cb2ad55982da60cacbe7682" translate="yes" xml:space="preserve">
          <source>CONFIG REWRITE   Rewrite the configuration file with the in memory configuration</source>
          <target state="translated">CONFIG REWRITE 메모리 구성으로 구성 파일을 다시 씁니다.</target>
        </trans-unit>
        <trans-unit id="d27538b14c1ebc5ce34011e7bb5ef99fff52c53d" translate="yes" xml:space="preserve">
          <source>CONFIG REWRITE is also able to rewrite the configuration file from scratch if the original one no longer exists for some reason. However if the server was started without a configuration file at all, the CONFIG REWRITE will just return an error.</source>
          <target state="translated">CONFIG REWRITE는 어떤 이유로 인해 원래 파일이 더 이상 존재하지 않으면 구성 파일을 처음부터 다시 작성할 수 있습니다. 그러나 서버가 구성 파일없이 시작된 경우 CONFIG REWRITE는 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bcdc354e91b58a18cc7f424a767e01c256e6b42b" translate="yes" xml:space="preserve">
          <source>CONFIG SET  parameter value   Set a configuration parameter to the given value</source>
          <target state="translated">CONFIG SET 매개 변수 값 구성 매개 변수를 주어진 값으로 설정</target>
        </trans-unit>
        <trans-unit id="aecf0292da85cb2048d8b648567127d024d4074f" translate="yes" xml:space="preserve">
          <source>COPY</source>
          <target state="translated">COPY</target>
        </trans-unit>
        <trans-unit id="b3729b7bb933c36d809f0e8ba9d3228341d27148" translate="yes" xml:space="preserve">
          <source>COPY  source destination [DB destination-db] [REPLACE]   Copy a key</source>
          <target state="translated">원본 대상 복사 [DB 대상 -db] [REPLACE] 키 복사</target>
        </trans-unit>
        <trans-unit id="5ba6c24ce4497d078be48b670ad16cc43d57f929" translate="yes" xml:space="preserve">
          <source>Calling &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; with a broken, negative, out of range, or otherwise invalid cursor, will result into undefined behavior but never into a crash. What will be undefined is that the guarantees about the returned elements can no longer be ensured by the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; implementation.</source>
          <target state="translated">파손, 음수, 범위를 벗어나거나 유효하지 않은 커서로 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 을 호출 하면 정의되지 않은 동작이 발생하지만 결코 충돌하지는 않습니다. 정의되지 않은 것은 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 구현을 통해 반환 된 요소에 대한 보장을 더 이상 보장 할 수 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5f46be6632e20880fa3190f308734a7c2debc935" translate="yes" xml:space="preserve">
          <source>Calling SCAN with a corrupted cursor</source>
          <target state="translated">손상된 커서로 SCAN 호출</target>
        </trans-unit>
        <trans-unit id="1e0b7fe9d077c2aa9a5144f650dffdcf03fa241c" translate="yes" xml:space="preserve">
          <source>Capped streams</source>
          <target state="translated">캡핑 된 스트림</target>
        </trans-unit>
        <trans-unit id="677509e3c92011eb7431eb950f99423de593897c" translate="yes" xml:space="preserve">
          <source>Care should be taken when executing &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; in the context of a pipelined request, since even in a pipeline the order of execution of commands must be guaranteed. If &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; will return a &lt;code&gt;NOSCRIPT&lt;/code&gt; error the command can not be reissued later otherwise the order of execution is violated.</source>
          <target state="translated">파이프 라인 된 요청 컨텍스트에서 &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; 를 실행할 때는주의를 기울여야합니다 . 파이프 라인에서도 명령 실행 순서가 보장되어야하기 때문입니다. 경우 &lt;a href=&quot;evalsha&quot;&gt;EVALSHA는&lt;/a&gt; 반환하며 &lt;code&gt;NOSCRIPT&lt;/code&gt; 의 명령이 나중에 다른 실행 순서가 위반 재발행 할 수없는 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="3c95b0aba9bde834d03663b5e6a82abbc6926a9f" translate="yes" xml:space="preserve">
          <source>Checking for all the available categories is as simple as:</source>
          <target state="translated">사용 가능한 모든 범주를 확인하는 것은 다음과 같이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="8eaf1e254fa69f8ab1d24e1e39a78203c7080474" translate="yes" xml:space="preserve">
          <source>Client IP address and port (4.0 only).</source>
          <target state="translated">클라이언트 IP 주소 및 포트 (4.0 만 해당).</target>
        </trans-unit>
        <trans-unit id="5cf75075a191bc11d161c66570997946e05f966f" translate="yes" xml:space="preserve">
          <source>Client libraries may use Redis in order to test their own hashing algorithm, generating random keys and hashing them with both their local implementation and using Redis &lt;a href=&quot;cluster-keyslot&quot;&gt;CLUSTER KEYSLOT&lt;/a&gt; command, then checking if the result is the same.</source>
          <target state="translated">클라이언트 라이브러리는 자체 해싱 알고리즘을 테스트하고 임의의 키를 생성하고 로컬 구현과 Redis &lt;a href=&quot;cluster-keyslot&quot;&gt;CLUSTER KEYSLOT&lt;/a&gt; 명령을 사용하여 해싱 한 다음 결과가 동일한 지 확인 하기 위해 Redis를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5993bbb849b531146b7a95269c1882c6ff8a9ed3" translate="yes" xml:space="preserve">
          <source>Client name if set via the &lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; command (4.0 only).</source>
          <target state="translated">&lt;a href=&quot;client-setname&quot;&gt;CLIENT SETNAME&lt;/a&gt; 명령을 통해 설정된 클라이언트 이름 (4.0 만 해당).</target>
        </trans-unit>
        <trans-unit id="d75dc68bbdd56c9cbd58d4bbdabda84bcca2c47f" translate="yes" xml:space="preserve">
          <source>Cluster</source>
          <target state="translated">Cluster</target>
        </trans-unit>
        <trans-unit id="4a4e6b60b2ae77bbe874af6a70cdbaba6049e713" translate="yes" xml:space="preserve">
          <source>Cluster clients must be aware of key positions in commands so commands can go to matching instances, but Redis commands vary between accepting one key, multiple keys, or even multiple keys separated by other data.</source>
          <target state="translated">클러스터 클라이언트는 명령에서 키 위치를 알고 있어야 명령이 일치하는 인스턴스로 이동할 수 있지만 Redis 명령은 하나의 키 수락, 여러 키 또는 다른 데이터로 구분 된 여러 키 사이에서 다양합니다.</target>
        </trans-unit>
        <trans-unit id="13fb8a1716343d8d81faf3b82f500e80a846e807" translate="yes" xml:space="preserve">
          <source>Cluster note: in a Redis Cluster clients can subscribe to every node, and can also publish to every other node. The cluster will make sure that published messages are forwarded as needed. That said, &lt;a href=&quot;pubsub&quot;&gt;PUBSUB&lt;/a&gt;'s replies in a cluster only report information from the node's Pub/Sub context, rather than the entire cluster.</source>
          <target state="translated">클러스터 참고 : Redis 클러스터에서 클라이언트는 모든 노드를 구독 할 수 있으며 다른 모든 노드에도 게시 할 수 있습니다. 클러스터는 게시 된 메시지가 필요에 따라 전달되는지 확인합니다. 즉, 클러스터의 &lt;a href=&quot;pubsub&quot;&gt;PUBSUB&lt;/a&gt; 응답은 전체 클러스터가 아닌 노드의 Pub / Sub 컨텍스트의 정보 만보 고 합니다.</target>
        </trans-unit>
        <trans-unit id="e3c356fac15c94ebf5b7447ee6cfaeb09fa342b3" translate="yes" xml:space="preserve">
          <source>Command Arity</source>
          <target state="translated">사령부</target>
        </trans-unit>
        <trans-unit id="b25b9ea512e65182e9de25869fda9886e798f471" translate="yes" xml:space="preserve">
          <source>Command Name</source>
          <target state="translated">명령 이름</target>
        </trans-unit>
        <trans-unit id="72da5b475c49e9d5cba38602d80b0de205cc6bb7" translate="yes" xml:space="preserve">
          <source>Command arity &lt;em&gt;includes&lt;/em&gt; counting the command name itself.</source>
          <target state="translated">명령 arity &lt;em&gt;에는&lt;/em&gt; 명령 이름 자체의 수를 &lt;em&gt;포함&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="7b7be4b904754c3884cb0bf72bfeb125fc2e6d02" translate="yes" xml:space="preserve">
          <source>Command arity follows a simple pattern:</source>
          <target state="translated">명령 arity는 간단한 패턴을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="da09292eaa6e23b8b1b1824949fffe53ca537116" translate="yes" xml:space="preserve">
          <source>Command flags is &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;Array reply&lt;/a&gt; containing one or more status replies:</source>
          <target state="translated">명령 플래그는 하나 이상의 상태 응답을 포함하는 &lt;a href=&quot;https://redis.io/topics/protocol#array-reply&quot;&gt;배열&lt;/a&gt; 응답입니다.</target>
        </trans-unit>
        <trans-unit id="d8fdc321243166f52a9f1732c47f181f168fb6cd" translate="yes" xml:space="preserve">
          <source>Command name is the command returned as a lowercase string.</source>
          <target state="translated">명령 이름은 소문자 문자열로 반환되는 명령입니다.</target>
        </trans-unit>
        <trans-unit id="c03350e2365b375b5bb4ce53303074533ba05e9e" translate="yes" xml:space="preserve">
          <source>Command options</source>
          <target state="translated">명령 옵션</target>
        </trans-unit>
        <trans-unit id="a4618f4b2f49e68da5c5eab1cb65f4e2cbae4e8c" translate="yes" xml:space="preserve">
          <source>Commands about keys already migrated are correctly processed in the context of the node which is the target of the migration, the new hash slot owner, in order to guarantee consistency.</source>
          <target state="translated">일관성을 보장하기 위해 이미 마이그레이션 된 키에 대한 명령은 마이그레이션의 대상인 새 해시 슬롯 소유자 인 노드의 컨텍스트에서 올바르게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b7c78328ebde5dad6a0b828ac630676fb4437227" translate="yes" xml:space="preserve">
          <source>Commands about this hash slot are refused and a &lt;code&gt;MOVED&lt;/code&gt; redirection is generated as usually, but in the case the command follows an &lt;code&gt;ASKING&lt;/code&gt; command, in this case the command is executed.</source>
          <target state="translated">이 해시 슬롯에 대한 명령이 거부되고 일반적으로 &lt;code&gt;MOVED&lt;/code&gt; 리디렉션이 생성되지만 명령이 &lt;code&gt;ASKING&lt;/code&gt; 명령을 따르는 경우이 명령이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="aa013f0386471baba0b09b24b999134de43d82e4" translate="yes" xml:space="preserve">
          <source>Commands denied because accessing keys not allowed in the current ACL rules.</source>
          <target state="translated">현재 ACL 규칙에서 허용되지 않는 키 액세스로 인해 명령이 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="3aef01612894a7eb8b7ac8feeb71f973dac67ca6" translate="yes" xml:space="preserve">
          <source>Commands denied because against the current ACL rules.</source>
          <target state="translated">현재 ACL 규칙을 위반하여 명령이 거부되었습니다.</target>
        </trans-unit>
        <trans-unit id="5080f3f78852fa61575aea2ee4cbd726a5e4c31e" translate="yes" xml:space="preserve">
          <source>Commands not logged by MONITOR</source>
          <target state="translated">MONITOR에 의해 로그되지 않은 명령</target>
        </trans-unit>
        <trans-unit id="b16b78407a41c93dd4cb4577acb6af8003abc8f6" translate="yes" xml:space="preserve">
          <source>Comments and the overall structure of the original redis.conf are preserved as much as possible.</source>
          <target state="translated">원래 redis.conf의 주석과 전체 구조는 최대한 보존됩니다.</target>
        </trans-unit>
        <trans-unit id="b2729f5c12d7e85d14c701273c4956c936eacdf5" translate="yes" xml:space="preserve">
          <source>Complete list of commands currently requiring key location parsing:</source>
          <target state="translated">현재 키 위치 구문 분석이 필요한 전체 명령 목록 :</target>
        </trans-unit>
        <trans-unit id="85cf1af73ea4830e4844b1efcacdc1968badce3f" translate="yes" xml:space="preserve">
          <source>Computes the difference between the first and all successive input sorted sets and stores the result in &lt;code&gt;destination&lt;/code&gt;. The total number of input keys is specified by &lt;code&gt;numkeys&lt;/code&gt;.</source>
          <target state="translated">첫 번째 및 모든 연속 입력 정렬 세트 간의 차이를 계산하고 그 결과를 &lt;code&gt;destination&lt;/code&gt; 에 저장 합니다 . 총 입력 키 수는 &lt;code&gt;numkeys&lt;/code&gt; 로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="fdc6213bb38f415f44656ea01a54b34f86489a7e" translate="yes" xml:space="preserve">
          <source>Computes the intersection of &lt;code&gt;numkeys&lt;/code&gt; sorted sets given by the specified keys, and stores the result in &lt;code&gt;destination&lt;/code&gt;. It is mandatory to provide the number of input keys (&lt;code&gt;numkeys&lt;/code&gt;) before passing the input keys and the other (optional) arguments.</source>
          <target state="translated">지정된 키에 의해 지정된 &lt;code&gt;numkeys&lt;/code&gt; 소트 세트 의 교집합을 계산하고 결과를 &lt;code&gt;destination&lt;/code&gt; 에 저장 합니다 . 입력 키와 다른 (선택적) 인수를 전달하기 전에 입력 키 ( &lt;code&gt;numkeys&lt;/code&gt; ) 를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9e0628d44bd94fff2a05cbf6e7329ac8c1542b4c" translate="yes" xml:space="preserve">
          <source>Computes the union of &lt;code&gt;numkeys&lt;/code&gt; sorted sets given by the specified keys, and stores the result in &lt;code&gt;destination&lt;/code&gt;. It is mandatory to provide the number of input keys (&lt;code&gt;numkeys&lt;/code&gt;) before passing the input keys and the other (optional) arguments.</source>
          <target state="translated">지정된 키에 의해 지정된 &lt;code&gt;numkeys&lt;/code&gt; 소트 세트 의 합집합을 계산하고 결과를 &lt;code&gt;destination&lt;/code&gt; 에 저장 합니다 . 입력 키와 다른 (선택적) 인수를 전달하기 전에 입력 키 ( &lt;code&gt;numkeys&lt;/code&gt; ) 를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1ac361d8a1971640b6145bcc2b23471d096806f1" translate="yes" xml:space="preserve">
          <source>Conditions where a SHUTDOWN fails</source>
          <target state="translated">SHUTDOWN이 실패하는 조건</target>
        </trans-unit>
        <trans-unit id="6512ee1541e9a6c52d5bf7cf465332e8df25ea3c" translate="yes" xml:space="preserve">
          <source>Connection</source>
          <target state="translated">Connection</target>
        </trans-unit>
        <trans-unit id="ce5886d8502f58f63f333861b5077fd91e99a286" translate="yes" xml:space="preserve">
          <source>Consistency and WAIT</source>
          <target state="translated">일관성과 WAIT</target>
        </trans-unit>
        <trans-unit id="5f2f16b6f5d5be95f9b3876b338cd86be1794d28" translate="yes" xml:space="preserve">
          <source>Consistency with range functions in various programming languages</source>
          <target state="translated">다양한 프로그래밍 언어에서 범위 기능과의 일관성</target>
        </trans-unit>
        <trans-unit id="b36b2f89bb23664788c6f3dd35338c638ba28a39" translate="yes" xml:space="preserve">
          <source>Consumer groups in 30 seconds</source>
          <target state="translated">30 초 내에 소비자 그룹</target>
        </trans-unit>
        <trans-unit id="bd58f13135bb4a18278653a136394b666aadff83" translate="yes" xml:space="preserve">
          <source>Consumers in a consumer group are auto-created every time a new consumer name is mentioned by some command. However sometimes it may be useful to remove old consumers since they are no longer used. This form returns the number of pending messages that the consumer had before it was deleted.</source>
          <target state="translated">소비자 그룹의 소비자는 일부 명령에 의해 새로운 소비자 이름이 언급 될 때마다 자동 생성됩니다. 그러나 오래된 소비자는 더 이상 사용되지 않으므로 제거하는 것이 유용 할 수 있습니다. 이 양식은 소비자가 삭제하기 전에 보유한 보류중인 메시지 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="93fee3ae260963d2ed888e760affe7075d85b781" translate="yes" xml:space="preserve">
          <source>Consumers in a consumer group are auto-created every time a new consumer name is mentioned by some command. They can also be explicitly created by using the following form:</source>
          <target state="translated">소비자 그룹의 소비자는 일부 명령에서 새 소비자 이름을 언급 할 때마다 자동으로 생성됩니다. 다음 형식을 사용하여 명시 적으로 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e04bdc35bafea7cf8c81eec69e12b57349af7a26" translate="yes" xml:space="preserve">
          <source>Conversion between Lua and Redis data types</source>
          <target state="translated">Lua와 Redis 데이터 유형 간 변환</target>
        </trans-unit>
        <trans-unit id="c74388ea06d766117ef931f93cf1e85e7c07bf21" translate="yes" xml:space="preserve">
          <source>Cost of running &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 운영 비용</target>
        </trans-unit>
        <trans-unit id="f43fec16935ea429ca6c4332ec8b80a51c3b6c5e" translate="yes" xml:space="preserve">
          <source>Cost of running MONITOR</source>
          <target state="translated">MONITOR 실행 비용</target>
        </trans-unit>
        <trans-unit id="e55d91fd97c87e8a34c622a7e4794ffcc51bd61d" translate="yes" xml:space="preserve">
          <source>Count argument extension</source>
          <target state="translated">카운트 인수 확장</target>
        </trans-unit>
        <trans-unit id="ed6fd4dc25ec3bdb3875f3c7192bde09b87a5801" translate="yes" xml:space="preserve">
          <source>Count the number of set bits (population counting) in a string.</source>
          <target state="translated">문자열에서 설정된 비트 수 (인구 수)를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="852a7b974be96bbc7c6036398114250aedbb0dca" translate="yes" xml:space="preserve">
          <source>Create a key associated with a value that is obtained by deserializing the provided serialized value (obtained via &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt;).</source>
          <target state="translated">제공된 직렬화 된 값을 직렬화 해제하여 얻은 값과 연관된 키를 작성하십시오 ( &lt;a href=&quot;dump&quot;&gt;DUMP&lt;/a&gt; 를 통해 획득 됨 ).</target>
        </trans-unit>
        <trans-unit id="1b9548967da77ce66eb092905a2179716e7c9d5d" translate="yes" xml:space="preserve">
          <source>Create a new consumer group associated with a stream.</source>
          <target state="translated">스트림과 연관된 새 이용자 그룹을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="5c0f29bb78fb88abe065ad6df1e2bc2b5123eed8" translate="yes" xml:space="preserve">
          <source>Create an ACL user with the specified rules or modify the rules of an existing user. This is the main interface in order to manipulate Redis ACL users interactively: if the username does not exist, the command creates the username without any privilege, then reads from left to right all the rules provided as successive arguments, setting the user ACL rules as specified.</source>
          <target state="translated">지정된 규칙을 사용하여 ACL 사용자를 생성하거나 기존 사용자의 규칙을 수정합니다. 이것은 Redis ACL 사용자를 대화식으로 조작하기위한 기본 인터페이스입니다. 사용자 이름이 존재하지 않으면 명령은 권한없이 사용자 이름을 생성 한 다음 연속 인수로 제공된 모든 규칙을 왼쪽에서 오른쪽으로 읽어 사용자 ACL 규칙을 다음과 같이 설정합니다. 지정.</target>
        </trans-unit>
        <trans-unit id="e8db62ea4abea13f4e50ca9316893c361ba8afd9" translate="yes" xml:space="preserve">
          <source>D ends re-added in the nodes table of A.</source>
          <target state="translated">D는 A의 노드 테이블에 다시 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d6ddfbac6ec07c32e2eb043cdffc4a0b7cf14714" translate="yes" xml:space="preserve">
          <source>D is now empty, but still listed in the nodes table of A, B and C.</source>
          <target state="translated">D는 이제 비어 있지만 여전히 A, B 및 C의 노드 테이블에 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="5231dbf5c92399c707fd162111bff340755773aa" translate="yes" xml:space="preserve">
          <source>DBSIZE</source>
          <target state="translated">DBSIZE</target>
        </trans-unit>
        <trans-unit id="cd67c53a53d3f0097d3c5a23561287ae0d9fb415" translate="yes" xml:space="preserve">
          <source>DBSIZE   Return the number of keys in the selected database</source>
          <target state="translated">DBSIZE 선택된 데이터베이스의 키 개수를 반환</target>
        </trans-unit>
        <trans-unit id="3f67e8f4eecf241b91f4cc8c976a487ade34d09d" translate="yes" xml:space="preserve">
          <source>DEBUG</source>
          <target state="translated">DEBUG</target>
        </trans-unit>
        <trans-unit id="64d12201fd531f0183ba8e8b6982cd30fb3885db" translate="yes" xml:space="preserve">
          <source>DEBUG OBJECT  key   Get debugging information about a key</source>
          <target state="translated">DEBUG OBJECT 키 키에 대한 디버깅 정보를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="a9e1eb844a55b579a65a4c4467b589dca48f8f1a" translate="yes" xml:space="preserve">
          <source>DEBUG SEGFAULT   Make the server crash</source>
          <target state="translated">버그 디버깅 서버 충돌을 일으킴</target>
        </trans-unit>
        <trans-unit id="d05cdacee2c153d405a26e62250727ce77ea0892" translate="yes" xml:space="preserve">
          <source>DECR</source>
          <target state="translated">DECR</target>
        </trans-unit>
        <trans-unit id="60ab4c3e9133d30eaf0ded676cadb4c538c56082" translate="yes" xml:space="preserve">
          <source>DECR  key   Decrement the integer value of a key by one</source>
          <target state="translated">DECR 키 키의 정수 값을 1 씩 감소시킵니다</target>
        </trans-unit>
        <trans-unit id="dd8d57c1b1a5522fa21a54d374912c18ca797f47" translate="yes" xml:space="preserve">
          <source>DECRBY</source>
          <target state="translated">DECRBY</target>
        </trans-unit>
        <trans-unit id="8c2782a79fd11dffe9a2c86222797cdb763ac992" translate="yes" xml:space="preserve">
          <source>DECRBY  key decrement   Decrement the integer value of a key by the given number</source>
          <target state="translated">DECRBY 키 감소 주어진 숫자만큼 키의 정수 값을 감소시킵니다</target>
        </trans-unit>
        <trans-unit id="4d017cb3dcf43d965d38a31c9ad97cefabc893fb" translate="yes" xml:space="preserve">
          <source>DEL</source>
          <target state="translated">DEL</target>
        </trans-unit>
        <trans-unit id="85fb2865a5ba87d91f28447addbf73c6630fa434" translate="yes" xml:space="preserve">
          <source>DEL  key [key ...]   Delete a key</source>
          <target state="translated">DEL 키 [키 ...] 키 삭제</target>
        </trans-unit>
        <trans-unit id="f70fbda4bf2a0042e1d9cc7f61715651b43106d6" translate="yes" xml:space="preserve">
          <source>DISCARD</source>
          <target state="translated">DISCARD</target>
        </trans-unit>
        <trans-unit id="7bb67c7109691456662bb20fddb311696e25ac95" translate="yes" xml:space="preserve">
          <source>DISCARD   Discard all commands issued after MULTI</source>
          <target state="translated">취소 MULTI 이후에 발행 된 모든 명령을 폐기하십시오</target>
        </trans-unit>
        <trans-unit id="fac3a6812b938bfbdd2af221e2fba7ec856f466e" translate="yes" xml:space="preserve">
          <source>DUMP</source>
          <target state="translated">DUMP</target>
        </trans-unit>
        <trans-unit id="88b9c1225fe8ce252d48041c949b9e8d2d7b90b3" translate="yes" xml:space="preserve">
          <source>DUMP  key   Return a serialized version of the value stored at the specified key.</source>
          <target state="translated">DUMP 키 지정된 키에 저장된 값의 직렬화 된 버전을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4220ea2836e7841048c2cdb7caf3ef474641deb4" translate="yes" xml:space="preserve">
          <source>Debugging Lua scripts</source>
          <target state="translated">루아 스크립트 디버깅</target>
        </trans-unit>
        <trans-unit id="f34ef3d0e6d55088a63bbe9a7135854f8a4a3c06" translate="yes" xml:space="preserve">
          <source>Decrements the number stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;decrement&lt;/code&gt;. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 숫자 를 &lt;code&gt;decrement&lt;/code&gt; . 키가 없으면 조작을 수행하기 전에 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 키에 잘못된 유형의 값이 있거나 정수로 표현할 수없는 문자열이 포함 된 경우 오류가 리턴됩니다. 이 연산은 64 비트 부호있는 정수로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="eabc98dcb44b2f848dc2b5fd749cc1976767b1ef" translate="yes" xml:space="preserve">
          <source>Decrements the number stored at &lt;code&gt;key&lt;/code&gt; by one. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to &lt;strong&gt;64 bit signed integers&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 숫자 를 하나씩 줄입니다. 키가 없으면 조작을 수행하기 전에 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 키에 잘못된 유형의 값이 있거나 정수로 표현할 수없는 문자열이 포함 된 경우 오류가 리턴됩니다. 이 작업은 &lt;strong&gt;64 비트 부호있는 정수로&lt;/strong&gt; 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="543341d8d409be4e8e87f012a0d71ed9115a00c9" translate="yes" xml:space="preserve">
          <source>Delete all the keys found expired.</source>
          <target state="translated">만료 된 모든 키를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="093f69205f9dd67871820195d9a0ab6b921ee71c" translate="yes" xml:space="preserve">
          <source>Delete all the keys of all the existing databases, not just the currently selected one. This command never fails.</source>
          <target state="translated">현재 선택된 데이터베이스뿐만 아니라 모든 기존 데이터베이스의 모든 키를 삭제하십시오. 이 명령은 절대 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a8bf3d0326f070451b1d5d0c69c59a369de9555" translate="yes" xml:space="preserve">
          <source>Delete all the keys of the currently selected DB. This command never fails.</source>
          <target state="translated">현재 선택된 DB의 모든 키를 삭제하십시오. 이 명령은 절대 실패하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26c0e71676fb555cdd0bb73d03160139913dfe07" translate="yes" xml:space="preserve">
          <source>Delete all the specified ACL users and terminate all the connections that are authenticated with such users. Note: the special &lt;code&gt;default&lt;/code&gt; user cannot be removed from the system, this is the default user that every new connection is authenticated with. The list of users may include usernames that do not exist, in such case no operation is performed for the non existing users.</source>
          <target state="translated">지정된 모든 ACL 사용자를 삭제하고 해당 사용자로 인증 된 모든 연결을 종료합니다. 참고 : 특수 &lt;code&gt;default&lt;/code&gt; 사용자는 시스템에서 제거 할 수 없으며 모든 새 연결이 인증되는 기본 사용자입니다. 사용자 목록에는 존재하지 않는 사용자 이름이 포함될 수 있습니다.이 경우 기존 사용자가 아닌 사용자에 대해 작업이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5165f9fa25a0905a85123f97b0428c87e1a5bb61" translate="yes" xml:space="preserve">
          <source>Deletes all slots from a node.</source>
          <target state="translated">노드에서 모든 슬롯을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="80a85a3d0c778d43ae904d63695fe309c4c3c24d" translate="yes" xml:space="preserve">
          <source>Deployment is hard if we have to make sure all instances contain a given command, especially in a distributed environment.</source>
          <target state="translated">특히 분산 환경에서 모든 인스턴스에 지정된 명령이 포함되어 있는지 확인해야 배포가 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="5ff30b622ac74ad50b3a17678781b111c2a76d5c" translate="yes" xml:space="preserve">
          <source>Design pattern</source>
          <target state="translated">디자인 패턴</target>
        </trans-unit>
        <trans-unit id="21a2deb58a8a8547be11baa26a8458026dc5e0be" translate="yes" xml:space="preserve">
          <source>Design pattern: Locking with &lt;code&gt;SETNX&lt;/code&gt;</source>
          <target state="translated">디자인 패턴 : &lt;code&gt;SETNX&lt;/code&gt; 로 잠금</target>
        </trans-unit>
        <trans-unit id="fa7fb27a452f3b56f97bc25556a2c1c23541060b" translate="yes" xml:space="preserve">
          <source>Destroy a consumer group.</source>
          <target state="translated">소비자 그룹을 파괴하십시오.</target>
        </trans-unit>
        <trans-unit id="2a999a830e915e0d76daa09bf5db1dee24489f35" translate="yes" xml:space="preserve">
          <source>Details on strings comparison</source>
          <target state="translated">문자열 비교에 대한 세부 사항</target>
        </trans-unit>
        <trans-unit id="b5cf1dd7b9908b60a915b47bdf1a512163a4abd6" translate="yes" xml:space="preserve">
          <source>Details on why the ban-list is needed</source>
          <target state="translated">금지 목록이 필요한 이유에 대한 세부 사항</target>
        </trans-unit>
        <trans-unit id="e861bf6485a8747057af520bff1e2bd98ca908ee" translate="yes" xml:space="preserve">
          <source>Detect timed out replicas.</source>
          <target state="translated">시간 초과 복제본을 감지합니다.</target>
        </trans-unit>
        <trans-unit id="c1a87c7e48f6afb9828d520eaa5085ecfdb87723" translate="yes" xml:space="preserve">
          <source>Differences between XREAD and XREADGROUP</source>
          <target state="translated">XREAD와 XREADGROUP의 차이점</target>
        </trans-unit>
        <trans-unit id="954c7e91bbe922ce8d0679c169669338d8457c3c" translate="yes" xml:space="preserve">
          <source>Differences in Redis prior 2.1.3</source>
          <target state="translated">2.1.3 이전 Redis의 차이점</target>
        </trans-unit>
        <trans-unit id="d60417fd68044b5a922b2a39105c16f898e592ce" translate="yes" xml:space="preserve">
          <source>Different instances may have different implementations of a command.</source>
          <target state="translated">인스턴스마다 다른 명령 구현이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e666a0e590c18bbb2775c33bdd4b4b2755c4fd8" translate="yes" xml:space="preserve">
          <source>Different return values are used for different subcommands.</source>
          <target state="translated">다른 부속 명령에 다른 리턴 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8519d2a89e19a4522b7059222e7d87dd5565a1b3" translate="yes" xml:space="preserve">
          <source>Disables read queries for a connection to a Redis Cluster slave node.</source>
          <target state="translated">Redis 클러스터 슬레이브 노드에 대한 연결에 대한 읽기 쿼리를 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="3c9664e573a114e8272bfbfb19ccbd51925d8d78" translate="yes" xml:space="preserve">
          <source>Distribution of returned elements</source>
          <target state="translated">반환 된 요소의 분포</target>
        </trans-unit>
        <trans-unit id="7ccde4db71eed2460dfb04d6817e8c9f76a501f5" translate="yes" xml:space="preserve">
          <source>Due to the single-threaded nature of Redis, it is not possible to kill a client connection while it is executing a command. From the client point of view, the connection can never be closed in the middle of the execution of a command. However, the client will notice the connection has been closed only when the next command is sent (and results in network error).</source>
          <target state="translated">Redis의 단일 스레드 특성으로 인해 명령을 실행하는 동안 클라이언트 연결을 종료 할 수 없습니다. 클라이언트 관점에서 명령 실행 도중 연결을 닫을 수 없습니다. 그러나 클라이언트는 다음 명령이 전송 될 때만 연결이 닫 혔음을 알 수 있으며 네트워크 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6781cfc8284296eb70ba05270579b9deac096a80" translate="yes" xml:space="preserve">
          <source>ECHO</source>
          <target state="translated">ECHO</target>
        </trans-unit>
        <trans-unit id="e7ec2091f33799c975a8d7a6ea9bc9b6bc50c88f" translate="yes" xml:space="preserve">
          <source>ECHO  message   Echo the given string</source>
          <target state="translated">ECHO 메시지 주어진 문자열을 에코</target>
        </trans-unit>
        <trans-unit id="225a586b70502eff079ebfff31adfbc6e0bf2d35" translate="yes" xml:space="preserve">
          <source>EVAL</source>
          <target state="translated">EVAL</target>
        </trans-unit>
        <trans-unit id="ea1523936796cac657906bcb4392d72c0f622a53" translate="yes" xml:space="preserve">
          <source>EVAL  script numkeys key [key ...] arg [arg ...]   Execute a Lua script server side</source>
          <target state="translated">EVAL 스크립트 numkeys 키 [key ...] arg [arg ...] Lua 스크립트 서버 측 실행</target>
        </trans-unit>
        <trans-unit id="8b8522c1abed78aca4ba0ae5b2f9d4375bf6841d" translate="yes" xml:space="preserve">
          <source>EVALSHA</source>
          <target state="translated">EVALSHA</target>
        </trans-unit>
        <trans-unit id="9ca231b5b5f90e450c680cb2bea30ab1800479a3" translate="yes" xml:space="preserve">
          <source>EVALSHA  sha1 numkeys key [key ...] arg [arg ...]   Execute a Lua script server side</source>
          <target state="translated">EVALSHA sha1 numkeys key [key ...] arg [arg ...] Lua 스크립트 서버 측 실행</target>
        </trans-unit>
        <trans-unit id="e29c908995e16002c05ec47ec36aaf34a1bd4b78" translate="yes" xml:space="preserve">
          <source>EVALSHA in the context of pipelining</source>
          <target state="translated">파이프 라이닝의 맥락에서 EVALSHA</target>
        </trans-unit>
        <trans-unit id="ea837e81db8c2bd7fcea29a56cd54086382f1f43" translate="yes" xml:space="preserve">
          <source>EXEC</source>
          <target state="translated">EXEC</target>
        </trans-unit>
        <trans-unit id="2b1156bdd8031e124d3a9ae093559b5a4386e538" translate="yes" xml:space="preserve">
          <source>EXEC   Execute all commands issued after MULTI</source>
          <target state="translated">EXEC MULTI 이후에 발행 된 모든 명령을 실행</target>
        </trans-unit>
        <trans-unit id="644b5806e118fe0af3936c64572a1496ddda7507" translate="yes" xml:space="preserve">
          <source>EXISTS</source>
          <target state="translated">EXISTS</target>
        </trans-unit>
        <trans-unit id="08807aa77041e8b29bbcefa207328a0789129027" translate="yes" xml:space="preserve">
          <source>EXISTS  key [key ...]   Determine if a key exists</source>
          <target state="translated">EXISTS 키 [key ...] 키가 있는지 확인</target>
        </trans-unit>
        <trans-unit id="1215753c2320bb44b6a871baac293e5bf276e781" translate="yes" xml:space="preserve">
          <source>EXPIRE</source>
          <target state="translated">EXPIRE</target>
        </trans-unit>
        <trans-unit id="436d86e478f5d801c08f118762eb43ed84923c39" translate="yes" xml:space="preserve">
          <source>EXPIRE  key seconds   Set a key's time to live in seconds</source>
          <target state="translated">EXPIRE key seconds 키의 시간을 초 단위로 설정합니다</target>
        </trans-unit>
        <trans-unit id="ce90cafacba153e381a002cc83387fcbd4d6f68f" translate="yes" xml:space="preserve">
          <source>EXPIREAT</source>
          <target state="translated">EXPIREAT</target>
        </trans-unit>
        <trans-unit id="34c23f46d63812eec7d4e21acb84ed6214c2b5cc" translate="yes" xml:space="preserve">
          <source>EXPIREAT  key timestamp   Set the expiration for a key as a UNIX timestamp</source>
          <target state="translated">EXPIREAT 키 타임 스탬프 키 만료를 UNIX 타임 스탬프로 설정</target>
        </trans-unit>
        <trans-unit id="1f423012c27396dae7aa028cc182a29eea955b66" translate="yes" xml:space="preserve">
          <source>Each failure report has a time to live of two times the &lt;em&gt;node timeout&lt;/em&gt; time.</source>
          <target state="translated">각 실패 보고서에는 &lt;em&gt;노드 시간 종료&lt;/em&gt; 시간 의 두 배가 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="e89059e939f6644b3364536eb50a1abdc89a1613" translate="yes" xml:space="preserve">
          <source>Each line is composed of a succession of &lt;code&gt;property=value&lt;/code&gt; fields separated by a space character.</source>
          <target state="translated">각 줄은 공백 문자로 구분 된 일련의 &lt;code&gt;property=value&lt;/code&gt; 필드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="4918aff92ee02999f29bacd99ab30d0a000253c7" translate="yes" xml:space="preserve">
          <source>Each line is composed of the following fields:</source>
          <target state="translated">각 줄은 다음 필드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="853014cc58f5042914b68be7e44d86291316a8d3" translate="yes" xml:space="preserve">
          <source>Each nested result is:</source>
          <target state="translated">각 중첩 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="001afdca6677847da08247ab1ec58a7506cae0eb" translate="yes" xml:space="preserve">
          <source>Each node in a Redis Cluster has its view of the current cluster configuration, given by the set of known nodes, the state of the connection we have with such nodes, their flags, properties and assigned slots, and so forth.</source>
          <target state="translated">Redis 클러스터의 각 노드는 알려진 노드 세트, 해당 노드와의 연결 상태, 플래그, 속성 및 할당 된 슬롯 등으로 현재 클러스터 구성을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebe29cd1a064ec2dc6312d2e8c8e3c40f46f1f35" translate="yes" xml:space="preserve">
          <source>Each reported event has the following fields:</source>
          <target state="translated">보고 된 각 이벤트에는 다음 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4031491a0a21d3efcb1ae0e642e160153ab9452c" translate="yes" xml:space="preserve">
          <source>Each result includes all active replicas of the master instance for the listed slot range. Failed replicas are not returned.</source>
          <target state="translated">각 결과에는 나열된 슬롯 범위에 대한 마스터 인스턴스의 모든 활성 복제본이 포함됩니다. 실패한 복제본은 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="39a5a1ac33abf7ccbf42de1a62abad74d800f2a8" translate="yes" xml:space="preserve">
          <source>Each subcommand is documented below. At the end you'll find a description of how live resharding is performed using this command and other related commands.</source>
          <target state="translated">각 하위 명령이 아래에 설명되어 있습니다. 마지막으로이 명령 및 기타 관련 명령을 사용하여 라이브 리 샤딩을 수행하는 방법에 대한 설명을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d0820e2ed028ade2f8d73ff5b41f73cd289b4e1" translate="yes" xml:space="preserve">
          <source>Each top-level result contains six nested results. Each nested result is:</source>
          <target state="translated">각 최상위 결과에는 6 개의 중첩 된 결과가 포함됩니다. 각 중첩 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b5f7d21b9ba2cb092f0980b7560e9cd91a246461" translate="yes" xml:space="preserve">
          <source>Effects on the node:</source>
          <target state="translated">노드에 미치는 영향 :</target>
        </trans-unit>
        <trans-unit id="1940e8677e72b823aadf3f1babad911e272f4f7b" translate="yes" xml:space="preserve">
          <source>Elements that were not constantly present in the collection during a full iteration, may be returned or not: it is undefined.</source>
          <target state="translated">전체 반복 동안 컬렉션에 지속적으로 존재하지 않는 요소는 반환 될 수도 있고 반환되지 않을 수도 있습니다. 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="fa43f0d9868a88416f82c35ed64e1745c1e56215" translate="yes" xml:space="preserve">
          <source>Elements with the same score</source>
          <target state="translated">같은 점수를 가진 요소</target>
        </trans-unit>
        <trans-unit id="127cfef1e8e010cbd37725ea8863aa38e5d50815" translate="yes" xml:space="preserve">
          <source>Emitting Redis logs from scripts</source>
          <target state="translated">스크립트에서 Redis 로그 방출</target>
        </trans-unit>
        <trans-unit id="1f733b322f80ecf7300735b8315383e95cf78665" translate="yes" xml:space="preserve">
          <source>Enables read queries for a connection to a Redis Cluster replica node.</source>
          <target state="translated">Redis 클러스터 복제본 노드에 연결하기위한 읽기 쿼리를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="6fb65c66a66392a71ca206846f2ac13ca3b45368" translate="yes" xml:space="preserve">
          <source>End slot range</source>
          <target state="translated">엔드 슬롯 범위</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="6ad4930b258ad43ab07d5ba00c43530ba3b62093" translate="yes" xml:space="preserve">
          <source>Evaluates a script cached on the server side by its SHA1 digest. Scripts are cached on the server side using the &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; command. The command is otherwise identical to &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;.</source>
          <target state="translated">SHA1 다이제스트를 통해 서버 측에서 캐시 된 스크립트를 평가합니다. 스크립트는 &lt;a href=&quot;script-load&quot;&gt;SCRIPT LOAD&lt;/a&gt; 명령을 사용하여 서버 측에서 캐시됩니다 . 그렇지 않으면 명령은 &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="3784064b237e9150f97da5ef4677aaab4b0c6d07" translate="yes" xml:space="preserve">
          <source>Even if other clients are actively pushing new items at the end of the list.</source>
          <target state="translated">다른 고객이 목록의 끝에 새 항목을 적극적으로 푸시하더라도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="7dd20b200cf466b9bb17c87ac888deb51e1a343f" translate="yes" xml:space="preserve">
          <source>Even running instances will always check the computer clock, so for instance if you set a key with a time to live of 1000 seconds, and then set your computer time 2000 seconds in the future, the key will be expired immediately, instead of lasting for 1000 seconds.</source>
          <target state="translated">실행중인 인스턴스조차도 항상 컴퓨터 시계를 확인하므로, 예를 들어 시간이 1000 초인 키를 설정 한 다음 나중에 컴퓨터 시간을 2000 초로 설정하면 키가 지속되는 대신 즉시 만료됩니다 1000 초</target>
        </trans-unit>
        <trans-unit id="d27fcdec12658758c11ddcfe5132a9543098333e" translate="yes" xml:space="preserve">
          <source>Event name.</source>
          <target state="translated">이벤트 이름.</target>
        </trans-unit>
        <trans-unit id="9ad3a7a35d62cd7230213de79ba4b1043488e12a" translate="yes" xml:space="preserve">
          <source>Eventually if all the entries in a macro-node are marked as deleted, the whole node is destroyed and the memory reclaimed. This means that if you delete a large amount of entries from a stream, for instance more than 50% of the entries appended to the stream, the memory usage per entry may increment, since what happens is that the stream will start to be fragmented. However the stream performances will remain the same.</source>
          <target state="translated">결국 매크로 노드의 모든 항목이 삭제 된 것으로 표시되면 전체 노드가 삭제되고 메모리가 회수됩니다. 이는 스트림에서 많은 양의 항목 (예 : 스트림에 추가 된 항목의 50 % 이상)을 삭제하면 스트림 조각화가 시작되기 때문에 항목 당 메모리 사용량이 증가 할 수 있음을 의미합니다. 그러나 스트림 성능은 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="792161cf042fd5babb68da92f1bbb2902dc3526e" translate="yes" xml:space="preserve">
          <source>Every Redis instance is &lt;em&gt;guaranteed&lt;/em&gt; to have all the above libraries so you can be sure that the environment for your Redis scripts is always the same.</source>
          <target state="translated">모든 Redis 인스턴스 에는 위의 모든 라이브러리 가 &lt;em&gt;보장&lt;/em&gt; 되므로 Redis 스크립트의 환경이 항상 동일하다는 것을 확신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff1000733402cd15305f0a4763cbc390865561a4" translate="yes" xml:space="preserve">
          <source>Every entry is composed of four (or six starting with Redis 4.0) fields:</source>
          <target state="translated">모든 항목은 4 개 (또는 Redis 4.0부터 6 개) 필드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c3f1325124fc7f8408e9843db0ab98baea3e119b" translate="yes" xml:space="preserve">
          <source>Every new connection starts without an assigned name.</source>
          <target state="translated">모든 새로운 연결은 지정된 이름없이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="51df853590a285fd9b12bc8e0d4650ccb232f700" translate="yes" xml:space="preserve">
          <source>Every time a node processes gossip packets from other nodes, it creates (and refreshes the TTL if needed) &lt;strong&gt;failure reports&lt;/strong&gt;, remembering that a given node said another given node is in &lt;code&gt;PFAIL&lt;/code&gt; condition.</source>
          <target state="translated">한 노드가 다른 노드에서 가십 패킷을 처리 할 때마다 지정된 노드가 다른 특정 노드가 &lt;code&gt;PFAIL&lt;/code&gt; 상태에 있다는 것을 기억하면서 &lt;strong&gt;실패 보고서를&lt;/strong&gt; 작성 (필요한 경우 TTL을 새로 고침) 합니다.</target>
        </trans-unit>
        <trans-unit id="c8f9b9897ccaf6988795d0fa2e49d6b67f29b456" translate="yes" xml:space="preserve">
          <source>Every time a user performs a page view, the application can register that in the current day the user visited the web site using the &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; command setting the bit corresponding to the current day.</source>
          <target state="translated">사용자가 페이지보기를 수행 할 때마다 응용 프로그램은 현재 날짜에 해당하는 비트를 설정하는 &lt;a href=&quot;setbit&quot;&gt;SETBIT&lt;/a&gt; 명령을 사용하여 현재 날짜에 사용자가 웹 사이트를 방문한 것을 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="434360186a18d9c330717a5f17d631c11575acb2" translate="yes" xml:space="preserve">
          <source>Every time this script executed the resulting list will have exactly the following elements:</source>
          <target state="translated">이 스크립트가 실행될 때마다 결과 목록은 정확히 다음 요소를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="815030c996b00efbe374a3c45d7121d3e9fc4929" translate="yes" xml:space="preserve">
          <source>Example of zero padding:</source>
          <target state="translated">제로 패딩의 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="c687d1b70c080536289366ba8155bc643fc72076" translate="yes" xml:space="preserve">
          <source>Exclusive intervals and infinity</source>
          <target state="translated">독점 간격과 무한대</target>
        </trans-unit>
        <trans-unit id="114f30848cb8a83d62c97a5a6476b435a78150bd" translate="yes" xml:space="preserve">
          <source>Exclusive ranges</source>
          <target state="translated">독점 범위</target>
        </trans-unit>
        <trans-unit id="55912897a10d768ac59806e69e2501c331778457" translate="yes" xml:space="preserve">
          <source>Exclusive ranges and iterating the PEL</source>
          <target state="translated">독점 범위 및 PEL 반복</target>
        </trans-unit>
        <trans-unit id="8e788d736a6e3a42271b3b6edc6a324f07e11667" translate="yes" xml:space="preserve">
          <source>Executed scripts are guaranteed to be in the script cache of a given execution of a Redis instance forever. This means that if an &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; is performed against a Redis instance all the subsequent &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; calls will succeed.</source>
          <target state="translated">실행 된 스크립트는 지정된 Redis 인스턴스 실행의 스크립트 캐시에 영구적으로 보장됩니다. 이는 Redis 인스턴스에 대해 &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 이 수행 되면 모든 후속 &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; 호출이 성공 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="446763d77e17832a47ad829663f2f4ba29ce76f7" translate="yes" xml:space="preserve">
          <source>Executes all previously queued commands in a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; and restores the connection state to normal.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;트랜잭션&lt;/a&gt; 에서 이전에 대기중인 모든 명령을 실행 하고 연결 상태를 정상으로 복원합니다.</target>
        </trans-unit>
        <trans-unit id="d80b1a46f6734fb75c0119610c9901aef0c08607" translate="yes" xml:space="preserve">
          <source>Executing a Lua Script with Redis 2.6 or newer.</source>
          <target state="translated">Redis 2.6 이상에서 Lua 스크립트 실행</target>
        </trans-unit>
        <trans-unit id="e1a9d983dc0912bcd36f098a1b8c4b6851a2ccbc" translate="yes" xml:space="preserve">
          <source>Expire accuracy</source>
          <target state="translated">만료 정확도</target>
        </trans-unit>
        <trans-unit id="5bbbfc0dcb3f1ea6203152c364bf711f30071354" translate="yes" xml:space="preserve">
          <source>Expires and persistence</source>
          <target state="translated">만료 및 지속성</target>
        </trans-unit>
        <trans-unit id="a4432b0943d588c17ab5d7e63d136bb9786a862c" translate="yes" xml:space="preserve">
          <source>Extended form of XPENDING</source>
          <target state="translated">확장 된 형태의 XPENDING</target>
        </trans-unit>
        <trans-unit id="ceae3e065a822da58b9dd577a4a2215264628a2c" translate="yes" xml:space="preserve">
          <source>FLUSHALL</source>
          <target state="translated">FLUSHALL</target>
        </trans-unit>
        <trans-unit id="a1dc7fedbb3161c8d2db024cd3ee46e2af26f812" translate="yes" xml:space="preserve">
          <source>FLUSHALL  [ASYNC]   Remove all keys from all databases</source>
          <target state="translated">FLUSHALL [ASYNC] 모든 데이터베이스에서 모든 키 제거</target>
        </trans-unit>
        <trans-unit id="10bb3c2c2d36018ba538d533264f2171634a8d95" translate="yes" xml:space="preserve">
          <source>FLUSHDB</source>
          <target state="translated">FLUSHDB</target>
        </trans-unit>
        <trans-unit id="b40b961b1c26ac58fbd9ac2f12f0c446fb2897d9" translate="yes" xml:space="preserve">
          <source>FLUSHDB  [ASYNC]   Remove all keys from the current database</source>
          <target state="translated">FLUSHDB [ASYNC] 현재 데이터베이스에서 모든 키 제거</target>
        </trans-unit>
        <trans-unit id="a5f0b2c20a29e7587597abea3e79fa609ca01e4c" translate="yes" xml:space="preserve">
          <source>FORCE option: manual failover when the master is down</source>
          <target state="translated">FORCE 옵션 : 마스터가 다운 될 때 수동 장애 조치</target>
        </trans-unit>
        <trans-unit id="f9c28b26fa472599864dea91ca5f8cd92a5475d7" translate="yes" xml:space="preserve">
          <source>Failures to authenticate their connections with &lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt; or &lt;a href=&quot;hello&quot;&gt;HELLO&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;auth&quot;&gt;AUTH&lt;/a&gt; 또는 &lt;a href=&quot;hello&quot;&gt;HELLO로&lt;/a&gt; 연결을 인증하지 못했습니다 .</target>
        </trans-unit>
        <trans-unit id="4a0878bdd16e36ba72b474afe51ae9c582fef6d5" translate="yes" xml:space="preserve">
          <source>Fetching a single entry from a stream, providing the ID of the entry to fetch two times: as start and end of the query interval.</source>
          <target state="translated">스트림에서 단일 항목을 가져 와서 조회 간격의 시작과 끝으로 두 번 페치 할 항목의 ID를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d11485369737f36370f75a3ff43b46d72effc624" translate="yes" xml:space="preserve">
          <source>Fetching data from a stream via a consumer group, and not acknowledging such data, has the effect of creating &lt;em&gt;pending entries&lt;/em&gt;. This is well explained in the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command, and even better in our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams&lt;/a&gt;. The &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; command will immediately remove the pending entry from the Pending Entry List (PEL) since once a message is successfully processed, there is no longer need for the consumer group to track it and to remember the current owner of the message.</source>
          <target state="translated">소비자 그룹을 통해 스트림에서 데이터를 가져오고 이러한 데이터를 승인하지 않으면 &lt;em&gt;보류중인 항목&lt;/em&gt; 을 만드는 효과가 있습니다. 이것은 &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; 명령 에 잘 설명되어 있으며 &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;Redis Streams 소개에&lt;/a&gt; 더 좋습니다 . &lt;a href=&quot;xack&quot;&gt;XACK의&lt;/a&gt; 명령은 즉시 메시지가 성공적으로 처리되면 이후 보류중인 항목 목록 (PEL)에서 보류중인 항목을 제거합니다, 소비자 그룹에 더 이상 필요를 추적하고 메시지의 현재 소유자를 기억이 없다.</target>
        </trans-unit>
        <trans-unit id="13b9c9d38a4b96f103ca63910ffc56743e00fd12" translate="yes" xml:space="preserve">
          <source>Fetching single items</source>
          <target state="translated">단일 항목을 가져 오는 중</target>
        </trans-unit>
        <trans-unit id="894f8f81f5445488b186c9a058eccf6bacfbb0db" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get help from the command, in case the user can't remember the exact syntax, by using the &lt;code&gt;HELP&lt;/code&gt; subcommand:</source>
          <target state="translated">마지막으로 사용자가 정확한 구문을 기억할 수없는 경우 &lt;code&gt;HELP&lt;/code&gt; 하위 명령 을 사용하여 명령 에서 도움말 을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8330be22b4e169fe5141dfbcacb82dc81724e13f" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get help from the command, in case the user can't remember the exact syntax, by using the &lt;code&gt;HELP&lt;/code&gt; subcommnad:</source>
          <target state="translated">마지막으로 &lt;code&gt;HELP&lt;/code&gt; 하위 명령 을 사용하여 사용자가 정확한 구문을 기억하지 못하는 경우 명령에서 도움을받을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5388f4a7abea666722d4311743c9d3e1d5bfc3b1" translate="yes" xml:space="preserve">
          <source>Finally it is possible to get the list of every consumer in a specific consumer group:</source>
          <target state="translated">마지막으로 특정 소비자 그룹의 모든 소비자 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cbe1b741345fc3839fb4d58149e9dd7af6c272a" translate="yes" xml:space="preserve">
          <source>Finally it is possible to pass an additional argument to the command, in order to see the messages having a specific owner:</source>
          <target state="translated">마지막으로 특정 소유자가있는 메시지를보기 위해 명령에 추가 인수를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58b2c6378bac42febc100a9e0341d2094c29e52e" translate="yes" xml:space="preserve">
          <source>Finally it possible to set the next message to deliver using the &lt;code&gt;SETID&lt;/code&gt; subcommand. Normally the next ID is set when the consumer is created, as the last argument of &lt;code&gt;XGROUP CREATE&lt;/code&gt;. However using this form the next ID can be modified later without deleting and creating the consumer group again. For instance if you want the consumers in a consumer group to re-process all the messages in a stream, you may want to set its next ID to 0:</source>
          <target state="translated">마지막으로 &lt;code&gt;SETID&lt;/code&gt; 부속 명령을 사용하여 전달할 다음 메시지를 설정할 수 있습니다 . 일반적으로 다음 ID는 소비자가 생성 될 때 &lt;code&gt;XGROUP CREATE&lt;/code&gt; 의 마지막 인수로 설정됩니다 . 그러나이 양식을 사용하면 소비자 그룹을 삭제하거나 다시 만들지 않고 다음 ID를 나중에 수정할 수 있습니다. 예를 들어 소비자 그룹의 소비자가 스트림의 모든 메시지를 다시 처리하도록하려면 다음 ID를 0으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53e0098dbba7db3bdb2ae206e024574f2dd74ced" translate="yes" xml:space="preserve">
          <source>Finally to also have the match len:</source>
          <target state="translated">마지막으로 일치 len을 갖기 위해 :</target>
        </trans-unit>
        <trans-unit id="8081b937f79256e42e7fd856b20cf39a90419c3e" translate="yes" xml:space="preserve">
          <source>Finally to get some help if you don't remember the syntax, use the HELP subcommand:</source>
          <target state="translated">구문을 기억하지 못하는 경우 도움을 받으려면 HELP 부속 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4827d8054bd5c8af82f3e09e291390e27412f49f" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;code&gt;MAXLEN&lt;/code&gt; option tells the command to compare the provided element only with a given maximum number of list items. So for instance specifying &lt;code&gt;MAXLEN 1000&lt;/code&gt; will make sure that the command performs only 1000 comparisons, effectively running the algorithm on a subset of the list (the first part or the last part depending on the fact we use a positive or negative rank). This is useful to limit the maximum complexity of the command. It is also useful when we expect the match to be found very early, but want to be sure that in case this is not true, the command does not take too much time to run.</source>
          <target state="translated">마지막으로 &lt;code&gt;MAXLEN&lt;/code&gt; 옵션은 제공된 요소를 주어진 최대 목록 항목 수와 만 비교하도록 명령에 지시합니다. 예를 들어 &lt;code&gt;MAXLEN 1000&lt;/code&gt; 을 지정 하면 명령이 1000 개의 비교 만 수행하여 목록의 하위 집합 (양수 또는 음수 순위를 사용한다는 사실에 따라 첫 번째 부분 또는 마지막 부분)에서 알고리즘을 효과적으로 실행합니다. 이는 명령의 최대 복잡성을 제한하는 데 유용합니다. 일치 항목이 매우 일찍 발견 될 것으로 예상 할 때도 유용하지만 이것이 사실이 아닌 경우 명령을 실행하는 데 너무 많은 시간이 걸리지 않는지 확인하고 싶을 때도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="fc63c9b0ba92886f08fc9cdd2dca430983266b7e" translate="yes" xml:space="preserve">
          <source>First Key in Argument List</source>
          <target state="translated">인수 목록의 첫 번째 키</target>
        </trans-unit>
        <trans-unit id="a8e315abf463cfb1c344b54fca5c387403cc9c5a" translate="yes" xml:space="preserve">
          <source>First replica of master for slot range</source>
          <target state="translated">슬롯 범위에 대한 마스터의 첫 번째 복제본</target>
        </trans-unit>
        <trans-unit id="5d728758adcdd5154d3be55552c1c061ef1489b2" translate="yes" xml:space="preserve">
          <source>Flags</source>
          <target state="translated">Flags</target>
        </trans-unit>
        <trans-unit id="4e0b6894626b05a7f879581f17814069cc8b9e6d" translate="yes" xml:space="preserve">
          <source>Flush the Append Only File if AOF is enabled.</source>
          <target state="translated">AOF가 활성화 된 경우 추가 전용 파일을 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="3b424754326ab3315277697bc94804652181fadd" translate="yes" xml:space="preserve">
          <source>Flush the Lua scripts cache.</source>
          <target state="translated">Lua 스크립트 캐시를 비 웁니다.</target>
        </trans-unit>
        <trans-unit id="f6bb844e2e06d69091cb567be5df64888a2d1098" translate="yes" xml:space="preserve">
          <source>Flushes all previously queued commands in a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; and restores the connection state to normal.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;트랜잭션&lt;/a&gt; 에서 이전에 대기 한 모든 명령을 플러시 하고 연결 상태를 정상으로 복원합니다.</target>
        </trans-unit>
        <trans-unit id="8c64c01f5213c6c086d3f83c900e781d98a8b4d5" translate="yes" xml:space="preserve">
          <source>Flushes all the previously watched keys for a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;트랜잭션에&lt;/a&gt; 대해 이전에 본 모든 키를 플러시 합니다 .</target>
        </trans-unit>
        <trans-unit id="e859a22c051906372e6ed21806faadd4fdf27b1c" translate="yes" xml:space="preserve">
          <source>For Redis 2.6 what happens is that the command performing multiple pushes is executed, and &lt;em&gt;only after&lt;/em&gt; the execution of the command the blocked clients are served. Consider this sequence of commands.</source>
          <target state="translated">Redis 2.6의 경우 다중 푸시를 수행하는 명령이 실행되고 명령 실행 &lt;em&gt;후에 만&lt;/em&gt; 차단 된 클라이언트가 제공됩니다. 이 명령 순서를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c9543ba9d8e4550fc68513216cde163b99c314dc" translate="yes" xml:space="preserve">
          <source>For a description of the &lt;code&gt;WEIGHTS&lt;/code&gt; and &lt;code&gt;AGGREGATE&lt;/code&gt; options, see &lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE&lt;/a&gt;.</source>
          <target state="translated">의 설명은 &lt;code&gt;WEIGHTS&lt;/code&gt; 와 &lt;code&gt;AGGREGATE&lt;/code&gt; 옵션을 참조 &lt;a href=&quot;zunionstore&quot;&gt;ZUNIONSTORE을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9618151d729f751e6074523159514ecdfdb57ef1" translate="yes" xml:space="preserve">
          <source>For an introduction to HyperLogLog data structure check the &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; command page.</source>
          <target state="translated">HyperLogLog 데이터 구조에 대한 소개는 &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; 명령 페이지를 확인 하십시오.</target>
        </trans-unit>
        <trans-unit id="6fcc6360d01cc6597619a76bd12e34dfa8c068d5" translate="yes" xml:space="preserve">
          <source>For an introduction to sorted sets, see the data types page on &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;sorted sets&lt;/a&gt;.</source>
          <target state="translated">정렬 된 세트에 대한 소개의 데이터 유형 페이지를 참조 &lt;a href=&quot;https://redis.io/topics/data-types#sorted-sets&quot;&gt;분류 세트를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e36005d4ed916277f75df55af354619d0ef5d5b" translate="yes" xml:space="preserve">
          <source>For each command type, the following line is added:</source>
          <target state="translated">각 명령 유형에 대해 다음 행이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e6d8b4b7b9b4f1b118134e1b85eed9b0b1555262" translate="yes" xml:space="preserve">
          <source>For each consumer group listed the command also shows the number of consumers known in that group and the pending messages (delivered but not yet acknowledged) in that group.</source>
          <target state="translated">나열된 각 소비자 그룹에 대해이 명령은 해당 그룹에 알려진 소비자 수와 해당 그룹에 보류중인 메시지 (전달되었지만 아직 승인되지 않은 메시지)도 표시합니다.</target>
        </trans-unit>
        <trans-unit id="2f01796f139a1dd83db65e8858f0ea9b62d77fdf" translate="yes" xml:space="preserve">
          <source>For each database, the following line is added:</source>
          <target state="translated">각 데이터베이스에 대해 다음 줄이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="0553e67e4dc3e5df5405dbaf017a41c48cd92358" translate="yes" xml:space="preserve">
          <source>For each replica, the following line is added:</source>
          <target state="translated">각 복제본에 대해 다음 줄이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4121db15148ef3ce1e89f4557d512e7c05a4cd89" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;field&lt;/code&gt; that does not exist in the hash, a &lt;code&gt;nil&lt;/code&gt; value is returned. Because non-existing keys are treated as empty hashes, running &lt;a href=&quot;hmget&quot;&gt;HMGET&lt;/a&gt; against a non-existing &lt;code&gt;key&lt;/code&gt; will return a list of &lt;code&gt;nil&lt;/code&gt; values.</source>
          <target state="translated">해시에 존재하지 않는 모든 &lt;code&gt;field&lt;/code&gt; 에 대해 &lt;code&gt;nil&lt;/code&gt; 값이 반환됩니다. 존재하지 않는 키를 실행, 비어있는 해시로 취급되기 때문에 &lt;a href=&quot;hmget&quot;&gt;HMGET을&lt;/a&gt; 존재하지 않는에 대한 &lt;code&gt;key&lt;/code&gt; 의 목록이 반환됩니다 &lt;code&gt;nil&lt;/code&gt; 값을.</target>
        </trans-unit>
        <trans-unit id="ebdc0b5372eb98dde6f0761af59221e15f0a9f9e" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;member&lt;/code&gt; that does not exist in the sorted set, a &lt;code&gt;nil&lt;/code&gt; value is returned.</source>
          <target state="translated">정렬 된 집합에 존재하지 않는 모든 &lt;code&gt;member&lt;/code&gt; 에 대해 &lt;code&gt;nil&lt;/code&gt; 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4313528e119e8db789aa6be23b8a03a247c203b4" translate="yes" xml:space="preserve">
          <source>For every &lt;code&gt;member&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; is returned if the value is a member of the set, or &lt;code&gt;0&lt;/code&gt; if the element is not a member of the set or if &lt;code&gt;key&lt;/code&gt; does not exist.</source>
          <target state="translated">모든 &lt;code&gt;member&lt;/code&gt; 에 대해 값이 집합의 멤버이면 &lt;code&gt;1&lt;/code&gt; 이 반환되고 , 요소가 집합의 멤버가 아니거나 &lt;code&gt;key&lt;/code&gt; 가 없으면 &lt;code&gt;0&lt;/code&gt; 이 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="b69fc5b2026538496f23b6b8fb03889d7e1936d3" translate="yes" xml:space="preserve">
          <source>For eviction purposes, you may use the &lt;code&gt;IDLETIME&lt;/code&gt; or &lt;code&gt;FREQ&lt;/code&gt; modifiers. See &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; for more information (Redis 5.0 or greater).</source>
          <target state="translated">퇴거 목적으로 &lt;code&gt;IDLETIME&lt;/code&gt; 또는 &lt;code&gt;FREQ&lt;/code&gt; 수정자를 사용할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;object&quot;&gt;OBJECT&lt;/a&gt; 를 참조하십시오 (Redis 5.0 이상).</target>
        </trans-unit>
        <trans-unit id="910c18521d782016253b4584c3c1718149e1c25d" translate="yes" xml:space="preserve">
          <source>For example a common problem when implementing Markov chains and other algorithms is to select an element at random from a set, but different elements may have different weights that change how likely it is they are picked.</source>
          <target state="translated">예를 들어 Markov 체인 및 기타 알고리즘을 구현할 때 일반적으로 발생하는 문제는 집합에서 임의의 요소를 임의로 선택하는 것이지만 요소마다 선택 될 가능성을 변경하는 가중치가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00e8032c1c0863c866e402146d15139ddaca7eea" translate="yes" xml:space="preserve">
          <source>For example in order to take the count of all the unique search queries performed in a day, a program needs to call &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; every time a query is processed. The estimated number of unique queries can be retrieved with &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; at any time.</source>
          <target state="translated">예를 들어 하루에 수행 된 모든 고유 검색 쿼리의 수를 계산하려면 쿼리가 처리 될 때마다 프로그램이 &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; 를 호출해야 합니다. &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT를 사용&lt;/a&gt; 하여 언제든지 예상되는 고유 쿼리 수를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="862ca7fa622c308433f665edc841f44e39e5d232" translate="yes" xml:space="preserve">
          <source>For example the following command assigns slots 1 2 3 to the node receiving the command:</source>
          <target state="translated">예를 들어 다음 명령은 슬롯 1 2 3을 명령을 수신하는 노드에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="49606e7b6de7a4d4946192e9ed0aa5fb1d49ac0b" translate="yes" xml:space="preserve">
          <source>For example the following command increments an 5 bit signed integer at bit offset 100, and gets the value of the 4 bit unsigned integer at bit offset 0:</source>
          <target state="translated">예를 들어 다음 명령은 비트 오프셋 100에서 5 비트 부호있는 정수를 증가시키고 비트 오프셋 0에서 4 비트 부호없는 정수 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b525686b0a28b28e11781b09afa87dd48c9db63b" translate="yes" xml:space="preserve">
          <source>For example the following command increments an 8 bit signed integer at bit offset 100, and gets the value of the 4 bit unsigned integer at bit offset 0:</source>
          <target state="translated">예를 들어 다음 명령은 비트 오프셋 100에서 8 비트 부호있는 정수를 증가시키고 비트 오프셋 0에서 4 비트 부호없는 정수의 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a97e5209e5c4a8fe8fdeedf84b0123aa8fa78b8b" translate="yes" xml:space="preserve">
          <source>For example the following command will trim the stream to exactly the latest 1000 items:</source>
          <target state="translated">예를 들어 다음 명령은 스트림을 정확히 최신 1000 개 항목으로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="bb5422e2190f7f64ad2cf5faf5279a8730064c02" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;LREM list -2 &quot;hello&quot;&lt;/code&gt; will remove the last two occurrences of &lt;code&gt;&quot;hello&quot;&lt;/code&gt; in the list stored at &lt;code&gt;list&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;LREM list -2 &quot;hello&quot;&lt;/code&gt; 는 list에 저장된 목록에서 &lt;code&gt;&quot;hello&quot;&lt;/code&gt; 의 마지막 두 항목을 제거 &lt;code&gt;list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="806b6380a574787b8a29a883731b6c80cdcdcc0d" translate="yes" xml:space="preserve">
          <source>For example, after setting a few bits, getting the string value of the bitmap would look like this:</source>
          <target state="translated">예를 들어, 몇 비트를 설정 한 후 비트 맵의 ​​문자열 값을 가져 오는 것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b555dc3155500027017fa2a4b40d9e13b0289813" translate="yes" xml:space="preserve">
          <source>For example, if I have two streams &lt;code&gt;mystream&lt;/code&gt; and &lt;code&gt;writers&lt;/code&gt;, and I want to read data from both the streams starting from the first element they contain, I could call &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; like in the following example.</source>
          <target state="translated">예를 들어 &lt;code&gt;mystream&lt;/code&gt; 과 &lt;code&gt;writers&lt;/code&gt; 두 개의 스트림이 있고 포함 된 첫 번째 요소에서 시작하여 두 스트림 모두에서 데이터를 읽으려면 다음 예제와 같이 &lt;a href=&quot;xread&quot;&gt;XREAD를&lt;/a&gt; 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd44de0983e01c60e504cf2bf01e0f7c36d85e53" translate="yes" xml:space="preserve">
          <source>For example, the example above could be replaced by:</source>
          <target state="translated">예를 들어, 위의 예는 다음으로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d36a4d27e7c4e26652f2b3ff43e697bb99cdbe49" translate="yes" xml:space="preserve">
          <source>For example: &lt;code&gt;LTRIM foobar 0 2&lt;/code&gt; will modify the list stored at &lt;code&gt;foobar&lt;/code&gt; so that only the first three elements of the list will remain.</source>
          <target state="translated">예를 들면 : &lt;code&gt;LTRIM foobar 0 2&lt;/code&gt; 는 &lt;code&gt;foobar&lt;/code&gt; 에 저장된 목록을 수정하여 목록 의 처음 세 요소 만 남게됩니다.</target>
        </trans-unit>
        <trans-unit id="aac3daaf191be281b6ccb464e390234af5058fcd" translate="yes" xml:space="preserve">
          <source>For example: consider &lt;code&gt;source&lt;/code&gt; holding the list &lt;code&gt;a,b,c&lt;/code&gt;, and &lt;code&gt;destination&lt;/code&gt; holding the list &lt;code&gt;x,y,z&lt;/code&gt;. Executing &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; results in &lt;code&gt;source&lt;/code&gt; holding &lt;code&gt;a,b&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; holding &lt;code&gt;c,x,y,z&lt;/code&gt;.</source>
          <target state="translated">예를 들어 : 목록 &lt;code&gt;a,b,c&lt;/code&gt; 를 보유한 &lt;code&gt;source&lt;/code&gt; 와 목록 &lt;code&gt;x,y,z&lt;/code&gt; 를 보유한 &lt;code&gt;destination&lt;/code&gt; 를 고려하십시오 . &lt;a href=&quot;rpoplpush&quot;&gt;RPOPLPUSH&lt;/a&gt; 를 실행 하면 &lt;code&gt;source&lt;/code&gt; 가 &lt;code&gt;a,b&lt;/code&gt; 를 보유 하고 &lt;code&gt;destination&lt;/code&gt; &lt;code&gt;c,x,y,z&lt;/code&gt; 를 보유 합니다.</target>
        </trans-unit>
        <trans-unit id="58bac03f69d7fb418a6dae21d7a1d10de406cdc5" translate="yes" xml:space="preserve">
          <source>For example: consider &lt;code&gt;source&lt;/code&gt; holding the list &lt;code&gt;a,b,c&lt;/code&gt;, and &lt;code&gt;destination&lt;/code&gt; holding the list &lt;code&gt;x,y,z&lt;/code&gt;. Executing &lt;code&gt;LMOVE source destination RIGHT LEFT&lt;/code&gt; results in &lt;code&gt;source&lt;/code&gt; holding &lt;code&gt;a,b&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; holding &lt;code&gt;c,x,y,z&lt;/code&gt;.</source>
          <target state="translated">예 : 목록 &lt;code&gt;a,b,c&lt;/code&gt; 를 보유한 &lt;code&gt;source&lt;/code&gt; 와 목록 &lt;code&gt;x,y,z&lt;/code&gt; 를 보유한 &lt;code&gt;destination&lt;/code&gt; 를 고려하십시오 . &lt;code&gt;LMOVE source destination RIGHT LEFT&lt;/code&gt; 실행 하면 &lt;code&gt;source&lt;/code&gt; 가 &lt;code&gt;a,b&lt;/code&gt; 를 보유 하고 &lt;code&gt;destination&lt;/code&gt; &lt;code&gt;c,x,y,z&lt;/code&gt; 를 보유하게 됩니다.</target>
        </trans-unit>
        <trans-unit id="b9a6b3077ebbc22869bdfb44c11c89f9170d1471" translate="yes" xml:space="preserve">
          <source>For expires to work well, the computer time must be taken stable. If you move an RDB file from two computers with a big desync in their clocks, funny things may happen (like all the keys loaded to be expired at loading time).</source>
          <target state="translated">만료가 제대로 작동하려면 컴퓨터 시간이 안정되어 있어야합니다. 시계가 크게 비 동기화 된 두 컴퓨터에서 RDB 파일을 이동하면로드 된 모든 키가로드시 만료되는 것처럼 재미있는 일이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f28bf0b4c581b256fa3b954009c5dc47ca8cc986" translate="yes" xml:space="preserve">
          <source>For further information about Redis streams please check our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams document&lt;/a&gt;.</source>
          <target state="translated">Redis 스트림에 대한 자세한 내용은 Redis 스트림 &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;소개 문서&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="9419f194b12efba96ec9e9a8a47640ef77051d15" translate="yes" xml:space="preserve">
          <source>For instance an application with a persistent connection to Redis can be sure that if a script was sent once it is still in memory, so EVALSHA can be used against those scripts in a pipeline without the chance of an error being generated due to an unknown script (we'll see this problem in detail later).</source>
          <target state="translated">예를 들어 Redis에 지속적으로 연결된 응용 프로그램은 스크립트가 메모리에 있으면 스크립트가 전송 된 경우 알 수없는 스크립트로 인해 오류가 발생하지 않고 파이프 라인의 해당 스크립트에 대해 EVALSHA를 사용할 수 있음을 확인할 수 있습니다. (이 문제는 나중에 자세히 볼 것입니다).</target>
        </trans-unit>
        <trans-unit id="dc915bb7cfa9bbec54b9f20262e4f69d0c2936e5" translate="yes" xml:space="preserve">
          <source>For instance in the above example, the last items that we received for the stream &lt;code&gt;mystream&lt;/code&gt; has ID &lt;code&gt;1526999352406-0&lt;/code&gt;, while for the stream &lt;code&gt;writers&lt;/code&gt; has the ID &lt;code&gt;1526985685298-0&lt;/code&gt;.</source>
          <target state="translated">예를 들어, 위 예제에서 &lt;code&gt;mystream&lt;/code&gt; 스트림에 대해 마지막으로 수신 한 항목의 ID는 &lt;code&gt;1526999352406-0&lt;/code&gt; 이고 스트림 &lt;code&gt;writers&lt;/code&gt; 경우 ID가 &lt;code&gt;1526985685298-0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="12e98a029b908a48582debab0c6f730b78e90807" translate="yes" xml:space="preserve">
          <source>For instance the LCS between &quot;foo&quot; and &quot;fao&quot; is &quot;fo&quot;, since scanning the two strings from left to right, the longest common set of characters is composed of the first &quot;f&quot; and then the &quot;o&quot;.</source>
          <target state="translated">예를 들어 &quot;foo&quot;와 &quot;fao&quot;사이의 LCS는 &quot;fo&quot;입니다. 왼쪽에서 오른쪽으로 두 문자열을 스캔하기 때문에 가장 긴 공통 문자 집합은 첫 번째 &quot;f&quot;와 &quot;o&quot;로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="abfec42c58b79c70de1796787342d5de058e9f11" translate="yes" xml:space="preserve">
          <source>For instance what in &lt;code&gt;redis.conf&lt;/code&gt; looks like:</source>
          <target state="translated">예를 들어 &lt;code&gt;redis.conf&lt;/code&gt; 의 내용 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="310775bb715bff8a1231237bf82d220b152e2252" translate="yes" xml:space="preserve">
          <source>For instance when Redis is used in order to implement a queue, producers and consumers of messages may want to set the name of the connection according to their role.</source>
          <target state="translated">예를 들어, 큐를 구현하기 위해 Redis를 사용하는 경우 메시지 생성자 및 소비자는 역할에 따라 연결 이름을 설정하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de61480f11e8a3010955bfd7cae332ac3deef0b2" translate="yes" xml:space="preserve">
          <source>For instance, in the above example the element &quot;c&quot; is present multiple times, if I want the index of the second match, I'll write:</source>
          <target state="translated">예를 들어, 위의 예에서 &quot;c&quot;요소는 여러 번 존재합니다. 두 번째 일치의 색인을 원하면 다음과 같이 작성합니다.</target>
        </trans-unit>
        <trans-unit id="42fe68157034ba62944abb2ee31fe519ec8ceb83" translate="yes" xml:space="preserve">
          <source>For more information about replication in Redis please check the &lt;a href=&quot;https://redis.io/topics/replication&quot;&gt;replication page&lt;/a&gt;.</source>
          <target state="translated">Redis에서의 복제에 대한 자세한 내용은 &lt;a href=&quot;https://redis.io/topics/replication&quot;&gt;복제 페이지&lt;/a&gt; 를 확인 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f14c631da3e9eabaf78a7f5c398db9fc1eb1c9a2" translate="yes" xml:space="preserve">
          <source>For more information refer to the &lt;a href=&quot;https://redis.io/topics/latency-monitor&quot;&gt;Latency Monitoring Framework page&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://redis.io/topics/latency-monitor&quot;&gt;대기 시간 모니터링 프레임 워크 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d1d2a650d31219d2da12b4e4c6aaa52db811850" translate="yes" xml:space="preserve">
          <source>For most commands the first key is position 1. Position 0 is always the command name itself.</source>
          <target state="translated">대부분의 명령에서 첫 번째 키는 위치 1입니다. 위치 0은 항상 명령 이름 자체입니다.</target>
        </trans-unit>
        <trans-unit id="f3b735d69f1d53bb920c323089af35c7960cd5bc" translate="yes" xml:space="preserve">
          <source>For nested data types, the optional &lt;code&gt;SAMPLES&lt;/code&gt; option can be provided, where &lt;code&gt;count&lt;/code&gt; is the number of sampled nested values. By default, this option is set to &lt;code&gt;5&lt;/code&gt;. To sample the all of the nested values, use &lt;code&gt;SAMPLES 0&lt;/code&gt;.</source>
          <target state="translated">중첩 데이터 유형의 경우 선택적 &lt;code&gt;SAMPLES&lt;/code&gt; 옵션을 제공 할 수 있습니다. 여기서 &lt;code&gt;count&lt;/code&gt; 는 샘플링 된 중첩 값의 수입니다. 기본적으로이 옵션은 &lt;code&gt;5&lt;/code&gt; 로 설정되어 있습니다. 모든 중첩 값을 샘플링하려면 &lt;code&gt;SAMPLES 0&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="29cc98c67031f5feb4c8c0734d6bcf119180ebd0" translate="yes" xml:space="preserve">
          <source>For real-time metrics and statistics involving large inputs a good approach is to use a replica (with read-only option disabled) where the bit-wise operations are performed to avoid blocking the master instance.</source>
          <target state="translated">대규모 입력이 포함 된 실시간 메트릭 및 통계의 경우 마스터 인스턴스 차단을 피하기 위해 비트 단위 작업이 수행되는 복제본 (읽기 전용 옵션이 비활성화 된 상태)을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="86c11a7ed67c320eacf7f860ba9da8b316757034" translate="yes" xml:space="preserve">
          <source>For security concerns, certain special administration commands like &lt;code&gt;CONFIG&lt;/code&gt; are not logged into the &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; output.</source>
          <target state="translated">보안상의 이유로 &lt;code&gt;CONFIG&lt;/code&gt; 와 같은 특정 특수 관리 명령 은 &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 출력에 로그인되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="906c5a5f8c50388c930df8c6fdc394c6fc2a805e" translate="yes" xml:space="preserve">
          <source>For the LCS algorithm:</source>
          <target state="translated">LCS 알고리즘의 경우 :</target>
        </trans-unit>
        <trans-unit id="68c60647d6f0b610c394981eaeb8a9621bab7be5" translate="yes" xml:space="preserve">
          <source>For the subsequent calls, you'll need to programmatically advance the last entry's ID returned. Most Redis client should abstract this detail, but the implementation can also be in the application if needed. In the example above, this means incrementing the sequence of &lt;code&gt;1526985685298-0&lt;/code&gt; by one, from 0 to 1. The second call would, therefore, be:</source>
          <target state="translated">후속 호출의 경우 반환 된 마지막 항목의 ID를 프로그래밍 방식으로 진행해야합니다. 대부분의 Redis 클라이언트는이 세부 사항을 추상화해야하지만 필요한 경우 애플리케이션에 구현할 수도 있습니다. 위의 예에서 이것은 &lt;code&gt;1526985685298-0&lt;/code&gt; 의 시퀀스 를 0에서 1까지 1 씩 증가시키는 것을 의미 합니다. 따라서 두 번째 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1d4a1b4aeeb486fd399846319b2294f91ddedb8b" translate="yes" xml:space="preserve">
          <source>For this reason, Redis 3.2 introduces a new command that only works when script effects replication is enabled, and is able to control the scripting replication engine. The command is called &lt;code&gt;redis.set_repl()&lt;/code&gt; and fails raising an error if called when script effects replication is disabled.</source>
          <target state="translated">이러한 이유로 Redis 3.2에는 스크립트 효과 복제가 활성화 된 경우에만 작동하고 스크립팅 복제 엔진을 제어 할 수있는 새로운 명령이 도입되었습니다. 이 명령을 &lt;code&gt;redis.set_repl()&lt;/code&gt; 이라고하며 스크립트 효과 복제가 비활성화 된 경우 호출되면 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51865baeeba9dd27720c605912d3014b8edbbb78" translate="yes" xml:space="preserve">
          <source>Forces a node to save the &lt;code&gt;nodes.conf&lt;/code&gt; configuration on disk. Before to return the command calls &lt;code&gt;fsync(2)&lt;/code&gt; in order to make sure the configuration is flushed on the computer disk.</source>
          <target state="translated">노드가 디스크에 &lt;code&gt;nodes.conf&lt;/code&gt; 구성 을 저장 하도록합니다. 명령을 리턴하기 전에 구성이 컴퓨터 디스크에서 플러시되는지 확인하기 위해 &lt;code&gt;fsync(2)&lt;/code&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="620cbfd5798a03238a582c36dc6180b1d68a8181" translate="yes" xml:space="preserve">
          <source>Fortunately, it's possible to avoid this issue using the following algorithm. Let's see how C4, our sane client, uses the good algorithm:</source>
          <target state="translated">다행히도 다음 알고리즘을 사용하여이 문제를 피할 수 있습니다. 제정신 클라이언트 인 C4가 어떻게 좋은 알고리즘을 사용하는지 봅시다 :</target>
        </trans-unit>
        <trans-unit id="e02d5afefc425c600d8eecdd85f79d3604e46010" translate="yes" xml:space="preserve">
          <source>From the point of view of the syntax, the commands are almost the same, however &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt;&lt;em&gt;requires&lt;/em&gt; a special and mandatory option:</source>
          <target state="translated">구문의 관점에서 보면 명령은 거의 동일하지만 &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP &lt;/a&gt;&lt;em&gt;에는&lt;/em&gt; 특수하고 필수 옵션이 &lt;em&gt;필요&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="86f3ae974780a50a7664a8c324379a24cfdab877" translate="yes" xml:space="preserve">
          <source>Fun fact: Reddit's 2017 April fools' project &lt;a href=&quot;https://reddit.com/r/place&quot;&gt;r/place&lt;/a&gt; was &lt;a href=&quot;https://redditblog.com/2017/04/13/how-we-built-rplace/&quot;&gt;built using the Redis BITFIELD command&lt;/a&gt; in order to take an in-memory representation of the collaborative canvas.</source>
          <target state="translated">재미있는 사실 : Reddit의 2017 년 4 월 바보 프로젝트 &lt;a href=&quot;https://reddit.com/r/place&quot;&gt;r / place&lt;/a&gt; 는 &lt;a href=&quot;https://redditblog.com/2017/04/13/how-we-built-rplace/&quot;&gt;Redis BITFIELD 명령&lt;/a&gt; 을 사용 하여 협업 캔버스를 메모리 내에서 표현하기 위해 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="53eb3603814482cd94f53dcb8dd480c97fb7a365" translate="yes" xml:space="preserve">
          <source>Furthermore, the following commands are also not logged:</source>
          <target state="translated">또한 다음 명령도 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29ad85263278e1f788abee93dcd93c6b5f400940" translate="yes" xml:space="preserve">
          <source>GEOADD</source>
          <target state="translated">GEOADD</target>
        </trans-unit>
        <trans-unit id="fe36dd170b2d009a6fb9b3209da995c6be0a8014" translate="yes" xml:space="preserve">
          <source>GEOADD  key longitude latitude member [longitude latitude member ...]   Add one or more geospatial items in the geospatial index represented using a sorted set</source>
          <target state="translated">GEOADD 키 경도 위도 멤버 [경도 위도 멤버 ...] 정렬 된 세트를 사용하여 나타내는 지리 공간 인덱스에 하나 이상의 지리 공간 항목을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9aee98cec79ef9607b17d14a98e26344f2559e24" translate="yes" xml:space="preserve">
          <source>GEODIST</source>
          <target state="translated">GEODIST</target>
        </trans-unit>
        <trans-unit id="d87009d6893410d7c22a72e0781ff862c94b8508" translate="yes" xml:space="preserve">
          <source>GEODIST  key member1 member2 [m|km|ft|mi]   Returns the distance between two members of a geospatial index</source>
          <target state="translated">GEODIST 키 멤버 1 멤버 2 [m | km | ft | mi] 지리 공간 인덱스의 두 멤버 사이의 거리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0a8e4fd28c6ceedcd2cf757094650298262be7f7" translate="yes" xml:space="preserve">
          <source>GEODIST  key member1 member2 [unit]   Returns the distance between two members of a geospatial index</source>
          <target state="translated">GEODIST 키 멤버 1 member2 [단위] 지리 공간 인덱스의 두 멤버 사이의 거리를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d944f228d17ba584e232ef6b37a2330565210913" translate="yes" xml:space="preserve">
          <source>GEOHASH</source>
          <target state="translated">GEOHASH</target>
        </trans-unit>
        <trans-unit id="15d5ff901e592f20465c4a81d62cdf535660ac71" translate="yes" xml:space="preserve">
          <source>GEOHASH  key member [member ...]   Returns members of a geospatial index as standard geohash strings</source>
          <target state="translated">GEOHASH 키 멤버 [member ...] 지리 공간 인덱스의 멤버를 표준 geohash 문자열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="567f488d82e3265931365c2760b37b40e268471e" translate="yes" xml:space="preserve">
          <source>GEOPOS</source>
          <target state="translated">GEOPOS</target>
        </trans-unit>
        <trans-unit id="681795a057130a9988e5c024a1915dc60c2ecb58" translate="yes" xml:space="preserve">
          <source>GEOPOS  key member [member ...]   Returns longitude and latitude of members of a geospatial index</source>
          <target state="translated">GEOPOS 키 멤버 [member ...] 지리 공간 인덱스 멤버의 경도와 위도를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f883ad1ea5b9628a7c035af52696e8e216f48428" translate="yes" xml:space="preserve">
          <source>GEORADIUS</source>
          <target state="translated">GEORADIUS</target>
        </trans-unit>
        <trans-unit id="78a8e700f33e02c64280e94efe97493736549c5c" translate="yes" xml:space="preserve">
          <source>GEORADIUS  key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]   Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point</source>
          <target state="translated">GEORADIUS 키 경도 위도 반경 m | km | ft | mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT 수] [ASC | DESC] [STORE 키] [STOREDIST 키] 일치하는 멤버를 가져 오기 위해 지리 공간 인덱스를 나타내는 정렬 된 세트를 쿼리합니다. 점으로부터 주어진 최대 거리</target>
        </trans-unit>
        <trans-unit id="ae4c6b87ec31f7b6af274155550a43bc379afb42" translate="yes" xml:space="preserve">
          <source>GEORADIUSBYMEMBER</source>
          <target state="translated">GEORADIUSBYMEMBER</target>
        </trans-unit>
        <trans-unit id="cf98dab16a680969ed5a7c59dd91c064dd5ffd22" translate="yes" xml:space="preserve">
          <source>GEORADIUSBYMEMBER  key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]   Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member</source>
          <target state="translated">GEORADIUSBYMEMBER 키 멤버 반경 m | km | ft | mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT 수] [ASC | DESC] [STORE 키] [STOREDIST 키] 지리 공간 인덱스를 나타내는 정렬 된 세트를 쿼리하여 멤버로부터 주어진 최대 거리</target>
        </trans-unit>
        <trans-unit id="8c656e42e400e0e0513de5eb5312afe50a9bf1f5" translate="yes" xml:space="preserve">
          <source>GEOSEARCH</source>
          <target state="translated">GEOSEARCH</target>
        </trans-unit>
        <trans-unit id="3f9c1bdbc9920ba8577c53041094c05d6b105844" translate="yes" xml:space="preserve">
          <source>GEOSEARCH  key [FROMMEMBER member] [FROMLONLAT longitude latitude] [BYRADIUS radius m|km|ft|mi] [BYBOX width height m|km|ft|mi] [ASC|DESC] [COUNT count] [WITHCOORD] [WITHDIST] [WITHHASH]   Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle.</source>
          <target state="translated">GEOSEARCH 키 [FROMMEMBER 멤버] [FROMLONLAT 경도 위도] [BYRADIUS 반경 m | km | ft | mi] [BYBOX 너비 높이 m | km | ft | mi] [ASC | DESC] [COUNT 카운트] [WITHCOORD] [WITHDIST] [ WITHHASH] 지리 공간 인덱스를 나타내는 정렬 된 집합을 쿼리하여 상자 또는 원의 영역 내부에있는 구성원을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6b6122a14306dc58653c28237fae16723377d12d" translate="yes" xml:space="preserve">
          <source>GEOSEARCHSTORE</source>
          <target state="translated">GEOSEARCHSTORE</target>
        </trans-unit>
        <trans-unit id="8ad42c0130aa6e2dd8ebab61f847d23ba5e52254" translate="yes" xml:space="preserve">
          <source>GEOSEARCHSTORE  destination source [FROMMEMBER member] [FROMLONLAT longitude latitude] [BYRADIUS radius m|km|ft|mi] [BYBOX width height m|km|ft|mi] [ASC|DESC] [COUNT count] [WITHCOORD] [WITHDIST] [WITHHASH] [STOREDIST]   Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle, and store the result in another key.</source>
          <target state="translated">GEOSEARCHSTORE 대상 소스 [FROMMEMBER 멤버] [FROMLONLAT 경도 위도] [BYRADIUS 반경 m | km | ft | mi] [BYBOX 너비 높이 m | km | ft | mi] [ASC | DESC] [COUNT 카운트] [WITHCOORD] [WITHDIST] [WITHHASH] [STOREDIST] 지리 공간 인덱스를 나타내는 정렬 된 집합을 쿼리하여 상자 또는 원의 영역 내부에있는 구성원을 가져오고 결과를 다른 키에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="f030bbbd32966cde41037b98a8849c46b76e4bc1" translate="yes" xml:space="preserve">
          <source>GET</source>
          <target state="translated">GET</target>
        </trans-unit>
        <trans-unit id="7d7f9a21ff2fe871d6f138989249c29532bb7fdc" translate="yes" xml:space="preserve">
          <source>GET  key   Get the value of a key</source>
          <target state="translated">GET 키 키 값 얻기</target>
        </trans-unit>
        <trans-unit id="ef9841e66f1ceb2a8ca3c4b61209bfb1ccb07d46" translate="yes" xml:space="preserve">
          <source>GETBIT</source>
          <target state="translated">GETBIT</target>
        </trans-unit>
        <trans-unit id="c67560b598b48f8d8597f643fcac2a09acec11dd" translate="yes" xml:space="preserve">
          <source>GETBIT  key offset   Returns the bit value at offset in the string value stored at key</source>
          <target state="translated">GETBIT 키 오프셋 키에 저장된 문자열 값에서 오프셋의 비트 값을 반환합니다</target>
        </trans-unit>
        <trans-unit id="171dc01acd21b14b16885f344959333f303f7868" translate="yes" xml:space="preserve">
          <source>GETRANGE</source>
          <target state="translated">GETRANGE</target>
        </trans-unit>
        <trans-unit id="120d6e3c8bea25d9ffe941d0b9d148464db210c6" translate="yes" xml:space="preserve">
          <source>GETRANGE  key start end   Get a substring of the string stored at a key</source>
          <target state="translated">GETRANGE key start end 키에 저장된 문자열의 부분 문자열을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="6a4472582074006f8a0d04a695a91bfb64d3f211" translate="yes" xml:space="preserve">
          <source>GETSET</source>
          <target state="translated">GETSET</target>
        </trans-unit>
        <trans-unit id="ea14ecdc443c7b2197bfb8f599d84d9e3ddc91a9" translate="yes" xml:space="preserve">
          <source>GETSET  key value   Set the string value of a key and return its old value</source>
          <target state="translated">GETSET 키 값 키의 문자열 값을 설정하고 이전 값을 반환</target>
        </trans-unit>
        <trans-unit id="0f33bfb55b7c38358e7fef810b5a8c3a19e508c9" translate="yes" xml:space="preserve">
          <source>Generate a new &lt;code&gt;configEpoch&lt;/code&gt; unilaterally, just taking the current greatest epoch available and incrementing it if its local configuration epoch is not already the greatest.</source>
          <target state="translated">현재 사용 가능한 가장 큰 에포크를 가져 와서 로컬 구성 에포크가 아직 크지 않은 경우 증가 &lt;code&gt;configEpoch&lt;/code&gt; 새로운 ConfigEpoch를 일방적으로 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8770e1d00765da154add27070eb66b76abb639e9" translate="yes" xml:space="preserve">
          <source>Geo</source>
          <target state="translated">Geo</target>
        </trans-unit>
        <trans-unit id="00754e7ec718eca2346352874423afcfcd99de6c" translate="yes" xml:space="preserve">
          <source>Geohash string properties</source>
          <target state="translated">지오 해시 문자열 속성</target>
        </trans-unit>
        <trans-unit id="fcba9fe6c6b3ee7a7679d8a80f01c177efafb91f" translate="yes" xml:space="preserve">
          <source>Get keys from the source node with &lt;a href=&quot;cluster-getkeysinslot&quot;&gt;CLUSTER GETKEYSINSLOT&lt;/a&gt; command and move them into the destination node using the &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;cluster-getkeysinslot&quot;&gt;CLUSTER GETKEYSINSLOT&lt;/a&gt; 명령으로 소스 노드에서 키를 가져 오고 &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt; 명령을 사용하여 대상 노드로 키를 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="09aec2d48c2bf33e9f4de1efe0b69e4c3361c2f6" translate="yes" xml:space="preserve">
          <source>Get the value of &lt;code&gt;key&lt;/code&gt;. If the key does not exist the special value &lt;code&gt;nil&lt;/code&gt; is returned. An error is returned if the value stored at &lt;code&gt;key&lt;/code&gt; is not a string, because &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; only handles string values.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 값을 얻습니다 . 키가 존재하지 않으면 특수 값 &lt;code&gt;nil&lt;/code&gt; 이 리턴됩니다. &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; 은 문자열 값만 처리 하므로 &lt;code&gt;key&lt;/code&gt; 에 저장된 값 이 문자열이 아닌 경우 오류가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f07c68cfde1cce4484071399ec3dcac10ef3226" translate="yes" xml:space="preserve">
          <source>Given a list of SHA1 digests as arguments this command returns an array of 1 or 0, where 1 means the specific SHA1 is recognized as a script already present in the scripting cache, while 0 means that a script with this SHA1 was never seen before (or at least never seen after the latest SCRIPT FLUSH command).</source>
          <target state="translated">SHA1 다이제스트 목록을 인수로 지정하면이 명령은 1 또는 0의 배열을 리턴합니다. 여기서 1은 특정 SHA1이 스크립팅 캐시에 이미 존재하는 스크립트로 인식되고 0은이 SHA1이 포함 된 스크립트가 이전에 본 적이 없음을 의미합니다 ( 또는 최신 SCRIPT FLUSH 명령 이후에는 본 적이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5e47705fe8d80f510ddf59025f5bedac0bd2d833" translate="yes" xml:space="preserve">
          <source>Given a sorted set representing a geospatial index, populated using the &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; command, it is often useful to obtain back the coordinates of specified members. When the geospatial index is populated via &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; the coordinates are converted into a 52 bit geohash, so the coordinates returned may not be exactly the ones used in order to add the elements, but small errors may be introduced.</source>
          <target state="translated">&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; 명령을 사용하여 채워진 지리 공간 인덱스를 나타내는 정렬 된 세트가 주어지면 종종 지정된 멤버의 좌표를 다시 얻는 것이 유용합니다. 지리 공간 인덱스가 &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; 를 통해 채워 지면 좌표가 52 비트 지오 해시로 변환되므로 반환 된 좌표가 요소를 추가하기 위해 사용 된 좌표가 아닐 수 있지만 작은 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a98977aea8887ddd5a1edb60251e403b53795ab" translate="yes" xml:space="preserve">
          <source>Given a sorted set representing a geospatial index, populated using the &lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; command, the command returns the distance between the two specified members in the specified unit.</source>
          <target state="translated">&lt;a href=&quot;geoadd&quot;&gt;GEOADD&lt;/a&gt; 명령을 사용하여 채워진 지리 공간 색인을 나타내는 정렬 된 세트가 제공 되면 명령은 지정된 단위로 지정된 두 멤버 사이의 거리를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f45f257965d0c26e93bb5789953aca2dc751ef9e" translate="yes" xml:space="preserve">
          <source>Global variables protection</source>
          <target state="translated">글로벌 변수 보호</target>
        </trans-unit>
        <trans-unit id="107625e2c3bcf140428d9df7e4e1066049947d81" translate="yes" xml:space="preserve">
          <source>Groups, consumers and PELs are returned.</source>
          <target state="translated">그룹, 소비자 및 PEL이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="15d1555c45e5fc58578080840f0c6368a6d6cb11" translate="yes" xml:space="preserve">
          <source>Guarantee of termination</source>
          <target state="translated">해지 보장</target>
        </trans-unit>
        <trans-unit id="5205aa5d3ee9c438b38044d5999ac4ba4201f832" translate="yes" xml:space="preserve">
          <source>HDEL</source>
          <target state="translated">HDEL</target>
        </trans-unit>
        <trans-unit id="f0d9eb5c49197bfd6feeb0c9d7b482f5e211f201" translate="yes" xml:space="preserve">
          <source>HDEL  key field [field ...]   Delete one or more hash fields</source>
          <target state="translated">HDEL 키 필드 [field ...] 하나 이상의 해시 필드 삭제</target>
        </trans-unit>
        <trans-unit id="c65f99f8c5376adadddc46d5cbcf5762f9e55eb7" translate="yes" xml:space="preserve">
          <source>HELLO</source>
          <target state="translated">HELLO</target>
        </trans-unit>
        <trans-unit id="194f965f233e82e8b705df8610029d9234df6a34" translate="yes" xml:space="preserve">
          <source>HELLO  protover [AUTH username password] [SETNAME clientname]   switch Redis protocol</source>
          <target state="translated">HELLO protover [AUTH username password] [SETNAME clientname] 스위치 Redis 프로토콜</target>
        </trans-unit>
        <trans-unit id="b48dcfbcf4eca1611582a1cc8baa82d9d2fa2960" translate="yes" xml:space="preserve">
          <source>HEXISTS</source>
          <target state="translated">HEXISTS</target>
        </trans-unit>
        <trans-unit id="a807653048c48da53e448a2b285039ef0573aae8" translate="yes" xml:space="preserve">
          <source>HEXISTS  key field   Determine if a hash field exists</source>
          <target state="translated">HEXISTS 키 필드 해시 필드가 존재하는지 확인</target>
        </trans-unit>
        <trans-unit id="2aa481a50927484124964b6f73bac3881de47ff3" translate="yes" xml:space="preserve">
          <source>HGET</source>
          <target state="translated">HGET</target>
        </trans-unit>
        <trans-unit id="53e1681d3979ea38127102b70459b3a4ea647f65" translate="yes" xml:space="preserve">
          <source>HGET  key field   Get the value of a hash field</source>
          <target state="translated">HGET 키 필드 해시 필드 값 가져 오기</target>
        </trans-unit>
        <trans-unit id="0949fe15e4d07355cc1f8bdf2d7d0a3bc27e0498" translate="yes" xml:space="preserve">
          <source>HGETALL</source>
          <target state="translated">HGETALL</target>
        </trans-unit>
        <trans-unit id="a9f2d8c36ab9a92512a3abf304cf22c78a10d32a" translate="yes" xml:space="preserve">
          <source>HGETALL  key   Get all the fields and values in a hash</source>
          <target state="translated">HGETALL 키 해시의 모든 필드와 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bec3f40ebfc071338931e9ec346c383954f688e2" translate="yes" xml:space="preserve">
          <source>HINCRBY</source>
          <target state="translated">HINCRBY</target>
        </trans-unit>
        <trans-unit id="85ba7d4ce6a861db6587eaef82d0c559a1acad5a" translate="yes" xml:space="preserve">
          <source>HINCRBY  key field increment   Increment the integer value of a hash field by the given number</source>
          <target state="translated">HINCRBY 키 필드 증분 해시 필드의 정수 값을 주어진 숫자만큼 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="a93522c3800a73e9eb332f7f840625aacdc296f3" translate="yes" xml:space="preserve">
          <source>HINCRBYFLOAT</source>
          <target state="translated">HINCRBYFLOAT</target>
        </trans-unit>
        <trans-unit id="b074f9cd10320d76be5375524c56b4c4f5083f25" translate="yes" xml:space="preserve">
          <source>HINCRBYFLOAT  key field increment   Increment the float value of a hash field by the given amount</source>
          <target state="translated">HINCRBYFLOAT 키 필드 증분 해시 필드의 부동 소수점 값을 주어진 양만큼 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="a857392e173da21b13e4d3e033f1d7d6aadde58a" translate="yes" xml:space="preserve">
          <source>HKEYS</source>
          <target state="translated">HKEYS</target>
        </trans-unit>
        <trans-unit id="4880894873a3e4a3dcf54bf74bebf960afb44a7c" translate="yes" xml:space="preserve">
          <source>HKEYS  key   Get all the fields in a hash</source>
          <target state="translated">HKEYS 키 해시의 모든 필드 가져 오기</target>
        </trans-unit>
        <trans-unit id="4d36dfb03a6ecdea21a171dc0c30adebe8d01184" translate="yes" xml:space="preserve">
          <source>HLEN</source>
          <target state="translated">HLEN</target>
        </trans-unit>
        <trans-unit id="bcfcea9d003f5af07b2bb8099e2b496b1e9e832a" translate="yes" xml:space="preserve">
          <source>HLEN  key   Get the number of fields in a hash</source>
          <target state="translated">HLEN 키 해시의 필드 수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="480987a6e9c4e7cd1d65f5ffad4b88a1132f2c6f" translate="yes" xml:space="preserve">
          <source>HMGET</source>
          <target state="translated">HMGET</target>
        </trans-unit>
        <trans-unit id="5b7367a8f047e6e2ad4600495794ba1f6c7d8f47" translate="yes" xml:space="preserve">
          <source>HMGET  key field [field ...]   Get the values of all the given hash fields</source>
          <target state="translated">HMGET 키 필드 [field ...] 주어진 모든 해시 필드의 값을 가져옵니다</target>
        </trans-unit>
        <trans-unit id="fb5089ab3a0516d344f9de817ed332775e142279" translate="yes" xml:space="preserve">
          <source>HMSET</source>
          <target state="translated">HMSET</target>
        </trans-unit>
        <trans-unit id="b9ce7bb49b575eba9a143cb12bd3a727345953bd" translate="yes" xml:space="preserve">
          <source>HMSET  key field value [field value ...]   Set multiple hash fields to multiple values</source>
          <target state="translated">HMSET 키 필드 값 [field value ...] 여러 해시 필드를 여러 값으로 설정</target>
        </trans-unit>
        <trans-unit id="f36a969e90bd023793807636ddb180dde5956fd7" translate="yes" xml:space="preserve">
          <source>HSCAN</source>
          <target state="translated">HSCAN</target>
        </trans-unit>
        <trans-unit id="1f717593e9570c814ba25178e664e1d1c164122d" translate="yes" xml:space="preserve">
          <source>HSCAN  key cursor [MATCH pattern] [COUNT count]   Incrementally iterate hash fields and associated values</source>
          <target state="translated">HSCAN 키 커서 [MATCH 패턴] [COUNT 수] 해시 필드 및 관련 값을 증분 반복</target>
        </trans-unit>
        <trans-unit id="00cee6cf2b7799f7538096724dbd92d41cec6aeb" translate="yes" xml:space="preserve">
          <source>HSET</source>
          <target state="translated">HSET</target>
        </trans-unit>
        <trans-unit id="665396b991835984fc7e3e34cd2fe5312ecf417d" translate="yes" xml:space="preserve">
          <source>HSET  key field value   Set the string value of a hash field</source>
          <target state="translated">HSET 키 필드 값 해시 필드의 문자열 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="bc6fdaa755b1bfae0ec78315f5fb3674c528f4e4" translate="yes" xml:space="preserve">
          <source>HSET  key field value [field value ...]   Set the string value of a hash field</source>
          <target state="translated">HSET 키 필드 값 [필드 값 ...] 해시 필드의 문자열 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f08f81142bc45f390db40acaf0af8de40d5f8df0" translate="yes" xml:space="preserve">
          <source>HSETNX</source>
          <target state="translated">HSETNX</target>
        </trans-unit>
        <trans-unit id="8f0805bb5892aca6c147d761f188dcc8c135168b" translate="yes" xml:space="preserve">
          <source>HSETNX  key field value   Set the value of a hash field, only if the field does not exist</source>
          <target state="translated">HSETNX 키 필드 값 필드가 존재하지 않는 경우에만 해시 필드의 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="653e2c00767d7da99a4ad249e0220683a0f21927" translate="yes" xml:space="preserve">
          <source>HSTRLEN</source>
          <target state="translated">HSTRLEN</target>
        </trans-unit>
        <trans-unit id="bb8103389cfdcecf46656f06573ed3513c20d29d" translate="yes" xml:space="preserve">
          <source>HSTRLEN  key field   Get the length of the value of a hash field</source>
          <target state="translated">HSTRLEN 키 필드 해시 필드 값의 길이를 가져옵니다</target>
        </trans-unit>
        <trans-unit id="75c2a102095c5cfb3745c7635997fd6d46e1ed99" translate="yes" xml:space="preserve">
          <source>HVALS</source>
          <target state="translated">HVALS</target>
        </trans-unit>
        <trans-unit id="2cf3758bf2c3fcb0cf4699e1fad2c529e7f60c18" translate="yes" xml:space="preserve">
          <source>HVALS  key   Get all the values in a hash</source>
          <target state="translated">HVALS 키 해시의 모든 값 가져 오기</target>
        </trans-unit>
        <trans-unit id="1679a916ecf39377920740d5654170e7e20f04f9" translate="yes" xml:space="preserve">
          <source>Handling deadlocks</source>
          <target state="translated">교착 상태 처리</target>
        </trans-unit>
        <trans-unit id="17348a159bc90f6828002f9fa69a3bdc1006ad33" translate="yes" xml:space="preserve">
          <source>Handling of strings with different lengths</source>
          <target state="translated">길이가 다른 문자열 처리</target>
        </trans-unit>
        <trans-unit id="5551ebd48f7eaa66477f72c449e4b2ccfc0f9609" translate="yes" xml:space="preserve">
          <source>Hashes</source>
          <target state="translated">Hashes</target>
        </trans-unit>
        <trans-unit id="abef659c43351c90fc57bd2f1f2ca21c74a56b5c" translate="yes" xml:space="preserve">
          <source>Hashes can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;hashtable&lt;/code&gt;. The &lt;code&gt;ziplist&lt;/code&gt; is a special encoding used for small hashes.</source>
          <target state="translated">해시는 &lt;code&gt;ziplist&lt;/code&gt; 또는 &lt;code&gt;hashtable&lt;/code&gt; 로 인코딩 될 수 있습니다 . &lt;code&gt;ziplist&lt;/code&gt; 는 작은 해시에 사용되는 특별한 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="a9f98aceea4b6640fde4f0db2b67c8b62670525a" translate="yes" xml:space="preserve">
          <source>Helper functions to return Redis types</source>
          <target state="translated">Redis 유형을 반환하는 도우미 함수</target>
        </trans-unit>
        <trans-unit id="71f2a2c44b12e8d025ffdb0ba44d167f2eb32dc5" translate="yes" xml:space="preserve">
          <source>Here are a few conversion examples:</source>
          <target state="translated">다음은 몇 가지 변환 예입니다.</target>
        </trans-unit>
        <trans-unit id="bd16d98ee220a06318e7c2f0edf89d89e391fb27" translate="yes" xml:space="preserve">
          <source>Here is the description of fields for Redis &amp;gt;= 2.4.</source>
          <target state="translated">다음은 Redis&amp;gt; = 2.4에 대한 필드 설명입니다.</target>
        </trans-unit>
        <trans-unit id="1953d7d107ad4ade79603b02cdb1e8adc699e514" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;clients&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;클라이언트&lt;/strong&gt; 섹션 에있는 모든 필드의 의미는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="aa545dc398491c6907d2041f2ded31d190284a9f" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;cpu&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;CPU&lt;/strong&gt; 섹션 의 모든 필드의 의미는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d3d5c7888fb0526434ccb545db7ed9e893e48b61" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;memory&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;메모리&lt;/strong&gt; 섹션 에있는 모든 필드의 의미는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d1e56b526c805770cba7347f8a39b9426d10e67e" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;persistence&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;지속성&lt;/strong&gt; 섹션 에있는 모든 필드의 의미는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="799881fdedd2437b9e8155aa33f7576cc6d468a1" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;replication&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;복제&lt;/strong&gt; 섹션 에있는 모든 필드의 의미는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="0d613b28b44d140ea4afd266be689c2f86ce192d" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;server&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;서버&lt;/strong&gt; 섹션 에있는 모든 필드의 의미는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9700349259df5577664d69e8579a5af99e65c52f" translate="yes" xml:space="preserve">
          <source>Here is the meaning of all fields in the &lt;strong&gt;stats&lt;/strong&gt; section:</source>
          <target state="translated">&lt;strong&gt;통계&lt;/strong&gt; 섹션 에있는 모든 필드의 의미는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4bd3033708ea4b8a6d1fbb504db04260b3b5e786" translate="yes" xml:space="preserve">
          <source>Here is the meaning of the fields:</source>
          <target state="translated">필드의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e97f41ad39a769cdba126aa050e98bd0bf28b8b9" translate="yes" xml:space="preserve">
          <source>Here's the default configuration for the default user:</source>
          <target state="translated">기본 사용자에 대한 기본 구성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4d96106a2b4866d88034cf3cbc99a16013a0e36c" translate="yes" xml:space="preserve">
          <source>Hint: it is possible to switch to a different key based on the current Unix time, in this way it is possible to have just a relatively small amount of samples per key, to avoid dealing with very big keys, and to make this pattern more friendly to be distributed across many Redis instances.</source>
          <target state="translated">힌트 : 현재 Unix 시간을 기준으로 다른 키로 전환 할 수 있습니다. 이러한 방식으로 키당 비교적 적은 양의 샘플을 가질 수 있으며, 큰 키를 다루지 않고이 패턴을 더 많이 만들 수 있습니다 많은 Redis 인스턴스에 배포 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90ccd6497400b5576aeca1bd94af74aae1e0a250" translate="yes" xml:space="preserve">
          <source>History</source>
          <target state="translated">History</target>
        </trans-unit>
        <trans-unit id="b51e386256184dc34229a5ca92a34accb7024327" translate="yes" xml:space="preserve">
          <source>How Redis expires keys</source>
          <target state="translated">Redis가 키를 만료하는 방법</target>
        </trans-unit>
        <trans-unit id="e21860bf37328b97ebb0ddd904694c78e4a7b382" translate="yes" xml:space="preserve">
          <source>How does it work?</source>
          <target state="translated">어떻게 작동합니까?</target>
        </trans-unit>
        <trans-unit id="88559343d1f8627b05ed905092ec3f856b6418a7" translate="yes" xml:space="preserve">
          <source>How expires are handled in the replication link and AOF file</source>
          <target state="translated">복제 링크 및 AOF 파일에서 만료가 처리되는 방식</target>
        </trans-unit>
        <trans-unit id="a8dbfaf95083e1d6e63da157f09e95d8c10fa20f" translate="yes" xml:space="preserve">
          <source>How multiple clients blocked on a single stream are served</source>
          <target state="translated">단일 스트림에서 차단 된 여러 클라이언트가 제공되는 방법</target>
        </trans-unit>
        <trans-unit id="d5868df09b7eeb0561970a8e423e96c9ad849dbe" translate="yes" xml:space="preserve">
          <source>How to specify intervals</source>
          <target state="translated">구간을 지정하는 방법</target>
        </trans-unit>
        <trans-unit id="d7cd6ea4777d91cd4768a12501593a68c032c01e" translate="yes" xml:space="preserve">
          <source>However Lua scripts running in Redis 6 or greater, are able to switch to RESP3 mode, and get the replies using the new available types. Similarly Lua scripts are able to reply to clients using the new types. Please make sure to understand &lt;a href=&quot;https://github.com/antirez/resp3&quot;&gt;the capabilities for RESP3&lt;/a&gt; before continuing reading this section.</source>
          <target state="translated">그러나 Redis 6 이상에서 실행되는 Lua 스크립트는 RESP3 모드로 전환 할 수 있으며 사용 가능한 새로운 유형을 사용하여 응답을받을 수 있습니다. 마찬가지로 Lua 스크립트는 새로운 유형을 사용하여 클라이언트에 응답 할 수 있습니다. 이 섹션을 계속 읽기 전에 &lt;a href=&quot;https://github.com/antirez/resp3&quot;&gt;RESP3의 기능&lt;/a&gt; 을 이해 하십시오.</target>
        </trans-unit>
        <trans-unit id="7a00a1128dbff721f5566b479531909bd1900b68" translate="yes" xml:space="preserve">
          <source>However because &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; has very little state associated (just the cursor) it has the following drawbacks:</source>
          <target state="translated">그러나 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 에는 커서와 관련된 상태가 거의 없기 때문에 다음과 같은 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5314787731edc5f7c64fb20d0e8d7d8aa980d1c" translate="yes" xml:space="preserve">
          <source>However if the offset is prefixed with a &lt;code&gt;#&lt;/code&gt; character, the specified offset is multiplied by the integer type width, so for example:</source>
          <target state="translated">그러나 오프셋에 &lt;code&gt;#&lt;/code&gt; 문자 가 접두사로 지정된 경우 지정된 오프셋에 정수 유형 너비가 곱해집니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5cfa667464e115c28334f27e6f622c0e6fc2a1c" translate="yes" xml:space="preserve">
          <source>However in this context the obtained queue is not &lt;em&gt;reliable&lt;/em&gt; as messages can be lost, for example in the case there is a network problem or if the consumer crashes just after the message is received but it is still to process.</source>
          <target state="translated">그러나 이러한 맥락에서 , 예를 들어 네트워크 문제가 있거나 메시지가 수신 된 직후 소비자가 충돌하지만 여전히 처리중인 경우와 같이 메시지가 유실 될 수 있으므로 획득 된 큐는 &lt;em&gt;신뢰할 수&lt;/em&gt; 없습니다 .</target>
        </trans-unit>
        <trans-unit id="32db1099030ce3f6b2493101785b95bdd63b63e3" translate="yes" xml:space="preserve">
          <source>However it returns OK to the caller ASAP, so the &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; command execution is not paused by itself.</source>
          <target state="translated">그러나 호출자에게 OK를 리턴하므로 &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; 명령 실행 자체가 일시 중지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ebc54eeb70e7c4776f4ca626c28b6528713adcd" translate="yes" xml:space="preserve">
          <source>However node hash slots can be in a special state, used in order to communicate errors after a node restart (mismatch between the keys in the AOF/RDB file, and the node hash slots configuration), or when there is a resharding operation in progress. This two states are &lt;strong&gt;importing&lt;/strong&gt; and &lt;strong&gt;migrating&lt;/strong&gt;.</source>
          <target state="translated">그러나 노드 해시 슬롯은 노드를 다시 시작한 후 (AOF / RDB 파일의 키와 노드 해시 슬롯 구성간에 불일치) 오류가 발생하거나 리 샤딩 작업이 진행중인 경우 오류를 전달하기 위해 사용되는 특수 상태 일 수 있습니다. . 이 두 가지 상태는 &lt;strong&gt;가져 오기&lt;/strong&gt; 및 &lt;strong&gt;마이그레이션 중&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="74506a394d8d9a9db887f0b3d8806ba4f46848f4" translate="yes" xml:space="preserve">
          <source>However note that with streams this is not a problem: stream entries are not removed from the stream when clients are served, so every client waiting will be served as soon as an &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; command provides data to the stream.</source>
          <target state="translated">그러나 스트림의 경우 이는 문제가되지 않습니다. 클라이언트가 서비스를 제공 할 때 스트림에서 스트림 항목이 제거되지 않으므로 &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; 명령이 데이터를 스트림에 제공 하는 즉시 대기중인 모든 클라이언트가 서비스됩니다 .</target>
        </trans-unit>
        <trans-unit id="5d5d9fa16c29cdab06e0b69ea5b8063d64e64fa1" translate="yes" xml:space="preserve">
          <source>However note that:</source>
          <target state="translated">그러나 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="c2edee6acbd228e132336d8defe53364f46f07e4" translate="yes" xml:space="preserve">
          <source>However once the data structures are bigger and are promoted to use real hash tables, the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of commands will resort to the normal behavior. Note that since this special behavior of returning all the elements is true only for small aggregates, it has no effects on the command complexity or latency. However the exact limits to get converted into real hash tables are &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;user configurable&lt;/a&gt;, so the maximum number of elements you can see returned in a single call depends on how big an aggregate data type could be and still use the packed representation.</source>
          <target state="translated">그러나 데이터 구조가 더 커지고 실제 해시 테이블을 사용하도록 승격되면 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 명령 계열은 정상적인 동작에 의존합니다. 모든 요소를 ​​반환하는 이러한 특수한 동작은 작은 집계에만 적용되므로 명령 복잡성 또는 대기 시간에는 영향을주지 않습니다. 그러나 실제 해시 테이블로 변환되는 정확한 제한은 &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;사용자가 구성&lt;/a&gt; 할 수 있으므로 한 번의 호출로 반환 될 수있는 최대 요소 수는 집계 데이터 형식의 크기와 패킹 된 표현의 크기에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b21c3d5072091035e19308ba188163eb9b4582ee" translate="yes" xml:space="preserve">
          <source>However starting with Redis 2.8.12 or greater, the command accepts the following form:</source>
          <target state="translated">그러나 Redis 2.8.12 이상으로 시작하면 명령은 다음 형식을 승인합니다.</target>
        </trans-unit>
        <trans-unit id="3d9349e56b3bf2d47d692509fd1873664bc86e71" translate="yes" xml:space="preserve">
          <source>However the command cannot simply drop the node from the internal node table of the node receiving the command, it also implements a ban-list, not allowing the same node to be added again as a side effect of processing the &lt;em&gt;gossip section&lt;/em&gt; of the heartbeat packets received from other nodes.</source>
          <target state="translated">그러나 명령은 단순히 명령을 수신하는 노드의 내부 노드 테이블에서 노드를 삭제할 수 없으며 금지 목록도 구현 하여 하트 비트 패킷 의 &lt;em&gt;가십 섹션&lt;/em&gt; 처리의 부작용으로 동일한 노드를 다시 추가 할 수 없습니다. 다른 노드에서 수신했습니다.</target>
        </trans-unit>
        <trans-unit id="77d71597c94f649040209c65345b9adb784d1ada" translate="yes" xml:space="preserve">
          <source>However the number of returned elements is reasonable, that is, in practical terms SCAN may return a maximum number of elements in the order of a few tens of elements when iterating a large collection, or may return all the elements of the collection in a single call when the iterated collection is small enough to be internally represented as an encoded data structure (this happens for small sets, hashes and sorted sets).</source>
          <target state="translated">그러나 반환 된 요소의 수는 합리적입니다. 즉, 실제 용어로 SCAN은 큰 컬렉션을 반복 할 때 수십 개의 요소 순서로 최대 수의 요소를 반환하거나 컬렉션의 모든 요소를 ​​단일로 반환 할 수 있습니다 반복 된 컬렉션이 내부적으로 인코딩 된 데이터 구조로 표현하기에 충분히 작은 경우 호출합니다 (작은 세트, 해시 및 정렬 된 세트에 대해 발생 함).</target>
        </trans-unit>
        <trans-unit id="4a9bd4d796e3f1d19b335cd4b8d1d2f3544974af" translate="yes" xml:space="preserve">
          <source>However the user can apply a transformation to the encoded string so that the first part of the element inserted in the sorted set will compare as the user requires for the specific application. For example if I want to add strings that will be compared in a case-insensitive way, but I still want to retrieve the real case when querying, I can add strings in the following way:</source>
          <target state="translated">그러나 사용자는 정렬 된 세트에 삽입 된 요소의 첫 번째 부분이 사용자가 특정 응용 프로그램에 필요한대로 비교할 수 있도록 인코딩 된 문자열에 변환을 적용 할 수 있습니다. 예를 들어 대소 문자를 구분하지 않고 비교할 문자열을 추가하고 싶지만 쿼리 할 때 실제 사례를 검색하려면 다음과 같은 방법으로 문자열을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="794f44a2bce77c8dc3d6e6888d73f15fd3089fde" translate="yes" xml:space="preserve">
          <source>However the user is still able to write commands with random behavior using the following simple trick. Imagine I want to write a Redis script that will populate a list with N random integers.</source>
          <target state="translated">그러나 사용자는 다음과 같은 간단한 트릭을 사용하여 임의의 동작으로 명령을 작성할 수 있습니다. N 개의 임의의 정수로 목록을 채울 Redis 스크립트를 작성한다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="fb5b52cca56c4cdd87edf1dfc660cd981c3a9505" translate="yes" xml:space="preserve">
          <source>However there is a way for the user to tune the order of magnitude of the number of returned elements per call using the &lt;strong&gt;COUNT&lt;/strong&gt; option.</source>
          <target state="translated">그러나 사용자는 &lt;strong&gt;COUNT&lt;/strong&gt; 옵션을 사용하여 호출 당 반환되는 요소 수의 크기 순서를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f8f1c30670b30342c4d809208def1afc1fbfd2c" translate="yes" xml:space="preserve">
          <source>However there is an exception to this rule, and it is when a new cluster is created from scratch. Redis Cluster &lt;em&gt;config epoch collision resolution&lt;/em&gt; algorithm can deal with new nodes all configured with the same configuration at startup, but this process is slow and should be the exception, only to make sure that whatever happens, two more nodes eventually always move away from the state of having the same configuration epoch.</source>
          <target state="translated">그러나이 규칙에는 예외가 있으며 새 클러스터가 처음부터 생성 될 때입니다. Redis Cluster &lt;em&gt;구성 에포크 충돌 해결&lt;/em&gt; 알고리즘은 시작시 동일한 구성으로 구성된 모든 새 노드를 처리 할 수 ​​있지만이 프로세스는 느리고 예외가되어야합니다. 동일한 구성 에포크가 있습니다.</target>
        </trans-unit>
        <trans-unit id="142631746a79e235cfed163ccdfe702d6be0326c" translate="yes" xml:space="preserve">
          <source>However this also means that executing slow scripts is not a good idea. It is not hard to create fast scripts, as the script overhead is very low, but if you are going to use slow scripts you should be aware that while the script is running no other client can execute commands.</source>
          <target state="translated">그러나 이것은 또한 느린 스크립트를 실행하는 것이 좋지 않다는 것을 의미합니다. 스크립트 오버 헤드가 매우 낮기 때문에 빠른 스크립트를 작성하는 것은 어렵지 않지만 느린 스크립트를 사용하려는 경우 스크립트가 실행되는 동안 다른 클라이언트가 명령을 실행할 수 없다는 것을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="0a33083c754611907b7f894af6eb43aadc3e4c17" translate="yes" xml:space="preserve">
          <source>However this is a useful feature since, sometimes, we need to execute certain commands only in the master in order to create, for example, intermediate values.</source>
          <target state="translated">그러나 이것은 때때로 중간 값과 같은 특정 값을 생성하기 위해 마스터에서만 특정 명령을 실행해야하기 때문에 유용한 기능입니다.</target>
        </trans-unit>
        <trans-unit id="d0af8abe6ce309a54e5c3abb2294351b6406b863" translate="yes" xml:space="preserve">
          <source>However this is just a best-effort attempt so it is possible to still lose a write synchronously replicated to multiple replicas.</source>
          <target state="translated">그러나 이것은 최선의 노력 일 뿐이므로 여러 복제본에 동기식으로 복제 된 쓰기를 계속 잃을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddd90e4937b6a5514534f2c76508301017283476" translate="yes" xml:space="preserve">
          <source>However trying to execute it again results into an error since the slots are already assigned:</source>
          <target state="translated">그러나 슬롯을 이미 할당 했으므로 다시 실행하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8abb1412bd4f6007eadde6067935f55706c8b96f" translate="yes" xml:space="preserve">
          <source>However using &lt;strong&gt;FORCE&lt;/strong&gt; we still need the majority of masters to be available in order to authorize the failover and generate a new configuration epoch for the replica that is going to become master.</source>
          <target state="translated">그러나 &lt;strong&gt;FORCE&lt;/strong&gt; 를 사용 하면 장애 조치를 승인하고 마스터가 될 복제본에 대한 새로운 구성 에포크를 생성하기 위해 여전히 대부분의 마스터를 사용할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="c681766630e9b93da85df642b31ac53297dab87b" translate="yes" xml:space="preserve">
          <source>However what is often very useful, is to know the match position in each strings:</source>
          <target state="translated">그러나 종종 매우 유용한 것은 각 문자열의 일치 위치를 아는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f7eb54420a392ba9d9fb195f48555b2f9849c4e4" translate="yes" xml:space="preserve">
          <source>However while blocking commands like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; are able to provide all the elements that are part of a Set in a given moment, The SCAN family of commands only offer limited guarantees about the returned elements since the collection that we incrementally iterate can change during the iteration process.</source>
          <target state="translated">그러나 &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; 와 같은 명령을 차단 하면 주어진 순간에 Set의 일부인 모든 요소를 ​​제공 할 수 있지만 , SCAN 명령 계열은 반복 프로세스 중에 점진적으로 반복되는 콜렉션이 변경 될 수 있으므로 리턴 된 요소에 대해 제한된 보증 만 제공합니다. .</target>
        </trans-unit>
        <trans-unit id="8368348c7a15aab35b99bad0b61100388ed947ac" translate="yes" xml:space="preserve">
          <source>However while the replicas connected to a master will not expire keys independently (but will wait for the &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; coming from the master), they'll still take the full state of the expires existing in the dataset, so when a replica is elected to master it will be able to expire the keys independently, fully acting as a master.</source>
          <target state="translated">그러나 마스터에 연결된 복제본은 키를 독립적으로 만료하지 않지만 ( 마스터에서 &lt;a href=&quot;del&quot;&gt;DEL이&lt;/a&gt; 올 때까지 기다릴 것임 ) 여전히 데이터 세트에 존재하는 만료의 전체 상태를 유지하므로 복제본이 마스터로 선택 될 때 마스터 역할을하며 키를 독립적으로 만료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7564bd1b123b79267215f60720a7ba2c7d0f2a4" translate="yes" xml:space="preserve">
          <source>However, note that:</source>
          <target state="translated">그러나 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="ae8b2a13bc4ae56dbd4d97a2490048eefaa8824d" translate="yes" xml:space="preserve">
          <source>However, this behavior changes if you are looking for clear bits and specify a range with both &lt;strong&gt;start&lt;/strong&gt; and &lt;strong&gt;end&lt;/strong&gt;. If no clear bit is found in the specified range, the function returns -1 as the user specified a clear range and there are no 0 bits in that range.</source>
          <target state="translated">그러나 명확한 비트를 찾고 &lt;strong&gt;start&lt;/strong&gt; 및 &lt;strong&gt;end&lt;/strong&gt; 모두 범위를 지정하면이 동작이 변경됩니다 . 지정된 범위에서 클리어 비트가 발견되지 않으면 사용자가 클리어 범위를 지정하고 해당 범위에 0 비트가없는 경우이 함수는 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="078d1434700af53deba94cb889757980e4b68051" translate="yes" xml:space="preserve">
          <source>Humans may use this command in order to check what is the hash slot, and then the associated Redis Cluster node, responsible for a given key.</source>
          <target state="translated">사용자는이 명령을 사용하여 해시 슬롯이 무엇인지 확인한 다음 지정된 키를 담당하는 관련 Redis 클러스터 노드를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d68bb5655889a7436b2eff6315d03293170f63d0" translate="yes" xml:space="preserve">
          <source>HyperLogLog</source>
          <target state="translated">HyperLogLog</target>
        </trans-unit>
        <trans-unit id="58b5c100f0d44808f0dbfcc3722f78c2d81f1aaf" translate="yes" xml:space="preserve">
          <source>HyperLogLog representation</source>
          <target state="translated">HyperLogLog 표현</target>
        </trans-unit>
        <trans-unit id="28c10e9d5a5781ed8d9e57c706ceb5a1dd97ff5f" translate="yes" xml:space="preserve">
          <source>I can start with this small Ruby program:</source>
          <target state="translated">이 작은 루비 프로그램으로 시작할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5188851d79e499077ff8c17718081d6a2d5d7980" translate="yes" xml:space="preserve">
          <source>IDs are guaranteed to be always incremental: If you compare the ID of the entry just inserted it will be greater than any other past ID, so entries are totally ordered inside a stream. In order to guarantee this property, if the current top ID in the stream has a time greater than the current local time of the instance, the top entry time will be used instead, and the sequence part of the ID incremented. This may happen when, for instance, the local clock jumps backward, or if after a failover the new master has a different absolute time.</source>
          <target state="translated">ID는 항상 증분으로 보장됩니다. 방금 삽입 한 항목의 ID를 비교하면 다른 과거 ID보다 커지므로 항목은 스트림 내부에서 완전히 정렬됩니다. 이 속성을 보장하기 위해 스트림의 현재 최상위 ID가 인스턴스의 현재 현지 시간보다 큰 시간을 갖는 경우 대신 상위 진입 시간이 사용되고 ID의 시퀀스 부분이 증가합니다. 예를 들어, 로컬 시계가 뒤로 이동하거나 장애 조치 후 새 마스터의 절대 시간이 다른 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0f8745b1bebe7ddae3a87f4efc1207e5b87a40b" translate="yes" xml:space="preserve">
          <source>IDs are specified by two numbers separated by a &lt;code&gt;-&lt;/code&gt; character:</source>
          <target state="translated">ID는 &lt;code&gt;-&lt;/code&gt; 문자로 구분 된 두 개의 숫자로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="70aab9650acd50b2b8e1776f69b86b88bbbe99e5" translate="yes" xml:space="preserve">
          <source>INCR</source>
          <target state="translated">INCR</target>
        </trans-unit>
        <trans-unit id="c59620ba3e9207aaf8fb1bf70e412a9caa358cb2" translate="yes" xml:space="preserve">
          <source>INCR  key   Increment the integer value of a key by one</source>
          <target state="translated">INCR 키 키의 정수 값을 1 씩 증가시킵니다</target>
        </trans-unit>
        <trans-unit id="af14b6096425a1f909b7628ce8491716c2d581ba" translate="yes" xml:space="preserve">
          <source>INCRBY</source>
          <target state="translated">INCRBY</target>
        </trans-unit>
        <trans-unit id="9ab1bc6a3a0563b50a9e4bcb930106db12e2ae4e" translate="yes" xml:space="preserve">
          <source>INCRBY  key increment   Increment the integer value of a key by the given amount</source>
          <target state="translated">INCRBY 키 증가 주어진 양만큼 키의 정수 값을 증가시킵니다</target>
        </trans-unit>
        <trans-unit id="769650b0192d046cb68b526ab27d41d927ea5cc8" translate="yes" xml:space="preserve">
          <source>INCRBYFLOAT</source>
          <target state="translated">INCRBYFLOAT</target>
        </trans-unit>
        <trans-unit id="2e3bba4aaf8bd64291b4999ea2633e1cde536fe3" translate="yes" xml:space="preserve">
          <source>INCRBYFLOAT  key increment   Increment the float value of a key by the given amount</source>
          <target state="translated">INCRBYFLOAT 키 증가 지정된 양만큼 키의 부동 소수점 값을 증가시킵니다</target>
        </trans-unit>
        <trans-unit id="9c9cf999829193894067bbd9e1484756ab736ac0" translate="yes" xml:space="preserve">
          <source>INFO</source>
          <target state="translated">INFO</target>
        </trans-unit>
        <trans-unit id="42089cfb2067d721afeae473b5079898e863248e" translate="yes" xml:space="preserve">
          <source>INFO  [section]   Get information and statistics about the server</source>
          <target state="translated">INFO [섹션] 서버에 대한 정보 및 통계를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="fc967bd2cc1b3485f1ee6c3bccb3832c0009ded5" translate="yes" xml:space="preserve">
          <source>Ideally, the &lt;code&gt;used_memory_rss&lt;/code&gt; value should be only slightly higher than &lt;code&gt;used_memory&lt;/code&gt;. When rss &amp;gt;&amp;gt; used, a large difference means there is memory fragmentation (internal or external), which can be evaluated by checking &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt;. When used &amp;gt;&amp;gt; rss, it means part of Redis memory has been swapped off by the operating system: expect some significant latencies.</source>
          <target state="translated">이상적으로는 &lt;code&gt;used_memory_rss&lt;/code&gt; 값은 &lt;code&gt;used_memory&lt;/code&gt; 보다 약간 더 높아야 합니다. rss &amp;gt;&amp;gt;가 사용될 때 큰 차이는 메모리 조각화 (내부 또는 외부)가 있음을 의미하며 &lt;code&gt;mem_fragmentation_ratio&lt;/code&gt; 를 확인하여 평가할 수 있습니다 . &amp;gt;&amp;gt; rss를 사용하면 운영 체제에서 Redis 메모리의 일부가 교체되었음을 의미합니다. 상당한 대기 시간이 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="73b4eda93b2219c5cea27cedcc70f71581e15c99" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; fails, no data gets lost as the old AOF will be untouched.</source>
          <target state="translated">경우 &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF이&lt;/a&gt; 실패 이전 AOF는 그대로 바와 같이, 데이터가 손실되지됩니다.</target>
        </trans-unit>
        <trans-unit id="1d20f361447b1eebe4e4808ffc994e347a4065d3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; returns &lt;code&gt;0&lt;/code&gt; the key is already locked by some other client. We can either return to the caller if it's a non blocking lock, or enter a loop retrying to hold the lock until we succeed or some kind of timeout expires.</source>
          <target state="translated">&lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; 가 &lt;code&gt;0&lt;/code&gt; 을 반환 하면 다른 클라이언트에 의해 키가 이미 잠겨있는 것입니다. 비 차단 잠금 인 경우 호출자에게 돌아가거나 성공하거나 일정 시간이 초과 될 때까지 잠금을 유지하기 위해 다시 시도하는 루프를 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2860996021d578f69065139684f5cafa8d2519b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; returns &lt;code&gt;1&lt;/code&gt; the client acquired the lock, setting the &lt;code&gt;lock.foo&lt;/code&gt; key to the Unix time at which the lock should no longer be considered valid. The client will later use &lt;code&gt;DEL lock.foo&lt;/code&gt; in order to release the lock.</source>
          <target state="translated">경우 &lt;a href=&quot;setnx&quot;&gt;SETNX가&lt;/a&gt; 반환 &lt;code&gt;1&lt;/code&gt; 클라이언트가 설정 잠금을 획득 &lt;code&gt;lock.foo&lt;/code&gt; 의 잠금이 더 이상 유효한 것으로 간주되어서는 안되는 유닉스 시간에 키를 누릅니다. 클라이언트는 나중에 잠금을 해제하기 위해 &lt;code&gt;DEL lock.foo&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="a5eee6810815d94e86b03260de66be0feb7ce88c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;watch&quot;&gt;WATCH&lt;/a&gt; was used, &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt; unwatches all keys watched by the connection.</source>
          <target state="translated">경우 &lt;a href=&quot;watch&quot;&gt;시계가&lt;/a&gt; 사용되었다 &lt;a href=&quot;discard&quot;&gt;DISCARD는&lt;/a&gt; 연결에 의해 감시 모든 키를 unwatches.</target>
        </trans-unit>
        <trans-unit id="db30f622717bd53f660e926c446f65281d373325" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BGSAVE SCHEDULE&lt;/code&gt; is used, the command will immediately return &lt;code&gt;OK&lt;/code&gt; when an AOF rewrite is in progress and schedule the background save to run at the next opportunity.</source>
          <target state="translated">경우 &lt;code&gt;BGSAVE SCHEDULE&lt;/code&gt; 사용되며,이 명령은 즉시 반환됩니다 &lt;code&gt;OK&lt;/code&gt; AOF 재 작성이 진행 중일 때 다음 기회에 실행에 저장 배경을 예약합니다.</target>
        </trans-unit>
        <trans-unit id="20ed44b2bda4227d511c46587683f47a00d993b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WITHCOORD&lt;/code&gt;, &lt;code&gt;WITHDIST&lt;/code&gt; or &lt;code&gt;WITHHASH&lt;/code&gt; options are specified, the command returns an array of arrays, where each sub-array represents a single item.</source>
          <target state="translated">경우 &lt;code&gt;WITHCOORD&lt;/code&gt; , &lt;code&gt;WITHDIST&lt;/code&gt; 또는 &lt;code&gt;WITHHASH&lt;/code&gt; 옵션을 지정하는 명령은 각각의 하위 배열은 하나의 항목을 나타내는 배열의 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="73dfe5f15062ceece61a6acc3449e57743eeff88" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;destination&lt;/code&gt; already exists, it is overwritten.</source>
          <target state="translated">경우 &lt;code&gt;destination&lt;/code&gt; 이미 존재, 그것은 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="ec00a71247f51a83461ff727be4fdc2a9b8eef53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; already exists and is a string, this command appends the &lt;code&gt;value&lt;/code&gt; at the end of the string. If &lt;code&gt;key&lt;/code&gt; does not exist it is created and set as an empty string, so &lt;a href=&quot;append&quot;&gt;APPEND&lt;/a&gt; will be similar to &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; in this special case.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 이미 문자열을 존재이며,이 명령은 추가 &lt;code&gt;value&lt;/code&gt; 문자열의 끝을. &lt;code&gt;key&lt;/code&gt; 가 존재하지 않으면 키 가 생성되어 빈 문자열로 설정 &lt;a href=&quot;append&quot;&gt;되므로이&lt;/a&gt; 특별한 경우 APPEND 는 &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="f65de86e658742c07d7bc6102da39df199a9b701" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist a nil bulk reply is returned.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는 전무 대량 응답이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bd4417fe5a7c2042f71015b09d46b92838be30fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; does not exist, a new sorted set with the specified members as sole members is created, like if the sorted set was empty. If the key exists but does not hold a sorted set, an error is returned.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는 소트 세트가 비어있는 경우처럼, 유일한 구성원으로 지정된 회원들과 새로운 소트 세트가 생성됩니다. 키가 있지만 정렬 된 세트를 보유하지 않으면 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e64662be889ce64c17aaa1cc9189ce3256310f93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set or &lt;code&gt;key&lt;/code&gt; does not exist, &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;: &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;member&lt;/code&gt; 정렬 된 세트 또는 존재하지 않는 &lt;code&gt;key&lt;/code&gt; , 존재하지 않는 &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량의 문자열 회신&lt;/a&gt; : &lt;code&gt;nil&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f23ea3c8266e3f5959aed27b93602e9cafb796f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set, or &lt;code&gt;key&lt;/code&gt; does not exist, &lt;code&gt;nil&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;member&lt;/code&gt; 정렬 된 세트에 존재하지 않는, 또는 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, &lt;code&gt;nil&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1e3e9eec1dfb85dde46f12f033df8c95cb570dc1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;member&lt;/code&gt; exists in the sorted set, &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;Integer reply&lt;/a&gt;: the rank of &lt;code&gt;member&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;member&lt;/code&gt; 가 정렬 된 세트에 존재 하면 &lt;a href=&quot;https://redis.io/topics/protocol#integer-reply&quot;&gt;정수 응답&lt;/a&gt; : &lt;code&gt;member&lt;/code&gt; 순위입니다 .</target>
        </trans-unit>
        <trans-unit id="b0602d8252b35c86b3177857f428ef2b6ebe2844" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;password&lt;/code&gt; matches the password in the configuration file, the server replies with the &lt;code&gt;OK&lt;/code&gt; status code and starts accepting commands. Otherwise, an error is returned and the clients needs to try a new password.</source>
          <target state="translated">경우 &lt;code&gt;password&lt;/code&gt; 구성 파일의 암호와 일치, 서버에 응답 &lt;code&gt;OK&lt;/code&gt; 의 상태 코드 및 시작 명령을 수용. 그렇지 않으면 오류가 리턴되고 클라이언트는 새 비밀번호를 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="25efaee0f3cfe5471248ed210126224686506e29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; does not exist, the value &lt;code&gt;nil&lt;/code&gt; is returned and no operation is performed. If &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are the same, the operation is equivalent to removing the first/last element from the list and pushing it as first/last element of the list, so it can be considered as a list rotation command (or a no-op if &lt;code&gt;wherefrom&lt;/code&gt; is the same as &lt;code&gt;whereto&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;source&lt;/code&gt; 존재하지 않는 값 &lt;code&gt;nil&lt;/code&gt; 반환 아무 작업이 수행되지 않습니다. 경우 &lt;code&gt;source&lt;/code&gt; 및 &lt;code&gt;destination&lt;/code&gt; 동일한이리스트 회전 명령 (또는 비 협동으로 고려 될 수 있도록, 동작은리스트로부터 제 / 마지막 요소를 제거하고,리스트의 첫번째 / 마지막 요소로 밀어 동등 만약 &lt;code&gt;wherefrom&lt;/code&gt; 는 동일하다 &lt;code&gt;whereto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d8a36f67086d264992352bae73959a976d08f592" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source&lt;/code&gt; does not exist, the value &lt;code&gt;nil&lt;/code&gt; is returned and no operation is performed. If &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt; are the same, the operation is equivalent to removing the last element from the list and pushing it as first element of the list, so it can be considered as a list rotation command.</source>
          <target state="translated">경우 &lt;code&gt;source&lt;/code&gt; 존재하지 않는 값 &lt;code&gt;nil&lt;/code&gt; 반환 아무 작업이 수행되지 않습니다. 경우 &lt;code&gt;source&lt;/code&gt; 및 &lt;code&gt;destination&lt;/code&gt; 동일한 작업이 목록에서 마지막 한 요소를 제거하고리스트의 첫 번째 요소로 추진에 상당하므로이리스트 회전 명령으로 간주 될 수있다.</target>
        </trans-unit>
        <trans-unit id="5b26bcfdadbb106d42a10a68f68adf4977b43380" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ttl&lt;/code&gt; is 0 the key is created without any expire, otherwise the specified expire time (in milliseconds) is set.</source>
          <target state="translated">경우 &lt;code&gt;ttl&lt;/code&gt; 0 어떤이 만료없이 키가 달리 지정, 작성은 시간 (밀리 초) 설정을 만료됩니다.</target>
        </trans-unit>
        <trans-unit id="2c1e9f5fc6b657f9746f093601d0e06e3be8a993" translate="yes" xml:space="preserve">
          <source>If AOF is activated, these additional fields will be added:</source>
          <target state="translated">AOF가 활성화되면 다음과 같은 추가 필드가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3a074c9af49d118ca170e19c962a9318fe91cfe4" translate="yes" xml:space="preserve">
          <source>If a Redis 6.0 instance, or greater, is using the &lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;Redis ACL system&lt;/a&gt;.</source>
          <target state="translated">Redis 6.0 인스턴스 이상이 &lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;Redis ACL 시스템을&lt;/a&gt; 사용하는 경우 .</target>
        </trans-unit>
        <trans-unit id="52fb5f5179b2d79edc8c3b551f845f186e716372" translate="yes" xml:space="preserve">
          <source>If a Redis child is creating a snapshot on disk, the AOF rewrite is &lt;em&gt;scheduled&lt;/em&gt; but not started until the saving child producing the RDB file terminates. In this case the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; will still return an OK code, but with an appropriate message. You can check if an AOF rewrite is scheduled looking at the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command as of Redis 2.6.</source>
          <target state="translated">Redis 하위가 디스크에서 스냅 샷을 작성하는 경우 AOF 재 작성이 &lt;em&gt;예약&lt;/em&gt; 되지만 RDB 파일을 생성하는 저장 하위가 종료 될 때까지 AOF 재 작성이 시작됩니다. 이 경우 &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; 는 여전히 OK 코드를 반환하지만 적절한 메시지가 표시됩니다. Redis 2.6 부터 &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 명령을 보고 AOF 다시 쓰기가 예약되어 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a26aac34716b82962d62dd7eb321e26db471b019" translate="yes" xml:space="preserve">
          <source>If a Redis child is creating a snapshot on disk, the AOF rewrite is &lt;em&gt;scheduled&lt;/em&gt; but not started until the saving child producing the RDB file terminates. In this case the &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; will still return an positive status reply, but with an appropriate message. You can check if an AOF rewrite is scheduled looking at the &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; command as of Redis 2.6 or successive versions.</source>
          <target state="translated">Redis 하위가 디스크에 스냅 샷을 생성하는 경우 AOF 재 작성이 &lt;em&gt;예약&lt;/em&gt; 되지만 RDB 파일을 생성하는 저장 하위가 종료 될 때까지 시작되지 않습니다. 이 경우 &lt;a href=&quot;bgrewriteaof&quot;&gt;BGREWRITEAOF&lt;/a&gt; 는 여전히 긍정적 인 상태 응답을 반환하지만 적절한 메시지를 표시합니다. Redis 2.6 또는 후속 버전 에서 &lt;a href=&quot;info&quot;&gt;INFO&lt;/a&gt; 명령을 보면 AOF 재 작성이 예약되어 있는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7fab76e64c7a99cf5ff09d3faf8bcf4e7b29c3b9" translate="yes" xml:space="preserve">
          <source>If a Redis server is already acting as replica, the command &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE will turn off the replication, turning the Redis server into a MASTER. In the proper form &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port will make the server a replica of another server listening at the specified hostname and port.</source>
          <target state="translated">Redis 서버가 이미 복제본으로 작동하는 경우 &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; NO ONE 명령 은 복제를 끄고 Redis 서버를 MASTER로 전환합니다. 올바른 형식으로 &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; 호스트 이름 포트는 서버를 지정된 호스트 이름 및 포트에서 수신 대기하는 다른 서버의 복제본으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6bba5cc9a8544de84799044ff9489eaddadc2beb" translate="yes" xml:space="preserve">
          <source>If a SYNC operation is on-going, these additional fields are provided:</source>
          <target state="translated">SYNC 작업이 진행중인 경우 다음과 같은 추가 필드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b39dab88e7088d47355746e00cd5a3b16aea36b7" translate="yes" xml:space="preserve">
          <source>If a cluster instance has non-contiguous slots (e.g. 1-400,900,1800-6000) then master and replica IP/Port results will be duplicated for each top-level slot range reply.</source>
          <target state="translated">클러스터 인스턴스에 비 연속 슬롯이있는 경우 (예 : 1-400,900,1800-6000) 마스터 및 복제 IP / 포트 결과는 각 최상위 슬롯 범위 응답에 대해 복제됩니다.</target>
        </trans-unit>
        <trans-unit id="59220272c64271f85f1f97cc7691835ad64c2de3" translate="yes" xml:space="preserve">
          <source>If a command accepts an unlimited number of keys, the last key position is -1.</source>
          <target state="translated">명령이 무제한의 키를 허용하면 마지막 키 위치는 -1입니다.</target>
        </trans-unit>
        <trans-unit id="140a2742270e0d194dfebacb6a9c7a4820592aff" translate="yes" xml:space="preserve">
          <source>If a command accepts one key, the first key and last key positions is 1.</source>
          <target state="translated">명령이 하나의 키를 허용하면 첫 번째 키와 마지막 키 위치는 1입니다.</target>
        </trans-unit>
        <trans-unit id="c31655fb4face26cd02e88dd6486f34dd31bb51e" translate="yes" xml:space="preserve">
          <source>If a command accepts two keys (e.g. &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt;, &lt;a href=&quot;smove&quot;&gt;SMOVE&lt;/a&gt;, &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, ...) then the last key position is the location of the last key in the argument list.</source>
          <target state="translated">명령이 두 개의 키 (예 : &lt;a href=&quot;brpoplpush&quot;&gt;BRPOPLPUSH&lt;/a&gt; , &lt;a href=&quot;smove&quot;&gt;SMOVE&lt;/a&gt; , &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; 등)를 허용하면 마지막 키 위치는 인수 목록에서 마지막 키의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="610d9883b3ed9e5bbf61e781dfb38f2ca5532e85" translate="yes" xml:space="preserve">
          <source>If a command is received about a key that does not exists, an &lt;code&gt;ASK&lt;/code&gt; redirection is emitted by the node, asking the client to retry only that specific query into &lt;code&gt;destination-node&lt;/code&gt;. In this case the client should not update its hash slot to node mapping.</source>
          <target state="translated">존재하지 않는 키에 대한 명령이 수신되면 , 클라이언트는 해당 특정 쿼리 만 &lt;code&gt;destination-node&lt;/code&gt; 로 재 시도하도록 요청하여 &lt;code&gt;ASK&lt;/code&gt; 경로 재 지정이 노드에 의해 생성됩니다 . 이 경우 클라이언트는 해시 슬롯을 노드 매핑으로 업데이트하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="adc3a75aac4d6b35ed7b12ce05235e4cc640c05b" translate="yes" xml:space="preserve">
          <source>If a command is received about an existing key, the command is processed as usually.</source>
          <target state="translated">기존 키에 대한 명령이 수신되면 명령이 일반적으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="a64d2ec3bb10e34eb579070274923657d7138a2a" translate="yes" xml:space="preserve">
          <source>If a key is overwritten by &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, like in the case of an existing key &lt;code&gt;Key_A&lt;/code&gt; that is overwritten by a call like &lt;code&gt;RENAME Key_B Key_A&lt;/code&gt;, it does not matter if the original &lt;code&gt;Key_A&lt;/code&gt; had a timeout associated or not, the new key &lt;code&gt;Key_A&lt;/code&gt; will inherit all the characteristics of &lt;code&gt;Key_B&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;RENAME Key_B Key_A&lt;/code&gt; 와 같은 호출로 덮어 쓰는 기존 키 &lt;code&gt;Key_A&lt;/code&gt; 의 경우처럼 &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; 이 키를 덮어 쓰면 원래 &lt;code&gt;Key_A&lt;/code&gt; 에 시간 초과가 발생했는지 여부는 중요하지 않습니다 . 새 키 &lt;code&gt;Key_A&lt;/code&gt; 는 모두 특성 &lt;code&gt;Key_B&lt;/code&gt; 와 .</target>
        </trans-unit>
        <trans-unit id="0360f4a1e3e37b28bbc1c81856843472bd113d44" translate="yes" xml:space="preserve">
          <source>If a key is renamed with &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt;, the associated time to live is transferred to the new key name.</source>
          <target state="translated">키의 이름이 &lt;a href=&quot;rename&quot;&gt;RENAME&lt;/a&gt; 으로 바뀌면 연관된 사용 시간이 새 키 이름으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="dba073505eef52f13e35c2d2b072e15bc497f1c3" translate="yes" xml:space="preserve">
          <source>If a load operation is on-going, these additional fields will be added:</source>
          <target state="translated">로드 조작이 진행중인 경우 다음 추가 필드가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a8036cb18b462f0b09c70d787c53e11501cfbc97" translate="yes" xml:space="preserve">
          <source>If a node with unbound hash slots receives a heartbeat packet from another node that claims to be the owner of some of those hash slots, the association is established instantly. Moreover, if a heartbeat or update message is received with a configuration epoch greater than the node's own, the association is re-established.</source>
          <target state="translated">바인딩되지 않은 해시 슬롯이있는 노드가 다른 해시 슬롯에서 해당 해시 슬롯의 소유자라고 주장하는 하트 비트 패킷을 수신하면 연결이 즉시 설정됩니다. 또한 노드 자체보다 큰 구성 에포크가있는 하트 비트 또는 업데이트 메시지가 수신되면 연결이 다시 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e6947348d36ca3b7d6ec64b0d3d493bff74f2cca" translate="yes" xml:space="preserve">
          <source>If a server is already a replica of some master, &lt;a href=&quot;replicaof&quot;&gt;REPLICAOF&lt;/a&gt; hostname port will stop the replication against the old server and start the synchronization against the new one, discarding the old dataset.</source>
          <target state="translated">서버가 이미 일부 마스터의 복제 &lt;a href=&quot;replicaof&quot;&gt;본인&lt;/a&gt; 경우 REPLICAOF 호스트 이름 포트는 이전 서버에 대한 복제를 중지하고 새 서버에 대한 동기화를 시작하여 이전 데이터 세트를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="8355cef42438c57bf29e119daff3edf69a2eafac" translate="yes" xml:space="preserve">
          <source>If a server is already a replica of some master, &lt;a href=&quot;slaveof&quot;&gt;SLAVEOF&lt;/a&gt; hostname port will stop the replication against the old server and start the synchronization against the new one, discarding the old dataset.</source>
          <target state="translated">서버가 이미 일부 마스터의 복제 &lt;a href=&quot;slaveof&quot;&gt;본인&lt;/a&gt; 경우 SLAVEOF 호스트 이름 포트는 이전 서버에 대한 복제를 중지하고 새 서버에 대한 동기화를 시작하여 이전 데이터 세트를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="796f8c82d2cb3bc6674d519060d62df76a47b5cf" translate="yes" xml:space="preserve">
          <source>If an AOF rewrite is already in progress the command returns an error and no AOF rewrite will be scheduled for a later time.</source>
          <target state="translated">AOF 다시 쓰기가 이미 진행 중이면 명령이 오류를 반환하고 나중에 AOF 다시 쓰기가 예약되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa95f2ff011f2ee3af55365c22aa9caf33f28db8" translate="yes" xml:space="preserve">
          <source>If an option already exists in the old redis.conf file, it will be rewritten at the same position (line number).</source>
          <target state="translated">이전 redis.conf 파일에 옵션이 이미 있으면 같은 위치 (행 번호)에 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="4658daabd5c918d6c9d2de1223a7f5eb6d9fd842" translate="yes" xml:space="preserve">
          <source>If an option was not already present, but it is set to a non-default value, it is appended at the end of the file.</source>
          <target state="translated">옵션이 아직 없지만 기본값이 아닌 값으로 설정되어 있으면 파일 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e4228aca6b611c430e003ee894c91eb30a1b6cd7" translate="yes" xml:space="preserve">
          <source>If an option was not already present, but it is set to its default value, it is not added by the rewrite process.</source>
          <target state="translated">옵션이 아직 없지만 기본값으로 설정되어 있으면 다시 쓰기 프로세스에 의해 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b63f671253761bdf3174af266654497deb63ef4b" translate="yes" xml:space="preserve">
          <source>If another client, for instance C5, was faster than C4 and acquired the lock with the &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; operation, the C4 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; operation will return a non expired timestamp. C4 will simply restart from the first step. Note that even if C4 set the key a bit a few seconds in the future this is not a problem.</source>
          <target state="translated">다른 클라이언트 (예 : C5)가 C4보다 빠르고 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; 조작으로 잠금을 획득 한 경우 C4 &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt; 조작은 만료되지 않은 시간 소인을 리턴합니다. C4는 첫 번째 단계부터 다시 시작합니다. C4가 앞으로 몇 초 동안 키를 약간 설정하더라도 이것은 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37cf40db32d54ae3579f3237037ff5c92145f193" translate="yes" xml:space="preserve">
          <source>If at a given time a node has another node flagged with &lt;code&gt;PFAIL&lt;/code&gt;, and at the same time collected the majority of other master nodes &lt;em&gt;failure reports&lt;/em&gt; about this node (including itself if it is a master), then it elevates the failure state of the node from &lt;code&gt;PFAIL&lt;/code&gt; to &lt;code&gt;FAIL&lt;/code&gt;, and broadcasts a message forcing all the nodes that can be reached to flag the node as &lt;code&gt;FAIL&lt;/code&gt;.</source>
          <target state="translated">주어진 시간에 노드에 &lt;code&gt;PFAIL&lt;/code&gt; 으로 플래그가 지정된 다른 노드가 있고 동시에이 노드에 대한 대부분의 다른 마스터 노드 &lt;em&gt;실패 보고서&lt;/em&gt; (마스터 인 경우 포함)를 수집하면 노드 의 실패 상태가 높아집니다 에서 &lt;code&gt;PFAIL&lt;/code&gt; 에 &lt;code&gt;FAIL&lt;/code&gt; , 브로드 캐스트 플래그로 노드에 도달 할 수있는 모든 노드 강제 메시지 &lt;code&gt;FAIL&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="5f5470ee8997d2330c4f1d3cb52035e4a73f57ce" translate="yes" xml:space="preserve">
          <source>If count is bigger than the number of elements inside the Set, the command will only return the whole set without additional elements.</source>
          <target state="translated">개수가 세트 내의 요소 수보다 큰 경우 명령은 추가 요소없이 전체 세트 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b7b84ded8883c2f1d689aced4377969210247451" translate="yes" xml:space="preserve">
          <source>If every line in the file is valid, all the ACLs are loaded.</source>
          <target state="translated">파일의 모든 행이 유효하면 모든 ACL이로드됩니다.</target>
        </trans-unit>
        <trans-unit id="7166a4c2e9e0a7b189fdf30ab0234c6d47986ab4" translate="yes" xml:space="preserve">
          <source>If instead the message was already delivered to this consumer, and it is just re-fetching the same message again, then the &lt;em&gt;last delivery counter&lt;/em&gt; is updated to the current time, and the &lt;em&gt;number of deliveries&lt;/em&gt; is incremented by one. You can access those message properties using the &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; command.</source>
          <target state="translated">대신이 메시지가 이미이 소비자에게 배달되었고 동일한 메시지를 다시 가져 오는 경우 &lt;em&gt;마지막 배달 카운터&lt;/em&gt; 가 현재 시간으로 업데이트되고 &lt;em&gt;배달 &lt;/em&gt;&lt;em&gt;수가&lt;/em&gt; 1 씩 증가합니다. &lt;a href=&quot;xpending&quot;&gt;XPENDING&lt;/a&gt; 명령을 사용하여 해당 메시지 특성에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5eb7b53c8c56d77ba922276fcf8d6fc9a5555deb" translate="yes" xml:space="preserve">
          <source>If instead you want consumers to fetch the whole stream history, use zero as the starting ID for the consumer group:</source>
          <target state="translated">대신 소비자가 전체 스트림 히스토리를 가져 오도록하려면 소비자 그룹의 시작 ID로 0을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="766551fe9e9ea8009a726c50e78e04cbf000fc57" translate="yes" xml:space="preserve">
          <source>If more than 25% of keys were expired, start again from step 1.</source>
          <target state="translated">키의 25 % 이상이 만료 된 경우 1 단계부터 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="18ba579c412c6a80f5484abbbc6da80390ec5935" translate="yes" xml:space="preserve">
          <source>If multiple clients are blocked for the same key, the first client to be served is the one that was waiting for more time (the first that blocked for the key). Once a client is unblocked it does not retain any priority, when it blocks again with the next call to &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; it will be served accordingly to the number of clients already blocked for the same key, that will all be served before it (from the first to the last that blocked).</source>
          <target state="translated">동일한 키에 대해 여러 클라이언트가 차단 된 경우 가장 먼저 제공되는 클라이언트는 더 많은 시간 동안 대기 한 클라이언트입니다 (첫 번째는 키를 차단 한 클라이언트). 클라이언트가 차단 해제되면 우선 순위를 유지하지 않고 다음 번 &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; 호출로 다시 차단하면 동일한 키에 대해 이미 차단 된 클라이언트 수에 따라 서비스가 제공됩니다. 마지막으로 차단).</target>
        </trans-unit>
        <trans-unit id="2d45448e42846cf1223f90529d7153a4f2ea7d57" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;pattern&lt;/code&gt; is specified, all the channels are listed, otherwise if pattern is specified only channels matching the specified glob-style pattern are listed.</source>
          <target state="translated">&lt;code&gt;pattern&lt;/code&gt; 을 지정 하지 않으면 모든 채널이 나열되고, 그렇지 않으면 패턴이 지정된 경우 지정된 glob 스타일 패턴과 일치하는 채널 만 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="ea2697ae6fd039b4a66dbcb2f98b8550bd0df116" translate="yes" xml:space="preserve">
          <source>If no reset type is specified, the default is &lt;strong&gt;soft&lt;/strong&gt;.</source>
          <target state="translated">재설정 유형을 지정하지 않으면 기본값은 &lt;strong&gt;soft&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7a5e1cf1e0228d3ddab066d68bd268b73f915f6a" translate="yes" xml:space="preserve">
          <source>If none of the specified keys exist, &lt;a href=&quot;blpop&quot;&gt;BLPOP&lt;/a&gt; blocks the connection until another client performs an &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; or &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; operation against one of the keys.</source>
          <target state="translated">지정된 키가 &lt;a href=&quot;blpop&quot;&gt;없으면 BLPOP&lt;/a&gt; 는 다른 클라이언트 가 키 중 하나에 대해 &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; 또는 &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; 작업을 수행 할 때까지 연결을 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="dfae9157f2f024976d442ab776949fdf1b2e1598" translate="yes" xml:space="preserve">
          <source>If one or both the members are missing, the command returns NULL.</source>
          <target state="translated">멤버 중 하나 또는 둘 다가 없으면 명령은 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="65c7882ecd3026e90538dbca3412ed2c9efa54bf" translate="yes" xml:space="preserve">
          <source>If one or more line in the file is not valid, nothing is loaded, and the old ACL rules defined in the server memory continue to be used.</source>
          <target state="translated">파일에서 하나 이상의 행이 유효하지 않으면 아무 것도로드되지 않으며 서버 메모리에 정의 된 이전 ACL 규칙이 계속 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4eccea0e4c99dbf5582f258e7eec112ee8e36e5c" translate="yes" xml:space="preserve">
          <source>If persistence is enabled this commands makes sure that Redis is switched off without the lost of any data. This is not guaranteed if the client uses simply &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; and then &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; because other clients may alter the DB data between the two commands.</source>
          <target state="translated">지속성이 활성화 된 경우이 명령은 데이터 손실없이 Redis가 꺼져 있는지 확인합니다. 다른 클라이언트가 두 명령 사이에서 DB 데이터를 변경할 수 있기 때문에 클라이언트가 단순히 &lt;a href=&quot;save&quot;&gt;SAVE&lt;/a&gt; 를 사용한 다음 &lt;a href=&quot;quit&quot;&gt;QUIT을&lt;/a&gt; 사용하는 경우에는 이것이 보장되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3c4893d742c042232e8b2da1b66fa8109b95fc06" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; option is specified, the return value will be &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;Bulk string reply&lt;/a&gt;:</source>
          <target state="translated">경우 &lt;a href=&quot;incr&quot;&gt;INCR의&lt;/a&gt; 옵션을 지정, 반환 값은 &lt;a href=&quot;https://redis.io/topics/protocol#bulk-string-reply&quot;&gt;대량 문자열 응답&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5342c7f917832f9f61b997cae89d595cc203017d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ABSTTL&lt;/code&gt; modifier was used, &lt;code&gt;ttl&lt;/code&gt; should represent an absolute &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;Unix timestamp&lt;/a&gt; (in milliseconds) in which the key will expire. (Redis 5.0 or greater).</source>
          <target state="translated">경우] &lt;code&gt;ABSTTL&lt;/code&gt; 의 수식을 사용하고, &lt;code&gt;ttl&lt;/code&gt; 절대 나타내야 &lt;a href=&quot;http://en.wikipedia.org/wiki/Unix_time&quot;&gt;유닉스 소인&lt;/a&gt; 키가 만료되는 (밀리 초)를. (Redis 5.0 이상).</target>
        </trans-unit>
        <trans-unit id="48c94188363158a9ff98bf015f1ddfb2076ba94d" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;BLOCK&lt;/strong&gt; option is not used, the command is synchronous, and can be considered somewhat related to &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt;: it will return a range of items inside streams, however it has two fundamental differences compared to &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; even if we just consider the synchronous usage:</source>
          <target state="translated">는 IF &lt;strong&gt;블록&lt;/strong&gt; 옵션을 사용하지 명령은 동기이며, 다소 관련이 고려 될 수있다 &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; :이 스트림 내 항목의 범위를 반환합니다, 그러나 그것은에 비해 두 가지 근본적인 차이가 &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 우리가 동기 사용을 고려하더라도를 :</target>
        </trans-unit>
        <trans-unit id="2a8ebc8cb8dd39729bf6fdaaa9469b8e9dd31c5f" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;FORCE&lt;/strong&gt; option is given, the replica does not perform any handshake with the master, that may be not reachable, but instead just starts a failover ASAP starting from point 4. This is useful when we want to start a manual failover while the master is no longer reachable.</source>
          <target state="translated">경우 &lt;strong&gt;강제&lt;/strong&gt; 옵션이 주어 복제본 마스터 어떤 핸드 셰이크를 수행하지 않습니다, 그 도달 할 수없는 수 있지만, 대신 장애 조치는 우리가 마스터하는 동안 수동 장애 조치를 시작할 때 유용 점 (4)부터 빨리 시작 더 이상 연결할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="41e165a8913dade3e9bd91924016ff8d6cab273f" translate="yes" xml:space="preserve">
          <source>If the AOF rewrite could start, but the attempt at starting it fails (for instance because of an error in creating the child process), an error is returned to the caller.</source>
          <target state="translated">AOF 재 작성이 시작될 수 있지만 시작 시도가 실패하면 (예 : 하위 프로세스 생성 오류로 인해) 호출자에게 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="32dde384b66bbd79b525259d52aa9797e8b17bb3" translate="yes" xml:space="preserve">
          <source>If the Redis server is password protected via the &lt;code&gt;requirepass&lt;/code&gt; option.</source>
          <target state="translated">Redis 서버가 &lt;code&gt;requirepass&lt;/code&gt; 옵션을 통해 비밀번호로 보호 된 경우 .</target>
        </trans-unit>
        <trans-unit id="fded77f647c95a1a86355a7eafad08fd193bd854" translate="yes" xml:space="preserve">
          <source>If the above condition happens using a Redis 2.6 server or greater, Client &lt;strong&gt;A&lt;/strong&gt; will be served with the &lt;code&gt;c&lt;/code&gt; element, because after the &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; command the list contains &lt;code&gt;c,b,a&lt;/code&gt;, so taking an element from the left means to return &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">위의 조건이 Redis 2.6 서버 이상을 사용하여 발생하는 경우 &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; 명령 이후에 목록에 &lt;code&gt;c,b,a&lt;/code&gt; 가 포함되어 있으므로 왼쪽에서 요소를 가져 와서 &lt;code&gt;c&lt;/code&gt; 를 반환하므로 클라이언트 &lt;strong&gt;A&lt;/strong&gt; 는 &lt;code&gt;c&lt;/code&gt; 요소 와 함께 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc531ff7f9715b58415dfa6813dab3cc7b073afd" translate="yes" xml:space="preserve">
          <source>If the approximated cardinality estimated by the HyperLogLog changed after executing the command, &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; returns 1, otherwise 0 is returned. The command automatically creates an empty HyperLogLog structure (that is, a Redis String of a specified length and with a given encoding) if the specified key does not exist.</source>
          <target state="translated">명령 실행 후 HyperLogLog에 의해 추정 된 근사 카디널리티가 변경된 경우 &lt;a href=&quot;pfadd&quot;&gt;PFADD&lt;/a&gt; 는 1을 리턴하고 그렇지 않으면 0을 리턴합니다. 지정된 키가 존재하지 않으면 명령은 빈 HyperLogLog 구조 (지정된 길이와 지정된 인코딩의 Redis 문자열)를 자동으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2a7df869ee4ed74778e5142a4cec6fc019c36dbe" translate="yes" xml:space="preserve">
          <source>If the client is subscribed to a channel or a pattern, it will instead return a multi-bulk with a &quot;pong&quot; in the first position and an empty bulk in the second position, unless an argument is provided in which case it returns a copy of the argument.</source>
          <target state="translated">클라이언트가 채널 또는 패턴을 구독하는 경우 인수가 제공되지 않으면 사본이 반환되지 않는 한 첫 번째 위치에 &quot;퐁&quot;이 있고 두 번째 위치에 빈 벌크가있는 멀티 벌크를 대신 반환합니다. 논쟁의.</target>
        </trans-unit>
        <trans-unit id="1e3b4ecb886491d18a97620613800a70a1d78a2c" translate="yes" xml:space="preserve">
          <source>If the client tries to blocks for multiple keys, but at least one key contains elements, the returned key / element pair is the first key from left to right that has one or more elements. In this case the client is not blocked. So for instance &lt;code&gt;BLPOP key1 key2 key3 key4 0&lt;/code&gt;, assuming that both &lt;code&gt;key2&lt;/code&gt; and &lt;code&gt;key4&lt;/code&gt; are non-empty, will always return an element from &lt;code&gt;key2&lt;/code&gt;.</source>
          <target state="translated">클라이언트가 여러 키를 차단하려고하지만 하나 이상의 키에 요소가 포함 된 경우 반환 된 키 / 요소 쌍은 하나 이상의 요소가있는 왼쪽에서 오른쪽으로 첫 번째 키입니다. 이 경우 클라이언트가 차단되지 않습니다. 예를 들어 &lt;code&gt;BLPOP key1 key2 key3 key4 0&lt;/code&gt; 은 &lt;code&gt;key2&lt;/code&gt; 와 &lt;code&gt;key4&lt;/code&gt; 가 모두 비어 있지 않다고 가정 하면 항상 &lt;code&gt;key2&lt;/code&gt; 에서 요소를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c4c4a551c5294109d275f4efb02ba586ea39cd4b" translate="yes" xml:space="preserve">
          <source>If the command contains multiple keys, in case none exist, the behavior is the same as point 2, if all exist, it is the same as point 1, however if only a partial number of keys exist, the command emits a &lt;code&gt;TRYAGAIN&lt;/code&gt; error in order for the keys interested to finish being migrated to the target node, so that the multi keys command can be executed.</source>
          <target state="translated">명령에 여러 키가 포함 된 경우, 존재하지 않는 경우 동작은 포인트 2와 동일하고, 모두 존재하는 경우 포인트 1과 동일하지만 키의 일부만 존재하는 경우 명령은 &lt;code&gt;TRYAGAIN&lt;/code&gt; 오류를 발생시킵니다. 다중 키 명령을 실행할 수 있도록 원하는 키가 대상 노드로 마이그레이션을 완료합니다.</target>
        </trans-unit>
        <trans-unit id="b47c13f341545793a768bad91b706c8230117dd6" translate="yes" xml:space="preserve">
          <source>If the command is sent as part of a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; transaction, the command does not block but instead just return ASAP the number of replicas that acknowledged the previous write commands.</source>
          <target state="translated">명령이 &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; 트랜잭션의 일부로 전송되면 명령은 이전 쓰기 명령을 승인 한 복제본 수를 차단하지 않고 최대한 빨리 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b2647b206316067e60c5c58ad3dabbd5311d10db" translate="yes" xml:space="preserve">
          <source>If the command is successful the new incremented value is stored as the new value of the key (replacing the old one), and returned to the caller as a string.</source>
          <target state="translated">명령이 성공하면 새 증분 값이 키의 새 값으로 저장되고 (이전 값 대체) 호출자에게 문자열로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e13c77b4e4b0cd6a39fdb6c6dd3019929d6f047e" translate="yes" xml:space="preserve">
          <source>If the command succeeds the new replica will immediately try to contact its master in order to replicate from it.</source>
          <target state="translated">명령이 성공하면 새 복제본은 즉시 복제하기 위해 해당 마스터에 연결을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="58e50abae2f1a6949ff81b62d232f71c48c7e358" translate="yes" xml:space="preserve">
          <source>If the current hash slot owner is the node receiving the command, but for effect of the command the slot would be assigned to a different node, the command will return an error if there are still keys for that hash slot in the node receiving the command.</source>
          <target state="translated">현재 해시 슬롯 소유자가 명령을 수신하는 노드이지만 명령의 효과로 인해 슬롯이 다른 노드에 할당되면 명령을 수신하는 노드에 해당 해시 슬롯에 대한 키가 여전히 있으면 명령이 오류를 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="8bdc0729f7e8e3e8d69c4bf5f17ea02031eef1ea" translate="yes" xml:space="preserve">
          <source>If the destination variable exists, it is treated as one of the source sets and its cardinality will be included in the cardinality of the computed HyperLogLog.</source>
          <target state="translated">대상 변수가 존재하면 소스 세트 중 하나로 처리되고 해당 카디널리티가 계산 된 HyperLogLog의 카디널리티에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b16a9421e847dd28010cba3e62963f9099073a99" translate="yes" xml:space="preserve">
          <source>If the elements in the sorted set have different scores, the returned elements are unspecified.</source>
          <target state="translated">정렬 된 세트의 요소가 다른 점수를 갖는 경우 반환 된 요소는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3481b2e7b6d800470df672a8874ad9a04f6afdca" translate="yes" xml:space="preserve">
          <source>If the instance is a replica, these additional fields are provided:</source>
          <target state="translated">인스턴스가 복제 본인 경우 다음과 같은 추가 필드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="a39168a871f5b0b2ac68a8345a687deba4b95089" translate="yes" xml:space="preserve">
          <source>If the link between master and replica is down, an additional field is provided:</source>
          <target state="translated">마스터와 복제본 간의 연결이 끊어지면 추가 필드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5d43590cf68cfd82fc6f591b087a5f138a1a7c3f" translate="yes" xml:space="preserve">
          <source>If the message was never delivered to anyone, that is, if we are talking about a new message, then a PEL (Pending Entry List) is created.</source>
          <target state="translated">메시지가 다른 사람에게 전달되지 않은 경우, 즉 새 메시지에 대해 이야기하는 경우 PEL (Pending Entry List)이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="638ffe7f713cb2cff80e46aae12ead14d0ec33c3" translate="yes" xml:space="preserve">
          <source>If the node is a replica it is turned into an (empty) master. Its dataset is flushed, so at the end the node will be an empty master.</source>
          <target state="translated">노드가 복제 본인 경우 (빈) 마스터로 바뀝니다. 데이터 세트가 플러시되므로 결국 노드는 빈 마스터가됩니다.</target>
        </trans-unit>
        <trans-unit id="1785c288c16b021950b10d9d886a7eae6f023094" translate="yes" xml:space="preserve">
          <source>If the node receiving the command is not already a replica, but is a master, the command will only succeed, and the node will be converted into a replica, only if the following additional conditions are met:</source>
          <target state="translated">명령을 수신하는 노드가 이미 복제본이 아니라 마스터 인 경우 다음 추가 조건이 충족되는 경우에만 명령이 성공하고 노드가 복제본으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="0d7f2602b57e25d3482f6de95a393b6a52d114e4" translate="yes" xml:space="preserve">
          <source>If the object you try to inspect is missing, a null bulk reply is returned.</source>
          <target state="translated">검사하려는 객체가 누락 된 경우 null 대량 응답이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="502f345996f0414bbb8039bdf0ba7a24bdfc3f8f" translate="yes" xml:space="preserve">
          <source>If the password provided via AUTH matches the password in the configuration file, the server replies with the &lt;code&gt;OK&lt;/code&gt; status code and starts accepting commands. Otherwise, an error is returned and the clients needs to try a new password.</source>
          <target state="translated">AUTH를 통해 제공된 암호가 구성 파일의 암호와 일치하면 서버는 &lt;code&gt;OK&lt;/code&gt; 상태 코드로 응답 하고 명령 수락을 시작합니다. 그렇지 않으면 오류가 반환되고 클라이언트는 새 암호를 시도해야합니다.</target>
        </trans-unit>
        <trans-unit id="8069378ad909326b9b791fda111aafbf70922eb2" translate="yes" xml:space="preserve">
          <source>If the rules contain errors, the error is returned.</source>
          <target state="translated">규칙에 오류가 있으면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ed8b33783f226cf240802124131a6b3112f200a2" translate="yes" xml:space="preserve">
          <source>If the script already called write commands the only allowed command becomes &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; that stops the server without saving the current data set on disk (basically the server is aborted).</source>
          <target state="translated">스크립트가 이미 쓰기 명령을 호출 한 경우 허용되는 유일한 명령은 &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; 가되어 현재 데이터 세트를 디스크에 저장하지 않고 서버를 중지합니다 (기본적으로 서버는 중단됨).</target>
        </trans-unit>
        <trans-unit id="7d7312df2553f6628fdfae5411ba0776826d8dfb" translate="yes" xml:space="preserve">
          <source>If the script already performed write operations it can not be killed in this way because it would violate Lua script atomicity contract. In such a case only &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; is able to kill the script, killing the Redis process in an hard way preventing it to persist with half-written information.</source>
          <target state="translated">스크립트가 이미 쓰기 작업을 수행 한 경우 Lua 스크립트 원자 계약을 위반하므로 이런 방식으로 종료 할 수 없습니다. 이러한 경우 &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; 만이 스크립트를 강제 종료 할 수 있으며, Redis 프로세스를 강제 종료하면 반으로 작성된 정보로 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5aeedf1a85f8e143cfd4057ccfb92d5e01611feb" translate="yes" xml:space="preserve">
          <source>If the server does not remember a script with this SHA1 digest, a special error is returned telling the client to use &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; instead.</source>
          <target state="translated">서버가이 SHA1 다이제스트가 포함 된 스크립트를 기억하지 않으면 클라이언트에게 &lt;a href=&quot;eval&quot;&gt;EVAL을&lt;/a&gt; 대신 사용하라는 특별한 오류가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="8c526024cc2b0adff52463eae82153b3e7035275" translate="yes" xml:space="preserve">
          <source>If the server is configured with the &lt;code&gt;min-slaves-to-write&lt;/code&gt; (or starting with Redis 5 with the &lt;code&gt;min-replicas-to-write&lt;/code&gt;) directive, an additional field is provided:</source>
          <target state="translated">서버가 &lt;code&gt;min-slaves-to-write&lt;/code&gt; (또는 &lt;code&gt;min-replicas-to-write&lt;/code&gt; 으로 Redis 5로 시작 ) 지시어로 구성된 경우 추가 필드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="160c785d0bbfa994844826d34af71d6ba78bcac0" translate="yes" xml:space="preserve">
          <source>If the server still remembers a script with a matching SHA1 digest, the script is executed.</source>
          <target state="translated">서버가 여전히 SHA1 다이제스트와 일치하는 스크립트를 기억하면 스크립트가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a73ff8adff60cf3faa9396c7d82031cce8e1eee5" translate="yes" xml:space="preserve">
          <source>If the slot is in &lt;em&gt;migrating&lt;/em&gt; state, the state gets cleared when the slot is assigned to another node.</source>
          <target state="translated">슬롯이 &lt;em&gt;마이그레이션&lt;/em&gt; 상태 인 경우 슬롯이 다른 노드에 할당되면 상태가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="4fb7824817ed0173726151921ede13e72a5a9bcf" translate="yes" xml:space="preserve">
          <source>If the slot was in &lt;em&gt;importing&lt;/em&gt; state in the node receiving the command, and the command assigns the slot to this node (which happens in the target node at the end of the resharding of a hash slot from one node to another), the command has the following side effects: A) the &lt;em&gt;importing&lt;/em&gt; state is cleared. B) If the node config epoch is not already the greatest of the cluster, it generates a new one and assigns the new config epoch to itself. This way its new hash slot ownership will win over any past configuration created by previous failovers or slot migrations.</source>
          <target state="translated">명령을 수신 한 노드 에서 슬롯이 &lt;em&gt;가져 오기&lt;/em&gt; 상태에 있고 명령이이 노드에 슬롯을 할당하면 (해당 슬롯에서 해시 슬롯의 리 샤딩 종료시 대상 노드에서 발생) 노드에 다른 명령이 있습니다. 다음과 같은 부작용이 있습니다. A) &lt;em&gt;가져 오기&lt;/em&gt; 상태가 해제됩니다. B) 노드 구성 에포크가 클러스터의 가장 큰 클러스터가 아닌 경우 새 클러스터를 생성하고 새 구성 에포크를 자체에 할당합니다. 이렇게하면 새로운 해시 슬롯 소유권이 이전 페일 오버 또는 슬롯 마이그레이션으로 생성 된 모든 이전 구성보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="e8cd47d9356aab972b5f2bd3e87e1b06b6cacf48" translate="yes" xml:space="preserve">
          <source>If the source set does not exist or does not contain the specified element, no operation is performed and &lt;code&gt;0&lt;/code&gt; is returned. Otherwise, the element is removed from the source set and added to the destination set. When the specified element already exists in the destination set, it is only removed from the source set.</source>
          <target state="translated">소스 세트가 존재하지 않거나 지정된 요소를 포함하지 않으면 조작이 수행되지 않고 &lt;code&gt;0&lt;/code&gt; 이 리턴됩니다. 그렇지 않으면 요소가 소스 세트에서 제거되고 대상 세트에 추가됩니다. 지정된 요소가 대상 세트에 이미 존재하면 소스 세트에서만 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3ca48297ca2c9df85be826386d88391801b54916" translate="yes" xml:space="preserve">
          <source>If the specified stream doesn't exist when creating a group, an error will be returned. You can use the optional &lt;code&gt;MKSTREAM&lt;/code&gt; subcommand as the last argument after the &lt;code&gt;ID&lt;/code&gt; to automatically create the stream, if it doesn't exist. Note that if the stream is created in this way it will have a length of 0:</source>
          <target state="translated">그룹을 생성 할 때 지정된 스트림이 존재하지 않으면 오류가 반환됩니다. 선택 사항 인 &lt;code&gt;MKSTREAM&lt;/code&gt; 하위 명령을 &lt;code&gt;ID&lt;/code&gt; 뒤의 마지막 인수로 사용하여 스트림이없는 경우 자동으로 생성 할 수 있습니다. 이러한 방식으로 스트림이 생성되면 길이가 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="b2a65b6aeeded425b23af7e95965a0f641dbdc37" translate="yes" xml:space="preserve">
          <source>If the user already exists, the provided ACL rules are simply applied &lt;em&gt;in addition&lt;/em&gt; to the rules already set. For example:</source>
          <target state="translated">사용자가 이미 존재하는 경우 제공된 ACL 규칙이 이미 설정된 규칙 &lt;em&gt;에 추가&lt;/em&gt; 로 적용 &lt;em&gt;됩니다&lt;/em&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da52acca0f5817a572a7d2dfec4d48663d8d1b71" translate="yes" xml:space="preserve">
          <source>If the user inserts all the elements in a sorted set with the same score (for example 0), all the elements of the sorted set are sorted lexicographically, and range queries on elements are possible using the command &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; (Note: it is also possible to query sorted sets by range of scores using &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt;).</source>
          <target state="translated">사용자가 동일한 점수 (예 : 0)로 정렬 된 세트에 모든 요소를 ​​삽입하면 정렬 된 세트의 모든 요소가 사전 식으로 정렬되고 &lt;a href=&quot;zrangebylex&quot;&gt;ZRANGEBYLEX&lt;/a&gt; 명령을 사용하여 요소에 대한 범위 쿼리가 가능합니다 (참고 : &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE를&lt;/a&gt; 사용하여 점수 범위별로 정렬 된 세트를 쿼리합니다 .</target>
        </trans-unit>
        <trans-unit id="bb5f5ae1336c1db943d20a454954235747a6d64e" translate="yes" xml:space="preserve">
          <source>If the user will be idle more than 60 seconds, the key will be deleted and only subsequent page views that have less than 60 seconds of difference will be recorded.</source>
          <target state="translated">사용자가 60 초 이상 유휴 상태 인 경우 키가 삭제되고 60 초 미만의 차이가있는 후속 페이지보기 만 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="dca107e1698238aa60bfb450d46b8e949be6578e" translate="yes" xml:space="preserve">
          <source>If there are no keys to migrate in the source instance &lt;code&gt;NOKEY&lt;/code&gt; is returned. Because missing keys are possible in normal conditions, from expiry for example, &lt;code&gt;NOKEY&lt;/code&gt; isn't an error.</source>
          <target state="translated">소스 인스턴스에 마이그레이션 할 키가 없으면 &lt;code&gt;NOKEY&lt;/code&gt; 가 반환됩니다. 예를 들어 만료일부터 &lt;code&gt;NOKEY&lt;/code&gt; 는 정상적인 조건에서 누락 된 키가 가능하기 때문에 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="65645be10cc140f75bd2c8251142687f4fa78461" translate="yes" xml:space="preserve">
          <source>If we generate a configuration epoch which happens to collide with another instance, eventually our configuration epoch, or the one of another instance with our same epoch, will be moved away using the &lt;em&gt;configuration epoch collision resolution algorithm&lt;/em&gt;.</source>
          <target state="translated">다른 인스턴스와 충돌하는 구성 에포크를 생성하면 결국 구성 에포크 또는 동일한 에포크가있는 다른 인스턴스 중 하나가 &lt;em&gt;구성 에포크 충돌 해결 알고리즘을&lt;/em&gt; 사용하여 멀리 이동 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b6f79d56180a9ad1d3aeb8220feacf255be61da4" translate="yes" xml:space="preserve">
          <source>If we look for clear bits (the bit argument is 0) and the string only contains bit set to 1, the function returns the first bit not part of the string on the right. So if the string is three bytes set to the value &lt;code&gt;0xff&lt;/code&gt; the command &lt;code&gt;BITPOS key 0&lt;/code&gt; will return 24, since up to bit 23 all the bits are 1.</source>
          <target state="translated">클리어 비트 (비트 인수가 0)를 찾고 문자열에 1로 설정된 비트 만 포함 된 경우 함수는 오른쪽에 문자열의 일부가 아닌 첫 번째 비트를 반환합니다. 따라서 문자열이 3 바이트 값 &lt;code&gt;0xff&lt;/code&gt; 로 설정되면 &lt;code&gt;BITPOS key 0&lt;/code&gt; 명령 은 24를 반환합니다. 비트 23까지는 모든 비트가 1이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="44b33ba5659f824ae39b000fc70d2cf7d6138c7b" translate="yes" xml:space="preserve">
          <source>If we look for set bits (the bit argument is 1) and the string is empty or composed of just zero bytes, -1 is returned.</source>
          <target state="translated">비트를 설정하고 (비트 인수가 1) 문자열이 비어 있거나 0 바이트로만 구성된 경우 -1이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2012c008377fbb50737408462ade88dce859c2ba" translate="yes" xml:space="preserve">
          <source>If you call &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; or &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt;, there's no need to manually call &lt;a href=&quot;unwatch&quot;&gt;UNWATCH&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; 또는 &lt;a href=&quot;discard&quot;&gt;DISCARD&lt;/a&gt; 를 호출하면 &lt;a href=&quot;unwatch&quot;&gt;UNWATCH&lt;/a&gt; 를 수동으로 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7adf0ee2bf057d6e4f3261ad571f6a13a6962d80" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want all the clients to get all the messages, you do not need a consumer group.</source>
          <target state="translated">스트림과 여러 클라이언트가 있고 모든 클라이언트가 모든 메시지를 받도록하려면 소비자 그룹이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7914b0ae2e05e8d2f74a0d7390601ab548d893de" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want the stream to be &lt;em&gt;partitioned&lt;/em&gt; or &lt;em&gt;sharded&lt;/em&gt; across your clients, so that each client will get a sub set of the messages arriving in a stream, you need a consumer group.</source>
          <target state="translated">당신이 스트림과 여러 클라이언트를 가지고 있고, 당신이 스트림이 원하는 경우 &lt;em&gt;분할&lt;/em&gt; 또는 &lt;em&gt;분산됩니다&lt;/em&gt; 각 클라이언트가 스트림에 도착한 메시지의 하위 집합을 얻을 것이다 그래서, 당신의 클라이언트를 통해, 당신은 소비자 그룹이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="560057ad39d223339741232ee3fcc91b0feb1edf" translate="yes" xml:space="preserve">
          <source>If you have a stream and multiple clients, and you want the stream to be &lt;em&gt;partitioned&lt;/em&gt; or &lt;em&gt;shareded&lt;/em&gt; across your clients, so that each client will get a sub set of the messages arriving in a stream, you need a consumer group.</source>
          <target state="translated">스트림과 여러 클라이언트가 있고 스트림이 클라이언트에서 &lt;em&gt;분할&lt;/em&gt; 되거나 &lt;em&gt;공유&lt;/em&gt; 되어 각 클라이언트가 스트림에 도착하는 메시지의 하위 세트를 가져 오려면 소비자 그룹이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b31dd57013b909fbb7b7346c7faa280640e4841b" translate="yes" xml:space="preserve">
          <source>If you like science fiction, think of time flowing at infinite speed inside a &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block...</source>
          <target state="translated">공상 과학 소설을 좋아한다면 &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; 블록 안에서 무한한 속도로 흐르는 시간을 생각해보십시오 .</target>
        </trans-unit>
        <trans-unit id="c010cb9076ea01e47bb02d7ca64129ac264912a3" translate="yes" xml:space="preserve">
          <source>If you look for an &lt;code&gt;XGET&lt;/code&gt; command you'll be disappointed because &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; is effectively the way to go in order to fetch a single entry from a stream. All you have to do is to specify the ID two times in the arguments of XRANGE:</source>
          <target state="translated">당신이 찾는 경우 &lt;code&gt;XGET&lt;/code&gt; 명령 때문에 실망 할 것이다 &lt;a href=&quot;xrange&quot;&gt;XRANGE이&lt;/a&gt; 효과적으로 스트림에서 하나의 항목을 가져 오기 위해 길을 가야하는 것입니다. XRANGE의 인수에서 ID를 두 번 지정하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="9b173c7e7e26659d2dc21433cf73d902805a206a" translate="yes" xml:space="preserve">
          <source>If you request details about non-existing commands, their return position will be nil.</source>
          <target state="translated">존재하지 않는 명령에 대한 세부 정보를 요청하면 반환 위치는 nil이됩니다.</target>
        </trans-unit>
        <trans-unit id="12acfb0048a8a9bf03f38f7e388902128cc410f3" translate="yes" xml:space="preserve">
          <source>Imagine you have a web service and you are interested in the latest N pages &lt;em&gt;recently&lt;/em&gt; visited by your users, such that each adjacent page view was not performed more than 60 seconds after the previous. Conceptually you may consider this set of page views as a &lt;em&gt;Navigation session&lt;/em&gt; of your user, that may contain interesting information about what kind of products he or she is looking for currently, so that you can recommend related products.</source>
          <target state="translated">웹 서비스가 있고 사용자가 &lt;em&gt;최근에&lt;/em&gt; 방문한 최신 N 페이지 &lt;em&gt;에&lt;/em&gt; 관심이 있다고 가정 하여 이전의 각 페이지보기가 60 초 이상 수행되지 않도록하십시오. 개념적으로이 페이지보기 세트를 사용자 의 &lt;em&gt;탐색 세션&lt;/em&gt; 으로 간주 할 수 있습니다. 여기에는 현재 찾고있는 제품 종류에 대한 흥미로운 정보가 포함되어 있으므로 관련 제품을 추천 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fb9a33bf9d1d9a11eb463de937edd8bbe41eff8" translate="yes" xml:space="preserve">
          <source>Imagine you have elements A, B and C with weights 1, 2 and 3. You compute the sum of the weights, which is 1+2+3 = 6</source>
          <target state="translated">가중치 1, 2 및 3을 가진 요소 A, B 및 C가 있다고 가정합니다. 가중치의 합을 계산합니다. 1 + 2 + 3 = 6입니다.</target>
        </trans-unit>
        <trans-unit id="28adac3b6124834ed39c280b45702edaf27ac85d" translate="yes" xml:space="preserve">
          <source>Implement &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;wait&quot;&gt;WAIT를&lt;/a&gt; 구현하십시오 .</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="11672e7162d8cdc131bd8b02c509dcb60a9d776d" translate="yes" xml:space="preserve">
          <source>Implementation details and notes</source>
          <target state="translated">구현 세부 사항 및 참고 사항</target>
        </trans-unit>
        <trans-unit id="cc7649d9b862b15149646b67450f76a9d95f07c8" translate="yes" xml:space="preserve">
          <source>Implementation details: MEET and PING packets</source>
          <target state="translated">구현 세부 사항 : MEET 및 PING 패킷</target>
        </trans-unit>
        <trans-unit id="c5a3d437892d8fb38c145f676153ba0009f546b9" translate="yes" xml:space="preserve">
          <source>Important: &lt;strong&gt;there is no need to use the same COUNT value&lt;/strong&gt; for every iteration. The caller is free to change the count from one iteration to the other as required, as long as the cursor passed in the next call is the one obtained in the previous call to the command.</source>
          <target state="translated">중요 : 모든 반복에 &lt;strong&gt;동일한 COUNT 값을 사용할 필요는 없습니다&lt;/strong&gt; . 다음 호출에서 전달 된 커서가 명령에 대한 이전 호출에서 얻은 것이라면 호출자는 한 반복에서 다른 반복으로 카운트를 자유롭게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6980584e557c93bab34f4259447d38dd3a9c928" translate="yes" xml:space="preserve">
          <source>Importing and migrating slots are emitted in the &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output as follows:</source>
          <target state="translated">가져 오기 및 마이그레이션 슬롯은 다음과 같이 &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; 출력 에서 방출 됩니다.</target>
        </trans-unit>
        <trans-unit id="50ac60eae9cbac9b1534be93c64ff4eb8e05e3df" translate="yes" xml:space="preserve">
          <source>Importing and migrating slots are provided as &lt;strong&gt;additional info&lt;/strong&gt;. If the node has a given hash slot assigned, it will be also a plain number in the list of hash slots, so clients that don't have a clue about hash slots migrations can just skip this special fields.</source>
          <target state="translated">슬롯 가져 오기 및 마이그레이션은 &lt;strong&gt;추가 정보&lt;/strong&gt; 로 제공됩니다 . 노드에 지정된 해시 슬롯이 할당되어 있으면 해시 슬롯 목록에도 일반 번호가 표시되므로 해시 슬롯 마이그레이션에 대한 단서가없는 클라이언트는이 특수 필드를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="779e3f1f46c82af5ed6e618104fadfbd8c5eb506" translate="yes" xml:space="preserve">
          <source>In Cluster mode, both &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;newkey&lt;/code&gt; must be in the same &lt;strong&gt;hash slot&lt;/strong&gt;, meaning that in practice only keys that have the same hash tag can be reliably renamed in cluster.</source>
          <target state="translated">클러스터 모드에서 &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;newkey&lt;/code&gt; 는 모두 동일한 &lt;strong&gt;해시 슬롯&lt;/strong&gt; 에 있어야합니다. 즉, 실제로는 동일한 해시 태그가있는 키만 클러스터에서 안정적으로 이름을 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e69ceca772f34d784aadd1c27595fdabe97b5262" translate="yes" xml:space="preserve">
          <source>In Redis 2.4 the expire might not be pin-point accurate, and it could be between zero to one seconds out.</source>
          <target state="translated">Redis 2.4에서 만료는 정확히 정확하지 않을 수 있으며 0 초에서 1 초 사이 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="404f7b7c02b7867c0901ee21294f6e2f5fef0d3c" translate="yes" xml:space="preserve">
          <source>In Redis 2.6 or older the command returns &lt;code&gt;-1&lt;/code&gt; if the key does not exist or if the key exist but has no associated expire.</source>
          <target state="translated">Redis 2.6 이상 에서는 키가 존재하지 않거나 키가 존재하지만 연관된 만료가없는 경우 명령은 &lt;code&gt;-1&lt;/code&gt; 을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="8b69e0b775a7565070cf9c5f2db4bd807c015a5f" translate="yes" xml:space="preserve">
          <source>In Redis Cluster, each node keeps track of which master is serving a particular hash slot.</source>
          <target state="translated">Redis Cluster에서 각 노드는 특정 해시 슬롯을 제공하는 마스터를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="d172f4fd77faed8def89fa030ed71bc01d833ea7" translate="yes" xml:space="preserve">
          <source>In Redis version 4, commands that may return elements in random order, like &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; (because Redis Sets are &lt;em&gt;unordered&lt;/em&gt;) have a different behavior when called from Lua, and undergo a silent lexicographical sorting filter before returning data to Lua scripts. So &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; will always return the Set elements in the same order, while the same command invoked from normal clients may return different results even if the key contains exactly the same elements. However starting with Redis 5 there is no longer such ordering step, because Redis 5 replicates scripts in a way that no longer needs non-deterministic commands to be converted into deterministic ones. In general, even when developing for Redis 4, never assume that certain commands in Lua will be ordered, but instead rely on the documentation of the original command you call to see the properties it provides.</source>
          <target state="translated">Redis 버전 4에서 &lt;a href=&quot;smembers&quot;&gt;SMEMBERS&lt;/a&gt; 와 같이 요소를 임의 순서로 반환 할 수있는 명령 (Redis 집합이 &lt;em&gt;순서&lt;/em&gt; 가 &lt;em&gt;지정되지&lt;/em&gt; 않았기 때문에 )은 Lua에서 호출 될 때 다른 동작을 가지며 Lua 스크립트로 데이터를 반환하기 전에 자동 사전 정렬 필터를 거칩니다. 그래서 &lt;code&gt;redis.call(&quot;smembers&quot;,KEYS[1])&lt;/code&gt; 는 항상 동일한 순서로 Set 요소를 반환하지만 일반 클라이언트에서 호출 된 동일한 명령은 키에 정확히 동일한 요소가 포함되어 있어도 다른 결과를 반환 할 수 있습니다. 그러나 Redis 5부터는 더 이상 이러한 순서 지정 단계가 없습니다. Redis 5는 더 이상 비 결정적 명령을 결정적 명령으로 변환 할 필요가없는 방식으로 스크립트를 복제하기 때문입니다. 일반적으로 Redis 4 용으로 개발할 때에도 Lua의 특정 명령이 정렬 될 것이라고 가정하지 말고 대신 호출하는 원래 명령의 문서에 의존하여 제공하는 속성을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d0bdbf698aa8eaf887d7877ad1c2d9ea20b7520a" translate="yes" xml:space="preserve">
          <source>In Redis versions prior &lt;strong&gt;2.1.3&lt;/strong&gt; altering a key with an expire set using a command altering its value had the effect of removing the key entirely. This semantics was needed because of limitations in the replication layer that are now fixed.</source>
          <target state="translated">&lt;strong&gt;2.1.3&lt;/strong&gt; 이전의 Redis 버전에서는 값을 변경하는 명령을 사용하여 만료 세트로 키를 변경하면 키를 완전히 제거하는 효과가있었습니다. 이 의미는 이제 수정 된 복제 계층의 제한 때문에 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="532b5a4c8c089bdea2a3dcd755e5c2d0a78f31ac" translate="yes" xml:space="preserve">
          <source>In a Redis Cluster clients can publish to every node. The cluster makes sure that published messages are forwarded as needed, so clients can subscribe to any channel by connecting to any one of the nodes.</source>
          <target state="translated">Redis 클러스터에서 클라이언트는 모든 노드에 게시 할 수 있습니다. 클러스터는 게시 된 메시지가 필요에 따라 전달되도록하므로 클라이언트는 노드 중 하나에 연결하여 모든 채널을 구독 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34f272b3296928896a7fa9c51b4f28ffa23b9540" translate="yes" xml:space="preserve">
          <source>In future versions of Redis it is possible that we'll trigger a node garbage collection in case a given macro-node reaches a given amount of deleted entries. Currently with the usage we anticipate for this data structure, it is not a good idea to add such complexity.</source>
          <target state="translated">Redis의 이후 버전에서는 지정된 매크로 노드가 지정된 양의 삭제 된 항목에 도달 할 경우 노드 가비지 수집을 트리거 할 수 있습니다. 현재 우리는이 데이터 구조에 대한 사용법으로 이러한 복잡성을 추가하는 것은 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="420ffa2728e82649ac426218fc502611ceb5c012" translate="yes" xml:space="preserve">
          <source>In general what you should know is that setting the &lt;code&gt;appendonly&lt;/code&gt; parameter to &lt;code&gt;yes&lt;/code&gt; will start a background process to save the initial append-only file (obtained from the in memory data set), and will append all the subsequent commands on the append-only file, thus obtaining exactly the same effect of a Redis server that started with AOF turned on since the start.</source>
          <target state="translated">일반적으로 &lt;code&gt;appendonly&lt;/code&gt; 매개 변수를 &lt;code&gt;yes&lt;/code&gt; 로 설정하면 백그라운드 프로세스가 시작되어 초기 추가 전용 파일 (메모리 데이터 세트에서 가져옴) 을 저장하고 이후의 모든 명령을 추가 전용 파일에 추가합니다. 따라서 시작 이후 AOF로 시작한 Redis 서버와 동일한 효과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="464e556758431df2768b0136fb61ecadb0a9af07" translate="yes" xml:space="preserve">
          <source>In its synchronous form, the command can get new data as long as there are more items available. However, at some point, we'll have to wait for producers of data to use &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; to push new entries inside the streams we are consuming. In order to avoid polling at a fixed or adaptive interval the command is able to block if it could not return any data, according to the specified streams and IDs, and automatically unblock once one of the requested keys accept data.</source>
          <target state="translated">동기식으로 사용 가능한 항목이 더 있으면 명령이 새 데이터를 가져올 수 있습니다. 그러나 어느 시점에서 우리는 데이터 생산자가 &lt;a href=&quot;xadd&quot;&gt;XADD&lt;/a&gt; 를 사용 하여 우리가 소비하는 스트림 내부에 새로운 항목을 푸시 할 때까지 기다려야합니다 . 고정 또는 적응 간격으로 폴링을 피하기 위해 지정된 스트림 및 ID에 따라 데이터를 반환 할 수없는 경우 명령을 차단하고 요청 된 키 중 하나가 데이터를 수락하면 자동으로 차단을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f71d43ee55e218973fa1e5cb6ebd10de6f4de1c3" translate="yes" xml:space="preserve">
          <source>In options where bytes or other quantities are specified, it is not possible to use the &lt;code&gt;redis.conf&lt;/code&gt; abbreviated form (&lt;code&gt;10k&lt;/code&gt;, &lt;code&gt;2gb&lt;/code&gt; ... and so forth), everything should be specified as a well-formed 64-bit integer, in the base unit of the configuration directive. However since Redis version 3.0 or greater, it is possible to use &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; with memory units for &lt;code&gt;maxmemory&lt;/code&gt;, client output buffers, and replication backlog size.</source>
          <target state="translated">바이트 또는 다른 수량이 지정된 옵션에서는 &lt;code&gt;redis.conf&lt;/code&gt; 약어 형식 ( &lt;code&gt;10k&lt;/code&gt; , &lt;code&gt;2gb&lt;/code&gt; ... 등) 을 사용할 수 없으며 모든 것이 올바른 형식의 64 비트 정수로 지정되어야합니다. 구성 지시문의 기본 단위. 그러나 Redis 버전 3.0 이상에서는 &lt;code&gt;maxmemory&lt;/code&gt; , 클라이언트 출력 버퍼 및 복제 백 로그 크기를 위한 메모리 단위와 함께 &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7b5d3135e15286cfdbe38c07d4aa01f9fe0988a" translate="yes" xml:space="preserve">
          <source>In order to authenticate the current connection with one of the connections defined in the ACL list (see &lt;a href=&quot;acl-setuser&quot;&gt;ACL SETUSER&lt;/a&gt;) and the official &lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;ACL guide&lt;/a&gt; for more information.</source>
          <target state="translated">ACL 목록 ( &lt;a href=&quot;acl-setuser&quot;&gt;ACL SETUSER&lt;/a&gt; 참조)에 정의 된 연결 중 하나로 현재 연결을 인증하고 자세한 내용 은 공식 &lt;a href=&quot;https://redis.io/topics/acl&quot;&gt;ACL 가이드&lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="74befe185bf5845d0b7429c8d4ecaac4587e1561" translate="yes" xml:space="preserve">
          <source>In order to avoid these problems while avoiding the bandwidth penalty, Redis implements the &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; command.</source>
          <target state="translated">대역폭 문제를 피하면서 이러한 문제를 피하기 위해 Redis는 &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; 명령을 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="4e60382da8db79c78bf47f321f4d7ec3aa869b88" translate="yes" xml:space="preserve">
          <source>In order to block, the &lt;strong&gt;BLOCK&lt;/strong&gt; option is used, together with the number of milliseconds we want to block before timing out. Normally Redis blocking commands take timeouts in seconds, however this command takes a millisecond timeout, even if normally the server will have a timeout resolution near to 0.1 seconds. This time it is possible to block for a shorter time in certain use cases, and if the server internals will improve over time, it is possible that the resolution of timeouts will improve.</source>
          <target state="translated">블록하기 위해, &lt;strong&gt;블록&lt;/strong&gt; 옵션은 시간 초과하기 전에 우리가 블록에 원하는 시간 (밀리 초)과 함께 사용된다. 일반적으로 Redis 차단 명령은 초 단위로 시간 초과되지만,이 명령은 일반적으로 서버가 0.1 초에 가까운 시간 초과 해상도를 갖더라도 밀리 초 시간 초과가 걸립니다. 이번에는 특정 사용 사례에서 더 짧은 시간 동안 차단할 수 있으며 서버 내부가 시간이 지남에 따라 개선 될 경우 시간 초과 해결이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0040f93cb8c4b8bdab630ff12697ba1b0160ca64" translate="yes" xml:space="preserve">
          <source>In order to enable script effects replication, you need to issue the following Lua command before any write operated by the script:</source>
          <target state="translated">스크립트 효과 복제를 사용하려면 스크립트에서 쓰기 작업을 수행하기 전에 다음 Lua 명령을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="013756f6d564f805aee9f75f0b5914a1c30d7b5d" translate="yes" xml:space="preserve">
          <source>In order to enable this form, the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; option is used, and the normal &lt;em&gt;key&lt;/em&gt; argument is set to an empty string. The actual key names will be provided after the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; argument itself, like in the following example:</source>
          <target state="translated">이 양식을 사용하기 위해 &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; 옵션이 사용되며 일반 &lt;em&gt;키&lt;/em&gt; 인수는 빈 문자열로 설정됩니다. 실제 키 이름은 다음 예제와 같이 &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; 인수 자체 뒤에 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="ae1f75fb4769a06b17ea6f198ef59cd43ba00d55" translate="yes" xml:space="preserve">
          <source>In order to enable tracking, use:</source>
          <target state="translated">추적을 활성화하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7e7cf3fffb86f4198755cdccfe390f7daca4376b" translate="yes" xml:space="preserve">
          <source>In order to enforce this behavior in scripts Redis does the following:</source>
          <target state="translated">스크립트에서이 동작을 시행하기 위해 Redis는 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="4210ec3e973c5d5ac271cc1ab7ffcffaa3f2c4da" translate="yes" xml:space="preserve">
          <source>In order to fix a broken cluster where certain slots are unassigned.</source>
          <target state="translated">특정 슬롯이 할당되지 않은 손상된 클러스터를 수정하기 위해.</target>
        </trans-unit>
        <trans-unit id="4708216948f38c6f376d2b00aef53c77bfc810bd" translate="yes" xml:space="preserve">
          <source>In order to iterate a stream, we can proceed as follows. Let's assume that we want two elements per iteration. We start fetching the first two elements, which is trivial:</source>
          <target state="translated">스트림을 반복하기 위해 다음과 같이 진행할 수 있습니다. 반복 당 2 개의 요소를 원한다고 가정 해 봅시다. 처음 두 요소를 가져 오기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="93f82278196654b93d4f14013ea15fe416b7d299" translate="yes" xml:space="preserve">
          <source>In order to make it a pure function, but still be sure that every invocation of the script will result in different random elements, we can simply add an additional argument to the script that will be used in order to seed the Lua pseudo-random number generator. The new script is as follows:</source>
          <target state="translated">순수한 함수로 만들기 위해 스크립트를 호출 할 때마다 다른 임의의 요소가 생성되도록하려면 루아 의사 난수를 시드하기 위해 사용할 인수를 스크립트에 추가하면됩니다. 발전기. 새로운 스크립트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e754dbb6b6073549994be57928409b8a9518fbf" translate="yes" xml:space="preserve">
          <source>In order to make sure the redis.conf file is always consistent, that is, on errors or crashes you always end with the old file, or the new one, the rewrite is performed with a single &lt;code&gt;write(2)&lt;/code&gt; call that has enough content to be at least as big as the old file. Sometimes additional padding in the form of comments is added in order to make sure the resulting file is big enough, and later the file gets truncated to remove the padding at the end.</source>
          <target state="translated">redis.conf 파일이 항상 일관성을 유지하기 위해, 즉 오류나 충돌이 발생하면 항상 이전 파일 또는 새 파일로 끝납니다. 충분한 내용 의 단일 &lt;code&gt;write(2)&lt;/code&gt; 호출로 다시 쓰기가 수행됩니다. 적어도 이전 파일만큼 커야합니다. 때로는 결과 파일이 충분히 큰지 확인하기 위해 주석 형식의 추가 패딩이 추가되고 나중에 파일이 끝에서 패딩을 제거하기 위해 잘립니다.</target>
        </trans-unit>
        <trans-unit id="45b71d9b591350682c94742bdef7ff99466f0e92" translate="yes" xml:space="preserve">
          <source>In order to make this locking algorithm more robust, a client holding a lock should always check the timeout didn't expire before unlocking the key with &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; because client failures can be complex, not just crashing but also blocking a lot of time against some operations and trying to issue &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; after a lot of time (when the LOCK is already held by another client).</source>
          <target state="translated">이 잠금 알고리즘을보다 견고하게 만들려면 잠금을 보유한 클라이언트가 &lt;a href=&quot;del&quot;&gt;DEL을 사용&lt;/a&gt; 하여 키를 잠금 해제하기 전에 항상 시간 초과가 만료되지 않았는지 확인해야 합니다. 많은 시간이 지나면 &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; 을 발행하려고 시도합니다 (다른 클라이언트가 이미 잠금을 보유한 경우).</target>
        </trans-unit>
        <trans-unit id="26d3078f4ebbdf0701299addb5fed6bbed540a2c" translate="yes" xml:space="preserve">
          <source>In order to obtain a correct behavior without sacrificing consistency, when a key expires, a &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; operation is synthesized in both the AOF file and gains all the attached replicas nodes. This way the expiration process is centralized in the master instance, and there is no chance of consistency errors.</source>
          <target state="translated">일관성을 유지하면서 올바른 동작을 얻기 위해 키가 만료되면 &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; 작업이 AOF 파일에서 모두 합성되고 연결된 모든 복제본 노드를 얻습니다. 이렇게하면 만료 프로세스가 마스터 인스턴스에서 중앙 집중화되며 일관성 오류가 발생할 가능성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4d1c1dcdd2afe763b414a4824111916d472be49" translate="yes" xml:space="preserve">
          <source>In order to switch to RESP3 a script should call this function:</source>
          <target state="translated">RESP3로 전환하려면 스크립트가이 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="40403839cd4ec5549ce4c8b0b88fe76bd596deee" translate="yes" xml:space="preserve">
          <source>In other words there is a one-to-one conversion between Lua and Redis types. The following table shows you all the conversions rules:</source>
          <target state="translated">즉, Lua와 Redis 유형간에 일대일 변환이 있습니다. 다음 표는 모든 변환 규칙을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b63d884600898ba55bb1960529b41996e05a6f02" translate="yes" xml:space="preserve">
          <source>In practical terms, Redis databases should be used to separate different keys belonging to the same application (if needed), and not to use a single Redis instance for multiple unrelated applications.</source>
          <target state="translated">실제적으로 Redis 데이터베이스는 동일한 애플리케이션 (필요한 경우)에 속하는 서로 다른 키를 분리하는 데 사용해야하며, 관련되지 않은 여러 애플리케이션에 단일 Redis 인스턴스를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="73283192b40f30e6bf23bca973e203da21ec7a06" translate="yes" xml:space="preserve">
          <source>In practical terms, Redis databases should mainly used in order to, if needed, separate different keys belonging to the same application, and not in order to use a single Redis instance for multiple unrelated applications.</source>
          <target state="translated">실질적인 측면에서, Redis 데이터베이스는 필요한 경우 동일한 애플리케이션에 속하는 서로 다른 키를 분리하고 여러 관련없는 애플리케이션에 단일 Redis 인스턴스를 사용하기 위해 주로 사용되어야합니다.</target>
        </trans-unit>
        <trans-unit id="1cb1bb56f86e93948082da017865db052e971cd7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;COUNT&lt;/code&gt; option documentation, we state that sometimes this family of commands may return all the elements of a Set, Hash or Sorted Set at once in a single call, regardless of the &lt;code&gt;COUNT&lt;/code&gt; option value. The reason why this happens is that the cursor-based iterator can be implemented, and is useful, only when the aggregate data type that we are scanning is represented as an hash table. However Redis uses a &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;memory optimization&lt;/a&gt; where small aggregate data types, until they reach a given amount of items or a given max size of single elements, are represented using a compact single-allocation packed encoding. When this is the case, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; has no meaningful cursor to return, and must iterate the whole data structure at once, so the only sane behavior it has is to return everything in a call.</source>
          <target state="translated">에서 &lt;code&gt;COUNT&lt;/code&gt; 의 옵션 문서, 우리는 명령 때로는 가족 관계없이의 단일 호출로 한 번에 설정, 해시 또는 소트 세트의 모든 요소를 반환 할 수 있습니다 상태 &lt;code&gt;COUNT&lt;/code&gt; 의 옵션 값. 이것이 발생하는 이유는 커서 기반 반복자가 구현 될 수 있고 스캔하는 집계 데이터 유형이 해시 테이블로 표시되는 경우에만 유용하기 때문입니다. 그러나 Redis는 소량의 집계 데이터 유형이 주어진 양의 항목 또는 주어진 최대 크기의 단일 요소에 도달 할 때까지 소형 단일 할당 묶음 인코딩을 사용하여 표시 되는 &lt;a href=&quot;https://redis.io/topics/memory-optimization&quot;&gt;메모리 최적화&lt;/a&gt; 를 사용합니다. 이 경우 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 의미있는 커서가 반환되지 않으며 전체 데이터 구조를 한 번에 반복해야하므로 호출에서 모든 것을 반환하는 것이 제정신입니다.</target>
        </trans-unit>
        <trans-unit id="8c0e05b70b67e4b92ac3373b78b09162115732be" translate="yes" xml:space="preserve">
          <source>In the above case the entry &lt;code&gt;1526985054069-0&lt;/code&gt; exists, otherwise the server would have sent us the next one. Using &lt;code&gt;COUNT&lt;/code&gt; is also the base in order to use &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; as an iterator.</source>
          <target state="translated">위의 경우 &lt;code&gt;1526985054069-0&lt;/code&gt; 항목 이 존재하면 서버가 다음 항목 을 전송했을 것입니다. &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 를 반복자 로 사용하려면 &lt;code&gt;COUNT&lt;/code&gt; 를 사용하는 것도 기본입니다 .</target>
        </trans-unit>
        <trans-unit id="f40be215733bf9374d8b827188eeddff85363cc0" translate="yes" xml:space="preserve">
          <source>In the above example of counting days, even after 10 years the application is online we still have just &lt;code&gt;365*10&lt;/code&gt; bits of data per user, that is just 456 bytes per user. With this amount of data &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; is still as fast as any other O(1) Redis command like &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; or &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt;.</source>
          <target state="translated">위의 날짜 계산 예에서 10 년이 지난 후에도 응용 프로그램은 온라인 상태이지만 사용자 당 &lt;code&gt;365*10&lt;/code&gt; 비트의 데이터, 즉 사용자 당 456 바이트입니다. 이 데이터 양으로 &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; 는 여전히 &lt;a href=&quot;get&quot;&gt;GET&lt;/a&gt; 또는 &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; 과 같은 다른 O (1) Redis 명령만큼 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="76a0365bc0972ed4321b2f354ddf621810b8b004" translate="yes" xml:space="preserve">
          <source>In the above example we claim the message with ID &lt;code&gt;1526569498055-0&lt;/code&gt;, only if the message is idle for at least one hour without the original consumer or some other consumer making progresses (acknowledging or claiming it), and assigns the ownership to the consumer &lt;code&gt;Alice&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 우리 는 메시지가 원래 소비자 또는 다른 소비자가 진행하지 않고 (확인 또는 청구하지 않고) 적어도 1 시간 동안 유휴 상태 인 경우에만 소유권이 소비자 &lt;code&gt;Alice&lt;/code&gt; 에게 할당 된 경우에만 ID가 &lt;code&gt;1526569498055-0&lt;/code&gt; 인 메시지를 청구합니다. .</target>
        </trans-unit>
        <trans-unit id="0bef89cf285951fc9b88c842b027336864d10794" translate="yes" xml:space="preserve">
          <source>In the above example you can see that the reported information are the number of elements of the stream, details about the radix tree representing the stream mostly useful for optimization and debugging tasks, the number of consumer groups associated with the stream, the last generated ID that may not be the same as the last entry ID in case some entry was deleted. Finally the full first and last entry in the stream are shown, in order to give some sense about what is the stream content.</source>
          <target state="translated">위의 예에서보고 된 정보는 스트림의 요소 수, 최적화 및 디버깅 작업에 주로 유용한 스트림을 나타내는 기수 트리에 대한 세부 정보, 스트림과 관련된 소비자 그룹 수, 마지막으로 생성 된 ID입니다. 일부 항목이 삭제 된 경우 마지막 항목 ID와 동일하지 않을 수 있습니다. 마지막으로 스트림 내용이 무엇인지 이해하기 위해 스트림의 전체 첫 번째 항목과 마지막 항목이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5e1f5dbd04f5dc1db0a038c0d0e6f0ff4a4acd34" translate="yes" xml:space="preserve">
          <source>In the above locking algorithm there is a problem: what happens if a client fails, crashes, or is otherwise not able to release the lock? It's possible to detect this condition because the lock key contains a UNIX timestamp. If such a timestamp is equal to the current Unix time the lock is no longer valid.</source>
          <target state="translated">위의 잠금 알고리즘에는 문제가 있습니다. 클라이언트가 실패하거나 충돌하거나 잠금을 해제 할 수없는 경우 어떻게됩니까? 잠금 키에 UNIX 타임 스탬프가 포함되어 있기 때문에이 조건을 감지 할 수 있습니다. 이러한 타임 스탬프가 현재 Unix 시간과 같으면 잠금이 더 이상 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7063c49f04f76f5d83a38b2826e82b8706b19e78" translate="yes" xml:space="preserve">
          <source>In the case of &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt;, keys are every other position so the step value is 2. Compare with &lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; above where the step value is just 1.</source>
          <target state="translated">&lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; 의 경우 키는 다른 모든 위치이므로 단계 값은 2입니다. 위의 &lt;a href=&quot;mget&quot;&gt;MGET&lt;/a&gt; 과 비교 하여 단계 값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="51cf6b9278dbdee20c8485961f1e557cd7119742" translate="yes" xml:space="preserve">
          <source>In the context of a node that has received a &lt;code&gt;DELSLOTS&lt;/code&gt; command and has consequently removed the associations for the passed hash slots, we say those hash slots are &lt;em&gt;unbound&lt;/em&gt;. Note that the existence of unbound hash slots occurs naturally when a node has not been configured to handle them (something that can be done with the &lt;code&gt;ADDSLOTS&lt;/code&gt; command) and if it has not received any information about who owns those hash slots (something that it can learn from heartbeat or update messages).</source>
          <target state="translated">&lt;code&gt;DELSLOTS&lt;/code&gt; 명령 을 수신하여 결과적으로 전달 된 해시 슬롯에 대한 연관을 제거한 노드 와 관련하여 해당 해시 슬롯은 &lt;em&gt;바인드되지 않습니다&lt;/em&gt; . 언 바운드 해시 슬롯의 존재는 노드가 노드를 처리하도록 구성되지 않았거나 ( &lt;code&gt;ADDSLOTS&lt;/code&gt; 명령 으로 수행 할 수있는 것 ) 해시 슬롯을 소유 한 사람에 대한 정보를받지 못한 경우 자연스럽게 발생합니다. 하트 비트 또는 업데이트 메시지를 통해 학습).</target>
        </trans-unit>
        <trans-unit id="0c3893e92cc9396f13c9f99b5e7ad611d2ac46c2" translate="yes" xml:space="preserve">
          <source>In the context of a stream consumer group, this command changes the ownership of a pending message, so that the new owner is the consumer specified as the command argument. Normally this is what happens:</source>
          <target state="translated">스트림 소비자 그룹의 컨텍스트에서이 명령은 보류중인 메시지의 소유권을 변경하여 새 소유자가 명령 인수로 지정된 소비자가되도록합니다. 일반적으로 이런 일이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="57bf1b4701a5c94880ee6e46bfe56ac8c7000db8" translate="yes" xml:space="preserve">
          <source>In the example above, the first call uses zero as a cursor, to start the iteration. The second call uses the cursor returned by the previous call as the first element of the reply, that is, 17.</source>
          <target state="translated">위의 예에서 첫 번째 호출은 반복을 시작하기 위해 커서로 0을 사용합니다. 두 번째 호출은 이전 호출에서 반환 된 커서를 응답의 첫 번째 요소, 즉 17로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="64f37e2cb3f5829eb3ba5c3a4f7f3eea2d872acc" translate="yes" xml:space="preserve">
          <source>In the extended form we no longer see the summary information, instead there are detailed information for each message in the pending entries list. For each message four attributes are returned:</source>
          <target state="translated">확장 된 양식에서는 더 이상 요약 정보가 표시되지 않고 보류중인 항목 목록에 각 메시지에 대한 자세한 정보가 있습니다. 각 메시지마다 네 가지 속성이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="611f148b8dfb6f6978d2aeb35216b9ff55929cae" translate="yes" xml:space="preserve">
          <source>In the extended form we no longer see the summary information, instead there is detailed information for each message in the pending entries list. For each message four attributes are returned:</source>
          <target state="translated">확장 된 양식에서는 더 이상 요약 정보가 표시되지 않고 대신 보류중인 항목 목록의 각 메시지에 대한 자세한 정보가 있습니다. 각 메시지에 대해 네 가지 속성이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="bec3c889a89e0a9bff423ca26bc6e8f597b12b82" translate="yes" xml:space="preserve">
          <source>In the following example the first call to &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; does not use a timeout and asks for the write to reach 1 replica. It returns with success. In the second attempt instead we put a timeout, and ask for the replication of the write to two replicas. Since there is a single replica available, after one second &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; unblocks and returns 1, the number of replicas reached.</source>
          <target state="translated">다음 예제에서 &lt;a href=&quot;wait&quot;&gt;WAIT에&lt;/a&gt; 대한 첫 번째 호출 은 시간 종료를 사용하지 않고 쓰기가 1 개의 복제본에 도달하도록 요청합니다. 성공으로 돌아옵니다. 두 번째 시도에서는 시간 초과를 설정하고 두 복제본에 대한 쓰기 복제를 요청합니다. 사용 가능한 단일 복제본이 있으므로 1 초 동안 &lt;a href=&quot;wait&quot;&gt;WAIT가&lt;/a&gt; 차단을 해제하고 1을 반환하면 복제본 수에 도달합니다.</target>
        </trans-unit>
        <trans-unit id="8e23d6a61281506fa3e98f414bcf348728e15107" translate="yes" xml:space="preserve">
          <source>In the following example we can see how floats and arrays containing nils and keys are handled:</source>
          <target state="translated">다음 예제에서 nil과 키를 포함하는 float와 배열이 어떻게 처리되는지 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="275502ca7bb30b2b024cd13d4001c3a1615096d6" translate="yes" xml:space="preserve">
          <source>In the following example we can see how floats and arrays with nils are handled:</source>
          <target state="translated">다음 예제에서는 nil이있는 float 및 배열이 처리되는 방식을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67aa25f5afe2285456ce925944008c892a8bde6a" translate="yes" xml:space="preserve">
          <source>In the following example we'll show why the command must not just remove a given node from the nodes table, but also prevent it for being re-inserted again for some time.</source>
          <target state="translated">다음 예에서는 명령이 노드 테이블에서 지정된 노드를 제거해야 할뿐만 아니라 일정 시간 동안 다시 삽입되지 않도록하는 이유를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1b27ba03d8db2c5155774200622adb0e3f3e2724" translate="yes" xml:space="preserve">
          <source>In the following example you can see how the encoding changes once Redis is no longer able to use the space saving encoding.</source>
          <target state="translated">다음 예에서 Redis가 더 이상 공간 절약 인코딩을 사용할 수없는 경우 인코딩이 어떻게 변경되는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d52481dfbaf58234ade345bdada825c509d89e9a" translate="yes" xml:space="preserve">
          <source>In the specific case of the implementation of &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt;, Redis remembers, for each client, the replication offset of the produced replication stream when a given write command was executed in the context of a given client. When &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; is called Redis checks if the specified number of replicas already acknowledged this offset or a greater one.</source>
          <target state="translated">&lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; 구현의 특정 경우 , Redis는 주어진 쓰기 명령이 주어진 클라이언트의 컨텍스트에서 실행될 때 생성 된 복제 스트림의 복제 오프셋을 각 클라이언트에 대해 기억합니다. &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; 가 호출 되면 Redis는 지정된 수의 복제본이 이미이 오프셋 이상을 승인했는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="903ead95cd2a4a5b9cbb852a8e750aedc79fee51" translate="yes" xml:space="preserve">
          <source>In this case, &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; will auto-complete the start interval with &lt;code&gt;-0&lt;/code&gt; and end interval with &lt;code&gt;-18446744073709551615&lt;/code&gt;, in order to return all the entries that were generated between a given millisecond and the end of the other specified millisecond. This also means that repeating the same millisecond two times, we get all the entries within such millisecond, because the sequence number range will be from zero to the maximum.</source>
          <target state="translated">이 경우 &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 는 지정된 밀리 초와 다른 지정된 밀리 초의 끝 사이에 생성 된 모든 항목을 리턴하기 위해 시작 간격을 &lt;code&gt;-0&lt;/code&gt; 으로 , 종료 간격을 &lt;code&gt;-18446744073709551615&lt;/code&gt; 로 자동 완성합니다 . 이것은 동일한 밀리 초를 두 번 반복하면 시퀀스 번호 범위가 0에서 최대가되기 때문에 그러한 밀리 초 내에 모든 항목을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9a9dd8640d5d9c354f3497144f8f471bfe5130bf" translate="yes" xml:space="preserve">
          <source>In this form the command returns general information about the stream stored at the specified key.</source>
          <target state="translated">이 형식으로 명령은 지정된 키에 저장된 스트림에 대한 일반 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fb6df0247f8ef1848f5f3284e1802dec98219082" translate="yes" xml:space="preserve">
          <source>In this form the command returns the entire state of the stream, including entries, groups, consumers and PELs. This form is available since Redis 6.0.</source>
          <target state="translated">이 형식에서 명령은 항목, 그룹, 소비자 및 PEL을 포함하여 스트림의 전체 상태를 반환합니다. 이 양식은 Redis 6.0부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9dc316159e0ab75070b1301d7b7adb86e569cda" translate="yes" xml:space="preserve">
          <source>In this form we just get as output all the consumer groups associated with the stream:</source>
          <target state="translated">이 형식에서는 스트림과 관련된 모든 소비자 그룹을 출력으로 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ddaa9f098110e2f5ed979aa965f072762268f6b4" translate="yes" xml:space="preserve">
          <source>In this form, the command outputs the total number of pending messages for this consumer group, which is one, followed by the smallest and greatest ID among the pending messages, and then list every consumer in the consumer group with at least one pending message, and the number of pending messages it has.</source>
          <target state="translated">이 양식에서이 명령은이 소비자 그룹에 대해 보류중인 메시지의 총 수 (하나는 다음에 보류중인 메시지 중 가장 작고 가장 큰 ID)를 출력 한 다음 소비자 그룹의 모든 소비자를 하나 이상의 보류중인 메시지와 함께 나열합니다. 보류중인 메시지 수</target>
        </trans-unit>
        <trans-unit id="7449f50cc271410bffecdb508cde8a6a6c5d9a68" translate="yes" xml:space="preserve">
          <source>In this particular case, running a single &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; client can reduce the throughput by more than 50%. Running more &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; clients will reduce throughput even more.</source>
          <target state="translated">이 경우 단일 &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 클라이언트를 실행 하면 처리량을 50 % 이상 줄일 수 있습니다. 더 많은 &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 클라이언트를 실행 하면 처리량이 훨씬 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="9499b337b96eb666a58f2a5ab4a4329e2007a622" translate="yes" xml:space="preserve">
          <source>In this replication mode, while Lua scripts are executed, Redis collects all the commands executed by the Lua scripting engine that actually modify the dataset. When the script execution finishes, the sequence of commands that the script generated are wrapped into a MULTI / EXEC transaction and are sent to replicas and AOF.</source>
          <target state="translated">이 복제 모드에서 Lua 스크립트가 실행되는 동안 Redis는 실제로 데이터 세트를 수정하는 Lua 스크립팅 엔진이 실행하는 모든 명령을 수집합니다. 스크립트 실행이 완료되면 스크립트가 생성 한 명령 시퀀스가 ​​MULTI / EXEC 트랜잭션으로 랩핑되어 복제본 및 AOF로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="9c59d992fdad2d2103f7862e5997a95c45fa8f53" translate="yes" xml:space="preserve">
          <source>In this way the example consumer code will fetch only new messages, process them, and acknowledge them via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;. However the example code above is not complete, because it does not handle recovering after a crash. What will happen if we crash in the middle of processing messages, is that our messages will remain in the pending entries list, so we can access our history by giving &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; initially an ID of 0, and performing the same loop. Once providing an ID of 0 the reply is an empty set of messages, we know that we processed and acknowledged all the pending messages: we can start to use &lt;code&gt;&amp;gt;&lt;/code&gt; as ID, in order to get the new messages and rejoin the consumers that are processing new things.</source>
          <target state="translated">이러한 방식으로 예제 소비자 코드는 새 메시지 만 가져 와서 처리하고 &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt; 를 통해 확인합니다 . 그러나 위의 예제 코드는 충돌 후 복구를 처리하지 않기 때문에 완전하지 않습니다. 메시지 처리 중에 충돌이 발생하면 메시지가 보류중인 항목 목록에 남아 있으므로 &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP에&lt;/a&gt; 처음에 ID 0 을 부여 하고 동일한 루프를 수행하여 기록에 액세스 할 수 있습니다 . 0의 ID를 제공하면 응답은 빈 메시지 집합이므로 모든 보류중인 메시지를 처리하고 확인했음을 알고 있습니다 . 새 메시지를 가져오고 처리중인 소비자에 다시 참여하기 위해 &lt;code&gt;&amp;gt;&lt;/code&gt; 를 ID 로 사용할 수 있습니다. 새로운 것들.</target>
        </trans-unit>
        <trans-unit id="ef44dcb3d65131c01d1f4f06af638521f8511b76" translate="yes" xml:space="preserve">
          <source>In this way the example consumer code will fetch only new messages, process them, and acknowledge them via &lt;a href=&quot;xack&quot;&gt;XACK&lt;/a&gt;. However the example code above is not complete, because it does not handle recovering after a crash. What will happen if we crash in the middle of processing messages, is that our messages will remain in the pending entries list, so we can access our history by giving &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; initially an ID of 0, and performing the same loop. Once providing and ID of 0 the reply is an empty set of messages, we know that we processed and acknowledged all the pending messages: we can start to use &lt;code&gt;&amp;gt;&lt;/code&gt; as ID, in order to get the new messages and rejoin the consumers that are processing new things.</source>
          <target state="translated">이런 식으로 소비자 코드 예제는 새 메시지 만 가져 와서 처리하고 &lt;a href=&quot;xack&quot;&gt;XACK을&lt;/a&gt; 통해 승인합니다 . 그러나 위의 예제 코드는 충돌 후 복구를 처리하지 않기 때문에 완전하지 않습니다. 메시지 처리 중에 충돌이 발생하면 메시지가 보류중인 항목 목록에 남아 있으므로 &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP에&lt;/a&gt; 초기에 ID 0 을 부여 하고 동일한 루프를 수행하여 기록에 액세스 할 수 있습니다 . 응답을 제공하고 ID가 0이면 빈 메시지 세트가 처리됩니다. 보류중인 모든 메시지를 처리하고 확인 했습니다. 새 메시지를 가져오고 처리중인 소비자에 다시 참여하기 위해 &lt;code&gt;&amp;gt;&lt;/code&gt; 를 ID 로 사용할 수 있습니다. 새로운 것들.</target>
        </trans-unit>
        <trans-unit id="0c6aff080ab580caca11c078c7c0fd0c074cc4b5" translate="yes" xml:space="preserve">
          <source>In this way when a node in migrating state generates an &lt;code&gt;ASK&lt;/code&gt; redirection, the client contacts the target node, sends &lt;code&gt;ASKING&lt;/code&gt;, and immediately after sends the command. This way commands about non-existing keys in the old node or keys already migrated to the target node are executed in the target node, so that:</source>
          <target state="translated">이러한 방식으로 마이그레이션 상태의 노드가 &lt;code&gt;ASK&lt;/code&gt; 경로 재 지정을 생성 하면 클라이언트는 대상 노드에 접속하여 &lt;code&gt;ASKING&lt;/code&gt; 을 보낸 후 명령을 보낸 직후에 보냅니다. 이 방법으로 기존 노드에 존재하지 않는 키 또는 대상 노드로 이미 마이그레이션 된 키에 대한 명령이 대상 노드에서 실행되므로 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a4976fd385ad81414ef5f0b5eb1d542ebee200c" translate="yes" xml:space="preserve">
          <source>Incomplete IDs</source>
          <target state="translated">불완전한 ID</target>
        </trans-unit>
        <trans-unit id="d076531fdc3e2f8747b11778603627c7ff4c3c03" translate="yes" xml:space="preserve">
          <source>Increment the specified &lt;code&gt;field&lt;/code&gt; of a hash stored at &lt;code&gt;key&lt;/code&gt;, and representing a floating point number, by the specified &lt;code&gt;increment&lt;/code&gt;. If the increment value is negative, the result is to have the hash field value &lt;strong&gt;decremented&lt;/strong&gt; instead of incremented. If the field does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if one of the following conditions occur:</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장되고 부동 소수점 숫자를 나타내는 해시 의 지정된 &lt;code&gt;field&lt;/code&gt; 를 지정된 &lt;code&gt;increment&lt;/code&gt; . 증분 값이 음수이면 해시 필드 값 이 증분 대신 &lt;strong&gt;감소&lt;/strong&gt; 됩니다. 필드가 존재하지 않으면 조작을 수행하기 전에 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 다음 조건 중 하나가 발생하면 오류가 반환됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0b2569a3073ebcb62549ecb7ec5a99e5e6f20a57" translate="yes" xml:space="preserve">
          <source>Increment the string representing a floating point number stored at &lt;code&gt;key&lt;/code&gt; by the specified &lt;code&gt;increment&lt;/code&gt;. By using a negative &lt;code&gt;increment&lt;/code&gt; value, the result is that the value stored at the key is decremented (by the obvious properties of addition). If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if one of the following conditions occur:</source>
          <target state="translated">지정된 &lt;code&gt;increment&lt;/code&gt; 만큼 &lt;code&gt;key&lt;/code&gt; 에 저장된 부동 소수점 숫자를 나타내는 문자열을 증가시킵니다 . 음의 &lt;code&gt;increment&lt;/code&gt; 값 을 사용 하면 키에 저장된 값이 추가되는 명백한 속성에 따라 감소합니다. 키가 없으면 조작을 수행하기 전에 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 다음 조건 중 하나가 발생하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b0ab00f78f69567a82e2e724fbf2c011708c66b2" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;field&lt;/code&gt; in the hash stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, a new key holding a hash is created. If &lt;code&gt;field&lt;/code&gt; does not exist the value is set to &lt;code&gt;0&lt;/code&gt; before the operation is performed.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 해시의 &lt;code&gt;field&lt;/code&gt; 에 저장된 숫자 를 &lt;code&gt;increment&lt;/code&gt; 만큼 증가시킵니다 . 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 해시를 들고 새 키가 생성됩니다. 경우 &lt;code&gt;field&lt;/code&gt; 값이 존재하지 않음으로 설정되어 &lt;code&gt;0&lt;/code&gt; 동작이 수행되기 전에.</target>
        </trans-unit>
        <trans-unit id="05fa8f17b5cc5360627e65f0e1bfbcb74f909616" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 숫자 를 &lt;code&gt;increment&lt;/code&gt; 만큼 증가시킵니다 . 키가 없으면 조작을 수행하기 전에 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 키에 잘못된 유형의 값이 있거나 정수로 표현할 수없는 문자열이 포함 된 경우 오류가 리턴됩니다. 이 연산은 64 비트 부호있는 정수로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="f9bd9898aaa3a2048914100ede9b89ccf7adc73a" translate="yes" xml:space="preserve">
          <source>Increments the number stored at &lt;code&gt;key&lt;/code&gt; by one. If the key does not exist, it is set to &lt;code&gt;0&lt;/code&gt; before performing the operation. An error is returned if the key contains a value of the wrong type or contains a string that can not be represented as integer. This operation is limited to 64 bit signed integers.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 숫자 를 하나씩 증가시킵니다 . 키가 없으면 조작을 수행하기 전에 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 키에 잘못된 유형의 값이 있거나 정수로 표현할 수없는 문자열이 포함 된 경우 오류가 리턴됩니다. 이 연산은 64 비트 부호있는 정수로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="b3b4497f3f9f641c1f07a98ba2294810e7c1c3a5" translate="yes" xml:space="preserve">
          <source>Increments the score of &lt;code&gt;member&lt;/code&gt; in the sorted set stored at &lt;code&gt;key&lt;/code&gt; by &lt;code&gt;increment&lt;/code&gt;. If &lt;code&gt;member&lt;/code&gt; does not exist in the sorted set, it is added with &lt;code&gt;increment&lt;/code&gt; as its score (as if its previous score was &lt;code&gt;0.0&lt;/code&gt;). If &lt;code&gt;key&lt;/code&gt; does not exist, a new sorted set with the specified &lt;code&gt;member&lt;/code&gt; as its sole member is created.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 정렬 된 세트 의 &lt;code&gt;member&lt;/code&gt; 점수를 &lt;code&gt;increment&lt;/code&gt; 만큼 증가시킵니다 . 경우 &lt;code&gt;member&lt;/code&gt; 정렬 된 세트에 존재하지 않는, 그것은과 추가 &lt;code&gt;increment&lt;/code&gt; 의 점수로 (이전 점수 인 것처럼 &lt;code&gt;0.0&lt;/code&gt; ). 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 지정된 가지는 새로운 소트 세트 &lt;code&gt;member&lt;/code&gt; 의 단독 구성원으로 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="b9e98de9b6972c3697024196bb1cf498f5df1583" translate="yes" xml:space="preserve">
          <source>Information about slots propagation and warnings</source>
          <target state="translated">슬롯 전파 및 경고에 대한 정보</target>
        </trans-unit>
        <trans-unit id="2adcb9298d658f855997a0893baf52120d4879fe" translate="yes" xml:space="preserve">
          <source>Initiates a replication stream from the master.</source>
          <target state="translated">마스터에서 복제 스트림을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="df92aa3b0e06eb79bf7c8f7098db769523ac9333" translate="yes" xml:space="preserve">
          <source>Insert all the specified values at the head of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as empty list before performing the push operations. When &lt;code&gt;key&lt;/code&gt; holds a value that is not a list, an error is returned.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 목록의 헤드에 지정된 모든 값을 삽입하십시오 . 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 그것은 푸시 작업을 수행하기 전에 빈 목록으로 작성됩니다. 때 &lt;code&gt;key&lt;/code&gt; 목록이 아닌 값을 보유하고 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d56f1eeeec0b6889ab12fc76a629d9cf4f377993" translate="yes" xml:space="preserve">
          <source>Insert all the specified values at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;. If &lt;code&gt;key&lt;/code&gt; does not exist, it is created as empty list before performing the push operation. When &lt;code&gt;key&lt;/code&gt; holds a value that is not a list, an error is returned.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 에 저장된 목록의 끝에 지정된 모든 값을 삽입하십시오 . 경우 &lt;code&gt;key&lt;/code&gt; 존재하지 않는, 그것은 푸시 작업을 수행하기 전에 빈 목록으로 작성됩니다. 때 &lt;code&gt;key&lt;/code&gt; 목록이 아닌 값을 보유하고 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="76405c7e5205b84962c7bcad1e955500c9c01bf2" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;element&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt; either before or after the reference value &lt;code&gt;pivot&lt;/code&gt;.</source>
          <target state="translated">참조 값 &lt;code&gt;pivot&lt;/code&gt; 앞 또는 뒤에 &lt;code&gt;key&lt;/code&gt; 저장된 목록에 &lt;code&gt;element&lt;/code&gt; 를 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="41914bb38b36cf790ad6dea5c850ff4f739bdf2f" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; at the head of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 이미 존재하고리스트를 보유하고있는 경우에만 &lt;code&gt;key&lt;/code&gt; 에 저장된리스트의 헤드에 &lt;code&gt;value&lt;/code&gt; 을 삽입합니다 . &lt;a href=&quot;lpush&quot;&gt;LPUSH와는&lt;/a&gt; 반대로 &lt;code&gt;key&lt;/code&gt; 가 아직 없으면 작업이 수행 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="483c4cdd37e1303cef072b494af9c173f5ba1e3a" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 이미 존재하고 목록을 보유하는 경우에만 &lt;code&gt;key&lt;/code&gt; 에 저장된 목록의 끝에 &lt;code&gt;value&lt;/code&gt; 을 삽입합니다 . &lt;a href=&quot;rpush&quot;&gt;RPUSH와는&lt;/a&gt; 반대로 &lt;code&gt;key&lt;/code&gt; 가 아직 없으면 작업이 수행 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d817081530a979658954b262ec5b27debd913f6b" translate="yes" xml:space="preserve">
          <source>Inserts &lt;code&gt;value&lt;/code&gt; in the list stored at &lt;code&gt;key&lt;/code&gt; either before or after the reference value &lt;code&gt;pivot&lt;/code&gt;.</source>
          <target state="translated">참조 값 &lt;code&gt;pivot&lt;/code&gt; 이전 또는 이후 에 &lt;code&gt;key&lt;/code&gt; 저장된 목록에 &lt;code&gt;value&lt;/code&gt; 을 삽입합니다 .</target>
        </trans-unit>
        <trans-unit id="5796a562198c08a1669595d2cc6b1a7851ecca7f" translate="yes" xml:space="preserve">
          <source>Inserts specified values at the head of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 이미 존재하고 목록을 보유하는 경우에만 &lt;code&gt;key&lt;/code&gt; 에 저장된 목록의 헤드에 지정된 값을 삽입합니다 . &lt;a href=&quot;lpush&quot;&gt;LPUSH&lt;/a&gt; 와 달리 &lt;code&gt;key&lt;/code&gt; 가 아직 존재하지 않으면 아무 작업도 수행 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea8b02564feb5003f96c3e70699d8d56ef9971fc" translate="yes" xml:space="preserve">
          <source>Inserts specified values at the tail of the list stored at &lt;code&gt;key&lt;/code&gt;, only if &lt;code&gt;key&lt;/code&gt; already exists and holds a list. In contrary to &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt;, no operation will be performed when &lt;code&gt;key&lt;/code&gt; does not yet exist.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 가 이미 존재하고 목록을 보유하는 경우에만 &lt;code&gt;key&lt;/code&gt; 에 저장된 목록의 끝에 지정된 값을 삽입합니다 . &lt;a href=&quot;rpush&quot;&gt;RPUSH&lt;/a&gt; 와 달리 &lt;code&gt;key&lt;/code&gt; 가 아직 없으면 아무 작업도 수행 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0b2cd21b122572712ccbe21dcfb324c039d60a6f" translate="yes" xml:space="preserve">
          <source>Instead Redis 2.4 works in a different way: clients are served &lt;em&gt;in the context&lt;/em&gt; of the push operation, so as long as &lt;code&gt;LPUSH foo a b c&lt;/code&gt; starts pushing the first element to the list, it will be delivered to the Client &lt;strong&gt;A&lt;/strong&gt;, that will receive &lt;code&gt;a&lt;/code&gt; (the first element pushed).</source>
          <target state="translated">대신 레디 스는 다른 방법으로 2.4 작품 : 클라이언트 서비스가 제공되는 &lt;em&gt;상황에서&lt;/em&gt; 로 너무 오래, 푸쉬 동작의 &lt;code&gt;LPUSH foo a b c&lt;/code&gt; 목록에 첫 번째 요소를 밀어 시작, 그것은 클라이언트에 전달됩니다 , 그 받게됩니다 &lt;code&gt;a&lt;/code&gt; ( 첫 번째 요소가 푸시되었습니다).&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="895d5878b1e7aebe2b652bf4030490cc648a385d" translate="yes" xml:space="preserve">
          <source>Instead of releasing the lock with &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt;, send a script that only removes the key if the value matches.</source>
          <target state="translated">&lt;a href=&quot;del&quot;&gt;DEL로&lt;/a&gt; 잠금을 해제하는 대신 값이 일치하는 경우에만 키를 제거하는 스크립트를 보내십시오.</target>
        </trans-unit>
        <trans-unit id="e1fb6600644f1089e2f02671b1d169470ef167d3" translate="yes" xml:space="preserve">
          <source>Instead of setting a fixed string, set a non-guessable large random string, called token.</source>
          <target state="translated">고정 문자열을 설정하는 대신 토큰이라고하는 추측 할 수없는 큰 임의 문자열을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="7e8138295a5156481cc0eb58921ff5f1b45d907b" translate="yes" xml:space="preserve">
          <source>Instead, if the lock is expired because the Unix time at &lt;code&gt;lock.foo&lt;/code&gt; is older than the current Unix time, C4 tries to perform:</source>
          <target state="translated">대신 &lt;code&gt;lock.foo&lt;/code&gt; 의 Unix 시간 이 현재 Unix 시간보다 오래 되어 잠금이 만료 되면 C4는 다음을 수행하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="9e41d77e11789212e3a04485592bea0019722472" translate="yes" xml:space="preserve">
          <source>Instruct Redis to start an &lt;a href=&quot;https://redis.io/topics/persistence#append-only-file&quot;&gt;Append Only File&lt;/a&gt; rewrite process. The rewrite will create a small optimized version of the current Append Only File.</source>
          <target state="translated">Redis에 &lt;a href=&quot;https://redis.io/topics/persistence#append-only-file&quot;&gt;Append Only File&lt;/a&gt; 다시 쓰기 프로세스 를 시작하도록 지시하십시오 . 다시 쓰면 현재 추가 전용 파일의 작은 최적화 버전이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="5d3a484e0575c563f1fd55a805b93fd40c42e60d" translate="yes" xml:space="preserve">
          <source>Integer reply</source>
          <target state="translated">정수 회신</target>
        </trans-unit>
        <trans-unit id="b78aed63c34c1be3f06c6bc59978ffe5ffe055ac" translate="yes" xml:space="preserve">
          <source>Introduction to EVAL</source>
          <target state="translated">EVAL 소개</target>
        </trans-unit>
        <trans-unit id="698c191721344bee0279a531fba2023586cfe9e4" translate="yes" xml:space="preserve">
          <source>It can also take the following values:</source>
          <target state="translated">다음 값을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="35178e7f69534d7802151005b608f5f33b33d650" translate="yes" xml:space="preserve">
          <source>It contains a 64-bit checksum that is used to make sure errors will be detected. The &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; command makes sure to check the checksum before synthesizing a key using the serialized value.</source>
          <target state="translated">여기에는 오류가 감지되는지 확인하는 데 사용되는 64 비트 체크섬이 포함되어 있습니다. &lt;a href=&quot;restore&quot;&gt;RESTORE&lt;/a&gt; 명령은 직렬화 된 값을 사용하여 키를 합성하기 전에 체크섬을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="d3cca1eb042dc5b5456d254387aa0bc9411f0e98" translate="yes" xml:space="preserve">
          <source>It is &lt;strong&gt;very important&lt;/strong&gt; to understand that you should use the &lt;code&gt;$&lt;/code&gt; ID only for the first call to &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt;. Later the ID should be the one of the last reported item in the stream, otherwise you could miss all the entries that are added in between.</source>
          <target state="translated">&lt;a href=&quot;xread&quot;&gt;XREAD를&lt;/a&gt; 처음 호출 할 때만 &lt;code&gt;$&lt;/code&gt; ID 를 사용해야한다는 것을 이해하는 것이 &lt;strong&gt;매우 중요&lt;/strong&gt; 합니다 . 나중에 ID는 스트림에서 마지막으로보고 된 항목 중 하나 여야합니다. 그렇지 않으면 사이에 추가 된 모든 항목을 놓칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80e58a0abe147b5052a4b292609ed6e990761a9f" translate="yes" xml:space="preserve">
          <source>It is also possible to &lt;code&gt;GET&lt;/code&gt; the element itself using the special pattern &lt;code&gt;#&lt;/code&gt;:</source>
          <target state="translated">특수 패턴 &lt;code&gt;#&lt;/code&gt; 을 사용하여 요소 자체 를 &lt;code&gt;GET&lt;/code&gt; 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98ad7fac6612120c355f6682c4b1a531c848bd30" translate="yes" xml:space="preserve">
          <source>It is also possible to compute the LCS between the content of two keys:</source>
          <target state="translated">두 키의 내용 사이에서 LCS를 계산할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b33a1c4c42a6d6feaa0bef4f81f6ace9278b22e9" translate="yes" xml:space="preserve">
          <source>It is also possible to use the &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; and &lt;a href=&quot;setrange&quot;&gt;SETRANGE&lt;/a&gt; string commands to efficiently access a range of bit offsets in a bitmap. Below is a sample implementation in idiomatic Redis Lua scripting that can be run with the &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; command:</source>
          <target state="translated">사용하는 것도 가능하다 &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; 및 &lt;a href=&quot;setrange&quot;&gt;SetRange를&lt;/a&gt; 효율적으로 비트 맵 오프셋들의 범위에 액세스 할 문자열 명령. 다음은 &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt; 명령 으로 실행할 수있는 관용적 Redis Lua 스크립팅의 샘플 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="344f6904cadbf67817bc580b98a14096a5ecb81b" translate="yes" xml:space="preserve">
          <source>It is important to note that step 3 is the only time when a Redis Cluster node will create a new config epoch without agreement from other nodes. This only happens when a manual configuration is operated. However it is impossible that this creates a non-transient setup where two nodes have the same config epoch, since Redis Cluster uses a config epoch collision resolution algorithm.</source>
          <target state="translated">3 단계는 Redis 클러스터 노드가 다른 노드와의 합의없이 새 설정 시대를 생성 할 유일한 시간이라는 점에 유의해야합니다. 수동 구성이 작동하는 경우에만 발생합니다. 그러나 Redis Cluster는 구성 에포크 충돌 해결 알고리즘을 사용하므로 두 노드가 동일한 구성 에포크를 갖는 비 일시적 설정을 만드는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="75e2007346bb90c5a30dbb62b43b72fa8d6f2346" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;strong&gt;MATCH&lt;/strong&gt; filter is applied after elements are retrieved from the collection, just before returning data to the client. This means that if the pattern matches very little elements inside the collection, &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; will likely return no elements in most iterations. An example is shown below:</source>
          <target state="translated">것이 중요합니다 &lt;strong&gt;MATCH의&lt;/strong&gt; 요소가 바로 클라이언트에 데이터를 반환하기 전에 컬렉션에서 검색 한 후 필터가 적용됩니다. 즉, 패턴이 컬렉션 내의 매우 적은 요소와 일치하면 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 은 대부분의 반복에서 요소를 반환하지 않을 것입니다. 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="05004148ae7826284b52ac4960264eb06c78f9cd" translate="yes" xml:space="preserve">
          <source>It is important to note that the &lt;strong&gt;TYPE&lt;/strong&gt; filter is also applied after elements are retrieved from the database, so the option does not reduce the amount of work the server has to do to complete a full iteration, and for rare types you may receive no elements in many iterations.</source>
          <target state="translated">주의하는 것이 중요하다 &lt;strong&gt;TYPE의&lt;/strong&gt; 요소가 데이터베이스에서 검색 한 후 옵션은 서버 전체 반복을 완료하기 위해 수행하는 작업의 양을 감소하지 않도록 필터도 적용되며, 희귀 한 유형의 당신은 어떤 요소가 나타날 수 많은 반복에서.</target>
        </trans-unit>
        <trans-unit id="6a489978b872ba9db6fad974b8d4112fa3f8ddea" translate="yes" xml:space="preserve">
          <source>It is important to understand that this command &lt;em&gt;fans out&lt;/em&gt; to all the clients that are waiting for the same range of IDs, so every consumer will get a copy of the data, unlike to what happens when blocking list pop operations are used.</source>
          <target state="translated">이 명령 은 동일한 범위의 ID를 기다리고있는 모든 클라이언트로 &lt;em&gt;팬 아웃&lt;/em&gt; 되므로 차단 목록 팝 작업을 사용할 때 발생하는 것과는 달리 모든 소비자가 데이터 복사본을 받게 된다는 점을 이해하는 것이 중요합니다 .</target>
        </trans-unit>
        <trans-unit id="c6bd66f1e8688cc2dae7b39af1276712b3930256" translate="yes" xml:space="preserve">
          <source>It is important to understand that this command is &lt;em&gt;fans out&lt;/em&gt; to all the clients that are waiting for the same range of IDs, so every consumer will get a copy of the data, unlike to what happens when blocking list pop operations are used.</source>
          <target state="translated">이 명령은 동일한 범위의 ID를 기다리는 모든 클라이언트에 대한 &lt;em&gt;팬 아웃&lt;/em&gt; 이므로, 목록 팝 조작을 사용할 때 발생하는 것과 달리 모든 소비자가 데이터 사본을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c855a69b0dba328dc98ac3bd3b714e220d6e64d4" translate="yes" xml:space="preserve">
          <source>It is never repeated, so if &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt; returns the same number, the caller can be sure that the underlying client did not disconnect and reconnect the connection, but it is still the same connection.</source>
          <target state="translated">반복되지 않으므로 &lt;a href=&quot;client-id&quot;&gt;CLIENT ID&lt;/a&gt; 가 동일한 번호를 리턴하면 호출자는 기본 클라이언트가 연결을 끊었다가 다시 연결하지 않았지만 여전히 동일한 연결인지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18c6232a5064b912687168695e794e952ea903ef" translate="yes" xml:space="preserve">
          <source>It is not possible for the key to get lost in the event of a timeout, but the client calling &lt;a href=&quot;migrate&quot;&gt;MIGRATE&lt;/a&gt;, in the event of a timeout error, should check if the key is &lt;em&gt;also&lt;/em&gt; present in the target instance and act accordingly.</source>
          <target state="translated">시간 초과시 키가 유실되지는 않지만 시간 종료 오류시 &lt;a href=&quot;migrate&quot;&gt;MIGRATE를&lt;/a&gt; 호출하는 클라이언트 는 키가 대상 인스턴스 &lt;em&gt;에도&lt;/em&gt; 존재 하는지 확인 하고 그에 따라 조치해야합니다.</target>
        </trans-unit>
        <trans-unit id="7a383107db035b97cc0f3e4c5c6844b9b02c255f" translate="yes" xml:space="preserve">
          <source>It is possible for an infinite number of clients to iterate the same collection at the same time, as the full state of the iterator is in the cursor, that is obtained and returned to the client at every call. Server side no state is taken at all.</source>
          <target state="translated">반복자의 전체 상태가 커서에있을 때마다 무한한 수의 클라이언트가 동일한 콜렉션을 반복 할 수 있으며, 이는 호출 할 때마다 확보되어 클라이언트로 리턴됩니다. 서버 측 상태가 전혀 없습니다.</target>
        </trans-unit>
        <trans-unit id="a485e395caaea14094a0b8ec68e5e3e0a8915e73" translate="yes" xml:space="preserve">
          <source>It is possible to call &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; using as argument a key that already has an existing expire set. In this case the time to live of a key is &lt;em&gt;updated&lt;/em&gt; to the new value. There are many useful applications for this, an example is documented in the &lt;em&gt;Navigation session&lt;/em&gt; pattern section below.</source>
          <target state="translated">기존 만료 세트가 이미있는 키를 인수로 사용하여 &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; 를 호출 할 수 있습니다 . 이 경우 키를 사용하는 시간 이 새로운 값으로 &lt;em&gt;업데이트&lt;/em&gt; 됩니다. 이에 대한 유용한 응용 프로그램이 많이 있으며 아래 의 &lt;em&gt;탐색 세션&lt;/em&gt; 패턴 섹션 에 예제가 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7f5fb81c26b1abadccf00465e65f7fa65dea140" translate="yes" xml:space="preserve">
          <source>It is possible to call &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; inside Lua scripts like with normal clients, However one subtle aspect of the behavior changes between Redis 2.8.11 and Redis 2.8.12. Before the 2.8.12 release the database selected by the Lua script was &lt;em&gt;transferred&lt;/em&gt; to the calling script as current database. Starting from Redis 2.8.12 the database selected by the Lua script only affects the execution of the script itself, but does not modify the database selected by the client calling the script.</source>
          <target state="translated">일반적인 클라이언트와 같이 Lua 스크립트 내에서 &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; 를 호출 할 수 있지만 동작의 미묘한 측면 중 하나는 Redis 2.8.11과 Redis 2.8.12 사이에서 변경됩니다. 2.8.12 릴리스 &lt;em&gt;이전&lt;/em&gt; 에 Lua 스크립트에 의해 선택된 데이터베이스는 현재 데이터베이스로서 호출 스크립트 에 &lt;em&gt;전송&lt;/em&gt; 되었습니다. Redis 2.8.12부터 Lua 스크립트에 의해 선택된 데이터베이스는 스크립트 자체의 실행에만 영향을 미치지 만 스크립트를 호출하는 클라이언트가 선택한 데이터베이스는 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0958a04d7552830b3684f48a6c436807896935c0" translate="yes" xml:space="preserve">
          <source>It is possible to call Redis commands from a Lua script using two different Lua functions:</source>
          <target state="translated">두 가지 다른 Lua 함수를 사용하여 Lua 스크립트에서 Redis 명령을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0a209f43840d7a1f6f04e02663cf8a792cab884" translate="yes" xml:space="preserve">
          <source>It is possible to entirely remove the connection name setting it to the empty string, that is not a valid connection name since it serves to this specific purpose.</source>
          <target state="translated">연결 이름을 빈 문자열로 설정하면 연결 이름을 완전히 제거 할 수 있습니다. 이는이 특정 목적에 부합하므로 유효한 연결 이름이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="db23050fd5ba19a3417f8b624df748886d949634" translate="yes" xml:space="preserve">
          <source>It is possible to get just the length of the slow log using the command &lt;strong&gt;SLOWLOG LEN&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;SLOWLOG LEN&lt;/strong&gt; 명령을 사용하여 느린 로그의 길이 만 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db19130f0bd00fca33ef9a77ffc0a1ce2466b31d" translate="yes" xml:space="preserve">
          <source>It is possible to give the command in the following special form in order to make it more efficient:</source>
          <target state="translated">명령을보다 효율적으로 만들기 위해 다음 특수 양식으로 명령을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e24f1bfbfced0e2fc3e90a67dd138360e0226aa2" translate="yes" xml:space="preserve">
          <source>It is possible to limit the size of the stream to a maximum number of elements using the &lt;strong&gt;MAXLEN&lt;/strong&gt; option.</source>
          <target state="translated">&lt;strong&gt;MAXLEN&lt;/strong&gt; 옵션을 사용하여 스트림 크기를 최대 요소 수로 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="712b25407c86c3da9193a8517aa1f28826626087" translate="yes" xml:space="preserve">
          <source>It is possible to limit the size of the stream to a maximum number of elements using the &lt;strong&gt;MAXLEN&lt;/strong&gt; option. By default, or when used with the &lt;code&gt;=&lt;/code&gt; argument, the &lt;strong&gt;MAXLEN&lt;/strong&gt; option performs an exact trimming. That means that the trimmed stream's length will be exactly the minimum between its original length and the specified maximum length.</source>
          <target state="translated">&lt;strong&gt;MAXLEN&lt;/strong&gt; 옵션을 사용하여 스트림의 크기를 최대 요소 수로 제한 할 수 있습니다. 기본적으로 또는 &lt;code&gt;=&lt;/code&gt; 인수 와 함께 사용되는 경우 &lt;strong&gt;MAXLEN&lt;/strong&gt; 옵션은 정확한 트리밍을 수행합니다. 즉, 트리밍 된 스트림의 길이는 원래 길이와 지정된 최대 길이 사이의 최소 길이가됩니다.</target>
        </trans-unit>
        <trans-unit id="ee2ff105ab5c2c719dd08acac18181138935047b" translate="yes" xml:space="preserve">
          <source>It is possible to make this system more robust modifying the unlock schema as follows:</source>
          <target state="translated">다음과 같이 잠금 해제 스키마를 수정하여이 시스템을보다 강력하게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="493e108b328a9e96e14d97d5ac7db908da18cbb1" translate="yes" xml:space="preserve">
          <source>It is possible to modify the maximum time a script can be executed with millisecond precision, either via &lt;code&gt;redis.conf&lt;/code&gt; or using the CONFIG GET / CONFIG SET command. The configuration parameter affecting max execution time is called &lt;code&gt;lua-time-limit&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;redis.conf&lt;/code&gt; 또는 CONFIG GET / CONFIG SET 명령을 사용하여 밀리 초 단위로 스크립트를 실행할 수있는 최대 시간을 수정할 수 있습니다 . 최대 실행 시간에 영향을주는 구성 매개 변수를 &lt;code&gt;lua-time-limit&lt;/code&gt; 라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="16570d1ed8c0ba499d85c4796bacd5587bfbf468" translate="yes" xml:space="preserve">
          <source>It is possible to only iterate elements matching a given glob-style pattern, similarly to the behavior of the &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; command that takes a pattern as only argument.</source>
          <target state="translated">패턴을 인수로만 사용하는 &lt;a href=&quot;keys&quot;&gt;KEYS&lt;/a&gt; 명령 의 동작과 유사하게 주어진 glob 스타일 패턴과 일치하는 요소 만 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b6a2609bc05ff6f008c837f6095456b47106ecb" translate="yes" xml:space="preserve">
          <source>It is possible to pass an additional argument to the command, in order to see the messages having a specific owner:</source>
          <target state="translated">특정 소유자가있는 메시지를보기 위해 명령에 추가 인수를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c90a5608f4fab2983bbd179b23cb40526ff6f3e" translate="yes" xml:space="preserve">
          <source>It is possible to pass the &lt;code&gt;WITHSCORES&lt;/code&gt; option in order to return the scores of the elements together with the elements. The returned list will contain &lt;code&gt;value1,score1,...,valueN,scoreN&lt;/code&gt; instead of &lt;code&gt;value1,...,valueN&lt;/code&gt;. Client libraries are free to return a more appropriate data type (suggestion: an array with (value, score) arrays/tuples).</source>
          <target state="translated">요소의 점수를 요소와 함께 리턴하기 위해 &lt;code&gt;WITHSCORES&lt;/code&gt; 옵션 을 전달할 수 있습니다 . 반환 목록에 포함 &lt;code&gt;value1,score1,...,valueN,scoreN&lt;/code&gt; 대신 &lt;code&gt;value1,...,valueN&lt;/code&gt; . 클라이언트 라이브러리는보다 적절한 데이터 유형 (추천 : (값, 점수) 배열 / 튜플이있는 배열)을 자유롭게 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fd91c3878c3497da37709cc86d8056d11e4d945" translate="yes" xml:space="preserve">
          <source>It is possible to provide multiple filters at the same time. The command will handle multiple filters via logical AND. For example:</source>
          <target state="translated">여러 개의 필터를 동시에 제공 할 수 있습니다. 이 명령은 논리 AND를 통해 여러 필터를 처리합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c3121b308c1fd1777b057f001ac070f1a4f6932" translate="yes" xml:space="preserve">
          <source>It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the head of the list, from the leftmost element to the rightmost element. So for instance the command &lt;code&gt;LPUSH mylist a b c&lt;/code&gt; will result into a list containing &lt;code&gt;c&lt;/code&gt; as first element, &lt;code&gt;b&lt;/code&gt; as second element and &lt;code&gt;a&lt;/code&gt; as third element.</source>
          <target state="translated">명령 끝에 여러 인수를 지정하여 단일 명령 호출을 사용하여 여러 요소를 푸시 할 수 있습니다. 요소는 맨 왼쪽 요소에서 가장 오른쪽 요소까지 목록의 머리 부분에 하나씩 삽입됩니다. 예를 들어 &lt;code&gt;LPUSH mylist a b c&lt;/code&gt; 명령 은 &lt;code&gt;c&lt;/code&gt; 를 첫 번째 요소로, &lt;code&gt;b&lt;/code&gt; 를 두 번째 요소로, &lt;code&gt;a&lt;/code&gt; 를 세 번째 요소로 포함하는 목록을 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="f7c76d9bc80fdf12c410c3b35eb8ad68df167802" translate="yes" xml:space="preserve">
          <source>It is possible to push multiple elements using a single command call just specifying multiple arguments at the end of the command. Elements are inserted one after the other to the tail of the list, from the leftmost element to the rightmost element. So for instance the command &lt;code&gt;RPUSH mylist a b c&lt;/code&gt; will result into a list containing &lt;code&gt;a&lt;/code&gt; as first element, &lt;code&gt;b&lt;/code&gt; as second element and &lt;code&gt;c&lt;/code&gt; as third element.</source>
          <target state="translated">명령 끝에 여러 인수를 지정하여 단일 명령 호출을 사용하여 여러 요소를 푸시 할 수 있습니다. 요소는 맨 왼쪽 요소에서 가장 오른쪽 요소까지 목록의 꼬리 부분에 하나씩 삽입됩니다. 예를 들어, &lt;code&gt;RPUSH mylist a b c&lt;/code&gt; 명령 은 &lt;code&gt;a&lt;/code&gt; 를 첫 번째 요소로, &lt;code&gt;b&lt;/code&gt; 를 두 번째 요소로, &lt;code&gt;c&lt;/code&gt; 를 세 번째 요소로 포함 하는 목록을 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="6156ba53b9a2d5fcb6563a933eb7f9a8915352ac" translate="yes" xml:space="preserve">
          <source>It is possible to reset only specific events by providing the &lt;code&gt;event&lt;/code&gt; names as arguments.</source>
          <target state="translated">&lt;code&gt;event&lt;/code&gt; 이름을 인수로 제공하여 특정 이벤트 만 재설정 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b01178931bb71c8630b481c710157203df1e465" translate="yes" xml:space="preserve">
          <source>It is possible to send &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; in a MULTI/EXEC block together with the &lt;code&gt;INFO replication&lt;/code&gt; command in order to get the current master offset at the time the clients are blocked. This way it is possible to wait for a specific offset in the replica side in order to make sure all the replication stream was processed.</source>
          <target state="translated">클라이언트가 차단 될 때 현재 마스터 오프셋을 얻기 위해 &lt;code&gt;INFO replication&lt;/code&gt; 명령 과 함께 MULTI / EXEC 블록에 &lt;a href=&quot;client-pause&quot;&gt;CLIENT PAUSE&lt;/a&gt; 를 보낼 수 있습니다. 이런 식으로 모든 복제 스트림이 처리되도록 복제본 측에서 특정 오프셋을 기다릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ec5055f100665a2489124e5d7125126bd09824c" translate="yes" xml:space="preserve">
          <source>It is possible to specify an optional modifier to alter the behavior of the command. Specifically:</source>
          <target state="translated">명령 동작을 변경하기 위해 선택적 수정자를 지정할 수 있습니다. 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="45f8f96397f97e0b1f0e90886760fbff08204ef1" translate="yes" xml:space="preserve">
          <source>It is possible to switch persistence from RDB snapshotting to append-only file (and the other way around) using the &lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; command. For more information about how to do that please check the &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;persistence page&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;config-set&quot;&gt;CONFIG SET&lt;/a&gt; 명령을 사용하여 지속성을 RDB 스냅 샷에서 추가 전용 파일 (및 다른 방법으로)로 전환 할 수 있습니다 . 이를 수행하는 방법에 대한 자세한 내용은 &lt;a href=&quot;https://redis.io/topics/persistence&quot;&gt;지속성 페이지&lt;/a&gt; 를 확인 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e2a6138f902bc8b4bcfbc90caefbe979c90132a" translate="yes" xml:space="preserve">
          <source>It is possible to terminate a script that executes only read-only commands using the &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; command. This does not violate the scripting semantic as no data was yet written to the dataset by the script.</source>
          <target state="translated">&lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; 명령을 사용하여 읽기 전용 명령 만 실행하는 스크립트를 종료 할 수 있습니다 . 아직 스크립트에 의해 데이터 세트에 데이터가 기록되지 않았기 때문에 스크립팅 시맨틱을 위반하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e71c9ce4c62f0cde3cb804acf308d1e98fe95b09" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; and &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; together at every page view to have a counter counting only the latest N page views separated by less than the specified amount of seconds.</source>
          <target state="translated">모든 페이지보기에서 &lt;a href=&quot;incr&quot;&gt;INCR&lt;/a&gt; 과 &lt;a href=&quot;expire&quot;&gt;EXPIRE를&lt;/a&gt; 함께 사용 하면 지정된 N 초 미만으로 분리 된 최신 N 페이지보기 만 계수하는 카운터를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dd681e578f9014910b8ac5ae0c3612f0ad14944" translate="yes" xml:space="preserve">
          <source>It is possible to use &lt;code&gt;BY&lt;/code&gt; and &lt;code&gt;GET&lt;/code&gt; options against hash fields with the following syntax:</source>
          <target state="translated">다음 구문으로 해시 필드에 대해 &lt;code&gt;BY&lt;/code&gt; 및 &lt;code&gt;GET&lt;/code&gt; 옵션 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7c843f5e285c955a784fb3560240c16b6f9efa9" translate="yes" xml:space="preserve">
          <source>It is possible to use them in &lt;code&gt;geohash.org&lt;/code&gt; URLs such as &lt;code&gt;http://geohash.org/&amp;lt;geohash-string&amp;gt;&lt;/code&gt;. This is an &lt;a href=&quot;http://geohash.org/sqdtr74hyu0&quot;&gt;example of such URL&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;http://geohash.org/&amp;lt;geohash-string&amp;gt;&lt;/code&gt; 과 같은 &lt;code&gt;geohash.org&lt;/code&gt; URL 에서 이들을 사용할 수 있습니다 . 이것은 &lt;a href=&quot;http://geohash.org/sqdtr74hyu0&quot;&gt;그러한 URL&lt;/a&gt; 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="b30cb831388a0a49ee8acf0fd13e74a7abc3ab8f" translate="yes" xml:space="preserve">
          <source>It is possible to write to the Redis log file from Lua scripts using the &lt;code&gt;redis.log&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;redis.log&lt;/code&gt; 함수를 사용하여 Lua 스크립트에서 Redis 로그 파일에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dee99c37f02de301ed26c2711bf105931901e4b7" translate="yes" xml:space="preserve">
          <source>It is the blocking version because it blocks the connection when there are no members to pop from any of the given sorted sets. A member with the highest score is popped from first sorted set that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">지정된 정렬 된 세트에서 팝업 할 멤버가 없을 때 연결을 차단하기 때문에 차단 버전입니다. 점수가 가장 높은 멤버는 비어 있지 않은 첫 번째 정렬 된 세트에서 팝되며 주어진 키는 주어진 순서대로 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="b7063c25aabd8a7e88f52a969b68eec3fd17473b" translate="yes" xml:space="preserve">
          <source>It is the blocking version because it blocks the connection when there are no members to pop from any of the given sorted sets. A member with the lowest score is popped from first sorted set that is non-empty, with the given keys being checked in the order that they are given.</source>
          <target state="translated">지정된 정렬 된 세트에서 팝업 할 멤버가 없을 때 연결을 차단하기 때문에 차단 버전입니다. 점수가 가장 낮은 멤버는 비어 있지 않은 첫 번째 정렬 된 세트에서 팝되며 주어진 키는 주어진 순서대로 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="164013c6ace79ff08b57e9e952d3d8fc12045787" translate="yes" xml:space="preserve">
          <source>It just assumes that the Earth is a sphere, since the used distance formula is the Haversine formula. This formula is only an approximation when applied to the Earth, which is not a perfect sphere. The introduced errors are not an issue when used in the context of social network sites that need to query by radius and most other applications. However in the worst case the error may be up to 0.5%, so you may want to consider other systems for error-critical applications.</source>
          <target state="translated">사용 된 거리 공식이 Haversine 공식이기 때문에 지구가 구체라고 가정합니다. 이 공식은 지구에 적용될 때의 근사치 일 뿐이며 완벽한 구는 아닙니다. 반경 및 대부분의 다른 응용 프로그램으로 쿼리해야하는 소셜 네트워크 사이트의 컨텍스트에서 사용될 때 도입 된 오류는 문제가되지 않습니다. 그러나 최악의 경우 오류가 최대 0.5 %가 될 수 있으므로 오류가 중요한 응용 프로그램에 다른 시스템을 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78cca099dcd0e67e0e370e606d28021ee24c5299" translate="yes" xml:space="preserve">
          <source>It should display some computer art. There are no limits as long as the output works well in a normal terminal display. However the output should not be limited to graphics (like LOLWUT 5 and 6 actually do), but can be generative poetry and other non graphical things.</source>
          <target state="translated">컴퓨터 아트가 표시되어야합니다. 출력이 일반 터미널 디스플레이에서 잘 작동하는 한 제한이 없습니다. 그러나 출력은 그래픽 (LOLWUT 5 및 6이 실제로하는 것과 같이)에 국한되어서는 안되며 생성시 및 기타 비 그래픽적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="886b0ba44681d142ee0340c1b1c340fb49ca65a9" translate="yes" xml:space="preserve">
          <source>It starts accepting commands again from other clients, but will reply with a BUSY error to all the clients sending normal commands. The only allowed commands in this status are &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; and &lt;code&gt;SHUTDOWN
NOSAVE&lt;/code&gt;.</source>
          <target state="translated">다른 클라이언트에서 명령을 다시 수락하기 시작하지만 일반 명령을 보내는 모든 클라이언트에 BUSY 오류로 응답합니다. 이 상태에서 유일하게 허용되는 명령은 &lt;a href=&quot;script-kill&quot;&gt;SCRIPT KILL&lt;/a&gt; 및 &lt;code&gt;SHUTDOWN NOSAVE&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c9c449f7e951338dc4ce45209e7239b6180f2387" translate="yes" xml:space="preserve">
          <source>It stops processing all the pending commands from normal and pub/sub clients. However interactions with replicas will continue normally.</source>
          <target state="translated">일반 및 pub / sub 클라이언트에서 보류중인 모든 명령 처리를 중지합니다. 그러나 복제본과의 상호 작용은 정상적으로 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="de49d1f951abef9774a1080b68edfd084cab6b36" translate="yes" xml:space="preserve">
          <source>It supports several other functions: &lt;code&gt;bit.tobit&lt;/code&gt;, &lt;code&gt;bit.tohex&lt;/code&gt;, &lt;code&gt;bit.bnot&lt;/code&gt;, &lt;code&gt;bit.band&lt;/code&gt;, &lt;code&gt;bit.bor&lt;/code&gt;, &lt;code&gt;bit.bxor&lt;/code&gt;, &lt;code&gt;bit.lshift&lt;/code&gt;, &lt;code&gt;bit.rshift&lt;/code&gt;, &lt;code&gt;bit.arshift&lt;/code&gt;, &lt;code&gt;bit.rol&lt;/code&gt;, &lt;code&gt;bit.ror&lt;/code&gt;, &lt;code&gt;bit.bswap&lt;/code&gt;. All available functions are documented in the &lt;a href=&quot;http://bitop.luajit.org/api.html&quot;&gt;Lua BitOp documentation&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;bit.tobit&lt;/code&gt; , &lt;code&gt;bit.tohex&lt;/code&gt; , &lt;code&gt;bit.bnot&lt;/code&gt; , &lt;code&gt;bit.band&lt;/code&gt; , &lt;code&gt;bit.bor&lt;/code&gt; , &lt;code&gt;bit.bxor&lt;/code&gt; , &lt;code&gt;bit.lshift&lt;/code&gt; , &lt;code&gt;bit.rshift&lt;/code&gt; , &lt;code&gt;bit.arshift&lt;/code&gt; , &lt;code&gt;bit.rol&lt;/code&gt; , &lt;code&gt;bit.ror&lt;/code&gt; , 기타 기능을 지원합니다. &lt;code&gt;bit.bswap&lt;/code&gt; . 사용 가능한 모든 기능은 &lt;a href=&quot;http://bitop.luajit.org/api.html&quot;&gt;Lua BitOp 설명서에 나와 있습니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa6a033ac7293343a89e1b83064df26de033f26b" translate="yes" xml:space="preserve">
          <source>Iteratating a stream incrementally, returning just a few items at every iteration. However it is semantically much more robust than the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of functions.</source>
          <target state="translated">스트림을 증분 반복하여 반복 할 때마다 몇 개의 항목 만 반환합니다. 그러나 이는 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 기능 군 보다 의미 상 훨씬 강력 합니다.</target>
        </trans-unit>
        <trans-unit id="3fa52c04afc758e80cafb88b8a1109903b053dfb" translate="yes" xml:space="preserve">
          <source>Iterating a stream</source>
          <target state="translated">스트림 반복</target>
        </trans-unit>
        <trans-unit id="51c1f7544778c11ca5b79e2c5f951971fc09700a" translate="yes" xml:space="preserve">
          <source>Iterating a stream incrementally, returning just a few items at every iteration. However it is semantically much more robust than the &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; family of functions.</source>
          <target state="translated">스트림을 점진적으로 반복하여 반복 할 때마다 몇 개의 항목 만 반환합니다. 그러나 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 기능 군 보다 의미 상 훨씬 더 강력 합니다.</target>
        </trans-unit>
        <trans-unit id="6cb66fccc1c9fe8583ef2426d5ce548dc6f7ff69" translate="yes" xml:space="preserve">
          <source>Iterating with XREVRANGE</source>
          <target state="translated">XREVRANGE를 사용하여 반복</target>
        </trans-unit>
        <trans-unit id="ac745b350ec3c8d6357a81e49fd4c8b3f51fac37" translate="yes" xml:space="preserve">
          <source>Iterating with earlier versions of Redis</source>
          <target state="translated">이전 버전의 Redis로 반복</target>
        </trans-unit>
        <trans-unit id="4794d4e58656f4a052385045d3fd4b0331ebddea" translate="yes" xml:space="preserve">
          <source>Iteration of a Hash value.</source>
          <target state="translated">해시 값의 반복.</target>
        </trans-unit>
        <trans-unit id="ac97fd8044e211b8965191abd3e1372d4a6075d6" translate="yes" xml:space="preserve">
          <source>KEYS</source>
          <target state="translated">KEYS</target>
        </trans-unit>
        <trans-unit id="d4d3343d1b4f35172b9d4fabff52e12ab9514f83" translate="yes" xml:space="preserve">
          <source>KEYS  pattern   Find all keys matching the given pattern</source>
          <target state="translated">키 패턴 주어진 패턴과 일치하는 모든 키를 찾습니다</target>
        </trans-unit>
        <trans-unit id="8001eeb819fd035ff21dae0c64b60f000bfc9daa" translate="yes" xml:space="preserve">
          <source>Key step count allows us to find key positions in commands like &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; where the format is &lt;code&gt;MSET _key1_ _val1_ [key2] [val2] [key3] [val3]...&lt;/code&gt;.</source>
          <target state="translated">키 단계 수를 통해 &lt;a href=&quot;mset&quot;&gt;MSET&lt;/a&gt; 과 같은 명령 에서 형식이 &lt;code&gt;MSET _key1_ _val1_ [key2] [val2] [key3] [val3]...&lt;/code&gt; 키 위치를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5651c683f14c95aa972cfdbc300d9fecfe02019" translate="yes" xml:space="preserve">
          <source>Keys</source>
          <target state="translated">Keys</target>
        </trans-unit>
        <trans-unit id="5e0969e73b8800b103eeedd8f6bcdbbbf0f4fa78" translate="yes" xml:space="preserve">
          <source>Keys are checked in the order that they are given. Let's say that the key &lt;code&gt;list1&lt;/code&gt; doesn't exist and &lt;code&gt;list2&lt;/code&gt; and &lt;code&gt;list3&lt;/code&gt; hold non-empty lists. Consider the following command:</source>
          <target state="translated">키는 주어진 순서대로 확인됩니다. 키 &lt;code&gt;list1&lt;/code&gt; 이 존재하지 않고 &lt;code&gt;list2&lt;/code&gt; 및 &lt;code&gt;list3&lt;/code&gt; 이 비어 있지 않은 목록을 보유 한다고 가정 해 봅시다 . 다음 명령을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="393be168e99116be87234133e2763b06336c48c1" translate="yes" xml:space="preserve">
          <source>Keys expiring information is stored as absolute Unix timestamps (in milliseconds in case of Redis version 2.6 or greater). This means that the time is flowing even when the Redis instance is not active.</source>
          <target state="translated">정보가 만료되는 키는 절대 Unix 타임 스탬프 (Redis 버전 2.6 이상의 경우 밀리 초)로 저장됩니다. 이는 Redis 인스턴스가 활성화되지 않은 경우에도 시간이 흐르고 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d3023dfa16df6ad208cc7d5460854b58da1edb26" translate="yes" xml:space="preserve">
          <source>Keys that do not exist are considered to be empty sets.</source>
          <target state="translated">존재하지 않는 키는 빈 세트로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d71481abd644158f5a9fbc5c9cecdf74dc0540c6" translate="yes" xml:space="preserve">
          <source>Keys that do not exist are considered to be empty sets. With one of the keys being an empty set, the resulting set is also empty (since set intersection with an empty set always results in an empty set).</source>
          <target state="translated">존재하지 않는 키는 빈 세트로 간주됩니다. 키 중 하나가 빈 세트 인 경우 결과 세트도 비어 있습니다 (빈 세트와의 집합 교차는 항상 빈 세트가되므로).</target>
        </trans-unit>
        <trans-unit id="a78a3a71051e865654da3b71a5c55513e9449b8a" translate="yes" xml:space="preserve">
          <source>Keys with an expire</source>
          <target state="translated">만료 된 키</target>
        </trans-unit>
        <trans-unit id="7bcef127a442604057181ff7e89e6774cfcbdec1" translate="yes" xml:space="preserve">
          <source>Keyspace hits</source>
          <target state="translated">키 스페이스 적중</target>
        </trans-unit>
        <trans-unit id="0ecc36a9eabb580bee92d3334fc963c0e285c8f2" translate="yes" xml:space="preserve">
          <source>Keyspace misses</source>
          <target state="translated">키 스페이스 누락</target>
        </trans-unit>
        <trans-unit id="18937f1c4a4cfb92babe800429a63d572cde1150" translate="yes" xml:space="preserve">
          <source>Kills the currently executing Lua script, assuming no write operation was yet performed by the script.</source>
          <target state="translated">스크립트에서 아직 쓰기 작업이 수행되지 않았다고 가정하고 현재 실행중인 Lua 스크립트를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="a5a5fafee83492d8b176cbbdd5bb0860a6fdbf28" translate="yes" xml:space="preserve">
          <source>Known limitations:</source>
          <target state="translated">알려진 제한 사항 :</target>
        </trans-unit>
        <trans-unit id="a452e11c491a60de5436b1999a469cdaa66c0c00" translate="yes" xml:space="preserve">
          <source>LASTSAVE</source>
          <target state="translated">LASTSAVE</target>
        </trans-unit>
        <trans-unit id="fb2ee42881d40ddc3d3aec1d41500b08e5d25e19" translate="yes" xml:space="preserve">
          <source>LASTSAVE   Get the UNIX time stamp of the last successful save to disk</source>
          <target state="translated">LASTSAVE 마지막으로 디스크에 성공적으로 저장 한 UNIX 타임 스탬프를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="49d6c10ecea9234f6d1697a89998efd2571a5a9d" translate="yes" xml:space="preserve">
          <source>LATENCY</source>
          <target state="translated">LATENCY</target>
        </trans-unit>
        <trans-unit id="0501d335a5299cb1743cbb10c7b8477444d0a1c2" translate="yes" xml:space="preserve">
          <source>LATENCY DOCTOR   Return a human readable latency analysis report.</source>
          <target state="translated">LATENCY DOCTOR 사람이 읽을 수있는 대기 시간 분석 보고서를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="186301f764b22cd2877e1aabbbb1538d6d5f7100" translate="yes" xml:space="preserve">
          <source>LATENCY GRAPH  event   Return a latency graph for the event.</source>
          <target state="translated">LATENCY GRAPH 이벤트 이벤트에 대한 대기 시간 그래프를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4bd2b2b9b61f8de610b1da572e4c2d464408238b" translate="yes" xml:space="preserve">
          <source>LATENCY HELP   Show helpful text about the different subcommands.</source>
          <target state="translated">LATENCY HELP 여러 하위 명령에 대한 유용한 텍스트를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d4448a36c961ebd2847369404270a681d688d37d" translate="yes" xml:space="preserve">
          <source>LATENCY HISTORY  event   Return timestamp-latency samples for the event.</source>
          <target state="translated">LATENCY HISTORY 이벤트 이벤트에 대한 타임 스탬프 지연 샘플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="40376256cb5363f7be31b5131fdde6f208ad798b" translate="yes" xml:space="preserve">
          <source>LATENCY LATEST   Return the latest latency samples for all events.</source>
          <target state="translated">LATENCY LATEST 모든 이벤트에 대한 최신 지연 샘플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a46ae60e5ee406730f6e4d649edcf9436c10620d" translate="yes" xml:space="preserve">
          <source>LATENCY RESET  [event [event ...]]   Reset latency data for one or more events.</source>
          <target state="translated">LATENCY RESET [이벤트 [이벤트 ...]] 하나 이상의 이벤트에 대한 대기 시간 데이터를 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="c6fdb30d112715d0c3b5d8a01834e5fa3472abec" translate="yes" xml:space="preserve">
          <source>LCS algorithm</source>
          <target state="translated">LCS 알고리즘</target>
        </trans-unit>
        <trans-unit id="89288dff0eca7e3500efaf0b7acd0c70cae1edc4" translate="yes" xml:space="preserve">
          <source>LCS is very useful in order to evaluate how similar two strings are. Strings can represent many things. For instance if two strings are DNA sequences, the LCS will provide a measure of similarity between the two DNA sequences. If the strings represent some text edited by some user, the LCS could represent how different the new text is compared to the old one, and so forth.</source>
          <target state="translated">LCS는 두 문자열이 얼마나 유사한 지 평가하는 데 매우 유용합니다. 문자열은 많은 것을 나타낼 수 있습니다. 예를 들어 두 문자열이 DNA 서열 인 경우 LCS는 두 DNA 서열 간의 유사성을 측정합니다. 문자열이 일부 사용자가 편집 한 일부 텍스트를 나타내는 경우 LCS는 새 텍스트가 이전 텍스트와 비교되는 정도를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9ffd63c8ba805a842d4d3d2465da47916360545" translate="yes" xml:space="preserve">
          <source>LDB can be enabled in one of two modes: asynchronous or synchronous. In asynchronous mode the server creates a forked debugging session that does not block and all changes to the data are &lt;strong&gt;rolled back&lt;/strong&gt; after the session finishes, so debugging can be restarted using the same initial state. The alternative synchronous debug mode blocks the server while the debugging session is active and retains all changes to the data set once it ends.</source>
          <target state="translated">LDB는 비동기 또는 동기 모드 중 하나에서 활성화 할 수 있습니다. 비동기 모드에서 서버는 차단되지 않는 분기 된 디버깅 세션을 작성 하고 세션이 완료된 후 데이터의 모든 변경 사항이 &lt;strong&gt;롤백&lt;/strong&gt; 되므로 동일한 초기 상태를 사용하여 디버깅을 다시 시작할 수 있습니다. 대체 동기 디버그 모드는 디버깅 세션이 활성 상태 인 동안 서버를 차단하고 데이터 세트가 종료되면 모든 변경 사항을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="14d2c13614325f3af7fa95efeb5dd818bb2ab0d1" translate="yes" xml:space="preserve">
          <source>LINDEX</source>
          <target state="translated">LINDEX</target>
        </trans-unit>
        <trans-unit id="a2dedc00417f0b7b29562ddaa4e03af088097cdb" translate="yes" xml:space="preserve">
          <source>LINDEX  key index   Get an element from a list by its index</source>
          <target state="translated">LINDEX 키 인덱스 인덱스로 목록에서 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="40088c47225008784271c2935753b4ae98fd6ec7" translate="yes" xml:space="preserve">
          <source>LINSERT</source>
          <target state="translated">LINSERT</target>
        </trans-unit>
        <trans-unit id="b2f2247f94ae9fe4fba40fd22b1b94acb748b154" translate="yes" xml:space="preserve">
          <source>LINSERT  key BEFORE|AFTER pivot element   Insert an element before or after another element in a list</source>
          <target state="translated">LINSERT 키 BEFORE | AFTER 피벗 요소 목록에서 다른 요소 앞 또는 뒤에 요소 삽입</target>
        </trans-unit>
        <trans-unit id="ca09700aae0c450ed6c327c789e3e1e3fef9f931" translate="yes" xml:space="preserve">
          <source>LINSERT  key BEFORE|AFTER pivot value   Insert an element before or after another element in a list</source>
          <target state="translated">LINSERT 키 BEFORE | AFTER 피벗 값 목록에서 다른 요소 앞이나 뒤에 요소 삽입</target>
        </trans-unit>
        <trans-unit id="19ce1639e2d6248a60334eca45396c2f1f706007" translate="yes" xml:space="preserve">
          <source>LLEN</source>
          <target state="translated">LLEN</target>
        </trans-unit>
        <trans-unit id="defc92ee8b39130b63cdf033e9edada00210e4f3" translate="yes" xml:space="preserve">
          <source>LLEN  key   Get the length of a list</source>
          <target state="translated">LLEN 키 목록의 길이를 가져옵니다</target>
        </trans-unit>
        <trans-unit id="cb98d0989512bc7d03fd0083653a3d72b76da663" translate="yes" xml:space="preserve">
          <source>LMOVE</source>
          <target state="translated">LMOVE</target>
        </trans-unit>
        <trans-unit id="78baeb2f5149c1548b47f47678b64129f94c3043" translate="yes" xml:space="preserve">
          <source>LMOVE  source destination LEFT|RIGHT LEFT|RIGHT   Pop an element from a list, push it to another list and return it</source>
          <target state="translated">LMOVE 소스 대상 LEFT | RIGHT LEFT | RIGHT 목록에서 요소를 팝하고 다른 목록으로 푸시 한 다음 반환</target>
        </trans-unit>
        <trans-unit id="9cd49a9c6357f14037353e324dbbd426c30c77ff" translate="yes" xml:space="preserve">
          <source>LOLWUT</source>
          <target state="translated">LOLWUT</target>
        </trans-unit>
        <trans-unit id="91989e8620d79bb9a73795ebf9495785796e20eb" translate="yes" xml:space="preserve">
          <source>LOLWUT  [VERSION version]   Display some computer art and the Redis version</source>
          <target state="translated">LOLWUT [VERSION 버전] 일부 컴퓨터 아트 및 Redis 버전 표시</target>
        </trans-unit>
        <trans-unit id="b8e5b9325998311e1bd0cdebf30f7c4698bea549" translate="yes" xml:space="preserve">
          <source>LOLWUT implementations should be safe and carefully checked for security, and resist to untrusted inputs if they take arguments.</source>
          <target state="translated">LOLWUT 구현은 안전하고 신중하게 보안을 확인해야하며 인수를받는 경우 신뢰할 수없는 입력에 저항해야합니다.</target>
        </trans-unit>
        <trans-unit id="8b789d56cc69b68e8cc9454d61b8f6bcb54c00bd" translate="yes" xml:space="preserve">
          <source>LOLWUT must always display the Redis version at the end.</source>
          <target state="translated">LOLWUT은 항상 끝에 Redis 버전을 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7fd4a8e75c582938a820d5ac113cfb69399cf55" translate="yes" xml:space="preserve">
          <source>LOLWUT output should be completely useless. Displaying some useful Redis internal metrics does not count as a valid LOLWUT.</source>
          <target state="translated">LOLWUT 출력은 완전히 쓸모가 없어야합니다. 유용한 Redis 내부 측정 항목을 표시하는 것은 유효한 LOLWUT로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b93af8b70d5c9191d5ace878da62d412c38ce8b2" translate="yes" xml:space="preserve">
          <source>LOLWUT output should be fast to generate so that the command can be called in production instances without issues. It should remain fast even when the user experiments with odd parameters.</source>
          <target state="translated">LOLWUT 출력은 생성 속도가 빨라야 문제없이 프로덕션 인스턴스에서 명령을 호출 할 수 있습니다. 사용자가 이상한 매개 변수로 실험하더라도 빠르게 유지되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0f982fb7857c5b2bb4e69ef661e4d5d07a8ccdf1" translate="yes" xml:space="preserve">
          <source>LOLWUT wants to be a reminder that there is more in programming than just putting some code together in order to create something useful. Every LOLWUT version should have the following properties:</source>
          <target state="translated">LOLWUT은 유용한 것을 만들기 위해 코드를 조합하는 것보다 프로그래밍에 더 많은 것이 있음을 상기시키고 자합니다. 모든 LOLWUT 버전에는 다음 속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="6f58be63c72a45daadb6f09041398ad98c6ac9a7" translate="yes" xml:space="preserve">
          <source>LPOP</source>
          <target state="translated">LPOP</target>
        </trans-unit>
        <trans-unit id="c0a0f50764c15280585040d66db05c7ea7d4701a" translate="yes" xml:space="preserve">
          <source>LPOP  key   Remove and get the first element in a list</source>
          <target state="translated">LPOP 키 목록에서 첫 번째 요소를 제거하고 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="75ee742440d0263541b4bf6b56f59ba72ebbd18e" translate="yes" xml:space="preserve">
          <source>LPOP  key [count]   Remove and get the first elements in a list</source>
          <target state="translated">LPOP 키 [count] 목록에서 첫 번째 요소를 제거하고 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="8692b4b41c5b80f3fc1b6efeb4604f7278100aec" translate="yes" xml:space="preserve">
          <source>LPOS</source>
          <target state="translated">LPOS</target>
        </trans-unit>
        <trans-unit id="2f8be8617cbb634559fc59c4d3862bfd42f75d83" translate="yes" xml:space="preserve">
          <source>LPOS  key element [RANK rank] [COUNT num-matches] [MAXLEN len]   Return the index of matching elements on a list</source>
          <target state="translated">LPOS 키 요소 [RANK 순위] [COUNT num-matches] [MAXLEN len] 목록에서 일치하는 요소의 인덱스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4f49fc76e42ddd892d0dbf761cab7456fba6707a" translate="yes" xml:space="preserve">
          <source>LPUSH</source>
          <target state="translated">LPUSH</target>
        </trans-unit>
        <trans-unit id="5005b933581b136ea08ec907be2cf03efef61621" translate="yes" xml:space="preserve">
          <source>LPUSH  key element [element ...]   Prepend one or multiple elements to a list</source>
          <target state="translated">LPUSH 키 요소 [요소 ...] 목록에 하나 이상의 요소 추가</target>
        </trans-unit>
        <trans-unit id="a3260ebe55f682088cc638c2329d0a5d2a5f9c43" translate="yes" xml:space="preserve">
          <source>LPUSH  key value [value ...]   Prepend one or multiple values to a list</source>
          <target state="translated">LPUSH 키 값 [값 ...] 하나 이상의 값을 목록에 추가</target>
        </trans-unit>
        <trans-unit id="73023347f78efa6f33e2849831f260102f26f9dc" translate="yes" xml:space="preserve">
          <source>LPUSHX</source>
          <target state="translated">LPUSHX</target>
        </trans-unit>
        <trans-unit id="ed89f101b9e76dd34f817063ee39924d1d879b9e" translate="yes" xml:space="preserve">
          <source>LPUSHX  key element [element ...]   Prepend an element to a list, only if the list exists</source>
          <target state="translated">LPUSHX 키 요소 [요소 ...] 목록이 존재하는 경우에만 목록 앞에 요소 추가</target>
        </trans-unit>
        <trans-unit id="11960d83f4ba3a64c1274bec7eeaf405b1c4abbe" translate="yes" xml:space="preserve">
          <source>LPUSHX  key value   Prepend a value to a list, only if the list exists</source>
          <target state="translated">LPUSHX 키 값 목록이 존재하는 경우에만 목록에 값을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="3b47c23e3107b92100b9303bb9ab3d1a9ccc56bd" translate="yes" xml:space="preserve">
          <source>LRANGE</source>
          <target state="translated">LRANGE</target>
        </trans-unit>
        <trans-unit id="326594fa342712e825205a5b864121b10bd2f5cf" translate="yes" xml:space="preserve">
          <source>LRANGE  key start stop   Get a range of elements from a list</source>
          <target state="translated">LRANGE 키 시작 중지 목록에서 다양한 요소 가져 오기</target>
        </trans-unit>
        <trans-unit id="abfc25d80dc9a80384bd4c9697b510b323ecc45b" translate="yes" xml:space="preserve">
          <source>LREM</source>
          <target state="translated">LREM</target>
        </trans-unit>
        <trans-unit id="254b612ba99c38d18c49c669440c641123e2f3a7" translate="yes" xml:space="preserve">
          <source>LREM  key count element   Remove elements from a list</source>
          <target state="translated">LREM 키 카운트 요소 목록에서 요소 제거</target>
        </trans-unit>
        <trans-unit id="f0b649e2191175bc6abf8bc7b2d0b6ec6fbf904d" translate="yes" xml:space="preserve">
          <source>LREM  key count value   Remove elements from a list</source>
          <target state="translated">LREM 키 수 값 목록에서 요소 제거</target>
        </trans-unit>
        <trans-unit id="70e8f03d6f4f36a9430ac8c4d4a1515597b0b252" translate="yes" xml:space="preserve">
          <source>LSET</source>
          <target state="translated">LSET</target>
        </trans-unit>
        <trans-unit id="67b8e37be9910fff9bc7142f035eae99cc3cc4f5" translate="yes" xml:space="preserve">
          <source>LSET  key index element   Set the value of an element in a list by its index</source>
          <target state="translated">LSET 키 인덱스 요소 인덱스로 목록의 요소 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="4f03203283df161a2d6f2abf4d29626d32823249" translate="yes" xml:space="preserve">
          <source>LSET  key index value   Set the value of an element in a list by its index</source>
          <target state="translated">LSET 키 인덱스 값 인덱스로 목록의 요소 값을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="13cbd920c001e22788dd4d82cdc291c6caac4662" translate="yes" xml:space="preserve">
          <source>LTRIM</source>
          <target state="translated">LTRIM</target>
        </trans-unit>
        <trans-unit id="6c5b375830efe50dd05881b52f80e2aa747afced" translate="yes" xml:space="preserve">
          <source>LTRIM  key start stop   Trim a list to the specified range</source>
          <target state="translated">LTRIM 키 시작 중지 목록을 지정된 범위로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="de6a27da313b316346ea7dcf9f866c5fcdaff765" translate="yes" xml:space="preserve">
          <source>Last Key in Argument List</source>
          <target state="translated">인수 목록의 마지막 키</target>
        </trans-unit>
        <trans-unit id="65fe7d4d518c0668f04d8585ccfbc20334e6fd38" translate="yes" xml:space="preserve">
          <source>Lastly, there are three important rules to note:</source>
          <target state="translated">마지막으로 주목해야 할 세 가지 중요한 규칙이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4e1040fdde9172717ea80a7cdcb3b316461fb75" translate="yes" xml:space="preserve">
          <source>Later it will be trivial to know the number of single days the user visited the web site simply calling the &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; command against the bitmap.</source>
          <target state="translated">나중에 비트 맵에 대해 &lt;a href=&quot;bitcount&quot;&gt;BITCOUNT&lt;/a&gt; 명령을 호출하는 사용자가 웹 사이트를 방문한 하루 수를 아는 것은 쉽지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="78d7ed93f503a940a73a89268b71f5daa31c6b65" translate="yes" xml:space="preserve">
          <source>Latest event latency in millisecond.</source>
          <target state="translated">최신 이벤트 지연 시간 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="6167261c71ec337f0f15b900208ad184a4f7b0c9" translate="yes" xml:space="preserve">
          <source>Latest fork(2) time</source>
          <target state="translated">최신 포크 (2) 시간</target>
        </trans-unit>
        <trans-unit id="0122f9d36a5bc7edfbaa17dc0a7b017882cfb3ae" translate="yes" xml:space="preserve">
          <source>Let's assume we have four nodes, A, B, C and D. In order to end with just a three nodes cluster A, B, C we may follow these steps:</source>
          <target state="translated">4 개의 노드 A, B, C 및 D가 있다고 가정 해 봅시다. 3 개의 노드 클러스터 A, B, C로 끝나기 위해 다음 단계를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f5c5e27076a7756eeef955cec8a1510af3fb9c4" translate="yes" xml:space="preserve">
          <source>Licensed under the Creative Commons Attribution-ShareAlike License 4.0.</source>
          <target state="translated">Creative Commons Attribution-ShareAlike License 4.0에 따라 라이센스가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="98cf5d780c53575d17f1d32cf3823650dcaa6c52" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; this command returns the remaining time to live of a key that has an expire set, with the sole difference that &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; returns the amount of remaining time in seconds while &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; returns it in milliseconds.</source>
          <target state="translated">&lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; 과 마찬가지로이 명령은 만료 세트가있는 키의 남은 시간을 반환합니다. 단, &lt;a href=&quot;ttl&quot;&gt;TTL&lt;/a&gt; 은 남은 시간을 초 단위로 반환하고 &lt;a href=&quot;pttl&quot;&gt;PTTL&lt;/a&gt; 은 밀리 초를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="199ff2ec8051414c46a22a354ba2c4bf9f64de93" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; this command can be used in order to iterate the whole stream content, however note that in this case, the next command calls should use the ID of the last entry, with the sequence number decremneted by one. However if the sequence number is already 0, the time part of the ID should be decremented by 1, and the sequence part should be set to the maxium possible sequence number, that is, 18446744073709551615, or could be omitted at all, and the command will automatically assume it to be such a number (see &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; for more info about incomplete IDs).</source>
          <target state="translated">&lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 와 마찬가지로이 명령을 사용하여 전체 스트림 내용을 반복 할 수 있지만이 경우 다음 명령 호출은 마지막 항목의 ID를 사용하고 순서 번호는 1 씩 감소해야합니다. 그러나 시퀀스 번호가 이미 0 인 경우 ID의 시간 부분은 1 씩 감소해야하며 시퀀스 부분은 가능한 최대 시퀀스 번호, 즉 18446744073709551615로 설정되거나 전혀 생략 될 수 있습니다. 자동으로 숫자로 간주합니다 ( 불완전한 ID에 대한 자세한 내용은 &lt;a href=&quot;xrange&quot;&gt;XRANGE&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="7a5a0a2011829340fa32a8f044e479cef542a701" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;xread&quot;&gt;XREAD&lt;/a&gt; the &lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP&lt;/a&gt; command can be used in a blocking way. There are no differences in this regard.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;xread&quot;&gt;XREAD &lt;/a&gt;&lt;a href=&quot;xreadgroup&quot;&gt;XREADGROUP의&lt;/a&gt; 명령은 차단 방법으로 사용할 수 있습니다. 이와 관련하여 차이점은 없습니다.</target>
        </trans-unit>
        <trans-unit id="964c6e379f4b517ab54346bbc59cea679f55f58d" translate="yes" xml:space="preserve">
          <source>Like for the &lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; command start and end can contain negative values in order to index bytes starting from the end of the string, where -1 is the last byte, -2 is the penultimate, and so forth.</source>
          <target state="translated">&lt;a href=&quot;getrange&quot;&gt;GETRANGE&lt;/a&gt; 명령 과 마찬가지로 start 및 end에는 문자열의 끝에서 시작하여 바이트를 인덱싱하기 위해 음수 값이 포함될 수 있습니다. 여기서 -1은 마지막 바이트이고 -2는 두 번째입니다.</target>
        </trans-unit>
        <trans-unit id="ce45b8148c6f69841bc195d50623329ea61f3da8" translate="yes" xml:space="preserve">
          <source>Lines can contain a section name (starting with a # character) or a property. All the properties are in the form of &lt;code&gt;field:value&lt;/code&gt; terminated by &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">행은 섹션 이름 (# 문자로 시작) 또는 속성을 포함 할 수 있습니다. 모든 속성은 &lt;code&gt;\r\n&lt;/code&gt; 끝나는 &lt;code&gt;field:value&lt;/code&gt; 형식으로 되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="39de9fe457bd2e361245f87b008646c82403b58e" translate="yes" xml:space="preserve">
          <source>List of rules</source>
          <target state="translated">규칙 목록</target>
        </trans-unit>
        <trans-unit id="57c9502a7d7d48fd4a86b45fefb2b163491c3ae1" translate="yes" xml:space="preserve">
          <source>Lists</source>
          <target state="translated">Lists</target>
        </trans-unit>
        <trans-unit id="899acbf6050de7813479a962bcb80b73089f0f38" translate="yes" xml:space="preserve">
          <source>Lists can be encoded as &lt;code&gt;ziplist&lt;/code&gt; or &lt;code&gt;linkedlist&lt;/code&gt;. The &lt;code&gt;ziplist&lt;/code&gt; is the special representation that is used to save space for small lists.</source>
          <target state="translated">리스트는 &lt;code&gt;ziplist&lt;/code&gt; 또는 &lt;code&gt;linkedlist&lt;/code&gt; 로 인코딩 될 수 있습니다 . &lt;code&gt;ziplist&lt;/code&gt; 은 작은 목록에 대한 공간을 절약하기 위해 사용되는 특별한 표현이다.</target>
        </trans-unit>
        <trans-unit id="db5be7f471516f84344dd104ba9b8aa174ce8d02" translate="yes" xml:space="preserve">
          <source>Lists the currently &lt;em&gt;active channels&lt;/em&gt;. An active channel is a Pub/Sub channel with one or more subscribers (not including clients subscribed to patterns).</source>
          <target state="translated">현재 &lt;em&gt;활성화 된 채널을&lt;/em&gt; 나열합니다 . 활성 채널은 하나 이상의 가입자 (패턴에 가입 한 클라이언트는 포함하지 않음)가있는 Pub / Sub 채널입니다.</target>
        </trans-unit>
        <trans-unit id="dcea1d44bcfef24039b8c1d6348290fc06d43c9a" translate="yes" xml:space="preserve">
          <source>Load a script into the scripts cache, without executing it. After the specified command is loaded into the script cache it will be callable using &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; with the correct SHA1 digest of the script, exactly like after the first successful invocation of &lt;a href=&quot;eval&quot;&gt;EVAL&lt;/a&gt;.</source>
          <target state="translated">스크립트를 실행하지 않고 스크립트를 스크립트 캐시에로드하십시오. 지정된 명령이 스크립트 캐시에로드 된 후 &lt;a href=&quot;eval&quot;&gt;EVAL을&lt;/a&gt; 처음 성공적으로 호출 한 후와 마찬가지로 스크립트의 올바른 SHA1 다이제스트와 함께 &lt;a href=&quot;evalsha&quot;&gt;EVALSHA&lt;/a&gt; 를 사용하여 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="735c2e48480d01f1dceaeb55af3cf36dcdd6249a" translate="yes" xml:space="preserve">
          <source>Loads a module from a dynamic library at runtime.</source>
          <target state="translated">런타임에 동적 라이브러리에서 모듈을로드합니다.</target>
        </trans-unit>
        <trans-unit id="694b70e7b053ef29ce888020d6a15ef0d17437e5" translate="yes" xml:space="preserve">
          <source>Lua boolean -&amp;gt; Redis boolean true or false. &lt;strong&gt;Note that this is a change compared to the RESP2 mode&lt;/strong&gt;, where returning true from Lua returned the number 1 to the Redis client, and returning false used to return NULL.</source>
          <target state="translated">Lua 부울-&amp;gt; Redis 부울 참 또는 거짓. &lt;strong&gt;이는&lt;/strong&gt; Lua에서 true를 반환하면 Redis 클라이언트에 숫자 1을 반환하고 NULL을 반환하는 데 사용되는 false를 반환 &lt;strong&gt;하는 RESP2 모드와 비교하여 변경된 것&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bcd47c9d2232eb759e90bf52905602d787217e6e" translate="yes" xml:space="preserve">
          <source>Lua boolean false -&amp;gt; Redis Nil bulk reply.</source>
          <target state="translated">루아 부울 거짓-&amp;gt; Redis Nil 대량 회신.</target>
        </trans-unit>
        <trans-unit id="197815ca05866b7c30c1048b9d86321ee4ce6238" translate="yes" xml:space="preserve">
          <source>Lua boolean true -&amp;gt; Redis integer reply with value of 1.</source>
          <target state="translated">루아 부울 true-&amp;gt; Redis 정수 응답은 1 값입니다.</target>
        </trans-unit>
        <trans-unit id="02dda41ef75370280dc992551fadb03b88d21b1f" translate="yes" xml:space="preserve">
          <source>Lua does not export commands to access the system time or other external state.</source>
          <target state="translated">Lua는 시스템 시간 또는 기타 외부 상태에 액세스하기위한 명령을 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="738b234f859993680828647d652f6de5655b0815" translate="yes" xml:space="preserve">
          <source>Lua has a single numerical type, Lua numbers. There is no distinction between integers and floats. So we always convert Lua numbers into integer replies, removing the decimal part of the number if any. &lt;strong&gt;If you want to return a float from Lua you should return it as a string&lt;/strong&gt;, exactly like Redis itself does (see for instance the &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; command).</source>
          <target state="translated">루아는 단일 숫자 유형 인 루아 숫자를가집니다. 정수와 부동 수에는 차이가 없습니다. 따라서 항상 루아 숫자를 정수 응답으로 변환하여 숫자의 소수 부분을 제거합니다. &lt;strong&gt;Lua에서 부동 소수점을 반환하려면&lt;/strong&gt; Redis 자체와 동일하게 &lt;strong&gt;문자열로 반환해야합니다&lt;/strong&gt; (예 : &lt;a href=&quot;zscore&quot;&gt;ZSCORE&lt;/a&gt; 명령 참조).</target>
        </trans-unit>
        <trans-unit id="8a5d229484ee19b076e60e7fc0d0b8345579dcc1" translate="yes" xml:space="preserve">
          <source>Lua null -&amp;gt; Redis RESP3 new null reply (protocol &lt;code&gt;&quot;_\r\n&quot;&lt;/code&gt;).</source>
          <target state="translated">Lua null-&amp;gt; Redis RESP3 새로운 null 응답 (프로토콜 &lt;code&gt;&quot;_\r\n&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7c212b1d165a2bdadf01bf8c01c306a9c3e780aa" translate="yes" xml:space="preserve">
          <source>Lua number -&amp;gt; Redis integer reply (the number is converted into an integer)</source>
          <target state="translated">루아 번호-&amp;gt; Redis 정수 응답 (숫자가 정수로 변환 됨)</target>
        </trans-unit>
        <trans-unit id="0fcb79bd3680efc38fab49be15ad5a556da29a6c" translate="yes" xml:space="preserve">
          <source>Lua pseudo random number generation functions &lt;code&gt;math.random&lt;/code&gt; and &lt;code&gt;math.randomseed&lt;/code&gt; are modified in order to always have the same seed every time a new script is executed. This means that calling &lt;code&gt;math.random&lt;/code&gt; will always generate the same sequence of numbers every time a script is executed if &lt;code&gt;math.randomseed&lt;/code&gt; is not used.</source>
          <target state="translated">루아 의사 난수 생성 함수 &lt;code&gt;math.random&lt;/code&gt; 및 &lt;code&gt;math.randomseed&lt;/code&gt; 는 새 스크립트가 실행될 때마다 항상 동일한 시드를 갖도록 수정됩니다. 호출하는 것으로이 수단 &lt;code&gt;math.random&lt;/code&gt; 항상 숫자의 동일한 시퀀스를 경우 스크립트가 실행될 때마다 생성합니다 &lt;code&gt;math.randomseed&lt;/code&gt; 가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e026038d7a23da497563d39bf562be4e8b076af8" translate="yes" xml:space="preserve">
          <source>Lua scripts can return a value that is converted from the Lua type to the Redis protocol using a set of conversion rules.</source>
          <target state="translated">Lua 스크립트는 일련의 변환 규칙을 사용하여 Lua 유형에서 Redis 프로토콜로 변환 된 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eec8779958c6af77259f2bed4f2206965d44330b" translate="yes" xml:space="preserve">
          <source>Lua string -&amp;gt; Redis bulk reply</source>
          <target state="translated">루아 문자열-&amp;gt; Redis 대량 회신</target>
        </trans-unit>
        <trans-unit id="0b78d29489185b7463559dbd5991d9b98e6ea241" translate="yes" xml:space="preserve">
          <source>Lua table (array) -&amp;gt; Redis multi bulk reply (truncated to the first nil inside the Lua array if any)</source>
          <target state="translated">Lua 테이블 (배열)-&amp;gt; Redis 다중 벌크 응답 (있는 경우 Lua 배열 내부의 첫 번째 nil로 잘림)</target>
        </trans-unit>
        <trans-unit id="011559d094bdd466ae90420b82cf3259960bb378" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;double&lt;/code&gt; field set to a field-value Lua table -&amp;gt; Redis double reply.</source>
          <target state="translated">단일 &lt;code&gt;double&lt;/code&gt; 필드가 필드 값 Lua 테이블-&amp;gt; Redis 이중 응답으로 설정된 Lua 테이블.</target>
        </trans-unit>
        <trans-unit id="92dffb8e404af7ee6cc40117a693313890548b7f" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;err&lt;/code&gt; field -&amp;gt; Redis error reply</source>
          <target state="translated">단일 &lt;code&gt;err&lt;/code&gt; 필드 가있는 Lua 테이블 -&amp;gt; Redis 오류 응답</target>
        </trans-unit>
        <trans-unit id="31b3bac91c4fbeb254b85ca62a253ad709c8a47f" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;map&lt;/code&gt; field set to a field-value Lua table -&amp;gt; Redis map reply.</source>
          <target state="translated">단일 &lt;code&gt;map&lt;/code&gt; 필드가 필드 값 Lua 테이블-&amp;gt; Redis 맵 응답으로 설정된 Lua 테이블.</target>
        </trans-unit>
        <trans-unit id="860f10116eaffeabf918bd97496952f6a8568b86" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;ok&lt;/code&gt; field -&amp;gt; Redis status reply</source>
          <target state="translated">하나와 루아 테이블 &lt;code&gt;ok&lt;/code&gt; 필드 -&amp;gt; 레디 스 상태 응답</target>
        </trans-unit>
        <trans-unit id="c86e8370e8448b07f033d118ba308f34fc561150" translate="yes" xml:space="preserve">
          <source>Lua table with a single &lt;code&gt;set&lt;/code&gt; field set to a field-value Lua table -&amp;gt; Redis set reply, the values are discarded and can be anything.</source>
          <target state="translated">단일 &lt;code&gt;set&lt;/code&gt; 필드가 필드 값 Lua 테이블-&amp;gt; Redis 세트 응답으로 설정된 Lua 테이블은 값이 삭제되고 무엇이든 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4b1c471ce1efbe25d7232b293140a21b7fea826" translate="yes" xml:space="preserve">
          <source>MEMORY</source>
          <target state="translated">MEMORY</target>
        </trans-unit>
        <trans-unit id="5f530d724793deebbb2b735aad30cfb0c16904b5" translate="yes" xml:space="preserve">
          <source>MEMORY DOCTOR   Outputs memory problems report</source>
          <target state="translated">MEMORY DOCTOR 메모리 문제 보고서를 출력합니다</target>
        </trans-unit>
        <trans-unit id="f41c78df06ee10a6b220b355855965b8d5802f0d" translate="yes" xml:space="preserve">
          <source>MEMORY HELP   Show helpful text about the different subcommands</source>
          <target state="translated">MEMORY HELP 다른 하위 명령에 대한 유용한 텍스트 표시</target>
        </trans-unit>
        <trans-unit id="c46a26bce66617f3cb9ccdc83db737a6115fdc5d" translate="yes" xml:space="preserve">
          <source>MEMORY MALLOC-STATS   Show allocator internal stats</source>
          <target state="translated">메모리 MALLOC-STATS 할당 자 내부 통계 표시</target>
        </trans-unit>
        <trans-unit id="eb96d4965b5bb6522ee6573db44c8a6e1ce6edba" translate="yes" xml:space="preserve">
          <source>MEMORY PURGE   Ask the allocator to release memory</source>
          <target state="translated">메모리 제거 할당 자에게 메모리 해제를 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="d3303c80cf9ee1aa6f783b72419ffa190e2a905d" translate="yes" xml:space="preserve">
          <source>MEMORY STATS   Show memory usage details</source>
          <target state="translated">메모리 통계 메모리 사용량 세부 정보 표시</target>
        </trans-unit>
        <trans-unit id="de9aed5605340cafa3f173e741e4bc7253d17f99" translate="yes" xml:space="preserve">
          <source>MEMORY USAGE  key [SAMPLES count]   Estimate the memory usage of a key</source>
          <target state="translated">MEMORY USAGE 키 [SAMPLES count] 키의 메모리 사용량을 추정하십시오.</target>
        </trans-unit>
        <trans-unit id="eb4b445b699787b561e4b67d4f6b08a7ef32cf55" translate="yes" xml:space="preserve">
          <source>MGET</source>
          <target state="translated">MGET</target>
        </trans-unit>
        <trans-unit id="ffbcf2b819692d7b52978ca1ef1e227536a082fe" translate="yes" xml:space="preserve">
          <source>MGET  key [key ...]   Get the values of all the given keys</source>
          <target state="translated">MGET 키 [key ...] 주어진 모든 키의 값을 얻습니다</target>
        </trans-unit>
        <trans-unit id="883beaf0f91aca7f9ebc4802e0bab2501cbbc8ea" translate="yes" xml:space="preserve">
          <source>MIGRATE</source>
          <target state="translated">MIGRATE</target>
        </trans-unit>
        <trans-unit id="c26be640f072695430c6befbdaab1be7da9a4af0" translate="yes" xml:space="preserve">
          <source>MIGRATE  host port key|&quot;&quot; destination-db timeout [COPY] [REPLACE] [AUTH password] [AUTH2 username password] [KEYS key [key ...]]   Atomically transfer a key from a Redis instance to another one.</source>
          <target state="translated">호스트 포트 키 마이그레이션 | &quot;&quot;destination-db timeout [COPY] [REPLACE] [AUTH password] [AUTH2 username password] [KEYS key [key ...]] Redis 인스턴스에서 다른 인스턴스로 키를 원자 적으로 전송합니다.</target>
        </trans-unit>
        <trans-unit id="2f0b2cdf3b3d88df6ed56ef5576fa5ec1a8aa5b1" translate="yes" xml:space="preserve">
          <source>MIGRATE  host port key|&quot;&quot; destination-db timeout [COPY] [REPLACE] [KEYS key [key ...]]   Atomically transfer a key from a Redis instance to another one.</source>
          <target state="translated">마이그레이션 호스트 포트 키 | &quot;&quot;destination-db 시간 초과 [복사] [바꾸기] [KEYS 키 [키 ...]] Redis 인스턴스에서 다른 키로 원자 적으로 키를 전송합니다.</target>
        </trans-unit>
        <trans-unit id="66bffe2295ae671e5d45439c77216938c792414b" translate="yes" xml:space="preserve">
          <source>MODULE</source>
          <target state="translated">MODULE</target>
        </trans-unit>
        <trans-unit id="43ac8ce01de13f2da2af292daa0522a8dce0815f" translate="yes" xml:space="preserve">
          <source>MODULE LIST   List all modules loaded by the server</source>
          <target state="translated">MODULE LIST 서버에서로드 한 모든 모듈을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="ead5dec077ff0d8c33078bffc3edb3a161d0c8b1" translate="yes" xml:space="preserve">
          <source>MODULE LOAD  path [ arg [arg ...]]   Load a module</source>
          <target state="translated">MODULE LOAD path [arg [arg ...]] 모듈로드</target>
        </trans-unit>
        <trans-unit id="c8d0e227668f65977f974daf28058d755a01a58f" translate="yes" xml:space="preserve">
          <source>MODULE UNLOAD  name   Unload a module</source>
          <target state="translated">MODULE UNLOAD 이름 모듈 언로드</target>
        </trans-unit>
        <trans-unit id="6da5b5979c630adef5abc39370410d7de4a1b8ef" translate="yes" xml:space="preserve">
          <source>MONITOR</source>
          <target state="translated">MONITOR</target>
        </trans-unit>
        <trans-unit id="55d4d86d6d24375e297cf38db11a4bacd4febc84" translate="yes" xml:space="preserve">
          <source>MONITOR   Listen for all requests received by the server in real time</source>
          <target state="translated">MONITOR 서버가 실시간으로 수신 한 모든 요청을 청취</target>
        </trans-unit>
        <trans-unit id="3bf08a84f15b98ce4d14b707f4a093b3cc8b853e" translate="yes" xml:space="preserve">
          <source>MOVE</source>
          <target state="translated">MOVE</target>
        </trans-unit>
        <trans-unit id="001d5d6407276cba944eda42b69684ebbbae5d55" translate="yes" xml:space="preserve">
          <source>MOVE  key db   Move a key to another database</source>
          <target state="translated">MOVE key db 키를 다른 데이터베이스로 이동</target>
        </trans-unit>
        <trans-unit id="4a4d41a590643b6020afed2c32a7fa4d49b49601" translate="yes" xml:space="preserve">
          <source>MSET</source>
          <target state="translated">MSET</target>
        </trans-unit>
        <trans-unit id="9a5861cd64b36ffe83c01382e80e50105a256980" translate="yes" xml:space="preserve">
          <source>MSET  key value [key value ...]   Set multiple keys to multiple values</source>
          <target state="translated">MSET 키 값 [key value ...] 여러 키를 여러 값으로 설정</target>
        </trans-unit>
        <trans-unit id="f7daca0dd0ee4f7979861ac9b4fb059852d07494" translate="yes" xml:space="preserve">
          <source>MSETNX</source>
          <target state="translated">MSETNX</target>
        </trans-unit>
        <trans-unit id="48498dbffef6df5e6474fe5db88a9722de54676a" translate="yes" xml:space="preserve">
          <source>MSETNX  key value [key value ...]   Set multiple keys to multiple values, only if none of the keys exist</source>
          <target state="translated">MSETNX 키 값 [key value ...] 키가없는 경우에만 여러 키를 여러 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="73cadb41b45514de9061a72461b466eafd7a01b0" translate="yes" xml:space="preserve">
          <source>MULTI</source>
          <target state="translated">MULTI</target>
        </trans-unit>
        <trans-unit id="bb76d99632737ac9f4ecd1c2218ac5cae7373df0" translate="yes" xml:space="preserve">
          <source>MULTI   Mark the start of a transaction block</source>
          <target state="translated">MULTI 트랜잭션 블록의 시작을 표시합니다</target>
        </trans-unit>
        <trans-unit id="5162c1f5fa963969d600908fd5531f9515bcd0ad" translate="yes" xml:space="preserve">
          <source>Manually issue the &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; command to stop a &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; stream running via &lt;code&gt;telnet&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; 명령을 수동으로 실행하여 &lt;code&gt;telnet&lt;/code&gt; 을 통해 실행 되는 &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 스트림 을 중지하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ab2b333d1a4eb7dc9f5b2c393ae0acfe6aa0aa8" translate="yes" xml:space="preserve">
          <source>Manually issue the &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; or &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; commands to stop a &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; stream running via &lt;code&gt;telnet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;telnet&lt;/code&gt; 통해 실행 되는 &lt;a href=&quot;monitor&quot;&gt;MONITOR&lt;/a&gt; 스트림 을 중지 하려면 &lt;a href=&quot;quit&quot;&gt;QUIT&lt;/a&gt; 또는 &lt;a href=&quot;reset&quot;&gt;RESET&lt;/a&gt; 명령을 수동으로 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="195fbe53b32ee6173d85e3798809ae2267b7bfce" translate="yes" xml:space="preserve">
          <source>Marks the given keys to be watched for conditional execution of a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt;.</source>
          <target state="translated">주어진 키가 &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;트랜잭션의&lt;/a&gt; 조건부 실행을 감시하도록 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="c8683729a7a727945cae9baf35f4c55f1439a9ae" translate="yes" xml:space="preserve">
          <source>Marks the start of a &lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;transaction&lt;/a&gt; block. Subsequent commands will be queued for atomic execution using &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://redis.io/topics/transactions&quot;&gt;트랜잭션&lt;/a&gt; 블록 의 시작을 표시합니다 . 후속 명령은 &lt;a href=&quot;exec&quot;&gt;EXEC를&lt;/a&gt; 사용하여 원자 실행을 위해 대기합니다 .</target>
        </trans-unit>
        <trans-unit id="f713e2ee906af8b74a13e92b2e0d07f7715b2d2e" translate="yes" xml:space="preserve">
          <source>Master for slot range represented as nested IP/Port array</source>
          <target state="translated">중첩 된 IP / 포트 배열로 표시되는 슬롯 범위의 마스터</target>
        </trans-unit>
        <trans-unit id="826539552e055ad1bd8dd2263cef37308d024f80" translate="yes" xml:space="preserve">
          <source>Master output</source>
          <target state="translated">마스터 출력</target>
        </trans-unit>
        <trans-unit id="221cc49f520f042d2c8db1934cf7365d8019893a" translate="yes" xml:space="preserve">
          <source>Matches are produced from the last one to the first one, since this is how the algorithm works, and it more efficient to emit things in the same order. The above array means that the first match (second element of the array) is between positions 2-3 of the first string and 0-1 of the second. Then there is another match between 4-7 and 5-8.</source>
          <target state="translated">이것이 알고리즘이 작동하는 방식이기 때문에 마지막 것부터 첫 번째 것까지 일치가 생성되며 동일한 순서로 항목을 방출하는 것이 더 효율적입니다. 위의 배열은 첫 번째 일치 (배열의 두 번째 요소)가 첫 번째 문자열의 위치 2-3과 두 번째 문자열의 0-1 사이에 있음을 의미합니다. 그런 다음 4-7과 5-8 사이에 또 ​​다른 일치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a00e4f9797b4c734ae7a585f001ffa257119f27" translate="yes" xml:space="preserve">
          <source>Meaning of the flags (field number 3):</source>
          <target state="translated">플래그의 의미 (필드 번호 3) :</target>
        </trans-unit>
        <trans-unit id="716383f923909d0c089205fcba00d4705b3601a5" translate="yes" xml:space="preserve">
          <source>Merge multiple HyperLogLog values into an unique value that will approximate the cardinality of the union of the observed Sets of the source HyperLogLog structures.</source>
          <target state="translated">여러 HyperLogLog 값을 고유 한 값으로 병합하여 관찰 된 소스 HyperLogLog 구조 세트의 합집합의 카디널리티에 근접합니다.</target>
        </trans-unit>
        <trans-unit id="d48699ea9bf170ea49610c0892198d522150833b" translate="yes" xml:space="preserve">
          <source>Migrating multiple keys with a single command call</source>
          <target state="translated">단일 명령 호출로 여러 키 마이그레이션</target>
        </trans-unit>
        <trans-unit id="1dc9fdcdad40a742a94a677f3b78a05f4ed5e6b5" translate="yes" xml:space="preserve">
          <source>Migration and importing slots are only added to the node flagged as &lt;code&gt;myself&lt;/code&gt;. This information is local to a node, for its own slots.</source>
          <target state="translated">마이그레이션 및 가져 오기 슬롯은 &lt;code&gt;myself&lt;/code&gt; 표시된 노드에만 추가됩니다 . 이 정보는 자체 슬롯에 대해 노드에 로컬입니다.</target>
        </trans-unit>
        <trans-unit id="b39875ef4297a449c400e22ef1b7f5a9df1b0b1a" translate="yes" xml:space="preserve">
          <source>Modules that register custom data types can not be unloaded.</source>
          <target state="translated">사용자 정의 데이터 유형을 등록하는 모듈은 언로드 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf4ac897fe1476ddf0632fbae3fd4061b3a77806" translate="yes" xml:space="preserve">
          <source>More details about the Redis HyperLogLog implementation can be found in &lt;a href=&quot;http://antirez.com/news/75&quot;&gt;this blog post&lt;/a&gt;. The source code of the implementation in the &lt;code&gt;hyperloglog.c&lt;/code&gt; file is also easy to read and understand, and includes a full specification for the exact encoding used for the sparse and dense representations.</source>
          <target state="translated">Redis HyperLogLog 구현에 대한 자세한 내용은 &lt;a href=&quot;http://antirez.com/news/75&quot;&gt;이 블로그 게시물&lt;/a&gt; 에서 확인할 수 있습니다 . &lt;code&gt;hyperloglog.c&lt;/code&gt; 파일 에서 구현의 소스 코드 도 읽고 이해하기 쉽고 희소하고 조밀 한 표현에 사용되는 정확한 인코딩에 대한 전체 사양을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="66fbce4faebab20f5ca1d3b33c08e967f22406cb" translate="yes" xml:space="preserve">
          <source>More information about the Current Epoch and Config Epoch variables are available in the Redis Cluster specification document.</source>
          <target state="translated">현재 Epoch 및 구성 Epoch 변수에 대한 자세한 내용은 Redis Cluster 사양 문서에서 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76f5a5481231f7dff85e48d6a0993bd209662a44" translate="yes" xml:space="preserve">
          <source>Moreover &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; does not need to be reciprocal. If I send the command to A in order to join B, I don't need to also send it to B in order to join A.</source>
          <target state="translated">또한 &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; 은 상호적일 필요는 없습니다. B에 가입하기 위해 A로 명령을 보내면 A에 가입하기 위해 B로도 명령을 보낼 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e46ae1b67b3a95c0efb340b998c24643ca486fb" translate="yes" xml:space="preserve">
          <source>Moreover, as a side effect, &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will increment the count of attempted deliveries of the message unless the &lt;code&gt;JUSTID&lt;/code&gt; option has been specified (which only delivers the message ID, not the message itself). In this way messages that cannot be processed for some reason, for instance because the consumers crash attempting to process them, will start to have a larger counter and can be detected inside the system.</source>
          <target state="translated">또한 부작용으로 &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; 은 &lt;code&gt;JUSTID&lt;/code&gt; 옵션 (메시지 자체가 아닌 메시지 ID 만 전달)이 지정 되지 않은 경우 메시지 전달 시도 횟수를 증가시킵니다 . 이러한 방식으로 어떤 이유로 처리 할 수없는 메시지 (예 : 소비자가 메시지를 처리하려는 경우 충돌이 발생하기 때문에)는 더 큰 카운터를 갖기 시작하고 시스템 내부에서 감지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8993f2e40360ac488b5303cad3bacad41d3a08f1" translate="yes" xml:space="preserve">
          <source>Moreover, as a side effect, &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will increment the count of attempted deliveries of the message. In this way messages that cannot be processed for some reason, for instance because the consumers crash attempting to process them, will start to have a larger counter and can be detected inside the system.</source>
          <target state="translated">또한 부작용으로 &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; 은 메시지 배달 시도 횟수를 증가시킵니다. 이런 식으로 어떤 이유로 처리 할 수없는 메시지 (예 : 소비자가 메시지를 처리하려고 시도하면 충돌)는 더 큰 카운터를 갖기 시작하고 시스템 내부에서 감지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6330fc6bbcd49c1766a676116e26172a91d38595" translate="yes" xml:space="preserve">
          <source>Moreover, if you are new to streams, we recommend to read our &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;introduction to Redis Streams&lt;/a&gt;. Make sure to understand the concept of consumer group in the introduction so that following how this command works will be simpler.</source>
          <target state="translated">또한 스트림을 &lt;a href=&quot;https://redis.io/topics/streams-intro&quot;&gt;처음 사용하는 경우 Redis Streams 소개를&lt;/a&gt; 읽는 것이 좋습니다 . 소개에서 소비자 그룹의 개념을 이해해야이 명령의 작동 방식을 따르는 것이 더 간단 해집니다.</target>
        </trans-unit>
        <trans-unit id="fde66fa86f8517d887e54616bf1fb31656fc7f81" translate="yes" xml:space="preserve">
          <source>Motivations</source>
          <target state="translated">Motivations</target>
        </trans-unit>
        <trans-unit id="eaf7a15ddfb6c5c306f486c8bf293512f163a845" translate="yes" xml:space="preserve">
          <source>Movable Keys</source>
          <target state="translated">움직일 수있는 키</target>
        </trans-unit>
        <trans-unit id="f77b47b8d13d94af9785e089c536b9963ca2c823" translate="yes" xml:space="preserve">
          <source>Move &lt;code&gt;key&lt;/code&gt; from the currently selected database (see &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt;) to the specified destination database. When &lt;code&gt;key&lt;/code&gt; already exists in the destination database, or it does not exist in the source database, it does nothing. It is possible to use &lt;a href=&quot;move&quot;&gt;MOVE&lt;/a&gt; as a locking primitive because of this.</source>
          <target state="translated">현재 선택된 데이터베이스 ( &lt;a href=&quot;select&quot;&gt;SELECT&lt;/a&gt; 참조 )에서 지정된 대상 데이터베이스로 &lt;code&gt;key&lt;/code&gt; 를 이동 하십시오 . 때 &lt;code&gt;key&lt;/code&gt; 이미 대상 데이터베이스에 존재하거나 소스 데이터베이스에 존재하지 않는, 그것은 아무것도하지 않는다. 이 때문에 &lt;a href=&quot;move&quot;&gt;MOVE&lt;/a&gt; 를 잠금 프리미티브로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17c083c9f9d68a5d0169cd11d9c0c04115759b24" translate="yes" xml:space="preserve">
          <source>Move &lt;code&gt;member&lt;/code&gt; from the set at &lt;code&gt;source&lt;/code&gt; to the set at &lt;code&gt;destination&lt;/code&gt;. This operation is atomic. In every given moment the element will appear to be a member of &lt;code&gt;source&lt;/code&gt;&lt;strong&gt;or&lt;/strong&gt;&lt;code&gt;destination&lt;/code&gt; for other clients.</source>
          <target state="translated">&lt;code&gt;source&lt;/code&gt; 세트에서 &lt;code&gt;destination&lt;/code&gt; 세트로 &lt;code&gt;member&lt;/code&gt; 를 이동 하십시오 . 이 작업은 원 자성입니다. 주어진 순간마다 요소는 다른 클라이언트 의 &lt;code&gt;source&lt;/code&gt; &lt;strong&gt;또는 &lt;/strong&gt; &lt;code&gt;destination&lt;/code&gt; 의 구성원으로 나타납니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="95a91b78dd0ce912aadce361711a043cae9a887e" translate="yes" xml:space="preserve">
          <source>Multiple parallel iterations</source>
          <target state="translated">다중 병렬 반복</target>
        </trans-unit>
        <trans-unit id="f492964822aab7cec6aa84fefaffe8fba8b6cd36" translate="yes" xml:space="preserve">
          <source>Nested Result Array</source>
          <target state="translated">중첩 된 결과 배열</target>
        </trans-unit>
        <trans-unit id="fdc70576104b358de95d88f0255666aac631aff0" translate="yes" xml:space="preserve">
          <source>New fields are regularly added for debugging purpose. Some could be removed in the future. A version safe Redis client using this command should parse the output accordingly (i.e. handling gracefully missing fields, skipping unknown fields).</source>
          <target state="translated">디버깅을 위해 새 필드가 정기적으로 추가됩니다. 나중에 일부를 제거 할 수 있습니다. 이 명령을 사용하는 버전 안전 Redis 클라이언트는 그에 따라 출력을 구문 분석해야합니다 (예 : 정상적으로 누락 된 필드 처리, 알 수없는 필드 생략).</target>
        </trans-unit>
        <trans-unit id="861e51e24f78632f52937df883ebeed5a0766d52" translate="yes" xml:space="preserve">
          <source>New keys are always created in the target node. During a hash slot migration we'll have to move only old keys, not new ones.</source>
          <target state="translated">새 키는 항상 대상 노드에 작성됩니다. 해시 슬롯 마이그레이션 중에는 새로운 키가 아닌 이전 키만 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="97bfa87b383568ddb64d92c09cf59316bbb313bd" translate="yes" xml:space="preserve">
          <source>No repeated elements are returned.</source>
          <target state="translated">반복되는 요소가 리턴되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75e932f04e490ddd2c64a4420d419573bd058eac" translate="yes" xml:space="preserve">
          <source>Nodes in &lt;code&gt;PFAIL&lt;/code&gt; state are provided in gossip sections of heartbeat packets.</source>
          <target state="translated">&lt;code&gt;PFAIL&lt;/code&gt; 상태의 노드 는 하트 비트 패킷의 가십 섹션에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c02697f1f51c2f137246d46e8911c8e7f53e6636" translate="yes" xml:space="preserve">
          <source>Non existing elements are reported as NULL elements of the array.</source>
          <target state="translated">존재하지 않는 요소는 배열의 NULL 요소로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="5dfb2fbf84cf8de01a0c2542d485d2207dc976ae" translate="yes" xml:space="preserve">
          <source>Non used lines are blanked. For instance if you used to have multiple &lt;code&gt;save&lt;/code&gt; directives, but the current configuration has fewer or none as you disabled RDB persistence, all the lines will be blanked.</source>
          <target state="translated">사용되지 않은 줄은 비워집니다. 예를 들어 , 여러 &lt;code&gt;save&lt;/code&gt; 지시문을 사용했지만 RDB 지속성을 사용하지 않도록 설정했을 때 현재 구성의 수가 적거나없는 경우 모든 행이 공백이됩니다.</target>
        </trans-unit>
        <trans-unit id="de44f50198c0734dcccb5b1c5d4825eb72c13aba" translate="yes" xml:space="preserve">
          <source>Non-blocking behavior</source>
          <target state="translated">비 차단 행동</target>
        </trans-unit>
        <trans-unit id="5cbfa62b0d0a8a33923d06127db99370a393ad0d" translate="yes" xml:space="preserve">
          <source>Non-blocking usage</source>
          <target state="translated">비 차단 사용량</target>
        </trans-unit>
        <trans-unit id="bcbbb0c35f64190eb100cd6befa838fbd5037874" translate="yes" xml:space="preserve">
          <source>Non-existent keys are treated as empty strings, so the command will return zero.</source>
          <target state="translated">존재하지 않는 키는 빈 문자열로 취급되므로 명령이 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="46b493cea7b65b3003ea2e423707591849b0ee78" translate="yes" xml:space="preserve">
          <source>Non-existent keys are treated as empty strings.</source>
          <target state="translated">존재하지 않는 키는 빈 문자열로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="9a60acaa61d5a344489afdd9e5311dbf8888aa00" translate="yes" xml:space="preserve">
          <source>Normally &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; is simply used in order to get range of items where the score is the indexed integer key, however it is possible to do less obvious things with the command.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;zrangebyscore&quot;&gt;ZRANGEBYSCORE&lt;/a&gt; 는 점수가 색인화 된 정수 키인 항목의 범위를 가져 오기 위해 간단히 사용되지만 명령으로 덜 명확한 일을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dba9f7be4e65fcc1fd8d86533e96e912932e110" translate="yes" xml:space="preserve">
          <source>Normally Redis keys are created without an associated time to live. The key will simply live forever, unless it is removed by the user in an explicit way, for instance using the &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; command.</source>
          <target state="translated">일반적으로 Redis 키는 관련 시간없이 생성됩니다. 키는 사용자가 &lt;a href=&quot;del&quot;&gt;DEL&lt;/a&gt; 명령을 사용하는 등의 명시적인 방법으로 제거하지 않는 한 영원히 지속 됩니다.</target>
        </trans-unit>
        <trans-unit id="488e099ce2d3130dde9348d7a491fea120dffc25" translate="yes" xml:space="preserve">
          <source>Normally Redis represents positions of elements using a variation of the Geohash technique where positions are encoded using 52 bit integers. The encoding is also different compared to the standard because the initial min and max coordinates used during the encoding and decoding process are different. This command however &lt;strong&gt;returns a standard Geohash&lt;/strong&gt; in the form of a string as described in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Wikipedia article&lt;/a&gt; and compatible with the &lt;a href=&quot;http://geohash.org&quot;&gt;geohash.org&lt;/a&gt; web site.</source>
          <target state="translated">일반적으로 Redis는 위치가 52 비트 정수를 사용하여 인코딩되는 Geohash 기술의 변형을 사용하여 요소의 위치를 ​​나타냅니다. 인코딩 및 디코딩 과정에서 사용되는 초기 최소 및 최대 좌표가 다르기 때문에 인코딩은 표준과 비교하여 다릅니다. 그러나이 명령 은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Geohash&quot;&gt;Wikipedia 기사에&lt;/a&gt; 설명되어 있고 &lt;a href=&quot;http://geohash.org&quot;&gt;geohash.org&lt;/a&gt; 웹 사이트 와 호환 되는 문자열 형식으로 &lt;strong&gt;표준 Geohash&lt;/strong&gt; 를 &lt;strong&gt;반환합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="48fbc2c3360b2ccdab702dc73f1af3fdad88932d" translate="yes" xml:space="preserve">
          <source>Normally hash slots associated to a given node are in one of the following formats, as already explained above:</source>
          <target state="translated">주어진 노드와 연관된 해시 슬롯은 일반적으로 위에서 설명한대로 다음 형식 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="20da22f8d3c73a214f41394b1c9a9c08c0230154" translate="yes" xml:space="preserve">
          <source>Normally if there is an AOF child process performing an AOF rewrite, Redis will simply kill it and exit. However there are two conditions where it is unsafe to do so, and the &lt;strong&gt;SHUTDOWN&lt;/strong&gt; command will be refused with an error instead. This happens when:</source>
          <target state="translated">일반적으로 AOF 재 작성을 수행하는 AOF 하위 프로세스가있는 경우 Redis는 단순히 프로세스를 종료하고 종료합니다. 그러나 안전하지 않은 두 가지 조건 이 있으며 대신 오류와 함께 &lt;strong&gt;SHUTDOWN&lt;/strong&gt; 명령이 거부됩니다. 다음과 같은 경우에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f552eaf00c55408f0aa996335bcd91c4da8dcdb7" translate="yes" xml:space="preserve">
          <source>Normally replica nodes will redirect clients to the authoritative master for the hash slot involved in a given command, however clients can use replicas in order to scale reads using the &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; command.</source>
          <target state="translated">일반적으로 복제본 노드는 지정된 명령에 포함 된 해시 슬롯에 대해 권한이있는 마스터로 클라이언트를 리디렉션하지만 클라이언트는 &lt;a href=&quot;readonly&quot;&gt;READONLY&lt;/a&gt; 명령을 사용하여 읽기를 확장하기 위해 복제본을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b040d0fd81d55e920e28d6b8b43687a96fedfb9" translate="yes" xml:space="preserve">
          <source>Normally replicating scripts instead of the effects of the scripts makes sense, however not in all the cases. So starting with Redis 3.2, the scripting engine is able to, alternatively, replicate the sequence of write commands resulting from the script execution, instead of replication the script itself. See the next section for more information. In this section we'll assume that scripts are replicated by sending the whole script. Let's call this replication mode &lt;strong&gt;whole scripts replication&lt;/strong&gt;.</source>
          <target state="translated">일반적으로 스크립트의 효과 대신 스크립트를 복제하는 것이 의미가 있지만 모든 경우에 해당되는 것은 아닙니다. 따라서 Redis 3.2부터는 스크립팅 엔진이 스크립트 자체를 복제하는 대신 스크립트 실행으로 인한 일련의 쓰기 명령을 복제 할 수 있습니다. 자세한 내용은 다음 섹션을 참조하십시오. 이 섹션에서는 전체 스크립트를 전송하여 스크립트를 복제한다고 가정합니다. 이 복제 모드를 &lt;strong&gt;전체 스크립트 복제라고합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="632bc7f3cbfc39c1e051fc94bc2f5127d08b095a" translate="yes" xml:space="preserve">
          <source>Normally the OK code is immediately returned. Redis forks, the parent continues to serve the clients, the child saves the DB on disk then exits.</source>
          <target state="translated">일반적으로 OK 코드는 즉시 반환됩니다. Redis 포크, 부모는 계속 클라이언트에게 서비스를 제공하고 자식은 DB를 디스크에 저장 한 다음 종료합니다.</target>
        </trans-unit>
        <trans-unit id="de2018dd71c22fe4b55fd2f381e3bcbd8ea7b844" translate="yes" xml:space="preserve">
          <source>Normally you may think at a Redis stream as an append-only data structure, however Redis streams are represented in memory, so we are able to also delete entries. This may be useful, for instance, in order to comply with certain privacy policies.</source>
          <target state="translated">일반적으로 Redis 스트림을 추가 전용 데이터 구조로 생각할 수 있지만 Redis 스트림은 메모리에 표시되므로 항목을 삭제할 수도 있습니다. 예를 들어 특정 개인 정보 보호 정책을 준수하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="675cc42aab3b45855f7e4f48b1a8a2f9ea1abcdc" translate="yes" xml:space="preserve">
          <source>Normally you use the command like that in order to get new messages and process them. In pseudo-code:</source>
          <target state="translated">일반적으로 새 메시지를 가져 와서 처리하기 위해 이와 같은 명령을 사용합니다. 의사 코드에서 :</target>
        </trans-unit>
        <trans-unit id="92faf092f64b7750013de7ad70293bed4c22e467" translate="yes" xml:space="preserve">
          <source>Note for Lua newbies: in order to avoid using global variables in your scripts simply declare every variable you are going to use using the &lt;em&gt;local&lt;/em&gt; keyword.</source>
          <target state="translated">Lua 초보자를위한 참고 사항 : 스크립트에서 전역 변수를 사용하지 않으려면 &lt;em&gt;local&lt;/em&gt; 키워드 를 사용하여 사용할 모든 변수를 선언하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="386ff54d1c33b65d55947a3bc043df349ed6b50a" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt;, &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; all work very similarly, so this documentation covers all the four commands. However an obvious difference is that in the case of &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt;, &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; and &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; the first argument is the name of the key holding the Set, Hash or Sorted Set value. The &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; command does not need any key name argument as it iterates keys in the current database, so the iterated object is the database itself.</source>
          <target state="translated">참고 &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; , &lt;a href=&quot;sscan&quot;&gt;sscan을&lt;/a&gt; , &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; 및 &lt;a href=&quot;zscan&quot;&gt;ZSCAN&lt;/a&gt; 매우 유사하게 모든 일을,이 문서 커버 이렇게 모두 네 개의 명령. 그러나 &lt;a href=&quot;sscan&quot;&gt;SSCAN&lt;/a&gt; , &lt;a href=&quot;hscan&quot;&gt;HSCAN&lt;/a&gt; 및 &lt;a href=&quot;zscan&quot;&gt;ZSCAN의&lt;/a&gt; 경우 첫 번째 인수는 Set, Hash 또는 Sorted Set 값을 보유하는 키의 이름이라는 것이 분명한 차이점입니다 . &lt;a href=&quot;scan&quot;&gt;SCAN&lt;/a&gt; 은 현재 데이터베이스에 키를 반복 할 때마다 반복되는 객체는 데이터베이스 자체 그래서 명령은 어떤 키 이름 인수를 필요로하지 않는다.</target>
        </trans-unit>
        <trans-unit id="b8af6b6330cf6687e8cc50e67b81c7d7beffd113" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; does not make Redis a strongly consistent store: while synchronous replication is part of a replicated state machine, it is not the only thing needed. However in the context of Sentinel or Redis Cluster failover, &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; improves the real world data safety.</source>
          <target state="translated">참고 &lt;a href=&quot;wait&quot;&gt;WAIT가&lt;/a&gt; 레디 스 강력한 일관성을 저장하지 않습니다 동기식 복제가 복제 된 상태 머신의 일부입니다 동안, 그것은 필요한 유일한 것은 아니다. 그러나 Sentinel 또는 Redis Cluster 장애 조치와 관련하여 &lt;a href=&quot;wait&quot;&gt;WAIT&lt;/a&gt; 는 실제 데이터 안전성을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="196f50bc6a6ac776d1991175d0001fae97125b81" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; is also available since Redis 3.2.10 and Redis 4.0.0 in order to provide a read-only command that can be used in replicas. See the &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; page for more information.</source>
          <target state="translated">참고 &lt;code&gt;GEORADIUSBYMEMBER_RO&lt;/code&gt; 가 복제에 사용할 수있는 읽기 전용 명령을 제공하기 위해 레디 스 3.2.10와 레디 스 4.0.0 이후도 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;georadius&quot;&gt;GEORADIUS&lt;/a&gt; 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7f4713a8dfe3582f9f0fc3ed836bf0396dfbd617" translate="yes" xml:space="preserve">
          <source>Note that &lt;strong&gt;TAKEOVER violates the last-failover-wins principle&lt;/strong&gt; of Redis Cluster, since the configuration epoch generated by the replica violates the normal generation of configuration epochs in several ways:</source>
          <target state="translated">복제본에서 생성 된 구성 에포크 (epoch)는 여러 가지 방법으로 일반 구성 에포크 (epoch)를 &lt;strong&gt;위반하기&lt;/strong&gt; 때문에 &lt;strong&gt;TAKEOVER&lt;/strong&gt; 는 Redis Cluster &lt;strong&gt;의 마지막 페일 오버&lt;/strong&gt; 윈 &lt;strong&gt;원칙&lt;/strong&gt; 을 위반합니다.</target>
        </trans-unit>
        <trans-unit id="b1e5f99b4ded8ce6be23a9f6f9872d3e5595ab46" translate="yes" xml:space="preserve">
          <source>Note that Redis Cluster needs to form a full mesh (each node is connected with each other node), but in order to create a cluster, there is no need to send all the &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; commands needed to form the full mesh. What matter is to send enough &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; messages so that each node can reach each other node through a &lt;em&gt;chain of known nodes&lt;/em&gt;. Thanks to the exchange of gossip information in heartbeat packets, the missing links will be created.</source>
          <target state="translated">Redis Cluster는 전체 메쉬를 형성해야하지만 (각 노드는 서로 연결되어 있음) 클러스터를 생성하기 위해 전체 메쉬를 형성하는 데 필요한 모든 &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; 명령 을 보낼 필요는 없습니다 . 중요한 것은 각 노드 &lt;em&gt;가 알려진 노드 체인을&lt;/em&gt; 통해 서로 노드에 도달 할 수 있도록 충분한 &lt;a href=&quot;cluster-meet&quot;&gt;CLUSTER MEET&lt;/a&gt; 메시지 를 보내는 것 입니다. 하트 비트 패킷으로 가십 정보를 교환함으로써 누락 된 링크가 생성됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2d97296cb1d6030b84b67b56dc33de3881c08256" translate="yes" xml:space="preserve">
          <source>Note that a script can switch back and forth from RESP3 and RESP2 by calling the function with the argument '3' or '2'.</source>
          <target state="translated">스크립트는 인수 '3'또는 '2'와 함께 함수를 호출하여 RESP3 및 RESP2에서 앞뒤로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17fc5decb8a235b9d4881b1185aa05ef897a69aa" translate="yes" xml:space="preserve">
          <source>Note that bit positions are returned always as absolute values starting from bit zero even when &lt;em&gt;start&lt;/em&gt; and &lt;em&gt;end&lt;/em&gt; are used to specify a range.</source>
          <target state="translated">&lt;em&gt;시작&lt;/em&gt; 과 &lt;em&gt;끝&lt;/em&gt; 을 사용하여 범위를 지정 하더라도 비트 위치는 항상 비트 0부터 시작하는 절대 값으로 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="d47127e4277fb6af8f1ec3e041d7aadf84ff3fe6" translate="yes" xml:space="preserve">
          <source>Note that calling &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt;/&lt;a href=&quot;pexpire&quot;&gt;PEXPIRE&lt;/a&gt; with a non-positive timeout or &lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt;/&lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt; with a time in the past will result in the key being &lt;a href=&quot;del&quot;&gt;deleted&lt;/a&gt; rather than expired (accordingly, the emitted &lt;a href=&quot;https://redis.io/topics/notifications&quot;&gt;key event&lt;/a&gt; will be &lt;code&gt;del&lt;/code&gt;, not &lt;code&gt;expired&lt;/code&gt;).</source>
          <target state="translated">참고 전화가 &lt;a href=&quot;expire&quot;&gt;EXPIRE&lt;/a&gt; / &lt;a href=&quot;pexpire&quot;&gt;PEXPIRE&lt;/a&gt; 이 아닌 긍정적 인 타임 아웃이나와 &lt;a href=&quot;expireat&quot;&gt;EXPIREAT&lt;/a&gt; / &lt;a href=&quot;pexpireat&quot;&gt;PEXPIREAT&lt;/a&gt; 키 존재가 발생합니다 과거의 시간이 &lt;a href=&quot;del&quot;&gt;삭제&lt;/a&gt; (따라서, 방출 만료보다는 &lt;a href=&quot;https://redis.io/topics/notifications&quot;&gt;키 이벤트가&lt;/a&gt; 될 것 &lt;code&gt;del&lt;/code&gt; 하지 &lt;code&gt;expired&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="134cdffcc8cc8242a1731baa707e6b6f212bd203" translate="yes" xml:space="preserve">
          <source>Note that each &lt;code&gt;OVERFLOW&lt;/code&gt; statement only affects the &lt;a href=&quot;incrby&quot;&gt;INCRBY&lt;/a&gt; commands that follow it in the list of subcommands, up to the next &lt;code&gt;OVERFLOW&lt;/code&gt; statement.</source>
          <target state="translated">각 &lt;code&gt;OVERFLOW&lt;/code&gt; 문 은 다음 &lt;code&gt;OVERFLOW&lt;/code&gt; 문 까지 하위 명령 목록 &lt;a href=&quot;incrby&quot;&gt;에서이&lt;/a&gt; 명령을 따르는 INCRBY 명령 에만 영향을 미칩니다 .</target>
        </trans-unit>
        <trans-unit id="c59e6cb007a017cde6a0590f3fe3a6903d02fdbc" translate="yes" xml:space="preserve">
          <source>Note that for correctly implementing this pattern it is important to avoid multiple clients rebuilding the cache at the same time. Some kind of locking is needed here (for instance using &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;).</source>
          <target state="translated">이 패턴을 올바르게 구현하려면 여러 클라이언트가 동시에 캐시를 다시 작성하지 않도록하는 것이 중요합니다. 여기서는 일종의 잠금이 필요합니다 (예 : &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; 사용 ).</target>
        </trans-unit>
        <trans-unit id="ab5932614de576b14cea0fbf3d424f67389687d0" translate="yes" xml:space="preserve">
          <source>Note that for the same reason a Lua script or a &lt;code&gt;MULTI/EXEC&lt;/code&gt; block may push elements into a list and afterward &lt;strong&gt;delete the list&lt;/strong&gt;. In this case the blocked clients will not be served at all and will continue to be blocked as long as no data is present on the list after the execution of a single command, transaction, or script.</source>
          <target state="translated">같은 이유로 Lua 스크립트 또는 &lt;code&gt;MULTI/EXEC&lt;/code&gt; 블록이 요소를 목록으로 푸시 한 다음 목록을 &lt;strong&gt;삭제할 수&lt;/strong&gt; 있습니다. 이 경우 차단 된 클라이언트는 전혀 제공되지 않으며 단일 명령, 트랜잭션 또는 스크립트를 실행 한 후 목록에 데이터가없는 한 계속 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="fcc828a00ba6196c133772751828406df7944657" translate="yes" xml:space="preserve">
          <source>Note that if a replica is added, moved, or removed from a given master node, and we ask &lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS&lt;/a&gt; to a node that has not yet received the configuration update, it may show stale information. However eventually (in a matter of seconds if there are no network partitions) all the nodes will agree about the set of nodes associated with a given master.</source>
          <target state="translated">지정된 마스터 노드에서 복제본을 추가, 이동 또는 제거하고 아직 구성 업데이트를받지 않은 노드에 &lt;a href=&quot;cluster-replicas&quot;&gt;CLUSTER REPLICAS&lt;/a&gt; 를 요청 하면 오래된 정보가 표시 될 수 있습니다. 그러나 결국 (네트워크 파티션이 없으면 몇 초 만에) 모든 노드는 주어진 마스터와 관련된 노드 세트에 동의합니다.</target>
        </trans-unit>
        <trans-unit id="21094e1f69e7fc1828b555fe35532f052b5ac245" translate="yes" xml:space="preserve">
          <source>Note that if a replica is added, moved, or removed from a given master node, and we ask &lt;a href=&quot;cluster-slaves&quot;&gt;CLUSTER SLAVES&lt;/a&gt; to a node that has not yet received the configuration update, it may show stale information. However eventually (in a matter of seconds if there are no network partitions) all the nodes will agree about the set of nodes associated with a given master.</source>
          <target state="translated">지정된 마스터 노드에서 복제본을 추가, 이동 또는 제거하고 아직 구성 업데이트를받지 않은 노드에 &lt;a href=&quot;cluster-slaves&quot;&gt;CLUSTER SLAVES&lt;/a&gt; 를 요청 하면 오래된 정보가 표시 될 수 있습니다. 그러나 결국 (네트워크 파티션이 없으면 몇 초 만에) 모든 노드는 주어진 마스터와 관련된 노드 세트에 동의합니다.</target>
        </trans-unit>
        <trans-unit id="92bc3cdf3318fb930ded8c852b6a00267accad1a" translate="yes" xml:space="preserve">
          <source>Note that if you have a list of numbers from 0 to 100, &lt;code&gt;LRANGE list 0 10&lt;/code&gt; will return 11 elements, that is, the rightmost item is included. This &lt;strong&gt;may or may not&lt;/strong&gt; be consistent with behavior of range-related functions in your programming language of choice (think Ruby's &lt;code&gt;Range.new&lt;/code&gt;, &lt;code&gt;Array#slice&lt;/code&gt; or Python's &lt;code&gt;range()&lt;/code&gt; function).</source>
          <target state="translated">0에서 100까지의 숫자 목록이있는 경우 &lt;code&gt;LRANGE list 0 10&lt;/code&gt; 은 11 개의 요소를 반환합니다. 즉, 가장 오른쪽 항목이 포함됩니다. 이것은 선택한 프로그래밍 언어에서 범위 관련 함수의 동작과 일치 &lt;strong&gt;하거나&lt;/strong&gt; 일치 &lt;strong&gt;하지 않을&lt;/strong&gt; 수 있습니다 (Ruby 's &lt;code&gt;Range.new&lt;/code&gt; , &lt;code&gt;Array#slice&lt;/code&gt; 또는 Python 's &lt;code&gt;range()&lt;/code&gt; 함수).</target>
        </trans-unit>
        <trans-unit id="b145f3c9b171e7c40ecd23d7161660cea0ebde1c" translate="yes" xml:space="preserve">
          <source>Note that it is valid to call this command without channels. In this case it will just return an empty list.</source>
          <target state="translated">채널없이이 명령을 호출하는 것이 유효합니다. 이 경우 빈 목록 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7cbc0087feeeb4b8394154849c8ec33aeb518c13" translate="yes" xml:space="preserve">
          <source>Note that non-existing keys are treated like empty lists, so when &lt;code&gt;key&lt;/code&gt; does not exist, the command will always return &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">존재하지 않는 &lt;code&gt;key&lt;/code&gt; 는 빈 목록처럼 취급되므로 키 가 존재하지 않으면 명령은 항상 &lt;code&gt;0&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e83de8fca6610aa183e7aad22115791cd55bc9fb" translate="yes" xml:space="preserve">
          <source>Note that normally clients willing to fetch the map between Cluster hash slots and node addresses should use &lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt; instead. &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt;, that provides more information, should be used for administrative tasks, debugging, and configuration inspections. It is also used by &lt;code&gt;redis-trib&lt;/code&gt; in order to manage a cluster.</source>
          <target state="translated">일반적으로 클러스터 해시 슬롯과 노드 주소간에 맵을 가져 오려는 클라이언트는 대신 &lt;a href=&quot;cluster-slots&quot;&gt;CLUSTER SLOTS&lt;/a&gt; 를 사용해야 합니다. 자세한 정보를 제공하는 &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; 는 관리 작업, 디버깅 및 구성 검사에 사용해야합니다. 클러스터를 관리하기 위해 &lt;code&gt;redis-trib&lt;/code&gt; 에서도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1f6b2fdffdf326f5f641aa170f10beb1a26d5924" translate="yes" xml:space="preserve">
          <source>Note that once a node assigns a set of slots to itself, it will start propagating this information in heartbeat packet headers. However the other nodes will accept the information only if they have the slot as not already bound with another node, or if the configuration epoch of the node advertising the new hash slot, is greater than the node currently listed in the table.</source>
          <target state="translated">노드가 자신에게 슬롯 세트를 할당하면이 정보를 하트 비트 패킷 헤더에 전파하기 시작합니다. 그러나 다른 노드는 아직 다른 노드와 바인드되지 않은 슬롯이 있거나 새 해시 슬롯을 알리는 노드의 구성 에포크가 현재 표에 나열된 노드보다 큰 경우에만 정보를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="34efcb15ecc544550f9bd4f238eeb1c37bfe6eb5" translate="yes" xml:space="preserve">
          <source>Note that the command implements the full hashing algorithm, including support for &lt;strong&gt;hash tags&lt;/strong&gt;, that is the special property of Redis Cluster key hashing algorithm, of hashing just what is between &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; if such a pattern is found inside the key name, in order to force multiple keys to be handled by the same node.</source>
          <target state="translated">이 명령은 &lt;strong&gt;해시 태그&lt;/strong&gt; 지원을 포함하여 Redis Cluster 키 해싱 알고리즘의 특수 속성 인 &lt;strong&gt;해시 태그&lt;/strong&gt; 지원을 포함하여 전체 해싱 알고리즘을 구현합니다. 이러한 패턴이 키 이름 내에 순서대로 발견되면 &lt;code&gt;{&lt;/code&gt; 와 &lt;code&gt;}&lt;/code&gt; 사이에있는 해싱입니다. 동일한 노드가 여러 키를 처리하도록합니다.</target>
        </trans-unit>
        <trans-unit id="44319adff6c7cf60df65ef2f592ee1b07d9db575" translate="yes" xml:space="preserve">
          <source>Note that the format does not have any space, so &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; output format is plain CSV with space as separator even when this special slots are emitted. However a complete parser for the format should be able to handle them.</source>
          <target state="translated">형식에 공백이 없으므로 &lt;a href=&quot;cluster-nodes&quot;&gt;CLUSTER NODES&lt;/a&gt; 출력 형식은이 특수 슬롯이 방출 되더라도 공백으로 구분 기호가있는 일반 CSV입니다. 그러나 형식에 대한 완전한 파서는 형식을 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="277c523b6a84e71c0289aa21eae881f107096f52" translate="yes" xml:space="preserve">
          <source>Note that the indexes are still reported in the &quot;natural&quot; way, that is, considering the first element starting from the head of the list at index 0, the next element at index 1, and so forth. This basically means that the returned indexes are stable whatever the rank is positive or negative.</source>
          <target state="translated">인덱스는 여전히 &quot;자연스러운&quot;방식으로보고됩니다. 즉, 인덱스 0의 목록 헤드에서 시작하는 첫 번째 요소, 인덱스 1의 다음 요소 등을 고려합니다. 이는 기본적으로 순위가 양수이든 음수이든 반환 된 인덱스가 안정적이라는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6cf3d39f27c1b799248d5e59a73b1a5b0f086afd" translate="yes" xml:space="preserve">
          <source>Note that the maximum offset that you can set is 2&lt;sup&gt;29&lt;/sup&gt; -1 (536870911), as Redis Strings are limited to 512 megabytes. If you need to grow beyond this size, you can use multiple keys.</source>
          <target state="translated">Redis 문자열이 512MB로 제한되므로 설정할 수있는 최대 오프셋은 2 &lt;sup&gt;29&lt;/sup&gt; -1 (536870911)입니다. 이 크기 이상으로 확장해야하는 경우 여러 키를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="365b9132d09f3318597589e9536ca42a38461cb4" translate="yes" xml:space="preserve">
          <source>Note that the message is claimed only if its idle time is greater the minimum idle time we specify when calling &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt;. Because as a side effect &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; will also reset the idle time (since this is a new attempt at processing the message), two consumers trying to claim a message at the same time will never both succeed: only one will successfully claim the message. This avoids that we process a given message multiple times in a trivial way (yet multiple processing is possible and unavoidable in the general case).</source>
          <target state="translated">유휴 시간이 &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; 호출시 지정하는 최소 유휴 시간보다 큰 경우에만 메시지가 청구됩니다 . 부작용으로 &lt;a href=&quot;xclaim&quot;&gt;XCLAIM&lt;/a&gt; 은 유휴 시간도 재설정하기 때문에 (메시지를 처리하려는 새로운 시도이기 때문에) 동시에 메시지를 청구하려고하는 두 명의 소비자는 둘 다 성공하지 못합니다. 한 사람 만이 메시지를 성공적으로 청구합니다. 이것은 우리가 주어진 메시지를 사소한 방식으로 여러 번 처리하는 것을 피합니다 (그러나 일반적인 경우에는 다중 처리가 가능하고 피할 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="dbbe3c8e1b4fe3c7e220f023943635e1ebf82c17" translate="yes" xml:space="preserve">
          <source>Note that this algorithm runs in &lt;code&gt;O(N*M)&lt;/code&gt; time, where N is the length of the first string and M is the length of the second string. So either spin a different Redis instance in order to run this algorithm, or make sure to run it against very small strings.</source>
          <target state="translated">이 알고리즘은 &lt;code&gt;O(N*M)&lt;/code&gt; 시간에 실행됩니다 . 여기서 N은 첫 번째 문자열의 길이이고 M은 두 번째 문자열의 길이입니다. 따라서이 알고리즘을 실행하기 위해 다른 Redis 인스턴스를 회전하거나 매우 작은 문자열에 대해 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="900544e94991ba5defea5df80a0dccc1aa474e00" translate="yes" xml:space="preserve">
          <source>Note that this command is not suitable when you need a guaranteed uniform distribution of the returned elements. For more information about the algorithms used for &lt;a href=&quot;spop&quot;&gt;SPOP&lt;/a&gt;, look up both the Knuth sampling and Floyd sampling algorithms.</source>
          <target state="translated">이 명령은 반환 된 요소의 균일 한 분포를 보장해야하는 경우에는 적합하지 않습니다. &lt;a href=&quot;spop&quot;&gt;SPOP에&lt;/a&gt; 사용되는 알고리즘에 대한 자세한 내용은 Knuth 샘플링 및 Floyd 샘플링 알고리즘을 모두 찾아보십시오.</target>
        </trans-unit>
        <trans-unit id="581b6da11286a19b84f5dbf7d26c9c4e1e18433c" translate="yes" xml:space="preserve">
          <source>Note that this command is not suitable when you need a guaranteed uniform distribution of the returned elements. For more information about the algorithms used for SPOP, look up both the Knuth sampling and Floyd sampling algorithms.</source>
          <target state="translated">반환 된 요소의 균일 한 분포를 보장해야하는 경우이 명령이 적합하지 않습니다. SPOP에 사용되는 알고리즘에 대한 자세한 내용은 Knuth 샘플링 및 Floyd 샘플링 알고리즘을 모두 찾아보십시오.</target>
        </trans-unit>
        <trans-unit id="7aae41763fe9b0bc6731024cb063283c77ec4608" translate="yes" xml:space="preserve">
          <source>Note that this implementation of workers is trivially scalable and reliable, because even if a message is lost the item is still in the queue and will be processed at the next iteration.</source>
          <target state="translated">이러한 작업자 구현은 메시지가 손실 되더라도 항목이 여전히 대기열에 있고 다음 반복에서 처리되기 때문에 간단하고 확장 가능합니다.</target>
        </trans-unit>
        <trans-unit id="de6800f82ca82bf510c822b7935a67d6ca2bf21c" translate="yes" xml:space="preserve">
          <source>Note that we have a race here, but it is not a problem: &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; may return false but the key may be created by another client before we create it inside the &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; block. However this race will just miss an API call under rare conditions, so the rate limiting will still work correctly.</source>
          <target state="translated">여기에는 경쟁이 있지만 문제는 아닙니다. &lt;a href=&quot;exists&quot;&gt;EXISTS&lt;/a&gt; 는 false를 반환 할 수 있지만 &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; / &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; 블록 내에 키를 만들기 전에 다른 클라이언트가 키를 만들 수 있습니다 . 그러나이 경쟁에서는 드문 조건에서 API 호출이 누락되므로 속도 제한이 여전히 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="290162572eb7adbad822a4117dca945c127babde" translate="yes" xml:space="preserve">
          <source>Note that you need a recent version of redis-cli in order to read the slow log output, since it uses some features of the protocol that were not formerly implemented in redis-cli (deeply nested multi bulk replies).</source>
          <target state="translated">느린 로그 출력을 읽으려면 최신 버전의 redis-cli가 필요합니다. 이는 이전에 redis-cli에서 구현되지 않은 프로토콜의 일부 기능 (깊게 중첩 된 다중 벌크 응답)을 사용하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="285f98e8d01e4962eff6724b78a3c6724d0931e6" translate="yes" xml:space="preserve">
          <source>Note that:</source>
          <target state="translated">참고 :</target>
        </trans-unit>
        <trans-unit id="851be398fabf2219f9c3aa64609a72f0559cc785" translate="yes" xml:space="preserve">
          <source>Note the used of &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; and &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; in order to make sure that we'll both increment and set the expire at every API call.</source>
          <target state="translated">모든 API 호출에서 만료를 설정하고 증가시킬 수 있도록 &lt;a href=&quot;multi&quot;&gt;MULTI&lt;/a&gt; 및 &lt;a href=&quot;exec&quot;&gt;EXEC&lt;/a&gt; 사용에 유의 하십시오.</target>
        </trans-unit>
        <trans-unit id="0ab5850865b49bbe39f155ec6e364488933508f0" translate="yes" xml:space="preserve">
          <source>Note this rule is not enforced in order to provide the user with opportunities to abuse the Redis single instance configuration, at the cost of writing scripts not compatible with Redis Cluster.</source>
          <target state="translated">이 규칙은 Redis 클러스터와 호환되지 않는 스크립트를 작성하는 비용으로 사용자에게 Redis 단일 인스턴스 구성을 악용 할 수있는 기회를 제공하기 위해 시행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9dfbcfbbaf119bccc3c44b098de0573996677b97" translate="yes" xml:space="preserve">
          <source>Note: A Redis instance that is configured for not persisting on disk (no AOF configured, nor &quot;save&quot; directive) will not dump the RDB file on &lt;a href=&quot;shutdown&quot;&gt;SHUTDOWN&lt;/a&gt;, as usually you don't want Redis instances used only for caching to block on when shutting down.</source>
          <target state="translated">참고 : 디스크에 유지되지 않도록 구성된 Redis 인스턴스 (AOF 구성 없음 또는 &quot;save&quot;지시문 없음)는 &lt;a href=&quot;shutdown&quot;&gt;SHUTDOWN에&lt;/a&gt; RDB 파일을 덤프 하지 않습니다. 일반적으로 캐싱에만 사용되는 Redis 인스턴스가 차단 될 때 원하지 않습니다 종료.</target>
        </trans-unit>
        <trans-unit id="4ffe4a3dcb4982dba6203770d54b7b49b3ebdb4a" translate="yes" xml:space="preserve">
          <source>Note: Since the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command options can replace &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;, &lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt;, &lt;a href=&quot;getset&quot;&gt;GETSET&lt;/a&gt;, it is possible that in future versions of Redis these three commands will be deprecated and finally removed.</source>
          <target state="translated">참고 : &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 명령 옵션은 &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; , &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt; , &lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt; , &lt;a href=&quot;getset&quot;&gt;GETSET을&lt;/a&gt; 대체 할 수 있으므로 Redis의 향후 버전에서는이 세 명령이 더 이상 사용되지 않고 최종적으로 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40e3fa9c72775db4fd05d5cf7a3a493e93afca05" translate="yes" xml:space="preserve">
          <source>Note: Since the &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; command options can replace &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt;, &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt;, &lt;a href=&quot;psetex&quot;&gt;PSETEX&lt;/a&gt;, it is possible that in future versions of Redis these three commands will be deprecated and finally removed.</source>
          <target state="translated">참고 : &lt;a href=&quot;set&quot;&gt;SET&lt;/a&gt; 명령 옵션은 &lt;a href=&quot;setnx&quot;&gt;SETNX&lt;/a&gt; , &lt;a href=&quot;setex&quot;&gt;SETEX&lt;/a&gt; , &lt;a href=&quot;psetex&quot;&gt;PSETEX를&lt;/a&gt; 대체 할 수 있으므로 이후 버전의 Redis에서는이 세 명령이 더 이상 사용되지 않고 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81129f6603906deb00ee7e872ec230ada40b4ee1" translate="yes" xml:space="preserve">
          <source>Note: The &lt;strong&gt;GT&lt;/strong&gt;, &lt;strong&gt;LT&lt;/strong&gt; and &lt;strong&gt;NX&lt;/strong&gt; options are mutually exclusive.</source>
          <target state="translated">참고 : &lt;strong&gt;GT&lt;/strong&gt; , &lt;strong&gt;LT&lt;/strong&gt; 및 &lt;strong&gt;NX&lt;/strong&gt; 옵션은 상호 배타적입니다.</target>
        </trans-unit>
        <trans-unit id="3d6762a6aa2cf0aca37a59f773d7789ef284a403" translate="yes" xml:space="preserve">
          <source>Note: an important part of this behavior is that the PRNG that Redis implements as &lt;code&gt;math.random&lt;/code&gt; and &lt;code&gt;math.randomseed&lt;/code&gt; is guaranteed to have the same output regardless of the architecture of the system running Redis. 32-bit, 64-bit, big-endian and little-endian systems will all produce the same output.</source>
          <target state="translated">참고 :이 동작의 중요한 부분은 Redis가 &lt;code&gt;math.random&lt;/code&gt; 및 &lt;code&gt;math.randomseed&lt;/code&gt; 로 구현하는 PRNG가 Redis를 실행 하는 시스템의 아키텍처와 상관없이 동일한 출력을 보장한다는 것입니다. 32 비트, 64 비트, 빅 엔디안 및 리틀 엔디안 시스템은 모두 동일한 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="19d14832252be8ae1106f6c63fb642cd3e9e2df4" translate="yes" xml:space="preserve">
          <source>Note: as a side effect of calling this function, it is possible that the HyperLogLog is modified, since the last 8 bytes encode the latest computed cardinality for caching purposes. So &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; is technically a write command.</source>
          <target state="translated">참고 :이 함수 호출의 부작용으로, 마지막 8 바이트가 캐싱 목적으로 최신 계산 된 카디널리티를 인코딩하므로 HyperLogLog가 수정 될 수 있습니다. 따라서 &lt;a href=&quot;pfcount&quot;&gt;PFCOUNT&lt;/a&gt; 는 기술적으로 쓰기 명령입니다.</target>
        </trans-unit>
        <trans-unit id="ca716680732d1d3e7b5dc5d38bf23aaa2688e964" translate="yes" xml:space="preserve">
          <source>Note: as you can see Lua arrays are returned as Redis multi bulk replies, that is a Redis return type that your client library will likely convert into an Array type in your programming language.</source>
          <target state="translated">참고 : Lua 배열은 Redis 다중 벌크 응답으로 반환되며 클라이언트 라이브러리가 프로그래밍 언어에서 배열 유형으로 변환 될 수있는 Redis 반환 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a094e9a0339a167054eac3028e87a3e324531dab" translate="yes" xml:space="preserve">
          <source>Note: of course as usually it is not guaranteed that the error text remains the same, however the error code will remain &lt;code&gt;-UNBLOCKED&lt;/code&gt;.</source>
          <target state="translated">참고 : 물론 일반적으로 오류 텍스트가 동일하게 유지되는 &lt;code&gt;-UNBLOCKED&lt;/code&gt; 오류 코드는 -UNBLOCKED로 유지 됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ba013a44d25a035abd0e8ad87d8b610e34b72b2" translate="yes" xml:space="preserve">
          <source>Note: the command has a complexity of just O(log(N)) because it uses elements ranks (see &lt;a href=&quot;zrank&quot;&gt;ZRANK&lt;/a&gt;) to get an idea of the range. Because of this there is no need to do a work proportional to the size of the range.</source>
          <target state="translated">참고 :이 명령은 요소 순위 ( &lt;a href=&quot;zrank&quot;&gt;ZRANK&lt;/a&gt; 참조 )를 사용하여 범위에 대한 아이디어를 얻으 므로 O (log (N))의 복잡성을 갖습니다 . 이 때문에 범위의 크기에 비례하는 작업을 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4cf334aa22d4d43d68ebc7afbb42dd9e08a0e09" translate="yes" xml:space="preserve">
          <source>Note: we use the &lt;strong&gt;COUNT&lt;/strong&gt; option in the example, so that for each stream the call will return at maximum two elements per stream.</source>
          <target state="translated">참고 : 이 예에서는 &lt;strong&gt;COUNT&lt;/strong&gt; 옵션을 사용 하므로 각 스트림마다 호출이 스트림 당 최대 2 개의 요소를 반환합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
